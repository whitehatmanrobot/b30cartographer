k;
        default:
            DPF ("unknown / illegal alpha argument '%d' in SelectAlphaInput",
                 pContext->tssState[dwD3DStage].dwValue[dwD3DTSSArg] & D3DTA_SELECTMASK);
            dbgD3DError();
            pContext->hwState.dwStateFlags |= CELSIUS_FLAG_SETUPFAILURE;
            break;
    }

    // now handle the alpha replicate and complement flags

    if (((pContext->tssState[dwD3DStage].dwValue[dwD3DTSSArg] & D3DTA_SELECTMASK) == D3DTA_CURRENT) &&
         (dwCombinerStage != 0) &&
         (pContext->hwState.dwStateFlags & CELSIUS_FLAG_DOTPRODUCT3(dwCombinerStage - 1))) {
        // if the last stage produced a dot product, we were supposed to have replicated the result
        // into alpha, but couldn't b/c celsius can't. get it from the color channels now.
        dwICW |= DRF_DEF(056, _SET_COMBINER_ALPHA, _ICW_D_ALPHA, _FALSE);
    }
    else {
        // just get alpha from alpha
        dwICW |= DRF_DEF(056, _SET_COMBINER_ALPHA, _ICW_D_ALPHA, _TRUE);
    }

    bComplement = ((pContext->tssState[dwD3DStage].dwValue[dwD3DTSSArg] & D3DTA_COMPLEMENT) ^
                   ((bComplement) ? D3DTA_COMPLEMENT : 0))
                  ?
                  TRUE : FALSE;

    if (bExpandNormal) {
        dwICW |= bComplement ? DRF_DEF(056, _SET_COMBINER_ALPHA, _ICW_D_MAP, _EXPAND_NEGATE) :
                               DRF_DEF(056, _SET_COMBINER_ALPHA, _ICW_D_MAP, _EXPAND_NORMAL);
    }
    else {
        dwICW |= bComplement ? DRF_DEF(056, _SET_COMBINER_ALPHA, _ICW_D_MAP, _UNSIGNED_INVERT) :
                               DRF_DEF(056, _SET_COMBINER_ALPHA, _ICW_D_MAP, _UNSIGNED_IDENTITY);
    }

    pContext->hwState.dwAlphaICW[dwCombinerStage] |= (dwICW << celsiusCombinerInputShift[eInput]);
    return (0);
}

//---------------------------------------------------------------------------

// Select the input into A
static HRESULT combineselect1 (PNVD3DCONTEXT pContext, int hdStage, int dxStage)
{
    HRESULT hr;

    // Make A input
    hr = SelectAlphaInput (pContext, celsiusCombinerInputA, hdStage, dxStage, D3DTSS_ALPHAARG1, FALSE, FALSE);
    // Make B 1
    SetAlphaInputOne (pContext, celsiusCombinerInputB, hdStage, FALSE);
    // C & D default to zero

    return (hr);
}

//---------------------------------------------------------------------------

// Select the input into D
static HRESULT combineselect2 (PNVD3DCONTEXT pContext, int hdStage, int dxStage)
{
    HRESULT hr;

    // Multiply D * 1
    SetAlphaInputOne (pContext, celsiusCombinerInputC, hdStage, FALSE);
    hr = SelectAlphaInput (pContext, celsiusCombinerInputD, hdStage, dxStage, D3DTSS_ALPHAARG2, FALSE, FALSE);
    // A & B default to zero

    return (hr);
}

//---------------------------------------------------------------------------

static HRESULT combinemodulate (PNVD3DCONTEXT pContext, int hdStage, int dxStage)
{
    HRESULT hr;

    // Multiply A * B
    hr  = SelectAlphaInput (pContext, celsiusCombinerInputA, hdStage, dxStage, D3DTSS_ALPHAARG1, FALSE, FALSE);
    hr |= SelectAlphaInput (pContext, celsiusCombinerInputB, hdStage, dxStage, D3DTSS_ALPHAARG2, FALSE, FALSE);
    // C & D default to zero

    return (hr);
}

//---------------------------------------------------------------------------

static HRESULT combineadd (PNVD3DCONTEXT pContext, int hdStage, int dxStage)
{
    HRESULT hr;

    // Multiply A * 1
    hr = SelectAlphaInput (pContext, celsiusCombinerInputA, hdStage, dxStage, D3DTSS_ALPHAARG1, FALSE, FALSE);
    // Make B 1
    SetAlphaInputOne (pContext, celsiusCombinerInputB, hdStage, FALSE);
    // Multiply D * 1
    SetAlphaInputOne (pContext, celsiusCombinerInputC, hdStage, FALSE);
    hr |= SelectAlphaInput (pContext, celsiusCombinerInputD, hdStage, dxStage, D3DTSS_ALPHAARG2, FALSE, FALSE);
    // Implicit A + D

    return (hr);
}

//---------------------------------------------------------------------------

static HRESULT combinesub (PNVD3DCONTEXT pContext, int hdStage, int dxStage)
{
    HRESULT hr;

    // Multiply A * 1
    hr = SelectAlphaInput (pContext, celsiusCombinerInputA, hdStage, dxStage, D3DTSS_ALPHAARG1, FALSE, FALSE);
    SetAlphaInputOne (pContext, celsiusCombinerInputB, hdStage, FALSE);
    // Multiply D * -1
    SetAlphaInputOne (pContext, celsiusCombinerInputC, hdStage, TRUE);
    hr |= SelectAlphaInput (pContext, celsiusCombinerInputD, hdStage, dxStage, D3DTSS_ALPHAARG2, FALSE, FALSE);
    // Implicit A + -D

    return (hr);
}

//---------------------------------------------------------------------------

static HRESULT combineaddsmooth (PNVD3DCONTEXT pContext,int hdStage, int dxStage)
{
    HRESULT hr;

    // Multiply A * 1
    hr = SelectAlphaInput (pContext, celsiusCombinerInputA, hdStage, dxStage, D3DTSS_ALPHAARG1, FALSE, FALSE);
    SetAlphaInputOne (pContext, celsiusCombinerInputB, hdStage, FALSE);
    // Make C: (1-arg1), make D: arg2
    hr |= SelectAlphaInput (pContext, celsiusCombinerInputC, hdStage, dxStage, D3DTSS_ALPHAARG1, TRUE, FALSE);
    hr |= SelectAlphaInput (pContext, celsiusCombinerInputD, hdStage, dxStage, D3DTSS_ALPHAARG2, FALSE, FALSE);

    return (hr);
}

//---------------------------------------------------------------------------

static HRESULT combineblendalpha (PNVD3DCONTEXT pContext, int hdStage, int dxStage, int type)
{
    HRESULT hr;
    int temp;

    // Multiply A * B(alpha)
    hr = SelectAlphaInput (pContext, celsiusCombinerInputA, hdStage, dxStage, D3DTSS_ALPHAARG1, FALSE, FALSE);

    if (type == TEXTUREPM) { // this type defined by us
        // Make B 1 since texture is already pre-multiplied
        SetAlphaInputOne (pContext, celsiusCombinerInputB, hdStage, FALSE);
        // set type again for making C (1-alpha) below
        type = D3DTA_TEXTURE;
    }
    else {
        // Make B alpha, appropriate type
        temp = pContext->tssState[dxStage].dwValue[D3DTSS_ALPHAARG2];
        pContext->tssState[dxStage].dwValue[D3DTSS_ALPHAARG2] = type;
        hr |= SelectAlphaInput (pContext, celsiusCombinerInputB, hdStage, dxStage, D3DTSS_ALPHAARG2, FALSE, FALSE);
        // copy arg2 back
        pContext->tssState[dxStage].dwValue[D3DTSS_ALPHAARG2] = temp;
    }

    // Make C: 1-alpha, make D: arg2
    temp = pContext->tssState[dxStage].dwValue[D3DTSS_ALPHAARG1];
    pContext->tssState[dxStage].dwValue[D3DTSS_ALPHAARG1] = type;
    hr |= SelectAlphaInput (pContext, celsiusCombinerInputC, hdStage, dxStage, D3DTSS_ALPHAARG1, TRUE, FALSE);
    // copy back to alphaarg1
    pContext->tssState[dxStage].dwValue[D3DTSS_ALPHAARG1] = temp;
    hr |= SelectAlphaInput (pContext, celsiusCombinerInputD, hdStage, dxStage, D3DTSS_ALPHAARG2, FALSE, FALSE);

    return (hr);
}

//---------------------------------------------------------------------------

// The way D3D does this, it essentially allows using texture from stage 1
// in stage1 twice.  D3D does not normally allow you to use a texture in
// stage 0 and stage1.  This way, D3D allows you to modulate in (effectively)
// stage 0 and then do whatever it is you are going to do in stage1.  The
// key is that we use the texture from stage1 (since there is really no texture
// in stage 0)
static HRESULT combinepremodulate (PNVD3DCONTEXT pContext,int hdStage, int dxStage)
{
    HRESULT hr;
    int temp, premodulate = 1;

    DPF ("pre-modulation is totally broken right now");
    dbgD3DError();

    if (dxStage == 0) {
        if(pContext->tssState[dxStage+1].dwValue[D3DTSS_ALPHAOP] != D3DTOP_DISABLE){
            // make A: alphaArg1(0), make B: texture(1)
             hr = SelectAlphaInput (pContext, celsiusCombinerInputA, hdStage, dxStage, D3DTSS_ALPHAARG1, FALSE, FALSE);
             temp = pContext->tssState[dxStage].dwValue[D3DTSS_ALPHAARG2];
             pContext->tssState[dxStage].dwValue[D3DTSS_ALPHAARG2] = D3DTA_TEXTURE;
             hr |= SelectAlphaInput (pContext, celsiusCombinerInputB, hdStage, dxStage, D3DTSS_ALPHAARG2, FALSE, FALSE);
             // copy back arg2
             pContext->tssState[dxStage].dwValue[D3DTSS_ALPHAARG2] = temp;
        }
        else{
            //asked to do premodulate on a single texture stage -- just pass down
            //the colorarg1
            hr = SelectAlphaInput (pContext, celsiusCombinerInputA, hdStage, dxStage, D3DTSS_ALPHAARG1, FALSE, FALSE);
            SetAlphaInputOne (pContext, celsiusCombinerInputB, hdStage, FALSE);
        }

    }
    else { // well, right now we only handle two stages (we could compress these)
        // if pre-modulate is called in stage1, we could modulate with
        // texture from next stage. But, we'd have to handle settexture a bit
        // differently. For now, we'll just use selectarg1
        hr = SelectAlphaInput (pContext, celsiusCombinerInputA, hdStage, dxStage, D3DTSS_ALPHAARG1, FALSE, FALSE);
        SetAlphaInputOne (pContext, celsiusCombinerInputB, hdStage, FALSE);
    }

    return (hr);
}
//---------------------------------------------------------------------------

static HRESULT combinemultiplyadd (PNVD3DCONTEXT pContext, int hdStage, int dxStage)
{
    HRESULT hr;

    // set A to arg1
    hr  = SelectAlphaInput (pContext, celsiusCombinerInputA, hdStage, dxStage, D3DTSS_ALPHAARG0, FALSE, FALSE);
    //set B to 1
    SetAlphaInputOne (pContext, celsiusCombinerInputB, hdStage, FALSE);
    // set C to arg2
    hr |= SelectAlphaInput (pContext, celsiusCombinerInputC, hdStage, dxStage, D3DTSS_ALPHAARG1, FALSE, FALSE);
    //set D to arg3
    hr |= SelectAlphaInput (pContext, celsiusCombinerInputD, hdStage, dxStage, D3DTSS_ALPHAARG2, FALSE, FALSE);

    return (hr);
}

//---------------------------------------------------------------------------

static HRESULT combinelerp (PNVD3DCONTEXT pContext, int hdStage, int dxStage)
{
    HRESULT hr;

    // Multiply A * B
    hr  = SelectAlphaInput (pContext, celsiusCombinerInputA, hdStage, dxStage, D3DTSS_ALPHAARG0, FALSE, FALSE);
    hr |= SelectAlphaInput (pContext, celsiusCombinerInputB, hdStage, dxStage, D3DTSS_ALPHAARG1, FALSE, FALSE);
    //set C to 1 - arg1
    hr |= SelectAlphaInput (pContext, celsiusCombinerInputC, hdStage, dxStage, D3DTSS_ALPHAARG0, TRUE, FALSE);
    //set D to arg3
    hr |= SelectAlphaInput (pContext, celsiusCombinerInputD, hdStage, dxStage, D3DTSS_ALPHAARG2, FALSE, FALSE);

    return (hr);
}

//---------------------------------------------------------------------------

void ConstructOutputAlphaCombiners (PNVD3DCONTEXT pContext, BOOL enable, int stage, int bias, int shift, int outtemp)
{
    outtemp  &= (stage != 1);

    if (!enable) {
        pContext->hwState.dwAlphaOCW[stage] |= DRF_DEF(056, _SET_COMBINER_ALPHA, _OCW_SUM_DST, _REG_0);
        return;
    }

    // select bias operation
    if (shift == 0) {
        if (bias == 0)
            pContext->hwState.dwAlphaOCW[stage] |= DRF_DEF(056, _SET_COMBINER_ALPHA, _OCW_OPERATION, _NOSHIFT);
        else
            pContext->hwState.dwAlphaOCW[stage] |= DRF_DEF(056, _SET_COMBINER_ALPHA, _OCW_OPERATION, _NOSHIFT_BIAS);
    }
    else if (shift == 1) {
        if (bias == 0)
            pContext->hwState.dwAlphaOCW[stage] |= DRF_DEF(056, _SET_COMBINER_ALPHA, _OCW_OPERATION, _SHIFTLEFTBY1);
        else
            pContext->hwState.dwAlphaOCW[stage] |= DRF_DEF(056, _SET_COMBINER_ALPHA, _OCW_OPERATION, _SHIFTLEFTBY1_BIAS);
    }
    else if (shift == 2) {
        if (bias == 0)
            pContext->hwState.dwAlphaOCW[stage] |= DRF_DEF(056, _SET_COMBINER_ALPHA, _OCW_OPERATION, _SHIFTLEFTBY2);
        else
            // we can't shift by 2 and bias. do the best we can...
            pContext->hwState.dwAlphaOCW[stage] |= DRF_DEF(056, _SET_COMBINER_ALPHA, _OCW_OPERATION, _SHIFTLEFTBY1_BIAS);
    }
    pContext->hwState.dwAlphaOCW[stage] |= DRF_DEF(056, _SET_COMBINER_ALPHA, _OCW_MUX_ENABLE, _FALSE);
    if (outtemp)
        pContext->hwState.dwAlphaOCW[stage] |= DRF_DEF(056, _SET_COMBINER_ALPHA, _OCW_SUM_DST, _REG_D);
    else
        pContext->hwState.dwAlphaOCW[stage] |= DRF_DEF(056, _SET_COMBINER_ALPHA, _OCW_SUM_DST, _REG_C);
    pContext->hwState.dwAlphaOCW[stage] |= DRF_DEF(056, _SET_COMBINER_ALPHA, _OCW_AB_DST, _REG_0);
    pContext->hwState.dwAlphaOCW[stage] |= DRF_DEF(056, _SET_COMBINER_ALPHA, _OCW_CD_DST, _REG_0);
}

//---------------------------------------------------------------------------

void ConstructAlphaCombiners (PNVD3DCONTEXT pContext, int hdStage, int dxStage, BOOL bStageActive)
{
    int     bias, shift;
    BOOL    enable;
    HRESULT hr = 0;

    bias = 0;
    shift = 0;
    enable = TRUE;

    pContext->hwState.dwAlphaICW[hdStage] = 0;
    pContext->hwState.dwAlphaOCW[hdStage] = 0;

    if (!bStageActive) {
        // colorop was set to disable
        if (hdStage == 0) { // only construct default for stage 0
            // Default is diffuse alpha, make A=diffuse alpha, B=1, C=D=0
            pContext->hwState.dwAlphaICW[hdStage] |= DRF_DEF(056, _SET_COMBINER_ALPHA, _ICW_A_SOURCE, _REG_4);
            pContext->hwState.dwAlphaICW[hdStage] |= DRF_DEF(056, _SET_COMBINER_ALPHA, _ICW_A_ALPHA, _TRUE);
            SetAlphaInputOne (pContext, celsiusCombinerInputB, hdStage, FALSE);
        }
        else {
            enable = FALSE;
        }
    }

    else {

        switch (pContext->tssState[dxStage].dwValue[D3DTSS_ALPHAOP]) {
            default:
            case D3DTOP_DOTPRODUCT3:
                // We treat dot3 like disable because it doesn't really matter.
                // if the colorop is also dot3, then alpha will be overwritten momentarily anyhow.
                // BUGBUG if the colorop is NOT dot3, what the heck does this even mean???
            case D3DTOP_DISABLE:
                if (hdStage == 0) { // only construct default for stage 0
                    // Default is diffuse alpha, make A=diffuse alpha, B=1, C=D=0
                    pContext->hwState.dwAlphaICW[hdStage] |= DRF_DEF(056, _SET_COMBINER_ALPHA, _ICW_A_SOURCE, _REG_4);
                    pContext->hwState.dwAlphaICW[hdStage] |= DRF_DEF(056, _SET_COMBINER_ALPHA, _ICW_A_ALPHA, _TRUE);
                    SetAlphaInputOne (pContext, celsiusCombinerInputB, hdStage, FALSE);
                }
                else {
                    enable = FALSE;
                }
                break;
            case D3DTOP_SELECTARG1:
                hr = combineselect1 (pContext, hdStage, dxStage);
                break;
            case D3DTOP_SELECTARG2:
                hr = combineselect2 (pContext, hdStage, dxStage);
                break;
            case D3DTOP_MODULATE4X:
                shift++;
            case D3DTOP_MODULATE2X:
                shift++;
            case D3DTOP_MODULATE:
                hr = combinemodulate (pContext, hdStage, dxStage);
                break;
            case D3DTOP_ADDSIGNED2X: // same as addsigned with following change
                shift = 1;
            case D3DTOP_ADDSIGNED:   // same as add with following change
                bias = 1;
            case D3DTOP_ADD:
                hr = combineadd (pContext, hdStage, dxStage);
                break;
            case D3DTOP_SUBTRACT:
                hr = combinesub (pContext, hdStage, dxStage);
                break;
            case D3DTOP_ADDSMOOTH:
                hr = combineaddsmooth (pContext, hdStage, dxStage);
                break;
            case D3DTOP_BLENDDIFFUSEALPHA:
                hr = combineblendalpha (pContext, hdStage, dxStage, D3DTA_DIFFUSE);
                break;
            case D3DTOP_BLENDTEXTUREALPHA:
                hr = combineblendalpha (pContext, hdStage, dxStage, D3DTA_TEXTURE);
                break;
            case D3DTOP_BLENDFACTORALPHA:
                hr = combineblendalpha (pContext, hdStage, dxStage, D3DTA_TFACTOR);
                break;
            case D3DTOP_BLENDTEXTUREALPHAPM:
                hr = combineblendalpha (pContext,hdStage, dxStage, TEXTUREPM);
                break;
            case D3DTOP_BLENDCURRENTALPHA:
                hr = combineblendalpha (pContext, hdStage, dxStage, D3DTA_CURRENT);
                break;
            case D3DTOP_PREMODULATE:
                hr = combinepremodulate (pContext, hdStage, dxStage);
                break;
// BUGBUG
#if 0
            case D3DTOP_ALPHAMODULATE:
                // This is the case where the old D3DRENDERSTATE_TEXTUREMAPBLEND was used with
                // the D3DTBLEND_MODULATE op because the dump translates this into TSS we define
                // a new op that properly handles D3DTBLEND_MODULATE
                // Alpha is obtained by the texture, if it has alpha otherwise it is obtained from
                // the vertex. The dump always sets arg1 to be texture and arg2 to be current
                if (statev.ptexture[0] && statev.ptexture[0]->sd.ddpfPixelFormat.dwRGBAlphaBitMask) {
                    combineselect1(hdStage);
                }
                else {
                    combineselect2(hdStage);
                }
                break;
#endif
            case D3DTOP_MULTIPLYADD:
                hr = combinemultiplyadd (pContext, hdStage, dxStage);
                break;
            case D3DTOP_LERP:
                hr = combinelerp (pContext, hdStage, dxStage);
                break;
        }  // switch

    }

    if (hr == TSS_USES_NULL_TEXTURE) {
        // this stage references a non-existent texture. just set it back to "select current"
        if (hdStage == 0) {
            // current = diffuse in stage 0
            pContext->hwState.dwAlphaICW[hdStage] = DRF_DEF(056, _SET_COMBINER_ALPHA, _ICW_A_SOURCE, _REG_4) |
                                                    DRF_DEF(056, _SET_COMBINER_ALPHA, _ICW_A_ALPHA, _TRUE);
        }
        else {
            pContext->hwState.dwAlphaICW[hdStage]  = DRF_DEF(056, _SET_COMBINER_ALPHA, _ICW_A_SOURCE, _REG_C);
            pContext->hwState.dwAlphaICW[hdStage] |= (pContext->hwState.dwStateFlags & CELSIUS_FLAG_DOTPRODUCT3(0)) ?
                                                     DRF_DEF(056, _SET_COMBINER_ALPHA, _ICW_A_ALPHA, _FALSE) :
                                                     DRF_DEF(056, _SET_COMBINER_ALPHA, _ICW_A_ALPHA, _TRUE);
        }
        SetAlphaInputOne (pContext, celsiusCombinerInputB, hdStage, FALSE);
    }

    ConstructOutputAlphaCombiners (pContext, enable, hdStage, bias, shift,
                                  pContext->tssState[dxStage].dwValue[D3DTSS_RESULTARG] == D3DTA_TEMP);
}

#endif  // NVARCH == 0x10
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\ddraw\celsius\src\nvCelsiusCompileVS_link.cpp ===
// **************************************************************************
//
//       Copyright 1993-2000 NVIDIA, Corporation.  All rights reserved.
//
//     NOTICE TO USER:   The source code  is copyrighted under  U.S. and
//     international laws.  Users and possessors of this source code are
//     hereby granted a nonexclusive,  royalty-free copyright license to
//     use this code in individual and commercial software.
//
//     Any use of this source code must include,  in the user documenta-
//     tion and  internal comments to the code,  notices to the end user
//     as follows:
//
//     NVIDIA, CORPORATION MAKES NO REPRESENTATION ABOUT THE SUITABILITY
//     OF  THIS SOURCE  CODE  FOR ANY PURPOSE.  IT IS  PROVIDED  "AS IS"
//     WITHOUT EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORPOR-
//     ATION DISCLAIMS ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,
//     INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY, NONINFRINGE-
//     MENT,  AND FITNESS  FOR A PARTICULAR PURPOSE.   IN NO EVENT SHALL
//     NVIDIA, CORPORATION  BE LIABLE FOR ANY SPECIAL,  INDIRECT,  INCI-
//     DENTAL, OR CONSEQUENTIAL DAMAGES,  OR ANY DAMAGES  WHATSOEVER RE-
//     SULTING FROM LOSS OF USE,  DATA OR PROFITS,  WHETHER IN AN ACTION
//     OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,  ARISING OUT OF
//     OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOURCE CODE.
//
//     U.S. Government  End  Users.   This source code  is a "commercial
//     item,"  as that  term is  defined at  48 C.F.R. 2.101 (OCT 1995),
//     consisting  of "commercial  computer  software"  and  "commercial
//     computer  software  documentation,"  as such  terms  are  used in
//     48 C.F.R. 12.212 (SEPT 1995)  and is provided to the U.S. Govern-
//     ment only as  a commercial end item.   Consistent with  48 C.F.R.
//     12.212 and  48 C.F.R. 227.7202-1 through  227.7202-4 (JUNE 1995),
//     all U.S. Government End Users  acquire the source code  with only
//     those rights set forth herein.
//
// **************************************************************************
//
//  Module: nvCelsiusCompileVS_link.cpp
//      a pointer to a shared file
//
// **************************************************************************

#include "nvprecomp.h"
#include "..\..\..\common\src\vpcompilex86.c"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\ddraw\celsius\src\nvCelsiusInlPrim.cpp ===
/*
 * Copyright 1993-1998 NVIDIA, Corporation.  All rights reserved.
 * THE INFORMATION CONTAINED HEREIN IS PROPRIETARY AND CONFIDENTIAL TO
 * NVIDIA, CORPORATION.  USE, REPRODUCTION OR DISCLOSURE TO ANY THIRD PARTY
 * IS SUBJECT TO WRITTEN PRE-APPROVAL BY NVIDIA, CORPORATION.
 */
/********************************* Direct 3D *******************************\
*                                                                           *
* Module: nvCelsiusInlPrim.cpp                                              *
*       indexed and ordered inline primitive                                *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*       Ben de Waal             20Oct99         NV10 optimization effort    *
*                                                                           *
\***************************************************************************/
#include "nvprecomp.h"

#if (NVARCH >= 0x10)

#include "x86.h"

//////////////////////////////////////////////////////////////////////////////
// notes:
//  - when offset changes, only program it, dont call setcelsiusstate
//
//////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////
// switches
//

//////////////////////////////////////////////////////////////////////////////
// aliases
//
#define ilcData         global.dwILCData
#define ilcCount        global.dwILCCount
#define ilcMax          global.dwILCMax

//////////////////////////////////////////////////////////////////////////////
// externals
//
void ILCCompile_mul                            (DWORD reg,DWORD num);
//void nvCelsiusILCompile_beginEnd               (DWORD dwPrimType);
//void nvCelsiusILCompile_computeIndexAndOffset  (DWORD dwVBStride,DWORD dwVBLogStride);
//void nvCelsiusILCompile_memcpy                 (DWORD dwCount, bool recurse);
void nvCelsiusILCompile_copyVertex             (PNVD3DCONTEXT pContext,DWORD dwFlags);
void nvCelsiusILCompile_prefetch               (BOOL bIsIndexed,BOOL bLegacyStrides);
void nvCelsiusILCompile_limit                  (DWORD regLimit,DWORD regDummy);

//void __stdcall nvCelsiusDispatchGetFreeSpace   (PNVD3DCONTEXT pContext);
void __stdcall nvCelsiusDispatchGetPusherSpace (void);
#ifdef DEBUG
//void __stdcall nvCelsiusDispatchFlush          (void);
//void __stdcall nvCelsiusDispatchPrintVertex    (PNVD3DCONTEXT pContext,DWORD dwPutAddress);
#endif

//---------------------------------------------------------------------------

// transformed points with per-vertex pointsize

// this handles the specific case of SW-transformed vertices that include a per-vertex
// point size. we are guaranteed that it is a single-stream primitive from stream zero.
// the vertex format will be a DX6-style TL vertex plus a point size.

// the HW may or may not have been programmed to expect one set of texture coordinates,
// continent on whether this is a textured point sprite or just a plain point. note that
// if we do send texture coordinates, we generate them upside down relative to D3D so
// that we match the manner in which celsius itself generates them in the HW T&L case.

void __cdecl nvCelsiusDumpTLPoints (DWORD dwFlags)
{
    DWORD          dwDiffuse,dwSpecular,dwU,dwV;
    float          fx,fy,fz,fw,fpsize;
    float          fx1,fx2,fy1,fy2;
    BOOL           bIsIndexed, bTexCoords;
    WORD          *pIndices   = (WORD *)(global.celsius.pIndices);
    PBYTE          pVertices  = (PBYTE)(global.celsius.pVertices);
    PBYTE          pVertex;
    PNVD3DCONTEXT  pContext   = (PNVD3DCONTEXT)global.celsius.pContext;
    CVertexShader *pVertexShader = pContext->pCurrentVShader;

    nvAssert ((pContext->dp2.dwDP2Prim == D3DDP2OP_POINTS) ||
              (pContext->dwRenderState[D3DRENDERSTATE_FILLMODE] == D3DFILL_POINT));
    nvAssert (pContext->pCurrentVShader->getStride() == 0x24);

    bIsIndexed = ((dwFlags & CELSIUS_ILMASK_LOOPTYPE) == CELSIUS_ILFLAG_IX_INL_PRIM)    ? TRUE : FALSE;
    bTexCoords = (pContext->hwState.dwStateFlags & CELSIUS_FLAG_USERTEXCOORDSNEEDED(0)) ? TRUE : FALSE;

    // cache current values, then set solid fill, solid shading, and disable culling
    DWORD dwOldFillMode  = pContext->dwRenderState[D3DRENDERSTATE_FILLMODE];
    DWORD dwOldShadeMode = pContext->dwRenderState[D3DRENDERSTATE_SHADEMODE];
    DWORD dwOldCullMode  = pContext->dwRenderState[D3DRENDERSTATE_CULLMODE];

    pContext->dwRenderState[D3DRENDERSTATE_FILLMODE]  = D3DFILL_SOLID;
    pContext->dwRenderState[D3DRENDERSTATE_SHADEMODE] = D3DSHADE_FLAT;
    pContext->dwRenderState[D3DRENDERSTATE_CULLMODE]  = D3DCULL_NONE;

    pContext->hwState.dwDirtyFlags |= CELSIUS_DIRTY_MISC_STATE;
    nvSetCelsiusState (pContext);

    // begin primitive
    nvPushData (0, ((sizeSetNv10CelsiusBeginEnd3MthdCnt << 2) << 16) | (NV_DD_CELSIUS << 13) | NV056_SET_BEGIN_END4);
    nvPushData (1, NV056_SET_BEGIN_END_OP_TRIANGLES);
    nvPusherAdjust (2);

    for (DWORD i=0; i<global.celsius.dwPrimCount; i++)
    {
        pVertex = pVertices + ((bIsIndexed ? pIndices[i] : i) * pVertexShader->getStride());

        fpsize  = *(float*)(pVertex + pVertexShader->getVAOffset(defaultInputRegMap[D3DVSDE_PSIZE]));
        fpsize *= 0.5f;
        fpsize  = min (fpsize, 32.0f);
        fx1     = *(float*)(pVertex + 0) - fpsize;
        fx2     = *(float*)(pVertex + 0) + fpsize;
        fy1     = *(float*)(pVertex + 4) - fpsize;
        fy2     = *(float*)(pVertex + 4) + fpsize;
        fz      = *(float*)(pVertex + 8);
        fw      = *(float*)(pVertex + 12);
        dwDiffuse  = *(DWORD *)(pVertex + pVertexShader->getVAOffset(defaultInputRegMap[D3DVSDE_DIFFUSE]));
        dwSpecular = *(DWORD *)(pVertex + pVertexShader->getVAOffset(defaultInputRegMap[D3DVSDE_SPECULAR]));

        if (bTexCoords) {
            for (DWORD j=0; j<6; j++) {
                switch (j) {
                    case 0:        fx=fx1; fy=fy1; dwU=FP_ONE_BITS; dwV=FP_ONE_BITS; break;
                    case 5:        fx=fx2; fy=fy2; dwU=0;           dwV=0;           break;
                    case 2:case 3: fx=fx1; fy=fy2; dwU=FP_ONE_BITS; dwV=0;           break;
                    case 1:case 4: fx=fx2; fy=fy1; dwU=0;           dwV=FP_ONE_BITS; break;
                }
                getDC()->nvPusher.push (0, (8 << 18) | (NV_DD_CELSIUS << 13) | NVPUSHER_NOINC(NV056_INLINE_ARRAY(0)));
                getDC()->nvPusher.push (1, dwU);
                getDC()->nvPusher.push (2, dwV);
                getDC()->nvPusher.push (3, dwSpecular);
                getDC()->nvPusher.push (4, dwDiffuse);
                getDC()->nvPusher.push (5, DWORD_FROM_FLOAT(fx));
                getDC()->nvPusher.push (6, DWORD_FROM_FLOAT(fy));
                getDC()->nvPusher.push (7, DWORD_FROM_FLOAT(fz));
                getDC()->nvPusher.push (8, DWORD_FROM_FLOAT(fw));
                nvPusherAdjust (9);
            }
        }
        else {
            for (DWORD j=0; j<6; j++) {
                switch (j) {
                    case 0:        fx=fx1; fy=fy1; break;
                    case 5:        fx=fx2; fy=fy2; break;
                    case 2:case 3: fx=fx1; fy=fy2; break;
                    case 1:case 4: fx=fx2; fy=fy1; break;
                }
                getDC()->nvPusher.push (0, (6 << 18) | (NV_DD_CELSIUS << 13) | NVPUSHER_NOINC(NV056_INLINE_ARRAY(0)));
                getDC()->nvPusher.push (1, dwSpecular);
                getDC()->nvPusher.push (2, dwDiffuse);
                getDC()->nvPusher.push (3, DWORD_FROM_FLOAT(fx));
                getDC()->nvPusher.push (4, DWORD_FROM_FLOAT(fy));
                getDC()->nvPusher.push (5, DWORD_FROM_FLOAT(fz));
                getDC()->nvPusher.push (6, DWORD_FROM_FLOAT(fw));
                nvPusherAdjust (7);
            }
        }
    }

    // end primitive
    nvPushData (0,((1 << 2) << 16) | ((NV_DD_CELSIUS) << 13) | NV056_SET_BEGIN_END4);
    nvPushData (1, NV056_SET_BEGIN_END_OP_END);
    nvPusherAdjust(2);

    // restore original fill, shade, and cull values
    pContext->dwRenderState[D3DRENDERSTATE_FILLMODE]  = dwOldFillMode;
    pContext->dwRenderState[D3DRENDERSTATE_SHADEMODE] = dwOldShadeMode;
    pContext->dwRenderState[D3DRENDERSTATE_CULLMODE]  = dwOldCullMode;

    pContext->hwState.dwDirtyFlags |= CELSIUS_DIRTY_MISC_STATE;
}

//---------------------------------------------------------------------------

DWORD nvCelsiusILCompile_inline_prim
(
    PNVD3DCONTEXT pContext,
    DWORD         dwFlags
)
{
    //
    // get loop constants
    //
    DWORD  dwMagic                = celsiusPrimitiveToPrimitiveMagic[dwFlags & CELSIUS_ILMASK_PRIMTYPE];
    DWORD  dwVerticesPerPrim      = (dwMagic >> 8) & 0xff;
    DWORD  dwStartVerticesPerPrim = (dwMagic >> 0) & 0xff;
    BOOL   bLegacyStrides         = dwFlags & CELSIUS_ILFLAG_LEGACY;
    BOOL   bIsIndexed             = (dwFlags & CELSIUS_ILMASK_LOOPTYPE) == CELSIUS_ILFLAG_IX_INL_PRIM;

    //
    // align entry point
    //
    while (ilcCount & 31) { xINT3 }
    DWORD lEntry;
    xLABEL (lEntry);

    //
    // setup stack frame
    //
    xPUSH_r     (rEBP)
    xPUSH_r     (rEBX)
    xPUSH_r     (rESI)
    xPUSH_r     (rEDI)

    //
    // verify that we are using the correct inner loop - debug only
    //
#ifdef DEBUG
    DWORD ld1,ld2;
    xLABEL      (ld1)
    xJMP        (0)
    xLABEL      (ld2)
    xINT3

#define CHECK(a,x)                  \
{                                   \
    xMOV_rm_imm (rmREG(rEBX),a)     \
    xMOV_rm_imm (rmREG(rEAX),x)     \
    xCMP_r_i32  (rEAX,mMEM32(x))    \
    xJNZ32      (ld2)               \
}
#define CHECK2(a,x,y,t)             \
{                                   \
    xMOV_r_i32  (rEDX,mMEM32(global.celsius.x))    \
    xMOV_rm_imm (rmREG(rEBX),a)     \
    xMOV_rm_imm (rmREG(rEAX),x->y)   \
    xCMP_r_rm   (rEAX,rmIND32(rEDX)) xOFS32(OFFSETOF(t,y)) \
    xJNZ32      (ld2)               \
}

    xTARGET_jmp (ld1)

/*
    CHECK (0x00000000,fvfData.dwVertexStride)

    CHECK (0x00010000,fvfData.dwVertexType)

    CHECK (0x00020000,fvfData.dwUVCount[0])
    CHECK (0x00020001,fvfData.dwUVCount[1])
    CHECK (0x00020002,fvfData.dwUVCount[2])
    CHECK (0x00020003,fvfData.dwUVCount[3])
    CHECK (0x00020004,fvfData.dwUVCount[4])
    CHECK (0x00020005,fvfData.dwUVCount[5])
    CHECK (0x00020006,fvfData.dwUVCount[6])
    CHECK (0x00020007,fvfData.dwUVCount[7])

    CHECK (0x00030000,fvfData.dwUVOffset[0])
    CHECK (0x00030001,fvfData.dwUVOffset[1])
    CHECK (0x00030002,fvfData.dwUVOffset[2])
    CHECK (0x00030003,fvfData.dwUVOffset[3])
    CHECK (0x00030004,fvfData.dwUVOffset[4])
    CHECK (0x00030005,fvfData.dwUVOffset[5])
    CHECK (0x00030006,fvfData.dwUVOffset[6])
    CHECK (0x00030007,fvfData.dwUVOffset[7])
*/

    //  - pContext->hwState.dwStateFlags & CELSIUS_MASK_INNERLOOPUNIQUENESS
    xMOV_r_i32  (rEDX,mMEM32(global.celsius.pContext))
    xMOV_rm_imm (rmREG(rEBX),0x00040000)
    xMOV_r_rm   (rEAX,rmIND32(rEDX)) xOFS32(OFFSETOF(NVD3DCONTEXT, hwState.dwStateFlags))
    xAND_rm_imm (rmREG(rEAX),CELSIUS_MASK_INNERLOOPUNIQUENESS)
    xCMP_rm_imm (rmREG(rEAX),pContext->hwState.dwStateFlags & CELSIUS_MASK_INNERLOOPUNIQUENESS)
    xJNZ32      (ld2)

    if (pContext->hwState.dwStateFlags & CELSIUS_FLAG_USERTEXCOORDSNEEDED(0))
    {
        CHECK2 (0x00050000,pContext,hwState.dwTexUnitToTexStageMapping[0],NVD3DCONTEXT)
    }
    if (pContext->hwState.dwStateFlags & CELSIUS_FLAG_USERTEXCOORDSNEEDED(1))
    {
        CHECK2 (0x00050001,pContext,hwState.dwTexUnitToTexStageMapping[1],NVD3DCONTEXT)
    }
#endif

    if ((pContext->hwState.pVertexShader->bVAExists(defaultInputRegMap[D3DVSDE_PSIZE]))
        &&
        ((pContext->dp2.dwDP2Prim == D3DDP2OP_POINTS) || (pContext->dwRenderState[D3DRENDERSTATE_FILLMODE] == D3DFILL_POINT)))
    {
        // do the point size expansion
#if 1 //USE_C_LOGIC
        xMOV_rm_imm (rmREG(rEAX),dwFlags)
            xPUSH_r (rEAX)
            xMOV_rm_imm (rmREG(rEAX),nvCelsiusDumpTLPoints)
            xCALL_rm (rmREG(rEAX))
            xADD_rm_imm (rmREG(rESP),4);
#else //USE_C_LOGIC
        nvAssert(0);
#endif
    }
    else
    {
    //
    // setup push buffer
    //
    xMOV_r_i32  (rEDX,mMEM32(pDriverData))
    xMOV_r_rm   (rEDI,rmIND32(rEDX)) xOFS32(OFFSETOF(CDriverContext,nvPusher.m_dwPut))

    //
    // calc how many verts to copy into EBX
    //
    xMOV_r_i32  (rEBX,mMEM32(global.celsius.dwPrimCount))
    ILCCompile_mul (rEBX, dwVerticesPerPrim);
    if (dwStartVerticesPerPrim)
    {
        xADD_rm_imm (rmREG(rEBX),dwStartVerticesPerPrim)
    }

    //
    // setup prefetcher (EBX has # of vertices to copy in total)
    //
    if (bIsIndexed)
    {
        xMOV_r_i32  (rEAX,mMEM32(global.celsius.pIndices))
         xLEA_r_rm   (rECX,rmSIB) xSIB(rEAX,rEBX,x2)
        xMOV_i32_r  (mMEM32(global.celsius.dwPrefetchBase),rEAX)
         xMOV_i32_r  (mMEM32(global.celsius.dwPrefetchMax),rECX)
        if (bLegacyStrides)
        {
            xMOV_r_i32  (rEAX,mMEM32(global.celsius.pIndices))
            xMOV_i32_r  (mMEM32(global.celsius.pIndexBase),rEAX)
        }
    }
    else
    {
        xMOV_r_i32  (rEAX,mMEM32(global.celsius.pVertices))
         xMOV_r_rm   (rECX,rmREG(rEBX))
         ILCCompile_mul (rECX,global.celsius.dwVertexStride);
         xADD_r_rm   (rECX,rmREG(rEAX))
        xMOV_i32_r  (mMEM32(global.celsius.dwPrefetchBase),rEAX)
         xMOV_i32_r  (mMEM32(global.celsius.dwPrefetchMax),rECX)
    }

    //
    // start primitive
    //
    xMOV_rm_imm (rmREG(rEAX),((sizeSetNv10CelsiusBeginEnd4MthdCnt << 2) << 16) | ((NV_DD_CELSIUS) << 13) | NV056_SET_BEGIN_END4);
    xMOV_rm_imm (rmREG(rECX),celsiusBeginEndOp[dwFlags & CELSIUS_ILMASK_PRIMTYPE])
    xMOV_rm_r   (rmIND(rEDI),rEAX)
    xMOV_rm_r   (rmIND8(rEDI),rECX) xOFS8(4)
    xLEA_r_rm   (rEDI,rmIND8(rEDI)) xOFS8(8)

    //
    // start copying
    //   for this loop EDI points to PUT and EBX has the amount of prims to go
    //
    DWORD labelLoop;
    xLABEL  (labelLoop)
    {
        xPUSH_r     (rEBX)

        //
        // prefetch
        //
        nvCelsiusILCompile_prefetch (bIsIndexed, bLegacyStrides);

        //
        // copy vertex
        //
        if (bIsIndexed)
        {
            // get index
            xMOV_r_i32  (rEDX,mMEM32(global.celsius.pIndices))
            xXOR_r_rm   (rESI,rmREG(rESI))
       x16r xMOV_r_rm   (rSI,rmIND(rEDX))
            xLEA_r_rm   (rEDX,rmIND8(rEDX)) xOFS8(2)
            if (bLegacyStrides)
            {
                xMOV_r_rm   (rEAX,rmREG(rEDX))
                xSUB_r_i32  (rEAX,mMEM32(global.celsius.pIndexBase))
                xAND_rm_imm (rmREG(rEAX),6)
                xXOR_r_rm   (rECX,rmREG(rECX))
                xCMP_rm_imm (rmREG(rEAX),6)
                xSETNZ_rm8  (rmREG(rCL))
                xDEC_rm     (rmREG(rECX))
                xAND_rm_imm (rmREG(rECX),2)
                xADD_r_rm   (rEDX,rmREG(rECX))
            }
            xMOV_i32_r  (mMEM32(global.celsius.pIndices),rEDX)
            // compute vertex offset
            ILCCompile_mul (rESI,global.celsius.dwVertexStride);
            // range limit for NT
            nvCelsiusILCompile_limit (rESI,rECX);

            // compute vertex address
            xADD_r_i32  (rESI,mMEM32(global.celsius.pVertices))
        }
        else
        {
            // get vertex & increment
            xMOV_r_i32  (rESI,mMEM32(global.celsius.pVertices))
            xLEA_r_rm   (rEAX,rmIND32(rESI)) xOFS32(global.celsius.dwVertexStride)
            xMOV_i32_r  (mMEM32(global.celsius.pVertices),rEAX)
        }

        // copy vertex (from ESI to EDI)
        nvCelsiusILCompile_copyVertex (pContext,dwFlags);

        // update instumentation stats
#ifdef INSTRUMENT_INNER_LOOPS
        {
            xMOV_rm_imm (rmREG(rEAX),fvfData.dwVertexStride)
            xADD_i32_r  (mMEM32(global.dwBytesCopied),rEAX)
        }
#endif


        // check for pusher space
        DWORD labelSpace;
        xMOV_r_i32  (rESI,mMEM32(pDriverData))
        xCMP_r_rm   (rEDI,rmIND32(rESI)) xOFS32(OFFSETOF(CDriverContext,nvPusher.m_dwThreshold))
        xLABEL      (labelSpace)
        xJL         (0)
        {
            xMOV_rm_r   (rmIND32(rESI),rEDI) xOFS32(OFFSETOF(CDriverContext,nvPusher.m_dwPut))
            xMOV_rm_imm (rmREG(rEAX),(DWORD)nvCelsiusDispatchGetPusherSpace)
            xCALL_rm    (rmREG(rEAX))
            xMOV_r_rm   (rEDI,rmIND32(rESI)) xOFS32(OFFSETOF(CDriverContext,nvPusher.m_dwPut))
        }
        xTARGET_b8  (labelSpace)

        // next
        xPOP_r  (rEBX)
        xDEC_rm (rmREG(rEBX))
    }
    xJNZ32  (labelLoop)

    //
    // end primitive
    //
    xMOV_rm_imm (rmREG(rEAX),((sizeSetNv10CelsiusBeginEnd4MthdCnt << 2) << 16) | ((NV_DD_CELSIUS) << 13) | NV056_SET_BEGIN_END4);
    xMOV_rm_imm (rmREG(rECX),NV056_SET_BEGIN_END4_OP_END)
    xMOV_rm_r   (rmIND(rEDI),rEAX)
    xMOV_rm_r   (rmIND8(rEDI),rECX) xOFS8(4)
    xLEA_r_rm   (rEDI,rmIND8(rEDI)) xOFS8(8)

    //
    // save off push buffer
    //
    xMOV_r_i32  (rEDX,mMEM32(pDriverData))
#ifndef NV_NULL_HW_DRIVER
    xMOV_rm_r   (rmIND32(rEDX),rEDI) xOFS32(OFFSETOF(CDriverContext,nvPusher.m_dwPut))
#endif
    }
    //
    // done
    //
    xPOP_r      (rEDI)
    xPOP_r      (rESI)
    xPOP_r      (rEBX)
    xPOP_r      (rEBP)
    xRET

    return lEntry;
}

#endif  // NVARCH == 0x10
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\ddraw\celsius\src\nvCelsiusComp.cpp ===
/*
 * Copyright 1993-1998 NVIDIA, Corporation.  All rights reserved.
 * THE INFORMATION CONTAINED HEREIN IS PROPRIETARY AND CONFIDENTIAL TO
 * NVIDIA, CORPORATION.  USE, REPRODUCTION OR DISCLOSURE TO ANY THIRD PARTY
 * IS SUBJECT TO WRITTEN PRE-APPROVAL BY NVIDIA, CORPORATION.
 */
/********************************* Direct 3D *******************************\
*                                                                           *
* Module: nvCelsiusComp.cpp                                                 *
*       Celsius inner loop compiler                                         *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*       Ben de Waal             29Sep99         NV10 optimization effort    *
*                                                                           *
\***************************************************************************/
#include "nvprecomp.h"

#if (NVARCH >= 0x10)

#include "x86.h"
#include "nvILHash.h"

//////////////////////////////////////////////////////////////////////////////
// notes:
//
// inner loop uniqueness is a function of:
//  - fvfData.dwVertexStride
//  - fvfData.dwVertexType
//  - fvfData.dwUVCount[8]
//  - fvfData.dwUVOffset[8]
//  - pContext->hwState.dwStateFlags & CELSIUS_MASK_INNERLOOPUNIQUENESS
//  - pContext->hwState.celsius.dwTexUnitToTexStageMapping[2]
//
//////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////
// switches
//
//#define PRINT_NAME          // prints ilcFlags for every primitive batch

//////////////////////////////////////////////////////////////////////////////
// aliases
//
#define ilcData         global.dwILCData
#define ilcCount        global.dwILCCount
#define ilcMax          global.dwILCMax

#define KNIMEM(x)           ((((DWORD)&((*(KATMAI_STATE*)global.kni).x[0])) + 15) & ~15)

//////////////////////////////////////////////////////////////////////////////
// external declarations (mostly nvcomp.cpp)
//
void ILCCompile_GetSpace (void);
void ILCCompile_mul      (DWORD reg,DWORD num);

//////////////////////////////////////////////////////////////////////////////
// forward declarations
//
DWORD nvCelsiusILCompile_inline_prim      (PNVD3DCONTEXT pContext,DWORD dwFlags);    // nvCelsiusInlPrim.cpp
DWORD nvCelsiusILCompile_inline_tri_list  (PNVD3DCONTEXT pContext,DWORD dwFlags);    // nvCelsiusInlTri.cpp
DWORD nvCelsiusILCompile_vb_prim          (PNVD3DCONTEXT pContext,DWORD dwFlags);    // nvCelsiusVbPrim.cpp
DWORD nvCelsiusILCompile_str_prim         (PNVD3DCONTEXT pContext,DWORD dwFlags);    // nvCelsiusInlStrPrim.cpp
DWORD nvCelsiusILCompile_super_tri_list   (PNVD3DCONTEXT pContext,DWORD dwFlags);    // nvCelsiusSuperTri.cpp

//---------------------------------------------------------------------------

// nvCelsiusGetDispatchRoutine

CELSIUSDISPATCHPRIMITIVE nvCelsiusGetDispatchRoutine
(
    PNVD3DCONTEXT pContext,
    DWORD         dwFlags
)
{
    // check quick cache
    if (global.celsius.dwLoopCache)
    {
        CILHashEntry *pEntry = (CILHashEntry*)global.celsius.dwLoopCache;
        if (pEntry->match (pContext,NVCLASS_FAMILY_CELSIUS,dwFlags))
        {
            return (CELSIUSDISPATCHPRIMITIVE)(ilcData + pEntry->getOffset());
        }
    }

    // check hash table
    DWORD dwHashIndex = (DRAW_PRIM_TABLE_ENTRIES - 1) & ((dwFlags + (dwFlags >> 12) + (dwFlags >> 24))
                                                      + pContext->hwState.pVertexShader->getStride()
                                                      + pContext->hwState.pVertexShader->getFVF());

    CILHashEntry *pEntry = (CILHashEntry*)dwDrawPrimitiveTable[dwHashIndex];

    while (pEntry)
    {
        // found it?
        if (pEntry->match (pContext,NVCLASS_FAMILY_CELSIUS,dwFlags))
        {
            global.celsius.dwLoopCache = (DWORD)pEntry;
            return (CELSIUSDISPATCHPRIMITIVE)(ilcData + pEntry->getOffset());
        }
        // next
        pEntry = pEntry->getNext();
    }

    // build new innerloop
    //  loops require pContext->hwState.dwStateFlags to be set up correctly (CM hack, inline expansion)
    DWORD dwOffset;
    switch (dwFlags & CELSIUS_ILMASK_LOOPTYPE)
    {
        case CELSIUS_ILFLAG_IX_VB_PRIM:
        case CELSIUS_ILFLAG_OR_VB_PRIM:      dwOffset = nvCelsiusILCompile_vb_prim(pContext,dwFlags);
                                             break;
        case CELSIUS_ILFLAG_IX_STR_PRIM:
        case CELSIUS_ILFLAG_OR_STR_PRIM:     dwOffset = nvCelsiusILCompile_str_prim(pContext,dwFlags);
                                             break;
        case CELSIUS_ILFLAG_IX_INL_PRIM:
        case CELSIUS_ILFLAG_OR_INL_PRIM:     dwOffset = nvCelsiusILCompile_inline_prim(pContext,dwFlags);
                                             break;
        case CELSIUS_ILFLAG_IX_INL_TRI_LIST:
        case CELSIUS_ILFLAG_OR_INL_TRI_LIST: dwOffset = nvCelsiusILCompile_inline_tri_list(pContext,dwFlags);
                                             break;
        case CELSIUS_ILFLAG_SUPER_TRI_LIST:  dwOffset = 0;//nvCelsiusILCompile_super_tri_list(pContext,dwFlags);
                                             break;
        case CELSIUS_ILFLAG_IX_DVB_TRI:      dwOffset = 0;//todo - nvCelsiusILCompile_indexed_dvb_tri(pContext,dwFlags);
                                             break;
    }

    //
    // add to hash list
    //
    pEntry = new CILHashEntry (pContext,NVCLASS_FAMILY_CELSIUS,dwFlags,dwOffset,(CILHashEntry*)dwDrawPrimitiveTable[dwHashIndex]);
    if (!pEntry) {
        nvAssert(0);
        return NULL;
    }
    dwDrawPrimitiveTable[dwHashIndex] = (DWORD)pEntry;

#ifdef PRINT_NAME
    PF ("new celsius loop (%08x): type %x, dp2 %s (%2x), state = %08x, %s %s %s", pEntry,
        (dwFlags & 0xF0000000) >> 28,
        celsiusPrimitiveName[dwFlags & 0xFFFF], dwFlags & 0xFFFF,
        pContext->hwState.dwStateFlags & CELSIUS_MASK_INNERLOOPUNIQUENESS,
        dwFlags & CELSIUS_ILFLAG_LEGACY ? "LEGACY" : "",
        dwFlags & CELSIUS_ILFLAG_CMHACK ? "CMHACK" : "",
        dwFlags & CELSIUS_ILFLAG_NOCULL ? "NOCULL" : "");
#endif

    //
    // done
    //
    global.celsius.dwLoopCache = (DWORD)pEntry;
    return (CELSIUSDISPATCHPRIMITIVE)(ilcData + pEntry->getOffset());
}
/*
//---------------------------------------------------------------------------

// indexed vertex buffer copy

DWORD nvCelsiusILCompile_indexed_vb
(
    DWORD dwFlags
)
{
    DWORD label;
    xLABEL (label);
    xMOV_rm_imm (rmREG(rEAX),dwFlags);
    xRET

    return label;
}

//---------------------------------------------------------------------------

// ordered vertex buffer copy

DWORD nvCelsiusILCompile_ordered_vb
(
    DWORD dwFlags
)
{
    DWORD label;
    xLABEL (label);
    xMOV_rm_imm (rmREG(rEAX),dwFlags);
    xRET

    return label;
}

//---------------------------------------------------------------------------

// indexed copy

DWORD nvCelsiusILCompile_indexed
(
    DWORD dwFlags
)
{
    DWORD label;
    xLABEL (label);
    xMOV_rm_imm (rmREG(rEAX),dwFlags);
    xRET

    return label;
}

//---------------------------------------------------------------------------

// ordered copy

DWORD nvCelsiusILCompile_ordered
(
    DWORD dwFlags
)
{
    DWORD label;
    xLABEL (label);
    xMOV_rm_imm (rmREG(rEAX),dwFlags);
    xRET

    return label;
}

//---------------------------------------------------------------------------

// ordered transformed triangle

DWORD nvCelsiusILCompile_ordered_tri
(
    DWORD dwFlags
)
{
    DWORD label;
    xLABEL (label);
    xMOV_rm_imm (rmREG(rEAX),dwFlags);
    xRET

    return label;
}

//---------------------------------------------------------------------------

// helpers - called by inner loops

void __stdcall nvCelsiusDispatchGetFreeSpace (PNVD3DCONTEXT pContext)
{
    // make space
    nvPusherAdjust (0);
    // read back defVB values
    getDC()->defaultVB.updateOffset (global.celsius.dwVBOffset);
    // get more space
    DWORD dwOffset = getDC()->defaultVB.waitForSpace (12 * 64 * 10, TRUE);
    // reset defVB values
    getDC()->defaultVB.updateOffset (dwOffset);
    global.celsius.dwVBGetOffset = getDC()->defaultVB.getCachedOffset();
}
*/
void __stdcall nvCelsiusDispatchGetPusherSpace (void)
{
    // wrap around -or- make space
    nvPusherAdjust (0);
}

#ifdef DEBUG
void __stdcall nvCelsiusDispatchFlush (void)
{
    nvPusherAdjust (0);
    getDC()->nvPusher.flush (TRUE, CPushBuffer::FLUSH_WITH_DELAY);
}

void __stdcall nvCelsiusDispatchPrintVertex (PNVD3DCONTEXT pContext,DWORD dwPutAddress)
{
    static DWORD dwVertexCount = 0;

    if (dbgShowState & NVDBG_SHOW_VERTICES)
    {
        DWORD *pdwData = ((DWORD*)dwPutAddress) + 1;

        dwVertexCount ++;

        DPF ("Vertex %d", dwVertexCount);

        if (pContext->hwState.pVertexShader->bVAExists(defaultInputRegMap[D3DVSDE_BLENDWEIGHT])) {
            DPF ("         B = %08x",pdwData[0]);
            pdwData += 1;
        }

        if (pContext->hwState.pVertexShader->bVAExists(defaultInputRegMap[D3DVSDE_NORMAL])) {
            DPF ("    Normal = %f, %f, %f", FLOAT_FROM_DWORD(pdwData[0]),FLOAT_FROM_DWORD(pdwData[1]),FLOAT_FROM_DWORD(pdwData[2]));
            DPF ("           = [%08x, %08x, %08x]", pdwData[0],pdwData[1],pdwData[2]);
            pdwData += 3;
        }

        if (pContext->hwState.dwStateFlags & CELSIUS_FLAG_USERTEXCOORDSNEEDED(1)) {
            DWORD dwD3DStage = pContext->hwState.dwTexUnitToTexStageMapping[1];
            DWORD dwTCIndex  = (pContext->hwState.dwTexCoordIndices >> 16) & 0xffff;
            DWORD dwVAIndex  = defaultInputRegMap[D3DVSDE_TEXCOORD0+dwTCIndex];
            DWORD dwCount    = (pContext->hwState.dwStateFlags & (CELSIUS_FLAG_PASSTHROUGHCUBEMAPPING(1) | CELSIUS_FLAG_TEXMATRIXSWFIX(1))) ?
                               4 : (pContext->hwState.pVertexShader->getVASize(dwVAIndex) >> 2);
            for (DWORD i = 0; i < dwCount; i++)
            {
                DPF ("   UV1[%d] = %f [%08x]", i,FLOAT_FROM_DWORD(pdwData[0]),pdwData[0]);
                pdwData += 1;
            }
        }

        if (pContext->hwState.dwStateFlags & CELSIUS_FLAG_USERTEXCOORDSNEEDED(0)) {
            DWORD dwD3DStage = pContext->hwState.dwTexUnitToTexStageMapping[0];
            DWORD dwTCIndex  = (pContext->hwState.dwTexCoordIndices >>  0) & 0xffff;
            DWORD dwVAIndex  = defaultInputRegMap[D3DVSDE_TEXCOORD0+dwTCIndex];
            DWORD dwCount    = (pContext->hwState.dwStateFlags & (CELSIUS_FLAG_PASSTHROUGHCUBEMAPPING(0) | CELSIUS_FLAG_TEXMATRIXSWFIX(0))) ?
                               4 : (pContext->hwState.pVertexShader->getVASize(dwVAIndex) >> 2);
            for (DWORD i = 0; i < dwCount; i++)
            {
                DPF ("   UV0[%d] = %f [%08x]", i,FLOAT_FROM_DWORD(pdwData[0]),pdwData[0]);
                pdwData += 1;
            }
        }

        if (pContext->hwState.pVertexShader->bVAExists(defaultInputRegMap[D3DVSDE_SPECULAR])){
            DPF ("  Specular = %08x",pdwData[0]);
            pdwData += 1;
        }

        if (pContext->hwState.pVertexShader->bVAExists(defaultInputRegMap[D3DVSDE_DIFFUSE])) {
            DPF ("   Diffuse = %08x",pdwData[0]);
            pdwData += 1;
        }

        nvAssert (pContext->hwState.pVertexShader->bVAExists(defaultInputRegMap[D3DVSDE_POSITION]));
        DPF ("       XYZ = %f, %f, %f", FLOAT_FROM_DWORD(pdwData[0]),FLOAT_FROM_DWORD(pdwData[1]),FLOAT_FROM_DWORD(pdwData[2]));
        DPF ("           = [%08x, %08x, %08x]", pdwData[0],pdwData[1],pdwData[2]);
        pdwData += 3;

        if (pContext->hwState.pVertexShader->getVASize(defaultInputRegMap[D3DVSDE_POSITION]) == 4*sizeof(DWORD)) {
            DPF ("       RHW = %f [%08x]", FLOAT_FROM_DWORD(pdwData[0]),pdwData[0]);
            pdwData += 1;
        }
        DPF ("");
    }
}
#endif
/*
//---------------------------------------------------------------------------

// helpers

void nvCelsiusILCompile_beginEnd
(
    DWORD dwPrimType
)
{
    xMOV_r_i32  (rEDX,mMEM32(pDriverData))
    xMOV_r_rm   (rEDI,rmIND32(rEDX)) xOFS32(OFFSETOF(CDriverContext,nvPusher.m_dwPut))
    xMOV_rm_imm (rmREG(rEAX),(((sizeSetNv10CelsiusBeginEnd2MthdCnt << 2) << 16) | ((NV_DD_CELSIUS) << 13) | NV056_SET_BEGIN_END2))
    xMOV_rm_imm (rmREG(rEBX),dwPrimType)
    xMOV_rm_r   (rmIND(rEDI),rEAX)
    xMOV_rm_r   (rmIND8(rEDI),rEBX) xOFS8(4)
    xLEA_r_rm   (rEDI,rmIND8(rEDI)) xOFS8(8)
#ifndef NV_NULL_HW_DRIVER
    xMOV_rm_r   (rmIND32(rEDX),rEDI) xOFS32(OFFSETOF(CDriverContext,nvPusher.m_dwPut))
#endif
}

void nvCelsiusILCompile_computeThreshold (void)
{
    DWORD dwVBReservedSpace = 64 * 12; // max fvf size times 12
    DWORD dwDefaultVBSize = getDC()->defaultVB.getSize();

    // global.celsius.dwVBThreshold = (dwVBOffset < dwVBGetOffset) ? (dwVBGetOffset - dwVBSpace)
    //                                                             : (dwDefaultVBSize - dwVBSpace);
    xMOV_r_i32  (rEAX,mMEM32(global.celsius.dwVBOffset))
        xMOV_rm_imm (rmREG(rEDX),dwDefaultVBSize)
    xXOR_r_rm   (rECX,rmREG(rECX))
    xSUB_r_i32  (rEAX,mMEM32(global.celsius.dwVBGetOffset))
    xSETL_rm8   (rmREG(rCL))        // ecx = (ofs < get) ? 1 : 0
        xSUB_r_i32  (rEDX,mMEM32(global.celsius.dwVBGetOffset)) // edx = (dwDefaultVBSize - dwVBGetOffset)
    xDEC_rm     (rmREG(rECX))       // ecx = (ofs < get) ? 0 : ~0
    xAND_r_rm   (rECX,rmREG(rEDX))  // ecx = (ofs < get) ? 0 : edx -> (dwDefaultVBSize - dwVBGetOffset)
    xADD_r_i32  (rECX,mMEM32(global.celsius.dwVBGetOffset))
                                    // ecx = (ofs < get) ? get : vbsize
    xSUB_rm_imm (rmREG(rECX),dwVBReservedSpace)
    xMOV_i32_r  (mMEM32(global.celsius.dwVBThreshold),rECX)
}

void nvCelsiusILCompile_computeIndexAndOffset
(
    DWORD dwVBStride,
    DWORD dwLogStride       // must be zero if dwVBstride is not a power of 2
)
{
    // global.celsius.dwVBIndex = (getDC()->dwDefVBCurrentOffset + dwVBStride * 4 - 1) / dwVBStride;
    xMOV_r_i32  (rEAX,mMEM32(pDriverData))
    xMOV_rm_imm (rmREG(rEBX),dwVBStride * 4 - 1)
    if (dwLogStride)
    {
        xMOV_r_rm   (rEAX,rmIND32(rEAX)) xOFS32(OFFSETOF(CDriverContext,defaultVB.m_dwCurrentOffset))
        xADD_r_rm   (rEAX,rmREG(rEBX))
        xSHR_rm_imm (rmREG(rEAX),dwLogStride)
    }
    else
    {
        xXOR_r_rm   (rEDX,rmREG(rEDX))
        xMOV_r_rm   (rEAX,rmIND32(rEAX)) xOFS32(OFFSETOF(CDriverContext,defaultVB.m_dwCurrentOffset))
        xMOV_rm_imm (rmREG(rECX),dwVBStride)
        xADD_r_rm   (rEAX,rmREG(rEBX))
        xDIV_rm     (rmREG(rECX))
    }
    xMOV_i32_r  (mMEM32(global.celsius.dwVBIndex),rEAX)

    // global.celsius.dwVBOffset = global.celsius.dwVBIndex * dwVBStride;
    ILCCompile_mul (rEAX,dwVBStride);
    xMOV_i32_r  (mMEM32(global.celsius.dwVBOffset),rEAX)

    // compute threshold
    nvCelsiusILCompile_computeThreshold();

    // compute DVB banks
    xMOV_r_i32  (rEAX,mMEM32(global.celsius.dwVBIndex))
    xMOV_r_rm   (rEBX,rmREG(rEAX))
    xAND_rm_imm (rmREG(rEAX),0xffff8000)
    xAND_rm_imm (rmREG(rEBX),0x00007fff)
    xMOV_i32_r  (mMEM32(global.celsius.dwVBIndex),rEBX)
    // check if we need to reprogram FVF (dwVBBank is in eax)
    xMOV_r_i32  (rESI,mMEM32(global.celsius.pContext_celsiusState))
    ILCCompile_mul (rEAX,dwVBStride);
    // pContext->hwState.celsius.dwVertexOffsetInUse = dwVBBank * dwVBStride;
    xMOV_rm_r   (rmIND32(rESI),rEAX) xOFS32(OFFSETOF(CCelsiusState,dwVertexOffsetInUse))
    // set fvf dirty if (getDC()->dwVBCachedVertexOffset != dwDefVBBase))
    xMOV_r_i32  (rEDI,mMEM32(pDriverData))
    xXOR_r_rm   (rECX,rmREG(rECX))
    xCMP_r_rm   (rEAX,rmIND32(rEDI)) xOFS32(OFFSETOF(CDriverContext,dwVBCachedVertexOffset))
    xSETZ_rm8   (rmREG(rCL))
    xDEC_rm     (rmREG(rECX))
    xAND_rm_imm (rmREG(rECX),CELSIUS_DIRTY_FVF)
    xOR_rm_r    (rmIND32(rESI),rECX) xOFS32(OFFSETOF(CCelsiusState,dwDirtyFlags))

    //
    // set state
    //
    xMOV_r_i32  (rESI,mMEM32(global.celsius.pContext))
    xMOV_rm_imm (rmREG(rEBX),(DWORD)nvSetCelsiusState)
    xPUSH_r     (rESI)
    xCALL_rm    (rmREG(rEBX))
}
*/
// copies dwCount bytes from [esi] to [edi] with increment. if dwCount is zero then we copy ecx bytes
// we use esi,edi,eax and ecx. for kni we also use xmm0 to xmm3
void nvCelsiusILCompile_memcpy
(
    DWORD dwCount, bool recurse
)
{

//    if (dwCount)
//    {
//        xMOV_rm_imm (rmREG(rECX),dwCount)
//    }
//
//    xMOV_r_rm   (rEAX,rmREG(rECX))
//    xSHR_rm_imm (rmREG(rECX),2)
//    xAND_rm_imm (rmREG(rEAX),3)
//    xREP xMOVSD
//    xMOV_r_rm   (rECX,rmREG(rEAX))
//    xREP xMOVSB
//
    if (dwCount)
    {
        // do copy
        if (pDriverData->nvD3DPerfData.dwCPUFeatureSet & FS_KATMAI)
        {
            //
            // KNI copy
            //
            while (dwCount >= 64)
            {
                xMOVLPS_r_rm    (rXMM0,rmIND(rESI))
                xMOVHPS_r_rm    (rXMM0,rmIND8(rESI)) xOFS8(8)
                xMOVLPS_r_rm    (rXMM1,rmIND8(rESI)) xOFS8(16)
                xMOVHPS_r_rm    (rXMM1,rmIND8(rESI)) xOFS8(24)
                xMOVLPS_r_rm    (rXMM2,rmIND8(rESI)) xOFS8(32)
                xMOVHPS_r_rm    (rXMM2,rmIND8(rESI)) xOFS8(40)
                xMOVLPS_r_rm    (rXMM3,rmIND8(rESI)) xOFS8(48)
                xMOVHPS_r_rm    (rXMM3,rmIND8(rESI)) xOFS8(56)
                xADD_rm_imm     (rmREG(rESI),64)
                xMOVLPS_rm_r    (rmIND(rEDI),rXMM0)
                xMOVHPS_rm_r    (rmIND8(rEDI),rXMM0) xOFS8(8)
                xMOVLPS_rm_r    (rmIND8(rEDI),rXMM1) xOFS8(16)
                xMOVHPS_rm_r    (rmIND8(rEDI),rXMM1) xOFS8(24)
                xMOVLPS_rm_r    (rmIND8(rEDI),rXMM2) xOFS8(32)
                xMOVHPS_rm_r    (rmIND8(rEDI),rXMM2) xOFS8(40)
                xMOVLPS_rm_r    (rmIND8(rEDI),rXMM3) xOFS8(48)
                xMOVHPS_rm_r    (rmIND8(rEDI),rXMM3) xOFS8(56)
                xADD_rm_imm     (rmREG(rEDI),64)
                dwCount -= 64;
            }

            while (dwCount >= 16)
            {
                xMOVLPS_r_rm    (rXMM0,rmIND(rESI))
                xMOVHPS_r_rm    (rXMM0,rmIND8(rESI)) xOFS8(8)
                xADD_rm_imm     (rmREG(rESI),16)
                xMOVLPS_rm_r    (rmIND(rEDI),rXMM0)
                xMOVHPS_rm_r    (rmIND8(rEDI),rXMM0) xOFS8(8)
                xADD_rm_imm     (rmREG(rEDI),16)
                dwCount -= 16;
            }

            while (dwCount >= 8)
            {
                xMOV_r_rm    (rEAX,rmIND(rESI))
                xMOV_r_rm    (rECX,rmIND8(rESI)) xOFS8(4)
                xADD_rm_imm  (rmREG(rESI),8)
                xMOV_rm_r    (rmIND(rEDI),rEAX)
                xADD_rm_imm  (rmREG(rEDI),8)
                xMOV_rm_r    (rmIND8(rEDI),rECX) xOFS8(4 - 8)
                dwCount -= 8;
            }

            while (dwCount >= 4)
            {
                xMOV_r_rm    (rEAX,rmIND(rESI))
                xADD_rm_imm  (rmREG(rESI),4)
                xMOV_rm_r    (rmIND(rEDI),rEAX)
                xADD_rm_imm  (rmREG(rEDI),4)
                dwCount -= 4;
            }

            if (dwCount)
            {
                xMOV_rm_imm (rmREG(rECX),dwCount)
                xREP xMOVSB
            }
        }
        else if (pDriverData->nvD3DPerfData.dwCPUFeatureSet & FS_ATHLON)
        {
            //
            // AMD copy
            //
            bool needFemms = false;
            if (dwCount >= 16 && !recurse)
            {
                xFEMMS
                needFemms = true;
            }

            while (dwCount >= 64)
            {
                xMOVQ_r_rm      (rMM0,rmIND(rESI))
                xMOVQ_r_rm      (rMM1,rmIND8(rESI)) xOFS8(8)
                xMOVQ_r_rm      (rMM2,rmIND8(rESI)) xOFS8(16)
                xMOVQ_r_rm      (rMM3,rmIND8(rESI)) xOFS8(24)
                xMOVQ_r_rm      (rMM4,rmIND8(rESI)) xOFS8(32)
                xMOVQ_r_rm      (rMM5,rmIND8(rESI)) xOFS8(40)
                xMOVQ_r_rm      (rMM6,rmIND8(rESI)) xOFS8(48)
                xMOVQ_r_rm      (rMM7,rmIND8(rESI)) xOFS8(56)
                xADD_rm_imm     (rmREG(rESI),64)
                xMOVNTQ_rm_r    (rmIND(rEDI),rMM0)
                xMOVNTQ_rm_r    (rmIND8(rEDI),rMM1) xOFS8(8)
                xMOVNTQ_rm_r    (rmIND8(rEDI),rMM2) xOFS8(16)
                xMOVNTQ_rm_r    (rmIND8(rEDI),rMM3) xOFS8(24)
                xMOVNTQ_rm_r    (rmIND8(rEDI),rMM4) xOFS8(32)
                xMOVNTQ_rm_r    (rmIND8(rEDI),rMM5) xOFS8(40)
                xMOVNTQ_rm_r    (rmIND8(rEDI),rMM6) xOFS8(48)
                xMOVNTQ_rm_r    (rmIND8(rEDI),rMM7) xOFS8(56)
                xADD_rm_imm     (rmREG(rEDI),64)
                dwCount -= 64;
            }

            while (dwCount >= 16)
            {
                xMOVQ_r_rm      (rMM0,rmIND(rESI))
                xMOVQ_r_rm      (rMM1,rmIND8(rESI)) xOFS8(8)
                xADD_rm_imm     (rmREG(rESI),16)
                xMOVNTQ_rm_r    (rmIND(rEDI),rMM0)
                xMOVNTQ_rm_r    (rmIND8(rEDI),rMM1) xOFS8(8)
                xADD_rm_imm     (rmREG(rEDI),16)
                dwCount -= 16;
            }

            while (dwCount >= 8)
            {
                xMOV_r_rm    (rEAX,rmIND(rESI))
                xMOV_r_rm    (rECX,rmIND8(rESI)) xOFS8(4)
                xADD_rm_imm  (rmREG(rESI),8)
                xMOV_rm_r    (rmIND(rEDI),rEAX)
                xADD_rm_imm  (rmREG(rEDI),8)
                xMOV_rm_r    (rmIND8(rEDI),rECX) xOFS8(4 - 8)
                dwCount -= 8;
            }

            while (dwCount >= 4)
            {
                xMOV_r_rm    (rEAX,rmIND(rESI))
                xADD_rm_imm  (rmREG(rESI),4)
                xMOV_rm_r    (rmIND(rEDI),rEAX)
                xADD_rm_imm  (rmREG(rEDI),4)
                dwCount -= 4;
            }

            if (dwCount)
            {
                xMOV_rm_imm (rmREG(rECX),dwCount)
                xREP xMOVSB
            }

            if (needFemms)
            {
                xFEMMS
            }

        }
        else
        {
            //
            // normal 8086 copy
            //
            DWORD dwWordCount = dwCount / 4;
            if (dwWordCount)
            {
                xMOV_rm_imm (rmREG(rECX),dwWordCount)
                xREP xMOVSD
            }
            dwCount &= 3;
            if (dwCount)
            {
                xMOV_rm_imm (rmREG(rECX),dwCount)
                xREP xMOVSB
            }
        }
    }
    else
    {
        // variable length copy
        if ((pDriverData->nvD3DPerfData.dwCPUFeatureSet & FS_KATMAI) || (pDriverData->nvD3DPerfData.dwCPUFeatureSet & FS_ATHLON))
        {
            bool needFemms = false;
            if (dwCount >= 16 && !recurse)
            {
                xFEMMS
                needFemms = true;
            }

            //
            // kni copy
            //
            DWORD label1;
            DWORD label2;
            // 64 byte xfers
            xLABEL      (label2)
            xCMP_rm_imm (rmREG(rECX),64)
            xLABEL      (label1)
            xJL32       (0)
            xPUSH_r     (rECX)
            nvCelsiusILCompile_memcpy (64, true);
            xPOP_r      (rECX)
            xLEA_r_rm   (rECX,rmIND8(rECX)) xOFS8(-64)
            xJMP        (label2)
            xTARGET_b32 (label1)
            // 16 byte xfers
            xLABEL      (label2)
            xCMP_rm_imm (rmREG(rECX),16)
            xLABEL      (label1)
            xJL32       (0)
            xPUSH_r     (rECX)
            nvCelsiusILCompile_memcpy (16, true);
            xPOP_r      (rECX)
            xLEA_r_rm   (rECX,rmIND8(rECX)) xOFS8(-16)
            xJMP        (label2)
            xTARGET_b32 (label1)
            // the rest
            xMOV_r_rm   (rEAX,rmREG(rECX))
            xSHR_rm_imm8(rmREG(rECX),2)
            xAND_rm_imm (rmREG(rEAX),3)
            xREP xMOVSD
            xMOV_r_rm   (rECX,rmREG(rEAX))
            xREP xMOVSB

            if (needFemms)
            {
                xFEMMS
            }
        }
        else
        {
            //
            // normal 8086 copy
            //
            xMOV_r_rm   (rEAX,rmREG(rECX))
            xSHR_rm_imm8(rmREG(rECX),2)
            xAND_rm_imm (rmREG(rEAX),3)
            xREP xMOVSD
            xMOV_r_rm   (rECX,rmREG(rEAX))
            xREP xMOVSB
        }
    }
}
// adds a base vertex index (16bit) to all 16bit chunks
// copies dwCount bytes from [esi] to [edi] with increment. if dwCount is zero then we copy ecx bytes
// we use esi,edi,eax and ecx. for kni we also use xmm0 to xmm3
void nvCelsiusILCompile_indexcpy
(
    DWORD dwCount
)
{
    if (dwCount)
    {
        // do copy
        if (pDriverData->nvD3DPerfData.dwCPUFeatureSet & FS_WILLAMETTE)
        {
            //
            // WNI copy
            //
            xMOV_r_i32      (rECX,mMEM32(global.celsius.dwBaseVertex))
            xSHL_rm_imm8    (rmREG(rECX),16)
            xOR_r_i32       (rECX,mMEM32(global.celsius.dwBaseVertex))
            xMOVDX_r_rm      (rXMM4, rmREG(rECX))
            xPSHUFLW_r_rm_imm (rXMM4, rmREG(rXMM4), 0)
            xPUNPCKLWDX_r_rm (rXMM4, rmREG(rXMM4))

            while (dwCount >= 64)
            {
                xMOVLPS_r_rm    (rXMM0,rmIND(rESI))
                xMOVHPS_r_rm    (rXMM0,rmIND8(rESI)) xOFS8(8)
                xPADDWX_r_rm    (rXMM0, rmREG(rXMM4))
                xMOVLPS_r_rm    (rXMM1,rmIND8(rESI)) xOFS8(16)
                xMOVHPS_r_rm    (rXMM1,rmIND8(rESI)) xOFS8(24)
                xPADDWX_r_rm    (rXMM1, rmREG(rXMM4))
                xMOVLPS_r_rm    (rXMM2,rmIND8(rESI)) xOFS8(32)
                xMOVHPS_r_rm    (rXMM2,rmIND8(rESI)) xOFS8(40)
                xPADDWX_r_rm    (rXMM2, rmREG(rXMM4))
                xMOVLPS_r_rm    (rXMM3,rmIND8(rESI)) xOFS8(48)
                xMOVHPS_r_rm    (rXMM3,rmIND8(rESI)) xOFS8(56)
                xPADDWX_r_rm    (rXMM3, rmREG(rXMM4))
                xADD_rm_imm     (rmREG(rESI),64)
                xMOVLPS_rm_r    (rmIND(rEDI),rXMM0)
                xMOVHPS_rm_r    (rmIND8(rEDI),rXMM0) xOFS8(8)
                xMOVLPS_rm_r    (rmIND8(rEDI),rXMM1) xOFS8(16)
                xMOVHPS_rm_r    (rmIND8(rEDI),rXMM1) xOFS8(24)
                xMOVLPS_rm_r    (rmIND8(rEDI),rXMM2) xOFS8(32)
                xMOVHPS_rm_r    (rmIND8(rEDI),rXMM2) xOFS8(40)
                xMOVLPS_rm_r    (rmIND8(rEDI),rXMM3) xOFS8(48)
                xMOVHPS_rm_r    (rmIND8(rEDI),rXMM3) xOFS8(56)
                xADD_rm_imm     (rmREG(rEDI),64)
                dwCount -= 64;
            }

            while (dwCount >= 16)
            {
                xMOVLPS_r_rm    (rXMM0,rmIND(rESI))
                xMOVHPS_r_rm    (rXMM0,rmIND8(rESI)) xOFS8(8)
                xPADDWX_r_rm    (rXMM0, rmREG(rXMM4))
                xADD_rm_imm     (rmREG(rESI),16)
                xMOVLPS_rm_r    (rmIND(rEDI),rXMM0)
                xMOVHPS_rm_r    (rmIND8(rEDI),rXMM0) xOFS8(8)
                xADD_rm_imm     (rmREG(rEDI),16)
                dwCount -= 16;
            }
        }
        else if (pDriverData->nvD3DPerfData.dwCPUFeatureSet & FS_KATMAI)
        {
            //
            // KNI copy - we use MMX because there's no integer add for KNI regs.
            //
            xEMMS
            xMOV_r_i32      (rECX,mMEM32(global.celsius.dwBaseVertex))
            xSHL_rm_imm8    (rmREG(rECX),16)
            xOR_r_i32       (rECX,mMEM32(global.celsius.dwBaseVertex))
            xMOVD_r_rm      (rMM4, rmREG(rECX))
            xPSHUFW_r_rm_imm (rMM4, rmREG(rMM4), 0)
            while (dwCount >= 64)
            {

                xMOVQ_r_rm      (rMM0,rmIND(rESI))
                xPADDW_r_rm     (rMM0, rmREG(rMM4))
                xMOVQ_r_rm      (rMM1,rmIND8(rESI)) xOFS8(8)
                xPADDW_r_rm     (rMM1, rmREG(rMM4))
                xMOVQ_r_rm      (rMM2,rmIND8(rESI)) xOFS8(16)
                xPADDW_r_rm     (rMM2, rmREG(rMM4))
                xMOVQ_r_rm      (rMM3,rmIND8(rESI)) xOFS8(24)
                xPADDW_r_rm     (rMM3, rmREG(rMM4))

                xMOVNTQ_rm_r    (rmIND(rEDI),rMM0)
                xMOVNTQ_rm_r    (rmIND8(rEDI),rMM1) xOFS8(8)
                xMOVNTQ_rm_r    (rmIND8(rEDI),rMM2) xOFS8(16)
                xMOVNTQ_rm_r    (rmIND8(rEDI),rMM3) xOFS8(24)

                xMOVQ_r_rm      (rMM0,rmIND8(rESI)) xOFS8(32)
                xPADDW_r_rm     (rMM0, rmREG(rMM4))
                xMOVQ_r_rm      (rMM1,rmIND8(rESI)) xOFS8(40)
                xPADDW_r_rm     (rMM1, rmREG(rMM4))
                xMOVQ_r_rm      (rMM2,rmIND8(rESI)) xOFS8(48)
                xPADDW_r_rm     (rMM2, rmREG(rMM4))
                xMOVQ_r_rm      (rMM3,rmIND8(rESI)) xOFS8(56)
                xPADDW_r_rm     (rMM3, rmREG(rMM4))

                xADD_rm_imm     (rmREG(rESI),64)


                xMOVNTQ_rm_r    (rmIND8(rEDI),rMM0) xOFS8(32)
                xMOVNTQ_rm_r    (rmIND8(rEDI),rMM1) xOFS8(40)
                xMOVNTQ_rm_r    (rmIND8(rEDI),rMM2) xOFS8(48)
                xMOVNTQ_rm_r    (rmIND8(rEDI),rMM3) xOFS8(56)
                xADD_rm_imm     (rmREG(rEDI),64)


                dwCount -= 64;
            }

            while (dwCount >= 16)
            {
                xMOVQ_r_rm      (rMM0,rmIND(rESI))
                xPADDW_r_rm     (rMM0, rmREG(rMM4))
                xMOVQ_r_rm      (rMM1,rmIND8(rESI)) xOFS8(8)
                xPADDW_r_rm     (rMM1, rmREG(rMM4))
                xADD_rm_imm     (rmREG(rESI),16)
                xMOVNTQ_rm_r    (rmIND(rEDI),rMM0)
                xMOVNTQ_rm_r    (rmIND8(rEDI),rMM1) xOFS8(8)
                xADD_rm_imm     (rmREG(rEDI),16)
                dwCount -= 16;
            }
            xEMMS

        }
        else if (pDriverData->nvD3DPerfData.dwCPUFeatureSet & FS_ATHLON)
        {
            //
            // AMD copy
            //
            xFEMMS
            xMOV_r_i32      (rECX,mMEM32(global.celsius.dwBaseVertex))
            xSHL_rm_imm8    (rmREG(rECX),16)
            xOR_r_i32       (rECX,mMEM32(global.celsius.dwBaseVertex))
            xMOVD_r_rm      (rMM4, rmREG(rECX))
            xPUNPCKLDQ_r_rm (rMM4, rmREG(rMM4))
            while (dwCount >= 64)
            {
                xMOVQ_r_rm      (rMM0,rmIND(rESI))
                xPADDW_r_rm     (rMM0, rmREG(rMM4))
                xMOVQ_r_rm      (rMM1,rmIND8(rESI)) xOFS8(8)
                xPADDW_r_rm     (rMM1, rmREG(rMM4))
                xMOVQ_r_rm      (rMM2,rmIND8(rESI)) xOFS8(16)
                xPADDW_r_rm     (rMM2, rmREG(rMM4))
                xMOVQ_r_rm      (rMM3,rmIND8(rESI)) xOFS8(24)
                xPADDW_r_rm     (rMM3, rmREG(rMM4))

                xMOVNTQ_rm_r    (rmIND(rEDI),rMM0)
                xMOVNTQ_rm_r    (rmIND8(rEDI),rMM1) xOFS8(8)
                xMOVNTQ_rm_r    (rmIND8(rEDI),rMM2) xOFS8(16)
                xMOVNTQ_rm_r    (rmIND8(rEDI),rMM3) xOFS8(24)

                xMOVQ_r_rm      (rMM0,rmIND8(rESI)) xOFS8(32)
                xPADDW_r_rm     (rMM0, rmREG(rMM4))
                xMOVQ_r_rm      (rMM1,rmIND8(rESI)) xOFS8(40)
                xPADDW_r_rm     (rMM1, rmREG(rMM4))
                xMOVQ_r_rm      (rMM2,rmIND8(rESI)) xOFS8(48)
                xPADDW_r_rm     (rMM2, rmREG(rMM4))
                xMOVQ_r_rm      (rMM3,rmIND8(rESI)) xOFS8(56)
                xPADDW_r_rm     (rMM3, rmREG(rMM4))

                xADD_rm_imm     (rmREG(rESI),64)


                xMOVNTQ_rm_r    (rmIND8(rEDI),rMM0) xOFS8(32)
                xMOVNTQ_rm_r    (rmIND8(rEDI),rMM1) xOFS8(40)
                xMOVNTQ_rm_r    (rmIND8(rEDI),rMM2) xOFS8(48)
                xMOVNTQ_rm_r    (rmIND8(rEDI),rMM3) xOFS8(56)
                xADD_rm_imm     (rmREG(rEDI),64)


                dwCount -= 64;
            }

            while (dwCount >= 16)
            {
                xMOVQ_r_rm      (rMM0,rmIND(rESI))
                xPADDW_r_rm     (rMM0, rmREG(rMM4))
                xMOVQ_r_rm      (rMM1,rmIND8(rESI)) xOFS8(8)
                xPADDW_r_rm     (rMM1, rmREG(rMM4))
                xADD_rm_imm     (rmREG(rESI),16)
                xMOVNTQ_rm_r    (rmIND(rEDI),rMM0)
                xMOVNTQ_rm_r    (rmIND8(rEDI),rMM1) xOFS8(8)
                xADD_rm_imm     (rmREG(rEDI),16)
                dwCount -= 16;
            }
            xFEMMS
        }
        if (dwCount)
        {
            //
            // normal 8086 copy
            //
            DWORD label;
            xLABEL (label)


            xMOV_r_i32  (rECX,mMEM32(global.celsius.dwBaseVertex))
            xSHL_rm_imm8 (rmREG(rECX),16)
            xOR_r_i32   (rECX,mMEM32(global.celsius.dwBaseVertex))
            //hmmm fully unrolled loop might not be the best... HMH
            //never mind, 64 indices is max (aka 32 moves)
            while (dwCount >= 4)
            {
                xMOV_r_rm    (rEAX,rmIND(rESI))
                xADD_rm_imm  (rmREG(rESI),4)
                xADD_r_rm    (rEAX, rmREG(rECX)) //add base index
                xMOV_rm_r    (rmIND(rEDI),rEAX)
                xADD_rm_imm  (rmREG(rEDI),4)
                dwCount -= 4;

            }
            if (dwCount) //it had better be 2
            {
                x16r xMOV_r_rm (rAX,rmIND(rESI))
                xADD_rm_imm  (rmREG(rESI),2)
                xADD_r_rm    (rEAX, rmREG(rECX)) //add base index
                xMOV_rm_r    (rmIND(rEDI),rAX)
                xADD_rm_imm  (rmREG(rEDI),2)
                dwCount -= 2;
            }
        }
    }
}

// vertex at ESI, pusher at EDI
//  thrashes eax,ebx,ecx,edx and ebp
void nvCelsiusILCompile_copyVertex_texMatrixFix
(
    PNVD3DCONTEXT pContext,
    DWORD         dwFlags,
    DWORD         dwD3DStage,
    DWORD         dwTCIndex,
    DWORD         dwInCount,
    DWORD         dwOutCount,
    BOOL          bProjected,
    DWORD        *pdwDstIndex
)
{
    // psuedo-C equivalent of the snippet below

    // D3DMATRIX *pMatrix = &(pContext->tssState[dwD3DStage].mTexTransformMatrix);
    // D3DVALUE dvCoordsIn[4], dvCoordsOut[4];
    // DWORD i;
    //
    // // fetch incoming coords
    // for (i = 0; i < dwInCount; i++) {
    //     dvCoordsIn[i] = rmIND8(rESI) xOFS8(i * 4 + fvfData.dwUVOffset[dwTCIndex])
    // }
    // // tack on a 1.0
    // dvCoordsIn[dwInCount] = 1.0;
    // // set the rest to zero
    // for (i = dwInCount+1; i < 4; i++) {
    //     dvCoordsIn[i] = 0;
    // }
    //
    // // transform
    // XformVector4 (D3DVALUE dvCoordsOut, D3DVALUE dvCoordsIn, pMatrix);
    //
    // // write out the real coordinates
    // for (i = 0; i < (dwOutCount - (bProjected ? 1 : 0)); i++) {
    //     xMOV_rm_r (rmIND8(rEDI), dvCoordsOut[i]) xOFS8(dwDstIndex)
    //     dwDstIndex += 4;
    // }
    // // pad with zeros
    // for (; i < 3; i++) {
    //     xMOV_rm_r (rmIND8(rEDI), 0);
    //     dwDstIndex += 4;
    // }
    // // fill the last slot with either 1.0 or the projected value
    // xMOV_rm_r (rmIND8(rEDI), bProjected ? dvCoordsOut[dwOutCount-1] : 1.0) xOFS8(dwDstIndex)
    // dwDstIndex += 4;

    //
    // get active tex transform matrix
    //
    xMOV_r_i32  (rEAX,mMEM32(global.celsius.pContext))
    xLEA_r_rm   (rEAX,rmIND32(rEAX)) xOFS32(OFFSETOF(NVD3DCONTEXT,tssState[dwD3DStage].mTexTransformMatrix))

    //
    // fetch
    //
    for (DWORD i = 0; i < dwInCount; i++)
    {
        xFLD_rm32 (rmIND8(rESI)) xOFS8(i * 4 + global.celsius.dwOffsetUV[dwTCIndex])
    }
    xFLD1
    for (i++; i < 4; i++)
    {
        xFLDZ
    }

    //
    // transform into temp space
    //
    for (i = 0; i < dwInCount; i++)
    {                                                           // w z y x
        xFLD_st (rST3)                                          // x w z y x
        xFMUL_rm (rmIND8(rEAX)) xOFS8((0*4+i)*4)                // x*m1i w z y x
        xFLD_st (rST3)                                          // y x*m1i w z y x
        xFLD_st (rST3)                                          // z y x*m1i w z y x
        xFMUL_rm (rmIND8(rEAX)) xOFS8((2*4+i)*4)                // z*m3i y x*m1i w z y x
        xFLD_st (rST3)                                          // w z*m3i y x*m1i w z y x
        xFMUL_rm (rmIND8(rEAX)) xOFS8((3*4+i)*4)                // w*m4i z*m3i y x*m1i w z y x
        xFXCH_st (rST2)                                         // y w*m4i z*m3i x*m1i w z y x
        xFMUL_rm (rmIND8(rEAX)) xOFS8((1*4+i)*4)                // y*m2i w*m4i z*m3i x*m1i w z y x
        xFADDP_st (rST1)                                        // y*m2i+w*m4i z*m3i x*m1i w z y x
        xFADDP_st (rST1)                                        // y*m2i+w*m4i+z*m3i x*m1i w z y x
        xFADDP_st (rST1)                                        // y*m2i+w*m4i+z*m3i+x*m1i w z y x
        xFSTP_i32 (KNIMEM(fRHW) + i*4)                          // w z y x
    }

    xFFREE_st (rST0)
    xFFREE_st (rST1)
    xFFREE_st (rST2)
    xFFREE_st (rST3)

    //
    // write out
    //
    for (i = 0; i < (dwOutCount - (bProjected ? 1 : 0)); i++)
    {
        xMOV_r_i32 (rEBX,KNIMEM(fRHW) + i*4)
        xMOV_rm_r (rmIND8(rEDI),rEBX) xOFS8(*pdwDstIndex)
        (*pdwDstIndex) += 4;
    }
    xXOR_r_rm (rEBX,rmREG(rEBX))
    for (; i < 3; i++) {
        xMOV_rm_r (rmIND8(rEDI),rEBX) xOFS8(*pdwDstIndex)
        (*pdwDstIndex) += 4;
    }
    // fill the last slot with either 1.0 or the projected value
    if (bProjected)
    {
        xMOV_r_i32 (rEBX,KNIMEM(fRHW) + 4*(dwOutCount-1))
    }
    else
    {
        xMOV_r_i32 (rEBX,KNIMEM(fOne))
    }
    xMOV_rm_r (rmIND8(rEDI),rEBX) xOFS8(*pdwDstIndex)
    (*pdwDstIndex) += 4;
}

// vertex at ESI, pusher at EDI
//  trashes eax,ebx,ecx,edx and ebp
void nvCelsiusILCompile_copyVertex
(
    PNVD3DCONTEXT pContext,
    DWORD         dwFlags
)
{
    CVertexShader *pVShader;
    DWORD          i;

    const DWORD    adwRegister[]        = { rEAX,rEBX,rECX,rEDX,rEBP };
    DWORD          dwDstIndex           = 0;
    DWORD          dwInlineVertexStride = pContext->hwState.dwInlineVertexStride;

    // cache the vertex shader
    pVShader = pContext->hwState.pVertexShader;
    nvAssert (pVShader);

    // rd: method
    xMOV_rm_imm (rmREG(rEAX),(((dwInlineVertexStride) << 16) | ((NV_DD_CELSIUS) << 13) | (NVPUSHER_NOINC(NV056_INLINE_ARRAY(0)))))

    // rd: b
    if (pVShader->bVAExists(defaultInputRegMap[D3DVSDE_BLENDWEIGHT]))
    {
        xMOV_r_rm   (rEBX,rmIND8(rESI)) xOFS8(global.celsius.dwOffsetWeight)
    }

    // rd: normal
    if (pVShader->bVAExists(defaultInputRegMap[D3DVSDE_NORMAL]))
    {
        xMOV_r_rm   (rECX,rmIND8(rESI)) xOFS8(global.celsius.dwOffsetNormal)
        xMOV_r_rm   (rEDX,rmIND8(rESI)) xOFS8(global.celsius.dwOffsetNormal + 4)
        xMOV_r_rm   (rEBP,rmIND8(rESI)) xOFS8(global.celsius.dwOffsetNormal + 8)
    }

    // wr: method
    xMOV_rm_r   (rmIND(rEDI),rEAX)
    dwDstIndex += 4;

    // wr: b
    if (pVShader->bVAExists(defaultInputRegMap[D3DVSDE_BLENDWEIGHT]))
    {
        xMOV_rm_r   (rmIND8(rEDI),rEBX) xOFS8(dwDstIndex)
        dwDstIndex += 4;
    }

    // wr: normal
    if (pVShader->bVAExists(defaultInputRegMap[D3DVSDE_NORMAL]))
    {
        xMOV_rm_r   (rmIND8(rEDI),rECX) xOFS8(dwDstIndex)
        xMOV_rm_r   (rmIND8(rEDI),rEDX) xOFS8(dwDstIndex + 4)
        xMOV_rm_r   (rmIND8(rEDI),rEBP) xOFS8(dwDstIndex + 8)
        dwDstIndex += 12;
    }

    // rd & wr: tex coords 1
    if (pContext->hwState.dwStateFlags & CELSIUS_FLAG_USERTEXCOORDSNEEDED(1))
    {
        DWORD dwD3DStage = pContext->hwState.dwTexUnitToTexStageMapping[1];
        DWORD dwTCIndex  = (pContext->hwState.dwTexCoordIndices >> 16) & 0xffff;
        DWORD dwVAIndex  = defaultInputRegMap[D3DVSDE_TEXCOORD0+dwTCIndex];
        DWORD dwCount    = (pContext->hwState.dwStateFlags & CELSIUS_FLAG_PASSTHROUGHCUBEMAPPING(1)) ?
                           3 : ((pVShader->getVASize(dwVAIndex)) >> 2);
        assert (dwCount < 5);

        if (pContext->hwState.dwStateFlags & CELSIUS_FLAG_TEXMATRIXSWFIX(1))
        {
            DWORD dwXFormFlags = pContext->tssState[dwD3DStage].dwValue[D3DTSS_TEXTURETRANSFORMFLAGS];
            DWORD dwOutCount   = dwXFormFlags & 0xff;
            BOOL  bProjected   = (dwXFormFlags & D3DTTFF_PROJECTED) ? TRUE : FALSE;
            nvCelsiusILCompile_copyVertex_texMatrixFix (pContext,dwFlags,dwD3DStage,dwTCIndex,dwCount,dwOutCount,bProjected,&dwDstIndex);
        }
        else
        {
            for (i=0; i<dwCount; i++) {
                xMOV_r_rm   (adwRegister[i],rmIND8(rESI)) xOFS8(i * 4 + global.celsius.dwOffsetUV[dwTCIndex])
            }
#ifdef STOMP_TEX_COORDS
            if (pContext->hwState.dwStateFlags & CELSIUS_FLAG_STOMP_4TH_COORD(1)) {
                xMOV_r_imm (adwRegister[3],0x3f800000)
            }
#endif  // STOMP_TEX_COORDS
            for (i=0; i<dwCount; i++) {
                xMOV_rm_r   (rmIND8(rEDI),adwRegister[i]) xOFS8(dwDstIndex)
                dwDstIndex += 4;
            }
            if (pContext->hwState.dwStateFlags & CELSIUS_FLAG_PASSTHROUGHCUBEMAPPING(1)) {
                xMOV_rm_r   (rmIND8(rEDI),adwRegister[2]) xOFS8(dwDstIndex)
                dwDstIndex += 4;
            }
        }
    }

    // rd & wr: tex coords 0
    if (pContext->hwState.dwStateFlags & CELSIUS_FLAG_USERTEXCOORDSNEEDED(0))
    {
        DWORD dwD3DStage = pContext->hwState.dwTexUnitToTexStageMapping[0];
        DWORD dwTCIndex  = (pContext->hwState.dwTexCoordIndices >> 0) & 0xffff;
        DWORD dwVAIndex  = defaultInputRegMap[D3DVSDE_TEXCOORD0+dwTCIndex];
        DWORD dwCount    = (pContext->hwState.dwStateFlags & CELSIUS_FLAG_PASSTHROUGHCUBEMAPPING(0)) ?
                           3 : ((pVShader->getVASize(dwVAIndex)) >> 2);
        assert (dwCount < 5);

        if (pContext->hwState.dwStateFlags & CELSIUS_FLAG_TEXMATRIXSWFIX(0))
        {
            DWORD dwXFormFlags = pContext->tssState[dwD3DStage].dwValue[D3DTSS_TEXTURETRANSFORMFLAGS];
            DWORD dwOutCount   = dwXFormFlags & 0xff;
            BOOL  bProjected   = (dwXFormFlags & D3DTTFF_PROJECTED) ? TRUE : FALSE;
            nvCelsiusILCompile_copyVertex_texMatrixFix (pContext,dwFlags,dwD3DStage,dwTCIndex,dwCount,dwOutCount,bProjected,&dwDstIndex);
        }
        else
        {
            for (DWORD i = 0; i < dwCount; i++)
            {
                xMOV_r_rm   (adwRegister[i],rmIND8(rESI)) xOFS8(i * 4 + global.celsius.dwOffsetUV[dwTCIndex])
            }
#ifdef STOMP_TEX_COORDS
            if (pContext->hwState.dwStateFlags & CELSIUS_FLAG_STOMP_4TH_COORD(0)) {
                xMOV_r_imm (adwRegister[3],0x3f800000)
            }
#endif  // STOMP_TEX_COORDS
            for (DWORD k = 0; k < dwCount; k++)
            {
                xMOV_rm_r   (rmIND8(rEDI),adwRegister[k]) xOFS8(dwDstIndex)
                dwDstIndex += 4;
            }
            if (pContext->hwState.dwStateFlags & CELSIUS_FLAG_PASSTHROUGHCUBEMAPPING(0))
            {
                xMOV_rm_r   (rmIND8(rEDI),adwRegister[2]) xOFS8(dwDstIndex)
                dwDstIndex += 4;
            }
        }
    }

    // rd: specular
    if (pVShader->bVAExists(defaultInputRegMap[D3DVSDE_SPECULAR]))
    {
        xMOV_r_rm   (rEAX,rmIND8(rESI)) xOFS8(global.celsius.dwOffsetSpecular)
    }

    // rd: diffuse
    if (pVShader->bVAExists(defaultInputRegMap[D3DVSDE_DIFFUSE]))
    {
        xMOV_r_rm   (rEBX,rmIND8(rESI)) xOFS8(global.celsius.dwOffsetDiffuse)
    }

    // rd: xyz
    nvAssert (pVShader->bVAExists(defaultInputRegMap[D3DVSDE_POSITION]));

    xMOV_r_rm   (rECX,rmIND8(rESI)) xOFS8(global.celsius.dwOffsetXYZ)
    xMOV_r_rm   (rEDX,rmIND8(rESI)) xOFS8(global.celsius.dwOffsetXYZ + 4)
    xMOV_r_rm   (rEBP,rmIND8(rESI)) xOFS8(global.celsius.dwOffsetXYZ + 8)

    // wr: specular
    if (pVShader->bVAExists(defaultInputRegMap[D3DVSDE_SPECULAR]))
    {
        xMOV_rm_r   (rmIND8(rEDI),rEAX) xOFS8(dwDstIndex)
        dwDstIndex += 4;
    }

    // wr: diffuse
    if (pVShader->bVAExists(defaultInputRegMap[D3DVSDE_DIFFUSE]))
    {
        xMOV_rm_r   (rmIND8(rEDI),rEBX) xOFS8(dwDstIndex)
        dwDstIndex += 4;
    }

    // wr: xyz
    xMOV_rm_r   (rmIND8(rEDI),rECX) xOFS8(dwDstIndex)
    xMOV_rm_r   (rmIND8(rEDI),rEDX) xOFS8(dwDstIndex + 4)
    xMOV_rm_r   (rmIND8(rEDI),rEBP) xOFS8(dwDstIndex + 8)
    dwDstIndex += 12;

    // rd & wr: rhw
    if (pVShader->getVASize(defaultInputRegMap[D3DVSDE_POSITION]) == 4*sizeof(DWORD))
    {
        xMOV_r_rm   (rEAX,rmIND8(rESI)) xOFS8(global.celsius.dwOffsetRHW)
        xMOV_rm_r   (rmIND8(rEDI),rEAX) xOFS8(dwDstIndex)
        dwDstIndex += 4;
    }

    // sanity check
    assert ((dwDstIndex - 4) == dwInlineVertexStride);

    // we can optionally print the vertex here
#if defined(DEBUG) || defined(NVSTATDRIVER)
    xMOV_rm_imm (rmREG(rEAX),(DWORD)nvCelsiusDispatchPrintVertex)
    xMOV_r_i32  (rEBX,mMEM32(global.celsius.pContext))
    xPUSH_r     (rEDI)
    xPUSH_r     (rEBX)
    xCALL_rm    (rmREG(rEAX))
#endif

    // adjust put
    xLEA_r_rm   (rEDI,rmIND8(rEDI)) xOFS8(dwDstIndex)
}

//
// range limit <only on NT> (dummy must be eax, ebx, ecx or edx)
//
void nvCelsiusILCompile_limit
(
    DWORD regLimit,
    DWORD regDummy
)
{
    assert ((regDummy == rEAX)
         || (regDummy == rEBX)
         || (regDummy == rECX)
         || (regDummy == rEDX));

#ifdef WINNT
    xXOR_r_rm   (regDummy,rmREG(regDummy))
    xCMP_r_i32  (regLimit,mMEM32(global.dwMaxVertexOffset))
    xSETAE_rm8  (rmREG(regDummy))
    xDEC_rm     (rmREG(regDummy))
    xAND_r_rm   (regLimit,rmREG(regDummy))
#endif
}

// prefetch data
//  will trash ESI, ECX, EDX, EAX
void nvCelsiusILCompile_prefetch
(
    BOOL bIsIndexed,
    BOOL bLegacyStrides
)
{
    if (bIsIndexed)
    {
        // prefetch & range check indices
        DWORD labelPrefetch1;
        DWORD labelPrefetch2;
        DWORD labelPrefetch3;
        DWORD labelPrefetch4;
        xLABEL      (labelPrefetch1)
        xMOV_r_i32  (rESI,mMEM32(global.celsius.dwPrefetchBase))
        xCMP_r_i32  (rESI,mMEM32(global.celsius.pIndices))
        xLABEL      (labelPrefetch2)
        xJA32       (0)

        xMOV_rm_imm (rmREG(rECX),2048 / global.celsius.dwVertexStride)
        xLABEL      (labelPrefetch4)
        {
            xPUSH_r     (rECX)
            // read index
            xXOR_r_rm   (rEDX,rmREG(rEDX))
       x16r xMOV_r_rm   (rDX,rmIND(rESI))
            xLEA_r_rm   (rESI,rmIND8(rESI)) xOFS8(2)
            if (bLegacyStrides)
            {
                xMOV_r_rm   (rEAX,rmREG(rESI))
                xSUB_r_i32  (rEAX,mMEM32(global.celsius.pIndexBase))
                xAND_rm_imm (rmREG(rEAX),6)
                xXOR_r_rm   (rECX,rmREG(rECX))
                xCMP_rm_imm (rmREG(rEAX),6)
                xSETNZ_rm8  (rmREG(rCL))
                xDEC_rm     (rmREG(rECX))
                xAND_rm_imm (rmREG(rECX),2)
                xADD_r_rm   (rESI,rmREG(rECX))
            }
            ILCCompile_mul (rEDX,global.celsius.dwVertexStride);
            // range limit
            nvCelsiusILCompile_limit (rEDX,rECX);
            // compute vertex address
            xADD_r_i32  (rEDX,mMEM32(global.celsius.pVertices))
            // prefetch
            xMOV_r_rm   (rEAX,rmIND(rEDX))
            if (global.celsius.dwVertexStride > 32)
            {
                xMOV_r_rm   (rEAX,rmIND8(rEDX)) xOFS8(32)
            }
            xMOV_rm_imm (rmREG(rEAX),0)
            // end of valid run?
            xPOP_r      (rECX)
            xCMP_r_i32  (rESI,mMEM32(global.celsius.dwPrefetchMax))
            xLABEL      (labelPrefetch3)
            xJAE32      (0)
            // next
            xDEC_rm     (rmREG(rECX))
        }
        xJNZ32      (labelPrefetch4)
        xTARGET_b32 (labelPrefetch3)
        xMOV_i32_r  (mMEM32(global.celsius.dwPrefetchBase),rESI)
        xTARGET_b32 (labelPrefetch2)
    }
    else
    {
        // prefetch & range check indices
        DWORD labelPrefetch1;
        DWORD labelPrefetch2;
        DWORD labelPrefetch3;
        DWORD labelPrefetch4;
        xLABEL      (labelPrefetch1)
        xMOV_r_i32  (rESI,mMEM32(global.celsius.dwPrefetchBase))
        xCMP_r_i32  (rESI,mMEM32(global.celsius.pVertices))
        xLABEL      (labelPrefetch2)
        xJA32       (0)

        xMOV_rm_imm (rmREG(rECX),2048 / global.celsius.dwVertexStride)
        xLABEL      (labelPrefetch4)
        {
            // prefetch
            xMOV_r_rm   (rEAX,rmIND(rESI))
            xMOV_rm_imm (rmREG(rEAX),0)
            xADD_rm_imm (rmREG(rESI),32)
            // end of valid run?
            xCMP_r_i32  (rESI,mMEM32(global.celsius.dwPrefetchMax))
            xLABEL      (labelPrefetch3)
            xJAE32      (0)
            // next
            xDEC_rm     (rmREG(rECX))
        }
        xJNZ32      (labelPrefetch4)
        xTARGET_b32 (labelPrefetch3)
        xMOV_i32_r  (mMEM32(global.celsius.dwPrefetchBase),rESI)
        xTARGET_b32 (labelPrefetch2)
    }
}

#endif  // NVARCH == 0x10
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\ddraw\celsius\src\nvCelsiusInlStrPrim.cpp ===
/*
* Copyright 1993-1998 NVIDIA, Corporation.  All rights reserved.
* THE INFORMATION CONTAINED HEREIN IS PROPRIETARY AND CONFIDENTIAL TO
* NVIDIA, CORPORATION.  USE, REPRODUCTION OR DISCLOSURE TO ANY THIRD PARTY
* IS SUBJECT TO WRITTEN PRE-APPROVAL BY NVIDIA, CORPORATION.
*/
/********************************* Direct 3D *******************************\
*                                                                           *
* Module: nvCelsiusInlPrim.cpp                                              *
*       indexed and ordered inline primitive                                *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*       Hadden Hoppert          20Oct99         Dx8 Stream support          *
*                                                                           *
\***************************************************************************/
#include "nvprecomp.h"

#if (NVARCH >= 0x10)

#include "x86.h"

//////////////////////////////////////////////////////////////////////////////
// aliases

#define ilcData     global.dwILCData
#define ilcCount    global.dwILCCount
#define ilcMax      global.dwILCMax

//=========================================================================

extern DWORD dwCelsiusMethodDispatch[11][16][2];

static int inline_renderorder[] = {
    D3DVSDE_BLENDWEIGHT,
    D3DVSDE_NORMAL,
    D3DVSDE_TEXCOORD1,
    D3DVSDE_TEXCOORD0,
    D3DVSDE_SPECULAR,
    D3DVSDE_DIFFUSE,
    D3DVSDE_POSITION
};

inline void vsCopyVertex(PVSHADERREGISTER pDest, DWORD dwSrc, DWORD dwType)
{
    switch(dwType)
    {
    case D3DVSDT_FLOAT1:
        pDest->x = ((float*)dwSrc)[0];
        pDest->y = 0.0f;
        pDest->z = 0.0f;
        pDest->w = 1.0f;
        break;
    case D3DVSDT_FLOAT2:
        pDest->x = ((float*)dwSrc)[0];
        pDest->y = ((float*)dwSrc)[1];
        pDest->z = 0.0f;
        pDest->w = 1.0f;
        break;
    case D3DVSDT_FLOAT3:
        pDest->x = ((float*)dwSrc)[0];
        pDest->y = ((float*)dwSrc)[1];
        pDest->z = ((float*)dwSrc)[2];
        pDest->w = 1.0f;
        break;
    case D3DVSDT_FLOAT4:
        pDest->x = ((float*)dwSrc)[0];
        pDest->y = ((float*)dwSrc)[1];
        pDest->z = ((float*)dwSrc)[2];
        pDest->w = ((float*)dwSrc)[3];
        break;
    case D3DVSDT_D3DCOLOR: {
        const DWORD v = *((DWORD*)dwSrc);
        pDest->x = RGBA_GETRED  (v) / 255.;
        pDest->y = RGBA_GETGREEN(v) / 255.;
        pDest->z = RGBA_GETBLUE (v) / 255.;
        pDest->w = RGBA_GETALPHA(v) / 255.;
        break;             }
    case D3DVSDT_UBYTE4:   {
        const BYTE *v = (BYTE*)dwSrc;
        pDest->x = v[0];
        pDest->y = v[1];
        pDest->z = v[2];
        pDest->w = v[3];
        break;             }
    case D3DVSDT_SHORT2:   {
        const SHORT *v = (SHORT*)dwSrc;
        pDest->x = v[0];
        pDest->y = v[1];
        pDest->z = 0.0f;
        pDest->w = 1.0f;
        break;             }
    case D3DVSDT_SHORT4:   {
        const SHORT *v = (SHORT*)dwSrc;
        pDest->x = v[0];
        pDest->y = v[1];
        pDest->z = v[2];
        pDest->w = v[3];
        break;             }
    default:
        DPF("Unknown vertex type");
        nvAssert(0);
    }
}

//---------------------------------------------------------------------------

__inline void pushPassthruCubeMapCoords (DWORD *pPusherIndex, PBYTE pVAData)
{
    // expand the three incoming coords into 4 slots
    nvPushData (*pPusherIndex, *(DWORD*)(pVAData + 0*sizeof(DWORD)));    (*pPusherIndex)++;
    nvPushData (*pPusherIndex, *(DWORD*)(pVAData + 1*sizeof(DWORD)));    (*pPusherIndex)++;
    nvPushData (*pPusherIndex, 0);                                       (*pPusherIndex)++;
    nvPushData (*pPusherIndex, *(DWORD*)(pVAData + 2*sizeof(DWORD)));    (*pPusherIndex)++;
}

//---------------------------------------------------------------------------

void pushTransformedTexCoords (DWORD *pPusherIndex, PBYTE pVAData, DWORD dwHWStage, DWORD dwInCount)
{
    PNVD3DCONTEXT pContext     = (PNVD3DCONTEXT)(global.celsius.pContext);
    DWORD         dwD3DStage   = pContext->hwState.dwTexUnitToTexStageMapping[dwHWStage];
    DWORD         dwXFormFlags = pContext->tssState[dwD3DStage].dwValue[D3DTSS_TEXTURETRANSFORMFLAGS];
    DWORD         dwOutCount   = dwXFormFlags & 0xff;
    BOOL          bProjected   = (dwXFormFlags & D3DTTFF_PROJECTED) ? TRUE : FALSE;
    D3DMATRIX    *pMatrix      = &(pContext->tssState[dwD3DStage].mTexTransformMatrix);
    D3DVALUE      dvCoordsIn[4], dvCoordsOut[4];

    // fetch incoming coords
    for (DWORD ii = 0; ii < dwInCount; ii++) {
        dvCoordsIn[ii] = *(D3DVALUE*)(pVAData + ii*sizeof(DWORD));
    }
    // tack on a 1.0
    dvCoordsIn[dwInCount] = 1.0;
    // set the rest to zero
    for (ii = dwInCount+1; ii < 4; ii++) {
        dvCoordsIn[ii] = 0;
    }
    // transform
    XformVector4 (dvCoordsOut, dvCoordsIn, pMatrix);
    // write out the real coordinates
    for (ii = 0; ii < (dwOutCount - (bProjected ? 1 : 0)); ii++) {
        nvPushData (*pPusherIndex, DWORD_FROM_FLOAT(dvCoordsOut[ii]));
        (*pPusherIndex)++;
    }
    // pad with zeros
    for (; ii < 3; ii++) {
        nvPushData (*pPusherIndex, 0);
        (*pPusherIndex)++;
    }
    // fill the last slot with either 1.0 or the projected value
    nvPushData (*pPusherIndex, bProjected ?
                               DWORD_FROM_FLOAT(dvCoordsOut[dwOutCount-1]) :
                               FP_ONE_BITS);
    (*pPusherIndex)++;
}

//---------------------------------------------------------------------------

void __cdecl nvCelsiusDumpStrPrimData (DWORD dwFlags)
{
    if (!global.celsius.dwPrimCount) return;

    PNVD3DCONTEXT pContext = (PNVD3DCONTEXT)(global.celsius.pContext);

    CVertexShader *pVertexShader  = pContext->pCurrentVShader;

    BOOL   bIsIndexed             = (dwFlags & CELSIUS_ILMASK_LOOPTYPE) <= CELSIUS_ILFLAG_IX_DVB_TRI;
    DWORD  dwMagic                = celsiusPrimitiveToPrimitiveMagic[dwFlags & CELSIUS_ILMASK_PRIMTYPE];
    DWORD  dwVerticesPerPrim      = (dwMagic >> 8) & 0xff;
    DWORD  dwStartVerticesPerPrim = (dwMagic >> 0) & 0xff;
    DWORD  dwCount = global.celsius.dwPrimCount * dwVerticesPerPrim + dwStartVerticesPerPrim;

    WORD  *pIndices = (WORD*)global.celsius.pIndices;
    DWORD  dwVertexBufferOffset = pContext->dp2.dwVStart;

    DWORD  dwCopyAddr  [NV_CAPS_MAX_STREAMS];
    DWORD  dwCopyLength[NV_CAPS_MAX_STREAMS];
    DWORD  dwCopyStride[NV_CAPS_MAX_STREAMS];

    DWORD  dwReg, dwStreamSelector;
    DWORD  dwD3DStage, dwHWStage, dwTCIndex, dwVAIndex;

    if (pVertexShader->hasProgram()) {

        // calculate fetch addresses
        for (dwReg = 0; dwReg < NV_CAPS_MAX_STREAMS; dwReg++)
        {
            dwStreamSelector = pVertexShader->getVAStream(dwReg);
            if (dwStreamSelector != CVertexShader::VA_STREAM_NONE)
            {
                CVertexBuffer *pStream = pContext->ppDX8Streams[dwStreamSelector];
                DPF_LEVEL (NVDBG_LEVEL_VSHADER_INFO, "reg: %02d , stream: %02d, type: %d, offset %02x, src: %x, flag: %d",
                           dwReg, pVertexShader->getVAStream(dwReg), pVertexShader->getVAType(dwReg),
                           pVertexShader->getVAOffset(dwReg), pVertexShader->getVASrc(dwReg), pVertexShader->getVAFlag(dwReg));
                dwCopyAddr  [dwReg]  = pStream->getAddress();
                dwCopyStride[dwReg]  = pStream->getVertexStride();
                dwCopyLength[dwReg]  = pVertexShader->getVASize(dwReg) / sizeof(DWORD);
                dwCopyAddr  [dwReg] += dwCopyStride[dwReg] * dwVertexBufferOffset + pVertexShader->getVAOffset(dwReg);
            }
            else
            {
                dwCopyAddr[dwReg] = 0;
            }
        }

        // VShader program
        nvPushData (0, ((1 << 2) << 16) | ((NV_DD_CELSIUS) << 13) | NV056_SET_BEGIN_END4);
        nvPushData (1, celsiusBeginEndOp[dwFlags & CELSIUS_ILMASK_PRIMTYPE]);
        nvPusherAdjust (2);

        // get the vertex program
        void *pfVertexProgram = (void *)pVertexShader->m_ProgramOutput.residentProgram;

        // counter
        DWORD k = 0;

        if (bIsIndexed)
        {
            while (k < dwCount)
            {
                // load
                for (dwReg = 0; dwReg < NV_CAPS_MAX_STREAMS; dwReg++)
                {
                    if (dwCopyAddr[dwReg])
                    {
                        vsCopyVertex (&pVertexShader->m_Attrib[dwReg],
                                      dwCopyAddr[dwReg] + pIndices[k] * dwCopyStride[dwReg],
                                      pVertexShader->getVAType(dwReg));

                        DPF_LEVEL (NVDBG_LEVEL_VSHADER_IO, "reg[%2d] indx (%f, %f, %f, %f)", dwReg,
                                   pVertexShader->m_Attrib[dwReg].x, pVertexShader->m_Attrib[dwReg].y,
                                   pVertexShader->m_Attrib[dwReg].z, pVertexShader->m_Attrib[dwReg].w);
                    }
                }

                // execute
                ((void (__cdecl *)(void *))pfVertexProgram)(NULL);

                // store
                for (int ii = 8; ii >= 0; ii--)
                {
                    DWORD  dwRegWriteMask = pVertexShader->m_ParsedProgram.resultRegsWritten[ii];
                    DWORD *pResult        = (DWORD*)&(pVertexShader->m_Result[ii]);

                    // data in this stream ?
                    if (dwRegWriteMask)
                    {
                        DWORD c1 = 0;
                        DWORD c2 = 0;
                        DWORD dwMethod = dwCelsiusMethodDispatch[ii][dwRegWriteMask][0];
                        DWORD dwCount  = dwCelsiusMethodDispatch[ii][dwRegWriteMask][1];

                        nvAssert (dwMethod != 0xDEADBEEF);

                        nvPushData (0,((((dwCount) << 2) << 16) | ((NV_DD_CELSIUS) << 13) | (dwMethod)));
                        // for all the reg components
                        while (dwRegWriteMask)
                        {
                            if (dwRegWriteMask & 1)
                            {
                                c1 ++;
                                nvPushData (c1, pResult[c2]);
                            }
                            dwRegWriteMask >>= 1;
                            c2 ++;
                        }

                        float *pFloat = (float*)pResult;
                        DPF_LEVEL (NVDBG_LEVEL_VSHADER_IO, "out(%2d): %x (%f, %f, %f, %f)", ii,
                                   dwMethod, pFloat[0], pFloat[1], pFloat[2], pFloat[3]);

                        nvPusherAdjust (dwCount + 1);
                    }
                }
                k++;
            }
        }

        else {

            // non indexed
            while (k < dwCount)
            {
                // load
                for (dwReg = 0; dwReg < NV_CAPS_MAX_STREAMS; dwReg++)
                {
                    if (dwCopyAddr[dwReg])
                    {
                        vsCopyVertex (&pVertexShader->m_Attrib[dwReg],
                                      dwCopyAddr[dwReg],
                                      pVertexShader->getVAType(dwReg));

                        DPF_LEVEL (NVDBG_LEVEL_VSHADER_IO, "reg[%2d] ninx (%f, %f, %f, %f)", dwReg,
                                   pVertexShader->m_Attrib[dwReg].x, pVertexShader->m_Attrib[dwReg].y,
                                   pVertexShader->m_Attrib[dwReg].z, pVertexShader->m_Attrib[dwReg].w);

                        dwCopyAddr[dwReg] += dwCopyStride[dwReg];
                    }
                }

                // execute
                ((void (__cdecl *)(void *))pfVertexProgram)(NULL);

                // store
                for (int ii = 8; ii >= 0; ii--)
                {
                    DWORD dwRegWriteMask = pVertexShader->m_ParsedProgram.resultRegsWritten[ii];
                    DWORD *pResult       = (DWORD*)&pVertexShader->m_Result[ii];

                    // data in this stream ?
                    if (dwRegWriteMask)
                    {
                        DWORD c1 = 0;
                        DWORD c2 = 0;
                        DWORD dwMethod = dwCelsiusMethodDispatch[ii][dwRegWriteMask][0];
                        DWORD dwCount  = dwCelsiusMethodDispatch[ii][dwRegWriteMask][1];

                        nvAssert (dwMethod != 0xDEADBEEF);

                        nvPushData (0,((((dwCount) << 2) << 16) | ((NV_DD_CELSIUS) << 13) | (dwMethod)));
                        // for all the reg components
                        while (dwRegWriteMask)
                        {
                            if (dwRegWriteMask & 1)
                            {
                                c1 ++;
                                nvPushData (c1, pResult[c2]);
                            }
                            dwRegWriteMask >>= 1;
                            c2 ++;
                        }

                        float *pFloat = (float*)pResult;
                        DPF_LEVEL (NVDBG_LEVEL_VSHADER_IO, "out(%2d): %x (%f, %f, %f, %f)", ii,
                                   dwMethod, pFloat[0], pFloat[1], pFloat[2], pFloat[3]);

                        nvPusherAdjust (dwCount + 1);
                    }
                }
                k++;
            }
        }
    }

    else {

        // no vertex program. we should be here because we have multiple DMAs
        nvAssert ((NV_NUM_UNIQUE_STREAMS(pContext->dwStreamDMACount) > 1)
               || (NV_NUM_SYSTEM_STREAMS(pContext->dwStreamDMACount) > 1));

        // calculate fetch addresses
        for (dwReg = defaultInputRegMap[D3DVSDE_POSITION]; dwReg < defaultInputRegMap[D3DVSDE_TEXCOORD0]; dwReg++)
        {
            dwStreamSelector = pVertexShader->getVAStream(dwReg);
            if (dwStreamSelector != CVertexShader::VA_STREAM_NONE)
            {
                CVertexBuffer *pStream = pContext->ppDX8Streams[dwStreamSelector];
                DPF_LEVEL (NVDBG_LEVEL_VSHADER_INFO, "reg: %02d , stream: %02d, type: %d, offset %02x, src: %x, flag: %d",
                           dwReg, pVertexShader->getVAStream(dwReg), pVertexShader->getVAType(dwReg),
                           pVertexShader->getVAOffset(dwReg), pVertexShader->getVASrc(dwReg), pVertexShader->getVAFlag(dwReg));
                dwCopyAddr  [dwReg]  = pStream->getAddress();
                dwCopyStride[dwReg]  = pStream->getVertexStride();
                dwCopyLength[dwReg]  = pVertexShader->getVASize(dwReg) / sizeof(DWORD);
                dwCopyAddr  [dwReg] += dwCopyStride[dwReg] * dwVertexBufferOffset + pVertexShader->getVAOffset(dwReg);
            }
            else
            {
                dwCopyAddr[dwReg] = 0;
            }
        }
        for (dwReg = defaultInputRegMap[D3DVSDE_TEXCOORD0]; dwReg < defaultInputRegMap[D3DVSDE_TEXCOORD2]; dwReg++)
        {
            dwHWStage = dwReg - defaultInputRegMap[D3DVSDE_TEXCOORD0];
            if (pContext->hwState.dwStateFlags & CELSIUS_FLAG_USERTEXCOORDSNEEDED(dwHWStage))
            {
                dwD3DStage = pContext->hwState.dwTexUnitToTexStageMapping[dwHWStage];
                nvAssert (dwD3DStage != CELSIUS_UNUSED);
                dwTCIndex  = (pContext->hwState.dwTexCoordIndices >> (16*dwHWStage)) & 0xffff;
                dwVAIndex  = defaultInputRegMap[D3DVSDE_TEXCOORD0+dwTCIndex];
                dwStreamSelector = pVertexShader->getVAStream (dwVAIndex);
                nvAssert ((dwStreamSelector != CVertexShader::VA_STREAM_NONE) && (pContext->ppDX8Streams[dwStreamSelector])); // they better have given us coordinates
                CVertexBuffer *pStream = pContext->ppDX8Streams[dwStreamSelector];
                DPF_LEVEL (NVDBG_LEVEL_VSHADER_INFO, "reg: %02d , stream: %02d, type: %d, offset %02x, src: %x, flag: %d",
                           dwReg, pVertexShader->getVAStream(dwVAIndex), pVertexShader->getVAType(dwVAIndex),
                           pVertexShader->getVAOffset(dwVAIndex), pVertexShader->getVASrc(dwVAIndex), pVertexShader->getVAFlag(dwVAIndex));
                dwCopyAddr  [dwReg]  = pStream->getAddress();
                dwCopyStride[dwReg]  = pStream->getVertexStride();
                dwCopyLength[dwReg]  = pVertexShader->getVASize(dwVAIndex) / sizeof(DWORD);
                dwCopyAddr  [dwReg] += dwCopyStride[dwReg] * dwVertexBufferOffset + pVertexShader->getVAOffset(dwVAIndex);
            }
            else
            {
                dwCopyAddr[dwReg] = 0;
            }
        }

        // fixed path
        nvPushData (0,((1 << 2) << 16) | ((NV_DD_CELSIUS) << 13) | NV056_SET_BEGIN_END4);
        nvPushData (1, celsiusBeginEndOp[dwFlags & CELSIUS_ILMASK_PRIMTYPE]);
        nvPusherAdjust(2);

        DWORD dwVertexSize = pContext->hwState.dwInlineVertexStride >> 2;
        DWORD dwPushed;

        for (DWORD k=0; k < dwCount; k++)
        {
            dwPushed = 0;
            getDC()->nvPusher.makeSpace(dwVertexSize + 1);
            getDC()->nvPusher.push (dwPushed, (dwVertexSize << 18) | (NV_DD_CELSIUS << 13) | NVPUSHER_NOINC(NV056_INLINE_ARRAY(0)));
            dwPushed++;

            for (DWORD i=0; i<7; i++)
            {
                DWORD dwCurrentArray = defaultInputRegMap[inline_renderorder[i]];
                PBYTE pVAData        = (PBYTE)(dwCopyAddr[dwCurrentArray]) + ((bIsIndexed ? pIndices[k] : k) * dwCopyStride[dwCurrentArray]);

                if (dwCopyAddr[dwCurrentArray])
                {
                    BOOL  bTex = ((dwCurrentArray == defaultInputRegMap[D3DVSDE_TEXCOORD0]) ||
                                  (dwCurrentArray == defaultInputRegMap[D3DVSDE_TEXCOORD1]));
                    DWORD dwTexIndex = dwCurrentArray - defaultInputRegMap[D3DVSDE_TEXCOORD0];

                    if (bTex && (pContext->hwState.dwStateFlags & CELSIUS_FLAG_PASSTHROUGHCUBEMAPPING(dwTexIndex))) {
                        pushPassthruCubeMapCoords (&dwPushed, pVAData);
                    }
                    else if (bTex && (pContext->hwState.dwStateFlags & CELSIUS_FLAG_TEXMATRIXSWFIX(dwTexIndex))) {
                        pushTransformedTexCoords (&dwPushed, pVAData, dwTexIndex, dwCopyLength[dwCurrentArray]);
                    }
                    else {
                        for (DWORD j=0; j < dwCopyLength[dwCurrentArray]; j++) {
                            nvPushData (dwPushed, *(DWORD*)(pVAData + j*sizeof(DWORD)));
                            dwPushed++;
                        }
                    }
                }
            }

            nvPusherAdjust(dwPushed);
        }

    }

    nvPushData (0,((1 << 2) << 16) | ((NV_DD_CELSIUS) << 13) | NV056_SET_BEGIN_END4);
    nvPushData (1, NV056_SET_BEGIN_END_OP_END);
    nvPusherAdjust(2);
}

//---------------------------------------------------------------------------

// must be used to handle the following cases not handled by the regular inner loops:
// 1. streams are coming from more than one context DMA
// 2. the current vertex shader includes a program

DWORD nvCelsiusILCompile_str_prim
(
    PNVD3DCONTEXT pContext,
    DWORD         dwFlags
)
{
    //
    // align entry point
    //
    while (ilcCount & 31) { xINT3 }
    DWORD lEntry;
    xLABEL (lEntry);

    //
    // setup stack frame
    //
    xPUSH_r     (rEBP)
    xPUSH_r     (rEBX)
    xPUSH_r     (rESI)
    xPUSH_r     (rEDI)

    //
    // verify that we are using the correct inner loop - debug only
    //
#ifdef DEBUG
        DWORD ld1,ld2;
    xLABEL      (ld1)
        xJMP        (0)
        xLABEL      (ld2)
        xINT3

#define CHECK(a,x)                  \
    {                                   \
    xMOV_rm_imm (rmREG(rEBX),a)     \
    xMOV_rm_imm (rmREG(rEAX),x)     \
    xCMP_r_i32  (rEAX,mMEM32(x))    \
    xJNZ32      (ld2)               \
    }
#define CHECK2(a,x,y,t)             \
    {                                   \
    xMOV_r_i32  (rEDX,mMEM32(global.celsius.x))    \
    xMOV_rm_imm (rmREG(rEBX),a)     \
    xMOV_rm_imm (rmREG(rEAX),x->y)   \
    xCMP_r_rm   (rEAX,rmIND32(rEDX)) xOFS32(OFFSETOF(t,y)) \
    xJNZ32      (ld2)               \
    }

        xTARGET_jmp (ld1)

        //  - pContext->hwState.dwStateFlags & CELSIUS_MASK_INNERLOOPUNIQUENESS
        xMOV_r_i32  (rEDX,mMEM32(global.celsius.pContext))
        xMOV_rm_imm (rmREG(rEBX),0x00040000)
        xMOV_r_rm   (rEAX,rmIND32(rEDX)) xOFS32(OFFSETOF(NVD3DCONTEXT,hwState.dwStateFlags))
        xAND_rm_imm (rmREG(rEAX),CELSIUS_MASK_INNERLOOPUNIQUENESS)
        xCMP_rm_imm (rmREG(rEAX),pContext->hwState.dwStateFlags & CELSIUS_MASK_INNERLOOPUNIQUENESS)
        xJNZ32      (ld2)

        if (pContext->hwState.dwStateFlags & CELSIUS_FLAG_USERTEXCOORDSNEEDED(0))
        {
            CHECK2 (0x00050000,pContext,hwState.dwTexUnitToTexStageMapping[0],NVD3DCONTEXT)
        }
        if (pContext->hwState.dwStateFlags & CELSIUS_FLAG_USERTEXCOORDSNEEDED(1))
        {
            CHECK2 (0x00050001,pContext,hwState.dwTexUnitToTexStageMapping[1],NVD3DCONTEXT)
        }
#endif

#if 1 //USE_C_LOGIC
        xMOV_rm_imm (rmREG(rEAX),dwFlags)
            xPUSH_r (rEAX)
            xMOV_rm_imm (rmREG(rEAX),nvCelsiusDumpStrPrimData)
            xCALL_rm (rmREG(rEAX))
            xADD_rm_imm (rmREG(rESP),4);
#else //USE_C_LOGIC
        nvAssert(0);
#endif
        //
        // done
        //
        xPOP_r      (rEDI)
        xPOP_r      (rESI)
        xPOP_r      (rEBX)
        xPOP_r      (rEBP)
        xRET
        return lEntry;
}
#endif  // NVARCH >= 0x010
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\ddraw\celsius\src\nvCelsiusNvTSS.cpp ===
// **************************************************************************
///
//       Copyright 1993-1999 NVIDIA, Corporation.  All rights reserved.
//
//     NOTICE TO USER:   The source code  is copyrighted under  U.S. and
//     international laws.  Users and possessors of this source code are
//     hereby granted a nonexclusive,  royalty-free copyright license to
//     use this code in individual and commercial software.
//
//     Any use of this source code must include,  in the user documenta-
//     tion and  internal comments to the code,  notices to the end user
//     as follows:
//
//       Copyright 1993-1999 NVIDIA, Corporation.  All rights reserved.
//
//     NVIDIA, CORPORATION MAKES NO REPRESENTATION ABOUT THE SUITABILITY
//     OF  THIS SOURCE  CODE  FOR ANY PURPOSE.  IT IS  PROVIDED  "AS IS"
//     WITHOUT EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORPOR-
//     ATION DISCLAIMS ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,
//     INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY, NONINFRINGE-
//     MENT,  AND FITNESS  FOR A PARTICULAR PURPOSE.   IN NO EVENT SHALL
//     NVIDIA, CORPORATION  BE LIABLE FOR ANY SPECIAL,  INDIRECT,  INCI-
//     DENTAL, OR CONSEQUENTIAL DAMAGES,  OR ANY DAMAGES  WHATSOEVER RE-
//     SULTING FROM LOSS OF USE,  DATA OR PROFITS,  WHETHER IN AN ACTION
//     OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,  ARISING OUT OF
//     OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOURCE CODE.
//
//     U.S. Government  End  Users.   This source code  is a "commercial
//     item,"  as that  term is  defined at  48 C.F.R. 2.101 (OCT 1995),
//     consisting  of "commercial  computer  software"  and  "commercial
//     computer  software  documentation,"  as such  terms  are  used in
//     48 C.F.R. 12.212 (SEPT 1995)  and is provided to the U.S. Govern-
//     ment only as  a commercial end item.   Consistent with  48 C.F.R.
//     12.212 and  48 C.F.R. 227.7202-1 through  227.7202-4 (JUNE 1995),
//     all U.S. Government End Users  acquire the source code  with only
//     those rights set forth herein.
//
// ********************************* Direct 3D ******************************
//
//  Module: nvCelsiusNvTSS.cpp
//      Celsius 2 stage combiner setup routines.
//
// **************************************************************************
//
//  History:
//      Lorie Sixia Deng       12Dec99         NV10 development
//
// **************************************************************************
#include "nvprecomp.h"

#if (NVARCH >= 0x10)

BOOL nvCheckBumpMapStates(PNVD3DCONTEXT pContext, int nStage)
{

    PNVD3DTEXSTAGESTATE ptssState0, ptssState1, ptssState2, ptssState3,
                        ptssState4, ptssState5, ptssState6, ptssState7;

    ptssState0 = &pContext->tssState[0];
    ptssState1 = &pContext->tssState[1];
    ptssState2 = &pContext->tssState[2];
    ptssState3 = &pContext->tssState[3];
    ptssState4 = &pContext->tssState[4];
    ptssState5 = &pContext->tssState[5];
    ptssState6 = &pContext->tssState[6];
    ptssState7 = &pContext->tssState[7];

    /*
    * Make specific check for our version of bump mapping.
    *
    * THIS IS A VERY SPECIFIC CHECK FOR OUR BUMP MAPPING ALGORITHM.  ALL CONDITIONS MUST BE
    * TRUE OR WE WILL FAIL VALIDATION AND NOT RENDER ANYTHING PREDICTABLE.
    *
    * Even though D3D specifies that Arg2 cannot be a texture, since we used to do this for
    * our bump mapping algorithm, I'm going to continue to allow it so that we don't break
    * anything.
    */

    if ((ptssState0->dwValue[D3DTSS_TEXTUREMAP] == NULL) ||
        (ptssState1->dwValue[D3DTSS_TEXTUREMAP] == NULL))
    {
        return FALSE;
    }

    if (nStage==4)
    {

        if ((ptssState0->dwValue[D3DTSS_ALPHAOP] != D3DTOP_SELECTARG1)
            || (ptssState0->dwValue[D3DTSS_ALPHAARG1] != (D3DTA_TEXTURE | D3DTA_COMPLEMENT))
            || (ptssState0->dwValue[D3DTSS_COLOROP] == D3DTOP_DISABLE)
            || (ptssState0->dwValue[D3DTSS_TEXCOORDINDEX] != 0)
            || (ptssState1->dwValue[D3DTSS_ALPHAOP] != D3DTOP_ADDSIGNED)
            || (!((ptssState1->dwValue[D3DTSS_ALPHAARG1] == D3DTA_TEXTURE)
            && (ptssState1->dwValue[D3DTSS_ALPHAARG2] == D3DTA_CURRENT))
            && !((ptssState1->dwValue[D3DTSS_ALPHAARG1] == D3DTA_CURRENT)
            && (ptssState1->dwValue[D3DTSS_ALPHAARG2] == D3DTA_TEXTURE)))
            || (ptssState1->dwValue[D3DTSS_COLOROP] == D3DTOP_DISABLE)
            || (ptssState1->dwValue[D3DTSS_TEXCOORDINDEX] != 1)
            || (ptssState2->dwValue[D3DTSS_ALPHAOP] != D3DTOP_DISABLE)
            || (ptssState2->dwValue[D3DTSS_COLOROP] != D3DTOP_ADDSIGNED2X)
            || (ptssState2->dwValue[D3DTSS_COLORARG1] != (D3DTA_CURRENT | D3DTA_COMPLEMENT | D3DTA_ALPHAREPLICATE))
            || (ptssState2->dwValue[D3DTSS_COLORARG2] != D3DTA_DIFFUSE)
            || (ptssState3->dwValue[D3DTSS_ALPHAOP] != D3DTOP_DISABLE)
            || (ptssState3->dwValue[D3DTSS_COLOROP] != D3DTOP_MODULATE)
            || (ptssState3->dwValue[D3DTSS_COLORARG1] != D3DTA_TEXTURE)
            || (ptssState3->dwValue[D3DTSS_TEXCOORDINDEX] != 0))
            return FALSE;

        else
            return TRUE;
    }

    else if (nStage==8)
    {
        /*
        * Check the alphaops and colorops.
        *
        * Stages 0, 2, 4, and 6 should all be set as D3DTOP_MODULATE.
        */
        if ((ptssState0->dwValue[D3DTSS_ALPHAOP] != D3DTOP_MODULATE)
            || (ptssState0->dwValue[D3DTSS_COLOROP] != D3DTOP_MODULATE)
            || (ptssState2->dwValue[D3DTSS_ALPHAOP] != D3DTOP_MODULATE)
            || (ptssState2->dwValue[D3DTSS_COLOROP] != D3DTOP_MODULATE)
            || (ptssState4->dwValue[D3DTSS_ALPHAOP] != D3DTOP_MODULATE)
            || (ptssState4->dwValue[D3DTSS_COLOROP] != D3DTOP_MODULATE)
            || (ptssState6->dwValue[D3DTSS_ALPHAOP] != D3DTOP_MODULATE)
            || (ptssState6->dwValue[D3DTSS_COLOROP] != D3DTOP_MODULATE))
            return FALSE;

        /*
        * Stages 3 and and 7 should all be set as D3DTOP_SELECTARG1
        */
        if ((ptssState3->dwValue[D3DTSS_ALPHAOP] != D3DTOP_SELECTARG1)
            || (ptssState3->dwValue[D3DTSS_COLOROP] != D3DTOP_SELECTARG1)
            || (ptssState7->dwValue[D3DTSS_ALPHAOP] != D3DTOP_SELECTARG1)
            || (ptssState7->dwValue[D3DTSS_COLOROP] != D3DTOP_SELECTARG1))
            return FALSE;

        /*
        * Stages 1 and 5 should be one of the following:
        * D3DTOP_ADD, D3DTOP_ADDSIGNED, D3DTOP_ADDSIGNED2X or D3DTOP_SUBTRACT.
        * We also allow D3DTOP_MODULATE2X and D3DTOP_MODULATE4X to be specified
        * but these operations are translated to ADD2 and ADD4 respectively.
        */
        if ((ptssState1->dwValue[D3DTSS_ALPHAOP] != D3DTOP_ADD)
            && (ptssState1->dwValue[D3DTSS_ALPHAOP] != D3DTOP_ADDSIGNED)
            && (ptssState1->dwValue[D3DTSS_ALPHAOP] != D3DTOP_ADDSIGNED2X)
            && (ptssState1->dwValue[D3DTSS_ALPHAOP] != D3DTOP_SUBTRACT)
            && (ptssState1->dwValue[D3DTSS_ALPHAOP] != D3DTOP_MODULATE2X)
            && (ptssState1->dwValue[D3DTSS_ALPHAOP] != D3DTOP_MODULATE4X))
            return FALSE;

        if ((ptssState1->dwValue[D3DTSS_COLOROP] != D3DTOP_ADD)
            && (ptssState1->dwValue[D3DTSS_COLOROP] != D3DTOP_ADDSIGNED)
            && (ptssState1->dwValue[D3DTSS_COLOROP] != D3DTOP_ADDSIGNED2X)
            && (ptssState1->dwValue[D3DTSS_COLOROP] != D3DTOP_SUBTRACT)
            && (ptssState1->dwValue[D3DTSS_COLOROP] != D3DTOP_MODULATE2X)
            && (ptssState1->dwValue[D3DTSS_COLOROP] != D3DTOP_MODULATE4X))
            return FALSE;

        if ((ptssState5->dwValue[D3DTSS_ALPHAOP] != D3DTOP_ADD)
            && (ptssState5->dwValue[D3DTSS_ALPHAOP] != D3DTOP_ADDSIGNED)
            && (ptssState5->dwValue[D3DTSS_ALPHAOP] != D3DTOP_ADDSIGNED2X)
            && (ptssState5->dwValue[D3DTSS_ALPHAOP] != D3DTOP_SUBTRACT)
            && (ptssState5->dwValue[D3DTSS_ALPHAOP] != D3DTOP_MODULATE2X)
            && (ptssState5->dwValue[D3DTSS_ALPHAOP] != D3DTOP_MODULATE4X))
            return FALSE;

        if ((ptssState5->dwValue[D3DTSS_COLOROP] != D3DTOP_ADD)
            && (ptssState5->dwValue[D3DTSS_COLOROP] != D3DTOP_ADDSIGNED)
            && (ptssState5->dwValue[D3DTSS_COLOROP] != D3DTOP_ADDSIGNED2X)
            && (ptssState5->dwValue[D3DTSS_COLOROP] != D3DTOP_SUBTRACT)
            && (ptssState5->dwValue[D3DTSS_COLOROP] != D3DTOP_MODULATE2X)
            && (ptssState5->dwValue[D3DTSS_COLOROP] != D3DTOP_MODULATE4X))
            return FALSE;

        return TRUE;

    }
    else
    {
        return FALSE;
    }
}

//set up the celsius combiners for either the current texture stage state
// or a legacy texture blend
HRESULT nvSetCelsius4StageBumpMapCombiners  (PNVD3DCONTEXT pContext)
{
    PNVD3DTEXSTAGESTATE ptssState0, ptssState1, ptssState2, ptssState3;

    //dbgTracePush ("nvSetCelsuisBumpMap1Combiners");

    /*
    * Set up some pointers to the individual texture stages.
    */
    ptssState0 = &pContext->tssState[0];
    ptssState1 = &pContext->tssState[1];
    ptssState2 = &pContext->tssState[2];
    ptssState3 = &pContext->tssState[3];

    /*
    * Set up Bump Mapping State.
    *
    * Texture0 and Texture1 comes from stage 0, 1 or 3 (always same texture).
    * Texture0 is used for stages with TEXCOORDINDEX = 0
    * Texture1 is used for stages with TEXCOORDINDEX = 1
    */
    pContext->hwState.dwTexUnitToTexStageMapping[0]=0;
    pContext->hwState.dwTexUnitToTexStageMapping[1]=1;
    pContext->hwState.dwNumActiveCombinerStages=2;

    pContext->hwState.dwAlphaICW[0] = DRF_NUM(056, _SET_COMBINER_ALPHA_ICW, _A_MAP,1)       // unsigned_invert
                                    | DRF_NUM(056, _SET_COMBINER_ALPHA_ICW, _A_ALPHA,1)
                                    | DRF_NUM(056, _SET_COMBINER_ALPHA_ICW, _A_SOURCE, 8)   // texture0
                                    | DRF_NUM(056, _SET_COMBINER_ALPHA_ICW, _B_MAP,1)       // replicate alpha
                                    | DRF_NUM(056, _SET_COMBINER_ALPHA_ICW, _B_ALPHA,1)
                                    | DRF_NUM(056, _SET_COMBINER_ALPHA_ICW, _B_SOURCE,0)
                                    | DRF_NUM(056, _SET_COMBINER_ALPHA_ICW, _C_MAP,0)
                                    | DRF_NUM(056, _SET_COMBINER_ALPHA_ICW, _C_ALPHA,1)
                                    | DRF_NUM(056, _SET_COMBINER_ALPHA_ICW, _C_SOURCE,9)    // texture1
                                    | DRF_NUM(056, _SET_COMBINER_ALPHA_ICW, _D_MAP,1)       // unsigned_invert
                                    | DRF_NUM(056, _SET_COMBINER_ALPHA_ICW, _D_ALPHA,1)
                                    | DRF_NUM(056, _SET_COMBINER_ALPHA_ICW, _D_SOURCE,0);

    pContext->hwState.dwAlphaOCW[0] = DRF_NUM(056, _SET_COMBINER_ALPHA_OCW, _OPERATION, 1)  // add bais
                                    | DRF_NUM(056, _SET_COMBINER_ALPHA_OCW,_MUX_ENABLE, 0)
                                    | DRF_NUM(056, _SET_COMBINER_ALPHA_OCW,_SUM_DST, 0xc)
                                    | DRF_NUM(056, _SET_COMBINER_ALPHA_OCW,_AB_DST, 0)
                                    | DRF_NUM(056, _SET_COMBINER_ALPHA_OCW,_CD_DST, 0);

    pContext->hwState.dwColorICW[0] = DRF_NUM(056, _SET_COMBINER_COLOR_ICW, _A_MAP,1)       // unsigned_invert
                                    | DRF_NUM(056, _SET_COMBINER_COLOR_ICW, _A_ALPHA,1)     // replicate alpha
                                    | DRF_NUM(056, _SET_COMBINER_COLOR_ICW, _A_SOURCE, 8)   // texture0
                                    | DRF_NUM(056, _SET_COMBINER_COLOR_ICW, _B_MAP,1)       // unsigned_invert
                                    | DRF_NUM(056, _SET_COMBINER_COLOR_ICW, _B_ALPHA,0)
                                    | DRF_NUM(056, _SET_COMBINER_COLOR_ICW, _B_SOURCE,0)
                                    | DRF_NUM(056, _SET_COMBINER_COLOR_ICW, _C_MAP,1)       // unsigned_invert
                                    | DRF_NUM(056, _SET_COMBINER_COLOR_ICW, _C_ALPHA,0)
                                    | DRF_NUM(056, _SET_COMBINER_COLOR_ICW, _C_SOURCE,0)
                                    | DRF_NUM(056, _SET_COMBINER_COLOR_ICW, _D_MAP,0)
                                    | DRF_NUM(056, _SET_COMBINER_COLOR_ICW, _D_ALPHA,1)     // replicate alpha
                                    | DRF_NUM(056, _SET_COMBINER_COLOR_ICW, _D_SOURCE,9);   // texture1

    pContext->hwState.dwColorOCW[0] = DRF_NUM(056, _SET_COMBINER0_COLOR_OCW, _OPERATION, 3) // add bais shiftleft by1
                                    | DRF_NUM(056, _SET_COMBINER0_COLOR_OCW,_MUX_ENABLE, 0)
                                    | DRF_NUM(056, _SET_COMBINER0_COLOR_OCW,_AB_DOT_ENABLE, 0)
                                    | DRF_NUM(056, _SET_COMBINER0_COLOR_OCW,_CD_DOT_ENABLE, 0)
                                    | DRF_NUM(056, _SET_COMBINER0_COLOR_OCW,_SUM_DST, 0xc)  // out put from combiner0
                                    | DRF_NUM(056, _SET_COMBINER0_COLOR_OCW,_AB_DST, 0)
                                    | DRF_NUM(056, _SET_COMBINER0_COLOR_OCW,_CD_DST, 0);

    pContext->hwState.dwAlphaICW[1] = DRF_NUM(056, _SET_COMBINER_ALPHA_ICW, _A_MAP,1)       // unsigned_invert
                                    | DRF_NUM(056, _SET_COMBINER_ALPHA_ICW, _A_ALPHA,1)
                                    | DRF_NUM(056, _SET_COMBINER_ALPHA_ICW, _A_SOURCE, 0)
                                    | DRF_NUM(056, _SET_COMBINER_ALPHA_ICW, _B_MAP,1)       // unsigned_invert
                                    | DRF_NUM(056, _SET_COMBINER_ALPHA_ICW, _B_ALPHA,1)
                                    | DRF_NUM(056, _SET_COMBINER_ALPHA_ICW, _B_SOURCE,0)
                                    | DRF_NUM(056, _SET_COMBINER_ALPHA_ICW, _C_MAP,0)
                                    | DRF_NUM(056, _SET_COMBINER_ALPHA_ICW, _C_ALPHA,1)
                                    | DRF_NUM(056, _SET_COMBINER_ALPHA_ICW, _C_SOURCE,0)
                                    | DRF_NUM(056, _SET_COMBINER_ALPHA_ICW, _D_MAP,0)
                                    | DRF_NUM(056, _SET_COMBINER_ALPHA_ICW, _D_ALPHA,1)
                                    | DRF_NUM(056, _SET_COMBINER_ALPHA_ICW, _D_SOURCE,0);

    pContext->hwState.dwAlphaOCW[1] = DRF_NUM(056, _SET_COMBINER_ALPHA_OCW, _OPERATION, 0)  // add no shift
                                    | DRF_NUM(056, _SET_COMBINER_ALPHA_OCW,_MUX_ENABLE, 0)
                                    | DRF_NUM(056, _SET_COMBINER_ALPHA_OCW,_SUM_DST, 0xc)   // output from combiner0
                                    | DRF_NUM(056, _SET_COMBINER_ALPHA_OCW,_AB_DST, 0)
                                    | DRF_NUM(056, _SET_COMBINER_ALPHA_OCW,_CD_DST, 0);

    pContext->hwState.dwColorICW[1] = DRF_NUM(056, _SET_COMBINER_COLOR_ICW, _A_MAP,1)       // unsinged_invert
                                    | DRF_NUM(056, _SET_COMBINER_COLOR_ICW, _A_ALPHA,0)
                                    | DRF_NUM(056, _SET_COMBINER_COLOR_ICW, _A_SOURCE, 0xc) // output from combiner0
                                    | DRF_NUM(056, _SET_COMBINER_COLOR_ICW, _B_MAP,0)
                                    | DRF_NUM(056, _SET_COMBINER_COLOR_ICW, _B_ALPHA,0)
                                    | DRF_NUM(056, _SET_COMBINER_COLOR_ICW, _B_SOURCE,8)    // texture0
                                    | DRF_NUM(056, _SET_COMBINER_COLOR_ICW, _C_MAP,0)
                                    | DRF_NUM(056, _SET_COMBINER_COLOR_ICW, _C_ALPHA,0)
                                    | DRF_NUM(056, _SET_COMBINER_COLOR_ICW, _C_SOURCE,8)    // texture0
                                    | DRF_NUM(056, _SET_COMBINER_COLOR_ICW, _D_MAP,0)
                                    | DRF_NUM(056, _SET_COMBINER_COLOR_ICW, _D_ALPHA,0)
                                    | DRF_NUM(056, _SET_COMBINER_COLOR_ICW, _D_SOURCE,4);   // diffuse

    pContext->hwState.dwColorOCW[1] = DRF_NUM(056, _SET_COMBINER1_COLOR_OCW, _ITERATION_COUNT, 2) // use both cominbers
                                    | DRF_NUM(056, _SET_COMBINER1_COLOR_OCW,_MUX_SELECT, 0)
                                    | DRF_NUM(056, _SET_COMBINER1_COLOR_OCW, _OPERATION, 0)
                                    | DRF_NUM(056, _SET_COMBINER1_COLOR_OCW,_MUX_ENABLE, 0)
                                    | DRF_NUM(056, _SET_COMBINER1_COLOR_OCW,_AB_DOT_ENABLE, 0)
                                    | DRF_NUM(056, _SET_COMBINER1_COLOR_OCW,_CD_DOT_ENABLE, 0)
                                    | DRF_NUM(056, _SET_COMBINER1_COLOR_OCW,_SUM_DST, 0xc)  // output from cominber0
                                    | DRF_NUM(056, _SET_COMBINER1_COLOR_OCW,_AB_DST, 0)
                                    | DRF_NUM(056, _SET_COMBINER1_COLOR_OCW,_CD_DST, 0);

#if COMBINER_STATUS
    DPF ("Result in 4 stage bump mapping set up");
    DPF ("   color icw[0] = 0x%08x", pContext->hwState.dwColorICW[0]);
    DPF ("   color ocw[0] = 0x%08x", pContext->hwState.dwColorOCW[0]);
    DPF ("   alpha icw[0] = 0x%08x", pContext->hwState.dwAlphaICW[0]);
    DPF ("   alpha ocw[0] = 0x%08x", pContext->hwState.dwAlphaOCW[0]);
    DPF ("   color icw[1] = 0x%08x", pContext->hwState.dwColorICW[1]);
    DPF ("   color ocw[1] = 0x%08x", pContext->hwState.dwColorOCW[1]);
    DPF ("   alpha icw[1] = 0x%08x", pContext->hwState.dwAlphaICW[1]);
    DPF ("   alpha ocw[1] = 0x%08x", pContext->hwState.dwAlphaOCW[1]);
    __asm int 3;
#endif

    return (D3D_OK);
}

HRESULT nvSetCelsius8StageBumpMapCombiners(PNVD3DCONTEXT pContext)
{
    DWORD                   operation, finDst;
    DWORD                   argASource, argAMap, argAAlpha;
    DWORD                   argBSource, argBMap, argBAlpha;
    DWORD                   argCSource, argCMap, argCAlpha;
    DWORD                   argDSource, argDMap, argDAlpha;
    PNVD3DTEXSTAGESTATE     ptssState0, ptssState1, ptssState2, ptssState3, ptssState4, ptssState5, ptssState6, ptssState7;
    PNVD3DTEXSTAGESTATE     ptssTexture0, ptssTexture1;

    finDst=0xc;

    //dbgTracePush ("nvSetCelsuisBumpMap2Combiners");

    /*
     * Set up some pointers to the individual texture stages.
     */
    ptssState0 = &pContext->tssState[0];
    ptssState1 = &pContext->tssState[1];
    ptssState2 = &pContext->tssState[2];
    ptssState3 = &pContext->tssState[3];
    ptssState4 = &pContext->tssState[4];
    ptssState5 = &pContext->tssState[5];
    ptssState6 = &pContext->tssState[6];
    ptssState7 = &pContext->tssState[7];
    // pmtsState  = &pContext->mtsState;


    /*
     * Next track down all the textures being used.
     * The method for selecting the textures is simple:
     *   Map Stage 0 Texture/TextureCoordIndex to TEXTURE0.
     *   Map Stage 1 Texture/TextureCoordIndex to TEXTURE1.
     */

    ptssTexture0 = &pContext->tssState[0];
    ptssTexture1 = &pContext->tssState[1];

    pContext->hwState.dwTexUnitToTexStageMapping[0]=0;
    pContext->hwState.dwTexUnitToTexStageMapping[1]=1;
    pContext->hwState.dwNumActiveCombinerStages=2;


    /*
     * Setup hardware texture combiner 0 alpha components based on texture stages 0-3.
     * Operation comes from AlphaOp of stage 1.
     * Arguments come from AlphaArg1 of stages 0-3.
     */
    switch (ptssState1->dwValue[D3DTSS_ALPHAOP])
    {
    case D3DTOP_ADD:
        operation = NV056_SET_COMBINER_ALPHA_OCW_OPERATION_NOSHIFT;
        break;
    case D3DTOP_ADDSIGNED:
        operation = NV056_SET_COMBINER_ALPHA_OCW_OPERATION_NOSHIFT_BIAS;
        break;
    case D3DTOP_ADDSIGNED2X:
        operation = NV056_SET_COMBINER_ALPHA_OCW_OPERATION_SHIFTLEFTBY1_BIAS;
        break;
    case D3DTOP_SUBTRACT:
        operation = NV056_SET_COMBINER_ALPHA_OCW_OPERATION_NOSHIFT;
        pContext->hwState.dwStateFlags |= (CELSIUS_FLAG_ADDCOMPLEMENTALPHA(0));
        break;
    case D3DTOP_MODULATE2X:
        operation = NV056_SET_COMBINER_ALPHA_OCW_OPERATION_SHIFTLEFTBY1;
        break;
    case D3DTOP_MODULATE4X:
        operation = NV056_SET_COMBINER_ALPHA_OCW_OPERATION_SHIFTLEFTBY2;
        break;
    }

    /*
     * Select Alpha Argument A Combiner 0.
     */
    switch (ptssState0->dwValue[D3DTSS_ALPHAARG1] & D3DTA_SELECTMASK)
    {
    case D3DTA_DIFFUSE:
        argASource = NV056_SET_COMBINER_ALPHA_ICW_A_SOURCE_REG_4;
        break;
    case D3DTA_CURRENT:
        argASource = NV056_SET_COMBINER_ALPHA_ICW_A_SOURCE_REG_4;
        break;
    case D3DTA_TEXTURE:
        if (ptssTexture0 && ((ptssState0->dwValue[D3DTSS_ALPHAARG2] & D3DTA_SELECTMASK) != D3DTA_TEXTURE))
            argASource = NV056_SET_COMBINER_ALPHA_ICW_A_SOURCE_REG_8;
        else if (ptssTexture1 && ((ptssState0->dwValue[D3DTSS_ALPHAARG2] & D3DTA_SELECTMASK) == D3DTA_TEXTURE))
            argASource = NV056_SET_COMBINER_ALPHA_ICW_A_SOURCE_REG_9;
        else
            argASource = NV056_SET_COMBINER_ALPHA_ICW_A_SOURCE_REG_4;
        break;
    case D3DTA_TFACTOR:
        if ((ptssState0->dwValue[D3DTSS_ALPHAARG2] & D3DTA_SELECTMASK) != D3DTA_TFACTOR)
            argASource = NV056_SET_COMBINER_ALPHA_ICW_A_SOURCE_REG_1;
        else
            argASource = NV056_SET_COMBINER_ALPHA_ICW_A_SOURCE_REG_0;
        break;
    }
    argAMap=!((ptssState0->dwValue[D3DTSS_ALPHAARG1] & D3DTA_COMPLEMENT) == 0);

    /*
     * Select Alpha Argument B Combiner 0.
     */
    switch (ptssState1->dwValue[D3DTSS_ALPHAARG1] & D3DTA_SELECTMASK)
    {
    case D3DTA_DIFFUSE:
        argBSource = NV056_SET_COMBINER_ALPHA_ICW_A_SOURCE_REG_4;
        break;
    case D3DTA_CURRENT:
        argBSource = NV056_SET_COMBINER_ALPHA_ICW_A_SOURCE_REG_4;
        break;
    case D3DTA_TEXTURE:
        if (ptssTexture0 && ((ptssState1->dwValue[D3DTSS_ALPHAARG2] & D3DTA_SELECTMASK) != D3DTA_TEXTURE))
            argBSource = NV056_SET_COMBINER_ALPHA_ICW_A_SOURCE_REG_8;
        else if (ptssTexture1 && ((ptssState1->dwValue[D3DTSS_ALPHAARG2] & D3DTA_SELECTMASK) == D3DTA_TEXTURE))
            argBSource = NV056_SET_COMBINER_ALPHA_ICW_A_SOURCE_REG_8;
        else
            argBSource = NV056_SET_COMBINER_ALPHA_ICW_A_SOURCE_REG_4;
        break;
    case D3DTA_TFACTOR:
        if ((ptssState1->dwValue[D3DTSS_ALPHAARG2] & D3DTA_SELECTMASK) != D3DTA_TFACTOR)
            argBSource = NV056_SET_COMBINER_ALPHA_ICW_A_SOURCE_REG_1;
        else
            argBSource = NV056_SET_COMBINER_ALPHA_ICW_A_SOURCE_REG_0;
        break;
    }
    argBMap=!((ptssState1->dwValue[D3DTSS_ALPHAARG1] & D3DTA_COMPLEMENT) == 0);

    /*
    * Select Alpha Argument C Combiner 0.
    */
    switch (ptssState2->dwValue[D3DTSS_ALPHAARG1] & D3DTA_SELECTMASK)
    {
    case D3DTA_DIFFUSE:
        argCSource = NV056_SET_COMBINER_ALPHA_ICW_A_SOURCE_REG_4;
        break;
    case D3DTA_CURRENT:
        argCSource = NV056_SET_COMBINER_ALPHA_ICW_A_SOURCE_REG_4;
        break;
    case D3DTA_TEXTURE:
        if (ptssTexture0 && ((ptssState2->dwValue[D3DTSS_ALPHAARG2] & D3DTA_SELECTMASK) != D3DTA_TEXTURE))
            argCSource = NV056_SET_COMBINER_ALPHA_ICW_A_SOURCE_REG_8;
        else if (ptssTexture1 && ((ptssState2->dwValue[D3DTSS_ALPHAARG2] & D3DTA_SELECTMASK) == D3DTA_TEXTURE))
            argCSource = NV056_SET_COMBINER_ALPHA_ICW_A_SOURCE_REG_9;
        else
            argCSource = NV056_SET_COMBINER_ALPHA_ICW_A_SOURCE_REG_4;
        break;
    case D3DTA_TFACTOR:
        if ((ptssState2->dwValue[D3DTSS_ALPHAARG2] & D3DTA_SELECTMASK) != D3DTA_TFACTOR)
            argCSource = NV056_SET_COMBINER_ALPHA_ICW_A_SOURCE_REG_1;
        else
            argCSource = NV056_SET_COMBINER_ALPHA_ICW_A_SOURCE_REG_0;
        break;
    }
    argCMap=!((ptssState2->dwValue[D3DTSS_ALPHAARG1] & D3DTA_COMPLEMENT) == 0);

    /*
     * Select Alpha Argument D Combiner 0.
     */
    switch (ptssState3->dwValue[D3DTSS_ALPHAARG1] & D3DTA_SELECTMASK)
    {
    case D3DTA_DIFFUSE:
        argDSource = NV056_SET_COMBINER_ALPHA_ICW_A_SOURCE_REG_4;
        break;
    case D3DTA_CURRENT:
        argDSource = NV056_SET_COMBINER_ALPHA_ICW_A_SOURCE_REG_4;
        break;
    case D3DTA_TEXTURE:
        if (ptssTexture0 && ((ptssState3->dwValue[D3DTSS_ALPHAARG2] & D3DTA_SELECTMASK) != D3DTA_TEXTURE))
            argDSource = NV056_SET_COMBINER_ALPHA_ICW_A_SOURCE_REG_8;
        else if (ptssTexture1 && ((ptssState3->dwValue[D3DTSS_ALPHAARG2] & D3DTA_SELECTMASK) == D3DTA_TEXTURE))
            argDSource = NV056_SET_COMBINER_ALPHA_ICW_A_SOURCE_REG_9;
        else
            argDSource = NV056_SET_COMBINER_ALPHA_ICW_A_SOURCE_REG_4;
        break;
    case D3DTA_TFACTOR:
        if ((ptssState3->dwValue[D3DTSS_ALPHAARG2] & D3DTA_SELECTMASK) != D3DTA_TFACTOR)
            argDSource = NV056_SET_COMBINER_ALPHA_ICW_A_SOURCE_REG_1;
        else
            argDSource = NV056_SET_COMBINER_ALPHA_ICW_A_SOURCE_REG_0;
        break;
    }
    argDMap=!((ptssState3->dwValue[D3DTSS_ALPHAARG1] & D3DTA_COMPLEMENT) == 0);

    /*
     * Program Texture Combine 0 Alpha Stage.
     */
    pContext->hwState.dwAlphaICW[0]= DRF_NUM(056, _SET_COMBINER_ALPHA_ICW, _A_MAP,argAMap)
                                |DRF_NUM(056, _SET_COMBINER_ALPHA_ICW, _A_ALPHA,1)
                                |DRF_NUM(056, _SET_COMBINER_ALPHA_ICW, _A_SOURCE, argASource)
                                |DRF_NUM(056, _SET_COMBINER_ALPHA_ICW, _B_MAP,argBMap)
                                |DRF_NUM(056, _SET_COMBINER_ALPHA_ICW, _B_ALPHA,1)
                                |DRF_NUM(056, _SET_COMBINER_ALPHA_ICW, _B_SOURCE,argBSource)
                                |DRF_NUM(056, _SET_COMBINER_ALPHA_ICW, _C_MAP,argCMap)
                                |DRF_NUM(056, _SET_COMBINER_ALPHA_ICW, _C_ALPHA,1)
                                |DRF_NUM(056, _SET_COMBINER_ALPHA_ICW, _C_SOURCE,argCSource)
                                |DRF_NUM(056, _SET_COMBINER_ALPHA_ICW, _D_MAP,argDMap)
                                |DRF_NUM(056, _SET_COMBINER_ALPHA_ICW, _D_ALPHA,1)
                                |DRF_NUM(056, _SET_COMBINER_ALPHA_ICW, _D_SOURCE,argDSource);

    pContext->hwState.dwAlphaOCW[0]=DRF_NUM(056, _SET_COMBINER_ALPHA_OCW, _OPERATION, operation)
                                |DRF_NUM(056, _SET_COMBINER_ALPHA_OCW,_MUX_ENABLE, 0)
                                |DRF_NUM(056, _SET_COMBINER_ALPHA_OCW,_SUM_DST, finDst)
                                |DRF_NUM(056, _SET_COMBINER_ALPHA_OCW,_AB_DST, 0)
                                |DRF_NUM(056, _SET_COMBINER_ALPHA_OCW,_CD_DST, 0);

    /*
    * Setup hardware texture combiner 0 color components based on texture stages 0-3.
    * Operation comes from ColorOp of stage 1.
    * Arguments come from ColorArg1 of stages 0-3.
    */
    switch (ptssState1->dwValue[D3DTSS_COLOROP])
    {
    case D3DTOP_ADD:
        operation = NV056_SET_COMBINER0_COLOR_OCW_OPERATION_NOSHIFT;
        break;
    case D3DTOP_ADDSIGNED:
        operation = NV056_SET_COMBINER0_COLOR_OCW_OPERATION_NOSHIFT_BIAS;
        break;
    case D3DTOP_ADDSIGNED2X:
        operation = NV056_SET_COMBINER0_COLOR_OCW_OPERATION_SHIFTLEFTBY1_BIAS;
        break;
    case D3DTOP_SUBTRACT:
        operation = NV056_SET_COMBINER0_COLOR_OCW_OPERATION_NOSHIFT;
        pContext->hwState.dwStateFlags |= (CELSIUS_FLAG_ADDCOMPLEMENTRGB(0));
        break;
    case D3DTOP_MODULATE2X:
        operation = NV056_SET_COMBINER0_COLOR_OCW_OPERATION_SHIFTLEFTBY1;
        break;
    case D3DTOP_MODULATE4X:
        operation = NV056_SET_COMBINER0_COLOR_OCW_OPERATION_SHIFTLEFTBY2;
        break;
    }

    /*
    * Select Color Argument A Combiner 0.
    */
    switch (ptssState0->dwValue[D3DTSS_COLORARG1] & D3DTA_SELECTMASK)
    {
    case D3DTA_DIFFUSE:
        argASource = NV056_SET_COMBINER_COLOR_ICW_A_SOURCE_REG_4;
        break;
    case D3DTA_CURRENT:
        argASource = NV056_SET_COMBINER_COLOR_ICW_A_SOURCE_REG_4;
        break;
    case D3DTA_TEXTURE:
        if (ptssTexture0 && ((ptssState0->dwValue[D3DTSS_COLORARG2] & D3DTA_SELECTMASK) != D3DTA_TEXTURE))
            argASource = NV056_SET_COMBINER_COLOR_ICW_A_SOURCE_REG_8;
        else if (ptssTexture1 && ((ptssState0->dwValue[D3DTSS_COLORARG2] & D3DTA_SELECTMASK) == D3DTA_TEXTURE))
            argASource = NV056_SET_COMBINER_COLOR_ICW_A_SOURCE_REG_9;
        else
            argASource = NV056_SET_COMBINER_COLOR_ICW_A_SOURCE_REG_4;
        break;
    case D3DTA_TFACTOR:
        if ((ptssState0->dwValue[D3DTSS_COLORARG2] & D3DTA_SELECTMASK) != D3DTA_TFACTOR)
            argASource = NV056_SET_COMBINER_COLOR_ICW_A_SOURCE_REG_1;
        else
            argASource = NV056_SET_COMBINER_COLOR_ICW_A_SOURCE_REG_0;
        break;
    }
    argAMap=!((ptssState0->dwValue[D3DTSS_COLORARG1] & D3DTA_COMPLEMENT) == 0);
    argAAlpha = !((ptssState0->dwValue[D3DTSS_COLORARG1] & D3DTA_ALPHAREPLICATE) == 0);

    /*
    * Select Color Argument B Combiner 0.
    */
    switch (ptssState1->dwValue[D3DTSS_COLORARG1] & D3DTA_SELECTMASK)
    {
    case D3DTA_DIFFUSE:
        argBSource = NV056_SET_COMBINER_COLOR_ICW_B_SOURCE_REG_4;
        break;
    case D3DTA_CURRENT:
        argBSource = NV056_SET_COMBINER_COLOR_ICW_B_SOURCE_REG_4;
        break;
    case D3DTA_TEXTURE:
        if (ptssTexture0 && ((ptssState1->dwValue[D3DTSS_COLORARG2] & D3DTA_SELECTMASK) != D3DTA_TEXTURE))
            argBSource = NV056_SET_COMBINER_COLOR_ICW_B_SOURCE_REG_8;
        else if (ptssTexture1 && ((ptssState1->dwValue[D3DTSS_COLORARG2] & D3DTA_SELECTMASK) == D3DTA_TEXTURE))
            argBSource = NV056_SET_COMBINER_COLOR_ICW_B_SOURCE_REG_9;
        else
            argBSource = NV056_SET_COMBINER_COLOR_ICW_B_SOURCE_REG_4;
        break;
    case D3DTA_TFACTOR:
        if ((ptssState1->dwValue[D3DTSS_COLORARG2] & D3DTA_SELECTMASK) != D3DTA_TFACTOR)
            argBSource = NV056_SET_COMBINER_COLOR_ICW_B_SOURCE_REG_1;
        else
            argBSource = NV056_SET_COMBINER_COLOR_ICW_B_SOURCE_REG_0;
        break;
    }
    argBMap=!((ptssState1->dwValue[D3DTSS_COLORARG1] & D3DTA_COMPLEMENT) == 0);
    argBAlpha = !((ptssState1->dwValue[D3DTSS_COLORARG1] & D3DTA_ALPHAREPLICATE) == 0);

    /*
    * Select Color Argument C Combiner 0.
    */
    switch (ptssState2->dwValue[D3DTSS_COLORARG1] & D3DTA_SELECTMASK)
    {
    case D3DTA_DIFFUSE:
        argCSource = NV056_SET_COMBINER_COLOR_ICW_C_SOURCE_REG_4;
        break;
    case D3DTA_CURRENT:
        argCSource = NV056_SET_COMBINER_COLOR_ICW_C_SOURCE_REG_4;
        break;
    case D3DTA_TEXTURE:
        if (ptssTexture0 && ((ptssState2->dwValue[D3DTSS_COLORARG2] & D3DTA_SELECTMASK) != D3DTA_TEXTURE))
            argCSource = NV056_SET_COMBINER_COLOR_ICW_C_SOURCE_REG_8;
        else if (ptssTexture1 && ((ptssState2->dwValue[D3DTSS_COLORARG2] & D3DTA_SELECTMASK) == D3DTA_TEXTURE))
            argCSource = NV056_SET_COMBINER_COLOR_ICW_C_SOURCE_REG_9;
        else
            argCSource = NV056_SET_COMBINER_COLOR_ICW_C_SOURCE_REG_4;
        break;
    case D3DTA_TFACTOR:
        if ((ptssState2->dwValue[D3DTSS_COLORARG2] & D3DTA_SELECTMASK) != D3DTA_TFACTOR)
            argCSource = NV056_SET_COMBINER_COLOR_ICW_C_SOURCE_REG_1;
        else
            argCSource = NV056_SET_COMBINER_COLOR_ICW_C_SOURCE_REG_0;
        break;
    }
    argCMap=!((ptssState2->dwValue[D3DTSS_COLORARG1] & D3DTA_COMPLEMENT) == 0);
    argCAlpha = !((ptssState2->dwValue[D3DTSS_COLORARG1] & D3DTA_ALPHAREPLICATE) == 0);

    /*
    * Select Color Argument D Combiner 0.
    */
    switch (ptssState3->dwValue[D3DTSS_COLORARG1] & D3DTA_SELECTMASK)
    {
    case D3DTA_DIFFUSE:
        argDSource = NV056_SET_COMBINER_COLOR_ICW_D_SOURCE_REG_4;
        break;
    case D3DTA_CURRENT:
        argDSource = NV056_SET_COMBINER_COLOR_ICW_D_SOURCE_REG_4;
        break;
    case D3DTA_TEXTURE:
        if (ptssTexture0 && ((ptssState3->dwValue[D3DTSS_COLORARG2] & D3DTA_SELECTMASK) != D3DTA_TEXTURE))
            argDSource = NV056_SET_COMBINER_COLOR_ICW_D_SOURCE_REG_8;
        else if (ptssTexture1 && ((ptssState3->dwValue[D3DTSS_COLORARG2] & D3DTA_SELECTMASK) == D3DTA_TEXTURE))
            argDSource = NV056_SET_COMBINER_COLOR_ICW_D_SOURCE_REG_9;
        else
            argDSource = NV056_SET_COMBINER_COLOR_ICW_D_SOURCE_REG_4;
        break;
    case D3DTA_TFACTOR:
        if ((ptssState3->dwValue[D3DTSS_COLORARG2] & D3DTA_SELECTMASK) != D3DTA_TFACTOR)
            argDSource = NV056_SET_COMBINER_COLOR_ICW_D_SOURCE_REG_1;
        else
            argDSource = NV056_SET_COMBINER_COLOR_ICW_D_SOURCE_REG_0;
        break;
    }
    argDMap=!((ptssState3->dwValue[D3DTSS_COLORARG1] & D3DTA_COMPLEMENT) == 0);
    argDAlpha = !((ptssState3->dwValue[D3DTSS_COLORARG1] & D3DTA_ALPHAREPLICATE) == 0);

    /*
    * Program Texture Combine 0 Color Stage.
    */
    pContext->hwState.dwColorICW[0]= DRF_NUM(056, _SET_COMBINER_COLOR_ICW, _A_MAP,argAMap)
                                        |DRF_NUM(056, _SET_COMBINER_COLOR_ICW, _A_ALPHA,argAAlpha)
                                        |DRF_NUM(056, _SET_COMBINER_COLOR_ICW, _A_SOURCE, argASource)
                                        |DRF_NUM(056, _SET_COMBINER_COLOR_ICW, _B_MAP,argBMap)
                                        |DRF_NUM(056, _SET_COMBINER_COLOR_ICW, _B_ALPHA,argBAlpha)
                                        |DRF_NUM(056, _SET_COMBINER_COLOR_ICW, _B_SOURCE,argBSource)
                                        |DRF_NUM(056, _SET_COMBINER_COLOR_ICW, _C_MAP,argCMap)
                                        |DRF_NUM(056, _SET_COMBINER_COLOR_ICW, _C_ALPHA,argCAlpha)
                                        |DRF_NUM(056, _SET_COMBINER_COLOR_ICW, _C_SOURCE,argCSource)
                                        |DRF_NUM(056, _SET_COMBINER_COLOR_ICW, _D_MAP,argDMap)
                                        |DRF_NUM(056, _SET_COMBINER_COLOR_ICW, _D_ALPHA,argDAlpha)
                                        |DRF_NUM(056, _SET_COMBINER_COLOR_ICW, _D_SOURCE,argDSource);

    pContext->hwState.dwColorOCW[0]= DRF_NUM(056, _SET_COMBINER0_COLOR_OCW, _OPERATION, operation)
                                        |DRF_NUM(056, _SET_COMBINER0_COLOR_OCW,_MUX_ENABLE, 0)
                                        |DRF_NUM(056, _SET_COMBINER0_COLOR_OCW,_AB_DOT_ENABLE, 0)
                                        |DRF_NUM(056, _SET_COMBINER0_COLOR_OCW,_CD_DOT_ENABLE, 0)
                                        |DRF_NUM(056, _SET_COMBINER0_COLOR_OCW,_SUM_DST, finDst)
                                        |DRF_NUM(056, _SET_COMBINER0_COLOR_OCW,_AB_DST, 0)
                                        |DRF_NUM(056, _SET_COMBINER0_COLOR_OCW,_CD_DST, 0);

    /*
    * Setup hardware texture combiner 1 alpha components based on texture stages 0-3.
    * Operation comes from AlphaOp of stage 5.
    * Arguments come from AlphaArg1 of stages 4-7.
    */

    argAMap=argBMap=argCMap=argDMap=0;

    switch (ptssState5->dwValue[D3DTSS_ALPHAOP])
    {
    case D3DTOP_ADD:
        operation = NV056_SET_COMBINER_ALPHA_OCW_OPERATION_NOSHIFT;
        break;
    case D3DTOP_ADDSIGNED:
        operation = NV056_SET_COMBINER_ALPHA_OCW_OPERATION_NOSHIFT_BIAS;
        break;
    case D3DTOP_ADDSIGNED2X:
        operation = NV056_SET_COMBINER_ALPHA_OCW_OPERATION_SHIFTLEFTBY1_BIAS;
        break;
    case D3DTOP_SUBTRACT:
        operation = NV056_SET_COMBINER_ALPHA_OCW_OPERATION_NOSHIFT;
        pContext->hwState.dwStateFlags |= (CELSIUS_FLAG_ADDCOMPLEMENTALPHA(1));
        pContext->hwState.dwDirtyFlags |= CELSIUS_DIRTY_SPECFOG_COMBINER;
        break;
    case D3DTOP_MODULATE2X:
        operation = NV056_SET_COMBINER_ALPHA_OCW_OPERATION_SHIFTLEFTBY1;
        break;
    case D3DTOP_MODULATE4X:
        operation = NV056_SET_COMBINER_ALPHA_OCW_OPERATION_SHIFTLEFTBY2;
        break;
    }

    /*
    * Select Alpha Argument A Combiner 1.
    */

    switch (ptssState4->dwValue[D3DTSS_ALPHAARG1] & D3DTA_SELECTMASK)
    {
    case D3DTA_DIFFUSE:
        argASource = NV056_SET_COMBINER_ALPHA_ICW_A_SOURCE_REG_4;
        break;
    case D3DTA_CURRENT:
        argASource = NV056_SET_COMBINER_ALPHA_ICW_A_SOURCE_REG_C;
        if (pContext->hwState.dwStateFlags & CELSIUS_FLAG_ADDCOMPLEMENTALPHA(0))
            argAMap=1;
        break;
    case D3DTA_TEXTURE:
        if (ptssTexture0 && ((ptssState4->dwValue[D3DTSS_ALPHAARG2] & D3DTA_SELECTMASK) != D3DTA_TEXTURE))
            argASource = NV056_SET_COMBINER_ALPHA_ICW_A_SOURCE_REG_8;
        else if (ptssTexture1 && ((ptssState4->dwValue[D3DTSS_ALPHAARG2] & D3DTA_SELECTMASK) == D3DTA_TEXTURE))
            argASource = NV056_SET_COMBINER_ALPHA_ICW_A_SOURCE_REG_9;
        else
            argASource = NV056_SET_COMBINER_ALPHA_ICW_A_SOURCE_REG_4;
        break;
    case D3DTA_TFACTOR:
        if ((ptssState4->dwValue[D3DTSS_ALPHAARG2] & D3DTA_SELECTMASK) != D3DTA_TFACTOR)
            argASource = NV056_SET_COMBINER_ALPHA_ICW_A_SOURCE_REG_1;
        else
            argASource = NV056_SET_COMBINER_ALPHA_ICW_A_SOURCE_REG_0;
        break;
    }

    argAMap ^=!((ptssState4->dwValue[D3DTSS_ALPHAARG1] & D3DTA_COMPLEMENT) == 0);

    /*
    * Select Alpha Argument B Combiner 1.
    */
    switch (ptssState5->dwValue[D3DTSS_ALPHAARG1] & D3DTA_SELECTMASK)
    {
    case D3DTA_DIFFUSE:
        argBSource = NV056_SET_COMBINER_ALPHA_ICW_A_SOURCE_REG_4;
        break;
    case D3DTA_CURRENT:
        argBSource = NV056_SET_COMBINER_ALPHA_ICW_A_SOURCE_REG_C;
        if (pContext->hwState.dwStateFlags & CELSIUS_FLAG_ADDCOMPLEMENTALPHA(0))
            argBMap=1;
        break;
    case D3DTA_TEXTURE:
        if (ptssTexture0 && ((ptssState1->dwValue[D3DTSS_ALPHAARG2] & D3DTA_SELECTMASK) != D3DTA_TEXTURE))
            argBSource = NV056_SET_COMBINER_ALPHA_ICW_A_SOURCE_REG_8;
        else if (ptssTexture1 && ((ptssState5->dwValue[D3DTSS_ALPHAARG2] & D3DTA_SELECTMASK) == D3DTA_TEXTURE))
            argBSource = NV056_SET_COMBINER_ALPHA_ICW_A_SOURCE_REG_8;
        else
            argBSource = NV056_SET_COMBINER_ALPHA_ICW_A_SOURCE_REG_4;
        break;
    case D3DTA_TFACTOR:
        if ((ptssState5->dwValue[D3DTSS_ALPHAARG2] & D3DTA_SELECTMASK) != D3DTA_TFACTOR)
            argBSource = NV056_SET_COMBINER_ALPHA_ICW_A_SOURCE_REG_1;
        else
            argBSource = NV056_SET_COMBINER_ALPHA_ICW_A_SOURCE_REG_0;
        break;
    }
    argBMap  =argBMap ^(!((ptssState5->dwValue[D3DTSS_ALPHAARG1] & D3DTA_COMPLEMENT) == 0));

    /*
    * Select Alpha Argument C Combiner 1.
    */
    switch (ptssState6->dwValue[D3DTSS_ALPHAARG1] & D3DTA_SELECTMASK)
    {
    case D3DTA_DIFFUSE:
        argCSource = NV056_SET_COMBINER_ALPHA_ICW_A_SOURCE_REG_4;
        break;
    case D3DTA_CURRENT:
        argCSource = NV056_SET_COMBINER_ALPHA_ICW_A_SOURCE_REG_C;
        if (pContext->hwState.dwStateFlags & CELSIUS_FLAG_ADDCOMPLEMENTALPHA(0))
            argCMap=1;
        break;
    case D3DTA_TEXTURE:
        if (ptssTexture0 && ((ptssState6->dwValue[D3DTSS_ALPHAARG2] & D3DTA_SELECTMASK) != D3DTA_TEXTURE))
            argCSource = NV056_SET_COMBINER_ALPHA_ICW_A_SOURCE_REG_8;
        else if (ptssTexture1 && ((ptssState6->dwValue[D3DTSS_ALPHAARG2] & D3DTA_SELECTMASK) == D3DTA_TEXTURE))
            argCSource = NV056_SET_COMBINER_ALPHA_ICW_A_SOURCE_REG_9;
        else
            argCSource = NV056_SET_COMBINER_ALPHA_ICW_A_SOURCE_REG_4;
        break;
    case D3DTA_TFACTOR:
        if ((ptssState6->dwValue[D3DTSS_ALPHAARG2] & D3DTA_SELECTMASK) != D3DTA_TFACTOR)
            argCSource = NV056_SET_COMBINER_ALPHA_ICW_A_SOURCE_REG_1;
        else
            argCSource = NV056_SET_COMBINER_ALPHA_ICW_A_SOURCE_REG_0;
        break;
    }
    argCMap ^=!((ptssState6->dwValue[D3DTSS_ALPHAARG1] & D3DTA_COMPLEMENT) == 0);

    /*
    * Select Alpha Argument D Combiner 1.
    */
    switch (ptssState6->dwValue[D3DTSS_ALPHAARG1] & D3DTA_SELECTMASK)
    {
    case D3DTA_DIFFUSE:
        argDSource = NV056_SET_COMBINER_ALPHA_ICW_A_SOURCE_REG_4;
        break;
    case D3DTA_CURRENT:
        argDSource = NV056_SET_COMBINER_ALPHA_ICW_A_SOURCE_REG_C;
        if (pContext->hwState.dwStateFlags & CELSIUS_FLAG_ADDCOMPLEMENTALPHA(0))
            argDMap=1;
        break;
    case D3DTA_TEXTURE:
        if (ptssTexture0 && ((ptssState7->dwValue[D3DTSS_ALPHAARG2] & D3DTA_SELECTMASK) != D3DTA_TEXTURE))
            argDSource = NV056_SET_COMBINER_ALPHA_ICW_A_SOURCE_REG_8;
        else if (ptssTexture1 && ((ptssState7->dwValue[D3DTSS_ALPHAARG2] & D3DTA_SELECTMASK) == D3DTA_TEXTURE))
            argDSource = NV056_SET_COMBINER_ALPHA_ICW_A_SOURCE_REG_9;
        else
            argDSource = NV056_SET_COMBINER_ALPHA_ICW_A_SOURCE_REG_4;
        break;
    case D3DTA_TFACTOR:
        if ((ptssState7->dwValue[D3DTSS_ALPHAARG2] & D3DTA_SELECTMASK) != D3DTA_TFACTOR)
            argDSource = NV056_SET_COMBINER_ALPHA_ICW_A_SOURCE_REG_1;
        else
            argDSource = NV056_SET_COMBINER_ALPHA_ICW_A_SOURCE_REG_0;
        break;
    }

    argDMap ^=!((ptssState7->dwValue[D3DTSS_ALPHAARG1] & D3DTA_COMPLEMENT) == 0);

    /*
    * Program Texture Combine 1 Alpha Stage.
    */
    pContext->hwState.dwAlphaICW[1]= DRF_NUM(056, _SET_COMBINER_ALPHA_ICW, _A_MAP,argAMap)
                                |DRF_NUM(056, _SET_COMBINER_ALPHA_ICW, _A_ALPHA,1)
                                |DRF_NUM(056, _SET_COMBINER_ALPHA_ICW, _A_SOURCE, argASource)
                                |DRF_NUM(056, _SET_COMBINER_ALPHA_ICW, _B_MAP,argBMap)
                                |DRF_NUM(056, _SET_COMBINER_ALPHA_ICW, _B_ALPHA,1)
                                |DRF_NUM(056, _SET_COMBINER_ALPHA_ICW, _B_SOURCE,argBSource)
                                |DRF_NUM(056, _SET_COMBINER_ALPHA_ICW, _C_MAP,argCMap)
                                |DRF_NUM(056, _SET_COMBINER_ALPHA_ICW, _C_ALPHA,1)
                                |DRF_NUM(056, _SET_COMBINER_ALPHA_ICW, _C_SOURCE,argCSource)
                                |DRF_NUM(056, _SET_COMBINER_ALPHA_ICW, _D_MAP,argDMap)
                                |DRF_NUM(056, _SET_COMBINER_ALPHA_ICW, _D_ALPHA,1)
                                |DRF_NUM(056, _SET_COMBINER_ALPHA_ICW, _D_SOURCE,argDSource);

    pContext->hwState.dwAlphaOCW[1]=DRF_NUM(056, _SET_COMBINER_ALPHA_OCW, _OPERATION, operation)
                                |DRF_NUM(056, _SET_COMBINER_ALPHA_OCW,_MUX_ENABLE, 0)
                                |DRF_NUM(056, _SET_COMBINER_ALPHA_OCW,_SUM_DST, finDst)
                                |DRF_NUM(056, _SET_COMBINER_ALPHA_OCW,_AB_DST, 0)
                                |DRF_NUM(056, _SET_COMBINER_ALPHA_OCW,_CD_DST, 0);



    /*
     * Setup hardware texture combiner 1 color components based on texture stages 0-3.
     * Operation comes from ColorOp of stage 5.
     * Arguments come from ColorArg1 of stages 4-7.
     */
    argAMap=argBMap=argCMap=argDMap=0;

    switch (ptssState5->dwValue[D3DTSS_COLOROP])
    {
    case D3DTOP_ADD:
        operation = NV056_SET_COMBINER1_COLOR_OCW_OPERATION_NOSHIFT;
        break;
    case D3DTOP_ADDSIGNED:
        operation = NV056_SET_COMBINER1_COLOR_OCW_OPERATION_NOSHIFT_BIAS;
        break;
    case D3DTOP_ADDSIGNED2X:
        operation = NV056_SET_COMBINER1_COLOR_OCW_OPERATION_SHIFTLEFTBY1_BIAS;
        break;
    case D3DTOP_SUBTRACT:
        operation = NV056_SET_COMBINER1_COLOR_OCW_OPERATION_NOSHIFT;
        pContext->hwState.dwStateFlags |= (CELSIUS_FLAG_ADDCOMPLEMENTRGB(1));
        pContext->hwState.dwDirtyFlags |= (CELSIUS_DIRTY_SPECFOG_COMBINER);
        break;
    case D3DTOP_MODULATE2X:
        operation = NV056_SET_COMBINER1_COLOR_OCW_OPERATION_SHIFTLEFTBY1;
        break;
    case D3DTOP_MODULATE4X:
        operation = NV056_SET_COMBINER1_COLOR_OCW_OPERATION_SHIFTLEFTBY2;
        break;
    }

    /*
     * Select Color Argument A Combiner 1.
     */
    switch (ptssState4->dwValue[D3DTSS_COLORARG1] & D3DTA_SELECTMASK)
    {
    case D3DTA_DIFFUSE:
        argASource = NV056_SET_COMBINER_COLOR_ICW_A_SOURCE_REG_4;
        break;
    case D3DTA_CURRENT:
        argASource = NV056_SET_COMBINER_COLOR_ICW_A_SOURCE_REG_C;
        if (pContext->hwState.dwStateFlags & CELSIUS_FLAG_ADDCOMPLEMENTRGB(0))
            argAMap=1;
        break;
    case D3DTA_TEXTURE:
        if (ptssTexture0 && ((ptssState0->dwValue[D3DTSS_COLORARG2] & D3DTA_SELECTMASK) != D3DTA_TEXTURE))
            argASource = NV056_SET_COMBINER_COLOR_ICW_A_SOURCE_REG_8;
        else if (ptssTexture1 && ((ptssState4->dwValue[D3DTSS_COLORARG2] & D3DTA_SELECTMASK) == D3DTA_TEXTURE))
            argASource = NV056_SET_COMBINER_COLOR_ICW_A_SOURCE_REG_9;
        else
            argASource = NV056_SET_COMBINER_COLOR_ICW_A_SOURCE_REG_4;
        break;
    case D3DTA_TFACTOR:
        if ((ptssState4->dwValue[D3DTSS_COLORARG2] & D3DTA_SELECTMASK) != D3DTA_TFACTOR)
            argASource = NV056_SET_COMBINER_COLOR_ICW_A_SOURCE_REG_1;
        else
            argASource = NV056_SET_COMBINER_COLOR_ICW_A_SOURCE_REG_0;
        break;
    }
    argAMap ^= !(ptssState4->dwValue[D3DTSS_COLORARG1] & D3DTA_COMPLEMENT) == 0;
    argAAlpha = !((ptssState4->dwValue[D3DTSS_COLORARG1] & D3DTA_ALPHAREPLICATE) == 0);

    /*
     * Select Color Argument B Combiner 1.
     */
    switch (ptssState5->dwValue[D3DTSS_COLORARG1] & D3DTA_SELECTMASK)
    {
    case D3DTA_DIFFUSE:
        argBSource = NV056_SET_COMBINER_COLOR_ICW_B_SOURCE_REG_4;
        break;
    case D3DTA_CURRENT:
        argBSource = NV056_SET_COMBINER_COLOR_ICW_B_SOURCE_REG_C;
        if (pContext->hwState.dwStateFlags & CELSIUS_FLAG_ADDCOMPLEMENTRGB(0))
            argBMap=1;
        break;
    case D3DTA_TEXTURE:
        if (ptssTexture0 && ((ptssState1->dwValue[D3DTSS_COLORARG2] & D3DTA_SELECTMASK) != D3DTA_TEXTURE))
            argBSource = NV056_SET_COMBINER_COLOR_ICW_B_SOURCE_REG_8;
        else if (ptssTexture0 && ((ptssState5->dwValue[D3DTSS_COLORARG2] & D3DTA_SELECTMASK) == D3DTA_TEXTURE))
            argBSource = NV056_SET_COMBINER_COLOR_ICW_B_SOURCE_REG_9;
        else
            argBSource = NV056_SET_COMBINER_COLOR_ICW_B_SOURCE_REG_4;
        break;
    case D3DTA_TFACTOR:
        if ((ptssState5->dwValue[D3DTSS_COLORARG2] & D3DTA_SELECTMASK) != D3DTA_TFACTOR)
            argBSource = NV056_SET_COMBINER_COLOR_ICW_B_SOURCE_REG_1;
        else
            argBSource = NV056_SET_COMBINER_COLOR_ICW_B_SOURCE_REG_0;
        break;
    }
    argBMap ^=!((ptssState5->dwValue[D3DTSS_COLORARG1] & D3DTA_COMPLEMENT) == 0);
    argBAlpha = !((ptssState5->dwValue[D3DTSS_COLORARG1] & D3DTA_ALPHAREPLICATE) == 0);

    /*
     * Select Color Argument C Combiner 1.
     */
    switch (ptssState6->dwValue[D3DTSS_COLORARG1] & D3DTA_SELECTMASK)
    {
    case D3DTA_DIFFUSE:
        argCSource = NV056_SET_COMBINER_COLOR_ICW_C_SOURCE_REG_4;
        break;
    case D3DTA_CURRENT:
        argCSource = NV056_SET_COMBINER_COLOR_ICW_C_SOURCE_REG_C;
        if (pContext->hwState.dwStateFlags & CELSIUS_FLAG_ADDCOMPLEMENTRGB(0))
            argCMap=1;
        break;
    case D3DTA_TEXTURE:
        if (ptssTexture0 && ((ptssState6->dwValue[D3DTSS_COLORARG2] & D3DTA_SELECTMASK) != D3DTA_TEXTURE))
            argCSource = NV056_SET_COMBINER_COLOR_ICW_C_SOURCE_REG_8;
        else if (ptssTexture1 && ((ptssState6->dwValue[D3DTSS_COLORARG2] & D3DTA_SELECTMASK) == D3DTA_TEXTURE))
            argCSource = NV056_SET_COMBINER_COLOR_ICW_C_SOURCE_REG_9;
        else
            argCSource = NV056_SET_COMBINER_COLOR_ICW_C_SOURCE_REG_4;
        break;
    case D3DTA_TFACTOR:
        if ((ptssState6->dwValue[D3DTSS_COLORARG2] & D3DTA_SELECTMASK) != D3DTA_TFACTOR)
            argCSource = NV056_SET_COMBINER_COLOR_ICW_C_SOURCE_REG_1;
        else
            argCSource = NV056_SET_COMBINER_COLOR_ICW_C_SOURCE_REG_0;
        break;
    }
    argCMap ^= !((ptssState6->dwValue[D3DTSS_COLORARG1] & D3DTA_COMPLEMENT) == 0);
    argCAlpha = !((ptssState6->dwValue[D3DTSS_COLORARG1] & D3DTA_ALPHAREPLICATE) == 0);

    /*
     * Select Color Argument D Combiner 1.
     */
    switch (ptssState7->dwValue[D3DTSS_COLORARG1] & D3DTA_SELECTMASK)
    {
    case D3DTA_DIFFUSE:
        argDSource = NV056_SET_COMBINER_COLOR_ICW_D_SOURCE_REG_4;
        break;
    case D3DTA_CURRENT:
        argDSource = NV056_SET_COMBINER_COLOR_ICW_D_SOURCE_REG_C;
        if (pContext->hwState.dwStateFlags & CELSIUS_FLAG_ADDCOMPLEMENTRGB(0))
            argDMap=1;
        break;
    case D3DTA_TEXTURE:
        if (ptssTexture0 && ((ptssState7->dwValue[D3DTSS_COLORARG2] & D3DTA_SELECTMASK) != D3DTA_TEXTURE))
            argDSource = NV056_SET_COMBINER_COLOR_ICW_D_SOURCE_REG_8;
        else if (ptssTexture1 && ((ptssState7->dwValue[D3DTSS_COLORARG2] & D3DTA_SELECTMASK) == D3DTA_TEXTURE))
            argDSource = NV056_SET_COMBINER_COLOR_ICW_D_SOURCE_REG_9;
        else
            argDSource = NV056_SET_COMBINER_COLOR_ICW_D_SOURCE_REG_4;
        break;
    case D3DTA_TFACTOR:
        if ((ptssState7->dwValue[D3DTSS_COLORARG2] & D3DTA_SELECTMASK) != D3DTA_TFACTOR)
            argDSource = NV056_SET_COMBINER_COLOR_ICW_D_SOURCE_REG_1;
        else
            argDSource = NV056_SET_COMBINER_COLOR_ICW_D_SOURCE_REG_0;
        break;
    }
    argDMap ^= !((ptssState7->dwValue[D3DTSS_COLORARG1] & D3DTA_COMPLEMENT) == 0);
    argDAlpha = !((ptssState7->dwValue[D3DTSS_COLORARG1] & D3DTA_ALPHAREPLICATE) == 0);

    /*
     * Program Texture Combine 1 Color Stage.
     */
    pContext->hwState.dwColorICW[1]= DRF_NUM(056, _SET_COMBINER_COLOR_ICW, _A_MAP,argAMap)
                                        |DRF_NUM(056, _SET_COMBINER_COLOR_ICW, _A_ALPHA,argAAlpha)
                                        |DRF_NUM(056, _SET_COMBINER_COLOR_ICW, _A_SOURCE, argASource)
                                        |DRF_NUM(056, _SET_COMBINER_COLOR_ICW, _B_MAP,argBMap)
                                        |DRF_NUM(056, _SET_COMBINER_COLOR_ICW, _B_ALPHA,argBAlpha)
                                        |DRF_NUM(056, _SET_COMBINER_COLOR_ICW, _B_SOURCE,argBSource)
                                        |DRF_NUM(056, _SET_COMBINER_COLOR_ICW, _C_MAP,argCMap)
                                        |DRF_NUM(056, _SET_COMBINER_COLOR_ICW, _C_ALPHA,argCAlpha)
                                        |DRF_NUM(056, _SET_COMBINER_COLOR_ICW, _C_SOURCE,argCSource)
                                        |DRF_NUM(056, _SET_COMBINER_COLOR_ICW, _D_MAP,argDMap)
                                        |DRF_NUM(056, _SET_COMBINER_COLOR_ICW, _D_ALPHA,argDAlpha)
                                        |DRF_NUM(056, _SET_COMBINER_COLOR_ICW, _D_SOURCE,argDSource);

    pContext->hwState.dwColorOCW[1]= DRF_NUM(056, _SET_COMBINER1_COLOR_OCW, _ITERATION_COUNT, 2)
                                        |DRF_NUM(056, _SET_COMBINER1_COLOR_OCW,_MUX_SELECT, 0)
                                        |DRF_NUM(056, _SET_COMBINER1_COLOR_OCW, _OPERATION, operation)
                                        |DRF_NUM(056, _SET_COMBINER1_COLOR_OCW,_MUX_ENABLE, 0)
                                        |DRF_NUM(056, _SET_COMBINER1_COLOR_OCW,_AB_DOT_ENABLE, 0)
                                        |DRF_NUM(056, _SET_COMBINER1_COLOR_OCW,_CD_DOT_ENABLE, 0)
                                        |DRF_NUM(056, _SET_COMBINER1_COLOR_OCW,_SUM_DST, finDst)
                                        |DRF_NUM(056, _SET_COMBINER1_COLOR_OCW,_AB_DST, 0)
                                        |DRF_NUM(056, _SET_COMBINER1_COLOR_OCW,_CD_DST, 0);

#if COMBINER_STATUS
    DPF ("Result in 8 stage mapping set up");
    DPF ("   color icw[0] = 0x%08x", pContext->hwState.dwColorICW[0]);
    DPF ("   color ocw[0] = 0x%08x", pContext->hwState.dwColorOCW[0]);
    DPF ("   alpha icw[0] = 0x%08x", pContext->hwState.dwAlphaICW[0]);
    DPF ("   alpha ocw[0] = 0x%08x", pContext->hwState.dwAlphaOCW[0]);
    DPF ("   color icw[1] = 0x%08x", pContext->hwState.dwColorICW[1]);
    DPF ("   color ocw[1] = 0x%08x", pContext->hwState.dwColorOCW[1]);
    DPF ("   alpha icw[1] = 0x%08x", pContext->hwState.dwAlphaICW[1]);
    DPF ("   alpha ocw[1] = 0x%08x", pContext->hwState.dwAlphaOCW[1]);
    __asm int 3;
#endif

    return (D3D_OK);
}


static BOOL Check3StageColor(PNVD3DCONTEXT pContext)
{
    PNVD3DTEXSTAGESTATE     ptssState0, ptssState1, ptssState2;

    ptssState0 = &pContext->tssState[0];
    ptssState1 = &pContext->tssState[1];
    ptssState2 = &pContext->tssState[2];

    //In stage 0: Color Op = D3DTOP_SELECTARG1 or D3DTOP_SELECTARG2
    if ((ptssState0->dwValue[D3DTSS_COLOROP] != D3DTOP_SELECTARG1)
        &&(ptssState0->dwValue[D3DTSS_COLOROP] != D3DTOP_SELECTARG2))
        goto Fail;

   //in stage 0: texture has to be selected
    if(!((((ptssState0->dwValue[D3DTSS_COLORARG1]&D3DTA_SELECTMASK )== D3DTA_TEXTURE)
        &&(ptssState0->dwValue[D3DTSS_COLOROP] == D3DTOP_SELECTARG1))
        ||(((ptssState0->dwValue[D3DTSS_COLORARG2]&D3DTA_SELECTMASK)== D3DTA_TEXTURE)
        &&(ptssState0->dwValue[D3DTSS_COLOROP] == D3DTOP_SELECTARG2))))
        goto Fail;

    //In Stage 0: validate the texture
    if (!(ptssState0->dwValue[D3DTSS_TEXTUREMAP]))
        goto Fail;

    //In stage 1: Color Arg1=current xor Arg2=current
    //And not alpha replication could be used for current in stage 1
    if (!(((ptssState1->dwValue[D3DTSS_COLORARG1]&D3DTA_SELECTMASK)== D3DTA_CURRENT)
        ^((ptssState1->dwValue[D3DTSS_COLORARG2]&D3DTA_SELECTMASK) == D3DTA_CURRENT)))
        goto Fail;
    else
    {
        if((ptssState1->dwValue[D3DTSS_COLORARG1]&D3DTA_SELECTMASK)== D3DTA_CURRENT)
        {
            if(ptssState1->dwValue[D3DTSS_COLORARG1]&D3DTA_ALPHAREPLICATE)
                goto Fail;
        }
        else
        {
             if(ptssState1->dwValue[D3DTSS_COLORARG2]&D3DTA_ALPHAREPLICATE)
                goto Fail;
        }
    }

    //When the stage1 color op = BlendCurrentAlpha, the stage0 alpha has to be select texture
    //restrictly, cannot use complement of the texture
    if((ptssState1->dwValue[D3DTSS_COLOROP] == D3DTOP_BLENDCURRENTALPHA)
        &&(!(((ptssState0->dwValue[D3DTSS_ALPHAOP] == D3DTOP_SELECTARG1)
        &&(ptssState0->dwValue[D3DTSS_ALPHAARG1] == D3DTA_TEXTURE))
        ||((ptssState0->dwValue[D3DTSS_ALPHAOP] == D3DTOP_SELECTARG2)
        &&(ptssState0->dwValue[D3DTSS_ALPHAARG2] == D3DTA_TEXTURE)))))
        goto Fail;

    //In Stage 1: Vaidate texture if it is used
    //We know that op1!= selectArg1 or selectArg2 (if it is, it is going to fail the final setting)
    if ((((ptssState1->dwValue[D3DTSS_COLORARG1] &D3DTA_SELECTMASK)== D3DTA_TEXTURE)
        ||((ptssState1->dwValue[D3DTSS_COLORARG2]&D3DTA_SELECTMASK)== D3DTA_TEXTURE))
        &&(!(ptssState1->dwValue[D3DTSS_TEXTUREMAP])))
        goto Fail;

    //In stage 2: Color Arg1=current or Arg2==current
    if(((ptssState2->dwValue[D3DTSS_COLORARG1]&D3DTA_SELECTMASK) != D3DTA_CURRENT)
        &&((ptssState2->dwValue[D3DTSS_COLORARG2]&D3DTA_SELECTMASK)!= D3DTA_CURRENT))
        goto Fail;
     else
    {
        if((ptssState2->dwValue[D3DTSS_COLORARG1]&D3DTA_SELECTMASK)== D3DTA_CURRENT)
        {
            if(ptssState2->dwValue[D3DTSS_COLORARG1]&D3DTA_ALPHAREPLICATE)
                goto Fail;
        }
        else
        {
             if(ptssState2->dwValue[D3DTSS_COLORARG2]&D3DTA_ALPHAREPLICATE)
                goto Fail;
        }
    }


    //In Stage 2: Non of the Arg could be Texture
    if (((ptssState2->dwValue[D3DTSS_COLORARG1]&D3DTA_SELECTMASK) == D3DTA_TEXTURE)
        ||((ptssState2->dwValue[D3DTSS_COLORARG2]&D3DTA_SELECTMASK) == D3DTA_TEXTURE))
        goto Fail;

    return TRUE;

Fail:
    DPF_LEVEL (NVDBG_LEVEL_INFO,"Failed the Color Arg check or the Color Op0 for 2 texture 3 stage");

    return FALSE;
}


static BOOL Check3StageAlpha(PNVD3DCONTEXT pContext)
{
    PNVD3DTEXSTAGESTATE     ptssState0, ptssState1;
    DWORD alphaStageCount = 0;
    ptssState0 = &pContext->tssState[0];
    ptssState1 = &pContext->tssState[1];

    while ((alphaStageCount < 8) &&
        (pContext->tssState[alphaStageCount].dwValue[D3DTSS_ALPHAOP] != D3DTOP_DISABLE))
    {
        alphaStageCount++;
    }

    if(alphaStageCount==0)
        return TRUE;
    else //alphaStageCount>0
    {
        //In stage 0: Texture is validated in Color Check alrady

        if(alphaStageCount==1)
            return TRUE;
        else //alphaStageCount>1
        {
            //In stage 1: Validate texture if is used.
            if (((((ptssState1->dwValue[D3DTSS_ALPHAARG1]&D3DTA_SELECTMASK) == D3DTA_TEXTURE)
                &&(ptssState1->dwValue[D3DTSS_ALPHAOP] != D3DTOP_SELECTARG2))
                ||((ptssState1->dwValue[D3DTSS_ALPHAARG2] == D3DTA_TEXTURE)
                &&((ptssState1->dwValue[D3DTSS_ALPHAOP]&D3DTA_SELECTMASK)!= D3DTOP_SELECTARG1)))
                &&(!(ptssState1->dwValue[D3DTSS_TEXTUREMAP])))
                return FALSE;
            else
            {
                if(alphaStageCount==2)
                    return TRUE;
                else
                {
                    DPF_LEVEL (NVDBG_LEVEL_INFO,"Alpha Stage# > 2, Too many alpha stages");

                    return FALSE;
                }
            }
        }
    }
}

//Check for the conditions that meet for 2 texture stage one combiner
static BOOL colorCheck2Stage1Combiner (PNVD3DCONTEXT pContext)
{
    PNVD3DTEXSTAGESTATE    ptssState0, ptssState1;
    ptssState0 = &pContext->tssState[0];
    ptssState1 = &pContext->tssState[1];

    //Add, Modulate
    if ((ptssState0->dwValue[D3DTSS_COLOROP] == D3DTOP_ADD)
        &&
        ((ptssState1->dwValue[D3DTSS_COLOROP] == D3DTOP_MODULATE)   ||
         (ptssState1->dwValue[D3DTSS_COLOROP] == D3DTOP_MODULATE2X) ||
         (ptssState1->dwValue[D3DTSS_COLOROP] == D3DTOP_MODULATE4X)))
    {
        //one and only one arg ins tage1 be current
        //no apha replicate or complement allowed for the "current" arg
        if (((ptssState1->dwValue[D3DTSS_COLORARG1]&D3DTA_SELECTMASK )== D3DTA_CURRENT)
            ^((ptssState1->dwValue[D3DTSS_COLORARG2]&D3DTA_SELECTMASK)== D3DTA_CURRENT))
        {
            if((ptssState1->dwValue[D3DTSS_COLORARG1]&D3DTA_SELECTMASK )== D3DTA_CURRENT)
            {
                if((ptssState1->dwValue[D3DTSS_COLORARG1]&D3DTA_COMPLEMENT)
                    ||(ptssState1->dwValue[D3DTSS_COLORARG1]&D3DTA_ALPHAREPLICATE))
                    goto Fail;
            }
            else
            {
                 if((ptssState1->dwValue[D3DTSS_COLORARG2]&D3DTA_COMPLEMENT)
                    ||(ptssState1->dwValue[D3DTSS_COLORARG2]&D3DTA_ALPHAREPLICATE))
                    goto Fail;
            }
            return TRUE;
        }
        else
            goto Fail;
    }

    //Modulate, Add
    if((ptssState0->dwValue[D3DTSS_COLOROP] == D3DTOP_MODULATE)
        &&((ptssState1->dwValue[D3DTSS_COLOROP] == D3DTOP_ADD)
        ||(ptssState1->dwValue[D3DTSS_COLOROP] == D3DTOP_ADDSIGNED)
        ||(ptssState1->dwValue[D3DTSS_COLOROP] == D3DTOP_ADDSIGNED2X)
        ||(ptssState1->dwValue[D3DTSS_COLOROP] == D3DTOP_SUBTRACT)))
    {
        //one and only one arg ins tage1 be current
        //no apha replicate or complement allowed for the "current" arg
           if (((ptssState1->dwValue[D3DTSS_COLORARG1]&D3DTA_SELECTMASK )== D3DTA_CURRENT)
            ^((ptssState1->dwValue[D3DTSS_COLORARG2]&D3DTA_SELECTMASK)== D3DTA_CURRENT))
        {
            if((ptssState1->dwValue[D3DTSS_COLORARG1]&D3DTA_SELECTMASK )== D3DTA_CURRENT)
            {
                if((ptssState1->dwValue[D3DTSS_COLORARG1]&D3DTA_COMPLEMENT)
                    ||(ptssState1->dwValue[D3DTSS_COLORARG1]&D3DTA_ALPHAREPLICATE))
                    goto Fail;
            }
            else
            {
                 if((ptssState1->dwValue[D3DTSS_COLORARG2]&D3DTA_COMPLEMENT)
                    ||(ptssState1->dwValue[D3DTSS_COLORARG2]&D3DTA_ALPHAREPLICATE))
                    goto Fail;
            }
            return TRUE;
        }
        else
            goto Fail;
    }

Fail:
/*#ifdef DEBUG
        DPF("Cannot put 2 stages Color setting into one combiner");
        _asm int 3;
#endif
*/
        return FALSE;
}
static BOOL alphaCheck2Stage1Combiner (PNVD3DCONTEXT pContext)
{
    PNVD3DTEXSTAGESTATE    ptssState0, ptssState1;
    DWORD                  alphaStageCount=0;

    ptssState0 = &pContext->tssState[0];
    ptssState1 = &pContext->tssState[1];

    while ((alphaStageCount < 2)
        &&(pContext->tssState[alphaStageCount].dwValue[D3DTSS_ALPHAOP] != D3DTOP_DISABLE))
    {
        alphaStageCount++;
    }

    if (alphaStageCount < 2)
        return TRUE;

    else //alpha stage > 1
    {
        //Add, Modulate
        if((ptssState0->dwValue[D3DTSS_ALPHAOP] == D3DTOP_ADD)
           &&
           ((ptssState1->dwValue[D3DTSS_ALPHAOP] == D3DTOP_MODULATE)   ||
            (ptssState1->dwValue[D3DTSS_ALPHAOP] == D3DTOP_MODULATE2X) ||
            (ptssState1->dwValue[D3DTSS_ALPHAOP] == D3DTOP_MODULATE4X)))
        {
            //one and only one arg ins tage1 be current
            //no complement allowed for the "current" arg
            if (((ptssState1->dwValue[D3DTSS_ALPHAARG1]&D3DTA_SELECTMASK )== D3DTA_CURRENT)
                ^((ptssState1->dwValue[D3DTSS_ALPHAARG2]&D3DTA_SELECTMASK)== D3DTA_CURRENT))
            {
                if((ptssState1->dwValue[D3DTSS_ALPHAARG1]&D3DTA_SELECTMASK )== D3DTA_CURRENT)
                {
                    if(ptssState1->dwValue[D3DTSS_ALPHAARG1]&D3DTA_COMPLEMENT)
                        goto Fail;
                }
                else
                {
                    if(ptssState1->dwValue[D3DTSS_ALPHAARG2]&D3DTA_COMPLEMENT)
                        goto Fail;
                }
                return TRUE;
            }
            else
                goto Fail;
        }

        //Modulate, Add
        if((ptssState0->dwValue[D3DTSS_ALPHAOP] == D3DTOP_MODULATE)
            &&((ptssState1->dwValue[D3DTSS_ALPHAOP] == D3DTOP_ADD)
            ||(ptssState1->dwValue[D3DTSS_ALPHAOP] == D3DTOP_ADDSIGNED)
            ||(ptssState1->dwValue[D3DTSS_ALPHAOP] == D3DTOP_ADDSIGNED2X)
            ||(ptssState1->dwValue[D3DTSS_ALPHAOP] == D3DTOP_SUBTRACT)))
        {
            //one and only one arg ins tage1 be current
            //no complement allowed for the "current" arg
            if (((ptssState1->dwValue[D3DTSS_ALPHAARG1]&D3DTA_SELECTMASK )== D3DTA_CURRENT)
                ^((ptssState1->dwValue[D3DTSS_ALPHAARG2]&D3DTA_SELECTMASK)== D3DTA_CURRENT))
            {
                if((ptssState1->dwValue[D3DTSS_ALPHAARG1]&D3DTA_SELECTMASK )== D3DTA_CURRENT)
                {
                    if(ptssState1->dwValue[D3DTSS_ALPHAARG1]&D3DTA_COMPLEMENT)
                        goto Fail;
                }
                else
                {
                    if(ptssState1->dwValue[D3DTSS_ALPHAARG2]&D3DTA_COMPLEMENT)
                        goto Fail;
                }
                return TRUE;
            }
            else
                goto Fail;
        }
    }

Fail:
/*#ifdef DEBUG
DPF("Cannot put 2 stages alpha setting into one combiner");
_asm int 3;
#endif
    */
    return FALSE;
}


/***************************************************************************************
* This is a special case to save one combiner stage
* Handle the case of (X0+X1)*X2 for color operation
* Set Color Combiner0 A=X0; B=X2; C=X1; D=X2
* Where  X0= one Arg of Stage 0; could be T0
*        X1= one Arg of Stage 1; could be T1;(the other Arg of Stage 1 is CURRENT)
* Disable Combiner1
*        X3= one Arg of Stage 2; cannot be TEXTURE;(the other Arg of Stage 1 is CURRENT)
* Alpha setting may not follow this
****************************************************************************************/

static HRESULT AddMod1(PNVD3DCONTEXT pContext)
{
    int      shift;
    BOOL     compA,compC, repA, repC, expA, expC;
    PNVD3DTEXSTAGESTATE     ptssState0, ptssState1, ptssState2;

    //initialize the flag for combiner
    shift  = 0;
    compA=compC=repA=repC=expA=expC=FALSE;

    //Set up some pointers to the individual texture stages.
    ptssState0 = &pContext->tssState[0];
    ptssState1 = &pContext->tssState[1];
    ptssState2 = &pContext->tssState[2];

    //initialize color combiner0
    pContext->hwState.dwColorICW[0] = 0;
    pContext->hwState.dwColorOCW[0] = 0;

    //Disable color combine1
    pContext->hwState.dwColorICW[1]=0;
    pContext->hwState.dwColorOCW[1]=0x10000000;
    pContext->hwState.dwNumActiveCombinerStages = 1;

    //deal with the situation for current complement

    if((((ptssState1->dwValue[D3DTSS_COLORARG1]&D3DTA_SELECTMASK)==D3DTA_CURRENT)
        &((ptssState1->dwValue[D3DTSS_COLORARG1]&D3DTA_COMPLEMENT)!=0))
        ||(((ptssState1->dwValue[D3DTSS_COLORARG2]&D3DTA_SELECTMASK)==D3DTA_CURRENT)
        &((ptssState1->dwValue[D3DTSS_COLORARG2]&D3DTA_COMPLEMENT)!=0)))
        compA ^=TRUE;

    /***************************************************************/
    /*Color Combiner 0 Setup
    /**************************************************************/
    //Stage0 Op = SelectArg1 or SelectArg2
    //Check Stage1 Op

    if (ptssState1->dwValue[D3DTSS_COLOROP]==D3DTOP_SUBTRACT)
    {
        if((ptssState1->dwValue[D3DTSS_COLORARG1]&D3DTA_SELECTMASK)==D3DTA_CURRENT)
        {   //(T0*B)+(-T1)*D
            compC ^=TRUE;
            expC=TRUE;
        }
        else
        {   //(-T0)*B+(T1)*D
            compA ^=TRUE;
            expA=TRUE;
        }
    }
    //Check Stage2 Op
    switch (ptssState2->dwValue[D3DTSS_COLOROP])
    {
    case D3DTOP_MODULATE2X:
        shift++;
        break;
    case D3DTOP_MODULATE4X:
        shift +=2;
        break;
    }

    //Color combiner ICW[0]
    pContext->hwState.dwNextAvailableTextureUnit=0;
    //input value A from stage0 Arg
    if (ptssState0->dwValue[D3DTSS_COLOROP] == D3DTOP_SELECTARG1)
        SelectColorInput(pContext, celsiusCombinerInputA, 0, 0, D3DTSS_COLORARG1,compA, expA, repA);
    else//D3DOP_SELECTARG2
        SelectColorInput(pContext, celsiusCombinerInputA, 0, 0, D3DTSS_COLORARG2,compA, expA, repA);

    pContext->hwState.dwNextAvailableTextureUnit=1;

    //input value C from stage1 args
    if((ptssState1->dwValue[D3DTSS_COLORARG1]&D3DTA_SELECTMASK) == D3DTA_CURRENT)
        SelectColorInput(pContext, celsiusCombinerInputC, 0, 1, D3DTSS_COLORARG2,compC, expC, repC);
    else
        SelectColorInput(pContext, celsiusCombinerInputC, 0, 1, D3DTSS_COLORARG1,compC, expC, repC);

    //input value  B & D from stage2 args (B=D)
    if((ptssState2->dwValue[D3DTSS_COLORARG1]&D3DTA_SELECTMASK) == D3DTA_CURRENT)
    {
        SelectColorInput(pContext, celsiusCombinerInputB, 0, 2, D3DTSS_COLORARG2,FALSE, FALSE, FALSE);
        SelectColorInput(pContext, celsiusCombinerInputD, 0, 2, D3DTSS_COLORARG2,FALSE, FALSE, FALSE);
    }
    else
    {
        SelectColorInput(pContext, celsiusCombinerInputB, 0, 2, D3DTSS_COLORARG1,FALSE, FALSE, FALSE);
        SelectColorInput(pContext, celsiusCombinerInputD, 0, 2, D3DTSS_COLORARG1,FALSE, FALSE, FALSE);
    }

    //Color Combiner OCW[0]
    ConstructOutputColorCombiners(pContext, TRUE, 0, 0, shift, 0, 0, 0 );
    //End of Color Combiner 0 Setup
    return (D3D_OK);

} //end AddMod1


/******************************************************************************************
/*
/*Normal case of Color Combiner0 set up, DX7 Stage 0 and Stage 1
/*
/******************************************************************************************/

/*****************************************************************************************
/*Set Color Combiner0 for op1=add/subtract: A=X0; B=1/-1; C=X1; D=1/-1
/*****************************************************************************************/
static HRESULT Add1(PNVD3DCONTEXT pContext)
{
    int                     bias, shift;
    BOOL                    compA, repA, negB, negD, smoothA, smoothC;
    PNVD3DTEXSTAGESTATE     ptssState0, ptssState1;

    //initialize the flags for combiner
    bias=shift = 0;
    compA=repA=FALSE;
    negB=negD=smoothA=smoothC=FALSE;

    //Set up some pointers to the individual texture stages.
    ptssState0 = &pContext->tssState[0];
    ptssState1 = &pContext->tssState[1];

    //initialize color combiner0
    pContext->hwState.dwColorICW[0] = 0;
    pContext->hwState.dwColorOCW[0] = 0;

    //deal with the situation for current complement and alpha replicat
    if((((ptssState1->dwValue[D3DTSS_COLORARG1]&D3DTA_SELECTMASK)==D3DTA_CURRENT)
        &((ptssState1->dwValue[D3DTSS_COLORARG1]&D3DTA_COMPLEMENT)!=0))
        ||(((ptssState1->dwValue[D3DTSS_COLORARG2]&D3DTA_SELECTMASK)==D3DTA_CURRENT)
        &((ptssState1->dwValue[D3DTSS_COLORARG2]&D3DTA_COMPLEMENT)!=0)))
        compA ^=TRUE;

    //Color Combiner 0
    switch (ptssState1->dwValue[D3DTSS_COLOROP])
    {
    case D3DTOP_ADDSIGNED:
        bias=1;
        break;
    case D3DTOP_ADDSIGNED2X:
        bias=1;
        shift++;
        break;
    case D3DTOP_SUBTRACT:
        if((ptssState1->dwValue[D3DTSS_COLORARG2]&D3DTA_SELECTMASK)==D3DTA_CURRENT)
            negB=TRUE; // T0*(-1)+T1*1
        else
            negD=TRUE; // T0*1+T1*(-1)
        break;
    case D3DTOP_ADDSMOOTH:
        if((ptssState1->dwValue[D3DTSS_COLORARG1]&D3DTA_SELECTMASK)==D3DTA_CURRENT)
            smoothA=TRUE;
        else
            smoothC=TRUE;
        break;
    }

    pContext->hwState.dwNextAvailableTextureUnit=0;
    //input value A from stage0 Arg
    if (ptssState0->dwValue[D3DTSS_COLOROP] == D3DTOP_SELECTARG1)
    {
        SelectColorInput(pContext, celsiusCombinerInputA, 0, 0, D3DTSS_COLORARG1,compA,FALSE,repA);
        if(smoothA)  //input D as ~(A-alpha)
        {
            compA ^=TRUE;
            SelectColorInput(pContext, celsiusCombinerInputD, 0, 0, D3DTSS_COLORARG1,compA,FALSE,repA);
        }
    }
    else//D3DOP_SELECTARG2
    {
        SelectColorInput(pContext, celsiusCombinerInputA, 0, 0, D3DTSS_COLORARG2,compA,FALSE,repA);
        if(smoothA) //input D as ~(A-alpha)
        {
            compA ^=TRUE;
            SelectColorInput(pContext, celsiusCombinerInputD, 0, 0, D3DTSS_COLORARG1,compA,FALSE,repA);
        }
    }

    pContext->hwState.dwNextAvailableTextureUnit=1;

    //input value C from stage1 args
    if((ptssState1->dwValue[D3DTSS_COLORARG1]&D3DTA_SELECTMASK) == D3DTA_CURRENT)
    {
        SelectColorInput(pContext, celsiusCombinerInputC, 0, 1, D3DTSS_COLORARG2,FALSE,FALSE,FALSE);
        if(smoothC) //input B as ~(C-alpha)
        {
            SelectColorInput(pContext, celsiusCombinerInputB, 0, 1, D3DTSS_COLORARG2,TRUE,FALSE,FALSE);
            SetColorInputOne(pContext, celsiusCombinerInputD, 0, FALSE);
        }
    }
    else
    {
        SelectColorInput(pContext, celsiusCombinerInputC, 0, 1, D3DTSS_COLORARG1,FALSE,FALSE,FALSE);
        if(smoothC) //input B as ~(C-alpha)
        {
            SelectColorInput(pContext, celsiusCombinerInputB, 0, 1, D3DTSS_COLORARG1,TRUE,FALSE,FALSE);
            SetColorInputOne(pContext, celsiusCombinerInputD, 0, FALSE);
        }
    }

    //If no addSmooth is used, use the normal setting
    if((!smoothC)&&(!smoothA))
    {
        //Set B=1 or (-1 if op 1 is subtract)
        SetColorInputOne (pContext, celsiusCombinerInputB, 0, negB);
        //Set D=1 or (-1 if op 1 is subtract)
        SetColorInputOne (pContext, celsiusCombinerInputD, 0, negD);
    }

    //Color Combiner OCW[0]
    ConstructOutputColorCombiners(pContext, TRUE, 0, bias, shift, 0, 0, 0);
    //End of Color Combiner 0 Setup

    return (DD_OK);
}//end Add1

/***************************************************************************************
/*Set Color Combiner0 for op1=add/subtract: A=X0; B=1; C=0; D=0
/****************************************************************************************/
static HRESULT Mod1(PNVD3DCONTEXT pContext)
{
    int                     shift;
    PNVD3DTEXSTAGESTATE     ptssState0, ptssState1;
    BOOL                    compA0, repA0;

     //initialize the flags for combiner
    shift = 0;
    compA0=repA0=FALSE;

    //Set up some pointers to the individual texture stages.
    ptssState0 = &pContext->tssState[0];
    ptssState1 = &pContext->tssState[1];

    //initialize
    pContext->hwState.dwColorICW[0] = 0;
    pContext->hwState.dwColorOCW[0] = 0;


    if((((ptssState1->dwValue[D3DTSS_COLORARG1]&D3DTA_SELECTMASK)==D3DTA_CURRENT)
        &((ptssState1->dwValue[D3DTSS_COLORARG1]&D3DTA_COMPLEMENT)!=0))
        ||(((ptssState1->dwValue[D3DTSS_COLORARG2]&D3DTA_SELECTMASK)==D3DTA_CURRENT)
        &((ptssState1->dwValue[D3DTSS_COLORARG2]&D3DTA_COMPLEMENT)!=0)))
        compA0 ^=TRUE;

    switch (ptssState1->dwValue[D3DTSS_COLOROP])
    {
    case D3DTOP_MODULATE2X:
        shift++;
        break;
    case D3DTOP_MODULATE4X:
        shift +=2;
        break;
    }
    //Color combiner ICW[0]
    //input value A from stage 0
    pContext->hwState.dwNextAvailableTextureUnit=0;
    if (ptssState0->dwValue[D3DTSS_COLOROP] == D3DTOP_SELECTARG1)
        SelectColorInput(pContext, celsiusCombinerInputA, 0, 0, D3DTSS_COLORARG1,compA0, FALSE, repA0);
    else//D3DOP_SELECTARG2
        SelectColorInput(pContext, celsiusCombinerInputA, 0, 0, D3DTSS_COLORARG2,compA0, FALSE, repA0);

    //input value B from Stage 1
    pContext->hwState.dwNextAvailableTextureUnit=1;
    if((ptssState1->dwValue[D3DTSS_COLORARG1]&D3DTA_SELECTMASK )== D3DTA_CURRENT)
        SelectColorInput(pContext, celsiusCombinerInputB, 0, 1, D3DTSS_COLORARG2,FALSE, FALSE, FALSE);
    else
        SelectColorInput(pContext, celsiusCombinerInputB, 0, 1, D3DTSS_COLORARG1,FALSE, FALSE, FALSE);

    //input value  C & D default to be 0

    //Color Combiner OCW[0]
    ConstructOutputColorCombiners(pContext, TRUE, 0, 0, shift, 0, 0, 0);
    //End of Color Combiner 0 Setup

    return (D3D_OK);
}//end Mod1


/********************************************************************
/* Set Color Combiner0 for AlphaBlend
/* alpha * arg1 + (1-alpha) * arg2
/********************************************************************/
static HRESULT Blend1(PNVD3DCONTEXT  pContext)
{
    int                    pm, type, temp;
    BOOL                   compA0, repA0;
    PNVD3DTEXSTAGESTATE    ptssState0, ptssState1;

    //initialize the flags for combiner
    pm=0;
    compA0=repA0=FALSE;

    //Set up some pointers to the individual texture stages.
    ptssState0 = &pContext->tssState[0];
    ptssState1 = &pContext->tssState[1];

    //initialize combiner0 & Combiner1
    pContext->hwState.dwColorICW[0] = 0;
    pContext->hwState.dwColorOCW[0] = 0;

    //deal with the situation for current complement
    if ((((ptssState1->dwValue[D3DTSS_COLORARG1] & D3DTA_SELECTMASK) == D3DTA_CURRENT) &&
         ((ptssState1->dwValue[D3DTSS_COLORARG1] & D3DTA_COMPLEMENT) != 0))
        ||
        (((ptssState1->dwValue[D3DTSS_COLORARG2] & D3DTA_SELECTMASK) == D3DTA_CURRENT) &&
         ((ptssState1->dwValue[D3DTSS_COLORARG2] & D3DTA_COMPLEMENT) != 0))) {
        compA0 ^= TRUE;
    }

    // check Stage1 op to determine source of alpha
    switch (ptssState1->dwValue[D3DTSS_COLOROP]) {
        case D3DTOP_BLENDDIFFUSEALPHA:
            type=D3DTA_DIFFUSE;
            break;
        case D3DTOP_BLENDTEXTUREALPHA:
            type=D3DTA_TEXTURE;
            // alpha comes from stage 1's texture
            pContext->hwState.dwNextAvailableTextureUnit = 1;
            break;
        case D3DTOP_BLENDFACTORALPHA:
            type=D3DTA_TFACTOR;
            break;
        case D3DTOP_BLENDTEXTUREALPHAPM:
            type=D3DTA_TEXTURE;
            // alpha comes from stage 1's texture
            pContext->hwState.dwNextAvailableTextureUnit = 1;
            pm=1;
            break;
        case D3DTOP_BLENDCURRENTALPHA:
            type=D3DTA_TEXTURE;
            // current alpha comes in from stage 0's texture
            pContext->hwState.dwNextAvailableTextureUnit = 0;
            break;
    }

    // A gets alpha (or 1)
    if (pm == 1) {
        // Make A 1 since texture is already pre-multiplied
        SetColorInputOne (pContext, celsiusCombinerInputA, 0, FALSE);
    }
    else {
        // Make A alpha, appropriate type
        temp = ptssState1->dwValue[D3DTSS_COLORARG2];
        ptssState1->dwValue[D3DTSS_COLORARG2] = type;
        SelectColorInput (pContext, celsiusCombinerInputA, 0, 1, D3DTSS_COLORARG2, FALSE, FALSE, TRUE);
        ptssState1->dwValue[D3DTSS_COLORARG2] = temp;
    }

    // C gets (1-alpha)
    temp = ptssState1->dwValue[D3DTSS_COLORARG1];
    ptssState1->dwValue[D3DTSS_COLORARG1] = type;
    SelectColorInput (pContext, celsiusCombinerInputC, 0, 1, D3DTSS_COLORARG1, TRUE, FALSE, TRUE);
    ptssState1->dwValue[D3DTSS_COLORARG1] = temp;

    // B gets arg1
    if ((ptssState1->dwValue[D3DTSS_COLORARG1] & D3DTA_SELECTMASK) == D3DTA_CURRENT) {
        // take output of d3d stage 0 (stage 0 op guaranteed to be a simple selectarg)
        pContext->hwState.dwNextAvailableTextureUnit = 0;
        SelectColorInput (pContext, celsiusCombinerInputB, 0, 0,
                          (ptssState0->dwValue[D3DTSS_COLOROP] == D3DTOP_SELECTARG1) ? D3DTSS_COLORARG1 : D3DTSS_COLORARG2,
                          compA0, FALSE, repA0);
    }
    else {
        // take arg1 from this stage in the normal fashion
        pContext->hwState.dwNextAvailableTextureUnit = 1;
        SelectColorInput (pContext, celsiusCombinerInputB, 0, 1, D3DTSS_COLORARG1, FALSE, FALSE, FALSE);
    }

    // D gets arg2
    if ((ptssState1->dwValue[D3DTSS_COLORARG1] & D3DTA_SELECTMASK) == D3DTA_CURRENT) {
        // take output of d3d stage 0 (stage 0 op guaranteed to be a simple selectarg)
        pContext->hwState.dwNextAvailableTextureUnit = 0;
        SelectColorInput (pContext, celsiusCombinerInputD, 0, 0,
                          (ptssState0->dwValue[D3DTSS_COLOROP] == D3DTOP_SELECTARG1) ? D3DTSS_COLORARG1 : D3DTSS_COLORARG2,
                          compA0, FALSE, repA0);
    }
    else if (((ptssState1->dwValue[D3DTSS_COLORARG2] & D3DTA_SELECTMASK) == D3DTA_CURRENT)
        && ((ptssState0->dwValue[D3DTSS_COLORARG1] & D3DTA_SELECTMASK) == D3DTA_TEXTURE)) {
        // take output of d3d stage 0 - fix for mfc tex bug ((tex0 OP tex1) MOD diffuse)
        pContext->hwState.dwNextAvailableTextureUnit = 0;
        SelectColorInput (pContext, celsiusCombinerInputD, 0, 0, D3DTSS_COLORARG1, compA0, FALSE, repA0);
    }
    else {
        // take arg2 from this stage in the normal fashion
        pContext->hwState.dwNextAvailableTextureUnit = 1;
        SelectColorInput (pContext, celsiusCombinerInputD, 0, 1, D3DTSS_COLORARG2, FALSE, FALSE, FALSE);
    }

    // color Combiner OCW[0]
    ConstructOutputColorCombiners(pContext, TRUE, 0, 0, 0, 0, 0, 0);

    return(D3D_OK);

} // Blend1


/*************************************************************************************
/* Color combiner1 set up for DX7 Stage 2
/**************************************************************************************/

/************************************************************************************
/ Color Combiner1 for op=add/mod/select in stage2
/************************************************************************************/
static HRESULT AddModSelect2(PNVD3DCONTEXT  pContext)
{
    int                     dotproduct, bias,shift, modselect;
    BOOL                    negD, smooth, forcearg1to1, forcearg2to1;
    PNVD3DTEXSTAGESTATE     ptssState2;

    //initialize
    negD=smooth=forcearg1to1=forcearg2to1=FALSE;
    dotproduct=bias =shift=modselect=0;

    ptssState2 = &pContext->tssState[2];

    pContext->hwState.dwColorICW[1] = 0; //enable 2 combiners
    pContext->hwState.dwColorOCW[1] = 0x20000000;

     //Check the Stage2 Op
     switch (ptssState2->dwValue[D3DTSS_COLOROP])
     {
     case D3DTOP_ADDSIGNED:
         bias=1;
         break;
     case D3DTOP_ADDSIGNED2X:
         bias=1;
         shift++;
         break;
     case D3DTOP_SUBTRACT:
         negD=TRUE;
         break;
     case D3DTOP_ADDSMOOTH:
         smooth=TRUE;
         break;
     case D3DTOP_MODULATE:
         modselect=1;
         break;
     case D3DTOP_MODULATE2X:
         modselect=1;
         shift++;
         break;
     case D3DTOP_MODULATE4X:
         modselect=1;
         shift +=2;
         break;
     case D3DTOP_SELECTARG1:
         modselect=1;
         forcearg2to1=TRUE;
         break;
     case D3DTOP_SELECTARG2:
         modselect=1;
         forcearg1to1=TRUE;
         break;
     case D3DTOP_DOTPRODUCT3: //in DX stage2
         dotproduct=1;
         modselect=1;
         pContext->hwState.dwStateFlags |= CELSIUS_FLAG_DOTPRODUCT3(1);
         break;
     }

     //Color combiner ICW[1]
     //input value A & B from Stage 2
     if(modselect) //modulate setting
     {
         if (forcearg1to1) SetColorInputOne (pContext, celsiusCombinerInputA, 1, FALSE);
         else              SelectColorInput(pContext, celsiusCombinerInputA, 1, 2, D3DTSS_COLORARG1,FALSE, FALSE, FALSE);

         if (forcearg2to1) SetColorInputOne (pContext, celsiusCombinerInputB, 1, FALSE);
         else              SelectColorInput(pContext, celsiusCombinerInputB, 1, 2, D3DTSS_COLORARG2,FALSE, FALSE, FALSE);
         //input value  C & D defalt to 0
     }
     else //add involved
     {
         SelectColorInput(pContext, celsiusCombinerInputA, 1, 2, D3DTSS_COLORARG1,FALSE, FALSE, FALSE);
         SelectColorInput(pContext, celsiusCombinerInputC, 1, 2, D3DTSS_COLORARG2,FALSE, FALSE, FALSE);
         SetColorInputOne (pContext, celsiusCombinerInputB, 1, FALSE);
         if(smooth)
             SelectColorInput(pContext, celsiusCombinerInputD, 1, 2, D3DTSS_COLORARG1,TRUE, FALSE, FALSE);
         else
             SetColorInputOne (pContext, celsiusCombinerInputD, 1, negD);
     }

     //Color Combiner OWC[1]
     ConstructOutputColorCombiners(pContext, TRUE, 1, bias, shift, dotproduct, 0, 0);

     //update the number of combinerstage that are used
     pContext->hwState.dwNumActiveCombinerStages = 2;

     return (D3D_OK);
}//end AddModSelect2

/************************************************************
Color: stage0: arg0+arg1; stage1: arg0*arg1
*************************************************************/
static HRESULT colorAddMod(PNVD3DCONTEXT  pContext, int textureCount)
{
    PNVD3DTEXSTAGESTATE ptssState0, ptssState1;
    int                 shift;

    //initialize the flag for combiner
    shift = 0;

    //Set up some pointers to the individual texture stages.
    ptssState0 = &pContext->tssState[0];
    ptssState1 = &pContext->tssState[1];

    //initialize color combiner0
    pContext->hwState.dwColorICW[0] = 0;
    pContext->hwState.dwColorOCW[0] = 0;

    //Disable color combine1
    pContext->hwState.dwColorICW[1]=0;
    pContext->hwState.dwColorOCW[1]=0x10000000;
    pContext->hwState.dwNumActiveCombinerStages = 1;

    //Check Stage0 Op

    // can't do subtraction. this would require a mapping like [0 1] -> [0 -1] which we don't have
    nvAssert (ptssState0->dwValue[D3DTSS_COLOROP] != D3DTOP_SUBTRACT);

    //Chech Stage1 Op
    switch (ptssState1->dwValue[D3DTSS_COLOROP])
    {
    case D3DTOP_MODULATE2X:
        shift++;
        break;
    case D3DTOP_MODULATE4X:
        shift +=2;
        break;
    }

    //Color combiner ICW[0]
    pContext->hwState.dwNextAvailableTextureUnit=0;

    //input A, C from stage0 args
    SelectColorInput(pContext, celsiusCombinerInputA, 0, 0, D3DTSS_COLORARG1, FALSE, FALSE, FALSE);
    SelectColorInput(pContext, celsiusCombinerInputC, 0, 0, D3DTSS_COLORARG2, FALSE, FALSE, FALSE);

    pContext->hwState.dwNextAvailableTextureUnit=textureCount-1;

    //input value  B & D from stage2 args (B=D)
    if((ptssState1->dwValue[D3DTSS_COLORARG1]&D3DTA_SELECTMASK) == D3DTA_CURRENT)
    {
        SelectColorInput(pContext, celsiusCombinerInputB, 0, 1, D3DTSS_COLORARG2,FALSE, FALSE, FALSE);
        SelectColorInput(pContext, celsiusCombinerInputD, 0, 1, D3DTSS_COLORARG2,FALSE, FALSE, FALSE);
    }
    else
    {
        SelectColorInput(pContext, celsiusCombinerInputB, 0, 1, D3DTSS_COLORARG1,FALSE, FALSE, FALSE);
        SelectColorInput(pContext, celsiusCombinerInputD, 0, 1, D3DTSS_COLORARG1,FALSE, FALSE, FALSE);
    }

    //Color Combiner OCW[0]
    ConstructOutputColorCombiners(pContext, TRUE, 0, 0, shift,0, 0, 0);
    return (D3D_OK);
}//colorAddMod


/************************************************************
Color: stage0: arg0*arg1; stage1: arg0+arg1
*************************************************************/
static HRESULT colorModAdd(PNVD3DCONTEXT  pContext, int textureCount)
{
    int                     shift, bias;
    PNVD3DTEXSTAGESTATE     ptssState0, ptssState1;

    //initialize the flags for combiner
    shift = bias = 0;

    //Set up some pointers to the individual texture stages.
    ptssState0 = &pContext->tssState[0];
    ptssState1 = &pContext->tssState[1];

    //initialize
    pContext->hwState.dwColorICW[0] = 0;
    pContext->hwState.dwColorOCW[0] = 0;
    pContext->hwState.dwColorICW[1] = 0;
    pContext->hwState.dwColorOCW[1] = 0x10000000;


    SetColorInputOne(pContext, celsiusCombinerInputD, 0, 0); // Set D = 1

    //Check Stage1 Op
    switch (ptssState1->dwValue[D3DTSS_COLOROP])
    {
    case D3DTOP_ADDSIGNED:
        bias=1;
        break;
    case D3DTOP_ADDSIGNED2X:
        bias=1;
        shift++;
        break;
    }

    //input A & B from stage 0
    pContext->hwState.dwNextAvailableTextureUnit=0;
    SelectColorInput(pContext, celsiusCombinerInputA, 0, 0, D3DTSS_COLORARG1, FALSE, FALSE, FALSE);
    SelectColorInput(pContext, celsiusCombinerInputB, 0, 0, D3DTSS_COLORARG2, FALSE, FALSE, FALSE);

    //input C from stage1
    pContext->hwState.dwNextAvailableTextureUnit=textureCount-1;
    if((ptssState1->dwValue[D3DTSS_COLORARG1]&D3DTA_SELECTMASK) == D3DTA_CURRENT)
        SelectColorInput(pContext, celsiusCombinerInputC, 0, 1, D3DTSS_COLORARG2, FALSE, FALSE, FALSE);
    else
        SelectColorInput(pContext, celsiusCombinerInputC, 0, 1, D3DTSS_COLORARG1, FALSE, FALSE, FALSE);


    if (ptssState1->dwValue[D3DTSS_COLOROP] == D3DTOP_SUBTRACT) {
        if((ptssState1->dwValue[D3DTSS_COLORARG1]&D3DTA_SELECTMASK)==D3DTA_CURRENT)
        {
            SetColorInputOne(pContext, celsiusCombinerInputD, 0, 1); //Set D = -1
        }
        else //Make the setting to be (A*(-B))+C*1
        {
            SetColorMapping(pContext, celsiusCombinerInputB, 0, NV056_SET_COMBINER_COLOR_ICW_D_MAP_SIGNED_NEGATE);
        }
    }

    //Color Combiner OCW[0]
    ConstructOutputColorCombiners(pContext, TRUE, 0, bias, shift,  0, 0, 0);
    //End of Color Combiner 0 Setup
    return (D3D_OK);
}//colorModAdd

/************************************************************
Alpha: stage0: arg0+arg1; stage1: arg0*arg1
*************************************************************/
static HRESULT alphaAddMod(PNVD3DCONTEXT  pContext, int textureCount)
{
    PNVD3DTEXSTAGESTATE ptssState0, ptssState1;
    int                 shift;

    //initialize the flag for combiner
    shift = 0;

    //Set up some pointers to the individual texture stages.
    ptssState0 = &pContext->tssState[0];
    ptssState1 = &pContext->tssState[1];

    //Disable alpha combines
    pContext->hwState.dwAlphaICW[0]=0;
    pContext->hwState.dwAlphaOCW[0]=0;
    pContext->hwState.dwAlphaICW[1]=0;
    pContext->hwState.dwAlphaOCW[1]=0;
    pContext->hwState.dwNumActiveCombinerStages = 1;

    //Check Stage0 Op

    // can't subtract. this would require a mapping like [0 1] -> [0 -1] which we don't have
    nvAssert (ptssState0->dwValue[D3DTSS_ALPHAOP] != D3DTOP_SUBTRACT);

    //Chech Stage1 Op
    switch (ptssState1->dwValue[D3DTSS_ALPHAOP])
    {
    case D3DTOP_MODULATE2X:
        shift++;
        break;
    case D3DTOP_MODULATE4X:
        shift += 2;
        break;
    }

    //ALPHA combiner ICW[0]
    pContext->hwState.dwNextAvailableTextureUnit=0;
    //input A, C from stage0 args
    SelectAlphaInput(pContext, celsiusCombinerInputA, 0, 0, D3DTSS_ALPHAARG1, FALSE, FALSE);
    SelectAlphaInput(pContext, celsiusCombinerInputC, 0, 0, D3DTSS_ALPHAARG2, FALSE, FALSE);

    pContext->hwState.dwNextAvailableTextureUnit = textureCount-1;

    //input value  B & D from stage1 args (B=D)
    if((ptssState1->dwValue[D3DTSS_ALPHAARG1]&D3DTA_SELECTMASK) == D3DTA_CURRENT)
    {
        SelectAlphaInput(pContext, celsiusCombinerInputB, 0, 1, D3DTSS_ALPHAARG2, FALSE, FALSE);
        SelectAlphaInput(pContext, celsiusCombinerInputD, 0, 1, D3DTSS_ALPHAARG2, FALSE, FALSE);
    }
    else
    {
        SelectAlphaInput(pContext, celsiusCombinerInputB, 0, 1, D3DTSS_ALPHAARG1, FALSE, FALSE);
        SelectAlphaInput(pContext, celsiusCombinerInputD, 0, 1, D3DTSS_ALPHAARG1, FALSE, FALSE);
    }


    //Color Combiner OCW[0]
    ConstructOutputAlphaCombiners(pContext, TRUE, 0, 0, shift, 0);
    //End of Color Combiner 0 Setup

    return (D3D_OK);

}//alphaAddMod

/************************************************************
Alpha: stage0: arg0*arg1; stage1: arg0+arg1
*************************************************************/
static HRESULT alphaModAdd(PNVD3DCONTEXT  pContext, int textureCount)
{   int                     shift, bias;
    PNVD3DTEXSTAGESTATE     ptssState0, ptssState1;
    BOOL     compA,repA,expA;

    //initialize the flags for combiner
    shift =bias = 0;
    compA=repA=expA=FALSE;

    //Set up some pointers to the individual texture stages.
    ptssState0 = &pContext->tssState[0];
    ptssState1 = &pContext->tssState[1];

    //initialize
    pContext->hwState.dwAlphaICW[0] = 0;
    pContext->hwState.dwAlphaOCW[0] = 0;
    pContext->hwState.dwAlphaICW[1] = 0;
    pContext->hwState.dwAlphaOCW[1] = 0; //0x10000000;

    //Set D = 1
    SetAlphaInputOne(pContext, celsiusCombinerInputD, 0, 0);

    //Check Stage1 Op
    switch (ptssState1->dwValue[D3DTSS_ALPHAOP])
    {
    case D3DTOP_ADDSIGNED:
        bias=1;
        break;
    case D3DTOP_ADDSIGNED2X:
        bias=1;
        shift++;
        break;
    case D3DTOP_SUBTRACT:
        if((ptssState1->dwValue[D3DTSS_ALPHAARG1]&D3DTA_SELECTMASK)==D3DTA_CURRENT)
        {
            //Set A*B+C*(-1)
            SetAlphaInputOne(pContext, celsiusCombinerInputD,0, 1);
        }
        else//Make the setting to be ((-A)*B))+C*1
        {
            compA ^=TRUE;
            expA=TRUE;
        }
        break;
    }

    //input A & B from stage 0
    pContext->hwState.dwNextAvailableTextureUnit=0;
    SelectAlphaInput(pContext, celsiusCombinerInputA, 0, 0, D3DTSS_ALPHAARG1,compA, expA);
    SelectAlphaInput(pContext, celsiusCombinerInputB, 0, 0, D3DTSS_ALPHAARG2,FALSE, FALSE);

    //input C from stage1
    pContext->hwState.dwNextAvailableTextureUnit=textureCount-1;
    if((ptssState1->dwValue[D3DTSS_ALPHAARG1]&D3DTA_SELECTMASK) == D3DTA_CURRENT)
        SelectAlphaInput(pContext, celsiusCombinerInputC, 0, 1, D3DTSS_ALPHAARG2,FALSE, FALSE);
    else
        SelectAlphaInput(pContext, celsiusCombinerInputC, 0, 1, D3DTSS_ALPHAARG1,FALSE, FALSE);


    //Alpha Combiner OCW[0]
    ConstructOutputAlphaCombiners(pContext, TRUE, 0, bias, shift, 0);

    return (D3D_OK);
}//alphaModAdd
 /***********************************************************************************
 /*Alpha combiner setup
/***********************************************************************************/
static HRESULT SetAlphaCombiner(PNVD3DCONTEXT pContext, DWORD alphaCount, DWORD textureCount)
{
    DWORD combCount;

    //Initialize alpha combiners
    pContext->hwState.dwAlphaICW[0] = 0;
    pContext->hwState.dwAlphaOCW[0] = 0;
    pContext->hwState.dwAlphaICW[1] = 0;
    pContext->hwState.dwAlphaOCW[1] = 0;

    combCount=pContext->hwState.dwNumActiveCombinerStages;

    pContext->hwState.dwNextAvailableTextureUnit=0;


    if(alphaCount<=1)
        ConstructAlphaCombiners(pContext, 0, 0, TRUE );

    else if(alphaCount==2)
    {
        if(combCount==1)
        {
            if(alphaCheck2Stage1Combiner(pContext))
            {
                PNVD3DTEXSTAGESTATE     ptssState0, ptssState1;
                //Set up some pointers to the individual texture stages.
                ptssState0 = &pContext->tssState[0];
                ptssState1 = &pContext->tssState[1];

                if((ptssState0->dwValue[D3DTSS_ALPHAOP] == D3DTOP_ADD)
                   &&
                   ((ptssState1->dwValue[D3DTSS_ALPHAOP] == D3DTOP_MODULATE)   ||
                    (ptssState1->dwValue[D3DTSS_ALPHAOP] == D3DTOP_MODULATE2X) ||
                    (ptssState1->dwValue[D3DTSS_ALPHAOP] == D3DTOP_MODULATE4X)))
                {
                    if (alphaAddMod(pContext, textureCount)==D3D_OK)
                        return D3D_OK;
                }

                //Modulate, Add
                if((ptssState0->dwValue[D3DTSS_ALPHAOP] == D3DTOP_MODULATE)
                    &&((ptssState1->dwValue[D3DTSS_ALPHAOP] == D3DTOP_ADD)
                    ||(ptssState1->dwValue[D3DTSS_ALPHAOP] == D3DTOP_ADDSIGNED)
                    ||(ptssState1->dwValue[D3DTSS_ALPHAOP] == D3DTOP_ADDSIGNED2X)
                    ||(ptssState1->dwValue[D3DTSS_ALPHAOP] == D3DTOP_SUBTRACT)))
                {
                    if (alphaModAdd(pContext, textureCount)==D3D_OK)
                        return D3D_OK;
                }
            }

            else
                pContext->hwState.dwColorOCW[1] = 0x20000000;//enable color combiner1
        }

        pContext->hwState.dwNumActiveCombinerStages = 2;

        pContext->hwState.dwNextAvailableTextureUnit=0;
        ConstructAlphaCombiners(pContext, 0,0, TRUE );
        pContext->hwState.dwNextAvailableTextureUnit=textureCount-1;
        ConstructAlphaCombiners(pContext, 1,1, TRUE );
    }
    else
        pContext->hwState.dwStateFlags |= CELSIUS_FLAG_SETUPFAILURE;

    return (D3D_OK);
}//end SetAlphaCombiner

/*************************************************************************
Set up color combiners for (X0 op X1) op X2 with 3 DX7 TSS:
*X0 is one of the colorargs from stage0
*X1 is one of the colorargs from stage1, cannot be D3DTA_CURRENT
*X2 is color arg from stage2, cannot be D3DTA_TEXTURE
In order the above is true:
*colorOp is stage0 has to be D3DTOP_SELECTARG1/2
*one and only one of the color args in stage1 to be D3DTA_CURRENT
*at least one of the color args in stage2 to be D3DTA_CURRENT

 op=all Modulateion,addition,subtraction and linear alpha blending
 Including D3DTOP_DUCTPRODUCT3 and D3DTOP_ADDSMOOTH

Only allow 2 alpha active stages, if has more, only look at the first 2
**************************************************************************/

#ifdef THREE_STAGE_ALPHA_SUPPORT

#define D3DTA_FLAGSMASK 0x000000f0
#define D3DTA_STAGEMASK 0xf0000000
#define D3DTA_STAGE0    0x00000000
#define D3DTA_STAGE1    0x10000000
#define D3DTA_STAGE2    0x20000000
#define D3DTA_STAGE3    0x30000000

HRESULT SelectAlphaInput2(PNVD3DCONTEXT pContext, celsiusCombinerInput eInput,
                          DWORD dwCombinerStage, DWORD dwArg, BOOL bComplement, BOOL bInv) {
    DWORD dwICW = 0x10101010;

    switch (dwArg & D3DTA_SELECTMASK) {
    case D3DTA_DIFFUSE:   dwICW |= DRF_DEF(056, _SET_COMBINER_ALPHA, _ICW_D_SOURCE, _REG_4);   break;
    case D3DTA_CURRENT:   dwICW |= DRF_DEF(056, _SET_COMBINER_ALPHA, _ICW_D_SOURCE, _REG_C);   break;
    case D3DTA_TEXTURE:
        if ((dwArg & D3DTA_STAGEMASK) == D3DTA_STAGE0) {
            dwICW |= DRF_DEF(056, _SET_COMBINER_ALPHA, _ICW_D_SOURCE, _REG_8);
        } else {
            dwICW |= DRF_DEF(056, _SET_COMBINER_ALPHA, _ICW_D_SOURCE, _REG_9);
        }
        break;
    case D3DTA_TFACTOR:   dwICW |= DRF_DEF(056, _SET_COMBINER_ALPHA, _ICW_D_SOURCE, _REG_1);   break;
    case D3DTA_SPECULAR:  dwICW |= DRF_DEF(056, _SET_COMBINER_ALPHA, _ICW_D_SOURCE, _REG_5);   break;
    case D3DTA_TEMP:      dwICW |= DRF_DEF(056, _SET_COMBINER_ALPHA, _ICW_D_SOURCE, _REG_D);   break;
    }

    if (bComplement && bInv) {
        // not quite right, but close enough
        dwICW |= DRF_DEF(056, _SET_COMBINER_ALPHA, _ICW_D_MAP, _EXPAND_NORMAL);
    } else if (bComplement && !bInv) {
        dwICW |= DRF_DEF(056, _SET_COMBINER_ALPHA, _ICW_D_MAP, _UNSIGNED_INVERT);
    } else if (!bComplement && bInv) {
        dwICW |= DRF_DEF(056, _SET_COMBINER_ALPHA, _ICW_D_MAP, _SIGNED_NEGATE);
    }

    pContext->hwState.dwAlphaICW[dwCombinerStage] |= (dwICW << celsiusCombinerInputShift[eInput]);

    return TRUE;
}


BOOL nvCelsiusSet3StageAlphaCombiners(PNVD3DCONTEXT pContext, BOOL program) {
    NVD3DTEXSTAGESTATE tssState0 = pContext->tssState[0];
    NVD3DTEXSTAGESTATE tssState1 = pContext->tssState[1];
    NVD3DTEXSTAGESTATE tssState2 = pContext->tssState[2];

    if (tssState0.dwValue[D3DTSS_RESULTARG] == D3DTA_TEMP) return FALSE;

    int current;
    if (tssState0.dwValue[D3DTSS_ALPHAOP] == D3DTOP_SELECTARG1) {
        current = tssState0.dwValue[D3DTSS_ALPHAARG1];
    } else if (tssState0.dwValue[D3DTSS_ALPHAOP] == D3DTOP_SELECTARG2) {
        current = tssState0.dwValue[D3DTSS_ALPHAARG2];
    } else {
        return FALSE;
    }

    tssState1.dwValue[D3DTSS_ALPHAARG1] |= D3DTA_STAGE1;
    tssState1.dwValue[D3DTSS_ALPHAARG2] |= D3DTA_STAGE1;

    if ((tssState1.dwValue[D3DTSS_ALPHAARG1] & D3DTA_SELECTMASK) == D3DTA_CURRENT) {
        tssState1.dwValue[D3DTSS_ALPHAARG1] = ((tssState1.dwValue[D3DTSS_ALPHAARG1] & D3DTA_FLAGSMASK) ^ (current & D3DTA_FLAGSMASK)) | current;
    }
    if ((tssState1.dwValue[D3DTSS_ALPHAARG2] & D3DTA_SELECTMASK) == D3DTA_CURRENT) {
        tssState1.dwValue[D3DTSS_ALPHAARG2] = ((tssState1.dwValue[D3DTSS_ALPHAARG2] & D3DTA_FLAGSMASK) ^ (current & D3DTA_FLAGSMASK)) | current;
    }


    // stage 0 current is really diffuse
    if ((tssState1.dwValue[D3DTSS_ALPHAARG1] & D3DTA_SELECTMASK) == D3DTA_CURRENT) {
        tssState1.dwValue[D3DTSS_ALPHAARG1] = (tssState1.dwValue[D3DTSS_ALPHAARG1] & D3DTA_FLAGSMASK) | D3DTA_DIFFUSE;
    }
    if ((tssState1.dwValue[D3DTSS_ALPHAARG2] & D3DTA_SELECTMASK) == D3DTA_CURRENT) {
        tssState1.dwValue[D3DTSS_ALPHAARG2] = (tssState1.dwValue[D3DTSS_ALPHAARG2] & D3DTA_FLAGSMASK) | D3DTA_DIFFUSE;
    }

    int shift=0, bias=0;
    int inputA=0xf, inputB=0xf, inputC=0xf, inputD=0xf, inputTemp;
    int invA=0, invB=0, invC=0, invD=0;
    int compA=0, compB=0, compC=0, compD=0;

    switch (tssState1.dwValue[D3DTSS_ALPHAOP]) {
    case D3DTOP_SELECTARG1:
        inputA = tssState1.dwValue[D3DTSS_ALPHAARG1];
        compB = 1;
        break;
    case D3DTOP_SELECTARG2:
        inputA = tssState1.dwValue[D3DTSS_ALPHAARG2];
        compB = 1;
        break;

    case D3DTOP_MODULATE4X:
        shift = 1;
    case D3DTOP_MODULATE2X:
        shift++;
    case D3DTOP_MODULATE:
        inputA = tssState1.dwValue[D3DTSS_ALPHAARG1];
        inputB = tssState1.dwValue[D3DTSS_ALPHAARG2];
        break;

    case D3DTOP_PREMODULATE:
    case D3DTOP_MODULATEALPHA_ADDCOLOR:
    case D3DTOP_MODULATECOLOR_ADDALPHA:
    case D3DTOP_MODULATEINVALPHA_ADDCOLOR:
    case D3DTOP_MODULATEINVCOLOR_ADDALPHA:
        break;

    case D3DTOP_ADDSIGNED2X:
        shift = 1;
    case D3DTOP_ADDSIGNED:
        bias = 1;
    case D3DTOP_ADD:
        inputA = tssState1.dwValue[D3DTSS_ALPHAARG1];
        compB = 1;
        inputC = tssState1.dwValue[D3DTSS_ALPHAARG2];
        compD = 1;
        break;

    case D3DTOP_SUBTRACT:
        inputA = tssState1.dwValue[D3DTSS_ALPHAARG1];
        compB = 1;
        inputC = tssState1.dwValue[D3DTSS_ALPHAARG2];
        compD = 1;
        invD = 1;
        break;

    case D3DTOP_ADDSMOOTH:
        inputA = tssState1.dwValue[D3DTSS_ALPHAARG1];
        inputB = tssState1.dwValue[D3DTSS_ALPHAARG2];
        compB = 1;
        inputC = tssState1.dwValue[D3DTSS_ALPHAARG2];
        compD = 1;
        break;

    case D3DTOP_BLENDDIFFUSEALPHA:
    case D3DTOP_BLENDTEXTUREALPHA:
    case D3DTOP_BLENDFACTORALPHA:
    case D3DTOP_BLENDTEXTUREALPHAPM:
    case D3DTOP_BLENDCURRENTALPHA:
        inputA = tssState1.dwValue[D3DTSS_ALPHAARG1];
        inputC = tssState1.dwValue[D3DTSS_ALPHAARG2];
        compD = 1;

        switch (tssState1.dwValue[D3DTSS_ALPHAOP]) {
        case D3DTOP_BLENDDIFFUSEALPHA:     inputTemp = D3DTA_DIFFUSE;  break;
        case D3DTOP_BLENDTEXTUREALPHA:     inputTemp = D3DTA_TEXTURE;  break;
        case D3DTOP_BLENDFACTORALPHA:      inputTemp = D3DTA_TFACTOR;  break;
        case D3DTOP_BLENDCURRENTALPHA:     inputTemp = current;        break;
        case D3DTOP_BLENDTEXTUREALPHAPM:   return FALSE;   // not supported yet
        }

        inputB = inputTemp;
        inputD = inputTemp;

        break;


    case D3DTOP_BUMPENVMAP:
    case D3DTOP_BUMPENVMAPLUMINANCE:
    case D3DTOP_DOTPRODUCT3:
    case D3DTOP_MULTIPLYADD:
    case D3DTOP_LERP:
        // not supported yet
        return FALSE;
    }

    if (program) {
        pContext->hwState.dwAlphaICW[0] = 0;
        pContext->hwState.dwAlphaOCW[0] = 0;
        SelectAlphaInput2(pContext, celsiusCombinerInputA, 0, inputA, compA, invA);
        SelectAlphaInput2(pContext, celsiusCombinerInputB, 0, inputB, compB, invB);
        SelectAlphaInput2(pContext, celsiusCombinerInputC, 0, inputC, compC, invC);
        SelectAlphaInput2(pContext, celsiusCombinerInputD, 0, inputD, compD, invD);
        ConstructOutputAlphaCombiners(pContext, TRUE, 0, bias, shift, tssState1.dwValue[D3DTSS_RESULTARG] == D3DTA_TEMP);
    }

//////////////////////////////////////

    shift = 0;
    bias = 0;
    inputA = inputB = inputC = inputD = 0xf;
    invA = invB = invC = invD = 0;
    compA = compB = compC = compD = 0;

    if (((tssState2.dwValue[D3DTSS_ALPHAARG1] & D3DTA_SELECTMASK) == D3DTA_TEXTURE) ||
        ((tssState2.dwValue[D3DTSS_ALPHAARG2] & D3DTA_SELECTMASK) == D3DTA_TEXTURE) ||
        ((tssState2.dwValue[D3DTSS_ALPHAARG1] & D3DTA_SELECTMASK) == D3DTA_TEMP) ||
        ((tssState2.dwValue[D3DTSS_ALPHAARG2] & D3DTA_SELECTMASK) == D3DTA_TEMP))
        return FALSE;

    switch (tssState2.dwValue[D3DTSS_ALPHAOP]) {
    case D3DTOP_SELECTARG1:
        inputA = tssState2.dwValue[D3DTSS_ALPHAARG1];
        compB = 1;
        break;
    case D3DTOP_SELECTARG2:
        inputA = tssState2.dwValue[D3DTSS_ALPHAARG2];
        compB = 1;
        break;

    case D3DTOP_MODULATE4X:
        shift = 1;
    case D3DTOP_MODULATE2X:
        shift++;
    case D3DTOP_MODULATE:
        inputA = tssState2.dwValue[D3DTSS_ALPHAARG1];
        inputB = tssState2.dwValue[D3DTSS_ALPHAARG2];
        break;

    case D3DTOP_PREMODULATE:
    case D3DTOP_MODULATEALPHA_ADDCOLOR:
    case D3DTOP_MODULATECOLOR_ADDALPHA:
    case D3DTOP_MODULATEINVALPHA_ADDCOLOR:
    case D3DTOP_MODULATEINVCOLOR_ADDALPHA:
        break;

    case D3DTOP_ADDSIGNED2X:
        shift = 2;
    case D3DTOP_ADDSIGNED:
        bias = 2;
    case D3DTOP_ADD:
        inputA = tssState2.dwValue[D3DTSS_ALPHAARG1];
        compB = 2;
        inputC = tssState2.dwValue[D3DTSS_ALPHAARG2];
        compD = 2;
        break;

    case D3DTOP_SUBTRACT:
        inputA = tssState2.dwValue[D3DTSS_ALPHAARG1];
        compB = 2;
        inputC = tssState2.dwValue[D3DTSS_ALPHAARG2];
        compD = 2;
        invD = 2;
        break;

    case D3DTOP_ADDSMOOTH:
        inputA = tssState2.dwValue[D3DTSS_ALPHAARG1];
        inputB = tssState2.dwValue[D3DTSS_ALPHAARG2];
        compB = 2;
        inputC = tssState2.dwValue[D3DTSS_ALPHAARG2];
        compD = 2;
        break;

    case D3DTOP_BLENDDIFFUSEALPHA:
    case D3DTOP_BLENDTEXTUREALPHA:
    case D3DTOP_BLENDFACTORALPHA:
    case D3DTOP_BLENDTEXTUREALPHAPM:
    case D3DTOP_BLENDCURRENTALPHA:
        inputA = tssState2.dwValue[D3DTSS_ALPHAARG1];
        inputC = tssState2.dwValue[D3DTSS_ALPHAARG2];
        compD = 1;

        switch (tssState2.dwValue[D3DTSS_ALPHAOP]) {
        case D3DTOP_BLENDDIFFUSEALPHA:     inputTemp = D3DTA_DIFFUSE;  break;
        case D3DTOP_BLENDTEXTUREALPHA:     inputTemp = D3DTA_TEXTURE;  break;
        case D3DTOP_BLENDFACTORALPHA:      inputTemp = D3DTA_TFACTOR;  break;
        case D3DTOP_BLENDCURRENTALPHA:     inputTemp = D3DTA_CURRENT;  break;
        case D3DTOP_BLENDTEXTUREALPHAPM:   return FALSE;   // not supported yet
        }

        break;

    case D3DTOP_BUMPENVMAP:
    case D3DTOP_BUMPENVMAPLUMINANCE:
    case D3DTOP_DOTPRODUCT3:
    case D3DTOP_MULTIPLYADD:
    case D3DTOP_LERP:
        // not supported yet
        return FALSE;
    }


    if (program) {
        pContext->hwState.dwAlphaICW[1] = 0;
        pContext->hwState.dwAlphaOCW[1] = 0;
        SelectAlphaInput2(pContext, celsiusCombinerInputA, 1, inputA, compA, invA);
        SelectAlphaInput2(pContext, celsiusCombinerInputB, 1, inputB, compB, invB);
        SelectAlphaInput2(pContext, celsiusCombinerInputC, 1, inputC, compC, invC);
        SelectAlphaInput2(pContext, celsiusCombinerInputD, 1, inputD, compD, invD);
        ConstructOutputAlphaCombiners(pContext, TRUE, 1, bias, shift, tssState2.dwValue[D3DTSS_RESULTARG] == D3DTA_TEMP);
    }

    return TRUE;
}
#endif

BOOL nvCelsiusCheck3Stage2Textures(PNVD3DCONTEXT pContext)
{
    if((Check3StageAlpha(pContext)
#ifdef THREE_STAGE_ALPHA_SUPPORT
        || nvCelsiusSet3StageAlphaCombiners(pContext, FALSE)
#endif
        )
        &&Check3StageColor(pContext))
        return TRUE;
    else
        return FALSE;
}

HRESULT nvCelsiusSetTextures3StageCombiners(PNVD3DCONTEXT pContext)
{

    PNVD3DTEXSTAGESTATE    ptssState0, ptssState1, ptssState2;
    DWORD                  alphaStageCount=0;

    ptssState0 = &pContext->tssState[0];
    ptssState1 = &pContext->tssState[1];
    ptssState2 = &pContext->tssState[2];

    dbgTracePush("nvCelsiusSetTextures3StageCombiners");

    while ((alphaStageCount < 8)
        &&(pContext->tssState[alphaStageCount].dwValue[D3DTSS_ALPHAOP] != D3DTOP_DISABLE))
    {
        alphaStageCount++;
    }

    //Set up Color Combiners
   //Check for Add in Stage1
    if((ptssState1->dwValue[D3DTSS_COLOROP] == D3DTOP_ADD)
        ||(ptssState1->dwValue[D3DTSS_COLOROP] == D3DTOP_ADDSIGNED)
        ||(ptssState1->dwValue[D3DTSS_COLOROP] == D3DTOP_ADDSIGNED2X)
        ||(ptssState1->dwValue[D3DTSS_COLOROP] == D3DTOP_SUBTRACT)
        ||(ptssState1->dwValue[D3DTSS_COLOROP] == D3DTOP_ADDSMOOTH))

    {
        //Cehck for AddMod which could be done in one combiner.
        if(((ptssState1->dwValue[D3DTSS_COLOROP] == D3DTOP_ADD)
            ||(ptssState1->dwValue[D3DTSS_COLOROP] == D3DTOP_SUBTRACT))
            &&((ptssState2->dwValue[D3DTSS_COLOROP] == D3DTOP_MODULATE)
            ||(ptssState2->dwValue[D3DTSS_COLOROP] == D3DTOP_MODULATE2X)
            ||(ptssState2->dwValue[D3DTSS_COLOROP] == D3DTOP_MODULATE4X))
            &&(((ptssState2->dwValue[D3DTSS_COLORARG1]&D3DTA_SELECTMASK)== D3DTA_CURRENT)
            ^((ptssState2->dwValue[D3DTSS_COLORARG2]&D3DTA_SELECTMASK)== D3DTA_CURRENT)))
        {
            if((ptssState1->dwValue[D3DTSS_COLORARG1]&D3DTA_SELECTMASK )== D3DTA_CURRENT)
            {
                if(!((ptssState1->dwValue[D3DTSS_COLORARG1]&D3DTA_COMPLEMENT)
                    ||(ptssState1->dwValue[D3DTSS_COLORARG1]&D3DTA_ALPHAREPLICATE)))
                {
                    if (AddMod1(pContext)==D3D_OK)
                        goto FinalStep;
                }
            }
            else
            {
                //hack for single combiner (arg1 OP arg2) MOD diffuse where OP=subtract when
                //arg1=tex0, arg2=tex0,diffuse,etc. the math fits in one combiner stage but the result
                //does not match refrast. TODO: make two tex,3 stage subtract work in one combiner
                if((ptssState0->dwValue[D3DTSS_COLOROP] == D3DTOP_SELECTARG1)
                    &&((ptssState0->dwValue[D3DTSS_COLORARG1]&D3DTA_SELECTMASK )== D3DTA_TEXTURE)
                    &&(ptssState1->dwValue[D3DTSS_COLOROP] == D3DTOP_SUBTRACT))
                {
                       goto Normal2ColorCombiner;
                }

                if(!((ptssState1->dwValue[D3DTSS_COLORARG2]&D3DTA_COMPLEMENT)
                   ||(ptssState1->dwValue[D3DTSS_COLORARG2]&D3DTA_ALPHAREPLICATE)))
                {
                   if (AddMod1(pContext)==D3D_OK)
                       goto FinalStep;
                 }
            }
        }

Normal2ColorCombiner:

        //Fall to the normal 2 color combiner stage
        if((ptssState2->dwValue[D3DTSS_COLOROP] == D3DTOP_ADD)
            ||(ptssState2->dwValue[D3DTSS_COLOROP] == D3DTOP_ADDSIGNED)
            ||(ptssState2->dwValue[D3DTSS_COLOROP] == D3DTOP_ADDSIGNED2X)
            ||(ptssState2->dwValue[D3DTSS_COLOROP] == D3DTOP_SUBTRACT)
            ||(ptssState2->dwValue[D3DTSS_COLOROP] == D3DTOP_ADDSMOOTH)
            ||(ptssState2->dwValue[D3DTSS_COLOROP] == D3DTOP_MODULATE)
            ||(ptssState2->dwValue[D3DTSS_COLOROP] == D3DTOP_MODULATE2X)
            ||(ptssState2->dwValue[D3DTSS_COLOROP] == D3DTOP_MODULATE4X)
            //Last stage, stage2: Color operation could be dotprocut3
            ||(ptssState2->dwValue[D3DTSS_COLOROP] == D3DTOP_DOTPRODUCT3))

        {
            Add1(pContext);
            AddModSelect2(pContext);
            goto FinalStep;
        }

        else //Something Wrong
            goto Invalid;
    }

    //Check for Modulate in stage 1
    else if ((ptssState1->dwValue[D3DTSS_COLOROP] == D3DTOP_MODULATE)
        ||(ptssState1->dwValue[D3DTSS_COLOROP] == D3DTOP_MODULATE2X)
        ||(ptssState1->dwValue[D3DTSS_COLOROP] == D3DTOP_MODULATE4X))

    {
        if((ptssState2->dwValue[D3DTSS_COLOROP] == D3DTOP_ADD)
            ||(ptssState2->dwValue[D3DTSS_COLOROP] == D3DTOP_ADDSIGNED)
            ||(ptssState2->dwValue[D3DTSS_COLOROP] == D3DTOP_ADDSIGNED2X)
            ||(ptssState2->dwValue[D3DTSS_COLOROP] == D3DTOP_SUBTRACT)
            ||(ptssState2->dwValue[D3DTSS_COLOROP] == D3DTOP_ADDSMOOTH)
            ||(ptssState2->dwValue[D3DTSS_COLOROP] == D3DTOP_MODULATE)
            ||(ptssState2->dwValue[D3DTSS_COLOROP] == D3DTOP_MODULATE2X)
            ||(ptssState2->dwValue[D3DTSS_COLOROP] == D3DTOP_MODULATE4X)
            //Last stage, stage2: Color operation could be dotprocut3
            ||(ptssState2->dwValue[D3DTSS_COLOROP] == D3DTOP_DOTPRODUCT3))
        {
            Mod1(pContext);
            AddModSelect2(pContext);
            goto FinalStep;
        }

        else //Something Wrong
            goto Invalid;
    }

    //Check for alphaBlend in Stage1
    else if((ptssState1->dwValue[D3DTSS_COLOROP] == D3DTOP_BLENDDIFFUSEALPHA)
        ||(ptssState1->dwValue[D3DTSS_COLOROP] == D3DTOP_BLENDTEXTUREALPHA)
        ||(ptssState1->dwValue[D3DTSS_COLOROP] == D3DTOP_BLENDFACTORALPHA)
        ||(ptssState1->dwValue[D3DTSS_COLOROP] == D3DTOP_BLENDTEXTUREALPHAPM)
        ||(ptssState1->dwValue[D3DTSS_COLOROP] == D3DTOP_BLENDCURRENTALPHA))
    {
        if((ptssState2->dwValue[D3DTSS_COLOROP] == D3DTOP_ADD)
            ||(ptssState2->dwValue[D3DTSS_COLOROP] == D3DTOP_ADDSIGNED)
            ||(ptssState2->dwValue[D3DTSS_COLOROP] == D3DTOP_ADDSIGNED2X)
            ||(ptssState2->dwValue[D3DTSS_COLOROP] == D3DTOP_SUBTRACT)
            ||(ptssState2->dwValue[D3DTSS_COLOROP] == D3DTOP_ADDSMOOTH)
            ||(ptssState2->dwValue[D3DTSS_COLOROP] == D3DTOP_MODULATE)
            ||(ptssState2->dwValue[D3DTSS_COLOROP] == D3DTOP_MODULATE2X)
            ||(ptssState2->dwValue[D3DTSS_COLOROP] == D3DTOP_MODULATE4X)
            ||(ptssState2->dwValue[D3DTSS_COLOROP] == D3DTOP_SELECTARG1)
            ||(ptssState2->dwValue[D3DTSS_COLOROP] == D3DTOP_SELECTARG2)
            //Last stage, stage2: Color operation could be dotprocut3
            ||(ptssState2->dwValue[D3DTSS_COLOROP] == D3DTOP_DOTPRODUCT3))
        {
            Blend1(pContext);
            AddModSelect2(pContext);
            goto FinalStep;
        }
        else
            goto Invalid;
    }
    else
        goto Invalid;

Invalid:

    DPF ("Invalid COLOR OPERATION for 2 texture 3 stages");
    nvAssert(0);

    pContext->hwState.dwStateFlags |= CELSIUS_FLAG_SETUPFAILURE;
    dbgTracePop();
    return (D3D_OK);

FinalStep:
#ifdef THREE_STAGE_ALPHA_SUPPORT
    if (alphaStageCount > 2) {
        nvCelsiusSet3StageAlphaCombiners(pContext, TRUE);
    } else
#endif
    {
        SetAlphaCombiner (pContext,alphaStageCount, 2);
    }
    pContext->hwState.dwTexUnitToTexStageMapping[0]=0;
    pContext->hwState.dwTexUnitToTexStageMapping[1]=1;

#if COMBINER_STATUS
    DPF ("Result in 3 stage 2 set up");
    DPF ("   color icw[0] = 0x%08x", pContext->hwState.dwColorICW[0]);
    DPF ("   color ocw[0] = 0x%08x", pContext->hwState.dwColorOCW[0]);
    DPF ("   alpha icw[0] = 0x%08x", pContext->hwState.dwAlphaICW[0]);
    DPF ("   alpha ocw[0] = 0x%08x", pContext->hwState.dwAlphaOCW[0]);
    DPF ("   color icw[1] = 0x%08x", pContext->hwState.dwColorICW[1]);
    DPF ("   color ocw[1] = 0x%08x", pContext->hwState.dwColorOCW[1]);
    DPF ("   alpha icw[1] = 0x%08x", pContext->hwState.dwAlphaICW[1]);
    DPF ("   alpha ocw[1] = 0x%08x", pContext->hwState.dwAlphaOCW[1]);
    __asm int 3;
#endif
    dbgTracePop();
    return (D3D_OK);

} // nvCelsiusSetTextures3StagesCombiners

/**************************************************************
For special 2 DX texutre stages but only one combiner stage
case 1:
stage0: arg0+arg1
stage1: arg0*arg1  (arg0=current or arg1=current)

case 2:
stage0: arg0*arg1
stage1: arg0+arg1  (arg0=current or arg1=current)

+ = ADD, ADDSIGNED, ADDSIGNED2X, SUBTRACR
* = MODULATE, MODULATE2X, MODULATE4X, cannot be DOT3
***************************************************************/


BOOL nvCelsiusCheck2Stage1Combiner (PNVD3DCONTEXT pContext)
{
    if(colorCheck2Stage1Combiner(pContext)
        &&alphaCheck2Stage1Combiner(pContext))
        return TRUE;
    else
        return FALSE;
}//nvCelsiusCheck2Stage1Combiner


HRESULT nvCelsiusSet2Stage1Combiner (PNVD3DCONTEXT pContext)
{
    PNVD3DTEXSTAGESTATE    ptssState0, ptssState1;
    WORD alphaStageCount, textureCount;

    ptssState0 = &pContext->tssState[0];
    ptssState1 = &pContext->tssState[1];

    dbgTracePush("nvCelsiusSet2Stage1Combiner");

    alphaStageCount=textureCount=0;

    //Get the # of active alpha stages
    while ((alphaStageCount < 8)
        &&(pContext->tssState[alphaStageCount].dwValue[D3DTSS_ALPHAOP] != D3DTOP_DISABLE))
    {
        alphaStageCount++;
    }

    //Get the  # of active textures
    if((((ptssState0->dwValue[D3DTSS_COLORARG1] & D3DTA_SELECTMASK)== D3DTA_TEXTURE)
        &&(ptssState0->dwValue[D3DTSS_COLOROP] != D3DTOP_SELECTARG2))
        ||(((ptssState0->dwValue[D3DTSS_COLORARG2] & D3DTA_SELECTMASK)== D3DTA_TEXTURE)
        &&(ptssState0->dwValue[D3DTSS_COLOROP] != D3DTOP_SELECTARG1))
        ||(((ptssState0->dwValue[D3DTSS_ALPHAARG1] & D3DTA_SELECTMASK)== D3DTA_TEXTURE)
        &&(ptssState0->dwValue[D3DTSS_ALPHAOP] != D3DTOP_SELECTARG2))
        ||(((ptssState0->dwValue[D3DTSS_ALPHAARG2] & D3DTA_SELECTMASK)== D3DTA_TEXTURE)
        &&(ptssState0->dwValue[D3DTSS_ALPHAOP] != D3DTOP_SELECTARG1)))
        textureCount++;

    if((((ptssState1->dwValue[D3DTSS_COLORARG1] & D3DTA_SELECTMASK)== D3DTA_TEXTURE)
        &&(ptssState1->dwValue[D3DTSS_COLOROP] != D3DTOP_SELECTARG2))
        ||(((ptssState1->dwValue[D3DTSS_COLORARG2] & D3DTA_SELECTMASK)== D3DTA_TEXTURE)
        &&(ptssState1->dwValue[D3DTSS_COLOROP] != D3DTOP_SELECTARG1))
        ||(((ptssState1->dwValue[D3DTSS_ALPHAARG1] & D3DTA_SELECTMASK)== D3DTA_TEXTURE)
        &&(ptssState1->dwValue[D3DTSS_ALPHAOP] != D3DTOP_SELECTARG2))
        ||(((ptssState1->dwValue[D3DTSS_ALPHAARG2] & D3DTA_SELECTMASK)== D3DTA_TEXTURE)
        &&(ptssState1->dwValue[D3DTSS_ALPHAOP] != D3DTOP_SELECTARG1)))
        textureCount++;

    //Add, Modulate
    if ((ptssState0->dwValue[D3DTSS_COLOROP] == D3DTOP_ADD)
        &&
        ((ptssState1->dwValue[D3DTSS_COLOROP] == D3DTOP_MODULATE)   ||
         (ptssState1->dwValue[D3DTSS_COLOROP] == D3DTOP_MODULATE2X) ||
         (ptssState1->dwValue[D3DTSS_COLOROP] == D3DTOP_MODULATE4X)))
    {
        if (colorAddMod(pContext,textureCount) == D3D_OK)
            goto Final;
        else
            goto Fail;
    }

    //Modulate, Add
    if((ptssState0->dwValue[D3DTSS_COLOROP] == D3DTOP_MODULATE)
        &&((ptssState1->dwValue[D3DTSS_COLOROP] == D3DTOP_ADD)
        ||(ptssState1->dwValue[D3DTSS_COLOROP] == D3DTOP_ADDSIGNED)
        ||(ptssState1->dwValue[D3DTSS_COLOROP] == D3DTOP_ADDSIGNED2X)
        ||(ptssState1->dwValue[D3DTSS_COLOROP] == D3DTOP_SUBTRACT)))
    {
        if(colorModAdd(pContext,textureCount)==D3D_OK)
            goto Final;
        else
            goto Fail;
    }


Final:
    SetAlphaCombiner(pContext, alphaStageCount, textureCount);

#if COMBINER_STATUS
    DPF ("Result in 3 stage 2 set up");
    DPF ("   color icw[0] = 0x%08x", pContext->hwState.dwColorICW[0]);
    DPF ("   color ocw[0] = 0x%08x", pContext->hwState.dwColorOCW[0]);
    DPF ("   alpha icw[0] = 0x%08x", pContext->hwState.dwAlphaICW[0]);
    DPF ("   alpha ocw[0] = 0x%08x", pContext->hwState.dwAlphaOCW[0]);
    DPF ("   color icw[1] = 0x%08x", pContext->hwState.dwColorICW[1]);
    DPF ("   color ocw[1] = 0x%08x", pContext->hwState.dwColorOCW[1]);
    DPF ("   alpha icw[1] = 0x%08x", pContext->hwState.dwAlphaICW[1]);
    DPF ("   alpha ocw[1] = 0x%08x", pContext->hwState.dwAlphaOCW[1]);
    __asm int 3;
#endif
    dbgTracePop();
    return (D3D_OK);

Fail:
    //reset the texture unit
    pContext->hwState.dwNextAvailableTextureUnit =0;
    dbgTracePop();
    return (DD_FALSE);
}//nvCelsiusSet2Stage1Combiner


/**************************************************************
*For special 3 DX texutre stages but only one combiner stage
***************************************************************/
BOOL nvCelsiusCheck3StageSpecial (PNVD3DCONTEXT pContext)
{

    PNVD3DTEXSTAGESTATE    ptssState0, ptssState1, ptssState2;
    DWORD                  alphaStageCount=0;

    ptssState0 = &pContext->tssState[0];
    ptssState1 = &pContext->tssState[1];
    ptssState2 = &pContext->tssState[2];


    //check for specular and fog off
    if((pContext->dwRenderState[D3DRENDERSTATE_SPECULARENABLE])
        ||(pContext->dwRenderState[D3DRENDERSTATE_FOGENABLE]))
        return FALSE;

    //check for the # of active alpha stages
    while ((alphaStageCount < 8)
        &&(pContext->tssState[alphaStageCount].dwValue[D3DTSS_ALPHAOP] != D3DTOP_DISABLE))
    {
        alphaStageCount++;
    }

    if(alphaStageCount>1)
        return FALSE;

    //check the color operations in all 3 stages
    if((ptssState0->dwValue[D3DTSS_COLOROP]!= D3DTOP_DOTPRODUCT3)
        ||(ptssState1->dwValue[D3DTSS_COLOROP]!= D3DTOP_MODULATE)
        ||(ptssState2->dwValue[D3DTSS_COLOROP]!= D3DTOP_MODULATE))
        return FALSE;

    //check for the stage0 args: one and only one arg to be texture
    if(!(((ptssState0->dwValue[D3DTSS_COLORARG1]&D3DTA_SELECTMASK)== D3DTA_TEXTURE)
        ^((ptssState0->dwValue[D3DTSS_COLORARG2]&D3DTA_SELECTMASK)== D3DTA_TEXTURE)))
        return FALSE;

    //check for the stage1 args:
    //arg1=texture arg2=current  or arg1=current, arg2=texture
    if(!((((ptssState1->dwValue[D3DTSS_COLORARG1]&D3DTA_SELECTMASK)== D3DTA_TEXTURE)
        &&((ptssState1->dwValue[D3DTSS_COLORARG2]&D3DTA_SELECTMASK)== D3DTA_CURRENT))
        ||(((ptssState1->dwValue[D3DTSS_COLORARG2]&D3DTA_SELECTMASK)== D3DTA_TEXTURE)
        &&((ptssState1->dwValue[D3DTSS_COLORARG1]&D3DTA_SELECTMASK)== D3DTA_CURRENT))))
        return FALSE;

    //check for the stage2 args: at least one of the arg to be current
    if(((ptssState2->dwValue[D3DTSS_COLORARG1]&D3DTA_SELECTMASK)!= D3DTA_CURRENT)
        &&((ptssState2->dwValue[D3DTSS_COLORARG2]&D3DTA_SELECTMASK)!= D3DTA_CURRENT))
        return FALSE;

    //check for stage2 args: not texture should be used
    if(((ptssState2->dwValue[D3DTSS_COLORARG1]&D3DTA_SELECTMASK)== D3DTA_TEXTURE)
        ||((ptssState2->dwValue[D3DTSS_COLORARG2]&D3DTA_SELECTMASK)== D3DTA_TEXTURE))
        return FALSE;

    //alpha replication cannot be used in stage2 current
    if(((ptssState2->dwValue[D3DTSS_COLORARG1]&D3DTA_ALPHAREPLICATE)
        &&((ptssState2->dwValue[D3DTSS_COLORARG1]&D3DTA_SELECTMASK)== D3DTA_CURRENT))
        ||((ptssState2->dwValue[D3DTSS_COLORARG2]&D3DTA_ALPHAREPLICATE)
        &&((ptssState2->dwValue[D3DTSS_COLORARG2]&D3DTA_SELECTMASK)== D3DTA_CURRENT)))
        return FALSE;

    //validate textures
    if(!((ptssState0->dwValue[D3DTSS_TEXTUREMAP])
        &&(ptssState1->dwValue[D3DTSS_TEXTUREMAP])))
        return FALSE;

    return TRUE;
}

HRESULT nvCelsiusSet3StageSpecial (PNVD3DCONTEXT pContext)
{
    // HW control words for SpecularFog combiner
    DWORD dwControl0, dwControl1;
    PNVD3DTEXSTAGESTATE     ptssState0, ptssState1, ptssState2;

    ptssState0 = &pContext->tssState[0];
    ptssState1 = &pContext->tssState[1];
    ptssState2 = &pContext->tssState[2];

    //Disable color combinr1
    pContext->hwState.dwNumActiveCombinerStages = 1;
    pContext->hwState.dwColorICW[1]=0;
    pContext->hwState.dwColorOCW[1]=0x10000000;

    //initialize alpha combiner
    pContext->hwState.dwAlphaICW[0]=0;
    pContext->hwState.dwAlphaOCW[0]=0;
    pContext->hwState.dwAlphaICW[1]=0;
    pContext->hwState.dwAlphaOCW[1]=0;

    //initialize SpecularFog combiner
    dwControl0=dwControl1=0;

    //map stage0 to color combiner0
    pContext->hwState.dwNextAvailableTextureUnit=0;
    ConstructColorCombiners (pContext, 0, 0);
    //alpha value is going to be pull from the result of color stage0
    //don't bother to canculate.

    pContext->hwState.dwNextAvailableTextureUnit=1;

    //Use SpecularFog combiner as another two layer of color combiner

    //A= current (E*F)
    dwControl0 |= DRF_DEF(056, _SET_COMBINER_SPECULAR_FOG_CW0, _A_SOURCE, _REG_EF_PROD);

    //B= ARG in stage2

    //in stage2 arg1=current
    if((ptssState2->dwValue[D3DTSS_COLORARG1]&D3DTA_SELECTMASK)==D3DTA_CURRENT)
    {
        //complement of A (current/arg1)
        if(ptssState2->dwValue[D3DTSS_COLORARG1]&D3DTA_COMPLEMENT)
            dwControl0 |= DRF_DEF(056, _SET_COMBINER_SPECULAR_FOG_CW0, _A_INVERSE, _TRUE);

        //complement and alpha replication of B (arg2)
        if(ptssState2->dwValue[D3DTSS_COLORARG2]&D3DTA_COMPLEMENT)
            dwControl0 |= DRF_DEF(056, _SET_COMBINER_SPECULAR_FOG_CW0, _B_INVERSE, _TRUE);

        if(ptssState2->dwValue[D3DTSS_COLORARG2]&D3DTA_ALPHAREPLICATE)
            dwControl0 |= DRF_DEF(056, _SET_COMBINER_SPECULAR_FOG_CW0, _B_ALPHA, _TRUE);

        switch (ptssState2->dwValue[D3DTSS_COLORARG2]&D3DTA_SELECTMASK)
        {
        case D3DTA_CURRENT:
            dwControl0 |= DRF_DEF(056, _SET_COMBINER_SPECULAR_FOG_CW0, _B_SOURCE, _REG_EF_PROD);
            break;

        case D3DTA_DIFFUSE:
            dwControl0 |= DRF_DEF(056, _SET_COMBINER_SPECULAR_FOG_CW0, _B_SOURCE, _REG_4);
            break;

        case D3DTA_TFACTOR:
            dwControl0 |= DRF_DEF(056, _SET_COMBINER_SPECULAR_FOG_CW0, _B_SOURCE, _REG_1);
            break;

        case D3DTA_SPECULAR:
            dwControl0 |= DRF_DEF(056, _SET_COMBINER_SPECULAR_FOG_CW0, _B_SOURCE, _REG_5);
            break;

        default:
            pContext->hwState.dwStateFlags |= CELSIUS_FLAG_SETUPFAILURE;
            break;
        }
    }

    else //in stage2 arg2 is current
    {
        //complement of A (current/arg2)
        if(ptssState2->dwValue[D3DTSS_COLORARG2]&D3DTA_COMPLEMENT)
            dwControl0 |= DRF_DEF(056, _SET_COMBINER_SPECULAR_FOG_CW0, _A_INVERSE, _TRUE);

        //complement and alpha replication of B (arg2)
        if(ptssState2->dwValue[D3DTSS_COLORARG1]&D3DTA_COMPLEMENT)
            dwControl0 |= DRF_DEF(056, _SET_COMBINER_SPECULAR_FOG_CW0, _B_INVERSE, _TRUE);

        if(ptssState2->dwValue[D3DTSS_COLORARG1]&D3DTA_ALPHAREPLICATE)
            dwControl0 |= DRF_DEF(056, _SET_COMBINER_SPECULAR_FOG_CW0, _B_ALPHA, _TRUE);

        switch (ptssState2->dwValue[D3DTSS_COLORARG1]&D3DTA_SELECTMASK)
        {
        case D3DTA_CURRENT:
            dwControl0 |= DRF_DEF(056, _SET_COMBINER_SPECULAR_FOG_CW0, _B_SOURCE, _REG_EF_PROD);
            break;

        case D3DTA_DIFFUSE:
            dwControl0 |= DRF_DEF(056, _SET_COMBINER_SPECULAR_FOG_CW0, _B_SOURCE, _REG_4);
            break;

        case D3DTA_TFACTOR:
            dwControl0 |= DRF_DEF(056, _SET_COMBINER_SPECULAR_FOG_CW0, _B_SOURCE, _REG_1);
            break;

        case D3DTA_SPECULAR:
            dwControl0 |= DRF_DEF(056, _SET_COMBINER_SPECULAR_FOG_CW0, _B_SOURCE, _REG_5);
            pContext->hwState.dwStateFlags |= CELSIUS_FLAG_COMBINERSNEEDSPECULAR;
            break;

        default:
            pContext->hwState.dwStateFlags |= CELSIUS_FLAG_SETUPFAILURE;
            break;
        }
    }

    //C=0, D=0

    //E=T1, F=current

    dwControl1 |= (DRF_DEF(056, _SET_COMBINER_SPECULAR_FOG_CW1, _E_SOURCE, _REG_9)|
                   DRF_DEF(056, _SET_COMBINER_SPECULAR_FOG_CW1, _F_SOURCE, _REG_C));

    //in stage1 arg1=current
    if((ptssState1->dwValue[D3DTSS_COLORARG1]&D3DTA_SELECTMASK)==D3DTA_CURRENT)
    {
        //complement and alphareplication of F (current/arg1)
        if(ptssState1->dwValue[D3DTSS_COLORARG1]&D3DTA_COMPLEMENT)
            dwControl1 |= DRF_DEF(056, _SET_COMBINER_SPECULAR_FOG_CW1, _F_INVERSE, _TRUE);
        if(ptssState1->dwValue[D3DTSS_COLORARG1]&D3DTA_ALPHAREPLICATE)
            dwControl1 |= DRF_DEF(056, _SET_COMBINER_SPECULAR_FOG_CW1, _F_ALPHA, _TRUE);

        //complement and alphareplication of E (T1/arg2)
        if(ptssState1->dwValue[D3DTSS_COLORARG2]&D3DTA_COMPLEMENT)
            dwControl1 |= DRF_DEF(056, _SET_COMBINER_SPECULAR_FOG_CW1, _E_INVERSE, _TRUE);
        if(ptssState1->dwValue[D3DTSS_COLORARG2]&D3DTA_ALPHAREPLICATE)
            dwControl1 |= DRF_DEF(056, _SET_COMBINER_SPECULAR_FOG_CW1, _E_ALPHA, _TRUE);
    }
    else  //in stage1 arg2=current
    {
        //complement and alphareplication of F (current/arg2)
        if(ptssState1->dwValue[D3DTSS_COLORARG2]&D3DTA_COMPLEMENT)
            dwControl1 |= DRF_DEF(056, _SET_COMBINER_SPECULAR_FOG_CW1, _F_INVERSE, _TRUE);
        if(ptssState1->dwValue[D3DTSS_COLORARG2]&D3DTA_ALPHAREPLICATE)
            dwControl1 |= DRF_DEF(056, _SET_COMBINER_SPECULAR_FOG_CW1, _F_ALPHA, _TRUE);

        //complement and alphareplication of E (T1/arg1)
        if(ptssState1->dwValue[D3DTSS_COLORARG1]&D3DTA_COMPLEMENT)
            dwControl1 |= DRF_DEF(056, _SET_COMBINER_SPECULAR_FOG_CW1, _E_INVERSE, _TRUE);
        if(ptssState1->dwValue[D3DTSS_COLORARG1]&D3DTA_ALPHAREPLICATE)
            dwControl1 |= DRF_DEF(056, _SET_COMBINER_SPECULAR_FOG_CW1, _E_ALPHA, _TRUE);
    }



    //G= out put of color from stage0 (regC' color chanel)
    dwControl1 |= (DRF_DEF(056, _SET_COMBINER_SPECULAR_FOG_CW1, _G_SOURCE, _REG_C)|
                   DRF_DEF(056, _SET_COMBINER_SPECULAR_FOG_CW1, _G_ALPHA, _FALSE));

    //Set the value
    pContext->hwState.celsius.set (NV056_SET_COMBINER_SPECULAR_FOG_CW0, dwControl0);
    pContext->hwState.celsius.set (NV056_SET_COMBINER_SPECULAR_FOG_CW1, dwControl1);

    pContext->hwState.dwDirtyFlags &= ~CELSIUS_DIRTY_SPECFOG_COMBINER;

    return D3D_OK;

}//nvCelsiusSet3Stage1Combiner


#endif // (NVARCH >= 0x10)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\ddraw\celsius\src\nvCelsiusInlTri.cpp ===
/*
 * Copyright 1993-1998 NVIDIA, Corporation.  All rights reserved.
 * THE INFORMATION CONTAINED HEREIN IS PROPRIETARY AND CONFIDENTIAL TO
 * NVIDIA, CORPORATION.  USE, REPRODUCTION OR DISCLOSURE TO ANY THIRD PARTY
 * IS SUBJECT TO WRITTEN PRE-APPROVAL BY NVIDIA, CORPORATION.
 */
/********************************* Direct 3D *******************************\
*                                                                           *
* Module: nvCelsiusInlTri.cpp                                               *
*       indexed and ordered inline triangle lists                           *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*       Ben de Waal             20Oct99         NV10 optimization effort    *
*                                                                           *
\***************************************************************************/
#include "nvprecomp.h"

#if (NVARCH >= 0x10)

#include "x86.h"

//////////////////////////////////////////////////////////////////////////////
// notes:
//  - when offset changes, only program it, dont call setcelsiusstate
//
//////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////
// switches
//

//////////////////////////////////////////////////////////////////////////////
// aliases
//
#define ilcData         global.dwILCData
#define ilcCount        global.dwILCCount
#define ilcMax          global.dwILCMax

//////////////////////////////////////////////////////////////////////////////
// externals
//
void ILCCompile_mul                            (DWORD reg,DWORD num);
void nvCelsiusILCompile_beginEnd               (DWORD dwPrimType);
void nvCelsiusILCompile_computeIndexAndOffset  (DWORD dwVBStride,DWORD dwVBLogStride);
void nvCelsiusILCompile_memcpy                 (DWORD dwCount, bool recurse);
void nvCelsiusILCompile_copyVertex             (PNVD3DCONTEXT pContext,DWORD dwFlags);
void nvCelsiusILCompile_prefetch               (BOOL bIsIndexed,BOOL bLegacyStrides);
void nvCelsiusILCompile_limit                  (DWORD regLimit,DWORD regDummy);

void __stdcall nvCelsiusDispatchGetFreeSpace   (PNVD3DCONTEXT pContext);
void __stdcall nvCelsiusDispatchGetPusherSpace (void);
#ifdef DEBUG
void __stdcall nvCelsiusDispatchFlush          (void);
void __stdcall nvCelsiusDispatchPrintVertex    (PNVD3DCONTEXT pContext,DWORD dwPutAddress);
#endif

/*****************************************************************************
 *****************************************************************************
 *** helpers *****************************************************************
 *****************************************************************************
 *****************************************************************************/

void nvCelsiusILCompile_cullcheck
(
    BOOL bIsIndexed
)
{
    //
    // get vertices into eax, ebx and ecx
    //
    if (bIsIndexed)
    {
        // already set up correctly
    }
    else
    {
        xMOV_r_i32       (rEAX,mMEM32(global.celsius.pVertices))
        xMOV_r_rm        (rEBX,rmREG(rEAX))
        xMOV_r_rm        (rECX,rmREG(rEAX))
        xADD_rm_imm      (rmREG(rEBX),global.celsius.dwVertexStride)
        xADD_rm_imm      (rmREG(rECX),global.celsius.dwVertexStride * 2)
    }

    //
    // compute cross product
    //
    if (pDriverData->nvD3DPerfData.dwCPUFeatureSet & FS_KATMAI)
    {
        /*
         * katmai
         */
        xMOVLPS_r_rm     (rXMM0,rmIND(rEAX))
        xMOVLPS_r_rm     (rXMM1,rmIND(rEBX))
        xSHUFPS_r_rm_imm (rXMM0,rmREG(rXMM0),0x44)          // xmm0: y0     x0      y0      x0
        xMOVHPS_r_rm     (rXMM1,rmIND(rECX))                // xmm1: y2     x2      y1      x1

        xSUBPS_r_rm      (rXMM1,rmREG(rXMM0))               // xmm1: y2-y0  x2-x0   y1-y0   x1-x0
        xSHUFPS_r_rm_imm (rXMM1,rmREG(rXMM1),0xe1)          // xmm1: y2-y0  x2-x0   x1-x0   y1-y0

        xMOVHLPS_r_r     (rXMM0,rXMM1)                      // xmm0: ?      ?       y2-y0   x2-x0
        xMULPS_r_rm      (rXMM0,rmREG(rXMM1))               // xmm0: ?      ?       (x1-x0)*(y2-y0) (y1-y0)*(x2-x0)

        xMOVAPS_r_rm     (rXMM1,rmREG(rXMM0))
        xSHUFPS_r_rm_imm (rXMM1,rmREG(rXMM1),0xe1)          // xmm1: ?      ?       ?       (x1-x0)*(y2-y0)

        xSUBSS_r_rm      (rXMM1,rmREG(rXMM0))               // xmm1: ?      ?       ?       (x1-x0)*(y2-y0)-(y1-y0)*(x2-x0)
        xMOVSS_i32_r     (mMEM32(global.dwTemp),rXMM1)
        xMOV_r_i32       (rEDX,mMEM32(global.dwTemp))
        xAND_rm_imm      (rmREG(rEDX),0x80000000)
        xCMP_r_i32       (rEDX,mMEM32(global.celsius.dwCullValue))
    }
    else
    {
        /*
         * generic
         */
        xFLD_rm32  (rmIND(rEAX))                    // X0
        xFLD_rm32  (rmIND(rEBX))                    // X1 | X0
        xFXCH_st   (rST1)                           // X0 | X1
        xFSUBP_st  (rST1)                           // X1-X0
        xFLD_rm32  (rmIND8(rECX)) xOFS8(4)          // Y2 | X1-X0
        xFXCH_st   (rST1)                           // X1-X0 | Y2
        xFLD_rm32  (rmIND8(rEAX)) xOFS8(4)          // Y0 | X1-X0 | Y2
        xFXCH_st   (rST1)                           // X1-X0 | Y0 | Y2
        xFLD_rm32  (rmIND(rECX))                    // X2 | X1-X0 | Y0 | Y2
        xFXCH_st   (rST3)                           // Y2 | X1-X0 | Y0 | X2
        xFLD_rm32  (rmIND(rEAX))                    // X0 | Y2 | X1-X0 | Y0 | X2
        xFXCH_st   (rST3)                           // Y0 | Y2 | X1-X0 | X0 | X2
        xFSUBP_st  (rST1)                           // Y2-Y0 | X1-X0 | X0 | X2
        xFXCH_st   (rST3)                           // X2 | X1-X0 | X0 | Y2-Y0
        xFLD_rm32  (rmIND8(rEBX)) xOFS8(4)          // Y1 | X2 | X1-X0 | X0 | Y2-Y0
        xFXCH_st   (rST3)                           // X0 | X2 | X1-X0 | Y1 | Y2-Y0
        xFSUBP_st  (rST1)                           // X2-X0 | X1-X0 | Y1 | Y2-Y0
        xFXCH_st   (rST3)                           // Y2-Y0 | X1-X0 | Y1 | X2-X0
        xFLD_rm32  (rmIND8(rEAX)) xOFS8(4)          // Y0 | Y2-Y0 | X1-X0 | Y1 | X2-X0
        xFXCH_st   (rST2)                           // X1-X0 | Y2-Y0 | Y0 | Y1 | X2-X0
        xFMULP_st  (rST1)                           // (X1-X0)(Y2-Y0) | Y0 | Y1 | X2-X0
        xFXCH_st   (rST1)                           // Y0 | (X1-X0)(Y2-Y0) | Y1 | X2-X0
        xFSUBP_st  (rST2)                           // (X1-X0)(Y2-Y0) | Y1-Y0 | X2-X0
        xFXCH_st   (rST2)                           // X2-X0 | Y1-Y0 | (X1-X0)(Y2-Y0)
        xFMULP_st  (rST1)                           // (X2-X0)(Y1-Y0) | (X1-X0)(Y2-Y0)
        xFSUBP_st  (rST1)                           // (X1-X0)(Y2-Y0)-(X2-X0)(Y1-Y0)
        xFSTP_i32  (mMEM32(global.dwTemp))
        xMOV_r_i32       (rEDX,mMEM32(global.dwTemp))
        xAND_rm_imm      (rmREG(rEDX),0x80000000)
        xCMP_r_i32       (rEDX,mMEM32(global.celsius.dwCullValue))
    }
}

/*****************************************************************************
 *****************************************************************************
 *** inline triangle lists ***************************************************
 *****************************************************************************
 *****************************************************************************/
DWORD nvCelsiusILCompile_inline_tri_list
(
    PNVD3DCONTEXT pContext,
    DWORD         dwFlags
)
{
    //
    // get loop constants
    //
    BOOL   bLegacyStrides = dwFlags & CELSIUS_ILFLAG_LEGACY;
    BOOL   bIsIndexed     = (dwFlags & CELSIUS_ILMASK_LOOPTYPE) == CELSIUS_ILFLAG_IX_INL_TRI_LIST;

    //
    // align entry point
    //
    while (ilcCount & 31) { xINT3 }
    DWORD lEntry;
    xLABEL (lEntry);

    //
    // setup stack frame
    //
    xPUSH_r     (rEBP)
    xPUSH_r     (rEBX)
    xPUSH_r     (rESI)
    xPUSH_r     (rEDI)

    //
    // verify that we are using the correct inner loop - debug only
    //
#ifdef DEBUG
    DWORD ld1,ld2;
    xLABEL      (ld1)
    xJMP        (0)
    xLABEL      (ld2)
    xINT3

#define CHECK(a,x)                  \
{                                   \
    xMOV_rm_imm (rmREG(rEBX),a)     \
    xMOV_rm_imm (rmREG(rEAX),x)     \
    xCMP_r_i32  (rEAX,mMEM32(x))    \
    xJNZ32      (ld2)               \
}
#define CHECK2(a,x,y,t)             \
{                                   \
    xMOV_r_i32  (rEDX,mMEM32(global.celsius.x))    \
    xMOV_rm_imm (rmREG(rEBX),a)     \
    xMOV_rm_imm (rmREG(rEAX),x->y)   \
    xCMP_r_rm   (rEAX,rmIND32(rEDX)) xOFS32(OFFSETOF(t,y)) \
    xJNZ32      (ld2)               \
}

    xTARGET_jmp (ld1)

/*
    CHECK (0x00000000,fvfData.dwVertexStride)

    CHECK (0x00010000,fvfData.dwVertexType)

    CHECK (0x00020000,fvfData.dwUVCount[0])
    CHECK (0x00020001,fvfData.dwUVCount[1])
    CHECK (0x00020002,fvfData.dwUVCount[2])
    CHECK (0x00020003,fvfData.dwUVCount[3])
    CHECK (0x00020004,fvfData.dwUVCount[4])
    CHECK (0x00020005,fvfData.dwUVCount[5])
    CHECK (0x00020006,fvfData.dwUVCount[6])
    CHECK (0x00020007,fvfData.dwUVCount[7])

    CHECK (0x00030000,fvfData.dwUVOffset[0])
    CHECK (0x00030001,fvfData.dwUVOffset[1])
    CHECK (0x00030002,fvfData.dwUVOffset[2])
    CHECK (0x00030003,fvfData.dwUVOffset[3])
    CHECK (0x00030004,fvfData.dwUVOffset[4])
    CHECK (0x00030005,fvfData.dwUVOffset[5])
    CHECK (0x00030006,fvfData.dwUVOffset[6])
    CHECK (0x00030007,fvfData.dwUVOffset[7])
*/

    //  - pContext->hwState.dwStateFlags & CELSIUS_MASK_INNERLOOPUNIQUENESS
    xMOV_r_i32  (rEDX,mMEM32(global.celsius.pContext))
    xMOV_rm_imm (rmREG(rEBX),0x00040000)
    xMOV_r_rm   (rEAX,rmIND32(rEDX)) xOFS32(OFFSETOF(NVD3DCONTEXT, hwState.dwStateFlags))
    xAND_rm_imm (rmREG(rEAX),CELSIUS_MASK_INNERLOOPUNIQUENESS)
    xCMP_rm_imm (rmREG(rEAX),pContext->hwState.dwStateFlags & CELSIUS_MASK_INNERLOOPUNIQUENESS)
    xJNZ32      (ld2)

    if (pContext->hwState.dwStateFlags & CELSIUS_FLAG_USERTEXCOORDSNEEDED(0))
    {
        CHECK2 (0x00050000,pContext,hwState.dwTexUnitToTexStageMapping[0],NVD3DCONTEXT)
    }
    if (pContext->hwState.dwStateFlags & CELSIUS_FLAG_USERTEXCOORDSNEEDED(1))
    {
        CHECK2 (0x00050001,pContext,hwState.dwTexUnitToTexStageMapping[1],NVD3DCONTEXT)
    }
#endif

    //
    // setup push buffer
    //
    xMOV_r_i32  (rEDX,mMEM32(pDriverData))
    xMOV_r_rm   (rEDI,rmIND32(rEDX)) xOFS32(OFFSETOF(CDriverContext,nvPusher.m_dwPut))

    //
    // calc how many verts to copy into EBX
    //
    xMOV_r_i32  (rEBX,mMEM32(global.celsius.dwPrimCount))
    ILCCompile_mul (rEBX,bLegacyStrides ? 4 : 3);

    //
    // setup prefetcher (EBX has # of vertices to copy in total)
    //
    if (bIsIndexed)
    {
        xMOV_r_i32  (rEAX,mMEM32(global.celsius.pIndices))
         xLEA_r_rm   (rECX,rmSIB) xSIB(rEAX,rEBX,x2)
        xMOV_i32_r  (mMEM32(global.celsius.dwPrefetchBase),rEAX)
         xMOV_i32_r  (mMEM32(global.celsius.dwPrefetchMax),rECX)
    }
    else
    {
        xMOV_r_i32  (rEAX,mMEM32(global.celsius.pVertices))
         xMOV_r_rm   (rECX,rmREG(rEBX))
         ILCCompile_mul (rECX,global.celsius.dwVertexStride);
         xADD_r_rm   (rECX,rmREG(rEAX))
        xMOV_i32_r  (mMEM32(global.celsius.dwPrefetchBase),rEAX)
         xMOV_i32_r  (mMEM32(global.celsius.dwPrefetchMax),rECX)
    }

    //
    // start primitive
    //
    xMOV_rm_imm (rmREG(rEAX),((sizeSetNv10CelsiusBeginEnd4MthdCnt << 2) << 16) | ((NV_DD_CELSIUS) << 13) | NV056_SET_BEGIN_END4);
    xMOV_rm_imm (rmREG(rECX),NV056_SET_BEGIN_END_OP_TRIANGLES)
    xMOV_rm_r   (rmIND(rEDI),rEAX)
    xMOV_rm_r   (rmIND8(rEDI),rECX) xOFS8(4)
    xLEA_r_rm   (rEDI,rmIND8(rEDI)) xOFS8(8)

    //
    // load prim count into EBX
    //
    xMOV_r_i32  (rEBX,mMEM32(global.celsius.dwPrimCount))

    //
    // start copying
    //   for this loop EDI points to PUT and EBX has the amount of prims to go
    //
    DWORD labelEarlyExit;
    DWORD labelLoop;
    xLABEL  (labelLoop)
    {
        xPUSH_r     (rEBX)

        //
        // prefetch
        //
        nvCelsiusILCompile_prefetch (bIsIndexed,bLegacyStrides);

        //
        // do two triangles at a time
        //
        for (DWORD dwTriNum = 0; dwTriNum < 2; dwTriNum++)
        {
            if (bIsIndexed)
            {
                //
                // compute vertices
                //
                xMOV_r_i32  (rEDX,mMEM32(global.celsius.pIndices))
                xXOR_r_rm   (rECX,rmREG(rECX))
                xLEA_r_rm   (rEAX,rmIND8(rEDX)) xOFS8 (bLegacyStrides ? 8 : 6)
                xMOV_r_rm   (rEBX,rmIND(rEDX))
           x16r xMOV_r_rm   (rCX,rmIND8(rEDX)) xOFS8(4)
                xMOV_i32_r  (mMEM32(global.celsius.pIndices),rEAX)
                xMOV_r_rm   (rEAX,rmREG(rEBX))
                xSHR_rm_imm8(rmREG(rEBX),16)
                xAND_rm_imm (rmREG(rEAX),0xffff)
                // convert indices to vertex address with limit checking (on NT)
                        ILCCompile_mul (rECX,global.celsius.dwVertexStride);
                    ILCCompile_mul (rEBX,global.celsius.dwVertexStride);
                ILCCompile_mul (rEAX,global.celsius.dwVertexStride);
                        nvCelsiusILCompile_limit (rECX,rEDX);
                    nvCelsiusILCompile_limit (rEBX,rEDX);
                nvCelsiusILCompile_limit (rEAX,rEDX);
                    xADD_r_i32  (rEBX,mMEM32(global.celsius.pVertices))
                xADD_r_i32  (rEAX,mMEM32(global.celsius.pVertices))
                        xADD_r_i32  (rECX,mMEM32(global.celsius.pVertices))
            }

            //
            // do cull check
            //      indexed - eax,ebx and ecx has vertex addresses
            //      ordered - pVertices has vertex0, rest follow in dwVertexStride increments
            DWORD labelCull;
            if (!(dwFlags & CELSIUS_ILFLAG_NOCULL))
            {
                nvCelsiusILCompile_cullcheck (bIsIndexed);
                xLABEL      (labelCull)
                xJZ32       (0)
            }

            //
            // copy vertices
            //
            if (bIsIndexed)
            {
                xPUSH_r     (rECX)
                xPUSH_r     (rEBX)
                xMOV_r_rm   (rESI,rmREG(rEAX))
                nvCelsiusILCompile_copyVertex (pContext,dwFlags);
                xPOP_r      (rESI)
                nvCelsiusILCompile_copyVertex (pContext,dwFlags);
                xPOP_r      (rESI)
                nvCelsiusILCompile_copyVertex (pContext,dwFlags);
            }
            else
            {
                xMOV_r_i32  (rESI,mMEM32(global.celsius.pVertices))
                nvCelsiusILCompile_copyVertex (pContext,dwFlags);
                xADD_rm_imm (rmREG(rESI),global.celsius.dwVertexStride)
                nvCelsiusILCompile_copyVertex (pContext,dwFlags);
                xADD_rm_imm (rmREG(rESI),global.celsius.dwVertexStride)
                nvCelsiusILCompile_copyVertex (pContext,dwFlags);
            }

            if (!(dwFlags & CELSIUS_ILFLAG_NOCULL))
            {
                xTARGET_b32 (labelCull)
            }

            // update instrumentation count (include culled tris so we have a normalized result)
#ifdef INSTRUMENT_INNER_LOOPS
            {
                xMOV_rm_imm (rmREG(rEAX),fvfData.dwVertexStride * 3)
                xADD_i32_r  (mMEM32(global.dwBytesCopied),rEAX)
            }
#endif

            //
            // next triangle
            //
            if (bIsIndexed)
            {
                // nothing to do here
            }
            else
            {
                xMOV_r_i32  (rEAX,mMEM32(global.celsius.pVertices))
                xADD_rm_imm (rmREG(rEAX),global.celsius.dwVertexStride * 3)
                xMOV_i32_r  (mMEM32(global.celsius.pVertices),rEAX)
            }

            //
            // done already? (odd # of triangles)
            //
            if (dwTriNum == 0)
            {
                xPOP_r  (rEBX)
                xDEC_rm (rmREG(rEBX))
                xLABEL  (labelEarlyExit)
                xJZ32   (0)
                xPUSH_r (rEBX)
            }
        }

/*
        //
        // copy vertex
        //
        if (bIsIndexed)
        {
            // get index
            xMOV_r_i32  (rEDX,mMEM32(global.celsius.pIndices))
            xXOR_r_rm   (rESI,rmREG(rESI))
       x16r xMOV_r_rm   (rSI,rmIND(rEDX))
            xLEA_r_rm   (rEDX,rmIND8(rEDX)) xOFS8(2)
            if (bLegacyStrides)
            {

// do in setup ....
          if (bLegacyStrides)
        {
            xMOV_r_i32  (rEAX,mMEM32(global.celsius.pIndices))
            xMOV_i32_r  (mMEM32(global.celsius.pIndexBase),rEAX)
        }


                xMOV_r_rm   (rEAX,rmREG(rEDX))
                xSUB_r_i32  (rEAX,mMEM32(global.celsius.pIndexBase))
                xAND_rm_imm (rmREG(rEAX),6)
                xXOR_r_rm   (rECX,rmREG(rECX))
                xCMP_rm_imm (rmREG(rEAX),6)
                xSETNZ_rm8  (rmREG(rCL))
                xDEC_rm     (rmREG(rECX))
                xAND_rm_imm (rmREG(rECX),2)
                xADD_r_rm   (rEDX,rmREG(rECX))
            }
            xMOV_i32_r  (mMEM32(global.celsius.pIndices),rEDX)
            // compute vertex offset
            ILCCompile_mul (rESI,fvfData.dwVertexStride);
            // range limit
            xXOR_r_rm   (rECX,rmREG(rECX))
            xCMP_r_i32  (rESI,mMEM32(global.dwMaxVertexOffset))
            xSETAE_rm8  (rmREG(rCL))
            xDEC_rm     (rmREG(rECX))
            xAND_r_rm   (rESI,rmREG(rECX))
            // compute vertex address
            xADD_r_i32  (rESI,mMEM32(global.celsius.pVertices))
        }
        else
        {
            // get vertex & increment
            xMOV_r_i32  (rESI,mMEM32(global.celsius.pVertices))
            xLEA_r_rm   (rEAX,rmIND32(rESI)) xOFS32(fvfData.dwVertexStride)
            xMOV_i32_r  (mMEM32(global.celsius.pVertices),rEAX)
        }

        // copy vertex (from ESI to EDI)
        nvCelsiusILCompile_copyVertex (pContext);
*/

        // check for pusher space
        DWORD labelSpace;
        xMOV_r_i32  (rESI,mMEM32(pDriverData))
        xCMP_r_rm   (rEDI,rmIND32(rESI)) xOFS32(OFFSETOF(CDriverContext,nvPusher.m_dwThreshold))
        xLABEL      (labelSpace)
        xJL         (0)
        {
            xMOV_rm_r   (rmIND32(rESI),rEDI) xOFS32(OFFSETOF(CDriverContext,nvPusher.m_dwPut))
            xMOV_rm_imm (rmREG(rEAX),(DWORD)nvCelsiusDispatchGetPusherSpace)
            xCALL_rm    (rmREG(rEAX))
            xMOV_r_rm   (rEDI,rmIND32(rESI)) xOFS32(OFFSETOF(CDriverContext,nvPusher.m_dwPut))
        }
        xTARGET_b8  (labelSpace)

        // next
        xPOP_r  (rEBX)
        xDEC_rm (rmREG(rEBX))
    }
    xJNZ32      (labelLoop)
    xTARGET_b32 (labelEarlyExit)

    //
    // end primitive
    //
    xMOV_rm_imm (rmREG(rEAX),((sizeSetNv10CelsiusBeginEnd4MthdCnt << 2) << 16) | ((NV_DD_CELSIUS) << 13) | NV056_SET_BEGIN_END4);
    xMOV_rm_imm (rmREG(rECX),NV056_SET_BEGIN_END4_OP_END)
    xMOV_rm_r   (rmIND(rEDI),rEAX)
    xMOV_rm_r   (rmIND8(rEDI),rECX) xOFS8(4)
    xLEA_r_rm   (rEDI,rmIND8(rEDI)) xOFS8(8)

    //
    // save off push buffer
    //
    xMOV_r_i32  (rEDX,mMEM32(pDriverData))
#ifndef NV_NULL_HW_DRIVER
    xMOV_rm_r   (rmIND32(rEDX),rEDI) xOFS32(OFFSETOF(CDriverContext,nvPusher.m_dwPut))
#endif

    //
    // done
    //
    xPOP_r      (rEDI)
    xPOP_r      (rESI)
    xPOP_r      (rEBX)
    xPOP_r      (rEBP)
    xRET
    return lEntry;
}

#endif  // NVARCH == 0x10
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\ddraw\celsius\src\nvCelsiusState.cpp ===
// **************************************************************************
//
//       Copyright 1993-1999 NVIDIA, Corporation.  All rights reserved.
//
//     NOTICE TO USER:   The source code  is copyrighted under  U.S. and
//     international laws.  Users and possessors of this source code are
//     hereby granted a nonexclusive,  royalty-free copyright license to
//     use this code in individual and commercial software.
//
//     Any use of this source code must include,  in the user documenta-
//     tion and  internal comments to the code,  notices to the end user
//     as follows:
//
//       Copyright 1993-1999 NVIDIA, Corporation.  All rights reserved.
//
//     NVIDIA, CORPORATION MAKES NO REPRESENTATION ABOUT THE SUITABILITY
//     OF  THIS SOURCE  CODE  FOR ANY PURPOSE.  IT IS  PROVIDED  "AS IS"
//     WITHOUT EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORPOR-
//     ATION DISCLAIMS ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,
//     INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY, NONINFRINGE-
//     MENT,  AND FITNESS  FOR A PARTICULAR PURPOSE.   IN NO EVENT SHALL
//     NVIDIA, CORPORATION  BE LIABLE FOR ANY SPECIAL,  INDIRECT,  INCI-
//     DENTAL, OR CONSEQUENTIAL DAMAGES,  OR ANY DAMAGES  WHATSOEVER RE-
//     SULTING FROM LOSS OF USE,  DATA OR PROFITS,  WHETHER IN AN ACTION
//     OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,  ARISING OUT OF
//     OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOURCE CODE.
//
//     U.S. Government  End  Users.   This source code  is a "commercial
//     item,"  as that  term is  defined at  48 C.F.R. 2.101 (OCT 1995),
//     consisting  of "commercial  computer  software"  and  "commercial
//     computer  software  documentation,"  as such  terms  are  used in
//     48 C.F.R. 12.212 (SEPT 1995)  and is provided to the U.S. Govern-
//     ment only as  a commercial end item.   Consistent with  48 C.F.R.
//     12.212 and  48 C.F.R. 227.7202-1 through  227.7202-4 (JUNE 1995),
//     all U.S. Government End Users  acquire the source code  with only
//     those rights set forth herein.
//
// ********************************* Direct 3D ******************************
//
//  Module: nvCelsiusState.cpp
//      Celsius state management routines.
//
// **************************************************************************
//
//  History:
//      Craig Duttweiler        12Feb99         NV10 development
//
// **************************************************************************
#include "nvprecomp.h"

#if (NVARCH >= 0x10)

#include "nvCelsiusCaps.h"

// all values in this matrix are constant except 3,1 and 4,1 which get correctly set later
// column 1 = vector by which [x,y,z,w] is scaled
// column 2 = vector by which [x,y,z] are biased
static D3DMATRIX mPassthruModelViewMatrix =
{
     1.f,   CELSIUS_BORDER,   0.f,   0.f,
     1.f,   CELSIUS_BORDER,   0.f,   0.f,
     0.f,   0.f,           0.f,   0.f,
     0.f,   0.f,           0.f,   0.f
};

// all elements of this matrix remain zero except the last row and the diagonal
// which get set appropriately in nvSetCelsiusTransform
static D3DMATRIX mViewportMatrix = matrixZero;

//---------------------------------------------------------------------------

// set things that are never changed in D3D. this routine is run once to initialize
// and then only whenever someone else (DDRAW) stomps on our celsius object

HRESULT nvSetCelsiusD3DDefaults (PNVD3DCONTEXT pContext)
{
    DWORD dwWindow;

    pContext->hwState.dwDirtyFlags &= ~CELSIUS_DIRTY_DEFAULTS;

    // context dmas
    pContext->hwState.celsius.set (NV056_SET_CONTEXT_DMA_NOTIFIES,NV_DD_DMA_PUSHER_SYNC_NOTIFIER_CONTEXT_DMA_TO_MEMORY); // notifier context
    pContext->hwState.celsius.set (NV056_SET_CONTEXT_DMA_A,       D3D_CONTEXT_DMA_HOST_MEMORY);                          // dma a - system/agp memory
    pContext->hwState.celsius.set (NV056_SET_CONTEXT_DMA_B,       NV_DD_DMA_CONTEXT_DMA_IN_VIDEO_MEMORY);                // dma b - video memory
    pContext->hwState.celsius.set (NV056_SET_CONTEXT_DMA_VERTEX,  NV01_NULL_OBJECT);                                     // vertex buffer context (gets set later)
    pContext->hwState.celsius.set (NV056_SET_CONTEXT_DMA_STATE,   NV_DD_DMA_CONTEXT_DMA_TO_VIDEO_MEMORY);                // state context
    pContext->hwState.celsius.set (NV056_SET_CONTEXT_DMA_COLOR,   NV_DD_DMA_CONTEXT_DMA_IN_VIDEO_MEMORY);                // frame buffer context
    pContext->hwState.celsius.set (NV056_SET_CONTEXT_DMA_ZETA,    NV_DD_DMA_CONTEXT_DMA_IN_VIDEO_MEMORY);                // zeta buffer context

    // use the first vertex to determine the color used for flat-shading
    pContext->hwState.celsius.set (NV056_SET_FLAT_SHADE_OP,   NV056_SET_FLAT_SHADE_OP_V_FIRST_VTX);
    pContext->hwState.celsius.prep_wait_for_idle_nv10();
    pContext->hwState.celsius.set (NV056_SET_WINDOW_CLIP_TYPE,NV056_SET_WINDOW_CLIP_TYPE_V_INCLUSIVE);

    // deactivate all but the first clip rectangle
    pContext->hwState.celsius.prep_wait_for_idle_nv10();
    for (dwWindow=1; dwWindow<CELSIUS_MAX_WINDOWS; dwWindow++) {
        pContext->hwState.celsius.set (NV056_SET_WINDOW_CLIP_HORIZONTAL(dwWindow),0);
        pContext->hwState.celsius.set (NV056_SET_WINDOW_CLIP_VERTICAL(dwWindow),0);
    }

    pContext->hwState.celsius.set (NV056_SET_POINT_PARAMS_ENABLE, NV056_SET_POINT_PARAMS_ENABLE_V_FALSE);

    pContext->hwState.celsius.set (NV056_SET_BLEND_EQUATION,      NV056_SET_BLEND_EQUATION_V_FUNC_ADD);
    pContext->hwState.celsius.set (NV056_SET_BLEND_COLOR,         0);

    pContext->hwState.celsius.set (NV056_SET_EDGE_FLAG,  1);

    pContext->hwState.celsius.set4f (NV056_SET_TEXCOORD0_4F(0), 0.0f, 0.0f, 0.0f, 1.0f);
    pContext->hwState.celsius.set4f (NV056_SET_TEXCOORD1_4F(0), 0.0f, 0.0f, 0.0f, 1.0f);

    pContext->hwState.celsius.set3f (NV056_SET_NORMAL3F(0), 0.0f, 0.0f, 1.0f);

    pContext->hwState.celsius.setf (NV056_SET_FOG1F, 0.0f);

    // we never have fog arrays
    pContext->hwState.celsius.set (NV056_SET_FOG_ARRAY_OFFSET, 0);
    pContext->hwState.celsius.set (NV056_SET_FOG_ARRAY_FORMAT,DRF_DEF(056, _SET_FOG_ARRAY_FORMAT, _SIZE, _0) |
                                                           DRF_DEF(056, _SET_FOG_ARRAY_FORMAT, _TYPE, _FLOAT));

    pContext->hwState.celsius.set (NV056_SET_TEXTURE_CONTROL1(0), DRF_NUM(056, _SET_TEXTURE_CONTROL1, _IMAGE_PITCH, 0x0008));
    pContext->hwState.celsius.set (NV056_SET_TEXTURE_CONTROL1(1), DRF_NUM(056, _SET_TEXTURE_CONTROL1, _IMAGE_PITCH, 0x0008));
    pContext->hwState.celsius.set (NV056_SET_TEXTURE_CONTROL2(0),(DRF_NUM(056, _SET_TEXTURE_CONTROL2, _IMAGE_LODF, 0) |
                                                               DRF_NUM(056, _SET_TEXTURE_CONTROL2, _PERTURB_DU, 0) |
                                                               DRF_NUM(056, _SET_TEXTURE_CONTROL2, _PERTURB_DV, 0)));
    pContext->hwState.celsius.set (NV056_SET_TEXTURE_CONTROL2(1),(DRF_NUM(056, _SET_TEXTURE_CONTROL2, _IMAGE_LODF, 0) |
                                                               DRF_NUM(056, _SET_TEXTURE_CONTROL2, _PERTURB_DU, 0) |
                                                               DRF_NUM(056, _SET_TEXTURE_CONTROL2, _PERTURB_DV, 0)));

    // D3D has no texgen (yet)
    pContext->hwState.celsius.set (NV056_SET_TEXGEN_S(0), NV056_SET_TEXGEN_S_V_DISABLE);
    pContext->hwState.celsius.set (NV056_SET_TEXGEN_T(0), NV056_SET_TEXGEN_T_V_DISABLE);
    pContext->hwState.celsius.set (NV056_SET_TEXGEN_R(0), NV056_SET_TEXGEN_Q_V_DISABLE);
    pContext->hwState.celsius.set (NV056_SET_TEXGEN_Q(0), NV056_SET_TEXGEN_R_V_DISABLE);
    pContext->hwState.celsius.set (NV056_SET_TEXGEN_S(1), NV056_SET_TEXGEN_S_V_DISABLE);
    pContext->hwState.celsius.set (NV056_SET_TEXGEN_T(1), NV056_SET_TEXGEN_T_V_DISABLE);
    pContext->hwState.celsius.set (NV056_SET_TEXGEN_R(1), NV056_SET_TEXGEN_Q_V_DISABLE);
    pContext->hwState.celsius.set (NV056_SET_TEXGEN_Q(1), NV056_SET_TEXGEN_R_V_DISABLE);

    // D3D has no smoothing (note smoothing != anti-aliasing!)
    pContext->hwState.celsius.set (NV056_SET_POINT_SMOOTH_ENABLE, NV056_SET_POINT_SMOOTH_ENABLE_V_FALSE);
    pContext->hwState.celsius.set (NV056_SET_LINE_SMOOTH_ENABLE,  NV056_SET_LINE_SMOOTH_ENABLE_V_FALSE);
    pContext->hwState.celsius.set (NV056_SET_POLY_SMOOTH_ENABLE,  NV056_SET_POLY_SMOOTH_ENABLE_V_FALSE);

    // swath width for the boustrophedonic rasterization
    // todo - use montrym's algorithm
    pContext->hwState.celsius.set (NV056_SET_SWATH_WIDTH, NV056_SET_SWATH_WIDTH_V_64);

    pContext->hwState.celsius.set4f (NV056_SET_EYE_POSITION(0), 0.0f, 0.0f, 0.0f, 1.0f);

    // we'll always cull what we call backfacing geometry.
    // this goes along with D3D's definition of culling.
    pContext->hwState.celsius.set (NV056_SET_CULL_FACE, NV056_SET_CULL_FACE_V_BACK);

    return (D3D_OK);
}

//---------------------------------------------------------------------------

// set surface info: offset, pitch, clip

HRESULT nvSetCelsiusSurfaceInfo (PNVD3DCONTEXT pContext)
{
    DWORD dwClipH, dwClipV;  // horizontal and vertical clip locations

    pContext->hwState.dwDirtyFlags &= ~CELSIUS_DIRTY_SURFACE;

    //
    // get render targets
    //
    CSimpleSurface *pRenderTarget;
    CSimpleSurface *pZetaBuffer;


    if (pContext->aa.isEnabled() && pContext->aa.isRenderTargetValid()) {
        pContext->aa.makeRenderTargetValid(pContext);
        pRenderTarget = pContext->pRenderTarget;
    } else if (!pContext->aa.isEnabled()) {
        pRenderTarget = pContext->pRenderTarget;
    } else {
        pRenderTarget = pContext->aa.pSuperRenderTarget;
    }

    if (pContext->aa.isEnabled() && pContext->aa.isZetaBufferValid()) {
        pContext->aa.makeZetaBufferValid(pContext);
        pZetaBuffer   = pContext->pZetaBuffer;
    } else if (!pContext->aa.isEnabled()) {
        pZetaBuffer   = pContext->pZetaBuffer;
    } else {
        pZetaBuffer   = pContext->aa.pSuperZetaBuffer;
    }


    if ((pDriverData->nvD3DPerfData.dwPerformanceStrategy & PS_CT_11M) && pZetaBuffer && (pZetaBuffer->getBPP() == 4) && 
        ((pContext->dwEarlyCopyStrategy == 2) || (pContext->dwEarlyCopyStrategy > 3)) &&
        !(pContext->aa.isEnabled() && (pContext->dwEarlyCopyStrategy > 9)))
    {
        pZetaBuffer->recreate(2);
    }


    //
    // program HW
    //
    nvAssert (pRenderTarget);
    DWORD dwFormat  = DRF_DEF(056, _SET_SURFACE_FORMAT, _TYPE, _PITCH);
    if (pRenderTarget->isSwizzled())
    {
        CTexture* pTexture = pRenderTarget->getWrapper()->getTexture();
        nvAssert(pTexture);
        dwFormat  = DRF_DEF(056, _SET_SURFACE_FORMAT, _TYPE, _SWIZZLE);
        dwFormat |= DRF_NUM(056, _SET_SURFACE_FORMAT, _WIDTH, pTexture->getLogWidth());
        dwFormat |= DRF_NUM(056, _SET_SURFACE_FORMAT, _HEIGHT, pTexture->getLogHeight());
    }
    nvAssert(nv056SurfaceFormat[pRenderTarget->getFormat()] != ~0);
    dwFormat |= nv056SurfaceFormat[pRenderTarget->getFormat()];
    if (pZetaBuffer && (pZetaBuffer->getBPP() == 2) && (pRenderTarget->getBPP() == 4))
    {
        // NV11 mixed mode support
        nvAssert(pDriverData->nvD3DPerfData.dwNVClasses & NVCLASS_1196_CELSIUS);
        dwFormat |= NV1196_SET_SURFACE_FORMAT_COLOR_LE_X1R5G5B5_Z1R5G5B5 ^
                    NV1196_SET_SURFACE_FORMAT_COLOR_LE_Z16_X1R5G5B5_Z1R5G5B5;
    }

    DWORD dwZPitch  = pZetaBuffer ? pZetaBuffer->getPitch()  : CELSIUS_ALIGNMENT_MIN;
#ifdef  STEREO_SUPPORT
    DWORD dwZOffset = pZetaBuffer ? GetStereoOffset(pZetaBuffer) : 0;
#else   //STEREO_SUPPORT==0
    DWORD dwZOffset = pZetaBuffer ? pZetaBuffer->getOffset() : 0;
#endif  //STEREO_SUPPORT
    pContext->hwState.celsius.prep_wait_for_idle_nv10();
    pContext->hwState.celsius.set (NV056_SET_SURFACE_FORMAT,       dwFormat);
    pContext->hwState.celsius.set (NV056_SET_SURFACE_PITCH,        (DRF_NUM(056, _SET_SURFACE_PITCH, _COLOR, pRenderTarget->getPitch()) |
                                                                 DRF_NUM(056, _SET_SURFACE_PITCH, _ZETA,  dwZPitch)));
#ifdef  STEREO_SUPPORT
    pContext->hwState.celsius.set (NV056_SET_SURFACE_COLOR_OFFSET, GetStereoOffset(pRenderTarget));
#else   //STEREO_SUPPORT==0
    pContext->hwState.celsius.set (NV056_SET_SURFACE_COLOR_OFFSET, pRenderTarget->getOffset());
#endif  //STEREO_SUPPORT
    pContext->hwState.celsius.set (NV056_SET_SURFACE_ZETA_OFFSET,  dwZOffset);

    // since we're using the window clip to clip to the viewport,
    // the surface clip can just clip to the whole window.
    dwClipH = DRF_NUM(056, _SET_SURFACE_CLIP_HORIZONTAL, _X, 0) |
              DRF_NUM(056, _SET_SURFACE_CLIP_HORIZONTAL, _WIDTH, ((DWORD)pRenderTarget->getWidth()));
    dwClipV = DRF_NUM(056, _SET_SURFACE_CLIP_VERTICAL, _Y, 0) |
              DRF_NUM(056, _SET_SURFACE_CLIP_VERTICAL, _HEIGHT, ((DWORD)pRenderTarget->getHeight()));
    pContext->hwState.celsius.prep_wait_for_idle_nv10();
    pContext->hwState.celsius.set (NV056_SET_SURFACE_CLIP_HORIZONTAL, dwClipH);
    pContext->hwState.celsius.set (NV056_SET_SURFACE_CLIP_VERTICAL,   dwClipV);

    if (pZetaBuffer) {
        if (pZetaBuffer->getBPP() == 2) {
            pContext->hwState.dvZScale    = CELSIUS_Z_SCALE16;
            pContext->hwState.dvInvZScale = CELSIUS_Z_SCALE16_INV;
        }
        else {
            pContext->hwState.dvZScale    = CELSIUS_Z_SCALE24;
            pContext->hwState.dvInvZScale = CELSIUS_Z_SCALE24_INV;
        }
    }

    return (D3D_OK);
}


//---------------------------------------------------------------------------

// set up the combiners to produce one of the legacy D3D texture blends

HRESULT nvCelsiusSetTextureBlend (PNVD3DCONTEXT pContext)
{
    DWORD dwTBlend;

    if (pContext->tssState[0].dwValue[D3DTSS_TEXTUREMAP]) {

        // we have a texture. go ahead and do the blend

        dwTBlend = pContext->dwRenderState[D3DRENDERSTATE_TEXTUREMAPBLEND];

        nvAssert (dwTBlend <= D3D_TBLEND_MAX);  // make sure we're not off the end of the table

        pContext->hwState.dwAlphaICW[0] = celsiusTextureBlendSettings[dwTBlend][0];
        pContext->hwState.dwColorICW[0] = celsiusTextureBlendSettings[dwTBlend][1];
        pContext->hwState.dwAlphaOCW[0] = celsiusTextureBlendSettings[dwTBlend][2];
        pContext->hwState.dwColorOCW[0] = celsiusTextureBlendSettings[dwTBlend][3];

        // handle the stupid special case in which we have TBLEND_MODULATE and a
        // texture without alpha; use D3DTBLEND_MODULATEALPHA instead
        if (dwTBlend == D3DTBLEND_MODULATE) {
            CTexture *pTexture = ((CNvObject *)(pContext->tssState[0].dwValue[D3DTSS_TEXTUREMAP]))->getTexture();
            if (!pTexture->hasAlpha()) {
                pContext->hwState.dwAlphaICW[0] = celsiusTextureBlendSettings[D3DTBLEND_MODULATEALPHA][0];
            }
        }

        pContext->hwState.dwTexUnitToTexStageMapping[0] = 0;

    }

    else {

        // they've enabled a texture blend without a texture. just use diffuse
        pContext->hwState.dwAlphaICW[0] = celsiusTextureBlendDefault[0];
        pContext->hwState.dwColorICW[0] = celsiusTextureBlendDefault[1];
        pContext->hwState.dwAlphaOCW[0] = celsiusTextureBlendDefault[2];
        pContext->hwState.dwColorOCW[0] = celsiusTextureBlendDefault[3];

    }

    pContext->hwState.dwAlphaICW[1] = 0;
    pContext->hwState.dwColorICW[1] = 0;
    pContext->hwState.dwAlphaOCW[1] = 0;
    pContext->hwState.dwColorOCW[1] = DRF_DEF(056, _SET_COMBINER1_COLOR_OCW, _ITERATION_COUNT, _ONE) |
                                          DRF_DEF(056, _SET_COMBINER1_COLOR_OCW, _MUX_SELECT, _LSB);

    return (D3D_OK);
}

//---------------------------------------------------------------------------

// define to enable profiling of combiner programs
// #define COMBINER_STATS

// set up the celsius combiners for either the current texture stage state
// or a legacy texture blend

HRESULT nvSetCelsiusColorCombiners (PNVD3DCONTEXT pContext)
{
    BOOL  bStageActive;
    DWORD dwMapping0, dwMapping1, dwStateFlags;
    DWORD dwTSSMask0, dwTSSMask1;

    #ifdef DEBUG
    static DWORD dwActiveStageCounts[2] = {0,0};
    static DWORD dwTotalPrograms = 0;
    static DWORD dwLastMask0, dwLastMask1;
    // masks requiring 2 stages that we already know about and don't want reported again
    // (also modes that could be compacted into one stage but are idiotic and don't deserve it)
    static DWORD dwKnownMasks[19][2] = {
        // uncompactable
        0x90020820, 0xb0220820,
        0x90400400, 0x90410400,
        0x90400400, 0x90411040,
        0x90400400, 0x94410400,
        0x90400400, 0xb4410400,
        0x90400840, 0x90410400,
        0x90400840, 0xb4410c01,
        0x90401040, 0x90411040,
        0x90401040, 0x94411c41,
        0x90401043, 0xc0411c41,
        0x90400c00, 0x10410840,
        0x90410400, 0x90411040,
        0x90410840, 0x90410400,
        0x90620840, 0x90220820,
        0xb8403840, 0x9c200c00,
        0xb8403840, 0x9c201c20,
        0xe0440840, 0x90410400,
        // idiotic
        0x10401040, 0x10411041,
        0x10401040, 0x34410400
    };
    #endif  // DEBUG

    pContext->hwState.dwDirtyFlags &= ~CELSIUS_DIRTY_COMBINERS;

    // cache current values
    dwStateFlags = pContext->hwState.dwStateFlags & CELSIUS_MASK_COMBINERPROGRAMUNIQUENESS;
    dwMapping0   = pContext->hwState.dwTexUnitToTexStageMapping[0];
    dwMapping1   = pContext->hwState.dwTexUnitToTexStageMapping[1];

    // clear state that will be re-determined here
    pContext->hwState.dwNextAvailableTextureUnit = 0;
    pContext->hwState.dwTexUnitToTexStageMapping[0] = CELSIUS_UNUSED;
    pContext->hwState.dwTexUnitToTexStageMapping[1] = CELSIUS_UNUSED;
    pContext->hwState.dwStateFlags &= ~(CELSIUS_FLAG_DOTPRODUCT3(0)        |
                                        CELSIUS_FLAG_DOTPRODUCT3(1)        |
                                        CELSIUS_FLAG_ADDCOMPLEMENTRGB(0)   |
                                        CELSIUS_FLAG_ADDCOMPLEMENTRGB(1)   |
                                        CELSIUS_FLAG_ADDCOMPLEMENTALPHA(0) |
                                        CELSIUS_FLAG_ADDCOMPLEMENTALPHA(1));

    if (pContext->bUseTBlendSettings) {

        nvCelsiusSetTextureBlend (pContext);
        pContext->hwState.dwNumActiveCombinerStages = 1;

    }

    else {

#ifdef CELSIUS_NVCOMBINER
        // count the number of texture stages
        DWORD dwStageCount = 0;
        DWORD dwTexCount = 0;
        while ((dwStageCount < 8) &&
               (pContext->tssState[dwStageCount].dwValue[D3DTSS_COLOROP] != D3DTOP_DISABLE))
        {
            if(pContext->tssState[dwStageCount].dwValue[D3DTSS_TEXTUREMAP]) dwTexCount++;
            dwStageCount++;
        }
        if (dwStageCount > 2) {
            switch (dwStageCount) {
                case 3:
                    // a very Special case required from developer
                    // disable for now, since not functional
                    /* if (nvCelsiusCheck3StageSpecial (pContext)) {
                        nvCelsiusSet3StageSpecial(pContext);
                    } else
                    */
                    // check for special 3-stage, 2-texture setting
                    if (nvCelsiusCheck3Stage2Textures (pContext)) {
                        nvCelsiusSetTextures3StageCombiners (pContext);
                    } else {
                        pContext->hwState.dwStateFlags |= CELSIUS_FLAG_SETUPFAILURE;
                        return (D3D_OK);
                    }
                    break;
                case 4:
                    // check for special 4-stage bumpmapping
                    if (nvCheckBumpMapStates (pContext, dwStageCount)) {
                        nvSetCelsius4StageBumpMapCombiners (pContext);
                    } else {
                        pContext->hwState.dwStateFlags |= CELSIUS_FLAG_SETUPFAILURE;
                        return (D3D_OK);
                    }
                    break;
                case 8:
                    // check for special 8-stage bumpmapping
                    if (((getDC()->nvD3DRegistryData.regD3DEnableBits1 & D3D_REG_DIRECTMAPENABLE_MASK) == D3D_REG_DIRECTMAPENABLE_ENABLE) &&
                        (nvCheckBumpMapStates (pContext,dwStageCount))) {
                        nvSetCelsius8StageBumpMapCombiners (pContext);
                    } else {
                        pContext->hwState.dwStateFlags |= CELSIUS_FLAG_SETUPFAILURE;
                        return (D3D_OK);
                    }
                    break;
                default:
                    DPF ("unhandled number of combiner stages");
                    pContext->hwState.dwStateFlags |=CELSIUS_FLAG_SETUPFAILURE;
                    return (D3D_OK);
            }
        }

        // see if we can pack two texture stages into one combiner
        else if ((dwStageCount==2) &&
                 (nvCelsiusCheck2Stage1Combiner(pContext)) &&
                 (nvCelsiusSet2Stage1Combiner(pContext) == D3D_OK)) {
            // everything's ok. nothing more to do
        }
        else
#endif
        {
            dwTSSMask0 = nvCelsiusBuildTSSMask (pContext, 0);
            dwTSSMask1 = nvCelsiusBuildTSSMask (pContext, 1);

            if (!nvCelsiusCombinersSetFromHashTable (pContext, dwTSSMask0, dwTSSMask1)) {

                // program the old-fashioned way
                pContext->hwState.dwNumActiveCombinerStages = 1;  // we always have at least one stage

                bStageActive = ConstructColorCombiners (pContext, 0, 0);
                ConstructAlphaCombiners (pContext, 0, 0, bStageActive);

                // if the current unit got assigned to this stage, move on to the next
                if (pContext->hwState.dwTexUnitToTexStageMapping[pContext->hwState.dwNextAvailableTextureUnit] != CELSIUS_UNUSED) {
                    pContext->hwState.dwNextAvailableTextureUnit++;
                }

                if (bStageActive) {

                    // if the first stage was active, go ahead and process the second
                    bStageActive = ConstructColorCombiners (pContext, 1, 1);
                    ConstructAlphaCombiners (pContext, 1, 1, bStageActive);

                    if (bStageActive) {
                        pContext->hwState.dwNumActiveCombinerStages = 2;
                    }

                }  // bStageActive

                else {

                    pContext->hwState.dwColorICW[1] = 0;
                    pContext->hwState.dwColorOCW[1] = 0;
                    pContext->hwState.dwAlphaICW[1] = 0;
                    pContext->hwState.dwAlphaOCW[1] = 0;

                }

                pContext->hwState.dwColorOCW[1] |= DRF_NUM(056, _SET_COMBINER1_COLOR, _OCW_ITERATION_COUNT,
                                                               pContext->hwState.dwNumActiveCombinerStages);

                // add this program to the hash table for future reference
                //only add it if it didn't fail.
                if (!(pContext->hwState.dwStateFlags & CELSIUS_FLAG_SETUPFAILURE))
                {
                    nvCelsiusCombinersAddToHashTable (pContext, dwTSSMask0, dwTSSMask1);
                }
            }  // !nvCelsiusCombinersSetFromHashTable

            #ifdef DEBUG
            dwActiveStageCounts[pContext->hwState.dwNumActiveCombinerStages-1] ++;
            if (pContext->hwState.dwNumActiveCombinerStages == 2) {
                // try to cut down on complaints a bit
                if ((dwTSSMask0 != dwLastMask0) ||
                    (dwTSSMask1 != dwLastMask1)) {
                    dwLastMask0 = dwTSSMask0;
                    dwLastMask1 = dwTSSMask1;
                    BOOL bKnown = FALSE;
                    for (DWORD i=0; i<(sizeof(dwKnownMasks)>>3); i++) {
                        if ((dwKnownMasks[i][0] == dwTSSMask0) &&
                            (dwKnownMasks[i][1] == dwTSSMask1)) {
                            bKnown = TRUE;
                            break;
                        }
                    }
                    if (!bKnown) {
                        DPF_LEVEL(NVDBG_LEVEL_INFO,"using two combiner stages in unknown mode.");
                        DPF_LEVEL(NVDBG_LEVEL_INFO,"please give the following information to craig.");
                        DPF_LEVEL(NVDBG_LEVEL_INFO,"   TSS mask 0 = 0x%08x", dwTSSMask0);
                        DPF_LEVEL(NVDBG_LEVEL_INFO,"   TSS mask 1 = 0x%08x", dwTSSMask1);
                        DPF_LEVEL(NVDBG_LEVEL_INFO,"   color icw[0] = 0x%08x", pContext->hwState.dwColorICW[0]);
                        DPF_LEVEL(NVDBG_LEVEL_INFO,"   color ocw[0] = 0x%08x", pContext->hwState.dwColorOCW[0]);
                        DPF_LEVEL(NVDBG_LEVEL_INFO,"   alpha icw[0] = 0x%08x", pContext->hwState.dwAlphaICW[0]);
                        DPF_LEVEL(NVDBG_LEVEL_INFO,"   alpha ocw[0] = 0x%08x", pContext->hwState.dwAlphaOCW[0]);
                        DPF_LEVEL(NVDBG_LEVEL_INFO,"   color icw[1] = 0x%08x", pContext->hwState.dwColorICW[1]);
                        DPF_LEVEL(NVDBG_LEVEL_INFO,"   color ocw[1] = 0x%08x", pContext->hwState.dwColorOCW[1]);
                        DPF_LEVEL(NVDBG_LEVEL_INFO,"   alpha icw[1] = 0x%08x", pContext->hwState.dwAlphaICW[1]);
                        DPF_LEVEL(NVDBG_LEVEL_INFO,"   alpha ocw[1] = 0x%08x", pContext->hwState.dwAlphaOCW[1]);
//                        __asm int 3;  comment out so others can use debug builds without hitting int 3
                    }
                }
            }
            #ifdef COMBINER_STATS
            dwTotalPrograms ++;
            if (dwTotalPrograms % 1000 == 0) {
                DPF ("----------------- combiner stats -------------------");
                DPF ("instances of 1 active stages: %d", dwActiveStageCounts[0]);
                DPF ("             2 active stages: %d", dwActiveStageCounts[1]);
                DPF ("total combiner programs: %d", dwTotalPrograms);
            }
            #endif  // COMBINER_STATS
            #endif  // DEBUG
        }
    }

#if 0
    // force combiner settings
    pContext->hwState.dwColorICW[0] = 0x20200000;
    pContext->hwState.dwColorOCW[0] = 0x00000c00;
    pContext->hwState.dwAlphaICW[0] = 0x30300000;
    pContext->hwState.dwAlphaOCW[0] = 0x00000c00;

    pContext->hwState.dwColorICW[1] = 0x00000000;
    pContext->hwState.dwColorOCW[1] = 0x10000000;
    pContext->hwState.dwAlphaICW[1] = 0x00000000;
    pContext->hwState.dwAlphaOCW[1] = 0x00000000;
#endif

    pContext->hwState.celsius.set (NV056_SET_COMBINER_COLOR_ICW(0), pContext->hwState.dwColorICW[0]);
    pContext->hwState.celsius.set (NV056_SET_COMBINER0_COLOR_OCW,   pContext->hwState.dwColorOCW[0]);
    pContext->hwState.celsius.set (NV056_SET_COMBINER_ALPHA_ICW(0), pContext->hwState.dwAlphaICW[0]);
    pContext->hwState.celsius.set (NV056_SET_COMBINER_ALPHA_OCW(0), pContext->hwState.dwAlphaOCW[0]);

    pContext->hwState.celsius.set (NV056_SET_COMBINER_COLOR_ICW(1), pContext->hwState.dwColorICW[1]);
    pContext->hwState.celsius.set (NV056_SET_COMBINER1_COLOR_OCW,   pContext->hwState.dwColorOCW[1]);
    pContext->hwState.celsius.set (NV056_SET_COMBINER_ALPHA_ICW(1), pContext->hwState.dwAlphaICW[1]);
    pContext->hwState.celsius.set (NV056_SET_COMBINER_ALPHA_OCW(1), pContext->hwState.dwAlphaOCW[1]);

    // if we've changed the flags or mappings, invalidate a bunch of state
    if ((pContext->hwState.dwStateFlags & CELSIUS_MASK_COMBINERPROGRAMUNIQUENESS) != dwStateFlags) {
        pContext->hwState.dwDirtyFlags |= CELSIUS_DIRTY_SPECFOG_COMBINER |
                                          CELSIUS_DIRTY_LIGHTS;
    }

    if ((pContext->hwState.dwTexUnitToTexStageMapping[0] != dwMapping0) ||
        (pContext->hwState.dwTexUnitToTexStageMapping[1] != dwMapping1)) {
        pContext->hwState.dwDirtyFlags |= CELSIUS_DIRTY_TEXTURE_STATE
                                       |  CELSIUS_DIRTY_TEXTURE_TRANSFORM
                                       |  CELSIUS_DIRTY_TL_MODE
                                       |  CELSIUS_DIRTY_FVF
                                       |  CELSIUS_DIRTY_TRANSFORM;
    }

#ifdef ALPHA_CULL
    if(pContext->dwEarlyCopyStrategy && pContext->hwState.alphacull_mode >= 2)
        pContext->hwState.dwDirtyFlags |= CELSIUS_DIRTY_MISC_STATE;
#endif

    return D3D_OK;
}


//---------------------------------------------------------------------------

// set up all the fundamental stuff that can be derived from the texture
// itself (without looking at renderstate, texture stage state, etc.)
// these are values that are handled identically for real user textures,
// the default texture, and the texture used for user clip planes, so we
// consolidate the code here.

__inline void nvCelsiusSetTextureBasics (CTexture *pTexture, DWORD *dwControl0,
                                         DWORD *dwFormatMask, DWORD *dwFilterMask)
{
    *dwControl0    = pTexture->getNV056Control0();
    *dwFormatMask  = pTexture->getNV056Format();
    *dwFilterMask  = 0;
}

//---------------------------------------------------------------------------

// OR in additional default texture stuff. these are values that are common
// to the default white texture and the clip plane texture but NOT real
// user textures. for the latter, they are contingent on other state settings.

__inline void nvCelsiusAddTextureDefaults (CTexture *pTexture,
                                           DWORD *dwControl0, DWORD *dwFormatMask,
                                           DWORD *dwFilterMask, DWORD *dwOffset)
{
    // these are backward from openGL. d3d can only set the maximum mipmap level, by which they mean
    // the openGL minimum level (d3d maximum = largest sized level to use, not largest level number).
    // the d3d minimum level (the openGL / celsius maximum) is always just the end of the chain
    *dwControl0 |= DRF_NUM(056, _SET_TEXTURE_CONTROL0, _MIN_LOD_CLAMP,
                           ((pTexture->getMipMapCount()-1) << 8));  // 4.8 fixed point

    *dwControl0 |= DRF_DEF(056, _SET_TEXTURE_CONTROL0, _LOG_MAX_ANISO, _0);

    *dwFormatMask |= DRF_DEF(056, _SET_TEXTURE_FORMAT, _CUBEMAP_ENABLE, _FALSE)  |

                     DRF_DEF(056, _SET_TEXTURE_FORMAT, _TEXTUREADDRESSU, _CLAMP) |
                     DRF_DEF(056, _SET_TEXTURE_FORMAT, _TEXTUREADDRESSV, _CLAMP) |

                     DRF_DEF(056, _SET_TEXTURE_FORMAT, _WRAPU, _FALSE)           |
                     DRF_DEF(056, _SET_TEXTURE_FORMAT, _WRAPV, _FALSE);

    *dwFilterMask |= DRF_DEF(056, _SET_TEXTURE_FILTER, _TEXTUREMIN, _NEAREST) |
                     DRF_DEF(056, _SET_TEXTURE_FILTER, _TEXTUREMAG, _NEAREST);

    *dwOffset = pTexture->getSwizzled()->getOffset();
}

//---------------------------------------------------------------------------

__inline void nvCelsiusSendTextureData (PNVD3DCONTEXT pContext,
                                        DWORD dwStage, DWORD dwControl0, DWORD dwOffset,
                                        DWORD dwFormatMask, DWORD dwFilterMask)
{
// #define TEXSTATE_STATS
#if defined(DEBUG) && defined(TEXSTATE_STATS)
    static DWORD dwC0Last = 0;
    static DWORD dwOffsetLast = 0;
    static DWORD dwFormatLast = 0;
    static DWORD dwFilterLast = 0;
    static DWORD dwC0Changes = 0;
    static DWORD dwOffsetChanges = 0;
    static DWORD dwFormatChanges = 0;
    static DWORD dwFilterChanges = 0;
    static DWORD dwTotalTexDataSets = 0;
    static DWORD dwLoopTime = 0;
#endif  // DEBUG && TEXSTATE_STATS

    pContext->hwState.celsius.set (NV056_SET_TEXTURE_CONTROL0(dwStage), dwControl0);
    pContext->hwState.celsius.set (NV056_SET_TEXTURE_OFFSET(dwStage),   dwOffset);
    pContext->hwState.celsius.set (NV056_SET_TEXTURE_FORMAT(dwStage),   dwFormatMask);
    pContext->hwState.celsius.set (NV056_SET_TEXTURE_FILTER(dwStage),   dwFilterMask);

#if defined(DEBUG) && defined(TEXSTATE_STATS)
    dwTotalTexDataSets++;
    if (dwControl0 != dwC0Last) {
        dwC0Last = dwControl0;
        dwC0Changes++;
    }
    if (dwOffset != dwOffsetLast) {
        dwOffsetLast = dwOffset;
        dwOffsetChanges++;
    }
    if (dwFormatMask != dwFormatLast) {
        dwFormatLast = dwFormatMask;
        dwFormatChanges++;
    }
    if (dwFilterMask != dwFilterLast) {
        dwFilterLast = dwFilterMask;
        dwFilterChanges++;
    }
    DWORD dwNow = GetTickCount();
    if ((dwNow - dwLoopTime) > 1000) {
        DPF ("----------------- TEX STATS ----------------- dwNow = %d",dwNow);
        dwLoopTime = dwNow;
        DPF ("control0 changes: %d", dwC0Changes);
        DPF ("  offset changes: %d", dwOffsetChanges);
        DPF ("  format changes: %d", dwFormatChanges);
        DPF ("  filter changes: %d", dwFilterChanges);
    }
#endif  // DEBUG && TEXSTATE_STATS
}

//---------------------------------------------------------------------------

HRESULT nvSetCelsiusTexturePalette (PNVD3DCONTEXT pContext, PNVD3DTEXSTAGESTATE pTSSState, DWORD dwHWStage)
{
    CSimpleSurface     *pPalette;
    CNvObject          *pPalObj;
    DWORD               dwCDMA, dwOffset;
    DWORD               dwSystemPalette = 0;    // count of system memory palettes
    DWORD               dwPaletteOffset = 0;

    // NV10 ISSUE:
    // The run-time DMA error STATUS_ERROR_INVALID_STATE (0x01000000) occurs
    // if the DMA controller requests 32-bit data words from system (PCI or AGP) memory
    // This can occur if the following condition was true when a primitive was launched:
    //  (((SetTextureControl0[0].Enable == TRUE) ||
    //    (SetTextureControl0[1].Enable == TRUE))   &&
    //   ((SetTextureFormat[0].Color == I8_A8R8G8B8) ||
    //    (SetTextureFormat[1].Color == I8_A8R8G8B8))   &&
    //   ((SetTexturePalette[0].PaletteContextDMA != SetTexturePalette[1].PaletteContextDMA) ||
    //    (SetTexturePalette[0].PaletteOffset != SetTexturePalette[1].PaletteOffset))   &&
    //   ((MemoryType(SetContextDmaA.handle) == SYSTEM) ||
    //    (MemoryType(SetContextDmaB.handle) == SYSTEM)))
    //   i.e. you can't fetch BOTH palettes from system/agp memory -- we don't have the bandwith.
    //   we can fetch them from video memory however.

    pPalObj = ((CNvObject *)(pTSSState->dwValue[D3DTSS_TEXTUREMAP]))->getPalette();

    if (pPalObj == NULL) {
        DPF ("stupid app/runtime gave us a palettized texture without a palette");
        dbgD3DError();
        return (DDERR_GENERIC);
    }

    pPalette = pPalObj->getPaletteSurface();
    nvAssert (pPalette);   // should already have bound a palette before using this texture

    dwCDMA   = nv056PaletteContextDma[pPalette->getContextDMA()];
    dwOffset = pPalette->getOffset();

    // only accept a VID MEM Palette
    nvAssert ((dwCDMA == NV056_SET_TEXTURE_PALETTE_CONTEXT_DMA_A) ||
              (dwCDMA == NV056_SET_TEXTURE_PALETTE_CONTEXT_DMA_B));
    nvAssert ((dwOffset & 0xff) == 0);

    if (dwCDMA == NV056_SET_TEXTURE_PALETTE_CONTEXT_DMA_B) {
        if (dwSystemPalette == 1 && dwPaletteOffset != dwOffset) {
            // nvAssert(0); // We can't do two system palettes at the same time
            dwOffset = dwPaletteOffset; // rather than faulting in the driver do this gross thing
                                        // of forcing the second palette to match the first.
        }
        else {
            dwSystemPalette = 1;
            dwPaletteOffset=dwOffset;
        }
    }

    // set the HW state. this perverse method wants dwOffset>>6. ours is not to reason why...
    pContext->hwState.celsius.set (NV056_SET_TEXTURE_PALETTE(dwHWStage),
                                (DRF_NUM (056, _SET_TEXTURE_PALETTE, _CONTEXT_DMA, dwCDMA) |
                                 DRF_NUM (056, _SET_TEXTURE_PALETTE, _PALETTE_OFFSET, (dwOffset>>6))));

    return (D3D_OK);
}

//---------------------------------------------------------------------------

// set celsius state having to do with textures, including:
//      - formats
//      - filters
//      - offsets
// note: the combiners must be set up before calling this routine!

HRESULT nvSetCelsiusTextureState (PNVD3DCONTEXT pContext)
{
    DWORD               dwHWStage, dwD3DStage, dwTexUnitStatus;
    DWORD               dwTexGen, dwTCIndex, dwVAIndex, dwMod;
    PNVD3DTEXSTAGESTATE pTSSState;
    DWORD               dwControl0, dwFormatMask, dwFilterMask;
    DWORD               dwOffset, dwTexgenMode;
    DWORD               dwTexgenT, dwZEnable;
    DWORD               dwUserCoordsNeeded = 0;
    DWORD               dwTexCoordIndices = 0;
    DWORD               dwNumTexCoordsNeeded = 0;
    DWORD               dwInvMVNeeded = 0;
    CTexture           *pTexture;
    BOOL                bCubeMap;
    BOOL                bWrapU, bWrapV, bWrapP, bWrapQ;
    DWORD               dwWDivideFlags = 0;
    DWORD               dwWSourceFlags = 0;
    BOOL                bWSourceFound = FALSE;
    D3DVALUE            pClipPlaneEye[4];
    D3DVALUE           *pClipPlane1, *pClipPlane2;
    DWORD               dwClipPlaneEnable, dwCurrentClipPlaneIndex;
    D3DMATRIX           mTmp, mTmp2;

    pContext->hwState.dwDirtyFlags &= ~CELSIUS_DIRTY_TEXTURE_STATE;

    dwZEnable = pContext->pZetaBuffer ? pContext->dwRenderState[D3DRENDERSTATE_ZENABLE] : 0;

    dwClipPlaneEnable = pContext->dwRenderState[D3DRENDERSTATE_CLIPPLANEENABLE];
    dwCurrentClipPlaneIndex = 0;

    // iterate over the HW's two texture units

    for (dwHWStage=0; dwHWStage < 2 ; dwHWStage++) {

        // which D3D stage is handled by this HW stage

        dwD3DStage = pContext->hwState.dwTexUnitToTexStageMapping[dwHWStage];

        if (dwD3DStage != CELSIUS_UNUSED) {

#ifdef NV_PROFILE_DP2OPS
            pDriverData->pBenchmark->incActiveTextures();
#endif

            // the combiners assigned this texture unit.
            // we must have a legitimate texture to use

            pTSSState = &(pContext->tssState[dwD3DStage]);
            nvAssert(pTSSState->dwValue[D3DTSS_TEXTUREMAP]);

            if (pTSSState->dwValue[D3DTSS_TEXTUREMAP]) {
                pTexture = ((CNvObject *)(pTSSState->dwValue[D3DTSS_TEXTUREMAP]))->getTexture();
                if(!pTexture){
                    //if failed to get a texture but user requested one -- use the default
                    pTexture = getDC()->pDefaultTexture;
                    pContext->hwState.dwStateFlags |= CELSIUS_FLAG_SETUPFAILURE;
                }
            } else {
                pTexture = getDC()->pDefaultTexture;
            }

            bCubeMap = pTexture->isCubeMap();
            if (bCubeMap) {
                // cubemaps may only be referenced from their bases
                pTexture = pTexture->getBaseTexture();

                if (dwZEnable == D3DZB_USEW) {
                    DPF("switching from W-buffering to Z-buffering b/c cube maps are enabled");
                    pContext->hwState.dwStateFlags |= CELSIUS_FLAG_SETUPFAILURE;
                    dwZEnable = D3DZB_TRUE;
                }
            }

            nvAssert (pTexture);
            dbgTextureDisplay (pTexture);

            dwNumTexCoordsNeeded |= KELVIN_SET_NUM_TEX_COORDS(dwHWStage, pTexture->getNumTexCoords());

            dwTexUnitStatus = CELSIUS_TEXUNITSTATUS_USER;
            pContext->hwState.pTextureInUse[dwHWStage] = pTexture;

            if (pTexture->isPalettized()) {
                nvSetCelsiusTexturePalette (pContext, pTSSState, dwHWStage);
            }
            else if (pTexture->hasAutoPalette()) {
                nvAssert((pTexture->getAutoPaletteOffset() & 63) == 0);
                // the header file (nv32.h) appears to be wrong here, texture offset is at bit 0
                // so we can't use the expected DRF_NUM(056, _SET_TEXTURE_PALETTE, _PALETTE_OFFSET, pTexture->getAutoPaletteOffset());
                DWORD dwFormat = DRF_NUM(056, _SET_TEXTURE_PALETTE, _CONTEXT_DMA, nv056PaletteContextDma[pTexture->getSwizzled()->getContextDMA()])
                               | (pTexture->getAutoPaletteOffset());
                pContext->hwState.celsius.set (NV056_SET_TEXTURE_PALETTE(dwHWStage), dwFormat);
            }

            // set up basic texture info
            nvCelsiusSetTextureBasics (pTexture, &dwControl0, &dwFormatMask, &dwFilterMask);

            // set up info specific to real user textures...

            dwTexGen  = (pContext->hwState.dwStateFlags & CELSIUS_FLAG_PASSTHROUGHMODE) ?
                        D3DTSS_TCI_PASSTHRU : pTSSState->dwValue[D3DTSS_TEXCOORDINDEX] & 0xffff0000;
            dwTCIndex = pTSSState->dwValue[D3DTSS_TEXCOORDINDEX] & 0x0000ffff;
            dwVAIndex = defaultInputRegMap[D3DVSDE_TEXCOORD0+dwTCIndex];

            // texgen
            switch (dwTexGen) {
                case D3DTSS_TCI_PASSTHRU:
                    if (pContext->pCurrentVShader->bVAExists(dwVAIndex)) {
                        dwUserCoordsNeeded |= CELSIUS_FLAG_USERTEXCOORDSNEEDED(dwHWStage);
                        dwTexCoordIndices  |= dwTCIndex << (16*dwHWStage);
                    }
                    else {
                        // u,v = 0,0   (says MS) W=1.0 THIS IS IMPORTANT (DOH!)
                            DWORD dwBase = NV056_SET_TEXCOORD0_4F(0) + 0x28 * dwHWStage; // macro not designed well
                            pContext->hwState.celsius.set4f (dwBase,0.0f, 0.0f, 0.0f, 1.0f);
                    }
                    dwTexgenMode = NV056_SET_TEXGEN_S_V_DISABLE;
                    break;
                case D3DTSS_TCI_CAMERASPACENORMAL:
                    dwInvMVNeeded = CELSIUS_FLAG_TEXSTATENEEDSINVMV;
                    dwTexgenMode = NV056_SET_TEXGEN_S_V_NORMAL_MAP;
                    break;
                case D3DTSS_TCI_CAMERASPACEPOSITION:
                    dwMod = 0x40 * dwHWStage; // macro not designed well
                    pContext->hwState.celsius.set4f (dwMod + NV056_SET_TEXGEN_SPLANE0(0), 1.0f, 0.0f, 0.0f, 0.0f);
                    pContext->hwState.celsius.set4f (dwMod + NV056_SET_TEXGEN_TPLANE0(0), 0.0f, 1.0f, 0.0f, 0.0f);
                    pContext->hwState.celsius.set4f (dwMod + NV056_SET_TEXGEN_RPLANE0(0), 0.0f, 0.0f, 1.0f, 0.0f);
                    dwTexgenMode = NV056_SET_TEXGEN_S_V_EYE_LINEAR;
                    break;
                case D3DTSS_TCI_CAMERASPACEREFLECTIONVECTOR:
                    dwInvMVNeeded = CELSIUS_FLAG_TEXSTATENEEDSINVMV;
                    dwTexgenMode = NV056_SET_TEXGEN_S_V_REFLECTION_MAP;
                    break;
                default:
                    DPF ("unknown texgen mode in nvSetCelsiusTextureState");
                    dbgD3DError();
                    pContext->hwState.dwStateFlags |= CELSIUS_FLAG_SETUPFAILURE;
                    break;
            }

            // we always generate three coordinates (i think)
            pContext->hwState.celsius.set (NV056_SET_TEXGEN_S(dwHWStage), dwTexgenMode);
            pContext->hwState.celsius.set (NV056_SET_TEXGEN_T(dwHWStage), dwTexgenMode);
            pContext->hwState.celsius.set (NV056_SET_TEXGEN_R(dwHWStage), dwTexgenMode);
            pContext->hwState.celsius.set (NV056_SET_TEXGEN_Q(dwHWStage), NV056_SET_TEXGEN_Q_V_DISABLE);

            // these are backward from openGL. d3d can only set the maximum mipmap level, by which they mean
            // the openGL minimum level (d3d maximum = largest sized level to use, not largest level number).
            // the d3d minimum level (the openGL / celsius maximum) is always just the end of the chain
            dwControl0 |= DRF_NUM(056, _SET_TEXTURE_CONTROL0, _MIN_LOD_CLAMP,
                                  (pTSSState->dwValue[D3DTSS_MAXMIPLEVEL] << 8));  // 4.8 fixed point

            // colorkey
            if ((pContext->dwRenderState[D3DRENDERSTATE_COLORKEYENABLE]) &&
                (pTexture->hasColorKey())) {
                dwControl0 |= DRF_DEF(056, _SET_TEXTURE_CONTROL0, _COLOR_KEY_OPERATION, _KILL);  // use this choice since the texture may not have alpha
                DWORD dwKey = pTexture->getColorKey();
#ifdef DEBUG
                DWORD dwFailState = 1;
#endif
                if (pTexture->isPalettized()) {
                    CNvObject *pObj = pTexture->getWrapper();
                    if (!pObj) goto failColorKeyPalette;

                    CNvObject *pPalette = pObj->getPalette();
                    if (!pPalette) goto failColorKeyPalette;

                    CSimpleSurface *pPaletteSurface = pPalette->getPaletteSurface();
                    if (!pPaletteSurface) goto failColorKeyPalette;

                    DWORD *dwPalette = (DWORD *)pPaletteSurface->getAddress();
                    if (!dwPalette) goto failColorKeyPalette;

                    if (dwKey >= 256) goto failColorKeyPalette;

                    dwKey = dwPalette[dwKey];
                }
#ifdef DEBUG
                dwFailState = 0;
#endif
failColorKeyPalette:  // We should put some kind of error code in here eventually
#ifdef DEBUG
                if (dwFailState) {
                    __asm int 3;
                    // Palettized
                }
#endif
                pContext->hwState.celsius.set (NV056_SET_COLOR_KEY_COLOR(dwHWStage), dwKey);
            }
            else {
                dwControl0 |= DRF_DEF(056, _SET_TEXTURE_CONTROL0, _COLOR_KEY_OPERATION, _FALSE);
            }

            // handle cubemapping
            dwFormatMask |= DRF_NUM(056, _SET_TEXTURE_FORMAT, _CUBEMAP_ENABLE, bCubeMap);

            dwFormatMask |= DRF_NUM(056, _SET_TEXTURE_FORMAT, _TEXTUREADDRESSU,
                                    nv056TextureAddress[pTSSState->dwValue[D3DTSS_ADDRESSU]]);
            dwFormatMask |= DRF_NUM(056, _SET_TEXTURE_FORMAT, _TEXTUREADDRESSV,
                                    nv056TextureAddress[pTSSState->dwValue[D3DTSS_ADDRESSV]]);

            // Check cylindrical wrapping (disallow it if we're cubemapping)
            NV_EVAL_CYLINDRICAL_WRAP (pContext, dwTCIndex, bWrapU, bWrapV, bWrapP, bWrapQ);

            if (bWrapU && !bCubeMap) {
                dwFormatMask |= DRF_DEF(056, _SET_TEXTURE_FORMAT, _WRAPU, _TRUE);
            }
            else {
                dwFormatMask |= DRF_DEF(056, _SET_TEXTURE_FORMAT, _WRAPU, _FALSE);
            }

            if (bWrapV && !bCubeMap) {
                dwFormatMask |= DRF_DEF(056, _SET_TEXTURE_FORMAT, _WRAPV, _TRUE);
            }
            else {
                dwFormatMask |= DRF_DEF(056, _SET_TEXTURE_FORMAT, _WRAPV, _FALSE);
            }

            if (!(dwFormatMask & (DRF_DEF(056, _SET_TEXTURE_FORMAT, _WRAPU, _TRUE) |
                                  DRF_DEF(056, _SET_TEXTURE_FORMAT, _WRAPV, _TRUE)))) {
#ifdef CELSIUS_ENABLE_BAD_PERSPECTIVE
                if (pContext->dwRenderState[D3DRENDERSTATE_TEXTUREPERSPECTIVE])
#endif
                {
                    dwWDivideFlags |= CELSIUS_FLAG_WDIVIDE (dwHWStage);
                    // we can source w from this stage for the purposes of w-buffering if w-divide is enabled
                    // and the texture is non-projective. we can't source w from a projective texture because
                    // the non-unitary q will be multiplied into the w values.
                    if (!(pTSSState->dwValue[D3DTSS_TEXTURETRANSFORMFLAGS] & D3DTTFF_PROJECTED)) {
                        dwWSourceFlags |= CELSIUS_FLAG_WSOURCE (dwHWStage);
                        bWSourceFound = TRUE;
                    }
                }
            }

            DWORD dwMinFilter = pTSSState->dwValue[D3DTSS_MINFILTER];
            DWORD dwMagFilter = pTSSState->dwValue[D3DTSS_MAGFILTER];
            DWORD dwMipFilter = pTSSState->dwValue[D3DTSS_MIPFILTER];

            if (pContext->dwDXAppVersion >= 0x800) {
                // DX8 changed the filter enumerants.  Remap them so we don't have to change our code.
                dwMinFilter = dx8MinFilterMapping[dwMinFilter];
                dwMagFilter = dx8MagFilterMapping[dwMagFilter];
                dwMipFilter = dx8MipFilterMapping[dwMipFilter];
            }

            // Mag filter aniso is bilinear in HW, and this passes WHQL.
            // As a result trigger anisotropic off of Min filter only
            if ((dwMinFilter == D3DTFN_ANISOTROPIC) ||
                (getDC()->nvD3DRegistryData.regAnisotropicLevel != D3D_REG_ANISOTROPICLEVEL_PASSIVE))
            {
                DWORD dwMaxAnisotropy = (getDC()->nvD3DRegistryData.regAnisotropicLevel == D3D_REG_ANISOTROPICLEVEL_PASSIVE) ?
                                        pTSSState->dwValue[D3DTSS_MAXANISOTROPY] :
                                        getDC()->nvD3DRegistryData.regAnisotropicLevel;
                switch (dwMaxAnisotropy) {
                    case 0:
                        // default back to point
                        dwControl0   |= DRF_DEF(056, _SET_TEXTURE_CONTROL0, _LOG_MAX_ANISO, _0);
                        dwFilterMask |= DRF_NUM(056, _SET_TEXTURE_FILTER, _TEXTUREMIN, nv056TextureMinFilter[D3DTFN_POINT][dwMipFilter]);
                        dwFilterMask |= DRF_NUM(056, _SET_TEXTURE_FILTER, _TEXTUREMAG, nv056TextureMagFilter[dwMagFilter]);
                        break;
                    case 1:
                        // default back to linear with no aniso
                        dwControl0   |= DRF_DEF(056, _SET_TEXTURE_CONTROL0, _LOG_MAX_ANISO, _0);
                        dwFilterMask |= DRF_NUM(056, _SET_TEXTURE_FILTER, _TEXTUREMIN, nv056TextureMinFilter[D3DTFN_LINEAR][dwMipFilter]);
                        dwFilterMask |= DRF_NUM(056, _SET_TEXTURE_FILTER, _TEXTUREMAG, nv056TextureMagFilter[dwMagFilter]);
                        break;
                    default:
                        // aniso > 2. we can't really do it, but we'll approximate it as best we can
                        pContext->hwState.dwStateFlags |= CELSIUS_FLAG_SETUPFAILURE;
                        // fall through
                    case 2:
                        // use real aniso
                        dwControl0   |= DRF_DEF(056, _SET_TEXTURE_CONTROL0, _LOG_MAX_ANISO, _1);
                        dwFilterMask |= DRF_NUM(056, _SET_TEXTURE_FILTER, _TEXTUREMIN, nv056TextureMinFilter[D3DTFN_LINEAR][dwMipFilter]);
                        dwFilterMask |= DRF_NUM(056, _SET_TEXTURE_FILTER, _TEXTUREMAG, nv056TextureMagFilter[D3DTFG_LINEAR]);

                        if(dwMagFilter == D3DTFG_POINT) {
                            // When aniso filtering is on, mag filter will be linear, point filtering
                            // won't happen, so we must fail validate texture stage for DCT450.
                            pContext->hwState.dwStateFlags |= CELSIUS_FLAG_SETUPFAILURE;
                        }
                        break;
                }  // switch
            }

            else {

                dwControl0   |= DRF_DEF(056, _SET_TEXTURE_CONTROL0, _LOG_MAX_ANISO, _0);
                dwFilterMask |= DRF_NUM(056, _SET_TEXTURE_FILTER, _TEXTUREMIN, nv056TextureMinFilter[dwMinFilter][dwMipFilter]);
                dwFilterMask |= DRF_NUM(056, _SET_TEXTURE_FILTER, _TEXTUREMAG, nv056TextureMagFilter[dwMagFilter]);
            }

            // OR in LOD bias
            DWORD dwLODBias = pTSSState->dwLODBias;
            if ((pContext->bScaledFlatPanel)         &&
                (pContext->dwEarlyCopyStrategy > 2)  &&
                (pContext->dwEarlyCopyStrategy < 10) &&
                (!(pContext->hwState.dwStateFlags & CELSIUS_FLAG_PASSTHROUGHMODE))) {
                // sign-extend from 5.8 to 24.8
                int iLODBias = (dwLODBias & 0x00001000) ? (dwLODBias | 0xfffff000) : dwLODBias;
                iLODBias += int (0.5f * 256.0f);   // 5.8 format
                // clamp to -2^12...2^12-1 (5.8 twos-complement fixed-point)
                iLODBias = max (iLODBias, int(-4096));
                iLODBias = min (iLODBias, int(4095));
                // return the last 13 bits
                dwLODBias = iLODBias & 0x00001fff;
            }
            dwFilterMask |= dwLODBias;

            dwOffset = pTexture->getSwizzled()->getOffset();

            nvCelsiusSendTextureData (pContext, dwHWStage, dwControl0, dwOffset, dwFormatMask, dwFilterMask);
        }

        else if (dwClipPlaneEnable) {

            // if user clip planes are enabled, knock off as many as we can.
            // (each texture stage can handle two)

            pTexture = getDC()->pClipPlaneTexture;

            dwTexUnitStatus = CELSIUS_TEXUNITSTATUS_CLIP;
            pContext->hwState.pTextureInUse[dwHWStage] = pTexture;

            dwWDivideFlags |= CELSIUS_FLAG_WDIVIDE (dwHWStage);
            dwWSourceFlags |= CELSIUS_FLAG_WSOURCE (dwHWStage);
            bWSourceFound = TRUE;

            // find the first enabled plane
            while (!(dwClipPlaneEnable & 0x1)) {
                dwClipPlaneEnable >>= 1;
                dwCurrentClipPlaneIndex++;
            }
            pClipPlane1 = pContext->ppClipPlane[dwCurrentClipPlaneIndex];
            dwClipPlaneEnable >>= 1;
            dwCurrentClipPlaneIndex++;

            // find the second enabled plane, if any
            if (dwClipPlaneEnable) {
                while (!(dwClipPlaneEnable & 0x1)) {
                    dwClipPlaneEnable >>= 1;
                    dwCurrentClipPlaneIndex++;
                }
                pClipPlane2 = pContext->ppClipPlane[dwCurrentClipPlaneIndex];
                dwTexgenT = NV056_SET_TEXGEN_T_V_EYE_LINEAR;
                dwClipPlaneEnable >>= 1;
                dwCurrentClipPlaneIndex++;
            }

            else {
                pClipPlane2 = NULL;
                dwTexgenT = NV056_SET_TEXGEN_T_V_DISABLE;
            }

            // set up tex coordinate sources
            // default to [1,1,0,1] and get s and/or t from eye space coords, as needed
            pContext->hwState.celsius.set4f (NV056_SET_TEXCOORD0_4F(0) + 0x28 * dwHWStage, 1.0f, 1.0f, 0.0f, 1.0f);
            pContext->hwState.celsius.set   (NV056_SET_TEXGEN_S(dwHWStage), NV056_SET_TEXGEN_S_V_EYE_LINEAR);
            pContext->hwState.celsius.set   (NV056_SET_TEXGEN_T(dwHWStage), dwTexgenT);
            pContext->hwState.celsius.set   (NV056_SET_TEXGEN_R(dwHWStage), NV056_SET_TEXGEN_R_V_DISABLE);
            pContext->hwState.celsius.set   (NV056_SET_TEXGEN_Q(dwHWStage), NV056_SET_TEXGEN_Q_V_DISABLE);

            // dot the eyespace coords with clip plane normals
            // D3D gives us the normals in world space, so they need to be converted to eye space
            Inverse4x4 (&mTmp, &(pContext->xfmView), TRUE);
            MatrixTranspose4x4 (&mTmp2, &mTmp);

            XformVector4 (pClipPlaneEye, pClipPlane1, &mTmp2);
            pContext->hwState.celsius.set4f (NV056_SET_TEXGEN_SPLANE0(0) + 0x40 * dwHWStage,
                                          pClipPlaneEye[0], pClipPlaneEye[1],
                                          pClipPlaneEye[2], pClipPlaneEye[3]);

            if (pClipPlane2) {
                XformVector4 (pClipPlaneEye, pClipPlane2, &mTmp2);
                pContext->hwState.celsius.set4f (NV056_SET_TEXGEN_TPLANE0(0) + 0x40 * dwHWStage,
                                              pClipPlaneEye[0], pClipPlaneEye[1],
                                              pClipPlaneEye[2], pClipPlaneEye[3]);
            }

            // we now have s<0 behind the plane and s>0 in front of the plane at the input
            // to the texture transform. we need to shift these coords by 0.5 so that clipped
            // stuff falls on the left (or upper) part of the texture and unclipped stuff falls
            // on the right (or lower) part of the texture
            pContext->hwState.celsius.set (NV056_SET_TEXTURE_MATRIX0_ENABLE + dwHWStage * 4, NV056_SET_TEXTURE_MATRIX0_ENABLE_V_TRUE);

            // for user clip planes we need a transform matrix that just adds small
            // quantities to the s and t coords produced by texgen
            DWORD dwBase = dwHWStage ? NV056_SET_TEXTURE_MATRIX1(0) : NV056_SET_TEXTURE_MATRIX0(0);
            pContext->hwState.celsius.set4f (dwBase +  0, 1.0f, 0.0f, 0.0f, 0.5f);
            pContext->hwState.celsius.set4f (dwBase + 16, 0.0f, 1.0f, 0.0f, pClipPlane2 ? 0.5f : 0.0f);
            pContext->hwState.celsius.set4f (dwBase + 32, 0.0f, 0.0f, 1.0f, 0.0f);
            pContext->hwState.celsius.set4f (dwBase + 48, 0.0f, 0.0f, 0.0f, 1.0f);

            nvCelsiusSetTextureBasics (pTexture, &dwControl0, &dwFormatMask, &dwFilterMask);
            nvCelsiusAddTextureDefaults (pTexture, &dwControl0, &dwFormatMask, &dwFilterMask, &dwOffset);

            dwControl0 |= DRF_DEF(056, _SET_TEXTURE_CONTROL0, _COLOR_KEY_OPERATION, _KILL);
            pContext->hwState.celsius.set (NV056_SET_COLOR_KEY_COLOR(dwHWStage), 0);

            nvCelsiusSendTextureData (pContext, dwHWStage, dwControl0, dwOffset, dwFormatMask, dwFilterMask);
        }

        else if ((dwZEnable==D3DZB_USEW) && (bWSourceFound==FALSE)) {

            // we're using w-buffering, but we haven't yet enabled a texture unit
            // in which we can do the requisite w divide. the w divide is required
            // because the inverted 1/w value (plain w itself) required for w-buffering
            // is only available (with sufficient precision) from the texturing unit.

            // use the default texture (white)
            pTexture = getDC()->pDefaultTexture;

            dwTexUnitStatus = CELSIUS_TEXUNITSTATUS_DEFAULT;
            pContext->hwState.pTextureInUse[dwHWStage] = pTexture;

            dwWDivideFlags |= CELSIUS_FLAG_WDIVIDE (dwHWStage);
            dwWSourceFlags |= CELSIUS_FLAG_WSOURCE (dwHWStage);
            bWSourceFound = TRUE;

            pContext->hwState.celsius.set4 (NV056_SET_TEXGEN_S(dwHWStage),
                                         NV056_SET_TEXGEN_S_V_DISABLE,
                                         NV056_SET_TEXGEN_T_V_DISABLE,
                                         NV056_SET_TEXGEN_R_V_DISABLE,
                                         NV056_SET_TEXGEN_Q_V_DISABLE);

            nvCelsiusSetTextureBasics (pTexture, &dwControl0, &dwFormatMask, &dwFilterMask);
            nvCelsiusAddTextureDefaults (pTexture, &dwControl0, &dwFormatMask, &dwFilterMask, &dwOffset);

            dwControl0 |= DRF_DEF(056, _SET_TEXTURE_CONTROL0, _COLOR_KEY_OPERATION, _FALSE);

            nvCelsiusSendTextureData (pContext, dwHWStage, dwControl0, dwOffset, dwFormatMask, dwFilterMask);
        }

        else {

            // no user texture, no clip planes, no w-buffering. go ahead and totally disable the stage

            dwTexUnitStatus = CELSIUS_TEXUNITSTATUS_IDLE;
            pContext->hwState.pTextureInUse[dwHWStage] = NULL;

            pContext->hwState.celsius.set4 (NV056_SET_TEXGEN_S(dwHWStage),
                                            NV056_SET_TEXGEN_S_V_DISABLE,
                                            NV056_SET_TEXGEN_T_V_DISABLE,
                                            NV056_SET_TEXGEN_R_V_DISABLE,
                                            NV056_SET_TEXGEN_Q_V_DISABLE);

            // control 0
            // explicitly disable aniso because celsius will not automatically
            // disable it when the texture itself is disabled (can cost performance)
            dwControl0 = DRF_DEF(056, _SET_TEXTURE_CONTROL0, _ENABLE, _FALSE) |
                         DRF_DEF(056, _SET_TEXTURE_CONTROL0, _LOG_MAX_ANISO, _0);

            pContext->hwState.celsius.set (NV056_SET_TEXTURE_CONTROL0(dwHWStage), dwControl0);
        }

        if (pContext->hwState.dwTextureUnitStatus[dwHWStage] != dwTexUnitStatus) {
            pContext->hwState.dwTextureUnitStatus[dwHWStage] = dwTexUnitStatus;
            pContext->hwState.dwDirtyFlags |= CELSIUS_DIRTY_TEXTURE_TRANSFORM
                                           |  CELSIUS_DIRTY_FVF
                                           |  CELSIUS_DIRTY_TL_MODE;
        }

    }  // for dwHWStage=0...

    // we can't w-buffer if we can't get w from any of the texture units
    if ((dwZEnable==D3DZB_USEW) && (bWSourceFound==FALSE)) {
        DPF("no texture unit available for w divide. w-buffering impossible");
        pContext->hwState.dwStateFlags |= CELSIUS_FLAG_SETUPFAILURE;
        dwZEnable = D3DZB_TRUE;
    }

    // set dependent dirty state

    if ((pContext->hwState.dwStateFlags & (CELSIUS_FLAG_USERTEXCOORDSNEEDED(0) | CELSIUS_FLAG_USERTEXCOORDSNEEDED(1))) != dwUserCoordsNeeded) {
        pContext->hwState.dwStateFlags &= ~(CELSIUS_FLAG_USERTEXCOORDSNEEDED(0) | CELSIUS_FLAG_USERTEXCOORDSNEEDED(1));
        pContext->hwState.dwStateFlags |= dwUserCoordsNeeded;
        pContext->hwState.dwDirtyFlags |= CELSIUS_DIRTY_FVF;
    }

    if ((pContext->hwState.dwStateFlags & (CELSIUS_FLAG_WDIVIDE(0) | CELSIUS_FLAG_WDIVIDE(1))) != dwWDivideFlags) {
        pContext->hwState.dwStateFlags &= ~(CELSIUS_FLAG_WDIVIDE(0) | CELSIUS_FLAG_WDIVIDE(1));
        pContext->hwState.dwStateFlags |= dwWDivideFlags;
        pContext->hwState.dwDirtyFlags |= CELSIUS_DIRTY_TL_MODE
                                       |  CELSIUS_DIRTY_TEXTURE_TRANSFORM;
    }

    if ((pContext->hwState.dwStateFlags & (CELSIUS_FLAG_WSOURCE(0) | CELSIUS_FLAG_WSOURCE(1))) != dwWSourceFlags) {
        pContext->hwState.dwStateFlags &= ~(CELSIUS_FLAG_WSOURCE(0) | CELSIUS_FLAG_WSOURCE(1));
        pContext->hwState.dwStateFlags |= dwWSourceFlags;
        pContext->hwState.dwDirtyFlags |= CELSIUS_DIRTY_CONTROL0;
    }

    if ((pContext->hwState.dwStateFlags & CELSIUS_FLAG_TEXSTATENEEDSINVMV) != dwInvMVNeeded) {
        pContext->hwState.dwStateFlags &= ~CELSIUS_FLAG_TEXSTATENEEDSINVMV;
        pContext->hwState.dwStateFlags |= dwInvMVNeeded;
        pContext->hwState.dwDirtyFlags |= dwInvMVNeeded ? CELSIUS_DIRTY_TRANSFORM : 0;
    }

    if (pContext->hwState.dwTexCoordIndices != dwTexCoordIndices) {
        pContext->hwState.dwTexCoordIndices = dwTexCoordIndices;
        pContext->hwState.dwDirtyFlags |= CELSIUS_DIRTY_FVF;
    }

    if (dwNumTexCoordsNeeded != pContext->hwState.dwNumTexCoordsNeeded) {
        pContext->hwState.dwNumTexCoordsNeeded = dwNumTexCoordsNeeded;
        pContext->hwState.dwDirtyFlags |= CELSIUS_DIRTY_FVF;
    }


    if (pContext->hwState.celsius.dwZEnable != dwZEnable) {
        pContext->hwState.celsius.dwZEnable = dwZEnable;
        pContext->hwState.dwDirtyFlags |= CELSIUS_DIRTY_TL_MODE
                                       |  CELSIUS_DIRTY_FVF
                                       |  CELSIUS_DIRTY_TRANSFORM
                                       |  CELSIUS_DIRTY_SPECFOG_COMBINER
                                       |  CELSIUS_DIRTY_CONTROL0
                                       |  CELSIUS_DIRTY_MISC_STATE;
    }

    if ((getDC()->nvD3DRegistryData.regD3DEnableBits1 & D3D_REG_SQUASHW_MASK) == D3D_REG_SQUASHW_ENABLE) {
        pContext->hwState.dwDirtyFlags |= CELSIUS_DIRTY_TRANSFORM;
    }

    return (D3D_OK);
}

//---------------------------------------------------------------------------

HRESULT nvCelsiusSetFogMode (PNVD3DCONTEXT pContext, DWORD *dwZFogMask)
{
    float fBias, fScale;

    nvAssert (pContext->dwRenderState[D3DRENDERSTATE_FOGENABLE]);

    cacheFogValues(pContext);

    pContext->hwState.celsius.prep_wait_for_idle_nv10();

    switch (pContext->fogData.dwFogTableMode) {
        case D3DFOG_NONE:   // user-supplied fog (neither table nor vertex)
            fBias = 1.0f;
            fScale = 1.0f;
            pContext->hwState.celsius.set (NV056_SET_FOG_MODE, NV056_SET_FOG_MODE_FOG_MODE_LINEAR);
            break;
        case D3DFOG_LINEAR:
            fBias = 1.0f + pContext->fogData.fFogTableEnd * pContext->fogData.fFogTableLinearScale;
            fScale = -pContext->fogData.fFogTableLinearScale;
            pContext->hwState.celsius.set (NV056_SET_FOG_MODE, NV056_SET_FOG_MODE_FOG_MODE_LINEAR);
            break;
        case D3DFOG_EXP:
            fBias = 1.5f;
            fScale = -pContext->fogData.fFogTableDensity * (1.0f / (2.0f * 5.5452f));
            pContext->hwState.celsius.set (NV056_SET_FOG_MODE, NV056_SET_FOG_MODE_FOG_MODE_EXP);
            break;
        case D3DFOG_EXP2:
            fBias = 1.5f;
            fScale = -pContext->fogData.fFogTableDensity * (1.0f / (2.0f * (float)sqrt(5.5452f)));
            pContext->hwState.celsius.set (NV056_SET_FOG_MODE, NV056_SET_FOG_MODE_FOG_MODE_EXP2);
            break;
        default:
            DPF ("uh oh. unknown fog mode");
    }

    *dwZFogMask = 0;

    if (pContext->fogData.dwFogTableMode == D3DFOG_NONE) {
        // both table fog and vertex fog are disabled. we default back to regular user fog
        pContext->hwState.celsius.set (NV056_SET_FOG_GEN_MODE, NV056_SET_FOG_GEN_MODE_FOG_GEN_MODE_USE_INPUT);
        // the hardware needs OGL's infinite view vector for user fog (for reasons that escape me)
        if (getDC()->bD3DViewVector) {
            nvglSetNv10CelsiusNoOp (NV_DD_CELSIUS);
            pContext->hwState.celsius.set3f (NV056_SET_EYE_DIRECTION_SW(0), 0.f,0.f,1.f);
            getDC()->bD3DViewVector = FALSE;
        }
    }

    else {
        // we're doing vertex or table fog. on celsius we simply upgrade the former to the
        // latter and treat them both the same way.
        if (pContext->hwState.dwStateFlags & CELSIUS_FLAG_PASSTHROUGHMODE) {
            // if we're in passthru mode, we have to hack things a bit to still get
            // the use of the HW fog table which is intimately tied to the T&L unit.
            // we use the foggenmode to tell the HW what to use for depth
            nvAssert(pContext->hwState.dwFogSource); // assert that fog source has been set
            if (pContext->hwState.dwFogSource == CHardwareState::FOG_SOURCE_Z) {
                // use z for fog depth
                pContext->hwState.celsius.set (NV056_SET_FOG_GEN_MODE, 0x01);
                *dwZFogMask = CELSIUS_FLAG_ZFOG;
            }
            else {
                // use w for fog depth
                pContext->hwState.celsius.set (NV056_SET_FOG_GEN_MODE, 0x02);
                // if we're w-buffering, 1/w will get scaled before it gets to the fog unit.
                // we need to undo the scale by re-applying the same scale here.
                // (we just re-apply, b/c 1/w has also been subsequently inverted)
                if (pContext->hwState.celsius.dwZEnable == D3DZB_USEW) {
                    nvAssert (pContext->pRenderTarget);
                    fScale *= (pContext->surfaceViewport.dvWFar * pContext->hwState.dvInvZScale);
                }
            }
        }
        else {
            // not in passthru mode. just do things normally
            if (pContext->dwRenderState[D3DRENDERSTATE_RANGEFOGENABLE]) {
                pContext->hwState.celsius.set (NV056_SET_FOG_GEN_MODE, NV056_SET_FOG_GEN_MODE_FOG_GEN_MODE_RADIAL);
            }
            else {
                pContext->hwState.celsius.set (NV056_SET_FOG_GEN_MODE, NV056_SET_FOG_GEN_MODE_FOG_GEN_MODE_PLANAR);
                // Since we're already in eye space, just construct the plane
                pContext->hwState.celsius.set4f (NV056_SET_FOG_PLANE(0), 0.0f, 0.0f, 1.0f, 0.0f);
            }
        }
    }

    if (pContext->hwState.dwStateFlags & CELSIUS_FLAG_PASSTHROUGHMODE) {
        // in passthru mode, K0, K1, and K2 all get the scale.
        // ambient red gets overloaded with the bias
        pContext->hwState.celsius.set3f (NV056_SET_FOG_PARAMS(0),          fScale, fScale, fScale);
        pContext->hwState.celsius.set3f (NV056_SET_SCENE_AMBIENT_COLOR(0), fBias,  0.0f,   0.0f  );
    }
    else {
        pContext->hwState.celsius.set3f (NV056_SET_FOG_PARAMS(0), fBias, fScale, 0.0f);
    }

    return (D3D_OK);
}

//---------------------------------------------------------------------------

// set the fog/specular combiner

HRESULT nvSetCelsiusSpecularFogCombiner (PNVD3DCONTEXT pContext)
{
    DWORD dwControl0, dwControl1;  // HW control words
    DWORD dwZFogMask;

    pContext->hwState.dwDirtyFlags &= ~CELSIUS_DIRTY_SPECFOG_COMBINER;

    dwControl0 = 0;

    if (pContext->dwRenderState[D3DRENDERSTATE_FOGENABLE]) {
        pContext->hwState.celsius.set (NV056_SET_FOG_ENABLE, NV056_SET_FOG_ENABLE_V_TRUE);
        pContext->hwState.celsius.set (NV056_SET_FOG_COLOR,  swapRGB(pContext->dwRenderState[D3DRENDERSTATE_FOGCOLOR]));

        nvCelsiusSetFogMode (pContext, &dwZFogMask);

        // A is fog factor in fog alpha
        dwControl0 |= DRF_DEF(056, _SET_COMBINER_SPECULAR_FOG_CW0, _A_SOURCE, _REG_3);
        // A alpha is used for fog - replicate it
        dwControl0 |= DRF_DEF(056, _SET_COMBINER_SPECULAR_FOG_CW0, _A_ALPHA, _TRUE);

        // B source is (textured diffuse) or (textured diffuse + specular)
        if (pContext->dwRenderState[D3DRENDERSTATE_SPECULARENABLE]) {
            dwControl0 |= DRF_DEF(056, _SET_COMBINER_SPECULAR_FOG_CW0, _B_SOURCE, _REG_SPECLIT);
        }
        else {  // don't add specular to diffuse(textured) color
            dwControl0 |= DRF_DEF(056, _SET_COMBINER_SPECULAR_FOG_CW0, _B_SOURCE, _REG_C);
        }

        // if the last stage was using addcomplement as its colorop, we need to invert color here
        if (pContext->hwState.dwStateFlags & CELSIUS_FLAG_ADDCOMPLEMENTRGB(pContext->hwState.dwNumActiveCombinerStages - 1)) {
            dwControl0 |= DRF_DEF(056, _SET_COMBINER_SPECULAR_FOG_CW0, _B_INVERSE, _TRUE);
        }

        // C is fog color
        dwControl0 |= DRF_DEF(056, _SET_COMBINER_SPECULAR_FOG_CW0, _C_SOURCE, _REG_3);

        // D isn't used
        pContext->hwState.celsius.set (NV056_SET_COMBINER_SPECULAR_FOG_CW0, dwControl0);
    }

    else { // no fog, just output diffuse (+ specular)
        pContext->hwState.celsius.set (NV056_SET_FOG_ENABLE, NV056_SET_FOG_ENABLE_V_FALSE);

        dwZFogMask = 0;

        if (pContext->dwRenderState[D3DRENDERSTATE_SPECULARENABLE]) {
            dwControl0 |= DRF_DEF(056, _SET_COMBINER_SPECULAR_FOG_CW0, _D_SOURCE, _REG_SPECLIT);
        }
        else {  // don't add specular to diffuse(textured) color
            dwControl0 |= DRF_DEF(056, _SET_COMBINER_SPECULAR_FOG_CW0, _D_SOURCE, _REG_C);
        }

        // if the last stage was using addcomplement as its colorop, we need to invert color here
        if (pContext->hwState.dwStateFlags & CELSIUS_FLAG_ADDCOMPLEMENTRGB(pContext->hwState.dwNumActiveCombinerStages - 1)) {
            dwControl0 |= DRF_DEF(056, _SET_COMBINER_SPECULAR_FOG_CW0, _D_INVERSE, _TRUE);
        }

        pContext->hwState.celsius.set (NV056_SET_COMBINER_SPECULAR_FOG_CW0, dwControl0);

        pContext->hwState.celsius.prep_wait_for_idle_nv10();
        pContext->hwState.celsius.set (NV056_SET_FOG_MODE,                  NV056_SET_FOG_MODE_FOG_MODE_LINEAR);
        pContext->hwState.celsius.set (NV056_SET_FOG_GEN_MODE,              NV056_SET_FOG_GEN_MODE_FOG_GEN_MODE_USE_INPUT);
    }

    dwControl1 = 0;

    // the final value for alpha is just taken from G
    dwControl1 |= DRF_DEF(056, _SET_COMBINER_SPECULAR_FOG_CW1, _G_SOURCE, _REG_C);

    if (pContext->hwState.dwStateFlags & CELSIUS_FLAG_DOTPRODUCT3(pContext->hwState.dwNumActiveCombinerStages-1)) {
        // if the last stage produced a dot product, we were supposed to have replicated the result
        // into alpha, but couldn't b/c celsius can't. get it from the color channels now.
        dwControl1 |= DRF_DEF(056, _SET_COMBINER_SPECULAR_FOG_CW1, _G_ALPHA, _FALSE);
    }
    else {
        // just grab alpha from alpha
        dwControl1 |= DRF_DEF(056, _SET_COMBINER_SPECULAR_FOG_CW1, _G_ALPHA, _TRUE);
        // if the last stage was using addcomplement as its alphaop, we need to invert alpha here
        if (pContext->hwState.dwStateFlags & CELSIUS_FLAG_ADDCOMPLEMENTALPHA(pContext->hwState.dwNumActiveCombinerStages-1)) {
            dwControl1 |= DRF_DEF(056, _SET_COMBINER_SPECULAR_FOG_CW1, _G_INVERSE, _TRUE);
        }
    }

    dwControl1 |= DRF_DEF(056, _SET_COMBINER_SPECULAR_FOG_CW1, _SPECULAR_CLAMP, _TRUE);

    pContext->hwState.celsius.set (NV056_SET_COMBINER_SPECULAR_FOG_CW1, dwControl1);

    //cachec off spec/fog control words
    pContext->hwState.specfog_cw[0] = dwControl0;
    pContext->hwState.specfog_cw[1] = dwControl1;

#ifdef ALPHA_CULL
    if(pContext->dwEarlyCopyStrategy && pContext->hwState.alphacull_mode >= 2)
        pContext->hwState.dwDirtyFlags |= CELSIUS_DIRTY_MISC_STATE;
#endif

    if ((pContext->hwState.dwStateFlags & CELSIUS_FLAG_ZFOG) != dwZFogMask) {
        pContext->hwState.dwStateFlags &= ~CELSIUS_FLAG_ZFOG;
        pContext->hwState.dwStateFlags |= dwZFogMask;
        pContext->hwState.dwDirtyFlags |= CELSIUS_DIRTY_TRANSFORM;
    }

    return (D3D_OK);
}

//---------------------------------------------------------------------------

// set celsius TL mode (passthrough stuff)

HRESULT nvSetCelsiusTLMode (PNVD3DCONTEXT pContext)
{
    DWORD dwPassthru, dwHWStage;

    pContext->hwState.dwDirtyFlags &= ~CELSIUS_DIRTY_TL_MODE;

    if (pContext->hwState.dwStateFlags & CELSIUS_FLAG_PASSTHROUGHMODE) {
        dwPassthru = DRF_DEF(056, _SET_TLMODE, _PASSTHROUGH, _TRUE);
    }
    else {
        dwPassthru = DRF_DEF(056, _SET_TLMODE, _PASSTHROUGH, _FALSE);
    }

    for (dwHWStage=0; dwHWStage<2; dwHWStage++) {
        if (pContext->hwState.dwStateFlags & CELSIUS_FLAG_WDIVIDE(dwHWStage)) {
            dwPassthru |= (dwHWStage == 0) ?
                          DRF_DEF(056, _SET_TLMODE, _W_DIVIDE_0, _ENABLE) :
                          DRF_DEF(056, _SET_TLMODE, _W_DIVIDE_1, _ENABLE);
        }
        else {
            dwPassthru |= (dwHWStage == 0) ?
                          DRF_DEF(056, _SET_TLMODE, _W_DIVIDE_0, _DISABLE) :
                          DRF_DEF(056, _SET_TLMODE, _W_DIVIDE_1, _DISABLE);
        }
    }

    pContext->hwState.celsius.set (NV056_SET_TLMODE, dwPassthru);

    return (D3D_OK);
}

#if 1

//---------------------------------------------------------------------------

// Check for need / feasibility of texture matrix hack and return values in bNeeded and bFeasible.
// The hack is needed if:
// - we only have a class 056 celsius
// - the broken matrix element is non-negligibly non-zero
// The HW hack if feasible if:
// - this stage uses eyespace coordinates generated by the HW
// - the other texture stage is either disabled or has a user texture with texgen disabled
// - we're not in passthru mode
// The SW workaround is feasible if:
// - texgen is not enabled

void nvTexMatrixHackCheck
(
    PNVD3DCONTEXT pContext,
    DWORD         dwHWStage,
    BOOL          bTexgen,
    D3DVALUE      dvCriticalElement,
    BOOL         *bEnableHWHack,
    BOOL         *bEnableSWHack
)
{
    DWORD dwOtherHWStage, dwOtherTexUnitStatus, dwOtherD3DStage, dwOtherTexgenMode;
    BOOL  bOtherTexgen;

    // assume things are ok unless we find otherwise
    *bEnableHWHack = *bEnableSWHack = FALSE;

    // we only need to worry about this if we have nothing better than a class 056 celsius
    // and the critical element is non-negligible
    if (!(pDriverData->nvD3DPerfData.dwNVClasses & (NVCLASS_0096_CELSIUS | NVCLASS_1196_CELSIUS))
        &&
        ((dvCriticalElement > CELSIUS_TEX_MATRIX_HACK_THRESHOLD) ||
         (dvCriticalElement < -CELSIUS_TEX_MATRIX_HACK_THRESHOLD)))
    {
        // a texture matrix workaround is required. can we do it?
        dwOtherHWStage       = dwHWStage ^ 0x1;
        dwOtherTexUnitStatus = pContext->hwState.dwTextureUnitStatus[dwOtherHWStage];

        if (dwOtherTexUnitStatus == CELSIUS_TEXUNITSTATUS_USER) {
            dwOtherD3DStage   = pContext->hwState.dwTexUnitToTexStageMapping[dwOtherHWStage];
            dwOtherTexgenMode = (pContext->hwState.dwStateFlags & CELSIUS_FLAG_PASSTHROUGHMODE) ?
                                D3DTSS_TCI_PASSTHRU:pContext->tssState[dwOtherD3DStage].dwValue[D3DTSS_TEXCOORDINDEX] & 0xffff0000;
            bOtherTexgen      = (dwOtherTexgenMode != D3DTSS_TCI_PASSTHRU);
        }

        if ((bTexgen)
            &&
            ((dwOtherTexUnitStatus == CELSIUS_TEXUNITSTATUS_IDLE)
             ||
             (dwOtherTexUnitStatus == CELSIUS_TEXUNITSTATUS_DEFAULT)
             ||
             ((dwOtherTexUnitStatus == CELSIUS_TEXUNITSTATUS_USER) && (!bOtherTexgen)))
            &&
            (!(pContext->hwState.dwStateFlags & CELSIUS_FLAG_PASSTHROUGHMODE)))
        {
            // enable the HW-based hack
            *bEnableHWHack = TRUE;
        }
        else if (!bTexgen)
        {
            // enable the SW workaround
            *bEnableSWHack = TRUE;
        }
        else
        {
            // we need it but can't do it
            pContext->hwState.dwStateFlags |= CELSIUS_FLAG_SETUPFAILURE;
        }
    }

}

#else

//---------------------------------------------------------------------------

// check for need / feasibility of texture matrix hack :
// - this stage uses eyespace coordinates generated by the HW
// - the broken matrix element is non-negligibly non-zero
// - the other texture stage is either disabled or has a user texture with texgen disabled
// - we're not in passthru mode

BOOL nvTexMatrixHackEnable (PNVD3DCONTEXT pContext, DWORD dwHWStage, BOOL bTexgen, D3DVALUE dvCriticalElement)
{
    DWORD dwOtherHWStage, dwOtherTexUnitStatus, dwOtherD3DStage, dwOtherTexgenMode;
    BOOL  bOtherTexgen;

    // we only need to worry about this if we have nothing better than a class 056 celsius
    if (pDriverData->nvD3DPerfData.dwNVClasses & (NVCLASS_0096_CELSIUS | NVCLASS_1196_CELSIUS)) {
        return (FALSE);
    }

    if ((dvCriticalElement > CELSIUS_TEX_MATRIX_HACK_THRESHOLD) ||
        (dvCriticalElement < -CELSIUS_TEX_MATRIX_HACK_THRESHOLD))
    {
        // the texture matrix hack is required. can we actually do it?
        dwOtherHWStage       = dwHWStage ^ 0x1;
        dwOtherTexUnitStatus = pContext->hwState.dwTextureUnitStatus[dwOtherHWStage];

        if (dwOtherTexUnitStatus == CELSIUS_TEXUNITSTATUS_USER) {
            dwOtherD3DStage   = pContext->hwState.dwTexUnitToTexStageMapping[dwOtherHWStage];
            dwOtherTexgenMode = pContext->tssState[dwOtherD3DStage].dwValue[D3DTSS_TEXCOORDINDEX] & 0xffff0000;
            bOtherTexgen      = (dwOtherTexgenMode != D3DTSS_TCI_PASSTHRU);
        }

        if ((bTexgen)
            &&
            ((dwOtherTexUnitStatus == CELSIUS_TEXUNITSTATUS_IDLE)
             ||
             (dwOtherTexUnitStatus == CELSIUS_TEXUNITSTATUS_DEFAULT)
             ||
             ((dwOtherTexUnitStatus == CELSIUS_TEXUNITSTATUS_USER) && (!bOtherTexgen)))
            &&
            (!(pContext->hwState.dwStateFlags & CELSIUS_FLAG_PASSTHROUGHMODE)))
        {
            // we need it and can do it
            return (TRUE);
        }
        else
        {
            // we need it but can't do it
            pContext->hwState.dwStateFlags |= CELSIUS_FLAG_SETUPFAILURE;
            return (FALSE);
        }
    }
    else
    {
        // texture matrix hack isn't required
        return (FALSE);
    }
}

#endif

//---------------------------------------------------------------------------

// set texture transformation matrices

HRESULT nvSetCelsiusTextureTransform (PNVD3DCONTEXT pContext)
{
    CTexture    *pTexture;
    BOOL        bEnable, bXForm, bCubeMap, bTexgen;
    DWORD       dwPassthruCubeMappingMask = 0;
    DWORD       dwTextureMatrixHackMask = 0;
#if (NVARCH >= 0x015)
    BOOL        bWDivideEnable;
#endif
    DWORD       dwOp, dwFlags, dwInCount, dwOutCount, dwTexUnitStatus, dwTexgenMode;
    DWORD       dwHWStage, dwD3DStage, dwMatrixEnable, dwMatrixDisable;
    DWORD       dwMatrixName, dwMatrixType;
    LPD3DMATRIX pMatrix;
#ifdef CELSIUS_TEX_MATRIX_HACK
    D3DVALUE    dvCriticalElement;
    BOOL        bHWHack, bSWHack;
#endif  // CELSIUS_TEX_MATRIX_HACK

    pContext->hwState.dwDirtyFlags &= ~CELSIUS_DIRTY_TEXTURE_TRANSFORM;

    for (dwHWStage=0; dwHWStage < 2; dwHWStage++) {

        dwTexUnitStatus = pContext->hwState.dwTextureUnitStatus[dwHWStage];

        if (dwTexUnitStatus == CELSIUS_TEXUNITSTATUS_CLIP) {
            // if we're doing clip planes, we've already set up texture transform
            continue;
        }

        if (dwHWStage==0) {
            dwMatrixEnable  = NV056_SET_TEXTURE_MATRIX0_ENABLE_V_TRUE;
            dwMatrixDisable = NV056_SET_TEXTURE_MATRIX0_ENABLE_V_FALSE;
            dwMatrixName    = NV056_SET_TEXTURE_MATRIX0(0);
        }
        else {
            dwMatrixEnable  = NV056_SET_TEXTURE_MATRIX1_ENABLE_V_TRUE;
            dwMatrixDisable = NV056_SET_TEXTURE_MATRIX1_ENABLE_V_FALSE;
            dwMatrixName    = NV056_SET_TEXTURE_MATRIX1(0);
        }

        dwD3DStage = pContext->hwState.dwTexUnitToTexStageMapping[dwHWStage];

        if (dwD3DStage == CELSIUS_UNUSED) {
            bEnable = FALSE;
        }

        else {

            nvAssert (dwTexUnitStatus == CELSIUS_TEXUNITSTATUS_USER);
            dwOp    = pContext->tssState[dwD3DStage].dwValue[D3DTSS_COLOROP];

            // Stage state doesn't matter if pixel shaders are on
            nvAssert (dwOp != D3DTOP_DISABLE || pContext->pCurrentPShader);

            dwFlags = pContext->tssState[dwD3DStage].dwValue[D3DTSS_TEXTURETRANSFORMFLAGS];

            // the number of coordinates to come out of the transformation, INCLUSIVE
            // of the projective coordinate when the D3DTTFF_PROJECTED flag is set.
            // (== the number of matrix columns with non-zero elements)
            dwOutCount = dwFlags & 0xff; // BUGBUG there should be a #define for this. pester MS
            bXForm = (dwOutCount != D3DTTFF_DISABLE);

            pTexture = pContext->hwState.pTextureInUse[dwHWStage];
            bCubeMap = pTexture && pTexture->isCubeMap();

            dwTexgenMode = pContext->tssState[dwD3DStage].dwValue[D3DTSS_TEXCOORDINDEX] & 0xffff0000;
            bTexgen = (dwTexgenMode != D3DTSS_TCI_PASSTHRU);

            bWDivideEnable = (pContext->hwState.dwStateFlags & CELSIUS_FLAG_WDIVIDE(dwHWStage)) ? TRUE : FALSE;

            // enable if they requested a transform explicitly or:
            // - cubemapping (requires shift of r into q)
            // - texgen is enabled (accommodate hacky nv15 HW fix for nv10 tex matrix bug)
            // - w divide is disabled in T&L mode (likewise)
            bEnable = bXForm   ||
                      bCubeMap ||
                      bTexgen  ||
                      (!bWDivideEnable && !(pContext->hwState.dwStateFlags & CELSIUS_FLAG_PASSTHROUGHMODE));

            if (bEnable && (pContext->hwState.dwStateFlags & CELSIUS_FLAG_PASSTHROUGHMODE))
            {
                bEnable = FALSE;
                if (bXForm || bTexgen) {
                    // we wanted tex transform for something more than just cubemapping. no can do.
                    DPF ("Hardware can't do texture matrix transform in passthrough mode");
                    pContext->hwState.dwStateFlags |= CELSIUS_FLAG_SETUPFAILURE;
                }
                if (bCubeMap) {
                    dwPassthruCubeMappingMask |= CELSIUS_FLAG_PASSTHROUGHCUBEMAPPING(dwHWStage);
                }
            }
        }


        if (!bEnable) {

            pContext->hwState.celsius.set (NV056_SET_TEXTURE_MATRIX0_ENABLE + dwHWStage * 4, dwMatrixDisable);

        }

        else {

            pContext->hwState.celsius.set (NV056_SET_TEXTURE_MATRIX0_ENABLE + dwHWStage * 4, dwMatrixEnable);

            pMatrix = &(pContext->tssState[dwD3DStage].mTexTransformMatrix);

            if (bCubeMap) {

                if (!bXForm) {
                    // no transformation desired by user, but celsius still requires a transformation
                    // to shift the r coordinate into the q position where the HW can access it.
                    // (celsius doesn't really handle 3 coordinates and always ignores the r slot)
                    pContext->hwState.celsius.setTextureTransformMatrixCubeMapIdent (dwMatrixName);
                }

                else {
                    // texture transformation and cubemapping are both enabled.

#ifdef CELSIUS_TEX_MATRIX_HACK
                    nvTexMatrixHackCheck (pContext, dwHWStage, bTexgen, pMatrix->_13, &bHWHack, &bSWHack);

                    if (bHWHack) {
                        DPF ("using tex transform hack #1a");
                        dwTextureMatrixHackMask |= CELSIUS_FLAG_TEXMATRIXHACK(dwHWStage);
                        pContext->hwState.celsius.setTextureTransformMatrixCubeMapIdent (dwMatrixName);
                    }
                    else if (bSWHack) {
                        DPF ("using SW workaround for broken texture matrix in stage %d", dwHWStage);
                        dwTextureMatrixHackMask |= CELSIUS_FLAG_TEXMATRIXSWFIX(dwHWStage);
                        pContext->hwState.celsius.setTextureTransformMatrixCubeMapIdent (dwMatrixName);
                    }
                    else
#endif  // CELSIUS_TEX_MATRIX_HACK
                    {
#ifdef DEBUG
                        // some sanity checks:
                        // the transformation should be a 3-coordinate transformation.
                        if (dwOutCount != D3DTTFF_COUNT3) {
                            DPF ("ugh. cubemap texture tranformation matrix is not a 3-D transformation");
                        }
                        // the transform should not include any shifting. translating 3 coordinates
                        // requires four rows in the matrix, but celsius only looks at three rows.
                        if ((pMatrix->_41) || (pMatrix->_42) || (pMatrix->_43)) {
                            DPF ("blurg. cubemap texture tranformation matrix is attempting translation");
                        }
                        // finally, the transform cannot include a projection because projecting
                        // requires q which is unavailable because r will be stored in its place.
                        // projecting cubemap coordinates really just means scaling a vector which
                        // is meaningless anyhow.
                        if (dwFlags & D3DTTFF_PROJECTED) {
                            DPF ("ack. can't do projective cubemapping, but who cares");
                        }
#endif
                        // set the matrix, copying column 3 to column 4, thereby moving r to the q slot.
                        pContext->hwState.celsius.setTextureTransformMatrixCubeMap (dwMatrixName,pMatrix);
                    }

                }

            }  // cubemap

            else if (bXForm) {

                // the number of coordinates incoming from the FVF vertex data or texgen
                // (== the number of matrix rows with non-zero elements)
                // (actually there can be dwInCount+1 rows with non-zero elements b/c D3D assumes
                // that a q==1 is automatially postpended to the coordinates they give you)
                DWORD dwTexGen  = pContext->tssState[dwD3DStage].dwValue[D3DTSS_TEXCOORDINDEX] & 0xffff0000;
                DWORD dwTCIndex = pContext->tssState[dwD3DStage].dwValue[D3DTSS_TEXCOORDINDEX] & 0x0000ffff;
                DWORD dwVAIndex = defaultInputRegMap[D3DVSDE_TEXCOORD0+dwTCIndex];
                if (dwTexGen) {
                    dwInCount = 3;
                }
                else {
                    // if index invalid, just use 0,0
                    dwInCount = (pContext->pCurrentVShader->bVAExists(dwVAIndex)) ?
                                (pContext->pCurrentVShader->getVASize(dwVAIndex)) :
                                2*sizeof(DWORD);
                    dwInCount >>= 2;
                }

                // calculate an arbitrary identifier
                dwMatrixType = ((dwFlags & D3DTTFF_PROJECTED) ? 2 : 1) * dwInCount;

#ifdef CELSIUS_TEX_MATRIX_HACK
                switch (dwMatrixType) {
                    case 2:
                    case 3:
                        dvCriticalElement = 0.0f;
                        break;
                    case 4:
                    case 6:
                        dvCriticalElement = pMatrix->_13;
                        break;
                }

                nvTexMatrixHackCheck (pContext, dwHWStage, bTexgen, dvCriticalElement, &bHWHack, &bSWHack);

                if (bHWHack) {
                    DPF ("using tex transform hack #1b");
                    dwTextureMatrixHackMask |= CELSIUS_FLAG_TEXMATRIXHACK(dwHWStage);
                    //swap R/Q columns so we divide by the right thing later.
                    D3DMATRIX mTemp;
                    mTemp._11 = mTemp._22 = mTemp._34 = mTemp._43 = 1;
                    mTemp._12 = mTemp._13 = mTemp._14 = mTemp._21 = mTemp._23 = mTemp._24 = 0;
                    mTemp._31 = mTemp._32 = mTemp._33 = mTemp._41 = mTemp._42 = mTemp._44 = 0;
                    pContext->hwState.celsius.setMatrixTransposed (dwMatrixName, &mTemp);
                    //nvglSetNv10CelsiusTextureMatrixEnable (NV_DD_CELSIUS, dwHWStage, dwMatrixDisable);
                }
                else if (bSWHack) {
                    DPF ("using SW workaround for broken texture matrix in stage %d", dwHWStage);
                    dwTextureMatrixHackMask |= CELSIUS_FLAG_TEXMATRIXSWFIX(dwHWStage);
                    pContext->hwState.celsius.setMatrixIdent (dwMatrixName);
                }
                else
#endif  // CELSIUS_TEX_MATRIX_HACK

                {
#if defined(CELSIUS_TEX_MATRIX_HACK) && defined(DEBUG)
                    if ((!(pDriverData->nvD3DPerfData.dwNVClasses & (NVCLASS_0096_CELSIUS | NVCLASS_1196_CELSIUS))) &&
                        (fabs(dvCriticalElement) > CELSIUS_TEX_MATRIX_HACK_THRESHOLD)) {
                        DPF ("nvSetCelsiusTextureTransform: Critical element is non-zero. Undefined result.");
                    }
#endif

                    switch (dwMatrixType) {

                        case 2:

                            // 2 incoming texture coordinates, unprojected
                            // dwOutCount for an unprojected texture should be 2 : (s,t)
                            nvAssert (dwOutCount == 2);
                            // expand the matrix and override the last column with [0 0 0 1]'
                            pContext->hwState.celsius.setTextureTransformMatrixTypeA (dwMatrixName, pMatrix);
#ifdef DEBUG
                            if ((pMatrix->_13 != 0.0f) || (pMatrix->_23 != 0.0f) || (pMatrix->_33 != 0.0f)) {
                                DPF_LEVEL(NVDBG_LEVEL_INFO,"d3d is sketchy. driver overwrote values in last column b/c it was");
                                DPF_LEVEL(NVDBG_LEVEL_INFO,"given a projective texture matrix when projection was disabled");
                            }
#endif
                            break;

                        case 3:

                            // 3 incoming texture coordinates, unprojected
                            // dwOutCount for an unprojected texture should be 2 : (s,t)
                            nvAssert (dwOutCount == 2);
                            // override the last column with [0 0 0 1]'
                            pContext->hwState.celsius.setTextureTransformMatrixTypeB (dwMatrixName, pMatrix);
#ifdef DEBUG
                            if ((pMatrix->_14 != 0.0f) || (pMatrix->_24 != 0.0f) ||
                                (pMatrix->_34 != 0.0f) || (pMatrix->_44 != 0.0f)) {
                                DPF_LEVEL(NVDBG_LEVEL_INFO,"d3d is sketchy. driver overwrote values in last column b/c it was");
                                DPF_LEVEL(NVDBG_LEVEL_INFO,"given a projective texture matrix when projection was disabled");
                            }
#endif
                            break;

                        case 4:

                            // 2 incoming texture coordinates, projected
                            // dwOutCount for a projected texture should be 3 : (s,t,q)
                            nvAssert (dwOutCount == 3);
                            // expand the matrix but don't override the last column
                            pContext->hwState.celsius.setTextureTransformMatrixTypeC (dwMatrixName, pMatrix);
#ifdef DEBUG
                            if ((pMatrix->_13 == 0.0f) && (pMatrix->_23 == 0.0f) && (pMatrix->_33 == 0.0f)) {
                                DPF_LEVEL(NVDBG_LEVEL_INFO,"d3d is REALLY sketchy. got a projective texture transform matrix");
                                DPF_LEVEL(NVDBG_LEVEL_INFO,"with no non-zero values in the last column");
                            }
#endif
                            break;

                        case 6:

                            // 3 incoming texture coordinates, projected
                            // dwOutCount for a projected texture should be 3 : (s,t,q)
                            nvAssert (dwOutCount == 3);
                            // move col 3 to col 4
                            pContext->hwState.celsius.setTextureTransformMatrixTypeD (dwMatrixName, pMatrix);
#ifdef DEBUG
                            if ((pMatrix->_13 == 0.0f) && (pMatrix->_23 == 0.0f) &&
                                (pMatrix->_33 == 0.0f) && (pMatrix->_43 == 0.0f)) {
                                DPF_LEVEL(NVDBG_LEVEL_INFO,"d3d is REALLY sketchy. got a projective texture transform matrix");
                                DPF_LEVEL(NVDBG_LEVEL_INFO,"with zeros in the whole 3rd column");
                            }
#endif
                            break;

                        default:

                            DPF ("unknown combination of projectivism and number of texture coords");
                            dbgD3DError();
                            break;

                    }  // switch

                }  // else ! tex matrix hack

            }  // bXForm

            else {  // !bcubemap && !bXForm

                // we don't have a cubemap and haven't enabled tex xform explicitly, but we're
                // using texgen or we've disabled w divide. due to some hacky HW fixes on nv15,
                // both of these require that we enable the texture transform.
                nvAssert (bTexgen || !bWDivideEnable);
                pContext->hwState.celsius.setMatrixIdent (dwMatrixName);

            }

        }  // else enable

    }  // for dwHWStage=0...

    if ((pContext->hwState.dwStateFlags & (CELSIUS_FLAG_PASSTHROUGHCUBEMAPPING(0) | CELSIUS_FLAG_PASSTHROUGHCUBEMAPPING(1))) != dwPassthruCubeMappingMask) {
        pContext->hwState.dwStateFlags &= ~(CELSIUS_FLAG_PASSTHROUGHCUBEMAPPING(0) | CELSIUS_FLAG_PASSTHROUGHCUBEMAPPING(1));
        pContext->hwState.dwStateFlags |= dwPassthruCubeMappingMask;
        pContext->hwState.dwDirtyFlags |= CELSIUS_DIRTY_FVF;
    }

    // if we now need a tex matrix hack or used to need it and now don't, re-program some other state
    // that has all sorts of hack-specific dependencies for which the dirty bits won't normally get set
    if ((dwTextureMatrixHackMask) || (pContext->hwState.dwStateFlags & CELSIUS_MASK_TEXMATRIXHACKS)) {
        pContext->hwState.dwStateFlags &= ~CELSIUS_MASK_TEXMATRIXHACKS;
        pContext->hwState.dwStateFlags |= dwTextureMatrixHackMask;
        pContext->hwState.dwDirtyFlags |= (CELSIUS_DIRTY_TRANSFORM | CELSIUS_DIRTY_FVF);
    }

    return (D3D_OK);
}

//---------------------------------------------------------------------------

// set celsius class specular parameters

HRESULT nvCelsiusSetSpecularParams (PNVD3DCONTEXT pContext)
{
    float L, M, N, L1, M1, N1, power;

    nvAssert ((pContext->dwRenderState[D3DRENDERSTATE_SPECULARENABLE]) ||
              (pContext->hwState.dwStateFlags & CELSIUS_FLAG_COMBINERSNEEDSPECULAR));

    power = pContext->Material.power;
    explut (power, &L, &M);
    N = 1.f+L-M;
    explut (0.5f*power, &L1, &M1);
    N1 = 1.f+L1-M1;
    pContext->hwState.celsius.set3f (NV056_SET_SPECULAR_PARAMS(0),L, M, N);
    pContext->hwState.celsius.set3f (NV056_SET_SPECULAR_PARAMS(3),L1,M1,N1);

    return (D3D_OK);
}

//---------------------------------------------------------------------------

// set diffuse, specular, and ambient colors for a particular light
// input:
//      - dwLightID = light index [0...7]
//      - pLight7 = pointer to light data
//      - dwCmArg   = color material flags

HRESULT nvCelsiusDumpLightColors (PNVD3DCONTEXT pContext,
                                  DWORD dwLightID, LPD3DLIGHT7 pLight7,
                                  DWORD dwCmArg, BOOL bSpecularNeeded)
{
    D3DVALUE dvAmbientR, dvAmbientG, dvAmbientB;
    D3DVALUE dvDiffuseR, dvDiffuseG, dvDiffuseB;
    D3DVALUE dvSpecularR, dvSpecularG, dvSpecularB;

    nvAssert ((dwLightID >=0) && (dwLightID <= 7));

    dvAmbientR = pLight7->dcvAmbient.dvR;
    dvAmbientG = pLight7->dcvAmbient.dvG;
    dvAmbientB = pLight7->dcvAmbient.dvB;
    if (!(dwCmArg & NV056_SET_COLOR_MATERIAL_V_AMBIENT)) {
        // follow material ambient color
        dvAmbientR *= pContext->Material.dcvAmbient.dvR;
        dvAmbientG *= pContext->Material.dcvAmbient.dvG;
        dvAmbientB *= pContext->Material.dcvAmbient.dvB;
    }

    dvDiffuseR = pLight7->dcvDiffuse.dvR;
    dvDiffuseG = pLight7->dcvDiffuse.dvG;
    dvDiffuseB = pLight7->dcvDiffuse.dvB;
    if (!(dwCmArg & NV056_SET_COLOR_MATERIAL_V_DIFFUSE)) {
        // follow material diffuse color
        dvDiffuseR *= pContext->Material.dcvDiffuse.dvR;
        dvDiffuseG *= pContext->Material.dcvDiffuse.dvG;
        dvDiffuseB *= pContext->Material.dcvDiffuse.dvB;
    }

    if (bSpecularNeeded) {
        dvSpecularR = pLight7->dcvSpecular.dvR;
        dvSpecularG = pLight7->dcvSpecular.dvG;
        dvSpecularB = pLight7->dcvSpecular.dvB;
        if (!(dwCmArg & NV056_SET_COLOR_MATERIAL_V_SPECULAR)) {
            // follow material specular color
            dvSpecularR *= pContext->Material.dcvSpecular.dvR;
            dvSpecularG *= pContext->Material.dcvSpecular.dvG;
            dvSpecularB *= pContext->Material.dcvSpecular.dvB;
        }
    }
    else {
        dvSpecularR = dvSpecularG = dvSpecularB = 0.0f;
    }

    pContext->hwState.celsius.set3f (NV056_SET_LIGHT_AMBIENT_COLOR(dwLightID,0), dvAmbientR, dvAmbientG, dvAmbientB);  // ambient
    pContext->hwState.celsius.set3f (NV056_SET_LIGHT_DIFFUSE_COLOR(dwLightID,0), dvDiffuseR, dvDiffuseG, dvDiffuseB);  // diffuse
    pContext->hwState.celsius.set3f (NV056_SET_LIGHT_SPECULAR_COLOR(dwLightID,0),dvSpecularR,dvSpecularG,dvSpecularB); // specular

    return (D3D_OK);
}

//---------------------------------------------------------------------------

// set position and attenuation of a particular light
// input:
//      - dwLightID = light index [0...7]
//      - pLight7 = pointer to light data

HRESULT nvCelsiusDumpLocalLightData (PNVD3DCONTEXT pContext, int dwLightID, LPD3DLIGHT7 pLight7)
{
    D3DVECTOR pos0, pos1;

    nvAssert ((dwLightID >=0) && (dwLightID <= 7));

    // We don't normalize the position
    pos0 = pLight7->dvPosition;
    XformBy4x3 (&pos1, &pos0, 1.f, &(pContext->xfmView));

#ifdef CELSIUS_TEX_MATRIX_HACK
    DWORD dwHackMask = pContext->hwState.dwStateFlags & (CELSIUS_FLAG_TEXMATRIXHACK(0) | CELSIUS_FLAG_TEXMATRIXHACK(1));
    // the hack can't be enabled for both stages simultaneously
    nvAssert (dwHackMask != (CELSIUS_FLAG_TEXMATRIXHACK(0) | CELSIUS_FLAG_TEXMATRIXHACK(1)));

    if (dwHackMask) {
        DWORD dwHWStage  = (dwHackMask & CELSIUS_FLAG_TEXMATRIXHACK(0)) ? 0 : 1;
        DWORD dwD3DStage = pContext->hwState.dwTexUnitToTexStageMapping[dwHWStage];
        LPD3DMATRIX pTexMatrix = &(pContext->tssState[dwD3DStage].mTexTransformMatrix);
        XformBy4x3 (&pos0, &pos1, 1.f, pTexMatrix);
        pos1 = pos0;
    }
#endif  // CELSIUS_TEX_MATRIX_HACK

    pContext->hwState.celsius.set3f (NV056_SET_LIGHT_LOCAL_POSITION(dwLightID,0), pos1.dvX, pos1.dvY, pos1.dvZ);

    if ((*(DWORD *)(&(pLight7->dvAttenuation0)) == 0) &&
        (*(DWORD *)(&(pLight7->dvAttenuation1)) == 0) &&
        (*(DWORD *)(&(pLight7->dvAttenuation2)) == 0)) {
        DPF ("d3d gave us a divide by 0 error b/c all attenuations are 0. nice.");
        pLight7->dvAttenuation0 = 1.f;
    }

    pContext->hwState.celsius.set3f (NV056_SET_LIGHT_LOCAL_ATTENUATION(dwLightID,0),
                                  pLight7->dvAttenuation0,
                                  pLight7->dvAttenuation1,
                                  pLight7->dvAttenuation2);

#ifdef STATE_CULL
    // attenuation stomps on infinite half-vector and vice-versa
    pContext->hwState.celsius.valid [NV056_SET_LIGHT_INFINITE_HALF_VECTOR(dwLightID,0) >> 2] = 0;
#endif

    return (D3D_OK);
}

//---------------------------------------------------------------------------

// D3D allows you to assign either of the two vertex colors (diffuse / specular)
// to ANY of the material colors, eg. you can stuff vertex diffuse into material
// emissive. Celsius can't do all these permutations, so we implement only those
// that we can.

DWORD getCelsiusColorMaterialFlags (PNVD3DCONTEXT pContext)
{
    DWORD dwArgs;

    dwArgs = NV056_SET_COLOR_MATERIAL_V_DISABLED;

    // if COLORVERTEX isn't set just return now
    if (!pContext->dwRenderState[D3DRENDERSTATE_COLORVERTEX]) {
        return (dwArgs);
    }

    switch (pContext->dwRenderState[D3DRENDERSTATE_AMBIENTMATERIALSOURCE]) {
        case D3DMCS_MATERIAL:
            break;
        case D3DMCS_COLOR1:  // diffuse
            // inherit material ambient from vertex diffuse
            if (pContext->pCurrentVShader->bVAExists(defaultInputRegMap[D3DVSDE_DIFFUSE])) {
                dwArgs |= NV056_SET_COLOR_MATERIAL_V_AMBIENT;
            }
            break;
        case D3DMCS_COLOR2:  // specular
            if (pContext->pCurrentVShader->bVAExists(defaultInputRegMap[D3DVSDE_SPECULAR])) {
                DPF ("Celsius can't map vertex specular into material ambient");
            }
            break;
        default:
            DPF ("unknown AMBIENTMATERIALSOURCE");
            break;
    }

    switch (pContext->dwRenderState[D3DRENDERSTATE_DIFFUSEMATERIALSOURCE]) {
        case D3DMCS_MATERIAL:
            break;
        case D3DMCS_COLOR1:  // diffuse
            // inherit material diffuse from vertex diffuse
            if (pContext->pCurrentVShader->bVAExists(defaultInputRegMap[D3DVSDE_DIFFUSE])) {
                dwArgs |= NV056_SET_COLOR_MATERIAL_V_DIFFUSE;
            }
            break;
        case D3DMCS_COLOR2:  // specular
            if (pContext->pCurrentVShader->bVAExists(defaultInputRegMap[D3DVSDE_SPECULAR])) {
                DPF ("Celsius can't map vertex specular into material diffuse");
            }
            break;
        default:
            DPF ("unknown DIFFUSEMATERIALSOURCE");
            break;
    }

    switch (pContext->dwRenderState[D3DRENDERSTATE_SPECULARMATERIALSOURCE]) {
        case D3DMCS_MATERIAL:
            break;
        case D3DMCS_COLOR1:  // diffuse
            if (pContext->pCurrentVShader->bVAExists(defaultInputRegMap[D3DVSDE_DIFFUSE])) {
                if (pContext->pCurrentVShader->bVAExists(defaultInputRegMap[D3DVSDE_SPECULAR])) {
                    // if vertex specular is valid, enabling NV056_SET_COLOR_MATERIAL_SPECULAR
                    // will make the HW pull material specular from the vertex specular,
                    // NOT vertex diffuse as desired.
                    DPF ("Celsius can't map vertex diffuse into material specular when vertex specular is valid");
                }
                else {
                    // in the absence of a vertex specular, NV056_SET_COLOR_MATERIAL_SPECULAR
                    // will make the HW pull material specular from the vertex diffuse
                    dwArgs |= NV056_SET_COLOR_MATERIAL_V_SPECULAR;
                }
            }
            break;
        case D3DMCS_COLOR2:  // specular
            // inherit material specular from vertex specular
            if (pContext->pCurrentVShader->bVAExists(defaultInputRegMap[D3DVSDE_SPECULAR])) {
                dwArgs |= NV056_SET_COLOR_MATERIAL_V_SPECULAR;
            }
            break;
        default:
            DPF ("unknown SPECULARMATERIALSOURCE");
            break;
    }

    switch (pContext->dwRenderState[D3DRENDERSTATE_EMISSIVEMATERIALSOURCE]) {
        case D3DMCS_MATERIAL:
            break;
        case D3DMCS_COLOR1:  // diffuse
            // inherit material emissive from vertex diffuse
            if (pContext->pCurrentVShader->bVAExists(defaultInputRegMap[D3DVSDE_DIFFUSE])) {
                dwArgs |= NV056_SET_COLOR_MATERIAL_V_EMISSION;
            }
            break;
        case D3DMCS_COLOR2:  // specular
            if (pContext->pCurrentVShader->bVAExists(defaultInputRegMap[D3DVSDE_SPECULAR])) {
                DPF ("Celsius can't map vertex specular into material emissive");
            }
            break;
        default:
            DPF ("unknown EMISSIVEMATERIALSOURCE");
            break;
    }

    return (dwArgs);
}

//---------------------------------------------------------------------------

// set lighting state

HRESULT nvSetCelsiusLights (PNVD3DCONTEXT pContext)
{
    DWORD         dwColorMaterialArgs;
    DWORD         dwControl = 0;
    DWORD         dwLightNum;
    DWORD         dwMask = 0;
    D3DCOLORVALUE dcvAmbient, dcvEmissive;
    D3DVECTOR     eyeDirection;
    D3DVECTOR     dir, hv, tmp;          // light directions
    pnvLight      pLight;
    LPD3DLIGHT7   pLight7;
#ifdef CELSIUS_TEX_MATRIX_HACK
    DWORD         dwHackMask, dwHWStage, dwD3DStage;
    LPD3DMATRIX   pTexMatrix;
#endif  // CELSIUS_TEX_MATRIX_HACK
    BOOL          bSpecularNeeded;
    DWORD         dwInvMVNeeded;

    pContext->hwState.dwDirtyFlags &= ~CELSIUS_DIRTY_LIGHTS;

    // specular enable
    bSpecularNeeded = ((pContext->dwRenderState[D3DRENDERSTATE_SPECULARENABLE]) ||
                       (pContext->hwState.dwStateFlags & CELSIUS_FLAG_COMBINERSNEEDSPECULAR)) ? TRUE : FALSE;
    pContext->hwState.celsius.set (NV056_SET_SPECULAR_ENABLE, DRF_NUM(056, _SET_SPECULAR_ENABLE, _V, bSpecularNeeded));


    // disable hardware lighting if app has disabled it or if we're in passthrough mode
    // (yes, stupid apps will try to enable lighting without giving us normals, etc...)
    if (!GET_LIGHTING_STATE(pContext) || (pContext->hwState.dwStateFlags & CELSIUS_FLAG_PASSTHROUGHMODE)) {

        // disable lighting
        pContext->hwState.celsius.set (NV056_SET_LIGHTING_ENABLE, NV056_SET_LIGHTING_ENABLE_V_FALSE);

        dwInvMVNeeded = 0;

        // lighting control
        dwControl |= (DRF_DEF(056, _SET_LIGHT_CONTROL, _LOCALEYE, _FALSE) |
                      DRF_DEF(056, _SET_LIGHT_CONTROL, _ATTENUATION_MODE, _INVERT));

        if (bSpecularNeeded) {
            dwControl |= (DRF_DEF(056, _SET_LIGHT_CONTROL, _SEPARATE_SPECULAR_EN, _TRUE) |  // don't force specular to 0
                          DRF_DEF(056, _SET_LIGHT_CONTROL, _SECONDARY_COLOR_EN, _TRUE));    // get specular from user input
        }
        else {
            dwControl |= (DRF_DEF(056, _SET_LIGHT_CONTROL, _SEPARATE_SPECULAR_EN, _FALSE) | // force specular to 0
                          DRF_DEF(056, _SET_LIGHT_CONTROL, _SECONDARY_COLOR_EN, _FALSE));   // doesn't actually matter where we get it from
        }
        pContext->hwState.celsius.set (NV056_SET_LIGHT_CONTROL, dwControl);

    }

    else {

        // we shouldn't be in passthru mode if we're really going to do lighting
        // (moreover we can't be, b/c we won't have calculated xfmInvModelView which
        // is needed for spot lights)
        nvAssert (!(pContext->hwState.dwStateFlags & CELSIUS_FLAG_PASSTHROUGHMODE));

        // enable lighting
        pContext->hwState.celsius.set (NV056_SET_LIGHTING_ENABLE, NV056_SET_LIGHTING_ENABLE_V_TRUE);

        dwInvMVNeeded = CELSIUS_FLAG_LIGHTINGNEEDSINVMV;

        // lighting control
        dwControl |= DRF_DEF(056, _SET_LIGHT_CONTROL, _ATTENUATION_MODE, _INVERT);

        // use local viewer only if we really need to, since it's slow
        if ((pContext->dwRenderState[D3DRENDERSTATE_LOCALVIEWER]) &&
            (pContext->lighting.pActiveLights != NULL) &&
            (bSpecularNeeded)) {
            dwControl |= DRF_DEF(056, _SET_LIGHT_CONTROL, _LOCALEYE, _TRUE);
        }
        else {
            dwControl |= DRF_DEF(056, _SET_LIGHT_CONTROL, _LOCALEYE, _FALSE);
            // if the hardware is currently set up to use OGL's infinite
            // view vector, re-program D3D's backward view vector
            if (!getDC()->bD3DViewVector) {
                nvglSetNv10CelsiusNoOp (NV_DD_CELSIUS);
                pContext->hwState.celsius.set3f (NV056_SET_EYE_DIRECTION_SW(0), 0.f,0.f,-1.f);
                getDC()->bD3DViewVector = TRUE;
            }
        }

        // set up specular
        if (bSpecularNeeded) {
            dwControl |= (DRF_DEF(056, _SET_LIGHT_CONTROL, _SEPARATE_SPECULAR_EN, _TRUE) |  // don't force specular to 0
                          DRF_DEF(056, _SET_LIGHT_CONTROL, _SECONDARY_COLOR_EN, _FALSE));   // get specular from T&L
            nvCelsiusSetSpecularParams (pContext);
        }
        else {
            dwControl |= (DRF_DEF(056, _SET_LIGHT_CONTROL, _SEPARATE_SPECULAR_EN, _FALSE) |  // force specular to 0
                          DRF_DEF(056, _SET_LIGHT_CONTROL, _SECONDARY_COLOR_EN, _FALSE));    // doesn't actually matter where we get it from
        }

        pContext->hwState.celsius.set (NV056_SET_LIGHT_CONTROL, dwControl);

        // material properties
        dwColorMaterialArgs = getCelsiusColorMaterialFlags (pContext);

        // We need to handle each of these combinations separately, because the hardware is a bit weird in some
        // ways.  First, Celsius can't do AMBIENT and EMISSION simultaneously--so we factor the emission component
        // into ambient by adding 1.  Second, material emission doesn't seem to work when AMBIENT isn't set, so we
        // again add that component into ambient.  Last, the hardware doesn't have separate controls for material
        // ambient and scene ambient, so we fold both of those into the global ambient when necessary.
        if ((dwColorMaterialArgs & NV056_SET_COLOR_MATERIAL_V_EMISSION_AMBIENT) == NV056_SET_COLOR_MATERIAL_V_EMISSION_AMBIENT) {
            dwColorMaterialArgs &= ~NV056_SET_COLOR_MATERIAL_V_EMISSION_AMBIENT;
            dwColorMaterialArgs |= NV056_SET_COLOR_MATERIAL_V_AMBIENT;
            dcvAmbient.dvR = pContext->lighting.dcvAmbient.dvR + 1.0f;
            dcvAmbient.dvG = pContext->lighting.dcvAmbient.dvG + 1.0f;
            dcvAmbient.dvB = pContext->lighting.dcvAmbient.dvB + 1.0f;
            dcvEmissive.dvR = 0.0f;
            dcvEmissive.dvG = 0.0f;
            dcvEmissive.dvB = 0.0f;
        }
        else if ((dwColorMaterialArgs & NV056_SET_COLOR_MATERIAL_V_AMBIENT) == NV056_SET_COLOR_MATERIAL_V_AMBIENT) {
            dcvAmbient.dvR  = pContext->lighting.dcvAmbient.dvR;
            dcvAmbient.dvG = pContext->lighting.dcvAmbient.dvG;
            dcvAmbient.dvB = pContext->lighting.dcvAmbient.dvB;
            dcvEmissive.dvR = pContext->Material.dcvEmissive.dvR;
            dcvEmissive.dvG = pContext->Material.dcvEmissive.dvG;
            dcvEmissive.dvB = pContext->Material.dcvEmissive.dvB;
        }
        else if ((dwColorMaterialArgs & NV056_SET_COLOR_MATERIAL_V_EMISSION) == NV056_SET_COLOR_MATERIAL_V_EMISSION) {
            dcvAmbient.dvR = pContext->lighting.dcvAmbient.dvR * pContext->Material.dcvAmbient.dvR;
            dcvAmbient.dvG = pContext->lighting.dcvAmbient.dvG * pContext->Material.dcvAmbient.dvG;
            dcvAmbient.dvB = pContext->lighting.dcvAmbient.dvB * pContext->Material.dcvAmbient.dvB;
            dcvEmissive.dvR = 0.0f;
            dcvEmissive.dvG = 0.0f;
            dcvEmissive.dvB = 0.0f;
        }
        else {
            dcvAmbient.dvR = pContext->lighting.dcvAmbient.dvR * pContext->Material.dcvAmbient.dvR + pContext->Material.dcvEmissive.dvR;
            dcvAmbient.dvG = pContext->lighting.dcvAmbient.dvG * pContext->Material.dcvAmbient.dvG + pContext->Material.dcvEmissive.dvG;
            dcvAmbient.dvB = pContext->lighting.dcvAmbient.dvB * pContext->Material.dcvAmbient.dvB + pContext->Material.dcvEmissive.dvB;
            dcvEmissive.dvR = 0.0f;
            dcvEmissive.dvG = 0.0f;
            dcvEmissive.dvB = 0.0f;
        }

        pContext->hwState.celsius.set (NV056_SET_COLOR_MATERIAL, dwColorMaterialArgs);

        pContext->hwState.celsius.set3f (NV056_SET_SCENE_AMBIENT_COLOR(0), dcvAmbient.dvR,  dcvAmbient.dvG,  dcvAmbient.dvB);
        pContext->hwState.celsius.set3f (NV056_SET_MATERIAL_EMISSION(0),   dcvEmissive.dvR, dcvEmissive.dvG, dcvEmissive.dvB);

        pContext->hwState.celsius.setf  (NV056_SET_MATERIAL_ALPHA,         pContext->Material.diffuse.a);

        // Set the eye position and direction
        eyeDirection = vectorZero;
        eyeDirection.dvZ = -1.0f;

    #ifdef CELSIUS_TEX_MATRIX_HACK
        dwHackMask = pContext->hwState.dwStateFlags & (CELSIUS_FLAG_TEXMATRIXHACK(0) | CELSIUS_FLAG_TEXMATRIXHACK(1));
        // the hack can't be enabled for both stages simultaneously
        nvAssert (dwHackMask != (CELSIUS_FLAG_TEXMATRIXHACK(0) | CELSIUS_FLAG_TEXMATRIXHACK(1)));

        if (dwHackMask) {
            dwHWStage  = (dwHackMask & CELSIUS_FLAG_TEXMATRIXHACK(0)) ? 0 : 1;
            dwD3DStage = pContext->hwState.dwTexUnitToTexStageMapping[dwHWStage];
            pTexMatrix = &(pContext->tssState[dwD3DStage].mTexTransformMatrix);
            XformBy4x3 (&tmp, &eyeDirection, 0.f, pTexMatrix);
            NormalizeVector3 (&tmp);
            eyeDirection = tmp;
        }
    #endif  // CELSIUS_TEX_MATRIX_HACK

        // Download transform and lighting methods. Pack lights and send them

        dwMask = 0;
        dwLightNum = 0;

        for (pLight=pContext->lighting.pActiveLights; pLight!=NULL; pLight=pLight->pNext) {

            if (dwLightNum == 8) break; // too many

            pLight7 = &(pLight->Light7);
            dbgDisplayLight (pLight7);

            switch (pLight7->dltType) {

                case D3DLIGHT_POINT:
                    dwMask |= NV056_SET_LIGHT_ENABLE_MASK_LIGHT0_LOCAL << (dwLightNum << 1);

                    nvCelsiusDumpLightColors (pContext, dwLightNum, pLight7, dwColorMaterialArgs, bSpecularNeeded);
                    pContext->hwState.celsius.setf (NV056_SET_LIGHT_LOCAL_RANGE(dwLightNum), pLight7->dvRange);
                    nvCelsiusDumpLocalLightData (pContext, dwLightNum, pLight7);

                    break;

                case D3DLIGHT_SPOT:
                    dwMask |= NV056_SET_LIGHT_ENABLE_MASK_LIGHT0_SPOT << (dwLightNum << 1);

                    nvCelsiusDumpLightColors (pContext, dwLightNum, pLight7, dwColorMaterialArgs, bSpecularNeeded);
                    pContext->hwState.celsius.setf (NV056_SET_LIGHT_LOCAL_RANGE(dwLightNum), pLight7->dvRange);
                    nvCelsiusDumpLocalLightData (pContext, dwLightNum, pLight7);

                    // Transform the spotlight direction vector back
                    XformBy4x3 (&dir, &(pLight->direction), 0.f, &(pContext->xfmView));
                    // unless the view matrix has non-uniform scales in it, this is not necessary
                    // For now, we take the easy way out though.
                    NormalizeVector3 (&dir);

    #ifdef CELSIUS_TEX_MATRIX_HACK
                    if (dwHackMask) {
                        XformBy4x3 (&tmp, &dir, 0.f, pTexMatrix);
                        NormalizeVector3 (&tmp);
                        dir = tmp;
                    }
    #endif  // CELSIUS_TEX_MATRIX_HACK

                    ScaleVector3 (&dir, &dir, pLight->dvScale);
                    pContext->hwState.celsius.set3f (NV056_SET_LIGHT_SPOT_FALLOFF(dwLightNum,0),
                                                  pLight->falloffParams.L,
                                                  pLight->falloffParams.M,
                                                  pLight->falloffParams.N);
                    pContext->hwState.celsius.set4f (NV056_SET_LIGHT_SPOT_DIRECTION(dwLightNum,0),
                                                  dir.dvX, dir.dvY, dir.dvZ, pLight->dvW);

                    break;

                case D3DLIGHT_DIRECTIONAL:
                    dwMask |= NV056_SET_LIGHT_ENABLE_MASK_LIGHT0_INFINITE << (dwLightNum << 1);

                    nvCelsiusDumpLightColors (pContext, dwLightNum, pLight7, dwColorMaterialArgs, bSpecularNeeded);
                    pContext->hwState.celsius.setf (NV056_SET_LIGHT_LOCAL_RANGE(dwLightNum), 1e30f);

                    // Transform the spotlight direction vector back
                    XformBy4x3 (&dir, &(pLight->direction), 0.f, &(pContext->xfmView));
                    // unless the view matrix has non-uniform scales in it, this is not necessary
                    // For now, we take the easy way out though.
                    NormalizeVector3 (&dir);

    #ifdef CELSIUS_TEX_MATRIX_HACK
                    if (dwHackMask) {
                        XformBy4x3 (&tmp, &dir, 0.f, pTexMatrix);
                        NormalizeVector3 (&tmp);
                        dir = tmp;
                    }
    #endif  // CELSIUS_TEX_MATRIX_HACK

                    AddVectors3 (&hv, &dir, &eyeDirection);
                    NormalizeVector3 (&hv);
                    pContext->hwState.celsius.set3f (NV056_SET_LIGHT_INFINITE_HALF_VECTOR(dwLightNum,0), hv.dvX, hv.dvY, hv.dvZ);
                    pContext->hwState.celsius.set3f (NV056_SET_LIGHT_INFINITE_DIRECTION(dwLightNum,0),   dir.dvX, dir.dvY, dir.dvZ);

#ifdef STATE_CULL
                    // infinite half-vector stomps on attenuation and vice-versa
                    pContext->hwState.celsius.valid [NV056_SET_LIGHT_LOCAL_ATTENUATION(dwLightNum,0) >> 2] = 0;
#endif

                    break;

                default:
                    DPF ("unknown light type in nvSetCelsiusLights");
                    dbgD3DError();
                    break;

            } // switch

            dwLightNum++;

        } // for all lights

        // Tell HW which lights are active
        pContext->hwState.celsius.set (NV056_SET_LIGHT_ENABLE_MASK, dwMask);

    }

    pContext->hwState.SuperTri.setNumLights(dwLightNum);

    if ((pContext->hwState.dwStateFlags & CELSIUS_FLAG_LIGHTINGNEEDSINVMV) != dwInvMVNeeded) {
        pContext->hwState.dwStateFlags &= ~CELSIUS_FLAG_LIGHTINGNEEDSINVMV;
        pContext->hwState.dwStateFlags |= dwInvMVNeeded;
        pContext->hwState.dwDirtyFlags |= dwInvMVNeeded ? CELSIUS_DIRTY_TRANSFORM : 0;
    }

    // disable lights after setting them up (i.e minimum impact)
#ifdef NV_NULL_LIGHTS_DRIVER
    pContext->hwState.celsius.set (NV056_SET_SPECULAR_ENABLE, DRF_NUM(056, _SET_SPECULAR_ENABLE, _V, FALSE));
    pContext->hwState.celsius.set (NV056_SET_LIGHTING_ENABLE, NV056_SET_LIGHTING_ENABLE_V_FALSE);
#endif

    return (D3D_OK);
}

//---------------------------------------------------------------------------

// set geometric transformation matrices

HRESULT nvSetCelsiusTransform (PNVD3DCONTEXT pContext)
{
    D3DMATRIX        mMV0, mMV1, mCTM, mInvMV, mTemp;
    DWORD            dwClipH, dwClipV;
    float            fm11, fm22, fm33, fm41, fm42, fm43, fm44;
    float            fxTrans, fyTrans;
    D3DVALUE         dvClip0, dvClip1;
    pSurfaceViewport pViewport;
#ifdef CELSIUS_TEX_MATRIX_HACK
    LPD3DMATRIX      pTexMatrix;
    D3DMATRIX        mTexMatrixInv;
    DWORD            dwHackMask;
#endif

    if (pContext->pZetaBuffer && !pContext->dwEarlyCopyStrategy)
    {
        CNvObject *pNvObj = pContext->pZetaBuffer->getWrapper();
        if (pNvObj->hasCTEnabled())
        {
            if ((pContext->dwRenderState[D3DRENDERSTATE_ZENABLE]      != D3DZB_TRUE)
             || (pContext->dwRenderState[D3DRENDERSTATE_ZWRITEENABLE] != TRUE))
            {
                pNvObj->tagCTZE();
            }
        }
    }

    pContext->hwState.dwDirtyFlags &= ~CELSIUS_DIRTY_TRANSFORM;

    pViewport = &(pContext->surfaceViewport);

    if (pContext->hwState.dwStateFlags & CELSIUS_FLAG_PASSTHROUGHMODE) {

        // set up the model view for passthru

        if ((pContext->hwState.celsius.dwZEnable != D3DZB_TRUE) &&
            (!(pContext->hwState.dwStateFlags & CELSIUS_FLAG_ZFOG))) {
            // we have no need for Z. squash it to zero to eliminates the chance
            // of clipping away bogus z's that we see in apps like 3d flipcube
            mPassthruModelViewMatrix._31 = 0.0;
            mPassthruModelViewMatrix._32 = 0.0f;
        }
        else {
            if (getDC()->nvD3DRegistryData.regfZBias) {
                mPassthruModelViewMatrix._31 = pContext->hwState.dvZScale / (1.f + getDC()->nvD3DRegistryData.regfZBias);
                mPassthruModelViewMatrix._32 = getDC()->nvD3DRegistryData.regfZBias * mPassthruModelViewMatrix._31;
            }
            else {
                mPassthruModelViewMatrix._31 = pContext->hwState.dvZScale;
                mPassthruModelViewMatrix._32 = 0.0f;
            }
        }

        if ( ((getDC()->nvD3DRegistryData.regD3DEnableBits1 & D3D_REG_SQUASHW_MASK) == D3D_REG_SQUASHW_ENABLE)
             &&
             ( ((pContext->hwState.dwTextureUnitStatus[0] == CELSIUS_TEXUNITSTATUS_IDLE) &&
                (pContext->hwState.dwTextureUnitStatus[1] == CELSIUS_TEXUNITSTATUS_IDLE))
               ||
               (pContext->dwRenderState[D3DRENDERSTATE_TEXTUREPERSPECTIVE] == FALSE)
             )
           )
        {
            mPassthruModelViewMatrix._41 = 0.0f;
        }

        else {

            if (pContext->hwState.celsius.dwZEnable == D3DZB_USEW) {
                // we are doing w-buffering
                mPassthruModelViewMatrix._41 = pContext->surfaceViewport.dvWFar * pContext->hwState.dvInvZScale;
            }

            else  {
                mPassthruModelViewMatrix._41 = 1.0f;

                // be sensitive to CT
                if (pContext->pZetaBuffer) {
                    CNvObject *pNvObj = pContext->pZetaBuffer->getWrapper();
                    if (pNvObj->hasCTEnabled()) {
                        if (pNvObj->isCTFront()) {
                            mPassthruModelViewMatrix._32  =  0.0f;
                            mPassthruModelViewMatrix._31 *=  0.5f;
                        }
                        else {
                            mPassthruModelViewMatrix._32  =  mPassthruModelViewMatrix._31;
                            mPassthruModelViewMatrix._31 *= -0.5f;
                        }
                    }  // CT enabled
                }  // pZetaBuffer

            }  // !wbuffering

        }  // ! squashing w

        // apply AA scales
        if (pContext->aa.isEnabled()) {
            mPassthruModelViewMatrix._11 = pContext->aa.fWidthAmplifier;
            mPassthruModelViewMatrix._21 = pContext->aa.fHeightAmplifier;
            // The best sample pattern in AA mode is for the samples to be centered over
            // the original sample.  Without the following correction, the new samples would
            // be down and to the right of the old sample.  Here, we offset the samples by 
            // a small amount such that the new samples are fairly well centered over the old
            // sample
            mPassthruModelViewMatrix._12 = CELSIUS_BORDER + 0.5 - 0.5f/pContext->aa.fWidthAmplifier;
            mPassthruModelViewMatrix._22 = CELSIUS_BORDER + 0.5 - 0.5f/pContext->aa.fHeightAmplifier;
        }
        else {
            mPassthruModelViewMatrix._11 = 1.0f;
            mPassthruModelViewMatrix._21 = 1.0f;
            mPassthruModelViewMatrix._12 = CELSIUS_BORDER;
            mPassthruModelViewMatrix._22 = CELSIUS_BORDER;
        }

#ifdef NV_NULL_FILL_DRIVER
        mPassthruModelViewMatrix._11 = 0.0f;
        mPassthruModelViewMatrix._21 = 0.0f;
#endif

        // this uses the 2nd matrix (normally used for skinning)
        pContext->hwState.celsius.setMatrixTransposed (NV056_SET_MODEL_VIEW_MATRIX1(0), &mPassthruModelViewMatrix);

        // set z clipping extents
        // if we're w-buffering in passthru mode, do the best we can to disable the HW's inevitable
        // z clipping because dumb apps may give us bad z's thinking they're unneeded.
        // otherwise, just clip z to the real range of the z-buffer
        dvClip0 = 0.0f;
        dvClip1 = (pContext->hwState.celsius.dwZEnable == D3DZB_USEW) ?
                  CELSIUS_Z_SCALE24 :
                  pContext->hwState.dvZScale;

    }

    else {  // !FVF_TRANSFORMED

        // apply AA scales
        float fx = 1.0f;
        float fy = 1.0f;
        float fdx = 0.0f;
        float fdy = 0.0f;
        if (pContext->aa.isEnabled()) {
            fx = pContext->aa.fWidthAmplifier;
            fy = pContext->aa.fHeightAmplifier;
            fdx = 0.5 - 0.5f/pContext->aa.fWidthAmplifier;
            fdy = 0.5 - 0.5f/pContext->aa.fHeightAmplifier;
        }

        // process viewport dependencies

        fxTrans = (float)(fx * pViewport->clipHorizontal.wX) + CELSIUS_BORDER + fdx;
        fyTrans = (float)(fy * pViewport->clipVertical.wY) + CELSIUS_BORDER + fdy;

        pContext->hwState.celsius.set4f (NV056_SET_VIEWPORT_OFFSET(0), fxTrans, fyTrans, 0.0f, 0.0f);

        // this is based on clipX = -1.0, clipY = 1.0

        fm11 = 0.5f * fx * (float)(pViewport->clipHorizontal.wWidth);
        fm41 = fm11;

        fm22 = -0.5f * fy * (float)(pViewport->clipVertical.wHeight);
        fm42 = -fm22;

        if (pContext->pZetaBuffer && pContext->pZetaBuffer->getWrapper()->hasCTEnabled()) {
            if (pContext->pZetaBuffer->getWrapper()->isCTFront()) {
                // z=0 => z_min/2    z=1 => z_max/2
                fm33 = 0.5f * (pContext->surfaceViewport.dvMaxZ - pContext->surfaceViewport.dvMinZ);
                fm43 = 0.5f * pContext->surfaceViewport.dvMinZ;
            }
            else {
                // z=0 => 1.0-z_min/2    z=1 => 1.0-z_max/2
                fm33 = -0.5f * (pContext->surfaceViewport.dvMaxZ - pContext->surfaceViewport.dvMinZ);
                fm43 = -0.5f * pContext->surfaceViewport.dvMinZ + 1.0f;
            }
        }
        else {
            // z=0 => z_min    z=1 => z_max
            fm33 = pContext->surfaceViewport.dvMaxZ - pContext->surfaceViewport.dvMinZ;
            fm43 = pContext->surfaceViewport.dvMinZ;
        }

        if( fm33 != 0.f ) {
            fm33 *= pContext->hwState.dvZScale;
            fm43 *= pContext->hwState.dvZScale;

            dvClip0 = fm43;         // 0*fm33 + fm43
            dvClip1 = fm33 + fm43;  // 1*fm33 + fm43
        }
        else {
            // MinZ and MaxZ are equal. It appears that the Z clip planes are not
            // inclusive. If dvClip0 == dvClip1 then primtivies are discarded. We should
            // not have Z clipping anyway (the Z transform has collapsed), so just get
            // the z clip planes out of the way.

            dvClip1 = pContext->hwState.dvZScale;
            dvClip0 = 0.f;

            // The Z clip planes can't always be moved out of the way, so muck with the matrix.
            // BUGBUG - this has been tuned to work with the Quake3 sky (w/ OGL wrapper), but
            // this might not work for all apps.
            float fDeltaZ = 0.0000001f;

            if( fm43 > 1.f - fDeltaZ ) {
                fm43 = pContext->hwState.dvZScale * (1.f - fDeltaZ);
            }
            else if( fm43 < fDeltaZ ) {
                fm43 = pContext->hwState.dvZScale * fDeltaZ;
            }
            else {
                fm43 *= pContext->hwState.dvZScale;
            }
        }

        if (pContext->hwState.celsius.dwZEnable == D3DZB_USEW) {
            // we are doing w-buffering  - scale w to optimize use of buffer
            fm44 = pContext->hwState.dvZScale * pContext->surfaceViewport.dvInvWFar;
            // scale x, y, and z similarly to negate the effect of dividing through by a scaled w
            fm11 *= fm44;  fm22 *= fm44;  fm33 *= fm44;
            fm41 *= fm44;  fm42 *= fm44;  fm43 *= fm44;
        }
        else {
            fm44 = 1.0f;
        }

#ifdef NV_NULL_FILL_DRIVER
        fm11 = 0.0f;
        fm22 = 0.0f;
#endif

        mViewportMatrix._11 = fm11;
        mViewportMatrix._22 = fm22;
        mViewportMatrix._33 = fm33;
        mViewportMatrix._41 = fm41;
        mViewportMatrix._42 = fm42;
        mViewportMatrix._43 = fm43;
        mViewportMatrix._44 = fm44;

        // set the 3 Cheops matrices

        // Cheops modelview = D3D world * D3D view
        MatrixProduct4x4 (&mMV0, &(pContext->xfmWorld[0]), &(pContext->xfmView));

#ifdef CELSIUS_TEX_MATRIX_HACK
        dwHackMask = pContext->hwState.dwStateFlags & (CELSIUS_FLAG_TEXMATRIXHACK(0) | CELSIUS_FLAG_TEXMATRIXHACK(1));
        // the hack can't be enabled for both stages simultaneously
        nvAssert (dwHackMask != (CELSIUS_FLAG_TEXMATRIXHACK(0) | CELSIUS_FLAG_TEXMATRIXHACK(1)));

        if (dwHackMask) {
            // cache off the original modelview matrix and redefine eye space to be
            // "texture space" by incorporating the texture transform here.
            DWORD dwHWStage  = (dwHackMask & CELSIUS_FLAG_TEXMATRIXHACK(0)) ? 0 : 1;
            DWORD dwD3DStage = pContext->hwState.dwTexUnitToTexStageMapping[dwHWStage];
            pTexMatrix = &(pContext->tssState[dwD3DStage].mTexTransformMatrix);
            mTemp = mMV0;
            MatrixProduct4x4 (&mMV0, &mTemp, pTexMatrix);
        }
#endif  // CELSIUS_TEX_MATRIX_HACK

        pContext->hwState.celsius.setMatrixTransposed (NV056_SET_MODEL_VIEW_MATRIX0(0), &mMV0);

        pContext->hwState.SuperTri.setEye(&mMV0);

        // Normals are transformed by the transpose of the inverse of the model view matrix.
        // (see Graphics Gems I, p. 541).
        // We only invert the upper 3x3 in order to eliminate the effects of translations.
        // the transposition happens because unlike all other matrices, we DON'T un-transpose
        // this one when we send it to the HW. (this is the one matrix for which D3D's
        // backwardness is convenient)

        if (pContext->hwState.dwStateFlags & (CELSIUS_FLAG_TEXSTATENEEDSINVMV | CELSIUS_FLAG_LIGHTINGNEEDSINVMV)) {
            // there's no reason to waste time normalizing the inverse MV matrix if we're going to have to normalize
            // normals anyway. otherwise, they give us normalized stuff and we need to preserve the normalization
            Inverse4x4 (&mInvMV, &mMV0, (pContext->dwRenderState[D3DRENDERSTATE_NORMALIZENORMALS] == FALSE));
            pContext->hwState.celsius.setInverseModelViewMatrix (NV056_SET_INVERSE_MODEL_VIEW_MATRIX0(0), &mInvMV);
        }

        if (pContext->pCurrentVShader->hasProgram()) {
            // prog pipe
            pContext->hwState.celsius.setMatrixTransposed (NV056_SET_COMPOSITE_MATRIX(0), &mViewportMatrix);
        }

        else if (GET_VERTEXBLEND_STATE(pContext)) {
            // we're skinning
            // compute the second modelview matrix, its inverse, and a distilled composite matrix:
            // cheops composite = projection plus accomodations for the viewport
            MatrixProduct4x4 (&mMV1, &(pContext->xfmWorld[1]), &(pContext->xfmView));
            if (dwHackMask) {
                mTemp = mMV1;
                MatrixProduct4x4 (&mMV1, &mTemp, pTexMatrix);
            }
            pContext->hwState.celsius.setMatrixTransposed (NV056_SET_MODEL_VIEW_MATRIX1(0), &mMV1);
            if (pContext->hwState.dwStateFlags & (CELSIUS_FLAG_TEXSTATENEEDSINVMV | CELSIUS_FLAG_LIGHTINGNEEDSINVMV)) {
                Inverse4x4 (&mInvMV, &mMV1, (pContext->dwRenderState[D3DRENDERSTATE_NORMALIZENORMALS] == FALSE));
                pContext->hwState.celsius.setInverseModelViewMatrix (NV056_SET_INVERSE_MODEL_VIEW_MATRIX1(0), &mInvMV);
            }
            MatrixProduct4x4 (&mCTM, &(pContext->xfmProj), &mViewportMatrix);
            if (dwHackMask) {
                // pre-multiply by the inverted texture matrix to undo the mess
                // we made by introducing it into the modelview matrices above
                Inverse4x4 (&mTexMatrixInv, pTexMatrix, FALSE);
                MatrixProduct4x4 (&mTemp, &mTexMatrixInv, &mCTM);
                mCTM = mTemp;
            }
            pContext->hwState.celsius.setMatrixTransposed (NV056_SET_COMPOSITE_MATRIX(0), &mCTM);
        }

        else {
            // we're not skinning
            // skip the second set of modelview matrices and compute the composite matrix normally:
            // cheops composite = D3D World*View*projection plus accomodations for the viewport
#ifdef CELSIUS_TEX_MATRIX_HACK
            if (dwHackMask) {
                // restore the original MV matrix for the sake of computing the composite matrix
                mMV0 = mTemp;
            }
#endif  // CELSIUS_TEX_MATRIX_HACK
            MatrixProduct4x4 (&mTemp,  &(pContext->xfmProj), &mViewportMatrix);
            MatrixProduct4x4 (&mCTM, &mMV0, &mTemp);
            pContext->hwState.celsius.setMatrixTransposed (NV056_SET_COMPOSITE_MATRIX(0), &mCTM);
            // for supertri we need world*view*proj
            if (pDriverData->nvD3DPerfData.dwPerformanceStrategy & PS_SUPERTRI) {
                MatrixProduct4x4 (&pContext->hwState.mTransform, &mMV0, &(pContext->xfmProj));
            }
        }

        pContext->hwState.celsius.set (NV056_SET_NORMALIZATION_ENABLE,
                                       DRF_NUM(056, _SET_NORMALIZATION_ENABLE, _V, pContext->dwRenderState[D3DRENDERSTATE_NORMALIZENORMALS]));

    }  // !FVF_TRANSFORMED

    // set z clipping
    // note that clips may be reversed because of CT, so we need the min/max functions
    pContext->hwState.celsius.set2f (NV056_SET_CLIP_MIN, min (dvClip0, dvClip1), max (dvClip0, dvClip1));

    // set window clipping
    // we subtract one from xmax (ymax) because the HW clips to xmin <= x <= xmax
    // ie. it's inclusive of the upper limit. note this makes it impossible to clip to nothing
    DWORD x,y,w,h;
    if (pContext->aa.isEnabled()) {
        float s;
        s = pContext->aa.fWidthAmplifier;
        x = DWORD(0.5f + pViewport->clipHorizontal.wX * s);
        //No one remembers the why of this (below) and we think its bogus
        //but leaving this alternative here commented just in case this is
        //revisited
        //w = DWORD(pViewport->clipHorizontal.wWidth * s + s - 1);
        w = DWORD(pViewport->clipHorizontal.wWidth * s );

        s = pContext->aa.fHeightAmplifier;
        y = DWORD(0.5f + pViewport->clipVertical.wY * s);
        //why??? h = DWORD(pViewport->clipVertical.wHeight * s + s - 1);
        h = DWORD(pViewport->clipVertical.wHeight * s );
    }
    else {
        x = pViewport->clipHorizontal.wX;
        w = pViewport->clipHorizontal.wWidth;
        y = pViewport->clipVertical.wY;
        h = pViewport->clipVertical.wHeight;
    }

    dwClipH = DRF_NUM(056, _SET_WINDOW_CLIP_HORIZONTAL, _XMIN,
                      ((x - CELSIUS_VIEWPORT_BOUND) & 0xfff))  |
              DRF_NUM(056, _SET_WINDOW_CLIP_HORIZONTAL, _XMAX,
                      ((x + w - 1 - CELSIUS_VIEWPORT_BOUND) & 0xfff));
    dwClipV = DRF_NUM(056, _SET_WINDOW_CLIP_VERTICAL, _YMIN,
                      ((y - CELSIUS_VIEWPORT_BOUND) & 0xfff))  |
              DRF_NUM(056, _SET_WINDOW_CLIP_VERTICAL, _YMAX,
                      ((y + h - 1 - CELSIUS_VIEWPORT_BOUND) & 0xfff));

    pContext->hwState.celsius.prep_wait_for_idle_nv10();
    pContext->hwState.celsius.set (NV056_SET_WINDOW_CLIP_HORIZONTAL(0), dwClipH);
    pContext->hwState.celsius.set (NV056_SET_WINDOW_CLIP_VERTICAL(0),   dwClipV);

    // BUBUG
    // This fixes a problem with the Billboard SDK app.  It sends down new vertices, and
    // changes the transform state for each primitive it renders, 4 vertices each
    // It seems likely that we should invalidate the cache here, but it seems just
    // as likely that the hardware should take care of this by itself.  Awaiting more
    // info
    nvglSetNv10CelsiusInvalidateVertexCache (NV_DD_CELSIUS);

    return (D3D_OK);
}


//---------------------------------------------------------------------------

// set everything else not covered by other celsius state routines. this includes:
//      - depth testing
//      - stencil testing
//      - alpha testing
//      - alpha blending

HRESULT nvSetCelsiusMiscState (PNVD3DCONTEXT pContext)
{
    DWORD dwMask, dwZBiasRS;
    DWORD dwSrcFactor, dwDstFactor;
    DWORD dwPointSize;
    float fZBias, fZScale;
    float a, t0, t1, t2, t3, t4, t5;  //point size variables
    float fSizeMin,fSizeMax,fSize;
    float aten1,aten2,aten3,fHeight, fScale;

    pContext->hwState.dwDirtyFlags &= ~CELSIUS_DIRTY_MISC_STATE;

    // z-buffering
    if (pContext->hwState.celsius.dwZEnable != D3DZB_FALSE) {
        pContext->hwState.celsius.set (NV056_SET_DEPTH_TEST_ENABLE, NV056_SET_DEPTH_TEST_ENABLE_V_TRUE);
        pContext->hwState.celsius.set (NV056_SET_DEPTH_MASK,        DRF_NUM(056, _SET_DEPTH_MASK, _V, pContext->dwRenderState[D3DRENDERSTATE_ZWRITEENABLE]));
        pContext->hwState.celsius.set (NV056_SET_DEPTH_FUNC,        nv056DepthFunc[CTFunc(pContext,pContext->dwRenderState[D3DRENDERSTATE_ZFUNC])]);
    }
    else {
        pContext->hwState.celsius.set (NV056_SET_DEPTH_TEST_ENABLE, NV056_SET_DEPTH_TEST_ENABLE_V_FALSE);
    }

    // fill mode
    switch (pContext->dwRenderState[D3DRENDERSTATE_FILLMODE]) {
        case D3DFILL_POINT:
            pContext->hwState.celsius.set (NV056_SET_FRONT_POLYGON_MODE, NV056_SET_FRONT_POLYGON_MODE_V_POINT);
            pContext->hwState.celsius.set (NV056_SET_BACK_POLYGON_MODE,  NV056_SET_BACK_POLYGON_MODE_V_POINT);
            break;
        case D3DFILL_WIREFRAME:
            pContext->hwState.celsius.set (NV056_SET_FRONT_POLYGON_MODE, NV056_SET_FRONT_POLYGON_MODE_V_LINE);
            pContext->hwState.celsius.set (NV056_SET_BACK_POLYGON_MODE,  NV056_SET_BACK_POLYGON_MODE_V_LINE);
            break;
        case D3DFILL_SOLID:
            pContext->hwState.celsius.set (NV056_SET_FRONT_POLYGON_MODE, NV056_SET_FRONT_POLYGON_MODE_V_FILL);
            pContext->hwState.celsius.set (NV056_SET_BACK_POLYGON_MODE,  NV056_SET_BACK_POLYGON_MODE_V_FILL);
            break;
        default:
            DPF ("unknown FILLMODE");
            dbgD3DError();
            break;
    }

    // shading
    pContext->hwState.celsius.set (NV056_SET_SHADE_MODE,(pContext->dwRenderState[D3DRENDERSTATE_SHADEMODE] == D3DSHADE_FLAT)
                                                     ? NV056_SET_SHADE_MODE_V_FLAT
                                                     : NV056_SET_SHADE_MODE_V_SMOOTH);

    // color write enable
    DWORD dwPlaneMask = pContext->dwRenderState[D3DRS_COLORWRITEENABLE];
    if (dwPlaneMask == (D3DCOLORWRITEENABLE_ALPHA |
                        D3DCOLORWRITEENABLE_RED   |
                        D3DCOLORWRITEENABLE_GREEN |
                        D3DCOLORWRITEENABLE_BLUE)) {
        // the common case
        dwMask = 0x01010101;
    }
    else {
        dwMask = 0;
        if (dwPlaneMask & D3DCOLORWRITEENABLE_ALPHA) dwMask |= (0x1 << 24);
        if (dwPlaneMask & D3DCOLORWRITEENABLE_RED)   dwMask |= (0x1 << 16);
        if (dwPlaneMask & D3DCOLORWRITEENABLE_GREEN) dwMask |= (0x1 << 8);
        if (dwPlaneMask & D3DCOLORWRITEENABLE_BLUE)  dwMask |= (0x1 << 0);
    }

    pContext->hwState.celsius.set (NV056_SET_COLOR_MASK, dwMask);

    // alpha blending
    if (pContext->dwRenderState[D3DRENDERSTATE_ALPHABLENDENABLE]) {
        pContext->hwState.celsius.set (NV056_SET_BLEND_ENABLE, NV056_SET_BLEND_ENABLE_V_TRUE);
        dwSrcFactor = nv056BlendFunc[pContext->dwRenderState[D3DRENDERSTATE_SRCBLEND]];
        dwDstFactor = nv056BlendFunc[pContext->dwRenderState[D3DRENDERSTATE_DESTBLEND]];
        // for these two cases, we need to go back and override dwDstFactor
        switch (pContext->dwRenderState[D3DRENDERSTATE_SRCBLEND]) {
            case D3DBLEND_BOTHSRCALPHA:    // obsolete, but we'll do it for Dx5 and prior
                dwDstFactor = NV056_SET_BLEND_FUNC_DFACTOR_V_ONE_MINUS_SRC_ALPHA;
                break;
            case D3DBLEND_BOTHINVSRCALPHA: // likewise
                dwDstFactor = NV056_SET_BLEND_FUNC_DFACTOR_V_SRC_ALPHA;
                break;
            default:
                // nada
                break;
        }

        pContext->hwState.celsius.set2 (NV056_SET_BLEND_FUNC_SFACTOR, dwSrcFactor, dwDstFactor);
        pContext->hwState.celsius.set (NV056_SET_BLEND_EQUATION, nv056BlendOp[pContext->dwRenderState[D3DRS_BLENDOP]]);
      }
    else {
        pContext->hwState.celsius.set (NV056_SET_BLEND_ENABLE, NV056_SET_BLEND_ENABLE_V_FALSE);
    }

    // culling
    switch (pContext->dwRenderState[D3DRENDERSTATE_CULLMODE]) {
        case D3DCULL_CW:
            pContext->hwState.celsius.set (NV056_SET_CULL_FACE_ENABLE, NV056_SET_CULL_FACE_ENABLE_V_TRUE);
            pContext->hwState.celsius.set (NV056_SET_FRONT_FACE,       NV056_SET_FRONT_FACE_V_CCW);
            break;
        case D3DCULL_CCW:
            pContext->hwState.celsius.set (NV056_SET_CULL_FACE_ENABLE, NV056_SET_CULL_FACE_ENABLE_V_TRUE);
            pContext->hwState.celsius.set (NV056_SET_FRONT_FACE,       NV056_SET_FRONT_FACE_V_CW);
            break;
        default:
            DPF ("unknown cull mode");
        case D3DCULL_NONE:
            pContext->hwState.celsius.set (NV056_SET_CULL_FACE_ENABLE, NV056_SET_CULL_FACE_ENABLE_V_FALSE);
            break;
    }

    if (pContext->dwRenderState[D3DRENDERSTATE_ALPHATESTENABLE]) {
        pContext->hwState.celsius.set (NV056_SET_ALPHA_TEST_ENABLE, NV056_SET_ALPHA_TEST_ENABLE_V_TRUE);
        pContext->hwState.celsius.set (NV056_SET_ALPHA_REF,         pContext->dwRenderState[D3DRENDERSTATE_ALPHAREF]);
        pContext->hwState.celsius.set (NV056_SET_ALPHA_FUNC,        nv056AlphaFunc[pContext->dwRenderState[D3DRENDERSTATE_ALPHAFUNC]]);
    }
    else {
        pContext->hwState.celsius.set (NV056_SET_ALPHA_TEST_ENABLE, NV056_SET_ALPHA_TEST_ENABLE_V_FALSE);
    }
#ifdef ALPHA_CULL
    // alpha test
#if ALPHA_CULL ==0
    pContext->hwState.alphacull_mode = 0;
    if (!pContext->dwRenderState[D3DRENDERSTATE_ALPHATESTENABLE] && pContext->dwRenderState[D3DRENDERSTATE_ALPHABLENDENABLE] &&
        !pContext->dwRenderState[D3DRENDERSTATE_ZWRITEENABLE] && !pContext->dwRenderState[D3DRENDERSTATE_STENCILENABLE] &&
    pContext->dwEarlyCopyStrategy
       )
    {
#else
    pContext->hwState.alphacull_mode = 0;
    if (!pContext->dwRenderState[D3DRENDERSTATE_ALPHATESTENABLE] && pContext->dwRenderState[D3DRENDERSTATE_ALPHABLENDENABLE] &&
        /*!pContext->dwRenderState[D3DRENDERSTATE_ZWRITEENABLE] &&*/ !pContext->dwRenderState[D3DRENDERSTATE_STENCILENABLE]  &&
    pContext->dwEarlyCopyStrategy
       )
#endif
    {
        pContext->hwState.alphacull_mode = 1;
        if(pContext->dwRenderState[D3DRENDERSTATE_SRCBLEND] == D3DBLEND_SRCALPHA &&
           pContext->dwRenderState[D3DRENDERSTATE_DESTBLEND] == D3DBLEND_INVSRCALPHA){
                pContext->hwState.celsius.set (NV056_SET_ALPHA_TEST_ENABLE, NV056_SET_ALPHA_TEST_ENABLE_V_TRUE);
                pContext->hwState.celsius.set (NV056_SET_ALPHA_REF, 0x8);
                pContext->hwState.celsius.set (NV056_SET_ALPHA_FUNC, NV056_SET_ALPHA_FUNC_V_GREATER);
        }
#if ALPHA_CULL >= 2
        /*else if(pContext->dwRenderState[D3DRENDERSTATE_SRCBLEND] == D3DBLEND_ZERO &&
           pContext->dwRenderState[D3DRENDERSTATE_DESTBLEND] == D3DBLEND_SRCCOLOR &&
           pContext->hwState.dwAlphaICW[0] == 0x18200000 && pContext->hwState.dwAlphaOCW[0] == 0xc00 &&
           pContext->hwState.dwColorICW[0] == 0x08040000 && pContext->hwState.dwColorOCW[0] == 0xc00)
        {
            pContext->hwState.celsius.alphacull_mode = 2;
            pContext->hwState.celsius.set (NV056_SET_COMBINER_COLOR_ICW(0), 0x08042820);
            pContext->hwState.celsius.set (NV056_SET_COMBINER0_COLOR_OCW,   0x000010CD);
            pContext->hwState.celsius.set (NV056_SET_COMBINER_ALPHA_ICW(0), 0x18200000);
            pContext->hwState.celsius.set (NV056_SET_COMBINER_ALPHA_OCW(0), 0x00000C00);
            pContext->hwState.celsius.set (NV056_SET_COMBINER_SPECULAR_FOG_CW0, pContext->hwState.specfog_cw[0]);
            pContext->hwState.celsius.set (NV056_SET_COMBINER_SPECULAR_FOG_CW1, 0x0D00 | (pContext->hwState.specfog_cw[1] & ~0x1f00));
            pContext->hwState.celsius.set (NV056_SET_ALPHA_TEST_ENABLE, NV056_SET_ALPHA_TEST_ENABLE_V_TRUE);
            pContext->hwState.celsius.set (NV056_SET_ALPHA_REF, 0x8);
            pContext->hwState.celsius.set (NV056_SET_ALPHA_FUNC, NV056_SET_ALPHA_FUNC_V_GREATER);
        }*/
#endif
#if ALPHA_CULL >= 3
        else if(pContext->dwRenderState[D3DRENDERSTATE_SRCBLEND] == D3DBLEND_ONE &&
           pContext->dwRenderState[D3DRENDERSTATE_DESTBLEND] == D3DBLEND_ONE &&
           pContext->hwState.dwColorICW[0] == 0x08040000 && pContext->hwState.dwColorOCW[0] == 0xc00 &&
           pContext->hwState.dwAlphaICW[0] == 0x18200000 && pContext->hwState.dwAlphaOCW[0] == 0xc00 &&
           pContext->dwEarlyCopyStrategy == 3)
        {
            pContext->hwState.alphacull_mode = 3;
            pContext->hwState.celsius.set (NV056_SET_COMBINER_COLOR_ICW(0), 0x08040820);
            pContext->hwState.celsius.set (NV056_SET_COMBINER0_COLOR_OCW,   0x000010CD);
            pContext->hwState.celsius.set (NV056_SET_COMBINER_ALPHA_ICW(0), 0x18200000);
            pContext->hwState.celsius.set (NV056_SET_COMBINER_ALPHA_OCW(0), 0x00000C00);
            pContext->hwState.celsius.set (NV056_SET_COMBINER_SPECULAR_FOG_CW0, pContext->hwState.specfog_cw[0]);
            pContext->hwState.celsius.set (NV056_SET_COMBINER_SPECULAR_FOG_CW1, 0x0D00 | (pContext->hwState.specfog_cw[1] & ~0x1f00));
            pContext->hwState.celsius.set (NV056_SET_ALPHA_TEST_ENABLE, NV056_SET_ALPHA_TEST_ENABLE_V_TRUE);
            pContext->hwState.celsius.set (NV056_SET_ALPHA_REF, 0x8);
            pContext->hwState.celsius.set (NV056_SET_ALPHA_FUNC, NV056_SET_ALPHA_FUNC_V_GREATER);
        }
#endif
        else if(pContext->dwRenderState[D3DRENDERSTATE_SRCBLEND] == D3DBLEND_INVSRCALPHA &&
                pContext->dwRenderState[D3DRENDERSTATE_DESTBLEND] == D3DBLEND_SRCALPHA){
                pContext->hwState.celsius.set (NV056_SET_ALPHA_TEST_ENABLE, NV056_SET_ALPHA_TEST_ENABLE_V_TRUE);
                pContext->hwState.celsius.set (NV056_SET_ALPHA_REF, 0xf4);
                pContext->hwState.celsius.set (NV056_SET_ALPHA_FUNC, NV056_SET_ALPHA_FUNC_V_LESS);
        }
        else if(pContext->dwRenderState[D3DRENDERSTATE_SRCBLEND] == D3DBLEND_ZERO){
            if(pContext->dwRenderState[D3DRENDERSTATE_DESTBLEND] == D3DBLEND_SRCALPHA){
                pContext->hwState.celsius.set (NV056_SET_ALPHA_TEST_ENABLE, NV056_SET_ALPHA_TEST_ENABLE_V_TRUE);
                pContext->hwState.celsius.set (NV056_SET_ALPHA_REF, 0xf4);
                pContext->hwState.celsius.set (NV056_SET_ALPHA_FUNC, NV056_SET_ALPHA_FUNC_V_LESS);
            }
            else if(pContext->dwRenderState[D3DRENDERSTATE_DESTBLEND] == D3DBLEND_INVSRCALPHA){
                pContext->hwState.celsius.set (NV056_SET_ALPHA_TEST_ENABLE, NV056_SET_ALPHA_TEST_ENABLE_V_TRUE);
                pContext->hwState.celsius.set (NV056_SET_ALPHA_REF, 0x8);
                pContext->hwState.celsius.set (NV056_SET_ALPHA_FUNC, NV056_SET_ALPHA_FUNC_V_GREATER);
            }
        }
    }
#endif

    //anti aliased edges
    if (getDC()->nvD3DPerfData.dwHaveAALines){
        if (pContext->dwRenderState[D3DRENDERSTATE_EDGEANTIALIAS]){
            pContext->hwState.celsius.set (NV056_SET_BLEND_ENABLE, NV056_SET_LINE_SMOOTH_ENABLE_V_TRUE);
        }
        else {
            pContext->hwState.celsius.set (NV056_SET_LINE_SMOOTH_ENABLE, NV056_SET_LINE_SMOOTH_ENABLE_V_FALSE);
        }
    }

    // dithering
    pContext->hwState.celsius.set (NV056_SET_DITHER_ENABLE, DRF_NUM(056, _SET_DITHER_ENABLE, _V, pContext->dwRenderState[D3DRENDERSTATE_DITHERENABLE]));

    // z bias
    dwZBiasRS = (pContext->dwRenderState[D3DRENDERSTATE_ZBIAS] != 0) ? 1 : 0;
    // switch on an arbitrary identifier
    switch (dwZBiasRS * pContext->hwState.celsius.dwZEnable) {
        case D3DZB_TRUE:
            // renderstate_zbias!=0 and zenable==D3DZB_TRUE.
            // the bias is applied to z values in device coordinates
            // (i.e in the range [0..2^16-1] or [0..2^24-1])
            pContext->hwState.celsius.set (NV056_SET_POLY_OFFSET_POINT_ENABLE, NV056_SET_POLY_OFFSET_POINT_ENABLE_V_TRUE);
            pContext->hwState.celsius.set (NV056_SET_POLY_OFFSET_LINE_ENABLE,  NV056_SET_POLY_OFFSET_LINE_ENABLE_V_TRUE);
            pContext->hwState.celsius.set (NV056_SET_POLY_OFFSET_FILL_ENABLE,  NV056_SET_POLY_OFFSET_FILL_ENABLE_V_TRUE);
            fZBias  = -(float)(pContext->dwRenderState[D3DRENDERSTATE_ZBIAS]);
            fZScale = 0.25f * fZBias;
            pContext->hwState.celsius.set2f (NV056_SET_POLYGON_OFFSET_SCALE_FACTOR, fZScale, fZBias);
            break;
        case D3DZB_USEW:
            // renderstate_zbias!=0 and zenable==D3DZB_USEW
            // D3D would want us to apply the bias to w instead of z, but we can't
            // really do this, so note a setup failure and fall through to disable
            pContext->hwState.dwStateFlags |= CELSIUS_FLAG_SETUPFAILURE;
        case 0:
            // renderstate_zbias==0 and/or zenable==D3DZB_FALSE
            pContext->hwState.celsius.set (NV056_SET_POLY_OFFSET_POINT_ENABLE, NV056_SET_POLY_OFFSET_POINT_ENABLE_V_FALSE);
            pContext->hwState.celsius.set (NV056_SET_POLY_OFFSET_LINE_ENABLE,  NV056_SET_POLY_OFFSET_LINE_ENABLE_V_FALSE);
            pContext->hwState.celsius.set (NV056_SET_POLY_OFFSET_FILL_ENABLE,  NV056_SET_POLY_OFFSET_FILL_ENABLE_V_FALSE);
            break;
        default:
            DPF ("oops. i goofed. got unexpected zbias case");
            dbgD3DError();
            break;
    }

    CNvObject *pNvObj = pContext->pZetaBuffer ? pContext->pZetaBuffer->getWrapper() : NULL;

    if (pNvObj) {
        if (pContext->dwRenderState[D3DRENDERSTATE_STENCILENABLE]) {
            pNvObj->tagAltStencilBadSemantics();
            pNvObj->tagAltStencilDisabled();
        }
    }

    // stencil
    if (pContext->dwRenderState[D3DRENDERSTATE_STENCILENABLE]) {
        pContext->bStencilEnabled = TRUE;
        pContext->hwState.celsius.set (NV056_SET_STENCIL_TEST_ENABLE, NV056_SET_STENCIL_TEST_ENABLE_V_TRUE);
        pContext->hwState.celsius.set (NV056_SET_STENCIL_OP_FAIL,     nv056StencilOp[pContext->dwRenderState[D3DRENDERSTATE_STENCILFAIL]]);
        pContext->hwState.celsius.set (NV056_SET_STENCIL_OP_ZFAIL,    nv056StencilOp[pContext->dwRenderState[D3DRENDERSTATE_STENCILZFAIL]]);
        pContext->hwState.celsius.set (NV056_SET_STENCIL_OP_ZPASS,    nv056StencilOp[pContext->dwRenderState[D3DRENDERSTATE_STENCILPASS]]);
        pContext->hwState.celsius.set (NV056_SET_STENCIL_FUNC,        nv056StencilFunc[pContext->dwRenderState[D3DRENDERSTATE_STENCILFUNC]]);
        pContext->hwState.celsius.set (NV056_SET_STENCIL_FUNC_REF,    pContext->dwRenderState[D3DRENDERSTATE_STENCILREF]       & 0xff);
        pContext->hwState.celsius.set (NV056_SET_STENCIL_FUNC_MASK,   pContext->dwRenderState[D3DRENDERSTATE_STENCILMASK]      & 0xff);
        pContext->hwState.celsius.set (NV056_SET_STENCIL_MASK,        pContext->dwRenderState[D3DRENDERSTATE_STENCILWRITEMASK] & 0xff);
    }
    else if (pNvObj && pNvObj->isAltStencilEnabled()) {
        // Do nothing; stencil is set elsewhere
    } else {
        pContext->hwState.celsius.set (NV056_SET_STENCIL_TEST_ENABLE, NV056_SET_STENCIL_TEST_ENABLE_V_FALSE);
    }

    // combiner factor
    pContext->hwState.celsius.set (NV056_SET_COMBINE_FACTOR(0), pContext->dwRenderState[D3DRENDERSTATE_TEXTUREFACTOR]);
    pContext->hwState.celsius.set (NV056_SET_COMBINE_FACTOR(1), pContext->dwRenderState[D3DRENDERSTATE_TEXTUREFACTOR]);

    // skinning
    pContext->hwState.celsius.set (NV056_SET_SKIN_ENABLE,(GET_VERTEXBLEND_STATE(pContext) ?
                                                       DRF_DEF(056, _SET_SKIN_ENABLE, _V, _TRUE) :
                                                       DRF_DEF(056, _SET_SKIN_ENABLE, _V, _FALSE)));

    // line and point sizes for AA
    if (pContext->aa.isEnabled()) {
        pContext->hwState.celsius.set (NV056_SET_LINE_WIDTH, pContext->aa.dwLinePointSize);
        pContext->hwState.celsius.set (NV056_SET_POINT_SIZE, pContext->aa.dwLinePointSize);
    }
    else {
        pContext->hwState.celsius.set (NV056_SET_LINE_WIDTH, 0x00000008);  // 6.3 format
        pContext->hwState.celsius.set (NV056_SET_POINT_SIZE, 0x00000008);  // 6.3 format
    }

    // Only do the pt. size renderstate if app is dx8 app.
    if (pContext->dwDXAppVersion >= 0x800)
    {

        fSizeMin = FLOAT_FROM_DWORD (pContext->dwRenderState[D3DRS_POINTSIZE_MIN]);
        fSizeMax = FLOAT_FROM_DWORD (pContext->dwRenderState[D3DRS_POINTSIZE_MAX]);
        fSize    = FLOAT_FROM_DWORD (pContext->dwRenderState[D3DRS_POINTSIZE]);
        fScale = fSize;
        aten1    = FLOAT_FROM_DWORD (pContext->dwRenderState[D3DRS_POINTSCALE_A]);
        aten2    = FLOAT_FROM_DWORD (pContext->dwRenderState[D3DRS_POINTSCALE_B]);
        aten3    = FLOAT_FROM_DWORD (pContext->dwRenderState[D3DRS_POINTSCALE_C]);
        if (fScale <= 0.0f) fScale = 0.0001f;
        if (fSizeMin <= 0.0f) fSizeMin =  0.0001f;   //watch out for divide by zero....
        if (fSizeMin > 63.869f) fSizeMin = 63.869f;   //watch out for divide by zero....
        if (fSizeMax > 63.870f) fSizeMax = 63.870f;
        if (fSizeMax < 0.0f) fSizeMax = 0.0f;
        //if (pContext->dwRenderState[D3DRS_POINTSCALEENABLE]) fSize *= pContext->surfaceViewport.clipVertical.wHeight;
        if (fSize > fSizeMax ) fSize = fSizeMax;
        if (fSize < fSizeMin ) fSize = fSizeMin;
        t3 = fSizeMax - fSizeMin;
        if (t3) t4 = -fSizeMin / t3;
        t5 = fSizeMin;

        fHeight = 1;
        if ( pContext->surfaceViewport.clipVertical.wHeight &&
             pContext->dwRenderState[D3DRS_POINTSCALEENABLE])
        {
            fHeight = (float)(pContext->surfaceViewport.clipVertical.wHeight);
            //have to do this loop if we want to move height into the attenuation
            //factors because valid point sprite sizes < 0.125 will be expressed
            //as zeros if we don't do something  HMH
            while (fSize < 32.0f && fHeight > 2.0f)
            {
                fSize *= 2;
                fScale *= 2;
                fHeight *= 0.5f;
            }
        }

        a = (t3 / fScale) * (t3 / fScale) * (1.0f / (fHeight * fHeight) );

        t0 = aten1 * a;
        t1 = aten2 * a;
        t2 = aten3 * a;

        dwPointSize = ((DWORD)(fSize * 8.0f)) & 0x1ff;  // convert to 6.3

        pContext->hwState.celsius.set3f (NV056_SET_POINT_PARAMS(0), t0,t1,t2);
        pContext->hwState.celsius.set3f (NV056_SET_POINT_PARAMS(3), t3,t3,t3);
        pContext->hwState.celsius.setf (NV056_SET_POINT_PARAMS(6), t4);
        pContext->hwState.celsius.setf (NV056_SET_POINT_PARAMS(7), t5);
        pContext->hwState.celsius.set (NV056_SET_POINT_SIZE, dwPointSize);  // 6.3 format
        pContext->hwState.celsius.set (NV056_SET_POINT_PARAMS_ENABLE, pContext->dwRenderState[D3DRS_POINTSCALEENABLE] ?
                                                                   NV056_SET_POINT_PARAMS_ENABLE_V_TRUE :
                                                                   NV056_SET_POINT_PARAMS_ENABLE_V_FALSE);
        pContext->hwState.celsius.set (NV056_SET_POINT_SMOOTH_ENABLE, pContext->dwRenderState[D3DRS_POINTSPRITEENABLE] ?
                                                                   NV056_SET_POINT_SMOOTH_ENABLE_V_TRUE:
                                                                   NV056_SET_POINT_SMOOTH_ENABLE_V_FALSE);


    }

    return (D3D_OK);
}

//---------------------------------------------------------------------------

// This handles the SetControl0 method:
//      premultiplied alpha
//      texture perspective
//      z perspective
//      z format
//      alpha kill mode
//      stencil write enable

HRESULT nvSetCelsiusControl0 (PNVD3DCONTEXT pContext)
{
    DWORD dwMask = 0;

    pContext->hwState.dwDirtyFlags &= ~CELSIUS_DIRTY_CONTROL0;

    // SRWNOTE: D3D has the possibility of having pre-multiplied alpha in 1
    // texture stage and not in another stage. How do we handle this?
    // hmm... actually this seems to be specified on a per surface basis
    // hedge on this for now
// BUGBUG
#if 0
    if (statev.premultipliedalpha)
        dwMask |= DRF_DEF(056, _SET_CONTROL0, _PREMULTIPLIEDALPHA, _TRUE);
    else
        dwMask |= DRF_DEF(056, _SET_CONTROL0, _PREMULTIPLIEDALPHA, _FALSE);
#endif

#ifdef CELSIUS_ENABLE_BAD_PERSPECTIVE
    // this method is horribly named. setting it to false forces w to 1.0 in primitive assembly
    // which actually has almost nothing to do with texture perspective, because the w-divide that
    // perspectively corrects textures has already been done in the transform unit.
    // the only things actually affected are those downstream of primitive assembly:
    // - perspectively correct color interpolation
    // - w-clipping
    // this should not ever be disabled in T&L mode because of the latter!
    dwMask |= (pContext->hwState.dwStateFlags & CELSIUS_FLAG_PASSTHROUGHMODE) ?
              DRF_NUM(056, _SET_CONTROL0, _TEXTUREPERSPECTIVE, pContext->dwRenderState[D3DRENDERSTATE_TEXTUREPERSPECTIVE]) :
              DRF_DEF(056, _SET_CONTROL0, _TEXTUREPERSPECTIVE, _TRUE);
#else
    dwMask |= DRF_DEF(056, _SET_CONTROL0, _TEXTUREPERSPECTIVE, _TRUE);
#endif

    // w or z buffering
    dwMask |= DRF_NUM(056, _SET_CONTROL0, _Z_PERSPECTIVE_ENABLE, (DWORD)(pContext->hwState.celsius.dwZEnable == D3DZB_USEW));

    // D3D has no provision for specification of zbuffer format
    // somewhat arbitrarily choose FIXED. alternately we could select it
    // to their advantage according to whether w-buffering is enabled (?)
    dwMask |= DRF_DEF(056, _SET_CONTROL0, _Z_FORMAT, _FIXED);

    if (pContext->hwState.celsius.dwZEnable == D3DZB_USEW) {
        if (pContext->hwState.dwStateFlags & CELSIUS_FLAG_WSOURCE(0)) {
            // pull w-buffer values from texture unit 0
            dwMask |= DRF_DEF(056, _SET_CONTROL0, _WBUFFER_SELECT, _0);
        }
        else if (pContext->hwState.dwStateFlags & CELSIUS_FLAG_WSOURCE(1)) {
            // pull w-buffer values from texture unit 1
            dwMask |= DRF_DEF(056, _SET_CONTROL0, _WBUFFER_SELECT, _1);
        }
        else {
            // w-buffering with no available w value
            nvAssert(0);
        }
    }
    else {
        // disable w-buffering
        dwMask |= DRF_DEF(056, _SET_CONTROL0, _WBUFFER_SELECT, _0);
    }

    CNvObject *pNvObj = pContext->pZetaBuffer ? pContext->pZetaBuffer->getWrapper() : NULL;

    dwMask |= (pContext->dwRenderState[D3DRENDERSTATE_STENCILENABLE] || (pNvObj && pNvObj->isAltStencilEnabled())) ?
        DRF_DEF(056, _SET_CONTROL0, _STENCIL_WRITE_ENABLE, _TRUE) :
        DRF_DEF(056, _SET_CONTROL0, _STENCIL_WRITE_ENABLE, _FALSE);

    pContext->hwState.celsius.set (NV056_SET_CONTROL0, dwMask);

    return (D3D_OK);
}

//---------------------------------------------------------------------------

// returns the size (in 4-byte words) of an inlined vertex

DWORD nvCelsiusInlineVertexStride (PNVD3DCONTEXT pContext)
{
    CVertexShader *pShader;
    DWORD          dwStride;

    pShader = pContext->pCurrentVShader;

    dwStride  = 0;
    dwStride += pShader->bVAExists (defaultInputRegMap[D3DVSDE_BLENDWEIGHT]) ? sizeof(DWORD) : 0;
    dwStride += pShader->getVASize (defaultInputRegMap[D3DVSDE_NORMAL]);

    if (pContext->hwState.dwStateFlags & CELSIUS_FLAG_USERTEXCOORDSNEEDED(1)) {
        DWORD dwD3DStage = pContext->hwState.dwTexUnitToTexStageMapping[1];
        nvAssert (dwD3DStage != CELSIUS_UNUSED);
        DWORD dwTCIndex  = (pContext->hwState.dwTexCoordIndices >> 16) & 0xffff;
        DWORD dwVAIndex  = defaultInputRegMap[D3DVSDE_TEXCOORD0+dwTCIndex];
        nvAssert (pShader->bVAExists (dwVAIndex));  // they better have given us coordinates
        DWORD n = (pContext->hwState.dwStateFlags & (CELSIUS_FLAG_PASSTHROUGHCUBEMAPPING(1) | CELSIUS_FLAG_TEXMATRIXSWFIX(1))) ?
                  4*sizeof(DWORD) : pShader->getVASize (dwVAIndex);
        dwStride += n;
    }
    if (pContext->hwState.dwStateFlags & CELSIUS_FLAG_USERTEXCOORDSNEEDED(0)) {
        DWORD dwD3DStage = pContext->hwState.dwTexUnitToTexStageMapping[0];
        nvAssert (dwD3DStage != CELSIUS_UNUSED);
        DWORD dwTCIndex  = (pContext->hwState.dwTexCoordIndices >>  0) & 0xffff;
        DWORD dwVAIndex  = defaultInputRegMap[D3DVSDE_TEXCOORD0+dwTCIndex];
        nvAssert (pShader->bVAExists (dwVAIndex));  // they better have given us coordinates
        DWORD n = (pContext->hwState.dwStateFlags & (CELSIUS_FLAG_PASSTHROUGHCUBEMAPPING(0) | CELSIUS_FLAG_TEXMATRIXSWFIX(0))) ?
                  4*sizeof(DWORD) : pShader->getVASize (dwVAIndex);
        dwStride += n;
    }

    dwStride += pShader->getVASize (defaultInputRegMap[D3DVSDE_SPECULAR]);
    dwStride += pShader->getVASize (defaultInputRegMap[D3DVSDE_DIFFUSE]);
    dwStride += pShader->getVASize (defaultInputRegMap[D3DVSDE_POSITION]);

    //don't actually add in point size because we we remove it in the inner loop HMH
    //    dwStride += (fvfData.dwPointSizeMask ? 1 : 0);

    return (dwStride >> 2);
}

//---------------------------------------------------------------------------

// set sources and offsets of various vertex components.

HRESULT nvSetCelsiusVertexFormat (PNVD3DCONTEXT pContext)
{
    DWORD   dwFormat[7], dwD3DStage, dwTexCount;
    DWORD   dwTCIndex, dwVAIndex;
    DWORD   dwVertexBufferOffset;
    DWORD   dwFormatShadow = 0;
    DWORD   dwStreamSelector;
    BOOL    bInlineVertices, bTess;
    DWORD   dwInlineStride, dwStride;
    DWORD   dwOffsetAdjustment;

    // clear dirty flag
    pContext->hwState.dwDirtyFlags &= ~CELSIUS_DIRTY_FVF;

    // calculate a tessellator style FVF format
    bTess = pContext->hwState.dwStateFlags & CELSIUS_FLAG_COMPUTE_TESS_VTX_STRIDE;

    CVertexShader  *pShader   = pContext->pCurrentVShader;
    CVertexBuffer **ppStreams = pContext->ppDX8Streams;

    // shadow the values so we know what we last sent to the HW
    pContext->hwState.dwVertexOffset = pContext->dp2.dwVertexBufferOffset;
    pContext->hwState.pVertexShader  = pContext->pCurrentVShader;
    nvMemCopy (pContext->hwState.ppStreams, pContext->ppDX8Streams, CELSIUS_CAPS_MAX_STREAMS*sizeof(CVertexBuffer *));

    // find the stream containing geometry
    dwStreamSelector = pShader->getVAStream (defaultInputRegMap[D3DVSDE_POSITION]);
    if ((dwStreamSelector == CVertexShader::VA_STREAM_NONE) || (ppStreams[dwStreamSelector] == NULL)) {
        // we don't have vertex data yet (happens if called via validateTSS())
        return (TRUE);
    }

#ifdef STOMP_TEX_COORDS
    pContext->hwState.dwStateFlags &= ~CELSIUS_FLAG_STOMP_4TH_COORD_MASK;

    if (!pShader->hasProgram()) {
        for (DWORD dwHWStage=0; dwHWStage < CELSIUS_NUM_TEXTURES; dwHWStage++) {
            if (pContext->hwState.dwStateFlags & CELSIUS_FLAG_USERTEXCOORDSNEEDED(dwHWStage)) {
                dwTCIndex  = (pContext->hwState.dwTexCoordIndices >> (16*dwHWStage)) & 0xffff;
                if ((pShader->getVASize(defaultInputRegMap[D3DVSDE_TEXCOORD0+dwTCIndex]) == 16) &&
                    (CELSIUS_GET_NUM_TEX_COORDS(pContext->hwState.dwNumTexCoordsNeeded, dwHWStage) < 4)) {
                    pContext->hwState.dwStateFlags |= CELSIUS_FLAG_STOMP_4TH_COORD(dwHWStage);
                }
            }
        }
    }

    // This should only happen in WHQL.  If it's happening elsewhere, either the app
    // is really stupid, or we're doing something wrong.
    nvAssert(!(pContext->hwState.dwStateFlags & CELSIUS_FLAG_STOMP_4TH_COORD_MASK));
#endif  // STOMP_TEX_COORDS

    // figure out if we need to inline this vertex data
    bInlineVertices = (NV_NUM_UNIQUE_STREAMS(pContext->dwStreamDMACount) > 1)
                      ||
                      (NV_NUM_SYSTEM_STREAMS(pContext->dwStreamDMACount) > 0)
                      ||
                      (pShader->hasProgram())
                      ||
                      (pShader->bVAExists(defaultInputRegMap[D3DVSDE_PSIZE]))
                      ||
#ifdef STOMP_TEX_COORDS
                      (pContext->hwState.dwStateFlags & (CELSIUS_FLAG_PASSTHROUGHCUBEMAPPING(0) |
                                                         CELSIUS_FLAG_PASSTHROUGHCUBEMAPPING(1) |
                                                         CELSIUS_FLAG_TEXMATRIXSWFIX(0)         |
                                                         CELSIUS_FLAG_TEXMATRIXSWFIX(1)         |
                                                         CELSIUS_FLAG_STOMP_4TH_COORD(0)        |
                                                         CELSIUS_FLAG_STOMP_4TH_COORD(1)));
#else  // !STOMP_TEX_COORDS
                      (pContext->hwState.dwStateFlags & (CELSIUS_FLAG_PASSTHROUGHCUBEMAPPING(0) |
                                                         CELSIUS_FLAG_PASSTHROUGHCUBEMAPPING(1) |
                                                         CELSIUS_FLAG_TEXMATRIXSWFIX(0)         |
                                                         CELSIUS_FLAG_TEXMATRIXSWFIX(1)));
#endif  // !STOMP_TEX_COORDS

    #ifdef FORCE_INLINE_VERTICES
        bInlineVertices = TRUE;
    #endif

    if (bInlineVertices) {
        dwInlineStride = nvCelsiusInlineVertexStride(pContext) << 2;
        pContext->hwState.dwInlineVertexStride = dwInlineStride;
    }
    else {
        pContext->hwState.dwInlineVertexStride = 0;
    }

    // note: dwFormatShadow is a hideous hack. basically, the hardware fails to write out
    // and restore vertex formats (actually just the sizes contained therein) correctly
    // upon context switches, so we store the information redundantly in some dead space
    // (the last element of the fourth row of the second inverse model view matrix).
    // From there, the RM can grab them and reset things properly after a context switch.

    // x, y, z, [w]
    dwStreamSelector = pShader->getVAStream (defaultInputRegMap[D3DVSDE_POSITION]);
    dwStride = bInlineVertices ? dwInlineStride : ppStreams[dwStreamSelector]->getVertexStride();
    if (pShader->getVASize(defaultInputRegMap[D3DVSDE_POSITION]) == 4*sizeof(DWORD)) {
        // w present
        dwFormat[0] = DRF_DEF(056, _SET_VERTEX_ARRAY_FORMAT, _SIZE, _4) |
                      DRF_DEF(056, _SET_VERTEX_ARRAY_FORMAT, _W, _PRESENT) |
                      DRF_DEF(056, _SET_VERTEX_ARRAY_FORMAT, _TYPE, _FLOAT) |
                      DRF_NUM(056, _SET_VERTEX_ARRAY_FORMAT, _STRIDE, dwStride);
        dwFormatShadow |= (NV056_SET_VERTEX_ARRAY_FORMAT_SIZE_4 << 0);
    }
    else {
        // x,y,z only
        dwFormat[0] = DRF_DEF(056, _SET_VERTEX_ARRAY_FORMAT, _SIZE, _3) |
                      DRF_DEF(056, _SET_VERTEX_ARRAY_FORMAT, _W, _NONE) |
                      DRF_DEF(056, _SET_VERTEX_ARRAY_FORMAT, _TYPE, _FLOAT) |
                      DRF_NUM(056, _SET_VERTEX_ARRAY_FORMAT, _STRIDE, dwStride);
        dwFormatShadow |= (NV056_SET_VERTEX_ARRAY_FORMAT_SIZE_3 << 0);
    }

    // diffuse array
    dwStreamSelector = pShader->getVAStream (defaultInputRegMap[D3DVSDE_DIFFUSE]);
    if ((dwStreamSelector != CVertexShader::VA_STREAM_NONE) && (ppStreams[dwStreamSelector])) {
        dwStride = bInlineVertices ? dwInlineStride : ppStreams[dwStreamSelector]->getVertexStride();
        dwFormat[1]  = DRF_DEF(056, _SET_DIFFUSE_ARRAY_FORMAT, _SIZE, _4) |
                       DRF_NUM(056, _SET_DIFFUSE_ARRAY_FORMAT, _STRIDE, dwStride);
        dwFormat[1] |= bTess?
                       DRF_DEF(056, _SET_DIFFUSE_ARRAY_FORMAT, _TYPE, _FLOAT) :
                       DRF_DEF(056, _SET_DIFFUSE_ARRAY_FORMAT, _TYPE, _UNSIGNED_BYTE_BGRA);
        dwFormatShadow |= (NV056_SET_DIFFUSE_ARRAY_FORMAT_SIZE_4 << 4);
    }
    else {
#ifdef STATE_CULL
        pContext->hwState.celsius.valid [NV056_SET_DIFFUSE_COLOR4UB >> 2] = 0;
#endif
        pContext->hwState.celsius.set (NV056_SET_DIFFUSE_COLOR4UB, 0xFFFFFFFF); // default to white
        dwFormat[1] = DRF_DEF(056, _SET_DIFFUSE_ARRAY_FORMAT, _SIZE, _0) |
                      DRF_DEF(056, _SET_DIFFUSE_ARRAY_FORMAT, _TYPE, _UNSIGNED_BYTE_BGRA);
        dwFormatShadow |= (NV056_SET_DIFFUSE_ARRAY_FORMAT_SIZE_0 << 4);
    }

    // specular array
    dwStreamSelector = pShader->getVAStream (defaultInputRegMap[D3DVSDE_SPECULAR]);
    if ((dwStreamSelector != CVertexShader::VA_STREAM_NONE) && (ppStreams[dwStreamSelector])) {
        dwStride = bInlineVertices ? dwInlineStride : ppStreams[dwStreamSelector]->getVertexStride();
        dwFormat[2]  = DRF_DEF(056, _SET_SPECULAR_ARRAY_FORMAT, _SIZE, _4) |
                       DRF_NUM(056, _SET_SPECULAR_ARRAY_FORMAT, _STRIDE, dwStride);
        dwFormat[2] |= bTess ?
                       DRF_DEF(056, _SET_SPECULAR_ARRAY_FORMAT, _TYPE, _FLOAT) :
                       DRF_DEF(056, _SET_SPECULAR_ARRAY_FORMAT, _TYPE, _UNSIGNED_BYTE_BGRA);
        dwFormatShadow |= (NV056_SET_SPECULAR_ARRAY_FORMAT_SIZE_4 << 8);
    }
    else {
#ifdef STATE_CULL
        pContext->hwState.celsius.valid [NV056_SET_SPECULAR_COLOR4UB >> 2] = 0;
#endif
        pContext->hwState.celsius.set (NV056_SET_SPECULAR_COLOR4UB, 0); // default to black
        dwFormat[2] = DRF_DEF(056, _SET_SPECULAR_ARRAY_FORMAT, _SIZE, _0) |
                      DRF_DEF(056, _SET_SPECULAR_ARRAY_FORMAT, _TYPE, _UNSIGNED_BYTE_BGRA);
        dwFormatShadow |= (NV056_SET_SPECULAR_ARRAY_FORMAT_SIZE_0 << 8);
    }

    // tex 0 array
    if (pContext->hwState.dwStateFlags & CELSIUS_FLAG_USERTEXCOORDSNEEDED(0)) {
        dwD3DStage = pContext->hwState.dwTexUnitToTexStageMapping[0];
        nvAssert (dwD3DStage != CELSIUS_UNUSED);
        dwTCIndex  = (pContext->hwState.dwTexCoordIndices >> 0) & 0xffff;
        dwVAIndex  = defaultInputRegMap[D3DVSDE_TEXCOORD0+dwTCIndex];
        dwStreamSelector = pShader->getVAStream (dwVAIndex);
        nvAssert ((dwStreamSelector != CVertexShader::VA_STREAM_NONE) && (ppStreams[dwStreamSelector])); // they better have given us coordinates
        dwTexCount = (pContext->hwState.dwStateFlags & (CELSIUS_FLAG_PASSTHROUGHCUBEMAPPING(0) | CELSIUS_FLAG_TEXMATRIXSWFIX(0))) ?
                     4 : ((pShader->getVASize (dwVAIndex)) >> 2);
        dwStride = bInlineVertices ? dwInlineStride : ppStreams[dwStreamSelector]->getVertexStride();
        dwFormat[3] = DRF_NUM(056, _SET_TEX_COORD0_ARRAY_FORMAT, _SIZE, dwTexCount) |
                      DRF_DEF(056, _SET_TEX_COORD0_ARRAY_FORMAT, _TYPE, _FLOAT) |
                      DRF_NUM(056, _SET_TEX_COORD0_ARRAY_FORMAT, _STRIDE, dwStride);
        dwFormatShadow |= (dwTexCount << 12);
    }
    else {
        dwFormat[3] = DRF_DEF(056, _SET_TEX_COORD0_ARRAY_FORMAT, _SIZE, _0) |
                      DRF_DEF(056, _SET_TEX_COORD0_ARRAY_FORMAT, _TYPE, _FLOAT);
        dwFormatShadow |= (NV056_SET_TEX_COORD0_ARRAY_FORMAT_SIZE_0 << 12);
    }

    // tex 1 array
    if (pContext->hwState.dwStateFlags & CELSIUS_FLAG_USERTEXCOORDSNEEDED(1)) {
        dwD3DStage = pContext->hwState.dwTexUnitToTexStageMapping[1];
        nvAssert (dwD3DStage != CELSIUS_UNUSED);
        dwTCIndex  = (pContext->hwState.dwTexCoordIndices >> 16) & 0xffff;
        dwVAIndex  = defaultInputRegMap[D3DVSDE_TEXCOORD0+dwTCIndex];
        dwStreamSelector = pShader->getVAStream (dwVAIndex);
        nvAssert ((dwStreamSelector != CVertexShader::VA_STREAM_NONE) && (ppStreams[dwStreamSelector])); // they better have given us coordinates
        dwTexCount = (pContext->hwState.dwStateFlags & (CELSIUS_FLAG_PASSTHROUGHCUBEMAPPING(1) | CELSIUS_FLAG_TEXMATRIXSWFIX(1))) ?
                     4 : ((pShader->getVASize (dwVAIndex)) >> 2);
        dwStride = bInlineVertices ? dwInlineStride : ppStreams[dwStreamSelector]->getVertexStride();
        dwFormat[4] = DRF_NUM(056, _SET_TEX_COORD1_ARRAY_FORMAT, _SIZE, dwTexCount) |
                      DRF_DEF(056, _SET_TEX_COORD1_ARRAY_FORMAT, _TYPE, _FLOAT) |
                      DRF_NUM(056, _SET_TEX_COORD1_ARRAY_FORMAT, _STRIDE, dwStride);
        dwFormatShadow |= (dwTexCount << 16);
    }
    else {
        dwFormat[4] = DRF_DEF(056, _SET_TEX_COORD1_ARRAY_FORMAT, _SIZE, _0) |
                      DRF_DEF(056, _SET_TEX_COORD1_ARRAY_FORMAT, _TYPE, _FLOAT);
        dwFormatShadow |= (NV056_SET_TEX_COORD1_ARRAY_FORMAT_SIZE_0 << 16);
    }

    // normal array
    dwStreamSelector = pShader->getVAStream (defaultInputRegMap[D3DVSDE_NORMAL]);
    if ((dwStreamSelector != CVertexShader::VA_STREAM_NONE) && (ppStreams[dwStreamSelector])) {
        dwStride = bInlineVertices ? dwInlineStride : ppStreams[dwStreamSelector]->getVertexStride();
        dwFormat[5] = DRF_DEF(056, _SET_NORMAL_ARRAY_FORMAT, _SIZE, _3)      |
                      DRF_DEF(056, _SET_NORMAL_ARRAY_FORMAT, _TYPE, _FLOAT)  |
                      DRF_NUM(056, _SET_NORMAL_ARRAY_FORMAT, _STRIDE, dwStride);
        dwFormatShadow |= (NV056_SET_NORMAL_ARRAY_FORMAT_SIZE_3 << 20);
    }
    else {
        dwFormat[5] = DRF_DEF(056, _SET_NORMAL_ARRAY_FORMAT, _SIZE, _0)      |
                      DRF_DEF(056, _SET_NORMAL_ARRAY_FORMAT, _TYPE, _FLOAT);
        dwFormatShadow |= (NV056_SET_NORMAL_ARRAY_FORMAT_SIZE_0 << 20);
    }

    // weight array
    dwStreamSelector = pShader->getVAStream(defaultInputRegMap[D3DVSDE_BLENDWEIGHT]);
    if ((dwStreamSelector != CVertexShader::VA_STREAM_NONE) && (ppStreams[dwStreamSelector])) {
        dwStride = bInlineVertices ? dwInlineStride : ppStreams[dwStreamSelector]->getVertexStride();
        dwFormat[6] = DRF_DEF(056, _SET_WEIGHT_ARRAY_FORMAT, _SIZE, _1)      |
                      DRF_DEF(056, _SET_WEIGHT_ARRAY_FORMAT, _TYPE, _FLOAT)  |
                      DRF_NUM(056, _SET_WEIGHT_ARRAY_FORMAT, _STRIDE, dwStride);
        dwFormatShadow |= (NV056_SET_WEIGHT_ARRAY_FORMAT_SIZE_1 << 24);
    }
    else {
        dwFormat[6] = DRF_DEF(056, _SET_WEIGHT_ARRAY_FORMAT, _SIZE, _0)      |
                      DRF_DEF(056, _SET_WEIGHT_ARRAY_FORMAT, _TYPE, _FLOAT);
        dwFormatShadow |= (NV056_SET_WEIGHT_ARRAY_FORMAT_SIZE_0 << 24);
    }

    // fog arrays (non-existent in D3D)
    dwFormatShadow |= (NV056_SET_FOG_ARRAY_FORMAT_SIZE_0 << 28);

    // now go ahead and actually set all the formats, PREFACED by the shadowed copy
    pContext->hwState.celsius.set (NV056_SET_VERTEX_FORMAT_SHADOW,    dwFormatShadow);
    pContext->hwState.celsius.set (NV056_SET_VERTEX_ARRAY_FORMAT,     dwFormat[0]);
    pContext->hwState.celsius.set (NV056_SET_DIFFUSE_ARRAY_FORMAT,    dwFormat[1]);
    pContext->hwState.celsius.set (NV056_SET_SPECULAR_ARRAY_FORMAT,   dwFormat[2]);
    pContext->hwState.celsius.set (NV056_SET_TEX_COORD0_ARRAY_FORMAT, dwFormat[3]);
    pContext->hwState.celsius.set (NV056_SET_TEX_COORD1_ARRAY_FORMAT, dwFormat[4]);
    pContext->hwState.celsius.set (NV056_SET_NORMAL_ARRAY_FORMAT,     dwFormat[5]);
    pContext->hwState.celsius.set (NV056_SET_WEIGHT_ARRAY_FORMAT,     dwFormat[6]);

    // if we're going to fetch vertex data directly, we also need to program up the context dma and offsets
    if (!bInlineVertices) {

        // program the context dma and calculate a celsius-specific offset adjustment:
        // celsius wants an offset relative to a page aligned context dma, something
        // we do not know we have using the built in getOffset() methods.
        dwStreamSelector = pShader->getVAStream (defaultInputRegMap[D3DVSDE_POSITION]);

        switch (ppStreams[dwStreamSelector]->getContextDMA()) {

            case NV_CONTEXT_DMA_AGP_OR_PCI:
                pContext->hwState.celsius.set (NV056_SET_CONTEXT_DMA_VERTEX, D3D_CONTEXT_DMA_HOST_MEMORY);
                pContext->hwState.celsius.set (NV056_INVALIDATE_VERTEX_CACHE_FILE, 0);
                // compensate for ctx dma that is possibly not 4k aligned
                dwOffsetAdjustment = (ppStreams[dwStreamSelector]->getHeapLocation() == CSimpleSurface::HEAP_AGP) ?
                                     (pDriverData->GARTLinearBase & 0xfff) :      // AGP
                                     (getDC()->nvD3DTexHeapData.dwBase & 0xfff);  // PCI
                break;
            case NV_CONTEXT_DMA_VID:
                pContext->hwState.celsius.set (NV056_SET_CONTEXT_DMA_VERTEX, NV_DD_DMA_CONTEXT_DMA_IN_VIDEO_MEMORY);
                pContext->hwState.celsius.set (NV056_INVALIDATE_VERTEX_CACHE_FILE, 0);
                // compensate for ctx dma that is possibly not 4k aligned
                // NOTE - this is highly unlikely to not be 4k aligned...
                nvAssert ((pDriverData->BaseAddress & 0xfff) == 0);
                dwOffsetAdjustment = 0;
                break;
            default:
                DPF ("unknown context DMA");
                dbgD3DError();
                break;

        }  // switch

        // x, y, z, [w]
        dwStreamSelector = pShader->getVAStream (defaultInputRegMap[D3DVSDE_POSITION]);
        nvAssert ((dwStreamSelector != CVertexShader::VA_STREAM_NONE) && (ppStreams[dwStreamSelector]));
        dwVertexBufferOffset = ppStreams[dwStreamSelector]->getOffset() +
                               pContext->hwState.dwVertexOffset +
                               pShader->getVAOffset (defaultInputRegMap[D3DVSDE_POSITION]) +
                               dwOffsetAdjustment;
        pContext->hwState.celsius.set (NV056_SET_VERTEX_ARRAY_OFFSET, dwVertexBufferOffset);

        // diffuse color
        dwStreamSelector = pShader->getVAStream (defaultInputRegMap[D3DVSDE_DIFFUSE]);
        if ((dwStreamSelector != CVertexShader::VA_STREAM_NONE) && (ppStreams[dwStreamSelector])) {
            dwVertexBufferOffset = ppStreams[dwStreamSelector]->getOffset() +
                                   pContext->hwState.dwVertexOffset +
                                   pShader->getVAOffset (defaultInputRegMap[D3DVSDE_DIFFUSE]) +
                                   dwOffsetAdjustment;
            pContext->hwState.celsius.set (NV056_SET_DIFFUSE_ARRAY_OFFSET, dwVertexBufferOffset);
        }

        // specular color
        dwStreamSelector = pShader->getVAStream (defaultInputRegMap[D3DVSDE_SPECULAR]);
        if ((dwStreamSelector != CVertexShader::VA_STREAM_NONE) && (ppStreams[dwStreamSelector])) {
            dwVertexBufferOffset = ppStreams[dwStreamSelector]->getOffset() +
                                   pContext->hwState.dwVertexOffset +
                                   pShader->getVAOffset (defaultInputRegMap[D3DVSDE_SPECULAR]) +
                                   dwOffsetAdjustment;
            pContext->hwState.celsius.set (NV056_SET_SPECULAR_ARRAY_OFFSET, dwVertexBufferOffset);
        }

        // texture0 coordinates
        if (pContext->hwState.dwStateFlags & CELSIUS_FLAG_USERTEXCOORDSNEEDED(0)) {
            dwD3DStage = pContext->hwState.dwTexUnitToTexStageMapping[0];
            nvAssert (dwD3DStage != CELSIUS_UNUSED);
            dwTCIndex  = (pContext->hwState.dwTexCoordIndices >> 0) & 0xffff;
            dwVAIndex  = defaultInputRegMap[D3DVSDE_TEXCOORD0+dwTCIndex];
            dwStreamSelector = pShader->getVAStream (dwVAIndex);
            nvAssert ((dwStreamSelector != CVertexShader::VA_STREAM_NONE) && (ppStreams[dwStreamSelector])); // they better have given us coordinates
            dwVertexBufferOffset = ppStreams[dwStreamSelector]->getOffset() +
                                   pContext->hwState.dwVertexOffset +
                                   pShader->getVAOffset (dwVAIndex) +
                                   dwOffsetAdjustment;
            pContext->hwState.celsius.set (NV056_SET_TEX_COORD0_ARRAY_OFFSET, dwVertexBufferOffset);
        }

        // texture1 coordinates
        if (pContext->hwState.dwStateFlags & CELSIUS_FLAG_USERTEXCOORDSNEEDED(1)) {
            dwD3DStage = pContext->hwState.dwTexUnitToTexStageMapping[1];
            nvAssert (dwD3DStage != CELSIUS_UNUSED);
            dwTCIndex  = (pContext->hwState.dwTexCoordIndices >> 16) & 0xffff;
            dwVAIndex  = defaultInputRegMap[D3DVSDE_TEXCOORD0+dwTCIndex];
            dwStreamSelector = pShader->getVAStream (dwVAIndex);
            nvAssert ((dwStreamSelector != CVertexShader::VA_STREAM_NONE) && (ppStreams[dwStreamSelector])); // they better have given us coordinates
            dwVertexBufferOffset = ppStreams[dwStreamSelector]->getOffset() +
                                   pContext->hwState.dwVertexOffset +
                                   pShader->getVAOffset (dwVAIndex) +
                                   dwOffsetAdjustment;
            pContext->hwState.celsius.set (NV056_SET_TEX_COORD1_ARRAY_OFFSET, dwVertexBufferOffset);
        }

        // normal
        dwStreamSelector = pShader->getVAStream (defaultInputRegMap[D3DVSDE_NORMAL]);
        if ((dwStreamSelector != CVertexShader::VA_STREAM_NONE) && (ppStreams[dwStreamSelector])) {
            dwVertexBufferOffset = ppStreams[dwStreamSelector]->getOffset() +
                                   pContext->hwState.dwVertexOffset +
                                   pShader->getVAOffset (defaultInputRegMap[D3DVSDE_NORMAL]) +
                                   dwOffsetAdjustment;
            pContext->hwState.celsius.set (NV056_SET_NORMAL_ARRAY_OFFSET, dwVertexBufferOffset);
        }

        // weights (for skinning)
        dwStreamSelector = pShader->getVAStream (defaultInputRegMap[D3DVSDE_BLENDWEIGHT]);
        if ((dwStreamSelector != CVertexShader::VA_STREAM_NONE) && (ppStreams[dwStreamSelector])) {
            dwVertexBufferOffset = ppStreams[dwStreamSelector]->getOffset() +
                                   pContext->hwState.dwVertexOffset +
                                   pShader->getVAOffset (defaultInputRegMap[D3DVSDE_BLENDWEIGHT]) +
                                   dwOffsetAdjustment;
            pContext->hwState.celsius.set (NV056_SET_WEIGHT_ARRAY_OFFSET, dwVertexBufferOffset);
        }

    }  // if (!bInlineVertices)

    // do not remove
    pContext->hwState.celsius.queueTLNOP();

    return (D3D_OK);
}

//---------------------------------------------------------------------------

// set all state of the celsius object
// should be called prior to rendering
HRESULT __stdcall nvSetCelsiusState (PNVD3DCONTEXT pContext)
{

#ifdef NV_PROFILE_DP2OPS
    pDriverData->pBenchmark->beginHWStateChange(pContext->hwState.dwDirtyFlags, pDriverData->nvPusher.m_dwPut);
#endif

#ifdef NV_NULL_BLEND

    if (((pContext->hwState.dwDirtyFlags & CELSIUS_DIRTY_MISC_STATE)) || (pContext->hwState.dwDirtyFlags & CELSIUS_DIRTY_COMBINERS) || (pContext->hwState.dwDirtyFlags & CELSIUS_DIRTY_TEXTURE_STATE)) {

    pContext->dwRenderState[D3DRENDERSTATE_SRCBLEND]           = D3DBLEND_ONE;
    pContext->dwRenderState[D3DRENDERSTATE_DESTBLEND]          = D3DBLEND_ZERO;
    DWORD dwLODBias0 = nvTranslateLODBias (0);
    pContext->dwRenderState[D3DRENDERSTATE_ALPHAFUNC]          = D3DCMP_ALWAYS;
    pContext->dwRenderState[D3DRENDERSTATE_ALPHABLENDENABLE]   = FALSE;
    for (int i = 0; i < 8; i++) {
#ifdef NV_NULL_TEXTURES
        pContext->tssState[i].dwValue[D3DTSS_TEXTUREMAP]      = 0;
        pContext->tssState[i].dwValue[D3DTSS_ADDRESSU]        = D3DTADDRESS_WRAP;
        pContext->tssState[i].dwValue[D3DTSS_ADDRESSV]        = D3DTADDRESS_WRAP;
        pContext->tssState[i].dwValue[D3DTSS_MAGFILTER]       = D3DTFG_POINT;
        pContext->tssState[i].dwValue[D3DTSS_MINFILTER]       = D3DTFN_POINT;
        pContext->tssState[i].dwValue[D3DTSS_MIPFILTER]       = D3DTFP_POINT;
        pContext->tssState[i].dwValue[D3DTSS_COLOROP]         = D3DTOP_DISABLE;
        pContext->tssState[i].dwValue[D3DTSS_COLORARG1]       = D3DTA_TEXTURE;
        pContext->tssState[i].dwValue[D3DTSS_COLORARG2]       = D3DTA_CURRENT;
#endif
        pContext->tssState[i].dwValue[D3DTSS_ALPHAOP]         = D3DTOP_DISABLE;
        pContext->tssState[i].dwValue[D3DTSS_ALPHAARG1]       = D3DTA_TEXTURE;
        pContext->tssState[i].dwValue[D3DTSS_ALPHAARG2]       = D3DTA_CURRENT;
#ifdef NV_NULL_TEXTURES
        pContext->tssState[i].dwValue[D3DTSS_BUMPENVMAT00]    = 0;
        pContext->tssState[i].dwValue[D3DTSS_BUMPENVMAT01]    = 0;
        pContext->tssState[i].dwValue[D3DTSS_BUMPENVMAT10]    = 0;
        pContext->tssState[i].dwValue[D3DTSS_BUMPENVMAT11]    = 0;
        pContext->tssState[i].dwValue[D3DTSS_TEXCOORDINDEX]   = 0;
        pContext->tssState[i].dwValue[D3DTSS_BORDERCOLOR]     = 0x00000000;
        pContext->tssState[i].dwValue[D3DTSS_MIPMAPLODBIAS]   = 0;
        pContext->tssState[i].dwValue[D3DTSS_MAXMIPLEVEL]     = 0;
        pContext->tssState[i].dwValue[D3DTSS_MAXANISOTROPY]   = 1;
        pContext->tssState[i].dwValue[D3DTSS_BUMPENVLSCALE]   = 0;
        pContext->tssState[i].dwValue[D3DTSS_BUMPENVLOFFSET]  = 0;
        pContext->tssState[i].dwHandle                        = 0;
        pContext->tssState[i].dwLODBias                       = dwLODBias0;
#endif
    }
#ifdef NV_NULL_TEXTURES
    pContext->tssState[0].dwValue[D3DTSS_COLOROP] = D3DTOP_MODULATE;
    pContext->tssState[0].dwValue[D3DTSS_ALPHAOP] = D3DTOP_SELECTARG1;
    pContext->dwStageCount       = 1;
#endif
    }

#endif

#if (NVARCH >= 0x010)
    // Tell AASTATE that we're starting 3D rendering
    // Note that we call nvSetCelsiusState whenever
    // we're about to do some 3D rendering
    pContext->aa.Rendering(pContext);
#endif  // NVARCH >= 0x010


    // clear the failure flag
    pContext->hwState.dwStateFlags &= ~CELSIUS_FLAG_SETUPFAILURE;

    // if ddraw has sullied the celsius object or if we last programmed
    // the celsius object for a different context, start from scratch
    if ((pDriverData->dwMostRecentHWUser != MODULE_ID_D3D) ||
        (getDC()->dwLastHWContext        != (DWORD)pContext))
    {
        pDriverData->dwMostRecentHWUser = MODULE_ID_D3D;
        getDC()->dwLastHWContext        = (DWORD)pContext;
        pContext->hwState.dwDirtyFlags  = CELSIUS_DIRTY_REALLY_FILTHY;
#ifdef STATE_CULL
        for (int i=0; i < CELSIUS_HWSTATE_SIZE; i++) {
            // this case also implies that the object has state inconsistent with our shadowed copy
            // therefore we need to disable HW shadowing for the rest of call
            pContext->hwState.celsius.valid[i] = 0;
        }
#endif
    }

    // apply out-of-context dirty flags
    pContext->hwState.dwDirtyFlags |= getDC()->dwOutOfContextCelsiusDirtyFlags;
    getDC()->dwOutOfContextCelsiusDirtyFlags = 0;

    // this compiles away to nothing in a retail build
    pContext->hwState.dwDirtyFlags |= dbgForceHWRefresh;

    // mask out any non-celsius bits
    pContext->hwState.dwDirtyFlags &= CELSIUS_DIRTY_REALLY_FILTHY;


    // if nothing is dirty, just return
    if (!(pContext->hwState.dwDirtyFlags)) {
        return D3D_OK;
    }

#ifdef NV_PROFILE_CALLSTACK
    NVP_START(NVP_T_SETCELSIUSSTATE);
#endif

    // fundamental D3D stuff that doesn't normally change
    if (pContext->hwState.dwDirtyFlags & CELSIUS_DIRTY_DEFAULTS) {
        nvSetCelsiusD3DDefaults (pContext);
    }

    if (pContext->hwState.dwDirtyFlags & CELSIUS_DIRTY_SURFACE) {
        nvSetCelsiusSurfaceInfo (pContext);
    }

    // program the color combiners early since they determine the mapping
    // between hardware texture units and D3D texture stages, upon
    // which tons of other stuff depends.
    if (pContext->hwState.dwDirtyFlags & CELSIUS_DIRTY_COMBINERS) {
        nvSetCelsiusColorCombiners (pContext);
    }

    // If a pixel shader is enabled, use it to update the state
    if (pContext->hwState.dwDirtyFlags & CELSIUS_DIRTY_PIXEL_SHADER) {
        if (pContext->pCurrentPShader) {
            pContext->pCurrentPShader->setCelsiusState(pContext);
            pContext->hwState.dwDirtyFlags |= CELSIUS_DIRTY_TEXTURE_STATE | CELSIUS_DIRTY_FVF;
        }
        pContext->hwState.dwDirtyFlags &= ~CELSIUS_DIRTY_PIXEL_SHADER;
    }

    // texture state
    if (pContext->hwState.dwDirtyFlags & CELSIUS_DIRTY_TEXTURE_STATE) {
        nvSetCelsiusTextureState (pContext);
    }

    // fog / specular combiner
    if (pContext->hwState.dwDirtyFlags & CELSIUS_DIRTY_SPECFOG_COMBINER) {
        nvSetCelsiusSpecularFogCombiner (pContext);
    }

    // transform / lighting mode
    if (pContext->hwState.dwDirtyFlags & CELSIUS_DIRTY_TL_MODE) {
        nvSetCelsiusTLMode (pContext);
    }

    // texture transform
    if (pContext->hwState.dwDirtyFlags & CELSIUS_DIRTY_TEXTURE_TRANSFORM) {
        nvSetCelsiusTextureTransform (pContext);
    }

    // lighting
    if (pContext->hwState.dwDirtyFlags & CELSIUS_DIRTY_LIGHTS) {
        nvSetCelsiusLights (pContext);
    }

    // transform
    if (pContext->hwState.dwDirtyFlags & CELSIUS_DIRTY_TRANSFORM) {
        nvSetCelsiusTransform (pContext);
    }

    // remaining random stuff
    if (pContext->hwState.dwDirtyFlags & CELSIUS_DIRTY_MISC_STATE) {
        nvSetCelsiusMiscState (pContext);
    }

    if (pContext->hwState.dwDirtyFlags & CELSIUS_DIRTY_CONTROL0) {
        nvSetCelsiusControl0 (pContext);
    }

    if (pContext->hwState.dwDirtyFlags & CELSIUS_DIRTY_FVF) {
        nvSetCelsiusVertexFormat (pContext);
    }


#ifdef NV_PROFILE_CALLSTACK
    NVP_STOP(NVP_T_SETCELSIUSSTATE);
    nvpLogTime(NVP_T_SETCELSIUSSTATE,nvpTime[NVP_T_SETCELSIUSSTATE]);
#endif

    // make sure we're not dirty anymore. (this might happen if
    // there are interdepencies among the celsius state routines
    // and the routines get called in the 'wrong' order)
    nvAssert (!(pContext->hwState.dwDirtyFlags));

#ifdef NV_PROFILE_DP2OPS
    pDriverData->pBenchmark->endHWStateChange(pDriverData->nvPusher.m_dwPut);
#endif

    return D3D_OK;
}

#endif // NV_ARCH == 0x010
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\ddraw\celsius\src\nvCelsiusTables.cpp ===
/*
 * Copyright 1993-1998 NVIDIA, Corporation.  All rights reserved.
 * THE INFORMATION CONTAINED HEREIN IS PROPRIETARY AND CONFIDENTIAL TO
 * NVIDIA, CORPORATION.  USE, REPRODUCTION OR DISCLOSURE TO ANY THIRD PARTY
 * IS SUBJECT TO WRITTEN PRE-APPROVAL BY NVIDIA, CORPORATION.
 */
/********************************* Direct 3D *******************************\
*                                                                           *
* Module: nvCelsiusTables.cpp                                               *
*       tables useful for quick lookups of precomputed values               *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*       Craig Duttweiler        13May99         NV10 development            *
*                                                                           *
\***************************************************************************/
#include "nvprecomp.h"

#if (NVARCH >= 0x10)

//---------------------------------------------------------------------------

// table of precomputed combiner settings for stupid legacy texture blends.

// the table is indexed as [i][j]
// where i = D3DTBLEND_BLAH
//       j=0 => alpha_icw[0]
//       j=1 => color_icw[0]
//       j=2 => alpha_ocw[0]
//       j=3 => color_ocw[0]

DWORD celsiusTextureBlendSettings[D3D_TBLEND_MAX+1][4] =
{
    // i=0
    // invalid

    ~0,
    ~0,
    ~0,
    ~0,

    // i=1
    // D3DTBLEND_DECAL
    // aPix = aTex
    // cPix = cTex

    DRF_DEF(056, _SET_COMBINER_ALPHA_ICW, _A_MAP,    _UNSIGNED_IDENTITY) |
    DRF_DEF(056, _SET_COMBINER_ALPHA_ICW, _A_ALPHA,  _TRUE)              |
    DRF_DEF(056, _SET_COMBINER_ALPHA_ICW, _A_SOURCE, _REG_8)             |  // aTex0
    DRF_DEF(056, _SET_COMBINER_ALPHA_ICW, _B_MAP,    _UNSIGNED_INVERT)   |
    DRF_DEF(056, _SET_COMBINER_ALPHA_ICW, _B_ALPHA,  _TRUE)              |
    DRF_DEF(056, _SET_COMBINER_ALPHA_ICW, _B_SOURCE, _REG_0)             |  // 1
    DRF_DEF(056, _SET_COMBINER_ALPHA_ICW, _C_MAP,    _UNSIGNED_IDENTITY) |
    DRF_DEF(056, _SET_COMBINER_ALPHA_ICW, _C_ALPHA,  _TRUE)              |
    DRF_DEF(056, _SET_COMBINER_ALPHA_ICW, _C_SOURCE, _REG_0)             |  // 0
    DRF_DEF(056, _SET_COMBINER_ALPHA_ICW, _D_MAP,    _UNSIGNED_IDENTITY) |
    DRF_DEF(056, _SET_COMBINER_ALPHA_ICW, _D_ALPHA,  _TRUE)              |
    DRF_DEF(056, _SET_COMBINER_ALPHA_ICW, _D_SOURCE, _REG_0),               // 0

    DRF_DEF(056, _SET_COMBINER_COLOR_ICW, _A_MAP,    _UNSIGNED_IDENTITY) |
    DRF_DEF(056, _SET_COMBINER_COLOR_ICW, _A_ALPHA,  _FALSE)             |
    DRF_DEF(056, _SET_COMBINER_COLOR_ICW, _A_SOURCE, _REG_8)             |  // cTex0
    DRF_DEF(056, _SET_COMBINER_COLOR_ICW, _B_MAP,    _UNSIGNED_INVERT)   |
    DRF_DEF(056, _SET_COMBINER_COLOR_ICW, _B_ALPHA,  _FALSE)             |
    DRF_DEF(056, _SET_COMBINER_COLOR_ICW, _B_SOURCE, _REG_0)             |  // 1
    DRF_DEF(056, _SET_COMBINER_COLOR_ICW, _C_MAP,    _UNSIGNED_IDENTITY) |
    DRF_DEF(056, _SET_COMBINER_COLOR_ICW, _C_ALPHA,  _FALSE)             |
    DRF_DEF(056, _SET_COMBINER_COLOR_ICW, _C_SOURCE, _REG_0)             |  // 0
    DRF_DEF(056, _SET_COMBINER_COLOR_ICW, _D_MAP,    _UNSIGNED_IDENTITY) |
    DRF_DEF(056, _SET_COMBINER_COLOR_ICW, _D_ALPHA,  _FALSE)             |
    DRF_DEF(056, _SET_COMBINER_COLOR_ICW, _D_SOURCE, _REG_0),               // 0

    DRF_DEF(056, _SET_COMBINER_ALPHA_OCW, _OPERATION,  _NOSHIFT) |
    DRF_DEF(056, _SET_COMBINER_ALPHA_OCW, _MUX_ENABLE, _FALSE)   |
    DRF_DEF(056, _SET_COMBINER_ALPHA_OCW, _SUM_DST,    _REG_C)   |  // a*b + c*d => r12
    DRF_DEF(056, _SET_COMBINER_ALPHA_OCW, _AB_DST,     _REG_0)   |  // dev/null
    DRF_DEF(056, _SET_COMBINER_ALPHA_OCW, _CD_DST,     _REG_0),     // dev/null

    DRF_DEF(056, _SET_COMBINER0_COLOR_OCW, _OPERATION,     _NOSHIFT) |
    DRF_DEF(056, _SET_COMBINER0_COLOR_OCW, _MUX_ENABLE,    _FALSE)   |
    DRF_DEF(056, _SET_COMBINER0_COLOR_OCW, _AB_DOT_ENABLE, _FALSE)   |
    DRF_DEF(056, _SET_COMBINER0_COLOR_OCW, _CD_DOT_ENABLE, _FALSE)   |
    DRF_DEF(056, _SET_COMBINER0_COLOR_OCW, _SUM_DST,       _REG_C)   |  // a*b + c*d => r12
    DRF_DEF(056, _SET_COMBINER0_COLOR_OCW, _AB_DST,        _REG_0)   |  // dev/null
    DRF_DEF(056, _SET_COMBINER0_COLOR_OCW, _CD_DST,        _REG_0),     // dev/null

    // i=2
    // D3DTBLEND_MODULATE
    // aPix = aTex
    // cPix = cTex * cDiffuse

    DRF_DEF(056, _SET_COMBINER_ALPHA_ICW, _A_MAP,    _UNSIGNED_IDENTITY) |
    DRF_DEF(056, _SET_COMBINER_ALPHA_ICW, _A_ALPHA,  _TRUE)              |
    DRF_DEF(056, _SET_COMBINER_ALPHA_ICW, _A_SOURCE, _REG_8)             |  // aTex0
    DRF_DEF(056, _SET_COMBINER_ALPHA_ICW, _B_MAP,    _UNSIGNED_INVERT)   |
    DRF_DEF(056, _SET_COMBINER_ALPHA_ICW, _B_ALPHA,  _TRUE)              |
    DRF_DEF(056, _SET_COMBINER_ALPHA_ICW, _B_SOURCE, _REG_0)             |  // 1
    DRF_DEF(056, _SET_COMBINER_ALPHA_ICW, _C_MAP,    _UNSIGNED_IDENTITY) |
    DRF_DEF(056, _SET_COMBINER_ALPHA_ICW, _C_ALPHA,  _TRUE)              |
    DRF_DEF(056, _SET_COMBINER_ALPHA_ICW, _C_SOURCE, _REG_0)             |  // 0
    DRF_DEF(056, _SET_COMBINER_ALPHA_ICW, _D_MAP,    _UNSIGNED_IDENTITY) |
    DRF_DEF(056, _SET_COMBINER_ALPHA_ICW, _D_ALPHA,  _TRUE)              |
    DRF_DEF(056, _SET_COMBINER_ALPHA_ICW, _D_SOURCE, _REG_0),               // 0

    DRF_DEF(056, _SET_COMBINER_COLOR_ICW, _A_MAP,    _UNSIGNED_IDENTITY) |
    DRF_DEF(056, _SET_COMBINER_COLOR_ICW, _A_ALPHA,  _FALSE)             |
    DRF_DEF(056, _SET_COMBINER_COLOR_ICW, _A_SOURCE, _REG_8)             |  // cTex0
    DRF_DEF(056, _SET_COMBINER_COLOR_ICW, _B_MAP,    _UNSIGNED_IDENTITY) |
    DRF_DEF(056, _SET_COMBINER_COLOR_ICW, _B_ALPHA,  _FALSE)             |
    DRF_DEF(056, _SET_COMBINER_COLOR_ICW, _B_SOURCE, _REG_4)             |  // cDiffuse
    DRF_DEF(056, _SET_COMBINER_COLOR_ICW, _C_MAP,    _UNSIGNED_IDENTITY) |
    DRF_DEF(056, _SET_COMBINER_COLOR_ICW, _C_ALPHA,  _FALSE)             |
    DRF_DEF(056, _SET_COMBINER_COLOR_ICW, _C_SOURCE, _REG_0)             |  // 0
    DRF_DEF(056, _SET_COMBINER_COLOR_ICW, _D_MAP,    _UNSIGNED_IDENTITY) |
    DRF_DEF(056, _SET_COMBINER_COLOR_ICW, _D_ALPHA,  _FALSE)             |
    DRF_DEF(056, _SET_COMBINER_COLOR_ICW, _D_SOURCE, _REG_0),               // 0

    DRF_DEF(056, _SET_COMBINER_ALPHA_OCW, _OPERATION,  _NOSHIFT) |
    DRF_DEF(056, _SET_COMBINER_ALPHA_OCW, _MUX_ENABLE, _FALSE)   |
    DRF_DEF(056, _SET_COMBINER_ALPHA_OCW, _SUM_DST,    _REG_C)   |  // a*b + c*d => r12
    DRF_DEF(056, _SET_COMBINER_ALPHA_OCW, _AB_DST,     _REG_0)   |  // dev/null
    DRF_DEF(056, _SET_COMBINER_ALPHA_OCW, _CD_DST,     _REG_0),     // dev/null

    DRF_DEF(056, _SET_COMBINER0_COLOR_OCW, _OPERATION,     _NOSHIFT) |
    DRF_DEF(056, _SET_COMBINER0_COLOR_OCW, _MUX_ENABLE,    _FALSE)   |
    DRF_DEF(056, _SET_COMBINER0_COLOR_OCW, _AB_DOT_ENABLE, _FALSE)   |
    DRF_DEF(056, _SET_COMBINER0_COLOR_OCW, _CD_DOT_ENABLE, _FALSE)   |
    DRF_DEF(056, _SET_COMBINER0_COLOR_OCW, _SUM_DST,       _REG_C)   |  // a*b + c*d => r12
    DRF_DEF(056, _SET_COMBINER0_COLOR_OCW, _AB_DST,        _REG_0)   |  // dev/null
    DRF_DEF(056, _SET_COMBINER0_COLOR_OCW, _CD_DST,        _REG_0),     // dev/null

    // i=3
    // D3DTBLEND_DECALALPHA
    // aPix = aDiffuse
    // cPix = ((1 - aTex) * cDiffuse) + (aTex * cTex)

    DRF_DEF(056, _SET_COMBINER_ALPHA_ICW, _A_MAP,    _UNSIGNED_IDENTITY) |
    DRF_DEF(056, _SET_COMBINER_ALPHA_ICW, _A_ALPHA,  _TRUE)              |
    DRF_DEF(056, _SET_COMBINER_ALPHA_ICW, _A_SOURCE, _REG_4)             |  // aDiffuse
    DRF_DEF(056, _SET_COMBINER_ALPHA_ICW, _B_MAP,    _UNSIGNED_INVERT)   |
    DRF_DEF(056, _SET_COMBINER_ALPHA_ICW, _B_ALPHA,  _TRUE)              |
    DRF_DEF(056, _SET_COMBINER_ALPHA_ICW, _B_SOURCE, _REG_0)             |  // 1
    DRF_DEF(056, _SET_COMBINER_ALPHA_ICW, _C_MAP,    _UNSIGNED_IDENTITY) |
    DRF_DEF(056, _SET_COMBINER_ALPHA_ICW, _C_ALPHA,  _TRUE)              |
    DRF_DEF(056, _SET_COMBINER_ALPHA_ICW, _C_SOURCE, _REG_0)             |  // 0
    DRF_DEF(056, _SET_COMBINER_ALPHA_ICW, _D_MAP,    _UNSIGNED_IDENTITY) |
    DRF_DEF(056, _SET_COMBINER_ALPHA_ICW, _D_ALPHA,  _TRUE)              |
    DRF_DEF(056, _SET_COMBINER_ALPHA_ICW, _D_SOURCE, _REG_0),               // 0

    DRF_DEF(056, _SET_COMBINER_COLOR_ICW, _A_MAP,    _UNSIGNED_INVERT)   |
    DRF_DEF(056, _SET_COMBINER_COLOR_ICW, _A_ALPHA,  _TRUE)              |
    DRF_DEF(056, _SET_COMBINER_COLOR_ICW, _A_SOURCE, _REG_8)             |  // 1-aTex0
    DRF_DEF(056, _SET_COMBINER_COLOR_ICW, _B_MAP,    _UNSIGNED_IDENTITY) |
    DRF_DEF(056, _SET_COMBINER_COLOR_ICW, _B_ALPHA,  _FALSE)             |
    DRF_DEF(056, _SET_COMBINER_COLOR_ICW, _B_SOURCE, _REG_4)             |  // cDiffuse
    DRF_DEF(056, _SET_COMBINER_COLOR_ICW, _C_MAP,    _UNSIGNED_IDENTITY) |
    DRF_DEF(056, _SET_COMBINER_COLOR_ICW, _C_ALPHA,  _TRUE)              |
    DRF_DEF(056, _SET_COMBINER_COLOR_ICW, _C_SOURCE, _REG_8)             |  // aTex0
    DRF_DEF(056, _SET_COMBINER_COLOR_ICW, _D_MAP,    _UNSIGNED_IDENTITY) |
    DRF_DEF(056, _SET_COMBINER_COLOR_ICW, _D_ALPHA,  _FALSE)             |
    DRF_DEF(056, _SET_COMBINER_COLOR_ICW, _D_SOURCE, _REG_8),               // cTex0

    DRF_DEF(056, _SET_COMBINER_ALPHA_OCW, _OPERATION,  _NOSHIFT) |
    DRF_DEF(056, _SET_COMBINER_ALPHA_OCW, _MUX_ENABLE, _FALSE)   |
    DRF_DEF(056, _SET_COMBINER_ALPHA_OCW, _SUM_DST,    _REG_C)   |  // a*b + c*d => r12
    DRF_DEF(056, _SET_COMBINER_ALPHA_OCW, _AB_DST,     _REG_0)   |  // dev/null
    DRF_DEF(056, _SET_COMBINER_ALPHA_OCW, _CD_DST,     _REG_0),     // dev/null

    DRF_DEF(056, _SET_COMBINER0_COLOR_OCW, _OPERATION,     _NOSHIFT) |
    DRF_DEF(056, _SET_COMBINER0_COLOR_OCW, _MUX_ENABLE,    _FALSE)   |
    DRF_DEF(056, _SET_COMBINER0_COLOR_OCW, _AB_DOT_ENABLE, _FALSE)   |
    DRF_DEF(056, _SET_COMBINER0_COLOR_OCW, _CD_DOT_ENABLE, _FALSE)   |
    DRF_DEF(056, _SET_COMBINER0_COLOR_OCW, _SUM_DST,       _REG_C)   |  // a*b + c*d => r12
    DRF_DEF(056, _SET_COMBINER0_COLOR_OCW, _AB_DST,        _REG_0)   |  // dev/null
    DRF_DEF(056, _SET_COMBINER0_COLOR_OCW, _CD_DST,        _REG_0),     // dev/null

    // i=4
    // D3DTBLEND_MODULATEALPHA
    // aPix = aTex * aDiffuse
    // cPix = cTex * cDiffuse

    DRF_DEF(056, _SET_COMBINER_ALPHA_ICW, _A_MAP,    _UNSIGNED_IDENTITY) |
    DRF_DEF(056, _SET_COMBINER_ALPHA_ICW, _A_ALPHA,  _TRUE)              |
    DRF_DEF(056, _SET_COMBINER_ALPHA_ICW, _A_SOURCE, _REG_8)             |  // aTex0
    DRF_DEF(056, _SET_COMBINER_ALPHA_ICW, _B_MAP,    _UNSIGNED_IDENTITY) |
    DRF_DEF(056, _SET_COMBINER_ALPHA_ICW, _B_ALPHA,  _TRUE)              |
    DRF_DEF(056, _SET_COMBINER_ALPHA_ICW, _B_SOURCE, _REG_4)             |  // aDiffuse
    DRF_DEF(056, _SET_COMBINER_ALPHA_ICW, _C_MAP,    _UNSIGNED_IDENTITY) |
    DRF_DEF(056, _SET_COMBINER_ALPHA_ICW, _C_ALPHA,  _TRUE)              |
    DRF_DEF(056, _SET_COMBINER_ALPHA_ICW, _C_SOURCE, _REG_0)             |  // 0
    DRF_DEF(056, _SET_COMBINER_ALPHA_ICW, _D_MAP,    _UNSIGNED_IDENTITY) |
    DRF_DEF(056, _SET_COMBINER_ALPHA_ICW, _D_ALPHA,  _TRUE)              |
    DRF_DEF(056, _SET_COMBINER_ALPHA_ICW, _D_SOURCE, _REG_0),               // 0

    DRF_DEF(056, _SET_COMBINER_COLOR_ICW, _A_MAP,    _UNSIGNED_IDENTITY) |
    DRF_DEF(056, _SET_COMBINER_COLOR_ICW, _A_ALPHA,  _FALSE)             |
    DRF_DEF(056, _SET_COMBINER_COLOR_ICW, _A_SOURCE, _REG_8)             |  // cTex0
    DRF_DEF(056, _SET_COMBINER_COLOR_ICW, _B_MAP,    _UNSIGNED_IDENTITY) |
    DRF_DEF(056, _SET_COMBINER_COLOR_ICW, _B_ALPHA,  _FALSE)             |
    DRF_DEF(056, _SET_COMBINER_COLOR_ICW, _B_SOURCE, _REG_4)             |  // cDiffuse
    DRF_DEF(056, _SET_COMBINER_COLOR_ICW, _C_MAP,    _UNSIGNED_IDENTITY) |
    DRF_DEF(056, _SET_COMBINER_COLOR_ICW, _C_ALPHA,  _FALSE)             |
    DRF_DEF(056, _SET_COMBINER_COLOR_ICW, _C_SOURCE, _REG_0)             |  // 0
    DRF_DEF(056, _SET_COMBINER_COLOR_ICW, _D_MAP,    _UNSIGNED_IDENTITY) |
    DRF_DEF(056, _SET_COMBINER_COLOR_ICW, _D_ALPHA,  _FALSE)             |
    DRF_DEF(056, _SET_COMBINER_COLOR_ICW, _D_SOURCE, _REG_0),               // 0

    DRF_DEF(056, _SET_COMBINER_ALPHA_OCW, _OPERATION,  _NOSHIFT) |
    DRF_DEF(056, _SET_COMBINER_ALPHA_OCW, _MUX_ENABLE, _FALSE)   |
    DRF_DEF(056, _SET_COMBINER_ALPHA_OCW, _SUM_DST,    _REG_C)   |  // a*b + c*d => r12
    DRF_DEF(056, _SET_COMBINER_ALPHA_OCW, _AB_DST,     _REG_0)   |  // dev/null
    DRF_DEF(056, _SET_COMBINER_ALPHA_OCW, _CD_DST,     _REG_0),     // dev/null

    DRF_DEF(056, _SET_COMBINER0_COLOR_OCW, _OPERATION,     _NOSHIFT) |
    DRF_DEF(056, _SET_COMBINER0_COLOR_OCW, _MUX_ENABLE,    _FALSE)   |
    DRF_DEF(056, _SET_COMBINER0_COLOR_OCW, _AB_DOT_ENABLE, _FALSE)   |
    DRF_DEF(056, _SET_COMBINER0_COLOR_OCW, _CD_DOT_ENABLE, _FALSE)   |
    DRF_DEF(056, _SET_COMBINER0_COLOR_OCW, _SUM_DST,       _REG_C)   |  // a*b + c*d => r12
    DRF_DEF(056, _SET_COMBINER0_COLOR_OCW, _AB_DST,        _REG_0)   |  // dev/null
    DRF_DEF(056, _SET_COMBINER0_COLOR_OCW, _CD_DST,        _REG_0),     // dev/null

    // i=5
    // D3DTBLEND_DECALMASK
    // aPix = aDiffuse
    // cPix = lsb(aTex) ? cTex : cDiffuse

    DRF_DEF(056, _SET_COMBINER_ALPHA_ICW, _A_MAP,    _UNSIGNED_IDENTITY) |
    DRF_DEF(056, _SET_COMBINER_ALPHA_ICW, _A_ALPHA,  _TRUE)              |
    DRF_DEF(056, _SET_COMBINER_ALPHA_ICW, _A_SOURCE, _REG_4)             |  // aDiffuse
    DRF_DEF(056, _SET_COMBINER_ALPHA_ICW, _B_MAP,    _UNSIGNED_INVERT)   |
    DRF_DEF(056, _SET_COMBINER_ALPHA_ICW, _B_ALPHA,  _TRUE)              |
    DRF_DEF(056, _SET_COMBINER_ALPHA_ICW, _B_SOURCE, _REG_0)             |  // 1
    DRF_DEF(056, _SET_COMBINER_ALPHA_ICW, _C_MAP,    _UNSIGNED_IDENTITY) |
    DRF_DEF(056, _SET_COMBINER_ALPHA_ICW, _C_ALPHA,  _TRUE)              |
    DRF_DEF(056, _SET_COMBINER_ALPHA_ICW, _C_SOURCE, _REG_0)             |  // 0
    DRF_DEF(056, _SET_COMBINER_ALPHA_ICW, _D_MAP,    _UNSIGNED_IDENTITY) |
    DRF_DEF(056, _SET_COMBINER_ALPHA_ICW, _D_ALPHA,  _TRUE)              |
    DRF_DEF(056, _SET_COMBINER_ALPHA_ICW, _D_SOURCE, _REG_0),               // 0

    DRF_DEF(056, _SET_COMBINER_COLOR_ICW, _A_MAP,    _UNSIGNED_IDENTITY) |
    DRF_DEF(056, _SET_COMBINER_COLOR_ICW, _A_ALPHA,  _FALSE)             |
    DRF_DEF(056, _SET_COMBINER_COLOR_ICW, _A_SOURCE, _REG_4)             |  // cDiffuse
    DRF_DEF(056, _SET_COMBINER_COLOR_ICW, _B_MAP,    _UNSIGNED_INVERT)   |
    DRF_DEF(056, _SET_COMBINER_COLOR_ICW, _B_ALPHA,  _FALSE)             |
    DRF_DEF(056, _SET_COMBINER_COLOR_ICW, _B_SOURCE, _REG_0)             |  // 1
    DRF_DEF(056, _SET_COMBINER_COLOR_ICW, _C_MAP,    _UNSIGNED_IDENTITY) |
    DRF_DEF(056, _SET_COMBINER_COLOR_ICW, _C_ALPHA,  _FALSE)             |
    DRF_DEF(056, _SET_COMBINER_COLOR_ICW, _C_SOURCE, _REG_8)             |  // cTex0
    DRF_DEF(056, _SET_COMBINER_COLOR_ICW, _D_MAP,    _UNSIGNED_INVERT)   |
    DRF_DEF(056, _SET_COMBINER_COLOR_ICW, _D_ALPHA,  _FALSE)             |
    DRF_DEF(056, _SET_COMBINER_COLOR_ICW, _D_SOURCE, _REG_0),               // 0

    DRF_DEF(056, _SET_COMBINER_ALPHA_OCW, _OPERATION,  _NOSHIFT) |
    DRF_DEF(056, _SET_COMBINER_ALPHA_OCW, _MUX_ENABLE, _FALSE)   |
    DRF_DEF(056, _SET_COMBINER_ALPHA_OCW, _SUM_DST,    _REG_C)   |  // a*b + c*d => r12
    DRF_DEF(056, _SET_COMBINER_ALPHA_OCW, _AB_DST,     _REG_0)   |  // dev/null
    DRF_DEF(056, _SET_COMBINER_ALPHA_OCW, _CD_DST,     _REG_0),     // dev/null

    DRF_DEF(056, _SET_COMBINER0_COLOR_OCW, _OPERATION,     _NOSHIFT) |
    DRF_DEF(056, _SET_COMBINER0_COLOR_OCW, _MUX_ENABLE,    _TRUE)    |
    DRF_DEF(056, _SET_COMBINER0_COLOR_OCW, _AB_DOT_ENABLE, _FALSE)   |
    DRF_DEF(056, _SET_COMBINER0_COLOR_OCW, _CD_DOT_ENABLE, _FALSE)   |
    DRF_DEF(056, _SET_COMBINER0_COLOR_OCW, _SUM_DST,       _REG_C)   |  // a*b + c*d => r12
    DRF_DEF(056, _SET_COMBINER0_COLOR_OCW, _AB_DST,        _REG_0)   |  // dev/null
    DRF_DEF(056, _SET_COMBINER0_COLOR_OCW, _CD_DST,        _REG_0),     // dev/null

    // i=6
    // D3DTBLEND_MODULATEMASK
    // aPix = aDiffuse
    // cPix = lsb(aTex) ? cTex * cDiffuse : cDiffuse

    DRF_DEF(056, _SET_COMBINER_ALPHA_ICW, _A_MAP,    _UNSIGNED_IDENTITY) |
    DRF_DEF(056, _SET_COMBINER_ALPHA_ICW, _A_ALPHA,  _TRUE)              |
    DRF_DEF(056, _SET_COMBINER_ALPHA_ICW, _A_SOURCE, _REG_4)             |  // aDiffuse
    DRF_DEF(056, _SET_COMBINER_ALPHA_ICW, _B_MAP,    _UNSIGNED_INVERT)   |
    DRF_DEF(056, _SET_COMBINER_ALPHA_ICW, _B_ALPHA,  _TRUE)              |
    DRF_DEF(056, _SET_COMBINER_ALPHA_ICW, _B_SOURCE, _REG_0)             |  // 1
    DRF_DEF(056, _SET_COMBINER_ALPHA_ICW, _C_MAP,    _UNSIGNED_IDENTITY) |
    DRF_DEF(056, _SET_COMBINER_ALPHA_ICW, _C_ALPHA,  _TRUE)              |
    DRF_DEF(056, _SET_COMBINER_ALPHA_ICW, _C_SOURCE, _REG_0)             |  // 0
    DRF_DEF(056, _SET_COMBINER_ALPHA_ICW, _D_MAP,    _UNSIGNED_IDENTITY) |
    DRF_DEF(056, _SET_COMBINER_ALPHA_ICW, _D_ALPHA,  _TRUE)              |
    DRF_DEF(056, _SET_COMBINER_ALPHA_ICW, _D_SOURCE, _REG_0),               // 0

    DRF_DEF(056, _SET_COMBINER_COLOR_ICW, _A_MAP,    _UNSIGNED_IDENTITY) |
    DRF_DEF(056, _SET_COMBINER_COLOR_ICW, _A_ALPHA,  _FALSE)             |
    DRF_DEF(056, _SET_COMBINER_COLOR_ICW, _A_SOURCE, _REG_4)             |  // cDiffuse
    DRF_DEF(056, _SET_COMBINER_COLOR_ICW, _B_MAP,    _UNSIGNED_INVERT)   |
    DRF_DEF(056, _SET_COMBINER_COLOR_ICW, _B_ALPHA,  _FALSE)             |
    DRF_DEF(056, _SET_COMBINER_COLOR_ICW, _B_SOURCE, _REG_0)             |  // 1
    DRF_DEF(056, _SET_COMBINER_COLOR_ICW, _C_MAP,    _UNSIGNED_IDENTITY) |
    DRF_DEF(056, _SET_COMBINER_COLOR_ICW, _C_ALPHA,  _FALSE)             |
    DRF_DEF(056, _SET_COMBINER_COLOR_ICW, _C_SOURCE, _REG_8)             |  // cTex0
    DRF_DEF(056, _SET_COMBINER_COLOR_ICW, _D_MAP,    _UNSIGNED_IDENTITY) |
    DRF_DEF(056, _SET_COMBINER_COLOR_ICW, _D_ALPHA,  _FALSE)             |
    DRF_DEF(056, _SET_COMBINER_COLOR_ICW, _D_SOURCE, _REG_4),               // cDiffuse

    DRF_DEF(056, _SET_COMBINER_ALPHA_OCW, _OPERATION,  _NOSHIFT) |
    DRF_DEF(056, _SET_COMBINER_ALPHA_OCW, _MUX_ENABLE, _FALSE)   |
    DRF_DEF(056, _SET_COMBINER_ALPHA_OCW, _SUM_DST,    _REG_C)   |  // a*b + c*d => r12
    DRF_DEF(056, _SET_COMBINER_ALPHA_OCW, _AB_DST,     _REG_0)   |  // dev/null
    DRF_DEF(056, _SET_COMBINER_ALPHA_OCW, _CD_DST,     _REG_0),     // dev/null

    DRF_DEF(056, _SET_COMBINER0_COLOR_OCW, _OPERATION,     _NOSHIFT) |
    DRF_DEF(056, _SET_COMBINER0_COLOR_OCW, _MUX_ENABLE,    _TRUE)    |
    DRF_DEF(056, _SET_COMBINER0_COLOR_OCW, _AB_DOT_ENABLE, _FALSE)   |
    DRF_DEF(056, _SET_COMBINER0_COLOR_OCW, _CD_DOT_ENABLE, _FALSE)   |
    DRF_DEF(056, _SET_COMBINER0_COLOR_OCW, _SUM_DST,       _REG_C)   |  // a*b + c*d => r12
    DRF_DEF(056, _SET_COMBINER0_COLOR_OCW, _AB_DST,        _REG_0)   |  // dev/null
    DRF_DEF(056, _SET_COMBINER0_COLOR_OCW, _CD_DST,        _REG_0),     // dev/null

    // i=7
    // D3DTBLEND_COPY (same as DECAL)
    // aPix = aTex
    // cPix = cTex

    DRF_DEF(056, _SET_COMBINER_ALPHA_ICW, _A_MAP,    _UNSIGNED_IDENTITY) |
    DRF_DEF(056, _SET_COMBINER_ALPHA_ICW, _A_ALPHA,  _TRUE)              |
    DRF_DEF(056, _SET_COMBINER_ALPHA_ICW, _A_SOURCE, _REG_8)             |  // aTex0
    DRF_DEF(056, _SET_COMBINER_ALPHA_ICW, _B_MAP,    _UNSIGNED_INVERT)   |
    DRF_DEF(056, _SET_COMBINER_ALPHA_ICW, _B_ALPHA,  _TRUE)              |
    DRF_DEF(056, _SET_COMBINER_ALPHA_ICW, _B_SOURCE, _REG_0)             |  // 1
    DRF_DEF(056, _SET_COMBINER_ALPHA_ICW, _C_MAP,    _UNSIGNED_IDENTITY) |
    DRF_DEF(056, _SET_COMBINER_ALPHA_ICW, _C_ALPHA,  _TRUE)              |
    DRF_DEF(056, _SET_COMBINER_ALPHA_ICW, _C_SOURCE, _REG_0)             |  // 0
    DRF_DEF(056, _SET_COMBINER_ALPHA_ICW, _D_MAP,    _UNSIGNED_IDENTITY) |
    DRF_DEF(056, _SET_COMBINER_ALPHA_ICW, _D_ALPHA,  _TRUE)              |
    DRF_DEF(056, _SET_COMBINER_ALPHA_ICW, _D_SOURCE, _REG_0),               // 0

    DRF_DEF(056, _SET_COMBINER_COLOR_ICW, _A_MAP,    _UNSIGNED_IDENTITY) |
    DRF_DEF(056, _SET_COMBINER_COLOR_ICW, _A_ALPHA,  _FALSE)             |
    DRF_DEF(056, _SET_COMBINER_COLOR_ICW, _A_SOURCE, _REG_8)             |  // cTex0
    DRF_DEF(056, _SET_COMBINER_COLOR_ICW, _B_MAP,    _UNSIGNED_INVERT)   |
    DRF_DEF(056, _SET_COMBINER_COLOR_ICW, _B_ALPHA,  _FALSE)             |
    DRF_DEF(056, _SET_COMBINER_COLOR_ICW, _B_SOURCE, _REG_0)             |  // 1
    DRF_DEF(056, _SET_COMBINER_COLOR_ICW, _C_MAP,    _UNSIGNED_IDENTITY) |
    DRF_DEF(056, _SET_COMBINER_COLOR_ICW, _C_ALPHA,  _FALSE)             |
    DRF_DEF(056, _SET_COMBINER_COLOR_ICW, _C_SOURCE, _REG_0)             |  // 0
    DRF_DEF(056, _SET_COMBINER_COLOR_ICW, _D_MAP,    _UNSIGNED_IDENTITY) |
    DRF_DEF(056, _SET_COMBINER_COLOR_ICW, _D_ALPHA,  _FALSE)             |
    DRF_DEF(056, _SET_COMBINER_COLOR_ICW, _D_SOURCE, _REG_0),               // 0

    DRF_DEF(056, _SET_COMBINER_ALPHA_OCW, _OPERATION,  _NOSHIFT) |
    DRF_DEF(056, _SET_COMBINER_ALPHA_OCW, _MUX_ENABLE, _FALSE)   |
    DRF_DEF(056, _SET_COMBINER_ALPHA_OCW, _SUM_DST,    _REG_C)   |  // a*b + c*d => r12
    DRF_DEF(056, _SET_COMBINER_ALPHA_OCW, _AB_DST,     _REG_0)   |  // dev/null
    DRF_DEF(056, _SET_COMBINER_ALPHA_OCW, _CD_DST,     _REG_0),     // dev/null

    DRF_DEF(056, _SET_COMBINER0_COLOR_OCW, _OPERATION,     _NOSHIFT) |
    DRF_DEF(056, _SET_COMBINER0_COLOR_OCW, _MUX_ENABLE,    _FALSE)   |
    DRF_DEF(056, _SET_COMBINER0_COLOR_OCW, _AB_DOT_ENABLE, _FALSE)   |
    DRF_DEF(056, _SET_COMBINER0_COLOR_OCW, _CD_DOT_ENABLE, _FALSE)   |
    DRF_DEF(056, _SET_COMBINER0_COLOR_OCW, _SUM_DST,       _REG_C)   |  // a*b + c*d => r12
    DRF_DEF(056, _SET_COMBINER0_COLOR_OCW, _AB_DST,        _REG_0)   |  // dev/null
    DRF_DEF(056, _SET_COMBINER0_COLOR_OCW, _CD_DST,        _REG_0),     // dev/null

    // i=8
    // D3DTBLEND_ADD
    // aPix = aDiffuse
    // cPix = cTex + cDiffuse

    DRF_DEF(056, _SET_COMBINER_ALPHA_ICW, _A_MAP,    _UNSIGNED_IDENTITY) |
    DRF_DEF(056, _SET_COMBINER_ALPHA_ICW, _A_ALPHA,  _TRUE)              |
    DRF_DEF(056, _SET_COMBINER_ALPHA_ICW, _A_SOURCE, _REG_4)             |  // aDiffuse
    DRF_DEF(056, _SET_COMBINER_ALPHA_ICW, _B_MAP,    _UNSIGNED_INVERT)   |
    DRF_DEF(056, _SET_COMBINER_ALPHA_ICW, _B_ALPHA,  _TRUE)              |
    DRF_DEF(056, _SET_COMBINER_ALPHA_ICW, _B_SOURCE, _REG_0)             |  // 1
    DRF_DEF(056, _SET_COMBINER_ALPHA_ICW, _C_MAP,    _UNSIGNED_IDENTITY) |
    DRF_DEF(056, _SET_COMBINER_ALPHA_ICW, _C_ALPHA,  _TRUE)              |
    DRF_DEF(056, _SET_COMBINER_ALPHA_ICW, _C_SOURCE, _REG_0)             |  // 0
    DRF_DEF(056, _SET_COMBINER_ALPHA_ICW, _D_MAP,    _UNSIGNED_IDENTITY) |
    DRF_DEF(056, _SET_COMBINER_ALPHA_ICW, _D_ALPHA,  _TRUE)              |
    DRF_DEF(056, _SET_COMBINER_ALPHA_ICW, _D_SOURCE, _REG_0),               // 0

    DRF_DEF(056, _SET_COMBINER_COLOR_ICW, _A_MAP,    _UNSIGNED_IDENTITY) |
    DRF_DEF(056, _SET_COMBINER_COLOR_ICW, _A_ALPHA,  _FALSE)             |
    DRF_DEF(056, _SET_COMBINER_COLOR_ICW, _A_SOURCE, _REG_8)             |  // cTex0
    DRF_DEF(056, _SET_COMBINER_COLOR_ICW, _B_MAP,    _UNSIGNED_INVERT)   |
    DRF_DEF(056, _SET_COMBINER_COLOR_ICW, _B_ALPHA,  _FALSE)             |
    DRF_DEF(056, _SET_COMBINER_COLOR_ICW, _B_SOURCE, _REG_0)             |  // 1
    DRF_DEF(056, _SET_COMBINER_COLOR_ICW, _C_MAP,    _UNSIGNED_IDENTITY) |
    DRF_DEF(056, _SET_COMBINER_COLOR_ICW, _C_ALPHA,  _FALSE)             |
    DRF_DEF(056, _SET_COMBINER_COLOR_ICW, _C_SOURCE, _REG_4)             |  // cDiffuse
    DRF_DEF(056, _SET_COMBINER_COLOR_ICW, _D_MAP,    _UNSIGNED_INVERT)   |
    DRF_DEF(056, _SET_COMBINER_COLOR_ICW, _D_ALPHA,  _FALSE)             |
    DRF_DEF(056, _SET_COMBINER_COLOR_ICW, _D_SOURCE, _REG_0),               // 1

    DRF_DEF(056, _SET_COMBINER_ALPHA_OCW, _OPERATION,  _NOSHIFT) |
    DRF_DEF(056, _SET_COMBINER_ALPHA_OCW, _MUX_ENABLE, _FALSE)   |
    DRF_DEF(056, _SET_COMBINER_ALPHA_OCW, _SUM_DST,    _REG_C)   |  // a*b + c*d => r12
    DRF_DEF(056, _SET_COMBINER_ALPHA_OCW, _AB_DST,     _REG_0)   |  // dev/null
    DRF_DEF(056, _SET_COMBINER_ALPHA_OCW, _CD_DST,     _REG_0),     // dev/null

    DRF_DEF(056, _SET_COMBINER0_COLOR_OCW, _OPERATION,     _NOSHIFT) |
    DRF_DEF(056, _SET_COMBINER0_COLOR_OCW, _MUX_ENABLE,    _FALSE)   |
    DRF_DEF(056, _SET_COMBINER0_COLOR_OCW, _AB_DOT_ENABLE, _FALSE)   |
    DRF_DEF(056, _SET_COMBINER0_COLOR_OCW, _CD_DOT_ENABLE, _FALSE)   |
    DRF_DEF(056, _SET_COMBINER0_COLOR_OCW, _SUM_DST,       _REG_C)   |  // a*b + c*d => r12
    DRF_DEF(056, _SET_COMBINER0_COLOR_OCW, _AB_DST,        _REG_0)   |  // dev/null
    DRF_DEF(056, _SET_COMBINER0_COLOR_OCW, _CD_DST,        _REG_0)      // dev/null
};

//---------------------------------------------------------------------------

// combiner settings used when they enable a texture blend but not a texture
// aPix = aDiffuse
// cPix = cDiffuse

DWORD celsiusTextureBlendDefault[4] =
{
    DRF_DEF(056, _SET_COMBINER_ALPHA_ICW, _A_MAP,    _UNSIGNED_IDENTITY) |
    DRF_DEF(056, _SET_COMBINER_ALPHA_ICW, _A_ALPHA,  _TRUE)              |
    DRF_DEF(056, _SET_COMBINER_ALPHA_ICW, _A_SOURCE, _REG_4)             |  // aDiffuse
    DRF_DEF(056, _SET_COMBINER_ALPHA_ICW, _B_MAP,    _UNSIGNED_INVERT)   |
    DRF_DEF(056, _SET_COMBINER_ALPHA_ICW, _B_ALPHA,  _TRUE)              |
    DRF_DEF(056, _SET_COMBINER_ALPHA_ICW, _B_SOURCE, _REG_0)             |  // 1
    DRF_DEF(056, _SET_COMBINER_ALPHA_ICW, _C_MAP,    _UNSIGNED_IDENTITY) |
    DRF_DEF(056, _SET_COMBINER_ALPHA_ICW, _C_ALPHA,  _TRUE)              |
    DRF_DEF(056, _SET_COMBINER_ALPHA_ICW, _C_SOURCE, _REG_0)             |  // 0
    DRF_DEF(056, _SET_COMBINER_ALPHA_ICW, _D_MAP,    _UNSIGNED_IDENTITY) |
    DRF_DEF(056, _SET_COMBINER_ALPHA_ICW, _D_ALPHA,  _TRUE)              |
    DRF_DEF(056, _SET_COMBINER_ALPHA_ICW, _D_SOURCE, _REG_0),               // 0

    DRF_DEF(056, _SET_COMBINER_COLOR_ICW, _A_MAP,    _UNSIGNED_IDENTITY) |
    DRF_DEF(056, _SET_COMBINER_COLOR_ICW, _A_ALPHA,  _FALSE)             |
    DRF_DEF(056, _SET_COMBINER_COLOR_ICW, _A_SOURCE, _REG_4)             |  // cDiffuse
    DRF_DEF(056, _SET_COMBINER_COLOR_ICW, _B_MAP,    _UNSIGNED_INVERT)   |
    DRF_DEF(056, _SET_COMBINER_COLOR_ICW, _B_ALPHA,  _FALSE)             |
    DRF_DEF(056, _SET_COMBINER_COLOR_ICW, _B_SOURCE, _REG_0)             |  // 1
    DRF_DEF(056, _SET_COMBINER_COLOR_ICW, _C_MAP,    _UNSIGNED_IDENTITY) |
    DRF_DEF(056, _SET_COMBINER_COLOR_ICW, _C_ALPHA,  _FALSE)             |
    DRF_DEF(056, _SET_COMBINER_COLOR_ICW, _C_SOURCE, _REG_0)             |  // 0
    DRF_DEF(056, _SET_COMBINER_COLOR_ICW, _D_MAP,    _UNSIGNED_IDENTITY) |
    DRF_DEF(056, _SET_COMBINER_COLOR_ICW, _D_ALPHA,  _FALSE)             |
    DRF_DEF(056, _SET_COMBINER_COLOR_ICW, _D_SOURCE, _REG_0),               // 0

    DRF_DEF(056, _SET_COMBINER_ALPHA_OCW, _OPERATION,  _NOSHIFT) |
    DRF_DEF(056, _SET_COMBINER_ALPHA_OCW, _MUX_ENABLE, _FALSE)   |
    DRF_DEF(056, _SET_COMBINER_ALPHA_OCW, _SUM_DST,    _REG_C)   |  // a*b + c*d => r12
    DRF_DEF(056, _SET_COMBINER_ALPHA_OCW, _AB_DST,     _REG_0)   |  // dev/null
    DRF_DEF(056, _SET_COMBINER_ALPHA_OCW, _CD_DST,     _REG_0),     // dev/null

    DRF_DEF(056, _SET_COMBINER0_COLOR_OCW, _OPERATION,     _NOSHIFT) |
    DRF_DEF(056, _SET_COMBINER0_COLOR_OCW, _MUX_ENABLE,    _FALSE)   |
    DRF_DEF(056, _SET_COMBINER0_COLOR_OCW, _AB_DOT_ENABLE, _FALSE)   |
    DRF_DEF(056, _SET_COMBINER0_COLOR_OCW, _CD_DOT_ENABLE, _FALSE)   |
    DRF_DEF(056, _SET_COMBINER0_COLOR_OCW, _SUM_DST,       _REG_C)   |  // a*b + c*d => r12
    DRF_DEF(056, _SET_COMBINER0_COLOR_OCW, _AB_DST,        _REG_0)   |  // dev/null
    DRF_DEF(056, _SET_COMBINER0_COLOR_OCW, _CD_DST,        _REG_0)      // dev/null
};

//---------------------------------------------------------------------------

// table mapping dependencies between d3d renderstates and celsius state.

// celsiusDirtyBitsFromRenderState[D3DRENDERSTATE_FOO] contains the celsius class
// dirty bits that should be set whenever D3DRENDERSTATE_FOO is changed

DWORD celsiusDirtyBitsFromRenderState[D3D_RENDERSTATE_MAX+1] =
{
    0,                                                            //  0   invalid
    (CELSIUS_DIRTY_COMBINERS | CELSIUS_DIRTY_TEXTURE_STATE |      //  1   D3DRENDERSTATE_TEXTUREHANDLE
     CELSIUS_DIRTY_TEXTURE_TRANSFORM),
    0,                                                            //  2   D3DRENDERSTATE_ANTIALIAS
    CELSIUS_DIRTY_TEXTURE_STATE,                                  //  3   D3DRENDERSTATE_TEXTUREADDRESS
    (CELSIUS_DIRTY_TEXTURE_STATE | CELSIUS_DIRTY_CONTROL0),       //  4   D3DRENDERSTATE_TEXTUREPERSPECTIVE
    (CELSIUS_DIRTY_TL_MODE | CELSIUS_DIRTY_TEXTURE_STATE),        //  5   D3DRENDERSTATE_WRAPU
    (CELSIUS_DIRTY_TL_MODE | CELSIUS_DIRTY_TEXTURE_STATE),        //  6   D3DRENDERSTATE_WRAPV
    (CELSIUS_DIRTY_TRANSFORM | CELSIUS_DIRTY_CONTROL0 |           //  7   D3DRENDERSTATE_ZENABLE
     CELSIUS_DIRTY_TEXTURE_STATE | CELSIUS_DIRTY_MISC_STATE |
     CELSIUS_DIRTY_SPECFOG_COMBINER | CELSIUS_DIRTY_TL_MODE),
    CELSIUS_DIRTY_MISC_STATE,                                     //  8   D3DRENDERSTATE_FILLMODE
    CELSIUS_DIRTY_MISC_STATE,                                     //  9   D3DRENDERSTATE_SHADEMODE
    0,                                                            //  10  D3DRENDERSTATE_LINEPATTERN
    0,                                                            //  11  D3DRENDERSTATE_MONOENABLE
    0,                                                            //  12  D3DRENDERSTATE_ROP2
    CELSIUS_DIRTY_MISC_STATE,                                     //  13  D3DRENDERSTATE_PLANEMASK
    CELSIUS_DIRTY_MISC_STATE,                                     //  14  D3DRENDERSTATE_ZWRITEENABLE
    CELSIUS_DIRTY_MISC_STATE,                                     //  15  D3DRENDERSTATE_ALPHATESTENABLE
    0,                                                            //  16  D3DRENDERSTATE_LASTPIXEL
    CELSIUS_DIRTY_TEXTURE_STATE,                                  //  17  D3DRENDERSTATE_TEXTUREMAG
    CELSIUS_DIRTY_TEXTURE_STATE,                                  //  18  D3DRENDERSTATE_TEXTUREMIN
    CELSIUS_DIRTY_MISC_STATE,                                     //  19  D3DRENDERSTATE_SRCBLEND
    CELSIUS_DIRTY_MISC_STATE,                                     //  20  D3DRENDERSTATE_DESTBLEND
    CELSIUS_DIRTY_COMBINERS,                                      //  21  D3DRENDERSTATE_TEXTUREMAPBLEND
    CELSIUS_DIRTY_MISC_STATE,                                     //  22  D3DRENDERSTATE_CULLMODE
    CELSIUS_DIRTY_MISC_STATE,                                     //  23  D3DRENDERSTATE_ZFUNC
    CELSIUS_DIRTY_MISC_STATE,                                     //  24  D3DRENDERSTATE_ALPHAREF
    CELSIUS_DIRTY_MISC_STATE,                                     //  25  D3DRENDERSTATE_ALPHAFUNC
    CELSIUS_DIRTY_MISC_STATE,                                     //  26  D3DRENDERSTATE_DITHERENABLE
    CELSIUS_DIRTY_MISC_STATE,                                     //  27  D3DRENDERSTATE_ALPHABLENDENABLE
    CELSIUS_DIRTY_SPECFOG_COMBINER,                               //  28  D3DRENDERSTATE_FOGENABLE
    (CELSIUS_DIRTY_LIGHTS | CELSIUS_DIRTY_SPECFOG_COMBINER),      //  29  D3DRENDERSTATE_SPECULARENABLE
    0,                                                            //  30  D3DRENDERSTATE_ZVISIBLE
    0,                                                            //  31  D3DRENDERSTATE_SUBPIXEL
    0,                                                            //  32  D3DRENDERSTATE_SUBPIXELX
    0,                                                            //  33  D3DRENDERSTATE_STIPPLEDALPHA
    CELSIUS_DIRTY_SPECFOG_COMBINER,                               //  34  D3DRENDERSTATE_FOGCOLOR
    CELSIUS_DIRTY_SPECFOG_COMBINER,                               //  35  D3DRENDERSTATE_FOGTABLEMODE
    CELSIUS_DIRTY_SPECFOG_COMBINER,                               //  36  D3DRENDERSTATE_FOGTABLESTART   (D3DRENDERSTATE_FOGSTART)
    CELSIUS_DIRTY_SPECFOG_COMBINER,                               //  37  D3DRENDERSTATE_FOGTABLEEND     (D3DRENDERSTATE_FOGEND)
    CELSIUS_DIRTY_SPECFOG_COMBINER,                               //  38  D3DRENDERSTATE_FOGTABLEDENSITY (D3DRENDERSTATE_FOGDENSITY)
    0,                                                            //  39  D3DRENDERSTATE_STIPPLEENABLE
    CELSIUS_DIRTY_MISC_STATE,                                     //  40  D3DRENDERSTATE_EDGEANTIALIAS
    CELSIUS_DIRTY_TEXTURE_STATE,                                  //  41  D3DRENDERSTATE_COLORKEYENABLE
    0,                                                            //  42  D3DRENDERSTATE_OLDALPHABLENDENABLE
    0,                                                            //  43  D3DRENDERSTATE_BORDERCOLOR
    CELSIUS_DIRTY_TEXTURE_STATE,                                  //  44  D3DRENDERSTATE_TEXTUREADDRESSU
    CELSIUS_DIRTY_TEXTURE_STATE,                                  //  45  D3DRENDERSTATE_TEXTUREADDRESSV
    CELSIUS_DIRTY_TEXTURE_STATE,                                  //  46  D3DRENDERSTATE_MIPMAPLODBIAS
    CELSIUS_DIRTY_MISC_STATE,                                     //  47  D3DRENDERSTATE_ZBIAS
    CELSIUS_DIRTY_SPECFOG_COMBINER,                               //  48  D3DRENDERSTATE_RANGEFOGENABLE
    CELSIUS_DIRTY_TEXTURE_STATE,                                  //  49  D3DRENDERSTATE_ANISOTROPY
    0,                                                            //  50  D3DRENDERSTATE_FLUSHBATCH
    0,                                                            //  51  D3DRENDERSTATE_TRANSLUCENTSORTINDEPENDENT
    (CELSIUS_DIRTY_CONTROL0 | CELSIUS_DIRTY_MISC_STATE),          //  52  D3DRENDERSTATE_STENCILENABLE
    CELSIUS_DIRTY_MISC_STATE,                                     //  53  D3DRENDERSTATE_STENCILFAIL
    CELSIUS_DIRTY_MISC_STATE,                                     //  54  D3DRENDERSTATE_STENCILZFAIL
    CELSIUS_DIRTY_MISC_STATE,                                     //  55  D3DRENDERSTATE_STENCILPASS
    CELSIUS_DIRTY_MISC_STATE,                                     //  56  D3DRENDERSTATE_STENCILFUNC
    CELSIUS_DIRTY_MISC_STATE,                                     //  57  D3DRENDERSTATE_STENCILREF
    CELSIUS_DIRTY_MISC_STATE,                                     //  58  D3DRENDERSTATE_STENCILMASK
    CELSIUS_DIRTY_MISC_STATE,                                     //  59  D3DRENDERSTATE_STENCILWRITEMASK
    CELSIUS_DIRTY_MISC_STATE,                                     //  60  D3DRENDERSTATE_TEXTUREFACTOR
    0,                                                            //  61  D3DRENDERSTATE_EVICTMANAGEDTEXTURES
    0,                                                            //  62  D3DRENDERSTATE_SCENECAPTURE
    0,                                                            //  63  invalid
    0,                                                            //  64  D3DRENDERSTATE_STIPPLEPATTERN00
    0,                                                            //  65  D3DRENDERSTATE_STIPPLEPATTERN01
    0,                                                            //  66  D3DRENDERSTATE_STIPPLEPATTERN02
    0,                                                            //  67  D3DRENDERSTATE_STIPPLEPATTERN03
    0,                                                            //  68  D3DRENDERSTATE_STIPPLEPATTERN04
    0,                                                            //  69  D3DRENDERSTATE_STIPPLEPATTERN05
    0,                                                            //  70  D3DRENDERSTATE_STIPPLEPATTERN06
    0,                                                            //  71  D3DRENDERSTATE_STIPPLEPATTERN07
    0,                                                            //  72  D3DRENDERSTATE_STIPPLEPATTERN08
    0,                                                            //  73  D3DRENDERSTATE_STIPPLEPATTERN09
    0,                                                            //  74  D3DRENDERSTATE_STIPPLEPATTERN10
    0,                                                            //  75  D3DRENDERSTATE_STIPPLEPATTERN11
    0,                                                            //  76  D3DRENDERSTATE_STIPPLEPATTERN12
    0,                                                            //  77  D3DRENDERSTATE_STIPPLEPATTERN13
    0,                                                            //  78  D3DRENDERSTATE_STIPPLEPATTERN14
    0,                                                            //  79  D3DRENDERSTATE_STIPPLEPATTERN15
    0,                                                            //  80  D3DRENDERSTATE_STIPPLEPATTERN16
    0,                                                            //  81  D3DRENDERSTATE_STIPPLEPATTERN17
    0,                                                            //  82  D3DRENDERSTATE_STIPPLEPATTERN18
    0,                                                            //  83  D3DRENDERSTATE_STIPPLEPATTERN19
    0,                                                            //  84  D3DRENDERSTATE_STIPPLEPATTERN20
    0,                                                            //  85  D3DRENDERSTATE_STIPPLEPATTERN21
    0,                                                            //  86  D3DRENDERSTATE_STIPPLEPATTERN22
    0,                                                            //  87  D3DRENDERSTATE_STIPPLEPATTERN23
    0,                                                            //  88  D3DRENDERSTATE_STIPPLEPATTERN24
    0,                                                            //  89  D3DRENDERSTATE_STIPPLEPATTERN25
    0,                                                            //  90  D3DRENDERSTATE_STIPPLEPATTERN26
    0,                                                            //  91  D3DRENDERSTATE_STIPPLEPATTERN27
    0,                                                            //  92  D3DRENDERSTATE_STIPPLEPATTERN28
    0,                                                            //  93  D3DRENDERSTATE_STIPPLEPATTERN29
    0,                                                            //  94  D3DRENDERSTATE_STIPPLEPATTERN30
    0,                                                            //  95  D3DRENDERSTATE_STIPPLEPATTERN31
    0,                                                            //  96  invalid
    0,                                                            //  97  invalid
    0,                                                            //  98  invalid
    0,                                                            //  99  invalid
    0,                                                            //  100 invalid
    0,                                                            //  101 invalid
    0,                                                            //  102 invalid
    0,                                                            //  103 invalid
    0,                                                            //  104 invalid
    0,                                                            //  105 invalid
    0,                                                            //  106 invalid
    0,                                                            //  107 invalid
    0,                                                            //  108 invalid
    0,                                                            //  109 invalid
    0,                                                            //  110 invalid
    0,                                                            //  111 invalid
    0,                                                            //  112 invalid
    0,                                                            //  113 invalid
    0,                                                            //  114 invalid
    0,                                                            //  115 invalid
    0,                                                            //  116 invalid
    0,                                                            //  117 invalid
    0,                                                            //  118 invalid
    0,                                                            //  119 invalid
    0,                                                            //  120 invalid
    0,                                                            //  121 invalid
    0,                                                            //  122 invalid
    0,                                                            //  123 invalid
    0,                                                            //  124 invalid
    0,                                                            //  125 invalid
    0,                                                            //  126 invalid
    0,                                                            //  127 invalid
    (CELSIUS_DIRTY_TL_MODE | CELSIUS_DIRTY_TEXTURE_STATE),        //  128 D3DRENDERSTATE_WRAP0
    (CELSIUS_DIRTY_TL_MODE | CELSIUS_DIRTY_TEXTURE_STATE),        //  129 D3DRENDERSTATE_WRAP1
    (CELSIUS_DIRTY_TL_MODE | CELSIUS_DIRTY_TEXTURE_STATE),        //  130 D3DRENDERSTATE_WRAP2
    (CELSIUS_DIRTY_TL_MODE | CELSIUS_DIRTY_TEXTURE_STATE),        //  131 D3DRENDERSTATE_WRAP3
    (CELSIUS_DIRTY_TL_MODE | CELSIUS_DIRTY_TEXTURE_STATE),        //  132 D3DRENDERSTATE_WRAP4
    (CELSIUS_DIRTY_TL_MODE | CELSIUS_DIRTY_TEXTURE_STATE),        //  133 D3DRENDERSTATE_WRAP5
    (CELSIUS_DIRTY_TL_MODE | CELSIUS_DIRTY_TEXTURE_STATE),        //  134 D3DRENDERSTATE_WRAP6
    (CELSIUS_DIRTY_TL_MODE | CELSIUS_DIRTY_TEXTURE_STATE),        //  135 D3DRENDERSTATE_WRAP7
    0,                                                            //  136 D3DRENDERSTATE_CLIPPING
    CELSIUS_DIRTY_LIGHTS,                                         //  137 D3DRENDERSTATE_LIGHTING
    0,                                                            //  138 D3DRENDERSTATE_EXTENTS
    CELSIUS_DIRTY_LIGHTS,                                         //  139 D3DRENDERSTATE_AMBIENT
    CELSIUS_DIRTY_SPECFOG_COMBINER,                               //  140 D3DRENDERSTATE_FOGVERTEXMODE
    CELSIUS_DIRTY_LIGHTS,                                         //  141 D3DRENDERSTATE_COLORVERTEX
    CELSIUS_DIRTY_LIGHTS,                                         //  142 D3DRENDERSTATE_LOCALVIEWER
    CELSIUS_DIRTY_TRANSFORM,                                      //  143 D3DRENDERSTATE_NORMALIZENORMALS
    0,                                                            //  144 D3DRENDERSTATE_COLORKEYBLENDENABLE
    CELSIUS_DIRTY_LIGHTS,                                         //  145 D3DRENDERSTATE_DIFFUSEMATERIALSOURCE
    CELSIUS_DIRTY_LIGHTS,                                         //  146 D3DRENDERSTATE_SPECULARMATERIALSOURCE
    CELSIUS_DIRTY_LIGHTS,                                         //  147 D3DRENDERSTATE_AMBIENTMATERIALSOURCE
    CELSIUS_DIRTY_LIGHTS,                                         //  148 D3DRENDERSTATE_EMISSIVEMATERIALSOURCE
    CELSIUS_DIRTY_LIGHTS,                                         //  149 D3DRENDERSTATE_ALPHASOURCE
    CELSIUS_DIRTY_LIGHTS,                                         //  150 D3DRENDERSTATE_FOGFACTORSOURCE
    (CELSIUS_DIRTY_MISC_STATE | CELSIUS_DIRTY_TRANSFORM),         //  151 D3DRENDERSTATE_VERTEXBLEND
    CELSIUS_DIRTY_TEXTURE_STATE,                                  //  152 D3DRENDERSTATE_CLIPPLANEENABLE
    0,                                                            //  153 D3DRENDERSTATE_SOFTWAREVEXTEXPROCESSING
    CELSIUS_DIRTY_MISC_STATE,                                     //  154 D3DRENDERSTATE_POINTSIZE
    CELSIUS_DIRTY_MISC_STATE,                                     //  155 D3DRENDERSTATE_POINTSIZEMIN
    CELSIUS_DIRTY_MISC_STATE | CELSIUS_DIRTY_TEXTURE_STATE,       //  156 D3DRENDERSTATE_POINTSPRITEENABLE
    CELSIUS_DIRTY_MISC_STATE | CELSIUS_DIRTY_TEXTURE_STATE,       //  157 D3DRENDERSTATE_POINTSCALEENABLE
    CELSIUS_DIRTY_MISC_STATE,                                     //  158 D3DRENDERSTATE_POINTSCALEA
    CELSIUS_DIRTY_MISC_STATE,                                     //  159 D3DRENDERSTATE_POINTSCALEB
    CELSIUS_DIRTY_MISC_STATE,                                     //  150 D3DRENDERSTATE_POINTSCALEC
    0,                                                            //  161 D3DRENDERSTATE_MULTISAMPLEAA
    0,                                                            //  162 D3DRENDERSTATE_MULTISAMPLEMASK
    0,                                                            //  163 D3DRENDERSTATE_COLORKEYMASK
    0,                                                            //  164 D3DRS_PATCHSEGMENTS
    0,                                                            //  165 D3DRS_DEBUGMONITORTOKEN
    0,                                                            //  166 D3DRS_POINTSIZE_MAX
    0,                                                            //  167 D3DRS_INDEXEDVERTEXBLENDENABLE
    CELSIUS_DIRTY_MISC_STATE,                                     //  168 D3DRS_COLORWRITEENABLE
    0,                                                            //  169 invalid
    0,                                                            //  170 D3DRS_TWEENFACTOR
    CELSIUS_DIRTY_MISC_STATE,                                     //  171 D3DRS_BLENDOP
};

//---------------------------------------------------------------------------

// table mapping dependencies between d3d texture stage state and celsius state.

// celsiusDirtyBitsFromTextureStageState[D3DTSS_FOO] contains the celsius class
// dirty bits that should be set whenever D3DTSS_FOO is changed

DWORD celsiusDirtyBitsFromTextureStageState[D3D_TEXSTAGESTATE_MAX+1] =
{
    CELSIUS_DIRTY_TEXTURE_STATE | CELSIUS_DIRTY_TEXTURE_TRANSFORM | //  0  D3DTSS_TEXTUREMAP
    CELSIUS_DIRTY_COMBINERS,
    CELSIUS_DIRTY_TEXTURE_TRANSFORM | CELSIUS_DIRTY_COMBINERS,      //  1  D3DTSS_COLOROP
    CELSIUS_DIRTY_COMBINERS,                                        //  2  D3DTSS_COLORARG1
    CELSIUS_DIRTY_COMBINERS,                                        //  3  D3DTSS_COLORARG2
    CELSIUS_DIRTY_COMBINERS,                                        //  4  D3DTSS_ALPHAOP
    CELSIUS_DIRTY_COMBINERS,                                        //  5  D3DTSS_ALPHAARG1
    CELSIUS_DIRTY_COMBINERS,                                        //  6  D3DTSS_ALPHAARG2
    0,                                                              //  7  D3DTSS_BUMPENVMAT00
    0,                                                              //  8  D3DTSS_BUMPENVMAT01
    0,                                                              //  9  D3DTSS_BUMPENVMAT10
    0,                                                              //  10 D3DTSS_BUMPENVMAT11
    CELSIUS_DIRTY_TEXTURE_TRANSFORM | CELSIUS_DIRTY_TEXTURE_STATE | //  11 D3DTSS_TEXCOORDINDEX
    CELSIUS_DIRTY_FVF | CELSIUS_DIRTY_TL_MODE,
    CELSIUS_DIRTY_TEXTURE_STATE,                                    //  12 D3DTSS_ADDRESS
    CELSIUS_DIRTY_TEXTURE_STATE,                                    //  13 D3DTSS_ADDRESSU
    CELSIUS_DIRTY_TEXTURE_STATE,                                    //  14 D3DTSS_ADDRESSV
    0,                                                              //  15 D3DTSS_BORDERCOLOR
    CELSIUS_DIRTY_TEXTURE_STATE,                                    //  16 D3DTSS_MAGFILTER
    CELSIUS_DIRTY_TEXTURE_STATE,                                    //  17 D3DTSS_MINFILTER
    CELSIUS_DIRTY_TEXTURE_STATE,                                    //  18 D3DTSS_MIPFILTER
    CELSIUS_DIRTY_TEXTURE_STATE,                                    //  19 D3DTSS_MIPMAPLODBIAS
    CELSIUS_DIRTY_TEXTURE_STATE,                                    //  20 D3DTSS_MAXMIPLEVEL
    CELSIUS_DIRTY_TEXTURE_STATE,                                    //  21 D3DTSS_MAXANISOTROPY
    0,                                                              //  22 D3DTSS_BUMPENVLSCALE
    0,                                                              //  23 D3DTSS_BUMPENVLOFFSET
    CELSIUS_DIRTY_TEXTURE_TRANSFORM,                                //  24 D3DTSS_TEXTURETRANSFORMFLAGS
    0,                                                              //  25 D3DTSS_ADDRESSW
    CELSIUS_DIRTY_COMBINERS,                                        //  26 D3DTSS_COLORARG0
    CELSIUS_DIRTY_COMBINERS,                                        //  27 D3DTSS_ALPHAARG0
    CELSIUS_DIRTY_COMBINERS                                         //  28 D3DTSS_RESULTARG
};

//---------------------------------------------------------------------------

// table mapping dp2ops to the celsius method values associated with them.
// these are defined in term of NV056_SET_BEGIN_END_OP_X but the same values
// are used for all enumerants of type NV056_SET_BEGIN_ENDX_OP_X

DWORD celsiusBeginEndOp[D3D_DP2OP_MAX+1] =
{
    ~0,                                          //   0  invalid
    NV056_SET_BEGIN_END_OP_POINTS,               //   1  D3DDP2OP_POINTS
    NV056_SET_BEGIN_END_OP_LINES,                //   2  D3DDP2OP_INDEXEDLINELIST
    NV056_SET_BEGIN_END_OP_TRIANGLES,            //   3  D3DDP2OP_INDEXEDTRIANGLELIST
    ~0,                                          //   4  invalid
    ~0,                                          //   5  invalid
    ~0,                                          //   6  invalid
    ~0,                                          //   7  invalid
    ~0,                                          //   8  D3DDP2OP_RENDERSTATE
    ~0,                                          //   9  invalid
    ~0,                                          //  10  invalid
    ~0,                                          //  11  invalid
    ~0,                                          //  12  invalid
    ~0,                                          //  13  invalid
    ~0,                                          //  14  invalid
    NV056_SET_BEGIN_END_OP_LINES,                //  15  D3DDP2OP_LINELIST
    NV056_SET_BEGIN_END_OP_LINE_STRIP,           //  16  D3DDP2OP_LINESTRIP
    NV056_SET_BEGIN_END_OP_LINE_STRIP,           //  17  D3DDP2OP_INDEXEDLINESTRIP
    NV056_SET_BEGIN_END_OP_TRIANGLES,            //  18  D3DDP2OP_TRIANGLELIST
    NV056_SET_BEGIN_END_OP_TRIANGLE_STRIP,       //  19  D3DDP2OP_TRIANGLESTRIP
    NV056_SET_BEGIN_END_OP_TRIANGLE_STRIP,       //  20  D3DDP2OP_INDEXEDTRIANGLESTRIP
    NV056_SET_BEGIN_END_OP_TRIANGLE_FAN,         //  21  D3DDP2OP_TRIANGLEFAN
    NV056_SET_BEGIN_END_OP_TRIANGLE_FAN,         //  22  D3DDP2OP_INDEXEDTRIANGLEFAN
    NV056_SET_BEGIN_END_OP_TRIANGLE_FAN,         //  23  D3DDP2OP_TRIANGLEFAN_IMM
    NV056_SET_BEGIN_END_OP_LINES,                //  24  D3DDP2OP_LINELIST_IMM
    ~0,                                          //  25  D3DDP2OP_TEXTURESTAGESTATE
    NV056_SET_BEGIN_END_OP_TRIANGLES,            //  26  D3DDP2OP_INDEXEDTRIANGLELIST2
    NV056_SET_BEGIN_END_OP_LINES,                //  27  D3DDP2OP_INDEXEDLINELIST2
    ~0,                                          //  28  D3DDP2OP_VIEWPORTINFO
    ~0,                                          //  29  D3DDP2OP_WINFO
    ~0,                                          //  30  D3DDP2OP_SETPALETTE
    ~0,                                          //  31  D3DDP2OP_UPDATEPALETTE
    ~0,                                          //  32  D3DDP2OP_ZRANGE
    ~0,                                          //  33  D3DDP2OP_SETMATERIAL
    ~0,                                          //  34  D3DDP2OP_SETLIGHT
    ~0,                                          //  35  D3DDP2OP_CREATELIGHT
    ~0,                                          //  36  D3DDP2OP_SETTRANSFORM
    ~0,                                          //  37  D3DDP2OP_EXT
    ~0,                                          //  38  D3DDP2OP_TEXBLT
    ~0,                                          //  39  D3DDP2OP_STATESET
    ~0,                                          //  40  D3DDP2OP_SETPRIORITY
    ~0,                                          //  41  D3DDP2OP_SETRENDERTARGET
    ~0,                                          //  42  D3DDP2OP_CLEAR
    ~0,                                          //  43  D3DDP2OP_SETTEXLOD
    ~0                                           //  44  D3DDP2OP_SETCLIPPLANE
};

//---------------------------------------------------------------------------

// table mapping dp2ops to the scale and bias required to calculate the number
// of vertices from the number of primitives. the scale is in the upper half
// of the word and the bias is in the lower.
// numVertices = scale * numPrimitives + bias

DWORD celsiusPrimitiveToPrimitiveMagic[D3D_DP2OP_MAX+1] =
{
    ~0,                                          //   0  invalid
    0x00010100,                                  //   1  D3DDP2OP_POINTS
    0x00020200,                                  //   2  D3DDP2OP_INDEXEDLINELIST
    0x00030300,                                  //   3  D3DDP2OP_INDEXEDTRIANGLELIST
    ~0,                                          //   4  invalid
    ~0,                                          //   5  invalid
    ~0,                                          //   6  invalid
    ~0,                                          //   7  invalid
    ~0,                                          //   8  D3DDP2OP_RENDERSTATE
    ~0,                                          //   9  invalid
    ~0,                                          //  10  invalid
    ~0,                                          //  11  invalid
    ~0,                                          //  12  invalid
    ~0,                                          //  13  invalid
    ~0,                                          //  14  invalid
    0x00020200,                                  //  15  D3DDP2OP_LINELIST
    0x00020101,                                  //  16  D3DDP2OP_LINESTRIP
    0x00020101,                                  //  17  D3DDP2OP_INDEXEDLINESTRIP
    0x00030300,                                  //  18  D3DDP2OP_TRIANGLELIST
    0x40030102,                                  //  19  D3DDP2OP_TRIANGLESTRIP
    0x40030102,                                  //  20  D3DDP2OP_INDEXEDTRIANGLESTRIP
    0x80030102,                                  //  21  D3DDP2OP_TRIANGLEFAN
    0x80030102,                                  //  22  D3DDP2OP_INDEXEDTRIANGLEFAN
    0x80030102,                                  //  23  D3DDP2OP_TRIANGLEFAN_IMM
    0x00020200,                                  //  24  D3DDP2OP_LINELIST_IMM
    ~0,                                          //  25  D3DDP2OP_TEXTURESTAGESTATE
    0x00030300,                                  //  26  D3DDP2OP_INDEXEDTRIANGLELIST2
    0x00020200,                                  //  27  D3DDP2OP_INDEXEDLINELIST2
    ~0,                                          //  28  D3DDP2OP_VIEWPORTINFO
    ~0,                                          //  29  D3DDP2OP_WINFO
    ~0,                                          //  30  D3DDP2OP_SETPALETTE
    ~0,                                          //  31  D3DDP2OP_UPDATEPALETTE
    ~0,                                          //  32  D3DDP2OP_ZRANGE
    ~0,                                          //  33  D3DDP2OP_SETMATERIAL
    ~0,                                          //  34  D3DDP2OP_SETLIGHT
    ~0,                                          //  35  D3DDP2OP_CREATELIGHT
    ~0,                                          //  36  D3DDP2OP_SETTRANSFORM
    ~0,                                          //  37  D3DDP2OP_EXT
    ~0,                                          //  38  D3DDP2OP_TEXBLT
    ~0,                                          //  39  D3DDP2OP_STATESET
    ~0,                                          //  40  D3DDP2OP_SETPRIORITY
    ~0,                                          //  41  D3DDP2OP_SETRENDERTARGET
    ~0,                                          //  42  D3DDP2OP_CLEAR
    ~0,                                          //  43  D3DDP2OP_SETTEXLOD
    ~0                                           //  44  D3DDP2OP_SETCLIPPLANE
};

//---------------------------------------------------------------------------

// table mapping dp2ops to a name humans understand

#ifdef DEBUG
char* celsiusPrimitiveName[D3D_DP2OP_MAX+1] =
{
    "oops",                                      //   0  invalid
    "points",                                    //   1  D3DDP2OP_POINTS
    "indexed line list",                         //   2  D3DDP2OP_INDEXEDLINELIST
    "indexed tri list",                          //   3  D3DDP2OP_INDEXEDTRIANGLELIST
    "oops",                                      //   4  invalid
    "oops",                                      //   5  invalid
    "oops",                                      //   6  invalid
    "oops",                                      //   7  invalid
    "oops",                                      //   8  D3DDP2OP_RENDERSTATE
    "oops",                                      //   9  invalid
    "oops",                                      //  10  invalid
    "oops",                                      //  11  invalid
    "oops",                                      //  12  invalid
    "oops",                                      //  13  invalid
    "oops",                                      //  14  invalid
    "line list",                                 //  15  D3DDP2OP_LINELIST
    "line strip",                                //  16  D3DDP2OP_LINESTRIP
    "indexed line strip",                        //  17  D3DDP2OP_INDEXEDLINESTRIP
    "tri list",                                  //  18  D3DDP2OP_TRIANGLELIST
    "tri strip",                                 //  19  D3DDP2OP_TRIANGLESTRIP
    "indexed tri strip",                         //  20  D3DDP2OP_INDEXEDTRIANGLESTRIP
    "tri fan",                                   //  21  D3DDP2OP_TRIANGLEFAN
    "indexed tri fan",                           //  22  D3DDP2OP_INDEXEDTRIANGLEFAN
    "tri fan imm",                               //  23  D3DDP2OP_TRIANGLEFAN_IMM
    "line list imm",                             //  24  D3DDP2OP_LINELIST_IMM
    "oops",                                      //  25  D3DDP2OP_TEXTURESTAGESTATE
    "indexed tri list 2",                        //  26  D3DDP2OP_INDEXEDTRIANGLELIST2
    "indexed line list 2",                       //  27  D3DDP2OP_INDEXEDLINELIST2
    "oops",                                      //  28  D3DDP2OP_VIEWPORTINFO
    "oops",                                      //  29  D3DDP2OP_WINFO
    "oops",                                      //  30  D3DDP2OP_SETPALETTE
    "oops",                                      //  31  D3DDP2OP_UPDATEPALETTE
    "oops",                                      //  32  D3DDP2OP_ZRANGE
    "oops",                                      //  33  D3DDP2OP_SETMATERIAL
    "oops",                                      //  34  D3DDP2OP_SETLIGHT
    "oops",                                      //  35  D3DDP2OP_CREATELIGHT
    "oops",                                      //  36  D3DDP2OP_SETTRANSFORM
    "oops",                                      //  37  D3DDP2OP_EXT
    "oops",                                      //  38  D3DDP2OP_TEXBLT
    "oops",                                      //  39  D3DDP2OP_STATESET
    "oops",                                      //  40  D3DDP2OP_SETPRIORITY
    "oops",                                      //  41  D3DDP2OP_SETRENDERTARGET
    "oops",                                      //  42  D3DDP2OP_CLEAR
    "oops",                                      //  43  D3DDP2OP_SETTEXLOD
    "oops"                                       //  44  D3DDP2OP_SETCLIPPLANE
};
#endif

// table needed to dispatch the right method for vertex shaders
// [] . .  stream  - ie vertex vs diffuse
// . [] .  data type  - ie XYZ vs XYZW
// . . [0] method name
// . . [1] param count (popcount of second index)
DWORD dwCelsiusMethodDispatch[11][16][2] = {
        // 0 vertex
        0xDEADBEEF,                    0, //  0 none
        0xDEADBEEF,                    0, //  1 x
        0xDEADBEEF,                    0, //  2  y
        0xDEADBEEF,                    0, //  3 xy
        0xDEADBEEF,                    0, //  4   z
        0xDEADBEEF,                    0, //  5 x z
        0xDEADBEEF,                    0, //  6  yz
        NV056_SET_VERTEX3F(0),         3, //  7 xyz
        0xDEADBEEF,                    0, //  8    w
        0xDEADBEEF,                    0, //  9 x  w
        0xDEADBEEF,                    0, // 10  y w
        NV056_SET_VERTEX3F(0),         3, // 11 xy w
        0xDEADBEEF,                    0, // 12   zw
        0xDEADBEEF,                    0, // 13 x zw
        0xDEADBEEF,                    0, // 14  yzw
        NV056_SET_VERTEX4F(0),         4, // 15 xyzw

        // 1 diffuse
        0xDEADBEEF,                    0, //  0 none
        0xDEADBEEF,                    0, //  1 x
        0xDEADBEEF,                    0, //  2  y
        0xDEADBEEF,                    0, //  3 xy
        0xDEADBEEF,                    0, //  4   z
        0xDEADBEEF,                    0, //  5 x z
        0xDEADBEEF,                    0, //  6  yz
        NV056_SET_DIFFUSE_COLOR3F(0),  3, //  7 xyz
        0xDEADBEEF,                    0, //  8    w
        0xDEADBEEF,                    0, //  9 x  w
        0xDEADBEEF,                    0, // 10  y w
        NV056_SET_DIFFUSE_COLOR3F(0),  3, // 11 xy w
        0xDEADBEEF,                    0, // 12   zw
        0xDEADBEEF,                    0, // 13 x zw
        0xDEADBEEF,                    0, // 14  yzw
        NV056_SET_DIFFUSE_COLOR4F(0),  4, // 15 xyzw

        // 2 specular
        0xDEADBEEF,                    0, //  0 none
        0xDEADBEEF,                    0, //  1 x
        0xDEADBEEF,                    0, //  2  y
        0xDEADBEEF,                    0, //  3 xy
        0xDEADBEEF,                    0, //  4   z
        0xDEADBEEF,                    0, //  5 x z
        0xDEADBEEF,                    0, //  6  yz
        NV056_SET_SPECULAR_COLOR3F(0), 3, //  7 xyz
        0xDEADBEEF,                    0, //  8    w
        0xDEADBEEF,                    0, //  9 x  w
        0xDEADBEEF,                    0, // 10  y w
        NV056_SET_SPECULAR_COLOR3F(0), 3, // 11 xy w
        0xDEADBEEF,                    0, // 12   zw
        0xDEADBEEF,                    0, // 13 x zw
        0xDEADBEEF,                    0, // 14  yzw
        NV056_SET_SPECULAR_COLOR4F(0), 4, // 15 xyzw

        // 3 backfacing diffuse - unused
        0xDEADBEEF,                    0, //  0 none
        0xDEADBEEF,                    0, //  1 x
        0xDEADBEEF,                    0, //  2  y
        0xDEADBEEF,                    0, //  3 xy
        0xDEADBEEF,                    0, //  4   z
        0xDEADBEEF,                    0, //  5 x z
        0xDEADBEEF,                    0, //  6  yz
        0xDEADBEEF,                    0, //  7 xyz
        0xDEADBEEF,                    0, //  8    w
        0xDEADBEEF,                    0, //  9 x  w
        0xDEADBEEF,                    0, // 10  y w
        0xDEADBEEF,                    0, // 11 xy w
        0xDEADBEEF,                    0, // 12   zw
        0xDEADBEEF,                    0, // 13 x zw
        0xDEADBEEF,                    0, // 14  yzw
        0xDEADBEEF,                    0, // 15 xyzw

        // 4 backfacing specular - unused
        0xDEADBEEF,                    0, //  0 none
        0xDEADBEEF,                    0, //  1 x
        0xDEADBEEF,                    0, //  2  y
        0xDEADBEEF,                    0, //  3 xy
        0xDEADBEEF,                    0, //  4   z
        0xDEADBEEF,                    0, //  5 x z
        0xDEADBEEF,                    0, //  6  yz
        0xDEADBEEF,                    0, //  7 xyz
        0xDEADBEEF,                    0, //  8    w
        0xDEADBEEF,                    0, //  9 x  w
        0xDEADBEEF,                    0, // 10  y w
        0xDEADBEEF,                    0, // 11 xy w
        0xDEADBEEF,                    0, // 12   zw
        0xDEADBEEF,                    0, // 13 x zw
        0xDEADBEEF,                    0, // 14  yzw
        0xDEADBEEF,                    0, // 15 xyzw

        // 5 fog
        0xDEADBEEF,                    0, //  0 none
        NV056_SET_FOG1F,               1, //  1 x
        0xDEADBEEF,                    0, //  2  y
        0xDEADBEEF,                    0, //  3 xy
        0xDEADBEEF,                    0, //  4   z
        0xDEADBEEF,                    0, //  5 x z
        0xDEADBEEF,                    0, //  6  yz
        0xDEADBEEF,                    0, //  7 xyz
        0xDEADBEEF,                    0, //  8    w
        0xDEADBEEF,                    0, //  9 x  w
        0xDEADBEEF,                    0, // 10  y w
        0xDEADBEEF,                    0, // 11 xy w
        0xDEADBEEF,                    0, // 12   zw
        0xDEADBEEF,                    0, // 13 x zw
        0xDEADBEEF,                    0, // 14  yzw
        0xDEADBEEF,                    0, // 15 xyzw

        // 6 point size
        0xDEADBEEF,                    0, //  0 none
        NV056_SET_POINT_SIZE,          1, //  1 x
        0xDEADBEEF,                    0, //  2  y
        0xDEADBEEF,                    0, //  3 xy
        0xDEADBEEF,                    0, //  4   z
        0xDEADBEEF,                    0, //  5 x z
        0xDEADBEEF,                    0, //  6  yz
        0xDEADBEEF,                    0, //  7 xyz
        0xDEADBEEF,                    0, //  8    w
        0xDEADBEEF,                    0, //  9 x  w
        0xDEADBEEF,                    0, // 10  y w
        0xDEADBEEF,                    0, // 11 xy w
        0xDEADBEEF,                    0, // 12   zw
        0xDEADBEEF,                    0, // 13 x zw
        0xDEADBEEF,                    0, // 14  yzw
        0xDEADBEEF,                    0, // 15 xyzw

        // 7 texture 0
        0xDEADBEEF,                    0, //  0 none
        0xDEADBEEF,                    0, //  1 x
        0xDEADBEEF,                    0, //  2  y
        NV056_SET_TEXCOORD0_2F(0),     2, //  3 xy
        0xDEADBEEF,                    0, //  4   z
        NV056_SET_TEXCOORD0_2F(0),     2, //  5 x z
        NV056_SET_TEXCOORD0_2F(0),     2, //  6  yz
        0xDEADBEEF,                    0, //  7 xyz
        0xDEADBEEF,                    0, //  8    w
        NV056_SET_TEXCOORD0_2F(0),     2, //  9 x  w
        NV056_SET_TEXCOORD0_2F(0),     2, // 10  y w
        0xDEADBEEF,                    0, // 11 xy w
        NV056_SET_TEXCOORD0_2F(0),     2, // 12   zw
        0xDEADBEEF,                    0, // 13 x zw
        0xDEADBEEF,                    0, // 14  yzw
        NV056_SET_TEXCOORD0_4F(0),     4, // 15 xyzw

        // 8 texture 1
        0xDEADBEEF,                    0, //  0 none
        0xDEADBEEF,                    0, //  1 x
        0xDEADBEEF,                    0, //  2  y
        NV056_SET_TEXCOORD1_2F(0),     2, //  3 xy
        0xDEADBEEF,                    0, //  4   z
        NV056_SET_TEXCOORD1_2F(0),     2, //  5 x z
        NV056_SET_TEXCOORD1_2F(0),     2, //  6  yz
        0xDEADBEEF,                    0, //  7 xyz
        0xDEADBEEF,                    0, //  8    w
        NV056_SET_TEXCOORD1_2F(0),     2, //  9 x  w
        NV056_SET_TEXCOORD1_2F(0),     2, // 10  y w
        0xDEADBEEF,                    0, // 11 xy w
        NV056_SET_TEXCOORD1_2F(0),     2, // 12   zw
        0xDEADBEEF,                    0, // 13 x zw
        0xDEADBEEF,                    0, // 14  yzw
        NV056_SET_TEXCOORD1_4F(0),     4, // 15 xyzw
};

#endif  // NVARCH >= 0x010
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\ddraw\celsius\src\nvCelsiusPrim.cpp ===
/*
 * Copyright 1993-1998 NVIDIA, Corporation.  All rights reserved.
 * THE INFORMATION CONTAINED HEREIN IS PROPRIETARY AND CONFIDENTIAL TO
 * NVIDIA, CORPORATION.  USE, REPRODUCTION OR DISCLOSURE TO ANY THIRD PARTY
 * IS SUBJECT TO WRITTEN PRE-APPROVAL BY NVIDIA, CORPORATION.
 */
/********************************* Direct 3D *******************************\
*                                                                           *
* Module: nvCelsiusPrim.cpp                                                 *
*       Celsius primitive rendering routines.                               *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*       Craig Duttweiler        04Mar99         NV10 development            *
*                                                                           *
\***************************************************************************/
#include "nvprecomp.h"

#if (NVARCH >= 0x10)

//////////////////////////////////////////////////////////////////////////////
// switches
//
//#define FORCE_NULL                // force no work
//#define FORCE_FROMDVB_VERTICES    // force CPU copy of verts (may be slow if read from AGP or VID vertex buffers)

//////////////////////////////////////////////////////////////////////////////
// forward declarations
//
#ifdef FORCE_INLINE_VERTICES
void nvCelsiusDispatchIndexedPrimitiveInline    (PNVD3DCONTEXT       pContext,
                                                 WORD                wCount,
                                                 LPWORD              lpIndices,
                                                 BOOL                bLegacyStrides);
void nvCelsiusDispatchNonIndexedPrimitiveInline (PNVD3DCONTEXT       pContext,
                                                 WORD                wCount);
#endif


#ifdef PROFILE_LIST2STRIP
void profile_lists2strips(WORD PrimCount, LPWORD pIndices);
#endif

// helper function that takes a src texture and updates the destination with
// an inverted (both horizontally and vertically mirrored) copy of the source

static void nvInvertSwizzle (CTexture *pSrcText,CTexture *pDestText)
{
    BYTE *pSrc,*pDest,*pDestScrap,*pSrcScrap;
    DWORD x,y,dwSrc,dwSrc2;

    //make sure both textures have linear surfaces
    //hmm... what about mipmap case? ignore mip mapped
    //point sprites for now...
    pSrcText->updateLinearSurface();
    pSrcText->cpuLockLin(CSimpleSurface::LOCK_NORMAL);
    pDestText->updateLinearSurface();
    pDestText->cpuLockLin(CSimpleSurface::LOCK_NORMAL);
    pDestText->getSwizzled()->tagOutOfDate();
    //alrighty, both texture exist, linear copies are locked, do the bit twiddling...
    pSrc  = (BYTE *)(pSrcText->getLinear()->getfpVidMem() + (pSrcText->getHeight() * pSrcText->getPitch()) );
    pDest = (BYTE *)(pDestText->getLinear()->getfpVidMem() );
    for (y = 0; y < pSrcText->getHeight(); y++)
    {
        pSrcScrap = pSrc;
        pDestScrap = pDest;
        for (x=0; x < pSrcText->getWidth();x++)
        {
            pSrcScrap -= pSrcText->getBPP();
            switch(pSrcText->getBPP())
            {
                case 1:
                    *pDestScrap = *pSrcScrap;
                    break;
                case 2:
                    *(WORD *)pDestScrap = *(WORD *)pSrcScrap;
                    break;
                case 4:
                    *(DWORD *)pDestScrap = *(DWORD *)pSrcScrap;
                    break;
                case 8:
                    //DXT1
                    *(DWORD *)pDestScrap = *(DWORD *)pSrcScrap;
                    dwSrc = *(DWORD *)(pSrcScrap+4 );
                    *(DWORD *)(pDestScrap +4) = (
                        (dwSrc & 0xC0000000) >> 30 | (dwSrc & 0x30000000) >> 26 |
                        (dwSrc & 0x0C000000) >> 22 | (dwSrc & 0x03000000) >> 18 |
                        (dwSrc & 0x00C00000) >> 14 | (dwSrc & 0x00300000) >> 10 |
                        (dwSrc & 0x000C0000) >> 6  | (dwSrc & 0x00030000) >> 2  |
                        (dwSrc & 0x0000C000) << 2  | (dwSrc & 0x00003000) << 6  |
                        (dwSrc & 0x00000C00) << 10 | (dwSrc & 0x00000300) << 14 |
                        (dwSrc & 0x000000C0) << 18 | (dwSrc & 0x00000030) << 22 |
                        (dwSrc & 0x0000000C) << 26 | (dwSrc & 0x00000003) << 30);
                    break;
                case 16:
                    if (pSrcText->getFormat() == NV_SURFACE_FORMAT_DXT23_A8R8G8B8)
                    {
                        dwSrc = *(DWORD *)(pSrcScrap + 4);
                        *(DWORD *)(pDestScrap) = (
                          (dwSrc & 0xF0000000) >> 28 | (dwSrc & 0x0F000000) >> 20 |
                          (dwSrc & 0x00F00000) >> 12 | (dwSrc & 0x000F0000) >>  4 |
                          (dwSrc & 0x0000F000) <<  4 | (dwSrc & 0x00000F00) << 12 |
                          (dwSrc & 0x000000F0) << 20 | (dwSrc & 0x0000000F) << 28);
                        dwSrc = *(DWORD *)(pSrcScrap);
                        *(DWORD *)(pDestScrap + 4) = (
                          (dwSrc & 0xF0000000) >> 28 | (dwSrc & 0x0F000000) >> 20 |
                          (dwSrc & 0x00F00000) >> 12 | (dwSrc & 0x000F0000) >>  4 |
                          (dwSrc & 0x0000F000) <<  4 | (dwSrc & 0x00000F00) << 12 |
                          (dwSrc & 0x000000F0) << 20 | (dwSrc & 0x0000000F) << 28);
                    }
                    else
                    {
                        dwSrc = *(DWORD *)(pSrcScrap);
                        dwSrc2 = *(DWORD *)(pSrcScrap + 4);
                        *(DWORD *)(pDestScrap) = (
                        (dwSrc  & 0x0000FFFF) |
                        (dwSrc2 & 0xE0000000) >> 13 | (dwSrc2 & 0x1C000000) >> 7  |
                        (dwSrc2 & 0x03800000) >> 1  | (dwSrc2 & 0x00700000) << 5  |
                        (dwSrc2 & 0x000E0000) << 11 | (dwSrc2 & 0x0001C000) << 17);
                        *(DWORD *)(pDestScrap + 4) = (
                        (dwSrc2 & 0x0001C000) >> 15 | (dwSrc2 & 0x00003800) >> 9  |
                        (dwSrc2 & 0x00000700) >> 3  | (dwSrc2 & 0x000000E0) << 3  |
                        (dwSrc2 & 0x0000001C) << 9  | (dwSrc2 & 0x00000003) << 14 |
                        (dwSrc  & 0x80000000) >> 15 | (dwSrc  & 0x70000000) >> 11 |
                        (dwSrc  & 0x0E000000) >> 5  | (dwSrc  & 0x01C00000) << 1  |
                        (dwSrc  & 0x00380000) << 7  | (dwSrc  & 0x00070000) << 13);
                    }
                    *(DWORD *)(pDestScrap + 8) = *(DWORD *)(pSrcScrap + 8);
                    dwSrc = *(DWORD *)(pSrcScrap + 12 );
                    *(DWORD *)(pDestScrap + 12) = (
                        (dwSrc & 0xC0000000) >> 30 | (dwSrc & 0x30000000) >> 26 |
                        (dwSrc & 0x0C000000) >> 22 | (dwSrc & 0x03000000) >> 18 |
                        (dwSrc & 0x00C00000) >> 14 | (dwSrc & 0x00300000) >> 10 |
                        (dwSrc & 0x000C0000) >> 6  | (dwSrc & 0x00030000) >> 2  |
                        (dwSrc & 0x0000C000) << 2  | (dwSrc & 0x00003000) << 6  |
                        (dwSrc & 0x00000C00) << 10 | (dwSrc & 0x00000300) << 14 |
                        (dwSrc & 0x000000C0) << 18 | (dwSrc & 0x00000030) << 22 |
                        (dwSrc & 0x0000000C) << 26 | (dwSrc & 0x00000003) << 30);
                    break;
                default:
                    DPF ("unknown or unhandled texture bit depth in nvInvertSwizzle");
                    dbgD3DError();
                    pSrcText->cpuUnlockLin();
                    pDestText->cpuUnlockLin();
                    return;
                    break;
            }
            pDestScrap += pSrcText->getBPP();
        }
        pSrc -= pSrcText->getPitch();
        pDest += pSrcText->getPitch();
    }
    //unlock the textures and continue
    pSrcText->cpuUnlockLin();
    pDestText->cpuUnlockLin();
}

//helper function for point sprite texture
static void nvPreparePointSpriteTexture(PNVD3DCONTEXT pContext)
{
    //create the inverted texture

    if (((pContext->dp2.dwDP2Prim == D3DDP2OP_POINTS)  ||
         (pContext->dwRenderState[D3DRENDERSTATE_FILLMODE] == D3DFILL_POINT) ) &&
         (pContext->dwRenderState[D3DRS_POINTSPRITEENABLE] == TRUE) &&
         (pContext->tssState[0].dwValue[D3DTSS_TEXTUREMAP] ) &&
         ((DWORD)pContext->pCelsiusPointTexture != pContext->tssState[0].dwValue[D3DTSS_TEXTUREMAP]) )
    {
        if (pContext->dwPointHandle != pContext->tssState[0].dwValue[D3DTSS_TEXTUREMAP])
        {
            //we have to recreate the point texture
            CNvObject *pSrcObj = (CNvObject *)(pContext->tssState[0].dwValue[D3DTSS_TEXTUREMAP]);
            CTexture  *pBaseTexture = pSrcObj->getTexture();
            CNvObject *pNvObj   = new CNvObject (0);
            CNvObject *pCurrObj,*pNextObj;
            CTexture  *pPointTexture = new CTexture;
            CTexture  *pNextTexture;
            DWORD     dwMipCount;

            //check to see if the current streams/rendertarget/Z/textures need to be unlocked
            if(pContext->dwHWUnlockAllPending){ //HMH
                nvHWUnlockTextures (pContext);
                // need to mark all streams as in use by hardware...
                nvHWUnlockStreams (pContext, CELSIUS_CAPS_MAX_STREAMS);
                pContext->dwHWUnlockAllPending=FALSE;
            }

            if(pContext->pCelsiusPointTexture)
            {
                //destroy the old texture;
                pCurrObj=pContext->pCelsiusPointTexture;
                pNextObj=pCurrObj->getAttachedA();
                for (dwMipCount=1;dwMipCount < pContext->pCelsiusPointTexture->getTexture()->getMipMapCount();dwMipCount++ ) //destroy each mip map
                {
                    pCurrObj=pNextObj;
                    pNextObj=pCurrObj->getAttachedA();
                    pCurrObj->getTexture()->destroy();
                    pCurrObj->release();
                }
                pContext->pCelsiusPointTexture->getTexture()->destroy();
                pContext->pCelsiusPointTexture->release(); //call destructor
            }
            if (!pNvObj || !pPointTexture || !pBaseTexture) {
                //something went horribly wrong
                if (pNvObj) pNvObj->release();
                if (pPointTexture ) pPointTexture->destroy();
            }
            else
            {
#ifdef WINNT
                pNvObj->setDDSLcl(NULL);
#endif
                pNvObj->setObject (CNvObject::NVOBJ_TEXTURE, pPointTexture);
                pPointTexture->create (pNvObj,
                                       pBaseTexture->getWidth(),
                                       pBaseTexture->getHeight(),
                                       pBaseTexture->getDepth(),
                                       pBaseTexture->getBPP(),
                                       pBaseTexture->getBPP(),
                                       pBaseTexture->getMipMapCount(),
                                       pBaseTexture->getFormat(),
                                       pBaseTexture->getSwizzled()->getHeapLocation(),
                                       pBaseTexture->getSwizzled()->getHeapLocation());
                pPointTexture->setFourCC (pBaseTexture->getFourCC());
                //although this looks stupid, we have to do it for reset the control words
                pPointTexture->calculateNV056ControlWords();
                nvInvertSwizzle (pBaseTexture,pPointTexture);
                pCurrObj = pNvObj;
                for (dwMipCount=1;dwMipCount<pBaseTexture->getMipMapCount();dwMipCount++)
                {
                    pNextObj = new CNvObject(0);
                    pNextTexture = new CTexture;
                    pCurrObj->setAttachedA(pNextObj);
#ifdef WINNT
                    pNextObj->setDDSLcl(NULL);
#endif
                    pNextObj->setObject (CNvObject::NVOBJ_TEXTURE, pNextTexture);

                    pSrcObj = pSrcObj->getAttachedA();

                    if (!pNextObj || !pNextTexture) {
                        //something went horribly wrong
                        if (pNextObj) pNextObj->release();
                        if (pNextTexture ) pNextTexture->destroy();
                    }
                    else
                    {
                        pNextTexture->create(pNextObj,0,pPointTexture,dwMipCount);
                        pNextTexture->setFourCC (pBaseTexture->getFourCC());
                        pNextTexture->calculateNV056ControlWords();
                        nvInvertSwizzle(pSrcObj->getTexture(),pNextTexture);
                    }
                    pCurrObj = pCurrObj->getAttachedA();
                }
                pContext->pCelsiusPointTexture = pNvObj;
            }
            pContext->dwPointHandle = pContext->tssState[0].dwValue[D3DTSS_TEXTUREMAP];
        }
        //check to see if the current streams/rendertarget/Z/textures need to be unlocked
        if(pContext->dwHWUnlockAllPending){ //HMH
            nvHWUnlockTextures (pContext);
            // need to mark all streams as in use by hardware...
            nvHWUnlockStreams (pContext, CELSIUS_CAPS_MAX_STREAMS);
            pContext->dwHWUnlockAllPending=FALSE;
        }

        pContext->tssState[0].dwValue[D3DTSS_TEXTUREMAP] = (DWORD)pContext->pCelsiusPointTexture;
        pContext->hwState.dwDirtyFlags |= CELSIUS_DIRTY_TEXTURE_STATE |
                                          CELSIUS_DIRTY_TEXTURE_TRANSFORM |
                                          CELSIUS_DIRTY_COMBINERS;
    }
    if( (((pContext->dp2.dwDP2Prim != D3DDP2OP_POINTS) &&
          (pContext->dwRenderState[D3DRENDERSTATE_FILLMODE] != D3DFILL_POINT)) ||
        (pContext->dwRenderState[D3DRS_POINTSPRITEENABLE] != TRUE)) &&
        ( pContext->tssState[0].dwValue[D3DTSS_TEXTUREMAP]) &&
    pContext->tssState[0].dwValue[D3DTSS_TEXTUREMAP] == (DWORD)pContext->pCelsiusPointTexture)
    {
        //check to see if the current streams/rendertarget/Z/textures need to be unlocked
        if(pContext->dwHWUnlockAllPending){ //HMH
            nvHWUnlockTextures (pContext);
            // need to mark all streams as in use by hardware...
            nvHWUnlockStreams (pContext, CELSIUS_CAPS_MAX_STREAMS);
            pContext->dwHWUnlockAllPending=FALSE;
        }

        //oops, set the real texture
        pContext->tssState[0].dwValue[D3DTSS_TEXTUREMAP] = pContext->dwPointHandle;
        pContext->hwState.dwDirtyFlags |= CELSIUS_DIRTY_TEXTURE_STATE |
                                          CELSIUS_DIRTY_TEXTURE_TRANSFORM |
                                          CELSIUS_DIRTY_COMBINERS;
    }
}


/*****************************************************************************
 *****************************************************************************
 *** nvCelsiusDispatchIndexedPrimitive ****************************************
 *****************************************************************************
 *****************************************************************************/

void nvCelsiusDispatchIndexedPrimitive
(
    NV_INNERLOOP_ARGLIST
)
{
    BOOL bLegacyStrides;

#ifdef FORCE_NULL
    return;
#endif

    // any work?
    if (dwCount == 0) return;

    // we must at least have position data
    if (!pContext->ppDX8Streams[pContext->pCurrentVShader->getVAStream(defaultInputRegMap[D3DVSDE_POSITION])]) {
        DPF ("caught attempt to render without a position stream");
        nvAssert (0);
        // return;
    }

#ifdef INSTRUMENT_INNER_LOOPS
    CNVTimer sw;
    global.dwBytesCopied = 0;
    sw.start (0);
#endif

#ifdef PROFILE_LIST2STRIP
    profile_lists2strips(dwCount, pIndices);
#endif //PROFILE_LISTS2STRIPS

    bLegacyStrides = (pContext->dp2.dwDP2Prim == D3DDP2OP_INDEXEDTRIANGLELIST) ? TRUE : FALSE;

    // book keeping
    if (pContext->pZetaBuffer) {
        pContext->pZetaBuffer->getWrapper()->setCTDrawPrim();
    }

#if SYSVB2AGP
    DWORD bAltVBPerfStrategy = ((pContext->dwEarlyCopyStrategy == 6) || (pContext->dwEarlyCopyStrategy == 7) || (pContext->dwEarlyCopyStrategy > 0x20));

    if (bAltVBPerfStrategy) {

        if (pContext->dp2.dwDP2Prim == D3DDP2OP_INDEXEDTRIANGLELIST2 && pContext->dp2.dwVertexBufferOffset == 0)
        {
            if (!pContext->sysvb.pSysMemVB)
            {
                DWORD stream = pContext->hwState.pVertexShader->getVAStream(defaultInputRegMap[D3DVSDE_POSITION]);
                CVertexBuffer *pVertexBuffer = pContext->ppDX8Streams[stream];
                if (!pVertexBuffer->cachedhwCanRead())
                {

                    DWORD dwTotalSize = pContext->hwState.pVertexShader->getStride() * pContext->dp2.dwVertexLength;
                    if (dwTotalSize < pDriverData->nvD3DPerfData.dwRecommendedStageBufferSize)   // never fill more than 1/4 at once
                    {
                        pContext->sysvb.dwStreamDMACount = pContext->dwStreamDMACount;
                        pContext->dwStreamDMACount &= 0xffff;
                        // get default VB
                        CVertexBuffer *pDefVertexBuffer = getDC()->defaultVB.getVB();
                        DWORD stride = pContext->hwState.pVertexShader->getStride();

                        pDefVertexBuffer->setVertexStride(stride);

                        // check for space
                        DWORD dwVBOffset = (getDC()->defaultVB.waitForSpace(dwTotalSize + 64 * 12, TRUE) + 32) & ~31;
                        // copy verts
                        nvMemCopy (pDefVertexBuffer->getAddress() + dwVBOffset ,
                                   (DWORD)pVertexBuffer->getAddress(),
                                   dwTotalSize);
                        // set up supertri
                        pDefVertexBuffer->setSuperTriLookAsideBuffer ((void*)((DWORD)pVertexBuffer->getAddress()));
                        pContext->dp2.dwVertexBufferOffsetSave = pContext->dp2.dwVertexBufferOffset;
                        pContext->sysvb.dwDefVBOffset = pContext->dp2.dwVertexBufferOffset = dwVBOffset;

                        pContext->sysvb.pSysMemVB = pVertexBuffer;
                        pContext->sysvb.dwSysMemVBStream = stream;
                        pContext->ppDX8Streams[stream] = pDefVertexBuffer;

                        // unlock vb
                        getDC()->defaultVB.m_dwTotalVerticesSincePut += pContext->dp2.dwVertexLength;
                        if (getDC()->defaultVB.m_dwTotalVerticesSincePut >= 128)
                        {
                            pContext->sysvb.bWriteOffset = TRUE;
                            getDC()->defaultVB.m_dwTotalVerticesSincePut = 0;
                        }
                        getDC()->defaultVB.m_dwCurrentOffset = dwVBOffset + dwTotalSize;

                    }
                }
            }
            else
            {
                pContext->sysvb.dwStreamDMACount = pContext->dwStreamDMACount;
                pContext->dwStreamDMACount &= 0xffff;
                pContext->dp2.dwVertexBufferOffsetSave = pContext->dp2.dwVertexBufferOffset;
                pContext->dp2.dwVertexBufferOffset = pContext->sysvb.dwDefVBOffset;
                pContext->sysvb.pSysMemVB = pContext->ppDX8Streams[pContext->sysvb.dwSysMemVBStream];
                pContext->ppDX8Streams[pContext->sysvb.dwSysMemVBStream] = getDC()->defaultVB.getVB();
            }
        }
    }
#endif //SYSVB2AGP

    // set the vertex sources and if anything has changed, dirty the fvf flag
    if (pContext->hwState.dwVertexOffset != pContext->dp2.dwVertexBufferOffset) {
        pContext->hwState.dwDirtyFlags |= CELSIUS_DIRTY_FVF;
    }

    //this is code to fix the upside down point sprites on NV10/NV11/NV15
    //It is NOT fast/efficient/optimized
    //It will perform well assuming that there is a single small texture used for points
    //if the point texture changes this code will thrash horribly.
    //This is pretty much strictly to pass WHQL since asymetrical point sprites are
    //basically never seen in real world apps
    //
    //HMH
    nvPreparePointSpriteTexture(pContext);

    // lock surfaces for use by the HW
    nvHWLockTextures (pContext);
    nvHWLockStreams (pContext, CELSIUS_CAPS_MAX_STREAMS);

    // set celsius state (required to get the correct inner loop)
    nvSetCelsiusState (pContext);

#ifdef FORCE_INLINE_VERTICES

    nvCelsiusDispatchIndexedPrimitiveInline (pContext, dwCount, pIndices, bLegacyStrides);

#else // !FORCE_INLINE_VERTICES

    // get inner loop entry point flags
    DWORD dwFlags = (pContext->dp2.dwDP2Prim & CELSIUS_ILMASK_PRIMTYPE)
                  | (bLegacyStrides ? CELSIUS_ILFLAG_LEGACY : 0);

    if (pContext->hwState.dwInlineVertexStride) {

        // set up inner loops to inline vertices
        if (pContext->hwState.pVertexShader->hasProgram()
            || (NV_NUM_UNIQUE_STREAMS(pContext->dwStreamDMACount) > 1)
            || (NV_NUM_SYSTEM_STREAMS(pContext->dwStreamDMACount) > 1)) {
            dwFlags |= CELSIUS_ILFLAG_IX_STR_PRIM;
        }
        else if ((dwCount >= CELSIUS_SHORT_INDEXED_PRIM_COUNT_CUTOFF) &&
                 ((celsiusPrimitiveToPrimitiveMagic[pContext->dp2.dwDP2Prim] & 0x00ffffff) == 0x00030300))
        {
            if (NV_VERTEX_TRANSFORMED(pContext->hwState.pVertexShader)) {
                dwFlags |= CELSIUS_ILFLAG_IX_INL_TRI_LIST;
            }
            else {
                dwFlags |= CELSIUS_ILFLAG_IX_INL_PRIM;
            }
            dwFlags                    |= ((pContext->dwRenderState[D3DRENDERSTATE_CULLMODE] == D3DCULL_NONE) ? CELSIUS_ILFLAG_NOCULL : 0);
            global.celsius.dwCullValue  =  (pContext->dwRenderState[D3DRENDERSTATE_CULLMODE] == D3DCULL_CCW)  ? 0x80000000 : 0x00000000;
        }
        else {
            dwFlags |= CELSIUS_ILFLAG_IX_INL_PRIM;
        }
    }

    else {
        if (pContext->hwState.SuperTri.Strategy (pContext->dp2.dwDP2Prim, dwCount, pContext->hwState.pVertexShader))
        {
            dwFlags &= ~CELSIUS_ILMASK_LOOPTYPE;
            dwFlags |= CELSIUS_ILFLAG_SUPER_TRI_LIST;
        }
        else
        {
            dwFlags |= CELSIUS_ILFLAG_IX_VB_PRIM;
        }
    }


#ifdef LPC_OPT
    static DWORD savedFlags=0;
    if ((savedFlags == dwFlags) && (pDriverData->dwLastDP2 == pDriverData->dwThisDP2))
    {
        global.celsius.dwPrimCount           = dwCount;
        global.celsius.pIndices              = pContext->dp2.dwIndices;
        global.celsius.dwIndexStride         = pContext->dp2.dwIndexStride;

        // BUGBUG this won't work with vertex shaders
        // pVertices is used in the inline functions and needs the base vertex (dwVStart) built in.
        // pVertices is not used in the VB routines - they use dwBaseVertex
        global.celsius.pVertices             = pContext->hwState.ppStreams[0]->getAddress() +
            pContext->hwState.dwVertexOffset +
            pContext->dp2.dwVStart * pContext->hwState.ppStreams[0]->getVertexStride() +
            pContext->hwState.pVertexShader->getVAOffset(defaultInputRegMap[D3DVSDE_POSITION]);
        //set base vertex for use in VB Prim and super tri routines
        global.celsius.dwBaseVertex          = pContext->dp2.dwVStart;
        global.celsius.dwEyeAddr             = pContext->hwState.SuperTri.getEyeAddr();
        global.celsius.dwCullAddr            = pContext->hwState.SuperTri.getCullsignAddr();
    }
    else
#endif
    {
        // setup variables passed to innerloop
        global.celsius.pContext              = (DWORD)pContext;
        global.celsius.pContext_hwState      = (DWORD)&pContext->hwState;
        global.celsius.dwPrimCount           = dwCount;

        global.celsius.dwVertexStride        = pContext->hwState.pVertexShader->getStride();  // vertex stride of source data
        global.celsius.pIndices              = pContext->dp2.dwIndices;
        global.celsius.dwIndexStride         = pContext->dp2.dwIndexStride;
        // BUGBUG this won't work with vertex shaders
        // pVertices is used in the inline functions and needs the base vertex (dwVStart) built in.
        // pVertices is not used in the VB routines - they use dwBaseVertex
        global.celsius.pVertices             = pContext->hwState.ppStreams[pContext->hwState.pVertexShader->getVAStream(defaultInputRegMap[D3DVSDE_POSITION])]->getAddress() +
                                               pContext->hwState.dwVertexOffset +
                                               pContext->dp2.dwVStart * pContext->hwState.ppStreams[pContext->hwState.pVertexShader->getVAStream(defaultInputRegMap[D3DVSDE_POSITION])]->getVertexStride() +
                                               pContext->hwState.pVertexShader->getVAOffset(defaultInputRegMap[D3DVSDE_POSITION]);
        //set base vertex for use in VB Prim and super tri routines
        global.celsius.dwBaseVertex          = pContext->dp2.dwVStart;

        // set component offsets
        global.celsius.dwOffsetXYZ           = pContext->hwState.pVertexShader->getVAOffset(defaultInputRegMap[D3DVSDE_POSITION]);
        global.celsius.dwOffsetRHW           = pContext->hwState.pVertexShader->getVAOffset(defaultInputRegMap[D3DVSDE_POSITION]) + 3*sizeof(DWORD);
        global.celsius.dwOffsetDiffuse       = pContext->hwState.pVertexShader->getVAOffset(defaultInputRegMap[D3DVSDE_DIFFUSE]);
        global.celsius.dwOffsetSpecular      = pContext->hwState.pVertexShader->getVAOffset(defaultInputRegMap[D3DVSDE_SPECULAR]);
        global.celsius.dwOffsetNormal        = pContext->hwState.pVertexShader->getVAOffset(defaultInputRegMap[D3DVSDE_NORMAL]);
        global.celsius.dwOffsetWeight        = pContext->hwState.pVertexShader->getVAOffset(defaultInputRegMap[D3DVSDE_BLENDWEIGHT]);
        for (DWORD i=0; i<CELSIUS_CAPS_MAX_UV_PAIRS; i++) {
            global.celsius.dwOffsetUV[i]     = pContext->hwState.pVertexShader->getVAOffset(defaultInputRegMap[D3DVSDE_TEXCOORD0+i]);
        }

        global.celsius.dwEyeAddr             = pContext->hwState.SuperTri.getEyeAddr();
        global.celsius.dwCullAddr            = pContext->hwState.SuperTri.getCullsignAddr();


    }

    if ((dwFlags & CELSIUS_ILMASK_LOOPTYPE) == CELSIUS_ILFLAG_SUPER_TRI_LIST)
    {
        //
        // do preprocessing
        //
        dwFlags                    |= ((pContext->dwRenderState[D3DRENDERSTATE_CULLMODE] == D3DCULL_NONE) ? CELSIUS_ILFLAG_NOCULL : 0);
        global.celsius.dwCullValue  = (pContext->dwRenderState[D3DRENDERSTATE_CULLMODE] == D3DCULL_CCW)  ? 0x80000000 : 0x00000000;
        CVertexBuffer *pVertexBufferInUse = pContext->ppDX8Streams[pContext->hwState.pVertexShader->getVAStream(defaultInputRegMap[D3DVSDE_POSITION])];
        global.celsius.pVertices             = (DWORD) pVertexBufferInUse->getSuperTriLookAsideBuffer() +
                                               pContext->hwState.pVertexShader->getVAOffset(defaultInputRegMap[D3DVSDE_POSITION]);

    }


    // go
    CELSIUSDISPATCHPRIMITIVE pfn = nvCelsiusGetDispatchRoutine(pContext,dwFlags);
    if (pfn) pfn();

    // restore important values
    nvPusherAdjust (0);

#ifdef LPC_OPT
    savedFlags = dwFlags;
#endif

#endif // !FORCE_INLINE_VERTICES

    //set that we need to unlock all surfaces.  defer till we need to lower number of CPU
    //clocks per primitive.
    pContext->dwHWUnlockAllPending = TRUE;

#ifdef INSTRUMENT_INNER_LOOPS
    sw.stop (0);
    PF ("Prim=%d, VPS=%f",dwFlags & 0xffff,float(global.dwBytesCopied)/sw.getTime(0));
#endif

#if SYSVB2AGP
    if (pContext->sysvb.pSysMemVB)
    {
        DWORD stream = pContext->sysvb.dwSysMemVBStream;
        pContext->ppDX8Streams[pContext->sysvb.dwSysMemVBStream] = pContext->sysvb.pSysMemVB;
        pContext->sysvb.pSysMemVB = getDC()->defaultVB.getVB();
        pContext->dwStreamDMACount = pContext->sysvb.dwStreamDMACount;
        pContext->dp2.dwVertexBufferOffset = pContext->dp2.dwVertexBufferOffsetSave;
    }
#endif
}

/*****************************************************************************
 *****************************************************************************
 *** nvCelsiusDispatchNonIndexedPrimitive ************************************
 *****************************************************************************
 *****************************************************************************/
void nvCelsiusDispatchNonIndexedPrimitive
(
    NV_INNERLOOP_ARGLIST
)
{
#ifdef FORCE_NULL
    return;
#endif

    // any work?
    if (dwCount == 0) return;

    // we must at least have position data
    if (!pContext->ppDX8Streams[pContext->pCurrentVShader->getVAStream(defaultInputRegMap[D3DVSDE_POSITION])]) {
        DPF ("caught attempt to render without a position stream");
        nvAssert (0);
        return;
    }

#ifdef INSTRUMENT_INNER_LOOPS
    CNVTimer sw;
    global.dwBytesCopied = 0;
    sw.start (0);
#endif

    // book keeping
    if (pContext->pZetaBuffer) {
        pContext->pZetaBuffer->getWrapper()->setCTDrawPrim();
    }

    // set the vertex sources and if anything has changed, dirty the fvf flag
    if (pContext->hwState.dwVertexOffset != pContext->dp2.dwVertexBufferOffset) {
        pContext->hwState.dwDirtyFlags |= CELSIUS_DIRTY_FVF;
    }

    //this is code to fix the upside down point sprites on NV10/NV11/NV15
    //It is NOT fast/efficient/optimized
    //It will perform well assuming that there is a single small texture used for points
    //if the point texture changes this code will thrash horribly.
    //This is pretty much strictly to pass WHQL since asymetrical point sprites are
    //basically never seen in real world apps
    //
    //HMH
    nvPreparePointSpriteTexture(pContext);

    // lock surfaces for use by the HW
    nvHWLockTextures (pContext);
    nvHWLockStreams (pContext, CELSIUS_CAPS_MAX_STREAMS);

    // set celsius state (required to get the correct inner loop)
    nvSetCelsiusState (pContext);

#ifdef FORCE_INLINE_VERTICES

    nvCelsiusDispatchNonIndexedPrimitiveInline (pContext, dwCount);

#else // !FORCE_INLINE_VERTICES

    // get inner loop entry point flags
    DWORD dwFlags = (pContext->dp2.dwDP2Prim & CELSIUS_ILMASK_PRIMTYPE)
                  | ((pContext->dwRenderState[D3DRENDERSTATE_CULLMODE] == D3DCULL_NONE) ? CELSIUS_ILFLAG_NOCULL : 0);


    if (pContext->hwState.dwInlineVertexStride ) {

        // set up inner loops to inline vertices
        if (pContext->hwState.pVertexShader->hasProgram()
            || (NV_NUM_UNIQUE_STREAMS(pContext->dwStreamDMACount) > 1)
            || (NV_NUM_SYSTEM_STREAMS(pContext->dwStreamDMACount) > 1)) {
            dwFlags |= CELSIUS_ILFLAG_OR_STR_PRIM;
        }
        else {
            if ((dwCount >= CELSIUS_SHORT_ORDERED_PRIM_COUNT_CUTOFF)
             && (NV_VERTEX_TRANSFORMED(pContext->hwState.pVertexShader))
             && ((celsiusPrimitiveToPrimitiveMagic[pContext->dp2.dwDP2Prim] & 0x00ffffff) == 0x00030300)) {
                dwFlags |= CELSIUS_ILFLAG_OR_INL_TRI_LIST
                        |  ((pContext->dwRenderState[D3DRENDERSTATE_CULLMODE] == D3DCULL_NONE) ? CELSIUS_ILFLAG_NOCULL : 0);
                global.celsius.dwCullValue  = (pContext->dwRenderState[D3DRENDERSTATE_CULLMODE] == D3DCULL_CCW)  ? 0x80000000 : 0x00000000;
            }
            else {
                dwFlags |= CELSIUS_ILFLAG_OR_INL_PRIM;
            }
        }

    }

    else {

#ifdef LPC_OPT
        //hw can pull verts directly from vid mem
        if (pContext->hwState.ppStreams[0]->getContextDMA() == NV_CONTEXT_DMA_VID && dwCount < 40)
        {
            nvAssert (celsiusBeginEndOp[pContext->dp2.dwDP2Prim] != ~0);
            nvglSetNv10CelsiusBeginEnd (NV_DD_CELSIUS, celsiusBeginEndOp[pContext->dp2.dwDP2Prim]);

            DWORD dwScaleAndBias = celsiusPrimitiveToPrimitiveMagic[pContext->dp2.dwDP2Prim];
            nvAssert (dwScaleAndBias != ~0);
            DWORD dwNumVertices = (((dwScaleAndBias >> 8) & 0xff) * dwCount) + (dwScaleAndBias & 0xff);

            DWORD dwIndex = 0;
            if (dwNumVertices) {
                nvglSetNv10CelsiusDrawArrays (NV_DD_CELSIUS,
                    DRF_NUM(056, _DRAW_ARRAYS, _COUNT, dwNumVertices-1) |
                    DRF_NUM(056, _DRAW_ARRAYS, _START_INDEX, dwIndex + pContext->dp2.dwVStart));
            }

            nvglSetNv10CelsiusBeginEnd (NV_DD_CELSIUS, NV056_SET_BEGIN_END_OP_END);

            return;
        }
#endif
        // set up inner loops to pull vertices
        dwFlags |= CELSIUS_ILFLAG_OR_VB_PRIM;

    }

#ifdef LPC_OPT
    static DWORD savedFlags=0;
    if ((savedFlags == dwFlags) && (pDriverData->dwLastDP2 == pDriverData->dwThisDP2))
    {
        global.celsius.dwPrimCount           = dwCount;
        global.celsius.pIndices              = pContext->dp2.dwIndices;
        global.celsius.dwBaseVertex          = pContext->dp2.dwVStart;
        global.celsius.pVertices             =
            pContext->hwState.ppStreams[0]->getAddress() +
            pContext->hwState.dwVertexOffset +
            pContext->dp2.dwVStart * pContext->hwState.ppStreams[0]->getVertexStride() +
            pContext->hwState.pVertexShader->getVAOffset(defaultInputRegMap[D3DVSDE_POSITION]);


    }
    else
#endif
    {
        // setup variables passed to innerloop
        global.celsius.pContext              = (DWORD)pContext;
        global.celsius.pContext_hwState      = (DWORD)&pContext->hwState;
        global.celsius.dwPrimCount           = dwCount;
        global.celsius.dwVertexStride        = pContext->hwState.pVertexShader->getStride();  // vertex stride of source data
        global.celsius.pIndices              = pContext->dp2.dwIndices;
        global.celsius.dwIndexStride         = pContext->dp2.dwIndexStride;
        global.celsius.pVertices             = pContext->hwState.ppStreams[pContext->hwState.pVertexShader->getVAStream(defaultInputRegMap[D3DVSDE_POSITION])]->getAddress() +
                                               pContext->hwState.dwVertexOffset +
                                               pContext->dp2.dwVStart * pContext->hwState.ppStreams[pContext->hwState.pVertexShader->getVAStream(defaultInputRegMap[D3DVSDE_POSITION])]->getVertexStride() +
                                               pContext->hwState.pVertexShader->getVAOffset(defaultInputRegMap[D3DVSDE_POSITION]);
        //set base vertex
        global.celsius.dwBaseVertex          = pContext->dp2.dwVStart;
        // set component offsets
        global.celsius.dwOffsetXYZ           = pContext->hwState.pVertexShader->getVAOffset(defaultInputRegMap[D3DVSDE_POSITION]);
        global.celsius.dwOffsetRHW           = pContext->hwState.pVertexShader->getVAOffset(defaultInputRegMap[D3DVSDE_POSITION]) + 3*sizeof(DWORD);
        global.celsius.dwOffsetDiffuse       = pContext->hwState.pVertexShader->getVAOffset(defaultInputRegMap[D3DVSDE_DIFFUSE]);
        global.celsius.dwOffsetSpecular      = pContext->hwState.pVertexShader->getVAOffset(defaultInputRegMap[D3DVSDE_SPECULAR]);
        global.celsius.dwOffsetNormal        = pContext->hwState.pVertexShader->getVAOffset(defaultInputRegMap[D3DVSDE_NORMAL]);
        global.celsius.dwOffsetWeight        = pContext->hwState.pVertexShader->getVAOffset(defaultInputRegMap[D3DVSDE_BLENDWEIGHT]);
        for (DWORD i = 0; i < 7; i++) {
            global.celsius.dwOffsetUV[i]     = pContext->hwState.pVertexShader->getVAOffset(defaultInputRegMap[D3DVSDE_TEXCOORD0+i]);
        }

    }

    // go
    CELSIUSDISPATCHPRIMITIVE pfn = nvCelsiusGetDispatchRoutine(pContext,dwFlags);
    if (pfn) pfn();

    // restore pusher
    nvPusherAdjust (0);

#ifdef LPC_OPT
    savedFlags = dwFlags;
#endif

#endif // !FORCE_INLINE_VERTICES
    //set that we need to unlock all surfaces.  defer till we need to to lower number of CPU
    //clocks per primitive.
    pContext->dwHWUnlockAllPending = TRUE;
#ifdef INSTRUMENT_INNER_LOOPS
    sw.stop (0);
    PF ("Prim=%d, VPS=%f",dwFlags & 0xffff,float(global.dwBytesCopied)/sw.getTime(0));
#endif

}

/*****************************************************************************
 *****************************************************************************
 *** nvCelsiusDispatchLegacyWireframePrimitive *******************************
 *****************************************************************************
 *****************************************************************************/

void nvCelsiusDispatchLegacyWireframePrimitive
(
    NV_INNERLOOP_ARGLIST
)
{
    // this routine handles DX5 primitives in wireframe mode, which may
    // have edge flags. we don't really care much about being efficient here.

    nvAssert (pContext->dwRenderState[D3DRENDERSTATE_FILLMODE] == D3DFILL_WIREFRAME);

    DWORD dwCachedDP2Op     = pContext->dp2.dwDP2Prim;
    pContext->dp2.dwDP2Prim = D3DDP2OP_INDEXEDLINELIST;

    if (dwCachedDP2Op == D3DDP2OP_INDEXEDTRIANGLELIST) {

        LPD3DHAL_DP2INDEXEDTRIANGLELIST pTriListData;
        DWORD dwEdge;
        WORD  wIndicesIn[3];
        WORD  wIndicesOut[2];

        pTriListData = (LPD3DHAL_DP2INDEXEDTRIANGLELIST)(pContext->dp2.dwIndices);
        pContext->dp2.dwIndices     = (DWORD)(&(wIndicesOut[0]));
        pContext->dp2.dwIndexStride = 2;

        while (dwCount) {

            wIndicesIn[0] = pTriListData->wV1;
            wIndicesIn[1] = pTriListData->wV2;
            wIndicesIn[2] = pTriListData->wV3;

            for (dwEdge=0; dwEdge<3; dwEdge++) {
                if (pTriListData->wFlags & (D3DTRIFLAG_EDGEENABLE1 << dwEdge)) {
                    wIndicesOut[0] = wIndicesIn [(dwEdge+0) % 3];
                    wIndicesOut[1] = wIndicesIn [(dwEdge+1) % 3];
                    nvCelsiusDispatchIndexedPrimitive (pContext, 1);
                }
            }

            pTriListData ++;
            dwCount --;

        }

    }

    else if ((dwCachedDP2Op == D3DDP2OP_TRIANGLEFAN_IMM) || (dwCachedDP2Op == D3DDP2OP_TRIANGLEFAN)) {

        DWORD dwEdgeFlags, dwEdgeMask;
        WORD  wTriNum;
        WORD  wIndicesOut[2];

        nvAssert (dwCount < 32);

        dwEdgeFlags = pContext->dp2.dwEdgeFlags;
        dwEdgeMask  = 0x1;

        pContext->dp2.dwIndices     = (DWORD)(&(wIndicesOut[0]));
        pContext->dp2.dwIndexStride = 2;

        // we never draw edge v0-v1 for anything but the first triangle
        wIndicesOut[0] = 1;
        wIndicesOut[1] = 0;
        if (dwEdgeFlags & dwEdgeMask) {
            nvCelsiusDispatchIndexedPrimitive (pContext, 1);
            dbgFlushType (NVDBG_FLUSH_PRIMITIVE);
        }
        dwEdgeMask <<= 1;

        // we may draw edge v1-v2 for any or all triangles
        for (wTriNum=0; wTriNum<dwCount; wTriNum++) {
            wIndicesOut[0] = wTriNum+1;
            wIndicesOut[1] = wTriNum+2;
            if (dwEdgeFlags & dwEdgeMask) {
                nvCelsiusDispatchIndexedPrimitive (pContext, 1);
                dbgFlushType (NVDBG_FLUSH_PRIMITIVE);
            }
            dwEdgeMask <<= 1;
        }

        // we never draw edge v2-v0 for anything but the last triangle
        wIndicesOut[0] = dwCount+1;
        wIndicesOut[1] = 0;
        if (dwEdgeFlags & dwEdgeMask) {
            nvCelsiusDispatchIndexedPrimitive (pContext, 1);
            dbgFlushType (NVDBG_FLUSH_PRIMITIVE);
        }
        dwEdgeMask <<= 1;

    }

    else {

        // we don't handle any other legacy primitives
        nvAssert (0);

    }

    pContext->dp2.dwDP2Prim = dwCachedDP2Op;

}

/*****************************************************************************
 *****************************************************************************
 *** Inline Vertex Code ******************************************************
 *****************************************************************************
 *****************************************************************************/

#ifdef FORCE_INLINE_VERTICES

// this code is typically unused. it's used only for debugging
// purposes if FORCE_INLINE_VERTICES is defined

//---------------------------------------------------------------------------

// table mapping dp2ops to the scale and bias required to calculate the number
// of vertices from the number of primitives. the scale is in the upper half
// of the word and the bias is in the lower.
// numVertices = scale * numPrimitives + bias

DWORD celsiusPrimitiveToVertexCountScaleAndBias[D3D_DP2OP_MAX+1] =
{
    ~0,                                          //   0  invalid
    0x00010000,                                  //   1  D3DDP2OP_POINTS
    0x00020000,                                  //   2  D3DDP2OP_INDEXEDLINELIST
    0x00030000,                                  //   3  D3DDP2OP_INDEXEDTRIANGLELIST
    ~0,                                          //   4  invalid
    ~0,                                          //   5  invalid
    ~0,                                          //   6  invalid
    ~0,                                          //   7  invalid
    ~0,                                          //   8  D3DDP2OP_RENDERSTATE
    ~0,                                          //   9  invalid
    ~0,                                          //  10  invalid
    ~0,                                          //  11  invalid
    ~0,                                          //  12  invalid
    ~0,                                          //  13  invalid
    ~0,                                          //  14  invalid
    0x00020000,                                  //  15  D3DDP2OP_LINELIST
    0x00010001,                                  //  16  D3DDP2OP_LINESTRIP
    0x00010001,                                  //  17  D3DDP2OP_INDEXEDLINESTRIP
    0x00030000,                                  //  18  D3DDP2OP_TRIANGLELIST
    0x00010002,                                  //  19  D3DDP2OP_TRIANGLESTRIP
    0x00010002,                                  //  20  D3DDP2OP_INDEXEDTRIANGLESTRIP
    0x00010002,                                  //  21  D3DDP2OP_TRIANGLEFAN
    0x00010002,                                  //  22  D3DDP2OP_INDEXEDTRIANGLEFAN
    0x00010002,                                  //  23  D3DDP2OP_TRIANGLEFAN_IMM
    0x00020000,                                  //  24  D3DDP2OP_LINELIST_IMM
    ~0,                                          //  25  D3DDP2OP_TEXTURESTAGESTATE
    0x00030000,                                  //  26  D3DDP2OP_INDEXEDTRIANGLELIST2
    0x00020000,                                  //  27  D3DDP2OP_INDEXEDLINELIST2
    ~0,                                          //  28  D3DDP2OP_VIEWPORTINFO
    ~0,                                          //  29  D3DDP2OP_WINFO
    ~0,                                          //  30  D3DDP2OP_SETPALETTE
    ~0,                                          //  31  D3DDP2OP_UPDATEPALETTE
    ~0,                                          //  32  D3DDP2OP_ZRANGE
    ~0,                                          //  33  D3DDP2OP_SETMATERIAL
    ~0,                                          //  34  D3DDP2OP_SETLIGHT
    ~0,                                          //  35  D3DDP2OP_CREATELIGHT
    ~0,                                          //  36  D3DDP2OP_SETTRANSFORM
    ~0,                                          //  37  D3DDP2OP_EXT
    ~0,                                          //  38  D3DDP2OP_TEXBLT
    ~0,                                          //  39  D3DDP2OP_STATESET
    ~0,                                          //  40  D3DDP2OP_SETPRIORITY
    ~0,                                          //  41  D3DDP2OP_SETRENDERTARGET
    ~0,                                          //  42  D3DDP2OP_CLEAR
    ~0,                                          //  43  D3DDP2OP_SETTEXLOD
    ~0                                           //  44  D3DDP2OP_SETCLIPPLANE
};

//---------------------------------------------------------------------------

// dumps one FVF vertex into the push buffer with the components in the order
// celsius requires. note that adequate push buffer space is assumed to have
// been verified already!

void nvCelsiusDumpInlineVertex
(
    PNVD3DCONTEXT pContext,
    DWORD         dwIndex
)
{
    CVertexShader  *pShader;
    CVertexBuffer **ppStreams;
    DWORD           dwStreamSelector;
    DWORD           dwVertexBufferOffset;
    DWORD           dwBaseVertex;
    D3DTLVERTEX     vertex;
    DWORD           pComponent;
    DWORD           i, j, n;
    DWORD           dwD3DStage, dwTCIndex, dwVAIndex;

    pShader              = pContext->hwState.pVertexShader;
    ppStreams            = pContext->hwState.ppStreams;
    dwVertexBufferOffset = pContext->hwState.dwVertexOffset;
    dwBaseVertex         = pContext->dp2.dwVStart;
    j=0;
    memset (&vertex, 0, sizeof(D3DTLVERTEX));

    // weights
    dwStreamSelector = pShader->getVAStream (defaultInputRegMap[D3DVSDE_BLENDWEIGHT]);
    if ((dwStreamSelector != CVertexShader::VA_STREAM_NONE) && (ppStreams[dwStreamSelector])) {
        pComponent = ppStreams[dwStreamSelector]->getAddress()                      // address of buffer
                   + dwVertexBufferOffset                                           // global offset within buffer
                   + dwBaseVertex * ppStreams[dwStreamSelector]->getVertexStride()
                   + pShader->getVAOffset (defaultInputRegMap[D3DVSDE_BLENDWEIGHT]) // offset of this component
                   + dwIndex*ppStreams[dwStreamSelector]->getVertexStride();        // offset of this particular vertex
        for (i=0; i<1; i++) { nvglSetData (j, ((LPDWORD)pComponent)[i]); j++; }
    }

    // normal
    dwStreamSelector = pShader->getVAStream (defaultInputRegMap[D3DVSDE_NORMAL]);
    if ((dwStreamSelector != CVertexShader::VA_STREAM_NONE) && (ppStreams[dwStreamSelector])) {
        pComponent = ppStreams[dwStreamSelector]->getAddress()                      // address of buffer
                   + dwVertexBufferOffset                                           // global offset within buffer
                   + dwBaseVertex * ppStreams[dwStreamSelector]->getVertexStride()
                   + pShader->getVAOffset (defaultInputRegMap[D3DVSDE_NORMAL])      // offset of this component
                   + dwIndex*ppStreams[dwStreamSelector]->getVertexStride();        // offset of this particular vertex
        for (i=0; i<3; i++) { nvglSetData (j, ((LPDWORD)pComponent)[i]); j++; }
    }

    // tex1 coords
    if (pContext->hwState.dwStateFlags & CELSIUS_FLAG_USERTEXCOORDSNEEDED(1)) {
        dwD3DStage = pContext->hwState.dwTexUnitToTexStageMapping[1];
        nvAssert (dwD3DStage != CELSIUS_UNUSED);
        dwTCIndex  = (pContext->hwState.dwTexCoordIndices >> 16) & 0xffff;
        dwVAIndex  = defaultInputRegMap[D3DVSDE_TEXCOORD0+dwTCIndex];
        dwStreamSelector = pShader->getVAStream (dwVAIndex);
        nvAssert ((dwStreamSelector != CVertexShader::VA_STREAM_NONE) && (ppStreams[dwStreamSelector])); // they better have given us coordinates
        pComponent = ppStreams[dwStreamSelector]->getAddress()                      // address of buffer
                   + dwVertexBufferOffset                                           // global offset within buffer
                   + dwBaseVertex * ppStreams[dwStreamSelector]->getVertexStride()
                   + pShader->getVAOffset (dwVAIndex)                               // offset of this component
                   + dwIndex*ppStreams[dwStreamSelector]->getVertexStride();        // offset of this particular vertex
        n = (pContext->hwState.dwStateFlags & (CELSIUS_FLAG_PASSTHROUGHCUBEMAPPING(1) | CELSIUS_FLAG_TEXMATRIXSWFIX(1))) ?
            4 : (pShader->getVASize (dwVAIndex) / sizeof(DWORD));

        for (i=0; i<n; i++) { nvglSetData (j, ((LPDWORD)pComponent)[i]); j++; }
#ifdef STOMP_TEX_COORDS
        if (pContext->hwState.dwStateFlags & CELSIUS_FLAG_STOMP_4TH_COORD(1)) nvglSetData (3, 0x3f800000);
#endif  // STOMP_TEX_COORDS
    }

    // tex0 coords
    if (pContext->hwState.dwStateFlags & CELSIUS_FLAG_USERTEXCOORDSNEEDED(0)) {
        dwD3DStage = pContext->hwState.dwTexUnitToTexStageMapping[0];
        nvAssert (dwD3DStage != CELSIUS_UNUSED);
        dwTCIndex  = (pContext->hwState.dwTexCoordIndices >> 0) & 0xffff;
        dwVAIndex  = defaultInputRegMap[D3DVSDE_TEXCOORD0+dwTCIndex];
        dwStreamSelector = pShader->getVAStream (dwVAIndex);
        nvAssert ((dwStreamSelector != CVertexShader::VA_STREAM_NONE) && (ppStreams[dwStreamSelector])); // they better have given us coordinates
        pComponent = ppStreams[dwStreamSelector]->getAddress()                      // address of buffer
                   + dwVertexBufferOffset                                           // global offset within buffer
                   + dwBaseVertex * ppStreams[dwStreamSelector]->getVertexStride()
                   + pShader->getVAOffset (dwVAIndex)                               // offset of this component
                   + dwIndex*ppStreams[dwStreamSelector]->getVertexStride();        // offset of this particular vertex
        n = (pContext->hwState.dwStateFlags & (CELSIUS_FLAG_PASSTHROUGHCUBEMAPPING(0) | CELSIUS_FLAG_TEXMATRIXSWFIX(0))) ?
            4 : (pShader->getVASize (dwVAIndex) / sizeof(DWORD));

        for (i=0; i<n; i++) { nvglSetData (j, ((LPDWORD)pComponent)[i]); j++; }
#ifdef STOMP_TEX_COORDS
        if (pContext->hwState.dwStateFlags & CELSIUS_FLAG_STOMP_4TH_COORD(0)) nvglSetData (3, 0x3f800000);
#endif  // STOMP_TEX_COORDS

        vertex.tu = FLOAT_FROM_DWORD(((LPDWORD)pComponent)[0]);
        vertex.tv = FLOAT_FROM_DWORD(((LPDWORD)pComponent)[1]);
    }

    // specular
    dwStreamSelector = pShader->getVAStream (defaultInputRegMap[D3DVSDE_SPECULAR]);
    if ((dwStreamSelector != CVertexShader::VA_STREAM_NONE) && (ppStreams[dwStreamSelector])) {
        pComponent = ppStreams[dwStreamSelector]->getAddress()                      // address of buffer
                   + dwVertexBufferOffset                                           // global offset within buffer
                   + dwBaseVertex * ppStreams[dwStreamSelector]->getVertexStride()
                   + pShader->getVAOffset (defaultInputRegMap[D3DVSDE_SPECULAR])    // offset of this component
                   + dwIndex*ppStreams[dwStreamSelector]->getVertexStride();        // offset of this particular vertex
        for (i=0; i<1; i++) { nvglSetData (j, ((LPDWORD)pComponent)[i]); j++; }
        vertex.specular = ((LPDWORD)pComponent)[0];
    }

    // diffuse
    dwStreamSelector = pShader->getVAStream (defaultInputRegMap[D3DVSDE_DIFFUSE]);
    if ((dwStreamSelector != CVertexShader::VA_STREAM_NONE) && (ppStreams[dwStreamSelector])) {
        pComponent = ppStreams[dwStreamSelector]->getAddress()                      // address of buffer
                   + dwVertexBufferOffset                                           // global offset within buffer
                   + dwBaseVertex * ppStreams[dwStreamSelector]->getVertexStride()
                   + pShader->getVAOffset (defaultInputRegMap[D3DVSDE_DIFFUSE])     // offset of this component
                   + dwIndex*ppStreams[dwStreamSelector]->getVertexStride();        // offset of this particular vertex
        for (i=0; i<1; i++) { nvglSetData (j, ((LPDWORD)pComponent)[i]); j++; }
        vertex.color = ((LPDWORD)pComponent)[0];
    }

    // x,y,z
    dwStreamSelector = pShader->getVAStream (defaultInputRegMap[D3DVSDE_POSITION]);
    nvAssert ((dwStreamSelector != CVertexShader::VA_STREAM_NONE) && (ppStreams[dwStreamSelector]));
    pComponent = ppStreams[dwStreamSelector]->getAddress()                          // address of buffer
               + dwVertexBufferOffset                                               // global offset within buffer
               + dwBaseVertex * ppStreams[dwStreamSelector]->getVertexStride()
               + pShader->getVAOffset (defaultInputRegMap[D3DVSDE_POSITION])        // offset of this component
               + dwIndex*ppStreams[dwStreamSelector]->getVertexStride();            // offset of this particular vertex
    for (i=0; i<3; i++) { nvglSetData (j, ((LPDWORD)pComponent)[i]); j++; }
    vertex.sx = FLOAT_FROM_DWORD(((LPDWORD)pComponent)[0]);
    vertex.sy = FLOAT_FROM_DWORD(((LPDWORD)pComponent)[1]);
    vertex.sz = FLOAT_FROM_DWORD(((LPDWORD)pComponent)[2]);
#ifdef CHECK_DEPTHS
    if (pContext->hwState.dwStateFlags & CELSIUS_FLAG_PASSTHROUGHMODE) {
        float fz = FLOAT_FROM_DWORD(((LPDWORD)pComponent)[2]);
        if ((fz < 0.f) || (fz > 1.f)) {
            DPF ("unbiased z=%f is out of bounds", fz);
        }
        if (pContext->dwRenderState[D3DRENDERSTATE_ZBIAS] && pContext->hwState.celsius.dwZEnable) {
            float fZBias  = -(float)(pContext->dwRenderState[D3DRENDERSTATE_ZBIAS]);
            float fZScale = 0.25f * fZBias;
            fZBias  *= pContext->hwState.dvInvZScale;
            fZScale *= pContext->hwState.dvInvZScale;
            fz = fZScale*fz + fZBias;
            if ((fz < 0.f) || (fz > 1.f)) {
                DPF ("biased z'=%f is out of bounds", fz);
            }
        }
    }
#endif  // CHECK_DEPTHS

    // w
    if (pShader->getVASize (defaultInputRegMap[D3DVSDE_POSITION]) == 4*sizeof(DWORD)) {
        pComponent += 3*sizeof(DWORD);
        for (i=0; i<1; i++) { nvglSetData (j, ((LPDWORD)pComponent)[i]); j++; }
        vertex.rhw = FLOAT_FROM_DWORD(((LPDWORD)pComponent)[0]);
#ifdef CHECK_DEPTHS
        if (pContext->hwState.dwStateFlags & CELSIUS_FLAG_PASSTHROUGHMODE) {
            float frhw = FLOAT_FROM_DWORD(((LPDWORD)pComponent)[0]);
            if (frhw < 0.f) {
                DPF ("rhw=%f is out of bounds", frhw);
            }
        }
#endif  // CHECK_DEPTHS
    }

    dbgDisplayVertexData (FALSE, (DWORD*)(&vertex));

    nvAssert (j == (pContext->hwState.dwInlineVertexStride >> 2));
    getDC()->nvPusher.inc (j);
}

//---------------------------------------------------------------------------

// dumps a block of 'count' non-indexed vertices starting with index 'i0'

void nvCelsiusDumpNonIndexedInlineVertexBlock
(
    PNVD3DCONTEXT pContext,
    DWORD         i0,
    DWORD         count,
    DWORD         dwInlineVertexStride
)
{
    DWORD methodCount;

    methodCount = count * dwInlineVertexStride;  // number of 4-byte words
    assert (methodCount <= 2048);

    getDC()->nvPusher.makeSpace (sizeSetStartMethod + methodCount);
    nvglSetStartMethod (0, NV_DD_CELSIUS, NVPUSHER_NOINC(NV056_INLINE_ARRAY(0)), methodCount);
    getDC()->nvPusher.inc (sizeSetStartMethod);

    for (DWORD i=i0; i<i0+count; i++) {
        nvCelsiusDumpInlineVertex (pContext, i);
    }
}

//---------------------------------------------------------------------------

// dumps a block of 'count' indexed vertices beginning with index 'i0'

void nvCelsiusDumpIndexedInlineVertexBlock
(
    PNVD3DCONTEXT pContext,
    LPWORD        lpIndices,
    DWORD         i0,
    DWORD         count,
    BOOL          bLegacyStrides,
    DWORD         dwInlineVertexStride
)
{
    DWORD methodCount;

    methodCount = count * dwInlineVertexStride;  // number of 4-byte words
    assert (methodCount <= 2048);

    getDC()->nvPusher.makeSpace (sizeSetStartMethod + methodCount);
    nvglSetStartMethod (0, NV_DD_CELSIUS, NVPUSHER_NOINC(NV056_INLINE_ARRAY(0)), methodCount);
    getDC()->nvPusher.inc (sizeSetStartMethod);

    if (bLegacyStrides) {
        DWORD i1;
        // stupid old style indexing - {index16:index16 index16:junk16} repeat
        for (DWORD i=i0; i < (i0+count); i++) {
            i1 = 4*i / 3;  // offset of the i'th index
            nvCelsiusDumpInlineVertex (pContext, lpIndices[i1]);
        }
    }
    else {
        // new indexing - fully packed
        for (DWORD i=i0; i < (i0+count); i++) {
            nvCelsiusDumpInlineVertex (pContext, lpIndices[i]);
        }
    }
}

//---------------------------------------------------------------------------

void nvCelsiusDispatchNonIndexedPrimitiveInline
(
    PNVD3DCONTEXT       pContext,
    WORD                dwCount
)
{
    DWORD numVertices, emittedVertices, dwScaleAndBias, dwInlineVertexStride;

    dwInlineVertexStride = pContext->hwState.dwInlineVertexStride >> 2;

    nvAssert (celsiusBeginEndOp[pContext->dp2.dwDP2Prim] != ~0);
    nvglSetNv10CelsiusBeginEnd4 (NV_DD_CELSIUS, celsiusBeginEndOp[pContext->dp2.dwDP2Prim]);

    dwScaleAndBias = celsiusPrimitiveToVertexCountScaleAndBias[pContext->dp2.dwDP2Prim];
    nvAssert (dwScaleAndBias != ~0);
    numVertices = (dwScaleAndBias >> 16) * dwCount + (dwScaleAndBias & 0xffff);

    emittedVertices = 0;

    while (numVertices > CELSIUS_MAX_INLINE_VERTICES) {
        // attempt to kick off some work already
        nvPusherStart (FALSE);
        // send more vertices
        nvCelsiusDumpNonIndexedInlineVertexBlock (pContext, emittedVertices, CELSIUS_MAX_INLINE_VERTICES, dwInlineVertexStride);
        emittedVertices += CELSIUS_MAX_INLINE_VERTICES;
        numVertices -= CELSIUS_MAX_INLINE_VERTICES;
    }

    nvCelsiusDumpNonIndexedInlineVertexBlock (pContext, emittedVertices, numVertices, dwInlineVertexStride);

    nvglSetNv10CelsiusBeginEnd4 (NV_DD_CELSIUS, NV056_SET_BEGIN_END4_OP_END);

    // attempt to kick off some work already
    nvPusherStart (FALSE);
}

//---------------------------------------------------------------------------

void nvCelsiusDispatchIndexedPrimitiveInline
(
    PNVD3DCONTEXT       pContext,
    DWORD               dwCount,
    LPWORD              lpIndices,
    BOOL                bLegacyStrides
)
{
    DWORD numVertices, emittedVertices, dwScaleAndBias, dwInlineVertexStride;

    dwInlineVertexStride = pContext->hwState.dwInlineVertexStride >> 2;

    // tell the hardware what kind of thing we're going to draw
    nvAssert (celsiusBeginEndOp[pContext->dp2.dwDP2Prim] != ~0);
    nvglSetNv10CelsiusBeginEnd4 (NV_DD_CELSIUS, celsiusBeginEndOp[pContext->dp2.dwDP2Prim]);

    // determine the number of vertices
    dwScaleAndBias = celsiusPrimitiveToVertexCountScaleAndBias[pContext->dp2.dwDP2Prim];
    nvAssert (dwScaleAndBias != ~0);
    numVertices = (dwScaleAndBias >> 16) * dwCount + (dwScaleAndBias & 0xffff);

    emittedVertices = 0;

    while (numVertices > CELSIUS_MAX_INLINE_VERTICES) {
        // attempt to kick off some work already
        nvPusherStart (FALSE);
        // send more vertices
        nvCelsiusDumpIndexedInlineVertexBlock (pContext, lpIndices, emittedVertices,
                                               CELSIUS_MAX_INLINE_VERTICES, bLegacyStrides, dwInlineVertexStride);
        emittedVertices += CELSIUS_MAX_INLINE_VERTICES;
        numVertices -= CELSIUS_MAX_INLINE_VERTICES;
    }

    nvCelsiusDumpIndexedInlineVertexBlock (pContext, lpIndices, emittedVertices,
                                           numVertices, bLegacyStrides, dwInlineVertexStride);

    nvglSetNv10CelsiusBeginEnd4 (NV_DD_CELSIUS, NV056_SET_BEGIN_END4_OP_END);

    nvPusherStart (FALSE);
}

#endif  // FORCE_INLINE_VERTICES

#endif  // NVARCH == 0x10


#ifdef PROFILE_LIST2STRIP

#define A1A2_B1C2 1     //New Vtx = B2
#define A1A2_C1B2 2     //New Vtx = C2
#define A1B2_B1A2 3     //New Vtx = C2
#define A1B2_C1C2 4     //New Vtx = A2
#define A1C2_B1B2 5     //New Vtx = A2
#define A1C2_C1A2 6     //New Vtx = B2
#define B1A2_C1C2 7     //New Vtx = B2
#define B1B2_C1A2 8     //New Vtx = C2
#define B1C2_C1B2 9     //New Vtx = A2

#define A1 0
#define B1 1
#define C1 2
#define A2 3
#define B2 4
#define C2 5

static DWORD listmatch[10] =
{
    0,0,0,0,0,0,0,0,0,0
};

typedef struct _strip_length_stats
{
    DWORD len2;     //length 2-4
    DWORD len5;     //length 5-9
    DWORD len10;    //length 10-19
    DWORD len20;    //length 20-49
    DWORD len50;    //length 50-99
    DWORD len100;   //length 100+
    DWORD count;    //total count;
} STRIP_STATS;

#define MAX_PAT_LEN 16
typedef struct _strip_length_pat
{
  BYTE pattern[MAX_PAT_LEN];
  DWORD pat_len;
  STRIP_STATS stats;
} STRIP_PATTERN;

#define MAX_PATS 200
static STRIP_PATTERN strip_pats[MAX_PATS+2];
static DWORD num_pats = 0;
static DWORD num_tris = 0;
static DWORD num_tris_in_strips = 0;
static STRIP_STATS stripstats;
static DWORD first_time = 1;

bool match(BYTE *s1, BYTE *s2, DWORD len)
{
    for (DWORD i = 0; i < len; i++)
    {
        if (*s1++ != *s2++)
            return false;
    }
    return true;
}

DWORD pat_len(BYTE *src, DWORD len)
{
    BYTE *pat;
    BYTE *subpat;
    for (DWORD length = 2; length < len/2 ;length++ )
    {
        pat = subpat = src;
        for (DWORD i = 0; i < len/length; i++ )
        {
            if (!match(pat, subpat+i*length, length)) goto next_len;
        }
        return length;
next_len:;

    }
    return len;
}

STRIP_PATTERN *get_smallest()
{
    DWORD i;
    DWORD count = 0xffffffff;
    STRIP_PATTERN *p = strip_pats;
    STRIP_PATTERN *low = 0;
    for (i = 0; i < MAX_PATS; i++,p++)
    {
        if (p->stats.count < count)
        {
            low = p;
            count = p->stats.count;

        }
    }
    return low;

}


DWORD match_pair(LPWORD pIndices)
{
        if (pIndices[A1] == pIndices[A2])
        {
            if (pIndices[B1] == pIndices[C2])
                return A1A2_B1C2;
            else if (pIndices[C1] == pIndices[B2])
                return A1A2_C1B2;
            // else no match
        }
        else if (pIndices[A1] == pIndices[B2])
        {
            if (pIndices[B1] == pIndices[A2])
                return A1B2_B1A2;
            else if (pIndices[C1] == pIndices[C2])
                return A1B2_C1C2;
            // else no match

        }
        else if (pIndices[A1] == pIndices[C2])
        {
            if (pIndices[B1] == pIndices[B2])
                return A1C2_B1B2;
            else if (pIndices[C1] == pIndices[A2])
                return A1C2_C1A2;
            // else no match
        }
        else if (pIndices[B1] == pIndices[A2])
        {
            if (pIndices[C1] == pIndices[C2])
                return B1A2_C1C2;
            // else no match
        }
        else if (pIndices[B1] == pIndices[B2])
        {
            if (pIndices[C1] == pIndices[A2])
                return B1B2_C1A2;
            // else no match
        }
        else if (pIndices[B1] == pIndices[C2])
        {
            if (pIndices[C1] == pIndices[B2])
                return B1C2_C1B2;
            // else no match
        }

        return 0;
}

void init_strip_stats()
{
    int i, j;
    num_pats = 0;
    for (i = 0; i < MAX_PATS ; i++)
    {
        for (j = 0; j < MAX_PAT_LEN; j++ )
        {
            strip_pats[i].pattern[j] = 0;
        }
        strip_pats[i].pat_len = 0;
        strip_pats[i].stats.len2 = 0;
        strip_pats[i].stats.len5 = 0;
        strip_pats[i].stats.len10 = 0;
        strip_pats[i].stats.len20 = 0;
        strip_pats[i].stats.len50 = 0;
        strip_pats[i].stats.len100 = 0;
        strip_pats[i].stats.count = 0;
    }
    first_time = 0;
    stripstats.len2 = 0;
    stripstats.len5 = 0;
    stripstats.len10 = 0;
    stripstats.len20 = 0;
    stripstats.len50 = 0;
    stripstats.len100 = 0;
    stripstats.count = 0;
    num_tris = 0;
    num_tris_in_strips = 0;
}

void strip_stats(STRIP_PATTERN *pat, DWORD len)
{
    pat->stats.count++;
    stripstats.count++;

    if (len >= 2 && len < 5)
    {
        pat->stats.len2++;
        stripstats.len2++;
    }
    else if (len >= 5 && len < 10)
    {
        pat->stats.len5++;
        stripstats.len5++;
    }
    else if (len >= 10 && len < 20)
    {
        pat->stats.len10++;
        stripstats.len10++;
    }
    else if (len >= 20 && len < 50)
    {
        pat->stats.len20++;
        stripstats.len20++;
    }
    else if (len >= 50 && len < 100)
    {
        pat->stats.len50++;
        stripstats.len50++;
    }
    else if (len >= 100)
    {
        pat->stats.len100++;
        stripstats.len100++;
    }
}

void add_strip(BYTE *strip, DWORD patlen, DWORD striplen)
{
    STRIP_PATTERN *p;
    p = strip_pats;
    DWORD i;
    if (num_pats == 0)
    {
        for (i = 0; i < patlen; i++)
        {
            p->pattern[i] = strip[i];
        }
        p->pat_len = patlen;
        strip_stats(p, striplen);
        num_pats++;
    }
    else
    {
        for (i = 0; i < num_pats ; i++)
        {
            if (patlen == p->pat_len)
            {
                if (match(p->pattern, strip, patlen))
                {
                    strip_stats(p, striplen);
                    goto done;
                }
            }
            p++;
        }

        if (num_pats < MAX_PATS)
        {
            num_pats++;
            for (i = 0; i < patlen; i++)
            {
                p->pattern[i] = strip[i];
            }
            p->pat_len = patlen;
            strip_stats(p, striplen);

        }
        else
        {
            p = get_smallest();
            if (p)
            {

                for (i = 0; i < patlen; i++)
                {
                    p->pattern[i] = strip[i];
                }
                p->pat_len = patlen;
                p->stats.len2 = 0;
                p->stats.len5 = 0;
                p->stats.len10 = 0;
                p->stats.len20 = 0;
                p->stats.len50 = 0;
                p->stats.len100 = 0;
                p->stats.count = 0;
                strip_stats(p, striplen);
            }
        }
    }
done: ;
}


void profile_lists2strips(WORD PrimCount, LPWORD pIndices)
{
    bool inStrip = false;
    int striplen = 0;
    int patlen = 0;
    BYTE strip[MAX_PAT_LEN];
    if (first_time)
        init_strip_stats();

    for (int i = 0; i < PrimCount-1; i++)
    {
        num_tris++;
        DWORD p = match_pair(pIndices);
        if (p)
        {
            num_tris_in_strips++;
            listmatch[p]++;
            if (!inStrip)
            {
                inStrip = true;
                striplen = 1;
                strip[0] = p;
            }
            else
            {
                if (striplen < MAX_PAT_LEN)
                    strip[striplen] = p;
                striplen++;
            }

        }
        else
        {
            if (inStrip)
            {
                patlen = pat_len(strip, (striplen<MAX_PAT_LEN) ? striplen : MAX_PAT_LEN);
                add_strip(strip, patlen, striplen);
            }
            inStrip = false;
            striplen = 0;
        }

        pIndices += 3;
    }

    if (inStrip)
    {
        patlen = pat_len(strip, (striplen<MAX_PAT_LEN) ? striplen : MAX_PAT_LEN);
        add_strip(strip, patlen, striplen);
    }
}

#endif // PROFILE_LIST2STRIP
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\ddraw\celsius\src\nvCelsiusStateHelp.cpp ===
/*
 * Copyright 1993-1998 NVIDIA, Corporation.  All rights reserved.
 * THE INFORMATION CONTAINED HEREIN IS PROPRIETARY AND CONFIDENTIAL TO
 * NVIDIA, CORPORATION.  USE, REPRODUCTION OR DISCLOSURE TO ANY THIRD PARTY
 * IS SUBJECT TO WRITTEN PRE-APPROVAL BY NVIDIA, CORPORATION.
 */
/********************************* Direct 3D *******************************\
*                                                                           *
* Module: nvCelsiusStateHelp.cpp                                            *
*       Celsius state management helper routines.                           *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*       Craig Duttweiler        26May99         NV10 development            *
*                                                                           *
\***************************************************************************/
#include "nvprecomp.h"

#if (NVARCH >= 0x10)

#include "nvCelsiusCaps.h"

//---------------------------------------------------------------------------

// this function comes from erik.

static float lar[32] =
{
     0.000000f,  // error=0.687808
    -0.023353f,  // error=0.070106
    -0.095120f,  // error=0.010402
    -0.170208f,  // error=0.016597
    -0.251038f,  // error=0.021605
    -0.336208f,  // error=0.025186
    -0.421539f,  // error=0.027635
    -0.503634f,  // error=0.029262
    -0.579592f,  // error=0.030311
    -0.647660f,  // error=0.030994
    -0.708580f,  // error=0.031427
    -0.760208f,  // error=0.031702
    -0.803673f,  // error=0.031889
    -0.840165f,  // error=0.031995
    -0.871344f,  // error=0.032067
    -0.896105f,  // error=0.032105
    -0.916457f,  // error=0.032139
    -0.933262f,  // error=0.032165
    -0.946507f,  // error=0.032173
    -0.957755f,  // error=0.032285
    -0.966165f,  // error=0.032230
    -0.972848f,  // error=0.032189
    -0.978413f,  // error=0.032191
    -0.983217f,  // error=0.032718
    -0.986471f,  // error=0.032289
    -0.988778f,  // error=0.033091
    -0.991837f,  // error=0.035067
    -0.993452f,  // error=0.034156
    -0.994839f,  // error=0.034863
    -0.995434f,  // error=0.034785
    -0.996690f,  // error=0.033426
    -1.000000f
};

static float mar[32] =
{
    -0.494592f,  // error=0.687808
    -0.494592f,  // error=0.070106
    -0.570775f,  // error=0.010402
    -0.855843f,  // error=0.016597
    -1.152452f,  // error=0.021605
    -1.436778f,  // error=0.025186
    -1.705918f,  // error=0.027635
    -1.948316f,  // error=0.029262
    -2.167573f,  // error=0.030311
    -2.361987f,  // error=0.030994
    -2.512236f,  // error=0.031427
    -2.652873f,  // error=0.031702
    -2.781295f,  // error=0.031889
    -2.890906f,  // error=0.031995
    -2.938739f,  // error=0.032067
    -3.017491f,  // error=0.032105
    -3.077762f,  // error=0.032139
    -3.099087f,  // error=0.032165
    -3.144977f,  // error=0.032173
    -3.100986f,  // error=0.032285
    -3.151608f,  // error=0.032230
    -3.212636f,  // error=0.032189
    -3.219419f,  // error=0.032191
    -3.079402f,  // error=0.032718
    -3.174922f,  // error=0.032289
    -3.469706f,  // error=0.033091
    -2.895668f,  // error=0.035067
    -2.959919f,  // error=0.034156
    -2.917150f,  // error=0.034863
    -3.600301f,  // error=0.034785
    -3.024990f,  // error=0.033426
    -3.300000f
};

#define LOG_64F    4.15888308336f
#define INV_LOG_2F 1.44269504089f

void explut (float n, float *l, float *m)
{
    float idx,f,a;
    long  i;

    if (n < 1.f) {
        a  = (n == 0.f) ? 0.f : (float)exp(-LOG_64F/n);
        *l = -a;
        *m = 1.f - (1.f-a)*n;
    }
    else {
        idx = 3.f * (float)log(n) * INV_LOG_2F;
        i = (long)idx;
        f = idx-i;

        *l = lar[i]*(1.f-f) + lar[i+1]*f;
        *m = mar[i]*(1.f-f) + mar[i+1]*f;
    }
}

//---------------------------------------------------------------------------

DWORD nvCelsiusBuildTSSMask (PNVD3DCONTEXT pContext, DWORD dwStage)
{
    PNVD3DTEXSTAGESTATE pTSS;
    DWORD dwMask, dwColorOp, dwAlphaOp;

    pTSS = &(pContext->tssState[dwStage]);
    dwColorOp = pTSS->dwValue[D3DTSS_COLOROP];
    dwAlphaOp = pTSS->dwValue[D3DTSS_ALPHAOP];

    dwMask = ( ((pTSS->dwValue[D3DTSS_TEXTUREMAP] != NULL) ? 0x80000000 : 0x0) |
               ((dwColorOp & 0x0000001f) << 26) |
               ((dwAlphaOp & 0x0000001f) << 10) );

    // don't bother with args unless op is not disable. this reduces
    // several otherwise inconsequentially distinct cases to one case
    switch (dwColorOp) {
        case D3DTOP_DISABLE:
            break;
        case D3DTOP_SELECTARG1:
            dwMask |= (NVTSSARGMASK(pTSS->dwValue[D3DTSS_COLORARG1]) << 21);
            break;
        case D3DTOP_SELECTARG2:
            dwMask |= (NVTSSARGMASK(pTSS->dwValue[D3DTSS_COLORARG2]) << 16);
            break;
        default:
            dwMask |= ((NVTSSARGMASK(pTSS->dwValue[D3DTSS_COLORARG1]) << 21) |
                       (NVTSSARGMASK(pTSS->dwValue[D3DTSS_COLORARG2]) << 16));
            break;
    }

    switch (dwAlphaOp) {
        case D3DTOP_DISABLE:
            break;
        case D3DTOP_SELECTARG1:
            dwMask |= (NVTSSARGMASK(pTSS->dwValue[D3DTSS_ALPHAARG1]) << 5);
            break;
        case D3DTOP_SELECTARG2:
            dwMask |= (NVTSSARGMASK(pTSS->dwValue[D3DTSS_ALPHAARG2]) << 0);
            break;
        default:
            dwMask |= ((NVTSSARGMASK(pTSS->dwValue[D3DTSS_ALPHAARG1]) << 5) |
                       (NVTSSARGMASK(pTSS->dwValue[D3DTSS_ALPHAARG2]) << 0));
            break;
    }

    //dwMask |= ((pTSS->dwValue[D3DTSS_RESULTARG] == D3DTA_CURRENT) ? 0 : 1) << 15; 

    return (dwMask);
}

//---------------------------------------------------------------------------

DWORD nvCelsiusCombinersGetHashIndex
(
    DWORD dwTSSMask0,
    DWORD dwTSSMask1
)
{
    DWORD dwIndex;

    // generate an index. until i think of something better,
    // just add the 8 bytes together and mask off the lower N bits
    dwIndex = ((dwTSSMask0 >>  0) & 0xff) +
              ((dwTSSMask0 >>  8) & 0xff) +
              ((dwTSSMask0 >> 16) & 0xff) +
              ((dwTSSMask0 >> 24) & 0xff) +
              ((dwTSSMask1 >>  0) & 0xff) +
              ((dwTSSMask1 >>  8) & 0xff) +
              ((dwTSSMask1 >> 16) & 0xff) +
              ((dwTSSMask1 >> 24) & 0xff);
    dwIndex &= CELSIUSCPTABLE_INDEXMASK;

    return (dwIndex);
}

//---------------------------------------------------------------------------

// lookup a combiner program in the hash table

PCELSIUSCOMBINERPROGRAM nvCelsiusCombinersLookupProgram
(
    DWORD dwTSSMask0,
    DWORD dwTSSMask1
)
{
    PCELSIUSCOMBINERPROGRAM pProgram;
    DWORD dwIndex;

    dwIndex  = nvCelsiusCombinersGetHashIndex (dwTSSMask0, dwTSSMask1);
    pProgram = global.celsiusCombinerProgramTable[dwIndex];

    while (pProgram) {
        if ((pProgram->dwTSSMask0 == dwTSSMask0) &&
            (pProgram->dwTSSMask1 == dwTSSMask1)) {
            return (pProgram);
        }
        pProgram = pProgram->pNext;
    }

    return (NULL);
}

//---------------------------------------------------------------------------

// attempt to set celsius combiners from the hash table.
// return TRUE if successful

BOOL nvCelsiusCombinersSetFromHashTable
(
    PNVD3DCONTEXT pContext,
    DWORD dwTSSMask0,
    DWORD dwTSSMask1
)
{
    PCELSIUSCOMBINERPROGRAM pProgram = nvCelsiusCombinersLookupProgram (dwTSSMask0, dwTSSMask1);

    if (pProgram) {
        // set celsius state from the program
        pContext->hwState.dwStateFlags                 &= ~CELSIUS_MASK_COMBINERPROGRAMUNIQUENESS;
        pContext->hwState.dwStateFlags                 |= pProgram->dwStateFlags;
        pContext->hwState.dwColorICW[0]                 = pProgram->dwColorICW[0];
        pContext->hwState.dwColorOCW[0]                 = pProgram->dwColorOCW[0];
        pContext->hwState.dwAlphaICW[0]                 = pProgram->dwAlphaICW[0];
        pContext->hwState.dwAlphaOCW[0]                 = pProgram->dwAlphaOCW[0];
        pContext->hwState.dwColorICW[1]                 = pProgram->dwColorICW[1];
        pContext->hwState.dwColorOCW[1]                 = pProgram->dwColorOCW[1];
        pContext->hwState.dwAlphaICW[1]                 = pProgram->dwAlphaICW[1];
        pContext->hwState.dwAlphaOCW[1]                 = pProgram->dwAlphaOCW[1];
        pContext->hwState.dwTexUnitToTexStageMapping[0] = pProgram->dwTexUnitMapping[0];
        pContext->hwState.dwTexUnitToTexStageMapping[1] = pProgram->dwTexUnitMapping[1];
        pContext->hwState.dwNumActiveCombinerStages     = pProgram->dwNumActiveStages;
        return TRUE;
    }
    else {
        return FALSE;
    }
}

//---------------------------------------------------------------------------

// add a combiner program to the hash table

void nvCelsiusCombinersAddProgramToHashTable
(
    PCELSIUSCOMBINERPROGRAM pProgram
)
{
    DWORD dwIndex;

    // make sure it's not already in the hash table (needed when using running apps)
    if (nvCelsiusCombinersLookupProgram (pProgram->dwTSSMask0, pProgram->dwTSSMask1)) {
        delete pProgram;
        return;
    }

    // hash out an index
    dwIndex = nvCelsiusCombinersGetHashIndex (pProgram->dwTSSMask0, pProgram->dwTSSMask1);

    // add the new program to the front of the list
    pProgram->pNext = global.celsiusCombinerProgramTable[dwIndex];
    global.celsiusCombinerProgramTable[dwIndex] = pProgram;
}

//---------------------------------------------------------------------------

// add the current combiner settings to the hash table as a new program.
// return true if successful.

BOOL nvCelsiusCombinersAddToHashTable
(
    PNVD3DCONTEXT pContext,
    DWORD dwTSSMask0,
    DWORD dwTSSMask1
)
{
    PCELSIUSCOMBINERPROGRAM pProgram;

/*    
#ifdef DEBUG
    // make sure it's not already in the hash table
    if (nvCelsiusCombinersLookupProgram (dwTSSMask0, dwTSSMask1)) {
        DPF ("nvCelsiusCombinersAddToHashTable: attempt to add something redundant");
        dbgD3DError();
    }
#endif
*/
    // create the program
    pProgram = (PCELSIUSCOMBINERPROGRAM) AllocIPM (sizeof(CELSIUSCOMBINERPROGRAM));

    if (!pProgram) {
        // couldn't get memory. just return
        DPF ("failure to allocate memory for combiner program hash table entry");
        dbgD3DError();
        return (FALSE);
    }

    pProgram->dwTSSMask0          = dwTSSMask0;
    pProgram->dwTSSMask1          = dwTSSMask1;
    pProgram->dwStateFlags        = pContext->hwState.dwStateFlags & CELSIUS_MASK_COMBINERPROGRAMUNIQUENESS;
    pProgram->dwColorICW[0]       = pContext->hwState.dwColorICW[0];
    pProgram->dwColorOCW[0]       = pContext->hwState.dwColorOCW[0];
    pProgram->dwAlphaICW[0]       = pContext->hwState.dwAlphaICW[0];
    pProgram->dwAlphaOCW[0]       = pContext->hwState.dwAlphaOCW[0];
    pProgram->dwColorICW[1]       = pContext->hwState.dwColorICW[1];
    pProgram->dwColorOCW[1]       = pContext->hwState.dwColorOCW[1];
    pProgram->dwAlphaICW[1]       = pContext->hwState.dwAlphaICW[1];
    pProgram->dwAlphaOCW[1]       = pContext->hwState.dwAlphaOCW[1];
    pProgram->dwTexUnitMapping[0] = pContext->hwState.dwTexUnitToTexStageMapping[0];
    pProgram->dwTexUnitMapping[1] = pContext->hwState.dwTexUnitToTexStageMapping[1];
    pProgram->dwNumActiveStages   = pContext->hwState.dwNumActiveCombinerStages;

    nvCelsiusCombinersAddProgramToHashTable (pProgram);

    return (TRUE);
}

//---------------------------------------------------------------------------

#define CELSIUS_VALIDATE_FAIL(reason)   \
{                                       \
    pvtssd->dwNumPasses = 0xffffffff;   \
    pvtssd->ddrval = reason;            \
    dbgTracePop();                      \
    return (DDHAL_DRIVER_HANDLED);      \
}

//---------------------------------------------------------------------------

DWORD nvCelsiusValidateTextureStageState
(
    LPD3DHAL_VALIDATETEXTURESTAGESTATEDATA pvtssd
)
{
    DWORD dwHWStage, dwD3DStage;

    dbgTracePush ("nvCelsiusValidateTextureStageState");

    // get the context
    PNVD3DCONTEXT pContext;
    NV_SET_CONTEXT (pContext, pvtssd);

    // update everything
    pContext->hwState.dwDirtyFlags = CELSIUS_DIRTY_REALLY_FILTHY;
    nvSetCelsiusState (pContext);

    // make sure the setup went smoothly
    if (pContext->hwState.dwStateFlags & CELSIUS_FLAG_SETUPFAILURE) {
        CELSIUS_VALIDATE_FAIL (D3DERR_CONFLICTINGRENDERSTATE);
    }

#ifndef CELSIUS_NVCOMBINER
    // make sure we don't have more than two texture stages in use
    DWORD dwStageCount = 0;
    if (!pContext->bUseTBlendSettings) {
        while ((dwStageCount < 8) && (pContext->tssState[dwStageCount].dwValue[D3DTSS_COLOROP] != D3DTOP_DISABLE)) {
            dwStageCount++;
        }
        if (dwStageCount > CELSIUS_CAPS_MAX_SIMULTANEOUS_TEXTURES) {
            CELSIUS_VALIDATE_FAIL (D3DERR_TOOMANYOPERATIONS);
        }
    }
#endif

    // count free stages
    DWORD dwFreeStages = 0;
    for (dwHWStage = 0; dwHWStage < 2; dwHWStage++) {
        // which D3D stage is handled by this HW stage
        dwD3DStage = pContext->hwState.dwTexUnitToTexStageMapping[dwHWStage];

        if (dwD3DStage == CELSIUS_UNUSED) {
            dwFreeStages++;
        }
    }

    // check clip planes
    DWORD dwClipPlaneEnable = pContext->dwRenderState[D3DRENDERSTATE_CLIPPLANEENABLE];
    DWORD dwClipPlaneCount = 0;

    // count the planes
    while (dwClipPlaneEnable) {
        if (dwClipPlaneEnable & 0x1) dwClipPlaneCount++;
        dwClipPlaneEnable >>= 1;
    }

    if (dwClipPlaneCount > 2*dwFreeStages) {
        CELSIUS_VALIDATE_FAIL (D3DERR_TOOMANYOPERATIONS);
    }

    // verify texture transform
    for (dwHWStage=0; dwHWStage < 2; dwHWStage++) {

        DWORD dwTexUnitStatus = pContext->hwState.dwTextureUnitStatus[dwHWStage];

        if (dwTexUnitStatus == CELSIUS_TEXUNITSTATUS_USER) {

            dwD3DStage = pContext->hwState.dwTexUnitToTexStageMapping[dwHWStage];

            DWORD dwOutCount = pContext->tssState[dwD3DStage].dwValue[D3DTSS_TEXTURETRANSFORMFLAGS] & 0xff;
            BOOL  bXForm     = (dwOutCount != D3DTTFF_DISABLE);

            DWORD dwTexgenMode = pContext->tssState[dwD3DStage].dwValue[D3DTSS_TEXCOORDINDEX] & 0xffff0000;
            BOOL  bTexgen      = (dwTexgenMode != D3DTSS_TCI_PASSTHRU);

            if ((bXForm || bTexgen) &&
                (pContext->hwState.dwStateFlags & CELSIUS_FLAG_PASSTHROUGHMODE) &&
                (!pContext->pCurrentVShader->hasProgram()))
            {
                CELSIUS_VALIDATE_FAIL (D3DERR_CONFLICTINGRENDERSTATE);
            }

        }

        // check for cube maps and w-buffering
        if (pContext->hwState.dwTexUnitToTexStageMapping[dwHWStage] != CELSIUS_UNUSED) {
            DWORD dwD3DStage = pContext->hwState.dwTexUnitToTexStageMapping[dwHWStage];
            if (dwD3DStage != CELSIUS_UNUSED) {
                PNVD3DTEXSTAGESTATE pTSSState = &(pContext->tssState[dwD3DStage]);
                CTexture* pTexture = ((CNvObject *)(pTSSState->dwValue[D3DTSS_TEXTUREMAP]))->getTexture();
                DWORD dwZEnable = pContext->pZetaBuffer ? pContext->dwRenderState[D3DRENDERSTATE_ZENABLE] : 0;
                if (pTexture->isCubeMap() && (dwZEnable == D3DZB_USEW)) {
                    CELSIUS_VALIDATE_FAIL (D3DERR_CONFLICTINGRENDERSTATE);
                }
            }

        }

    }

    // verify color material
    if (pContext->dwRenderState[D3DRENDERSTATE_COLORVERTEX]) {

        if (pContext->dwRenderState[D3DRENDERSTATE_AMBIENTMATERIALSOURCE] == D3DMCS_COLOR2) {
            if (pContext->hwState.pVertexShader->bVAExists(defaultInputRegMap[D3DVSDE_SPECULAR])) {
                CELSIUS_VALIDATE_FAIL (D3DERR_CONFLICTINGRENDERSTATE);
            }
        }

        if (pContext->dwRenderState[D3DRENDERSTATE_DIFFUSEMATERIALSOURCE] == D3DMCS_COLOR2) {
            if (pContext->hwState.pVertexShader->bVAExists(defaultInputRegMap[D3DVSDE_SPECULAR])) {
                CELSIUS_VALIDATE_FAIL (D3DERR_CONFLICTINGRENDERSTATE);
            }
        }

        if (pContext->dwRenderState[D3DRENDERSTATE_SPECULARMATERIALSOURCE] == D3DMCS_COLOR1) {
            if (pContext->hwState.pVertexShader->bVAExists(defaultInputRegMap[D3DVSDE_DIFFUSE])) {
                if (pContext->hwState.pVertexShader->bVAExists(defaultInputRegMap[D3DVSDE_SPECULAR])) {
                    // if vertex specular is valid, enabling NV056_SET_COLOR_MATERIAL_SPECULAR
                    // will make the HW pull material specular from the vertex specular,
                    // NOT vertex diffuse as desired.
                    CELSIUS_VALIDATE_FAIL (D3DERR_CONFLICTINGRENDERSTATE);
                }
            }
        }

        if (pContext->dwRenderState[D3DRENDERSTATE_EMISSIVEMATERIALSOURCE] == D3DMCS_COLOR2) {
            if (pContext->hwState.pVertexShader->bVAExists(defaultInputRegMap[D3DVSDE_SPECULAR])) {
                CELSIUS_VALIDATE_FAIL (D3DERR_CONFLICTINGRENDERSTATE);
            }
        }

    }

    // check lights
    if (GET_LIGHTING_STATE(pContext) && (!(pContext->hwState.dwStateFlags & CELSIUS_FLAG_PASSTHROUGHMODE))) {

        DWORD    dwNumLights = 0;
        pnvLight pLight = pContext->lighting.pActiveLights;

        while (pLight) {
            dwNumLights++;
            pLight = pLight->pNext;
        }

        if (dwNumLights > 8) {
            CELSIUS_VALIDATE_FAIL (D3DERR_CONFLICTINGRENDERSTATE);
        }

    }

    // miscellaneous sanity checks (are these legit or should we just quietly tolerate such crap?)
    if (pContext->dwRenderState[D3DRENDERSTATE_STENCILENABLE]) {
        if ((pContext->pZetaBuffer == NULL) ||
            (pContext->pZetaBuffer->hasStencil() == FALSE)) {
            CELSIUS_VALIDATE_FAIL (D3DERR_CONFLICTINGRENDERSTATE);
        }
    }

    if (pContext->hwState.celsius.dwZEnable != D3DZB_FALSE) {
        if (pContext->pZetaBuffer == NULL) {
            CELSIUS_VALIDATE_FAIL (D3DERR_CONFLICTINGRENDERSTATE);
        }
    }

    // everything is kosher. get the number of passes and return OK
    pvtssd->dwNumPasses = 1;    // don't want this... implies multipass when it is not. pContext->hwState.celsius.dwNumActiveCombinerStages;
    pvtssd->ddrval      = D3D_OK;

    dbgTracePop();
    return (DDHAL_DRIVER_HANDLED);


}
#endif  // NVARCH >= 0x010
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\ddraw\celsius\src\nvCelsiusVbPrim.cpp ===
/*
 * Copyright 1993-1998 NVIDIA, Corporation.  All rights reserved.
 * THE INFORMATION CONTAINED HEREIN IS PROPRIETARY AND CONFIDENTIAL TO
 * NVIDIA, CORPORATION.  USE, REPRODUCTION OR DISCLOSURE TO ANY THIRD PARTY
 * IS SUBJECT TO WRITTEN PRE-APPROVAL BY NVIDIA, CORPORATION.
 */
/********************************* Direct 3D *******************************\
*                                                                           *
* Module: nvCelsiusVbPrim.cpp                                               *
*       indexed and ordered vb primitives                                   *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*       Ben de Waal             20Oct99         NV10 optimization effort    *
*                                                                           *
\***************************************************************************/
#include "nvprecomp.h"
#if (NVARCH >= 0x10)

#include "x86.h"

//////////////////////////////////////////////////////////////////////////////
// notes:
//  - when offset changes, only program it, dont call setcelsiusstate
//
//////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////
// switches
//

//////////////////////////////////////////////////////////////////////////////
// aliases
//
#define ilcData         global.dwILCData
#define ilcCount        global.dwILCCount
#define ilcMax          global.dwILCMax

//////////////////////////////////////////////////////////////////////////////
// externals
//
void ILCCompile_mul                      (DWORD reg,DWORD num);
void nvCelsiusILCompile_beginEnd              (DWORD dwPrimType);
void nvCelsiusILCompile_computeIndexAndOffset (DWORD dwVBStride,DWORD dwVBLogStride);
void nvCelsiusILCompile_memcpy                 (DWORD dwCount, bool recurse);
void nvCelsiusILCompile_indexcpy               (DWORD dwCount);
void nvCelsiusILCompile_copyVertex            (PNVD3DCONTEXT pContext,DWORD dwFlags);
void nvCelsiusILCompile_prefetch              (BOOL bIsIndexed,BOOL bLegacyStrides);
void nvCelsiusILCompile_limit                 (DWORD regLimit,DWORD regDummy);

void __stdcall nvCelsiusDispatchGetFreeSpace   (PNVD3DCONTEXT pContext);
void __stdcall nvCelsiusDispatchGetPusherSpace (void);
#ifdef DEBUG
void __stdcall nvCelsiusDispatchFlush          (void);
void __stdcall nvCelsiusDispatchPrintVertex    (PNVD3DCONTEXT pContext,DWORD dwPutAddress);
#endif

//---------------------------------------------------------------------------

// vb primitive

DWORD nvCelsiusILCompile_vb_prim
(
    PNVD3DCONTEXT pContext,
    DWORD         dwFlags
)
{
    //
    // get loop constants
    //
    DWORD  dwMagic                = celsiusPrimitiveToPrimitiveMagic[dwFlags & CELSIUS_ILMASK_PRIMTYPE];
    DWORD  dwVerticesPerPrim      = (dwMagic >> 8) & 0xff;
    DWORD  dwStartVerticesPerPrim = (dwMagic >> 0) & 0xff;
    BOOL   bLegacyStrides         = dwFlags & CELSIUS_ILFLAG_LEGACY;
    BOOL   bIsIndexed             = (dwFlags & CELSIUS_ILMASK_LOOPTYPE) == CELSIUS_ILFLAG_IX_VB_PRIM;

    //
    // align entry point
    //
    while (ilcCount & 31) { xINT3 }
    DWORD lEntry;
    xLABEL (lEntry);

    //
    // setup stack frame
    //
    xPUSH_r     (rEBP)
    xPUSH_r     (rEBX)
    xPUSH_r     (rESI)
    xPUSH_r     (rEDI)

    //
    // verify that we are using the correct inner loop - debug only
    //
#ifdef DEBUG
    DWORD ld1,ld2;
    xLABEL      (ld1)
    xJMP        (0)
    xLABEL      (ld2)
    xINT3

#define CHECK(a,x)                  \
{                                   \
    xMOV_rm_imm (rmREG(rEBX),a)     \
    xMOV_rm_imm (rmREG(rEAX),x)     \
    xCMP_r_i32  (rEAX,mMEM32(x))    \
    xJNZ32      (ld2)               \
}
#define CHECK2(a,x,y,t)             \
{                                   \
    xMOV_r_i32  (rEDX,mMEM32(global.celsius.x))    \
    xMOV_rm_imm (rmREG(rEBX),a)     \
    xMOV_rm_imm (rmREG(rEAX),x->y)   \
    xCMP_r_rm   (rEAX,rmIND32(rEDX)) xOFS32(OFFSETOF(t,y)) \
    xJNZ32      (ld2)               \
}

    xTARGET_jmp (ld1)

/*
    CHECK (0x00000000,fvfData.dwVertexStride)

    CHECK (0x00010000,fvfData.dwVertexType)

    CHECK (0x00020000,fvfData.dwUVCount[0])
    CHECK (0x00020001,fvfData.dwUVCount[1])
    CHECK (0x00020002,fvfData.dwUVCount[2])
    CHECK (0x00020003,fvfData.dwUVCount[3])
    CHECK (0x00020004,fvfData.dwUVCount[4])
    CHECK (0x00020005,fvfData.dwUVCount[5])
    CHECK (0x00020006,fvfData.dwUVCount[6])
    CHECK (0x00020007,fvfData.dwUVCount[7])

    CHECK (0x00030000,fvfData.dwUVOffset[0])
    CHECK (0x00030001,fvfData.dwUVOffset[1])
    CHECK (0x00030002,fvfData.dwUVOffset[2])
    CHECK (0x00030003,fvfData.dwUVOffset[3])
    CHECK (0x00030004,fvfData.dwUVOffset[4])
    CHECK (0x00030005,fvfData.dwUVOffset[5])
    CHECK (0x00030006,fvfData.dwUVOffset[6])
    CHECK (0x00030007,fvfData.dwUVOffset[7])
*/

    //  - pContext->hwState.dwStateFlags & CELSIUS_MASK_INNERLOOPUNIQUENESS
    xMOV_r_i32  (rEDX,mMEM32(global.celsius.pContext))
    xMOV_rm_imm (rmREG(rEBX),0x00040000)
    xMOV_r_rm   (rEAX,rmIND32(rEDX)) xOFS32(OFFSETOF(NVD3DCONTEXT, hwState.dwStateFlags))
    xAND_rm_imm (rmREG(rEAX),CELSIUS_MASK_INNERLOOPUNIQUENESS)
    xCMP_rm_imm (rmREG(rEAX),pContext->hwState.dwStateFlags & CELSIUS_MASK_INNERLOOPUNIQUENESS)
    xJNZ32      (ld2)

    if (pContext->hwState.dwStateFlags & CELSIUS_FLAG_USERTEXCOORDSNEEDED(0))
    {
        CHECK2 (0x00050000,pContext,hwState.dwTexUnitToTexStageMapping[0],NVD3DCONTEXT)
    }
    if (pContext->hwState.dwStateFlags & CELSIUS_FLAG_USERTEXCOORDSNEEDED(1))
    {
        CHECK2 (0x00050001,pContext,hwState.dwTexUnitToTexStageMapping[1],NVD3DCONTEXT)
    }
#endif

    //
    // setup push buffer
    //
    xMOV_r_i32  (rEDX,mMEM32(pDriverData))
    xMOV_r_rm   (rEDI,rmIND32(rEDX)) xOFS32(OFFSETOF(CDriverContext,nvPusher.m_dwPut))

    //
    // start prim
    //
    xMOV_rm_imm (rmREG(rEAX),((sizeSetNv10CelsiusBeginEnd3MthdCnt << 2) << 16) | ((NV_DD_CELSIUS) << 13) | NV056_SET_BEGIN_END3);
    xMOV_rm_imm (rmREG(rECX),celsiusBeginEndOp[dwFlags & CELSIUS_ILMASK_PRIMTYPE])
    xMOV_rm_r   (rmIND(rEDI),rEAX)
    xMOV_rm_r   (rmIND8(rEDI),rECX) xOFS8(4)
    xLEA_r_rm   (rEDI,rmIND8(rEDI)) xOFS8(8)

    //
    // do work
    //
    if (bIsIndexed)
    {
        //
        // indexed VB
        //

        //
        // setup prefetcher
        //
        xMOV_r_i32  (rEBX,mMEM32(global.celsius.dwPrimCount))
        ILCCompile_mul (rEBX,bLegacyStrides ? 4 : dwVerticesPerPrim);
        if (dwStartVerticesPerPrim)
        {
            xADD_rm_imm (rmREG(rEBX),dwStartVerticesPerPrim)
        }
        xLEA_r_rm   (rECX,rmSIB) xSIB(rEBX,rEBX,x1)

        xMOV_r_i32  (rEAX,mMEM32(global.celsius.pIndices))
        xADD_r_rm   (rECX,rmREG(rEAX))
        xMOV_i32_r  (mMEM32(global.celsius.dwPrefetchBase),rEAX)
        xMOV_i32_r  (mMEM32(global.celsius.dwPrefetchMax),rECX)

        //
        // send indices
        //
        xMOV_r_i32  (rESI,mMEM32(global.celsius.pIndices))
        DWORD labelNext;
        xLABEL      (labelNext)

        //
        // prefetch
        //
        DWORD labelPrefetch1;
        DWORD labelPrefetch2;
        DWORD labelPrefetch3;
        xMOV_r_i32  (rEDX,mMEM32(global.celsius.dwPrefetchBase))
        xCMP_r_rm   (rEDX,rmREG(rESI))
        xLABEL      (labelPrefetch1)
        xJA32       (0)

        xMOV_rm_imm (rmREG(rECX),2048 / 32)
        xLABEL      (labelPrefetch2)
        {
            xCMP_r_i32  (rEDX,mMEM32(global.celsius.dwPrefetchMax))
            xLABEL      (labelPrefetch3)
            xJAE32      (0)
            xMOV_r_rm   (rEAX,rmIND(rEDX))
            xDEC_rm     (rmREG(rECX))
            xLEA_r_rm   (rEDX,rmIND8(rEDX)) xOFS8(32)
            xJNZ32      (labelPrefetch2)
        }
        xTARGET_b32 (labelPrefetch3)
        xMOV_i32_r  (mMEM32(global.celsius.dwPrefetchBase),rEDX)
        xTARGET_b32 (labelPrefetch1)

        //
        // copy indices
        //
        if (bLegacyStrides)
        {
            //
            // legacy - pretty simple since it MUST be a tri list
            //          source = index0:16,index1:16,index2:16,flags:16
            //
            xMOV_r_rm   (rEAX,rmIND(rESI))
            xMOV_r_rm   (rECX,rmIND8(rESI)) xOFS8(4)
            xLEA_r_rm   (rESI,rmIND8(rESI)) xOFS8(8)
            xMOV_r_rm   (rEBP,rmREG(rEAX))
            xAND_rm_imm (rmREG(rEAX),0xffff)
            xADD_r_i32  (rEAX, mMEM32(global.celsius.dwBaseVertex) ) //add base index
            xMOV_rm_imm (rmREG(rEDX),((((3) << 2) << 16) | ((NV_DD_CELSIUS) << 13) | (NVPUSHER_NOINC(NV056_ARRAY_ELEMENT32(0)))))
            xSHR_rm_imm8(rmREG(rEBP),16)
            xADD_r_i32  (rEBP, mMEM32(global.celsius.dwBaseVertex) ) //add base index
            xMOV_rm_r   (rmIND(rEDI),rEDX)
            xMOV_rm_r   (rmIND8(rEDI),rEAX) xOFS8(4)
            xLEA_r_rm   (rEDI,rmIND8(rEDI)) xOFS8(16)
            xAND_rm_imm (rmREG(rECX),0xffff)
            xADD_r_i32  (rECX, mMEM32(global.celsius.dwBaseVertex) ) //add base index
            xMOV_rm_r   (rmIND8(rEDI),rEBP) xOFS8(8 - 16)
            xSUB_rm_imm (rmREG(rEBX),4)
            xMOV_rm_r   (rmIND8(rEDI),rECX) xOFS8(12 - 16)
            // next tri
            xJNZ32      (labelNext)
        }
        else
        {
            //
            // do a 64 index batch
            //
            DWORD labelCopy0;
            xCMP_rm_imm (rmREG(rEBX),64)
            xLABEL      (labelCopy0)
            xJB32       (0)
            {
                xMOV_rm_imm (rmREG(rEAX),((((32) << 2) << 16) | ((NV_DD_CELSIUS) << 13) | (NVPUSHER_NOINC(NV056_ARRAY_ELEMENT16(0)))))
                xMOV_rm_r   (rmIND(rEDI),rEAX)
                xLEA_r_rm   (rEDI,rmIND8(rEDI)) xOFS8(4)
                
                nvCelsiusILCompile_indexcpy (128);

                // check for pusher space
                DWORD labelSpace;
                xMOV_r_i32  (rEDX,mMEM32(pDriverData))
                xCMP_r_rm   (rEDI,rmIND32(rEDX)) xOFS32(OFFSETOF(CDriverContext,nvPusher.m_dwThreshold))
                xLABEL      (labelSpace)
                xJL         (0)
                {
                    xMOV_rm_r   (rmIND32(rEDX),rEDI) xOFS32(OFFSETOF(CDriverContext,nvPusher.m_dwPut))
                    xMOV_rm_imm (rmREG(rEAX),(DWORD)nvCelsiusDispatchGetPusherSpace)
                    xPUSH_r     (rEDX)
                    xCALL_rm    (rmREG(rEAX))
                    xPOP_r      (rEDX)
                    xMOV_r_rm   (rEDI,rmIND32(rEDX)) xOFS32(OFFSETOF(CDriverContext,nvPusher.m_dwPut))
                }
                xTARGET_b8  (labelSpace)

                xSUB_rm_imm (rmREG(rEBX),64)
                xJMP        (labelNext)
            }
            xTARGET_b32 (labelCopy0) // back to prefetch

            //
            // do a 16 index batch
            //
            DWORD labelCopy1;
            xCMP_rm_imm (rmREG(rEBX),16)
            xLABEL      (labelCopy1)
            xJB32       (0)
            {
                xMOV_rm_imm (rmREG(rEAX),((((8) << 2) << 16) | ((NV_DD_CELSIUS) << 13) | (NVPUSHER_NOINC(NV056_ARRAY_ELEMENT16(0)))))
                xMOV_rm_r   (rmIND(rEDI),rEAX)
                xLEA_r_rm   (rEDI,rmIND8(rEDI)) xOFS8(4)

                nvCelsiusILCompile_indexcpy (32);

                xSUB_rm_imm (rmREG(rEBX),16)
                xJMP        (labelNext) // back to prefetch
            }
            xTARGET_b32 (labelCopy1)

            //
            // do a 4 index batch
            //
            DWORD labelCopy2,labelNext2;
            xLABEL      (labelNext2)
            xCMP_rm_imm (rmREG(rEBX),4)
            xLABEL      (labelCopy2)
            xJB32       (0)
            {
                xMOV_rm_imm (rmREG(rEAX),((((2) << 2) << 16) | ((NV_DD_CELSIUS) << 13) | (NVPUSHER_NOINC(NV056_ARRAY_ELEMENT16(0)))))
                xMOV_rm_r   (rmIND(rEDI),rEAX)
                xLEA_r_rm   (rEDI,rmIND8(rEDI)) xOFS8(4)

                nvCelsiusILCompile_indexcpy (8);

                xSUB_rm_imm (rmREG(rEBX),4)
                xJMP        (labelNext2)
            }
            xTARGET_b32 (labelCopy2)

            //
            // do a single index
            //
            DWORD labelCopy3,labelNext3;
            xOR_r_rm    (rEBX,rmREG(rEBX))
            xLABEL      (labelCopy3)
            xJZ32       (0)
            xMOV_rm_imm (rmREG(rEDX),8)
            xLABEL      (labelNext3)
            {
                xXOR_r_rm   (rECX,rmREG(rECX))
                xMOV_rm_imm (rmREG(rEAX),((((1) << 2) << 16) | ((NV_DD_CELSIUS) << 13) | (NVPUSHER_NOINC(NV056_ARRAY_ELEMENT32(0)))))
           x16r xMOV_r_rm   (rCX,rmIND(rESI))
                xLEA_r_rm   (rESI,rmIND8(rESI)) xOFS8(2)
                xMOV_rm_r   (rmIND(rEDI),rEAX)
                xADD_r_rm   (rEDI,rmREG(rEDX))
                xADD_r_i32  (rECX, mMEM32(global.celsius.dwBaseVertex) ) //add base index
                xDEC_rm     (rmREG(rEBX))
                xMOV_rm_r   (rmIND8(rEDI),rECX) xOFS8(4 - 8)
                xJNZ32      (labelNext3)
            }
            xTARGET_b32 (labelCopy3)
        }
    }
    else
    {
        //
        // ordered VB
        //

        //
        // compute how many vertices to send
        //
        xMOV_r_i32  (rEBX,mMEM32(global.celsius.dwPrimCount))
        ILCCompile_mul (rEBX,dwVerticesPerPrim);
        if (dwStartVerticesPerPrim)
        {
            xADD_rm_imm (rmREG(rEBX),dwStartVerticesPerPrim)
        }

        //
        // actually use base vertex
        //
        xMOV_r_i32  (rESI,mMEM32(global.celsius.dwBaseVertex))
        //
        // send
        //
        DWORD labelNext1;
        DWORD labelNext3;
        xLABEL      (labelNext3)
        xCMP_rm_imm (rmREG(rEBX),256)
        xLABEL      (labelNext1)
        xJB32       (0)
        {
            // send 128 vertices
            xMOV_rm_imm (rmREG(rEAX),(((sizeSetNv10CelsiusDrawArraysMthdCnt << 2) << 16) | ((NV_DD_CELSIUS) << 13) | NV056_DRAW_ARRAYS(0)))
            xMOV_rm_r   (rmREG(rECX),rESI)
            // xSHL_rm_imm (rmREG(rECX),0 ? NV056_DRAW_ARRAYS_START_INDEX)  // in principle this should be here, but it's a <<0
            xOR_rm_imm  (rmREG(rECX),DRF_NUM(056, _DRAW_ARRAYS, _COUNT, (256 - 1)))
            xMOV_rm_r   (rmIND(rEDI),rEAX)
            xMOV_rm_r   (rmIND8(rEDI),rECX) xOFS8(4)
            xLEA_r_rm   (rEDI,rmIND8(rEDI)) xOFS8(8)
            xSUB_rm_imm (rmREG(rEBX),256)  // decrement the vertex counter
            xADD_rm_imm (rmREG(rESI),256)  // increment the index counter

            // check for pusher space
            xMOV_r_i32  (rEDX,mMEM32(pDriverData))
            xCMP_r_rm   (rEDI,rmIND32(rEDX)) xOFS32(OFFSETOF(CDriverContext,nvPusher.m_dwThreshold))
            xJL32       (labelNext3)
            {
                xMOV_rm_r   (rmIND32(rEDX),rEDI) xOFS32(OFFSETOF(CDriverContext,nvPusher.m_dwPut))
                xMOV_rm_imm (rmREG(rEAX),(DWORD)nvCelsiusDispatchGetPusherSpace)
                xPUSH_r     (rEDX)
                xCALL_rm    (rmREG(rEAX))
                xPOP_r      (rEDX)
                xMOV_r_rm   (rEDI,rmIND32(rEDX)) xOFS32(OFFSETOF(CDriverContext,nvPusher.m_dwPut))
            }
            xJMP        (labelNext3)
        }
        xTARGET_b32     (labelNext1)

        DWORD labelNext2;
        xOR_r_rm        (rEBX,rmREG(rEBX))
        xLABEL          (labelNext2)
        xJZ32           (0)
        {
            // send rest of vertices
            xMOV_rm_imm (rmREG(rEAX),(((sizeSetNv10CelsiusDrawArraysMthdCnt << 2) << 16) | ((NV_DD_CELSIUS) << 13) | NV056_DRAW_ARRAYS(0)))
            xDEC_rm     (rmREG(rEBX))
            xSHL_rm_imm8(rmREG(rEBX),0 ? NV056_DRAW_ARRAYS_COUNT)
            // xSHL_rm_imm (rmREG(rESI),0 ? NV056_DRAW_ARRAYS_START_INDEX)  // in principle this should be here, but it's a <<0
            xOR_rm_r    (rmREG(rEBX),rESI)

            xMOV_rm_r   (rmIND(rEDI),rEAX)
            xMOV_rm_r   (rmIND8(rEDI),rEBX) xOFS8(4)
            xLEA_r_rm   (rEDI,rmIND8(rEDI)) xOFS8(8)
        }
        xTARGET_b32     (labelNext2)
    }

    //
    // end prim
    //
    xMOV_rm_imm (rmREG(rEAX),((sizeSetNv10CelsiusBeginEnd3MthdCnt << 2) << 16) | ((NV_DD_CELSIUS) << 13) | NV056_SET_BEGIN_END3);
    xMOV_rm_imm (rmREG(rECX),NV056_SET_BEGIN_END3_OP_END)
    xMOV_rm_r   (rmIND(rEDI),rEAX)
    xMOV_rm_r   (rmIND8(rEDI),rECX) xOFS8(4)
    xLEA_r_rm   (rEDI,rmIND8(rEDI)) xOFS8(8)

    // check for pusher space
    DWORD labelSpace;
    xMOV_r_i32  (rESI,mMEM32(pDriverData))
    xCMP_r_rm   (rEDI,rmIND32(rESI)) xOFS32(OFFSETOF(CDriverContext,nvPusher.m_dwThreshold))
    xLABEL      (labelSpace)
    xJL         (0)
    {
        xMOV_rm_r   (rmIND32(rESI),rEDI) xOFS32(OFFSETOF(CDriverContext,nvPusher.m_dwPut))
        xMOV_rm_imm (rmREG(rEAX),(DWORD)nvCelsiusDispatchGetPusherSpace)
        xCALL_rm    (rmREG(rEAX))
        xMOV_r_rm   (rEDI,rmIND32(rESI)) xOFS32(OFFSETOF(CDriverContext,nvPusher.m_dwPut))
    }
    xTARGET_b8  (labelSpace)

    //
    // save off push buffer
    //
    xMOV_r_i32  (rEDX,mMEM32(pDriverData))
#ifndef NV_NULL_HW_DRIVER
    xMOV_rm_r   (rmIND32(rEDX),rEDI) xOFS32(OFFSETOF(CDriverContext,nvPusher.m_dwPut))
#endif

    //
    // done
    //
    xPOP_r      (rEDI)
    xPOP_r      (rESI)
    xPOP_r      (rEBX)
    xPOP_r      (rEBP)
    xRET
    return lEntry;
}

#endif  // NVARCH == 0x10
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\ddraw\common\inc\arb_fifo.h ===
/***************************************************************************\
|*                                                                           *|
|*        Copyright (c) 1993-1997 NVIDIA, Corp.  All rights reserved.        *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.   NVIDIA, Corp. of Sunnyvale, California owns     *|
|*     the copyright  and as design patents  pending  on the design  and     *|
|*     interface  of the NV chips.   Users and possessors of this source     *|
|*     code are hereby granted  a nonexclusive,  royalty-free  copyright     *|
|*     and  design  patent license  to use this code  in individual  and     *|
|*     commercial software.                                                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     Copyright (c) 1993-1997  NVIDIA, Corp.    NVIDIA  design  patents     *|
|*     pending in the U.S. and foreign countries.                            *|
|*                                                                           *|
|*     NVIDIA, CORP.  MAKES  NO REPRESENTATION ABOUT  THE SUITABILITY OF     *|
|*     THIS SOURCE CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT     *|
|*     EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORP. DISCLAIMS     *|
|*     ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,  INCLUDING  ALL     *|
|*     IMPLIED   WARRANTIES  OF  MERCHANTABILITY  AND   FITNESS   FOR  A     *|
|*     PARTICULAR  PURPOSE.   IN NO EVENT SHALL NVIDIA, CORP.  BE LIABLE     *|
|*     FOR ANY SPECIAL, INDIRECT, INCIDENTAL,  OR CONSEQUENTIAL DAMAGES,     *|
|*     OR ANY DAMAGES  WHATSOEVER  RESULTING  FROM LOSS OF USE,  DATA OR     *|
|*     PROFITS,  WHETHER IN AN ACTION  OF CONTRACT,  NEGLIGENCE OR OTHER     *|
|*     TORTIOUS ACTION, ARISING OUT  OF OR IN CONNECTION WITH THE USE OR     *|
|*     PERFORMANCE OF THIS SOURCE CODE.                                      *|
|*                                                                           *|
 \***************************************************************************/

/******************************** ARB Structures ****************************\
*                                                                           *
* Module: ARB_FIFO.H                                                        *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*                                                                           *
\***************************************************************************/

#ifndef _ARB_FIFO_H
#define ARB_FIFO_H

#ifdef __cplusplus
extern "C" {            // Assume C declarations for C++
#endif // __cplusplus

#define DEFAULT_GR_LWM 100
#define DEFAULT_VID_LWM 100
#define DEFAULT_GR_BURST_SIZE 256
#define DEFAULT_VID_BURST_SIZE 128

typedef struct {

  int graphics_lwm;  // GR LWM
  int video_lwm;    // Video LWM

  int graphics_burst_size;
  int video_burst_size;

  int valid;  // good values

} fifo_info;

typedef struct {
  int pclk_khz;
  int mclk_khz;
  int nvclk_khz;
  char mem_page_miss;
  char mem_latency; // cas_latency
  int memory_width;
  char enable_video;
  char gr_during_vid;
  char pix_bpp;
  char mem_aligned;
  char enable_mp;
} sim_state;

#define VIDEO		0
#define GRAPHICS	1
#define MPORT		2
#define ENGINE		3

#define GFIFO_SIZE	320 	// Graphics Fifo Sizes
#define GFIFO_SIZE_128	256 // Graphics Fifo Sizes
#define MFIFO_SIZE	120	    // MP Fifo Sizes
#define VFIFO_SIZE	256	    // Video Fifo Sizes

#define	ABS(a)	(a>0?a:-a)

#ifdef __cplusplus
}
#endif // __cplusplus

#endif // ARB_FIFO_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\ddraw\common\inc\d3dDebug.h ===
// **************************************************************************
//
//       Copyright 1993-1999 NVIDIA, Corporation.  All rights reserved.
//
//     NOTICE TO USER:   The source code  is copyrighted under  U.S. and
//     international laws.  Users and possessors of this source code are
//     hereby granted a nonexclusive,  royalty-free copyright license to
//     use this code in individual and commercial software.
//
//     Any use of this source code must include,  in the user documenta-
//     tion and  internal comments to the code,  notices to the end user
//     as follows:
//
//       Copyright 1993-1999 NVIDIA, Corporation.  All rights reserved.
//
//     NVIDIA, CORPORATION MAKES NO REPRESENTATION ABOUT THE SUITABILITY
//     OF  THIS SOURCE  CODE  FOR ANY PURPOSE.  IT IS  PROVIDED  "AS IS"
//     WITHOUT EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORPOR-
//     ATION DISCLAIMS ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,
//     INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY, NONINFRINGE-
//     MENT,  AND FITNESS  FOR A PARTICULAR PURPOSE.   IN NO EVENT SHALL
//     NVIDIA, CORPORATION  BE LIABLE FOR ANY SPECIAL,  INDIRECT,  INCI-
//     DENTAL, OR CONSEQUENTIAL DAMAGES,  OR ANY DAMAGES  WHATSOEVER RE-
//     SULTING FROM LOSS OF USE,  DATA OR PROFITS,  WHETHER IN AN ACTION
//     OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,  ARISING OUT OF
//     OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOURCE CODE.
//
//     U.S. Government  End  Users.   This source code  is a "commercial
//     item,"  as that  term is  defined at  48 C.F.R. 2.101 (OCT 1995),
//     consisting  of "commercial  computer  software"  and  "commercial
//     computer  software  documentation,"  as such  terms  are  used in
//     48 C.F.R. 12.212 (SEPT 1995)  and is provided to the U.S. Govern-
//     ment only as  a commercial end item.   Consistent with  48 C.F.R.
//     12.212 and  48 C.F.R. 227.7202-1 through  227.7202-4 (JUNE 1995),
//     all U.S. Government End Users  acquire the source code  with only
//     those rights set forth herein.
//
// ********************************* Direct 3D ******************************
//
//  Module: d3dDebug.h
//      D3D-specific debugging routines
//
// **************************************************************************
//
//  History:
//      Chas Inman              18Nov97         original version
//      Craig Duttweiler        21Nov00         major rehash
//
// **************************************************************************

#ifndef _NV3DDBG_H_
#define _NV3DDBG_H_

#ifdef __cplusplus
extern "C" {
#endif

//-------------------------------------------------------------------------
// SHARED DEBUG CODE CONFIGURATION
//-------------------------------------------------------------------------

// override the defaults
#undef  DPF_START_STR
#define DPF_START_STR  "NVDD32: "

#undef  DPF_END_STR
#define DPF_END_STR    "\r\n"

#undef  DPF_LOG_FILE
#define DPF_LOG_FILE   "\\nvdd32.log"

// definitions for dbgLevel debug output level flags
#define NVDBG_LEVEL_ERROR               0x80000000
#define NVDBG_LEVEL_INFO                0x40000000
#define NVDBG_LEVEL_VERTEX_REUSE        0x20000000
#define NVDBG_LEVEL_COLORKEY_INFO       0x10000000
#define NVDBG_LEVEL_AA_INFO             0x08000000
#define NVDBG_LEVEL_FLIP                0x04000000
#define NVDBG_LEVEL_SURFACE             0x02000000  // shows info for CreateSurface, CreateSurfaceEx and DestroySurface
#define NVDBG_LEVEL_SURFACE_ACTIVITY    0x01000000  // shows surface activity
#define NVDBG_LEVEL_SURFACEALLOC        0x00800000  // print info about surface allocations
#define NVDBG_LEVEL_NVOBJ_INFO          0x00400000  // print reference/release access on CNVObjects
#define NVDBG_LEVEL_TEXMAN              0x00200000  // print info about texture fetches and evictions
#define NVDBG_LEVEL_HEAP_ACTIVITY       0x00100000  // print info about IPM heap activity
#define NVDBG_LEVEL_HEAP_USAGE          0x00080000  // print info about heap usage
#define NVDBG_LEVEL_PALETTE             0x00040000  // print info about palette usage
#define NVDBG_LEVEL_PERFORMANCE         0x00020000  // print performance issues
#define NVDBG_LEVEL_VSHADER_INFO        0x00010000  // print inner loop info about vertex shaders
#define NVDBG_LEVEL_VSHADER_IO          0x00008000  // print inner loop info about vertex shader input/output data
#define NVDBG_LEVEL_VSHADER_INS         0x00004000  // print vertex shader instructions
#define NVDBG_LEVEL_HOS_INFO            0x00002000  // print info on HOS processing
#define NVDBG_LEVEL_HOS_VERTEX_INFO     0x00001000  // print info on HOS vertex data
#define NVDBG_LEVEL_PIXEL_SHADER        0x00000800  // print pixel shader instructions (create info)
#define NVDBG_LEVEL_NV_AGP              0x00000400  // print info about nvidia managed AGP activity
#ifdef KPFS
#define NVDBG_LEVEL_VSHADER_MAN         0x00000200  // print info about the vertex shader manager
#endif

//-------------------------------------------------------------------------
// D3D DEBUG BITS
//-------------------------------------------------------------------------

// Bit definitions for the dbgShowState debug flags
#define NVDBG_SHOW_RENDER_STATE         0x80000000
#define NVDBG_SHOW_DX5_CLASS_STATE      0x40000000
#define NVDBG_SHOW_SURFACE_STATE        0x20000000
#define NVDBG_SHOW_VERTICES             0x10000000
#define NVDBG_SHOW_MTS_STATE            0x0F000000  // Selects number of multi-texture stage state values to display.
#define NVDBG_SHOW_MTS_STATE_MAX        8
#define NVDBG_SHOW_MTS_STATE_SHIFT      24
#define NVDBG_SHOW_DX6_CLASS_STATE      0x00800000
#define NVDBG_SHOW_DRAWPRIM2_INFO       0x00400000
#define NVDBG_SHOW_VERTEX_MAX_MIN       0x00200000
#define NVDBG_SHOW_LIGHTS               0x00100000
#define NVDBG_SHOW_MANUAL_OVERRIDE      0x00000002  // force show/dump regardless of dbgShowState/dbgDumpState values
#define NVDBG_SHOW_TEXTURE_RENAME       0x00080000  // prints information on texture renaming

// Bit definitions for the dbgFlush debug flags
#define NVDBG_FLUSH_PRIMITIVE           0x80000000  // flush triangles, lines, points, etc.
#define NVDBG_FLUSH_SETUP               0x40000000  // flush commands that set up / tear down HW object state
#define NVDBG_FLUSH_STATE               0x20000000  // flush DP2 commands that set render state, etc
#define NVDBG_FLUSH_2D                  0x10000000  // flush 2d operations: blits, clears, flips, etc.

// Bit definitions for the texture preview debug flags
#define NVDBG_TEXTURE_PREVIEW_BASE      0x00000001
#define NVDBG_TEXTURE_PREVIEW_MIP       0x00000002
#define NVDBG_TEXTURE_PREVIEW_CUBE      0x00000004
#define NVDBG_TEXTURE_PREVIEW_LINEAR    0x80000000  // preview linear rather than swizzled version
#define NVDBG_TEXTURE_PREVIEW_ALPHA     0x08000000  // preview the alpha values in grayscale

// Filenames for dumped data
#if 0
// multiple small logs
#define NVDBG_DUMP_RENDER_STATE_FILENAME     "\\render_state.txt"
#define NVDBG_DUMP_DX5_CLASS_STATE_FILENAME  "\\dx5_state.txt"
#define NVDBG_DUMP_SURFACE_STATE_FILENAME    "\\surface_state.txt"
#define NVDBG_DUMP_VERTICES_FILENAME         "\\vertices.txt"
#define NVDBG_DUMP_MTS_STATE_FILENAME        "\\mts_state.txt"
#define NVDBG_DUMP_DX6_CLASS_STATE_FILENAME  "\\dx6_state.txt"
#define NVDBG_DUMP_DRAWPRIM2_INFO_FILENAME   "\\drawprim2_info.txt"
#define NVDBG_DUMP_MANUAL_OVERRIDE_FILENAME  "\\manual_dump.txt"
#else
// one big log
#define NVDBG_DUMP_RENDER_STATE_FILENAME     "\\d3ddump.txt"
#define NVDBG_DUMP_DX5_CLASS_STATE_FILENAME  "\\d3ddump.txt"
#define NVDBG_DUMP_SURFACE_STATE_FILENAME    "\\d3ddump.txt"
#define NVDBG_DUMP_VERTICES_FILENAME         "\\d3ddump.txt"
#define NVDBG_DUMP_MTS_STATE_FILENAME        "\\d3ddump.txt"
#define NVDBG_DUMP_DX6_CLASS_STATE_FILENAME  "\\d3ddump.txt"
#define NVDBG_DUMP_DRAWPRIM2_INFO_FILENAME   "\\d3ddump.txt"
#define NVDBG_DUMP_MANUAL_OVERRIDE_FILENAME  "\\d3ddump.txt"
#endif

//-------------------------------------------------------------------------
// GLOBAL VARIABLES
//-------------------------------------------------------------------------

#ifdef DEBUG

    // general debugging
    extern  DWORD                   dbgShowState;
    extern  DWORD                   dbgDumpState;
    extern  DWORD                   dbgFlush;
    extern  DWORD                   dbgForceHWRefresh;

    // primary info (shared by front buffer rendering and texture previewing)
    extern  DWORD                   dbgPrimaryPitch;
    extern  DWORD                   dbgPrimaryHeight;
    extern  DWORD                   dbgPrimaryBPP;

    // front buffer rendering
    extern  BOOL                    dbgFrontRender;
    extern  CSimpleSurface          dbgFrontRenderSurface;

    // texture previewing
    extern  DWORD                   dbgTexturePreview;

#else

    #define dbgShowState            0
    #define dbgDumpState            0
    #define dbgFlush                0
    #define dbgForceHWRefresh       0

    // primary info (shared by front buffer rendering and texture previewing)
    #define dbgPrimaryPitch         0
    #define dbgPrimaryHeight        0
    #define dbgPrimaryBPP           0

    #define dbgFrontRender          FALSE
    #define dbgFrontRenderSurface   NULL

    #define dbgTexturePreview       FALSE

#endif

//-------------------------------------------------------------------------
// PROTOTYPES
//-------------------------------------------------------------------------

#ifdef DEBUG

    // printing
    void __cdecl dbgDPFAndDump                  (DWORD flag, LPSTR szFormat, ...);

    // state dumping
    void         dbgDisplayContextState         (DWORD, PNVD3DCONTEXT);
    void         dbgShowRenderStateChange       (BOOL bChanged, DWORD dwStateType, DWORD dwStateValue);
    void         dbgDisplayDrawPrimitives2Info  (BYTE,WORD);
    void         dbgDisplayVertexData           (BOOL, DWORD *);
    void         dbgDisplayLight                (LPD3DLIGHT7 pLight7);

    // state validation
    BOOL         dbgValidateControlRegisters    (PNVD3DCONTEXT);

    // texture previewing
    void         dbgTextureDisplay              (CTexture *pTexture);

    // front rendering
    void         dbgSetFrontRenderTarget        (PNVD3DCONTEXT pContext, CSimpleSurface *pSurfaceToMimic);

#else  // !DEBUG

    // printing
    #define      dbgDPFAndDump                  1 ? (void)0 : (void)

    // state dumping
    #define      dbgDisplayContextState(f,x)
    #define      dbgShowRenderStateChange(a,b,c)
    #define      dbgDisplayDrawPrimitives2Info(x,y)
    #define      dbgDisplayVertexData(a,b)
    #define      dbgDisplayLight(pLight7)

    // state validation
    #define      dbgValidateControlRegisters(noop) TRUE

    // texture previewing
    #define      dbgTextureDisplay(a)

    // front rendering
    #define      dbgSetFrontRenderTarget(a,b)

#endif

#ifdef NVSTATDRIVER

#define DX7PROPER 1

// prototypes
void __cdecl nvStatLogError(DWORD dwLevel, LPSTR szFormat, ...);

// override some stuff
#undef DPF_LEVEL
#define DPF_LEVEL nvStatLogError
#undef  dbgDisplayVertexData
#define dbgDisplayVertexData nvStatLogVertexData
#endif  // NVSTATDRIVER


//-------------------------------------------------------------------------
// MISCELLANEOUS
//-------------------------------------------------------------------------

#ifdef DEBUG

    #define dbgD3DError()  dbgError("NV D3D ERROR!");
    #define dbgFlushType(type)                                                  \
    {                                                                           \
        if (dbgFlush & type) {                                                  \
            getDC()->nvPusher.flush (TRUE, CPushBuffer::FLUSH_WITH_DELAY);      \
        }                                                                       \
    }

#elif defined(NVSTATDRIVER)

    #define dbgD3DError()  DPF("NV D3D ERROR!!!");
    #define dbgFlushType(a)

#else  // !NVSTATDRIVER && !DEBUG

    #define dbgD3DError()
    #define dbgFlushType(a)

#endif  // !NVSTATDRIVER && !DEBUG


#ifdef __cplusplus
}
#endif // __cplusplus

#endif // _NV3DDBG_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\ddraw\common\inc\d3dMath.h ===
/*
 * Copyright 1993-1998 NVIDIA, Corporation.  All rights reserved.
 *
 * THE INFORMATION CONTAINED HEREIN IS PROPRIETARY AND CONFIDENTIAL TO
 * NVIDIA, CORPORATION.  USE, REPRODUCTION OR DISCLOSURE TO ANY THIRD PARTY
 * IS SUBJECT TO WRITTEN PRE-APPROVAL BY NVIDIA, CORPORATION.
 */

/********************************* Direct 3D *******************************\
*                                                                           *
* Module: d3dMath.h                                                         *
*       header file for d3dmath.cpp                                         *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*       Craig Duttweiler    (bertrem)   09Sep99     created                 *
*                                                                           *
\***************************************************************************/

#ifndef __D3DMATH_H
#define __D3DMATH_H

#ifdef __cplusplus
extern "C" {
#endif

//---------------------------------------------------------------------------

// constants

#define EPSILON 0.0000001f

//---------------------------------------------------------------------------

// augment D3D with some sorely missing types

typedef struct _D3DVECTOR4 {
    D3DVALUE dvX;
    D3DVALUE dvY;
    D3DVALUE dvZ;
    D3DVALUE dvW;
} D3DVECTOR4;

typedef struct _D3DMATRIX3 {
    D3DVALUE _11, _12, _13;
    D3DVALUE _21, _22, _23;
    D3DVALUE _31, _32, _33;
} D3DMATRIX3;

//---------------------------------------------------------------------------

// basic matrices and vectors

static D3DMATRIX matrixIdent =
{
    1.0f, 0.0f, 0.0f, 0.0f,
    0.0f, 1.0f, 0.0f, 0.0f,
    0.0f, 0.0f, 1.0f, 0.0f,
    0.0f, 0.0f, 0.0f, 1.0f
};

static D3DMATRIX matrixZero =
{
    0.0f, 0.0f, 0.0f, 0.0f,
    0.0f, 0.0f, 0.0f, 0.0f,
    0.0f, 0.0f, 0.0f, 0.0f,
    0.0f, 0.0f, 0.0f, 0.0f
};

static D3DVECTOR vectorZero = {0.0f, 0.0f, 0.0f};

//---------------------------------------------------------------------------

// prototypes

float    __fastcall JBInvSqrt (const float x);
float    __fastcall nvSqrt (float x);
float    __fastcall nvInv (float x);
void     __fastcall ReverseVector3 (D3DVECTOR *out, D3DVECTOR *in);
void     __fastcall ScaleVector3 (D3DVECTOR *out, D3DVECTOR *v1, D3DVALUE scale);
void     __fastcall AddVectors3 (D3DVECTOR *out, D3DVECTOR *v1, D3DVECTOR *v2);
void     __fastcall SubtractVectors3 (D3DVECTOR *out, D3DVECTOR *v1, D3DVECTOR *v2);
D3DVALUE __fastcall SquareMagnitude3 (D3DVECTOR *v);
D3DVALUE __fastcall Magnitude3 (D3DVECTOR *v);
void     __fastcall NormalizeVector3 (D3DVECTOR *v);
D3DVALUE __fastcall DotProduct3 (D3DVECTOR *v1, D3DVECTOR *v2);
void     __fastcall XformBy4x3 (D3DVECTOR *res, D3DVECTOR *v, D3DVALUE w, D3DMATRIX *m);
void     __fastcall XformVector3 (D3DVECTOR *res, D3DVECTOR *v, D3DMATRIX *m);
void     __fastcall XformVector4 (D3DVALUE *res, D3DVALUE *v, D3DMATRIX *m);
void     __fastcall MatrixProduct3x3 (D3DMATRIX *res, D3DMATRIX *a, D3DMATRIX *b);
void     __fastcall MatrixProduct4x4 (D3DMATRIX *res, D3DMATRIX *a, D3DMATRIX *b);
void     __fastcall MatrixTranspose4x4 (D3DMATRIX *res, D3DMATRIX *m);
int      __fastcall Inverse3x3 (D3DMATRIX *inverse, D3DMATRIX *src, BOOL bNormalize);
int      __fastcall Inverse4x4 (D3DMATRIX *inverse, D3DMATRIX *src, BOOL bNormalize);
int      __fastcall STInverse4x4 (D3DMATRIX *inverse, D3DMATRIX *src);

// other prototypes
void nvComputeBoundingBox    (BYTE *pVertices,DWORD dwCount,DWORD dwVertexStride,float *pafMinMaxInfo);
void nvComputeXfmAndOutCodes (D3DMATRIX *pXfm,float *pfVerticesIn,float *pfVerticesOut,DWORD dwCount,DWORD *pdwOutCodes);

#ifdef __cplusplus
}
#endif // __cplusplus

#endif // __D3DMATH_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\ddraw\common\inc\D3DINC.H ===
/*
 * (C) Copyright NVIDIA Corporation Inc., 1996,1997. All rights reserved.
 */
/********************************* Direct 3D *******************************\
*                                                                           *
* Module: D3DINC.H                                                          *
*   NV specific direct 3d structure definitions.                            *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*       Eugene Lapidous             ??/??/96 - wrote it.                    *
*       Charles Inman (chasi)       01/02/97 - re-wrote and cleaned up.     *
*                                                                           *
\***************************************************************************/

#ifndef _D3DINC_H_
#define _D3DINC_H_

#ifdef __cplusplus
extern "C" {
#endif

/*
 * --------------------------------------------------------------------------
 * Data Cache macros
 * --------------------------------------------------------------------------
 */
#define PREFETCH(address)       ((volatile DWORD)*(DWORD*)(address))

/*
 * --------------------------------------------------------------------------
 * Texture heap management defines and structures.
 * --------------------------------------------------------------------------
 */
typedef struct _def_tex_heap_header TEXHEAPHEADER, *PTEXHEAPHEADER;

#define PACKCHARS(c0, c1, c2, c3)               \
    (((DWORD)(unsigned char)(c0))       |       \
     ((DWORD)(unsigned char)(c1) << 8)  |       \
     ((DWORD)(unsigned char)(c2) << 16) |       \
     ((DWORD)(unsigned char)(c3) << 24))

#define HEAP_SHARED                 0x04000000UL    // put heap in shared memory
#define HEAP_SIZE_ADJUST            0x00100000
#define HEAP_TAG_FREE               PACKCHARS('F', 'R', 'E', 'E')
#define HEAP_TAG_ALLOC              PACKCHARS('L', 'O', 'C', 'K')

struct _def_tex_heap_header
{
    DWORD           dwTag;
    DWORD           dwBlockSize;
    DWORD           dwBlockStartOffset;
    DWORD           dwReserved;
    PTEXHEAPHEADER  pNextFreeBlock;
    PTEXHEAPHEADER  pPrevFreeBlock;
    PTEXHEAPHEADER  pNextAllocBlock;
    PTEXHEAPHEADER  pPrevAllocBlock;
};

/*
 * --------------------------------------------------------------------------
 * General purpose constants
 * --------------------------------------------------------------------------
 */
#define CONTEXT_ARRAY_SIZE          64
#define CONTEXT_ARRAY_DELTA         64
#define TEXTURE_ARRAY_SIZE          256
#define TEXTURE_ARRAY_DELTA         256
#define AGPLIST_ARRAY_SIZE          256
#define AGPLIST_ARRAY_DELTA         256
#define NVD3D_DEFAULT_TL_NUM        0           // was: ((32 * 2048) / sizeof(D3DTLVERTEX))

#define MAX_STATE                   D3DSTATE_OVERRIDE_BIAS
#define DWORD_BITS                  32
#define DWORD_SHIFT                 5

// point and line sizes
#define LINE_WIDTH                  1.0f
#define HALF_LINE_WIDTH             (0.5f*LINE_WIDTH)
#define POINT_SIZE                  1.0f
#define HALF_POINT_SIZE             (0.5f*POINT_SIZE)

#define NV4_VERTEX_CACHE_SIZE       16

// define global values to be the greatest of those required by the various architectures
#if (NVARCH >= 0x020)
#define NV_CAPS_MAX_COMBINERS       KELVIN_NUM_COMBINERS
#define NV_CAPS_MAX_TEXTURES        KELVIN_NUM_TEXTURES
#define NV_CAPS_MAX_MATRICES        KELVIN_NUM_MATRICES
#define NV_CAPS_MAX_UV_SETS         KELVIN_CAPS_MAX_UV_PAIRS
#define NV_CAPS_MAX_CLIPPLANES      KELVIN_CAPS_MAX_USER_CLIP_PLANES_ALLOWED
#define NV_CAPS_MAX_STREAMS         KELVIN_CAPS_MAX_STREAMS
#define NV_CAPS_MAX_PSHADER_CONSTS  KELVIN_CAPS_MAX_PSHADER_CONSTS
#define NV_CAPS_MAX_VSHADER_TEMPS   KELVIN_CAPS_MAX_VSHADER_TEMPS
#define NV_CAPS_MAX_VSHADER_CONSTS  KELVIN_CAPS_MAX_VSHADER_CONSTS
#elif (NVARCH >= 0x010)
#define NV_CAPS_MAX_COMBINERS       CELSIUS_NUM_COMBINERS
#define NV_CAPS_MAX_TEXTURES        CELSIUS_NUM_TEXTURES
#define NV_CAPS_MAX_MATRICES        CELSIUS_CAPS_MAX_VERTEX_BLEND_MATRICES
#define NV_CAPS_MAX_UV_SETS         CELSIUS_CAPS_MAX_UV_PAIRS
#define NV_CAPS_MAX_CLIPPLANES      CELSIUS_CAPS_MAX_USER_CLIP_PLANES
#define NV_CAPS_MAX_STREAMS         CELSIUS_CAPS_MAX_STREAMS
#define NV_CAPS_MAX_PSHADER_CONSTS  CELSIUS_CAPS_MAX_PSHADER_CONSTS
#define NV_CAPS_MAX_VSHADER_TEMPS   CELSIUS_CAPS_MAX_VSHADER_TEMPS
#define NV_CAPS_MAX_VSHADER_CONSTS  CELSIUS_CAPS_MAX_VSHADER_CONSTS
#else  // nv4
#define NV_CAPS_MAX_TEXTURES        2
#define NV_CAPS_MAX_STREAMS         1
#define NV_CAPS_MAX_MATRICES        NV4_CAPS_MAX_VERTEX_BLEND_MATRICES
#define NV_CAPS_MAX_UV_SETS         NV4_CAPS_MAX_UV_PAIRS
#define NV_CAPS_MAX_CLIPPLANES      NV4_CAPS_MAX_USER_CLIP_PLANES
#define NV_CAPS_MAX_PSHADER_CONSTS  0
#define NV_CAPS_MAX_VSHADER_TEMPS   0
#define NV_CAPS_MAX_VSHADER_CONSTS  0
#endif

// helper functions to cope with vertex shader programs
#define GET_LIGHTING_STATE(pContext)    \
    (pContext->pCurrentVShader->hasProgram() ? FALSE : (pContext->dwRenderState[D3DRENDERSTATE_LIGHTING]))
#define GET_VERTEXBLEND_STATE(pContext) \
    (pContext->pCurrentVShader->hasProgram() ? D3DVBLEND_DISABLE : (pContext->dwRenderState[D3DRENDERSTATE_VERTEXBLEND]))

/*
 * --------------------------------------------------------------------------
 *  Data structures.
 * --------------------------------------------------------------------------
 */

/*
 * D3D state set data.
 */
typedef struct _nv_d3d_state_set
{
    DWORD bits[MAX_STATE >> DWORD_SHIFT];
} NVD3DSTATESET;

// DP2 stateset stuff
#define DEFAULT_STATESET_SIZE     4096
#define INCREMENTAL_STATESET_SIZE 2048

typedef struct _STATESET {
    int    allocatedSize;
    int    dataSize;
    LPBYTE pData;
} STATESET;

#ifdef __cplusplus
}
#endif // __cplusplus

#endif // _D3DINC_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\ddraw\common\inc\DDHal.h ===
// (C) Copyright NVIDIA Corporation Inc., 1996,1998. All rights reserved.

/********************************* Direct 3D *******************************\
*                                                                           *
* Module: DDHal.h                                                           *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*       Paul van der Kouwe          6/15/99 - Created                       *
*                                                                           *
\***************************************************************************/
#ifndef _DDHAL_H_
#define _DDHAL_H_

#ifdef __cplusplus
extern "C" {
#endif // __cplusplus

#ifndef WINNT
// public
FLATPTR EXTERN_DDAPI DDHAL32_VidMemAlloc (LPDDRAWI_DIRECTDRAW_GBL pdrv, int heap, DWORD dwXDim, DWORD dwYDim);
void EXTERN_DDAPI DDHAL32_VidMemFree (LPDDRAWI_DIRECTDRAW_GBL pdrv, int heap, FLATPTR ptr);
#endif // WINNT

#ifdef __cplusplus
}
#endif // __cplusplus

#endif // _DDHAL_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\ddraw\common\inc\d3dConst.h ===
/*
 * Copyright 1993-1998 NVIDIA, Corporation.  All rights reserved.
 *
 * THE INFORMATION CONTAINED HEREIN IS PROPRIETARY AND CONFIDENTIAL TO
 * NVIDIA, CORPORATION.  USE, REPRODUCTION OR DISCLOSURE TO ANY THIRD PARTY
 * IS SUBJECT TO WRITTEN PRE-APPROVAL BY NVIDIA, CORPORATION.
 */
/********************************* Direct 3D *******************************\
*                                                                           *
* Module: d3dConst.h                                                        *
*     General constants associate with D3D                                  *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*       Craig Duttweiler    (bertrem)   22June99     created                *
*                                                                           *
\***************************************************************************/

#ifndef __D3D_CONST_
#define __D3D_CONST_

//---------------------------------------------------------------------------

// global constants

// these are missing from the MS's DX8 header files

#if (DIRECT3D_VERSION == 0x0800)

#define _FACD3D  0x876
#define MAKE_D3DHRESULT( code )  MAKE_HRESULT( 1, _FACD3D, code )

#define D3DERR_TEXTURE_CREATE_FAILED    MAKE_DDHRESULT(721)
#define D3DTSS_ADDRESS 12
#define D3DERR_WRONGTEXTUREFORMAT               MAKE_D3DHRESULT(2072)
#define D3DERR_UNSUPPORTEDCOLOROPERATION        MAKE_D3DHRESULT(2073)
#define D3DERR_UNSUPPORTEDCOLORARG              MAKE_D3DHRESULT(2074)
#define D3DERR_UNSUPPORTEDALPHAOPERATION        MAKE_D3DHRESULT(2075)
#define D3DERR_UNSUPPORTEDALPHAARG              MAKE_D3DHRESULT(2076)
#define D3DERR_TOOMANYOPERATIONS                MAKE_D3DHRESULT(2077)
#define D3DERR_CONFLICTINGTEXTUREFILTER         MAKE_D3DHRESULT(2078)
#define D3DERR_UNSUPPORTEDFACTORVALUE           MAKE_D3DHRESULT(2079)
#define D3DERR_CONFLICTINGRENDERSTATE           MAKE_D3DHRESULT(2081)
#define D3DERR_UNSUPPORTEDTEXTUREFILTER         MAKE_D3DHRESULT(2082)
#define D3DERR_CONFLICTINGTEXTUREPALETTE        MAKE_D3DHRESULT(2086)
#define D3DERR_DRIVERINTERNALERROR              MAKE_D3DHRESULT(2087)

#define D3DERR_NOTFOUND                         MAKE_D3DHRESULT(2150)
#define D3DERR_MOREDATA                         MAKE_D3DHRESULT(2151)
#define D3DERR_DEVICELOST                       MAKE_D3DHRESULT(2152)
#define D3DERR_DEVICENOTRESET                   MAKE_D3DHRESULT(2153)
#define D3DERR_NOTAVAILABLE                     MAKE_D3DHRESULT(2154)
#define D3DERR_OUTOFVIDEOMEMORY                 MAKE_D3DHRESULT(380)
#define D3DERR_INVALIDDEVICE                    MAKE_D3DHRESULT(2155)
#define D3DERR_INVALIDCALL                      MAKE_D3DHRESULT(2156)
// end missing MS info

#endif // (DIRECT3D_VERSION == 0x0800)

// Look in D3DTYPES.H to determine what these values are.
#define D3D_RENDERSTATE_MAX     D3DRS_BLENDOP
#define D3D_DP2OP_MAX           D3DDP2OP_MULTIPLYTRANSFORM
#define D3D_TEXSTAGESTATE_MAX   D3DTSS_RESULTARG
#define D3D_TBLEND_MAX          D3DTBLEND_ADD

//---------------------------------------------------------------------------

// global helpers

// placement new and delete
inline void* operator new    (size_t nSize,void *pPlace) { return pPlace; }
//inline void  operator delete (void*,void*)               {}

//---------------------------------------------------------------------------

// global macros

#define OFFSETOF(s,m)           ((DWORD)(&(((s*)0)->m)))

// retrieve or set the pointer to the NvObject associated with a particular DDSLcl
#ifdef WINNT
#define GET_PNVOBJ(pDDSLcl)        ((CNvObject *)((pDDSLcl)->dwReserved1))
#define SET_PNVOBJ(pDDSLcl,value)  (pDDSLcl)->dwReserved1 = (DWORD)(value);
#else
// under win9x, we store NvObj pointer in GBL_MORE rather than DDSLcl b/c this field gets swapped on a flip
#define GET_PNVOBJ(pDDSLcl)        ((CNvObject *)((GET_LPDDRAWSURFACE_GBL_MORE((pDDSLcl)->lpGbl))->dwDriverReserved))
#define SET_PNVOBJ(pDDSLcl,value)  (GET_LPDDRAWSURFACE_GBL_MORE((pDDSLcl)->lpGbl))->dwDriverReserved = (DWORD)(value);
#endif

#define IS_VALID_PNVOBJ(value)     (((value) != NULL) && ((((DWORD)(value)) & MASK_FLOATING_CONTEXT_DMA_ID) != FLOATING_CONTEXT_DMA_ID))

// template classes for general purpose use
typedef void* NVPOSITION;

//---------------------------------------------------------------------------

// CNVLinkedList

template<class T,class R> class CNVLinkedList
{
protected:
    class CEntry
    {
    public:
        T       m_Object;
        CEntry *m_pNext;
        CEntry *m_pPrev;
    };

    CEntry *m_pHead;
    CEntry *m_pTail;

public:
    inline NVPOSITION getFirstPosition (void) const { return (NVPOSITION)m_pHead; }
    inline NVPOSITION getLastPosition  (void) const { return (NVPOSITION)m_pTail; }

    inline R getNextPosition (NVPOSITION& pos)
    {
        CEntry *pEntry = (CEntry*)pos;
        if (pEntry)
        {
            pos = pEntry->m_pNext;
            return pEntry->m_Object;
        }
        return NULL;
    }

    inline R getPreviousPosition (NVPOSITION& pos)
    {
        CEntry *pEntry = (CEntry*)pos;
        if (pEntry)
        {
            pos = pEntry->m_pPrev;
            return pEntry->m_Object;
        }
        return NULL;
    }

    inline int addFront (R obj)
    {
        CEntry *pEntry = new CEntry;
        if (!pEntry) return 0;
        pEntry->m_Object = obj;
        pEntry->m_pPrev  = NULL;
        pEntry->m_pNext  = m_pHead;
        if (m_pHead) m_pHead->m_pPrev = pEntry;
        m_pHead = pEntry;
        if (!m_pTail) m_pTail = pEntry;
        return 1;
    }

    inline int addBack (R obj)
    {
        CEntry *pEntry = new CEntry;
        if (!pEntry) return 0;
        pEntry->m_Object = obj;
        pEntry->m_pPrev  = m_pTail;
        pEntry->m_pNext  = NULL;
        if (m_pHead) m_pTail->m_pNext = pEntry;
        m_pTail = pEntry;
        if (!m_pHead) m_pHead = pEntry;
        return 1;
    }

    inline void remove (NVPOSITION pos)
    {
        CEntry *pEntry = (CEntry*)pos;
        if (pEntry->m_pNext) pEntry->m_pNext->m_pPrev = pEntry->m_pPrev;
                        else m_pTail = pEntry->m_pPrev;
        if (pEntry->m_pPrev) pEntry->m_pPrev->m_pNext = pEntry->m_pNext;
                        else m_pHead = pEntry->m_pNext;
        delete pEntry;
    }

    inline void removeAll (void)
    {
        while (m_pHead)
        {
            CEntry *pNext = m_pHead;
            delete m_pHead;
            m_pHead = pNext;
        }
        m_pHead = m_pTail = NULL;
    }

    inline NVPOSITION find (R obj) const
    {
        for (CEntry *pEntry = m_pHead; pEntry; pEntry = pEntry->m_pNext)
        {
            if (pEntry->m_Object == obj)
            {
                return (NVPOSITION)pEntry;
            }
        }
        return (NVPOSITION)0;
    }

    inline  CNVLinkedList (void) { m_pHead = m_pTail = NULL; }
    inline ~CNVLinkedList (void)
    {
#ifdef DEBUG
        if (m_pHead) { DPF ("Warning: CLinkedList<> not empty at destruction time"); }
#endif
    }
};

//---------------------------------------------------------------------------

// CNVArray
//    cannot store classes with constructors/destructors or with '=' operators
template<class T,class R,const int ciGrowBy = 128> class CNVArray
{
protected:
    T     *m_pData;
    DWORD  m_dwMax;
    DWORD  m_dwCount;

protected:
    void init (void)
    {
        m_pData = NULL;
        m_dwMax = m_dwCount = 0;
    }
    void grow (DWORD dwNewSize)
    {
        dwNewSize = (dwNewSize + ciGrowBy - 1) & ~(ciGrowBy - 1);
        if (dwNewSize > m_dwMax)
        {
            ReallocIPM(m_pData,sizeof(T) * dwNewSize,(void**)&m_pData);
            m_dwMax = dwNewSize;
        }
    }
    void kill (void)
    {
        if (m_pData) FreeIPM (m_pData);
        init();
    }

public:
    void append (R data)
    {
        if (m_dwCount >= m_dwMax) grow (m_dwCount + 1);
        m_pData[m_dwCount] = data;
        m_dwCount++;
    }

    void removeAll (void)
    {
        m_dwCount = 0;
    }

          DWORD getCount (void) const { return m_dwCount; }
    const T*    getData  (void) const { return m_pData; }

public:
    CNVArray  (void) { init(); }
    ~CNVArray (void) { kill(); }
};

#endif  // __D3D_CONST_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\ddraw\common\inc\ddFlip.h ===
/*
 * (C) Copyright NVIDIA Corporation Inc., 1996,1997,1998. All rights reserved.
 */
/********************************* Direct 3D *******************************\
*                                                                           *
* Module: ddFlip.h                                                          *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*       Paul van der Kouwe 06/16/99 - created.                              *
*                                                                           *
\***************************************************************************/

#ifndef _DDFLIP_H_
#define _DDFLIP_H_

#ifdef __cplusplus
extern "C" {
#endif

#define FLIP_ANYSURFACE         0xFFFFFFF7         // fpVidMem parameter for updateFlipStatus

// prototypes
HRESULT __stdcall getFlipStatusPrimary (FLATPTR fpVidMem);
HRESULT __stdcall getFlipStatusOverlay (FLATPTR fpVidMem);
HRESULT __stdcall getFlipStatus        (FLATPTR fpVidMem, DWORD dwType);
DWORD   __stdcall GetFlipStatus32       (LPDDHAL_GETFLIPSTATUSDATA lpGetFlipStatus);
DWORD   __stdcall Flip32                (LPDDHAL_FLIPDATA pfd);

#ifdef __cplusplus
}
#endif // __cplusplus

#endif // _DDFLIP_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\ddraw\common\inc\ddCapture.h ===
// **************************************************************************
//
//       Copyright 1993-1999 NVIDIA, Corporation.  All rights reserved.
//
//     NOTICE TO USER:   The source code  is copyrighted under  U.S. and
//     international laws.  Users and possessors of this source code are
//     hereby granted a nonexclusive,  royalty-free copyright license to
//     use this code in individual and commercial software.
//
//     Any use of this source code must include,  in the user documenta-
//     tion and  internal comments to the code,  notices to the end user
//     as follows:
//
//       Copyright 1993-1999 NVIDIA, Corporation.  All rights reserved.
//
//     NVIDIA, CORPORATION MAKES NO REPRESENTATION ABOUT THE SUITABILITY
//     OF  THIS SOURCE  CODE  FOR ANY PURPOSE.  IT IS  PROVIDED  "AS IS"
//     WITHOUT EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORPOR-
//     ATION DISCLAIMS ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,
//     INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY, NONINFRINGE-
//     MENT,  AND FITNESS  FOR A PARTICULAR PURPOSE.   IN NO EVENT SHALL
//     NVIDIA, CORPORATION  BE LIABLE FOR ANY SPECIAL,  INDIRECT,  INCI-
//     DENTAL, OR CONSEQUENTIAL DAMAGES,  OR ANY DAMAGES  WHATSOEVER RE-
//     SULTING FROM LOSS OF USE,  DATA OR PROFITS,  WHETHER IN AN ACTION
//     OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,  ARISING OUT OF
//     OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOURCE CODE.
//
//     U.S. Government  End  Users.   This source code  is a "commercial
//     item,"  as that  term is  defined at  48 C.F.R. 2.101 (OCT 1995),
//     consisting  of "commercial  computer  software"  and  "commercial
//     computer  software  documentation,"  as such  terms  are  used in
//     48 C.F.R. 12.212 (SEPT 1995)  and is provided to the U.S. Govern-
//     ment only as  a commercial end item.   Consistent with  48 C.F.R.
//     12.212 and  48 C.F.R. 227.7202-1 through  227.7202-4 (JUNE 1995),
//     all U.S. Government End Users  acquire the source code  with only
//     those rights set forth herein.
//
// ********************************* Direct 3D ******************************
//
//  Module: ddCapture.h
//      macros used by a capture driver (this is a local extension
//      to the shared file nvCapture.h)
//
// **************************************************************************
//
//  History:
//      Craig Duttweiler        24May00         created
//
// **************************************************************************

#ifndef _DDCAPTURE_H
#define _DDCAPTURE_H

#ifdef CAPTURE

//////////////////////////////////////////////////////////////////////////////
// override object creation
//
inline ULONG __capture_NvRmAllocObject (ULONG hClient, ULONG hChannel, ULONG hObject, ULONG hClass)
{
    if (!global.b16BitCode)
    {
        if (getDC()->nvD3DRegistryData.regCaptureEnable & D3D_REG_CAPTUREENABLE_RECORD) {
            CAPTURE_OBJECT_CREATE create;
            create.dwJmpCommand         = CAPTURE_JMP_COMMAND;
            create.dwExtensionSignature = CAPTURE_EXT_SIGNATURE;
            create.dwExtensionID        = CAPTURE_XID_OBJECT_CREATE;
            create.dwClassID            = hClass;
            create.dwHandle             = hObject;
            captureLog (&create,sizeof(create));
        }
    }
    return NvRmAllocObject (hClient, hChannel, hObject, hClass);
}
#define NvRmAllocObject __capture_NvRmAllocObject   // alias to CAPTURE create

//////////////////////////////////////////////////////////////////////////////
// override second flavor of object creation
//
inline ULONG __capture_NvRmAlloc (ULONG hClient, ULONG hParent, ULONG hObject, ULONG hClass, PVOID pAllocParms)
{
    if (!global.b16BitCode)
    {
        if (getDC()->nvD3DRegistryData.regCaptureEnable & D3D_REG_CAPTUREENABLE_RECORD) {
            CAPTURE_OBJECT_CREATE create;
            create.dwJmpCommand         = CAPTURE_JMP_COMMAND;
            create.dwExtensionSignature = CAPTURE_EXT_SIGNATURE;
            create.dwExtensionID        = CAPTURE_XID_OBJECT_CREATE;
            create.dwClassID            = hClass;
            create.dwHandle             = hObject;
            captureLog (&create,sizeof(create));
        }
    }
    return NvRmAlloc (hClient, hParent, hObject, hClass, pAllocParms);
}
#define NvRmAlloc __capture_NvRmAlloc

//////////////////////////////////////////////////////////////////////////////
// override context DMA creation
//
inline ULONG __capture_NvRmAllocContextDma (ULONG hClient, ULONG hDma, ULONG hClass, ULONG flags, PVOID base, ULONG limit)
{
    if (getDC()->nvD3DRegistryData.regCaptureEnable & D3D_REG_CAPTUREENABLE_RECORD) {
        CAPTURE_CTXDMA_CREATE create;
        create.dwJmpCommand         = CAPTURE_JMP_COMMAND;
        create.dwExtensionSignature = CAPTURE_EXT_SIGNATURE;
        create.dwExtensionID        = CAPTURE_XID_CTXDMA_CREATE;
        create.dwHandle             = hDma;
        create.dwSize               = limit + 1;
        create.dwBaseAddress        = (DWORD)(base);

        if ((DWORD(base) >= pDriverData->BaseAddress)
         && (DWORD(base) < (pDriverData->BaseAddress + pDriverData->TotalVRAM)))
        {
            create.dwType = CAPTURE_CTXDMA_TYPE_VID;
        }
        else if (pDriverData->GARTLinearBase
              && (DWORD(base) >= pDriverData->GARTLinearBase)
              && (DWORD(base) <  (pDriverData->GARTLinearBase + pDriverData->regMaxAGPLimit + 1)))
        {
            create.dwType = CAPTURE_CTXDMA_TYPE_AGP;
        }
        else
        {
            create.dwType = CAPTURE_CTXDMA_TYPE_PCI;
        }
        captureLog (&create,sizeof(create));
    }
    return NvRmAllocContextDma (hClient, hDma, hClass, flags, base, limit);
}
#define NvRmAllocContextDma __capture_NvRmAllocContextDma

//////////////////////////////////////////////////////////////////////////////
// override object / context dma deletion
//
inline ULONG __capture_NvRmFree (ULONG hClient, ULONG hChannel, ULONG hObject)
{
    if (getDC()->nvD3DRegistryData.regCaptureEnable & D3D_REG_CAPTUREENABLE_RECORD) {
        CAPTURE_OBJECT_FREE free;
        free.dwJmpCommand         = CAPTURE_JMP_COMMAND;
        free.dwExtensionSignature = CAPTURE_EXT_SIGNATURE;
        free.dwExtensionID        = CAPTURE_XID_OBJECT_FREE;
        free.dwHandle             = hObject;
        captureLog (&free,sizeof(free));
    }
    return NvRmFree (hClient, hChannel, hObject);
}
#define NvRmFree __capture_NvRmFree

#endif  // CAPTURE

#endif  // _DDCAPTURE_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\ddraw\common\inc\ddSurface.h ===
// **************************************************************************
//
//       Copyright 1993-1999 NVIDIA, Corporation.  All rights reserved.
//
//     NOTICE TO USER:   The source code  is copyrighted under  U.S. and
//     international laws.  Users and possessors of this source code are
//     hereby granted a nonexclusive,  royalty-free copyright license to
//     use this code in individual and commercial software.
//
//     Any use of this source code must include,  in the user documenta-
//     tion and  internal comments to the code,  notices to the end user
//     as follows:
//
//       Copyright 1993-1999 NVIDIA, Corporation.  All rights reserved.
//
//     NVIDIA, CORPORATION MAKES NO REPRESENTATION ABOUT THE SUITABILITY
//     OF  THIS SOURCE  CODE  FOR ANY PURPOSE.  IT IS  PROVIDED  "AS IS"
//     WITHOUT EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORPOR-
//     ATION DISCLAIMS ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,
//     INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY, NONINFRINGE-
//     MENT,  AND FITNESS  FOR A PARTICULAR PURPOSE.   IN NO EVENT SHALL
//     NVIDIA, CORPORATION  BE LIABLE FOR ANY SPECIAL,  INDIRECT,  INCI-
//     DENTAL, OR CONSEQUENTIAL DAMAGES,  OR ANY DAMAGES  WHATSOEVER RE-
//     SULTING FROM LOSS OF USE,  DATA OR PROFITS,  WHETHER IN AN ACTION
//     OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,  ARISING OUT OF
//     OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOURCE CODE.
//
//     U.S. Government  End  Users.   This source code  is a "commercial
//     item,"  as that  term is  defined at  48 C.F.R. 2.101 (OCT 1995),
//     consisting  of "commercial  computer  software"  and  "commercial
//     computer  software  documentation,"  as such  terms  are  used in
//     48 C.F.R. 12.212 (SEPT 1995)  and is provided to the U.S. Govern-
//     ment only as  a commercial end item.   Consistent with  48 C.F.R.
//     12.212 and  48 C.F.R. 227.7202-1 through  227.7202-4 (JUNE 1995),
//     all U.S. Government End Users  acquire the source code  with only
//     those rights set forth herein.
//
// **************************************************************************
//
//  Module: ddSurface.h
//    Definition file for:
//       ddsurf.c
//
// **************************************************************************
//
// History:
//       Paul van der Kouwe 06/16/99 - created.
//
// **************************************************************************

#ifndef _DDSURFACE_H_
#define _DDSURFACE_H_

#ifdef __cplusplus
extern "C" {
#endif

// macros

#define SET_GBL_SURFACE_DATA(pDDSLcl, flags, bits, rmask, gmask, bmask, amask)  \
{                                                                               \
    pDDSLcl->lpGbl->ddpfSurface.dwFlags = (flags);                              \
    pDDSLcl->lpGbl->ddpfSurface.dwRGBBitCount = (bits);                         \
    pDDSLcl->lpGbl->ddpfSurface.dwRBitMask = (rmask);                           \
    pDDSLcl->lpGbl->ddpfSurface.dwGBitMask = (gmask);                           \
    pDDSLcl->lpGbl->ddpfSurface.dwBBitMask = (bmask);                           \
    pDDSLcl->lpGbl->ddpfSurface.dwRGBAlphaBitMask = (amask);                    \
}

// helper routines
#ifndef WINNT
void  getDisplayDuration (void);
#endif
BOOL  nvCalculateColorKey (DWORD *pColorKey, LPDDRAWI_DDRAWSURFACE_LCL pLcl, DWORD dwFormat);
DWORD nvCalculateSurfaceParams (LPDDRAWI_DDRAWSURFACE_LCL pDDSLcl,
                                DWORD *pFormat, BOOL *bFourCC,
                                DWORD *pWidth, DWORD *pHeight, DWORD *pDepth, DWORD *dwMultiSampleBits,
                                DWORD *pBPPRequested, DWORD *pBPPGranted,
                                DWORD *pPitch, DWORD *pSlicePitch, BOOL bComputePitch /* rather than extracting it from pDDSLcl */);

// callbacks

DWORD __stdcall DestroySurface32   (LPDDHAL_DESTROYSURFACEDATA lpDestroySurface);
DWORD __stdcall CreateSurface32    (LPDDHAL_CREATESURFACEDATA lpCreateSurface);
DWORD __stdcall CanCreateSurface32 (LPDDHAL_CANCREATESURFACEDATA lpCanCreateSurface);


#ifdef __cplusplus
}
#endif // __cplusplus

#endif // _DDSURFACE_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\ddraw\common\inc\ddkmapi.h ===
/*==========================================================================;
 *
 *  Copyright (C) 1997 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       ddkmapi.h
 *  Content:    Kernel mode APIs for accessing DirectDraw support.
 *
 ***************************************************************************/

#ifndef __DDKMAPI_INCLUDED__
#define __DDKMAPI_INCLUDED__

#ifdef __cplusplus
extern "C" {
#endif

/*
 * API entry point
 */
DWORD
FAR PASCAL
DxApi(
    DWORD dwFunctionNum,
    DWORD lpvInBuffer,
    DWORD cbInBuffer,
    DWORD lpvOutBuffer,
    DWORD cbOutBuffer
);


#define DXAPI_MAJORVERSION              1
#define DXAPI_MINORVERSION              0

#define DD_FIRST_DXAPI                                  0x500

typedef DWORD (FAR PASCAL *LPDD_NOTIFYCALLBACK)(DWORD dwFlags, PVOID pContext, DWORD dwParam1, DWORD dwParam2);

/*
 * Queries the DXAPI version number.
 *
 * Input:  Null
 * Output: LPDDGETVERSIONNUMBER
 */
#define DD_DXAPI_GETVERSIONNUMBER                       (DD_FIRST_DXAPI)

    typedef struct _DDGETVERSIONNUMBER
    {
        DWORD   ddRVal;
        DWORD   dwMajorVersion;
        DWORD   dwMinorVersion;
    } DDGETVERSIONNUMBER, FAR *LPDDGETVERSIONNUMBER;

/*
 * Closes the kernel mode handle.
 *
 * Input:  LPDDCLOSEHANDLE
 * Output: DWORD DirectDraw return value
 */
#define DD_DXAPI_CLOSEHANDLE                            (DD_FIRST_DXAPI+1)

    typedef struct _DDCLOSEHANDLE
    {
        HANDLE  hHandle;
    } DDCLOSEHANDLE, FAR *LPDDCLOSEHANDLE;

/*
 * Opens the DirectDraw object and returns a kernel mode handle.
 *
 * Input:  LPDDOPENDIRECTDRAWIN
 * Output: LPDDOPENDIRECTDRAWOUT
 */
#define DD_DXAPI_OPENDIRECTDRAW                         (DD_FIRST_DXAPI+2)

    typedef struct _DDOPENDIRECTDRAWIN
    {
        DWORD               dwDirectDrawHandle;
        LPDD_NOTIFYCALLBACK pfnDirectDrawClose;
        PVOID               pContext;
    } DDOPENDIRECTDRAWIN, FAR *LPDDOPENDIRECTDRAWIN;

    typedef struct _DDOPENDIRECTDRAWOUT
    {
        DWORD   ddRVal;
        HANDLE  hDirectDraw;
    } DDOPENDIRECTDRAWOUT, FAR *LPDDOPENDIRECTDRAWOUT;

/*
 * Opens the surface and returns a kernel mode handle.
 *
 * Input:  LPDDOPENSURFACEIN
 * Output: LPDDOPENSURFACEOUT
 */
#define DD_DXAPI_OPENSURFACE                            (DD_FIRST_DXAPI+3)

    typedef struct _DDOPENSURFACEIN
    {
        HANDLE              hDirectDraw;
        DWORD               dwSurfaceHandle;
        LPDD_NOTIFYCALLBACK pfnSurfaceClose;
        PVOID               pContext;
    } DDOPENSURFACEIN, FAR *LPDDOPENSURFACEIN;

    typedef struct _DDOPENSURFACEOUT
    {
        DWORD   ddRVal;
        HANDLE  hSurface;
    } DDOPENSURFACEOUT, FAR *LPDDOPENSURFACEOUT;

/*
 * Opens the VideoPort and returns a kernel mode handle.
 *
 * Input:  LPDDOPENVIDEOPORTIN
 * Output: LPDDOPENVIDEOPORTOUT
 */
#define DD_DXAPI_OPENVIDEOPORT                          (DD_FIRST_DXAPI+4)

    typedef struct _DDOPENVIDEOPORTIN
    {
        HANDLE              hDirectDraw;
        DWORD               dwVideoPortHandle;
        LPDD_NOTIFYCALLBACK pfnVideoPortClose;
        PVOID               pContext;
    } DDOPENVIDEOPORTIN, FAR *LPDDOPENVIDEOPORTIN;

    typedef struct _DDOPENVIDEOPORTOUT
    {
        DWORD   ddRVal;
        HANDLE  hVideoPort;
    } DDOPENVIDEOPORTOUT, FAR *LPDDOPENVIDEOPORTOUT;

/*
 * Returns the kernel mode capabilities supported by the device
 *
 * Input:  HANDLE hDirectDraw
 * Output: LPDDGETKERNELCAPSOUT
 */
#define DD_DXAPI_GETKERNELCAPS                          (DD_FIRST_DXAPI+5)

    typedef struct _DDGETKERNELCAPSOUT
    {
        DWORD   ddRVal;
        DWORD   dwCaps;
        DWORD   dwIRQCaps;
    } DDGETKERNELCAPSOUT, FAR *LPDDGETKERNELCAPSOUT;

/*
 * Gets the current field number
 *
 * Input:  LPDDGETFIELDNUMIN
 * Output: LPDDGETFIELDNUMOUT
 */
#define DD_DXAPI_GET_VP_FIELD_NUMBER                    (DD_FIRST_DXAPI+6)

    typedef struct _DDGETFIELDNUMIN
    {
        HANDLE  hDirectDraw;
        HANDLE  hVideoPort;
    } DDGETFIELDNUMIN, FAR *LPDDGETFIELDNUMIN;

    typedef struct _DDGETFIELDNUMOUT
    {
        DWORD   ddRVal;
        DWORD   dwFieldNum;
    } DDGETFIELDNUMOUT, FAR *LPDDGETFIELDNUMOUT;

/*
 * Sets the current field number
 *
 * Input:  LPDDSETFIELDNUM
 * Output: DWORD DirectDraw return value
 */
#define DD_DXAPI_SET_VP_FIELD_NUMBER                    (DD_FIRST_DXAPI+7)

    typedef struct _DDSETFIELDNUM
    {
        HANDLE  hDirectDraw;
        HANDLE  hVideoPort;
        DWORD   dwFieldNum;
    } DDSETFIELDNUM, FAR *LPDDSETFIELDNUM;

/*
 * Indicates which fields should be skipped to undo the 3:2 pulldown.
 *
 * Input:  LPDDSETSKIPFIELD
 * Output: DWORD DirectDraw return value
 */
#define DD_DXAPI_SET_VP_SKIP_FIELD                      (DD_FIRST_DXAPI+8)

    typedef struct _DDSETSKIPFIELD
    {
        HANDLE  hDirectDraw;
        HANDLE  hVideoPort;
        DWORD   dwStartField;
    } DDSETSKIPFIELD, FAR *LPDDSETSKIPFIELD;

/*
 * Notifies whether the surface is in bob or weave mode.
 *
 * Input:  LPDDGETSURFACESTATEIN
 * Output: LPDDGETSURFACESTATEOUT
 */
#define DD_DXAPI_GET_SURFACE_STATE                      (DD_FIRST_DXAPI+9)

    typedef struct _DDGETSURFACESTATEIN
    {
        HANDLE  hDirectDraw;
        HANDLE  hSurface;
    } DDGETSURFACESTATEIN, FAR *LPDDGETSURFACESTATEIN;

    typedef struct _DDGETSURFACESTATEOUT
    {
        DWORD   ddRVal;
        DWORD   dwStateCaps;
        DWORD   dwStateStatus;
    } DDGETSURFACESTATEOUT, FAR *LPDDGETSURFACESTATEOUT;

/*
 * Changes the surface between bob and weave mode.
 *
 * Input:  LPDDSETSURFACESTATE
 * Output: DWORD DirectDraw return value
 */
#define DD_DXAPI_SET_SURFACE_STATE                      (DD_FIRST_DXAPI+10)

    typedef struct _DDSETSURFACETATE
    {
        HANDLE  hDirectDraw;
        HANDLE  hSurface;
        DWORD   dwState;
        DWORD   dwStartField;
    } DDSETSURFACESTATE, FAR *LPDDSETSURFACESTATE;

/*
 * Allows direct access to the surface memory
 *
 * Input:  LPDDLOCKIN
 * Output: LPDDLOCKOUT
 */
#define DD_DXAPI_LOCK                                   (DD_FIRST_DXAPI+11)

    typedef struct _DDLOCKIN
    {
        HANDLE  hDirectDraw;
        HANDLE  hSurface;
    } DDLOCKIN, FAR *LPDDLOCKIN;

    typedef struct _DDLOCKOUT
    {
        DWORD   ddRVal;
        DWORD   dwSurfHeight;
        DWORD   dwSurfWidth;
        LONG    lSurfPitch;
        PVOID   lpSurface;
        DWORD   SurfaceCaps;
        DWORD   dwFormatFlags;
        DWORD   dwFormatFourCC;
        DWORD   dwFormatBitCount;
        union
        {
            DWORD       dwRBitMask;
            DWORD       dwYBitMask;
        };
        union
        {
            DWORD       dwGBitMask;
            DWORD       dwUBitMask;
        };
        union
        {
            DWORD       dwBBitMask;
            DWORD       dwVBitMask;
        };
    } DDLOCKOUT, FAR *LPDDLOCKOUT;

/*
 * Flips the overlay surface
 *
 * Input:  LPDDFLIPOVERLAY
 * Output: DWORD DirectDraw return value
 */
#define DD_DXAPI_FLIP_OVERLAY                           (DD_FIRST_DXAPI+12)

    typedef struct _DDFLIPOVERLAY
    {
        HANDLE  hDirectDraw;
        HANDLE  hCurrentSurface;
        HANDLE  hTargetSurface;
        DWORD   dwFlags;
    } DDFLIPOVERLAY, FAR *LPDDFLIPOVERLAY;

/*
 * Flips the video port
 *
 * Input:  LPDDFLIPOVERLAY
 * Output: DWORD DirectDraw return value
 */
#define DD_DXAPI_FLIP_VP                                (DD_FIRST_DXAPI+13)

    typedef struct _DDFLIPVIDEOPORT
    {
        HANDLE  hDirectDraw;
        HANDLE  hVideoPort;
        HANDLE  hCurrentSurface;
        HANDLE  hTargetSurface;
        DWORD   dwFlags;
    } DDFLIPVIDEOPORT, FAR *LPDDFLIPVIDEOPORT;

/*
 * Returns the current surface receiving the data while autoflipping
 *
 * Input:  LPDDGETAUTOFLIPIN
 * Output: LPDDGETAUTOFLIPOUT
 */
#define DD_DXAPI_GET_CURRENT_VP_AUTOFLIP_SURFACE        (DD_FIRST_DXAPI+14)

    typedef struct _DDGETAUTOFLIPIN
    {
        HANDLE  hDirectDraw;
        HANDLE  hVideoPort;
    } DDGETAUTOFLIPIN, FAR *LPDDGETAUTOFLIPIN;

    typedef struct _DDGETAUTOFLIPOUT
    {
        DWORD   ddRVal;
        HANDLE  hVideoSurface;
        HANDLE  hVBISurface;
        BOOL    bPolarity;
    } DDGETAUTOFLIPOUT, FAR *LPDDGETAUTOFLIPOUT;

/*
 * Returns the surface that received the previous field of data (could
 * be the same as current if video is interleaved)
 *
 * Input:  LPDDGETAUTOFLIPIN
 * Output: LPDDGETAUTOFLIPOUT
 */
#define DD_DXAPI_GET_LAST_VP_AUTOFLIP_SURFACE           (DD_FIRST_DXAPI+15)

/*
 * Registers a callback for when various events occur.
 *
 * Input:  LPDDREGISTERCALLBACK
 * Output: DWORD DirectDraw return value
 */
#define DD_DXAPI_REGISTER_CALLBACK                      (DD_FIRST_DXAPI+16)

    typedef struct _DDREGISTERCALLBACK
    {
        HANDLE              hDirectDraw;
        DWORD               dwEvents;
        LPDD_NOTIFYCALLBACK pfnCallback;
        DWORD               dwParam1;
        DWORD               dwParam2;
        PVOID               pContext;
    } DDREGISTERCALLBACK, FAR *LPDDREGISTERCALLBACK;

/*
 * Unregisters a callback for when various events occur.
 *
 * Input:  LPDDREGISTERCALLBACK
 * Output: DWORD DirectDraw return value
 */
#define DD_DXAPI_UNREGISTER_CALLBACK                    (DD_FIRST_DXAPI+17)

/*
 * Returns the polarity (odd/even) of the current field
 *
 * Input:  LPDDGETPOLARITYIN
 * Output: LPDDGETPOLARITYOUT
 */
#define DD_DXAPI_GET_POLARITY                           (DD_FIRST_DXAPI+18)

    typedef struct _DDGETPOLARITYIN
    {
        HANDLE  hDirectDraw;
        HANDLE  hVideoPort;
    } DDGETPOLARITYIN, FAR *LPDDGETPOLARITYIN;

    typedef struct _DDGETPOLARITYOUT
    {
        DWORD   ddRVal;
        BOOL    bPolarity;
    } DDGETPOLARITYOUT, FAR *LPDDGETPOLARITYOUT;

/*
 * Opens the device for capture
 *
 * Input:  LPDDOPENCAPTUREDEVICEIN
 * Output: LPDDOPENCAPTUREDEVICEOUT
 */
#define DD_DXAPI_OPENVPCAPTUREDEVICE                    (DD_FIRST_DXAPI+19)

    typedef struct _DDOPENVPCAPTUREDEVICEIN
    {
        HANDLE  hDirectDraw;
        HANDLE  hVideoPort;
        DWORD   dwStartLine;
        DWORD   dwEndLine;
        DWORD   dwCaptureEveryNFields;
        LPDD_NOTIFYCALLBACK pfnCaptureClose;
        PVOID   pContext;
    } DDOPENVPCAPTUREDEVICEIN, FAR * LPDDOPENVPCAPTUREDEVICEIN;

    typedef struct _DDOPENVPCAPTUREDEVICEOUT
    {
        DWORD   ddRVal;
        HANDLE  hCapture;
    } DDOPENVPCAPTUREDEVICEOUT, FAR * LPDDOPENVPCAPTUREDEVICEOUT;

/*
 * Adds a capture buffer to the internal video port capture queue
 *
 * Input:  LPDDADDVPCAPTUREBUFF
 * Output: DWORD DirectDraw return value
 */
#define DD_DXAPI_ADDVPCAPTUREBUFFER                     (DD_FIRST_DXAPI+20)

    typedef struct _DDCAPBUFFINFO
    {
        DWORD           dwFieldNumber;
        DWORD           bPolarity;
        LARGE_INTEGER   liTimeStamp;
        DWORD           ddRVal;
    } DDCAPBUFFINFO, FAR * LPDDCAPBUFFINFO;

    typedef struct _DDADDVPCAPTUREBUFF
    {
        HANDLE  hCapture;
        DWORD   dwFlags;
        PMDL    pMDL;
        PKEVENT pKEvent;
        LPDDCAPBUFFINFO lpBuffInfo;
    } DDADDVPCAPTUREBUFF, FAR * LPDDADDVPCAPTUREBUFF;

    #define DDADDBUFF_SYSTEMMEMORY      0x0001  // lpBuffer points to sys mem
    #define DDADDBUFF_NONLOCALVIDMEM    0x0002  // lpBuffer points to AGP mem
    #define DDADDBUFF_INVERT            0x0004  // invert the buffer during capture

/*
 * Flushes the internal video port capture queue
 *
 * Input:  HANDLE to capture device
 * Output: DWORD DirectDraw return value
 */
#define DD_DXAPI_FLUSHVPCAPTUREBUFFERS                  (DD_FIRST_DXAPI+21)


/*
 * State flags returned by DSVXD_DXAPI_DD_GET_SURFACE_STATE
 */
#define DDSTATE_BOB                             0x0001
#define DDSTATE_WEAVE                           0x0002
#define DDSTATE_EXPLICITLY_SET                  0x0004
#define DDSTATE_SOFTWARE_AUTOFLIP               0x0008

/*
 * Event flags - passed into RegisterCallback
 */
#define DDEVENT_DISPLAY_VSYNC                   0x0001
#define DDEVENT_VP_VSYNC                        0x0002
#define DDEVENT_VP_LINE                         0x0004
#define DDEVENT_PRERESCHANGE                    0x0008
#define DDEVENT_POSTRESCHANGE                   0x0010
#define DDEVENT_PREDOSBOX                       0x0020
#define DDEVENT_POSTDOSBOX                      0x0040

/*
 * Notification flags - passed to the notification proc
 */
#define DDNOTIFY_DISPLAY_VSYNC                  0x0001  // dwParam1 = hDirectDraw
#define DDNOTIFY_VP_VSYNC                       0x0002  // dwParam1 = hVideoPort
#define DDNOTIFY_VP_LINE                        0x0004  // dwParam1 = hVideoPort
#define DDNOTIFY_PRERESCHANGE                   0x0008  // dwParam1 = hDirectDraw
#define DDNOTIFY_POSTRESCHANGE                  0x0010  // dwParam1 = hDirectDraw
#define DDNOTIFY_PREDOSBOX                      0x0020  // dwParam1 = hDirectDraw
#define DDNOTIFY_POSTDOSBOX                     0x0040  // dwParam1 = hDirectDraw
#define DDNOTIFY_CLOSEDIRECTDRAW                0x0080  // dwParam1 = hDirectDraw
#define DDNOTIFY_CLOSESURFACE                   0x0100  // dwParam1 = hSurface
#define DDNOTIFY_CLOSEVIDEOPORT                 0x0200  // dwParam1 = hVideoPort
#define DDNOTIFY_CLOSECAPTURE                   0x0400  // dwParam1 = hCapture

#ifdef __cplusplus
}
#endif // __cplusplus

#endif // __DDKMAPI_INCLUDED__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\ddraw\common\inc\ddVideo.h ===
/*
 * (C) Copyright NVIDIA Corporation Inc., 1996,1997,1998. All rights reserved.
 */
/********************************* Direct 3D *******************************\
*                                                                           *
* Module: ddVideo.h                                                         *
*    Definition file for:                                                   *
*       dvideo32.c                                                          *
*    Suggested new name:                                                    *
*       ddVideo.c                                                           *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*       Paul van der Kouwe 06/16/99 - created.                              *
*                                                                           *
\***************************************************************************/

#ifndef _DDVIDEO_H_
#define _DDVIDEO_H_

#ifdef __cplusplus
extern "C" {
#endif

// public
DWORD __stdcall ConvertOverlay32                (LPDDRAWI_DDRAWSURFACE_LCL, BOOL waitForCompletion, LPDWORD lpDstYOffset);
DWORD __stdcall PreScaleOverlay32               (LPDDRAWI_DDRAWSURFACE_LCL);
DWORD __stdcall UpdateOverlay32                 (LPDDHAL_UPDATEOVERLAYDATA);
DWORD __stdcall SetOverlayPosition32            (LPDDHAL_SETOVERLAYPOSITIONDATA);
BOOL  __stdcall GetVideoScalerBandwidthStatus32 (DWORD, DWORD);

#ifdef __cplusplus
}
#endif // __cplusplus

#endif // _DDVIDEO_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\ddraw\common\inc\GLOBAL.H ===
#ifndef _global_h // multiple include protection
#define _global_h

#ifdef __cplusplus
extern "C" {
#endif

//////////////////////////////////////////////////////////////////////////////
// All globals go into the 'global' structure. We divie the big structure up into
// banks. Every bank is a multiple of 32 bytes big. We place globals that are used
// together in inner loops in the same bank. This way we minimize pentium cache
// misses
//
// we assume that this structure starts 32-byte aligned. Will be so once all globs
// are placed here - and the C libraries do not mess with us... Look at .map output
// for alignment info
//
#pragma pack(push,1) // we control alignment

#ifdef SW_WC
#define SW_WC_LINES2FILL    48
#define SW_WC_LINESIZE      64
#define SW_WC_BYTES         (SW_WC_LINES2FILL*SW_WC_LINESIZE)
#define SW_WC_SIZE          (SW_WC_BYTES/4)     //# of DWORDS
#endif

typedef struct KATMAI_STATE
{
    // nv4/5
    float fFogC1[4];
    float fFogC2[4];
    float fFogTableDensity[4];
    float fFogTableLinearScale[4];
    float fFogTableStart[4];
    float fFogTableEnd[4];
    float fRHW[4];
    DWORD dwFogValue[4];
    float fZero[4];
    float fOne[4];
    float f255[4];
    DWORD dwMask3[4];
    // supertri
#ifdef SW_WC
    DWORD dwTriDispatch[SW_WC_SIZE];
#else
    DWORD dwTriDispatch[4];
#endif

#if (NVARCH >= 0x020)
#ifdef SW_WC
    DWORD dwKelvinTriDispatch[SW_WC_SIZE];
#else
    DWORD dwKelvinTriDispatch[4];
#endif
#endif
    struct TLVERTEX
    {
        float x,y,z,w;
        DWORD outCode;
        DWORD signOfW;
        DWORD _pad[2];
    } adwTLVertexCache[VB_CACHE_SIZE];
} KATMAI_STATE;

//---------------------------------------------------------------------------

#define SOFT_WC_SIZE    64 // must be power of 2, must be less than 120
typedef struct _GLOBALCELSIUSDATA
{
// bank
    DWORD  pContext;
    DWORD  pContext_hwState;
    DWORD  dwPrimCount;
    DWORD  pIndices;
    DWORD  pVertices;
    DWORD  dwVertexSN;
    DWORD  dwSoftWCIndex;
    DWORD  dwLoopCache;
// bank
    DWORD  dwVBIndex;
    DWORD  dwVBOffset;
    DWORD  dwVBGetOffset;
    DWORD  dwVBThreshold;
    DWORD  dwVerticesBatched;
    DWORD  dwPrimsBatched;
    DWORD  dwPrefetchBase;
    DWORD  dwPrefetchMax;
// bank
    DWORD  dwCullValue;
    DWORD  pIndexBase;          // used by inl prim & legacy
    DWORD  dwVertexStride;
    DWORD  dwIndexStride;
    DWORD  dwPrefMaxIdx;
    DWORD  dwEyeAddr;
    DWORD  dwCullAddr;
    DWORD  dwBaseVertex;
// bank
    float  pafMinInfo[4];
    float  pafMaxInfo[4];
// bank
    unsigned __int64 qwBegin3;
    unsigned __int64 qwEnd3;
    DWORD  _pad_c5[4];
// bank
    DWORD  dwOffsetXYZ;
    DWORD  dwOffsetRHW;
    DWORD  dwOffsetDiffuse;
    DWORD  dwOffsetSpecular;
    DWORD  dwOffsetNormal;
    DWORD  dwOffsetWeight;
    DWORD  _pad_c6[2];
// bank
    DWORD  dwOffsetUV[8];
// bank
    DWORD  dwSoftWCBuffer[SOFT_WC_SIZE];
} GLOBALCELSIUSDATA;

//---------------------------------------------------------------------------

#define KELVIN_MAX_REUSE 4
#define KELVIN_REUSE_MASK (KELVIN_MAX_REUSE-1)

typedef struct _GLOBALKELVINDATA
{
// bank
    DWORD  pContext;
    DWORD  pContext_kelvinState;
    DWORD  dwPrimCount;
    DWORD  pIndices;
    DWORD  pVertices;
    DWORD  dwVertexSN;
    DWORD  dwSoftWCIndex;
    DWORD  dwLoopCache;
// bank
    DWORD  dwVBIndex;
    DWORD  dwVBOffset;
    DWORD  dwVBGetOffset;
    DWORD  dwVBThreshold;
    DWORD  dwVerticesBatched;
    DWORD  dwPrimsBatched;
    DWORD  dwPrefetchBase;
    DWORD  dwPrefetchMax;
// bank
    DWORD  dwCullValue;
    DWORD  pIndexBase;          // used by inl prim & legacy
    DWORD  dwVertexStride;
    DWORD  dwIndexStride;
    DWORD  dwPrefMaxIdx;
    DWORD  dwEyeAddr;
    DWORD  dwCullAddr;
    DWORD  dwBaseVertex;
// bank
    float  pafMinInfo[4];
    float  pafMaxInfo[4];
// bank
    unsigned __int64 qwBegin;
    unsigned __int64 qwEnd;
    DWORD  _pad_c5[4];
// bank
// bank
    DWORD  dwOffsetXYZ;
    DWORD  dwOffsetRHW;
    DWORD  dwOffsetDiffuse;
    DWORD  dwOffsetSpecular;
    DWORD  dwOffsetNormal;
    DWORD  dwOffsetWeight;
    DWORD  dwOffsetPointSize;
    DWORD  _pad_c6[1];
// bank
    DWORD  dwOffsetUV[8];
// bank
    DWORD dwSoftWCBuffer[SOFT_WC_SIZE];
// bank
    DWORD   dwVertexReuse[KELVIN_MAX_REUSE];
// bank
    DWORD   dwCurrentHistoryIndex;
    DWORD   dwHistoryIndex;
    DWORD   __pad_c7[6];

} GLOBALKELVINDATA;

//---------------------------------------------------------------------------

typedef struct {
//////////
// debug and retail banks
// bank
    DWORD nvCachedPut;          // only used by inner loops
    DWORD nvCachedThreshold;    // only used by inner loops
    BYTE* dwILCData;
    DWORD dwILCCount;
    DWORD dwILCMax;
    DWORD dwCullMask1;
    DWORD dwCullMask2;
// bank
    DWORD    dwDelayCount;
    float    fPixelCount;
    double   fdMushLimitClocksPerTri;
    double   fdMushLimitClocksPerPixel;
//bank
    double   fdMushLimitClocksPerFrame;
    __int64  i64MushStart;
    DWORD    dwTriCountTotal;
    DWORD   _dwPad001[3];

// bank
    GLOBALCELSIUSDATA celsius;

// bank
    GLOBALKELVINDATA  kelvin;

    // dx5/dx6
// bank
    DWORD dwPrimCount;          // # of primitives to render
    DWORD pVertices;            // vertex list
    DWORD pIndices;             // index list (NULL for ordered prims)
    DWORD dwPrimBatchCount;     // # of prims per batch
    DWORD dwStripSense;         // strip sense (0 or 4)
    DWORD dwVertexSN;           // current vertex cache serial number
    DWORD dwVertexCount;        // vertex dispatcher vertex count
    float fCTC1;
// bank
    DWORD dwIndex0;             // )
    DWORD dwIndex1;             //  ) current triangle index
    DWORD dwIndex2;             // )
    DWORD dwVertex0;            // )
    DWORD dwVertex1;            //  ) current triangle
    DWORD dwVertex2;            // )
    DWORD dwBlendRegister;      // blend register (with spec enabled)
    DWORD dwSpecularCount;      // timeout for spec hack
// bank
    DWORD dwFlatColor;          // color used for flat shading
    DWORD dwFlatSpecular;       // specular used for flat shading
    float fRWFar;
    DWORD dwTemp;
#ifdef INSTRUMENT_INNER_LOOPS
    DWORD dwBytesCopied;
#else
    DWORD _reserved;
#endif
    DWORD dwMaxVertexOffset;    // used under NT only to validate vertices
    DWORD _pad2_3[1];
    KATMAI_STATE *pKNI;

    // bank 2.4 - note that the following variables start on the next 16-byte boundary and
    //            not neccesseraly exactly where this definition shows
    BYTE  kni[sizeof(KATMAI_STATE) + 16];
    //          - end alignment exception
    // bank 2.5
    DWORD dwVertexCacheIndex[VB_CACHE_SIZE]; // indices of cache hits
    DWORD dwVertexCache[VB_CACHE_SIZE];     // vertex cache
    // bank 2.6
    DWORD dwDXRuntimeVersion;
    BOOL  b16BitCode;                       // the current call stack has propogated from 16-bit code
    DWORD dwVertexCacheDate;
    DWORD dwSpecularState;                  // used to cache whether specular is on or off
                                            // for the specular optimzation in the inner loops (0/1)

    // pointer to GDI's display enumeration function
#ifdef WINNT
    DWORD _pad2_6[4];
#else
    BOOL   (WINAPI* pfEnumDisplayDevices)(LPCSTR, DWORD, PDISPLAY_DEVICE, DWORD);
    HANDLE (WINAPI *pfOpenVxDHandle)(HANDLE);
    DWORD _pad2_6[2];
#endif

    // banks 5-36
    DWORD adwMemCopy[256];

    // bank 37
    CNvObject                  *pNvObjectHead;
    struct _NV_OBJECT_LIST     *pNvSurfaceLists;     // list of surface handle->object lists
    struct _NV_OBJECT_LIST     *pNvPaletteLists;     // list of palette handle->object lists
    struct _NV_OBJECT_LIST     *pNvVShaderLists;     // list of vertex shader handle->object lists
    struct _NV_OBJECT_LIST     *pNvPShaderLists;     // list of pixel shader handle->object lists
    struct _NV_OBJECT_LIST     *pNvPatchLists;       // list of patch handle->object lists

    // bank 38
    double fdClockPerTri;
    double fdClockPerPixel;
    float  fTotalPixelsTimes2;
    DWORD _pad_5[3];

#if (NVARCH >= 0x010)
    PCELSIUSCOMBINERPROGRAM     celsiusCombinerProgramTable[CELSIUSCPTABLE_SIZE];
#endif // NVARCH == 0x010


} global_struc;

extern global_struc global;

//---------------------------------------------------------------------------

__forceinline void nvDelay
(
    void
)
{
    DWORD dw = global.dwDelayCount;
    __asm
    {
    push ecx
        mov ecx,[dw]
xxx:
        loop xxx
    pop ecx
    }
}

//---------------------------------------------------------------------------

// encrypted registry keys

#define NV4D3D_REG_STRING_SIZE_MAX  32

typedef char reg_entry[NV4D3D_REG_STRING_SIZE_MAX];

// keep this structure in sync with its initialization in global.cpp
typedef struct
{
    DWORD dwID[8];
    DWORD dwSize;
    /*
     * Encrypted registry key strings.
     */
    // booleans
    reg_entry szAntiAliasEnableString;             // ANTIALIASENABLE
    reg_entry szAntiAliasForceEnableString;        // ANTIALIASFORCEENABLE
    reg_entry szAntiAliasDynamicEnableString;      // ANTIALIASDYNAMICENABLE
    reg_entry szAntiAliasConvolutionFastModeString;// ANTIALIASCONVOLUTIONFASTMODE
    reg_entry szCKCompatabilityEnableString;       // CKCOMPATABILITYENABLE
    reg_entry szDirectMapEnableString;             // DIRECTMAPENABLE
    reg_entry szEnforceStrictTrilinearString;      // ENFORCESTRICTTRILINEAR
    reg_entry szFlushAfterBlitEnableString;        // FLUSHAFTERBLITENABLE
    reg_entry szFogTableString;                    // FOGTABLEENABLE
    reg_entry szForceBlitWaitFlagEnableString;     // FORCEBLITWAITFLAGENABLE
    reg_entry szLimitQueuedFBBlitsEnableString;    // LIMITQUEUEDFBBLITSENABLE
    reg_entry szLogoEnableString;                  // LOGOENABLE
#ifndef TEXFORMAT_CRD
    reg_entry szPaletteEnableString;               // PALETTEENABLE
#endif  // !TEXFORMAT_CRD
    reg_entry szSquashWString;                     // SQUASHW
    reg_entry szSceneSyncString;                   // SCENESYNC
#ifndef TEXFORMAT_CRD
    reg_entry szTextureCompressionEnableString;    // TEXTURECOMPRESSIONENABLE
#endif  // !TEXFORMAT_CRD
    reg_entry szTextureManagementEnableString;     // TEXTUREMANAGEMENTENABLE
    reg_entry szTilingString;                      // TILINGENABLE
    reg_entry szZCullEnableString;                 // ZCULLENABLE
    reg_entry szUserMipMapsString;                 // USERMIPMAPS
    reg_entry szVideoTextureString;                // VIDEOTEXTURE
    reg_entry szVS_HOS_EmulationString;            // VS_HOS_EMULATION
    reg_entry szWEnableString;                     // WENABLE
    reg_entry szZ24EnableString;                   // Z24ENABLE
    reg_entry szZCompressEnableString;             // ZCOMPRESSENABLE
    DWORD dwSyncPoint0;
    // non-boolean enumerated types
    reg_entry szAntiAliasQualityString;            // ANTIALIASQUALITY
    reg_entry szAntiAliasDynamicFPS;               // ANTIALIASDYNAMICFPS
    reg_entry szCaptureConfigString;               // CAPTURECONFIG
    reg_entry szCaptureEnableString;               // CAPTUREENABLE
    reg_entry szCKRefString;                       // CKREF
    reg_entry szAnisotropicLevelString;            // ANISOTROPICLEVEL
    reg_entry szMipMapDitherEnableString;          // MIPMAPDITHERENABLE
#ifdef TEXFORMAT_CRD
    reg_entry szSurfaceFormatsDX7String;           // SURFACEFORMATSDX7
    reg_entry szSurfaceFormatsDX8String;           // SURFACEFORMATSDX8
#endif  // TEXFORMAT_CRD
    reg_entry szTexelAlignmentString;              // TEXELALIGNMENT
    reg_entry szTextureManageStrategyString;       // TEXTUREMANAGESTRATEGY
    reg_entry szValidateZMethodString;             // VALIDATEZMETHOD
    reg_entry szVSyncModeString;                   // VSYNCMODE
    reg_entry szW16FormatString;                   // W16FORMAT
    reg_entry szW32FormatString;                   // W32FORMAT
    DWORD dwSyncPoint1;
    // non-boolean non-enumerated types
    reg_entry szAACompatibilityBitsString;         // AACOMPATIBILITYBITS
    reg_entry szAAReadCompatibilityFileString;     // AAREADCOMPATIBILITYFILE
    reg_entry szAGPTextureCutoff;                  // AGPTEXCUTOFF
    reg_entry szCapturePlayFilenum;                // D3D_REG_CAPTUREPLAYFILENUM
    reg_entry szCaptureRecordFilenum;              // D3D_REG_CAPTUREPLAYRECORDNUM
    reg_entry szD3DContextMaxString;               // D3DCONTEXTMAX
    reg_entry szD3DTextureMaxString;               // D3DTEXTUREMAX
    reg_entry szDebugLevelString;                  // DEBUGLEVEL
    reg_entry szLodBiasAdjustString;               // LODBIASADJUST
    reg_entry szMinVideoTexSizeString;             // MINVIDEOTEXSIZE
    reg_entry szPCITexHeapSizeString;              // PCITEXHEAPSIZE
    reg_entry szPerformanceStrategyOrString;       // PSOR
    reg_entry szPerformanceStrategyAndString;      // PSAND
    reg_entry szPreRenderLimitString;              // NOVSYNCPRERENDERLIMIT
    reg_entry szPushBufferSizeMaxString;           // DMAPUSHBUFFERSIZEMAX
    reg_entry szWScale16String;                    // WSCALE16
    reg_entry szWScale24String;                    // WSCALE24
    reg_entry szZBiasString;                       // ZBIAS
    DWORD dwSyncPoint2;
    // strings
    reg_entry szCapturePlayFilenameString;         // CAPTUREPLAYFILENAME
    reg_entry szCapturePlayPathString;             // CAPTUREPLAYPATH
    reg_entry szCaptureRecordFilenameString;       // CAPTURERECORDFILENAME
    reg_entry szCaptureRecordPathString;           // CAPTURERECORDPATH
    DWORD dwSyncPoint3;
} reg_struc;
extern reg_struc reg;

//---------------------------------------------------------------------------

void decryptRegistryKeys (void);


#pragma pack(pop)

//////////////////////////////////////////////////////////////////////////////
// this function initializes globals - see global.c
void __stdcall init_globals (void);

// GUID compare functions which can be compiled as C or CPP
#if defined(__cplusplus) && !defined(WINNT)
#define IsEqualGUID_C(rguid1, rguid2) IsEqualGUID((rguid1), (rguid2))
#define IsEqualIID_C(riid1, riid2) IsEqualIID((riid1), (riid2))
#else
#define IsEqualGUID_C(rguid1, rguid2) IsEqualGUID(&(rguid1), &(rguid2))
#define IsEqualIID_C(riid1, riid2) IsEqualIID(&(riid1), &(riid2))
#endif  //  __cplusplus

#ifdef __cplusplus
}
#endif // __cplusplus

#endif // _global_h
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\ddraw\common\inc\dxvadefs.h ===
/*==========================================================================;
 *
 *  Copyright (C) 1999, 2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:	dxva.h
 *
 *  Content:	DirectX Video Acceleration header file
 *
 *  Sept. 15, 2000
 *
 ***************************************************************************/

#ifndef __DIRECTX_VA__
#define __DIRECTX_VA__

#ifdef __cplusplus
extern "C" {
#endif

DEFINE_GUID(DXVA_ModeNone,    0x1b81be00, 0xa0c7,0x11d3,0xb9,0x84,0x00,0xc0,0x4f,0x2e,0x73,0xc5);
DEFINE_GUID(DXVA_ModeH261_A,  0x1b81be01, 0xa0c7,0x11d3,0xb9,0x84,0x00,0xc0,0x4f,0x2e,0x73,0xc5);
DEFINE_GUID(DXVA_ModeH261_B,  0x1b81be02, 0xa0c7,0x11d3,0xb9,0x84,0x00,0xc0,0x4f,0x2e,0x73,0xc5);
DEFINE_GUID(DXVA_ModeH263_A,  0x1b81be03, 0xa0c7,0x11d3,0xb9,0x84,0x00,0xc0,0x4f,0x2e,0x73,0xc5);
DEFINE_GUID(DXVA_ModeH263_B,  0x1b81be04, 0xa0c7,0x11d3,0xb9,0x84,0x00,0xc0,0x4f,0x2e,0x73,0xc5);
DEFINE_GUID(DXVA_ModeH263_C,  0x1b81be05, 0xa0c7,0x11d3,0xb9,0x84,0x00,0xc0,0x4f,0x2e,0x73,0xc5);
DEFINE_GUID(DXVA_ModeH263_D,  0x1b81be06, 0xa0c7,0x11d3,0xb9,0x84,0x00,0xc0,0x4f,0x2e,0x73,0xc5);
DEFINE_GUID(DXVA_ModeH263_E,  0x1b81be07, 0xa0c7,0x11d3,0xb9,0x84,0x00,0xc0,0x4f,0x2e,0x73,0xc5);
DEFINE_GUID(DXVA_ModeH263_F,  0x1b81be08, 0xa0c7,0x11d3,0xb9,0x84,0x00,0xc0,0x4f,0x2e,0x73,0xc5);
DEFINE_GUID(DXVA_ModeMPEG1_A, 0x1b81be09, 0xa0c7,0x11d3,0xb9,0x84,0x00,0xc0,0x4f,0x2e,0x73,0xc5);
DEFINE_GUID(DXVA_ModeMPEG2_A, 0x1b81be0A, 0xa0c7,0x11d3,0xb9,0x84,0x00,0xc0,0x4f,0x2e,0x73,0xc5);
DEFINE_GUID(DXVA_ModeMPEG2_B, 0x1b81be0B, 0xa0c7,0x11d3,0xb9,0x84,0x00,0xc0,0x4f,0x2e,0x73,0xc5);
DEFINE_GUID(DXVA_ModeMPEG2_C, 0x1b81be0C, 0xa0c7,0x11d3,0xb9,0x84,0x00,0xc0,0x4f,0x2e,0x73,0xc5);
DEFINE_GUID(DXVA_ModeMPEG2_D, 0x1b81be0D, 0xa0c7,0x11d3,0xb9,0x84,0x00,0xc0,0x4f,0x2e,0x73,0xc5);

DEFINE_GUID(DXVA_NoEncrypt,   0x1b81beD0, 0xa0c7,0x11d3,0xb9,0x84,0x00,0xc0,0x4f,0x2e,0x73,0xc5);
DEFINE_GUID(DXVA_EncryptProt1, 0x1b81beD1, 0xa0c7,0x11d3,0xb9,0x84,0x00,0xc0,0x4f,0x2e,0x73,0xc5);

#define DXVA_RESTRICTED_MODE_UNRESTRICTED        0xFFFF
#define DXVA_RESTRICTED_MODE_H261_A              1
#define DXVA_RESTRICTED_MODE_H261_B              2
#define DXVA_RESTRICTED_MODE_H263_A              3
#define DXVA_RESTRICTED_MODE_H263_B              4
#define DXVA_RESTRICTED_MODE_H263_C              5
#define DXVA_RESTRICTED_MODE_H263_D              6
#define DXVA_RESTRICTED_MODE_H263_E              7
#define DXVA_RESTRICTED_MODE_H263_F              8
#define DXVA_RESTRICTED_MODE_MPEG1_A             9
#define DXVA_RESTRICTED_MODE_MPEG2_A             0xA
#define DXVA_RESTRICTED_MODE_MPEG2_B             0xB
#define DXVA_RESTRICTED_MODE_MPEG2_C             0xC
#define DXVA_RESTRICTED_MODE_MPEG2_D             0xD

#define DXVA_COMPBUFFER_TYPE_THAT_IS_NOT_USED    0
#define DXVA_PICTURE_DECODE_BUFFER               1
#define DXVA_MACROBLOCK_CONTROL_BUFFER           2
#define DXVA_RESIDUAL_DIFFERENCE_BUFFER          3
#define DXVA_DEBLOCKING_CONTROL_BUFFER           4
#define DXVA_INVERSE_QUANTIZATION_MATRIX_BUFFER  5
#define DXVA_SLICE_CONTROL_BUFFER                6
#define DXVA_BITSTREAM_DATA_BUFFER               7
#define DXVA_AYUV_BUFFER                         8
#define DXVA_IA44_SURFACE_BUFFER                 9
#define DXVA_DPXD_SURFACE_BUFFER                10
#define DXVA_HIGHLIGHT_BUFFER                   11
#define DXVA_DCCMD_SURFACE_BUFFER               12
#define DXVA_ALPHA_BLEND_COMBINATION_BUFFER     13
#define DXVA_PICTURE_RESAMPLE_BUFFER            14
#define DXVA_READ_BACK_BUFFER                   15

#define DXVA_NUM_TYPES_COMP_BUFFERS             16

/* values for bDXVA_Func */
#define DXVA_PICTURE_DECODING_FUNCTION        1
#define DXVA_ALPHA_BLEND_DATA_LOAD_FUNCTION   2
#define DXVA_ALPHA_BLEND_COMBINATION_FUNCTION 3
#define DXVA_PICTURE_RESAMPLE_FUNCTION        4

/* values returned from Execute command in absence of read-back */
#define DXVA_EXECUTE_RETURN_OK                  0
#define DXVA_EXECUTE_RETURN_DATA_ERROR_MINOR    1
#define DXVA_EXECUTE_RETURN_DATA_ERROR_SIGNIF   2
#define DXVA_EXECUTE_RETURN_DATA_ERROR_SEVERE   3
#define DXVA_EXECUTE_RETURN_OTHER_ERROR_SEVERE  4


#pragma pack(push, BeforeDXVApacking, 1)


typedef struct _DXVA_ConnectMode {
  GUID guidMode;
  WORD wRestrictedMode;
} DXVA_ConnectMode, *LPDXVA_ConnectMode;


typedef DWORD DXVA_ConfigQueryOrReplyFunc, *LPDXVA_ConfigQueryOrReplyFunc;

#define DXVA_QUERYORREPLYFUNCFLAG_DECODER_PROBE_QUERY     0xFFFFF1
#define DXVA_QUERYORREPLYFUNCFLAG_DECODER_LOCK_QUERY      0xFFFFF5
#define DXVA_QUERYORREPLYFUNCFLAG_ACCEL_PROBE_OK_COPY     0xFFFFF8
#define DXVA_QUERYORREPLYFUNCFLAG_ACCEL_PROBE_OK_PLUS     0xFFFFF9
#define DXVA_QUERYORREPLYFUNCFLAG_ACCEL_LOCK_OK_COPY      0xFFFFFC
#define DXVA_QUERYORREPLYFUNCFLAG_ACCEL_PROBE_FALSE_PLUS  0xFFFFFB
#define DXVA_QUERYORREPLYFUNCFLAG_ACCEL_LOCK_FALSE_PLUS   0xFFFFFF

#define readDXVA_QueryOrReplyFuncFlag(ptr)        ((*(ptr)) >> 8)

#define readDXVA_QueryOrReplyFuncFlag_ACCEL(ptr)  (((*(ptr)) >> 11) & 1)
#define readDXVA_QueryOrReplyFuncFlag_LOCK(ptr)   (((*(ptr)) >> 10) & 1)
#define readDXVA_QueryOrReplyFuncFlag_BAD(ptr)    (((*(ptr)) >>  9) & 1)
#define readDXVA_QueryOrReplyFuncFlag_PLUS(ptr)   (((*(ptr)) >>  8) & 1)

#define readDXVA_QueryOrReplyFuncFunc(ptr)        ((*(ptr)) & 0xFF)

#define writeDXVA_QueryOrReplyFunc(ptr, flg, fnc) ((*(ptr)) = ((flg) << 8) | (fnc))

#define setDXVA_QueryOrReplyFuncFlag(ptr, flg) ((*(ptr)) |= ((flg) << 8))
#define setDXVA_QueryOrReplyFuncFunc(ptr, fnc) ((*(ptr)) |= (fnc));

typedef DWORD DXVA_EncryptProtocolFunc, *LPDXVA_EncryptProtocolFunc;

#define DXVA_ENCRYPTPROTOCOLFUNCFLAG_HOST    0xFFFF00
#define DXVA_ENCRYPTPROTOCOLFUNCFLAG_ACCEL   0xFFFF08

#define readDXVA_EncryptProtocolFuncFlag(ptr)        ((*(ptr)) >> 8)
#define readDXVA_EncryptProtocolFuncFlag_ACCEL(ptr)  (((*(ptr)) >> 11) & 1)

#define readDXVA_EncryptProtocolFuncFunc(ptr)        ((*(ptr)) & 0xFF)

#define writeDXVA_EncryptProtocolFunc(ptr, flg, fnc) ((*(ptr)) = ((flg) << 8) | (fnc))

#define setDXVA_EncryptProtocolFuncFlag(ptr, flg) ((*(ptr)) |= ((flg) << 8))
#define setDXVA_EncryptProtocolFuncFunc(ptr, fnc) ((*(ptr)) |= (fnc));

typedef struct _DXVA_EncryptProtocolHeader {
  DXVA_EncryptProtocolFunc dwFunction;
  DWORD ReservedBits[3];
  GUID  guidEncryptProtocol;
} DXVA_EncryptProtocolHeader, *LPDXVA_EncryptProtocolHeader;

typedef struct _DXVA_ConfigPictureDecode {

  // Operation Indicated
  DXVA_ConfigQueryOrReplyFunc dwFunction;

  // Alignment
  DWORD dwReservedBits[3];

  // Encryption GUIDs
  GUID guidConfigBitstreamEncryption;
  GUID guidConfigMBcontrolEncryption;
  GUID guidConfigResidDiffEncryption;

  // Bitstream Processing Indicator
  BYTE bConfigBitstreamRaw;

  // Macroblock Control Config
  BYTE bConfigMBcontrolRasterOrder;

  // Host Resid Diff Config
  BYTE bConfigResidDiffHost;
  BYTE bConfigSpatialResid8;
  BYTE bConfigResid8Subtraction;
  BYTE bConfigSpatialHost8or9Clipping;
  BYTE bConfigSpatialResidInterleaved;
  BYTE bConfigIntraResidUnsigned;

  // Accelerator Resid Diff Config
  BYTE bConfigResidDiffAccelerator;
  BYTE bConfigHostInverseScan;
  BYTE bConfigSpecificIDCT;
  BYTE bConfig4GroupedCoefs;
} DXVA_ConfigPictureDecode, *LPDXVA_ConfigPictureDecode;


/* Picture Decoding Parameters */

typedef struct _DXVA_PictureParameters {

  WORD wDecodedPictureIndex;
  WORD wDeblockedPictureIndex;

  WORD wForwardRefPictureIndex;
  WORD wBackwardRefPictureIndex;

  WORD wPicWidthInMBminus1;
  WORD wPicHeightInMBminus1;

  BYTE bMacroblockWidthMinus1;
  BYTE bMacroblockHeightMinus1;

  BYTE bBlockWidthMinus1;
  BYTE bBlockHeightMinus1;

  BYTE bBPPminus1;

  BYTE bPicStructure;
  BYTE bSecondField;
  BYTE bPicIntra;
  BYTE bPicBackwardPrediction;

  BYTE bBidirectionalAveragingMode;
  BYTE bMVprecisionAndChromaRelation;
  BYTE bChromaFormat;

  BYTE bPicScanFixed;
  BYTE bPicScanMethod;
  BYTE bPicReadbackRequests;

  BYTE bRcontrol;
  BYTE bPicSpatialResid8;
  BYTE bPicOverflowBlocks;
  BYTE bPicExtrapolation;

  BYTE bPicDeblocked;
  BYTE bPicDeblockConfined;
  BYTE bPic4MVallowed;
  BYTE bPicOBMC;
  BYTE bPicBinPB;
  BYTE bMV_RPS;

  BYTE bReservedBits;

  WORD wBitstreamFcodes;
  WORD wBitstreamPCEelements;
  BYTE bBitstreamConcealmentNeed;
  BYTE bBitstreamConcealmentMethod;

} DXVA_PictureParameters, *LPDXVA_PictureParameters;


/* Picture Resampling */

typedef struct _DXVA_PicResample {

  WORD  wPicResampleSourcePicIndex;
  WORD  wPicResampleDestPicIndex;

  WORD  wPicResampleRcontrol;
  BYTE  bPicResampleExtrapWidth;
  BYTE  bPicResampleExtrapHeight;

  DWORD dwPicResampleSourceWidth;
  DWORD dwPicResampleSourceHeight;

  DWORD dwPicResampleDestWidth;
  DWORD dwPicResampleDestHeight;

  DWORD dwPicResampleFullDestWidth;
  DWORD dwPicResampleFullDestHeight;

} DXVA_PicResample, *LPDXVA_PicResample;


#define DXVA_CHROMA_FORMAT_420 1
#define DXVA_CHROMA_FORMAT_422 2
#define DXVA_CHROMA_FORMAT_444 3

#define DXVA_PICTURE_STRUCTURE_TOP_FIELD    1
#define DXVA_PICTURE_STRUCTURE_BOTTOM_FIELD 2
#define DXVA_PICTURE_STRUCTURE_FRAME        3

#define DXVA_BIDIRECTIONAL_AVERAGING_MPEG2_ROUND 0
#define DXVA_BIDIRECTIONAL_AVERAGING_H263_TRUNC  1

#define DXVA_MV_PRECISION_AND_CHROMA_RELATION_MPEG2  0
#define DXVA_MV_PRECISION_AND_CHROMA_RELATION_H263   1
#define DXVA_MV_PRECISION_AND_CHROMA_RELATION_H261   2

#define DXVA_SCAN_METHOD_ZIG_ZAG              0
#define DXVA_SCAN_METHOD_ALTERNATE_VERTICAL   1
#define DXVA_SCAN_METHOD_ALTERNATE_HORIZONTAL 2
#define DXVA_SCAN_METHOD_ARBITRARY            3

#define DXVA_BITSTREAM_CONCEALMENT_NEED_UNLIKELY 0
#define DXVA_BITSTREAM_CONCEALMENT_NEED_MILD     1
#define DXVA_BITSTREAM_CONCEALMENT_NEED_LIKELY   2
#define DXVA_BITSTREAM_CONCEALMENT_NEED_SEVERE   3

#define DXVA_BITSTREAM_CONCEALMENT_METHOD_UNSPECIFIED 0
#define DXVA_BITSTREAM_CONCEALMENT_METHOD_INTRA       1
#define DXVA_BITSTREAM_CONCEALMENT_METHOD_FORWARD     2
#define DXVA_BITSTREAM_CONCEALMENT_METHOD_BACKWARD    3


/* Buffer Description Data */

typedef struct _DXVA_BufferDescription {
  DWORD dwTypeIndex;
  DWORD dwBufferIndex;
  DWORD dwDataOffset;
  DWORD dwDataSize;
  DWORD dwFirstMBaddress;
  DWORD dwNumMBsInBuffer;
  DWORD dwWidth;
  DWORD dwHeight;
  DWORD dwStride;
  DWORD dwReservedBits;
} DXVA_BufferDescription, *LPDXVA_BufferDescription;


/* Off-Host IDCT Coefficient Data Structures */

typedef struct _DXVA_TCoef4Group {
  BYTE  TCoefIDX[4];
  SHORT TCoefValue[4];
} DXVA_TCoef4Group, *LPDXVA_TCoef4Group;

typedef struct _DXVA_TCoefSingle {
  WORD  wIndexWithEOB;
  SHORT TCoefValue;
} DXVA_TCoefSingle, *LPDXVA_TCoefSingle;

/* Macros for Reading EOB and Index Values */

#define readDXVA_TCoefSingleIDX(ptr) ((ptr)->wIndexWithEOB >> 1)
#define readDXVA_TCoefSingleEOB(ptr) ((ptr)->wIndexWithEOB & 1)

/* Macro for Writing EOB and Index Values */

#define writeDXVA_TCoefSingleIndexWithEOB(ptr, idx, eob) ((ptr)->wIndexWithEOB = ((idx) << 1) | (eob))
#define setDXVA_TCoefSingleIDX(ptr, idx) ((ptr)->wIndexWithEOB |= ((idx) << 1))
#define setDXVA_TCoefSingleEOB(ptr)      ((ptr)->wIndexWithEOB |= 1)

/* Spatial-Domain Residual Difference Blocks */

#define DXVA_USUAL_BLOCK_WIDTH   8
#define DXVA_USUAL_BLOCK_HEIGHT  8
#define DXVA_USUAL_BLOCK_SIZE   (DXVA_USUAL_BLOCK_WIDTH * DXVA_USUAL_BLOCK_HEIGHT)

typedef SHORT       DXVA_Sample16[DXVA_USUAL_BLOCK_SIZE];
typedef signed char DXVA_Sample8 [DXVA_USUAL_BLOCK_SIZE];

/* Deblocking Filter Control Structure */

typedef BYTE DXVA_DeblockingEdgeControl;

typedef DXVA_DeblockingEdgeControl * LPDXVA_DeblockingEdgeControl;

/* Macros for Reading STRENGTH and FilterOn */

#define readDXVA_EdgeFilterStrength(ptr) ((*(ptr)) >> 1)
#define readDXVA_EdgeFilterOn(ptr)       ((*(ptr)) & 1)

/* Macro for Writing STRENGTH and FilterOn */

#define writeDXVA_DeblockingEdgeControl(ptr, str, fon) ((*(ptr)) = ((str) << 1) | (fon))
#define setDXVA_EdgeFilterStrength(ptr, str)           ((*(ptr)) |= ((str) << 1))
#define setDXVA_EdgeFilterOn(ptr)                      ((*(ptr)) |= 1)


/* Macroblock Control Command Data Structures */

typedef struct _DXVA_MVvalue {
  SHORT horz, vert;
} DXVA_MVvalue, *LPDXVA_MVvalue;


/* Inverse Quantization Matrices */

typedef struct _DXVA_QmatrixData {
  BYTE bNewQmatrix[4]; /* intra Y, inter Y, intra chroma, inter chroma */
  WORD Qmatrix[4][DXVA_USUAL_BLOCK_WIDTH * DXVA_USUAL_BLOCK_HEIGHT];
} DXVA_QmatrixData, *LPDXVA_QmatrixData;


/* Slice Control Buffer Data */

typedef struct _DXVA_SliceInfo {
  WORD  wHorizontalPosition;
  WORD  wVerticalPosition;
  DWORD dwSliceBitsInBuffer;
  DWORD dwSliceDataLocation;
  BYTE  bStartCodeBitOffset;
  BYTE  bReservedBits;
  WORD  wMBbitOffset;
  WORD  wNumberMBsInSlice;
  WORD  wQuantizerScaleCode;
  WORD  wBadSliceChopping;
} DXVA_SliceInfo, *LPDXVA_SliceInfo;


#define DXVA_NumMV_OBMC_off_BinPBwith4MV_off    4
#define DXVA_NumMV_OBMC_off_BinPBwith4MV_on  (4+1)
#define DXVA_NumMV_OBMC_on__BinPB_off         (10)
#define DXVA_NumMV_OBMC_on__BinPB_on          (11) /* not current standards */

#define DXVA_NumBlocksPerMB_420 (4+2+0)
#define DXVA_NumBlocksPerMB_422 (4+2+2)
#define DXVA_NumBlocksPerMB_444 (4+4+4)

/* Basic form for I pictures */
/* Host Residual Differences */
typedef struct _DXVA_MBctrl_I_HostResidDiff_1 {
  WORD  wMBaddress;
  WORD  wMBtype;
  DWORD dwMB_SNL;
  WORD  wPatternCode;
  WORD  wPC_Overflow; /* zero if not overflow format */
  DWORD dwReservedBits2;
} DXVA_MBctrl_I_HostResidDiff_1;

/* Basic form for I pictures */
/* Off-Host IDCT, 4:2:0 sampling */
typedef struct _DXVA_MBctrl_I_OffHostIDCT_1 {
  WORD  wMBaddress;
  WORD  wMBtype;
  DWORD dwMB_SNL;
  WORD  wPatternCode;
  BYTE  bNumCoef[DXVA_NumBlocksPerMB_420];
} DXVA_MBctrl_I_OffHostIDCT_1;

/* Basic form for P and B pictures */
/* Should also be used for concealment MVs in MPEG-2 I pictures */
/* Without OBMC, without BinPB and 4MV together, without MV RPS */
/* Host Residual Differences */
typedef struct _DXVA_MBctrl_P_HostResidDiff_1 {
  WORD         wMBaddress;
  WORD         wMBtype;
  DWORD        dwMB_SNL;
  WORD         wPatternCode;
  WORD         wPC_Overflow; /* zero if not overflow format */
  DWORD        dwReservedBits2;
  DXVA_MVvalue MVector[DXVA_NumMV_OBMC_off_BinPBwith4MV_off];
} DXVA_MBctrl_P_HostResidDiff_1;

/* Basic form for P and B pictures */
/* Without OBMC, without BinPB and 4MV together, without MV RPS */
/* Off-Host IDCT, 4:2:0 sampling */
typedef struct _DXVA_MBctrl_P_OffHostIDCT_1 {
  WORD         wMBaddress;
  WORD         wMBtype;
  DWORD        dwMB_SNL;
  WORD         wPatternCode;
  BYTE         bNumCoef[DXVA_NumBlocksPerMB_420];
  DXVA_MVvalue MVector[DXVA_NumMV_OBMC_off_BinPBwith4MV_off];
} DXVA_MBctrl_P_OffHostIDCT_1;

/* How to load alpha blending graphic data */
typedef struct _DXVA_ConfigAlphaLoad {

  // Operation Indicated
  DXVA_ConfigQueryOrReplyFunc dwFunction;

  // Alignment
  DWORD dwReservedBits[3];

  BYTE  bConfigDataType;
} DXVA_ConfigAlphaLoad, *LPDXVA_ConfigAlphaLoad;

#define DXVA_CONFIG_DATA_TYPE_IA44  0
#define DXVA_CONFIG_DATA_TYPE_AI44  1
#define DXVA_CONFIG_DATA_TYPE_DPXD  2
#define DXVA_CONFIG_DATA_TYPE_AYUV  3


/* How to combine alpha blending graphic data */
typedef struct _DXVA_ConfigAlphaCombine {

  // Operation Indicated
  DXVA_ConfigQueryOrReplyFunc dwFunction;

  // Alignment
  DWORD dwReservedBits[3];

  BYTE  bConfigBlendType;
  BYTE  bConfigPictureResizing;
  BYTE  bConfigOnlyUsePicDestRectArea;
  BYTE  bConfigGraphicResizing;
  BYTE  bConfigWholePlaneAlpha;

} DXVA_ConfigAlphaCombine, *LPDXVA_ConfigAlphaCombine;

#define DXVA_CONFIG_BLEND_TYPE_FRONT_BUFFER   0
#define DXVA_CONFIG_BLEND_TYPE_BACK_HARDWARE  1


/* AYUV sample for 16-entry YUV palette or graphic surface */

typedef struct _DXVA_AYUVsample {
//  BYTE bSampleAlpha8, bY_Value, bCbValue, bCrValue;
    //new in version 1.01
    BYTE bCrValue, bCbValue, bY_Value, bSampleAlpha8;
} DXVA_AYUVsample, *LPDXVA_AYUVsample;

/* Macros for IA44 alpha blending surface samples */

typedef BYTE DXVA_IA44sample, *LPDXVA_IA44sample;

#define readDXVA_IA44index(ptr) (((*(ptr)) & 0xF0) >> 4)
#define readDXVA_IA44alpha(ptr)  ((*(ptr)) & 0x0F)

#define writeDXVA_IA44(ptr, idx, alpha) ((*(ptr)) = (((idx) << 4) | (alpha)))

#define setDXVA_IA44index(ptr, idx)    ((*(ptr)) |= ((idx) << 4))
#define setDXVA_IA44alpha(ptr, alpha)  ((*(ptr)) |= (alpha))

/* Macros for AI44 alpha blending surface samples */

typedef BYTE DXVA_AI44sample, *LPDXVA_AI44sample;

#define readDXVA_AI44index(ptr)  ((*(ptr)) & 0x0F)
#define readDXVA_AI44alpha(ptr) (((*(ptr)) & 0xF0) >> 4)

#define writeDXVA_AI44(ptr, idx, alpha) ((*(ptr)) = (((alpha) << 4) | (idx)))

#define setDXVA_AI44index(ptr, idx)    ((*(ptr)) |= (idx))
#define setDXVA_AI44alpha(ptr, alpha)  ((*(ptr)) |= ((alpha) << 4))


/* Highlight data structure */

typedef struct _DXVA_Highlight {
  WORD wHighlightActive;
  WORD wHighlightIndices;
  WORD wHighlightAlphas;
  RECT HighlightRect;
} DXVA_Highlight, *LPDXVA_Highlight;

typedef BYTE DXVA_DPXD,  *LPDXVA_DPXD;
typedef WORD DXVA_DCCMD, *LPDXVA_DCCMD;

/* Alpha blend combination */

typedef struct _DXVA_BlendCombination {
  WORD wPictureSourceIndex;
  WORD wBlendedDestinationIndex;
  RECT PictureSourceRect16thPel;
  RECT PictureDestinationRect;
  RECT GraphicSourceRect;
  RECT GraphicDestinationRect;
  WORD wBlendDelay;
  BYTE bBlendOn;
  BYTE bWholePlaneAlpha;
  DXVA_AYUVsample OutsideYUVcolor;
} DXVA_BlendCombination, *LPDXVA_BlendCombination;


/* Encryption Protocol #1 Data Structure */

#define DXVA_MAX_URIsize  1024

typedef struct _DXVA_EncryptProt1Data_Sign512_Accel512 {
  DXVA_EncryptProtocolHeader header;

  DWORD  dwSigningModulusSize;  /* equal to 64 */
  BYTE   SigningModulusValue[64];
  DWORD  dwSigningExponentSize; /* equal to 64 */
  BYTE   SigningExponentValue[64];

  DWORD  dwAccelModulusSize;    /* equal to 64 */
  BYTE   AccelModulusValue[64];
  DWORD  dwAccelExponentSize;   /* equal to 64 */
  BYTE   AccelExponentValue[64];

  DWORD  dwEncryptionFrequency;

  DWORD  dwURIsize;
  WCHAR  URIstring[DXVA_MAX_URIsize];

  BYTE   Signature[64];
} DXVA_EncryptProt1Data_Sign512_Accel512,
  *LPDXVA_EncryptProt1Data_Sign512_Accel512;


#pragma pack(push, 16)


typedef DXVA_MBctrl_I_HostResidDiff_1 *
       LPDXVA_MBctrl_I_HostResidDiff_1;

typedef DXVA_MBctrl_I_OffHostIDCT_1 *
       LPDXVA_MBctrl_I_OffHostIDCT_1;

typedef DXVA_MBctrl_P_HostResidDiff_1 *
       LPDXVA_MBctrl_P_HostResidDiff_1;

typedef DXVA_MBctrl_P_OffHostIDCT_1 *
       LPDXVA_MBctrl_P_OffHostIDCT_1;


#pragma pack(pop)

/*
 * Other forms of pictures are constructed in the obvious way
 * from the above by adjusting the number of residual difference
 * blocks, the number of motion vectors per macroblock, etc.
 */

#define readDXVA_MBskipsFollowing(ptr)       (((ptr)->dwMB_SNL & 0xFF000000) >> 24)
#define readDXVA_MBdataLocation(ptr)         (((ptr)->dwMB_SNL & 0x00FFFFFF))

#define writeDXVA_MB_SNL(ptr, skips, dloc)   ((ptr)->dwMB_SNL = (((skips) << 24) | (dloc)))
#define setDXVA_MBskipsFollowing(ptr, skips) ((ptr)->dwMB_SNL |= ((skips) << 24))
#define setDXVA_MBdataLocation(ptr, dloc)    ((ptr)->dwMB_SNL |= (dloc))

#define readDXVA_MvertFieldSel_3(ptr)    (((ptr)->wMBtype & 0x8000) >> 15)
#define readDXVA_MvertFieldSel_2(ptr)    (((ptr)->wMBtype & 0x4000) >> 14)
#define readDXVA_MvertFieldSel_1(ptr)    (((ptr)->wMBtype & 0x2000) >> 13)
#define readDXVA_MvertFieldSel_0(ptr)    (((ptr)->wMBtype & 0x1000) >> 12)
#define readDXVA_ReservedBits(ptr)       (((ptr)->wMBtype & 0x0800) >> 11)
#define readDXVA_HostResidDiff(ptr)      (((ptr)->wMBtype & 0x0400) >> 10)
#define readDXVA_MotionType(ptr)         (((ptr)->wMBtype & 0x0300) >>  8)
#define readDXVA_MBscanMethod(ptr)       (((ptr)->wMBtype & 0x00C0) >>  6)
#define readDXVA_FieldResidual(ptr)      (((ptr)->wMBtype & 0x0020) >>  5)
#define readDXVA_H261LoopFilter(ptr)     (((ptr)->wMBtype & 0x0010) >>  4)
#define readDXVA_Motion4MV(ptr)          (((ptr)->wMBtype & 0x0008) >>  3)
#define readDXVA_MotionBackward(ptr)     (((ptr)->wMBtype & 0x0004) >>  2)
#define readDXVA_MotionForward(ptr)      (((ptr)->wMBtype & 0x0002) >>  1)
#define readDXVA_IntraMacroblock(ptr)    (((ptr)->wMBtype & 0x0001))

#define setDXVA_MvertFieldSel_3(ptr)     ((ptr)->wMBtype |= 0x8000)
#define setDXVA_MvertFieldSel_2(ptr)     ((ptr)->wMBtype |= 0x4000)
#define setDXVA_MvertFieldSel_1(ptr)     ((ptr)->wMBtype |= 0x2000)
#define setDXVA_MvertFieldSel_0(ptr)     ((ptr)->wMBtype |= 0x1000)
#define setDXVA_ReservedBits(ptr)        ((ptr)->wMBtype |= 0x0800)
#define setDXVA_HostResidDiff(ptr)       ((ptr)->wMBtype |= 0x0400)
#define setDXVA_MotionType(ptr, value)   ((ptr)->wMBtype |= ((value) << 8))
#define setDXVA_MBscanMethod(ptr, value) ((ptr)->wMBtype |= ((value) << 6))
#define setDXVA_FieldResidual(ptr)       ((ptr)->wMBtype |= 0x0020)
#define setDXVA_H261LoopFilter(ptr)      ((ptr)->wMBtype |= 0x0010)
#define setDXVA_Motion4MV(ptr)           ((ptr)->wMBtype |= 0x0008)
#define setDXVA_MotionBackward(ptr)      ((ptr)->wMBtype |= 0x0004)
#define setDXVA_MotionForward(ptr)       ((ptr)->wMBtype |= 0x0002)
#define setDXVA_IntraMacroblock(ptr)     ((ptr)->wMBtype |= 0x0001)

#define readDXVA_Y___0coded(ptr)        (((ptr)->wPatternCode & 0x0800) >> 11)
#define readDXVA_Y___1coded(ptr)        (((ptr)->wPatternCode & 0x0400) >> 10)
#define readDXVA_Y___2coded(ptr)        (((ptr)->wPatternCode & 0x0200) >>  9)
#define readDXVA_Y___3coded(ptr)        (((ptr)->wPatternCode & 0x0100) >>  8)
#define readDXVA_Cb__4coded(ptr)        (((ptr)->wPatternCode & 0x0080) >>  7)
#define readDXVA_Cr__5coded(ptr)        (((ptr)->wPatternCode & 0x0040) >>  6)
#define readDXVA_Cb__6coded(ptr)        (((ptr)->wPatternCode & 0x0020) >>  5)
#define readDXVA_Cr__7coded(ptr)        (((ptr)->wPatternCode & 0x0010) >>  4)
#define readDXVA_Cb__8coded(ptr)        (((ptr)->wPatternCode & 0x0008) >>  3)
#define readDXVA_Cb__9coded(ptr)        (((ptr)->wPatternCode & 0x0004) >>  2)
#define readDXVA_Cr_10coded(ptr)        (((ptr)->wPatternCode & 0x0002) >>  1)
#define readDXVA_Cr_11coded(ptr)        (((ptr)->wPatternCode & 0x0001))

#define readDXVA_Y___0oflow(ptr)        (((ptr)->wPC_Overflow & 0x0800) >> 11)
#define readDXVA_Y___1oflow(ptr)        (((ptr)->wPC_Overflow & 0x0400) >> 10)
#define readDXVA_Y___2oflow(ptr)        (((ptr)->wPC_Overflow & 0x0200) >>  9)
#define readDXVA_Y___3oflow(ptr)        (((ptr)->wPC_Overflow & 0x0100) >>  8)
#define readDXVA_Cb__4oflow(ptr)        (((ptr)->wPC_Overflow & 0x0080) >>  7)
#define readDXVA_Cr__5oflow(ptr)        (((ptr)->wPC_Overflow & 0x0040) >>  6)
#define readDXVA_Cb__6oflow(ptr)        (((ptr)->wPC_Overflow & 0x0020) >>  5)
#define readDXVA_Cr__7oflow(ptr)        (((ptr)->wPC_Overflow & 0x0010) >>  4)
#define readDXVA_Cb__8oflow(ptr)        (((ptr)->wPC_Overflow & 0x0008) >>  3)
#define readDXVA_Cb__9oflow(ptr)        (((ptr)->wPC_Overflow & 0x0004) >>  2)
#define readDXVA_Cr_10oflow(ptr)        (((ptr)->wPC_Overflow & 0x0002) >>  1)
#define readDXVA_Cr_11oflow(ptr)        (((ptr)->wPC_Overflow & 0x0001))

#pragma pack(pop, BeforeDXVApacking)

#ifdef __cplusplus
}
#endif

#endif /* __DIRECTX_VA__ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\ddraw\common\inc\nv4caps.h ===
#ifndef _NV4DCAPS_H_
#define _NV4DCAPS_H_

/*
 * (C) Copyright NVIDIA Corporation Inc., 1996,1997. All rights reserved.
 */
/********************************* Direct 3D *******************************\
*                                                                           *
* Module: NV4DCAPS.H                                                        *
*   Define the capabilities of the NV4 D3D driver.                          *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*       Charles Inman (chasi)       01/26/98 - created                      *
*                                                                           *
\***************************************************************************/

/*
 * --------------------------------------------------------------------------
 *  Direct 3D HAL Capabilities
 * --------------------------------------------------------------------------
 */

/*
 * Define which fields of the D3DDEVICECAPS structure are valid.
 */
#define NV4_DEVDESC_FLAGS           D3DDD_COLORMODEL                    |   \
                                    D3DDD_DEVCAPS                       |   \
                                    D3DDD_LINECAPS                      |   \
                                    D3DDD_TRICAPS                       |   \
                                    D3DDD_DEVICERENDERBITDEPTH          |   \
                                    D3DDD_DEVICEZBUFFERBITDEPTH

/*
 * Define the color model for the D3D driver.
 */
#define NV4_COLORMODEL              D3DCOLOR_RGB

/*
 * Define the device capabilities.
 */
#define NV4_DEVCAPS_FLAGS           D3DDEVCAPS_FLOATTLVERTEX            |   \
                                    D3DDEVCAPS_EXECUTESYSTEMMEMORY      |   \
                                    D3DDEVCAPS_TLVERTEXSYSTEMMEMORY     |   \
                                    D3DDEVCAPS_TEXTUREVIDEOMEMORY       |   \
                                    D3DDEVCAPS_DRAWPRIMTLVERTEX         |   \
                                    D3DDEVCAPS_TEXTURENONLOCALVIDMEM    |   \
                                    D3DDEVCAPS_DRAWPRIMITIVES2          |   \
                                    D3DDEVCAPS_DRAWPRIMITIVES2EX        |   \
                                    D3DDEVCAPS_HWRASTERIZATION

/*
 * Define the transformation capabilities.
 */
#define NV4_TRANSFORMCAPS_FLAGS     0

/*
 * Define 3D clipping capabilities.
 */
#define NV4_3DCLIPPINGCAPS          FALSE

/*
 * Define the lighting capabilities.
 */
#define NV4_LIGHTINGCAPS_FLAGS      0
#define NV4_MAX_LIGHTS              0

/*
 * Define NULL primary capabilities.
 */
#define NV4_PRIMCAPS_NULL           0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0

/*
 * Define the line capabilities.
 *
 * Miscellaneous capabilities (dwMiscCaps)
 */
#define NV4_LINECAPS_MISC           D3DPMISCCAPS_MASKZ                  |   \
                                    D3DPMISCCAPS_CULLNONE               |   \
                                    D3DPMISCCAPS_CULLCW                 |   \
                                    D3DPMISCCAPS_CULLCCW

/*
 * Raster capabilities (dwRasterCaps)
 */
#define NV4_LINECAPS_RASTER         D3DPRASTERCAPS_DITHER               |   \
                                    D3DPRASTERCAPS_SUBPIXEL             |   \
                                    D3DPRASTERCAPS_FOGVERTEX            |   \
                                    D3DPRASTERCAPS_FOGTABLE             |   \
                                    D3DPRASTERCAPS_MIPMAPLODBIAS        |   \
                                    D3DPRASTERCAPS_FOGRANGE             |   \
                                    D3DPRASTERCAPS_WBUFFER              |   \
                                    D3DPRASTERCAPS_WFOG                 |   \
                                    D3DPRASTERCAPS_ZFOG			
//                                  D3DPRASTERCAPS_ANISOTROPY           |   \

/*
 * Z Compare capabilities (dwZCmpCaps)
 */
#define NV4_LINECAPS_ZCMP           D3DPCMPCAPS_NEVER                   |   \
                                    D3DPCMPCAPS_LESS                    |   \
                                    D3DPCMPCAPS_EQUAL                   |   \
                                    D3DPCMPCAPS_LESSEQUAL               |   \
                                    D3DPCMPCAPS_GREATER                 |   \
                                    D3DPCMPCAPS_NOTEQUAL                |   \
                                    D3DPCMPCAPS_GREATEREQUAL            |   \
                                    D3DPCMPCAPS_ALWAYS

/*
 * Source blend capabilities (dwSrcBlendCaps)
 */
#define NV4_LINECAPS_SRCBLEND       D3DPBLENDCAPS_ZERO                  |   \
                                    D3DPBLENDCAPS_ONE                   |   \
                                    D3DPBLENDCAPS_SRCCOLOR              |   \
                                    D3DPBLENDCAPS_INVSRCCOLOR           |   \
                                    D3DPBLENDCAPS_SRCALPHA              |   \
                                    D3DPBLENDCAPS_INVSRCALPHA           |   \
                                    D3DPBLENDCAPS_DESTALPHA             |   \
                                    D3DPBLENDCAPS_INVDESTALPHA          |   \
                                    D3DPBLENDCAPS_DESTCOLOR             |   \
                                    D3DPBLENDCAPS_INVDESTCOLOR          |   \
                                    D3DPBLENDCAPS_SRCALPHASAT           |   \
                                    D3DPBLENDCAPS_BOTHSRCALPHA          |   \
                                    D3DPBLENDCAPS_BOTHINVSRCALPHA

/*
 * Destination blend capabilities (dwDestBlendCaps)
 */
#define NV4_LINECAPS_DESTBLEND      D3DPBLENDCAPS_ZERO                  |   \
                                    D3DPBLENDCAPS_ONE                   |   \
                                    D3DPBLENDCAPS_SRCCOLOR              |   \
                                    D3DPBLENDCAPS_INVSRCCOLOR           |   \
                                    D3DPBLENDCAPS_SRCALPHA              |   \
                                    D3DPBLENDCAPS_INVSRCALPHA           |   \
                                    D3DPBLENDCAPS_DESTALPHA             |   \
                                    D3DPBLENDCAPS_INVDESTALPHA          |   \
                                    D3DPBLENDCAPS_DESTCOLOR             |   \
                                    D3DPBLENDCAPS_INVDESTCOLOR          |   \
                                    D3DPBLENDCAPS_SRCALPHASAT           |   \
                                    D3DPBLENDCAPS_BOTHSRCALPHA          |   \
                                    D3DPBLENDCAPS_BOTHINVSRCALPHA

/*
 * Alpha compare capabilities (dwAlphaCmpCaps)
 */
#define NV4_LINECAPS_ALPHACMP       D3DPCMPCAPS_NEVER                   |   \
                                    D3DPCMPCAPS_LESS                    |   \
                                    D3DPCMPCAPS_EQUAL                   |   \
                                    D3DPCMPCAPS_LESSEQUAL               |   \
                                    D3DPCMPCAPS_GREATER                 |   \
                                    D3DPCMPCAPS_NOTEQUAL                |   \
                                    D3DPCMPCAPS_GREATEREQUAL            |   \
                                    D3DPCMPCAPS_ALWAYS

/*
 * Shading capabilities (dwShadeCaps)
 */
#define NV4_LINECAPS_SHADE          D3DPSHADECAPS_COLORFLATMONO         |   \
                                    D3DPSHADECAPS_COLORFLATRGB          |   \
                                    D3DPSHADECAPS_COLORGOURAUDMONO      |   \
                                    D3DPSHADECAPS_COLORGOURAUDRGB       |   \
                                    D3DPSHADECAPS_SPECULARFLATRGB       |   \
                                    D3DPSHADECAPS_SPECULARGOURAUDRGB    |   \
                                    D3DPSHADECAPS_ALPHAFLATBLEND        |   \
                                    D3DPSHADECAPS_ALPHAGOURAUDBLEND     |   \
                                    D3DPSHADECAPS_FOGFLAT               |   \
                                    D3DPSHADECAPS_FOGGOURAUD

/*
 * Texture capabilities (dwTextureCaps)
 */
#define NV4_LINECAPS_TEXTURE        D3DPTEXTURECAPS_PERSPECTIVE         |   \
                                    D3DPTEXTURECAPS_POW2                |   \
                                    D3DPTEXTURECAPS_ALPHA               |   \
                                    D3DPTEXTURECAPS_TRANSPARENCY        |   \
                                    D3DPTEXTURECAPS_TEXREPEATNOTSCALEDBYSIZE

/*
 * Texture filtering capabilities (dwTextureFilterCaps)
 */
#define NV4_LINECAPS_TEXTUREFILTER  D3DPTFILTERCAPS_NEAREST             |   \
                                    D3DPTFILTERCAPS_LINEAR              |   \
                                    D3DPTFILTERCAPS_MIPNEAREST          |   \
                                    D3DPTFILTERCAPS_MIPLINEAR           |   \
                                    D3DPTFILTERCAPS_LINEARMIPNEAREST    |   \
                                    D3DPTFILTERCAPS_LINEARMIPLINEAR     |   \
                                    D3DPTFILTERCAPS_MINFPOINT           |   \
                                    D3DPTFILTERCAPS_MINFLINEAR          |   \
                                    D3DPTFILTERCAPS_MIPFPOINT           |   \
                                    D3DPTFILTERCAPS_MIPFLINEAR          |   \
                                    D3DPTFILTERCAPS_MAGFPOINT           |   \
                                    D3DPTFILTERCAPS_MAGFLINEAR

/*
 * Texture blending capabilities (dwTextureBlendCaps)
 */
#define NV4_LINECAPS_TEXTUREBLEND   D3DPTBLENDCAPS_DECAL                |   \
                                    D3DPTBLENDCAPS_MODULATE             |   \
                                    D3DPTBLENDCAPS_DECALALPHA           |   \
                                    D3DPTBLENDCAPS_MODULATEALPHA        |   \
                                    D3DPTBLENDCAPS_DECALMASK            |   \
                                    D3DPTBLENDCAPS_MODULATEMASK         |   \
                                    D3DPTBLENDCAPS_COPY                 |   \
                                    D3DPTBLENDCAPS_ADD

/*
 * Texture addressing capabilities (dwTextureAddressCaps)
 */
#define NV4_LINECAPS_TEXTUREADDRESS D3DPTADDRESSCAPS_WRAP               |   \
                                    D3DPTADDRESSCAPS_MIRROR             |   \
                                    D3DPTADDRESSCAPS_CLAMP              |   \
                                    D3DPTADDRESSCAPS_INDEPENDENTUV

/*
 * Maximum stipple dimensions.
 */
#define NV4_LINECAPS_STIPPLEWIDTH    0
#define NV4_LINECAPS_STIPPLEHEIGHT   0

/*
 * Define the triangle capabilities.
 *
 * Miscellaneous capabilities (dwMiscCaps)
 */
#define NV4_TRICAPS_MISC            D3DPMISCCAPS_MASKZ                  |   \
                                    D3DPMISCCAPS_CULLNONE               |   \
                                    D3DPMISCCAPS_CULLCW                 |   \
                                    D3DPMISCCAPS_CULLCCW

/*
 * Raster capabilities (dwRasterCaps)
 */
#define NV4_TRICAPS_RASTER          D3DPRASTERCAPS_DITHER               |   \
                                    D3DPRASTERCAPS_SUBPIXEL             |   \
                                    D3DPRASTERCAPS_FOGVERTEX            |   \
                                    D3DPRASTERCAPS_FOGTABLE             |   \
                                    D3DPRASTERCAPS_MIPMAPLODBIAS        |   \
                                    D3DPRASTERCAPS_FOGRANGE             |   \
                                    D3DPRASTERCAPS_WBUFFER              |   \
                                    D3DPRASTERCAPS_WFOG                 |   \
                                    D3DPRASTERCAPS_ZFOG
//                                  D3DPRASTERCAPS_ANISOTROPY           |   \

/*
 * Z Compare capabilities (dwZCmpCaps)
 */
#define NV4_TRICAPS_ZCMP            D3DPCMPCAPS_NEVER                   |   \
                                    D3DPCMPCAPS_LESS                    |   \
                                    D3DPCMPCAPS_EQUAL                   |   \
                                    D3DPCMPCAPS_LESSEQUAL               |   \
                                    D3DPCMPCAPS_GREATER                 |   \
                                    D3DPCMPCAPS_NOTEQUAL                |   \
                                    D3DPCMPCAPS_GREATEREQUAL            |   \
                                    D3DPCMPCAPS_ALWAYS

/*
 * Source blend capabilities (dwSrcBlendCaps)
 */
#define NV4_TRICAPS_SRCBLEND        D3DPBLENDCAPS_ZERO                  |   \
                                    D3DPBLENDCAPS_ONE                   |   \
                                    D3DPBLENDCAPS_SRCCOLOR              |   \
                                    D3DPBLENDCAPS_INVSRCCOLOR           |   \
                                    D3DPBLENDCAPS_SRCALPHA              |   \
                                    D3DPBLENDCAPS_INVSRCALPHA           |   \
                                    D3DPBLENDCAPS_DESTALPHA             |   \
                                    D3DPBLENDCAPS_INVDESTALPHA          |   \
                                    D3DPBLENDCAPS_DESTCOLOR             |   \
                                    D3DPBLENDCAPS_INVDESTCOLOR          |   \
                                    D3DPBLENDCAPS_SRCALPHASAT           |   \
                                    D3DPBLENDCAPS_BOTHSRCALPHA          |   \
                                    D3DPBLENDCAPS_BOTHINVSRCALPHA

/*
 * Destination blend capabilities (dwDestBlendCaps)
 */
#define NV4_TRICAPS_DESTBLEND       D3DPBLENDCAPS_ZERO                  |   \
                                    D3DPBLENDCAPS_ONE                   |   \
                                    D3DPBLENDCAPS_SRCCOLOR              |   \
                                    D3DPBLENDCAPS_INVSRCCOLOR           |   \
                                    D3DPBLENDCAPS_SRCALPHA              |   \
                                    D3DPBLENDCAPS_INVSRCALPHA           |   \
                                    D3DPBLENDCAPS_DESTALPHA             |   \
                                    D3DPBLENDCAPS_INVDESTALPHA          |   \
                                    D3DPBLENDCAPS_DESTCOLOR             |   \
                                    D3DPBLENDCAPS_INVDESTCOLOR          |   \
                                    D3DPBLENDCAPS_SRCALPHASAT           |   \
                                    D3DPBLENDCAPS_BOTHSRCALPHA          |   \
                                    D3DPBLENDCAPS_BOTHINVSRCALPHA

/*
 * Alpha compare capabilities (dwAlphaCmpCaps)
 */
#define NV4_TRICAPS_ALPHACMP        D3DPCMPCAPS_NEVER                   |   \
                                    D3DPCMPCAPS_LESS                    |   \
                                    D3DPCMPCAPS_EQUAL                   |   \
                                    D3DPCMPCAPS_LESSEQUAL               |   \
                                    D3DPCMPCAPS_GREATER                 |   \
                                    D3DPCMPCAPS_NOTEQUAL                |   \
                                    D3DPCMPCAPS_GREATEREQUAL            |   \
                                    D3DPCMPCAPS_ALWAYS

/*
 * Shading capabilities (dwShadeCaps)
 */
#define NV4_TRICAPS_SHADE           D3DPSHADECAPS_COLORFLATMONO         |   \
                                    D3DPSHADECAPS_COLORFLATRGB          |   \
                                    D3DPSHADECAPS_COLORGOURAUDMONO      |   \
                                    D3DPSHADECAPS_COLORGOURAUDRGB       |   \
                                    D3DPSHADECAPS_SPECULARFLATRGB       |   \
                                    D3DPSHADECAPS_SPECULARGOURAUDRGB    |   \
                                    D3DPSHADECAPS_ALPHAFLATBLEND        |   \
                                    D3DPSHADECAPS_ALPHAGOURAUDBLEND     |   \
                                    D3DPSHADECAPS_FOGFLAT               |   \
                                    D3DPSHADECAPS_FOGGOURAUD

/*
 * Texture capabilities (dwTextureCaps)
 */
#define NV4_TRICAPS_TEXTURE         D3DPTEXTURECAPS_PERSPECTIVE         |   \
                                    D3DPTEXTURECAPS_POW2                |   \
                                    D3DPTEXTURECAPS_ALPHA               |   \
                                    D3DPTEXTURECAPS_TRANSPARENCY        |   \
                                    D3DPTEXTURECAPS_TEXREPEATNOTSCALEDBYSIZE

/*
 * Texture filtering capabilities (dwTextureFilterCaps)
 */
#define NV4_TRICAPS_TEXTUREFILTER   D3DPTFILTERCAPS_NEAREST             |   \
                                    D3DPTFILTERCAPS_LINEAR              |   \
                                    D3DPTFILTERCAPS_MIPNEAREST          |   \
                                    D3DPTFILTERCAPS_MIPLINEAR           |   \
                                    D3DPTFILTERCAPS_LINEARMIPNEAREST    |   \
                                    D3DPTFILTERCAPS_LINEARMIPLINEAR     |   \
                                    D3DPTFILTERCAPS_MINFPOINT           |   \
                                    D3DPTFILTERCAPS_MINFLINEAR          |   \
                                    D3DPTFILTERCAPS_MIPFPOINT           |   \
                                    D3DPTFILTERCAPS_MIPFLINEAR          |   \
                                    D3DPTFILTERCAPS_MAGFPOINT           |   \
                                    D3DPTFILTERCAPS_MAGFLINEAR            
                                    //D3DPTFILTERCAPS_MINFANISOTROPIC   
                                    //D3DPTFILTERCAPS_MAGFANISOTROPIC

/*
 * Texture blending capabilities (dwTextureBlendCaps)
 */
#define NV4_TRICAPS_TEXTUREBLEND    D3DPTBLENDCAPS_DECAL                |   \
                                    D3DPTBLENDCAPS_MODULATE             |   \
                                    D3DPTBLENDCAPS_DECALALPHA           |   \
                                    D3DPTBLENDCAPS_MODULATEALPHA        |   \
                                    D3DPTBLENDCAPS_DECALMASK            |   \
                                    D3DPTBLENDCAPS_MODULATEMASK         |   \
                                    D3DPTBLENDCAPS_COPY                 |   \
                                    D3DPTBLENDCAPS_ADD

/*
 * Texture addressing capabilities (dwTextureAddressCaps)
 */
#define NV4_TRICAPS_TEXTUREADDRESS  D3DPTADDRESSCAPS_WRAP               |   \
                                    D3DPTADDRESSCAPS_MIRROR             |   \
                                    D3DPTADDRESSCAPS_CLAMP              |   \
                                    D3DPTADDRESSCAPS_INDEPENDENTUV

/*
 * Maximum stipple dimensions.
 */
#define NV4_TRICAPS_STIPPLEWIDTH    0
#define NV4_TRICAPS_STIPPLEHEIGHT   0

/*
 * Texture Ops
 */
#define NV4_CAPS_TEXTUREOPS   D3DTEXOPCAPS_DISABLE                      |   \
                              D3DTEXOPCAPS_SELECTARG1                   |   \
                              D3DTEXOPCAPS_SELECTARG2                   |   \
                              D3DTEXOPCAPS_MODULATE                     |   \
                              D3DTEXOPCAPS_MODULATE2X                   |   \
                              D3DTEXOPCAPS_MODULATE4X                   |   \
                              D3DTEXOPCAPS_ADD                          |   \
                              D3DTEXOPCAPS_ADDSIGNED                    |   \
                              D3DTEXOPCAPS_ADDSIGNED2X                  |   \
                              D3DTEXOPCAPS_ADDSMOOTH                    |   \
                              D3DTEXOPCAPS_SUBTRACT                     |   \
                              D3DTEXOPCAPS_BLENDDIFFUSEALPHA            |   \
                              D3DTEXOPCAPS_BLENDTEXTUREALPHA            |   \
                              D3DTEXOPCAPS_BLENDFACTORALPHA             |   \
                              D3DTEXOPCAPS_BLENDTEXTUREALPHAPM          |   \
                              D3DTEXOPCAPS_BLENDCURRENTALPHA            |   \
                              D3DTEXOPCAPS_PREMODULATE                  |   \
                              D3DTEXOPCAPS_MODULATEALPHA_ADDCOLOR       |   \
                              D3DTEXOPCAPS_MODULATECOLOR_ADDALPHA       |   \
                              D3DTEXOPCAPS_MODULATEINVALPHA_ADDCOLOR    |   \
                              D3DTEXOPCAPS_MODULATEINVCOLOR_ADDALPHA

/*
 * Stencil Ops
 */
#define NV4_CAPS_STENCILOPS   D3DSTENCILCAPS_KEEP                       |   \
                              D3DSTENCILCAPS_ZERO                       |   \
                              D3DSTENCILCAPS_REPLACE                    |   \
                              D3DSTENCILCAPS_INCRSAT                    |   \
                              D3DSTENCILCAPS_DECRSAT                    |   \
                              D3DSTENCILCAPS_INVERT                     |   \
                              D3DSTENCILCAPS_INCR                       |   \
                              D3DSTENCILCAPS_DECR

/*
 * Vertex Processing Caps
 */
#define NV4_CAPS_VTXPCAPS     0

/*
 * Define the render bit depth capabilites.
 */
#define NV4_RENDERBITDEPTHCAPS      (DDBD_16 | DDBD_32)

/*
 * Define the Z buffer bit depth capabilities.
 */
#define NV4_ZBUFFERBITDEPTHCAPS     (DDBD_16 | DDBD_24)

/*
 * Define the maximum execute buffer size capabilites.
 */
#define NV4_MAXBUFFERSIZE           0

/*
 * Define the maximum vertex count
 */
#define NV4_MAXVERTEXCOUNT          NVD3D_DEFAULT_TL_NUM

#define NV4_CAPS_MAX_TEXTURE_REPEAT                  0 // nv4's max tex coord is actually ~2^19, independent of texture
                                                       // size and geometry size, but apparently MS doesn't look at this
                                                       // value if D3DPTEXTURECAPS_TEXREPEATNOTSCALEDBYSIZE is set
#define NV4_CAPS_MAX_TEXTURE_ASPECT_RATIO            0
#define NV4_CAPS_MAX_ANISOTROPY                      0 // Means we support anisotropic filtering.
//#define NV4_CAPS_MAX_ANISOTROPY                      2 // Means we support anisotropic filtering.

#define NV4_CAPS_GUARD_BAND_LEFT                     -2048
#define NV4_CAPS_GUARD_BAND_TOP                      -2048
#define NV4_CAPS_GUARD_BAND_RIGHT                    2047
#define NV4_CAPS_GUARD_BAND_BOTTOM                   2047

#define NV4_CAPS_EXTENTS_ADJUST                      0
#define NV4_CAPS_MAX_UV_PAIRS                        8 // Number of texture uv's supported.
#define NV4_CAPS_FVF_CAPS                            (NV4_CAPS_MAX_UV_PAIRS | D3DFVFCAPS_DONOTSTRIPELEMENTS)
#define NV4_CAPS_MAX_TEXTURE_BLEND_STATES            4
#define NV4_CAPS_MAX_SIMULTANEOUS_TEXTURES           2

// DX7 stuff
#define NV4_CAPS_MAX_ACTIVE_LIGHTS                   0
#define NV4_CAPS_MAX_USER_CLIP_PLANES                0
#define NV4_CAPS_MAX_VERTEX_BLEND_MATRICES           0

#endif  // _NV4DCAPS_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\ddraw\common\inc\MINIVDD.H ===
//*****************************************************************************
//
//   (C) Copyright MICROSOFT Corp., 1988-1993
//
//   Title:      minivdd.inc - VDD definitions for other VxD's and multiple VDD's
//
//   Version:    4.00
//
//   Date:
//
//   Author: FredE for the Mini-VDD interface.  Adapted from VDD.INC in
//           the general include area.  Added services are ONLY for the
//           use of the Mini-VDD and should therefore not be documented.
//
//-----------------------------------------------------------------------------
//=============================================================================

#ifndef _MINIVDD_H_
#define _MINIVDD_H_

#ifdef __cplusplus
extern "C" {
#endif

#ifndef Not_VxD

/*XLATOFF*/
#define VDD_Service Declare_Service
#pragma warning (disable:4003)      // turn off not enough params warning
/*XLATON*/

#ifdef MINIVDD
#ifdef NEC_98
/*MACROS*/
//
// VDD protect mode services for other devices and VMM (Get_Version must be first).
// Only define these if we're assembling either the "main" VDD or one of the
// mini-VDD's.  Don't define this if we're assembling a display driver or other
// caller of the MiniVDD stuff:
//
Begin_Service_Table(VDD)
VDD_Service(     VDD_Get_Version            ) // Get version number and ID string ptr
VDD_Service(     VDD_PIF_State              ) // Pass video PIF bits to VDD
VDD_Service(     VDD_Get_GrabRtn            ) // Get routine addr for video grab
VDD_Service(     VDD_Hide_Cursor            ) // Hide cursor when display is windowed
VDD_Service(     VDD_Set_VMType             ) // Set VM type(windowed, bckgrnd, excl)
VDD_Service(     VDD_Get_ModTime            ) // Return system time of last mod
VDD_Service(     VDD_Set_HCurTrk            ) // Track horiz cursor movement in window
VDD_Service(     VDD_Msg_ClrScrn            ) // Clear screen for sysmodal message
VDD_Service(     VDD_Msg_ForColor           ) // Set Msg_TextOut forground color
VDD_Service(     VDD_Msg_BakColor           ) // Set Msg_TextOut background color
VDD_Service(     VDD_Msg_TextOut            ) // Output a string
VDD_Service(     VDD_Msg_SetCursPos         ) // Set cursor position
VDD_Service(     VDD_Query_Access           ) // Is it OK to access video now?
VDD_Service(     VDD_Check_Update_Soon      ) // User action may update screen
VDD_Service(     VDD_Get_Mini_Dispatch_Table) // Get addr of dispatch table to mini-VDD
VDD_Service(     VDD_Register_Virtual_Port  ) // Mini-VDD asks us to setup I/O trap
VDD_Service(     VDD_Get_VM_Info            ) // Returns CRTC owner and MemC owners
                                              // and other special VM handles
VDD_Service(     VDD_Get_Special_VM_IDs     ) // returns planar & msg mode IDs
VDD_Service(     VDD_Register_Extra_Screen_Selector )
                                              // allows display driver to use second
                                              // screen selector for block moves
VDD_Service(     VDD_Takeover_VGA_Port      ) // allows MiniVDD to takeover a port
                                              // in range 3C0H through 3DFH
VDD_Service(     VDD_Get_DISPLAYINFO        ) // get DISPLAYINFO data structure
VDD_Service(     VDD_Do_Physical_IO         ) // perform physical I/O for trapped port
VDD_Service(     VDD_Register_Mini_VDD   )
VDD_Service(    VDD_Install_IO_Handler   )
VDD_Service(    VDD_Install_Mult_IO_Handlers    )
VDD_Service(    VDD_Enable_Local_Trapping       )
VDD_Service(    VDD_Disable_Local_Trapping      )
VDD_Service(    VDD_Trap_Suspend        )
VDD_Service(    Test_Vid_VM_Handle      )
VDD_Service(    VDD_Set_Core_Graphics   )
VDD_Service(    VDD_Load_AccBIOS        )
VDD_Service(    VDD_Map_AccBIOS         )
VDD_Service(    VDD_Map_VRAM            )
End_Service_Table(VDD)
/*ENDMACROS*/
#else  /*NEC_98*/
/*MACROS*/
//
// VDD protect mode services for other devices and VMM (Get_Version must be first).
// Only define these if we're assembling either the "main" VDD or one of the
// mini-VDD's.  Don't define this if we're assembling a display driver or other
// caller of the MiniVDD stuff:
//
Begin_Service_Table(VDD)
VDD_Service(     VDD_Get_Version             )// Get version number and ID string ptr
VDD_Service(     VDD_PIF_State               )// Pass video PIF bits to VDD
VDD_Service(     VDD_Get_GrabRtn             )// Get routine addr for video grab
VDD_Service(     VDD_Hide_Cursor             )// Hide cursor when display is windowed
VDD_Service(     VDD_Set_VMType              )// Set VM type(windowed, bckgrnd, excl)
VDD_Service(     VDD_Get_ModTime             )// Return system time of last mod
VDD_Service(     VDD_Set_HCurTrk             )// Track horiz cursor movement in window
VDD_Service(     VDD_Msg_ClrScrn             )// Clear screen for sysmodal message
VDD_Service(     VDD_Msg_ForColor            )// Set Msg_TextOut forground color
VDD_Service(     VDD_Msg_BakColor            )// Set Msg_TextOut background color
VDD_Service(     VDD_Msg_TextOut             )// Output a string
VDD_Service(     VDD_Msg_SetCursPos          )// Set cursor position
VDD_Service(     VDD_Query_Access            )// Is it OK to access video now?
VDD_Service(     VDD_Check_Update_Soon       )// User action may update screen
VDD_Service(     VDD_Get_Mini_Dispatch_Table )// Get addr of dispatch table to mini-VDD
VDD_Service(     VDD_Register_Virtual_Port   )// Mini-VDD asks us to setup I/O trap
VDD_Service(     VDD_Get_VM_Info             )// Returns CRTC owner and MemC owners
                                              // and other special VM handles
VDD_Service(     VDD_Get_Special_VM_IDs      )// returns planar & msg mode IDs
VDD_Service(     VDD_Register_Extra_Screen_Selector )
                                              // allows display driver to use second
                                              // screen selector for block moves
VDD_Service(     VDD_Takeover_VGA_Port   )    // allows MiniVDD to takeover a port
                                              // in range 3C0H through 3DFH
VDD_Service(     VDD_Get_DISPLAYINFO     )    // get DISPLAYINFO data structure
VDD_Service(     VDD_Do_Physical_IO      )    // perform physical I/O for trapped port
VDD_Service(     VDD_Set_Sleep_Flag_Addr )    // when display driver can't be interrupted
End_Service_Table(VDD)                   
/*ENDMACROS*/
#endif  /*NEC_98*/
#endif  /*MINIVDD*/

/*XLATOFF*/
#pragma warning (default:4003)              // turn off not enough params warning
/*XLATON*/

#define VDD_VerNum      0x0400  // version 4.00
#define VDD_MinVerNum   0x030A  // supports down to 3.10

//***************
// PIF_State service definitions
//
// These definitions cannot change without changing the PIF editor!!!
//
#ifdef NEC_98
#define bVidTextMd	 4	; Allocate text mode mem
#define fVidTextMd	 (1 << 4)
#define bVidNTModeFF	 0	; NoTrap: Mode F/F
#define fVidNTModeFF	 (1 << 0)
#define bVidNTModeFFC16	 1	; Default is 16 color mode
#define fVidNTModeFFC16	 (1 << 1)
#define bVidNTDispRW	 2	; NoTrap: Bank Register
#define fVidNTDispRW	 (1 << 2)
#define bVidNTPal	 3	; NoTrap: Palette
#define fVidNTPal	 (1 << 3)
#define bVidNTGDC	 5	; NoTrap: GDC
#define fVidNTGDC	 (1 << 5)
#define bVidNTGDCTON	 6	; Default Text on
#define fVidNTGDCTON	 (1 << 6)
#define bVidNTGDCGON	 7	; Default Grph on
#define fVidNTGDCGON	 (1 << 7)
#define bVidNTFont	 8	; NoTrap: KCG
#define fVidNTFont	 (1 << 8)
#define bVidCRTC	 9	; Use CRTC Tracer
#define fVidCRTC	 (1 << 9)
#define bVidDispDataXfer 10	; Transrate mode (0:Text, 1:Text/Grph)
#define fVidDispDataXfer (1 << 10)
#define bVidXFERPlane0	 11	; Transrate plane Blue
#define fVidXFERPlane0	 (1 << 11)
#define bVidXFERPlane1	 12	; 		  Red
#define fVidXFERPlane1	 (1 << 12)
#define bVidXFERPlane2	 13	; 		  Green
#define fVidXFERPlane2	 (1 << 13)
#define bVidXFERPlane3	 14	; 		  Intensity
#define fVidXFERPlane3	 (1 << 14)

#define mVidXFERPlane	(fVidXFERPlane0+fVidXFERPlane1+fVidXFERPlane2+fVidXFERPlane3)
#define mVidNTH98	(fVidNTModeFF+fVidNTModeFFC16+fVidNTDispRW+fVidNTPal+fVidNTGDC+fVidNTGDCTON+fVidNTGDCGON)
#else //NEC_98
#define fVidTxtEmulate  0x0001  // Do INT 10h TTY and cursor emulation
#define fVidNoTrpTxt    0x0002  // Do not trap text mode apps
#define fVidNoTrpLRGrfx 0x0004  // Do not trap lo res graphics mode apps
#define fVidNoTrpHRGrfx 0x0008  // Do not trap hi res graphics mode apps
#define fVidTextMd      0x0010  // Allocate text mode mem
#define fVidLowRsGrfxMd 0x0020  // Allocate lo res graphics mode mem
#define fVidHghRsGrfxMd 0x0040  // Allocate hi res graphics mode mem
#define fVidRetainAllo  0x0080  // Never deallocate once allocated
#endif //NEC_98

//
// The following stuff was added for mini-VDD support:
//
// Functions that we can call in the hardware-dependent mini-VDD.  Note that
// these equates are used to create the dispatch table for calling functions
// in the mini-VDD:
//
#ifdef NEC_98
#define REGISTER_DISPLAY_DRIVER 	     0
#define PRE_HIRES_TO_VGA		     1
#define SAVE_REGISTERS			     2
#define RESTORE_REGISTERS		     3
#define ENABLE_TRAPS			     4
#define DISABLE_TRAPS			     5
#define DISPLAY_DRIVER_DISABLING	     6
#define ENABLE_ACCELERATER		     7
#define DISABLE_ACCELERATER		     8
#define CHECK_UPDATE			     9
#define CHECK_WINDOWED			     10
#define ACC_VBE_PM			     11
#define ACC_VBE_DDC			     12
#define ACC_INT_10			     13
#define ACC_GET_CAPABILITIES		     14
#define ACC_GET_EXT_MODE_INFO		     15
#define ACC_GET_FLAT_SELECTOR		     16
#define ACC_ENABLE_BIOS			     17
#define ACC_DISABLE_BIOS		     18
#define ACC_SET_PALETTE			     19
#define ACC_GET_PALETTE			     20
#define ACC_SET_CURSOR			     21
#define ACC_SHOW_CURSOR			     22
#define ACC_HIDE_CURSOR			     23
#define ACC_SET_CURSOR_POS		     24
#define ACC_GET_CURSOR_POS		     25
;
#define NBR_MINI_VDD_FUNCTIONS               26      //REMEMBER TO RESET THIS!!!!!!
#else //NEC_98
#define REGISTER_DISPLAY_DRIVER              0
#define GET_VDD_BANK                         1
#define SET_VDD_BANK                         2
#define RESET_BANK                           3
#define PRE_HIRES_TO_VGA                     4
#define POST_HIRES_TO_VGA                    5
#define PRE_VGA_TO_HIRES                     6
#define POST_VGA_TO_HIRES                    7
#define SAVE_REGISTERS                       8
#define RESTORE_REGISTERS                    9
#define MODIFY_REGISTER_STATE                10
#define ACCESS_VGA_MEMORY_MODE               11
#define ACCESS_LINEAR_MEMORY_MODE            12
#define ENABLE_TRAPS                         13
#define DISABLE_TRAPS                        14
#define MAKE_HARDWARE_NOT_BUSY               15
#define VIRTUALIZE_CRTC_IN                   16
#define VIRTUALIZE_CRTC_OUT                  17
#define VIRTUALIZE_SEQUENCER_IN              18
#define VIRTUALIZE_SEQUENCER_OUT             19
#define VIRTUALIZE_GCR_IN                    20
#define VIRTUALIZE_GCR_OUT                   21
#define SET_LATCH_BANK                       22
#define RESET_LATCH_BANK                     23
#define SAVE_LATCHES                         24
#define RESTORE_LATCHES                      25
#define DISPLAY_DRIVER_DISABLING             26
#define SELECT_PLANE                         27
#define PRE_CRTC_MODE_CHANGE                 28
#define POST_CRTC_MODE_CHANGE                29
#define VIRTUALIZE_DAC_OUT                   30
#define VIRTUALIZE_DAC_IN                    31
#define GET_CURRENT_BANK_WRITE               32
#define GET_CURRENT_BANK_READ                33
#define SET_BANK                             34
#define CHECK_HIRES_MODE                     35
#define GET_TOTAL_VRAM_SIZE                  36
#define GET_BANK_SIZE                        37
#define SET_HIRES_MODE                       38
#define PRE_HIRES_SAVE_RESTORE               39
#define POST_HIRES_SAVE_RESTORE              40
#define VESA_SUPPORT                         41
#define GET_CHIP_ID                          42
#define CHECK_SCREEN_SWITCH_OK               43
#define VIRTUALIZE_BLTER_IO                  44
#define SAVE_MESSAGE_MODE_STATE              45
#define SAVE_FORCED_PLANAR_STATE             46
#define VESA_CALL_POST_PROCESSING            47
#define PRE_INT_10_MODE_SET                  48
#define NBR_MINI_VDD_FUNCTIONS_40            49      //REMEMBER TO RESET THIS!!!!!!

//
//  new miniVDD functions that a 4.1 miniVDD should implement
//
#define GET_NUM_UNITS                        49
#define TURN_VGA_OFF                         50
#define TURN_VGA_ON                          51
#define SET_ADAPTER_POWER_STATE              52
#define GET_ADAPTER_POWER_STATE_CAPS         53
#define SET_MONITOR_POWER_STATE              54
#define GET_MONITOR_POWER_STATE_CAPS         55
#define NBR_MINI_VDD_FUNCTIONS_41            56

#ifdef MAINVDD
#define NBR_MINI_VDD_FUNCTIONS  NBR_MINI_VDD_FUNCTIONS_41
#else
#define NBR_MINI_VDD_FUNCTIONS  NBR_MINI_VDD_FUNCTIONS_40
#endif

#endif //NEC_98

#endif /*NotVxD*/

//
// Following are function codes that can be called via the VDD's
// API entry point. These are mainly for display driver --> VDD communication.
// Since Windows 3.0 and 3.1 VDD's may have used the sequential numbers
// (after the Grabber functions) for other VDD API services, we start our
// numbering at 80H so as to avoid ugly conflicts with old 3.1 stuff:
//
// all these entry points take as input:
//
// Entry:
//      Client_EAX  - function code.
//      Client_EBX  - device handle, or device id (1-N)
//
#define VDD_QUERY_VERSION                   0
#define MINIVDD_SVC_BASE_OFFSET             0x80
#define VDD_DRIVER_REGISTER                 (0  + MINIVDD_SVC_BASE_OFFSET)
#define VDD_DRIVER_UNREGISTER               (1  + MINIVDD_SVC_BASE_OFFSET)
#define VDD_SAVE_DRIVER_STATE               (2  + MINIVDD_SVC_BASE_OFFSET)
#define VDD_REGISTER_DISPLAY_DRIVER_INFO    (3  + MINIVDD_SVC_BASE_OFFSET)
#define VDD_REGISTER_SSB_FLAGS              (4  + MINIVDD_SVC_BASE_OFFSET)
#define VDD_GET_DISPLAY_CONFIG              (5  + MINIVDD_SVC_BASE_OFFSET)
#define VDD_PRE_MODE_CHANGE                 (6  + MINIVDD_SVC_BASE_OFFSET)
#define VDD_POST_MODE_CHANGE                (7  + MINIVDD_SVC_BASE_OFFSET)
#define VDD_SET_USER_FLAGS                  (8  + MINIVDD_SVC_BASE_OFFSET)
#define VDD_SET_BUSY_FLAG_ADDR              (9  + MINIVDD_SVC_BASE_OFFSET)
#define VDD_PC98_RESERVED                   (10 + MINIVDD_SVC_BASE_OFFSET)
#define VDD_VBE_PM                          (10 + MINIVDD_SVC_BASE_OFFSET)
//
//   all functions >= VDD_ENABLE also take the following params:
//
//      Client_ES:DI    - buffer
//      Client_ECX      - buffer size
//      Client_EDX      - flags
//
// Exit:
//      Client_EAX  = function code  if the function is not supported.
//                  = 0              if the function succeded.
//                  = -1             if the function failed.
//
#define VDD_ENABLE                          (11 + MINIVDD_SVC_BASE_OFFSET)
#define VDD_GETMEMBASE                      (12 + MINIVDD_SVC_BASE_OFFSET)
#define VDD_OPEN                            (13 + MINIVDD_SVC_BASE_OFFSET)
#define VDD_CLOSE                           (14 + MINIVDD_SVC_BASE_OFFSET)
#define VDD_OPEN_KEY                        (15 + MINIVDD_SVC_BASE_OFFSET)
#define VDD_SET_POWER_STATE                 (16 + MINIVDD_SVC_BASE_OFFSET)
#define VDD_ENUM                            (17 + MINIVDD_SVC_BASE_OFFSET)

//
// special verion of VDD_GET_DISPLAY_CONFIG that always get the
// monitor data, even if the user has disabled using a refresh rate.
//
#define VDD_GET_DISPLAY_CONFIG2             0x8085

//
//  VDD_DRIVER_REGISTER
//
//  The display driver sends us some information needed to handle various
//  context changes.
//
//  Entry:
//         Client_ES:DI Selector:Offset of callback routine used
//                      to reset to Windows HiRes mode upon return
//                      from a full screen DOS VM to the Windows VM.
//         Client_ES    Main code segment of display driver.
//         Client_ECX   contains the total nbr of bytes on-screen (excluding
//                      off-screen memory).
//         Client_EDX   contain 0 if we are to attempt to allow 4 plane VGA
//                      virtualization.
//         Client_EDX   contains -1 if we are to not allow 4 plane VGA
//                      virtualization.
//         Client_EBX   device handle, or device id (1-N)
//  Exit:
//         Client_EAX   contains total bytes of memory used by visible screen
//                      AND the VDD virtualization area (ie: the start of
//                      off-screen memory available for use by the display
//                      driver as "scratch" memory).
//

//
//  VDD_DRIVER_UNREGISTER
//
//  Entry:
//          Client_EBX   device handle, or device id (1-N)
//  Exit:
//

//
//  VDD_ENABLE
//
//  entry:
//      Client_EAX      - VDD_ENABLE (0x008B)
//      Client_EBX      - device handle, or device id (1-N)
//      Client_EDX      - enable flags (see below)
//
//  exit:
//      Client_EAX      - previous enable state.
//
//  only one device at a time can have VGAMEM, VGAIO, or ROM access
//  at a time.
//
#define ENABLE_IO               0x00000001  // enable IO.
#define ENABLE_MEM              0x00000002  // enable memory.
#define ENABLE_VGA              0x00000030  // enable VGA
#define ENABLE_ROM              0x00000080  // enable ROM at C000.
#define ENABLE_ALL              0x000000FF  // enable all access to this device
#define ENABLE_NONE             0x00000000  // disable device.
#define ENABLE_VALID            0x000000FF  // valid flags.
#define ENABLE_ERROR            0xFFFFFFFF  // enable fail code

//
//  VDD_OPEN
//
//      open a device given a name
//
//  Entry:
//          Client_ES:EDI   - device name
//          Client_EDX      - flag
//  Exit:
//          Client_EAX      - device handle
//
#define VDD_OPEN_TEST       0x00000001


//
//  WIN32 IOCTLS
//
//  The following defines are used with the Win32 function DeviceIOControl
//
#define VDD_IOCTL_SET_NOTIFY    0x10000001  // set mode change notify
#define VDD_IOCTL_GET_DDHAL     0x10000002  // get DDHAL functions from miniVDD

//
//  VDD_IOCTL_SET_NOTIFY
//
//  sets a notification function that will be called when events
//  happen on the device.
//
//  input:
//          NotifyMask      - bitfield of events
//          NotifyType      - type of notify
//          NotifyProc      - notify procedure
//          NotifyData      - client data
//
//  output:
//           none
//
//  return:
//          ERROR_SUCCES
//
typedef struct tagVDD_IOCTL_SET_NOTIFY_INPUT {
    DWORD   NotifyMask;
    DWORD   NotifyType;
    DWORD   NotifyProc;
    DWORD   NotifyData;
}   VDD_IOCTL_SET_NOTIFY_INPUT;


//
// NotifyMask
//
#define VDD_NOTIFY_START_MODE_CHANGE    0x00000001
#define VDD_NOTIFY_END_MODE_CHANGE      0x00000002
#define VDD_NOTIFY_ENABLE               0x00000004
#define VDD_NOTIFY_DISABLE              0x00000008

//
//  NotifyType
//
#define VDD_NOTIFY_TYPE_CALLBACK        1


//
// Port size equates:
//
#define BYTE_LENGTHED                       1
#define WORD_LENGTHED                       2

//
// Flag equates:
//
#define GOING_TO_WINDOWS_MODE               1
#define GOING_TO_VGA_MODE                   2
#define DISPLAY_DRIVER_DISABLED             4
#define IN_WINDOWS_HIRES_MODE               8

//
//  DISPLAYINFO structure
//
typedef struct DISPLAYINFO {
        WORD  diHdrSize;
        WORD  diInfoFlags;
        //
        //  display mode specific data
        //
        DWORD diDevNodeHandle;
        char  diDriverName[16];
        WORD  diXRes;
        WORD  diYRes;
        WORD  diDPI;
        BYTE  diPlanes;
        BYTE  diBpp;
        //
        //  monitor specific data
        //
        WORD  diRefreshRateMax;
        WORD  diRefreshRateMin;
        WORD  diLowHorz;
        WORD  diHighHorz;
        WORD  diLowVert;
        WORD  diHighVert;
        DWORD diMonitorDevNodeHandle;
        BYTE  diHorzSyncPolarity;
        BYTE  diVertSyncPolarity;
        //
        // new 4.1 stuff
        //
        DWORD diUnitNumber;             // device unit number
        DWORD diDisplayFlags;           // mode specific flags
        DWORD diXDesktopPos;            // position of desktop
        DWORD diYDesktopPos;            // ...
        DWORD diXDesktopSize;           // size of desktop (for panning)
        DWORD diYDesktopSize;           // ...

} DISPLAYINFO;

/*ASM
DISPLAYINFO_SIZE    equ  diRefreshRateMax+2-diHdrSize
DISPLAYINFO_SIZE1   equ  diBpp+1-diHdrSize
DISPLAYINFO_SIZE2   equ  diVertSyncPolarity+1-diHdrSize
DISPLAYINFO_SIZE3   equ  diMemorySize+4-diHdrSize
*/

//
// Following are values for the diInfoFlags word in DISPLAYINFO:
//
#define RETURNED_DATA_IS_STALE           0x0001
#define MINIVDD_FAILED_TO_LOAD           0x0002
#define MINIVDD_CHIP_ID_DIDNT_MATCH      0x0004
#define REGISTRY_BPP_NOT_VALID           0x0008
#define REGISTRY_RESOLUTION_NOT_VALID    0x0010
#define REGISTRY_DPI_NOT_VALID           0x0020
#define MONITOR_DEVNODE_NOT_ACTIVE       0x0040
#define MONITOR_INFO_NOT_VALID           0x0080
#define MONITOR_INFO_DISABLED_BY_USER    0x0100
#define REFRESH_RATE_MAX_ONLY            0x0200
#define CARD_VDD_LOADED_OK               0x0400
#define DEVICE_IS_NOT_VGA                0x0800

//
//  Following are explanations for the diInfoFlags word in DISPLAYINFO:
//
//  RETURNED_DATA_IS_STALE, if set, means that this call to VDD_GET_DISPLAY_CONFIG
//  or VDD_GetDisplayInfo (which are the Ring 3 and Ring 0 methods by which a
//  program would get the DISPLAYINFO structure returned to him) caused the VDD
//  to return data that was read in a previous call to VDD_GET_DISPLAY_CONFIG
//  insted of actually going out and reading "fresh" data from the Registry.
//
//  This flag brings to light the fact that there are some circumstances when the
//  VDD cannot go out and read the registry in response to the call to
//  VDD_GET_DISPLAY_CONFIG or VDD_GetDisplayInfo (due to system multi-tasking
//  considerations).  In this case, this flag will be set to a 1 to indicate that
//  the information being returned isn't "fresh" -- that is -- it may be
//  incorrect and obsolete.  The caller should respond accordingly if this flag
//  is set.
//
//
//  MINIVDD_FAILED_TO_LOAD if set, indicates that for some reason (typically
//  that the MiniVDD didn't match the chipset installed in the machine), the
//  MiniVDD didn't load.  Callers can examine this flag and act accordingly.
//
//
//  MINIVDD_CHIP_ID_DIDNT_MATCH means that although the MiniVDD did load
//  successfully, when the ChipID that the MiniVDD calculated was compared
//  against the value saved in the registry, they didn't match.  An example of
//  when this would happen is when the user is happily using an S3-911 card
//  and then decides to upgrade his display card to an S3-864.  Since both
//  cards use S3.VXD, the MiniVDD will load, however, since the card model
//  is different, the VDD will return a defect to configuration manager and
//  set this flag.  Callers of the GET_DISPLAY_CONFIG functions can use this
//  flag to take appropriate actions to make sure that the user gets his
//  configuration correct.
//
//
//  REGISTRY_BPP_NOT_VALID if set, means that we failed to obtain the BPP value
//  from the registry when the VDD tried to read it.
//
//
//  REGISTRY_RESOLUTION_NOT_VALID if set, means that we failed to obtain the
//  resolution value from the registry when the VDD tried to read it.
//
//
//  REGISTRY_DPI_NOT_VALID if set, means that we failed to obtain the
//  DPI value from the registry when the VDD tried to read it.
//
//
//  MONITOR_DEVNODE_NOT_ACTIVE is set if someone tries to make a call to the
//  GET_DISPLAY_CONFIG function before the monitor DevNode has been created.
//  This is certainly not fatal by any means.  It simply means that the
//  monitor refresh rate info in the DISPLAYINFO data structure is totally
//  invalid!
//
//
//  MONITOR_INFO_NOT_VALID indicates that something within the code which
//  retrieves and calculates the refresh rate data has failed.  This indicates
//  that the values in diRefreshRateMax through diVertSyncPolarity are not
//  valid and could contain random data.
//
//
//  MONITOR_INFO_DISABLED_BY_USER indicates that the either the RefreshRate=
//  string in SYSTEM.INI had a negative number in it or that the string in
//  the display's software key RefreshRate = string was 0 or a negative number.
//
//
//  REFRESH_RATE_MAX_ONLY indicates that there was no diLowHorz, diHighHorz,
//  diLowVert, diHighVert, or sync polarity data in the registry.  The
//  value returned in diRefreshRateMax is the only refresh rate data that
//  we have available.  This was derived either from RefreshRate= in SYSTEM.INI
//  or the display software key RefreshRate = string in the registry.
//
//
//  CARD_VDD_LOADED_OK indicates that a second MiniVDD (which is useful for
//  display card manufacturers wishing to extend the capabilities of the chip level
//  MiniVDD's ) has successfully been loaded and initialized.
//
//  DEVICE_IS_NOT_VGA indicates that this device is not the primary vga
//

#define NoTrace_VIRTUALIZE_CRTC_IN
#define NoTrace_VIRTUALIZE_CRTC_OUT
#define NoTrace_VIRTUALIZE_SEQUENCER_IN
#define NoTrace_VIRTUALIZE_SEQUENCER_OUT
#define NoTrace_VIRTUALIZE_GCR_IN
#define NoTrace_VIRTUALIZE_GCR_OUT
#define NoTrace_VIRTUALIZE_DAC_OUT
#define NoTrace_VIRTUALIZE_DAC_IN
#define NoTrace_CHECK_HIRES_MODE
/*ASM

ifdef NEC_98
;******************************************************************************
;				 E Q U A T E S
;******************************************************************************

    ;
    ;	Mini-VDD Static Flags
    ;
vFlg_Machine_Std	equ			00000001b
vFlg_Machine_Multi	equ			00000010b
vFlg_Machine_Mate	equ			00000100b
vFlg_Machine_H98	equ			00001000b
vFlg_CRT_New		equ			00010000b
vFlg_CRT_NonInter	equ			00100000b
vFlg_GDC_5MHz		equ			01000000b
vFlg_GDC_Emulate	equ			10000000b
vFlg_Acc_Internal	equ		0000000100000000b
vFlg_Acc_External	equ		0000001000000000b
vFlg_Acc_PCI		equ		0000010000000000b
vFlg_Acc_ML		equ		0000100000000000b
vFlg_Acc_PVD		equ		0001000000000000b
vFlg_Mode_NH		equ		0010000000000000b
vFlg_Mode_H		equ		0100000000000000b
vFlg_Initialized	equ		1000000000000000b
vFlg_Opt_MFR		equ	000000010000000000000000b
vFlg_Opt_NewMFR		equ	000000100000000000000000b
vFlg_Opt_VDP		equ	000001000000000000000000b
vFlg_Opt_NewVDP		equ	000010000000000000000000b

vFlg_Local		equ	000000000100000010000000b

    ;
    ;	Mini-VDD Support Max
    ;
MaxMiniVDD	equ	16
MaxMiniTrap	equ	32
MaxMultiTrap	equ	3
MaxMultiFunc	equ	MaxMiniVDD

    ;
    ;	MiniVDD_LTrap_Struct.LTrap_Status
    ;	MiniVDD_LTrap_Struct.LTrap_Flags.xxxx
    ;
LT_Enable	equ	00000001b
LT_Enable_bit	equ	0
LT_Initialized	equ	10000000b
LT_Initialized_bit equ	7


;******************************************************************************
;			D A T A   S T R U C T U R E S
;******************************************************************************

    ;
    ;	Vids_struct
    ;

Vids_struct struc
   ;
   ;	Common Data supplied by Base-VDD. Some data(bits) set by Mini-VDD.
   ;
	Vids_SFlags		dd	?	; Static flags
	Vids_CB_Offset		dd	?	; 
	Vids_Msg_Pseudo_VM	dd	?	; 

   ;
   ;	Common Procedure supplied by Base-VDD
   ;
	VDD_TGDC_Draw_Off	dd	?	; 
	VDD_TGDC_Sync_Off	dd	?	; 
	VDD_TGDC_Sync_On	dd	?	; 
	VDD_TGDC_FIFO_Empty	dd	?	; 
	VDD_GGDC_Draw_Off	dd	?	; 
	VDD_GGDC_Sync_Off	dd	?	; 
	VDD_GGDC_Sync_On	dd	?	; 
	VDD_GGDC_FIFO_Empty	dd	?	; 
	VDD_GGDC_MOD_Emulate	dd	?	; 

   ;
   ;	Common Procedure supplied by Mini-VDD
   ;
	H98_FLORA_Change	dd	?	; H98 - NH mode
	H98_Clear_Text		dd	?	; H98 - NH mode
	H98_Rest_GCs		dd	?	; H98
	H98_Rest_etc		dd	?	; H98
	H98_Save_ModeFF		dd	?	; H98

Vids_struct ends


Vid_SFlags		equ	<Vids.Vids_SFlags>
VDD_CB_Offset		equ	<Vids.Vids_CB_Offset>
VDD_Msg_Pseudo_VM	equ	<Vids.Vids_Msg_Pseudo_VM>

TGDC_Draw_Off		equ	<Vids.VDD_TGDC_Draw_Off>
GGDC_Draw_Off		equ	<Vids.VDD_GGDC_Draw_Off>
TGDC_Sync_On		equ	<Vids.VDD_TGDC_Sync_On>
TGDC_Sync_Off		equ	<Vids.VDD_TGDC_Sync_Off>
TGDC_FIFO_Empty		equ	<Vids.VDD_TGDC_FIFO_Empty>
GGDC_FIFO_Empty		equ	<Vids.VDD_GGDC_FIFO_Empty>


    ;
    ;	RegTrapStruct
    ;
MiniFuncStruct	STRUC
MF_ProcAddr	dd	?
;;MF_Order	dw	?
;;MF_MiniID	db	?
;;MF_Flags	db	?
MiniFuncStruct	ENDS

    ;
    ;	MiniProcStruct
    ;
MiniVDD_Proc_Struct	STRUC
Proc_Address	dd	?
Proc_Order	dw	?
Proc_MiniID	db	?
Proc_Flags	db	?
MiniVDD_Proc_Struct	ENDS
.errnz	(size MiniVDD_Proc_Struct) mod 4

    ;
    ;	MiniTrapTable	- Global Info
    ;	LocalTrapTable	- Local Status
    ;
MiniVDD_GTrap_Struct	STRUC
GTrap_ProcAddr	dd	?
GTrap_PortAddr	dw	?
GTrap_NumMini	dw	?
GTrap_ProcTable	db	((size MiniVDD_Proc_Struct) * MaxMultiTrap) dup (?)
MiniVDD_GTrap_Struct	ENDS

MiniVDD_LTrap_Struct	STRUC
LTrap_ProcAddr	dd	?
LTrap_Status	db	?
LTrap_Flags	db	MaxMultiTrap dup (?)
MiniVDD_LTrap_Struct	ENDS


;******************************************************************************
;				M A C R O S
;******************************************************************************

    ;
    ;	BeginMiniFunc	TableName
    ;	    MiniFunc	Function-ID, ProcedureName
    ;		|	
    ;	EndMiniFunc	TableName
    ;
EndMiniFunc_	MACRO	n
ifdef	MiniFunc&n
	dd	OFFSET32 MiniFunc&n		; MiniFuncStruct
else
	dd	0
endif
		ENDM

MiniFunc_	MACRO	FuncID, FuncName
		MiniFunc&FuncID equ <FuncName>
		ENDM

BeginMiniFunc	MACRO	TableName
public	TableName
TableName	label	near
		ENDM

EndMiniFunc	MACRO	TableName
		x = 0
		REPT	NBR_MINI_VDD_FUNCTIONS
		EndMiniFunc_	%x
		x = x + 1
		ENDM
		ENDM

MiniFunc	MACRO	FuncID, FuncName
		MiniFunc_ %(FuncID), <FuncName>
		ENDM

    ;
    ;	MiniVDDCall	Function-ID
    ;
MiniVDDCall	MACRO	FuncID, SetCarry
		local	MiniCall_Loop
		local	MiniCall_Exit

		push	ecx
		push	esi
		lea	esi, [MiniVDD_Func_Table][(size MiniVDD_Proc_Struct) * MaxMultiFunc * FuncID]
		mov	ecx, [MiniVDD_NumMini]
MiniCall_Loop:
		cmp	dword ptr [esi.Proc_Address], 0
		jz	MiniCall_Exit
		pushad
ifnb <SetCarry>
		stc
endif
		call	dword ptr [esi.Proc_Address]
		popad
		jc	MiniCall_Exit
		add	esi, size MiniVDD_Proc_Struct
		loop	MiniCall_Loop
MiniCall_Exit:
		pop	esi
		pop	ecx
		ENDM

    ;
    ;	MiniVDDCall	Function-ID
    ;
MiniVDDFunc	MACRO	TmpReg, FuncID
		mov	TmpReg, [MiniVDD_Func_Table.Proc_Address][(size MiniVDD_Proc_Struct) * MaxMultiFunc * FuncID]
		ENDM

    ;
    ;	ExecMode/ExecModeThru
    ;	ExecModeNot/ExecModeThruNot
    ;	ExecModeOnly
    ;	ExecModeOnlyNot
    ;	ExecModeElse
    ;	ExecModeElseNot
    ;	ExecModeEnd
    ;

ExecModeLL	macro	Num
ExecMode_L&Num:
		endm

ExecModeLE	macro	Num
ExecMode_E&Num:
		endm

ExecModeJE	macro	Num
	jmp	ExecMode_E&Num
		endm

ExecModeJZ	macro	Num
	jz	ExecMode_L&Num
		endm

ExecModeJNZ	macro	Num
	jnz	ExecMode_L&Num
		endm

ExecModeJEZ	macro	Num
	jz	ExecMode_E&Num
		endm

ExecModeJENZ	macro	Num
	jnz	ExecMode_E&Num
		endm


ExecModeTest	macro	ModeFlag, CB_Reg
if	ModeFlag and vFlg_Local
ifidni	<CB_Reg>, <Vid>
	push	ebx
	mov	ebx, [Vid_VM_Handle]
	add	ebx, [VDD_CB_Offset]
	test	[ebx.VDD_SFlags], ModeFlag
	pop	ebx
else
ifidni	<CB_Reg>, <Cur>
	push	ebx
	VMMCall	Get_Cur_VM_Handle
	add	ebx, [VDD_CB_Offset]
	test	[ebx.VDD_SFlags], ModeFlag
	pop	ebx
else
ifb	<CB_Reg>
	push	ebx
	add	ebx, [VDD_CB_Offset]
	test	[ebx.VDD_SFlags], ModeFlag
	pop	ebx
else
	test	[CB_Reg.VDD_SFlags], ModeFlag
endif
endif
endif
else
	test	[Vid_SFlags], ModeFlag
endif
	endm


ExecModeChk	macro	HdrFlag, JmpFlag, JmpLabel, ModeFlag, CB_Reg
ifidni	<HdrFlag>, <Jmp>
.erre	FlgExecMode
	ExecModeJE	%EndExecMode
endif
ExecModeLL	%NumExecMode
NumExecMode = NumExecMode + 1
FlgExecMode = 1
ifnb	<ModeFlag>
	ExecModeTest	<ModeFlag>, <CB_Reg>
ifidni	<JmpLabel>, <End>
ifidni	<JmpFlag>, <Not>
	ExecModeJENZ	%EndExecMode
else
	ExecModeJEZ	%EndExecMode
endif
else
ifidni	<JmpFlag>, <Not>
	ExecModeJNZ	%NumExecMode
else
	ExecModeJZ	%NumExecMode
endif
endif
endif
		endm

ExecModeEnd	macro
ExecModeLL	%NumExecMode
ExecModeLE	%EndExecMode
NumExecMode = NumExecMode + 1
EndExecMode = EndExecMode + 1
FlgExecMode = 0
		endm

   ;
   ;	CB_Reg   = Regs/Vid/Cur
   ;	ModeFlag = vFlg_xxxx
   ;
ExecModeJmp	macro	JmpLabel, ModeFlag, CB_Reg
	ExecModeTest	%ModeFlag, <CB_Reg>
	jnz	JmpLabel
		endm

ExecModeJmpNot	macro	JmpLabel, ModeFlag, CB_Reg
	ExecModeTest	%ModeFlag, <CB_Reg>
	jz	JmpLabel
		endm

ExecMode	macro	ModeFlag, CB_Reg
	ExecModeChk Top, Equ, Next, %ModeFlag, CB_Reg
		endm

ExecModeNot	macro	ModeFlag, CB_Reg
	ExecModeChk Top, Not, Next, %ModeFlag, CB_Reg
		endm

ExecModeOnly	macro	ModeFlag, CB_Reg
	ExecModeChk Top, Equ, End, %ModeFlag, CB_Reg
		endm

ExecModeOnlyNot	macro	ModeFlag, CB_Reg
	ExecModeChk Top, Not, End, %ModeFlag, CB_Reg
		endm

ExecModeElse	macro	ModeFlag, CB_Reg
	ExecModeChk Jmp, Equ, Next, %ModeFlag, CB_Reg
		endm

ExecModeElseNot	macro	ModeFlag, CB_Reg
	ExecModeChk Jmp, Not, Next, %ModeFlag, CB_Reg
		endm

ExecModeThru	macro	ModeFlag, CB_Reg
	ExecModeChk Thru, Equ, Next, %ModeFlag, CB_Reg
		endm

ExecModeThruNot	macro	ModeFlag, CB_Reg
	ExecModeChk Thru, Not, Next, %ModeFlag, CB_Reg
		endm

NumExecMode = 1
EndExecMode = 1
FlgExecMode = 0

else ;NEC_98
;
;Some external definitions.  Only define these if we're assembling the
;device independent "main" portion of the Mini-VDD:
;
ifdef MAINVDD
externdef	MiniVDDDispatchTable:dword	;in VDDCTL.ASM
endif ;MAINVDD
;
;
MiniVDDDispatch 	macro	FunctionCode, HandlerAddr
	mov	[edi+(FunctionCode*4)],OFFSET32 MiniVDD_&HandlerAddr
endm
;
;
CardVDDDispatch 	macro	FunctionCode, HandlerAddr
	mov	[edi+(FunctionCode*4)],OFFSET32 CardVDD_&HandlerAddr
endm
;
;
MiniVDDCall		macro	FunctionCode, SaveFlags
local   MiniVDDCallExit, MiniVDDCallLeave

ifdef MAXDEBUG
  ifndef NoTrace_&FunctionCode&
        Trace_Out "MiniVDDCall: &FunctionCode&"
  endif
endif
        push    edi                     ;;save this register for now
ifnb    <SaveFlags>
	pushfd				;;save the flags state
endif
	mov	edi,OFFSET32 MiniVDDDispatchTable
	cmp	dword ptr [edi+(FunctionCode*4)],0
	je	MiniVDDCallLeave	;;MiniVDD doesn't support this
ifnb	<SaveFlags>
	popfd				;;just clear the Stack from the flags
endif
        call    dword ptr [edi+(FunctionCode*4)]
ifnb	<SaveFlags>
	jmp	MiniVDDCallExit 	;;we already restored the flags
endif
;
MiniVDDCallLeave:
ifnb	<SaveFlags>
	popfd				;;
endif
;
MiniVDDCallExit:
	pop	edi			;;we're done handling this call
endm
endif ;NEC_98
*/

#ifdef __cplusplus
}
#endif // __cplusplus

#endif  // _MINIVDD_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\ddraw\common\inc\k32exp.h ===
/* 
 * K32EXP.H -- Get32ProcAddress
 * Win32 code to import by ordinal from KERNEL32.DLL in Windows 95
 *
 * Andrew Schulman
 * Senior editor, O'Reilly & Associates (Sebastopol CA)
 * andrew@ora.com
 * 
 * August 1995
 */

// KERNEL32.1 through KERNEL32.9 are all VxDCall
#define VXDCALL_ORD                 1

// found these by examining RUNDLL32.EXE
#define LOADLIBRARY16_ORD           35
#define FREELIBRARY16_ORD           36
#define GETPROCADDRESS16_ORD        37

// found these by examining WOW32.DLL
// actually, these are documented: see GENTHUNK.TXT ("Windows NT
// Generic Thunk Overview") and WOWNT32.H in Microsoft's Win32 SDK
#define WOWCallback16_ORD           54                      
#define WOWCallback16Ex_ORD         55                      
#define WOWGetVDMPointer_ORD        56                      
#define WOWHandle32_ORD             57                      
#define WOWHandle16_ORD             58                      
#define WOWGlobalAlloc16_ORD        59                      
#define WOWGlobalLock16_ORD         60                      
#define WOWGlobalUnlock16_ORD       61                      
#define WOWGlobalFree16_ORD         62                      
#define WOWGlobalAllocLock16_ORD    63                      
#define WOWGlobalUnlockFree16_ORD   64                      
#define WOWGlobalLockSize16_ORD     65                      
#define WOWYield16_ORD              66                      
#define WOWDirectedYield16_ORD      67                      
#define WOWGetVDMPointerFix_ORD     68                      
#define WOWGetVDMPointerUnfix_ORD   69                      
#define WOW32_1_ORD                 70

// found these by examining NTDLL.DLL (Win95)
#define RtlLargeIntegerAdd_ORD              72 
#define RtlEnlargedIntegerMultiply_ORD      73 
#define RtlEnlargedUnsignedMultiply_ORD     74 
#define RtlEnlargedUnsignedDivide_ORD       75 
#define RtlExtendedLargeIntegerDivide_ORD   76 
#define RtlExtendedMagicDivide_ORD          77 
#define RtlExtendedIntegerMultiply_ORD      78 
#define RtlLargeIntegerShiftLeft_ORD        79 
#define RtlLargeIntegerShiftRight_ORD       80 
#define RtlLargeIntegerArithmeticShift_ORD  81 
#define RtlLargeIntegerNegate_ORD           82 
#define RtlLargeIntegerSubtract_ORD         83 
#define RtlConvertLongToLargeInteger_ORD    84 
#define RtlConvertUlongToLargeInteger_ORD   85 

#define GETPWIN16MUTEX_ORD          93
#define ENTERSYSLEVEL_ORD           97
#define LEAVESYSLEVEL_ORD           98

// VxDCall is probably the most important undocumented Win32 API
DWORD (WINAPI *VxDCall)(DWORD srvc, DWORD eax, DWORD ecx);

// Walking VxD chain shows that these are the VxDs that provide
// Win32 services
#define VMM_ID          0x0001             // 41 services
#define REBOOT_ID       0x0009             // 2
#define VNETBIOS_ID     0x0014             // 2
#define VWIN32_ID       0x002A             // 79
#define VCOMM_ID        0x002B             // 27
#define VCOND_ID        0x0038             // 53 -- Virtual CON (Console)

// found these by examining ADVAPI32.DLL and REGSERV.EXE
// REGSERV.EXE calls these directly for remote registry services
#define RegOpenKeyEx_CALL                   0x10011
#define RegCreatKeyA_CALL                   0x10012
#define RegCloseKey_CALL                    0x10013
#define RegDeleteKey_CALL                   0x10014
#define RegSetValueA_CALL                   0x10015
#define RegDeleteValueA_CALL                0x10016
#define RegQueryValueA_CALL                 0x10017
#define RegEnumKeyA_CALL                    0x10018
#define RegQueryValueEx_CALL                0x1001A
#define RegSetValueExA_CALL                 0x1001B
#define RegFlushKey_CALL                    0x1001C
#define RegLoadKeyA_CALL                    0x10021
#define RegUnloadKeyA_CALL                  0x10022
#define RegSaveKeyA_CALL                    0x10023
#define RegRemapPreDefKey_CALL              0x10024
#define RegQueryMultipleValuesA_CALL        0x10026
#define RegReplaceKeyA_CALL                 0x10027

// two important VWIN32 services
#define VWIN32_INT21_CALL       0x2A0010
#define VWIN32_INT31_CALL       0x2A0029
#define DosCall(eax, ecx)       VxDCall(VWIN32_INT21_CALL, (eax), (ecx))
#define DPMICall(eax, ecx)      VxDCall(VWIN32_INT31_CALL, (eax), (ecx))

#if 0
// other undocumented interfaces
HINSTANCE (WINAPI *LoadLibrary16)(LPCSTR lpLibFileName);
int (WINAPI *FreeLibrary16)(HINSTANCE hModule);
FARPROC (WINAPI *GetProcAddress16)(HINSTANCE hModule, LPCSTR lpProcName);
void (WINAPI *GetpWin16Lock)(DWORD *pWin16Lock);
// int (WINAPI *_ConfirmWin16Lock)(void);  // returns current lock count
void (WINAPI *_EnterSysLevel)(DWORD lock);
void (WINAPI *_LeaveSysLevel)(DWORD lock);
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\ddraw\common\inc\nv4Tables.h ===
#ifndef _NV4TABLES_H
#define _NV4TABLES_H

/*
 * Copyright 1993-1998 NVIDIA, Corporation.  All rights reserved.
 *
 * THE INFORMATION CONTAINED HEREIN IS PROPRIETARY AND CONFIDENTIAL TO
 * NVIDIA, CORPORATION.  USE, REPRODUCTION OR DISCLOSURE TO ANY THIRD PARTY
 * IS SUBJECT TO WRITTEN PRE-APPROVAL BY NVIDIA, CORPORATION.
 */
/********************************* Direct 3D *******************************\
*                                                                           *
* Module: nv4tables.h                                                      *
*     Constants and macros associated with nv4tables.cpp                   *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*       Craig Duttweiler    (bertrem)    28Oct99     created                *
*                                                                           *
\***************************************************************************/

#if (NVARCH >= 0x004)

#define DRAW_PRIM_TABLE_ENTRIES      0x800

extern DWORD dwDrawPrimitiveTable [DRAW_PRIM_TABLE_ENTRIES+4];

#define LIST_STRIDES   0x00000303
#define STRIP_STRIDES  0x01010101
#define FAN_STRIDES    0x02000001
#define LEGACY_STRIDES 0x03000404

extern DWORD nv4DP2OpToStride [D3D_DP2OP_MAX+1];

#endif  // NVARCH >= 0x010

#endif  // _NV4TABLES_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\ddraw\common\inc\nvblockmanager.h ===
/*
 * Copyright 1993-1998 NVIDIA, Corporation.  All rights reserved.
 * THE INFORMATION CONTAINED HEREIN IS PROPRIETARY AND CONFIDENTIAL TO
 * NVIDIA, CORPORATION.  USE, REPRODUCTION OR DISCLOSURE TO ANY THIRD PARTY
 * IS SUBJECT TO WRITTEN PRE-APPROVAL BY NVIDIA, CORPORATION.
 */
/********************************* Direct 3D *******************************\
*                                                                           *
* Module: nvBlockManager.cpp                                                *
*   block management/caching/renaming                                       *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*       Franck Diard/Michael Conrad  21Feb2001  rel20 development            *
*                                                                           *
\***************************************************************************/


#ifdef MCFD

#if (NVARCH >= 0x04)

#include "nvprecomp.h" 
#pragma hdrstop
#endif

class CMipLevelSet;
class CBlockListHeader;
class CMipLevel;
class CTexture;
class CBlockList;
class CBlockDescriptor;


enum
{
    RENAME_POLICY_NO_COPY   = 1,            // rename if allowed
    RENAME_POLICY_COPY   = 2,            // rename if allowed and also copy contents forward
};
/*
enum
{
    ALLOCATE_SIMPLE         = 0x00000001,
    ALLOCATE_TILED          = 0x00000002,
    ALLOCATE_AS_ZBUFFER_UNC = 0x00000010,   // uncompressed z-buffer
    ALLOCATE_AS_ZBUFFER_CMP = 0x00000020,   // compressed z-buffer
    ALLOCATE_AS_ZBUFFER     = 0x00000030    // any z format
};

enum
{
    FLAG_UPTODATE           = 0x00000100,   // surface data is up to date (can be used)
    FLAG_RENDERTARGET       = 0x00000200,   // surface is a render target
    FLAG_ZBUFFER            = 0x00000400,   // surface is a zbuffer
    FLAG_DONOTOWNMEMORY     = 0x00000800,   // memory management is done by somebody else (not self)
    FLAG_TILED              = 0x00001000,   // surface was allocated in tiled memory
    FLAG_SWIZZLED           = 0x00002000,   // surface is a swizzled (used by nvSetRenderTargetDX7)
    FLAG_available          = 0x00004000,
    FLAG_HASALPHA           = 0x00008000,   // surface format has alpha
    FLAG_ISDXT              = 0x00010000,   // surface format is DXT
#ifdef  STEREO_SUPPORT
    FLAG_STEREO             = 0x00020000,   // surface is stereo
#endif  //STEREO_SUPPORT

};
typedef enum
{
    LOCK_NONE               = 0,            // reserved
    LOCK_READ               = 1,            // READ
    LOCK_WRITE              = 2,            // WRITE
}BMLockPermission;

typedef enum
{
    HEAP_LOCATION_MASK      = 0x0000001f,   // surface location - preserve order
}BMMask;
typedef enum
{
    HEAP_VID                = 0x01,
    HEAP_AGP                = 0x02,
    HEAP_PCI                = 0x04,
    HEAP_SYS                = 0x08,

    HEAP_DYNSYS             = 0x18,
    HEAP_DYNSYSBIT          = 0x10,
    HEAP_ANYWHERE           = HEAP_VID | HEAP_AGP | HEAP_PCI | HEAP_SYS | HEAP_DYNSYS,
    HEAP_NOWHERE            = 0x0,
}DWORD;
 */

extern DWORD g_adwSurfaceContextDMA[9];

inline BOOL  BMhwCanRead         (DWORD dwFlags)         { return (dwFlags & CSimpleSurface::HEAP_LOCATION_MASK) != CSimpleSurface::HEAP_SYS; }
inline BOOL  BMhwCanWrite        (DWORD dwFlags)         { return (dwFlags & CSimpleSurface::HEAP_LOCATION_MASK) == CSimpleSurface::HEAP_VID; }
inline BOOL  BMisReadCached      (DWORD dwFlags)         { return (dwFlags & CSimpleSurface::HEAP_LOCATION_MASK) >= CSimpleSurface::HEAP_PCI; }
inline BOOL  BMisWriteCached     (DWORD dwFlags)         { return (dwFlags & CSimpleSurface::HEAP_LOCATION_MASK) >= CSimpleSurface::HEAP_PCI; }
inline BOOL  BMisWriteCombined   (DWORD dwFlags)         { return (dwFlags & CSimpleSurface::HEAP_LOCATION_MASK) <= CSimpleSurface::HEAP_AGP; }

#define MAXHEAD 4           // is there a limit here ?

BOOL GarbageCollect(DWORD Heap);

class CBlockManager
{
    friend CBlockList;
    friend CBlockDescriptor;

    //active blocks

	CBlockDescriptor * m_apVIDFirst[1];           // one heap per chip
	CBlockDescriptor * m_pAGPFirst;
	CBlockDescriptor * m_pPCIFirst;
	CBlockDescriptor * m_pSYSFirst;

    // cached block

	CBlockDescriptor * m_apVIDAllocCacheFirst[1];
	CBlockDescriptor * m_pAGPAllocCacheFirst;
	CBlockDescriptor * m_pPCIAllocCacheFirst;
	CBlockDescriptor * m_pSYSAllocCacheFirst;


    DWORD m_dwAllocatedVIDMemory;
    DWORD m_adwAllocatedVIDMemoryPerDevice[1];
    DWORD m_dwAllocatedAGPMemory;
    DWORD m_dwAllocatedPCIMemory;
    DWORD m_dwAllocatedSYSMemory;

    DWORD m_dwActiveBlocks;
    DWORD m_dwCachedBlocks;

public:

    CBlockManager();


    BOOL CBlockManager::GarbageCollect(DWORD Heaps);

    BOOL CreateBlock(CBlockList * BlockList,            // create, allocate and register a block, clone of SimpleSurface::create
        DWORD dwPitch,
        DWORD dwHeight,
        DWORD dwDepth,
        DWORD dwBPPGranted,
        DWORD dwAllowedHeaps,
        DWORD dwPreferredHeap,
        DWORD dwAllocFlags
    );

    BOOL AllocateBlock(
        CBlockDescriptor * ToFill,
        DWORD dwPitch,
        DWORD dwHeight,
        DWORD dwDepth,
        DWORD dwBPPGranted,
        DWORD dwAllowedHeaps,
        DWORD dwPreferredHeap,
        DWORD dwAllocFlags
    );

    BOOL OwnBlock(              CBlockList * BlockList,
                                DWORD dwAddress, DWORD dwPitch, DWORD dwLogHeight, 
                                DWORD dwHeapLocation, BOOL bOwnMemory );

    BOOL DisownBlock( CBlockList * BlockList);

    BOOL CreateBlock(CBlockDescriptor * ToClone);
    BOOL FreeBlock(CBlockList * BlockList, CBlockDescriptor * ToFree);
    BOOL FreeList(CBlockList * BlockList);
    BOOL Lock(CBlockList * BlockList, DWORD dwAccess, DWORD dwNewSize=-1);


private:
    BOOL AddToCachedBlockList(CBlockDescriptor * ToAdd);
    BOOL RegisterBlock(CBlockList * BlockList, CBlockDescriptor * ToAdd);
};

class CBlockDescriptor          // basically, a CSimpleSurface
{
    friend CBlockList;
    friend CBlockManager;

    DWORD   m_dwAddress;       // surface address [absolute]
    DWORD   m_dwOffset;        // surface offset [depends on dma context]
    DWORD   m_dwFlags;         // flags
    DWORD   m_dwHeap;
    DWORD   m_dwRetireDate;    // date that HW access retires
    DWORD   m_dwSize;         // size
    DWORD   m_dwAllocFlags;
    DWORD   m_dwPitch;
    DWORD   m_dwWidth;
    DWORD   m_dwHeight;        // height = 1 for vertex buffers, etc
    DWORD   m_dwDepth;         // depth = 1 for vertex buffers, etc

    CBlockList * m_pOwner; 

    CBlockDescriptor * m_pNextGlobal; // block manager use
    CBlockDescriptor * m_pPreviousGlobal; // block manager use        for debranching

	CBlockDescriptor * m_pNextRenamed; // renaming use
	CBlockDescriptor * m_pPreviousRenamed; // renaming use

public:
 


    inline BOOL  hwCanRead         (void)         const { return (BMhwCanRead(m_dwFlags)); }
    inline BOOL  hwCanWrite        (void)         const { return (BMhwCanWrite(m_dwFlags)); }
    inline BOOL  isReadCached      (void)         const { return (BMisReadCached(m_dwFlags)); }
    inline BOOL  isWriteCached     (void)         const { return (BMisWriteCached(m_dwFlags)); }
    inline BOOL  isWriteCombined   (void)         const { return (BMisWriteCombined(m_dwFlags)); }

    inline DWORD getAddress        (void)         const { return m_dwAddress; }
    inline DWORD getOffset         (void)         const { return m_dwOffset;  }
    inline DWORD getSize           (void)         const { return m_dwSize;  }

    inline DWORD getContextDMA     (void)         const { return g_adwSurfaceContextDMA[m_dwFlags & CSimpleSurface::HEAP_LOCATION_MASK]; }
    inline DWORD getHeapLocation   (void)         const { return m_dwFlags & CSimpleSurface::HEAP_LOCATION_MASK; }
    inline DWORD getFlags          (void)         const { return m_dwFlags; }

    BOOL IsBusy();

    CBlockDescriptor()
    {
        memset(this, 0, sizeof(CBlockDescriptor));
    }
};


class CBlockList
{
public:
    BOOL m_renaming;
    BOOL m_bOwnMemory;

	CBlockDescriptor * m_pActive;
	DWORD   m_dwNb;
	DWORD   m_dwMax;

    BOOL m_cpuLocked;
    BOOL m_gpuLocked;

    DWORD m_dwAllowedHeaps;
    DWORD m_dwPreferredHeap;
    DWORD m_dwBPPGranted;

    CBlockList(DWORD Max=6)
    {
        memset(this, 0, sizeof(CBlockList));
        m_dwMax=Max;
    }

    void  LockForGPU(DWORD dwAccess);
    void  UnlockForGPU(void);

    void  LockForCPU(DWORD dwAccess, DWORD dwRenamePolicy=RENAME_POLICY_NO_COPY);
    void  UnlockForCPU(void);

    BOOL Rename(DWORD dwRenamingCopyPolicy);

public:


    void  enableRenaming( ) {m_renaming=TRUE;};
    void  disableRenaming() {m_renaming=FALSE;};            // should cleanup


    inline DWORD modifyDDCaps (DWORD dwCaps) const
    {
        // clear all flags
        dwCaps &= ~(DDSCAPS_VIDEOMEMORY    |
                    DDSCAPS_LOCALVIDMEM    |
                    DDSCAPS_NONLOCALVIDMEM |
                    DDSCAPS_SYSTEMMEMORY);
        // put back the flags we want
        switch (m_pActive->m_dwFlags & CSimpleSurface::HEAP_LOCATION_MASK)
        {
            case CSimpleSurface::HEAP_VID:
                dwCaps |= (DDSCAPS_VIDEOMEMORY | DDSCAPS_LOCALVIDMEM);
                break;
            case CSimpleSurface::HEAP_AGP:
            case CSimpleSurface::HEAP_PCI:
                dwCaps |= (DDSCAPS_VIDEOMEMORY | DDSCAPS_NONLOCALVIDMEM);
                break;
            // DDRAW just hates it if you specify the DDSCAPS_SYSTEMMEMORY flag. basically it will
            //  never call back to free surfaces. Ugghh.
            // believe it or not, it actually want the VidMem flag set!
            default:
                dwCaps |= (DDSCAPS_VIDEOMEMORY);
                break;
        }
        // return the new flags
        return (dwCaps);
    }
};



//////////////////////////// 

class CMipLevelSet
{
	void * m_data;  //pointer to the whole bitmap

	CBlockList m_blockList;   // list header of the blocks belonging to the renaming chain

	int m_pNbLevels;	   //number of items in the array
	CMipLevel * m_pLevels;     // the array  6 mip level -> new CMipLevel[6]
    BOOL m_bDirtyMipLevels;

	CTexture * m_pOwner;

	AllocateCreateVolume(DWORD dwWitdh, DWORD dwHeight, DWORD dwDepth, DWORD dwMip, DWORD SizeOfItem, DWORD dwFlags);
	AllocateCreate2DTexture(DWORD dwWitdh, DWORD dwHeight, DWORD dwMip, DWORD SizeOfItem, DWORD dwFlags);
	AllocateCreateCubeMap(DWORD dwWitdh, DWORD dwHeight, DWORD dwMip, DWORD SizeOfItem, DWORD dwFlags);

	UpdateMipMapChain(int MipLevelToExclude); //Update bitmap
	Lock(); // BM->Lock(m_blockList, rename_policy);
	UnLock();
};

class CMipLevel
{
	CMipLevelSet * m_pOwner;
	DWORD m_dwDataOffset;
	DWORD m_dwHeight;
	DWORD m_dwWidth;
	DWORD m_dwPitch;
	Lock(); // m_pOwner->Lock()
};



#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\ddraw\common\inc\nvAccess.h ===
//======================================================================
// Module:		nvAccess.cpp
// Description:	Generic kernel access routines that are neutral to the calling OS
// 
//  Copyright (C) 2000 NVidia Corporation.  All Rights Reserved.
//======================================================================

#ifndef NVFILE_H
#define NVFILE_H

//#include <nvprecomp.h>

#ifdef WINNT

//#define NV_USE_ZW_PFUNCS

typedef LONG NTSTATUS;
//
// Unicode strings are counted 16-bit character strings. If they are
// NULL terminated, Length does not include trailing NULL.
//

typedef struct _UNICODE_STRING {
    USHORT Length;
    USHORT MaximumLength;
#ifdef MIDL_PASS
    [size_is(MaximumLength / 2), length_is((Length) / 2) ] USHORT * Buffer;
#else // MIDL_PASS
    PWSTR  Buffer;
#endif // MIDL_PASS
} UNICODE_STRING;
typedef UNICODE_STRING *PUNICODE_STRING;
typedef const UNICODE_STRING *PCUNICODE_STRING;
#define UNICODE_NULL ((WCHAR)0) // winnt

//
// Define the base asynchronous I/O argument types
//

typedef struct _IO_STATUS_BLOCK {
    union {
        NTSTATUS Status;
        PVOID Pointer;
    };

    ULONG_PTR Information;
} IO_STATUS_BLOCK, *PIO_STATUS_BLOCK;

typedef
VOID
(NTAPI *PIO_APC_ROUTINE) (
    IN PVOID ApcContext,
    IN PIO_STATUS_BLOCK IoStatusBlock,
    IN ULONG Reserved
    );
#define PIO_APC_ROUTINE_DEFINED

//
// Valid values for the Attributes field
//

#define OBJ_INHERIT             0x00000002L
#define OBJ_PERMANENT           0x00000010L
#define OBJ_EXCLUSIVE           0x00000020L
#define OBJ_CASE_INSENSITIVE    0x00000040L
#define OBJ_OPENIF              0x00000080L
#define OBJ_OPENLINK            0x00000100L
#define OBJ_KERNEL_HANDLE       0x00000200L
#define OBJ_VALID_ATTRIBUTES    0x000003F2L

//
// Object Attributes structure
//

typedef struct _OBJECT_ATTRIBUTES {
    ULONG Length;
    HANDLE RootDirectory;
    PUNICODE_STRING ObjectName;
    ULONG Attributes;
    PVOID SecurityDescriptor;        // Points to type SECURITY_DESCRIPTOR
    PVOID SecurityQualityOfService;  // Points to type SECURITY_QUALITY_OF_SERVICE
} OBJECT_ATTRIBUTES;
typedef OBJECT_ATTRIBUTES *POBJECT_ATTRIBUTES;


typedef enum _KEY_VALUE_INFORMATION_CLASS {
    KeyValueBasicInformation,
    KeyValueFullInformation,
    KeyValuePartialInformation,
    KeyValueFullInformationAlign64,
    KeyValuePartialInformationAlign64
} KEY_VALUE_INFORMATION_CLASS;

typedef struct _KEY_VALUE_PARTIAL_INFORMATION {
    ULONG   TitleIndex;
    ULONG   Type;
    ULONG   DataLength;
    UCHAR   Data[64];            // Variable size
} KEY_VALUE_PARTIAL_INFORMATION, *PKEY_VALUE_PARTIAL_INFORMATION;

#define InitializeObjectAttributes( p, n, a, r, s ) { \
    (p)->Length = sizeof( OBJECT_ATTRIBUTES );          \
    (p)->RootDirectory = r;                             \
    (p)->Attributes = a;                                \
    (p)->ObjectName = n;                                \
    (p)->SecurityDescriptor = s;                        \
    (p)->SecurityQualityOfService = NULL;               \
    }

//
// Define the access check value for any access
//
//
// The FILE_READ_ACCESS and FILE_WRITE_ACCESS constants are also defined in
// ntioapi.h as FILE_READ_DATA and FILE_WRITE_DATA. The values for these
// constants *MUST* always be in sync.
//
//
// FILE_SPECIAL_ACCESS is checked by the NT I/O system the same as FILE_ANY_ACCESS.
// The file systems, however, may add additional access checks for I/O and FS controls
// that use this value.
//


#define FILE_ANY_ACCESS                 0
#define FILE_SPECIAL_ACCESS    (FILE_ANY_ACCESS)
#define FILE_READ_ACCESS          ( 0x0001 )    // file & pipe
#define FILE_WRITE_ACCESS         ( 0x0002 )    // file & pipe

// begin_winnt

//
// Define access rights to files and directories
//

//
// The FILE_READ_DATA and FILE_WRITE_DATA constants are also defined in
// devioctl.h as FILE_READ_ACCESS and FILE_WRITE_ACCESS. The values for these
// constants *MUST* always be in sync.
// The values are redefined in devioctl.h because they must be available to
// both DOS and NT.
//

#define FILE_READ_DATA            ( 0x0001 )    // file & pipe
#define FILE_LIST_DIRECTORY       ( 0x0001 )    // directory

#define FILE_WRITE_DATA           ( 0x0002 )    // file & pipe
#define FILE_ADD_FILE             ( 0x0002 )    // directory

#define FILE_APPEND_DATA          ( 0x0004 )    // file
#define FILE_ADD_SUBDIRECTORY     ( 0x0004 )    // directory
#define FILE_CREATE_PIPE_INSTANCE ( 0x0004 )    // named pipe


#define FILE_READ_EA              ( 0x0008 )    // file & directory

#define FILE_WRITE_EA             ( 0x0010 )    // file & directory

#define FILE_EXECUTE              ( 0x0020 )    // file
#define FILE_TRAVERSE             ( 0x0020 )    // directory

#define FILE_DELETE_CHILD         ( 0x0040 )    // directory

#define FILE_READ_ATTRIBUTES      ( 0x0080 )    // all

#define FILE_WRITE_ATTRIBUTES     ( 0x0100 )    // all


#define FILE_ALL_ACCESS (STANDARD_RIGHTS_REQUIRED | SYNCHRONIZE | 0x1FF)


#define FILE_GENERIC_READ         (STANDARD_RIGHTS_READ     |\
                                   FILE_READ_DATA           |\
                                   FILE_READ_ATTRIBUTES     |\
                                   FILE_READ_EA             |\
                                   SYNCHRONIZE)


#define FILE_GENERIC_WRITE        (STANDARD_RIGHTS_WRITE    |\
                                   FILE_WRITE_DATA          |\
                                   FILE_WRITE_ATTRIBUTES    |\
                                   FILE_WRITE_EA            |\
                                   FILE_APPEND_DATA         |\
                                   SYNCHRONIZE)


#define FILE_GENERIC_EXECUTE      (STANDARD_RIGHTS_EXECUTE  |\
                                   FILE_READ_ATTRIBUTES     |\
                                   FILE_EXECUTE             |\
                                   SYNCHRONIZE)

// end_winnt


//
// Define share access rights to files and directories
//

#define FILE_SHARE_READ                 0x00000001  // winnt
#define FILE_SHARE_WRITE                0x00000002  // winnt
#define FILE_SHARE_DELETE               0x00000004  // winnt
#define FILE_SHARE_VALID_FLAGS          0x00000007

//
// Define the file attributes values
//
// Note:  0x00000008 is reserved for use for the old DOS VOLID (volume ID)
//        and is therefore not considered valid in NT.
//
// Note:  0x00000010 is reserved for use for the old DOS SUBDIRECTORY flag
//        and is therefore not considered valid in NT.  This flag has
//        been disassociated with file attributes since the other flags are
//        protected with READ_ and WRITE_ATTRIBUTES access to the file.
//
// Note:  Note also that the order of these flags is set to allow both the
//        FAT and the Pinball File Systems to directly set the attributes
//        flags in attributes words without having to pick each flag out
//        individually.  The order of these flags should not be changed!
//


#define FILE_ATTRIBUTE_READONLY             0x00000001  // winnt
#define FILE_ATTRIBUTE_HIDDEN               0x00000002  // winnt
#define FILE_ATTRIBUTE_SYSTEM               0x00000004  // winnt
//OLD DOS VOLID                             0x00000008

#define FILE_ATTRIBUTE_DIRECTORY            0x00000010  // winnt
#define FILE_ATTRIBUTE_ARCHIVE              0x00000020  // winnt
#define FILE_ATTRIBUTE_DEVICE               0x00000040  // winnt
#define FILE_ATTRIBUTE_NORMAL               0x00000080  // winnt

#define FILE_ATTRIBUTE_TEMPORARY            0x00000100  // winnt
#define FILE_ATTRIBUTE_SPARSE_FILE          0x00000200  // winnt
#define FILE_ATTRIBUTE_REPARSE_POINT        0x00000400  // winnt
#define FILE_ATTRIBUTE_COMPRESSED           0x00000800  // winnt

#define FILE_ATTRIBUTE_OFFLINE              0x00001000  // winnt
#define FILE_ATTRIBUTE_NOT_CONTENT_INDEXED  0x00002000  // winnt
#define FILE_ATTRIBUTE_ENCRYPTED            0x00004000  // winnt


//
//  This definition is old and will disappear shortly
//

#define FILE_ATTRIBUTE_CONTENT_INDEXED      FILE_ATTRIBUTE_NOT_CONTENT_INDEXED

#define FILE_ATTRIBUTE_VALID_FLAGS      0x00007fb7
#define FILE_ATTRIBUTE_VALID_SET_FLAGS  0x000031a7

//
// Define the create disposition values
//

#define FILE_SUPERSEDE                  0x00000000
#define FILE_OPEN                       0x00000001
#define FILE_CREATE                     0x00000002
#define FILE_OPEN_IF                    0x00000003
#define FILE_OVERWRITE                  0x00000004
#define FILE_OVERWRITE_IF               0x00000005
#define FILE_MAXIMUM_DISPOSITION        0x00000005

//
// Define the create/open option flags
//

#define FILE_DIRECTORY_FILE                     0x00000001
#define FILE_WRITE_THROUGH                      0x00000002
#define FILE_SEQUENTIAL_ONLY                    0x00000004
#define FILE_NO_INTERMEDIATE_BUFFERING          0x00000008

#define FILE_SYNCHRONOUS_IO_ALERT               0x00000010
#define FILE_SYNCHRONOUS_IO_NONALERT            0x00000020
#define FILE_NON_DIRECTORY_FILE                 0x00000040
#define FILE_CREATE_TREE_CONNECTION             0x00000080

#define FILE_COMPLETE_IF_OPLOCKED               0x00000100
#define FILE_NO_EA_KNOWLEDGE                    0x00000200
#define FILE_OPEN_FOR_RECOVERY                  0x00000400
#define FILE_RANDOM_ACCESS                      0x00000800

#define FILE_DELETE_ON_CLOSE                    0x00001000
#define FILE_OPEN_BY_FILE_ID                    0x00002000
#define FILE_OPEN_FOR_BACKUP_INTENT             0x00004000
#define FILE_NO_COMPRESSION                     0x00008000

#define FILE_RESERVE_OPFILTER                   0x00100000
#define FILE_OPEN_REPARSE_POINT                 0x00200000
#define FILE_OPEN_NO_RECALL                     0x00400000
#define FILE_OPEN_FOR_FREE_SPACE_QUERY          0x00800000

#define FILE_COPY_STRUCTURED_STORAGE            0x00000041
#define FILE_STRUCTURED_STORAGE                 0x00000441

#define FILE_VALID_OPTION_FLAGS                 0x00ffffff
#define FILE_VALID_PIPE_OPTION_FLAGS            0x00000032
#define FILE_VALID_MAILSLOT_OPTION_FLAGS        0x00000032
#define FILE_VALID_SET_FLAGS                    0x00000036

//
// Define the I/O status information return values for NtCreateFile/NtOpenFile
//

#define FILE_SUPERSEDED                 0x00000000
#define FILE_OPENED                     0x00000001
#define FILE_CREATED                    0x00000002
#define FILE_OVERWRITTEN                0x00000003
#define FILE_EXISTS                     0x00000004
#define FILE_DOES_NOT_EXIST             0x00000005

//int 2e escape codes
#define ZWCREATEFILEFCODE 20h
#define ZWCLOSEHANDLEFCODE 18h
#define ZWWRITEFILEFCODE 0xed
#define ZWREADFILEFCODE	0xa1
#define ZWDEVICEIOCONTROLFILEFCODE 0x38
#define ZWOPENKEYCODE 0x67
#define ZWQUERYVALUECODE 0x9b
#define ZWSETVALUECODE 0xd7

#endif

BOOL NvReadFile(HANDLE hFile,                // handle to file
                LPVOID lpBuffer,             // data buffer
                DWORD nNumberOfBytesToRead,  // number of bytes to read
                LPDWORD lpNumberOfBytesRead, // number of bytes read
                LPOVERLAPPED lpOverlapped    // overlapped buffer
                );

BOOL NvWriteFile( HANDLE hFile,                    // handle to file
                LPCVOID lpBuffer,                // data buffer
                DWORD nNumberOfBytesToWrite,     // number of bytes to write
                LPDWORD lpNumberOfBytesWritten,  // number of bytes written
                LPOVERLAPPED lpOverlapped        // overlapped buffer
                );

BOOL NvCloseHandle(HANDLE h);

HANDLE NvCreateFile(LPCTSTR lpFileName,                         // file name
                   DWORD dwDesiredAccess,                      // access mode
                   DWORD dwShareMode,                          // share mode
                   LPSECURITY_ATTRIBUTES lpSecurityAttributes, // SD
                   DWORD dwCreationDisposition,                // how to create
                   DWORD dwFlagsAndAttributes,                 // file attributes
                   HANDLE hTemplateFile                        // handle to template file
                   );

BOOL NvDeviceIoControl(
                HANDLE hDevice,              // handle to device
                DWORD dwIoControlCode,       // operation control code
                LPVOID lpInBuffer,           // input data buffer
                DWORD nInBufferSize,         // size of input data buffer
                LPVOID lpOutBuffer,          // output data buffer
                DWORD nOutBufferSize,        // size of output data buffer
                LPDWORD lpBytesReturned,     // byte count
                LPOVERLAPPED lpOverlapped    // overlapped information
);


#endif

DWORD NvGetTickCount();
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\ddraw\common\inc\nvbenchmark.h ===
// **************************************************************************
//
//       Copyright 1993-1999 NVIDIA, Corporation.  All rights reserved.
//
//     NOTICE TO USER:   The source code  is copyrighted under  U.S. and
//     international laws.  Users and possessors of this source code are
//     hereby granted a nonexclusive,  royalty-free copyright license to
//     use this code in individual and commercial software.
//
//     Any use of this source code must include,  in the user documenta-
//     tion and  internal comments to the code,  notices to the end user
//     as follows:
//
//       Copyright 1993-1999 NVIDIA, Corporation.  All rights reserved.
//
//     NVIDIA, CORPORATION MAKES NO REPRESENTATION ABOUT THE SUITABILITY
//     OF  THIS SOURCE  CODE  FOR ANY PURPOSE.  IT IS  PROVIDED  "AS IS"
//     WITHOUT EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORPOR-
//     ATION DISCLAIMS ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,
//     INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY, NONINFRINGE-
//     MENT,  AND FITNESS  FOR A PARTICULAR PURPOSE.   IN NO EVENT SHALL
//     NVIDIA, CORPORATION  BE LIABLE FOR ANY SPECIAL,  INDIRECT,  INCI-
//     DENTAL, OR CONSEQUENTIAL DAMAGES,  OR ANY DAMAGES  WHATSOEVER RE-
//     SULTING FROM LOSS OF USE,  DATA OR PROFITS,  WHETHER IN AN ACTION
//     OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,  ARISING OUT OF
//     OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOURCE CODE.
//
//     U.S. Government  End  Users.   This source code  is a "commercial
//     item,"  as that  term is  defined at  48 C.F.R. 2.101 (OCT 1995),
//     consisting  of "commercial  computer  software"  and  "commercial
//     computer  software  documentation,"  as such  terms  are  used in
//     48 C.F.R. 12.212 (SEPT 1995)  and is provided to the U.S. Govern-
//     ment only as  a commercial end item.   Consistent with  48 C.F.R.
//     12.212 and  48 C.F.R. 227.7202-1 through  227.7202-4 (JUNE 1995),
//     all U.S. Government End Users  acquire the source code  with only
//     those rights set forth herein.
//
// **************************************************************************
//
//  Module: nvBenchmark.h
//        Prototypes and definitions for nvBenchmark.cpp utility class
//
//  History:
//        Menelaos Levas    1/30/2001
//
// **************************************************************************

#ifdef NV_PROFILE_DP2OPS

#define OUTPUT_TOTALS                   0x80000000
#define OUTPUT_ALL_DP2OPS               0x40000000
#define OUTPUT_HWSTATE_CHANGES          0x20000000

#define CLEAR_DATA                      0x08000000
#define OUTPUT_FRAMECOUNT               0x0000FFFF



class CBenchmark
{
public:
    DWORD logData(DWORD dwCommand, DWORD dwPrimCount);
    DWORD logDrawPrimitive(DWORD dwCount);
    DWORD beginHWStateChange(DWORD dwFlags, DWORD dwPut);
    DWORD endHWStateChange(DWORD dwPut);
    DWORD incActiveTextures();
    DWORD resetData();
    DWORD outputData(DWORD dwFlags);

protected:
    DWORD dwActiveTextures, dwLastPrimCount;
    DWORD dwHWStateChangeSize, dwStartPut;
    DWORD dwStateBlocks, dwDrawBlocks, dwLastType;
    DWORD dwCurrentFrame, dwHWStateChanges;
    DWORD dwDrawingCalls, dwStateCalls;
    DWORD dwDrawingPrimCount, dwStatePrimCount;
    DWORD dwTexPrims[5];
    DWORD dwHWChanged[13];
    DWORD dwStateBits[8192];
    DWORD dwCallsCountTable[D3D_DP2OP_MAX+1];
    DWORD dwPrimsCountTable[D3D_DP2OP_MAX+1];
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\ddraw\common\inc\nvCelsiusCaps.h ===
#ifndef _NVCELSIUSCAPS_H_
#define _NVCELSIUSCAPS_H_

#if (NVARCH >= 0x010)
/*
 * Copyright 1993-1998 NVIDIA, Corporation.  All rights reserved.
 * THE INFORMATION CONTAINED HEREIN IS PROPRIETARY AND CONFIDENTIAL TO
 * NVIDIA, CORPORATION.  USE, REPRODUCTION OR DISCLOSURE TO ANY THIRD PARTY
 * IS SUBJECT TO WRITTEN PRE-APPROVAL BY NVIDIA, CORPORATION.
 */
/********************************* Direct 3D *******************************\
*                                                                           *
* Module: nvCelsiusCaps.h                                                   *
*   Define the capabilities of the celsius D3D driver.                      *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*       Craig Duttweiler    bertrem     10Feb99     created                 *
*                                                                           *
\***************************************************************************/

/*
 * --------------------------------------------------------------------------
 *  Direct 3D HAL Capabilities
 * --------------------------------------------------------------------------
 */

/*
 * Define which fields of the D3DDEVICECAPS structure are valid.
 */
#define CELSIUS_DEVDESC_FLAGS           D3DDD_COLORMODEL                    |   \
                                        D3DDD_DEVCAPS                       |   \
                                        D3DDD_LINECAPS                      |   \
                                        D3DDD_TRICAPS                       |   \
                                        D3DDD_DEVICERENDERBITDEPTH          |   \
                                        D3DDD_DEVICEZBUFFERBITDEPTH

/*
 * Define the color model for the D3D driver.
 */
#define CELSIUS_COLORMODEL              D3DCOLOR_RGB

/*
 * Define the device capabilities.
 */
#define CELSIUS_DEVCAPS_FLAGS           D3DDEVCAPS_FLOATTLVERTEX            |   \
                                        D3DDEVCAPS_EXECUTESYSTEMMEMORY      |   \
                                        D3DDEVCAPS_EXECUTEVIDEOMEMORY       |   \
                                        D3DDEVCAPS_TLVERTEXSYSTEMMEMORY     |   \
                                        D3DDEVCAPS_TLVERTEXVIDEOMEMORY      |   \
                                        D3DDEVCAPS_TEXTUREVIDEOMEMORY       |   \
                                        D3DDEVCAPS_DRAWPRIMTLVERTEX         |   \
                                        D3DDEVCAPS_CANRENDERAFTERFLIP       |   \
                                        D3DDEVCAPS_TEXTURENONLOCALVIDMEM    |   \
                                        D3DDEVCAPS_DRAWPRIMITIVES2          |   \
                                        D3DDEVCAPS_DRAWPRIMITIVES2EX        |   \
                                        D3DDEVCAPS_CANBLTSYSTONONLOCAL      |   \
                                        D3DDEVCAPS_PUREDEVICE               |   \
                                        D3DDEVCAPS_HWVERTEXBUFFER           |   \
                                        D3DDEVCAPS_HWINDEXBUFFER            |   \
                                        D3DDEVCAPS_HWTRANSFORMANDLIGHT      |   \
                                        D3DDEVCAPS_TEXTURENONLOCALVIDMEM    |   \
                                        D3DDEVCAPS_HWRASTERIZATION

/*
 * Define the transformation capabilities.
 */
#define CELSIUS_TRANSFORMCAPS_FLAGS     D3DTRANSFORMCAPS_CLIP

/*
 * Define 3D clipping capabilities.
 */
#define CELSIUS_3DCLIPPINGCAPS          TRUE

/*
 * Define the lighting capabilities.
 */
#define CELSIUS_LIGHTINGCAPS_FLAGS      D3DLIGHTINGMODEL_RGB                |   \
                                        D3DLIGHTCAPS_POINT                  |   \
                                        D3DLIGHTCAPS_SPOT                   |   \
                                        D3DLIGHTCAPS_DIRECTIONAL
#define CELSIUS_MAX_LIGHTS              8

/*
 * Define NULL primary capabilities.
 */
#define CELSIUS_PRIMCAPS_NULL           0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0

/*
 * Define the line capabilities.
 *
 * Miscellaneous capabilities (dwMiscCaps)
 */
#define CELSIUS_LINECAPS_MISC           D3DPMISCCAPS_MASKZ                  |   \
                                        D3DPMISCCAPS_CULLNONE               |   \
                                        D3DPMISCCAPS_CULLCW                 |   \
                                        D3DPMISCCAPS_CULLCCW                |   \
                                        D3DPMISCCAPS_BLENDOP                |   \
                                        D3DPMISCCAPS_COLORWRITEENABLE       |   \
                                        D3DPMISCCAPS_TSSARGTEMP

/*
 * Raster capabilities (dwRasterCaps)
 */
#define CELSIUS_LINECAPS_RASTER         D3DPRASTERCAPS_DITHER                   |   \
                                        D3DPRASTERCAPS_SUBPIXEL                 |   \
                                        D3DPRASTERCAPS_FOGVERTEX                |   \
                                        D3DPRASTERCAPS_FOGTABLE                 |   \
                                        D3DPRASTERCAPS_MIPMAPLODBIAS            |   \
                                        D3DPRASTERCAPS_ZBIAS                    |   \
                                        D3DPRASTERCAPS_FOGRANGE                 |   \
                                        D3DPRASTERCAPS_ANISOTROPY               |   \
                                        D3DPRASTERCAPS_WBUFFER                  |   \
                                        D3DPRASTERCAPS_WFOG                     |   \
                                        D3DPRASTERCAPS_STRETCHBLTMULTISAMPLE    |   \
                                        D3DPRASTERCAPS_ZFOG

/*
 * Z Compare capabilities (dwZCmpCaps)
 */
#define CELSIUS_LINECAPS_ZCMP           D3DPCMPCAPS_NEVER                   |   \
                                        D3DPCMPCAPS_LESS                    |   \
                                        D3DPCMPCAPS_EQUAL                   |   \
                                        D3DPCMPCAPS_LESSEQUAL               |   \
                                        D3DPCMPCAPS_GREATER                 |   \
                                        D3DPCMPCAPS_NOTEQUAL                |   \
                                        D3DPCMPCAPS_GREATEREQUAL            |   \
                                        D3DPCMPCAPS_ALWAYS

/*
 * Source blend capabilities (dwSrcBlendCaps)
 */
#define CELSIUS_LINECAPS_SRCBLEND       D3DPBLENDCAPS_ZERO                  |   \
                                        D3DPBLENDCAPS_ONE                   |   \
                                        D3DPBLENDCAPS_SRCCOLOR              |   \
                                        D3DPBLENDCAPS_INVSRCCOLOR           |   \
                                        D3DPBLENDCAPS_SRCALPHA              |   \
                                        D3DPBLENDCAPS_INVSRCALPHA           |   \
                                        D3DPBLENDCAPS_DESTALPHA             |   \
                                        D3DPBLENDCAPS_INVDESTALPHA          |   \
                                        D3DPBLENDCAPS_DESTCOLOR             |   \
                                        D3DPBLENDCAPS_INVDESTCOLOR          |   \
                                        D3DPBLENDCAPS_SRCALPHASAT           |   \
                                        D3DPBLENDCAPS_BOTHSRCALPHA          |   \
                                        D3DPBLENDCAPS_BOTHINVSRCALPHA

/*
 * Destination blend capabilities (dwDestBlendCaps)
 */
#define CELSIUS_LINECAPS_DESTBLEND      D3DPBLENDCAPS_ZERO                  |   \
                                        D3DPBLENDCAPS_ONE                   |   \
                                        D3DPBLENDCAPS_SRCCOLOR              |   \
                                        D3DPBLENDCAPS_INVSRCCOLOR           |   \
                                        D3DPBLENDCAPS_SRCALPHA              |   \
                                        D3DPBLENDCAPS_INVSRCALPHA           |   \
                                        D3DPBLENDCAPS_DESTALPHA             |   \
                                        D3DPBLENDCAPS_INVDESTALPHA          |   \
                                        D3DPBLENDCAPS_DESTCOLOR             |   \
                                        D3DPBLENDCAPS_INVDESTCOLOR          |   \
                                        D3DPBLENDCAPS_SRCALPHASAT           |   \
                                        D3DPBLENDCAPS_BOTHSRCALPHA          |   \
                                        D3DPBLENDCAPS_BOTHINVSRCALPHA

/*
 * Alpha compare capabilities (dwAlphaCmpCaps)
 */
#define CELSIUS_LINECAPS_ALPHACMP       D3DPCMPCAPS_NEVER                   |   \
                                        D3DPCMPCAPS_LESS                    |   \
                                        D3DPCMPCAPS_EQUAL                   |   \
                                        D3DPCMPCAPS_LESSEQUAL               |   \
                                        D3DPCMPCAPS_GREATER                 |   \
                                        D3DPCMPCAPS_NOTEQUAL                |   \
                                        D3DPCMPCAPS_GREATEREQUAL            |   \
                                        D3DPCMPCAPS_ALWAYS

/*
 * Shading capabilities (dwShadeCaps)
 */
#define CELSIUS_LINECAPS_SHADE          D3DPSHADECAPS_COLORFLATMONO         |   \
                                        D3DPSHADECAPS_COLORFLATRGB          |   \
                                        D3DPSHADECAPS_COLORGOURAUDMONO      |   \
                                        D3DPSHADECAPS_COLORGOURAUDRGB       |   \
                                        D3DPSHADECAPS_SPECULARFLATRGB       |   \
                                        D3DPSHADECAPS_SPECULARGOURAUDRGB    |   \
                                        D3DPSHADECAPS_ALPHAFLATBLEND        |   \
                                        D3DPSHADECAPS_ALPHAGOURAUDBLEND     |   \
                                        D3DPSHADECAPS_FOGFLAT               |   \
                                        D3DPSHADECAPS_FOGGOURAUD

/*
 * Texture capabilities (dwTextureCaps)
 */
#define CELSIUS_LINECAPS_TEXTURE        D3DPTEXTURECAPS_PERSPECTIVE         |   \
                                        D3DPTEXTURECAPS_POW2                |   \
                                        D3DPTEXTURECAPS_ALPHA               |   \
                                        D3DPTEXTURECAPS_TRANSPARENCY        |   \
                                        D3DPTEXTURECAPS_CUBEMAP             |   \
                                        D3DPTEXTURECAPS_CUBEMAP_POW2        |   \
                                        D3DPTEXTURECAPS_MIPCUBEMAP          |   \
                                        D3DPTEXTURECAPS_MIPMAP              |   \
                                        D3DPTEXTURECAPS_PROJECTED           |   \
                                        D3DPTEXTURECAPS_ALPHAPALETTE

/*
 * Texture filtering capabilities (dwTextureFilterCaps)
 */
#define CELSIUS_LINECAPS_TEXTUREFILTER  D3DPTFILTERCAPS_NEAREST             |   \
                                        D3DPTFILTERCAPS_LINEAR              |   \
                                        D3DPTFILTERCAPS_MIPNEAREST          |   \
                                        D3DPTFILTERCAPS_MIPLINEAR           |   \
                                        D3DPTFILTERCAPS_LINEARMIPNEAREST    |   \
                                        D3DPTFILTERCAPS_LINEARMIPLINEAR     |   \
                                        D3DPTFILTERCAPS_MINFPOINT           |   \
                                        D3DPTFILTERCAPS_MINFLINEAR          |   \
                                        D3DPTFILTERCAPS_MIPFPOINT           |   \
                                        D3DPTFILTERCAPS_MIPFLINEAR          |   \
                                        D3DPTFILTERCAPS_MAGFPOINT           |   \
                                        D3DPTFILTERCAPS_MAGFLINEAR

/*
 * Texture blending capabilities (dwTextureBlendCaps)
 */
#define CELSIUS_LINECAPS_TEXTUREBLEND   D3DPTBLENDCAPS_DECAL                |   \
                                        D3DPTBLENDCAPS_MODULATE             |   \
                                        D3DPTBLENDCAPS_DECALALPHA           |   \
                                        D3DPTBLENDCAPS_MODULATEALPHA        |   \
                                        D3DPTBLENDCAPS_DECALMASK            |   \
                                        D3DPTBLENDCAPS_MODULATEMASK         |   \
                                        D3DPTBLENDCAPS_COPY                 |   \
                                        D3DPTBLENDCAPS_ADD

/*
 * Texture addressing capabilities (dwTextureAddressCaps)
 */
#define CELSIUS_LINECAPS_TEXTUREADDRESS D3DPTADDRESSCAPS_WRAP               |   \
                                        D3DPTADDRESSCAPS_MIRROR             |   \
                                        D3DPTADDRESSCAPS_CLAMP              |   \
                                        D3DPTADDRESSCAPS_INDEPENDENTUV

/*
 * Maximum stipple dimensions.
 */
#define CELSIUS_LINECAPS_STIPPLEWIDTH    0
#define CELSIUS_LINECAPS_STIPPLEHEIGHT   0

/*
 * Define the triangle capabilities.
 *
 * Miscellaneous capabilities (dwMiscCaps)
 */
#define CELSIUS_TRICAPS_MISC            D3DPMISCCAPS_MASKZ                  |   \
                                        D3DPMISCCAPS_CULLNONE               |   \
                                        D3DPMISCCAPS_CULLCW                 |   \
                                        D3DPMISCCAPS_CULLCCW                |   \
                                        D3DPMISCCAPS_BLENDOP                |   \
                                        D3DPMISCCAPS_COLORWRITEENABLE       |   \
                                        D3DPMISCCAPS_TSSARGTEMP

/*
 * Raster capabilities (dwRasterCaps)
 */
#define CELSIUS_TRICAPS_RASTER          D3DPRASTERCAPS_DITHER                   |   \
                                        D3DPRASTERCAPS_SUBPIXEL                 |   \
                                        D3DPRASTERCAPS_FOGVERTEX                |   \
                                        D3DPRASTERCAPS_FOGTABLE                 |   \
                                        D3DPRASTERCAPS_MIPMAPLODBIAS            |   \
                                        D3DPRASTERCAPS_ZBIAS                    |   \
                                        D3DPRASTERCAPS_FOGRANGE                 |   \
                                        D3DPRASTERCAPS_ANISOTROPY               |   \
                                        D3DPRASTERCAPS_WBUFFER                  |   \
                                        D3DPRASTERCAPS_WFOG                     |   \
                                        D3DPRASTERCAPS_STRETCHBLTMULTISAMPLE    |   \
                                        D3DPRASTERCAPS_ZFOG

/*
 * Z Compare capabilities (dwZCmpCaps)
 */
#define CELSIUS_TRICAPS_ZCMP            D3DPCMPCAPS_NEVER                   |   \
                                        D3DPCMPCAPS_LESS                    |   \
                                        D3DPCMPCAPS_EQUAL                   |   \
                                        D3DPCMPCAPS_LESSEQUAL               |   \
                                        D3DPCMPCAPS_GREATER                 |   \
                                        D3DPCMPCAPS_NOTEQUAL                |   \
                                        D3DPCMPCAPS_GREATEREQUAL            |   \
                                        D3DPCMPCAPS_ALWAYS

/*
 * Source blend capabilities (dwSrcBlendCaps)
 */
#define CELSIUS_TRICAPS_SRCBLEND        D3DPBLENDCAPS_ZERO                  |   \
                                        D3DPBLENDCAPS_ONE                   |   \
                                        D3DPBLENDCAPS_SRCCOLOR              |   \
                                        D3DPBLENDCAPS_INVSRCCOLOR           |   \
                                        D3DPBLENDCAPS_SRCALPHA              |   \
                                        D3DPBLENDCAPS_INVSRCALPHA           |   \
                                        D3DPBLENDCAPS_DESTALPHA             |   \
                                        D3DPBLENDCAPS_INVDESTALPHA          |   \
                                        D3DPBLENDCAPS_DESTCOLOR             |   \
                                        D3DPBLENDCAPS_INVDESTCOLOR          |   \
                                        D3DPBLENDCAPS_SRCALPHASAT           |   \
                                        D3DPBLENDCAPS_BOTHSRCALPHA          |   \
                                        D3DPBLENDCAPS_BOTHINVSRCALPHA

/*
 * Destination blend capabilities (dwDestBlendCaps)
 */
#define CELSIUS_TRICAPS_DESTBLEND       D3DPBLENDCAPS_ZERO                  |   \
                                        D3DPBLENDCAPS_ONE                   |   \
                                        D3DPBLENDCAPS_SRCCOLOR              |   \
                                        D3DPBLENDCAPS_INVSRCCOLOR           |   \
                                        D3DPBLENDCAPS_SRCALPHA              |   \
                                        D3DPBLENDCAPS_INVSRCALPHA           |   \
                                        D3DPBLENDCAPS_DESTALPHA             |   \
                                        D3DPBLENDCAPS_INVDESTALPHA          |   \
                                        D3DPBLENDCAPS_DESTCOLOR             |   \
                                        D3DPBLENDCAPS_INVDESTCOLOR          |   \
                                        D3DPBLENDCAPS_SRCALPHASAT           |   \
                                        D3DPBLENDCAPS_BOTHSRCALPHA          |   \
                                        D3DPBLENDCAPS_BOTHINVSRCALPHA

/*
 * Alpha compare capabilities (dwAlphaCmpCaps)
 */
#define CELSIUS_TRICAPS_ALPHACMP        D3DPCMPCAPS_NEVER                   |   \
                                        D3DPCMPCAPS_LESS                    |   \
                                        D3DPCMPCAPS_EQUAL                   |   \
                                        D3DPCMPCAPS_LESSEQUAL               |   \
                                        D3DPCMPCAPS_GREATER                 |   \
                                        D3DPCMPCAPS_NOTEQUAL                |   \
                                        D3DPCMPCAPS_GREATEREQUAL            |   \
                                        D3DPCMPCAPS_ALWAYS

/*
 * Shading capabilities (dwShadeCaps)
 */
#define CELSIUS_TRICAPS_SHADE           D3DPSHADECAPS_COLORFLATMONO         |   \
                                        D3DPSHADECAPS_COLORFLATRGB          |   \
                                        D3DPSHADECAPS_COLORGOURAUDMONO      |   \
                                        D3DPSHADECAPS_COLORGOURAUDRGB       |   \
                                        D3DPSHADECAPS_SPECULARFLATRGB       |   \
                                        D3DPSHADECAPS_SPECULARGOURAUDRGB    |   \
                                        D3DPSHADECAPS_ALPHAFLATBLEND        |   \
                                        D3DPSHADECAPS_ALPHAGOURAUDBLEND     |   \
                                        D3DPSHADECAPS_FOGFLAT               |   \
                                        D3DPSHADECAPS_FOGGOURAUD

/*
 * Texture capabilities (dwTextureCaps)
 */
#define CELSIUS_TRICAPS_TEXTURE         D3DPTEXTURECAPS_PERSPECTIVE         |   \
                                        D3DPTEXTURECAPS_POW2                |   \
                                        D3DPTEXTURECAPS_ALPHA               |   \
                                        D3DPTEXTURECAPS_TRANSPARENCY        |   \
                                        D3DPTEXTURECAPS_CUBEMAP             |   \
                                        D3DPTEXTURECAPS_CUBEMAP_POW2        |   \
                                        D3DPTEXTURECAPS_MIPMAP              |   \
                                        D3DPTEXTURECAPS_MIPCUBEMAP          |   \
                                        D3DPTEXTURECAPS_PROJECTED           |   \
                                        D3DPTEXTURECAPS_ALPHAPALETTE

/*
 * Texture filtering capabilities (dwTextureFilterCaps)
 */
#define CELSIUS_TRICAPS_TEXTUREFILTER   D3DPTFILTERCAPS_NEAREST             |   \
                                        D3DPTFILTERCAPS_LINEAR              |   \
                                        D3DPTFILTERCAPS_MIPNEAREST          |   \
                                        D3DPTFILTERCAPS_MIPLINEAR           |   \
                                        D3DPTFILTERCAPS_LINEARMIPNEAREST    |   \
                                        D3DPTFILTERCAPS_LINEARMIPLINEAR     |   \
                                        D3DPTFILTERCAPS_MINFPOINT           |   \
                                        D3DPTFILTERCAPS_MINFLINEAR          |   \
                                        D3DPTFILTERCAPS_MIPFPOINT           |   \
                                        D3DPTFILTERCAPS_MIPFLINEAR          |   \
                                        D3DPTFILTERCAPS_MAGFPOINT           |   \
                                        D3DPTFILTERCAPS_MAGFLINEAR          |   \
                                        D3DPTFILTERCAPS_MINFANISOTROPIC     |   \
                                        D3DPTFILTERCAPS_MAGFANISOTROPIC

/*
 * Texture blending capabilities (dwTextureBlendCaps)
 */
#define CELSIUS_TRICAPS_TEXTUREBLEND    D3DPTBLENDCAPS_DECAL                |   \
                                        D3DPTBLENDCAPS_MODULATE             |   \
                                        D3DPTBLENDCAPS_DECALALPHA           |   \
                                        D3DPTBLENDCAPS_MODULATEALPHA        |   \
                                        D3DPTBLENDCAPS_DECALMASK            |   \
                                        D3DPTBLENDCAPS_MODULATEMASK         |   \
                                        D3DPTBLENDCAPS_COPY                 |   \
                                        D3DPTBLENDCAPS_ADD

/*
 * Texture addressing capabilities (dwTextureAddressCaps)
 */
#define CELSIUS_TRICAPS_TEXTUREADDRESS  D3DPTADDRESSCAPS_WRAP               |   \
                                        D3DPTADDRESSCAPS_MIRROR             |   \
                                        D3DPTADDRESSCAPS_CLAMP              |   \
                                        D3DPTADDRESSCAPS_INDEPENDENTUV

/*
 * Maximum stipple dimensions.
 */
#define CELSIUS_TRICAPS_STIPPLEWIDTH    0
#define CELSIUS_TRICAPS_STIPPLEHEIGHT   0

/*
 * Texture Ops
 */
#define CELSIUS_CAPS_TEXTUREOPS  D3DTEXOPCAPS_DISABLE                       |   \
                                 D3DTEXOPCAPS_SELECTARG1                    |   \
                                 D3DTEXOPCAPS_SELECTARG2                    |   \
                                 D3DTEXOPCAPS_MODULATE                      |   \
                                 D3DTEXOPCAPS_MODULATE2X                    |   \
                                 D3DTEXOPCAPS_MODULATE4X                    |   \
                                 D3DTEXOPCAPS_ADD                           |   \
                                 D3DTEXOPCAPS_ADDSIGNED                     |   \
                                 D3DTEXOPCAPS_ADDSIGNED2X                   |   \
                                 D3DTEXOPCAPS_SUBTRACT                      |   \
                                 D3DTEXOPCAPS_ADDSMOOTH                     |   \
                                 D3DTEXOPCAPS_BLENDDIFFUSEALPHA             |   \
                                 D3DTEXOPCAPS_BLENDTEXTUREALPHA             |   \
                                 D3DTEXOPCAPS_BLENDFACTORALPHA              |   \
                                 D3DTEXOPCAPS_BLENDTEXTUREALPHAPM           |   \
                                 D3DTEXOPCAPS_BLENDCURRENTALPHA             |   \
                                 D3DTEXOPCAPS_PREMODULATE                   |   \
                                 D3DTEXOPCAPS_MODULATEALPHA_ADDCOLOR        |   \
                                 D3DTEXOPCAPS_MODULATECOLOR_ADDALPHA        |   \
                                 D3DTEXOPCAPS_MODULATEINVALPHA_ADDCOLOR     |   \
                                 D3DTEXOPCAPS_MODULATEINVCOLOR_ADDALPHA     |   \
                                 D3DTEXOPCAPS_DOTPRODUCT3                   |   \
                                 D3DTEXOPCAPS_MULTIPLYADD                   |   \
                                 D3DTEXOPCAPS_LERP

/*
 * Stencil Ops
 */
#define CELSIUS_CAPS_STENCILOPS  D3DSTENCILCAPS_KEEP                        |   \
                                 D3DSTENCILCAPS_ZERO                        |   \
                                 D3DSTENCILCAPS_REPLACE                     |   \
                                 D3DSTENCILCAPS_INCRSAT                     |   \
                                 D3DSTENCILCAPS_DECRSAT                     |   \
                                 D3DSTENCILCAPS_INVERT                      |   \
                                 D3DSTENCILCAPS_INCR                        |   \
                                 D3DSTENCILCAPS_DECR

/*
 * Vertex Processing Caps
 */
#define CELSIUS_CAPS_VTXPCAPS  D3DVTXPCAPS_TEXGEN                           |   \
                               /*D3DVTXPCAPS_MATERIALSOURCE7                |*/ \
                               D3DVTXPCAPS_VERTEXFOG                        |   \
                               D3DVTXPCAPS_DIRECTIONALLIGHTS                |   \
                               D3DVTXPCAPS_POSITIONALLIGHTS                 |   \
                               D3DVTXPCAPS_LOCALVIEWER

/*
 * Define the render bit depth capabilites.
 */
#define CELSIUS_RENDERBITDEPTHCAPS      (DDBD_16 | DDBD_32)

/*
 * Define the Z buffer bit depth capabilities.
 */
#define CELSIUS_ZBUFFERBITDEPTHCAPS     (DDBD_16 | DDBD_24)

#endif  // NVARCH > 0x010
#endif  // _NVCELSIUSCAPS_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\ddraw\common\inc\nvComp.h ===
/***************************************************************************\
|*                                                                           *|
|*       Copyright 1993-1999 NVIDIA, Corporation.  All rights reserved.      *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.  Users and possessors of this source code are     *|
|*     hereby granted a nonexclusive,  royalty-free copyright license to     *|
|*     use this code in individual and commercial software.                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*       Copyright 1993-1999 NVIDIA, Corporation.  All rights reserved.      *|
|*                                                                           *|
|*     NVIDIA, CORPORATION MAKES NO REPRESENTATION ABOUT THE SUITABILITY     *|
|*     OF  THIS SOURCE  CODE  FOR ANY PURPOSE.  IT IS  PROVIDED  "AS IS"     *|
|*     WITHOUT EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORPOR-     *|
|*     ATION DISCLAIMS ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,     *|
|*     INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY, NONINFRINGE-     *|
|*     MENT,  AND FITNESS  FOR A PARTICULAR PURPOSE.   IN NO EVENT SHALL     *|
|*     NVIDIA, CORPORATION  BE LIABLE FOR ANY SPECIAL,  INDIRECT,  INCI-     *|
|*     DENTAL, OR CONSEQUENTIAL DAMAGES,  OR ANY DAMAGES  WHATSOEVER RE-     *|
|*     SULTING FROM LOSS OF USE,  DATA OR PROFITS,  WHETHER IN AN ACTION     *|
|*     OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,  ARISING OUT OF     *|
|*     OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOURCE CODE.     *|
|*                                                                           *|
|*     U.S. Government  End  Users.   This source code  is a "commercial     *|
|*     item,"  as that  term is  defined at  48 C.F.R. 2.101 (OCT 1995),     *|
|*     consisting  of "commercial  computer  software"  and  "commercial     *|
|*     computer  software  documentation,"  as such  terms  are  used in     *|
|*     48 C.F.R. 12.212 (SEPT 1995)  and is provided to the U.S. Govern-     *|
|*     ment only as  a commercial end item.   Consistent with  48 C.F.R.     *|
|*     12.212 and  48 C.F.R. 227.7202-1 through  227.7202-4 (JUNE 1995),     *|
|*     all U.S. Government End Users  acquire the source code  with only     *|
|*     those rights set forth herein.                                        *|
|*                                                                           *|
 \***************************************************************************/
#ifndef _nvComp_h
#define _nvComp_h

#ifdef __cplusplus
extern "C" {
#endif

// note: the two functions below CANNOT be used concurrently

// dx5/dx6 class
void __stdcall nvTriangleDispatch (NV_INNERLOOP_ARGLIST);
void __stdcall nvDX5TriangleSetup (PNVD3DCONTEXT, DWORD, LPWORD, LPBYTE);
void __stdcall nvDX6TriangleSetup (PNVD3DCONTEXT, DWORD, LPWORD, LPBYTE);

// fast mem copy
DWORD nvBuildCustomCopyRoutine (DWORD dwCount);
DWORD nvBuildCustomCopyRoutineMisAligned ();

#ifdef __cplusplus
}
#endif

#endif // _nvComp_h
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\ddraw\common\inc\nvClear.h ===
/*
 * (C) Copyright NVIDIA Corporation Inc., 1996,1997. All rights reserved.
 */
/********************************* Direct 3D *******************************\
*                                                                           *
* Module: NVCLEAR.H                                                         *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*       Craig Duttweiler    (bertrem)       07Jul99      created            *
*                                                                           *
\***************************************************************************/

#ifndef _NVCLEAR_H_
#define _NVCLEAR_H_

DWORD __stdcall nvClear  (LPD3DHAL_CLEARDATA);
DWORD __stdcall nvClear2 (LPD3DHAL_CLEAR2DATA pc2d);
void  nvCTDecodeBuffer   (CNvObject *pNvObj,DWORD dwAddr,DWORD dwBPP,
                          DWORD dwPitch,DWORD dwWidth,DWORD dwHeight);

#endif // _NVCLEAR_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\ddraw\common\inc\nvdbgsurf.h ===
// **************************************************************************
//
//       Copyright 1993-1999 NVIDIA, Corporation.  All rights reserved.
//
//     NOTICE TO USER:   The source code  is copyrighted under  U.S. and
//     international laws.  Users and possessors of this source code are
//     hereby granted a nonexclusive,  royalty-free copyright license to
//     use this code in individual and commercial software.
//
//     Any use of this source code must include,  in the user documenta-
//     tion and  internal comments to the code,  notices to the end user
//     as follows:
//
//       Copyright 1993-1999 NVIDIA, Corporation.  All rights reserved.
//
//     NVIDIA, CORPORATION MAKES NO REPRESENTATION ABOUT THE SUITABILITY
//     OF  THIS SOURCE  CODE  FOR ANY PURPOSE.  IT IS  PROVIDED  "AS IS"
//     WITHOUT EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORPOR-
//     ATION DISCLAIMS ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,
//     INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY, NONINFRINGE-
//     MENT,  AND FITNESS  FOR A PARTICULAR PURPOSE.   IN NO EVENT SHALL
//     NVIDIA, CORPORATION  BE LIABLE FOR ANY SPECIAL,  INDIRECT,  INCI-
//     DENTAL, OR CONSEQUENTIAL DAMAGES,  OR ANY DAMAGES  WHATSOEVER RE-
//     SULTING FROM LOSS OF USE,  DATA OR PROFITS,  WHETHER IN AN ACTION
//     OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,  ARISING OUT OF
//     OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOURCE CODE.
//
//     U.S. Government  End  Users.   This source code  is a "commercial
//     item,"  as that  term is  defined at  48 C.F.R. 2.101 (OCT 1995),
//     consisting  of "commercial  computer  software"  and  "commercial
//     computer  software  documentation,"  as such  terms  are  used in
//     48 C.F.R. 12.212 (SEPT 1995)  and is provided to the U.S. Govern-
//     ment only as  a commercial end item.   Consistent with  48 C.F.R.
//     12.212 and  48 C.F.R. 227.7202-1 through  227.7202-4 (JUNE 1995),
//     all U.S. Government End Users  acquire the source code  with only
//     those rights set forth herein.
//
// ********************************* Direct 3D ******************************
//
//  Module: nvDbgSurf.cpp
//      Debug surface placement
//
// **************************************************************************
//
//  History:
//      Scott Kephart           01Dec00         NV20 development
//
// **************************************************************************


#ifdef DEBUG_SURFACE_PLACEMENT
#define CSD_MAX_BACK_BUFFERS 2
#define CSD_MAX_SURFACES 8

enum SurfDbgType {
FrontBuffer=0,
BackBuffer,
Z_Buffer,
AA_RenderTarget,
AA_Z_Buffer
};

class CSurfDebugOrder {
public:
    SurfDbgType     SurfaceType;
    CSimpleSurface  *pSurf;
    CSimpleSurface  Surf;
    bool Deleted;
    bool ReCreated;
};

#define ZTAG_MAX    1024

class CKelvinFBRegs {
public:
    DWORD nv_pfb_cfg0;
    DWORD nv_pfb_cfg1;
    DWORD nv_pfb_cstatus;
    DWORD nv_pfb_timing0;
    DWORD nv_pfb_timing1;
    DWORD nv_pfb_timing2;
    DWORD nv_pfb_tile[8];
    DWORD nv_pfb_tlimit[8];
    DWORD nv_pfb_tsize[8];
    DWORD nv_pfb_tstatus[8];
    DWORD nv_pfb_zcomp[8];
    DWORD nv_pfb_zcomp_max_tag;
    DWORD nv_pfb_zcomp_offset;
    DWORD nv_ztag0[ZTAG_MAX];
    DWORD nv_ztag1[ZTAG_MAX];
    DWORD nv_ztag2[ZTAG_MAX];
    DWORD nv_ztag3[ZTAG_MAX];
    
};

//---------------------------------------------------------------------------
class CSurfaceDebug 
{
private:
    int             FileNum;
    int             surf_cnt;
    BYTE           *pHWRegisters;
    CSurfDebugOrder Surfaces[CSD_MAX_SURFACES];
    bool            bInitialized;
    bool            bValidated;
    bool            bFileOpen;
    HANDLE          CSDFile;
    char outbuf[1024];
public:
    CSurfaceDebug() {};
    ~CSurfaceDebug() {};
    void Init();
    void Destroy();
    void DumpSurfaceInfo();
    void DumpCSimpleSurface(CSimpleSurface *p);
    void ValidateSurfacePlacement();
    void SetFrontBuffer(CSimpleSurface *pBuff);
    void SetBackBuffer(CSimpleSurface *pBuff);
    void SetZBuffer(CSimpleSurface *pBuff);
    void ReCreateZBuffer(CSimpleSurface *pBuff);
    void SetAARenderBuffer(CSimpleSurface *pBuff);
    void SetAAZBuffer(CSimpleSurface *pBuff);
    void DeleteSurface(CSimpleSurface *pBuff);
    void CaptureFBRegs();
private:
    void REG_WR32(DWORD addr, DWORD data);
    void REG_RD32(DWORD addr, DWORD &data);
    void RDI_REG_WR32(DWORD select, DWORD addr, DWORD data);
    void RDI_REG_RD32(DWORD select, DWORD addr, DWORD &data);
};
#endif //DEBUG_SURFACE_PLACEMENT
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\ddraw\common\inc\nvContext.h ===
/***************************************************************************\
|*                                                                           *|
|*       Copyright 1993-1999 NVIDIA, Corporation.  All rights reserved.      *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.  Users and possessors of this source code are     *|
|*     hereby granted a nonexclusive,  royalty-free copyright license to     *|
|*     use this code in individual and commercial software.                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*       Copyright 1993-1999 NVIDIA, Corporation.  All rights reserved.      *|
|*                                                                           *|
|*     NVIDIA, CORPORATION MAKES NO REPRESENTATION ABOUT THE SUITABILITY     *|
|*     OF  THIS SOURCE  CODE  FOR ANY PURPOSE.  IT IS  PROVIDED  "AS IS"     *|
|*     WITHOUT EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORPOR-     *|
|*     ATION DISCLAIMS ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,     *|
|*     INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY, NONINFRINGE-     *|
|*     MENT,  AND FITNESS  FOR A PARTICULAR PURPOSE.   IN NO EVENT SHALL     *|
|*     NVIDIA, CORPORATION  BE LIABLE FOR ANY SPECIAL,  INDIRECT,  INCI-     *|
|*     DENTAL, OR CONSEQUENTIAL DAMAGES,  OR ANY DAMAGES  WHATSOEVER RE-     *|
|*     SULTING FROM LOSS OF USE,  DATA OR PROFITS,  WHETHER IN AN ACTION     *|
|*     OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,  ARISING OUT OF     *|
|*     OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOURCE CODE.     *|
|*                                                                           *|
|*     U.S. Government  End  Users.   This source code  is a "commercial     *|
|*     item,"  as that  term is  defined at  48 C.F.R. 2.101 (OCT 1995),     *|
|*     consisting  of "commercial  computer  software"  and  "commercial     *|
|*     computer  software  documentation,"  as such  terms  are  used in     *|
|*     48 C.F.R. 12.212 (SEPT 1995)  and is provided to the U.S. Govern-     *|
|*     ment only as  a commercial end item.   Consistent with  48 C.F.R.     *|
|*     12.212 and  48 C.F.R. 227.7202-1 through  227.7202-4 (JUNE 1995),     *|
|*     all U.S. Government End Users  acquire the source code  with only     *|
|*     those rights set forth herein.                                        *|
|*                                                                           *|
 \***************************************************************************/
#ifndef _nvContext_h
#define _nvContext_h

#ifndef __cplusplus
#error This file requires a C++ compiler
#endif

extern "C++"
{

//---------------------------------------------------------------------------
// helpers

__forceinline DWORD swapRGB (DWORD dw) { return (dw & 0xff00ff00) | ((dw & 0x00ff0000) >> 16) | ((dw & 0x000000ff) << 16); }

//---------------------------------------------------------------------------
// nvidia mem copy

void nvMemCopyReset (void);
void nvMemCopy      (DWORD dwDest,DWORD dwSrc,DWORD dwCount);
__forceinline void nvMemCopy (void *pDest,void *pSrc,DWORD dwCount) { nvMemCopy(DWORD(pDest),DWORD(pSrc),dwCount); }

//---------------------------------------------------------------------------
// flip history

#define FLIP_HISTORY_SIZE 16  // should be power of 2
#define FLIP_HISTORY_MASK (FLIP_HISTORY_SIZE - 1)

typedef struct {
    DWORD surfacesFrom[FLIP_HISTORY_SIZE];  // circular buffer of surfaces we've flipped FROM
#ifdef CHECK_FLIP_TO
    DWORD surfacesTo[FLIP_HISTORY_SIZE];    // circular buffer of surfaces we've flipped TO
#endif
    DWORD dwIndex;                          // current buffer element
} FLIPHISTORY;

//---------------------------------------------------------------------------
// registry data

typedef struct _D3D_REGISTRYDATA
{
    // bank
    DWORD regD3DEnableBits1;
    DWORD regAntiAliasQuality;          // rel5 and later
    DWORD regColorkeyRef;
    DWORD regMipMapDitherMode;
    DWORD regTexelAlignment;
    DWORD regValidateZMethod;
    DWORD regVSyncMode;
    DWORD regW16Format;
    // bank
    DWORD regW32Format;
    DWORD regAGPTexCutOff;
    DWORD regD3DContextMax;
    DWORD regD3DTextureMax;
    DWORD regLODBiasAdjust;
    DWORD regMinVideoTextureSize;
    DWORD regPCITexHeapSize;
    DWORD regPreRenderLimit;
    // bank
    DWORD regPushBufferSizeMax;
    float regfWScale16;
    float regfWScale24;
    DWORD regAntiAliasDynamicMSpF;
    float regfZBias;
    DWORD regTextureManageStrategy;
    DWORD regAAReadCompatibilityFile;
    DWORD regDebugLevel;
    // bank
    DWORD regCaptureConfig;
    DWORD regCaptureEnable;
    DWORD regCapturePlayFilenum;
    DWORD regCaptureRecordFilenum;
    DWORD regAnisotropicLevel;
    DWORD regAACompatibilityBits;
#ifdef TEXFORMAT_CRD
    DWORD regSurfaceFormatsDX7;
    DWORD regSurfaceFormatsDX8;
#else   // !TEXFORMAT_CRD
    DWORD dwPad01[2];
#endif  // !TEXFORMAT_CRD
    // bank
    char  regszCapturePlayFilename[D3D_REG_STRING_LENGTH];
    char  regszCapturePlayPath[D3D_REG_STRING_LENGTH];
    char  regszCaptureRecordFilename[D3D_REG_STRING_LENGTH];
    char  regszCaptureRecordPath[D3D_REG_STRING_LENGTH];
} NVD3D_REGISTRYDATA;

//---------------------------------------------------------------------------
// device caps

typedef struct _NVD3D_DEVCAPS
{
#ifdef RM20
    // this padding is because the portion of VPE that lives in the RM is not quite
    // ready to switch direct7 yet
    DWORD                   paddingForVPE[272];
#else
    D3DDEVICEDESC_V1        dd1Caps;
    D3DHAL_D3DEXTENDEDCAPS  d3dExtCaps;
#endif
    D3DCAPS8                dwD3DCap8;
} NVD3D_DEVCAPS;

//---------------------------------------------------------------------------
// texture heap stuff

typedef struct _NVD3D_TEXTUREHEAPDATA
{
    DWORD dwHandle;
    DWORD dwBaseRaw;        // unaligned base address
    DWORD dwBase;           // aligned base address
    DWORD dwAllocHead;
    DWORD dwAllocTail;
    DWORD dwFreeHead;
    DWORD dwFreeTail;
    DWORD dwSize;
    // bank
    DWORD dwSizeMax;
    DWORD dwLimit;
    DWORD dwLimitMax;
    DWORD dwAllocSize;
    DWORD dwFreeSize;
    DWORD _pad[3];
} NVD3D_TEXTUREHEAPDATA;

//---------------------------------------------------------------------------
// forward declarations of things defined elsewhere

class CNvObject;
class CTexture;
class CPushBuffer;
class CVertexShader;
class CVertexBuffer;
class CReferenceCount;

#ifdef KPFS
#if (NVARCH >= 0x020)
class CKelvinProgramMan;
#endif
#endif

#ifdef NV_PROFILE_DP2OPS
class CBenchmark;
#endif

template <int cdwLogMax> class CReferenceCountMap;

//---------------------------------------------------------------------------
//
// driver context declaration
//  every instance here must preserve 32-byte alignment
//

class CDriverContext : public _GLOBALDATA
{
public:
    const enum {
        DC_ENABLESTATUS_DISABLED       = 0,   // push buffer, channels, and objects not allocated
        DC_ENABLESTATUS_ENABLED        = 1,   // push buffer, channels, and objects are allocated
        DC_ENABLESTATUS_PENDINGDISABLE = 2    // disable required at next opportunity
    };

public:
// bank
    BYTE                     pbScratchBuffer8192[8192]; // DO NOT MOVE OR RESIZE
// bank
    DWORD                    dwEnableStatus;
    DWORD                    dwEnablePixelDepth;
    DWORD                    dwAGPHeapList;
    DWORD                    dwAGPHeapListMax;
    DWORD                    dwAGPHashTableHead;
    DWORD                    dwAGPHashTable;
    DWORD                    dwAGPHashTableMax;
    BOOL                     bAGPHeapValid;
// bank
    DWORD                    dwFVFCachedType;
    DWORD                    dwCurrentBlit;             // used to count present blits to limit the number of frames we get ahead
    DWORD                    dwCurrentFlip[4];          // array of flip counts, one element per head
    DWORD                    dwCompletedFlip[4];
    BOOL                     bD3DViewVector;

#if (NVARCH >= 0x020)

#ifdef KELVIN_SEMAPHORES
    CPushBuffer              nvPusherDAC;
    CSemaphoreManager        nvSemaphoreManager;
    CFlipper                 nvFlipper;
#endif

#ifdef KPFS
    CKelvinProgramMan        nvKelvinPM;
#endif

#ifdef LPC_OPT
    DWORD dwLastDP2;
    DWORD dwThisDP2;
#endif    

#endif
    CDefaultVB               defaultVB;
    CDefaultVB               defaultSysVB;              // used to hold legacy user mode vertex data (can't this just be a CVertexBuffer?)
    CReferenceCountMap<5>   *pBlitTracker;
    FLIPHISTORY              flipHistory;

    NVD3D_REGISTRYDATA       nvD3DRegistryData;
    NVD3D_DEVCAPS            nvD3DDevCaps;

#if (NVARCH >= 0x04)
    NVD3D_TEXTUREHEAPDATA    nvD3DTexHeapData;

    D3DHAL_GLOBALDRIVERDATA  D3DGlobalDriverData;
    DWORD                    dwD3DContextCount;
    DWORD                    dwD3DTextureCount;
    DWORD                    dwAAContextCount;
    PNVD3DCONTEXT            dwContextListHead;
    PNVD3DCONTEXT            dwPreapprovedContextListHead;
    DWORD                    dwLastHWContext;           // the last d3d context for which celsius/kelvin was programmed
    DWORD                    dwOutOfContextCelsiusDirtyFlags;
#endif  // (NVARCH >= 0x04)

#ifdef NV_PROFILE_DP2OPS
    CBenchmark *pBenchmark;
#endif

    // nV logo stuff
    CNvObject               *pLogoObject;
    CTexture                *pLogoTexture;
    CVertexBuffer           *pLogoVertexBuffer;
    CVertexShader           *pLogoVertexShader;

    CTexture                *pDefaultTexture;           // Default texture rendering object.
    CTexture                *pClipPlaneTexture;         // Texture used for user clip planes

    // memory for unaligned texture access spoof
    DWORD                    dwSpareTextureAddr[2];
    DWORD                    dwSpareTextureOffset[2];

#ifdef TEXFORMAT_CRD
    // surface formats for < DX8
    DWORD                    dwSurfaceDescriptorCount;
    DDSURFACEDESC           *pSurfaceDescriptors;

    // surface formats for >= DX8
    DWORD                    dwPixelFormatCount;
    DDPIXELFORMAT           *pPixelFormats;
#endif  // TEXFORMAT_CRD

    // methods
public:
    __forceinline LPDDRAWI_DIRECTDRAW_GBL getDDGlobal (void) const { return (LPDDRAWI_DIRECTDRAW_GBL)pDriverData->dwDDGlobal; }

public:
    void create  (void);
    void destroy (void);

    // redefine 'new' for this class so that it zeroes out memory before returning it.
    // this is required because the memset can't be included in CDriverContext::CDriverContext;
    // at that point, the constructors for classes included in CDriverContext have already
    // been automatically called and we don't want to stomp on them.
    void * operator new (size_t sz)     {   void *p = new char[sz];
                                            if(p){memset(p,0,sz);}
                                            return p;   }

    // contruction
    CDriverContext  (void) {
        memset(&dwSpareTextureAddr[0],0xff,sizeof(dwSpareTextureAddr)); // Init to all 0xff (invalid addresses)
    };
    ~CDriverContext (void) {};
};

// this must be a macro so that we access the local pDriverData, if one exists, rather than the global
#define getDC() ((CDriverContext*)pDriverData)

}   // extern c++

#endif // _nvContext_h
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\ddraw\common\inc\nvDefVB.h ===
// **************************************************************************
//
//       Copyright 1993-1999 NVIDIA, Corporation.  All rights reserved.
//
//     NOTICE TO USER:   The source code  is copyrighted under  U.S. and
//     international laws.  Users and possessors of this source code are
//     hereby granted a nonexclusive,  royalty-free copyright license to
//     use this code in individual and commercial software.
//
//     Any use of this source code must include,  in the user documenta-
//     tion and  internal comments to the code,  notices to the end user
//     as follows:
//
//       Copyright 1993-1999 NVIDIA, Corporation.  All rights reserved.
//
//     NVIDIA, CORPORATION MAKES NO REPRESENTATION ABOUT THE SUITABILITY
//     OF  THIS SOURCE  CODE  FOR ANY PURPOSE.  IT IS  PROVIDED  "AS IS"
//     WITHOUT EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORPOR-
//     ATION DISCLAIMS ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,
//     INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY, NONINFRINGE-
//     MENT,  AND FITNESS  FOR A PARTICULAR PURPOSE.   IN NO EVENT SHALL
//     NVIDIA, CORPORATION  BE LIABLE FOR ANY SPECIAL,  INDIRECT,  INCI-
//     DENTAL, OR CONSEQUENTIAL DAMAGES,  OR ANY DAMAGES  WHATSOEVER RE-
//     SULTING FROM LOSS OF USE,  DATA OR PROFITS,  WHETHER IN AN ACTION
//     OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,  ARISING OUT OF
//     OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOURCE CODE.
//
//     U.S. Government  End  Users.   This source code  is a "commercial
//     item,"  as that  term is  defined at  48 C.F.R. 2.101 (OCT 1995),
//     consisting  of "commercial  computer  software"  and  "commercial
//     computer  software  documentation,"  as such  terms  are  used in
//     48 C.F.R. 12.212 (SEPT 1995)  and is provided to the U.S. Govern-
//     ment only as  a commercial end item.   Consistent with  48 C.F.R.
//     12.212 and  48 C.F.R. 227.7202-1 through  227.7202-4 (JUNE 1995),
//     all U.S. Government End Users  acquire the source code  with only
//     those rights set forth herein.
//
// ********************************* Direct 3D ******************************
//
//  Module: nvDefVB.h
//      default vertex buffer header file
//
// **************************************************************************
//
//  History:
//      Craig Duttweiler        15Jun00         creation
//
// **************************************************************************

#ifndef __NVDEFVB_H
#define __NVDEFVB_H

// forward declarations

class CVertexBuffer;
template <int cdwLogMax> class CReferenceCountMap;

//---------------------------------------------------------------------------

class CDefaultVB
{

private:
    CVertexBuffer           *m_pVertexBuffer;
    CReferenceCountMap<10>  *m_pRefCountMap;

public:
    DWORD                    m_dwCurrentOffset;
    DWORD                    m_dwTotalVerticesSincePut;

public:
    // inline functions
    inline CVertexBuffer* getVB (void)      {   return (m_pVertexBuffer);   }

    // prototypes
    BOOL  create             (DWORD dwHeap, DWORD dwSize);
    BOOL  destroy            (void);
    DWORD getHeap            (void);
    DWORD getAddress         (void);
    DWORD getSize            (void);
    DWORD getOffset          (void);
    DWORD getCachedOffset    (void);
    void  updateOffset       (DWORD dwOffset);
    void  updateMap          (void);
    DWORD waitForSpace       (int iSize, BOOL bWait);

private:
    DWORD dispatchWrapAround (int iVBOffset);

    // construction
public:
    CDefaultVB  (void);
    ~CDefaultVB (void);

    // friends
    friend void nvCelsiusILCompile_computeIndexAndOffset (DWORD dwVBStride, DWORD dwLogStride);

};

#endif  // __NVDEFVB_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\ddraw\common\inc\NVD3DMAC.H ===
// **************************************************************************
//
//       Copyright 1993-1999 NVIDIA, Corporation.  All rights reserved.
//
//     NOTICE TO USER:   The source code  is copyrighted under  U.S. and
//     international laws.  Users and possessors of this source code are
//     hereby granted a nonexclusive,  royalty-free copyright license to
//     use this code in individual and commercial software.
//
//     Any use of this source code must include,  in the user documenta-
//     tion and  internal comments to the code,  notices to the end user
//     as follows:
//
//       Copyright 1993-1999 NVIDIA, Corporation.  All rights reserved.
//
//     NVIDIA, CORPORATION MAKES NO REPRESENTATION ABOUT THE SUITABILITY
//     OF  THIS SOURCE  CODE  FOR ANY PURPOSE.  IT IS  PROVIDED  "AS IS"
//     WITHOUT EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORPOR-
//     ATION DISCLAIMS ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,
//     INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY, NONINFRINGE-
//     MENT,  AND FITNESS  FOR A PARTICULAR PURPOSE.   IN NO EVENT SHALL
//     NVIDIA, CORPORATION  BE LIABLE FOR ANY SPECIAL,  INDIRECT,  INCI-
//     DENTAL, OR CONSEQUENTIAL DAMAGES,  OR ANY DAMAGES  WHATSOEVER RE-
//     SULTING FROM LOSS OF USE,  DATA OR PROFITS,  WHETHER IN AN ACTION
//     OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,  ARISING OUT OF
//     OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOURCE CODE.
//
//     U.S. Government  End  Users.   This source code  is a "commercial
//     item,"  as that  term is  defined at  48 C.F.R. 2.101 (OCT 1995),
//     consisting  of "commercial  computer  software"  and  "commercial
//     computer  software  documentation,"  as such  terms  are  used in
//     48 C.F.R. 12.212 (SEPT 1995)  and is provided to the U.S. Govern-
//     ment only as  a commercial end item.   Consistent with  48 C.F.R.
//     12.212 and  48 C.F.R. 227.7202-1 through  227.7202-4 (JUNE 1995),
//     all U.S. Government End Users  acquire the source code  with only
//     those rights set forth herein.
//
// **************************************************************************
//
//  Module: nvD3DMac.h
//      Define various macros used in the D3D driver.
//
//      THESE SHOULD BE STAND-ALONE MACROS. THERE SHOULD BE NO
//      DEPENDENCIES ON OTHER NV HEADER FILES!!
//
// **************************************************************************
//
//  History:
//      Charles Inman (chasi)       01/31/98 - Created.
//
// **************************************************************************

#ifndef _NVD3DMAC_H_
#define _NVD3DMAC_H_

#ifdef __cplusplus
extern "C" {
#endif

//---------------------------------------------------------------------------

// swap two 4-byte values using temporary storage
#define NV_SWAP_1(a,b)                      \
{                                           \
    DWORD c;                                \
    c                = *(DWORD *)(&(a));    \
    *(DWORD *)(&(a)) = *(DWORD *)(&(b));    \
    *(DWORD *)(&(b)) = c;                   \
}

// swap two 4-byte values using XORs
#define NV_SWAP_2(a,b)                      \
{                                           \
    *(DWORD *)(&(a)) ^= *(DWORD *)(&(b));   \
    *(DWORD *)(&(b)) ^= *(DWORD *)(&(a));   \
    *(DWORD *)(&(a)) ^= *(DWORD *)(&(b));   \
}

//---------------------------------------------------------------------------

// Some FP macros used in table fog. Thanks Jim!
#define FP_INV(r,p)                                     \
{                                                       \
    int _i = 2 * FP_ONE_BITS - *(int *)&(p);            \
    r = FLOAT_FROM_DWORD(_i);                           \
    r = r * (2.0f - (p) * r);                           \
}
#define FP_EXP(e,p)                                     \
{                                                       \
    int _i;                                             \
    e = -1.44269504f * (float)0x00800000 * (p);         \
    _i = (int)e + 0x3F800000;                           \
    e = FLOAT_FROM_DWORD(_i);                           \
}
#define FP_NORM_TO_BYTE(i,p)                            \
{                                                       \
    float _n = (p) + 1.0f;                              \
    (i) = *(int *)&_n;                                  \
    if ((i) >= 0x40000000)     (i) = 0xFF;              \
    else if ((i) <=0x3F800000) (i) = 0;                 \
    else (i) = ((i) >> 15) & 0xFF;                      \
}
#define FP_NORM_TO_BIT24(i,p)                           \
{                                                       \
    float _n = (p) + 1.0f;                              \
    (i) = *(int *)&_n;                                  \
    if ((i) >= 0x40000000)     (i) = 0xFF000000;        \
    else if ((i) <=0x3F800000) (i) = 0;                 \
    else (i) = ((i) << 9) & 0xFF000000;                 \
}

//---------------------------------------------------------------------------

// Fast floating point operations.

#define nvFloor(fp,fretval)                             \
{                                                       \
    int fpbits;                                         \
    int expo;                                           \
                                                        \
    if (fp < 0.0f) fp -= 0.9999999f;                    \
    fpbits = *(int *)&fp;                               \
    if ((fpbits >= 0) && (fpbits < 0x3F800000)) {       \
        fretval = 0.0f;                                 \
    }                                                   \
    else {                                              \
        expo = 150 - ((fpbits >> 23) & 0xFF);           \
        if (expo < 1) {                                 \
            fretval = fp;                               \
        }                                               \
        else {                                          \
            fpbits &= 0xFFFFFFFF << expo;               \
            fretval = FLOAT_FROM_DWORD(fpbits);         \
        }                                               \
    }                                                   \
}

//---------------------------------------------------------------------------

// D3D state macros.

#define IS_OVERRIDE(type)       ((DWORD)(type) > D3DSTATE_OVERRIDE_BIAS)
#define GET_OVERRIDE(type)      ((DWORD)(type) - D3DSTATE_OVERRIDE_BIAS)

#define STATESET_MASK(set, state)                                           \
        (set).bits[((state) - 1) >> DWORD_SHIFT]

#define STATESET_BIT(state)     (1 << (((state) - 1) & (DWORD_BITS - 1)))

#define STATESET_ISSET(set, state)                                          \
        STATESET_MASK(set, state) & STATESET_BIT(state)

#define STATESET_SET(set, state)                                            \
        STATESET_MASK(set, state) |= STATESET_BIT(state)

#define STATESET_CLEAR(set, state)                                          \
        STATESET_MASK(set, state) &= ~STATESET_BIT(state)

#define STATESET_INIT(set)      memset(&(set), 0, sizeof(set))

//---------------------------------------------------------------------------

// Memory management macros.

/* this is legacy (win3.1)

#define GlobalUnlockPtr32(lp)                                               \
        GlobalUnlock(GlobalHandle((LPCVOID)lp))

#define GlobalAllocPtr32(flags, cb)                                         \
        (GlobalLock(GlobalAlloc((flags), (cb))))

#define GlobalFreePtr32(lp)                                                 \
        (GlobalUnlockPtr32(lp), (BOOL)GlobalFree(GlobalHandle((LPCVOID)lp)))
*/

#define GlobalUnlockPtr32(lp)                                               \
        ((LPCVOID)lp)

#define GlobalAllocPtr32(flags, cb)                                         \
        (GlobalAlloc((flags), (cb)))

#define GlobalFreePtr32(lp)                                                 \
        ((BOOL)GlobalFree((LPCVOID)lp))


//---------------------------------------------------------------------------

// fog mode macros
// For NV4, table and vertex fog are handled identically, so reduce the two
// renderstates to one value. If both are something other than FOG_NONE,
// table fog wins
#define NV_FOG_MODE \
    (pContext->dwRenderState[D3DRENDERSTATE_FOGENABLE] ?                    \
        (NV_VERTEX_TRANSFORMED(pContext->pCurrentVShader) ?                \
            pContext->dwRenderState[D3DRENDERSTATE_FOGTABLEMODE] :          \
            (pContext->dwRenderState[D3DRENDERSTATE_FOGTABLEMODE] ?         \
                pContext->dwRenderState[D3DRENDERSTATE_FOGTABLEMODE] :      \
                pContext->dwRenderState[D3DRENDERSTATE_FOGVERTEXMODE])) :   \
        D3DFOG_NONE)

//---------------------------------------------------------------------------

// cull macro
#define IF_NOT_CULLED_BEGIN(v0,v1,v2,cv) {             \
    DWORD _sx0  = (DWORD)(v0) + 0;                     \
    DWORD _sy0  = (DWORD)(v0) + 4;                     \
    DWORD _sx1  = (DWORD)(v1) + 0;                     \
    DWORD _sy1  = (DWORD)(v1) + 4;                     \
    DWORD _sx2  = (DWORD)(v2) + 0;                     \
    DWORD _sy2  = (DWORD)(v2) + 4;                     \
    float _dx10 = *(float*)_sx1 - *(float*)_sx0;       \
    float _dy10 = *(float*)_sy1 - *(float*)_sy0;       \
    float _dx20 = *(float*)_sx2 - *(float*)_sx0;       \
    float _dy20 = *(float*)_sy2 - *(float*)_sy0;       \
           cv   = _dx10*_dy20  - _dx20*_dy10;          \
    if (((*(DWORD*)&cv) ^ dwCullMask1) & dwCullMask2) {

#define IF_NOT_CULLED_END } }

//---------------------------------------------------------------------------

#define NV_EVAL_CYLINDRICAL_WRAP(pContext, dwTCIndex, bWrapU, bWrapV, bWrapP, bWrapQ)                                   \
{                                                                                                                       \
    BOOL bIndexOK; DWORD dwStream;                                                                                      \
    if (pContext->pCurrentVShader->hasProgram()) {                                                                      \
        bIndexOK = (dwTCIndex < 8) ? TRUE : FALSE;                                                                      \
    }                                                                                                                   \
    else {                                                                                                              \
        dwStream = pContext->pCurrentVShader->getVAStream (defaultInputRegMap[D3DVSDE_TEXCOORD0+dwTCIndex]);            \
        bIndexOK = ((dwStream != CVertexShader::VA_STREAM_NONE) && (pContext->ppDX8Streams[dwStream])) ? TRUE : FALSE;  \
    }                                                                                                                   \
    if (bIndexOK) {                                                                                                     \
        bWrapU = ((pContext->dwRenderState[D3DRENDERSTATE_WRAPU]) ||                                                    \
                  (pContext->dwRenderState[D3DRENDERSTATE_WRAP0 + dwTCIndex] & D3DWRAPCOORD_0)) ? TRUE : FALSE;         \
        bWrapV = ((pContext->dwRenderState[D3DRENDERSTATE_WRAPV]) ||                                                    \
                  (pContext->dwRenderState[D3DRENDERSTATE_WRAP0 + dwTCIndex] & D3DWRAPCOORD_1)) ? TRUE : FALSE;         \
        bWrapP = ((pContext->dwRenderState[D3DRENDERSTATE_WRAP0 + dwTCIndex] & D3DWRAPCOORD_2)) ? TRUE : FALSE;         \
        bWrapQ = ((pContext->dwRenderState[D3DRENDERSTATE_WRAP0 + dwTCIndex] & D3DWRAPCOORD_3)) ? TRUE : FALSE;         \
    }                                                                                                                   \
    else {                                                                                                              \
        bWrapU = bWrapV = bWrapP = bWrapQ = FALSE;                                                                      \
    }                                                                                                                   \
}

//---------------------------------------------------------------------------

#define NEXTINSTRUCTION(ptr, type, num, extrabytes)                             \
    ptr = (LPD3DHAL_DP2COMMAND)((LPBYTE)ptr + sizeof(D3DHAL_DP2COMMAND) +       \
                                ((num) * sizeof(type)) + (extrabytes))

#define GET_FVF_POINTER(ptr, lpvert, mask, offset, index, stride)               \
    (ptr) = (BYTE *) ((((DWORD)(lpvert) + ((index) * (stride))) & (DWORD)(mask)) + (offset));

//---------------------------------------------------------------------------

/*
 * Need to make sure that an unfriendly mode switch didn't sneak and not cause
 * us to get re-enabled properly.
 */
#define DOS_FULLSCREEN_CHECK(pp)

/*
 * Set up all the current context state per call.  This should be as efficient as
 * possible as it is executed for every rendering entrypoint.
 * NB - we can't check pContext->dwRTHandle since 0 is actually valid for DX5 apps running on dx7
 */
#define NV_SET_CONTEXT(pContext,pp)                                             \
{                                                                               \
    pContext = (PNVD3DCONTEXT)((pp)->dwhContext);                               \
    if (!pContext) {                                                            \
        DPF("D3D: - Bad Context");                                              \
        (pp)->ddrval = D3DHAL_CONTEXT_BAD;                                      \
        dbgTracePop();                                                          \
        return (DDHAL_DRIVER_HANDLED);                                          \
    }                                                                           \
}

//---------------------------------------------------------------------------

/*
 * Some cool macros for use during texture swizzling.
 */
// the goal here is to interleave bits (pushing all higher order
// bits to the left as we go) until the texture width exceeds the
// height. at that point, we treat square chunks of the texture as
// swizzled 'blocks' that are indexed linearly by the higher order
// bits above those that are interleaved. (thus, we freeze the value
// of 'shift' when bit == h)

#define U_INTERLEAVE(u,uu,w,h)                              \
{                                                           \
    int bit,shift;                                          \
    u = 0;                                                  \
    if (uu != 0)                                            \
    {                                                       \
        shift = 0;                                          \
        for (bit = 1; bit < (int)(w); bit <<= 1)            \
        {                                                   \
            u |= (uu & bit) << shift;                       \
            if (bit < (int)(h)) shift++;                    \
        }                                                   \
    }                                                       \
}
#define U_UNINTERLEAVE(u,uu,w,h)                            \
{                                                           \
    int bit, shift;                                         \
    u = 0;                                                  \
    shift = 0;                                              \
    for (bit = 1; bit < (int)(w); bit << = 1)               \
    {                                                       \
        u |= (uu >> shift) & bit;                           \
        if (bit < (int)(h)) shift++;                        \
    }                                                       \
}
#define V_INTERLEAVE(v,vv,w,h)                              \
{                                                           \
    int bit,shift;                                          \
    v = 0;                                                  \
    if (vv != 0)                                            \
    {                                                       \
        shift = 0;                                          \
        for (bit = 1; bit < (int)(h); bit <<= 1)            \
        {                                                   \
            if (bit < (int)(w)) shift++;                    \
            v |= (vv & bit) << shift;                       \
        }                                                   \
    }                                                       \
}
#define V_UNINTERLEAVE(v,vv,w,h)                            \
{                                                           \
    int bit,shift;                                          \
    v = 0;                                                  \
    shift = 0;                                              \
    for (bit = 1; bit < (int)(h); bit <<= 1)                \
    {                                                       \
        if (bit < (int)(w)) shift++;                        \
        v |= (vv >> shift) & bit;                           \
    }                                                       \
}
#define U_INC_MASK(i,m,h)                                   \
{                                                           \
    int logh;                                               \
    int hh = (int)(h) - 1;                                  \
    for (logh = 0; hh != 0; hh >>= 1, logh++);              \
    m = ((1 << (2 * logh)) - 1);                            \
    i = (0xAAAAAAAA & m) + 1;                               \
    m = (0x55555555 & m) | (~m);                            \
}
#define U_INC2_MASK(i1,i2,m,h)                              \
{                                                           \
    int logh;                                               \
    int hh = (int)(h) - 1;                                  \
    for (logh = 0; hh != 0; hh >>= 1,logh++);               \
    m = ((1 << (2 * logh)) - 1);                            \
    i1 = (0xAAAAAAAA & m) + 1;                              \
    i2 = (0xAAAAAAAA & m) + 2;                              \
    m = (0x55555555 & m) | (~m);                            \
}
#define V_INC_MASK(i,m,w)                                   \
{                                                           \
    int logw;                                               \
    int ww = (int)(w) - 1;                                  \
    for (logw = 0; ww != 0; ww >>= 1, logw++);              \
    m = ((1 << (2 * logw)) - 1);                            \
    i = (0x55555555 & m) + 1;                               \
    m = (0xAAAAAAAA & m) | (~m);                            \
}
#define UV_INC(uv,i,m)      (((uv) + i) & m)
#define UV_OFFSET(uu,vv)    ((uu) | (vv))

#ifdef __cplusplus
}
#endif // __cplusplus

#endif  // _NVD3DMAC_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\ddraw\common\inc\nvdblnd.h ===
/*
 * Copyright 1993-1998 NVIDIA, Corporation.  All rights reserved.
 * THE INFORMATION CONTAINED HEREIN IS PROPRIETARY AND CONFIDENTIAL TO
 * NVIDIA, CORPORATION.  USE, REPRODUCTION OR DISCLOSURE TO ANY THIRD PARTY
 * IS SUBJECT TO WRITTEN PRE-APPROVAL BY NVIDIA, CORPORATION.
 */
/********************************* Direct 3D *******************************\
*                                                                           *
* Module: NV4DBLND.H                                                        *
*   DX6 Class Blending definitions.                                         *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*       Charles Inman (chasi)       09/09/98 - created.                     *
*                                                                           *
\***************************************************************************/

#ifndef _NV4DBLND_H_
#define _NV4DBLND_H_

#ifdef __cplusplus
extern "C" {
#endif

/*
 * Combine1 Pass Thru
 */
#define DX6TRI_COMBINE1ALPHA_PASS_THRU                      \
    (DRF_DEF(055, _COMBINE_1_ALPHA, _INVERSE_0,  _NORMAL)   \
  |  DRF_DEF(055, _COMBINE_1_ALPHA, _ARGUMENT_0, _INPUT)    \
  |  DRF_DEF(055, _COMBINE_1_ALPHA, _INVERSE_1,  _INVERSE)  \
  |  DRF_DEF(055, _COMBINE_1_ALPHA, _ARGUMENT_1, _ZERO)     \
  |  DRF_DEF(055, _COMBINE_1_ALPHA, _INVERSE_2,  _NORMAL)   \
  |  DRF_DEF(055, _COMBINE_1_ALPHA, _ARGUMENT_2, _ZERO)     \
  |  DRF_DEF(055, _COMBINE_1_ALPHA, _INVERSE_3,  _NORMAL)   \
  |  DRF_DEF(055, _COMBINE_1_ALPHA, _ARGUMENT_3, _ZERO)     \
  |  DRF_DEF(055, _COMBINE_1_ALPHA, _OPERATION,  _ADD))


#define DX6TRI_COMBINE1COLOR_PASS_THRU                      \
    (DRF_DEF(055, _COMBINE_1_COLOR, _INVERSE_0,  _NORMAL)   \
  |  DRF_DEF(055, _COMBINE_1_COLOR, _ALPHA_0,    _COLOR)    \
  |  DRF_DEF(055, _COMBINE_1_COLOR, _ARGUMENT_0, _INPUT)    \
  |  DRF_DEF(055, _COMBINE_1_COLOR, _INVERSE_1,  _INVERSE)  \
  |  DRF_DEF(055, _COMBINE_1_COLOR, _ALPHA_1,    _COLOR)    \
  |  DRF_DEF(055, _COMBINE_1_COLOR, _ARGUMENT_1, _ZERO)     \
  |  DRF_DEF(055, _COMBINE_1_COLOR, _INVERSE_2,  _NORMAL)   \
  |  DRF_DEF(055, _COMBINE_1_COLOR, _ALPHA_2,    _COLOR)    \
  |  DRF_DEF(055, _COMBINE_1_COLOR, _ARGUMENT_2, _ZERO)     \
  |  DRF_DEF(055, _COMBINE_1_COLOR, _INVERSE_3,  _NORMAL)   \
  |  DRF_DEF(055, _COMBINE_1_COLOR, _ALPHA_3,    _COLOR)    \
  |  DRF_DEF(055, _COMBINE_1_COLOR, _ARGUMENT_3, _ZERO)     \
  |  DRF_DEF(055, _COMBINE_1_COLOR, _OPERATION,  _ADD))

/*
 * Combine0 Disable
 */
#define DX6TRI_COMBINE0ALPHA_DISABLE                        \
    (DRF_DEF(055, _COMBINE_0_ALPHA, _INVERSE_0,  _NORMAL)   \
  |  DRF_DEF(055, _COMBINE_0_ALPHA, _ARGUMENT_0, _DIFFUSE)  \
  |  DRF_DEF(055, _COMBINE_0_ALPHA, _INVERSE_1,  _INVERSE)  \
  |  DRF_DEF(055, _COMBINE_0_ALPHA, _ARGUMENT_1, _ZERO)     \
  |  DRF_DEF(055, _COMBINE_0_ALPHA, _INVERSE_2,  _NORMAL)   \
  |  DRF_DEF(055, _COMBINE_0_ALPHA, _ARGUMENT_2, _ZERO)     \
  |  DRF_DEF(055, _COMBINE_0_ALPHA, _INVERSE_3,  _NORMAL)   \
  |  DRF_DEF(055, _COMBINE_0_ALPHA, _ARGUMENT_3, _ZERO)     \
  |  DRF_DEF(055, _COMBINE_0_ALPHA, _OPERATION,  _ADD))

#define DX6TRI_COMBINE0COLOR_DISABLE                        \
    (DRF_DEF(055, _COMBINE_0_COLOR, _INVERSE_0,  _NORMAL)   \
  |  DRF_DEF(055, _COMBINE_0_COLOR, _ALPHA_0,    _COLOR)    \
  |  DRF_DEF(055, _COMBINE_0_COLOR, _ARGUMENT_0, _ZERO)     \
  |  DRF_DEF(055, _COMBINE_0_COLOR, _INVERSE_1,  _NORMAL)   \
  |  DRF_DEF(055, _COMBINE_0_COLOR, _ALPHA_1,    _COLOR)    \
  |  DRF_DEF(055, _COMBINE_0_COLOR, _ARGUMENT_1, _ZERO)     \
  |  DRF_DEF(055, _COMBINE_0_COLOR, _INVERSE_2,  _NORMAL)   \
  |  DRF_DEF(055, _COMBINE_0_COLOR, _ALPHA_2,    _COLOR)    \
  |  DRF_DEF(055, _COMBINE_0_COLOR, _ARGUMENT_2, _ZERO)     \
  |  DRF_DEF(055, _COMBINE_0_COLOR, _INVERSE_3,  _NORMAL)   \
  |  DRF_DEF(055, _COMBINE_0_COLOR, _ALPHA_3,    _COLOR)    \
  |  DRF_DEF(055, _COMBINE_0_COLOR, _ARGUMENT_3, _ZERO)     \
  |  DRF_DEF(055, _COMBINE_0_COLOR, _OPERATION,  _ADD))

/*
 * Combine1 Disable
 */
#define DX6TRI_COMBINE1ALPHA_DISABLE                        \
    (DRF_DEF(055, _COMBINE_1_ALPHA, _INVERSE_0,  _NORMAL)   \
  |  DRF_DEF(055, _COMBINE_1_ALPHA, _ARGUMENT_0, _DIFFUSE)  \
  |  DRF_DEF(055, _COMBINE_1_ALPHA, _INVERSE_1,  _INVERSE)  \
  |  DRF_DEF(055, _COMBINE_1_ALPHA, _ARGUMENT_1, _ZERO)     \
  |  DRF_DEF(055, _COMBINE_1_ALPHA, _INVERSE_2,  _NORMAL)   \
  |  DRF_DEF(055, _COMBINE_1_ALPHA, _ARGUMENT_2, _ZERO)     \
  |  DRF_DEF(055, _COMBINE_1_ALPHA, _INVERSE_3,  _NORMAL)   \
  |  DRF_DEF(055, _COMBINE_1_ALPHA, _ARGUMENT_3, _ZERO)     \
  |  DRF_DEF(055, _COMBINE_1_ALPHA, _OPERATION,  _ADD))

#define DX6TRI_COMBINE1COLOR_DISABLE                        \
    (DRF_DEF(055, _COMBINE_1_COLOR, _INVERSE_0,  _NORMAL)   \
  |  DRF_DEF(055, _COMBINE_1_COLOR, _ALPHA_0,    _COLOR)    \
  |  DRF_DEF(055, _COMBINE_1_COLOR, _ARGUMENT_0, _ZERO)     \
  |  DRF_DEF(055, _COMBINE_1_COLOR, _INVERSE_1,  _NORMAL)   \
  |  DRF_DEF(055, _COMBINE_1_COLOR, _ALPHA_1,    _COLOR)    \
  |  DRF_DEF(055, _COMBINE_1_COLOR, _ARGUMENT_1, _ZERO)     \
  |  DRF_DEF(055, _COMBINE_1_COLOR, _INVERSE_2,  _NORMAL)   \
  |  DRF_DEF(055, _COMBINE_1_COLOR, _ALPHA_2,    _COLOR)    \
  |  DRF_DEF(055, _COMBINE_1_COLOR, _ARGUMENT_2, _ZERO)     \
  |  DRF_DEF(055, _COMBINE_1_COLOR, _INVERSE_3,  _NORMAL)   \
  |  DRF_DEF(055, _COMBINE_1_COLOR, _ALPHA_3,    _COLOR)    \
  |  DRF_DEF(055, _COMBINE_1_COLOR, _ARGUMENT_3, _ZERO)     \
  |  DRF_DEF(055, _COMBINE_1_COLOR, _OPERATION,  _ADD))

/*
 * Default Combiner setup.
 */
#define DX6TRI_COMBINE0ALPHA_DEFAULT    DX6TRI_COMBINE0ALPHA_DISABLE

#define DX6TRI_COMBINE0COLOR_DEFAULT                            \
    (DRF_DEF(055, _COMBINE_0_COLOR, _INVERSE_0,  _INVERSE)      \
  |  DRF_DEF(055, _COMBINE_0_COLOR, _ALPHA_0,    _COLOR)        \
  |  DRF_DEF(055, _COMBINE_0_COLOR, _ARGUMENT_0, _ZERO)         \
  |  DRF_DEF(055, _COMBINE_0_COLOR, _INVERSE_1,  _NORMAL)       \
  |  DRF_DEF(055, _COMBINE_0_COLOR, _ALPHA_1,    _COLOR)        \
  |  DRF_DEF(055, _COMBINE_0_COLOR, _ARGUMENT_1, _DIFFUSE)      \
  |  DRF_DEF(055, _COMBINE_0_COLOR, _INVERSE_2,  _NORMAL)       \
  |  DRF_DEF(055, _COMBINE_0_COLOR, _ALPHA_2,    _COLOR)        \
  |  DRF_DEF(055, _COMBINE_0_COLOR, _ARGUMENT_2, _ZERO)         \
  |  DRF_DEF(055, _COMBINE_0_COLOR, _INVERSE_3,  _NORMAL)       \
  |  DRF_DEF(055, _COMBINE_0_COLOR, _ALPHA_3,    _COLOR)        \
  |  DRF_DEF(055, _COMBINE_0_COLOR, _ARGUMENT_3, _ZERO)         \
  |  DRF_DEF(055, _COMBINE_0_COLOR, _OPERATION,  _ADD))

#define DX6TRI_COMBINE1ALPHA_DEFAULT                            \
    (DRF_DEF(055, _COMBINE_1_ALPHA, _INVERSE_0,  _INVERSE)      \
  |  DRF_DEF(055, _COMBINE_1_ALPHA, _ARGUMENT_0, _ZERO)         \
  |  DRF_DEF(055, _COMBINE_1_ALPHA, _INVERSE_1,  _NORMAL)       \
  |  DRF_DEF(055, _COMBINE_1_ALPHA, _ARGUMENT_1, _INPUT)        \
  |  DRF_DEF(055, _COMBINE_1_ALPHA, _INVERSE_2,  _NORMAL)       \
  |  DRF_DEF(055, _COMBINE_1_ALPHA, _ARGUMENT_2, _ZERO)         \
  |  DRF_DEF(055, _COMBINE_1_ALPHA, _INVERSE_3,  _NORMAL)       \
  |  DRF_DEF(055, _COMBINE_1_ALPHA, _ARGUMENT_3, _ZERO)         \
  |  DRF_DEF(055, _COMBINE_1_ALPHA, _OPERATION,  _ADD))

#define DX6TRI_COMBINE1COLOR_DEFAULT    DX6TRI_COMBINE1COLOR_PASS_THRU

/*
 * Bump Mapping Combiner Setup.
 */
#define DX6TRI_COMBINE0ALPHA_BUMP                               \
    (DRF_DEF(055, _COMBINE_0_ALPHA, _INVERSE_0,  _INVERSE)      \
  |  DRF_DEF(055, _COMBINE_0_ALPHA, _ARGUMENT_0, _TEXTURE0)     \
  |  DRF_DEF(055, _COMBINE_0_ALPHA, _INVERSE_1,  _INVERSE)      \
  |  DRF_DEF(055, _COMBINE_0_ALPHA, _ARGUMENT_1, _ZERO)         \
  |  DRF_DEF(055, _COMBINE_0_ALPHA, _INVERSE_2,  _NORMAL)       \
  |  DRF_DEF(055, _COMBINE_0_ALPHA, _ARGUMENT_2, _TEXTURE1)     \
  |  DRF_DEF(055, _COMBINE_0_ALPHA, _INVERSE_3,  _INVERSE)      \
  |  DRF_DEF(055, _COMBINE_0_ALPHA, _ARGUMENT_3, _ZERO)         \
  |  DRF_DEF(055, _COMBINE_0_ALPHA, _OPERATION,  _ADDSIGNED))

#define DX6TRI_COMBINE0COLOR_BUMP                               \
    (DRF_DEF(055, _COMBINE_0_COLOR, _INVERSE_0,  _INVERSE)      \
  |  DRF_DEF(055, _COMBINE_0_COLOR, _ALPHA_0,    _ALPHA)        \
  |  DRF_DEF(055, _COMBINE_0_COLOR, _ARGUMENT_0, _TEXTURE0)     \
  |  DRF_DEF(055, _COMBINE_0_COLOR, _INVERSE_1,  _INVERSE)      \
  |  DRF_DEF(055, _COMBINE_0_COLOR, _ALPHA_1,    _COLOR)        \
  |  DRF_DEF(055, _COMBINE_0_COLOR, _ARGUMENT_1, _ZERO)         \
  |  DRF_DEF(055, _COMBINE_0_COLOR, _INVERSE_2,  _INVERSE)      \
  |  DRF_DEF(055, _COMBINE_0_COLOR, _ALPHA_2,    _COLOR)        \
  |  DRF_DEF(055, _COMBINE_0_COLOR, _ARGUMENT_2, _ZERO)         \
  |  DRF_DEF(055, _COMBINE_0_COLOR, _INVERSE_3,  _NORMAL)       \
  |  DRF_DEF(055, _COMBINE_0_COLOR, _ALPHA_3,    _ALPHA)        \
  |  DRF_DEF(055, _COMBINE_0_COLOR, _ARGUMENT_3, _TEXTURE1)     \
  |  DRF_DEF(055, _COMBINE_0_COLOR, _OPERATION,  _ADDSIGNED2))

#define DX6TRI_COMBINE1ALPHA_BUMP                               \
    (DRF_DEF(055, _COMBINE_1_ALPHA, _INVERSE_0,  _INVERSE)      \
  |  DRF_DEF(055, _COMBINE_1_ALPHA, _ARGUMENT_0, _ZERO)         \
  |  DRF_DEF(055, _COMBINE_1_ALPHA, _INVERSE_1,  _INVERSE)      \
  |  DRF_DEF(055, _COMBINE_1_ALPHA, _ARGUMENT_1, _ZERO)         \
  |  DRF_DEF(055, _COMBINE_1_ALPHA, _INVERSE_2,  _NORMAL)       \
  |  DRF_DEF(055, _COMBINE_1_ALPHA, _ARGUMENT_2, _ZERO)         \
  |  DRF_DEF(055, _COMBINE_1_ALPHA, _INVERSE_3,  _NORMAL)       \
  |  DRF_DEF(055, _COMBINE_1_ALPHA, _ARGUMENT_3, _ZERO)         \
  |  DRF_DEF(055, _COMBINE_1_ALPHA, _OPERATION,  _ADD))

#define DX6TRI_COMBINE1COLOR_BUMP                               \
    (DRF_DEF(055, _COMBINE_0_COLOR, _INVERSE_0,  _INVERSE)      \
  |  DRF_DEF(055, _COMBINE_0_COLOR, _ALPHA_0,    _COLOR)        \
  |  DRF_DEF(055, _COMBINE_0_COLOR, _ARGUMENT_0, _INPUT)        \
  |  DRF_DEF(055, _COMBINE_0_COLOR, _INVERSE_1,  _NORMAL)       \
  |  DRF_DEF(055, _COMBINE_0_COLOR, _ALPHA_1,    _COLOR)        \
  |  DRF_DEF(055, _COMBINE_0_COLOR, _ARGUMENT_1, _TEXTURE0)     \
  |  DRF_DEF(055, _COMBINE_0_COLOR, _INVERSE_2,  _NORMAL)       \
  |  DRF_DEF(055, _COMBINE_0_COLOR, _ALPHA_2,    _COLOR)        \
  |  DRF_DEF(055, _COMBINE_0_COLOR, _ARGUMENT_2, _TEXTURE0)     \
  |  DRF_DEF(055, _COMBINE_0_COLOR, _INVERSE_3,  _NORMAL)       \
  |  DRF_DEF(055, _COMBINE_0_COLOR, _ALPHA_3,    _COLOR)        \
  |  DRF_DEF(055, _COMBINE_0_COLOR, _ARGUMENT_3, _DIFFUSE)      \
  |  DRF_DEF(055, _COMBINE_0_COLOR, _OPERATION,  _ADD))

/*
 * DX6 Triangle Class combiner mappings for TEXTUREMAPBLEND_DECAL
 * cPix = cTex
 * aPix = aTex
 */
#define DX6TRI_COMBINE0ALPHA_TBLEND_DECAL                       \
    (DRF_DEF(055, _COMBINE_0_ALPHA, _INVERSE_0,  _NORMAL)       \
  |  DRF_DEF(055, _COMBINE_0_ALPHA, _ARGUMENT_0, _TEXTURE0)     \
  |  DRF_DEF(055, _COMBINE_0_ALPHA, _INVERSE_1,  _INVERSE)      \
  |  DRF_DEF(055, _COMBINE_0_ALPHA, _ARGUMENT_1, _ZERO)         \
  |  DRF_DEF(055, _COMBINE_0_ALPHA, _INVERSE_2,  _NORMAL)       \
  |  DRF_DEF(055, _COMBINE_0_ALPHA, _ARGUMENT_2, _ZERO)         \
  |  DRF_DEF(055, _COMBINE_0_ALPHA, _INVERSE_3,  _NORMAL)       \
  |  DRF_DEF(055, _COMBINE_0_ALPHA, _ARGUMENT_3, _ZERO)         \
  |  DRF_DEF(055, _COMBINE_0_ALPHA, _OPERATION,  _ADD))

#define DX6TRI_COMBINE0COLOR_TBLEND_DECAL                       \
    (DRF_DEF(055, _COMBINE_0_COLOR, _INVERSE_0,  _NORMAL)       \
  |  DRF_DEF(055, _COMBINE_0_COLOR, _ALPHA_0,    _COLOR)        \
  |  DRF_DEF(055, _COMBINE_0_COLOR, _ARGUMENT_0, _TEXTURE0)     \
  |  DRF_DEF(055, _COMBINE_0_COLOR, _INVERSE_1,  _INVERSE)      \
  |  DRF_DEF(055, _COMBINE_0_COLOR, _ALPHA_1,    _COLOR)        \
  |  DRF_DEF(055, _COMBINE_0_COLOR, _ARGUMENT_1, _ZERO)         \
  |  DRF_DEF(055, _COMBINE_0_COLOR, _INVERSE_2,  _NORMAL)       \
  |  DRF_DEF(055, _COMBINE_0_COLOR, _ALPHA_2,    _COLOR)        \
  |  DRF_DEF(055, _COMBINE_0_COLOR, _ARGUMENT_2, _ZERO)         \
  |  DRF_DEF(055, _COMBINE_0_COLOR, _INVERSE_3,  _NORMAL)       \
  |  DRF_DEF(055, _COMBINE_0_COLOR, _ALPHA_3,    _COLOR)        \
  |  DRF_DEF(055, _COMBINE_0_COLOR, _ARGUMENT_3, _ZERO)         \
  |  DRF_DEF(055, _COMBINE_0_COLOR, _OPERATION,  _ADD))

/*
 * DX6 Triangle Class combiner mappings for TEXTUREMAPBLEND_MODULATE
 * cPix = cTex * cSrc
 * aPix = aTex
 */
#define DX6TRI_COMBINE0ALPHA_TBLEND_MODULATE                    \
    (DRF_DEF(055, _COMBINE_0_ALPHA, _INVERSE_0,  _NORMAL)       \
  |  DRF_DEF(055, _COMBINE_0_ALPHA, _ARGUMENT_0, _TEXTURE0)     \
  |  DRF_DEF(055, _COMBINE_0_ALPHA, _INVERSE_1,  _INVERSE)      \
  |  DRF_DEF(055, _COMBINE_0_ALPHA, _ARGUMENT_1, _ZERO)         \
  |  DRF_DEF(055, _COMBINE_0_ALPHA, _INVERSE_2,  _NORMAL)       \
  |  DRF_DEF(055, _COMBINE_0_ALPHA, _ARGUMENT_2, _ZERO)         \
  |  DRF_DEF(055, _COMBINE_0_ALPHA, _INVERSE_3,  _NORMAL)       \
  |  DRF_DEF(055, _COMBINE_0_ALPHA, _ARGUMENT_3, _ZERO)         \
  |  DRF_DEF(055, _COMBINE_0_ALPHA, _OPERATION,  _ADD))

#define DX6TRI_COMBINE0COLOR_TBLEND_MODULATE                    \
    (DRF_DEF(055, _COMBINE_0_COLOR, _INVERSE_0,  _NORMAL)       \
  |  DRF_DEF(055, _COMBINE_0_COLOR, _ALPHA_0,    _COLOR)        \
  |  DRF_DEF(055, _COMBINE_0_COLOR, _ARGUMENT_0, _TEXTURE0)     \
  |  DRF_DEF(055, _COMBINE_0_COLOR, _INVERSE_1,  _NORMAL)       \
  |  DRF_DEF(055, _COMBINE_0_COLOR, _ALPHA_1,    _COLOR)        \
  |  DRF_DEF(055, _COMBINE_0_COLOR, _ARGUMENT_1, _DIFFUSE)      \
  |  DRF_DEF(055, _COMBINE_0_COLOR, _INVERSE_2,  _NORMAL)       \
  |  DRF_DEF(055, _COMBINE_0_COLOR, _ALPHA_2,    _COLOR)        \
  |  DRF_DEF(055, _COMBINE_0_COLOR, _ARGUMENT_2, _ZERO)         \
  |  DRF_DEF(055, _COMBINE_0_COLOR, _INVERSE_3,  _NORMAL)       \
  |  DRF_DEF(055, _COMBINE_0_COLOR, _ALPHA_3,    _COLOR)        \
  |  DRF_DEF(055, _COMBINE_0_COLOR, _ARGUMENT_3, _ZERO)         \
  |  DRF_DEF(055, _COMBINE_0_COLOR, _OPERATION,  _ADD))

/*
 * DX6 Triangle Class combiner mappings for TEXTUREMAPBLEND_DECALALPHA
 * cPix = ((1 - aTex) * cSrc) + (aTex * cTex)
 * aPix = aSrc
 */
#define DX6TRI_COMBINE0ALPHA_TBLEND_DECALALPHA                  \
    (DRF_DEF(055, _COMBINE_0_ALPHA, _INVERSE_0,  _NORMAL)       \
  |  DRF_DEF(055, _COMBINE_0_ALPHA, _ARGUMENT_0, _DIFFUSE)      \
  |  DRF_DEF(055, _COMBINE_0_ALPHA, _INVERSE_1,  _INVERSE)      \
  |  DRF_DEF(055, _COMBINE_0_ALPHA, _ARGUMENT_1, _ZERO)         \
  |  DRF_DEF(055, _COMBINE_0_ALPHA, _INVERSE_2,  _NORMAL)       \
  |  DRF_DEF(055, _COMBINE_0_ALPHA, _ARGUMENT_2, _ZERO)         \
  |  DRF_DEF(055, _COMBINE_0_ALPHA, _INVERSE_3,  _NORMAL)       \
  |  DRF_DEF(055, _COMBINE_0_ALPHA, _ARGUMENT_3, _ZERO)         \
  |  DRF_DEF(055, _COMBINE_0_ALPHA, _OPERATION,  _ADD))

#define DX6TRI_COMBINE0COLOR_TBLEND_DECALALPHA                  \
    (DRF_DEF(055, _COMBINE_0_COLOR, _INVERSE_0,  _INVERSE)      \
  |  DRF_DEF(055, _COMBINE_0_COLOR, _ALPHA_0,    _ALPHA)        \
  |  DRF_DEF(055, _COMBINE_0_COLOR, _ARGUMENT_0, _TEXTURE0)     \
  |  DRF_DEF(055, _COMBINE_0_COLOR, _INVERSE_1,  _NORMAL)       \
  |  DRF_DEF(055, _COMBINE_0_COLOR, _ALPHA_1,    _COLOR)        \
  |  DRF_DEF(055, _COMBINE_0_COLOR, _ARGUMENT_1, _DIFFUSE)      \
  |  DRF_DEF(055, _COMBINE_0_COLOR, _INVERSE_2,  _NORMAL)       \
  |  DRF_DEF(055, _COMBINE_0_COLOR, _ALPHA_2,    _ALPHA)        \
  |  DRF_DEF(055, _COMBINE_0_COLOR, _ARGUMENT_2, _TEXTURE0)     \
  |  DRF_DEF(055, _COMBINE_0_COLOR, _INVERSE_3,  _NORMAL)       \
  |  DRF_DEF(055, _COMBINE_0_COLOR, _ALPHA_3,    _COLOR)        \
  |  DRF_DEF(055, _COMBINE_0_COLOR, _ARGUMENT_3, _TEXTURE0)     \
  |  DRF_DEF(055, _COMBINE_0_COLOR, _OPERATION,  _ADD))

/*
 * DX6 Triangle Class combiner mappings for TEXTUREMAPBLEND_MODULATEALPHA
 * cPix = cTex * cSrc
 * aPix = aTex * aSrc
 */
#define DX6TRI_COMBINE0ALPHA_TBLEND_MODULATEALPHA               \
    (DRF_DEF(055, _COMBINE_0_ALPHA, _INVERSE_0,  _NORMAL)       \
  |  DRF_DEF(055, _COMBINE_0_ALPHA, _ARGUMENT_0, _TEXTURE0)     \
  |  DRF_DEF(055, _COMBINE_0_ALPHA, _INVERSE_1,  _NORMAL)       \
  |  DRF_DEF(055, _COMBINE_0_ALPHA, _ARGUMENT_1, _DIFFUSE)      \
  |  DRF_DEF(055, _COMBINE_0_ALPHA, _INVERSE_2,  _NORMAL)       \
  |  DRF_DEF(055, _COMBINE_0_ALPHA, _ARGUMENT_2, _ZERO)         \
  |  DRF_DEF(055, _COMBINE_0_ALPHA, _INVERSE_3,  _NORMAL)       \
  |  DRF_DEF(055, _COMBINE_0_ALPHA, _ARGUMENT_3, _ZERO)         \
  |  DRF_DEF(055, _COMBINE_0_ALPHA, _OPERATION,  _ADD))

#define DX6TRI_COMBINE0COLOR_TBLEND_MODULATEALPHA               \
    (DRF_DEF(055, _COMBINE_0_COLOR, _INVERSE_0,  _NORMAL)       \
  |  DRF_DEF(055, _COMBINE_0_COLOR, _ALPHA_0,    _COLOR)        \
  |  DRF_DEF(055, _COMBINE_0_COLOR, _ARGUMENT_0, _TEXTURE0)     \
  |  DRF_DEF(055, _COMBINE_0_COLOR, _INVERSE_1,  _NORMAL)       \
  |  DRF_DEF(055, _COMBINE_0_COLOR, _ALPHA_1,    _COLOR)        \
  |  DRF_DEF(055, _COMBINE_0_COLOR, _ARGUMENT_1, _DIFFUSE)      \
  |  DRF_DEF(055, _COMBINE_0_COLOR, _INVERSE_2,  _NORMAL)       \
  |  DRF_DEF(055, _COMBINE_0_COLOR, _ALPHA_2,    _COLOR)        \
  |  DRF_DEF(055, _COMBINE_0_COLOR, _ARGUMENT_2, _ZERO)         \
  |  DRF_DEF(055, _COMBINE_0_COLOR, _INVERSE_3,  _NORMAL)       \
  |  DRF_DEF(055, _COMBINE_0_COLOR, _ALPHA_3,    _COLOR)        \
  |  DRF_DEF(055, _COMBINE_0_COLOR, _ARGUMENT_3, _ZERO)         \
  |  DRF_DEF(055, _COMBINE_0_COLOR, _OPERATION,  _ADD))

/*
 * DX6 Triangle Class combiner mappings for TEXTUREMAPBLEND_DECALMASK
 * cPix = lsb(aTex) ? cTex : cSrc
 * aPix = aSrc
 */
#if 0
#define DX6TRI_COMBINE0ALPHA_TBLEND_DECALMASK                   \
    (DRF_DEF(055, _COMBINE_0_ALPHA, _INVERSE_0,  _NORMAL)       \
  |  DRF_DEF(055, _COMBINE_0_ALPHA, _ARGUMENT_0, _DIFFUSE)      \
  |  DRF_DEF(055, _COMBINE_0_ALPHA, _INVERSE_1,  _INVERSE)      \
  |  DRF_DEF(055, _COMBINE_0_ALPHA, _ARGUMENT_1, _ZERO)         \
  |  DRF_DEF(055, _COMBINE_0_ALPHA, _INVERSE_2,  _NORMAL)       \
  |  DRF_DEF(055, _COMBINE_0_ALPHA, _ARGUMENT_2, _ZERO)         \
  |  DRF_DEF(055, _COMBINE_0_ALPHA, _INVERSE_3,  _NORMAL)       \
  |  DRF_DEF(055, _COMBINE_0_ALPHA, _ARGUMENT_3, _ZERO)         \
  |  DRF_DEF(055, _COMBINE_0_ALPHA, _OPERATION,  _ADD))
#else
#define DX6TRI_COMBINE0ALPHA_TBLEND_DECALMASK   DX6TRI_COMBINE0ALPHA_TBLEND_DECAL
#endif

#define DX6TRI_COMBINE0COLOR_TBLEND_DECALMASK   DX6TRI_COMBINE0COLOR_TBLEND_DECAL

/*
 * DX6 Triangle Class combiner mappings for TEXTUREMAPBLEND_MODULATEMASK
 * cPix = lsb(aTex) ? cTex * cSrc : cSrc
 * aPix = aSrc
 */
#if 0
#define DX6TRI_COMBINE0ALPHA_TBLEND_MODULATEMASK                \
    (DRF_DEF(055, _COMBINE_0_ALPHA, _INVERSE_0,  _NORMAL)       \
  |  DRF_DEF(055, _COMBINE_0_ALPHA, _ARGUMENT_0, _DIFFUSE)      \
  |  DRF_DEF(055, _COMBINE_0_ALPHA, _INVERSE_1,  _INVERSE)      \
  |  DRF_DEF(055, _COMBINE_0_ALPHA, _ARGUMENT_1, _ZERO)         \
  |  DRF_DEF(055, _COMBINE_0_ALPHA, _INVERSE_2,  _NORMAL)       \
  |  DRF_DEF(055, _COMBINE_0_ALPHA, _ARGUMENT_2, _ZERO)         \
  |  DRF_DEF(055, _COMBINE_0_ALPHA, _INVERSE_3,  _NORMAL)       \
  |  DRF_DEF(055, _COMBINE_0_ALPHA, _ARGUMENT_3, _ZERO)         \
  |  DRF_DEF(055, _COMBINE_0_ALPHA, _OPERATION,  _ADD))
#else
#define DX6TRI_COMBINE0ALPHA_TBLEND_MODULATEMASK    DX6TRI_COMBINE0ALPHA_TBLEND_MODULATE
#endif

#define DX6TRI_COMBINE0COLOR_TBLEND_MODULATEMASK    DX6TRI_COMBINE0COLOR_TBLEND_MODULATE

/*
 * DX6 Triangle Class combiner mappings for TEXTUREMAPBLEND_COPY
 * cPix = cTex
 * aPix = aTex
 */
#define DX6TRI_COMBINE0ALPHA_TBLEND_COPY    DX6TRI_COMBINE0ALPHA_TBLEND_DECAL
#define DX6TRI_COMBINE0COLOR_TBLEND_COPY    DX6TRI_COMBINE0COLOR_TBLEND_DECAL

/*
 * DX6 Triangle Class combiner mappings for TEXTUREMAPBLEND_ADD
 * cPix = cTex + cSrc
 * aPix = aSrc
 */
#define DX6TRI_COMBINE0ALPHA_TBLEND_ADD                         \
    (DRF_DEF(055, _COMBINE_0_ALPHA, _INVERSE_0,  _NORMAL)       \
  |  DRF_DEF(055, _COMBINE_0_ALPHA, _ARGUMENT_0, _DIFFUSE)      \
  |  DRF_DEF(055, _COMBINE_0_ALPHA, _INVERSE_1,  _INVERSE)      \
  |  DRF_DEF(055, _COMBINE_0_ALPHA, _ARGUMENT_1, _ZERO)         \
  |  DRF_DEF(055, _COMBINE_0_ALPHA, _INVERSE_2,  _NORMAL)       \
  |  DRF_DEF(055, _COMBINE_0_ALPHA, _ARGUMENT_2, _ZERO)         \
  |  DRF_DEF(055, _COMBINE_0_ALPHA, _INVERSE_3,  _NORMAL)       \
  |  DRF_DEF(055, _COMBINE_0_ALPHA, _ARGUMENT_3, _ZERO)         \
  |  DRF_DEF(055, _COMBINE_0_ALPHA, _OPERATION,  _ADD))

#define DX6TRI_COMBINE0COLOR_TBLEND_ADD                         \
    (DRF_DEF(055, _COMBINE_0_COLOR, _INVERSE_0,  _NORMAL)       \
  |  DRF_DEF(055, _COMBINE_0_COLOR, _ALPHA_0,    _COLOR)        \
  |  DRF_DEF(055, _COMBINE_0_COLOR, _ARGUMENT_0, _TEXTURE0)     \
  |  DRF_DEF(055, _COMBINE_0_COLOR, _INVERSE_1,  _INVERSE)      \
  |  DRF_DEF(055, _COMBINE_0_COLOR, _ALPHA_1,    _COLOR)        \
  |  DRF_DEF(055, _COMBINE_0_COLOR, _ARGUMENT_1, _ZERO)         \
  |  DRF_DEF(055, _COMBINE_0_COLOR, _INVERSE_2,  _NORMAL)       \
  |  DRF_DEF(055, _COMBINE_0_COLOR, _ALPHA_2,    _COLOR)        \
  |  DRF_DEF(055, _COMBINE_0_COLOR, _ARGUMENT_2, _DIFFUSE)      \
  |  DRF_DEF(055, _COMBINE_0_COLOR, _INVERSE_3,  _INVERSE)      \
  |  DRF_DEF(055, _COMBINE_0_COLOR, _ALPHA_3,    _COLOR)        \
  |  DRF_DEF(055, _COMBINE_0_COLOR, _ARGUMENT_3, _ZERO)         \
  |  DRF_DEF(055, _COMBINE_0_COLOR, _OPERATION,  _ADD))

#ifdef __cplusplus
}
#endif // __cplusplus

#endif // _NV4DBLND_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\ddraw\common\inc\nvdp2help.h ===
// **************************************************************************
//
//       Copyright 1993-1999 NVIDIA, Corporation.  All rights reserved.
//
//     NOTICE TO USER:   The source code  is copyrighted under  U.S. and
//     international laws.  Users and possessors of this source code are
//     hereby granted a nonexclusive,  royalty-free copyright license to
//     use this code in individual and commercial software.
//
//     Any use of this source code must include,  in the user documenta-
//     tion and  internal comments to the code,  notices to the end user
//     as follows:
//
//       Copyright 1993-1999 NVIDIA, Corporation.  All rights reserved.
//
//     NVIDIA, CORPORATION MAKES NO REPRESENTATION ABOUT THE SUITABILITY
//     OF  THIS SOURCE  CODE  FOR ANY PURPOSE.  IT IS  PROVIDED  "AS IS"
//     WITHOUT EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORPOR-
//     ATION DISCLAIMS ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,
//     INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY, NONINFRINGE-
//     MENT,  AND FITNESS  FOR A PARTICULAR PURPOSE.   IN NO EVENT SHALL
//     NVIDIA, CORPORATION  BE LIABLE FOR ANY SPECIAL,  INDIRECT,  INCI-
//     DENTAL, OR CONSEQUENTIAL DAMAGES,  OR ANY DAMAGES  WHATSOEVER RE-
//     SULTING FROM LOSS OF USE,  DATA OR PROFITS,  WHETHER IN AN ACTION
//     OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,  ARISING OUT OF
//     OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOURCE CODE.
//
//     U.S. Government  End  Users.   This source code  is a "commercial
//     item,"  as that  term is  defined at  48 C.F.R. 2.101 (OCT 1995),
//     consisting  of "commercial  computer  software"  and  "commercial
//     computer  software  documentation,"  as such  terms  are  used in
//     48 C.F.R. 12.212 (SEPT 1995)  and is provided to the U.S. Govern-
//     ment only as  a commercial end item.   Consistent with  48 C.F.R.
//     12.212 and  48 C.F.R. 227.7202-1 through  227.7202-4 (JUNE 1995),
//     all U.S. Government End Users  acquire the source code  with only
//     those rights set forth herein.
//
// ********************************* Direct 3D ******************************
//
//  Module: nvDP2Help.h
//      helper routines for DP2 operations
//
// **************************************************************************
//
//  History:
//      Craig Duttweiler        08Nov00         created
//
// **************************************************************************

// definitions
#define NV_NUM_UNIQUE_STREAMS(count) (((count) & 0x0000ffff) >>  0)
#define NV_NUM_SYSTEM_STREAMS(count) (((count) & 0xffff0000) >> 16)

// prototypes
void __stdcall  nvWireframeIndexedTriangle      (NV_INNERLOOP_ARGLIST);
void __stdcall  nvPointIndexedTriangle          (NV_INNERLOOP_ARGLIST);
void __stdcall  nvWireframeNonIndexedTriangle   (NV_INNERLOOP_ARGLIST);
void __stdcall  nvPointNonIndexedTriangle       (NV_INNERLOOP_ARGLIST);

void            nvCalcRWFar                     (PNVD3DCONTEXT pContext);

BOOL            nvPaletteBlt                    (CNvObject *pSrcObj, CTexture *pDstTexture);
BOOL            nvUnpalettize                   (CNvObject *pDstObj);
void            nvAutoPaletteCheckAndRevert     (CTexture* pTexture, BOOL bFullSurface);

DWORD           nvCountStreamDMAs               (PNVD3DCONTEXT pContext, DWORD dwStreamCount);
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\ddraw\common\inc\nvdinc.h ===
/*
 * Copyright 1993-1998 NVIDIA, Corporation.  All rights reserved.
 * THE INFORMATION CONTAINED HEREIN IS PROPRIETARY AND CONFIDENTIAL TO
 * NVIDIA, CORPORATION.  USE, REPRODUCTION OR DISCLOSURE TO ANY THIRD PARTY
 * IS SUBJECT TO WRITTEN PRE-APPROVAL BY NVIDIA, CORPORATION.
 */
/********************************* Direct 3D *******************************\
*                                                                           *
* Module: NVDINC.H                                                         *
*   NV4 specific direct 3d structure definitions.                           *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*       Charles Inman (chasi)       01/31/97 - created.                     *
*                                                                           *
\***************************************************************************/

#ifndef _NVDINC_H_
#define _NVDINC_H_

#ifndef __cplusplus
#error C++ compiler needed
#endif

/*****************************************************************************
 * macros
 ****************************************************************************/

/*
 * Always build for D3D.
 * Always build a non-syncing driver.
 */
#define NVD3D       1
#define D3D_NOSYNC  1

// macros to push & restore current context
#define NVPUSH(pType,pPtr)        pType __##pPtr##_TempStorage__ = (pPtr);
#define NVPOP(pType,pPtr)         (pPtr) = __##pPtr##_TempStorage__;

// basically this needs to be the union of arguments required
// by all the various DP2 functions
#define NV_DP2FUNCTION_ARGLIST  PNVD3DCONTEXT        pContext,              \
                                LPD3DHAL_DP2COMMAND *ppCommands,            \
                                LPBYTE               pCommandBufferEnd,     \
                                LPDWORD              pdwDP2RStates,         \
                                DWORD                dwDP2Flags

#define NV_INNERLOOP_ARGLIST    PNVD3DCONTEXT        pContext,              \
                                DWORD                dwCount

#define NV_INNERLOOP_ARGS       pContext,                                   \
                                dwCount

typedef HRESULT (*LPNVDP2FUNCTION) (NV_DP2FUNCTION_ARGLIST);
typedef LPNVDP2FUNCTION     nvDP2FunctionTable[D3D_DP2OP_MAX+1];
typedef nvDP2FunctionTable *pnvDP2FunctionTable;

typedef DWORD (*PFNRENDERPRIMITIVEOP)         (NV_INNERLOOP_ARGLIST);
typedef void  (*LPNVINDEXEDPRIM)              (NV_INNERLOOP_ARGLIST);
typedef void  (*LPNVDRAWPRIM)                 (NV_INNERLOOP_ARGLIST);
typedef void  (__stdcall *LPNVFVFINDEXEDPRIM) (NV_INNERLOOP_ARGLIST);
typedef void  (__stdcall *LPNVFVFDRAWPRIM)    (NV_INNERLOOP_ARGLIST);

#define NV_UV_COORDINATE_COUNT_MAX  2

/*
 * --------------------------------------------------------------------------
 * Define texture heap constants
 * --------------------------------------------------------------------------
 */
#define NV_MIN_TEXTURE_SIZE                        ((1*2)*1)
#define NV_TEXTURE_PAD                             512
#define NV_TEXTURE_OFFSET_ALIGN                    255
#define NV_KELVIN_CUBEMAP_FACE_ALIGN               127            // alignment of subordinate faces -x thru -z, both compressed and not
#define NV_CELSIUS_CUBEMAP_FACE_ALIGN              127            // alignment of uncompressed subordinate faces -x thru -z
#define NV_CELSIUS_CUBEMAP_FACE_ALIGN_COMPRESSED   31             // alignment of compressed subordinate faces -x thru -z

/*
 * ScaledImageFromMemory size in limitation
 */
#define NV4_SCALED_IMAGE_CUTOFF         16

/*
 * Cache aligned inner loop context data.
 * Note also, that the hardware registers should be defined in the order that
 * they appear in the in the object class.
 */
typedef struct _def_nv_d3d_context_inner_loop
{
// bank 0       !!!Don't change bank or element ordering!!!
    /*
     * Current rendering state.
     */
    DWORD                       dwColorKey;
    DWORD                       dwTextureOffset;       // Offset within DMA context to start of texture.
    DWORD                       dwFormat;
    DWORD                       dwFilter;              // Current filtering state.
    DWORD                       dwBlend;
    DWORD                       dwControl;
    DWORD                       dwFogColor;             // Current fog color.
    DWORD                       _dwPad0[1];
} NVD3DCONTEXTINNERLOOP, *PNVD3DCONTEXTINNERLOOP;

//---------------------------------------------------------------------------

typedef struct _def_nv_d3d_texture_stage_state
{
    DWORD   dwValue[D3D_TEXSTAGESTATE_MAX+1];
    DWORD   dwHandle;      // texture handle
    DWORD   dwLODBias;     // LOD bias value to feed to HW
    D3DMATRIX mTexTransformMatrix;
} NVD3DTEXSTAGESTATE, *PNVD3DTEXSTAGESTATE;

//---------------------------------------------------------------------------

typedef struct _def_nv_d3d_multi_texture_state
{
    DWORD   dwTextureOffset[2];
    DWORD   dwTextureFormat[2];
    DWORD   dwTextureFilter[2];
    DWORD   dwCombine0Alpha;
    DWORD   dwCombine0Color;
    DWORD   dwCombine1Alpha;
    DWORD   dwCombine1Color;
    DWORD   dwCombineFactor;
    DWORD   dwBlend;
    DWORD   dwControl0;
    DWORD   dwControl1;
    DWORD   dwControl2;
    DWORD   dwFogColor;

    /*
     * The hardware requires the the UVx texture coordinates match up with
     * TEXTUREx.  i.e. tu0, tv0 are the coordinates for TEXTURE0, and tu1,
     * tv1 are the coordinates for TEXTURE1.
     * To simplify life, I am making TEXTURE0 always correspond to texture
     * stage 0, TEXTURE1 will always correspond to texture stage 1, etc.
     * However, there does not always have to be a one to one correspondence
     * to the Texture stage and the order in which the UV coordinate pairs
     * appear in the FVF Vertices.  The texture stage state defines which
     * set of UV coordinates applies to the texture in that stage.  This
     * allows for a single set of UV coordinates to be used for the multiple
     * texture stages.
     * The following offset array gives the byte offset from the start of the
     * FVF UV corrdinate pairs to the actual UV coordinates to be used for
     * a particular UVx pair.  They are initialized when the multi-texture state
     * is caclulated.
     */
    DWORD   dwUVOffset[8];

    /*
     * This flag defines if the current texture stage state is
     * valid.  This flag basicly defines whether or not multi-texturing
     * is possible with the current state.
     * This flag can be used during the ValidateTextureStageState callback
     * to report whether we can mulit-texture with the current state.
     * If the state is not valid, ddrval will contain the error that should
     * be returned during a ValidateTextureStageState callback.
     */
    BOOL    bTSSValid;
    HRESULT ddrval;
} NVD3DMULTITEXTURESTATE, *PNVD3DMULTITEXTURESTATE;

//---------------------------------------------------------------------------

// Surface clip rectangle.
typedef struct _SurfaceViewport {                   // Surface clip region
    union {
        DWORD   dwClipHorizontal;
        struct  _clip_horizontal {
            WORD    wX;                             // Surface left edge
            WORD    wWidth;                         // Surface Clip Width
        } clipHorizontal;
    };
    union {
        DWORD   dwClipVertical;
        struct  _clip_vertical {
            WORD    wY;                             // Surface top edge
            WORD    wHeight;                        // Surface Clip Height
        } clipVertical;
    };

    D3DVALUE dvMinZ;                                // Min/max of clip Volume
    D3DVALUE dvMaxZ;

    D3DVALUE dvWNear;
    D3DVALUE dvWFar;
    D3DVALUE dvRWFar;                               // Fudged reciprocal of WFar.
    D3DVALUE dvInvWFar;                             // the real reciprocal of WFar
} SurfaceViewport, *pSurfaceViewport;

//---------------------------------------------------------------------------

// vertex shader constants
typedef struct _VertexShaderConsts {
    // The zero padding is here to handle the constant addressing offsets in software
    // efficiently.  Rather than performing a bounds check upon each memory
    VSHADERREGISTER zeroPadding[128];
    VSHADERREGISTER vertexShaderConstants[NV_CAPS_MAX_VSHADER_CONSTS];
    VSHADERREGISTER zeroPadding2[128];
    VSHADERREGISTER vertexShaderTemp[NV_CAPS_MAX_VSHADER_TEMPS];
} VertexShaderConsts;

//---------------------------------------------------------------------------

// Vertex buffer offset parameters from DP2. These structure fields are used in place of passing parameters to the
// DP2 routines and to the inner loops. Sometimes the inner loops need to recalculate the offset. Passing in a precomputed
// offset made this difficult, because the inner loop did not have have access to the DP2 command.

// dwVertexBufferOffset is set in nvDrawPrimitives and nvDrawPrimitives2 and takes the place of the dwVertexBufferOffset argument
// to the DP2 routines.
//
// dwVStart is set by DP2 routines to the starting index, i.e. it's scaled by the stride of the VB. It's set to zero when not
// needed.
//
// dwTotalOffset is set by DP2 routines to be dwVertexBufferOffset + (dwVStart * Stride). Inner loops that change the stride
// of the VB must recompute this. It's provided by the DP2 routines for compatibility with the older inner loop code.

typedef struct _nv_d3d_context_dp2_param {
    DWORD           dwDP2Prim;                     // current prim
    DWORD           dwVertexBufferOffset;          // pdp2d->dwVertexOffset
    DWORD           dwVertexBufferOffsetSave;      // temp copy of pdp2d->dwVertexOffset
    DWORD           dwVStart;                      // lpPrim->wVStart
    DWORD           dwTotalOffset;                 // pdp2d->dwVertexOffset + (lpPrim->wVStart * Stride)
    DWORD           dwVertexLength;                // pdp2d->dwVertexLength;
    DWORD           dwEdgeFlags;                   // uhhh... take a wild guess
    DWORD           dwIndices;                     // address of indices (if indexed primitive, else NULL)
    DWORD           dwIndexStride;                 // index stride in bytes (2 or 4)
} NVD3DCONTEXTDP2PARAM, *PNVD3DCONTEXTDP2PARAM;

//---------------------------------------------------------------------------

typedef struct _nv_d3d_context_sysVB {
    CVertexBuffer  *pSysMemVB;
    DWORD           dwDefVBOffset;
    DWORD           dwSysMemVBStream;
    BOOL            bWriteOffset;
    BYTE            _dwPad0[3];
    DWORD           dwStreamDMACount;
    DWORD           _dwPad[3];
} NVD3DCONTEXTSYSVB, *PNVD3DCONTEXTSYSVB;

//---------------------------------------------------------------------------

typedef struct _nv_fog_data {
    DWORD           dwFogTableMode;
    float           fFogTableStart;
    float           fFogTableEnd;
    float           fFogTableDensity;
    float           fFogTableLinearScale;
} NVFOGDATA;

//---------------------------------------------------------------------------

extern "C++"
{

class CCommonState
{
public:
    enum
    {
        FOG_SOURCE_Z = 1,
        FOG_SOURCE_W = 2
    };

    // this area contains state that is common to all devices
    // this includes state for which the meaning is identical
    // as well as flags that are either identical in meaning or mutually exclusive in usage
    // when flags are neither identical nor mutually exclusive, we must ensure that they are only set for the correct class
    DWORD          dwDirtyFlags;                        // dirty state that needs to be resent to HW
    DWORD          dwStateFlags;                        // hardware state flags
    DWORD          dwTexCoordIndices;                   // texture coordinate indices used for texture unit 0 (0x0000ffff) and 1 (0xffff0000)
    DWORD          dwNumTexCoordsNeeded;                // number of texture coordinates needed for the currently set texture
    DWORD          dwNumActiveCombinerStages;           // number of enabled HW combiner stages
    DWORD          dwNextAvailableTextureUnit;          // which texture unit / combiner input will be used for the next texture
    DWORD          dwInlineVertexStride;                // stride of inline vertices (in bytes)
    DWORD          dwVertexOffset;                      // last vertex offset for whch the HW was programmed
    DWORD          dwFogSource;                         // indicates if we should use Z or W based fog
    DWORD          dwCombinerDP2Prim;                   // last DP2 Primitive for which combiners were programmed (affects point sprites)

    D3DVALUE       dvZScale;                            // the scale applied to a Z in [0...1] to make it fill the z buffer
    D3DVALUE       dvInvZScale;                         // the inverse

    CVertexShader *pVertexShader;                       // last vertex shader for which the HW was programmed

    CVertexBuffer *ppStreams          [NV_CAPS_MAX_STREAMS];         // last stream set for which hardware was programmed
    DWORD          dwTexUnitToTexStageMapping[NV_CAPS_MAX_TEXTURES]; // which D3D texture stage (if any) is being handled by this HW texture unit
    DWORD          dwTextureUnitStatus[NV_CAPS_MAX_TEXTURES];        // what is each hardware texture unit being used for?
    CTexture      *pTextureInUse      [NV_CAPS_MAX_TEXTURES];        // texture (if any) currently in use by HW texture unit i

    CSuperTri      SuperTri;

    DWORD          alphacull_mode;                                   // tracks which alpha cull mode I'm using for dirty bit checks

    DWORD          dwColorICW         [NV_CAPS_MAX_COMBINERS];       // color combiner input control words
    DWORD          dwColorOCW         [NV_CAPS_MAX_COMBINERS];       // color combiner output control words
    DWORD          dwAlphaICW         [NV_CAPS_MAX_COMBINERS];       // color combiner input control words
    DWORD          dwAlphaOCW         [NV_CAPS_MAX_COMBINERS];       // alpha combiner output control words

    D3DMATRIX      mTransform;                                       // supertri transform matrix
    DWORD          specfog_cw[2];
};

//---------------------------------------------------------------------------

class CHardwareState : public CCommonState
{
public:
#if (NVARCH >= 0x010)
    CCelsiusState celsius;
#endif // NVARCH == 0x010
#if (NVARCH >= 0x020)
    CKelvinState  kelvin;
#endif // NVARCH == 0x020
};

//---------------------------------------------------------------------------

typedef enum _D3DCONTEXTFLAGS
{
    CONTEXT_NEEDS_VTX_CACHE_FLUSH = 0x01
} D3DCONTEXTFLAGS;

// Define the context header.
typedef struct _def_nv_d3d_context
{
    // Application DX version.
    DWORD                       dwDXAppVersion;         // the application's DX version level.

    // Default texture state for this context.
    DWORD                       dwTickLastUsed;         // cheesy way of determining the active context
    DWORD                       dwLastFillColor;        // most reset fill color (used for logo clear)
    BOOL                        bClearLogo;             // TRUE if we must clear the area behind the logo

#if (NVARCH >= 0x010)
    AASTATE                     aa;
#endif  // NVARCH >= 0x010
#if (NVARCH >= 0x020)
    CKelvinAAState              kelvinAA;
#endif  // NVARCH >= 0x010

    // palette
    DWORD                       dwTexturePaletteStagingHandle;
    DWORD                       dwTexturePaletteAddr;   // address of palette staging area
    DWORD                       dwTexturePaletteOffset; // offset of palette staging area

    CSimpleSurface             *pRenderTarget;
    DWORD                       dwRTHandle;             // cached for RT restore after mode switch
    CSimpleSurface             *pZetaBuffer;
    DWORD                       dwZBHandle;             // cached for RT restore after mode switch

    // Number of flips to allow pending before using SUPER_TRI code.
    DWORD                       dwSuperTriPendingFlips;
    DWORD                       dwSuperTriThrottle;
    DWORD                       dwSuperTriMask;

    NVD3DCONTEXTDP2PARAM        dp2;
    DWORD                       dwHWUnlockAllPending;
    DWORD                       dwFlags;
    // the following fields of this array have been superceded by equivalent fields in tssState[0].
    //      D3DRENDERSTATE_TEXTUREHANDLE    (1)
    //      D3DRENDERSTATE_TEXTUREADDRESS   (3)
    //      D3DRENDERSTATE_BORDERCOLOR      (43)
    //      D3DRENDERSTATE_TEXTUREADDRESSU  (44)
    //      D3DRENDERSTATE_TEXTUREADDRESSV  (45)
    //      D3DRENDERSTATE_MIPMAPLODBIAS    (46)
    //      D3DRENDERSTATE_ANISOTROPY       (49)
    // values for these fields are no longer saved in dwRenderState and the fields are therefore
    // liable to contain junk! the real values MUST be obtained from tssState[0].
    DWORD                       dwRenderState[D3D_RENDERSTATE_MAX+1];
    BOOL                        bStateChange;
    NVD3DSTATESET               overrides;              // Render state override bits.

    NVFOGDATA                   fogData;

    struct _def_nv_d3d_context *pContextPrev;
    struct _def_nv_d3d_context *pContextNext;

    // DX6 Texture Stage State.
    DWORD                       dwStageCount;           // Number of enabled/valid texture stages.
    BOOL                        bUseDX6Class;           // Use DX6 Multi-Texture Triangle Class.
    BOOL                        bUseTBlendSettings;     //
    DWORD                       dwTBlendCombine0Alpha;
    DWORD                       dwTBlendCombine0Color;
    NVD3DMULTITEXTURESTATE      mtsState;               // DX6 Multi-Texture Triangle State.
    NVD3DMULTITEXTURESTATE      mtsShadowState;         //  for state update optimizations

    NVD3DTEXSTAGESTATE          tssState[8];            // Texture Stage State.

    BOOL                        bStencilEnabled;        // has the stencil buffer ever been enabled?
    DWORD                       dwStencilFill;          // the last value to which the stencil buffer was filled

    DWORD                       pid;                    // Process ID
    DWORD                       dwDDLclID;              // tag for this context's DIRECTDRAW_LCL
    DWORD                       dwDDGblID;              // tag for this context's DIRECTDRAW_GBL
    CDriverContext             *pDriverData;            // this context's pDriverData
#ifdef WINNT
    PDEV                       *ppdev;
#else WINNT
    DISPDRVDIRECTXCOMMON       *pDXShare;               // this context's pDXShare
#endif

    NVLIGHTING                  lighting;               // Lighting state
    nvLight                    *pLightArray;
    DWORD                       dwLightArraySize;       // Size of the light array allocated

    D3DMATERIAL7                Material;               // the current material

    D3DMATRIX                   xfmProj;
    D3DMATRIX                   xfmView;
    D3DMATRIX                   xfmWorld[NV_CAPS_MAX_MATRICES];  // world matrices

    D3DVALUE                    ppClipPlane[D3DMAXUSERCLIPPLANES][4];

    // stateset stuff
    pnvDP2FunctionTable         pDP2FunctionTable;      // current DP2 functions (set, record, or capture)
    DWORD                       dwCurrentStateSet;
    DWORD                       dwMaxStateSetHandles;
    STATESET                   *pStateSets;

    DWORD                       dwFunctionLookup;       // Lookup index for the appropriate nv4 render function.
    NVD3DCONTEXTINNERLOOP       ctxInnerLoop;           // Context data used within inner loops.
    NVD3DCONTEXTINNERLOOP       ctxInnerLoopShadow;     // hw image of above
    CHardwareState              hwState;

    // viewport
    SurfaceViewport             surfaceViewport;

    CVertexShader              *pCurrentVShader;
    VertexShaderConsts         *pVShaderConsts;

    CPixelShader               *pCurrentPShader;
    CPixelShader               *pLastPShader;
    D3DCOLORVALUE               pixelShaderConsts[NV_CAPS_MAX_PSHADER_CONSTS];

    CVertexBuffer              *ppDX8Streams[NV_CAPS_MAX_STREAMS];   // Streams for DX8 prims, note they all use dwVertexOffsetInUse
    DWORD                       dwStreamDMACount;                    // number of unique context DMAs in 15:0, number of system streams in 31:16

    CVertexBuffer              *pIndexBuffer;                        // Index buffer for DX8 primitives

    CNvObject                  *pCelsiusPointTexture;
    DWORD                       dwPointHandle;

    NVD3DCONTEXTSYSVB           sysvb;

    PBYTE                       pVertexDataUM;
    DWORD                       dwVertexDataLengthUM;

#ifdef WINNT
    // Need this for Winnt to access the PDEV state struct maintained by display
    // driver. PDEV also contains a ptr to the GLOBALDATA struct.
    PDD_DIRECTDRAW_GLOBAL       lpDD;
#endif // #ifdef WINNT

#ifdef TEX_MANAGE
    NV_TEXMAN_DATA              texManData;  // data used by the texture manager
#endif  // TEX_MANAGE

    DWORD                       dwEarlyCopyStrategy; // ask ScottC for details
    DWORD                       dwClearCount;        // number of full clears this frame
    DWORD                       dwTotalClearCount;   // total number of clears on the primary Z surface, modulo 256
    BOOL                        bSeenTriangles;      // Have we seen any triangle calls
    BOOL                        bScaledFlatPanel;   // are we in a scaled, flat panel mode?

} NVD3DCONTEXT, *PNVD3DCONTEXT;  // struct _def_nv_d3d_context

} // extern C++

// NV_OBJECT_LIST is a list of pointers to the NV objects
// associated with a particular DIRECTDRAW_LCL. the list is indexed by the
// handles that have been associated with the objects via CreateSurfaceEx.
// we maintain a linked list of these structures for each DIRECTDRAW_GBL.

#define NV_OBJECT_LIST_SIZE_DEFAULT      128
#define NV_OBJECT_LIST_SIZE_INCREMENTAL  128

typedef struct _NV_OBJECT_LIST {
    DWORD                     dwDDLclID;     // ID tag for the DD_LCL for which this list is kept
    DWORD                     dwListSize;    // the size of the list
    CNvObject               **ppObjectList;  // the list itself (just an array)
    struct _NV_OBJECT_LIST   *pNext;         // the next list
} NV_OBJECT_LIST, *PNV_OBJECT_LIST;

/*
 * External data.
 */
extern PFNRENDERPRIMITIVEOP       pfnRenderPrimitiveOperation[];
extern PFND3DPARSEUNKNOWNCOMMAND  fnD3DParseUnknownCommandCallback;

/*
 * Texture Staging Manager Functions
 */
#define TM_STAGESPACE              (2*1024*1024) // 2048k

#define NV_PN_TEX_RETIRE           0    // depreciated in for nv_tex2
#define NV_PN_SPOOFED_FLIP_COUNT   4
#define NV_PN_TEXTURE_RETIRE       8

/*
 * Embedded Profiler Functions
 */
#ifdef NV_PROFILE

/*
 * Constants
 */
 #define NVP_E_BEGINSCENE            0 // beginscene event
 #define NVP_E_PUT                   1 // put event
 #define NVP_T_HDFLUSH               2 // hd flush time
 #define NVP_T_SCENE                 3 // scene time
 #define NVP_T_DP2                   4 // total dp2 time

#ifdef NV_PROFILE_CPULOCK
 #define NVP_T_VBDP2_LOCK            5 // dp2 exit cpu lock
 #define NVP_T_VB_LOCK               6 // D3DLockExecuteBuffer
 #define NVP_T_VB_INLINE             7 // inline VB lock
 #define NVP_T_TEX_ULS               8 // update linear surface
 #define NVP_T_TEX_USS               9 // update swizzle surface
 #define NVP_T_TEX_BLT              10 // nvTextureBlt
 #define NVP_T_TEX_LOCK             11 // nvTextureLock
 #define NVP_T_FLOAT0               12
 #define NVP_T_FLOAT1               13
#endif

#ifdef NV_PROFILE_PUSHER
 #define NVP_T_WRAPAROUND            5
 #define NVP_T_MAKESPACE             6
 #define NVP_T_ADJUST                7
 #define NVP_T_FLUSH                 8 // time spend waiting in nvPusherFlush
 #define NVP_C_PENDINGSIZE           9 // size of pending pushe buffer (at put time)
 #define NVP_C_PUT                  10
 #define NVP_C_GET                  11
 #define NVP_C_VELOCITY             12
#endif

#ifdef NV_PROFILE_CALLSTACK
 #define NVP_T_SETCELSIUSSTATE       5
 #define NVP_T_SETKELVINSTATE        6
 #define NVP_T_IDXDISPATCH           7
 #define NVP_T_ORDDISPATCH           8
#endif

#ifdef NV_PROFILE_DEFVB
 #define NVP_C_PUT                   5
 #define NVP_C_GET                   6
 #define NVP_C_FREECOUNT             7
 #define NVP_E_PRIM                  8
#endif

#ifdef NV_PROFILE_COPIES
 #define NVP_T_RENAME_AUTO_COPY      5
 #define NVP_T_LIN2SWZ2              6
 #define NVP_T_RENAME_FWD            7
#endif

/*
 * Macros
 */
#define _NVP_PUSH  __asm push eax __asm push edx __asm push ebx
#define _NVP_POP   __asm pop ebx __asm pop edx __asm pop eax
#define _NVP_SYNC  __asm xchg al,al __asm nop __asm nop
#define _NVP_RDTSC _NVP_SYNC __asm _emit 0x0f __asm _emit 0x31

#define NVP_START(_t) { nvpTime[_t]=0; NVP_RESTART(_t); }
#define NVP_RESTART(_t) { _NVP_PUSH _NVP_RDTSC __asm mov ebx,(OFFSET nvpTime+(_t)*8) __asm sub [ebx],eax __asm sbb [ebx+4],edx _NVP_POP }
#define NVP_STOP(_t)  { _NVP_PUSH _NVP_RDTSC __asm mov ebx,(OFFSET nvpTime+(_t)*8) __asm add [ebx],eax __asm adc [ebx+4],edx _NVP_POP }

extern __int64 nvpTime[256];
extern DWORD   nvpEnableBits;
extern DWORD   nvpTriPerSecWindow;

#endif // !NV_PROFILE

// nv4comp.h
typedef void (__stdcall *PFNDRAWPRIMITIVE)(DWORD dwPrimCount,LPWORD pIndices,DWORD dwStrides,LPBYTE pVertices);

// Check the return value and return if something wrong.
// Assume hr has been declared
#define HR_RET(exp)       \
{                         \
    hr = (exp);           \
    if (hr != D3D_OK)     \
    {                     \
        return hr;        \
    }                     \
}

// FVF related macros
#define FVF_TRANSFORMED(dwFVF)          ((dwFVF & D3DFVF_POSITION_MASK) == D3DFVF_XYZRHW)
#define FVF_TEXCOORD_NUMBER(dwFVF)      (((dwFVF) & D3DFVF_TEXCOUNT_MASK) >> D3DFVF_TEXCOUNT_SHIFT)
#define NV_VERTEX_TRANSFORMED(pVShader) (((pVShader->hasProgram() == FALSE) && (pVShader->getVASize(defaultInputRegMap[D3DVSDE_POSITION]) == 4*sizeof(DWORD))) ? TRUE : FALSE)

// page constants
#ifndef PAGE_MASK
#define PAGE_MASK   0xFFFFF000
#endif
#ifndef PAGE_SIZE
#define PAGE_SIZE   0x00001000
#endif

#endif  // _NVDINC_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\ddraw\common\inc\nvEnable.h ===
// (C) Copyright NVIDIA Corporation Inc., 1996,1998. All rights reserved.

/********************************* Direct 3D *******************************\
*                                                                           *
* Module: nvEnable.h                                                        *
*    Definition file for:                                                   *
*       enablec.c and disablec.c                                            *
*    Suggested new name for combined file:                                  *
*       nvEnable.c                                                          *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*       Paul van der Kouwe          6/15/99 - Created                       *
*                                                                           *
\***************************************************************************/

#ifndef _NVENABLE_H_
#define _NVENABLE_H_

#ifdef __cplusplus
extern "C" {
#endif // __cplusplus

// public
BOOL           nvEnable32                           (LPDDRAWI_DIRECTDRAW_GBL pDDGbl);
BOOL __stdcall nvDisable32                          (void);
BOOL           nvEnableD3D                          (void);
BOOL           nvInitD3DObjects                     (void);
void           nvDisableD3D                         (void);
void           nvCreateVidHeapVarsAndPseudoNotifier (void);
BOOL           nvCreateDACObjects                   (DWORD dwChannel, DWORD dwHandle);

#ifdef __cplusplus
}
#endif // __cplusplus

#endif // _NVENABLE_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\ddraw\common\inc\nvFlipper.h ===
// **************************************************************************
//
//       Copyright 1993-1999 NVIDIA, Corporation.  All rights reserved.
//
//     NOTICE TO USER:   The source code  is copyrighted under  U.S. and
//     international laws.  Users and possessors of this source code are
//     hereby granted a nonexclusive,  royalty-free copyright license to
//     use this code in individual and commercial software.
//
//     Any use of this source code must include,  in the user documenta-
//     tion and  internal comments to the code,  notices to the end user
//     as follows:
//
//       Copyright 1993-1999 NVIDIA, Corporation.  All rights reserved.
//
//     NVIDIA, CORPORATION MAKES NO REPRESENTATION ABOUT THE SUITABILITY
//     OF  THIS SOURCE  CODE  FOR ANY PURPOSE.  IT IS  PROVIDED  "AS IS"
//     WITHOUT EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORPOR-
//     ATION DISCLAIMS ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,
//     INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY, NONINFRINGE-
//     MENT,  AND FITNESS  FOR A PARTICULAR PURPOSE.   IN NO EVENT SHALL
//     NVIDIA, CORPORATION  BE LIABLE FOR ANY SPECIAL,  INDIRECT,  INCI-
//     DENTAL, OR CONSEQUENTIAL DAMAGES,  OR ANY DAMAGES  WHATSOEVER RE-
//     SULTING FROM LOSS OF USE,  DATA OR PROFITS,  WHETHER IN AN ACTION
//     OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,  ARISING OUT OF
//     OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOURCE CODE.
//
//     U.S. Government  End  Users.   This source code  is a "commercial
//     item,"  as that  term is  defined at  48 C.F.R. 2.101 (OCT 1995),
//     consisting  of "commercial  computer  software"  and  "commercial
//     computer  software  documentation,"  as such  terms  are  used in
//     48 C.F.R. 12.212 (SEPT 1995)  and is provided to the U.S. Govern-
//     ment only as  a commercial end item.   Consistent with  48 C.F.R.
//     12.212 and  48 C.F.R. 227.7202-1 through  227.7202-4 (JUNE 1995),
//     all U.S. Government End Users  acquire the source code  with only
//     those rights set forth herein.
//
// ********************************* Direct 3D ******************************
//
//  Module: nvFlipper.h
//      a flipping class, for use with kelvin-style semaphores
//      (possibly to be expanded to handle flipping more generally)
//
// **************************************************************************
//
//  History:
//      Craig Duttweiler        26Jun2000         created, NV20 development
//
// **************************************************************************

#ifndef __NVFLIPPER_H
#define __NVFLIPPER_H

#if (NVARCH >= 0x020)
#ifdef KELVIN_SEMAPHORES

#define FLIPPER_MAX_CHAIN_SIZE 16

//---------------------------------------------------------------------------

class CFlipper
{

private:

    const enum {
        SEMAPHORE_READY_FOR_RENDER  = 0,
        SEMAPHORE_READY_FOR_SCANOUT = 1,
        SEMAPHORE_FLIP_COMPLETE     = 2
    };

    CSemaphore      *m_ppSemaphores[FLIPPER_MAX_CHAIN_SIZE];
    DWORD            m_dwFlipChainSize;
    DWORD            m_dwIndex;

public:

    BOOL create     (void);
    BOOL destroy    (void);
    BOOL init       (DWORD dwChainSize);
    BOOL flip       (CPushBuffer *pPusher3D,
                     CPushBuffer *pPusherDAC,
                     LPDDRAWI_DDRAWSURFACE_LCL pSurfCurr,
                     LPDDRAWI_DDRAWSURFACE_LCL pSurfTarg,
                     BOOL bNoVSync);

    CFlipper()      {   m_dwFlipChainSize = 0;
                        m_dwIndex         = 0;    }

    ~CFlipper()     {}
};

#endif  // KELVIN_SEMAPHORES
#endif  // NVARCH >= 0x020
#endif  // __NVFLIPPER_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\ddraw\common\inc\nvdp2ops.h ===
/*
 * Copyright 1993-1998 NVIDIA, Corporation.  All rights reserved.
 * THE INFORMATION CONTAINED HEREIN IS PROPRIETARY AND CONFIDENTIAL TO
 * NVIDIA, CORPORATION.  USE, REPRODUCTION OR DISCLOSURE TO ANY THIRD PARTY
 * IS SUBJECT TO WRITTEN PRE-APPROVAL BY NVIDIA, CORPORATION.
 */
/********************************* Direct 3D *******************************\
*                                                                           *
* Module: NVDP2OPS.H                                                        *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*       Craig Duttweiler    bertrem     02June99    created                 *
*                                                                           *
\***************************************************************************/

#ifndef _NVDP2OPS_H
#define _NVDP2OPS_H

#ifdef __cplusplus
extern "C" {
#endif

extern nvDP2FunctionTable nvDP2SetFuncs;
extern nvDP2FunctionTable nvDP2RecordFuncs;
extern nvDP2FunctionTable nvDP2CaptureFuncs;

// prototypes
HRESULT nvDP2Points (NV_DP2FUNCTION_ARGLIST);
HRESULT nvDP2IndexedLineList (NV_DP2FUNCTION_ARGLIST);
HRESULT nvDP2IndexedTriangleList (NV_DP2FUNCTION_ARGLIST);
HRESULT nvDP2LineList (NV_DP2FUNCTION_ARGLIST);
HRESULT nvDP2LineStrip (NV_DP2FUNCTION_ARGLIST);
HRESULT nvDP2IndexedLineStrip (NV_DP2FUNCTION_ARGLIST);
HRESULT nvDP2TriangleList (NV_DP2FUNCTION_ARGLIST);
HRESULT nvDP2TriangleStrip (NV_DP2FUNCTION_ARGLIST);
HRESULT nvDP2IndexedTriangleStrip (NV_DP2FUNCTION_ARGLIST);
HRESULT nvDP2TriangleFan (NV_DP2FUNCTION_ARGLIST);
HRESULT nvDP2IndexedTriangleFan (NV_DP2FUNCTION_ARGLIST);
HRESULT nvDP2TriangleFanImm (NV_DP2FUNCTION_ARGLIST);
HRESULT nvDP2LineListImm (NV_DP2FUNCTION_ARGLIST);
HRESULT nvDP2IndexedTriangleList2 (NV_DP2FUNCTION_ARGLIST);
HRESULT nvDP2IndexedLineList2 (NV_DP2FUNCTION_ARGLIST);
HRESULT nvDP2SetRenderState (NV_DP2FUNCTION_ARGLIST);
HRESULT nvDP2NOP (NV_DP2FUNCTION_ARGLIST);
HRESULT nvDP2SetTextureStageState (NV_DP2FUNCTION_ARGLIST);
HRESULT nvDP2SetViewport (NV_DP2FUNCTION_ARGLIST);
HRESULT nvDP2SetWRange (NV_DP2FUNCTION_ARGLIST);
HRESULT nvDP2SetZRange (NV_DP2FUNCTION_ARGLIST);
HRESULT nvDP2SetPalette (NV_DP2FUNCTION_ARGLIST);
HRESULT nvDP2UpdatePalette (NV_DP2FUNCTION_ARGLIST);
HRESULT nvDP2SetMaterial (NV_DP2FUNCTION_ARGLIST);
HRESULT nvDP2SetLight (NV_DP2FUNCTION_ARGLIST);
HRESULT nvDP2CreateLight (NV_DP2FUNCTION_ARGLIST);
HRESULT nvDP2SetTransform (NV_DP2FUNCTION_ARGLIST);
HRESULT nvDP2Extension (NV_DP2FUNCTION_ARGLIST);
HRESULT nvDP2TexBlt (NV_DP2FUNCTION_ARGLIST);
HRESULT nvDP2StateSet (NV_DP2FUNCTION_ARGLIST);
HRESULT nvDP2SetPriority (NV_DP2FUNCTION_ARGLIST);
HRESULT nvDP2SetRenderTarget (NV_DP2FUNCTION_ARGLIST);
HRESULT nvDP2Clear (NV_DP2FUNCTION_ARGLIST);
HRESULT nvDP2SetTexLOD (NV_DP2FUNCTION_ARGLIST);
HRESULT nvDP2SetClipPlane (NV_DP2FUNCTION_ARGLIST);
HRESULT nvDP2StreamEnd (NV_DP2FUNCTION_ARGLIST);
HRESULT nvDP2VolumeBlt (NV_DP2FUNCTION_ARGLIST);
HRESULT nvDP2BufferBlt (NV_DP2FUNCTION_ARGLIST);

HRESULT nvDP2RecordSetRenderState (NV_DP2FUNCTION_ARGLIST);
HRESULT nvDP2RecordSetTextureStageState (NV_DP2FUNCTION_ARGLIST);
HRESULT nvDP2RecordSetViewport (NV_DP2FUNCTION_ARGLIST);
HRESULT nvDP2RecordSetWRange (NV_DP2FUNCTION_ARGLIST);
HRESULT nvDP2RecordSetZRange (NV_DP2FUNCTION_ARGLIST);
HRESULT nvDP2RecordSetMaterial (NV_DP2FUNCTION_ARGLIST);
HRESULT nvDP2RecordSetLight (NV_DP2FUNCTION_ARGLIST);
HRESULT nvDP2RecordSetTransform (NV_DP2FUNCTION_ARGLIST);
HRESULT nvDP2RecordExtension (NV_DP2FUNCTION_ARGLIST);
HRESULT nvDP2RecordSetClipPlane (NV_DP2FUNCTION_ARGLIST);

HRESULT nvDP2CaptureSetRenderState (NV_DP2FUNCTION_ARGLIST);
HRESULT nvDP2CaptureSetTextureStageState (NV_DP2FUNCTION_ARGLIST);
HRESULT nvDP2CaptureSetViewport (NV_DP2FUNCTION_ARGLIST);
HRESULT nvDP2CaptureSetWRange (NV_DP2FUNCTION_ARGLIST);
HRESULT nvDP2CaptureSetZRange (NV_DP2FUNCTION_ARGLIST);
HRESULT nvDP2CaptureSetMaterial (NV_DP2FUNCTION_ARGLIST);
HRESULT nvDP2CaptureSetLight (NV_DP2FUNCTION_ARGLIST);
HRESULT nvDP2CaptureSetTransform (NV_DP2FUNCTION_ARGLIST);
HRESULT nvDP2CaptureExtension (NV_DP2FUNCTION_ARGLIST);
HRESULT nvDP2CaptureSetClipPlane (NV_DP2FUNCTION_ARGLIST);

HRESULT nvDP2CreateVertexShader (NV_DP2FUNCTION_ARGLIST);
HRESULT nvDP2DeleteVertexShader (NV_DP2FUNCTION_ARGLIST);
HRESULT nvDP2SetVertexShader (NV_DP2FUNCTION_ARGLIST);
HRESULT nvDP2SetVertexShaderConst (NV_DP2FUNCTION_ARGLIST);

HRESULT nvDP2CreatePixelShader (NV_DP2FUNCTION_ARGLIST);
HRESULT nvDP2DeletePixelShader (NV_DP2FUNCTION_ARGLIST);
HRESULT nvDP2SetPixelShader (NV_DP2FUNCTION_ARGLIST);

HRESULT nvDP2SetStreamSource (NV_DP2FUNCTION_ARGLIST);
HRESULT nvDP2SetStreamSourceUM (NV_DP2FUNCTION_ARGLIST);

HRESULT nvDP2SetIndices (NV_DP2FUNCTION_ARGLIST);

HRESULT nvDP2DrawPrimitive (NV_DP2FUNCTION_ARGLIST);
HRESULT nvDP2DrawIndexedPrimitive (NV_DP2FUNCTION_ARGLIST);

HRESULT nvDP2SetPixelShaderConst (NV_DP2FUNCTION_ARGLIST);
HRESULT nvDP2ClippedTriangleFan (NV_DP2FUNCTION_ARGLIST);
HRESULT nvDP2DrawPrimitive2 (NV_DP2FUNCTION_ARGLIST);
HRESULT nvDP2DrawIndexedPrimitive2 (NV_DP2FUNCTION_ARGLIST);
HRESULT nvDP2DrawRectSurface (NV_DP2FUNCTION_ARGLIST);
HRESULT nvDP2DrawTriSurface (NV_DP2FUNCTION_ARGLIST);

HRESULT nvDP2VolumeBlt (NV_DP2FUNCTION_ARGLIST);
HRESULT nvDP2BufferBlt (NV_DP2FUNCTION_ARGLIST);

HRESULT nvDP2RecordSetVertexShader (NV_DP2FUNCTION_ARGLIST);
HRESULT nvDP2RecordSetVertexShaderConst (NV_DP2FUNCTION_ARGLIST);
HRESULT nvDP2RecordSetStreamSource (NV_DP2FUNCTION_ARGLIST);
HRESULT nvDP2RecordSetStreamSourceUM (NV_DP2FUNCTION_ARGLIST);
HRESULT nvDP2RecordSetIndices (NV_DP2FUNCTION_ARGLIST);
HRESULT nvDP2RecordSetPixelShader (NV_DP2FUNCTION_ARGLIST);
HRESULT nvDP2RecordSetPixelShaderConst (NV_DP2FUNCTION_ARGLIST);

HRESULT nvDP2CaptureSetVertexShader (NV_DP2FUNCTION_ARGLIST);
HRESULT nvDP2CaptureSetVertexShaderConst (NV_DP2FUNCTION_ARGLIST);
HRESULT nvDP2CaptureSetStreamSource (NV_DP2FUNCTION_ARGLIST);
HRESULT nvDP2CaptureSetStreamSourceUM (NV_DP2FUNCTION_ARGLIST);
HRESULT nvDP2CaptureSetIndices (NV_DP2FUNCTION_ARGLIST);
HRESULT nvDP2CaptureSetPixelShader (NV_DP2FUNCTION_ARGLIST);
HRESULT nvDP2CaptureSetPixelShaderConst (NV_DP2FUNCTION_ARGLIST);

HRESULT nvDP2MultiplyTransform (NV_DP2FUNCTION_ARGLIST);
HRESULT nvDP2RecordMultiplyTransform (NV_DP2FUNCTION_ARGLIST);

#ifdef __cplusplus
}
#endif // __cplusplus

#endif // _NVDP2OPS_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\ddraw\common\inc\nvILHash.h ===
//                                                                             //
// (C) Copyright NVIDIA Corporation Inc., 1996,1997,1998. All rights reserved. //
//                                                                             //
////////////////////////////////// Direct 3D ////////////////////////////////////
//                                                                             //
// Module: nvILHash.h                                                          //
//   hash function for the dynamically compiled inner loops                    //
//                                                                             //
/////////////////////////////////////////////////////////////////////////////////
//                                                                             //
// History:                                                                    //
//       Paul van der Kouwe 12/13/99 - created.                                //
//                                                                             //
/////////////////////////////////////////////////////////////////////////////////

#ifndef _NVILHASH_H_
#define _NVILHASH_H_

/////////////////////////////////////////////////////////////////////////////////
// structures
//
class CILHashEntry
{
private:
    DWORD         m_dwRenderClass;  // the class for which this loop was built
    DWORD         m_dwOffset;
    CILHashEntry *m_pNext;

    // common parameters
    DWORD m_dwVertexType;
    union
    {
        // NV4 unique parameters
        struct
        {
            DWORD        m_dwFLUI;
            DWORD        m_dwTextureOrder;
        };
        // celsius unique parameters
        struct
        {
            DWORD        m_dwFlags;
            DWORD        m_dwSTILFlags;
            DWORD        m_dwVertexStride;
            VASOURCEINFO m_vaSourceData[NV_CAPS_MAX_STREAMS];  // sources of the data loaded into the 16 vertex attribute registers
            DWORD        m_dwStateFlags;
            DWORD        m_dwTexUnitToTexStageMapping[2];
            DWORD        m_dwTexCoordIndices;
            DWORD        m_dwTexTransformFlags[4];
        };
    };

public:
    inline DWORD           getOffset (void)   const { return m_dwOffset; }
    inline CILHashEntry*   getNext   (void)   const { return m_pNext;    }

    // NV4 constuctor
    inline CILHashEntry
    (
        DWORD         dwFLUI,
        DWORD         dwVertexType,
        DWORD         dwTextureOrder,
        DWORD         dwOffset,
        CILHashEntry* pNext
    )
    {
        m_dwRenderClass  = NVCLASS_FAMILY_DXTRI;
        m_dwFLUI         = dwFLUI;
        m_dwVertexType   = dwVertexType;
        m_dwTextureOrder = dwTextureOrder;

        m_dwOffset       = dwOffset;
        m_pNext          = pNext;
    }

    inline BOOL match (DWORD dwFLUI, DWORD dwVertexType, DWORD dwTextureOrder) const
    {
        return (m_dwRenderClass  == NVCLASS_FAMILY_DXTRI)
            && (m_dwFLUI         == dwFLUI)
            && (m_dwVertexType   == dwVertexType)
            && (m_dwTextureOrder == dwTextureOrder);
    }

    // celsius/kelvin constructor
    inline CILHashEntry
    (
        PNVD3DCONTEXT   pContext,
        DWORD           dwClass,
        DWORD           dwFlags,
        DWORD           dwOffset,
        CILHashEntry*   pNext
    )
    {
        m_dwRenderClass = dwClass;

#if (NVARCH >= 0x020)
        if (dwClass == NVCLASS_FAMILY_KELVIN) {
            m_dwFlags           = dwFlags;
            m_dwVertexStride    = pContext->pCurrentVShader->getStride();
            m_dwSTILFlags       = pContext->hwState.SuperTri.dwSTILFlags;
            m_dwStateFlags      = pContext->hwState.dwStateFlags & KELVIN_MASK_INNERLOOPUNIQUENESS;
            m_dwTexCoordIndices = pContext->hwState.dwTexCoordIndices;
            nvMemCopy (m_dwTexUnitToTexStageMapping, pContext->hwState.dwTexUnitToTexStageMapping, sizeof(m_dwTexUnitToTexStageMapping));
            nvMemCopy (m_vaSourceData, pContext->pCurrentVShader->m_vaSourceData, sizeof(m_vaSourceData));
        }
        else
#endif
#if (NVARCH >= 0x010)
        if (dwClass == NVCLASS_FAMILY_CELSIUS) {
            m_dwFlags           = dwFlags;
            m_dwSTILFlags       = pContext->hwState.SuperTri.dwSTILFlags;
            m_dwVertexStride    = pContext->pCurrentVShader->getStride();
            m_dwStateFlags      = pContext->hwState.dwStateFlags & CELSIUS_MASK_INNERLOOPUNIQUENESS;
            m_dwTexCoordIndices = pContext->hwState.dwTexCoordIndices;
            nvMemCopy (m_dwTexUnitToTexStageMapping,pContext->hwState.dwTexUnitToTexStageMapping,sizeof(m_dwTexUnitToTexStageMapping));
            nvMemCopy (m_vaSourceData, pContext->pCurrentVShader->m_vaSourceData, sizeof(m_vaSourceData));
            if (m_dwStateFlags & (CELSIUS_FLAG_TEXMATRIXSWFIX(0) | CELSIUS_FLAG_TEXMATRIXSWFIX(1))) {
                m_dwTexTransformFlags[0] = pContext->tssState[0].dwValue[D3DTSS_TEXTURETRANSFORMFLAGS];
                m_dwTexTransformFlags[1] = pContext->tssState[1].dwValue[D3DTSS_TEXTURETRANSFORMFLAGS];
                m_dwTexTransformFlags[2] = pContext->tssState[2].dwValue[D3DTSS_TEXTURETRANSFORMFLAGS];
                m_dwTexTransformFlags[3] = pContext->tssState[3].dwValue[D3DTSS_TEXTURETRANSFORMFLAGS];
            }
        }
        else
#endif  // NVARCH >= 0x010
        {
            DPF ("unknown class in CILHashEntry::CILHashEntry");
            dbgD3DError();
        }

        m_dwOffset       = dwOffset;
        m_pNext          = pNext;
    }

    // celsius / kelvin match function
    inline BOOL match
    (
        PNVD3DCONTEXT pContext,
        DWORD         dwClass,
        DWORD         dwFlags
    )
    const
    {
#if (NVARCH >= 0x020)
        if (m_dwRenderClass == NVCLASS_FAMILY_KELVIN) {
            return ((m_dwFlags           == dwFlags)
                 && (m_dwSTILFlags       == pContext->hwState.SuperTri.dwSTILFlags)
                 && (m_dwVertexStride    == pContext->pCurrentVShader->getStride())
                 && (m_dwStateFlags      == (pContext->hwState.dwStateFlags & KELVIN_MASK_INNERLOOPUNIQUENESS))
                 && (m_dwTexCoordIndices == pContext->hwState.dwTexCoordIndices)
                 && !memcmp(m_dwTexUnitToTexStageMapping, pContext->hwState.dwTexUnitToTexStageMapping, sizeof(m_dwTexUnitToTexStageMapping))
                 && !memcmp(m_vaSourceData, pContext->pCurrentVShader->m_vaSourceData, sizeof(m_vaSourceData)));
        }
        else
#endif
#if (NVARCH >= 0x010)
        if (m_dwRenderClass == NVCLASS_FAMILY_CELSIUS) {
#if 0       // SK - will re-enable this in R7 after some additional work
            // SK - todo: Simplify this further.
            if ((pContext->dwEarlyCopyStrategy) && (dwFlags & CELSIUS_ILMASK_LOOPTYPE) == CELSIUS_ILFLAG_SUPER_TRI_LIST) 
            {
                if (!(pContext->hwState.SuperTri.dwSTILFlags & NV_STILFLAG_STDEFVB)) 
                {
                    return (m_dwSTILFlags == pContext->hwState.SuperTri.dwSTILFlags);                
                }
                else
                {
                    return ((m_dwSTILFlags == pContext->hwState.SuperTri.dwSTILFlags) 
                            && (m_dwVertexStride == pContext->hwState.SuperTri.getSTLBStride()));                
                }
            }
            else 
#endif
            {
                return ((m_dwFlags           == dwFlags)
                     && (m_dwSTILFlags       == pContext->hwState.SuperTri.dwSTILFlags)
                     && (m_dwVertexStride    == pContext->pCurrentVShader->getStride())
                     && (m_dwStateFlags      == (pContext->hwState.dwStateFlags & CELSIUS_MASK_INNERLOOPUNIQUENESS))
                     && (m_dwTexCoordIndices == pContext->hwState.dwTexCoordIndices)
                     && !memcmp(m_dwTexUnitToTexStageMapping, pContext->hwState.dwTexUnitToTexStageMapping, sizeof(m_dwTexUnitToTexStageMapping))
                     && !memcmp(m_vaSourceData, pContext->pCurrentVShader->m_vaSourceData, sizeof(m_vaSourceData))
                     && (!(m_dwStateFlags & (CELSIUS_FLAG_TEXMATRIXSWFIX(0) | CELSIUS_FLAG_TEXMATRIXSWFIX(1)))
                         ||
                         ((m_dwTexTransformFlags[0] == pContext->tssState[0].dwValue[D3DTSS_TEXTURETRANSFORMFLAGS]) &&
                          (m_dwTexTransformFlags[1] == pContext->tssState[1].dwValue[D3DTSS_TEXTURETRANSFORMFLAGS]) &&
                          (m_dwTexTransformFlags[2] == pContext->tssState[2].dwValue[D3DTSS_TEXTURETRANSFORMFLAGS]) &&
                          (m_dwTexTransformFlags[3] == pContext->tssState[3].dwValue[D3DTSS_TEXTURETRANSFORMFLAGS]))));
            }
        }
        else
#endif  // NVARCH >= 0x010
        {
            DPF ("unknown class in CILHashEntry::match");
            dbgD3DError();
            return (FALSE);
        }
    }

};

#endif // _NVILHASH_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\ddraw\common\inc\nvHeap.h ===
/***************************************************************************\
|*                                                                           *|
|*       Copyright 1993-1999 NVIDIA, Corporation.  All rights reserved.      *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.  Users and possessors of this source code are     *|
|*     hereby granted a nonexclusive,  royalty-free copyright license to     *|
|*     use this code in individual and commercial software.                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*       Copyright 1993-1999 NVIDIA, Corporation.  All rights reserved.      *|
|*                                                                           *|
|*     NVIDIA, CORPORATION MAKES NO REPRESENTATION ABOUT THE SUITABILITY     *|
|*     OF  THIS SOURCE  CODE  FOR ANY PURPOSE.  IT IS  PROVIDED  "AS IS"     *|
|*     WITHOUT EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORPOR-     *|
|*     ATION DISCLAIMS ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,     *|
|*     INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY, NONINFRINGE-     *|
|*     MENT,  AND FITNESS  FOR A PARTICULAR PURPOSE.   IN NO EVENT SHALL     *|
|*     NVIDIA, CORPORATION  BE LIABLE FOR ANY SPECIAL,  INDIRECT,  INCI-     *|
|*     DENTAL, OR CONSEQUENTIAL DAMAGES,  OR ANY DAMAGES  WHATSOEVER RE-     *|
|*     SULTING FROM LOSS OF USE,  DATA OR PROFITS,  WHETHER IN AN ACTION     *|
|*     OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,  ARISING OUT OF     *|
|*     OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOURCE CODE.     *|
|*                                                                           *|
|*     U.S. Government  End  Users.   This source code  is a "commercial     *|
|*     item,"  as that  term is  defined at  48 C.F.R. 2.101 (OCT 1995),     *|
|*     consisting  of "commercial  computer  software"  and  "commercial     *|
|*     computer  software  documentation,"  as such  terms  are  used in     *|
|*     48 C.F.R. 12.212 (SEPT 1995)  and is provided to the U.S. Govern-     *|
|*     ment only as  a commercial end item.   Consistent with  48 C.F.R.     *|
|*     12.212 and  48 C.F.R. 227.7202-1 through  227.7202-4 (JUNE 1995),     *|
|*     all U.S. Government End Users  acquire the source code  with only     *|
|*     those rights set forth herein.                                        *|
|*                                                                           *|
 \***************************************************************************/

 /********************************* Direct 3D *******************************\
*                                                                           *
* Module: NVHEAP.H                                                          *
*   Heap allocation stuff                                                   *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*       Craig Duttweiler        bertrem     16Jul99     created             *
*       Ben de Waal                         27Jul99     add CHeap class     *
*                                                                           *
\***************************************************************************/

#ifndef _NVHEAP_H_
#define _NVHEAP_H_

#ifndef __cplusplus
#error C++ compiler required
#endif

extern "C"
{

extern NVOS11_PARAMETERS HeapParams;

// define to disable tiled memory
//#define HEAP_DISABLE_TILING
//#define CHEAP_SANITY_CHECK      // check integrity

#define HEAP_ALLOC_DEPTH_WIDTH_HEIGHT        1
#define HEAP_ALLOC_SIZE                      2
#define HEAP_FREE                            3
#define HEAP_PURGE                           4
#define HEAP_INFO                            5
#define HEAP_ALLOC_TILED_PITCH_HEIGHT        6

#define TYPE_IMAGE                           0
#define TYPE_DEPTH                           1
#define TYPE_TEXTURE                         2
#define TYPE_OVERLAY                         3
#define TYPE_FONT                            4
#define TYPE_CURSOR                          5
#define TYPE_DMA                             6
#define TYPE_INSTANCE                        7
#define TYPE_VERTEX                          2  // same as texture for now. differentiate later
#define MEM_TYPE_PRIMARY                     8
#define MEM_TYPE_IMAGE_TILED                 9
#define TYPE_DEPTH_COMPR16                   10
#define TYPE_DEPTH_COMPR32                   11

#define STATUS_SUCCESS                       (0x00000000)
#define STATUS_ERROR_INSUFFICIENT_RESOURCES  (0x00000001)
#define STATUS_ERROR_INVALID_FUNCTION        (0x00000002)
#define STATUS_ERROR_INVALID_OWNER           (0x00000003)

//
// Heap manager interface.
//
//extern void __stdcall NvIoControl(DWORD, PVOID);

#define DX_HEAP_ID  'NVDX'

#ifndef WINNT

// parameter values
#define NVHEAP_PURGE()                                          \
{                                                               \
    HeapParams.hRoot = pDriverData->dwRootHandle;               \
    HeapParams.hObjectParent = NV_WIN_DEVICE;                   \
    HeapParams.function = HEAP_PURGE;                           \
    HeapParams.owner    = DX_HEAP_ID;                           \
    HeapParams.status = NvRmArchHeap((ULONG) HeapParams.hRoot, (ULONG) HeapParams.hObjectParent, (ULONG) HeapParams.function, (ULONG) HeapParams.owner,HeapParams.type,HeapParams.height,HeapParams.size, (ULONG *)&HeapParams.pitch, &HeapParams.offset, &HeapParams.address, &HeapParams.limit, &HeapParams.free, &HeapParams.total); \
}

#define NVHEAP_INFO()                                           \
{                                                               \
    HeapParams.hRoot = pDriverData->dwRootHandle;               \
    HeapParams.hObjectParent = NV_WIN_DEVICE;                   \
    HeapParams.function = HEAP_INFO;                            \
    HeapParams.owner    = DX_HEAP_ID;                           \
    HeapParams.status = NvRmArchHeap((ULONG) HeapParams.hRoot, (ULONG) HeapParams.hObjectParent, (ULONG) HeapParams.function, (ULONG) HeapParams.owner,HeapParams.type,HeapParams.height,HeapParams.size, (ULONG *)&HeapParams.pitch, &HeapParams.offset, &HeapParams.address, &HeapParams.limit, &HeapParams.free, &HeapParams.total); \
    if (pDriverData && !pDriverData->DDrawVideoSurfaceCount) {  \
        pDriverData->VideoHeapOverhead = HeapParams.total - HeapParams.free; \
    }                                                           \
}

#define NVHEAP_ALLOC(sts,pvm,sz,tp)                             \
{                                                               \
    HeapParams.hRoot = pDriverData->dwRootHandle;               \
    HeapParams.hObjectParent = NV_WIN_DEVICE;                   \
    HeapParams.function = HEAP_ALLOC_SIZE;                      \
    HeapParams.owner    = DX_HEAP_ID;                           \
    HeapParams.type     = (tp);                                 \
    HeapParams.size     = (sz);                                 \
    HeapParams.status = NvRmArchHeap((ULONG) HeapParams.hRoot, (ULONG) HeapParams.hObjectParent, (ULONG) HeapParams.function, (ULONG) HeapParams.owner,HeapParams.type,HeapParams.height,HeapParams.size, (ULONG *)&HeapParams.pitch, &HeapParams.offset, &HeapParams.address, &HeapParams.limit, &HeapParams.free, &HeapParams.total); \
    (sts) = HeapParams.status;                                  \
    (pvm) = (unsigned long)(HeapParams.address);                \
    pDriverData->VideoHeapFree = HeapParams.free;               \
}

#define NVHEAP_ALLOC_B(sts,pvm,sz,tp)                           \
{                                                               \
    HeapParams.hRoot = pDriverData->dwRootHandle;               \
    HeapParams.hObjectParent = NV_WIN_DEVICE;                   \
    HeapParams.function = HEAP_ALLOC_SIZE;                      \
    HeapParams.owner    = DX_HEAP_ID;                           \
    HeapParams.type     = (tp);                                 \
    HeapParams.size     = (sz);                                 \
    HeapParams.status = NvRmArchHeap((ULONG) HeapParams.hRoot, (ULONG) HeapParams.hObjectParent, (ULONG) HeapParams.function, (ULONG) HeapParams.owner,HeapParams.type,HeapParams.height,HeapParams.size, (ULONG *)&HeapParams.pitch, &HeapParams.offset, &HeapParams.address, &HeapParams.limit, &HeapParams.free, &HeapParams.total); \
    (sts) = HeapParams.status;                                  \
    (pvm) = (unsigned long)(HeapParams.address);                \
    pDriverData->VideoHeapFree = HeapParams.free;               \
}

#define NVHEAP_ALLOC_C(sts,pvm,sz,tp)                           \
{                                                               \
    HeapParams.hRoot = pDriverData->dwRootHandle;               \
    HeapParams.hObjectParent = NV_WIN_DEVICE;                   \
    HeapParams.function = HEAP_ALLOC_SIZE;                      \
    HeapParams.owner    = DX_HEAP_ID;                           \
    HeapParams.type     = (tp);                                 \
    HeapParams.size     = (sz);                                 \
    HeapParams.status = NvRmArchHeap((ULONG) HeapParams.hRoot, (ULONG) HeapParams.hObjectParent, (ULONG) HeapParams.function, (ULONG) HeapParams.owner,HeapParams.type,HeapParams.height,HeapParams.size, (ULONG *)&HeapParams.pitch, &HeapParams.offset, &HeapParams.address, &HeapParams.limit, &HeapParams.free, &HeapParams.total); \
    (sts) = HeapParams.status;                                  \
    (pvm) = (unsigned long)(HeapParams.address);                \
    pDriverData->VideoHeapFree = HeapParams.free;               \
}

#ifndef HEAP_DISABLE_TILING
#define NVHEAP_ALLOC_TILED(sts,pvm,pch,ht,tp)                   \
{                                                               \
    HeapParams.hRoot = pDriverData->dwRootHandle;               \
    HeapParams.hObjectParent = NV_WIN_DEVICE;                   \
    HeapParams.function = HEAP_ALLOC_TILED_PITCH_HEIGHT;        \
    HeapParams.owner    = DX_HEAP_ID;                           \
    HeapParams.type     = (tp);                                 \
    HeapParams.pitch    = (pch);                                \
    HeapParams.height   = (ht);                                 \
    HeapParams.status = NvRmArchHeap((ULONG) HeapParams.hRoot, (ULONG) HeapParams.hObjectParent, (ULONG) HeapParams.function, (ULONG) HeapParams.owner,HeapParams.type,HeapParams.height,HeapParams.size, (ULONG *)&HeapParams.pitch, &HeapParams.offset, &HeapParams.address, &HeapParams.limit, &HeapParams.free, &HeapParams.total); \
    (sts) = HeapParams.status;                                  \
    (pvm) = (unsigned long)(HeapParams.address);                \
    (pch) = HeapParams.pitch;                                   \
    pDriverData->VideoHeapFree = HeapParams.free;               \
}
#else
#define NVHEAP_ALLOC_TILED(sts,pvm,pch,ht,tp) NVHEAP_ALLOC(sts,pvm,pch,ht,tp)
#endif

#define NVHEAP_FREE(pvm)                                        \
{                                                               \
    HeapParams.hRoot = pDriverData->dwRootHandle;               \
    HeapParams.hObjectParent = NV_WIN_DEVICE;                   \
    HeapParams.function = HEAP_FREE;                            \
    HeapParams.owner    = DX_HEAP_ID;                           \
    HeapParams.offset   = (U032)(pvm) - pDriverData->BaseAddress;\
    HeapParams.status = NvRmArchHeap((ULONG) HeapParams.hRoot, (ULONG) HeapParams.hObjectParent, (ULONG) HeapParams.function, (ULONG) HeapParams.owner,HeapParams.type,HeapParams.height,HeapParams.size, (ULONG *)&HeapParams.pitch, &HeapParams.offset, &HeapParams.address, &HeapParams.limit, &HeapParams.free, &HeapParams.total); \
    pDriverData->VideoHeapFree = HeapParams.free;               \
}
#else   // WINNT

#define NVHEAP_PURGE() // NT never does a purge!

#define NVHEAP_INFO()                                           \
{                                                               \
    PVOID pParms = (PVOID) &HeapParams;                         \
    DWORD cbReturned;                                           \
                                                                \
    HeapParams.hRoot = ppdev->hClient;                          \
    HeapParams.hObjectParent = ppdev->hDevice;                  \
    HeapParams.function = HEAP_INFO;                            \
    HeapParams.owner    = 'NVDD';                               \
    EngDeviceIoControl(                                         \
        ppdev->hDriver,                                         \
        (DWORD)IOCTL_NV01_ARCH_HEAP,                            \
        (&pParms),                                              \
        sizeof(PVOID),                                          \
        pParms,                                                 \
        sizeof(NVOS11_PARAMETERS),                              \
        &cbReturned                                             \
    );                                                          \
    if (pDriverData) {                                          \
        if (!pDriverData->DDrawVideoSurfaceCount)               \
        {                                                       \
            pDriverData->VideoHeapOverhead = HeapParams.total - \
            HeapParams.free - ppdev->cbGdiHeap;                 \
        }                                                       \
        ppdev->VideoHeapTotal = HeapParams.total;               \
        ppdev->VideoHeapFree = HeapParams.free;                 \
    }                                                           \
    HeapParams.address = 0;                                     \
}


#define NVHEAP_ALLOC(sts,pvm,sz,tp)                             \
{                                                               \
    NVOS11_PARAMETERS   HeapParams;                             \
    PVOID pParms = (PVOID) &HeapParams;                         \
    DWORD cbReturned;                                           \
                                                                \
    if (pDriverData && !pDriverData->DDrawVideoSurfaceCount && !ppdev->cbGdiHeap)    \
    {                                                           \
        ppdev->cbGdiHeap = ppdev->VideoHeapTotal -              \
            ppdev->VideoHeapFree;                               \
    }                                                           \
                                                                \
    HeapParams.hRoot = ppdev->hClient;                          \
    HeapParams.hObjectParent = ppdev->hDevice;                  \
    HeapParams.function = HEAP_ALLOC_SIZE;                      \
    HeapParams.owner    = 'NVDD';                               \
    HeapParams.type     = (tp);                                 \
    HeapParams.size     = (sz);                                 \
    EngDeviceIoControl(                                         \
        ppdev->hDriver,                                         \
        (DWORD)IOCTL_NV01_ARCH_HEAP,                            \
        (&pParms),                                              \
        sizeof(PVOID),                                          \
        pParms,                                                 \
        sizeof(NVOS11_PARAMETERS),                              \
        &cbReturned                                             \
    );                                                          \
    (sts) = HeapParams.status;                                  \
    (pvm) = (unsigned long)(HeapParams.offset);                 \
                                                                \
    if (sts && ppdev->cbGdiHeap)                                \
    {                                                           \
        bMoveAllDfbsFromOffscreenToDibs(ppdev);                 \
        HeapParams.hRoot = ppdev->hClient;                      \
        HeapParams.hObjectParent = ppdev->hDevice;              \
        HeapParams.function = HEAP_ALLOC_SIZE;                  \
        HeapParams.owner    = 'NVDD';                           \
        HeapParams.type     = (tp);                             \
        HeapParams.size     = (sz);                             \
        EngDeviceIoControl(                                     \
            ppdev->hDriver,                                     \
            (DWORD)IOCTL_NV01_ARCH_HEAP,                        \
            (&pParms),                                          \
            sizeof(PVOID),                                      \
            pParms,                                             \
            sizeof(NVOS11_PARAMETERS),                          \
            &cbReturned                                         \
        );                                                      \
        (sts) = HeapParams.status;                              \
        (pvm) = (unsigned long)(HeapParams.offset);             \
        pDriverData->VideoHeapFree =                            \
            ppdev->VideoHeapFree;                               \
    }                                                           \
                                                                \
    if (!(sts)) {                                               \
        ppdev->VideoHeapFree = HeapParams.free;                 \
        pDriverData->VideoHeapFree =                            \
            HeapParams.free + ppdev->cbGdiHeap;                 \
    }                                                           \
}

#define NVHEAP_ALLOC_B(sts,pvm,sz,tp)                           \
{                                                               \
    NVOS11_PARAMETERS   HeapParams;                             \
    PVOID pParms = (PVOID) &HeapParams;                         \
    DWORD cbReturned;                                           \
                                                                \
    if (pDriverData && !pDriverData->DDrawVideoSurfaceCount && !ppdev->cbGdiHeap)    \
    {                                                           \
        ppdev->cbGdiHeap = ppdev->VideoHeapTotal -              \
            ppdev->VideoHeapFree;                               \
    }                                                           \
                                                                \
    HeapParams.hRoot = ppdev->hClient;                          \
    HeapParams.hObjectParent = ppdev->hDevice;                  \
    HeapParams.function = HEAP_ALLOC_SIZE;                      \
    HeapParams.owner    = 'NVDD';                               \
    HeapParams.type     = (tp);                                 \
    HeapParams.size     = (sz);                                 \
    EngDeviceIoControl(                                         \
        ppdev->hDriver,                                         \
        (DWORD)IOCTL_NV01_ARCH_HEAP,                            \
        (&pParms),                                              \
        sizeof(PVOID),                                          \
        pParms,                                                 \
        sizeof(NVOS11_PARAMETERS),                              \
        &cbReturned                                             \
    );                                                          \
    (sts) = HeapParams.status;                                  \
    (pvm) = (unsigned long)(HeapParams.offset);                 \
                                                                \
    if (sts && ppdev->cbGdiHeap)                                \
    {                                                           \
        bMoveAllDfbsFromOffscreenToDibs(ppdev);                 \
        HeapParams.hRoot = ppdev->hClient;                      \
        HeapParams.hObjectParent = ppdev->hDevice;              \
        HeapParams.function = HEAP_ALLOC_SIZE;                  \
        HeapParams.owner    = 'NVDD';                           \
        HeapParams.type     = (tp);                             \
        HeapParams.size     = (sz);                             \
        EngDeviceIoControl(                                     \
            ppdev->hDriver,                                     \
            (DWORD)IOCTL_NV01_ARCH_HEAP,                        \
            (&pParms),                                          \
            sizeof(PVOID),                                      \
            pParms,                                             \
            sizeof(NVOS11_PARAMETERS),                          \
            &cbReturned                                         \
        );                                                      \
        (sts) = HeapParams.status;                              \
        (pvm) = (unsigned long)(HeapParams.offset);             \
        pDriverData->VideoHeapFree =                            \
            ppdev->VideoHeapFree;                               \
    }                                                           \
                                                                \
    if (!(sts)) {                                               \
        ppdev->VideoHeapFree = HeapParams.free;                 \
        pDriverData->VideoHeapFree =                            \
            HeapParams.free + ppdev->cbGdiHeap;                 \
    }                                                           \
}

#define NVHEAP_ALLOC_C(sts,pvm,sz,tp)                           \
{                                                               \
    NVOS11_PARAMETERS   HeapParams;                             \
    PVOID pParms = (PVOID) &HeapParams;                         \
    DWORD cbReturned;                                           \
                                                                \
    if (pDriverData && !pDriverData->DDrawVideoSurfaceCount && !ppdev->cbGdiHeap)    \
    {                                                           \
        ppdev->cbGdiHeap = ppdev->VideoHeapTotal -              \
            ppdev->VideoHeapFree;                               \
    }                                                           \
                                                                \
    HeapParams.hRoot = ppdev->hClient;                          \
    HeapParams.hObjectParent = ppdev->hDevice;                  \
    HeapParams.function = HEAP_ALLOC_SIZE;                      \
    HeapParams.owner    = 'NVDD';                               \
    HeapParams.type     = (tp);                                 \
    HeapParams.size     = (sz);                                 \
    EngDeviceIoControl(                                         \
        ppdev->hDriver,                                         \
        (DWORD)IOCTL_NV01_ARCH_HEAP,                            \
        (&pParms),                                              \
        sizeof(PVOID),                                          \
        pParms,                                                 \
        sizeof(NVOS11_PARAMETERS),                              \
        &cbReturned                                             \
    );                                                          \
    (sts) = HeapParams.status;                                  \
    (pvm) = (unsigned long)(HeapParams.offset);                 \
                                                                \
    if (sts && ppdev->cbGdiHeap)                                \
    {                                                           \
        bMoveAllDfbsFromOffscreenToDibs(ppdev);                 \
        HeapParams.hRoot = ppdev->hClient;                      \
        HeapParams.hObjectParent = ppdev->hDevice;              \
        HeapParams.function = HEAP_ALLOC_SIZE;                  \
        HeapParams.owner    = 'NVDD';                           \
        HeapParams.type     = (tp);                             \
        HeapParams.size     = (sz);                             \
        EngDeviceIoControl(                                     \
            ppdev->hDriver,                                     \
            (DWORD)IOCTL_NV01_ARCH_HEAP,                        \
            (&pParms),                                          \
            sizeof(PVOID),                                      \
            pParms,                                             \
            sizeof(NVOS11_PARAMETERS),                          \
            &cbReturned                                         \
        );                                                      \
        (sts) = HeapParams.status;                              \
        (pvm) = (unsigned long)(HeapParams.offset);             \
        pDriverData->VideoHeapFree =                            \
            ppdev->VideoHeapFree;                               \
    }                                                           \
                                                                \
    if (!(sts)) {                                               \
        ppdev->VideoHeapFree = HeapParams.free;                 \
        pDriverData->VideoHeapFree =                            \
            HeapParams.free + ppdev->cbGdiHeap;                 \
    }                                                           \
}

#ifndef HEAP_DISABLE_TILING
#define NVHEAP_ALLOC_TILED(sts,pvm,pch,ht,tp)                   \
{                                                               \
    NVOS11_PARAMETERS   HeapParams;                             \
    PVOID pParms = (PVOID) &HeapParams;                         \
    DWORD cbReturned;                                           \
                                                                \
    if (pDriverData && !pDriverData->DDrawVideoSurfaceCount && !ppdev->cbGdiHeap)    \
    {                                                           \
        ppdev->cbGdiHeap = ppdev->VideoHeapTotal -              \
            ppdev->VideoHeapFree;                               \
    }                                                           \
                                                                \
    HeapParams.hRoot = ppdev->hClient;                          \
    HeapParams.hObjectParent = ppdev->hDevice;                  \
    HeapParams.function = HEAP_ALLOC_TILED_PITCH_HEIGHT;        \
    HeapParams.owner    = 'NVDD';                               \
    HeapParams.type     = (tp);                                 \
    HeapParams.pitch    = (pch);                                \
    HeapParams.height   = (ht);                                 \
    EngDeviceIoControl(                                         \
        ppdev->hDriver,                                         \
        (DWORD)IOCTL_NV01_ARCH_HEAP,                            \
        (&pParms),                                              \
        sizeof(PVOID),                                          \
        pParms,                                                 \
        sizeof(NVOS11_PARAMETERS),                              \
        &cbReturned                                             \
    );                                                          \
    (sts) = HeapParams.status;                                  \
    (pvm) = ((DWORD) HeapParams.address - (DWORD) ppdev->pjFrameBufbase);  \
                                                                \
    if (sts && ppdev->cbGdiHeap)                                \
    {                                                           \
        bMoveAllDfbsFromOffscreenToDibs(ppdev);                 \
        HeapParams.hRoot = ppdev->hClient;                      \
        HeapParams.hObjectParent = ppdev->hDevice;              \
        HeapParams.function = HEAP_ALLOC_TILED_PITCH_HEIGHT;    \
        HeapParams.owner    = 'NVDD';                           \
        HeapParams.type     = (tp);                             \
        HeapParams.pitch    = (pch);                            \
        HeapParams.height   = (ht);                             \
        EngDeviceIoControl(                                     \
            ppdev->hDriver,                                     \
            (DWORD)IOCTL_NV01_ARCH_HEAP,                        \
            (&pParms),                                          \
            sizeof(PVOID),                                      \
            pParms,                                             \
            sizeof(NVOS11_PARAMETERS),                          \
            &cbReturned                                         \
        );                                                      \
        (sts) = HeapParams.status;                              \
        (pvm) = ((DWORD) HeapParams.address - (DWORD) ppdev->pjFrameBufbase);  \
        pDriverData->VideoHeapFree =                            \
            ppdev->VideoHeapFree;                               \
    }                                                           \
                                                                \
    if (!(sts)) {                                               \
        (pch) = HeapParams.pitch;                               \
        ppdev->VideoHeapFree = HeapParams.free;                 \
        pDriverData->VideoHeapFree =                            \
            HeapParams.free + ppdev->cbGdiHeap;                 \
    }                                                           \
}

#else // HEAP_DISABLE_TILING
#define NVHEAP_ALLOC_TILED(sts,pvm,pch,ht,tp) NVHEAP_ALLOC(sts,pvm,pch*ht,tp)
#endif

#define NVHEAP_FREE(pvm)                                        \
{                                                               \
    NVOS11_PARAMETERS HeapParams;                               \
    PVOID pParms = (PVOID) &HeapParams;                         \
    DWORD cbReturned;                                           \
    HeapParams.hRoot = ppdev->hClient;                          \
    HeapParams.hObjectParent = ppdev->hDevice;                  \
    HeapParams.function = HEAP_FREE;                            \
    HeapParams.owner    = 'NVDD';                               \
    HeapParams.offset   = (U032)(pvm);                          \
    EngDeviceIoControl(                                         \
        ppdev->hDriver,                                         \
        (DWORD)IOCTL_NV01_ARCH_HEAP,                            \
        (&pParms),                                              \
        sizeof(PVOID),                                          \
        pParms,                                                 \
        sizeof(NVOS11_PARAMETERS),                              \
        &cbReturned                                             \
    );                                                          \
    if (!HeapParams.status) {                                   \
        ppdev->VideoHeapFree = HeapParams.free;                 \
        pDriverData->VideoHeapFree =                            \
            HeapParams.free + ppdev->cbGdiHeap;                 \
    }                                                           \
}

#endif  // WINNT

#define AGP_HEAP 0

}

/*****************************************************************************
 *****************************************************************************
 *****************************************************************************
 ***  CInterProcessHeap ******************************************************
 *****************************************************************************
 *****************************************************************************
 *****************************************************************************/
class CInterProcessHeap
{
    /*
     * internal flags
     */
protected:
    enum
    {
        FLAG_ALLOCATED      = 0x00000001,   // this block is allocated
        FLAG_BOUNDARY       = 0x00000002,   // start of a new block
        FLAG_16BIT          = 0x00000004,   // this block was allocated from 16 bit land

        ALIGN               = 64,           // byte alignment (power of 2)
    };

    /*
     * internal structures
     */
protected:
    struct HEADER
    {
        HEADER *pNext;          // next block
        HEADER *pNextFree;      // next free block
        HEADER *pPrev;          // prev block
        HEADER *pPrevFree;      // prev free block
        DWORD   dwFlags;        // state
        DWORD   dwUserStart;    // start of user memory
        DWORD   dwUserSize;     // size of user memory
        DWORD   dwRealSize;     // size of this block + headers
        DWORD   dwRMID;         // RM ID of mem block, only if alloc'd directly by OS
#ifdef DEBUG
        void   *pCaller;        // pointer to allocation requester
#endif
        // NOTE!!! the dwReserved entry must appear last in this structure
        DWORD   dwReserved;     // may be used by back pointer - depends on alignment
    };


    /*
     * internal members
     */
protected:
    static BOOL m_bInitialized;

protected:
    HEADER *m_pBase;            // 1st block
    HEADER *m_pBaseFree;        // 1st free block
    DWORD   m_dwRMID;
#ifndef WINNT
    DWORD   m_dwRootHandle;     // root handle
    DWORD   m_dwDeviceHandle;   // device handle
#endif

    /*
     * internal helpers
     */
protected:
    inline BOOL isBoundary (HEADER *p) const { return p->dwFlags & FLAG_BOUNDARY;     }
    inline BOOL isFree     (HEADER *p) const { return !(p->dwFlags & FLAG_ALLOCATED); }
    inline BOOL isAlloc    (HEADER *p) const { return p->dwFlags & FLAG_ALLOCATED;    }

    inline void AddToList(HEADER *pHeader) {
        pHeader->pPrev = NULL;
        pHeader->pNext = m_pBase;
        if (m_pBase) m_pBase->pPrev = pHeader;
        m_pBase = pHeader;
    }
    inline void RemoveFromList(HEADER *pHeader) {
        if (pHeader->pNext)     pHeader->pNext->pPrev = pHeader->pPrev;
        if (pHeader->pPrev)     pHeader->pPrev->pNext = pHeader->pNext;
        if (m_pBase == pHeader) m_pBase = pHeader->pNext;
    }
    inline void AddToFreeList(HEADER *pHeader) {
        pHeader->pPrevFree = NULL;
        pHeader->pNextFree = m_pBaseFree;
        if (m_pBaseFree) m_pBaseFree->pPrevFree = pHeader;
        m_pBaseFree = pHeader;
    }
    inline void RemoveFromFreeList(HEADER *pHeader) {
        if (pHeader->pNextFree)     pHeader->pNextFree->pPrevFree = pHeader->pPrevFree;
        if (pHeader->pPrevFree)     pHeader->pPrevFree->pNextFree = pHeader->pNextFree;
        if (m_pBaseFree == pHeader) m_pBaseFree = pHeader->pNextFree;
    }
    inline void CInterProcessHeap::freeBlock(HEADER *pHeader);

#ifdef CHEAP_SANITY_CHECK
           void dbgTestIntegrity (void);
#else
    inline void dbgTestIntegrity (void) const {}
#endif
    HEADER* create            (DWORD dwSize);
    void combineFreeBlocks (void);
    void releaseFreeBlocks (void);

    /*
     * public methods
     */
public:
    void  init    (void);
    void  destroy (void);
    void  checkHeapUsage (void);

#ifdef DEBUG
    void* alloc   (DWORD dwSize, void *pCaller = 0);
#else
    void* alloc   (DWORD dwSize);
#endif
    BOOL  realloc (void *pOldMem, DWORD dwNewSize, void **pNewMem);
    void  free    (void *pMemory);
};

//
// exports
//
extern CInterProcessHeap g_nvIPHeap;

inline void  InitIPM          (void)                { g_nvIPHeap.init();    }
inline void  DestroyIPM       (void)                { g_nvIPHeap.destroy(); }

inline void* AllocIPM         (DWORD dwSize)        { return g_nvIPHeap.alloc(dwSize); }
inline BOOL  ReallocIPM       (void *pOldMem, DWORD dwNewSize, void **ppNewMem) {
                                                      return g_nvIPHeap.realloc(pOldMem, dwNewSize, ppNewMem); }
inline void  FreeIPM          (void *pMemory)       { g_nvIPHeap.free(pMemory); }

//for interfacing with the vertex shader compilers
inline void* glLikeAllocIPM (void *bogus, size_t szSize) { return g_nvIPHeap.alloc((DWORD)szSize); }
inline void glLikeFreeIPM (void *bogus, void* pMemory) { g_nvIPHeap.free(pMemory); }

// all new & deletes use IPM
inline void* _cdecl operator new    (size_t nSize)  { return g_nvIPHeap.alloc(nSize); }
inline void  _cdecl operator delete (void *p)       { if (p) g_nvIPHeap.free(p);      }

// multi heap versions of new & delete
//inline void* _cdecl operator new    (size_t nSize, CInterProcessHeap* pHeap) { return pHeap->alloc(nSize); }
//inline void  _cdecl operator delete (void *p, CInterProcessHeap* pHeap)      { if (p) pHeap->free(p);      }

#endif  // _NVHEAP_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\ddraw\common\inc\nvFormats.h ===
// **************************************************************************
//
//       Copyright 1993-1999 NVIDIA, Corporation.  All rights reserved.
//
//     NOTICE TO USER:   The source code  is copyrighted under  U.S. and
//     international laws.  Users and possessors of this source code are
//     hereby granted a nonexclusive,  royalty-free copyright license to
//     use this code in individual and commercial software.
//
//     Any use of this source code must include,  in the user documenta-
//     tion and  internal comments to the code,  notices to the end user
//     as follows:
//
//       Copyright 1993-1999 NVIDIA, Corporation.  All rights reserved.
//
//     NVIDIA, CORPORATION MAKES NO REPRESENTATION ABOUT THE SUITABILITY
//     OF  THIS SOURCE  CODE  FOR ANY PURPOSE.  IT IS  PROVIDED  "AS IS"
//     WITHOUT EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORPOR-
//     ATION DISCLAIMS ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,
//     INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY, NONINFRINGE-
//     MENT,  AND FITNESS  FOR A PARTICULAR PURPOSE.   IN NO EVENT SHALL
//     NVIDIA, CORPORATION  BE LIABLE FOR ANY SPECIAL,  INDIRECT,  INCI-
//     DENTAL, OR CONSEQUENTIAL DAMAGES,  OR ANY DAMAGES  WHATSOEVER RE-
//     SULTING FROM LOSS OF USE,  DATA OR PROFITS,  WHETHER IN AN ACTION
//     OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,  ARISING OUT OF
//     OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOURCE CODE.
//
//     U.S. Government  End  Users.   This source code  is a "commercial
//     item,"  as that  term is  defined at  48 C.F.R. 2.101 (OCT 1995),
//     consisting  of "commercial  computer  software"  and  "commercial
//     computer  software  documentation,"  as such  terms  are  used in
//     48 C.F.R. 12.212 (SEPT 1995)  and is provided to the U.S. Govern-
//     ment only as  a commercial end item.   Consistent with  48 C.F.R.
//     12.212 and  48 C.F.R. 227.7202-1 through  227.7202-4 (JUNE 1995),
//     all U.S. Government End Users  acquire the source code  with only
//     those rights set forth herein.
//
// ********************************* Direct 3D ******************************
//
//  Module: nvFormats.h
//      prototypes and definitions for nvFormats.cpp
//
// **************************************************************************
//
//  History:
//      Craig Duttweiler        05Mar2001         creation
//
// **************************************************************************

#ifndef __FORMATS_H
#define __FORMATS_H

// prototypes
BOOL nvEnumerateFourCCs        (void);
BOOL nvEnumerateSurfaceFormats (void);

#endif // __FORMATS_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\ddraw\common\inc\nvLight.h ===
///////////////////////////////////////////////////////////////////////////////
// Copyright (C) Microsoft Corporation, 1998.
//
// reftnl.h
//
// Direct3D Reference Transform and Lighting - Main Header File
//
///////////////////////////////////////////////////////////////////////////////

#ifndef  _REFTNL_H
#define  _REFTNL_H

#ifdef __cplusplus
extern "C" {
#endif

// Default color values that should be used when ther is no lighting and
// color in vertices provided
#define D3D_DEFAULT_DIFFUSE  0xFFFFFFFF;
#define D3D_DEFAULT_SPECULAR 0;

struct _nvLight;

//---------------------------------------------------------------------
// NVLIGHTING
// All the lighting related state clubbed together
//---------------------------------------------------------------------

typedef struct {D3DVALUE r,g,b;} RGBCOLOR;

typedef struct _NVLIGHTING
{
    // Active Light list
    struct _nvLight *pActiveLights;

    // Ambient color set by D3DRENDERSTATE_AMBIENT
    // components are all scaled to 0 - 1
    D3DCOLORVALUE dcvAmbient;

} NVLIGHTING;

//-----------------------------------------------------------------------------
//
// nvLight - The light object used by the Reference T&L implementation
// An array of these are instanced in the ReferenceRasterizer object.
//
//-----------------------------------------------------------------------------

// nvLight flags
#define NVLIGHT_DEFINED             0x00000001  // has this light been defined?
#define NVLIGHT_ENABLED             0x00000002  // Is the light active

typedef struct _expParams
{
    D3DVALUE L;
    D3DVALUE M;
    D3DVALUE N;
} expParams, *pexpParms;

typedef struct _nvLight
{
    DWORD            dwFlags;           // see above
    struct _nvLight *pNext;             // next active light
    D3DLIGHT7        Light7;            // Light data set by the runtime (unmodified!!)
    // derived data
    D3DVECTOR        direction;         // negated a la OGL and normalized
    expParams        falloffParams;     // spotlight falloff params
    D3DVALUE         dvScale;           // spotlight scale factor
    D3DVALUE         dvW;               // spotlight direction W
} nvLight, *pnvLight;

#ifdef __cplusplus
}
#endif

#endif // _REFTNL_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\ddraw\common\inc\nvPal.h ===
// **************************************************************************
//
//       Copyright 1993-1999 NVIDIA, Corporation.  All rights reserved.
//
//     NOTICE TO USER:   The source code  is copyrighted under  U.S. and
//     international laws.  Users and possessors of this source code are
//     hereby granted a nonexclusive,  royalty-free copyright license to
//     use this code in individual and commercial software.
//
//     Any use of this source code must include,  in the user documenta-
//     tion and  internal comments to the code,  notices to the end user
//     as follows:
//
//       Copyright 1993-1999 NVIDIA, Corporation.  All rights reserved.
//
//     NVIDIA, CORPORATION MAKES NO REPRESENTATION ABOUT THE SUITABILITY
//     OF  THIS SOURCE  CODE  FOR ANY PURPOSE.  IT IS  PROVIDED  "AS IS"
//     WITHOUT EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORPOR-
//     ATION DISCLAIMS ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,
//     INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY, NONINFRINGE-
//     MENT,  AND FITNESS  FOR A PARTICULAR PURPOSE.   IN NO EVENT SHALL
//     NVIDIA, CORPORATION  BE LIABLE FOR ANY SPECIAL,  INDIRECT,  INCI-
//     DENTAL, OR CONSEQUENTIAL DAMAGES,  OR ANY DAMAGES  WHATSOEVER RE-
//     SULTING FROM LOSS OF USE,  DATA OR PROFITS,  WHETHER IN AN ACTION
//     OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,  ARISING OUT OF
//     OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOURCE CODE.
//
//     U.S. Government  End  Users.   This source code  is a "commercial
//     item,"  as that  term is  defined at  48 C.F.R. 2.101 (OCT 1995),
//     consisting  of "commercial  computer  software"  and  "commercial
//     computer  software  documentation,"  as such  terms  are  used in
//     48 C.F.R. 12.212 (SEPT 1995)  and is provided to the U.S. Govern-
//     ment only as  a commercial end item.   Consistent with  48 C.F.R.
//     12.212 and  48 C.F.R. 227.7202-1 through  227.7202-4 (JUNE 1995),
//     all U.S. Government End Users  acquire the source code  with only
//     those rights set forth herein.
//
// **************************************************************************
//
//  Module: nvPal.h
//        Prototypes and definitions for nvPallette.cpp
//
//  History:
//        Daniel Rohrer
//
// **************************************************************************

#ifndef __NV_PAL_H_
#define __NV_PAL_H_

PNV_OBJECT_LIST  nvCreatePaletteList            (DWORD dwDDLclID);
BOOL             nvDeletePaletteList            (DWORD dwDDLclID);
BOOL             nvExpandPaletteList            (PNV_OBJECT_LIST pNvPaletteList, DWORD dwHandle);
PNV_OBJECT_LIST  nvFindPaletteList              (DWORD dwDDLclID);
CNvObject       *nvGetPaletteFromHandle         (DWORD dwDDLclID, DWORD dwHandle);
BOOL             nvClearPaletteListEntry        (CNvObject *pObj);
DWORD            nvAddPaletteToList             (PNV_OBJECT_LIST pNvPaletteList, CNvObject *pPal, DWORD dwHandle);

#endif // __NV_PAL_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\ddraw\common\inc\nvObjectLists.h ===
/*
 * (C) Copyright NVIDIA Corporation Inc., 1996,1997,1998. All rights reserved.
 */
/********************************* Direct 3D *******************************\
*                                                                           *
* Module: nvObjectLists.h                                                   *
*   Routines for management of NvObject lists added in DX7                  *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*       Paul van der Kouwe (paulvdk)   3 Mar 2001 created                   *
*                                                                           *
\***************************************************************************/

#ifndef _NVLIST_H_
#define _NVLIST_H_

#ifdef __cplusplus
extern "C" {
#endif
    
PNV_OBJECT_LIST  nvCreateObjectList       (DWORD dwDDLclID, NV_OBJECT_LIST **ppList);
BOOL             nvDeleteObjectList       (DWORD dwDDLclID, NV_OBJECT_LIST **ppList);
PNV_OBJECT_LIST  nvFindObjectList         (DWORD dwDDLclID, NV_OBJECT_LIST **ppList);
CNvObject       *nvGetObjectFromHandle    (DWORD dwDDLclID, DWORD dwHandle, NV_OBJECT_LIST **ppList);
BOOL             nvClearObjectListEntry   (CNvObject *pObj, NV_OBJECT_LIST **ppList);
DWORD            nvAddObjectToList        (PNV_OBJECT_LIST pNvGenObjList, CNvObject *pGenObj, DWORD dwHandle);

#ifdef __cplusplus
}
#endif // __cplusplus

#endif // _NVLIST_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\ddraw\common\inc\nvPalette.h ===
// **************************************************************************
//
//       Copyright 1993-1999 NVIDIA, Corporation.  All rights reserved.
//
//     NOTICE TO USER:   The source code  is copyrighted under  U.S. and
//     international laws.  Users and possessors of this source code are
//     hereby granted a nonexclusive,  royalty-free copyright license to
//     use this code in individual and commercial software.
//
//     Any use of this source code must include,  in the user documenta-
//     tion and  internal comments to the code,  notices to the end user
//     as follows:
//
//       Copyright 1993-1999 NVIDIA, Corporation.  All rights reserved.
//
//     NVIDIA, CORPORATION MAKES NO REPRESENTATION ABOUT THE SUITABILITY
//     OF  THIS SOURCE  CODE  FOR ANY PURPOSE.  IT IS  PROVIDED  "AS IS"
//     WITHOUT EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORPOR-
//     ATION DISCLAIMS ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,
//     INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY, NONINFRINGE-
//     MENT,  AND FITNESS  FOR A PARTICULAR PURPOSE.   IN NO EVENT SHALL
//     NVIDIA, CORPORATION  BE LIABLE FOR ANY SPECIAL,  INDIRECT,  INCI-
//     DENTAL, OR CONSEQUENTIAL DAMAGES,  OR ANY DAMAGES  WHATSOEVER RE-
//     SULTING FROM LOSS OF USE,  DATA OR PROFITS,  WHETHER IN AN ACTION
//     OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,  ARISING OUT OF
//     OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOURCE CODE.
//
//     U.S. Government  End  Users.   This source code  is a "commercial
//     item,"  as that  term is  defined at  48 C.F.R. 2.101 (OCT 1995),
//     consisting  of "commercial  computer  software"  and  "commercial
//     computer  software  documentation,"  as such  terms  are  used in
//     48 C.F.R. 12.212 (SEPT 1995)  and is provided to the U.S. Govern-
//     ment only as  a commercial end item.   Consistent with  48 C.F.R.
//     12.212 and  48 C.F.R. 227.7202-1 through  227.7202-4 (JUNE 1995),
//     all U.S. Government End Users  acquire the source code  with only
//     those rights set forth herein.
//
// **************************************************************************
//
//  Module: nvPal.h
//        Prototypes and definitions for nvPallette.cpp
//
//  History:
//        Daniel Rohrer
//
// **************************************************************************
#ifndef _nvPalette_h
#define _nvPalette_h

#ifndef __cplusplus
#error This file requires a C++ compiler
#endif

DWORD __stdcall CreatePalette32(LPDDHAL_CREATEPALETTEDATA lpDDCreatePaletteData);
DWORD __stdcall SetEntries32(LPDDHAL_SETENTRIESDATA lpDDSetEntriesData);
DWORD __stdcall SetPalette32(LPDDHAL_SETPALETTEDATA lpDDSetPaletteData);
DWORD __stdcall DestroyPalette32(LPDDHAL_DESTROYPALETTEDATA lpDDDestroyPaletteData);

DWORD nvSetEntries( DWORD dwPaletteHandle, DWORD dwNumEntries, DWORD dwStartIndex);
DWORD nvSetPalette( DWORD, CNvObject *, CNvObject*);

#endif //__nvPalette_h
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\ddraw\common\inc\nvmocomp.h ===
/***************************************************************************\
|*                                                                           *|
|*       Copyright 1993-2000 NVIDIA, Corporation.  All rights reserved.      *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.  Users and possessors of this source code are     *|
|*     hereby granted a nonexclusive,  royalty-free copyright license to     *|
|*     use this code in individual and commercial software.                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*       Copyright 1993-2000 NVIDIA, Corporation.  All rights reserved.      *|
|*                                                                           *|
|*     NVIDIA, CORPORATION MAKES NO REPRESENTATION ABOUT THE SUITABILITY     *|
|*     OF  THIS SOURCE  CODE  FOR ANY PURPOSE.  IT IS  PROVIDED  "AS IS"     *|
|*     WITHOUT EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORPOR-     *|
|*     ATION DISCLAIMS ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,     *|
|*     INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY, NONINFRINGE-     *|
|*     MENT,  AND FITNESS  FOR A PARTICULAR PURPOSE.   IN NO EVENT SHALL     *|
|*     NVIDIA, CORPORATION  BE LIABLE FOR ANY SPECIAL,  INDIRECT,  INCI-     *|
|*     DENTAL, OR CONSEQUENTIAL DAMAGES,  OR ANY DAMAGES  WHATSOEVER RE-     *|
|*     SULTING FROM LOSS OF USE,  DATA OR PROFITS,  WHETHER IN AN ACTION     *|
|*     OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,  ARISING OUT OF     *|
|*     OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOURCE CODE.     *|
|*                                                                           *|
|*     U.S. Government  End  Users.   This source code  is a "commercial     *|
|*     item,"  as that  term is  defined at  48 C.F.R. 2.101 (OCT 1995),     *|
|*     consisting  of "commercial  computer  software"  and  "commercial     *|
|*     computer  software  documentation,"  as such  terms  are  used in     *|
|*     48 C.F.R. 12.212 (SEPT 1995)  and is provided to the U.S. Govern-     *|
|*     ment only as  a commercial end item.   Consistent with  48 C.F.R.     *|
|*     12.212 and  48 C.F.R. 227.7202-1 through  227.7202-4 (JUNE 1995),     *|
|*     all U.S. Government End Users  acquire the source code  with only     *|
|*     those rights set forth herein.                                        *|
|*                                                                           *|
 \***************************************************************************/
/*==========================================================================;
 *
 *  Copyright (C) 2000 NVidia Corporation.  All Rights Reserved.
 *
 *  File:       nvmocomp.h
 *  Content:    Windows98 DDraw 32 bit driver motion compensation definitions
 *
 ***************************************************************************/

#ifndef _NVMOCOMP_H_
#define _NVMOCOMP_H_

#ifdef __cplusplus
extern "C" {
#endif

// Execute functions
#define EXECUTE_MOTION_COMPENSATION                 0
#define EXECUTE_TEMPORAL_FILTER                     1
#define EXECUTE_SUBPICTURE_DECOMPRESSION            2
#define EXECUTE_SUBPICTURE_COMPOSITING              3
#define EXECUTE_DISPLAY_OVERLAY_SURFACE             4
#define EXECUTE_FORMAT_CONVERT_OVERLAY_SURFACE      5
#define EXECUTE_NON_PREBIASED_MOTION_COMPENSATION   6
#define EXECUTE_DXVA_ALPHA_BLENDING                 7

// Temporal filter options
#define TEMPORAL_FILTER_ENABLE_ON_ALL_SURFACES      0
#define TEMPORAL_FILTER_DISABLE_ON_ALL_SURFACES     1
#define TEMPORAL_FILTER_DISABLE_ON_SINGLE_SURFACE   128

// PictureStructure
#define PICTURE_STRUCTURE_TOP_FIELD     1
#define PICTURE_STRUCTURE_BOTTOM_FIELD  2
#define PICTURE_STRUCTURE_FRAME         3

// PictureCodingType
#define PICTURE_TYPE_I                  1
#define PICTURE_TYPE_P                  2
#define PICTURE_TYPE_B                  3

// CodedBlockPattern
#define CBP_Y0                          32
#define CBP_Y1                          16
#define CBP_Y2                          8
#define CBP_Y3                          4
#define CBP_CB                          2
#define CBP_CR                          1

// DCTType
#define DCT_FRAME                       0
#define DCT_FIELD                       1

// MacroblockType
#define MB_INTRA                        0
#define MB_MOTION_FORWARD               1
#define MB_MOTION_BACKWARD              2

// MotionType
#define FRAME_STRUCTURE_MOTION_FIELD    1       // Field prediction
#define FRAME_STRUCTURE_MOTION_FRAME    2       // Frame prediction
#define FRAME_STRUCTURE_MOTION_DP       3       // Dual prime prediction
#define FIELD_STRUCTURE_MOTION_FIELD    1       // Field prediction
#define FIELD_STRUCTURE_MOTION_16X8     2       // 16x8 prediction
#define FIELD_STRUCTURE_MOTION_DP       3       // Dual prime prediction

// CorrectionType
#define CORRECTION_FIRST_PASS           0
#define CORRECTION_OVERFLOW_PASS        1

// VertexMode
#define VERTEX_MODE_FORWARD             1
#define VERTEX_MODE_BACKWARD            2
#define VERTEX_MODE_BIDIRECTIONAL       3

// DataFormat
#define DATA_FORMAT_LUMA                        1
#define DATA_FORMAT_CHROMA                      2
#define DATA_FORMAT_CORRECTION                  3
#define DATA_FORMAT_CHROMA_CORRECTION           4
#define DATA_FORMAT_UNBIASED_CORRECTION         5
#define DATA_FORMAT_UNBIASED_CHROMA_CORRECTION  6
#define DATA_FORMAT_FOURCC_CONVERSION           7
#define DATA_FORMAT_TEMPORAL_FILTER             8
#define DATA_FORMAT_SUBPICTURE_LUMA_BLEND       9
#define DATA_FORMAT_SUBPICTURE_CHROMA_BLEND     10

#define CELSIUS_DESTINATION_VIEWPORT_XOFFSET    (2046 << 2)
// Calculated for a scale factor of 75% ((2046/0.75) << 2)
#define SCALED_CELSIUS_DESTINATION_VIEWPORT_XOFFSET    (10912)

// DXVA Convert Buffer
#define LOOKUP_TABLE_OFFSET         0
#define LOOKUP_TABLE_SIZE           1024L
#define MACROBLOCKS_OFFSET          1024L
#define MACROBLOCKS_SIZE            1048576L
#define CONVERT_BUFFER_SIZE         LOOKUP_TABLE_SIZE + MACROBLOCKS_SIZE

// Other DXVA Constants
#define DXVA_SUBPICTURE_WIDTH       720L
#define DXVA_SUBPICTURE_HEIGHT      576L


// PMV[r][s][t] definitions
//      index   0                                   1
//
//      r       first motion vector in macroblock   second motion vector in macroblock (also indexes 2 and 3 in dual prime)
//      s       forward motion vector               backward motion vector
//      t       horizontal component                vertical component
//


typedef struct tagNVBEGINFRAMEDATA {
  BYTE  bMCPictureStructure;
  BYTE  bMCPictureCodingType;
  BYTE  bMCTopFieldFirst;
  BYTE  bMCSecondField;
  BYTE  bMCFrameType;
} NVBEGINFRAMEDATA, *LPNVBEGINFRAMEDATA;


typedef unsigned long (*PFUNC)();

typedef struct tagNVMCFRAMEDATA {
  PFUNC dwMCNvExecute;
  DWORD dwMCMultiMonID;
  BYTE  bMCDestinationSurfaceIndex;
  BYTE  bMCForwardSurfaceIndex;
  BYTE  bMCBackwardSurfaceIndex;
  BYTE  bMCPictureStructure;
  BYTE  bMCPictureCodingType;
  BYTE  bMCTopFieldFirst;
  BYTE  bMCSecondField;
  BYTE  bMCFrameType;
  BYTE  bMCEndOfPicture;

  // The following are reserved for NVDS proprietary interface.
  BYTE  bReserved1;
  BYTE  bReserved2;
  BYTE  bReserved3;
  DWORD dwReserved4;

  // The following are used by our DXVA functions only.
  WORD  wDXVADecodedPictureIndex;
  WORD  wDXVAForwardRefPictureIndex;
  WORD  wDXVABackwardRefPictureIndex;
  WORD  wDXVAPicWidthInMB;
  WORD  wDXVAPicHeightInMB;
  DWORD dwDXVASubpicBuffer;
  DWORD dwDXVASubpicStride;
  RECT  rcGraphicSourceRect;
  RECT  rcGraphicDestinationRect;
  BYTE  bBlendOn;

} NVMCFRAMEDATA, *LPNVMCFRAMEDATA;


typedef struct tagNVDECODEMACROBLOCK {
  short hOffset;            // upper left macroblock coordinates in pels
  short vOffset;            // upper left macroblock coordinates in scanlines
  unsigned short firstIDCTIndex;
  BYTE DCTType;
  BYTE codedBlockPattern;
  BYTE overflowCodedBlockPattern;
  BYTE motionType;
  short PMV[2][2][2];       // contains motion vectors in half pel units
  BYTE fieldSelect[2][2];
  BYTE macroblockType;
  BYTE pad0;                // currently unused
} NVDECODEMACROBLOCK, *LPNVDECODEMACROBLOCK;


typedef struct tagNVMCDISPLAYOVERLAYDATA {
    DWORD dwMCOverlayFlags; // DDOVER_INTERLEAVED, DDOVER_BOB, etc.
    DWORD dwMCFlipFlags;    // DDFLIP_ODD, DDFLIP_EVEN, DDFLIP_WAIT, etc.
} NVMCDISPLAYOVERLAYDATA, *LPNVMCDISPLAYOVERLAYDATA;


typedef struct tagNVMCFILTERDATA {
    BYTE bMCCurrentFieldCombinationFactor;      // 0 - 100 (%)
    BYTE bMCFilterOptions;                      // 0 == default == enable on all surfaces, 1 == disable on all surfaces
} NVMCFILTERDATA, *LPNVMCFILTERDATA;            // 128 == disable on dwSurfaceIndex only


typedef struct tagNVSPDECOMPRESSDATA {
    short wSPHOffset;
    short wSPVOffset;
    short wSPWidth;
    short wSPHeight;
    BYTE bSPUpdateLookUpTable; // TRUE == look up table has changed, FALSE == no look up table change
    BYTE bSPNumberOfActiveTableEntries; // 0 == 256, else 1 - 255
    BYTE bSPFormat;             // 0 == YUV, 1 == RGB
    BYTE bSPpad1;               // currently unused
    DWORD dwSPLookUpTable[256]; // byte format in each YUV DWORD is byte0 = V, byte1 = U, byte2 = Y, byte3 = X
                                // byte format in each RGB DWORD is byte0 = B, byte1 = G, byte2 = R, byte3 = X
} NVSPDECOMPRESSDATA, *LPNVSPDECOMPRESSDATA;


typedef struct tagNVSPCOMPOSITEDATA {
    short wSPHOffset;
    short wSPVOffset;
    short wSPWidth;
    short wSPHeight;
    short wMCHOffset;
    short wMCVOffset;
    short wMCWidth;
    short wMCHeight;
    BYTE bSPCompositeWith; // Frame/Top Field/Bottom Field
    BYTE bSPRestoreImageBeforeCompositing;
} NVSPCOMPOSITEDATA, *LPNVSPCOMPOSITEDATA;


typedef struct tagNVMOCOMPPARAMS {
  unsigned long surfaceLumaPitch;
  unsigned long surfaceLumaHeight;
  unsigned long surfaceOffset;
  unsigned long surfaceChromaOffset;
  unsigned long surfaceBiasedIntraBlockOffset;
  long blockX;
  long blockY;
  long blockY2;
  long correctionY;
  short blockWidth;
  short blockHeight;
  short forwardHorizontalVector;
  short forwardVerticalVector;
  short backwardHorizontalVector;
  short backwardVerticalVector;
  BYTE forwardField;
  BYTE backwardField;
  BYTE correctionField;
  BYTE destinationField;
  BYTE currentForwardField;
  BYTE currentBackwardField;
  BYTE currentDestinationField;
  BYTE destinationFieldIs0;
  short forwardHorizontalVector2;
  short forwardVerticalVector2;
  short backwardHorizontalVector2;
  short backwardVerticalVector2;
  BYTE forwardField2;
  BYTE backwardField2;
  BYTE correctionField2;
  BYTE destinationField2;
  BYTE vertexMode;
  BYTE dataFormat;
  short celsiusDestinationViewportXOffset;
  short celsiusFieldXOffset;
} NVMOCOMPPARAMS, *LPNVMOCOMPPARAMS;


#if (NVARCH >= 0x10)

typedef void (__stdcall *PNVMCPREDFUNC)(BOOL);
typedef DWORD (__stdcall *PNVMCPREDFUNC2)(LPNVDECODEMACROBLOCK, WORD);
typedef void (__stdcall *PNVMCCORRFUNC)(void);
typedef void (__stdcall *PNVMCCORRFUNC2)(long, long);

#define nvPushMoCompQuadData(OFFSET) do { \
    nvPushData((OFFSET), texture1BlockY0 | texture1BlockX0); \
    nvPushData((OFFSET+1), texture0BlockY0 | texture0BlockX0); \
    nvPushData((OFFSET+2), blockY0 | blockX0); \
    nvPushData((OFFSET+3), texture1BlockY1 | texture1BlockX0); \
    nvPushData((OFFSET+4), texture0BlockY1 | texture0BlockX0); \
    nvPushData((OFFSET+5), blockY1 | blockX0); \
    nvPushData((OFFSET+6), texture1BlockY1 | texture1BlockX1); \
    nvPushData((OFFSET+7), texture0BlockY1 | texture0BlockX1); \
    nvPushData((OFFSET+8), blockY1 | blockX1); \
    nvPushData((OFFSET+9), texture1BlockY0 | texture1BlockX1); \
    nvPushData((OFFSET+10), texture0BlockY0 | texture0BlockX1); \
    nvPushData((OFFSET+11), blockY0 | blockX1); \
} while(0)

#define nvPushKelvinMoCompQuadData(OFFSET) do { \
    nvPushData((OFFSET), blockY0 | blockX0); \
    nvPushData((OFFSET+1), texture0BlockY0 | texture0BlockX0); \
    nvPushData((OFFSET+2), texture1BlockY0 | texture1BlockX0); \
    nvPushData((OFFSET+3), blockY1 | blockX0); \
    nvPushData((OFFSET+4), texture0BlockY1 | texture0BlockX0); \
    nvPushData((OFFSET+5), texture1BlockY1 | texture1BlockX0); \
    nvPushData((OFFSET+6), blockY1 | blockX1); \
    nvPushData((OFFSET+7), texture0BlockY1 | texture0BlockX1); \
    nvPushData((OFFSET+8), texture1BlockY1 | texture1BlockX1); \
    nvPushData((OFFSET+9), blockY0 | blockX1); \
    nvPushData((OFFSET+10), texture0BlockY0 | texture0BlockX1); \
    nvPushData((OFFSET+11), texture1BlockY0 | texture1BlockX1); \
} while(0)



#define DEFAULT_ALPHA_ICW   (NV056_SET_COMBINER_ALPHA_ICW_A_MAP_UNSIGNED_IDENTITY << 29) |  \
                            (NV056_SET_COMBINER_ALPHA_ICW_A_ALPHA_TRUE << 28) |             \
                            (NV056_SET_COMBINER_ALPHA_ICW_A_SOURCE_REG_4 << 24) |           \
                                                                                            \
                            (NV056_SET_COMBINER_ALPHA_ICW_B_MAP_UNSIGNED_INVERT << 21) |    \
                            (NV056_SET_COMBINER_ALPHA_ICW_B_ALPHA_TRUE << 20) |             \
                            (NV056_SET_COMBINER_ALPHA_ICW_B_SOURCE_REG_0 << 16) |           \
                                                                                            \
                            (NV056_SET_COMBINER_ALPHA_ICW_C_MAP_UNSIGNED_IDENTITY << 13) |  \
                            (NV056_SET_COMBINER_ALPHA_ICW_C_ALPHA_TRUE << 12) |             \
                            (NV056_SET_COMBINER_ALPHA_ICW_C_SOURCE_REG_0 << 8) |            \
                                                                                            \
                            (NV056_SET_COMBINER_ALPHA_ICW_D_MAP_UNSIGNED_IDENTITY << 5) |   \
                            (NV056_SET_COMBINER_ALPHA_ICW_D_ALPHA_TRUE << 4) |              \
                             NV056_SET_COMBINER_ALPHA_ICW_D_SOURCE_REG_0

#define DEFAULT_COLOR_ICW   (NV056_SET_COMBINER_COLOR_ICW_A_MAP_UNSIGNED_IDENTITY << 29) |  \
                            (NV056_SET_COMBINER_COLOR_ICW_A_ALPHA_FALSE << 28) |            \
                            (NV056_SET_COMBINER_COLOR_ICW_A_SOURCE_REG_4 << 24) |           \
                                                                                            \
                            (NV056_SET_COMBINER_COLOR_ICW_B_MAP_UNSIGNED_INVERT << 21) |    \
                            (NV056_SET_COMBINER_COLOR_ICW_B_ALPHA_FALSE << 20) |            \
                            (NV056_SET_COMBINER_COLOR_ICW_B_SOURCE_REG_0 << 16) |           \
                                                                                            \
                            (NV056_SET_COMBINER_COLOR_ICW_C_MAP_UNSIGNED_IDENTITY << 13) |  \
                            (NV056_SET_COMBINER_COLOR_ICW_C_ALPHA_FALSE << 12) |            \
                            (NV056_SET_COMBINER_COLOR_ICW_C_SOURCE_REG_0 << 8) |            \
                                                                                            \
                            (NV056_SET_COMBINER_COLOR_ICW_D_MAP_UNSIGNED_IDENTITY << 5) |   \
                            (NV056_SET_COMBINER_COLOR_ICW_D_ALPHA_FALSE << 4) |             \
                             NV056_SET_COMBINER_COLOR_ICW_D_SOURCE_REG_0

#define DEFAULT_ALPHA_OCW   (NV056_SET_COMBINER_ALPHA_OCW_OPERATION_NOSHIFT << 15) |        \
                            (NV056_SET_COMBINER_ALPHA_OCW_MUX_ENABLE_FALSE << 14) |         \
                            (NV056_SET_COMBINER_ALPHA_OCW_SUM_DST_REG_C << 8) |             \
                            (NV056_SET_COMBINER_ALPHA_OCW_AB_DST_REG_0 << 4) |              \
                             NV056_SET_COMBINER_ALPHA_OCW_CD_DST_REG_0

#define DEFAULT_C1_COLOR_OCW (NV056_SET_COMBINER1_COLOR_OCW_ITERATION_COUNT_ONE << 28) |    \
                             (NV056_SET_COMBINER1_COLOR_OCW_MUX_SELECT_MSB << 27) |         \
                             (NV056_SET_COMBINER1_COLOR_OCW_OPERATION_NOSHIFT << 15) |      \
                             (NV056_SET_COMBINER1_COLOR_OCW_MUX_ENABLE_FALSE << 14) |       \
                             (NV056_SET_COMBINER1_COLOR_OCW_AB_DOT_ENABLE_FALSE << 13) |    \
                             (NV056_SET_COMBINER1_COLOR_OCW_CD_DOT_ENABLE_FALSE << 12) |    \
                             (NV056_SET_COMBINER1_COLOR_OCW_SUM_DST_REG_C << 8) |           \
                             (NV056_SET_COMBINER1_COLOR_OCW_AB_DST_REG_0 << 4) |            \
                              NV056_SET_COMBINER1_COLOR_OCW_CD_DST_REG_0

#define SET_LUMA_DATA_FORMAT() do { \
    if (nvMoCompParams.dataFormat != DATA_FORMAT_LUMA) { \
        nvMoCompParams.dataFormat = DATA_FORMAT_LUMA; \
        nvPushData(0, dDrawSubchannelOffset(NV_DD_CELSIUS) + \
                      NV056_SET_SURFACE_FORMAT | 0x40000); \
        nvPushData(1, (NV056_SET_SURFACE_FORMAT_TYPE_PITCH << 8) | \
                      NV056_SET_SURFACE_FORMAT_COLOR_LE_B8); \
        nvPushData(2, dDrawSubchannelOffset(NV_DD_CELSIUS) + \
                      NV056_SET_TEXTURE_FORMAT(0) | 0x80000); \
        nvPushData(3, (NV056_SET_TEXTURE_FORMAT_WRAPV_FALSE << 31) | \
                      (NV056_SET_TEXTURE_FORMAT_TEXTUREADDRESSV_CLAMP << 28) | \
                      (NV056_SET_TEXTURE_FORMAT_WRAPU_FALSE << 27) | \
                      (NV056_SET_TEXTURE_FORMAT_TEXTUREADDRESSU_CLAMP << 24) | \
                      (1 << 12) | \
                      (NV056_SET_TEXTURE_FORMAT_COLOR_LE_IMAGE_Y8 << 7) | \
                      (NV056_SET_TEXTURE_FORMAT_ORIGIN_FOH_CORNER << 5) | \
                      (NV056_SET_TEXTURE_FORMAT_ORIGIN_ZOH_CORNER << 3) | \
                      (NV056_SET_TEXTURE_FORMAT_CUBEMAP_ENABLE_FALSE << 2) | \
                       NV056_SET_TEXTURE_FORMAT_CONTEXT_DMA_A); \
        nvPushData(4, (NV056_SET_TEXTURE_FORMAT_WRAPV_FALSE << 31) | \
                      (NV056_SET_TEXTURE_FORMAT_TEXTUREADDRESSV_CLAMP << 28) | \
                      (NV056_SET_TEXTURE_FORMAT_WRAPU_FALSE << 27) | \
                      (NV056_SET_TEXTURE_FORMAT_TEXTUREADDRESSU_CLAMP << 24) | \
                      (1 << 12) | \
                      (NV056_SET_TEXTURE_FORMAT_COLOR_LE_IMAGE_Y8 << 7) | \
                      (NV056_SET_TEXTURE_FORMAT_ORIGIN_FOH_CORNER << 5) | \
                      (NV056_SET_TEXTURE_FORMAT_ORIGIN_ZOH_CORNER << 3) | \
                      (NV056_SET_TEXTURE_FORMAT_CUBEMAP_ENABLE_FALSE << 2) | \
                       NV056_SET_TEXTURE_FORMAT_CONTEXT_DMA_A); \
        nvPusherAdjust(5); \
    } \
} while(0)

#define SET_KELVIN_LUMA_DATA_FORMAT() do { \
    if (nvMoCompParams.dataFormat != DATA_FORMAT_LUMA) { \
        nvMoCompParams.dataFormat = DATA_FORMAT_LUMA; \
        nvPushData(0, dDrawSubchannelOffset(NV_DD_KELVIN) + \
                      NV097_SET_SURFACE_FORMAT | 0x40000); \
        nvPushData(1, (NV097_SET_SURFACE_FORMAT_ANTI_ALIASING_CENTER_1 << 12) | \
                      (NV097_SET_SURFACE_FORMAT_TYPE_PITCH << 8) | \
                      (NV097_SET_SURFACE_FORMAT_ZETA_Z16 << 4) | \
                       NV097_SET_SURFACE_FORMAT_COLOR_LE_B8); \
        nvPushData(2, dDrawSubchannelOffset(NV_DD_KELVIN) + \
                      NV097_SET_TEXTURE_FORMAT(0) | 0x40000); \
        nvPushData(3, (1 << 16) | \
                      (NV097_SET_TEXTURE_FORMAT_COLOR_LU_IMAGE_Y8 << 8) | \
                      (NV097_SET_TEXTURE_FORMAT_DIMENSIONALITY_TWO << 4) | \
                      (NV097_SET_TEXTURE_FORMAT_BORDER_SOURCE_COLOR << 3) | \
                      (NV097_SET_TEXTURE_FORMAT_CUBEMAP_ENABLE_FALSE << 2) | \
                       NV097_SET_TEXTURE_FORMAT_CONTEXT_DMA_A); \
        nvPushData(4, dDrawSubchannelOffset(NV_DD_KELVIN) + \
                      NV097_SET_TEXTURE_FORMAT(1) | 0x40000); \
        nvPushData(5, (1 << 16) | \
                      (NV097_SET_TEXTURE_FORMAT_COLOR_LU_IMAGE_Y8 << 8) | \
                      (NV097_SET_TEXTURE_FORMAT_DIMENSIONALITY_TWO << 4) | \
                      (NV097_SET_TEXTURE_FORMAT_BORDER_SOURCE_COLOR << 3) | \
                      (NV097_SET_TEXTURE_FORMAT_CUBEMAP_ENABLE_FALSE << 2) | \
                       NV097_SET_TEXTURE_FORMAT_CONTEXT_DMA_A); \
        nvPusherAdjust(6); \
    } \
} while(0)

#define SET_CHROMA_DATA_FORMAT() do { \
    if (nvMoCompParams.dataFormat != DATA_FORMAT_CHROMA) { \
        nvMoCompParams.dataFormat = DATA_FORMAT_CHROMA; \
        nvPushData(0, dDrawSubchannelOffset(NV_DD_CELSIUS) + \
                      NV056_SET_SURFACE_FORMAT | 0x40000); \
        nvPushData(1, (NV056_SET_SURFACE_FORMAT_TYPE_PITCH << 8) | \
                      NV056_SET_SURFACE_FORMAT_COLOR_LE_G8B8); \
        nvPushData(2, dDrawSubchannelOffset(NV_DD_CELSIUS) + \
                      NV056_SET_TEXTURE_FORMAT(0) | 0x80000); \
        nvPushData(3, (NV056_SET_TEXTURE_FORMAT_WRAPV_FALSE << 31) | \
                      (NV056_SET_TEXTURE_FORMAT_TEXTUREADDRESSV_CLAMP << 28) | \
                      (NV056_SET_TEXTURE_FORMAT_WRAPU_FALSE << 27) | \
                      (NV056_SET_TEXTURE_FORMAT_TEXTUREADDRESSU_CLAMP << 24) | \
                      (1 << 12) | \
                      (NV056_SET_TEXTURE_FORMAT_COLOR_LE_IMAGE_G8B8 << 7) | \
                      (NV056_SET_TEXTURE_FORMAT_ORIGIN_FOH_CORNER << 5) | \
                      (NV056_SET_TEXTURE_FORMAT_ORIGIN_ZOH_CORNER << 3) | \
                      (NV056_SET_TEXTURE_FORMAT_CUBEMAP_ENABLE_FALSE << 2) | \
                       NV056_SET_TEXTURE_FORMAT_CONTEXT_DMA_A); \
        nvPushData(4, (NV056_SET_TEXTURE_FORMAT_WRAPV_FALSE << 31) | \
                      (NV056_SET_TEXTURE_FORMAT_TEXTUREADDRESSV_CLAMP << 28) | \
                      (NV056_SET_TEXTURE_FORMAT_WRAPU_FALSE << 27) | \
                      (NV056_SET_TEXTURE_FORMAT_TEXTUREADDRESSU_CLAMP << 24) | \
                      (1 << 12) | \
                      (NV056_SET_TEXTURE_FORMAT_COLOR_LE_IMAGE_G8B8 << 7) | \
                      (NV056_SET_TEXTURE_FORMAT_ORIGIN_FOH_CORNER << 5) | \
                      (NV056_SET_TEXTURE_FORMAT_ORIGIN_ZOH_CORNER << 3) | \
                      (NV056_SET_TEXTURE_FORMAT_CUBEMAP_ENABLE_FALSE << 2) | \
                       NV056_SET_TEXTURE_FORMAT_CONTEXT_DMA_A); \
        nvPusherAdjust(5); \
    } \
} while(0)

#define SET_KELVIN_CHROMA_DATA_FORMAT() do { \
    if (nvMoCompParams.dataFormat != DATA_FORMAT_CHROMA) { \
        nvMoCompParams.dataFormat = DATA_FORMAT_CHROMA; \
        nvPushData(0, dDrawSubchannelOffset(NV_DD_KELVIN) + \
                      NV097_SET_SURFACE_FORMAT | 0x40000); \
        nvPushData(1, (NV097_SET_SURFACE_FORMAT_ANTI_ALIASING_CENTER_1 << 12) | \
                      (NV097_SET_SURFACE_FORMAT_TYPE_PITCH << 8) | \
                      (NV097_SET_SURFACE_FORMAT_ZETA_Z16 << 4) | \
                       NV097_SET_SURFACE_FORMAT_COLOR_LE_G8B8); \
        nvPushData(2, dDrawSubchannelOffset(NV_DD_KELVIN) + \
                      NV097_SET_TEXTURE_FORMAT(0) | 0x40000); \
        nvPushData(3, (1 << 16) | \
                      (NV097_SET_TEXTURE_FORMAT_COLOR_LU_IMAGE_G8B8 << 8) | \
                      (NV097_SET_TEXTURE_FORMAT_DIMENSIONALITY_TWO << 4) | \
                      (NV097_SET_TEXTURE_FORMAT_BORDER_SOURCE_COLOR << 3) | \
                      (NV097_SET_TEXTURE_FORMAT_CUBEMAP_ENABLE_FALSE << 2) | \
                       NV097_SET_TEXTURE_FORMAT_CONTEXT_DMA_A); \
        nvPushData(4, dDrawSubchannelOffset(NV_DD_KELVIN) + \
                      NV097_SET_TEXTURE_FORMAT(1) | 0x40000); \
        nvPushData(5, (1 << 16) | \
                      (NV097_SET_TEXTURE_FORMAT_COLOR_LU_IMAGE_G8B8 << 8) | \
                      (NV097_SET_TEXTURE_FORMAT_DIMENSIONALITY_TWO << 4) | \
                      (NV097_SET_TEXTURE_FORMAT_BORDER_SOURCE_COLOR << 3) | \
                      (NV097_SET_TEXTURE_FORMAT_CUBEMAP_ENABLE_FALSE << 2) | \
                       NV097_SET_TEXTURE_FORMAT_CONTEXT_DMA_A); \
        nvPusherAdjust(6); \
    } \
} while(0)

#define SET_CORRECTION_DATA_FORMAT() do { \
    if (nvMoCompParams.dataFormat != DATA_FORMAT_CORRECTION) { \
        nvMoCompParams.dataFormat = DATA_FORMAT_CORRECTION; \
        nvPushData(0, dDrawSubchannelOffset(NV_DD_CELSIUS) + \
                      NV056_SET_SURFACE_FORMAT | 0x40000); \
        nvPushData(1, (NV056_SET_SURFACE_FORMAT_TYPE_PITCH << 8) | \
                      NV056_SET_SURFACE_FORMAT_COLOR_LE_B8); \
        nvPushData(2, dDrawSubchannelOffset(NV_DD_CELSIUS) + \
                      NV056_SET_TEXTURE_FORMAT(0) | 0x80000); \
        nvPushData(3, (NV056_SET_TEXTURE_FORMAT_WRAPV_FALSE << 31) | \
                      (NV056_SET_TEXTURE_FORMAT_TEXTUREADDRESSV_CLAMP << 28) | \
                      (NV056_SET_TEXTURE_FORMAT_WRAPU_FALSE << 27) | \
                      (NV056_SET_TEXTURE_FORMAT_TEXTUREADDRESSU_CLAMP << 24) | \
                      (1 << 12) | \
                      (NV056_SET_TEXTURE_FORMAT_COLOR_LE_IMAGE_SY8 << 7) | \
                      (NV056_SET_TEXTURE_FORMAT_ORIGIN_FOH_CORNER << 5) | \
                      (NV056_SET_TEXTURE_FORMAT_ORIGIN_ZOH_CORNER << 3) | \
                      (NV056_SET_TEXTURE_FORMAT_CUBEMAP_ENABLE_FALSE << 2) | \
                       NV056_SET_TEXTURE_FORMAT_CONTEXT_DMA_B); \
        nvPushData(4, (NV056_SET_TEXTURE_FORMAT_WRAPV_FALSE << 31) | \
                      (NV056_SET_TEXTURE_FORMAT_TEXTUREADDRESSV_CLAMP << 28) | \
                      (NV056_SET_TEXTURE_FORMAT_WRAPU_FALSE << 27) | \
                      (NV056_SET_TEXTURE_FORMAT_TEXTUREADDRESSU_CLAMP << 24) | \
                      (1 << 12) | \
                      (NV056_SET_TEXTURE_FORMAT_COLOR_LE_IMAGE_Y8 << 7) | \
                      (NV056_SET_TEXTURE_FORMAT_ORIGIN_FOH_CORNER << 5) | \
                      (NV056_SET_TEXTURE_FORMAT_ORIGIN_ZOH_CORNER << 3) | \
                      (NV056_SET_TEXTURE_FORMAT_CUBEMAP_ENABLE_FALSE << 2) | \
                       NV056_SET_TEXTURE_FORMAT_CONTEXT_DMA_A); \
        nvPusherAdjust(5); \
    } \
} while(0)

#define SET_CHROMA_CORRECTION_DATA_FORMAT() do { \
    if (nvMoCompParams.dataFormat != DATA_FORMAT_CHROMA_CORRECTION) { \
        nvMoCompParams.dataFormat = DATA_FORMAT_CHROMA_CORRECTION; \
        nvPushData(0, dDrawSubchannelOffset(NV_DD_CELSIUS) + \
                      NV056_SET_SURFACE_FORMAT | 0x40000); \
        nvPushData(1, (NV056_SET_SURFACE_FORMAT_TYPE_PITCH << 8) | \
                      NV056_SET_SURFACE_FORMAT_COLOR_LE_G8B8); \
        nvPushData(2, dDrawSubchannelOffset(NV_DD_CELSIUS) + \
                      NV056_SET_TEXTURE_FORMAT(0) | 0x80000); \
        nvPushData(3, (NV056_SET_TEXTURE_FORMAT_WRAPV_FALSE << 31) | \
                      (NV056_SET_TEXTURE_FORMAT_TEXTUREADDRESSV_CLAMP << 28) | \
                      (NV056_SET_TEXTURE_FORMAT_WRAPU_FALSE << 27) | \
                      (NV056_SET_TEXTURE_FORMAT_TEXTUREADDRESSU_CLAMP << 24) | \
                      (1 << 12) | \
                      (NV056_SET_TEXTURE_FORMAT_COLOR_LE_IMAGE_SG8SB8 << 7) | \
                      (NV056_SET_TEXTURE_FORMAT_ORIGIN_FOH_CORNER << 5) | \
                      (NV056_SET_TEXTURE_FORMAT_ORIGIN_ZOH_CORNER << 3) | \
                      (NV056_SET_TEXTURE_FORMAT_CUBEMAP_ENABLE_FALSE << 2) | \
                       NV056_SET_TEXTURE_FORMAT_CONTEXT_DMA_B); \
        nvPushData(4, (NV056_SET_TEXTURE_FORMAT_WRAPV_FALSE << 31) | \
                      (NV056_SET_TEXTURE_FORMAT_TEXTUREADDRESSV_CLAMP << 28) | \
                      (NV056_SET_TEXTURE_FORMAT_WRAPU_FALSE << 27) | \
                      (NV056_SET_TEXTURE_FORMAT_TEXTUREADDRESSU_CLAMP << 24) | \
                      (1 << 12) | \
                      (NV056_SET_TEXTURE_FORMAT_COLOR_LE_IMAGE_G8B8 << 7) | \
                      (NV056_SET_TEXTURE_FORMAT_ORIGIN_FOH_CORNER << 5) | \
                      (NV056_SET_TEXTURE_FORMAT_ORIGIN_ZOH_CORNER << 3) | \
                      (NV056_SET_TEXTURE_FORMAT_CUBEMAP_ENABLE_FALSE << 2) | \
                       NV056_SET_TEXTURE_FORMAT_CONTEXT_DMA_A); \
        nvPusherAdjust(5); \
    } \
} while(0)

#define SET_KELVIN_CORRECTION_DATA_FORMAT() do { \
    if (nvMoCompParams.dataFormat != DATA_FORMAT_CORRECTION) { \
        nvMoCompParams.dataFormat = DATA_FORMAT_CORRECTION; \
        nvPushData(0, dDrawSubchannelOffset(NV_DD_KELVIN) + \
                      NV097_SET_SURFACE_FORMAT | 0x40000); \
        nvPushData(1, (NV097_SET_SURFACE_FORMAT_ANTI_ALIASING_CENTER_1 << 12) | \
                      (NV097_SET_SURFACE_FORMAT_TYPE_PITCH << 8) | \
                      (NV097_SET_SURFACE_FORMAT_ZETA_Z16 << 4) | \
                       NV097_SET_SURFACE_FORMAT_COLOR_LE_B8); \
        nvPushData(2, dDrawSubchannelOffset(NV_DD_KELVIN) + \
                      NV097_SET_TEXTURE_FORMAT(0) | 0x40000); \
        nvPushData(3, (1 << 16) | \
                      (NV097_SET_TEXTURE_FORMAT_COLOR_LU_IMAGE_SY8 << 8) | \
                      (NV097_SET_TEXTURE_FORMAT_DIMENSIONALITY_TWO << 4) | \
                      (NV097_SET_TEXTURE_FORMAT_BORDER_SOURCE_COLOR << 3) | \
                      (NV097_SET_TEXTURE_FORMAT_CUBEMAP_ENABLE_FALSE << 2) | \
                       NV097_SET_TEXTURE_FORMAT_CONTEXT_DMA_B); \
        nvPushData(4, dDrawSubchannelOffset(NV_DD_KELVIN) + \
                      NV097_SET_TEXTURE_FORMAT(1) | 0x40000); \
        nvPushData(5, (1 << 16) | \
                      (NV097_SET_TEXTURE_FORMAT_COLOR_LU_IMAGE_Y8 << 8) | \
                      (NV097_SET_TEXTURE_FORMAT_DIMENSIONALITY_TWO << 4) | \
                      (NV097_SET_TEXTURE_FORMAT_BORDER_SOURCE_COLOR << 3) | \
                      (NV097_SET_TEXTURE_FORMAT_CUBEMAP_ENABLE_FALSE << 2) | \
                       NV097_SET_TEXTURE_FORMAT_CONTEXT_DMA_A); \
        nvPusherAdjust(6); \
    } \
} while(0)

#define SET_KELVIN_CHROMA_CORRECTION_DATA_FORMAT() do { \
    if (nvMoCompParams.dataFormat != DATA_FORMAT_CHROMA_CORRECTION) { \
        nvMoCompParams.dataFormat = DATA_FORMAT_CHROMA_CORRECTION; \
        nvPushData(0, dDrawSubchannelOffset(NV_DD_KELVIN) + \
                      NV097_SET_SURFACE_FORMAT | 0x40000); \
        nvPushData(1, (NV097_SET_SURFACE_FORMAT_ANTI_ALIASING_CENTER_1 << 12) | \
                      (NV097_SET_SURFACE_FORMAT_TYPE_PITCH << 8) | \
                      (NV097_SET_SURFACE_FORMAT_ZETA_Z16 << 4) | \
                       NV097_SET_SURFACE_FORMAT_COLOR_LE_G8B8); \
        nvPushData(2, dDrawSubchannelOffset(NV_DD_KELVIN) + \
                      NV097_SET_TEXTURE_FORMAT(0) | 0x40000); \
        nvPushData(3, (1 << 16) | \
                      (NV097_SET_TEXTURE_FORMAT_COLOR_LU_IMAGE_SG8SB8 << 8) | \
                      (NV097_SET_TEXTURE_FORMAT_DIMENSIONALITY_TWO << 4) | \
                      (NV097_SET_TEXTURE_FORMAT_BORDER_SOURCE_COLOR << 3) | \
                      (NV097_SET_TEXTURE_FORMAT_CUBEMAP_ENABLE_FALSE << 2) | \
                       NV097_SET_TEXTURE_FORMAT_CONTEXT_DMA_B); \
        nvPushData(4, dDrawSubchannelOffset(NV_DD_KELVIN) + \
                      NV097_SET_TEXTURE_FORMAT(1) | 0x40000); \
        nvPushData(5, (1 << 16) | \
                      (NV097_SET_TEXTURE_FORMAT_COLOR_LU_IMAGE_G8B8 << 8) | \
                      (NV097_SET_TEXTURE_FORMAT_DIMENSIONALITY_TWO << 4) | \
                      (NV097_SET_TEXTURE_FORMAT_BORDER_SOURCE_COLOR << 3) | \
                      (NV097_SET_TEXTURE_FORMAT_CUBEMAP_ENABLE_FALSE << 2) | \
                       NV097_SET_TEXTURE_FORMAT_CONTEXT_DMA_A); \
        nvPusherAdjust(6); \
    } \
} while(0)

#define SET_UNBIASED_CORRECTION_DATA_FORMAT() do { \
    if (nvMoCompParams.dataFormat != DATA_FORMAT_UNBIASED_CORRECTION) { \
        nvMoCompParams.dataFormat = DATA_FORMAT_UNBIASED_CORRECTION; \
        nvPushData(0, dDrawSubchannelOffset(NV_DD_CELSIUS) + \
                      NV056_SET_SURFACE_FORMAT | 0x40000); \
        nvPushData(1, (NV056_SET_SURFACE_FORMAT_TYPE_PITCH << 8) | \
                      NV056_SET_SURFACE_FORMAT_COLOR_LE_B8); \
        nvPushData(2, dDrawSubchannelOffset(NV_DD_CELSIUS) + \
                      NV056_SET_TEXTURE_FORMAT(0) | 0x80000); \
        nvPushData(3, (NV056_SET_TEXTURE_FORMAT_WRAPV_FALSE << 31) | \
                      (NV056_SET_TEXTURE_FORMAT_TEXTUREADDRESSV_CLAMP << 28) | \
                      (NV056_SET_TEXTURE_FORMAT_WRAPU_FALSE << 27) | \
                      (NV056_SET_TEXTURE_FORMAT_TEXTUREADDRESSU_CLAMP << 24) | \
                      (1 << 12) | \
                      (NV056_SET_TEXTURE_FORMAT_COLOR_LE_IMAGE_Y8 << 7) | \
                      (NV056_SET_TEXTURE_FORMAT_ORIGIN_FOH_CORNER << 5) | \
                      (NV056_SET_TEXTURE_FORMAT_ORIGIN_ZOH_CORNER << 3) | \
                      (NV056_SET_TEXTURE_FORMAT_CUBEMAP_ENABLE_FALSE << 2) | \
                       NV056_SET_TEXTURE_FORMAT_CONTEXT_DMA_B); \
        nvPushData(4, (NV056_SET_TEXTURE_FORMAT_WRAPV_FALSE << 31) | \
                      (NV056_SET_TEXTURE_FORMAT_TEXTUREADDRESSV_CLAMP << 28) | \
                      (NV056_SET_TEXTURE_FORMAT_WRAPU_FALSE << 27) | \
                      (NV056_SET_TEXTURE_FORMAT_TEXTUREADDRESSU_CLAMP << 24) | \
                      (1 << 12) | \
                      (NV056_SET_TEXTURE_FORMAT_COLOR_LE_IMAGE_Y8 << 7) | \
                      (NV056_SET_TEXTURE_FORMAT_ORIGIN_FOH_CORNER << 5) | \
                      (NV056_SET_TEXTURE_FORMAT_ORIGIN_ZOH_CORNER << 3) | \
                      (NV056_SET_TEXTURE_FORMAT_CUBEMAP_ENABLE_FALSE << 2) | \
                       NV056_SET_TEXTURE_FORMAT_CONTEXT_DMA_A); \
        nvPusherAdjust(5); \
    } \
} while(0)

#define SET_UNBIASED_CHROMA_CORRECTION_DATA_FORMAT() do { \
    if (nvMoCompParams.dataFormat != DATA_FORMAT_UNBIASED_CHROMA_CORRECTION) { \
        nvMoCompParams.dataFormat = DATA_FORMAT_UNBIASED_CHROMA_CORRECTION; \
        nvPushData(0, dDrawSubchannelOffset(NV_DD_CELSIUS) + \
                      NV056_SET_SURFACE_FORMAT | 0x40000); \
        nvPushData(1, (NV056_SET_SURFACE_FORMAT_TYPE_PITCH << 8) | \
                      NV056_SET_SURFACE_FORMAT_COLOR_LE_G8B8); \
        nvPushData(2, dDrawSubchannelOffset(NV_DD_CELSIUS) + \
                      NV056_SET_TEXTURE_FORMAT(0) | 0x80000); \
        nvPushData(3, (NV056_SET_TEXTURE_FORMAT_WRAPV_FALSE << 31) | \
                      (NV056_SET_TEXTURE_FORMAT_TEXTUREADDRESSV_CLAMP << 28) | \
                      (NV056_SET_TEXTURE_FORMAT_WRAPU_FALSE << 27) | \
                      (NV056_SET_TEXTURE_FORMAT_TEXTUREADDRESSU_CLAMP << 24) | \
                      (1 << 12) | \
                      (NV056_SET_TEXTURE_FORMAT_COLOR_LE_IMAGE_G8B8 << 7) | \
                      (NV056_SET_TEXTURE_FORMAT_ORIGIN_FOH_CORNER << 5) | \
                      (NV056_SET_TEXTURE_FORMAT_ORIGIN_ZOH_CORNER << 3) | \
                      (NV056_SET_TEXTURE_FORMAT_CUBEMAP_ENABLE_FALSE << 2) | \
                       NV056_SET_TEXTURE_FORMAT_CONTEXT_DMA_B); \
        nvPushData(4, (NV056_SET_TEXTURE_FORMAT_WRAPV_FALSE << 31) | \
                      (NV056_SET_TEXTURE_FORMAT_TEXTUREADDRESSV_CLAMP << 28) | \
                      (NV056_SET_TEXTURE_FORMAT_WRAPU_FALSE << 27) | \
                      (NV056_SET_TEXTURE_FORMAT_TEXTUREADDRESSU_CLAMP << 24) | \
                      (1 << 12) | \
                      (NV056_SET_TEXTURE_FORMAT_COLOR_LE_IMAGE_G8B8 << 7) | \
                      (NV056_SET_TEXTURE_FORMAT_ORIGIN_FOH_CORNER << 5) | \
                      (NV056_SET_TEXTURE_FORMAT_ORIGIN_ZOH_CORNER << 3) | \
                      (NV056_SET_TEXTURE_FORMAT_CUBEMAP_ENABLE_FALSE << 2) | \
                       NV056_SET_TEXTURE_FORMAT_CONTEXT_DMA_A); \
        nvPusherAdjust(5); \
    } \
} while(0)

#define SET_KELVIN_UNBIASED_CORRECTION_DATA_FORMAT() do { \
    if (nvMoCompParams.dataFormat != DATA_FORMAT_UNBIASED_CORRECTION) { \
        nvMoCompParams.dataFormat = DATA_FORMAT_UNBIASED_CORRECTION; \
        nvPushData(0, dDrawSubchannelOffset(NV_DD_KELVIN) + \
                      NV097_SET_SURFACE_FORMAT | 0x40000); \
        nvPushData(1, (NV097_SET_SURFACE_FORMAT_ANTI_ALIASING_CENTER_1 << 12) | \
                      (NV097_SET_SURFACE_FORMAT_TYPE_PITCH << 8) | \
                      (NV097_SET_SURFACE_FORMAT_ZETA_Z16 << 4) | \
                       NV097_SET_SURFACE_FORMAT_COLOR_LE_B8); \
        nvPushData(2, dDrawSubchannelOffset(NV_DD_KELVIN) + \
                      NV097_SET_TEXTURE_FORMAT(0) | 0x40000); \
        nvPushData(3, (1 << 16) | \
                      (NV097_SET_TEXTURE_FORMAT_COLOR_LU_IMAGE_Y8 << 8) | \
                      (NV097_SET_TEXTURE_FORMAT_DIMENSIONALITY_TWO << 4) | \
                      (NV097_SET_TEXTURE_FORMAT_BORDER_SOURCE_COLOR << 3) | \
                      (NV097_SET_TEXTURE_FORMAT_CUBEMAP_ENABLE_FALSE << 2) | \
                       NV097_SET_TEXTURE_FORMAT_CONTEXT_DMA_B); \
        nvPushData(4, dDrawSubchannelOffset(NV_DD_KELVIN) + \
                      NV097_SET_TEXTURE_FORMAT(1) | 0x40000); \
        nvPushData(5, (1 << 16) | \
                      (NV097_SET_TEXTURE_FORMAT_COLOR_LU_IMAGE_Y8 << 8) | \
                      (NV097_SET_TEXTURE_FORMAT_DIMENSIONALITY_TWO << 4) | \
                      (NV097_SET_TEXTURE_FORMAT_BORDER_SOURCE_COLOR << 3) | \
                      (NV097_SET_TEXTURE_FORMAT_CUBEMAP_ENABLE_FALSE << 2) | \
                       NV097_SET_TEXTURE_FORMAT_CONTEXT_DMA_A); \
        nvPusherAdjust(6); \
    } \
} while(0)

#define SET_KELVIN_UNBIASED_CHROMA_CORRECTION_DATA_FORMAT() do { \
    if (nvMoCompParams.dataFormat != DATA_FORMAT_UNBIASED_CHROMA_CORRECTION) { \
        nvMoCompParams.dataFormat = DATA_FORMAT_UNBIASED_CHROMA_CORRECTION; \
        nvPushData(0, dDrawSubchannelOffset(NV_DD_KELVIN) + \
                      NV097_SET_SURFACE_FORMAT | 0x40000); \
        nvPushData(1, (NV097_SET_SURFACE_FORMAT_ANTI_ALIASING_CENTER_1 << 12) | \
                      (NV097_SET_SURFACE_FORMAT_TYPE_PITCH << 8) | \
                      (NV097_SET_SURFACE_FORMAT_ZETA_Z16 << 4) | \
                       NV097_SET_SURFACE_FORMAT_COLOR_LE_G8B8); \
        nvPushData(2, dDrawSubchannelOffset(NV_DD_KELVIN) + \
                      NV097_SET_TEXTURE_FORMAT(0) | 0x40000); \
        nvPushData(3, (1 << 16) | \
                      (NV097_SET_TEXTURE_FORMAT_COLOR_LU_IMAGE_G8B8 << 8) | \
                      (NV097_SET_TEXTURE_FORMAT_DIMENSIONALITY_TWO << 4) | \
                      (NV097_SET_TEXTURE_FORMAT_BORDER_SOURCE_COLOR << 3) | \
                      (NV097_SET_TEXTURE_FORMAT_CUBEMAP_ENABLE_FALSE << 2) | \
                       NV097_SET_TEXTURE_FORMAT_CONTEXT_DMA_B); \
        nvPushData(4, dDrawSubchannelOffset(NV_DD_KELVIN) + \
                      NV097_SET_TEXTURE_FORMAT(1) | 0x40000); \
        nvPushData(5, (1 << 16) | \
                      (NV097_SET_TEXTURE_FORMAT_COLOR_LU_IMAGE_G8B8 << 8) | \
                      (NV097_SET_TEXTURE_FORMAT_DIMENSIONALITY_TWO << 4) | \
                      (NV097_SET_TEXTURE_FORMAT_BORDER_SOURCE_COLOR << 3) | \
                      (NV097_SET_TEXTURE_FORMAT_CUBEMAP_ENABLE_FALSE << 2) | \
                       NV097_SET_TEXTURE_FORMAT_CONTEXT_DMA_A); \
        nvPusherAdjust(6); \
    } \
} while(0)


// NOTE: vertexSizeContext is an NV10 hardware context switching bug workaround which saves the
// current vertex size context in an unused but context switched location in the 2nd inverse
// model view matrix which the RM uses to restore this lost context data when restoring the context of this channel

#define SET_BIDIRECTIONAL_VERTEX_ARRAY_MODE() do { \
    if (nvMoCompParams.vertexMode != VERTEX_MODE_BIDIRECTIONAL) { \
        unsigned long vertexSizeContext; \
        nvMoCompParams.vertexMode = VERTEX_MODE_BIDIRECTIONAL; \
        vertexSizeContext = NV056_SET_VERTEX_ARRAY_FORMAT_SIZE_2 | \
                            (NV056_SET_DIFFUSE_ARRAY_FORMAT_SIZE_0 << 4) | \
                            (NV056_SET_SPECULAR_ARRAY_FORMAT_SIZE_0 << 8) | \
                            (NV056_SET_TEX_COORD0_ARRAY_FORMAT_SIZE_2 << 12) | \
                            (NV056_SET_TEX_COORD1_ARRAY_FORMAT_SIZE_2 << 16) | \
                            (NV056_SET_NORMAL_ARRAY_FORMAT_SIZE_0 << 20) | \
                            (NV056_SET_WEIGHT_ARRAY_FORMAT_SIZE_0 << 24) | \
                            (NV056_SET_FOG_ARRAY_FORMAT_SIZE_0 << 28); \
        nvPushData(0, dDrawSubchannelOffset(NV_DD_CELSIUS) + \
                      NV056_SET_INVERSE_MODEL_VIEW_MATRIX1(15) | 0x40000); \
        nvPushData(1, vertexSizeContext); \
        nvPushData(2, dDrawSubchannelOffset(NV_DD_CELSIUS) + \
                      NV056_SET_VERTEX_ARRAY_OFFSET | 0x400000); \
        nvPushData(3, 0); \
        nvPushData(4, (NV056_SET_VERTEX_ARRAY_FORMAT_W_NONE << 24) | \
                      (12 << 8) | \
                      (NV056_SET_VERTEX_ARRAY_FORMAT_SIZE_2 << 4) | \
                       NV056_SET_VERTEX_ARRAY_FORMAT_TYPE_SHORT); \
        nvPushData(5, 0); \
        nvPushData(6, (12 << 8) | \
                      (NV056_SET_DIFFUSE_ARRAY_FORMAT_SIZE_0 << 4) | \
                       NV056_SET_DIFFUSE_ARRAY_FORMAT_TYPE_UNSIGNED_BYTE_BGRA); \
        nvPushData(7, 0); \
        nvPushData(8, (12 << 8) | \
                      (NV056_SET_SPECULAR_ARRAY_FORMAT_SIZE_0 << 4) | \
                       NV056_SET_SPECULAR_ARRAY_FORMAT_TYPE_UNSIGNED_BYTE_BGRA); \
        nvPushData(9, 4); \
        nvPushData(10, (12 << 8) | \
                      (NV056_SET_TEX_COORD0_ARRAY_FORMAT_SIZE_2 << 4) | \
                       NV056_SET_TEX_COORD0_ARRAY_FORMAT_TYPE_SHORT); \
        nvPushData(11, 8); \
        nvPushData(12, (12 << 8) | \
                       (NV056_SET_TEX_COORD1_ARRAY_FORMAT_SIZE_2 << 4) | \
                        NV056_SET_TEX_COORD1_ARRAY_FORMAT_TYPE_SHORT); \
        nvPushData(13, 0); \
        nvPushData(14, (12 << 8) | \
                       (NV056_SET_NORMAL_ARRAY_FORMAT_SIZE_0 << 4) | \
                        NV056_SET_NORMAL_ARRAY_FORMAT_TYPE_SHORT); \
        nvPushData(15, 0); \
        nvPushData(16, (12 << 8) | \
                       (NV056_SET_WEIGHT_ARRAY_FORMAT_SIZE_0 << 4) | \
                        NV056_SET_WEIGHT_ARRAY_FORMAT_TYPE_SHORT); \
        nvPushData(17, 0); \
        nvPushData(18, (12 << 8) | \
                       (NV056_SET_FOG_ARRAY_FORMAT_SIZE_0 << 4) | \
                        NV056_SET_FOG_ARRAY_FORMAT_TYPE_SHORT); \
        nvPusherAdjust(19); \
    } \
} while(0)

// Kelvin vertex data array slots (in order)
//
// Position
// Weight
// Normal
// Diffuse
// Specular (RGBA or BGRF in 4th component, if present)
// Fog
// Point Size
// Back Diffuse
// Back Specular
// Texture 0
// Texture 1
// Texture 2
// Texture 3
// Reserved
// Reserved
// Reserved

#define SET_KELVIN_BIDIRECTIONAL_VERTEX_ARRAY_MODE() do { \
    if (nvMoCompParams.vertexMode != VERTEX_MODE_BIDIRECTIONAL) { \
        nvMoCompParams.vertexMode = VERTEX_MODE_BIDIRECTIONAL; \
        nvPushData(0, dDrawSubchannelOffset(NV_DD_KELVIN) + \
                      NV097_SET_VERTEX_DATA_ARRAY_OFFSET(0) | 0x340000); \
        nvPushData(1, 0); \
        nvPushData(2, 0); \
        nvPushData(3, 0); \
        nvPushData(4, 0); \
        nvPushData(5, 0); \
        nvPushData(6, 0); \
        nvPushData(7, 0); \
        nvPushData(8, 0); \
        nvPushData(9, 0); \
        nvPushData(10, 4); \
        nvPushData(11, 8); \
        nvPushData(12, 0); \
        nvPushData(13, 0); \
        nvPushData(14, dDrawSubchannelOffset(NV_DD_KELVIN) + \
                       NV097_SET_VERTEX_DATA_ARRAY_FORMAT(0) | 0x340000); \
        nvPushData(15, (12 << 8) | \
                       (NV097_SET_VERTEX_DATA_ARRAY_FORMAT_SIZE_2 << 4) | \
                        NV097_SET_VERTEX_DATA_ARRAY_FORMAT_TYPE_S32K); \
        nvPushData(16, (12 << 8) | \
                       (NV097_SET_VERTEX_DATA_ARRAY_FORMAT_SIZE_DISABLED << 4) | \
                        NV097_SET_VERTEX_DATA_ARRAY_FORMAT_TYPE_S32K); \
        nvPushData(17, (12 << 8) | \
                       (NV097_SET_VERTEX_DATA_ARRAY_FORMAT_SIZE_DISABLED << 4) | \
                        NV097_SET_VERTEX_DATA_ARRAY_FORMAT_TYPE_S32K); \
        nvPushData(18, (12 << 8) | \
                       (NV097_SET_VERTEX_DATA_ARRAY_FORMAT_SIZE_DISABLED << 4) | \
                        NV097_SET_VERTEX_DATA_ARRAY_FORMAT_TYPE_S32K); \
        nvPushData(19, (12 << 8) | \
                       (NV097_SET_VERTEX_DATA_ARRAY_FORMAT_SIZE_DISABLED << 4) | \
                        NV097_SET_VERTEX_DATA_ARRAY_FORMAT_TYPE_S32K); \
        nvPushData(20, (12 << 8) | \
                       (NV097_SET_VERTEX_DATA_ARRAY_FORMAT_SIZE_DISABLED << 4) | \
                        NV097_SET_VERTEX_DATA_ARRAY_FORMAT_TYPE_S32K); \
        nvPushData(21, (12 << 8) | \
                       (NV097_SET_VERTEX_DATA_ARRAY_FORMAT_SIZE_DISABLED << 4) | \
                        NV097_SET_VERTEX_DATA_ARRAY_FORMAT_TYPE_S32K); \
        nvPushData(22, (12 << 8) | \
                       (NV097_SET_VERTEX_DATA_ARRAY_FORMAT_SIZE_DISABLED << 4) | \
                        NV097_SET_VERTEX_DATA_ARRAY_FORMAT_TYPE_S32K); \
        nvPushData(23, (12 << 8) | \
                       (NV097_SET_VERTEX_DATA_ARRAY_FORMAT_SIZE_DISABLED << 4) | \
                        NV097_SET_VERTEX_DATA_ARRAY_FORMAT_TYPE_S32K); \
        nvPushData(24, (12 << 8) | \
                       (NV097_SET_VERTEX_DATA_ARRAY_FORMAT_SIZE_2 << 4) | \
                        NV097_SET_VERTEX_DATA_ARRAY_FORMAT_TYPE_S32K); \
        nvPushData(25, (12 << 8) | \
                       (NV097_SET_VERTEX_DATA_ARRAY_FORMAT_SIZE_2 << 4) | \
                        NV097_SET_VERTEX_DATA_ARRAY_FORMAT_TYPE_S32K); \
        nvPushData(26, (12 << 8) | \
                       (NV097_SET_VERTEX_DATA_ARRAY_FORMAT_SIZE_DISABLED << 4) | \
                        NV097_SET_VERTEX_DATA_ARRAY_FORMAT_TYPE_S32K); \
        nvPushData(27, (12 << 8) | \
                       (NV097_SET_VERTEX_DATA_ARRAY_FORMAT_SIZE_DISABLED << 4) | \
                        NV097_SET_VERTEX_DATA_ARRAY_FORMAT_TYPE_S32K); \
        nvPusherAdjust(28); \
    } \
} while(0)

// NOTE: vertexSizeContext is an NV10 hardware context switching bug workaround which saves the
// current vertex size context in an unused but context switched location in the 2nd inverse
// model view matrix which the RM uses to restore this lost context data when restoring the context of this channel

#define SET_FORWARD_VERTEX_ARRAY_MODE() do { \
    if (nvMoCompParams.vertexMode != VERTEX_MODE_FORWARD) { \
        unsigned long vertexSizeContext; \
        nvMoCompParams.vertexMode = VERTEX_MODE_FORWARD; \
        vertexSizeContext = NV056_SET_VERTEX_ARRAY_FORMAT_SIZE_2 | \
                            (NV056_SET_DIFFUSE_ARRAY_FORMAT_SIZE_0 << 4) | \
                            (NV056_SET_SPECULAR_ARRAY_FORMAT_SIZE_0 << 8) | \
                            (NV056_SET_TEX_COORD0_ARRAY_FORMAT_SIZE_2 << 12) | \
                            (NV056_SET_TEX_COORD1_ARRAY_FORMAT_SIZE_0 << 16) | \
                            (NV056_SET_NORMAL_ARRAY_FORMAT_SIZE_0 << 20) | \
                            (NV056_SET_WEIGHT_ARRAY_FORMAT_SIZE_0 << 24) | \
                            (NV056_SET_FOG_ARRAY_FORMAT_SIZE_0 << 28); \
        nvPushData(0, dDrawSubchannelOffset(NV_DD_CELSIUS) + \
                      NV056_SET_INVERSE_MODEL_VIEW_MATRIX1(15) | 0x40000); \
        nvPushData(1, vertexSizeContext); \
        nvPushData(2, dDrawSubchannelOffset(NV_DD_CELSIUS) + \
                      NV056_SET_VERTEX_ARRAY_OFFSET | 0x400000); \
        nvPushData(3, 0); \
        nvPushData(4, (NV056_SET_VERTEX_ARRAY_FORMAT_W_NONE << 24) | \
                      (8 << 8) | \
                      (NV056_SET_VERTEX_ARRAY_FORMAT_SIZE_2 << 4) | \
                       NV056_SET_VERTEX_ARRAY_FORMAT_TYPE_SHORT); \
        nvPushData(5, 0); \
        nvPushData(6, (8 << 8) | \
                      (NV056_SET_DIFFUSE_ARRAY_FORMAT_SIZE_0 << 4) | \
                       NV056_SET_DIFFUSE_ARRAY_FORMAT_TYPE_UNSIGNED_BYTE_BGRA); \
        nvPushData(7, 0); \
        nvPushData(8,(8 << 8) | \
                      (NV056_SET_SPECULAR_ARRAY_FORMAT_SIZE_0 << 4) | \
                       NV056_SET_SPECULAR_ARRAY_FORMAT_TYPE_UNSIGNED_BYTE_BGRA); \
        nvPushData(9, 4); \
        nvPushData(10, (8 << 8) | \
                      (NV056_SET_TEX_COORD0_ARRAY_FORMAT_SIZE_2 << 4) | \
                       NV056_SET_TEX_COORD0_ARRAY_FORMAT_TYPE_SHORT); \
        nvPushData(11, 0); \
        nvPushData(12, (8 << 8) | \
                       (NV056_SET_TEX_COORD1_ARRAY_FORMAT_SIZE_0 << 4) | \
                        NV056_SET_TEX_COORD1_ARRAY_FORMAT_TYPE_SHORT); \
        nvPushData(13, 0); \
        nvPushData(14, (8 << 8) | \
                       (NV056_SET_NORMAL_ARRAY_FORMAT_SIZE_0 << 4) | \
                        NV056_SET_NORMAL_ARRAY_FORMAT_TYPE_SHORT); \
        nvPushData(15, 0); \
        nvPushData(16, (8 << 8) | \
                       (NV056_SET_WEIGHT_ARRAY_FORMAT_SIZE_0 << 4) | \
                        NV056_SET_WEIGHT_ARRAY_FORMAT_TYPE_SHORT); \
        nvPushData(17, 0); \
        nvPushData(18, (8 << 8) | \
                       (NV056_SET_FOG_ARRAY_FORMAT_SIZE_0 << 4) | \
                        NV056_SET_FOG_ARRAY_FORMAT_TYPE_SHORT); \
        nvPusherAdjust(19); \
    } \
} while(0)

#define SET_KELVIN_FORWARD_VERTEX_ARRAY_MODE() do { \
    if (nvMoCompParams.vertexMode != VERTEX_MODE_FORWARD) { \
        nvMoCompParams.vertexMode = VERTEX_MODE_FORWARD; \
        nvPushData(0, dDrawSubchannelOffset(NV_DD_KELVIN) + \
                      NV097_SET_VERTEX_DATA_ARRAY_OFFSET(0) | 0x340000); \
        nvPushData(1, 0); \
        nvPushData(2, 0); \
        nvPushData(3, 0); \
        nvPushData(4, 0); \
        nvPushData(5, 0); \
        nvPushData(6, 0); \
        nvPushData(7, 0); \
        nvPushData(8, 0); \
        nvPushData(9, 0); \
        nvPushData(10, 4); \
        nvPushData(11, 0); \
        nvPushData(12, 0); \
        nvPushData(13, 0); \
        nvPushData(14, dDrawSubchannelOffset(NV_DD_KELVIN) + \
                       NV097_SET_VERTEX_DATA_ARRAY_FORMAT(0) | 0x340000); \
        nvPushData(15, (8 << 8) | \
                       (NV097_SET_VERTEX_DATA_ARRAY_FORMAT_SIZE_2 << 4) | \
                        NV097_SET_VERTEX_DATA_ARRAY_FORMAT_TYPE_S32K); \
        nvPushData(16, (8 << 8) | \
                       (NV097_SET_VERTEX_DATA_ARRAY_FORMAT_SIZE_DISABLED << 4) | \
                        NV097_SET_VERTEX_DATA_ARRAY_FORMAT_TYPE_S32K); \
        nvPushData(17, (8 << 8) | \
                       (NV097_SET_VERTEX_DATA_ARRAY_FORMAT_SIZE_DISABLED << 4) | \
                        NV097_SET_VERTEX_DATA_ARRAY_FORMAT_TYPE_S32K); \
        nvPushData(18, (8 << 8) | \
                       (NV097_SET_VERTEX_DATA_ARRAY_FORMAT_SIZE_DISABLED << 4) | \
                        NV097_SET_VERTEX_DATA_ARRAY_FORMAT_TYPE_S32K); \
        nvPushData(19, (8 << 8) | \
                       (NV097_SET_VERTEX_DATA_ARRAY_FORMAT_SIZE_DISABLED << 4) | \
                        NV097_SET_VERTEX_DATA_ARRAY_FORMAT_TYPE_S32K); \
        nvPushData(20, (8 << 8) | \
                       (NV097_SET_VERTEX_DATA_ARRAY_FORMAT_SIZE_DISABLED << 4) | \
                        NV097_SET_VERTEX_DATA_ARRAY_FORMAT_TYPE_S32K); \
        nvPushData(21, (8 << 8) | \
                       (NV097_SET_VERTEX_DATA_ARRAY_FORMAT_SIZE_DISABLED << 4) | \
                        NV097_SET_VERTEX_DATA_ARRAY_FORMAT_TYPE_S32K); \
        nvPushData(22, (8 << 8) | \
                       (NV097_SET_VERTEX_DATA_ARRAY_FORMAT_SIZE_DISABLED << 4) | \
                        NV097_SET_VERTEX_DATA_ARRAY_FORMAT_TYPE_S32K); \
        nvPushData(23, (8 << 8) | \
                       (NV097_SET_VERTEX_DATA_ARRAY_FORMAT_SIZE_DISABLED << 4) | \
                        NV097_SET_VERTEX_DATA_ARRAY_FORMAT_TYPE_S32K); \
        nvPushData(24, (8 << 8) | \
                       (NV097_SET_VERTEX_DATA_ARRAY_FORMAT_SIZE_2 << 4) | \
                        NV097_SET_VERTEX_DATA_ARRAY_FORMAT_TYPE_S32K); \
        nvPushData(25, (8 << 8) | \
                       (NV097_SET_VERTEX_DATA_ARRAY_FORMAT_SIZE_DISABLED << 4) | \
                        NV097_SET_VERTEX_DATA_ARRAY_FORMAT_TYPE_S32K); \
        nvPushData(26, (8 << 8) | \
                       (NV097_SET_VERTEX_DATA_ARRAY_FORMAT_SIZE_DISABLED << 4) | \
                        NV097_SET_VERTEX_DATA_ARRAY_FORMAT_TYPE_S32K); \
        nvPushData(27, (8 << 8) | \
                       (NV097_SET_VERTEX_DATA_ARRAY_FORMAT_SIZE_DISABLED << 4) | \
                        NV097_SET_VERTEX_DATA_ARRAY_FORMAT_TYPE_S32K); \
        nvPusherAdjust(28); \
    } \
} while(0)

// NOTE: vertexSizeContext is an NV10 hardware context switching bug workaround which saves the
// current vertex size context in an unused but context switched location in the 2nd inverse
// model view matrix which the RM uses to restore this lost context data when restoring the context of this channel

#define SET_BACKWARD_VERTEX_ARRAY_MODE() do { \
    if (nvMoCompParams.vertexMode != VERTEX_MODE_BACKWARD) { \
        unsigned long vertexSizeContext; \
        nvMoCompParams.vertexMode = VERTEX_MODE_BACKWARD; \
        vertexSizeContext = NV056_SET_VERTEX_ARRAY_FORMAT_SIZE_2 | \
                            (NV056_SET_DIFFUSE_ARRAY_FORMAT_SIZE_0 << 4) | \
                            (NV056_SET_SPECULAR_ARRAY_FORMAT_SIZE_0 << 8) | \
                            (NV056_SET_TEX_COORD0_ARRAY_FORMAT_SIZE_0 << 12) | \
                            (NV056_SET_TEX_COORD1_ARRAY_FORMAT_SIZE_2 << 16) | \
                            (NV056_SET_NORMAL_ARRAY_FORMAT_SIZE_0 << 20) | \
                            (NV056_SET_WEIGHT_ARRAY_FORMAT_SIZE_0 << 24) | \
                            (NV056_SET_FOG_ARRAY_FORMAT_SIZE_0 << 28); \
        nvPushData(0, dDrawSubchannelOffset(NV_DD_CELSIUS) + \
                      NV056_SET_INVERSE_MODEL_VIEW_MATRIX1(15) | 0x40000); \
        nvPushData(1, vertexSizeContext); \
        nvPushData(2, dDrawSubchannelOffset(NV_DD_CELSIUS) + \
                      NV056_SET_VERTEX_ARRAY_OFFSET | 0x400000); \
        nvPushData(3, 0); \
        nvPushData(4, (NV056_SET_VERTEX_ARRAY_FORMAT_W_NONE << 24) | \
                      (8 << 8) | \
                      (NV056_SET_VERTEX_ARRAY_FORMAT_SIZE_2 << 4) | \
                       NV056_SET_VERTEX_ARRAY_FORMAT_TYPE_SHORT); \
        nvPushData(5, 0); \
        nvPushData(6, (8 << 8) | \
                      (NV056_SET_DIFFUSE_ARRAY_FORMAT_SIZE_0 << 4) | \
                       NV056_SET_DIFFUSE_ARRAY_FORMAT_TYPE_UNSIGNED_BYTE_BGRA); \
        nvPushData(7, 0); \
        nvPushData(8, (8 << 8) | \
                      (NV056_SET_SPECULAR_ARRAY_FORMAT_SIZE_0 << 4) | \
                       NV056_SET_SPECULAR_ARRAY_FORMAT_TYPE_UNSIGNED_BYTE_BGRA); \
        nvPushData(9, 0); \
        nvPushData(10, (8 << 8) | \
                      (NV056_SET_TEX_COORD0_ARRAY_FORMAT_SIZE_0 << 4) | \
                       NV056_SET_TEX_COORD0_ARRAY_FORMAT_TYPE_SHORT); \
        nvPushData(11, 4); \
        nvPushData(12, (8 << 8) | \
                       (NV056_SET_TEX_COORD1_ARRAY_FORMAT_SIZE_2 << 4) | \
                        NV056_SET_TEX_COORD1_ARRAY_FORMAT_TYPE_SHORT); \
        nvPushData(13, 0); \
        nvPushData(14, (8 << 8) | \
                       (NV056_SET_NORMAL_ARRAY_FORMAT_SIZE_0 << 4) | \
                        NV056_SET_NORMAL_ARRAY_FORMAT_TYPE_SHORT); \
        nvPushData(15, 0); \
        nvPushData(16, (8 << 8) | \
                       (NV056_SET_WEIGHT_ARRAY_FORMAT_SIZE_0 << 4) | \
                        NV056_SET_WEIGHT_ARRAY_FORMAT_TYPE_SHORT); \
        nvPushData(17, 0); \
        nvPushData(18, (8 << 8) | \
                       (NV056_SET_FOG_ARRAY_FORMAT_SIZE_0 << 4) | \
                        NV056_SET_FOG_ARRAY_FORMAT_TYPE_SHORT); \
        nvPusherAdjust(19); \
    } \
} while(0)

#define SET_KELVIN_BACKWARD_VERTEX_ARRAY_MODE() do { \
    if (nvMoCompParams.vertexMode != VERTEX_MODE_BACKWARD) { \
        nvMoCompParams.vertexMode = VERTEX_MODE_BACKWARD; \
        nvPushData(0, dDrawSubchannelOffset(NV_DD_KELVIN) + \
                      NV097_SET_VERTEX_DATA_ARRAY_OFFSET(0) | 0x340000); \
        nvPushData(1, 0); \
        nvPushData(2, 0); \
        nvPushData(3, 0); \
        nvPushData(4, 0); \
        nvPushData(5, 0); \
        nvPushData(6, 0); \
        nvPushData(7, 0); \
        nvPushData(8, 0); \
        nvPushData(9, 0); \
        nvPushData(10, 0); \
        nvPushData(11, 4); \
        nvPushData(12, 0); \
        nvPushData(13, 0); \
        nvPushData(14, dDrawSubchannelOffset(NV_DD_KELVIN) + \
                       NV097_SET_VERTEX_DATA_ARRAY_FORMAT(0) | 0x340000); \
        nvPushData(15, (8 << 8) | \
                       (NV097_SET_VERTEX_DATA_ARRAY_FORMAT_SIZE_2 << 4) | \
                        NV097_SET_VERTEX_DATA_ARRAY_FORMAT_TYPE_S32K); \
        nvPushData(16, (8 << 8) | \
                       (NV097_SET_VERTEX_DATA_ARRAY_FORMAT_SIZE_DISABLED << 4) | \
                        NV097_SET_VERTEX_DATA_ARRAY_FORMAT_TYPE_S32K); \
        nvPushData(17, (8 << 8) | \
                       (NV097_SET_VERTEX_DATA_ARRAY_FORMAT_SIZE_DISABLED << 4) | \
                        NV097_SET_VERTEX_DATA_ARRAY_FORMAT_TYPE_S32K); \
        nvPushData(18, (8 << 8) | \
                       (NV097_SET_VERTEX_DATA_ARRAY_FORMAT_SIZE_DISABLED << 4) | \
                        NV097_SET_VERTEX_DATA_ARRAY_FORMAT_TYPE_S32K); \
        nvPushData(19, (8 << 8) | \
                       (NV097_SET_VERTEX_DATA_ARRAY_FORMAT_SIZE_DISABLED << 4) | \
                        NV097_SET_VERTEX_DATA_ARRAY_FORMAT_TYPE_S32K); \
        nvPushData(20, (8 << 8) | \
                       (NV097_SET_VERTEX_DATA_ARRAY_FORMAT_SIZE_DISABLED << 4) | \
                        NV097_SET_VERTEX_DATA_ARRAY_FORMAT_TYPE_S32K); \
        nvPushData(21, (8 << 8) | \
                       (NV097_SET_VERTEX_DATA_ARRAY_FORMAT_SIZE_DISABLED << 4) | \
                        NV097_SET_VERTEX_DATA_ARRAY_FORMAT_TYPE_S32K); \
        nvPushData(22, (8 << 8) | \
                       (NV097_SET_VERTEX_DATA_ARRAY_FORMAT_SIZE_DISABLED << 4) | \
                        NV097_SET_VERTEX_DATA_ARRAY_FORMAT_TYPE_S32K); \
        nvPushData(23, (8 << 8) | \
                       (NV097_SET_VERTEX_DATA_ARRAY_FORMAT_SIZE_DISABLED << 4) | \
                        NV097_SET_VERTEX_DATA_ARRAY_FORMAT_TYPE_S32K); \
        nvPushData(24, (8 << 8) | \
                       (NV097_SET_VERTEX_DATA_ARRAY_FORMAT_SIZE_DISABLED << 4) | \
                        NV097_SET_VERTEX_DATA_ARRAY_FORMAT_TYPE_S32K); \
        nvPushData(25, (8 << 8) | \
                       (NV097_SET_VERTEX_DATA_ARRAY_FORMAT_SIZE_2 << 4) | \
                        NV097_SET_VERTEX_DATA_ARRAY_FORMAT_TYPE_S32K); \
        nvPushData(26, (8 << 8) | \
                       (NV097_SET_VERTEX_DATA_ARRAY_FORMAT_SIZE_DISABLED << 4) | \
                        NV097_SET_VERTEX_DATA_ARRAY_FORMAT_TYPE_S32K); \
        nvPushData(27, (8 << 8) | \
                       (NV097_SET_VERTEX_DATA_ARRAY_FORMAT_SIZE_DISABLED << 4) | \
                        NV097_SET_VERTEX_DATA_ARRAY_FORMAT_TYPE_S32K); \
        nvPusherAdjust(28); \
    } \
} while(0)

//---------------------------------------------------------------------------

// global varaiables

#ifdef  DEBUG
extern unsigned long overlaySurfaceBase;
extern unsigned long moCompDebugLevel;
#endif  // DEBUG

//---------------------------------------------------------------------------

// Because of differences between the Win9X and Win2K headers...
#ifdef  WINNT
typedef DDMOCOMPBUFFERINFO  DDMCBUFFERINFO, *LPDDMCBUFFERINFO;
#endif

// prototypes

void  __stdcall nvGetMoCompDriverInfo (LPDDHAL_GETDRIVERINFODATA lpData);
DWORD __stdcall nvMoCompExecute (DWORD dwMCMultiMonID,
                                 DWORD dwFunction,
                                 LPVOID lpInputData,
                                 DWORD dwInputDataSize,
                                 DWORD dwSurfaceIndex);
DWORD __stdcall nvMoCompConvertSurfaceFormat (DWORD fpVidMem, BOOL filterChroma, DWORD dwHowMuchToConvert);
DWORD __stdcall nvMoCompTemporalFilter (DWORD fpVidMem, BYTE combinationFactor);
DWORD __stdcall nvRenderCheckDecodeConfig(LPDDHAL_RENDERMOCOMPDATA lpRMCData);
DWORD __stdcall nvRenderCheckAlphaLoadConfig(LPDDHAL_RENDERMOCOMPDATA lpRMCData);
DWORD __stdcall nvRenderCheckAlphaCombineConfig(LPDDHAL_RENDERMOCOMPDATA lpRMCData);
DWORD __stdcall nvRenderGetPictureParams(LPDDHAL_RENDERMOCOMPDATA lpRMCData,
                                         LPDDMCBUFFERINFO lpPictureParams);
DWORD __stdcall nvRenderDoMotionComp(LPDDHAL_RENDERMOCOMPDATA lpRMCData,
                                     DWORD dwMacroblockIndex,
                                     DWORD dwDifferenceIndex);
LPBYTE __stdcall nvGetLinearAddress(LPDDRAWI_DDRAWSURFACE_LCL lpSurf);
DWORD  __stdcall nvRenderGetYUVPalette(LPDDHAL_RENDERMOCOMPDATA lpRMCData, DWORD dwRenderIndex);
DWORD  __stdcall nvRenderGetIA44Surface(LPDDHAL_RENDERMOCOMPDATA lpRMCData, DWORD dwRenderIndex);
DWORD  __stdcall nvRenderAlphaBlendCombination(LPDDHAL_RENDERMOCOMPDATA lpRMCData, DWORD dwRenderIndex);
DWORD  __stdcall nvDXVACompositeSubpicture(LPVOID lpInputData, DWORD dwIndex);
void   __stdcall nvUpdateDXVAIndexTable(GLOBALDATA *pDriverData);
DWORD  __stdcall nvMoCompFrameStatus(FLATPTR fpVidMem);
DWORD  __stdcall nvDXVABackEndAlphaBlend(FLATPTR fpVidMem);

#endif  // NVARCH >= 0x10

#ifdef __cplusplus
}
#endif // __cplusplus

#endif // _NVMOCOMP_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\ddraw\common\inc\nvLogo.h ===
/*
 * (C) Copyright NVIDIA Corporation Inc., 1996,1997,1998. All rights reserved.
 */
/********************************* Direct 3D *******************************\
*                                                                           *
* Module: nvLogo.h                                                          *
*   NVIDIA Logo loading/drawing routines.                                   *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*       Paul van der Kouwe 05/26/99 - created.                              *
*                                                                           *
\***************************************************************************/

#ifndef _NVLOGO_H_
#define _NVLOGO_H_

#ifdef __cplusplus
extern "C" {
#endif

void nvLoadLogo (void);
void nvFreeLogo (void);
void nvDrawLogo (PNVD3DCONTEXT pContext, BOOL bClear);

#ifdef __cplusplus
}
#endif // __cplusplus

#endif // _NVLOGO_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\ddraw\common\inc\nvObject.h ===
//**************************************************************************
//
//       Copyright 1993-1999 NVIDIA, Corporation.  All rights reserved.
//
//     NOTICE TO USER:   The source code  is copyrighted under  U.S. and
//     international laws.  Users and possessors of this source code are
//     hereby granted a nonexclusive,  royalty-free copyright license to
//     use this code in individual and commercial software.
//
//     Any use of this source code must include,  in the user documenta-
//     tion and  internal comments to the code,  notices to the end user
//     as follows:
//
//       Copyright 1993-1999 NVIDIA, Corporation.  All rights reserved.
//
//     NVIDIA, CORPORATION MAKES NO REPRESENTATION ABOUT THE SUITABILITY
//     OF  THIS SOURCE  CODE  FOR ANY PURPOSE.  IT IS  PROVIDED  "AS IS"
//     WITHOUT EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORPOR-
//     ATION DISCLAIMS ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,
//     INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY, NONINFRINGE-
//     MENT,  AND FITNESS  FOR A PARTICULAR PURPOSE.   IN NO EVENT SHALL
//     NVIDIA, CORPORATION  BE LIABLE FOR ANY SPECIAL,  INDIRECT,  INCI-
//     DENTAL, OR CONSEQUENTIAL DAMAGES,  OR ANY DAMAGES  WHATSOEVER RE-
//     SULTING FROM LOSS OF USE,  DATA OR PROFITS,  WHETHER IN AN ACTION
//     OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,  ARISING OUT OF
//     OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOURCE CODE.
//
//     U.S. Government  End  Users.   This source code  is a "commercial
//     item,"  as that  term is  defined at  48 C.F.R. 2.101 (OCT 1995),
//     consisting  of "commercial  computer  software"  and  "commercial
//     computer  software  documentation,"  as such  terms  are  used in
//     48 C.F.R. 12.212 (SEPT 1995)  and is provided to the U.S. Govern-
//     ment only as  a commercial end item.   Consistent with  48 C.F.R.
//     12.212 and  48 C.F.R. 227.7202-1 through  227.7202-4 (JUNE 1995),
//     all U.S. Government End Users  acquire the source code  with only
//     those rights set forth herein.
//
// **************************************************************************
//
//  Module: nvObject.h
//        definition of CNvObject
//
//  History:
//        Craig Duttweiler      (bertrem)      10Apr00      created
//
// **************************************************************************
#include "nvPatch.h"

// forward defintions
class CTexture;
class CVertexBuffer;
class CCommandBuffer;
class CVideoSurface;

class CNvObject
{
    //
    // constants
    //
public:
    enum
    {
        NVOBJ_UNKNOWN           = 0,
        NVOBJ_TEXTURE           = 1,
        NVOBJ_VERTEXBUFFER      = 2,
        NVOBJ_COMMANDBUFFER     = 3,
        NVOBJ_SIMPLESURFACE     = 4,
        NVOBJ_PALETTE           = 5,
        NVOBJ_VERTEXSHADER      = 6,
        NVOBJ_PIXELSHADER       = 7,
        NVOBJ_CACHEDPATCH       = 8,

        NVOBJID0                = 0x4e564944,
        NVOBJID1                = 0x420352ec,

        FLAG_CT_ENABLE          = 1,
        FLAG_CT_FLOCK           = 2,
        FLAG_CT_FBLT            = 4,
        FLAG_CT_ZLOCK           = 8,
        FLAG_CT_ZBLT            = 16,
        FLAG_CT_ZE              = 32,
        FLAG_CT_FRONT           = 64,
        FLAG_CT_DRAWPRIM        = 128,
        FLAG_CT_DBLCLEAR        = 256,

        FLAG_ALT_STENCIL_ENABLE  = 512,
        FLAG_ALT_STENCIL_BAD_SEM = 1024,
    };

    enum RTC_STATE
    {
        RTC_STATE_NONE = 0,
        RTC_START_NO_CLEAR = 1,
        RTC_START_PARTIAL = 2,
        RTC_STOP_PARTIAL = 3,
        RTC_CLEAR_FULL = 4
    };

    //
    // members
    //
protected:
// bank
    CNvObject        *m_pAttachedA;  // next attached surface on "axis 1" (used for mipmaps, flip chains)
    CNvObject        *m_pAttachedB;  // next attached surface on "axis 2" (used for cubemap faces)
    CNvObject        *m_pPrev;
    CNvObject        *m_pNext;
    DWORD             m_dwRefCount;
    void             *m_pObject;
    DWORD             m_dwClass;
// bank
    DWORD             m_dwPID;
    DWORD             m_dwDDLclID;   // a tag for the DDLcl with which this object is associated
    DWORD             m_dwHandle;    // the handle by which this object was last known (note it is not guaranteed to be currently valid!!)
    DWORD             m_dwFlags;
    BOOL              m_bDirty;      // used to indicate if the surface has been modified in CreateSurfaceEx
#ifdef WINNT
    PDD_SURFACE_LOCAL m_pDDSLcl;
#endif

    CNvObject        *m_pPalette;

    // data whose function varies depending on the type of object
    // please re-use these when possible rather than adding more fields
    DWORD             m_dwContextualValue0;   // for z-buffers: width of last RT with which associated
    DWORD             m_dwContextualValue1;   // for z-buffers: height of last RT with which associated

    DWORD             m_ContextDma;   // only used for system memory surfaces

#ifdef DEBUG
    DWORD             m_dwID[2];
#else
    DWORD             m_dwReserved[2];
#endif
    RTC_STATE         m_clrRTState;
    BOOL              m_bRTLocked;
    //
    // helpers
    //
public:
    inline BOOL isValid (void) const
    {
#ifdef DEBUG
        // readable
        if (IsBadReadPtr(this,sizeof(*this)))                   return FALSE;
        // match ID                     ss
        if ((m_dwID[0] != NVOBJID0) || (m_dwID[1] != NVOBJID1)) return FALSE;
#endif
        // valid if this instance is non NULL
        return this != NULL;
    }
    inline DWORD getClass (void) const
    {
#ifdef DEBUG
        // readable
        if (IsBadReadPtr(this,sizeof(*this)))                   return NVOBJ_UNKNOWN;
        // match ID
        if ((m_dwID[0] != NVOBJID0) || (m_dwID[1] != NVOBJID1)) return NVOBJ_UNKNOWN;
#endif
        // valid
        return this ? m_dwClass : NULL;
    }

    inline void               setObject           (DWORD dwClass, void *pObject) { m_dwClass = dwClass; m_pObject = pObject; }

    inline DWORD              getPID              (void) const { return m_dwPID; }
    inline CNvObject*         getNext             (void) const { return m_pNext; }

    inline CTexture*          getTexture          (void) const { return (CTexture*)       ((getClass() == NVOBJ_TEXTURE)       ? m_pObject : NULL); }
    inline CVertexBuffer*     getVertexBuffer     (void) const { return (CVertexBuffer*)  ((getClass() == NVOBJ_VERTEXBUFFER)  ? m_pObject : NULL); }
    inline CCommandBuffer*    getCommandBuffer    (void) const { return (CCommandBuffer*) ((getClass() == NVOBJ_COMMANDBUFFER) ? m_pObject : NULL); }
    inline CSimpleSurface*    getSimpleSurface    (void) const { return (CSimpleSurface*) ((getClass() == NVOBJ_SIMPLESURFACE) ? m_pObject : NULL); }

    // returns a pointer to the surface containing the palette information (called on the PaletteObject -- NOT the texture->paletteObject)
    inline CSimpleSurface*    getPaletteSurface   (void) const { return (CSimpleSurface*) ((getClass() == NVOBJ_PALETTE)       ? m_pObject : NULL); }

    inline CVertexShader*     getVertexShader     (void) const { return (CVertexShader*) ((getClass() == NVOBJ_VERTEXSHADER) ? m_pObject : NULL); }
    inline CPixelShader*      getPixelShader      (void) const { return (CPixelShader*)  ((getClass() == NVOBJ_PIXELSHADER)  ? m_pObject : NULL); }
    inline CPatch*            getPatch            (void) const { return (CPatch*)        ((getClass() == NVOBJ_CACHEDPATCH)  ? m_pObject : NULL); }

    inline void               setAttachedA        (CNvObject *pA)  { m_pAttachedA = pA; }
    inline CNvObject*         getAttachedA        (void) const { return (m_pAttachedA); }
    inline void               setAttachedB        (CNvObject *pB)  { m_pAttachedB = pB; }
    inline CNvObject*         getAttachedB        (void) const { return (m_pAttachedB); }

    inline void               setDDLclID          (DWORD dwID) { m_dwDDLclID = dwID; }
    inline DWORD              getDDLclID          (void) const { return (m_dwDDLclID); }

#ifdef WINNT
    inline void               setDDSLcl           (PDD_SURFACE_LOCAL pDDSLcl) { m_pDDSLcl = pDDSLcl; }
    inline PDD_SURFACE_LOCAL  getDDSLcl           (void) const { return m_pDDSLcl; }
#endif // WINNT

    inline void               setHandle           (DWORD dwH)  { m_dwHandle = dwH; }
    inline DWORD              getHandle           (void) const { return (m_dwHandle); }

    inline BOOL               hasCTEnabled        (void) const { return m_dwFlags & FLAG_CT_ENABLE; }
    inline BOOL               hasCTEnabledNotFront(void) const { return (m_dwFlags & (FLAG_CT_ENABLE | FLAG_CT_FRONT)) == FLAG_CT_ENABLE; }
    inline void               enableCT            (void)       { m_dwFlags |= FLAG_CT_ENABLE; }
    inline void               disableCT           (void)       { m_dwFlags &= ~FLAG_CT_ENABLE; }

    inline BOOL               isAltStencilEnabled       (void) const { return (m_dwFlags & FLAG_ALT_STENCIL_ENABLE); }
    inline void               tagAltStencilEnabled      (void)       { m_dwFlags |= FLAG_ALT_STENCIL_ENABLE; }
    inline void               tagAltStencilDisabled     (void)       { m_dwFlags &= ~FLAG_ALT_STENCIL_ENABLE; }
    inline BOOL               hasAltStencilBadSemantics (void) const { return (m_dwFlags & FLAG_ALT_STENCIL_BAD_SEM); }
    inline void               tagAltStencilBadSemantics (void)       { m_dwFlags |= FLAG_ALT_STENCIL_BAD_SEM; }

    inline BOOL               isCTFLock           (void) const { return m_dwFlags & FLAG_CT_FLOCK; }
    inline void               tagFLock            (void)       { m_dwFlags |= FLAG_CT_FLOCK; }

    inline BOOL               isCTFBlt            (void) const { return m_dwFlags & FLAG_CT_FBLT; }
    inline void               tagFBlt             (void)       { m_dwFlags |= FLAG_CT_FBLT; }

    inline BOOL               isCTZLock           (void) const { return m_dwFlags & FLAG_CT_ZLOCK; }
    inline void               tagZLock            (void)       { m_dwFlags |= FLAG_CT_ZLOCK; }

    inline BOOL               isCTZBlt            (void) const { return m_dwFlags & FLAG_CT_ZBLT; }
    inline void               tagZBlt             (void)       { m_dwFlags |= FLAG_CT_ZBLT; }

    inline void               tagDblClear         (void)       { m_dwFlags |= FLAG_CT_DBLCLEAR; }

    inline BOOL               hasBadCTSem         (void) const { return m_dwFlags & (FLAG_CT_ZBLT | FLAG_CT_ZLOCK | FLAG_CT_ZE | FLAG_CT_DBLCLEAR | FLAG_CT_FBLT); }
                                                                 /*| FLAG_CT_FBLT | FLAG_CT_FLOCK */

    inline BOOL               isCTDrawPrim        (void) const { return m_dwFlags & FLAG_CT_DRAWPRIM; }
    inline void               clearCTDrawPrim     (void)       { m_dwFlags &= ~FLAG_CT_DRAWPRIM; }
    inline void               setCTDrawPrim       (void)       { m_dwFlags |= FLAG_CT_DRAWPRIM; }

    inline void               setCTFront          (void)       { m_dwFlags |= FLAG_CT_FRONT; }
    inline BOOL               isCTFront           (void) const { return m_dwFlags & FLAG_CT_FRONT; }

    inline void               toggleFrontDrawPrim (void)       { m_dwFlags ^= FLAG_CT_FRONT | FLAG_CT_DRAWPRIM; }
    inline void               tagCTZE             (void)       { m_dwFlags |= FLAG_CT_ZE; }

    inline DWORD              getFlags            (void) const { return m_dwFlags; }

    inline BOOL               isDirty             (void) const { return m_bDirty;  }
    inline void               setDirty            (void)       { m_bDirty = TRUE;  }
    inline void               clearDirty          (void)       { m_bDirty = FALSE; }

    inline void               setRTLocked         (void)       { m_bRTLocked = TRUE; m_clrRTState = RTC_STATE_NONE; }
    inline bool               doClearRTAll        (void) const { return (m_clrRTState == RTC_STATE_NONE) || (m_clrRTState == RTC_CLEAR_FULL); }
    inline bool               doClearRTPartial    (void) const { return m_clrRTState == RTC_START_PARTIAL; }
    inline bool               doClearRTNone       (void) const { return (m_clrRTState == RTC_START_NO_CLEAR) || (m_clrRTState == RTC_STOP_PARTIAL); }
    inline void               adjustRTCBounds     (DWORD &y, DWORD &h) const { if (doClearRTPartial()) {y += 2*h/16; h = 14*h/16; }}
    inline void               allowClearRT        (void)       { m_clrRTState = RTC_STATE_NONE; }

    // set/access the linked palette (relevant only for CNvObjects containing textures)
    inline void               setPalette          (CNvObject *pPal)  { m_pPalette = pPal; }
    inline CNvObject*         getPalette          (void) const       { return (m_pPalette); }

    inline void               setContextDma       (DWORD dwCDma)  { m_ContextDma = dwCDma; }
    inline DWORD              getContextDma       (void) const    { return m_ContextDma; }

    inline void               setContextualValue0 (DWORD dwValue) { m_dwContextualValue0 = dwValue; }
    inline DWORD              getContextualValue0 (void) const    { return m_dwContextualValue0; }
    inline void               setContextualValue1 (DWORD dwValue) { m_dwContextualValue1 = dwValue; }
    inline DWORD              getContextualValue1 (void) const    { return m_dwContextualValue1; }

    //
    // internal helpers
    //
#ifdef DEBUG
           void dbgTestIntegrity (void);
#else
    inline void dbgTestIntegrity (void) const {}
#endif

    //
    // reference count
    //
public:
    inline DWORD reference (void) {
        DPF_LEVEL(NVDBG_LEVEL_NVOBJ_INFO,"NVObjReference: this = %08x handle = %08x refcount = %d\n",this,m_dwHandle, m_dwRefCount);
        return ++m_dwRefCount;
    }

    inline DWORD release   (void) {
        if (--m_dwRefCount){
            DPF_LEVEL(NVDBG_LEVEL_NVOBJ_INFO,"NVObjRelease: this = %08x handle = %08x refcount = %d\n",this,m_dwHandle, m_dwRefCount);
            return m_dwRefCount;
        }
        DPF_LEVEL(NVDBG_LEVEL_NVOBJ_INFO,"NVObjRelease(Del): this = %08x handle = %08x refcount = %d\n",this,m_dwHandle, m_dwRefCount);
        delete this;
        return 0;
    }

    // completely swap the contents of two NvObjects EXCEPT :
    // - pPrev and pNext, since doing so would mess up the chain
    // - reserved fields that are currently unused
    inline void swap (CNvObject *pNvObj) {
        NV_SWAP_1 (m_pAttachedA,         pNvObj->m_pAttachedA);
        NV_SWAP_1 (m_pAttachedB,         pNvObj->m_pAttachedB);
        NV_SWAP_1 (m_dwRefCount,         pNvObj->m_dwRefCount);
        NV_SWAP_1 (m_pObject,            pNvObj->m_pObject);
        NV_SWAP_1 (m_dwClass,            pNvObj->m_dwClass);
        NV_SWAP_1 (m_dwPID,              pNvObj->m_dwPID);
        NV_SWAP_1 (m_dwDDLclID,          pNvObj->m_dwDDLclID);
        NV_SWAP_1 (m_dwHandle,           pNvObj->m_dwHandle);
        NV_SWAP_1 (m_dwFlags,            pNvObj->m_dwFlags);
        NV_SWAP_1 (m_bDirty,             pNvObj->m_bDirty);
    #ifdef WINNT
        NV_SWAP_1 (m_pDDSLcl,            pNvObj->m_pDDSLcl);
    #endif
        NV_SWAP_1 (m_pPalette,           pNvObj->m_pPalette);
        NV_SWAP_1 (m_ContextDma,         pNvObj->m_ContextDma);

        NV_SWAP_1 (m_dwContextualValue0, pNvObj->m_dwContextualValue0);
        NV_SWAP_1 (m_dwContextualValue1, pNvObj->m_dwContextualValue1);

    #ifdef DEBUG
        NV_SWAP_1 (m_dwID[0],            pNvObj->m_dwID[0]);
        NV_SWAP_1 (m_dwID[1],            pNvObj->m_dwID[1]);
    #endif

        // fix up the back-pointers in the child objects
        ((CSimpleSurface *)(  this->m_pObject))->setWrapper (  this);
        ((CSimpleSurface *)(pNvObj->m_pObject))->setWrapper (pNvObj);
    }

    //
    // construction
    //
public:
    inline CNvObject (DWORD dwPID)
    {
        // sanity
        if (global.pNvObjectHead)
        {
            global.pNvObjectHead->dbgTestIntegrity();
        }
        // assign
        m_pAttachedA  = NULL;
        m_pAttachedB  = NULL;
        m_dwClass     = NVOBJ_UNKNOWN;
        m_pObject     = NULL;
        m_dwPID       = dwPID;
        m_dwDDLclID   = 0;
        m_dwHandle    = 0;
        m_dwRefCount  = 1;
        m_dwFlags     = 0;
        m_bDirty      = FALSE;
        m_pPalette    = NULL;
        m_ContextDma  = 0;
        m_dwContextualValue0 = 0;
        m_dwContextualValue1 = 0;
        m_clrRTState = RTC_STATE_NONE;
        m_bRTLocked = FALSE;

#ifdef DEBUG
        m_dwID[0]     = NVOBJID0;
        m_dwID[1]     = NVOBJID1;
#endif

        // attach to our list of all NvObjects
        m_pPrev = NULL;
        m_pNext = global.pNvObjectHead;
        if (m_pNext) m_pNext->m_pPrev = this;
        global.pNvObjectHead = this;

        // check sanity
        dbgTestIntegrity();
        if (m_pPrev) m_pPrev->dbgTestIntegrity();
        if (m_pNext) m_pNext->dbgTestIntegrity();
        if (global.pNvObjectHead)
        {
            global.pNvObjectHead->dbgTestIntegrity();
        }
        DPF_LEVEL(NVDBG_LEVEL_NVOBJ_INFO,"NVObjCreate: this = %08x handle = %08x refcount = %d\n",this,m_dwHandle, m_dwRefCount);
    }


    void CNvObject::checkClearRT (DWORD dwEarlyCopyStrategy, float *A, float *B, float *C)
    {
        float dist;
        float aa, bb, cc;
        const float epsilon = 20.0f;
        static DWORD t[5][3] ={
            {0, 0, 0},                              //RTC_STATE_NONE
            {0x412AB541, 0xC18F6038, 0xC1F25F30},   //RTC_START_NO_CLEAR
            {0xC1E02B5C, 0x41329DB7, 0xC203223C},   //RTC_START_PARTIAL
            {0x3FB8F4FF, 0xBDD35fDF, 0x41cc4DED},   //RTC_STOP_PARTIAL
            {0x4042B599, 0xC012F702, 0xC110395b}    //RTC_CELAER_FULL
        };
        static float *table[5] = {(float *) t[0], (float *) t[1], (float *) t[2], (float *) t[3], (float *) t[4] };

        if ((dwEarlyCopyStrategy != 0x34))
        {
            allowClearRT();
            return;
        }

        if (m_bRTLocked)
            m_clrRTState = RTC_CLEAR_FULL;
        else if (m_clrRTState == RTC_STATE_NONE)
        {
            m_clrRTState = RTC_START_NO_CLEAR;
        }
        else
        {
            switch (m_clrRTState) {
            case RTC_START_NO_CLEAR:
                aa = table[RTC_START_PARTIAL][0] - *A;
                aa *= aa;
                bb = table[RTC_START_PARTIAL][1] - *B;
                bb *= bb;
                cc = table[RTC_START_PARTIAL][2] - *C;
                cc *= cc;
                dist = aa + bb + cc;
                if (dist < epsilon) m_clrRTState = RTC_START_PARTIAL;
                break;
            case RTC_START_PARTIAL:
                aa = table[RTC_STOP_PARTIAL][0] - *A;
                aa *= aa;
                bb = table[RTC_STOP_PARTIAL][1] - *B;
                bb *= bb;
                cc = table[RTC_STOP_PARTIAL][2] - *C;
                cc *= cc;
                dist = aa + bb + cc;
                if (dist < epsilon) m_clrRTState = RTC_STOP_PARTIAL;
                break;
            case RTC_STOP_PARTIAL:
                aa = table[RTC_CLEAR_FULL][0] - *A;
                aa *= aa;
                bb = table[RTC_CLEAR_FULL][1] - *B;
                bb *= bb;
                cc = table[RTC_CLEAR_FULL][2] - *C;
                cc *= cc;
                dist = aa + bb + cc;
                if (dist < epsilon) m_clrRTState = RTC_CLEAR_FULL;
                break;
            case RTC_CLEAR_FULL:
                break;
            };


        }

        m_bRTLocked = FALSE;
    }



    // do NOT call delete on this object. ONLY call release()
private:
    ~CNvObject (void)
    {
        if (m_pObject != NULL)
        {
            clearReferences();

            switch (getClass()) {
                case NVOBJ_TEXTURE:
                    delete (CTexture*)m_pObject;
                    break;
                case NVOBJ_VERTEXBUFFER:
                    delete (CVertexBuffer*)m_pObject;
                    break;
                case NVOBJ_COMMANDBUFFER:
                    delete (CCommandBuffer*)m_pObject;
                    break;
                case NVOBJ_PALETTE:
                    delete (CSimpleSurface*)m_pObject;
                    break;
                case NVOBJ_VERTEXSHADER:
                    delete (CVertexShader*)m_pObject;
                    break;
                case NVOBJ_PIXELSHADER:
                    delete (CPixelShader*)m_pObject;
                    break;
                case NVOBJ_CACHEDPATCH:
                    delete (CPatch*)m_pObject;
                    break;
                case NVOBJ_SIMPLESURFACE:
                    delete (CSimpleSurface*)m_pObject;
                    break;
            }
            m_pObject = NULL;
        }

        // remove class information
        m_dwClass = NVOBJ_UNKNOWN;

        if (m_ContextDma) {
            NvRmFree(pDriverData->dwRootHandle, pDriverData->dwRootHandle, m_ContextDma);
        }

        // check sanity
#ifdef DEBUG
        if (m_dwRefCount)
        {
            DPF ("CNvObject deleted with non-zero ref count");
        }
        if (global.pNvObjectHead)
        {
            global.pNvObjectHead->dbgTestIntegrity();
        }
        dbgTestIntegrity();
#endif
        // free from list
        if (m_pPrev) m_pPrev->m_pNext  = m_pNext;
                else global.pNvObjectHead = m_pNext;
        if (m_pNext) m_pNext->m_pPrev  = m_pPrev;
        // check sanity
#ifdef DEBUG
        if (m_pPrev) m_pPrev->dbgTestIntegrity();
        if (m_pNext) m_pNext->dbgTestIntegrity();
        if (global.pNvObjectHead)
        {
            global.pNvObjectHead->dbgTestIntegrity();
        }
        memset (this,0xCC,sizeof(*this));
#endif
    }

    // remove all references to an object prior to deletion
    void clearReferences (void)
    {
        PNVD3DCONTEXT pContext;
        DWORD i;

        switch (getClass()) {
            case NVOBJ_VERTEXBUFFER:
                pContext = (PNVD3DCONTEXT) getDC()->dwContextListHead;
                while (pContext) {
                    for (i=0; i<NV_CAPS_MAX_STREAMS; i++) {
                        if (pContext->ppDX8Streams[i] == (CVertexBuffer *)m_pObject) {
                            DPF_LEVEL (NVDBG_LEVEL_SURFACEALLOC, "active stream deleted. reference removed");
                            pContext->ppDX8Streams[i] = NULL;
                        }
                    }
                    pContext = pContext->pContextNext;
                }
                break;
            default:
                // nada
                break;
        }  // switch
    }

};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\ddraw\common\inc\nvPatch.h ===
// **************************************************************************
//
//       Copyright 1993-1999 NVIDIA, Corporation.  All rights reserved.
//
//     NOTICE TO USER:   The source code  is copyrighted under  U.S. and
//     international laws.  Users and possessors of this source code are
//     hereby granted a nonexclusive,  royalty-free copyright license to
//     use this code in individual and commercial software.
//
//     Any use of this source code must include,  in the user documenta-
//     tion and  internal comments to the code,  notices to the end user
//     as follows:
//
//       Copyright 1993-1999 NVIDIA, Corporation.  All rights reserved.
//
//     NVIDIA, CORPORATION MAKES NO REPRESENTATION ABOUT THE SUITABILITY
//     OF  THIS SOURCE  CODE  FOR ANY PURPOSE.  IT IS  PROVIDED  "AS IS"
//     WITHOUT EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORPOR-
//     ATION DISCLAIMS ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,
//     INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY, NONINFRINGE-
//     MENT,  AND FITNESS  FOR A PARTICULAR PURPOSE.   IN NO EVENT SHALL
//     NVIDIA, CORPORATION  BE LIABLE FOR ANY SPECIAL,  INDIRECT,  INCI-
//     DENTAL, OR CONSEQUENTIAL DAMAGES,  OR ANY DAMAGES  WHATSOEVER RE-
//     SULTING FROM LOSS OF USE,  DATA OR PROFITS,  WHETHER IN AN ACTION
//     OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,  ARISING OUT OF
//     OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOURCE CODE.
//
//     U.S. Government  End  Users.   This source code  is a "commercial
//     item,"  as that  term is  defined at  48 C.F.R. 2.101 (OCT 1995),
//     consisting  of "commercial  computer  software"  and  "commercial
//     computer  software  documentation,"  as such  terms  are  used in
//     48 C.F.R. 12.212 (SEPT 1995)  and is provided to the U.S. Govern-
//     ment only as  a commercial end item.   Consistent with  48 C.F.R.
//     12.212 and  48 C.F.R. 227.7202-1 through  227.7202-4 (JUNE 1995),
//     all U.S. Government End Users  acquire the source code  with only
//     those rights set forth herein.
//
// ********************************* Direct 3D ******************************
//
//  Module: nvPatch.h
//      description here
//
// **************************************************************************
//
//  History:
//      Daniel ROhrer?          Jul00           DX8 development
//
// **************************************************************************

#ifndef _nvPatch_h
#define _nvPatch_h

#ifdef WINNT
#include "driver.h"
#endif
#include "nvPatchInterface.h"

#define CPATCH_DP2_BUFFER_SIZE 8000
extern NV_PATCH_BACKEND nvCelsiusImm_Backend;
extern NV_PATCH_BACKEND nvKelvinImm_Backend;

//max D3DOrder is 5 so 6x6=36 ctrl pts per patch max here.
// scratch[attribute][u][v][xyzw]

class CPatch {
    private:
        DWORD               m_dwFlags;          //
        DWORD               m_dwHandle;         //cache patch handle
        CNvObject          *m_pWrapperObject;   //

        //copy of pRSInfo data
        DWORD               m_subpatchcount;
        DWORD               m_dwHeight, m_dwWidth, m_dwOrder, m_dwStride;
        DWORD               m_dwVertexOffset;
        NV_PATCH_VERTEX_FORMAT_TYPE m_dwTypes[NV_PATCH_NUMBER_OF_ATTRIBS];

        //cached data ptrs
        FDMatrix            **m00, **m10, **m01, **m11;
        NV_PATCH_FRAC_QUAD_GUARD_INFO **guardQF;
        NV_PATCH_QUAD_INFO       **cachedQuadInfo;
        NV_PATCH_FRAC_TRI_GUARD_INFO  **guardTF;
        //temporary data ptrs -- we need to allocate a patches worth of data then free it at the end.

        NV_PATCH_INFO       m_PatchData;        //patch struct to hand to shared code

        //callback functions
        static NV_PATCH_DRIVER_CALLBACKS m_callbacks;
        static void *alloc         (void *context, size_t bytes);
        static void free           (void *context, void *ptr   );
        static void memcpy         (void *dst, const void *src, size_t size);

        void setStream      (UINT streamID, void *memptr, DWORD stride, DWORD pitch,
                             NV_PATCH_VERTEX_FORMAT_TYPE mt, UINT order);
    public:

        CPatch(CNvObject *pObj,DWORD dwHandle);
        ~CPatch(void);

        void getCachedData  (DWORD subpatch);       //copy the 'nth' subpatch FD ptrs over to m_PatchData for rendering
        void saveCachedData (DWORD subpatch);       //save the 'nth' subpatch FD ptrs from m_PatchData (i.e. cache new data)
        void freeCached();                          //free any cached data members
        BOOL allocCached(DWORD);                    //alloc space for n 'subpatches' worth of FD coeffs/guards.

        void setupStreams   (PNVD3DCONTEXT pContext);

        void copyDataToScratch(PNVD3DCONTEXT,DWORD,DWORD);
        void copyDataToScratchTri(PNVD3DCONTEXT,DWORD,DWORD);
        void convertBsplineToBezier();              //helper routines -- converts patch data inplace
        void convertCatmullRomToBezier();           //helper routines -- converts patch data inplace
        void setBasis       (NV_PATCH_BASIS_TYPE bt)    {m_PatchData.basis = bt; }
        UINT getBasis()                                 {return m_PatchData.basis; }
        NV_PATCH_INFO*      getInfo()                   { return &m_PatchData; }

        void setTessMode    (UINT rf)                   {(rf == NV_PATCH_FLAG_TESS_FRACTIONAL ? m_PatchData.flags |= NV_PATCH_FLAG_TESS_FRACTIONAL : 
                                                                                                m_PatchData.flags &= ~NV_PATCH_FLAG_TESS_MASK);}        
        void setPrimMode    (UINT rf)                   {(rf == NV_PATCH_FLAG_TYPE_TRIANGULAR ? m_PatchData.flags |= NV_PATCH_FLAG_TYPE_TRIANGULAR : 
                                                                                                m_PatchData.flags &= ~NV_PATCH_FLAG_TYPE_MASK);}        
        void setTessellation(float *segs, int flag)     { if((flag & NV_PATCH_FLAG_TYPE_MASK) == NV_PATCH_FLAG_TYPE_TRIANGULAR)
                                                          {  m_PatchData.tess.tri.n1 = segs[1]; 
                                                             m_PatchData.tess.tri.n2 = segs[2]; 
                                                             m_PatchData.tess.tri.n3 = segs[0]; }
                                                          else
                                                          {  m_PatchData.tess.tensor.nu0 = segs[0]; m_PatchData.tess.tensor.nv0 = segs[3]; 
                                                             m_PatchData.tess.tensor.nu1 = segs[2]; m_PatchData.tess.tensor.nv1 = segs[1]; }
                                                        }        
        void setOriginalTessellation(float *segs, int flag){ if((flag & NV_PATCH_FLAG_TYPE_MASK) == NV_PATCH_FLAG_TYPE_TRIANGULAR)
                                                          {  m_PatchData.originaltess.tri.n1 = segs[1]; 
                                                             m_PatchData.originaltess.tri.n2 = segs[2]; 
                                                             m_PatchData.originaltess.tri.n3 = segs[0]; }
                                                          else
                                                          {  m_PatchData.originaltess.tensor.nu0 = segs[0]; m_PatchData.originaltess.tensor.nv0 = segs[3]; 
                                                             m_PatchData.originaltess.tensor.nu1 = segs[2]; m_PatchData.originaltess.tensor.nv1 = segs[1]; }
                                                        }        
       
        //THERE ARE SIDE AFFECTS TO THIS CALL IN REGARDS TO MEMORY ALLOCATION
        void setOutputMode  (NV_PATCH_BACKEND_TYPE rf);
        void prepareBuffer  (long);                     //stream type should be set BEFORE calling this

        void setVertexOffset(DWORD dwOffset)            {m_dwVertexOffset = dwOffset;}
        void setAutoNormal  (UINT dwSrc, UINT dwDst)    {m_PatchData.srcNormal = dwSrc; m_PatchData.dstNormal = dwDst;
                                                         m_PatchData.flags |= NV_PATCH_FLAG_AUTO_NORMAL; }
        void setAutoUV      (UINT dwSrc, UINT dwDst, int i){m_PatchData.srcUV[i] = dwSrc; m_PatchData.dstUV[i] = dwDst;
                                                         m_PatchData.flags |= NV_PATCH_FLAG_AUTO_UV;}
        void  setDimension  (UINT width, UINT height)   {m_dwWidth = width; m_dwHeight = height;}
        UINT  getWidth      ()                          {return m_dwWidth;}
        UINT  getHeight     ()                          {return m_dwHeight;}
        void  setOrder      (DWORD order)               {m_dwOrder = order;}
        DWORD getOrder      ()                          {return m_dwOrder;}
        void  setStride     (DWORD stride)              {m_dwStride = stride;}
        DWORD getStride     ()                          {return m_dwStride;}
        void  setTextureOffsets(float startu, float endu,
                               float startv, float endv){ m_PatchData.startu = startu; m_PatchData.startv = startv;
                                                          m_PatchData.endu   = endu;   m_PatchData.endv   = endv; }

        float getSeg        (UINT i)                    {switch(i){
                                                            case 0: return m_PatchData.tess.tensor.nu0;
                                                            case 1: return m_PatchData.tess.tensor.nv1;
                                                            case 2: return m_PatchData.tess.tensor.nu1;
                                                            case 3: return m_PatchData.tess.tensor.nv0;
                                                            default: return 0;
                                                        }}
        void setCalc        (UINT df)                   {for(int i=0; i < NV_PATCH_NUMBER_OF_ATTRIBS; i++) m_PatchData.maps[i].dirtyFlags = df;}
        UINT getCalc        ()                          {return m_PatchData.maps[0].dirtyFlags;}
        void setContext     (PNVD3DCONTEXT pContext)    {m_PatchData.context = (void*)pContext;}
        void setVertexStride(int size)                  {m_PatchData.vertexSize = size;}
        unsigned char* getCachedPB()                    {return m_PatchData.cachedPB;}
        unsigned long  getCachedPBSize()                {return m_PatchData.cachedPBSize;}
        void           allocCachedPB(unsigned long dwSize){m_PatchData.cachedPB = new unsigned char[dwSize]; 
                                                         m_PatchData.cachedPBSize = dwSize;
                                                         m_PatchData.cachedPBCounter = 0;
                                                        }
        void           freeCachedPB()                   {if(m_PatchData.cachedPB) delete []m_PatchData.cachedPB; 
                                                                                  m_PatchData.cachedPB = NULL;
                                                                                  m_PatchData.cachedPBSize = 0;}        
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\ddraw\common\inc\nvPopupList.h ===
#ifndef STEREO_POPUP_LIST_CLASS_DECL
#define STEREO_POPUP_LIST_CLASS_DECL

#include "PopupAgent.h"
#include "duma.h"

///////////////////////////////////////////////////////////
//
// popup flavours
//
///////////////////////////////////////////////////////////
class CPerfStatPopup: public CPopupAgent
{
public:
	CPerfStatPopup();
	virtual ~CPerfStatPopup();
	
};

class CStereoStatPopup: public CPopupAgent, protected STEREOSTATS  
{
public:
	CStereoStatPopup();
	virtual ~CStereoStatPopup();

	void			setContext(NVD3DCONTEXT* aContext); //overloaded: set context and update stereo stats from context
};

///////////////////////////////////////////////////////////
//
// popup controller
//
///////////////////////////////////////////////////////////
class CPopupAgentList
{
public:
//types
    struct PopupHotkeys
    {
        HOTKEY  PopupToggle;
        HOTKEY  FPStoggle;
        HOTKEY  StatsToggle;
    };

protected:
//attributes
	char			strModule[MAX_PATH];
	HMODULE			hMod;
	CPopupAgent*	popupAgentList; //root of the list
    bool            bPerfStat;      //FPS popup enabled/disabled
    bool            bStereoStat;    //Stereo statistics popup enabled/disabled
    bool            isPopupEnabled;
    PopupHotkeys    hotkeys;
//members
    void            add(CPopupAgent* next);
public:
	CPopupAgentList();
	~CPopupAgentList();
	HRESULT			create();
	HRESULT			create(const char* aModule);
	HRESULT			destroy();
    HRESULT         initHotKeys();
    HRESULT         finiHotKeys();
	HRESULT			render(NVD3DCONTEXT *pContext);
    bool&           enabled() {return isPopupEnabled;};
    void            toggle()   {isPopupEnabled = isPopupEnabled?false:true;};
    void            getOptions();
};

extern CPopupAgentList popupAgents;

#endif //STEREO_POPUP_LIST_CLASS_DECL
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\ddraw\common\inc\nvSemaphore.h ===
// **************************************************************************
//
//       Copyright 1993-1999 NVIDIA, Corporation.  All rights reserved.
//
//     NOTICE TO USER:   The source code  is copyrighted under  U.S. and
//     international laws.  Users and possessors of this source code are
//     hereby granted a nonexclusive,  royalty-free copyright license to
//     use this code in individual and commercial software.
//
//     Any use of this source code must include,  in the user documenta-
//     tion and  internal comments to the code,  notices to the end user
//     as follows:
//
//       Copyright 1993-1999 NVIDIA, Corporation.  All rights reserved.
//
//     NVIDIA, CORPORATION MAKES NO REPRESENTATION ABOUT THE SUITABILITY
//     OF  THIS SOURCE  CODE  FOR ANY PURPOSE.  IT IS  PROVIDED  "AS IS"
//     WITHOUT EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORPOR-
//     ATION DISCLAIMS ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,
//     INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY, NONINFRINGE-
//     MENT,  AND FITNESS  FOR A PARTICULAR PURPOSE.   IN NO EVENT SHALL
//     NVIDIA, CORPORATION  BE LIABLE FOR ANY SPECIAL,  INDIRECT,  INCI-
//     DENTAL, OR CONSEQUENTIAL DAMAGES,  OR ANY DAMAGES  WHATSOEVER RE-
//     SULTING FROM LOSS OF USE,  DATA OR PROFITS,  WHETHER IN AN ACTION
//     OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,  ARISING OUT OF
//     OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOURCE CODE.
//
//     U.S. Government  End  Users.   This source code  is a "commercial
//     item,"  as that  term is  defined at  48 C.F.R. 2.101 (OCT 1995),
//     consisting  of "commercial  computer  software"  and  "commercial
//     computer  software  documentation,"  as such  terms  are  used in
//     48 C.F.R. 12.212 (SEPT 1995)  and is provided to the U.S. Govern-
//     ment only as  a commercial end item.   Consistent with  48 C.F.R.
//     12.212 and  48 C.F.R. 227.7202-1 through  227.7202-4 (JUNE 1995),
//     all U.S. Government End Users  acquire the source code  with only
//     those rights set forth herein.
//
// ********************************* Direct 3D ******************************
//
//  Module: nvSemaphore.cpp
//      a semaphore class, for use with kelvin-style semaphores
//      handles allocation and management
//
// **************************************************************************
//
//  History:
//      Craig Duttweiler        13Sep2000         created, NV20 development
//
// **************************************************************************

#ifndef __NVSEMAPHORE_H
#define __NVSEMAPHORE_H

#if (NVARCH >= 0x020)
#ifdef KELVIN_SEMAPHORES

//---------------------------------------------------------------------------

// forward definitions

class CSimpleSurface;
class CSemaphoreManager;

//---------------------------------------------------------------------------

class CSemaphore
{

public:
    const enum {
        SEMAPHORE_RELEASE_KELVIN_BACKEND = 1,
        SEMAPHORE_RELEASE_KELVIN_TEXTURE = 2,
        SEMAPHORE_RELEASE_DAC            = 3
    };

private:
    DWORD   m_dwValue;   // must be first
    DWORD   m_dwOffset;  // offset of this semaphore within the semphore context DMA
    BOOL    m_bInUse;
    DWORD   m_dwPad;     // semaphores must be 16-byte aligned

public:
    BOOL    acquire (DWORD dwValue, CPushBuffer *pPusher);
    BOOL    release (DWORD dwValue, CPushBuffer *pPusher);
    BOOL    release (DWORD dwValue, CPushBuffer *pPusher, DWORD dwSubCh, DWORD dwType);

    DWORD   read    (void)      { return (m_dwValue); }

    CSemaphore()    {}
    ~CSemaphore()   {}

    friend CSemaphoreManager;

};

//---------------------------------------------------------------------------

class CSemaphoreManager
{

public:

    const enum {
        SEMAPHORE_CONTEXT_DMA_IN_MEMORY   = 0xDD001E00,
        SEMAPHORE_CONTEXT_DMA_FROM_MEMORY = 0xDD001E01
    };

private:

    CSimpleSurface *m_pSemaphoreSurface;
    BYTE           *m_pSemaphoreMemory;

public:

    BOOL            create    (void);
    BOOL            destroy   (void);
    CSemaphore     *allocate  (DWORD dwInitialValue);
    BOOL            free      (CSemaphore *pSem);

    CSemaphoreManager()       {   m_pSemaphoreSurface = (CSimpleSurface *)NULL;
                                  m_pSemaphoreMemory  = NULL;
                              }

    ~CSemaphoreManager()      {}

};

#endif  // KELVIN_SEMAPHORES
#endif  // NVARCH >= 0x020

#endif  // __NVSEMAPHORE_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\ddraw\common\inc\nvRefCount.h ===
/***************************************************************************\
|*                                                                           *|
|*       Copyright 1993-1999 NVIDIA, Corporation.  All rights reserved.      *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.  Users and possessors of this source code are     *|
|*     hereby granted a nonexclusive,  royalty-free copyright license to     *|
|*     use this code in individual and commercial software.                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*       Copyright 1993-1999 NVIDIA, Corporation.  All rights reserved.      *|
|*                                                                           *|
|*     NVIDIA, CORPORATION MAKES NO REPRESENTATION ABOUT THE SUITABILITY     *|
|*     OF  THIS SOURCE  CODE  FOR ANY PURPOSE.  IT IS  PROVIDED  "AS IS"     *|
|*     WITHOUT EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORPOR-     *|
|*     ATION DISCLAIMS ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,     *|
|*     INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY, NONINFRINGE-     *|
|*     MENT,  AND FITNESS  FOR A PARTICULAR PURPOSE.   IN NO EVENT SHALL     *|
|*     NVIDIA, CORPORATION  BE LIABLE FOR ANY SPECIAL,  INDIRECT,  INCI-     *|
|*     DENTAL, OR CONSEQUENTIAL DAMAGES,  OR ANY DAMAGES  WHATSOEVER RE-     *|
|*     SULTING FROM LOSS OF USE,  DATA OR PROFITS,  WHETHER IN AN ACTION     *|
|*     OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,  ARISING OUT OF     *|
|*     OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOURCE CODE.     *|
|*                                                                           *|
|*     U.S. Government  End  Users.   This source code  is a "commercial     *|
|*     item,"  as that  term is  defined at  48 C.F.R. 2.101 (OCT 1995),     *|
|*     consisting  of "commercial  computer  software"  and  "commercial     *|
|*     computer  software  documentation,"  as such  terms  are  used in     *|
|*     48 C.F.R. 12.212 (SEPT 1995)  and is provided to the U.S. Govern-     *|
|*     ment only as  a commercial end item.   Consistent with  48 C.F.R.     *|
|*     12.212 and  48 C.F.R. 227.7202-1 through  227.7202-4 (JUNE 1995),     *|
|*     all U.S. Government End Users  acquire the source code  with only     *|
|*     those rights set forth herein.                                        *|
|*                                                                           *|
 \***************************************************************************/
#ifndef _nvRefCount_h
#define _nvRefCount_h

#ifndef __cplusplus
#error This file requires a C++ compiler
#endif

/*****************************************************************************
 * class CReferenceCount
 *
 * interface to shared reference count logic. also abstracts functionality to
 * work with pre-refcount HW.
 * NOTE: all functions work only in the context of a proper pDriverData
 */
class CReferenceCount
{
public:
    CReferenceCount::CReferenceCount() {
      m_dwRefCount            = 0xffffffff;
      m_dwHWRefCount          = 0xffffffff;
      m_dwNV4SurfaceMemory    = 0xffffffff;
      m_dwNV4SurfaceOffset    = 0xffffffff;
      m_dwLastPut             = 0xffffffff;
      m_dwLastWrap            = 0xffffffff;
      m_dwTimeOutValue        = 0xffffffff;
      m_dwTimeOutReload       = 0xffffffff;
    };
        // flags
public:
    const enum {
        // flags used to specify waiting protocol
        WAIT_COOPERATIVE = 0x01,
        WAIT_PREEMPTIVE  = 0x02,

        INC_LAZY         = 0x03,
        INC_IMMEDIATE    = 0x04
    };

    // members
private:
    DWORD       m_dwRefCount;             // the last reference count written to the HW
    DWORD       m_dwHWRefCount;           // the last reference count read from the HW
                                          // (conservative estimate, might be slightly out of date)
    DWORD       m_dwNV4SurfaceMemory;     // nv4 notifier emulation address
    DWORD       m_dwNV4SurfaceOffset;     // nv4 notifier emulation offset
    DWORD       m_dwLastPut;              // last put we wrote a notifier
    DWORD       m_dwLastWrap;             // last wrap count we wrote a notifier
    DWORD       m_dwTimeOutValue;         // # of writes to go before writing
    DWORD       m_dwTimeOutReload;        // # to reset timeout to

#if ((NVARCH >= 0x020) && defined(KELVIN_SEMAPHORES2))
    CSemaphore *m_pSem;
#endif

    // methods
private:
    void nv4WriteCount (void);

    // write a reference count instruction
    inline void writeRefCount (void)
    {
        // write count
#if ((NVARCH >= 0x020) && defined(KELVIN_SEMAPHORES2))
        if ((pDriverData->nvD3DPerfData.dwNVClasses  & NVCLASS_FAMILY_KELVIN)   &&
            (pDriverData->nvD3DPerfData.dwNVClasses  & NVCLASS_007C_DAC)        &&
            (pDriverData->nvD3DPerfData.dwNVClasses1 & NVCLASS1_206E_CHANNELDMA))
        {
            m_pSem->release (m_dwRefCount, &(getDC()->nvPusher), NV_DD_KELVIN, CSemaphore::SEMAPHORE_RELEASE_KELVIN_BACKEND);
        }
        else
#endif
#if (NVARCH >= 0x020)
        if (pDriverData->nvD3DPerfData.dwNVClasses & NVCLASS_FAMILY_KELVIN) {
            // kelvin acts like celsius for now
            getDC()->nvPusher.push   (0, dDrawSubchannelOffset(NV_DD_KELVIN) + NV06E_SET_REFERENCE | 0x40000);
            getDC()->nvPusher.push   (1, m_dwRefCount);
            getDC()->nvPusher.adjust (2);
        }
        else
#endif
        if (pDriverData->nvD3DPerfData.dwNVClasses & NVCLASS_FAMILY_CELSIUS) {
            getDC()->nvPusher.push   (0, dDrawSubchannelOffset(NV_DD_CELSIUS) + NV06E_SET_REFERENCE | 0x40000);
            getDC()->nvPusher.push   (1, m_dwRefCount);
            getDC()->nvPusher.adjust (2);
        }
        else {
            nv4WriteCount();
        }
        // cache current pusher values
        m_dwLastPut  = getDC()->nvPusher.getPut();
        m_dwLastWrap = getDC()->nvPusher.getWrapCount();
    }

public:
    // conditionally increment the ref count, write it, and return it
    // INC_LAZY:      we will only write the refcount if we actually pushed
    //                something since we called this or forceInc last.
    //                also - we do not write every time, but batch some up
    // INC_IMMEDIATE: force ref count to be incremented and written
    inline DWORD inc (DWORD dwIncMode)
    {
        switch (dwIncMode) {

            case INC_LAZY:

                if ((getDC()->nvPusher.getPut()       == m_dwLastPut) &&
                    (getDC()->nvPusher.getWrapCount() == m_dwLastWrap)) {
                    return m_dwRefCount;
                }

                if (m_dwTimeOutValue) {
                    m_dwTimeOutValue--;
                    // return fake retirement date. this date won't actually get
                    // written out (or occur) until a sync is forced via wait()
                    return (m_dwRefCount+1);
                }

                // reload
                m_dwTimeOutValue = m_dwTimeOutReload;

                // fall through: write next number

            case INC_IMMEDIATE:

                // increment but never allow it to be zero. zero has special meaning
                m_dwRefCount++;
                if (m_dwRefCount > 0xFFFFFFF0) {
                    // refcount is about to roll over, flush now
                    getDC()->nvPusher.start (TRUE);
                    while (read() != (m_dwRefCount-1)) {
                        nvDelay();
                    }
                    m_dwRefCount = 1;
                    DPF ("refcount wrapped. this may be buggy!");
                    nvAssert (0);
                }

                // write and return new count
                writeRefCount();
                return (m_dwRefCount);

                break;

            default:
                break;

        }  // switch

        DPF ("CReferenceCount::inc() failure");
        dbgD3DError();
        return (0);
    }

    // gets the current HW ref count
    inline DWORD read (void)
    {
#if ((NVARCH >= 0x020) && defined(KELVIN_SEMAPHORES2))
        if ((pDriverData->nvD3DPerfData.dwNVClasses  & NVCLASS_FAMILY_KELVIN)   &&
            (pDriverData->nvD3DPerfData.dwNVClasses  & NVCLASS_007C_DAC)        &&
            (pDriverData->nvD3DPerfData.dwNVClasses1 & NVCLASS1_206E_CHANNELDMA))
        {
            m_dwHWRefCount = m_pSem->read();
        }
        else
#endif
        if ((pDriverData->nvD3DPerfData.dwNVClasses & NVCLASS_FAMILY_KELVIN) ||
            (pDriverData->nvD3DPerfData.dwNVClasses & NVCLASS_FAMILY_CELSIUS))
        {
            if (getDC()->nvPusher.isValid()) {
                m_dwHWRefCount = getDC()->nvPusher.getRefCount();
            }
            else {
                // force retirement
                m_dwHWRefCount = m_dwRefCount;
            }
        }
        else
        {
            if (m_dwNV4SurfaceOffset) {
                m_dwHWRefCount = *(DWORD*)(VIDMEM_ADDR((m_dwNV4SurfaceOffset + pDriverData->BaseAddress)));
            }
            else {
                // force retirement
                m_dwHWRefCount = m_dwRefCount;
            }
        }
        return m_dwHWRefCount;
    }

    // gets the shadowed HW ref count
    inline DWORD readShadow (void) const
    {
        return (m_dwHWRefCount);
    }

    // wait until hardware has reached the specified reference count or until we've timed out.
    // returns true if it successfully waits for the HW to catch up, FALSE if it times out
    inline BOOL wait (DWORD dwWaitMode, DWORD dwRetireDate, DWORD dwMaxDelay)
    {
#ifdef CAPTURE
        if (getDC()->nvD3DRegistryData.regCaptureEnable & D3D_REG_CAPTUREENABLE_RECORD) {
            CAPTURE_SYNC3 sync;
            sync.dwJmpCommand         = CAPTURE_JMP_COMMAND;
            sync.dwExtensionSignature = CAPTURE_EXT_SIGNATURE;
            sync.dwExtensionID        = CAPTURE_XID_SYNC3;
            sync.dwValue              = dwRetireDate;
#if ((NVARCH >= 0x020) && defined(KELVIN_SEMAPHORES2))
            if ((pDriverData->nvD3DPerfData.dwNVClasses  & NVCLASS_FAMILY_KELVIN)   &&
                (pDriverData->nvD3DPerfData.dwNVClasses  & NVCLASS_007C_DAC)        &&
                (pDriverData->nvD3DPerfData.dwNVClasses1 & NVCLASS1_206E_CHANNELDMA))
            {
                sync.dwType           = CAPTURE_SYNC3_TYPE_SEMAPHORE;
                sync.dwCtxDMAHandle   = CSemaphoreManager::SEMAPHORE_CONTEXT_DMA_IN_MEMORY;
                sync.dwOffset         = m_pSem->m_dwOffset;
            }
            else
#endif
            if ((pDriverData->nvD3DPerfData.dwNVClasses & NVCLASS_FAMILY_KELVIN) ||
                (pDriverData->nvD3DPerfData.dwNVClasses & NVCLASS_FAMILY_CELSIUS))
            {
                sync.dwType           = CAPTURE_SYNC3_TYPE_REFCOUNT;
                sync.dwCtxDMAHandle   = 0;
                sync.dwOffset         = 0;
            }
            captureLog (&sync,sizeof(sync));
        }
#endif  // CAPTURE

        if (m_dwHWRefCount >= dwRetireDate) {
            return (TRUE);
        }

        // make sure we actually call forceInc() before starting a sync loop
        if (dwRetireDate > m_dwRefCount) {
            // There are 2 situations where we expect this to happen:
            // 1) dwRetireDate contains a fake value that hasn't been sent
            //    to the HW yet. We know it is m_dwRefCount+1
            // 2) nvReset occured before surface has retired. That means m_dwRefCount=0.
            // In any of these cases the next line solves the problem.
            m_dwRefCount = dwRetireDate;
            writeRefCount();
        }

        getDC()->nvPusher.start (TRUE);

        if (!dwMaxDelay) {
            // don't delay at all. just re-read the value from the HW check it
            return ((read() >= dwRetireDate) ? TRUE : FALSE);
        }

        while (dwMaxDelay) {
            switch (dwWaitMode) {
                case WAIT_COOPERATIVE:
                    NV_SLEEP;
                    break;
                case WAIT_PREEMPTIVE:
                    nvDelay();
                    break;
                default:
                    DPF ("unknown wait flags");
                    dbgD3DError();
            }
            if (read() >= dwRetireDate) {
                return (TRUE);
            }
            dwMaxDelay--;
        }

        return (FALSE);
    }

    // wait as long as required for hardware to reach the specified reference count
    inline BOOL wait (DWORD dwWaitMode, DWORD dwRetireDate)
    {
        BOOL bDone = FALSE;
        while (!bDone) {
            bDone = wait (dwWaitMode, dwRetireDate, 1000);
        }
        return (TRUE);
    }

    // wait as long as required for hardware to reach the current reference count
    inline BOOL wait (DWORD dwWaitMode)
    {
        return (wait (dwWaitMode, m_dwRefCount));
    }

public:
    BOOL create  (DWORD dwTimeOut);
    void destroy (void);
};

/*****************************************************************************
 * class CReferenceCountMap
 *
 * object that maps refcount values on to custom values.
 */
template <int cdwLogMax> class CReferenceCountMap
{
    /*
     * members
     */
protected:
// bank
    BOOL        m_bConservative;
    DWORD       m_dwHead;
    DWORD       m_dwTail;
    DWORD       m_dwLast;
    DWORD       m_dwLast2;
    DWORD       m_dwLastPut;
#if ((NVARCH >= 0x020) && defined(KELVIN_SEMAPHORES2))
    CSemaphore *m_pSem;
    DWORD       _pad[1];
#else
    DWORD       _pad[2];
#endif

// bank
    DWORD       m_adwRefCount[1 << cdwLogMax];
// bank
    DWORD       m_adwNumber[1 << cdwLogMax];

    /*
     * methods
     */
public:
           void  put       (DWORD dwNumber);
           DWORD get       (void);
    inline DWORD getCached (void)               const { return m_dwLast; }
           BOOL  isBusy    (void);

    /*
     * construction
     */
public:
           void  create    (DWORD dwInitialNumber, BOOL bConservative);
           void  destroy   (void);
};

#endif _nvRefCount_h
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\ddraw\common\inc\nvprecomp.h ===
// **************************************************************************
//
//       Copyright 1993-1999 NVIDIA, Corporation.  All rights reserved.
//
//     NOTICE TO USER:   The source code  is copyrighted under  U.S. and
//     international laws.  Users and possessors of this source code are
//     hereby granted a nonexclusive,  royalty-free copyright license to
//     use this code in individual and commercial software.
//
//     Any use of this source code must include,  in the user documenta-
//     tion and  internal comments to the code,  notices to the end user
//     as follows:
//
//       Copyright 1993-1999 NVIDIA, Corporation.  All rights reserved.
//
//     NVIDIA, CORPORATION MAKES NO REPRESENTATION ABOUT THE SUITABILITY
//     OF  THIS SOURCE  CODE  FOR ANY PURPOSE.  IT IS  PROVIDED  "AS IS"
//     WITHOUT EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORPOR-
//     ATION DISCLAIMS ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,
//     INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY, NONINFRINGE-
//     MENT,  AND FITNESS  FOR A PARTICULAR PURPOSE.   IN NO EVENT SHALL
//     NVIDIA, CORPORATION  BE LIABLE FOR ANY SPECIAL,  INDIRECT,  INCI-
//     DENTAL, OR CONSEQUENTIAL DAMAGES,  OR ANY DAMAGES  WHATSOEVER RE-
//     SULTING FROM LOSS OF USE,  DATA OR PROFITS,  WHETHER IN AN ACTION
//     OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,  ARISING OUT OF
//     OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOURCE CODE.
//
//     U.S. Government  End  Users.   This source code  is a "commercial
//     item,"  as that  term is  defined at  48 C.F.R. 2.101 (OCT 1995),p
//     consisting  of "commercial  computer  software"  and  "commercial
//     computer  software  documentation,"  as such  terms  are  used in
//     48 C.F.R. 12.212 (SEPT 1995)  and is provided to the U.S. Govern-
//     ment only as  a commercial end item.   Consistent with  48 C.F.R.
//     12.212 and  48 C.F.R. 227.7202-1 through  227.7202-4 (JUNE 1995),
//     all U.S. Government End Users  acquire the source code  with only
//     those rights set forth herein.
//
// **************************************************************************
//
//  Module: nvprecomp.h
//     headers used frequently by D3D drivers for all architectures.
//     all are included via this file to enable pre-compiling.
//
// **************************************************************************
//
//  History:
//       Craig Duttweiler    (bertrem)   01Mar99     created
//
// **************************************************************************

#ifndef _NVPRECOMP_H
#define _NVPRECOMP_H

#include <math.h>

#include "CompileControl.h"

// include compile-time switches
#include "nvSwitches.h"

// System Stuff
//#include <windows.h>
#include <stdlib.h>
//#include <conio.h>
#ifndef WINNT
    //#include <windows.h>
    //#include <assert.h>
    //#include <wingdi.h>

    #include "ddrawi.h"
    #include "d3dhal.h"
    #include "d3d.h"
    #include "dx95type.h"
    #include "dmemmgr.h"
#else // WINNT
    #define  __NTDDKCOMP__
    //#include <d3dtypes.h>
    //#include <d3d8.h>
    //#include <ddrawint.h>
    #include <devioctl.h>
    //#include <ntddvdeo.h>
#endif

#define D3D_OK S_OK

//#include "ddkmmini.h"
// Shared NV files
#include "nvreg.h"
//#include "nvtypes.h"
//#include "nv32.h"

#ifndef WINNT
    #include "nvwin32.h"
#endif // !WINNT

#include "ddrvmem.h"
#include "nvProcMan.h"
#include "ddmini.h"
#include "nvrmapi.h"
#include "nvrmarch.inc"
#include "nvddobj.h"
#include "nvcm.h"
#include "nvos.h"
#include "nvPriv.h"

#ifdef WINNT
    #include "memstruc.h"
    #include "nvEscDef.h"
    #include "nvntioctl.h"
#endif // WINNT

#include "surfaces.h"
#include "nvstat.h"
#include "escape.h"
#include "nvPM.h"
#include "nvCapture.h"

// Local NV common files
// *** order sensitive ***
#include "d3dConst.h"
#include "nvDMac.h"
#include "nvD3DMac.h"
#include "nvPusher.h"
#include "nvSemaphore.h"
#include "nvFlipper.h"
#include "nvDefVB.h"

#ifdef KPFS
    #include "nvKelvinProgram.h"
#endif

#include "nvContext.h"
#include "nvTranslate.h"
#include "nvSurface.h"
#include "nvLight.h"
#include "nvBlockManager.h"
#include "nvPalette.h"
#include "nvBlit.h"
#include "nvTex.h"
#include "nvTexManage.h"
#include "nvVB.h"
#include "nv4Tables.h"
#include "nvSwiz.h"
#include "nvheap.h"
#include "d3dDebug.h"
#include "nvvxmac.h"
#include "nvtexfmt.h"
#include "nvmocomp.h"
#include "nvEnable.h"
#include "ddFlip.h"
#include "nvClear.h"
#include "ddVideo.h"
#include "DDHal.h"
#include "nvVideoPort.h"
#include "ddSurface.h"
#include "nvLogo.h"
#include "d3dMath.h"
#include "nvBenchmark.h"
#include "nvAccess.h"   //FILE abstraction



#if (NVARCH >= 0x020)
    #include "nvSuperTri.h"
    #ifndef KPFS
    #include "nvKelvinProgram.h"
    #endif
    #include "nvKelvinTables.h"
    #include "nvKelvinState.h"
    #include "nvKelvinStateHelp.h"
    #include "nvKelvinAA.h"
#endif

#if (NVARCH >= 0x010)
    #include "nvCelsiusTables.h"
    #include "nvCelsiusState.h"
    #include "nvCelsiusStateHelp.h"
    #include "nvCelsiusNvTSS.h"
    #include "nvCelsiusAA.h"
#endif // NVARCH >= 0x010

#include "d3dinc.h"
#include "nvVShad.h"
#include "nvPShad.h"
#include "nvdinc.h"
#include "nvproto.h"
#include "global.h"
#include "nvObjectLists.h"
//#include "ddCapture.h"
#include "nvComp.h"
#include "nvDP2Help.h"
#include "nvdp2ops.h"
#include "nvFormats.h"
#include "nvSurf.h"
//#include "nvPal.h"
#include "nvObject.h"
#include "nvRefCount.h"
//#include "nvTimer.h"
#include "nvStereo.h"
//#include "PopupAgent.h"

// DO NOT include x86 in the precompiled headers.  It redefines things that affect some variable
// names and thereby causes hard-to-understand compile problems.
//#include "x86.h"

// preventive logic
#undef GlobalLock
#define GlobalLock      __this_is_an_unsupported_legacy_operation__do_not_use__
#undef GlobalUnlock
#define GlobalUnlock    __this_is_an_unsupported_legacy_operation__do_not_use__

#endif // _NVPRECOMP_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\ddraw\common\inc\nvproto.h ===
/*
 * Copyright 1993-1999 NVIDIA, Corporation.  All rights reserved.
 * THE INFORMATION CONTAINED HEREIN IS PROPRIETARY AND CONFIDENTIAL TO
 * NVIDIA, CORPORATION.  USE, REPRODUCTION OR DISCLOSURE TO ANY THIRD PARTY
 * IS SUBJECT TO WRITTEN PRE-APPROVAL BY NVIDIA, CORPORATION.
 */
/********************************* Direct 3D *******************************\
*                                                                           *
* Module: NV_PROTO.H                                                        *
*       Function Prototypes                                                 *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*       Craig Duttweiler         11Feb99           created                  *
*                                                                           *
\***************************************************************************/

#ifndef _NVPROTO_H
#define _NVPROTO_H

#ifdef __cplusplus
extern "C" {
#endif

// d3dctxt.cpp
BOOL            nvCreateContextListHeap (GLOBALDATA *pDriverData);
BOOL            nvDestroyContextListHeap (void);
DWORD __stdcall nvContextCreate (LPD3DHAL_CONTEXTCREATEDATA);
DWORD __stdcall nvContextDestroy (LPD3DHAL_CONTEXTDESTROYDATA);
DWORD __stdcall nvContextDestroyAll (LPD3DHAL_CONTEXTDESTROYALLDATA);
void            nvD3DRecover(void);
void            nvDDrawRecover(void);
DWORD __stdcall nvDestroyDDLocal (LPDDHAL_DESTROYDDLOCALDATA);
PNVD3DCONTEXT   nvGetPreapprovedContext(void);
void            nvDestroyPreapprovedContexts(void);

// d3drendr.cpp
#ifndef WINNT  // these calls are obsolete on NT (DX7)
DWORD   __stdcall nvRenderState              (LPD3DHAL_RENDERSTATEDATA);
DWORD   __stdcall nvRenderPrimitive          (LPD3DHAL_RENDERPRIMITIVEDATA);
#endif // !WINNT
DWORD   __stdcall nvSetRenderTarget          (LPD3DHAL_SETRENDERTARGETDATA);
BOOL              nvD3DClearZBuffer          (LPDDRAWI_DDRAWSURFACE_LCL, DWORD, DWORD,DWORD,DWORD,DWORD);
BOOL              nvCheckBufferCompatibility (CSimpleSurface *pRenderTarget, CSimpleSurface *pZetaBuffer,
                                              LPDDRAWI_DDRAWSURFACE_LCL pDDSLclZ, DWORD dwDXAppVersion);
DWORD             nvSetRenderTargetDX7       (PNVD3DCONTEXT pContext, DWORD dwTargetHandle, DWORD dwZBufferHandle);

// D3Dmini.cpp
extern BOOL __stdcall D3DHALCreateDriver     (LPD3DHAL_GLOBALDRIVERDATA lpGlobal,
                                              LPD3DHAL_CALLBACKS* lplpHALCallbacks,
                                              LPDDHAL_DDEXEBUFCALLBACKS* lplpBufCallbacks,
                                              GLOBALDATA* pDriverData);
// d3dstate.cpp
DWORD __stdcall nvGetDriverState(LPDDHAL_GETDRIVERSTATEDATA);
#ifndef WINNT  // these calls are obsolete on NT (DX7)
DWORD __stdcall nvGetState(LPD3DHAL_GETSTATEDATA);
#endif

DWORD __stdcall nvTextureCreate  (LPD3DHAL_TEXTURECREATEDATA);
DWORD __stdcall nvTextureDestroy (LPD3DHAL_TEXTUREDESTROYDATA);
DWORD __stdcall nvTextureSwap    (LPD3DHAL_TEXTURESWAPDATA);
DWORD __stdcall nvTextureGetSurf (LPD3DHAL_TEXTUREGETSURFDATA);

// d3dtex.cpp / nvtext.cpp
BOOL  nvPCICreateHeap  (void);
BOOL  nvPCIDestroyHeap (void);
DWORD nvPCIAlloc       (DWORD);
BOOL  nvPCIFree        (DWORD);

// nvAGP.cpp
BOOL  nvAGPCreateHeap   (void);
BOOL  nvAGPDestroyHeap  (void);
void  nvAGPResetHeap    (void);
void  nvAGPInvalidate   (void);
void* nvAGPAlloc        (DWORD dwSize);
DWORD nvAGPGetUserAddr  (DWORD dwAddr);
void  nvAGPFree         (void *pMemory);
void  nvAGPCombine      (void);
void  nvAGPReclaim      (void);
void  nvAGPGetMemory    (DWORD *pdwTotal, DWORD *pdwFree);

// dddrv32.cpp
DWORD __stdcall       GetDriverInfo32           (LPDDHAL_GETDRIVERINFODATA lpData);
DWORD __stdcall       Blit32                    (LPDDHAL_BLTDATA pbd );
DWORD                 WaitForIdle               (BOOL bWait, BOOL bUseEvent);
BOOL                  ResetTwinViewState        (GLOBALDATA *pDriverData);

#ifndef WINNT
void  __stdcall       AddModeToTable            (DDHALMODEINFO *pMode, int nXRes, int nYRes, int nBitsPerPixel);
int   __stdcall       SortDDHalModeList         (void);
DWORD __stdcall       DrawOneIndexedPrimitive32 (LPD3DHAL_DRAWONEINDEXEDPRIMITIVEDATA);
DWORD __stdcall       DrawOnePrimitive32        (LPD3DHAL_DRAWONEPRIMITIVEDATA);
DWORD __stdcall       DrawPrimitives32          (LPD3DHAL_DRAWPRIMITIVESDATA);
int                   DrvCallbackFunc           (DWORD dwFunction, void *pIn, void *pOut);
BOOL                  MyExtEscape               (DWORD dwHead, int nEscapeID, int nInBytes, LPCSTR lpIn, int nOutBytes, LPSTR lpOut);
int                   getAdapterIndex           (DISPDRVDIRECTXCOMMON *pNewDXShare, DWORD *pdwRootIndex);
DISPDRVDIRECTXCOMMON* getDXShare                (DWORD dwRootHandle, DWORD dwHeadNumber);
BOOL                  nvFillAdapterTable        (void);
HDC                   nvCreateDCHandle          (DISPDRVDIRECTXCOMMON *pDXS);
void                  nvDestroyDCHandle         (HDC hDC);
DWORD __stdcall		  GetModePitch				(int nXRes, int nYRes, int nBitsPerPixel);
#endif  // !WINNT

// nvCaps.cpp
void  nvSetHardwareCaps (void);

// nvctxt.cpp
BOOL  nvSetSurfaceViewport (PNVD3DCONTEXT);
void  nvRefreshSurfaceInfo (PNVD3DCONTEXT);
BOOL  nvSetupContext       (PNVD3DCONTEXT);
void  nvInitTLData         (PNVD3DCONTEXT pContext);
#if (NVARCH >= 0x010)
void  nvInitCelsiusData    (PNVD3DCONTEXT pContext);
#endif  // NVARCH >= 0x010
#if (NVARCH >= 0x020)
void  nvInitKelvinData     (PNVD3DCONTEXT pContext);
#endif  // NVARCH >= 0x020

// nvline.cpp
DWORD nvRenderLine                  (NV_INNERLOOP_ARGLIST);
void  nvDrawLine                    (NV_INNERLOOP_ARGLIST);
void  nvIndexedLine                 (NV_INNERLOOP_ARGLIST);
void  nvIndexedWireframeTriangle    (NV_INNERLOOP_ARGLIST);
void  nvDrawWireframeTriangle       (NV_INNERLOOP_ARGLIST);
void  nvFVFDrawLine                 (NV_INNERLOOP_ARGLIST);
void  nvFVFIndexedLine              (NV_INNERLOOP_ARGLIST);
void  nvFVFIndexedWireframeTriangle (NV_INNERLOOP_ARGLIST);
void  nvFVFDrawWireframeTriangle    (NV_INNERLOOP_ARGLIST);

// nvmini.cpp
void  D3DReadRegistry       (GLOBALDATA *pDriverData);
void  D3DModifyCapabilities (D3DHAL_GLOBALDRIVERDATA *pNvGlobal, GLOBALDATA *pDriverData);
BOOL  CreateItemArrays      (GLOBALDATA *pDriverData);
HKEY  OpenLocalD3DRegKey    (void);

BOOL nvReadRegistryDWORD (
#ifdef WINNT
    PDEV   *pDev,
#else
    HKEY    hKey,
#endif
    LPCTSTR lpValueName,
    LPDWORD lpData
);

// nvpoint.cpp
DWORD nvRenderPoint             (NV_INNERLOOP_ARGLIST);
void  nvDrawPointList           (NV_INNERLOOP_ARGLIST);
void  nvIndexedPointTriangle    (NV_INNERLOOP_ARGLIST);
void  nvDrawPointTriangle       (NV_INNERLOOP_ARGLIST);
void  nvFVFDrawPointList        (NV_INNERLOOP_ARGLIST);
void  nvFVFIndexedPointTriangle (NV_INNERLOOP_ARGLIST);
void  nvFVFDrawPointTriangle    (NV_INNERLOOP_ARGLIST);

// nvprim.cpp
#ifndef WINNT
DWORD nvDrawOnePrimitive        (LPD3DHAL_DRAWONEPRIMITIVEDATA);
DWORD nvDrawPrimitives          (LPD3DHAL_DRAWPRIMITIVESDATA);
DWORD nvDrawOneIndexedPrimitive (LPD3DHAL_DRAWONEINDEXEDPRIMITIVEDATA);
#endif  // !WINNT

// nvPatch.cpp
DWORD nvDrawRectSurface (PNVD3DCONTEXT pContext, DWORD dwHandle,
                         float *pfSegs, D3DRECTPATCH_INFO *pRSInfo);
DWORD nvDrawTriSurface  (PNVD3DCONTEXT pContext, DWORD dwHandle,
                         float *pfSegs, D3DTRIPATCH_INFO *pRSInfo);

// nvprim2.cpp
DWORD __stdcall nvDrawPrimitives2 (LPD3DHAL_DRAWPRIMITIVES2DATA);

// nvprof.cpp
#ifdef __cplusplus
extern "C" {
#endif
#ifdef WINNT
BOOL  __stdcall nvDeterminePerformanceStrategy (GLOBALDATA *pDriverData, PDEV* ppdev);
#else // !WINNT
BOOL  __stdcall nvDeterminePerformanceStrategy (GLOBALDATA *pDriverData);
#endif // !WINNT
void nvDetermineEarlyCopyStrategy(PNVD3DCONTEXT pContext);
#ifdef __cplusplus
}
#endif // __cplusplus

#ifdef NV_PROFILE
void nvpCreate   (void);
void nvpDestroy  (void);
void nvpFlush    (void);
void nvpLogEvent (DWORD id);
void nvpLogCount (DWORD id,int count);
void nvpLogTime  (DWORD id,__int64 time);
void nvpSetLogPusher(bool log);
bool nvpGetLogPusher();
#endif  // NV_PROFILE

// nvscene.cpp
DWORD __stdcall nvSceneCapture (LPD3DHAL_SCENECAPTUREDATA);

// nvstate.cpp
DWORD            CTFunc                         (PNVD3DCONTEXT pContext, DWORD dw);
BOOL             nvStencilBufferExists          (PNVD3DCONTEXT pContext);
DWORD            nvTranslateLODBias             (DWORD);
void             nvSetD3DSurfaceState           (PNVD3DCONTEXT);
void             nvSetD3DSurfaceViewport        (PNVD3DCONTEXT);
void             nvSetDx5TriangleState          (PNVD3DCONTEXT);
DWORD            nvSetContextState              (PNVD3DCONTEXT pContext, DWORD, DWORD, HRESULT *);
BOOL             nvSetHardwareState             (PNVD3DCONTEXT pContext);
void             nvSetDx6MultiTextureState      (PNVD3DCONTEXT);
DWORD FAR PASCAL nvValidateTextureStageState    (LPD3DHAL_VALIDATETEXTURESTAGESTATEDATA);
void             nvSetMultiTextureHardwareState (PNVD3DCONTEXT pContext);
void             cacheFogValues                 (PNVD3DCONTEXT pContext);

// nvstateset.cpp
#ifdef DEBUG
void    recordDebugMarker   (PNVD3DCONTEXT pContext);
#else
#define recordDebugMarker(a)
#endif
HRESULT recordState         (PNVD3DCONTEXT pContext, LPBYTE, DWORD);
HRESULT recordLastStateOnly (PNVD3DCONTEXT pContext, LPD3DHAL_DP2COMMAND, DWORD);
HRESULT stateSetBegin       (PNVD3DCONTEXT, DWORD);
HRESULT stateSetEnd         (PNVD3DCONTEXT);
HRESULT stateSetExecute     (PNVD3DCONTEXT, DWORD);
HRESULT stateSetCapture     (PNVD3DCONTEXT, DWORD);
HRESULT stateSetCreate      (PNVD3DCONTEXT, DWORD, D3DSTATEBLOCKTYPE);
HRESULT stateSetDelete      (PNVD3DCONTEXT, DWORD);

// nvtri.cpp
DWORD   nvRenderNoOp     (NV_INNERLOOP_ARGLIST);
DWORD   nvRenderTriangle (NV_INNERLOOP_ARGLIST);

// nvlight.cpp
HRESULT nvLightSetLight  (nvLight *, LPD3DLIGHT7);
void    nvLightEnable    (nvLight *, nvLight **);
void    nvLightDisable   (nvLight *, nvLight **);
HRESULT nvGrowLightArray (PNVD3DCONTEXT, DWORD);
BOOL    nvLightIsEnabled (nvLight *);
BOOL    nvLightIsDefined (nvLight *);

// nvRZ.cpp
BOOL            rzDetectCachingCapabilities (void);
BOOL  __stdcall rzSetAGPMTRR                (DWORD dwPhysBase,DWORD dwType);
DWORD           rzMapPhysicalToLinear       (DWORD dwPhysBase,DWORD dwLength);
BOOL            rzSetPATIndices             (DWORD dwStart,DWORD dwCount,DWORD dwValue);

#if (NVARCH >= 0x010)

// nvCelsiusAlphaCombiner.cpp
void    SetAlphaInputOne (PNVD3DCONTEXT pContext, celsiusCombinerInput eInput,
                          DWORD dwCombinerStage, BOOL bNegate);
HRESULT SelectAlphaInput (PNVD3DCONTEXT pContext, celsiusCombinerInput eInput,
                          DWORD dwCombinerStage, DWORD dwD3DStage, DWORD dwD3DTSSArg,
                          BOOL bComplement, BOOL bExpandNormal);
void    ConstructAlphaCombiners (PNVD3DCONTEXT pContext, int, int, BOOL);
void    ConstructOutputAlphaCombiners (PNVD3DCONTEXT pContext, int, int, int, int, int);

// nvCelsiusColorCombiner.cpp
void    SetColorMapping  (PNVD3DCONTEXT pContext, celsiusCombinerInput eInput,
                          DWORD dwCombinerStage, DWORD dwMapping);
void    SetColorInputOne (PNVD3DCONTEXT pContext, celsiusCombinerInput eInput,
                          DWORD dwCombinerStage, BOOL bNegate);
HRESULT SelectColorInput (PNVD3DCONTEXT pContext, celsiusCombinerInput eInput,
                          DWORD dwCombinerStage, DWORD dwD3DStage, DWORD dwD3DTSSArg,
                          BOOL bComplement, BOOL bExpandNormal, BOOL bAlphaReplicate);
BOOL    ConstructColorCombiners (PNVD3DCONTEXT pContext, int, int);
void    ConstructOutputColorCombiners (PNVD3DCONTEXT pContext, int, int, int, int, int, int, int);

// nvCelsiusPrim.cpp
void    nvCelsiusDispatchNonIndexedPrimitive      (NV_INNERLOOP_ARGLIST);
void    nvCelsiusDispatchIndexedPrimitive         (NV_INNERLOOP_ARGLIST);
void    nvCelsiusDispatchLegacyWireframePrimitive (NV_INNERLOOP_ARGLIST);

#endif  // NVARCH == 0x010

#if (NVARCH >= 0x020)
// nvKelvinAlphaCombiners.cpp
void    nvConstructKelvinAlphaCombiners (PNVD3DCONTEXT pContext, DWORD dwHWStage, DWORD dwDXStage, BOOL bStageActive);
void    nvConstructKelvinOutputAlphaCombiners (PNVD3DCONTEXT pContext, BOOL bEnable,
                                               DWORD dwHWStage, DWORD dwDXStage,
                                               BOOL bBias, DWORD dwShift, BOOL bOutTemp);

// nvKelvinColorCombiners.cpp
BOOL    nvConstructKelvinColorCombiners (PNVD3DCONTEXT pContext, DWORD dwHWStage, DWORD dwDXStage);
void    nvConstructKelvinOutputColorCombiners (PNVD3DCONTEXT pContext, BOOL bEnable, DWORD dwStage,
                                               BOOL bBias, DWORD dwShift, BOOL bDotAB, BOOL bDotCD, BOOL bOutTemp);

// nvKelvinPrim.cpp
void    nvKelvinDispatchNonIndexedPrimitive      (NV_INNERLOOP_ARGLIST);
void    nvKelvinDispatchIndexedPrimitive         (NV_INNERLOOP_ARGLIST);
void    nvKelvinDispatchLegacyWireframePrimitive (NV_INNERLOOP_ARGLIST);

#endif

// nvpkrnl.c (nvpe.lib)
#ifdef NVPE
void  __stdcall NVPInitialState(GLOBALDATA *pDriverData);
BOOL  __stdcall NVPIsVPEEnabled(GLOBALDATA *pDriverData, DWORD hDriver);
DWORD __stdcall NVPCleanUp(GLOBALDATA *pDriverData, LPDDRAWI_DIRECTDRAW_GBL pDDGbl);
DWORD __stdcall NVPUpdateOverlay(GLOBALDATA *pDriverData, LPDDRAWI_DIRECTDRAW_GBL pDDGbl);
#endif // NVPE

#ifdef __cplusplus
}
#endif // __cplusplus

#endif  // _NVPROTO_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\ddraw\common\inc\nvsupertri.h ===
// **************************************************************************
//
//       Copyright 1993-2000 NVIDIA, Corporation.  All rights reserved.
//
//     NOTICE TO USER:   The source code  is copyrighted under  U.S. and
//     international laws.  Users and possessors of this source code are
//     hereby granted a nonexclusive,  royalty-free copyright license to
//     use this code in individual and commercial software.
//
//     Any use of this source code must include,  in the user documenta-
//     tion and  internal comments to the code,  notices to the end user
//     as follows:
//
//       Copyright 1993-2000 NVIDIA, Corporation.  All rights reserved.
//
//     NVIDIA, CORPORATION MAKES NO REPRESENTATION ABOUT THE SUITABILITY
//     OF  THIS SOURCE  CODE  FOR ANY PURPOSE.  IT IS  PROVIDED  "AS IS"
//     WITHOUT EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORPOR-
//     ATION DISCLAIMS ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,
//     INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY, NONINFRINGE-
//     MENT,  AND FITNESS  FOR A PARTICULAR PURPOSE.   IN NO EVENT SHALL
//     NVIDIA, CORPORATION  BE LIABLE FOR ANY SPECIAL,  INDIRECT,  INCI-
//     DENTAL, OR CONSEQUENTIAL DAMAGES,  OR ANY DAMAGES  WHATSOEVER RE-
//     SULTING FROM LOSS OF USE,  DATA OR PROFITS,  WHETHER IN AN ACTION
//     OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,  ARISING OUT OF
//     OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOURCE CODE.
//
//     U.S. Government  End  Users.   This source code  is a "commercial
//     item,"  as that  term is  defined at  48 C.F.R. 2.101 (OCT 1995),
//     consisting  of "commercial  computer  software"  and  "commercial
//     computer  software  documentation,"  as such  terms  are  used in
//     48 C.F.R. 12.212 (SEPT 1995)  and is provided to the U.S. Govern-
//     ment only as  a commercial end item.   Consistent with  48 C.F.R.
//     12.212 and  48 C.F.R. 227.7202-1 through  227.7202-4 (JUNE 1995),
//     all U.S. Government End Users  acquire the source code  with only
//     those rights set forth herein.
//
// ********************************* Direct 3D ******************************
//
//  Module: nvSuperTri.h
//      SuperTri state header file
//
// **************************************************************************
//
//  History:
//      Scott Kephart           08Nov00             Kelvin Development
//
// **************************************************************************


#if (NVARCH >= 0x10)
// xPipe / Super-tri constants
#define NV_CULLFLAG_SUPERTRI            0x00000001
#define NV_CULLFLAG_MODELOK             0x00000002
#define NV_CULLFLAG_XFORMOK             0x00000004

// xPipe / Super-tri inner loop flags. These ought to be in the inner loop flags above, but we don't have enough
// flag bits.


#define NV_STILFLAG_STDEFVB             0x00000001  // default VB is used (affects supertri logic)
#define NV_STILFLAG_MODEL               0x00000002  // Model Culling
#define NV_STILFLAG_XFORM               0x00000004  // Xform / clipcheck / cull
#define NV_STILFLAG_HIBW                0x00000008  // High bandwidth mode -- check all triangles
#define NV_STILFLAG_NOCULL              0x00000010  // Disable cull-check

class CSuperTri;
class CVertexShader;

typedef bool (*PST_STRAT_FN)(CSuperTri *, DWORD dwDP2Operation, DWORD primcount, CVertexShader *pVertexShader);

class CSuperTri
{
//private:
public:
    // Number of flips to allow pending before using SUPER_TRI code.
    DWORD                       dwSuperTriPendingFlips;
    DWORD                       dwSuperTriThrottle;
    DWORD                       dwSuperTriMask;
    DWORD                       cullsign;
    D3DVECTOR4                  eye;                                 // supertri eye in model space
//bank
    DWORD                       dwCullFlags;                         // culling state flags
    DWORD                       dwSTILFlags;
    DWORD                       dwSTLBStride;
    PST_STRAT_FN                pStrategy;
    PNVD3DCONTEXT               pContext;
    DWORD                       dwNumLights;
    DWORD                       _pad0[2];
public:
    void SuperTriInit(PNVD3DCONTEXT pContext);
    __forceinline void setSuperTri() {dwCullFlags |= NV_CULLFLAG_SUPERTRI;}
    __forceinline void clrSuperTri() {dwCullFlags &= ~(NV_CULLFLAG_SUPERTRI|NV_CULLFLAG_MODELOK);}
    __forceinline bool isSuperTri() {return ((dwCullFlags & NV_CULLFLAG_SUPERTRI) != 0);}
    __forceinline void setModelCullOK() {dwCullFlags |= NV_CULLFLAG_MODELOK;}
    __forceinline void clrModelCullOK() {dwCullFlags &= ~(NV_CULLFLAG_MODELOK);}
    __forceinline bool isModelCullOK() {return (dwCullFlags & NV_CULLFLAG_MODELOK) != 0;}
    __forceinline void setXFormCullOK() {dwCullFlags |= NV_CULLFLAG_XFORMOK;}
    __forceinline void clrXFormCullOK() {dwCullFlags &= ~(NV_CULLFLAG_XFORMOK);}
    __forceinline bool isXFormCullOK() {return (dwCullFlags & NV_CULLFLAG_XFORMOK) != 0;}
    __forceinline void setFixedLBStride() {dwSTILFlags &= ~NV_STILFLAG_STDEFVB;};
    __forceinline bool isFixedLBStride() {return (dwSTILFlags & NV_STILFLAG_STDEFVB) == 0;}
    __forceinline void setVarLBStride() {dwSTILFlags |= NV_STILFLAG_STDEFVB;};
    __forceinline void setModelCull() {dwSTILFlags |= NV_STILFLAG_MODEL; dwSTILFlags &= ~NV_STILFLAG_XFORM;}
    __forceinline void clrCullILFlags() {dwSTILFlags &= ~(NV_STILFLAG_MODEL | NV_STILFLAG_XFORM | NV_STILFLAG_STDEFVB | NV_STILFLAG_HIBW | NV_STILFLAG_NOCULL);}
    __forceinline void setXformCull() {dwSTILFlags |= NV_STILFLAG_XFORM; dwSTILFlags &= ~NV_STILFLAG_MODEL;}
    __forceinline bool isModelCull() {return (dwSTILFlags & NV_STILFLAG_MODEL) != 0;}
    __forceinline bool isXFormCull() {return (dwSTILFlags & NV_STILFLAG_XFORM) != 0;}
    __forceinline void setCheckAll()  {dwSTILFlags |= NV_STILFLAG_HIBW;}
    __forceinline void clrCheckAll()  {dwSTILFlags &= ~NV_STILFLAG_HIBW;}
    __forceinline bool isCheckAll() {return (dwSTILFlags & NV_STILFLAG_HIBW) != 0;}
    __forceinline void setNoCull() {dwSTILFlags |= NV_STILFLAG_NOCULL;}
    __forceinline void clrNoCull() {dwSTILFlags &= ~NV_STILFLAG_NOCULL;}
    __forceinline bool isNoCull() {return (dwSTILFlags & NV_STILFLAG_NOCULL) != 0;}
    __forceinline void setNumLights(DWORD lights) {dwNumLights = lights;}
    __forceinline DWORD getNumLights() {return dwNumLights;}

    void setSTLBStride();

    __forceinline void setSTLBStride (DWORD stride) { dwSTLBStride = stride; }

    __forceinline DWORD getSTLBStride(){ return dwSTLBStride; }

    void setStrategy();
    __forceinline bool Strategy(DWORD dwDP2Operation, DWORD PrimCount, CVertexShader *pVertexShader) { return (*pStrategy)(this, dwDP2Operation, PrimCount, pVertexShader); }
    void setEye(D3DMATRIX *MV);
    __forceinline DWORD getEyeAddr() {return (DWORD) (&eye);}
    __forceinline void setCullsign(DWORD c) {cullsign = c;}
    __forceinline DWORD getCullsignAddr() {return (DWORD) (&cullsign);}

    friend bool ST_Strat_P3(CSuperTri *st, DWORD dwDP2Operation, DWORD PrimCount, CVertexShader *pVertexShader);
    friend bool ST_Strat_P4(CSuperTri *st, DWORD dwDP2Operation, DWORD PrimCount, CVertexShader *pVertexShader);
    friend bool ST_Strat_Null(CSuperTri *st, DWORD dwDP2Operation, DWORD PrimCount, CVertexShader *pVertexShader);
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\ddraw\common\inc\nvPShad.h ===
/***************************************************************************\
|*                                                                           *|
|*       Copyright 1993-1999 NVIDIA, Corporation.  All rights reserved.      *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.  Users and possessors of this source code are     *|
|*     hereby granted a nonexclusive,  royalty-free copyright license to     *|
|*     use this code in individual and commercial software.                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*       Copyright 1993-1999 NVIDIA, Corporation.  All rights reserved.      *|
|*                                                                           *|
|*     NVIDIA, CORPORATION MAKES NO REPRESENTATION ABOUT THE SUITABILITY     *|
|*     OF  THIS SOURCE  CODE  FOR ANY PURPOSE.  IT IS  PROVIDED  "AS IS"     *|
|*     WITHOUT EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORPOR-     *|
|*     ATION DISCLAIMS ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,     *|
|*     INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY, NONINFRINGE-     *|
|*     MENT,  AND FITNESS  FOR A PARTICULAR PURPOSE.   IN NO EVENT SHALL     *|
|*     NVIDIA, CORPORATION  BE LIABLE FOR ANY SPECIAL,  INDIRECT,  INCI-     *|
|*     DENTAL, OR CONSEQUENTIAL DAMAGES,  OR ANY DAMAGES  WHATSOEVER RE-     *|
|*     SULTING FROM LOSS OF USE,  DATA OR PROFITS,  WHETHER IN AN ACTION     *|
|*     OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,  ARISING OUT OF     *|
|*     OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOURCE CODE.     *|
|*                                                                           *|
|*     U.S. Government  End  Users.   This source code  is a "commercial     *|
|*     item,"  as that  term is  defined at  48 C.F.R. 2.101 (OCT 1995),     *|
|*     consisting  of "commercial  computer  software"  and  "commercial     *|
|*     computer  software  documentation,"  as such  terms  are  used in     *|
|*     48 C.F.R. 12.212 (SEPT 1995)  and is provided to the U.S. Govern-     *|
|*     ment only as  a commercial end item.   Consistent with  48 C.F.R.     *|
|*     12.212 and  48 C.F.R. 227.7202-1 through  227.7202-4 (JUNE 1995),     *|
|*     all U.S. Government End Users  acquire the source code  with only     *|
|*     those rights set forth herein.                                        *|
|*                                                                           *|
 \***************************************************************************/
#ifndef _nvPShad_h
#define _nvPShad_h

#ifdef __cplusplus
extern "C"
{
#endif

// Some redefines for my convenience
#define NV_MAPPING_UNSIGNED_IDENTITY  NV056_SET_COMBINER_COLOR_ICW_A_MAP_UNSIGNED_IDENTITY
#define NV_MAPPING_UNSIGNED_INVERT    NV056_SET_COMBINER_COLOR_ICW_A_MAP_UNSIGNED_INVERT
#define NV_MAPPING_EXPAND_NORMAL      NV056_SET_COMBINER_COLOR_ICW_A_MAP_EXPAND_NORMAL
#define NV_MAPPING_EXPAND_NEGATE      NV056_SET_COMBINER_COLOR_ICW_A_MAP_EXPAND_NEGATE
#define NV_MAPPING_HALF_BIAS_NORMAL   NV056_SET_COMBINER_COLOR_ICW_A_MAP_HALFBIAS_NORMAL
#define NV_MAPPING_HALF_BIAS_NEGATE   NV056_SET_COMBINER_COLOR_ICW_A_MAP_HALFBIAS_NEGATE
#define NV_MAPPING_SIGNED_IDENTITY    NV056_SET_COMBINER_COLOR_ICW_A_MAP_SIGNED_IDENTITY
#define NV_MAPPING_SIGNED_NEGATE      NV056_SET_COMBINER_COLOR_ICW_A_MAP_SIGNED_NEGATE


#define NV_REG_ZERO              0x0
#define NV_REG_CONSTANT0         0x1
#define NV_REG_CONSTANT1         0x2
#define NV_REG_FOG               0x3
#define NV_REG_COLOR0            0x4
#define NV_REG_COLOR1            0x5
#define NV_REG_TEXTURE4          0x6
#define NV_REG_TEXTURE5          0x7
#define NV_REG_TEXTURE0          0x8
#define NV_REG_TEXTURE1          0x9
#define NV_REG_TEXTURE2          0xA
#define NV_REG_TEXTURE3          0xB
#define NV_REG_SPARE0            0xC
#define NV_REG_SPARE1            0xD
#define NV_REG_TEXTURE6          0xE
#define NV_REG_TEXTURE7          0xF
#define NV_REG_SPECLIT           0xE
#define NV_REG_EF_PROD           0xF
#define NV_REG_MAX              0x10

#define D3DSP_WRITEMASK_RGBA (D3DSP_WRITEMASK_0 | D3DSP_WRITEMASK_1 | D3DSP_WRITEMASK_2 | D3DSP_WRITEMASK_3)
#define D3DSP_WRITEMASK_RGB (D3DSP_WRITEMASK_0 | D3DSP_WRITEMASK_1 | D3DSP_WRITEMASK_2)
#define D3DSP_WRITEMASK_A (D3DSP_WRITEMASK_3)
#define D3DSP_WRITEMASK_SHIFT 16

#define DRF_SHIFTMASK(x) (DRF_MASK(x) << DRF_SHIFT(x))



// Random constants
#define CELSIUS_COMBINER_STAGES   2
#define KELVIN_COMBINER_STAGES    8
#define PSHAD_MAX_COMBINER_STAGES       8

#if (NVARCH >= 0x020)
#define PSHAD_MAX_SHADER_STAGES         KELVIN_NUM_TEXTURES
#else
#define PSHAD_MAX_SHADER_STAGES         2
#endif

#define PSHAD_MAX_CONSTANTS       NV_CAPS_MAX_PSHADER_CONSTS

#define PSHAD_INSTRUCTION_ARGS DWORD stage, DWORD color, DWORD shift, DWORD sat, DWORD *dst, DWORD *src, DWORD *alpha, DWORD *map

#define PSHAD_MAX_SRC_ARGS_PER_INSTRUCTION 7
#define PSHAD_MAX_DST_ARGS_PER_INSTRUCTION 2

#define PSHAD_COLOR 0
#define PSHAD_ALPHA 1
#define PSHAD_ICW   0
#define PSHAD_OCW   1

#define PSHAD_DEF   0   // Definition instruction
#define PSHAD_INS   1   // Regular instruction
#define PSHAD_TEX   2   // Texture addressing instruction

// For m_dwPixelShaderConstFlags
#define PSHAD_CONST_SIGNED 0x0001
#define PSHAD_CONST_LOCAL  0x0002
#define PSHAD_CONST_STAGE_SHIFT 16
#define PSHAD_CONST_STAGE_MASK  0xf
#define PSHAD_CONST_NUM_SHIFT   20
#define PSHAD_CONST_NUM_MASK  0xf


#define PSHAD_UNUSED 0xdeadbeef


#define D3DSIO_NV_MMA   59
#define D3DSIO_NV_DD    60
#define D3DSIO_NV_MD    61
#define D3DSIO_NV_MM    62
#define D3DSIO_NV_SPF   63


class CPixelShader {
protected:
    // Structure declarations

    struct SConstMapping {
        DWORD dwRegNum;
        DWORD dwMap;
        BOOL  bSigned;
        SConstMapping() { dwRegNum = PSHAD_UNUSED; }
    };

    // Data declarations

    CNvObject                   *m_pWrapperObject;
    DWORD                       m_dwHandle;
    DWORD                       m_dwCodeSize;
    DWORD                       *m_dwCodeData;

    DWORD                       m_dwStage;

	DWORD                       m_cw[PSHAD_MAX_COMBINER_STAGES][2][2];

    DWORD                       m_textureStageSwap;             // Texture stage 0 and 1 have been swapped for Celsius compatibility

    DWORD                       m_shaderStageProgram[PSHAD_MAX_SHADER_STAGES];
    DWORD                       m_shaderStageInput[PSHAD_MAX_SHADER_STAGES];
    DWORD                       m_shaderStageInputInverse[PSHAD_MAX_SHADER_STAGES];
    DWORD                       m_shaderStageInputMapping[PSHAD_MAX_SHADER_STAGES];

    DWORD                       m_dwTextureStage;
    DWORD                       m_celsiusTexStageMapping[PSHAD_MAX_SHADER_STAGES];
    DWORD                       m_texturesUsed;

    D3DCOLORVALUE               m_pixelShaderConsts[PSHAD_MAX_CONSTANTS];
    DWORD                       m_dwPixelShaderConstFlags[PSHAD_MAX_CONSTANTS];

    SConstMapping               m_dwConstMapping[8][2];

    // Method declarations

    DWORD AllocateConstRegister(DWORD dwStage, DWORD dwRegNum, BOOL bSigned, DWORD dwMap);
    DWORD ColorConvertWithMapping(D3DCOLORVALUE color, DWORD dwMap, BOOL *bSigned);

    DWORD DSTdecode(DWORD *dst, DWORD *shift, DWORD *bias, DWORD *mask, DWORD op);
    DWORD SRCdecode(DWORD *src, DWORD *rgbAlpha, DWORD *alphaAlpha, DWORD *map, DWORD op, DWORD mask, BOOL bSignedConst);

    void GetTextureRegMapping(DWORD *newoffset, DWORD offset);
    DWORD GetShaderProgram(PNVD3DCONTEXT pContext, DWORD dwStage);

    DWORD GetRGBMapping(const CTexture *);

    void DBGPrintInstruction(DWORD op, DWORD dstop, DWORD *srcop);

    void SetCombinerInput(DWORD stage, DWORD color, DWORD var, DWORD mapping, DWORD alpha, DWORD src);

    static const DWORD  PSD3DModToNVMap[];
    static const DWORD  NVMapToNVMapInvert[];
    static const DWORD  PSTypeOffsetToCombinerReg[][4];
    static const DWORD  PSInstructionType[];
    static const char * PSInstructionStrings[];
    static const char * PSProgramNames[];
    static const bool   PSShaderUsesTexture[];
    static const int    PSD3DTexToNVShader[][4];
    static const DWORD  PSNumDstRegs[];
    static const DWORD  PSNumSrcRegs[];
    static const bool   PSIsProjective[];
    static void  (CPixelShader::* const PSInstructionLUT[])(PSHAD_INSTRUCTION_ARGS);
    static const char * PSRegTypeToPrefix[];
    static const char * PSWriteMask[];

    // Instructions broken into two groups, pairable and not.  Pairable ones
    // can be doubled up in a single combiner if there are no dependencies, and
    // have an extra parameter ("side") that determines whether the AB or CD
    // half is used.
    // Note: currently, no optimizations are in place that make this distinction.
    // This should change over time.

	// Standard DX8
    void InstructionMOV(PSHAD_INSTRUCTION_ARGS);
    void InstructionMUL(PSHAD_INSTRUCTION_ARGS);
    void InstructionDP3(PSHAD_INSTRUCTION_ARGS);
    void InstructionNOP(PSHAD_INSTRUCTION_ARGS);
    void InstructionADD(PSHAD_INSTRUCTION_ARGS);
    void InstructionSUB(PSHAD_INSTRUCTION_ARGS);
    void InstructionMAD(PSHAD_INSTRUCTION_ARGS);
    void InstructionLRP(PSHAD_INSTRUCTION_ARGS);
    void InstructionCND(PSHAD_INSTRUCTION_ARGS);

	// NVIDIA internal
	void InstructionNV_MMA(PSHAD_INSTRUCTION_ARGS);
	void InstructionNV_DD (PSHAD_INSTRUCTION_ARGS);
	void InstructionNV_MD (PSHAD_INSTRUCTION_ARGS);
	void InstructionNV_MM (PSHAD_INSTRUCTION_ARGS);
    void InstructionNV_SPF(PSHAD_INSTRUCTION_ARGS);

public:

    BOOL create(PNVD3DCONTEXT pContext, DWORD dwHandle, DWORD dwCodeSize, DWORD *lpCode);
    inline DWORD getHandle() const { return m_dwHandle;  }

    BOOL needsTexCoords(DWORD dwStage) { return (m_shaderStageProgram[dwStage] != NV097_SET_SHADER_STAGE_PROGRAM_STAGE0_PROGRAM_NONE); }

#if (NVARCH >= 0x020)
    void setKelvinState(PNVD3DCONTEXT);
#endif
#if (NVARCH >= 0x010)
    void setCelsiusState(PNVD3DCONTEXT);
#endif

    bool stageUsesTexture(DWORD);
    DWORD isBEM(DWORD);
    DWORD isBEML(DWORD);
    DWORD getNumTexCoords(PNVD3DCONTEXT, DWORD);

    ~CPixelShader(void);
};

#ifdef __cplusplus
}
#endif

#endif // _nvPShad_h
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\ddraw\common\inc\nvStereo.h ===
/***************************************************************************\
* Copyright 1993-1999 NVIDIA, Corporation.  All rights reserved.            *
* THE INFORMATION CONTAINED HEREIN IS PROPRIETARY AND CONFIDENTIAL TO       *
* NVIDIA, CORPORATION.  USE, REPRODUCTION OR DISCLOSURE TO ANY THIRD PARTY  *
* IS SUBJECT TO WRITTEN PRE-APPROVAL BY NVIDIA, CORPORATION.                *
*                                                                           *
*  Portions: Copyright (C) 1995 Microsoft Corporation.  All Rights Reserved.*
*                                                                           *
* Module: Stereo.h                                                          *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*       Andrei Osnovich    02/08/00  Created                                *
*                                                                           *
\***************************************************************************/

#ifndef _STEREO_H_
#define _STEREO_H_

#ifdef  STEREO_SUPPORT

#define LASER_SIGHT
#define SNAP_SHOT

#ifdef	DEBUG
#define	STEREO_DEBUG
#else
#ifdef	DEVELOP
#define	STEREO_DEBUG
#endif
#endif

#include <nvRmStereo.h>
#include "duma.h"
#include "StereoDDK.h"

#define UPTODATE_STEREO_SUPPORT (SVF_OVERANDUNDER | SVF_FRAMESEQUENTIAL)

//Eye's IDs.
#define EYE_NONE  0
#define EYE_LEFT  1
#define EYE_RIGHT 2
#define EYE_COUNT EYE_RIGHT+1

#define DEFAULT_STEREO_SEPARATION               0.08f
#define DEFAULT_STEREO_CONVERGENCE              4.0f
#define DEFAULT_STEREO_CONVERGENCE_MULTIPLIER   5.0f
#define CONVERGENCE_THRESHOLD                   0.01f

//FrustumAdjustMode values
#define NO_FRUSTUM_ADJUST                   0
#define FRUSTUM_STRETCH                     1
#define FRUSTUM_CLEAR_EDGES                 2

//PartialClearMode values
#define DO_AS_REQUESTED                     0
#define DO_A_FULL_CLEAR                     1
#define DO_NOTHING                          2

//Possible bit values in the pStereoData->dwFlags.
#define STEREO_PROJECTIONMATRIXVALID        0x00000001
#define STEREO_LOCKCACHEABLE                0x00000002
#define STEREO_FORCEDOFF                    0x00000004
#define STEREO_FORCEDTOGDI                  0x00000008
#define STEREO_LOCKACTIVE                   0x00000010
#define STEREO_LOCKINIT                     0x00000020
#define STEREO_RHWGREATERATSCREEN           0x00000040
#define STEREO_RHWEQUALATSCREEN             0x00000080
#define STEREO_RHWLESSATSCREEN              0x00000100
#define STEREO_DISALLOWED_NOT_FULL_SCREEN   0x00000200
#define STEREO_DISALLOWED_NO_RESOURCES      0x00000400
#define STEREO_DISALLOWED                   0x00000600
#define STEREO_AUTOCONVERGENCE              0x00000800
#define STEREO_DISABLETnL                   0x00001000
#define STEREO_RIGHTEYEINIT                 0x00002000
#define STEREO_FAVORSZOVERRHW               0x00004000
#define STEREO_LASERSIGHT                   0x00008000
#define STEREO_LASERGETRHWSCALE             0x00010000
#define STEREO_CLEAROCCURED                 0x00020000
#define STEREO_DEFAULTON                    0x00040000
#define STEREO_CONVERGENCE                  0x00080000
#define STEREO_CONVERGENCEMULTIPLIER        0x00100000
#define STEREO_SEPARATION                   0x00200000
#define STEREO_LASERSIGHTENABLED            0x00400000
#define STEREO_ANAGLYPH                     0x00800000
#define STEREO_GAMMACORRECTION              0x01000000
#define STEREO_MIXEDTNLS					0x02000000

#define STEREO_CUSTOMSETTINGSMASK           (STEREO_RHWGREATERATSCREEN|STEREO_RHWEQUALATSCREEN|STEREO_RHWLESSATSCREEN|STEREO_AUTOCONVERGENCE|STEREO_CONVERGENCE|STEREO_CONVERGENCEMULTIPLIER|STEREO_SEPARATION|STEREO_FAVORSZOVERRHW)      

#define STEREO_LOG_DIRECTORY		        "C:\\NVSTEREO.LOG"
#define STEREO_IMG_DIRECTORY		        "C:\\NVSTEREO.IMG"

#ifdef  LASER_SIGHT_
typedef unsigned short* (__cdecl *GetLaserSightType)    (DWORD &dwWidth, DWORD &dwHeight, COLORREF &crRef, DWORD &dwTransparency);	
typedef void            (__cdecl *ReleaseLaserSightType)(unsigned short *pusData);
#endif  //LASER_SIGHT
#ifdef  LASER_SIGHT
typedef unsigned short* (__cdecl *GetLaserSight)    (DWORD &dwWidth, DWORD &dwHeight, DWORD &dwColorKey);	
typedef void            (__cdecl *ReleaseLaserSight)(unsigned short *pusData);
#endif  //LASER_SIGHT

typedef struct _per_vertex_storage_Flip
{
    LPD3DVALUE      pVertex;
    D3DVALUE        OrigX;
    D3DVALUE        XCorrection;
} PERVERTEXSTORAGE_FLIP, *LPPERVERTEXSTORAGE_FLIP;

/*****************************************************************************
 * CVertexRegister
 * This class is used to determine which vertices are unique in a list. Required when we modify
 * post-transformed vertices for the left and right eyes.
 */
class CVertexRegister
{
    /*
     * constants
     */
public:
    enum
    {   //m_dwStage possible values.
        FIRST_EYE           = 0,
        SECOND_EYE          = 1,
        RESTORE             = 2,
    };
    /*
     * members
     */
protected:
    LPBYTE                  m_pInUse;
    DWORD                   m_dwInUseSize;
    LPPERVERTEXSTORAGE_FLIP m_VertexStorage_Flip;
    DWORD                   m_dwVertexCount;
    DWORD                   m_dwStage; // 0 - first eye, 1 - second eye, 2 - restore

    /*
     * methods
     */
public:
    inline void cleanupInUse(void)
    {
        memset ((LPVOID)m_pInUse, 0, m_dwInUseSize);
        //Pleeease don't touch m_dwStage. It lives its own life.
    }
    BOOL isInUse(DWORD dwVertex);
    BOOL isInUseTag(DWORD dwVertex);
    inline void UpdateStage(void)
    {
        if (++m_dwStage > RESTORE)
            m_dwStage = FIRST_EYE;
    }
    inline void SaveX(LPD3DVALUE pX)
    {
        m_VertexStorage_Flip[m_dwVertexCount].pVertex  = pX;
        m_VertexStorage_Flip[m_dwVertexCount].OrigX    = pX[0];
    }
    inline void SaveXCorrection_Flip(D3DVALUE XCorrection)
    {
        m_VertexStorage_Flip[m_dwVertexCount].XCorrection  = XCorrection;
        m_dwVertexCount++;
    }
    //Next functions' behaviour is based on the current stage. If stage is FIRST_EYE the function does nothing
    //and report that. The caller is responsible to fill out the m_pVertexData and next time the DoAutomaticStage
    //will take care of everything automatically.
    DWORD   DoAutomaticStage_Flip(void);

    /*
     * construction
     */
public:
    CVertexRegister (DWORD dwNumVertices);
    ~CVertexRegister (void);
};

#define	STEREO_CONFIG_ASSIST
#ifdef	STEREO_CONFIG_ASSIST
typedef struct _CONFIG_ASSIST_INFO
{
    HOTKEY      SuggestKey;
    HOTKEY      UnsuggestKey;
    HOTKEY      WriteKey;
    HOTKEY      DeleteKey;
    HOTKEY      FrustumAdjust;
    HOTKEY      ToggleAutoConvergence;
    HOTKEY      ToggleAutoConvergenceRestore;
    HOTKEY      RHWAtScreenMore;
    HOTKEY      RHWAtScreenLess;
    HOTKEY      RHWLessAtScreenMore;
    HOTKEY      RHWLessAtScreenLess;
    HOTKEY      LaserXPlusKey;
    HOTKEY      LaserXMinusKey;
    HOTKEY      LaserYPlusKey;
    HOTKEY      LaserYMinusKey;
    HOTKEY      GammaAdjustMore;
    HOTKEY      GammaAdjustLess;
    DWORD       dwFlags;

    D3DVALUE    rhwMin;
    D3DVALUE    rhwMax;
    D3DVALUE    rhwMin2D;
    D3DVALUE    rhwMax2D;
    D3DVALUE    szMin;
    D3DVALUE    szMax;
    D3DVALUE    szMin2D;
    D3DVALUE    szMax2D;

    D3DVALUE    fLastNonAutoConvergenceMultiplier;
    HANDLE      FileHandle;
    char        Buf[1024];
} CONFIG_ASSIST_INFO;
#endif //STEREO_CONFIG_ASSIST

typedef struct _STEREOSETTINGS {
    DWORD               dwFlags;
    float               fStereoSeparation;      //Half way horizontal separation if screen width is 1.0 (0.04).
    float               fScreenStereoSeparation;//Half way horizontal separation in pixels based on mode.
    float               fStereoConvergence;     //Convergence degree (in the range [0.0 - 0.15]).
    float               fPostStereoConvergence; //Convergence degree for post-transform (game specific).
    float               fPostStereoXStretch;    //Stretching of the field of view for post-transform.
    float               fPostStereoXShift;      //Shifting of the field of view for post-transform.
    float               fRHWGreaterAtScreen;    //All objects closer than this are considered to be 2D.
    float               fRHWLessAtScreen;       //All objects farther than this are considered to be 2D.
    float               fConvergenceMultiplier; //fPostStereoConvergence = fStereoConvergence*fConvergenceMultiplier
    DWORD               FrustumAdjustMode;      //Tells how to adjust frustum for possible lack of X information after eye shift.
    DWORD               PartialClearMode;       //Tells how to do a partial clear (as is, replace with a full screen clear or ignore).
    float               AutoConvergenceAdjustPace;
    float               fStereoGamma;
#ifdef  LASER_SIGHT
    float               fLaserXAdjust;
    float               fLaserYAdjust;
#endif  //LASER_SIGHT
} STEREOSETTINGS, *LPSTEREOSETTINGS;

typedef struct _STEREOHOKEYS {
    LPCHOTKEYINTERFACE  pHotKeyI;
    HOTKEY              StereoToggle;
    HOTKEY              StereoSeparationAdjustMore;
    HOTKEY              StereoSeparationAdjustLess;
    HOTKEY              StereoConvergenceAdjustMore;
    HOTKEY              StereoConvergenceAdjustLess;
} STEREOHOKEYS, *LPSTEREOHOKEYS;

typedef struct _STEREOEYE {
    D3DHAL_DP2VIEWPORTINFO  Viewport;               //Eye viewport
    D3DMATRIX               ProjMatrix;             //Eye projection matrix
} STEREOEYE, *LPSTEREOEYE;

typedef struct _STEREODATA {
    STEREOSETTINGS          StereoSettings;
    BOOL                    bStereoActivated;       //Stereo is currently activated.
    DWORD                   dwHWTnL;                //Total amount of currently allocated non transformed VBs.
    BYTE                    StereoViewerName[128];  //Stereo viewer driver name.
#ifdef  LASER_SIGHT
    BYTE                    LaserSightFile[128];    //Stereo laser sight file name.
#endif  //LASER_SIGHT
    DWORD                   dwStereoVideoMode;      //Current video mode used for stereo.
#ifdef  STEREO_VIEWER_DRV
    STEREOCAPS              StereoViewerCaps;       //Stereo viewer capabilities.
    DWORD                   dwStereoFormat;         //Method of displaying stereo.
    LPSTEREOVIEWER          pStereoViewer;          //Pointer to stereo viewer object
    HMODULE                 hStereoDrv;             //Stereo viewer driver handle.
#else   //STEREO_VIEWER_DRV==0
    DWORD                   dwStereoHWType;         //Stereo Viewer HW type.
    DWORD                   dwLineCodeColor;
	DWORD					dwLeftAnaglyphFilter;
	DWORD					dwRightAnaglyphFilter;
#endif  //STEREO_VIEWER_DRV
    float                   fFrameRHWMax;           //Closes vertex RHW for a scene.
    float                   fRHW2DDetectionMin;     //RHW far limit for 2D object detection.
    DWORD                   dwLastEye;              //The eye representing the current stereo context.
    PNVD3DCONTEXT           dwContext;
    DWORD                   StereoModeNumber;       //Video mode for which stereo had been activated
    DWORD                   dwVertexRegisterSize;   //Max # of vertices we accept.
    CVertexRegister        *pVertexRegister;        //Pointer to an object used to modify post-transformed vertices.
    LPDDRAWI_DDRAWSURFACE_LCL pLockSubstituteLcl;   //Lock substitute local for emulating front-back-z locks.
    CSimpleSurface         *pLastLockedSurface;
    LPDDRAWI_DDRAWSURFACE_LCL pLockTargetLcl;       //Our fake persistent Lcl for delayed lock processing
    DWORD                   dwSurfaceCount;         //# of stereo surfaces
    char                    bAppName[128];          //Current application name returned by GetCommandLine (might be bogus).
    char                    bAppRealName[128];      //Current application name retreived from the bAppName (if not a symbolic link).
    WORD                    SaveCurrentGamma[256*3];
    CSimpleSurface         *pRenderTargets[3];      
    NV_CFG_STEREO_PARAMS    RmStereoParams;         //Shared structure between D3D driver & resman for flipped stereo.
    STEREOHOKEYS            StereoKeys;             //Stereo control hotkeys.
    STEREOEYE               Eye[EYE_COUNT];         //Eye specific stereo data
} STEREODATA, *LPSTEREODATA;

typedef struct StereoBltPassInfo
{
    union {
        DWORD   dwDstOffset;
        DWORD   dwDstY;
        FLATPTR fpDstVidMem;
        LONG    lTop;
    };
    union {
        DWORD   dwSrcOffset;
        DWORD   dwSrcY;
        FLATPTR fpSrcVidMem;
        LONG    lBottom;
    };
    DWORD   dwPass;
} STEREOBLTPASSINFO, *LPSTEREOBLTPASSINFO;

typedef DWORD (*PSTEREOEYEFUNC)(PNVD3DCONTEXT pContext, LPBYTE pVertices, DWORD dwCount);
typedef DWORD (*PSTEREOEYEFUNCINDEX)(PNVD3DCONTEXT pContext, LPBYTE pVertices, LPBYTE pIndices, DWORD dwCount);
typedef BOOL  (*PSTEREORHWFUNC)(PNVD3DCONTEXT pContext, LPBYTE pVertices, DWORD dwCount, DWORD dwCondition);
typedef BOOL  (*PSTEREORHWFUNCINDEX)(PNVD3DCONTEXT pContext, LPBYTE pVertices, LPBYTE pIndices, DWORD dwCount, DWORD dwCondition);

extern  void                        LoadStereoRegistry(void);
extern  void                        StereoAdjustmentMonitor(PNVD3DCONTEXT pContext);
extern  void                        StereoContextCreate(void);
extern  void                        StereoContextDestroy(PNVD3DCONTEXT pContext);
extern  void                        DestroyStereo(void);
extern  LPD3DMATRIX                 SetStereoProjection(LPD3DMATRIX pMat, PNVD3DCONTEXT pContext);
extern  void                        SetupStereoContext(PNVD3DCONTEXT pContext);
extern  void                        AlternateStereoContext(PNVD3DCONTEXT pContext);
extern  DWORD                       GetStereoOffset(CSimpleSurface *pSurf);
extern  DWORD                       StereoBltAdjustParameters(SURFINFO &src, SURFINFO &dst, STEREOBLTPASSINFO &StereoBltPass);
extern  BOOL                        CreateLockSubstitute(LPDDRAWI_DDRAWSURFACE_LCL pDDSLcl);
extern  BOOL                        StereoLockSubstitute(LPDDHAL_LOCKDATA lpLockData);
extern  BOOL                        StereoLockSubstituteRestore(LPDDHAL_UNLOCKDATA lpUnlockData);
extern  BOOL                        StereoLockSubstituteFlush(void);
extern  void                        StereoFlipNotify(LPDDHAL_FLIPDATA pfd);
extern  void                        StereoModeSetProcessing(void);
extern  void                        StereoModifyDDHALInfo(void);
extern  void                        StereoBackend(LPDDHAL_FLIPDATA pfd);
extern  void __cdecl                LOG(char * szFormat, ...);

#ifdef  PER_PRIMITIVE_SYNC
extern  void						StereoSync(void);
#endif	//PER_PRIMITIVE_SYNC

#ifdef  LASER_SIGHT
//extern  void                        ClearLaserSight(PNVD3DCONTEXT pContext);
#endif  //LASER_SIGHT

extern  LPSTEREODATA                pStereoData;
extern  nvDP2FunctionTable nvDP2SetFuncs_Stereo_Flip;
extern  nvDP2FunctionTable nvDP2SetFuncs_Orig;

#define NvSetStereoDataPtrFromDriverData  pStereoData=(LPSTEREODATA)pDriverData->pStereoData;

#define STEREO_ENABLED              (pStereoData) //Stereo can be potentially activated.
#define STEREO_ACTIVATED            (STEREO_ENABLED && pStereoData->bStereoActivated)
#define ORIG_VIEWPORT               (pStereoData->Eye[EYE_NONE].Viewport)
#define ORIG_PROJECTION             (pStereoData->Eye[EYE_NONE].ProjMatrix)
#define STEREO_R_US(pCtxt)          (pStereoData->dwContext==pCtxt) // BUGBUG remove me eventually
#define STEREODATA(field)           pStereoData->field

#define CREATESTEREOHOTKEY(HotKey)  CREATEHOTKEY(pStereoData->StereoKeys.pHotKeyI,HotKey)
#define DESTROYSTEREOHOTKEY(HotKey) DESTROYHOTKEY(pStereoData->StereoKeys.pHotKeyI,HotKey)
#define POLLSTEREOHOTKEY(HotKey)    POLLHOTKEY(pStereoData->StereoKeys.pHotKeyI,HotKey)
#define ENFORCEKEYBOARDFILTER()     ENFORCEFILTER(pStereoData->StereoKeys.pHotKeyI)

/*********************************************************************************************************/

#else  // !STEREO_SUPPORT

#define NvSetStereoDataPtrFromDriverData

/*********************************************************************************************************/

#endif  // !STEREO_SUPPORT

#endif  //_STEREO_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\ddraw\common\inc\NVSTAT.h ===
/////////////////////////////////
// Header file for NVSTAT.VxD
// FileName: NVSTAT.h - created by VxDWriter

#ifndef _NVSTAT_H
#define _NVSTAT_H

#define  NVSTAT_MAJOR_VER      1	// Major version No. of VxD
#define  NVSTAT_MINOR_VER      7    // Minor version No. of VxD
#define  NVSTAT_DEVICE_ID      0x3FD5	// Device ID for this VxD
#define  NVSTAT_INIT_ORDER     UNDEFINED_INIT_ORDER	// Initialization order

enum NVSTATIOCTLS {
// WIN95 device IO Control's are +1
#ifdef _VXDLIB_H
		GETVERSION = 0,
#else
		GETVERSION = 1,
#endif
		STARTCAPTURE,
		ENDCAPTURE,
		SETCONFIGURATION,
		GETCONFIGURATION,
		SETRING3CALLBACK,		// callback when pageflip/blt happens.
		CLEARSTATISTICS,
		INITUSERMEMORY			// has to be done in context of application
};

#ifndef NVSTATNT_IOCTL
#define NVSTATNT_IOCTL(_index_) \
    CTL_CODE (FILE_DEVICE_NVSTATNT, _index_, METHOD_BUFFERED, FILE_ANY_ACCESS)
#endif

#define IOCTL_NVSTATNT_GETVERSION					NVSTATNT_IOCTL (GETVERSION)
#define IOCTL_NVSTATNT_STARTCAPTURE					NVSTATNT_IOCTL (STARTCAPTURE)
#define IOCTL_NVSTATNT_ENDCAPTURE					NVSTATNT_IOCTL (ENDCAPTURE)
#define IOCTL_NVSTATNT_SETCONFIGURATION				NVSTATNT_IOCTL (SETCONFIGURATION)
#define IOCTL_NVSTATNT_GETCONFIGURATION				NVSTATNT_IOCTL (GETCONFIGURATION)
#define IOCTL_NVSTATNT_SETRING3CALLBACK				NVSTATNT_IOCTL (SETRING3CALLBACK)
#define IOCTL_NVSTATNT_CLEARSTATISTICS				NVSTATNT_IOCTL (CLEARSTATISTICS)
#define IOCTL_NVSTATNT_INITUSERMEMORY				NVSTATNT_IOCTL (INITUSERMEMORY)

#define DRIVER_DEVICE_NAME L"NVSTAT"
#define FILE_DEVICE_NVSTATNT  0x00008400


#define	CTRLHOTKEY	(1 << 16)
#define ALTHOTKEY	(2 << 16)
#define SHIFTHOTKEY (4 << 16)

typedef enum FRAMEENDTYPE
{
	FEFLIP = 0,
	FEBEGINEND,
	FEBLIT
} FRAMEENDTYPE;

typedef enum VERTFLAGS
{
	VERTSBMASK = 1,
	VERTSNORMALMASK = 2,
	VERTSUSERUV1 = 4,
	VERTSUSERUV0 = 8,
	VERTSSPECULAR = 16,
	VERTSDIFFUSE = 32,
	VERTSXYZ = 64,
	VERTSRHW = 128
} VERTFLAGS;

#pragma pack(push,1)
typedef struct NVSTATCNF
{
	DWORD captureSize;			// capture size in bytes/ this is static
	void *captureMem;
	DWORD logSize;				// how big the memory log size is (4k chunks)
	void *logMem;				// pointer to log memory
	DWORD logHead;				// header of log buffer for wrap mode
	DWORD logTail;				// tail of log buffer for wrap mode
	DWORD logFormat;			// 0 = off, 1 = minimal, 2 = maximum (everything)
	DWORD  logFull;				// flag when circular buffer is full
	DWORD logMissed;			// number of dwords missed while log is full
	DWORD hotKey;				// LOWWORD = scan code/ HIWORD(CTRLHOTKEY | ALTHOTKEY | SHIFTHOTKEY)
	FRAMEENDTYPE fEndType;		// how to capture/ flips/blts - Begin Scene/End Scene pair
	DWORD startFrame;			// starting Frame to capture
	DWORD endFrame;				// ending frame to capture
	DWORD frameRangeEnable;
} NVSTATCNF;
#pragma pack(pop)

#include "statdef.h"

#ifndef NVSTATDRIVER
#include "basetyps.h"
#include "d3d8types.h"
#define D3D_RENDERSTATE_MAX     D3DRS_BLENDOP
#define D3D_TEXSTAGESTATE_MAX   D3DTSS_RESULTARG
#else
// include this earlier, so we can redefine dbgTracePush
#include "nvDbg.h"
#include "d3dconst.h"
#endif

#define D3D_NUM_RENDERSTATES	(D3D_RENDERSTATE_MAX+1)
#define D3D_NUM_TEXSTAGESTATES	(D3D_TEXSTAGESTATE_MAX+1)

#define DXNUMFUNCTIONS (STAT_NUM_FUNCTIONS+D3D_NUM_RENDERSTATES+D3D_NUM_TEXSTAGESTATES)

#define START_RENDER_STATE (STAT_NUM_FUNCTIONS)
#define END_RENDER_STATE (STAT_NUM_FUNCTIONS+(D3D_NUM_RENDERSTATES))

#define D3D_LOG_PARAMETERS	0x8000					// bit to set for parameters

enum {
	D3D_LOG_ERROR = DXNUMFUNCTIONS | D3D_LOG_PARAMETERS,
	D3D_LOG_PERFORMANCE,
	D3D_LOG_DX6_PRIMITIVES,
	D3D_LOG_DX5_PRIMITIVES,
	D3D_LOG_DX7_PRIMITIVES,
	D3D_LOG_DX8_PRIMITIVES,
	D3D_LOG_FRAME_END,
	D3D_PRIM_COUNT_PARMS,
	D3D_LOG_LOCK_INDEX
};

typedef enum LOGFORMATBITS
{
	LOG_NONE_BIT = 0,							// no bits set
	LOG_MINIMUM_BIT = 1,
	LOG_MEDIUM_BIT = 2,
	LOG_MAXIMUM_BIT = 4,
	LOG_PERFORMANCE_BIT = 8
} LOGFORMATBITS;

#pragma pack(push,1)
//
// ---- structure for static clock tick counters
//
typedef struct NVDXTICK
{
	DWORD captureOn;							// 0 = No Capture, >= 1 if lock count
	FRAMEENDTYPE fEndType;						// how to capture/ flips/blts - Begin Scene/End Scene pair
	DWORD frameRangeEnable;						// whether to capture between frames
	DWORD startFrame;							// which frame to turn on the capture
	DWORD endFrame;								// when to turn off the capture
	DWORD FRCount;								// incremented hit count for range of frames
	DWORD tickCount;							// Timer tick count for this frame
	DWORD curFrame;								// current frame count for direct draw
	DWORD logSize;								// how big the memory log size is (4k chunks)
	DWORD logHead;								// header of log buffer for wrap mode
	DWORD logTail;								// tail of log buffer for wrap mode
	DWORD logFormat;
	void *logMem;								// pointer to log memory, can change so this variable is duplicated
	void *userLogMem;							// user memory in case different from kernel memory
	DWORD  logFull;								// flag when circular buffer is full
	DWORD logMissed;							    // number of dwords missed while log is full
	__int64 DXAdditiveTick[DXNUMFUNCTIONS];	// all the ticks for the capture
	DWORD DXHits[DXNUMFUNCTIONS];				// number of hits for this function
} NVDXTICK;
#pragma pack(pop)

#define SCAN_SYSREQ     0x54	// default scan-code
#define VK_SYSREQ		0x2c	// windows NT uses VK Codes.
#define SCAN_BREAK		0		// ?????

// this was added so we can include this file for Ring 3 applications.
#ifdef _VXDLIB_H
// Prototype declaration(s) for Win32 device ioctl APIs(s)
W32API_PROC GetVersion;		// Declare additional prototypes here.
W32API_PROC	StartCapture;
W32API_PROC	EndCapture;
W32API_PROC	SetConfiguration;
W32API_PROC	GetConfiguration;
W32API_PROC SetRing3Callback;
W32API_PROC ClearStatistics;

#define NVSHIFTSTATE(mask, compare) ( (~((mask) | SS_Toggle_mask)) << 16 | compare)

#endif

#ifdef NVSTATDRIVER

extern NVDXTICK *DXStatTickPtr;
void __cdecl nvStatLookupIndex(char *fmt, ...);

typedef struct STATINDEX
{
	DWORD	index;
	DWORD	nParms;
	__int64 startCount;
	__int64 outsideCount;
	STATINDEX *lastStatIndex;
} STATINDEX;

#define INVALID_INDEX 0xffffffff

#undef dbgTracePush
#define dbgTracePush																						\
	static STATINDEX StatIndex = { INVALID_INDEX, 0 };	/* Create the static class */ 						\
	CStatEnd StatEnd(&StatIndex);						/* when this routine ends call ~CStatEnd */			\
	if (gNVStatIndex != &StatIndex)						/* check for recursion */							\
	{																										\
		StatIndex.lastStatIndex = gNVStatIndex;																\
		StatIndex.outsideCount = 0;						/* reset outside count to zero */					\
	}																										\
	gNVStatIndex = &StatIndex;							/* Setup global for our lookup routine */			\
	if (DXStatTickPtr && DXStatTickPtr->captureOn >= 1)	/* if we are capturing data	*/						\
	{																										\
		DXStatTickPtr->captureOn++;						/* bump up reference count */						\
		if ((StatIndex.index != INVALID_INDEX) && (StatIndex.index < STAT_NUM_FUNCTIONS)) 					\
		{												/* if not first time through */						\
			nvStatWriteLogOpCode(1, StatIndex.index);	/* call to write opcode to log memory */			\
			if (DXStatTickPtr->logFormat & LOG_MEDIUM_BIT) /* if medium logging is enabled */				\
			{																								\
				NVStatLogMedium(StatIndex.index, 0);														\
			}																								\
			else if (DXStatTickPtr->logFormat & LOG_MAXIMUM_BIT) /* call maximum logging function */		\
			{																								\
				NVStatLogMaximum(StatIndex.index, 0);														\
			}																								\
		}																									\
		{																									\
		__asm push	eax																						\
		__asm push	ebx																						\
		__asm push	edx									/* save some register */							\
		__asm rdtsc										/* read time stamp count */							\
		__asm mov	ebx, OFFSET (StatIndex.startCount)	/* save off count into static StatIndex structure */\
		__asm mov	[ebx], eax																				\
		__asm mov	[ebx+4], edx																			\
		__asm pop	edx																						\
		__asm pop	ebx																						\
		__asm pop	eax																						\
		}																									\
	}												/* this next code replaces dbgPushTrace	with lookup */	\
	nvStatLookupIndex

extern STATINDEX *gNVStatIndex;

class CStatEnd {
public:
	STATINDEX *curSI;

	CStatEnd(STATINDEX *localSI)
	{
		curSI = localSI;
	}

	~CStatEnd()
	{
		__int64 endCount;

		// if capture is hooked up and it it is on and startCount has been initialized
		if (DXStatTickPtr && DXStatTickPtr->captureOn > 1)
		{
			__asm {
				push eax
				push ebx
				push edx
				rdtsc
				mov	dword ptr endCount, eax			/* save off end count */
				mov	dword ptr endCount+4,edx
				pop	edx
				pop	ebx
				pop	eax
			};

			if (curSI->index != INVALID_INDEX)
			{
				// turn into delta count
				endCount -= curSI->startCount;
				if (curSI->lastStatIndex != NULL)
				{
					// add our accumlated deltas to subtract out of parents
					curSI->lastStatIndex->outsideCount += endCount;
				}

				// subtract out calls to other functions we called
				endCount -= curSI->outsideCount;

				DXStatTickPtr->DXAdditiveTick[curSI->index] += endCount;
				DXStatTickPtr->DXHits[curSI->index]++;
			}

			DXStatTickPtr->captureOn--;
		}

		gNVStatIndex = curSI->lastStatIndex;
	}
};



typedef enum
{
	NVSTAT_LOCK_UNKNOWN = 0,
	NVSTAT_LOCK_PALETTE = 1,
	NVSTAT_LOCK_OPT_DEST = 2,
	NVSTAT_LOCK_VB = 3,
	NVSTAT_LOCK_AUTO_MIP = 4,
	NVSTAT_LOCK_VB_FLUSH = 5,
	NVSTAT_LOCK_UPDATE_LINEAR = 6,
	NVSTAT_LOCK_L2L_COPY = 7,
	NVSTAT_LOCK_L2O_COPY = 8,
	NVSTAT_LOCK_O2L_COPY = 9,
	NVSTAT_LOCK_O2O_COPY = 10,
	NVSTAT_LOCK_FILL_OPT = 11,
	NVSTAT_LOCK_STR_BLT = 12,
	NVSTAT_LOCK_TEX_NORMAL = 13,
	NVSTAT_LOCK_TEXMAN_EVICT = 14,
	NVSTAT_LOCK_TEXMAN_EVICT_ALL = 15,
	NVSTAT_LOCK_EXECUTE_BUFFER = 16,
	NVSTAT_LOCK_VID_TEX = 17,
	NVSTAT_LOCK_COPY_TEX = 18,
	NVSTAT_LOCK_UPDATE_OPTIMIZED = 19
} NVSTATLOCKINDEX;

extern NVSTATLOCKINDEX nvStatLockIndex;

struct _def_nv_d3d_context;
typedef _def_nv_d3d_context *PNVD3DCONTEXT;

void NVStatLogMedium(DWORD DXFunction, DWORD value);
void NVStatLogMaximum(DWORD DXFunction, DWORD value);
void nvStatWriteLogOpCode(DWORD nDWords, DWORD opCode);
void nvStatWriteLogData(DWORD nDWords, DWORD *theData);
BOOL nvStatCheckLogSpace(DWORD nDWords);
void __cdecl nvStatLogDwordData(DWORD parmEnum, int count, ...);
void nvStatLogVertexData(BOOL dx6, DWORD *pVertex);
void __stdcall nvCelsiusDispatchPrintVertex (PNVD3DCONTEXT pContext,DWORD dwPutAddress);
void __stdcall nvKelvinDispatchPrintVertex (PNVD3DCONTEXT pContext,DWORD dwPutAddress);

#define DDLOCKINDEX(LockIndex)				\
	nvStatLockIndex = LockIndex;

#define DDSTARTTICK(DXFunction)
#define DDENDTICK(DXFunction)


// FOffset come in one based, so decrement it.
#define DDTICKOFFSET(DXFunction, value)				\
{														\
	if (DXStatTickPtr != NULL)							\
	{													\
		if (DXFunction < (D3D_NUM_RENDERSTATES+D3D_NUM_TEXSTAGESTATES))			\
		{												\
			StatIndex.index = (DXFunction)+STAT_NUM_FUNCTIONS;	\
			if (DXStatTickPtr->captureOn >= 1)				\
			{												\
				nvStatWriteLogOpCode(1, StatIndex.index);	\
				if (DXStatTickPtr->logFormat & LOG_MEDIUM_BIT)	\
				{											\
					NVStatLogMedium(StatIndex.index, (value));	\
				}											\
				else if (DXStatTickPtr->logFormat & LOG_MAXIMUM_BIT)	\
				{											\
					NVStatLogMaximum(StatIndex.index, (value)); \
				}											\
			}												\
		}													\
	}														\
}	

#define DDFLIPTICKS(flipType)				\
	if (DXStatTickPtr != NULL)				\
	{										\
		if (DXStatTickPtr->fEndType == flipType)	\
		{									\
			DWORD frameTickCount;			\
											\
			frameTickCount = DXStatTickPtr->tickCount;		\
			DXStatTickPtr->tickCount = NvGetTickCount();	\
			frameTickCount = DXStatTickPtr->tickCount - frameTickCount;	\
			if (DXStatTickPtr->captureOn >= 1) \
			{								\
				nvStatWriteLogOpCode(3, D3D_LOG_FRAME_END);	\
				nvStatWriteLogData(1, &frameTickCount); \
				nvStatWriteLogData(1, &(DXStatTickPtr->curFrame)); \
			}								\
			DXStatTickPtr->curFrame++;		\
		}									\
		if (DXStatTickPtr->frameRangeEnable)	\
		{									\
			if (DXStatTickPtr->captureOn == 0)	\
			{								\
				if (DXStatTickPtr->curFrame == DXStatTickPtr->startFrame)	\
					DXStatTickPtr->captureOn = 1; \
			}								\
			else							\
			{								\
				if (DXStatTickPtr->curFrame == DXStatTickPtr->endFrame)	\
				{							\
					DXStatTickPtr->captureOn = 0;	\
					DXStatTickPtr->FRCount++; \
				}							\
			}								\
		}									\
	}

#define DDFLIPINIT()						\
	if (DXStatTickPtr != NULL)				\
	{										\
		DXStatTickPtr->curFrame = 0;		\
		DXStatTickPtr->logTail = 0;			 /* reset logging */ \
	}				

#define DDSTATLOGWORDS(x, y, z)				\
	if ((DXStatTickPtr != NULL) &&			\
		((DXStatTickPtr->logFormat & (LOG_MAXIMUM_BIT | LOG_MEDIUM_BIT)) != 0))	\
	{										\
		DWORD temp;							\
		temp = (z);							\
		nvStatWriteLogOpCode(2, x);		\
		nvStatWriteLogData(1, (DWORD *)(&temp)); \
	}										\

#else

#define DDSTARTTICK(DXFunction)
#define DDENDTICK(DXFunction)
#define DDSTARTTICKO(pContext, DXFunction, FOffset)
#define DDENDTICKO(DXFunction, FOffset)
#define DDFLIPTICKS(flipType)
#define DDFLIPINIT()
#define DDSTATLOGWORDS(x, y, z)
#define DDLOCKINDEX(LockIndex)
#define DDTICKOFFSET(DXFunction, value)

#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\ddraw\common\inc\nvSurf.h ===
// **************************************************************************
//
//       Copyright 1993-1999 NVIDIA, Corporation.  All rights reserved.
//
//     NOTICE TO USER:   The source code  is copyrighted under  U.S. and
//     international laws.  Users and possessors of this source code are
//     hereby granted a nonexclusive,  royalty-free copyright license to
//     use this code in individual and commercial software.
//
//     Any use of this source code must include,  in the user documenta-
//     tion and  internal comments to the code,  notices to the end user
//     as follows:
//
//       Copyright 1993-1999 NVIDIA, Corporation.  All rights reserved.
//
//     NVIDIA, CORPORATION MAKES NO REPRESENTATION ABOUT THE SUITABILITY
//     OF  THIS SOURCE  CODE  FOR ANY PURPOSE.  IT IS  PROVIDED  "AS IS"
//     WITHOUT EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORPOR-
//     ATION DISCLAIMS ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,
//     INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY, NONINFRINGE-
//     MENT,  AND FITNESS  FOR A PARTICULAR PURPOSE.   IN NO EVENT SHALL
//     NVIDIA, CORPORATION  BE LIABLE FOR ANY SPECIAL,  INDIRECT,  INCI-
//     DENTAL, OR CONSEQUENTIAL DAMAGES,  OR ANY DAMAGES  WHATSOEVER RE-
//     SULTING FROM LOSS OF USE,  DATA OR PROFITS,  WHETHER IN AN ACTION
//     OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,  ARISING OUT OF
//     OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOURCE CODE.
//
//     U.S. Government  End  Users.   This source code  is a "commercial
//     item,"  as that  term is  defined at  48 C.F.R. 2.101 (OCT 1995),
//     consisting  of "commercial  computer  software"  and  "commercial
//     computer  software  documentation,"  as such  terms  are  used in
//     48 C.F.R. 12.212 (SEPT 1995)  and is provided to the U.S. Govern-
//     ment only as  a commercial end item.   Consistent with  48 C.F.R.
//     12.212 and  48 C.F.R. 227.7202-1 through  227.7202-4 (JUNE 1995),
//     all U.S. Government End Users  acquire the source code  with only
//     those rights set forth herein.
//
// **************************************************************************
//
//  Module: nvSurf.h
//        Prototypes and definitions for nvSurf.cpp
//
//  History:
//        Craig Duttweiler      bertrem         17Aug99         created
//
// **************************************************************************

#ifndef __NV_SURF_H_
#define __NV_SURF_H_

DWORD            nvCreateSystemMemorySurface (LPDDRAWI_DDRAWSURFACE_LCL pDDSLcl);
DWORD            nvDeleteSystemMemorySurface (LPDDRAWI_DDRAWSURFACE_LCL pDDSLcl);

DWORD __stdcall  nvCreateSurfaceEx (LPDDHAL_CREATESURFACEEXDATA);

void             nvHWLockTextures   (PNVD3DCONTEXT);
void             nvHWUnlockTextures (PNVD3DCONTEXT);
void             nvHWLockStreams    (PNVD3DCONTEXT pContext, DWORD dwCount);
void             nvHWUnlockStreams  (PNVD3DCONTEXT pContext, DWORD dwCount);

#endif  // __NV_SURF_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\ddraw\common\inc\nvSurface.h ===
// **************************************************************************
//
//       Copyright 1993-1999 NVIDIA, Corporation.  All rights reserved.
//
//     NOTICE TO USER:   The source code  is copyrighted under  U.S. and
//     international laws.  Users and possessors of this source code are
//     hereby granted a nonexclusive,  royalty-free copyright license to
//     use this code in individual and commercial software.
//
//     Any use of this source code must include,  in the user documenta-
//     tion and  internal comments to the code,  notices to the end user
//     as follows:
//
//       Copyright 1993-1999 NVIDIA, Corporation.  All rights reserved.
//
//     NVIDIA, CORPORATION MAKES NO REPRESENTATION ABOUT THE SUITABILITY
//     OF  THIS SOURCE  CODE  FOR ANY PURPOSE.  IT IS  PROVIDED  "AS IS"
//     WITHOUT EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORPOR-
//     ATION DISCLAIMS ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,
//     INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY, NONINFRINGE-
//     MENT,  AND FITNESS  FOR A PARTICULAR PURPOSE.   IN NO EVENT SHALL
//     NVIDIA, CORPORATION  BE LIABLE FOR ANY SPECIAL,  INDIRECT,  INCI-
//     DENTAL, OR CONSEQUENTIAL DAMAGES,  OR ANY DAMAGES  WHATSOEVER RE-
//     SULTING FROM LOSS OF USE,  DATA OR PROFITS,  WHETHER IN AN ACTION
//     OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,  ARISING OUT OF
//     OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOURCE CODE.
//
//     U.S. Government  End  Users.   This source code  is a "commercial
//     item,"  as that  term is  defined at  48 C.F.R. 2.101 (OCT 1995),
//     consisting  of "commercial  computer  software"  and  "commercial
//     computer  software  documentation,"  as such  terms  are  used in
//     48 C.F.R. 12.212 (SEPT 1995)  and is provided to the U.S. Govern-
//     ment only as  a commercial end item.   Consistent with  48 C.F.R.
//     12.212 and  48 C.F.R. 227.7202-1 through  227.7202-4 (JUNE 1995),
//     all U.S. Government End Users  acquire the source code  with only
//     those rights set forth herein.
//
// **************************************************************************

#ifndef _nvSurface_h
#define _nvSurface_h

#ifndef __cplusplus
#error This file requires a C++ compiler
#endif

extern DWORD g_adwSurfaceContextDMA[9];

//---------------------------------------------------------------------------

// class CSimpleSurface
//
// simple surface object
//  an instance will encapsulate a linear chunk of memory in any memory space.
//  it also contains HW specifics needed for HW access.
//  it is not very smart.

class CSimpleSurface
{
    // constants
public:
    enum
    {
        // used to specify where we want to allocate a surface (or'ed together)
        // or where it's currently allocated
        HEAP_LOCATION_MASK      = 0x0000001f,   // surface location - preserve order
        HEAP_VID                = 0x01,
        HEAP_AGP                = 0x02,
        HEAP_PCI                = 0x04,
        HEAP_SYS                = 0x08,
        HEAP_DYNSYS             = 0x18,
        HEAP_DYNSYSBIT          = 0x10,
        HEAP_ANYWHERE           = HEAP_VID | HEAP_AGP | HEAP_PCI | HEAP_SYS | HEAP_DYNSYS,
        HEAP_NOWHERE            = 0x0,

        FLAG_UPTODATE           = 0x00000100,   // surface data is up to date (can be used)
        FLAG_RENDERTARGET       = 0x00000200,   // surface is a render target
        FLAG_ZBUFFER            = 0x00000400,   // surface is a zbuffer
        FLAG_DONOTOWNMEMORY     = 0x00000800,   // memory management is done by somebody else (not self)
        FLAG_TILED              = 0x00001000,   // surface was allocated in tiled memory
        FLAG_SWIZZLED           = 0x00002000,   // surface is a swizzled (used by nvSetRenderTargetDX7)
        FLAG_available          = 0x00004000,
        FLAG_HASALPHA           = 0x00008000,   // surface format has alpha
        FLAG_ISDXT              = 0x00010000,   // surface format is DXT
#ifdef  STEREO_SUPPORT
        FLAG_STEREO             = 0x00020000,   // surface is stereo
        FLAG_NOTREAL            = 0x00040000,   // surface is stereo
#endif  //STEREO_SUPPORT

        // original lock parameters
        LOCK_NORMAL             = 0,            // normal access. do not rename
        LOCK_RENAME             = 1,            // rename if allowed
        LOCK_RENAME_COPY        = 3,            // rename if allowed and also copy contents forward

        LOCK_READ,                 //permissions
        LOCK_WRITE,

        LOCKED_NOT=0,               // for lock states
        LOCKED_READ=1,
        LOCKED_WRITE=2,

        // allocation flags
        ALLOCATE_SIMPLE         = 0x00000001,
        ALLOCATE_TILED          = 0x00000002,
        ALLOCATE_AS_ZBUFFER_UNC = 0x00000010,   // uncompressed z-buffer
        ALLOCATE_AS_ZBUFFER_CMP = 0x00000020,   // compressed z-buffer
        ALLOCATE_AS_ZBUFFER     = 0x00000030,   // any z format
		ALLOCATE_AS_STEREO		= 0x00000040	// stereo surface
    };

    // members
protected:
//bank
    DWORD      m_dwAddress;       // surface address [absolute]
    DWORD      m_dwOffset;        // surface offset [depends on dma context]
    DWORD      m_dwFormat;
    DWORD      m_dwBPP;           // bytes per pixel
    DWORD      m_dwBPPRequested;  // what did the app originally ask for? (not necessarily what was granted)
    DWORD      m_dwWidth;
    DWORD      m_dwHeight;        // height = 1 for vertex buffers, etc
    DWORD      m_dwDepth;         // depth = 1 for vertex buffers, etc
    DWORD      m_dwMultiSampleBits;   // number of samples per pixel
//bank
    DWORD      m_dwPitch;         // pitch = size for vertex buffers, etc.
    DWORD      m_dwSlicePitch;    // pitch of 2D slice for volume textures
    DWORD      m_dwFourCC;        // fourCC code (0 if not a fourCC surface)
    DWORD      m_dwFlags;         // flags
    DWORD      m_dwRetireDate;    // date that HW access retires
    CNvObject *m_pWrapperObject;
    DWORD      m_dwUsedMin;       // supertri only
    DWORD      m_dwUsedMax;       // supertri only
//bank
    DWORD      m_dwAllocFlags;    // our allocation flags (for debug purposes)
#ifdef  DEBUG_SURFACE_PLACEMENT
    DWORD      m_dwRMAllocFlags;  // Resman alloc flags (for debug purposes
#endif
#ifdef  STEREO_SUPPORT
    DWORD      m_dwAddressRight;  // right eye surface address [absolute]
    DWORD      m_dwOffsetRight;   // right eye surface offset [depends on dma context]
    DWORD      _dummy[5];
#else
    DWORD      _dummy[7];
#endif  //STEREO_SUPPORT
//bank

    // inline helper methods
public:
    inline BOOL  isValid           (void)         const { return m_dwAddress != 0; }
    inline BOOL  hwCanRead         (void)         const { return (m_dwFlags & HEAP_LOCATION_MASK) != HEAP_SYS; }
    inline BOOL  hwCanWrite        (void)         const { return (m_dwFlags & HEAP_LOCATION_MASK) == HEAP_VID; }
    inline BOOL  isReadCached      (void)         const { return (m_dwFlags & HEAP_LOCATION_MASK) >= HEAP_PCI; }
    inline BOOL  isWriteCached     (void)         const { return (m_dwFlags & HEAP_LOCATION_MASK) >= HEAP_PCI; }
    inline BOOL  isWriteCombined   (void)         const { return (m_dwFlags & HEAP_LOCATION_MASK) <= HEAP_AGP; }

    inline DWORD getSize           (void)         const { return (m_dwPitch * m_dwHeight); }
    inline DWORD getContextDMA     (void)         const { return g_adwSurfaceContextDMA[m_dwFlags & HEAP_LOCATION_MASK]; }
    inline DWORD getHeapLocation   (void)         const { return m_dwFlags & HEAP_LOCATION_MASK; }
    inline DWORD getOffset         (void)         const { return m_dwOffset;  }
    // Used by updateCachedValues in CVertexBuffer to mainatin a cached copy of the flags.
    // It's only added in the right places for Vertex Buffers, as well.
    inline DWORD getFlags          (void)         const { return m_dwFlags; }

    // this should only be used in DX6 DestroySurface32 to restore the surface address of the render target
    // the surface must be in video memory only
    inline void  setAddress        (DWORD dwAddress)    { m_dwAddress = dwAddress; m_dwOffset = dwAddress - pDriverData->BaseAddress; }

    inline DWORD getAddress        (void)         const { return m_dwAddress; }
#ifdef WINNT
    inline DWORD getfpVidMem       (void)         const { return ((getHeapLocation() & (HEAP_VID | HEAP_AGP)) ? m_dwOffset : m_dwAddress); }
#else
    inline DWORD getfpVidMem       (void)         const { return m_dwAddress; }
#endif // WINNT
    inline void  setPitch          (DWORD dwP)          { m_dwPitch = dwP; }
    inline DWORD getPitch          (void)         const { return (m_dwPitch); }

    inline void  setSlicePitch     (DWORD dwSP)         { m_dwSlicePitch = dwSP; }
    inline DWORD getSlicePitch     (void)         const { return (m_dwSlicePitch); }

    inline void  setWidth          (DWORD dwW)          { m_dwWidth = dwW; }
    inline DWORD getWidth          (void)         const { return (m_dwWidth); }

    inline void  setHeight         (DWORD dwH)          { m_dwHeight = dwH; }
    inline DWORD getHeight         (void)         const { return (m_dwHeight); }

    inline void  setDepth          (DWORD dwD)          { m_dwDepth = dwD; }
    inline DWORD getDepth          (void)         const { return (m_dwDepth); }

    inline void  setMultiSampleBits(DWORD dwM)          { m_dwMultiSampleBits = dwM; }
    inline DWORD getMultiSampleBits(void)         const { return (m_dwMultiSampleBits); }

    inline void  tagUpToDate       (void)               { m_dwFlags |=  FLAG_UPTODATE; }
    inline void  tagOutOfDate      (void)               { m_dwFlags &= ~FLAG_UPTODATE; }
    inline BOOL  isUpToDate        (void)         const { return m_dwFlags & FLAG_UPTODATE; }

    inline void  tagAsLinear       (void)               { m_dwFlags &= ~FLAG_SWIZZLED; }
    inline void  tagAsSwizzled     (void)               { m_dwFlags |=  FLAG_SWIZZLED; } // used to tag render targets only
    inline BOOL  isSwizzled        (void)         const { return m_dwFlags & FLAG_SWIZZLED; }

    inline void  tagAsZBuffer      (void)               { m_dwFlags |=  FLAG_ZBUFFER; }
    inline BOOL  isZBuffer         (void)         const { return m_dwFlags & FLAG_ZBUFFER; }

    inline void  tagAsOwner        (void)               { m_dwFlags &= ~FLAG_DONOTOWNMEMORY; }
    inline void  tagNotAsOwner     (void)               { m_dwFlags |=  FLAG_DONOTOWNMEMORY; }

    inline void  tagAsDynSys       (void)               { m_dwFlags &= ~HEAP_DYNSYSBIT; }
    inline void  tagNotAsDynSys    (void)               { m_dwFlags |=  HEAP_DYNSYSBIT; }

    inline BOOL  isOwner           (void)         const { return (m_dwFlags & FLAG_DONOTOWNMEMORY) == 0; }


    inline DWORD getRetireDate     (void)         const { return m_dwRetireDate; }
           BOOL  isBusy            (void)         const;
           void  reset             (void);

           void  own               (DWORD dwAddress, DWORD dwPitch, DWORD dwHeight,
                                    DWORD dwHeapLocation, BOOL bOwnMemory);
           void  disown            (void);

    // formatted surface helpers
    inline void       setWrapper       (CNvObject *nvO)         { m_pWrapperObject = nvO; }
    inline CNvObject* getWrapper       (void)             const { return (m_pWrapperObject); }

    inline void       setBPP           (DWORD dwBPP)            { m_dwBPP = dwBPP; }
    inline DWORD      getBPP           (void)             const { return (m_dwBPP); }

    inline void       setBPPRequested  (DWORD dwBPPReq)         { m_dwBPPRequested = dwBPPReq; }
    inline DWORD      getBPPRequested  (void)             const { return (m_dwBPPRequested); }

    inline void       setFormat        (DWORD dwFmt)            { m_dwFormat = dwFmt;
                                                                  // note: determination of alpha's existence in palettized
                                                                  // textures is deferred until a palette is set
                                                                  if ((dwFmt == NV_SURFACE_FORMAT_A1R5G5B5)       ||
                                                                      (dwFmt == NV_SURFACE_FORMAT_A4R4G4B4)       ||
                                                                      (dwFmt == NV_SURFACE_FORMAT_A8R8G8B8)       ||
                                                                      (dwFmt == NV_SURFACE_FORMAT_X1A7R8G8B8)     ||
                                                                      (dwFmt == NV_SURFACE_FORMAT_DXT1_A1R5G5B5)  ||
                                                                      (dwFmt == NV_SURFACE_FORMAT_DXT23_A8R8G8B8) ||
                                                                      (dwFmt == NV_SURFACE_FORMAT_DXT45_A8R8G8B8))
                                                                  {
                                                                      m_dwFlags |= FLAG_HASALPHA;
                                                                  }
                                                                  else
                                                                  {
                                                                      m_dwFlags &= ~FLAG_HASALPHA;
                                                                  }
                                                                }
    inline DWORD      getFormat        (void)             const { return (m_dwFormat); }

    inline void       setFourCC        (DWORD dw4cc)            { m_dwFourCC = dw4cc;
                                                                  if (((dw4cc == FOURCC_DXT1) ||
                                                                       (dw4cc == FOURCC_DXT2) ||
                                                                       (dw4cc == FOURCC_DXT3) ||
                                                                       (dw4cc == FOURCC_DXT4) ||
                                                                       (dw4cc == FOURCC_DXT5)))
                                                                  {
                                                                      m_dwFlags |= FLAG_ISDXT;
                                                                  }
                                                                  else
                                                                  {
                                                                      m_dwFlags &= ~FLAG_ISDXT;
                                                                  }
                                                                }
    inline DWORD      getFourCC        (void)             const { return m_dwFourCC; }

    inline BOOL       isFourCC         (void)             const { return m_dwFourCC != 0; }
    inline BOOL       isDXT            (void)             const { return (m_dwFlags & FLAG_ISDXT) == FLAG_ISDXT; }

    inline void       tagHasAlpha      (void)                   { m_dwFlags |=  FLAG_HASALPHA; }
    inline void       tagHasNoAlpha    (void)                   { m_dwFlags &= ~FLAG_HASALPHA; }
    inline BOOL       hasAlpha         (void)             const { return (m_dwFlags & FLAG_HASALPHA) == FLAG_HASALPHA; }

    inline BOOL       hasStencil       (void)             const { return m_dwFormat == NV_SURFACE_FORMAT_Z24S8; }
    
    inline DWORD      getAllocFlags    (void)             const { return m_dwAllocFlags; }
#ifdef  DEBUG_SURFACE_PLACEMENT
    inline DWORD      getRMAllocFlags  (void)             const { return m_dwRMAllocFlags; }
#endif

    // helpers
public:
    inline void hwLock    (DWORD dwAccess) {}   // aquire hw access
           void hwUnlock  (void);               // release hw access
           void cpuLock   (DWORD dwAccess);     // aquire cpu access
    inline void cpuUnlock (void) {}             // release cpu access

    void swap (CSimpleSurface* pSurface);         // swap surface pointers

    inline DWORD modifyDDCaps (DWORD dwCaps) const
    {
        // clear all flags
        dwCaps &= ~(DDSCAPS_VIDEOMEMORY    |
                    DDSCAPS_LOCALVIDMEM    |
                    DDSCAPS_NONLOCALVIDMEM |
                    DDSCAPS_SYSTEMMEMORY);
        // put back the flags we want
        switch (m_dwFlags & HEAP_LOCATION_MASK)
        {
            case HEAP_VID:
                dwCaps |= (DDSCAPS_VIDEOMEMORY | DDSCAPS_LOCALVIDMEM);
                break;
            case HEAP_AGP:
            case HEAP_PCI:
                dwCaps |= (DDSCAPS_VIDEOMEMORY | DDSCAPS_NONLOCALVIDMEM);
                break;
            // DDRAW just hates it if you specify the DDSCAPS_SYSTEMMEMORY flag. basically it will
            //  never call back to free surfaces. Ugghh.
            // believe it or not, it actually want the VidMem flag set!
            default:
                dwCaps |= (DDSCAPS_VIDEOMEMORY);
                break;
        }
        // return the new flags
        return (dwCaps);
    }

    // construction
public:
    BOOL create   (DWORD dwPitch, DWORD dwHeight, DWORD dwDepth, DWORD dwBPPGranted,
                   DWORD dwAllowedHeaps, DWORD dwPreferredHeap,
                   DWORD dwAllocFlags
#ifdef CAPTURE
                  ,DWORD dwUsageKind  // CAPTURE_SURFACE_KIND_xxx
#endif
                   );

    BOOL create   (const CSimpleSurface* pTemplateSurface
#ifdef CAPTURE
                  ,DWORD dwUsageKind  // CAPTURE_SURFACE_KIND_xxx
#endif
                   );

    // formatted surface create
    BOOL create   (CNvObject *pWrapperObject, DWORD dwFormat,
                   DWORD dwWidth, DWORD dwHeight, DWORD dwDepth, DWORD dwMultiSampleBits,
                   DWORD dwBPPRequested, DWORD dwBPPGranted,
                   DWORD dwPitch, DWORD dwAllowedHeaps, DWORD dwPreferredHeap,
                   DWORD dwAllocFlags
#ifdef CAPTURE
                  ,DWORD dwUsageKind  // CAPTURE_SURFACE_KIND_xxx
#endif
                   );

    BOOL recreate (DWORD dwBPP);

    BOOL growBy   (DWORD dwDelta, BOOL bPreserveContents);

    BOOL destroy  (void);


#ifdef  STEREO_SUPPORT
    inline void     tagAsStereo     (void)       { m_dwFlags |=  FLAG_STEREO; }
    inline void     tagNotAsStereo  (void)       { m_dwFlags &= ~FLAG_STEREO; }
    inline void     tagNotReal      (void)       { m_dwFlags |=  FLAG_NOTREAL; }
    inline DWORD    getAddressRight (void) const { return m_dwAddressRight;  }
    inline DWORD    getOffsetRight  (void) const { return m_dwOffsetRight;  }
    inline BOOL     isStereo        (void) const { return m_dwFlags & FLAG_STEREO; }
    BOOL            createStereo    (void);
    BOOL            destroyStereo   (void);
#endif  //STEREO_SUPPORT

    inline CSimpleSurface (void)
    {
#ifdef DEBUG
        memset (this,0xcc,sizeof(*this));
#endif
        m_dwAddress = 0;
        m_dwWidth   = 0;
        m_dwHeight  = 0;
        m_dwDepth   = 0;
        m_dwMultiSampleBits = 0;
        m_dwPitch   = 0;
        m_dwFlags   = 0;
        m_dwFourCC  = 0;
        m_dwUsedMin = ~0;
        m_dwUsedMax = 0;
        m_pWrapperObject = 0; //HH
#ifdef  STEREO_SUPPORT
        m_dwAddressRight = 0;
        m_dwOffsetRight = 0;
#endif  //STEREO_SUPPORT
    }

    // assumed to be init with zeroes
    inline ~CSimpleSurface (void)
    {
        if (m_dwAddress)
        {
            destroy();
        }
    }
};

//---------------------------------------------------------------------------

// class CComplexSurface
//
// wrapper for simple surfaces that reduces CPU blocking when accessed.
//  potentially consumes tons of memory.
// only useful for textures and vertex buffers.
// cannot be instanced by itself - you have to inherit and implement
//  abstract methods.

template<int cMax> class CComplexSurface
{
    // contants
public:
    enum
    {
    FLAG_RENAME     = 0x00000001,
    FLAG_RENAME_CALL        = 0x00000002,   // rename will call user function

        RENAME_DO_NOTHING       = 0,            // rename options
        RENAME_EXTERNAL         = 1,
    };

    // types
public:
    typedef BOOL (__stdcall *PCANRENAMEPROC)(void *pContext);
    typedef void (__stdcall *PRENAMEPROC)   (void *pContext,DWORD dwOldIndex,DWORD dwNewIndex);

    // members
protected:
//bank
    DWORD           m_dwActiveSurface;      // active one
    DWORD           m_dwPreviousSurface;    // last one used
    DWORD           m_dwTotalSurfaces;      // # in use
    DWORD           m_dwFlags;
    PCANRENAMEPROC  m_pfnCanRenameProc;
    PRENAMEPROC     m_pfnRenameProc;
    void           *m_pRenameContext;
    DWORD           _pad[1];
//bank
    CSimpleSurface  m_aSurface[cMax];       // all surfaces

    // inline helpers
public:
    inline CSimpleSurface* getSurface         (DWORD dwIndex)       { return &m_aSurface[dwIndex]; }
    inline CSimpleSurface* getActiveSurface   (void)                { return &m_aSurface[m_dwActiveSurface]; }
    inline CSimpleSurface* getPreviousSurface (void)                { return &m_aSurface[m_dwPreviousSurface]; }
    inline DWORD           getTotalSurfaces   (void)          const { return m_dwTotalSurfaces; }

    inline void      reset              (void)                { for (DWORD i = getTotalSurfaces(),j = 0; i; j++,i--) m_aSurface[j].reset(); }

           void      tagRenameEnable    (DWORD           dwRenameType,
                                         DWORD           dwPreAllocCount  = 1,  // create MUST have been called before you can set this to more than 1
                                         PCANRENAMEPROC  pfnCanRenameProc = NULL,
                                         PRENAMEPROC     pfnRenameProc    = NULL,
                                         void           *pContext         = NULL);
    inline void      tagRenameDisable   (void)                { m_dwFlags &= ~FLAG_RENAME; }
    inline BOOL      canRename          (void)          const { return m_dwFlags & FLAG_RENAME; }

           void      forceRename        (DWORD dwNewSurface,DWORD dwNewAddress);

    // helpers
public:
    inline void hwLock    (DWORD dwAccess) { getActiveSurface()->hwLock (dwAccess); }
    inline void hwUnlock  (void)           { getActiveSurface()->hwUnlock(); }
           void cpuLock   (DWORD dwAccess);
    inline void cpuUnlock (void)           { getActiveSurface()->cpuUnlock(); }

    // construction
public:
    BOOL create  (CNvObject *pWrapper, DWORD dwSize, DWORD dwAllowedHeaps, DWORD dwPreferredHeap
#ifdef CAPTURE
                 ,DWORD dwUsageKind  // CAPTURE_SURFACE_KIND_xxx
#endif
                  );
    BOOL own     (DWORD dwAddress, DWORD dwPitch, DWORD dwLogHeight, DWORD dwHeapLocation, BOOL bOwnMemory);
    BOOL disown  (void);
    BOOL swap    (CComplexSurface *pCSurf);
    BOOL destroy (void);

    CComplexSurface (void) { m_dwActiveSurface = m_dwTotalSurfaces = m_dwFlags = 0; }
};

#endif // _nvSurface_h
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\ddraw\common\inc\nvSwiz.h ===
/***************************************************************************\
|*                                                                           *|
|*       Copyright 1993-1999 NVIDIA, Corporation.  All rights reserved.      *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.  Users and possessors of this source code are     *|
|*     hereby granted a nonexclusive,  royalty-free copyright license to     *|
|*     use this code in individual and commercial software.                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*       Copyright 1993-1999 NVIDIA, Corporation.  All rights reserved.      *|
|*                                                                           *|
|*     NVIDIA, CORPORATION MAKES NO REPRESENTATION ABOUT THE SUITABILITY     *|
|*     OF  THIS SOURCE  CODE  FOR ANY PURPOSE.  IT IS  PROVIDED  "AS IS"     *|
|*     WITHOUT EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORPOR-     *|
|*     ATION DISCLAIMS ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,     *|
|*     INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY, NONINFRINGE-     *|
|*     MENT,  AND FITNESS  FOR A PARTICULAR PURPOSE.   IN NO EVENT SHALL     *|
|*     NVIDIA, CORPORATION  BE LIABLE FOR ANY SPECIAL,  INDIRECT,  INCI-     *|
|*     DENTAL, OR CONSEQUENTIAL DAMAGES,  OR ANY DAMAGES  WHATSOEVER RE-     *|
|*     SULTING FROM LOSS OF USE,  DATA OR PROFITS,  WHETHER IN AN ACTION     *|
|*     OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,  ARISING OUT OF     *|
|*     OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOURCE CODE.     *|
|*                                                                           *|
|*     U.S. Government  End  Users.   This source code  is a "commercial     *|
|*     item,"  as that  term is  defined at  48 C.F.R. 2.101 (OCT 1995),     *|
|*     consisting  of "commercial  computer  software"  and  "commercial     *|
|*     computer  software  documentation,"  as such  terms  are  used in     *|
|*     48 C.F.R. 12.212 (SEPT 1995)  and is provided to the U.S. Govern-     *|
|*     ment only as  a commercial end item.   Consistent with  48 C.F.R.     *|
|*     12.212 and  48 C.F.R. 227.7202-1 through  227.7202-4 (JUNE 1995),     *|
|*     all U.S. Government End Users  acquire the source code  with only     *|
|*     those rights set forth herein.                                        *|
|*                                                                           *|
 \***************************************************************************/
#ifndef _nvSwiz_h
#define _nvSwiz_h

#ifdef __cplusplus
extern "C"
{
#else
#error C++ Compiler required
#endif

//
// forward declarations
//
class CTexture;

/*
 * exports
 */

// cpu or gpu swizzle routines
void nvSwizBlt_lin2swz (PNVD3DCONTEXT pContext, 
                        DWORD dwSrcAddr, DWORD dwSrcPitch, DWORD dwSrcSlicePitch,
                        DWORD dwSrcX,DWORD dwSrcY,DWORD dwSrcZ,
                        CTexture *pDstTexture, DWORD dwDstAddr,
                        DWORD dwDstX, DWORD dwDstY, DWORD dwDstZ,
                        DWORD dwDstLogWidth, DWORD dwDstLogHeight, DWORD dwDstLogDepth,
                        DWORD dwWidth, DWORD dwHeight, DWORD dwDepth,
                        DWORD dwBPP);

// cpu swizzle routines
void nvSwizBlt_cpu_lin2lin (DWORD dwSrcAddr,DWORD dwSrcPitch,DWORD dwSrcX,DWORD dwSrcY,
                            DWORD dwDstAddr,DWORD dwDstPitch,DWORD dwDstX,DWORD dwDstY,
                            DWORD dwWidth,DWORD dwHeight,DWORD dwBPP);

void nvSwizBlt_cpu_lin2swz (DWORD dwSrcAddr,DWORD dwSrcPitch,DWORD dwSrcX,DWORD dwSrcY,
                            DWORD dwDstAddr,DWORD dwDstX,DWORD dwDstY,DWORD dwDstLogWidth,DWORD dwDstLogHeight,
                            DWORD dwWidth,DWORD dwHeight,DWORD dwBPP);

void nvSwizBlt_cpu_swz2lin (DWORD dwSrcAddr,DWORD dwSrcX,DWORD dwSrcY,DWORD dwSrcLogWidth,DWORD dwSrcLogHeight,
                            DWORD dwDstAddr,DWORD dwDstPitch,DWORD dwDstX,DWORD dwDstY,
                            DWORD dwWidth,DWORD dwHeight,DWORD dwBPP);

void nvSwizBlt_cpu_swz2swz (DWORD dwSrcAddr,DWORD dwSrcX,DWORD dwSrcY,DWORD dwSrcLogWidth,DWORD dwSrcLogHeight,
                            DWORD dwDstAddr,DWORD dwDstX,DWORD dwDstY,DWORD dwDstLogWidth,DWORD dwDstLogHeight,
                            DWORD dwWidth,DWORD dwHeight,DWORD dwBPP);

// gpu swizzle routines - todo
/*
void nvSwizBlt_gpu_lin2lin
*/
void nvSwizBlt_gpu_lin2swz (DWORD dwSrcOffset,DWORD dwSrcHeap,DWORD dwSrcPitch,DWORD dwSrcX,DWORD dwSrcY,
                            DWORD dwDstOffset,DWORD dwDstX,DWORD dwDstY,DWORD dwDstLogWidth,DWORD dwDstLogHeight,
                            DWORD dwWidth,DWORD dwHeight,DWORD dwFormat);

/*
void nvSwizBlt_gpu_swz2lin
*/
/*
void nvSwizBlt_gpu_swz2swz
*/

//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////////////////////

#define PT_8888     0
#define PT_X888     1
#define PT_4444     2
#define PT_1555     3
#define PT_X555     4
#define PT_565      5

////////////////////////////////////////////////////////////////////////////////////////

class CPaletteBuilder
{
    //
    // create palette
    //
public:
    BOOL initTable  (DWORD dwPalType);
    BOOL buildTable (DWORD dwPalType,DWORD dwSource,DWORD dwWidth,DWORD dwHeight);
    BOOL palettize  (DWORD dwPalType,BYTE *pbPalette);
    BOOL apply      (DWORD dwPalType,DWORD dwSource,DWORD dwDest,DWORD dwWidth,DWORD dwLogWidth,DWORD dwHeight,DWORD dwLogHeight);
    BOOL freeTable  (DWORD dwPalType);

    //
    // depalettize
    //
public:
    BOOL depalettizeInPlace      (DWORD dwPalType,DWORD dwSource,DWORD dwDest,DWORD dwWidth,DWORD dwHeight,DWORD *pPalette);
    BOOL depalettizeAndDeswizzle (DWORD dwPalType,DWORD dwSource,DWORD dwDest,DWORD dwWidth,DWORD dwLogWidth,DWORD dwHeight,DWORD dwLogHeight,DWORD dwDeviceMemPaletteAddr);
};

#ifdef __cplusplus
}
#endif

#endif // _nvSwiz_h
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\ddraw\common\inc\nvSwitches.h ===
// **************************************************************************
//
//       Copyright 1993-1999 NVIDIA, Corporation.  All rights reserved.
//
//     NOTICE TO USER:   The source code  is copyrighted under  U.S. and
//     international laws.  Users and possessors of this source code are
//     hereby granted a nonexclusive,  royalty-free copyright license to
//     use this code in individual and commercial software.
//
//     Any use of this source code must include,  in the user documenta-
//     tion and  internal comments to the code,  notices to the end user
//     as follows:
//
//       Copyright 1993-1999 NVIDIA, Corporation.  All rights reserved.
//
//     NVIDIA, CORPORATION MAKES NO REPRESENTATION ABOUT THE SUITABILITY
//     OF  THIS SOURCE  CODE  FOR ANY PURPOSE.  IT IS  PROVIDED  "AS IS"
//     WITHOUT EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORPOR-
//     ATION DISCLAIMS ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,
//     INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY, NONINFRINGE-
//     MENT,  AND FITNESS  FOR A PARTICULAR PURPOSE.   IN NO EVENT SHALL
//     NVIDIA, CORPORATION  BE LIABLE FOR ANY SPECIAL,  INDIRECT,  INCI-
//     DENTAL, OR CONSEQUENTIAL DAMAGES,  OR ANY DAMAGES  WHATSOEVER RE-
//     SULTING FROM LOSS OF USE,  DATA OR PROFITS,  WHETHER IN AN ACTION
//     OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,  ARISING OUT OF
//     OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOURCE CODE.
//
//     U.S. Government  End  Users.   This source code  is a "commercial
//     item,"  as that  term is  defined at  48 C.F.R. 2.101 (OCT 1995),
//     consisting  of "commercial  computer  software"  and  "commercial
//     computer  software  documentation,"  as such  terms  are  used in
//     48 C.F.R. 12.212 (SEPT 1995)  and is provided to the U.S. Govern-
//     ment only as  a commercial end item.   Consistent with  48 C.F.R.
//     12.212 and  48 C.F.R. 227.7202-1 through  227.7202-4 (JUNE 1995),
//     all U.S. Government End Users  acquire the source code  with only
//     those rights set forth herein.
//
// **************************************************************************
//
//  Module: nvSwitches.h
//     compile-time switches used in the D3D driver
//
// **************************************************************************
//
//  History:
//       Craig Duttweiler    (bertrem)   15Mar00     created
//
// **************************************************************************

#ifndef NVDD32
#define NVDD32                              // so shared files know what we are talking about
#endif

//---------------------------------------------------------------------------
// general d3d and external functionality
//---------------------------------------------------------------------------

//#define DO_NOT_SUPPORT_VERTEX_BUFFERS       // define to disable d3d vb exports (we use the internal vb still)
#define HOSURF_ENABLE               // enable HOS support
//#define DX7PROPER                           // emit proper dx7 usage
//#define TEX_MANAGE                          // enable texture management
//#define MULTISTAGE_BUMPMAPPING              // enable code to detect special 4- and 8-stage TSS cases
#define CELSIUS_NVCOMBINER                  // enable special NV multi-stage combiner settings in celsius
#ifndef WINNT
#define STEREO_SUPPORT                      // enable stereo support
#endif

//---------------------------------------------------------------------------
// Release 20 functionality
//---------------------------------------------------------------------------

#ifdef WINNT
#define NV_AGP       // NVIDIA managed AGP (does not request AGP heap from MS, required for winXP dual-view)
#endif

//#define REL20

#ifdef REL20

//#define KPFS
//#define LPC_OPT

#endif // REL20



//---------------------------------------------------------------------------
// internal functionality
//---------------------------------------------------------------------------

#define HWFLIP                              // enable use of NV15 ff. HW flip
//#define KELVIN_SEMAPHORES                   // employ kelvin-style semaphores for HW flipping
//#define KELVIN_SEMAPHORES2                  // employ kelvin-style semaphores in place of ref counts / ref count maps
#define SUPERTRI                            // enable super triangle processing on real fast machines
#define CELSIUS_TEX_MATRIX_HACK             // enable workaround for broken texture matrix in nv10
#define ALPHA_CULL 3
//#define ALTERNATE_STENCIL_MODE
//#define SPOOF_KELVIN                        // pretend HW has kelvin support even tho it doesn't
// Uncomment the following line for a ~10-15% gain on DX7 on Win2K
//#define WIN2K_DX7OPT                        // enable to copy sysmem VB's to AGP for Windows 2000
#define KELVIN_CLEAR                        // clear via the kelvin class rather than through 2d classes
#define KELVIN_ILC                          // build kelvin inner loops
#define KELVIN_INLINE_REUSE                 // enable inline primitive reuse for Kelvin innerloops
//#define PROFILE_INDEX
//#define SW_WC
//#define FORCE_CT 1                          // 0 = force CT off, 1 = force CT on
//#define DISABLE_Z_COMPR                     // Disable Z compression
#define SYSVB2AGP 1                         // 0 = disable copy of system memory VB's to AGP 1 = enable.
//#define TEXFORMAT_CRD                       // improved texture format export mechanism
#define STATE_OPTIMIZE 0
#define CHECK_DUP_MATRIX 0
//#define SPOOF_ALPHA                           //create an A8R8G8B8 surface instead of an X8R8G8B8. workaround for a ms issue.
// SPOOF_ALPHA causes problems in 3DWinBench200 or WHQL
#define THREE_STAGE_ALPHA_SUPPORT              // limited three-stage alpha support

//---------------------------------------------------------------------------
// debugging and instrumentation
//---------------------------------------------------------------------------

//#define FORCE_NV10_AS_NV5                   // make NV10 be treated like an NV5
//#define VTUNE_SUPPORT
//#define INSTRUMENT_INNER_LOOPS              // capture MB/S data for inner loops
//#define NV_DISASM                           // compile with push buffer disassembling code
//#define TEX_MANAGE_TEST                     // stress the texture manager by forcing lots of allocation failures, etc.
//#define NV_NULL_DRIVER_DYNAMIC              // allowes dynamically to null out particular drawing primitives.

// null driver flavors
//#define NV_NULL_DRIVER                      // do no work in driver
//#define NV_NULL_HW_DRIVER                   // do work in driver, copy verts (if needed) but dont render geometry (hw will not T&L or rasterize - will set state)
//#define NV_NULL_FILL_DRIVER                 // zero sized triangles
//#define NV_NULL_LIGHTS_DRIVER               // turn of HW lighting
//#define NV_NULL_TEXTURE_DRIVER              // suppress all texture ops (except alloc/free)
//#define NV_NULL_BLEND                       // disable texture and alpha blending
//#define NV_NULL_TEXTURES                    // disable all texturing operations (must also enable NV_NULL_BLEND)

// locutus
//#define NV_PROFILE_CPULOCK                  // LOCUTUS 1 -> CSimpleSurface::cpuLock profiling
//#define NV_PROFILE_PUSHER                   // LOCUTUS 1 -> push buffer profiling
//#define NV_PROFILE_CALLSTACK                // LOCUTUS 1 -> breakdown of time spend in different layers of call stack
//#define NV_PROFILE_DEFVB                    // LOCUTUS 1 -> defualt VB profile
//#define NV_PROFILE_COPIES                   // LOCUTUS 1 -> check major copy routines

// nvDP2Ops profiling
//#define NV_PROFILE_DP2OPS

// texture profiling
//#define NO_TEX_BLTS                         // Do not allow texture blits/downloads
//#define NO_TEX_SWZ                          // Allow texturing downloads, but do not allow swizzling (force linear)
//#define CNT_TEX                             // Count all texture downloads

// procedure instrumentation
//#define INSTRUMENT_ALL_CALLS                // time each and every dbgTraceXXX call (only works for !DEBUG)
#define IAC_THRESHOLD           10          // time in ms to exceed before logging

// capture file creation
//#define CAPTURE

//#define FORCE_INLINE_VERTICES               // force use of inline vertices
//#define CHECK_DEPTHS                        // check that transformed z's aren't outside [0...1].

//#define DEBUG_SURFACE_PLACEMENT

//---------------------------------------------------------------------------
// switch logic
//---------------------------------------------------------------------------

#if defined(NV_PROFILE_CPULOCK) || defined(NV_PROFILE_PUSHER) || defined(NV_PROFILE_CALLSTACK) || defined(NV_PROFILE_DEFVB) || defined(NV_PROFILE_COPIES)
#define NV_PROFILE
#endif

#if defined(STEREO_SUPPORT) && defined(DEBUG)
//#define PER_PRIMITIVE_SYNC
//#define NEW_FRONT_RENDER
#endif

#ifdef WINNT
#undef CAPTURE
#endif

#ifndef WINNT
#undef WIN2K_DX7OPT
#endif

#ifdef CHECK_DEPTHS
#define FORCE_INLINE_VERTICES
#endif

#ifndef TEXFORMAT_CRD
//#define HILO_SUPPORT_DX7          // Support HILO texture formats NVHS and NVHU via dx7
#define HILO_SUPPORT_DX8          // Support HILO texture formats NVHS and NVHU via dx8
//#define NVxn_SUPPORT_DX7
#define NVxn_SUPPORT_DX8
#define DXT_SUPPORT
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\ddraw\common\inc\nvTex.h ===
/***************************************************************************\
|*                                                                           *|
|*       Copyright 1993-1999 NVIDIA, Corporation.  All rights reserved.      *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.  Users and possessors of this source code are     *|
|*     hereby granted a nonexclusive,  royalty-free copyright license to     *|
|*     use this code in individual and commercial software.                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*       Copyright 1993-1999 NVIDIA, Corporation.  All rights reserved.      *|
|*                                                                           *|
|*     NVIDIA, CORPORATION MAKES NO REPRESENTATION ABOUT THE SUITABILITY     *|
|*     OF  THIS SOURCE  CODE  FOR ANY PURPOSE.  IT IS  PROVIDED  "AS IS"     *|
|*     WITHOUT EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORPOR-     *|
|*     ATION DISCLAIMS ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,     *|
|*     INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY, NONINFRINGE-     *|
|*     MENT,  AND FITNESS  FOR A PARTICULAR PURPOSE.   IN NO EVENT SHALL     *|
|*     NVIDIA, CORPORATION  BE LIABLE FOR ANY SPECIAL,  INDIRECT,  INCI-     *|
|*     DENTAL, OR CONSEQUENTIAL DAMAGES,  OR ANY DAMAGES  WHATSOEVER RE-     *|
|*     SULTING FROM LOSS OF USE,  DATA OR PROFITS,  WHETHER IN AN ACTION     *|
|*     OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,  ARISING OUT OF     *|
|*     OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOURCE CODE.     *|
|*                                                                           *|
|*     U.S. Government  End  Users.   This source code  is a "commercial     *|
|*     item,"  as that  term is  defined at  48 C.F.R. 2.101 (OCT 1995),     *|
|*     consisting  of "commercial  computer  software"  and  "commercial     *|
|*     computer  software  documentation,"  as such  terms  are  used in     *|
|*     48 C.F.R. 12.212 (SEPT 1995)  and is provided to the U.S. Govern-     *|
|*     ment only as  a commercial end item.   Consistent with  48 C.F.R.     *|
|*     12.212 and  48 C.F.R. 227.7202-1 through  227.7202-4 (JUNE 1995),     *|
|*     all U.S. Government End Users  acquire the source code  with only     *|
|*     those rights set forth herein.                                        *|
|*                                                                           *|
 \***************************************************************************/
#ifndef _nvTex_h
#define _nvTex_h

#ifndef __cplusplus
#error This file requires a C++ compiler
#endif

#include "nvUtil.h"

#define TOTAL_TEX_RENAME 8

#ifdef CNT_TEX
#define MAX_FRAME_CNT 5000
extern DWORD g_dwVidTexDL[], g_dwAgpTexDL[];
extern DWORD g_dwFrames;
#endif
//---------------------------------------------------------------------------

struct _def_nv_d3d_context;
typedef _def_nv_d3d_context *PNVD3DCONTEXT;

// class CTexture
//
// texture object

class CTexture
{
    // more flags
public:
    enum
    {
        FLAG_USERMIPLEVEL       = 0x80000000,   // this structure is part of a mip map chain (does not own surface)
        FLAG_PALETTIZED         = 0x40000000,   // texture is palettized
        FLAG_COMPRESSED         = 0x20000000,   // texture is compressed
        FLAG_CUBEMAP            = 0x10000000,   // texture is part of a cube map
        FLAG_VOLUMEMAP          = 0x08000000,   // texture is volumetric data
        FLAG_HASHANDLE          = 0x04000000,   // texture has a legacy handle (dx3,dx5)
        FLAG_MANAGED            = 0x02000000,   // app wants us to manage this texture
        FLAG_COLORKEY           = 0x01000000,   // has a color key
        FLAG_RENAMENOTCOPIED    = 0x00800000,   // set when a texture was just renamed and its contents is not copied over yet
        FLAG_SUBSURFDIRTY       = 0x00400000,   // a mip or cube map sub surface is dirty - force chain update in hwLock
        FLAG_AUTOPALETTIZED     = 0x00200000,   // texture is dynamically palettized by texture blit
        FLAG_UNPALETTIZED       = 0x00100000,   // flag that this serface was palettized and then converted back
    };

    // members
protected:
// bank
    CSimpleSurface                    m_surfLinear;
    CComplexSurface<TOTAL_TEX_RENAME> m_surfSwizzled;

// bank
    CTexture              *m_pBaseTexture;  // the root of the mipmap chain, or for cubemaps, the root of the +x chain. the root points to itself.
    DWORD                  m_dwLogWidth;
    DWORD                  m_dwLogHeight;
    DWORD                  m_dwLogDepth;
    DWORD                  m_dwMipMapCount;
    DWORD                  m_dwPriority;
    DWORD                  m_dwColorKey;
    DWORD                  m_dwFlags;

// bank
    DWORD                  m_dwAutoPaletteOffset; // offset to auto palette
    DWORD                  m_dwOriginalFormat;    // contains the original texture format (if auto palette converts it)

    // cube map data (common to all surfaces that are part of the same cube map)
    DWORD                  m_dwCubeMapSizeFacePadded;

    // we try to precompute and store as much HW state as possible
    DWORD                  m_dwNV056Control0;
    DWORD                  m_dwNV056Format;

#ifdef TEX_MANAGE
    // links in chains of textures used for texture management
    CTexture              *m_pNext;
    CTexture              *m_pPrev;
    PNVD3DCONTEXT          m_pContext; // the context in whose lists this texture is kept and with which it is
                                       // associated. we do our best to make these associations correctly, but
                                       // since textures exist outside of contexts, we're sometimes forced to
                                       // make arbitrary choices.
#endif

    // helpers
public:
    inline void            setBaseTexture      (CTexture *pTexture)       { m_pBaseTexture = pTexture; }
    inline CTexture*       getBaseTexture      (void)               const { return (m_pBaseTexture); }
    inline BOOL            isBaseTexture       (void)               const { return ((this==m_pBaseTexture) ? TRUE : FALSE); };

    inline void            setPriority         (DWORD dwPriority)         { m_dwPriority = dwPriority; }

    inline DWORD           getMipMapCount      (void)               const { return m_dwMipMapCount; }
    inline void            tagUserMipLevel     (void)                     { m_dwFlags |= FLAG_USERMIPLEVEL; }
    inline BOOL            isUserMipLevel      (void)               const { return ((m_dwFlags & FLAG_USERMIPLEVEL) == FLAG_USERMIPLEVEL); }

    inline void            tagPalettized       (void)                     { m_dwFlags |= FLAG_PALETTIZED; }
    inline BOOL            isPalettized        (void)               const { return ((m_dwFlags & FLAG_PALETTIZED) == FLAG_PALETTIZED); }

    // for auto-palette use
    inline void            tagAutoPalettized   (void)                     { m_dwFlags |= FLAG_AUTOPALETTIZED; }
    inline void            untagAutoPalettized (void)                     { m_dwFlags &= ~FLAG_AUTOPALETTIZED; }
    inline void            tagUnpalettized     (void)                     { m_dwFlags |= FLAG_UNPALETTIZED; }
    inline BOOL            isReused            (void)               const { return m_dwFlags & FLAG_UNPALETTIZED; }
    inline void            setOriginalFormat   (DWORD dwFormat)           { m_dwOriginalFormat = dwFormat; }
    inline DWORD           getOriginalFormat   (void)               const { return m_dwOriginalFormat; }
    inline void            resetOriginalFormat (void)                     { setFormat(m_dwOriginalFormat); }
    inline void            setAutoPaletteOffset(DWORD dwPalette)          { m_dwAutoPaletteOffset = dwPalette; }
    inline DWORD           getAutoPaletteOffset(void)               const { return m_dwAutoPaletteOffset; }
    inline BOOL            hasAutoPalette      (void)               const { return m_dwFlags & FLAG_AUTOPALETTIZED; }

    inline void            tagCubeMap          (void)                     { m_dwFlags |= FLAG_CUBEMAP; }
    inline BOOL            isCubeMap           (void)               const { return ((m_dwFlags & FLAG_CUBEMAP) == FLAG_CUBEMAP); }

    inline void            tagVolumeMap          (void)                     { m_dwFlags |= FLAG_VOLUMEMAP; }
    inline BOOL            isVolumeMap           (void)               const { return ((m_dwFlags & FLAG_VOLUMEMAP) == FLAG_VOLUMEMAP); }

    inline void            tagHasHandle        (void)                     { m_dwFlags |= FLAG_HASHANDLE; }
    inline BOOL            hasHandle           (void)               const { return ((m_dwFlags & FLAG_HASHANDLE) == FLAG_HASHANDLE); }

    inline void            tagManaged          (void)                     { m_dwFlags |= FLAG_MANAGED; }
    inline BOOL            isManaged           (void)               const { return ((m_dwFlags & FLAG_MANAGED) == FLAG_MANAGED); }

    inline void            tagRenamedNotCopied (void)                     { m_dwFlags |=  FLAG_RENAMENOTCOPIED; }
    inline void            tagRenamedAndCopied (void)                     { m_dwFlags &= ~FLAG_RENAMENOTCOPIED; }
    inline BOOL            isRenamedNotCopied  (void)               const { return ((m_dwFlags & FLAG_RENAMENOTCOPIED) == FLAG_RENAMENOTCOPIED); }

    inline void            tagSubSurfacesDirty (void)                     { m_dwFlags |=  FLAG_SUBSURFDIRTY; }
    inline void            tagSubSurfacesClean (void)                     { m_dwFlags &= ~FLAG_SUBSURFDIRTY; }
    inline BOOL            isSubSurfacesDirty  (void)               const { return ((m_dwFlags & FLAG_SUBSURFDIRTY) == FLAG_SUBSURFDIRTY); }

    inline CSimpleSurface* getSwizzled         (void)                     { return (m_surfSwizzled.getActiveSurface()); }
    inline CSimpleSurface* getPreviousSwizzled (void)                     { return (m_surfSwizzled.getPreviousSurface()); }
    inline CSimpleSurface* getLinear           (void)                     { return (&m_surfLinear); }
    inline CTexture*       getBaseTexture      (void)                     { return m_pBaseTexture; }

    inline CNvObject*      getWrapper          (void)               const { return (m_surfLinear.getWrapper()); }
    inline BOOL            hwCanWrite          (void)               const { return (m_surfLinear.hwCanWrite()); }

    inline DWORD           getSize             (void)               const { return (m_surfLinear.getSize()); }

    inline void            setWidth            (DWORD dwW)                { m_surfLinear.setWidth(dwW);
                                                                            ASM_LOG2(dwW);
                                                                            m_dwLogWidth = dwW;
                                                                            #if (NVARCH >= 0x010)
                                                                            if (pDriverData->nvD3DPerfData.dwNVClasses & NVCLASS_FAMILY_CELSIUS) calculateNV056ControlWords();
                                                                            #endif  // NVARCH >= 0x010
                                                                          }

    inline DWORD           getWidth            (void)               const { return (m_surfLinear.getWidth()); }
    inline DWORD           getLogWidth         (void)               const { return (m_dwLogWidth); }  // for DXTs, this is the UNEXPANDED width
    inline DWORD           getLogicalWidth     (void)               const { return isDXT() ? m_surfLinear.getWidth() * 4 : m_surfLinear.getWidth(); }
    inline DWORD           getLogicalLogWidth  (void)               const { return isDXT() ? (m_dwLogWidth + 2) : m_dwLogWidth; }

    inline void            setHeight           (DWORD dwH)                { m_surfLinear.setHeight(dwH);
                                                                            ASM_LOG2(dwH);
                                                                            m_dwLogHeight = dwH;
                                                                            #if (NVARCH >= 0x010)
                                                                            if (pDriverData->nvD3DPerfData.dwNVClasses & NVCLASS_FAMILY_CELSIUS) calculateNV056ControlWords();
                                                                            #endif  // NVARCH >= 0x010
                                                                          }

    inline DWORD           getHeight           (void)               const { return (m_surfLinear.getHeight()); }
    inline DWORD           getLogHeight        (void)               const { return (m_dwLogHeight); }  // for DXTs, this is the UNEXPANDED height
    inline DWORD           getLogicalHeight    (void)               const { return isDXT() ? m_surfLinear.getHeight() * 4 : m_surfLinear.getHeight(); }
    inline DWORD           getLogicalLogHeight (void)               const { return isDXT() ? (m_dwLogHeight + 2) : m_dwLogHeight; }

    inline void            setDepth            (DWORD dwD)                { m_surfLinear.setDepth(dwD);
                                                                            ASM_LOG2(dwD);
                                                                            m_dwLogDepth = dwD; }
    inline DWORD           getDepth            (void)               const { return (m_surfLinear.getDepth()); }
    inline DWORD           getLogDepth         (void)               const { return (m_dwLogDepth); }  // What does this mean for 3D DXT???
    inline DWORD           getLogicalDepth     (void)               const { return (m_surfLinear.getDepth()); }
    inline DWORD           getLogicalLogDepth  (void)               const { return (m_dwLogDepth); }

    inline DWORD           getNumTexCoords     (void)               const { return ((isVolumeMap() || isCubeMap()) ? 3 : 2); }

    inline void            setBPP              (DWORD dwBPP)              { m_surfLinear.setBPP(dwBPP); }
    inline DWORD           getBPP              (void)               const { return (m_surfLinear.getBPP()); }

    inline void            setBPPRequested     (DWORD dwBPP)              { m_surfLinear.setBPPRequested(dwBPP); }
    inline DWORD           getBPPRequested     (void)               const { return (m_surfLinear.getBPPRequested()); }

    inline void            setPitch            (DWORD dwPitch)            { m_surfLinear.setPitch(dwPitch); }
    inline DWORD           getPitch            (void)               const { return (m_surfLinear.getPitch()); }

    inline void            setSlicePitch       (DWORD dwSlicePitch)       { m_surfLinear.setSlicePitch(dwSlicePitch); }
    inline DWORD           getSlicePitch       (void)               const { return (m_surfLinear.getSlicePitch()); }

    inline void            setFormat           (DWORD dwFmt)              { m_surfLinear.setFormat(dwFmt);
                                                                            #if (NVARCH >= 0x010)
                                                                            if (pDriverData->nvD3DPerfData.dwNVClasses & NVCLASS_FAMILY_CELSIUS) calculateNV056ControlWords();
                                                                            #endif  // NVARCH >= 0x010
                                                                          }

    inline DWORD           getFormat           (void)               const { return (m_surfLinear.getFormat()); }

    inline void            setFourCC           (DWORD dw4cc)              { m_surfLinear.setFourCC(dw4cc); }
    inline BOOL            getFourCC           (void)               const { return (m_surfLinear.getFourCC()); }
    inline BOOL            isFourCC            (void)               const { return (m_surfLinear.isFourCC()); }
    inline BOOL            isDXT               (void)               const { return (m_surfLinear.isDXT()); }
    inline BOOL            isBumpMap           (void)               const { return ((m_surfLinear.getFormat() == NV_SURFACE_FORMAT_DV8DU8)   ||
                                                                                    (m_surfLinear.getFormat() == NV_SURFACE_FORMAT_L6DV5DU5) ||
                                                                                    (m_surfLinear.getFormat() == NV_SURFACE_FORMAT_X8L8DV8DU8)); }

    inline void            tagHasAlpha         (void)                     { m_surfLinear.tagHasAlpha(); }
    inline void            tagHasNoAlpha       (void)                     { m_surfLinear.tagHasNoAlpha(); }
    inline BOOL            hasAlpha            (void)               const { return (m_surfLinear.hasAlpha()); }

#ifdef TEX_MANAGE
    inline void            setNext             (CTexture *pNext)          { m_pNext = pNext; }
    inline CTexture*       getNext             (void)               const { return (m_pNext); }
    inline void            setPrev             (CTexture *pPrev)          { m_pPrev = pPrev; }
    inline CTexture*       getPrev             (void)               const { return (m_pPrev); }
    inline void            setContext          (PNVD3DCONTEXT pCtx)       { m_pContext = pCtx; }
    inline PNVD3DCONTEXT   getContext          (void)               const { return (m_pContext); }

    inline BOOL            isResident          (void)                     { return ((getSwizzled()->getHeapLocation() != CSimpleSurface::HEAP_SYS) ? TRUE : FALSE); }
    inline BOOL            isEvicted           (void)                     { return ((getSwizzled()->getHeapLocation() == CSimpleSurface::HEAP_SYS) ? TRUE : FALSE); }
#endif

    inline void            tagColorKey         (void)                     { m_dwFlags |= FLAG_COLORKEY; }
    inline BOOL            hasColorKey         (void)               const { return ((m_dwFlags & FLAG_COLORKEY) == FLAG_COLORKEY); }
    inline void            setColorKey         (DWORD dwCK)               { m_dwColorKey = dwCK; }
    inline DWORD           getColorKey         (void)               const { return (m_dwColorKey); }

    inline DWORD           getNV056Control0    (void)               const { return (m_dwNV056Control0); }
    inline DWORD           getNV056Format      (void)               const { return (m_dwNV056Format); }

           void            hwLock              (PNVD3DCONTEXT pContext, DWORD dwAccess);
    inline void            hwUnlock            (void)                     { m_surfSwizzled.hwUnlock(); }
    inline void            cpuLockSwz          (DWORD dwAccess)           { m_surfSwizzled.cpuLock (dwAccess); }
    inline void            cpuUnlockSwz        (void)                     { m_surfSwizzled.cpuUnlock(); }
    inline void            cpuLockLin          (DWORD dwAccess)           { m_surfLinear.cpuLock (dwAccess); }
    inline void            cpuUnlockLin        (void)                     { m_surfLinear.cpuUnlock(); }

           BOOL            internalCanRename   (void);
           void            internalRename      (DWORD dwOldIndex, DWORD dwNewIndex);
           void            enableRenaming      (void);

    // methods
public:
    DWORD        calcMipMapSize              (DWORD dwLogU, DWORD dwLogV, DWORD dwLogP, DWORD dwMipMapLevels);
    BOOL         prepareLinearAsRenderTarget (void);
    BOOL         updateLinearSurface         (void);
    BOOL         updateSwizzleSurface        (PNVD3DCONTEXT pContext);
    void         calculateNV056ControlWords  (void);
    static DWORD getCubeMapFaceNum           (DWORD dwFace);
#ifdef TEX_MANAGE
    BOOL         evict                       (void);
    BOOL         fetch                       (void);
#endif

    // construction
public:
    // new creation
    BOOL create  (CNvObject *pWrapperObject,      // NvObject wrapping this texture
                  DWORD      dwWidth,             // width
                  DWORD      dwHeight,            // height
                  DWORD      dwDepth,             // depth
                  DWORD      dwBPPRequested,      // bytes per pixel requested
                  DWORD      dwBPPGranted,        // bytes per pixel granted
                  DWORD      dwMipMapCount,       // # of mipmaps (including self)
                  DWORD      dwFormat,            // texture format NV_TEXTURE_FORMAT_xxx
                  DWORD      dwAllowedHeaps,      // allowed heaps to allocate in
                  DWORD      dwPreferredHeap);    // preferred heap
    BOOL create  (CNvObject *pWrapperObject,      // NvObject wrapping this texture
                  DWORD      dwThisFace,          // cubemap face
                  CTexture  *pBaseTexture,        // create a mipmap from this base
                  DWORD      dwMipMapLevel);      // this is the nth mipmap (base = 0)
    // new destruction
    BOOL destroy (void);

     CTexture ();
    ~CTexture ();
};

//---------------------------------------------------------------------------

#ifdef __cplusplus
extern "C"
{
#endif

// public functions
DWORD nvTextureCreateSurface    (LPDDRAWI_DDRAWSURFACE_LCL pLcl, LPDDRAWI_DIRECTDRAW_GBL pDDGbl, LPDDSURFACEDESC pDDSurfDesc);
BOOL  nvTextureDestroySurface   (LPDDHAL_DESTROYSURFACEDATA pDestorySurfaceData, LPDDRAWI_DDRAWSURFACE_LCL pLcl);
DWORD nvTextureBlt              (PNVD3DCONTEXT pContext, LPDDHAL_BLTDATA pBltData);
DWORD nvTextureBltDX7           (PNVD3DCONTEXT pContext, CNvObject *pSrcObj, CNvObject *pDstObj, D3DBOX *boxSrc, DWORD dwDstX, DWORD dwDstY, DWORD dwDstZ, DWORD dwFlags);
DWORD nvTextureColorFill        (CNvObject *pDstObj, DWORD dwX0, DWORD dwY0, DWORD dwFillWidth, DWORD dwFillHeight, DWORD dwColor);
DWORD nvTextureStretchBlit      (LPSURFINFO pSrcInfo, LPSURFINFO pDstInfo);
DWORD nvTextureLock             (CTexture *pTexture, LPDDHAL_LOCKDATA pLockData);
DWORD nvTextureUnlock           (CTexture *pTexture, LPDDHAL_UNLOCKDATA pUnlockData);

DWORD D3DCreateTextureContexts  (DWORD dwHeapBase, DWORD dwNewLimit);
void  D3DDestroyTextureContexts (GLOBALDATA *pDriverData);

BOOL  nvTextureDefaultAlloc     (void);
void  nvTextureDefaultFree      (void);

#ifdef __cplusplus
}
#endif

#endif // _nvTex_h
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\ddraw\common\inc\NVTEXFMT.H ===
/*
 * (C) Copyright NVIDIA Corporation Inc., 1996,1997,1998. All rights reserved.
 */
/********************************* Direct 3D *******************************\
*                                                                           *
* Module: NVTEXFMT.H                                                        *
*   Define the texture format available for the NV D3D driver.              *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*       Charles Inman (chasi)       01/31/98 - created.                     *
*                                                                           *
\***************************************************************************/

#ifndef _NVTEXFMT_H_
#define _NVTEXFMT_H_

#ifdef __cplusplus
extern "C" {
#endif

/*
 * Define the various texture format definitions.
 * For any given hardware, the texture format definitions don't change,
 * just the formats that are available on that hardware change.
 */
/*
 * RGB 16 BPP (R5xG5xB5)
 */
#define NV_TFMT_X1R5G5B5                                                            \
{                                                                                   \
    sizeof(DDSURFACEDESC),                  /* dwSize */                            \
    DDSD_CAPS | DDSD_PIXELFORMAT,           /* dwFlags */                           \
    0,                                      /* dwHeight */                          \
    0,                                      /* dwWidth */                           \
    0,                                      /* lPitch */                            \
    0,                                      /* dwBackBufferCount */                 \
    0,                                      /* dwZBufferBitDepth */                 \
    0,                                      /* dwAlphaBitDepth */                   \
    0,                                      /* dwReserved */                        \
    NULL,                                   /* lpSurface */                         \
    { 0, 0 },                               /* ddckCKDestOverlay */                 \
    { 0, 0 },                               /* ddckCKDestBlt */                     \
    { 0, 0 },                               /* ddckCKSrcOverlay */                  \
    { 0, 0 },                               /* ddckCKSrcBlt */                      \
    {                                                                               \
      sizeof(DDPIXELFORMAT),                /* ddpfPixelFormat.dwSize */            \
      DDPF_RGB,                             /* ddpfPixelFormat.dwFlags */           \
      0,                                    /* FOURCC code */                       \
      16,                                   /* ddpfPixelFormat.dwRGBBitCount */     \
      0x7C00,                                                                       \
      0x03E0,                                                                       \
      0x001F,                                                                       \
      0x0000                                                                        \
    },                                                                              \
    DDSCAPS_TEXTURE                         /* ddscaps.dwCaps */                    \
}

/*
 * RGB 16 BPP Alpha (A1xR5xG5xB5)
 */
#define NV_TFMT_A1R5G5B5                                                            \
{                                                                                  \
    sizeof(DDSURFACEDESC),                  /* dwSize */                            \
    DDSD_CAPS | DDSD_PIXELFORMAT,           /* dwFlags */                           \
    0,                                      /* dwHeight */                          \
    0,                                      /* dwWidth */                           \
    0,                                      /* lPitch */                            \
    0,                                      /* dwBackBufferCount */                 \
    0,                                      /* dwZBufferBitDepth */                 \
    0,                                      /* dwAlphaBitDepth */                   \
    0,                                      /* dwReserved */                        \
    NULL,                                   /* lpSurface */                         \
    { 0, 0 },                               /* ddckCKDestOverlay */                 \
    { 0, 0 },                               /* ddckCKDestBlt */                     \
    { 0, 0 },                               /* ddckCKSrcOverlay */                  \
    { 0, 0 },                               /* ddckCKSrcBlt */                      \
    {                                                                               \
      sizeof(DDPIXELFORMAT),                /* ddpfPixelFormat.dwSize */            \
      DDPF_RGB | DDPF_ALPHAPIXELS,          /* ddpfPixelFormat.dwFlags */           \
      0,                                    /* FOURCC code */                       \
      16,                                   /* ddpfPixelFormat.dwRGBBitCount */     \
      0x7C00,                                                                       \
      0x03E0,                                                                       \
      0x001F,                                                                       \
      0x8000                                                                        \
    },                                                                              \
    DDSCAPS_TEXTURE                         /* ddscaps.dwCaps */                    \
}

/*
 * RGB 16 BPP Alpha (A4xR4xG4xB4)
 */
#define NV_TFMT_A4R4G4B4                                                            \
{                                                                                   \
    sizeof(DDSURFACEDESC),                  /* dwSize */                            \
    DDSD_CAPS | DDSD_PIXELFORMAT,           /* dwFlags */                           \
    0,                                      /* dwHeight */                          \
    0,                                      /* dwWidth */                           \
    0,                                      /* lPitch */                            \
    0,                                      /* dwBackBufferCount */                 \
    0,                                      /* dwZBufferBitDepth */                 \
    0,                                      /* dwAlphaBitDepth */                   \
    0,                                      /* dwReserved */                        \
    NULL,                                   /* lpSurface */                         \
    { 0, 0 },                               /* ddckCKDestOverlay */                 \
    { 0, 0 },                               /* ddckCKDestBlt */                     \
    { 0, 0 },                               /* ddckCKSrcOverlay */                  \
    { 0, 0 },                               /* ddckCKSrcBlt */                      \
    {                                                                               \
      sizeof(DDPIXELFORMAT),                /* ddpfPixelFormat.dwSize */            \
      DDPF_RGB | DDPF_ALPHAPIXELS,          /* ddpfPixelFormat.dwFlags */           \
      0,                                    /* FOURCC code */                       \
      16,                                   /* ddpfPixelFormat.dwRGBBitCount */     \
      0x0F00,                                                                       \
      0x00F0,                                                                       \
      0x000F,                                                                       \
      0xF000                                                                        \
    },                                                                              \
    DDSCAPS_TEXTURE                         /* ddscaps.dwCaps */                    \
}

/*
 * RGB 16 BPP (R5xG6xB5)
 */
#define NV_TFMT_R5G6B5                                                              \
{                                                                                   \
    sizeof(DDSURFACEDESC),                  /* dwSize */                            \
    DDSD_CAPS | DDSD_PIXELFORMAT,           /* dwFlags */                           \
    0,                                      /* dwHeight */                          \
    0,                                      /* dwWidth */                           \
    0,                                      /* lPitch */                            \
    0,                                      /* dwBackBufferCount */                 \
    0,                                      /* dwZBufferBitDepth */                 \
    0,                                      /* dwAlphaBitDepth */                   \
    0,                                      /* dwReserved */                        \
    NULL,                                   /* lpSurface */                         \
    { 0, 0 },                               /* ddckCKDestOverlay */                 \
    { 0, 0 },                               /* ddckCKDestBlt */                     \
    { 0, 0 },                               /* ddckCKSrcOverlay */                  \
    { 0, 0 },                               /* ddckCKSrcBlt */                      \
    {                                                                               \
      sizeof(DDPIXELFORMAT),                /* ddpfPixelFormat.dwSize */            \
      DDPF_RGB,                             /* ddpfPixelFormat.dwFlags */           \
      0,                                    /* FOURCC code */                       \
      16,                                   /* ddpfPixelFormat.dwRGBBitCount */     \
      0xF800,                                                                       \
      0x07E0,                                                                       \
      0x001F,                                                                       \
      0x0000                                                                        \
    },                                                                              \
    DDSCAPS_TEXTURE                         /* ddscaps.dwCaps */                    \
}

/*
 * RGB 32 BPP (X8xR8xG8xB8)
 */
#define NV_TFMT_X8R8G8B8                                                            \
{                                                                                   \
    sizeof(DDSURFACEDESC),                  /* dwSize */                            \
    DDSD_CAPS | DDSD_PIXELFORMAT,           /* dwFlags */                           \
    0,                                      /* dwHeight */                          \
    0,                                      /* dwWidth */                           \
    0,                                      /* lPitch */                            \
    0,                                      /* dwBackBufferCount */                 \
    0,                                      /* dwZBufferBitDepth */                 \
    0,                                      /* dwAlphaBitDepth */                   \
    0,                                      /* dwReserved */                        \
    NULL,                                   /* lpSurface */                         \
    { 0, 0 },                               /* ddckCKDestOverlay */                 \
    { 0, 0 },                               /* ddckCKDestBlt */                     \
    { 0, 0 },                               /* ddckCKSrcOverlay */                  \
    { 0, 0 },                               /* ddckCKSrcBlt */                      \
    {                                                                               \
      sizeof(DDPIXELFORMAT),                /* ddpfPixelFormat.dwSize */            \
      DDPF_RGB,                             /* ddpfPixelFormat.dwFlags */           \
      0,                                    /* FOURCC code */                       \
      32,                                   /* ddpfPixelFormat.dwRGBBitCount */     \
      0x00FF0000,                           /* Red Component Mask */                \
      0x0000FF00,                           /* Green Component Mask */              \
      0x000000FF,                           /* Blue Component Mask */               \
      0x00000000                            /* Alpha Component Mask */              \
    },                                                                              \
    DDSCAPS_TEXTURE                         /* ddscaps.dwCaps */                    \
}

/*
 * RGB 32 BPP (A8xR8xG8xB8)
 */
#define NV_TFMT_A8R8G8B8                                                            \
{                                                                                   \
    sizeof(DDSURFACEDESC),                  /* dwSize */                            \
    DDSD_CAPS | DDSD_PIXELFORMAT,           /* dwFlags */                           \
    0,                                      /* dwHeight */                          \
    0,                                      /* dwWidth */                           \
    0,                                      /* lPitch */                            \
    0,                                      /* dwBackBufferCount */                 \
    0,                                      /* dwZBufferBitDepth */                 \
    0,                                      /* dwAlphaBitDepth */                   \
    0,                                      /* dwReserved */                        \
    NULL,                                   /* lpSurface */                         \
    { 0, 0 },                               /* ddckCKDestOverlay */                 \
    { 0, 0 },                               /* ddckCKDestBlt */                     \
    { 0, 0 },                               /* ddckCKSrcOverlay */                  \
    { 0, 0 },                               /* ddckCKSrcBlt */                      \
    {                                                                               \
      sizeof(DDPIXELFORMAT),                /* ddpfPixelFormat.dwSize */            \
      DDPF_RGB | DDPF_ALPHAPIXELS,          /* ddpfPixelFormat.dwFlags */           \
      0,                                    /* FOURCC code */                       \
      32,                                   /* ddpfPixelFormat.dwRGBBitCount */     \
      0x00FF0000,                           /* Red Component Mask */                \
      0x0000FF00,                           /* Green Component Mask */              \
      0x000000FF,                           /* Blue Component Mask */               \
      0xFF000000                            /* Alpha Component Mask */              \
    },                                                                              \
    DDSCAPS_TEXTURE                         /* ddscaps.dwCaps */                    \
}

/*
 * RGB 24 BPP (R8xG8xB8)
 * Hardware doesn't actually support this.  The texture would actually
 * have to be expanded to a 32bpp X8xR8xG8xB8 format.
 * Haven't decided if I really want to do this.
 */
#define NV_TFMT_R8G8B8                                                              \
{                                                                                   \
    sizeof(DDSURFACEDESC),                  /* dwSize */                            \
    DDSD_CAPS | DDSD_PIXELFORMAT,           /* dwFlags */                           \
    0,                                      /* dwHeight */                          \
    0,                                      /* dwWidth */                           \
    0,                                      /* lPitch */                            \
    0,                                      /* dwBackBufferCount */                 \
    0,                                      /* dwZBufferBitDepth */                 \
    0,                                      /* dwAlphaBitDepth */                   \
    0,                                      /* dwReserved */                        \
    NULL,                                   /* lpSurface */                         \
    { 0, 0 },                               /* ddckCKDestOverlay */                 \
    { 0, 0 },                               /* ddckCKDestBlt */                     \
    { 0, 0 },                               /* ddckCKSrcOverlay */                  \
    { 0, 0 },                               /* ddckCKSrcBlt */                      \
    {                                                                               \
      sizeof(DDPIXELFORMAT),                /* ddpfPixelFormat.dwSize */            \
      DDPF_RGB,                             /* ddpfPixelFormat.dwFlags */           \
      0,                                    /* FOURCC code */                       \
      24,                                   /* ddpfPixelFormat.dwRGBBitCount */     \
      0x00FF0000,                           /* Red Component Mask */                \
      0x0000FF00,                           /* Green Component Mask */              \
      0x000000FF,                           /* Blue Component Mask */               \
      0x00000000                            /* Alpha Component Mask */              \
    },                                                                              \
    DDSCAPS_TEXTURE                         /* ddscaps.dwCaps */                    \
}

/*
 * FFVII REQUIRES 8bit textures.  What a pain.  Of course so does PC98/PC99.
 */
#define NV_TFMT_RGB8                                                                \
{                                                                                   \
    sizeof(DDSURFACEDESC),                  /* dwSize */                            \
    DDSD_CAPS | DDSD_PIXELFORMAT,           /* dwFlags */                           \
    0,                                      /* dwHeight */                          \
    0,                                      /* dwWidth */                           \
    0,                                      /* lPitch */                            \
    0,                                      /* dwBackBufferCount */                 \
    0,                                      /* dwZBufferBitDepth */                 \
    0,                                      /* dwAlphaBitDepth */                   \
    0,                                      /* dwReserved */                        \
    NULL,                                   /* lpSurface */                         \
    { 0, 0 },                               /* ddckCKDestOverlay */                 \
    { 0, 0 },                               /* ddckCKDestBlt */                     \
    { 0, 0 },                               /* ddckCKSrcOverlay */                  \
    { 0, 0 },                               /* ddckCKSrcBlt */                      \
    {                                                                               \
      sizeof(DDPIXELFORMAT),                /* ddpfPixelFormat.dwSize */            \
      DDPF_RGB | DDPF_PALETTEINDEXED8,      /* ddpfPixelFormat.dwFlags */           \
      0,                                    /* FOURCC code */                       \
      8,                                    /* ddpfPixelFormat.dwRGBBitCount */     \
      0x00000000,                           /* Red Component Mask */                \
      0x00000000,                           /* Green Component Mask */              \
      0x00000000,                           /* Blue Component Mask */               \
      0x00000000                            /* Alpha Component Mask */              \
    },                                                                              \
    DDSCAPS_TEXTURE                         /* ddscaps.dwCaps */                    \
}

/*
 * 16-bit bumpmap
 * dU occupies the LSByte, dV occupies the MSByte
 */
#define NV_TFMT_BUMPMAP_DV8_DU8                                                     \
{                                                                                   \
    sizeof(DDSURFACEDESC),                  /* dwSize */                            \
    DDSD_CAPS | DDSD_PIXELFORMAT,           /* dwFlags */                           \
    0,                                      /* dwHeight */                          \
    0,                                      /* dwWidth */                           \
    0,                                      /* lPitch */                            \
    0,                                      /* dwBackBufferCount */                 \
    0,                                      /* dwZBufferBitDepth */                 \
    0,                                      /* dwAlphaBitDepth */                   \
    0,                                      /* dwReserved */                        \
    NULL,                                   /* lpSurface */                         \
    { 0, 0 },                               /* ddckCKDestOverlay */                 \
    { 0, 0 },                               /* ddckCKDestBlt */                     \
    { 0, 0 },                               /* ddckCKSrcOverlay */                  \
    { 0, 0 },                               /* ddckCKSrcBlt */                      \
    {                                                                               \
      sizeof(DDPIXELFORMAT),                /* ddpfPixelFormat.dwSize */            \
      DDPF_BUMPDUDV,                        /* ddpfPixelFormat.dwFlags */           \
      0,                                    /* FOURCC code */                       \
      16,                                   /* ddpfPixelFormat.dwRGBBitCount */     \
      0x000000FF,                           /* dU mask */                           \
      0x0000FF00,                           /* dV mask */                           \
      0x00000000,                           /* luminance mask */                    \
      0                                     /* unused */                            \
    },                                                                              \
    DDSCAPS_TEXTURE                         /* ddscaps.dwCaps */                    \
}

/*
 * 16-bit bumpmap with luminance
 * dU occupies the LSByte, luminance occupies the MSByte, dV is in the middle
 */
#define NV_TFMT_BUMPMAP_L6_DV5_DU5                                                  \
{                                                                                   \
    sizeof(DDSURFACEDESC),                  /* dwSize */                            \
    DDSD_CAPS | DDSD_PIXELFORMAT,           /* dwFlags */                           \
    0,                                      /* dwHeight */                          \
    0,                                      /* dwWidth */                           \
    0,                                      /* lPitch */                            \
    0,                                      /* dwBackBufferCount */                 \
    0,                                      /* dwZBufferBitDepth */                 \
    0,                                      /* dwAlphaBitDepth */                   \
    0,                                      /* dwReserved */                        \
    NULL,                                   /* lpSurface */                         \
    { 0, 0 },                               /* ddckCKDestOverlay */                 \
    { 0, 0 },                               /* ddckCKDestBlt */                     \
    { 0, 0 },                               /* ddckCKSrcOverlay */                  \
    { 0, 0 },                               /* ddckCKSrcBlt */                      \
    {                                                                               \
      sizeof(DDPIXELFORMAT),                /* ddpfPixelFormat.dwSize */            \
      DDPF_BUMPDUDV | DDPF_BUMPLUMINANCE,   /* ddpfPixelFormat.dwFlags */           \
      0,                                    /* FOURCC code */                       \
      16,                                   /* ddpfPixelFormat.dwRGBBitCount */     \
      0x0000001F,                           /* dU mask */                           \
      0x000003E0,                           /* dV mask */                           \
      0x0000FC00,                           /* luminance mask */                    \
      0                                     /* unused */                            \
    },                                                                              \
    DDSCAPS_TEXTURE                         /* ddscaps.dwCaps */                    \
}

/*
 * 24-bit bumpmap with luminance
 * dU is in the LSByte, dV is in the second byte and luminance is in the third.
 * the MSByte is unused
 */
#define NV_TFMT_BUMPMAP_L8_DV8_DU8                                                  \
{                                                                                   \
    sizeof(DDSURFACEDESC),                  /* dwSize */                            \
    DDSD_CAPS | DDSD_PIXELFORMAT,           /* dwFlags */                           \
    0,                                      /* dwHeight */                          \
    0,                                      /* dwWidth */                           \
    0,                                      /* lPitch */                            \
    0,                                      /* dwBackBufferCount */                 \
    0,                                      /* dwZBufferBitDepth */                 \
    0,                                      /* dwAlphaBitDepth */                   \
    0,                                      /* dwReserved */                        \
    NULL,                                   /* lpSurface */                         \
    { 0, 0 },                               /* ddckCKDestOverlay */                 \
    { 0, 0 },                               /* ddckCKDestBlt */                     \
    { 0, 0 },                               /* ddckCKSrcOverlay */                  \
    { 0, 0 },                               /* ddckCKSrcBlt */                      \
    {                                                                               \
      sizeof(DDPIXELFORMAT),                /* ddpfPixelFormat.dwSize */            \
      DDPF_BUMPDUDV | DDPF_BUMPLUMINANCE,   /* ddpfPixelFormat.dwFlags */           \
      0,                                    /* FOURCC code */                       \
      32,                                   /* ddpfPixelFormat.dwRGBBitCount */     \
      0x000000FF,                           /* dU mask */                           \
      0x0000FF00,                           /* dV mask */                           \
      0x00FF0000,                           /* luminance mask */                    \
      0                                     /* unused */                            \
    },                                                                              \
    DDSCAPS_TEXTURE                         /* ddscaps.dwCaps */                    \
}

/*
 * fourcc macro
 */
#define NV_TFMT_FOURCC(x)                                                           \
{                                                                                   \
    sizeof(DDSURFACEDESC),                  /* dwSize */                            \
    DDSD_CAPS | DDSD_PIXELFORMAT,           /* dwFlags */                           \
    0,                                      /* dwHeight */                          \
    0,                                      /* dwWidth */                           \
    0,                                      /* lPitch */                            \
    0,                                      /* dwBackBufferCount */                 \
    0,                                      /* dwZBufferBitDepth */                 \
    0,                                      /* dwAlphaBitDepth */                   \
    0,                                      /* dwReserved */                        \
    NULL,                                   /* lpSurface */                         \
    { 0, 0 },                               /* ddckCKDestOverlay */                 \
    { 0, 0 },                               /* ddckCKDestBlt */                     \
    { 0, 0 },                               /* ddckCKSrcOverlay */                  \
    { 0, 0 },                               /* ddckCKSrcBlt */                      \
    {                                                                               \
      sizeof(DDPIXELFORMAT),                /* ddpfPixelFormat.dwSize */            \
      DDPF_FOURCC,                          /* ddpfPixelFormat.dwFlags */           \
      (x),                                  /* FOURCC code */                       \
      0,                                    /* ddpfPixelFormat.dwRGBBitCount */     \
      0,                                                                            \
      0,                                                                            \
      0,                                                                            \
      0,                                                                            \
    },                                                                              \
    DDSCAPS_TEXTURE                         /* ddscaps.dwCaps */                    \
}

// FourCC formats
#define NV_TFMT_DXT1            NV_TFMT_FOURCC(FOURCC_DXT1)
#define NV_TFMT_DXT2            NV_TFMT_FOURCC(FOURCC_DXT2)
#define NV_TFMT_DXT3            NV_TFMT_FOURCC(FOURCC_DXT3)
#define NV_TFMT_DXT4            NV_TFMT_FOURCC(FOURCC_DXT4)
#define NV_TFMT_DXT5            NV_TFMT_FOURCC(FOURCC_DXT5)

// HILO formats
#define NV_TFMT_NVHU            NV_TFMT_FOURCC(FOURCC_NVHU)
#define NV_TFMT_NVHS            NV_TFMT_FOURCC(FOURCC_NVHS)

#define NV_TFMT_DX8(x,y)                                                            \
{                                                                                   \
    sizeof(DDPIXELFORMAT),                  /* ddpfPixelFormat.dwSize */            \
    DDPF_D3DFORMAT,                         /* ddpfPixelFormat.dwFlags */           \
    (x),                                    /* FOURCC code */                       \
    0,                                      /* ddpfPixelFormat.dwRGBBitCount */     \
    y,                                                                              \
    0,                                                                              \
    0,                                                                              \
    0,                                                                              \
}

#define NV_TFMT_DX8_KELVIN_MULTISAMPLE(x,y)                                                            \
{                                                                                   \
    sizeof(DDPIXELFORMAT),                  /* ddpfPixelFormat.dwSize */            \
    DDPF_D3DFORMAT,                         /* ddpfPixelFormat.dwFlags */           \
    (x),                                    /* FOURCC code */                       \
    0,                                      /* ddpfPixelFormat.dwRGBBitCount */     \
    y,                                                                              \
    (/*(1 << (D3DMULTISAMPLE_5_SAMPLES-1)) | */(1 << (D3DMULTISAMPLE_4_SAMPLES-1)) | (1 << (D3DMULTISAMPLE_3_SAMPLES-1)) | (1 << (D3DMULTISAMPLE_2_SAMPLES-1))) |        \
    ((/*(1 << (D3DMULTISAMPLE_5_SAMPLES-1)) | */(1 << (D3DMULTISAMPLE_4_SAMPLES-1)) | (1 << (D3DMULTISAMPLE_3_SAMPLES-1)) | (1 << (D3DMULTISAMPLE_2_SAMPLES-1))) << 16), \
    0,                                                                              \
    0,                                                                              \
}

#define NV_TFMT_DX8_CELSIUS_MULTISAMPLE(x,y)                                                            \
{                                                                                   \
    sizeof(DDPIXELFORMAT),                  /* ddpfPixelFormat.dwSize */            \
    DDPF_D3DFORMAT,                         /* ddpfPixelFormat.dwFlags */           \
    (x),                                    /* FOURCC code */                       \
    0,                                      /* ddpfPixelFormat.dwRGBBitCount */     \
    y,                                                                              \
    ((1 << (D3DMULTISAMPLE_4_SAMPLES-1)) | (1 << (D3DMULTISAMPLE_2_SAMPLES-1))) |        \
    (((1 << (D3DMULTISAMPLE_4_SAMPLES-1)) | (1 << (D3DMULTISAMPLE_2_SAMPLES-1))) << 16), \
    0,                                                                              \
    0,                                                                              \
}

#define D3D_RENDER_TEXTURE  D3DFORMAT_OP_CUBETEXTURE |            \
                            D3DFORMAT_OP_TEXTURE     |            \
                            D3DFORMAT_OP_OFFSCREEN_RENDERTARGET

#define D3D_TEXTURE         D3DFORMAT_OP_CUBETEXTURE |           \
                            D3DFORMAT_OP_TEXTURE

#define D3D_FRONT_BUFFER    D3DFORMAT_OP_DISPLAYMODE |           \
                            D3DFORMAT_OP_3DACCELERATION

#define D3D_BACK_BUFFER     D3DFORMAT_OP_SAME_FORMAT_UP_TO_ALPHA_RENDERTARGET

#define NV_TFMT_X1R5G5B5_DX8              NV_TFMT_DX8(D3DFMT_X1R5G5B5, (D3DFORMAT_OP_VOLUMETEXTURE | D3D_RENDER_TEXTURE | D3D_BACK_BUFFER))
#define NV_TFMT_A1R5G5B5_DX8              NV_TFMT_DX8(D3DFMT_A1R5G5B5, (D3DFORMAT_OP_VOLUMETEXTURE | D3D_TEXTURE))
#define NV_TFMT_A4R4G4B4_DX8              NV_TFMT_DX8(D3DFMT_A4R4G4B4, (D3DFORMAT_OP_VOLUMETEXTURE | D3D_TEXTURE))
#define NV_TFMT_R5G6B5_DX8                NV_TFMT_DX8(D3DFMT_R5G6B5,(D3DFORMAT_OP_VOLUMETEXTURE | D3D_RENDER_TEXTURE | D3D_BACK_BUFFER | D3D_FRONT_BUFFER ))
#define NV_TFMT_X8R8G8B8_DX8              NV_TFMT_DX8(D3DFMT_X8R8G8B8,(D3DFORMAT_OP_VOLUMETEXTURE | D3D_RENDER_TEXTURE | D3D_FRONT_BUFFER | D3D_BACK_BUFFER))
#define NV_TFMT_A8R8G8B8_DX8              NV_TFMT_DX8(D3DFMT_A8R8G8B8,(D3DFORMAT_OP_VOLUMETEXTURE | D3D_RENDER_TEXTURE | D3D_BACK_BUFFER))
#define NV_TFMT_RGB8_DX8                  NV_TFMT_DX8(D3DFMT_P8, (D3DFORMAT_OP_VOLUMETEXTURE | D3D_TEXTURE))
#define NV_TFMT_BUMPMAP_DV8_DU8_DX8       NV_TFMT_DX8(D3DFMT_V8U8, D3D_TEXTURE)
#define NV_TFMT_BUMPMAP_L6_DV5_DU5_DX8    NV_TFMT_DX8(D3DFMT_L6V5U5, D3D_TEXTURE)
#define NV_TFMT_BUMPMAP_L8_DV8_DU8_DX8    NV_TFMT_DX8(D3DFMT_X8L8V8U8, D3D_TEXTURE)
#define NV_TFMT_DXT1_DX8                  NV_TFMT_DX8(D3DFMT_DXT1, D3D_TEXTURE)
#define NV_TFMT_DXT2_DX8                  NV_TFMT_DX8(D3DFMT_DXT2, D3D_TEXTURE)
#define NV_TFMT_DXT3_DX8                  NV_TFMT_DX8(D3DFMT_DXT3, D3D_TEXTURE)
#define NV_TFMT_DXT4_DX8                  NV_TFMT_DX8(D3DFMT_DXT4, D3D_TEXTURE)
#define NV_TFMT_DXT5_DX8                  NV_TFMT_DX8(D3DFMT_DXT5, D3D_TEXTURE)

#define NV_TFMT_NVHU_DX8                  NV_TFMT_DX8(FOURCC_NVHU, D3D_TEXTURE)
#define NV_TFMT_NVHS_DX8                  NV_TFMT_DX8(FOURCC_NVHS, D3D_TEXTURE)

#ifndef TEXFORMAT_CRD // -----------------------------------------------------

#ifdef NVxn_SUPPORT_DX7

#define NV_TFMT_NVxn \
    NV_TFMT_FOURCC(FOURCC_NVT0), \
    NV_TFMT_FOURCC(FOURCC_NVT1), \
    NV_TFMT_FOURCC(FOURCC_NVT2), \
    NV_TFMT_FOURCC(FOURCC_NVT3), \
    NV_TFMT_FOURCC(FOURCC_NVT4), \
    NV_TFMT_FOURCC(FOURCC_NVT5), \
    NV_TFMT_FOURCC(FOURCC_NVS0), \
    NV_TFMT_FOURCC(FOURCC_NVS1), \
    NV_TFMT_FOURCC(FOURCC_NVS2), \
    NV_TFMT_FOURCC(FOURCC_NVS3), \
    NV_TFMT_FOURCC(FOURCC_NVS4), \
    NV_TFMT_FOURCC(FOURCC_NVS5),

#else // NVxn_SUPPORT_DX7

#define NV_TFMT_NVxn

#endif // NVxn_SUPPORT_DX7

#ifdef NVxn_SUPPORT_DX8

#define NV_TFMT_NVxn_DX8 \
    NV_TFMT_DX8(FOURCC_NVT0, D3D_TEXTURE), \
    NV_TFMT_DX8(FOURCC_NVT1, D3D_TEXTURE), \
    NV_TFMT_DX8(FOURCC_NVT2, D3D_TEXTURE), \
    NV_TFMT_DX8(FOURCC_NVT3, D3D_TEXTURE), \
    NV_TFMT_DX8(FOURCC_NVT4, D3D_TEXTURE), \
    NV_TFMT_DX8(FOURCC_NVT5, D3D_TEXTURE), \
    NV_TFMT_DX8(FOURCC_NVS0, D3D_TEXTURE), \
    NV_TFMT_DX8(FOURCC_NVS1, D3D_TEXTURE), \
    NV_TFMT_DX8(FOURCC_NVS2, D3D_TEXTURE), \
    NV_TFMT_DX8(FOURCC_NVS3, D3D_TEXTURE), \
    NV_TFMT_DX8(FOURCC_NVS4, D3D_TEXTURE), \
    NV_TFMT_DX8(FOURCC_NVS5, D3D_TEXTURE),

#else // NVxn_SUPPORT_DX8

#define NV_TFMT_NVxn_DX8

#endif // NVxn_SUPPORT_DX8

#ifdef HILO_SUPPORT_DX7
#define NV_TFMT_HILO_FORMATS              NV_TFMT_NVHU, NV_TFMT_NVHS,
#else
#define NV_TFMT_HILO_FORMATS
#endif

#ifdef HILO_SUPPORT_DX8
#define NV_TFMT_HILO_FORMATS_DX8          NV_TFMT_NVHU_DX8, NV_TFMT_NVHS_DX8,
#else
#define NV_TFMT_HILO_FORMATS_DX8
#endif

#endif  // !TEXFORMAT_CRD --------------------------------------------

#define NV_TFMT_Q8W8V8U8_DX8              NV_TFMT_DX8(D3DFMT_Q8W8V8U8, D3D_TEXTURE)

#define NV_TFMT_Z16                       NV_TFMT_DX8(D3DFMT_D16_LOCKABLE, D3DFORMAT_OP_ZSTENCIL)
#define NV_TFMT_Z24_S8                    NV_TFMT_DX8(D3DFMT_D24S8, D3DFORMAT_OP_ZSTENCIL)
#define NV_TFMT_Z24                       NV_TFMT_DX8(D3DFMT_D24X8, D3DFORMAT_OP_ZSTENCIL)

// Multisample formats
#define NV_TFMT_R5G6B5_DX8_KELVIN_MULTISAMPLE    NV_TFMT_DX8_KELVIN_MULTISAMPLE(D3DFMT_R5G6B5,(D3DFORMAT_OP_VOLUMETEXTURE | D3D_RENDER_TEXTURE | D3D_BACK_BUFFER | D3D_FRONT_BUFFER ))
#define NV_TFMT_X8R8G8B8_DX8_KELVIN_MULTISAMPLE  NV_TFMT_DX8_KELVIN_MULTISAMPLE(D3DFMT_X8R8G8B8,(D3DFORMAT_OP_VOLUMETEXTURE | D3D_RENDER_TEXTURE | D3D_FRONT_BUFFER | D3D_BACK_BUFFER))
#define NV_TFMT_A8R8G8B8_DX8_KELVIN_MULTISAMPLE  NV_TFMT_DX8_KELVIN_MULTISAMPLE(D3DFMT_A8R8G8B8,(D3DFORMAT_OP_VOLUMETEXTURE | D3D_RENDER_TEXTURE | D3D_BACK_BUFFER))

#define NV_TFMT_Z16_KELVIN_MULTISAMPLE           NV_TFMT_DX8_KELVIN_MULTISAMPLE(D3DFMT_D16,   D3DFORMAT_OP_ZSTENCIL | D3DFORMAT_OP_ZSTENCIL_WITH_ARBITRARY_COLOR_DEPTH)
#define NV_TFMT_Z24_S8_KELVIN_MULTISAMPLE        NV_TFMT_DX8_KELVIN_MULTISAMPLE(D3DFMT_D24S8, D3DFORMAT_OP_ZSTENCIL | D3DFORMAT_OP_ZSTENCIL_WITH_ARBITRARY_COLOR_DEPTH)
#define NV_TFMT_Z24_KELVIN_MULTISAMPLE           NV_TFMT_DX8_KELVIN_MULTISAMPLE(D3DFMT_D24X8, D3DFORMAT_OP_ZSTENCIL | D3DFORMAT_OP_ZSTENCIL_WITH_ARBITRARY_COLOR_DEPTH)

#define NV_TFMT_R5G6B5_DX8_CELSIUS_MULTISAMPLE    NV_TFMT_DX8_CELSIUS_MULTISAMPLE(D3DFMT_R5G6B5,(D3DFORMAT_OP_VOLUMETEXTURE | D3D_RENDER_TEXTURE | D3D_BACK_BUFFER | D3D_FRONT_BUFFER ))
#define NV_TFMT_X8R8G8B8_DX8_CELSIUS_MULTISAMPLE  NV_TFMT_DX8_CELSIUS_MULTISAMPLE(D3DFMT_X8R8G8B8,(D3DFORMAT_OP_VOLUMETEXTURE | D3D_RENDER_TEXTURE | D3D_FRONT_BUFFER | D3D_BACK_BUFFER))
#define NV_TFMT_A8R8G8B8_DX8_CELSIUS_MULTISAMPLE  NV_TFMT_DX8_CELSIUS_MULTISAMPLE(D3DFMT_A8R8G8B8,(D3DFORMAT_OP_VOLUMETEXTURE | D3D_RENDER_TEXTURE | D3D_BACK_BUFFER))

#define NV_TFMT_Z16_CELSIUS_MULTISAMPLE           NV_TFMT_DX8_CELSIUS_MULTISAMPLE(D3DFMT_D16,   D3DFORMAT_OP_ZSTENCIL)
#define NV_TFMT_Z24_S8_CELSIUS_MULTISAMPLE        NV_TFMT_DX8_CELSIUS_MULTISAMPLE(D3DFMT_D24S8, D3DFORMAT_OP_ZSTENCIL)
#define NV_TFMT_Z24_CELSIUS_MULTISAMPLE           NV_TFMT_DX8_CELSIUS_MULTISAMPLE(D3DFMT_D24X8, D3DFORMAT_OP_ZSTENCIL)

#ifdef TEXFORMAT_CRD

// moved to NvFormats.cpp

#else  // !TEXFORMAT_CRD

/*
 * Potentially need 4bpp and 8bpp palettized textures.
 */

// Define the texture formats available on NV3 hardware.
// NV_TFMT_R5G6B5 texture format should be the last format in the
// structure so it can be easily enabled/disabled at runtime.
#define NV3_TEXTURE_FORMATS                NV_TFMT_X1R5G5B5,                \
                                           NV_TFMT_A1R5G5B5,                \
                                           NV_TFMT_A4R4G4B4,                \
                                           NV_TFMT_R5G6B5

// Define the texture formats available on NV4 hardware.
#define NV4_TEXTURE_FORMATS                NV_TFMT_X1R5G5B5,                \
                                           NV_TFMT_A1R5G5B5,                \
                                           NV_TFMT_A4R4G4B4,                \
                                           NV_TFMT_R5G6B5,                  \
                                           NV_TFMT_X8R8G8B8,                \
                                           NV_TFMT_A8R8G8B8

// Define the texture formats available in the celsius class
#define CELSIUS_TEXTURE_FORMATS            NV_TFMT_X1R5G5B5,                \
                                           NV_TFMT_A1R5G5B5,                \
                                           NV_TFMT_A4R4G4B4,                \
                                           NV_TFMT_R5G6B5,                  \
                                           NV_TFMT_X8R8G8B8,                \
                                           NV_TFMT_A8R8G8B8,                \
                                           NV_TFMT_DXT1,                    \
                                           NV_TFMT_DXT2,                    \
                                           NV_TFMT_DXT3,                    \
                                           NV_TFMT_DXT4,                    \
                                           NV_TFMT_DXT5,                    \
                                           NV_TFMT_NVxn                     \
                                           NV_TFMT_RGB8

#define CELSIUS_TEXTURE_FORMATS_NO_DXT     NV_TFMT_X1R5G5B5,                \
                                           NV_TFMT_A1R5G5B5,                \
                                           NV_TFMT_A4R4G4B4,                \
                                           NV_TFMT_R5G6B5,                  \
                                           NV_TFMT_X8R8G8B8,                \
                                           NV_TFMT_A8R8G8B8,                \
                                           NV_TFMT_NVxn                     \
                                           NV_TFMT_RGB8

#define CELSIUS_TEXTURE_FORMATS_DX8        NV_TFMT_X1R5G5B5_DX8,                    \
                                           NV_TFMT_A1R5G5B5_DX8,                    \
                                           NV_TFMT_A4R4G4B4_DX8,                    \
                                           NV_TFMT_R5G6B5_DX8_CELSIUS_MULTISAMPLE,  \
                                           NV_TFMT_X8R8G8B8_DX8_CELSIUS_MULTISAMPLE,\
                                           NV_TFMT_A8R8G8B8_DX8_CELSIUS_MULTISAMPLE,\
                                           NV_TFMT_DXT1_DX8,                        \
                                           NV_TFMT_DXT2_DX8,                        \
                                           NV_TFMT_DXT3_DX8,                        \
                                           NV_TFMT_DXT4_DX8,                        \
                                           NV_TFMT_DXT5_DX8,                        \
                                           NV_TFMT_Z16_CELSIUS_MULTISAMPLE,         \
                                           NV_TFMT_Z24_CELSIUS_MULTISAMPLE,         \
                                           NV_TFMT_Z24_S8_CELSIUS_MULTISAMPLE,      \
                                           NV_TFMT_NVxn_DX8                         \
                                           NV_TFMT_RGB8_DX8

#define CELSIUS_TEXTURE_FORMATS_NO_DXT_DX8 NV_TFMT_X1R5G5B5_DX8,                    \
                                           NV_TFMT_A1R5G5B5_DX8,                    \
                                           NV_TFMT_A4R4G4B4_DX8,                    \
                                           NV_TFMT_R5G6B5_DX8_CELSIUS_MULTISAMPLE,  \
                                           NV_TFMT_X8R8G8B8_DX8_CELSIUS_MULTISAMPLE,\
                                           NV_TFMT_A8R8G8B8_DX8_CELSIUS_MULTISAMPLE,\
                                           NV_TFMT_BUMPMAP_DV8_DU8_DX8,             \
                                           NV_TFMT_BUMPMAP_L6_DV5_DU5_DX8,          \
                                           NV_TFMT_BUMPMAP_L8_DV8_DU8_DX8,          \
                                           NV_TFMT_Z16_CELSIUS_MULTISAMPLE,         \
                                           NV_TFMT_Z24_CELSIUS_MULTISAMPLE,         \
                                           NV_TFMT_Z24_S8_CELSIUS_MULTISAMPLE,      \
                                           NV_TFMT_NVxn_DX8                         \
                                           NV_TFMT_RGB8_DX8

#if (NVARCH >= 0x020)

// Define the texture formats available in the kelvin class
#define KELVIN_TEXTURE_FORMATS             NV_TFMT_X1R5G5B5,                \
                                           NV_TFMT_A1R5G5B5,                \
                                           NV_TFMT_A4R4G4B4,                \
                                           NV_TFMT_R5G6B5,                  \
                                           NV_TFMT_X8R8G8B8,                \
                                           NV_TFMT_A8R8G8B8,                \
                                           NV_TFMT_BUMPMAP_DV8_DU8,         \
                                           NV_TFMT_BUMPMAP_L6_DV5_DU5,      \
                                           NV_TFMT_BUMPMAP_L8_DV8_DU8,      \
                                           NV_TFMT_DXT1,                    \
                                           NV_TFMT_DXT2,                    \
                                           NV_TFMT_DXT3,                    \
                                           NV_TFMT_DXT4,                    \
                                           NV_TFMT_DXT5,                    \
                                           NV_TFMT_NVxn                     \
                                           NV_TFMT_HILO_FORMATS             \
                                           NV_TFMT_RGB8

#define KELVIN_TEXTURE_FORMATS_NO_DXT      NV_TFMT_X1R5G5B5,                \
                                           NV_TFMT_A1R5G5B5,                \
                                           NV_TFMT_A4R4G4B4,                \
                                           NV_TFMT_R5G6B5,                  \
                                           NV_TFMT_X8R8G8B8,                \
                                           NV_TFMT_A8R8G8B8,                \
                                           NV_TFMT_BUMPMAP_DV8_DU8,         \
                                           NV_TFMT_BUMPMAP_L6_DV5_DU5,      \
                                           NV_TFMT_BUMPMAP_L8_DV8_DU8,      \
                                           NV_TFMT_NVxn                     \
                                           NV_TFMT_HILO_FORMATS             \
                                           NV_TFMT_RGB8

#define KELVIN_TEXTURE_FORMATS_DX8         NV_TFMT_X1R5G5B5_DX8,                   \
                                           NV_TFMT_A1R5G5B5_DX8,                   \
                                           NV_TFMT_A4R4G4B4_DX8,                   \
                                           NV_TFMT_R5G6B5_DX8_KELVIN_MULTISAMPLE,  \
                                           NV_TFMT_X8R8G8B8_DX8_KELVIN_MULTISAMPLE,\
                                           NV_TFMT_A8R8G8B8_DX8_KELVIN_MULTISAMPLE,\
                                           NV_TFMT_BUMPMAP_DV8_DU8_DX8,            \
                                           NV_TFMT_BUMPMAP_L6_DV5_DU5_DX8,         \
                                           NV_TFMT_BUMPMAP_L8_DV8_DU8_DX8,         \
                                           NV_TFMT_DXT1_DX8,                       \
                                           NV_TFMT_DXT2_DX8,                       \
                                           NV_TFMT_DXT3_DX8,                       \
                                           NV_TFMT_DXT4_DX8,                       \
                                           NV_TFMT_DXT5_DX8,                       \
                                           NV_TFMT_Z16_KELVIN_MULTISAMPLE,         \
                                           NV_TFMT_Z24_KELVIN_MULTISAMPLE,         \
                                           NV_TFMT_Z24_S8_KELVIN_MULTISAMPLE,      \
                                           NV_TFMT_Q8W8V8U8_DX8,                   \
                                           NV_TFMT_NVxn_DX8                        \
                                           NV_TFMT_HILO_FORMATS_DX8                \
                                           NV_TFMT_RGB8_DX8

#define KELVIN_TEXTURE_FORMATS_NO_DXT_DX8  NV_TFMT_X1R5G5B5_DX8,                   \
                                           NV_TFMT_A1R5G5B5_DX8,                   \
                                           NV_TFMT_A4R4G4B4_DX8,                   \
                                           NV_TFMT_R5G6B5_DX8_KELVIN_MULTISAMPLE,  \
                                           NV_TFMT_X8R8G8B8_DX8_KELVIN_MULTISAMPLE,\
                                           NV_TFMT_A8R8G8B8_DX8_KELVIN_MULTISAMPLE,\
                                           NV_TFMT_BUMPMAP_DV8_DU8_DX8,            \
                                           NV_TFMT_BUMPMAP_L6_DV5_DU5_DX8,         \
                                           NV_TFMT_BUMPMAP_L8_DV8_DU8_DX8,         \
                                           NV_TFMT_Z16_KELVIN_MULTISAMPLE,         \
                                           NV_TFMT_Z24_KELVIN_MULTISAMPLE,         \
                                           NV_TFMT_Z24_S8_KELVIN_MULTISAMPLE,      \
                                           NV_TFMT_Q8W8V8U8_DX8,                   \
                                           NV_TFMT_NVxn_DX8                        \
                                           NV_TFMT_HILO_FORMATS_DX8                \
                                           NV_TFMT_RGB8_DX8

#endif  // (NVARCH >= 0x020)

// number of 8-bit formats (common to all classes (for now at least))
#define NV_NUM_8BIT_TEXTURE_FORMATS        1

#endif  // !TEXFORMAT_CRD

#ifdef __cplusplus
}
#endif

#endif  // _NVTEXFMT_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\ddraw\common\inc\nvTexManage.h ===
// **************************************************************************
//
//       Copyright 1993-1999 NVIDIA, Corporation.  All rights reserved.
//
//     NOTICE TO USER:   The source code  is copyrighted under  U.S. and
//     international laws.  Users and possessors of this source code are
//     hereby granted a nonexclusive,  royalty-free copyright license to
//     use this code in individual and commercial software.
//
//     Any use of this source code must include,  in the user documenta-
//     tion and  internal comments to the code,  notices to the end user
//     as follows:
//
//       Copyright 1993-1999 NVIDIA, Corporation.  All rights reserved.
//
//     NVIDIA, CORPORATION MAKES NO REPRESENTATION ABOUT THE SUITABILITY
//     OF  THIS SOURCE  CODE  FOR ANY PURPOSE.  IT IS  PROVIDED  "AS IS"
//     WITHOUT EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORPOR-
//     ATION DISCLAIMS ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,
//     INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY, NONINFRINGE-
//     MENT,  AND FITNESS  FOR A PARTICULAR PURPOSE.   IN NO EVENT SHALL
//     NVIDIA, CORPORATION  BE LIABLE FOR ANY SPECIAL,  INDIRECT,  INCI-
//     DENTAL, OR CONSEQUENTIAL DAMAGES,  OR ANY DAMAGES  WHATSOEVER RE-
//     SULTING FROM LOSS OF USE,  DATA OR PROFITS,  WHETHER IN AN ACTION
//     OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,  ARISING OUT OF
//     OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOURCE CODE.
//
//     U.S. Government  End  Users.   This source code  is a "commercial
//     item,"  as that  term is  defined at  48 C.F.R. 2.101 (OCT 1995),
//     consisting  of "commercial  computer  software"  and  "commercial
//     computer  software  documentation,"  as such  terms  are  used in
//     48 C.F.R. 12.212 (SEPT 1995)  and is provided to the U.S. Govern-
//     ment only as  a commercial end item.   Consistent with  48 C.F.R.
//     12.212 and  48 C.F.R. 227.7202-1 through  227.7202-4 (JUNE 1995),
//     all U.S. Government End Users  acquire the source code  with only
//     those rights set forth herein.
//
// **************************************************************************
//
//  Module: nvTexManage.h
//        definitions and prototypes associated with texture management
//
//  History:
//        Craig Duttweiler      (bertrem)       3Dec99      created
//
// **************************************************************************

#ifdef TEX_MANAGE

// Texture Management Scheme Overview
// we keep multiple texture lists to allow different "classes"  of textures to be defined
// for eviction purposes. class 0 is evicted first; class N is evicted last. within each class,
// the LRU texture is evicted first and the MRU texture is evicted last. textures can be moved
// from one class to another (or entire class lists can be swapped/combined) as needed.

// the currect implementation will classify textures according to the frame in which they were
// most recently used:

// class 0 : textures used in neither the current nor previous frames
// class 1 : textures most recently used in the current frame
// class 2 : textures most recently used in the last frame

#define NV_TEXMAN_NUM_CLASSES   3
#define NV_TEXMAN_DEFAULT_CLASS 1  // the class to which new and "touched" textures get added

// eviction protocols

#define NV_TEXMAN_EVICTION_PROTOCOL_PASSIVE     0  // evict only what we can without syncing or changing contexts
#define NV_TEXMAN_EVICTION_PROTOCOL_AGGRESSIVE  1  // force hardware to sync and relinquish control of each texture before eviction is attempted
#define NV_TEXMAN_EVICTION_PROTOCOL_SEVERE      2  // try to evict from other contexts too
#define NV_TEXMAN_EVICTION_PROTOCOL_ANY         3  // try all protocols in order of increasing severity until eviction succeeds

typedef struct _NV_TEXMAN_DATA {

    DWORD     dwTextureListInUse;

    // pointers to the the ends of the class lists
    CTexture *pTextureLRU[NV_TEXMAN_NUM_CLASSES];
    CTexture *pTextureMRU[NV_TEXMAN_NUM_CLASSES];

    // the next texture to evict. this pointer should ALWAYS be non-NULL unless
    // all texture lists are empty and there is truly nothing to evict.
    CTexture *pTextureToEvict;

} NV_TEXMAN_DATA, *PNV_TEXMAN_DATA;

// prototypes

BOOL nvTexManageInit          (PNVD3DCONTEXT pContext);
BOOL nvTexManageAddTexture    (PNVD3DCONTEXT pContext, CTexture *pTex, DWORD dwClass);
BOOL nvTexManageRemoveTexture (CTexture *pTex);
BOOL nvTexManageAdvanceList   (PNVD3DCONTEXT pContext, DWORD dwList);
BOOL nvTexManageResetPtr      (PNVD3DCONTEXT pContext);
BOOL nvTexManageAdvancePtr    (PNVD3DCONTEXT pContext);
BOOL nvTexManageEvict         (PNVD3DCONTEXT pContext, DWORD dwProtocol);
BOOL nvTexManageEvictAll      (PNVD3DCONTEXT pContext);
BOOL nvTexManageFetch         (PNVD3DCONTEXT pContext, CTexture *pTexture);
BOOL nvTexManageTouch         (PNVD3DCONTEXT pContext, CTexture *pTexture);
BOOL nvTexManageSceneEnd      (PNVD3DCONTEXT pContext);

#endif  // TEX_MANAGE
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\ddraw\common\inc\nvVideoPort.h ===
/*
 * (C) Copyright NVIDIA Corporation Inc., 1996,1997,1998. All rights reserved.
 */
/********************************* Direct 3D *******************************\
*                                                                           *
* Module: nvVideoPort.h                                                     *
*    Definition file for:                                                   *
*       vp.c                                                                *
*    Suggested new name:                                                    *
*       nvVideoPort.c                                                       *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*       Paul van der Kouwe 06/16/99 - created.                              *
*                                                                           *
\***************************************************************************/

#ifndef __NVVIDEOPORT_H_
#define __NVVIDEOPORT_H_

#ifdef __cplusplus
extern "C" {
#endif

// public
DWORD __stdcall CanCreateVideoPort32       (LPDDHAL_CANCREATEVPORTDATA);
DWORD __stdcall CreateVideoPort32          (LPDDHAL_CREATEVPORTDATA);
DWORD __stdcall FlipVideoPort32            (LPDDHAL_FLIPVPORTDATA);
DWORD __stdcall GetVideoPortBandwidth32    (LPDDHAL_GETVPORTBANDWIDTHDATA);
DWORD __stdcall GetVideoPortInputFormat32  (LPDDHAL_GETVPORTINPUTFORMATDATA);
DWORD __stdcall GetVideoPortOutputFormat32 (LPDDHAL_GETVPORTOUTPUTFORMATDATA);
DWORD __stdcall GetVideoPortField32        (LPDDHAL_GETVPORTFIELDDATA);
DWORD __stdcall GetVideoPortLine32         (LPDDHAL_GETVPORTLINEDATA);
DWORD __stdcall GetVideoPortConnectInfo    (LPDDHAL_GETVPORTCONNECTDATA);
DWORD __stdcall DestroyVideoPort32         (LPDDHAL_DESTROYVPORTDATA);
DWORD __stdcall GetVideoPortFlipStatus32   (LPDDHAL_GETVPORTFLIPSTATUSDATA);
DWORD __stdcall UpdateVideoPort32          (LPDDHAL_UPDATEVPORTDATA);
DWORD __stdcall WaitForVideoPortSync32     (LPDDHAL_WAITFORVPORTSYNCDATA);
DWORD __stdcall GetVideoSignalStatus32     (LPDDHAL_GETVPORTSIGNALDATA);

#ifdef __cplusplus
}
#endif // __cplusplus

#endif // __NVVIDEOPORT_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\ddraw\common\inc\nvTimer.h ===
// **************************************************************************
//
//       Copyright 1993-1999 NVIDIA, Corporation.  All rights reserved.
//
//     NOTICE TO USER:   The source code  is copyrighted under  U.S. and
//     international laws.  Users and possessors of this source code are
//     hereby granted a nonexclusive,  royalty-free copyright license to
//     use this code in individual and commercial software.
//
//     Any use of this source code must include,  in the user documenta-
//     tion and  internal comments to the code,  notices to the end user
//     as follows:
//
//       Copyright 1993-1999 NVIDIA, Corporation.  All rights reserved.
//
//     NVIDIA, CORPORATION MAKES NO REPRESENTATION ABOUT THE SUITABILITY
//     OF  THIS SOURCE  CODE  FOR ANY PURPOSE.  IT IS  PROVIDED  "AS IS"
//     WITHOUT EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORPOR-
//     ATION DISCLAIMS ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,
//     INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY, NONINFRINGE-
//     MENT,  AND FITNESS  FOR A PARTICULAR PURPOSE.   IN NO EVENT SHALL
//     NVIDIA, CORPORATION  BE LIABLE FOR ANY SPECIAL,  INDIRECT,  INCI-
//     DENTAL, OR CONSEQUENTIAL DAMAGES,  OR ANY DAMAGES  WHATSOEVER RE-
//     SULTING FROM LOSS OF USE,  DATA OR PROFITS,  WHETHER IN AN ACTION
//     OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,  ARISING OUT OF
//     OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOURCE CODE.
//
//     U.S. Government  End  Users.   This source code  is a "commercial
//     item,"  as that  term is  defined at  48 C.F.R. 2.101 (OCT 1995),
//     consisting  of "commercial  computer  software"  and  "commercial
//     computer  software  documentation,"  as such  terms  are  used in
//     48 C.F.R. 12.212 (SEPT 1995)  and is provided to the U.S. Govern-
//     ment only as  a commercial end item.   Consistent with  48 C.F.R.
//     12.212 and  48 C.F.R. 227.7202-1 through  227.7202-4 (JUNE 1995),
//     all U.S. Government End Users  acquire the source code  with only
//     those rights set forth herein.
//
// **************************************************************************
//
//  Module: nvTimer.h
//        definition of a timing mechanism
//
//  History:
//      Ben DeWaal            (ben)          ??           created
//      Craig Duttweiler      (bertrem)      10Apr00      moved to this file
//
// **************************************************************************

class CNVTimer
{
protected:
    __int64 m_qwTime[64];

public:
    inline void reset (int iTimeSlot)
    {
        m_qwTime[iTimeSlot] = 0;
    }

    inline void start (int iTimeSlot)
    {
        __int64 i64;
        __asm
        {
            push eax
            push edx
            rdtsc
            mov dword ptr [i64],eax
            mov dword ptr [i64+4],edx
            pop edx
            pop eax
        }
        m_qwTime[iTimeSlot] = -i64;
    }

    inline void restart (int iTimeSlot)
    {
        __int64 i64;
        __asm
        {
            push eax
            push edx
            rdtsc
            mov dword ptr [i64],eax
            mov dword ptr [i64+4],edx
            pop edx
            pop eax
        }
        m_qwTime[iTimeSlot] -= i64;
    }

    inline void stop (int iTimeSlot)
    {
        __int64 i64;
        __asm
        {
            push eax
            push edx
            rdtsc
            mov dword ptr [i64],eax
            mov dword ptr [i64+4],edx
            pop edx
            pop eax
        }
        m_qwTime[iTimeSlot] += i64;
    }

    inline double getTime (int iTimeSlot)
    {
        return double(m_qwTime[iTimeSlot]) / (1e6 * double(pDriverData->nvD3DPerfData.dwProcessorSpeed));
    }
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\ddraw\common\inc\nvVB.h ===
/***************************************************************************\
|*                                                                           *|
|*       Copyright 1993-1999 NVIDIA, Corporation.  All rights reserved.      *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.  Users and possessors of this source code are     *|
|*     hereby granted a nonexclusive,  royalty-free copyright license to     *|
|*     use this code in individual and commercial software.                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*       Copyright 1993-1999 NVIDIA, Corporation.  All rights reserved.      *|
|*                                                                           *|
|*     NVIDIA, CORPORATION MAKES NO REPRESENTATION ABOUT THE SUITABILITY     *|
|*     OF  THIS SOURCE  CODE  FOR ANY PURPOSE.  IT IS  PROVIDED  "AS IS"     *|
|*     WITHOUT EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORPOR-     *|
|*     ATION DISCLAIMS ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,     *|
|*     INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY, NONINFRINGE-     *|
|*     MENT,  AND FITNESS  FOR A PARTICULAR PURPOSE.   IN NO EVENT SHALL     *|
|*     NVIDIA, CORPORATION  BE LIABLE FOR ANY SPECIAL,  INDIRECT,  INCI-     *|
|*     DENTAL, OR CONSEQUENTIAL DAMAGES,  OR ANY DAMAGES  WHATSOEVER RE-     *|
|*     SULTING FROM LOSS OF USE,  DATA OR PROFITS,  WHETHER IN AN ACTION     *|
|*     OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,  ARISING OUT OF     *|
|*     OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOURCE CODE.     *|
|*                                                                           *|
|*     U.S. Government  End  Users.   This source code  is a "commercial     *|
|*     item,"  as that  term is  defined at  48 C.F.R. 2.101 (OCT 1995),     *|
|*     consisting  of "commercial  computer  software"  and  "commercial     *|
|*     computer  software  documentation,"  as such  terms  are  used in     *|
|*     48 C.F.R. 12.212 (SEPT 1995)  and is provided to the U.S. Govern-     *|
|*     ment only as  a commercial end item.   Consistent with  48 C.F.R.     *|
|*     12.212 and  48 C.F.R. 227.7202-1 through  227.7202-4 (JUNE 1995),     *|
|*     all U.S. Government End Users  acquire the source code  with only     *|
|*     those rights set forth herein.                                        *|
|*                                                                           *|
 \***************************************************************************/
#ifndef _nvVB_h
#define _nvVB_h

#ifdef __cplusplus
extern "C"
{
#endif

/*****************************************************************************
 * constants
 */
#define VB_CACHE_SIZE               32              // # of software cache entries (no more than 256)
#define TOTAL_VB_RENAME             16

/*****************************************************************************
 * CVertexBuffer
 *
 * d3d vertex buffer internal structure
 */
class CVertexBuffer
{
    /*
     * constants
     */
public:
    enum
    {
        FLAG_D3D_LOCKED         = 1,    // d3d has lock (affects renaming policy)
        FLAG_D3D_IMPLICIT       = 2,    // d3d implicit VB
        FLAG_DX6                = 4,    // dx6 vertex buffer
        FLAG_MODIFIED           = 8,    // set when we believe the contents of the buffer has changed
        FLAG_RENAME2SYSTEM      = 16,   // when set, we will attempt to move the VB to system memory (used to CM hack performance)
        FLAG_DYNAMIC            = 32,   // dynamic buffer
        FLAG_SUPERTRIOWNSMEM    = 64,   // supertri owns the look aside buffer
        FLAG_ALIASLOCKED        = 128   // NV_AGP alias lock
    };

public:
    struct STVERTEX
    {
        float x,y,z,reserved;
    };

    /*
     * members
     */
protected:
// bank
#ifdef MCFD

#else 
    DWORD            m_Cache_CSS_dwFlags;             // Copy of CSimpleSurface flags
    CSimpleSurface  *m_Cache_CSS_pActiveSurface;      // Pointer to the currently active surface
#endif //MCFD
    CNvObject       *m_pWrapperObject;
    DWORD            m_dwFlags;
    DWORD            m_dwVertexStride;
    void            *m_pSuperTriLookAsideBuffer;
    DWORD            m_dwSuperTriLookAsideBufferSize;
    DWORD            m_dwLockCount;
// bank
    DWORD          __pad[8];
// bank

#ifdef MCFD
	void * m_data;  //pointer to the whole bitmap
public:
	CBlockList m_blockList;   // list header of the blocks belonging to the renaming chain

    inline DWORD           getContextDMA     (void)   { return m_blockList.m_pActive->getContextDMA(); }
    inline DWORD           getHeapLocation   (void)   { return m_blockList.m_pActive->getHeapLocation(); }
    inline DWORD           getOffset         (void)   { return m_blockList.m_pActive->getOffset();  }
    DWORD                  getAddress        (void);
    inline DWORD           getfpVidMem       (void)   { return m_blockList.m_pActive->getAddress(); }
    inline DWORD           getSize           (void)   { return m_blockList.m_pActive->getSize();    }

    inline BOOL            hwCanRead(void)            { return m_blockList.m_pActive->hwCanRead(); }

    void  LockForGPU             (DWORD dwAcess);
    void  UnlockForGPU           (void);

    void  LockForCPU            (DWORD dwAcess, DWORD RenamingPolicy=RENAME_POLICY_NO_COPY);
    void  UnlockForCPU          (void);


#else
    CComplexSurface<TOTAL_VB_RENAME> m_Surface;

    /*
     * helpers
     */
public:
    inline CSimpleSurface* getSurface        (void)   { return m_Surface.getActiveSurface(); }
    inline DWORD           getContextDMA     (void)   { return m_Surface.getActiveSurface()->getContextDMA(); }
    inline DWORD           getHeapLocation   (void)   { return m_Surface.getActiveSurface()->getHeapLocation(); }
    inline DWORD           getOffset         (void)   { return m_Surface.getActiveSurface()->getOffset();  }
    inline DWORD           getAddress        (void)   { return m_Surface.getActiveSurface()->getAddress(); }
    inline DWORD           getfpVidMem       (void)   { return m_Surface.getActiveSurface()->getfpVidMem(); }
    inline DWORD           getSize           (void)   { return m_Surface.getActiveSurface()->getSize();    }
#endif
    inline CNvObject*      getWrapper        (void)   { return (m_pWrapperObject); }

    /*
     * methods
     */
public:
           BOOL  prepareSuperTriLookAsideBuffer (void);
           void  destroySuperTriLookAsideBuffer (void);
    inline void* getSuperTriLookAsideBuffer     (void)    const {   return m_pSuperTriLookAsideBuffer;   }
    inline void  setSuperTriLookAsideBuffer     (void *p)       {   m_pSuperTriLookAsideBuffer = p;
                                                                    // this should never assert, but if it does, this simply means we should free the look aside buffer we already own
                                                                    nvAssert (!(m_dwFlags & FLAG_SUPERTRIOWNSMEM));
                                                                }

#ifdef MCFD
    BOOL  create             (DWORD dwSize, DWORD dwAllowedHeaps, DWORD dwPreferredHeap);
    BOOL  destroy            (void);
    void  own                (DWORD dwAddress, DWORD dwSize, DWORD dwHeapLocation);
    void  disown             (void) ;
    void  tagRenameEnable    (DWORD dwRenameType, DWORD dwPreAllocCount=1);
#else
    inline BOOL  create             (DWORD dwSize, DWORD dwAllowedHeaps, DWORD dwPreferredHeap)
                                                                {   BOOL bCreated =  m_Surface.create (m_pWrapperObject,
                                                                                                       dwSize,
                                                                                                       dwAllowedHeaps,
                                                                                                       dwPreferredHeap
#ifdef CAPTURE
                                                                                                      ,CAPTURE_SURFACE_KIND_VERTEX
#endif
                                                                                                       );
                                                                    updateCachedValues();
                                                                    return bCreated;
                                                                }


    inline BOOL  destroy            (void)                      {   destroySuperTriLookAsideBuffer();
                                                                    return (m_Surface.destroy());
                                                                }

    inline void  own                (DWORD dwAddress, DWORD dwSize, DWORD dwHeapLocation)
                                                                {   m_Surface.own(dwAddress,dwSize,1,dwHeapLocation,FALSE);
                                                                    updateCachedValues();
                                                                }

    inline void  disown             (void)                      {   m_Surface.disown();   }

    inline void  tagRenameEnable    (DWORD dwRenameType, DWORD dwPreAllocCount=1)
                                                                {   m_Surface.tagRenameEnable (dwRenameType, dwPreAllocCount);   }
#endif

#ifndef MCFD
    inline void  hwLock             (DWORD dwAccess)            {   m_Surface.hwLock (dwAccess);   }
    inline void  hwUnlock           (void)                      {   m_Surface.hwUnlock();   }

    inline void  cpuLock            (DWORD dwAccess)            {   m_Surface.cpuLock (dwAccess);
                                                                    updateCachedValues();
                                                                    if (pDriverData->nvD3DPerfData.dwNVClasses & NVCLASS_FAMILY_KELVIN) {
                                                                        nvglSetNv20KelvinInvalidateVertexCache (NV_DD_KELVIN);
                                                                    }
                                                                    else if (pDriverData->nvD3DPerfData.dwNVClasses & NVCLASS_FAMILY_CELSIUS) {
                                                                        nvglSetNv10CelsiusInvalidateVertexCache (NV_DD_CELSIUS);
                                                                    }
                                                                }

    inline void  cpuUnlock          (void)                      {   m_Surface.cpuUnlock();   }
#endif

    inline void  tagD3DLocked       (void)                      {   m_dwFlags |= FLAG_D3D_LOCKED;         }
    inline void  tagD3DUnlocked     (void)                      {   m_dwFlags &= ~FLAG_D3D_LOCKED;        }
    inline BOOL  isD3DLocked        (void) const                {   return (m_dwFlags & FLAG_D3D_LOCKED); }

    inline void  tagD3DImplicit     (void)                      {   m_dwFlags |= FLAG_D3D_IMPLICIT;         }
    inline BOOL  isD3DImplicit      (void) const                {   return (m_dwFlags & FLAG_D3D_IMPLICIT); }

    inline void  tagDX6             (void)                      {   m_dwFlags |= FLAG_DX6;         }
    inline BOOL  isDX6              (void) const                {   return (m_dwFlags & FLAG_DX6); }

    inline void  tagModified        (void)                      {   m_dwFlags |=  FLAG_MODIFIED;        }
    inline void  tagNotModified     (void)                      {   m_dwFlags &= ~FLAG_MODIFIED;        }
    inline BOOL  isModified         (void) const                {   return (m_dwFlags & FLAG_MODIFIED); }

    inline void  tagAliasLocked     (void)                      {   m_dwFlags |=  FLAG_ALIASLOCKED;        }
    inline void  tagNotAliasLocked  (void)                      {   m_dwFlags &= ~FLAG_ALIASLOCKED;        }
    inline BOOL  isAliasLocked      (void) const                {   return (m_dwFlags & FLAG_ALIASLOCKED); }

    inline void  tagRenameToSystem  (void)                      {   m_dwFlags |= FLAG_RENAME2SYSTEM;         }
    inline void  tagRenamedToSystem (void)                      {   m_dwFlags &= ~FLAG_RENAME2SYSTEM;        }
    inline BOOL  mustRenameToSystem (void) const                {   return (m_dwFlags & FLAG_RENAME2SYSTEM); }

    inline void  tagDynamic         (void)                      {   m_dwFlags |= FLAG_DYNAMIC;         }
    inline BOOL  isDynamic          (void) const                {   return (m_dwFlags & FLAG_DYNAMIC); }

    inline void  setVertexStride    (DWORD dw)                  {   m_dwVertexStride = dw;     }
    inline DWORD getVertexStride    (void) const                {   return (m_dwVertexStride); }

    inline void  bumpLockCount      (void)                      {   m_dwLockCount++;        }
    inline DWORD getLockCount       (void) const                {   return (m_dwLockCount); }

#ifdef MCFD

    inline void  updateCachedValues (void)                      {   
                                                                }

    inline bool  cachedhwCanRead    (void)                      {   return (m_blockList.m_pActive->getFlags() & CSimpleSurface::HEAP_LOCATION_MASK) != CSimpleSurface::HEAP_SYS;   }
    inline void  prefetchSurface() {};

#else

    // SK - The following are used to prefetch the current, active vertex buffer
    inline void  updateCachedValues (void)                      {   CSimpleSurface *p = m_Surface.getActiveSurface();
                                                                    m_Cache_CSS_dwFlags = p->getFlags();
                                                                    m_Cache_CSS_pActiveSurface = p;
                                                                }

    inline bool  cachedhwCanRead    (void)                      {   return (m_Cache_CSS_dwFlags & CSimpleSurface::HEAP_LOCATION_MASK) != CSimpleSurface::HEAP_SYS;   }

    #define rEAX                    0
    #define rEDX                    2
    #define mREG(x)                 ((x) << 3)
    #define rmIND8(x)               (0x40 | (x))
    #define prefetch_rm8(h,rm,ofs)  __asm _emit 0x0f __asm _emit 0x18 __asm _emit (mREG(h) | (rm)) __asm _emit (ofs)

    inline void  prefetchSurface    (void) const                {   if (pDriverData->nvD3DPerfData.dwCPUFeatureSet & FS_KATMAI) {
                                                                        __asm
                                                                        {
                                                                            mov eax, this
                                                                            lea edx, [eax].m_Surface
                                                                            prefetch_rm8(1, rmIND8(rEAX), 0)
                                                                            prefetch_rm8(0, rmIND8(rEAX), 32)
                                                                            mov edx, [eax]CVertexBuffer.m_Cache_CSS_pActiveSurface
                                                                            prefetch_rm8(1, rmIND8(rEDX), 0)
                                                                            prefetch_rm8(1, rmIND8(rEDX), 32)
                                                                        }
                                                                    }

                                                                }
    #undef rEAX
    #undef rEDX
    #undef mREG
    #undef rmIND8
    #undef prefetch_rm8
#endif
    /*
     * construction
     */
public:
    CVertexBuffer  (CNvObject *pWrapperObject = NULL);
    ~CVertexBuffer (void);

};

/*****************************************************************************
 * CCommandBuffer
 *
 * d3d system memory wrapper (command and execute buffers)
 */
class CCommandBuffer
{
    /*
     * members
     */
protected:
// bank
    CSimpleSurface             m_Surface;
// bank
    CNvObject                 *m_pWrapperObject;
    LPDDRAWI_DDRAWSURFACE_LCL  m_pDDSurfaceLcl;
    DWORD                      _pad0[6];

    /*
     * helpers
     */
public:
    inline LPDDRAWI_DDRAWSURFACE_LCL getDDSurfaceLcl (void) const { return m_pDDSurfaceLcl; }

    inline CSimpleSurface* getSurface (void)                 { return &m_Surface; }
    inline DWORD           getAddress (void)           const { return m_Surface.getAddress(); }
    inline DWORD           getSize    (void)           const { return m_Surface.getSize();    }

    inline void            cpuLock    (DWORD dwAccess)       { m_Surface.cpuLock (dwAccess); }
    inline void            cpuUnlock  (void)                 { m_Surface.cpuUnlock(); }

    /*
     * methods
     */
public:
    inline BOOL create  (DWORD dwSize)  { return m_Surface.create (dwSize, 1, 1, 0,
                                                                   CSimpleSurface::HEAP_SYS,
                                                                   CSimpleSurface::HEAP_SYS,
                                                                   CSimpleSurface::ALLOCATE_SIMPLE
#ifdef CAPTURE
                                                                  ,CAPTURE_SURFACE_KIND_COMMAND
#endif
                                                                   ); }
    inline BOOL destroy (void)          { return m_Surface.destroy(); }

    inline void own     (DWORD dwAddress, DWORD dwSize, DWORD dwHeapLocation)
                                                               { m_Surface.own(dwAddress, dwSize, 1, dwHeapLocation, FALSE); }

    inline BOOL isOwner (void)    const { return m_Surface.isOwner(); }


    inline BOOL growBy  (DWORD dwSize, BOOL bPreserveContents) { return m_Surface.growBy(dwSize, bPreserveContents); }

    /*
     * construction
     */
public:
    CCommandBuffer (CNvObject                 *pWrapperObject,
                    LPDDRAWI_DDRAWSURFACE_LCL  pDDSurfaceLcl);
    ~CCommandBuffer (void);
};

/*****************************************************************************
 * D3D callbacks
 */
DWORD __stdcall D3DCanCreateExecuteBuffer32 (LPDDHAL_CANCREATESURFACEDATA pCanCreateSurfaceData);
DWORD __stdcall D3DCreateExecuteBuffer32    (LPDDHAL_CREATESURFACEDATA    pCreateSurfaceData);
DWORD __stdcall D3DDestroyExecuteBuffer32   (LPDDHAL_DESTROYSURFACEDATA   pDestroySurfaceData);
DWORD __stdcall D3DLockExecuteBuffer32      (LPDDHAL_LOCKDATA             pLockData);
DWORD __stdcall D3DUnlockExecuteBuffer32    (LPDDHAL_UNLOCKDATA           pUnlockData);

#ifdef __cplusplus
}
#endif

#endif // _nvVB_h
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\ddraw\common\inc\nvVShad.h ===
/***************************************************************************\
|*                                                                           *|
|*       Copyright 1993-1999 NVIDIA, Corporation.  All rights reserved.      *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.  Users and possessors of this source code are     *|
|*     hereby granted a nonexclusive,  royalty-free copyright license to     *|
|*     use this code in individual and commercial software.                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*       Copyright 1993-1999 NVIDIA, Corporation.  All rights reserved.      *|
|*                                                                           *|
|*     NVIDIA, CORPORATION MAKES NO REPRESENTATION ABOUT THE SUITABILITY     *|
|*     OF  THIS SOURCE  CODE  FOR ANY PURPOSE.  IT IS  PROVIDED  "AS IS"     *|
|*     WITHOUT EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORPOR-     *|
|*     ATION DISCLAIMS ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,     *|
|*     INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY, NONINFRINGE-     *|
|*     MENT,  AND FITNESS  FOR A PARTICULAR PURPOSE.   IN NO EVENT SHALL     *|
|*     NVIDIA, CORPORATION  BE LIABLE FOR ANY SPECIAL,  INDIRECT,  INCI-     *|
|*     DENTAL, OR CONSEQUENTIAL DAMAGES,  OR ANY DAMAGES  WHATSOEVER RE-     *|
|*     SULTING FROM LOSS OF USE,  DATA OR PROFITS,  WHETHER IN AN ACTION     *|
|*     OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,  ARISING OUT OF     *|
|*     OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOURCE CODE.     *|
|*                                                                           *|
|*     U.S. Government  End  Users.   This source code  is a "commercial     *|
|*     item,"  as that  term is  defined at  48 C.F.R. 2.101 (OCT 1995),     *|
|*     consisting  of "commercial  computer  software"  and  "commercial     *|
|*     computer  software  documentation,"  as such  terms  are  used in     *|
|*     48 C.F.R. 12.212 (SEPT 1995)  and is provided to the U.S. Govern-     *|
|*     ment only as  a commercial end item.   Consistent with  48 C.F.R.     *|
|*     12.212 and  48 C.F.R. 227.7202-1 through  227.7202-4 (JUNE 1995),     *|
|*     all U.S. Government End Users  acquire the source code  with only     *|
|*     those rights set forth herein.                                        *|
|*                                                                           *|
 \***************************************************************************/
#ifndef _nvVShad_h
#define _nvVShad_h

#include "../../../common/inc/vtxpgmcomp.h"
#include "nvDbg.h"

#ifdef __cplusplus
extern "C"
{
#endif

typedef struct v_shader_register{  //replace with DX define when I find it HMH
    float x;
    float y;
    float z;
    float w;
} VSHADERREGISTER, *PVSHADERREGISTER;

// vertex attribute source info
typedef struct _VASOURCEINFO {
    DWORD dwStream;    // the stream from which this attribute gets its values
    DWORD dwOffset;    // the offset (in bytes) within a component from which the values come
    DWORD dwType;      // the type of data loaded into this attribute
    DWORD dwSrc;       // for tessellator types -- src register for a normal/uv autocalc
    DWORD flag;        // type of autocalc   0=none, 1=normal, 2=autotex
} VASOURCEINFO;

//---------------------------------------------------------------------------

class CVertexShader
{
public:

    enum {
        AUTONONE      = 0,
        AUTONORMAL    = 1,
        AUTOTEXCOORD  = 2,
    };

    enum {
        VA_STREAM_NONE = 0xFFFFFFFF
    };

    VASOURCEINFO        m_vaSourceData[NV_CAPS_MAX_STREAMS];  // sources of the data loaded into the 16 vertex attribute registers

    ParsedProgram       m_ParsedProgram;
    VertexProgramOutput m_ProgramOutput;
    VSHADERREGISTER     m_Attrib[16];
    VSHADERREGISTER     m_Result[15];

    char                m_numConsts            [D3DVS_CONSTREG_MAX_V1_1]; // number of constants set from each index
    VSHADERREGISTER     m_vertexShaderConstants[D3DVS_CONSTREG_MAX_V1_1]; // actual constants

#if (NVARCH >= 0x020)
    PKELVIN_PROGRAM       m_pKelvinProgram;      // compiled kelvin meta-code
#endif

protected:

    DWORD             m_dwHandle;
    DWORD             m_dwFVF;
    DWORD             m_dwCodeSize;          // size of code   declaration
    DWORD            *m_pCodeData;           // ptr to code    declaration data
    DWORD             m_dwStride;            // the total size (in bytes) of all vertex attributes pulled from streams by this shader
    float             m_one, m_zero;
    BOOL              m_bHasConsts;

    VtxProgCompileX86    m_Caller;
    VtxProgCompileKelvin m_CallerKelvin;

public:

    BOOL create (PNVD3DCONTEXT pContext, DWORD dwHandle, DWORD dwStreamSize, DWORD dwCodeSize, DWORD *lpStream, DWORD *lpCode);
    BOOL create (PNVD3DCONTEXT pContext, DWORD dwFVF, DWORD dwHandle);
    BOOL reset ( void );

    CVertexShader(void);
    ~CVertexShader(void);

    inline BOOL  bVAExists            (DWORD dwReg)   {   return ((getVAStream(dwReg) != VA_STREAM_NONE) ? TRUE : FALSE);   }

    inline DWORD getVAStream          (DWORD dwReg)   {   return (m_vaSourceData[dwReg].dwStream);   }
    inline DWORD getVAOffset          (DWORD dwReg)   {   return (m_vaSourceData[dwReg].dwOffset);   }
    inline DWORD getVAType            (DWORD dwReg)   {   return (m_vaSourceData[dwReg].dwType);     }
    inline DWORD getVASrc             (DWORD dwReg)   {   return (m_vaSourceData[dwReg].dwSrc);      }
    inline char  getVAFlag            (DWORD dwReg)   {   return (m_vaSourceData[dwReg].flag);       }

    inline DWORD getAutoNormalStream  (void)          {   for (int i=0; i<NV_CAPS_MAX_STREAMS; i++) {
                                                              if (m_vaSourceData[i].flag == CVertexShader::AUTONORMAL) {
                                                                  return i;
                                                              }
                                                          }
                                                          return VA_STREAM_NONE;
                                                      }

    inline DWORD getAutoTextureStream (DWORD dwCount) {   for (int i=0; i<NV_CAPS_MAX_STREAMS; i++) {
                                                              if (m_vaSourceData[i].flag == CVertexShader::AUTOTEXCOORD) {
                                                                  if (dwCount == 0) return i;
                                                                  else dwCount--;
                                                              }
                                                          }
                                                          return VA_STREAM_NONE;
                                                      }

    inline DWORD getVASize            (DWORD dwReg)   {   if (bVAExists(dwReg)) {
                                                              switch (getVAType(dwReg)) {
                                                              case D3DVSDT_FLOAT1:   // 0
                                                                  return 1 * sizeof(DWORD);
                                                              case D3DVSDT_FLOAT2:   // 1
                                                                  return 2 * sizeof(DWORD);
                                                              case D3DVSDT_FLOAT3:   // 2
                                                                  return 3 * sizeof(DWORD);
                                                              case D3DVSDT_FLOAT4:   // 3
                                                                  return 4 * sizeof(DWORD);
                                                              case D3DVSDT_D3DCOLOR: // 4
                                                                  return 4 * sizeof(BYTE);
                                                              case D3DVSDT_UBYTE4:   // 5
                                                                  return 4 * sizeof(BYTE);
                                                              case D3DVSDT_SHORT2:   // 6
                                                                  return 2 * sizeof(SHORT);
                                                              case D3DVSDT_SHORT4:   // 7
                                                                  return 4 * sizeof(SHORT);
                                                              default:
                                                                  DPF("Unknown vertex array type: %d", getVAType(dwReg));
                                                                  nvAssert(0);
                                                                  return 0;
                                                              }
                                                          } else {
                                                              return 0;
                                                          }
                                                      }

    inline BOOL  hasProgram           (void)   const  {   return m_dwCodeSize ? TRUE : FALSE; }
    inline BOOL  hasConstants         (void)   const  {   return m_bHasConsts;                }
    inline DWORD getStride            (void)   const  {   return m_dwStride;                  }
    inline DWORD getHandle            (void)   const  {   return m_dwHandle;                  }
    inline DWORD getFVF               (void)   const  {   return m_dwFVF;                     }
    inline BOOL  isFvfShader          (void)   const  {   return !(m_dwHandle & 0x1);         }

    // This is temporary.  For the short-term we will have all FVFs share the
    // same vertex shader 0 ala DX7.
    // This may be replaced with a hash table lookup in Rel20.
    static inline DWORD getHandleFromFvf     (DWORD dwFvf)   { return 0ul; }

};

#ifdef __cplusplus
}
#endif

#endif // _nvVShad_h
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\ddraw\common\inc\nvtranslate.h ===
/*
 * Copyright 1993-1998 NVIDIA, Corporation.  All rights reserved.
 * THE INFORMATION CONTAINED HEREIN IS PROPRIETARY AND CONFIDENTIAL TO
 * NVIDIA, CORPORATION.  USE, REPRODUCTION OR DISCLOSURE TO ANY THIRD PARTY
 * IS SUBJECT TO WRITTEN PRE-APPROVAL BY NVIDIA, CORPORATION.
 */
/********************************* Direct 3D *******************************\
*                                                                           *
* Module: NVTRANSLATE.H                                                     *
*   declatations of constants and prototypes for tables needed to           *
*   translate from generic definitions (either NV or D3D) to HW-specific    *
*   definitions                                                             *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*       Craig Duttweiler    bertrem     03May99     created                 *
*                                                                           *
\***************************************************************************/

#ifndef _NVTRANSLATE_H_
#define _NVTRANSLATE_H_

#ifdef __cplusplus
extern "C" {
#endif

//--------------------------------------------------------------------------
// surface formats
//--------------------------------------------------------------------------

// generic names
// note these are all named by enumerating components from MSB to LSB.
// please keep it this way (despite what people in redmond do)!
#define NV_SURFACE_FORMAT_Y8                            0
#define NV_SURFACE_FORMAT_AY8                           1
#define NV_SURFACE_FORMAT_A1R5G5B5                      2
#define NV_SURFACE_FORMAT_X1R5G5B5                      3
#define NV_SURFACE_FORMAT_A4R4G4B4                      4
#define NV_SURFACE_FORMAT_R5G6B5                        5
#define NV_SURFACE_FORMAT_A8R8G8B8                      6
#define NV_SURFACE_FORMAT_X1A7R8G8B8                    7
#define NV_SURFACE_FORMAT_X8R8G8B8                      8
#define NV_SURFACE_FORMAT_I8_A1R5G5B5                   9
#define NV_SURFACE_FORMAT_I8_R5G6B5                     10
#define NV_SURFACE_FORMAT_I8_A4R4G4B4                   11
#define NV_SURFACE_FORMAT_I8_A8R8G8B8                   12
#define NV_SURFACE_FORMAT_DXT1_A1R5G5B5                 13
#define NV_SURFACE_FORMAT_DXT23_A8R8G8B8                14
#define NV_SURFACE_FORMAT_DXT45_A8R8G8B8                15
#define NV_SURFACE_FORMAT_IMAGE_A1R5G5B5                16
#define NV_SURFACE_FORMAT_IMAGE_R5G6B5                  17
#define NV_SURFACE_FORMAT_IMAGE_A8R8G8B8                18
#define NV_SURFACE_FORMAT_IMAGE_Y8                      19
#define NV_SURFACE_FORMAT_IMAGE_SY8                     20
#define NV_SURFACE_FORMAT_IMAGE_X7SY9                   21
#define NV_SURFACE_FORMAT_IMAGE_R8B8                    22
#define NV_SURFACE_FORMAT_IMAGE_G8B8                    23
#define NV_SURFACE_FORMAT_IMAGE_SG8SB8                  24
#define NV_SURFACE_FORMAT_Z16                           25
#define NV_SURFACE_FORMAT_Z24S8                         26
#define NV_SURFACE_FORMAT_Z24X8                         27
#define NV_SURFACE_FORMAT_DV8DU8                        28
#define NV_SURFACE_FORMAT_L6DV5DU5                      29
#define NV_SURFACE_FORMAT_X8L8DV8DU8                    30
#define NV_SURFACE_FORMAT_HILO_1_V16U16                 31
#define NV_SURFACE_FORMAT_HILO_HEMI_V16U16              32
#define NV_SURFACE_FORMAT_A8B8G8R8                      33
#define NV_SURFACE_FORMAT_UNKNOWN                       34 //used for sys surfaces we don't control

#define NV_SURFACE_FORMAT_COUNT                         35

// format to BPP conversion
extern const DWORD nvSurfaceFormatToBPP[NV_SURFACE_FORMAT_COUNT];

// generic -> HW surface format conversion tables
extern const DWORD nv052SurfaceFormat[NV_SURFACE_FORMAT_COUNT];
extern const DWORD nv053SurfaceFormat[NV_SURFACE_FORMAT_COUNT];
extern const DWORD nv056SurfaceFormat[NV_SURFACE_FORMAT_COUNT];
extern const DWORD nv062SurfaceFormat[NV_SURFACE_FORMAT_COUNT];
extern const DWORD nv077SurfaceFormat[NV_SURFACE_FORMAT_COUNT];
extern const DWORD nv089SurfaceFormat[NV_SURFACE_FORMAT_COUNT];
extern const DWORD nv097SurfaceFormat[NV_SURFACE_FORMAT_COUNT];

// generic -> HW texture format conversion tables
extern const DWORD nv054TextureFormat[NV_SURFACE_FORMAT_COUNT];
extern const DWORD nv055TextureFormat[NV_SURFACE_FORMAT_COUNT];
extern const DWORD nv056TextureFormat[NV_SURFACE_FORMAT_COUNT];
extern const DWORD nv097TextureFormat[NV_SURFACE_FORMAT_COUNT];

//--------------------------------------------------------------------------
// context DMAs
//--------------------------------------------------------------------------

// generic names
#define NV_CONTEXT_DMA_NONE                             0   // system memory
#define NV_CONTEXT_DMA_AGP_OR_PCI                       1   // pci / agp
#define NV_CONTEXT_DMA_VID                              2   // video

#define NV_CONTEXT_DMA_COUNT                            3

// generic -> HW texture format context DMA conversion tables
extern const DWORD nv054TextureContextDma[NV_CONTEXT_DMA_COUNT];
extern const DWORD nv055TextureContextDma[NV_CONTEXT_DMA_COUNT];
extern const DWORD nv056TextureContextDma[NV_CONTEXT_DMA_COUNT];
extern const DWORD nv097TextureContextDma[NV_CONTEXT_DMA_COUNT];
extern const DWORD nv056PaletteContextDma[NV_CONTEXT_DMA_COUNT];
extern const DWORD nv097PaletteContextDma[NV_CONTEXT_DMA_COUNT];

//--------------------------------------------------------------------------
// D3D conversion stuff
//--------------------------------------------------------------------------

#define D3D_STENCIL_OP_COUNT                            9
#define D3D_CMP_FUNC_COUNT                              9
#define D3D_BLEND_COUNT                                14
#define D3D_BLEND_OP_COUNT                              6
#define D3D_TADDRESS_COUNT                              5
#define D3D_MAGFILTER_COUNT                             6
#define D3D_MINFILTER_COUNT                             4
#define D3D_MIPFILTER_COUNT                             4

#define D3D_INPUTREGMAP_COUNT                           D3DVSDE_NORMAL2+1
#define D3D_OUTPUTREGMAP_COUNT                          16

// D3D -> HW conversion tables
extern const DWORD nv056StencilOp[D3D_STENCIL_OP_COUNT];
extern const DWORD nv097StencilOp[D3D_STENCIL_OP_COUNT];
extern const DWORD nv056StencilFunc[D3D_CMP_FUNC_COUNT];
extern const DWORD nv097StencilFunc[D3D_CMP_FUNC_COUNT];
extern const DWORD nv056AlphaFunc[D3D_CMP_FUNC_COUNT];
extern const DWORD nv097AlphaFunc[D3D_CMP_FUNC_COUNT];
extern const DWORD nv056DepthFunc[D3D_CMP_FUNC_COUNT];
extern const DWORD nv097DepthFunc[D3D_CMP_FUNC_COUNT];
extern const DWORD nv056BlendFunc[D3D_BLEND_COUNT];
extern const DWORD nv097BlendFunc[D3D_BLEND_COUNT];
extern const DWORD nv056BlendOp[D3D_BLEND_OP_COUNT];
extern const DWORD nv097BlendOp[D3D_BLEND_OP_COUNT];
extern const DWORD nv056TextureAddress[D3D_TADDRESS_COUNT];
extern const DWORD nv097TextureAddress[D3D_TADDRESS_COUNT];
extern const DWORD nv056TextureMagFilter[D3D_MAGFILTER_COUNT];
extern const DWORD nv097TextureMagFilter[D3D_MAGFILTER_COUNT];
extern const DWORD nv056TextureMinFilter[D3D_MINFILTER_COUNT][D3D_MIPFILTER_COUNT];
extern const DWORD nv097TextureMinFilter[D3D_MINFILTER_COUNT][D3D_MIPFILTER_COUNT];

extern const DWORD dx8MinFilterMapping[];
extern const DWORD dx8MagFilterMapping[];
extern const DWORD dx8MipFilterMapping[];

extern const DWORD defaultInputRegMap[D3D_INPUTREGMAP_COUNT];
extern const DWORD defaultOutputRegMap[D3D_OUTPUTREGMAP_COUNT];

//--------------------------------------------------------------------------

#ifdef __cplusplus
}
#endif

#endif // _NVTRANSLATE_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\ddraw\common\inc\nvvxmac.h ===
/*
 * Copyright 1993-1998 NVIDIA, Corporation.  All rights reserved.
 *
 * THE INFORMATION CONTAINED HEREIN IS PROPRIETARY AND CONFIDENTIAL TO
 * NVIDIA, CORPORATION.  USE, REPRODUCTION OR DISCLOSURE TO ANY THIRD PARTY
 * IS SUBJECT TO WRITTEN PRE-APPROVAL BY NVIDIA, CORPORATION.
 */

#ifndef _nvvxmac_h_
#define _nvvxmac_h_

#ifdef __cplusplus
extern "C" {
#endif

/*
 * Inner Loop Prototypes and Vertex Macros
 */

/*
 * General Constants
 */
#define NV_FORCE_TRI_SETUP(_ctx) (_ctx)->dwFunctionLookup = NV_SETUP_FUNCTION_INDEX;

#define NV_DX6_FUNCTION_ADJUST      2
#define NV_FIXED_FUNCTION_INDEX     2048
#define NV_AA_FUNCTION_INDEX        2048
#define NV_SETUP_FUNCTION_INDEX     2049

#define sizeDX5TriangleVertex       9
#define sizeDx5TriangleTLVertex     sizeDX5TriangleVertex

#define sizeDX6TriangleVertex       11
#define sizeDx6TriangleTLVertex     sizeDX6TriangleVertex

/*
 * Vertex Macros
 */

#define nvglDX5TriangleVertex(fifo,freecount,ch,alias,vertex)\
{\
    *(DWORD*)(fifo +  0) = ((sizeDX5TriangleVertex-1)<<18) | ((ch)<<13) | NV054_TLVERTEX((alias));\
    memcpy ((void*)(fifo + 4),(void*)(vertex),32);\
    dbgDisplayVertexData(FALSE, &(((DWORD*)nvFifo)[1]));\
    fifo      += sizeDX5TriangleVertex * 4;\
    freecount -= sizeDX5TriangleVertex;\
}

#define nvglDX5TriangleVertexExpFog(fifo,freecount,ch,alias,vertex)\
{\
    DWORD dwTemp;\
    DWORD zmask,dwrhw,dwz;\
    int   ifog;\
    float ffog,fz,fw;\
    float frhw;\
    *(DWORD*)(fifo +  0) = ((sizeDX5TriangleVertex-1)<<18) | ((ch)<<13) | NV054_TLVERTEX((alias));\
    *(DWORD*)(fifo +  4) = (*(DWORD*)(vertex +  0));\
    *(DWORD*)(fifo +  8) = (*(DWORD*)(vertex +  4));\
    *(DWORD*)(fifo + 12) = dwz = (*(DWORD*)(vertex +  8));\
    dwTemp = (*(DWORD*)(vertex + 12));\
    *(DWORD*)(fifo + 16) = dwrhw = dwTemp;\
    *(DWORD*)(fifo + 20) = (*(DWORD*)(vertex + 16));\
    dwTemp = (*(DWORD*)(vertex + 20));\
    zmask = ((*(DWORD *)&(pContext->dvWNear) == 0x3f800000) && (*(DWORD *)&(pContext->dvWFar) == 0x3f800000)) ? 0xffffffff : 0;\
    frhw = FLOAT_FROM_DWORD(dwrhw);\
    FP_INV (fw, frhw);\
    dwz = (dwz & zmask) | (*(DWORD *)&fw & ~zmask);\
    fz = FLOAT_FROM_DWORD(dwz);\
    ffog  = fz * pContext->fFogTableDensity;\
    FP_EXP (ffog,ffog);\
    FP_NORM_TO_BIT24 (ifog,ffog);\
    dwTemp = (dwTemp & 0x00ffffff) | ifog;\
    *(DWORD*)(fifo + 24) = dwTemp;\
    *(DWORD*)(fifo + 28) = (*(DWORD*)(vertex + 24));\
    *(DWORD*)(fifo + 32) = (*(DWORD*)(vertex + 28));\
    dbgDisplayVertexData(FALSE, &(((DWORD*)nvFifo)[1]));\
    fifo      += sizeDX5TriangleVertex * 4;\
    freecount -= sizeDX5TriangleVertex;\
}

#define nvglDX5TriangleVertexExp2Fog(fifo,freecount,ch,alias,vertex)\
{\
    DWORD dwTemp;\
    DWORD zmask,dwrhw,dwz;\
    int   ifog;\
    float ffog,fz,fw;\
    float frhw;\
    *(DWORD*)(fifo +  0) = ((sizeDX5TriangleVertex-1)<<18) | ((ch)<<13) | NV054_TLVERTEX((alias));\
    *(DWORD*)(fifo +  4) = (*(DWORD*)(vertex +  0));\
    *(DWORD*)(fifo +  8) = (*(DWORD*)(vertex +  4));\
    *(DWORD*)(fifo + 12) = dwz = (*(DWORD*)(vertex +  8));\
    dwTemp = (*(DWORD*)(vertex + 12));\
    *(DWORD*)(fifo + 16) = dwrhw = dwTemp;\
    *(DWORD*)(fifo + 20) = (*(DWORD*)(vertex + 16));\
    dwTemp = (*(DWORD*)(vertex + 20));\
    zmask = ((*(DWORD *)&(pContext->dvWNear) == 0x3f800000) && (*(DWORD *)&(pContext->dvWFar) == 0x3f800000)) ? 0xffffffff : 0;\
    frhw = FLOAT_FROM_DWORD(dwrhw);\
    FP_INV (fw, frhw);\
    dwz = (dwz & zmask) | (*(DWORD *)&fw & ~zmask);\
    fz = FLOAT_FROM_DWORD(dwz);\
    ffog  = fz * pContext->fFogTableDensity;\
    ffog *= ffog;\
    FP_EXP (ffog,ffog);\
    FP_NORM_TO_BIT24 (ifog,ffog);\
    dwTemp = (dwTemp & 0x00ffffff) | ifog;\
    *(DWORD*)(fifo + 24) = dwTemp;\
    *(DWORD*)(fifo + 28) = (*(DWORD*)(vertex + 24));\
    *(DWORD*)(fifo + 32) = (*(DWORD*)(vertex + 28));\
    dbgDisplayVertexData(FALSE, &(((DWORD*)nvFifo)[1]));\
    fifo      += sizeDX5TriangleVertex * 4;\
    freecount -= sizeDX5TriangleVertex;\
}

#define nvglDX5TriangleVertexLinearFog(fifo,freecount,ch,alias,vertex)\
{\
    DWORD dwTemp;\
    DWORD zmask,dwrhw,dwz;\
    int   ifog;\
    float ffog,fz,fw;\
    float frhw;\
    *(DWORD*)(fifo +  0) = ((sizeDX5TriangleVertex-1)<<18) | ((ch)<<13) | NV054_TLVERTEX((alias));\
    *(DWORD*)(fifo +  4) = (*(DWORD*)(vertex +  0));\
    *(DWORD*)(fifo +  8) = (*(DWORD*)(vertex +  4));\
    *(DWORD*)(fifo + 12) = dwz = (*(DWORD*)(vertex +  8));\
    dwTemp = (*(DWORD*)(vertex + 12));\
    *(DWORD*)(fifo + 16) = dwrhw = dwTemp;\
    *(DWORD*)(fifo + 20) = (*(DWORD*)(vertex + 16));\
    dwTemp = (*(DWORD*)(vertex + 20));\
    zmask = ((*(DWORD *)&(pContext->dvWNear) == 0x3f800000) && (*(DWORD *)&(pContext->dvWFar) == 0x3f800000)) ? 0xffffffff : 0;\
    frhw = FLOAT_FROM_DWORD(dwrhw);\
    FP_INV (fw, frhw);\
    dwz = (dwz & zmask) | (*(DWORD *)&fw & ~zmask);\
    fz = FLOAT_FROM_DWORD(dwz);\
    ffog = (fz >= pContext->fFogTableEnd) ? 0.0f :\
           (fz <= pContext->fFogTableStart) ? 1.0f :\
           (pContext->fFogTableEnd - fz) * pContext->fFogTableLinearScale;\
    FP_NORM_TO_BIT24 (ifog,ffog);\
    dwTemp = (dwTemp & 0x00ffffff) | ifog;\
    *(DWORD*)(fifo + 24) = dwTemp;\
    *(DWORD*)(fifo + 28) = (*(DWORD*)(vertex + 24));\
    *(DWORD*)(fifo + 32) = (*(DWORD*)(vertex + 28));\
    dbgDisplayVertexData(FALSE, &(((DWORD*)nvFifo)[1]));\
    fifo      += sizeDX5TriangleVertex * 4;\
    freecount -= sizeDX5TriangleVertex;\
}

#define nvglDX5TriangleVertexWBuf(fifo,freecount,ch,alias,vertex)\
{\
    DWORD dwTemp;\
    float frhw;\
    *(DWORD*)(fifo +  0) = ((sizeDX5TriangleVertex-1)<<18) | ((ch)<<13) | NV054_TLVERTEX((alias));\
    *(DWORD*)(fifo +  4) = (*(DWORD*)(vertex +  0));\
    *(DWORD*)(fifo +  8) = (*(DWORD*)(vertex +  4));\
    *(DWORD*)(fifo + 12) = (*(DWORD*)(vertex +  8));\
    dwTemp = (*(DWORD*)(vertex + 12));\
    frhw = (FLOAT_FROM_DWORD(dwTemp)) * pContext->dvRWFar;\
    *(DWORD*)(fifo + 16) = *(DWORD*)&frhw;\
    *(DWORD*)(fifo + 20) = (*(DWORD*)(vertex + 16));\
    dwTemp = (*(DWORD*)(vertex + 20));\
    *(DWORD*)(fifo + 24) = dwTemp;\
    *(DWORD*)(fifo + 28) = (*(DWORD*)(vertex + 24));\
    *(DWORD*)(fifo + 32) = (*(DWORD*)(vertex + 28));\
    dbgDisplayVertexData(FALSE, &(((DWORD*)nvFifo)[1]));\
    fifo      += sizeDX5TriangleVertex * 4;\
    freecount -= sizeDX5TriangleVertex;\
}

#define nvglDX5TriangleVertexExpFogWBuf(fifo,freecount,ch,alias,vertex)\
{\
    DWORD dwTemp;\
    DWORD zmask,dwrhw,dwz;\
    int   ifog;\
    float ffog,fz,fw;\
    float frhw;\
    *(DWORD*)(fifo +  0) = ((sizeDX5TriangleVertex-1)<<18) | ((ch)<<13) | NV054_TLVERTEX((alias));\
    *(DWORD*)(fifo +  4) = (*(DWORD*)(vertex +  0));\
    *(DWORD*)(fifo +  8) = (*(DWORD*)(vertex +  4));\
    *(DWORD*)(fifo + 12) = dwz = (*(DWORD*)(vertex +  8));\
    dwTemp = (*(DWORD*)(vertex + 12));\
    frhw = (FLOAT_FROM_DWORD(dwTemp)) * pContext->dvRWFar;\
    *(DWORD*)(fifo + 16) = dwrhw = *(DWORD*)&frhw;\
    *(DWORD*)(fifo + 20) = (*(DWORD*)(vertex + 16));\
    dwTemp = (*(DWORD*)(vertex + 20));\
    zmask = ((*(DWORD *)&(pContext->dvWNear) == 0x3f800000) && (*(DWORD *)&(pContext->dvWFar) == 0x3f800000)) ? 0xffffffff : 0;\
    frhw = FLOAT_FROM_DWORD(dwrhw);\
    FP_INV (fw, frhw);\
    dwz = (dwz & zmask) | (*(DWORD *)&fw & ~zmask);\
    fz = FLOAT_FROM_DWORD(dwz);\
    ffog  = fz * pContext->fFogTableDensity;\
    FP_EXP (ffog,ffog);\
    FP_NORM_TO_BIT24 (ifog,ffog);\
    dwTemp = (dwTemp & 0x00ffffff) | ifog;\
    *(DWORD*)(fifo + 24) = dwTemp;\
    *(DWORD*)(fifo + 28) = (*(DWORD*)(vertex + 24));\
    *(DWORD*)(fifo + 32) = (*(DWORD*)(vertex + 28));\
    dbgDisplayVertexData(FALSE, &(((DWORD*)nvFifo)[1]));\
    fifo      += sizeDX5TriangleVertex * 4;\
    freecount -= sizeDX5TriangleVertex;\
}

#define nvglDX5TriangleVertexExp2FogWBuf(fifo,freecount,ch,alias,vertex)\
{\
    DWORD dwTemp;\
    DWORD zmask,dwrhw,dwz;\
    int   ifog;\
    float ffog,fz,fw;\
    float frhw;\
    *(DWORD*)(fifo +  0) = ((sizeDX5TriangleVertex-1)<<18) | ((ch)<<13) | NV054_TLVERTEX((alias));\
    *(DWORD*)(fifo +  4) = (*(DWORD*)(vertex +  0));\
    *(DWORD*)(fifo +  8) = (*(DWORD*)(vertex +  4));\
    *(DWORD*)(fifo + 12) = dwz = (*(DWORD*)(vertex +  8));\
    dwTemp = (*(DWORD*)(vertex + 12));\
    frhw = (FLOAT_FROM_DWORD(dwTemp)) * pContext->dvRWFar;\
    *(DWORD*)(fifo + 16) = dwrhw = *(DWORD*)&frhw;\
    *(DWORD*)(fifo + 20) = (*(DWORD*)(vertex + 16));\
    dwTemp = (*(DWORD*)(vertex + 20));\
    zmask = ((*(DWORD *)&(pContext->dvWNear) == 0x3f800000) && (*(DWORD *)&(pContext->dvWFar) == 0x3f800000)) ? 0xffffffff : 0;\
    frhw = FLOAT_FROM_DWORD(dwrhw);\
    FP_INV (fw, frhw);\
    dwz = (dwz & zmask) | (*(DWORD *)&fw & ~zmask);\
    fz = FLOAT_FROM_DWORD(dwz);\
    ffog  = fz * pContext->fFogTableDensity;\
    ffog *= ffog;\
    FP_EXP (ffog,ffog);\
    FP_NORM_TO_BIT24 (ifog,ffog);\
    dwTemp = (dwTemp & 0x00ffffff) | ifog;\
    *(DWORD*)(fifo + 24) = dwTemp;\
    *(DWORD*)(fifo + 28) = (*(DWORD*)(vertex + 24));\
    *(DWORD*)(fifo + 32) = (*(DWORD*)(vertex + 28));\
    dbgDisplayVertexData(FALSE, &(((DWORD*)nvFifo)[1]));\
    fifo      += sizeDX5TriangleVertex * 4;\
    freecount -= sizeDX5TriangleVertex;\
}

#define nvglDX5TriangleVertexLinearFogWBuf(fifo,freecount,ch,alias,vertex)\
{\
    DWORD dwTemp;\
    DWORD zmask,dwrhw,dwz;\
    int   ifog;\
    float ffog,fz,fw;\
    float frhw;\
    *(DWORD*)(fifo +  0) = ((sizeDX5TriangleVertex-1)<<18) | ((ch)<<13) | NV054_TLVERTEX((alias));\
    *(DWORD*)(fifo +  4) = (*(DWORD*)(vertex +  0));\
    *(DWORD*)(fifo +  8) = (*(DWORD*)(vertex +  4));\
    *(DWORD*)(fifo + 12) = dwz = (*(DWORD*)(vertex +  8));\
    dwTemp = (*(DWORD*)(vertex + 12));\
    frhw = (FLOAT_FROM_DWORD(dwTemp)) * pContext->dvRWFar;\
    *(DWORD*)(fifo + 16) = dwrhw = *(DWORD*)&frhw;\
    *(DWORD*)(fifo + 20) = (*(DWORD*)(vertex + 16));\
    dwTemp = (*(DWORD*)(vertex + 20));\
    zmask = ((*(DWORD *)&(pContext->dvWNear) == 0x3f800000) && (*(DWORD *)&(pContext->dvWFar) == 0x3f800000)) ? 0xffffffff : 0;\
    frhw = FLOAT_FROM_DWORD(dwrhw);\
    FP_INV (fw, frhw);\
    dwz = (dwz & zmask) | (*(DWORD *)&fw & ~zmask);\
    fz = FLOAT_FROM_DWORD(dwz);\
    ffog = (fz >= pContext->fFogTableEnd) ? 0.0f :\
           (fz <= pContext->fFogTableStart) ? 1.0f :\
           (pContext->fFogTableEnd - fz) * pContext->fFogTableLinearScale;\
    FP_NORM_TO_BIT24 (ifog,ffog);\
    dwTemp = (dwTemp & 0x00ffffff) | ifog;\
    *(DWORD*)(fifo + 24) = dwTemp;\
    *(DWORD*)(fifo + 28) = (*(DWORD*)(vertex + 24));\
    *(DWORD*)(fifo + 32) = (*(DWORD*)(vertex + 28));\
    dbgDisplayVertexData(FALSE, &(((DWORD*)nvFifo)[1]));\
    fifo      += sizeDX5TriangleVertex * 4;\
    freecount -= sizeDX5TriangleVertex;\
}

#define nvglDX5FlexTriangleVertex(fifo,freecount,ch,alias,vertex,fvf,uvoff)\
{\
    DWORD dwTemp;\
    *(DWORD*)(fifo +  0) = ((sizeDX5TriangleVertex-1)<<18) | ((ch)<<13) | NV054_TLVERTEX((alias));\
    *(DWORD*)(fifo +  4) = (*(DWORD*)(vertex +  0));\
    *(DWORD*)(fifo +  8) = (*(DWORD*)(vertex +  4));\
    *(DWORD*)(fifo + 12) = (*(DWORD*)(vertex +  8));\
    dwTemp = *(DWORD*)((vertex & fvf.dwRHWMask) + fvf.dwRHWOffset);\
    *(DWORD*)(fifo + 16) = dwTemp;\
    *(DWORD*)(fifo + 20) = *(DWORD*)((vertex & fvf.dwDiffuseMask) + fvf.dwDiffuseOffset);\
    dwTemp = *(DWORD*)((vertex & fvf.dwSpecularMask) + fvf.dwSpecularOffset);\
    *(DWORD*)(fifo + 24) = dwTemp;\
    dwTemp = (vertex & fvf.dwUVMask) + fvf.dwUVOffset[0];\
    *(DWORD*)(fifo + 28) = *(DWORD*)(dwTemp + (uvoff)[0] + 0);\
    *(DWORD*)(fifo + 32) = *(DWORD*)(dwTemp + (uvoff)[0] + 4);\
    dbgDisplayVertexData(FALSE, &(((DWORD*)nvFifo)[1]));\
    fifo      += sizeDX5TriangleVertex * 4;\
    freecount -= sizeDX5TriangleVertex;\
}

#define nvglDX5FlexTriangleVertexExpFog(fifo,freecount,ch,alias,vertex,fvf,uvoff)\
{\
    DWORD dwTemp;\
    DWORD zmask,dwrhw,dwz;\
    int   ifog;\
    float ffog,fz,fw;\
    float frhw;\
    *(DWORD*)(fifo +  0) = ((sizeDX5TriangleVertex-1)<<18) | ((ch)<<13) | NV054_TLVERTEX((alias));\
    *(DWORD*)(fifo +  4) = (*(DWORD*)(vertex +  0));\
    *(DWORD*)(fifo +  8) = (*(DWORD*)(vertex +  4));\
    *(DWORD*)(fifo + 12) = dwz = (*(DWORD*)(vertex +  8));\
    dwTemp = *(DWORD*)((vertex & fvf.dwRHWMask) + fvf.dwRHWOffset);\
    *(DWORD*)(fifo + 16) = dwrhw = dwTemp;\
    *(DWORD*)(fifo + 20) = *(DWORD*)((vertex & fvf.dwDiffuseMask) + fvf.dwDiffuseOffset);\
    dwTemp = *(DWORD*)((vertex & fvf.dwSpecularMask) + fvf.dwSpecularOffset);\
    zmask = ((*(DWORD *)&(pContext->dvWNear) == 0x3f800000) && (*(DWORD *)&(pContext->dvWFar) == 0x3f800000)) ? 0xffffffff : 0;\
    frhw = FLOAT_FROM_DWORD(dwrhw);\
    FP_INV (fw, frhw);\
    dwz = (dwz & zmask) | (*(DWORD *)&fw & ~zmask);\
    fz = FLOAT_FROM_DWORD(dwz);\
    ffog  = fz * pContext->fFogTableDensity;\
    FP_EXP (ffog,ffog);\
    FP_NORM_TO_BIT24 (ifog,ffog);\
    dwTemp = (dwTemp & 0x00ffffff) | ifog;\
    *(DWORD*)(fifo + 24) = dwTemp;\
    dwTemp = (vertex & fvf.dwUVMask) + fvf.dwUVOffset[0];\
    *(DWORD*)(fifo + 28) = *(DWORD*)(dwTemp + (uvoff)[0] + 0);\
    *(DWORD*)(fifo + 32) = *(DWORD*)(dwTemp + (uvoff)[0] + 4);\
    dbgDisplayVertexData(FALSE, &(((DWORD*)nvFifo)[1]));\
    fifo      += sizeDX5TriangleVertex * 4;\
    freecount -= sizeDX5TriangleVertex;\
}

#define nvglDX5FlexTriangleVertexExp2Fog(fifo,freecount,ch,alias,vertex,fvf,uvoff)\
{\
    DWORD dwTemp;\
    DWORD zmask,dwrhw,dwz;\
    int   ifog;\
    float ffog,fz,fw;\
    float frhw;\
    *(DWORD*)(fifo +  0) = ((sizeDX5TriangleVertex-1)<<18) | ((ch)<<13) | NV054_TLVERTEX((alias));\
    *(DWORD*)(fifo +  4) = (*(DWORD*)(vertex +  0));\
    *(DWORD*)(fifo +  8) = (*(DWORD*)(vertex +  4));\
    *(DWORD*)(fifo + 12) = dwz = (*(DWORD*)(vertex +  8));\
    dwTemp = *(DWORD*)((vertex & fvf.dwRHWMask) + fvf.dwRHWOffset);\
    *(DWORD*)(fifo + 16) = dwrhw = dwTemp;\
    *(DWORD*)(fifo + 20) = *(DWORD*)((vertex & fvf.dwDiffuseMask) + fvf.dwDiffuseOffset);\
    dwTemp = *(DWORD*)((vertex & fvf.dwSpecularMask) + fvf.dwSpecularOffset);\
    zmask = ((*(DWORD *)&(pContext->dvWNear) == 0x3f800000) && (*(DWORD *)&(pContext->dvWFar) == 0x3f800000)) ? 0xffffffff : 0;\
    frhw = FLOAT_FROM_DWORD(dwrhw);\
    FP_INV (fw, frhw);\
    dwz = (dwz & zmask) | (*(DWORD *)&fw & ~zmask);\
    fz = FLOAT_FROM_DWORD(dwz);\
    ffog  = fz * pContext->fFogTableDensity;\
    ffog *= ffog;\
    FP_EXP (ffog,ffog);\
    FP_NORM_TO_BIT24 (ifog,ffog);\
    dwTemp = (dwTemp & 0x00ffffff) | ifog;\
    *(DWORD*)(fifo + 24) = dwTemp;\
    dwTemp = (vertex & fvf.dwUVMask) + fvf.dwUVOffset[0];\
    *(DWORD*)(fifo + 28) = *(DWORD*)(dwTemp + (uvoff)[0] + 0);\
    *(DWORD*)(fifo + 32) = *(DWORD*)(dwTemp + (uvoff)[0] + 4);\
    dbgDisplayVertexData(FALSE, &(((DWORD*)nvFifo)[1]));\
    fifo      += sizeDX5TriangleVertex * 4;\
    freecount -= sizeDX5TriangleVertex;\
}

#define nvglDX5FlexTriangleVertexLinearFog(fifo,freecount,ch,alias,vertex,fvf,uvoff)\
{\
    DWORD dwTemp;\
    DWORD zmask,dwrhw,dwz;\
    int   ifog;\
    float ffog,fz,fw;\
    float frhw;\
    *(DWORD*)(fifo +  0) = ((sizeDX5TriangleVertex-1)<<18) | ((ch)<<13) | NV054_TLVERTEX((alias));\
    *(DWORD*)(fifo +  4) = (*(DWORD*)(vertex +  0));\
    *(DWORD*)(fifo +  8) = (*(DWORD*)(vertex +  4));\
    *(DWORD*)(fifo + 12) = dwz = (*(DWORD*)(vertex +  8));\
    dwTemp = *(DWORD*)((vertex & fvf.dwRHWMask) + fvf.dwRHWOffset);\
    *(DWORD*)(fifo + 16) = dwrhw = dwTemp;\
    *(DWORD*)(fifo + 20) = *(DWORD*)((vertex & fvf.dwDiffuseMask) + fvf.dwDiffuseOffset);\
    dwTemp = *(DWORD*)((vertex & fvf.dwSpecularMask) + fvf.dwSpecularOffset);\
    zmask = ((*(DWORD *)&(pContext->dvWNear) == 0x3f800000) && (*(DWORD *)&(pContext->dvWFar) == 0x3f800000)) ? 0xffffffff : 0;\
    frhw = FLOAT_FROM_DWORD(dwrhw);\
    FP_INV (fw, frhw);\
    dwz = (dwz & zmask) | (*(DWORD *)&fw & ~zmask);\
    fz = FLOAT_FROM_DWORD(dwz);\
    ffog = (fz >= pContext->fFogTableEnd) ? 0.0f :\
           (fz <= pContext->fFogTableStart) ? 1.0f :\
           (pContext->fFogTableEnd - fz) * pContext->fFogTableLinearScale;\
    FP_NORM_TO_BIT24 (ifog,ffog);\
    dwTemp = (dwTemp & 0x00ffffff) | ifog;\
    *(DWORD*)(fifo + 24) = dwTemp;\
    dwTemp = (vertex & fvf.dwUVMask) + fvf.dwUVOffset[0];\
    *(DWORD*)(fifo + 28) = *(DWORD*)(dwTemp + (uvoff)[0] + 0);\
    *(DWORD*)(fifo + 32) = *(DWORD*)(dwTemp + (uvoff)[0] + 4);\
    dbgDisplayVertexData(FALSE, &(((DWORD*)nvFifo)[1]));\
    fifo      += sizeDX5TriangleVertex * 4;\
    freecount -= sizeDX5TriangleVertex;\
}

#define nvglDX5FlexTriangleVertexWBuf(fifo,freecount,ch,alias,vertex,fvf,uvoff)\
{\
    DWORD dwTemp;\
    float frhw;\
    *(DWORD*)(fifo +  0) = ((sizeDX5TriangleVertex-1)<<18) | ((ch)<<13) | NV054_TLVERTEX((alias));\
    *(DWORD*)(fifo +  4) = (*(DWORD*)(vertex +  0));\
    *(DWORD*)(fifo +  8) = (*(DWORD*)(vertex +  4));\
    *(DWORD*)(fifo + 12) = (*(DWORD*)(vertex +  8));\
    dwTemp = *(DWORD*)((vertex & fvf.dwRHWMask) + fvf.dwRHWOffset);\
    frhw = (FLOAT_FROM_DWORD(dwTemp)) * pContext->dvRWFar;\
    *(DWORD*)(fifo + 16) = *(DWORD*)&frhw;\
    *(DWORD*)(fifo + 20) = *(DWORD*)((vertex & fvf.dwDiffuseMask) + fvf.dwDiffuseOffset);\
    dwTemp = *(DWORD*)((vertex & fvf.dwSpecularMask) + fvf.dwSpecularOffset);\
    *(DWORD*)(fifo + 24) = dwTemp;\
    dwTemp = (vertex & fvf.dwUVMask) + fvf.dwUVOffset[0];\
    *(DWORD*)(fifo + 28) = *(DWORD*)(dwTemp + (uvoff)[0] + 0);\
    *(DWORD*)(fifo + 32) = *(DWORD*)(dwTemp + (uvoff)[0] + 4);\
    dbgDisplayVertexData(FALSE, &(((DWORD*)nvFifo)[1]));\
    fifo      += sizeDX5TriangleVertex * 4;\
    freecount -= sizeDX5TriangleVertex;\
}

#define nvglDX5FlexTriangleVertexExpFogWBuf(fifo,freecount,ch,alias,vertex,fvf,uvoff)\
{\
    DWORD dwTemp;\
    DWORD zmask,dwrhw,dwz;\
    int   ifog;\
    float ffog,fz,fw;\
    float frhw;\
    *(DWORD*)(fifo +  0) = ((sizeDX5TriangleVertex-1)<<18) | ((ch)<<13) | NV054_TLVERTEX((alias));\
    *(DWORD*)(fifo +  4) = (*(DWORD*)(vertex +  0));\
    *(DWORD*)(fifo +  8) = (*(DWORD*)(vertex +  4));\
    *(DWORD*)(fifo + 12) = dwz = (*(DWORD*)(vertex +  8));\
    dwTemp = *(DWORD*)((vertex & fvf.dwRHWMask) + fvf.dwRHWOffset);\
    frhw = (FLOAT_FROM_DWORD(dwTemp)) * pContext->dvRWFar;\
    *(DWORD*)(fifo + 16) = dwrhw = *(DWORD*)&frhw;\
    *(DWORD*)(fifo + 20) = *(DWORD*)((vertex & fvf.dwDiffuseMask) + fvf.dwDiffuseOffset);\
    dwTemp = *(DWORD*)((vertex & fvf.dwSpecularMask) + fvf.dwSpecularOffset);\
    zmask = ((*(DWORD *)&(pContext->dvWNear) == 0x3f800000) && (*(DWORD *)&(pContext->dvWFar) == 0x3f800000)) ? 0xffffffff : 0;\
    frhw = FLOAT_FROM_DWORD(dwrhw);\
    FP_INV (fw, frhw);\
    dwz = (dwz & zmask) | (*(DWORD *)&fw & ~zmask);\
    fz = FLOAT_FROM_DWORD(dwz);\
    ffog  = fz * pContext->fFogTableDensity;\
    FP_EXP (ffog,ffog);\
    FP_NORM_TO_BIT24 (ifog,ffog);\
    dwTemp = (dwTemp & 0x00ffffff) | ifog;\
    *(DWORD*)(fifo + 24) = dwTemp;\
    dwTemp = (vertex & fvf.dwUVMask) + fvf.dwUVOffset[0];\
    *(DWORD*)(fifo + 28) = *(DWORD*)(dwTemp + (uvoff)[0] + 0);\
    *(DWORD*)(fifo + 32) = *(DWORD*)(dwTemp + (uvoff)[0] + 4);\
    dbgDisplayVertexData(FALSE, &(((DWORD*)nvFifo)[1]));\
    fifo      += sizeDX5TriangleVertex * 4;\
    freecount -= sizeDX5TriangleVertex;\
}

#define nvglDX5FlexTriangleVertexExp2FogWBuf(fifo,freecount,ch,alias,vertex,fvf,uvoff)\
{\
    DWORD dwTemp;\
    DWORD zmask,dwrhw,dwz;\
    int   ifog;\
    float ffog,fz,fw;\
    float frhw;\
    *(DWORD*)(fifo +  0) = ((sizeDX5TriangleVertex-1)<<18) | ((ch)<<13) | NV054_TLVERTEX((alias));\
    *(DWORD*)(fifo +  4) = (*(DWORD*)(vertex +  0));\
    *(DWORD*)(fifo +  8) = (*(DWORD*)(vertex +  4));\
    *(DWORD*)(fifo + 12) = dwz = (*(DWORD*)(vertex +  8));\
    dwTemp = *(DWORD*)((vertex & fvf.dwRHWMask) + fvf.dwRHWOffset);\
    frhw = (FLOAT_FROM_DWORD(dwTemp)) * pContext->dvRWFar;\
    *(DWORD*)(fifo + 16) = dwrhw = *(DWORD*)&frhw;\
    *(DWORD*)(fifo + 20) = *(DWORD*)((vertex & fvf.dwDiffuseMask) + fvf.dwDiffuseOffset);\
    dwTemp = *(DWORD*)((vertex & fvf.dwSpecularMask) + fvf.dwSpecularOffset);\
    zmask = ((*(DWORD *)&(pContext->dvWNear) == 0x3f800000) && (*(DWORD *)&(pContext->dvWFar) == 0x3f800000)) ? 0xffffffff : 0;\
    frhw = FLOAT_FROM_DWORD(dwrhw);\
    FP_INV (fw, frhw);\
    dwz = (dwz & zmask) | (*(DWORD *)&fw & ~zmask);\
    fz = FLOAT_FROM_DWORD(dwz);\
    ffog  = fz * pContext->fFogTableDensity;\
    ffog *= ffog;\
    FP_EXP (ffog,ffog);\
    FP_NORM_TO_BIT24 (ifog,ffog);\
    dwTemp = (dwTemp & 0x00ffffff) | ifog;\
    *(DWORD*)(fifo + 24) = dwTemp;\
    dwTemp = (vertex & fvf.dwUVMask) + fvf.dwUVOffset[0];\
    *(DWORD*)(fifo + 28) = *(DWORD*)(dwTemp + (uvoff)[0] + 0);\
    *(DWORD*)(fifo + 32) = *(DWORD*)(dwTemp + (uvoff)[0] + 4);\
    dbgDisplayVertexData(FALSE, &(((DWORD*)nvFifo)[1]));\
    fifo      += sizeDX5TriangleVertex * 4;\
    freecount -= sizeDX5TriangleVertex;\
}

#define nvglDX5FlexTriangleVertexLinearFogWBuf(fifo,freecount,ch,alias,vertex,fvf,uvoff)\
{\
    DWORD dwTemp;\
    DWORD zmask,dwrhw,dwz;\
    int   ifog;\
    float ffog,fz,fw;\
    float frhw;\
    *(DWORD*)(fifo +  0) = ((sizeDX5TriangleVertex-1)<<18) | ((ch)<<13) | NV054_TLVERTEX((alias));\
    *(DWORD*)(fifo +  4) = (*(DWORD*)(vertex +  0));\
    *(DWORD*)(fifo +  8) = (*(DWORD*)(vertex +  4));\
    *(DWORD*)(fifo + 12) = dwz = (*(DWORD*)(vertex +  8));\
    dwTemp = *(DWORD*)((vertex & fvf.dwRHWMask) + fvf.dwRHWOffset);\
    frhw = (FLOAT_FROM_DWORD(dwTemp)) * pContext->dvRWFar;\
    *(DWORD*)(fifo + 16) = dwrhw = *(DWORD*)&frhw;\
    *(DWORD*)(fifo + 20) = *(DWORD*)((vertex & fvf.dwDiffuseMask) + fvf.dwDiffuseOffset);\
    dwTemp = *(DWORD*)((vertex & fvf.dwSpecularMask) + fvf.dwSpecularOffset);\
    zmask = ((*(DWORD *)&(pContext->dvWNear) == 0x3f800000) && (*(DWORD *)&(pContext->dvWFar) == 0x3f800000)) ? 0xffffffff : 0;\
    frhw = FLOAT_FROM_DWORD(dwrhw);\
    FP_INV (fw, frhw);\
    dwz = (dwz & zmask) | (*(DWORD *)&fw & ~zmask);\
    fz = FLOAT_FROM_DWORD(dwz);\
    ffog = (fz >= pContext->fFogTableEnd) ? 0.0f :\
           (fz <= pContext->fFogTableStart) ? 1.0f :\
           (pContext->fFogTableEnd - fz) * pContext->fFogTableLinearScale;\
    FP_NORM_TO_BIT24 (ifog,ffog);\
    dwTemp = (dwTemp & 0x00ffffff) | ifog;\
    *(DWORD*)(fifo + 24) = dwTemp;\
    dwTemp = (vertex & fvf.dwUVMask) + fvf.dwUVOffset[0];\
    *(DWORD*)(fifo + 28) = *(DWORD*)(dwTemp + (uvoff)[0] + 0);\
    *(DWORD*)(fifo + 32) = *(DWORD*)(dwTemp + (uvoff)[0] + 4);\
    dbgDisplayVertexData(FALSE, &(((DWORD*)nvFifo)[1]));\
    fifo      += sizeDX5TriangleVertex * 4;\
    freecount -= sizeDX5TriangleVertex;\
}

#define nvglDX6FlexTriangleVertex(fifo,freecount,ch,alias,vertex,fvf,uvoff)\
{\
    DWORD dwTemp;\
    *(DWORD*)(fifo +  0) = ((sizeDX6TriangleVertex-1)<<18) | ((ch)<<13) | NV055_TLMTVERTEX((alias));\
    *(DWORD*)(fifo +  4) = (*(DWORD*)(vertex +  0));\
    *(DWORD*)(fifo +  8) = (*(DWORD*)(vertex +  4));\
    *(DWORD*)(fifo + 12) = (*(DWORD*)(vertex +  8));\
    dwTemp = *(DWORD*)((vertex & fvf.dwRHWMask) + fvf.dwRHWOffset);\
    *(DWORD*)(fifo + 16) = dwTemp;\
    *(DWORD*)(fifo + 20) = *(DWORD*)((vertex & fvf.dwDiffuseMask) + fvf.dwDiffuseOffset);\
    dwTemp = *(DWORD*)((vertex & fvf.dwSpecularMask) + fvf.dwSpecularOffset);\
    *(DWORD*)(fifo + 24) = dwTemp;\
    dwTemp = (vertex & fvf.dwUVMask) + fvf.dwUVOffset[0];\
    *(DWORD*)(fifo + 28) = *(DWORD*)(dwTemp + (uvoff)[0] + 0);\
    *(DWORD*)(fifo + 32) = *(DWORD*)(dwTemp + (uvoff)[0] + 4);\
    *(DWORD*)(fifo + 36) = *(DWORD*)(dwTemp + (uvoff)[1] + 0);\
    *(DWORD*)(fifo + 40) = *(DWORD*)(dwTemp + (uvoff)[1] + 4);\
    dbgDisplayVertexData(TRUE, &(((DWORD*)nvFifo)[1]));\
    fifo      += sizeDX6TriangleVertex * 4;\
    freecount -= sizeDX6TriangleVertex;\
}

#define nvglDX6FlexTriangleVertexExpFog(fifo,freecount,ch,alias,vertex,fvf,uvoff)\
{\
    DWORD dwTemp;\
    DWORD zmask,dwrhw,dwz;\
    int   ifog;\
    float ffog,fz,fw;\
    float frhw;\
    *(DWORD*)(fifo +  0) = ((sizeDX6TriangleVertex-1)<<18) | ((ch)<<13) | NV055_TLMTVERTEX((alias));\
    *(DWORD*)(fifo +  4) = (*(DWORD*)(vertex +  0));\
    *(DWORD*)(fifo +  8) = (*(DWORD*)(vertex +  4));\
    *(DWORD*)(fifo + 12) = dwz = (*(DWORD*)(vertex +  8));\
    dwTemp = *(DWORD*)((vertex & fvf.dwRHWMask) + fvf.dwRHWOffset);\
    *(DWORD*)(fifo + 16) = dwrhw = dwTemp;\
    *(DWORD*)(fifo + 20) = *(DWORD*)((vertex & fvf.dwDiffuseMask) + fvf.dwDiffuseOffset);\
    dwTemp = *(DWORD*)((vertex & fvf.dwSpecularMask) + fvf.dwSpecularOffset);\
    zmask = ((*(DWORD *)&(pContext->dvWNear) == 0x3f800000) && (*(DWORD *)&(pContext->dvWFar) == 0x3f800000)) ? 0xffffffff : 0;\
    frhw = FLOAT_FROM_DWORD(dwrhw);\
    FP_INV (fw, frhw);\
    dwz = (dwz & zmask) | (*(DWORD *)&fw & ~zmask);\
    fz = FLOAT_FROM_DWORD(dwz);\
    ffog  = fz * pContext->fFogTableDensity;\
    FP_EXP (ffog,ffog);\
    FP_NORM_TO_BIT24 (ifog,ffog);\
    dwTemp = (dwTemp & 0x00ffffff) | ifog;\
    *(DWORD*)(fifo + 24) = dwTemp;\
    dwTemp = (vertex & fvf.dwUVMask) + fvf.dwUVOffset[0];\
    *(DWORD*)(fifo + 28) = *(DWORD*)(dwTemp + (uvoff)[0] + 0);\
    *(DWORD*)(fifo + 32) = *(DWORD*)(dwTemp + (uvoff)[0] + 4);\
    *(DWORD*)(fifo + 36) = *(DWORD*)(dwTemp + (uvoff)[1] + 0);\
    *(DWORD*)(fifo + 40) = *(DWORD*)(dwTemp + (uvoff)[1] + 4);\
    dbgDisplayVertexData(TRUE, &(((DWORD*)nvFifo)[1]));\
    fifo      += sizeDX6TriangleVertex * 4;\
    freecount -= sizeDX6TriangleVertex;\
}

#define nvglDX6FlexTriangleVertexExp2Fog(fifo,freecount,ch,alias,vertex,fvf,uvoff)\
{\
    DWORD dwTemp;\
    DWORD zmask,dwrhw,dwz;\
    int   ifog;\
    float ffog,fz,fw;\
    float frhw;\
    *(DWORD*)(fifo +  0) = ((sizeDX6TriangleVertex-1)<<18) | ((ch)<<13) | NV055_TLMTVERTEX((alias));\
    *(DWORD*)(fifo +  4) = (*(DWORD*)(vertex +  0));\
    *(DWORD*)(fifo +  8) = (*(DWORD*)(vertex +  4));\
    *(DWORD*)(fifo + 12) = dwz = (*(DWORD*)(vertex +  8));\
    dwTemp = *(DWORD*)((vertex & fvf.dwRHWMask) + fvf.dwRHWOffset);\
    *(DWORD*)(fifo + 16) = dwrhw = dwTemp;\
    *(DWORD*)(fifo + 20) = *(DWORD*)((vertex & fvf.dwDiffuseMask) + fvf.dwDiffuseOffset);\
    dwTemp = *(DWORD*)((vertex & fvf.dwSpecularMask) + fvf.dwSpecularOffset);\
    zmask = ((*(DWORD *)&(pContext->dvWNear) == 0x3f800000) && (*(DWORD *)&(pContext->dvWFar) == 0x3f800000)) ? 0xffffffff : 0;\
    frhw = FLOAT_FROM_DWORD(dwrhw);\
    FP_INV (fw, frhw);\
    dwz = (dwz & zmask) | (*(DWORD *)&fw & ~zmask);\
    fz = FLOAT_FROM_DWORD(dwz);\
    ffog  = fz * pContext->fFogTableDensity;\
    ffog *= ffog;\
    FP_EXP (ffog,ffog);\
    FP_NORM_TO_BIT24 (ifog,ffog);\
    dwTemp = (dwTemp & 0x00ffffff) | ifog;\
    *(DWORD*)(fifo + 24) = dwTemp;\
    dwTemp = (vertex & fvf.dwUVMask) + fvf.dwUVOffset[0];\
    *(DWORD*)(fifo + 28) = *(DWORD*)(dwTemp + (uvoff)[0] + 0);\
    *(DWORD*)(fifo + 32) = *(DWORD*)(dwTemp + (uvoff)[0] + 4);\
    *(DWORD*)(fifo + 36) = *(DWORD*)(dwTemp + (uvoff)[1] + 0);\
    *(DWORD*)(fifo + 40) = *(DWORD*)(dwTemp + (uvoff)[1] + 4);\
    dbgDisplayVertexData(TRUE, &(((DWORD*)nvFifo)[1]));\
    fifo      += sizeDX6TriangleVertex * 4;\
    freecount -= sizeDX6TriangleVertex;\
}

#define nvglDX6FlexTriangleVertexLinearFog(fifo,freecount,ch,alias,vertex,fvf,uvoff)\
{\
    DWORD dwTemp;\
    DWORD zmask,dwrhw,dwz;\
    int   ifog;\
    float ffog,fz,fw;\
    float frhw;\
    *(DWORD*)(fifo +  0) = ((sizeDX6TriangleVertex-1)<<18) | ((ch)<<13) | NV055_TLMTVERTEX((alias));\
    *(DWORD*)(fifo +  4) = (*(DWORD*)(vertex +  0));\
    *(DWORD*)(fifo +  8) = (*(DWORD*)(vertex +  4));\
    *(DWORD*)(fifo + 12) = dwz = (*(DWORD*)(vertex +  8));\
    dwTemp = *(DWORD*)((vertex & fvf.dwRHWMask) + fvf.dwRHWOffset);\
    *(DWORD*)(fifo + 16) = dwrhw = dwTemp;\
    *(DWORD*)(fifo + 20) = *(DWORD*)((vertex & fvf.dwDiffuseMask) + fvf.dwDiffuseOffset);\
    dwTemp = *(DWORD*)((vertex & fvf.dwSpecularMask) + fvf.dwSpecularOffset);\
    zmask = ((*(DWORD *)&(pContext->dvWNear) == 0x3f800000) && (*(DWORD *)&(pContext->dvWFar) == 0x3f800000)) ? 0xffffffff : 0;\
    frhw = FLOAT_FROM_DWORD(dwrhw);\
    FP_INV (fw, frhw);\
    dwz = (dwz & zmask) | (*(DWORD *)&fw & ~zmask);\
    fz = FLOAT_FROM_DWORD(dwz);\
    ffog = (fz >= pContext->fFogTableEnd) ? 0.0f :\
           (fz <= pContext->fFogTableStart) ? 1.0f :\
           (pContext->fFogTableEnd - fz) * pContext->fFogTableLinearScale;\
    FP_NORM_TO_BIT24 (ifog,ffog);\
    dwTemp = (dwTemp & 0x00ffffff) | ifog;\
    *(DWORD*)(fifo + 24) = dwTemp;\
    dwTemp = (vertex & fvf.dwUVMask) + fvf.dwUVOffset[0];\
    *(DWORD*)(fifo + 28) = *(DWORD*)(dwTemp + (uvoff)[0] + 0);\
    *(DWORD*)(fifo + 32) = *(DWORD*)(dwTemp + (uvoff)[0] + 4);\
    *(DWORD*)(fifo + 36) = *(DWORD*)(dwTemp + (uvoff)[1] + 0);\
    *(DWORD*)(fifo + 40) = *(DWORD*)(dwTemp + (uvoff)[1] + 4);\
    dbgDisplayVertexData(TRUE, &(((DWORD*)nvFifo)[1]));\
    fifo      += sizeDX6TriangleVertex * 4;\
    freecount -= sizeDX6TriangleVertex;\
}

#define nvglDX6FlexTriangleVertexWBuf(fifo,freecount,ch,alias,vertex,fvf,uvoff)\
{\
    DWORD dwTemp;\
    float frhw;\
    *(DWORD*)(fifo +  0) = ((sizeDX6TriangleVertex-1)<<18) | ((ch)<<13) | NV055_TLMTVERTEX((alias));\
    *(DWORD*)(fifo +  4) = (*(DWORD*)(vertex +  0));\
    *(DWORD*)(fifo +  8) = (*(DWORD*)(vertex +  4));\
    *(DWORD*)(fifo + 12) = (*(DWORD*)(vertex +  8));\
    dwTemp = *(DWORD*)((vertex & fvf.dwRHWMask) + fvf.dwRHWOffset);\
    frhw = (FLOAT_FROM_DWORD(dwTemp)) * pContext->dvRWFar;\
    *(DWORD*)(fifo + 16) = *(DWORD*)&frhw;\
    *(DWORD*)(fifo + 20) = *(DWORD*)((vertex & fvf.dwDiffuseMask) + fvf.dwDiffuseOffset);\
    dwTemp = *(DWORD*)((vertex & fvf.dwSpecularMask) + fvf.dwSpecularOffset);\
    *(DWORD*)(fifo + 24) = dwTemp;\
    dwTemp = (vertex & fvf.dwUVMask) + fvf.dwUVOffset[0];\
    *(DWORD*)(fifo + 28) = *(DWORD*)(dwTemp + (uvoff)[0] + 0);\
    *(DWORD*)(fifo + 32) = *(DWORD*)(dwTemp + (uvoff)[0] + 4);\
    *(DWORD*)(fifo + 36) = *(DWORD*)(dwTemp + (uvoff)[1] + 0);\
    *(DWORD*)(fifo + 40) = *(DWORD*)(dwTemp + (uvoff)[1] + 4);\
    dbgDisplayVertexData(TRUE, &(((DWORD*)nvFifo)[1]));\
    fifo      += sizeDX6TriangleVertex * 4;\
    freecount -= sizeDX6TriangleVertex;\
}

#define nvglDX6FlexTriangleVertexExpFogWBuf(fifo,freecount,ch,alias,vertex,fvf,uvoff)\
{\
    DWORD dwTemp;\
    DWORD zmask,dwrhw,dwz;\
    int   ifog;\
    float ffog,fz,fw;\
    float frhw;\
    *(DWORD*)(fifo +  0) = ((sizeDX6TriangleVertex-1)<<18) | ((ch)<<13) | NV055_TLMTVERTEX((alias));\
    *(DWORD*)(fifo +  4) = (*(DWORD*)(vertex +  0));\
    *(DWORD*)(fifo +  8) = (*(DWORD*)(vertex +  4));\
    *(DWORD*)(fifo + 12) = dwz = (*(DWORD*)(vertex +  8));\
    dwTemp = *(DWORD*)((vertex & fvf.dwRHWMask) + fvf.dwRHWOffset);\
    frhw = (FLOAT_FROM_DWORD(dwTemp)) * pContext->dvRWFar;\
    *(DWORD*)(fifo + 16) = dwrhw = *(DWORD*)&frhw;\
    *(DWORD*)(fifo + 20) = *(DWORD*)((vertex & fvf.dwDiffuseMask) + fvf.dwDiffuseOffset);\
    dwTemp = *(DWORD*)((vertex & fvf.dwSpecularMask) + fvf.dwSpecularOffset);\
    zmask = ((*(DWORD *)&(pContext->dvWNear) == 0x3f800000) && (*(DWORD *)&(pContext->dvWFar) == 0x3f800000)) ? 0xffffffff : 0;\
    frhw = FLOAT_FROM_DWORD(dwrhw);\
    FP_INV (fw, frhw);\
    dwz = (dwz & zmask) | (*(DWORD *)&fw & ~zmask);\
    fz = FLOAT_FROM_DWORD(dwz);\
    ffog  = fz * pContext->fFogTableDensity;\
    FP_EXP (ffog,ffog);\
    FP_NORM_TO_BIT24 (ifog,ffog);\
    dwTemp = (dwTemp & 0x00ffffff) | ifog;\
    *(DWORD*)(fifo + 24) = dwTemp;\
    dwTemp = (vertex & fvf.dwUVMask) + fvf.dwUVOffset[0];\
    *(DWORD*)(fifo + 28) = *(DWORD*)(dwTemp + (uvoff)[0] + 0);\
    *(DWORD*)(fifo + 32) = *(DWORD*)(dwTemp + (uvoff)[0] + 4);\
    *(DWORD*)(fifo + 36) = *(DWORD*)(dwTemp + (uvoff)[1] + 0);\
    *(DWORD*)(fifo + 40) = *(DWORD*)(dwTemp + (uvoff)[1] + 4);\
    dbgDisplayVertexData(TRUE, &(((DWORD*)nvFifo)[1]));\
    fifo      += sizeDX6TriangleVertex * 4;\
    freecount -= sizeDX6TriangleVertex;\
}

#define nvglDX6FlexTriangleVertexExp2FogWBuf(fifo,freecount,ch,alias,vertex,fvf,uvoff)\
{\
    DWORD dwTemp;\
    DWORD zmask,dwrhw,dwz;\
    int   ifog;\
    float ffog,fz,fw;\
    float frhw;\
    *(DWORD*)(fifo +  0) = ((sizeDX6TriangleVertex-1)<<18) | ((ch)<<13) | NV055_TLMTVERTEX((alias));\
    *(DWORD*)(fifo +  4) = (*(DWORD*)(vertex +  0));\
    *(DWORD*)(fifo +  8) = (*(DWORD*)(vertex +  4));\
    *(DWORD*)(fifo + 12) = dwz = (*(DWORD*)(vertex +  8));\
    dwTemp = *(DWORD*)((vertex & fvf.dwRHWMask) + fvf.dwRHWOffset);\
    frhw = (FLOAT_FROM_DWORD(dwTemp)) * pContext->dvRWFar;\
    *(DWORD*)(fifo + 16) = dwrhw = *(DWORD*)&frhw;\
    *(DWORD*)(fifo + 20) = *(DWORD*)((vertex & fvf.dwDiffuseMask) + fvf.dwDiffuseOffset);\
    dwTemp = *(DWORD*)((vertex & fvf.dwSpecularMask) + fvf.dwSpecularOffset);\
    zmask = ((*(DWORD *)&(pContext->dvWNear) == 0x3f800000) && (*(DWORD *)&(pContext->dvWFar) == 0x3f800000)) ? 0xffffffff : 0;\
    frhw = FLOAT_FROM_DWORD(dwrhw);\
    FP_INV (fw, frhw);\
    dwz = (dwz & zmask) | (*(DWORD *)&fw & ~zmask);\
    fz = FLOAT_FROM_DWORD(dwz);\
    ffog  = fz * pContext->fFogTableDensity;\
    ffog *= ffog;\
    FP_EXP (ffog,ffog);\
    FP_NORM_TO_BIT24 (ifog,ffog);\
    dwTemp = (dwTemp & 0x00ffffff) | ifog;\
    *(DWORD*)(fifo + 24) = dwTemp;\
    dwTemp = (vertex & fvf.dwUVMask) + fvf.dwUVOffset[0];\
    *(DWORD*)(fifo + 28) = *(DWORD*)(dwTemp + (uvoff)[0] + 0);\
    *(DWORD*)(fifo + 32) = *(DWORD*)(dwTemp + (uvoff)[0] + 4);\
    *(DWORD*)(fifo + 36) = *(DWORD*)(dwTemp + (uvoff)[1] + 0);\
    *(DWORD*)(fifo + 40) = *(DWORD*)(dwTemp + (uvoff)[1] + 4);\
    dbgDisplayVertexData(TRUE, &(((DWORD*)nvFifo)[1]));\
    fifo      += sizeDX6TriangleVertex * 4;\
    freecount -= sizeDX6TriangleVertex;\
}

#define nvglDX6FlexTriangleVertexLinearFogWBuf(fifo,freecount,ch,alias,vertex,fvf,uvoff)\
{\
    DWORD dwTemp;\
    DWORD zmask,dwrhw,dwz;\
    int   ifog;\
    float ffog,fz,fw;\
    float frhw;\
    *(DWORD*)(fifo +  0) = ((sizeDX6TriangleVertex-1)<<18) | ((ch)<<13) | NV055_TLMTVERTEX((alias));\
    *(DWORD*)(fifo +  4) = (*(DWORD*)(vertex +  0));\
    *(DWORD*)(fifo +  8) = (*(DWORD*)(vertex +  4));\
    *(DWORD*)(fifo + 12) = dwz = (*(DWORD*)(vertex +  8));\
    dwTemp = *(DWORD*)((vertex & fvf.dwRHWMask) + fvf.dwRHWOffset);\
    frhw = (FLOAT_FROM_DWORD(dwTemp)) * pContext->dvRWFar;\
    *(DWORD*)(fifo + 16) = dwrhw = *(DWORD*)&frhw;\
    *(DWORD*)(fifo + 20) = *(DWORD*)((vertex & fvf.dwDiffuseMask) + fvf.dwDiffuseOffset);\
    dwTemp = *(DWORD*)((vertex & fvf.dwSpecularMask) + fvf.dwSpecularOffset);\
    zmask = ((*(DWORD *)&(pContext->dvWNear) == 0x3f800000) && (*(DWORD *)&(pContext->dvWFar) == 0x3f800000)) ? 0xffffffff : 0;\
    frhw = FLOAT_FROM_DWORD(dwrhw);\
    FP_INV (fw, frhw);\
    dwz = (dwz & zmask) | (*(DWORD *)&fw & ~zmask);\
    fz = FLOAT_FROM_DWORD(dwz);\
    ffog = (fz >= pContext->fFogTableEnd) ? 0.0f :\
           (fz <= pContext->fFogTableStart) ? 1.0f :\
           (pContext->fFogTableEnd - fz) * pContext->fFogTableLinearScale;\
    FP_NORM_TO_BIT24 (ifog,ffog);\
    dwTemp = (dwTemp & 0x00ffffff) | ifog;\
    *(DWORD*)(fifo + 24) = dwTemp;\
    dwTemp = (vertex & fvf.dwUVMask) + fvf.dwUVOffset[0];\
    *(DWORD*)(fifo + 28) = *(DWORD*)(dwTemp + (uvoff)[0] + 0);\
    *(DWORD*)(fifo + 32) = *(DWORD*)(dwTemp + (uvoff)[0] + 4);\
    *(DWORD*)(fifo + 36) = *(DWORD*)(dwTemp + (uvoff)[1] + 0);\
    *(DWORD*)(fifo + 40) = *(DWORD*)(dwTemp + (uvoff)[1] + 4);\
    dbgDisplayVertexData(TRUE, &(((DWORD*)nvFifo)[1]));\
    fifo      += sizeDX6TriangleVertex * 4;\
    freecount -= sizeDX6TriangleVertex;\
}

#ifdef __cplusplus
}
#endif

#endif // _nvvxmac_h_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\ddraw\common\inc\statdef.h ===
// File created by FindTrace
// Last modified: Wed Jan 03 13:49:51 2001
 

#ifndef STATDEF_H
#define STATDEF_H

typedef struct LENHASH
{
	union
	{
		DWORD offset;
		char *strPtr;
	};
	union
	{
		struct
		{
			WORD numEntries;
			WORD startID;
		};
		DWORD strLen;
	};
} LENHASH;

#define STAT_NUM_FUNCTIONS		382
#define STAT_HASH_TABLE_SIZE	122

#ifdef STAT_INSTANIATE_TABLE
LENHASH statDefHash[STAT_HASH_TABLE_SIZE] = {
	{0xffffffff, {0, 0}},
	{0xffffffff, {0, 0}},
	{0xffffffff, {0, 0}},
	{0xffffffff, {0, 0}},
	{0xffffffff, {0, 0}},
	{0xffffffff, {0, 0}},
	{0, {2, 0} },
	{14, {3, 2} },
	{38, {1, 5} },
	{47, {2, 6} },
	{67, {4, 8} },
	{111, {9, 12} },
	{219, {7, 21} },
	{310, {17, 28} },
	{548, {20, 45} },
	{848, {24, 65} },
	{1232, {25, 89} },
	{1657, {22, 114} },
	{2053, {25, 136} },
	{2528, {22, 161} },
	{2968, {23, 183} },
	{3451, {22, 206} },
	{3935, {22, 228} },
	{4441, {19, 250} },
	{4897, {19, 269} },
	{5372, {18, 288} },
	{5840, {9, 306} },
	{6083, {14, 315} },
	{6475, {4, 329} },
	{6591, {7, 333} },
	{6801, {8, 340} },
	{7049, {5, 348} },
	{7209, {5, 353} },
	{7374, {2, 358} },
	{7442, {2, 360} },
	{7512, {1, 362} },
	{7548, {2, 363} },
	{7622, {3, 365} },
	{7736, {1, 368} },
	{7775, {1, 369} },
	{7815, {1, 370} },
	{7856, {1, 371} },
	{0xffffffff, {0, 0}},
	{0xffffffff, {0, 0}},
	{0xffffffff, {0, 0}},
	{7898, {1, 372} },
	{0xffffffff, {0, 0}},
	{7944, {1, 373} },
	{0xffffffff, {0, 0}},
	{0xffffffff, {0, 0}},
	{0xffffffff, {0, 0}},
	{7992, {1, 374} },
	{0xffffffff, {0, 0}},
	{0xffffffff, {0, 0}},
	{0xffffffff, {0, 0}},
	{0xffffffff, {0, 0}},
	{0xffffffff, {0, 0}},
	{0xffffffff, {0, 0}},
	{0xffffffff, {0, 0}},
	{0xffffffff, {0, 0}},
	{0xffffffff, {0, 0}},
	{0xffffffff, {0, 0}},
	{0xffffffff, {0, 0}},
	{0xffffffff, {0, 0}},
	{0xffffffff, {0, 0}},
	{0xffffffff, {0, 0}},
	{0xffffffff, {0, 0}},
	{0xffffffff, {0, 0}},
	{0xffffffff, {0, 0}},
	{8044, {1, 375} },
	{0xffffffff, {0, 0}},
	{0xffffffff, {0, 0}},
	{8114, {1, 376} },
	{0xffffffff, {0, 0}},
	{0xffffffff, {0, 0}},
	{0xffffffff, {0, 0}},
	{0xffffffff, {0, 0}},
	{0xffffffff, {0, 0}},
	{0xffffffff, {0, 0}},
	{8187, {1, 377} },
	{0xffffffff, {0, 0}},
	{0xffffffff, {0, 0}},
	{0xffffffff, {0, 0}},
	{0xffffffff, {0, 0}},
	{0xffffffff, {0, 0}},
	{0xffffffff, {0, 0}},
	{0xffffffff, {0, 0}},
	{8267, {1, 378} },
	{0xffffffff, {0, 0}},
	{0xffffffff, {0, 0}},
	{0xffffffff, {0, 0}},
	{8355, {1, 379} },
	{0xffffffff, {0, 0}},
	{0xffffffff, {0, 0}},
	{0xffffffff, {0, 0}},
	{0xffffffff, {0, 0}},
	{0xffffffff, {0, 0}},
	{0xffffffff, {0, 0}},
	{0xffffffff, {0, 0}},
	{0xffffffff, {0, 0}},
	{0xffffffff, {0, 0}},
	{8447, {1, 380} },
	{0xffffffff, {0, 0}},
	{0xffffffff, {0, 0}},
	{0xffffffff, {0, 0}},
	{0xffffffff, {0, 0}},
	{0xffffffff, {0, 0}},
	{0xffffffff, {0, 0}},
	{0xffffffff, {0, 0}},
	{0xffffffff, {0, 0}},
	{0xffffffff, {0, 0}},
	{0xffffffff, {0, 0}},
	{0xffffffff, {0, 0}},
	{0xffffffff, {0, 0}},
	{0xffffffff, {0, 0}},
	{0xffffffff, {0, 0}},
	{0xffffffff, {0, 0}},
	{0xffffffff, {0, 0}},
	{0xffffffff, {0, 0}},
	{0xffffffff, {0, 0}},
	{0xffffffff, {0, 0}},
	{8549, {1, 381} }
};

char statDefList[] = 
		"Blit32\0"
		"Flip32\0"
		"DllMain\0"
		"__Reset\0"
		"nvClear\0"
		"nvClear2\0"
		"SetMode32\0"
		"bltStrBlt\0"
		"DriverInit\0"
		"bltTexture\0"
		"nvDP2Clear\0"
		"nvEnable32\0"
		"FreeAgpHeap\0"
		"MyExtEscape\0"
		"SetDCHandle\0"
		"WaitForIdle\0"
		"blt4CCto4CC\0"
		"nvDP2Points\0"
		"nvDP2TexBlt\0"
		"nvDisable32\0"
		"nvEnableD3D\0"
		"AllocAGPHeap\0"
		"GetModePitch\0"
		"SetEntries32\0"
		"SetPalette32\0"
		"getRootIndex\0"
		"nvDisableD3D\0"
		"nvPaletteBlt\0"
		"ColourControl\0"
		"FirstTimeInit\0"
		"GetScanLine32\0"
		"blt8bppStrBlt\0"
		"bltColourFill\0"
		"bltSimpleCopy\0"
		"bltUpdateClip\0"
		"nvD3DReenable\0"
		"nvDP2LineList\0"
		"nvDP2SetLight\0"
		"nvDP2StateSet\0"
		"nvEnableHeaps\0"
		"nvFreeContext\0"
		"nvRenderState\0"
		"nvSetDX6State\0"
		"nvTextureLock\0"
		"nvUnpalettize\0"
		"AddModeToTable\0"
		"GetBltStatus32\0"
		"GetFlatCodeSel\0"
		"GetFlatDataSel\0"
		"bltAllocAGPMem\0"
		"bltAllocSysMem\0"
		"bltAllocVidMem\0"
		"bltSetBltState\0"
		"bltSlowStoVBlt\0"
		"bltSlowVtoSBlt\0"
		"cacheFogValues\0"
		"nvDP2LineStrip\0"
		"nvDP2SetTexLOD\0"
		"nvDP2SetWRange\0"
		"nvDP2SetZRange\0"
		"nvDP2StreamEnd\0"
		"nvHWSwizzleBlt\0"
		"nvResetContext\0"
		"nvSceneCapture\0"
		"nvSetupContext\0"
		"AboutToBeLoaded\0"
		"CTexture::evict\0"
		"CTexture::fetch\0"
		"CreatePalette32\0"
		"CreateSurface32\0"
		"D3DReadRegistry\0"
		"DestroyDriver32\0"
		"FreeTextureHeap\0"
		"GetDriverInfo32\0"
		"ScaleZFillDepth\0"
		"getAdapterIndex\0"
		"nvContextCreate\0"
		"nvCreateZBuffer\0"
		"nvDP2BufferBlit\0"
		"nvDP2SetIndices\0"
		"nvDP2SetPalette\0"
		"nvDP2VolumeBlit\0"
		"nvDrawPointList\0"
		"nvEnableOverlay\0"
		"nvInitRefCounts\0"
		"nvTexManageInit\0"
		"nvTextureBltDX7\0"
		"nvTextureCreate\0"
		"nvTextureUnlock\0"
		"AcquireUserMutex\0"
		"AllocTextureHeap\0"
		"CTexture::hwLock\0"
		"DestroyPalette32\0"
		"DestroySurface32\0"
		"DrawPrimitives32\0"
		"ReleaseUserMutex\0"
		"_CTexture_rename\0"
		"bltSetSurfaces2D\0"
		"bltSimpleVtoVBlt\0"
		"buildDDHALInfo32\0"
		"nvContextDestroy\0"
		"nvDP2CreateLight\0"
		"nvDP2LineListImm\0"
		"nvDP2SetMaterial\0"
		"nvDP2SetPriority\0"
		"nvDP2SetViewport\0"
		"nvDP2TriangleFan\0"
		"nvDestroyDDLocal\0"
		"nvDrawPrimitives\0"
		"nvFindObjectList\0"
		"nvInitD3DObjects\0"
		"nvTexManageEvict\0"
		"nvTexManageFetch\0"
		"nvTexManageTouch\0"
		"AboutToBeUnloaded\0"
		"CreateDmaContexts\0"
		"CreateTextureHeap\0"
		"GetK32ProcAddress\0"
		"SortDDHalModeList\0"
		"bltAllocWorkSpace\0"
		"bltControlTraffic\0"
		"getDXShareForHead\0"
		"nvAddObjectToList\0"
		"nvCelsiusAACreate\0"
		"nvCelsiusAAMinify\0"
		"nvCreateSurfaceEx\0"
		"nvDP2SetClipPlane\0"
		"nvDP2SetTransform\0"
		"nvDP2TriangleList\0"
		"nvEnableNotifiers\0"
		"nvFindGenericList\0"
		"nvSetContextState\0"
		"nvSetHardwareCaps\0"
		"nvSetRenderTarget\0"
		"nvSwizBlt_lin2swz\0"
		"updateMipMapChain\0"
		"CDefaultVB::create\0"
		"CanCreateSurface32\0"
		"DestroyDmaContexts\0"
		"DestroyTextureHeap\0"
		"DrawOnePrimitive32\0"
		"GetHeapAlignment32\0"
		"bltEarlyErrorCheck\0"
		"getDisplayDuration\0"
		"nvCelsiusAADestroy\0"
		"nvCelsiusAAMagnify\0"
		"nvCelsiusAAMinifyZ\0"
		"nvCreateObjectList\0"
		"nvDP2DrawPrimitive\0"
		"nvDP2TriangleStrip\0"
		"nvDP2UpdatePalette\0"
		"nvDeleteObjectList\0"
		"nvDrawOnePrimitive\0"
		"nvEnableSemaphores\0"
		"nvExpandObjectList\0"
		"nvFVFDrawPointList\0"
		"nvFindSurfaceChain\0"
		"nvInitDDrawObjects\0"
		"nvSetHardwareState\0"
		"nvTextureColorFill\0"
		"nvTranslateLODBias\0"
		"BuildDDHalModeTable\0"
		"CDefaultVB::destroy\0"
		"GetOffsetTranslated\0"
		"GetTranslatedOffset\0"
		"SafeSyncSurfaceData\0"
		"_CTexture_canRename\0"
		"bltCreateContextDMA\0"
		"nvCalculateColorKey\0"
		"nvCelsiusAAMagnifyZ\0"
		"nvContextDestroyAll\0"
		"nvCreateGenericList\0"
		"nvDP2DrawPrimitive2\0"
		"nvDP2DrawTriSurface\0"
		"nvDP2RecordSetLight\0"
		"nvDP2SetPixelShader\0"
		"nvDP2SetRenderState\0"
		"nvDP2TriangleFanImm\0"
		"nvDeleteGenericList\0"
		"nvDrawPointTriangle\0"
		"nvExpandGenericList\0"
		"nvTexManageResetPtr\0"
		"nvTexManageSceneEnd\0"
		"UpdateNonLocalHeap32\0"
		"__DDHAL32_VidMemFree\0"
		"nvCelsiusAAScaledBlt\0"
		"nvDP2CaptureSetLight\0"
		"nvDP2DrawRectSurface\0"
		"nvDP2IndexedLineList\0"
		"nvDP2RecordExtension\0"
		"nvDP2RecordSetWRange\0"
		"nvDP2RecordSetZRange\0"
		"nvDP2SetRenderTarget\0"
		"nvDP2SetStreamSource\0"
		"nvDP2SetVertexShader\0"
		"nvRefreshSurfaceInfo\0"
		"nvSetD3DSurfaceState\0"
		"nvSetDX6TextureState\0"
		"nvSetSurfaceViewport\0"
		"nvStencilBufferInUse\0"
		"nvSwizzleBlt_Lin_Lin\0"
		"nvSwizzleBlt_Lin_Swz\0"
		"nvSwizzleBlt_Swz_Lin\0"
		"nvSwizzleBlt_Swz_Swz\0"
		"nvTextureDefaultFree\0"
		"nvTextureStretchBlit\0"
		"GetPointerTextureHeap\0"
		"SafeSyncVideoPortData\0"
		"__DDHAL32_VidMemAlloc\0"
		"nvAllocateContextDMAs\0"
		"nvDP2CaptureExtension\0"
		"nvDP2CaptureSetWRange\0"
		"nvDP2CaptureSetZRange\0"
		"nvDP2IndexedLineList2\0"
		"nvDP2IndexedLineStrip\0"
		"nvDP2RecordSetIndices\0"
		"nvFindNextCubemapFace\0"
		"nvGetObjectFromHandle\0"
		"nvSetDx5TriangleState\0"
		"nvStencilBufferExists\0"
		"nvSwizBlt_cpu_lin2lin\0"
		"nvSwizBlt_cpu_lin2swz\0"
		"nvSwizBlt_cpu_swz2lin\0"
		"nvSwizBlt_cpu_swz2swz\0"
		"nvSwizBlt_gpu_lin2swz\0"
		"nvTexManageAddTexture\0"
		"nvTexManageAdvancePtr\0"
		"nvTextureDefaultAlloc\0"
		"CDefaultVB::CDefaultVB\0"
		"CDriverContext::create\0"
		"CSimpleSurface::create\0"
		"CSimpleSurface::isBusy\0"
		"D3DLockExecuteBuffer32\0"
		"GetAvailDriverMemory32\0"
		"WaitForVerticalBlank32\0"
		"invalidateTextureCache\0"
		"nvAllocateDDrawObjects\0"
		"nvCelsiusAAScaledBltHW\0"
		"nvClearObjectListEntry\0"
		"nvDP2CaptureSetIndices\0"
		"nvDP2CreatePixelShader\0"
		"nvDP2DeletePixelShader\0"
		"nvDP2MultiplyTransform\0"
		"nvDP2RecordSetMaterial\0"
		"nvDP2RecordSetViewport\0"
		"nvDP2SetStreamSourceUM\0"
		"nvFVFDrawPointTriangle\0"
		"nvIndexedPointTriangle\0"
		"nvTexManageAdvanceList\0"
		"nvTextureCreateSurface\0"
		"CDefaultVB::~CDefaultVB\0"
		"CDriverContext::destroy\0"
		"CSimpleSurface::cpuLock\0"
		"Lock32: fpvidmem = %08x\0"
		"nvAddSurfaceChainToList\0"
		"nvAllocDriverStructures\0"
		"nvCalculateBumpMapState\0"
		"nvClearGenericListEntry\0"
		"nvCreateContextListHeap\0"
		"nvDP2CaptureSetMaterial\0"
		"nvDP2CaptureSetViewport\0"
		"nvDP2ClippedTriangleFan\0"
		"nvDP2CreateVertexShader\0"
		"nvDP2DeleteVertexShader\0"
		"nvDP2IndexedTriangleFan\0"
		"nvDP2RecordSetClipPlane\0"
		"nvDP2RecordSetTransform\0"
		"nvSetD3DSurfaceViewport\0"
		"nvTextureDestroySurface\0"
		"CComplexSurface::cpuLock\0"
		"CSimpleSurface::hwUnlock\0"
		"CTexture::calcMipMapSize\0"
		"CTexture::enableRenaming\0"
		"CTexture::internalRename\0"
		"D3DCreateExecuteBuffer32\0"
		"D3DCreateTextureContexts\0"
		"D3DUnlockExecuteBuffer32\0"
		"bltDestroyAllContextDMAs\0"
		"bltPotentialFaultHandler\0"
		"nvCalculateSurfaceParams\0"
		"nvCalculateZBufferParams\0"
		"nvDP2CaptureSetClipPlane\0"
		"nvDP2CaptureSetTransform\0"
		"nvDP2IndexedTriangleList\0"
		"nvDP2SetPixelShaderConst\0"
		"nvDestroyContextListHeap\0"
		"nvDrawPrimitives2 (%08x)\0"
		"nvTexManageRemoveTexture\0"
		"CComplexSurface::disown()\0"
		"CTexture[%08x]::destroy()\0"
		"D3DDestroyExecuteBuffer32\0"
		"D3DDestroyTextureContexts\0"
		"DrawOneIndexedPrimitive32\0"
		"Unlock32: fpvidmem = %08x\0"
		"nvCelsiusAAMinifyInternal\0"
		"nvCreateSurfaceWithFormat\0"
		"nvDP2DrawIndexedPrimitive\0"
		"nvDP2IndexedTriangleList2\0"
		"nvDP2IndexedTriangleStrip\0"
		"nvDP2RecordSetPixelShader\0"
		"nvDP2RecordSetRenderState\0"
		"nvDP2SetTextureStageState\0"
		"nvDP2SetVertexShaderConst\0"
		"nvDrawOneIndexedPrimitive\0"
		"nvFVFIndexedPointTriangle\0"
		"nvSetDx6MultiTextureState\0"
		"BuildDefaultDDHalModeTable\0"
		"CTexture[%08x]::CTexture()\0"
		"nvCelsiusAAMagnifyInternal\0"
		"nvCheckSystemMemorySurface\0"
		"nvDP2CaptureSetPixelShader\0"
		"nvDP2CaptureSetRenderState\0"
		"nvDP2DrawIndexedPrimitive2\0"
		"nvDP2RecordSetStreamSource\0"
		"nvDP2RecordSetVertexShader\0"
		"CNvObject::dbgTestIntegrity\0"
		"CTexture::getCubeMapFaceNum\0"
		"CTexture::internalCanRename\0"
		"CTexture[%08x]::~CTexture()\0"
		"D3DCanCreateExecuteBuffer32\0"
		"nvAutoPaletteCheckAndRevert\0"
		"nvCalculateHardwareStateDX5\0"
		"nvCelsiusSet2Stage1Combiner\0"
		"nvCreateSystemMemorySurface\0"
		"nvDP2CaptureSetStreamSource\0"
		"nvDP2CaptureSetVertexShader\0"
		"nvDeleteSystemMemorySurface\0"
		"nvValidateTextureStageState\0"
		"nvVolumeSwizBlt_cpu_lin2swz\0"
		"nv4ValidateTextureStageState\0"
		"nvCreateSurfaceWithoutFormat\0"
		"nvDP2RecordSetStreamSourceUM\0"
		"nvGetWin16MutexProcAddresses\0"
		"CComplexSurface[%08x]::swap()\0"
		"CSimpleSurface[%08x]::reset()\0"
		"GetSelectorsFromDisplayDriver\0"
		"nvCelsiusAASelectSuperBuffers\0"
		"nvDP2CaptureSetStreamSourceUM\0"
		"nvSetCelsuisBumpMap1Combiners\0"
		"nvSetCelsuisBumpMap2Combiners\0"
		"CSimpleSurface[%08x]::disown()\0"
		"FreeSelectorsFromDisplayDriver\0"
		"nvCalculateDirectHardwareState\0"
		"nvCelsiusAASelectNormalBuffers\0"
		"nvDP2RecordSetPixelShaderConst\0"
		"nvSetMultiTextureHardwareState\0"
		"nvTextureDestroy - handle=%08x\0"
		"nvTextureGetSurf - handle=%08x\0"
		"CSimpleSurface[%08x]::destroy()\0"
		"nvConvertTextureStageToDX5Class\0"
		"nvDP2CaptureSetPixelShaderConst\0"
		"nvDP2RecordSetTextureStageState\0"
		"nvDP2RecordSetVertexShaderConst\0"
		"CComplexSurface::tagRenameEnable\0"
		"CComplexSurface[%08x]::destroy()\0"
		"nvDP2CaptureSetTextureStageState\0"
		"nvDP2CaptureSetVertexShaderConst\0"
		"nvSwizzleBlt_Lin_Swz_FullTexture\0"
		"nvKelvinValidateTextureStageState\0"
		"nvPointIndexedTriangle (%d,%x,%p)\0"
		"nvCelsiusValidateTextureStageState\0"
		"nvTexManageEvictAll: pContext=%08x\0"
		"nvCelsiusSetTextures3StageCombiners\0"
		"nvCreateVidHeapVarsAndPseudoNotifier\0"
		"nvPointNonIndexedTriangle (%d,%x,%p)\0"
		"CTexture[%08x]::updateLinearSurface()\0"
		"nvSetDefaultMultiTextureHardwareState\0"
		"nvWireframeIndexedTriangle (%d,%x,%x)\0"
		"CTexture[%08x]::updateSwizzleSurface()\0"
		"nvSetRenderTargetDX7 (rt = %d, zb = %d)\0"
		"nvWireframeNonIndexedTriangle (%d,%x,%x)\0"
		"CSimpleSurface[%08x]::swap(pSurface=%08x)\0"
		"CTexture[%08x]::prepareLinearAsRenderTarget()\0"
		"nvTextureSwap - hContext=%08x, h1=%08x, h2=%08x\0"
		"CSimpleSurface[%08x]::create(pTemplateSurface=%08x)\0"
		"SetSurfaceColorKey32: lpSetCK->lpDD=%08x, lpSetCK->lpDDSurface = %08x\0"
		"CTexture[%08x]::create(dwThisFace=%d,pBaseTexture=%08x,dwMipMapLevel=%d)\0"
		"CComplexSurface[%08x]::create(dwSize=%08x,dwAllowedHeaps=%x,dwPreferredHeap=%x)\0"
		"CSimpleSurface[%08x]::own(dwAddress=%08x,dwPitch=%08x,dwH=%08x,dwHeapLoc=%x,bOwnMem=%d)\0"
		"CComplexSurface[%08x]::own(dwAddress=%08x,dwPitch=%08x,dwLogH=%08x,dwHeapLoc=%x,bOwnMem=%d)\0"
		"CSimpleSurface[%08x]::create(dwPitch=%08x,dwHt=%08x,dwDp=%08x,dwAllHeaps=%x,dwPrefHeap=%x,dwFlags=%x)\0"
		"CTexture[%08x]::create(dwWidth=%d,dwHeight=%d,dwBPP=%d,dwMipMapCount=%d,dwFormat=%x,dwAllowedHeaps=%x,dwPreferredHeap=%x)\0";
#endif	 //STAT_INSTANIATE_TABLE
#endif	// ifndef <filename>
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\ddraw\common\src\d3dContext.cpp ===
/*
 * Copyright (C) 1995 Microsoft Corporation.  All Rights Reserved.
 * (C) Copyright NVIDIA Corporation Inc., 1996,1998. All rights reserved.
 */
/********************************* Direct 3D *******************************\
*                                                                           *
* Module: d3dContext.cpp                                                    *
*   The Direct3D context management routines.                               *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*       Charles Inman (chasi)       01/02/97 - re-wrote and cleaned up.     *
*                                                                           *
\***************************************************************************/
#include "nvprecomp.h"

#if (NVARCH >= 0x04)

#ifdef PROFILE_INDEX
void nvCreateIndexProfile();
void nvDestroyIndexProfile();
#endif //PROFILE_INDEX

#ifdef NV_DISASM
HANDLE nvPusherFile               = 0;
BOOL   nvPusherDisassemblerEnable = 0;
#endif

#ifdef DEBUG_SURFACE_PLACEMENT
extern CSurfaceDebug csd;
#endif

//-------------------------------------------------------------------------

/*
 * Miscellaneous D3D context related routines.
 */
BOOL nvCreateContextListHeap
(
    GLOBALDATA *pDriverData
)
{
    dbgTracePush ("nvCreateContextListHeap");
    dbgTracePop();
    return (TRUE);
}

//-------------------------------------------------------------------------

BOOL nvDestroyContextListHeap
(
    void
)
{
    PNVD3DCONTEXT   pContext;
    PNVD3DCONTEXT   pContextNext;

    dbgTracePush ("nvDestroyContextListHeap");

    /*
     * Free any contexts that are still allocated.
     */
    pContext = (PNVD3DCONTEXT)getDC()->dwContextListHead;
    while (pContext)
    {
        pContextNext = pContext->pContextNext;
        FreeIPM(pContext);
        getDC()->dwD3DContextCount--;
        pContext = pContextNext;
    }

    dbgTracePop();
    return (TRUE);
}

/*
 * --------------------------------------------------------------------------
 * nvDestroyPreapprovedContexts
 *
 *    This function destroys all preapproved contexts that had been created
 *    and never migrated to the natural ones.
 * --------------------------------------------------------------------------
 */
void nvDestroyPreapprovedContexts(void)
{
    PNVD3DCONTEXT pPreapprovedContext, pPreapprovedContextNext;
    pPreapprovedContext = (PNVD3DCONTEXT)getDC()->dwPreapprovedContextListHead;
    getDC()->dwPreapprovedContextListHead = 0;
    while (pPreapprovedContext)
    {
        pPreapprovedContextNext = (PNVD3DCONTEXT)pPreapprovedContext->pContextNext;
        FreeIPM(pPreapprovedContext);
        pPreapprovedContext = pPreapprovedContextNext;
    }
}

/*
 * --------------------------------------------------------------------------
 * nvFindPreapprovedContext
 *
 *    This function searches the getDC()->dwPreapprovedContextListHead
 *    list of preapproved PNVD3DCONTEXT structures by the process ID.
 * --------------------------------------------------------------------------
 */
PNVD3DCONTEXT nvFindPreapprovedContext(DWORD dwPID, BOOL bRemove)
{
    PNVD3DCONTEXT pPreapprovedContext, pPreapprovedContextPrev;
    pPreapprovedContextPrev = NULL;
    pPreapprovedContext = (PNVD3DCONTEXT)getDC()->dwPreapprovedContextListHead;
    while (pPreapprovedContext)
    {
        if(pPreapprovedContext->pid == dwPID)
        {
            if (bRemove)
            {
                if (pPreapprovedContextPrev)
                    pPreapprovedContextPrev->pContextNext = pPreapprovedContext->pContextNext;
                else
                    getDC()->dwPreapprovedContextListHead = pPreapprovedContext->pContextNext;
            }
            return pPreapprovedContext;
        }
        pPreapprovedContextPrev = pPreapprovedContext;
        pPreapprovedContext = (PNVD3DCONTEXT)pPreapprovedContext->pContextNext;
    }
    return NULL;
}

/*
 * --------------------------------------------------------------------------
 * nvGetPreapprovedContext
 *
 *    This function returns a pointer to a PNVD3DCONTEXT structure
 *    which is used for saving application belongings before the natural
 *    call to the nvContextCreate has been made. The nvContextCreate must
 *    inherit all significant information being kept here. First the function
 *    looks for the PreapprovedContext in the existing list and that failed it
 *    allocates a new structure.
 * --------------------------------------------------------------------------
 */
PNVD3DCONTEXT nvGetPreapprovedContext(void)
{
    PNVD3DCONTEXT pPreapprovedContext;
    DWORD         dwPID = GetCurrentProcessId();
    if (pPreapprovedContext = nvFindPreapprovedContext(dwPID, FALSE))
        return pPreapprovedContext;
    pPreapprovedContext = (PNVD3DCONTEXT)AllocIPM(sizeof(NVD3DCONTEXT));
    if (!pPreapprovedContext)
        return NULL;
    memset(pPreapprovedContext, 0, sizeof(NVD3DCONTEXT));

    // Set the process ID for the context.
    pPreapprovedContext->pid = dwPID;
#ifdef TEX_MANAGE
    // initialize texture manager
    nvTexManageInit (pPreapprovedContext);
#endif

    /*
     * Update the context list.
     */
    pPreapprovedContext->pContextPrev = (PNVD3DCONTEXT)NULL;
    pPreapprovedContext->pContextNext = (PNVD3DCONTEXT)getDC()->dwPreapprovedContextListHead;
    if (pPreapprovedContext->pContextNext)
        pPreapprovedContext->pContextNext->pContextPrev = pPreapprovedContext;
    getDC()->dwPreapprovedContextListHead = pPreapprovedContext;
    return pPreapprovedContext;
}

/*
 * D3D HAL context callback routines
 */

/*
 * --------------------------------------------------------------------------
 * NvContextCreate
 *
 * LPD3DHAL_CONTEXTCREATEDATA pccd
 *    Pointer to a structure containing things including the current
 *    rendering surface, the current Z surface, and the DirectX object
 *    handle, etc.
 * --------------------------------------------------------------------------
 */

DWORD __stdcall nvContextCreate
(
    LPD3DHAL_CONTEXTCREATEDATA  pccd
)
{
    unsigned char              *pData = 0;
    HDDRVITEM                   hContext;
    LPDDRAWI_DDRAWSURFACE_INT   pDDS   = 0;
    LPDDRAWI_DDRAWSURFACE_INT   pDDSZ  = 0;
    LPDDRAWI_DDRAWSURFACE_LCL   pDDSLcl  = 0;
    LPDDRAWI_DDRAWSURFACE_GBL   pDDSGbl  = 0;
    LPDDRAWI_DDRAWSURFACE_LCL   pDDSLclZ = 0;
    LPDDRAWI_DIRECTDRAW_GBL     pDDGbl   = 0;

    dbgTracePush ("nvContextCreate");

    // analyzer markers
#ifdef NV_MARKER
    {
        extern DWORD dwMarkerCount;
        dwMarkerCount = 0;
    }
#endif

    // push buffer disassembler
#ifdef NV_DISASM
    {
        nvPusherFile = NvCreateFile("\\PushData.bin",GENERIC_WRITE,0,0,CREATE_ALWAYS,0,0);
        if (nvPusherFile == INVALID_HANDLE_VALUE)
        {
            nvPusherFile = 0;
        }
    }
#endif

    // Validate the direct draw surface pointers.
#ifndef WINNT // Chas said.
    if (global.dwDXRuntimeVersion >= 0x0700)
    {
        // directX 7 or higher.
        if ((pDDSLcl = pccd->lpDDSLcl) == NULL) {
            pccd->ddrval = DDERR_CURRENTLYNOTAVAIL;
            dbgTracePop();
            return (DDHAL_DRIVER_HANDLED);
        }
    }
    else
#endif // WINNT
    {
        // directX 6 or earlier and NT cause Chas said so.
        if ((pccd->lpDDSLcl == NULL))
        {
            pccd->ddrval = DDERR_CURRENTLYNOTAVAIL;
            dbgTracePop();
            return (DDHAL_DRIVER_HANDLED);
        }
        if ((pDDSLcl = DDS_LCL(pccd->lpDDSLcl)) == NULL)
        {
            pccd->ddrval = DDERR_CURRENTLYNOTAVAIL;
            dbgTracePop();
            return (DDHAL_DRIVER_HANDLED);
        }
    }

    if (pDDSLcl->ddsCaps.dwCaps & DDSCAPS_SYSTEMMEMORY)
    {
        pccd->ddrval = DDERR_CURRENTLYNOTAVAIL;
        dbgTracePop();
        return (DDHAL_DRIVER_HANDLED);
    }
    if ((pDDSGbl = pDDSLcl->lpGbl ) == NULL)
    {
        pccd->ddrval = DDERR_CURRENTLYNOTAVAIL;
        dbgTracePop();
        return DDHAL_DRIVER_HANDLED;
    }
#ifndef WINNT
    if (global.dwDXRuntimeVersion >= 0x0700)
    {
        // directX 7 or higher.
        pDDSLclZ = pccd->lpDDSZLcl;
    }
    else
#endif // !WINNT
    {
        // directX 6 or earlier
        if ((pccd->lpDDSZLcl != NULL)
            && ((pDDSLclZ = DDS_LCL(pccd->lpDDSZLcl)) == NULL)) {
            pccd->ddrval = DDERR_CURRENTLYNOTAVAIL;
            dbgTracePop();
            return (DDHAL_DRIVER_HANDLED);
        }
    }

    if (pDDSLclZ && (pDDSLclZ->ddsCaps.dwCaps & DDSCAPS_SYSTEMMEMORY))
    {
        pccd->ddrval = DDERR_CURRENTLYNOTAVAIL;
        dbgTracePop();
        return (DDHAL_DRIVER_HANDLED);
    }

    // Get pointer to global driver data structure.
    if (global.dwDXRuntimeVersion >= 0x0700) {
        pDDGbl = pccd->lpDDLcl->lpGbl;
    }
    else {
        pDDGbl = pccd->lpDDGbl;
    }
    nvSetDriverDataPtrFromDDGbl (pDDGbl);

#ifdef WINNT
    // on Win2K the registry is only read on a mode switch - read it here too so that
    // the settings can take immediate effect on windowed app too
    D3DReadRegistry (pDriverData);
#endif

    // load the logo if necessary
    nvLoadLogo();

    // connect to pm
#ifndef WINNT
    // ben BUGBUG philosophical ugliness
    DWORD dwID = (pDriverData->nvD3DPerfData.dwNVClasses & NVCLASS_0097_KELVIN) ?
                     0x020 :
                     (pDriverData->nvD3DPerfData.dwNVClasses & NVCLASS_FAMILY_CELSIUS) ?
                         0x010 :
                         0x004;
    pmConnect (pDXShare->dwHeadNumber,(U032)NvDeviceBaseGet(NV_DEV_BASE,pDriverData->dwDeviceIDNum), dwID);
#endif // !WINNT

    PNVD3DCONTEXT pContext;

    // Try to find the context among existing preapproved contexts already allocated
    pContext = nvFindPreapprovedContext (pccd->dwPID, TRUE);

    if (!pContext)
    {
        // Allocate a new context from the context array.
        hContext = (HDDRVITEM)AllocIPM(sizeof(NVD3DCONTEXT));

        // Get the pointer to the newly allocated context.
        pContext = (PNVD3DCONTEXT)hContext;
        if (!pContext)
        {
            NvReleaseSemaphore(pDriverData);
            DPF_LEVEL (NVDBG_LEVEL_ERROR, "nvContextCreate - Bad Context");
            pccd->ddrval = D3DHAL_OUTOFCONTEXTS;
            dbgTracePop();
            return (DDHAL_DRIVER_HANDLED);
        }
        memset(pContext, 0, sizeof(NVD3DCONTEXT));

        // Set the process ID for the context.
        pContext->pid = pccd->dwPID;

#ifdef TEX_MANAGE
        // initialize texture manager
        nvTexManageInit (pContext);
#endif
    }
    else {
        nvAssert(0);
    }

    // Save off the applications DirectX version level.
    //      1 -> DX5 (?)
    //      2 -> DX6
    //      3 -> DX7
    //      4 -> DX8
    switch (pccd->dwhContext)
    {
        default: // pessimism
        case 0: pContext->dwDXAppVersion = 0x300;
                break;
        case 1: pContext->dwDXAppVersion = 0x500;
                break;
        case 2: pContext->dwDXAppVersion = 0x600;
                break;
        case 3: pContext->dwDXAppVersion = 0x700;
                break;
        case 4: pContext->dwDXAppVersion = 0x800;
                break;
    }

    // Return the handle of the new context.
    pccd->dwhContext = hContext;

    // cache off a pointer to pDXShare & pDriverData
#ifdef WINNT
    pContext->ppdev    = ppdev;
#else // !WINNT
    pContext->pDXShare = pDXShare;
#endif // !WINNT
    pContext->pDriverData = pDriverData;

    // initialize the surface specific context data
    nvAssert (pDDSLcl);   // we must have a render target
    CNvObject *pNvObj = GET_PNVOBJ (pDDSLcl);
    nvAssert (IS_VALID_PNVOBJ(pNvObj));     // we better have gotten a CreateSurface32 call for this already
    if( !IS_VALID_PNVOBJ(pNvObj) ) {
            DPF_LEVEL (NVDBG_LEVEL_ERROR, "nvContextCreate - Bad Render Target");
            FreeIPM(pContext);
            pccd->dwhContext = 0;
            pccd->ddrval = DDERR_SURFACELOST;
            NvReleaseSemaphore(pDriverData);
            dbgTracePop();
            return (DDHAL_DRIVER_HANDLED);
    }
    if (global.dwDXRuntimeVersion < 0x0700) {
        // nvobject pointers may have been swapped around amongst ddslcls since this
        // surface was created. make sure this nvobject's handle still points to this ddslcl.
        pNvObj->setHandle ((DWORD)pDDSLcl);
    }
    pContext->pRenderTarget = pNvObj->getSimpleSurface();
    pContext->dwRTHandle = pNvObj->getHandle();

    // Set up the default viewport
    nvSetSurfaceViewport (pContext);

    dbgSetFrontRenderTarget (pContext, pContext->pRenderTarget);

    // check for a z-buffer
    if (pDDSLclZ) {
        pNvObj = GET_PNVOBJ (pDDSLclZ);
        nvAssert (IS_VALID_PNVOBJ(pNvObj));     // we better have gotten a CreateSurface32 call for this already
        if (global.dwDXRuntimeVersion < 0x0700) {
            pNvObj->setHandle ((DWORD)pDDSLclZ);
        }
        pContext->pZetaBuffer = pNvObj->getSimpleSurface();
        pContext->dwZBHandle = pNvObj->getHandle();
    }
    else {
        pContext->pZetaBuffer = NULL;
        pContext->dwZBHandle  = 0;
    }

    // now that both surfaces are set, check that we can actually render with this combination.
    if (!nvCheckBufferCompatibility (pContext->pRenderTarget, pContext->pZetaBuffer,
                                     pDDSLclZ, pContext->dwDXAppVersion) ||
        !CKelvinAAState::CheckBufferMemoryConfig(pContext)) {
        FreeIPM(pContext);
        pccd->dwhContext = 0;
        pccd->ddrval = DDERR_CURRENTLYNOTAVAIL;
        NvReleaseSemaphore(pDriverData);
        dbgTracePop();
        return (DDHAL_DRIVER_HANDLED);
    }

#ifdef WINNT
    /*
     * Winnt only: save a ptr to the DX driver state associated with
     * this context.
     */
    pContext->lpDD = pccd->lpDDLcl->lpGbl;
#endif // #ifdef WINNT

    // save the DIRECTDRAW_LCL and GBL associated with this context
    if (global.dwDXRuntimeVersion >= 0x0700) {
        pContext->dwDDLclID = (DWORD)(pccd->lpDDLcl);
        nvAssert (pDDGbl == pccd->lpDDLcl->lpGbl);  // there are two ways to access this. make sure they're ==
    }
    else {
        pContext->dwDDLclID = 0;     // this isn't available before DX7
        nvAssert (pDDGbl == pccd->lpDDGbl);  // there are two ways to access this. make sure they're ==
    }
    pContext->dwDDGblID = (DWORD)pDDGbl;

    /*
     * Do the hardware specific context setup.
     */
    if (!nvSetupContext(pContext))
    {
        /*
         * When this call fails, it means there was some sort of problem with the
         * surface format.  Either an unsupported pixel format was specified or
         * an unsupported pixel/zeta format was specified.
         * Free the context memory and return an error.
         */
        FreeIPM(pContext);
        NvReleaseSemaphore(pDriverData);
        pccd->dwhContext = 0;
        pContext  = 0;
        pccd->ddrval = DDERR_INVALIDPIXELFORMAT;
        dbgTracePop();
        return (DDHAL_DRIVER_HANDLED);
    }

    // zero out state set code
    pContext->pStateSets           = NULL;
    pContext->dwMaxStateSetHandles = 0;
    pContext->dwCurrentStateSet    = 0;

    // Update the open context count.
    getDC()->dwD3DContextCount++;

    // Update the context list.
    pContext->pContextPrev = (PNVD3DCONTEXT)NULL;
    pContext->pContextNext = (PNVD3DCONTEXT)getDC()->dwContextListHead;
    if (pContext->pContextNext) {
        pContext->pContextNext->pContextPrev = pContext;
    }
    getDC()->dwContextListHead = pContext;

    pContext->dwTickLastUsed = GetTickCount();

    pContext->bClearLogo = FALSE;

    // Initialize vxd frame count for statistics driver
    DDFLIPINIT();

    nvInitTLData (pContext);
#if (NVARCH >= 0x010)
    if (pDriverData->nvD3DPerfData.dwNVClasses & NVCLASS_FAMILY_KELVIN) {
        nvInitKelvinData (pContext);
    }
    else if (pDriverData->nvD3DPerfData.dwNVClasses & NVCLASS_FAMILY_CELSIUS) {
        nvInitCelsiusData (pContext);
    }
#endif

    // Create a default vertex shader
    pContext->pCurrentVShader = new CVertexShader;
    nvAssert(pContext->pCurrentVShader != NULL);
    CNvObject *pObj = new CNvObject(pContext->pid);
    nvAssert(pObj != NULL);
    pObj->setObject (CNvObject::NVOBJ_VERTEXSHADER, pContext->pCurrentVShader);

    // add this handle 0 object to the global list of objects
    // this is our default
    PNV_OBJECT_LIST pNvList = nvFindObjectList(pContext->dwDDLclID, &global.pNvVShaderLists);
    nvAddObjectToList(pNvList, pObj, 0);

    if (pContext->dwDXAppVersion >= 0x0800) {
        pContext->pVShaderConsts = new VertexShaderConsts;
        memset(pContext->pVShaderConsts, 0, sizeof(VertexShaderConsts));
    } else {
        pContext->pVShaderConsts = NULL;
    }

    // stateset schtuff
    // initially put things in 'set' (rather than 'record') mode
    pContext->pDP2FunctionTable = &nvDP2SetFuncs;

    // We clearly haven't seen any triangles yet =)
    pContext->bSeenTriangles = FALSE;

    // Initialize view and world matrix to unit matrix to avoid a mess in supertri if we try to set hwstate
    // before we get a chance to initialize the matrices (usually happens when kelvin AA is enabled)
    pContext->xfmView._11 = 1.0;
    pContext->xfmView._22 = 1.0;
    pContext->xfmView._33 = 1.0;
    pContext->xfmView._44 = 1.0;

    pContext->xfmWorld[0]._11 = 1.0;
    pContext->xfmWorld[0]._22 = 1.0;
    pContext->xfmWorld[0]._33 = 1.0;
    pContext->xfmWorld[0]._44 = 1.0;


#ifdef NV_PROFILE
    // Start up profiler
    nvpCreate();
#endif //NV_PROFILE

#ifdef PROFILE_INDEX
    nvCreateIndexProfile();
#endif // PROFILE_INDEX
#ifdef DEBUG
#ifdef HAVE_NV_FILE_FACILITY
    createDPFLog();
#endif
#endif
#ifdef NV_MARKER
    *(DWORD*)(VIDMEM_ADDR(pDriverData->BaseAddress)) = 0xcccccccc;
#endif

    // make sure we have a valid texture heap
    nvAssert (getDC()->nvD3DTexHeapData.dwHandle);  // delete after sept00

#ifdef TEX_MANAGE_TEST
    // chew up some memory
    {
        DWORD dwAddr, dwStatus, dwSize;
        //dwSize = 24 * (1<<20);  // 24 MB
        dwSize = 0x01a34000;  // 2 of 3 allocations in multitexture SDK app will succeed (1280x1024x32)
        //dwSize = 0x01a36000;  // 1 of 3 allocations in multitexture SDK app will succeed (1280x1024x32)
        //dwSize = 0x01a38000;  // 0 of 3 allocations in multitexture SDK app will succeed (1280x1024x32)
        NVHEAP_ALLOC (dwStatus, dwAddr, dwSize, TYPE_TEXTURE);
        nvAssert (dwStatus == 0);  // allocation successful
    }
#endif

#ifdef  STEREO_SUPPORT
    StereoContextCreate();
#endif  //STEREO_SUPPORT

#if (NVARCH >= 0x010)
    // Set up a few defaults
    pContext->aa.fWidthAmplifier  = 1.0f;
    pContext->aa.fHeightAmplifier = 1.0f;
    pContext->aa.dwDepthAmplifier = 1;
    pContext->aa.fLODBias         = 0.0f;
    pContext->aa.dwLinePointSize  = 0x8; // 1.0 in 6.3 fmt
#endif

    if (pDriverData->nvD3DPerfData.dwPerformanceStrategy & PS_CT_11M)
    {
        NV_CFGEX_GET_FLATPANEL_INFO_MULTI_PARAMS panel;
        NV_CFGEX_GET_MONITOR_INFO_MULTI_PARAMS monitor0, monitor1;
        NV_CFGEX_VBLANK_ENABLED_PARAMS mon0vb;
        NV_CFGEX_VBLANK_ENABLED_PARAMS pan0vb;
        DWORD dwSWidth, dwSHeight;
        NvRmConfigGet (pDriverData->dwRootHandle, NV_WIN_DEVICE, NV_CFG_SCREEN_WIDTH,  &dwSWidth);
        NvRmConfigGet (pDriverData->dwRootHandle, NV_WIN_DEVICE, NV_CFG_SCREEN_HEIGHT, &dwSHeight);
        panel.Head =0;
        NvRmConfigGetEx (pDriverData->dwRootHandle, NV_WIN_DEVICE, NV_CFGEX_GET_FLAT_PANEL_INFO_MULTI, &panel,sizeof(panel) );
        if ((panel.Head == 0) && (!panel.FlatPanelConnected) )
        {

            panel.Head =1;
            NvRmConfigGetEx (pDriverData->dwRootHandle, NV_WIN_DEVICE, NV_CFGEX_GET_FLAT_PANEL_INFO_MULTI, &panel,sizeof(panel) );
        }

        if (panel.FlatPanelConnected)
        {
            pan0vb.Head = panel.Head;
            NvRmConfigGetEx (pDriverData->dwRootHandle, NV_WIN_DEVICE, NV_CFGEX_VBLANK_ENABLED, &pan0vb,sizeof(pan0vb));

        }

        monitor0.Head = 0;
        NvRmConfigGetEx (pDriverData->dwRootHandle, NV_WIN_DEVICE, NV_CFGEX_GET_MONITOR_INFO_MULTI, &monitor0,sizeof(monitor0));

        if (monitor0.MonitorConnected)
        {
            mon0vb.Head = 0;
            NvRmConfigGetEx (pDriverData->dwRootHandle, NV_WIN_DEVICE, NV_CFGEX_VBLANK_ENABLED, &mon0vb,sizeof(mon0vb));
        }
        else
        {
            monitor1.Head = 1;
            NvRmConfigGetEx (pDriverData->dwRootHandle, NV_WIN_DEVICE, NV_CFGEX_GET_MONITOR_INFO_MULTI, &monitor1,sizeof(monitor1));
            if (monitor0.MonitorConnected)
            {
                mon0vb.Head = 0;
                NvRmConfigGetEx (pDriverData->dwRootHandle, NV_WIN_DEVICE, NV_CFGEX_VBLANK_ENABLED, &mon0vb,sizeof(mon0vb));
            }
        }



        pContext->bScaledFlatPanel = false;
        if (panel.FlatPanelConnected && (dwSWidth > 640) && (dwSHeight > 480) && (panel.FlatPanelMode == 0) && (dwSWidth < panel.FlatPanelSizeX) && (dwSHeight < panel.FlatPanelSizeY))
            if (!mon0vb.Enabled && pan0vb.Enabled)
            {
                pContext->bScaledFlatPanel = true;
            }

    }

    /*
     * Context creation complete, return successfully.
     */
    NvReleaseSemaphore(pDriverData);
    pccd->ddrval = DD_OK;
    dbgTracePop();
    return (DDHAL_DRIVER_HANDLED);
}

//-------------------------------------------------------------------------

void nvFreeContext (PNVD3DCONTEXT pContext)
{
    DWORD i;

    dbgTracePush ("nvFreeContext");

    // free the lights
    delete [](pContext->pLightArray);

    // free palettes - MS provides no formal mechanism for freeing palettes
    // a potential problem exists if the D3D context is destroyed but not the DDRAW context.
    // the video memory associated with the palette may be released and the pointer in our palette
    // object will point to memory we no longer own. Release the palette memory here to prevent this.
    // nvDP2UpdatePalette will reallocate the video memory if required.
    PNV_OBJECT_LIST pNvPaletteList = nvFindObjectList(pContext->dwDDLclID, &global.pNvPaletteLists);
    for(i = 0; i < pNvPaletteList->dwListSize; i ++) {
        CNvObject *pNvObj = nvGetObjectFromHandle(pContext->dwDDLclID, i, &global.pNvPaletteLists);
        if (pNvObj) {
            // free the video memory associated with this palette
            pNvObj->getPaletteSurface()->destroy();
        }
    }

    // free state sets
    if (pContext->pStateSets)
    {
        for (i = 0; i < pContext->dwMaxStateSetHandles; i++) {
            stateSetDelete (pContext, i);
        }

        FreeIPM (pContext->pStateSets);
    }
    pContext->pStateSets           = NULL;
    pContext->dwMaxStateSetHandles = 0;

    // only free the global data when the last context is gone
    getDC()->dwD3DContextCount --;
    if (getDC()->dwD3DContextCount == 0)
    {
#if (NVARCH >= 0x010)
        // free the celsius combiner programs
        PCELSIUSCOMBINERPROGRAM pProgram, pNext;
        for (i = 0; i < CELSIUSCPTABLE_SIZE; i++) {
            pProgram = global.celsiusCombinerProgramTable[i];
            while (pProgram) {
                pNext = pProgram->pNext;
                FreeIPM (pProgram);
                pProgram = pNext;
            }
            global.celsiusCombinerProgramTable[i] = NULL;
        }
#endif  // NVARCH >= 0x010
    }

    // remove context from context list
    if (pContext->pContextPrev) {
        pContext->pContextPrev->pContextNext = pContext->pContextNext;
    }
    if (pContext->pContextNext) {
        pContext->pContextNext->pContextPrev = pContext->pContextPrev;
    }
    if (getDC()->dwContextListHead == pContext) {
        getDC()->dwContextListHead = pContext->pContextNext;
    }

    if (pContext->pVShaderConsts) {
        delete pContext->pVShaderConsts;
        pContext->pVShaderConsts = NULL;
    }

    FreeIPM(pContext);

    dbgTracePop();
}

//-------------------------------------------------------------------------

/*
 * nvContextDestroy
 *
 * d3d callback to destroy the given context and all association with it
 */

DWORD __stdcall nvContextDestroy
(
    LPD3DHAL_CONTEXTDESTROYDATA pcdd
)
{
    dbgTracePush ("nvContextDestroy");

    // Get pointer to context being destroyed.
    PNVD3DCONTEXT pContext = (PNVD3DCONTEXT)pcdd->dwhContext;
    if (!pContext)
    {
        DPF_LEVEL (NVDBG_LEVEL_ERROR, "nvContextDestroy - Bad Context");
        pcdd->ddrval = D3DHAL_CONTEXT_BAD;
        dbgTracePop();
        return (DDHAL_DRIVER_HANDLED);
    }

    // Get pointer to global driver data structure
    nvSetDriverDataPtrFromContext(pContext);

#ifdef DEBUG_SURFACE_PLACEMENT
    csd.Destroy();
#endif

    if (getDC()->dwD3DContextCount == 0)
    {
        pcdd->ddrval = DD_OK;
        NvReleaseSemaphore(pDriverData);
        dbgTracePop();
        return (DDHAL_DRIVER_HANDLED);
    }

#ifdef  STEREO_SUPPORT
    StereoContextDestroy(pContext);
#endif  //STEREO_SUPPORT

#ifdef NV_MARKER
    *(DWORD*)(VIDMEM_ADDR(pDriverData->BaseAddress)) = 0xdddddddd;
#endif

    // push buffer disassembler
#ifdef NV_DISASM
    {
        if (nvPusherFile)
        {
            NvCloseHandle(nvPusherFile);
            nvPusherFile = 0;
        }
    }
#endif

     // disconnect from pm
     pmDisconnect();

#ifdef NV_PROFILE
    // Shut down profiler
    nvpDestroy();
#endif //NV_PROFILE

#ifdef PROFILE_INDEX
    // Shut down profiler
    nvDestroyIndexProfile();
#endif //PROFILE_INDEX

    // Perform any cleanup required.

    // kill AA
#if (NVARCH >= 0x010)
    nvCelsiusAADestroy (pContext);
#endif  // NVARCH >= 0x010

#if (NVARCH >= 0x020)
    pContext->kelvinAA.Destroy();
#endif  // NVARCH >= 0x020

#ifdef TEX_MANAGE
    nvTexManageEvictAll (pContext);
#endif

    nvFreeContext (pContext);

    // Reset the global context and texture handles.
    pDriverData->dwCurrentContextHandle = 0;

    // Return successfully.
    pcdd->ddrval = DD_OK;
    NvReleaseSemaphore(pDriverData);
    dbgTracePop();
#ifdef DEBUG
#ifdef HAVE_NV_FILE_FACILITY
    closeDPFLog();
#endif
#endif
    return (DDHAL_DRIVER_HANDLED);
}

//-------------------------------------------------------------------------

// This callback is invoked when a process dies.

DWORD __stdcall nvContextDestroyAll
(
    LPD3DHAL_CONTEXTDESTROYALLDATA  pcdd
)
{
    dbgTracePush ("nvContextDestroyAll");

    // This routine is legacy and will only ever be called in non-mulitmonitor
    // situations, so it's ok to trust what has been previously loaded into
    // pDriverData.

    if (getDC()->dwD3DContextCount == 0)
    {
        pcdd->ddrval = DD_OK;
        dbgTracePop();
        return (DDHAL_DRIVER_HANDLED);
    }

    // iterate through all contexts and destroy the ones with this PID
    PNVD3DCONTEXT pContext = (PNVD3DCONTEXT)getDC()->dwContextListHead;
    while (pContext)
    {
        PNVD3DCONTEXT pNext = pContext->pContextNext;

        if ((pcdd->dwPID == ~0) || (pContext->pid == pcdd->dwPID))
        {
            D3DHAL_CONTEXTDESTROYDATA pcdd;
            pcdd.dwhContext = (ULONG_PTR) pContext;
            nvContextDestroy (&pcdd);
        }

        pContext = pNext;
    }

    // Destroy all objects associated with this PID.
    // For our own purposes we use a PID value of ~0 to indicate that we want to destroy all PIDs
    for (CNvObject *pNvObj = global.pNvObjectHead; pNvObj;)
    {
        // get next
        CNvObject *pNext = pNvObj->getNext();

        // should we free it?
        if (((pcdd->dwPID == ~0) || (pNvObj->getPID() == pcdd->dwPID))
#ifndef WINNT
            && (pNvObj != (CNvObject*)pDXShare->pNvPrimarySurf)
#endif
           )
        {
            CCommandBuffer *pCommandBuffer = pNvObj->getCommandBuffer();
            if (pCommandBuffer)
            {
                SET_PNVOBJ (pCommandBuffer->getDDSurfaceLcl(), NULL);
            }
            // cleanup is handled in nvObject release
            pNvObj->release();
        }
        pNvObj = pNext;
    }

    // Reset the global context and texture handles.
    pDriverData->dwCurrentContextHandle = 0;

    pcdd->ddrval = DD_OK;
    dbgTracePop();
    return (DDHAL_DRIVER_HANDLED);
}

//-------------------------------------------------------------------------

DWORD __stdcall nvDestroyDDLocal
(
    LPDDHAL_DESTROYDDLOCALDATA pdddld
)
{
    nvSetDriverDataPtrFromDDGbl (pdddld->pDDLcl->lpGbl);

    dbgTracePush ("nvDestroyDDLocal");
    nvAssert (pdddld->pDDLcl != NULL);

    for (CNvObject *pNvObj = global.pNvObjectHead; pNvObj;)
    {
        CNvObject *pNext = pNvObj->getNext();

        // does it belong to this context?
        if (pNvObj->getDDLclID() == (DWORD)pdddld->pDDLcl)
        {
            switch(pNvObj->getClass()) {
            // release these object types
            case CNvObject::NVOBJ_VERTEXSHADER:
            case CNvObject::NVOBJ_CACHEDPATCH:
            case CNvObject::NVOBJ_PALETTE:
            case CNvObject::NVOBJ_PIXELSHADER:
                pNvObj->release();
                break;
            // ignore these
            case CNvObject::NVOBJ_TEXTURE:
            case CNvObject::NVOBJ_VERTEXBUFFER:
            case CNvObject::NVOBJ_COMMANDBUFFER:
            case CNvObject::NVOBJ_SIMPLESURFACE:
                // nvAssert(0);  -- DCT can get here legitimately
                break;
            // unknown object type
            default:
                break;
            }
        }
        pNvObj = pNext;
    }

    nvDeleteObjectList ((DWORD)pdddld->pDDLcl, &global.pNvSurfaceLists);
    nvDeleteObjectList ((DWORD)pdddld->pDDLcl, &global.pNvPaletteLists);
    nvDeleteObjectList ((DWORD)pdddld->pDDLcl, &global.pNvVShaderLists);
    nvDeleteObjectList ((DWORD)pdddld->pDDLcl, &global.pNvPShaderLists);
    nvDeleteObjectList ((DWORD)pdddld->pDDLcl, &global.pNvPatchLists);
    
#ifdef WINNT
    // display heap usage
    g_nvIPHeap.checkHeapUsage();
#endif

    NvReleaseSemaphore(pDriverData);
    pdddld->ddRVal = DD_OK;
    dbgTracePop();
    return (DDHAL_DRIVER_HANDLED);
}

#endif  // NVARCH >= 0x04
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\ddraw\common\src\d3dDebug.cpp ===
// **************************************************************************
//
//       Copyright 1993-1999 NVIDIA, Corporation.  All rights reserved.
//
//     NOTICE TO USER:   The source code  is copyrighted under  U.S. and
//     international laws.  Users and possessors of this source code are
//     hereby granted a nonexclusive,  royalty-free copyright license to
//     use this code in individual and commercial software.
//
//     Any use of this source code must include,  in the user documenta-
//     tion and  internal comments to the code,  notices to the end user
//     as follows:
//
//       Copyright 1993-1999 NVIDIA, Corporation.  All rights reserved.
//
//     NVIDIA, CORPORATION MAKES NO REPRESENTATION ABOUT THE SUITABILITY
//     OF  THIS SOURCE  CODE  FOR ANY PURPOSE.  IT IS  PROVIDED  "AS IS"
//     WITHOUT EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORPOR-
//     ATION DISCLAIMS ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,
//     INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY, NONINFRINGE-
//     MENT,  AND FITNESS  FOR A PARTICULAR PURPOSE.   IN NO EVENT SHALL
//     NVIDIA, CORPORATION  BE LIABLE FOR ANY SPECIAL,  INDIRECT,  INCI-
//     DENTAL, OR CONSEQUENTIAL DAMAGES,  OR ANY DAMAGES  WHATSOEVER RE-
//     SULTING FROM LOSS OF USE,  DATA OR PROFITS,  WHETHER IN AN ACTION
//     OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,  ARISING OUT OF
//     OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOURCE CODE.
//
//     U.S. Government  End  Users.   This source code  is a "commercial
//     item,"  as that  term is  defined at  48 C.F.R. 2.101 (OCT 1995),
//     consisting  of "commercial  computer  software"  and  "commercial
//     computer  software  documentation,"  as such  terms  are  used in
//     48 C.F.R. 12.212 (SEPT 1995)  and is provided to the U.S. Govern-
//     ment only as  a commercial end item.   Consistent with  48 C.F.R.
//     12.212 and  48 C.F.R. 227.7202-1 through  227.7202-4 (JUNE 1995),
//     all U.S. Government End Users  acquire the source code  with only
//     those rights set forth herein.
//
// ********************************* Direct 3D ******************************
//
//  Module: d3dDebug.cpp
//      D3D-specific debugging routines
//
// **************************************************************************
//
//  History:
//      Chas Inman              18Nov97         original version
//      Craig Duttweiler        21Nov00         major rehash
//
// **************************************************************************
#include "nvprecomp.h"

#if (NVARCH >= 0x04)

#ifdef WINNT
    void atexit (void) {};
#endif

//-------------------------------------------------------------------------
// GLOBAL VARIABLES
//---------------------------------------------------------------------------

#ifdef DEBUG

    // general debugging
    DWORD          dbgShowState             = 0x00000000;
    DWORD          dbgDumpState             = 0x00000000;
    DWORD          dbgFlush                 = 0x00000000; // Flush Nothing
    DWORD          dbgForceHWRefresh        = 0x00000000;

    // primary info (shared by front buffer rendering and texture previewing)
    DWORD          dbgPrimaryPitch          = 0;
    DWORD          dbgPrimaryHeight         = 0;
    DWORD          dbgPrimaryBPP            = 0;

    // front buffer rendering
    CSimpleSurface dbgFrontRenderSurface;
    BOOL           dbgFrontRender           = 0;

    // texture previewing
    DWORD          dbgTexturePreview        = 0;

#endif  // DEBUG

//-------------------------------------------------------------------------
// STRING TABLES
//---------------------------------------------------------------------------

#ifdef DEBUG

char szD3DBoolean[][32] =
{
    "FALSE",
    "TRUE",
};

char szD3DShadeMode[][32] =
{
    "NULL",
    "D3DSHADE_FLAT",
    "D3DSHADE_GOURAUD",
    "D3DSHADE_PHONG"
};

char szD3DFillMode[][32] =
{
    "NULL",
    "D3DFILL_POINT",
    "D3DFILL_WIREFRAME",
    "D3DFILL_SOLID"
};

char szD3DTextureFilter[][32] =
{
    "NULL",
    "D3DFILTER_NEAREST",
    "D3DFILTER_LINEAR",
    "D3DFILTER_MIPNEAREST",
    "D3DFILTER_MIPLINEAR",
    "D3DFILTER_LINEARMIPNEAREST",
    "D3DFILTER_LINEARMIPLINEAR"
};

char szD3DBlend[][32] =
{
    "NULL",
    "D3DBLEND_ZERO",
    "D3DBLEND_ONE",
    "D3DBLEND_SRCCOLOR",
    "D3DBLEND_INVSRCCOLOR",
    "D3DBLEND_SRCALPHA",
    "D3DBLEND_INVSRCALPHA",
    "D3DBLEND_DESTALPHA",
    "D3DBLEND_INVDESTALPHA",
    "D3DBLEND_DESTCOLOR",
    "D3DBLEND_INVDESTCOLOR",
    "D3DBLEND_SRCALPHASAT",
    "D3DBLEND_BOTHSRCALPHA",
    "D3DBLEND_BOTHINVSRCALPHA"
};

char szD3DTextureBlend[][32] =
{
    "NULL",
    "D3DTBLEND_DECAL",
    "D3DTBLEND_MODULATE",
    "D3DTBLEND_DECALALPHA",
    "D3DTBLEND_MODULATEALPHA",
    "D3DTBLEND_DECALMASK",
    "D3DTBLEND_MODULATEMASK",
    "D3DTBLEND_COPY",
    "D3DTBLEND_ADD"
};

char szD3DTextureAddress[][32] =
{
    "NULL",
    "D3DTADDRESS_WRAP",
    "D3DTADDRESS_MIRROR",
    "D3DTADDRESS_CLAMP",
    "D3DTADDRESS_BORDER"
};

char szD3DCull[][32] =
{
    "NULL",
    "D3DCULL_NONE",
    "D3DCULL_CW",
    "D3DCULL_CCW"
};

char szD3DCmpFunc[][32] =
{
    "NULL",
    "D3DCMP_NEVER",
    "D3DCMP_LESS",
    "D3DCMP_EQUAL",
    "D3DCMP_LESSEQUAL",
    "D3DCMP_GREATER",
    "D3DCMP_NOTEQUAL",
    "D3DCMP_GREATEREQUAL",
    "D3DCMP_ALWAYS"
};

char szD3DStencilOp[][32] =
{
    "NULL",
    "D3DSTENCILOP_KEEP",
    "D3DSTENCILOP_ZERO",
    "D3DSTENCILOP_REPLACE",
    "D3DSTENCILOP_INCRSAT",
    "D3DSTENCILOP_DECRSAT",
    "D3DSTENCILOP_INVERT",
    "D3DSTENCILOP_INCR",
    "D3DSTENCILOP_DECR"
};

char szD3DFogMode[][32] =
{
    "D3DFOG_NONE",
    "D3DFOG_EXP",
    "D3DFOG_EXP2",
    "D3DFOG_LINEAR"
};

char szD3DZBufferType[][32] =
{
    "D3DZB_FALSE",
    "D3DZB_TRUE",
    "D3DZB_USEW"
};

char szD3DAntiAliasMode[][32] =
{
    "NULL",
    "D3DANTIALIAS_NONE",
    "D3DANTIALIAS_SORTDEPENDENT",
    "D3DANTIALIAS_SORTINDEPENDENT"
};

char szD3DTextureOp[][36] =
{
    "NULL",
    "D3DTOP_DISABLE",
    "D3DTOP_SELECTARG1",
    "D3DTOP_SELECTARG2",
    "D3DTOP_MODULATE",
    "D3DTOP_MODULATE2X",
    "D3DTOP_MODULATE4X",
    "D3DTOP_ADD",
    "D3DTOP_ADDSIGNED",
    "D3DTOP_ADDSIGNED2X",
    "D3DTOP_SUBTRACT",
    "D3DTOP_ADDSMOOTH",
    "D3DTOP_BLENDDIFFUSEALPHA",
    "D3DTOP_BLENDTEXTUREALPHA",
    "D3DTOP_BLENDFACTORALPHA",
    "D3DTOP_BLENDTEXTUREALPHAPM",
    "D3DTOP_BLENDCURRENTALPHA",
    "D3DTOP_PREMODULATE",
    "D3DTOP_MODULATEALPHA_ADDCOLOR",
    "D3DTOP_MODULATECOLOR_ADDALPHA",
    "D3DTOP_MODULATEINVALPHA_ADDCOLOR",
    "D3DTOP_MODULATEINVCOLOR_ADDALPHA",
    "D3DTOP_BUMPENVMAP",
    "D3DTOP_BUMPENVMAPLUMINANCE",
    "D3DTOP_DOTPRODUCT3"
};

char szD3DArg[][64] =
{
    "D3DTA_DIFFUSE",
    "D3DTA_CURRENT",
    "D3DTA_TEXTURE",
    "D3DTA_TFACTOR",
    "INVALID",
    "INVALID",
    "INVALID",
    "INVALID",
    "INVALID",
    "INVALID",
    "INVALID",
    "INVALID",
    "INVALID",
    "INVALID",
    "INVALID",
    "INVALID",
    "D3DTA_DIFFUSE | D3DTA_COMPLEMENT",
    "D3DTA_CURRENT | D3DTA_COMPLEMENT",
    "D3DTA_TEXTURE | D3DTA_COMPLEMENT",
    "D3DTA_TFACTOR | D3DTA_COMPLEMENT",
    "INVALID",
    "INVALID",
    "INVALID",
    "INVALID",
    "INVALID",
    "INVALID",
    "INVALID",
    "INVALID",
    "INVALID",
    "INVALID",
    "INVALID",
    "INVALID",
    "D3DTA_DIFFUSE | D3DTA_ALPHAREPLICATE",
    "D3DTA_CURRENT | D3DTA_ALPHAREPLICATE",
    "D3DTA_TEXTURE | D3DTA_ALPHAREPLICATE",
    "D3DTA_TFACTOR | D3DTA_ALPHAREPLICATE",
    "INVALID",
    "INVALID",
    "INVALID",
    "INVALID",
    "INVALID",
    "INVALID",
    "INVALID",
    "INVALID",
    "INVALID",
    "INVALID",
    "INVALID",
    "INVALID",
    "D3DTA_DIFFUSE | D3DTA_COMPLEMENT | D3DTA_ALPHAREPLICATE",
    "D3DTA_CURRENT | D3DTA_COMPLEMENT | D3DTA_ALPHAREPLICATE",
    "D3DTA_TEXTURE | D3DTA_COMPLEMENT | D3DTA_ALPHAREPLICATE",
    "D3DTA_TFACTOR | D3DTA_COMPLEMENT | D3DTA_ALPHAREPLICATE",
    "INVALID",
    "INVALID",
    "INVALID",
    "INVALID",
    "INVALID",
    "INVALID",
    "INVALID",
    "INVALID",
    "INVALID",
    "INVALID",
    "INVALID",
    "INVALID"
};

char szD3DArgModifier[][32] =
{
    "D3DTA_NORMAL",
    "D3DTA_COMPLEMENT",
    "D3DTA_ALPHAREPLICATE"
};

char szD3DTextureMagFilter[][32] =
{
    "NULL",
    "D3DTFG_POINT",
    "D3DTFG_LINEAR",
    "D3DTFG_FLATCUBIC",
    "D3DTFG_GAUSSIANCUBIC",
    "D3DTFG_ANISOTROPIC"
};

char szD3DTextureMinFilter[][32] =
{
    "NULL",
    "D3DTFN_POINT",
    "D3DTFN_LINEAR",
    "D3DTFN_ANISOTROPIC"
};

char szD3DTextureMipFilter[][32] =
{
    "NULL",
    "D3DTFP_POINT",
    "D3DTFP_LINEAR"
};

char szD3DRenderStateLookupTable[D3D_RENDERSTATE_MAX+1][50] =
{
    "D3DRENDERSTATE_UNKNOWN",                       // 0
    "D3DRENDERSTATE_TEXTUREHANDLE",                 // 1
    "D3DRENDERSTATE_ANTIALIAS",                     // 2   D3DANTIALIASMODE
    "D3DRENDERSTATE_TEXTUREADDRESS",                // 3
    "D3DRENDERSTATE_TEXTUREPERSPECTIVE",            // 4   TRUE for perspective correction
    "D3DRENDERSTATE_WRAPU",                         // 5
    "D3DRENDERSTATE_WRAPV",                         // 6
    "D3DRENDERSTATE_ZENABLE",                       // 7   D3DZBUFFERTYPE (or TRUE/FALSE for legacy)
    "D3DRENDERSTATE_FILLMODE",                      // 8   D3DFILL_MODE
    "D3DRENDERSTATE_SHADEMODE",                     // 9   D3DSHADEMODE
    "D3DRENDERSTATE_LINEPATTERN",                   // 10  D3DLINEPATTERN
    "D3DRENDERSTATE_MONOENABLE",                    // 11  TRUE to enable mono rasterization
    "D3DRENDERSTATE_ROP2",                          // 12  ROP2
    "D3DRENDERSTATE_PLANEMASK",                     // 13
    "D3DRENDERSTATE_ZWRITEENABLE",                  // 14  TRUE to enable z writes
    "D3DRENDERSTATE_ALPHATESTENABLE",               // 15  TRUE to enable alpha tests
    "D3DRENDERSTATE_LASTPIXEL",                     // 16  TRUE for last-pixel on lines
    "D3DRENDERSTATE_TEXTUREMAG",                    // 17
    "D3DRENDERSTATE_TEXTUREMIN",                    // 18
    "D3DRENDERSTATE_SRCBLEND",                      // 19  D3DBLEND
    "D3DRENDERSTATE_DESTBLEND",                     // 20  D3DBLEND
    "D3DRENDERSTATE_TEXTUREMAPBLEND",               // 21
    "D3DRENDERSTATE_CULLMODE",                      // 22  D3DCULL
    "D3DRENDERSTATE_ZFUNC",                         // 23  D3DCMPFUNC
    "D3DRENDERSTATE_ALPHAREF",                      // 24  D3DFIXED
    "D3DRENDERSTATE_ALPHAFUNC",                     // 25  D3DCMPFUNC
    "D3DRENDERSTATE_DITHERENABLE",                  // 26  TRUE to enable dithering
    "D3DRENDERSTATE_ALPHABLENDENABLE",              // 27  TRUE to enable alpha blending
    "D3DRENDERSTATE_FOGENABLE",                     // 28  TRUE to enable fog blending
    "D3DRENDERSTATE_SPECULARENABLE",                // 29  TRUE to enable specular
    "D3DRENDERSTATE_ZVISIBLE",                      // 30  TRUE to enable z checking
    "D3DRENDERSTATE_SUBPIXEL",                      // 31
    "D3DRENDERSTATE_SUBPIXELX",                     // 32
    "D3DRENDERSTATE_STIPPLEDALPHA",                 // 33  TRUE to enable stippled alpha (RGB device only)
    "D3DRENDERSTATE_FOGCOLOR",                      // 34  D3DCOLOR
    "D3DRENDERSTATE_FOGTABLEMODE",                  // 35  D3DFOGMODE
    "D3DRENDERSTATE_FOGSTART",                      // 36  Fog start (for both vertex and pixel fog)
    "D3DRENDERSTATE_FOGEND",                        // 37  Fog end
    "D3DRENDERSTATE_FOGDENSITY",                    // 38  Fog density
    "D3DRENDERSTATE_STIPPLEENABLE",                 // 39  TRUE to enable stippling
    "D3DRENDERSTATE_EDGEANTIALIAS",                 // 40  TRUE to enable edge antialiasing
    "D3DRENDERSTATE_COLORKEYENABLE",                // 41  TRUE to enable source colorkeyed textures
    "D3DRENDERSTATE_UNKNOWN",                       // 42
    "D3DRENDERSTATE_BORDERCOLOR",                   // 43  Border color for texturing w/border
    "D3DRENDERSTATE_TEXTUREADDRESSU",               // 44  Texture addressing mode for U coordinate
    "D3DRENDERSTATE_TEXTUREADDRESSV",               // 45  Texture addressing mode for V coordinate
    "D3DRENDERSTATE_MIPMAPLODBIAS",                 // 46  D3DVALUE Mipmap LOD bias
    "D3DRENDERSTATE_ZBIAS",                         // 47  LONG Z bias
    "D3DRENDERSTATE_RANGEFOGENABLE",                // 48  Enables range-based fog
    "D3DRENDERSTATE_ANISOTROPY",                    // 49  Max. anisotropy. 1 = no anisotropy
    "D3DRENDERSTATE_FLUSHBATCH",                    // 50  Explicit flush for DP batching (DX5 Only)
    "D3DRENDERSTATE_TRANSLUCENTSORTINDEPENDENT",    // 51  BOOL enable sort-independent transparency
    "D3DRENDERSTATE_STENCILENABLE",                 // 52  BOOL enable/disable stenciling
    "D3DRENDERSTATE_STENCILFAIL",                   // 53  D3DSTENCILOP to do if stencil test fails
    "D3DRENDERSTATE_STENCILZFAIL",                  // 54  D3DSTENCILOP to do if stencil test passes and Z test fails
    "D3DRENDERSTATE_STENCILPASS",                   // 55  D3DSTENCILOP to do if both stencil and Z tests pass
    "D3DRENDERSTATE_STENCILFUNC",                   // 56  D3DCMPFUNC fn.  Stencil Test passes if ((ref & mask) stencilfn (stencil & mask)) is true
    "D3DRENDERSTATE_STENCILREF",                    // 57  Reference value used in stencil test
    "D3DRENDERSTATE_STENCILMASK",                   // 58  Mask value used in stencil test
    "D3DRENDERSTATE_STENCILWRITEMASK",              // 59  Write mask applied to values written to stencil buffer
    "D3DRENDERSTATE_TEXTUREFACTOR",                 // 60  D3DCOLOR used for multi-texture blend
    "D3DRENDERSTATE_EVICTMANAGEDTEXTURES",          // 61  D3DRENDERSTATE_EVICTMANAGEDTEXTURES???
    "D3DRENDERSTATE_SCENECAPTURE",                  // 62  D3DRENDERSTATE_SCENECAPTURE???
    "D3DRENDERSTATE_UNKNOWN",                       // 63  invalid???
    "D3DRENDERSTATE_STIPPLEPATTERN00",              // 64  Stipple pattern 01...
    "D3DRENDERSTATE_STIPPLEPATTERN01",              // 65
    "D3DRENDERSTATE_STIPPLEPATTERN02",              // 66
    "D3DRENDERSTATE_STIPPLEPATTERN03",              // 67
    "D3DRENDERSTATE_STIPPLEPATTERN04",              // 68
    "D3DRENDERSTATE_STIPPLEPATTERN05",              // 69
    "D3DRENDERSTATE_STIPPLEPATTERN06",              // 70
    "D3DRENDERSTATE_STIPPLEPATTERN07",              // 71
    "D3DRENDERSTATE_STIPPLEPATTERN08",              // 72
    "D3DRENDERSTATE_STIPPLEPATTERN09",              // 73
    "D3DRENDERSTATE_STIPPLEPATTERN10",              // 74
    "D3DRENDERSTATE_STIPPLEPATTERN11",              // 75
    "D3DRENDERSTATE_STIPPLEPATTERN12",              // 76
    "D3DRENDERSTATE_STIPPLEPATTERN13",              // 77
    "D3DRENDERSTATE_STIPPLEPATTERN14",              // 78
    "D3DRENDERSTATE_STIPPLEPATTERN15",              // 79
    "D3DRENDERSTATE_STIPPLEPATTERN16",              // 80
    "D3DRENDERSTATE_STIPPLEPATTERN17",              // 81
    "D3DRENDERSTATE_STIPPLEPATTERN18",              // 82
    "D3DRENDERSTATE_STIPPLEPATTERN19",              // 83
    "D3DRENDERSTATE_STIPPLEPATTERN20",              // 84
    "D3DRENDERSTATE_STIPPLEPATTERN21",              // 85
    "D3DRENDERSTATE_STIPPLEPATTERN22",              // 86
    "D3DRENDERSTATE_STIPPLEPATTERN23",              // 87
    "D3DRENDERSTATE_STIPPLEPATTERN24",              // 88
    "D3DRENDERSTATE_STIPPLEPATTERN25",              // 89
    "D3DRENDERSTATE_STIPPLEPATTERN26",              // 90
    "D3DRENDERSTATE_STIPPLEPATTERN27",              // 91
    "D3DRENDERSTATE_STIPPLEPATTERN28",              // 92
    "D3DRENDERSTATE_STIPPLEPATTERN29",              // 93
    "D3DRENDERSTATE_STIPPLEPATTERN30",              // 94
    "D3DRENDERSTATE_STIPPLEPATTERN31",              // 95
    "D3DRENDERSTATE_UNKNOWN",                       // 96
    "D3DRENDERSTATE_UNKNOWN",                       // 97
    "D3DRENDERSTATE_UNKNOWN",                       // 98
    "D3DRENDERSTATE_UNKNOWN",                       // 99
    "D3DRENDERSTATE_UNKNOWN",                       // 100
    "D3DRENDERSTATE_UNKNOWN",                       // 101
    "D3DRENDERSTATE_UNKNOWN",                       // 102
    "D3DRENDERSTATE_UNKNOWN",                       // 103
    "D3DRENDERSTATE_UNKNOWN",                       // 104
    "D3DRENDERSTATE_UNKNOWN",                       // 105
    "D3DRENDERSTATE_UNKNOWN",                       // 106
    "D3DRENDERSTATE_UNKNOWN",                       // 107
    "D3DRENDERSTATE_UNKNOWN",                       // 108
    "D3DRENDERSTATE_UNKNOWN",                       // 109
    "D3DRENDERSTATE_UNKNOWN",                       // 110
    "D3DRENDERSTATE_UNKNOWN",                       // 111
    "D3DRENDERSTATE_UNKNOWN",                       // 112
    "D3DRENDERSTATE_UNKNOWN",                       // 113
    "D3DRENDERSTATE_UNKNOWN",                       // 114
    "D3DRENDERSTATE_UNKNOWN",                       // 115
    "D3DRENDERSTATE_UNKNOWN",                       // 116
    "D3DRENDERSTATE_UNKNOWN",                       // 117
    "D3DRENDERSTATE_UNKNOWN",                       // 118
    "D3DRENDERSTATE_UNKNOWN",                       // 119
    "D3DRENDERSTATE_UNKNOWN",                       // 120
    "D3DRENDERSTATE_UNKNOWN",                       // 121
    "D3DRENDERSTATE_UNKNOWN",                       // 122
    "D3DRENDERSTATE_UNKNOWN",                       // 123
    "D3DRENDERSTATE_UNKNOWN",                       // 124
    "D3DRENDERSTATE_UNKNOWN",                       // 125
    "D3DRENDERSTATE_UNKNOWN",                       // 126
    "D3DRENDERSTATE_UNKNOWN",                       // 127
    "D3DRENDERSTATE_WRAP0",                         // 128  wrap for 1st texture coord. set
    "D3DRENDERSTATE_WRAP1",                         // 129  wrap for 2nd texture coord. set
    "D3DRENDERSTATE_WRAP2",                         // 130  wrap for 3rd texture coord. set
    "D3DRENDERSTATE_WRAP3",                         // 131  wrap for 4th texture coord. set
    "D3DRENDERSTATE_WRAP4",                         // 132  wrap for 5th texture coord. set
    "D3DRENDERSTATE_WRAP5",                         // 133  wrap for 6th texture coord. set
    "D3DRENDERSTATE_WRAP6",                         // 134  wrap for 7th texture coord. set
    "D3DRENDERSTATE_WRAP7",                         // 135  wrap for 8th texture coord. set
    "D3DRENDERSTATE_CLIPPING",                      // 136
    "D3DRENDERSTATE_LIGHTING",                      // 137
    "D3DRENDERSTATE_EXTENTS",                       // 138
    "D3DRENDERSTATE_AMBIENT",                       // 139
    "D3DRENDERSTATE_FOGVERTEXMODE",                 // 140
    "D3DRENDERSTATE_COLORVERTEX",                   // 141
    "D3DRENDERSTATE_LOCALVIEWER",                   // 142
    "D3DRENDERSTATE_NORMALIZENORMALS",              // 143
    "D3DRENDERSTATE_COLORKEYBLENDENABLE",           // 144
    "D3DRENDERSTATE_DIFFUSEMATERIALSOURCE",         // 145
    "D3DRENDERSTATE_SPECULARMATERIALSOURCE",        // 146
    "D3DRENDERSTATE_AMBIENTMATERIALSOURCE",         // 147
    "D3DRENDERSTATE_EMISSIVEMATERIALSOURCE",        // 148
    "D3DRENDERSTATE_UNKNOWN",                       // 149
    "D3DRENDERSTATE_UNKNOWN",                       // 150
    "D3DRENDERSTATE_VERTEXBLEND",                   // 151
    "D3DRENDERSTATE_CLIPPLANEENABLE",               // 152
    "D3DRS_SOFTWAREVERTEXPROCESSING",               // 153
    "D3DRS_POINTSIZE",                              // 154
    "D3DRS_POINTSIZE_MIN",                          // 155
    "D3DRS_POINTSPRITEENABLE",                      // 156
    "D3DRS_POINTSCALEENABLE",                       // 157
    "D3DRS_POINTSCALE_A",                           // 158
    "D3DRS_POINTSCALE_B",                           // 159
    "D3DRS_POINTSCALE_C",                           // 160
    "D3DRS_MULTISAMPLEANTIALIAS",                   // 161
    "D3DRS_MULTISAMPLEMASK",                        // 162
    "D3DRS_PATCHEDGESTYLE",                         // 163
    "D3DRS_PRIMSEGMENTS",                           // 164
    "D3DRS_DEBUGMONITORTOKEN",                      // 165
    "D3DRS_POINTSIZE_MAX",                          // 166
    "D3DRS_INDEXEDVERTEXBLENDENABLE",               // 167
    "D3DRS_COLORWRITEENABLE",                       // 168
    "D3DRENDERSTATE_UNKNOWN",                       // 169
    "D3DRS_TWEENFACTOR",                            // 170
    "D3DRS_BLENDOP"                                 // 171
};

char szD3DDP2OpLookupTable[D3D_DP2OP_MAX+1][64] =
{
    "D3DDP2OP_UNKNOWN",                             //  0
    "D3DDP2OP_POINTS",                              //  1
    "D3DDP2OP_INDEXEDLINELIST",                     //  2
    "D3DDP2OP_INDEXEDTRIANGLELIST",                 //  3
    "D3DDP2OP_RESERVED0",                           //  4
    "D3DDP2OP_UNKNOWN",                             //  5
    "D3DDP2OP_UNKNOWN",                             //  6
    "D3DDP2OP_UNKNOWN",                             //  7
    "D3DDP2OP_RENDERSTATE",                         //  8
    "D3DDP2OP_UNKNOWN",                             //  9
    "D3DDP2OP_UNKNOWN",                             // 10
    "D3DDP2OP_END",                                 // 11
    "D3DDP2OP_UNKNOWN",                             // 12
    "D3DDP2OP_UNKNOWN",                             // 13
    "D3DDP2OP_UNKNOWN",                             // 14
    "D3DDP2OP_LINELIST",                            // 15
    "D3DDP2OP_LINESTRIP",                           // 16
    "D3DDP2OP_INDEXEDLINESTRIP",                    // 17
    "D3DDP2OP_TRIANGLELIST",                        // 18
    "D3DDP2OP_TRIANGLESTRIP",                       // 19
    "D3DDP2OP_INDEXEDTRIANGLESTRIP",                // 20
    "D3DDP2OP_TRIANGLEFAN",                         // 21
    "D3DDP2OP_INDEXEDTRIANGLEFAN",                  // 22
    "D3DDP2OP_TRIANGLEFAN_IMM",                     // 23
    "D3DDP2OP_LINELIST_IMM",                        // 24
    "D3DDP2OP_TEXTURESTAGESTATE",                   // 25
    "D3DDP2OP_INDEXEDTRIANGLELIST2",                // 26
    "D3DDP2OP_INDEXEDLINELIST2",                    // 27
    "D3DDP2OP_VIEWPORTINFO",                        // 28
    "D3DDP2OP_WINFO",                               // 29
    "D3DDP2OP_SETPALETTE",                          // 30
    "D3DDP2OP_UPDATEPALETTE",                       // 31
    "D3DDP2OP_ZRANGE",                              // 32
    "D3DDP2OP_SETMATERIAL",                         // 33
    "D3DDP2OP_SETLIGHT",                            // 34
    "D3DDP2OP_CREATELIGHT",                         // 35
    "D3DDP2OP_SETTRANSFORM",                        // 36
    "D3DDP2OP_EXT",                                 // 37
    "D3DDP2OP_TEXBLT",                              // 38
    "D3DDP2OP_STATESET",                            // 39
    "D3DDP2OP_SETPRIORITY",                         // 40
    "D3DDP2OP_SETRENDERTARGET",                     // 41
    "D3DDP2OP_CLEAR",                               // 42
    "D3DDP2OP_SETTEXLOD",                           // 43
    "D3DDP2OP_SETCLIPPLANE",                        // 44
    "D3DDP2OP_CREATEVERTEXSHADER",                  // 45
    "D3DDP2OP_DELETEVERTEXSHADER",                  // 46
    "D3DDP2OP_SETVERTEXSHADER",                     // 47
    "D3DDP2OP_SETVERTEXSHADERCONST",                // 48
    "D3DDP2OP_SETSTREAMSOURCE",                     // 49
    "D3DDP2OP_SETSTREAMSOURCEUM",                   // 50
    "D3DDP2OP_SETINDICES",                          // 51
    "D3DDP2OP_DRAWPRIMITIVE",                       // 52
    "D3DDP2OP_DRAWINDEXEDPRIMITIVE",                // 53
    "D3DDP2OP_CREATEPIXELSHADER",                   // 54
    "D3DDP2OP_DELETEPIXELSHADER",                   // 55
    "D3DDP2OP_SETPIXELSHADER",                      // 56
    "D3DDP2OP_SETPIXELSHADERCONST",                 // 57
    "D3DDP2OP_CLIPPEDTRIANGLEFAN",                  // 58
    "D3DDP2OP_DRAWPRIMITIVE2",                      // 59
    "D3DDP2OP_DRAWINDEXEDPRIMITIVE2",               // 60
    "D3DDP2OP_DRAWRECTSURFACE",                     // 61
    "D3DDP2OP_DRAWTRISURFACE",                      // 62
    "D3DDP2OP_VOLUMEBLT",                           // 63
    "D3DDP2OP_BUFFERBLT",                           // 64
    "D3DDP2OP_MULTIPLYTRANSFORM"                    // 65
};

#endif  // DEBUG

//-------------------------------------------------------------------------
// DEBUG PRINTING
//---------------------------------------------------------------------------

#ifdef DEBUG

// conditionally print a string out as debug message and/or to a file

void __cdecl dbgDPFAndDump (DWORD flag, LPSTR szFormat, ...)
{
    char str[256];

    nvSprintfVAL (str, szFormat, (va_list)(&szFormat+1));

    if ((flag == NVDBG_SHOW_MANUAL_OVERRIDE) || (dbgShowState & flag)) {
        DPF("%s", str);
    }

    if ((flag == NVDBG_SHOW_MANUAL_OVERRIDE) || (dbgDumpState & flag)) {
        char  *filename;
        HANDLE hFile;
        DWORD  dwJunk;

        // find the appropriate filename
        switch (flag) {
            case NVDBG_SHOW_RENDER_STATE:
                filename = NVDBG_DUMP_RENDER_STATE_FILENAME;
                break;
            case NVDBG_SHOW_DX5_CLASS_STATE:
                filename = NVDBG_DUMP_DX5_CLASS_STATE_FILENAME;
                break;
            case NVDBG_SHOW_SURFACE_STATE:
                filename = NVDBG_DUMP_SURFACE_STATE_FILENAME;
                break;
            case NVDBG_SHOW_VERTICES:
                filename = NVDBG_DUMP_VERTICES_FILENAME;
                break;
            case NVDBG_SHOW_MTS_STATE:
                filename = NVDBG_DUMP_MTS_STATE_FILENAME;
                break;
            case NVDBG_SHOW_DX6_CLASS_STATE:
                filename = NVDBG_DUMP_DX6_CLASS_STATE_FILENAME;
                break;
            case NVDBG_SHOW_DRAWPRIM2_INFO:
                filename = NVDBG_DUMP_DRAWPRIM2_INFO_FILENAME;
                break;
            case NVDBG_SHOW_MANUAL_OVERRIDE:
                filename = NVDBG_DUMP_MANUAL_OVERRIDE_FILENAME;
                break;
            default:
                DPF("dbgDPFAndDump: unknown flag");
                return;
                break;
        }

        // open the file if it exists, create it if not.
        hFile = NvCreateFile(filename,GENERIC_WRITE,0,0,OPEN_ALWAYS,0,0);
        if (hFile == INVALID_HANDLE_VALUE) {
            DPF ("dbgDPFAndDump: File open failed");
            __asm int 3;
        }

        // set the file pointer to the end. this appears to be
        // the only way to append to a file. how retarded.
        SetFilePointer(hFile, 0,0, FILE_END);

        NvWriteFile(hFile,str,nvStrLen(str),&dwJunk,0);
        NvWriteFile(hFile,"\r\n",2,&dwJunk,0);
        FlushFileBuffers(hFile);
        NvCloseHandle(hFile);
    }

}

//-------------------------------------------------------------------------
// STATE DUMPING
//-------------------------------------------------------------------------

void dbgDisplayContextState
(
    DWORD           dwFlags,
    PNVD3DCONTEXT   pContext
)
{
    BOOL  bDPF, bDump;
    DWORD flag;

    if (!(dbgShowState || dbgDumpState)) return;

    bDPF = dbgShowState & NVDBG_SHOW_RENDER_STATE;
    bDump = dbgDumpState & NVDBG_SHOW_RENDER_STATE;
    flag = NVDBG_SHOW_RENDER_STATE;

    if ((bDPF || bDump) &&
        (dwFlags & NVDBG_SHOW_RENDER_STATE)) {
        dbgDPFAndDump(flag, "D3D:Context Render State:");
        dbgDPFAndDump(flag, "    TextureHandle *    = %08x", pContext->dwRenderState[D3DRENDERSTATE_TEXTUREHANDLE]);
        dbgDPFAndDump(flag, "    AntiAlias          = %s",   szD3DBoolean[pContext->dwRenderState[D3DRENDERSTATE_ANTIALIAS]]);
        dbgDPFAndDump(flag, "    TextureAddress *   = %s",   szD3DTextureAddress[pContext->dwRenderState[D3DRENDERSTATE_TEXTUREADDRESS]]);
        dbgDPFAndDump(flag, "    TexturePerspective = %s",   szD3DBoolean[pContext->dwRenderState[D3DRENDERSTATE_TEXTUREPERSPECTIVE]]);
        dbgDPFAndDump(flag, "    WrapU              = %s",   szD3DBoolean[pContext->dwRenderState[D3DRENDERSTATE_WRAPU]]);
        dbgDPFAndDump(flag, "    WrapV              = %s",   szD3DBoolean[pContext->dwRenderState[D3DRENDERSTATE_WRAPV]]);
        dbgDPFAndDump(flag, "    ZEnable            = %s",   szD3DZBufferType[pContext->dwRenderState[D3DRENDERSTATE_ZENABLE]]);
        dbgDPFAndDump(flag, "    FillMode           = %s",   szD3DFillMode[pContext->dwRenderState[D3DRENDERSTATE_FILLMODE]]);
        dbgDPFAndDump(flag, "    ShadeMode          = %s",   szD3DShadeMode[pContext->dwRenderState[D3DRENDERSTATE_SHADEMODE]]);
        dbgDPFAndDump(flag, "    LinePattern        = %08x", pContext->dwRenderState[D3DRENDERSTATE_LINEPATTERN]);
        dbgDPFAndDump(flag, "    MonoEnable         = %08x", pContext->dwRenderState[D3DRENDERSTATE_MONOENABLE]);
        dbgDPFAndDump(flag, "    Rop2               = %08x", pContext->dwRenderState[D3DRENDERSTATE_ROP2]);
        dbgDPFAndDump(flag, "    PlaneMask          = %08x", pContext->dwRenderState[D3DRENDERSTATE_PLANEMASK]);
        dbgDPFAndDump(flag, "    ZWriteEnable       = %s",   szD3DBoolean[pContext->dwRenderState[D3DRENDERSTATE_ZWRITEENABLE]]);
        dbgDPFAndDump(flag, "    AlphaTestEnable    = %s",   szD3DBoolean[pContext->dwRenderState[D3DRENDERSTATE_ALPHATESTENABLE]]);
        dbgDPFAndDump(flag, "    LastPixelEnable    = %s",   szD3DBoolean[pContext->dwRenderState[D3DRENDERSTATE_LASTPIXEL]]);
        dbgDPFAndDump(flag, "    TextureMag         = %s",   szD3DTextureFilter[pContext->dwRenderState[D3DRENDERSTATE_TEXTUREMAG]]);
        dbgDPFAndDump(flag, "    TextureMin         = %s",   szD3DTextureFilter[pContext->dwRenderState[D3DRENDERSTATE_TEXTUREMIN]]);
        dbgDPFAndDump(flag, "    SrcBlend           = %s",   szD3DBlend[pContext->dwRenderState[D3DRENDERSTATE_SRCBLEND]]);
        dbgDPFAndDump(flag, "    DstBlend           = %s",   szD3DBlend[pContext->dwRenderState[D3DRENDERSTATE_DESTBLEND]]);
        dbgDPFAndDump(flag, "    TextureMapBlend    = %s",   szD3DTextureBlend[pContext->dwRenderState[D3DRENDERSTATE_TEXTUREMAPBLEND]]);
        dbgDPFAndDump(flag, "    CullMode           = %s",   szD3DCull[pContext->dwRenderState[D3DRENDERSTATE_CULLMODE]]);
        dbgDPFAndDump(flag, "    ZFunc              = %s",   szD3DCmpFunc[pContext->dwRenderState[D3DRENDERSTATE_ZFUNC]]);
        dbgDPFAndDump(flag, "    AlphaRef           = %08x", pContext->dwRenderState[D3DRENDERSTATE_ALPHAREF]);
        dbgDPFAndDump(flag, "    AlphaFunc          = %s",   szD3DCmpFunc[pContext->dwRenderState[D3DRENDERSTATE_ALPHAFUNC]]);
        dbgDPFAndDump(flag, "    DitherEnable       = %s",   szD3DBoolean[pContext->dwRenderState[D3DRENDERSTATE_DITHERENABLE]]);
        dbgDPFAndDump(flag, "    AlphaBlendEnable   = %s",   szD3DBoolean[pContext->dwRenderState[D3DRENDERSTATE_ALPHABLENDENABLE]]);
        dbgDPFAndDump(flag, "    FogEnable          = %s",   szD3DBoolean[pContext->dwRenderState[D3DRENDERSTATE_FOGENABLE]]);
        dbgDPFAndDump(flag, "    SpecularEnable     = %s",   szD3DBoolean[pContext->dwRenderState[D3DRENDERSTATE_SPECULARENABLE]]);
        dbgDPFAndDump(flag, "    ZVisible           = %08x", pContext->dwRenderState[D3DRENDERSTATE_ZVISIBLE]);
        dbgDPFAndDump(flag, "    SubPixel           = %08x", pContext->dwRenderState[D3DRENDERSTATE_SUBPIXEL]);
        dbgDPFAndDump(flag, "    SubPixelX          = %08x", pContext->dwRenderState[D3DRENDERSTATE_SUBPIXELX]);
        dbgDPFAndDump(flag, "    StippledAlpha      = %08x", pContext->dwRenderState[D3DRENDERSTATE_STIPPLEDALPHA]);
        dbgDPFAndDump(flag, "    FogColor           = %08x", pContext->dwRenderState[D3DRENDERSTATE_FOGCOLOR]);
        dbgDPFAndDump(flag, "    FogTableMode       = %s",   szD3DFogMode[pContext->dwRenderState[D3DRENDERSTATE_FOGTABLEMODE]]);
        dbgDPFAndDump(flag, "    FogTableStart      = %f",   pContext->dwRenderState[D3DRENDERSTATE_FOGTABLESTART]);
        dbgDPFAndDump(flag, "    FogTableEnd        = %f",   pContext->dwRenderState[D3DRENDERSTATE_FOGTABLEEND]);
        dbgDPFAndDump(flag, "    FogTableDensity    = %f",   pContext->dwRenderState[D3DRENDERSTATE_FOGTABLEDENSITY]);
        dbgDPFAndDump(flag, "    StippledEnable     = %s",   szD3DBoolean[pContext->dwRenderState[D3DRENDERSTATE_STIPPLEENABLE]]);
        dbgDPFAndDump(flag, "    EdgeAntiAlias      = %s",   szD3DBoolean[pContext->dwRenderState[D3DRENDERSTATE_EDGEANTIALIAS]]);
        dbgDPFAndDump(flag, "    ColorKeyEnable     = %s",   szD3DBoolean[pContext->dwRenderState[D3DRENDERSTATE_COLORKEYENABLE]]);
        dbgDPFAndDump(flag, "    BorderColor        = %08x", pContext->dwRenderState[D3DRENDERSTATE_BORDERCOLOR]);
        dbgDPFAndDump(flag, "    TextureAddressU *  = %s",   szD3DTextureAddress[pContext->dwRenderState[D3DRENDERSTATE_TEXTUREADDRESSU]]);
        dbgDPFAndDump(flag, "    TextureAddressV *  = %s",   szD3DTextureAddress[pContext->dwRenderState[D3DRENDERSTATE_TEXTUREADDRESSV]]);
        dbgDPFAndDump(flag, "    MipMapLODBias *    = %08x", pContext->dwRenderState[D3DRENDERSTATE_MIPMAPLODBIAS]);
        dbgDPFAndDump(flag, "    ZBias              = %08x", pContext->dwRenderState[D3DRENDERSTATE_ZBIAS]);
        dbgDPFAndDump(flag, "    RangeFogEnable     = %s",   szD3DBoolean[pContext->dwRenderState[D3DRENDERSTATE_RANGEFOGENABLE]]);
        dbgDPFAndDump(flag, "    Anisotropy *       = %08x", pContext->dwRenderState[D3DRENDERSTATE_ANISOTROPY]);
        dbgDPFAndDump(flag, "    FlushBatch         = %08x", pContext->dwRenderState[D3DRENDERSTATE_FLUSHBATCH]);
        dbgDPFAndDump(flag, "    TranslucentSortInd = %08x", pContext->dwRenderState[D3DRENDERSTATE_TRANSLUCENTSORTINDEPENDENT]);
        dbgDPFAndDump(flag, "    StencilEnable      = %s",   szD3DBoolean[pContext->dwRenderState[D3DRENDERSTATE_STENCILENABLE]]);
        dbgDPFAndDump(flag, "    StencilFail        = %s",   szD3DStencilOp[pContext->dwRenderState[D3DRENDERSTATE_STENCILFAIL]]);
        dbgDPFAndDump(flag, "    StencilZFail       = %s",   szD3DStencilOp[pContext->dwRenderState[D3DRENDERSTATE_STENCILZFAIL]]);
        dbgDPFAndDump(flag, "    StencilPass        = %s",   szD3DStencilOp[pContext->dwRenderState[D3DRENDERSTATE_STENCILPASS]]);
        dbgDPFAndDump(flag, "    StencilFunc        = %s",   szD3DCmpFunc[pContext->dwRenderState[D3DRENDERSTATE_STENCILFUNC]]);
        dbgDPFAndDump(flag, "    StencilRef         = %08x", pContext->dwRenderState[D3DRENDERSTATE_STENCILREF]);
        dbgDPFAndDump(flag, "    StencilMask        = %08x", pContext->dwRenderState[D3DRENDERSTATE_STENCILMASK]);
        dbgDPFAndDump(flag, "    StencilWriteMask   = %08x", pContext->dwRenderState[D3DRENDERSTATE_STENCILWRITEMASK]);
        dbgDPFAndDump(flag, "    TextureFactor      = %08x", pContext->dwRenderState[D3DRENDERSTATE_TEXTUREFACTOR]);
        dbgDPFAndDump(flag, "    Wrap0              = %08x", pContext->dwRenderState[D3DRENDERSTATE_WRAP0]);
        dbgDPFAndDump(flag, "    Wrap1              = %08x", pContext->dwRenderState[D3DRENDERSTATE_WRAP1]);
        dbgDPFAndDump(flag, "    Wrap2              = %08x", pContext->dwRenderState[D3DRENDERSTATE_WRAP2]);
        dbgDPFAndDump(flag, "    Wrap3              = %08x", pContext->dwRenderState[D3DRENDERSTATE_WRAP3]);
        dbgDPFAndDump(flag, "    Wrap4              = %08x", pContext->dwRenderState[D3DRENDERSTATE_WRAP4]);
        dbgDPFAndDump(flag, "    Wrap5              = %08x", pContext->dwRenderState[D3DRENDERSTATE_WRAP5]);
        dbgDPFAndDump(flag, "    Wrap6              = %08x", pContext->dwRenderState[D3DRENDERSTATE_WRAP6]);
        dbgDPFAndDump(flag, "    Wrap7              = %08x", pContext->dwRenderState[D3DRENDERSTATE_WRAP7]);
        dbgDPFAndDump(flag, "");
        dbgDPFAndDump(flag, "* These fields may contain invalid junk. They have been superceded");
        dbgDPFAndDump(flag, "  by equivalent fields in tssState[0] and should never be referenced.");
        dbgDPFAndDump(flag, "");
    }

    bDPF = dbgShowState & NVDBG_SHOW_MTS_STATE;
    bDump = dbgDumpState & NVDBG_SHOW_MTS_STATE;
    flag = NVDBG_SHOW_MTS_STATE;

    if ((bDPF || bDump) &&
        (dwFlags & NVDBG_SHOW_MTS_STATE)) {
        DWORD dwStage, dwNumStages;

        dwNumStages = (dbgShowState & NVDBG_SHOW_MTS_STATE) >> NVDBG_SHOW_MTS_STATE_SHIFT;
        dwNumStages = (dwNumStages <= NVDBG_SHOW_MTS_STATE_MAX) ? dwNumStages : NVDBG_SHOW_MTS_STATE_MAX;

        for (dwStage = 0; dwStage < dwNumStages; dwStage++) {
            dbgDPFAndDump(flag, "D3D:Texture Stage %d State:", dwStage);
            dbgDPFAndDump(flag, "    TextureMap     = %08x", pContext->tssState[dwStage].dwValue[D3DTSS_TEXTUREMAP]);
            dbgDPFAndDump(flag, "    AddressU       = %s",   szD3DTextureAddress[pContext->tssState[dwStage].dwValue[D3DTSS_ADDRESSU]]);
            dbgDPFAndDump(flag, "    AddressV       = %s",   szD3DTextureAddress[pContext->tssState[dwStage].dwValue[D3DTSS_ADDRESSV]]);
            dbgDPFAndDump(flag, "    MagFilter      = %s",   szD3DTextureMagFilter[pContext->tssState[dwStage].dwValue[D3DTSS_MAGFILTER]]);
            dbgDPFAndDump(flag, "    MinFilter      = %s",   szD3DTextureMinFilter[pContext->tssState[dwStage].dwValue[D3DTSS_MINFILTER]]);
            dbgDPFAndDump(flag, "    MipFilter      = %s",   szD3DTextureMipFilter[pContext->tssState[dwStage].dwValue[D3DTSS_MIPFILTER]]);
            dbgDPFAndDump(flag, "    ColorOp        = %s",   szD3DTextureOp[pContext->tssState[dwStage].dwValue[D3DTSS_COLOROP]]);
            dbgDPFAndDump(flag, "    ColorArg1      = %s",   szD3DArg[pContext->tssState[dwStage].dwValue[D3DTSS_COLORARG1]]);
            dbgDPFAndDump(flag, "    ColorArg2      = %s",   szD3DArg[pContext->tssState[dwStage].dwValue[D3DTSS_COLORARG2]]);
            dbgDPFAndDump(flag, "    AlphaOp        = %s",   szD3DTextureOp[pContext->tssState[dwStage].dwValue[D3DTSS_ALPHAOP]]);
            dbgDPFAndDump(flag, "    AlphaArg1      = %s",   szD3DArg[pContext->tssState[dwStage].dwValue[D3DTSS_ALPHAARG1]]);
            dbgDPFAndDump(flag, "    AlphaArg2      = %s",   szD3DArg[pContext->tssState[dwStage].dwValue[D3DTSS_ALPHAARG2]]);
            dbgDPFAndDump(flag, "    BumpEnvMat00   = %08x", pContext->tssState[dwStage].dwValue[D3DTSS_BUMPENVMAT00]);
            dbgDPFAndDump(flag, "    BumpEnvMat01   = %08x", pContext->tssState[dwStage].dwValue[D3DTSS_BUMPENVMAT01]);
            dbgDPFAndDump(flag, "    BumpEnvMat10   = %08x", pContext->tssState[dwStage].dwValue[D3DTSS_BUMPENVMAT10]);
            dbgDPFAndDump(flag, "    BumpEnvMat11   = %08x", pContext->tssState[dwStage].dwValue[D3DTSS_BUMPENVMAT11]);
            dbgDPFAndDump(flag, "    TexCoordIndex  = %08x", pContext->tssState[dwStage].dwValue[D3DTSS_TEXCOORDINDEX]);
            dbgDPFAndDump(flag, "    BorderColor    = %08x", pContext->tssState[dwStage].dwValue[D3DTSS_BORDERCOLOR]);
            dbgDPFAndDump(flag, "    MipMapLODBias  = %08x", pContext->tssState[dwStage].dwValue[D3DTSS_MIPMAPLODBIAS]);
            dbgDPFAndDump(flag, "    MaxMipMapLevel = %08x", pContext->tssState[dwStage].dwValue[D3DTSS_MAXMIPLEVEL]);
            dbgDPFAndDump(flag, "    MaxAnisotropy  = %08x", pContext->tssState[dwStage].dwValue[D3DTSS_MAXANISOTROPY]);
            dbgDPFAndDump(flag, "    BumpEnvlScale  = %08x", pContext->tssState[dwStage].dwValue[D3DTSS_BUMPENVLSCALE]);
            dbgDPFAndDump(flag, "    BumpEnvlOffset = %08x", pContext->tssState[dwStage].dwValue[D3DTSS_BUMPENVLOFFSET]);
            dbgDPFAndDump(flag, "");
        }
    }

    bDPF = dbgShowState & NVDBG_SHOW_DX5_CLASS_STATE;
    bDump = dbgDumpState & NVDBG_SHOW_DX5_CLASS_STATE;
    flag = NVDBG_SHOW_DX5_CLASS_STATE;

    if ((bDPF || bDump) &&
        (dwFlags & NVDBG_SHOW_DX5_CLASS_STATE)) {
        dbgDPFAndDump(flag, "D3D:NV4 DX5 Class Context State:");
        dbgDPFAndDump(flag, "    ColorKey           = %08x", pContext->ctxInnerLoop.dwColorKey);
        dbgDPFAndDump(flag, "    TextureOffset      = %08x", pContext->ctxInnerLoop.dwTextureOffset);
        dbgDPFAndDump(flag, "    Format             = %08x", pContext->ctxInnerLoop.dwFormat);
        dbgDPFAndDump(flag, "    Filter             = %08x", pContext->ctxInnerLoop.dwFilter);
        dbgDPFAndDump(flag, "    Blend              = %08x", pContext->ctxInnerLoop.dwBlend);
        dbgDPFAndDump(flag, "    Control            = %08x", pContext->ctxInnerLoop.dwControl);
        dbgDPFAndDump(flag, "    FogColor           = %08x", pContext->ctxInnerLoop.dwFogColor);
        dbgDPFAndDump(flag, "");
    }

    bDPF = dbgShowState & NVDBG_SHOW_DX6_CLASS_STATE;
    bDump = dbgDumpState & NVDBG_SHOW_DX6_CLASS_STATE;
    flag = NVDBG_SHOW_DX6_CLASS_STATE;

    if ((bDPF || bDump) &&
        (dwFlags & NVDBG_SHOW_DX6_CLASS_STATE)) {
        dbgDPFAndDump(flag, "D3D:NV4 DX6 Class Context State:");
        dbgDPFAndDump(flag, "    TextureOffset[0]   = %08x", pContext->mtsState.dwTextureOffset[0]);
        dbgDPFAndDump(flag, "    TextureOffset[1]   = %08x", pContext->mtsState.dwTextureOffset[1]);
        dbgDPFAndDump(flag, "    TextureFormat[0]   = %08x", pContext->mtsState.dwTextureFormat[0]);
        dbgDPFAndDump(flag, "    TextureFormat[1]   = %08x", pContext->mtsState.dwTextureFormat[1]);
        dbgDPFAndDump(flag, "    TextureFilter[0]   = %08x", pContext->mtsState.dwTextureFilter[0]);
        dbgDPFAndDump(flag, "    TextureFilter[1]   = %08x", pContext->mtsState.dwTextureFilter[1]);
        dbgDPFAndDump(flag, "    Combine0Alpha      = %08x", pContext->mtsState.dwCombine0Alpha);
        dbgDPFAndDump(flag, "    Combine0Color      = %08x", pContext->mtsState.dwCombine0Color);
        dbgDPFAndDump(flag, "    Combine1Alpha      = %08x", pContext->mtsState.dwCombine1Alpha);
        dbgDPFAndDump(flag, "    Combine1Color      = %08x", pContext->mtsState.dwCombine1Color);
        dbgDPFAndDump(flag, "    CombineFactor      = %08x", pContext->mtsState.dwCombineFactor);
        dbgDPFAndDump(flag, "    Blend              = %08x", pContext->mtsState.dwBlend);
        dbgDPFAndDump(flag, "    Control0           = %08x", pContext->mtsState.dwControl0);
        dbgDPFAndDump(flag, "    Control1           = %08x", pContext->mtsState.dwControl1);
        dbgDPFAndDump(flag, "    Control2           = %08x", pContext->mtsState.dwControl2);
        dbgDPFAndDump(flag, "    FogColor           = %08x", pContext->mtsState.dwFogColor);
        dbgDPFAndDump(flag, "");
    }

    bDPF = dbgShowState & NVDBG_SHOW_SURFACE_STATE;
    bDump = dbgDumpState & NVDBG_SHOW_SURFACE_STATE;
    flag = NVDBG_SHOW_SURFACE_STATE;

    if ((bDPF || bDump) &&
        (dwFlags & NVDBG_SHOW_SURFACE_STATE)) {
        dbgDPFAndDump(flag, "D3D:NV4 Surface State:");
        dbgDPFAndDump(flag, "    ClipStart (x, y)   = %04d, %04d", pContext->surfaceViewport.clipHorizontal.wX, pContext->surfaceViewport.clipVertical.wY);
        dbgDPFAndDump(flag, "    ClipSize (w, h)    = %04d, %04d", pContext->surfaceViewport.clipHorizontal.wWidth, pContext->surfaceViewport.clipVertical.wHeight);
        dbgDPFAndDump(flag, "    SurfaceAddr        = %08x",       pContext->pRenderTarget->getAddress());
        dbgDPFAndDump(flag, "    SurfaceOffset      = %08x",       pContext->pRenderTarget->getOffset());
        dbgDPFAndDump(flag, "    SurfacePitch       = %04x",       pContext->pRenderTarget->getPitch());
        dbgDPFAndDump(flag, "    SurfaceFormat      = %08x",       pContext->pRenderTarget->getFormat());
        dbgDPFAndDump(flag, "    SurfaceBPP         = %08x",       pContext->pRenderTarget->getBPP());
        dbgDPFAndDump(flag, "    Z-BufferAddr       = %08x",       pContext->pZetaBuffer->getAddress());
        dbgDPFAndDump(flag, "    Z-BufferOffset     = %08x",       pContext->pZetaBuffer->getOffset());
        dbgDPFAndDump(flag, "    Z-BufferPitch      = %04x",       pContext->pZetaBuffer->getPitch());
        dbgDPFAndDump(flag, "");
    }

    return;
}

//-------------------------------------------------------------------------

void dbgShowRenderStateChange (BOOL bChanged, DWORD dwStateType, DWORD dwStateValue)
{
    if (dbgShowState & NVDBG_SHOW_RENDER_STATE) {
        if (bChanged) {
            DPF("nvSetContextState: Render State changed");
        }
        else {
            DPF("nvSetContextState: Render State unchanged");
        }
        DPF("  State = %s (%08d)", szD3DRenderStateLookupTable[dwStateType], dwStateType);
        DPF("  Data  = 0x%08x",    dwStateValue);
    }
}

//-------------------------------------------------------------------------

void dbgDisplayDrawPrimitives2Info (BYTE bCommand, WORD wCommandCount)
{
    BOOL  bDPF, bDump;
    DWORD flag;

    bDPF  = dbgShowState & NVDBG_SHOW_DRAWPRIM2_INFO;
    bDump = dbgDumpState & NVDBG_SHOW_DRAWPRIM2_INFO;
    flag  = NVDBG_SHOW_DRAWPRIM2_INFO;

    if (!(bDPF || bDump)) return;

    if (bCommand <= D3D_DP2OP_MAX) {
        dbgDPFAndDump(flag, "%s (%d) : %08x", szD3DDP2OpLookupTable[bCommand], (DWORD)bCommand, (DWORD)wCommandCount);
    }
    else {
        dbgDPFAndDump(flag, "%s (%d) : %08x", "D3DDP2OP_UNKNOWN", (DWORD)bCommand, (DWORD)wCommandCount);
    }
}

//-------------------------------------------------------------------------

void dbgDisplayVertexData
(
    BOOL    dx6,      // dx6 ? two sets of texture coordinates : one set
    DWORD   *pVertex  // array of vertex components (e.g. D3DTLVERTEX)
)
{
    static DWORD dbgVertexCount = 0;
    BOOL   bDPF, bDump;
    DWORD  flag;

    static float xmin   =  100000.0;
    static float ymin   =  100000.0;
    static float zmin   =  100000.0;
    static float rhwmin =  100000.0;
    static float xmax   = -100000.0;
    static float ymax   = -100000.0;
    static float zmax   = -100000.0;
    static float rhwmax = -100000.0;

    bDPF  = dbgShowState & NVDBG_SHOW_VERTICES;
    bDump = dbgDumpState & NVDBG_SHOW_VERTICES;
    flag  = NVDBG_SHOW_VERTICES;

    dbgVertexCount++;

    if (bDPF || bDump) {
        dbgDPFAndDump(flag, "D3D:NV4 Vertex Data (#%d):", dbgVertexCount);
        dbgDPFAndDump(flag, "    X        = %f",    FLOAT_FROM_DWORD(pVertex[0]));
        dbgDPFAndDump(flag, "    Y        = %f",    FLOAT_FROM_DWORD(pVertex[1]));
        dbgDPFAndDump(flag, "    Z        = %f",    FLOAT_FROM_DWORD(pVertex[2]));
        dbgDPFAndDump(flag, "    RHW      = %f",    FLOAT_FROM_DWORD(pVertex[3]));
        dbgDPFAndDump(flag, "    Diffuse  = %08x",  pVertex[4]);
        dbgDPFAndDump(flag, "    Specular = %08x",  pVertex[5]);
        dbgDPFAndDump(flag, "    U        = %f",    FLOAT_FROM_DWORD(pVertex[6]));
        dbgDPFAndDump(flag, "    V        = %f",    FLOAT_FROM_DWORD(pVertex[7]));

        if (dx6) {
            dbgDPFAndDump(flag, "    U2       = %f", FLOAT_FROM_DWORD(pVertex[8]));
            dbgDPFAndDump(flag, "    V2       = %f", FLOAT_FROM_DWORD(pVertex[9]));
        }

        dbgDPFAndDump(flag, "");
    }

    bDPF  = dbgShowState & NVDBG_SHOW_VERTEX_MAX_MIN;;
    bDump = dbgDumpState & NVDBG_SHOW_VERTEX_MAX_MIN;;
    flag  = NVDBG_SHOW_VERTEX_MAX_MIN;

    if (bDPF || bDump) {

        float f;
        f = FLOAT_FROM_DWORD(pVertex[0]);
        if (f > xmax) xmax = f;
        if (f < xmin) xmin = f;
        f = FLOAT_FROM_DWORD(pVertex[1]);
        if (f > ymax) ymax = f;
        if (f < ymin) ymin = f;
        f = FLOAT_FROM_DWORD(pVertex[2]);
        if (f > zmax) zmax = f;
        if (f < zmin) zmin = f;
        f = FLOAT_FROM_DWORD(pVertex[3]);
        if (f > rhwmax) rhwmax = f;
        if (f < rhwmin) rhwmin = f;

        dbgDPFAndDump(flag,"Minimum / Maximum Values");
        dbgDPFAndDump(flag,"  X   => %f / %f", xmin,xmax);
        dbgDPFAndDump(flag,"  Y   => %f / %f", ymin,ymax);
        dbgDPFAndDump(flag,"  Z   => %f / %f", zmin,zmax);
        dbgDPFAndDump(flag,"  RHW => %f / %f", rhwmin,rhwmax);
        dbgDPFAndDump(flag,"\r\n");

    } else {

        // if NVDBG_SHOW_VERTEX_MAX_MIN is off, then reset values
        xmin   =  100000.0;
        ymin   =  100000.0;
        zmin   =  100000.0;
        rhwmin =  100000.0;
        xmax   = -100000.0;
        ymax   = -100000.0;
        zmax   = -100000.0;
        rhwmax = -100000.0;

    }

}

//-------------------------------------------------------------------------

void dbgDisplayLight
(
    LPD3DLIGHT7 pLight7
)
{
    if (dbgShowState & NVDBG_SHOW_LIGHTS)
    {
        static DWORD dwCount = 0;
        dwCount++;

        //if ((dwCount == 1) || (dwCount == 30))
        {
            DPF ("D3DLIGHT7 (call #%d):-  (note: large floats will not be printed correctly)",dwCount);
            switch (pLight7->dltType)
            {
                case D3DLIGHT_SPOT:         DPF ("    type: SPOT");
                                            break;
                case D3DLIGHT_POINT:        DPF ("    type: POINT");
                                            break;
                case D3DLIGHT_DIRECTIONAL:  DPF ("    type: DIRECTIONAL");
                                            break;
            }
            DPF (" diffuse: ARGB = %02x %02x %02x %02x",
                      int(255.0 * pLight7->dcvDiffuse.a),
                      int(255.0 * pLight7->dcvDiffuse.r),
                      int(255.0 * pLight7->dcvDiffuse.g),
                      int(255.0 * pLight7->dcvDiffuse.b));
            DPF ("specular: ARGB = %02x %02x %02x %02x",
                      int(255.0 * pLight7->dcvSpecular.a),
                      int(255.0 * pLight7->dcvSpecular.r),
                      int(255.0 * pLight7->dcvSpecular.g),
                      int(255.0 * pLight7->dcvSpecular.b));
            DPF (" ambient: ARGB = %02x %02x %02x %02x",
                      int(255.0 * pLight7->dcvAmbient.a),
                      int(255.0 * pLight7->dcvAmbient.r),
                      int(255.0 * pLight7->dcvAmbient.g),
                      int(255.0 * pLight7->dcvAmbient.b));

            DPF ("position: %d.%04d %d.%04d %d.%04d",
                      int(pLight7->dvPosition.x),ABS(int(pLight7->dvPosition.x * 10000) % 10000),
                      int(pLight7->dvPosition.y),ABS(int(pLight7->dvPosition.y * 10000) % 10000),
                      int(pLight7->dvPosition.z),ABS(int(pLight7->dvPosition.z * 10000) % 10000));

            DPF ("     dir: %d.%04d %d.%04d %d.%04d",
                      int(pLight7->dvDirection.x),ABS(int(pLight7->dvDirection.x * 10000) % 10000),
                      int(pLight7->dvDirection.y),ABS(int(pLight7->dvDirection.y * 10000) % 10000),
                      int(pLight7->dvDirection.z),ABS(int(pLight7->dvDirection.z * 10000) % 10000));

            DPF ("   range: %d.%04d",int(pLight7->dvRange),ABS(int(pLight7->dvRange * 10000) % 10000));
            DPF (" falloff: %d.%04d",int(pLight7->dvFalloff),ABS(int(pLight7->dvFalloff * 10000) % 10000));
            DPF ("    att0: %d.%04d",int(pLight7->dvAttenuation0),ABS(int(pLight7->dvAttenuation0 * 10000) % 10000));
            DPF ("    att1: %d.%04d",int(pLight7->dvAttenuation1),ABS(int(pLight7->dvAttenuation1 * 10000) % 10000));
            DPF ("    att2: %d.%04d",int(pLight7->dvAttenuation2),ABS(int(pLight7->dvAttenuation2 * 10000) % 10000));
            DPF ("   theta: %d.%04d",int(pLight7->dvTheta),ABS(int(pLight7->dvTheta * 10000) % 10000));
            DPF ("     phi: %d.%04d",int(pLight7->dvPhi),ABS(int(pLight7->dvPhi * 10000) % 10000));
        }
    }
}

//-------------------------------------------------------------------------
// STATE VALIDATION
//-------------------------------------------------------------------------

BOOL dbgValidateControlRegisters
(
    PNVD3DCONTEXT   pContext
)
{
    DWORD   drfValue;

    nvAssert (!(pDriverData->nvD3DPerfData.dwNVClasses & NVCLASS_FAMILY_CELSIUS) &&
              !(pDriverData->nvD3DPerfData.dwNVClasses & NVCLASS_FAMILY_KELVIN));

    /*
     * Validate the Format register.
     */
    drfValue = DRF_VAL(054, _FORMAT, _CONTEXT_DMA, pContext->ctxInnerLoop.dwFormat);
    if ((drfValue != NV054_FORMAT_CONTEXT_DMA_A)
        && (drfValue != NV054_FORMAT_CONTEXT_DMA_B)) {
        DPF("dbgValidateControlRegisters: NV054_FORMAT_CONTEXT_DMA field invalid 0x%08x", drfValue);
        dbgD3DError();
    }
    drfValue = DRF_VAL(054, _FORMAT, _COLORKEYENABLE, pContext->ctxInnerLoop.dwFormat);
    if ((drfValue != NV054_FORMAT_COLORKEYENABLE_FALSE)
        && (drfValue != NV054_FORMAT_COLORKEYENABLE_TRUE)) {
        DPF("dbgValidateControlRegisters: NV054_FORMAT_COLORKEYENABLE field invalid 0x%08x", drfValue);
        dbgD3DError();
    }
    drfValue = DRF_VAL(054, _FORMAT, _ORIGIN_ZOH, pContext->ctxInnerLoop.dwFormat);
    if ((drfValue != NV054_FORMAT_ORIGIN_ZOH_CENTER)
        && (drfValue != NV054_FORMAT_ORIGIN_ZOH_CORNER)) {
        DPF("dbgValidateControlRegisters: NV054_FORMAT__ORIGIN_ZOH field invalid 0x%08x", drfValue);
        dbgD3DError();
    }
    drfValue = DRF_VAL(054, _FORMAT, _ORIGIN_FOH, pContext->ctxInnerLoop.dwFormat);
    if ((drfValue != NV054_FORMAT_ORIGIN_FOH_CENTER)
        && (drfValue != NV054_FORMAT_ORIGIN_FOH_CORNER)) {
        DPF("dbgValidateControlRegisters: NV054_FORMAT__ORIGIN_FOH field invalid 0x%08x", drfValue);
        dbgD3DError();
    }
    drfValue = DRF_VAL(054, _FORMAT, _COLOR, pContext->ctxInnerLoop.dwFormat);
    if ((drfValue != NV054_FORMAT_COLOR_LE_Y8)
        && (drfValue != NV054_FORMAT_COLOR_LE_A1R5G5B5)
        && (drfValue != NV054_FORMAT_COLOR_LE_X1R5G5B5)
        && (drfValue != NV054_FORMAT_COLOR_LE_A4R4G4B4)
        && (drfValue != NV054_FORMAT_COLOR_LE_R5G6B5)
        && (drfValue != NV054_FORMAT_COLOR_LE_A8R8G8B8)
        && (drfValue != NV054_FORMAT_COLOR_LE_X8R8G8B8)) {
        DPF("dbgValidateControlRegisters: NV054_FORMAT_COLOR field invalid 0x%08x", drfValue);
        dbgD3DError();
    }
//    drfValue = DRF_VAL(054, _FORMAT, _MIPMAP_LEVELS, pContext->ctxInnerLoop.dwFormat);
//    if (drfValue )
//    {
//        DPF("dbgValidateControlRegisters: NV054_FORMAT_MIPMAP_LEVELS field invalid 0x%08x", drfValue);
//        dbgD3DError();
//    }
    drfValue = DRF_VAL(054, _FORMAT, _BASE_SIZE_U, pContext->ctxInnerLoop.dwFormat);
    if ((drfValue != NV054_FORMAT_BASE_SIZE_U_1)
        && (drfValue != NV054_FORMAT_BASE_SIZE_U_2)
        && (drfValue != NV054_FORMAT_BASE_SIZE_U_4)
        && (drfValue != NV054_FORMAT_BASE_SIZE_U_8)
        && (drfValue != NV054_FORMAT_BASE_SIZE_U_16)
        && (drfValue != NV054_FORMAT_BASE_SIZE_U_32)
        && (drfValue != NV054_FORMAT_BASE_SIZE_U_64)
        && (drfValue != NV054_FORMAT_BASE_SIZE_U_128)
        && (drfValue != NV054_FORMAT_BASE_SIZE_U_256)
        && (drfValue != NV054_FORMAT_BASE_SIZE_U_512)
        && (drfValue != NV054_FORMAT_BASE_SIZE_U_1024)
        && (drfValue != NV054_FORMAT_BASE_SIZE_U_2048)) {
        DPF("dbgValidateControlRegisters: NV054_FORMAT_BASE_SIZE_U field invalid 0x%08x", drfValue);
        dbgD3DError();
    }
    drfValue = DRF_VAL(054, _FORMAT, _BASE_SIZE_V, pContext->ctxInnerLoop.dwFormat);
    if ((drfValue != NV054_FORMAT_BASE_SIZE_V_1)
        && (drfValue != NV054_FORMAT_BASE_SIZE_V_2)
        && (drfValue != NV054_FORMAT_BASE_SIZE_V_4)
        && (drfValue != NV054_FORMAT_BASE_SIZE_V_8)
        && (drfValue != NV054_FORMAT_BASE_SIZE_V_16)
        && (drfValue != NV054_FORMAT_BASE_SIZE_V_32)
        && (drfValue != NV054_FORMAT_BASE_SIZE_V_64)
        && (drfValue != NV054_FORMAT_BASE_SIZE_V_128)
        && (drfValue != NV054_FORMAT_BASE_SIZE_V_256)
        && (drfValue != NV054_FORMAT_BASE_SIZE_V_512)
        && (drfValue != NV054_FORMAT_BASE_SIZE_V_1024)
        && (drfValue != NV054_FORMAT_BASE_SIZE_V_2048)) {
        DPF("dbgValidateControlRegisters: NV054_FORMAT_BASE_SIZE_V field invalid 0x%08x", drfValue);
        dbgD3DError();
    }
    drfValue = DRF_VAL(054, _FORMAT, _TEXTUREADDRESSU, pContext->ctxInnerLoop.dwFormat);
    if ((drfValue != NV054_FORMAT_TEXTUREADDRESSU_WRAP)
        && (drfValue != NV054_FORMAT_TEXTUREADDRESSU_MIRROR)
        && (drfValue != NV054_FORMAT_TEXTUREADDRESSU_CLAMP)
        && (drfValue != NV054_FORMAT_TEXTUREADDRESSU_BORDER)) {
        DPF("dbgValidateControlRegisters: NV054_FORMAT_TEXTUREADDRESSU field invalid 0x%08x", drfValue);
        dbgD3DError();
    }
    drfValue = DRF_VAL(054, _FORMAT, _WRAPU, pContext->ctxInnerLoop.dwFormat);
    if ((drfValue != NV054_FORMAT_WRAPU_FALSE)
        && (drfValue != NV054_FORMAT_WRAPU_TRUE)) {
        DPF("dbgValidateControlRegisters: NV054_FORMAT_WRAPU field invalid 0x%08x", drfValue);
        dbgD3DError();
    }
    drfValue = DRF_VAL(054, _FORMAT, _TEXTUREADDRESSV, pContext->ctxInnerLoop.dwFormat);
    if ((drfValue != NV054_FORMAT_TEXTUREADDRESSV_WRAP)
        && (drfValue != NV054_FORMAT_TEXTUREADDRESSV_MIRROR)
        && (drfValue != NV054_FORMAT_TEXTUREADDRESSV_CLAMP)
        && (drfValue != NV054_FORMAT_TEXTUREADDRESSV_BORDER)) {
        DPF("dbgValidateControlRegisters: NV054_FORMAT_TEXTUREADDRESSV field invalid 0x%08x", drfValue);
        dbgD3DError();
    }
    drfValue = DRF_VAL(054, _FORMAT, _WRAPV, pContext->ctxInnerLoop.dwFormat);
    if ((drfValue != NV054_FORMAT_WRAPV_FALSE)
        && (drfValue != NV054_FORMAT_WRAPV_TRUE)) {
        DPF("dbgValidateControlRegisters: NV054_FORMAT_WRAPV field invalid 0x%08x", drfValue);
        dbgD3DError();
    }

    // Validate the Filter register.
    drfValue = DRF_VAL(054, _FILTER, _MIPMAP_DITHER_ENABLE, pContext->ctxInnerLoop.dwFilter);
    if ((drfValue != NV054_FILTER_MIPMAP_DITHER_ENABLE_FALSE)
        && (drfValue != NV054_FILTER_MIPMAP_DITHER_ENABLE_TRUE)) {
        DPF("dbgValidateControlRegisters: NV054_FILTER_MIPMAP_DITHER_ENABLE field invalid 0x%08x", drfValue);
        dbgD3DError();
    }
    drfValue = DRF_VAL(054, _FILTER, _TEXTUREMIN, pContext->ctxInnerLoop.dwFilter);
    if ((drfValue != NV054_FILTER_TEXTUREMIN_NEAREST)
        && (drfValue != NV054_FILTER_TEXTUREMIN_LINEAR)
        && (drfValue != NV054_FILTER_TEXTUREMIN_MIPNEAREST)
        && (drfValue != NV054_FILTER_TEXTUREMIN_MIPLINEAR)
        && (drfValue != NV054_FILTER_TEXTUREMIN_LINEARMIPNEAREST)
        && (drfValue != NV054_FILTER_TEXTUREMIN_LINEARMIPLINEAR)) {
        DPF("dbgValidateControlRegisters: NV054_FILTER_TEXTUREMIN field invalid 0x%08x", drfValue);
        dbgD3DError();
    }
    drfValue = DRF_VAL(054, _FILTER, _ANISOTROPIC_MINIFY_ENABLE, pContext->ctxInnerLoop.dwFilter);
    if ((drfValue != NV054_FILTER_ANISOTROPIC_MINIFY_ENABLE_FALSE)
        && (drfValue != NV054_FILTER_ANISOTROPIC_MINIFY_ENABLE_TRUE)) {
        DPF("dbgValidateControlRegisters: NV054_FILTER_ANISOTROPIC_MINIFY_ENABLE field invalid 0x%08x", drfValue);
        dbgD3DError();
    }
    drfValue = DRF_VAL(054, _FILTER, _TEXTUREMAG, pContext->ctxInnerLoop.dwFilter);
    if ((drfValue != NV054_FILTER_TEXTUREMAG_NEAREST)
        && (drfValue != NV054_FILTER_TEXTUREMAG_LINEAR)
        && (drfValue != NV054_FILTER_TEXTUREMAG_MIPNEAREST)
        && (drfValue != NV054_FILTER_TEXTUREMAG_MIPLINEAR)
        && (drfValue != NV054_FILTER_TEXTUREMAG_LINEARMIPNEAREST)
        && (drfValue != NV054_FILTER_TEXTUREMAG_LINEARMIPLINEAR)) {
        DPF("dbgValidateControlRegisters: NV054_FILTER_TEXTUREMAG field invalid 0x%08x", drfValue);
        dbgD3DError();
    }
    drfValue = DRF_VAL(054, _FILTER, _ANISOTROPIC_MAGNIFY_ENABLE, pContext->ctxInnerLoop.dwFilter);
    if ((drfValue != NV054_FILTER_ANISOTROPIC_MAGNIFY_ENABLE_FALSE)
        && (drfValue != NV054_FILTER_ANISOTROPIC_MAGNIFY_ENABLE_TRUE)) {
        DPF("dbgValidateControlRegisters: NV054_FILTER_ANISOTROPIC_MAGNIFY_ENABLE field invalid 0x%08x", drfValue);
        dbgD3DError();
    }

    // Validate the Blend register.
    drfValue = DRF_VAL(054, _BLEND, _TEXTUREMAPBLEND, pContext->ctxInnerLoop.dwBlend);
    if ((drfValue != NV054_BLEND_TEXTUREMAPBLEND_DECAL)
        && (drfValue != NV054_BLEND_TEXTUREMAPBLEND_MODULATE)
        && (drfValue != NV054_BLEND_TEXTUREMAPBLEND_DECALALPHA)
        && (drfValue != NV054_BLEND_TEXTUREMAPBLEND_MODULATEALPHA)
        && (drfValue != NV054_BLEND_TEXTUREMAPBLEND_DECALMASK)
        && (drfValue != NV054_BLEND_TEXTUREMAPBLEND_MODULATEMASK)
        && (drfValue != NV054_BLEND_TEXTUREMAPBLEND_COPY)
        && (drfValue != NV054_BLEND_TEXTUREMAPBLEND_ADD)) {
        DPF("dbgValidateControlRegisters: NV054_BLEND_TEXTUREMAPBLEND field invalid 0x%08x", drfValue);
        dbgD3DError();
    }
    drfValue = DRF_VAL(054, _BLEND, _MASK_BIT, pContext->ctxInnerLoop.dwBlend);
    if ((drfValue != NV054_BLEND_MASK_BIT_LSB)
        && (drfValue != NV054_BLEND_MASK_BIT_MSB)) {
        DPF("dbgValidateControlRegisters: NV054_BLEND_MASK_BIT field invalid 0x%08x", drfValue);
        dbgD3DError();
    }
    drfValue = DRF_VAL(054, _BLEND, _SHADEMODE, pContext->ctxInnerLoop.dwBlend);
    if ((drfValue != NV054_BLEND_SHADEMODE_FLAT)
        && (drfValue != NV054_BLEND_SHADEMODE_GOURAUD)
        && (drfValue != NV054_BLEND_SHADEMODE_PHONG)) {
        DPF("dbgValidateControlRegisters: NV054_BLEND_SHADEMODE field invalid 0x%08x", drfValue);
        dbgD3DError();
    }
    drfValue = DRF_VAL(054, _BLEND, _TEXTUREPERSPECTIVE, pContext->ctxInnerLoop.dwBlend);
    if ((drfValue != NV054_BLEND_TEXTUREPERSPECTIVE_FALSE)
        && (drfValue != NV054_BLEND_TEXTUREPERSPECTIVE_TRUE)) {
        DPF("dbgValidateControlRegisters: NV054_BLEND_TEXTUREPERSPECTIVE field invalid 0x%08x", drfValue);
        dbgD3DError();
    }
    drfValue = DRF_VAL(054, _BLEND, _SPECULARENABLE, pContext->ctxInnerLoop.dwBlend);
    if ((drfValue != NV054_BLEND_SPECULARENABLE_FALSE)
        && (drfValue != NV054_BLEND_SPECULARENABLE_TRUE)) {
        DPF("dbgValidateControlRegisters: NV054_BLEND_SPECULARENABLE field invalid 0x%08x", drfValue);
        dbgD3DError();
    }
    drfValue = DRF_VAL(054, _BLEND, _FOGENABLE, pContext->ctxInnerLoop.dwBlend);
    if ((drfValue != NV054_BLEND_FOGENABLE_FALSE)
        && (drfValue != NV054_BLEND_FOGENABLE_TRUE)) {
        DPF("dbgValidateControlRegisters: NV054_BLEND_FOGENABLE field invalid 0x%08x", drfValue);
        dbgD3DError();
    }
    drfValue = DRF_VAL(054, _BLEND, _ALPHABLENDENABLE, pContext->ctxInnerLoop.dwBlend);
    if ((drfValue != NV054_BLEND_ALPHABLENDENABLE_FALSE)
        && (drfValue != NV054_BLEND_ALPHABLENDENABLE_TRUE)) {
        DPF("dbgValidateControlRegisters: NV054_BLEND_ALPHABLENDENABLE field invalid 0x%08x", drfValue);
        dbgD3DError();
    }
    drfValue = DRF_VAL(054, _BLEND, _SRCBLEND, pContext->ctxInnerLoop.dwBlend);
    if ((drfValue != NV054_BLEND_SRCBLEND_ZERO)
        && (drfValue != NV054_BLEND_SRCBLEND_ONE)
        && (drfValue != NV054_BLEND_SRCBLEND_SRCCOLOR)
        && (drfValue != NV054_BLEND_SRCBLEND_INVSRCCOLOR)
        && (drfValue != NV054_BLEND_SRCBLEND_SRCALPHA)
        && (drfValue != NV054_BLEND_SRCBLEND_INVSRCALPHA)
        && (drfValue != NV054_BLEND_SRCBLEND_DESTALPHA)
        && (drfValue != NV054_BLEND_SRCBLEND_INVDESTALPHA)
        && (drfValue != NV054_BLEND_SRCBLEND_DESTCOLOR)
        && (drfValue != NV054_BLEND_SRCBLEND_INVDESTCOLOR)
        && (drfValue != NV054_BLEND_SRCBLEND_SRCALPHASAT)) {
        DPF("dbgValidateControlRegisters: NV054_BLEND_SRCBLEND field invalid 0x%08x", drfValue);
        dbgD3DError();
    }
    drfValue = DRF_VAL(054, _BLEND, _DESTBLEND, pContext->ctxInnerLoop.dwBlend);
    if ((drfValue != NV054_BLEND_DESTBLEND_ZERO)
        && (drfValue != NV054_BLEND_DESTBLEND_ONE)
        && (drfValue != NV054_BLEND_DESTBLEND_SRCCOLOR)
        && (drfValue != NV054_BLEND_DESTBLEND_INVSRCCOLOR)
        && (drfValue != NV054_BLEND_DESTBLEND_SRCALPHA)
        && (drfValue != NV054_BLEND_DESTBLEND_INVSRCALPHA)
        && (drfValue != NV054_BLEND_DESTBLEND_DESTALPHA)
        && (drfValue != NV054_BLEND_DESTBLEND_INVDESTALPHA)
        && (drfValue != NV054_BLEND_DESTBLEND_DESTCOLOR)
        && (drfValue != NV054_BLEND_DESTBLEND_INVDESTCOLOR)
        && (drfValue != NV054_BLEND_DESTBLEND_SRCALPHASAT)) {
        DPF("dbgValidateControlRegisters: NV054_BLEND_DESTBLEND field invalid 0x%08x", drfValue);
        dbgD3DError();
    }

    // Validate the Control register.
    drfValue = DRF_VAL(054, _CONTROL, _ALPHAFUNC, pContext->ctxInnerLoop.dwControl);
    if ((drfValue != NV054_CONTROL_ALPHAFUNC_NEVER)
        && (drfValue != NV054_CONTROL_ALPHAFUNC_LESS)
        && (drfValue != NV054_CONTROL_ALPHAFUNC_EQUAL)
        && (drfValue != NV054_CONTROL_ALPHAFUNC_LESSEQUAL)
        && (drfValue != NV054_CONTROL_ALPHAFUNC_GREATER)
        && (drfValue != NV054_CONTROL_ALPHAFUNC_NOTEQUAL)
        && (drfValue != NV054_CONTROL_ALPHAFUNC_GREATEREQUAL)
        && (drfValue != NV054_CONTROL_ALPHAFUNC_ALWAYS)) {
        DPF("dbgValidateControlRegisters: NV054_CONTROL_ALPHAFUNC field invalid 0x%08x", drfValue);
        dbgD3DError();
    }
    drfValue = DRF_VAL(054, _CONTROL, _ALPHATESTENABLE, pContext->ctxInnerLoop.dwControl);
    if ((drfValue != NV054_CONTROL_ALPHATESTENABLE_FALSE)
        && (drfValue != NV054_CONTROL_ALPHATESTENABLE_TRUE)) {
        DPF("dbgValidateControlRegisters: NV054_CONTROL_ALPHATESTENABLE field invalid 0x%08x", drfValue);
        dbgD3DError();
    }
    drfValue = DRF_VAL(054, _CONTROL, _ZENABLE, pContext->ctxInnerLoop.dwControl);
    if ((drfValue != NV054_CONTROL_ZENABLE_FALSE)
        && (drfValue != NV054_CONTROL_ZENABLE_TRUE)) {
        DPF("dbgValidateControlRegisters: NV054_CONTROL_ZENABLE field invalid 0x%08x", drfValue);
        dbgD3DError();
    }
    drfValue = DRF_VAL(054, _CONTROL, _ZFUNC, pContext->ctxInnerLoop.dwControl);
    if ((drfValue != NV054_CONTROL_ZFUNC_NEVER)
        && (drfValue != NV054_CONTROL_ZFUNC_LESS)
        && (drfValue != NV054_CONTROL_ZFUNC_EQUAL)
        && (drfValue != NV054_CONTROL_ZFUNC_LESSEQUAL)
        && (drfValue != NV054_CONTROL_ZFUNC_GREATER)
        && (drfValue != NV054_CONTROL_ZFUNC_NOTEQUAL)
        && (drfValue != NV054_CONTROL_ZFUNC_GREATEREQUAL)
        && (drfValue != NV054_CONTROL_ZFUNC_ALWAYS)) {
        DPF("dbgValidateControlRegisters: NV054_CONTROL_ZFUNC field invalid 0x%08x", drfValue);
        dbgD3DError();
    }
    drfValue = DRF_VAL(054, _CONTROL, _CULLMODE, pContext->ctxInnerLoop.dwControl);
    if ((drfValue != NV054_CONTROL_CULLMODE_NONE)
        && (drfValue != NV054_CONTROL_CULLMODE_CW)
        && (drfValue != NV054_CONTROL_CULLMODE_CCW)) {
        DPF("dbgValidateControlRegisters: NV054_CONTROL_CULLMODE field invalid 0x%08x", drfValue);
        dbgD3DError();
    }
    drfValue = DRF_VAL(054, _CONTROL, _DITHERENABLE, pContext->ctxInnerLoop.dwControl);
    if ((drfValue != NV054_CONTROL_DITHERENABLE_FALSE)
        && (drfValue != NV054_CONTROL_DITHERENABLE_TRUE)) {
        DPF("dbgValidateControlRegisters: NV054_CONTROL_DITHERENABLE field invalid 0x%08x", drfValue);
        dbgD3DError();
    }
    drfValue = DRF_VAL(054, _CONTROL, _Z_PERSPECTIVE_ENABLE, pContext->ctxInnerLoop.dwControl);
    if ((drfValue != NV054_CONTROL_Z_PERSPECTIVE_ENABLE_FALSE)
        && (drfValue != NV054_CONTROL_Z_PERSPECTIVE_ENABLE_TRUE)) {
        DPF("dbgValidateControlRegisters: NV054_CONTROL_Z_PERSPECTIVE_ENABLE field invalid 0x%08x", drfValue);
        dbgD3DError();
    }
    drfValue = DRF_VAL(054, _CONTROL, _ZWRITEENABLE, pContext->ctxInnerLoop.dwControl);
    if ((drfValue != NV054_CONTROL_ZWRITEENABLE_FALSE)
        && (drfValue != NV054_CONTROL_ZWRITEENABLE_TRUE)) {
        DPF("dbgValidateControlRegisters: NV054_CONTROL_ZWRITEENABLE field invalid 0x%08x", drfValue);
        dbgD3DError();
    }
    drfValue = DRF_VAL(054, _CONTROL, _Z_FORMAT, pContext->ctxInnerLoop.dwControl);
    if ((drfValue != NV054_CONTROL_Z_FORMAT_FIXED)
        && (drfValue != NV054_CONTROL_Z_FORMAT_FLOAT)) {
        DPF("dbgValidateControlRegisters: NV054_CONTROL_Z_FORMAT field invalid 0x%08x", drfValue);
        dbgD3DError();
    }
    return(TRUE);
}

#endif // DEBUG

//-------------------------------------------------------------------------
// TEXTURE PREVIEWING
//-------------------------------------------------------------------------

#ifdef DEBUG

// display a particular texture mipmap level at screen position (dwX, dwY)

#define CLEAR_BORDER_SIZE 24

// set one pixel's worth of data from pSrc, subject to dwBPP
#define SETPIXEL1(pPix, pSrc, dwBPP)                \
{                                                   \
    if ((dwBPP) == 2) {                             \
        *(WORD*)(pPix) = *(WORD*)(pSrc);            \
    }                                               \
    else {                                          \
        *(DWORD*)(pPix) = *(DWORD*)(pSrc);          \
    }                                               \
}

// set one pixel's data from BYTES a, r, g, and b, subject to dwBPP
#define SETPIXEL2(pPix, a,r,g,b, dwBPP)             \
{                                                   \
    if ((dwBPP) == 2) {                             \
        *(WORD*)(pPix) = ((((r) & 0xf8) << 8) |     \
                          (((g) & 0xfc) << 3) |     \
                          (((b) & 0xf8) >> 3));     \
    }                                               \
    else {                                          \
        *(DWORD*)(pPix) = (((a) << 24) |            \
                           ((r) << 16) |            \
                           ((g) <<  8) |            \
                           ((b) <<  0));            \
    }                                               \
}

//---------------------------------------------------------------------------

void dbgTextureDisplayLevel
(
    CTexture *pTexture,
    DWORD     dwX,           // horizontal location for output
    DWORD     dwY,           // vertical location for output
    DWORD     dwClearColor
)
{
    DWORD u, v, u0, v0, uu, vv;
    DWORD dwNonZeroAlphaCount = 0;
    DWORD dwTexWidth, dwTexHeight, dwTexPitch;
    DWORD dwTexLogicalWidth, dwTexLogicalHeight;
    DWORD dwXOffset, dwXOffsetMax, dwYMax;
    DWORD dwFBOffset, dwFBIndexShift;
    DWORD dwTexelIndex, dwTexIndexShift;
    DWORD dwColors, dwBits;
    PBYTE pTextureBase, pTexel, pPalette;
    PBYTE pFB, pFB0;
    float a0, r0, g0, b0;
    float a1, r1, g1, b1;
    float da, dr, dg, db;
    WORD  wInterpIndex, wInterp;
    BYTE  a, r, g, b;
    BOOL  bLinear;

    bLinear = (dbgTexturePreview & NVDBG_TEXTURE_PREVIEW_LINEAR) ? TRUE : FALSE;

    dwTexWidth         = pTexture->getWidth();
    dwTexLogicalWidth  = pTexture->getLogicalWidth();
    dwTexHeight        = pTexture->getHeight();
    dwTexLogicalHeight = pTexture->getLogicalHeight();
    dwTexPitch         = pTexture->getPitch();

    // make sure we don't draw outside the primary
    dwXOffset    = dwX * dbgPrimaryBPP;
    dwXOffsetMax = dbgPrimaryPitch  - dbgPrimaryBPP * (dwTexLogicalWidth + CLEAR_BORDER_SIZE);
    dwYMax       = dbgPrimaryHeight - (dwTexLogicalHeight + CLEAR_BORDER_SIZE);

    dwXOffset = min (dwXOffset, dwXOffsetMax);
    dwY       = min (dwY, dwYMax);

    dwFBOffset = dwY*dbgPrimaryPitch + dwXOffset;

    pFB  = (PBYTE) VIDMEM_ADDR(pDriverData->CurrentVisibleSurfaceAddress);
    pFB  = pFB + dwFBOffset;
    pFB0 = pFB;

    pTextureBase = bLinear ?
                   (PBYTE) (pTexture->getLinear()->getAddress()) :
                   (PBYTE) (pTexture->getSwizzled()->getAddress());

    if (!pTextureBase) {
        DPF ("dbgTextureDisplayLevel: couldn't get texture base. aborting preview");
        return;
    }

    dwTexIndexShift = pTexture->getBPP();
    ASM_LOG2 (dwTexIndexShift);

    dwFBIndexShift = dbgPrimaryBPP;
    ASM_LOG2 (dwFBIndexShift);

    // clear the area first

    for (v = 0; v < dwTexLogicalHeight+CLEAR_BORDER_SIZE; v++) {
        for (u = 0; u < dwTexLogicalWidth+CLEAR_BORDER_SIZE; u++) {
            SETPIXEL1 (pFB+(u<<dwFBIndexShift), &dwClearColor, dbgPrimaryBPP);
        }
        pFB += dbgPrimaryPitch;
    }
    pFB = pFB0;

    // render the texture

    if (pTexture->isDXT()) {

        // iterate over the blocks
        for (v=0; v < dwTexHeight; v++) {

            // start pFB in the upper-left corner of this row of 4x4 blocks
            pFB = pFB0 + (dbgPrimaryPitch * (v<<2));

            for (u=0; u < dwTexWidth; u++) {

                dwTexelIndex = dwTexWidth * v + u;
                pTexel = pTextureBase + (dwTexelIndex << dwTexIndexShift);

                switch (pTexture->getFormat()) {

                    case NV_SURFACE_FORMAT_DXT1_A1R5G5B5:
                        // ignore the 1-bit alpha sub-case of DXT1
                        dwColors = ((DWORD*)pTexel)[0];
                        dwBits   = ((DWORD*)pTexel)[1];
                        break;

                    case NV_SURFACE_FORMAT_DXT23_A8R8G8B8:
                    case NV_SURFACE_FORMAT_DXT45_A8R8G8B8:
                        // ignore the alpha component completely for DXT2-5
                        dwColors = ((DWORD*)pTexel)[2];
                        dwBits   = ((DWORD*)pTexel)[3];
                        break;

                    default:
                        DPF ("unhandled texture format in dbgTextureDisplay");
                        dbgD3DError();
                        return;
                        break;

                }  // switch

                a0 = (float) (0);
                r0 = (float) ((dwColors >> 8) & 0xf8);
                g0 = (float) ((dwColors >> 3) & 0xfc);
                b0 = (float) ((dwColors << 3) & 0xf8);

                a1 = (float) (0);
                r1 = (float) ((dwColors >> 24) & 0xf8);
                g1 = (float) ((dwColors >> 19) & 0xfc);
                b1 = (float) ((dwColors >> 13) & 0xf8);

                da = (float) ((a1 - a0) / 3);
                dr = (float) ((r1 - r0) / 3);
                dg = (float) ((g1 - g0) / 3);
                db = (float) ((b1 - b0) / 3);

                for (vv=0; vv<4; vv++) {
                    for (uu=0; uu<4; uu++) {
                        wInterpIndex = (WORD)(dwBits & 0x3);
                        wInterp = (wInterpIndex == 0x0) ? 0 :
                                  (wInterpIndex == 0x1) ? 3 :
                                  (wInterpIndex == 0x2) ? 1 : 2;
                        dwBits >>= 2;
                        a = (BYTE) (a0 + wInterp*da);
                        r = (BYTE) (r0 + wInterp*dr);
                        g = (BYTE) (g0 + wInterp*dg);
                        b = (BYTE) (b0 + wInterp*db);
                        SETPIXEL2 ((pFB + vv*dbgPrimaryPitch) + (uu<<dwFBIndexShift), a,r,g,b, dbgPrimaryBPP);
                    }
                }

                // move over to the next 4x4 block
                pFB += (4 << dwFBIndexShift);

            }  // u

        }  // v

    }

    else {  // !DXT

        // check for palettized surfaces
        if (pTexture->isPalettized()) {
            nvAssert (pTexture->getWrapper());
            if (pTexture->getWrapper()->getPalette()) {
                nvAssert (pTexture->getWrapper()->getPalette()->getPaletteSurface());
                pPalette = (PBYTE)(pTexture->getWrapper()->getPalette()->getPaletteSurface()->getAddress());
            } else {
                DPF("preview texture does not yet have a palette (normal if previewing from blit)");
                return;
            }
        }
        else if (pTexture->hasAutoPalette()) {
            pPalette = (PBYTE)(pTexture->getAutoPaletteOffset() +
                       pTexture->getSwizzled()->getAddress() -
                       pTexture->getSwizzled()->getOffset());
        }

        for (v=0; v < dwTexHeight; v++) {

            V_INTERLEAVE (v0, v, dwTexWidth, dwTexHeight);

            for (u=0; u < dwTexWidth; u++) {

                U_INTERLEAVE (u0, u, dwTexWidth, dwTexHeight);

                if (bLinear) {
                    pTexel = pTextureBase + (v * dwTexPitch) + (u << dwTexIndexShift);
                }
                else {
                    dwTexelIndex = u0 | v0;
                    pTexel = pTextureBase + (dwTexelIndex << dwTexIndexShift);
                }

                switch (pTexture->getFormat()) {

                    case NV_SURFACE_FORMAT_A1R5G5B5:

                        a = (BYTE)((*(WORD*)pTexel >> 8) & 0x80);
                        r = (BYTE)((*(WORD*)pTexel >> 7) & 0xf8);
                        g = (BYTE)((*(WORD*)pTexel >> 2) & 0xf8);
                        b = (BYTE)((*(WORD*)pTexel << 3) & 0xf8);
                        break;

                    case NV_SURFACE_FORMAT_X1R5G5B5:

                        a = (BYTE)(0xFF);
                        r = (BYTE)((*(WORD*)pTexel >> 7) & 0xf8);
                        g = (BYTE)((*(WORD*)pTexel >> 2) & 0xf8);
                        b = (BYTE)((*(WORD*)pTexel << 3) & 0xf8);
                        break;

                    case NV_SURFACE_FORMAT_A4R4G4B4:

                        a = (BYTE)((*(WORD*)pTexel >> 8) & 0xf0);
                        r = (BYTE)((*(WORD*)pTexel >> 4) & 0xf0);
                        g = (BYTE)((*(WORD*)pTexel >> 0) & 0xf0);
                        b = (BYTE)((*(WORD*)pTexel << 4) & 0xf0);
                        break;

                    case NV_SURFACE_FORMAT_R5G6B5:

                        a = (BYTE)(0xFF);
                        r = (BYTE)((*(WORD*)pTexel >> 8) & 0xf8);
                        g = (BYTE)((*(WORD*)pTexel >> 3) & 0xfc);
                        b = (BYTE)((*(WORD*)pTexel << 3) & 0xf8);
                        break;

                    case NV_SURFACE_FORMAT_A8R8G8B8:

                        a = (BYTE)((*(DWORD*)pTexel >> 24) & 0xff);
                        r = (BYTE)((*(DWORD*)pTexel >> 16) & 0xff);
                        g = (BYTE)((*(DWORD*)pTexel >>  8) & 0xff);
                        b = (BYTE)((*(DWORD*)pTexel >>  0) & 0xff);
                        break;

                    case NV_SURFACE_FORMAT_X8R8G8B8:

                        a = (BYTE)(0xFF);
                        r = (BYTE)((*(DWORD*)pTexel >> 16) & 0xff);
                        g = (BYTE)((*(DWORD*)pTexel >>  8) & 0xff);
                        b = (BYTE)((*(DWORD*)pTexel >>  0) & 0xff);
                        break;

                    case NV_SURFACE_FORMAT_DV8DU8:

                        a = (BYTE)(0xFF);
                        r = (BYTE)(0);
                        g = (BYTE)((*(WORD*)pTexel >> 8) & 0xff);
                        b = (BYTE)((*(WORD*)pTexel >> 0) & 0xff);
                        break;

                    case NV_SURFACE_FORMAT_L6DV5DU5:

                        a = (BYTE)(0xFF);
                        r = (BYTE)((*(WORD*)pTexel >> 8) & 0xfc);
                        g = (BYTE)((*(WORD*)pTexel >> 2) & 0xf8);
                        b = (BYTE)((*(WORD*)pTexel << 3) & 0xf8);
                        break;

                    case NV_SURFACE_FORMAT_X8L8DV8DU8:

                        a = (BYTE)(0xFF);
                        r = (BYTE)((*(DWORD*)pTexel >> 16) & 0xff);
                        g = (BYTE)((*(DWORD*)pTexel >>  8) & 0xff);
                        b = (BYTE)((*(DWORD*)pTexel >>  0) & 0xff);
                        break;

                    case NV_SURFACE_FORMAT_I8_A8R8G8B8:

                        nvAssert(pPalette);
                        dwColors = ((DWORD *)pPalette)[*pTexel];
                        a = (BYTE)((dwColors >> 24) & 0xff);
                        r = (BYTE)((dwColors >> 16) & 0xff);
                        g = (BYTE)((dwColors >>  8) & 0xff);
                        b = (BYTE)((dwColors >>  0) & 0xff);
                        break;

                    default:

                        DPF ("unhandled texture format in dbgTextureDisplay");
                        dbgD3DError();
                        return;
                        break;

                }  // switch

                if (dbgTexturePreview & NVDBG_TEXTURE_PREVIEW_ALPHA) r=g=b=a;
                if (a) dwNonZeroAlphaCount++;

                SETPIXEL2 (pFB+(u<<dwFBIndexShift), a,r,g,b, dbgPrimaryBPP);

            }  // loop on u

            pFB += dbgPrimaryPitch;

        }  // loop on v

    }  // !DXT

    if (pTexture->hasAlpha()) {
        if (dwNonZeroAlphaCount) {
            DPF_LEVEL (NVDBG_LEVEL_INFO, "dbgTextureDisplay - Non Zero Alpha Count = %08x of %08x",
                       dwNonZeroAlphaCount, dwTexWidth * dwTexHeight);
        }
        else {
            DPF_LEVEL (NVDBG_LEVEL_INFO, "dbgTextureDisplay - alpha texture has no alpha!!!!");
        }
    }
}

//---------------------------------------------------------------------------

void dbgTextureDisplay
(
    CTexture *pTexture
)
{
    CNvObject *pNvObjA, *pNvObjB;
    DWORD      dwX, dwY;
    DWORD      dwClearColor;

    nvAssert (pTexture);

    if (dbgTexturePreview & NVDBG_TEXTURE_PREVIEW_CUBE) {

        dwClearColor = (DWORD)(0xffffffff * ((double)rand() / RAND_MAX));
        dwX = 0;
        pNvObjB = pTexture->getWrapper();
        while (pNvObjB) {
            if (dbgTexturePreview & NVDBG_TEXTURE_PREVIEW_MIP) {
                dwY = 0;
                pNvObjA = pNvObjB;
                while (pNvObjA) {
                    dbgTextureDisplayLevel (pNvObjA->getTexture(), dwX, dwY, dwClearColor);
                    dwY += pNvObjA->getTexture()->getLogicalHeight();
                    pNvObjA = pNvObjA->getAttachedA();
                }
            }
            else {
                dbgTextureDisplayLevel (pNvObjB->getTexture(), dwX, 0, dwClearColor);
            }
            dwX += pNvObjB->getTexture()->getLogicalWidth();
            pNvObjB = pNvObjB->getAttachedB();
            dwClearColor = (DWORD)(0xffffffff * ((double)rand() / RAND_MAX));
        }

    }

    else if (dbgTexturePreview & NVDBG_TEXTURE_PREVIEW_MIP) {

        dwClearColor = (DWORD)(0xffffffff * ((double)rand() / RAND_MAX));
        dwY = 0;
        pNvObjA = pTexture->getWrapper();
        while (pNvObjA) {
            dbgTextureDisplayLevel (pNvObjA->getTexture(), 0, dwY, dwClearColor);
            dwY += pNvObjA->getTexture()->getLogicalHeight();
            pNvObjA = pNvObjA->getAttachedA();
        }

    }

    else if (dbgTexturePreview & NVDBG_TEXTURE_PREVIEW_BASE) {

        dwClearColor = (DWORD)(0xffffffff * ((double)rand() / RAND_MAX));
        dbgTextureDisplayLevel (pTexture, 0, 0, dwClearColor);

    }
}

#endif  // DEBUG

//-------------------------------------------------------------------------
// FRONT RENDERING
//-------------------------------------------------------------------------

#ifdef DEBUG

void dbgSetFrontRenderTarget (PNVD3DCONTEXT pContext, CSimpleSurface *pSurfaceToMimic)
{
    if (dbgFrontRender) {
        if (!pSurfaceToMimic->getWrapper()->getTexture()) {  // don't try to co-opt texture rendering
            dbgFrontRenderSurface.disown();
            dbgFrontRenderSurface.own (VIDMEM_ADDR(pDriverData->CurrentVisibleSurfaceAddress),
                                       dbgPrimaryPitch,
                                       pSurfaceToMimic->getHeight(),
                                       CSimpleSurface::HEAP_VID, FALSE);
            dbgFrontRenderSurface.setFormat (pSurfaceToMimic->getFormat());
            dbgFrontRenderSurface.setWidth (pSurfaceToMimic->getWidth());
            dbgFrontRenderSurface.setBPP (pSurfaceToMimic->getBPP());
            dbgFrontRenderSurface.setBPPRequested (pSurfaceToMimic->getBPPRequested());
            dbgFrontRenderSurface.setWrapper (pSurfaceToMimic->getWrapper());
            pContext->pRenderTarget = &(dbgFrontRenderSurface);
        }
    }
}

#endif // DEBUG

#endif  // NVARCH >= 0x04
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\ddraw\common\src\d3dState.cpp ===
/*
 * Copyright (C) 1995 Microsoft Corporation.  All Rights Reserved.
 * (C) Copyright NVIDIA Corporation Inc., 1996,1997. All rights reserved.
 */
/********************************* Direct 3D *******************************\
*                                                                           *
* Module: d3dState.cpp                                                      *
*   The Direct3D state routines.                                            *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*       Charles Inman (chasi)       01/02/97 - re-wrote and cleaned up.     *
*                                                                           *
\***************************************************************************/

#include "nvprecomp.h"
#if (NVARCH >= 0x04)


//-------------------------------------------------------------------------

#ifndef WINNT  // these calls are obsolete on NT (DX7)

DWORD __stdcall nvGetState
(
    LPD3DHAL_GETSTATEDATA pgsd
)
{
    /*
     * NOTES:
     * This callback is called when Direct3D requires information about
     * the state of a particular stage in the pipeline. If you only handle
     * rasterisation then you only need to respond to D3DHALSTATE_GET_RENDER
     * calls.
     * The state wanted is in pgsd->ddState.drstRenderStateType.
     * Return the answer in pgsd->ddState.dwArg[0].
     */
    if (!pgsd->dwhContext)
    {
        pgsd->ddrval = D3DHAL_CONTEXT_BAD;
        return (DDHAL_DRIVER_HANDLED);
    }
    if (pgsd->dwWhich != D3DHALSTATE_GET_RENDER)
    {
        pgsd->ddrval = DD_OK;
        return (DDHAL_DRIVER_HANDLED);
    }
    pgsd->ddState.dwArg[0] = 1;
    pgsd->ddrval           = DD_OK;
    return (DDHAL_DRIVER_HANDLED);
}

#endif  // !WINNT

//remove these defines when they get into the MS runtime.
typedef struct    _D3DDEVINFO_VCACHEPARAM
{
DWORD Pattern; // bit pattern,return value must be FOUR_CC('C', 'A', 'C', 'H')
DWORD OptMethod;//optimization method 0 means longest strips, 1 means vertex cache based
DWORD CacheSize;// cache size to optimize for  (only required if type is 1)
DWORD MagicNumber; // used to determine when to restart strips 
} D3DDEVINFO_VCACHEPARAM;
 
#define D3DDEVINFOID_VCACHEPARAM   4
//end remove


//-------------------------------------------------------------------------
// This fdunction is a general purpose callback.  Almost ANYTHING can be passed
// back and forth.  It is currently used for Vertex Cache information and texture
// management, but is easily extended.


DWORD __stdcall nvGetDriverState
(
    LPDDHAL_GETDRIVERSTATEDATA pgdsd
)
{
    DWORD dwHandled=DDHAL_DRIVER_NOTHANDLED;
    PNVD3DCONTEXT pContext = (PNVD3DCONTEXT)pgdsd->dwhContext;

    dbgTracePush ("nvGetDriverState");
    
    nvSetDriverDataPtrFromContext(pContext);

#if (NVARCH >= 0x010)    
    if (pgdsd->dwFlags == D3DDEVINFOID_VCACHEPARAM && 
        pgdsd->dwLength >= sizeof(D3DDEVINFO_VCACHEPARAM) )
    {
        D3DDEVINFO_VCACHEPARAM *lpVCache = (D3DDEVINFO_VCACHEPARAM *)pgdsd->lpdwStates;

        lpVCache->Pattern = mmioFOURCC('C', 'A', 'C', 'H');
        lpVCache->OptMethod = 1;
        lpVCache->MagicNumber = 7;
#if (NVARCH >= 0x020)
        if (pDriverData->nvD3DPerfData.dwNVClasses & NVCLASS_FAMILY_KELVIN) 
        {
            lpVCache->CacheSize = 16;
        }
        else 
#endif
        if (pDriverData->nvD3DPerfData.dwNVClasses & NVCLASS_FAMILY_CELSIUS) 
        {
            lpVCache->CacheSize = 12;
        }
        pgdsd->ddRVal = DD_OK;
        dwHandled = DDHAL_DRIVER_HANDLED;
    }
#endif
    dbgTracePop();
    DDHAL_EXIT(dwHandled);
}

#endif  // NVARCH >= 0x04
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\ddraw\common\src\d3dTex.cpp ===
/*
 * Copyright (C) 1995 Microsoft Corporation.  All Rights Reserved.
 * (C) Copyright NVIDIA Corporation Inc., 1996,1998. All rights reserved.
 */
/********************************* Direct 3D *******************************\
*                                                                           *
* Module: d3dTex.cpp                                                        *
*   The Direct3D texture routines.                                          *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*       Charles Inman (chasi)       01/02/97 - re-wrote and cleaned up.     *
*       Ben de Waal (bdw)           08/28/97 - enabled locked tex status    *
*                                   09/19/97 - optimize mipmap creation     *
*                                                                           *
\***************************************************************************/
#include "nvprecomp.h"

#if (NVARCH >= 0x04)

/*
 * --------------------------------------------------------------------------
 * D3D HAL texture callback routines
 * --------------------------------------------------------------------------
 */
DWORD __stdcall nvTextureCreate
(
    LPD3DHAL_TEXTURECREATEDATA  pTextureCreateData
)
{
    dbgTracePush ("nvTextureCreate");

    LPDDRAWI_DDRAWSURFACE_LCL   lpLcl;

    /*
     * NOTES:
     *
     * This callback is invoked when a texture is to be created from a
     *  DirectDrawSurface.
     * We must pass back the created handle.
     */

    /*
     * Get the pointer to the context this texture is associated with.
     */
    PNVD3DCONTEXT pContext;
    NV_SET_CONTEXT (pContext, pTextureCreateData);

    /*
     * Validate the parameters of the texture being created.
     */
    lpLcl = NvLockTextureSurface(pTextureCreateData);
    if (!lpLcl)
    {
        DPF_LEVEL(NVDBG_LEVEL_ERROR, "nvTextureCreate - Texture Create Failed");
        dbgD3DError();
        pTextureCreateData->ddrval = D3DERR_TEXTURE_CREATE_FAILED;
        dbgTracePop();
        return (DDHAL_DRIVER_HANDLED);
    }

    /*
     * Get pointer to global driver. data structure.
     */
    nvSetDriverDataPtrFromContext(pContext);

    /*
     * verify that we have the DX6 runtime. Should never happen on DX7.
     */
    nvAssert (global.dwDXRuntimeVersion < 0x0700);

    /*
     * get texture pointer
     */
    CNvObject *pNvObj = GET_PNVOBJ (lpLcl);

    if (lpLcl->ddsCaps.dwCaps & DDSCAPS_SYSTEMMEMORY) {

        // Not that much we can do about a system memory texture. We just need to
        // create an object which we will use from now on.
        if (!IS_VALID_PNVOBJ(pNvObj)) {
            //The object hasn't been allocated yet.
            if ((pTextureCreateData->ddrval = nvCreateSystemMemorySurface(lpLcl)) != DD_OK)
            {
                dbgD3DError();
                DPF_LEVEL(NVDBG_LEVEL_ERROR, "nvTextureCreate - out of memory");
                pTextureCreateData->ddrval = D3DERR_TEXTURE_CREATE_FAILED;
            }
            pNvObj = GET_PNVOBJ (lpLcl);
        }
        else {
            //Nothing to do at all
            pTextureCreateData->ddrval = DD_OK;
        }

        nvAssert (IS_VALID_PNVOBJ(pNvObj));
        pTextureCreateData->dwHandle = (DWORD) pNvObj;
        // For DX6 runtime we will reuse the Object->Handle to keep a pointer to the local.
        pNvObj->setHandle ((DWORD)lpLcl);

        NvReleaseSemaphore(pDriverData);
        dbgTracePop();
        return (DDHAL_DRIVER_HANDLED);
    }

    CTexture *pTexture = pNvObj ? pNvObj->getTexture() : NULL;

    /*
     * is texture object allocated yet?
     */
    if (!pTexture)
    {
        /*
         * verify that we do not overwrite a different object
         */
        nvAssert (GET_PNVOBJ(lpLcl) == NULL);

        /*
         * The internal texture data structure has not been allocated yet. This can
         * happen if the application allocates it's texture handles before it creates the
         * texture surfaces.  (Ziff Davis 3D Winbench)
         * So we have to handle both cases.  If the data structure has not been allocated
         * yet, allocate it here.
         */
        pNvObj   = new CNvObject (pContext->pid);
        pTexture = new CTexture;

        if (!pNvObj || !pTexture)
        {
            /*
             * Bad news.  Could not allocate the internal data structure.  No choice but to
             * return an error.
             */
            dbgD3DError();
            DPF_LEVEL(NVDBG_LEVEL_ERROR, "nvTextureCreate - out of memory");
            if (pNvObj) pNvObj->release();
            NvReleaseSemaphore(pDriverData);
            pTextureCreateData->ddrval = D3DERR_TEXTURE_CREATE_FAILED;
            dbgTracePop();
            return (DDHAL_DRIVER_HANDLED);
        }

        /*
         * update stats
         */
        getDC()->dwD3DTextureCount++;

        /*
         * Store the handle of the internal texture structure in the local surface structure
         * driver reserved field.
         */
        pNvObj->setObject (CNvObject::NVOBJ_TEXTURE, pTexture);
        SET_PNVOBJ (lpLcl, pNvObj);
    }

    /*
     * Return the new texture handle.
     */
    DPF_LEVEL(NVDBG_LEVEL_INFO, "nvTextureCreate - New texture handle = %08x", pTexture);
    pTextureCreateData->dwHandle = (DWORD)pNvObj;

    /*
     * A handle is only ever allocated for the top-most level of the mipmap chain.
     * run down the chain and update the mipmap base texture for each mipmap.
     */
    if ((lpLcl->ddsCaps.dwCaps & DDSCAPS_MIPMAP)
     && (!lpLcl->lpAttachListFrom)
     && (lpLcl->lpAttachList))
    {
        LPDDRAWI_DDRAWSURFACE_LCL lclMip;
        lclMip = lpLcl->lpAttachList->lpAttached;
        while (lclMip)
        {
            CTexture *pMipMap;

            pMipMap = GET_PNVOBJ(lclMip)->getTexture();
            if (IS_VALID_PNVOBJ(pMipMap))
            {
                pMipMap->tagUserMipLevel();
                pMipMap->setBaseTexture (pTexture);
            }
            if (lclMip->lpAttachList) {
                lclMip = lclMip->lpAttachList->lpAttached;
            }
            else {
                lclMip = 0;
            }
        }
    }

    NvUnlockTextureSurface(lpLcl);
    /*
     * Show that the texture has not been loaded yet and that it is not locked.
     */
    pTexture->tagHasHandle();

    /*
     * Load convert the texture immediately so that hopefully real game speed does not
     * get impacted during actual game play.  This has no effect on the benchmarks, but
     * it can sometimes help out games (like moto racer with the polygon patch).
     */
    if (!pTexture->getSwizzled()->isValid() && pTexture->getLinear()->isValid())
    {
        pTexture->updateSwizzleSurface (pContext);
    }

    /*
     * For DX6 runtime we will reuse the Object->Handle to keep a pointer to
     * the local.
     */
     pNvObj->setHandle((DWORD)lpLcl);
     pNvObj->reference();    //add a reference so we don't go and delete this object
                             //when we 'release' the texture in the symmetric destroy call.

    /*
     * Texture creation successful.
     */
    NvReleaseSemaphore(pDriverData);
    pTextureCreateData->ddrval = DD_OK;
    dbgTracePop();
    return DDHAL_DRIVER_HANDLED;
}

//-------------------------------------------------------------------------

DWORD __stdcall nvTextureDestroy
(
    LPD3DHAL_TEXTUREDESTROYDATA pTextureDestroyData
)
{
    CNvObject *pNvObj;
    CTexture  *pTexture;

    dbgTracePush ("nvTextureDestroy - handle=%08x", pTextureDestroyData->dwHandle);

    /*
     * get context
     */
    PNVD3DCONTEXT pContext;
    NV_SET_CONTEXT (pContext, pTextureDestroyData);

    nvSetDriverDataPtrFromContext (pContext);

    /*
     * verify that we have the DX6 runtime. Should never happen on DX7.
     */
    nvAssert (global.dwDXRuntimeVersion < 0x0700);

    pNvObj   = (CNvObject *)pTextureDestroyData->dwHandle;

    if (pNvObj->getClass() == CNvObject::NVOBJ_SIMPLESURFACE) {
        /* This handle is associated with a texture in system memory.
         * We just need to release the object.
         */
        LPDDRAWI_DDRAWSURFACE_LCL lpLcl = (LPDDRAWI_DDRAWSURFACE_LCL)pNvObj->getHandle();
        nvDeleteSystemMemorySurface(lpLcl);
        pTextureDestroyData->ddrval = DD_OK;
        NvReleaseSemaphore(pDriverData);
        dbgTracePop();
        return (DDHAL_DRIVER_HANDLED);
    }

    pTexture = pNvObj->getTexture();

    /*
     * Perform all the neccessary steps for destroying this texture handle.
     * Destruction of the actual texture data structure is actually
     * dependent on the current state of the texture surface structure.
     */
    if (pTexture)
    {
        // Make sure the texture is not the currently selected handle in the context.
        DWORD   dwStage;

        for (dwStage = 0; dwStage < 8; dwStage++)
        {
            if (pContext->tssState[dwStage].dwValue[D3DTSS_TEXTUREMAP] == (DWORD)pNvObj) {
                pContext->tssState[dwStage].dwValue[D3DTSS_TEXTUREMAP] = NULL;
                pContext->tssState[dwStage].dwHandle = 0;
            }
        }

        // Destroy the internal texture data structure.
        //this seems circular if we had a pNvObj above.
        //CNvObject *pNvObj = pTexture->getWrapper();

        //don't remove the pnvobj here -- we shouldn't actually destroy surfaces here
        //LPDDRAWI_DDRAWSURFACE_LCL lpLcl = (LPDDRAWI_DDRAWSURFACE_LCL)pNvObj->getHandle();
        //SET_PNVOBJ (lpLcl, NULL);

        pNvObj->release();
    }

    // Texture destroyed successfully.
    pTextureDestroyData->ddrval = DD_OK;
    NvReleaseSemaphore(pDriverData);
    dbgTracePop();
    return DDHAL_DRIVER_HANDLED;
}

//-------------------------------------------------------------------------

/*
 * nvTextureSwap
 *
 * This callback is invoked when two texture handles are to be swapped.
 * I.e. the data refered to by the two handles is to be swapped.
 */
DWORD __stdcall nvTextureSwap
(
    LPD3DHAL_TEXTURESWAPDATA pTextureSwapData
)
{
    dbgTracePush ("nvTextureSwap - hContext=%08x, h1=%08x, h2=%08x",
                  pTextureSwapData->dwhContext, pTextureSwapData->dwHandle1, pTextureSwapData->dwHandle2);

    // get a pointer to the context
    PNVD3DCONTEXT pContext;
    NV_SET_CONTEXT (pContext, pTextureSwapData);

    nvSetDriverDataPtrFromContext(pContext);

    // verify that we have the DX6 runtime. Should never happen on DX7.
    nvAssert (global.dwDXRuntimeVersion < 0x0700);

    // Get pointers and classes
    CNvObject *pNvObj1, *pNvObj2;
    DWORD      dwClass1, dwClass2;

    pNvObj1  = (CNvObject *)(pTextureSwapData->dwHandle1);
    pNvObj2  = (CNvObject *)(pTextureSwapData->dwHandle2);
    nvAssert (pNvObj1);
    nvAssert (pNvObj2);
    dwClass1 = pNvObj1->getClass();
    dwClass2 = pNvObj2->getClass();

    if ((dwClass1 != CNvObject::NVOBJ_SIMPLESURFACE) &&
        (dwClass1 != CNvObject::NVOBJ_TEXTURE)) {
        DPF_LEVEL(NVDBG_LEVEL_ERROR, "nvTextureSwap - Bad Texture 1");
        dbgD3DError();
        NvReleaseSemaphore(pDriverData);
        pTextureSwapData->ddrval = DDERR_INVALIDPARAMS;
        dbgTracePop();
        return (DDHAL_DRIVER_HANDLED);
    }

    if ((dwClass2 != CNvObject::NVOBJ_SIMPLESURFACE) &&
        (dwClass2 != CNvObject::NVOBJ_TEXTURE)) {
        DPF_LEVEL(NVDBG_LEVEL_ERROR, "nvTextureSwap - Bad Texture 2");
        dbgD3DError();
        NvReleaseSemaphore(pDriverData);
        pTextureSwapData->ddrval = DDERR_INVALIDPARAMS;
        dbgTracePop();
        return (DDHAL_DRIVER_HANDLED);
    }

    // swap the contents of the pNvObjects
    pNvObj1->swap (pNvObj2);

    // fix up the back-pointers in the DDSLcls
    SET_PNVOBJ (((LPDDRAWI_DDRAWSURFACE_LCL)pNvObj1->getHandle()), pNvObj1);
    SET_PNVOBJ (((LPDDRAWI_DDRAWSURFACE_LCL)pNvObj2->getHandle()), pNvObj2);

    // Texture swap was successful.
    NvReleaseSemaphore(pDriverData);
    pTextureSwapData->ddrval = DD_OK;
    dbgTracePop();
    return (DDHAL_DRIVER_HANDLED);
}

//-------------------------------------------------------------------------

/*
 * nvTextureGetSurf
 *
 * This callback is invoked when d3d needs to obtain the surface
 * referred to by a handle.
 */
DWORD __stdcall nvTextureGetSurf
(
    LPD3DHAL_TEXTUREGETSURFDATA pTextureGetSurfData
)
{
    dbgTracePush ("nvTextureGetSurf - handle=%08x", pTextureGetSurfData->dwHandle);

    /*
     * Get the pointer to the specified context.
     */
    PNVD3DCONTEXT pContext = (PNVD3DCONTEXT)pTextureGetSurfData->dwhContext;
    if (!pContext)
    {
        dbgD3DError();
        DPF_LEVEL(NVDBG_LEVEL_ERROR, "nvTextureGetSurf - Bad Context");
        pTextureGetSurfData->ddrval = D3DHAL_CONTEXT_BAD;
        dbgTracePop();
        return (DDHAL_DRIVER_HANDLED);
    }

    /*
     * verify that we have the DX6 runtime. Should never happen on DX7.
     */
    nvAssert (global.dwDXRuntimeVersion < 0x0700);
#ifndef WINNT
// WINNT BUG
    CNvObject *pNvObj = (CNvObject *)pTextureGetSurfData->dwHandle;
    LPDDRAWI_DDRAWSURFACE_LCL lpLcl = (LPDDRAWI_DDRAWSURFACE_LCL)pNvObj->getHandle();
    pTextureGetSurfData->lpDDS = (ULONG_PTR)lpLcl;
#endif

    // Texture surface was gotten successfully.
    pTextureGetSurfData->ddrval = DD_OK;
    dbgTracePop();
    return (DDHAL_DRIVER_HANDLED);
}

/*
 * --------------------------------------------------------------------------
 * Texture heap management routines.
 * --------------------------------------------------------------------------
 */

// nvPCICreateHeap
// top-level routine for creation of the PCI heap

BOOL nvPCICreateHeap
(
    void
)
{
    DWORD status;
    DWORD dwBlockStartOffset;

    dbgTracePush ("nvPCICreateHeap");

    // shouldn't create the heap more than once
    nvAssert(!pDriverData->nvD3DTexHeapData.dwHandle);

    // should only do this if AGP is not available
    nvAssert(!pDriverData->GARTLinearBase);

    // The texture heap always starts out empty.
    getDC()->nvD3DTexHeapData.dwAllocSize = 0;

    // Get the maximum size of the texture heap.
    getDC()->nvD3DTexHeapData.dwSizeMax = getDC()->nvD3DRegistryData.regPCITexHeapSize ?
                                          getDC()->nvD3DRegistryData.regPCITexHeapSize :
                                          pDriverData->nvD3DPerfData.dwRecommendedPCITexHeapSize;

    if (!(getDC()->nvD3DTexHeapData.dwSizeMax)) {
        dbgTracePop();
        return (TRUE);
    }

    do {
        // Create the texture heap.
        getDC()->nvD3DTexHeapData.dwHandle = (DWORD)HeapCreate(HEAP_SHARED, getDC()->nvD3DTexHeapData.dwSizeMax, 0);
        if (!getDC()->nvD3DTexHeapData.dwHandle) {
            dbgTracePop();
            return (FALSE);
        }

        // Allocate the entire heap up front for management.
        getDC()->nvD3DTexHeapData.dwBaseRaw = (unsigned long)HeapAlloc((HANDLE)getDC()->nvD3DTexHeapData.dwHandle, HEAP_ZERO_MEMORY, getDC()->nvD3DTexHeapData.dwSizeMax);
        if (!getDC()->nvD3DTexHeapData.dwBaseRaw)
        {
            HeapDestroy((HANDLE)getDC()->nvD3DTexHeapData.dwHandle);
            getDC()->nvD3DTexHeapData.dwHandle = (DWORD)NULL;
            dbgTracePop();
            return (FALSE);
        }

        // Get the size of the allocated heap and set the maximum heap limit. The size shouldn't be different
        // than what we asked for, but on win9x, we do the check just to be safe. (On WinNT, we can't, because
        // the function HeapSize does not exist)
#ifndef WINNT
        getDC()->nvD3DTexHeapData.dwSizeMax = (DWORD) HeapSize ((HANDLE)getDC()->nvD3DTexHeapData.dwHandle, 0, (PTEXHEAPHEADER)getDC()->nvD3DTexHeapData.dwBaseRaw);
#endif

        // Align the heap properly.
        getDC()->nvD3DTexHeapData.dwBase      = ((getDC()->nvD3DTexHeapData.dwBaseRaw + NV_TEXTURE_OFFSET_ALIGN) & ~NV_TEXTURE_OFFSET_ALIGN);
        getDC()->nvD3DTexHeapData.dwSizeMax  -= (getDC()->nvD3DTexHeapData.dwBase - getDC()->nvD3DTexHeapData.dwBaseRaw);
        getDC()->nvD3DTexHeapData.dwSizeMax  &= 0xFFFFFF00;
        getDC()->nvD3DTexHeapData.dwLimitMax  = getDC()->nvD3DTexHeapData.dwSizeMax - 1;
        getDC()->nvD3DTexHeapData.dwFreeSize  = getDC()->nvD3DTexHeapData.dwSizeMax - NV_TEXTURE_PAD;
        getDC()->nvD3DTexHeapData.dwSize      = getDC()->nvD3DTexHeapData.dwSizeMax;
        getDC()->nvD3DTexHeapData.dwLimit     = getDC()->nvD3DTexHeapData.dwSize - 1;

        // Try and lock down the entire heap.
        status = D3DCreateTextureContexts (getDC()->nvD3DTexHeapData.dwBase, getDC()->nvD3DTexHeapData.dwLimit);

        if (status)
        {
            // Map the context to the frame buffer because the RM/Hardware doesn't
            // like having limts of 0.
//            D3DCreateTextureContexts (VIDMEM_ADDR(pDriverData->BaseAddress), 0xFF, 0xFF);
            HeapFree((HANDLE)getDC()->nvD3DTexHeapData.dwHandle, 0, (PTEXHEAPHEADER)getDC()->nvD3DTexHeapData.dwBaseRaw);
            HeapDestroy((HANDLE)getDC()->nvD3DTexHeapData.dwHandle);
            getDC()->nvD3DTexHeapData.dwHandle  = (DWORD)NULL;
            getDC()->nvD3DTexHeapData.dwBaseRaw = (unsigned long)NULL;

            // reduce the size and try again
            getDC()->nvD3DTexHeapData.dwSizeMax -= min(getDC()->nvD3DTexHeapData.dwSizeMax, HEAP_SIZE_ADJUST);
            if (!getDC()->nvD3DTexHeapData.dwSizeMax)
            {
                nvAssert(0);
                // Can't lock down even a minimal heap.  Disable system memory textures.
                pDriverData->nvD3DPerfData.dwRecommendedPCITexHeapSize = 0;
                getDC()->nvD3DRegistryData.regPCITexHeapSize           = 0;
                getDC()->nvD3DTexHeapData.dwSizeMax                    = 0;
                getDC()->nvD3DTexHeapData.dwLimitMax                   = 0;
                dbgTracePop();
                return (FALSE);
            }
        }

    } while (!getDC()->nvD3DTexHeapData.dwHandle);

    /*
     * Align the start of the texture.
     * 1) Original way was aligning the texture heap base address then aligning each
     *    individual texture start offset off of the texture heap base address.
     */
//    dwBlockStartOffset                       = (sizeof(TEXHEAPHEADER) + NV_TEXTURE_OFFSET_ALIGN) & ~NV_TEXTURE_OFFSET_ALIGN;
    /*
     * 2) New way is to align the texture heap address and align the start address of each
     *    texture.
     */
    dwBlockStartOffset = (((getDC()->nvD3DTexHeapData.dwBase + sizeof(TEXHEAPHEADER) + NV_TEXTURE_OFFSET_ALIGN) & ~NV_TEXTURE_OFFSET_ALIGN) - getDC()->nvD3DTexHeapData.dwBase);

    // Fill in the initial block structure.
    (getDC()->nvD3DTexHeapData.dwFreeHead)                                     = (unsigned long)(getDC()->nvD3DTexHeapData.dwBase + dwBlockStartOffset - sizeof(TEXHEAPHEADER));
    (getDC()->nvD3DTexHeapData.dwFreeTail)                                     = (unsigned long)getDC()->nvD3DTexHeapData.dwFreeHead;
    ((PTEXHEAPHEADER)getDC()->nvD3DTexHeapData.dwFreeHead)->dwTag              = HEAP_TAG_FREE;
    ((PTEXHEAPHEADER)getDC()->nvD3DTexHeapData.dwFreeHead)->dwBlockSize        = getDC()->nvD3DTexHeapData.dwSizeMax - dwBlockStartOffset;
    ((PTEXHEAPHEADER)getDC()->nvD3DTexHeapData.dwFreeHead)->dwBlockStartOffset = dwBlockStartOffset;
    ((PTEXHEAPHEADER)getDC()->nvD3DTexHeapData.dwFreeHead)->pNextFreeBlock     = (PTEXHEAPHEADER)NULL;
    ((PTEXHEAPHEADER)getDC()->nvD3DTexHeapData.dwFreeHead)->pPrevFreeBlock     = (PTEXHEAPHEADER)NULL;
    ((PTEXHEAPHEADER)getDC()->nvD3DTexHeapData.dwFreeHead)->pNextAllocBlock    = (PTEXHEAPHEADER)NULL;
    ((PTEXHEAPHEADER)getDC()->nvD3DTexHeapData.dwFreeHead)->pPrevAllocBlock    = (PTEXHEAPHEADER)NULL;

    // Dump some information about the texture heap.
    DPF_LEVEL(NVDBG_LEVEL_INFO, "nvPCICreateHeap:");
    DPF_LEVEL(NVDBG_LEVEL_INFO, "   dwBase      = %08x", getDC()->nvD3DTexHeapData.dwBase);
    DPF_LEVEL(NVDBG_LEVEL_INFO, "   dwSizeMax   = %08x", getDC()->nvD3DTexHeapData.dwSizeMax);
    DPF_LEVEL(NVDBG_LEVEL_INFO, "   dwLimitMax  = %08x", getDC()->nvD3DTexHeapData.dwLimitMax);
    DPF_LEVEL(NVDBG_LEVEL_INFO, "   dwSize      = %08x", getDC()->nvD3DTexHeapData.dwSize);
    DPF_LEVEL(NVDBG_LEVEL_INFO, "   dwLimit     = %08x", getDC()->nvD3DTexHeapData.dwLimit);
    DPF_LEVEL(NVDBG_LEVEL_INFO, "   dwFreeSize  = %08x", getDC()->nvD3DTexHeapData.dwFreeSize);
    DPF_LEVEL(NVDBG_LEVEL_INFO, "   dwAllocSize = %08x", getDC()->nvD3DTexHeapData.dwAllocSize);

    // Return successfully.
    dbgTracePop();
    return (TRUE);
}

//-------------------------------------------------------------------------

// DestroyTextureHeap
// top-level routine for destruction of the PCI heap

BOOL nvPCIDestroyHeap
(
    void
)
{
    dbgTracePush ("nvPCIDestroyHeap");

    D3DDestroyTextureContexts (pDriverData);

    // Can't destroy a heap if there isn't one.
    nvAssert (getDC()->nvD3DTexHeapData.dwHandle);

    if (!(getDC()->nvD3DTexHeapData.dwHandle)) { return TRUE; }

    nvAssert(pDriverData->GARTLinearBase == 0);

    // Only need to free the heap if it was allocated.  (it won't be allocated on an AGP system)
    HeapFree((HANDLE)getDC()->nvD3DTexHeapData.dwHandle, 0, (PTEXHEAPHEADER)getDC()->nvD3DTexHeapData.dwBaseRaw);
    HeapDestroy((HANDLE)getDC()->nvD3DTexHeapData.dwHandle);

    // Clean up a little bit.
    getDC()->nvD3DTexHeapData.dwHandle    = (DWORD)NULL;
    getDC()->nvD3DTexHeapData.dwBaseRaw   = (unsigned long)NULL;
    getDC()->nvD3DTexHeapData.dwBase      = (unsigned long)NULL;
    getDC()->nvD3DTexHeapData.dwAllocHead = (unsigned long)NULL;
    getDC()->nvD3DTexHeapData.dwAllocTail = (unsigned long)NULL;
    getDC()->nvD3DTexHeapData.dwFreeHead  = (unsigned long)NULL;
    getDC()->nvD3DTexHeapData.dwFreeTail  = (unsigned long)NULL;
    getDC()->nvD3DTexHeapData.dwSize      = 0;
    getDC()->nvD3DTexHeapData.dwSizeMax   = 0;
    getDC()->nvD3DTexHeapData.dwLimit     = 0;
    getDC()->nvD3DTexHeapData.dwLimitMax  = 0;
    getDC()->nvD3DTexHeapData.dwAllocSize = 0;
    getDC()->nvD3DTexHeapData.dwFreeSize  = 0;

    dbgTracePop();
    return (TRUE);
}

//-------------------------------------------------------------------------

DWORD nvPCIAlloc
(
    DWORD   dwSizeRequest
)
{
    DWORD           dwAllocBlockSize;
    DWORD           dwNewFreeBlockSize;
    DWORD           dwNewFreeBlockOffset;
    DWORD           dwNewFreeBlockStartOffset;
    DWORD           dwAllocLimit;
    PTEXHEAPHEADER  pAllocBlock;
    PTEXHEAPHEADER  pList;
    PTEXHEAPHEADER  pNextFree;
    PTEXHEAPHEADER  pPrevFree;
    PTEXHEAPHEADER  pNewFree;

    dbgTracePush ("nvPCIAlloc");

    // make sure we have a heap to allocate from
    nvAssert (getDC()->nvD3DTexHeapData.dwHandle);

    /*
     * If the free list is null, then there's no memory to be allocated.
     */
    if ((!getDC()->nvD3DTexHeapData.dwFreeHead)
     || (getDC()->nvD3DTexHeapData.dwFreeSize < dwSizeRequest))
    {
        DPF_LEVEL(NVDBG_LEVEL_ERROR, "nvPCIAlloc - Not enough free memory to fill request!");
        dbgTracePop();
        return (0);
    }

    /*
     * Search the free block list for a block large enough to fill this
     * request.
     */
    pAllocBlock      = (PTEXHEAPHEADER)NULL;
    dwAllocBlockSize = 0;
    pList            = (PTEXHEAPHEADER)getDC()->nvD3DTexHeapData.dwFreeHead;

    /*
     * The search will end when a block has been found that exactly matches
     * the requested size or the end of the free list has been reached. In the
     * event that an exact size match is not found, then the first block that is
     * closest to the requested size will be used.
     *
     * CHASNOTE: Potential problem with this method is that a larger block might
     * be passed up for a smaller block later in the heap and this could mean that
     * the context limit will fail shrink when it may have otherwise if the larger
     * block was used.
     */
    while ((pList)
        && (dwAllocBlockSize != dwSizeRequest))
    {
        if (pList->dwBlockSize >= dwSizeRequest)
        {
            if ((!dwAllocBlockSize)
             || (pList->dwBlockSize < dwAllocBlockSize))
            {
                pAllocBlock      = pList;
                dwAllocBlockSize = pList->dwBlockSize;
            }
        }
        pList = pList->pNextFreeBlock;
    }

    /*
     * If there was no block large enough to fill the request, return unsuccessful.
     */
    if (!pAllocBlock) {
        dbgTracePop();
        return (0);
    }

    /*
     * Get a few pointers.
     */
    pPrevFree                   = pAllocBlock->pPrevFreeBlock;
    pNextFree                   = pAllocBlock->pNextFreeBlock;
    pAllocBlock->pPrevFreeBlock = (PTEXHEAPHEADER)NULL;
    pAllocBlock->pNextFreeBlock = (PTEXHEAPHEADER)NULL;

    /*
     * Initialize the newly allocated block header and create
     * the new free block as neccessary.
     */
    pAllocBlock->dwTag       = HEAP_TAG_ALLOC;
    pAllocBlock->dwBlockSize = dwSizeRequest;

    /*
     * Allocate any new free block if the block being used for the allocation
     * is larger than the requested block size.
     */
    dwNewFreeBlockSize = dwAllocBlockSize - dwSizeRequest;

    /*
     * Adjust alignment so the next free block starts on the correct boundry for an NV3
     * texture.
     */
    if (dwNewFreeBlockSize >= (sizeof(TEXHEAPHEADER) + NV_MIN_TEXTURE_SIZE))
    {
        DWORD dwNextBlockOffset;
        DWORD dwExcess;

        dwNextBlockOffset = pAllocBlock->dwBlockStartOffset + dwSizeRequest;
        /*
         * Align the start of the texture.
         * 1) Original way was aligning the texture heap base address then aligning each
         *    individual texture start offset off of the texture heap base address.
         */
//        dwNewFreeBlockStartOffset = (dwNextBlockOffset + sizeof(TEXHEAPHEADER) + NV_TEXTURE_OFFSET_ALIGN) & ~NV_TEXTURE_OFFSET_ALIGN;
        /*
         * 2) New way is to align the texture heap address and align the start address of each
         *    texture.
         */
        dwNewFreeBlockStartOffset = ((((getDC()->nvD3DTexHeapData.dwBase + dwNextBlockOffset + sizeof(TEXHEAPHEADER)) + NV_TEXTURE_OFFSET_ALIGN) & ~NV_TEXTURE_OFFSET_ALIGN) - getDC()->nvD3DTexHeapData.dwBase);
        dwNewFreeBlockOffset      = dwNewFreeBlockStartOffset - sizeof(TEXHEAPHEADER);
        dwExcess                  = dwNewFreeBlockOffset - dwNextBlockOffset;
        dwNewFreeBlockSize       -= dwExcess;
        pAllocBlock->dwBlockSize += dwExcess;
    }

    /*
     * Now that the block has been aligned on the correct boundry, check again to make sure
     * that there's still enough room for a minimum sized texture.
     */
    if (dwNewFreeBlockSize >= (sizeof(TEXHEAPHEADER) + NV_MIN_TEXTURE_SIZE))
    {
        DPF_LEVEL(NVDBG_LEVEL_INFO, "nvPCIAlloc - Create new free block at end of allocation block.");

        /*
         * Create the new free block.
         */
        pNewFree                     = (PTEXHEAPHEADER)(getDC()->nvD3DTexHeapData.dwBase + dwNewFreeBlockOffset);
        pNewFree->dwTag              = HEAP_TAG_FREE;
        pNewFree->dwBlockStartOffset = dwNewFreeBlockStartOffset;
        pNewFree->dwBlockSize        = dwNewFreeBlockSize - sizeof(TEXHEAPHEADER);
        pNewFree->pNextFreeBlock     = pNextFree;
        pNewFree->pPrevFreeBlock     = pPrevFree;
        pNewFree->pNextAllocBlock    = (PTEXHEAPHEADER)NULL;
        pNewFree->pPrevAllocBlock    = (PTEXHEAPHEADER)NULL;

        /*
         * Insert the new free block into the free block list.
         */
        if (pPrevFree) {
            pPrevFree->pNextFreeBlock = pNewFree;
        }
        else {
            getDC()->nvD3DTexHeapData.dwFreeHead = (unsigned long)pNewFree;
        }

        if (pNextFree) {
            pNextFree->pPrevFreeBlock = pNewFree;
        }
        else {
            getDC()->nvD3DTexHeapData.dwFreeTail = (unsigned long)pNewFree;
        }
    }
    else
    {
        DPF_LEVEL(NVDBG_LEVEL_INFO, "nvPCIAlloc - Tack excess free memory  onto end of allocation block.");

        /*
         * Tack the excess memory on to the end of the block.
         */
        pAllocBlock->dwBlockSize += dwNewFreeBlockSize;

        /*
         * Remove the block from the free block list.
         */
        if (pPrevFree) {
            pPrevFree->pNextFreeBlock = pNextFree;
        }
        else {
            getDC()->nvD3DTexHeapData.dwFreeHead = (unsigned long)pNextFree;
        }

        if (pNextFree) {
            pNextFree->pPrevFreeBlock = pPrevFree;
        }
        else {
            getDC()->nvD3DTexHeapData.dwFreeTail = (unsigned long)pPrevFree;
        }
    }

    /*
     * Update the allocation sizes.
     */
    getDC()->nvD3DTexHeapData.dwAllocSize += pAllocBlock->dwBlockSize;
    getDC()->nvD3DTexHeapData.dwFreeSize  -= pAllocBlock->dwBlockSize;

    /*
     * Insert the newly allocated block into the allocation list.
     * First handle the best case scenarios, the block is either the first block
     * to be allocated, the block comes before the current head of the allocation
     * list, or the block comes after the current tail of the allocation list.
     * In these cases, its simply a case of updating a few pointers.
     */
    if (!getDC()->nvD3DTexHeapData.dwAllocHead)
    {
        DPF_LEVEL(NVDBG_LEVEL_INFO, "nvPCIAlloc - Insert new allocation block at head of allocation list. First time.");
        pAllocBlock->pPrevAllocBlock          = (PTEXHEAPHEADER)NULL;
        pAllocBlock->pNextAllocBlock          = (PTEXHEAPHEADER)NULL;
        getDC()->nvD3DTexHeapData.dwAllocHead = (unsigned long)pAllocBlock;
        getDC()->nvD3DTexHeapData.dwAllocTail = (unsigned long)pAllocBlock;

        /*
         * The tail of allocation list has changed. Check to see if the texture context
         * needs to be udpated to reflect the change.
         */
        if (getDC()->nvD3DTexHeapData.dwAllocTail) {
            dwAllocLimit = ((PTEXHEAPHEADER)getDC()->nvD3DTexHeapData.dwAllocTail)->dwBlockStartOffset +
                           ((PTEXHEAPHEADER)getDC()->nvD3DTexHeapData.dwAllocTail)->dwBlockSize - 1;
        }
        else {
            dwAllocLimit = 0;
        }
    }
    else if (pAllocBlock < (PTEXHEAPHEADER)getDC()->nvD3DTexHeapData.dwAllocHead)
    {
        DPF_LEVEL(NVDBG_LEVEL_INFO, "nvPCIAlloc - Insert new allocation block at head of allocation list.");
        ((PTEXHEAPHEADER)getDC()->nvD3DTexHeapData.dwAllocHead)->pPrevAllocBlock = pAllocBlock;
        pAllocBlock->pPrevAllocBlock          = (PTEXHEAPHEADER)NULL;
        pAllocBlock->pNextAllocBlock          = (PTEXHEAPHEADER)getDC()->nvD3DTexHeapData.dwAllocHead;
        getDC()->nvD3DTexHeapData.dwAllocHead = (unsigned long)pAllocBlock;
    }
    else if (pAllocBlock > (PTEXHEAPHEADER)getDC()->nvD3DTexHeapData.dwAllocTail)
    {
        DPF_LEVEL(NVDBG_LEVEL_INFO, "nvPCIAlloc - Insert new allocation block at tail of allocation list.");
        ((PTEXHEAPHEADER)getDC()->nvD3DTexHeapData.dwAllocTail)->pNextAllocBlock = pAllocBlock;
        pAllocBlock->pPrevAllocBlock          = (PTEXHEAPHEADER)getDC()->nvD3DTexHeapData.dwAllocTail;
        pAllocBlock->pNextAllocBlock          = (PTEXHEAPHEADER)NULL;
        getDC()->nvD3DTexHeapData.dwAllocTail = (unsigned long)pAllocBlock;

        /*
         * The tail of allocation list has changed. Check to see if the texture context
         * needs to be udpated to reflect the change.
         */
        if (getDC()->nvD3DTexHeapData.dwAllocTail) {
            dwAllocLimit = ((PTEXHEAPHEADER)getDC()->nvD3DTexHeapData.dwAllocTail)->dwBlockStartOffset +
                           ((PTEXHEAPHEADER)getDC()->nvD3DTexHeapData.dwAllocTail)->dwBlockSize - 1;
        }
        else {
            dwAllocLimit = 0;
        }
    }
    else
    {
        DPF_LEVEL(NVDBG_LEVEL_INFO, "nvPCIAlloc - Insert new allocation block in middle of allocation list.");

        /* WORST CASE
         * The newly allocated block falls between the head and tail of the allocation
         * list. Search all memory blocks following the new allocation block to find the
         * next allocated block, then just update the pointers.
         */
        pList = (PTEXHEAPHEADER)((DWORD)pAllocBlock + sizeof(TEXHEAPHEADER) + pAllocBlock->dwBlockSize);
        while ((pList) && (pList->dwTag != HEAP_TAG_ALLOC))
        {
            pList = (PTEXHEAPHEADER)((DWORD)pList + sizeof(TEXHEAPHEADER) + pList->dwBlockSize);
        }
        /*
         * This should never happen, if it does, then we've got problems.
         */
        if (!pList)
        {
            DPF_LEVEL(NVDBG_LEVEL_ERROR, "nvPCIAlloc - Error inserting new allocation block!!");
            dbgTracePop();
            return (pAllocBlock->dwBlockStartOffset);
        }

        /*
         * Update the pointers.
         */
        pAllocBlock->pPrevAllocBlock                  = pList->pPrevAllocBlock;
        pAllocBlock->pNextAllocBlock                  = pList;
        pList->pPrevAllocBlock                        = pAllocBlock;
        pAllocBlock->pPrevAllocBlock->pNextAllocBlock = pAllocBlock;
    }

    /*
     * Dump some information about the texture heap allocation.
     */
    DPF_LEVEL(NVDBG_LEVEL_INFO, "nvPCIAlloc - pAllocBlock->dwBlockStartOffset = %08x", (DWORD)pAllocBlock->dwBlockStartOffset);
    DPF_LEVEL(NVDBG_LEVEL_INFO, "nvPCIAlloc - dwSize                          = %08x", getDC()->nvD3DTexHeapData.dwSize);
    DPF_LEVEL(NVDBG_LEVEL_INFO, "nvPCIAlloc - dwLimit                         = %08x", getDC()->nvD3DTexHeapData.dwLimit);
    DPF_LEVEL(NVDBG_LEVEL_INFO, "nvPCIAlloc - dwFreeSize                      = %08x", getDC()->nvD3DTexHeapData.dwFreeSize);
    DPF_LEVEL(NVDBG_LEVEL_INFO, "nvPCIAlloc - dwAllocSize                     = %08x", getDC()->nvD3DTexHeapData.dwAllocSize);

    /*
     * Return the offset to the allocated block.
     */
    dbgTracePop();
    return (pAllocBlock->dwBlockStartOffset);
}

//-------------------------------------------------------------------------

BOOL nvPCIFree
(
    DWORD   dwFreeBlockOffset
)
{
    DWORD           dwAllocLimit;
    PTEXHEAPHEADER  pList;
    PTEXHEAPHEADER  pFreeBlock;
    PTEXHEAPHEADER  pPrevFree;
    PTEXHEAPHEADER  pNextFree;
    PTEXHEAPHEADER  pPrevAlloc;
    PTEXHEAPHEADER  pNextAlloc;

    dbgTracePush ("nvPCIFree");

    /*
     * Make sure there is a valid texture heap to free the memory from.
     */
    if (!getDC()->nvD3DTexHeapData.dwBase) {
        dbgTracePop();
        return (TRUE);
    }

    /*
     * Make sure there is actually a valid texture block to free.
     */
    if (!dwFreeBlockOffset) {
        dbgTracePop();
        return (FALSE);
    }

    /*
     * Calculate the pointer to the header of the block being freed.
     */
    pFreeBlock = (PTEXHEAPHEADER)(getDC()->nvD3DTexHeapData.dwBase + (dwFreeBlockOffset - sizeof(TEXHEAPHEADER)));
    DPF_LEVEL(NVDBG_LEVEL_INFO, "nvPCIFree - pFreeBlock->dwBlockSize = %08x", pFreeBlock->dwBlockSize);

    /*
     * Make sure we are pointer to an actual allocated block header.
     */
    if (pFreeBlock->dwTag != HEAP_TAG_ALLOC) {
        dbgTracePop();
        return (FALSE);
    }

    /*
     * Get a few pointers.
     */
    pPrevAlloc                  = pFreeBlock->pPrevAllocBlock;
    pNextAlloc                  = pFreeBlock->pNextAllocBlock;
    pFreeBlock->pPrevAllocBlock = (PTEXHEAPHEADER)NULL;
    pFreeBlock->pNextAllocBlock = (PTEXHEAPHEADER)NULL;

    /*
     * Remove the block from the allocation list.
     */
    if (pPrevAlloc)
        pPrevAlloc->pNextAllocBlock = pNextAlloc;
    else
        getDC()->nvD3DTexHeapData.dwAllocHead = (unsigned long)pNextAlloc;
    if (pNextAlloc)
        pNextAlloc->pPrevAllocBlock = pPrevAlloc;
    else
    {
        getDC()->nvD3DTexHeapData.dwAllocTail = (unsigned long)pPrevAlloc;

        /*
         * The tail of allocation list has changed. Check to see if the texture context
         * needs to be udpated to reflect the change.
         */
        if (getDC()->nvD3DTexHeapData.dwAllocTail)
            dwAllocLimit = ((PTEXHEAPHEADER)getDC()->nvD3DTexHeapData.dwAllocTail)->dwBlockStartOffset + ((PTEXHEAPHEADER)getDC()->nvD3DTexHeapData.dwAllocTail)->dwBlockSize - 1;
        else
            dwAllocLimit = 0;
    }

    /*
     * Mark the block as freed and get the size of the block.
     */
    pFreeBlock->dwTag = HEAP_TAG_FREE;

    /*
     * Update the allocation sizes.
     */
    getDC()->nvD3DTexHeapData.dwAllocSize -= pFreeBlock->dwBlockSize;
    getDC()->nvD3DTexHeapData.dwFreeSize  += pFreeBlock->dwBlockSize;

    /*
     * Insert the newly freed block into the free list.
     */
    if (!getDC()->nvD3DTexHeapData.dwFreeHead)
    {
        DPF_LEVEL(NVDBG_LEVEL_INFO, "nvPCIFree - Insert new free block at head of free list. First time.");
        pFreeBlock->pPrevFreeBlock    = (PTEXHEAPHEADER)NULL;
        pFreeBlock->pNextFreeBlock    = (PTEXHEAPHEADER)NULL;
        getDC()->nvD3DTexHeapData.dwFreeHead = (unsigned long)pFreeBlock;
        getDC()->nvD3DTexHeapData.dwFreeTail = (unsigned long)pFreeBlock;
    }
    else if (pFreeBlock < (PTEXHEAPHEADER)getDC()->nvD3DTexHeapData.dwFreeHead)
    {
        DPF_LEVEL(NVDBG_LEVEL_INFO, "nvPCIFree - Insert new free block at head of free list.");
        ((PTEXHEAPHEADER)getDC()->nvD3DTexHeapData.dwFreeHead)->pPrevFreeBlock = pFreeBlock;
        pFreeBlock->pPrevFreeBlock           = (PTEXHEAPHEADER)NULL;
        pFreeBlock->pNextFreeBlock           = (PTEXHEAPHEADER)getDC()->nvD3DTexHeapData.dwFreeHead;
        getDC()->nvD3DTexHeapData.dwFreeHead = (unsigned long)pFreeBlock;
    }
    else if (pFreeBlock > (PTEXHEAPHEADER)getDC()->nvD3DTexHeapData.dwFreeTail)
    {
        DPF_LEVEL(NVDBG_LEVEL_INFO, "nvPCIFree - Insert new free block at tail of free list.");
        ((PTEXHEAPHEADER)getDC()->nvD3DTexHeapData.dwFreeTail)->pNextFreeBlock = pFreeBlock;
        pFreeBlock->pPrevFreeBlock           = (PTEXHEAPHEADER)getDC()->nvD3DTexHeapData.dwFreeTail;
        pFreeBlock->pNextFreeBlock           = (PTEXHEAPHEADER)NULL;
        getDC()->nvD3DTexHeapData.dwFreeTail = (unsigned long)pFreeBlock;
    }
    else
    {
        DPF_LEVEL(NVDBG_LEVEL_INFO, "nvPCIFree - Insert new free block in middle of free list.");

        /* WORST CASE
         * The newly freed block falls between the head and tail of the free
         * list. Search all memory blocks following the new freed block to find the
         * next free block, then just update the pointers.
         */
        pList = (PTEXHEAPHEADER)((DWORD)pFreeBlock + sizeof(TEXHEAPHEADER) + pFreeBlock->dwBlockSize);
        while ((pList)
            && (pList->dwTag != HEAP_TAG_FREE))
        {
            pList = (PTEXHEAPHEADER)((DWORD)pList + sizeof(TEXHEAPHEADER) + pList->dwBlockSize);
        }
        /*
         * This should never happen, if it does, then we've got problems.
         */
        if (!pList)
        {
            DPF_LEVEL(NVDBG_LEVEL_ERROR, "nvPCIFree - Error inserting newly freed block!!");
            dbgTracePop();
            return (TRUE);
        }

        /*
         * Update the pointers.
         */
        pFreeBlock->pPrevFreeBlock                 = pList->pPrevFreeBlock;
        pFreeBlock->pNextFreeBlock                 = pList;
        pList->pPrevFreeBlock                      = pFreeBlock;
        pFreeBlock->pPrevFreeBlock->pNextFreeBlock = pFreeBlock;
    }

    /*
     * Do some basic garbage collection to try and consolidate contiguous free
     * blocks.
     */
    pPrevFree = pFreeBlock->pPrevFreeBlock;
    pNextFree = pFreeBlock->pNextFreeBlock;

    if ((pPrevFree)
     && (((DWORD)pPrevFree + sizeof(TEXHEAPHEADER) + pPrevFree->dwBlockSize) == (DWORD)pFreeBlock))
    {
        /*
         * Merge the previous free block with the new free block.
         */
        pPrevFree->dwBlockSize += sizeof(TEXHEAPHEADER) + pFreeBlock->dwBlockSize;
        if (pPrevFree->pNextFreeBlock = pNextFree) {
            pNextFree->pPrevFreeBlock = pPrevFree;
        }
        else {
            getDC()->nvD3DTexHeapData.dwFreeTail = (unsigned long)pPrevFree;
        }

        /*
         * Clean out the old free block header.
         */
        pFreeBlock->dwTag              = 0;
        pFreeBlock->dwBlockSize        = 0;
        pFreeBlock->dwBlockStartOffset = 0;
        pFreeBlock->pPrevFreeBlock     = (PTEXHEAPHEADER)NULL;
        pFreeBlock->pNextFreeBlock     = (PTEXHEAPHEADER)NULL;
        pFreeBlock->pPrevAllocBlock    = (PTEXHEAPHEADER)NULL;
        pFreeBlock->pNextAllocBlock    = (PTEXHEAPHEADER)NULL;

        /*
         * Update the free block pointer to point to the new consolidated block.
         */
        pFreeBlock = pPrevFree;
    }

    if ((pNextFree)
     && (((DWORD)pFreeBlock + sizeof(TEXHEAPHEADER) + pFreeBlock->dwBlockSize) == (DWORD)pNextFree))
    {
        /*
         * Merge the new free block with the next free block.
         */
        pFreeBlock->dwBlockSize += sizeof(TEXHEAPHEADER) + pNextFree->dwBlockSize;
        if (pFreeBlock->pNextFreeBlock = pNextFree->pNextFreeBlock)
            pNextFree->pNextFreeBlock->pPrevFreeBlock = pFreeBlock;
        else
            getDC()->nvD3DTexHeapData.dwFreeTail = (unsigned long)pFreeBlock;

        /*
         * Clean out the old free block header.
         */
        pNextFree->dwTag              = 0;
        pNextFree->dwBlockSize        = 0;
        pNextFree->dwBlockStartOffset = 0;
        pNextFree->pPrevFreeBlock     = (PTEXHEAPHEADER)NULL;
        pNextFree->pNextFreeBlock     = (PTEXHEAPHEADER)NULL;
        pNextFree->pPrevAllocBlock    = (PTEXHEAPHEADER)NULL;
        pNextFree->pNextAllocBlock    = (PTEXHEAPHEADER)NULL;
    }

    /*
     * Dump some information about the texture heap allocation.
     */
    DPF_LEVEL(NVDBG_LEVEL_INFO, "nvPCIFree - dwSize      = %08x", getDC()->nvD3DTexHeapData.dwSize);
    DPF_LEVEL(NVDBG_LEVEL_INFO, "nvPCIFree - dwLimit     = %08x", getDC()->nvD3DTexHeapData.dwLimit);
    DPF_LEVEL(NVDBG_LEVEL_INFO, "nvPCIFree - dwFreeSize  = %08x", getDC()->nvD3DTexHeapData.dwFreeSize);
    DPF_LEVEL(NVDBG_LEVEL_INFO, "nvPCIFree - dwAllocSize = %08x", getDC()->nvD3DTexHeapData.dwAllocSize);

    /*
     * Return successfully.
     */
    dbgTracePop();
    return (TRUE);
}

//-------------------------------------------------------------------------

#ifdef NV_TRACKAGP

#undef DDHAL32_VidMemAlloc
#undef DDHAL32_VidMemFree

FLATPTR EXTERN_DDAPI DDHAL32_VidMemAlloc (LPDDRAWI_DIRECTDRAW_GBL pdrv, int heap, DWORD dwXDim, DWORD dwYDim);
void EXTERN_DDAPI DDHAL32_VidMemFree (LPDDRAWI_DIRECTDRAW_GBL pdrv, int heap, FLATPTR ptr);

typedef struct
{
    FLATPTR ptr;
    DWORD size;
} TABLE;

static TABLE *lpTable = NULL;
static DWORD dwMax    = 0;
static DWORD dwTotal  = 0;

//-------------------------------------------------------------------------

FLATPTR EXTERN_DDAPI __DDHAL32_VidMemAlloc
(
    LPDDRAWI_DIRECTDRAW_GBL pdrv,
    int heap,
    DWORD dwXDim,
    DWORD dwYDim
)
{
    dbgTracePush ("__DDHAL32_VidMemAlloc");

    FLATPTR ptr = DDHAL32_VidMemAlloc (pdrv, heap, dwXDim, dwYDim);

    if (ptr && (heap == AGP_HEAP))
    {
        DWORD i;

        dwTotal += dwXDim * dwYDim;
        DPF ("a %d", dwTotal);

        for (i = 0; i < dwMax; i++)
        {
            if (lpTable[i].ptr == (FLATPTR)NULL)
            {
                lpTable[i].ptr = ptr;
                lpTable[i].size = dwXDim * dwYDim;
                dbgTracePop();
                return ptr;
            }
        }
        dwMax += 128;
        lpTable = (TABLE*)ReallocIPM(lpTable, dwMax * sizeof(TABLE));
        lpTable[i].ptr = ptr;
        lpTable[i].size = dwXDim * dwYDim;
        dbgTracePop();
        return ptr;
    }

    dbgTracePop();
    return ptr;
}

//-------------------------------------------------------------------------

void EXTERN_DDAPI __DDHAL32_VidMemFree
(
    LPDDRAWI_DIRECTDRAW_GBL pdrv,
    int heap,
    FLATPTR ptr
)
{
    dbgTracePush ("__DDHAL32_VidMemFree");

    if (heap == AGP_HEAP)
    {
        DWORD i;

        for (i = 0; i<dwMax; i++)
        {
            if (lpTable[i].ptr == ptr)
            {
                dwTotal -= lpTable[i].size;
                lpTable[i].ptr = (FLATPTR)NULL;

                DPF ("f %d", dwTotal);

                DDHAL32_VidMemFree (pdrv, heap, ptr);
                dbgTracePop();
                return;
            }
        }

        // should not get here
        __asm int 3;
    }

    DDHAL32_VidMemFree (pdrv, heap, ptr);
    dbgTracePop();
}

//-------------------------------------------------------------------------

void __Reset (void)
{
    dbgTracePush ("__Reset");

    FreeIPM (lpTable);
    lpTable = NULL;
    dwTotal = dwMax = 0;
    DPF ("reset");

    dbgTracePop();
}

#endif //NV_TRACKAGP

#endif  // NVARCH >= 0x04
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\ddraw\common\src\d3dMath.cpp ===
/*
 * Copyright 1993-1998 NVIDIA, Corporation.  All rights reserved.
 *
 * THE INFORMATION CONTAINED HEREIN IS PROPRIETARY AND CONFIDENTIAL TO
 * NVIDIA, CORPORATION.  USE, REPRODUCTION OR DISCLOSURE TO ANY THIRD PARTY
 * IS SUBJECT TO WRITTEN PRE-APPROVAL BY NVIDIA, CORPORATION.
 */

/********************************* Direct 3D *******************************\
*                                                                           *
* Module: d3dMath.cpp                                                       *
*     matrix, vector, and other math routines                               *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*       Craig Duttweiler    (bertrem)   09Sep99     created                 *
*                                                                           *
\***************************************************************************/
#include "nvprecomp.h"

#if (NVARCH >= 0x04)

#include "x86.h"

//---------------------------------------------------------------------------

// returns  1 / sqrt(x)

static float _0_47 = 0.47f;
static float _1_47 = 1.47f;

float __fastcall JBInvSqrt (const float x)
{
    DWORD y;
    float r;

    _asm
    {
        mov     eax, 07F000000h+03F800000h  // (ONE_AS_INTEGER<<1) + ONE_AS_INTEGER
        sub     eax, x
        sar     eax, 1

        mov     y, eax                      // y
        fld     _0_47                       // 0.47
        fmul    DWORD PTR x                 // x*0.47

        fld     DWORD PTR y
        fld     st(0)                       // y y x*0.47
        fmul    st(0), st(1)                // y*y y x*0.47

        fld     _1_47                       // 1.47 y*y y x*0.47
        fxch    st(3)                       // x*0.47 y*y y 1.47
        fmulp   st(1), st(0)                // x*0.47*y*y y 1.47
        fsubp   st(2), st(0)                // y 1.47-x*0.47*y*y
        fmulp   st(1), st(0)                // result
        fstp    y
    }

    y &= 0x7FFFFFFF;  // make it positive
    r = FLOAT_FROM_DWORD(y);

    // optional
    r = (3.0f - x * (r * r)) * r * 0.5f;    // remove for low accuracy

    return (r);
}

//---------------------------------------------------------------------------

//  sqrt(x) = x * (1/sqrt(x))

float __fastcall nvSqrt (float x)
{
    return (x*JBInvSqrt(x));
}

//---------------------------------------------------------------------------

//  1/x = 1 / sqrt(x*x) plus sign bit

float __fastcall nvInv (float x)
{
    DWORD dwSign = *(DWORD *)&x & 0x80000000;
    float invSqRt = JBInvSqrt (x*x);
    DWORD dwInv = dwSign | *(DWORD *)&invSqRt;
    return (FLOAT_FROM_DWORD(dwInv));
}

//---------------------------------------------------------------------------

// reverse a 3-component vector

void __fastcall ReverseVector3 (D3DVECTOR *out, D3DVECTOR *in)
{
    out->x = -(in->x);
    out->y = -(in->y);
    out->z = -(in->z);
}

//---------------------------------------------------------------------------

// scale a 3-component vector

void __fastcall ScaleVector3 (D3DVECTOR *out, D3DVECTOR *v1, D3DVALUE scale)
{
    out->x = scale * v1->x;
    out->y = scale * v1->y;
    out->z = scale * v1->z;
}

//---------------------------------------------------------------------------

// add two 3-component vectors

void __fastcall AddVectors3 (D3DVECTOR *out, D3DVECTOR *v1, D3DVECTOR *v2)
{
    out->x = v1->x + v2->x;
    out->y = v1->y + v2->y;
    out->z = v1->z + v2->z;
}

//---------------------------------------------------------------------------

// subtract two 3-component vectors

void __fastcall SubtractVectors3 (D3DVECTOR *out, D3DVECTOR *v1, D3DVECTOR *v2)
{
    out->x = v1->x - v2->x;
    out->y = v1->y - v2->y;
    out->z = v1->z - v2->z;
}

//---------------------------------------------------------------------------

// return the square of the magnitude of a 3-component vectors

D3DVALUE __fastcall SquareMagnitude3 (D3DVECTOR *v)
{
    return (v->x*v->x + v->y*v->y + v->z*v->z);
}

//---------------------------------------------------------------------------

// return the magnitude of a 3-component vector

D3DVALUE __fastcall Magnitude3 (D3DVECTOR *v)
{
    return (D3DVALUE) nvSqrt(SquareMagnitude3(v));
}

//---------------------------------------------------------------------------

// normalize a 3-component vector

void __fastcall NormalizeVector3 (D3DVECTOR *v)
{
    D3DVALUE invmag = JBInvSqrt (SquareMagnitude3(v));
    nvAssert (invmag > 0);
    v->x *= invmag;
    v->y *= invmag;
    v->z *= invmag;
}

//---------------------------------------------------------------------------

// dot product of a 3-component vector

D3DVALUE __fastcall DotProduct3 (D3DVECTOR *v1, D3DVECTOR *v2)
{
    return (v1->x*v2->x + v1->y*v2->y + v1->z*v2->z);
}

//---------------------------------------------------------------------------

// Multiplies row vector [v.x v.y v.z w] by 4x3 matrix m
// res and v should not be the same

void __fastcall XformBy4x3 (D3DVECTOR *res, D3DVECTOR *v, D3DVALUE w, D3DMATRIX *m)
{
    nvAssert (res != v);
    res->x = v->x*m->_11 + v->y*m->_21 + v->z*m->_31 + w*m->_41;
    res->y = v->x*m->_12 + v->y*m->_22 + v->z*m->_32 + w*m->_42;
    res->z = v->x*m->_13 + v->y*m->_23 + v->z*m->_33 + w*m->_43;
}

//---------------------------------------------------------------------------

// Multiplies vector (x,y,z) by 3x3 matrix
// res and v should not be the same

void __fastcall XformVector3 (D3DVECTOR *res, D3DVECTOR *v, D3DMATRIX *m)
{
    nvAssert (res != v);
    res->x = v->x*m->_11 + v->y*m->_21 + v->z*m->_31;
    res->y = v->x*m->_12 + v->y*m->_22 + v->z*m->_32;
    res->z = v->x*m->_13 + v->y*m->_23 + v->z*m->_33;
}

//---------------------------------------------------------------------------

// Multiplies vector (x,y,z,w) by 4x4 matrix
// res and v should not be the same

void __fastcall XformVector4 (D3DVALUE *res, D3DVALUE *v, D3DMATRIX *m)
{
    nvAssert (res != v);
    res[0] = v[0]*m->_11 + v[1]*m->_21 + v[2]*m->_31 + v[3]*m->_41;
    res[1] = v[0]*m->_12 + v[1]*m->_22 + v[2]*m->_32 + v[3]*m->_42;
    res[2] = v[0]*m->_13 + v[1]*m->_23 + v[2]*m->_33 + v[3]*m->_43;
    res[3] = v[0]*m->_14 + v[1]*m->_24 + v[2]*m->_34 + v[3]*m->_44;
}

//---------------------------------------------------------------------------

void __fastcall MatrixProduct3x3 (D3DMATRIX *res, D3DMATRIX *a, D3DMATRIX *b)
{
    res->_11 = a->_11*b->_11 + a->_12*b->_21 + a->_13*b->_31;
    res->_12 = a->_11*b->_12 + a->_12*b->_22 + a->_13*b->_32;
    res->_13 = a->_11*b->_13 + a->_12*b->_23 + a->_13*b->_33;

    res->_21 = a->_21*b->_11 + a->_22*b->_21 + a->_23*b->_31;
    res->_22 = a->_21*b->_12 + a->_22*b->_22 + a->_23*b->_32;
    res->_23 = a->_21*b->_13 + a->_22*b->_23 + a->_23*b->_33;

    res->_31 = a->_31*b->_11 + a->_32*b->_21 + a->_33*b->_31;
    res->_32 = a->_31*b->_12 + a->_32*b->_22 + a->_33*b->_32;
    res->_33 = a->_31*b->_13 + a->_32*b->_23 + a->_33*b->_33;
}

//---------------------------------------------------------------------------

void __fastcall MatrixProduct4x4 (D3DMATRIX *res, D3DMATRIX *a, D3DMATRIX *b)
{
    res->_11 = a->_11*b->_11 + a->_12*b->_21 + a->_13*b->_31 + a->_14*b->_41;
    res->_12 = a->_11*b->_12 + a->_12*b->_22 + a->_13*b->_32 + a->_14*b->_42;
    res->_13 = a->_11*b->_13 + a->_12*b->_23 + a->_13*b->_33 + a->_14*b->_43;
    res->_14 = a->_11*b->_14 + a->_12*b->_24 + a->_13*b->_34 + a->_14*b->_44;

    res->_21 = a->_21*b->_11 + a->_22*b->_21 + a->_23*b->_31 + a->_24*b->_41;
    res->_22 = a->_21*b->_12 + a->_22*b->_22 + a->_23*b->_32 + a->_24*b->_42;
    res->_23 = a->_21*b->_13 + a->_22*b->_23 + a->_23*b->_33 + a->_24*b->_43;
    res->_24 = a->_21*b->_14 + a->_22*b->_24 + a->_23*b->_34 + a->_24*b->_44;

    res->_31 = a->_31*b->_11 + a->_32*b->_21 + a->_33*b->_31 + a->_34*b->_41;
    res->_32 = a->_31*b->_12 + a->_32*b->_22 + a->_33*b->_32 + a->_34*b->_42;
    res->_33 = a->_31*b->_13 + a->_32*b->_23 + a->_33*b->_33 + a->_34*b->_43;
    res->_34 = a->_31*b->_14 + a->_32*b->_24 + a->_33*b->_34 + a->_34*b->_44;

    res->_41 = a->_41*b->_11 + a->_42*b->_21 + a->_43*b->_31 + a->_44*b->_41;
    res->_42 = a->_41*b->_12 + a->_42*b->_22 + a->_43*b->_32 + a->_44*b->_42;
    res->_43 = a->_41*b->_13 + a->_42*b->_23 + a->_43*b->_33 + a->_44*b->_43;
    res->_44 = a->_41*b->_14 + a->_42*b->_24 + a->_43*b->_34 + a->_44*b->_44;
}

//---------------------------------------------------------------------------

// transpose a 4x4 matrix. res and m should not be the same.

void __fastcall MatrixTranspose4x4 (D3DMATRIX *res, D3DMATRIX *m)
{
    assert (res != m);

    res->_11 = m->_11;
    res->_12 = m->_21;
    res->_13 = m->_31;
    res->_14 = m->_41;

    res->_21 = m->_12;
    res->_22 = m->_22;
    res->_23 = m->_32;
    res->_24 = m->_42;

    res->_31 = m->_13;
    res->_32 = m->_23;
    res->_33 = m->_33;
    res->_34 = m->_43;

    res->_41 = m->_14;
    res->_42 = m->_24;
    res->_43 = m->_34;
    res->_44 = m->_44;
}

//---------------------------------------------------------------------------

// This function uses Cramer's Rule to calculate the inverse of a 3x3 matrix
// (or the upper 3x3 portion of a larger matrix)
//
// Returns:
//    0 - if success
//   -1 - if input matrix is singular

#define DETERMINANT(m, r1, r2, c1, c2) (m->_##r1##c1 * m->_##r2##c2 - m->_##r1##c2 * m->_##r2##c1)

int __fastcall Inverse3x3 (D3DMATRIX *inverse, D3DMATRIX *src, BOOL bNormalize)
{
    float b11,b12,b13;
    float b21,b22,b23;
    float b31,b32,b33;
    float det, idet;
    DWORD dwSign;

    b11 =  DETERMINANT(src, 2,3,2,3);
    b12 = -DETERMINANT(src, 2,3,1,3);
    b13 =  DETERMINANT(src, 2,3,1,2);
    b21 = -DETERMINANT(src, 1,3,2,3);
    b22 =  DETERMINANT(src, 1,3,1,3);
    b23 = -DETERMINANT(src, 1,3,1,2);
    b31 =  DETERMINANT(src, 1,2,2,3);
    b32 = -DETERMINANT(src, 1,2,1,3);
    b33 =  DETERMINANT(src, 1,2,1,2);

    // compute 3x3 determinant
    det = (src->_11 * b11) + (src->_12 * b12) + (src->_13 * b13);
    if (det == 0.0) {
        return (-1);
    }

    if (bNormalize) {
        // get the reciprocal of the determinant
        // and multiply all 3x3 cofactors by it
        idet = nvInv (det);
        inverse->_11 = (D3DVALUE) (idet * b11);
        inverse->_12 = (D3DVALUE) (idet * b21);
        inverse->_13 = (D3DVALUE) (idet * b31);
        inverse->_21 = (D3DVALUE) (idet * b12);
        inverse->_22 = (D3DVALUE) (idet * b22);
        inverse->_23 = (D3DVALUE) (idet * b32);
        inverse->_31 = (D3DVALUE) (idet * b13);
        inverse->_32 = (D3DVALUE) (idet * b23);
        inverse->_33 = (D3DVALUE) (idet * b33);
    }

    else {
        // just get the sign of the determinant and multiply all
        // cofactors by that. since we're not normalizing, we don't
        // care about the magnitude, but we do care about the sense.
        dwSign = FP_SIGN_BIT(det);
        DWORD_FROM_FLOAT(b11) ^= dwSign;
        inverse->_11 = (D3DVALUE) (b11);
        DWORD_FROM_FLOAT(b21) ^= dwSign;
        inverse->_12 = (D3DVALUE) (b21);
        DWORD_FROM_FLOAT(b31) ^= dwSign;
        inverse->_13 = (D3DVALUE) (b31);
        DWORD_FROM_FLOAT(b12) ^= dwSign;
        inverse->_21 = (D3DVALUE) (b12);
        DWORD_FROM_FLOAT(b22) ^= dwSign;
        inverse->_22 = (D3DVALUE) (b22);
        DWORD_FROM_FLOAT(b32) ^= dwSign;
        inverse->_23 = (D3DVALUE) (b32);
        DWORD_FROM_FLOAT(b13) ^= dwSign;
        inverse->_31 = (D3DVALUE) (b13);
        DWORD_FROM_FLOAT(b23) ^= dwSign;
        inverse->_32 = (D3DVALUE) (b23);
        DWORD_FROM_FLOAT(b33) ^= dwSign;
        inverse->_33 = (D3DVALUE) (b33);
    }

    return (0);
}

//---------------------------------------------------------------------------

// This function uses Cramer's Rule to calculate the matrix inverse.
//
// Returns:
//    0 - if success
//   -1 - if input matrix is singular

int __fastcall Inverse4x4 (D3DMATRIX *inverse, D3DMATRIX *src, BOOL bNormalize)
{
    float x00, x01, x02;
    float x10, x11, x12;
    float x20, x21, x22;
    float x30, x31, x32;
    float rcp;
    float y01, y02, y03, y12, y13, y23;
    float z02, z03, z12, z13, z22, z23, z32, z33;
    DWORD  dwSign;

#define x03 x01
#define x13 x11
#define x23 x21
#define x33 x31
#define z00 x02
#define z10 x12
#define z20 x22
#define z30 x32
#define z01 x03
#define z11 x13
#define z21 x23
#define z31 x33

    /* read 1st two columns of matrix into registers */
    x00 = src->_11;
    x01 = src->_12;
    x10 = src->_21;
    x11 = src->_22;
    x20 = src->_31;
    x21 = src->_32;
    x30 = src->_41;
    x31 = src->_42;

    /* compute all six 2x2 determinants of 1st two columns */
    y01 = x00*x11 - x10*x01;
    y02 = x00*x21 - x20*x01;
    y03 = x00*x31 - x30*x01;
    y12 = x10*x21 - x20*x11;
    y13 = x10*x31 - x30*x11;
    y23 = x20*x31 - x30*x21;

    /* read 2nd two columns of matrix into registers */
    x02 = src->_13;
    x03 = src->_14;
    x12 = src->_23;
    x13 = src->_24;
    x22 = src->_33;
    x23 = src->_34;
    x32 = src->_43;
    x33 = src->_44;

    /* compute all 3x3 cofactors for 2nd two columns */
    z33 = x02*y12 - x12*y02 + x22*y01;
    z23 = x12*y03 - x32*y01 - x02*y13;
    z13 = x02*y23 - x22*y03 + x32*y02;
    z03 = x22*y13 - x32*y12 - x12*y23;
    z32 = x13*y02 - x23*y01 - x03*y12;
    z22 = x03*y13 - x13*y03 + x33*y01;
    z12 = x23*y03 - x33*y02 - x03*y23;
    z02 = x13*y23 - x23*y13 + x33*y12;

    /* compute all six 2x2 determinants of 2nd two columns */
    y01 = x02*x13 - x12*x03;
    y02 = x02*x23 - x22*x03;
    y03 = x02*x33 - x32*x03;
    y12 = x12*x23 - x22*x13;
    y13 = x12*x33 - x32*x13;
    y23 = x22*x33 - x32*x23;

    /* read 1st two columns of matrix into registers */
    x00 = src->_11;
    x01 = src->_12;
    x10 = src->_21;
    x11 = src->_22;
    x20 = src->_31;
    x21 = src->_32;
    x30 = src->_41;
    x31 = src->_42;

    /* compute all 3x3 cofactors for 1st column */
    z30 = x11*y02 - x21*y01 - x01*y12;
    z20 = x01*y13 - x11*y03 + x31*y01;
    z10 = x21*y03 - x31*y02 - x01*y23;
    z00 = x11*y23 - x21*y13 + x31*y12;

    /* compute all 3x3 cofactors for 2nd column */
    z31 = x00*y12 - x10*y02 + x20*y01;
    z21 = x10*y03 - x30*y01 - x00*y13;
    z11 = x00*y23 - x20*y03 + x30*y02;
    z01 = x20*y13 - x30*y12 - x10*y23;

    // compute 4x4 determinant
    rcp = x30*z30 + x20*z20 + x10*z10 + x00*z00;
    if (rcp == 0.f) return (-1);

    if (bNormalize) {
        // get the reciprocal of the determinant
        // and multiply all 3x3 cofactors by it
        rcp = nvInv (rcp);
        inverse->_11 = z00*rcp;
        inverse->_21 = z01*rcp;
        inverse->_12 = z10*rcp;
        inverse->_31 = z02*rcp;
        inverse->_13 = z20*rcp;
        inverse->_41 = z03*rcp;
        inverse->_14 = z30*rcp;
        inverse->_22 = z11*rcp;
        inverse->_32 = z12*rcp;
        inverse->_23 = z21*rcp;
        inverse->_42 = z13*rcp;
        inverse->_24 = z31*rcp;
        inverse->_33 = z22*rcp;
        inverse->_43 = z23*rcp;
        inverse->_34 = z32*rcp;
        inverse->_44 = z33*rcp;
    }

    else {
        // just get the sign of the determinant and multiply all
        // cofactors by that. since we're not normalizing, we don't
        // care about the magnitude, but we do care about the sense.
        dwSign = FP_SIGN_BIT(rcp);
        DWORD_FROM_FLOAT(z00) ^= dwSign;
        inverse->_11 = z00;
        DWORD_FROM_FLOAT(z01) ^= dwSign;
        inverse->_21 = z01;
        DWORD_FROM_FLOAT(z10) ^= dwSign;
        inverse->_12 = z10;
        DWORD_FROM_FLOAT(z02) ^= dwSign;
        inverse->_31 = z02;
        DWORD_FROM_FLOAT(z20) ^= dwSign;
        inverse->_13 = z20;
        DWORD_FROM_FLOAT(z03) ^= dwSign;
        inverse->_41 = z03;
        DWORD_FROM_FLOAT(z30) ^= dwSign;
        inverse->_14 = z30;
        DWORD_FROM_FLOAT(z11) ^= dwSign;
        inverse->_22 = z11;
        DWORD_FROM_FLOAT(z12) ^= dwSign;
        inverse->_32 = z12;
        DWORD_FROM_FLOAT(z21) ^= dwSign;
        inverse->_23 = z21;
        DWORD_FROM_FLOAT(z13) ^= dwSign;
        inverse->_42 = z13;
        DWORD_FROM_FLOAT(z31) ^= dwSign;
        inverse->_24 = z31;
        DWORD_FROM_FLOAT(z22) ^= dwSign;
        inverse->_33 = z22;
        DWORD_FROM_FLOAT(z23) ^= dwSign;
        inverse->_43 = z23;
        DWORD_FROM_FLOAT(z32) ^= dwSign;
        inverse->_34 = z32;
        DWORD_FROM_FLOAT(z33) ^= dwSign;
        inverse->_44 = z33;
    }

    return (0);

#undef x03
#undef x13
#undef x23
#undef x33
#undef z00
#undef z10
#undef z20
#undef z30
#undef z01
#undef z11
#undef z21
#undef z31

}

// More accurate matrix inversion. The reciprocal of the determinant computed by Inverse4x4
// is often really, really bad.
int __fastcall STInverse4x4 (D3DMATRIX *inverse, D3DMATRIX *src)
{
    float x00, x01, x02;
    float x10, x11, x12;
    float x20, x21, x22;
    float x30, x31, x32;
    float rcp;
    float y01, y02, y03, y12, y13, y23;
    float z02, z03, z12, z13, z22, z23, z32, z33;

#define x03 x01
#define x13 x11
#define x23 x21
#define x33 x31
#define z00 x02
#define z10 x12
#define z20 x22
#define z30 x32
#define z01 x03
#define z11 x13
#define z21 x23
#define z31 x33

    /* read 1st two columns of matrix into registers */
    x00 = src->_11;
    x01 = src->_12;
    x10 = src->_21;
    x11 = src->_22;
    x20 = src->_31;
    x21 = src->_32;
    x30 = src->_41;
    x31 = src->_42;

    /* compute all six 2x2 determinants of 1st two columns */
    y01 = x00*x11 - x10*x01;
    y02 = x00*x21 - x20*x01;
    y03 = x00*x31 - x30*x01;
    y12 = x10*x21 - x20*x11;
    y13 = x10*x31 - x30*x11;
    y23 = x20*x31 - x30*x21;

    /* read 2nd two columns of matrix into registers */
    x02 = src->_13;
    x03 = src->_14;
    x12 = src->_23;
    x13 = src->_24;
    x22 = src->_33;
    x23 = src->_34;
    x32 = src->_43;
    x33 = src->_44;

    /* compute all 3x3 cofactors for 2nd two columns */
    z33 = x02*y12 - x12*y02 + x22*y01;
    z23 = x12*y03 - x32*y01 - x02*y13;
    z13 = x02*y23 - x22*y03 + x32*y02;
    z03 = x22*y13 - x32*y12 - x12*y23;
    z32 = x13*y02 - x23*y01 - x03*y12;
    z22 = x03*y13 - x13*y03 + x33*y01;
    z12 = x23*y03 - x33*y02 - x03*y23;
    z02 = x13*y23 - x23*y13 + x33*y12;

    /* compute all six 2x2 determinants of 2nd two columns */
    y01 = x02*x13 - x12*x03;
    y02 = x02*x23 - x22*x03;
    y03 = x02*x33 - x32*x03;
    y12 = x12*x23 - x22*x13;
    y13 = x12*x33 - x32*x13;
    y23 = x22*x33 - x32*x23;

    /* read 1st two columns of matrix into registers */
    x00 = src->_11;
    x01 = src->_12;
    x10 = src->_21;
    x11 = src->_22;
    x20 = src->_31;
    x21 = src->_32;
    x30 = src->_41;
    x31 = src->_42;

    /* compute all 3x3 cofactors for 1st column */
    z30 = x11*y02 - x21*y01 - x01*y12;
    z20 = x01*y13 - x11*y03 + x31*y01;
    z10 = x21*y03 - x31*y02 - x01*y23;
    z00 = x11*y23 - x21*y13 + x31*y12;

    /* compute all 3x3 cofactors for 2nd column */
    z31 = x00*y12 - x10*y02 + x20*y01;
    z21 = x10*y03 - x30*y01 - x00*y13;
    z11 = x00*y23 - x20*y03 + x30*y02;
    z01 = x20*y13 - x30*y12 - x10*y23;

    // compute 4x4 determinant
    rcp = x30*z30 + x20*z20 + x10*z10 + x00*z00;
    if (rcp == 0.f) return (-1);

    // get the reciprocal of the determinant
    // and multiply all 3x3 cofactors by it
    rcp = 1.0f / rcp;
    inverse->_11 = z00*rcp;
    inverse->_21 = z01*rcp;
    inverse->_12 = z10*rcp;
    inverse->_31 = z02*rcp;
    inverse->_13 = z20*rcp;
    inverse->_41 = z03*rcp;
    inverse->_14 = z30*rcp;
    inverse->_22 = z11*rcp;
    inverse->_32 = z12*rcp;
    inverse->_23 = z21*rcp;
    inverse->_42 = z13*rcp;
    inverse->_24 = z31*rcp;
    inverse->_33 = z22*rcp;
    inverse->_43 = z23*rcp;
    inverse->_34 = z32*rcp;
    inverse->_44 = z33*rcp;

    return (0);

#undef x03
#undef x13
#undef x23
#undef x33
#undef z00
#undef z10
#undef z20
#undef z30
#undef z01
#undef z11
#undef z21
#undef z31

}

//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
// helper routines ///////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////

void nvComputeBoundingBox
(
    BYTE  *pVertices,
    DWORD  dwCount,
    DWORD  dwVertexStride,
    float *pafMinMaxInfo        // 6 floats, x,y,z min; x,y,z max
)
{
    if (!dwCount)
    {
        pafMinMaxInfo[0] = pafMinMaxInfo[1]
                         = pafMinMaxInfo[2]
                         = pafMinMaxInfo[3]
                         = pafMinMaxInfo[4]
                         = pafMinMaxInfo[5]
                         = 0.0f;
        return;
    }

    //
    // todo - use SIMD for AMD and KNI
    //
    pafMinMaxInfo[0] = +1e37f;
    pafMinMaxInfo[1] = +1e37f;
    pafMinMaxInfo[2] = +1e37f;
    pafMinMaxInfo[3] = -1e37f;
    pafMinMaxInfo[4] = -1e37f;
    pafMinMaxInfo[5] = -1e37f;
    while (dwCount)
    {
        float x = *(float*)(pVertices + 0);
        float y = *(float*)(pVertices + 4);
        float z = *(float*)(pVertices + 8);

        if (x < pafMinMaxInfo[0]) pafMinMaxInfo[0] = x;
        if (y < pafMinMaxInfo[1]) pafMinMaxInfo[1] = y;
        if (z < pafMinMaxInfo[2]) pafMinMaxInfo[2] = z;

        if (x > pafMinMaxInfo[3]) pafMinMaxInfo[3] = x;
        if (y > pafMinMaxInfo[4]) pafMinMaxInfo[4] = y;
        if (z > pafMinMaxInfo[5]) pafMinMaxInfo[5] = z;

        pVertices += dwVertexStride;
        dwCount--;
    }
}

//////////////////////////////////////////////////////////////////////////////

#define X pfVerticesOut[0]
#define Y pfVerticesOut[1]
#define Z pfVerticesOut[2]
#define W pfVerticesOut[3]

void nvComputeXfmAndOutCodes
(
    D3DMATRIX *pXfm,
    float     *pfVerticesIn,
    float     *pfVerticesOut,
    DWORD      dwCount,
    DWORD     *pdwOutCodes
)
{
    //
    // todo - use SIMD for AMD and KNI
    //
    while (dwCount)
    {
        // xfm
        XformVector4 (pfVerticesOut,pfVerticesIn,pXfm);

        // outcodes
        DWORD dwOutCode = 0;
        if (X < -W) dwOutCode |= 1;
        if (X >  W) dwOutCode |= 2;
        if (Y < -W) dwOutCode |= 4;
        if (Y >  W) dwOutCode |= 8;
        if (Z <  0) dwOutCode |= 16;
        if (Z >  W) dwOutCode |= 32;
        *pdwOutCodes = dwOutCode;

        // next
        pfVerticesIn  += 4;
        pfVerticesOut += 4;
        pdwOutCodes   ++;
        dwCount       --;
    }
}

#undef X
#undef Y
#undef Z
#undef W

//////////////////////////////////////////////////////////////////////////////


#endif  // (NVARCH >= 0x04)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\ddraw\common\src\d3dMini.cpp ===
/*
 * Copyright (C) 1995 Microsoft Corporation.  All Rights Reserved.
 * (C) Copyright NVIDIA Corporation Inc., 1996,1997. All rights reserved.
 */
/********************************* Direct 3D *******************************\
*                                                                           *
* Module: d3dMini.cpp                                                       *
*   The Direct3D HAL driver routines are implemented in this module.        *
*   This file is a hardware independant file.                               *
*   DO NOT PUT HARDWARE SPECIFIC CODE IN THIS FILE                          *
*   Hardware specific code can be found in:                                 *
*   nv3mini.c, nv4mini.c, ...                                               *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*       Charles Inman (chasi)       01/02/97 - re-wrote and cleaned up.     *
*       Charles Inman               01/31/98 - Ported for NV4               *
*                                                                           *
\***************************************************************************/
#include "nvprecomp.h"

#if (NVARCH >= 0x04)

/*
 * Direct3D HAL Callback Table.
 */
static D3DHAL_CALLBACKS NvD3DHALCallbacks =
{
    sizeof(D3DHAL_CALLBACKS),
    /*
     * Device context
     */
    nvContextCreate,            /* Required. */
    nvContextDestroy,           /* Required. */
    nvContextDestroyAll,        /* Required. */
    /*
     * Scene capture
     */
    nvSceneCapture,             /* Optional. */
    /*
     * Execution
     */
    0,                          /* Optional. Not needed if only rasterization */
    0,
#ifdef WINNT                    // must be at least DX7 and these calls are therefore obsolete
    0L,
    0L,
#else
    nvRenderState,              /* Required if no Execute */
    nvRenderPrimitive,          /* Required if no Execute */
#endif
    0L,                         /* Reserved, must be zero */
    /*
     * Textures
     */
    nvTextureCreate,            /* If any of these calls are supported, */
    nvTextureDestroy,           /* they must all be. */
    nvTextureSwap,              /* ditto - but can always fail. */
    nvTextureGetSurf,           /* ditto - but can always fail. */
    /*
     * Transform - must be supported if lighting is supported.
     */
    0,                          /* If any of these calls are supported, */
    0,                          /* they must all be. */
    0,                          /* ditto */
    0,                          /* ditto */
    0,                          /* ditto */
    /*
     * Lighting
     */
    0,                          /* If any of these calls are supported, */
    0,                          /* they must all be. */
    0,                          /* ditto */
    0,                          /* ditto */
    0,                          /* ditto */
    /*
     * Pipeline state
     */
#ifdef WINNT                    // must be at least DX7 and these calls are therefore obsolete
    0,
#else
    nvGetState,                 /* Required if implementing Execute. */
#endif // !WINNT
    /*
     * Reserved
     */
    0L,                         /* Reserved, must be zero */
    0L,                         /* Reserved, must be zero */
    0L,                         /* Reserved, must be zero */
    0L,                         /* Reserved, must be zero */
    0L,                         /* Reserved, must be zero */
    0L,                         /* Reserved, must be zero */
    0L,                         /* Reserved, must be zero */
    0L,                         /* Reserved, must be zero */
    0L,                         /* Reserved, must be zero */
    0L,                         /* Reserved, must be zero */
};

/*
 * Define supported vertex buffer callbacks
 */
static DDHAL_DDEXEBUFCALLBACKS NvD3DBufCallbacks =
{
    sizeof(DDHAL_DDEXEBUFCALLBACKS),
    0x1F,       // hardcoded to all, runtime doesn't even check, so it doesn't REALLY matter
    D3DCanCreateExecuteBuffer32,
    D3DCreateExecuteBuffer32,
    D3DDestroyExecuteBuffer32,
    D3DLockExecuteBuffer32,
    D3DUnlockExecuteBuffer32,
};

#ifndef TEXFORMAT_CRD

/*
 * Define supported texture formats.
 */
static DDSURFACEDESC Nv4TextureFormats[] =
{
    NV4_TEXTURE_FORMATS             // Texture formats defined in NVTEXFMTS.H
};

static DDSURFACEDESC celsiusTextureFormats[] =
{
    CELSIUS_TEXTURE_FORMATS         // Texture formats defined in NVTEXFMTS.H
};
static DDSURFACEDESC celsiusTextureFormatsNoDXT[] =
{
    CELSIUS_TEXTURE_FORMATS_NO_DXT  // Texture formats defined in NVTEXFMTS.H
};

#if (NVARCH >= 0x020)
static DDSURFACEDESC kelvinTextureFormats[] =
{
    KELVIN_TEXTURE_FORMATS         // Texture formats defined in NVTEXFMTS.H
};

static DDSURFACEDESC kelvinTextureFormatsNoDXT[] =
{
    KELVIN_TEXTURE_FORMATS_NO_DXT  // Texture formats defined in NVTEXFMTS.H
};
#endif // (NVARCH >= 0x020)

#endif  // !TEXFORMAT_CRD

/*
 * --------------------------------------------------------------------------
 *  Direct 3D HAL driver creation routines.
 *  Functions used to instantiate the 3D portion of the DirectDraw HAL
 *  Will be called (for example) from invokeCreateDriver() from ddsamp.
 *
 *  D3DHALCreateDriver
 *
 *  LPD3DHAL_GLOBALDRIVERDATA lpGlobal
 *      - A pointer to a structure containing alot of global information about
 *        our driver.
 *
 *  LPD3DHAL_CALLBACKS* lplpHALCallbacks
 *      - A pointer to a structure we fill in with the callbacks that this
 *        driver supports.
 * --------------------------------------------------------------------------
 */
BOOL __stdcall D3DHALCreateDriver
(
    LPD3DHAL_GLOBALDRIVERDATA  lpGlobal,
    LPD3DHAL_CALLBACKS         *lplpHALCallbacks,
    LPDDHAL_DDEXEBUFCALLBACKS  *lplpBufCallbacks,
    GLOBALDATA                 *pDriverData
)
{
    /*
     * check if driver is valid
     */
    {
        extern BYTE bDeveloperID[32 + 32];
        DWORD i,c;

        for (i = 32,c = 0; i < 64; i++)
        {
            if ((i & 7) == 7)
            {
                c ^= 0x42;
                if ((c ^ bDeveloperID[i]) & 0xfe)
                {
                    DPF_LEVEL (NVDBG_LEVEL_ERROR, "Invalid Driver ID");
                    return FALSE;
                }
                c = 0;
            }
            else
            {
                c ^= bDeveloperID[i];
            }
        }
    }

    // create context tables
    if (!CreateItemArrays(pDriverData))
    {
        DPF_LEVEL (NVDBG_LEVEL_ERROR, "Failed to initialize arrays");
        return FALSE;
    }

    //
    // Here we fill in the supplied structures.
    //
    memset(lpGlobal, 0, sizeof(D3DHAL_GLOBALDRIVERDATA));
    lpGlobal->dwSize              = sizeof(D3DHAL_GLOBALDRIVERDATA);
    lpGlobal->hwCaps              = getDC()->nvD3DDevCaps.dd1Caps;
    lpGlobal->dwNumVertices       = 32768;
    lpGlobal->dwNumClipVertices   = 32768;

#ifdef TEXFORMAT_CRD // --------------------------------

    lpGlobal->dwNumTextureFormats = getDC()->dwSurfaceDescriptorCount;
    lpGlobal->lpTextureFormats    = getDC()->pSurfaceDescriptors;

#else  // !TEXFORMAT_CRD // --------------------------------

#if (NVARCH >= 0x020)
    if (pDriverData->nvD3DPerfData.dwNVClasses & NVCLASS_FAMILY_KELVIN)
    {
#ifdef DXT_SUPPORT
        if ((getDC()->nvD3DRegistryData.regD3DEnableBits1 & D3D_REG_TEXTURECOMPRESSIONENABLE_MASK) == D3D_REG_TEXTURECOMPRESSIONENABLE_ENABLE) {
            lpGlobal->dwNumTextureFormats = sizeof(kelvinTextureFormats) / sizeof(DDSURFACEDESC);
            lpGlobal->lpTextureFormats    = &kelvinTextureFormats[0];
        }
        else
#endif  // DXT_SUPPORT
        {
            lpGlobal->dwNumTextureFormats = sizeof(kelvinTextureFormatsNoDXT) / sizeof(DDSURFACEDESC);
            lpGlobal->lpTextureFormats    = &kelvinTextureFormatsNoDXT[0];
        }
    }
    else
#endif  // NVARCH >= 0x020
#if (NVARCH >= 0x010)
    if (pDriverData->nvD3DPerfData.dwNVClasses & NVCLASS_FAMILY_CELSIUS)
    {
#ifdef DXT_SUPPORT
        if ((getDC()->nvD3DRegistryData.regD3DEnableBits1 & D3D_REG_TEXTURECOMPRESSIONENABLE_MASK) == D3D_REG_TEXTURECOMPRESSIONENABLE_ENABLE) {
            lpGlobal->dwNumTextureFormats = sizeof(celsiusTextureFormats) / sizeof(DDSURFACEDESC);
            lpGlobal->lpTextureFormats    = &celsiusTextureFormats[0];
        }
        else
#endif  // DXT_SUPPORT
        {
            lpGlobal->dwNumTextureFormats = sizeof(celsiusTextureFormatsNoDXT) / sizeof(DDSURFACEDESC);
            lpGlobal->lpTextureFormats    = &celsiusTextureFormatsNoDXT[0];
        }
    }
    else
#endif (NVARCH >= 0x010)
    if (pDriverData->nvD3DPerfData.dwNVClasses & NVCLASS_FAMILY_DXTRI) {
        lpGlobal->dwNumTextureFormats = sizeof(Nv4TextureFormats) / sizeof(DDSURFACEDESC);
        lpGlobal->lpTextureFormats    = &Nv4TextureFormats[0];
    }
    else {
        DPF("Unknown architecture");
        dbgD3DError();
        lpGlobal->dwNumTextureFormats = sizeof(Nv4TextureFormats) / sizeof(DDSURFACEDESC);
        lpGlobal->lpTextureFormats    = &Nv4TextureFormats[0];
    }

#endif  // !TEXFORMAT_CRD --------------------------------

    /*
     * Modify the capabilities as neccessary for the registry settings.
     */
    D3DModifyCapabilities(lpGlobal, pDriverData);

    /*
     * Return the HAL table.
     */
    *lplpHALCallbacks = &NvD3DHALCallbacks;
#ifndef DO_NOT_SUPPORT_VERTEX_BUFFERS // see nvprecomp.h
    if (
#if (NVARCH >= 0x020)
        (pDriverData->nvD3DPerfData.dwNVClasses & NVCLASS_FAMILY_KELVIN) ||
#endif // (NVARCH >= 0x020)
        (pDriverData->nvD3DPerfData.dwNVClasses & NVCLASS_FAMILY_CELSIUS)
       )
    {

        *lplpBufCallbacks = &NvD3DBufCallbacks;
    }
    else
#endif
    {
        *lplpBufCallbacks = NULL;
    }
    return (TRUE);
}

/*
 * --------------------------------------------------------------------------
 * Initialization routines.
 * --------------------------------------------------------------------------
 */

/*
 * This routine creates the various dynamic item arrays used by the Direct3D
 * driver for managing contexts and textures. This routine should be called
 * at DLL_PROCESS_ATTACH time from DllMain.
 */
BOOL CreateItemArrays
(
    GLOBALDATA *pDriverData
)
{
    /*
     * Initialize memory system.
     */
    if (!DDrvItemArrayInit())
    {
        DPF_LEVEL (NVDBG_LEVEL_ERROR, "CreateItemArrays - Failed to initialize memory subsystem");
        return (FALSE);
    }

    /*
     * Create the D3D context heap.
     */
    if (!nvCreateContextListHeap(pDriverData))
        return (FALSE);

    /*
     * done
     */
    return (TRUE);
}

/*
 * --------------------------------------------------------------------------
 * Termination routines.
 * --------------------------------------------------------------------------
 */

/*
 * This routine destroys the various dynamic item arrays used by the
 * Direct3D driver for managing contexts and textures. This routine should
 * be called at DLL_PROCESS_DETACH time from DllMain.
 */
BOOL DestroyItemArrays
(
    void
)
{
    // Cleanup the D3D context heap.
    nvDestroyContextListHeap();

    // Cleanup memory.
    return (DDrvItemArrayFini());
}

#endif  // NVARCH >= 0x04
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\ddraw\common\src\d3dRender.cpp ===
/*
 * Copyright (C) 1995 Microsoft Corporation.  All Rights Reserved.
 * (C) Copyright NVIDIA Corporation Inc., 1996,1998. All rights reserved.
 */
/********************************* Direct 3D *******************************\
*                                                                           *
* Module: d3dRender.cpp                                                     *
*   The Direct3D rendering routines.                                        *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*       Charles Inman (chasi)       01/02/97 - re-wrote and cleaned up.     *
*       Ben de Waal (bdw)           11/06/97 - Linear MipMap xxx            *
*                                                                           *
\***************************************************************************/
#include "nvprecomp.h"

#if (NVARCH >= 0x04)

/*
 * Dma Pushing loop stats.
 */
DWORD   statDmaSyncLoop      = 0;
DWORD   statDmaSyncOverflow  = 0;
DWORD   statDmaBusyLoop      = 0;
DWORD   statDmaBusyOverflow  = 0;
DWORD   statDmaFlushLoop     = 0;
DWORD   statDmaFlushOverflow = 0;

#ifndef WINNT  // these calls are obsolete on NT (DX7)
/*
 * --------------------------------------------------------------------------
 * nvRenderState
 *
 * LPD3DHAL_RENDERSTATEDATA
 * - Points to the instruction in the execute buffer.
 *
 * We get the count of states to set and then walk the execute buffer
 * handling each one at a time.
 * --------------------------------------------------------------------------
 */
DWORD __stdcall nvRenderState
(
    LPD3DHAL_RENDERSTATEDATA prd
)
{
    DWORD           i;
    LPBYTE          lpData;
    LPD3DSTATE      lpState;
    DWORD override;

    dbgTracePush ("nvRenderState");

    // get the context
    PNVD3DCONTEXT pContext;
    NV_SET_CONTEXT (pContext, prd);

    // Get pointer to global driver. data structure.
    nvSetDriverDataPtrFromContext(pContext);

    lpData = (LPBYTE)(((LPDDRAWI_DDRAWSURFACE_INT)prd->lpExeBuf)->lpLcl->lpGbl->fpVidMem);
    for (i = 0, lpState = (LPD3DSTATE)(lpData + prd->dwOffset);
         i < prd->dwCount; i++, lpState++)
    {
        DWORD rtype = (DWORD) lpState->drstRenderStateType;

        if (IS_OVERRIDE(rtype))
        {
            override = GET_OVERRIDE(rtype);
            if (((override - 1) >> DWORD_SHIFT) >= (MAX_STATE >> DWORD_SHIFT))
            {
                DPF("Invalid state override\n");
                dbgD3DError();
                continue;
            }

            if (lpState->dwArg[0])
            {
                DPF_LEVEL (NVDBG_LEVEL_INFO, "nvRenderState - setting override for state %08x", override);
                STATESET_SET(pContext->overrides, override);
            }
            else
            {
                DPF_LEVEL (NVDBG_LEVEL_INFO, "nvRenderState, clearing override for state %08x", override);
                STATESET_CLEAR(pContext->overrides, override);
            }
            DDTICKOFFSET(rtype, lpState->dwArg[0]);

            continue;
        }
        if (STATESET_ISSET(pContext->overrides, rtype))
        {
            DPF_LEVEL (NVDBG_LEVEL_INFO, "nvRenderState, state %08x is overridden, ignoring", rtype);
            DDTICKOFFSET(rtype, lpState->dwArg[0]);
            continue;
        }
        nvSetContextState (pContext, lpState->drstRenderStateType, lpState->dwArg[0], &prd->ddrval);
        if (prd->ddrval != DD_OK)
        {
            NvReleaseSemaphore(pDriverData);
            dbgTracePop();
            return (DDHAL_DRIVER_HANDLED);
        }

    }

    NvReleaseSemaphore(pDriverData);
    prd->ddrval = DD_OK;
    dbgTracePop();
    return (DDHAL_DRIVER_HANDLED);
}
#endif  // !WINNT

//---------------------------------------------------------------------------

DWORD __stdcall nvSetRenderTarget
(
    LPD3DHAL_SETRENDERTARGETDATA pRTData
)
{
    LPDDRAWI_DDRAWSURFACE_INT pDDS, pDDSZ;
    LPDDRAWI_DDRAWSURFACE_LCL lpDDSLcl, lpDDSLclZ;
    DWORD                     dwTargetHandle, dwZHandle;
    DWORD                     dwErrorReturnValue;

    dbgTracePush ("nvSetRenderTarget");

    // this now becomes a wrapper for the DX7 version.
    nvAssert (global.dwDXRuntimeVersion < 0x0700);

    // get the context
    PNVD3DCONTEXT pContext;
    NV_SET_CONTEXT (pContext, pRTData);

    // Select the appropriate return value.
    // Normally, DDHAL_DRIVER_HANDLED would be returned from this routine when
    // an error is encountered during processing.  However, DX6 has a bug in which
    // it only returns the pRTData->ddrval error value to the application if
    // DDHAL_DRIVER_NOTHANDLED is returned from SetRenderTarget.
    // Based on the registry setting, return the desired value when an error occurs.
    if (getDC()->nvD3DRegistryData.regValidateZMethod == D3D_REG_VALIDATEZMETHOD_SRTRETURNNOTHANDLED) {
        dwErrorReturnValue = DDHAL_DRIVER_NOTHANDLED;
    }
    else {
        dwErrorReturnValue = DDHAL_DRIVER_HANDLED;
    }

    pDDS = (LPDDRAWI_DDRAWSURFACE_INT)pRTData->lpDDS;
    if (!pDDS) {
        dbgD3DError();
        pRTData->ddrval = DDERR_CURRENTLYNOTAVAIL;
        dbgTracePop();
        return (dwErrorReturnValue);
    }
    lpDDSLcl = pDDS->lpLcl;
    if (!lpDDSLcl) {
        dbgD3DError();
        pRTData->ddrval = DDERR_CURRENTLYNOTAVAIL;
        dbgTracePop();
        return (dwErrorReturnValue);
    }

    dwTargetHandle = (DWORD)lpDDSLcl;

    // get the zbuffer handle if we've got one
    if ((pDDSZ = (LPDDRAWI_DDRAWSURFACE_INT)pRTData->lpDDSZ) != NULL) {
        lpDDSLclZ = pDDSZ->lpLcl;
    }
    else {
        lpDDSLclZ = NULL;
    }
    dwZHandle = (DWORD)lpDDSLclZ;

    // update the associated NvObjects back-pointers since the runtime
    // may have moved nvObject pointers around amongst DDSLcls.
    CNvObject *pNvObj;
    pNvObj = GET_PNVOBJ (lpDDSLcl);
    pNvObj->setHandle ((DWORD)lpDDSLcl);
    if (lpDDSLclZ) {
        pNvObj = GET_PNVOBJ (lpDDSLclZ);
        pNvObj->setHandle ((DWORD)lpDDSLclZ);
    }

    pRTData->ddrval = nvSetRenderTargetDX7 (pContext, dwTargetHandle, dwZHandle);

    if (pRTData->ddrval != DD_OK) {
        dbgTracePop();
        return (dwErrorReturnValue);
    }

    dbgTracePop();
    return (DDHAL_DRIVER_HANDLED);
}

//---------------------------------------------------------------------------

BOOL nvAdjustZBuffer (CSimpleSurface *pZetaBuffer, LPDDRAWI_DDRAWSURFACE_LCL pDDSLclZ, DWORD dwNewBPP)
{
    if (pZetaBuffer->recreate (dwNewBPP)) {
        // successful allocation. reset some stuff in MS land
        if (pDDSLclZ) {
            pDDSLclZ->lpGbl->fpVidMem                      = pZetaBuffer->getfpVidMem();
            pDDSLclZ->lpGbl->lPitch                        = pZetaBuffer->getPitch();
            pDDSLclZ->lpGbl->lSlicePitch                   = pZetaBuffer->getSlicePitch();
            pDDSLclZ->lpGbl->ddpfSurface.dwZBufferBitDepth = dwNewBPP << 3;
            pDDSLclZ->lpGbl->ddpfSurface.dwZBitMask        = (dwNewBPP==2) ? 0x0000ffff : 0xffffff00;
        }
    }
    else {
        // re-allocation failed. now things are really bad.
        DPF ("nvCheckBufferCompatibility: z-buffer reallocation failed");
        nvAssert(0);
        return FALSE;
    }
    return TRUE;
}

//---------------------------------------------------------------------------

// check that we can actually render with this combination of z-buffer and
// render target. if not, try to fix things up for pre-DX7 apps.
// returns TRUE if everything is OK, FALSE otherwise

BOOL nvCheckBufferCompatibility (CSimpleSurface *pRenderTarget, CSimpleSurface *pZetaBuffer,
                                 LPDDRAWI_DDRAWSURFACE_LCL pDDSLclZ, DWORD dwDXAppVersion)
{
    if ((pZetaBuffer == NULL) || (pRenderTarget == NULL)) {
        // non-existent buffers can't conflict
        return TRUE;
    }

    if (pDriverData->nvD3DPerfData.dwNVClasses & NVCLASS_0097_KELVIN) {
        // with kelvin, all combinations of bit depths are ok
    }

    else if (dwDXAppVersion >= 0x800) { // !kelvin && DX8

        // DX8 apps convert Z if necessary
        if (pDriverData->nvD3DPerfData.dwNVClasses & NVCLASS_1196_CELSIUS) {
            // NV 11 supports C32/Z16
            if (pZetaBuffer->getBPP() > pRenderTarget->getBPP()) {
                DPF ("nvCheckBufferCompatibility: downgrading NV11 depth buffer for DX8 app");
                if (!nvAdjustZBuffer(pZetaBuffer, pDDSLclZ, pRenderTarget->getBPP())) {
                    return FALSE;
                }
            }
        }
        else if (pZetaBuffer->getBPP() != pRenderTarget->getBPP()) {
            // !NV11
            DPF ("nvCheckBufferCompatibility: forcing congruent bit depths for DX8 app");
            nvAdjustZBuffer(pZetaBuffer, pDDSLclZ, pRenderTarget->getBPP());
        }

    }

    else if (dwDXAppVersion >= 0x700) { // !kelvin && dx7

        // DX7 apps are expected to be compliant
        if ((pZetaBuffer->getBPPRequested() > pRenderTarget->getBPPRequested())
            ||
            ((!(pDriverData->nvD3DPerfData.dwNVClasses & NVCLASS_1196_CELSIUS)) &&
            (pZetaBuffer->getBPP() != pRenderTarget->getBPP())))
        {
            DPF ("nvCheckBufferCompatibility: mixed bit depths are disallowed for dx7");
            nvAssert(0);
            return FALSE;
        }

    }

    else { // !kelvin && DX6 or earlier

        // we try to cater to legacy apps no matter what they requested
        if ((pZetaBuffer->getBPP() > pRenderTarget->getBPP())
            ||
            ((!(pDriverData->nvD3DPerfData.dwNVClasses & NVCLASS_1196_CELSIUS)) &&
            (pZetaBuffer->getBPP() != pRenderTarget->getBPP())))
        {
            DPF ("nvCheckBufferCompatibility: forcing congruent bit depths for legacy app");
            if (!nvAdjustZBuffer(pZetaBuffer, pDDSLclZ, pRenderTarget->getBPP())) {
                return FALSE;
            }
        }

    }

    // check that the z-buffer is big enough
    if ((pRenderTarget->getHeight() > pZetaBuffer->getHeight()) ||
        (pRenderTarget->getWidth() > pZetaBuffer->getWidth())) {
        DPF ("nvCheckBufferCompatibility: z-buffer is insufficiently large");
        return FALSE;
    }

    return TRUE;
}

//---------------------------------------------------------------------------

DWORD nvSetRenderTargetDX7
(
    PNVD3DCONTEXT pContext,
    DWORD dwTargetHandle,
    DWORD dwZBufferHandle
)
{
    CNvObject       *pObj, *pZObj;
    CSimpleSurface  *pSurface, *pZSurface;
    CTexture        *pTexture;
    DWORD            dwClass;
    BOOL             bRTChanged;

    dbgTracePush ("nvSetRenderTargetDX7 (rt = %d, zb = %d)", dwTargetHandle, dwZBufferHandle);

    // Set pointer to global driver data structure.
    nvSetDriverDataPtrFromContext (pContext);

    // get the z surface
    if (dwZBufferHandle) {
        pZObj = nvGetObjectFromHandle (pContext->dwDDLclID, dwZBufferHandle, &global.pNvSurfaceLists);
        pZSurface = pZObj ? pZObj->getSimpleSurface() : NULL;
    }
    else {
        pZSurface = NULL;
    }

    // set the render target ------------------------------------------------

#ifdef WINNT
    pObj = nvGetObjectFromHandle (pContext->dwDDLclID, dwTargetHandle, &global.pNvSurfaceLists);
#else // !WINNT
    // runtime bug in dx7 when running dx5 apps - we will get a handle of 0 here for the primary surface
    // the runtime is supposed to swap the surface handles internally
    pObj = dwTargetHandle ? nvGetObjectFromHandle (pContext->dwDDLclID, dwTargetHandle, &global.pNvSurfaceLists) : (CNvObject*)pDXShare->pNvPrimarySurf;
#endif // !WINNT
    dwClass = pObj ? pObj->getClass() : CNvObject::NVOBJ_UNKNOWN;

    switch (dwClass) {

        case CNvObject::NVOBJ_SIMPLESURFACE :

#if (NVARCH >= 0x010)
            if (pContext->aa.isSuspended()) {
                pContext->aa.modFlags (~AASTATE::FLAG_SUSPENDED,AASTATE::FLAG_ENABLED);
            }
#endif  // NVARCH >= 0x010
#if (NVARCH >= 0x020)
            pContext->kelvinAA.Resume();
#endif
            pSurface = pObj->getSimpleSurface();

#ifdef  STEREO_SUPPORT
            //Make sure the render target has the right eye.
            if (STEREO_ENABLED && !pSurface->isStereo())
            {
                if (!pSurface->createStereo()) {
                    LOG("nvSetRenderTargetDX7: Can't create a stereo surface");
                }
            }
#endif  //STEREO_SUPPORT

            // make sure this is something we can write to
            if (!pSurface->hwCanWrite()) {
                NvReleaseSemaphore(pDriverData);
                dbgD3DError();
                dbgTracePop();
                return (DDERR_CURRENTLYNOTAVAIL);
            }
            break;

        case CNvObject::NVOBJ_TEXTURE :

#if (NVARCH >= 0x010)
            if (pContext->aa.isEnabled())  {
                pContext->aa.modFlags (~AASTATE::FLAG_ENABLED,AASTATE::FLAG_SUSPENDED);
            }
#endif  // NVARCH >= 0x010
#if (NVARCH >= 0x020)
            pContext->kelvinAA.Suspend();
#endif

            pTexture = pObj->getTexture();

            // render to the linear copy if it's newer or if we have dissimilar bit
            // depths on NV11/NV20 which can't handle mixed swizzled rendering
            if ( (pTexture->getLinear()->isUpToDate() && !pTexture->getSwizzled()->isUpToDate())
                 ||
                 (pZSurface && (pZSurface->getBPP() != pTexture->getBPP()))       // and mixed
               )
            {
                pSurface = pTexture->getLinear();
                // make certain we have a video memory linear surface
                if (!pTexture->prepareLinearAsRenderTarget()) {
                    NvReleaseSemaphore(pDriverData);
                    dbgD3DError();
                    dbgTracePop();
                    return (DDERR_OUTOFVIDEOMEMORY);
                }
            }
            else
            {
                // use swizzled rendering in hardware
                pTexture->updateSwizzleSurface(pContext);
                pSurface = pTexture->getSwizzled();
                pSurface->setWrapper (pTexture->getWrapper());
                pSurface->setFormat (pTexture->getFormat());
                pSurface->setBPP (pTexture->getBPP());
                pSurface->setBPPRequested (pTexture->getBPPRequested());
                pSurface->setWidth (pTexture->getWidth());
                pSurface->setHeight (pTexture->getHeight());
                pSurface->setDepth (pTexture->getDepth());
                pSurface->setPitch (pTexture->getPitch());
                pSurface->setSlicePitch (pTexture->getSlicePitch());
                pSurface->tagAsSwizzled();
            }
            break;

        default:
            // no formatted surface available
            DPF("nvSetRenderTarget - NULL target");
            NvReleaseSemaphore(pDriverData);
            dbgD3DError();
            dbgTracePop();
            return (DDERR_CURRENTLYNOTAVAIL);
            break;

    } // switch

    // if required, make certain that the previous flip has completed
    nvPusherSignalWaitForFlip (pSurface->getfpVidMem(), DDSCAPS_PRIMARYSURFACE);

    // mark RT as up to date
    pObj->clearDirty();

    // set the z-buffer -----------------------------------------------------

    if (pZSurface) {
        // enter if AA is not enabled.  Note that AA may have been created but is suspended at the moment
        // due to rendering to a texture or some such.
        // if AA is on and not suspended, then we'll assume that everything works--after all, we created the Z buffer,
        // so we're pretty sure it's valid.
        if (!pContext->kelvinAA.IsEnabled()) {
            if (pContext->kelvinAA.IsCreated()) {
                // if kelvin AA is or was on, we may have destroyed the z-buffer. attempt to re-create it now
                if (!pZSurface->isValid()) {
                    pContext->kelvinAA.ReCreateZBuffer();
                }
            }

            // if the z-surface is still invalid or isn't something the HW can write, bail out now
            if (!pZSurface->isValid() || !pZSurface->hwCanWrite()) {
                NvReleaseSemaphore(pDriverData);
                dbgD3DError();
                dbgTracePop();
                return (DDERR_CURRENTLYNOTAVAIL);
            }
        }

        // disable CT if the z-buffer is being associated with a render target whose size
        // is different from that of the render target with which it was last associated
        DWORD dwLastW = pZObj->getContextualValue0();
        DWORD dwLastH = pZObj->getContextualValue1();
        if (((dwLastW != 0) && (dwLastW != pSurface->getWidth()))
            ||
            ((dwLastH != 0) && (dwLastH != pSurface->getHeight())))
        {
            pZObj->disableCT();
        }
        pZObj->setContextualValue0 (pSurface->getWidth());
        pZObj->setContextualValue1 (pSurface->getHeight());
        // check that the z-buffer is big enough
        if ((pSurface->getHeight() > pZSurface->getHeight()) ||
            (pSurface->getWidth() > pZSurface->getWidth()))
        {
            DPF("z-buffer disabled due to insufficient space");
            pZSurface = NULL;
            dwZBufferHandle = 0;
        }
    }

    else {
        // according to MS, (dwZBufferHandle == 0) => disable z-buffer
        pZSurface = NULL;
    }

    // check that we can render with this combination
    if (!nvCheckBufferCompatibility (pSurface, pZSurface, NULL, pContext->dwDXAppVersion)) {
        NvReleaseSemaphore(pDriverData);
        dbgTracePop();
        return (DDERR_CURRENTLYNOTAVAIL);
    }

    // only now that all sanity checks have passed, update values in the context
    bRTChanged = (pContext->pRenderTarget != pSurface) ? TRUE : FALSE;
    pContext->dwRTHandle    = dwTargetHandle;
    pContext->dwZBHandle    = dwZBufferHandle;
    pContext->pRenderTarget = pSurface;
    pContext->pZetaBuffer   = pZSurface;

    dbgSetFrontRenderTarget (pContext, pSurface);

    // fix up AA if render target changed
    if (bRTChanged) {
        if (getDC()->dwAAContextCount >= 1) {
#if (NVARCH >= 0x020)
        if (pDriverData->nvD3DPerfData.dwNVClasses & NVCLASS_FAMILY_KELVIN) {
            pContext->kelvinAA.UpdateZBuffer();
            pContext->kelvinAA.UpdateRenderTarget();
        } else
#endif  // NVARCH >= 0x020
#if (NVARCH >= 0x010)
        if (pDriverData->nvD3DPerfData.dwNVClasses & NVCLASS_FAMILY_CELSIUS) {
            // Magnify the new render target into the super buffer
            if (pContext->aa.mAppCompat.bDiscardSRT){
//              pContext->aa.invalidateSRT();
                pContext->aa.makeSuperBufferValid(pContext);
            }
        }
#endif  // NVARCH >= 0x010
        }
    }

#if (NVARCH >= 0x010)
    pContext->hwState.dwDirtyFlags |= (CELSIUS_DIRTY_SURFACE   |
                                       CELSIUS_DIRTY_TRANSFORM |
                                       CELSIUS_DIRTY_SPECFOG_COMBINER);
    pContext->hwState.dwDirtyFlags |= (KELVIN_DIRTY_SURFACE   |
                                       KELVIN_DIRTY_TRANSFORM |
                                       KELVIN_DIRTY_COMBINERS_SPECFOG);
#endif
    pDriverData->bDirtyRenderTarget = TRUE;

    nvSetD3DSurfaceState (pContext);

#if (NVARCH >= 0x020)
    if (pDriverData->nvD3DPerfData.dwNVClasses & NVCLASS_FAMILY_KELVIN) {
        pContext->kelvinAA.TestCreation(pContext);
    } else
#endif
#if (NVARCH >= 0x010)
    if (pDriverData->nvD3DPerfData.dwNVClasses & NVCLASS_FAMILY_CELSIUS) {
        pContext->aa.Create(pContext);
    }
#endif  // NVARCH >= 0x010

    NvReleaseSemaphore(pDriverData);
    dbgTracePop();
    return (DD_OK);
}
#endif  // NVARCH >= 0x04
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\ddraw\common\src\ddDrvMem.cpp ===
// =========================================================
// Memory allocator for display drivers.
// =========================================================
#include "nvprecomp.h"

#if (NVARCH >= 0x04)

//
// Local Memory Management macros, variables, etc.
//

#define HEAP_SHARED 0x04000000UL    // put heap in shared memory

HANDLE g_hD3DHAL_DriverHeap = (HANDLE)NULL;

#define MEMINIT    {g_hD3DHAL_DriverHeap = (HANDLE)HeapCreate(HEAP_SHARED, 0x2000, 0 );}
#define MEMFINI     (HeapDestroy (g_hD3DHAL_DriverHeap) ? (g_hD3DHAL_DriverHeap = NULL, TRUE) : (g_hD3DHAL_DriverHeap = NULL, FALSE))
#define MEMCHECK    (g_hD3DHAL_DriverHeap ? TRUE : FALSE)



// Defaults
#define DDRV_DEFAULT_SIZE    4
#define DDRV_DEFAULT_DELTA   4

#define NOT_FOUND ((DWORD)-1)

typedef struct __ddrvitemarraydata {
    void    *pBase;         // Pointer to array of Items
    BOOL    *pValid;        // Pointer to boolean array of valid items
    DWORD   dwSize;         // Size of each Item in array (in Bytes)
    DWORD   dwDelta;        // Growth Factor of array
    DWORD   dwNumItems;     // Num of items in array
    BOOL    bValidArray;    // Is this array in use ???
} DDRVITEMARRAYDATA, *LPDDRVITEMARRAYDATA;

LPDDRVITEMARRAYDATA pArrays = 0;
DWORD dwNumArrays = 0;


/*
**-----------------------------------------------------------------------------
** Name:    DDrvItemArrayInit
** Purpose: Creates an array of item arrays
**-----------------------------------------------------------------------------
*/

BOOL
DDrvItemArrayInit ()
{
    // Initialize Memory ?!?
    if (! MEMCHECK) {
        MEMINIT;
        if (! MEMCHECK) {
            return FALSE;
        }
    }

    // Create Starting Arrays
    if (!pArrays) {
        pArrays = (LPDDRVITEMARRAYDATA) MEMALLOC (DDRV_DEFAULT_SIZE * sizeof(DDRVITEMARRAYDATA));
        if (! pArrays) {
            return FALSE;
        }

        dwNumArrays = DDRV_DEFAULT_SIZE;
    }
    return TRUE;
}


/*
**-----------------------------------------------------------------------------
** Name:    DDrvItemArrayFini
** Purpose: Destroys an array of item arrays
**-----------------------------------------------------------------------------
*/

BOOL
DDrvItemArrayFini ()
{
    BOOL ret;

    if (! MEMCHECK) {
        return TRUE;
    }

    // Cleanup Memory ?!?
    ret = MEMFINI;
    return ret;
}



/*
**-----------------------------------------------------------------------------
** Name:    DDrvItemArrayCreate
** Purpose: Creates a new item array, returns handle to new array
**-----------------------------------------------------------------------------
*/

BOOL
DDrvItemArrayCreate (DWORD nItems, DWORD dwSize,
                     DWORD dwDelta, LPHDDRVITEMARRAY phArray)
{
    DWORD i;

    // Find first empty array
    for (i = 0; i < dwNumArrays; i += 1)
        if (! pArrays[i].bValidArray)
            break;

    // If no empty arrays, then grow number of arrays
    if (i == dwNumArrays) {
        LPDDRVITEMARRAYDATA newArrays = (LPDDRVITEMARRAYDATA) MEMALLOC ((dwNumArrays+DDRV_DEFAULT_DELTA)*sizeof(DDRVITEMARRAYDATA));
        if (! newArrays) {
            return FALSE;
        }

        MEMCOPY(newArrays, pArrays, dwNumArrays * sizeof(DDRVITEMARRAYDATA));
        MEMFREE(pArrays);

        pArrays = newArrays;
        dwNumArrays += DDRV_DEFAULT_DELTA;
    }

    // Create new array of items
    dwSize = (dwSize + 7) & ~7;

    pArrays[i].pBase = MEMALLOC (nItems*dwSize);
    if (! pArrays[i].pBase) {
        return FALSE;
    }

    pArrays[i].pValid = (BOOL *) MEMALLOC (nItems * sizeof(BOOL));
    if (! pArrays[i].pValid) {
        MEMFREE(pArrays[i].pBase);
        pArrays[i].pBase = NULL;
        return FALSE;
    }

    pArrays[i].dwSize       = dwSize;
    pArrays[i].dwDelta      = dwDelta;
    pArrays[i].dwNumItems   = nItems;
    pArrays[i].bValidArray  = TRUE;

    *phArray = (i+1);
    return TRUE;
}


/*
**-----------------------------------------------------------------------------
** Name:    DDrvItemArrayDestroy
** Purpose: Destroys an item array
**-----------------------------------------------------------------------------
*/

BOOL
DDrvItemArrayDestroy (HDDRVITEMARRAY hArray)
{
    DWORD dwArray = hArray - 1;
    LPDDRVITEMARRAYDATA lpArray = pArrays + dwArray;

    if ((dwArray >= dwNumArrays) || (! lpArray->bValidArray))
    {
        return FALSE;
    }

    // Destroy array of items
    if (lpArray->pValid) {
        MEMFREE (lpArray->pValid);
        lpArray->pValid = NULL;
    }

    if (lpArray->pBase) {
        MEMFREE (lpArray->pBase);
        lpArray->pBase = NULL;
    }

    lpArray->bValidArray = FALSE;
    return TRUE;
}



/*
**-----------------------------------------------------------------------------
** Name:    DDrvItemArrayDestroy
** Purpose: Flushes an item array by marking all item slots
**          as empty
**-----------------------------------------------------------------------------
*/

BOOL
DDrvItemArrayFlush (HDDRVITEMARRAY hArray)
{
    DWORD i;
    DWORD dwArray = hArray - 1;
    LPDDRVITEMARRAYDATA lpArray = pArrays + dwArray;

    if ((dwArray >= dwNumArrays) || (! lpArray->bValidArray))
    {
        return FALSE;
    }

    // Mark all items in array as empty
    for (i = 0; i < lpArray->dwNumItems; i++) {
        lpArray->pValid[i] = FALSE;
    }

    return TRUE;
}



/*
**-----------------------------------------------------------------------------
** Name:    DDrvItemArrayAlloc
** Purpose: Creates a new item in specified item array
**-----------------------------------------------------------------------------
*/

BOOL
DDrvItemArrayAlloc (HDDRVITEMARRAY hArray, LPHDDRVITEM lphItem)
{
    DWORD dwArray = hArray - 1;
    DWORD i;
    LPDDRVITEMARRAYDATA lpArray = pArrays + dwArray;

    if ((dwArray >= dwNumArrays) || (! lpArray->bValidArray))
    {
        return FALSE;
    }

    // Find first empty item in array
    for (i = 0; i < lpArray->dwNumItems; i++) {
        if (! (lpArray->pValid[i]))
            break;
    }

    // If no empty items in array
    // then grow array
    if (i == lpArray->dwNumItems) {
        BOOL * newpValid;
        LPVOID newpBase;
        DWORD  dwNewSize = lpArray->dwNumItems + lpArray->dwDelta;

        // Check for static array
        if (! lpArray->dwDelta) {
            return FALSE;
        }

        newpBase = MEMALLOC (dwNewSize * lpArray->dwSize);
        if (! newpBase) {
            return FALSE;
        }

        newpValid = (BOOL *) MEMALLOC ((dwNewSize) * sizeof(BOOL));
        if (! newpValid) {
            MEMFREE (newpBase);
            return FALSE;
        }

        MEMCOPY (newpValid, lpArray->pValid, lpArray->dwNumItems * sizeof(DWORD));
        MEMCOPY (newpBase, lpArray->pBase, lpArray->dwNumItems * lpArray->dwSize);

        MEMFREE (lpArray->pValid);
        lpArray->pValid = newpValid;

        MEMFREE (lpArray->pBase);
        lpArray->pBase  = newpBase;

        lpArray->dwNumItems += lpArray->dwDelta;
    }

    // Return handle to item
    lpArray->pValid[i] = TRUE;
    *lphItem = i+1;
    return TRUE;
}

/*
**-----------------------------------------------------------------------------
** Name:    DDrvItemArrayGetPtr
** Purpose: Gets a pointer to item in item array
**-----------------------------------------------------------------------------
*/

LPVOID
DDrvItemArrayGetPtr (HDDRVITEMARRAY hArray, HDDRVITEM hItem)
{
    DWORD dwItem    = hItem - 1;
    DWORD dwArray   = hArray - 1;
    LPDDRVITEMARRAYDATA lpArray = pArrays + dwArray;

    if (hArray >= dwNumArrays ||
        lpArray->bValidArray == FALSE ||
        dwItem >= lpArray->dwNumItems ||
        lpArray->pValid[dwItem] == FALSE) {
        return NULL;
    }

    // Return pointer to item
    return ((char *)(lpArray->pBase) + dwItem * lpArray->dwSize);
}



/*
**-----------------------------------------------------------------------------
** Name:    DDrvItemArrayFree
** Purpose: Frees item from item array
**-----------------------------------------------------------------------------
*/

BOOL
DDrvItemArrayFree (HDDRVITEMARRAY hArray, HDDRVITEM hItem)
{
    DWORD dwItem  = hItem - 1;
    DWORD dwArray = hArray - 1;
    LPDDRVITEMARRAYDATA lpArray = pArrays + dwArray;

    if (hArray >= dwNumArrays ||
        lpArray->bValidArray == FALSE ||
        dwItem >= lpArray->dwNumItems ||
        lpArray->pValid[dwItem] == FALSE) {
        return FALSE;
    }

    // Set valid flag to false
    lpArray->pValid[dwItem] = FALSE;
    return TRUE;
}



/*
**-----------------------------------------------------------------------------
** Name:    DDrvItemFindFirstValid
** Purpose: Finds first valid item in array
**-----------------------------------------------------------------------------
*/

BOOL
DDrvItemArrayFindFirstValid (
    HDDRVITEMARRAY  hArray,
    LPHDDRVITEM     lpNextValid)
{
    DWORD i;
    DWORD dwArray = hArray - 1;
    LPDDRVITEMARRAYDATA lpArray = pArrays + dwArray;

    if ((dwArray >= dwNumArrays) || (! lpArray->bValidArray))
    {
        return FALSE;
    }

    // Find first valid array item
    for (i = 0; i < lpArray->dwNumItems; i++) {
        if (lpArray->pValid[i]) {
            if (lpNextValid) {
                *lpNextValid = i + 1;
            }
            return TRUE;
        }
    }

    return FALSE;
} // End Find First Valid


/*
**-----------------------------------------------------------------------------
** Name:    DDrvItemFindNextValid
** Purpose: Finds next valid item in array,
**          after specified start item
**-----------------------------------------------------------------------------
*/

BOOL
DDrvItemArrayFindNextValid (
    HDDRVITEMARRAY  hArray,
    HDDRVITEM       hStartFrom,
    LPHDDRVITEM     lpNextValid)
{
    DWORD i;
    DWORD dwArray = hArray - 1;
    LPDDRVITEMARRAYDATA lpArray = pArrays + dwArray;

    if ((dwArray >= dwNumArrays) || (! lpArray->bValidArray))
    {
        return FALSE;
    }

    // Find next valid array item after hStartFrom
    for (i = hStartFrom; i < lpArray->dwNumItems; i++) {
        if (lpArray->pValid[i]) {
            if (lpNextValid) {
                *lpNextValid = i + 1;
            }
            return TRUE;
        }
    }

    return FALSE;
} // End Find Next Valid


/*
**-----------------------------------------------------------------------------
** Name:    DDrvItemArrayApplyValid
** Purpose: Apply specified callback to each valid item in array
**-----------------------------------------------------------------------------
*/

BOOL
DDrvItemArrayApplyValid (
    HDDRVITEMARRAY  hArray,
    DDRVAPPLYFUNC   lpCallback,
    DWORD           dwExtra)
{
    DWORD i;
    DWORD dwRet;
    DWORD dwArray = hArray - 1;
    DWORD dwSuccessCount;
    LPDDRVITEMARRAYDATA lpArray = pArrays + dwArray;

    dwSuccessCount = 0;
    if ((dwArray >= dwNumArrays) || (! lpArray->bValidArray))
        return (dwSuccessCount);

    if (! lpCallback)
        return (dwSuccessCount);

    for (i = 0; i < lpArray->dwNumItems; i++) {
        if (lpArray->pValid[i]) {

            // Call user callback
            dwRet = (*lpCallback)(((char *)(lpArray->pBase) + (i * lpArray->dwSize)),
                                  (i+1),
                                  dwExtra);

            // Check Return Value
            switch (dwRet)
            {
            case DDRV_SUCCESS_CONTINUE:
                dwSuccessCount++;
                break;
            case DDRV_ERROR_CONTINUE:
                break;

            case DDRV_SUCCESS_STOP:
                return (dwSuccessCount);

            case DDRV_ERROR_STOP:
            default:
                return (dwSuccessCount);
            }
        }
    }

    return (dwSuccessCount);
} // End DDrvItemArrayApplyValid


/*
**-----------------------------------------------------------------------------
** Name:    DDrvItemApplyAll
** Purpose: Apply specified callback to each item in array
**-----------------------------------------------------------------------------
*/

BOOL
DDrvItemArrayApplyAll (
    HDDRVITEMARRAY  hArray,
    DDRVAPPLYFUNC   lpCallback,
    DWORD           dwExtra)
{
    DWORD i;
    DWORD dwRet;
    DWORD dwArray = hArray - 1;
    DWORD dwSuccessCount;
    LPDDRVITEMARRAYDATA lpArray = pArrays + dwArray;

    dwSuccessCount = 0;
    if ((dwArray >= dwNumArrays) || (! lpArray->bValidArray))
        return (dwSuccessCount);

    if (! lpCallback)
        return (dwSuccessCount);

    for (i = 0; i < lpArray->dwNumItems; i++) {
        // Call user callback
        dwRet = (*lpCallback)(((char *)(lpArray->pBase) + (i * lpArray->dwSize)),
                              (i+1),
                              dwExtra);

        // Check Return Value
        switch (dwRet)
        {
        case DDRV_SUCCESS_CONTINUE:
            dwSuccessCount++;
            break;
        case DDRV_ERROR_CONTINUE:
            break;

        case DDRV_SUCCESS_STOP:
            return (dwSuccessCount);

        case DDRV_ERROR_STOP:
        default:
            return (dwSuccessCount);
        }
    }

    return (dwSuccessCount);
} // End DDrvItemArrayApplyAll

#endif  // NVARCH >= 0x04
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\ddraw\common\src\ddDrv.cpp ===
/***************************************************************************\
* Copyright 1993-1999 NVIDIA, Corporation.  All rights reserved.            *
* THE INFORMATION CONTAINED HEREIN IS PROPRIETARY AND CONFIDENTIAL TO       *
* NVIDIA, CORPORATION.  USE, REPRODUCTION OR DISCLOSURE TO ANY THIRD PARTY  *
* IS SUBJECT TO WRITTEN PRE-APPROVAL BY NVIDIA, CORPORATION.                *
*                                                                           *
*  Portions: Copyright (C) 1995 Microsoft Corporation.  All Rights Reserved.*
*                                                                           *
* Module: ddDrv.cpp                                                         *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*       schaefer           7/6/99                                           *
*                                                                           *
\***************************************************************************/
// NB: This file is 'opted out' of using precompiled headers
#define INITGUID
#include "nvprecomp.h"

#include "escape.h"
#include "dxshare.h"
#include "nvcm.h"
#include "nvreg.h"
#include "nvILHash.h"
#include "..\..\..\modeset.mhd\include\modeext.h"
#include "wincommon.h"


#ifdef WINNT
    #ifdef _NO_COM
        #include <ddkernel.h>
    #else
        #define _NO_COM
        #include <ddkernel.h>
        #undef _NO_COM
    #endif // _NO_COM
#endif // WINNT

#ifdef WINNT
    PDEV    *ppdev;
#else
    DISPDRVDIRECTXCOMMON *pDXShare;

    U032  __stdcall SetSharedFSDOSBoxPtr (U032 *pData);
    DWORD __stdcall buildDDHALInfo16 (void);
    DWORD __stdcall UpdateNonLocalHeap32 (LPDDHAL_UPDATENONLOCALHEAPDATA lpd);
    DWORD __stdcall nvModeSetPrepare16 (void);
    DWORD __stdcall nvModeSetCleanup16 (void);
    void  __stdcall BuildDefaultDDHalModeTable (void);
    DWORD __stdcall GetSelectorsFromDisplayDriver (void);
    DWORD __stdcall FreeSelectorsFromDisplayDriver (void);
    void  __stdcall BuildDDHalModeTable (void);
#endif // !WINNT

#define NV_BUS_TYPE_AGP 4

CDriverContext         *pDriverData;

#ifdef CNT_TEX
DWORD g_dwVidTexDL[MAX_FRAME_CNT];
DWORD g_dwAgpTexDL[MAX_FRAME_CNT];
DWORD g_dwFrames;
#endif

/*
 * list of ROPs we support
 *
 * SRCCOPY is the key one to support
 */
static DWORD ropList[] = {
    BLACKNESSBIT | NOTSRCERASEBIT,               // 0x00 - 0x1F
    NOTSRCCOPYBIT,                               // 0x20 - 0x3F
    SRCERASEBIT,                                 // 0x40 - 0x5F
    SRCINVERTBIT,                                // 0x60 - 0x7F
    SRCANDBIT,                                   // 0x80 - 0x9F
    MERGEPAINTBIT,                               // 0xA0 - 0xBF
    SRCCOPYBIT,                                  // 0xC0 - 0xDF
    SRCPAINTBIT | WHITENESSBIT                   // 0xE0 - 0xFF
};

#ifdef WINNT
    // caps are not dynamic on WINNT, so always declare overlay and just fail creation if we need to
    #define NO_OVERLAY (FALSE)
#else
    #define NO_OVERLAY (pDriverData->dwHeads > 1 &&                                         \
                        pDriverData->dwDesktopState == NVTWINVIEW_STATE_CLONE &&            \
                      !(pDriverData->vpp.regOverlayMode2 & NV4_REG_OVL_MODE2_FSDEVICEMASK) &&   \
                      !(pDriverData->vpp.regOverlayMode3 & NV4_REG_OVL_MODE3_ALLOWOVL))
#endif

#if WINNT
extern "C" void __cdecl nvDDrawSynWithNvGdiDrv(PDEV*   ppdev);
#endif

/*
 * IN_VBLANK should be replaced by a test to see if the hardware is currently
 * in the vertical blank
 */
static BOOL     bInVBlank;
static BOOL     bInDisplay;
#define IN_VBLANK               (bInVBlank= !bInVBlank)
#define IN_DISPLAY              (bInDisplay= !bInDisplay)

/*
 * DRAW_ENGINE_BUSY should be replaced by a test to see the bltter is still
 * busy drawing
 */
#define DRAW_ENGINE_BUSY        FALSE

/*
 * ENOUGH_FIFO_FOR_BLT should be replaced with a test to see if there is enough
 * room in the hardware fifo for a blt
 */
#define ENOUGH_FIFO_FOR_BLT     TRUE

/*
 * CURRENT_VLINE should be replaced by a macro to retrieve the current
 * scanline
 */
#define CURRENT_VLINE   0

extern Nv10ControlDma * __stdcall NvSysOpenDma(char *, int, int, int);
extern DWORD __stdcall NvSysOpen(DWORD);
extern void  __stdcall NvSysClose(DWORD);

#ifndef WINNT   // Win9x Hackery
#ifndef NVPE
extern DWORD HookUpVxdStorage();
#endif
extern vpSurfaces* pMySurfaces;
#endif // !WINNT

#ifdef NVD3D
/*
 * D3D Hal Fcts
 */
extern BOOL DestroyItemArrays(void);
#endif // NVD3D

#ifdef NVSTATDRIVER
/*
 * Statitistics driver functions
 */
void __stdcall AttachNVStat();
void __stdcall DetachNVStat();

#endif // NVSTATDRIVER

#ifdef NV_TRACKAGP
void __Reset (void);
#endif //NV_TRACKAGP

/*
 * Define the Z-Buffer/Stencil Buffer Formats supported.
 * 16bit Formats should appear first in the data structure and then 24/32 bit formats.
 */
#define NV_NUM_16BIT_ZBUFFER_FORMATS    1
#define NV_NUM_ZBUFFER_FORMATS          3

typedef struct _def_zpixel_formats
{
    DWORD           dwNumZFormats;
    DDPIXELFORMAT   NvZBufferFormats[NV_NUM_ZBUFFER_FORMATS];
} ZPIXELFORMATS;

static  ZPIXELFORMATS  NvZPixelFormats =
{
    NV_NUM_ZBUFFER_FORMATS,
    {
        /*
         * 16 bit z buffer
         */
        {
            sizeof (DDPIXELFORMAT),                 // dwSize
            DDPF_ZBUFFER,                           // dwFlags
            0,                                      // dwFourCC (Not used)
            16,                                     // dwZBufferBitDepth
            0,                                      // dwStencilBitDepth
            0x0000FFFF,                             // dwZBitMask
            0x00000000,                             // dwStencilBitMask
            0x00000000                              // dwRGBZBitMask (Not used)
        },
        /*
         * 24 bit z-buffer, no stencil
         */
        {
            sizeof (DDPIXELFORMAT),                 // dwSize
            DDPF_ZBUFFER,                           // dwFlags
            0,                                      // dwFourCC (Not used)
            24,                                     // dwZBufferBitDepth
            0,                                      // dwStencilBitDepth
            0xFFFFFF00,                             // dwZBitMask
            0x00000000,                             // dwStencilBitMask
            0x00000000                              // dwRGBZBitMask (Not used)
        },
        /*
         * 24 bit z-buffer, 8 bit stencil
         */
        {
            sizeof (DDPIXELFORMAT),                 // dwSize
            DDPF_ZBUFFER | DDPF_STENCILBUFFER,      // dwFlags
            0,                                      // dwFourCC (Not used)
            32,                                     // dwZBufferBitDepth - This is so brain dead.  MS needs to learn consistency.
            8,                                      // dwStencilBitDepth
            0xFFFFFF00,                             // dwZBitMask
            0x000000FF,                             // dwStencilBitMask
            0x00000000                              // dwRGBZBitMask (Not used)
        }
    }
};

#ifndef TEXFORMAT_CRD

// DX8 Texture/Z/Render formats
static DDPIXELFORMAT celsiusPixelFormatsDX8[] =
{
    CELSIUS_TEXTURE_FORMATS_DX8         // Texture formats defined in NVTEXFMTS.H
};

static DDPIXELFORMAT celsiusPixelFormatsDX8NoDXT[] =
{
    CELSIUS_TEXTURE_FORMATS_NO_DXT_DX8  // Texture formats defined in NVTEXFMTS.H
};
#if (NVARCH >= 0x020)
static DDPIXELFORMAT kelvinPixelFormatsDX8[] =
{
    KELVIN_TEXTURE_FORMATS_DX8         // Texture formats defined in NVTEXFMTS.H
};

static DDPIXELFORMAT kelvinPixelFormatsDX8NoDXT[] =
{
    KELVIN_TEXTURE_FORMATS_NO_DXT_DX8  // Texture formats defined in NVTEXFMTS.H
};
#endif // (NVARCH >= 0x020)

#endif  // !TEXFORMAT_CRD

//---------------------------------------------------------------------------

#ifndef WINNT
BOOL MyExtEscape (DWORD dwHead, int nEscapeID, int nInBytes, LPCSTR lpIn, int nOutBytes, LPSTR lpOut)
{
    DISPDRVDIRECTXCOMMON *pDXS;
    BOOL bRet;

    dbgTracePush ("MyExtEscape");

    nvAssert (pDXShare);

    // fetch the appropriate DXShare
    pDXS = getDXShare (pDXShare->dwRootHandle, dwHead);

    if (pDXS) {
        // get the DC handle for this pDXShare
        HDC hDC = nvCreateDCHandle (pDXS);
        nvAssert (GetObjectType(hDC));
        // make the escape call
        bRet = ExtEscape (hDC, nEscapeID, nInBytes, lpIn, nOutBytes, lpOut);
        // release the handle
        nvDestroyDCHandle (hDC);
    }
    else {
        // no heads are enabled
        bRet = FALSE;
    }

    dbgTracePop();
    return (bRet);
}
#endif // !WINNT

//---------------------------------------------------------------------------

DWORD WaitForIdle(BOOL bWait, BOOL bUseEvent)
{
    NvNotification *pDmaSyncNotifier = pDriverData->pDmaSyncNotifierFlat;
    LPPROCESSINFO   lpProcInfo;

    dbgTracePush ("WaitForIdle");

    if (bUseEvent) {
        lpProcInfo = pmGetProcess(pDriverData, GetCurrentProcessId());
        if ((lpProcInfo == NULL) || (lpProcInfo->hIdleSyncEvent3 == 0)) {
            DPF("WaitForIdle: Unable to get process ID, using NV_SLEEP");
            bUseEvent = FALSE;
        }
        else {
            NvResetEvent(lpProcInfo->hIdleSyncEvent3);
        }
    }

    if ((pDmaSyncNotifier == NULL) || (!getDC()->nvPusher.isValid())) {
        DPF("WaitForIdle: Invalid parameters");
        dbgTracePop();
        return (DD_OK);
    }

    // Waiting for a notifier with the FIFO in this state guarantees a hang
    if (pDriverData->dwFullScreenDOSStatus & (FSDOSSTATUS_RECOVERYNEEDED_D3D | FSDOSSTATUS_RECOVERYNEEDED_DDRAW)) {
        DPF("WaitForIdle: Early exit due to DosOccurred flag");
        dbgTracePop();
        return (DD_OK);
    }

    pDriverData->TwoDRenderingOccurred = 1;

    // wait for other dma channels to go idle
    getDC()->nvPusher.waitForOtherChannels();

    // MUST wait for any pending notification to prevent possible loss of notification serialization
    if (!bUseEvent && bWait) {
        while ((volatile)pDmaSyncNotifier->status == NV_IN_PROGRESS) NV_SLEEP;
#ifdef CAPTURE
        if (getDC()->nvD3DRegistryData.regCaptureEnable & D3D_REG_CAPTUREENABLE_RECORD) {
            CAPTURE_SYNC3 sync;
            sync.dwJmpCommand         = CAPTURE_JMP_COMMAND;
            sync.dwExtensionSignature = CAPTURE_EXT_SIGNATURE;
            sync.dwExtensionID        = CAPTURE_XID_SYNC3;
            sync.dwType               = CAPTURE_SYNC3_TYPE_NOTIFIER;
            sync.dwCtxDMAHandle       = NV_DD_DMA_SYNC_NOTIFIER_CONTEXT_DMA_TO_MEMORY;
            sync.dwOffset             = 0;
            sync.dwValue              = 0;
            captureLog (&sync,sizeof(sync));
        }
#endif // CAPTURE
    }

    pDmaSyncNotifier->status = NV_IN_PROGRESS;

    nvPushData (0, dDrawSubchannelOffset(NV_DD_ROP_RECT_AND_TEXT) + RECT_AND_TEXT_NOTIFY_OFFSET | 0x40000);
    nvPushData (1, ((bWait && bUseEvent) ? NV04A_NOTIFY_WRITE_THEN_AWAKEN : 0));
    nvPushData (2, dDrawSubchannelOffset(NV_DD_ROP_RECT_AND_TEXT) + RECT_AND_TEXT_NO_OPERATION_OFFSET | 0x40000);
    nvPushData (3, 0);

    nvPusherAdjust (4);
    nvPusherStart  (TRUE);

    if (bWait) {
        if (bUseEvent) {
            if (IS_EVENT_ERROR(NvWaitEvent(lpProcInfo->hIdleSyncEvent3, 500))) {
                // timeout, our process list must be messed up
                EVENT_ERROR;
            }
        } else {
            while ((volatile)pDmaSyncNotifier->status == NV_IN_PROGRESS) NV_SLEEP;
#ifdef CAPTURE
            if (getDC()->nvD3DRegistryData.regCaptureEnable & D3D_REG_CAPTUREENABLE_RECORD) {
                CAPTURE_SYNC3 sync;
                sync.dwJmpCommand         = CAPTURE_JMP_COMMAND;
                sync.dwExtensionSignature = CAPTURE_EXT_SIGNATURE;
                sync.dwExtensionID        = CAPTURE_XID_SYNC3;
                sync.dwType               = CAPTURE_SYNC3_TYPE_NOTIFIER;
                sync.dwCtxDMAHandle       = NV_DD_DMA_SYNC_NOTIFIER_CONTEXT_DMA_TO_MEMORY;
                sync.dwOffset             = 0;
                sync.dwValue              = 0;
                captureLog (&sync,sizeof(sync));
            }
#endif // CAPTURE
        }
    }
    else {
        NV_SLEEP;
        if (pDmaSyncNotifier->status == NV_IN_PROGRESS) {
            dbgTracePop();
            return (DDERR_WASSTILLDRAWING);
        }
    }

    dbgTracePop();
    return (DD_OK);
}

//---------------------------------------------------------------------------
#ifndef WINNT // HAL function not present under NT
/*
 * SetMode32

    This API call is only made on boards which do not have an
    associated display driver -- i.e. the 3D only boards. We
    should never see this on an NVidia board.
 */
DWORD __stdcall SetMode32( LPDDHAL_SETMODEDATA lpSetModeData )
{
    dbgTracePush ("SetMode32");

    nvSetDriverDataPtrFromDDGbl (lpSetModeData->lpDD);

    pDriverData->dwUseRefreshRate = lpSetModeData->useRefreshRate;

#if 0
    // Call back to 16 bit direct draw code to set mode
    MyExtEscape(NVSETDDRAWMODE, 0, 0, 0, 0);
#endif

    lpSetModeData->ddRVal = DD_OK;

    NvReleaseSemaphore(pDriverData);
    dbgTracePop();
    return (DDHAL_DRIVER_HANDLED);
}
#endif // !WINNT

//---------------------------------------------------------------------------

/*
 * Lock32
 */
DWORD __stdcall Lock32 (LPDDHAL_LOCKDATA lpLockData)
{
    HRESULT                     ddrval = DDHAL_DRIVER_NOTHANDLED;
    DWORD                       dwCaps;
    LPDDRAWI_DDRAWSURFACE_GBL   psurf_gbl;

    dbgTracePush ("Lock32: fpvidmem = %08x", lpLockData->lpDDSurface->lpGbl->fpVidMem);

    dwCaps = lpLockData->lpDDSurface->ddsCaps.dwCaps;

    if (dwCaps & DDSCAPS_EXECUTEBUFFER)
    {
        // silly hack for screwed up kernel calls
        DWORD dwRetVal;
        dwRetVal = D3DLockExecuteBuffer32(lpLockData);
        dbgTracePop();
        return dwRetVal;
    }

    DDSTARTTICK(SURF4_LOCK);
    nvSetDriverDataPtrFromDDGbl (lpLockData->lpDD);

    lpLockData->ddRVal = DD_OK;

    // DO THIS FIRST!! We shouldn't assign pointers below first,
    // because if we end up resetting nv via nvEnable32, the pointers
    // may have changed in the pDriverData structure.

    // Reset NV and get the monitor frequency after a mode reset
    if (getDC()->dwEnableStatus != CDriverContext::DC_ENABLESTATUS_ENABLED) {
        getDC()->nvPusher.waitForOtherChannels();
        if (!nvEnable32 (lpLockData->lpDD)) {
            NvReleaseSemaphore(pDriverData);
            DDENDTICK(SURF4_CREATESURFACE);
            lpLockData->ddRVal = DDERR_OUTOFMEMORY;
            dbgTracePop();
            return DDHAL_DRIVER_HANDLED;
        }
    }

    /*
     * NOTES:
     *
     * This callback is invoked whenever a surface is about to be directly
     * accessed by the user.   This is where you need to make sure that
     * a surface can be safely accessed by the user.
     *
     * If your memory cannot be accessed while in accelerator mode, you
     * should either take the card out of accelerator mode or else
     * return DDERR_SURFACEBUSY
     *
     * If someone is accessing a surface that was just flipped away from,
     * make sure that the old surface (what was the primary) has finished
     * being displayed.
     */

    dwCaps = lpLockData->lpDDSurface->ddsCaps.dwCaps;

    psurf_gbl = lpLockData->lpDDSurface->lpGbl;

    if (pDriverData->dwFullScreenDOSStatus & (FSDOSSTATUS_RECOVERYNEEDED_D3D | FSDOSSTATUS_RECOVERYNEEDED_DDRAW)) {
        if (pDriverData->dwFullScreenDOSStatus & FSDOSSTATUS_COMPLETE) {
            if (pDriverData->dwFullScreenDOSStatus & FSDOSSTATUS_RECOVERYNEEDED_D3D) {
                nvD3DRecover();
            }
            if (pDriverData->dwFullScreenDOSStatus & FSDOSSTATUS_RECOVERYNEEDED_DDRAW) {
                nvDDrawRecover();
            }
        }
        else {
            lpLockData->ddRVal = DDERR_SURFACEBUSY;
            DDENDTICK(SURF4_LOCK);
            NvReleaseSemaphore(pDriverData);
            dbgTracePop();
            return (DDHAL_DRIVER_HANDLED);
        }
    }

    if (((!getDC()->nvPusher.isValid()) && (dwCaps & DDSCAPS_VIDEOMEMORY)) || // Mode switches might occur without warning
        (IS_OVERLAY(dwCaps,psurf_gbl->ddpfSurface.dwFourCC) && pDriverData->vpp.dwOverlayFSOvlLost)) {    // overlay capability has vanished
        lpLockData->ddRVal = DDERR_SURFACELOST;
        DDENDTICK(SURF4_LOCK);
        NvReleaseSemaphore(pDriverData);
        dbgTracePop();
        return (DDHAL_DRIVER_HANDLED);
    }

#ifdef CAPTURE
    CNvObject *pNvObj_cap = GET_PNVOBJ(lpLockData->lpDDSurface);
    DWORD      dwHeap_cap = 0;
    DWORD      dwOffset_cap, dwSize_cap;
    if (getDC()->nvD3DRegistryData.regCaptureEnable & D3D_REG_CAPTUREENABLE_RECORD) {
        if (pNvObj_cap) {
            if (pNvObj_cap->getTexture()) {
                dwHeap_cap   = pNvObj_cap->getTexture()->getSwizzled()->getHeapLocation();
                dwOffset_cap = pNvObj_cap->getTexture()->getSwizzled()->getOffset();
                dwSize_cap   = pNvObj_cap->getTexture()->getSize();
            }
            else if (pNvObj_cap->getVertexBuffer()) {
                dwHeap_cap   = pNvObj_cap->getVertexBuffer()->getHeapLocation();
                dwOffset_cap = pNvObj_cap->getVertexBuffer()->getOffset();
                dwSize_cap   = pNvObj_cap->getVertexBuffer()->getSize();
            }
            else if (pNvObj_cap->getSimpleSurface()) {
                dwHeap_cap   = pNvObj_cap->getSimpleSurface()->getHeapLocation();
                dwOffset_cap = pNvObj_cap->getSimpleSurface()->getOffset();
                dwSize_cap   = pNvObj_cap->getSimpleSurface()->getSize();
            }
            else if (pNvObj_cap->getPaletteSurface()) {
                dwHeap_cap   = pNvObj_cap->getPaletteSurface()->getHeapLocation();
                dwOffset_cap = pNvObj_cap->getPaletteSurface()->getOffset();
                dwSize_cap   = pNvObj_cap->getPaletteSurface()->getSize();
            }
        }
        if (dwHeap_cap) {
            CAPTURE_LOCK lock;
            lock.dwJmpCommand         = CAPTURE_JMP_COMMAND;
            lock.dwExtensionSignature = CAPTURE_EXT_SIGNATURE;
            lock.dwExtensionID        = CAPTURE_XID_LOCK;
            lock.dwType               = CAPTURE_LOCK_TYPE_LOCK;
            lock.dwCtxDMAHandle       = (dwHeap_cap == CSimpleSurface::HEAP_VID)
                                      ? NV_DD_DMA_CONTEXT_DMA_IN_VIDEO_MEMORY
                                      : D3D_CONTEXT_DMA_HOST_MEMORY;
            lock.dwOffset             = dwOffset_cap;
            captureLog (&lock, sizeof(lock));
        }
    }
#endif

    /*
     * Check for texture lock BEFORE syncing hard
     */
    if (dwCaps & DDSCAPS_TEXTURE) {
        /*
         * get texture
         */
        CTexture *pTexture = GET_PNVOBJ(lpLockData->lpDDSurface)->getTexture();
        /*
         * user wants to lock a texture - process elsewhere
         */
        if (IS_VALID_PNVOBJ(pTexture))
        {
            ddrval = nvTextureLock (pTexture,lpLockData);
            DDENDTICK(SURF4_LOCK);
            NvReleaseSemaphore(pDriverData);
            dbgTracePop();
            return ddrval;
        }
    }

#if (NVARCH >= 0x10)

    if (!(pDriverData->vpp.dwDecoderCaps & NVOCID2_OS_SCHEDULED)) {
        if (psurf_gbl->ddpfSurface.dwFlags & DDPF_FOURCC) {
            if ((psurf_gbl->ddpfSurface.dwFourCC == FOURCC_NVMC) ||
                (psurf_gbl->ddpfSurface.dwFourCC == FOURCC_NVDS)) { // Is it our motion comp. control surface ?
                LPNVMCFRAMEDATA lpNvMCFrameData = (LPNVMCFRAMEDATA) VIDMEM_ADDR(psurf_gbl->fpVidMem);
#ifdef WINNT
                lpNvMCFrameData->dwMCNvExecute = NULL;
                lpNvMCFrameData->dwMCMultiMonID = 0;
#else // !WINNT
                lpNvMCFrameData->dwMCNvExecute = (PFUNC)nvMoCompExecute;
                lpNvMCFrameData->dwMCMultiMonID = (DWORD)pDXShare;
#endif // !WINNT
                if (psurf_gbl->ddpfSurface.dwFourCC == FOURCC_NVMC) // Don't trash NVDS surfaces
                    lpNvMCFrameData->bMCDestinationSurfaceIndex = 255;
                lpNvMCFrameData->bMCForwardSurfaceIndex = 255;
                lpNvMCFrameData->bMCBackwardSurfaceIndex = 255;
                lpNvMCFrameData->bMCEndOfPicture = FALSE;
                pDriverData->bMCNewFrame = TRUE;
                DDENDTICK(SURF4_LOCK);
                NvReleaseSemaphore(pDriverData);
                dbgTracePop();
                return (DDHAL_DRIVER_NOTHANDLED);
            }

            else if (psurf_gbl->ddpfSurface.dwFourCC == FOURCC_NVID) { // Is it a motion comp. IDCT surface ?

                if (lpLockData->lpDDSurface != (LPDDRAWI_DDRAWSURFACE_LCL)pDriverData->dwMCIDCTSurface) {

                    for (DWORD dwIndex=0; dwIndex<4; dwIndex++) {
                        if (lpLockData->lpDDSurface == (LPDDRAWI_DDRAWSURFACE_LCL)pDriverData->dwMCNVIDSurface[dwIndex]) {
                            break;
                        }
                    }

                    if (dwIndex < 4) {

                        if (!getDC()->pRefCount->wait (CReferenceCount::WAIT_COOPERATIVE,
                                                       pDriverData->dwMCNVIDSurfaceReferenceCount[dwIndex],
                                                       1)) {
                             NvReleaseSemaphore(pDriverData);
                             lpLockData->ddRVal = DDERR_WASSTILLDRAWING;
                             DDENDTICK(SURF4_LOCK);
                             dbgTracePop();
                             return (DDHAL_DRIVER_HANDLED);
                        }
                    }
                }

                DDENDTICK(SURF4_LOCK);
                NvReleaseSemaphore(pDriverData);
                dbgTracePop();
                return (DDHAL_DRIVER_NOTHANDLED);
            }

            else if (psurf_gbl->ddpfSurface.dwFourCC == FOURCC_NV12) { // Is it a motion comp. image surface ?

                LPNVMCSURFACEFLAGS lpSurfaceFlags = (LPNVMCSURFACEFLAGS)&pDriverData->nvMCSurfaceFlags[0];

                while ((lpSurfaceFlags->dwMCSurfaceBase != 0) &&
                       (lpSurfaceFlags->dwMCSurfaceBase != psurf_gbl->fpVidMem)) {
                    lpSurfaceFlags++;
                }

                if (lpLockData->lpDDSurface == (LPDDRAWI_DDRAWSURFACE_LCL)pDriverData->dwMCDestinationSurface) {
                    if (lpLockData->dwFlags & DDLOCK_READONLY) {
                        if (!getDC()->pRefCount->wait (CReferenceCount::WAIT_COOPERATIVE,
                                                       lpSurfaceFlags->dwMCMotionCompReferenceCount,
                                                       0)) {
                            lpLockData->ddRVal = DDERR_WASSTILLDRAWING;
                        }
                    }
                    else {

                        if ((!getDC()->pRefCount->wait (CReferenceCount::WAIT_COOPERATIVE,
                                                        lpSurfaceFlags->dwMCMotionCompReferenceCount,
                                                        0))
                            ||
                            (!getDC()->pRefCount->wait (CReferenceCount::WAIT_COOPERATIVE,
                                                        lpSurfaceFlags->dwMCFormatCnvReferenceCount,
                                                        0))) {
                            lpLockData->ddRVal = DDERR_WASSTILLDRAWING;
                        }
                    }
                }
                else if ((lpLockData->lpDDSurface == (LPDDRAWI_DDRAWSURFACE_LCL)pDriverData->dwMCForwardSurface) ||
                         (lpLockData->lpDDSurface == (LPDDRAWI_DDRAWSURFACE_LCL)pDriverData->dwMCBackwardSurface)) {
                    if (!(lpLockData->dwFlags & DDLOCK_READONLY)) {
                        if (!getDC()->pRefCount->wait (CReferenceCount::WAIT_COOPERATIVE,
                                                       lpSurfaceFlags->dwMCMotionCompReferenceCount,
                                                       0)) {
                            lpLockData->ddRVal = DDERR_WASSTILLDRAWING;
                        }
                    }
                }

                // If DXVA locks this NV12 surface it means the decoder is probably going to
                // change the contents, so force a reconversion from NV12 to YUY2 at Flip32 time.
                if (pDriverData->dwDXVAFlags & DXVA_MO_COMP_IN_PROGRESS)
                    lpSurfaceFlags->bMCFrameAlreadyFormatConverted = 0;

                DDENDTICK(SURF4_LOCK);
                NvReleaseSemaphore(pDriverData);
                dbgTracePop();
                if (lpLockData->ddRVal != DD_OK) {
                    return DDHAL_DRIVER_HANDLED;
                } else {
                    return DDHAL_DRIVER_NOTHANDLED;
                }
            }
        }
    }

#endif  // NVARCH >= 0x10

#if (NVARCH >= 0x010)
    // Handle AA: When locking a render target or Z buffer, minify first.
    if (getDC()->dwAAContextCount >= 1)
    {
#if (NVARCH >= 0x020)
        if (pDriverData->nvD3DPerfData.dwNVClasses & NVCLASS_FAMILY_KELVIN) {
            CNvObject *pObj = GET_PNVOBJ(lpLockData->lpDDSurface);
            if (pObj) {
                PNVD3DCONTEXT pContext = nvCelsiusAAFindContext(pObj->getSimpleSurface());
                if (pContext)
                {
                    CKelvinAAState::AccessType access = (lpLockData->dwFlags & DDLOCK_READONLY) ? CKelvinAAState::ACCESS_READ : CKelvinAAState::ACCESS_WRITE;
                    access = (lpLockData->dwFlags & DDLOCK_DISCARDCONTENTS) ? CKelvinAAState::ACCESS_WRITE_DISCARD : access;

                    if ((pObj->getSimpleSurface() == pContext->pRenderTarget)) {
                        pContext->kelvinAA.GrantAccess(CKelvinAAState::BUFFER_RT, access, false, true);
                    }
                    if ((pContext->pZetaBuffer) && (pObj->getSimpleSurface() == pContext->pZetaBuffer)) {
                        pContext->kelvinAA.GrantAccess(CKelvinAAState::BUFFER_ZB, access, false, true);
                    }
                }
            }
        } else
#endif
        if (pDriverData->nvD3DPerfData.dwNVClasses & NVCLASS_FAMILY_CELSIUS) {
            CNvObject *pObj = GET_PNVOBJ(lpLockData->lpDDSurface);
            if (pObj) {
                PNVD3DCONTEXT pContext = nvCelsiusAAFindContext(pObj->getSimpleSurface());
                if (pContext && pContext->aa.isInit())
                {
                    if ((pObj->getSimpleSurface() == pContext->pRenderTarget)) {
                        pContext->aa.Lock(pContext);
                    }
                    if ((pContext->pZetaBuffer) && (pObj->getSimpleSurface() == pContext->pZetaBuffer)) {
                        pContext->aa.LockZ(pContext);
                    }
                }
            }
        }
    }
#endif  // NVARCH >= 0x010

    // determine conditions under which a wait is required
    BOOL bWrite = !(lpLockData->dwFlags & DDLOCK_READONLY);

    if (lpLockData->dwFlags & DDLOCK_WAIT) {
        if (bWrite) { // wait is only required if we intend to write to this surface
            // wait for flip if scanning out from this surface
            ddrval = getFlipStatus (psurf_gbl->fpVidMem, dwCaps);
            while (ddrval != DD_OK) {
                NV_SLEEP;
                ddrval = getFlipStatus (psurf_gbl->fpVidMem, dwCaps);
            }
        }
        // flush out all blit and clear operations
        if (IS_OVERLAY(dwCaps,psurf_gbl->ddpfSurface.dwFourCC) ||
            psurf_gbl->ddpfSurface.dwFourCC == FOURCC_NV12 ||
            psurf_gbl->ddpfSurface.dwFourCC == FOURCC_NVID ||
            psurf_gbl->ddpfSurface.dwFourCC == FOURCC_NVMC ||
            psurf_gbl->ddpfSurface.dwFourCC == FOURCC_NVDS ||
            psurf_gbl->ddpfSurface.dwFourCC == FOURCC_NVSP ||
           (lpLockData->lpDDSurface->ddsCaps.dwCaps & (DDSCAPS_VIDEOPORT | DDSCAPS_HWCODEC | DDSCAPS_PRIMARYSURFACE))) {
            // yielding stall for video
            WaitForIdle(TRUE, TRUE);
        } else {
            // polling stall for D3D
            getDC()->nvPusher.flush (TRUE, CPushBuffer::FLUSH_WITH_DELAY);
        }

        if (lpLockData->lpDDSurface->ddsCaps.dwCaps & (DDSCAPS_FRONTBUFFER | DDSCAPS_PRIMARYSURFACE | DDSCAPS_VISIBLE)) {
#ifdef WINNT
            nvDDrawSynWithNvGdiDrv(ppdev);
#else
            // flush out all GDI blits (MS does this for us in all cases except the primary)
            void *lpPDevice = GET_HALINFO()->lpPDevice;
            DrvCallbackFunc(NV_DRVSERVICE_BEGINACCESS, lpPDevice, NULL);
#endif
        }
    } else {
        // return error code if required
        if ((bWrite && (getFlipStatus (psurf_gbl->fpVidMem, dwCaps) != DD_OK)) || !getDC()->nvPusher.isIdle(TRUE)) {
            lpLockData->ddRVal = DDERR_WASSTILLDRAWING;
            DDENDTICK(SURF4_LOCK);
            NvReleaseSemaphore(pDriverData);
            dbgTracePop();
            return (DDHAL_DRIVER_HANDLED);
        }
#ifdef WINNT
        if (lpLockData->lpDDSurface->ddsCaps.dwCaps & (DDSCAPS_FRONTBUFFER | DDSCAPS_PRIMARYSURFACE | DDSCAPS_VISIBLE)) 
        {
            nvDDrawSynWithNvGdiDrv(ppdev);
        }
#endif
    }

    if ((pDriverData->pGenericScaledImageNotifier->status == NV_IN_PROGRESS) &&
        (pDriverData->NvDmaFromMemSurfaceMem == psurf_gbl->fpVidMem)) {
        lpLockData->ddRVal = DDERR_WASSTILLDRAWING;
        DDENDTICK(SURF4_LOCK);
        NvReleaseSemaphore(pDriverData);
        dbgTracePop();
        return (DDHAL_DRIVER_HANDLED);
    }

    //
    // check if at least one 3d context exists
    //
    if ((getDC()->dwD3DContextCount > 0)
     && (pDriverData->nvD3DPerfData.dwPerformanceStrategy & (PS_CONTROL_TRAFFIC_16 | PS_CONTROL_TRAFFIC_32)))
    {
        CNvObject *pNvObj = GET_PNVOBJ(lpLockData->lpDDSurface);

        // test for traffic control
        if (dwCaps & DDSCAPS_ZBUFFER)
        {
            if (IS_VALID_PNVOBJ(pNvObj) && pNvObj->hasCTEnabled())
            {
                pNvObj->tagZLock();
                pNvObj->disableCT();
                nvCTDecodeBuffer (pNvObj,
                                  VIDMEM_ADDR(psurf_gbl->fpVidMem),
                                  psurf_gbl->ddpfSurface.dwRGBBitCount >> 3,
                                  psurf_gbl->lPitch,
                                  psurf_gbl->wWidth,
                                  psurf_gbl->wHeight);
            }
        }
        else
        {
            PNVD3DCONTEXT pContext = (PNVD3DCONTEXT)getDC()->dwContextListHead;
            while (pContext)
            {
                if ((pContext->pRenderTarget) &&
                    (pContext->pRenderTarget->getWrapper() == pNvObj))
                {
                    if (pContext->pZetaBuffer)
                    {
                        nvAssert (pContext->pZetaBuffer->getWrapper());
                        pContext->pZetaBuffer->getWrapper()->tagFLock();
                    }
                    break;
                }
                pContext = pContext->pContextNext;
            }
        }
    }

    // Note that this may return NULL
    CNvObject *pNvObj;
    pNvObj = GET_PNVOBJ(lpLockData->lpDDSurface);

    if ((dwCaps & DDSCAPS_VIDEOMEMORY) && ((dwCaps & DDSCAPS_TEXTURE) == 0)) {
        // No need to lock textures even though they may currently be in use because
        //     their surface memory is not used directly when rendering
        // Every other surface type with DDSCAPS_VIDMEMORY set does need locked however
        if(pNvObj && pNvObj->getSimpleSurface())
        {
            DDLOCKINDEX(NVSTAT_LOCK_VID_TEX);
            pNvObj->getSimpleSurface()->cpuLock(CSimpleSurface::LOCK_NORMAL);
            if (dwCaps & DDSCAPS_BACKBUFFER)
            {
                // avoid clearing the render target in 3D Mark 2000
                pNvObj->setRTLocked();
            }
        }
    }

#ifdef  STEREO_SUPPORT
    BOOL bLockSubstituted = StereoLockSubstitute(lpLockData);
#endif  //STEREO_SUPPORT


    if (pNvObj
#ifdef  STEREO_SUPPORT
        && bLockSubstituted == FALSE
#endif  //STEREO_SUPPORT
        )
    {
        // update MS cached pointer, which might be different if we renamed or otherwise
        // recreated the surface
        CSimpleSurface *pSurface = pNvObj->getSimpleSurface();

        if (pSurface) {
            switch(pSurface->getHeapLocation()) {
            case CSimpleSurface::HEAP_VID:
                psurf_gbl->fpVidMem = pSurface->getfpVidMem();
                break;
#ifdef NV_AGP
            case CSimpleSurface::HEAP_AGP:
                psurf_gbl->fpVidMem = nvAGPGetUserAddr(pSurface->getAddress());
                break;
#endif
            }
        }
    }

#ifndef WINNT
    // Currently works only for pDriverData->bi.biBitCount pixel depth surfaces
    DWORD dwOffset;
    if (lpLockData->bHasRect) {
        dwOffset = lpLockData->rArea.top * psurf_gbl->lPitch;
        dwOffset += (lpLockData->rArea.left * (GET_MODE_BPP() >> 3));
    }
    else {
        dwOffset = 0;
    }

    lpLockData->lpSurfData = (VOID *)((DWORD)psurf_gbl->fpVidMem + dwOffset);
#endif // !WINNT

#ifdef  STEREO_SUPPORT
    if (bLockSubstituted && lpLockData->ddRVal == DD_OK)
    {
        //We can't return DDHAL_DRIVER_NOTHANDLED for stereo if we really want to fool DX and substitute the
        //stereo buffer address. Otherwise DX retrieves the buffer address from its own internal structures
        //depending on the surface capabilities sometimes ignoring what we specified in the lpLockData->lpSurfData
        //or psurf_gbl->fpVidMem. For instance for the front buffer it retrieves the memory address from
        //LPDDRAWI_DIRECTDRAW_GBL->vmiData.fpPrimary. It is a pain in the ... for us to handle all the cases.
        //If we return DDHAL_DRIVER_HANDLED though it uses lpLockData->lpSurfData for sure (Andrei Osnovich).
        ddrval = DDHAL_DRIVER_HANDLED;
    }
#endif  //STEREO_SUPPORT

    DDENDTICK(SURF4_LOCK);
    NvReleaseSemaphore(pDriverData);
    dbgTracePop();
    return ddrval;

}  // Lock32

//---------------------------------------------------------------------------

/*
 * Unlock32
 */
DWORD __stdcall Unlock32( LPDDHAL_UNLOCKDATA lpUnlockData )
{
    LPDDRAWI_DDRAWSURFACE_GBL   pDDSGbl;
    DWORD                       caps;
    DWORD   ddrval;

    dbgTracePush ("Unlock32: fpvidmem = %08x", lpUnlockData->lpDDSurface->lpGbl->fpVidMem);

    if (lpUnlockData->lpDDSurface->ddsCaps.dwCaps & DDSCAPS_EXECUTEBUFFER )
    {
        //silly hack for screwed up kernel calls
        DWORD dwRetVal;
        dwRetVal = D3DUnlockExecuteBuffer32(lpUnlockData);
        dbgTracePop();
        return dwRetVal;
    }

    DDSTARTTICK(SURF4_UNLOCK);
    nvSetDriverDataPtrFromDDGbl (lpUnlockData->lpDD);

    caps = lpUnlockData->lpDDSurface->ddsCaps.dwCaps;

    if ((!getDC()->nvPusher.isValid()) && (caps & DDSCAPS_VIDEOMEMORY)) {  /* Mode switches might occur without warning */
        lpUnlockData->ddRVal = DDERR_SURFACELOST;
        DDENDTICK(SURF4_UNLOCK);
        NvReleaseSemaphore(pDriverData);
        dbgTracePop();
        return (DDHAL_DRIVER_HANDLED);
    }

#ifdef CAPTURE
    CNvObject *pNvObj_cap = GET_PNVOBJ(lpUnlockData->lpDDSurface);
    DWORD      dwHeap_cap = 0;
    DWORD      dwAddr_cap, dwOffset_cap, dwSize_cap;
    if (getDC()->nvD3DRegistryData.regCaptureEnable & D3D_REG_CAPTUREENABLE_RECORD) {
        if (pNvObj_cap) {
            if (pNvObj_cap->getTexture()) {
                dwHeap_cap   = pNvObj_cap->getTexture()->getSwizzled()->getHeapLocation();
                dwAddr_cap   = pNvObj_cap->getTexture()->getSwizzled()->getAddress();
                dwOffset_cap = pNvObj_cap->getTexture()->getSwizzled()->getOffset();
                dwSize_cap   = pNvObj_cap->getTexture()->getSize();
            }
            else if (pNvObj_cap->getVertexBuffer()) {
                dwHeap_cap   = pNvObj_cap->getVertexBuffer()->getHeapLocation();
                dwAddr_cap   = pNvObj_cap->getVertexBuffer()->getAddress();
                dwOffset_cap = pNvObj_cap->getVertexBuffer()->getOffset();
                dwSize_cap   = pNvObj_cap->getVertexBuffer()->getSize();
            }
            else if (pNvObj_cap->getSimpleSurface()) {
                dwHeap_cap   = pNvObj_cap->getSimpleSurface()->getHeapLocation();
                dwAddr_cap   = pNvObj_cap->getSimpleSurface()->getAddress();
                dwOffset_cap = pNvObj_cap->getSimpleSurface()->getOffset();
                dwSize_cap   = pNvObj_cap->getSimpleSurface()->getSize();
            }
            else if (pNvObj_cap->getPaletteSurface()) {
                dwHeap_cap   = pNvObj_cap->getPaletteSurface()->getHeapLocation();
                dwAddr_cap   = pNvObj_cap->getPaletteSurface()->getAddress();
                dwOffset_cap = pNvObj_cap->getPaletteSurface()->getOffset();
                dwSize_cap   = pNvObj_cap->getPaletteSurface()->getSize();
            }
        }
        if (dwHeap_cap) {
            CAPTURE_LOCK lock;
            lock.dwJmpCommand         = CAPTURE_JMP_COMMAND;
            lock.dwExtensionSignature = CAPTURE_EXT_SIGNATURE;
            lock.dwExtensionID        = CAPTURE_XID_LOCK;
            lock.dwType               = CAPTURE_LOCK_TYPE_UNLOCK;
            lock.dwCtxDMAHandle       = (dwHeap_cap == CSimpleSurface::HEAP_VID)
                                      ? NV_DD_DMA_CONTEXT_DMA_IN_VIDEO_MEMORY
                                      : D3D_CONTEXT_DMA_HOST_MEMORY;
            lock.dwOffset             = dwOffset_cap;
            captureLog (&lock, sizeof(lock));
        }
    }
#endif

    /*
     * Signal that the texture surface has been unlocked.
     */
    if (caps & DDSCAPS_TEXTURE) {
        /*
         * get texture
         */
        CTexture *pTexture = GET_PNVOBJ(lpUnlockData->lpDDSurface)->getTexture();

        /*
         * user wants to unlock a texture - process elsewhere
         */
        if (IS_VALID_PNVOBJ(pTexture))
        {
            ddrval = nvTextureUnlock(pTexture,lpUnlockData);
            DDENDTICK(SURF4_UNLOCK);
            NvReleaseSemaphore(pDriverData);
            dbgTracePop();
            return ddrval;
        }
    }

    if ((caps & DDSCAPS_VIDEOMEMORY) && ((caps & DDSCAPS_TEXTURE) == 0)) {
        //unlock the video surface
        CNvObject *pNvObj;
        pNvObj = GET_PNVOBJ(lpUnlockData->lpDDSurface);
        if(pNvObj && pNvObj->getSimpleSurface()) pNvObj->getSimpleSurface()->cpuUnlock();
    }

#ifdef  STEREO_SUPPORT
    StereoLockSubstituteRestore(lpUnlockData);
#endif  //STEREO_SUPPORT

    pDDSGbl = lpUnlockData->lpDDSurface->lpGbl;

#ifndef WINNT
        if (lpUnlockData->lpDDSurface->ddsCaps.dwCaps & (DDSCAPS_FRONTBUFFER | DDSCAPS_PRIMARYSURFACE | DDSCAPS_VISIBLE)) {
            // signal "end access" to the display driver
            void *lpPDevice = GET_HALINFO()->lpPDevice;
            DrvCallbackFunc(NV_DRVSERVICE_ENDACCESS, lpPDevice, NULL);
        }
#endif

    if (IS_OVERLAY(caps,pDDSGbl->ddpfSurface.dwFourCC) &&
        (pDDSGbl->ddpfSurface.dwFourCC != FOURCC_NV12) &&
        ((caps & (DDSCAPS_VISIBLE | DDSCAPS_FRONTBUFFER)) ||
         (pDriverData->vpp.dwOverlaySurfaces < 3))) {

        // (H.AZAR: 08/17/99): surface must be visible to call VPP flip !
        if (!(caps & DDSCAPS_VIDEOPORT) && (caps & (DDSCAPS_VISIBLE
#ifndef WINNT
        | DDSCAPS_FRONTBUFFER
#endif
        )) && (pDriverData->bRing0FlippingFlag == FALSE)) {
            VppDoFlip(&(pDriverData->vpp),
                          pDDSGbl->fpVidMem - pDriverData->BaseAddress,
                          pDDSGbl->lPitch,
                          pDDSGbl->wWidth,
                          pDDSGbl->wHeight,
                          pDDSGbl->ddpfSurface.dwFourCC,
                          VPP_STATIC | VPP_WAIT);
        }
    }
#if (NVARCH >= 0x10)
    else if (pDDSGbl->ddpfSurface.dwFlags & DDPF_FOURCC) {
        if ((pDDSGbl->ddpfSurface.dwFourCC == FOURCC_NVMC) ||
            (pDDSGbl->ddpfSurface.dwFourCC == FOURCC_NVDS)) { // Is it our motion comp. control surface ?
            LPNVMCFRAMEDATA lpNvMCFrameData = (LPNVMCFRAMEDATA) VIDMEM_ADDR(pDDSGbl->fpVidMem);

            if (lpNvMCFrameData->bMCDestinationSurfaceIndex == 255) {
                lpUnlockData->ddRVal = DDERR_INVALIDPARAMS;
                DDENDTICK(SURF4_UNLOCK);
                NvReleaseSemaphore(pDriverData);
                dbgTracePop();
                return (DDHAL_DRIVER_HANDLED);
            } else if ((pDDSGbl->ddpfSurface.dwFourCC != FOURCC_NVDS) &&
                       (lpNvMCFrameData->bMCEndOfPicture))  {
                LPNVMCSURFACEFLAGS lpSurfaceFlags =
                    (LPNVMCSURFACEFLAGS)&pDriverData->nvMCSurfaceFlags[0];

                while ((lpSurfaceFlags->dwMCSurfaceBase != 0) &&
                       (lpSurfaceFlags->dwMCSurfaceBase != pDriverData->dwMCMostRecentlyDecodedSurfaceBase)) {
                    lpSurfaceFlags++;
                }

                // Make sure surface has been format converted
                if (lpSurfaceFlags->dwMCSurfaceBase != 0) {
                    if ((lpSurfaceFlags->bMCPictureStructure == PICTURE_STRUCTURE_FRAME) &&
                        (lpSurfaceFlags->bMCFrameAlreadyFormatConverted < 15))
                        nvMoCompConvertSurfaceFormat(lpSurfaceFlags->dwMCSurfaceBase, TRUE, 15);
                    else if (lpSurfaceFlags->bMCPictureStructure == PICTURE_STRUCTURE_TOP_FIELD) {
                        if ((lpSurfaceFlags->bMCFrameAlreadyFormatConverted & 3) < 3)
                            nvMoCompConvertSurfaceFormat(lpSurfaceFlags->dwMCSurfaceBase, TRUE, 3);
                    } else if (lpSurfaceFlags->bMCPictureStructure == PICTURE_STRUCTURE_BOTTOM_FIELD) {
                        if (lpSurfaceFlags->bMCFrameAlreadyFormatConverted < 12)
                            nvMoCompConvertSurfaceFormat(lpSurfaceFlags->dwMCSurfaceBase, TRUE, 12);
                    }
                    if ((lpSurfaceFlags->bMCFrameAlreadyFormatConverted == 15) &&
                        (lpSurfaceFlags->bMCFrameIsFiltered == FALSE) &&
                        (pDriverData->bMCTemporalFilterDisabled == FALSE))
                        nvMoCompTemporalFilter(lpSurfaceFlags->dwMCSurfaceBase, pDriverData->bMCPercentCurrentField);
                }
            }
        }
    }
#endif  // NVARCH >= 0x10

#ifdef CAPTURE
    if (getDC()->nvD3DRegistryData.regCaptureEnable & D3D_REG_CAPTUREENABLE_RECORD) {
        if (dwHeap_cap) {
            CAPTURE_MEMORY_WRITE memwr;
            memwr.dwJmpCommand         = CAPTURE_JMP_COMMAND;
            memwr.dwExtensionSignature = CAPTURE_EXT_SIGNATURE;
            memwr.dwExtensionID        = CAPTURE_XID_MEMORY_WRITE;
            memwr.dwCtxDMAHandle       = (dwHeap_cap == CSimpleSurface::HEAP_VID)
                                       ? NV_DD_DMA_CONTEXT_DMA_IN_VIDEO_MEMORY
                                       : D3D_CONTEXT_DMA_HOST_MEMORY;
            memwr.dwOffset             = dwOffset_cap;
            memwr.dwSize               = dwSize_cap;
            captureLog (&memwr, sizeof(memwr));
            captureLog ((void*)dwAddr_cap, memwr.dwSize);
        }
    }
#endif

    // Handle AA: When unlocking a render target or Z buffer, magnify the
    // modified buffer back into the super buffer.
    // Scott C: Removed AA stuff, we'll leave the buffers as they are
    // (we just have to make sure to supersize the buffers if we start 3D
    // rendering again)

    lpUnlockData->ddRVal = DD_OK;

    DDENDTICK(SURF4_UNLOCK);
    NvReleaseSemaphore(pDriverData);
    dbgTracePop();
    return (DDHAL_DRIVER_HANDLED);

} /* Unlock32 */

//---------------------------------------------------------------------------

/*
 * WaitForVerticalBlank32
 */
// Old macro used when accessing raster register through the RM
#if 0
#define IS_IN_VBLANK(a) ((a)==0 || (a)>=(DWORD)GET_MODE_PHYSICAL_HEIGHT(cfgParams.Head))
#endif

// Macros used when accessing raster register directly
#define MASK_IN_VBLANK(a) (a & 0x00010000)
#define MASK_SCANLINE(a) (a & 0x000007FF)
#define VBLANK_REGISTER_OFFSET  0x600808    // Physical head 0, add 0x2000 for head 1

DWORD __stdcall WaitForVerticalBlank32 (LPDDHAL_WAITFORVERTICALBLANKDATA lpWaitForVerticalBlank)
{
    LONGLONG timeStart;
    LONGLONG timeFrequency;
    NV_CFGEX_CURRENT_SCANLINE_MULTI_PARAMS cfgParams;
    BOOL timeOut;
    #ifdef WINNT
    int dwTimeoutCount;
    #endif

    dbgTracePush ("WaitForVerticalBlank32");

    DDSTARTTICK(DEVICE_WAITVBL);
    nvSetDriverDataPtrFromDDGbl (lpWaitForVerticalBlank->lpDD);

    if (pDriverData->dwFullScreenDOSStatus & FSDOSSTATUS_RECOVERYNEEDED_D3D) {
        if (pDriverData->dwFullScreenDOSStatus & FSDOSSTATUS_COMPLETE) {
            nvD3DRecover();
        }
        else {
            lpWaitForVerticalBlank->ddRVal = DD_OK;
            DDENDTICK(DEVICE_WAITVBL);
            NvReleaseSemaphore(pDriverData);
            dbgTracePop();
            return (DDHAL_DRIVER_HANDLED);
        }
    }

#ifdef WINNT
    // under WINNT, we have a virtual desktop which spans both monitors, and it is not really possible
    // to make this work as a head specific thing, so just pick a head.
    cfgParams.Head = GET_CURRENT_HEAD();
    dwTimeoutCount = 1000000;
#else
    cfgParams.Head = pDXShare->dwPhysicalHeadNumber;
#endif

    if (GET_MODE_PHYSICAL_HEIGHT(cfgParams.Head) == 0) {
        // can have this degenerate case in win2k, a call into this routine without nvEnable being called
        // at a minimum, we need to init some of these display timing structures
        getDisplayDuration();
    }

    timeOut = FALSE;

    // **** IMPORTANT ****
    // The following piece of code could break with future versions of the chip
    // if the raster register is moved.  Unfortunately, accessing this register directly
    // is the only way to limit the time spent in this function and allow the
    // WHQL Surface Flipping test to succeed.
    // 02/02/2001 PG/Video group

    volatile DWORD* npNvRasterRegister;
    volatile DWORD dwRaster = 0;

    npNvRasterRegister = (DWORD*) pDriverData->NvBaseFlat;
    npNvRasterRegister += ((VBLANK_REGISTER_OFFSET + (cfgParams.Head == 1 ? 0x2000 : 0)) >> 2);

    switch ( lpWaitForVerticalBlank->dwFlags ) {

        case DDWAITVB_I_TESTVB:
            /*
             * if testvb is just a request for the current vertical blank status
             */
            lpWaitForVerticalBlank->ddRVal = DD_OK;

            /*
             * Monitor is on
             */

            // Read the raster register directly
            dwRaster = *npNvRasterRegister;

            lpWaitForVerticalBlank->bIsInVB = (MASK_IN_VBLANK(dwRaster) ? TRUE : FALSE);  // Bit 16 is one when in the VBLANK

            DDENDTICK(DEVICE_WAITVBL);
            NvReleaseSemaphore(pDriverData);
            dbgTracePop();
            return (DDHAL_DRIVER_HANDLED);

        case DDWAITVB_BLOCKBEGIN:

            // The following code is for debug of 20001211-143119.
            // I am having trouble accessing this fields using softice.
            //   ... and I don't know why. -mlavoie
            {
                DWORD physicalModeHeight = (DWORD)GET_MODE_PHYSICAL_HEIGHT(cfgParams.Head);
                DWORD physicalModeHeight2 = pDriverData->flipPrimaryRecord.nvTimingInfo[cfgParams.Head].VDisplayEnd;

            }

            /*
             * Monitor is ON
             */
            /*
             * if blockbegin is requested we wait until the vertical blank
             * is over, and then wait for the display period to end.
             */
            // get start time for timeouts (display may be disabled)
            QueryPerformanceFrequency((LARGE_INTEGER *)&timeFrequency);
            QueryPerformanceCounter((LARGE_INTEGER*)&timeStart);

            dwRaster = *npNvRasterRegister;
            cfgParams.RasterPosition = MASK_SCANLINE(dwRaster);  // Keep the raster position (bits 10:0)

            while (MASK_IN_VBLANK(dwRaster) && !timeOut) {
                dwRaster = *npNvRasterRegister;
                cfgParams.RasterPosition = MASK_SCANLINE(dwRaster);  // Keep the raster position (bits 10:0)
#ifdef WINNT
                if (dwTimeoutCount-- <= 0)
                    timeOut = TRUE;
#else
                LONGLONG timeNow;
                QueryPerformanceCounter((LARGE_INTEGER*)&timeNow);
                if ((timeNow - timeStart) >= (timeFrequency / 20)) timeOut = TRUE;  // timout of 1/20th of a second
#endif
            }
            while (!MASK_IN_VBLANK(dwRaster) && !timeOut) {
                dwRaster = *npNvRasterRegister;
                cfgParams.RasterPosition = MASK_SCANLINE(dwRaster);  // Keep the raster position (bits 10:0)
#ifdef WINNT
                if (dwTimeoutCount-- <= 0)
                    timeOut = TRUE;
#else
                LONGLONG timeNow;
                QueryPerformanceCounter((LARGE_INTEGER*)&timeNow);
                if ((timeNow - timeStart) >= (timeFrequency / 20)) timeOut = TRUE;  // timout of 1/20th of a second
#endif
            }

            lpWaitForVerticalBlank->ddRVal = DD_OK;
            DDENDTICK(DEVICE_WAITVBL);
            NvReleaseSemaphore(pDriverData);
            dbgTracePop();
            return (DDHAL_DRIVER_HANDLED);

        case DDWAITVB_BLOCKEND:

            /*
             * Monitor is ON
             */
            /*
             * if blockend is requested we wait for the vblank interval to end.
             */
            // get start time for timeouts (display may be disabled)
            QueryPerformanceFrequency((LARGE_INTEGER *)&timeFrequency);
            QueryPerformanceCounter((LARGE_INTEGER*)&timeStart);

            dwRaster = *npNvRasterRegister;
            cfgParams.RasterPosition = MASK_SCANLINE(dwRaster);  // Keep the raster position (bits 10:0)

            while (!MASK_IN_VBLANK(dwRaster) && !timeOut) {
                dwRaster = *npNvRasterRegister;
                cfgParams.RasterPosition = MASK_SCANLINE(dwRaster);  // Keep the raster position (bits 10:0)
#ifdef WINNT
                if (dwTimeoutCount-- <= 0)
                    timeOut = TRUE;
#else
                LONGLONG timeNow;
                QueryPerformanceCounter((LARGE_INTEGER*)&timeNow);
                if ((timeNow - timeStart) >= (timeFrequency / 20)) timeOut = TRUE;  // timout of 1/20th of a second
#endif
            }
            while (MASK_IN_VBLANK(dwRaster) && !timeOut) {
                dwRaster = *npNvRasterRegister;
                cfgParams.RasterPosition = MASK_SCANLINE(dwRaster);  // Keep the raster position (bits 10:0)
#ifdef WINNT
                if (dwTimeoutCount-- <= 0)
                    timeOut = TRUE;
#else
                LONGLONG timeNow;
                QueryPerformanceCounter((LARGE_INTEGER*)&timeNow);
                if ((timeNow - timeStart) >= (timeFrequency / 20)) timeOut = TRUE;  // timout of 1/20th of a second
#endif
            }

            lpWaitForVerticalBlank->ddRVal = DD_OK;
            DDENDTICK(DEVICE_WAITVBL);
            NvReleaseSemaphore(pDriverData);
            dbgTracePop();
            return (DDHAL_DRIVER_HANDLED);
    }

    DDENDTICK(DEVICE_WAITVBL);
    NvReleaseSemaphore(pDriverData);
    dbgTracePop();
    return (DDHAL_DRIVER_NOTHANDLED);

} /* WaitForVerticalBlank32 */

//---------------------------------------------------------------------------

/*
 * GetScanLine32
 */
DWORD __stdcall GetScanLine32( LPDDHAL_GETSCANLINEDATA lpGetScanLine )
{
    volatile DWORD* npNvRasterRegister;
    volatile DWORD dwRaster;
    NV_CFGEX_CURRENT_SCANLINE_MULTI_PARAMS cfgParams;
#if 0
    DWORD dwModeHeight;
#endif

    dbgTracePush ("GetScanLine32");

    DDSTARTTICK(DEVICE_GETSCANLINE);
    nvSetDriverDataPtrFromDDGbl (lpGetScanLine->lpDD);

    if (pDriverData->dwFullScreenDOSStatus & FSDOSSTATUS_RECOVERYNEEDED_D3D) {
        if (pDriverData->dwFullScreenDOSStatus & FSDOSSTATUS_COMPLETE) {
            nvD3DRecover();
        }
        else {
            lpGetScanLine->ddRVal = DDERR_VERTICALBLANKINPROGRESS;
            DDENDTICK(DEVICE_GETSCANLINE);
            NvReleaseSemaphore(pDriverData);
            dbgTracePop();
            return(DDHAL_DRIVER_HANDLED);
        }
    }

    /*
     * If a vertical blank is in progress the scan line is in
     * indeterminant. If the scan line is indeterminant we return
     * the error code DDERR_VERTICALBLANKINPROGRESS.
     * Otherwise we return the scan line and a success code
     */
#ifdef WINNT
    // under WINNT, we have a virtual desktop which spans both monitors, and it is not really possible
    // to make this work as a head specific thing, so just pick the primary head.
    cfgParams.Head = GET_CURRENT_HEAD();
    if (GET_MODE_PHYSICAL_HEIGHT(cfgParams.Head) == 0) {
         // can have this degenerate case in win2k, a call into this routine without nvEnable being called
        // at a minimum, we need to init some of these display timing structures
        getDisplayDuration();

    }
#if 0
    dwModeHeight = (DWORD)GET_MODE_PHYSICAL_HEIGHT(cfgParams.Head);

    if ((ppdev->ulDesktopMode & NV_SPANNING_MODE) &&
         ppdev->TwinView_Orientation == VERTICAL_ORIENTATION) {
        dwModeHeight >>= 1;
    }
#endif

#else
    // RM needs physical head, map logical to physical
    NVTWINVIEWDATA twinData;
    twinData.dwFlag   = NVTWINVIEW_FLAG_GET;
    twinData.dwAction = NVTWINVIEW_ACTION_MAP_LOG_TO_PHYS_HEAD;
    twinData.dwCrtc   = pDXShare->dwHeadNumber;
    MyExtEscape (pDXShare->dwHeadNumber, NV_ESC_SETGET_TWINVIEW_DATA, sizeof(NV_ESC_SETGET_TWINVIEW_DATA), (LPCSTR) &twinData, sizeof(NV_ESC_SETGET_TWINVIEW_DATA), (LPSTR) &twinData);

    cfgParams.Head    = twinData.dwCrtc;
    if (GET_MODE_PHYSICAL_HEIGHT(cfgParams.Head) == 0) {
        // can have this degenerate case in win2k, a call into this routine without nvEnable being called
        // at a minimum, we need to init some of these display timing structures
        getDisplayDuration();
    }
#if 0
    dwModeHeight = (DWORD)GET_MODE_PHYSICAL_HEIGHT(cfgParams.Head);

    // not really possible to make this work correctly for both heads in clone mode, one will always be wrong
    NvRmConfigGetEx (pDriverData->dwRootHandle, pDriverData->dwDeviceHandle,
        NV_CFGEX_CURRENT_SCANLINE_MULTI, &cfgParams, sizeof(cfgParams));

    lpGetScanLine->dwScanLine = cfgParams.RasterPosition;
#endif

#endif
    // **** IMPORTANT ****
    // The following piece of code could break with future versions of the chip
    // if the raster register is moved.  Unfortunately, accessing this register directly
    // is the only way to limit the time spent in this function and allow the
    // WHQL Read Scanline test to succeed.
    // Kept the old way of doing for future reference or in case we can ever go back to it.
    // 02/01/2001 PG/Video Group

    // Read the raster register directly
    npNvRasterRegister = (DWORD*) pDriverData->NvBaseFlat;
    npNvRasterRegister += ((VBLANK_REGISTER_OFFSET + (cfgParams.Head == 1 ? 0x2000 : 0)) >> 2);
    dwRaster = *npNvRasterRegister;
    lpGetScanLine->dwScanLine = MASK_SCANLINE(dwRaster);  // Keep the raster position (bits 10:0)

    if (MASK_IN_VBLANK(dwRaster))  // Bit 16 is one when in the VBLANK
        lpGetScanLine->ddRVal = DDERR_VERTICALBLANKINPROGRESS;
    else
        lpGetScanLine->ddRVal = DD_OK;

    DDENDTICK(DEVICE_GETSCANLINE);
    NvReleaseSemaphore(pDriverData);
    dbgTracePop();
    return (DDHAL_DRIVER_HANDLED);

} /* GetScanLine32 */

//---------------------------------------------------------------------------

/*
 * SetSurfaceColorKey32
 */

DWORD __stdcall SetSurfaceColorKey32(LPDDHAL_SETCOLORKEYDATA lpSetColorKey)
{
    LPDDRAWI_DIRECTDRAW_GBL   pdrv;
    LPDDRAWI_DDRAWSURFACE_LCL pDDSLcl;

    dbgTracePush ("SetSurfaceColorKey32: lpSetCK->lpDD=%08x, lpSetCK->lpDDSurface = %08x",
                  lpSetColorKey->lpDD, lpSetColorKey->lpDDSurface);

    DDSTARTTICK(SURF4_SETCOLORKEY);
    nvSetDriverDataPtrFromDDGbl (lpSetColorKey->lpDD);

    pdrv = lpSetColorKey->lpDD;
    pDDSLcl = lpSetColorKey->lpDDSurface;

    if (lpSetColorKey->dwFlags == DDCKEY_SRCBLT) {
        pDDSLcl->ddckCKSrcBlt.dwColorSpaceLowValue  = lpSetColorKey->ckNew.dwColorSpaceLowValue & pDriverData->physicalColorMask;
        // Use no mask on this one on NV3 so that our D3D driver can get all the bits when surface is 565
        pDDSLcl->ddckCKSrcBlt.dwColorSpaceHighValue = lpSetColorKey->ckNew.dwColorSpaceHighValue;
        CNvObject *pNvObj = GET_PNVOBJ (pDDSLcl);
        if (IS_VALID_PNVOBJ(pNvObj) && (pNvObj->getClass() == CNvObject::NVOBJ_TEXTURE)) {
            CTexture *pTex = pNvObj->getTexture();
            DWORD     dwColorKey;
            BOOL      bRV;
            bRV = nvCalculateColorKey (&dwColorKey, pDDSLcl, pTex->getFormat());
            nvAssert (bRV);
            pTex->tagColorKey();
            pTex->setColorKey (dwColorKey);
        }
    }

    else if (lpSetColorKey->dwFlags == DDCKEY_DESTOVERLAY) {
        pDDSLcl->ddckCKDestOverlay.dwColorSpaceLowValue  = lpSetColorKey->ckNew.dwColorSpaceLowValue & pDriverData->physicalColorMask;
        pDDSLcl->ddckCKDestOverlay.dwColorSpaceHighValue = lpSetColorKey->ckNew.dwColorSpaceHighValue & pDriverData->physicalColorMask;
    }

    else {
        lpSetColorKey->ddRVal = DDERR_UNSUPPORTED;
        DDENDTICK(SURF4_SETCOLORKEY);
        NvReleaseSemaphore(pDriverData);
        dbgTracePop();
        return (DDHAL_DRIVER_HANDLED);
    }

    lpSetColorKey->ddRVal = DD_OK;
    DDENDTICK(SURF4_SETCOLORKEY);
    NvReleaseSemaphore(pDriverData);
    dbgTracePop();
    return (DDHAL_DRIVER_HANDLED);
}


/********************************************************************************
 *
 * FUNCTION: GetK32ProcAddress
 *
 * DESC: A helper routine for getting the Win16 mutex.
 *
 *
 * Win32 code to import by ordinal from KERNEL32.DLL in Windows 95
 *
 * Andrew Schulman
 * andrew@ora.com
 * http://www.ora.com/windows/
 * ftp://ftp.ora.com/pub/examples/windows/win95.update/schulman.html
 * August 1995
 *
 ********************************************************************************/

#include "k32exp.h"

#define ENEWHDR     0x003CL         /* offset of new EXE header */
#define EMAGIC      0x5A4D          /* old EXE magic id:  'MZ'  */
#define PEMAGIC     0x4550          /* NT portable executable */

#define GET_DIR(x)  (hdr->OptionalHeader.DataDirectory[x].VirtualAddress)

static DWORD WINAPI GetK32ProcAddress(HMODULE hMod, int ord)
{
    IMAGE_NT_HEADERS       *hdr;
    IMAGE_EXPORT_DIRECTORY *exp;
    DWORD                  *AddrFunc;
    WORD                   enewhdr, *pw;
    BYTE                   *moddb;

    dbgTracePush ("GetK32ProcAddress");

    moddb = (BYTE *) hMod;
    pw = (WORD *) &moddb[0];
    if (*pw != EMAGIC) {
        dbgTracePop();
        return 0;
    }
    pw = (WORD *) &moddb[ENEWHDR];
    enewhdr = *pw;
    pw = (WORD *) &moddb[enewhdr];
    if (*pw != PEMAGIC) {
        dbgTracePop();
        return 0;
    }
    hdr = (IMAGE_NT_HEADERS *) pw;

    // Note: offset from moddb, *NOT* from hdr!
    exp = (IMAGE_EXPORT_DIRECTORY *) (((DWORD) moddb) +
                                      ((DWORD) GET_DIR(IMAGE_DIRECTORY_ENTRY_EXPORT)));
    AddrFunc = (DWORD *) (moddb + (DWORD) exp->AddressOfFunctions);

    // should verify that e.g.:
    // GetProcAddress(nvProcessGlobalData.win9x.hmod, "VirtualAlloc") == GetK32ProcAddress(710);

    ord--;  // table is 0-based, ordinals are 1-based
    if (ord < (int)exp->NumberOfFunctions) {
        dbgTracePop();
        return ((DWORD)(moddb + AddrFunc[ord]));
    }

    dbgTracePop();
    return (0);
}

#ifndef WINNT
/********************************************************************************
 *
 * FUNCTION: nvGetWin16MutexProcAddresses
 *
 * DESC: Get a pointer to the Win16 mutex routines in kernel32.dll.
 *
 ********************************************************************************/
typedef void (WINAPI *GETPWIN16MUTEX)(DWORD *);
typedef void (WINAPI *ENTERSYSLEVEL)(DWORD);
typedef void (WINAPI *LEAVESYSLEVEL)(DWORD);

BOOL nvGetWin16MutexProcAddresses(LPDWORD         win16Mutex,
                                  GETPWIN16MUTEX *lpfnGetpWin16Mutex,
                                  ENTERSYSLEVEL  *lpfnEnterSysLevel,
                                  ENTERSYSLEVEL  *lpfnLeaveSysLevel)
{
    HMODULE hMod = NULL;

    dbgTracePush ("nvGetWin16MutexProcAddresses");

    *win16Mutex         = 0;
    *lpfnGetpWin16Mutex = NULL;
    *lpfnEnterSysLevel  = NULL;
    *lpfnLeaveSysLevel  = NULL;

    hMod = GetModuleHandle("KERNEL32");

    if (hMod == NULL) { // still
        dbgTracePop();
        return FALSE;
    }

    *lpfnGetpWin16Mutex = (GETPWIN16MUTEX)GetProcAddress(hMod, "GetpWin16Lock");
    *lpfnEnterSysLevel  = (ENTERSYSLEVEL) GetProcAddress(hMod, "_EnterSysLevel");
    *lpfnLeaveSysLevel  = (LEAVESYSLEVEL) GetProcAddress(hMod, "_LeaveSysLevel");

    if (*lpfnGetpWin16Mutex == NULL) {
        *lpfnGetpWin16Mutex = (GETPWIN16MUTEX)GetK32ProcAddress(hMod, GETPWIN16MUTEX_ORD);
        *lpfnEnterSysLevel  = (ENTERSYSLEVEL) GetK32ProcAddress(hMod, ENTERSYSLEVEL_ORD);
        *lpfnLeaveSysLevel  = (LEAVESYSLEVEL) GetK32ProcAddress(hMod, LEAVESYSLEVEL_ORD);
    }

    if (*lpfnGetpWin16Mutex) {
        (*(*lpfnGetpWin16Mutex))(win16Mutex);
        dbgTracePop();
        return TRUE;
    }
    dbgTracePop();
    return (FALSE);
}

//---------------------------------------------------------------------------

// enumerate all the NVIDIA boards and store their pDXShare pointers in the g_adapterData table.
// returns TRUE if an nvidia display adapter is found and enabled, false otherwise.

BOOL nvFillAdapterTable (void)
{
    dbgTracePush ("nvFillAdapterTable");

    BOOL bEnabled = FALSE;

    if (global.pfEnumDisplayDevices) {

        DISPLAY_DEVICE DisplayDevice;
        DisplayDevice.cb = sizeof(DisplayDevice);

        for (DWORD dwDevNum=0; global.pfEnumDisplayDevices(NULL, dwDevNum, &DisplayDevice, 0); dwDevNum++) {

            if (DisplayDevice.StateFlags & DISPLAY_DEVICE_ATTACHED_TO_DESKTOP) {

                // create a DC for this display
                HDC hDC = CreateDC (NULL, (LPCSTR)DisplayDevice.DeviceName, NULL, NULL);

                if (hDC) {

                    // make sure this is an NVidia display driver
                    DISPDRVDIRECTXCOMMON *pThisDXShare = 0;

                    if (ExtEscape (hDC, NV_ESC_GET_FLAT_DIRECTX_SHARED_DATA, 0, NULL, 8, (LPSTR) &pThisDXShare) && pThisDXShare) {

                        // add this pDXShare to our g_adapterData table
                        g_adapterData[dwDevNum].pDXShare = pThisDXShare;

                        // only return TRUE if the current pDXShare belongs to an active driver
                        if (pDXShare == pThisDXShare) {
                            bEnabled = TRUE;
                        }

                        // get logical to physical head mapping
                        NVTWINVIEWDATA twinData;
                        twinData.dwFlag   = NVTWINVIEW_FLAG_GET;
                        twinData.dwAction = NVTWINVIEW_ACTION_MAP_LOG_TO_PHYS_HEAD;
                        twinData.dwCrtc   = pThisDXShare->dwHeadNumber;
                        ExtEscape(hDC, NV_ESC_SETGET_TWINVIEW_DATA, sizeof(NV_ESC_SETGET_TWINVIEW_DATA), (LPCSTR) &twinData, sizeof(NV_ESC_SETGET_TWINVIEW_DATA), (LPSTR) &twinData);
                        pThisDXShare->dwPhysicalHeadNumber = twinData.dwCrtc;
                    } else {

                        // not an NVIDIA driver
                        g_adapterData[dwDevNum].pDXShare    = NULL;
                        g_adapterData[dwDevNum].pDriverData = NULL;

                    }

                    DeleteDC (hDC);

                } // if (hDC)

            } else {

                // not attached to desktop (inactive)
                g_adapterData[dwDevNum].pDXShare    = NULL;
                g_adapterData[dwDevNum].pDriverData = NULL;

            }

        }  // for

    }

    else {

        // Windows 95 - no multi-mon
        bEnabled = TRUE;
        g_adapterData[0].pDXShare = pDXShare;

    }

    dbgTracePop();
    return (bEnabled);
}

//---------------------------------------------------------------------------

// return a DC handle for the specified device.

HDC nvCreateDCHandle (DISPDRVDIRECTXCOMMON *pDXS)
{
    dbgTracePush ("nvCreateDCHandle");

    if (global.pfEnumDisplayDevices) {

        DISPLAY_DEVICE DisplayDevice;
        DisplayDevice.cb = sizeof(DisplayDevice);

        for (DWORD dwDevNum=0; global.pfEnumDisplayDevices(NULL, dwDevNum, &DisplayDevice, 0); dwDevNum++) {

            if (DisplayDevice.StateFlags & DISPLAY_DEVICE_ATTACHED_TO_DESKTOP) {

                // create a DC for this display
                HDC hDC = CreateDC (NULL, (LPCSTR)DisplayDevice.DeviceName, NULL, NULL);

                if (hDC) {

                    DISPDRVDIRECTXCOMMON *pThisDXShare = 0;

                    if (ExtEscape (hDC, NV_ESC_GET_FLAT_DIRECTX_SHARED_DATA, 0, NULL, 8, (LPSTR)&pThisDXShare)) {
                        if (pDXS == pThisDXShare) {
                            // success! found the DC for this display.
                            dbgTracePop();
                            return (hDC);
                        }
                    }

                    DeleteDC (hDC);

                } // if (hDC)

            } // if (ATTACHED)

        } // for

    }

    else {

        // Windows 95 - no multi-mon
        dbgTracePop();
        return (GetDC (NULL));

    }

    DPF ("failed to find hDC!");

    dbgTracePop();
    return (NULL);
}

//--------------------------------------------------------------------------

// free the given DC handle if necessary

void nvDestroyDCHandle (HDC hDC)
{
    dbgTracePush ("nvDestroyDCHandle");

    if ((global.pfEnumDisplayDevices) && (hDC)) {
        DeleteDC (hDC);
    }
    // else win95, no need to delete...

    dbgTracePop();
}
#endif // !WINNT

/***************************************************************************
 *DestroyDriver32
 ***************************************************************************/
#ifdef VTUNE_SUPPORT
void nvVTuneFlushData (void);
#endif

/*
 * Under NT, DestroyDriver32 does not exist as a HAL function. However,
 * we still need to perform its cleanup tasks when DX is disabled.
 * So the NT display driver calls this routine when DX is turned off.
 */
#ifdef WINNT
HRESULT __stdcall DestroyDriver32(GLOBALDATA *pDrvData)
#else // !WINNT
HRESULT __stdcall DestroyDriver32(LPDDHAL_DESTROYDRIVERDATA pDestroyDriverData)
#endif  // !WINNT
{
    LPDDRAWI_DIRECTDRAW_GBL     pDDGbl;
    DWORD                       index = 0;
    DWORD                       i;
    DWORD                       retval = DDHAL_DRIVER_HANDLED;
    dbgTracePush ("DestroyDriver32");

#ifdef WINNT

    pDDGbl = NULL; // Under NT this is never used.
    NvAcquireSemaphore((CDriverContext *)pDrvData);
    pDriverData = (CDriverContext *)pDrvData;

#endif

    // must flush all before destroying anything
    if (getDC()->nvPusher.isValid()) {
        getDC()->nvPusher.flush (TRUE, CPushBuffer::FLUSH_WITH_DELAY);
        while (getFlipStatusPrimary(FLIP_ANYSURFACE) != DD_OK) {
            NV_SLEEPFLIP;
        }
    }

#ifdef KPFS
#if (NVARCH >= 0x20)
    pDriverData->nvKelvinPM.destroy();
#endif
#endif

#if IS_WIN9X

    DWORD                       win16Mutex;
    GETPWIN16MUTEX              lpfnGetpWin16Mutex;
    ENTERSYSLEVEL               lpfnEnterSysLevel;
    ENTERSYSLEVEL               lpfnLeaveSysLevel;
    DCICMD sMyDciCmd;

    // if full-screen DOS happened, destroy all the contexts as we don't get any calls from MS to do this, bad MS.
    if (pDriverData->dwFullScreenDOSStatus & FSDOSSTATUS_RECOVERYNEEDED_D3D) {
        D3DHAL_CONTEXTDESTROYALLDATA cdd;
        cdd.dwPID = ~0;
        nvContextDestroyAll(&cdd);
    }

    nvSetDriverDataPtrFromDDGbl (pDestroyDriverData->lpDD);
    pDDGbl = pDestroyDriverData->lpDD;

    // Assume call will succeed, will flag errors when they occur.
    pDestroyDriverData->ddRVal = DD_OK;

    pDriverData->dwDrvRefCount--;
    if (pDriverData->dwDrvRefCount != 0) {
        DWORD dwRoot;
        getAdapterIndex(pDXShare, &dwRoot);
        if (dwRoot == -1) {     // assume this is the AGP device
            // free the AGP push buffer here, a PCI push buffer should auto-create for the other device.
            nvDisable32();
        }

        NvReleaseSemaphore(pDriverData);
        dbgTracePop();
        return (retval);
    }

    // Call back to 16 bit direct draw code so it knows that
    // DirectX is going away.  Do this after the DC's are released.
    sMyDciCmd.dwVersion = DD_VERSION;
    sMyDciCmd.dwCommand = DDNVDESTROYDRIVEROBJECT;
    MyExtEscape(pDXShare->dwHeadNumber, DCICOMMAND, sizeof(DCICMD), (const char *)&sMyDciCmd, 0, 0);

    nvGetWin16MutexProcAddresses(&win16Mutex, &lpfnGetpWin16Mutex,
                                 &lpfnEnterSysLevel, &lpfnLeaveSysLevel);

    // grab win16 mutex
    if (lpfnEnterSysLevel) {
        (*(lpfnEnterSysLevel))(win16Mutex);
    }

#endif // !WINNT

#ifdef VTUNE_SUPPORT
    nvVTuneFlushData();
#endif

#ifdef ENABLE_VPP_DISPATCH_CODE
#ifndef WINNT
    vppDestroyDispatcher(&(pDriverData->vpp));
#endif // !WINNT
#endif

#ifdef WINNT
    //walk the pcontext list and deactivate ALL AA setup.
    //this is to fixe a strange AA config problem in MS Baseball
    PNVD3DCONTEXT pContext = (PNVD3DCONTEXT)pDriverData->dwContextListHead;
    while (pContext)
    {
        if(pContext->pDriverData == pDriverData){
            if(pContext->aa.isEnabled()) nvCelsiusAADestroy(pContext);
        }
        pContext = pContext->pContextNext; // next
    }
#endif

    // make sure all floating context DMA's are freed
    DWORD dwContextDma;
    for (i=0; i < pDriverData->bltData.dwSystemSurfaceContextDMAIndex; i+=2) {
        dwContextDma = NV_DD_FLOATING_CONTEXT_DMA_BASE + i;
        // HWFIX: deal with hw hash table bug, swap bits 1 and 2 with 11 and 22 (which are part of the hash function)
        dwContextDma = ((dwContextDma & 0x00000002) << 10) | ((dwContextDma & 0x00000800) >> 10) |
                       ((dwContextDma & 0x00000004) << 20) | ((dwContextDma & 0x00400000) >> 20) |
                       (dwContextDma & ~0x00400806);
        NvRmFree(pDriverData->dwRootHandle, pDriverData->dwRootHandle, dwContextDma);
    }
    pDriverData->bltData.dwSystemSurfaceContextDMAIndex = 0;

    // deallocate all blt workspaces
    if (pDriverData->bltVidMemInfo.dwLocale == BLTWS_VIDEO) {
        NVHEAP_FREE(pDriverData->bltVidMemInfo.fpVidMem);
        pDriverData->bltVidMemInfo.dwLocale = BLTWS_UNINITIALIZED;
    }
    if (pDriverData->bltSysMemInfo.dwLocale == BLTWS_SYSTEM) {
        NvRmFree(pDriverData->dwRootHandle, pDriverData->dwRootHandle, pDriverData->bltSysMemInfo.dwContextDma);
        FreeIPM((void*)pDriverData->bltSysMemInfo.fpVidMem);
        pDriverData->bltSysMemInfo.dwLocale = BLTWS_UNINITIALIZED;
    }
    if (pDriverData->bltAGPMemInfo.dwLocale == BLTWS_AGP) {
        NvRmFree(pDriverData->dwRootHandle, pDriverData->dwRootHandle, pDriverData->bltAGPMemInfo.dwContextDma);
        nvAGPFree((void*)pDriverData->bltAGPMemInfo.fpVidMem);
        pDriverData->bltAGPMemInfo.dwLocale = BLTWS_UNINITIALIZED;
    }

    // Clear motion comp context
    pDriverData->dwMCNVMCSurface = 0;
    pDriverData->dwMCNVDSSurfaceBase = 0;
    pDriverData->dwMCCurrentCelsiusIDCTCtxDma = 0;

    for (i=0; i<4; i++) {
        pDriverData->dwMCIDCTAGPSurfaceBase[i] = 0;
        if (pDriverData->dwMCIDCTAGPCtxDmaSize[i] != 0) {
            NvRmFree(pDriverData->dwRootHandle, pDriverData->dwRootHandle,
                     NV_DD_DMA_FLOATING_MC_IDCT0_CONTEXT_DMA_FROM_MEMORY+i);
            pDriverData->dwMCIDCTAGPCtxDmaSize[i] = 0;
        }
    }

    // If an overlay is currently active then shut it down
    if ((getDC()->nvPusher.isValid()) && (pDriverData->vpp.dwOverlaySurfaces > 0)) {

        FAST long videoFreeCount = pDriverData->NvVideoFreeCount;
        LPPROCESSINFO lpProcInfo = pmGetProcess(pDriverData, GetCurrentProcessId());

        // make sure we sync with other channels before writing put
        getDC()->nvPusher.setSyncChannelFlag();

        // Trash spare subchannel
        pDriverData->dwRingZeroMutex = TRUE;

        Sleep(VPP_TIMEOUT_TIME * 3);

        // Should not be talking directly to VPP objects -@mjl@
        nvPushData(0, dDrawSubchannelOffset(NV_DD_SPARE) | 0x40000);
        nvPushData(1, NV_VPP_OVERLAY_IID);
        nvPushData(2, dDrawSubchannelOffset(NV_DD_SPARE) | NV07A_STOP_OVERLAY(0) | 0x80000);
        nvPushData(3, NV07A_STOP_OVERLAY_AS_SOON_AS_POSSIBLE);  // StopOverlay[0]
        nvPushData(4, NV07A_STOP_OVERLAY_AS_SOON_AS_POSSIBLE);  // StopOverlay[1]
        nvPusherAdjust(5);
        nvPusherStart(TRUE);

        pDriverData->dwRingZeroMutex = FALSE;
        pDriverData->dDrawSpareSubchannelObject = 0;

        GET_HALINFO()->ddCaps.dwCurrVisibleOverlays = 0;
    }

    pmDeleteAllProcesses(pDriverData);


    /*
     * This routine will insure that any allocated preapproved context is destroyed.
     */
    nvDestroyPreapprovedContexts();

#ifndef WINNT
    pDriverData->HALCallbacks.lpSetInfo = 0;
#endif  // WINNT

    if (!nvDisable32()) {
#ifdef WINNT
        retval = DDHAL_DRIVER_NOTHANDLED;
#else // !WINNT
        pDestroyDriverData->ddRVal = DDERR_GENERIC;
#endif // !WINNT
    }

    // Free any existing dynamic context dma objects
    if (pDriverData->dwVidMemCtxDmaSize != 0) {
        NvRmFree(pDriverData->dwRootHandle, pDriverData->dwDeviceHandle, NV_DD_DMA_CONTEXT_DMA_IN_VIDEO_MEMORY);
        NvRmFree(pDriverData->dwRootHandle, pDriverData->dwDeviceHandle, NV_DD_DMA_CONTEXT_DMA_FROM_VIDEO_MEMORY);
        NvRmFree(pDriverData->dwRootHandle, pDriverData->dwDeviceHandle, NV_DD_DMA_CONTEXT_DMA_TO_VIDEO_MEMORY);
        pDriverData->dwVidMemCtxDmaSize = 0;
    }

    VppDestructor(&pDriverData->vpp);

    // Make sure we reset the current Celsius user to none
    pDriverData->dwMostRecentHWUser = MODULE_ID_NONE;

    if (pDriverData->NvDevVideoFlatPio != 0) {
        NvRmFree(pDriverData->dwRootHandle, NV_WIN_DEVICE, NV_DD_DEV_VIDEO);
        pDriverData->NvDevVideoFlatPio = 0;
    }

    // Let 16 bit Display Driver code know that Direct Draw is no longer active
    pDriverData->DDrawVideoSurfaceCount = 0;

    pDriverData->fNvActiveFloatingContexts = 0;

#ifdef WINNT
    if (pDriverData->GARTLinearBase) {
        getDC()->defaultVB.destroy();
#ifndef NV_AGP
        NvWin2KUnmapAgpHeap(ppdev);
#endif // !NV_AGP
    }
#else // !WINNT
#ifndef NV_AGP
    // Reset AGP GART addresses
    pDriverData->GARTLinearBase = 0;
    pDriverData->GARTPhysicalBase = 0;
#endif // !NVAGP
#endif // !WINNT

    pDriverData->dwRingZeroMutex = FALSE;

#ifndef WINNT   // WINNT BUG
    pMySurfaces = NULL;

    // release win16 mutex
    if (lpfnLeaveSysLevel) {
        (*(lpfnLeaveSysLevel))(win16Mutex);
    }
#endif // !WINNT

    // delete the inner loop table entries
    for(i = 0; i < DRAW_PRIM_TABLE_ENTRIES; i++)
    {
        // release inner loops
        CILHashEntry *pEntry = (CILHashEntry*)dwDrawPrimitiveTable[i];
        while (pEntry)
        {
            CILHashEntry *pNext = pEntry->getNext();
            delete pEntry;
            pEntry = pNext;
        }
    }

    nvPatchDestroyFD();

    // clear the inner loop lookup table to zero
    memset ((void *)dwDrawPrimitiveTable, 0, DRAW_PRIM_TABLE_ENTRIES<<2);
    global.celsius.dwLoopCache = 0;
#if (NVARCH >= 0x20)
    global.kelvin.dwLoopCache = 0;
#endif
    // also clear the compiled memcopy routines
    memset (global.adwMemCopy,0,sizeof(global.adwMemCopy));

    // finally free the memory
    if (global.dwILCData) {
        // kill compiled state variables
        FreeIPM(global.dwILCData);
        global.dwILCData  = 0;
        global.dwILCCount = 0;
        global.dwILCMax   = 0;
    }


#ifdef CNT_TEX

    HANDLE hFile = CreateFile("\\TexDL.txt", GENERIC_WRITE, 0, NULL, OPEN_ALWAYS, 0, NULL);

    char cTempBuf[64];
    DWORD dwTotVid, dwTotAgp, dwTot;
    dwTotVid = 0;
    dwTotAgp = 0;
    SetFilePointer(hFile, 0,0,FILE_END);
    if (g_dwFrames > MAX_FRAME_CNT)
        g_dwFrames = MAX_FRAME_CNT;

    for (int iFrmCnt=0; iFrmCnt < (int)g_dwFrames; iFrmCnt++) {
        sprintf(cTempBuf, "\nFrame: %d", iFrmCnt);
        WriteFile(hFile, cTempBuf, strlen(cTempBuf), &dwTot, NULL);
        sprintf(cTempBuf, "\n\tNumber of Video Texture Downloads: %d", g_dwVidTexDL[iFrmCnt]);
        WriteFile(hFile, cTempBuf, strlen(cTempBuf), &dwTot, NULL);
        sprintf(cTempBuf, "\n\tNumber of AGP Texture Downloads: %d\n", g_dwAgpTexDL[iFrmCnt]);
        WriteFile(hFile, cTempBuf, strlen(cTempBuf), &dwTot, NULL);

        dwTotVid += g_dwVidTexDL[iFrmCnt];
        dwTotAgp += g_dwAgpTexDL[iFrmCnt];
        g_dwVidTexDL[iFrmCnt] = 0;
        g_dwAgpTexDL[iFrmCnt] = 0;
    }

    // print out totals
    sprintf(cTempBuf, "\nTotal Number of Frames: %d", g_dwFrames);
    WriteFile(hFile, cTempBuf, strlen(cTempBuf), &dwTot, NULL);
    sprintf(cTempBuf, "\nTotal Number of Video Texture Downloads: %d", dwTotVid);
    WriteFile(hFile, cTempBuf, strlen(cTempBuf), &dwTot, NULL);
    sprintf(cTempBuf, "\nTotal Number of AGP Texture Downloads: %d\n", dwTotAgp);
    WriteFile(hFile, cTempBuf, strlen(cTempBuf), &dwTot, NULL);

    CloseHandle(hFile);

    g_dwFrames = 0;
#endif

    // bAssertModeDirectDraw checks this to know if DriverInit() needs to be called again
    // in some modeset sequences.  The initialization sequence on Win9x requires that we
    // do not clear this however... *sigh*  it's a mess.
#if IS_WINNT5
    pDriverData->dwRootHandle = 0;
#endif

#if IS_WIN9X
    // kill timer proc
    if (pDriverData->dwTVTunerTimer) {
        KillTimer(NULL, pDriverData->dwTVTunerTimer);
    }

    // compact the heap and display usage
    g_nvIPHeap.checkHeapUsage();

    // done
    pDestroyDriverData->ddRVal = DD_OK;
#endif // IS_WIN9X

#ifdef NVSTATDRIVER
            DetachNVStat();
#endif // NVSTATDRIVER

    NvReleaseSemaphore(pDriverData);
    dbgTracePop();
    return (retval);
} // DestroyDriver32

//---------------------------------------------------------------------------

/*
 * GetHeapAlignment32
 *
 * Returns more specific heap alignment requirements to DDRAW than
 * those described in the heap structure.
 */

DWORD __stdcall GetHeapAlignment32 (LPDDHAL_GETHEAPALIGNMENTDATA lpGhaData)
{
    dbgTracePush ("GetHeapAlignment32");

    lpGhaData->ddRVal= DD_OK;

    if (lpGhaData->dwHeap == 0) {
        lpGhaData->Alignment.ddsCaps.dwCaps = DDSCAPS_OFFSCREENPLAIN |
                                              DDSCAPS_EXECUTEBUFFER |
                                              DDSCAPS_OVERLAY |
                                              DDSCAPS_TEXTURE |
                                              DDSCAPS_ZBUFFER |
                                              DDSCAPS_ALPHA |
                                              DDSCAPS_FLIP;

        /* Alignments in bytes */

        lpGhaData->Alignment.ExecuteBuffer.Linear.dwStartAlignment = 0;
        lpGhaData->Alignment.ExecuteBuffer.Linear.dwPitchAlignment = 0;

        lpGhaData->Alignment.Overlay.Linear.dwStartAlignment = NV_OVERLAY_BYTE_ALIGNMENT;
        lpGhaData->Alignment.Overlay.Linear.dwPitchAlignment = NV_OVERLAY_BYTE_ALIGNMENT;

        lpGhaData->Alignment.Texture.Linear.dwStartAlignment = pDriverData->dwSurfaceAlign; /* Texture surfaces, not our optimized texture alignment */
        lpGhaData->Alignment.Texture.Linear.dwPitchAlignment = pDriverData->dwSurfaceAlign;

        lpGhaData->Alignment.ZBuffer.Linear.dwStartAlignment = pDriverData->dwSurfaceAlign;
        lpGhaData->Alignment.ZBuffer.Linear.dwPitchAlignment = pDriverData->dwSurfaceAlign;

        lpGhaData->Alignment.AlphaBuffer.Linear.dwStartAlignment = pDriverData->dwSurfaceAlign;
        lpGhaData->Alignment.AlphaBuffer.Linear.dwPitchAlignment = pDriverData->dwSurfaceAlign;

        lpGhaData->Alignment.Offscreen.Linear.dwStartAlignment = pDriverData->dwSurfaceAlign;
        lpGhaData->Alignment.Offscreen.Linear.dwPitchAlignment = pDriverData->dwSurfaceAlign;

        lpGhaData->Alignment.FlipTarget.Linear.dwStartAlignment = pDriverData->dwSurfaceBitAlign;
        lpGhaData->Alignment.FlipTarget.Linear.dwPitchAlignment = pDriverData->dwSurfaceAlign;

    }
    else {
        DPF("D3D: GetHeapAlignment32 - invalid parameters 10");
        lpGhaData->ddRVal = DDERR_INVALIDPARAMS;
        dbgTracePop();
        return (DDHAL_DRIVER_NOTHANDLED);
    }

    dbgTracePop();
    return (DDHAL_DRIVER_HANDLED);

} /* GetHeapAlignment32 */

#ifndef WINNT
/*
 * This callback is Win9x specific - for its Winnt counterpart, see
 * GetDriverInfo32.GUID_UpdateNonLocalHeap.
 */

//---------------------------------------------------------------------------

/*
 * UpdateNonLocalHeap32
 *
 * Records actual AGP memory linear and physical addresses.
 */

DWORD __stdcall UpdateNonLocalHeap32( LPDDHAL_UPDATENONLOCALHEAPDATA lpd )
{
    dbgTracePush ("UpdateNonLocalHeap32");

    nvSetDriverDataPtrFromDDGbl (lpd->lpDD);

    // the heap has been ripped out from under us. mark it invalid so we don't try to use it
    nvAGPInvalidate();

    bltDestroyAllContextDMAs(lpd->lpDD);

    if (pDriverData->bltAGPMemInfo.dwLocale == BLTWS_SYSTEM) {
        NvRmFree(pDriverData->dwRootHandle, pDriverData->dwRootHandle, pDriverData->bltAGPMemInfo.dwContextDma);
        nvAGPFree((void*)pDriverData->bltAGPMemInfo.fpVidMem);
        pDriverData->bltAGPMemInfo.dwLocale = BLTWS_UNINITIALIZED;
    }

    if (pDriverData->dwFullScreenDOSStatus & (FSDOSSTATUS_RECOVERYNEEDED_D3D | FSDOSSTATUS_RECOVERYNEEDED_DDRAW)) {
        if (!(pDriverData->dwFullScreenDOSStatus & FSDOSSTATUS_COMPLETE)) {
            lpd->ddRVal = DDERR_GENERIC;
            NvReleaseSemaphore(pDriverData);
            dbgTracePop();
            return (DDHAL_DRIVER_HANDLED);
        }
    }

#ifdef CAPTURE
    if ((getDC()->nvD3DRegistryData.regCaptureEnable & D3D_REG_CAPTUREENABLE_RECORD) &&
        (getDC()->nvD3DRegistryData.regCaptureConfig & D3D_REG_CAPTURECONFIG_FORCEPCI)) {
        pDriverData->GARTPhysicalBase = 0;
        pDriverData->GARTLinearBase = 0;
    }
    else
#endif

    if ((lpd->dwHeap == AGP_HEAP) && (lpd->fpGARTLin != 0)) { // AGP heap

        // This is the linear non-local heap we use for DMA push buffers, textures and YV12 surfaces...
        pDriverData->GARTPhysicalBase = lpd->fpGARTDev;
        pDriverData->GARTLinearBase = lpd->fpGARTLin;

        // Let the resource manager know this information
        DWORD dwDummy;
        NvRmConfigSet (pDriverData->dwRootHandle, pDriverData->dwDeviceHandle,
                       NV_CFG_AGP_PHYS_BASE, pDriverData->GARTPhysicalBase, &dwDummy);
        NvRmConfigSet (pDriverData->dwRootHandle, pDriverData->dwDeviceHandle,
                       NV_CFG_AGP_LINEAR_BASE, pDriverData->GARTLinearBase, &dwDummy);

        if (!pDriverData->regMaxAGPLimit) {
            // MS is lazy about setting up MTRR's and sometimes this config get in DriverInit
            // will fail because they haven't done it yet.  Try to get it again here as a last
            // ditch attempt -- (this has the side affect of setting up some mapping variables
            // in pdev on the RM side).
            NvRmConfigGet (pDriverData->dwRootHandle, NV_WIN_DEVICE,
                           NV_CFG_AGP_LIMIT, &pDriverData->regMaxAGPLimit);
            if (!pDriverData->regMaxAGPLimit) {
                // we _still_ can't get the heap size. just revert to the default and pray...
                pDriverData->regMaxAGPLimit = NV_MAX_AGP_MEMORY_LIMIT;
                DPF ("falling back to default AGP heap size for lack of information from MS");
                dbgD3DError();
            }
        }

        // win9x fix for any system that sets an AGP aperature TOO large
        {
            DWORD dwMem = pDriverData->nvD3DPerfData.dwSystemMemory * 1024 * 1024 / 2 - 1;
            pDriverData->regMaxAGPLimit = min(pDriverData->regMaxAGPLimit, dwMem);
        }

        // Even though regMaxAGPLimit is accurate, we could be further limited by lpd->ulPolicyMaxBytes
        NvRmConfigSet (pDriverData->dwRootHandle, pDriverData->dwDeviceHandle,
                       NV_CFG_AGP_LIMIT, pDriverData->regMaxAGPLimit, &dwDummy);

#ifdef NV_TRACKAGP
        __Reset();
#endif //NV_TRACKAGP

        // reset if we weren't yet enabled or if we had a valid
        // push buffer in AGP memory (which has been blown away)
        if ((getDC()->dwEnableStatus != CDriverContext::DC_ENABLESTATUS_ENABLED)
            ||
            (getDC()->nvPusher.isValid() && (getDC()->nvPusher.getHeap() == CSimpleSurface::HEAP_AGP))) {
            nvDisable32();
            if (!nvEnable32 (lpd->lpDD)) {
                NvReleaseSemaphore(pDriverData);
                lpd->ddRVal = DDERR_OUTOFMEMORY;
                dbgTracePop();
                return DDHAL_DRIVER_HANDLED;
            }
        }
    }

    NvReleaseSemaphore(pDriverData);
    lpd->ddRVal = DD_OK;
    dbgTracePop();
    return (DDHAL_DRIVER_HANDLED);

} // UpdateNonLocalHeap32

#endif // !WINNT

//---------------------------------------------------------------------------

/*
 * GetAvailDriverMemory32
 *
 * Reports amount of memory that the driver is managing itself.
 */

DWORD __stdcall GetAvailDriverMemory32( LPDDHAL_GETAVAILDRIVERMEMORYDATA lpd )
{
    dbgTracePush ("GetAvailDriverMemory32");

    // We need to see if if there has been a mode set and re-init.
    // Although this routine does nothing with hardware, the offscreen
    // memory heap will not really be accurate if we don't. Fixes
    // WQHL bug where WHQL test allocates a bunch of surfaces and then
    // frees them and then checks to make sure that there is the
    // same amount of video memory before allocating as after freeing.
    // Because we allocate some extra video memory for a notifier in
    // NvDDEnable32 on the first createSurface call and don't free
    // the notifier when the last surface is destroyed (which is
    // perfectly fine!), WHQL thinks we are losing memory, but we aren't.
    // However, I fix it by checking if NV needs a reset here which
    // will force the notifier to allocate before the memory is sized.
    nvSetDriverDataPtrFromDDGbl (lpd->lpDD);

    // Make certain that we're enabled before reporting memory.
    // Our nvEnable code does do some minor allocations which we need
    // to account for before reporting to the app how much remains
    // available to it.
    if (getDC()->dwEnableStatus != CDriverContext::DC_ENABLESTATUS_ENABLED)
    {
        if (!nvEnable32 (lpd->lpDD)) {
            NvReleaseSemaphore(pDriverData);
            lpd->ddRVal = DDERR_OUTOFMEMORY;
            dbgTracePop();
            return DDHAL_DRIVER_HANDLED;
        }
    }

    // figure out what the caller requested
    BOOL bVidMem  = (lpd->DDSCaps.dwCaps & (DDSCAPS_VIDEOMEMORY | DDSCAPS_LOCALVIDMEM))
                    == (DDSCAPS_VIDEOMEMORY | DDSCAPS_LOCALVIDMEM);
    BOOL bAGPMem  = (lpd->DDSCaps.dwCaps & (DDSCAPS_VIDEOMEMORY | DDSCAPS_NONLOCALVIDMEM))
                    == (DDSCAPS_VIDEOMEMORY | DDSCAPS_NONLOCALVIDMEM);
    BOOL bTexture = (lpd->DDSCaps.dwCaps & DDSCAPS_TEXTURE) == DDSCAPS_TEXTURE;
    BOOL bZBufMem = (lpd->DDSCaps.dwCaps & DDSCAPS_ZBUFFER) == DDSCAPS_ZBUFFER;

    // Ths ZBuffer is always in video memory since the chip has to be able
    // to write to it. So, the request is really for vid mem.
    if (bZBufMem)
        bVidMem = TRUE;

    if (!bVidMem && !bAGPMem)
    {
        // if DDSCAPS_VIDEOMEMORY is set but the location is not specified we will return local vid mem only
        if (lpd->DDSCaps.dwCaps & DDSCAPS_VIDEOMEMORY)
            bVidMem = TRUE;

        // when primary surface is specified, use local vid mem
        if (lpd->DDSCaps.dwCaps & DDSCAPS_PRIMARYSURFACE)
            bVidMem = TRUE;

        // off screen plain -> video only
        if (lpd->DDSCaps.dwCaps & DDSCAPS_OFFSCREENPLAIN)
            bVidMem = TRUE;

        // only DDSCAPS_LOCALVIDMEM -> vid mem
        if (lpd->DDSCaps.dwCaps & DDSCAPS_LOCALVIDMEM)
            bVidMem = TRUE;

        // only DDSCAPS_NONLOCALVIDMEM -> agp mem
        if (lpd->DDSCaps.dwCaps & DDSCAPS_NONLOCALVIDMEM)
            bAGPMem = TRUE;

        // only DDSCAPS_TEXTURE -> vid & agp (if it exists)
        if (bTexture)
        {
            bVidMem = TRUE;
            if (pDriverData->GARTLinearBase) {
                bAGPMem = TRUE;
            }
        }
    }

    nvCreateVidHeapVarsAndPseudoNotifier();

    lpd->dwTotal = 0;
    lpd->dwFree  = 0;

    //
    // local video memory
    //
    if (bVidMem)
    {
        // The driver is managing local video memory itself.
        // AGP memory is being managed by DirectX.  So just
        // return amount of local memory being managed.
        lpd->dwTotal += pDriverData->VideoHeapTotal - pDriverData->VideoHeapOverhead;
        lpd->dwFree  += pDriverData->VideoHeapFree;
    }

    //
    // PCI texture memory
    //
    if (bTexture
     && !bAGPMem
     && !pDriverData->GARTLinearBase)
    {
        if (getDC()->nvD3DTexHeapData.dwSizeMax == 0)
        {
             // If the current texture heap size is not initialized
             // yet, then this means D3D has not be fired up yet to
             // actually allocate the texture heap.  In this case
             // return the amount that is being requested.  Once D3D
             // is up and running, the memory sizes will be based on
             // what the heap size really is.
            DWORD dwHeapSize = getDC()->nvD3DRegistryData.regPCITexHeapSize ?
                               getDC()->nvD3DRegistryData.regPCITexHeapSize :
                               pDriverData->nvD3DPerfData.dwRecommendedPCITexHeapSize;
            lpd->dwTotal += dwHeapSize;
            lpd->dwFree  += dwHeapSize;
        }
        else
        {
            // Return the maximum and available size of the internal
            // PCI system memory texture heap
            lpd->dwTotal += getDC()->nvD3DTexHeapData.dwSizeMax;
            lpd->dwFree  += getDC()->nvD3DTexHeapData.dwFreeSize;
        }
    }

    //
    // AGP texture memory
    //
    if (bAGPMem)
    {
        // On AGP systems, the driver also manages textures, but in AGP memory.
        // Our driver allocates a chunk of AGP memory from the the DirectX
        // managed AGP heap. Then we sub-allocate from this chunk for our
        // textures. Hence, DirectX thinks there is less AGP memory available
        // than there actually is. We need to correct for that.
        DWORD total, free;

        nvAGPGetMemory (&total, &free);

#ifdef NV_AGP
        lpd->dwTotal += pDriverData->regMaxAGPLimit;
        lpd->dwFree  += pDriverData->regMaxAGPLimit - total + free;
#else // !NV_AGP
        lpd->dwTotal += 0;      // total is already correct
        lpd->dwFree  += free;   // we have this much free
#endif // !NV_AGP
    }

    lpd->ddRVal = DD_OK;
    NvReleaseSemaphore(pDriverData);
    dbgTracePop();
    return(DDHAL_DRIVER_HANDLED);
}

//---------------------------------------------------------------------------

/* Safe procedures, basically if they are called nothing happens */
DWORD FAR PASCAL SafeSyncSurfaceData(LPDDHAL_SYNCSURFACEDATA lpInput)
{
    dbgTracePush ("SafeSyncSurfaceData");
    lpInput->ddRVal= DD_OK;
    dbgTracePop();
    return (DDHAL_DRIVER_HANDLED);
}

DWORD FAR PASCAL SafeSyncVideoPortData(LPDDHAL_SYNCVIDEOPORTDATA lpInput)
{
    dbgTracePush ("SafeSyncVideoPortData");
    lpInput->ddRVal= DD_OK;
    dbgTracePop();
    return (DDHAL_DRIVER_HANDLED);
}

//---------------------------------------------------------------------------

/*
 * GetTranslatedOffset(DWORD lBrightness )
 *
 * Converts linear brightness into an offset to program into
 * CSC registers, this algorithm is non-linear and
 * includes two ranges.
 */
DWORD GetTranslatedOffset( unsigned long lBrightness)
{
    DWORD dwOffset;

    dbgTracePush ("GetTranslatedOffset");

    if (lBrightness>10000)
        lBrightness = 10,000;

    if (lBrightness<=750) {
        dwOffset = 1+ ( 0x3D * (lBrightness/749) );
    }
    else {
        dwOffset = (0x69 * (lBrightness/(10,000-750)));
    }

    dbgTracePop();
    return (dwOffset);
}

//---------------------------------------------------------------------------

#define NV_PVIDEO_RED_CSC 0x680280
#define NV_PVIDEO_GREEN_CSC 0x680284
#define NV_PVIDEO_BLUE_CSC 0x680288

DWORD GetOffsetTranslated()
{
    U032 * nvBase;
    U032 dwRedCsc;

    dbgTracePush ("GetOffsetTranslated");

    // all of this is based of the red csc value
    nvBase = (U032 *) (pDriverData->NvBaseFlat);

    dwRedCsc = nvBase[NV_PVIDEO_RED_CSC/4];

    if (dwRedCsc>=0x69) {// 750 to 0 range
        dbgTracePop();
        return(750 * ((dwRedCsc-0x69)/0x3E));
    }
    else {// 750-10,000 range
        dbgTracePop();
        return(750 + ((10000-750)* ((0x69-dwRedCsc)/0x69)) );
    }
}

//---------------------------------------------------------------------------

/*
 * Colour Control
 * Extended functionality of DirectDraw/VPE
 */
DWORD __stdcall ColourControl( LPDDHAL_COLORCONTROLDATA pvpcd )
{
    U032 *nvBase;

    dbgTracePush ("ColourControl");

    nvSetDriverDataPtrFromDDGbl (pvpcd->lpDD);

    if (IS_OVERLAY(pvpcd->lpDDSurface->ddsCaps.dwCaps, pvpcd->lpDDSurface->lpGbl->ddpfSurface.dwFourCC)) {

        if (pvpcd->dwFlags & DDRAWI_GETCOLOR ) {

            pvpcd->lpColorData->dwSize = sizeof(DDCOLORCONTROL);

            pvpcd->lpColorData->dwFlags = DDCOLOR_BRIGHTNESS;
            pvpcd->lpColorData->dwFlags |= DDCOLOR_CONTRAST;
            pvpcd->lpColorData->dwFlags |= DDCOLOR_SATURATION;
            pvpcd->lpColorData->dwFlags |= DDCOLOR_HUE;

            if (pDriverData->NvDeviceVersion >= NV_DEVICE_VERSION_10) {
                pvpcd->lpColorData->lBrightness = pDriverData->vpp.colorCtrl.lBrightness;
                pvpcd->lpColorData->lContrast = pDriverData->vpp.colorCtrl.lContrast;
                pvpcd->lpColorData->lHue = pDriverData->vpp.colorCtrl.lHue;
                pvpcd->lpColorData->lSaturation = pDriverData->vpp.colorCtrl.lSaturation;
            }
            else {
                // is in units of 1, maximum is 10,000
                pvpcd->lpColorData->lBrightness = GetOffsetTranslated();

                // contrast ranges from 0 to 20,000 (intended to be 0 to 200%)
                pvpcd->lpColorData->lContrast = min(pDriverData->vpp.colorCtrl.lContrast * 10000 / 255, 20000);

                // hue is in range of -180 to 180 degrees
                pvpcd->lpColorData->lHue = pDriverData->vpp.colorCtrl.lHue;
                while (pvpcd->lpColorData->lHue > 180)  pvpcd->lpColorData->lHue -= 360;
                while (pvpcd->lpColorData->lHue < -180) pvpcd->lpColorData->lHue += 360;

                // saturation ranges from 0 to 20,000
                pvpcd->lpColorData->lSaturation = min(pDriverData->vpp.colorCtrl.lSaturation * 10000 / 256, 20000);
            }

            pvpcd->ddRVal = DD_OK;
            NvReleaseSemaphore(pDriverData);
            dbgTracePop();
            return (DDHAL_DRIVER_HANDLED);
        }

        if (pvpcd->dwFlags & DDRAWI_SETCOLOR ) {
            if (pDriverData->NvDeviceVersion >= NV_DEVICE_VERSION_10) {
                if (pvpcd->lpColorData->dwFlags & DDCOLOR_CONTRAST) {
                    pDriverData->vpp.colorCtrl.lContrast = pvpcd->lpColorData->lContrast;
                }
                if (pvpcd->lpColorData->dwFlags & DDCOLOR_BRIGHTNESS) {
                    pDriverData->vpp.colorCtrl.lBrightness = pvpcd->lpColorData->lBrightness;
                }
                if (pvpcd->lpColorData->dwFlags & DDCOLOR_SATURATION) {
                    pDriverData->vpp.colorCtrl.lSaturation = pvpcd->lpColorData->lSaturation;
                }
                if (pvpcd->lpColorData->dwFlags & DDCOLOR_HUE) {
                    pDriverData->vpp.colorCtrl.lHue = pvpcd->lpColorData->lHue;
                }
                VppSetOverlayColourControl(&(pDriverData->vpp));

                if (pvpcd->lpColorData->dwFlags & (DDCOLOR_BRIGHTNESS | DDCOLOR_CONTRAST | DDCOLOR_HUE | DDCOLOR_SATURATION)) {
                    pvpcd->ddRVal = DD_OK;
                    NvReleaseSemaphore(pDriverData);
                    dbgTracePop();
                    return (DDHAL_DRIVER_HANDLED);
                }
            }
            else {
                if (pvpcd->lpColorData->dwFlags & DDCOLOR_BRIGHTNESS) {
                    DWORD dwCscOffset;
                    DWORD dwCscRed, dwCscGreen, dwCscBlue;

                    pDriverData->vpp.colorCtrl.lBrightness = min(pvpcd->lpColorData->lBrightness / 100, 255);
                    dwCscOffset = GetTranslatedOffset( pvpcd->lpColorData->lBrightness );

                    dwCscRed = 0x69     + dwCscOffset;
                    dwCscGreen = 0x3E   - dwCscOffset;
                    dwCscBlue  = 0x89   + dwCscOffset;

                    nvBase = (U032 *) (pDriverData->NvBaseFlat);

                    nvBase[NV_PVIDEO_RED_CSC/4] = dwCscRed;
                    nvBase[NV_PVIDEO_GREEN_CSC/4] = dwCscGreen;
                    nvBase[NV_PVIDEO_BLUE_CSC/4] = dwCscBlue;
                }
                if (pvpcd->lpColorData->dwFlags & DDCOLOR_CONTRAST) {
                    pDriverData->vpp.colorCtrl.lContrast = min(pvpcd->lpColorData->lContrast * 255 / 10000, 511);
                }
                if (pvpcd->lpColorData->dwFlags & DDCOLOR_HUE) {
                    pDriverData->vpp.colorCtrl.lHue = pvpcd->lpColorData->lHue;
                    while (pDriverData->vpp.colorCtrl.lHue < 0)    pDriverData->vpp.colorCtrl.lHue += 360;
                    while (pDriverData->vpp.colorCtrl.lHue >= 360) pDriverData->vpp.colorCtrl.lHue -= 360;
                }
                if (pvpcd->lpColorData->dwFlags & DDCOLOR_SATURATION) {
                    pDriverData->vpp.colorCtrl.lSaturation = min(pvpcd->lpColorData->lSaturation * 256 / 10000, 512);
                }
                if (pvpcd->lpColorData->dwFlags & (DDCOLOR_BRIGHTNESS | DDCOLOR_CONTRAST | DDCOLOR_HUE | DDCOLOR_SATURATION)) {
                    pvpcd->ddRVal = DD_OK;
                    NvReleaseSemaphore(pDriverData);
                    dbgTracePop();
                    return (DDHAL_DRIVER_HANDLED);
                }
            }
        }
    }

    NvReleaseSemaphore(pDriverData);
    dbgTracePop();
    return (DDHAL_DRIVER_NOTHANDLED);
}

//---------------------------------------------------------------------------

/*
 * GetDriverInfo32
 *
 * Initialize Extended Functionality Classes
 */
DWORD __stdcall GetDriverInfo32(LPDDHAL_GETDRIVERINFODATA lpData)
{
    DWORD dwSize;

    dbgTracePush ("GetDriverInfo32");

#ifdef WINNT
    NvAcquireSemaphore((((PPDEV) (lpData->dhpdev))->pDriverData));
    pDriverData = (CDriverContext *) ((PPDEV)(lpData->dhpdev))->pDriverData;
#else // !WINNT
    pDXShare = (DISPDRVDIRECTXCOMMON *) lpData->dwContext;
    pDriverData = (CDriverContext *) pDXShare->pDirectXData;
#endif // !WINNT

    // set up pointer to DDHALINFO
    LPDDHALINFO pHalInfo = GET_HALINFO();

    lpData->ddRVal = DDERR_CURRENTLYNOTAVAIL;

    // please keep these GUIDs alphabetized. there are too
    // many of them to otherwise keep track of.

    if (IsEqualIID_C ((lpData->guidInfo), GUID_ColorControlCallbacks) &&
       (pDriverData->NvDeviceVersion >= NV_DEVICE_VERSION_10 || pDriverData->vpp.regOverlayColourControlEnable)) {
        DDHAL_DDCOLORCONTROLCALLBACKS ccCB;

        dwSize = lpData->dwExpectedSize;

        lpData->dwActualSize = sizeof( DDHAL_DDCOLORCONTROLCALLBACKS );

        ccCB.dwSize = (dwSize<lpData->dwActualSize)?
                      dwSize:lpData->dwActualSize;

        ccCB.dwFlags = DDHAL_COLOR_COLORCONTROL;
        ccCB.ColorControl = ColourControl;

        memcpy(lpData->lpvData, &ccCB, ccCB.dwSize );

        lpData->ddRVal = DD_OK;
    }

#ifndef WINNT
    if (IsEqualIID_C ((lpData->guidInfo), GUID_D3DCallbacks2))
    {
        D3DHAL_CALLBACKS2 D3DCallbacks2;

        DPF_LEVEL(NVDBG_LEVEL_INFO, "D3DGetDriverInfo - Process GUID_D3DCallbacks2");

        global.dwDXRuntimeVersion = max (global.dwDXRuntimeVersion, 0x0300);

        memset(&D3DCallbacks2, 0, sizeof(D3DHAL_CALLBACKS2));
        dwSize               = min(lpData->dwExpectedSize, sizeof(D3DHAL_CALLBACKS2));
        lpData->dwActualSize = sizeof(D3DHAL_CALLBACKS2);
        D3DCallbacks2.dwSize = dwSize;

        /*
         * Always export the SetRenderTarget callback.
         */
        D3DCallbacks2.dwFlags = D3DHAL2_CB32_SETRENDERTARGET;
        D3DCallbacks2.SetRenderTarget = nvSetRenderTarget;

        /*
         * Always export the D3D Clear callback.
         */
        D3DCallbacks2.dwFlags |= D3DHAL2_CB32_CLEAR;
        D3DCallbacks2.Clear    = nvClear;

        /*
         * Always export the DrawPrimitive callbacks.
         */
        D3DCallbacks2.dwFlags |= D3DHAL2_CB32_DRAWONEPRIMITIVE
                              |  D3DHAL2_CB32_DRAWONEINDEXEDPRIMITIVE
                              |  D3DHAL2_CB32_DRAWPRIMITIVES;
        D3DCallbacks2.DrawOnePrimitive        = DrawOnePrimitive32;
        D3DCallbacks2.DrawOneIndexedPrimitive = DrawOneIndexedPrimitive32;
        D3DCallbacks2.DrawPrimitives          = DrawPrimitives32;

        /*
         * Copy as much of the data as possible up to dwExpectedSize.
         */
        memcpy(lpData->lpvData, &D3DCallbacks2, dwSize);

        /*
         * Set successful return code.
         */
        lpData->ddRVal = DD_OK;
    }
#endif  // !WINNT

    if (IsEqualIID_C((lpData->guidInfo), GUID_D3DCallbacks3))
    {
        D3DHAL_CALLBACKS3   D3DCallbacks3;

        DPF_LEVEL(NVDBG_LEVEL_INFO, "D3DGetDriverInfo - Process GUID_D3DCallbacks3");

        global.dwDXRuntimeVersion = max (global.dwDXRuntimeVersion, 0x0600);

        memset(&D3DCallbacks3, 0, sizeof(D3DHAL_CALLBACKS3));
        dwSize               = min(lpData->dwExpectedSize, sizeof(D3DHAL_CALLBACKS3));
        lpData->dwActualSize = sizeof(D3DHAL_CALLBACKS3);
        D3DCallbacks3.dwSize = dwSize;

        /*
         * Export DX6 DrawPrimitives2 DDI callback.
         */
        D3DCallbacks3.dwFlags |= D3DHAL3_CB32_DRAWPRIMITIVES2;
        D3DCallbacks3.DrawPrimitives2 = nvDrawPrimitives2;

        /*
         * Export DX6 Mult-Texture state validation callback.
         */
        D3DCallbacks3.dwFlags |= D3DHAL3_CB32_VALIDATETEXTURESTAGESTATE;
        D3DCallbacks3.ValidateTextureStageState = nvValidateTextureStageState;

        /*
         * Export DX6 callback for clear Render target, Z-Buffer and Stencil Buffer.
         */
        D3DCallbacks3.dwFlags |= D3DHAL3_CB32_CLEAR2;
        D3DCallbacks3.Clear2 = nvClear2;

        /*
         * Copy as much of the data as possible up to dwExpectedSize.
         */
        memcpy(lpData->lpvData, &D3DCallbacks3, dwSize);

        /*
         * Set successful return code.
         */
        lpData->ddRVal = DD_OK;
    }

    if (IsEqualIID_C ((lpData->guidInfo), GUID_D3DExtendedCaps))
    {
        D3DHAL_D3DEXTENDEDCAPS  D3DExtendedCaps;

        D3DExtendedCaps        = getDC()->nvD3DDevCaps.d3dExtCaps;
        dwSize                 = min (lpData->dwExpectedSize, sizeof(D3DHAL_D3DEXTENDEDCAPS));
        lpData->dwActualSize   = dwSize;
        D3DExtendedCaps.dwSize = dwSize;

#ifdef  STEREO_SUPPORT
        if (STEREO_ENABLED && pStereoData->StereoSettings.dwFlags & STEREO_DISABLETnL)
        {
            D3DExtendedCaps.dwVertexProcessingCaps  = 0;
            D3DExtendedCaps.dwMaxActiveLights       = 0;
        }
#endif  //STEREO_SUPPORT

        // Copy as much of the data as possible up to dwExpectedSize.
        memcpy(lpData->lpvData, &D3DExtendedCaps, dwSize);

        // Set successful return code.
        lpData->ddRVal = DD_OK;
    }

    if (IsEqualIID_C((lpData->guidInfo), GUID_D3DParseUnknownCommandCallback))
    {
        DPF_LEVEL(NVDBG_LEVEL_INFO, "D3DGetDriverInfo - Process GUID_D3DParseUnknownCommandCallback");

        global.dwDXRuntimeVersion = max (global.dwDXRuntimeVersion, 0x0600);

        // Get address of callback function.
        fnD3DParseUnknownCommandCallback = (PFND3DPARSEUNKNOWNCOMMAND)lpData->lpvData;

        // Set successful return code.
        lpData->ddRVal = DD_OK;
    }

#if 0  // alpha blit sppears to have been removed from dx7 build 169   27may99   CRD
    if (IsEqualIID_C ((lpData->guidInfo), GUID_DDMoreCaps)) {

        DDMORECAPS ddMoreCaps;

        global.dwDXRuntimeVersion = max (global.dwDXRuntimeVersion, 0x0700);

        if (lpData->dwExpectedSize != sizeof(DDMORECAPS) ) {
            NvReleaseSemaphore(pDriverData);
            dbgTracePop();
            return (DDHAL_DRIVER_HANDLED);
        }

        lpData->dwActualSize = sizeof(DDMORECAPS);

        ddMoreCaps.dwSize = sizeof(DDMORECAPS);

        ddMoreCaps.dwAlphaCaps = 0;
                                 DDALPHACAPS_BLTALPHAPIXELS |
                                 DDALPHACAPS_BLTSATURATE    |
                                 DDALPHACAPS_BLTPREMULT     |
                                 // DDALPHACAPS_BLTNONPREMULT |
                                 DDALPHACAPS_BLTARGBSCALE1F |
                                 DDALPHACAPS_BLTARGBSCALE4F |
                                 DDALPHACAPS_BLTALPHAFILL;

        ddMoreCaps.dwSVBAlphaCaps = 0;
                                    DDALPHACAPS_BLTALPHAPIXELS |
                                    DDALPHACAPS_BLTSATURATE |
                                    DDALPHACAPS_BLTPREMULT |
                                    // DDALPHACAPS_BLTNONPREMULT |
                                    DDALPHACAPS_BLTARGBSCALE1F |
                                    DDALPHACAPS_BLTARGBSCALE4F |
                                    DDALPHACAPS_BLTALPHAFILL;

        ddMoreCaps.dwFilterCaps = 0;
                                  DDFILTCAPS_BLTQUALITYFILTER |
                                  DDFILTCAPS_BLTCANDISABLEFILTER;

        ddMoreCaps.dwSVBFilterCaps = 0;
                                     DDFILTCAPS_BLTQUALITYFILTER |
                                     DDFILTCAPS_BLTCANDISABLEFILTER;

        memcpy(lpData->lpvData, &ddMoreCaps, sizeof(DDMORECAPS));
        lpData->ddRVal = DD_OK;
    }
#endif  // 0

    if (IsEqualIID_C ((lpData->guidInfo), GUID_DDMoreSurfaceCaps)) {

        DDMORESURFACECAPS ddMoreSurfaceCaps;
        DDSCAPSEX         ddsCapsEx, ddsCapsExAlt;

        global.dwDXRuntimeVersion = max (global.dwDXRuntimeVersion, 0x0600);

        // fill in everything until expectedsize... (first heap's caps)
        memset(&ddMoreSurfaceCaps, 0, sizeof(ddMoreSurfaceCaps));

        // caps for heaps 2..n
        memset(&ddsCapsEx, 0, sizeof(ddsCapsEx));
        memset(&ddsCapsExAlt, 0, sizeof(ddsCapsEx));

        ddMoreSurfaceCaps.dwSize = lpData->dwExpectedSize;

        ddMoreSurfaceCaps.ddsCapsMore.dwCaps2 = DDSCAPS2_CUBEMAP;
        ddsCapsEx.dwCaps2 = DDSCAPS2_CUBEMAP;

        ddsCapsExAlt.dwCaps2 = DDSCAPS2_CUBEMAP;

        lpData->dwActualSize = lpData->dwExpectedSize;

        dwSize = min(sizeof(ddMoreSurfaceCaps),lpData->dwExpectedSize);
        memcpy(lpData->lpvData, &ddMoreSurfaceCaps, dwSize);

        // now fill in other heaps...
        while (dwSize < lpData->dwExpectedSize) {
            memcpy((PBYTE)lpData->lpvData+dwSize, &ddsCapsEx, sizeof(DDSCAPSEX));
            dwSize += sizeof(DDSCAPSEX);
            memcpy((PBYTE)lpData->lpvData+dwSize, &ddsCapsExAlt, sizeof(DDSCAPSEX));
            dwSize += sizeof(DDSCAPSEX);
        }

        lpData->ddRVal = DD_OK;
    }

#if (!defined(WINNT) || defined(NVPE))
    if (IsEqualIID_C ((lpData->guidInfo), GUID_KernelCallbacks) ) {
        DDHAL_DDKERNELCALLBACKS kCB;

        dwSize = lpData->dwExpectedSize;

        if ( sizeof(kCB) < dwSize )
            dwSize = sizeof(kCB);
        lpData->dwActualSize = sizeof(kCB);

        kCB.dwSize = sizeof(DDHAL_DDKERNELCALLBACKS);
        kCB.dwFlags = DDHAL_KERNEL_SYNCSURFACEDATA | DDHAL_KERNEL_SYNCVIDEOPORTDATA;
        kCB.SyncSurfaceData = SafeSyncSurfaceData;  // we're not doing anything
                                                    // on EITHER of these yet
        kCB.SyncVideoPortData = SafeSyncVideoPortData;

        memcpy(lpData->lpvData, &kCB, dwSize );
        //lpData->ddRVal = DDERR_CURRENTLYNOTAVAIL;
        lpData->ddRVal = DD_OK;
    }

    if (IsEqualIID_C ((lpData->guidInfo), GUID_KernelCaps) ) {
        DDKERNELCAPS KernelCaps;

        // these functions can be called to control the Overlay,
        // so even if VPE is not here we need to have these
        if (lpData->dwExpectedSize != sizeof(DDKERNELCAPS)) {
            dbgTracePop();
            NvReleaseSemaphore(pDriverData);
            return (DDHAL_DRIVER_HANDLED);
        }

        lpData->dwActualSize = sizeof(DDKERNELCAPS);

        KernelCaps.dwSize = sizeof(DDKERNELCAPS);
        KernelCaps.dwCaps = DDKERNELCAPS_SKIPFIELDS     |
                            DDKERNELCAPS_AUTOFLIP       |
                            DDKERNELCAPS_SETSTATE       |
                            DDKERNELCAPS_LOCK           |
                            DDKERNELCAPS_FLIPVIDEOPORT  |
                            DDKERNELCAPS_FLIPOVERLAY    |
                            DDKERNELCAPS_CAPTURE_SYSMEM |
                            // DDKERNELCAPS_CAPTURE_NONLOCALVIDMEM |
                            DDKERNELCAPS_FIELDPOLARITY  |
                            DDKERNELCAPS_CAPTURE_INVERTED;

        KernelCaps.dwIRQCaps = DDIRQ_VPORT0_VSYNC |
                               //  DDIRQ_BUSMASTER;
                               //  #define DDIRQ_BUSMASTER         0x00000002l
                               0x00000002;

        // DDIRQ_DISPLAY_VSYNC      |
        // DDIRQ_RESERVED1          |
        // DDIRQ_VPORT0_VSYNC       // this is the only IRQ we'll be supporting
        // DDIRQ_VPORT0_LINE        |
        // DDIRQ_VPORT1_VSYNC       |
        // DDIRQ_VPORT1_LINE        |


        memcpy(lpData->lpvData, &KernelCaps, sizeof(DDKERNELCAPS) );
        //lpData->ddRVal = DDERR_CURRENTLYNOTAVAIL;
        lpData->ddRVal = DD_OK;
    }
#endif // !WINNT || NVPE

    if (IsEqualIID_C ((lpData->guidInfo), GUID_MiscellaneousCallbacks) ) {
        DDHAL_DDMISCELLANEOUSCALLBACKS miscCB;

        dwSize = lpData->dwExpectedSize;

        global.dwDXRuntimeVersion = max (global.dwDXRuntimeVersion, 0x0500);

        if ( sizeof(miscCB) < dwSize )
            dwSize = sizeof(miscCB);
        lpData->dwActualSize = sizeof(miscCB);
        memset(&miscCB, 0, dwSize);
        miscCB.dwSize = dwSize;

#ifdef WINNT
        miscCB.dwFlags = DDHAL_MISCCB32_GETAVAILDRIVERMEMORY;
#else // !WINNT
        miscCB.dwFlags = DDHAL_MISCCB32_GETHEAPALIGNMENT |
                         DDHAL_MISCCB32_UPDATENONLOCALHEAP |
                         DDHAL_MISCCB32_GETAVAILDRIVERMEMORY;
        miscCB.GetHeapAlignment = GetHeapAlignment32;
        miscCB.UpdateNonLocalHeap = UpdateNonLocalHeap32;
#endif // !WINNT

        // only GetAvailDriverMemory32 is valid for WINNT
        miscCB.GetAvailDriverMemory = GetAvailDriverMemory32;

        memcpy(lpData->lpvData, &miscCB, dwSize );
        lpData->ddRVal = DD_OK;
    }

    if (IsEqualIID_C ((lpData->guidInfo), GUID_Miscellaneous2Callbacks) ) {
        DDHAL_DDMISCELLANEOUS2CALLBACKS misc2CB;

        dwSize = lpData->dwExpectedSize;

        global.dwDXRuntimeVersion = max (global.dwDXRuntimeVersion, 0x0700);

        if ( sizeof(misc2CB) < dwSize )
            dwSize = sizeof(misc2CB);
        lpData->dwActualSize = sizeof(misc2CB);
        memset(&misc2CB, 0, dwSize);
        misc2CB.dwSize = dwSize;
        misc2CB.dwFlags = 0;

#if 0 // alpha blit sppears to have been removed from dx7 build 169   27may99   CRD
        // alphablt
        misc2CB.dwFlags |= DDHAL_MISC2CB32_ALPHABLT;
        misc2CB.AlphaBlt = Blit32;  // Use common callback with Blit32 calls
#endif // 0

        // createsurfaceex
        misc2CB.dwFlags |= DDHAL_MISC2CB32_CREATESURFACEEX;
        misc2CB.CreateSurfaceEx = nvCreateSurfaceEx;

        // getdriverstate
        misc2CB.dwFlags |= DDHAL_MISC2CB32_GETDRIVERSTATE;
        misc2CB.GetDriverState = nvGetDriverState;

        // destroyddlocal
        misc2CB.dwFlags |= DDHAL_MISC2CB32_DESTROYDDLOCAL;
        misc2CB.DestroyDDLocal = nvDestroyDDLocal;

        memcpy(lpData->lpvData, &misc2CB, dwSize );
        lpData->ddRVal = DD_OK;
    }

#if (NVARCH >= 0x10)
    // Check for Motion Comp GUID
    if (IsEqualIID_C ((lpData->guidInfo), GUID_MotionCompCallbacks)) {
        if (pDriverData->NvDeviceVersion >= NV_DEVICE_VERSION_10)
            nvGetMoCompDriverInfo(lpData);
    }
#endif // NVARCH >= 0x10

    if (IsEqualGUID_C((lpData->guidInfo), GUID_NonLocalVidMemCaps ) ) {
        LPDDNONLOCALVIDMEMCAPS lpCaps;
        int i;

        /* Size validation code omitted for clarity */
        dwSize = min(lpData->dwExpectedSize, sizeof(DDNONLOCALVIDMEMCAPS));
        lpCaps = (LPDDNONLOCALVIDMEMCAPS)(lpData->lpvData);
        lpCaps->dwSize = dwSize;

        lpCaps->dwNLVBCaps     = pHalInfo->ddCaps.dwCaps;
        lpCaps->dwNLVBCaps2    = pHalInfo->ddCaps.dwCaps2;
        lpCaps->dwNLVBCKeyCaps = pHalInfo->ddCaps.dwCKeyCaps;
        lpCaps->dwNLVBFXCaps   = pHalInfo->ddCaps.dwFXCaps;

        for ( i=0; i < DD_ROP_SPACE; i++ )
            lpCaps->dwNLVBRops[i] = ropList[i];

        lpData->dwActualSize = dwSize;
        lpData->ddRVal = DD_OK;
    }

#if (!defined(WINNT) || defined(NVPE))      // BUGBUG - we will add Win2K videoport support

    if (IsEqualIID_C ((lpData->guidInfo), GUID_VideoPortCallbacks) ) {

        DDHAL_DDVIDEOPORTCALLBACKS vpCB;

        dwSize = lpData->dwExpectedSize;

        // this test prevent reporting of VPE functions so that if necessary we can turn off VPE via registry.
        if (pDriverData->bEnableVPE == 1 ) {

            if ( sizeof(vpCB) < dwSize )
                dwSize = sizeof(vpCB);
            lpData->dwActualSize = sizeof(vpCB);
            memset(&vpCB, 0, dwSize);
            vpCB.dwSize = dwSize;

            vpCB.dwFlags = DDHAL_VPORT32_CANCREATEVIDEOPORT |
                           DDHAL_VPORT32_CREATEVIDEOPORT    |
                           DDHAL_VPORT32_DESTROY            |
                           DDHAL_VPORT32_FLIP               |
                           DDHAL_VPORT32_GETBANDWIDTH       |
                           DDHAL_VPORT32_GETINPUTFORMATS    |
                           DDHAL_VPORT32_GETOUTPUTFORMATS   |
                           DDHAL_VPORT32_GETFIELD           |
                           DDHAL_VPORT32_GETCONNECT         |
                           DDHAL_VPORT32_GETFLIPSTATUS      |
                           DDHAL_VPORT32_UPDATE             |
                           DDHAL_VPORT32_WAITFORSYNC        |
                           DDHAL_VPORT32_GETSIGNALSTATUS;


            vpCB.CanCreateVideoPort         = CanCreateVideoPort32;
            vpCB.CreateVideoPort            = CreateVideoPort32;
            vpCB.DestroyVideoPort           = DestroyVideoPort32;
            vpCB.FlipVideoPort              = FlipVideoPort32;

            vpCB.GetVideoPortBandwidth      = GetVideoPortBandwidth32;
            vpCB.GetVideoPortInputFormats   = GetVideoPortInputFormat32;
            vpCB.GetVideoPortOutputFormats  = GetVideoPortOutputFormat32;
            vpCB.GetVideoPortField          = GetVideoPortField32;
            vpCB.GetVideoPortConnectInfo    = GetVideoPortConnectInfo;

            vpCB.GetVideoPortFlipStatus     = GetVideoPortFlipStatus32;
            vpCB.UpdateVideoPort            = UpdateVideoPort32;
            vpCB.WaitForVideoPortSync       = WaitForVideoPortSync32;
            vpCB.GetVideoSignalStatus       = GetVideoSignalStatus32;

            memcpy(lpData->lpvData, &vpCB, dwSize );
            lpData->ddRVal = DD_OK;
        }

    }

    if (IsEqualIID_C ((lpData->guidInfo), GUID_VideoPortCaps) ) {
        DDVIDEOPORTCAPS VideoPortCaps;
        DDVIDEOPORTCAPS *pVideoPortCapsDest = (DDVIDEOPORTCAPS*)lpData->lpvData;
        DWORD dwIndex;

        // this test prevent reporting of VPE functions so that
        // if necessary we can turn off VPE via registry.
        if (pDriverData->bEnableVPE == 1 ) {
            // expecting query for 1 video port
            if (lpData->dwExpectedSize != (sizeof(VideoPortCaps))) {
                NvReleaseSemaphore(pDriverData);
                dbgTracePop();
                return (DDHAL_DRIVER_HANDLED);
            }

            lpData->dwActualSize = (sizeof(VideoPortCaps) );

            // index changed to allow only 1 report resolution, for time being only NTSC
            // until class structure is changed to test PAL etc
            for (dwIndex = 0; dwIndex < 1; dwIndex++) {
                if (pDriverData->NvDeviceVersion >= NV_DEVICE_VERSION_10) {

                  memset(&VideoPortCaps, 0, sizeof(DDVIDEOPORTCAPS));

                  VideoPortCaps.dwSize = sizeof(DDVIDEOPORTCAPS);

                  VideoPortCaps.dwFlags = DDVPD_WIDTH             |
                                          DDVPD_HEIGHT            |
                                          DDVPD_ID                |
                                          DDVPD_CAPS              |
                                          DDVPD_FX                |
                                          DDVPD_AUTOFLIP          |
                                          DDVPD_ALIGN             |
                                          DDVPD_PREFERREDAUTOFLIP |
                                          DDVPD_FILTERQUALITY;

                  VideoPortCaps.dwVideoPortID = dwIndex;
                  // for more supported video modes, place the resolutions here
                  //        VideoPortCaps.dwMaxWidth      = ST_VPE_MAX_INPUT_X;
                  //       VideoPortCaps.dwMaxVBIWidth = ST_VPE_MAX_INPUT_X;
                  //          VideoPortCaps.dwMaxHeight   = ST_VPE_MAX_INPUT_Y;
                  VideoPortCaps.dwMaxWidth    = 4096;   // must talk to joe and get
                                                        // the details on this..
                  VideoPortCaps.dwMaxVBIWidth = 4096;
                  VideoPortCaps.dwMaxHeight   = 4096;    //this value is calculated from
                                                         // 2^24 (bytes)  / 2  / 2048 pixels / line

                  // could have share even/odd, but for now keep things simple

                  VideoPortCaps.dwCaps =
                  DDVPCAPS_AUTOFLIP       |
                  DDVPCAPS_INTERLACED     |
                  DDVPCAPS_NONINTERLACED  |
                  // DDVPCAPS_SHAREABLE     |
                  DDVPCAPS_SKIPEVENFIELDS |
                  DDVPCAPS_SKIPODDFIELDS  |
                  DDVPCAPS_VBISURFACE     |
                  DDVPCAPS_OVERSAMPLEDVBI;

                  VideoPortCaps.dwFX =
                  DDVPFX_CROPTOPDATA      |
                  DDVPFX_INTERLEAVE       |
                  DDVPFX_PRESHRINKXB      |
                  DDVPFX_PRESHRINKY       | // y can accept arbitary (except 0)
                  DDVPFX_VBICONVERT       |
                  DDVPFX_VBINOSCALE       |
                  DDVPFX_VBINOINTERLEAVE  |
                  DDVPFX_IGNOREVBIXCROP;


                  VideoPortCaps.dwNumAutoFlipSurfaces = 5;


                  VideoPortCaps.dwAlignVideoPortBoundary      = pDriverData->vpp.dwOverlayByteAlignmentPad + 1;
                  VideoPortCaps.dwAlignVideoPortPrescaleWidth = 1;

                  // can't crop to an arbitary rectangle!!
                  VideoPortCaps.dwAlignVideoPortCropBoundary  = 1;
                  VideoPortCaps.dwAlignVideoPortCropWidth     = 1;

                  // not valid for PRESHRINKX/YB flag as set above
                  VideoPortCaps.dwPreshrinkXStep = 24;
                  VideoPortCaps.dwPreshrinkYStep = 0x400;


                  VideoPortCaps.dwNumVBIAutoFlipSurfaces = 5;

                  VideoPortCaps.dwNumPreferredAutoflip =3;
                  VideoPortCaps.wNumFilterTapsX = 2;
                  VideoPortCaps.wNumFilterTapsY = 1;
                  memcpy(&pVideoPortCapsDest[dwIndex], &VideoPortCaps, sizeof(VideoPortCaps) );

               } else {


                  memset(&VideoPortCaps, 0, sizeof(DDVIDEOPORTCAPS));

                  VideoPortCaps.dwSize = sizeof(DDVIDEOPORTCAPS);

                  VideoPortCaps.dwFlags = DDVPD_WIDTH             |
                                          DDVPD_HEIGHT            |
                                          DDVPD_ID                |
                                          DDVPD_CAPS              |
                                          DDVPD_FX                |
                                          DDVPD_AUTOFLIP          |
                                          DDVPD_ALIGN             |
                                          DDVPD_PREFERREDAUTOFLIP |
                                          DDVPD_FILTERQUALITY;

                  VideoPortCaps.dwVideoPortID = dwIndex;
                  // for more supported video modes, place the resolutions here
                  //        VideoPortCaps.dwMaxWidth      = ST_VPE_MAX_INPUT_X;
                  //       VideoPortCaps.dwMaxVBIWidth = ST_VPE_MAX_INPUT_X;
                  //          VideoPortCaps.dwMaxHeight   = ST_VPE_MAX_INPUT_Y;
                  VideoPortCaps.dwMaxWidth    = 4096;   // must talk to joe and get
                                                        // the details on this..
                  VideoPortCaps.dwMaxVBIWidth = 4096;
                  VideoPortCaps.dwMaxHeight   = 640;    // just arbitarily larger than
                                                        // PAL field *2 for progressive

                  // could have share even/odd, but for now keep things simple

                  VideoPortCaps.dwCaps =
                  DDVPCAPS_AUTOFLIP       |
                  DDVPCAPS_INTERLACED     |
                  DDVPCAPS_NONINTERLACED  |
                  // DDVPCAPS_SHAREABLE     |
                  DDVPCAPS_SKIPEVENFIELDS |
                  DDVPCAPS_SKIPODDFIELDS  |
                  DDVPCAPS_VBISURFACE     |
                  DDVPCAPS_OVERSAMPLEDVBI;

                  VideoPortCaps.dwFX =
                  DDVPFX_CROPTOPDATA      |
                  DDVPFX_INTERLEAVE       |
                  DDVPFX_PRESHRINKXB      |
                  DDVPFX_PRESHRINKY       | // y can accept arbitary (except 0)
                  DDVPFX_VBICONVERT       |
                  DDVPFX_VBINOSCALE       |
                  DDVPFX_VBINOINTERLEAVE  |
                  DDVPFX_IGNOREVBIXCROP;


                  VideoPortCaps.dwNumAutoFlipSurfaces = 5;


                  VideoPortCaps.dwAlignVideoPortBoundary      = pDriverData->vpp.dwOverlayByteAlignmentPad + 1;
                  VideoPortCaps.dwAlignVideoPortPrescaleWidth = 1;

                  // can't crop to an arbitary rectangle!!
                  VideoPortCaps.dwAlignVideoPortCropBoundary  = 1;
                  VideoPortCaps.dwAlignVideoPortCropWidth     = 1;

                  // not valid for PRESHRINKX/YB flag as set above
                  VideoPortCaps.dwPreshrinkXStep = 24;
                  VideoPortCaps.dwPreshrinkYStep = 0x400;


                  VideoPortCaps.dwNumVBIAutoFlipSurfaces = 5;

                  VideoPortCaps.dwNumPreferredAutoflip =3;
                  VideoPortCaps.wNumFilterTapsX = 5;
                  VideoPortCaps.wNumFilterTapsY = 1;

                  memcpy(&pVideoPortCapsDest[dwIndex], &VideoPortCaps, sizeof(VideoPortCaps) );
               }
            }
            lpData->ddRVal = DD_OK;
        }
    }
#endif // !WINNT || NVPE      // BUGBUG - we will add Win2K videoport support

    if (IsEqualIID_C((lpData->guidInfo), GUID_ZPixelFormats))
    {
        DPF_LEVEL(NVDBG_LEVEL_INFO, "D3DGetDriverInfo - Process GUID_ZPixelFormats");

        global.dwDXRuntimeVersion = max (global.dwDXRuntimeVersion, 0x0600);

        /*
         * Return a pointer to the z-buffer format data.
         */
        dwSize = min(lpData->dwExpectedSize, sizeof(NvZPixelFormats));
        memcpy(lpData->lpvData, &NvZPixelFormats, dwSize);
        lpData->dwActualSize = dwSize;

        /*
         * Don't export 24-bit z-buffer formats if the registry has disabled them.
         */
        if (!(getDC()->nvD3DRegistryData.regD3DEnableBits1 & D3D_REG_Z24ENABLE_ENABLE)) {
            ((ZPIXELFORMATS *)lpData->lpvData)->dwNumZFormats = NV_NUM_16BIT_ZBUFFER_FORMATS;
        }

        /*
         * Set successful return code.
         */
        lpData->ddRVal = DD_OK;
    }

#ifdef WINNT
    // Under Win2K/DX7 there is a GUID_ for UpdateNonLocalHeap where under Win9x
    // this function has been a callback.

    if (IsEqualIID_C((lpData->guidInfo), GUID_UpdateNonLocalHeap) && ppdev->AgpHeap)
    {
#ifdef NV_AGP
        nvAssert(0); // we should never get GUID_UpdateNonLocalHeap with NV_AGP enabled
#else // !NV_AGP
        DD_UPDATENONLOCALHEAPDATA *pHeapData;
        ULONG pAgpBase;

        pHeapData = (DD_UPDATENONLOCALHEAPDATA *) lpData->lpvData;
        pHeapData->dwHeap = AGP_HEAP;
        pDriverData->GARTPhysicalBase = pHeapData->fpGARTDev;
        pDriverData->GARTLinearHeapOffset = pHeapData->fpGARTLin;

        // get the aperture size as set in the BIOS
        NvRmConfigGet(pDriverData->dwRootHandle,
                      NV_WIN_DEVICE,
                      NV_CFG_AGP_PHYS_BASE,
                      &pAgpBase);
        NvWin2KGetAgpLimit(pDriverData, pDriverData->dwRootHandle, NV_WIN_DEVICE);

        if (ppdev->AgpPushBuffer && (ppdev->DmaPushBufTotalSize <= pDriverData->regMaxAGPLimit))
            pDriverData->regMaxAGPLimit -= ppdev->DmaPushBufTotalSize;

        NvWin2KMapAgpHeap(pDriverData);
#endif // !NV_AGP
    }

    if (IsEqualIID_C((lpData->guidInfo), GUID_GetHeapAlignment))
    {
        DD_GETHEAPALIGNMENTDATA *lpGhaData;
        lpGhaData = (DD_GETHEAPALIGNMENTDATA *) lpData->lpvData;

        if (lpGhaData->dwHeap == 0) {
            lpGhaData->Alignment.ddsCaps.dwCaps = DDSCAPS_OFFSCREENPLAIN |
                                                  DDSCAPS_EXECUTEBUFFER  |
                                                  DDSCAPS_OVERLAY        |
                                                  DDSCAPS_TEXTURE        |
                                                  DDSCAPS_ZBUFFER        |
                                                  DDSCAPS_ALPHA          |
                                                  DDSCAPS_FLIP;

            /* Alignments in bytes */

            lpGhaData->Alignment.ExecuteBuffer.Linear.dwStartAlignment = 0;
            lpGhaData->Alignment.ExecuteBuffer.Linear.dwPitchAlignment = 0;

            lpGhaData->Alignment.Overlay.Linear.dwStartAlignment = NV_OVERLAY_BYTE_ALIGNMENT;
            lpGhaData->Alignment.Overlay.Linear.dwPitchAlignment = NV_OVERLAY_BYTE_ALIGNMENT;

            lpGhaData->Alignment.Texture.Linear.dwStartAlignment = pDriverData->dwSurfaceAlign; /* Texture surfaces, not our optimized texture alignment */
            lpGhaData->Alignment.Texture.Linear.dwPitchAlignment = pDriverData->dwSurfaceAlign;

            lpGhaData->Alignment.ZBuffer.Linear.dwStartAlignment = pDriverData->dwSurfaceAlign;
            lpGhaData->Alignment.ZBuffer.Linear.dwPitchAlignment = pDriverData->dwSurfaceAlign;

            lpGhaData->Alignment.AlphaBuffer.Linear.dwStartAlignment = pDriverData->dwSurfaceAlign;
            lpGhaData->Alignment.AlphaBuffer.Linear.dwPitchAlignment = pDriverData->dwSurfaceAlign;

            lpGhaData->Alignment.Offscreen.Linear.dwStartAlignment = pDriverData->dwSurfaceAlign;
            lpGhaData->Alignment.Offscreen.Linear.dwPitchAlignment = pDriverData->dwSurfaceAlign;

            lpGhaData->Alignment.FlipTarget.Linear.dwStartAlignment = pDriverData->dwSurfaceBitAlign;
            lpGhaData->Alignment.FlipTarget.Linear.dwPitchAlignment = pDriverData->dwSurfaceAlign;

        }
    }

    if (IsEqualIID_C((lpData->guidInfo), GUID_NTPrivateDriverCaps))
    {
#define DDHAL_PRIVATECAP_RESERVED1 0x00000004l        // WinXP - no 7 second stall on mode switch
        DD_NTPRIVATEDRIVERCAPS *pNTPrivateDriverCaps = (DD_NTPRIVATEDRIVERCAPS*)lpData->lpvData;
        pNTPrivateDriverCaps->dwPrivateCaps = DDHAL_PRIVATECAP_ATOMICSURFACECREATION
                                            | DDHAL_PRIVATECAP_NOTIFYPRIMARYCREATION
                                            | DDHAL_PRIVATECAP_RESERVED1;
        lpData->ddRVal = DD_OK;
    }
#endif // WINNT

    //watch out for stereo call GUID_DDStereoMode
    //only allow DX8 driver calls to be parsed by Celsius and Kelvin driver
    if (IsEqualIID_C((lpData->guidInfo), GUID_GetDriverInfo2) &&
        ((DD_STEREOMODE*)lpData->lpvData)->dwHeight == D3DGDI2_MAGIC &&
        (
#if (NVARCH >= 0x020)
        (pDriverData->nvD3DPerfData.dwNVClasses & NVCLASS_FAMILY_KELVIN) ||
#endif // (NVARCH >= 0x020)
        (pDriverData->nvD3DPerfData.dwNVClasses & NVCLASS_FAMILY_CELSIUS)
         ))
    {

        DD_GETDRIVERINFO2DATA* pGDI2 = (DD_GETDRIVERINFO2DATA*)lpData->lpvData;

        switch (pGDI2->dwType)
        {
            case D3DGDI2_TYPE_GETD3DCAPS8:
            {
                DWORD copySize = min(sizeof(getDC()->nvD3DDevCaps.dwD3DCap8), pGDI2->dwExpectedSize);

                global.dwDXRuntimeVersion = max (global.dwDXRuntimeVersion, 0x0800);

                memcpy(lpData->lpvData, &(getDC()->nvD3DDevCaps.dwD3DCap8), copySize);
                lpData->dwActualSize = copySize;
                lpData->ddRVal       = DD_OK;
            }
            break;

            case D3DGDI2_TYPE_GETFORMATCOUNT:
            {
                DD_GETFORMATCOUNTDATA * pGFCD = (DD_GETFORMATCOUNTDATA *)lpData->lpvData;

#ifdef TEXFORMAT_CRD // --------------------------------

                pGFCD->dwFormatCount = getDC()->dwPixelFormatCount;

#else // !TEXFORMAT_CRD  --------------------------------

#if (NVARCH >= 0x020)
                if (pDriverData->nvD3DPerfData.dwNVClasses & NVCLASS_FAMILY_KELVIN)
                {
#ifdef DXT_SUPPORT
                    if ((getDC()->nvD3DRegistryData.regD3DEnableBits1 & D3D_REG_TEXTURECOMPRESSIONENABLE_MASK) == D3D_REG_TEXTURECOMPRESSIONENABLE_ENABLE)
                    {
                        pGFCD->dwFormatCount = sizeof(kelvinPixelFormatsDX8) / sizeof(DDPIXELFORMAT);
                    }
                    else
#endif
                    {
                        pGFCD->dwFormatCount = sizeof(kelvinPixelFormatsDX8NoDXT) / sizeof(DDPIXELFORMAT);
                    }
                }
                else
#endif
                {
#ifdef DXT_SUPPORT
                    if ((getDC()->nvD3DRegistryData.regD3DEnableBits1 & D3D_REG_TEXTURECOMPRESSIONENABLE_MASK) == D3D_REG_TEXTURECOMPRESSIONENABLE_ENABLE)
                    {
                        pGFCD->dwFormatCount =  sizeof(celsiusPixelFormatsDX8) / sizeof(DDPIXELFORMAT);
                    }
                    else
#endif
                    {
                        pGFCD->dwFormatCount = sizeof(celsiusPixelFormatsDX8NoDXT) / sizeof(DDPIXELFORMAT);
                    }
                }

                if (pDriverData->nvD3DPerfData.dwNVClasses & (NVCLASS_FAMILY_CELSIUS | NVCLASS_FAMILY_KELVIN)) {
                    if ((global.dwDXRuntimeVersion < 0x0800) ||
                        ((getDC()->nvD3DRegistryData.regD3DEnableBits1 & D3D_REG_PALETTEENABLE_MASK) == D3D_REG_PALETTEENABLE_DISABLE))
                    {
                        pGFCD->dwFormatCount -= NV_NUM_8BIT_TEXTURE_FORMATS;
                    }
                }

#endif // !TEXFORMAT_CRD  --------------------------------

                lpData->dwActualSize = sizeof(DD_GETFORMATCOUNTDATA);
                lpData->ddRVal       = DD_OK;
            }
            break;

            case D3DGDI2_TYPE_GETFORMAT:
            {
                DD_GETFORMATDATA* pGFD = (DD_GETFORMATDATA *)lpData->lpvData;

#ifdef TEXFORMAT_CRD // --------------------------------

                pGFD->format = (getDC()->pPixelFormats)[pGFD->dwFormatIndex];

#else // !TEXFORMAT_CRD  --------------------------------

#if (NVARCH >= 0x020)
                if (pDriverData->nvD3DPerfData.dwNVClasses & NVCLASS_FAMILY_KELVIN)
                {
#ifdef DXT_SUPPORT
                    if ((getDC()->nvD3DRegistryData.regD3DEnableBits1 & D3D_REG_TEXTURECOMPRESSIONENABLE_MASK) == D3D_REG_TEXTURECOMPRESSIONENABLE_ENABLE)
                    {
                        pGFD->format = kelvinPixelFormatsDX8[pGFD->dwFormatIndex];
                    }
                    else
#endif // DXT_SUPPORT
                    {
                        pGFD->format = kelvinPixelFormatsDX8NoDXT[pGFD->dwFormatIndex];
                    }
                }
                else
#endif // (NVARCH >= 0x020)
                {
#ifdef DXT_SUPPORT
                    if ((getDC()->nvD3DRegistryData.regD3DEnableBits1 & D3D_REG_TEXTURECOMPRESSIONENABLE_MASK) == D3D_REG_TEXTURECOMPRESSIONENABLE_ENABLE)
                    {
                        pGFD->format = celsiusPixelFormatsDX8[pGFD->dwFormatIndex];
                    }
                    else
#endif // DXT_SUPPORT
                    {
                        pGFD->format = celsiusPixelFormatsDX8NoDXT[pGFD->dwFormatIndex];
                    }
                }
#endif // !TEXFORMAT_CRD  --------------------------------

                lpData->dwActualSize = sizeof(DD_GETFORMATDATA);
                lpData->ddRVal       = DD_OK;
            }
            break;

            case D3DGDI2_TYPE_DXVERSION:
            {
                DD_DXVERSION* pGFD = (DD_DXVERSION *)lpData->lpvData;
                global.dwDXRuntimeVersion = max (global.dwDXRuntimeVersion, pGFD->dwDXVersion);
                lpData->dwActualSize = sizeof(DD_DXVERSION);
                lpData->ddRVal       = DD_OK;
            }
            break;
        }
    }

    NvReleaseSemaphore(pDriverData);
    dbgTracePop();
    return (DDHAL_DRIVER_HANDLED);

} // GetDriverInfo32

//---------------------------------------------------------------------------
//
// SetExclusiveMode32 DDHAL callback
//
#ifndef WINNT
DWORD __stdcall SetExclusiveMode32 (LPDDHAL_SETEXCLUSIVEMODEDATA lpSetExclusiveMode)
{
HANDLE eventExclusive;

    lpSetExclusiveMode->ddRVal = DD_OK;

    // We need to signal quicktweak that we have entered fullscreen exclusive mode
    // for mobile hotkey disabling. This scenario is guaranteed to be in a single
    // physical adapter configuration.
    eventExclusive = OpenEvent(EVENT_MODIFY_STATE, FALSE, EVENTNAME_DXEXCLUSIVEMODE);
    if (eventExclusive) {
        if (lpSetExclusiveMode->dwEnterExcl) {
            SetEvent(eventExclusive);
        } else {
            ResetEvent(eventExclusive);
        }

        CloseHandle(eventExclusive);
    }

    return DDHAL_DRIVER_HANDLED;
}
#endif  // !WINNT

//---------------------------------------------------------------------------
//
// FlipToGDISurface32 DDHAL callback
//
// - enabling this callback causes flashing problems with MS Combat Flight Simulator 2
//
DWORD __stdcall FlipToGDISurface32 (LPDDHAL_FLIPTOGDISURFACEDATA lpFlipToGDISurface)
{
#ifndef WINNT
    lpFlipToGDISurface->ddRVal = DD_OK;
    nvSetDriverDataPtrFromDDGbl (lpFlipToGDISurface->lpDD);

    // In extended mode, the DX runtime could call us here after the push buffer has
    // been destroyed by the first call to DestroyDriver32.  Test for validity of the push buffer.
    if ((pDriverData->nvD3DPerfData.dwNVClasses & NVCLASS_0097_KELVIN) ||
        (!getDC()->nvPusher.isValid()))
    {
        return DDHAL_DRIVER_NOTHANDLED;
    }
    else if ((pDriverData->nvD3DPerfData.dwNVClasses & (NVCLASS_1196_CELSIUS | NVCLASS_0096_CELSIUS))
          && (lpFlipToGDISurface->dwToGDI))
    {
        // flush out all but one v-blank
        WaitForIdle(TRUE, FALSE);

        // get the current v-blank count
        NV_CFGEX_VBLANK_COUNTER_MULTI_PARAMS nvVBCounter;
        nvVBCounter.Head = GET_CURRENT_HEAD();
        NvRmConfigGetEx(pDriverData->dwRootHandle, NV_WIN_DEVICE, NV_CFGEX_VBLANK_COUNTER_MULTI,
            &nvVBCounter, sizeof(nvVBCounter));

        // wait for one more v-blank (only really required in triple buffered case)
        DWORD dwFirstCount = nvVBCounter.VBlankCounter;
        do {
            NvRmConfigGetEx(pDriverData->dwRootHandle, NV_WIN_DEVICE, NV_CFGEX_VBLANK_COUNTER_MULTI,
                &nvVBCounter, sizeof(nvVBCounter));
        } while (nvVBCounter.VBlankCounter == dwFirstCount);

        // tell the HW we want to start writing to the next buffer, this must stay in-sync
        nvglSetNv15CelsiusSyncIncWrite (NV_DD_CELSIUS);

        BOOL  bCloneMode = pDriverData->dwDesktopState == NVTWINVIEW_STATE_CLONE;
        DWORD dwDAC      = NV_DD_VIDEO_LUT_CURSOR_DAC + (bCloneMode ? 0 : pDXShare->dwHeadNumber);

        DWORD dwNumHeads = bCloneMode ? pDriverData->dwHeads : 1;
        DWORD dwFormat   = (NV07C_SET_IMAGE_FORMAT_NOTIFY_WRITE_ONLY << 31) |
                           (NV07C_SET_IMAGE_FORMAT_FLAGS_COMPLETE_ON_OBJECT_CLEANUP << 25) |
                           (((DIBENGINEHDR1 *)pDXShare->pFlatDibeng)->deDeltaScan);
        dwFormat |= (NV07C_SET_IMAGE_FORMAT_WHEN_IMMEDIATELY << 20);
        dwFormat |= bCloneMode ? (NV07C_SET_IMAGE_FORMAT_MULTIHEAD_SYNC_ENABLED << 24) :
                                 (NV07C_SET_IMAGE_FORMAT_MULTIHEAD_SYNC_DISABLED << 24);

        PRIMARY_BUFFER_INDEX ^= 0x1;

        for (DWORD dwHead = 0; dwHead < dwNumHeads; dwHead++) {

            // calculate offset, the RM will add the pan & scan adjustment from the display driver if needed
            DWORD dwOffset = GET_PRIMARY_ADDR() - pDriverData->BaseAddress;

            // program the flip
            nvglSetObject (NV_DD_SURFACES, dwDAC + dwHead); // load the DAC object
            nvglSetNv15VideoLUTCursorDACImageData (NV_DD_SURFACES, PRIMARY_BUFFER_INDEX, dwOffset, dwFormat);
        }

        // put back the NV_DD_SURFACES_2D object
        nvglSetObject (NV_DD_SURFACES, NV_DD_SURFACES_2D);

        nvPusherStart(TRUE);

        // update frame counter
        CURRENT_FLIP ++;

        return (DDHAL_DRIVER_HANDLED);
    }

#endif // !WINNT
    return DDHAL_DRIVER_NOTHANDLED;
}

//---------------------------------------------------------------------------

/*
 * buildDDHALInfo32
 *
 * build DDHALInfo structure
 */
BOOL __stdcall buildDDHALInfo32(GLOBALDATA *pDriverData)
{
    int i;
#ifndef NVPE
    char regStr[256] = {0,0,0,0,0,0};
    HKEY hKey;
#endif // NVPE

    dbgTracePush ("buildDDHALInfo32");

    /*
     * fill out the main driver callbacks
     */
    memset(&pDriverData->DDCallbacks, 0, sizeof(DDHAL_DDCALLBACKS));
    pDriverData->DDCallbacks.dwSize                = sizeof(DDHAL_DDCALLBACKS);
//    pDriverData->DDCallbacks.SetMode               = SetMode32;   Never called by DDRAW
    pDriverData->DDCallbacks.WaitForVerticalBlank  = WaitForVerticalBlank32;
    pDriverData->DDCallbacks.GetScanLine           = GetScanLine32;
    pDriverData->DDCallbacks.CreateSurface         = CreateSurface32;
    pDriverData->DDCallbacks.CanCreateSurface      = CanCreateSurface32;
#ifndef WINNT
    pDriverData->DDCallbacks.SetExclusiveMode      = SetExclusiveMode32;
#endif

    pDriverData->DDCallbacks.dwFlags               = DDHAL_CB32_WAITFORVERTICALBLANK
#ifndef WINNT
                                                   | DDHAL_CB32_SETEXCLUSIVEMODE
#endif
//                                                 | DDHAL_CB32_SETMODE
                                                   | DDHAL_CB32_GETSCANLINE
                                                   | DDHAL_CB32_CANCREATESURFACE
                                                   | DDHAL_CB32_CREATESURFACE;

#ifndef WINNT // not needed under WINNT
    pDriverData->DDCallbacks.DestroyDriver         = (LPDDHAL_DESTROYDRIVER)DestroyDriver32;

    pDriverData->DDCallbacks.dwFlags               |= DDHAL_CB32_DESTROYDRIVER;
#endif  // !WINNT


    // fill out the palette callbacks
    memset(&pDriverData->DDPaletteCallbacks, 0, sizeof(DDHAL_DDPALETTECALLBACKS));
    pDriverData->DDPaletteCallbacks.dwSize  = sizeof(DDHAL_DDPALETTECALLBACKS);
    pDriverData->DDPaletteCallbacks.dwFlags = 0;

    // set up pointer to DDHALINFO
    LPDDHALINFO pHalInfo = GET_HALINFO();

    // fill out the HALINFO
#ifndef WINNT   // These don't exist under NT, HAL callbacks returned via DrvGetDirectDrawInfo
    memset(pHalInfo, 0, sizeof(DDHALINFO));
#endif

    pHalInfo->dwSize = sizeof(DDHALINFO);
    pHalInfo->ddCaps.dwSize = sizeof(DDCORECAPS);

#ifndef WINNT
    // callback functions
    pHalInfo->lpDDCallbacks        = &pDriverData->DDCallbacks;
    pHalInfo->lpDDSurfaceCallbacks = &pDriverData->DDSurfaceCallbacks;
    pHalInfo->lpDDPaletteCallbacks = &pDriverData->DDPaletteCallbacks;
    pHalInfo->lpDDExeBufCallbacks  = &pDriverData->DDExecuteBufferCallbacks;

    // although MS calls this an instance handle, they actually just want a unique per head/card identifier
    pHalInfo->hInstance = (DWORD)pDXShare;

    // set the physical device ptr
    DIBENGINEHDR1 *pDibeng = (DIBENGINEHDR1 *)pDXShare->pFlatDibeng;
    pHalInfo->lpPDevice = (void*)pDibeng->delpPDevice;
#endif  // !WINNT

    // ROPS supported
    for ( i=0; i < DD_ROP_SPACE; i++ )
        pHalInfo->ddCaps.dwRops[i] = ropList[i];

    // fill out the surface callbacks
    memset(&pDriverData->DDSurfaceCallbacks, 0, sizeof(DDHAL_DDSURFACECALLBACKS));
    pDriverData->DDSurfaceCallbacks.dwSize             = sizeof(DDHAL_DDSURFACECALLBACKS);
    pDriverData->DDSurfaceCallbacks.DestroySurface     = DestroySurface32;
    pDriverData->DDSurfaceCallbacks.Blt                = Blit32;
    pDriverData->DDSurfaceCallbacks.Flip               = Flip32;
    pDriverData->DDSurfaceCallbacks.Lock               = Lock32;
    pDriverData->DDSurfaceCallbacks.Unlock             = Unlock32;
    pDriverData->DDSurfaceCallbacks.GetBltStatus       = GetBltStatus32;
    pDriverData->DDSurfaceCallbacks.GetFlipStatus      = GetFlipStatus32;
    pDriverData->DDSurfaceCallbacks.SetColorKey        = SetSurfaceColorKey32;
    if (NO_OVERLAY) {
        pDriverData->DDSurfaceCallbacks.UpdateOverlay      = NULL;
        pDriverData->DDSurfaceCallbacks.SetOverlayPosition = NULL;
        pDriverData->DDSurfaceCallbacks.dwFlags            = DDHAL_SURFCB32_BLT |
                                                             DDHAL_SURFCB32_FLIP |
                                                             DDHAL_SURFCB32_LOCK |
                                                             DDHAL_SURFCB32_UNLOCK |
                                                             DDHAL_SURFCB32_SETCOLORKEY |
                                                             DDHAL_SURFCB32_GETBLTSTATUS |
                                                             DDHAL_SURFCB32_GETFLIPSTATUS |
                                                             DDHAL_SURFCB32_DESTROYSURFACE;
    } else {
        pDriverData->DDSurfaceCallbacks.UpdateOverlay      = UpdateOverlay32;
        pDriverData->DDSurfaceCallbacks.SetOverlayPosition = SetOverlayPosition32;
        pDriverData->DDSurfaceCallbacks.dwFlags            = DDHAL_SURFCB32_BLT |
                                                             DDHAL_SURFCB32_FLIP |
                                                             DDHAL_SURFCB32_LOCK |
                                                             DDHAL_SURFCB32_UNLOCK |
                                                             DDHAL_SURFCB32_SETCOLORKEY |
                                                             DDHAL_SURFCB32_GETBLTSTATUS |
                                                             DDHAL_SURFCB32_GETFLIPSTATUS |
                                                             DDHAL_SURFCB32_UPDATEOVERLAY |
                                                             DDHAL_SURFCB32_SETOVERLAYPOSITION |
                                                             DDHAL_SURFCB32_DESTROYSURFACE;
    }

#ifndef DO_NOT_SUPPORT_VERTEX_BUFFERS // see nvprecomp.h
    if (
#if (NVARCH >= 0x020)
        (pDriverData->nvD3DPerfData.dwNVClasses & NVCLASS_FAMILY_KELVIN) ||
#endif // (NVARCH >= 0x020)
        (pDriverData->nvD3DPerfData.dwNVClasses & NVCLASS_FAMILY_CELSIUS)
       )
    {
        /*
         * populate execute buffer callbacks, so that we can allocate vertex buffers
         */
        pDriverData->DDExecuteBufferCallbacks.dwSize                 = sizeof(pDriverData->DDExecuteBufferCallbacks);
#ifdef WINNT
        pDriverData->DDExecuteBufferCallbacks.CanCreateD3DBuffer     = D3DCanCreateExecuteBuffer32;
        pDriverData->DDExecuteBufferCallbacks.CreateD3DBuffer        = D3DCreateExecuteBuffer32;
        pDriverData->DDExecuteBufferCallbacks.DestroyD3DBuffer       = D3DDestroyExecuteBuffer32;
        pDriverData->DDExecuteBufferCallbacks.LockD3DBuffer          = D3DLockExecuteBuffer32;
        pDriverData->DDExecuteBufferCallbacks.UnlockD3DBuffer        = D3DUnlockExecuteBuffer32;
        pDriverData->DDExecuteBufferCallbacks.dwFlags                = 0x1F; //hardcoded flags aren't defined
#else
        pDriverData->DDExecuteBufferCallbacks.CanCreateExecuteBuffer = D3DCanCreateExecuteBuffer32;
        pDriverData->DDExecuteBufferCallbacks.CreateExecuteBuffer    = D3DCreateExecuteBuffer32;
        pDriverData->DDExecuteBufferCallbacks.DestroyExecuteBuffer   = D3DDestroyExecuteBuffer32;
        pDriverData->DDExecuteBufferCallbacks.LockExecuteBuffer      = D3DLockExecuteBuffer32;
        pDriverData->DDExecuteBufferCallbacks.UnlockExecuteBuffer    = D3DUnlockExecuteBuffer32;
        pDriverData->DDExecuteBufferCallbacks.dwFlags                = DDHAL_EXEBUFCB32_CANCREATEEXEBUF
                                                                     | DDHAL_EXEBUFCB32_CREATEEXEBUF
                                                                     | DDHAL_EXEBUFCB32_DESTROYEXEBUF
                                                                     | DDHAL_EXEBUFCB32_LOCKEXEBUF
                                                                     | DDHAL_EXEBUFCB32_UNLOCKEXEBUF;
#endif
    }
    else
#endif //!DO_NOT_SUPPORT_VERTEX_BUFFERS
    {
        /*
         * we are not interested in any vertex buffer allocation
         */
        memset (&pDriverData->DDExecuteBufferCallbacks,0,sizeof(pDriverData->DDExecuteBufferCallbacks));
        pDriverData->DDExecuteBufferCallbacks.dwSize = sizeof(pDriverData->DDExecuteBufferCallbacks);
    }

    /*
     * capabilities supported
     */
    if (NO_OVERLAY) {
        pHalInfo->ddCaps.dwCaps = DDCAPS_ALIGNSTRIDE |
                                  DDCAPS_ALIGNBOUNDARYDEST |
                                  DDCAPS_BLT |
                                  DDCAPS_BLTFOURCC |
                                  DDCAPS_BLTSTRETCH |
                                  DDCAPS_BLTQUEUE |
                                  DDCAPS_BLTCOLORFILL |
                                  DDCAPS_CANBLTSYSMEM |
                                  DDCAPS_ALPHA |
                                  DDCAPS_COLORKEY |
                                  DDCAPS_READSCANLINE |
                                  DDCAPS_BLTDEPTHFILL |
                                  DDCAPS_3D;
    } else {
        pHalInfo->ddCaps.dwCaps = DDCAPS_ALIGNSTRIDE |
                                  DDCAPS_ALIGNBOUNDARYDEST |
                                  DDCAPS_BLT |
                                  DDCAPS_BLTFOURCC |
                                  DDCAPS_BLTSTRETCH |
                                  DDCAPS_BLTQUEUE |
                                  DDCAPS_BLTCOLORFILL |
                                  DDCAPS_CANBLTSYSMEM |
                                  DDCAPS_ALPHA |
                                  DDCAPS_COLORKEY |
                                  DDCAPS_OVERLAY |
                                  DDCAPS_OVERLAYCANTCLIP  |
                                  DDCAPS_OVERLAYFOURCC |
                                  DDCAPS_OVERLAYSTRETCH |
                                  DDCAPS_READSCANLINE |
                                  DDCAPS_BLTDEPTHFILL |
                                  DDCAPS_3D;
    }

#ifndef WINNT
    pHalInfo->ddCaps.dwCaps |= DDCAPS_GDI;
#endif

#ifndef WINNT
    if ((pDriverData->nvD3DPerfData.dwNVClasses & (NVCLASS_FAMILY_CELSIUS | NVCLASS_FAMILY_KELVIN)) &&
        (global.dwDXRuntimeVersion >= 0x0800) &&
#ifdef TEXFORMAT_CRD
        (getDC()->nvD3DRegistryData.regSurfaceFormatsDX8 & D3D_REG_SURFACEFORMATS_PALETTIZED))
#else   // !TEXFORMAT_CRD
        ((getDC()->nvD3DRegistryData.regD3DEnableBits1 & D3D_REG_PALETTEENABLE_MASK) == D3D_REG_PALETTEENABLE_ENABLE))
#endif  // !TEXFORMAT_CRD
    {
        pHalInfo->ddCaps.dwCaps |= DDCAPS_PALETTE;
    }
#endif

    pHalInfo->ddCaps.dwCaps2 |= DDCAPS2_NOPAGELOCKREQUIRED
//                             | DDCAPS2_CERTIFIED           // **** Turning this on breaks HAL enumeration ****
                             |  DDCAPS2_WIDESURFACES
                             |  DDCAPS2_PRIMARYGAMMA
                             |  DDCAPS2_CANRENDERWINDOWED
                             |  DDCAPS2_NONLOCALVIDMEMCAPS
                             |  DDCAPS2_COPYFOURCC;

    if (pDriverData->dwBusType == NV_BUS_TYPE_AGP) {
        // intially set DDCAPS2_NONLOCALVIDMEM here, it may be cleared later
        // in buildDDHalInfo16 on Win9x, or in DrvGetDirectDrawInfo on Win2K
        pHalInfo->ddCaps.dwCaps2 |= DDCAPS2_NONLOCALVIDMEM;
    }


    if (!NO_OVERLAY) {
        pHalInfo->ddCaps.dwCaps2 |= DDCAPS2_CANBOBHARDWARE
                                 |  DDCAPS2_CANBOBNONINTERLEAVED
                                 |  DDCAPS2_CANBOBINTERLEAVED
                                 |  DDCAPS2_CANBOBHARDWARE
                                 |  DDCAPS2_CANFLIPODDEVEN;
    }

#if defined(TEX_MANAGE)
    if ((getDC()->nvD3DRegistryData.regD3DEnableBits1 & D3D_REG_TEXTUREMANAGEMENTENABLE_MASK) == D3D_REG_TEXTUREMANAGEMENTENABLE_ENABLE) {
        pHalInfo->ddCaps.dwCaps2 |= DDCAPS2_CANMANAGETEXTURE;
    }
#endif

    // set flipnovsync flag only on hardware later than NV4
    if (pDriverData->nvD3DPerfData.dwNVClasses & (NVCLASS_0049_DAC |
                                                  NVCLASS_0067_DAC |
                                                  NVCLASS_007C_DAC)) {
        pHalInfo->ddCaps.dwCaps2 |= DDCAPS2_FLIPNOVSYNC;
    }


    if (NO_OVERLAY) {
        pHalInfo->ddCaps.dwCKeyCaps = DDCKEYCAPS_SRCBLT;

        pHalInfo->ddCaps.dwFXCaps = DDFXCAPS_BLTARITHSTRETCHY |
                                    DDFXCAPS_BLTMIRRORLEFTRIGHT |
                                    DDFXCAPS_BLTMIRRORUPDOWN |
                                    DDFXCAPS_BLTSHRINKX |
                                    DDFXCAPS_BLTSHRINKY |
                                    DDFXCAPS_BLTSTRETCHX |
                                    DDFXCAPS_BLTSTRETCHY |
                                    DDFXCAPS_BLTALPHA |
                                    DDFXCAPS_BLTFILTER;
    } else {
        if ((pDriverData->NvDeviceVersion >= NV_DEVICE_VERSION_10) || pDriverData->vpp.regOverlayColourControlEnable)
            pHalInfo->ddCaps.dwCaps2 |= DDCAPS2_COLORCONTROLOVERLAY;

        pHalInfo->ddCaps.dwCKeyCaps = DDCKEYCAPS_SRCBLT |
                                      DDCKEYCAPS_DESTOVERLAY |
                                      DDCKEYCAPS_DESTOVERLAYONEACTIVE;

        pHalInfo->ddCaps.dwFXCaps = DDFXCAPS_BLTARITHSTRETCHY |
                                    DDFXCAPS_BLTMIRRORLEFTRIGHT |
                                    DDFXCAPS_BLTMIRRORUPDOWN |
                                    DDFXCAPS_BLTSHRINKX |
                                    DDFXCAPS_BLTSHRINKY |
                                    DDFXCAPS_BLTSTRETCHX |
                                    DDFXCAPS_BLTSTRETCHY |
                                    DDFXCAPS_BLTALPHA |
                                    DDFXCAPS_BLTFILTER |
                                    DDFXCAPS_OVERLAYFILTER |
                                    DDFXCAPS_OVERLAYMIRRORUPDOWN |
                                    DDFXCAPS_OVERLAYSHRINKX |
                                    DDFXCAPS_OVERLAYSHRINKY |
                                    DDFXCAPS_OVERLAYSTRETCHX |
                                    DDFXCAPS_OVERLAYARITHSTRETCHY |
                                    DDFXCAPS_OVERLAYSTRETCHY;
    }

#ifndef WINNT // sigh this causes us to die HMH
    if ((pDriverData->nvD3DPerfData.dwNVClasses & (NVCLASS_FAMILY_CELSIUS | NVCLASS_FAMILY_KELVIN)) &&
        (global.dwDXRuntimeVersion >= 0x0800) &&
#ifdef TEXFORMAT_CRD
        (getDC()->nvD3DRegistryData.regSurfaceFormatsDX8 & D3D_REG_SURFACEFORMATS_PALETTIZED))
#else   // !TEXFORMAT_CRD
        ((getDC()->nvD3DRegistryData.regD3DEnableBits1 & D3D_REG_PALETTEENABLE_MASK) == D3D_REG_PALETTEENABLE_ENABLE))
#endif  // !TEXFORMAT_CRD
    {
        pHalInfo->ddCaps.dwPalCaps = DDPCAPS_8BIT; // | DDPCAPS_ALLOW256;
    }
#endif

    pHalInfo->ddCaps.dwFXAlphaCaps  = 0;

    if (NO_OVERLAY) {
        pHalInfo->ddCaps.ddsCaps.dwCaps = DDSCAPS_VIDEOMEMORY |
                                          DDSCAPS_PRIMARYSURFACE |
                                          DDSCAPS_HWCODEC |
                                          DDSCAPS_OFFSCREENPLAIN |
                                          DDSCAPS_VISIBLE |
                                          DDSCAPS_FLIP |
                                          DDSCAPS_FRONTBUFFER |
                                          DDSCAPS_BACKBUFFER |
                                          DDSCAPS_ZBUFFER |
                                          DDSCAPS_3DDEVICE |
                                          DDSCAPS_ALPHA |
                                          DDSCAPS_TEXTURE |
                                          DDSCAPS_MIPMAP |
                                          DDSCAPS_EXECUTEBUFFER;
    } else {
        pHalInfo->ddCaps.ddsCaps.dwCaps = DDSCAPS_VIDEOMEMORY |
                                          DDSCAPS_PRIMARYSURFACE |
                                          DDSCAPS_HWCODEC |
                                          DDSCAPS_OFFSCREENPLAIN |
                                          DDSCAPS_VISIBLE |
                                          DDSCAPS_FLIP |
                                          DDSCAPS_FRONTBUFFER |
                                          DDSCAPS_BACKBUFFER |
                                          DDSCAPS_OVERLAY |
                                          DDSCAPS_ZBUFFER |
                                          DDSCAPS_3DDEVICE |
                                          DDSCAPS_ALPHA |
                                          DDSCAPS_TEXTURE |
                                          DDSCAPS_MIPMAP |
                                          DDSCAPS_EXECUTEBUFFER;
    }

#ifndef WINNT
    pHalInfo->ddCaps.ddsCaps.dwCaps |= DDSCAPS_SYSTEMMEMORY;
#endif

#ifndef WINNT
    if ((pDriverData->nvD3DPerfData.dwNVClasses & (NVCLASS_FAMILY_CELSIUS | NVCLASS_FAMILY_KELVIN)) &&
        (global.dwDXRuntimeVersion >= 0x0800) &&
#ifdef TEXFORMAT_CRD
        (getDC()->nvD3DRegistryData.regSurfaceFormatsDX8 & D3D_REG_SURFACEFORMATS_PALETTIZED))
#else   // !TEXFORMAT_CRD
        ((getDC()->nvD3DRegistryData.regD3DEnableBits1 & D3D_REG_PALETTEENABLE_MASK) == D3D_REG_PALETTEENABLE_ENABLE))
#endif  // !TEXFORMAT_CRD
    {
        pHalInfo->ddCaps.ddsCaps.dwCaps |= DDSCAPS_PALETTE;
    }
#endif

#ifdef WINNT
    if (global.dwDXRuntimeVersion >= 0x800)
#else // !WINNT
    if (1)
#endif // !WINNT
    {
        for ( i=0; i < DD_ROP_SPACE; i++ )
            pHalInfo->ddCaps.dwSVBRops[i] = ropList[i];
        pHalInfo->ddCaps.dwSVBCaps = pHalInfo->ddCaps.dwCaps;
        pHalInfo->ddCaps.dwSVBCaps2 = pHalInfo->ddCaps.dwCaps2;
        pHalInfo->ddCaps.dwSVBCKeyCaps = pHalInfo->ddCaps.dwCKeyCaps;
        pHalInfo->ddCaps.dwSVBFXCaps = pHalInfo->ddCaps.dwFXCaps;

        pHalInfo->ddCaps.dwVSBCaps = DDCAPS_BLT |
            DDCAPS_BLTQUEUE;
        pHalInfo->ddCaps.dwVSBCKeyCaps = 0;
        pHalInfo->ddCaps.dwVSBFXCaps = 0;
        for ( i=0; i < DD_ROP_SPACE; i++ ) {
            pHalInfo->ddCaps.dwVSBRops[i] = 0;
        }
        pHalInfo->ddCaps.dwVSBRops[6] = SRCCOPYBIT;
    }
    else
    {
        // turn off system->video blits on Win2K DX7 runtime due to MS bug (TestDrive 6)
        for ( i=0; i < DD_ROP_SPACE; i++ )
            pHalInfo->ddCaps.dwSVBRops[i] = 0;

        pHalInfo->ddCaps.dwSVBCaps = 0;
        pHalInfo->ddCaps.dwSVBCaps2 = 0;
        pHalInfo->ddCaps.dwSVBCKeyCaps = 0;
        pHalInfo->ddCaps.dwSVBFXCaps = 0;
        pHalInfo->ddCaps.dwVSBCaps = 0;
        pHalInfo->ddCaps.dwVSBCKeyCaps = 0;
        pHalInfo->ddCaps.dwVSBFXCaps = 0;

        for ( i=0; i < DD_ROP_SPACE; i++ )
            pHalInfo->ddCaps.dwVSBRops[i] = 0;
    }

    /*
     * Z buffer bit depths supported
     */
    pHalInfo->ddCaps.dwZBufferBitDepths = DDBD_16 | DDBD_24;

    /*
     * NV3 Required alignments
     */
    pHalInfo->ddCaps.dwAlignBoundaryDest = 1;
    /* All video memory surfaces must be aligned with aligned strides */
    pHalInfo->ddCaps.dwAlignStrideAlign = pDriverData->dwSurfaceAlign;

    /*
     * NV3 stretching capabilities
     */
    pHalInfo->ddCaps.dwMinOverlayStretch = 1;
    pHalInfo->ddCaps.dwMaxOverlayStretch = 20000;

    pHalInfo->ddCaps.dwMinLiveVideoStretch = 1;
    pHalInfo->ddCaps.dwMaxLiveVideoStretch = 20000;

    pHalInfo->ddCaps.dwMinHwCodecStretch = 1;
    pHalInfo->ddCaps.dwMaxHwCodecStretch = 4095000;

    /*
     *  FOURCCs supported
     *
     *  Table address MUST be set in 16 bit portion of Direct Draw Driver but
     *  can add more FOURCC codes to table here if needed.
     */

    if (pDriverData->NvDeviceVersion >= NV_DEVICE_VERSION_10) {
        pHalInfo->ddCaps.dwNumFourCCCodes = NV_MAX_FOURCC;
    }
    else {
        pHalInfo->ddCaps.dwNumFourCCCodes = NV_MAX_FOURCC_REGULAR;
    }

    /*
     *  Maximum number of overlays supported
     */

    if (NO_OVERLAY) {
        pHalInfo->ddCaps.dwMaxVisibleOverlays = 0;
    } else {
        pHalInfo->ddCaps.dwMaxVisibleOverlays = 1;
    }

    /*
     * current video mode, the 16bit driver will fill this out for real.
     */
#ifndef WINNT   // Under WINNT, mode sets are handled by display driver
    pHalInfo->dwModeIndex = DDUNSUPPORTEDMODE;
#endif

    /*
     * required byte alignments of the scan lines for each kind of memory
     * (default is 4, NV3 needs 16, NV4 needs 32, NV10 wants 64
     */
    pHalInfo->vmiData.dwOffscreenAlign = pDriverData->dwSurfaceAlign;
    pHalInfo->vmiData.dwOverlayAlign   = NV_OVERLAY_BYTE_ALIGNMENT;
    pHalInfo->vmiData.dwTextureAlign   = pDriverData->dwSurfaceAlign; // Texture surface, not our optimized texture
    pHalInfo->vmiData.dwAlphaAlign     = pDriverData->dwSurfaceAlign;
    pHalInfo->vmiData.dwZBufferAlign   = pDriverData->dwSurfaceAlign;

#ifdef NVD3D
    pDriverData->bDirtyRenderTarget = TRUE;
    pDriverData->ThreeDRenderingOccurred = FALSE;

    // If 24-bit z-buffers are disabled, only show 16-bit formats.
    if ((getDC()->nvD3DRegistryData.regD3DEnableBits1 & D3D_REG_Z24ENABLE_MASK) == D3D_REG_Z24ENABLE_DISABLE) {
        pHalInfo->ddCaps.dwZBufferBitDepths = DDBD_16;
    }
#endif // NVD3D

#ifdef NVPE
    pDriverData->bEnableVPE = 0;
    if (NVPIsVPEEnabled(pDriverData, 0)) {
        pDriverData->bEnableVPE = 1;
    }
#else
    // Grab the local registry path and append the DirectDraw subkey to the string
    // without using the C runtime library.
#ifndef WINNT
    MyExtEscape(NV_ESC_GET_LOCAL_REGISTRY_PATH, 0, NULL, 256, regStr);
#endif // BUGBUG WINNT

    nvStrCat(&(regStr[4]), "\\" NV4_REG_DIRECT_DRAW_SUBKEY);

    //VPE enable stuff
    pDriverData->bEnableVPE = 1;

    if (RegOpenKeyEx((HKEY)(*((LPDWORD)&regStr[0])), &regStr[4], 0, KEY_QUERY_VALUE, &hKey) != ERROR_SUCCESS) {
        hKey = 0;
    }
    if (hKey) {
        DWORD   dwSize = sizeof(long);
        DWORD   dwType = REG_DWORD;
        long    lValue;

        //check for VPE enable bit
        if (RegQueryValueEx(hKey, NV4_REG_VPE_ENABLE, NULL, &dwType, (LPBYTE)&lValue, &dwSize) == ERROR_SUCCESS) {
            if(!lValue)
                pDriverData->bEnableVPE = 0;
        }
        RegCloseKey(hKey);
    }
#endif // NVPE

    //VPE enable stuff
    if(pDriverData->bEnableVPE == 1 && !NO_OVERLAY) {
      /*
       * Video Port Capabilities
       */
      pHalInfo->ddCaps.dwCaps2 |= DDCAPS2_VIDEOPORT               |
                                             DDCAPS2_CANBOBINTERLEAVED       |
                                             DDCAPS2_CANBOBNONINTERLEAVED    |
                                             DDCAPS2_AUTOFLIPOVERLAY;

      pHalInfo->ddCaps.dwMaxVideoPorts = 1;
      pHalInfo->ddCaps.dwCurrVideoPorts = 0;

    }
    pHalInfo->GetDriverInfo = GetDriverInfo32;
    pHalInfo->dwFlags |= DDHALINFO_GETDRIVERINFOSET;
    if (
#if (NVARCH >= 0x020)
    (pDriverData->nvD3DPerfData.dwNVClasses & NVCLASS_FAMILY_KELVIN) ||
#endif // (NVARCH >= 0x020)
    (pDriverData->nvD3DPerfData.dwNVClasses & NVCLASS_FAMILY_CELSIUS)
     )
    {
    pHalInfo->dwFlags |= DDHALINFO_GETDRIVERINFO2;
    }
#ifndef WINNT
    pHalInfo->dwFlags |= DDHALINFO_MODEXILLEGAL;
#endif
#ifdef  STEREO_SUPPORT
    StereoModifyDDHALInfo();
#endif  //STEREO_SUPPORT

    DPF_LEVEL (NVDBG_LEVEL_INFO, "Display: Filling in ddHALInfo.GetDriverInfo: %x", GetDriverInfo32);

    dbgTracePop();
    return (TRUE);

}  // buildDDHALInfo32

//---------------------------------------------------------------------------

/*
    GetFlatCodeSel
*/
DWORD __stdcall GetFlatCodeSel (void)
{
    unsigned long dwSel;

    dbgTracePush ("GetFlatCodeSel");

    _asm
    {
        mov     ax,cs
        movzx   eax,ax
        mov     dwSel,eax
    }

    dbgTracePop();
    return (dwSel);
}

//---------------------------------------------------------------------------

/*
    GetFlatDataSel
*/
DWORD __stdcall GetFlatDataSel (void)
{
    unsigned long dwSel;

    dbgTracePush ("GetFlatDataSel");

    _asm
    {
        mov     ax,ds
        movzx   eax,ax
        mov     dwSel,eax
    }

    dbgTracePop();
    return (dwSel);
}

//---------------------------------------------------------------------------

#ifndef WINNT   // This is Win9x specific
/*
    buildDDHALInfo16 ()

    This procedure used to be in the display driver. It was there because
    the code in this routine needs to execute just after a modeset and
    before we call the DirectX internal funciton lpSetInfo and there is
    no mechanism for getting over to the DirectX driver and back to the
    display driver in a serialized fashion.  i.e. If we do a thunk to get
    over to the 32bit DirectX driver, then the Win16 mutex gets released
    and the sequence is not serialized properly.

    However, this code is properly DirectX code so it belongs in this
    driver, not over in the display driver. The bold way to execute this
    code in sequence with the code in the display driver is to CALL it
    directly without doing a thunk or releaseing the mutex!!! This imposes
    a few serious restrictions on what can occur in this routine.

    This routine can only have straight C code in it -- DO NOT call out
    to any system functions because you are not really running in flat
    land. When this routine is executing it is running as a part of the
    16 bit display driver!!  This should not be too much of a problem,
    though, because there is no necessity for doing more than setting
    capability bits and structure fields herein.

    If you call out to a system function (like memory allocation or
    any Kernel, USER32, GDI32, etc function, you will LOCK the system!!
*/

DWORD __stdcall buildDDHALInfo16 (void)
{
    LPDDHALMODEINFO     lpMode;

    // set this flag so that all functions called herein
    // know not to make any system calls
    global.b16BitCode = TRUE;

    DIBENGINEHDR1 *pDibeng = (DIBENGINEHDR1 *)pDXShare->pFlatDibeng;

    // set up pointer to DDHALINFO
    LPDDHALINFO pHalInfo = (LPDDHALINFO)pDXShare->pHalInfo;

    // Grab the mode list and add each mode.  This is largely just to fix
    // a bug in Motocross Madness where the mode list is gotten before
    // the 32bit DirectX driver initializes and builds a mode table. The
    // mode table returned here is a shotgun-return-all-the-modes in the
    // registry approach. Except for motocross madness (as far as we know),
    // all other DX apps won't grab the modes until after DriverInit
    // is called. DriverInit calls BuildDDHalModeTable which computes
    // the real mode list (should be very close to what we return here.)
#if 0
    LPMODEENTRYANDPITCH lpM = (LPMODEENTRYANDPITCH) pDXShare->lpMasterModeList;
    LPDDHALMODEINFO pMode = pDriverData->ModeList;
    for (i = 0; lpM[i].dwXRes != 0; i++) {
        AddModeToTable (pMode++, lpM[i].dwXRes, lpM[i].dwYRes, lpM[i].dwBpp); //, lpM[i].dwPitch);
    }

    SortDDHalModeList ();
#endif

    if (pDriverData->NvDeviceVersion < NV_DEVICE_VERSION_10) { // Starting with NV10, we never close this channel
        if (pDriverData->NvDevVideoFlatPio != 0) {
            pDriverData->CloseNvDevVideoFlatPio = pDriverData->NvDevVideoFlatPio;
            pDriverData->NvDevVideoFlatPio = 0;
        }
    }

    DWORD dwRootIndex = 0;
    getAdapterIndex(pDXShare, &dwRootIndex);
    if ((dwRootIndex           == -1)                // if we are head 0
     || (pDXShare->deWidth     != GET_MODE_WIDTH())  // or if the mode has really changed
     || (pDXShare->deHeight    != GET_MODE_HEIGHT())
     || (pDXShare->deBitsPixel != GET_MODE_BPP()))
    {
        nvDisable32();
        pDXShare->deWidth     = GET_MODE_WIDTH();
        pDXShare->deHeight    = GET_MODE_HEIGHT();
        pDXShare->deBitsPixel = GET_MODE_BPP();
    }

    // Set a ptr to the table
    pHalInfo->lpModeInfo = (struct _DDHALMODEINFO *) (pDriverData->dwModeListSelector << 16);

    // Find the mode number
    pDXShare->dwModeNumber = -1;

    for (int i = 0; pDriverData->ModeList[i].dwWidth != 0; i++)
    {
        if ((pDriverData->ModeList[i].dwWidth  == pDibeng->deWidth)     &&
            (pDriverData->ModeList[i].dwHeight == pDibeng->deHeight)    &&
            (pDriverData->ModeList[i].dwBPP    == pDibeng->deBitsPixel) &&
            ((pDriverData->ModeList[i].lPitch * pDriverData->ModeList[i].dwHeight) <= pDriverData->TotalVRAM))
        {
#ifdef  STEREO_SUPPORT_
            if (STEREO_ENABLED)
            {
                __asm int 3
                DWORD dwWidth = pDriverData->ModeList[i].dwWidth;
                int RealIndex = i;
                for (i=i+1; pDriverData->ModeList[i].dwWidth == dwWidth; i++)
                {
                    if (pDriverData->ModeList[i].wRefreshRate == 0x1234)
                    {
                        //Our fake entry
                        pDriverData->ModeList[i] = pDriverData->ModeList[RealIndex];
                        break;
                    }
                }
            }
#endif  //STEREO_SUPPORT

            pDXShare->dwModeNumber = i;
            break;
        }
    }

    // Overlay information
    pHalInfo->ddCaps.dwMaxVisibleOverlays = 1;
    pHalInfo->ddCaps.dwCurrVisibleOverlays = 0;

    // FOURCC code information
    if (pDriverData->NvDeviceVersion >= NV_DEVICE_VERSION_10) {
        pHalInfo->ddCaps.dwNumFourCCCodes = NV_MAX_FOURCC;
    }
    else {
        pHalInfo->ddCaps.dwNumFourCCCodes = NV_MAX_FOURCC_REGULAR;
    }

    // lpdwFourCC must be a 16:16 pointer. It is set at FirstTimeInit
    pHalInfo->lpdwFourCC = (unsigned long *) (pDriverData->dwFourCCSelector << 16);

    // current video mode
    pHalInfo->dwModeIndex = pDXShare->dwModeNumber;
    lpMode = &(pDriverData->ModeList[pHalInfo->dwModeIndex]);

    // current primary surface attributes
    pHalInfo->vmiData.fpPrimary = VIDMEM_ADDR(GET_PRIMARY_ADDR());

    // fill in the pixel format
    pHalInfo->vmiData.ddpfDisplay.dwSize  = sizeof (DDPIXELFORMAT);
    pHalInfo->vmiData.ddpfDisplay.dwFlags = DDPF_RGB;

    if  (pDXShare->dwModeNumber != -1)
    {
        pHalInfo->vmiData.ddpfDisplay.dwRGBBitCount     = lpMode->dwBPP;
        pHalInfo->vmiData.dwDisplayWidth                = lpMode->dwWidth;
        pHalInfo->vmiData.dwDisplayHeight               = lpMode->dwHeight;
        pHalInfo->vmiData.lDisplayPitch                 = lpMode->lPitch;
        pHalInfo->vmiData.ddpfDisplay.dwRGBAlphaBitMask = lpMode->dwAlphaBitMask;
        pHalInfo->vmiData.ddpfDisplay.dwRBitMask        = lpMode->dwRBitMask;
        pHalInfo->vmiData.ddpfDisplay.dwGBitMask        = lpMode->dwGBitMask;
        pHalInfo->vmiData.ddpfDisplay.dwBBitMask        = lpMode->dwBBitMask;

        if (lpMode->wFlags & DDMODEINFO_PALETTIZED) {
            pHalInfo->vmiData.ddpfDisplay.dwFlags |= DDPF_PALETTEINDEXED8;
        }
#ifdef SPOOF_ALPHA
        if (lpMode->dwAlphaBitMask) {
            pHalInfo->vmiData.ddpfDisplay.dwFlags |= DDPF_ALPHAPIXELS;
        }
#endif
    }

#ifdef NV_AGP
    // we are managing the heaps, don't ask MS for one
    pHalInfo->vmiData.dwNumHeaps = 0;
    if (pDriverData->dwBusType == NV_BUS_TYPE_AGP) {
        pHalInfo->ddCaps.dwCaps2 |=  DDCAPS2_NONLOCALVIDMEM;
    } else {
        pHalInfo->ddCaps.dwCaps2 &= ~DDCAPS2_NONLOCALVIDMEM;
    }
#else // !NV_AGP
    // Setup the AGP heap
    DWORD dwRoot;
    getAdapterIndex(pDXShare, &dwRoot);
    if ((pDriverData->dwBusType == NV_BUS_TYPE_AGP) &&
        (pDXShare->dwModeNumber != -1) &&
        (dwRoot == -1)) // this is the second or later device on a multi-head card (no AGP heap)
    {
        pHalInfo->vmiData.dwNumHeaps = 1;
        pHalInfo->ddCaps.dwCaps2 |= DDCAPS2_NONLOCALVIDMEM;
    }
    else
    {
        pHalInfo->vmiData.dwNumHeaps = 0;
        pHalInfo->ddCaps.dwCaps2 &= ~DDCAPS2_NONLOCALVIDMEM;
    }
#endif // !NV_AGP

    // pvmList must be a 16:16 pointer. It is set at FirstTimeInit.
    pHalInfo->vmiData.pvmList = (struct _VIDMEM *) (pDriverData->dwPvmListSelector << 16);

    if (pHalInfo->vmiData.dwNumHeaps == 1)
    {
        // Describe NONLOCALVIDMEM heap
        pDriverData->vidMem[0].dwFlags = VIDMEM_ISLINEAR   |
                                         VIDMEM_ISNONLOCAL |  // AGP memory
                                         VIDMEM_ISWC;         // do write combining

        // don't place in nonlocal video memory on first pass
        // prefer not to allocate anything but
        // optimized textures and YV12 overlays
        pDriverData->vidMem[0].ddsCaps.dwCaps = DDSCAPS_OVERLAY        |
                                                DDSCAPS_OFFSCREENPLAIN |
                                                DDSCAPS_FRONTBUFFER    |
                                                DDSCAPS_BACKBUFFER     |
                                                DDSCAPS_ZBUFFER;

        // don't place in nonlocal video memory on 2nd pass
        // Even if no other memory, don't allocate anything but
        // optimized textures and YV12 overlays
        pDriverData->vidMem[0].ddsCapsAlt.dwCaps = DDSCAPS_OVERLAY        |
                                                   DDSCAPS_OFFSCREENPLAIN |
                                                   DDSCAPS_FRONTBUFFER    |
                                                   DDSCAPS_BACKBUFFER     |
                                                   DDSCAPS_ZBUFFER;

        pDriverData->vidMem[0].fpStart = 0x00000000;
        if (pDriverData->regSuper7Compat == 2) {
            // Allocate 32-sizeof(pushbuffer)-sizeof(defaultVB) megabytes of address space
            pDriverData->vidMem[0].fpEnd = pDriverData->regMaxAGPLimit - getDC()->nvPusher.getSize();
        } else {
            pDriverData->vidMem[0].fpEnd = pDriverData->regMaxAGPLimit - pDriverData->regPersistAGPSize;
        }
    }

    // The color alphas
    switch (pDibeng->deBitsPixel) {
        case 8 : pDriverData->physicalColorMask = 0xFF;     break;
        case 16: pDriverData->physicalColorMask = 0xFFFF;   break;
        case 32: pDriverData->physicalColorMask = 0xFFFFFF; break;
        default: break;
    }

    // callback functions
    pHalInfo->lpDDCallbacks        = (DDHAL_DDCALLBACKS *)        (pDriverData->dwDDCallbacksSelector << 16);
    pHalInfo->lpDDSurfaceCallbacks = (DDHAL_DDSURFACECALLBACKS *) (pDriverData->dwDDSurfaceCallbacksSelector << 16);
    pHalInfo->lpDDPaletteCallbacks = (DDHAL_DDPALETTECALLBACKS *) (pDriverData->dwDDPaletteCallbacksSelector << 16);
    pHalInfo->lpDDExeBufCallbacks  = (DDHAL_DDEXEBUFCALLBACKS *)  (pDriverData->dwDDExecuteBufferCallbackSelector << 16);

    ///////////////////////////////////////////////////////////////////
    // The 16bit side (the caller) needs 4 pieces of info back:
    // 1) A flat ptr to the HALInfo structure - assigned in FirstTimeInit
    // 2) The length of the HALInfo structure
    // 3) The HINSTANCE of this driver (MS calls this an instance handle but all they want is a unique per head/card identifier)

    pDXShare->dwHALInfoSize    = (unsigned long) sizeof(DDHALINFO);
    pDXShare->hDirectXInstance = (unsigned long) pDXShare;
    ///////////////////////////////////////////////////////////////////

#ifdef  STEREO_SUPPORT
    StereoModeSetProcessing();
#endif  //STEREO_SUPPORT

    // clear the 16-bit flag
    global.b16BitCode = FALSE;

    return (TRUE);
}

#endif // !WINNT

//---------------------------------------------------------------------------

// allocate space for major driver structures
// returns TRUE on success, FALSE on failure
#ifndef WINNT
BOOL nvAllocDriverStructures (void)
{
    dbgTracePush ("nvAllocDriverStructures");

    // allocate memory for global (one per card) data structures
    // this memory is only released when the driver dll is unloaded

    // alloc pDriverData
    pDriverData = new CDriverContext;

    if (!pDriverData) {
        // out of memory
        DPF ("nvAllocDriverStructures: out of memory allocating CDriverContext");
        dbgTracePop();
        return (FALSE);
    }

    // initialise pDriverData
    getDC()->create();

    // alloc ModeList
    void *pModeList = AllocIPM(sizeof(DDHALMODEINFO) * MAX_MODEENTRYS);
    if (!pModeList)
    {
        // out of memory - prepare to die
        DPF ("nvAllocDriverStructures: out of memory allocating DDHALMODEINFO");
        // free pDriverData
        delete pDriverData;
        pDriverData = NULL;
        // free pModeList
        FreeIPM(pModeList);
        dbgTracePop();
        return (FALSE);
    }

    // store the pointers to our newly allocated memory
    pDXShare->pDirectXData = (DWORD)pDriverData;
    pDriverData->ModeList  = (DDHALMODEINFO*)pModeList;

    dbgTracePop();
    return (TRUE);
}
#endif // !WINNT
//---------------------------------------------------------------------------

// FirstTimeInit()
// perform one-time initialization required on first call to DriverInit()

DWORD __stdcall FirstTimeInit (void)
{
    dbgTracePush ("FirstTimeInit");

    // Initialize DX state based on info obtained from the display driver
#ifdef WINNT
    pDriverData->BaseAddress       = 0;   // offset of frame buffer
    pDriverData->dwDeviceIDNum     = ppdev->ulDeviceReference;
    pDriverData->dwRootHandle      = ppdev->hClient;
    pDriverData->dwDeviceHandle    = ppdev->hDevice;
    pDriverData->NvDeviceVersion   = (unsigned short) ppdev->dwDeviceVersion;
    pDriverData->dwSurfaceAlignPad = ppdev->ulSurfaceAlign;
    pDriverData->dwSurfaceAlign    = ppdev->ulSurfaceAlign + 1;
    pDriverData->dwSurfaceBitAlign = ppdev->ulSurfaceBitAlign;
    pDriverData->NvBaseFlat   = (DWORD) ppdev->NvBaseAddr;
    pDriverData->thisDeviceID = pDriverData->dwDeviceHandle;
#else // !WINNT
    pDriverData->BaseAddress       = pDXShare->dwScreenLinearBase;  // linear base address of frame buffer
    pDriverData->dwDeviceIDNum     = pDXShare->dwNVDeviceID;
    pDriverData->dwRootHandle      = pDXShare->dwRootHandle;
    pDriverData->dwDeviceHandle    = pDXShare->dwDeviceHandle;
    pDriverData->NvDeviceVersion   = (unsigned short) pDXShare->dwDeviceVersion;
    pDriverData->dwSurfaceAlignPad = NV_BYTE_ALIGNMENT_PAD;
    pDriverData->dwSurfaceAlign    = NV_BYTE_ALIGNMENT;
    pDriverData->dwSurfaceBitAlign = NV_BIT_ALIGNMENT;
    pDriverData->NvBaseFlat        = pDXShare->dwDeviceLinearBase;
    pDriverData->flatSelector      = (unsigned short) GetFlatCodeSel();
    pDriverData->thisDeviceID      = pDXShare->dwNVDeviceID;
    // Setup an initial default of 32MB - under Win2k we've already computed the limit
    pDriverData->regMaxAGPLimit = NV_MAX_AGP_MEMORY_LIMIT;

    DWORD dwRoot;
    if (getAdapterIndex (pDXShare, &dwRoot) == 0) {
        SetSharedFSDOSBoxPtr ((U032 *)(&(pDriverData->dwFullScreenDOSStatus)));
    }
#endif // !WINNT

    NvRmConfigGet (pDriverData->dwRootHandle, pDriverData->dwDeviceHandle, NV_CFG_RAM_SIZE_MB, &(pDriverData->TotalVRAM));
    pDriverData->TotalVRAM       <<= 20;
    pDriverData->dwDeviceClass     = pDriverData->dwDeviceIDNum + (NV01_DEVICE_0 - 1);

#if (NVARCH < 0x010)
    if (pDriverData->NvDeviceVersion > NV_DEVICE_VERSION_5) {
        pDriverData->NvDeviceVersion = NV_DEVICE_VERSION_5;
    }
#endif // !NV10

    pDriverData->dwVersion = DDMINI_VERSION;

    NvRmConfigGet (pDriverData->dwRootHandle, pDriverData->dwDeviceHandle, NV_CFG_BUS_TYPE, &(pDriverData->dwBusType));

#ifdef WINNT
    {
        // Ask miniport if AGP should be enabled.
        DWORD ulReturn = 0;

        if (EngDeviceIoControl(ppdev->hDriver,
                               IOCTL_VIDEO_SHOULD_AGP_BE_ENABLED,
                               NULL, 0, NULL, 0, &ulReturn))
        {
            pDriverData->dwBusType = 1; // Force it to be PCI if miniport thinks otherwise.
        }
    }
#endif

    pDriverData->pCurrentChannelID = 0;

    // get the number of heads (DACs) on this device
    NvRmConfigGet (pDriverData->dwRootHandle, pDriverData->dwDeviceHandle, NV_CFG_NUMBER_OF_HEADS, &pDriverData->dwHeads);

    if (pDriverData->thisDeviceID <= 1) {
        pDriverData->thisDeviceID = 0;
    }

    pDriverData->dwDrvRefCount = 0;

#ifndef TEXFORMAT_CRD
    DWORD dwNum = 0;

    // A few other random things that never change
    pDriverData->fourCC[dwNum++] = FOURCC_UYVY;
    pDriverData->fourCC[dwNum++] = FOURCC_UYNV;
    pDriverData->fourCC[dwNum++] = FOURCC_YUY2;
    pDriverData->fourCC[dwNum++] = FOURCC_YUNV;
    if (pDriverData->NvDeviceVersion >= NV_DEVICE_VERSION_10)
    pDriverData->fourCC[dwNum++] = FOURCC_NVDS;
    pDriverData->fourCC[dwNum++] = FOURCC_YV12;
    pDriverData->fourCC[dwNum++] = FOURCC_YVU9;
    pDriverData->fourCC[dwNum++] = FOURCC_IF09;
    pDriverData->fourCC[dwNum++] = FOURCC_IV32;
    pDriverData->fourCC[dwNum++] = FOURCC_IV31;
    pDriverData->fourCC[dwNum++] = FOURCC_RAW8;
    pDriverData->fourCC[dwNum++] = FOURCC_NVT0;
    pDriverData->fourCC[dwNum++] = FOURCC_NVT1;
    pDriverData->fourCC[dwNum++] = FOURCC_NVT2;
    pDriverData->fourCC[dwNum++] = FOURCC_NVT3;
    pDriverData->fourCC[dwNum++] = FOURCC_NVT4;
    pDriverData->fourCC[dwNum++] = FOURCC_NVT5;
    pDriverData->fourCC[dwNum++] = FOURCC_NVS0;
    pDriverData->fourCC[dwNum++] = FOURCC_NVS1;
    pDriverData->fourCC[dwNum++] = FOURCC_NVS2;
    pDriverData->fourCC[dwNum++] = FOURCC_NVS3;
    pDriverData->fourCC[dwNum++] = FOURCC_NVS4;
    pDriverData->fourCC[dwNum++] = FOURCC_NVS5;

#ifdef DXT_SUPPORT
    if (pDriverData->NvDeviceVersion >= NV_DEVICE_VERSION_10) {
        pDriverData->fourCC[dwNum++] = FOURCC_DXT1;
        pDriverData->fourCC[dwNum++] = FOURCC_DXT2;
        pDriverData->fourCC[dwNum++] = FOURCC_DXT3;
        pDriverData->fourCC[dwNum++] = FOURCC_DXT4;
        pDriverData->fourCC[dwNum++] = FOURCC_DXT5;
    }
#endif
#if defined(HILO_SUPPORT_DX7) || defined(HILO_SUPPORT_DX8)
    if (pDriverData->nvD3DPerfData.dwNVClasses & NVCLASS_FAMILY_KELVIN) {
        pDriverData->fourCC[dwNum++] = FOURCC_NVHS;
        pDriverData->fourCC[dwNum++] = FOURCC_NVHU;
    }
#endif

#endif // !TEXFORMAT_CRD

    dbgTracePop();
    return  (TRUE);
}

//---------------------------------------------------------------------------
// ResetTwinViewState
//      Reset anything that has been destroyed by a change to the TwinView state
//

BOOL ResetTwinViewState (GLOBALDATA *pDriverData)
{
    dbgTracePush ("ResetTwinViewState");

    pDriverData->dwFullScreenDOSStatus &= ~FSDOSSTATUS_TWINVIEW_STATE_CHANGE;

#ifdef WINNT
    pDriverData->dwDesktopState = ppdev->TwinView_State;
#else

    // refresh the adapter table
    nvFillAdapterTable();

    // reinstantiate desktop state and reconnect DX in case TwinView state has changed
    NVTWINVIEWDATA twinViewData;
    DWORD dwOldDesktopState = pDriverData->dwDesktopState;
    memset(&twinViewData, 0, sizeof(twinViewData));
    twinViewData.dwFlag   = NVTWINVIEW_FLAG_GET;
    twinViewData.dwAction = NVTWINVIEW_ACTION_SETGET_STATE;
    MyExtEscape(pDXShare->dwHeadNumber, NV_ESC_SETGET_TWINVIEW_DATA, 0, NULL, sizeof(twinViewData), (char*)&twinViewData);
    nvAssert(twinViewData.dwSuccess);
    pDriverData->dwDesktopState = twinViewData.dwState;

    // reenable primary flip objects
    for (DWORD dwHead = 0; dwHead < pDriverData->dwHeads; dwHead ++) {
        NvRmFree (pDriverData->dwRootHandle, NV_DD_DEV_DMA, NV_DD_VIDEO_LUT_CURSOR_DAC + dwHead);
    }

    if (!nvCreateDACObjects (NV_DD_DEV_DMA, NV_DD_VIDEO_LUT_CURSOR_DAC)) {
        dbgTracePop();
        return (FALSE);
    }

    for (dwHead = 0; dwHead < pDriverData->dwHeads; dwHead ++) {
        // initialize LUT-cursor-DAC object
        nvPushData (0,dDrawSubchannelOffset(NV_DD_SPARE) | 0x40000);
        nvPushData (1,NV_DD_VIDEO_LUT_CURSOR_DAC + dwHead);
        nvPushData (2,dDrawSubchannelOffset(NV_DD_SPARE) + NV067_SET_CONTEXT_DMA_NOTIFIES | 0x1C0000);
        nvPushData (3,NV_DD_DMA_FLIP_PRIMARY_NOTIFIER_CONTEXT_DMA_TO_MEMORY + dwHead);
        nvPushData (4,NV_DD_DMA_CONTEXT_DMA_IN_VIDEO_MEMORY);  // image a
        nvPushData (5,NV_DD_DMA_CONTEXT_DMA_IN_VIDEO_MEMORY);  // image b
        nvPushData (6,NV_DD_DMA_CONTEXT_DMA_IN_VIDEO_MEMORY);  // LUT a
        nvPushData (7,NV_DD_DMA_CONTEXT_DMA_IN_VIDEO_MEMORY);  // LUT b
        nvPushData (8,NV_DD_DMA_CONTEXT_DMA_IN_VIDEO_MEMORY);  // cursor a
        nvPushData (9,NV_DD_DMA_CONTEXT_DMA_IN_VIDEO_MEMORY);  // cursor b
        nvPushData (10,dDrawSubchannelOffset(NV_DD_SPARE) + NV067_SET_DAC(0) | 0x40000);
        nvPushData (11,asmMergeCoords(GET_MODE_WIDTH(), GET_MODE_HEIGHT()));
        nvPusherAdjust (12);
    }

#endif

    dbgTracePop();
    return (TRUE);
}

//---------------------------------------------------------------------------

#ifndef WINNT

// The Dll is about to be loaded.  Do whatever you want ...

DWORD __stdcall AboutToBeLoaded (void)
{
    dbgTracePush ("AboutToBeLoaded");
    dbgTracePop();
    return (TRUE);
}

//---------------------------------------------------------------------------

// The Dll is about to be unloaded.  Do whatever you want ...
// Unfortunately, we do not have a context ptr. Assume whatever
// was the last one although this could be wrong.

DWORD __stdcall AboutToBeUnloaded (void)
{
    dbgTracePush ("AboutToBeUnloaded");

    // clear the display driver's pointers to our global data structures
    for (int i = 0; i < MAX_ADAPTERS; i++) {

        pDriverData = (CDriverContext *)g_adapterData[i].pDriverData;
        pDXShare    = g_adapterData[i].pDXShare;

        // this memory will be released when the IPM heap is destroyed
        if (pDXShare) {
            pDXShare->pHalInfo       = NULL;
            pDXShare->pNvPrimarySurf = NULL;
        }

        if (pDriverData) {

            VppDisable(&pDriverData->vpp);   // Free objects...
            VppDestructor(&pDriverData->vpp);

#ifdef STEREO_SUPPORT
            DestroyStereo();
#endif // STEREO_SUPPORT

            // Destroy Item Arrays
            DestroyItemArrays();

            // Set this to NULL, so we won't try to call from the display driver
            // and GPF.
            pDXShare->pfnInterfaceFunc = (unsigned long) NULL;

            // Free the 16bit selectors we got from the display driver.
            FreeSelectorsFromDisplayDriver ();

            // Purge the heap of all DirectX allocations
            NVHEAP_PURGE ();

            // clear this entry in the table
            memset(&g_adapterData[i], 0, sizeof(NV_ADAPTER_TYPE));
        }
    }

    // destroy the heap
    DestroyIPM();

    dbgTracePop();
    return (TRUE);
}

//---------------------------------------------------------------------------

/*
    if nGet is TRUE then, selectors are allocated (unless they are
    already allocated.) if nGet = FALSE, they are freed (unless they
    are already freed.)
*/
DWORD __stdcall GetSelectorsFromDisplayDriver (void)
{
    DWORD dwEsc[2];

    dbgTracePush ("GetSelectorsFromDisplayDriver");

    if (!pDriverData->dwFourCCSelector) {

        // Allocate some selectors from the display driver. We need
        // these to fill in the HALInfo table correctly later.
        dwEsc[0] = (DWORD) &(pDriverData->fourCC[0]);
        dwEsc[1] = NV_MAX_FOURCC*4;
        if (!MyExtEscape(pDXShare->dwHeadNumber, GN_ESC_ALLOC_SELECTOR_AND_MAP, 8,
            (const char *) &(dwEsc[0]), 4, (char *) &pDriverData->dwFourCCSelector)) {
            dbgTracePop();
            return FALSE;
        }

        // Allocate some selectors from the display driver. We need
        // these to fill in the HALInfo table correctly later.
        dwEsc[0] = (DWORD) pDriverData->ModeList;
        dwEsc[1] = sizeof(DDHALMODEINFO) * MAX_MODEENTRYS;
        if (!MyExtEscape(pDXShare->dwHeadNumber, GN_ESC_ALLOC_SELECTOR_AND_MAP, 8,
            (const char *) &(dwEsc[0]), 4, (char *) &pDriverData->dwModeListSelector)) {
            dbgTracePop();
            return FALSE;
        }

        dwEsc[0] = (DWORD) &(pDriverData->vidMem);
        dwEsc[1] = sizeof(VIDMEM) * 2;
        if (!MyExtEscape(pDXShare->dwHeadNumber, GN_ESC_ALLOC_SELECTOR_AND_MAP, 8,
            (const char *) &(dwEsc[0]), 4, (char *) &pDriverData->dwPvmListSelector)) {
            dbgTracePop();
            return FALSE;
        }

        dwEsc[0] = (DWORD) &(pDriverData->DDCallbacks);
        dwEsc[1] = sizeof(pDriverData->DDCallbacks);
        if (!MyExtEscape(pDXShare->dwHeadNumber, GN_ESC_ALLOC_SELECTOR_AND_MAP, 8,
            (const char *) &(dwEsc[0]), 4, (char *) &pDriverData->dwDDCallbacksSelector)) {
            dbgTracePop();
            return FALSE;
        }

        dwEsc[0] = (DWORD) &(pDriverData->DDSurfaceCallbacks);
        dwEsc[1] = sizeof(pDriverData->DDSurfaceCallbacks);
        if (!MyExtEscape(pDXShare->dwHeadNumber, GN_ESC_ALLOC_SELECTOR_AND_MAP, 8,
            (const char *) &(dwEsc[0]), 4, (char *) &pDriverData->dwDDSurfaceCallbacksSelector)) {
            dbgTracePop();
            return FALSE;
        }

        dwEsc[0] = (DWORD) &(pDriverData->DDPaletteCallbacks);
        dwEsc[1] = sizeof(pDriverData->DDPaletteCallbacks);
        if (!MyExtEscape(pDXShare->dwHeadNumber, GN_ESC_ALLOC_SELECTOR_AND_MAP, 8,
            (const char *) &(dwEsc[0]), 4, (char *) &pDriverData->dwDDPaletteCallbacksSelector)) {
            dbgTracePop();
            return FALSE;
        }

        dwEsc[0] = (DWORD) &(pDriverData->DDExecuteBufferCallbacks);
        dwEsc[1] = sizeof(pDriverData->DDExecuteBufferCallbacks);
        if (!MyExtEscape(pDXShare->dwHeadNumber, GN_ESC_ALLOC_SELECTOR_AND_MAP, 8,
            (const char *) &(dwEsc[0]), 4, (char *) &pDriverData->dwDDExecuteBufferCallbackSelector)) {
            dbgTracePop();
            return FALSE;
        }
    }

    dbgTracePop();
    return(1);
}

DWORD __stdcall FreeSelectorsFromDisplayDriver (void)
{
    dbgTracePush ("FreeSelectorsFromDisplayDriver");

    if (pDriverData->dwFourCCSelector) {
        MyExtEscape(pDXShare->dwHeadNumber, GN_ESC_UNMAP_AND_FREE_SELECTOR, 4,
            (const char *) &pDriverData->dwFourCCSelector, 0, 0);
        pDriverData->dwFourCCSelector = 0;
    }

    if (pDriverData->dwModeListSelector) {
        MyExtEscape(pDXShare->dwHeadNumber, GN_ESC_UNMAP_AND_FREE_SELECTOR, 4,
            (const char *) &pDriverData->dwModeListSelector, 0, 0);
        pDriverData->dwModeListSelector = 0;
    }

    if (pDriverData->dwPvmListSelector) {
        MyExtEscape(pDXShare->dwHeadNumber, GN_ESC_UNMAP_AND_FREE_SELECTOR, 4,
            (const char *) &pDriverData->dwPvmListSelector, 0, 0);
        pDriverData->dwPvmListSelector = 0;
    }

    if (pDriverData->dwDDCallbacksSelector) {
        MyExtEscape(pDXShare->dwHeadNumber, GN_ESC_UNMAP_AND_FREE_SELECTOR, 4,
            (const char *) &pDriverData->dwDDCallbacksSelector, 0, 0);
        pDriverData->dwDDCallbacksSelector = 0;
    }

    if (pDriverData->dwDDSurfaceCallbacksSelector) {
        MyExtEscape(pDXShare->dwHeadNumber, GN_ESC_UNMAP_AND_FREE_SELECTOR, 4,
            (const char *) &pDriverData->dwDDSurfaceCallbacksSelector, 0, 0);
        pDriverData->dwDDSurfaceCallbacksSelector = 0;
    }

    if (pDriverData->dwDDPaletteCallbacksSelector) {
        MyExtEscape(pDXShare->dwHeadNumber, GN_ESC_UNMAP_AND_FREE_SELECTOR, 4,
            (const char *) &pDriverData->dwDDPaletteCallbacksSelector, 0, 0);
        pDriverData->dwDDPaletteCallbacksSelector = 0;
    }

    if (pDriverData->dwDDExecuteBufferCallbackSelector) {
        MyExtEscape(pDXShare->dwHeadNumber, GN_ESC_UNMAP_AND_FREE_SELECTOR, 4,
            (const char *) &pDriverData->dwDDExecuteBufferCallbackSelector, 0, 0);
        pDriverData->dwDDExecuteBufferCallbackSelector = 0;
    }

    dbgTracePop();
    return 1;
}

//---------------------------------------------------------------------------

/*
    DrvInterfaceFuncC (DWORD dwInterfaceID)

    This routine is called by the display driver directly from 16bit
    land. Do not call any system functions or you will hang. But you can
    set variables and just do normal C code.
*/

void __stdcall DrvInterfaceFuncC(DWORD dwInterfaceID, DWORD dwExtraData)
{
    global.b16BitCode = TRUE;

    // pDXShare has been set to the correct context data just before
    // DrvInterfaceFuncC is called, but pDriverData has not. Set it now.
    pDriverData = (CDriverContext *)pDXShare->pDirectXData;

    switch (dwInterfaceID)
    {
        case GDIDX_PRE_SETINFOINIT:
            buildDDHALInfo16 ();
            break;

        case GDIDX_PRE_MODESET_NOTIFY:
            nvModeSetPrepare16();
            break;

        case GDIDX_POST_MODESET_NOTIFY:
            nvModeSetCleanup16();
            break;

        case GDIDX_DIRECTX_OS_VERSION:
            // dwExtraData is the system DirectX runtime version.
            global.dwDXRuntimeVersion = dwExtraData;
            break;

        case GDIDX_DRIVER_UNLOADING:
        {
            DWORD dwRootIndex;
            int dwIndex = getAdapterIndex(pDXShare, &dwRootIndex);
            if (dwIndex != -1) {
                g_adapterData[dwIndex].pDXShare = NULL;
            }
            break;
        }

        case GDIDX_EARLY_DX_CONNECT:
            pDriverData->dwFullScreenDOSStatus |= FSDOSSTATUS_TWINVIEW_STATE_CHANGE;
            // if we were in video mirror mode, then context data is no longer valid
            pDriverData->vpp.dwOverlayFSTwinData.nvtwPhysicalModeImmediate.pHWCrtcCX = 0;
            pDriverData->vpp.dwOverlayFSTwinData.nvtwPhysicalModeImmediate.pGNLogdevCX = 0;
            pDriverData->vpp.dwOverlayFSTwinData.nvtwLockUnlockHwcrtc.pHWCrtcCX = 0;
            pDriverData->vpp.dwOverlayFSTwinData.nvtwLockUnlockHwcrtc.pGNLogdevCX = 0;
            break;
    }

    global.b16BitCode = FALSE;
    return;
}

//---------------------------------------------------------------------------

/*
    This call is used as a direct thunk from the 2D display driver to
    the 3D DirectX driver. The Win16 Mutex is not released. You can't
    make system calls from within this call.  However, there are certain
    important events that need to be sent over here as notifications,
    that are particularly important, so this interface was created.

    Arguments:  eax         flat 32 pDXShare
                ebx         purpose of call.
                            One of the GDIDX_XXX equates in dxshare.h
                ecx         Other context data which depends upon ebx.
*/

void __declspec(naked) __stdcall DrvInterfaceFunc(void)
{
    __asm
    {
    mov     pDXShare,eax
    push    ecx
    push    ebx
    call    DrvInterfaceFuncC
    retf
    }
}

/*
    This call is used as an interface back to the display driver
    from DirectX. However!! It should only be used to call back to
    the display driver, if we are in the DirectX driver because the
    display driver called it though the DrvInterfaceFunc function
    above. Basically you can only use this if you are running
    under the 16bit display driver context.

    Arguments:
    I set this function up to have parameters similar to the
    Display Driver escape call. There is a function select
    parameter which tells what the specific callback is. Then
    there is an lpIn ptr giving input parameters to the callback
    and an lpOut ptr to return things in.

    Returns:
    This routine returns TRUE if the dwFunction was recognized. The
    return values for specific functions are given in the structure
    pointed to by lpOut.
    This routine returns FALSE if the dwFunction was not recognized.

    The callbacks supported are given in drivers\common\win9x\inc\dxshare.h
*/
int DrvCallbackFunc(DWORD dwFunction, void *pIn, void *pOut)
{
    int     iRetVal;
    DWORD   dwCallSelector, dwCallOffset, pDispDriverHWLogDevCX;

    dwCallOffset          = pDXShare->dwDrvCallbackOffset;
    dwCallSelector        = pDXShare->dwDrvCallbackSelector;
    pDispDriverHWLogDevCX = pDXShare->pDispDriverHWLogDevCX;

    __asm
    {
        push    esi
        push    edi
        push    ebx

        // Flip the order of the parameters around since the
        // display driver uses PASCAL calling conventions.
        push    pDispDriverHWLogDevCX
        push    dwFunction
        push    pIn
        push    pOut

        ; push the return address
        mov     ax,cs
        and     eax,0FFFFH
        push    eax
        lea     eax,ComeBack
        push    eax

        ; Push the call address
        push    dwCallSelector
        push    dwCallOffset

        ; "Call" the 16bit side by doing a retf
        retf

ComeBack:
        mov iRetVal,eax

        ; The caller already popped the parameters
        ; Just pop the saved registers
        pop ebx
        pop edi
        pop esi
    }

    return  (iRetVal);
}

//---------------------------------------------------------------------------

/*
    GetModePitch ()

    This routine figurs out the pitch of a given mode. Since there might
    be tiling, the RM may have to get involved.
*/

DWORD __stdcall GetModePitch (int nXRes, int nYRes, int nBitsPerPixel)
{
    DWORD   dwPrimaryDisplayPitchInBytes, dwRoundValue;
    NV_CFGEX_GET_SURFACE_PITCH_PARAMS params;

    dbgTracePush ("GetModePitch");

    params.Width = nXRes;
    params.Depth = nBitsPerPixel;

    // Get the pitch from the RM for a given width/bpp
    if (NvRmConfigGetEx(pDriverData->dwRootHandle, NV_WIN_DEVICE,
                        NV_CFGEX_GET_SURFACE_PITCH,
                        &params, sizeof(params)) == NVOS_CGE_STATUS_SUCCESS) {
        dbgTracePop();
        return params.Pitch;
    }

    //
    // Couldn't get the value from the RM, so we'll make a best effort
    // attempt at determining what the pitch likely should be.
    //
    dwPrimaryDisplayPitchInBytes = (nXRes * nBitsPerPixel) >> 3;
    if (pDriverData->NvDeviceVersion >= NV_DEVICE_VERSION_10) {
        dwRoundValue = 0x3F;
    }
    else {
        dwRoundValue = 0x1F;
    }

    dwPrimaryDisplayPitchInBytes += dwRoundValue;
    dwPrimaryDisplayPitchInBytes &= (~dwRoundValue);

    dbgTracePop();
    return (dwPrimaryDisplayPitchInBytes);
}

//---------------------------------------------------------------------------

/*
    SortDDHalModeList ()

    This routine sorts the DDHalMode list so that modes are sorted
    first by color depth and then by XResolution. It returns the
    number of modes in the table.
*/
int __stdcall SortDDHalModeList ()
{
    DDHALMODEINFO   *p1, *p2, sTempMode;
    int             nSwap;

    dbgTracePush ("SortDDHalModeList");

    // OK, let's bubble sort the mode list
    for (p1 = pDriverData->ModeList; p1[1].dwWidth != 0; p1++)
    {
        for (p2 = p1 + 1; p2->dwWidth != 0; p2++)
        {
            // Assume correct order
            nSwap = 0;

            // Primary sort is on pixel depth
            if  (p1->dwBPP > p2->dwBPP)
                nSwap = 1;
            else
            {
                // Check if pixel depths equal
                if  (p1->dwBPP == p2->dwBPP)
                {
                    // pixel depths are equal -- sort on width
                    if  (p1->dwWidth > p2->dwWidth)
                        nSwap = 1;
                    else
                    {
                        // check if widths are equal
                        if  (p1->dwWidth == p2->dwWidth)
                        {
                            // widths equal -- sort on height
                            if  (p1->dwHeight > p2->dwHeight)
                                nSwap = 1;
                        }
                    }

                }
            }

            if  (nSwap)
            {
                sTempMode = *p1;
                *p1 = *p2;
                *p2 = sTempMode;
            }
        }
    }

    dbgTracePop();
    return ((p1 - pDriverData->ModeList) + 1);
}

//---------------------------------------------------------------------------

/*
    AddModeToTable ()

    This routine adds the mode to the mode table.
*/
void __stdcall AddModeToTable (DDHALMODEINFO *pMode, int nXRes, int nYRes, int nBitsPerPixel, int refresh)
{
    dbgTracePush ("AddModeToTable");

    // Add an entry to the ModeList
    // Special case to add a termination mode.
    if  (nXRes == 0)
    {
        pMode->dwWidth          = 0;
        pMode->dwHeight         = 0;
        pMode->lPitch           = 0;
        pMode->dwBPP            = 0;
        pMode->wRefreshRate     = 0;
        pMode->wFlags           = 0;
        pMode->dwRBitMask       = 0;
        pMode->dwGBitMask       = 0;
        pMode->dwBBitMask       = 0;
        pMode->dwAlphaBitMask   = 0;
        dbgTracePop();
        return;
    }

    pMode->dwWidth  = (DWORD) nXRes;
    pMode->dwHeight = (DWORD) nYRes;
    pMode->lPitch   = (LONG) GetModePitch(nXRes, nYRes, nBitsPerPixel);
    pMode->dwBPP    = (DWORD) nBitsPerPixel;
    pMode->wRefreshRate = refresh;

    if  (nBitsPerPixel == 8)
    {
        pMode->wFlags           = DDMODEINFO_PALETTIZED;
        pMode->dwRBitMask       = 0;
        pMode->dwGBitMask       = 0;
        pMode->dwBBitMask       = 0;
        pMode->dwAlphaBitMask   = 0;
    }

    if  (nBitsPerPixel == 16)
    {
        pMode->wFlags           = 0;
        pMode->dwRBitMask       = 0x0000F800;
        pMode->dwGBitMask       = 0x000007E0;
        pMode->dwBBitMask       = 0x0000001F;
        pMode->dwAlphaBitMask   = 0x00000000;
    }

    if  (nBitsPerPixel == 32)
    {
        pMode->wFlags           = 0;
        pMode->dwRBitMask       = 0x00FF0000;
        pMode->dwGBitMask       = 0x0000FF00;
        pMode->dwBBitMask       = 0x000000FF;
#ifdef SPOOF_ALPHA
        pMode->dwAlphaBitMask   = 0xFF000000;
#else
        pMode->dwAlphaBitMask   = 0x00000000;
#endif
    }

    dbgTracePop();
    return;
}

//---------------------------------------------------------------------------

/*
    BuildDefaultDDHalModeTable ()

    This routine builds a default table.
*/
void __stdcall BuildDefaultDDHalModeTable ()
{
    DDHALMODEINFO *pMode;

    dbgTracePush ("BuildDefaultDDHalModeTable");

    // Start out with a mode ptr
    pMode = pDriverData->ModeList;

    // These modes MUST be valid modes!
    AddModeToTable (pMode++, 640, 480, 8, 0);
    AddModeToTable (pMode++, 640, 480, 16, 0);
    AddModeToTable (pMode++, 640, 480, 32, 0);
    AddModeToTable (pMode++, 800, 600, 8, 0);
    AddModeToTable (pMode++, 800, 600, 16, 0);
    AddModeToTable (pMode++, 800, 600, 32, 0);
    AddModeToTable (pMode++, 1024, 768, 8, 0);
    AddModeToTable (pMode++, 1024, 768, 16, 0);
    AddModeToTable (pMode++, 1024, 768, 32, 0);

    // Sort the list
    SortDDHalModeList();

    // Record the number of modes in the table
    GET_HALINFO()->dwNumModes = pMode - pDriverData->ModeList;

    dbgTracePop();
    return;
}
#endif  // !WINNT

//---------------------------------------------------------------------------

/*
    BuildDDHalModeTable ()

    This routine calls the display driver to get the list of destop
    modes and also adds in a bunch of DDraw specific modes. It filters
    each mode based upon:
    1) The amount of free contiguous video memory starting from offset 0
       and the pitch of a mode determining the maximum number of bytes
       that can be consumed by the primary surface.
    2) The DAC speed (determining maximum pixel rate)
    3) The display type (NTSC, PAL, FLATPANEL 800,1024,1280, VGA MONITOR)
*/
void __stdcall BuildDDHalModeTable ()
{
#ifndef WINNT   // WINNT BUG Is there a SetMode callback under NT?
    DDHALMODEINFO   *pMode;
    MODEENTRY       sModeDesc[MAX_MODEENTRYS];
    int             i;
    DWORD           dwModeEntryType;
    BOOL            doRestrictTVModes;

    dbgTracePush ("BuildDDHalModeTable");

    // Call back to display driver to get the mode list from the registry
    // - zero out the mode list so that we have at least one record at the end
    //   of the list with dwXRes == 0. this allows the for loop that adds the
    //   basic mode table to terminate properly.
    memset (sModeDesc,0,sizeof(sModeDesc)); // zero out
    dwModeEntryType = MODETYPE_MODEENTRY;
    if  (!MyExtEscape(pDXShare->dwHeadNumber, NV_ESC_GET_REGISTRY_MODE_LIST, sizeof(DWORD), (LPCSTR)&dwModeEntryType,
                MAX_MODEENTRYS * sizeof(MODEENTRY), (char *) sModeDesc))
    {
        BuildDefaultDDHalModeTable ();
        dbgTracePop();
        return;
    }

    // Start off pointing to the ModeList
    pMode = pDriverData->ModeList;
    memset(pMode, 0, MAX_MODEENTRYS * sizeof(DDHALMODEINFO));

    // Make sure TwinView state is current
    ResetTwinViewState (pDriverData);

    // find out whether we need to restrict the modes to ones which will work on a TV
    doRestrictTVModes = FALSE;
    for (i = 0; i < (int)pDriverData->dwHeads; i++) {
        NVTWINVIEWDATA twinData = {0};
        DWORD          retVal;
        DWORD          dwCrtcNumber;
        DWORD          dwCompare;
        DWORD          dwHead;

        switch (pDriverData->dwDesktopState) {
        case NVTWINVIEW_STATE_DUALVIEW:
            dwCrtcNumber = 0;       // need to use logical head numbers in multimon mode
            dwHead = i;
            dwCompare = pDXShare->dwHeadNumber;
            break;
        case NVTWINVIEW_STATE_CLONE:
            dwCrtcNumber = i;
            dwHead = pDXShare->dwHeadNumber;
            dwCompare = i;
            break;
        default:
            // single mode
            dwCrtcNumber = 0;
            dwHead = pDXShare->dwHeadNumber;
            dwCompare = 0;
            break;
        }

        twinData.dwFlag   = NVTWINVIEW_FLAG_GET;
        twinData.dwAction = NVTWINVIEW_ACTION_SETGET_DEVICE_TYPE;
        twinData.dwCrtc   = dwCrtcNumber;

        retVal = MyExtEscape(dwHead, NV_ESC_SETGET_TWINVIEW_DATA, sizeof(NV_ESC_SETGET_TWINVIEW_DATA), (LPCSTR) &twinData, sizeof(NV_ESC_SETGET_TWINVIEW_DATA), (LPSTR) &twinData);
        if (twinData.dwSuccess && retVal &&
           (twinData.NVTWINVIEWUNION.nvtwdevdata[0].dwDeviceType == MONITOR_TYPE_NTSC ||
            twinData.NVTWINVIEWUNION.nvtwdevdata[0].dwDeviceType == MONITOR_TYPE_PAL)) {
            if (i == (int)dwCompare) {
                doRestrictTVModes = TRUE;
            }
        }
    }

    // Now we need to take the basic mode list we got back from the
    // display driver, convert it, and stick those modes in the Ddraw
    // table.
    if (doRestrictTVModes) {
        DWORD dwEncoderType;
        BOOL allow720, allow800, allow1024, allow800orHigher;
        // determine on a case by case basis which modes are allowed
        NvRmConfigGet (pDriverData->dwRootHandle, pDriverData->dwDeviceHandle,
                       NV_CFG_VIDEO_ENCODER_TYPE, &dwEncoderType);

        switch (dwEncoderType) {
        case NV_ENCODER_BROOKTREE_868:
        case NV_ENCODER_BROOKTREE_869:
            allow720 = TRUE;
            allow800 = TRUE;
            allow1024 = FALSE;
            break;
            
        case NV_ENCODER_CHRONTEL_7007:
        case NV_ENCODER_CHRONTEL_7008:
            allow720 = TRUE;
            allow800 = TRUE;
            allow1024 = FALSE;
            break;

        case NV_ENCODER_CHRONTEL_7003:
        case NV_ENCODER_CHRONTEL_7004:
        case NV_ENCODER_CHRONTEL_7005:
        case NV_ENCODER_CHRONTEL_7006:
        case NV_ENCODER_PHILIPS_7102:
        case NV_ENCODER_PHILIPS_7103:
        case NV_ENCODER_PHILIPS_7108:
        case NV_ENCODER_PHILIPS_7109:
        case NV_ENCODER_PHILIPS_7108B:
            allow720 = FALSE;
            allow800 = TRUE;
            allow1024 = FALSE;
            break;

        case NV_ENCODER_BROOKTREE_871:
            allow720 = FALSE;
            allow800 = TRUE;
            allow1024 = TRUE;
            break;

        default:
            allow720 = FALSE;
            allow800 = TRUE;
            allow1024 = TRUE;
            break;
        }

        allow800orHigher = TRUE;    // Toshiba special request

        // no refresh rate enumeration for TV modes
        for (i = 0; sModeDesc[i].dwXRes != 0; i++) {
            if (sModeDesc[i].dwRefreshRate == 60 &&
               (sModeDesc[i].dwXRes == 320 ||
                sModeDesc[i].dwXRes == 640 ||
               (sModeDesc[i].dwXRes == 720 && allow720) ||
               (sModeDesc[i].dwXRes == 800 && allow800) ||
               (sModeDesc[i].dwXRes >= 800 && allow800orHigher) ||  // for Toshiba
               (sModeDesc[i].dwXRes == 1024 && allow1024) ||
               (sModeDesc[i].dwXRes >= 800 && pDriverData->dwDesktopState == NVTWINVIEW_STATE_CLONE))) {
                AddModeToTable (pMode++, sModeDesc[i].dwXRes, sModeDesc[i].dwYRes, sModeDesc[i].dwBpp, 0);
            }
        }
    } else {
        DWORD dwLastXRes = 0, dwLastYRes = 0;
        if (pDriverData->regEnumDDRefresh == NV4_REG_ENUM_REFRESH_DISABLE) {
            for (i = 0; sModeDesc[i].dwXRes != 0; i++) {
                if (sModeDesc[i].dwXRes != dwLastXRes || sModeDesc[i].dwYRes != dwLastYRes) {
                    AddModeToTable (pMode++, sModeDesc[i].dwXRes, sModeDesc[i].dwYRes, sModeDesc[i].dwBpp, 0);
                    dwLastXRes = sModeDesc[i].dwXRes;
                    dwLastYRes = sModeDesc[i].dwYRes;
                }
            }
        } else if (pDriverData->regEnumDDRefresh == NV4_REG_ENUM_REFRESH_ENABLEBIG) {
            for (i = 0; sModeDesc[i].dwXRes != 0; i++) {
                if (sModeDesc[i].dwXRes >= 640 && sModeDesc[i].dwYRes >= 480) {
                    AddModeToTable (pMode++, sModeDesc[i].dwXRes, sModeDesc[i].dwYRes, sModeDesc[i].dwBpp, sModeDesc[i].dwRefreshRate);
                } else {
                    if (sModeDesc[i].dwXRes != dwLastXRes || sModeDesc[i].dwYRes != dwLastYRes) {
                        AddModeToTable (pMode++, sModeDesc[i].dwXRes, sModeDesc[i].dwYRes, sModeDesc[i].dwBpp, 0);
                        dwLastXRes = sModeDesc[i].dwXRes;
                        dwLastYRes = sModeDesc[i].dwYRes;
                    }
                }
            }
        } else if (pDriverData->regEnumDDRefresh == NV4_REG_ENUM_REFRESH_ENABLEALL) {
            for (i = 0; sModeDesc[i].dwXRes != 0; i++) {
                AddModeToTable (pMode++, sModeDesc[i].dwXRes, sModeDesc[i].dwYRes, sModeDesc[i].dwBpp, sModeDesc[i].dwRefreshRate);
            }
        }
    }

#ifdef  STEREO_SUPPORT_
    // For ASUS type of stereo connection we want to fool the DX and force it to reset a video mode
    // even if it matches the current desktop one. It has to be done because ASUS stereo requires
    // all stereo surfaces pairs (left/right eyes) to be adjasent in memory. And we don't want to waste
    // video memory when we're in 2D (aka desktop or GDI). Here is how we handle this. First we let
    // resman know that we enter "adjasent stereo surface allocation mode". Then we fool DX by building
    // a dummy mode entry that matches the current desktop. Basically for the current desktop mode we
    // will have 2 identical entries but the dummy one will be located behind the real one so DX will
    // never see it. By returning the dummy index in the dwModeIndex we will force DX to reset the video
    // mode. Bingo!!! Then resman will take care of the rest and create an adjacent stereo surface.
    if (STEREO_ENABLED)
    {
        DIBENGINEHDR1 *pDibeng = (DIBENGINEHDR1 *)pDXShare->pFlatDibeng;
        AddModeToTable (pMode++, pDibeng->deWidth, pDibeng->deHeight, pDibeng->deBitsPixel, 0x1234);
    }
#endif  //STEREO_SUPPORT

    // set up pointer to DDHALINFO
    LPDDHALINFO pHalInfo = (LPDDHALINFO)pDXShare->pHalInfo;

    // Setup the number of modes counter
    pHalInfo->dwNumModes = pMode - pDriverData->ModeList;

    // Sanity check
    if  (pHalInfo->dwNumModes == 0)
    {
        BuildDefaultDDHalModeTable ();
        dbgTracePop();
        return;
    }

    // Sort the mode list appropriately
    SortDDHalModeList ();

    dbgTracePop();
#endif // !WINNT
    return;
}

//---------------------------------------------------------------------------

#ifndef WINNT
int getRootIndex(DWORD dwAdapterIndex)
{
    dbgTracePush ("getRootIndex");

    nvAssert(dwAdapterIndex < MAX_ADAPTERS);

    DISPDRVDIRECTXCOMMON *pDXShare = g_adapterData[dwAdapterIndex].pDXShare;
    if (!pDXShare) {
        // not a valid index
        dbgTracePop();
        return -1;
    }

    DWORD dwRootHandle = pDXShare->dwRootHandle;

    for (DWORD i = 0; i < dwAdapterIndex; i++) {

        if (NULL == g_adapterData[i].pDXShare)
            continue;
        if (g_adapterData[i].pDXShare->dwRootHandle == dwRootHandle) {
            // found the root device for this adapter
            dbgTracePop();
            return i;
        }

    }

    dbgTracePop();
    return -1;
}

//---------------------------------------------------------------------------

DISPDRVDIRECTXCOMMON* getDXShare(DWORD dwRootHandle, DWORD dwHeadNumber)
{
   dbgTracePush ("getDXShareForHead");

   for (DWORD i = 0; i < MAX_ADAPTERS; i++) {

        DISPDRVDIRECTXCOMMON* pDXShare = g_adapterData[i].pDXShare;
        if (pDXShare
         && (pDXShare->dwRootHandle == dwRootHandle)
         && (pDXShare->dwHeadNumber == dwHeadNumber)) {
            // found the root device for this adapter
            dbgTracePop();
            return pDXShare;
        }

    }

    dbgTracePop();
    return NULL;
}

//---------------------------------------------------------------------------

int getAdapterIndex(DISPDRVDIRECTXCOMMON *pNewDXShare, DWORD *pdwRootIndex)
{
    dbgTracePush ("getAdapterIndex");

    nvAssert(pNewDXShare);

    for(DWORD i = 0; i < MAX_ADAPTERS; i++) {

        DISPDRVDIRECTXCOMMON *pDXShare = g_adapterData[i].pDXShare;

        if (pDXShare == pNewDXShare) {
            // found an entry, get the root index
            *pdwRootIndex = getRootIndex(i);
            dbgTracePop();
            return i;
        }

    }

    // the adapter table is full
    nvAssert(0);

    *pdwRootIndex = -1;
    dbgTracePop();
    return -1;
}
#endif

//---------------------------------------------------------------------------

/*
 * DriverInit
 *
 * this is the entry point called by DirectDraw to
 * initialize the 32-bit driver.
 *
 */
DWORD __stdcall DriverInit(DWORD dwDriverData)
{
    char regStr[256];
    HKEY  hKey;

    dbgResetTraceLevel ();
    dbgTracePush ("DriverInit");

#ifdef WINNT

    NvAcquireSemaphore((CDriverContext *) ((PDEV*)dwDriverData)->pDriverData);
    ppdev = (PDEV*)dwDriverData;
    pDriverData = (CDriverContext *)ppdev->pDriverData;
    DWORD dwAdapterIndex = ppdev->ulDeviceReference;

    BOOL bFirstTime = TRUE;

#else // !WINNT

    // The context data is always the PDevice
    pDXShare = (DISPDRVDIRECTXCOMMON *) dwDriverData;

    // get an hDC if we don't already have one
    if (!nvFillAdapterTable()) {
        // return if device is disabled
        NvReleaseSemaphore(pDriverData);
        dbgTracePop();
        return 0;
    }

    // add a new entry, or get an existing entry from the adapter table
    DWORD dwAdapterIndex, dwRootIndex;
    dwAdapterIndex = getAdapterIndex(pDXShare, &dwRootIndex);

    if (dwRootIndex == -1) {
        pDriverData = (CDriverContext *)g_adapterData[dwAdapterIndex].pDriverData;
    } else {
        // this is a secondary (or later) unit on a mult-unit card
        pDriverData = (CDriverContext *)g_adapterData[dwRootIndex].pDriverData;
    }

    // Give the HW-specific portion of the PDevice the flat selectors.
    pDXShare->dwFlatCodeSel = (unsigned long) GetFlatCodeSel();
    pDXShare->dwFlatDataSel = (unsigned long) GetFlatDataSel();
    pDXShare->pDirectXData  = (DWORD)pDriverData;

    if (!pDXShare->pHalInfo) {
        // allocate a DDHALINFO structure for this unit
        pDXShare->pHalInfo = (unsigned long)AllocIPM(sizeof(DDHALINFO));
        if (!pDXShare->pHalInfo) {
            // out of memory
            DPF("DriverInit: out of memory allocating DDHALINFO");
            NvReleaseSemaphore(pDriverData);
            dbgTracePop();
            return 0;
        }
    }

    BOOL bFirstTime = FALSE;

    // Allocate a DriverData structure if there isn't already one
    if (!pDriverData) {
        bFirstTime = TRUE;
        if (!nvAllocDriverStructures()) {
            NvReleaseSemaphore(pDriverData);
            dbgTracePop();
            return 0;
        }
    }

#endif // !WINNT

#ifdef NVSTATDRIVER
    AttachNVStat();
#endif

    if (bFirstTime)
    {
        if (!FirstTimeInit()) {
            NvReleaseSemaphore(pDriverData);
            dbgTracePop();
            return 0;
        }
        // add the pDriverData entry for this device to the global adapter table
        // always associate the pDriverData with the the first entry for this card
#ifdef WINNT
        g_adapterData[dwAdapterIndex].pDriverData = pDriverData;
#else
        if (dwRootIndex == -1) {
            g_adapterData[dwAdapterIndex].pDriverData = pDriverData;
        } else {
            g_adapterData[dwRootIndex].pDriverData = pDriverData;
        }
#endif
    }

    // Get the current registry settings from the hardware specific routine.
    D3DReadRegistry (pDriverData);

#ifdef TEXFORMAT_CRD
#ifndef WINNT
    // Attempt to get the RM derived AGP limit from the RM
    NvRmConfigGet (pDriverData->dwRootHandle,
                   NV_WIN_DEVICE,
                   NV_CFG_AGP_LIMIT,
                   &pDriverData->regMaxAGPLimit);

    // detect installed HW and determine how we are going to operate
    // Under WINNT, we need this info much earlier in the DX initialization
    // sequence (at DrvGetDirectDrawInfo time). So we have already called
    // nvDeterminePerformanceStrategy from the GDI driver at DrvEnablePDEV time.
    nvDeterminePerformanceStrategy (pDriverData);
#endif // !WINNT
#endif // TEXFORMAT_CRD

    // start capture stuff
#ifdef CAPTURE
    if (bFirstTime) {
        captureStartup (getDC()->nvD3DRegistryData.regszCaptureRecordPath,
                        getDC()->nvD3DRegistryData.regszCaptureRecordFilename,
                        getDC()->nvD3DRegistryData.regCaptureRecordFilenum);
        capturePlayStartup (getDC()->nvD3DRegistryData.regszCapturePlayPath,
                            getDC()->nvD3DRegistryData.regszCapturePlayFilename,
                            getDC()->nvD3DRegistryData.regCapturePlayFilenum);
    }
    else {
        captureSetParams (getDC()->nvD3DRegistryData.regszCaptureRecordPath,
                          getDC()->nvD3DRegistryData.regszCaptureRecordFilename,
                          getDC()->nvD3DRegistryData.regCaptureRecordFilenum);
        capturePlaySetParams (getDC()->nvD3DRegistryData.regszCapturePlayPath,
                              getDC()->nvD3DRegistryData.regszCapturePlayFilename,
                              getDC()->nvD3DRegistryData.regCapturePlayFilenum);
    }
#endif  // CAPTURE

    if (bFirstTime)
    {
#ifdef TEXFORMAT_CRD
        if (!nvEnumerateFourCCs()) {
            NvReleaseSemaphore(pDriverData);
            dbgTracePop();
            return 0;
        }
        if (!nvEnumerateSurfaceFormats()) {
            NvReleaseSemaphore(pDriverData);
            dbgTracePop();
            return 0;
        }
#endif  // TEXFORMAT_CRD
    }

#ifdef WINNT
    //***************************************************************
    // Shared variable for active channel id is stored in NT display
    // driver state.
    //***************************************************************
    pDriverData->pCurrentChannelID = (ULONG) &(ppdev->oglLastChannel);
#else // !WINNT

    // Have to get the DC first before we can isue this call. Hence,
    // I can't do it in FirstTimeInit.
    MyExtEscape(pDXShare->dwHeadNumber, NV_ESC_GETACTIVECHANNELPTR, 0, 0, 4, (char *) &(pDriverData->pCurrentChannelID));
    // Allocate 16 bit selectors we will need and assign them if it hasn't
    // already been done (the routine protects itself from doing twice.)
    if (!GetSelectorsFromDisplayDriver()) {
        NvReleaseSemaphore(pDriverData);
        dbgTracePop();
        return 0;
    }

    // Do this every time we come into DriverInit -- just in case
    // KillHelp is run. DllMain will clear out the ptr when the DirectX
    // driver is punted out of memory. Here we need to re-establish it.
    pDXShare->pfnInterfaceFunc = (unsigned long) DrvInterfaceFunc;

    {
        DCICMD sMyDciCmd;

        // Adding new escape to display driver to tell them that a DX
        // app is being started.
        sMyDciCmd.dwVersion = DD_VERSION;
        sMyDciCmd.dwCommand = DDNVCREATEDRIVEROBJECT;
        MyExtEscape(pDXShare->dwHeadNumber, DCICOMMAND, sizeof(DCICMD), (const char *)&sMyDciCmd, 0, 0);
    }
#endif // !WINNT

    // set up pointer to DDHALINFO
    LPDDHALINFO pHalInfo = GET_HALINFO();

    // if this is the second driverinit for the second head, kick out
    if (pDriverData->dwDrvRefCount++ > 0) {

        buildDDHALInfo32(pDriverData);
        nvSetHardwareCaps();

#ifdef WINNT
        pHalInfo->lpD3DGlobalDriverData = (LPVOID)&(getDC()->D3DGlobalDriverData);
        D3DHALCreateDriver((LPD3DHAL_GLOBALDRIVERDATA) pHalInfo->lpD3DGlobalDriverData,
                           (LPD3DHAL_CALLBACKS*)&pHalInfo->lpD3DHALCallbacks,
                           (LPDDHAL_DDEXEBUFCALLBACKS *)&pHalInfo->lpD3DBufCallbacks,
                           pDriverData);
#else
        pHalInfo->lpD3DGlobalDriverData = (ULONG_PTR)&(getDC()->D3DGlobalDriverData);
        //they just HAD to rename the structure members didn't they....
        D3DHALCreateDriver((LPD3DHAL_GLOBALDRIVERDATA) pHalInfo->lpD3DGlobalDriverData,
                           (LPD3DHAL_CALLBACKS*)&pHalInfo->lpD3DHALCallbacks,
                           (LPDDHAL_DDEXEBUFCALLBACKS *)&pHalInfo->lpDDExeBufCallbacks,
                           pDriverData);
#endif // !WINNT

        BuildDDHalModeTable ();
        NvReleaseSemaphore(pDriverData);
        dbgTracePop();
        return (DWORD)dwDriverData;

    }

#ifndef WINNT
    // grab north bridge ID
    DWORD nbID;
    _asm {
            mov edx, 0cf8h
            mov eax, 80000000h
            out dx,eax
            mov edx, 0cfch
            in  eax, dx
            mov nbID, eax
    }
    pDriverData->northBridgeID = nbID;
#else
    pDriverData->northBridgeID = 0;
#endif

    pDriverData->dwCurrentBlit   = 0;
    CURRENT_FLIP   = 0;
    COMPLETED_FLIP = 0;

    getDC()->dwAAContextCount = 0;
    pDriverData->dwRingZeroMutex = FALSE;

    pDriverData->blitCalled = FALSE;

#ifndef WINNT
    pDriverData->HALCallbacks.lpSetInfo = 0;
#endif // !WINNT

#ifndef TEXFORMAT_CRD  // moved up
#ifndef WINNT
    // Attempt to get the RM derived AGP limit from the RM
    NvRmConfigGet (pDriverData->dwRootHandle,
                   NV_WIN_DEVICE,
                   NV_CFG_AGP_LIMIT,
                   &pDriverData->regMaxAGPLimit);

    // detect installed HW and determine how we are going to operate
    // this effects the following test for pushbuffer size
    // Under WINNT, we need this info much earlier in the DX initialization
    // sequence (at DrvGetDirectDrawInfo time). So we have already
    // called nvDeterminePerformanceStrategy from the GDI driver
    // at DrvEnablePDEV time.
    nvDeterminePerformanceStrategy(pDriverData);
#endif // !WINNT
#endif // !TEXFORMAT_CRD

    // Construct the VPP object (must be after nvDeterminePerformanceStrategy)
    //   There must be NO references to vpp data prior to this point
    //
#ifdef WINNT
    if (!VppConstructor(ppdev, &(pDriverData->vpp), &pDriverData->nvD3DPerfData))
#else
    if (!VppConstructor(pDriverData, &(pDriverData->vpp), &pDriverData->nvD3DPerfData))
#endif
    {
        VppDestructor(&(pDriverData->vpp)); // Release anything we might have allocated thus far
        NvReleaseSemaphore(pDriverData);
        dbgTracePop();
        return 0;
    }
#if IS_WINNT5
    VppReadRegistry(&pDriverData->vpp, ppdev->hDriver, ppdev->ulDeviceDisplay[0]);
#else
    VppReadRegistry(&pDriverData->vpp, 0             , pDXShare->dwHeadNumber);
#endif

    // Reset in case of a mode switch which unloaded the driver
    pHalInfo->ddCaps.dwCurrVisibleOverlays = 0;

    // Reset motion comp control
    pDriverData->dwMCNVMCSurface = 0;
    pDriverData->dwMCNVDSSurfaceBase = 0;
    pDriverData->bMCOverlaySrcIsSingleField1080i = FALSE;
    pDriverData->bMCHorizontallyDownscale1080i = FALSE;

    pDriverData->dwVideoPortsAvailable = 1;

    bltInit();

    pDriverData->DDrawVideoSurfaceCount = 0;

    #ifdef NVPE
    // set VPE initial state
    NVPInitialState(pDriverData);
    #else
    pDriverData->nvpeState.bVPEInitialized = 0;
    pDriverData->nvpeState.bFsMirrorEnabled = 0;
    #endif

    // Can't reinitialize NV here because mode change may not have happened yet.

    // Append DirectDraw subkey to the global registry base path without using C runtime lib
    nvStrCpy(regStr, NV4_REG_GLOBAL_BASE_PATH "\\" NV4_REG_DIRECT_DRAW_SUBKEY);

    // Controls how much persistent AGP is reserved (i.e. not included in DDraw's heap)
    // We keep at least 8MB and no more than 1/8th the total amount of AGP memory
    pDriverData->regPersistAGPSize = max (((pDriverData->regMaxAGPLimit + 1) >> 3), 0x800000);

    // Let any registry entries override our values; lookup happens under the Global\DirectDraw key
    if (RegOpenKeyEx(NV4_REG_GLOBAL_BASE_KEY, regStr, 0, KEY_QUERY_VALUE, &hKey) == ERROR_SUCCESS) {
        DWORD   dwSize = sizeof(long);
        DWORD   dwType = REG_DWORD;
        long    lValue;

        if (RegQueryValueEx(hKey, PERSISTENT_AGP_SIZE, NULL, &dwType, (LPBYTE)&lValue, &dwSize) == ERROR_SUCCESS) {
            pDriverData->regPersistAGPSize = lValue;
        }
        if (RegQueryValueEx(hKey, NV_MAX_AGP_SIZE, NULL, &dwType, (LPBYTE)&lValue, &dwSize) == ERROR_SUCCESS) {
            pDriverData->regMaxAGPLimit = lValue - 1;   // appears we can setup 128M and alloc at least 80M

        }
        RegCloseKey(hKey);
    }

    pDriverData->dwTVTunerFlipCount = 0;
    pDriverData->dwTVTunerTimer = 0;
    pDriverData->regEnumDDRefresh = 0;
    pDriverData->regTVTunerHack = NV4_REG_VBMM_NOHACK;

    //VPE enable stuff
#ifndef NVPE
    pDriverData->bEnableVPE = 1;
#endif // NVPE

    // Append System subkey to the global registry base path without using C runtime lib
    nvStrCpy(regStr, NV4_REG_GLOBAL_BASE_PATH "\\" NV4_REG_RESOURCE_MANAGER_SUBKEY);

#ifndef WINNT
    // controls whether dma push buffer should be forced into PCI memory
    // 1 = force DMA push buffer to be created in PCI memory
    // 2 = same as '1', but also reduce AGP heap size by an amount equal to the size of the push buffer
    if (IS_VIA_MVP3_NB_ID(pDriverData->northBridgeID)) {
        // default case for the VIA 598 is to put push buffer in system memory
        pDriverData->regSuper7Compat = 1;
    } else {
        pDriverData->regSuper7Compat = 0;
    }
#else
    pDriverData->regSuper7Compat = 0;
#endif

    if (RegOpenKeyEx(NV4_REG_GLOBAL_BASE_KEY, regStr, 0, KEY_QUERY_VALUE, &hKey) == ERROR_SUCCESS)
    {
        hKey = 0;
    }
    if (hKey) {
        DWORD   dwSize = sizeof(long);
        DWORD   dwType = REG_DWORD;
        long    lValue;

        if (RegQueryValueEx(hKey, NV_REG_SYS_SUPER7_COMPATIBILITY, NULL, &dwType, (LPBYTE)&lValue, &dwSize) == ERROR_SUCCESS) {
            pDriverData->regSuper7Compat = lValue;
        }
        RegCloseKey(hKey);
    }

#ifndef WINNT
    // Grab the local registry path and append the System subkey to the string
    // without using the C runtime library.
    MyExtEscape (pDXShare->dwHeadNumber, NV_ESC_GET_LOCAL_REGISTRY_PATH, 0, NULL, 256, regStr);
    nvStrCat (&(regStr[4]), "\\" NV4_REG_RESOURCE_MANAGER_SUBKEY);
#endif // !WINNT

    // Controls the push buffer location
    if (pDriverData->regSuper7Compat) {
        pDriverData->regPBLocale = NV_REG_SYS_PB_LOCATION_SYSTEM;
    } else {
        pDriverData->regPBLocale = NV_REG_SYS_PB_LOCATION_DEFAULT;
    }
    if (RegOpenKeyEx((HKEY)(*((LPDWORD)&regStr[0])), &regStr[4], 0, KEY_QUERY_VALUE, &hKey) == ERROR_SUCCESS) {
        DWORD   dwSize = sizeof(long);
        DWORD   dwType = REG_DWORD;
        long    lValue;

        if (RegQueryValueEx(hKey, NV_REG_SYS_PB_LOCATION, NULL, &dwType, (LPBYTE)&lValue, &dwSize) == ERROR_SUCCESS) {
            pDriverData->regPBLocale = lValue;
        }
        RegCloseKey(hKey);
    }

// Used for texture profiling (counting the # of texture DL's)
#ifdef CNT_TEX
    for (int iFrmCnt = 0; iFrmCnt<MAX_FRAME_CNT; iFrmCnt++) {
        g_dwVidTexDL[iFrmCnt] = 0;
        g_dwAgpTexDL[iFrmCnt] = 0;
    }
    g_dwFrames = 0;
#endif

    // the desktopstate value needs to be processed before calling buildddhalinfo32
#ifdef WINNT
    pDriverData->dwDesktopState = ppdev->TwinView_State;
#else
    NVTWINVIEWDATA twinViewData;
    memset(&twinViewData, 0, sizeof(twinViewData));
    twinViewData.dwFlag   = NVTWINVIEW_FLAG_GET;
    twinViewData.dwAction = NVTWINVIEW_ACTION_SETGET_STATE;
    MyExtEscape(pDXShare->dwHeadNumber, NV_ESC_SETGET_TWINVIEW_DATA, 0, NULL, sizeof(twinViewData), (char*)&twinViewData);
    nvAssert(twinViewData.dwSuccess);
    pDriverData->dwDesktopState = twinViewData.dwState;
#endif

    buildDDHALInfo32(pDriverData);
    BuildDDHalModeTable();
    nvSetHardwareCaps();

#ifdef WINNT
    pHalInfo->lpD3DGlobalDriverData = (LPVOID)&(getDC()->D3DGlobalDriverData);
    D3DHALCreateDriver((LPD3DHAL_GLOBALDRIVERDATA) pHalInfo->lpD3DGlobalDriverData,
                       (LPD3DHAL_CALLBACKS*)&pHalInfo->lpD3DHALCallbacks,
                       (LPDDHAL_DDEXEBUFCALLBACKS *)&pHalInfo->lpD3DBufCallbacks,
                       pDriverData);
#else
    pHalInfo->lpD3DGlobalDriverData = (ULONG_PTR)&(getDC()->D3DGlobalDriverData);
    //they just HAD to rename the structure members didn't they....
    D3DHALCreateDriver((LPD3DHAL_GLOBALDRIVERDATA) pHalInfo->lpD3DGlobalDriverData,
                       (LPD3DHAL_CALLBACKS*)&pHalInfo->lpD3DHALCallbacks,
                       (LPDDHAL_DDEXEBUFCALLBACKS *)&pHalInfo->lpDDExeBufCallbacks,
                       pDriverData);
#endif // !WINNT

    // process manager initialization
    pDriverData->lpProcessInfoHead = 0;

#ifdef ENABLE_VPP_DISPATCH_CODE
#ifndef WINNT
    vppInitDispatcher(&(pDriverData->vpp));
#endif // !WINNT
#endif


#ifdef KPFS
#if (NVARCH >= 0x20)
    pDriverData->nvKelvinPM.create(128);
#endif
#endif


#ifndef WINNT   // Win9x Hackery
#ifndef NVPE
    // this call is for VPE/KMVT stuff, to hook up with and initialize their storage
    if ( !HookUpVxdStorage() ) {
        // couldn't get VXD... what do we do?
        // return zero indicating that we can't do it!
        NvReleaseSemaphore(pDriverData);
        dbgTracePop();
        return 0;
    }
#endif // !NVPE
#endif // !WINNT

    pDriverData->bRing0FlippingFlag = FALSE;

    NvReleaseSemaphore(pDriverData);
    dbgTracePop();
    return (DWORD)dwDriverData;
} // DriverInit


//---------------------------------------------------------------------------

/*
 * Here's where we redirect all DDHAL32_VidMemAlloc/DDHAL32_VidMemFree calls to the RM.
 * We also keep a AGP_TABLE that keeps a mapping of allocations to dynamically created
 * memory handles.
 *
 */
#ifndef WINNT
#undef DDHAL32_VidMemAlloc
#undef DDHAL32_VidMemFree
FLATPTR EXTERN_DDAPI DDHAL32_VidMemAlloc (LPDDRAWI_DIRECTDRAW_GBL pdrv, int heap, DWORD dwXDim, DWORD dwYDim);
void    EXTERN_DDAPI DDHAL32_VidMemFree  (LPDDRAWI_DIRECTDRAW_GBL pdrv, int heap, FLATPTR ptr);
#endif

typedef struct _AGP_TABLE
{
    FLATPTR             addr;
    FLATPTR             physaddr;
    DWORD               offset;
    DWORD               limit;
    DWORD               handle;
    struct _AGP_TABLE   *next;
} AGP_TABLE;

static AGP_TABLE *lpAGPTable = NULL;
static AGP_TABLE *lastOffset = NULL;

#ifndef WINNT

U032 __stdcall SetSharedFSDOSBoxPtr (U032 *pData)
{
    HANDLE  dwVXDHandle;
    U032    dwError;
    U032    outputSize = 0;

    dbgTracePush ("SetSharedFSDOSBoxPtr");

    if (pDriverData->thisDeviceID > 1) {
        // There is never a DOS box on the secondary device
        dbgTracePop();
        return (FALSE);
    }

    dwVXDHandle = NvCreateFile(NVX_PRIMARY_MINIVDD, 0,0,0, CREATE_NEW, FILE_FLAG_DELETE_ON_CLOSE, 0);

    if ((dwVXDHandle == NULL) || (dwVXDHandle == INVALID_HANDLE_VALUE)) {
        DPF("\r\nCan't get Vxd handle   :-(");
        dwError = GetLastError();
        DPF("The error was %d (0x%x)", dwError, dwError);
        if (dwError == 50) {
            DPF("Which means most likely that you don't have a version of NVMINI.VXD which supports IOCTL");
        }
        dbgTracePop();
        return (FALSE);
    }

    DeviceIoControl(dwVXDHandle,
                    0x20000700,
                    pData,
                    4,
                    NULL,
                    0,
                    &outputSize,
                    NULL);

    NvCloseHandle(dwVXDHandle);

    dbgTracePop();
    return (TRUE);
}

//---------------------------------------------------------------------------

BOOL WINAPI DllMain(HINSTANCE hModule, DWORD dwReason, LPVOID lpvReserved)
{
    static DWORD dwAttachCount = 0;

    dbgTracePush ("DllMain");

    switch ( dwReason ) {

        case DLL_PROCESS_ATTACH:
            DisableThreadLibraryCalls( hModule );
#ifdef  NVD3D
            if (dwAttachCount == 0) {
                init_globals();
            }
#endif  // NVD3D
            dwAttachCount++;
            InitIPM();
            AboutToBeLoaded();
            break;

        case DLL_PROCESS_DETACH:
            dwAttachCount--;
#ifdef  NVD3D
            if (dwAttachCount == 0) {
                SetSharedFSDOSBoxPtr (NULL);
                AboutToBeUnloaded();
            }
#endif  // NVD3D
            break;

        case DLL_THREAD_ATTACH:
            break;

        case DLL_THREAD_DETACH:
            break;

        default:
            break;
    }

    dbgTracePop();
    return (TRUE);

} // DllMain

//---------------------------------------------------------------------------

// these old entry points never were defined on NT and never will be

/*
 * D3D DX5 Draw Primitive entry points
 */
DWORD __stdcall DrawOnePrimitive32 (LPD3DHAL_DRAWONEPRIMITIVEDATA pdopd)
{
    dbgTracePush ("DrawOnePrimitive32");

    nvAssert (global.dwDXRuntimeVersion < 0x0700);

    // get the context
    PNVD3DCONTEXT pContext;
    NV_SET_CONTEXT (pContext, pdopd);

    nvSetDriverDataPtrFromContext (pContext);

    nvSetD3DSurfaceState (pContext);

    if (global.dwDXRuntimeVersion < 0x700) {
        nvPusherSignalWaitForFlip (pContext->pRenderTarget->getfpVidMem(), DDSCAPS_PRIMARYSURFACE);
    }

    DWORD dwRV = nvDrawOnePrimitive(pdopd);

    NvReleaseSemaphore(pDriverData);
    dbgTracePop();
    return(dwRV);
}

//---------------------------------------------------------------------------

DWORD __stdcall DrawOneIndexedPrimitive32 (LPD3DHAL_DRAWONEINDEXEDPRIMITIVEDATA pdoipd)
{
    dbgTracePush ("DrawOneIndexedPrimitive32");

    nvAssert (global.dwDXRuntimeVersion < 0x0700);

    // get the context
    PNVD3DCONTEXT pContext;
    NV_SET_CONTEXT (pContext, pdoipd);

    nvSetDriverDataPtrFromContext (pContext);

    nvSetD3DSurfaceState (pContext);

    if (global.dwDXRuntimeVersion < 0x700) {
        nvPusherSignalWaitForFlip (pContext->pRenderTarget->getfpVidMem(), DDSCAPS_PRIMARYSURFACE);
    }

    DWORD dwRV = nvDrawOneIndexedPrimitive(pdoipd);

    NvReleaseSemaphore(pDriverData);
    dbgTracePop();
    return(dwRV);
}

//---------------------------------------------------------------------------

DWORD __stdcall DrawPrimitives32 (LPD3DHAL_DRAWPRIMITIVESDATA pdpd)
{
    dbgTracePush ("DrawPrimitives32");

    nvAssert (global.dwDXRuntimeVersion < 0x0700);

    // get the context
    PNVD3DCONTEXT pContext;
    NV_SET_CONTEXT (pContext, pdpd);

    nvSetDriverDataPtrFromContext (pContext);

    nvSetD3DSurfaceState (pContext);

    if (global.dwDXRuntimeVersion < 0x700) {
        nvPusherSignalWaitForFlip (pContext->pRenderTarget->getfpVidMem(), DDSCAPS_PRIMARYSURFACE);
    }

    DWORD dwRV = nvDrawPrimitives(pdpd);

    NvReleaseSemaphore(pDriverData);
    dbgTracePop();
    return(dwRV);
}

#endif // !WINNT

//---------------------------------------------------------------------------

// prepare for an impending mode switch under win9x.
// note this is 16-bit code. system calls and stuff are disallowed!

DWORD __stdcall nvModeSetPrepare16 (void)
{
#ifdef TEX_MANAGE
    nvTexManageEvictAll (NULL);
#endif
    return (DD_OK);
}

//---------------------------------------------------------------------------

// cleanup subsequent to a mode switch under win9x.
// note this is 16-bit code. system calls and stuff are disallowed!

DWORD __stdcall nvModeSetCleanup16 (void)
{
    // empty for now.
    return (DD_OK);
}

//---------------------------------------------------------------------------

#ifdef WINNT

//
// Win2K D3DHALCreateDriver entry point
//
BOOL __stdcall NvWin2KD3DHALCreateDriver(DD_HALINFO* pHalInfo, PDEV* ppdev)
{
    GLOBALDATA* pDriverData = ppdev->pDriverData;
    pHalInfo->lpD3DGlobalDriverData = (void*)&(getDC()->D3DGlobalDriverData);
    return D3DHALCreateDriver((LPD3DHAL_GLOBALDRIVERDATA)pHalInfo->lpD3DGlobalDriverData,
                              (LPD3DHAL_CALLBACKS *)&pHalInfo->lpD3DHALCallbacks,
                              (PDD_D3DBUFCALLBACKS *)&pHalInfo->lpD3DBufCallbacks,
                              pDriverData);
}

//---------------------------------------------------------------------------

BOOL __stdcall NvWin2KAllocDriverData(PDEV* ppdev)
{
    nvAssert(ppdev);

    CDriverContext *pDriverContext = (CDriverContext*)g_adapterData[ppdev->ulDeviceReference].pDriverData;

    if (pDriverContext) {

        // return the pDriverData we already have
        ppdev->pDriverData = pDriverContext;

        return FALSE;
    }

    // set up local context
    //   this context has the same scope as pDriverData but it only defined for nvdd32.dll
    //   we also make certain it is aligned to a 32 byte boundary (rm gives us page aligned)
    //   rm requires size to be a page-size multiple

    // new operator is used to init it properly
    pDriverContext = new CDriverContext;

    if (!pDriverContext)
    {
        nvAssert(FALSE);
        return TRUE;
    }

    pDriverContext->create();

    //
    // Associate the DX GLOBALDATA with the GDI PDEV.
    //
    ppdev->pDriverData = pDriverContext;

    return FALSE;
}

//---------------------------------------------------------------------------

//
// Win2K routine to initialize all DX related global data structures.
//
void __stdcall NvWin2KInitDXGlobals()
{
    init_globals();
    InitIPM();
    return;
}

//---------------------------------------------------------------------------

DWORD __stdcall NvWin2KGetAgpLimit(PDEV *ppdev, DWORD dwRootHandle, DWORD dwDevID)
{
    DWORD dwAgpLimit, dwValue;

    if (!nvReadRegistryDWORD(ppdev, "MAXAGPHEAPSIZE", &dwValue))
    {
#ifdef NV_AGP
        dwValue = 128; // default heap size is 128MB
#else // !NV_AGP
        dwValue = 32; // default heap size is 32MB
#endif // !NV_AGP
    }

#ifndef NV_AGP
    // the heap size may not be more than 1/8 of the system memory size (win2k kernel issue)
    dwValue = min(ppdev->pDriverData->nvD3DPerfData.dwSystemMemory / 8, dwValue);
#else    
    // fix for any system that sets an AGP aperature TOO large
    {
        DWORD dwMem = ppdev->pDriverData->nvD3DPerfData.dwSystemMemory / 2;
        dwValue = min(dwValue, dwMem);
    }
#endif // !NV_AGP

    // convert to MB
    ppdev->pDriverData->regMaxAGPLimit = dwValue * 1024 * 1024 - 1;

#ifdef NV_AGP
    // the heap size may not be more than the aperture size
    NvRmConfigGet(dwRootHandle, dwDevID, NV_CFG_AGP_LIMIT, &dwAgpLimit);

    // GDI may be using an AGP push buffer so adjust for it
    if (ppdev->AgpPushBuffer)
        dwAgpLimit -= ppdev->DmaPushBufTotalSize;

    ppdev->pDriverData->regMaxAGPLimit = min(dwAgpLimit, ppdev->pDriverData->regMaxAGPLimit);

#else // !NV_AGP

    // the heap size may not be more than half the aperture size
    NvRmConfigGet(dwRootHandle, dwDevID, NV_CFG_AGP_LIMIT, &dwAgpLimit);

    // GDI AGP push buffer adjustment is done in NvWin2KpvmConfig for !NV_AGP case

    ppdev->pDriverData->regMaxAGPLimit = min(((dwAgpLimit + 1) / 2) - 1, ppdev->pDriverData->regMaxAGPLimit);

    if (ppdev->AgpHeap) {
        DWORD dwLimit = ppdev->AgpHeap->fpEnd - ppdev->AgpHeap->fpStart;
        if (ppdev->pDriverData->regMaxAGPLimit > dwLimit) {
            ppdev->pDriverData->regMaxAGPLimit = dwLimit;
            DPF("AGP Heap size adjusted to %d MB", (dwLimit + 1) / 1024 / 1024);
        }
    }
#endif // !NV_AGP

    return TRUE;
}

//---------------------------------------------------------------------------

#ifdef NV_AGP

//
// Win2K routine to fill in the pvmList data structure
//
void __stdcall NvWin2KpvmConfig(PDEV *ppdev, VIDEOMEMORY *pvmList)
{
    memset(pvmList, 0, sizeof(VIDEOMEMORY));
}

#else // !NV_AGP

//
// Win2K routine to fill in the pvmList data structure
//
void __stdcall NvWin2KpvmConfig(PDEV *ppdev, VIDEOMEMORY *pvmList)
{
    // Tell ddraw that this heap is not to be used for any
    // type of surface.
    pvmList->dwFlags = VIDMEM_ISLINEAR | VIDMEM_ISNONLOCAL | VIDMEM_ISWC;
    pvmList->fpStart = 0;
    pvmList->fpEnd   = pvmList->fpStart + ppdev->pDriverData->regMaxAGPLimit;

    // If GDI pushbuf is in AGP mem, need to adjust the AGP heap
    // size request.
    if (ppdev->AgpPushBuffer && (ppdev->DmaPushBufTotalSize <= pvmList->fpEnd))
        pvmList->fpEnd -= ppdev->DmaPushBufTotalSize;

    // Only use AGP mem for offscreenplain, or textures if first
    // pass allocation failed.
    pvmList->ddsCaps.dwCaps    = ~(DDSCAPS_OFFSCREENPLAIN | DDSCAPS_TEXTURE | DDSCAPS_NONLOCALVIDMEM);
    pvmList->ddsCapsAlt.dwCaps = ~(DDSCAPS_OFFSCREENPLAIN | DDSCAPS_TEXTURE | DDSCAPS_NONLOCALVIDMEM);
}

//
// Win2K routine to map the AGP heap into kernel mode address space.
//
DWORD __stdcall NvWin2KMapAgpHeap(PDEV *ppdev)
{
    NV_SYSMEM_SHARE_MEMORY      AgpHeapIn, AgpHeapOut;
    DWORD                       dwReturnedDataLength;

    AgpHeapIn.byteLength = ppdev->pDriverData->regMaxAGPLimit + 1;
    AgpHeapIn.physicalAddress = (ULONG) ppdev->pDriverData->GARTPhysicalBase;
    if (EngDeviceIoControl(ppdev->hDriver,
                           IOCTL_VIDEO_MAP_PHYS_ADDR,
                           &AgpHeapIn,  sizeof(NV_SYSMEM_SHARE_MEMORY),
                           &AgpHeapOut, sizeof(NV_SYSMEM_SHARE_MEMORY),
                           &dwReturnedDataLength))
    {
        // could not map AGP heap
        nvAssert(0);
        return FALSE;
    }

    ppdev->pDriverData->GARTLinearBase = (ULONG) AgpHeapOut.ddVirtualAddress;

    return TRUE;
}

//---------------------------------------------------------------------------

//
// Win2K routine to unmap the kernel mode address of the AGP heap.
//
DWORD __stdcall NvWin2KUnmapAgpHeap(PDEV *ppdev)
{
    NV_SYSMEM_SHARE_MEMORY      AgpHeapIn;
    DWORD                       dwReturnedDataLength;

    AgpHeapIn.byteLength = ppdev->pDriverData->regMaxAGPLimit + 1;
    AgpHeapIn.ddVirtualAddress = (PVOID) ppdev->pDriverData->GARTLinearBase;
    if (EngDeviceIoControl(ppdev->hDriver,
                           IOCTL_VIDEO_UNMAP_PHYS_ADDR,
                           &AgpHeapIn, sizeof(NV_SYSMEM_SHARE_MEMORY),
                           &AgpHeapIn, sizeof(NV_SYSMEM_SHARE_MEMORY),
                           &dwReturnedDataLength))
    {
        // could not unmap AGP heap
        nvAssert(0);
        return FALSE;
    }

    // Indicate that there is no longer an active AGP heap.
    ppdev->pDriverData->GARTLinearBase = 0;
    return TRUE;
}

//---------------------------------------------------------------------------

FLATPTR NvWin2kDxAllocMem(GLOBALDATA *pDriverData, ULONG ulHeapId, ULONG ulSize)
{
    FLATPTR fpOffset;

    if (ulHeapId == AGP_HEAP)
    {
        fpOffset = HeapVidMemAllocAligned(ppdev->AgpHeap, ulSize, 1,
            &(ppdev->AgpHeapAlignment), &(ppdev->AgpDummyPitch));
        if (fpOffset) {
            fpOffset -= pDriverData->GARTLinearHeapOffset;
        }
        else {
            // AGP memory allocation request failed
            fpOffset = ERR_DXALLOC_FAILED;
        }
    }
    else {
        nvAssert(0);
        fpOffset = ERR_DXALLOC_FAILED;
    }
    return(fpOffset);
}

//---------------------------------------------------------------------------

void NvWin2kDxFreeMem(GLOBALDATA *pDriverData, ULONG ulHeapId, FLATPTR fpOffset)
{
    if ((ulHeapId == AGP_HEAP) && pDriverData->GARTLinearBase)
    {
        fpOffset += pDriverData->GARTLinearHeapOffset;
        VidMemFree(ppdev->AgpHeap->lpHeap,
            fpOffset);
    }
}
#endif // !NV_AGP
#endif // WINNT
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\ddraw\common\src\ddSurf.cpp ===
// **************************************************************************
//
//       Copyright 1993-1999 NVIDIA, Corporation.  All rights reserved.
//
//     NOTICE TO USER:   The source code  is copyrighted under  U.S. and
//     international laws.  Users and possessors of this source code are
//     hereby granted a nonexclusive,  royalty-free copyright license to
//     use this code in individual and commercial software.
//
//     Any use of this source code must include,  in the user documenta-
//     tion and  internal comments to the code,  notices to the end user
//     as follows:
//
//       Copyright 1993-1999 NVIDIA, Corporation.  All rights reserved.
//
//     NVIDIA, CORPORATION MAKES NO REPRESENTATION ABOUT THE SUITABILITY
//     OF  THIS SOURCE  CODE  FOR ANY PURPOSE.  IT IS  PROVIDED  "AS IS"
//     WITHOUT EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORPOR-
//     ATION DISCLAIMS ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,
//     INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY, NONINFRINGE-
//     MENT,  AND FITNESS  FOR A PARTICULAR PURPOSE.   IN NO EVENT SHALL
//     NVIDIA, CORPORATION  BE LIABLE FOR ANY SPECIAL,  INDIRECT,  INCI-
//     DENTAL, OR CONSEQUENTIAL DAMAGES,  OR ANY DAMAGES  WHATSOEVER RE-
//     SULTING FROM LOSS OF USE,  DATA OR PROFITS,  WHETHER IN AN ACTION
//     OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,  ARISING OUT OF
//     OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOURCE CODE.
//
//     U.S. Government  End  Users.   This source code  is a "commercial
//     item,"  as that  term is  defined at  48 C.F.R. 2.101 (OCT 1995),
//     consisting  of "commercial  computer  software"  and  "commercial
//     computer  software  documentation,"  as such  terms  are  used in
//     48 C.F.R. 12.212 (SEPT 1995)  and is provided to the U.S. Govern-
//     ment only as  a commercial end item.   Consistent with  48 C.F.R.
//     12.212 and  48 C.F.R. 227.7202-1 through  227.7202-4 (JUNE 1995),
//     all U.S. Government End Users  acquire the source code  with only
//     those rights set forth herein.
//
// **************************************************************************
//  Content:    DirectDraw HAL surface management
//
//  History:
//        schaefer           7/6/99
//
// **************************************************************************
#include "nvprecomp.h"

#if (NVARCH >= 0x04)

#include "nvOverlaySurf.h"  // For creation of FOURCC and overlay surfaces
#ifdef VPEFSMIRROR
#include "nvpkrnl.h" // for VPE FS Mirror
#endif

#ifdef WINNT
#include "nvMultiMon.h"
#endif

#ifdef WINNT
extern "C"
{
    extern void __cdecl NV_OglDDrawSurfaceCreated(PDEV *ppdev);
    extern void __cdecl NV_OglDDrawSurfaceDestroyed(PDEV *ppdev);
}
#define NV_OGLDDRAWSURFACECREATED(PDEV) NV_OglDDrawSurfaceCreated((PDEV))
#define NV_OGLDDRAWSURFACEDESTROYED(PDEV) NV_OglDDrawSurfaceDestroyed((PDEV))
#else
#define NV_OGLDDRAWSURFACECREATED(PDEV)
#define NV_OGLDDRAWSURFACEDESTROYED(PDEV)
#endif

#ifdef DEBUG_SURFACE_PLACEMENT
extern CSurfaceDebug csd;
#endif

// getDisplayDuration
//
// get the length (in ticks) of a refresh cycle
void getDisplayDuration( void )
{
#ifdef WINNT
    DWORD dwHead;
    NV_CFGEX_GET_REFRESH_INFO_PARAMS refreshInfo;
    __int64 timeFrequency;

    dbgTracePush ("getDisplayDuration");

    // for the most part inactive for win2k
    getDC()->flipPrimaryRecord.fpFlipFrom = 0xDEADBEEF;

    // we need this stuff for the back door CRTC synchronized blits

    // determine which head is the default
    dwHead = GET_CURRENT_HEAD();

    // get and save CRTC params
    getDC()->flipPrimaryRecord.nvTimingInfo[dwHead].Head = dwHead;
    getDC()->flipPrimaryRecord.nvTimingInfo[dwHead].Reg = NV_CFGEX_CRTC_TIMING_REGISTER;
    if (NvRmConfigGetEx(pDriverData->dwRootHandle, NV_WIN_DEVICE,
                        NV_CFGEX_CRTC_TIMING_MULTI,
                        &getDC()->flipPrimaryRecord.nvTimingInfo[dwHead],
                        sizeof(NV_CFGEX_CRTC_TIMING_PARAMS)) != NVOS_CGE_STATUS_SUCCESS) {
        // error, this structure is invalid
        getDC()->flipPrimaryRecord.nvTimingInfo[dwHead].Head = 0xFFFFFFFF;
    }

    // get refresh rate
    refreshInfo.Head = dwHead;
    refreshInfo.ulState = 0;
    if (NvRmConfigGetEx(pDriverData->dwRootHandle, NV_WIN_DEVICE,
                        NV_CFGEX_GET_REFRESH_INFO,
                        &refreshInfo,
                        sizeof(NV_CFGEX_GET_REFRESH_INFO_PARAMS)) != NVOS_CGE_STATUS_SUCCESS) {
        // error can find refresh rate
        getDC()->flipPrimaryRecord.llFlipDurationNs[dwHead] = 0;
    } else {
        if (refreshInfo.ulRefreshRate) {
            getDC()->flipPrimaryRecord.llFlipDurationNs[dwHead] = (LONGLONG)1000000000 / (LONGLONG)refreshInfo.ulRefreshRate;
        } else {
            getDC()->flipPrimaryRecord.llFlipDurationNs[dwHead] = 0;
        }
    }

    // calculate flip duration in units of ticks
    EngQueryPerformanceFrequency(&timeFrequency);
    getDC()->flipPrimaryRecord.dwFlipDuration = (unsigned long)(timeFrequency * getDC()->flipPrimaryRecord.llFlipDurationNs[dwHead] / 1000000000);

    // get and save CRTC params for the other head
    if ((ppdev->ulDesktopMode & NV_TWO_DACS) &&
       ((ppdev->ulDesktopMode & NV_CLONE_DESKTOP) ||
        (ppdev->ulDesktopMode & NV_SPANNING_MODE))) {
        // we are in a TwinView mode, get the CRTC params for the other head too
        dwHead ^= 1;
        getDC()->flipPrimaryRecord.nvTimingInfo[dwHead].Head = dwHead;
        getDC()->flipPrimaryRecord.nvTimingInfo[dwHead].Reg = NV_CFGEX_CRTC_TIMING_REGISTER;
        if (NvRmConfigGetEx(pDriverData->dwRootHandle, NV_WIN_DEVICE,
                            NV_CFGEX_CRTC_TIMING_MULTI,
                            &getDC()->flipPrimaryRecord.nvTimingInfo[dwHead],
                            sizeof(NV_CFGEX_CRTC_TIMING_PARAMS)) != NVOS_CGE_STATUS_SUCCESS) {
            // error, this structure is invalid
            getDC()->flipPrimaryRecord.nvTimingInfo[dwHead].Head = 0xFFFFFFFF;
        }

        // get refresh rate
        refreshInfo.Head = dwHead;
        refreshInfo.ulState = 0;
        if (NvRmConfigGetEx(pDriverData->dwRootHandle, NV_WIN_DEVICE,
                            NV_CFGEX_GET_REFRESH_INFO,
                            &refreshInfo,
                            sizeof(NV_CFGEX_GET_REFRESH_INFO_PARAMS)) != NVOS_CGE_STATUS_SUCCESS) {
            // error can find refresh rate
            getDC()->flipPrimaryRecord.llFlipDurationNs[dwHead] = 0;
        } else {
            if (refreshInfo.ulRefreshRate) {
                getDC()->flipPrimaryRecord.llFlipDurationNs[dwHead] = (LONGLONG)1000000000 / (LONGLONG)refreshInfo.ulRefreshRate;
            } else {
                getDC()->flipPrimaryRecord.llFlipDurationNs[dwHead] = 0;
            }
        }

    } else {
        getDC()->flipPrimaryRecord.nvTimingInfo[dwHead ^ 1].Head = 0xFFFFFFFF;
        getDC()->flipPrimaryRecord.llFlipDurationNs[dwHead ^ 1] = 0;
    }
#else
#define IS_IN_VBLANK(a) ((a)==0 || (a)>=GET_MODE_PHYSICAL_HEIGHT(cfgParams.Head))
    int         i;
    __int64     start, end;
    DWORD       oldclass;
    HANDLE      hprocess;
    NV_CFGEX_CURRENT_SCANLINE_MULTI_PARAMS cfgParams;
    BOOL timeOut;

    dbgTracePush ("getDisplayDuration");

    memset( &getDC()->flipPrimaryRecord, 0, sizeof( getDC()->flipPrimaryRecord ) );
    memset( &getDC()->flipOverlayRecord, 0, sizeof( getDC()->flipOverlayRecord ) );

    NVTWINVIEWDATA twinData;
    LONGLONG timeFrequency;
    // RM needs physical head, map logical to physical
    twinData.dwFlag   = NVTWINVIEW_FLAG_GET;
    twinData.dwAction = NVTWINVIEW_ACTION_MAP_LOG_TO_PHYS_HEAD;
    twinData.dwCrtc   = pDXShare->dwHeadNumber;
    MyExtEscape(pDXShare->dwHeadNumber, NV_ESC_SETGET_TWINVIEW_DATA, sizeof(NV_ESC_SETGET_TWINVIEW_DATA), (LPCSTR) &twinData, sizeof(NV_ESC_SETGET_TWINVIEW_DATA), (LPSTR) &twinData);
    cfgParams.Head    = twinData.dwCrtc;
    // get start time for timeouts (display may be disabled)
    QueryPerformanceFrequency((LARGE_INTEGER *)&timeFrequency);

    // get and save CRTC params
    getDC()->flipPrimaryRecord.nvTimingInfo[cfgParams.Head].Head = cfgParams.Head;
    getDC()->flipPrimaryRecord.nvTimingInfo[cfgParams.Head].Reg = NV_CFGEX_CRTC_TIMING_REGISTER;
    if (NvRmConfigGetEx(pDriverData->dwRootHandle, NV_WIN_DEVICE,
                        NV_CFGEX_CRTC_TIMING_MULTI,
                        &getDC()->flipPrimaryRecord.nvTimingInfo[cfgParams.Head],
                        sizeof(NV_CFGEX_CRTC_TIMING_PARAMS)) != NVOS_CGE_STATUS_SUCCESS) {
        // error, this structure is invalid
        getDC()->flipPrimaryRecord.nvTimingInfo[cfgParams.Head].Head = 0xFFFFFFFF;
    }

    hprocess = GetCurrentProcess();
    oldclass = GetPriorityClass( hprocess );
//    SetPriorityClass( hprocess, REALTIME_PRIORITY_CLASS ); Can't do this due to Electronic Arts bug in Triple Play 97
    SetPriorityClass( hprocess, HIGH_PRIORITY_CLASS );

    NvRmConfigGetEx (pDriverData->dwRootHandle, pDriverData->dwDeviceHandle,
                     NV_CFGEX_CURRENT_SCANLINE_MULTI, &cfgParams, sizeof(cfgParams));
    timeOut = FALSE;
    QueryPerformanceCounter((LARGE_INTEGER*)&start);
    while (!IS_IN_VBLANK(cfgParams.RasterPosition) && !timeOut) {
        NvRmConfigGetEx (pDriverData->dwRootHandle, pDriverData->dwDeviceHandle,
                         NV_CFGEX_CURRENT_SCANLINE_MULTI, &cfgParams, sizeof(cfgParams));
        LONGLONG timeNow;
        QueryPerformanceCounter((LARGE_INTEGER*)&timeNow);
        if ((timeNow - start) >= (timeFrequency / 20)) timeOut = TRUE;  // timout of 1/20th of a second
    }

    QueryPerformanceCounter((LARGE_INTEGER*)&start);
    #define LOOP_CNT    20
    for ( i=0;i<LOOP_CNT;i++ ) {
        NvRmConfigGetEx (pDriverData->dwRootHandle, pDriverData->dwDeviceHandle,
                         NV_CFGEX_CURRENT_SCANLINE_MULTI, &cfgParams, sizeof(cfgParams));
        while (IS_IN_VBLANK(cfgParams.RasterPosition) && !timeOut) {
            NvRmConfigGetEx (pDriverData->dwRootHandle, pDriverData->dwDeviceHandle,
                             NV_CFGEX_CURRENT_SCANLINE_MULTI, &cfgParams, sizeof(cfgParams));
            LONGLONG timeNow;
            QueryPerformanceCounter((LARGE_INTEGER*)&timeNow);
            if ((timeNow - start) >= timeFrequency) timeOut = TRUE;  // timout of 1/20th of a second
        }
        while (!IS_IN_VBLANK(cfgParams.RasterPosition) && !timeOut) {
            NvRmConfigGetEx (pDriverData->dwRootHandle, pDriverData->dwDeviceHandle,
                             NV_CFGEX_CURRENT_SCANLINE_MULTI, &cfgParams, sizeof(cfgParams));
            LONGLONG timeNow;
            QueryPerformanceCounter((LARGE_INTEGER*)&timeNow);
            if ((timeNow - start) >= timeFrequency) timeOut = TRUE;  // timout of 1/20th of a second
        }
    }
    QueryPerformanceCounter((LARGE_INTEGER*)&end);

    SetPriorityClass( hprocess, oldclass );
    getDC()->flipPrimaryRecord.dwFlipDuration = ((DWORD)(end-start) + LOOP_CNT/2)/LOOP_CNT;

    GET_HALINFO()->dwMonitorFrequency = (DWORD)start / getDC()->flipPrimaryRecord.dwFlipDuration;

    getDC()->flipPrimaryRecord.llFlipDurationNs[cfgParams.Head] = (LONGLONG)getDC()->flipPrimaryRecord.dwFlipDuration * 1000000000 / timeFrequency;

    // get and save CRTC params for the other head
    if (pDriverData->dwHeads > 1 &&
       (pDriverData->dwDesktopState == NVTWINVIEW_STATE_CLONE ||
        pDriverData->dwDesktopState == NVTWINVIEW_STATE_DUALVIEW)) {
        // we are in a TwinView mode, get the CRTC params for the other head too
        cfgParams.Head ^= 1;
        getDC()->flipPrimaryRecord.nvTimingInfo[cfgParams.Head].Head = cfgParams.Head;
        getDC()->flipPrimaryRecord.nvTimingInfo[cfgParams.Head].Reg = NV_CFGEX_CRTC_TIMING_REGISTER;
        if (NvRmConfigGetEx(pDriverData->dwRootHandle, NV_WIN_DEVICE,
                            NV_CFGEX_CRTC_TIMING_MULTI,
                            &getDC()->flipPrimaryRecord.nvTimingInfo[cfgParams.Head],
                            sizeof(NV_CFGEX_CRTC_TIMING_PARAMS)) != NVOS_CGE_STATUS_SUCCESS) {
            // error, this structure is invalid
            getDC()->flipPrimaryRecord.nvTimingInfo[cfgParams.Head].Head = 0xFFFFFFFF;
        }

        // need to do all the timing for the other head
        SetPriorityClass( hprocess, HIGH_PRIORITY_CLASS );

        NvRmConfigGetEx (pDriverData->dwRootHandle, pDriverData->dwDeviceHandle,
                         NV_CFGEX_CURRENT_SCANLINE_MULTI, &cfgParams, sizeof(cfgParams));
        timeOut = FALSE;
        QueryPerformanceCounter((LARGE_INTEGER*)&start);
        while (!IS_IN_VBLANK(cfgParams.RasterPosition) && !timeOut) {
            NvRmConfigGetEx (pDriverData->dwRootHandle, pDriverData->dwDeviceHandle,
                             NV_CFGEX_CURRENT_SCANLINE_MULTI, &cfgParams, sizeof(cfgParams));
            LONGLONG timeNow;
            QueryPerformanceCounter((LARGE_INTEGER*)&timeNow);
            if ((timeNow - start) >= (timeFrequency / 20)) timeOut = TRUE;  // timout of 1/20th of a second
        }

        QueryPerformanceCounter((LARGE_INTEGER*)&start);
        for ( i=0;i<LOOP_CNT;i++ ) {
            NvRmConfigGetEx (pDriverData->dwRootHandle, pDriverData->dwDeviceHandle,
                             NV_CFGEX_CURRENT_SCANLINE_MULTI, &cfgParams, sizeof(cfgParams));
            while (IS_IN_VBLANK(cfgParams.RasterPosition) && !timeOut) {
                NvRmConfigGetEx (pDriverData->dwRootHandle, pDriverData->dwDeviceHandle,
                                 NV_CFGEX_CURRENT_SCANLINE_MULTI, &cfgParams, sizeof(cfgParams));
                LONGLONG timeNow;
                QueryPerformanceCounter((LARGE_INTEGER*)&timeNow);
                if ((timeNow - start) >= timeFrequency) timeOut = TRUE;  // timout of 1/20th of a second
            }
            while (!IS_IN_VBLANK(cfgParams.RasterPosition) && !timeOut) {
                NvRmConfigGetEx (pDriverData->dwRootHandle, pDriverData->dwDeviceHandle,
                                 NV_CFGEX_CURRENT_SCANLINE_MULTI, &cfgParams, sizeof(cfgParams));
                LONGLONG timeNow;
                QueryPerformanceCounter((LARGE_INTEGER*)&timeNow);
                if ((timeNow - start) >= timeFrequency) timeOut = TRUE;  // timout of 1/20th of a second
            }
        }
        QueryPerformanceCounter((LARGE_INTEGER*)&end);

        SetPriorityClass( hprocess, oldclass );
        getDC()->flipPrimaryRecord.llFlipDurationNs[cfgParams.Head] = (LONGLONG)(((DWORD)(end-start) + LOOP_CNT/2)/LOOP_CNT) * 1000000000 / timeFrequency;

    } else {
        getDC()->flipPrimaryRecord.nvTimingInfo[cfgParams.Head ^ 1].Head = 0xFFFFFFFF;
        getDC()->flipPrimaryRecord.llFlipDurationNs[cfgParams.Head ^ 1] = 0;
    }

#ifdef DEBUG
    QueryPerformanceFrequency((LARGE_INTEGER*)&start);

    DPF_LEVEL(NVDBG_LEVEL_SURFACE, "Duration = %d ticks, %dms, %dHz",
         getDC()->flipPrimaryRecord.dwFlipDuration,
         getDC()->flipPrimaryRecord.dwFlipDuration * 1000 / (DWORD)start,
         (DWORD)start / getDC()->flipPrimaryRecord.dwFlipDuration);
#endif // DEBUG

#endif // !WINNT

    dbgTracePop();

} // getDisplayDuration

//---------------------------------------------------------------------------
//
//  CreateSurface helper routines
//
//---------------------------------------------------------------------------

BOOL nvCalculateColorKey (DWORD *pColorKey, LPDDRAWI_DDRAWSURFACE_LCL pDDSLcl, DWORD dwFormat)
{
    dbgTracePush ("nvCalculateColorKey");

    if (pDDSLcl->dwFlags & DDRAWISURF_HASCKEYSRCBLT)
    {
        switch (dwFormat)
        {
            case NV_SURFACE_FORMAT_Y8:
            case NV_SURFACE_FORMAT_A1R5G5B5:
            case NV_SURFACE_FORMAT_A4R4G4B4:
            case NV_SURFACE_FORMAT_R5G6B5:
                // Must assume the application does the right thing here and passes
                // in the exact color key value as is in the texture map. If the alpha
                // bits are masked here, WHQL will fail.
                *pColorKey = pDDSLcl->ddckCKSrcBlt.dwColorSpaceHighValue & 0x0000FFFF;
                break;
            case NV_SURFACE_FORMAT_X1R5G5B5:
            case NV_SURFACE_FORMAT_DXT1_A1R5G5B5:
                *pColorKey = pDDSLcl->ddckCKSrcBlt.dwColorSpaceHighValue & 0x00007FFF;
                break;
            case NV_SURFACE_FORMAT_A8R8G8B8:
            case NV_SURFACE_FORMAT_X8R8G8B8:
            case NV_SURFACE_FORMAT_DXT23_A8R8G8B8:
            case NV_SURFACE_FORMAT_DXT45_A8R8G8B8:
                *pColorKey = pDDSLcl->ddckCKSrcBlt.dwColorSpaceHighValue;
                break;
            case NV_SURFACE_FORMAT_I8_A8R8G8B8:
                if ((GET_PNVOBJ(pDDSLcl))
                 && (GET_PNVOBJ(pDDSLcl)->getTexture())
                 && (GET_PNVOBJ(pDDSLcl)->getTexture()->hasAutoPalette())
                 && (GET_PNVOBJ(pDDSLcl)->getTexture()->getOriginalFormat() == NV_SURFACE_FORMAT_X8R8G8B8))
                {
                    *pColorKey = pDDSLcl->ddckCKSrcBlt.dwColorSpaceHighValue | 0xFF000000; // fix colour-key alpha
                } else {
                    *pColorKey = pDDSLcl->ddckCKSrcBlt.dwColorSpaceHighValue;
                }
                break;
            default:
                DPF ("unhandled texture format %d in nvCalculateColorKey", dwFormat);
                nvAssert(0);
                dbgTracePop();
                return FALSE;
                break;
        }  // switch

        dbgTracePop();
        return TRUE;
    }

    dbgTracePop();
    return FALSE;
}

//---------------------------------------------------------------------------

DWORD nvCalculateZBufferParams (LPDDRAWI_DDRAWSURFACE_LCL pDDSLcl,
                                DWORD *pFormat, DWORD *pWidth, DWORD *pHeight, DWORD *pMultiSampleBits,
                                DWORD *pBPPRequested, DWORD *pBPPGranted, DWORD *pPitch)
{
    DWORD dwRenderDepth, dwZDepth;

    dbgTracePush ("nvCalculateZBufferParams");

#ifndef WINNT
    // on WIN2K this flag is undefined at this point
    nvAssert (pDDSLcl->dwFlags & DDRAWISURF_HASPIXELFORMAT);
#endif

    // i contend that this will always be set. please let me know
    // if this assertion ever fails... CRD
    // (CRD note to self: if no failure, consolidate with other calc routine,
    // add param to (dis)allow BPP munging. FALSE for sys, true for vid)
    nvAssert (pDDSLcl->lpGbl->ddpfSurface.dwFlags & DDPF_ZBUFFER);

    dwRenderDepth = GET_MODE_BPP();

    if (pDDSLcl->lpGbl->ddpfSurface.dwFlags & DDPF_ZBUFFER) {
        dwZDepth = pDDSLcl->lpGbl->ddpfSurface.dwZBufferBitDepth;
    }
    else {
        dwZDepth = dwRenderDepth;
    }

    // treat 24 and 32 bits as synonymous
    if (dwZDepth == 24) dwZDepth = 32;

    // we only allow 16- and 32-bit z-buffers
    if ((dwZDepth != 16) &&
        (dwZDepth != 32)) {
        DPF ("unsupported zeta depth in nvCalculateZBufferParams");
        dbgTracePop();
        return (DDERR_INVALIDPIXELFORMAT);
    }

    // ideally we want to always be strict if this is a DX7 app, but we have
    // no way of telling what kind of app this is in this context
    if ((getDC()->nvD3DRegistryData.regValidateZMethod == D3D_REG_VALIDATEZMETHOD_STRICT) &&
        (dwRenderDepth != dwZDepth)) {
        dbgTracePop();
        return (DDERR_INVALIDPIXELFORMAT);
    }

    *pBPPRequested = dwZDepth >> 3;

    if ((*pBPPRequested == 4)
     || (pDriverData->nvD3DPerfData.dwNVClasses & NVCLASS_FAMILY_KELVIN)
     || (pDriverData->nvD3DPerfData.dwNVClasses & NVCLASS_1196_CELSIUS)) {
        // if they requested 32 bits or we have kelvin or an nv11, they get what they want
        *pBPPGranted = *pBPPRequested;
    }
    else {
        // on non-mixed buffer hardware, grant a z buffer compatible with the render target
        *pBPPGranted = (dwRenderDepth > 16) ? 4 : 2;
    }

    *pWidth  = pDDSLcl->lpGbl->wWidth;
    *pHeight = pDDSLcl->lpGbl->wHeight;

    *pPitch  = *pBPPGranted * *pWidth;
    *pPitch = (*pPitch + pDriverData->dwSurfaceAlignPad) & ~pDriverData->dwSurfaceAlignPad;

    if (*pBPPGranted == 2) {
        *pFormat = NV_SURFACE_FORMAT_Z16;
    }
    else {  // *pBPPGranted = 4
        if (pDDSLcl->lpGbl->ddpfSurface.dwFlags & DDPF_STENCILBUFFER) {
            *pFormat = NV_SURFACE_FORMAT_Z24S8;
        }
        else {
            *pFormat = NV_SURFACE_FORMAT_Z24X8;
        }
    }

    // Multisampling surfaces
    *pMultiSampleBits = pDDSLcl->lpSurfMore->ddsCapsEx.dwCaps3 & DDSCAPS3_MULTISAMPLE_MASK;

    dbgTracePop();
    return (DD_OK);
}

//---------------------------------------------------------------------------

DWORD nvCalculateSurfaceParams (LPDDRAWI_DDRAWSURFACE_LCL pDDSLcl,
                                DWORD *pFormat, BOOL *bFourCC,
                                DWORD *pWidth, DWORD *pHeight, DWORD *pDepth,
                                DWORD *pMultiSampleBits,
                                DWORD *pBPPRequested, DWORD *pBPPGranted,
                                DWORD *pPitch, DWORD *pSlicePitch, BOOL bComputePitch /* rather than extracting it */)
{
    DWORD dwBitCount, dwAlphaMask, dwRedMask, dwLumMask;
    BOOL  bIsDXT = FALSE;

    dbgTracePush ("nvCalculateSurfaceParams");

    // take care of execute buffers first
    if (pDDSLcl->ddsCaps.dwCaps & DDSCAPS_EXECUTEBUFFER) {
        *pFormat       = 0;
        *bFourCC       = FALSE;
        *pWidth        = pDDSLcl->lpGbl->dwLinearSize;
        *pHeight       = 1;
        *pDepth        = 1;
        *pMultiSampleBits = 0;
        *pBPPRequested = 0;
        *pBPPGranted   = 0;
        *pPitch        = *pWidth;
        dbgTracePop();
        return (DD_OK);
    }

    // error message setup
#ifdef DEBUG
    const char *pErrMsg = NULL;
    #define ERRMSG(str) (pErrMsg = str)
#else
    #define ERRMSG(str) //no-op
#endif

    // determine surface format, BPP, and fourCC'ness according to surface type

#ifdef WINNT
    // under WIN2K the DDRAWISURF_HASPIXELFORMAT flag is undefined and implied to be set
    // use the display bit depth when getting a request for an 8 bit surface,
    // this allows the 8 bit DCT AGP Blit tests to run
    if (!((pDDSLcl->lpGbl->ddpfSurface.dwRGBBitCount == 8) && (pDDSLcl->lpGbl->ddpfSurface.dwFlags & DDPF_RGB) && !(pDDSLcl->lpGbl->ddpfSurface.dwFlags & DDPF_PALETTEINDEXED8))) {
#else
    if (pDDSLcl->dwFlags & DDRAWISURF_HASPIXELFORMAT) {
#endif

        // if we have a pixel format, we must be either RGB, fourCC, or a zbuffer

        if ((pDDSLcl->lpGbl->ddpfSurface.dwFlags & DDPF_RGB) ||
            (pDDSLcl->lpGbl->ddpfSurface.dwFlags & DDPF_FOURCC) && (pDDSLcl->lpGbl->ddpfSurface.dwFourCC == FOURCC_RGB0)) {

            // find the bit count, the alpha mask, and the red mask.
            // these are sufficient to infer the surface format

            dwBitCount  = pDDSLcl->lpGbl->ddpfSurface.dwRGBBitCount;
            dwAlphaMask = (pDDSLcl->lpGbl->ddpfSurface.dwFlags & DDPF_ALPHAPIXELS) ?
                           pDDSLcl->lpGbl->ddpfSurface.dwRGBAlphaBitMask : 0;
            dwRedMask   = pDDSLcl->lpGbl->ddpfSurface.dwRBitMask;

            // derive an nv format from the bit count and masks

            if ((dwBitCount == 32) || (dwBitCount == 24)) {
                switch (dwAlphaMask) {
                    case 0x00000000:
#ifdef SPOOF_ALPHA
                        if ((pDDSLcl->ddsCaps.dwCaps & DDSCAPS_3DDEVICE) && !(pDDSLcl->ddsCaps.dwCaps & (DDSCAPS_TEXTURE | DDSCAPS_OFFSCREENPLAIN))) {
                            *pFormat = NV_SURFACE_FORMAT_A8R8G8B8;
                        } else {
                            *pFormat = NV_SURFACE_FORMAT_X8R8G8B8;
                        }

#else
                        *pFormat = NV_SURFACE_FORMAT_X8R8G8B8;
#endif
                        break;
                    case 0x7F000000:
                        *pFormat = NV_SURFACE_FORMAT_X1A7R8G8B8;
                        break;
                    case 0xFF000000:
                        *pFormat = NV_SURFACE_FORMAT_A8R8G8B8;
                        break;
                    default:
                        ERRMSG( "invalid %02ld bpp surface format!! [RGB]" );
                        goto bad_fmt_exit;
                }
                *pBPPRequested = *pBPPGranted = 4;
            }

            else if (dwBitCount == 16) {
                switch (dwAlphaMask) {
                    case 0x00000000:
                        if (dwRedMask == 0x7C00) {
                            *pFormat = NV_SURFACE_FORMAT_X1R5G5B5;
                        }
                        else {
                            // dwRedMask == 0xF800
                            *pFormat = NV_SURFACE_FORMAT_R5G6B5;
                        }
                        break;
                    case 0x00008000:
                        *pFormat = NV_SURFACE_FORMAT_A1R5G5B5;
                        break;
                    case 0x0000F000:
                        *pFormat = NV_SURFACE_FORMAT_A4R4G4B4;
                        break;
                    default:
                        ERRMSG( "invalid 16 bpp surface format!! [RGB]" );
                        goto bad_fmt_exit;
                }
                *pBPPRequested = *pBPPGranted = 2;
            }

            else if ((dwBitCount == 8) && (pDDSLcl->lpGbl->ddpfSurface.dwFlags & DDPF_PALETTEINDEXED8)) {
                *pFormat = NV_SURFACE_FORMAT_I8_A8R8G8B8;  // Indexed format
                *pBPPRequested = *pBPPGranted = 1;
            }

            else {
                ERRMSG( "invalid %02ld bpp surface format!! [fallthru]" );
                goto bad_fmt_exit;
            }

            *bFourCC = FALSE;

        }

        else if (pDDSLcl->lpGbl->ddpfSurface.dwFlags & DDPF_BUMPDUDV) {

            dwBitCount = pDDSLcl->lpGbl->ddpfSurface.dwBumpBitCount;
            dwLumMask  = (pDDSLcl->lpGbl->ddpfSurface.dwFlags & DDPF_BUMPLUMINANCE) ?
                         pDDSLcl->lpGbl->ddpfSurface.dwBumpLuminanceBitMask : 0;

            if (dwBitCount == 16) {
                *pFormat = (dwLumMask == 0) ? NV_SURFACE_FORMAT_DV8DU8 : NV_SURFACE_FORMAT_L6DV5DU5;
                *pBPPRequested = *pBPPGranted = 2;
            }
//            else if (dwBitCount == 24) {
//                *pFormat = NV_SURFACE_FORMAT_X8L8DV8DU8;
//                *pBPPRequested = *pBPPGranted = 3;
//            }
            else if (dwBitCount == 32) {
                *pFormat = NV_SURFACE_FORMAT_X8L8DV8DU8;
                *pBPPRequested = *pBPPGranted = 4;
            } else {
                // Invalid bitdepth
                ERRMSG( "nvCalculateSurfaceParams - invalid Bump map dUdV format!" );
                goto bad_fmt_exit;
            }

            *bFourCC = FALSE;

        }

        else if (pDDSLcl->lpGbl->ddpfSurface.dwFlags & DDPF_FOURCC) {

            // query the fourcc list
            switch (pDDSLcl->lpGbl->ddpfSurface.dwFourCC) {
                case FOURCC_RGB0:
                    // we should handle this case with regular rgb surfaces
                    nvAssert (0);
                    break;
                case FOURCC_NVT0:
                case FOURCC_NVS0:
                    *pFormat = NV_SURFACE_FORMAT_X1R5G5B5;
                    *pBPPRequested = 2;
                    SET_GBL_SURFACE_DATA (pDDSLcl,DDPF_RGB,16,0x7C00,0x03E0,0x001F,0x0000);
                    break;
                case FOURCC_NVT1:
                case FOURCC_NVS1:
                    *pFormat = NV_SURFACE_FORMAT_A1R5G5B5;
                    *pBPPRequested = 2;
                    SET_GBL_SURFACE_DATA (pDDSLcl,(DDPF_RGB|DDPF_ALPHAPIXELS),16,0x7C00,0x03E0,0x001F,0x8000);
                    break;
                case FOURCC_NVT2:
                case FOURCC_NVS2:
                    *pFormat = NV_SURFACE_FORMAT_A4R4G4B4;
                    *pBPPRequested = 2;
                    SET_GBL_SURFACE_DATA (pDDSLcl,(DDPF_RGB|DDPF_ALPHAPIXELS),16,0x0F00,0x00F0,0x000F,0xF000);
                    break;
                case FOURCC_NVT3:
                case FOURCC_NVS3:
                    *pFormat = NV_SURFACE_FORMAT_R5G6B5;
                    *pBPPRequested = 2;
                    SET_GBL_SURFACE_DATA (pDDSLcl,DDPF_RGB,16,0xF800,0x07E0,0x001F,0x0000);
                    break;
                case FOURCC_NVT4:
                case FOURCC_NVS4:
                    *pFormat = NV_SURFACE_FORMAT_X8R8G8B8;
                    *pBPPRequested = 4;
                    SET_GBL_SURFACE_DATA (pDDSLcl,DDPF_RGB,32,0x00FF0000,0x0000FF00,0x000000FF,0x00000000);
                    break;
                case FOURCC_NVT5:
                case FOURCC_NVS5:
                    *pFormat = NV_SURFACE_FORMAT_A8R8G8B8;
                    *pBPPRequested = 4;
                    SET_GBL_SURFACE_DATA (pDDSLcl,(DDPF_RGB|DDPF_ALPHAPIXELS),32,0x00FF0000,0x0000FF00,0x000000FF,0xFF000000);
                    break;
#ifdef TEXFORMAT_CRD // --------------------------------
                case FOURCC_NVHU:
                    *pFormat = NV_SURFACE_FORMAT_HILO_1_V16U16;
                    *pBPPRequested = 4;
                    break;
                case FOURCC_NVHS:
                    *pFormat = NV_SURFACE_FORMAT_HILO_HEMI_V16U16;
                    *pBPPRequested = 4;
                    break;
#else // !TEXFORMAT_CRD  --------------------------------
#if defined(HILO_SUPPORT_DX7) || defined(HILO_SUPPORT_DX8)
                case FOURCC_NVHU:
                    *pFormat = NV_SURFACE_FORMAT_HILO_1_V16U16;
                    *pBPPRequested = 4;
                    break;
                case FOURCC_NVHS:
                    *pFormat = NV_SURFACE_FORMAT_HILO_HEMI_V16U16;
                    *pBPPRequested = 4;
                    break;
#endif
#endif // !TEXFORMAT_CRD  --------------------------------
                case D3DFMT_Q8W8V8U8:
                    *pFormat = NV_SURFACE_FORMAT_A8B8G8R8;
                    *pBPPRequested = 4;
                    break;
                case FOURCC_DXT1:
                    *pFormat = NV_SURFACE_FORMAT_DXT1_A1R5G5B5;
                    *pBPPRequested = 8;
                    bIsDXT = TRUE;
                    break;
                case FOURCC_DXT2:
                case FOURCC_DXT3:
                    *pFormat = NV_SURFACE_FORMAT_DXT23_A8R8G8B8;
                    *pBPPRequested = 16;
                    bIsDXT = TRUE;
                    break;
                case FOURCC_DXT4:
                case FOURCC_DXT5:
                    *pFormat = NV_SURFACE_FORMAT_DXT45_A8R8G8B8;
                    *pBPPRequested = 16;
                    bIsDXT = TRUE;
                    break;
                default:
                    // Invalid pixel format. Return the error.
                    ERRMSG( "nvCalculateSurfaceParams - invalid 4cc format!" );
                    goto bad_fmt_exit;
            }  // switch

            *pBPPGranted = *pBPPRequested;
            *bFourCC = TRUE;

        }

        else if (pDDSLcl->lpGbl->ddpfSurface.dwFlags & DDPF_ZBUFFER) {

            DWORD dwRetVal = nvCalculateZBufferParams (pDDSLcl, pFormat, pWidth, pHeight,
                                                       pMultiSampleBits, pBPPRequested, pBPPGranted, pPitch);
            *pDepth  = 1;
            *bFourCC = FALSE;
            dbgTracePop();
            return (dwRetVal);

        }

        else {

            // we were told we had a pixel format but this is neither fourCC nor RGB nor a zbuffer
            ERRMSG( "formatted surface is neither fourCC nor RGB" );
            goto bad_fmt_exit;
        }

    }

    else {  // !(pDDSLcl->dwFlags & DDRAWISURF_HASPIXELFORMAT)

        // we weren't given any pixel format
        dwBitCount  = GET_MODE_BPP();

        switch (dwBitCount)
        {
            case 8:
                *pFormat = NV_SURFACE_FORMAT_Y8;
                *pBPPRequested = 1;
                break;
            case 16:
                *pFormat = NV_SURFACE_FORMAT_R5G6B5;
                *pBPPRequested = 2;
                break;
            case 24:
            case 32:  // we treat these as synonymous
#ifdef SPOOF_ALPHA
                if ((pDDSLcl->ddsCaps.dwCaps & DDSCAPS_3DDEVICE) && !(pDDSLcl->ddsCaps.dwCaps & (DDSCAPS_TEXTURE | DDSCAPS_OFFSCREENPLAIN))) {
                    *pFormat = NV_SURFACE_FORMAT_A8R8G8B8;
                } else {
                    *pFormat = NV_SURFACE_FORMAT_X8R8G8B8;
                }
#else
                *pFormat = NV_SURFACE_FORMAT_X8R8G8B8;
#endif
                *pBPPRequested = 4;
                break;
            default:
                ERRMSG( "illegal bit depth" );  // maybe do INT3 here?
                goto bad_fmt_exit;
        }

        *pBPPGranted = *pBPPRequested;
        *bFourCC = FALSE;

    }

    // get the width and height

    if (pDDSLcl->ddsCaps.dwCaps & (DDSCAPS_FRONTBUFFER | DDSCAPS_PRIMARYSURFACE | DDSCAPS_VISIBLE)) {
        *pWidth  = GET_MODE_WIDTH();
        *pHeight = GET_MODE_HEIGHT();
        *pDepth  = 1;
    }
    else {
        *pWidth  = bIsDXT ? max (1, (pDDSLcl->lpGbl->wWidth  >> 2))
                          : pDDSLcl->lpGbl->wWidth;
        *pHeight = bIsDXT ? max (1, (pDDSLcl->lpGbl->wHeight >> 2))
                          : pDDSLcl->lpGbl->wHeight;
        // stored in the lower WORD of the dwCaps4
        *pDepth  = bIsDXT ? max (1, ((pDDSLcl->lpSurfMore->ddsCapsEx.dwCaps4 & 0xffff) >> 2))
                          : max (1, pDDSLcl->lpSurfMore->ddsCapsEx.dwCaps4 & 0xffff);
    }

    // calculate pitch
    if (bComputePitch)
    {
        *pPitch = *pBPPGranted * *pWidth;

        // align the pitch if this isn't a system memory surface or a texture
        if (!(pDDSLcl->ddsCaps.dwCaps & DDSCAPS_SYSTEMMEMORY)
         && !(pDDSLcl->ddsCaps.dwCaps & DDSCAPS_TEXTURE))
        {
            *pPitch = (*pPitch + pDriverData->dwSurfaceAlignPad) & ~pDriverData->dwSurfaceAlignPad;
        }

        *pSlicePitch = (*pPitch) * (*pHeight);
    }
    else
    {
        if (bIsDXT) {
            // linear size is given - we recompute pitch here
            *pPitch = (*pWidth) * (*pBPPGranted);
            *pSlicePitch = (*pPitch) * (*pHeight);
        }
        else {
            *pPitch = pDDSLcl->lpGbl->lPitch;
            *pSlicePitch = pDDSLcl->lpGbl->lSlicePitch;
        }
    }

    // Multisampling surfaces
    *pMultiSampleBits = pDDSLcl->lpSurfMore->ddsCapsEx.dwCaps3 & DDSCAPS3_MULTISAMPLE_MASK;

    dbgTracePop();
    return (DD_OK);

// jump to here for bad pixel format
bad_fmt_exit:
#ifdef DEBUG
    nvAssert( pErrMsg != NULL );
    DPF_LEVEL(NVDBG_LEVEL_ERROR, (char*)pErrMsg, dwBitCount);
    // dbgD3DError(); -- let the calling program decide if it wants to throw an INT3
    dbgTracePop();
#endif
    return DDERR_INVALIDPIXELFORMAT;
}

//---------------------------------------------------------------------------

DWORD nvCreateZBuffer (LPDDRAWI_DDRAWSURFACE_LCL pDDSLcl)
{
    DWORD dwFormat, dwWidth, dwHeight, dwMultiSampleBits, dwBPPRequested, dwBPPGranted, dwPitch;

    dbgTracePush ("nvCreateZBuffer");

#ifndef WINNT
    CNvObject         *pNvObj = new CNvObject (pDDSLcl->dwProcessId);
#else
    CNvObject         *pNvObj = new CNvObject (0);
#endif // WINNT
    CSimpleSurface    *pSurf  = new CSimpleSurface;

    if (!pNvObj || !pSurf) {
        if (pNvObj) pNvObj->release();
        if (pSurf ) delete pSurf;
        pDDSLcl->lpGbl->fpVidMem = NULL;
        SET_PNVOBJ (pDDSLcl, NULL);
        dbgTracePop();
        return (DDERR_OUTOFMEMORY);
    }

    pNvObj->setObject (CNvObject::NVOBJ_SIMPLESURFACE, pSurf);

    DWORD dwRV = nvCalculateZBufferParams (pDDSLcl, &dwFormat, &dwWidth, &dwHeight, &dwMultiSampleBits, &dwBPPRequested, &dwBPPGranted, &dwPitch);
    if (dwRV != DD_OK) {
        if (pNvObj) pNvObj->release();
        dbgTracePop();
        return (dwRV);
    }

#ifdef CAPTURE
    if ((getDC()->nvD3DRegistryData.regCaptureEnable & D3D_REG_CAPTUREENABLE_RECORD) &&
        (getDC()->nvD3DRegistryData.regCaptureConfig & D3D_REG_CAPTURECONFIG_ALLOC4X)) {

        CAPTURE_ANNOTATION anno;
        anno.dwJmpCommand         = CAPTURE_JMP_COMMAND;
        anno.dwExtensionSignature = CAPTURE_EXT_SIGNATURE;
        anno.dwExtensionID        = CAPTURE_XID_ANNOTATION;
        anno.dwValue              = CAPTURE_ANNOTATION_ALLOC4X;
        captureLog (&anno, sizeof(anno));

        dwWidth  <<= 1;
        dwHeight <<= 1;
        dwPitch  <<= 1;
    }
#endif

    DWORD dwAllocFlags = (!(pDriverData->nvD3DPerfData.dwNVClasses & NVCLASS_FAMILY_KELVIN))        ?
                         (CSimpleSurface::ALLOCATE_TILED | CSimpleSurface::ALLOCATE_AS_ZBUFFER_UNC) :
                         (CSimpleSurface::ALLOCATE_TILED | CSimpleSurface::ALLOCATE_AS_ZBUFFER_CMP);
#ifdef  STEREO_SUPPORT
    if (pDDSLcl->lpSurfMore->ddsCapsEx.dwCaps2 & DDSCAPS2_STEREOSURFACELEFT
        && STEREO_ENABLED)
    {
		dwAllocFlags |= CSimpleSurface::ALLOCATE_AS_STEREO;
	}
#endif  //STEREO_SUPPORT

    if (pSurf->create (pNvObj, dwFormat, dwWidth, dwHeight, 1,
                       dwMultiSampleBits, dwBPPRequested, dwBPPGranted, dwPitch,
                       CSimpleSurface::HEAP_VID, CSimpleSurface::HEAP_VID,
                       dwAllocFlags

#ifdef CAPTURE
                      ,CAPTURE_SURFACE_KIND_ZETA
#endif
                       ))
    {
        // successful allocation
        SET_PNVOBJ (pDDSLcl, pNvObj);  // BUGBUG does this really work for z buffers?
        pDDSLcl->lpGbl->fpVidMem                      = pSurf->getfpVidMem();
        pDDSLcl->lpGbl->lPitch                        = pSurf->getPitch();
        pDDSLcl->lpGbl->lSlicePitch                   = pSurf->getSlicePitch();
        pDDSLcl->lpGbl->ddpfSurface.dwZBufferBitDepth = dwBPPGranted << 3;
        pDDSLcl->lpGbl->ddpfSurface.dwZBitMask        = (dwBPPGranted==2) ? 0x0000ffff : 0xffffff00;
        pDDSLcl->lpGbl->dwReserved1                   = 0;
        pDDSLcl->ddsCaps.dwCaps                      |= (DDSCAPS_VIDEOMEMORY | DDSCAPS_LOCALVIDMEM);
        pDDSLcl->ddsCaps.dwCaps                      &= ~DDSCAPS_SYSTEMMEMORY;
        pSurf->tagAsOwner();
    }

    else {
        DPF_LEVEL (NVDBG_LEVEL_SURFACE, "Video memory Z buffer surface allocation failed" );
        if (pNvObj) pNvObj->release();
        dbgTracePop();
        return (DDERR_OUTOFVIDEOMEMORY);
    }
#ifdef DEBUG_SURFACE_PLACEMENT
        csd.SetZBuffer(pSurf);
#endif

    dbgTracePop();
    return(DD_OK);

}  // nvCreateZBuffer()

//---------------------------------------------------------------------------

// returns an error code that CreateSurface should return via ->ddRVal

DWORD nvCreateSurfaceWithFormat (LPDDRAWI_DDRAWSURFACE_LCL pDDSLcl,
                                 LPDDRAWI_DIRECTDRAW_GBL pDDGbl, DWORD dwExtraSize, DWORD dwExtraNumSurfaces, DWORD dwBlockHeight)
{
    DWORD dwPitch, dwSlicePitch, dwMultiSampleBits;

    dbgTracePush ("nvCreateSurfaceWithFormat");

    DWORD dwModeBPP = GET_MODE_BPP() >> 3;

    if (pDDSLcl->lpGbl->ddpfSurface.dwFlags & DDPF_ALPHAPREMULT) {

        // BUGBUG needs to be G.U.D.ified someday
        DPF_LEVEL(NVDBG_LEVEL_SURFACE,  "  ALPHA_PREMULT surface requested" );
        dwPitch = pDDSLcl->lpGbl->wWidth * dwModeBPP;
        dwPitch = (dwPitch + pDriverData->dwSurfaceAlignPad) & ~pDriverData->dwSurfaceAlignPad;
        dwSlicePitch = dwPitch * pDDSLcl->lpGbl->wHeight;

        DWORD dwBlockSize = (dwPitch * ((DWORD)pDDSLcl->lpGbl->wHeight));
        pDDSLcl->lpGbl->ddpfSurface.dwRGBBitCount = dwModeBPP << 3;
        pDDSLcl->lpGbl->ddpfSurface.dwRGBAlphaBitMask = 0xFF000000;
        pDDSLcl->lpGbl->ddpfSurface.dwRBitMask = 0x00FF0000;
        pDDSLcl->lpGbl->ddpfSurface.dwGBitMask = 0x0000FF00;
        pDDSLcl->lpGbl->ddpfSurface.dwBBitMask = 0x000000FF;
        pDDSLcl->lpGbl->lPitch = dwPitch;
        pDDSLcl->lpGbl->lSlicePitch = dwSlicePitch;
        pDDSLcl->lpGbl->fpVidMem = 0;
        pDDSLcl->lpGbl->dwReserved1 = 0;

        if (pDDSLcl->ddsCaps.dwCaps & DDSCAPS_VIDEOMEMORY) {

            DWORD dwStatus;
            NVHEAP_ALLOC (dwStatus, pDDSLcl->lpGbl->fpVidMem, dwBlockSize, TYPE_IMAGE);
            if (dwStatus == 0) {
                pDriverData->DDrawVideoSurfaceCount++;
                pDDSLcl->ddsCaps.dwCaps &= ~DDSCAPS_SYSTEMMEMORY;
                pDDSLcl->ddsCaps.dwCaps |= DDSCAPS_LOCALVIDMEM;
            }

        }

        else {
            dbgTracePop();
            return (DDERR_OUTOFMEMORY);
        }

        // if one of these fails, then this code was and is totally broken.
        // it used to just continue on from this if block. i've added the return.
        // as best i can tell. there was nothing preventing us from allocating this
        // surface twice. why would we want to do that?
        assert (!(pDDSLcl->lpGbl->ddpfSurface.dwFlags & DDPF_FOURCC));
        assert (!(pDDSLcl->ddsCaps.dwCaps & DDSCAPS_TEXTURE));
        assert (!(pDDSLcl->ddsCaps.dwCaps & DDSCAPS_ZBUFFER));
        dbgTracePop();
        return (DD_OK);

    }

    if (pDDSLcl->lpGbl->ddpfSurface.dwFlags & DDPF_FOURCC) {

        // BUGBUG needs to be G.U.D.ified someday
        DWORD dwRV = VppCreateFourCCSurface(&(pDriverData->vpp),pDDSLcl, pDDGbl,dwExtraSize, dwExtraNumSurfaces, dwBlockHeight);
        dbgTracePop();
        return (dwRV);

    }

    if (pDDSLcl->ddsCaps.dwCaps & DDSCAPS_OFFSCREENPLAIN) {

        DWORD dwFormat, dwWidth, dwHeight, dwDepth, dwBPPRequested, dwBPPGranted, dwPitch;
        BOOL bFourCC;

#ifndef WINNT
        CNvObject      *pNvObj = new CNvObject (pDDSLcl->dwProcessId);
#else
        CNvObject      *pNvObj = new CNvObject (0);
#endif // WINNT

        CSimpleSurface *pSurf  = new CSimpleSurface;

        if (!pNvObj || !pSurf) {
            if (pNvObj) pNvObj->release();
            if (pSurf ) delete pSurf;
            pDDSLcl->lpGbl->fpVidMem = NULL;
            SET_PNVOBJ (pDDSLcl, NULL);
            dbgTracePop();
            return (DDERR_OUTOFMEMORY);
        }

        pNvObj->setObject (CNvObject::NVOBJ_SIMPLESURFACE, pSurf);

        DWORD dwRV = nvCalculateSurfaceParams (pDDSLcl, &dwFormat, &bFourCC, &dwWidth, &dwHeight, &dwDepth, &dwMultiSampleBits,
                                               &dwBPPRequested, &dwBPPGranted, &dwPitch, &dwSlicePitch, TRUE);
        if (dwRV != DD_OK) {
            dbgD3DError();  // ?? can we get here for legit reasons?
            if (pNvObj) pNvObj->release();
            dbgTracePop();
            return (dwRV);
        }

        // figure out where to stick it
        DWORD dwPreferredHeap, dwAllowedHeaps, dwAllocFlags;

        if (pDDSLcl->ddsCaps.dwCaps & DDSCAPS_NONLOCALVIDMEM) {
            dwPreferredHeap = (pDriverData->GARTLinearBase > 0) ?
                              CSimpleSurface::HEAP_AGP :
                              CSimpleSurface::HEAP_PCI;
            dwAllowedHeaps  = dwPreferredHeap;
            dwAllocFlags    = CSimpleSurface::ALLOCATE_SIMPLE;
        }
        else {
            dwPreferredHeap = CSimpleSurface::HEAP_VID;
            dwAllowedHeaps  = dwPreferredHeap;

            if (pDDSLcl->ddsCaps.dwCaps & DDSCAPS_3DDEVICE) {
                dwAllocFlags = CSimpleSurface::ALLOCATE_TILED;
            }
            else {
                dwAllocFlags = CSimpleSurface::ALLOCATE_SIMPLE;
            }
            // if they haven't demanded video memory, allow fallback to system
            if (!(pDDSLcl->ddsCaps.dwCaps & DDSCAPS_VIDEOMEMORY)) {
                dwAllowedHeaps |= CSimpleSurface::HEAP_SYS;
            }
        }

        if (pSurf->create (pNvObj, dwFormat, dwWidth, dwHeight, dwDepth,
                           dwMultiSampleBits, dwBPPRequested, dwBPPGranted, dwPitch,
                           dwAllowedHeaps, dwPreferredHeap, dwAllocFlags
#ifdef CAPTURE
                          ,CAPTURE_SURFACE_KIND_UNKNOWN
#endif
                           ))
        {
            // allocation succeeded. set stuff in MS-land
            if (pSurf->getHeapLocation() == CSimpleSurface::HEAP_SYS) {
                pDDSLcl->lpGbl->fpVidMem    = (FLATPTR)pSurf->getfpVidMem();
                pDDSLcl->lpGbl->dwReserved1 = (DWORD)pSurf->getfpVidMem();
            }
#ifdef WINNT
            // MS-suggested Hack to make AGP surfaces whose mem was
            // allocated through HeapVidMemAllocAligned work properly
            else if (pSurf->getHeapLocation() == CSimpleSurface::HEAP_AGP) {
#ifdef NV_AGP
                pDDSLcl->lpGbl->fpVidMem = nvAGPGetUserAddr(pSurf->getAddress());
#else
                pDDSLcl->lpGbl->lpVidMemHeap = ppdev->AgpHeap;
                pDDSLcl->lpGbl->fpHeapOffset = pSurf->getfpVidMem() + pDriverData->GARTLinearHeapOffset;
#endif
                pDDSLcl->lpGbl->dwReserved1  = 0;
            }
#endif // WINNT
            else {
                pDDSLcl->lpGbl->fpVidMem    = pSurf->getfpVidMem();
                pDDSLcl->lpGbl->dwReserved1 = 0;
            }
            SET_PNVOBJ (pDDSLcl, pNvObj);
            pDDSLcl->lpGbl->lPitch      = pSurf->getPitch();  // may be different than dwPitch!
            pDDSLcl->lpGbl->lSlicePitch = pSurf->getSlicePitch();
            pDDSLcl->ddsCaps.dwCaps     = pSurf->modifyDDCaps (pDDSLcl->ddsCaps.dwCaps);
            pSurf->tagAsOwner();
        }

        else {
            // surface creation failed
            DPF_LEVEL(NVDBG_LEVEL_SURFACE, "Offscreen surface allocation failed" );
            if (pNvObj) pNvObj->release();
            pDDSLcl->lpGbl->dwReserved1 = 0;
            dbgTracePop();
            return (DDERR_OUTOFVIDEOMEMORY);
        }

        DPF_LEVEL(NVDBG_LEVEL_SURFACE, "Offscreen surface granted" );
        return (DD_OK);
    }

    if (pDDSLcl->ddsCaps.dwCaps & DDSCAPS_ZBUFFER) {

        DWORD dwRV = nvCreateZBuffer (pDDSLcl);
        dbgTracePop();
        return (dwRV);

    }

    DPF ("unknown surface type in nvCreateSurfaceWithFormat");
    dbgD3DError();

    dbgTracePop();
    return (DDERR_UNSUPPORTEDFORMAT);

}  // nvCreateSurfaceWithFormat()

//---------------------------------------------------------------------------
// nvApplicationCheck
//      Does application specific things
//      ***** DO NOT ADD ANY ENTRIES WITHOUT A COMPLETE DESCRIPTION OF THE BUG *****
//      ***** SYMPTOMS AND THE SOLUTION.  THIS MEANS YOU                       *****
void nvApplicationCheck(void)
{
#if 0
#ifndef WINNT
LPTSTR pCmdLine, pExe, pStr;

    // get command line
    pCmdLine = GetCommandLine();

    // strip path and leave the raw executable name
    for (pExe = pCmdLine; *pCmdLine != '\0'; pCmdLine++) {
        if (*pCmdLine == '\\' || *pCmdLine == ':') {
            pExe = pCmdLine + 1;
        }
    }

    // early string termination if quote, space, or control character is detected
    for (pStr = pExe; *pStr != '\0'; pStr++) {
        if (*pStr == '\"' || *pStr < ' ') {
            *pStr = '\0';
        }
    }

    // ------------------------
    // Rainbow Six: Rogue Spear
    //      This app thrashes blit context DMAs, so blit code wants to fall back to old
    //      blit code for performance reasons.  However, old blit code has a bug in it
    //      (if you want to fix it, you obviously have not seen the old fallback code)
    //      and text is corrupted.  The end of each scan line is not correctly fed into
    //      the image_from_cpu class.  The fix is to detect this app, and let it thrash.
    //      It will be slower, but at least it will work.  See code in nvBlit.cpp.
    //      --- slum
    if (nvStrCmp(pExe, "RogueSpear.exe")==0) {
        pDriverData->bltData.dwLetItThrash = TRUE;
    }
#endif
#endif
}

//---------------------------------------------------------------------------
//
// returns an error code that CreateSurface should return via ->ddRVal
//
// called only from one place in CreateSurface32()

DWORD nvCreateSurfaceWithoutFormat (LPDDRAWI_DDRAWSURFACE_LCL pDDSLcl,
                                    LPDDRAWI_DIRECTDRAW_GBL pDDGbl)
{
    dbgTracePush ("nvCreateSurfaceWithoutFormat");

    DWORD dwModeBPP = GET_MODE_BPP() >> 3;

    // create the basic objects
#ifdef WINNT
    CNvObject      *pNvObj = new CNvObject (0);
#else // !WINNT
    CNvObject      *pNvObj = new CNvObject (pDDSLcl->dwProcessId);
#endif // !WINNT

    CSimpleSurface *pSurf  = new CSimpleSurface;

    if (!pNvObj || !pSurf) {
        if (pNvObj) pNvObj->release();
        if (pSurf ) delete pSurf;
        pDDSLcl->lpGbl->fpVidMem = NULL;
        SET_PNVOBJ (pDDSLcl, NULL);
        dbgTracePop();
        return (DDERR_OUTOFMEMORY);
    }

    pNvObj->setObject (CNvObject::NVOBJ_SIMPLESURFACE, pSurf);

    // determine common surface parameters
    DWORD dwFormat, dwWidth, dwHeight, dwDepth, dwBPPRequested, dwBPPGranted, dwPitch, dwSlicePitch, dwMultiSampleBits;
    BOOL  bFourCC;

    DWORD dwRV = nvCalculateSurfaceParams (pDDSLcl, &dwFormat, &bFourCC, &dwWidth, &dwHeight, &dwDepth, &dwMultiSampleBits,
                                           &dwBPPRequested, &dwBPPGranted, &dwPitch, &dwSlicePitch, TRUE);

    if (dwRV != DD_OK) {
        dbgD3DError();  // ?? can we get here for legit reasons?
        if (pNvObj) pNvObj->release();
        dbgTracePop();
        return (dwRV);
    }

    // handle surface specifics according to type
    if (pDDSLcl->ddsCaps.dwCaps & (DDSCAPS_FRONTBUFFER | DDSCAPS_PRIMARYSURFACE | DDSCAPS_VISIBLE)) {

        nvApplicationCheck();

        // Must allow primary surface access even if not correct pixel depth for 3D
        // Fixes Jedi Knight bug
        if ((pDDSLcl->ddsCaps.dwCaps & DDSCAPS_3DDEVICE) &&
            (!(pDDSLcl->ddsCaps.dwCaps & DDSCAPS_PRIMARYSURFACE))) {
            if (dwModeBPP == 1) {
                pNvObj->release();
                dbgTracePop();
                return (DDERR_INVALIDPIXELFORMAT);
            }
        }

#ifdef WINNT
        ppdev->bD3DappIsRunning = TRUE;
        dwPitch = ppdev->lDelta;
#else // !WINNT
        // override pitch determined above with the pitch that's
        // been rounded up to account for tiling
        dwPitch = ((DIBENGINEHDR1 *)pDXShare->pFlatDibeng)->deDeltaScan;
#endif // !WINNT

#ifdef DEBUG
        dbgPrimaryPitch  = dwPitch;
        dbgPrimaryHeight = dwHeight;
        dbgPrimaryBPP    = dwBPPGranted;
#endif

#ifndef WINNT
        if (pDXShare->pNvPrimarySurf) {
            // some other context has already created an NvObject for this primary
            // delete the new objects we just created
            pNvObj->release();

            // assign pointers to the old objects
            pNvObj = (CNvObject*)pDXShare->pNvPrimarySurf;
            pSurf = pNvObj->getSimpleSurface();
        } else {
            // use the new pNvObject
            pDXShare->pNvPrimarySurf = (DWORD)pNvObj;
        }
#endif // !WINNT

#ifdef  STEREO_SUPPORT
        pSurf->destroyStereo();
#endif  //STEREO_SUPPORT

        pSurf->own (VIDMEM_ADDR(GET_PRIMARY_ADDR()), dwPitch, dwHeight, CSimpleSurface::HEAP_VID, FALSE);
        pSurf->setWrapper (pNvObj);
        pSurf->setFormat (dwFormat);
        pSurf->setWidth (dwWidth);
        pSurf->setBPP (dwBPPGranted);
        pSurf->setBPPRequested (dwBPPRequested);
        pSurf->setDepth(dwDepth);

#ifdef DEBUG_SURFACE_PLACEMENT
        csd.SetFrontBuffer(pSurf);
#endif
        // set stuff back in MS-land as well
        SET_PNVOBJ (pDDSLcl, pNvObj);
        pDDSLcl->lpGbl->fpVidMem    = GET_PRIMARY_ADDR();
        pDDSLcl->lpGbl->lPitch      = dwPitch;
        pDDSLcl->lpGbl->lSlicePitch = dwSlicePitch;
        pDDSLcl->lpGbl->dwReserved1 = 0;
        pDDSLcl->ddsCaps.dwCaps    |= (DDSCAPS_VIDEOMEMORY | DDSCAPS_LOCALVIDMEM);

#ifdef  STEREO_SUPPORT
		if (STEREO_ENABLED)
		{				
			CreateLockSubstitute(pDDSLcl);
			if (!pSurf->createStereo ())
			{
				LOG("Can't create a stereo rendering surface");
			}
		}
#endif  //STEREO_SUPPORT

        DPF_LEVEL(NVDBG_LEVEL_SURFACE, "front buffer granted" );

        // we need to tell displaydriver that a PRIMARY surface was acquired
        NV_OGLDDRAWSURFACECREATED( ppdev );

    }

    else if (pDDSLcl->ddsCaps.dwCaps & (DDSCAPS_BACKBUFFER | DDSCAPS_FLIP)) {

        // make sure we come up with the same value we used to...
        nvAssert (dwWidth  == (DWORD)GET_MODE_WIDTH());
        nvAssert (dwHeight == (DWORD)GET_MODE_HEIGHT());
        nvAssert (dwBPPRequested == dwModeBPP);

#ifdef CAPTURE
        if ((getDC()->nvD3DRegistryData.regCaptureEnable & D3D_REG_CAPTUREENABLE_RECORD) &&
            (getDC()->nvD3DRegistryData.regCaptureConfig & D3D_REG_CAPTURECONFIG_ALLOC4X)) {

            CAPTURE_ANNOTATION anno;
            anno.dwJmpCommand         = CAPTURE_JMP_COMMAND;
            anno.dwExtensionSignature = CAPTURE_EXT_SIGNATURE;
            anno.dwExtensionID        = CAPTURE_XID_ANNOTATION;
            anno.dwValue              = CAPTURE_ANNOTATION_ALLOC4X;
            captureLog (&anno, sizeof(anno));

            dwWidth  <<= 1;
            dwHeight <<= 1;
            dwPitch  <<= 1;
        }
#endif

		DWORD	dwAllocFlags = CSimpleSurface::ALLOCATE_TILED;
#ifdef  STEREO_SUPPORT
		if (pDDSLcl->lpSurfMore->ddsCapsEx.dwCaps2 & DDSCAPS2_STEREOSURFACELEFT
			&& STEREO_ENABLED)
		{
			dwAllocFlags |= CSimpleSurface::ALLOCATE_AS_STEREO;
		}
#endif  //STEREO_SUPPORT
        if (pSurf->create (pNvObj, dwFormat, dwWidth, dwHeight, dwDepth,
                           dwMultiSampleBits, dwBPPRequested, dwBPPGranted, dwPitch,
                           CSimpleSurface::HEAP_VID, CSimpleSurface::HEAP_VID,
                           dwAllocFlags
#ifdef CAPTURE
                          ,CAPTURE_SURFACE_KIND_TARGET
#endif
                           ))
        {
            // set stuff in MS-land
            SET_PNVOBJ (pDDSLcl, pNvObj);
            pDDSLcl->lpGbl->fpVidMem = pSurf->getfpVidMem();
            pDDSLcl->lpGbl->lPitch   = pSurf->getPitch();
            pDDSLcl->lpGbl->lSlicePitch   = pSurf->getSlicePitch();
            pDDSLcl->ddsCaps.dwCaps |= (DDSCAPS_VIDEOMEMORY | DDSCAPS_LOCALVIDMEM);
            pDDSLcl->ddsCaps.dwCaps &= ~DDSCAPS_SYSTEMMEMORY;
            pSurf->tagAsOwner();
        }

        else {
            DPF_LEVEL(NVDBG_LEVEL_SURFACE, "Backbuffer or flippable video memory surface allocation failed" );
            if(pNvObj) pNvObj->release();
            dbgTracePop();
            return (DDERR_OUTOFVIDEOMEMORY);
        }

#ifdef DEBUG_SURFACE_PLACEMENT
        csd.SetBackBuffer(pSurf);
#endif
        DPF_LEVEL(NVDBG_LEVEL_SURFACE, "Back buffer or flip surface granted" );

    }

    else if (pDDSLcl->ddsCaps.dwCaps & DDSCAPS_OFFSCREENPLAIN) {

        putInOffscreen:

        // make sure we come up with the same value we used to...
        nvAssert (dwWidth == (DWORD)pDDSLcl->lpGbl->wWidth);
        nvAssert (dwHeight == (DWORD)pDDSLcl->lpGbl->wHeight);
        nvAssert (dwBPPRequested == dwModeBPP);

        // figure out where to stick it

        DWORD dwPreferredHeap, dwAllowedHeaps, dwAllocFlags;

        if (pDDSLcl->ddsCaps.dwCaps & DDSCAPS_NONLOCALVIDMEM) {
            dwPreferredHeap = (pDriverData->GARTLinearBase > 0) ?
                              CSimpleSurface::HEAP_AGP :
                              CSimpleSurface::HEAP_PCI;
            dwAllowedHeaps  = dwPreferredHeap;
            dwAllocFlags    = CSimpleSurface::ALLOCATE_SIMPLE;
        }

        else {
            dwPreferredHeap = CSimpleSurface::HEAP_VID;
            dwAllowedHeaps  = dwPreferredHeap;

            if (pDDSLcl->ddsCaps.dwCaps & DDSCAPS_3DDEVICE) {
                dwAllocFlags = CSimpleSurface::ALLOCATE_TILED;
            }
            else {
                dwAllocFlags = CSimpleSurface::ALLOCATE_SIMPLE;
            }
            // if they haven't demanded video memory, allow fallback to system
            if (!(pDDSLcl->ddsCaps.dwCaps & DDSCAPS_VIDEOMEMORY)) {
                dwAllowedHeaps |= CSimpleSurface::HEAP_SYS;
            }
        }

        if (pSurf->create (pNvObj, dwFormat, dwWidth, dwHeight, dwDepth,
                           dwMultiSampleBits, dwBPPRequested, dwBPPGranted, dwPitch,
                           dwAllowedHeaps, dwPreferredHeap, dwAllocFlags
#ifdef CAPTURE
                          ,CAPTURE_SURFACE_KIND_UNKNOWN
#endif
                           ))
        {
            // allocation succeeded. set stuff in MS-land
            if (pSurf->getHeapLocation() == CSimpleSurface::HEAP_SYS) {
                pDDSLcl->lpGbl->fpVidMem    = (FLATPTR)pSurf->getfpVidMem();
                pDDSLcl->lpGbl->dwReserved1 = (DWORD)pSurf->getfpVidMem();
            }
#ifdef WINNT
            // MS-suggested Hack to make AGP surfaces whose mem was
            // allocated through HeapVidMemAllocAligned work properly
            else if (pSurf->getHeapLocation() == CSimpleSurface::HEAP_AGP) {
#ifdef NV_AGP
                pDDSLcl->lpGbl->fpVidMem     = nvAGPGetUserAddr(pSurf->getAddress());
#else
                pDDSLcl->lpGbl->lpVidMemHeap = ppdev->AgpHeap;
                pDDSLcl->lpGbl->fpHeapOffset = pSurf->getfpVidMem() + pDriverData->GARTLinearHeapOffset;
#endif
                pDDSLcl->lpGbl->dwReserved1 = 0;
            }
#endif // WINNT
            else {
                pDDSLcl->lpGbl->fpVidMem    = pSurf->getfpVidMem();
                pDDSLcl->lpGbl->dwReserved1 = 0;
            }
            SET_PNVOBJ (pDDSLcl, pNvObj);
            pDDSLcl->lpGbl->lPitch  = pSurf->getPitch();  // may be different than dwPitch!
            pDDSLcl->lpGbl->lSlicePitch = pSurf->getSlicePitch();  // may be different than dwPitch!
            pDDSLcl->ddsCaps.dwCaps = pSurf->modifyDDCaps (pDDSLcl->ddsCaps.dwCaps);
            pSurf->tagAsOwner();
        }

        else {
            // surface creation failed
            DPF_LEVEL(NVDBG_LEVEL_SURFACE, "Offscreen surface allocation failed" );
            pDDSLcl->lpGbl->dwReserved1 = 0;
            if (pNvObj) pNvObj->release();
            dbgTracePop();
            return (DDERR_OUTOFVIDEOMEMORY);
        }

        DPF_LEVEL(NVDBG_LEVEL_SURFACE, "Offscreen surface granted" );

    }

    else if (pDDSLcl->ddsCaps.dwCaps & DDSCAPS_SYSTEMMEMORY) {

        // make sure we come up with the same value we used to...
        nvAssert (dwWidth == (DWORD)pDDSLcl->lpGbl->wWidth);
        nvAssert (dwHeight == (DWORD)pDDSLcl->lpGbl->wHeight);
        nvAssert (dwBPPRequested == dwModeBPP);

        if (pSurf->create (pNvObj, dwFormat, dwWidth, dwHeight, dwDepth,
                           dwMultiSampleBits, dwBPPRequested, dwBPPGranted, dwPitch,
                           CSimpleSurface::HEAP_SYS, CSimpleSurface::HEAP_SYS,
                           CSimpleSurface::ALLOCATE_SIMPLE
#ifdef CAPTURE
                          ,CAPTURE_SURFACE_KIND_UNKNOWN
#endif
                           ))
        {
            // set stuff in MS-land
            SET_PNVOBJ (pDDSLcl, pNvObj);
            pDDSLcl->lpGbl->fpVidMem    = (FLATPTR)pSurf->getfpVidMem();
            pDDSLcl->lpGbl->dwReserved1 = (DWORD)pSurf->getfpVidMem();
            pDDSLcl->lpGbl->lPitch      = pSurf->getPitch();
            pDDSLcl->lpGbl->lSlicePitch      = pSurf->getSlicePitch();
            pSurf->tagAsOwner();
        }

        else {
            DPF_LEVEL(NVDBG_LEVEL_SURFACE, "System memory surface allocation failed" );
            if(pNvObj) pNvObj->release();
            dbgTracePop();
            return (DDERR_OUTOFMEMORY);
        }

        DPF_LEVEL(NVDBG_LEVEL_SURFACE, "System memory surface granted" );

    }

    else if (pDDSLcl->ddsCaps.dwCaps & DDSCAPS_VIDEOMEMORY) {

        goto putInOffscreen;

    }

    dbgTracePop();
    return (DD_OK);

}  // nvCreateSurfaceWithoutFormat ()

#ifdef  NEW_FRONT_RENDER
//This mechanism doesn't work for triple buffering and is intended for debugging only.
FLATPTR BackVidMem;
CNvObject *pBackNvObj;
#endif  //NEW_FRONT_RENDER

//---------------------------------------------------------------------------

// CreateSurface32
// Create a Direct Draw surface.

DWORD __stdcall CreateSurface32 (LPDDHAL_CREATESURFACEDATA lpCSData)
{
    dbgTracePush ("CreateSurface32");
    if (lpCSData->lplpSList[0]->ddsCaps.dwCaps & DDSCAPS_EXECUTEBUFFER )
    {
        //silly hack for screwed up kernel calls
        DWORD dwRetVal;
        dwRetVal = D3DCreateExecuteBuffer32(lpCSData);
        dbgTracePop();
        return dwRetVal;
    }

    DDSTARTTICK(SURF4_CREATESURFACE);

    LPDDRAWI_DIRECTDRAW_GBL pDDGbl = lpCSData->lpDD;
    nvSetDriverDataPtrFromDDGbl (pDDGbl);

    if (pDriverData->dwFullScreenDOSStatus & (FSDOSSTATUS_RECOVERYNEEDED_D3D | FSDOSSTATUS_RECOVERYNEEDED_DDRAW)) {
        if (pDriverData->dwFullScreenDOSStatus & FSDOSSTATUS_COMPLETE) {
            if (pDriverData->dwFullScreenDOSStatus & FSDOSSTATUS_RECOVERYNEEDED_D3D) {
                nvD3DRecover();
            }
            if (pDriverData->dwFullScreenDOSStatus & FSDOSSTATUS_RECOVERYNEEDED_DDRAW) {
                nvDDrawRecover();
            }
        }
    }
    
    // Reset NV and get the monitor frequency after a mode reset
    if (getDC()->dwEnableStatus != CDriverContext::DC_ENABLESTATUS_ENABLED) {
        if (!nvEnable32 (lpCSData->lpDD)) {
            DDENDTICK(SURF4_CREATESURFACE);
            NvReleaseSemaphore(pDriverData);
            lpCSData->ddRVal = DDERR_OUTOFMEMORY;
            dbgTracePop();
            return DDHAL_DRIVER_HANDLED;
        }
    }

    // NOTES:
    // This callback is invoked once the surface objects have been created.
    // You can:
    //   - compute the size of the block, by returning
    //     DDHAL_PLEASEALLOC_BLOCKSIZE in fpVidMem, and putting the size
    //     in dwBlockSizeX and dwBlockSizeY
    //   - override some fields in the surface structure, like the pitch.
    //     (you must specify the pitch if you are computing the size)

    DPF_LEVEL (NVDBG_LEVEL_SURFACE_ACTIVITY,
               "CreateSurface: lpCSData->lplpSList = %08x, lpCSData->dwSCnt = %d",
               lpCSData->lplpSList, lpCSData->dwSCnt);

    // see if any of these surfaces are FOURCC codes...
//    pmAddProcess(pDriverData, GetCurrentProcessId());

    // get first surface
    LPDDRAWI_DDRAWSURFACE_LCL pDDSLcl = lpCSData->lplpSList[0];

    // can overlay be created in this mode?  Need to call this before nvCSCalcExtraSpace
    if (IS_OVERLAY(pDDSLcl->ddsCaps.dwCaps, pDDSLcl->lpGbl->ddpfSurface.dwFourCC)) {

        // Disable dual view for video overlay
#ifdef WINNT
        if ((ppdev->ulDesktopMode & NV_TWO_DACS) &&
           !(ppdev->TwinView_State == NVTWINVIEW_STATE_CLONE &&
            (pDriverData->vpp.regOverlayMode2 & NV4_REG_OVL_MODE2_FSDEVICEMASK)) &&
           !(pDriverData->vpp.regOverlayMode3 & NV4_REG_OVL_MODE3_ALLOWOVL))
#else
        if (pDriverData->dwHeads > 1 &&
            pDriverData->dwDesktopState == NVTWINVIEW_STATE_CLONE &&
           (pDriverData->vpp.regOverlayMode2 & NV4_REG_OVL_MODE2_FSDEVICEMASK) == 0 &&
          !(pDriverData->vpp.regOverlayMode3 & NV4_REG_OVL_MODE3_ALLOWOVL))
#endif
        {
            lpCSData->ddRVal = DDERR_NOOVERLAYHW;
            DDENDTICK(SURF4_CREATESURFACE);
            NvReleaseSemaphore(pDriverData);
            dbgTracePop();
            return (DDHAL_DRIVER_HANDLED);
        }

        if (pDriverData->dwFullScreenDOSStatus & FSDOSSTATUS_RECOVERYNEEDED_DDRAW) {
            if (pDriverData->dwFullScreenDOSStatus & FSDOSSTATUS_COMPLETE) {
                nvDDrawRecover();
            }
            else {
                // deny overlay creation if we are in a full screen DOS box (because we need the draw engine)
                lpCSData->ddRVal = DDERR_NOOVERLAYHW;
                DDENDTICK(SURF4_CREATESURFACE);
                NvReleaseSemaphore(pDriverData);
                dbgTracePop();
                return (DDHAL_DRIVER_HANDLED);
            }
        }

        if (VppGetVideoScalerBandwidthStatus(&pDriverData->vpp,pDDSLcl->lpGbl->wWidth) == FALSE) {
            // deny overlay creation if not enough video memory bandwidth
            lpCSData->ddRVal = DDERR_NOOVERLAYHW;
            DDENDTICK(SURF4_CREATESURFACE);
            NvReleaseSemaphore(pDriverData);
            dbgTracePop();
            return (DDHAL_DRIVER_HANDLED);
        }

        // Reset flag indicating whether overlay has ever been in Bob mode.
        pDriverData->dwDXVAFlags &= ~DXVA_OVERLAY_WAS_BOBBED;

        // If this create is for an NV12 surface, limit the number of buffers
        // depending on frame buffer size and TwinView state, to leave room
        // for Video Mirror.
        if (pDDSLcl->lpGbl->ddpfSurface.dwFourCC == FOURCC_NV12) {
            DWORD   dwMaxAllowed;

            // For 16MB frame buffers...
            if (pDriverData->TotalVRAM < 0x2000000) {

                if((pDriverData->dwDesktopState == NVTWINVIEW_STATE_DUALVIEW) ||
                    (pDriverData->dwDesktopState == NVTWINVIEW_STATE_CLONE))
                    dwMaxAllowed = 4;
                else
                    dwMaxAllowed = 6;
            }

            // For 32MB frame buffers...
            else {

                if((pDriverData->dwDesktopState == NVTWINVIEW_STATE_DUALVIEW) ||
                    (pDriverData->dwDesktopState == NVTWINVIEW_STATE_CLONE))
                    dwMaxAllowed = 7;
                else
                    dwMaxAllowed = 8;
            }

            // If number of buffers requested is more than this, return error.
            if (lpCSData->dwSCnt > dwMaxAllowed) {
                lpCSData->ddRVal = DDERR_OUTOFMEMORY;
                DDENDTICK(SURF4_CREATESURFACE);
                NvReleaseSemaphore(pDriverData);
                dbgTracePop();
                return (DDHAL_DRIVER_HANDLED);
            }
        }
    }

    // check to see if the set of surfaces being created is the primary flip chain
    BOOL bPrimaryFlipChain = lpCSData->dwSCnt
                          && (lpCSData->lplpSList[0]->ddsCaps.dwCaps & DDSCAPS_PRIMARYSURFACE)
                          && (lpCSData->lplpSList[0]->ddsCaps.dwCaps & DDSCAPS_FLIP);

#if (NVARCH >= 0x04) && defined(HWFLIP)

    // set up HW support for flipping
    if (bPrimaryFlipChain) {
        if (lpCSData->dwSCnt > 2) {
            // in the triple buffered case, we may still have a v-blank outstanding, which causes a race
            // condition between the increment read (on processing the v-blank) and the SetRWM below.
            // wait for the last v-blank here to prevent this

            // flush out all but one v-blank
            WaitForIdle(TRUE, FALSE);

            // get the current v-blank count
            NV_CFGEX_VBLANK_COUNTER_MULTI_PARAMS nvVBCounter;
            nvVBCounter.Head = GET_CURRENT_HEAD();
            NvRmConfigGetEx(pDriverData->dwRootHandle, NV_WIN_DEVICE, NV_CFGEX_VBLANK_COUNTER_MULTI,
                &nvVBCounter, sizeof(nvVBCounter));

            // wait for one more v-blank
            DWORD dwFirstCount = nvVBCounter.VBlankCounter;
            do {
                NvRmConfigGetEx(pDriverData->dwRootHandle, NV_WIN_DEVICE, NV_CFGEX_VBLANK_COUNTER_MULTI,
                    &nvVBCounter, sizeof(nvVBCounter));
            } while (nvVBCounter.VBlankCounter == dwFirstCount);
        }
#if (NVARCH >= 0x020) && defined(KELVIN_SEMAPHORES)
        if ((pDriverData->nvD3DPerfData.dwNVClasses  & NVCLASS_FAMILY_KELVIN)   &&
            (pDriverData->nvD3DPerfData.dwNVClasses  & NVCLASS_007C_DAC)        &&
            (pDriverData->nvD3DPerfData.dwNVClasses1 & NVCLASS1_206E_CHANNELDMA))
        {
            getDC()->nvFlipper.init (lpCSData->dwSCnt);
        }
        else if (pDriverData->nvD3DPerfData.dwNVClasses & (NVCLASS_1196_CELSIUS | NVCLASS_0096_CELSIUS)) {
            DPF_LEVEL (NVDBG_LEVEL_SURFACE, "Setting number of surfaces in primary flip chain to %d", lpCSData->dwSCnt);
            nvglSetNv15CelsiusSyncSetRWM (NV_DD_CELSIUS, 0, 1, lpCSData->dwSCnt)
        }
#elif (NVARCH >= 0x020)
        if (pDriverData->nvD3DPerfData.dwNVClasses & (NVCLASS_1196_CELSIUS | NVCLASS_0096_CELSIUS | NVCLASS_FAMILY_KELVIN)) {
            DPF_LEVEL (NVDBG_LEVEL_SURFACE, "Setting number of surfaces in primary flip chain to %d", lpCSData->dwSCnt);
            nvglSetNv15CelsiusSyncSetRWM (NV_DD_CELSIUS, 0, 1, lpCSData->dwSCnt)
        }
#elif (NVARCH >= 0x010)
        if (pDriverData->nvD3DPerfData.dwNVClasses & (NVCLASS_1196_CELSIUS | NVCLASS_0096_CELSIUS)) {
            DPF_LEVEL (NVDBG_LEVEL_SURFACE, "Setting number of surfaces in primary flip chain to %d", lpCSData->dwSCnt);
            nvglSetNv15CelsiusSyncSetRWM (NV_DD_CELSIUS, 0, 1, lpCSData->dwSCnt)
        }
#endif
    }

#endif  // HWFLIP

    // figure out how much extra space is required for video post processing
    // dwExtraSize is the size of one workspace surface, for NV4/5 we need 4,
    // for NV10 we need 3
    DWORD dwExtraSize, dwExtraNumSurfaces, dwBlockHeight;
    LPDDHALINFO pHalInfo = GET_HALINFO();
    VppCalcExtraSurfaceSpace(&(pDriverData->vpp), pDDSLcl, pHalInfo->vmiData.dwDisplayHeight, lpCSData->dwSCnt, &dwExtraSize, &dwExtraNumSurfaces, &dwBlockHeight);

    for (int i = 0; i < int(lpCSData->dwSCnt); i++) {

        BOOL bRealSurface = FALSE;

        // traversing SList in the reverse order ensures that we use one of the two faster
        // memory banks in triple buffer, render to front buffer only tests
        pDDSLcl = lpCSData->lplpSList[bPrimaryFlipChain ? (lpCSData->dwSCnt - i - 1) : i];

#ifdef  STEREO_SUPPORT
        nvAssert((pDDSLcl->lpSurfMore->ddsCapsEx.dwCaps2 & DDSCAPS2_STEREOSURFACELEFT) == 0);
        pDDSLcl->lpSurfMore->ddsCapsEx.dwCaps2 &= ~DDSCAPS2_STEREOSURFACELEFT;
        if (STEREO_ENABLED)
        {
            if (bPrimaryFlipChain || pDDSLcl->ddsCaps.dwCaps &
               (DDSCAPS_BACKBUFFER | DDSCAPS_PRIMARYSURFACE | DDSCAPS_ZBUFFER))
            {
                //We will emulate the stereo bit for internal use. Will clear it on exit.
                pDDSLcl->lpSurfMore->ddsCapsEx.dwCaps2 |= DDSCAPS2_STEREOSURFACELEFT;
            }
        }
#endif  //STEREO_SUPPORT

        if (global.dwDXRuntimeVersion < 0x0700) {
            DPF_LEVEL(NVDBG_LEVEL_SURFACE_ACTIVITY, "CreateSurface: pDDGbl = %08x, pDDSLcl = %08x", pDDGbl, pDDSLcl);
        } else {
            DPF_LEVEL(NVDBG_LEVEL_SURFACE_ACTIVITY, "CreateSurface: pDDGbl = %08x, pDDSLcl = %08x, handle = %02x",
                      pDDGbl, pDDSLcl, pDDSLcl->lpSurfMore->dwSurfaceHandle);
        }

        if (pDDSLcl->ddsCaps.dwCaps & DDSCAPS_TEXTURE) {
            DPF_LEVEL(NVDBG_LEVEL_SURFACEALLOC,"Texture Create:");
            lpCSData->ddRVal = nvTextureCreateSurface (pDDSLcl, pDDGbl, lpCSData->lpDDSurfaceDesc);
        }

        else if (pDDSLcl->dwFlags & DDRAWISURF_HASPIXELFORMAT) {
            DPF_LEVEL(NVDBG_LEVEL_SURFACEALLOC,"Surface With Format:");
            lpCSData->ddRVal = nvCreateSurfaceWithFormat (pDDSLcl, pDDGbl, dwExtraSize, dwExtraNumSurfaces, dwBlockHeight);
            bRealSurface     = TRUE;
        }

        else {
            DPF_LEVEL(NVDBG_LEVEL_SURFACEALLOC,"Surface Without Format:");
            lpCSData->ddRVal = nvCreateSurfaceWithoutFormat (pDDSLcl, pDDGbl);
            bRealSurface     = TRUE;
        }

#if (NVARCH >= 0x010)
        if (bRealSurface && (global.dwDXRuntimeVersion >= 0x0700)) {
            // If we have forced aa on, then dont return error here.  Simply continue without aa
            if (!nvCelsiusAACanCreate(pDDSLcl) && !(pDriverData->nvD3DRegistryData.regD3DEnableBits1 & D3D_REG_ANTIALIASFORCEENABLE_MASK))
            {
                lpCSData->ddRVal = DDERR_OUTOFVIDEOMEMORY;
                DPF("CreateSurface32: cannot create AA buffers");
            }
        }
#endif  // NVARCH >= 0x010

        if (global.dwDXRuntimeVersion < 0x0700)
        {
            // For DX6 runtime we're going to have to keep a pointer to a Local structure.
            // We will reuse the Object->Handle which isn't used in DX6.
            CNvObject *pNvObj = GET_PNVOBJ (pDDSLcl);
            // if this a surface that hasn't yet been G.U.D.ified, we won't have an NvObject for it
            if (IS_VALID_PNVOBJ(pNvObj)) {
                pNvObj->setHandle ((DWORD)pDDSLcl);
            }
        }

#ifdef  STEREO_SUPPORT
        pDDSLcl->lpSurfMore->ddsCapsEx.dwCaps2 &= ~DDSCAPS2_STEREOSURFACELEFT;
#endif  //STEREO_SUPPORT

        if (IS_OVERLAY(pDDSLcl->ddsCaps.dwCaps, pDDSLcl->lpGbl->ddpfSurface.dwFourCC)) {
            // overlay has succeeded, enable VPP
            if (i == 0 && !VppCreateOverlay(&pDriverData->vpp)) {
                lpCSData->ddRVal = DDERR_GENERIC;
            }
        }

        if (lpCSData->ddRVal != DD_OK) {
            if (IS_OVERLAY(pDDSLcl->ddsCaps.dwCaps, pDDSLcl->lpGbl->ddpfSurface.dwFourCC)) {
                VppDestroyOverlay(&pDriverData->vpp);
            }
#ifdef DEBUG
            switch (lpCSData->ddRVal) {
                case DDERR_OUTOFMEMORY:
                    DPF("CreateSurface32: Out of memory");
                    break;
                case DDERR_OUTOFVIDEOMEMORY:
                    DPF("CreateSurface32: Out of video memory");
                    break;
                default:
                    DPF("CreateSurface32: Encountered error %x", lpCSData->ddRVal);
                    break;
            }
#endif

            // roll back the allocations that succeeded
            DDHAL_DESTROYSURFACEDATA ddDSData;
            ddDSData.lpDD = lpCSData->lpDD;
            for (i=i-1; i>=0; i--) {
                ddDSData.lpDDSurface = lpCSData->lplpSList[bPrimaryFlipChain ? (lpCSData->dwSCnt - i - 1) : i];
                DestroySurface32 (&ddDSData);
            }

            NvReleaseSemaphore(pDriverData);
            dbgTracePop();
            return (DDHAL_DRIVER_HANDLED);
        }
    }

#ifdef CAPTURE
    if (getDC()->nvD3DRegistryData.regCaptureEnable & D3D_REG_CAPTUREENABLE_RECORD) {
        if (bPrimaryFlipChain) {
            CAPTURE_FLIP_CHAIN chain;
            chain.dwJmpCommand         = CAPTURE_JMP_COMMAND;
            chain.dwExtensionSignature = CAPTURE_EXT_SIGNATURE;
            chain.dwExtensionID        = CAPTURE_XID_FLIP_CHAIN;
            chain.dwCount              = lpCSData->dwSCnt;
            captureLog (&chain, sizeof(chain));
            for (DWORD ii=0; ii<lpCSData->dwSCnt; ii++) {
                pDDSLcl = lpCSData->lplpSList[lpCSData->dwSCnt - ii - 1];
                DWORD dwSurfOffset = (GET_PNVOBJ(pDDSLcl))->getSimpleSurface()->getOffset();
                captureLog (&dwSurfOffset, sizeof(DWORD));
            }
        }
    }
#endif

#ifdef  NEW_FRONT_RENDER
    if (bPrimaryFlipChain) {
        if (lpCSData->dwSCnt == 2) {
            BackVidMem = lpCSData->lplpSList[1]->lpGbl->fpVidMem;
            pBackNvObj = GET_PNVOBJ (lpCSData->lplpSList[1]);
            lpCSData->lplpSList[1]->lpGbl->fpVidMem = lpCSData->lplpSList[0]->lpGbl->fpVidMem;
            SET_PNVOBJ(lpCSData->lplpSList[1], GET_PNVOBJ (lpCSData->lplpSList[0]));
        }
    }
#endif  //NEW_FRONT_RENDER

    if (IS_OVERLAY(pDDSLcl->ddsCaps.dwCaps, pDDSLcl->lpGbl->ddpfSurface.dwFourCC)) {
        if (pDDSLcl->lpGbl->wWidth < 640 && pDDSLcl->lpGbl->wHeight < 480) {
            // media player, quicktime, or realplayer
            pDriverData->vpp.dwOverlayFSSrcWidth = pDDSLcl->lpGbl->wWidth;
            pDriverData->vpp.dwOverlayFSSrcHeight = pDDSLcl->lpGbl->wHeight;
            pDriverData->vpp.dwOverlayFSSrcMinX = 0;
            pDriverData->vpp.dwOverlayFSSrcMinY = 0;
        } else {
            // DVD player, figure out the source bounding box dimensions later
            pDriverData->vpp.dwOverlayFSSrcWidth = 0;
            pDriverData->vpp.dwOverlayFSSrcHeight = 0;
            pDriverData->vpp.dwOverlayFSSrcMinX = 0xFFFFFFFF;
            pDriverData->vpp.dwOverlayFSSrcMinY = 0xFFFFFFFF;
        }

#ifdef VPEFSMIRROR
        VppCreateFSMirror(&(pDriverData->vpp), pDDSLcl->lpGbl->wWidth, pDDSLcl->lpGbl->wHeight);
        if (pDriverData->nvpeState.bVPEInitialized && (pDriverData->vpp.dwOverlayFSNumSurfaces > 0)) {
            NVPFsMirrorEnable(pDriverData);
        }
#else
        if(!(pDriverData->nvpeState.bVPEInitialized)) {
            VppCreateFSMirror(&(pDriverData->vpp), pDDSLcl->lpGbl->wWidth, pDDSLcl->lpGbl->wHeight);
        }
#endif
    }

    NvReleaseSemaphore(pDriverData);
    DDENDTICK(SURF4_CREATESURFACE);

    dbgTracePop();
    return (DDHAL_DRIVER_HANDLED);

} // CreateSurface32

//---------------------------------------------------------------------------

// CanCreateSurface32
//
// Determine whether we support creation of a particular surface type in our HAL driver
//
// NOTES:
// This entry point is called after parameter validation but before
// any object creation.   You can decide here if it is possible for
// you to create this surface.  For example, if the person is trying
// to create an overlay, and you already have the maximum number of
// overlays created, this is the place to fail the call.
//
// You also need to check if the pixel format specified can be supported.
//
// lpCanCreateSurface->bIsDifferentPixelFormat tells us if the pixel format of the
// surface being created matches that of the primary surface.  It can be
// true for Z buffer and alpha buffers, so don't just reject it out of
// hand...

DWORD __stdcall CanCreateSurface32 (LPDDHAL_CANCREATESURFACEDATA lpCanCreateSurface)
{
    dbgTracePush ("CanCreateSurface32");

    if (lpCanCreateSurface->lpDDSurfaceDesc->ddsCaps.dwCaps & DDSCAPS_EXECUTEBUFFER) {
        // silly hack for screwed up kernel calls
        DWORD dwRetVal;
        dwRetVal = D3DCanCreateExecuteBuffer32(lpCanCreateSurface);
        dbgTracePop();
        return dwRetVal;
    }


    DPF_LEVEL(NVDBG_LEVEL_SURFACE, "CanCreateSurface, lpCanCreateSurface->lpDD=%08x", lpCanCreateSurface->lpDD );
    DPF_LEVEL(NVDBG_LEVEL_SURFACE, "    lpCanCreateSurface->lpDDSurfaceDesc=%08x", lpCanCreateSurface->lpDDSurfaceDesc );

    DDSTARTTICK(SURF4_CANCREATESURFACE);
    nvSetDriverDataPtrFromDDGbl (lpCanCreateSurface->lpDD);

    LPDDSURFACEDESC lpDDSurface = lpCanCreateSurface->lpDDSurfaceDesc;
    DWORD caps         = lpDDSurface->ddsCaps.dwCaps;
    DWORD dwModeWidth  = GET_MODE_WIDTH();
    DWORD dwModeHeight = GET_MODE_HEIGHT();
    DWORD dwModeBPP    = GET_MODE_BPP() >> 3;

    // Reset NV and get the monitor frequency after a mode reset
    if (getDC()->dwEnableStatus != CDriverContext::DC_ENABLESTATUS_ENABLED) {

        if (!nvEnable32 (lpCanCreateSurface->lpDD)) {
            DDENDTICK(SURF4_CREATESURFACE);
            NvReleaseSemaphore(pDriverData);
            lpCanCreateSurface->ddRVal = DDERR_OUTOFMEMORY;
            dbgTracePop();
            return DDHAL_DRIVER_HANDLED;
        }

    }

    if (caps & (DDSCAPS_MODEX | DDSCAPS_PALETTE)) {

        NvReleaseSemaphore(pDriverData);
        DDENDTICK(SURF4_CANCREATESURFACE);
        dbgTracePop();
        return (DDHAL_DRIVER_NOTHANDLED);

    }

    if ((dwModeBPP == 1) && (caps & DDSCAPS_ALPHA)) {

        NvReleaseSemaphore(pDriverData);
        DDENDTICK(SURF4_CANCREATESURFACE);
        dbgTracePop();
        return (DDHAL_DRIVER_NOTHANDLED);

    }

    if (caps & DDSCAPS_3DDEVICE) {

        if ((lpDDSurface->ddpfPixelFormat.dwRGBBitCount == 16) && (lpDDSurface->ddpfPixelFormat.dwFlags & DDPF_ALPHAPIXELS)) {
            NvReleaseSemaphore(pDriverData);
            DPF_LEVEL(NVDBG_LEVEL_SURFACE, "CanCreateSurface32 - no 16bit alpha 3d render target");
            lpCanCreateSurface->ddRVal = DDERR_INVALIDPIXELFORMAT;
            DDENDTICK(SURF4_CANCREATESURFACE);
            dbgTracePop();
            return (DDHAL_DRIVER_HANDLED);
          }
    }

    if (caps & DDSCAPS_TEXTURE) {

        // Don't allow textures in 8bpp
        if (dwModeBPP == 1) {
            NvReleaseSemaphore(pDriverData);
            DPF_LEVEL(NVDBG_LEVEL_SURFACE, "CanCreateSurface32 - invalid pixel format 130");
            lpCanCreateSurface->ddRVal = DDERR_INVALIDPIXELFORMAT;
            DDENDTICK(SURF4_CANCREATESURFACE);
            dbgTracePop();
            return (DDHAL_DRIVER_HANDLED);
        }

        // ??BOGUS??  Do we really want to accept all other textures?  What about bogus
        // FOURCC formats?  What about contradictory flags in 'caps'?
        // Partial answer: CreateSurface() does these checks, which fills the functional
        // need and probably keeps code simpler for now.

        NvReleaseSemaphore(pDriverData);
        lpDDSurface->ddsCaps.dwCaps &= ~DDSCAPS_VIDEOMEMORY;
        lpDDSurface->ddsCaps.dwCaps |= DDSCAPS_SYSTEMMEMORY;
        lpCanCreateSurface->ddRVal = DD_OK;
        DDENDTICK(SURF4_CANCREATESURFACE);
        dbgTracePop();
        return (DDHAL_DRIVER_HANDLED);
    }

    // check pixel format.   Don't allow pixel formats that aren't
    // the same, unless we have a valid fourcc code, an overlay,
    // an alpha surface, or z buffer.

    if (lpCanCreateSurface->bIsDifferentPixelFormat) {

        DPF_LEVEL(NVDBG_LEVEL_SURFACE, "    different pixel format!" );

        if ( lpDDSurface->ddpfPixelFormat.dwFlags & DDPF_ALPHAPREMULT ) {

            if ((dwModeBPP == 1) || (dwModeBPP == 2)) {
                // We don't support alpha surfaces in 8bpp mode
                NvReleaseSemaphore(pDriverData);
                DPF_LEVEL(NVDBG_LEVEL_SURFACE, "CanCreateSurface32 - no alpha surf in 8bpp");
                lpCanCreateSurface->ddRVal = DDERR_INVALIDPIXELFORMAT;
                DDENDTICK(SURF4_CANCREATESURFACE);
                dbgTracePop();
                return (DDHAL_DRIVER_HANDLED);
            }

            if (dwModeBPP == 4) {
                if ((lpDDSurface->ddpfPixelFormat.dwRGBAlphaBitMask != 0xFF000000) ||
                    (lpDDSurface->ddpfPixelFormat.dwRBitMask != 0x00FF0000) ||
                    (lpDDSurface->ddpfPixelFormat.dwGBitMask != 0x0000FF00) ||
                    (lpDDSurface->ddpfPixelFormat.dwBBitMask != 0x000000FF)) {
                    NvReleaseSemaphore(pDriverData);
                    DPF_LEVEL(NVDBG_LEVEL_SURFACE, "CanCreateSurface32 - unsupported format 10");
                    lpCanCreateSurface->ddRVal = DDERR_UNSUPPORTEDFORMAT;
                    DDENDTICK(SURF4_CANCREATESURFACE);
                    dbgTracePop();
                    return (DDHAL_DRIVER_HANDLED);
                }
                else {
                    NvReleaseSemaphore(pDriverData);
                    lpCanCreateSurface->ddRVal = DD_OK;
                    DDENDTICK(SURF4_CANCREATESURFACE);
                    dbgTracePop();
                    return (DDHAL_DRIVER_HANDLED);
                }
            }
        }

        if ( lpDDSurface->ddpfPixelFormat.dwFlags & DDPF_FOURCC ) {

#ifdef WINNT
            // Don't allow NVDS surfaces to be created under NT or Win2K, since the
            // proprietary motion comp interface doesn't work there.
            if (lpDDSurface->ddpfPixelFormat.dwFourCC == FOURCC_NVDS) {
                NvReleaseSemaphore(pDriverData);
                lpCanCreateSurface->ddRVal = DDERR_INVALIDPIXELFORMAT;
                DDENDTICK(SURF4_CANCREATESURFACE);
                dbgTracePop();
                return (DDHAL_DRIVER_HANDLED);
            }
#endif

            if (dwModeBPP == 1) {
                // We don't support RGB FOURCCs in 8bpp mode
                if (lpDDSurface->ddpfPixelFormat.dwFourCC == FOURCC_RGB0) {
                    NvReleaseSemaphore(pDriverData);
                    DPF_LEVEL(NVDBG_LEVEL_SURFACE, "CanCreateSurface32 - invalid pixel format 10");
                    lpCanCreateSurface->ddRVal = DDERR_INVALIDPIXELFORMAT;
                    DDENDTICK(SURF4_CANCREATESURFACE);
                    dbgTracePop();
                    return (DDHAL_DRIVER_HANDLED);
                }
            }

            DPF_LEVEL(NVDBG_LEVEL_SURFACE, "    FourCC requested (%4.4s, 0x%08x)",
                 (LPSTR) &lpDDSurface->ddpfPixelFormat.dwFourCC,
                 lpDDSurface->ddpfPixelFormat.dwFourCC );

            for (DWORD i=0; i < NV_MAX_FOURCC; i++) {

                if ( lpDDSurface->ddpfPixelFormat.dwFourCC == pDriverData->fourCC[i] ) {

                    DPF_LEVEL(NVDBG_LEVEL_SURFACE, "    FOURCC=%4.4s", (LPSTR) &pDriverData->fourCC[i] );

                    // ??BOGUS??  Won't this test always fail?  The same test higher up seems
                    // to catch all cases.
                    if (caps & DDSCAPS_TEXTURE) {

#ifdef TEXFORMAT_CRD // --------------------------------

                        lpCanCreateSurface->ddRVal = DDERR_UNSUPPORTEDFORMAT;

                        if ((pDriverData->nvD3DPerfData.dwNVClasses & NVCLASS_FAMILY_KELVIN)
                            &&
                            ((getDC()->nvD3DRegistryData.regSurfaceFormatsDX7 & D3D_REG_SURFACEFORMATS_NVXN) ||
                             (getDC()->nvD3DRegistryData.regSurfaceFormatsDX8 & D3D_REG_SURFACEFORMATS_NVXN))
                            &&
                            ((lpDDSurface->ddpfPixelFormat.dwFourCC == FOURCC_NVT0) ||
                             (lpDDSurface->ddpfPixelFormat.dwFourCC == FOURCC_NVT1) ||
                             (lpDDSurface->ddpfPixelFormat.dwFourCC == FOURCC_NVT2) ||
                             (lpDDSurface->ddpfPixelFormat.dwFourCC == FOURCC_NVT3) ||
                             (lpDDSurface->ddpfPixelFormat.dwFourCC == FOURCC_NVT4) ||
                             (lpDDSurface->ddpfPixelFormat.dwFourCC == FOURCC_NVT5) ||
                             (lpDDSurface->ddpfPixelFormat.dwFourCC == FOURCC_NVS0) ||
                             (lpDDSurface->ddpfPixelFormat.dwFourCC == FOURCC_NVS1) ||
                             (lpDDSurface->ddpfPixelFormat.dwFourCC == FOURCC_NVS2) ||
                             (lpDDSurface->ddpfPixelFormat.dwFourCC == FOURCC_NVS3) ||
                             (lpDDSurface->ddpfPixelFormat.dwFourCC == FOURCC_NVS4) ||
                             (lpDDSurface->ddpfPixelFormat.dwFourCC == FOURCC_NVS5))
                           )
                        {
                            // accept
                            lpCanCreateSurface->ddRVal = DD_OK;
                        }

                        if (((getDC()->nvD3DRegistryData.regSurfaceFormatsDX7 & D3D_REG_SURFACEFORMATS_HILO) ||
                             (getDC()->nvD3DRegistryData.regSurfaceFormatsDX8 & D3D_REG_SURFACEFORMATS_HILO))
                            &&
                            ((lpDDSurface->ddpfPixelFormat.dwFourCC == FOURCC_NVHS) ||
                             (lpDDSurface->ddpfPixelFormat.dwFourCC == FOURCC_NVHU))
                           )
                        {
                            // accept
                            lpCanCreateSurface->ddRVal = DD_OK;
                        }

                        if (((getDC()->nvD3DRegistryData.regSurfaceFormatsDX7 & D3D_REG_SURFACEFORMATS_DXT) ||
                             (getDC()->nvD3DRegistryData.regSurfaceFormatsDX8 & D3D_REG_SURFACEFORMATS_DXT))
                            &&
                            ((lpDDSurface->ddpfPixelFormat.dwFourCC == FOURCC_DXT1) ||
                             (lpDDSurface->ddpfPixelFormat.dwFourCC == FOURCC_DXT2) ||
                             (lpDDSurface->ddpfPixelFormat.dwFourCC == FOURCC_DXT3) ||
                             (lpDDSurface->ddpfPixelFormat.dwFourCC == FOURCC_DXT4) ||
                             (lpDDSurface->ddpfPixelFormat.dwFourCC == FOURCC_DXT5))
                           )
                        {
                            // accept
                            lpCanCreateSurface->ddRVal = DD_OK;
                        }

                        if (lpCanCreateSurface->ddRVal != DD_OK) {
                            DPF_LEVEL(NVDBG_LEVEL_SURFACE, "CanCreateSurface32 - unsupported texture format (via FOURCC)");
                        }

#else // !TEXFORMAT_CRD  --------------------------------

                        // allow only known texture fourcc formats
                        if (pDriverData->nvD3DPerfData.dwNVClasses & NVCLASS_FAMILY_KELVIN) {
                            if ((lpDDSurface->ddpfPixelFormat.dwFourCC == FOURCC_NVT0)
                             || (lpDDSurface->ddpfPixelFormat.dwFourCC == FOURCC_NVT1)
                             || (lpDDSurface->ddpfPixelFormat.dwFourCC == FOURCC_NVT2)
                             || (lpDDSurface->ddpfPixelFormat.dwFourCC == FOURCC_NVT3)
                             || (lpDDSurface->ddpfPixelFormat.dwFourCC == FOURCC_NVT4)
                             || (lpDDSurface->ddpfPixelFormat.dwFourCC == FOURCC_NVT5)
                             || (lpDDSurface->ddpfPixelFormat.dwFourCC == FOURCC_NVS0)
                             || (lpDDSurface->ddpfPixelFormat.dwFourCC == FOURCC_NVS1)
                             || (lpDDSurface->ddpfPixelFormat.dwFourCC == FOURCC_NVS2)
                             || (lpDDSurface->ddpfPixelFormat.dwFourCC == FOURCC_NVS3)
                             || (lpDDSurface->ddpfPixelFormat.dwFourCC == FOURCC_NVS4)
                             || (lpDDSurface->ddpfPixelFormat.dwFourCC == FOURCC_NVS5)
#if defined(HILO_SUPPORT_DX7) || defined(HILO_SUPPORT_DX8)
                             || (lpDDSurface->ddpfPixelFormat.dwFourCC == FOURCC_NVHS)
                             || (lpDDSurface->ddpfPixelFormat.dwFourCC == FOURCC_NVHU)
#endif
                             )
                            {
                                // accept
                                lpCanCreateSurface->ddRVal = DD_OK;
                            }
                        }
#ifdef DXT_SUPPORT
                        if (((getDC()->nvD3DRegistryData.regD3DEnableBits1 & D3D_REG_TEXTURECOMPRESSIONENABLE_MASK) ==
                               D3D_REG_TEXTURECOMPRESSIONENABLE_ENABLE)
                              &&
                              ((lpDDSurface->ddpfPixelFormat.dwFourCC == FOURCC_DXT1) ||
                               (lpDDSurface->ddpfPixelFormat.dwFourCC == FOURCC_DXT2) ||
                               (lpDDSurface->ddpfPixelFormat.dwFourCC == FOURCC_DXT3) ||
                               (lpDDSurface->ddpfPixelFormat.dwFourCC == FOURCC_DXT4) ||
                               (lpDDSurface->ddpfPixelFormat.dwFourCC == FOURCC_DXT5))
                            )
                        {
                            // accept
                            lpCanCreateSurface->ddRVal = DD_OK;
                        } else
#endif
                        {
                            DPF_LEVEL(NVDBG_LEVEL_SURFACE, "CanCreateSurface32 - unsupported texture format (via FOURCC)");
                            lpCanCreateSurface->ddRVal = DDERR_UNSUPPORTEDFORMAT;
                        }

#endif // !TEXFORMAT_CRD  --------------------------------

                        NvReleaseSemaphore(pDriverData);
                        DDENDTICK(SURF4_CANCREATESURFACE);
                        dbgTracePop();
                        return (DDHAL_DRIVER_HANDLED);
                    }

                    else if (caps & DDSCAPS_OVERLAY) {

                        if ((lpDDSurface->ddpfPixelFormat.dwFourCC != FOURCC_UYVY) &&
                            (lpDDSurface->ddpfPixelFormat.dwFourCC != FOURCC_UYNV) &&
                            (lpDDSurface->ddpfPixelFormat.dwFourCC != FOURCC_YUY2) &&
                            (lpDDSurface->ddpfPixelFormat.dwFourCC != FOURCC_YUNV) &&
                            (lpDDSurface->ddpfPixelFormat.dwFourCC != FOURCC_YV12) &&
                            (lpDDSurface->ddpfPixelFormat.dwFourCC != FOURCC_NV12) &&
                            (lpDDSurface->ddpfPixelFormat.dwFourCC != FOURCC_NVDS) &&
//                            (lpDDSurface->ddpfPixelFormat.dwFourCC != FOURCC_420i) &&
                            (lpDDSurface->ddpfPixelFormat.dwFourCC != FOURCC_IF09) &&
                            (lpDDSurface->ddpfPixelFormat.dwFourCC != FOURCC_YVU9) &&
                            (lpDDSurface->ddpfPixelFormat.dwFourCC != FOURCC_IV32) &&
                            (lpDDSurface->ddpfPixelFormat.dwFourCC != FOURCC_IV31)) {
                            NvReleaseSemaphore(pDriverData);
                            DPF_LEVEL(NVDBG_LEVEL_SURFACE, "CanCreateSurface32 - unsupported format 20");
                            lpCanCreateSurface->ddRVal = DDERR_UNSUPPORTEDFORMAT;
                            DDENDTICK(SURF4_CANCREATESURFACE);
                            dbgTracePop();
                            return (DDHAL_DRIVER_HANDLED);
                        }

                        if ((caps & (DDSCAPS_VIDEOPORT | DDSCAPS_FLIP)) == (DDSCAPS_VIDEOPORT | DDSCAPS_FLIP)) {
                            // Surface is for overlay with flip associated with video port
                            // check number of buffers, can't have more than 5 surfaces
                            // This will probably change when we have kernel mode flipping support
                            if ((lpDDSurface->dwFlags & DDSD_BACKBUFFERCOUNT) &&
                                (lpDDSurface->dwBackBufferCount > 4)) {
                                NvReleaseSemaphore(pDriverData);
                                DPF_LEVEL(NVDBG_LEVEL_SURFACE, "CanCreateSurface32 - invalid parameters 10");
                                lpCanCreateSurface->ddRVal = DDERR_INVALIDPARAMS;
                                DDENDTICK(SURF4_CANCREATESURFACE);
                                dbgTracePop();
                                return (DDHAL_DRIVER_HANDLED);
                            }
                        }
                        else {
                            // Workaround for Microsoft DirectVideo Cinepak decoding bug
                            // The reason for the existence of FOURCC_UYNV and FOURCC_YUNV
//                                              if ((lpDDSurface->dwFlags & DDSD_BACKBUFFERCOUNT) &&
//                                (lpDDSurface->dwBackBufferCount > 1) &&
//                                ((lpDDSurface->ddpfPixelFormat.dwFourCC == FOURCC_UYVY) ||
//                                 (lpDDSurface->ddpfPixelFormat.dwFourCC == FOURCC_YUY2))) {
//                                                      lpCanCreateSurface->ddRVal = DDERR_INVALIDPARAMS;
//                                dbgTracePop();
//                                return DDHAL_DRIVER_HANDLED;
//                                          }

                            // We must limit number of YV12 overlay surfaces to the maximum number we can manage reformatting
                            if ((lpDDSurface->dwFlags & DDSD_BACKBUFFERCOUNT) &&
                                (lpDDSurface->dwBackBufferCount > 3) &&
                                (lpDDSurface->ddpfPixelFormat.dwFourCC == FOURCC_YV12)) {
                                NvReleaseSemaphore(pDriverData);
                                DPF_LEVEL(NVDBG_LEVEL_SURFACE, "CanCreateSurface32 - out of caps 10");
                                lpCanCreateSurface->ddRVal = DDERR_OUTOFCAPS;
                                DDENDTICK(SURF4_CANCREATESURFACE);
                                dbgTracePop();
                                return (DDHAL_DRIVER_HANDLED);
                            }
                        }

                        if (VppIsOverlayActive(&pDriverData->vpp))
                        {
                            NvReleaseSemaphore(pDriverData);
                            DPF_LEVEL(NVDBG_LEVEL_SURFACE, "CanCreateSurface32 - out of caps 20");
                            lpCanCreateSurface->ddRVal = DDERR_OUTOFCAPS;
                            DDENDTICK(SURF4_CANCREATESURFACE);
                            dbgTracePop();
                            return (DDHAL_DRIVER_HANDLED);
                        }

                        // NB: Do not call VppGetVideoScalerBandwidthStatus() in CanCreateSurface() because
                        //     on some modesets (etc) Ddraw will re-create surfaces by ONLY calling CreateSurface().
                    }

                    else if (caps & (DDSCAPS_VIDEOMEMORY | DDSCAPS_OFFSCREENPLAIN)) {

                        // only support certain FOURCC formats
                        switch ( lpDDSurface->ddpfPixelFormat.dwFourCC )
                        {
                        // These are the formats we like.  They're supported in VppCreateFourCCSurface(),
                        // which seems to be the only routine that allocs a non-texture FOURCC surface.
                        //
                        // I've commented out a few for the following reasons (from previous check-ins):
                        //     Front end YUV support cannot reformat data so Indeo is not supported
                        //     Currently also disallowing front end YUV420 since YUYV or UYVY
                        //     should do ok when not enough backend bandwidth is available.
                        case FOURCC_RGB0:
                        case FOURCC_RAW8:
                      //case FOURCC_IF09:
                      //case FOURCC_YVU9:
                      //case FOURCC_IV32:
                      //case FOURCC_IV31:
#if IS_WINNT5 || IS_WIN9X
                        case FOURCC_NV12: // Our motion comp surface format
                        case FOURCC_NVMC: // Our motion comp control surface, NV10 or greater
                        case FOURCC_NVDS:
                        case FOURCC_NVSP: // A subpicture surface (overlay)
                        case FOURCC_NVID:
#endif
                        case FOURCC_YUY2:
                        case FOURCC_YUNV:
                        case FOURCC_UYVY:
                        case FOURCC_UYNV:
                      //case FOURCC_YV12:
                      //case FOURCC_420i:
                            // no-op -- we're happy if we get here
                            //--?? Why not return here?
                            break;

                        default:
                            // we can't/won't support anything but what's listed above
                            NvReleaseSemaphore(pDriverData);
                            DPF_LEVEL(NVDBG_LEVEL_SURFACE, "CanCreateSurface32 - unsupported format 30");
                            lpCanCreateSurface->ddRVal = DDERR_UNSUPPORTEDFORMAT;
                            DDENDTICK(SURF4_CANCREATESURFACE);
                            dbgTracePop();
                            return (DDHAL_DRIVER_HANDLED);
                        }

                        if (caps & DDSCAPS_VIDEOPORT) {
                            // Nonoverlay FOURCC video surfaces are only supported for YUV422
                            // formats and only when associated with the video port
                            if ((lpDDSurface->ddpfPixelFormat.dwFourCC != FOURCC_YUY2) &&
                                (lpDDSurface->ddpfPixelFormat.dwFourCC != FOURCC_YUNV) &&
                                (lpDDSurface->ddpfPixelFormat.dwFourCC != FOURCC_UYVY) &&
                                (lpDDSurface->ddpfPixelFormat.dwFourCC != FOURCC_UYNV) &&
                                (lpDDSurface->ddpfPixelFormat.dwFourCC != FOURCC_RAW8)
                               ) {
                                NvReleaseSemaphore(pDriverData);
                                DPF_LEVEL(NVDBG_LEVEL_SURFACE, "CanCreateSurface32 - unsupported format 40");
                                lpCanCreateSurface->ddRVal = DDERR_UNSUPPORTEDFORMAT;
                                DDENDTICK(SURF4_CANCREATESURFACE);
                                dbgTracePop();
                                return (DDHAL_DRIVER_HANDLED);
                            }
                            // Front end YUV support not available in 8bit indexed mode
                        }
                        else if (dwModeBPP == 1) {
                            if (lpDDSurface->ddpfPixelFormat.dwFourCC != FOURCC_RAW8) {
                                NvReleaseSemaphore(pDriverData);
                                DPF_LEVEL(NVDBG_LEVEL_SURFACE, "CanCreateSurface32 - unsupported format 50");
                                lpCanCreateSurface->ddRVal = DDERR_UNSUPPORTEDFORMAT;
                                DDENDTICK(SURF4_CANCREATESURFACE);
                                dbgTracePop();
                                return (DDHAL_DRIVER_HANDLED);
                            }
                        }
                    }

                    if (lpDDSurface->ddpfPixelFormat.dwFourCC == FOURCC_RGB0) {
                        if (((dwModeBPP == 2) && (lpDDSurface->ddpfPixelFormat.dwRGBBitCount != DDBD_16)) ||
                            ((dwModeBPP == 4) && (lpDDSurface->ddpfPixelFormat.dwRGBBitCount != DDBD_32))) {
                            NvReleaseSemaphore(pDriverData);
                            DPF_LEVEL(NVDBG_LEVEL_SURFACE, "CanCreateSurface32 - invalid pixel format 20");
                            lpCanCreateSurface->ddRVal = DDERR_INVALIDPIXELFORMAT;
                            DDENDTICK(SURF4_CANCREATESURFACE);
                            dbgTracePop();
                            return (DDHAL_DRIVER_HANDLED);
                        }
                    }

                    NvReleaseSemaphore(pDriverData);
                    lpCanCreateSurface->ddRVal = DD_OK;
                    DDENDTICK(SURF4_CANCREATESURFACE);
                    dbgTracePop();
                    return (DDHAL_DRIVER_HANDLED);
                }

                else { // Check for known "hidden" FOURCC formats
                    if (pDriverData->NvDeviceVersion >= NV_DEVICE_VERSION_10) {
                        if ((lpDDSurface->ddpfPixelFormat.dwFourCC == FOURCC_NVMC) ||
                            (lpDDSurface->ddpfPixelFormat.dwFourCC == FOURCC_NVDS) ||
                            (lpDDSurface->ddpfPixelFormat.dwFourCC == FOURCC_NV12) ||
                            (lpDDSurface->ddpfPixelFormat.dwFourCC == FOURCC_NVID) ||
                            (lpDDSurface->ddpfPixelFormat.dwFourCC == FOURCC_NVSP)) {

                            if (lpDDSurface->ddpfPixelFormat.dwFourCC == FOURCC_NVMC) {
                                if (pDriverData->vpp.dwOverlaySurfaces > 0) {
                                    NvReleaseSemaphore(pDriverData);
                                    DPF_LEVEL(NVDBG_LEVEL_SURFACE, "CanCreateSurface32 - out of caps 21");
                                    lpCanCreateSurface->ddRVal = DDERR_OUTOFCAPS;
                                    DDENDTICK(SURF4_CANCREATESURFACE);
                                    dbgTracePop();
                                    return (DDHAL_DRIVER_HANDLED);
                                }
                            }

                            if (lpDDSurface->ddpfPixelFormat.dwFourCC == FOURCC_NV12) {
                                if (VppGetVideoScalerBandwidthStatus(&pDriverData->vpp, lpCanCreateSurface->lpDDSurfaceDesc->dwWidth) == FALSE) {
                                    NvReleaseSemaphore(pDriverData);
                                    DPF_LEVEL(NVDBG_LEVEL_SURFACE, "CanCreateSurface32 - no overlay hardware 10");
                                    lpCanCreateSurface->ddRVal = DDERR_NOOVERLAYHW;
                                    DDENDTICK(SURF4_CANCREATESURFACE);
                                    dbgTracePop();
                                    return (DDHAL_DRIVER_HANDLED);
                                }
                            }

                            NvReleaseSemaphore(pDriverData);
                            lpCanCreateSurface->ddRVal = DD_OK;
                            DDENDTICK(SURF4_CANCREATESURFACE);
                            dbgTracePop();
                            return (DDHAL_DRIVER_HANDLED);
                        }
                    }
                }
            }
        }

        else if ( lpDDSurface->ddpfPixelFormat.dwFlags & DDPF_RGB ) {

            // Don't allow 3D devices in 8bpp
            if (caps & DDSCAPS_3DDEVICE) {
                if (lpDDSurface->ddpfPixelFormat.dwRGBBitCount == 8) {
                    NvReleaseSemaphore(pDriverData);
                    DPF_LEVEL(NVDBG_LEVEL_SURFACE, "CanCreateSurface32 - invalid pixel format 30");
                    lpCanCreateSurface->ddRVal = DDERR_INVALIDPIXELFORMAT;
                    DDENDTICK(SURF4_CANCREATESURFACE);
                    dbgTracePop();
                    return (DDHAL_DRIVER_HANDLED);
                }
            }

            // ??BOGUS??  Won't the texture bit always be zero?  It appears that all texture
            // cases are handled higher up.
            if (caps & DDSCAPS_TEXTURE || caps & DDSCAPS_OFFSCREENPLAIN) {

                // Don't allow textures in 8bpp.
                if (dwModeBPP == 1) {
                    NvReleaseSemaphore(pDriverData);
                    DPF_LEVEL(NVDBG_LEVEL_SURFACE, "CanCreateSurface32 - invalid pixel format 40");
                    lpCanCreateSurface->ddRVal = DDERR_INVALIDPIXELFORMAT;
                    DDENDTICK(SURF4_CANCREATESURFACE);
                    dbgTracePop();
                    return (DDHAL_DRIVER_NOTHANDLED);
                }

                // accept 8 bit palettized textures
                // do I need to be more specific like DDPF_RGB also???
                // supposedly palette creation should be allowed here
                // when I set the Palette to Surface I need to check
                // matching bit depths there.
                if ((lpDDSurface->ddpfPixelFormat.dwFlags & DDPF_PALETTEINDEXED8)
#ifdef TEXFORMAT_CRD
                    &&
                    ((getDC()->nvD3DRegistryData.regSurfaceFormatsDX7 & D3D_REG_SURFACEFORMATS_PALETTIZED) ||
                     (getDC()->nvD3DRegistryData.regSurfaceFormatsDX8 & D3D_REG_SURFACEFORMATS_PALETTIZED))
                   )
#else   // !TEXFORMAT_CRD
                 && ((getDC()->nvD3DRegistryData.regD3DEnableBits1 & D3D_REG_PALETTEENABLE_MASK) == D3D_REG_PALETTEENABLE_ENABLE))
#endif  // !TEXFORMAT_CRD
                {
                    lpCanCreateSurface->ddRVal = DD_OK;
                    DDENDTICK(SURF4_CANCREATESURFACE);
                    NvReleaseSemaphore(pDriverData);
                    dbgTracePop();
                    return (DDHAL_DRIVER_HANDLED);
                }

                // accept all 16 and 32 bpp texture formats
                if ((lpDDSurface->ddpfPixelFormat.dwRGBBitCount == 16) ||
                    (lpDDSurface->ddpfPixelFormat.dwRGBBitCount == 32)) {
                    NvReleaseSemaphore(pDriverData);
                    lpCanCreateSurface->ddRVal = DD_OK;
                    DDENDTICK(SURF4_CANCREATESURFACE);
                    dbgTracePop();
                    return (DDHAL_DRIVER_HANDLED);
                }
            }

            if (caps & DDSCAPS_ZBUFFER) {
                if (getDC()->nvD3DRegistryData.regValidateZMethod == D3D_REG_VALIDATEZMETHOD_STRICT) {
                    // For now, support z buffers in video memory only when our primary rendering depth is 16 bpp
                    if ((lpDDSurface->ddpfPixelFormat.dwRGBBitCount == 16) && (dwModeBPP == 2)) {
                        // accept all 16 bpp z buffer formats when in 16 bpp disply mode
                        NvReleaseSemaphore(pDriverData);
                        lpCanCreateSurface->ddRVal = DD_OK;
                        DDENDTICK(SURF4_CANCREATESURFACE);
                        dbgTracePop();
                        return (DDHAL_DRIVER_HANDLED);
                    }
                    if ((lpDDSurface->ddpfPixelFormat.dwRGBBitCount == 32) && (dwModeBPP == 4)) {
                        // accept all 32 bpp z buffer formats when in 32 bpp disply mode
                        NvReleaseSemaphore(pDriverData);
                        lpCanCreateSurface->ddRVal = DD_OK;
                        DDENDTICK(SURF4_CANCREATESURFACE);
                        dbgTracePop();
                        return (DDHAL_DRIVER_HANDLED);
                    }
                    // Any other z buffer depth or combination of z/display surface depths
                    // are invalid.
                    NvReleaseSemaphore(pDriverData);
                    DDENDTICK(SURF4_CANCREATESURFACE);
                    dbgTracePop();
                    return (DDHAL_DRIVER_NOTHANDLED);
                }
                else {
                    // Allocate the z-buffer with the proper padding based on the bit depth of the primary surface
                    // accept all 16, 24, 32 bpp z buffer formats when in 16 bpp disply mode
                    if ((lpDDSurface->ddpfPixelFormat.dwRGBBitCount == 16)
                        || (lpDDSurface->ddpfPixelFormat.dwRGBBitCount == 24)
                        || (lpDDSurface->ddpfPixelFormat.dwRGBBitCount == 32)) {
                        NvReleaseSemaphore(pDriverData);
                        lpCanCreateSurface->ddRVal = DD_OK;
                        DDENDTICK(SURF4_CANCREATESURFACE);
                        dbgTracePop();
                        return (DDHAL_DRIVER_HANDLED);
                    }
                    // Any other z buffer depth or combination of z/display surface depths
                    // are invalid.
                    NvReleaseSemaphore(pDriverData);
                    DDENDTICK(SURF4_CANCREATESURFACE);
                    dbgTracePop();
                    return (DDHAL_DRIVER_NOTHANDLED);
                }
            }

            // We don't support any other RGB surfaces not in our native format
            NvReleaseSemaphore(pDriverData);
            DPF_LEVEL(NVDBG_LEVEL_SURFACE, "CanCreateSurface32 - invalid pixel format 50");
            lpCanCreateSurface->ddRVal = DDERR_INVALIDPIXELFORMAT;
            DDENDTICK(SURF4_CANCREATESURFACE);
            dbgTracePop();
            return (DDHAL_DRIVER_HANDLED);

        }

        else if ( lpDDSurface->ddpfPixelFormat.dwFlags & DDPF_ZBUFFER ) {

            // Don't allow z-buffer surfaces in 8bpp
            if (caps & DDSCAPS_ZBUFFER) {
                if (dwModeBPP == 1) {
                    NvReleaseSemaphore(pDriverData);
                    DPF_LEVEL(NVDBG_LEVEL_SURFACE, "CanCreateSurface32 - invalid pixel format 60");
                    lpCanCreateSurface->ddRVal = DDERR_INVALIDPIXELFORMAT;
                    DDENDTICK(SURF4_CANCREATESURFACE);
                    dbgTracePop();
                    return (DDHAL_DRIVER_NOTHANDLED);
                }
                if (getDC()->nvD3DRegistryData.regValidateZMethod == D3D_REG_VALIDATEZMETHOD_STRICT) {
                    if ((lpDDSurface->ddpfPixelFormat.dwZBufferBitDepth != (dwModeBPP << 3))) {
                        NvReleaseSemaphore(pDriverData);
                        DPF_LEVEL(NVDBG_LEVEL_SURFACE, "CanCreateSurface32 - invalid pixel format 70");
                        lpCanCreateSurface->ddRVal = DDERR_INVALIDPIXELFORMAT;
                        DDENDTICK(SURF4_CANCREATESURFACE);
                        dbgTracePop();
                        return (DDHAL_DRIVER_NOTHANDLED);
                    }
                }
                else {
                    if ((lpDDSurface->ddpfPixelFormat.dwZBufferBitDepth != 16)
                        && (lpDDSurface->ddpfPixelFormat.dwZBufferBitDepth != 24)
                        && (lpDDSurface->ddpfPixelFormat.dwZBufferBitDepth != 32)) {
                        NvReleaseSemaphore(pDriverData);
                        DPF_LEVEL(NVDBG_LEVEL_SURFACE, "CanCreateSurface32 - invalid pixel format 80");
                        lpCanCreateSurface->ddRVal = DDERR_INVALIDPIXELFORMAT;
                        DDENDTICK(SURF4_CANCREATESURFACE);
                        dbgTracePop();
                        return (DDHAL_DRIVER_NOTHANDLED);
                    }
                }
            }

            NvReleaseSemaphore(pDriverData);
            DPF_LEVEL(NVDBG_LEVEL_SURFACE, "Z BUFFER OK!" );
            lpCanCreateSurface->ddRVal = DD_OK;
            DDENDTICK(SURF4_CANCREATESURFA