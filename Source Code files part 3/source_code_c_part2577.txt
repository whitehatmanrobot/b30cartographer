verbActive = FALSE;
    m_pCoefs = NULL;
    m_pStates = NULL;
    m_ReverbParams.fInGain = 0.0;
    m_ReverbParams.fReverbMix = -10.0;
    m_ReverbParams.fReverbTime = 1000.0;
    m_ReverbParams.fHighFreqRTRatio = (float) 0.001;
    m_ppControl = NULL;
    m_dwControlCount = 0;
    m_nMaxVoices = MAX_NUM_VOICES;
    m_nExtraVoices = NUM_EXTRA_VOICES;
    m_stLastStats = 0;
    m_fAllowPanWhilePlayingNote = TRUE;
    m_fAllowVolumeChangeWhilePlayingNote = TRUE;
    ResetPerformanceStats();
    m_stLastTime = 0;
    m_dwSampleRate = SAMPLE_RATE_22;
    SetSampleRate(SAMPLE_RATE_22);
    SetStereoMode(BUFFERFLAG_INTERLEAVED);
    SetGainAdjust(600);

    m_sfMMXEnabled = FALSE;
#ifdef MMX_ENABLED
    m_sfMMXEnabled = MultiMediaInstructionsSupported();
#endif // MMX_ENABLED
}

CSynth::~CSynth()

{
    CVoice *pVoice;

    if (m_fCSInitialized)
    {
        // If CS never initialized, nothing else will have been set up
        //
        Close();
        while (pVoice = m_VoicesInUse.RemoveHead())
        {
            delete pVoice;
        }
        while (pVoice = m_VoicesFree.RemoveHead())
        {
            delete pVoice;
        }
        while (pVoice = m_VoicesExtra.RemoveHead())
        {
            delete pVoice;
        }

        DeleteCriticalSection(&m_CriticalSection);
    }
}

short CSynth::ChangeVoiceCount(CVoiceList *pList,short nOld,short nCount)

{
    if (nCount > nOld)
    {
        short nNew = nCount - nOld;
        for (;nNew != 0; nNew--)
        {
            CVoice *pVoice = new CVoice;
            if (pVoice != NULL)
            {
                pList->AddHead(pVoice);
            }
        }
    }
    else
    {
        short nNew = nOld - nCount;
        for (;nNew > 0; nNew--)
        {
            CVoice *pVoice = pList->RemoveHead();
            if (pVoice != NULL)
            {
                delete pVoice;
            }
            else
            {
                nCount += nNew;
                break;
            }
        }
    }
    return nCount;
}

HRESULT CSynth::SetMaxVoices(short nVoices,short nTempVoices)

{
    if (nVoices < 1)
    {
        nVoices = 1;
    }
    if (nTempVoices < 1)
    {
        nTempVoices = 1;
    }
    ::EnterCriticalSection(&m_CriticalSection);

    m_nMaxVoices = ChangeVoiceCount(&m_VoicesFree,m_nMaxVoices,nVoices);
    m_nExtraVoices = ChangeVoiceCount(&m_VoicesExtra,m_nExtraVoices,nTempVoices);

    ::LeaveCriticalSection(&m_CriticalSection);
    return S_OK;
}

HRESULT CSynth::SetNumChannelGroups(DWORD dwCableCount)

{
    HRESULT hr = S_OK;
    CControlLogic **ppControl;
    if ((dwCableCount < 1) || (dwCableCount > MAX_CHANNEL_GROUPS))
    {
        Trace(1,"Error: Request to set synth to %ld channel groups is invalid.\n",dwCableCount);
        return E_INVALIDARG;
    }
    ::EnterCriticalSection(&m_CriticalSection);
    if (m_dwControlCount != dwCableCount)
    {
        try
        {
            ppControl = new CControlLogic *[dwCableCount];
        }
        catch( ... )
        {
            ppControl = NULL;
        }

        if (ppControl)
        {
            DWORD dwX;
            for (dwX = 0; dwX < dwCableCount; dwX++)
            {
                ppControl[dwX] = NULL;
            }
            if (m_dwControlCount < dwCableCount)
            {
                for (dwX = 0; dwX < m_dwControlCount; dwX++)
                {
                    ppControl[dwX] = m_ppControl[dwX];
                }
                for (;dwX < dwCableCount; dwX++)
                {
                    try
                    {
                        ppControl[dwX] = new CControlLogic;
                    }
                    catch( ... )
                    {
                        ppControl[dwX] = NULL;
                    }

                    if (ppControl[dwX])
                    {
                        hr = ppControl[dwX]->Init(&m_Instruments, this);
                        if (FAILED(hr))
                        {
                            delete ppControl[dwX];
                            ppControl[dwX] = NULL;
                            dwCableCount = dwX;
                            break;
                        }

                        ppControl[dwX]->SetGainAdjust(m_vrGainAdjust);
                    }
                    else
                    {
                        dwCableCount = dwX;
                        break;
                    }
                }
            }
            else
            {
                AllNotesOff();
                for (dwX = 0; dwX < dwCableCount; dwX++)
                {
                    ppControl[dwX] = m_ppControl[dwX];
                }
                for (; dwX < m_dwControlCount; dwX++)
                {
                    if (m_ppControl[dwX])
                    {
                        delete m_ppControl[dwX];
                    }
                }
            }
            if (m_ppControl)
            {
                delete[] m_ppControl;
            }
            m_ppControl = ppControl;
            m_dwControlCount = dwCableCount;
        }
        else
        {
            hr = E_OUTOFMEMORY;
        }
    }
    ::LeaveCriticalSection(&m_CriticalSection);
    return hr;
}

void CSynth::SetGainAdjust(VREL vrGainAdjust)
{
    DWORD idx;

    m_vrGainAdjust = vrGainAdjust;
    ::EnterCriticalSection(&m_CriticalSection);

    for (idx = 0; idx < m_dwControlCount; idx++)
    {
        m_ppControl[idx]->SetGainAdjust(m_vrGainAdjust);
    }

    ::LeaveCriticalSection(&m_CriticalSection);
}

HRESULT CSynth::SetReverb(DMUS_WAVES_REVERB_PARAMS *pParams)

{
    m_ReverbParams = *pParams;
    if (m_pCoefs)
    {
#ifdef REVERB_ENABLED
        ::SetSVerb(m_ReverbParams.fInGain,m_ReverbParams.fReverbMix,
            m_ReverbParams.fReverbTime,m_ReverbParams.fHighFreqRTRatio,m_pCoefs );
#endif
    }
    return S_OK;;
}

void CSynth::SetReverbActive(BOOL fReverb)

{
    ::EnterCriticalSection(&m_CriticalSection);
#ifdef REVERB_ENABLED
    if (m_fReverbActive != fReverb)
    {
        if (m_fReverbActive = fReverb)
        {
            if (!m_pCoefs)
            {
                long lSize = GetCoefsSize();
                m_pCoefs = (void *) malloc(lSize);
                lSize = GetStatesSize();
                m_pStates = (long *) malloc(lSize);
                if (m_pCoefs && m_pStates)
                {
                    memset((void *) m_pStates,0,lSize);
                    InitSVerb( (float) m_dwSampleRate, m_pCoefs);
                    InitSVerbStates( m_pStates );
                    SetReverb(&m_ReverbParams);
                }
            }
            else if (m_pStates)
            {
                InitSVerbStates( m_pStates );
            }
        }
    }
#else
        m_fReverbActive = FALSE;
#endif
    ::LeaveCriticalSection(&m_CriticalSection);
}

void CSynth::GetReverb(DMUS_WAVES_REVERB_PARAMS *pParams)
{
    *pParams = m_ReverbParams;
}

BOOL CSynth::IsReverbActive()

{
    return m_fReverbActive;
}


HRESULT CSynth::Open(DWORD dwCableCount, DWORD dwVoices, BOOL fReverb)

{
    HRESULT hr = S_OK;
    if ((dwCableCount < 1) || (dwCableCount > MAX_CHANNEL_GROUPS))
    {
        Trace(1,"Error: Request to open synth with %ld channel groups is invalid.\n",dwCableCount);
        return E_INVALIDARG;
    }
    if (m_ppControl)
    {
        Trace(1,"Error: Request to open synth failed because synth was already opened.\n");
        return E_FAIL;  // Already opened.
    }
    ::EnterCriticalSection(&m_CriticalSection);
    hr = SetNumChannelGroups(dwCableCount);
    if (SUCCEEDED(hr))
    {
        short nTemp = (short) dwVoices / 4;
        if (nTemp < 4) nTemp = 4;
        SetMaxVoices((short) dwVoices, nTemp);
    }
    SetReverbActive(fReverb);
    m_vrGainAdjust = 0;
    ::LeaveCriticalSection(&m_CriticalSection);
    return hr;
}

HRESULT CSynth::Close()

{
    ::EnterCriticalSection(&m_CriticalSection);
    AllNotesOff();
    DWORD dwX;
    for (dwX = 0; dwX < m_dwControlCount; dwX++)
    {
        if (m_ppControl[dwX])
        {
            delete m_ppControl[dwX];
        }
    }
    m_dwControlCount = 0;
    if (m_ppControl)
    {
        delete[] m_ppControl;
        m_ppControl = NULL;
    }
    m_stLastStats = 0;
    m_stLastTime = 0;
    m_fReverbActive = FALSE;
#ifdef REVERB_ENABLED
    if (m_pCoefs)
    {
        free(m_pCoefs);
        m_pCoefs = NULL;
    }
    if (m_pStates)
    {
        free(m_pStates);
        m_pStates = NULL;
    }
#endif
    ::LeaveCriticalSection(&m_CriticalSection);
    return S_OK;
}

HRESULT CSynth::GetMaxVoices(
    short * pnMaxVoices,    // Returns maximum number of allowed voices for continuous play.
    short * pnTempVoices )  // Returns number of extra voices for voice overflow.
{
    if (pnMaxVoices != NULL)
    {
        *pnMaxVoices = m_nMaxVoices;
    }
    if (pnTempVoices != NULL)
    {
        *pnTempVoices = m_nExtraVoices;
    }
    return S_OK;
}

HRESULT CSynth::SetSampleRate(
    DWORD dwSampleRate)
{
    HRESULT hr = S_OK;

    // Can't set the sample rate to 0
    if (dwSampleRate == 0)
    {
        Trace(1,"Error: Request to set sample rate to 0 failed.\n");
        return E_INVALIDARG;
    }

    ::EnterCriticalSection(&m_CriticalSection);
    AllNotesOff();
    if ( m_dwSampleRate || dwSampleRate )
    {
        m_stLastTime *= dwSampleRate;
        m_stLastTime /= m_dwSampleRate;
    }

//>>>>>>>>>>> why is this commented out????
    // m_stLastTime = MulDiv(m_stLastTime,dwSampleRate,m_dwSampleRate);
    m_stLastStats = 0;
    m_dwSampleRate = dwSampleRate;
    m_stMinSpan = dwSampleRate / 100;   // 10 ms.
    m_stMaxSpan = (dwSampleRate + 19) / 20;    // 50 ms.
    ::LeaveCriticalSection(&m_CriticalSection);
    m_Instruments.SetSampleRate(dwSampleRate);
    return hr;
}

HRESULT CSynth::Activate(DWORD dwSampleRate, DWORD dwBufferFlags)

{
#ifdef REVERB_ENABLED
    if (m_fReverbActive && m_pStates && m_pCoefs)
    {
        InitSVerb( (float) m_dwSampleRate, m_pCoefs);
        InitSVerbStates( m_pStates );
        SetReverb(&m_ReverbParams);
    }
#endif
    m_stLastTime = 0;
    SetSampleRate(dwSampleRate);
    SetStereoMode(dwBufferFlags);
    ResetPerformanceStats();
    return S_OK;
}

HRESULT CSynth::Deactivate()

{
    AllNotesOff();
    return S_OK;
}

HRESULT CSynth::GetPerformanceStats(PerfStats *pStats)

{
    if (pStats == NULL)
    {
        Trace(1,"Error: Null pointer passed for performance stats.\n");
        return E_POINTER;
    }
    *pStats = m_CopyStats;
    return (S_OK);
}

bool CSynth::BusIDToFunctionID(DWORD dwBusID, DWORD *pdwFunctionID, long *plPitchBends, DWORD *pdwIndex)

{
    // This should only be called if the internal bus pointers exist and there is at least one buffer.
    assert(m_pdwBusIDs && m_pdwFuncIDs && m_plPitchBends && m_dwBufferCount);
    // Scan through the list of bus ids, looking for the match for dwBusID.
    for ( DWORD nIndexSinkIds = 0; nIndexSinkIds < m_dwBufferCount; nIndexSinkIds++ )
    {
        // Is this one it?
        if (m_pdwBusIDs[nIndexSinkIds] == dwBusID)
        {
            *pdwFunctionID = m_pdwFuncIDs[nIndexSinkIds];
            if (plPitchBends)
                *plPitchBends = m_plPitchBends[nIndexSinkIds];
            if (pdwIndex)
                *pdwIndex = nIndexSinkIds;
            return true;
        }
    }
    return false;
}

void CSynth::Mix(short **ppvBuffer, DWORD *pdwIDs, DWORD *pdwFuncIDs, long *plPitchBends, DWORD dwBufferCount, DWORD dwBufferFlags,  DWORD dwLength, LONGLONG llPosition)
{
    static BOOL fDidLast = FALSE;

    STIME stEndTime;
    CVoice *pVoice;
    CVoice *pNextVoice;
    long lNumVoices = 0;
    DWORD i;

    ::EnterCriticalSection(&m_CriticalSection);

    // Store pointers to the id arrays so we can access them from BusIDToFunctionID.
    m_pdwBusIDs = pdwIDs;
    m_pdwFuncIDs = pdwFuncIDs;
    m_plPitchBends = plPitchBends;
    m_dwBufferCount = dwBufferCount;

/*  // Useful for debugging the incoming buses...
    static DWORD sdwCountDown = 0;
    if (!sdwCountDown)
    {
        for (DWORD dwIX = 0; dwIX < dwBufferCount; dwIX++)
        {
            Trace(0,"%ld:%ld->%ld\t",dwIX,pdwIDs[dwIX],pdwFuncIDs[dwIX]);
        }
        Trace(0,"\n");
        sdwCountDown = 100;
    }
    sdwCountDown--;*/

    LONG    lTime = - (LONG)::GetTheCurrentTime();

    stEndTime = llPosition + dwLength;
    StealNotes(stEndTime);
    DWORD dwX;

    for ( i = 0; i < dwBufferCount; i++ )
    {
        // For interleaved buffers only the first buss is valid
        if ( dwBufferFlags & BUFFERFLAG_INTERLEAVED && i > 0 )
        {
            break;
        }
        StartMix(ppvBuffer[i],dwLength,(dwBufferFlags&BUFFERFLAG_INTERLEAVED));
    }

    for (dwX = 0; dwX < m_dwControlCount; dwX++)
    {
        m_ppControl[dwX]->QueueNotes(llPosition, stEndTime);
        m_ppControl[dwX]->QueueWaves(stEndTime);
    }
    pVoice = m_VoicesInUse.GetHead();

    for (;pVoice != NULL;pVoice = pNextVoice)
    {
        if (pVoice->m_stWaveStopTime && (pVoice->m_stWaveStopTime < stEndTime))
        {
            pVoice->StopVoice(pVoice->m_stWaveStopTime);
        }
        pNextVoice = pVoice->GetNext();
        pVoice->Mix(ppvBuffer, dwBufferFlags, dwLength, llPosition, stEndTime);

        lNumVoices++;

        if (pVoice->m_fInUse == FALSE)
        {
            m_VoicesInUse.Remove(pVoice);
            m_VoicesFree.AddHead(pVoice);

            if (pVoice->m_stStartTime < m_stLastStats)
            {
                m_BuildStats.dwTotalSamples += (long) (pVoice->m_stStopTime - m_stLastStats);
            }
            else
            {
                m_BuildStats.dwTotalSamples += (long) (pVoice->m_stStopTime - pVoice->m_stStartTime);
            }
        }
    }

    for (dwX = 0; dwX < m_dwControlCount; dwX++)
    {
        m_ppControl[dwX]->ClearMIDI(stEndTime);
    }

#ifdef REVERB_ENABLED
    if (m_fReverbActive && m_pCoefs && m_pStates && !(dwBufferFlags & BUFFERFLAG_MULTIBUFFER) )
    {
        if (dwBufferFlags & BUFFERFLAG_INTERLEAVED)
        {
            SVerbStereoToStereoShort(dwLength,ppvBuffer[0],ppvBuffer[0],m_pCoefs,m_pStates);
        }
        else
        {
            SVerbMonoToMonoShort(dwLength,ppvBuffer[0],ppvBuffer[0],m_pCoefs,m_pStates);
        }
    }
#endif

    for ( i = 0; i < dwBufferCount; i++ )
    {
        // For interleaved buffers only the first buss is valid
        if ( dwBufferFlags & BUFFERFLAG_INTERLEAVED && i > 0 )
        {
            break;
        }
        FinishMix(ppvBuffer[i],dwLength,(dwBufferFlags&BUFFERFLAG_INTERLEAVED));
    }

    if (stEndTime > m_stLastTime)
    {
        m_stLastTime = stEndTime;
    }

    lTime += ::GetTheCurrentTime();

    m_BuildStats.dwTotalTime += lTime;

    if ((m_stLastStats + m_dwSampleRate) <= m_stLastTime)
    {
        DWORD dwElapsed = (DWORD) (m_stLastTime - m_stLastStats);
        pVoice = m_VoicesInUse.GetHead();

        for (;pVoice != NULL;pVoice = pVoice->GetNext())
        {
            if (pVoice->m_stStartTime < m_stLastStats)
            {
                m_BuildStats.dwTotalSamples += dwElapsed;
            }
            else
            {
                m_BuildStats.dwTotalSamples += (long) (m_stLastTime - pVoice->m_stStartTime);
            }
        }

        if (dwElapsed == 0)
            dwElapsed = 1;

        if (m_BuildStats.dwTotalSamples == 0)
            m_BuildStats.dwTotalSamples = 1;

        m_BuildStats.dwVoices =
            (m_BuildStats.dwTotalSamples + (dwElapsed >> 1)) / dwElapsed;
        {
            m_BuildStats.dwCPU = MulDiv(m_BuildStats.dwTotalTime,
                m_dwSampleRate, dwElapsed);
        }

        m_CopyStats = m_BuildStats;
        memset(&m_BuildStats, 0, sizeof(m_BuildStats));
        m_stLastStats = m_stLastTime;
    }

    m_pdwBusIDs = NULL;
    m_pdwFuncIDs = NULL;
    m_plPitchBends = NULL;
    m_dwBufferCount = 0;

    ::LeaveCriticalSection(&m_CriticalSection);
}

CVoice *CSynth::OldestVoice()

{
    CVoice *pVoice;
    CVoice *pBest = NULL;
    pVoice = m_VoicesInUse.GetHead();
    pBest = pVoice;
    if (pBest)
    {
        pVoice = pVoice->GetNext();
        for (;pVoice;pVoice = pVoice->GetNext())
        {
            if (!pVoice->m_fTag)
            {
                if (pBest->m_fTag)
                {
                    pBest = pVoice;
                }
                else
                {
                    if (pVoice->m_dwPriority <= pBest->m_dwPriority)
                    {
                        if (pVoice->m_fNoteOn)
                        {
                            if (pBest->m_fNoteOn)
                            {
                                if (pBest->m_stStartTime > pVoice->m_stStartTime)
                                {
                                    pBest = pVoice;
                                }
                            }
                        }
                        else
                        {
                            if (pBest->m_fNoteOn ||
                                (pBest->m_vrVolume > pVoice->m_vrVolume))
                            {
                                pBest = pVoice;
                            }
                        }
                    }
                }
            }
        }
        if (pBest->m_fTag)
        {
            pBest = NULL;
        }
    }
    return pBest;
}

CVoice *CSynth::StealVoice(DWORD dwPriority)

{
    CVoice *pVoice;
    CVoice *pBest = NULL;
    pVoice = m_VoicesInUse.GetHead();
    for (;pVoice != NULL;pVoice = pVoice->GetNext())
    {
        if (pVoice->m_dwPriority <= dwPriority)
        {
            if (!pBest)
            {
                pBest = pVoice;
            }
            else
            {
                if (pVoice->m_fNoteOn == FALSE)
                {
                    if ((pBest->m_fNoteOn == TRUE) ||
                        (pBest->m_vrVolume > pVoice->m_vrVolume))
                    {
                        pBest = pVoice;
                    }
                }
                else
                {
                    if (pBest->m_stStartTime > pVoice->m_stStartTime)
                    {
                        pBest = pVoice;
                    }
                }
            }
        }
    }
    if (pBest != NULL)
    {
        pBest->ClearVoice();
        pBest->m_fInUse = FALSE;
        m_VoicesInUse.Remove(pBest);

        pBest->SetNext(NULL);
    }
    return pBest;
}

void CSynth::QueueVoice(CVoice *pVoice)

/*  This function queues a voice in the list of currently
    synthesizing voices. It places them in the queue so that
    the higher priority voices are later in the queue. This
    allows the note stealing algorithm to take off the top of
    the queue.
    And, we want older playing notes to be later in the queue
    so the note ons and offs overlap properly. So, the queue is
    sorted in priority order with older notes later within one
    priority level.
*/

{
    CVoice *pScan = m_VoicesInUse.GetHead();
    CVoice *pNext = NULL;
    if (!pScan) // Empty list?
    {
        m_VoicesInUse.AddHead(pVoice);
        return;
    }
    if (pScan->m_dwPriority > pVoice->m_dwPriority)
    {   // Are we lower priority than the head of the list?
        m_VoicesInUse.AddHead(pVoice);
        return;
    }

    pNext = pScan->GetNext();
    for (;pNext;)
    {
        if (pNext->m_dwPriority > pVoice->m_dwPriority)
        {
            // Lower priority than next in the list.
            pScan->SetNext(pVoice);
            pVoice->SetNext(pNext);
            return;
        }
        pScan = pNext;
        pNext = pNext->GetNext();
    }
    // Reached the end of the list.
    pScan->SetNext(pVoice);
    pVoice->SetNext(NULL);
}

void CSynth::StealNotes(STIME stTime)

{
    CVoice *pVoice;
    long lToMove = m_nExtraVoices - m_VoicesExtra.GetCount();
    if (lToMove > 0)
    {
        for (;lToMove > 0;)
        {
            pVoice = m_VoicesFree.RemoveHead();
            if (pVoice != NULL)
            {
                m_VoicesExtra.AddHead(pVoice);
                lToMove--;
            }
            else break;
        }
        if (lToMove > 0)
        {
            pVoice = m_VoicesInUse.GetHead();
            for (;pVoice;pVoice = pVoice->GetNext())
            {
                if (pVoice->m_fTag) // Voice is already slated to be returned.
                {
                    lToMove--;
                }
            }
            for (;lToMove > 0;lToMove--)
            {
                pVoice = OldestVoice();
                if (pVoice != NULL)
                {
                    pVoice->QuickStopVoice(stTime);
                    m_BuildStats.dwNotesLost++;
                }
                else break;
            }
        }
    }
}

#ifndef i386
void CSynth::StartMix(short *pBuffer,DWORD dwLength, BOOL bInterleaved)
{
    DWORD dwIndex = 0;
    DWORD dwLen = dwLength << bInterleaved;

    for (; dwIndex < dwLen; dwIndex++)
    {
        pBuffer[dwIndex] <<= 1;
    }
}
#else
void CSynth::StartMix(short *pBuffer,DWORD dwLength, BOOL bInterleaved)
{
    DWORD dwIndex;
    DWORD dwLen = dwLength << bInterleaved;

    dwIndex = 0;

    if (m_sfMMXEnabled && dwLen >= 16)
    {
        dwIndex = (dwLen & ~0x0000000F);

        _asm {
            mov         eax, dwIndex
            mov         ebx, pBuffer
            lea         ebx, [ebx+eax*2]        // move to the end to start...
            neg         eax

TopOfLoop:
            movq        mm0, [ebx+eax*2]
            movq        mm1, [ebx+eax*2+8]

            psraw       mm0, 1

            movq        mm2, [ebx+eax*2+16]

            psraw       mm1, 1

            movq        mm3, [ebx+eax*2+24]

            psraw       mm2, 1

            movq        [ebx+eax*2], mm0

            psraw       mm3, 1

            movq        [ebx+eax*2+8], mm1
            movq        [ebx+eax*2+16], mm2
            movq        [ebx+eax*2+24], mm3

            add         eax, 16
            jl          TopOfLoop

            emms
        }
    }

    for (; dwIndex < dwLen; dwIndex++)
    {
        pBuffer[dwIndex] <<= 1;
    }
}
#endif

//////////////////////////////////////////////////////////////////
// FinishMix - C Base for Optimized code
#ifndef i386
void CSynth::FinishMix(short *pBuffer,DWORD dwLength, BOOL bInterleaved)

{
    DWORD dwIndex = 0;
    long lMax = (long) m_BuildStats.dwMaxAmplitude;
    long lTemp;
    DWORD dwLen = dwLength << bInterleaved;

    for (; dwIndex < dwLen; dwIndex++)
    {
        lTemp = pBuffer[dwIndex];
        lTemp <<= 1;

        if (lTemp < -32767) lTemp = -32767;
        if (lTemp > 32767) lTemp = 32767;

        pBuffer[dwIndex] = (short) lTemp;
        if (lTemp > lMax)
        {
            lMax = lTemp;
        }
        else if (lTemp < 0 && -lTemp > lMax)
        {
            lMax = -lTemp;
        }
    }
    m_BuildStats.dwMaxAmplitude = lMax;
}
#else
void CSynth::FinishMix(short *pBuffer,DWORD dwLength, BOOL bInterleaved)
{
    DWORD dwIndex;
    long lMax = (long) m_BuildStats.dwMaxAmplitude;
    long lTemp;
    DWORD dwLen = dwLength << bInterleaved;

    short PosMax, NegMax;

    PosMax =   (short) lMax;
    NegMax = - (short) lMax;

    dwIndex = 0;

    if (m_sfMMXEnabled && dwLen >= 4)
    {
        dwIndex = (dwLen & ~0x3);

        _asm {
            mov         eax, dwIndex
            mov         ebx, pBuffer
            lea         ebx, [ebx+eax*2]        // move to the end to start...
            neg         eax
            pxor        mm0, mm0
            movsx       ecx,  WORD PTR PosMax
            movsx       edx,  WORD PTR NegMax
Start:
            movq        mm1, QWORD PTR [ebx+eax*2]
            movq        mm2, mm1
            punpcklwd   mm1, mm0
            punpckhwd   mm2, mm0
            pslld       mm1, 16
            pslld       mm2, 16
            psrad       mm1, 15
            psrad       mm2, 15
            packssdw    mm1, mm2
            movq        QWORD PTR [ebx+eax*2], mm1
            movsx       esi, WORD PTR [ebx+eax*2]
            movsx       edi, WORD PTR [ebx+eax*2+2]

            cmp         esi, ecx
            jg          Max1
Max10:      cmp         edi, edx
            jl          Min1

Min10:      movsx       esi, WORD PTR [ebx+eax*2+4]
            cmp         edi, ecx
            jg          Max2
Max20:      cmp         edi, edx
            jl          Min2

Min20:      movsx       edi, WORD PTR [ebx+eax*2+6]
            cmp         esi, ecx
            jg          Max3
Max30:      cmp         esi, edx
            jl          Min3

Min30:      cmp         edi, ecx
            jg          Max4
Max40:      cmp         edi, edx
            jl          Min4

Min40:      add         eax, 4
            jl          Start
            jmp         Finished
Max1:
            mov         ecx, esi
            jmp         Max10
Max2:
            mov         ecx, edi
            jmp         Max20
Max3:
            mov         ecx, esi
            jmp         Max30
Max4:
            mov         ecx, edi
            jmp         Max40
Min1:
            mov         edx, esi
            jmp         Min10
Min2:
            mov         edx, edi
            jmp         Min20
Min3:
            mov         edx, esi
            jmp         Min30
Min4:
            mov         edx, edi
            jmp         Min40
Finished:
            emms
            mov         WORD PTR PosMax, cx
            mov         WORD PTR NegMax, dx
        }
        if (lMax < PosMax)
            lMax = PosMax;

        if (lMax < -NegMax)
            lMax = -NegMax;
    }

    for (; dwIndex < dwLen; dwIndex++)
    {
        lTemp = pBuffer[dwIndex];
        lTemp <<= 1;

        if (lTemp < -32767) lTemp = -32767;
        if (lTemp > 32767) lTemp = 32767;

        pBuffer[dwIndex] = (short) lTemp;
        if (lTemp > lMax)
        {
            lMax = lTemp;
        }
        else if (lTemp < 0 && -lTemp > lMax)
        {
            lMax = -lTemp;
        }
    }

    m_BuildStats.dwMaxAmplitude = lMax;
}
#endif

HRESULT CSynth::Unload(HANDLE hDownload,
                       HRESULT ( CALLBACK *lpFreeMemory)(HANDLE,HANDLE),
                       HANDLE hUserData)
{
    return m_Instruments.Unload( hDownload, lpFreeMemory, hUserData);
}

HRESULT CSynth::Download(LPHANDLE phDownload, void * pdwData, LPBOOL bpFree)

{
    return m_Instruments.Download( phDownload, (DWORD *) pdwData,  bpFree);
}

HRESULT CSynth::PlayBuffer(IDirectMusicSynthSink *pSynthSink, REFERENCE_TIME rt, LPBYTE lpBuffer, DWORD cbBuffer, ULONG ulCable)

{
    STIME stTime;

    ::EnterCriticalSection(&m_CriticalSection);

    if ( rt == 0 ) // Special case of time == 0.
    {
        stTime = m_stLastTime;
    }
    else
    {
        pSynthSink->RefTimeToSample(rt, &stTime);
    }

    PlayBuffer(stTime, rt, lpBuffer, cbBuffer, ulCable);

    ::LeaveCriticalSection(&m_CriticalSection);
    return S_OK;
}

HRESULT CSynth::PlayBuffer(IDirectSoundSynthSink *pSynthSink, REFERENCE_TIME rt, LPBYTE lpBuffer, DWORD cbBuffer, ULONG ulCable)

{
    STIME stTime;

    ::EnterCriticalSection(&m_CriticalSection);

    if ( rt == 0 ) // Special case of time == 0.
    {
        stTime = m_stLastTime;
    }
    else
    {
        pSynthSink->RefToSampleTime(rt, &stTime);
    }

    //Trace(0,"Reftime[%lx%08lx] LastTime[%lx%08lx] SampleTime[%lx%08lx]\n\r",(DWORD)(rt>>32),(DWORD)(rt&0x00000000ffffffff),(DWORD)(m_stLastTime>>32),(DWORD)(m_stLastTime&0x00000000ffffffff),(DWORD)(stTime>>32),(DWORD)(stTime&0x00000000ffffffff));

    PlayBuffer(stTime, rt, lpBuffer, cbBuffer, ulCable);

    ::LeaveCriticalSection(&m_CriticalSection);
    return S_OK;
}

HRESULT CSynth::PlayBuffer(STIME stTime, REFERENCE_TIME rt, LPBYTE lpBuffer, DWORD cbBuffer, ULONG ulCable)

{
    ::EnterCriticalSection(&m_CriticalSection);

    if (cbBuffer <= sizeof(DWORD))
    {
#ifdef DBG
        if (stTime < m_stLastTime)
        {
            static DWORD dwFailed = 0;
            if ((lpBuffer[0] & 0xF0) == MIDI_NOTEON)
            {
                if (!dwFailed)
                {
                    Trace(2,"Warning: Note On arrived too late to the synth, synth has mixed ahead by %ld samples. This could be caused by latency calculated too low.\n",
                         (long) (m_stLastTime - stTime));
                        dwFailed = 100;
                }
                dwFailed--;
            }
        }
        else if ((stTime - (10000 * 1000)) > m_stLastTime)
        {
            static DWORD dwFailed = 0;
            if ((lpBuffer[0] & 0xF0) == MIDI_NOTEON)
            {
                if (!dwFailed)
                {
                    Trace(2,"Warning: Note On at sample %ld, was stamped too late for synth, which is at mix time %ld, error is %ld samples\n",
                         (long) stTime, (long) m_stLastTime, (long) (m_stLastTime - stTime));
                        dwFailed = 100;
                }
                dwFailed--;
            }
        }
#endif
        if (ulCable <= m_dwControlCount)
        {
            if (ulCable == 0) // Play all groups if 0.
            {
                for (; ulCable < m_dwControlCount; ulCable++)
                {
                    m_ppControl[ulCable]->RecordMIDI(stTime,lpBuffer[0],
                        lpBuffer[1], lpBuffer[2]);
                }
            }
            else
            {
                m_ppControl[ulCable - 1]->RecordMIDI(stTime,lpBuffer[0],
                lpBuffer[1], lpBuffer[2]);

            }
        }
        else
        {
            Trace(1,"Error: MIDI event on channel group %ld is beyond range of %ld opened channel groups\n",
                ulCable, m_dwControlCount);
        }
    }
    else
    {
        if (ulCable <= m_dwControlCount)
        {
            if (ulCable == 0)
            {
                for (; ulCable < m_dwControlCount; ulCable++)
                {
                    m_ppControl[ulCable]->RecordSysEx(cbBuffer,
                        &lpBuffer[0], stTime);
                }
            }
            else
            {
                m_ppControl[ulCable-1]->RecordSysEx(cbBuffer,
                    &lpBuffer[0], stTime);
            }
        }
    }

    ::LeaveCriticalSection(&m_CriticalSection);
    return S_OK;
}

// Sets the stereo mode for the synth
// this value is currently only being used
// to deterim whether one can pan or not.
HRESULT CSynth::SetStereoMode(
    DWORD dwBufferFlags )
{
    HRESULT hr = S_OK;

    if (dwBufferFlags & BUFFERFLAG_INTERLEAVED )
    {
        m_dwStereo = TRUE;
    }
    else if (dwBufferFlags & BUFFERFLAG_MULTIBUFFER )
    {
        m_dwStereo = TRUE;
    }
    else
        m_dwStereo = FALSE;

    return hr;
}

void CSynth::ResetPerformanceStats()

{
    m_BuildStats.dwNotesLost = 0;
    m_BuildStats.dwTotalTime = 0;
    m_BuildStats.dwVoices = 0;
    m_BuildStats.dwTotalSamples = 0;
    m_BuildStats.dwCPU = 0;
    m_BuildStats.dwMaxAmplitude = 0;
    m_CopyStats = m_BuildStats;
}

HRESULT CSynth::AllNotesOff()

{
    CVoice *pVoice;
    ::EnterCriticalSection(&m_CriticalSection);
    while (pVoice = m_VoicesInUse.RemoveHead())
    {
        pVoice->ClearVoice();
        pVoice->m_fInUse = FALSE;
        m_VoicesFree.AddHead(pVoice);

        if (pVoice->m_stStartTime < m_stLastStats)
        {
            m_BuildStats.dwTotalSamples += (long) (pVoice->m_stStopTime - m_stLastStats);
        }
        else
        {
            m_BuildStats.dwTotalSamples += (long) (pVoice->m_stStopTime - pVoice->m_stStartTime);
        }
    }
    ::LeaveCriticalSection(&m_CriticalSection);
    return (S_OK);
}

HRESULT CSynth::SetChannelPriority(
    DWORD dwChannelGroup,
    DWORD dwChannel,
    DWORD dwPriority)
{
    HRESULT hr = S_OK;

    ::EnterCriticalSection(&m_CriticalSection);

    dwChannelGroup--;
    if ((dwChannelGroup >= m_dwControlCount) || (dwChannel > 15))
    {
        Trace(1,"Error: Request to set channel priority on channel group %ld, channel %ld, is out of range.\n",
            dwChannelGroup,dwChannel);
        hr = E_INVALIDARG;
    }
    else
    {
        if (m_ppControl)
        {
            hr = m_ppControl[dwChannelGroup]->SetChannelPriority(dwChannel,dwPriority);
        }
    }
    ::LeaveCriticalSection(&m_CriticalSection);

    return hr;
}

HRESULT CSynth::GetChannelPriority(
    DWORD dwChannelGroup,
    DWORD dwChannel,
    LPDWORD pdwPriority)
{
    HRESULT hr = S_OK;

    ::EnterCriticalSection(&m_CriticalSection);

    dwChannelGroup--;
    if ((dwChannelGroup >= m_dwControlCount) || (dwChannel > 15))
    {
        Trace(1,"Error: Request to get channel priority on channel group %ld, channel %ld, is out of range.\n",
            dwChannelGroup,dwChannel);
        hr = E_INVALIDARG;
    }
    else
    {
        if (m_ppControl)
        {
            hr = m_ppControl[dwChannelGroup]->GetChannelPriority(dwChannel,pdwPriority);
        }
    }
    ::LeaveCriticalSection(&m_CriticalSection);

    return hr;
}


//////////////////////////////////////////////////////////
// Directx8 Methods

HRESULT CSynth::PlayVoice(
    IDirectSoundSynthSink *pSynthSink,
    REFERENCE_TIME rt,
    DWORD dwVoiceId,
    DWORD dwChannelGroup,
    DWORD dwChannel,
    DWORD dwDLId,
    VREL vrVolume,
    PREL prPitch,
    SAMPLE_TIME stVoiceStart,
    SAMPLE_TIME stLoopStart,
    SAMPLE_TIME stLoopEnd
    )
{
    HRESULT hr = S_OK;
    STIME stTime;

    ::EnterCriticalSection(&m_CriticalSection);

    dwChannelGroup--;
    if ((dwChannelGroup >= m_dwControlCount) || (dwChannel > 15))
    {
        Trace(1,"Error: Request to set play voice on channel group %ld, channel %ld, is out of range.\n",
            dwChannelGroup,dwChannel);
        hr = E_INVALIDARG;
    }

    if ( rt == 0 ) // Special case of time == 0.
    {
        stTime = m_stLastTime;
    }
    else
    {
        pSynthSink->RefToSampleTime(rt, &stTime);
    }

    CWaveArt *pWaveArt = m_Instruments.GetWaveArt(dwDLId);
    if ( pWaveArt )
        m_ppControl[dwChannelGroup]->RecordWaveEvent(
            stTime,
            (BYTE)(dwChannel & 0xF),
            dwVoiceId,
            vrVolume,
            prPitch,
            stVoiceStart,
            stLoopStart,
            stLoopEnd,
            pWaveArt);

    ::LeaveCriticalSection(&m_CriticalSection);

    return hr;
}

HRESULT CSynth::StopVoice(
    IDirectSoundSynthSink *pSynthSink,
    REFERENCE_TIME rt,
    DWORD dwVoiceId )
{
    HRESULT hr = S_OK;
    STIME stTime;

    ::EnterCriticalSection(&m_CriticalSection);

    if ( rt == 0 )  // Special case of time == 0.
    {
        stTime = m_stLastTime;
    }
    else
    {
        pSynthSink->RefToSampleTime(rt, &stTime);
    }

    CVoice * pVoice = m_VoicesInUse.GetHead();
    bool fFoundVoice = false;
    for (;pVoice != NULL;pVoice = pVoice->GetNext())
    {
        if ( pVoice->m_dwVoiceId == dwVoiceId )
        {
            pVoice->m_stWaveStopTime = stTime;
            fFoundVoice = true;
        }
    }
    if (!fFoundVoice)
    {
        TraceI(2, "Warning: Synth couldn't find voice %d to stop.\n", dwVoiceId);
        for (DWORD dwX = 0; dwX < m_dwControlCount; dwX++)
        {
            m_ppControl[dwX]->FlushWaveByStopTime(dwVoiceId, stTime);
        }
    }

    ::LeaveCriticalSection(&m_CriticalSection);

    return hr;
}

HRESULT CSynth::GetVoiceState(
    DWORD dwVoice[],
    DWORD cbVoice,
    DMUS_VOICE_STATE VoiceState[] )
{
    HRESULT hr = E_FAIL;

    ::EnterCriticalSection(&m_CriticalSection);

    for ( DWORD i = 0; i < cbVoice; i++ )
    {
        VoiceState[i].bExists = FALSE;
        VoiceState[i].spPosition = 0;

        CVoice * pVoice = m_VoicesInUse.GetHead();
        for (;pVoice != NULL;pVoice = pVoice->GetNext())
        {
            if ( pVoice->m_dwVoiceId == dwVoice[i] )
            {
                VoiceState[i].bExists = TRUE;
                VoiceState[i].spPosition = pVoice->GetCurrentPos();
                break;
            }
        }
    }

    ::LeaveCriticalSection(&m_CriticalSection);

    return S_OK;
}

HRESULT CSynth::Refresh(
    DWORD dwDownloadID,
    DWORD dwFlags)
{
    HRESULT hr = S_OK;

    ::EnterCriticalSection(&m_CriticalSection);

    CWave *pWave = m_Instruments.GetWave(dwDownloadID);
    if ( pWave )
    {
        if ( pWave->m_bValid )
        {
            Trace(1,"Error: Attempting to validate already validated streaming buffer\n\r");
            hr = E_FAIL;
        }

        if ( pWave->m_bActive )
        {
            Trace(1,"Error: Attempting to validate active playing streaming buffer\n\r");
            hr = E_FAIL;
        }

        if (SUCCEEDED(hr))
        {
            pWave->m_bValid = TRUE;

            if (pWave->m_bSampleType == SFORMAT_8)
            {
                DWORD dwX;
                char *pData = (char *) pWave->m_pnWave;
                for (dwX = 0; dwX < pWave->m_dwSampleLength; dwX++)
                {
                    pData[dwX] -= (char) 128;
                }
            }

            // Indicate that we did find a vaild download id
            hr = S_OK;
        }
    }

    ::LeaveCriticalSection(&m_CriticalSection);

    return hr;
}

HRESULT CSynth::AssignChannelToBuses(
    DWORD dwChannelGroup,
    DWORD dwChannel,
    LPDWORD pdwBuses,
    DWORD cBuses)
{
    HRESULT hr = S_OK;

    ::EnterCriticalSection(&m_CriticalSection);

//>>>>>>> Probably need a better check here since panning is only valid for left and right?

    dwChannelGroup--;
    if ((dwChannelGroup >= m_dwControlCount) || (dwChannel > 15))
    {
        hr = E_INVALIDARG;
    }

    if (SUCCEEDED(hr))
    {
        hr = m_ppControl[dwChannelGroup]->AssignChannelToBuses(dwChannel, pdwBuses, cBuses);
    }

    ::LeaveCriticalSection(&m_CriticalSection);

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\XboxSynth\debug.h ===
//
// debug.h
// 
// Copyright (c) 1997-1999 Microsoft Corporation. All rights reserved.
//
// Note:
//

#ifndef DEBUG_H
#define DEBUG_H

#include <windows.h>

#define DM_DEBUG_CRITICAL		1	// Used to include critical messages
#define DM_DEBUG_NON_CRITICAL	2	// Used to include level 1 plus important non-critical messages
#define DM_DEBUG_STATUS			3	// Used to include level 1 and level 2 plus status\state messages
#define DM_DEBUG_FUNC_FLOW		4	// Used to include level 1, level 2 and level 3 plus function flow messages
#define DM_DEBUG_ALL			5	// Used to include all debug messages

// Default to no debug output compiled
//
#define Trace
#define TraceI
#define assert(exp) ((void)0)

#ifdef DBG

// Checked build: include at least external debug spew
//
extern void DebugInit(void);
extern void DebugTrace(int iDebugLevel, LPSTR pstrFormat, ...);
extern void DebugAssert(LPSTR szExp, LPSTR szFile, ULONG ulLine);

# undef Trace
# define Trace DebugTrace

# undef assert
# define assert(exp) (void)( (exp) || (DebugAssert(#exp, __FILE__, __LINE__), 0) )

// If internal build flag set, include everything
//
# ifdef DMUSIC_INTERNAL
#  undef TraceI
#  define TraceI DebugTrace
# endif

#endif  // #ifdef DBG
#endif  // #ifndef DEBUG_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\XboxSynth\dsoundp.h ===
/*==========================================================================;
 *
 *  Copyright (C) 1995-2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       dsound.h
 *  Content:    DirectSound include file
 *@@BEGIN_MSINTERNAL
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *  2/10/96     angusm  Added CLSID for DirectSound
 *  2/11/96     angusm  Added DSERR_UNINITIALIZED
 *  2/12/96     angusm  Added DSSCL_UNINITIALIZED
 *  3/5/96      angusm  Removed DSSCL_UNINITIALIZED
 *  1/29/97     dereks  Added boundaries, LPC* and REFGUIDs
 *  4/10/97     dereks  Added IDirectSoundCapture
 *  4/11/97     dereks  Added IKsPropertySet
 *  4/25/97     johnnyl Added DSCCREATE_WAVEMAPPED flag
 *  5/7/97      johnnyl Added DirectSoundCaptureBuffer::Initialize method
 *  5/8/97      dereks  Backed out REFGUIDs
 *  5/9/97      johnnyl Changed DSCCREATE_WAVEMAPPED to DSCBCAPS_WAVEMAPPED
 *                      Added DSCBLOCK_ENTIREBUFFER flag
 *  5/29/97     dereks  IDirectSoundPropertySet => IKsPropertySet
 *  7/10/98     dereks  Added DirectX 6.1 features
 *  8/19/98     dereks  Moved private object to dsprv.h
 *  9/15/98     dereks  Added DirectX 7.0 features
 *  7/6/99      duganp  Added DirectX 8.0 features
 *  10/29/99    duganp  Added DirectX 7.1 features
 *  06/06/00    alanlu  Clean up DSFX_I3DL2XXX constants
 *@@END_MSINTERNAL
 *
 **************************************************************************/

#define COM_NO_WINDOWS_H
#include <objbase.h>
#include <float.h>

#ifndef DIRECTSOUND_VERSION
#define DIRECTSOUND_VERSION 0x0800  /* Version 8.0 */
#endif

#ifdef __cplusplus
extern "C" {
#endif // __cplusplus

#ifndef __DSOUND_INCLUDED__
#define __DSOUND_INCLUDED__

/* Type definitions shared with Direct3D */

#ifndef DX_SHARED_DEFINES

typedef float D3DVALUE, *LPD3DVALUE;

#ifndef D3DCOLOR_DEFINED
typedef DWORD D3DCOLOR;
#define D3DCOLOR_DEFINED
#endif

#ifndef LPD3DCOLOR_DEFINED
typedef DWORD *LPD3DCOLOR;
#define LPD3DCOLOR_DEFINED
#endif

#ifndef D3DVECTOR_DEFINED
typedef struct _D3DVECTOR {
    float x;
    float y;
    float z;
} D3DVECTOR;
#define D3DVECTOR_DEFINED
#endif

#ifndef LPD3DVECTOR_DEFINED
typedef D3DVECTOR *LPD3DVECTOR;
#define LPD3DVECTOR_DEFINED
#endif

#define DX_SHARED_DEFINES
#endif // DX_SHARED_DEFINES

#define _FACDS  0x878   /* DirectSound's facility code */
#define MAKE_DSHRESULT(code)  MAKE_HRESULT(1, _FACDS, code)

// DirectSound Component GUID {47D4D946-62E8-11CF-93BC-444553540000}
DEFINE_GUID(CLSID_DirectSound, 0x47d4d946, 0x62e8, 0x11cf, 0x93, 0xbc, 0x44, 0x45, 0x53, 0x54, 0x0, 0x0);

// DirectSound 8.0 Component GUID {3901CC3F-84B5-4FA4-BA35-AA8172B8A09B}
DEFINE_GUID(CLSID_DirectSound8, 0x3901cc3f, 0x84b5, 0x4fa4, 0xba, 0x35, 0xaa, 0x81, 0x72, 0xb8, 0xa0, 0x9b);

// DirectSound Capture Component GUID {B0210780-89CD-11D0-AF08-00A0C925CD16}
DEFINE_GUID(CLSID_DirectSoundCapture, 0xb0210780, 0x89cd, 0x11d0, 0xaf, 0x8, 0x0, 0xa0, 0xc9, 0x25, 0xcd, 0x16);

// DirectSound 8.0 Capture Component GUID {E4BCAC13-7F99-4908-9A8E-74E3BF24B6E1}
DEFINE_GUID(CLSID_DirectSoundCapture8, 0xe4bcac13, 0x7f99, 0x4908, 0x9a, 0x8e, 0x74, 0xe3, 0xbf, 0x24, 0xb6, 0xe1);

// DirectSound Full Duplex Component GUID {FEA4300C-7959-4147-B26A-2377B9E7A91D}
DEFINE_GUID(CLSID_DirectSoundFullDuplex, 0xfea4300c, 0x7959, 0x4147, 0xb2, 0x6a, 0x23, 0x77, 0xb9, 0xe7, 0xa9, 0x1d);

//@@BEGIN_MSINTERNAL
// DirectSound Buffer Descriptor GUID {B2F586D4-5558-49D1-A07B3249DBBB33C2}
DEFINE_GUID(CLSID_DirectSoundBufferConfig, 0xb2f586d4, 0x5558, 0x49d1, 0xa0, 0x7b, 0x32, 0x49, 0xdb, 0xbb, 0x33, 0xc2);
//@@END_MSINTERNAL

//@@BEGIN_MSINTERNAL
// Magic private DirectSound buffer descriptor GUID {74A794F9-FDD2-4684-88831CB3CA6E6DA6}
DEFINE_GUID(CLSID_PRIVATE_CDirectSoundBufferConfig, 0x74a794f9, 0xfdd2, 0x4684, 0x88, 0x83, 0x1c, 0xb3, 0xca, 0x6e, 0x6d, 0xa6);
//@@END_MSINTERNAL

// DirectSound default playback device GUID {DEF00000-9C6D-47ED-AAF1-4DDA8F2B5C03}
DEFINE_GUID(DSDEVID_DefaultPlayback, 0xdef00000, 0x9c6d, 0x47ed, 0xaa, 0xf1, 0x4d, 0xda, 0x8f, 0x2b, 0x5c, 0x03);

// DirectSound default capture device GUID {DEF00001-9C6D-47ED-AAF1-4DDA8F2B5C03}
DEFINE_GUID(DSDEVID_DefaultCapture, 0xdef00001, 0x9c6d, 0x47ed, 0xaa, 0xf1, 0x4d, 0xda, 0x8f, 0x2b, 0x5c, 0x03);

// DirectSound default device for voice playback {DEF00002-9C6D-47ED-AAF1-4DDA8F2B5C03}
DEFINE_GUID(DSDEVID_DefaultVoicePlayback, 0xdef00002, 0x9c6d, 0x47ed, 0xaa, 0xf1, 0x4d, 0xda, 0x8f, 0x2b, 0x5c, 0x03);

// DirectSound default device for voice capture {DEF00003-9C6D-47ED-AAF1-4DDA8F2B5C03}
DEFINE_GUID(DSDEVID_DefaultVoiceCapture, 0xdef00003, 0x9c6d, 0x47ed, 0xaa, 0xf1, 0x4d, 0xda, 0x8f, 0x2b, 0x5c, 0x03);


//
// Forward declarations for interfaces.
// 'struct' not 'class' per the way DECLARE_INTERFACE_ is defined
//

#ifdef __cplusplus
struct IDirectSound;
struct IDirectSoundBuffer;
struct IDirectSound3DListener;
struct IDirectSound3DBuffer;
struct IDirectSoundCapture;
struct IDirectSoundCaptureBuffer;
struct IDirectSoundNotify;
#endif // __cplusplus

//@@BEGIN_MSINTERNAL

//
// DirectSound 7.1 (Windows ME) interface.
//

#if DIRECTSOUND_VERSION >= 0x0701
#ifdef __cplusplus
struct IDirectSoundCaptureBuffer7_1;
#endif
#endif

//@@END_MSINTERNAL

//
// DirectSound 8.0 interfaces.
//

#if DIRECTSOUND_VERSION >= 0x0800

#ifdef __cplusplus
struct IDirectSound8;
struct IDirectSoundBuffer8;
struct IDirectSoundCaptureBuffer8;
//@@BEGIN_MSINTERNAL
struct IDirectSoundFXSend;
//@@END_MSINTERNAL
struct IDirectSoundFXGargle;
struct IDirectSoundFXChorus;
struct IDirectSoundFXFlanger;
struct IDirectSoundFXEcho;
struct IDirectSoundFXDistortion;
struct IDirectSoundFXCompressor;
struct IDirectSoundFXParamEq;
struct IDirectSoundFXWavesReverb;
//@@BEGIN_MSINTERNAL
///struct IDirectSoundFXI3DL2Source;
//@@END_MSINTERNAL
struct IDirectSoundFXI3DL2Reverb;
struct IDirectSoundCaptureFXAec;
struct IDirectSoundCaptureFXNoiseSuppress;
//@@BEGIN_MSINTERNAL
struct IDirectSoundCaptureFXAgc;
struct IDirectSoundCaptureFXMicArray;
struct IDirectSoundDMOProxy;
struct IDirectSoundFXI3DL2SourceEnv;
struct IDirectSound3DBufferPrivate;
//@@END_MSINTERNAL
struct IDirectSoundFullDuplex;
#endif // __cplusplus

// IDirectSound8, IDirectSoundBuffer8 and IDirectSoundCaptureBuffer8 are the
// only DirectSound 7.0 interfaces with changed functionality in version 8.0.
// The other level 8 interfaces as equivalent to their level 7 counterparts:

#define IDirectSoundCapture8            IDirectSoundCapture
#define IDirectSound3DListener8         IDirectSound3DListener
#define IDirectSound3DBuffer8           IDirectSound3DBuffer
#define IDirectSoundNotify8             IDirectSoundNotify
//@@BEGIN_MSINTERNAL
#define IDirectSoundFXSend8             IDirectSoundFXSend
//@@END_MSINTERNAL
#define IDirectSoundFXGargle8           IDirectSoundFXGargle
#define IDirectSoundFXChorus8           IDirectSoundFXChorus
#define IDirectSoundFXFlanger8          IDirectSoundFXFlanger
#define IDirectSoundFXEcho8             IDirectSoundFXEcho
#define IDirectSoundFXDistortion8       IDirectSoundFXDistortion
#define IDirectSoundFXCompressor8       IDirectSoundFXCompressor
#define IDirectSoundFXParamEq8          IDirectSoundFXParamEq
#define IDirectSoundFXWavesReverb8      IDirectSoundFXWavesReverb
//@@BEGIN_MSINTERNAL
///#define IDirectSoundFXI3DL2Source8      IDirectSoundFXI3DL2Source
//@@END_MSINTERNAL
#define IDirectSoundFXI3DL2Reverb8      IDirectSoundFXI3DL2Reverb
#define IDirectSoundCaptureFXAec8       IDirectSoundCaptureFXAec
#define IDirectSoundCaptureFXNoiseSuppress8 IDirectSoundCaptureFXNoiseSuppress
//@@BEGIN_MSINTERNAL
#define IDirectSoundCaptureFXAgc8       IDirectSoundCaptureFXAgc
#define IDirectSoundCaptureFXMicArray8  IDirectSoundCaptureFXMicArray
#define IDirectSoundDMOProxy8           IDirectSoundDMOProxy
#define IDirectSoundFXI3DL2SourceEnv8   IDirectSoundFXI3DL2SourceEnv
#define IDirectSound3DBufferPrivate8    IDirectSound3DBufferPrivate
//@@END_MSINTERNAL
#define IDirectSoundFullDuplex8         IDirectSoundFullDuplex

#endif // DIRECTSOUND_VERSION >= 0x0800


typedef struct IDirectSound                 *LPDIRECTSOUND;
typedef struct IDirectSoundBuffer           *LPDIRECTSOUNDBUFFER;
typedef struct IDirectSound3DListener       *LPDIRECTSOUND3DLISTENER;
typedef struct IDirectSound3DBuffer         *LPDIRECTSOUND3DBUFFER;
typedef struct IDirectSoundCapture          *LPDIRECTSOUNDCAPTURE;
typedef struct IDirectSoundCaptureBuffer    *LPDIRECTSOUNDCAPTUREBUFFER;
typedef struct IDirectSoundNotify           *LPDIRECTSOUNDNOTIFY;

//@@BEGIN_MSINTERNAL
#if DIRECTSOUND_VERSION >= 0x0701
typedef struct IDirectSoundCaptureBuffer7_1 *LPDIRECTSOUNDCAPTUREBUFFER7_1;
#endif
//@@END_MSINTERNAL

#if DIRECTSOUND_VERSION >= 0x0800
//@@BEGIN_MSINTERNAL
typedef struct IDirectSoundFXSend           *LPDIRECTSOUNDFXSEND;
//@@END_MSINTERNAL
typedef struct IDirectSoundFXGargle         *LPDIRECTSOUNDFXGARGLE;
typedef struct IDirectSoundFXChorus         *LPDIRECTSOUNDFXCHORUS;
typedef struct IDirectSoundFXFlanger        *LPDIRECTSOUNDFXFLANGER;
typedef struct IDirectSoundFXEcho           *LPDIRECTSOUNDFXECHO;
typedef struct IDirectSoundFXDistortion     *LPDIRECTSOUNDFXDISTORTION;
typedef struct IDirectSoundFXCompressor     *LPDIRECTSOUNDFXCOMPRESSOR;
typedef struct IDirectSoundFXParamEq        *LPDIRECTSOUNDFXPARAMEQ;
typedef struct IDirectSoundFXWavesReverb    *LPDIRECTSOUNDFXWAVESREVERB;
//@@BEGIN_MSINTERNAL
///typedef struct IDirectSoundFXI3DL2Source    *LPDIRECTSOUNDFXI3DL2SOURCE;
//@@END_MSINTERNAL
typedef struct IDirectSoundFXI3DL2Reverb    *LPDIRECTSOUNDFXI3DL2REVERB;
typedef struct IDirectSoundCaptureFXAec     *LPDIRECTSOUNDCAPTUREFXAEC;
typedef struct IDirectSoundCaptureFXNoiseSuppress *LPDIRECTSOUNDCAPTUREFXNOISESUPPRESS;
//@@BEGIN_MSINTERNAL
typedef struct IDirectSoundCaptureFXAgc     *LPDIRECTSOUNDCAPTUREFXAGC;
typedef struct IDirectSoundCaptureFXMicArray *LPDIRECTSOUNDCAPTUREFXMICARRAY;
typedef struct IDirectSoundDMOProxy         *LPDIRECTSOUNDDMOPROXY;
typedef struct IDirectSoundFXI3DL2SourceEnv *LPDIRECTSOUNDFXI3DL2SOURCEENV;
typedef struct IDirectSound3DBufferPrivate  *LPDIRECTSOUND3DBUFFERPRIVATE;
//@@END_MSINTERNAL
typedef struct IDirectSoundFullDuplex       *LPDIRECTSOUNDFULLDUPLEX;

typedef struct IDirectSound8                *LPDIRECTSOUND8;
typedef struct IDirectSoundBuffer8          *LPDIRECTSOUNDBUFFER8;
typedef struct IDirectSound3DListener8      *LPDIRECTSOUND3DLISTENER8;
typedef struct IDirectSound3DBuffer8        *LPDIRECTSOUND3DBUFFER8;
typedef struct IDirectSoundCapture8         *LPDIRECTSOUNDCAPTURE8;
typedef struct IDirectSoundCaptureBuffer8   *LPDIRECTSOUNDCAPTUREBUFFER8;
typedef struct IDirectSoundNotify8          *LPDIRECTSOUNDNOTIFY8;
//@@BEGIN_MSINTERNAL
typedef struct IDirectSoundFXSend8          *LPDIRECTSOUNDFXSEND8;
//@@END_MSINTERNAL
typedef struct IDirectSoundFXGargle8        *LPDIRECTSOUNDFXGARGLE8;
typedef struct IDirectSoundFXChorus8        *LPDIRECTSOUNDFXCHORUS8;
typedef struct IDirectSoundFXFlanger8       *LPDIRECTSOUNDFXFLANGER8;
typedef struct IDirectSoundFXEcho8          *LPDIRECTSOUNDFXECHO8;
typedef struct IDirectSoundFXDistortion8    *LPDIRECTSOUNDFXDISTORTION8;
typedef struct IDirectSoundFXCompressor8    *LPDIRECTSOUNDFXCOMPRESSOR8;
typedef struct IDirectSoundFXParamEq8       *LPDIRECTSOUNDFXPARAMEQ8;
typedef struct IDirectSoundFXWavesReverb8   *LPDIRECTSOUNDFXWAVESREVERB8;
//@@BEGIN_MSINTERNAL
///typedef struct IDirectSoundFXI3DL2Source8   *LPDIRECTSOUNDFXI3DL2SOURCE8;
//@@END_MSINTERNAL
typedef struct IDirectSoundFXI3DL2Reverb8   *LPDIRECTSOUNDFXI3DL2REVERB8;
typedef struct IDirectSoundCaptureFXAec8    *LPDIRECTSOUNDCAPTUREFXAEC8;
typedef struct IDirectSoundCaptureFXNoiseSuppress8 *LPDIRECTSOUNDCAPTUREFXNOISESUPPRESS8;
//@@BEGIN_MSINTERNAL
typedef struct IDirectSoundCaptureFXAgc8    *LPDIRECTSOUNDCAPTUREFXAGC8;
typedef struct IDirectSoundCaptureFXMicArray8 *LPDIRECTSOUNDCAPTUREFXMICARRAY8;
typedef struct IDirectSoundDMOProxy8        *LPDIRECTSOUNDDMOPROXY8;
typedef struct IDirectSoundFXI3DL2SourceEnv8 *LPDIRECTSOUNDFXI3DL2SOURCEENV8;
typedef struct IDirectSound3DBufferPrivate8 *LPDIRECTSOUND3DBUFFERPRIVATE8;
//@@END_MSINTERNAL
typedef struct IDirectSoundFullDuplex8      *LPDIRECTSOUNDFULLDUPLEX8;

#endif // DIRECTSOUND_VERSION >= 0x0800

//
// IID definitions for the unchanged DirectSound 8.0 interfaces
//

#if DIRECTSOUND_VERSION >= 0x0800
#define IID_IDirectSoundCapture8            IID_IDirectSoundCapture
#define IID_IDirectSound3DListener8         IID_IDirectSound3DListener
#define IID_IDirectSound3DBuffer8           IID_IDirectSound3DBuffer
#define IID_IDirectSoundNotify8             IID_IDirectSoundNotify
//@@BEGIN_MSINTERNAL
#define IID_IDirectSoundFXSend8             IID_IDirectSoundFXSend
//@@END_MSINTERNAL
#define IID_IDirectSoundFXGargle8           IID_IDirectSoundFXGargle
#define IID_IDirectSoundFXChorus8           IID_IDirectSoundFXChorus
#define IID_IDirectSoundFXFlanger8          IID_IDirectSoundFXFlanger
#define IID_IDirectSoundFXEcho8             IID_IDirectSoundFXEcho
#define IID_IDirectSoundFXDistortion8       IID_IDirectSoundFXDistortion
#define IID_IDirectSoundFXCompressor8       IID_IDirectSoundFXCompressor
#define IID_IDirectSoundFXParamEq8          IID_IDirectSoundFXParamEq
#define IID_IDirectSoundFXWavesReverb8      IID_IDirectSoundFXWavesReverb
//@@BEGIN_MSINTERNAL
///#define IID_IDirectSoundFXI3DL2Source8      IID_IDirectSoundFXI3DL2Source
//@@END_MSINTERNAL
#define IID_IDirectSoundFXI3DL2Reverb8      IID_IDirectSoundFXI3DL2Reverb
#define IID_IDirectSoundCaptureFXAec8       IID_IDirectSoundCaptureFXAec
#define IID_IDirectSoundCaptureFXNoiseSuppress8 IID_IDirectSoundCaptureFXNoiseSuppress
//@@BEGIN_MSINTERNAL
#define IID_IDirectSoundCaptureFXAgc8       IID_IDirectSoundCaptureFXAgc
#define IID_IDirectSoundCaptureFXMicArray8  IID_IDirectSoundCaptureFXMicArray
#define IID_IDirectSoundDMOProxy8           IID_IDirectSoundDMOProxy
#define IID_IDirectSoundFXI3DL2SourceEnv8   IID_IDirectSoundFXI3DL2SourceEnv
#define IID_IDirectSound3DBufferPrivate8    IID_IDirectSound3DBufferPrivate
//@@END_MSINTERNAL
#define IID_IDirectSoundFullDuplex8         IID_IDirectSoundFullDuplex
#endif // DIRECTSOUND_VERSION >= 0x0800

//
// Compatibility typedefs
//

#ifndef _LPCWAVEFORMATEX_DEFINED
#define _LPCWAVEFORMATEX_DEFINED
typedef const WAVEFORMATEX *LPCWAVEFORMATEX;
#endif // _LPCWAVEFORMATEX_DEFINED

#ifndef __LPCGUID_DEFINED__
#define __LPCGUID_DEFINED__
typedef const GUID *LPCGUID;
#endif // __LPCGUID_DEFINED__

typedef LPDIRECTSOUND *LPLPDIRECTSOUND;
typedef LPDIRECTSOUNDBUFFER *LPLPDIRECTSOUNDBUFFER;
typedef LPDIRECTSOUND3DLISTENER *LPLPDIRECTSOUND3DLISTENER;
typedef LPDIRECTSOUND3DBUFFER *LPLPDIRECTSOUND3DBUFFER;
typedef LPDIRECTSOUNDCAPTURE *LPLPDIRECTSOUNDCAPTURE;
typedef LPDIRECTSOUNDCAPTUREBUFFER *LPLPDIRECTSOUNDCAPTUREBUFFER;
typedef LPDIRECTSOUNDNOTIFY *LPLPDIRECTSOUNDNOTIFY;

#if DIRECTSOUND_VERSION >= 0x0800
typedef LPDIRECTSOUND8 *LPLPDIRECTSOUND8;
typedef LPDIRECTSOUNDBUFFER8 *LPLPDIRECTSOUNDBUFFER8;
typedef LPDIRECTSOUNDCAPTURE8 *LPLPDIRECTSOUNDCAPTURE8;
typedef LPDIRECTSOUNDCAPTUREBUFFER8 *LPLPDIRECTSOUNDCAPTUREBUFFER8;
#endif // DIRECTSOUND_VERSION >= 0x0800

//
// Structures
//

typedef struct _DSCAPS
{
    DWORD           dwSize;
    DWORD           dwFlags;
    DWORD           dwMinSecondarySampleRate;
    DWORD           dwMaxSecondarySampleRate;
    DWORD           dwPrimaryBuffers;
    DWORD           dwMaxHwMixingAllBuffers;
    DWORD           dwMaxHwMixingStaticBuffers;
    DWORD           dwMaxHwMixingStreamingBuffers;
    DWORD           dwFreeHwMixingAllBuffers;
    DWORD           dwFreeHwMixingStaticBuffers;
    DWORD           dwFreeHwMixingStreamingBuffers;
    DWORD           dwMaxHw3DAllBuffers;
    DWORD           dwMaxHw3DStaticBuffers;
    DWORD           dwMaxHw3DStreamingBuffers;
    DWORD           dwFreeHw3DAllBuffers;
    DWORD           dwFreeHw3DStaticBuffers;
    DWORD           dwFreeHw3DStreamingBuffers;
    DWORD           dwTotalHwMemBytes;
    DWORD           dwFreeHwMemBytes;
    DWORD           dwMaxContigFreeHwMemBytes;
    DWORD           dwUnlockTransferRateHwBuffers;
    DWORD           dwPlayCpuOverheadSwBuffers;
//@@BEGIN_MSINTERNAL
    // dwReserved1 == minor ver number, dwReserved2 == major ver number.
//@@END_MSINTERNAL
    DWORD           dwReserved1;
    DWORD           dwReserved2;
} DSCAPS, *LPDSCAPS;

typedef const DSCAPS *LPCDSCAPS;

typedef struct _DSBCAPS
{
    DWORD           dwSize;
    DWORD           dwFlags;
    DWORD           dwBufferBytes;
    DWORD           dwUnlockTransferRate;
    DWORD           dwPlayCpuOverhead;
} DSBCAPS, *LPDSBCAPS;

typedef const DSBCAPS *LPCDSBCAPS;

#if DIRECTSOUND_VERSION >= 0x0800

    typedef struct _DSEFFECTDESC
    {
        DWORD       dwSize;
        DWORD       dwFlags;
        GUID        guidDSFXClass;
        DWORD_PTR   dwReserved1;
        DWORD_PTR   dwReserved2;
    } DSEFFECTDESC, *LPDSEFFECTDESC;
    typedef const DSEFFECTDESC *LPCDSEFFECTDESC;

    #define DSFX_LOCHARDWARE    0x00000001
    #define DSFX_LOCSOFTWARE    0x00000002
//@@BEGIN_MSINTERNAL
    #define DSFX_OPTIONAL       0x00000004
    #define DSFX_VALIDFLAGS     (DSFX_LOCHARDWARE | DSFX_LOCSOFTWARE)
//@@END_MSINTERNAL

    enum
    {
        DSFXR_PRESENT,          // 0
        DSFXR_LOCHARDWARE,      // 1
        DSFXR_LOCSOFTWARE,      // 2
        DSFXR_UNALLOCATED,      // 3
        DSFXR_FAILED,           // 4
        DSFXR_UNKNOWN,          // 5
        DSFXR_SENDLOOP          // 6
    };

    typedef struct _DSCEFFECTDESC
    {
        DWORD       dwSize;
        DWORD       dwFlags;
        GUID        guidDSCFXClass;
        GUID        guidDSCFXInstance;
        DWORD       dwReserved1;
        DWORD       dwReserved2;
    } DSCEFFECTDESC, *LPDSCEFFECTDESC;
    typedef const DSCEFFECTDESC *LPCDSCEFFECTDESC;

    #define DSCFX_LOCHARDWARE   0x00000001
    #define DSCFX_LOCSOFTWARE   0x00000002
//@@BEGIN_MSINTERNAL
    #define DSCFX_RESERVED      0x00000020
//@@END_MSINTERNAL

//@@BEGIN_MSINTERNAL
    #define DSCFX_LOCMASK         (DSCFX_LOCHARDWARE | DSCFX_LOCSOFTWARE )
    #define DSCFX_VALIDFLAGS      (DSCFX_LOCMASK)
//@@END_MSINTERNAL

    #define DSCFXR_LOCHARDWARE  0x00000010
    #define DSCFXR_LOCSOFTWARE  0x00000020
//@@BEGIN_MSINTERNAL
// Since we don't support LOCDEFER-style voice management on capture,
// and we don't have a DSCFX_OPTIONAL flag at the moment, none of the
// flags below can ever be returned.  So they're private for now.
    #define DSCFXR_UNALLOCATED  0x00000040
    #define DSCFXR_FAILED       0x00000080
    #define DSCFXR_UNKNOWN      0x00000100
//@@END_MSINTERNAL

#endif // DIRECTSOUND_VERSION >= 0x0800

typedef struct _DSBUFFERDESC
{
    DWORD           dwSize;
    DWORD           dwFlags;
    DWORD           dwBufferBytes;
    DWORD           dwReserved;
    LPWAVEFORMATEX  lpwfxFormat;
#if DIRECTSOUND_VERSION >= 0x0700
    GUID            guid3DAlgorithm;
#endif
} DSBUFFERDESC, *LPDSBUFFERDESC;

typedef const DSBUFFERDESC *LPCDSBUFFERDESC;

// Older version of this structure:

typedef struct _DSBUFFERDESC1
{
    DWORD           dwSize;
    DWORD           dwFlags;
    DWORD           dwBufferBytes;
    DWORD           dwReserved;
    LPWAVEFORMATEX  lpwfxFormat;
} DSBUFFERDESC1, *LPDSBUFFERDESC1;

typedef const DSBUFFERDESC1 *LPCDSBUFFERDESC1;

typedef struct _DS3DBUFFER
{
    DWORD           dwSize;
    D3DVECTOR       vPosition;
    D3DVECTOR       vVelocity;
    DWORD           dwInsideConeAngle;
    DWORD           dwOutsideConeAngle;
    D3DVECTOR       vConeOrientation;
    LONG            lConeOutsideVolume;
    D3DVALUE        flMinDistance;
    D3DVALUE        flMaxDistance;
    DWORD           dwMode;
} DS3DBUFFER, *LPDS3DBUFFER;

typedef const DS3DBUFFER *LPCDS3DBUFFER;

typedef struct _DS3DLISTENER
{
    DWORD           dwSize;
    D3DVECTOR       vPosition;
    D3DVECTOR       vVelocity;
    D3DVECTOR       vOrientFront;
    D3DVECTOR       vOrientTop;
    D3DVALUE        flDistanceFactor;
    D3DVALUE        flRolloffFactor;
    D3DVALUE        flDopplerFactor;
} DS3DLISTENER, *LPDS3DLISTENER;

typedef const DS3DLISTENER *LPCDS3DLISTENER;

typedef struct _DSCCAPS
{
    DWORD           dwSize;
    DWORD           dwFlags;
    DWORD           dwFormats;
    DWORD           dwChannels;
} DSCCAPS, *LPDSCCAPS;

typedef const DSCCAPS *LPCDSCCAPS;

typedef struct _DSCBUFFERDESC1
{
    DWORD           dwSize;
    DWORD           dwFlags;
    DWORD           dwBufferBytes;
    DWORD           dwReserved;
    LPWAVEFORMATEX  lpwfxFormat;
} DSCBUFFERDESC1, *LPDSCBUFFERDESC1;

typedef struct _DSCBUFFERDESC
{
    DWORD           dwSize;
    DWORD           dwFlags;
    DWORD           dwBufferBytes;
    DWORD           dwReserved;
    LPWAVEFORMATEX  lpwfxFormat;
#if DIRECTSOUND_VERSION >= 0x0800
    DWORD           dwFXCount;
    LPDSCEFFECTDESC lpDSCFXDesc;
#endif
} DSCBUFFERDESC, *LPDSCBUFFERDESC;

typedef const DSCBUFFERDESC *LPCDSCBUFFERDESC;

typedef struct _DSCBCAPS
{
    DWORD           dwSize;
    DWORD           dwFlags;
    DWORD           dwBufferBytes;
    DWORD           dwReserved;
} DSCBCAPS, *LPDSCBCAPS;

typedef const DSCBCAPS *LPCDSCBCAPS;

typedef struct _DSBPOSITIONNOTIFY
{
    DWORD           dwOffset;
    HANDLE          hEventNotify;
} DSBPOSITIONNOTIFY, *LPDSBPOSITIONNOTIFY;

typedef const DSBPOSITIONNOTIFY *LPCDSBPOSITIONNOTIFY;

//
// DirectSound API
//

typedef BOOL (CALLBACK *LPDSENUMCALLBACKA)(LPGUID, LPCSTR, LPCSTR, LPVOID);
typedef BOOL (CALLBACK *LPDSENUMCALLBACKW)(LPGUID, LPCWSTR, LPCWSTR, LPVOID);

extern HRESULT WINAPI DirectSoundCreate(LPCGUID pcGuidDevice, LPDIRECTSOUND *ppDS, LPUNKNOWN pUnkOuter);
extern HRESULT WINAPI DirectSoundEnumerateA(LPDSENUMCALLBACKA pDSEnumCallback, LPVOID pContext);
extern HRESULT WINAPI DirectSoundEnumerateW(LPDSENUMCALLBACKW pDSEnumCallback, LPVOID pContext);

extern HRESULT WINAPI DirectSoundCaptureCreate(LPCGUID pcGuidDevice, LPDIRECTSOUNDCAPTURE *ppDSC, LPUNKNOWN pUnkOuter);
extern HRESULT WINAPI DirectSoundCaptureEnumerateA(LPDSENUMCALLBACKA pDSEnumCallback, LPVOID pContext);
extern HRESULT WINAPI DirectSoundCaptureEnumerateW(LPDSENUMCALLBACKW pDSEnumCallback, LPVOID pContext);

#if DIRECTSOUND_VERSION >= 0x0800
extern HRESULT WINAPI DirectSoundCreate8(LPCGUID pcGuidDevice, LPDIRECTSOUND8 *ppDS8, LPUNKNOWN pUnkOuter);
extern HRESULT WINAPI DirectSoundCaptureCreate8(LPCGUID pcGuidDevice, LPDIRECTSOUNDCAPTURE8 *ppDSC8, LPUNKNOWN pUnkOuter);
extern HRESULT WINAPI DirectSoundFullDuplexCreate(LPCGUID pcGuidCaptureDevice, LPCGUID pcGuidRenderDevice,
        LPCDSCBUFFERDESC pcDSCBufferDesc, LPCDSBUFFERDESC pcDSBufferDesc, HWND hWnd,
        DWORD dwLevel, LPDIRECTSOUNDFULLDUPLEX* ppDSFD, LPDIRECTSOUNDCAPTUREBUFFER8 *ppDSCBuffer8,
        LPDIRECTSOUNDBUFFER8 *ppDSBuffer8, LPUNKNOWN pUnkOuter);
#define DirectSoundFullDuplexCreate8 DirectSoundFullDuplexCreate

extern HRESULT WINAPI GetDeviceID(LPCGUID pGuidSrc, LPGUID pGuidDest);
#endif // DIRECTSOUND_VERSION >= 0x0800

#ifdef UNICODE
#define LPDSENUMCALLBACK            LPDSENUMCALLBACKW
#define DirectSoundEnumerate        DirectSoundEnumerateW
#define DirectSoundCaptureEnumerate DirectSoundCaptureEnumerateW
#else // UNICODE
#define LPDSENUMCALLBACK            LPDSENUMCALLBACKA
#define DirectSoundEnumerate        DirectSoundEnumerateA
#define DirectSoundCaptureEnumerate DirectSoundCaptureEnumerateA
#endif // UNICODE

//
// IUnknown
//

#if !defined(__cplusplus) || defined(CINTERFACE)
#ifndef IUnknown_QueryInterface
#define IUnknown_QueryInterface(p,a,b)  (p)->lpVtbl->QueryInterface(p,a,b)
#endif // IUnknown_QueryInterface
#ifndef IUnknown_AddRef
#define IUnknown_AddRef(p)              (p)->lpVtbl->AddRef(p)
#endif // IUnknown_AddRef
#ifndef IUnknown_Release
#define IUnknown_Release(p)             (p)->lpVtbl->Release(p)
#endif // IUnknown_Release
#else // !defined(__cplusplus) || defined(CINTERFACE)
#ifndef IUnknown_QueryInterface
#define IUnknown_QueryInterface(p,a,b)  (p)->QueryInterface(a,b)
#endif // IUnknown_QueryInterface
#ifndef IUnknown_AddRef
#define IUnknown_AddRef(p)              (p)->AddRef()
#endif // IUnknown_AddRef
#ifndef IUnknown_Release
#define IUnknown_Release(p)             (p)->Release()
#endif // IUnknown_Release
#endif // !defined(__cplusplus) || defined(CINTERFACE)

#ifndef __IReferenceClock_INTERFACE_DEFINED__
#define __IReferenceClock_INTERFACE_DEFINED__

typedef LONGLONG REFERENCE_TIME;
typedef REFERENCE_TIME *LPREFERENCE_TIME;

DEFINE_GUID(IID_IReferenceClock, 0x56a86897, 0x0ad4, 0x11ce, 0xb0, 0x3a, 0x00, 0x20, 0xaf, 0x0b, 0xa7, 0x70);

#undef INTERFACE
#define INTERFACE IReferenceClock

DECLARE_INTERFACE_(IReferenceClock, IUnknown)
{
    // IUnknown methods
    STDMETHOD(QueryInterface)       (THIS_ REFIID, LPVOID *) PURE;
    STDMETHOD_(ULONG,AddRef)        (THIS) PURE;
    STDMETHOD_(ULONG,Release)       (THIS) PURE;

    // IReferenceClock methods
    STDMETHOD(GetTime)              (THIS_ REFERENCE_TIME *pTime) PURE;
    STDMETHOD(AdviseTime)           (THIS_ REFERENCE_TIME rtBaseTime, REFERENCE_TIME rtStreamTime,
                                           HANDLE hEvent, LPDWORD pdwAdviseCookie) PURE;
    STDMETHOD(AdvisePeriodic)       (THIS_ REFERENCE_TIME rtStartTime, REFERENCE_TIME rtPeriodTime,
                                           HANDLE hSemaphore, LPDWORD pdwAdviseCookie) PURE;
    STDMETHOD(Unadvise)             (THIS_ DWORD dwAdviseCookie) PURE;
};

#endif // __IReferenceClock_INTERFACE_DEFINED__

#ifndef IReferenceClock_QueryInterface

#define IReferenceClock_QueryInterface(p,a,b)      IUnknown_QueryInterface(p,a,b)
#define IReferenceClock_AddRef(p)                  IUnknown_AddRef(p)
#define IReferenceClock_Release(p)                 IUnknown_Release(p)

#if !defined(__cplusplus) || defined(CINTERFACE)
#define IReferenceClock_GetTime(p,a)               (p)->lpVtbl->GetTime(p,a)
#define IReferenceClock_AdviseTime(p,a,b,c,d)      (p)->lpVtbl->AdviseTime(p,a,b,c,d)
#define IReferenceClock_AdvisePeriodic(p,a,b,c,d)  (p)->lpVtbl->AdvisePeriodic(p,a,b,c,d)
#define IReferenceClock_Unadvise(p,a)              (p)->lpVtbl->Unadvise(p,a)
#else // !defined(__cplusplus) || defined(CINTERFACE)
#define IReferenceClock_GetTime(p,a)               (p)->GetTime(a)
#define IReferenceClock_AdviseTime(p,a,b,c,d)      (p)->AdviseTime(a,b,c,d)
#define IReferenceClock_AdvisePeriodic(p,a,b,c,d)  (p)->AdvisePeriodic(a,b,c,d)
#define IReferenceClock_Unadvise(p,a)              (p)->Unadvise(a)
#endif // !defined(__cplusplus) || defined(CINTERFACE)

#endif // IReferenceClock_QueryInterface

//
// IDirectSound
//

DEFINE_GUID(IID_IDirectSound, 0x279AFA83, 0x4981, 0x11CE, 0xA5, 0x21, 0x00, 0x20, 0xAF, 0x0B, 0xE5, 0x60);

#undef INTERFACE
#define INTERFACE IDirectSound

DECLARE_INTERFACE_(IDirectSound, IUnknown)
{
    // IUnknown methods
    STDMETHOD(QueryInterface)       (THIS_ REFIID, LPVOID *) PURE;
    STDMETHOD_(ULONG,AddRef)        (THIS) PURE;
    STDMETHOD_(ULONG,Release)       (THIS) PURE;

    // IDirectSound methods
    STDMETHOD(CreateSoundBuffer)    (THIS_ LPCDSBUFFERDESC pcDSBufferDesc, LPDIRECTSOUNDBUFFER *ppDSBuffer, LPUNKNOWN pUnkOuter) PURE;
    STDMETHOD(GetCaps)              (THIS_ LPDSCAPS pDSCaps) PURE;
    STDMETHOD(DuplicateSoundBuffer) (THIS_ LPDIRECTSOUNDBUFFER pDSBufferOriginal, LPDIRECTSOUNDBUFFER *ppDSBufferDuplicate) PURE;
    STDMETHOD(SetCooperativeLevel)  (THIS_ HWND hwnd, DWORD dwLevel) PURE;
    STDMETHOD(Compact)              (THIS) PURE;
    STDMETHOD(GetSpeakerConfig)     (THIS_ LPDWORD pdwSpeakerConfig) PURE;
    STDMETHOD(SetSpeakerConfig)     (THIS_ DWORD dwSpeakerConfig) PURE;
    STDMETHOD(Initialize)           (THIS_ LPCGUID pcGuidDevice) PURE;
};

#define IDirectSound_QueryInterface(p,a,b)       IUnknown_QueryInterface(p,a,b)
#define IDirectSound_AddRef(p)                   IUnknown_AddRef(p)
#define IDirectSound_Release(p)                  IUnknown_Release(p)

#if !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectSound_CreateSoundBuffer(p,a,b,c)  (p)->lpVtbl->CreateSoundBuffer(p,a,b,c)
#define IDirectSound_GetCaps(p,a)                (p)->lpVtbl->GetCaps(p,a)
#define IDirectSound_DuplicateSoundBuffer(p,a,b) (p)->lpVtbl->DuplicateSoundBuffer(p,a,b)
#define IDirectSound_SetCooperativeLevel(p,a,b)  (p)->lpVtbl->SetCooperativeLevel(p,a,b)
#define IDirectSound_Compact(p)                  (p)->lpVtbl->Compact(p)
#define IDirectSound_GetSpeakerConfig(p,a)       (p)->lpVtbl->GetSpeakerConfig(p,a)
#define IDirectSound_SetSpeakerConfig(p,b)       (p)->lpVtbl->SetSpeakerConfig(p,b)
#define IDirectSound_Initialize(p,a)             (p)->lpVtbl->Initialize(p,a)
#else // !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectSound_CreateSoundBuffer(p,a,b,c)  (p)->CreateSoundBuffer(a,b,c)
#define IDirectSound_GetCaps(p,a)                (p)->GetCaps(a)
#define IDirectSound_DuplicateSoundBuffer(p,a,b) (p)->DuplicateSoundBuffer(a,b)
#define IDirectSound_SetCooperativeLevel(p,a,b)  (p)->SetCooperativeLevel(a,b)
#define IDirectSound_Compact(p)                  (p)->Compact()
#define IDirectSound_GetSpeakerConfig(p,a)       (p)->GetSpeakerConfig(a)
#define IDirectSound_SetSpeakerConfig(p,b)       (p)->SetSpeakerConfig(b)
#define IDirectSound_Initialize(p,a)             (p)->Initialize(a)
#endif // !defined(__cplusplus) || defined(CINTERFACE)

#if DIRECTSOUND_VERSION >= 0x0800

//
// IDirectSound8
//

DEFINE_GUID(IID_IDirectSound8, 0xC50A7E93, 0xF395, 0x4834, 0x9E, 0xF6, 0x7F, 0xA9, 0x9D, 0xE5, 0x09, 0x66);

#undef INTERFACE
#define INTERFACE IDirectSound8

DECLARE_INTERFACE_(IDirectSound8, IDirectSound)
{
    // IUnknown methods
    STDMETHOD(QueryInterface)       (THIS_ REFIID, LPVOID *) PURE;
    STDMETHOD_(ULONG,AddRef)        (THIS) PURE;
    STDMETHOD_(ULONG,Release)       (THIS) PURE;

    // IDirectSound methods
    STDMETHOD(CreateSoundBuffer)    (THIS_ LPCDSBUFFERDESC pcDSBufferDesc, LPDIRECTSOUNDBUFFER *ppDSBuffer, LPUNKNOWN pUnkOuter) PURE;
    STDMETHOD(GetCaps)              (THIS_ LPDSCAPS pDSCaps) PURE;
    STDMETHOD(DuplicateSoundBuffer) (THIS_ LPDIRECTSOUNDBUFFER pDSBufferOriginal, LPDIRECTSOUNDBUFFER *ppDSBufferDuplicate) PURE;
    STDMETHOD(SetCooperativeLevel)  (THIS_ HWND hwnd, DWORD dwLevel) PURE;
    STDMETHOD(Compact)              (THIS) PURE;
    STDMETHOD(GetSpeakerConfig)     (THIS_ LPDWORD pdwSpeakerConfig) PURE;
    STDMETHOD(SetSpeakerConfig)     (THIS_ DWORD dwSpeakerConfig) PURE;
    STDMETHOD(Initialize)           (THIS_ LPCGUID pcGuidDevice) PURE;

    // IDirectSound8 methods
    STDMETHOD(VerifyCertification)  (THIS_ LPDWORD pdwCertified) PURE;
//@@BEGIN_MSINTERNAL
#ifdef FUTURE_WAVE_SUPPORT
    STDMETHOD(CreateSoundBufferFromWave) (THIS_ LPUNKNOWN pDSWave, DWORD dwFlags, LPDIRECTSOUNDBUFFER *ppDSBuffer) PURE;
#endif
//@@END_MSINTERNAL
};

#define IDirectSound8_QueryInterface(p,a,b)       IDirectSound_QueryInterface(p,a,b)
#define IDirectSound8_AddRef(p)                   IDirectSound_AddRef(p)
#define IDirectSound8_Release(p)                  IDirectSound_Release(p)
#define IDirectSound8_CreateSoundBuffer(p,a,b,c)  IDirectSound_CreateSoundBuffer(p,a,b,c)
#define IDirectSound8_GetCaps(p,a)                IDirectSound_GetCaps(p,a)
#define IDirectSound8_DuplicateSoundBuffer(p,a,b) IDirectSound_DuplicateSoundBuffer(p,a,b)
#define IDirectSound8_SetCooperativeLevel(p,a,b)  IDirectSound_SetCooperativeLevel(p,a,b)
#define IDirectSound8_Compact(p)                  IDirectSound_Compact(p)
#define IDirectSound8_GetSpeakerConfig(p,a)       IDirectSound_GetSpeakerConfig(p,a)
#define IDirectSound8_SetSpeakerConfig(p,a)       IDirectSound_SetSpeakerConfig(p,a)
#define IDirectSound8_Initialize(p,a)             IDirectSound_Initialize(p,a)

#if !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectSound8_VerifyCertification(p,a)           (p)->lpVtbl->VerifyCertification(p,a)
//@@BEGIN_MSINTERNAL
#ifdef FUTURE_WAVE_SUPPORT
#define IDirectSound8_CreateSoundBufferFromWave(p,a,b,c) (p)->lpVtbl->CreateSoundBufferFromWave(p,a,b,c)
#endif
//@@END_MSINTERNAL
#else // !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectSound8_VerifyCertification(p,a)           (p)->VerifyCertification(a)
//@@BEGIN_MSINTERNAL
#ifdef FUTURE_WAVE_SUPPORT
#define IDirectSound8_CreateSoundBufferFromWave(p,a,b,c) (p)->CreateSoundBufferFromWave(a,b,c)
#endif
//@@END_MSINTERNAL
#endif // !defined(__cplusplus) || defined(CINTERFACE)

#endif // DIRECTSOUND_VERSION >= 0x0800

//
// IDirectSoundBuffer
//

DEFINE_GUID(IID_IDirectSoundBuffer, 0x279AFA85, 0x4981, 0x11CE, 0xA5, 0x21, 0x00, 0x20, 0xAF, 0x0B, 0xE5, 0x60);

#undef INTERFACE
#define INTERFACE IDirectSoundBuffer

DECLARE_INTERFACE_(IDirectSoundBuffer, IUnknown)
{
    // IUnknown methods
    STDMETHOD(QueryInterface)       (THIS_ REFIID, LPVOID *) PURE;
    STDMETHOD_(ULONG,AddRef)        (THIS) PURE;
    STDMETHOD_(ULONG,Release)       (THIS) PURE;

    // IDirectSoundBuffer methods
    STDMETHOD(GetCaps)              (THIS_ LPDSBCAPS pDSBufferCaps) PURE;
    STDMETHOD(GetCurrentPosition)   (THIS_ LPDWORD pdwCurrentPlayCursor, LPDWORD pdwCurrentWriteCursor) PURE;
    STDMETHOD(GetFormat)            (THIS_ LPWAVEFORMATEX pwfxFormat, DWORD dwSizeAllocated, LPDWORD pdwSizeWritten) PURE;
    STDMETHOD(GetVolume)            (THIS_ LPLONG plVolume) PURE;
    STDMETHOD(GetPan)               (THIS_ LPLONG plPan) PURE;
    STDMETHOD(GetFrequency)         (THIS_ LPDWORD pdwFrequency) PURE;
    STDMETHOD(GetStatus)            (THIS_ LPDWORD pdwStatus) PURE;
    STDMETHOD(Initialize)           (THIS_ LPDIRECTSOUND pDirectSound, LPCDSBUFFERDESC pcDSBufferDesc) PURE;
    STDMETHOD(Lock)                 (THIS_ DWORD dwOffset, DWORD dwBytes, LPVOID *ppvAudioPtr1, LPDWORD pdwAudioBytes1,
                                           LPVOID *ppvAudioPtr2, LPDWORD pdwAudioBytes2, DWORD dwFlags) PURE;
    STDMETHOD(Play)                 (THIS_ DWORD dwReserved1, DWORD dwPriority, DWORD dwFlags) PURE;
    STDMETHOD(SetCurrentPosition)   (THIS_ DWORD dwNewPosition) PURE;
    STDMETHOD(SetFormat)            (THIS_ LPCWAVEFORMATEX pcfxFormat) PURE;
    STDMETHOD(SetVolume)            (THIS_ LONG lVolume) PURE;
    STDMETHOD(SetPan)               (THIS_ LONG lPan) PURE;
    STDMETHOD(SetFrequency)         (THIS_ DWORD dwFrequency) PURE;
    STDMETHOD(Stop)                 (THIS) PURE;
    STDMETHOD(Unlock)               (THIS_ LPVOID pvAudioPtr1, DWORD dwAudioBytes1, LPVOID pvAudioPtr2, DWORD dwAudioBytes2) PURE;
    STDMETHOD(Restore)              (THIS) PURE;
};

#define IDirectSoundBuffer_QueryInterface(p,a,b)        IUnknown_QueryInterface(p,a,b)
#define IDirectSoundBuffer_AddRef(p)                    IUnknown_AddRef(p)
#define IDirectSoundBuffer_Release(p)                   IUnknown_Release(p)

#if !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectSoundBuffer_GetCaps(p,a)                 (p)->lpVtbl->GetCaps(p,a)
#define IDirectSoundBuffer_GetCurrentPosition(p,a,b)    (p)->lpVtbl->GetCurrentPosition(p,a,b)
#define IDirectSoundBuffer_GetFormat(p,a,b,c)           (p)->lpVtbl->GetFormat(p,a,b,c)
#define IDirectSoundBuffer_GetVolume(p,a)               (p)->lpVtbl->GetVolume(p,a)
#define IDirectSoundBuffer_GetPan(p,a)                  (p)->lpVtbl->GetPan(p,a)
#define IDirectSoundBuffer_GetFrequency(p,a)            (p)->lpVtbl->GetFrequency(p,a)
#define IDirectSoundBuffer_GetStatus(p,a)               (p)->lpVtbl->GetStatus(p,a)
#define IDirectSoundBuffer_Initialize(p,a,b)            (p)->lpVtbl->Initialize(p,a,b)
#define IDirectSoundBuffer_Lock(p,a,b,c,d,e,f,g)        (p)->lpVtbl->Lock(p,a,b,c,d,e,f,g)
#define IDirectSoundBuffer_Play(p,a,b,c)                (p)->lpVtbl->Play(p,a,b,c)
#define IDirectSoundBuffer_SetCurrentPosition(p,a)      (p)->lpVtbl->SetCurrentPosition(p,a)
#define IDirectSoundBuffer_SetFormat(p,a)               (p)->lpVtbl->SetFormat(p,a)
#define IDirectSoundBuffer_SetVolume(p,a)               (p)->lpVtbl->SetVolume(p,a)
#define IDirectSoundBuffer_SetPan(p,a)                  (p)->lpVtbl->SetPan(p,a)
#define IDirectSoundBuffer_SetFrequency(p,a)            (p)->lpVtbl->SetFrequency(p,a)
#define IDirectSoundBuffer_Stop(p)                      (p)->lpVtbl->Stop(p)
#define IDirectSoundBuffer_Unlock(p,a,b,c,d)            (p)->lpVtbl->Unlock(p,a,b,c,d)
#define IDirectSoundBuffer_Restore(p)                   (p)->lpVtbl->Restore(p)
#else // !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectSoundBuffer_GetCaps(p,a)                 (p)->GetCaps(a)
#define IDirectSoundBuffer_GetCurrentPosition(p,a,b)    (p)->GetCurrentPosition(a,b)
#define IDirectSoundBuffer_GetFormat(p,a,b,c)           (p)->GetFormat(a,b,c)
#define IDirectSoundBuffer_GetVolume(p,a)               (p)->GetVolume(a)
#define IDirectSoundBuffer_GetPan(p,a)                  (p)->GetPan(a)
#define IDirectSoundBuffer_GetFrequency(p,a)            (p)->GetFrequency(a)
#define IDirectSoundBuffer_GetStatus(p,a)               (p)->GetStatus(a)
#define IDirectSoundBuffer_Initialize(p,a,b)            (p)->Initialize(a,b)
#define IDirectSoundBuffer_Lock(p,a,b,c,d,e,f,g)        (p)->Lock(a,b,c,d,e,f,g)
#define IDirectSoundBuffer_Play(p,a,b,c)                (p)->Play(a,b,c)
#define IDirectSoundBuffer_SetCurrentPosition(p,a)      (p)->SetCurrentPosition(a)
#define IDirectSoundBuffer_SetFormat(p,a)               (p)->SetFormat(a)
#define IDirectSoundBuffer_SetVolume(p,a)               (p)->SetVolume(a)
#define IDirectSoundBuffer_SetPan(p,a)                  (p)->SetPan(a)
#define IDirectSoundBuffer_SetFrequency(p,a)            (p)->SetFrequency(a)
#define IDirectSoundBuffer_Stop(p)                      (p)->Stop()
#define IDirectSoundBuffer_Unlock(p,a,b,c,d)            (p)->Unlock(a,b,c,d)
#define IDirectSoundBuffer_Restore(p)                   (p)->Restore()
#endif // !defined(__cplusplus) || defined(CINTERFACE)

#if DIRECTSOUND_VERSION >= 0x0800

//
// IDirectSoundBuffer8
//

DEFINE_GUID(IID_IDirectSoundBuffer8, 0x6825a449, 0x7524, 0x4d82, 0x92, 0x0f, 0x50, 0xe3, 0x6a, 0xb3, 0xab, 0x1e);

#undef INTERFACE
#define INTERFACE IDirectSoundBuffer8

DECLARE_INTERFACE_(IDirectSoundBuffer8, IDirectSoundBuffer)
{
    // IUnknown methods
    STDMETHOD(QueryInterface)       (THIS_ REFIID, LPVOID *) PURE;
    STDMETHOD_(ULONG,AddRef)        (THIS) PURE;
    STDMETHOD_(ULONG,Release)       (THIS) PURE;

    // IDirectSoundBuffer methods
    STDMETHOD(GetCaps)              (THIS_ LPDSBCAPS pDSBufferCaps) PURE;
    STDMETHOD(GetCurrentPosition)   (THIS_ LPDWORD pdwCurrentPlayCursor, LPDWORD pdwCurrentWriteCursor) PURE;
    STDMETHOD(GetFormat)            (THIS_ LPWAVEFORMATEX pwfxFormat, DWORD dwSizeAllocated, LPDWORD pdwSizeWritten) PURE;
    STDMETHOD(GetVolume)            (THIS_ LPLONG plVolume) PURE;
    STDMETHOD(GetPan)               (THIS_ LPLONG plPan) PURE;
    STDMETHOD(GetFrequency)         (THIS_ LPDWORD pdwFrequency) PURE;
    STDMETHOD(GetStatus)            (THIS_ LPDWORD pdwStatus) PURE;
    STDMETHOD(Initialize)           (THIS_ LPDIRECTSOUND pDirectSound, LPCDSBUFFERDESC pcDSBufferDesc) PURE;
    STDMETHOD(Lock)                 (THIS_ DWORD dwOffset, DWORD dwBytes, LPVOID *ppvAudioPtr1, LPDWORD pdwAudioBytes1,
                                           LPVOID *ppvAudioPtr2, LPDWORD pdwAudioBytes2, DWORD dwFlags) PURE;
    STDMETHOD(Play)                 (THIS_ DWORD dwReserved1, DWORD dwPriority, DWORD dwFlags) PURE;
    STDMETHOD(SetCurrentPosition)   (THIS_ DWORD dwNewPosition) PURE;
    STDMETHOD(SetFormat)            (THIS_ LPCWAVEFORMATEX pcfxFormat) PURE;
    STDMETHOD(SetVolume)            (THIS_ LONG lVolume) PURE;
    STDMETHOD(SetPan)               (THIS_ LONG lPan) PURE;
    STDMETHOD(SetFrequency)         (THIS_ DWORD dwFrequency) PURE;
    STDMETHOD(Stop)                 (THIS) PURE;
    STDMETHOD(Unlock)               (THIS_ LPVOID pvAudioPtr1, DWORD dwAudioBytes1, LPVOID pvAudioPtr2, DWORD dwAudioBytes2) PURE;
    STDMETHOD(Restore)              (THIS) PURE;

    // IDirectSoundBuffer8 methods
    STDMETHOD(SetFX)                (THIS_ DWORD dwEffectsCount, LPDSEFFECTDESC pDSFXDesc, LPDWORD pdwResultCodes) PURE;
    STDMETHOD(AcquireResources)     (THIS_ DWORD dwFlags, DWORD dwEffectsCount, LPDWORD pdwResultCodes) PURE;
    STDMETHOD(GetObjectInPath)      (THIS_ REFGUID rguidObject, DWORD dwIndex, REFGUID rguidInterface, LPVOID *ppObject) PURE;
//@@BEGIN_MSINTERNAL
#ifdef FUTURE_MULTIPAN_SUPPORT
    STDMETHOD(SetChannelVolume)     (THIS_ DWORD dwChannelCount, LPDWORD pdwChannels, LPLONG plVolumes) PURE;
#endif
//@@END_MSINTERNAL
};

// Special GUID meaning "select all objects" for use in GetObjectInPath()
DEFINE_GUID(GUID_All_Objects, 0xaa114de5, 0xc262, 0x4169, 0xa1, 0xc8, 0x23, 0xd6, 0x98, 0xcc, 0x73, 0xb5);

#define IDirectSoundBuffer8_QueryInterface(p,a,b)           IUnknown_QueryInterface(p,a,b)
#define IDirectSoundBuffer8_AddRef(p)                       IUnknown_AddRef(p)
#define IDirectSoundBuffer8_Release(p)                      IUnknown_Release(p)

#define IDirectSoundBuffer8_GetCaps(p,a)                    IDirectSoundBuffer_GetCaps(p,a)
#define IDirectSoundBuffer8_GetCurrentPosition(p,a,b)       IDirectSoundBuffer_GetCurrentPosition(p,a,b)
#define IDirectSoundBuffer8_GetFormat(p,a,b,c)              IDirectSoundBuffer_GetFormat(p,a,b,c)
#define IDirectSoundBuffer8_GetVolume(p,a)                  IDirectSoundBuffer_GetVolume(p,a)
#define IDirectSoundBuffer8_GetPan(p,a)                     IDirectSoundBuffer_GetPan(p,a)
#define IDirectSoundBuffer8_GetFrequency(p,a)               IDirectSoundBuffer_GetFrequency(p,a)
#define IDirectSoundBuffer8_GetStatus(p,a)                  IDirectSoundBuffer_GetStatus(p,a)
#define IDirectSoundBuffer8_Initialize(p,a,b)               IDirectSoundBuffer_Initialize(p,a,b)
#define IDirectSoundBuffer8_Lock(p,a,b,c,d,e,f,g)           IDirectSoundBuffer_Lock(p,a,b,c,d,e,f,g)
#define IDirectSoundBuffer8_Play(p,a,b,c)                   IDirectSoundBuffer_Play(p,a,b,c)
#define IDirectSoundBuffer8_SetCurrentPosition(p,a)         IDirectSoundBuffer_SetCurrentPosition(p,a)
#define IDirectSoundBuffer8_SetFormat(p,a)                  IDirectSoundBuffer_SetFormat(p,a)
#define IDirectSoundBuffer8_SetVolume(p,a)                  IDirectSoundBuffer_SetVolume(p,a)
#define IDirectSoundBuffer8_SetPan(p,a)                     IDirectSoundBuffer_SetPan(p,a)
#define IDirectSoundBuffer8_SetFrequency(p,a)               IDirectSoundBuffer_SetFrequency(p,a)
#define IDirectSoundBuffer8_Stop(p)                         IDirectSoundBuffer_Stop(p)
#define IDirectSoundBuffer8_Unlock(p,a,b,c,d)               IDirectSoundBuffer_Unlock(p,a,b,c,d)
#define IDirectSoundBuffer8_Restore(p)                      IDirectSoundBuffer_Restore(p)

#if !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectSoundBuffer8_SetFX(p,a,b,c)                  (p)->lpVtbl->SetFX(p,a,b,c)
#define IDirectSoundBuffer8_AcquireResources(p,a,b,c)       (p)->lpVtbl->AcquireResources(p,a,b,c)
#define IDirectSoundBuffer8_GetObjectInPath(p,a,b,c,d)      (p)->lpVtbl->GetObjectInPath(p,a,b,c,d)
#else // !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectSoundBuffer8_SetFX(p,a,b,c)                  (p)->SetFX(a,b,c)
#define IDirectSoundBuffer8_AcquireResources(p,a,b,c)       (p)->AcquireResources(a,b,c)
#define IDirectSoundBuffer8_GetObjectInPath(p,a,b,c,d)      (p)->GetObjectInPath(a,b,c,d)
#endif // !defined(__cplusplus) || defined(CINTERFACE)

#endif // DIRECTSOUND_VERSION >= 0x0800

//
// IDirectSound3DListener
//

DEFINE_GUID(IID_IDirectSound3DListener, 0x279AFA84, 0x4981, 0x11CE, 0xA5, 0x21, 0x00, 0x20, 0xAF, 0x0B, 0xE5, 0x60);

#undef INTERFACE
#define INTERFACE IDirectSound3DListener

DECLARE_INTERFACE_(IDirectSound3DListener, IUnknown)
{
    // IUnknown methods
    STDMETHOD(QueryInterface)           (THIS_ REFIID, LPVOID *) PURE;
    STDMETHOD_(ULONG,AddRef)            (THIS) PURE;
    STDMETHOD_(ULONG,Release)           (THIS) PURE;

    // IDirectSound3DListener methods
    STDMETHOD(GetAllParameters)         (THIS_ LPDS3DLISTENER pListener) PURE;
    STDMETHOD(GetDistanceFactor)        (THIS_ D3DVALUE* pflDistanceFactor) PURE;
    STDMETHOD(GetDopplerFactor)         (THIS_ D3DVALUE* pflDopplerFactor) PURE;
    STDMETHOD(GetOrientation)           (THIS_ D3DVECTOR* pvOrientFront, D3DVECTOR* pvOrientTop) PURE;
    STDMETHOD(GetPosition)              (THIS_ D3DVECTOR* pvPosition) PURE;
    STDMETHOD(GetRolloffFactor)         (THIS_ D3DVALUE* pflRolloffFactor) PURE;
    STDMETHOD(GetVelocity)              (THIS_ D3DVECTOR* pvVelocity) PURE;
    STDMETHOD(SetAllParameters)         (THIS_ LPCDS3DLISTENER pcListener, DWORD dwApply) PURE;
    STDMETHOD(SetDistanceFactor)        (THIS_ D3DVALUE flDistanceFactor, DWORD dwApply) PURE;
    STDMETHOD(SetDopplerFactor)         (THIS_ D3DVALUE flDopplerFactor, DWORD dwApply) PURE;
    STDMETHOD(SetOrientation)           (THIS_ D3DVALUE xFront, D3DVALUE yFront, D3DVALUE zFront,
                                               D3DVALUE xTop, D3DVALUE yTop, D3DVALUE zTop, DWORD dwApply) PURE;
    STDMETHOD(SetPosition)              (THIS_ D3DVALUE x, D3DVALUE y, D3DVALUE z, DWORD dwApply) PURE;
    STDMETHOD(SetRolloffFactor)         (THIS_ D3DVALUE flRolloffFactor, DWORD dwApply) PURE;
    STDMETHOD(SetVelocity)              (THIS_ D3DVALUE x, D3DVALUE y, D3DVALUE z, DWORD dwApply) PURE;
    STDMETHOD(CommitDeferredSettings)   (THIS) PURE;
};

#define IDirectSound3DListener_QueryInterface(p,a,b)            IUnknown_QueryInterface(p,a,b)
#define IDirectSound3DListener_AddRef(p)                        IUnknown_AddRef(p)
#define IDirectSound3DListener_Release(p)                       IUnknown_Release(p)

#if !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectSound3DListener_GetAllParameters(p,a)            (p)->lpVtbl->GetAllParameters(p,a)
#define IDirectSound3DListener_GetDistanceFactor(p,a)           (p)->lpVtbl->GetDistanceFactor(p,a)
#define IDirectSound3DListener_GetDopplerFactor(p,a)            (p)->lpVtbl->GetDopplerFactor(p,a)
#define IDirectSound3DListener_GetOrientation(p,a,b)            (p)->lpVtbl->GetOrientation(p,a,b)
#define IDirectSound3DListener_GetPosition(p,a)                 (p)->lpVtbl->GetPosition(p,a)
#define IDirectSound3DListener_GetRolloffFactor(p,a)            (p)->lpVtbl->GetRolloffFactor(p,a)
#define IDirectSound3DListener_GetVelocity(p,a)                 (p)->lpVtbl->GetVelocity(p,a)
#define IDirectSound3DListener_SetAllParameters(p,a,b)          (p)->lpVtbl->SetAllParameters(p,a,b)
#define IDirectSound3DListener_SetDistanceFactor(p,a,b)         (p)->lpVtbl->SetDistanceFactor(p,a,b)
#define IDirectSound3DListener_SetDopplerFactor(p,a,b)          (p)->lpVtbl->SetDopplerFactor(p,a,b)
#define IDirectSound3DListener_SetOrientation(p,a,b,c,d,e,f,g)  (p)->lpVtbl->SetOrientation(p,a,b,c,d,e,f,g)
#define IDirectSound3DListener_SetPosition(p,a,b,c,d)           (p)->lpVtbl->SetPosition(p,a,b,c,d)
#define IDirectSound3DListener_SetRolloffFactor(p,a,b)          (p)->lpVtbl->SetRolloffFactor(p,a,b)
#define IDirectSound3DListener_SetVelocity(p,a,b,c,d)           (p)->lpVtbl->SetVelocity(p,a,b,c,d)
#define IDirectSound3DListener_CommitDeferredSettings(p)        (p)->lpVtbl->CommitDeferredSettings(p)
#else // !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectSound3DListener_GetAllParameters(p,a)            (p)->GetAllParameters(a)
#define IDirectSound3DListener_GetDistanceFactor(p,a)           (p)->GetDistanceFactor(a)
#define IDirectSound3DListener_GetDopplerFactor(p,a)            (p)->GetDopplerFactor(a)
#define IDirectSound3DListener_GetOrientation(p,a,b)            (p)->GetOrientation(a,b)
#define IDirectSound3DListener_GetPosition(p,a)                 (p)->GetPosition(a)
#define IDirectSound3DListener_GetRolloffFactor(p,a)            (p)->GetRolloffFactor(a)
#define IDirectSound3DListener_GetVelocity(p,a)                 (p)->GetVelocity(a)
#define IDirectSound3DListener_SetAllParameters(p,a,b)          (p)->SetAllParameters(a,b)
#define IDirectSound3DListener_SetDistanceFactor(p,a,b)         (p)->SetDistanceFactor(a,b)
#define IDirectSound3DListener_SetDopplerFactor(p,a,b)          (p)->SetDopplerFactor(a,b)
#define IDirectSound3DListener_SetOrientation(p,a,b,c,d,e,f,g)  (p)->SetOrientation(a,b,c,d,e,f,g)
#define IDirectSound3DListener_SetPosition(p,a,b,c,d)           (p)->SetPosition(a,b,c,d)
#define IDirectSound3DListener_SetRolloffFactor(p,a,b)          (p)->SetRolloffFactor(a,b)
#define IDirectSound3DListener_SetVelocity(p,a,b,c,d)           (p)->SetVelocity(a,b,c,d)
#define IDirectSound3DListener_CommitDeferredSettings(p)        (p)->CommitDeferredSettings()
#endif // !defined(__cplusplus) || defined(CINTERFACE)

//
// IDirectSound3DBuffer
//

DEFINE_GUID(IID_IDirectSound3DBuffer, 0x279AFA86, 0x4981, 0x11CE, 0xA5, 0x21, 0x00, 0x20, 0xAF, 0x0B, 0xE5, 0x60);

#undef INTERFACE
#define INTERFACE IDirectSound3DBuffer

DECLARE_INTERFACE_(IDirectSound3DBuffer, IUnknown)
{
    // IUnknown methods
    STDMETHOD(QueryInterface)       (THIS_ REFIID, LPVOID *) PURE;
    STDMETHOD_(ULONG,AddRef)        (THIS) PURE;
    STDMETHOD_(ULONG,Release)       (THIS) PURE;

    // IDirectSound3DBuffer methods
    STDMETHOD(GetAllParameters)     (THIS_ LPDS3DBUFFER pDs3dBuffer) PURE;
    STDMETHOD(GetConeAngles)        (THIS_ LPDWORD pdwInsideConeAngle, LPDWORD pdwOutsideConeAngle) PURE;
    STDMETHOD(GetConeOrientation)   (THIS_ D3DVECTOR* pvOrientation) PURE;
    STDMETHOD(GetConeOutsideVolume) (THIS_ LPLONG plConeOutsideVolume) PURE;
    STDMETHOD(GetMaxDistance)       (THIS_ D3DVALUE* pflMaxDistance) PURE;
    STDMETHOD(GetMinDistance)       (THIS_ D3DVALUE* pflMinDistance) PURE;
    STDMETHOD(GetMode)              (THIS_ LPDWORD pdwMode) PURE;
    STDMETHOD(GetPosition)          (THIS_ D3DVECTOR* pvPosition) PURE;
    STDMETHOD(GetVelocity)          (THIS_ D3DVECTOR* pvVelocity) PURE;
    STDMETHOD(SetAllParameters)     (THIS_ LPCDS3DBUFFER pcDs3dBuffer, DWORD dwApply) PURE;
    STDMETHOD(SetConeAngles)        (THIS_ DWORD dwInsideConeAngle, DWORD dwOutsideConeAngle, DWORD dwApply) PURE;
    STDMETHOD(SetConeOrientation)   (THIS_ D3DVALUE x, D3DVALUE y, D3DVALUE z, DWORD dwApply) PURE;
    STDMETHOD(SetConeOutsideVolume) (THIS_ LONG lConeOutsideVolume, DWORD dwApply) PURE;
    STDMETHOD(SetMaxDistance)       (THIS_ D3DVALUE flMaxDistance, DWORD dwApply) PURE;
    STDMETHOD(SetMinDistance)       (THIS_ D3DVALUE flMinDistance, DWORD dwApply) PURE;
    STDMETHOD(SetMode)              (THIS_ DWORD dwMode, DWORD dwApply) PURE;
    STDMETHOD(SetPosition)          (THIS_ D3DVALUE x, D3DVALUE y, D3DVALUE z, DWORD dwApply) PURE;
    STDMETHOD(SetVelocity)          (THIS_ D3DVALUE x, D3DVALUE y, D3DVALUE z, DWORD dwApply) PURE;
};

#define IDirectSound3DBuffer_QueryInterface(p,a,b)          IUnknown_QueryInterface(p,a,b)
#define IDirectSound3DBuffer_AddRef(p)                      IUnknown_AddRef(p)
#define IDirectSound3DBuffer_Release(p)                     IUnknown_Release(p)

#if !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectSound3DBuffer_GetAllParameters(p,a)          (p)->lpVtbl->GetAllParameters(p,a)
#define IDirectSound3DBuffer_GetConeAngles(p,a,b)           (p)->lpVtbl->GetConeAngles(p,a,b)
#define IDirectSound3DBuffer_GetConeOrientation(p,a)        (p)->lpVtbl->GetConeOrientation(p,a)
#define IDirectSound3DBuffer_GetConeOutsideVolume(p,a)      (p)->lpVtbl->GetConeOutsideVolume(p,a)
#define IDirectSound3DBuffer_GetPosition(p,a)               (p)->lpVtbl->GetPosition(p,a)
#define IDirectSound3DBuffer_GetMinDistance(p,a)            (p)->lpVtbl->GetMinDistance(p,a)
#define IDirectSound3DBuffer_GetMaxDistance(p,a)            (p)->lpVtbl->GetMaxDistance(p,a)
#define IDirectSound3DBuffer_GetMode(p,a)                   (p)->lpVtbl->GetMode(p,a)
#define IDirectSound3DBuffer_GetVelocity(p,a)               (p)->lpVtbl->GetVelocity(p,a)
#define IDirectSound3DBuffer_SetAllParameters(p,a,b)        (p)->lpVtbl->SetAllParameters(p,a,b)
#define IDirectSound3DBuffer_SetConeAngles(p,a,b,c)         (p)->lpVtbl->SetConeAngles(p,a,b,c)
#define IDirectSound3DBuffer_SetConeOrientation(p,a,b,c,d)  (p)->lpVtbl->SetConeOrientation(p,a,b,c,d)
#define IDirectSound3DBuffer_SetConeOutsideVolume(p,a,b)    (p)->lpVtbl->SetConeOutsideVolume(p,a,b)
#define IDirectSound3DBuffer_SetPosition(p,a,b,c,d)         (p)->lpVtbl->SetPosition(p,a,b,c,d)
#define IDirectSound3DBuffer_SetMinDistance(p,a,b)          (p)->lpVtbl->SetMinDistance(p,a,b)
#define IDirectSound3DBuffer_SetMaxDistance(p,a,b)          (p)->lpVtbl->SetMaxDistance(p,a,b)
#define IDirectSound3DBuffer_SetMode(p,a,b)                 (p)->lpVtbl->SetMode(p,a,b)
#define IDirectSound3DBuffer_SetVelocity(p,a,b,c,d)         (p)->lpVtbl->SetVelocity(p,a,b,c,d)
#else // !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectSound3DBuffer_GetAllParameters(p,a)          (p)->GetAllParameters(a)
#define IDirectSound3DBuffer_GetConeAngles(p,a,b)           (p)->GetConeAngles(a,b)
#define IDirectSound3DBuffer_GetConeOrientation(p,a)        (p)->GetConeOrientation(a)
#define IDirectSound3DBuffer_GetConeOutsideVolume(p,a)      (p)->GetConeOutsideVolume(a)
#define IDirectSound3DBuffer_GetPosition(p,a)               (p)->GetPosition(a)
#define IDirectSound3DBuffer_GetMinDistance(p,a)            (p)->GetMinDistance(a)
#define IDirectSound3DBuffer_GetMaxDistance(p,a)            (p)->GetMaxDistance(a)
#define IDirectSound3DBuffer_GetMode(p,a)                   (p)->GetMode(a)
#define IDirectSound3DBuffer_GetVelocity(p,a)               (p)->GetVelocity(a)
#define IDirectSound3DBuffer_SetAllParameters(p,a,b)        (p)->SetAllParameters(a,b)
#define IDirectSound3DBuffer_SetConeAngles(p,a,b,c)         (p)->SetConeAngles(a,b,c)
#define IDirectSound3DBuffer_SetConeOrientation(p,a,b,c,d)  (p)->SetConeOrientation(a,b,c,d)
#define IDirectSound3DBuffer_SetConeOutsideVolume(p,a,b)    (p)->SetConeOutsideVolume(a,b)
#define IDirectSound3DBuffer_SetPosition(p,a,b,c,d)         (p)->SetPosition(a,b,c,d)
#define IDirectSound3DBuffer_SetMinDistance(p,a,b)          (p)->SetMinDistance(a,b)
#define IDirectSound3DBuffer_SetMaxDistance(p,a,b)          (p)->SetMaxDistance(a,b)
#define IDirectSound3DBuffer_SetMode(p,a,b)                 (p)->SetMode(a,b)
#define IDirectSound3DBuffer_SetVelocity(p,a,b,c,d)         (p)->SetVelocity(a,b,c,d)
#endif // !defined(__cplusplus) || defined(CINTERFACE)

//
// IDirectSoundCapture
//

DEFINE_GUID(IID_IDirectSoundCapture, 0xb0210781, 0x89cd, 0x11d0, 0xaf, 0x8, 0x0, 0xa0, 0xc9, 0x25, 0xcd, 0x16);

#undef INTERFACE
#define INTERFACE IDirectSoundCapture

DECLARE_INTERFACE_(IDirectSoundCapture, IUnknown)
{
    // IUnknown methods
    STDMETHOD(QueryInterface)       (THIS_ REFIID, LPVOID *) PURE;
    STDMETHOD_(ULONG,AddRef)        (THIS) PURE;
    STDMETHOD_(ULONG,Release)       (THIS) PURE;

    // IDirectSoundCapture methods
    STDMETHOD(CreateCaptureBuffer)  (THIS_ LPCDSCBUFFERDESC pcDSCBufferDesc, LPDIRECTSOUNDCAPTUREBUFFER *ppDSCBuffer, LPUNKNOWN pUnkOuter) PURE;
    STDMETHOD(GetCaps)              (THIS_ LPDSCCAPS pDSCCaps) PURE;
    STDMETHOD(Initialize)           (THIS_ LPCGUID pcGuidDevice) PURE;
};

#define IDirectSoundCapture_QueryInterface(p,a,b)           IUnknown_QueryInterface(p,a,b)
#define IDirectSoundCapture_AddRef(p)                       IUnknown_AddRef(p)
#define IDirectSoundCapture_Release(p)                      IUnknown_Release(p)

#if !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectSoundCapture_CreateCaptureBuffer(p,a,b,c)    (p)->lpVtbl->CreateCaptureBuffer(p,a,b,c)
#define IDirectSoundCapture_GetCaps(p,a)                    (p)->lpVtbl->GetCaps(p,a)
#define IDirectSoundCapture_Initialize(p,a)                 (p)->lpVtbl->Initialize(p,a)
#else // !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectSoundCapture_CreateCaptureBuffer(p,a,b,c)    (p)->CreateCaptureBuffer(a,b,c)
#define IDirectSoundCapture_GetCaps(p,a)                    (p)->GetCaps(a)
#define IDirectSoundCapture_Initialize(p,a)                 (p)->Initialize(a)
#endif // !defined(__cplusplus) || defined(CINTERFACE)

//
// IDirectSoundCaptureBuffer
//

DEFINE_GUID(IID_IDirectSoundCaptureBuffer, 0xb0210782, 0x89cd, 0x11d0, 0xaf, 0x8, 0x0, 0xa0, 0xc9, 0x25, 0xcd, 0x16);

#undef INTERFACE
#define INTERFACE IDirectSoundCaptureBuffer

DECLARE_INTERFACE_(IDirectSoundCaptureBuffer, IUnknown)
{
    // IUnknown methods
    STDMETHOD(QueryInterface)       (THIS_ REFIID, LPVOID *) PURE;
    STDMETHOD_(ULONG,AddRef)        (THIS) PURE;
    STDMETHOD_(ULONG,Release)       (THIS) PURE;

    // IDirectSoundCaptureBuffer methods
    STDMETHOD(GetCaps)              (THIS_ LPDSCBCAPS pDSCBCaps) PURE;
    STDMETHOD(GetCurrentPosition)   (THIS_ LPDWORD pdwCapturePosition, LPDWORD pdwReadPosition) PURE;
    STDMETHOD(GetFormat)            (THIS_ LPWAVEFORMATEX pwfxFormat, DWORD dwSizeAllocated, LPDWORD pdwSizeWritten) PURE;
    STDMETHOD(GetStatus)            (THIS_ LPDWORD pdwStatus) PURE;
    STDMETHOD(Initialize)           (THIS_ LPDIRECTSOUNDCAPTURE pDirectSoundCapture, LPCDSCBUFFERDESC pcDSCBufferDesc) PURE;
    STDMETHOD(Lock)                 (THIS_ DWORD dwOffset, DWORD dwBytes, LPVOID *ppvAudioPtr1, LPDWORD pdwAudioBytes1,
                                           LPVOID *ppvAudioPtr2, LPDWORD pdwAudioBytes2, DWORD dwFlags) PURE;
    STDMETHOD(Start)                (THIS_ DWORD dwFlags) PURE;
    STDMETHOD(Stop)                 (THIS) PURE;
    STDMETHOD(Unlock)               (THIS_ LPVOID pvAudioPtr1, DWORD dwAudioBytes1, LPVOID pvAudioPtr2, DWORD dwAudioBytes2) PURE;
};

#define IDirectSoundCaptureBuffer_QueryInterface(p,a,b)         IUnknown_QueryInterface(p,a,b)
#define IDirectSoundCaptureBuffer_AddRef(p)                     IUnknown_AddRef(p)
#define IDirectSoundCaptureBuffer_Release(p)                    IUnknown_Release(p)

#if !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectSoundCaptureBuffer_GetCaps(p,a)                  (p)->lpVtbl->GetCaps(p,a)
#define IDirectSoundCaptureBuffer_GetCurrentPosition(p,a,b)     (p)->lpVtbl->GetCurrentPosition(p,a,b)
#define IDirectSoundCaptureBuffer_GetFormat(p,a,b,c)            (p)->lpVtbl->GetFormat(p,a,b,c)
#define IDirectSoundCaptureBuffer_GetStatus(p,a)                (p)->lpVtbl->GetStatus(p,a)
#define IDirectSoundCaptureBuffer_Initialize(p,a,b)             (p)->lpVtbl->Initialize(p,a,b)
#define IDirectSoundCaptureBuffer_Lock(p,a,b,c,d,e,f,g)         (p)->lpVtbl->Lock(p,a,b,c,d,e,f,g)
#define IDirectSoundCaptureBuffer_Start(p,a)                    (p)->lpVtbl->Start(p,a)
#define IDirectSoundCaptureBuffer_Stop(p)                       (p)->lpVtbl->Stop(p)
#define IDirectSoundCaptureBuffer_Unlock(p,a,b,c,d)             (p)->lpVtbl->Unlock(p,a,b,c,d)
#else // !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectSoundCaptureBuffer_GetCaps(p,a)                  (p)->GetCaps(a)
#define IDirectSoundCaptureBuffer_GetCurrentPosition(p,a,b)     (p)->GetCurrentPosition(a,b)
#define IDirectSoundCaptureBuffer_GetFormat(p,a,b,c)            (p)->GetFormat(a,b,c)
#define IDirectSoundCaptureBuffer_GetStatus(p,a)                (p)->GetStatus(a)
#define IDirectSoundCaptureBuffer_Initialize(p,a,b)             (p)->Initialize(a,b)
#define IDirectSoundCaptureBuffer_Lock(p,a,b,c,d,e,f,g)         (p)->Lock(a,b,c,d,e,f,g)
#define IDirectSoundCaptureBuffer_Start(p,a)                    (p)->Start(a)
#define IDirectSoundCaptureBuffer_Stop(p)                       (p)->Stop()
#define IDirectSoundCaptureBuffer_Unlock(p,a,b,c,d)             (p)->Unlock(a,b,c,d)
#endif // !defined(__cplusplus) || defined(CINTERFACE)

//@@BEGIN_MSINTERNAL
#if DIRECTSOUND_VERSION >= 0x0701

//
// IDirectSoundCaptureBuffer7_1
//

DEFINE_GUID(IID_IDirectSoundCaptureBuffer7_1, 0xd6b2a50d, 0x918e, 0x47de, 0x9b, 0xcd, 0x64, 0xd4, 0x9c, 0x5b, 0x1d, 0x75);

#undef INTERFACE
#define INTERFACE IDirectSoundCaptureBuffer7_1

DECLARE_INTERFACE_(IDirectSoundCaptureBuffer7_1, IDirectSoundCaptureBuffer)
{
    // IUnknown methods
    STDMETHOD(QueryInterface)       (THIS_ REFIID, LPVOID *) PURE;
    STDMETHOD_(ULONG,AddRef)        (THIS) PURE;
    STDMETHOD_(ULONG,Release)       (THIS) PURE;

    // IDirectSoundCaptureBuffer methods
    STDMETHOD(GetCaps)              (THIS_ LPDSCBCAPS pDSCBCaps) PURE;
    STDMETHOD(GetCurrentPosition)   (THIS_ LPDWORD pdwCapturePosition, LPDWORD pdwReadPosition) PURE;
    STDMETHOD(GetFormat)            (THIS_ LPWAVEFORMATEX pwfxFormat, DWORD dwSizeAllocated, LPDWORD pdwSizeWritten) PURE;
    STDMETHOD(GetStatus)            (THIS_ LPDWORD pdwStatus) PURE;
    STDMETHOD(Initialize)           (THIS_ LPDIRECTSOUNDCAPTURE pDirectSoundCapture, LPCDSCBUFFERDESC pcDSCBufferDesc) PURE;
    STDMETHOD(Lock)                 (THIS_ DWORD dwOffset, DWORD dwBytes, LPVOID *ppvAudioPtr1, LPDWORD pdwAudioBytes1,
                                           LPVOID *ppvAudioPtr2, LPDWORD pdwAudioBytes2, DWORD dwFlags) PURE;
    STDMETHOD(Start)                (THIS_ DWORD dwFlags) PURE;
    STDMETHOD(Stop)                 (THIS) PURE;
    STDMETHOD(Unlock)               (THIS_ LPVOID pvAudioPtr1, DWORD dwAudioBytes1, LPVOID pvAudioPtr2, DWORD dwAudioBytes2) PURE;

    // IDirectSoundCaptureBuffer7_1 methods
    STDMETHOD(SetVolume)            (THIS_ LONG lVolume) PURE;
    STDMETHOD(GetVolume)            (THIS_ LPLONG plVolume) PURE;
    STDMETHOD(SetMicVolume)         (THIS_ LONG lVolume) PURE;
    STDMETHOD(GetMicVolume)         (THIS_ LPLONG plVolume) PURE;
    STDMETHOD(EnableMic)            (THIS_ BOOL fEnable) PURE;
    STDMETHOD(YieldFocus)           (THIS) PURE;
    STDMETHOD(ClaimFocus)           (THIS) PURE;
    STDMETHOD(SetFocusHWND)         (THIS_ HWND hwndMainWindow) PURE;
    STDMETHOD(GetFocusHWND)         (THIS_ HWND *phwndMainWindow) PURE;
    STDMETHOD(EnableFocusNotifications) (THIS_ HANDLE hFocusEvent) PURE;
};

#define IDirectSoundCaptureBuffer7_1_QueryInterface(p,a,b)            IUnknown_QueryInterface(p,a,b)
#define IDirectSoundCaptureBuffer7_1_AddRef(p)                        IUnknown_AddRef(p)
#define IDirectSoundCaptureBuffer7_1_Release(p)                       IUnknown_Release(p)

#if !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectSoundCaptureBuffer7_1_GetCaps(p,a)                     (p)->lpVtbl->GetCaps(p,a)
#define IDirectSoundCaptureBuffer7_1_GetCurrentPosition(p,a,b)        (p)->lpVtbl->GetCurrentPosition(p,a,b)
#define IDirectSoundCaptureBuffer7_1_GetFormat(p,a,b,c)               (p)->lpVtbl->GetFormat(p,a,b,c)
#define IDirectSoundCaptureBuffer7_1_GetStatus(p,a)                   (p)->lpVtbl->GetStatus(p,a)
#define IDirectSoundCaptureBuffer7_1_Initialize(p,a,b)                (p)->lpVtbl->Initialize(p,a,b)
#define IDirectSoundCaptureBuffer7_1_Lock(p,a,b,c,d,e,f,g)            (p)->lpVtbl->Lock(p,a,b,c,d,e,f,g)
#define IDirectSoundCaptureBuffer7_1_Start(p,a)                       (p)->lpVtbl->Start(p,a)
#define IDirectSoundCaptureBuffer7_1_Stop(p)                          (p)->lpVtbl->Stop(p)
#define IDirectSoundCaptureBuffer7_1_Unlock(p,a,b,c,d)                (p)->lpVtbl->Unlock(p,a,b,c,d)
#define IDirectSoundCaptureBuffer7_1_SetMicVolume(p,a)                (p)->lpVtbl->SetMicVolume(p,a)
#define IDirectSoundCaptureBuffer7_1_GetMicVolume(p,a)                (p)->lpVtbl->GetMicVolume(p,a)
#define IDirectSoundCaptureBuffer7_1_YieldFocus(p)                    (p)->lpVtbl->YieldFocus(p)
#define IDirectSoundCaptureBuffer7_1_ClaimFocus(p)                    (p)->lpVtbl->ClaimFocus(p)
#define IDirectSoundCaptureBuffer7_1_SetFocusHWND(p,a)                (p)->lpVtbl->SetFocusHWND(p,a)
#define IDirectSoundCaptureBuffer7_1_GetFocusHWND(p,a)                (p)->lpVtbl->GetFocusHWND(p,a)
#define IDirectSoundCaptureBuffer7_1_SetFocusNotificationHandler(p,a) (p)->lpVtbl->EnableFocusNotifications(p,a)
#else // !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectSoundCaptureBuffer7_1_GetCaps(p,a)                     (p)->GetCaps(a)
#define IDirectSoundCaptureBuffer7_1_GetCurrentPosition(p,a,b)        (p)->GetCurrentPosition(a,b)
#define IDirectSoundCaptureBuffer7_1_GetFormat(p,a,b,c)               (p)->GetFormat(a,b,c)
#define IDirectSoundCaptureBuffer7_1_GetStatus(p,a)                   (p)->GetStatus(a)
#define IDirectSoundCaptureBuffer7_1_Initialize(p,a,b)                (p)->Initialize(a,b)
#define IDirectSoundCaptureBuffer7_1_Lock(p,a,b,c,d,e,f,g)            (p)->Lock(a,b,c,d,e,f,g)
#define IDirectSoundCaptureBuffer7_1_Start(p,a)                       (p)->Start(a)
#define IDirectSoundCaptureBuffer7_1_Stop(p)                          (p)->Stop()
#define IDirectSoundCaptureBuffer7_1_Unlock(p,a,b,c,d)                (p)->Unlock(a,b,c,d)
#define IDirectSoundCaptureBuffer7_1_SetMicVolume(p,a)                (p)->SetMicVolume(a)
#define IDirectSoundCaptureBuffer7_1_GetMicVolume(p,a)                (p)->GetMicVolume(a)
#define IDirectSoundCaptureBuffer7_1_YieldFocus(p)                    (p)->YieldFocus()
#define IDirectSoundCaptureBuffer7_1_ClaimFocus(p)                    (p)->ClaimFocus()
#define IDirectSoundCaptureBuffer7_1_SetFocusHWND(p,a)                (p)->SetFocusHWND(a)
#define IDirectSoundCaptureBuffer7_1_GetFocusHWND(p,a)                (p)->GetFocusHWND(a)
#define IDirectSoundCaptureBuffer7_1_SetFocusNotificationHandler(p,a) (p)->EnableFocusNotifications(a)
#endif // !defined(__cplusplus) || defined(CINTERFACE)

#endif // DIRECTSOUND_VERSION >= 0x0701
//@@END_MSINTERNAL

#if DIRECTSOUND_VERSION >= 0x0800

//
// IDirectSoundCaptureBuffer8
//

DEFINE_GUID(IID_IDirectSoundCaptureBuffer8, 0x990df4, 0xdbb, 0x4872, 0x83, 0x3e, 0x6d, 0x30, 0x3e, 0x80, 0xae, 0xb6);

#undef INTERFACE
#define INTERFACE IDirectSoundCaptureBuffer8

DECLARE_INTERFACE_(IDirectSoundCaptureBuffer8, IDirectSoundCaptureBuffer)
{
    // IUnknown methods
    STDMETHOD(QueryInterface)       (THIS_ REFIID, LPVOID *) PURE;
    STDMETHOD_(ULONG,AddRef)        (THIS) PURE;
    STDMETHOD_(ULONG,Release)       (THIS) PURE;

    // IDirectSoundCaptureBuffer methods
    STDMETHOD(GetCaps)              (THIS_ LPDSCBCAPS pDSCBCaps) PURE;
    STDMETHOD(GetCurrentPosition)   (THIS_ LPDWORD pdwCapturePosition, LPDWORD pdwReadPosition) PURE;
    STDMETHOD(GetFormat)            (THIS_ LPWAVEFORMATEX pwfxFormat, DWORD dwSizeAllocated, LPDWORD pdwSizeWritten) PURE;
    STDMETHOD(GetStatus)            (THIS_ LPDWORD pdwStatus) PURE;
    STDMETHOD(Initialize)           (THIS_ LPDIRECTSOUNDCAPTURE pDirectSoundCapture, LPCDSCBUFFERDESC pcDSCBufferDesc) PURE;
    STDMETHOD(Lock)                 (THIS_ DWORD dwOffset, DWORD dwBytes, LPVOID *ppvAudioPtr1, LPDWORD pdwAudioBytes1,
                                           LPVOID *ppvAudioPtr2, LPDWORD pdwAudioBytes2, DWORD dwFlags) PURE;
    STDMETHOD(Start)                (THIS_ DWORD dwFlags) PURE;
    STDMETHOD(Stop)                 (THIS) PURE;
    STDMETHOD(Unlock)               (THIS_ LPVOID pvAudioPtr1, DWORD dwAudioBytes1, LPVOID pvAudioPtr2, DWORD dwAudioBytes2) PURE;

    // IDirectSoundCaptureBuffer8 methods
    STDMETHOD(GetObjectInPath)      (THIS_ REFGUID rguidObject, DWORD dwIndex, REFGUID rguidInterface, LPVOID *ppObject) PURE;
    STDMETHOD(GetFXStatus)          (DWORD dwFXCount, LPDWORD pdwFXStatus) PURE;
};

#define IDirectSoundCaptureBuffer8_QueryInterface(p,a,b)            IUnknown_QueryInterface(p,a,b)
#define IDirectSoundCaptureBuffer8_AddRef(p)                        IUnknown_AddRef(p)
#define IDirectSoundCaptureBuffer8_Release(p)                       IUnknown_Release(p)

#define IDirectSoundCaptureBuffer8_GetCaps(p,a)                     IDirectSoundCaptureBuffer_GetCaps(p,a)
#define IDirectSoundCaptureBuffer8_GetCurrentPosition(p,a,b)        IDirectSoundCaptureBuffer_GetCurrentPosition(p,a,b)
#define IDirectSoundCaptureBuffer8_GetFormat(p,a,b,c)               IDirectSoundCaptureBuffer_GetFormat(p,a,b,c)
#define IDirectSoundCaptureBuffer8_GetStatus(p,a)                   IDirectSoundCaptureBuffer_GetStatus(p,a)
#define IDirectSoundCaptureBuffer8_Initialize(p,a,b)                IDirectSoundCaptureBuffer_Initialize(p,a,b)
#define IDirectSoundCaptureBuffer8_Lock(p,a,b,c,d,e,f,g)            IDirectSoundCaptureBuffer_Lock(p,a,b,c,d,e,f,g)
#define IDirectSoundCaptureBuffer8_Start(p,a)                       IDirectSoundCaptureBuffer_Start(p,a)
#define IDirectSoundCaptureBuffer8_Stop(p)                          IDirectSoundCaptureBuffer_Stop(p))
#define IDirectSoundCaptureBuffer8_Unlock(p,a,b,c,d)                IDirectSoundCaptureBuffer_Unlock(p,a,b,c,d)

#if !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectSoundCaptureBuffer8_GetObjectInPath(p,a,b,c,d)       (p)->lpVtbl->GetObjectInPath(p,a,b,c,d)
#define IDirectSoundCaptureBuffer8_GetFXStatus(p,a,b)               (p)->lpVtbl->GetFXStatus(p,a,b)
#else // !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectSoundCaptureBuffer8_GetObjectInPath(p,a,b,c,d)       (p)->GetObjectInPath(a,b,c,d)
#define IDirectSoundCaptureBuffer8_GetFXStatus(p,a,b)               (p)->GetFXStatus(a,b)
#endif // !defined(__cplusplus) || defined(CINTERFACE)

#endif // DIRECTSOUND_VERSION >= 0x0800

//
// IDirectSoundNotify
//

DEFINE_GUID(IID_IDirectSoundNotify, 0xb0210783, 0x89cd, 0x11d0, 0xaf, 0x8, 0x0, 0xa0, 0xc9, 0x25, 0xcd, 0x16);

#undef INTERFACE
#define INTERFACE IDirectSoundNotify

DECLARE_INTERFACE_(IDirectSoundNotify, IUnknown)
{
    // IUnknown methods
    STDMETHOD(QueryInterface)           (THIS_ REFIID, LPVOID *) PURE;
    STDMETHOD_(ULONG,AddRef)            (THIS) PURE;
    STDMETHOD_(ULONG,Release)           (THIS) PURE;

    // IDirectSoundNotify methods
    STDMETHOD(SetNotificationPositions) (THIS_ DWORD dwPositionNotifies, LPCDSBPOSITIONNOTIFY pcPositionNotifies) PURE;
};

#define IDirectSoundNotify_QueryInterface(p,a,b)            IUnknown_QueryInterface(p,a,b)
#define IDirectSoundNotify_AddRef(p)                        IUnknown_AddRef(p)
#define IDirectSoundNotify_Release(p)                       IUnknown_Release(p)

#if !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectSoundNotify_SetNotificationPositions(p,a,b)  (p)->lpVtbl->SetNotificationPositions(p,a,b)
#else // !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectSoundNotify_SetNotificationPositions(p,a,b)  (p)->SetNotificationPositions(a,b)
#endif // !defined(__cplusplus) || defined(CINTERFACE)

//
// IKsPropertySet
//

#ifndef _IKsPropertySet_
#define _IKsPropertySet_

#ifdef __cplusplus
// 'struct' not 'class' per the way DECLARE_INTERFACE_ is defined
struct IKsPropertySet;
#endif // __cplusplus

typedef struct IKsPropertySet *LPKSPROPERTYSET;

#define KSPROPERTY_SUPPORT_GET  0x00000001
#define KSPROPERTY_SUPPORT_SET  0x00000002

DEFINE_GUID(IID_IKsPropertySet, 0x31efac30, 0x515c, 0x11d0, 0xa9, 0xaa, 0x00, 0xaa, 0x00, 0x61, 0xbe, 0x93);

#undef INTERFACE
#define INTERFACE IKsPropertySet

DECLARE_INTERFACE_(IKsPropertySet, IUnknown)
{
    // IUnknown methods
    STDMETHOD(QueryInterface)   (THIS_ REFIID, LPVOID *) PURE;
    STDMETHOD_(ULONG,AddRef)    (THIS) PURE;
    STDMETHOD_(ULONG,Release)   (THIS) PURE;

    // IKsPropertySet methods
    STDMETHOD(Get)              (THIS_ REFGUID rguidPropSet, ULONG ulId, LPVOID pInstanceData, ULONG ulInstanceLength,
                                       LPVOID pPropertyData, ULONG ulDataLength, PULONG pulBytesReturned) PURE;
    STDMETHOD(Set)              (THIS_ REFGUID rguidPropSet, ULONG ulId, LPVOID pInstanceData, ULONG ulInstanceLength,
                                       LPVOID pPropertyData, ULONG ulDataLength) PURE;
    STDMETHOD(QuerySupport)     (THIS_ REFGUID rguidPropSet, ULONG ulId, PULONG pulTypeSupport) PURE;
};

#define IKsPropertySet_QueryInterface(p,a,b)       IUnknown_QueryInterface(p,a,b)
#define IKsPropertySet_AddRef(p)                   IUnknown_AddRef(p)
#define IKsPropertySet_Release(p)                  IUnknown_Release(p)

#if !defined(__cplusplus) || defined(CINTERFACE)
#define IKsPropertySet_Get(p,a,b,c,d,e,f,g)        (p)->lpVtbl->Get(p,a,b,c,d,e,f,g)
#define IKsPropertySet_Set(p,a,b,c,d,e,f)          (p)->lpVtbl->Set(p,a,b,c,d,e,f)
#define IKsPropertySet_QuerySupport(p,a,b,c)       (p)->lpVtbl->QuerySupport(p,a,b,c)
#else // !defined(__cplusplus) || defined(CINTERFACE)
#define IKsPropertySet_Get(p,a,b,c,d,e,f,g)        (p)->Get(a,b,c,d,e,f,g)
#define IKsPropertySet_Set(p,a,b,c,d,e,f)          (p)->Set(a,b,c,d,e,f)
#define IKsPropertySet_QuerySupport(p,a,b,c)       (p)->QuerySupport(a,b,c)
#endif // !defined(__cplusplus) || defined(CINTERFACE)

#endif // _IKsPropertySet_

#if DIRECTSOUND_VERSION >= 0x0800
//@@BEGIN_MSINTERNAL

//
// IDirectSoundFXSend
//

DEFINE_GUID(IID_IDirectSoundFXSend, 0xb30f3564, 0x1698, 0x45ba, 0x9f, 0x75, 0xfc, 0x3c, 0x6c, 0x3b, 0x28, 0x10);

typedef struct _DSFXSend
{
    LONG lSendLevel;
} DSFXSend, *LPDSFXSend;

typedef const DSFXSend *LPCDSFXSend;

#undef INTERFACE
#define INTERFACE IDirectSoundFXSend

DECLARE_INTERFACE_(IDirectSoundFXSend, IUnknown)
{
    // IUnknown methods
    STDMETHOD(QueryInterface)       (THIS_ REFIID, LPVOID *) PURE;
    STDMETHOD_(ULONG,AddRef)        (THIS) PURE;
    STDMETHOD_(ULONG,Release)       (THIS) PURE;

    // IDirectSoundFXSend methods
    STDMETHOD(SetAllParameters)     (THIS_ LPCDSFXSend pcDsFxSend) PURE;
    STDMETHOD(GetAllParameters)     (THIS_ LPDSFXSend pDsFxSend) PURE;
};

#define IDirectSoundFXSend_QueryInterface(p,a,b)            IUnknown_QueryInterface(p,a,b)
#define IDirectSoundFXSend_AddRef(p)                        IUnknown_AddRef(p)
#define IDirectSoundFXSend_Release(p)                       IUnknown_Release(p)

#if !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectSoundFXSend_SetAllParameters(p,a)            (p)->lpVtbl->SetAllParameters(p,a)
#define IDirectSoundFXSend_GetAllParameters(p,a)            (p)->lpVtbl->GetAllParameters(p,a)
#else // !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectSoundFXSend_SetAllParameters(p,a)            (p)->SetAllParameters(a)
#define IDirectSoundFXSend_GetAllParameters(p,a)            (p)->GetAllParameters(a)
#endif // !defined(__cplusplus) || defined(CINTERFACE)
//@@END_MSINTERNAL

//
// IDirectSoundFXGargle
//

DEFINE_GUID(IID_IDirectSoundFXGargle, 0xd616f352, 0xd622, 0x11ce, 0xaa, 0xc5, 0x00, 0x20, 0xaf, 0x0b, 0x99, 0xa3);

typedef struct _DSFXGargle
{
    DWORD       dwRateHz;               // Rate of modulation in hz
    DWORD       dwWaveShape;            // DSFXGARGLE_WAVE_xxx
} DSFXGargle, *LPDSFXGargle;

#define DSFXGARGLE_WAVE_TRIANGLE        0
#define DSFXGARGLE_WAVE_SQUARE          1

typedef const DSFXGargle *LPCDSFXGargle;

#define DSFXGARGLE_RATEHZ_MIN           1
#define DSFXGARGLE_RATEHZ_MAX           1000

#undef INTERFACE
#define INTERFACE IDirectSoundFXGargle

DECLARE_INTERFACE_(IDirectSoundFXGargle, IUnknown)
{
    // IUnknown methods
    STDMETHOD(QueryInterface)       (THIS_ REFIID, LPVOID *) PURE;
    STDMETHOD_(ULONG,AddRef)        (THIS) PURE;
    STDMETHOD_(ULONG,Release)       (THIS) PURE;

    // IDirectSoundFXGargle methods
    STDMETHOD(SetAllParameters)     (THIS_ LPCDSFXGargle pcDsFxGargle) PURE;
    STDMETHOD(GetAllParameters)     (THIS_ LPDSFXGargle pDsFxGargle) PURE;
};

#define IDirectSoundFXGargle_QueryInterface(p,a,b)          IUnknown_QueryInterface(p,a,b)
#define IDirectSoundFXGargle_AddRef(p)                      IUnknown_AddRef(p)
#define IDirectSoundFXGargle_Release(p)                     IUnknown_Release(p)

#if !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectSoundFXGargle_SetAllParameters(p,a)          (p)->lpVtbl->SetAllParameters(p,a)
#define IDirectSoundFXGargle_GetAllParameters(p,a)          (p)->lpVtbl->GetAllParameters(p,a)
#else // !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectSoundFXGargle_SetAllParameters(p,a)          (p)->SetAllParameters(a)
#define IDirectSoundFXGargle_GetAllParameters(p,a)          (p)->GetAllParameters(a)
#endif // !defined(__cplusplus) || defined(CINTERFACE)

//
// IDirectSoundFXChorus
//

DEFINE_GUID(IID_IDirectSoundFXChorus, 0x880842e3, 0x145f, 0x43e6, 0xa9, 0x34, 0xa7, 0x18, 0x06, 0xe5, 0x05, 0x47);

typedef struct _DSFXChorus
{
    FLOAT       fWetDryMix;
    FLOAT       fDepth;
    FLOAT       fFeedback;
    FLOAT       fFrequency;
    LONG        lWaveform;          // LFO shape; DSFXCHORUS_WAVE_xxx
    FLOAT       fDelay;
    LONG        lPhase;
} DSFXChorus, *LPDSFXChorus;

typedef const DSFXChorus *LPCDSFXChorus;

#define DSFXCHORUS_WAVE_TRIANGLE        0
#define DSFXCHORUS_WAVE_SIN             1

#define DSFXCHORUS_WETDRYMIX_MIN        0.0f
#define DSFXCHORUS_WETDRYMIX_MAX        100.0f
#define DSFXCHORUS_DEPTH_MIN            0.0f
#define DSFXCHORUS_DEPTH_MAX            100.0f
#define DSFXCHORUS_FEEDBACK_MIN         -99.0f
#define DSFXCHORUS_FEEDBACK_MAX         99.0f
#define DSFXCHORUS_FREQUENCY_MIN        0.0f
#define DSFXCHORUS_FREQUENCY_MAX        10.0f
#define DSFXCHORUS_DELAY_MIN            0.0f
#define DSFXCHORUS_DELAY_MAX            20.0f
#define DSFXCHORUS_PHASE_MIN            0
#define DSFXCHORUS_PHASE_MAX            4

#define DSFXCHORUS_PHASE_NEG_180        0
#define DSFXCHORUS_PHASE_NEG_90         1
#define DSFXCHORUS_PHASE_ZERO           2
#define DSFXCHORUS_PHASE_90             3
#define DSFXCHORUS_PHASE_180            4

#undef INTERFACE
#define INTERFACE IDirectSoundFXChorus

DECLARE_INTERFACE_(IDirectSoundFXChorus, IUnknown)
{
    // IUnknown methods
    STDMETHOD(QueryInterface)       (THIS_ REFIID, LPVOID *) PURE;
    STDMETHOD_(ULONG,AddRef)        (THIS) PURE;
    STDMETHOD_(ULONG,Release)       (THIS) PURE;

    // IDirectSoundFXChorus methods
    STDMETHOD(SetAllParameters)     (THIS_ LPCDSFXChorus pcDsFxChorus) PURE;
    STDMETHOD(GetAllParameters)     (THIS_ LPDSFXChorus pDsFxChorus) PURE;
};

#define IDirectSoundFXChorus_QueryInterface(p,a,b)          IUnknown_QueryInterface(p,a,b)
#define IDirectSoundFXChorus_AddRef(p)                      IUnknown_AddRef(p)
#define IDirectSoundFXChorus_Release(p)                     IUnknown_Release(p)

#if !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectSoundFXChorus_SetAllParameters(p,a)          (p)->lpVtbl->SetAllParameters(p,a)
#define IDirectSoundFXChorus_GetAllParameters(p,a)          (p)->lpVtbl->GetAllParameters(p,a)
#else // !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectSoundFXChorus_SetAllParameters(p,a)          (p)->SetAllParameters(a)
#define IDirectSoundFXChorus_GetAllParameters(p,a)          (p)->GetAllParameters(a)
#endif // !defined(__cplusplus) || defined(CINTERFACE)

//
// IDirectSoundFXFlanger
//

DEFINE_GUID(IID_IDirectSoundFXFlanger, 0x903e9878, 0x2c92, 0x4072, 0x9b, 0x2c, 0xea, 0x68, 0xf5, 0x39, 0x67, 0x83);

typedef struct _DSFXFlanger
{
    FLOAT       fWetDryMix;
    FLOAT       fDepth;
    FLOAT       fFeedback;
    FLOAT       fFrequency;
    LONG        lWaveform;
    FLOAT       fDelay;
    LONG        lPhase;
} DSFXFlanger, *LPDSFXFlanger;

typedef const DSFXFlanger *LPCDSFXFlanger;

#define DSFXFLANGER_WAVE_TRIANGLE       0
#define DSFXFLANGER_WAVE_SIN            1

#define DSFXFLANGER_WETDRYMIX_MIN       0.0f
#define DSFXFLANGER_WETDRYMIX_MAX       100.0f
#define DSFXFLANGER_FREQUENCY_MIN       0.0f
#define DSFXFLANGER_FREQUENCY_MAX       10.0f
#define DSFXFLANGER_DEPTH_MIN           0.0f
#define DSFXFLANGER_DEPTH_MAX           100.0f
#define DSFXFLANGER_PHASE_MIN           0
#define DSFXFLANGER_PHASE_MAX           4
#define DSFXFLANGER_FEEDBACK_MIN        -99.0f
#define DSFXFLANGER_FEEDBACK_MAX        99.0f
#define DSFXFLANGER_DELAY_MIN           0.0f
#define DSFXFLANGER_DELAY_MAX           4.0f

#define DSFXFLANGER_PHASE_NEG_180       0
#define DSFXFLANGER_PHASE_NEG_90        1
#define DSFXFLANGER_PHASE_ZERO          2
#define DSFXFLANGER_PHASE_90            3
#define DSFXFLANGER_PHASE_180           4

#undef INTERFACE
#define INTERFACE IDirectSoundFXFlanger

DECLARE_INTERFACE_(IDirectSoundFXFlanger, IUnknown)
{
    // IUnknown methods
    STDMETHOD(QueryInterface)       (THIS_ REFIID, LPVOID *) PURE;
    STDMETHOD_(ULONG,AddRef)        (THIS) PURE;
    STDMETHOD_(ULONG,Release)       (THIS) PURE;

    // IDirectSoundFXFlanger methods
    STDMETHOD(SetAllParameters)     (THIS_ LPCDSFXFlanger pcDsFxFlanger) PURE;
    STDMETHOD(GetAllParameters)     (THIS_ LPDSFXFlanger pDsFxFlanger) PURE;
};

#define IDirectSoundFXFlanger_QueryInterface(p,a,b)         IUnknown_QueryInterface(p,a,b)
#define IDirectSoundFXFlanger_AddRef(p)                     IUnknown_AddRef(p)
#define IDirectSoundFXFlanger_Release(p)                    IUnknown_Release(p)

#if !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectSoundFXFlanger_SetAllParameters(p,a)         (p)->lpVtbl->SetAllParameters(p,a)
#define IDirectSoundFXFlanger_GetAllParameters(p,a)         (p)->lpVtbl->GetAllParameters(p,a)
#else // !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectSoundFXFlanger_SetAllParameters(p,a)         (p)->SetAllParameters(a)
#define IDirectSoundFXFlanger_GetAllParameters(p,a)         (p)->GetAllParameters(a)
#endif // !defined(__cplusplus) || defined(CINTERFACE)

//
// IDirectSoundFXEcho
//

DEFINE_GUID(IID_IDirectSoundFXEcho, 0x8bd28edf, 0x50db, 0x4e92, 0xa2, 0xbd, 0x44, 0x54, 0x88, 0xd1, 0xed, 0x42);

typedef struct _DSFXEcho
{
    FLOAT   fWetDryMix;
    FLOAT   fFeedback;
    FLOAT   fLeftDelay;
    FLOAT   fRightDelay;
    LONG    lPanDelay;
} DSFXEcho, *LPDSFXEcho;

typedef const DSFXEcho *LPCDSFXEcho;

#define DSFXECHO_WETDRYMIX_MIN      0.0f
#define DSFXECHO_WETDRYMIX_MAX      100.0f
#define DSFXECHO_FEEDBACK_MIN       0.0f
#define DSFXECHO_FEEDBACK_MAX       100.0f
#define DSFXECHO_LEFTDELAY_MIN      1.0f
#define DSFXECHO_LEFTDELAY_MAX      2000.0f
#define DSFXECHO_RIGHTDELAY_MIN     1.0f
#define DSFXECHO_RIGHTDELAY_MAX     2000.0f
#define DSFXECHO_PANDELAY_MIN       0
#define DSFXECHO_PANDELAY_MAX       1

#undef INTERFACE
#define INTERFACE IDirectSoundFXEcho

DECLARE_INTERFACE_(IDirectSoundFXEcho, IUnknown)
{
    // IUnknown methods
    STDMETHOD(QueryInterface)       (THIS_ REFIID, LPVOID *) PURE;
    STDMETHOD_(ULONG,AddRef)        (THIS) PURE;
    STDMETHOD_(ULONG,Release)       (THIS) PURE;

    // IDirectSoundFXEcho methods
    STDMETHOD(SetAllParameters)     (THIS_ LPCDSFXEcho pcDsFxEcho) PURE;
    STDMETHOD(GetAllParameters)     (THIS_ LPDSFXEcho pDsFxEcho) PURE;
};

#define IDirectSoundFXEcho_QueryInterface(p,a,b)            IUnknown_QueryInterface(p,a,b)
#define IDirectSoundFXEcho_AddRef(p)                        IUnknown_AddRef(p)
#define IDirectSoundFXEcho_Release(p)                       IUnknown_Release(p)

#if !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectSoundFXEcho_SetAllParameters(p,a)            (p)->lpVtbl->SetAllParameters(p,a)
#define IDirectSoundFXEcho_GetAllParameters(p,a)            (p)->lpVtbl->GetAllParameters(p,a)
#else // !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectSoundFXEcho_SetAllParameters(p,a)            (p)->SetAllParameters(a)
#define IDirectSoundFXEcho_GetAllParameters(p,a)            (p)->GetAllParameters(a)
#endif // !defined(__cplusplus) || defined(CINTERFACE)

//
// IDirectSoundFXDistortion
//

DEFINE_GUID(IID_IDirectSoundFXDistortion, 0x8ecf4326, 0x455f, 0x4d8b, 0xbd, 0xa9, 0x8d, 0x5d, 0x3e, 0x9e, 0x3e, 0x0b);

typedef struct _DSFXDistortion
{
    FLOAT   fGain;
    FLOAT   fEdge;
    FLOAT   fPostEQCenterFrequency;
    FLOAT   fPostEQBandwidth;
    FLOAT   fPreLowpassCutoff;
} DSFXDistortion, *LPDSFXDistortion;

typedef const DSFXDistortion *LPCDSFXDistortion;

#define DSFXDISTORTION_GAIN_MIN                     -60.0f
#define DSFXDISTORTION_GAIN_MAX                     0.0f
#define DSFXDISTORTION_EDGE_MIN                     0.0f
#define DSFXDISTORTION_EDGE_MAX                     100.0f
#define DSFXDISTORTION_POSTEQCENTERFREQUENCY_MIN    100.0f
#define DSFXDISTORTION_POSTEQCENTERFREQUENCY_MAX    8000.0f
#define DSFXDISTORTION_POSTEQBANDWIDTH_MIN          100.0f
#define DSFXDISTORTION_POSTEQBANDWIDTH_MAX          8000.0f
#define DSFXDISTORTION_PRELOWPASSCUTOFF_MIN         100.0f
#define DSFXDISTORTION_PRELOWPASSCUTOFF_MAX         8000.0f

#undef INTERFACE
#define INTERFACE IDirectSoundFXDistortion

DECLARE_INTERFACE_(IDirectSoundFXDistortion, IUnknown)
{
    // IUnknown methods
    STDMETHOD(QueryInterface)       (THIS_ REFIID, LPVOID *) PURE;
    STDMETHOD_(ULONG,AddRef)        (THIS) PURE;
    STDMETHOD_(ULONG,Release)       (THIS) PURE;

    // IDirectSoundFXDistortion methods
    STDMETHOD(SetAllParameters)     (THIS_ LPCDSFXDistortion pcDsFxDistortion) PURE;
    STDMETHOD(GetAllParameters)     (THIS_ LPDSFXDistortion pDsFxDistortion) PURE;
};

#define IDirectSoundFXDistortion_QueryInterface(p,a,b)      IUnknown_QueryInterface(p,a,b)
#define IDirectSoundFXDistortion_AddRef(p)                  IUnknown_AddRef(p)
#define IDirectSoundFXDistortion_Release(p)                 IUnknown_Release(p)

#if !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectSoundFXDistortion_SetAllParameters(p,a)      (p)->lpVtbl->SetAllParameters(p,a)
#define IDirectSoundFXDistortion_GetAllParameters(p,a)      (p)->lpVtbl->GetAllParameters(p,a)
#else // !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectSoundFXDistortion_SetAllParameters(p,a)      (p)->SetAllParameters(a)
#define IDirectSoundFXDistortion_GetAllParameters(p,a)      (p)->GetAllParameters(a)
#endif // !defined(__cplusplus) || defined(CINTERFACE)

//
// IDirectSoundFXCompressor
//

DEFINE_GUID(IID_IDirectSoundFXCompressor, 0x4bbd1154, 0x62f6, 0x4e2c, 0xa1, 0x5c, 0xd3, 0xb6, 0xc4, 0x17, 0xf7, 0xa0);

typedef struct _DSFXCompressor
{
    FLOAT   fGain;
    FLOAT   fAttack;
    FLOAT   fRelease;
    FLOAT   fThreshold;
    FLOAT   fRatio;
    FLOAT   fPredelay;
} DSFXCompressor, *LPDSFXCompressor;

typedef const DSFXCompressor *LPCDSFXCompressor;

#define DSFXCOMPRESSOR_GAIN_MIN             -60.0f
#define DSFXCOMPRESSOR_GAIN_MAX             60.0f
#define DSFXCOMPRESSOR_ATTACK_MIN           0.01f
#define DSFXCOMPRESSOR_ATTACK_MAX           500.0f
#define DSFXCOMPRESSOR_RELEASE_MIN          50.0f
#define DSFXCOMPRESSOR_RELEASE_MAX          3000.0f
#define DSFXCOMPRESSOR_THRESHOLD_MIN        -60.0f
#define DSFXCOMPRESSOR_THRESHOLD_MAX        0.0f
#define DSFXCOMPRESSOR_RATIO_MIN            1.0f
#define DSFXCOMPRESSOR_RATIO_MAX            100.0f
#define DSFXCOMPRESSOR_PREDELAY_MIN         0.0f
#define DSFXCOMPRESSOR_PREDELAY_MAX         4.0f

#undef INTERFACE
#define INTERFACE IDirectSoundFXCompressor

DECLARE_INTERFACE_(IDirectSoundFXCompressor, IUnknown)
{
    // IUnknown methods
    STDMETHOD(QueryInterface)       (THIS_ REFIID, LPVOID *) PURE;
    STDMETHOD_(ULONG,AddRef)        (THIS) PURE;
    STDMETHOD_(ULONG,Release)       (THIS) PURE;

    // IDirectSoundFXCompressor methods
    STDMETHOD(SetAllParameters)     (THIS_ LPCDSFXCompressor pcDsFxCompressor) PURE;
    STDMETHOD(GetAllParameters)     (THIS_ LPDSFXCompressor pDsFxCompressor) PURE;
};

#define IDirectSoundFXCompressor_QueryInterface(p,a,b)      IUnknown_QueryInterface(p,a,b)
#define IDirectSoundFXCompressor_AddRef(p)                  IUnknown_AddRef(p)
#define IDirectSoundFXCompressor_Release(p)                 IUnknown_Release(p)

#if !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectSoundFXCompressor_SetAllParameters(p,a)      (p)->lpVtbl->SetAllParameters(p,a)
#define IDirectSoundFXCompressor_GetAllParameters(p,a)      (p)->lpVtbl->GetAllParameters(p,a)
#else // !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectSoundFXCompressor_SetAllParameters(p,a)      (p)->SetAllParameters(a)
#define IDirectSoundFXCompressor_GetAllParameters(p,a)      (p)->GetAllParameters(a)
#endif // !defined(__cplusplus) || defined(CINTERFACE)

//
// IDirectSoundFXParamEq
//

DEFINE_GUID(IID_IDirectSoundFXParamEq, 0xc03ca9fe, 0xfe90, 0x4204, 0x80, 0x78, 0x82, 0x33, 0x4c, 0xd1, 0x77, 0xda);

typedef struct _DSFXParamEq
{
    FLOAT   fCenter;
    FLOAT   fBandwidth;
    FLOAT   fGain;
} DSFXParamEq, *LPDSFXParamEq;

typedef const DSFXParamEq *LPCDSFXParamEq;

#define DSFXPARAMEQ_CENTER_MIN      80.0f
#define DSFXPARAMEQ_CENTER_MAX      16000.0f
#define DSFXPARAMEQ_BANDWIDTH_MIN   1.0f
#define DSFXPARAMEQ_BANDWIDTH_MAX   36.0f
#define DSFXPARAMEQ_GAIN_MIN        -15.0f
#define DSFXPARAMEQ_GAIN_MAX        15.0f

#undef INTERFACE
#define INTERFACE IDirectSoundFXParamEq

DECLARE_INTERFACE_(IDirectSoundFXParamEq, IUnknown)
{
    // IUnknown methods
    STDMETHOD(QueryInterface)       (THIS_ REFIID, LPVOID *) PURE;
    STDMETHOD_(ULONG,AddRef)        (THIS) PURE;
    STDMETHOD_(ULONG,Release)       (THIS) PURE;

    // IDirectSoundFXParamEq methods
    STDMETHOD(SetAllParameters)     (THIS_ LPCDSFXParamEq pcDsFxParamEq) PURE;
    STDMETHOD(GetAllParameters)     (THIS_ LPDSFXParamEq pDsFxParamEq) PURE;
};

#define IDirectSoundFXParamEq_QueryInterface(p,a,b)      IUnknown_QueryInterface(p,a,b)
#define IDirectSoundFXParamEq_AddRef(p)                  IUnknown_AddRef(p)
#define IDirectSoundFXParamEq_Release(p)                 IUnknown_Release(p)

#if !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectSoundFXParamEq_SetAllParameters(p,a)      (p)->lpVtbl->SetAllParameters(p,a)
#define IDirectSoundFXParamEq_GetAllParameters(p,a)      (p)->lpVtbl->GetAllParameters(p,a)
#else // !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectSoundFXParamEq_SetAllParameters(p,a)      (p)->SetAllParameters(a)
#define IDirectSoundFXParamEq_GetAllParameters(p,a)      (p)->GetAllParameters(a)
#endif // !defined(__cplusplus) || defined(CINTERFACE)

//@@BEGIN_MSINTERNAL
#if 0
//
// IDirectSoundFXI3DL2Source
//

DEFINE_GUID(IID_IDirectSoundFXI3DL2Source, 0x4363ff5c, 0x0410, 0x4507, 0xb3, 0x21, 0xea, 0x09, 0xf8, 0xf4, 0x56, 0x99);

typedef struct _DSFXI3DL2Obstruction
{
    LONG    lHFLevel;   // [-10000, 0] default: 0 mB
    FLOAT   flLFRatio;  // [0.0, 1.0]  default: 0.0
} DSFXI3DL2Obstruction, *LPDSFXI3DL2Obstruction;

typedef const DSFXI3DL2Obstruction *LPCDSFXI3DL2Obstruction;

typedef struct _DSFXI3DL2Occlusion
{
    LONG    lHFLevel;   // [-10000, 0] default: 0 mB
    FLOAT   flLFRatio;  // [0.0, 1.0]  default: 0.25
} DSFXI3DL2Occlusion, *LPDSFXI3DL2Occlusion;

typedef const DSFXI3DL2Occlusion *LPCDSFXI3DL2Occlusion;

typedef struct _DSFXI3DL2Source
{
    LONG                    lDirect;                // [-10000, 1000] default: 0 mB
    LONG                    lDirectHF;              // [-10000, 0]    default: 0 mB
    LONG                    lRoom;                  // [-10000, 1000] default: 0 mB
    LONG                    lRoomHF;                // [-10000, 0]    default: 0 mB
    FLOAT                   flRoomRolloffFactor;    // [0.0, 10.0]    default: 0.0
    DSFXI3DL2Obstruction  Obstruction;
    DSFXI3DL2Occlusion    Occlusion;
    DWORD                   dwFlags;                // default: DSFX_I3DL2SOURCE_OCC_LPF
} DSFXI3DL2Source, *LPDSFXI3DL2Source;

typedef const DSFXI3DL2Source *LPCDSFXI3DL2Source;

#define DSFX_I3DL2SOURCE_DIRECT_MIN                     (-10000)
#define DSFX_I3DL2SOURCE_DIRECT_MAX                     1000
#define DSFX_I3DL2SOURCE_DIRECT_DEFAULT                 0
                                                        
#define DSFX_I3DL2SOURCE_DIRECTHF_MIN                   (-10000)
#define DSFX_I3DL2SOURCE_DIRECTHF_MAX                   0
#define DSFX_I3DL2SOURCE_DIRECTHF_DEFAULT               0
                                                        
#define DSFX_I3DL2SOURCE_ROOM_MIN                       (-10000)
#define DSFX_I3DL2SOURCE_ROOM_MAX                        1000
#define DSFX_I3DL2SOURCE_ROOM_DEFAULT                   0
                                                        
#define DSFX_I3DL2SOURCE_ROOMHF_MIN                     (-10000)
#define DSFX_I3DL2SOURCE_ROOMHF_MAX                     0
#define DSFX_I3DL2SOURCE_ROOMHF_DEFAULT                 0
                                                        
#define DSFX_I3DL2SOURCE_ROOMROLLOFFFACTOR_MIN          0.0f
#define DSFX_I3DL2SOURCE_ROOMROLLOFFFACTOR_MAX          10.0f
#define DSFX_I3DL2SOURCE_ROOMROLLOFFFACTOR_DEFAULT      0.0f
                                                        
#define DSFX_I3DL2SOURCE_OBSTRUCTION_HFLEVEL_MIN        (-10000)
#define DSFX_I3DL2SOURCE_OBSTRUCTION_HFLEVEL_MAX        0
#define DSFX_I3DL2SOURCE_OBSTRUCTION_HFLEVEL_DEFAULT    0

#define DSFX_I3DL2SOURCE_OBSTRUCTION_LFRATIO_MIN        0.0f
#define DSFX_I3DL2SOURCE_OBSTRUCTION_LFRATIO_MAX        1.0f
#define DSFX_I3DL2SOURCE_OBSTRUCTION_LFRATIO_DEFAULT    0.0f

#define DSFX_I3DL2SOURCE_OCCLUSION_HFLEVEL_MIN          (-10000)
#define DSFX_I3DL2SOURCE_OCCLUSION_HFLEVEL_MAX          0
#define DSFX_I3DL2SOURCE_OCCLUSION_HFLEVEL_DEFAULT      0
                                                        
#define DSFX_I3DL2SOURCE_OCCLUSION_LFRATIO_MIN          0.0f
#define DSFX_I3DL2SOURCE_OCCLUSION_LFRATIO_MAX          1.0f
#define DSFX_I3DL2SOURCE_OCCLUSION_LFRATIO_DEFAULT      0.25f

#undef INTERFACE
#define INTERFACE IDirectSoundFXI3DL2Source

DECLARE_INTERFACE_(IDirectSoundFXI3DL2Source, IUnknown)
{
    // IUnknown methods
    STDMETHOD(QueryInterface)       (THIS_ REFIID, LPVOID *) PURE;
    STDMETHOD_(ULONG,AddRef)        (THIS) PURE;
    STDMETHOD_(ULONG,Release)       (THIS) PURE;

    // IDirectSoundFXI3DL2Source methods
    STDMETHOD(SetAllParameters)     (THIS_ LPCDSFXI3DL2Source pcDsFxI3DL2Source) PURE;
    STDMETHOD(GetAllParameters)     (THIS_ LPDSFXI3DL2Source pDsFxI3DL2Source) PURE;
    STDMETHOD(SetObstructionPreset) (THIS_ DWORD dwPreset) PURE;
    STDMETHOD(GetObstructionPreset) (THIS_ LPDWORD pdwPreset) PURE;
    STDMETHOD(SetOcclusionPreset)   (THIS_ DWORD dwPreset) PURE;
    STDMETHOD(GetOcclusionPreset)   (THIS_ LPDWORD pdwPreset) PURE;
};

#define IDirectSoundFXI3DL2Source_QueryInterface(p,a,b)     IUnknown_QueryInterface(p,a,b)
#define IDirectSoundFXI3DL2Source_AddRef(p)                 IUnknown_AddRef(p)
#define IDirectSoundFXI3DL2Source_Release(p)                IUnknown_Release(p)

#if !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectSoundFXI3DL2Source_SetAllParameters(p,a)     (p)->lpVtbl->SetAllParameters(p,a)
#define IDirectSoundFXI3DL2Source_GetAllParameters(p,a)     (p)->lpVtbl->GetAllParameters(p,a)
#define IDirectSoundFXI3DL2Source_SetObstructionPreset(p,a) (p)->lpVtbl->SetObstructionPreset(p,a)
#define IDirectSoundFXI3DL2Source_GetObstructionPreset(p,a) (p)->lpVtbl->GetObstructionPreset(p,a)
#define IDirectSoundFXI3DL2Source_SetOcclusionPreset(p,a)   (p)->lpVtbl->SetOcclusionPreset(p,a)
#define IDirectSoundFXI3DL2Source_GetOcclusionPreset(p,a)   (p)->lpVtbl->GetOcclusionPreset(p,a)
#else // !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectSoundFXI3DL2Source_SetAllParameters(p,a)     (p)->SetAllParameters(a)
#define IDirectSoundFXI3DL2Source_GetAllParameters(p,a)     (p)->GetAllParameters(a)
#define IDirectSoundFXI3DL2Source_SetObstructionPreset(p,a) (p)->SetObstructionPreset(a)
#define IDirectSoundFXI3DL2Source_GetObstructionPreset(p,a) (p)->GetObstructionPreset(a)
#define IDirectSoundFXI3DL2Source_SetOcclusionPreset(p,a)   (p)->SetOcclusionPreset(a)
#define IDirectSoundFXI3DL2Source_GetOcclusionPreset(p,a)   (p)->GetOcclusionPreset(a)
#endif // !defined(__cplusplus) || defined(CINTERFACE)
#endif // 0
//@@END_MSINTERNAL

//
// IDirectSoundFXI3DL2Reverb
//

DEFINE_GUID(IID_IDirectSoundFXI3DL2Reverb, 0x4b166a6a, 0x0d66, 0x43f3, 0x80, 0xe3, 0xee, 0x62, 0x80, 0xde, 0xe1, 0xa4);

typedef struct _DSFXI3DL2Reverb
{
    LONG    lRoom;                  // [-10000, 0]      default: -1000 mB
    LONG    lRoomHF;                // [-10000, 0]      default: 0 mB
    FLOAT   flRoomRolloffFactor;    // [0.0, 10.0]      default: 0.0
    FLOAT   flDecayTime;            // [0.1, 20.0]      default: 1.49s
    FLOAT   flDecayHFRatio;         // [0.1, 2.0]       default: 0.83
    LONG    lReflections;           // [-10000, 1000]   default: -2602 mB
    FLOAT   flReflectionsDelay;     // [0.0, 0.3]       default: 0.007 s
    LONG    lReverb;                // [-10000, 2000]   default: 200 mB
    FLOAT   flReverbDelay;          // [0.0, 0.1]       default: 0.011 s
    FLOAT   flDiffusion;            // [0.0, 100.0]     default: 100.0 %
    FLOAT   flDensity;              // [0.0, 100.0]     default: 100.0 %
    FLOAT   flHFReference;          // [20.0, 20000.0]  default: 5000.0 Hz
} DSFXI3DL2Reverb, *LPDSFXI3DL2Reverb;

typedef const DSFXI3DL2Reverb *LPCDSFXI3DL2Reverb;

#define DSFX_I3DL2REVERB_ROOM_MIN                   (-10000)
#define DSFX_I3DL2REVERB_ROOM_MAX                   0
#define DSFX_I3DL2REVERB_ROOM_DEFAULT               (-1000)
                                                    
#define DSFX_I3DL2REVERB_ROOMHF_MIN                 (-10000)
#define DSFX_I3DL2REVERB_ROOMHF_MAX                 0
#define DSFX_I3DL2REVERB_ROOMHF_DEFAULT             (-100)
                                                    
#define DSFX_I3DL2REVERB_ROOMROLLOFFFACTOR_MIN      0.0f
#define DSFX_I3DL2REVERB_ROOMROLLOFFFACTOR_MAX      10.0f
#define DSFX_I3DL2REVERB_ROOMROLLOFFFACTOR_DEFAULT  0.0f

#define DSFX_I3DL2REVERB_DECAYTIME_MIN              0.1f
#define DSFX_I3DL2REVERB_DECAYTIME_MAX              20.0f
#define DSFX_I3DL2REVERB_DECAYTIME_DEFAULT          1.49f
                                                    
#define DSFX_I3DL2REVERB_DECAYHFRATIO_MIN           0.1f
#define DSFX_I3DL2REVERB_DECAYHFRATIO_MAX           2.0f
#define DSFX_I3DL2REVERB_DECAYHFRATIO_DEFAULT       0.83f
                                                    
#define DSFX_I3DL2REVERB_REFLECTIONS_MIN            (-10000)
#define DSFX_I3DL2REVERB_REFLECTIONS_MAX            1000
#define DSFX_I3DL2REVERB_REFLECTIONS_DEFAULT        (-2602)
                                                    
#define DSFX_I3DL2REVERB_REFLECTIONSDELAY_MIN       0.0f
#define DSFX_I3DL2REVERB_REFLECTIONSDELAY_MAX       0.3f
#define DSFX_I3DL2REVERB_REFLECTIONSDELAY_DEFAULT   0.007f

#define DSFX_I3DL2REVERB_REVERB_MIN                 (-10000)
#define DSFX_I3DL2REVERB_REVERB_MAX                 2000
#define DSFX_I3DL2REVERB_REVERB_DEFAULT             (200)
                                                    
#define DSFX_I3DL2REVERB_REVERBDELAY_MIN            0.0f
#define DSFX_I3DL2REVERB_REVERBDELAY_MAX            0.1f
#define DSFX_I3DL2REVERB_REVERBDELAY_DEFAULT        0.011f
                                                    
#define DSFX_I3DL2REVERB_DIFFUSION_MIN              0.0f
#define DSFX_I3DL2REVERB_DIFFUSION_MAX              100.0f
#define DSFX_I3DL2REVERB_DIFFUSION_DEFAULT          100.0f
                                                    
#define DSFX_I3DL2REVERB_DENSITY_MIN                0.0f
#define DSFX_I3DL2REVERB_DENSITY_MAX                100.0f
#define DSFX_I3DL2REVERB_DENSITY_DEFAULT            100.0f
                                                    
#define DSFX_I3DL2REVERB_HFREFERENCE_MIN            20.0f
#define DSFX_I3DL2REVERB_HFREFERENCE_MAX            20000.0f
#define DSFX_I3DL2REVERB_HFREFERENCE_DEFAULT        5000.0f
                                                    
#define DSFX_I3DL2REVERB_QUALITY_MIN                0
#define DSFX_I3DL2REVERB_QUALITY_MAX                3
#define DSFX_I3DL2REVERB_QUALITY_DEFAULT            2

#undef INTERFACE
#define INTERFACE IDirectSoundFXI3DL2Reverb

DECLARE_INTERFACE_(IDirectSoundFXI3DL2Reverb, IUnknown)
{
    // IUnknown methods
    STDMETHOD(QueryInterface)       (THIS_ REFIID, LPVOID *) PURE;
    STDMETHOD_(ULONG,AddRef)        (THIS) PURE;
    STDMETHOD_(ULONG,Release)       (THIS) PURE;

    // IDirectSoundFXI3DL2Reverb methods
    STDMETHOD(SetAllParameters)     (THIS_ LPCDSFXI3DL2Reverb pcDsFxI3DL2Reverb) PURE;
    STDMETHOD(GetAllParameters)     (THIS_ LPDSFXI3DL2Reverb pDsFxI3DL2Reverb) PURE;
    STDMETHOD(SetPreset)            (THIS_ DWORD dwPreset) PURE;
    STDMETHOD(GetPreset)            (THIS_ LPDWORD pdwPreset) PURE;
    STDMETHOD(SetQuality)           (THIS_ LONG lQuality) PURE;
    STDMETHOD(GetQuality)           (THIS_ LONG *plQuality) PURE;
};

#define IDirectSoundFXI3DL2Reverb_QueryInterface(p,a,b)     IUnknown_QueryInterface(p,a,b)
#define IDirectSoundFXI3DL2Reverb_AddRef(p)                 IUnknown_AddRef(p)
#define IDirectSoundFXI3DL2Reverb_Release(p)                IUnknown_Release(p)

#if !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectSoundFXI3DL2Reverb_SetAllParameters(p,a)     (p)->lpVtbl->SetAllParameters(p,a)
#define IDirectSoundFXI3DL2Reverb_GetAllParameters(p,a)     (p)->lpVtbl->GetAllParameters(p,a)
#define IDirectSoundFXI3DL2Reverb_SetPreset(p,a)            (p)->lpVtbl->SetPreset(p,a)
#define IDirectSoundFXI3DL2Reverb_GetPreset(p,a)            (p)->lpVtbl->GetPreset(p,a)
#else // !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectSoundFXI3DL2Reverb_SetAllParameters(p,a)     (p)->SetAllParameters(a)
#define IDirectSoundFXI3DL2Reverb_GetAllParameters(p,a)     (p)->GetAllParameters(a)
#define IDirectSoundFXI3DL2Reverb_SetPreset(p,a)            (p)->SetPreset(a)
#define IDirectSoundFXI3DL2Reverb_GetPreset(p,a)            (p)->GetPreset(a)
#endif // !defined(__cplusplus) || defined(CINTERFACE)

//@@BEGIN_MSINTERNAL
//
// IDirectSoundFXI3DL2SourceEnv - A private interface used by the I3DL2 source DMO
// to receive various bits of information about the environment it's operating in.
//

DEFINE_GUID(IID_IDirectSoundFXI3DL2SourceEnv, 0xf6c55470, 0x7706, 0x4ce1, 0xa3, 0x54, 0x74, 0xb2, 0xf0, 0x3, 0x25, 0xe2);

#undef INTERFACE
#define INTERFACE IDirectSoundFXI3DL2SourceEnv

DECLARE_INTERFACE_(IDirectSoundFXI3DL2SourceEnv, IUnknown)
{
	// IUnknown methods
    STDMETHOD(QueryInterface)       (THIS_ REFIID, LPVOID *) PURE;
    STDMETHOD_(ULONG,AddRef)        (THIS) PURE;
    STDMETHOD_(ULONG,Release)       (THIS) PURE;

	// IDirectSoundFXI3DL2SourceEnv methods
    STDMETHOD(SetEnvironmentReverb) (THIS_ LPDIRECTSOUNDFXI3DL2REVERB8) PURE;
    STDMETHOD(SetDS3DBuffer)        (THIS_ LPDIRECTSOUND3DBUFFER) PURE;
    STDMETHOD(SetDS3DListener)      (THIS_ LPDIRECTSOUND3DLISTENER) PURE;
};

#define IDirectSoundFXI3DL2SourceEnv_QueryInterface(p,a,b)      IUnknown_QueryInterface(p,a,b)
#define IDirectSoundFXI3DL2SourceEnv_AddRef(p)                  IUnknown_AddRef(p)
#define IDirectSoundFXI3DL2SourceEnv_Release(p)                 IUnknown_Release(p)

#if !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectSoundFXI3DL2SourceEnv_SetEnvironmentReverb(p,a)  (p)->lpVtbl->SetEnvironmentReverb(p,a)
#define IDirectSoundFXI3DL2SourceEnv_SetDS3DBuffer(p,a)         (p)->lpVtbl->SetDS3DBuffer(p,a)
#define IDirectSoundFXI3DL2SourceEnv_SetDS3DListener(p,a)       (p)->lpVtbl->SetDS3DListener(p,a)
#else // !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectSoundFXI3DL2SourceEnv_SetEnvironmentReverb(p,a)  (p)->SetEnvironmentReverb(a)
#define IDirectSoundFXI3DL2SourceEnv_SetDS3DBuffer(p,a)         (p)->SetDS3DBuffer(a)
#define IDirectSoundFXI3DL2SourceEnv_SetDS3DListener(p,a)       (p)->SetDS3DListener(a)
#endif // !defined(__cplusplus) || defined(CINTERFACE)

//
// IDirectSound3DBufferPrivate - provided by our 3D buffer object so that the
// I3DL2 source DMO can discover the current attenuation of its host buffer.
//

DEFINE_GUID(IID_IDirectSound3DBufferPrivate, 0x7d8ef383, 0xca05, 0x4593, 0x82, 0xa1, 0x44, 0x4e, 0x80, 0x08, 0x71, 0xe1);

#undef INTERFACE
#define INTERFACE IDirectSound3DBufferPrivate

DECLARE_INTERFACE_(IDirectSound3DBufferPrivate, IUnknown)
{
	// IUnknown methods
    STDMETHOD(QueryInterface)       (THIS_ REFIID, LPVOID *) PURE;
    STDMETHOD_(ULONG,AddRef)        (THIS) PURE;
    STDMETHOD_(ULONG,Release)       (THIS) PURE;

	// IDirectSound3DBufferPrivate methods
    STDMETHOD(GetAttenuation)       (THIS_ FLOAT*) PURE;
};

#define IDirectSound3DBufferPrivate_QueryInterface(p,a,b)   IUnknown_QueryInterface(p,a,b)
#define IDirectSound3DBufferPrivate_AddRef(p)               IUnknown_AddRef(p)
#define IDirectSound3DBufferPrivate_Release(p)              IUnknown_Release(p)

#if !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectSound3DBufferPrivate_GetAttenuation(p,a)     (p)->lpVtbl->GetAttenuation(p,a)
#else // !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectSound3DBufferPrivate_GetAttenuation(p,a)     (p)->GetAttenuation(a)
#endif // !defined(__cplusplus) || defined(CINTERFACE)
//@@END_MSINTERNAL

//
// IDirectSoundFXWavesReverb
//

DEFINE_GUID(IID_IDirectSoundFXWavesReverb,0x46858c3a,0x0dc6,0x45e3,0xb7,0x60,0xd4,0xee,0xf1,0x6c,0xb3,0x25);

typedef struct _DSFXWavesReverb
{
    FLOAT   fInGain;                // [-96.0,0.0]            default: 0.0 dB
    FLOAT   fReverbMix;             // [-96.0,0.0]            default: 0.0 db
    FLOAT   fReverbTime;            // [0.001,3000.0]         default: 1000.0 ms
    FLOAT   fHighFreqRTRatio;       // [0.001,0.999]          default: 0.001
} DSFXWavesReverb, *LPDSFXWavesReverb;

typedef const DSFXWavesReverb *LPCDSFXWavesReverb;

#define DSFX_WAVESREVERB_INGAIN_MIN                 -96.0f
#define DSFX_WAVESREVERB_INGAIN_MAX                 0.0f
#define DSFX_WAVESREVERB_INGAIN_DEFAULT             0.0f
#define DSFX_WAVESREVERB_REVERBMIX_MIN              -96.0f
#define DSFX_WAVESREVERB_REVERBMIX_MAX              0.0f
#define DSFX_WAVESREVERB_REVERBMIX_DEFAULT          0.0f
#define DSFX_WAVESREVERB_REVERBTIME_MIN             0.001f
#define DSFX_WAVESREVERB_REVERBTIME_MAX             3000.0f
#define DSFX_WAVESREVERB_REVERBTIME_DEFAULT         1000.0f
#define DSFX_WAVESREVERB_HIGHFREQRTRATIO_MIN        0.001f
#define DSFX_WAVESREVERB_HIGHFREQRTRATIO_MAX        0.999f
#define DSFX_WAVESREVERB_HIGHFREQRTRATIO_DEFAULT    0.001f

#undef INTERFACE
#define INTERFACE IDirectSoundFXWavesReverb

DECLARE_INTERFACE_(IDirectSoundFXWavesReverb, IUnknown)
{
    // IUnknown methods
    STDMETHOD(QueryInterface)       (THIS_ REFIID, LPVOID *) PURE;
    STDMETHOD_(ULONG,AddRef)        (THIS) PURE;
    STDMETHOD_(ULONG,Release)       (THIS) PURE;

    // IDirectSoundFXWavesReverb methods
    STDMETHOD(SetAllParameters)     (THIS_ LPCDSFXWavesReverb pcDsFxWavesReverb) PURE;
    STDMETHOD(GetAllParameters)     (THIS_ LPDSFXWavesReverb pDsFxWavesReverb) PURE;
};

#define IDirectSoundFXWavesReverb_QueryInterface(p,a,b)     IUnknown_QueryInterface(p,a,b)
#define IDirectSoundFXWavesReverb_AddRef(p)                 IUnknown_AddRef(p)
#define IDirectSoundFXWavesReverb_Release(p)                IUnknown_Release(p)

#if !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectSoundFXWavesReverb_SetAllParameters(p,a)     (p)->lpVtbl->SetAllParameters(p,a)
#define IDirectSoundFXWavesReverb_GetAllParameters(p,a)     (p)->lpVtbl->GetAllParameters(p,a)
#else // !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectSoundFXWavesReverb_SetAllParameters(p,a)     (p)->SetAllParameters(a)
#define IDirectSoundFXWavesReverb_GetAllParameters(p,a)     (p)->GetAllParameters(a)
#endif // !defined(__cplusplus) || defined(CINTERFACE)

//
// IDirectSoundCaptureFXAec
//

DEFINE_GUID(IID_IDirectSoundCaptureFXAec, 0x174d3eb9, 0x6696, 0x4fac, 0xa4, 0x6c, 0xa0, 0xac, 0x7b, 0xc9, 0xe2, 0xf);

typedef struct _DSCFXAec
{
    BOOL    fEnable;
    BOOL    fReset;
    BOOL    fNoiseFill;
} DSCFXAec, *LPDSCFXAec;

typedef const DSCFXAec *LPCDSCFXAec;

#undef INTERFACE
#define INTERFACE IDirectSoundCaptureFXAec

DECLARE_INTERFACE_(IDirectSoundCaptureFXAec, IUnknown)
{
    // IUnknown methods
    STDMETHOD(QueryInterface)       (THIS_ REFIID, LPVOID *) PURE;
    STDMETHOD_(ULONG,AddRef)        (THIS) PURE;
    STDMETHOD_(ULONG,Release)       (THIS) PURE;

    // IDirectSoundCaptureFXAec methods
    STDMETHOD(SetAllParameters)     (THIS_ LPCDSCFXAec pDscFxAec) PURE;
    STDMETHOD(GetAllParameters)     (THIS_ LPDSCFXAec pDscFxAec) PURE;
};

#define IDirectSoundCaptureFXAec_QueryInterface(p,a,b)     IUnknown_QueryInterface(p,a,b)
#define IDirectSoundCaptureFXAec_AddRef(p)                 IUnknown_AddRef(p)
#define IDirectSoundCaptureFXAec_Release(p)                IUnknown_Release(p)

#if !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectSoundCaptureFXAec_SetAllParameters(p,a)     (p)->lpVtbl->SetAllParameters(p,a)
#define IDirectSoundCaptureFXAec_GetAllParameters(p,a)     (p)->lpVtbl->GetAllParameters(p,a)
#else // !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectSoundCaptureFXAec_SetAllParameters(p,a)     (p)->SetAllParameters(a)
#define IDirectSoundCaptureFXAec_GetAllParameters(p,a)     (p)->GetAllParameters(a)
#endif // !defined(__cplusplus) || defined(CINTERFACE)


//
// IDirectSoundCaptureFXNoiseSuppress
//

DEFINE_GUID(IID_IDirectSoundCaptureFXNoiseSuppress, 0xed311e41, 0xfbae, 0x4175, 0x96, 0x25, 0xcd, 0x8, 0x54, 0xf6, 0x93, 0xca);

typedef struct _DSCFXNoiseSuppress
{
    BOOL    fEnable;
    BOOL    fReset;
} DSCFXNoiseSuppress, *LPDSCFXNoiseSuppress;

typedef const DSCFXNoiseSuppress *LPCDSCFXNoiseSuppress;

#undef INTERFACE
#define INTERFACE IDirectSoundCaptureFXNoiseSuppress

DECLARE_INTERFACE_(IDirectSoundCaptureFXNoiseSuppress, IUnknown)
{
    // IUnknown methods
    STDMETHOD(QueryInterface)       (THIS_ REFIID, LPVOID *) PURE;
    STDMETHOD_(ULONG,AddRef)        (THIS) PURE;
    STDMETHOD_(ULONG,Release)       (THIS) PURE;

    // IDirectSoundCaptureFXNoiseSuppress methods
    STDMETHOD(SetAllParameters)     (THIS_ LPCDSCFXNoiseSuppress pcDscFxNoiseSuppress) PURE;
    STDMETHOD(GetAllParameters)     (THIS_ LPDSCFXNoiseSuppress pDscFxNoiseSuppress) PURE;
};

#define IDirectSoundCaptureFXNoiseSuppress_QueryInterface(p,a,b)     IUnknown_QueryInterface(p,a,b)
#define IDirectSoundCaptureFXNoiseSuppress_AddRef(p)                 IUnknown_AddRef(p)
#define IDirectSoundCaptureFXNoiseSuppress_Release(p)                IUnknown_Release(p)

#if !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectSoundCaptureFXNoiseSuppress_SetAllParameters(p,a)     (p)->lpVtbl->SetAllParameters(p,a)
#define IDirectSoundCaptureFXNoiseSuppress_GetAllParameters(p,a)     (p)->lpVtbl->GetAllParameters(p,a)
#else // !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectSoundCaptureFXNoiseSuppress_SetAllParameters(p,a)     (p)->SetAllParameters(a)
#define IDirectSoundCaptureFXNoiseSuppress_GetAllParameters(p,a)     (p)->GetAllParameters(a)
#endif // !defined(__cplusplus) || defined(CINTERFACE)

//@@BEGIN_MSINTERNAL

//
// IDirectSoundCaptureFXAgc
//

DEFINE_GUID(IID_IDirectSoundCaptureFXAgc, 0xe54f76b8, 0xe48f, 0x427b, 0xb7, 0xf7, 0xaf, 0xb8, 0xc7, 0x13, 0xa1, 0x25);

typedef struct _DSCFXAgc
{
    BOOL    fEnable;
    BOOL    fReset;
} DSCFXAgc, *LPDSCFXAgc;

typedef const DSCFXAgc *LPCDSCFXAgc;

#undef INTERFACE
#define INTERFACE IDirectSoundCaptureFXAgc

DECLARE_INTERFACE_(IDirectSoundCaptureFXAgc, IUnknown)
{
    // IUnknown methods
    STDMETHOD(QueryInterface)       (THIS_ REFIID, LPVOID *) PURE;
    STDMETHOD_(ULONG,AddRef)        (THIS) PURE;
    STDMETHOD_(ULONG,Release)       (THIS) PURE;

    // IDirectSoundCaptureFXAgc methods
    STDMETHOD(SetAllParameters)     (THIS_ LPCDSCFXAgc pcDscFxAgc) PURE;
    STDMETHOD(GetAllParameters)     (THIS_ LPDSCFXAgc pDscFxAgc) PURE;
};

#define IDirectSoundCaptureFXAgc_QueryInterface(p,a,b)     IUnknown_QueryInterface(p,a,b)
#define IDirectSoundCaptureFXAgc_AddRef(p)                 IUnknown_AddRef(p)
#define IDirectSoundCaptureFXAgc_Release(p)                IUnknown_Release(p)

#if !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectSoundCaptureFXAgc_SetAllParameters(p,a)     (p)->lpVtbl->SetAllParameters(p,a)
#define IDirectSoundCaptureFXAgc_GetAllParameters(p,a)     (p)->lpVtbl->GetAllParameters(p,a)
#else // !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectSoundCaptureFXAgc_SetAllParameters(p,a)     (p)->SetAllParameters(a)
#define IDirectSoundCaptureFXAgc_GetAllParameters(p,a)     (p)->GetAllParameters(a)
#endif // !defined(__cplusplus) || defined(CINTERFACE)

//
// IDirectSoundCaptureFXMicArray
//

DEFINE_GUID(IID_IDirectSoundCaptureFXMicArray, 0x9AAB5F95, 0xCAF6, 0x4e2a, 0x9D, 0x16, 0x24, 0x5E, 0xBF, 0xDC, 0xFB, 0xE9);

typedef struct _DSCFXMicArray
{
    BOOL    fEnable;
    BOOL    fReset;
} DSCFXMicArray, *LPDSCFXMicArray;

typedef const DSCFXMicArray *LPCDSCFXMicArray;

#undef INTERFACE
#define INTERFACE IDirectSoundCaptureFXMicArray

DECLARE_INTERFACE_(IDirectSoundCaptureFXMicArray, IUnknown)
{
    // IUnknown methods
    STDMETHOD(QueryInterface)       (THIS_ REFIID, LPVOID *) PURE;
    STDMETHOD_(ULONG,AddRef)        (THIS) PURE;
    STDMETHOD_(ULONG,Release)       (THIS) PURE;

    // IDirectSoundCaptureFXMicArray methods
    STDMETHOD(SetAllParameters)     (THIS_ LPCDSCFXMicArray pcDscFxMicArray) PURE;
    STDMETHOD(GetAllParameters)     (THIS_ LPDSCFXMicArray pDscFxMicArray) PURE;
};

#define IDirectSoundCaptureFXMicArray_QueryInterface(p,a,b)     IUnknown_QueryInterface(p,a,b)
#define IDirectSoundCaptureFXMicArray_AddRef(p)                 IUnknown_AddRef(p)
#define IDirectSoundCaptureFXMicArray_Release(p)                IUnknown_Release(p)

#if !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectSoundCaptureFXMicArray_SetAllParameters(p,a)     (p)->lpVtbl->SetAllParameters(p,a)
#define IDirectSoundCaptureFXMicArray_GetAllParameters(p,a)     (p)->lpVtbl->GetAllParameters(p,a)
#else // !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectSoundCaptureFXMicArray_SetAllParameters(p,a)     (p)->SetAllParameters(a)
#define IDirectSoundCaptureFXMicArray_GetAllParameters(p,a)     (p)->GetAllParameters(a)
#endif // !defined(__cplusplus) || defined(CINTERFACE)

//
// IDirectSoundDMOProxy
//

DEFINE_GUID(IID_IDirectSoundDMOProxy,0xe782c03b,0x8187,0x4110,0xb6,0x53,0xd1,0x53,0xff,0x8f,0x42,0xc7);

#undef INTERFACE
#define INTERFACE IDirectSoundDMOProxy

DECLARE_INTERFACE_(IDirectSoundDMOProxy, IUnknown)
{
    // IUnknown methods
    STDMETHOD(QueryInterface)       (THIS_ REFIID, LPVOID *) PURE;
    STDMETHOD_(ULONG,AddRef)        (THIS) PURE;
    STDMETHOD_(ULONG,Release)       (THIS) PURE;

    // IDirectSoundDMOProxy methods
    STDMETHOD(AcquireResources)     (THIS_ IKsPropertySet *pKsPropertySet) PURE;
    STDMETHOD(ReleaseResources)     (THIS) PURE;
    STDMETHOD(InitializeNode)       (THIS_ HANDLE hPin, ULONG ulNodeId) PURE;
};

#define IDirectSoundDMOProxy_QueryInterface(p,a,b)     IUnknown_QueryInterface(p,a,b)
#define IDirectSoundDMOProxy_AddRef(p)                 IUnknown_AddRef(p)
#define IDirectSoundDMOProxy_Release(p)                IUnknown_Release(p)

#if !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectSoundDMOProxy_AcquireResources(p,a)     (p)->lpVtbl->AcquireResources(p,a)
#define IDirectSoundDMOProxy_ReleaseResources(p)       (p)->lpVtbl->ReleaseResources(p)
#define IDirectSoundDMOProxy_InitializeNode(p,a,b)     (p)->lpVtbl->InitializeNode(p,a,b)
#else // !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectSoundDMOProxy_AcquireResources(p,a)     (p)->AcquireResources(a)
#define IDirectSoundDMOProxy_ReleaseResources(p)       (p)->ReleaseResources()
#define IDirectSoundDMOProxy_InitializeNode(p,a,b)     (p)->InitializeNode(a,b)
#endif // !defined(__cplusplus) || defined(CINTERFACE)

//@@END_MSINTERNAL

//
// IDirectSoundFullDuplex
//

#ifndef _IDirectSoundFullDuplex_
#define _IDirectSoundFullDuplex_

#ifdef __cplusplus
// 'struct' not 'class' per the way DECLARE_INTERFACE_ is defined
struct IDirectSoundFullDuplex;
#endif // __cplusplus

typedef struct IDirectSoundFullDuplex *LPDIRECTSOUNDFULLDUPLEX;

DEFINE_GUID(IID_IDirectSoundFullDuplex, 0xedcb4c7a, 0xdaab, 0x4216, 0xa4, 0x2e, 0x6c, 0x50, 0x59, 0x6d, 0xdc, 0x1d);

#undef INTERFACE
#define INTERFACE IDirectSoundFullDuplex

DECLARE_INTERFACE_(IDirectSoundFullDuplex, IUnknown)
{
    // IUnknown methods
    STDMETHOD(QueryInterface)   (THIS_ REFIID, LPVOID *) PURE;
    STDMETHOD_(ULONG,AddRef)    (THIS) PURE;
    STDMETHOD_(ULONG,Release)   (THIS) PURE;

    // IDirectSoundFullDuplex methods 
    STDMETHOD(Initialize)     (THIS_ LPCGUID pCaptureGuid, LPCGUID pRenderGuid, LPCDSCBUFFERDESC lpDscBufferDesc, LPCDSBUFFERDESC lpDsBufferDesc, HWND hWnd, DWORD dwLevel, LPLPDIRECTSOUNDCAPTUREBUFFER8 lplpDirectSoundCaptureBuffer8, LPLPDIRECTSOUNDBUFFER8 lplpDirectSoundBuffer8) PURE;
};

#define IDirectSoundFullDuplex_QueryInterface(p,a,b)    IUnknown_QueryInterface(p,a,b)
#define IDirectSoundFullDuplex_AddRef(p)                IUnknown_AddRef(p)
#define IDirectSoundFullDuplex_Release(p)               IUnknown_Release(p)

#if !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectSoundFullDuplex_Initialize(p,a,b,c,d,e,f,g,h)     (p)->lpVtbl->Initialize(p,a,b,c,d,e,f,g,h)
#else // !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectSoundFullDuplex_Initialize(p,a,b,c,d,e,f,g,h)     (p)->Initialize(a,b,c,d,e,f,g,h)
#endif // !defined(__cplusplus) || defined(CINTERFACE)

#endif // _IDirectSoundFullDuplex_

#endif // DIRECTSOUND_VERSION >= 0x0800

//
// Return Codes
//

// The function completed successfully
#define DS_OK                           S_OK
//@@BEGIN_MSINTERNAL
#define DS_OK_EXPLANATION TEXT("The function completed successfully")
//@@END_MSINTERNAL

// The call succeeded, but we had to substitute the 3D algorithm
#define DS_NO_VIRTUALIZATION            MAKE_HRESULT(0, _FACDS, 10)
//@@BEGIN_MSINTERNAL
#define DS_NO_VIRTUALIZATION_EXPLANATION TEXT("The function succeeded, substituting the Pan3D algorithm")
//@@END_MSINTERNAL

// The call succeeded, but not all of the optional effects were obtained.
#define DS_INCOMPLETE                   MAKE_HRESULT(0, _FACDS, 20)
//@@BEGIN_MSINTERNAL
#define DS_INCOMPLETE_EXPLANATION TEXT("The function succeeded, but not all of the optional effects requested could be obtained")
//@@END_MSINTERNAL

// The call failed because resources (such as a priority level)
// were already being used by another caller
#define DSERR_ALLOCATED                 MAKE_DSHRESULT(10)
//@@BEGIN_MSINTERNAL
#define DSERR_ALLOCATED_EXPLANATION TEXT("The call failed because resources (such as a priority level) were already being used by another caller")
//@@END_MSINTERNAL
//@@BEGIN_MSINTERNAL
// An attempt was made to lock the area between the play and write cursors
#define DSERR_CANTLOCKPLAYCURSOR        MAKE_DSHRESULT(20)
//@@END_MSINTERNAL
//@@BEGIN_MSINTERNAL
#define DSERR_CANTLOCKPLAYCURSOR_EXPLANATION TEXT("An attempt was made to lock the area between the play and write cursors")
//@@END_MSINTERNAL

// The control (vol, pan, etc.) requested by the caller is not available
#define DSERR_CONTROLUNAVAIL            MAKE_DSHRESULT(30)
//@@BEGIN_MSINTERNAL
#define DSERR_CONTROLUNAVAIL_EXPLANATION TEXT("The control (vol, pan, etc.) requested by the caller is not available")
//@@END_MSINTERNAL

// An invalid parameter was passed to the returning function
#define DSERR_INVALIDPARAM              E_INVALIDARG
//@@BEGIN_MSINTERNAL
#define DSERR_INVALIDPARAM_EXPLANATION TEXT("An invalid parameter was passed to the returning function")
//@@END_MSINTERNAL

// This call is not valid for the current state of this object
#define DSERR_INVALIDCALL               MAKE_DSHRESULT(50)
//@@BEGIN_MSINTERNAL
#define DSERR_INVALIDCALL_EXPLANATION TEXT("This call is not valid for the current state of this object")
//@@END_MSINTERNAL

// An undetermined error occurred inside the DirectSound subsystem
#define DSERR_GENERIC                   E_FAIL
//@@BEGIN_MSINTERNAL
#define DSERR_GENERIC_EXPLANATION TEXT("An undetermined error occurred inside the DirectSound subsystem")
//@@END_MSINTERNAL

// The caller does not have the priority level required for the function to
// succeed
#define DSERR_PRIOLEVELNEEDED           MAKE_DSHRESULT(70)
//@@BEGIN_MSINTERNAL
#define DSERR_PRIOLEVELNEEDED_EXPLANATION TEXT("The caller does not have the priority level required for the function to succeed")
//@@END_MSINTERNAL

// Not enough free memory is available to complete the operation
#define DSERR_OUTOFMEMORY               E_OUTOFMEMORY
//@@BEGIN_MSINTERNAL
#define DSERR_OUTOFMEMORY_EXPLANATION TEXT("Not enough free memory is available to complete the operation")
//@@END_MSINTERNAL

// The specified WAVE format is not supported
#define DSERR_BADFORMAT                 MAKE_DSHRESULT(100)
//@@BEGIN_MSINTERNAL
#define DSERR_BADFORMAT_EXPLANATION TEXT("The specified WAVE format is not supported")
//@@END_MSINTERNAL

// The function called is not supported at this time
#define DSERR_UNSUPPORTED               E_NOTIMPL
//@@BEGIN_MSINTERNAL
#define DSERR_UNSUPPORTED_EXPLANATION TEXT("The function called is not supported at this time")
//@@END_MSINTERNAL

// No sound driver is available for use
#define DSERR_NODRIVER                  MAKE_DSHRESULT(120)
//@@BEGIN_MSINTERNAL
#define DSERR_NODRIVER_EXPLANATION TEXT("No sound device is available for use, or the given device ID isn't valid")
//@@END_MSINTERNAL

// This object is already initialized
#define DSERR_ALREADYINITIALIZED        MAKE_DSHRESULT(130)
//@@BEGIN_MSINTERNAL
#define DSERR_ALREADYINITIALIZED_EXPLANATION TEXT("This object is already initialized")
//@@END_MSINTERNAL

// This object does not support aggregation
#define DSERR_NOAGGREGATION             CLASS_E_NOAGGREGATION
//@@BEGIN_MSINTERNAL
#define DSERR_NOAGGREGATION_EXPLANATION TEXT("This object does not support aggregation")
//@@END_MSINTERNAL

// The buffer memory has been lost, and must be restored
#define DSERR_BUFFERLOST                MAKE_DSHRESULT(150)
//@@BEGIN_MSINTERNAL
#define DSERR_BUFFERLOST_EXPLANATION TEXT("The buffer memory has been lost, and must be restored")
//@@END_MSINTERNAL

// Another app has a higher priority level, preventing this call from
// succeeding
#define DSERR_OTHERAPPHASPRIO           MAKE_DSHRESULT(160)
//@@BEGIN_MSINTERNAL
#define DSERR_OTHERAPPHASPRIO_EXPLANATION TEXT("Another app has a higher priority level, preventing this call from succeeding")
//@@END_MSINTERNAL

// This object has not been initialized
#define DSERR_UNINITIALIZED             MAKE_DSHRESULT(170)
//@@BEGIN_MSINTERNAL
#define DSERR_UNINITIALIZED_EXPLANATION TEXT("This object has not been initialized")
//@@END_MSINTERNAL

// The requested COM interface is not available
#define DSERR_NOINTERFACE               E_NOINTERFACE
//@@BEGIN_MSINTERNAL
#define DSERR_NOINTERFACE_EXPLANATION TEXT("The requested COM interface is not available")
//@@END_MSINTERNAL

// Access is denied
#define DSERR_ACCESSDENIED              E_ACCESSDENIED
//@@BEGIN_MSINTERNAL
#define DSERR_ACCESSDENIED_EXPLANATION TEXT("Access is denied")
//@@END_MSINTERNAL

// Tried to create a DSBCAPS_CTRLFX buffer shorter than DSBSIZE_FX_MIN milliseconds
#define DSERR_BUFFERTOOSMALL            MAKE_DSHRESULT(180)
//@@BEGIN_MSINTERNAL
#define DSERR_BUFFERTOOSMALL_EXPLANATION TEXT("Tried to create a CTRLFX buffer shorter than DSBSIZE_FX_MIN milliseconds")
//@@END_MSINTERNAL

// Attempt to use DirectSound 8 functionality on an older DirectSound object
#define DSERR_DS8_REQUIRED              MAKE_DSHRESULT(190)
//@@BEGIN_MSINTERNAL
#define DSERR_DS8_REQUIRED_EXPLANATION TEXT("Attempt to use DirectSound 8 functionality on an older DirectSound object")
//@@END_MSINTERNAL

// A circular loop of send effects was detected
#define DSERR_SENDLOOP                  MAKE_DSHRESULT(200)
//@@BEGIN_MSINTERNAL
#define DSERR_SENDLOOP_EXPLANATION TEXT("A circular loop of send effects was detected")
//@@END_MSINTERNAL

// The GUID specified in an audiopath file does not match a valid MIXIN buffer
#define DSERR_BADSENDBUFFERGUID         MAKE_DSHRESULT(210)
//@@BEGIN_MSINTERNAL
#define DSERR_BADSENDBUFFERGUID_EXPLANATION TEXT("The GUID specified does not match a valid MIXIN buffer")
//@@END_MSINTERNAL

// The object requested was not found (numerically equal to DMUS_E_NOT_FOUND)
#define DSERR_OBJECTNOTFOUND            MAKE_DSHRESULT(4449)
//@@BEGIN_MSINTERNAL
// Can't just be #defined to DMUS_E_NOTFOUND because we don't include the header
#define DSERR_OBJECTNOTFOUND_EXPLANATION TEXT("The object was not found")
//@@END_MSINTERNAL

// The effects requested could not be found on the system, or they were found
// but in the wrong order, or in the wrong hardware/software locations.
#define DSERR_FXUNAVAILABLE             MAKE_DSHRESULT(220)
//@@BEGIN_MSINTERNAL
#define DSERR_FXUNAVAILABLE_EXPLANATION TEXT("The effects could not be found in the order and location requested")
//@@END_MSINTERNAL

//
// Flags
//

#define DSCAPS_PRIMARYMONO          0x00000001
#define DSCAPS_PRIMARYSTEREO        0x00000002
#define DSCAPS_PRIMARY8BIT          0x00000004
#define DSCAPS_PRIMARY16BIT         0x00000008
#define DSCAPS_CONTINUOUSRATE       0x00000010
#define DSCAPS_EMULDRIVER           0x00000020
#define DSCAPS_CERTIFIED            0x00000040
#define DSCAPS_SECONDARYMONO        0x00000100
#define DSCAPS_SECONDARYSTEREO      0x00000200
#define DSCAPS_SECONDARY8BIT        0x00000400
#define DSCAPS_SECONDARY16BIT       0x00000800
//@@BEGIN_MSINTERNAL
#define DSCAPS_PRIMARYFLAGS         (DSCAPS_PRIMARYMONO | DSCAPS_PRIMARYSTEREO | DSCAPS_PRIMARY8BIT | DSCAPS_PRIMARY16BIT)
#define DSCAPS_SECONDARYFLAGS       (DSCAPS_SECONDARYMONO | DSCAPS_SECONDARYSTEREO | DSCAPS_SECONDARY8BIT | DSCAPS_SECONDARY16BIT)
#define DSCAPS_VALIDDRIVERFLAGS     (DSCAPS_PRIMARYFLAGS | DSCAPS_SECONDARYFLAGS | DSCAPS_CONTINUOUSRATE)
#define DSCAPS_VALIDFLAGS           (DSCAPS_VALIDDRIVERFLAGS | DSCAPS_EMULDRIVER | DSCAPS_CERTIFIED)
#define DSCAPS_FILENAMECOOKIE       179  // Must be less than 256.
#define DSCAPS_FILENAMEMODVALUE     247  // Must be less that 256.
//@@END_MSINTERNAL

#define DSSCL_NORMAL                0x00000001
#define DSSCL_PRIORITY              0x00000002
#define DSSCL_EXCLUSIVE             0x00000003
#define DSSCL_WRITEPRIMARY          0x00000004
//@@BEGIN_MSINTERNAL
#define DSSCL_NONE                  0x00000000
#define DSSCL_FIRST                 DSSCL_NORMAL
#define DSSCL_LAST                  DSSCL_WRITEPRIMARY
//@@END_MSINTERNAL

#define DSSPEAKER_DIRECTOUT         0x00000000
#define DSSPEAKER_HEADPHONE         0x00000001
#define DSSPEAKER_MONO              0x00000002
#define DSSPEAKER_QUAD              0x00000003
#define DSSPEAKER_STEREO            0x00000004
#define DSSPEAKER_SURROUND          0x00000005
#define DSSPEAKER_5POINT1           0x00000006
#define DSSPEAKER_7POINT1           0x00000007
//@@BEGIN_MSINTERNAL
#define DSSPEAKER_FIRST             DSSPEAKER_DIRECTOUT
#define DSSPEAKER_LAST              DSSPEAKER_7POINT1
#define DSSPEAKER_DEFAULT           DSSPEAKER_STEREO
//@@END_MSINTERNAL

#define DSSPEAKER_GEOMETRY_MIN      0x00000005  //   5 degrees
#define DSSPEAKER_GEOMETRY_NARROW   0x0000000A  //  10 degrees
#define DSSPEAKER_GEOMETRY_WIDE     0x00000014  //  20 degrees
#define DSSPEAKER_GEOMETRY_MAX      0x000000B4  // 180 degrees

#define DSSPEAKER_COMBINED(c, g)    ((DWORD)(((BYTE)(c)) | ((DWORD)((BYTE)(g))) << 16))
#define DSSPEAKER_CONFIG(a)         ((BYTE)(a))
#define DSSPEAKER_GEOMETRY(a)       ((BYTE)(((DWORD)(a) >> 16) & 0x00FF))
//@@BEGIN_MSINTERNAL
#define DSSPEAKER_CONFIG_MASK       0x000000FF
#define DSSPEAKER_GEOMETRY_MASK     0x00FF0000
//@@END_MSINTERNAL

//@@BEGIN_MSINTERNAL
#ifdef FUTURE_MULTIPAN_SUPPORT
#ifndef _SPEAKER_POSITIONS_

// Speaker positions for SetChannelVolume()
#define _SPEAKER_POSITIONS_
#define SPEAKER_FRONT_LEFT              0x1
#define SPEAKER_FRONT_RIGHT             0x2
#define SPEAKER_FRONT_CENTER            0x4
#define SPEAKER_LOW_FREQUENCY           0x8
#define SPEAKER_BACK_LEFT               0x10
#define SPEAKER_BACK_RIGHT              0x20
#define SPEAKER_FRONT_LEFT_OF_CENTER    0x40
#define SPEAKER_FRONT_RIGHT_OF_CENTER   0x80
#define SPEAKER_BACK_CENTER             0x100
#define SPEAKER_SIDE_LEFT               0x200
#define SPEAKER_SIDE_RIGHT              0x400
#define SPEAKER_TOP_CENTER              0x800
#define SPEAKER_TOP_FRONT_LEFT          0x1000
#define SPEAKER_TOP_FRONT_CENTER        0x2000
#define SPEAKER_TOP_FRONT_RIGHT         0x4000
#define SPEAKER_TOP_BACK_LEFT           0x8000
#define SPEAKER_TOP_BACK_CENTER         0x10000
#define SPEAKER_TOP_BACK_RIGHT          0x20000

// Bit mask locations reserved for future use
#define SPEAKER_RESERVED                0x7FFC0000

// Not used in the DirectSound API
#define SPEAKER_ALL                     0x80000000

#endif // _SPEAKER_POSITIONS_
#endif // FUTURE_MULTIPAN_SUPPORT
//@@END_MSINTERNAL

#define DSBCAPS_PRIMARYBUFFER       0x00000001
#define DSBCAPS_STATIC              0x00000002
#define DSBCAPS_LOCHARDWARE         0x00000004
#define DSBCAPS_LOCSOFTWARE         0x00000008
#define DSBCAPS_CTRL3D              0x00000010
#define DSBCAPS_CTRLFREQUENCY       0x00000020
#define DSBCAPS_CTRLPAN             0x00000040
#define DSBCAPS_CTRLVOLUME          0x00000080
#define DSBCAPS_CTRLPOSITIONNOTIFY  0x00000100
#define DSBCAPS_CTRLFX              0x00000200
//@@BEGIN_MSINTERNAL
#ifdef FUTURE_MULTIPAN_SUPPORT
#define DSBCAPS_CTRLCHANNELVOLUME   0x00000400
#endif
#define DSBCAPS_MIXIN               0x00002000
//@@END_MSINTERNAL
#define DSBCAPS_STICKYFOCUS         0x00004000
#define DSBCAPS_GLOBALFOCUS         0x00008000
#define DSBCAPS_GETCURRENTPOSITION2 0x00010000
#define DSBCAPS_MUTE3DATMAXDISTANCE 0x00020000
#define DSBCAPS_LOCDEFER            0x00040000
//@@BEGIN_MSINTERNAL
#define DSBCAPS_SINKIN              0x00001000  // Means buffer will receive data from a DirectSound sink
#ifdef FUTURE_WAVE_SUPPORT
#define DSBCAPS_FROMWAVEOBJECT      0x00080000  // Means buffer was created with CreateSoundBufferFromWave()
#endif
#define DSBCAPS_DSBUFFERDESC1MASK   0x0003C1FF  // Flags valid for pre-DX7 applications
#define DSBCAPS_DSBUFFERDESC7MASK   (DSBCAPS_DSBUFFERDESC1MASK | DSBCAPS_LOCDEFER)  // Flags valid for DX7 apps
#define DSBCAPS_VALIDFLAGS          (DSBCAPS_DSBUFFERDESC7MASK | DSBCAPS_CTRLFX | DSBCAPS_MIXIN)  //...DX8 apps
#define DSBCAPS_CTRLATTENUATION     (DSBCAPS_CTRLVOLUME | DSBCAPS_CTRLPAN)
#define DSBCAPS_CTRLNOVIRT          (DSBCAPS_CTRLVOLUME | DSBCAPS_CTRLPAN | DSBCAPS_CTRLFREQUENCY)
#define DSBCAPS_LOCMASK             (DSBCAPS_LOCHARDWARE | DSBCAPS_LOCSOFTWARE)  // All valid location flags
#define DSBCAPS_FOCUSMASK           (DSBCAPS_STICKYFOCUS | DSBCAPS_GLOBALFOCUS)  // All valid focus flags
#define DSBCAPS_DRIVERFLAGSMASK     (DSBCAPS_PRIMARYBUFFER | DSBCAPS_CTRLPOSITIONNOTIFY | DSBCAPS_CTRLATTENUATION | \
                                     DSBCAPS_CTRL3D | DSBCAPS_CTRLFREQUENCY)  // Flags of interest to a VxD driver
#define DSBCAPS_STREAMINGVALIDFLAGS (DSBCAPS_LOCMASK | DSBCAPS_FOCUSMASK | DSBCAPS_MIXIN | \
                                     DSBCAPS_CTRLPAN | DSBCAPS_CTRLVOLUME | DSBCAPS_CTRLFX | \
                                     DSBCAPS_CTRL3D | DSBCAPS_MUTE3DATMAXDISTANCE )
#define DSBCAPS_CHANVOLVALIDFLAGS   (DSBCAPS_VALIDFLAGS & ~(DSBCAPS_PRIMARYBUFFER | DSBCAPS_CTRLPAN | \
                                                            DSBCAPS_CTRL3D | DSBCAPS_MUTE3DATMAXDISTANCE))
#define DSBCAPS_FROMWAVEVALIDFLAGS  (DSBCAPS_LOCMASK | DSBCAPS_LOCDEFER | DSBCAPS_FOCUSMASK | DSBCAPS_CTRLPAN | \
                                     DSBCAPS_CTRLVOLUME | DSBCAPS_CTRLFX | DSBCAPS_CTRLFREQUENCY)
//@@END_MSINTERNAL

#define DSBPLAY_LOOPING             0x00000001
#define DSBPLAY_LOCHARDWARE         0x00000002
#define DSBPLAY_LOCSOFTWARE         0x00000004
#define DSBPLAY_TERMINATEBY_TIME    0x00000008
#define DSBPLAY_TERMINATEBY_DISTANCE    0x000000010
#define DSBPLAY_TERMINATEBY_PRIORITY    0x000000020
//@@BEGIN_MSINTERNAL
#define DSBPLAY_LOCMASK             (DSBPLAY_LOCHARDWARE | DSBPLAY_LOCSOFTWARE)  // All valid location flags
#define DSBPLAY_TERMINATEBY_MASK    (DSBPLAY_TERMINATEBY_TIME | DSBPLAY_TERMINATEBY_DISTANCE | DSBPLAY_TERMINATEBY_PRIORITY)
#define DSBPLAY_LOCDEFERMASK        (DSBPLAY_LOCMASK | DSBPLAY_TERMINATEBY_MASK)
#define DSBPLAY_VALIDFLAGS          (DSBPLAY_LOCDEFERMASK | DSBPLAY_LOOPING)
//@@END_MSINTERNAL

#define DSBSTATUS_PLAYING           0x00000001
#define DSBSTATUS_BUFFERLOST        0x00000002
#define DSBSTATUS_LOOPING           0x00000004
#define DSBSTATUS_LOCHARDWARE       0x00000008
#define DSBSTATUS_LOCSOFTWARE       0x00000010
#define DSBSTATUS_TERMINATED        0x00000020
//@@BEGIN_MSINTERNAL
#define DSBSTATUS_ACTIVE            0x00000040
#define DSBSTATUS_RESOURCESACQUIRED 0x00000080
#define DSBSTATUS_STOPPEDBYFOCUS    0x00000100
#define DSBSTATUS_LOCMASK           (DSBSTATUS_LOCHARDWARE | DSBSTATUS_LOCSOFTWARE)
#define DSBSTATUS_LOCDEFERMASK      (DSBSTATUS_LOCMASK | DSBSTATUS_TERMINATED)
#define DSBSTATUS_USERMASK          (DSBSTATUS_LOCDEFERMASK | DSBSTATUS_PLAYING | DSBSTATUS_BUFFERLOST | DSBSTATUS_LOOPING)
//@@END_MSINTERNAL

#define DSBLOCK_FROMWRITECURSOR     0x00000001
#define DSBLOCK_ENTIREBUFFER        0x00000002
//@@BEGIN_MSINTERNAL
#define DSBLOCK_VALIDFLAGS          (DSBLOCK_FROMWRITECURSOR | DSBLOCK_ENTIREBUFFER)
//@@END_MSINTERNAL

#define DSBFREQUENCY_MIN            100
#define DSBFREQUENCY_MAX            100000
#define DSBFREQUENCY_ORIGINAL       0

#define DSBPAN_LEFT                 -10000
#define DSBPAN_CENTER               0
#define DSBPAN_RIGHT                10000

#define DSBVOLUME_MIN               -10000
#define DSBVOLUME_MAX               0

#define DSBSIZE_MIN                 4
#define DSBSIZE_MAX                 0x0FFFFFFF
#define DSBSIZE_FX_MIN              150  // NOTE: Milliseconds, not bytes

#define DS3DMODE_NORMAL             0x00000000
#define DS3DMODE_HEADRELATIVE       0x00000001
#define DS3DMODE_DISABLE            0x00000002
//@@BEGIN_MSINTERNAL
#define DS3DMODE_FIRST              DS3DMODE_NORMAL
#define DS3DMODE_LAST               DS3DMODE_DISABLE
//@@END_MSINTERNAL

#define DS3D_IMMEDIATE              0x00000000
#define DS3D_DEFERRED               0x00000001
//@@BEGIN_MSINTERNAL
#define DS3D_VALIDFLAGS             0x00000001
//@@END_MSINTERNAL

#define DS3D_MINDISTANCEFACTOR      FLT_MIN
#define DS3D_MAXDISTANCEFACTOR      FLT_MAX
#define DS3D_DEFAULTDISTANCEFACTOR  1.0f

#define DS3D_MINROLLOFFFACTOR       0.0f
#define DS3D_MAXROLLOFFFACTOR       10.0f
#define DS3D_DEFAULTROLLOFFFACTOR   1.0f

#define DS3D_MINDOPPLERFACTOR       0.0f
#define DS3D_MAXDOPPLERFACTOR       10.0f
#define DS3D_DEFAULTDOPPLERFACTOR   1.0f

#define DS3D_DEFAULTMINDISTANCE     1.0f
#define DS3D_DEFAULTMAXDISTANCE     1000000000.0f

#define DS3D_MINCONEANGLE           0
#define DS3D_MAXCONEANGLE           360
#define DS3D_DEFAULTCONEANGLE       360

#define DS3D_DEFAULTCONEOUTSIDEVOLUME DSBVOLUME_MAX

// IDirectSoundCapture attributes

#define DSCCAPS_EMULDRIVER          DSCAPS_EMULDRIVER
#define DSCCAPS_CERTIFIED           DSCAPS_CERTIFIED
//@@BEGIN_MSINTERNAL
#if DIRECTSOUND_VERSION >= 0x0701
#define DSCCAPS_MULTIPLECAPTURE     0x00000001
#endif
//@@END_MSINTERNAL

// IDirectSoundCaptureBuffer attributes

#define DSCBCAPS_WAVEMAPPED         0x80000000

#if DIRECTSOUND_VERSION >= 0x0800
#define DSCBCAPS_CTRLFX             0x00000200
#endif

//@@BEGIN_MSINTERNAL
#define DSCBCAPS_LOCHARDWARE        0x00000004
#define DSCBCAPS_LOCSOFTWARE        0x00000008

#if DIRECTSOUND_VERSION >= 0x0701
#define DSCBCAPS_CTRLVOLUME         0x10000000
#define DSCBCAPS_FOCUSAWARE         0x20000000
#define DSCBCAPS_STRICTFOCUS        0x40000000
#endif

#define DSCBCAPS_VALIDFLAGS         (DSCBCAPS_WAVEMAPPED | DSCBCAPS_STRICTFOCUS | DSCBCAPS_FOCUSAWARE | DSCBCAPS_CTRLVOLUME | DSCBCAPS_CTRLFX)
//@@END_MSINTERNAL

#define DSCBLOCK_ENTIREBUFFER       0x00000001
//@@BEGIN_MSINTERNAL
#define DSCBLOCK_VALIDFLAGS         0x00000001
//@@END_MSINTERNAL

#define DSCBSTATUS_CAPTURING        0x00000001
#define DSCBSTATUS_LOOPING          0x00000002
//@@BEGIN_MSINTERNAL
#if DIRECTSOUND_VERSION >= 0x0701
#define DSCBSTATUS_INFOCUS          0x00000004
#define DSCBSTATUS_LOSTFOCUS        0x00000008
#endif
#define DSCBSTATUS_STOPPING         0x80000000
#define DSCBSTATUS_STOPPED          0x40000000

#define DSCBSTATUS_USERMASK         0x0000FFFF
//@@END_MSINTERNAL

#define DSCBSTART_LOOPING           0x00000001
//@@BEGIN_MSINTERNAL
#define DSCBSTART_VALIDFLAGS        DSCBSTART_LOOPING
//@@END_MSINTERNAL

#define DSBPN_OFFSETSTOP            0xFFFFFFFF

#define DS_CERTIFIED                0x00000000
#define DS_UNCERTIFIED              0x00000001

// Dsound SYSTEM resource constants
// Matches the KSAUDIO_CPU_RESOURCES_xxx_HOST_CPU values defined 
// in ksmedia.h.
#define DS_SYSTEM_RESOURCES_NO_HOST_RESOURCES  0x00000000
#define DS_SYSTEM_RESOURCES_ALL_HOST_RESOURCES 0x7FFFFFFF
#define DS_SYSTEM_RESOURCES_UNDEFINED          0x80000000

//@@BEGIN_MSINTERNAL
#if 0
//
// Flags for the I3DL2 reverberation effect
//

enum
{
    DSFX_I3DL2SOURCE_OCC_LPF,
    DSFX_I3DL2SOURCE_OCC_VOLUME
};
#endif
//@@END_MSINTERNAL

//
// I3DL2 Material Presets
//

enum
{
    DSFX_I3DL2_MATERIAL_PRESET_SINGLEWINDOW,
    DSFX_I3DL2_MATERIAL_PRESET_DOUBLEWINDOW,
    DSFX_I3DL2_MATERIAL_PRESET_THINDOOR,
    DSFX_I3DL2_MATERIAL_PRESET_THICKDOOR,
    DSFX_I3DL2_MATERIAL_PRESET_WOODWALL,
    DSFX_I3DL2_MATERIAL_PRESET_BRICKWALL,
    DSFX_I3DL2_MATERIAL_PRESET_STONEWALL,
    DSFX_I3DL2_MATERIAL_PRESET_CURTAIN
//@@BEGIN_MSINTERNAL
    ,DSFX_I3DL2_MATERIAL_PRESET_MAX
//@@END_MSINTERNAL
};

#define I3DL2_MATERIAL_PRESET_SINGLEWINDOW    -2800,0.71f
#define I3DL2_MATERIAL_PRESET_DOUBLEWINDOW    -5000,0.40f
#define I3DL2_MATERIAL_PRESET_THINDOOR        -1800,0.66f
#define I3DL2_MATERIAL_PRESET_THICKDOOR       -4400,0.64f
#define I3DL2_MATERIAL_PRESET_WOODWALL        -4000,0.50f
#define I3DL2_MATERIAL_PRESET_BRICKWALL       -5000,0.60f
#define I3DL2_MATERIAL_PRESET_STONEWALL       -6000,0.68f
#define I3DL2_MATERIAL_PRESET_CURTAIN         -1200,0.15f


enum
{
    DSFX_I3DL2_ENVIRONMENT_PRESET_DEFAULT,
    DSFX_I3DL2_ENVIRONMENT_PRESET_GENERIC,
    DSFX_I3DL2_ENVIRONMENT_PRESET_PADDEDCELL,
    DSFX_I3DL2_ENVIRONMENT_PRESET_ROOM,
    DSFX_I3DL2_ENVIRONMENT_PRESET_BATHROOM,
    DSFX_I3DL2_ENVIRONMENT_PRESET_LIVINGROOM,
    DSFX_I3DL2_ENVIRONMENT_PRESET_STONEROOM,
    DSFX_I3DL2_ENVIRONMENT_PRESET_AUDITORIUM,
    DSFX_I3DL2_ENVIRONMENT_PRESET_CONCERTHALL,
    DSFX_I3DL2_ENVIRONMENT_PRESET_CAVE,
    DSFX_I3DL2_ENVIRONMENT_PRESET_ARENA,
    DSFX_I3DL2_ENVIRONMENT_PRESET_HANGAR,
    DSFX_I3DL2_ENVIRONMENT_PRESET_CARPETEDHALLWAY,
    DSFX_I3DL2_ENVIRONMENT_PRESET_HALLWAY,
    DSFX_I3DL2_ENVIRONMENT_PRESET_STONECORRIDOR,
    DSFX_I3DL2_ENVIRONMENT_PRESET_ALLEY,
    DSFX_I3DL2_ENVIRONMENT_PRESET_FOREST,
    DSFX_I3DL2_ENVIRONMENT_PRESET_CITY,
    DSFX_I3DL2_ENVIRONMENT_PRESET_MOUNTAINS,
    DSFX_I3DL2_ENVIRONMENT_PRESET_QUARRY,
    DSFX_I3DL2_ENVIRONMENT_PRESET_PLAIN,
    DSFX_I3DL2_ENVIRONMENT_PRESET_PARKINGLOT,
    DSFX_I3DL2_ENVIRONMENT_PRESET_SEWERPIPE,
    DSFX_I3DL2_ENVIRONMENT_PRESET_UNDERWATER,
    DSFX_I3DL2_ENVIRONMENT_PRESET_SMALLROOM,
    DSFX_I3DL2_ENVIRONMENT_PRESET_MEDIUMROOM,
    DSFX_I3DL2_ENVIRONMENT_PRESET_LARGEROOM,
    DSFX_I3DL2_ENVIRONMENT_PRESET_MEDIUMHALL,
    DSFX_I3DL2_ENVIRONMENT_PRESET_LARGEHALL,
    DSFX_I3DL2_ENVIRONMENT_PRESET_PLATE
//@@BEGIN_MSINTERNAL
    ,DSFX_I3DL2_ENVIRONMENT_PRESET_MAX
//@@END_MSINTERNAL
};

//
// I3DL2 Reverberation Presets Values
//

#define I3DL2_ENVIRONMENT_PRESET_DEFAULT         -1000, -100, 0.0f, 1.49f, 0.83f, -2602, 0.007f,   200, 0.011f, 100.0f, 100.0f, 5000.0f
#define I3DL2_ENVIRONMENT_PRESET_GENERIC         -1000, -100, 0.0f, 1.49f, 0.83f, -2602, 0.007f,   200, 0.011f, 100.0f, 100.0f, 5000.0f
#define I3DL2_ENVIRONMENT_PRESET_PADDEDCELL      -1000,-6000, 0.0f, 0.17f, 0.10f, -1204, 0.001f,   207, 0.002f, 100.0f, 100.0f, 5000.0f
#define I3DL2_ENVIRONMENT_PRESET_ROOM            -1000, -454, 0.0f, 0.40f, 0.83f, -1646, 0.002f,    53, 0.003f, 100.0f, 100.0f, 5000.0f
#define I3DL2_ENVIRONMENT_PRESET_BATHROOM        -1000,-1200, 0.0f, 1.49f, 0.54f,  -370, 0.007f,  1030, 0.011f, 100.0f,  60.0f, 5000.0f
#define I3DL2_ENVIRONMENT_PRESET_LIVINGROOM      -1000,-6000, 0.0f, 0.50f, 0.10f, -1376, 0.003f, -1104, 0.004f, 100.0f, 100.0f, 5000.0f
#define I3DL2_ENVIRONMENT_PRESET_STONEROOM       -1000, -300, 0.0f, 2.31f, 0.64f,  -711, 0.012f,    83, 0.017f, 100.0f, 100.0f, 5000.0f
#define I3DL2_ENVIRONMENT_PRESET_AUDITORIUM      -1000, -476, 0.0f, 4.32f, 0.59f,  -789, 0.020f,  -289, 0.030f, 100.0f, 100.0f, 5000.0f
#define I3DL2_ENVIRONMENT_PRESET_CONCERTHALL     -1000, -500, 0.0f, 3.92f, 0.70f, -1230, 0.020f,    -2, 0.029f, 100.0f, 100.0f, 5000.0f
#define I3DL2_ENVIRONMENT_PRESET_CAVE            -1000,    0, 0.0f, 2.91f, 1.30f,  -602, 0.015f,  -302, 0.022f, 100.0f, 100.0f, 5000.0f
#define I3DL2_ENVIRONMENT_PRESET_ARENA           -1000, -698, 0.0f, 7.24f, 0.33f, -1166, 0.020f,    16, 0.030f, 100.0f, 100.0f, 5000.0f
#define I3DL2_ENVIRONMENT_PRESET_HANGAR          -1000,-1000, 0.0f,10.05f, 0.23f,  -602, 0.020f,   198, 0.030f, 100.0f, 100.0f, 5000.0f
#define I3DL2_ENVIRONMENT_PRESET_CARPETEDHALLWAY -1000,-4000, 0.0f, 0.30f, 0.10f, -1831, 0.002f, -1630, 0.030f, 100.0f, 100.0f, 5000.0f
#define I3DL2_ENVIRONMENT_PRESET_HALLWAY         -1000, -300, 0.0f, 1.49f, 0.59f, -1219, 0.007f,   441, 0.011f, 100.0f, 100.0f, 5000.0f
#define I3DL2_ENVIRONMENT_PRESET_STONECORRIDOR   -1000, -237, 0.0f, 2.70f, 0.79f, -1214, 0.013f,   395, 0.020f, 100.0f, 100.0f, 5000.0f
#define I3DL2_ENVIRONMENT_PRESET_ALLEY           -1000, -270, 0.0f, 1.49f, 0.86f, -1204, 0.007f,    -4, 0.011f, 100.0f, 100.0f, 5000.0f
#define I3DL2_ENVIRONMENT_PRESET_FOREST          -1000,-3300, 0.0f, 1.49f, 0.54f, -2560, 0.162f,  -613, 0.088f,  79.0f, 100.0f, 5000.0f
#define I3DL2_ENVIRONMENT_PRESET_CITY            -1000, -800, 0.0f, 1.49f, 0.67f, -2273, 0.007f, -2217, 0.011f,  50.0f, 100.0f, 5000.0f
#define I3DL2_ENVIRONMENT_PRESET_MOUNTAINS       -1000,-2500, 0.0f, 1.49f, 0.21f, -2780, 0.300f, -2014, 0.100f,  27.0f, 100.0f, 5000.0f
#define I3DL2_ENVIRONMENT_PRESET_QUARRY          -1000,-1000, 0.0f, 1.49f, 0.83f,-10000, 0.061f,   500, 0.025f, 100.0f, 100.0f, 5000.0f
#define I3DL2_ENVIRONMENT_PRESET_PLAIN           -1000,-2000, 0.0f, 1.49f, 0.50f, -2466, 0.179f, -2514, 0.100f,  21.0f, 100.0f, 5000.0f
#define I3DL2_ENVIRONMENT_PRESET_PARKINGLOT      -1000,    0, 0.0f, 1.65f, 1.50f, -1363, 0.008f, -1153, 0.012f, 100.0f, 100.0f, 5000.0f
#define I3DL2_ENVIRONMENT_PRESET_SEWERPIPE       -1000,-1000, 0.0f, 2.81f, 0.14f,   429, 0.014f,   648, 0.021f,  80.0f,  60.0f, 5000.0f
#define I3DL2_ENVIRONMENT_PRESET_UNDERWATER      -1000,-4000, 0.0f, 1.49f, 0.10f,  -449, 0.007f,  1700, 0.011f, 100.0f, 100.0f, 5000.0f

//
// Examples simulating 'musical' reverb presets
//
// Name       Decay time   Description
// Small Room    1.1s      A small size room with a length of 5m or so.
// Medium Room   1.3s      A medium size room with a length of 10m or so.
// Large Room    1.5s      A large size room suitable for live performances.
// Medium Hall   1.8s      A medium size concert hall.
// Large Hall    1.8s      A large size concert hall suitable for a full orchestra.
// Plate         1.3s      A plate reverb simulation.
//

#define I3DL2_ENVIRONMENT_PRESET_SMALLROOM       -1000, -600, 0.0f, 1.10f, 0.83f,  -400, 0.005f,   500, 0.010f, 100.0f, 100.0f, 5000.0f
#define I3DL2_ENVIRONMENT_PRESET_MEDIUMROOM      -1000, -600, 0.0f, 1.30f, 0.83f, -1000, 0.010f,  -200, 0.020f, 100.0f, 100.0f, 5000.0f
#define I3DL2_ENVIRONMENT_PRESET_LARGEROOM       -1000, -600, 0.0f, 1.50f, 0.83f, -1600, 0.020f, -1000, 0.040f, 100.0f, 100.0f, 5000.0f
#define I3DL2_ENVIRONMENT_PRESET_MEDIUMHALL      -1000, -600, 0.0f, 1.80f, 0.70f, -1300, 0.015f,  -800, 0.030f, 100.0f, 100.0f, 5000.0f
#define I3DL2_ENVIRONMENT_PRESET_LARGEHALL       -1000, -600, 0.0f, 1.80f, 0.70f, -2000, 0.030f, -1400, 0.060f, 100.0f, 100.0f, 5000.0f
#define I3DL2_ENVIRONMENT_PRESET_PLATE           -1000, -200, 0.0f, 1.30f, 0.90f,     0, 0.002f,     0, 0.010f, 100.0f,  75.0f, 5000.0f

//
// DirectSound3D Algorithms
//

// Default DirectSound3D algorithm {00000000-0000-0000-0000-000000000000}
#define DS3DALG_DEFAULT GUID_NULL

// No virtualization (Pan3D) {C241333F-1C1B-11d2-94F5-00C04FC28ACA}
DEFINE_GUID(DS3DALG_NO_VIRTUALIZATION, 0xc241333f, 0x1c1b, 0x11d2, 0x94, 0xf5, 0x0, 0xc0, 0x4f, 0xc2, 0x8a, 0xca);

// High-quality HRTF algorithm {C2413340-1C1B-11d2-94F5-00C04FC28ACA}
DEFINE_GUID(DS3DALG_HRTF_FULL, 0xc2413340, 0x1c1b, 0x11d2, 0x94, 0xf5, 0x0, 0xc0, 0x4f, 0xc2, 0x8a, 0xca);

// Lower-quality HRTF algorithm {C2413342-1C1B-11d2-94F5-00C04FC28ACA}
DEFINE_GUID(DS3DALG_HRTF_LIGHT, 0xc2413342, 0x1c1b, 0x11d2, 0x94, 0xf5, 0x0, 0xc0, 0x4f, 0xc2, 0x8a, 0xca);

//@@BEGIN_MSINTERNAL
// Original DirectSound3D ITD algorithm {1B5C9566-5E20-11d2-91BD-00C04FC28ACA}
DEFINE_GUID(DS3DALG_ITD, 0x1b5c9566, 0x5e20, 0x11d2, 0x91, 0xbd, 0x0, 0xc0, 0x4f, 0xc2, 0x8a, 0xca);
//@@END_MSINTERNAL

#if DIRECTSOUND_VERSION >= 0x0800

//
// DirectSound Internal Effect Algorithms
//

//@@BEGIN_MSINTERNAL
// Buffer Send {EF602176-BCBB-49E0-8CCA-E09A5A152B33}
DEFINE_GUID(GUID_DSFX_SEND, 0xef602176, 0xbcbb, 0x49e0, 0x8c, 0xca, 0xe0, 0x9a, 0x5a, 0x15, 0x2b, 0x33);
//@@END_MSINTERNAL

// Gargle {DAFD8210-5711-4B91-9FE3-F75B7AE279BF}
DEFINE_GUID(GUID_DSFX_STANDARD_GARGLE, 0xdafd8210, 0x5711, 0x4b91, 0x9f, 0xe3, 0xf7, 0x5b, 0x7a, 0xe2, 0x79, 0xbf);

// Chorus {EFE6629C-81F7-4281-BD91-C9D604A95AF6}
DEFINE_GUID(GUID_DSFX_STANDARD_CHORUS, 0xefe6629c, 0x81f7, 0x4281, 0xbd, 0x91, 0xc9, 0xd6, 0x04, 0xa9, 0x5a, 0xf6);

// Flanger {EFCA3D92-DFD8-4672-A603-7420894BAD98}
DEFINE_GUID(GUID_DSFX_STANDARD_FLANGER, 0xefca3d92, 0xdfd8, 0x4672, 0xa6, 0x03, 0x74, 0x20, 0x89, 0x4b, 0xad, 0x98);

// Echo/Delay {EF3E932C-D40B-4F51-8CCF-3F98F1B29D5D}
DEFINE_GUID(GUID_DSFX_STANDARD_ECHO, 0xef3e932c, 0xd40b, 0x4f51, 0x8c, 0xcf, 0x3f, 0x98, 0xf1, 0xb2, 0x9d, 0x5d);

// Distortion {EF114C90-CD1D-484E-96E5-09CFAF912A21}
DEFINE_GUID(GUID_DSFX_STANDARD_DISTORTION, 0xef114c90, 0xcd1d, 0x484e, 0x96, 0xe5, 0x09, 0xcf, 0xaf, 0x91, 0x2a, 0x21);

// Compressor/Limiter {EF011F79-4000-406D-87AF-BFFB3FC39D57}
DEFINE_GUID(GUID_DSFX_STANDARD_COMPRESSOR, 0xef011f79, 0x4000, 0x406d, 0x87, 0xaf, 0xbf, 0xfb, 0x3f, 0xc3, 0x9d, 0x57);

// Parametric Equalization {120CED89-3BF4-4173-A132-3CB406CF3231}
DEFINE_GUID(GUID_DSFX_STANDARD_PARAMEQ, 0x120ced89, 0x3bf4, 0x4173, 0xa1, 0x32, 0x3c, 0xb4, 0x06, 0xcf, 0x32, 0x31);

//@@BEGIN_MSINTERNAL
// I3DL2 Environmental Reverberation: Source Effect {EFBA364A-E606-451C-8E97-07D508119C65}
///DEFINE_GUID(GUID_DSFX_STANDARD_I3DL2SOURCE, 0xefba364a, 0xe606, 0x451c, 0x8e, 0x97, 0x07, 0xd5, 0x08, 0x11, 0x9c, 0x65);
//@@END_MSINTERNAL

// I3DL2 Environmental Reverberation: Reverb (Listener) Effect {EF985E71-D5C7-42D4-BA4D-2D073E2E96F4}
DEFINE_GUID(GUID_DSFX_STANDARD_I3DL2REVERB, 0xef985e71, 0xd5c7, 0x42d4, 0xba, 0x4d, 0x2d, 0x07, 0x3e, 0x2e, 0x96, 0xf4);

// Waves Reverberation {87FC0268-9A55-4360-95AA-004A1D9DE26C}
DEFINE_GUID(GUID_DSFX_WAVES_REVERB, 0x87fc0268, 0x9a55, 0x4360, 0x95, 0xaa, 0x00, 0x4a, 0x1d, 0x9d, 0xe2, 0x6c);

//
// DirectSound Capture Effect Algorithms
//

//@@BEGIN_MSINTERNAL
// Microphone Array Processor {830A44f2-A32D-476B-BE97-42845673B35A}
// Matches KSNODETYPE_MICROPHONE_ARRAY_PROCESSOR in ksmedia.h
DEFINE_GUID(GUID_DSCFX_CLASS_MA, 0x830A44F2, 0xA32D, 0x476B,  0xBE, 0x97, 0x42, 0x84, 0x56, 0x73, 0xB3, 0x5A);

// Microsoft Microphone Array Processor {F4A49496-1481-44d7-9C4E-A0269CAF0597}
DEFINE_GUID(GUID_DSCFX_MS_MA, 0xF4A49496, 0x1481, 0x44d7, 0x9C, 0x4E, 0xA0, 0x26, 0x9C, 0xAF, 0x5, 0x97);

// System Microphone Array Processor {B6F5A0A0-9E61-4f8c-91E3-76CF0F3C471F}
DEFINE_GUID(GUID_DSCFX_SYSTEM_MA, 0xB6F5A0A0, 0x9E61, 0x4F8C, 0x91, 0xE3, 0x76, 0xCF, 0xF, 0x3C, 0x47, 0x1F );

// Automatic Gain Control {E88C9BA0-C557-11D0-8A2B-00A0C9255AC1}
// Matches KSNODETYPE_AGC in ksmedia.h
DEFINE_GUID(GUID_DSCFX_CLASS_AGC, 0xE88C9BA0L, 0xC557, 0x11D0, 0x8A, 0x2B, 0x00, 0xA0, 0xC9, 0x25, 0x5A, 0xC1);

// Microsoft Automatic Gain Control {5A86531E-8E2A-419f-B4CC-18EB8E891796}
DEFINE_GUID(GUID_DSCFX_MS_AGC, 0x5a86531e, 0x8e2a, 0x419f, 0xb4, 0xcc, 0x18, 0xeb, 0x8e, 0x89, 0x17, 0x96);

// System Automatic Gain Control {950E55B9-877C-4c67-BE08-E47B5611130A}
DEFINE_GUID(GUID_DSCFX_SYSTEM_AGC, 0x950e55b9, 0x877c, 0x4c67, 0xbe, 0x8, 0xe4, 0x7b, 0x56, 0x11, 0x13, 0xa);
//@@END_MSINTERNAL

// Acoustic Echo Canceller {BF963D80-C559-11D0-8A2B-00A0C9255AC1}
// Matches KSNODETYPE_ACOUSTIC_ECHO_CANCEL in ksmedia.h
DEFINE_GUID(GUID_DSCFX_CLASS_AEC, 0xBF963D80L, 0xC559, 0x11D0, 0x8A, 0x2B, 0x00, 0xA0, 0xC9, 0x25, 0x5A, 0xC1);

// Microsoft AEC {CDEBB919-379A-488a-8765-F53CFD36DE40}
DEFINE_GUID(GUID_DSCFX_MS_AEC, 0xcdebb919, 0x379a, 0x488a, 0x87, 0x65, 0xf5, 0x3c, 0xfd, 0x36, 0xde, 0x40);

// System AEC {1C22C56D-9879-4f5b-A389-27996DDC2810}
DEFINE_GUID(GUID_DSCFX_SYSTEM_AEC, 0x1c22c56d, 0x9879, 0x4f5b, 0xa3, 0x89, 0x27, 0x99, 0x6d, 0xdc, 0x28, 0x10);

// Noise Supression {E07F903F-62FD-4e60-8CDD-DEA7236665B5}
// Matches KSNODETYPE_NOISE_SUPPRESS in post Windows ME DDK's ksmedia.h
DEFINE_GUID(GUID_DSCFX_CLASS_NS, 0xe07f903f, 0x62fd, 0x4e60, 0x8c, 0xdd, 0xde, 0xa7, 0x23, 0x66, 0x65, 0xb5);

// Microsoft Noise Suppresion {11C5C73B-66E9-4ba1-A0BA-E814C6EED92D}
DEFINE_GUID(GUID_DSCFX_MS_NS, 0x11c5c73b, 0x66e9, 0x4ba1, 0xa0, 0xba, 0xe8, 0x14, 0xc6, 0xee, 0xd9, 0x2d);

// System Noise Suppresion {5AB0882E-7274-4516-877D-4EEE99BA4FD0}
DEFINE_GUID(GUID_DSCFX_SYSTEM_NS, 0x5ab0882e, 0x7274, 0x4516, 0x87, 0x7d, 0x4e, 0xee, 0x99, 0xba, 0x4f, 0xd0);

#endif // DIRECTSOUND_VERSION >= 0x0800

#endif // __DSOUND_INCLUDED__


//@@BEGIN_MSINTERNAL

#ifndef __DSOUNDP_INCLUDED__
#define __DSOUNDP_INCLUDED__

#if DIRECTSOUND_VERSION >= 0x0800

//
// Private DirectSound interfaces used by DMusic, DPlayVoice, etc.
// Eventually much of the MSINTERNAL stuff above should migrate here.
//

#ifdef __cplusplus
struct IDirectSoundPrivate;
struct IDirectSoundSynthSink;
struct IDirectSoundConnect;
struct IDirectSoundSinkSync;
struct IDirectSoundSource;
struct IDirectSoundWave;
#endif // __cplusplus

#define IDirectSoundPrivate8          IDirectSoundPrivate
#define IDirectSoundSynthSink8        IDirectSoundSynthSink
#define IDirectSoundConnect8          IDirectSoundConnect
#define IDirectSoundSinkSync8         IDirectSoundSinkSync
#define IDirectSoundSource8           IDirectSoundSource
#define IDirectSoundWave8             IDirectSoundWave

#define IID_IDirectSoundPrivate8      IID_IDirectSoundPrivate
#define IID_IDirectSoundSynthSink8    IID_IDirectSoundSynthSink
#define IID_IDirectSoundConnect8      IID_IDirectSoundConnect
#define IID_IDirectSoundSinkSync8     IID_IDirectSoundSinkSync
#define IID_IDirectSoundSource8       IID_IDirectSoundSource
#define IID_IDirectSoundWave8         IID_IDirectSoundWave

typedef struct IDirectSoundPrivate    *LPDIRECTSOUNDPRIVATE;
typedef struct IDirectSoundSynthSink  *LPDIRECTSOUNDSYNTHSINK;
typedef struct IDirectSoundConnect    *LPDIRECTSOUNDCONNECT;
typedef struct IDirectSoundSinkSync   *LPDIRECTSOUNDSINKSYNC;
typedef struct IDirectSoundSource     *LPDIRECTSOUNDSOURCE;
typedef struct IDirectSoundWave       *LPDIRECTSOUNDWAVE;

typedef struct IDirectSoundPrivate8   *LPDIRECTSOUNDPRIVATE8;
typedef struct IDirectSoundSynthSink8 *LPDIRECTSOUNDSYNTHSINK8;
typedef struct IDirectSoundConnect8   *LPDIRECTSOUNDCONNECT8;
typedef struct IDirectSoundSinkSync8  *LPDIRECTSOUNDSINKSYNC8;
typedef struct IDirectSoundSource8    *LPDIRECTSOUNDSOURCE8;
typedef struct IDirectSoundWave8      *LPDIRECTSOUNDWAVE8;

//
// IDirectSoundPrivate: used by DirectMusic to create DirectSoundSink objects
//

DEFINE_GUID(IID_IDirectSoundPrivate, 0xd6e525ae, 0xb125, 0x4ec4, 0xbe, 0x13, 0x12, 0x6d, 0x0c, 0xf7, 0xaf, 0xb6);

#undef INTERFACE
#define INTERFACE IDirectSoundPrivate

DECLARE_INTERFACE_(IDirectSoundPrivate, IUnknown)
{
    // IUnknown methods
    STDMETHOD(QueryInterface)       (THIS_ REFIID, LPVOID FAR *) PURE;
    STDMETHOD_(ULONG,AddRef)        (THIS) PURE;
    STDMETHOD_(ULONG,Release)       (THIS) PURE;

    // IDirectSoundPrivate methods
    STDMETHOD(AllocSink)            (THIS_ LPWAVEFORMATEX pwfxFormat, LPDIRECTSOUNDCONNECT *ppSinkConnect) PURE;
};

#define IDirectSoundPrivate_QueryInterface(p,a,b)       IUnknown_QueryInterface(p,a,b)
#define IDirectSoundPrivate_AddRef(p)                   IUnknown_AddRef(p)
#define IDirectSoundPrivate_Release(p)                  IUnknown_Release(p)

#if !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectSoundPrivate_AllocSink(p,a,b)            (p)->lpVtbl->AllocSink(p,a,b)
#else // !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectSoundPrivate_AllocSink(p,a,b)            (p)->AllocSink(a,b)
#endif // !defined(__cplusplus) || defined(CINTERFACE)

//
// IDirectSoundSynthSink: used by the DirectMusic synthesiser
//

DEFINE_GUID(IID_IDirectSoundSynthSink, 0x73a6a85a, 0x493e, 0x4c87, 0xb4, 0xa5, 0xbe, 0x53, 0xeb, 0x92, 0x74, 0x4b);

#undef INTERFACE
#define INTERFACE IDirectSoundSynthSink

DECLARE_INTERFACE_(IDirectSoundSynthSink, IUnknown)
{
    // IUnknown methods
    STDMETHOD(QueryInterface)       (THIS_ REFIID, LPVOID FAR *) PURE;
    STDMETHOD_(ULONG,AddRef)        (THIS) PURE;
    STDMETHOD_(ULONG,Release)       (THIS) PURE;

    // IDirectSoundSynthSink methods
    STDMETHOD(GetLatencyClock)      (THIS_ IReferenceClock **ppClock) PURE;
    STDMETHOD(Activate)             (THIS_ BOOL fEnable) PURE;
    STDMETHOD(SampleToRefTime)      (THIS_ LONGLONG llSampleTime, REFERENCE_TIME *prtTime) PURE;
    STDMETHOD(RefToSampleTime)      (THIS_ REFERENCE_TIME rtTime, LONGLONG *pllSampleTime) PURE;
    STDMETHOD(GetFormat)            (THIS_ LPWAVEFORMATEX pwfxFormat, DWORD dwSizeAllocated, LPDWORD pdwSizeWritten) PURE;
};

#define IDirectSoundSynthSink_QueryInterface(p,a,b)     IUnknown_QueryInterface(p,a,b)
#define IDirectSoundSynthSink_AddRef(p)                 IUnknown_AddRef(p)
#define IDirectSoundSynthSink_Release(p)                IUnknown_Release(p)

#if !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectSoundSynthSink_GetLatencyClock(p,a)      (p)->lpVtbl->GetLatencyClock(p,a)
#define IDirectSoundSynthSink_Activate(p,a)             (p)->lpVtbl->Activate(p,a)
#define IDirectSoundSynthSink_SampleToRefTime(p,a,b)    (p)->lpVtbl->SampleToRefTime(p,a,b)
#define IDirectSoundSynthSink_RefToSampleTime(p,a,b)    (p)->lpVtbl->RefToSampleTime(p,a,b)
#define IDirectSoundSynthSink_GetFormat(p,a,b)          (p)->lpVtbl->GetFormat(p,a,b)
#else // !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectSoundSynthSink_GetLatencyClock(p,a)      (p)->GetLatencyClock(a)
#define IDirectSoundSynthSink_Activate(p,a)             (p)->Activate(a)
#define IDirectSoundSynthSink_SampleToRefTime(p,a,b)    (p)->SampleToRefTime(a,b)
#define IDirectSoundSynthSink_RefToSampleTime(p,a,b)    (p)->RefToSampleTime(a,b)
#define IDirectSoundSynthSink_GetFormat(p,a,b)          (p)->GetFormat(a,b)
#endif // !defined(__cplusplus) || defined(CINTERFACE)

//
// IDirectSoundConnect: used by DirectMusic to implement
// audio paths and connect the synthesiser to the sink
//

DEFINE_GUID(IID_IDirectSoundConnect, 0x5bee1fe0, 0x60d5, 0x4ef9, 0x88, 0xbc, 0x33, 0x67, 0xb9, 0x75, 0xc6, 0x11);

#undef INTERFACE
#define INTERFACE IDirectSoundConnect

DECLARE_INTERFACE_(IDirectSoundConnect, IUnknown)
{
    // IUnknown methods
    STDMETHOD(QueryInterface)       (THIS_ REFIID, LPVOID FAR *) PURE;
    STDMETHOD_(ULONG,AddRef)        (THIS) PURE;
    STDMETHOD_(ULONG,Release)       (THIS) PURE;

    // IDirectSoundConnect methods
    STDMETHOD(AddSource)            (THIS_ LPDIRECTSOUNDSOURCE pDSSource) PURE;
    STDMETHOD(RemoveSource)         (THIS_ LPDIRECTSOUNDSOURCE pDSSource) PURE;
    STDMETHOD(SetMasterClock)       (THIS_ IReferenceClock *pClock) PURE;
    STDMETHOD(CreateSoundBuffer)    (THIS_ LPCDSBUFFERDESC pcDSBufferDesc, LPDWORD pdwFuncID, DWORD dwBusIDCount,
                                           REFGUID guidBufferID, LPDIRECTSOUNDBUFFER *ppDSBuffer) PURE;
    STDMETHOD(CreateSoundBufferFromConfig) (THIS_ LPUNKNOWN pConfig, LPDIRECTSOUNDBUFFER *ppDSBuffer) PURE;
    STDMETHOD(GetSoundBuffer)       (THIS_ DWORD dwBusID, LPDIRECTSOUNDBUFFER *ppDSBuffer) PURE;
    STDMETHOD(GetBusCount)          (THIS_ LPDWORD pdwCount) PURE;
    STDMETHOD(GetBusIDs)            (THIS_ LPDWORD pdwBusIDs, LPDWORD pdwFuncIDs, DWORD dwBusCount) PURE;
    STDMETHOD(GetFunctionalID)      (THIS_ DWORD dwBusID, LPDWORD pdwFuncID) PURE;
    STDMETHOD(GetSoundBufferBusIDs) (THIS_ LPDIRECTSOUNDBUFFER pDSBuffer, LPDWORD pdwBusIDs, LPDWORD pdwFuncIDs, LPDWORD pdwBusCount) PURE;
};

#define IDirectSoundConnect_QueryInterface(p,a,b)               IUnknown_QueryInterface(p,a,b)
#define IDirectSoundConnect_AddRef(p)                           IUnknown_AddRef(p)
#define IDirectSoundConnect_Release(p)                          IUnknown_Release(p)

#if !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectSoundConnect_AddSource(p,a)                      (p)->lpVtbl->AddSource(p,a)
#define IDirectSoundConnect_RemoveSource(p,a)                   (p)->lpVtbl->RemoveSource(p,a)
#define IDirectSoundConnect_SetMasterClock(p,a)                 (p)->lpVtbl->SetMasterClock(p,a)
#define IDirectSoundConnect_CreateSoundBuffer(p,a,b,c,d)        (p)->lpVtbl->CreateSoundBuffer(p,a,b,c,d)
#define IDirectSoundConnect_CreateSoundBufferFromConfig(p,a,b)  (p)->lpVtbl->CreateSoundBufferFromConfig(p,a,b)
#define IDirectSoundConnect_GetSoundBuffer(p,a,b)               (p)->lpVtbl->GetSoundBuffer(p,a,b)
#define IDirectSoundConnect_GetBusCount(p,a)                    (p)->lpVtbl->GetBusCount(p,a)
#define IDirectSoundConnect_GetBusIDs(p,a,b,c)                  (p)->lpVtbl->GetBusIDs(p,a,b,c)
#define IDirectSoundConnect_GetFunctionalID(p,a,b)              (p)->lpVtbl->GetFunctionalID(p,a,b)
#define IDirectSoundConnect_GetSoundBufferBusIDs(p,a,b,c,d)     (p)->lpVtbl->GetSoundBufferBusIDs(p,a,b,c,d)
#else // !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectSoundConnect_AddSource(p,a)                      (p)->AddSource(a)
#define IDirectSoundConnect_RemoveSource(p,a)                   (p)->RemoveSource(a)
#define IDirectSoundConnect_SetMasterClock(p,a)                 (p)->SetMasterClock(a)
#define IDirectSoundConnect_CreateSoundBuffer(p,a,b,c,d)        (p)->CreateSoundBuffer(a,b,c,d)
#define IDirectSoundConnect_CreateSoundBufferFromConfig(p,a,b)  (p)->CreateSoundBufferFromConfig(a,b)
#define IDirectSoundConnect_GetSoundBuffer(p,a,b)               (p)->GetSoundBuffer(a,b)
#define IDirectSoundConnect_GetBusCount(p,a)                    (p)->GetBusCount(a)
#define IDirectSoundConnect_GetBusIDs(p,a,b,c)                  (p)->GetBusIDs(a,b,c)
#define IDirectSoundConnect_GetFunctionalID(p,a,b)              (p)->GetFunctionalID(a,b)
#define IDirectSoundConnect_GetSoundBufferBusIDs(p,a,b,c,d)     (p)->GetSoundBufferBusIDs(a,b,c,d)
#endif // !defined(__cplusplus) || defined(CINTERFACE)

//
// IDirectSoundSinkSync: provided by the DirectMusic master clock
// to allow DirectSound to synchronize with it
//

DEFINE_GUID(IID_IDirectSoundSinkSync, 0xd28de0d0, 0x2794, 0x492f, 0xa3, 0xff, 0xe2, 0x41, 0x80, 0xd5, 0x43, 0x79);

#undef INTERFACE
#define INTERFACE IDirectSoundSinkSync

DECLARE_INTERFACE_(IDirectSoundSinkSync, IUnknown)
{
    // IUnknown methods
    STDMETHOD(QueryInterface)       (THIS_ REFIID, LPVOID FAR *) PURE;
    STDMETHOD_(ULONG,AddRef)        (THIS) PURE;
    STDMETHOD_(ULONG,Release)       (THIS) PURE;

    // IDirectSoundSinkSync methods
    STDMETHOD(SetClockOffset)       (THIS_ LONGLONG llOffset) PURE;
};

#define IDirectSoundSinkSync_QueryInterface(p,a,b)  IUnknown_QueryInterface(p,a,b)
#define IDirectSoundSinkSync_AddRef(p)              IUnknown_AddRef(p)
#define IDirectSoundSinkSync_Release(p)             IUnknown_Release(p)

#if !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectSoundSinkSync_SetClockOffset(p,a)    (p)->lpVtbl->SetClockOffset(p,a)
#else // !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectSoundSinkSync_SetClockOffset(p,a)    (p)->SetClockOffset(a)
#endif // !defined(__cplusplus) || defined(CINTERFACE)

//
// IDirectSoundSource (currently private)
//

DEFINE_GUID(IID_IDirectSoundSource, 0x536f7af3, 0xdb03, 0x4888, 0x93, 0x66, 0x54, 0x48, 0xb1, 0x1d, 0x4a, 0x19);

#undef INTERFACE
#define INTERFACE IDirectSoundSource

DECLARE_INTERFACE_(IDirectSoundSource, IUnknown)
{
    // IUnknown methods
    STDMETHOD(QueryInterface)       (THIS_ REFIID, LPVOID *) PURE;
    STDMETHOD_(ULONG,AddRef)        (THIS) PURE;
    STDMETHOD_(ULONG,Release)       (THIS) PURE;

    // IDirectSoundSource methods
    STDMETHOD(SetSink)              (THIS_ LPDIRECTSOUNDCONNECT pSinkConnect) PURE;
    STDMETHOD(GetFormat)            (THIS_ LPWAVEFORMATEX pwfxFormat, DWORD dwSizeAllocated, LPDWORD pdwSizeWritten) PURE;
    STDMETHOD(Seek)                 (THIS_ ULONGLONG ullPosition) PURE;
    STDMETHOD(Read)                 (THIS_ LPVOID *ppvBusBuffers, LPDWORD pdwIDs, LPDWORD pdwFuncIDs, LPLONG plPitchAdjust, DWORD dwBufferCount, ULONGLONG *ullLength) PURE;
    STDMETHOD(GetSize)              (THIS_ ULONGLONG *pullStreamSize) PURE;
};

#define IDirectSoundSource_QueryInterface(p,a,b)    IUnknown_QueryInterface(p,a,b)
#define IDirectSoundSource_AddRef(p)                IUnknown_AddRef(p)
#define IDirectSoundSource_Release(p)               IUnknown_Release(p)

#if !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectSoundSource_SetSink(p,a)             (p)->lpVtbl->SetSink(p,a)
#define IDirectSoundSource_GetFormat(p,a,b)         (p)->lpVtbl->GetFormat(p,a,b)
#define IDirectSoundSource_Seek(p,a)                (p)->lpVtbl->Seek(p,a)
#define IDirectSoundSource_Read(p,a,b,c,d,e)        (p)->lpVtbl->Read(p,a,b,c,d,e)
#define IDirectSoundSource_GetSize(p,a)             (p)->lpVtbl->GetSize(p,a)
#else // !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectSoundSource_SetSink(p,a)             (p)->SetSink(a)
#define IDirectSoundSource_GetFormat(p,a,b)         (p)->GetFormat(a,b)
#define IDirectSoundSource_Seek(p,a)                (p)->Seek(a)
#define IDirectSoundSource_Read(p,a,b,c,d,e)        (p)->Read(a,b,c,d,e)
#define IDirectSoundSource_GetSize(p,a)             (p)->GetSize(a)
#endif // !defined(__cplusplus) || defined(CINTERFACE)

//
// IDirectSoundWave (currently private)
//

DEFINE_GUID(IID_IDirectSoundWave, 0x69e934e4, 0x97f1, 0x4f1d, 0x88, 0xe8, 0xf2, 0xac, 0x88, 0x67, 0x13, 0x27);

#define DSWCS_F_DEINTERLEAVED   0x00000001
#define DSWCS_F_TOGGLE_8BIT     0x00000002

#undef INTERFACE
#define INTERFACE IDirectSoundWave

DECLARE_INTERFACE_(IDirectSoundWave, IUnknown)
{
    // IUnknown methods
    STDMETHOD(QueryInterface)       (THIS_ REFIID, LPVOID *) PURE;
    STDMETHOD_(ULONG,AddRef)        (THIS) PURE;
    STDMETHOD_(ULONG,Release)       (THIS) PURE;

    // IDirectSoundWave methods
    STDMETHOD(CreateSource)         (THIS_ LPDIRECTSOUNDSOURCE *ppDSSource, LPWAVEFORMATEX pwfxFormat, DWORD dwFlags) PURE;
    STDMETHOD(GetFormat)            (THIS_ LPWAVEFORMATEX pwfxFormat, DWORD dwSizeAllocated, LPDWORD pdwSizeWritten) PURE;
    STDMETHOD(GetStreamingParms)    (THIS_ LPDWORD pdwFlags, REFERENCE_TIME *prtReadAhead) PURE;
};

#define IDirectSoundWave_QueryInterface(p,a,b)      IUnknown_QueryInterface(p,a,b)
#define IDirectSoundWave_AddRef(p)                  IUnknown_AddRef(p)
#define IDirectSoundWave_Release(p)                 IUnknown_Release(p)

#if !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectSoundWave_CreateSource(p,a,b,c)      (p)->lpVtbl->CreateSource(p,a,b,c)
#define IDirectSoundWave_GetFormat(p,a,b)           (p)->lpVtbl->GetFormat(p,a,b)
#define IDirectSoundWave_GetStreamingParms(p,a,b)   (p)->lpVtbl->GetStreamingParms(p,a,b)
#else // !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectSoundWave_CreateSource(p,a,b,c)      (p)->CreateSource(a,b,c)
#define IDirectSoundWave_GetFormat(p,a,b)           (p)->GetFormat(a,b)
#define IDirectSoundWave_GetStreamingParms(p,a,b)   (p)->GetStreamingParms(a,b)
#endif // !defined(__cplusplus) || defined(CINTERFACE)

#endif // DIRECTSOUND_VERSION >= 0x0800

#endif // __DSOUNDP_INCLUDED__

//@@END_MSINTERNAL

#ifdef __cplusplus
};
#endif // __cplusplus
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\XboxSynth\error.h ===
// Copyright (c) 1998 Microsoft Corporation
//      Error.h

#define RA_E_FIRST				(OLE_E_FIRST + 5000)

#define E_BADWAVE		        (RA_E_FIRST + 1)    // Bad wave chunk
#define E_NOTPCM		        (RA_E_FIRST + 2)    // Not PCM data in wave
#define E_NOTMONO		        (RA_E_FIRST + 3)    // Wave not MONO
#define E_BADARTICULATION       (RA_E_FIRST + 4)    // Bad articulation chunk
#define E_BADREGION		        (RA_E_FIRST + 5)    // Bad region chunk
#define E_BADWAVELINK	        (RA_E_FIRST + 6)    // Bad link from region to wave
#define E_BADINSTRUMENT	        (RA_E_FIRST + 7)    // Bad instrument chunk
#define E_NOARTICULATION        (RA_E_FIRST + 8)    // No articulation found in region
#define E_NOWAVE		        (RA_E_FIRST + 9)    // No wave found for region.
#define E_BADCOLLECTION	        (RA_E_FIRST + 10)   // Bad collection chunk.
#define E_NOLOADER   	        (RA_E_FIRST + 11)   // No IRALoader interface 
#define E_NOLOCK		        (RA_E_FIRST + 12)   // Unable to lock a region.
#define E_TOOBUSY		        (RA_E_FIRST + 13)   // RActive to busy to fully follow command.
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\XboxSynth\float.h ===
//      Copyright (c) 1996-1999 Microsoft Corporation

// float.h
//
// Defines fp_ floating point functions which don't rely on the C runtime.
//
// If you don't want to pull in C runtime floating point support, you
// need to include the following in a .cpp file:
//
//     extern "C" int _fltused = 1;
//

// floating point operations
STDAPI_(long)   fp_ftol     (float flX);
STDAPI_(float)  fp_ltof     (long lX);
STDAPI_(float)  fp_fadd     (float fA, float fB);
STDAPI_(float)  fp_fsub     (float fA, float fB);
STDAPI_(float)  fp_fmul     (float fA, float fB);
STDAPI_(float)  fp_fdiv     (float fNum, float fDenom);
STDAPI_(float)  fp_fabs     (float flX);
STDAPI_(float)  fp_fsin     (float flX);
STDAPI_(float)  fp_fcos     (float flX);
STDAPI_(float)  fp_fpow     (float flX, float flY);
STDAPI_(float)  fp_flog2    (float flX);
STDAPI_(float)  fp_flog10   (float flX);
STDAPI_(float)  fp_fchs     (float flX);
STDAPI_(int)    fp_fcmp     (float flA, float flB);
STDAPI_(float)  fp_fmin     (float flA, float flB);
STDAPI_(float)  fp_fmax     (float flA, float flB);
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\XboxSynth\guids.cpp ===
//      Copyright (c) 1996-2001 Microsoft Corporation

#include <objbase.h>
#include "initguid.h"
#include <mmsystem.h>
#include <dsoundp.h>
#include "dmusicc.h"
#include "dmusics.h"
#include "dmusici.h"
#include "dsoundp.h"
#include "..\shared\dmusiccp.h" // For class ids.
#include "umsynth.h"
#include "dmksctrl.h"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\XboxSynth\dmsynth.cpp ===
//      Copyright (c) 1996-2001 Microsoft Corporation

// READ THIS!!!!!!!!!!!!!!!!!!!!!!!!!!!
//
// 4530: C++ exception handler used, but unwind semantics are not enabled. Specify -GX
//
// We disable this because we use exceptions and do *not* specify -GX (USE_NATIVE_EH in
// sources).
//
// The one place we use exceptions is around construction of objects that call 
// InitializeCriticalSection. We guarantee that it is safe to use in this case with
// the restriction given by not using -GX (automatic objects in the call chain between
// throw and handler are not destructed). Turning on -GX buys us nothing but +10% to code
// size because of the unwind code.
//
// Any other use of exceptions must follow these restrictions or -GX must be turned on.
//
// READ THIS!!!!!!!!!!!!!!!!!!!!!!!!!!!
//
#pragma warning(disable:4530)
// dmsynth.cpp
//
// Dll entry points and IDirectMusicSynthFactory implementation
//
#include <objbase.h>
#include <mmsystem.h>
#include <dsoundp.h>
#include "debug.h"

#include "oledll.h"

#include "dmusicc.h"
#include "dmusics.h"
#include "umsynth.h"
#include "misc.h" 
#include <regstr.h>
#include "synth.h"

#include "validate.h"


// Globals
//


// Version information for our class
//
TCHAR g_szMSSynthFriendlyName[]    = TEXT("Microsoft Xbox Synthesizer");

TCHAR g_szSynthFriendlyName[]    = TEXT("XboxSynth");
TCHAR g_szSynthVerIndProgID[]    = TEXT("Microsoft.XboxSynth");
TCHAR g_szSynthProgID[]          = TEXT("Microsoft.XboxSynth.1");

// Dll's hModule
//
HMODULE g_hModule = NULL; 

// Count of active components and class factory server locks
//
long g_cComponent = 0;
long g_cLock = 0;


static char const g_szDoEmulation[] = "DoEmulation";

// CDirectMusicSynthFactory::QueryInterface
//
HRESULT __stdcall
CDirectMusicSynthFactory::QueryInterface(const IID &iid,
                                    void **ppv)
{
    V_INAME(IDirectMusicSynthFactory::QueryInterface);
    V_REFGUID(iid);
    V_PTRPTR_WRITE(ppv);

    if (iid == IID_IUnknown || iid == IID_IClassFactory) {
        *ppv = static_cast<IClassFactory*>(this);
    } else {
        *ppv = NULL;
        return E_NOINTERFACE;
    }

    reinterpret_cast<IUnknown*>(*ppv)->AddRef();
    return S_OK;
}

CDirectMusicSynthFactory::CDirectMusicSynthFactory()

{
	m_cRef = 1;
	InterlockedIncrement(&g_cLock);
}

CDirectMusicSynthFactory::~CDirectMusicSynthFactory()

{
	InterlockedDecrement(&g_cLock);
}

// CDirectMusicSynthFactory::AddRef
//
ULONG __stdcall
CDirectMusicSynthFactory::AddRef()
{
    return InterlockedIncrement(&m_cRef);
}

// CDirectMusicSynthFactory::Release
//
ULONG __stdcall
CDirectMusicSynthFactory::Release()
{
    if (!InterlockedDecrement(&m_cRef)) {
        delete this;
        return 0;
    }

    return m_cRef;
}

// CDirectMusicSynthFactory::CreateInstance
//
//
HRESULT __stdcall
CDirectMusicSynthFactory::CreateInstance(IUnknown* pUnknownOuter,
                                    const IID& iid,
                                    void** ppv)
{
//    OSVERSIONINFO osvi;
    HRESULT hr;

//    DebugBreak();
    
    if (pUnknownOuter) {
         return CLASS_E_NOAGGREGATION;
    }

    CUserModeSynth *pDM;
    
    try
    {
        pDM = new CUserModeSynth;
    }
    catch( ... )
    {
        return E_OUTOFMEMORY;
    }

    if (pDM == NULL) {
        return E_OUTOFMEMORY;
    }

    // Do initialiazation
    //
    hr = pDM->Init();
    if (!SUCCEEDED(hr)) {
        delete pDM;
        return hr;
    }

    hr = pDM->QueryInterface(iid, ppv);

    if( FAILED(hr) )
    {
        delete pDM;
    }
    
    return hr;
}

// CDirectMusicSynthFactory::LockServer
//
HRESULT __stdcall
CDirectMusicSynthFactory::LockServer(BOOL bLock)
{
    if (bLock) {
        InterlockedIncrement(&g_cLock);
    } else {
        InterlockedDecrement(&g_cLock);
    }

    return S_OK;
}



// Standard calls needed to be an inproc server
//
STDAPI  DllCanUnloadNow()
{
    if (g_cComponent || g_cLock) {
        return S_FALSE;
    }

    return S_OK;
}

STDAPI DllGetClassObject(const CLSID& clsid,
                         const IID& iid,
                         void** ppv)
{
        IUnknown* pIUnknown = NULL;


        if(clsid == CLSID_XboxSynth)
        {

                pIUnknown = static_cast<IUnknown*> (new CDirectMusicSynthFactory);
                if(!pIUnknown) 
                {
                        return E_OUTOFMEMORY;
                }
        }
        else
        {
			return CLASS_E_CLASSNOTAVAILABLE;
		}

        HRESULT hr = pIUnknown->QueryInterface(iid, ppv);
        pIUnknown->Release();

    return hr;
}

const TCHAR cszSynthRegRoot[] = TEXT(REGSTR_PATH_SOFTWARESYNTHS) TEXT("\\");
const TCHAR cszDescriptionKey[] = TEXT("Description");
const int CLSID_STRING_SIZE = 39;
HRESULT CLSIDToStr(const CLSID &clsid, TCHAR *szStr, int cbStr);

HRESULT RegisterSynth(REFGUID guid,
                      const TCHAR szDescription[])
{
    HKEY hk;
    TCHAR szCLSID[CLSID_STRING_SIZE];
    TCHAR szRegKey[256];
    
    HRESULT hr = CLSIDToStr(guid, szCLSID, sizeof(szCLSID));
    if (!SUCCEEDED(hr))
    {
        return hr;
    }

    lstrcpy(szRegKey, cszSynthRegRoot);
    lstrcat(szRegKey, szCLSID);

    if (RegCreateKey(HKEY_LOCAL_MACHINE,
                     szRegKey,
                     &hk))
    {
        return E_FAIL;
    }

    hr = S_OK;

    if (RegSetValueEx(hk,
                  cszDescriptionKey,
                  0L,
                  REG_SZ,
                  (CONST BYTE*)szDescription,
                  lstrlen(szDescription) + 1))
    {
        hr = E_FAIL;
    }

    RegCloseKey(hk);
    return hr;
}

STDAPI DllUnregisterServer()
{
    UnregisterServer(CLSID_XboxSynth,
                     g_szSynthFriendlyName,
                     g_szSynthVerIndProgID,
                     g_szSynthProgID);


    return S_OK;
}

STDAPI DllRegisterServer()
{
    RegisterServer(g_hModule,
                   CLSID_XboxSynth,
                   g_szSynthFriendlyName,
                   g_szSynthVerIndProgID,
                   g_szSynthProgID);


    RegisterSynth(CLSID_XboxSynth, g_szMSSynthFriendlyName);

    return S_OK;
}

extern void DebugInit();

// Standard Win32 DllMain
//

#ifdef DBG
static char* aszReasons[] =
{
    "DLL_PROCESS_DETACH",
    "DLL_PROCESS_ATTACH",
    "DLL_THREAD_ATTACH",
    "DLL_THREAD_DETACH"
};
const DWORD nReasons = (sizeof(aszReasons) / sizeof(char*));
#endif

BOOL APIENTRY DllMain(HINSTANCE hModule,
                      DWORD dwReason,
                      void *lpReserved)

{
    static int nReferenceCount = 0;

#ifdef DBG
    if (dwReason < nReasons)
    {
        Trace(0, "DllMain: %s\n", (LPSTR)aszReasons[dwReason]);
    }
    else
    {
        Trace(0, "DllMain: Unknown dwReason <%u>\n", dwReason);
    }
#endif
    if (dwReason == DLL_PROCESS_ATTACH) {
        if (++nReferenceCount == 1)
		{
            DisableThreadLibraryCalls(hModule);
            g_hModule = hModule;
#ifdef DBG
			DebugInit();
#endif
#ifdef DBG
//>>>>>>>>> remove these when done 
/*
			_CrtSetReportMode( _CRT_WARN, _CRTDBG_MODE_DEBUG );
			int iFlag = _CrtSetDbgFlag( _CRTDBG_REPORT_FLAG );
			_CrtSetDbgFlag( iFlag | _CRTDBG_ALLOC_MEM_DF | _CRTDBG_CHECK_ALWAYS_DF );
*/
#endif 
            if (!CControlLogic::InitCriticalSection())
            {
                TraceI(0, "Failed to initialize global critical section -- failing init\n");
                return FALSE;
            }            
		}
    }
	else if (dwReason == DLL_PROCESS_DETACH) 
	{
		if (--nReferenceCount == 0)
		{
            TraceI(-1, "Unloading g_cLock %d  g_cComponent %d\n", g_cLock, g_cComponent);
            // Assert if we still have some objects hanging around
            assert(g_cComponent == 0);
            assert(g_cLock == 0);
		}

#ifdef DBG
//>>>>>>>>> remove these when done 
/*
		if ( !_CrtCheckMemory() )
		    ::MessageBox(NULL,"Synth Heap Corupted","ERROR",MB_OK);

        if ( _CrtDumpMemoryLeaks() )
		    ::MessageBox(NULL,"Memory Leaks Detected","ERROR",MB_OK);
*/
#endif 
        CControlLogic::KillCriticalSection();
	}
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\XboxSynth\fparms.h ===
// Filter coefficients in 2.30 fixed point
//

// b1 min -1.998977207 max -0.166675302 range  0.083380291
//
// NOTE: b1 is stored as a positive value, and these coefcients are 
//       the negation of b1, which when originally calculated is a 
//       negative number.  Compensation for this is made in the 
//       filter calculation by changing a subtraction to and add.
//
COEFF CVoiceFilter::m_aB1[FILTER_PARMS_DIM_Q][FILTER_PARMS_DIM_FC] =
{
    { 0x7ebb466f, 0x7ebb466f, 0x7ebb466f, 0x7ebb466f, 0x7ea7f78f, 0x7e9382d1, 0x7e7dd6bd, 0x7e66e0d2, 0x7e4e8d7b, 0x7e34c7ef, 0x7e197a33, 0x7dfc8cf8, 0x7ddde792, 0x7dbd6fdd, 0x7d9b0a28, 0x7d76991c, 0x7d4ffdad, 0x7d2716f0, 0x7cfbc20e, 0x7ccdda1e, 0x7c9d380b, 0x7c69b277, 0x7c331d86, 0x7bf94ada, 0x7bbc094e, 0x7b7b24e1, 0x7b366687, 0x7aed93fd, 0x7aa06f93, 0x7a4eb80d, 0x79f82860, 0x799c7781, 0x793b5834, 0x78d478ce, 0x786782f6, 0x77f41b69, 0x7779e1be, 0x76f8701a, 0x766f5af7, 0x75de30d9, 0x75447a04, 0x74a1b83e, 0x73f5667e, 0x733ef8b2, 0x727ddb68, 0x71b17398, 0x70d91e64, 0x6ff430d6, 0x6f01f7a6, 0x6e01b71c, 0x6cf2aadd, 0x6bd405d3, 0x6aa4f217, 0x696490f9, 0x6811fafc, 0x66ac4000, 0x65326754, 0x63a36ffd, 0x61fe50cb, 0x6041f8ab, 0x5e6d4eb5, 0x5c7f3229, 0x5a767a36, 0x5851f538, 0x5610676b, 0x53b08886, 0x5131001c, 0x4e905faf, 0x4bcd1a02, 0x48e5763a, 0x45d77cf6, 0x42a0dcf4, 0x3f3ec32e, 0x3bada059, 0x37e8d1eb, 0x33ea1e16, 0x2fa8e4d8, 0x2b18cea1, 0x262787a8, 0x20b88fa1, 0x1a9cba80, 0x137e89ae, 0x0aaacee2, 0x0aaacee2, 0x0aaacee2, 0x0aaacee2, 0x0aaacee2, 0x0aaacee2, 0x0aaacee2 },
    { 0x7f3a8183, 0x7f3a8183, 0x7f2ead4b, 0x7f222259, 0x7f14d583, 0x7f06bae2, 0x7ef7c5d3, 0x7ee7e8ea, 0x7ed715da, 0x7ec53d71, 0x7eb24f85, 0x7e9e3ae1, 0x7e88ed39, 0x7e72530b, 0x7e5a579e, 0x7e40e4d6, 0x7e25e328, 0x7e093982, 0x7deacd2c, 0x7dca81a3, 0x7da8388e, 0x7d83d181, 0x7d5d29ef, 0x7d341cf8, 0x7d088340, 0x7cda32c0, 0x7ca8fe95, 0x7c74b6d6, 0x7c3d284a, 0x7c021c39, 0x7bc35824, 0x7b809d86, 0x7b39a97d, 0x7aee348f, 0x7a9df23f, 0x7a4890c5, 0x79edb8a4, 0x798d0c45, 0x7926278e, 0x78b89f77, 0x78440187, 0x77c7d362, 0x7743924f, 0x76b6b2a7, 0x76209f5b, 0x7580b96c, 0x74d65768, 0x7420c4e2, 0x735f420b, 0x7291032c, 0x71b53057, 0x70cae514, 0x6fd13038, 0x6ec713cd, 0x6dab8536, 0x6c7d6d73, 0x6b3ba9b9, 0x69e50c2b, 0x68785d07, 0x66f45c16, 0x6557c263, 0x63a14479, 0x61cf94cf, 0x5fe16688, 0x5dd57057, 0x5baa6f6a, 0x595f29ec, 0x56f270e8, 0x546320cc, 0x51b01fee, 0x4ed859b9, 0x4bdab532, 0x48b6048b, 0x4568ea9d, 0x41f1b1a9, 0x3e4e0bdb, 0x3a7ab142, 0x3672c53e, 0x322ed973, 0x2da33782, 0x28bcab08, 0x2359c59e, 0x1d3a3b6e, 0x15c8f78f, 0x0ad59d8d, 0x0ad59d8d, 0x0ad59d8d, 0x0ad59d8d, 0x0ad59d8d },
    { 0x7f6169cb, 0x7f6169cb, 0x7f57defe, 0x7f4dbf73, 0x7f4301e7, 0x7f379c78, 0x7f2b84a6, 0x7f1eaf3a, 0x7f111048, 0x7f029b14, 0x7ef3420b, 0x7ee2f6b4, 0x7ed1a99a, 0x7ebf4a40, 0x7eabc708, 0x7e970d26, 0x7e81087b, 0x7e69a38d, 0x7e50c75f, 0x7e365b5d, 0x7e1a4537, 0x7dfc68c2, 0x7ddca7d3, 0x7dbae216, 0x7d96f4e2, 0x7d70bb13, 0x7d480cca, 0x7d1cbf41, 0x7ceea488, 0x7cbd8b51, 0x7c893e9b, 0x7c518573, 0x7c1622a4, 0x7bd6d458, 0x7b9353c0, 0x7b4b54ae, 0x7afe8530, 0x7aac8d10, 0x7a550d69, 0x79f7a015, 0x7993d737, 0x79293c91, 0x78b75107, 0x783d8beb, 0x77bb5a68, 0x77301ed6, 0x769b3017, 0x75fbd8eb, 0x75515756, 0x749adc08, 0x73d789d5, 0x7306753c, 0x7226a41d, 0x71370d81, 0x703699a8, 0x6f242241, 0x6dfe72fd, 0x6cc44a73, 0x6b745b74, 0x6a0d4ed7, 0x688dc5cd, 0x66f45cc7, 0x653faef9, 0x636e5a7e, 0x617f04ff, 0x5f7060dd, 0x5d41329c, 0x5af0564c, 0x587cc486, 0x55e59655, 0x532a075b, 0x50497505, 0x4d43595c, 0x4a173fa1, 0x46c4b010, 0x434b0ef8, 0x3fa969d4, 0x3bde2949, 0x37e698f1, 0x33be287e, 0x2f5d2dc3, 0x2ab6aaf1, 0x25b3e5f6, 0x202a5a83, 0x19bf4b09, 0x11701842, 0x11701842, 0x11701842, 0x11701842 },
    { 0x7f7da104, 0x7f7da104, 0x7f75bfb5, 0x7f6d6274, 0x7f648169, 0x7f5b1431, 0x7f5111dd, 0x7f4670e0, 0x7f3b2709, 0x7f2f2971, 0x7f226c75, 0x7f14e3a0, 0x7f0681a3, 0x7ef7383b, 0x7ee6f825, 0x7ed5b10b, 0x7ec35165, 0x7eafc66c, 0x7e9afbfb, 0x7e84dc73, 0x7e6d509c, 0x7e543f86, 0x7e398e64, 0x7e1d2062, 0x7dfed67c, 0x7dde8f51, 0x7dbc26f0, 0x7d97769b, 0x7d705491, 0x7d4693c9, 0x7d1a03b1, 0x7cea6fd5, 0x7cb79f94, 0x7c8155c7, 0x7c475050, 0x7c0947c7, 0x7bc6eeee, 0x7b7ff248, 0x7b33f78a, 0x7ae29d14, 0x7a8b7954, 0x7a2e1a2a, 0x79ca0439, 0x795eb23c, 0x78eb944a, 0x78700f15, 0x77eb7b2c, 0x775d2433, 0x76c4482b, 0x762016ab, 0x756fb043, 0x74b225dc, 0x73e6783b, 0x730b97bd, 0x7220642c, 0x7123acf0, 0x7014317d, 0x6ef0a248, 0x6db7a20d, 0x6c67c7cb, 0x6affa156, 0x697db69c, 0x67e08dc2, 0x6626b01a, 0x644eafdb, 0x62572ece, 0x603ee57b, 0x5e04aafe, 0x5ba77ce1, 0x592686c3, 0x568128db, 0x53b6fcd2, 0x50c7d78f, 0x4db3c6ce, 0x4a7b0894, 0x471dfa79, 0x439cfdbf, 0x3ff84c11, 0x3c2fb6b7, 0x384245be, 0x342da44a, 0x2fed3590, 0x2b7884e6, 0x26c05ba8, 0x21a898a4, 0x1bf8a7e1, 0x15274a9e, 0x15274a9e, 0x15274a9e },
    { 0x7f93a2b0, 0x7f93a2b0, 0x7f8d0dc6, 0x7f86105c, 0x7f7ea3b7, 0x7f76c0a3, 0x7f6e5f6d, 0x7f6577d8, 0x7f5c0115, 0x7f51f1b0, 0x7f473f91, 0x7f3bdfde, 0x7f2fc6fa, 0x7f22e86c, 0x7f1536d3, 0x7f06a3cf, 0x7ef71feb, 0x7ee69a8e, 0x7ed501db, 0x7ec24294, 0x7eae4802, 0x7e98fbd4, 0x7e8245f5, 0x7e6a0c6d, 0x7e503333, 0x7e349bff, 0x7e172613, 0x7df7ae0a, 0x7dd60d9a, 0x7db21b4e, 0x7d8baa41, 0x7d6289c9, 0x7d36852d, 0x7d07633c, 0x7cd4e5eb, 0x7c9ec9e7, 0x7c64c61b, 0x7c268b32, 0x7be3c306, 0x7b9c100f, 0x7b4f0cbd, 0x7afc4ad1, 0x7aa3529d, 0x7a43a250, 0x79dcad21, 0x796dda81, 0x78f68542, 0x7875fabd, 0x77eb79f0, 0x775632b1, 0x76b544d9, 0x7607bf96, 0x754ca0c0, 0x7482d46f, 0x73a934b9, 0x72be89b5, 0x71c189d9, 0x70b0dac8, 0x6f8b129d, 0x6e4eb9e0, 0x6cfa4e2d, 0x6b8c45af, 0x6a03138e, 0x685d2d5a, 0x6699117f, 0x64b54ed3, 0x62b08d14, 0x60899651, 0x5e3f60c6, 0x5bd1190b, 0x593e2bbe, 0x56864e2b, 0x53a984c3, 0x50a82680, 0x4d82db94, 0x4a3a9616, 0x46d0828f, 0x4345ee35, 0x3f9c1fed, 0x3bd41fa2, 0x37ee6513, 0x33ea61f2, 0x2fc5cfda, 0x2b7b9215, 0x2701bf1f, 0x2245c3dc, 0x1d23897b, 0x174c1540, 0x174c1540 },
    { 0x7faa8d3c, 0x7fa55772, 0x7f9fce51, 0x7f99ec65, 0x7f93abdb, 0x7f8d0674, 0x7f85f581, 0x7f7e71d5, 0x7f7673bf, 0x7f6df2ff, 0x7f64e6b8, 0x7f5b4566, 0x7f5104cc, 0x7f4619ea, 0x7f3a78e7, 0x7f2e1502, 0x7f20e07c, 0x7f12cc82, 0x7f03c91b, 0x7ef3c4fe, 0x7ee2ad8a, 0x7ed06e97, 0x7ebcf254, 0x7ea8212a, 0x7e91e189, 0x7e7a17c1, 0x7e60a5c5, 0x7e456b02, 0x7e284416, 0x7e090a91, 0x7de794b2, 0x7dc3b50c, 0x7d9d3a3b, 0x7d73ee7a, 0x7d47973f, 0x7d17f4cc, 0x7ce4c1b2, 0x7cadb243, 0x7c727412, 0x7c32ad42, 0x7bedfbf0, 0x7ba3f56f, 0x7b542590, 0x7afe0dcf, 0x7aa12484, 0x7a3cd3f0, 0x79d07969, 0x795b6453, 0x78dcd541, 0x7853fcf4, 0x77bffb84, 0x771fdf7d, 0x7672a526, 0x75b735ec, 0x74ec67fd, 0x7410fe2d, 0x7323a82d, 0x72230340, 0x710d9b70, 0x6fe1ed6b, 0x6e9e6932, 0x6d41759b, 0x6bc974f2, 0x6a34ca99, 0x6881e1fa, 0x66af36a9, 0x64bb5dbb, 0x62a51048, 0x606b36c1, 0x5e0cf4df, 0x5b89b59a, 0x58e13672, 0x56139154, 0x532143db, 0x500b32ed, 0x4cd2a936, 0x49794f3a, 0x46011b47, 0x426c37aa, 0x3ebcdd2c, 0x3af51eff, 0x3716a3e0, 0x332244c6, 0x2f17828a, 0x2af3b49f, 0x26b0b02c, 0x22424d7d, 0x1d912d1f, 0x1d912d1f },
    { 0x7fb839e1, 0x7fb3d32f, 0x7faf2553, 0x7faa2b92, 0x7fa4e0d5, 0x7f9f3fa8, 0x7f994231, 0x7f92e226, 0x7f8c18c4, 0x7f84dec5, 0x7f7d2c55, 0x7f74f907, 0x7f6c3bc7, 0x7f62eac8, 0x7f58fb7a, 0x7f4e6274, 0x7f431362, 0x7f3700ef, 0x7f2a1cb0, 0x7f1c5708, 0x7f0d9f0b, 0x7efde261, 0x7eed0d25, 0x7edb09bb, 0x7ec7c0ab, 0x7eb31872, 0x7e9cf54d, 0x7e853907, 0x7e6bc2b9, 0x7e506e89, 0x7e33155f, 0x7e138c98, 0x7df1a5a8, 0x7dcd2dc2, 0x7da5ed67, 0x7d7ba7f5, 0x7d4e1b29, 0x7d1cfe97, 0x7ce80313, 0x7caed210, 0x7c710cf1, 0x7c2e4c4f, 0x7be61f2d, 0x7b980a23, 0x7b43867c, 0x7ae80144, 0x7a84da4d, 0x7a196334, 0x79a4de57, 0x79267dd1, 0x789d6277, 0x78089aef, 0x776722ce, 0x76b7e1e5, 0x75f9abbf, 0x752b3f60, 0x744b4761, 0x73585a7e, 0x7250fcab, 0x7133a0e7, 0x6ffeabc6, 0x6eb07703, 0x6d47561a, 0x6bc19c21, 0x6a1da2ec, 0x6859d390, 0x6674b054, 0x646cdff2, 0x624139f9, 0x5ff0d403, 0x5d7b0f50, 0x5adfa61e, 0x581eb7d9, 0x5538d35c, 0x522efddc, 0x4f02b579, 0x4bb5ee15, 0x484b073e, 0x44c4b9d3, 0x4125fc8a, 0x3d71ddef, 0x39ab5281, 0x35d4f4a1, 0x31f0b1e2, 0x2dff5ccf, 0x2a001103, 0x25ef4246, 0x21c51d73, 0x1d725a1a },
    { 0x7fc3854a, 0x7fbfc9c8, 0x7fbbd133, 0x7fb79765, 0x7fb317e7, 0x7fae4def, 0x7fa93451, 0x7fa3c580, 0x7f9dfb7f, 0x7f97cfdb, 0x7f913b9c, 0x7f8a373d, 0x7f82baa1, 0x7f7abcfe, 0x7f7234d6, 0x7f6917e0, 0x7f5f5af8, 0x7f54f208, 0x7f49cff6, 0x7f3de686, 0x7f312643, 0x7f237e5a, 0x7f14dc81, 0x7f052ccd, 0x7ef45987, 0x7ee24b06, 0x7ecee775, 0x7eba12a8, 0x7ea3adcf, 0x7e8b9747, 0x7e71aa3e, 0x7e55be73, 0x7e37a7d3, 0x7e173619, 0x7df4346a, 0x7dce68d6, 0x7da593e2, 0x7d796ff6, 0x7d49b0c7, 0x7d1602b4, 0x7cde0a0e, 0x7ca1625a, 0x7c5f9d83, 0x7c1842f7, 0x7bcacebd, 0x7b76b07e, 0x7b1b4a7b, 0x7ab7f07f, 0x7a4be6cb, 0x79d660fb, 0x795680f7, 0x78cb55e3, 0x7833db38, 0x778ef7e3, 0x76db7daf, 0x761828e6, 0x7543a043, 0x745c7567, 0x736125d1, 0x72501c86, 0x7127b496, 0x6fe63c91, 0x6e89fb28, 0x6d1134ff, 0x6b7a340d, 0x69c35048, 0x67eafa01, 0x65efc5a4, 0x63d078d9, 0x618c18b3, 0x5f21f87c, 0x5c91c885, 0x59dba433, 0x57001e59, 0x54004a9f, 0x50ddc30c, 0x4d9aa823, 0x4a399ab2, 0x46bdae2e, 0x432a52e1, 0x3f83375e, 0x3bcc20ef, 0x3808ba85, 0x343c5962, 0x3069b54f, 0x2c928f48, 0x28b73b99, 0x24d5f78a, 0x20e9d5ff },
    { 0x7fcce827, 0x7fc9bb01, 0x7fc65930, 0x7fc2bf08, 0x7fbee89a, 0x7fbad1a7, 0x7fb67598, 0x7fb1cf7d, 0x7facda00, 0x7fa78f5b, 0x7fa1e950, 0x7f9be11e, 0x7f956f75, 0x7f8e8c66, 0x7f872f58, 0x7f7f4ef4, 0x7f76e114, 0x7f6ddab2, 0x7f642fce, 0x7f59d356, 0x7f4eb70e, 0x7f42cb6f, 0x7f35ff8b, 0x7f2840e0, 0x7f197b38, 0x7f09987b, 0x7ef8807b, 0x7ee618be, 0x7ed24446, 0x7ebce34c, 0x7ea5d2f6, 0x7e8ced09, 0x7e720791, 0x7e54f47b, 0x7e35812f, 0x7e137615, 0x7dee961a, 0x7dc69e1e, 0x7d9b445c, 0x7d6c37bf, 0x7d391f32, 0x7d0198d1, 0x7cc5391e, 0x7c838a17, 0x7c3c0a41, 0x7bee2bac, 0x7b9952dc, 0x7b3cd5b2, 0x7ad7fa4a, 0x7a69f5cf, 0x79f1eb58, 0x796eead1, 0x78dfefe8, 0x7843e126, 0x77998f3a, 0x76dfb477, 0x7614f4ac, 0x7537dd80, 0x7446e739, 0x7340765c, 0x7222de0a, 0x70ec635f, 0x6f9b4209, 0x6e2db21d, 0x6ca1ef73, 0x6af6428f, 0x69290b1f, 0x6738cc30, 0x652439c6, 0x62ea47c0, 0x608a398b, 0x5e03b219, 0x5b56c349, 0x5883fbda, 0x558c72cf, 0x5271cf04, 0x4f3649d9, 0x4bdcabb6, 0x4868417d, 0x44dcca5a, 0x413e5d7f, 0x3d914802, 0x39d9e335, 0x361c63f7, 0x325ca340, 0x2e9ddf39, 0x2ae27242, 0x272b7951, 0x23785afd },
    { 0x7fd4bcff, 0x7fd206b2, 0x7fcf22be, 0x7fcc0de3, 0x7fc8c49f, 0x7fc54329, 0x7fc18569, 0x7fbd86f1, 0x7fb942f5, 0x7fb4b443, 0x7fafd53a, 0x7faa9fbb, 0x7fa50d24, 0x7f9f163e, 0x7f98b330, 0x7f91db6e, 0x7f8a85ab, 0x7f82a7c3, 0x7f7a36a4, 0x7f71263a, 0x7f676950, 0x7f5cf179, 0x7f51aee8, 0x7f459054, 0x7f3882cb, 0x7f2a7187, 0x7f1b45c0, 0x7f0ae674, 0x7ef9382b, 0x7ee61cb8, 0x7ed172ed, 0x7ebb164d, 0x7ea2deb1, 0x7e889fec, 0x7e6c2957, 0x7e4d4560, 0x7e2bb908, 0x7e074354, 0x7ddf9cae, 0x7db4763e, 0x7d857932, 0x7d5245f2, 0x7d1a7349, 0x7cdd8d7a, 0x7c9b1549, 0x7c527ef1, 0x7c033109, 0x7bac835e, 0x7b4dbdd2, 0x7ae61711, 0x7a74b372, 0x79f8a3bd, 0x7970e411, 0x78dc5ae9, 0x7839d842, 0x77881509, 0x76c5b2dd, 0x75f13c3f, 0x7509254d, 0x740bcd34, 0x72f78079, 0x71ca7c44, 0x7082f2db, 0x6f1f1176, 0x6d9d0790, 0x6bfb0fed, 0x6a377b3a, 0x6850bc7d, 0x6645770b, 0x64148df9, 0x61bd3478, 0x5f3efe9a, 0x5c99f1e0, 0x59ce9460, 0x56ddf9a4, 0x53c9cbef, 0x509450bf, 0x4d406758, 0x49d1807a, 0x464b8e94, 0x42b2ee35, 0x3f0c4716, 0x3b5c6658, 0x37a81308, 0x33f3de13, 0x3043eec5, 0x2c9bcbe4, 0x28fe206f, 0x256c77e6 },
    { 0x7fdb4a34, 0x7fd8f760, 0x7fd67cc5, 0x7fd3d77e, 0x7fd10466, 0x7fce0016, 0x7fcac6df, 0x7fc754c3, 0x7fc3a569, 0x7fbfb41c, 0x7fbb7bbd, 0x7fb6f6b7, 0x7fb21efb, 0x7facedea, 0x7fa75c4f, 0x7fa1624b, 0x7f9af745, 0x7f9411d8, 0x7f8ca7bd, 0x7f84adb3, 0x7f7c1767, 0x7f72d756, 0x7f68deae, 0x7f5e1d2a, 0x7f5280ea, 0x7f45f64b, 0x7f3867b3, 0x7f29bd5e, 0x7f19dd22, 0x7f08aa2e, 0x7ef604c0, 0x7ee1c9da, 0x7ecbd2e2, 0x7eb3f544, 0x7e9a020a, 0x7e7dc55b, 0x7e5f0606, 0x7e3d84e5, 0x7e18fc4a, 0x7df11f4e, 0x7dc59917, 0x7d960c0d, 0x7d6210fb, 0x7d29362a, 0x7ceafe57, 0x7ca6dfac, 0x7c5c429f, 0x7c0a80c0, 0x7bb0e38d, 0x7b4ea327, 0x7ae2e512, 0x7a6cbb02, 0x79eb21a7, 0x795cff99, 0x78c12472, 0x7816482c, 0x775b0ab7, 0x768df41f, 0x75ad7523, 0x74b7e894, 0x73ab957d, 0x7286b251, 0x7147695b, 0x6febde78, 0x6e72366f, 0x6cd89fee, 0x6b1d5e49, 0x693ed60a, 0x673b9b3c, 0x6512812b, 0x62c2ab45, 0x604b9e91, 0x5dad5307, 0x5ae843b3, 0x57fd7cbe, 0x54eea5ff, 0x51be08f5, 0x4e6e90dd, 0x4b03c417, 0x4781b613, 0x43ecf1a2, 0x404a5bed, 0x3c9f10f8, 0x38f03acf, 0x3542e51c, 0x319bceae, 0x2dff3a6b, 0x2a70c076, 0x26f31efe },
    { 0x7fe0c7d8, 0x7fdec869, 0x7fdca623, 0x7fda5e6b, 0x7fd7ee6a, 0x7fd5530d, 0x7fd288fc, 0x7fcf8c96, 0x7fcc59e6, 0x7fc8ec9e, 0x7fc5400d, 0x7fc14f13, 0x7fbd141a, 0x7fb88908, 0x7fb3a72e, 0x7fae6740, 0x7fa8c13d, 0x7fa2ac62, 0x7f9c1f11, 0x7f950ebf, 0x7f8d6fd5, 0x7f853598, 0x7f7c5208, 0x7f72b5bd, 0x7f684fc1, 0x7f5d0d66, 0x7f50da12, 0x7f439f10, 0x7f354351, 0x7f25ab2d, 0x7f14b819, 0x7f02485b, 0x7eee36ab, 0x7ed859d7, 0x7ec08458, 0x7ea683d2, 0x7e8a209c, 0x7e6b1d29, 0x7e49356c, 0x7e241e2c, 0x7dfb8443, 0x7dcf0bd6, 0x7d9e4f73, 0x7d68df1f, 0x7d2e3f59, 0x7cede801, 0x7ca74330, 0x7c59ac12, 0x7c046d98, 0x7ba6c134, 0x7b3fcd8f, 0x7acea543, 0x7a524595, 0x79c99560, 0x79336415, 0x788e68f8, 0x77d942bc, 0x7712777a, 0x7638753d, 0x75499341, 0x74441400, 0x73262852, 0x71edf3bd, 0x70999227, 0x6f271f12, 0x6d94bea9, 0x6be0a885, 0x6a093455, 0x680ce85d, 0x65ea896f, 0x63a12c42, 0x6130475f, 0x5e97c51c, 0x5bd8148e, 0x58f23872, 0x55e7d2d8, 0x52bb2c2d, 0x4f6f34a3, 0x4c077ecf, 0x488832f8, 0x44f5faab, 0x4155e518, 0x3dad44df, 0x3a0188d5, 0x3658114f, 0x32b60416, 0x2f2020c5, 0x2b9a9736, 0x2828e0cf },
    { 0x7fe56357, 0x7fe3a9e9, 0x7fe1d1c9, 0x7fdfd89a, 0x7fddbbc9, 0x7fdb7887, 0x7fd90bc8, 0x7fd67237, 0x7fd3a834, 0x7fd0a9c7, 0x7fcd729c, 0x7fc9fdf7, 0x7fc646a7, 0x7fc24700, 0x7fbdf8c9, 0x7fb9552d, 0x7fb454ae, 0x7faeef11, 0x7fa91b48, 0x7fa2cf5e, 0x7f9c005e, 0x7f94a235, 0x7f8ca795, 0x7f8401d2, 0x7f7aa0bb, 0x7f707271, 0x7f656335, 0x7f595d36, 0x7f4c4856, 0x7f3e09e9, 0x7f2e846e, 0x7f1d973b, 0x7f0b1e2e, 0x7ef6f13f, 0x7ee0e41f, 0x7ec8c5ba, 0x7eae5fb9, 0x7e9175e9, 0x7e71c5a5, 0x7e4f0526, 0x7e28e2bf, 0x7dff0415, 0x7dd1053a, 0x7d9e77bb, 0x7d66e199, 0x7d29bc35, 0x7ce67321, 0x7c9c62e9, 0x7c4ad7d1, 0x7bf10c7d, 0x7b8e28a1, 0x7b213fac, 0x7aa94f85, 0x7a253f50, 0x7993de76, 0x78f3e3c7, 0x7843ecfc, 0x77827eaa, 0x76ae04a8, 0x75c4d340, 0x74c52928, 0x73ad3282, 0x727b0d1b, 0x712cce0a, 0x6fc088ea, 0x6e3458ca, 0x6c866b0f, 0x6ab50c19, 0x68beb5ec, 0x66a2205d, 0x645e52ad, 0x61f2b5ea, 0x5f5f2757, 0x5ca40a08, 0x59c25688, 0x56bba74b, 0x539240bc, 0x50491385, 0x4ce3b851, 0x4966640b, 0x45d5d47d, 0x423735a4, 0x3e900064, 0x3ae5d428, 0x373e4d29, 0x339ed976, 0x300c8eda, 0x2c8c038a, 0x29212b03 },
    { 0x7fe941eb, 0x7fe7c34b, 0x7fe62976, 0x7fe47242, 0x7fe29b53, 0x7fe0a218, 0x7fde83c1, 0x7fdc3d3c, 0x7fd9cb2d, 0x7fd729e8, 0x7fd45566, 0x7fd1493e, 0x7fce0096, 0x7fca761f, 0x7fc6a3ff, 0x7fc283cc, 0x7fbe0e72, 0x7fb93c2a, 0x7fb4045f, 0x7fae5d9d, 0x7fa83d75, 0x7fa19865, 0x7f9a61b3, 0x7f928b52, 0x7f8a05b9, 0x7f80bfb7, 0x7f76a646, 0x7f6ba45a, 0x7f5fa29e, 0x7f52873e, 0x7f443597, 0x7f348dec, 0x7f236d0f, 0x7f10abf9, 0x7efc1f67, 0x7ee59758, 0x7eccde96, 0x7eb1ba1b, 0x7e93e873, 0x7e732113, 0x7e4f1394, 0x7e2766e4, 0x7dfbb865, 0x7dcb9af5, 0x7d9695e6, 0x7d5c23e7, 0x7d1bb1d0, 0x7cd49d69, 0x7c86341d, 0x7c2fb1a2, 0x7bd03e9b, 0x7b66ef41, 0x7af2c20d, 0x7a729e7d, 0x79e55403, 0x7949991f, 0x789e0ad1, 0x77e12c75, 0x7711681c, 0x762d0fa7, 0x75325ea2, 0x741f7d44, 0x72f28483, 0x71a983b1, 0x704287a5, 0x6ebba3a0, 0x6d12fc2b, 0x6b46d3ce, 0x695599ca, 0x673dfa72, 0x64fef0f3, 0x6297da11, 0x600886ea, 0x5d514f1c, 0x5a7320f1, 0x576f8e8b, 0x5448d6ab, 0x5101e7ca, 0x4d9e5ca7, 0x4a227160, 0x4692f0d9, 0x42f51abf, 0x3f4e82f1, 0x3ba4eba0, 0x37fe1c20, 0x345fb672, 0x30cf0dcf, 0x2d510037, 0x29e9d4d1 },
    { 0x7fec8253, 0x7feb3520, 0x7fe9cfa6, 0x7fe84fe8, 0x7fe6b3b9, 0x7fe4f8b7, 0x7fe31c49, 0x7fe11b94, 0x7fdef378, 0x7fdca085, 0x7fda1ef6, 0x7fd76aa8, 0x7fd47f0c, 0x7fd1571f, 0x7fcded5b, 0x7fca3baa, 0x7fc63b57, 0x7fc1e4fa, 0x7fbd3065, 0x7fb81491, 0x7fb28782, 0x7fac7e2b, 0x7fa5ec54, 0x7f9ec476, 0x7f96f793, 0x7f8e7511, 0x7f852a86, 0x7f7b0389, 0x7f6fe973, 0x7f63c325, 0x7f5674bb, 0x7f47df40, 0x7f37e054, 0x7f2651cb, 0x7f130945, 0x7efdd7af, 0x7ee688c7, 0x7ecce283, 0x7eb0a47a, 0x7e91872f, 0x7e6f3b4d, 0x7e4968e1, 0x7e1fae6b, 0x7df19fed, 0x7dbec5da, 0x7d869c03, 0x7d48905b, 0x7d0401bd, 0x7cb83e97, 0x7c64838f, 0x7c07fa20, 0x7ba1b737, 0x7b30b9d7, 0x7ab3e9d8, 0x7a2a16c0, 0x7991f6dc, 0x78ea26a1, 0x7831286c, 0x776564e2, 0x76852bdf, 0x758eb65b, 0x7480293a, 0x73579964, 0x7213114a, 0x70b097f7, 0x6f2e3a03, 0x6d8a1454, 0x6bc260f5, 0x69d585c0, 0x67c224eb, 0x65872efa, 0x6323f5a5, 0x60983f09, 0x5de4581b, 0x5b09255a, 0x58083084, 0x54e3b1f0, 0x519e9462, 0x4e3c722f, 0x4ac18b10, 0x4732b221, 0x4395347c, 0x3feeb90e, 0x3c451b2a, 0x389e4194, 0x34fff44d, 0x316fb356, 0x2df2908d, 0x2a8d0e8b },
    { 0x7fef3e18, 0x7fee1a75, 0x7fece101, 0x7feb8fe5, 0x7fea251c, 0x7fe89e6f, 0x7fe6f96e, 0x7fe5336f, 0x7fe34982, 0x7fe1386d, 0x7fdefca2, 0x7fdc9239, 0x7fd9f4e0, 0x7fd71fd5, 0x7fd40dd9, 0x7fd0b91f, 0x7fcd1b3f, 0x7fc92d23, 0x7fc4e6f4, 0x7fc04005, 0x7fbb2ebb, 0x7fb5a870, 0x7fafa156, 0x7fa90c57, 0x7fa1daee, 0x7f99fcfd, 0x7f91609f, 0x7f87f1f5, 0x7f7d9aed, 0x7f724300, 0x7f65ceea, 0x7f582061, 0x7f4915b4, 0x7f388972, 0x7f2651fa, 0x7f124102, 0x7efc2319, 0x7ee3bf10, 0x7ec8d55c, 0x7eab1f63, 0x7e8a4ec5, 0x7e660c7a, 0x7e3df7fd, 0x7e11a645, 0x7de0a0c4, 0x7daa6441, 0x7d6e5fa4, 0x7d2bf2b5, 0x7ce26cc4, 0x7c910b49, 0x7c36f87f, 0x7bd349f2, 0x7b64ff25, 0x7aeb0043, 0x7a641cef, 0x79cf0b56, 0x792a677d, 0x7874b300, 0x77ac5551, 0x76cf9caa, 0x75dcbfd5, 0x74d1e0f2, 0x73ad117e, 0x726c57c6, 0x710db5f1, 0x6f8f32e2, 0x6deee4f8, 0x6c2afee8, 0x6a41de6d, 0x68321cf0, 0x65faa194, 0x639ab459, 0x61121178, 0x5e60fc3d, 0x5b88500f, 0x58898e9b, 0x5566e9ae, 0x5223478d, 0x4ec240ac, 0x4b481609, 0x47b99fb0, 0x441c33c2, 0x407586b6, 0x3ccb861c, 0x39242feb, 0x35856852, 0x31f4d089, 0x2e77a0b4, 0x2b1286d9 }
};

// b2 min  0.043480612 max  0.999116025 range 22.978426231
//
COEFF CVoiceFilter::m_aB2[FILTER_PARMS_DIM_Q][FILTER_PARMS_DIM_FC] =
{   
    { 0x3ebe7626, 0x3ebe7626, 0x3ebe7626, 0x3ebe7626, 0x3eab8aa1, 0x3e97854f, 0x3e82562c, 0x3e6bec5b, 0x3e54361a, 0x3e3b20ae, 0x3e209866, 0x3e048882, 0x3de6db39, 0x3dc7799c, 0x3da64b93, 0x3d8337cb, 0x3d5e23ba, 0x3d36f379, 0x3d0d89d3, 0x3ce1c827, 0x3cb38e63, 0x3c82baff, 0x3c4f2ae0, 0x3c18b96d, 0x3bdf4064, 0x3ba297ee, 0x3b62968b, 0x3b1f1112, 0x3ad7daa6, 0x3a8cc4c5, 0x3a3d9f3e, 0x39ea3834, 0x39925c32, 0x3935d62d, 0x38d46f98, 0x386df075, 0x38021f72, 0x3790c206, 0x37199c9d, 0x369c72be, 0x36190740, 0x358f1c8b, 0x34fe74dc, 0x3466d294, 0x33c7f88f, 0x3321aa8b, 0x3273ad96, 0x31bdc889, 0x30ffc486, 0x30396d94, 0x2f6a9338, 0x2e930912, 0x2db2a793, 0x2cc94cb2, 0x2bd6dc9f, 0x2adb428b, 0x29d6714e, 0x28c8642a, 0x27b11f57, 0x2690b095, 0x25672f95, 0x2434be20, 0x22f98820, 0x21b5c336, 0x2069ae02, 0x1f158ed7, 0x1db9b1dc, 0x1c566646, 0x1aebfaa1, 0x197ab7ca, 0x1802da28, 0x168488c4, 0x14ffc94a, 0x13746fb3, 0x11e2079e, 0x1047b3cb, 0x0ea3fd72, 0x0cf487dc, 0x0b359075, 0x096107e6, 0x076cc67a, 0x054678ea, 0x02c862e7, 0x02c862e7, 0x02c862e7, 0x02c862e7, 0x02c862e7, 0x02c862e7, 0x02c862e7 },
    { 0x3f3d0b77, 0x3f3d0b77, 0x3f318694, 0x3f2554a1, 0x3f186ba1, 0x3f0ac0fd, 0x3efc498d, 0x3eecf98b, 0x3edcc486, 0x3ecb9d5d, 0x3eb9763c, 0x3ea64087, 0x3e91ecdd, 0x3e7c6b03, 0x3e65a9e6, 0x3e4d9786, 0x3e3420ec, 0x3e193229, 0x3dfcb643, 0x3dde9727, 0x3dbebdab, 0x3d9d116e, 0x3d7978e0, 0x3d53d92f, 0x3d2c1638, 0x3d021282, 0x3cd5af2c, 0x3ca6cbee, 0x3c754707, 0x3c40fd34, 0x3c09c9ad, 0x3bcf861e, 0x3b920a9b, 0x3b512da8, 0x3b0cc42e, 0x3ac4a183, 0x3a78976a, 0x3a28761c, 0x39d40c50, 0x397b2755, 0x391d9313, 0x38bb1a34, 0x38538643, 0x37e69fc4, 0x37742e70, 0x36fbf961, 0x367dc754, 0x35f95eec, 0x356e870c, 0x34dd0725, 0x3444a7aa, 0x33a53278, 0x32fe735e, 0x32503899, 0x319a5376, 0x30dc98e2, 0x3016e21a, 0x2f490d4a, 0x2e72fe3e, 0x2d949f0a, 0x2cade09b, 0x2bbebb4e, 0x2ac72f4d, 0x29c744d0, 0x28bf0c1a, 0x27ae9d24, 0x269616cf, 0x25759d89, 0x244d5931, 0x231d71f8, 0x21e60bff, 0x20a74136, 0x1f6118ec, 0x1e137c22, 0x1cbe252e, 0x1b608854, 0x19f9b13c, 0x18880dc4, 0x17091796, 0x1578bd9c, 0x13d045d2, 0x1203e8e8, 0x0ffcc2a0, 0x0d8481cc, 0x09c35cee, 0x09c35cee, 0x09c35cee, 0x09c35cee, 0x09c35cee },
    { 0x3f63f484, 0x3f63f484, 0x3f5ab931, 0x3f50f2d2, 0x3f46994f, 0x3f3ba41d, 0x3f300a33, 0x3f23c207, 0x3f16c188, 0x3f08fe0f, 0x3efa6c64, 0x3eeb00aa, 0x3edaae5d, 0x3ec9684c, 0x3eb72088, 0x3ea3c864, 0x3e8f5066, 0x3e79a840, 0x3e62bec1, 0x3e4a81d4, 0x3e30de6e, 0x3e15c085, 0x3df91305, 0x3ddabfca, 0x3dbaaf8a, 0x3d98c9d9, 0x3d74f50f, 0x3d4f1648, 0x3d271153, 0x3cfcc8ab, 0x3cd01d6e, 0x3ca0ef4e, 0x3c6f1c95, 0x3c3a820f, 0x3c02fb0f, 0x3bc86166, 0x3b8a8d62, 0x3b4955cd, 0x3b048ff0, 0x3abc0f97, 0x3a6fa71e, 0x3a1f2773, 0x39ca6037, 0x39711fc3, 0x39133352, 0x38b06719, 0x38488678, 0x37db5c24, 0x3768b267, 0x36f0535f, 0x3672094f, 0x35ed9ef4, 0x3562dfe9, 0x34d19916, 0x34399932, 0x339ab13f, 0x32f4b528, 0x32477c54, 0x3192e254, 0x30d6c789, 0x301311d4, 0x2f47ad3e, 0x2e748c93, 0x2d99a9f6, 0x2cb70741, 0x2bccae44, 0x2adab0c2, 0x29e12809, 0x28e0341b, 0x27d7fa34, 0x26c8a27f, 0x25b254c2, 0x24953398, 0x237155db, 0x2246bd71, 0x21154a82, 0x1fdca95d, 0x1e9c3828, 0x1d52df41, 0x1bfed284, 0x1a9d27af, 0x192915dd, 0x179a7055, 0x15e21bce, 0x13dfce54, 0x1135a2b0, 0x1135a2b0, 0x1135a2b0, 0x1135a2b0 },
    { 0x3f802c4d, 0x3f802c4d, 0x3f789a93, 0x3f70969d, 0x3f6819c2, 0x3f5f1cf4, 0x3f5598bf, 0x3f4b8541, 0x3f40da28, 0x3f358ea6, 0x3f299972, 0x3f1cf0ba, 0x3f0f8a20, 0x3f015ab3, 0x3ef256e5, 0x3ee27286, 0x3ed1a0b8, 0x3ebfd3e9, 0x3eacfdcc, 0x3e990f4b, 0x3e83f883, 0x3e6da8b5, 0x3e560e41, 0x3e3d1698, 0x3e22ae33, 0x3e06c08a, 0x3de9380a, 0x3dc9fe06, 0x3da8faaf, 0x3d86150c, 0x3d6132ef, 0x3d3a38e4, 0x3d110a32, 0x3ce588cf, 0x3cb7954f, 0x3c870eef, 0x3c53d37c, 0x3c1dbf5b, 0x3be4ad84, 0x3ba8777d, 0x3b68f562, 0x3b25fde8, 0x3adf6661, 0x3a9502cf, 0x3a46a5f2, 0x39f4215a, 0x399d4589, 0x3941e20f, 0x38e1c5ba, 0x387cbebf, 0x38129afc, 0x37a32838, 0x372e346e, 0x36b38e32, 0x3633050b, 0x35ac69ed, 0x351f8fb3, 0x348c4bb0, 0x33f27640, 0x3351eb71, 0x32aa8bac, 0x31fc3c66, 0x3146e8d1, 0x308a8290, 0x2fc70254, 0x2efc686e, 0x2e2abd32, 0x2d521134, 0x2c727d2f, 0x2b8c2198, 0x2a9f25a1, 0x29abb5a3, 0x28b2009b, 0x27b23494, 0x26ac7990, 0x25a0ea7b, 0x248f8b5e, 0x23783bb4, 0x225aa2ea, 0x213613b5, 0x20096000, 0x1ed29165, 0x1d8e6c27, 0x1c378009, 0x1ac42369, 0x19214197, 0x1720899b, 0x1720899b, 0x1720899b },
    { 0x3f962e69, 0x3f962e69, 0x3f8fe929, 0x3f894523, 0x3f823ccd, 0x3f7aca45, 0x3f72e758, 0x3f6a8d74, 0x3f61b5aa, 0x3f5858a3, 0x3f4e6e9f, 0x3f43ef6c, 0x3f38d261, 0x3f2d0e5b, 0x3f2099b0, 0x3f136a2c, 0x3f05750b, 0x3ef6aeee, 0x3ee70bd8, 0x3ed67f1f, 0x3ec4fb6d, 0x3eb272ad, 0x3e9ed609, 0x3e8a15e1, 0x3e7421be, 0x3e5ce84b, 0x3e44574a, 0x3e2a5b89, 0x3e0ee0dd, 0x3df1d212, 0x3dd318e5, 0x3db29df6, 0x3d9048c4, 0x3d6bffa0, 0x3d45a7a4, 0x3d1d24ab, 0x3cf2594b, 0x3cc526cf, 0x3c956d2c, 0x3c630b06, 0x3c2ddda8, 0x3bf5c105, 0x3bba8fbb, 0x3b7c231b, 0x3b3a5330, 0x3af4f6cc, 0x3aabe399, 0x3a5eee36, 0x3a0dea49, 0x39b8aab0, 0x395f01a2, 0x3900c0ea, 0x389dba1f, 0x3835bef0, 0x37c8a176, 0x37563490, 0x36de4c53, 0x3660be81, 0x35dd630d, 0x355414b1, 0x34c4b18e, 0x342f1bd5, 0x33933a7d, 0x32f0f9fd, 0x32484d01, 0x31992d22, 0x30e39b88, 0x3027a17a, 0x2f6550b7, 0x2e9cc3a9, 0x2dce1d34, 0x2cf9882f, 0x2c1f363e, 0x2b3f5e0a, 0x2a5a3881, 0x296ffcfa, 0x2880dbc7, 0x278cf6bf, 0x269456f9, 0x2596de6d, 0x2494335c, 0x238ba1b0, 0x227beaef, 0x2162f5da, 0x203d3c3d, 0x1f04a33d, 0x1dadc7f2, 0x1c2020c3, 0x1c2020c3 },
    { 0x3facd242, 0x3fa7e386, 0x3fa2aa1f, 0x3f9d21ac, 0x3f974588, 0x3f9110ca, 0x3f8a7e42, 0x3f83886f, 0x3f7c2983, 0x3f745b58, 0x3f6c1771, 0x3f6356ee, 0x3f5a128e, 0x3f5042a4, 0x3f45df15, 0x3f3adf50, 0x3f2f3a4a, 0x3f22e670, 0x3f15d9b1, 0x3f080960, 0x3ef96a43, 0x3ee9f07c, 0x3ed98f86, 0x3ec83a2e, 0x3eb5e28d, 0x3ea279f8, 0x3e8df0fe, 0x3e78375a, 0x3e613bf0, 0x3e48ecba, 0x3e2f36ca, 0x3e140637, 0x3df7461c, 0x3dd8e086, 0x3db8be71, 0x3d96c7be, 0x3d72e32d, 0x3d4cf64d, 0x3d24e583, 0x3cfa93f6, 0x3ccde398, 0x3c9eb518, 0x3c6ce7e8, 0x3c385a3d, 0x3c00e913, 0x3bc67032, 0x3b88ca3c, 0x3b47d0bd, 0x3b035c3c, 0x3abb4455, 0x3a6f5fe0, 0x3a1f850d, 0x39cb899c, 0x39734316, 0x3916870d, 0x38b52b68, 0x384f06c1, 0x37e3f0c9, 0x3773c2be, 0x36fe57ea, 0x36838e36, 0x360346c0, 0x357d6692, 0x34f1d749, 0x346087d9, 0x33c96d4a, 0x332c8377, 0x3289cdc6, 0x31e157bf, 0x31333597, 0x307f847b, 0x2fc66aa2, 0x2f0816ff, 0x2e44c088, 0x2d7ca4dd, 0x2cb00638, 0x2bdf2870, 0x2b0a4cc5, 0x2a31ac27, 0x29556f6c, 0x2875a4b3, 0x2792308b, 0x26aab8a3, 0x25be8391, 0x24cc4528, 0x23d1c4fa, 0x22cb33bf, 0x21b1bb02, 0x21b1bb02 },
    { 0x3fba7f26, 0x3fb65f8c, 0x3fb20179, 0x3fad6141, 0x3fa87afe, 0x3fa34a92, 0x3f9dcba1, 0x3f97f990, 0x3f91cf7f, 0x3f8b4844, 0x3f845e6b, 0x3f7d0c2f, 0x3f754b75, 0x3f6d15cc, 0x3f646460, 0x3f5b2ffd, 0x3f517106, 0x3f471f6c, 0x3f3c32b1, 0x3f30a1d8, 0x3f246366, 0x3f176d58, 0x3f09b51b, 0x3efb2f88, 0x3eebd0dd, 0x3edb8cae, 0x3eca55e8, 0x3eb81ec0, 0x3ea4d8b0, 0x3e90746c, 0x3e7ae1d8, 0x3e641006, 0x3e4bed22, 0x3e326677, 0x3e176859, 0x3dfade27, 0x3ddcb23b, 0x3dbccde7, 0x3d9b196e, 0x3d777bfc, 0x3d51db9c, 0x3d2a1d3e, 0x3d0024ab, 0x3cd3d488, 0x3ca50e54, 0x3c73b270, 0x3c3fa020, 0x3c08b597, 0x3bced007, 0x3b91cbb0, 0x3b5183f7, 0x3b0dd389, 0x3ac6947a, 0x3a7ba075, 0x3a2cd0f1, 0x39d9ff70, 0x398305c7, 0x3927be79, 0x38c80514, 0x3863b6a5, 0x37fab231, 0x378cd949, 0x371a109b, 0x36a240a3, 0x36255657, 0x35a343e8, 0x351c0181, 0x348f8e0e, 0x33fdeff5, 0x336735c2, 0x32cb76bd, 0x322ad352, 0x3185753e, 0x30db8f76, 0x302d5da7, 0x2f7b2336, 0x2ec529a2, 0x2e0bbe25, 0x2d4f2e67, 0x2c8fc3fd, 0x2bcdbe72, 0x2b094b48, 0x2a427b2f, 0x29793311, 0x28ad1653, 0x27dd6585, 0x2708c753, 0x262ce530, 0x2545a324 },
    { 0x3fc5cac1, 0x3fc25662, 0x3fbeada1, 0x3fbacd6a, 0x3fb6b277, 0x3fb25952, 0x3fadbe51, 0x3fa8dd97, 0x3fa3b307, 0x3f9e3a4d, 0x3f986ed3, 0x3f924bbc, 0x3f8bcbe7, 0x3f84e9e6, 0x3f7d9ffc, 0x3f75e816, 0x3f6dbbc8, 0x3f65144b, 0x3f5bea72, 0x3f5236aa, 0x3f47f0f2, 0x3f3d10d5, 0x3f318d65, 0x3f255d34, 0x3f18764e, 0x3f0ace34, 0x3efc59cf, 0x3eed0d71, 0x3edcdcc6, 0x3ecbbad4, 0x3eb999ec, 0x3ea66ba7, 0x3e9220da, 0x3e7ca993, 0x3e65f50d, 0x3e4df1a9, 0x3e348ce5, 0x3e19b359, 0x3dfd50a9, 0x3ddf4f85, 0x3dbf999c, 0x3d9e179f, 0x3d7ab134, 0x3d554cfa, 0x3d2dd084, 0x3d04205c, 0x3cd82005, 0x3ca9b1ff, 0x3c78b7d3, 0x3c45121d, 0x3c0ea0a3, 0x3bd54261, 0x3b98d5b2, 0x3b593867, 0x3b1647f8, 0x3acfe1bb, 0x3a85e315, 0x3a3829cc, 0x39e69455, 0x39910235, 0x3937546a, 0x38d96deb, 0x3877342e, 0x38108fbc, 0x37a56cdd, 0x3735bc40, 0x36c173bc, 0x36488f0d, 0x35cb109a, 0x3549022d, 0x34c275a8, 0x3437859b, 0x33a855b9, 0x33151318, 0x327df42b, 0x31e33869, 0x31452781, 0x30a41006, 0x3000457e, 0x2f5a1dac, 0x2eb1ecf2, 0x2e08019b, 0x2d5c9dbb, 0x2cafef34, 0x2c020509, 0x2b52c097, 0x2aa1bfe7, 0x29ee3b94, 0x2936cc73 },
    { 0x3fcf2dc9, 0x3fcc47ce, 0x3fc935da, 0x3fc5f555, 0x3fc2837e, 0x3fbedd6f, 0x3fbb0011, 0x3fb6e823, 0x3fb29232, 0x3fadfa98, 0x3fa91d77, 0x3fa3f6ba, 0x3f9e820f, 0x3f98bae2, 0x3f929c5d, 0x3f8c2163, 0x3f85448a, 0x3f7e001a, 0x3f764e06, 0x3f6e27ea, 0x3f658703, 0x3f5c642d, 0x3f52b7de, 0x3f487a1c, 0x3f3da27d, 0x3f32281f, 0x3f2601a0, 0x3f192519, 0x3f0b8819, 0x3efd1f9d, 0x3eede009, 0x3eddbd20, 0x3ecca9ff, 0x3eba9914, 0x3ea77c18, 0x3e934406, 0x3e7de114, 0x3e6742af, 0x3e4f576f, 0x3e360d13, 0x3e1b507d, 0x3dff0da7, 0x3de12fa4, 0x3dc1a099, 0x3da049bb, 0x3d7d134f, 0x3d57e4a8, 0x3d30a430, 0x3d073767, 0x3cdb82ef, 0x3cad6a99, 0x3c7cd174, 0x3c4999e5, 0x3c13a5bd, 0x3bdad664, 0x3b9f0cfa, 0x3b602a89, 0x3b1e1048, 0x3ad89fd3, 0x3a8fbb87, 0x3a4346db, 0x39f326c5, 0x399f4237, 0x394782a2, 0x38ebd487, 0x388c281d, 0x382871f6, 0x37c0abb9, 0x3754d4dc, 0x36e4f365, 0x3671149a, 0x35f94db7, 0x357dbc7b, 0x34fe879d, 0x347bdf12, 0x33f5fc06, 0x336d2099, 0x32e19728, 0x3253b126, 0x31c3c571, 0x31322dfd, 0x309f44d8, 0x300b6050, 0x2f76ce22, 0x2ee1cd72, 0x2e4c8708, 0x2db7031f, 0x2d211b1f, 0x2c8a645a },
    { 0x3fd702c5, 0x3fd493a9, 0x3fd1ff9b, 0x3fcf446b, 0x3fcc5fcb, 0x3fc94f46, 0x3fc61047, 0x3fc2a00e, 0x3fbefbb5, 0x3fbb2029, 0x3fb70a2a, 0x3fb2b646, 0x3fae20da, 0x3fa9460b, 0x3fa421c5, 0x3f9eafb9, 0x3f98eb57, 0x3f92cfcb, 0x3f8c57fb, 0x3f857e83, 0x3f7e3dad, 0x3f768f72, 0x3f6e6d74, 0x3f65d0f4, 0x3f5cb2d7, 0x3f530b98, 0x3f48d348, 0x3f3e0184, 0x3f328d76, 0x3f266dc7, 0x3f1998a0, 0x3f0c039e, 0x3efda3d2, 0x3eee6db4, 0x3ede551f, 0x3ecd4d4d, 0x3ebb48cc, 0x3ea8397b, 0x3e941080, 0x3e7ebe46, 0x3e683272, 0x3e505be3, 0x3e3728aa, 0x3e1c8606, 0x3e00605f, 0x3de2a34a, 0x3dc33983, 0x3da20cee, 0x3d7f06a1, 0x3d5a0ee0, 0x3d330d2d, 0x3d09e855, 0x3cde867a, 0x3cb0cd2f, 0x3c80a18f, 0x3c4de860, 0x3c18863a, 0x3be05fb9, 0x3ba559b2, 0x3b67597f, 0x3b264542, 0x3ae2044a, 0x3a9a7f71, 0x3a4fa195, 0x3a015818, 0x39af936e, 0x395a47b5, 0x39016d60, 0x38a501e3, 0x38450863, 0x37e18a72, 0x377a98b3, 0x37104b83, 0x36a2c37d, 0x363229e5, 0x35beb0da, 0x35489359, 0x34d014e8, 0x345580ee, 0x33d929a2, 0x335b667f, 0x32dc923e, 0x325d0837, 0x31dd2132, 0x315d2f7f, 0x30dd7a44, 0x305e37c9, 0x2fdf864b, 0x2f61627d },
    { 0x3fdd9018, 0x3fdb847a, 0x3fd959cc, 0x3fd70e39, 0x3fd49fcd, 0x3fd20c7a, 0x3fcf5211, 0x3fcc6e44, 0x3fc95ea0, 0x3fc6208f, 0x3fc2b154, 0x3fbf0e09, 0x3fbb339d, 0x3fb71ed1, 0x3fb2cc34, 0x3fae3825, 0x3fa95eca, 0x3fa43c13, 0x3f9ecbb1, 0x3f990917, 0x3f92ef75, 0x3f8c79b3, 0x3f85a270, 0x3f7e63fc, 0x3f76b852, 0x3f6e991b, 0x3f65ff9d, 0x3f5ce4c5, 0x3f534114, 0x3f490ca4, 0x3f3e3f1e, 0x3f32cfb6, 0x3f26b525, 0x3f19e5a3, 0x3f0c56e1, 0x3efdfe03, 0x3eeecf9c, 0x3edebfa7, 0x3ecdc17f, 0x3ebbc7da, 0x3ea8c4c9, 0x3e94a9aa, 0x3e7f6729, 0x3e68ed3a, 0x3e512b16, 0x3e380f3a, 0x3e1d8761, 0x3e018088, 0x3de3e6f1, 0x3dc4a623, 0x3da3a8f0, 0x3d80d983, 0x3d5c216a, 0x3d3569a6, 0x3d0c9abd, 0x3ce19cdd, 0x3cb457f8, 0x3c84b3e9, 0x3c5298a7, 0x3c1dee7e, 0x3be69e4f, 0x3bac91dc, 0x3b6fb420, 0x3b2ff1b4, 0x3aed393e, 0x3aa77bee, 0x3a5eae06, 0x3a12c76e, 0x39c3c453, 0x3971a5cb, 0x391c727d, 0x38c43747, 0x386907df, 0x380aff61, 0x37aa40c4, 0x3746f735, 0x36e15632, 0x3679997d, 0x361004bc, 0x35a4e2c7, 0x353884a1, 0x34cb3ffe, 0x345d6d6b, 0x33ef65fc, 0x3381808d, 0x33140e8f, 0x32a75852, 0x323b98b7, 0x31d0f817 },
    { 0x3fe30dd5, 0x3fe155a1, 0x3fdf834e, 0x3fdd9550, 0x3fdb8a03, 0x3fd95fac, 0x3fd71474, 0x3fd4a66b, 0x3fd21381, 0x3fcf5987, 0x3fcc7631, 0x3fc9670d, 0x3fc62984, 0x3fc2badb, 0x3fbf182c, 0x3fbb3e68, 0x3fb72a50, 0x3fb2d875, 0x3fae4537, 0x3fa96cbf, 0x3fa44afc, 0x3f9edba4, 0x3f991a2a, 0x3f9301c2, 0x3f8c8d57, 0x3f85b78d, 0x3f7e7ab5, 0x3f76d0d3, 0x3f6eb392, 0x3f661c42, 0x3f5d03d5, 0x3f5362d8, 0x3f49316e, 0x3f3e674d, 0x3f32fbb7, 0x3f26e578, 0x3f1a1adb, 0x3f0c91aa, 0x3efe3f25, 0x3eef1802, 0x3edf1060, 0x3ece1bca, 0x3ebc2d2e, 0x3ea936db, 0x3e952a7c, 0x3e7ff915, 0x3e699304, 0x3e51e7fe, 0x3e38e70f, 0x3e1e7ea0, 0x3e029c76, 0x3de52dbe, 0x3dc61f13, 0x3da55c8e, 0x3d82d1d5, 0x3d5e6a2f, 0x3d3810a4, 0x3d0fb017, 0x3ce53371, 0x3cb885d1, 0x3c8992be, 0x3c58466e, 0x3c248e0c, 0x3bee580e, 0x3bb59497, 0x3b7a35e0, 0x3b3c30b4, 0x3afb7ceb, 0x3ab81600, 0x3a71fb9a, 0x3a29322e, 0x39ddc393, 0x398fbf9c, 0x393f3ca1, 0x38ec57fc, 0x38973667, 0x38400438, 0x37e6f56b, 0x378c4579, 0x373036e4, 0x36d3127c, 0x3675264f, 0x3616c441, 0x35b84050, 0x3559ee80, 0x34fc207c, 0x349f22e1, 0x34433a51, 0x33e8a02a },
    { 0x3fe7a969, 0x3fe6373a, 0x3fe4af12, 0x3fe30fa2, 0x3fe1578c, 0x3fdf8558, 0x3fdd977b, 0x3fdb8c52, 0x3fd96222, 0x3fd71714, 0x3fd4a937, 0x3fd2167d, 0x3fcf5cb8, 0x3fcc799b, 0x3fc96ab4, 0x3fc62d6e, 0x3fc2bf0f, 0x3fbf1cb1, 0x3fbb4345, 0x3fb72f8e, 0x3fb2de1f, 0x3fae4b59, 0x3fa97365, 0x3fa45236, 0x3f9ee383, 0x3f9922c4, 0x3f930b2d, 0x3f8c97af, 0x3f85c2f1, 0x3f7e874b, 0x3f76dec5, 0x3f6ec313, 0x3f662d8d, 0x3f5d172e, 0x3f53788f, 0x3f4949e3, 0x3f3e82f0, 0x3f331b0b, 0x3f270916, 0x3f1a4379, 0x3f0cc01e, 0x3efe746c, 0x3eef5545, 0x3edf56fe, 0x3ece6d62, 0x3ebc8ba8, 0x3ea9a478, 0x3e95a9e4, 0x3e808d6c, 0x3e6a3ffc, 0x3e52b1f4, 0x3e39d327, 0x3e1f92e8, 0x3e03e010, 0x3de6a90d, 0x3dc7dbf5, 0x3da76699, 0x3d8536a2, 0x3d6139ae, 0x3d3b5d7b, 0x3d139014, 0x3ce9c005, 0x3cbddc9d, 0x3c8fd635, 0x3c5f9e82, 0x3c2d28f3, 0x3bf86b17, 0x3bc15d0e, 0x3b87fa08, 0x3b4c40c1, 0x3b0e340c, 0x3acddb64, 0x3a8b436b, 0x3a467e75, 0x39ffa4fc, 0x39b6d601, 0x396c374f, 0x391ff59f, 0x38d24484, 0x38835e23, 0x383382b1, 0x37e2f7a0, 0x37920691, 0x3740fbf4, 0x36f02565, 0x369fcfd2, 0x36504564, 0x3601cb44, 0x35b49f43 },
    { 0x3feb880e, 0x3fea50b1, 0x3fe906d7, 0x3fe7a967, 0x3fe63739, 0x3fe4af13, 0x3fe30fa6, 0x3fe15792, 0x3fdf8561, 0x3fdd9788, 0x3fdb8c65, 0x3fd9623a, 0x3fd71734, 0x3fd4a960, 0x3fd216b1, 0x3fcf5cf9, 0x3fcc79eb, 0x3fc96b17, 0x3fc62de9, 0x3fc2bfa5, 0x3fbf1d67, 0x3fbb4422, 0x3fb7309a, 0x3fb2df62, 0x3fae4cde, 0x3fa9753a, 0x3fa4546a, 0x3f9ee628, 0x3f9925ef, 0x3f930ef8, 0x3f8c9c39, 0x3f85c85e, 0x3f7e8dc7, 0x3f76e683, 0x3f6ecc4f, 0x3f663890, 0x3f5d244f, 0x3f538834, 0x3f495c85, 0x3f3e991e, 0x3f333571, 0x3f27287f, 0x3f1a68d6, 0x3f0cec8b, 0x3efea93c, 0x3eef9408, 0x3edfa18f, 0x3ecec5f1, 0x3ebcf4cf, 0x3eaa2149, 0x3e963e00, 0x3e813d1c, 0x3e6b1052, 0x3e53a8e9, 0x3e3af7c6, 0x3e20ed7d, 0x3e057a5d, 0x3de88e8b, 0x3dca1a1b, 0x3daa0d31, 0x3d885823, 0x3d64ebb1, 0x3d3fb92e, 0x3d18b2c6, 0x3cefcbc1, 0x3cc4f8d0, 0x3c98306c, 0x3c696b31, 0x3c38a44d, 0x3c05d9f1, 0x3bd10dc8, 0x3b9a4575, 0x3b618b0a, 0x3b26ed86, 0x3aea813c, 0x3aac6035, 0x3a6caa78, 0x3a2b862b, 0x39e91fa0, 0x39a5a91e, 0x39615a84, 0x391c70ac, 0x38d72c91, 0x3891d239, 0x384ca765, 0x3807f20a, 0x37c3f6a9, 0x3780f686, 0x373f2dce },
    { 0x3feec885, 0x3fedc297, 0x3fecad1c, 0x3feb8726, 0x3fea4fbc, 0x3fe905d5, 0x3fe7a858, 0x3fe6361c, 0x3fe4ade7, 0x3fe30e6b, 0x3fe15648, 0x3fdf8408, 0x3fdd9620, 0x3fdb8aed, 0x3fd960b3, 0x3fd7159e, 0x3fd4a7bc, 0x3fd21500, 0x3fcf5b3d, 0x3fcc7825, 0x3fc9694a, 0x3fc62c18, 0x3fc2bdd4, 0x3fbf1b9d, 0x3fbb4265, 0x3fb72ef2, 0x3fb2ddda, 0x3fae4b81, 0x3fa97418, 0x3fa45395, 0x3f9ee5b7, 0x3f9925fd, 0x3f930fa6, 0x3f8c9dae, 0x3f85cac9, 0x3f7e9160, 0x3f76eb90, 0x3f6ed320, 0x3f664186, 0x3f5d2fde, 0x3f5396e6, 0x3f496f00, 0x3f3eb026, 0x3f3351f0, 0x3f274b8b, 0x3f1a93ba, 0x3f0d20d0, 0x3efee8b4, 0x3eefe0db, 0x3edffe4e, 0x3ecf35a4, 0x3ebd7b0e, 0x3eaac251, 0x3e96fed7, 0x3e8223ad, 0x3e6c239a, 0x3e54f122, 0x3e3c7e9f, 0x3e22be56, 0x3e07a292, 0x3deb1dc2, 0x3dcd22a2, 0x3dada467, 0x3d8c96f1, 0x3d69ef0b, 0x3d45a2a8, 0x3d1fa935, 0x3cf7fbea, 0x3cce9625, 0x3ca375cf, 0x3c769bc5, 0x3c480c41, 0x3c17cf4c, 0x3be5f125, 0x3bb282a5, 0x3b7d9997, 0x3b4750fd, 0x3b0fc93c, 0x3ad72824, 0x3a9d98db, 0x3a634b8e, 0x3a2874fd, 0x39ed4dca, 0x39b2119a, 0x3976fdfe, 0x393c5136, 0x390248cf, 0x38c9202e, 0x38910f0a },
    { 0x3ff18456, 0x3ff0a7fb, 0x3fefbe88, 0x3feec739, 0x3fedc139, 0x3fecabaa, 0x3feb85a0, 0x3fea4e20, 0x3fe90423, 0x3fe7a68e, 0x3fe6343a, 0x3fe4abec, 0x3fe30c56, 0x3fe15419, 0x3fdf81be, 0x3fdd93ba, 0x3fdb886a, 0x3fd95e15, 0x3fd712e3, 0x3fd4a4e6, 0x3fd21210, 0x3fcf5834, 0x3fcc7506, 0x3fc96618, 0x3fc628d7, 0x3fc2ba8a, 0x3fbf1850, 0x3fbb3f1f, 0x3fb72bbd, 0x3fb2dac4, 0x3fae489b, 0x3fa97177, 0x3fa45152, 0x3f9ee3f0, 0x3f9924d8, 0x3f930f51, 0x3f8c9e5e, 0x3f85ccc0, 0x3f7e94ed, 0x3f76f111, 0x3f6edb07, 0x3f664c5a, 0x3f5d3e41, 0x3f53a99a, 0x3f4986ea, 0x3f3ece59, 0x3f3377b4, 0x3f277a64, 0x3f1acd75, 0x3f0d6793, 0x3eff3f08, 0x3ef049c5, 0x3ee07d5d, 0x3ecfcf11, 0x3ebe33d4, 0x3eaba054, 0x3e980907, 0x3e836237, 0x3e6da01b, 0x3e56b6e6, 0x3e3e9ae4, 0x3e25409f, 0x3e0a9cff, 0x3deea575, 0x3dd15033, 0x3db29463, 0x3d926a62, 0x3d70cc12, 0x3d4db520, 0x3d29235d, 0x3d03171b, 0x3cdb9383, 0x3cb29eff, 0x3c884390, 0x3c5c8f2b, 0x3c2f9404, 0x3c0168d4, 0x3bd228fe, 0x3ba1f4a4, 0x3b70f096, 0x3b3f461c, 0x3b0d2296, 0x3adab6f0, 0x3aa836eb, 0x3a75d836, 0x3a43d167, 0x3a1258d3, 0x39e1a356, 0x39b1e30e }
};

// k  min  0.000038014 max  0.901921617 range 23725.941121027
COEFF CVoiceFilter::m_aK[FILTER_PARMS_DIM_Q][FILTER_PARMS_DIM_FC] =
{
    { 0x00032fb7, 0x00032fb7, 0x00032fb7, 0x00032fb7, 0x00039311, 0x0004027d, 0x00047f6f, 0x00050b89, 0x0005a89f, 0x000658bf, 0x00071e32, 0x0007fb8a, 0x0008f3a7, 0x000a09bf, 0x000b416a, 0x000c9eae, 0x000e260c, 0x000fdc89, 0x0011c7c5, 0x0013ee09, 0x00165657, 0x00190887, 0x001c0d5a, 0x001f6e92, 0x00233715, 0x0027730c, 0x002c3003, 0x00317d14, 0x00376b12, 0x003e0cb8, 0x004576de, 0x004dc0b3, 0x005703fd, 0x00615d5f, 0x006ceca2, 0x0079d50b, 0x00883db3, 0x009851ec, 0x00aa41a6, 0x00be41e5, 0x00d48d3b, 0x00ed644d, 0x01090e5d, 0x0127d9e1, 0x014a1d27, 0x017036f2, 0x019a8f31, 0x01c997b3, 0x01fdccdf, 0x0237b678, 0x0277e85a, 0x02bf033e, 0x030db57b, 0x0364bbb8, 0x03c4e1a3, 0x042f028a, 0x04a409f9, 0x0524f42d, 0x05b2ce8b, 0x064eb7ea, 0x06f9e0df, 0x07b58bf7, 0x08830de9, 0x0963cdfd, 0x0a594697, 0x0b650650, 0x0c88b1bf, 0x0dc60696, 0x0f1ee09f, 0x1095418f, 0x122b5d31, 0x13e3abd0, 0x15c1061b, 0x17c6cf5a, 0x19f935b3, 0x1c5d95b5, 0x1efb189a, 0x21dbb93a, 0x250e08cc, 0x28a87844, 0x2cd00bf9, 0x31c7ef3c, 0x381d9404, 0x381d9404, 0x381d9404, 0x381d9404, 0x381d9404, 0x381d9404, 0x381d9404 },
    { 0x0002542f, 0x0002542f, 0x00029cf4, 0x0002ee96, 0x00034a2a, 0x0003b0e4, 0x0004241e, 0x0004a55e, 0x00053655, 0x0005d8ec, 0x00068f45, 0x00075bc3, 0x00084113, 0x00094236, 0x000a6286, 0x000ba5c6, 0x000d102b, 0x000ea66b, 0x00106dcb, 0x00126c30, 0x0014a832, 0x00172933, 0x0019f772, 0x001d1c25, 0x0020a19b, 0x00249354, 0x0028fe2c, 0x002df07b, 0x00337a42, 0x0039ad5f, 0x00409dba, 0x00486185, 0x00511179, 0x005ac91c, 0x0065a70e, 0x0071cd5c, 0x007f61de, 0x008e8e97, 0x009f8226, 0x00b27037, 0x00c79204, 0x00df26dd, 0x00f974b5, 0x0116c8c2, 0x0137781e, 0x015be072, 0x018468a3, 0x01b18194, 0x01e3a6d3, 0x021b5f5b, 0x02593e48, 0x029de384, 0x02e9fc65, 0x033e443d, 0x039b84c3, 0x0402965f, 0x04746041, 0x04f1d845, 0x057c0283, 0x0613f09c, 0x06bac0a3, 0x07719b9f, 0x0839b3aa, 0x091441a3, 0x0a028282, 0x0b05b462, 0x0c1f1374, 0x0d4fd70b, 0x0e992f29, 0x0ffc430c, 0x117a318a, 0x13141429, 0x14cb0677, 0x16a033a0, 0x1894ed45, 0x1aaad042, 0x1ce3feeb, 0x1f437e0e, 0x21cdcdc6, 0x2489f176, 0x27835b3b, 0x2acde79e, 0x2e8f9163, 0x331f4566, 0x39b91572, 0x39b91572, 0x39b91572, 0x39b91572, 0x39b91572 },
    { 0x00022384, 0x00022384, 0x00026663, 0x0002b169, 0x00030596, 0x00036405, 0x0003cdf5, 0x000444cd, 0x0004ca1f, 0x00055faa, 0x00060769, 0x0006c38f, 0x00079695, 0x00088340, 0x00098cab, 0x000ab650, 0x000c0412, 0x000d7a4e, 0x000f1de6, 0x0010f44f, 0x001303a6, 0x001552c5, 0x0017e950, 0x001acfda, 0x001e0ff3, 0x0021b450, 0x0025c8e8, 0x002a5b15, 0x002f79c6, 0x003535a4, 0x003ba148, 0x0042d170, 0x004add3f, 0x0053de7b, 0x005df1db, 0x00693757, 0x0075d27f, 0x0083eada, 0x0093ac54, 0x00a547a9, 0x00b8f2e7, 0x00cee9ee, 0x00e76efe, 0x0102cb52, 0x01214fbc, 0x0143554f, 0x01693e0f, 0x019375a6, 0x01c27219, 0x01f6b483, 0x0230c9c4, 0x02714b30, 0x02b8df28, 0x0308399f, 0x03601c7d, 0x03c157dd, 0x042cca0f, 0x04a35f5a, 0x0526116e, 0x05b5e669, 0x0653ef7f, 0x0701470a, 0x07bf0e27, 0x088e69a9, 0x09707e87, 0x0a666dba, 0x0b714fa4, 0x0c922f32, 0x0dca04f5, 0x0f19b291, 0x1081ff0d, 0x120394aa, 0x139f013f, 0x1554ba3e, 0x17252608, 0x1910acce, 0x1b17d437, 0x1d3b6ad1, 0x1f7ccbeb, 0x21de4b5a, 0x2463e832, 0x27148a26, 0x29fc6fb2, 0x2d32a8ee, 0x30e86427, 0x35a83b0c, 0x35a83b0c, 0x35a83b0c, 0x35a83b0c },
    { 0x0001f6a7, 0x0001f6a7, 0x00023413, 0x000278fe, 0x0002c651, 0x00031d13, 0x00037e6a, 0x0003eb9e, 0x00046623, 0x0004ef95, 0x000589c5, 0x000636bd, 0x0006f8c2, 0x0007d264, 0x0008c67e, 0x0009d845, 0x000b0b52, 0x000c63aa, 0x000de5d0, 0x000f96d0, 0x00117c50, 0x00139ca4, 0x0015fee2, 0x0018aaf5, 0x001ba9bd, 0x001f0522, 0x0022c83c, 0x0026ff72, 0x002bb89c, 0x00310337, 0x0036f08a, 0x003d93e2, 0x004502c8, 0x004d553f, 0x0056a60e, 0x00611309, 0x006cbd67, 0x0079ca1f, 0x00886248, 0x0098b38e, 0x00aaf09e, 0x00bf51b0, 0x00d61509, 0x00ef7f8f, 0x010bdd68, 0x012b829b, 0x014ecbba, 0x01761e96, 0x01a1eaf1, 0x01d2ab36, 0x0208e526, 0x02452a86, 0x028819b8, 0x02d25e3b, 0x0324b116, 0x037fd911, 0x03e4aab8, 0x04540813, 0x04cee01b, 0x05562daf, 0x05eaf621, 0x068e4732, 0x07413475, 0x0804d401, 0x08da3a80, 0x09c2767d, 0x0abe8b23, 0x0bcf6a5f, 0x0cf5eec1, 0x0e32d541, 0x0f86b771, 0x10f20687, 0x12750809, 0x140fd4e9, 0x15c25c28, 0x178c6a51, 0x196db772, 0x1b65fdf1, 0x1d751d7e, 0x1f9b4fb7, 0x21d97821, 0x2431a24d, 0x26a7d611, 0x29439ec2, 0x2c133d10, 0x2f33a1a2, 0x32eafa0f, 0x32eafa0f, 0x32eafa0f },
    { 0x0001cd62, 0x0001cd62, 0x000205c8, 0x00024511, 0x00028c13, 0x0002dbc1, 0x00033528, 0x00039978, 0x00040a03, 0x00048849, 0x000515f3, 0x0005b4e2, 0x0006672e, 0x00072f32, 0x00080f90, 0x00090b3d, 0x000a258a, 0x000b622b, 0x000cc548, 0x000e538b, 0x0010122a, 0x001206fd, 0x0014388e, 0x0016ae2f, 0x00197011, 0x001c8761, 0x001ffe60, 0x0023e087, 0x00283aab, 0x002d1b23, 0x003291f3, 0x0038b103, 0x003f8c4d, 0x00473a20, 0x004fd35d, 0x005973c1, 0x00643a36, 0x00704928, 0x007dc6e5, 0x008cde06, 0x009dbde0, 0x00b09afa, 0x00c5af96, 0x00dd3c39, 0x00f78845, 0x0114e292, 0x0135a219, 0x015a269d, 0x0182d95d, 0x01b02dc3, 0x01e2a215, 0x021ac01a, 0x02591dba, 0x029e5d7e, 0x02eb2efa, 0x03404f0c, 0x039e87e9, 0x0406b0dc, 0x0479adc0, 0x04f86e02, 0x0583eb30, 0x061d2703, 0x06c528b0, 0x077cf9a2, 0x0845a162, 0x092020be, 0x0a0d6c42, 0x0b0e65ea, 0x0c23d66c, 0x0d4e6624, 0x0e8e961e, 0x0fe4b990, 0x1150f07a, 0x12d323fa, 0x146b054c, 0x1618103b, 0x17d99237, 0x19aeb752, 0x1b969e8f, 0x1d9077d2, 0x1f9baece, 0x21b828c2, 0x23e6a087, 0x26293843, 0x288475ad, 0x2b012cb7, 0x2db0da5d, 0x30ba095c, 0x30ba095c },
    { 0x0001794e, 0x0001a772, 0x0001db38, 0x00021552, 0x00025684, 0x00029fad, 0x0002f1c5, 0x00034de2, 0x0003b53e, 0x00042936, 0x0004ab54, 0x00053d51, 0x0005e11b, 0x000698dd, 0x00076703, 0x00084e46, 0x000951b2, 0x000a74b4, 0x000bbb1f, 0x000d293d, 0x000ec3de, 0x00109064, 0x001294d8, 0x0014d7fa, 0x0017615c, 0x001a3972, 0x001d69b9, 0x0020fcc8, 0x0024fe7c, 0x00297c17, 0x002e846b, 0x0034280b, 0x003a7977, 0x00418d59, 0x00497ac3, 0x00525b70, 0x005c4c10, 0x00676c9c, 0x0073e0b0, 0x0081cfe9, 0x00916654, 0x00a2d4e2, 0x00b651e1, 0x00cc1986, 0x00e46e7a, 0x00ff9a74, 0x011deed5, 0x013fc551, 0x01658096, 0x018f8cff, 0x01be6137, 0x01f27ee4, 0x022c7340, 0x026cd79c, 0x02b451d1, 0x03039482, 0x035b5f2e, 0x03bc7e07, 0x0427c96c, 0x049e250c, 0x05207e81, 0x05afcb75, 0x064d070b, 0x06f92eaa, 0x07b53dfd, 0x08822a20, 0x0960dc0f, 0x0a522a46, 0x0b56d1cf, 0x0c6f6ed3, 0x0d9c750d, 0x0ede287a, 0x103496c4, 0x119f9209, 0x131eadaa, 0x14b13ded, 0x16565b33, 0x180ce9ad, 0x19d3a65e, 0x1ba93a71, 0x1d8c561e, 0x1f7bd50e, 0x2176efb7, 0x237d8042, 0x259068ea, 0x27b239d6, 0x29e85e5e, 0x2c3d9358, 0x2c3d9358 },
    { 0x00015a3d, 0x00018496, 0x0001b41c, 0x0001e972, 0x0002254b, 0x00026875, 0x0002b3d2, 0x00030865, 0x0003674b, 0x0003d1c7, 0x00044942, 0x0004cf53, 0x000565bf, 0x00060e84, 0x0006cbde, 0x0007a04d, 0x00088ea1, 0x000999fe, 0x000ac5ea, 0x000c165a, 0x000d8fbb, 0x000f3703, 0x001111c1, 0x0013262e, 0x00157b44, 0x001818d1, 0x001b0792, 0x001e5150, 0x002200fc, 0x002622d5, 0x002ac48d, 0x002ff572, 0x0035c6a1, 0x003c4b37, 0x0043988c, 0x004bc673, 0x0054ef7e, 0x005f3151, 0x006aacf0, 0x0077871e, 0x0085e8c1, 0x0095ff52, 0x00a7fd50, 0x00bc1ac0, 0x00d295b6, 0x00ebb2e4, 0x0107be33, 0x01270b61, 0x0149f6a9, 0x0170e564, 0x019c46b1, 0x01cc941a, 0x02025227, 0x023e10e8, 0x02806c60, 0x02ca0cd5, 0x031ba6e8, 0x0375fb74, 0x03d9d725, 0x044811a5, 0x04c18c61, 0x054730be, 0x05d9edb8, 0x067ab4c8, 0x072a7611, 0x07ea1bbc, 0x08ba8480, 0x099c7d61, 0x0a90bac5, 0x0b97d0f4, 0x0cb22c5e, 0x0de009dd, 0x0f216f99, 0x107626d4, 0x11ddb782, 0x1357662a, 0x14e234cf, 0x167ce78f, 0x18260d90, 0x19dc0eb7, 0x1b9d3ebb, 0x1d67f61c, 0x1f3ab1d8, 0x21143bce, 0x22f3df6a, 0x24d9b2b0, 0x26c704ea, 0x28bf1ac3, 0x2ac89c1a },
    { 0x00013db4, 0x00016492, 0x00019030, 0x0001c124, 0x0001f813, 0x000235b8, 0x00027ae6, 0x0002c889, 0x00031fa7, 0x00038169, 0x0003ef1b, 0x00046a32, 0x0004f450, 0x00058f49, 0x00063d2b, 0x00070043, 0x0007db25, 0x0008d0b8, 0x0009e438, 0x000b1949, 0x000c73fe, 0x000df8e8, 0x000fad25, 0x00119671, 0x0013bb39, 0x001622ac, 0x0018d4d9, 0x001bdac6, 0x001f3e88, 0x00230b6c, 0x00274e14, 0x002c14a1, 0x00316edf, 0x00376e77, 0x003e2720, 0x0045aee0, 0x004e1e4d, 0x005790cf, 0x006224f9, 0x006dfcd6, 0x007b3e4d, 0x008a1388, 0x009aab5f, 0x00ad39d5, 0x00c1f894, 0x00d9277b, 0x00f30d27, 0x010ff794, 0x01303caf, 0x01543b01, 0x017c5a46, 0x01a90c0e, 0x01dacc51, 0x021221f5, 0x024f9f3b, 0x0293e210, 0x02df9433, 0x03336b20, 0x039027b0, 0x03f6956a, 0x0467895d, 0x04e3e07d, 0x056c7d6c, 0x06024594, 0x06a61d88, 0x0758e497, 0x081b6f98, 0x08ee82de, 0x09d2cb77, 0x0ac8d7d9, 0x0bd11026, 0x0cebae6d, 0x0e18b736, 0x0f57f2ea, 0x10a8e8ac, 0x120adb23, 0x137cc7f2, 0x14fd6a6e, 0x168b41f7, 0x18249c70, 0x19c7a4f0, 0x1b7276d3, 0x1d23352d, 0x1ed826db, 0x208fd7e6, 0x2249423f, 0x2404024f, 0x25c0a169, 0x27810c5b },
    { 0x00012382, 0x0001472c, 0x00016f34, 0x00019c20, 0x0001ce8a, 0x0002071f, 0x0002469d, 0x00028ddf, 0x0002ddd5, 0x00033791, 0x00039c43, 0x00040d43, 0x00048c0e, 0x00051a56, 0x0005b9fb, 0x00066d1d, 0x0007361a, 0x0008179c, 0x0009149d, 0x000a3077, 0x000b6ee9, 0x000cd426, 0x000e64e4, 0x00102669, 0x00121e9f, 0x00145425, 0x0016ce67, 0x001995b1, 0x001cb351, 0x002031ae, 0x00241c6f, 0x0028809b, 0x002d6cc2, 0x0032f130, 0x00392019, 0x00400dd0, 0x0047d10a, 0x0050831b, 0x005a4044, 0x00652801, 0x00715d64, 0x007f0773, 0x008e5191, 0x009f6bee, 0x00b28c03, 0x00c7ed0e, 0x00dfd0a0, 0x00fa7f27, 0x01184887, 0x013984b0, 0x015e9439, 0x0187e0f6, 0x01b5de87, 0x01e90adc, 0x0221eea5, 0x02611da3, 0x02a736d2, 0x02f4e463, 0x034adb6d, 0x03a9db52, 0x0412acb5, 0x04862003, 0x05050b5f, 0x059047fa, 0x0628aead, 0x06cf13d2, 0x07844255, 0x0848f5f7, 0x091dd4d5, 0x0a036855, 0x0afa15a1, 0x0c021601, 0x0d1b6f69, 0x0e45edb5, 0x0f811d18, 0x10cc464a, 0x12266d14, 0x138e51ac, 0x15027574, 0x1681233c, 0x18087b41, 0x199682cd, 0x1b293725, 0x1cbea389, 0x1e54f9f6, 0x1feaaecd, 0x217e9845, 0x23101435, 0x249f3a0a },
    { 0x00010b74, 0x00012c2f, 0x000150ea, 0x00017a24, 0x0001a868, 0x0001dc54, 0x00021699, 0x000257fe, 0x0002a162, 0x0002f3be, 0x0003502a, 0x0003b7e2, 0x00042c45, 0x0004aee0, 0x0005416e, 0x0005e5e0, 0x00069e66, 0x00076d71, 0x000855bf, 0x00095a63, 0x000a7ecf, 0x000bc6e0, 0x000d36eb, 0x000ed3cb, 0x0010a2ee, 0x0012aa6e, 0x0014f11e, 0x00177ea3, 0x001a5b8c, 0x001d916e, 0x00212b04, 0x0025344f, 0x0029babc, 0x002ecd4d, 0x00347ccc, 0x003adbfa, 0x0041ffc7, 0x0049ff94, 0x0052f577, 0x005cfe84, 0x00683b21, 0x0074cf60, 0x0082e360, 0x0092a3b7, 0x00a441e3, 0x00b7f4c0, 0x00cdf911, 0x00e691fc, 0x0102099f, 0x0120b19f, 0x0142e3b5, 0x01690245, 0x019378e3, 0x01c2bcd7, 0x01f74d86, 0x0231b4c8, 0x02728719, 0x02ba6395, 0x0309f3c0, 0x0361eaf8, 0x03c3058e, 0x042e076a, 0x04a3ba2e, 0x0524eaba, 0x05b2660c, 0x064cf55b, 0x06f5597c, 0x07ac4577, 0x08725869, 0x094816c2, 0x0a2de310, 0x0b23f696, 0x0c2a5a01, 0x0d40deaa, 0x0e6718db, 0x0f9c5baa, 0x10dfb6e2, 0x122ff786, 0x138bab5a, 0x14f127a5, 0x165e934c, 0x17d1f428, 0x19493f27, 0x1ac26ad4, 0x1c3b83a2, 0x1db2c176, 0x1f269e3c, 0x2095eddb, 0x21fff8fe },
    { 0x0000f561, 0x00011369, 0x0001351d, 0x00015af1, 0x00018565, 0x0001b50a, 0x0001ea83, 0x00022686, 0x000269e0, 0x0002b575, 0x00030a47, 0x00036978, 0x0003d44a, 0x00044c2a, 0x0004d2ae, 0x000569a1, 0x00061303, 0x0006d113, 0x0007a656, 0x000895a0, 0x0009a21a, 0x000acf53, 0x000c2145, 0x000d9c66, 0x000f45b8, 0x001122d4, 0x00133a01, 0x00159248, 0x0018338a, 0x001b2698, 0x001e7552, 0x00222ac5, 0x0026534d, 0x002afcbf, 0x00303691, 0x0036120a, 0x003ca279, 0x0043fd6b, 0x004c3aef, 0x005575d8, 0x005fcc0d, 0x006b5edb, 0x00785351, 0x0086d29e, 0x00970a82, 0x00a92dba, 0x00bd747a, 0x00d41cec, 0x00ed6bb3, 0x0109ac78, 0x0129326d, 0x014c58db, 0x017383a4, 0x019f1fc1, 0x01cfa3a9, 0x02058fa5, 0x02416e05, 0x0283d325, 0x02cd5d3f, 0x031eb3f2, 0x03788770, 0x03db8f4b, 0x044888b9, 0x04c03453, 0x05435330, 0x05d2a349, 0x066edb2f, 0x0718a4fc, 0x07d0988c, 0x08973525, 0x096cda96, 0x0a51c229, 0x0b45f791, 0x0c495259, 0x0d5b702a, 0x0e7bb07e, 0x0fa93225, 0x10e2d337, 0x122733b3, 0x1374bb25, 0x14c9a15c, 0x1623fa08, 0x1781c2ea, 0x18e0f412, 0x1a3f9171, 0x1b9bbd16, 0x1cf3c978, 0x1e464b68, 0x1f922bcd },
    { 0x0000e11e, 0x0000fcac, 0x00011b98, 0x00013e4e, 0x00016542, 0x000190fa, 0x0001c20b, 0x0001f91c, 0x000236e9, 0x00027c45, 0x0002ca1c, 0x00032177, 0x0003837f, 0x0003f183, 0x00046cf8, 0x0004f783, 0x000592fa, 0x0006416e, 0x0007052f, 0x0007e0d6, 0x0008d74b, 0x0009ebd3, 0x000b2215, 0x000c7e2b, 0x000e04ae, 0x000fbac5, 0x0011a636, 0x0013cd77, 0x001637c8, 0x0018ed45, 0x001bf703, 0x001f5f2e, 0x00233125, 0x002779a4, 0x002c46e6, 0x0031a8d4, 0x0037b136, 0x003e73e9, 0x00460715, 0x004e8376, 0x0058049e, 0x0062a942, 0x006e9393, 0x007be994, 0x008ad580, 0x009b8635, 0x00ae2fa0, 0x00c30b37, 0x00da5874, 0x00f45d57, 0x011166e5, 0x0131c9a9, 0x0155e238, 0x017e159e, 0x01aad1cc, 0x01dc8de6, 0x0213ca77, 0x02511184, 0x0294f65e, 0x02e01541, 0x03331297, 0x038e99df, 0x03f35c20, 0x04620dd2, 0x04db643a, 0x05601213, 0x05f0c392, 0x068e19b1, 0x0738a4cd, 0x07f0deae, 0x08b72410, 0x098badee, 0x0a6e8ac7, 0x0b5f984a, 0x0c5e7dba, 0x0d6aa797, 0x0e8344f7, 0x0fa74701, 0x10d562ef, 0x120c16cf, 0x1349b11d, 0x148c5b0d, 0x15d22535, 0x17191617, 0x185f39d1, 0x19a2b23c, 0x1ae1c6c5, 0x1c1af35e, 0x1d4cf631 },
    { 0x0000ce86, 0x0000e7ce, 0x0001042d, 0x00012405, 0x000147c3, 0x00016fe0, 0x00019ce5, 0x0001cf6c, 0x00020821, 0x000247c6, 0x00028f33, 0x0002df5c, 0x00033951, 0x00039e46, 0x00040f92, 0x00048eb7, 0x00051d65, 0x0005bd81, 0x0006712b, 0x00073ac6, 0x00081cfd, 0x00091ad1, 0x000a379d, 0x000b7727, 0x000cdda7, 0x000e6fd9, 0x0010330c, 0x00122d31, 0x001464f0, 0x0016e1bf, 0x0019abf9, 0x001cccf7, 0x00204f2f, 0x00243e58, 0x0028a78a, 0x002d996a, 0x00332455, 0x00395a94, 0x0040508f, 0x00481d0e, 0x0050d976, 0x005aa213, 0x0065966a, 0x0071d987, 0x007f925d, 0x008eec29, 0x00a016d7, 0x00b34775, 0x00c8b8a4, 0x00e0ab12, 0x00fb65f0, 0x01193773, 0x013a7543, 0x015f7cf0, 0x0188b453, 0x01b689db, 0x01e974ca, 0x0221f53d, 0x02609415, 0x02a5e299, 0x02f279d5, 0x0346f998, 0x03a4070e, 0x040a4ad7, 0x047a6e97, 0x04f519e7, 0x057aeea3, 0x060c8490, 0x06aa6459, 0x075501f9, 0x080cb6b6, 0x08d1bac3, 0x09a41ef0, 0x0a83c696, 0x0b706236, 0x0c696b2c, 0x0d6e20f1, 0x0e7d8855, 0x0f966cfa, 0x10b76567, 0x11ded9b8, 0x130b0ccd, 0x143a27b8, 0x156a46de, 0x16998831, 0x17c619c7, 0x18ee480b, 0x1a108ae8, 0x1b2b9167 },
    { 0x0000bd76, 0x0000d4a7, 0x0000eeaf, 0x00010be7, 0x00012cb1, 0x0001517f, 0x00017acd, 0x0001a929, 0x0001dd31, 0x00021796, 0x00025920, 0x0002a2ad, 0x0002f539, 0x000351dd, 0x0003b9d4, 0x00042e80, 0x0004b16e, 0x0005445d, 0x0005e93f, 0x0006a244, 0x000771e2, 0x00085ad9, 0x0009603f, 0x000a858a, 0x000bce9c, 0x000d3fcd, 0x000eddfe, 0x0010aea5, 0x0012b7e0, 0x0015008a, 0x00179050, 0x001a6fcc, 0x001da89b, 0x00214582, 0x0025528d, 0x0029dd33, 0x002ef483, 0x0034a94f, 0x003b0e5f, 0x004238aa, 0x004a3f93, 0x00533d28, 0x005d4e6f, 0x006893b3, 0x007530d9, 0x00834dbc, 0x0093168b, 0x00a4bc35, 0x00b874d3, 0x00ce7c16, 0x00e713bc, 0x01028400, 0x01211c0c, 0x01433261, 0x01692533, 0x01935aba, 0x01c24165, 0x01f64fee, 0x02300543, 0x026fe838, 0x02b686f5, 0x03047611, 0x035a4f47, 0x03b8afbe, 0x042035c7, 0x04917e13, 0x050d2048, 0x0593aaf7, 0x06259eff, 0x06c36a55, 0x076d6267, 0x0823be2c, 0x08e6902d, 0x09b5c0c6, 0x0a910909, 0x0b77ee8d, 0x0c69c0ae, 0x0d659798, 0x0e6a5565, 0x0f76a99c, 0x1089171d, 0x119ffc66, 0x12b99de6, 0x13d431f4, 0x14ededce, 0x160512e7, 0x1717fbde, 0x1825286a, 0x192b47b2 },
    { 0x0000adce, 0x0000c315, 0x0000daf7, 0x0000f5c5, 0x000113da, 0x0001359e, 0x00015b84, 0x0001860c, 0x0001b5c9, 0x0001eb5d, 0x0002277e, 0x00026afb, 0x0002b6b8, 0x00030bb9, 0x00036b1e, 0x0003d62d, 0x00044e52, 0x0004d526, 0x00056c74, 0x0006163e, 0x0006d4c5, 0x0007aa91, 0x00089a77, 0x0009a7a4, 0x000ad5aa, 0x000c2886, 0x000da4b2, 0x000f4f33, 0x00112da9, 0x0013465e, 0x0015a062, 0x0018439b, 0x001b38df, 0x001e8a15, 0x00224250, 0x00266df0, 0x002b1ace, 0x00305862, 0x003637f3, 0x003ccccb, 0x00442c6d, 0x004c6ed4, 0x0055aeb8, 0x006009d3, 0x006ba132, 0x0078998c, 0x00871b95, 0x00975467, 0x00a975de, 0x00bdb706, 0x00d45482, 0x00ed90f8, 0x0109b57d, 0x012911ee, 0x014bfd57, 0x0172d631, 0x019e029b, 0x01cdf070, 0x02031533, 0x023dedd0, 0x027efe12, 0x02c6cfd9, 0x0315f1f0, 0x036cf676, 0x03cc70cf, 0x0434f315, 0x04a70af1, 0x05233de3, 0x05aa04fa, 0x063bc806, 0x06d8d852, 0x07816b2a, 0x0835943d, 0x08f54038, 0x09c02fec, 0x0a95f44f, 0x0b75ebc5, 0x0c5f4109, 0x0d50ec0c, 0x0e49b4f5, 0x0f48396b, 0x104af40a, 0x115045c1, 0x125680c5, 0x135bf472, 0x145ef986, 0x155dfe0a, 0x16579042, 0x174a6820 },
    { 0x00009f71, 0x0000b2f6, 0x0000c8de, 0x0000e176, 0x0000fd0f, 0x00011c09, 0x00013ece, 0x000165d3, 0x0001919f, 0x0001c2c7, 0x0001f9f2, 0x000237dd, 0x00027d5b, 0x0002cb59, 0x000322e0, 0x0003851a, 0x0003f358, 0x00046f0f, 0x0004f9e5, 0x000595b2, 0x00064487, 0x000708b8, 0x0007e4de, 0x0008dbe4, 0x0009f110, 0x000b280c, 0x000c84f6, 0x000e0c69, 0x000fc38e, 0x0011b02f, 0x0013d8c7, 0x00164497, 0x0018fbbf, 0x001c0757, 0x001f718c, 0x002345bf, 0x002790aa, 0x002c6085, 0x0031c533, 0x0037d070, 0x003e9604, 0x00462bff, 0x004eaaf5, 0x00582e40, 0x0062d44c, 0x006ebee2, 0x007c137e, 0x008afba7, 0x009ba54a, 0x00ae4320, 0x00c30d09, 0x00da4079, 0x00f420d1, 0x0110f7c2, 0x0131159d, 0x0154d19b, 0x017c8a0e, 0x01a8a479, 0x01d98d81, 0x020fb8b5, 0x024ba016, 0x028dc35b, 0x02d6a6e6, 0x0326d24f, 0x037ece84, 0x03df236b, 0x04485503, 0x04badff1, 0x05373590, 0x05bdb779, 0x064eb2ab, 0x06ea5a69, 0x0790c302, 0x0841dcc7, 0x08fd6f74, 0x09c31669, 0x0a923e06, 0x0b6a2289, 0x0c49d0ad, 0x0d302852, 0x0e1be132, 0x0f0b919f, 0x0ffdb710, 0x10f0c01e, 0x11e3176c, 0x12d32eeb, 0x13bf8ad2, 0x14a6cbb7, 0x1587b740 }
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\XboxSynth\kernhelp.h ===
// Copyright (c) 1998 Microsoft Corporation
//
//
//
#ifndef _KernHelp_
#define _KernHelp_

// Use kernel mutex to implement critical section
//
typedef KMUTEX CRITICAL_SECTION;
typedef CRITICAL_SECTION *LPCRITICAL_SECTION;

VOID InitializeCriticalSection(
    LPCRITICAL_SECTION);

VOID EnterCriticalSection(
    LPCRITICAL_SECTION);

VOID LeaveCriticalSection(
    LPCRITICAL_SECTION);

VOID DeleteCriticalSection(
    LPCRITICAL_SECTION);

// We have very little registry work to do, so just encapsulate the
// entire process
//
int GetRegValueDword(
    LPTSTR RegPath,
    LPTSTR ValueName,
    PULONG Value);

ULONG GetTheCurrentTime();


#ifndef _NEW_DELETE_OPERATORS_
#define _NEW_DELETE_OPERATORS_

inline void* __cdecl operator new
(
    unsigned int    iSize
)
{
    PVOID result = ExAllocatePoolWithTag(NonPagedPool, iSize, 'suMD');
    if (result)
    {
        RtlZeroMemory(result, iSize);
    }

    return result;
}

/*****************************************************************************
 * ::new()
 *****************************************************************************
 * New function for creating objects with a specified allocation tag.
 */
inline PVOID operator new
(
    unsigned int    iSize,
    POOL_TYPE       poolType
)
{
    PVOID result = ExAllocatePoolWithTag(poolType, iSize, 'suMD');
    if (result)
    {
        RtlZeroMemory(result, iSize);
    }

    return result;
}

/*****************************************************************************
 * ::new()
 *****************************************************************************
 * New function for creating objects with a specified allocation tag.
 */
inline PVOID operator new
(
    unsigned int    iSize,
    POOL_TYPE       poolType,
    ULONG           tag
)
{
    PVOID result = ExAllocatePoolWithTag(poolType, iSize, tag);

    if (result)
    {
        RtlZeroMemory(result,iSize);
    }

    return result;
}

/*****************************************************************************
 * ::delete()
 *****************************************************************************
 * Delete function.
 */
inline void __cdecl operator delete
(
    PVOID pVoid
)
{
    ExFreePool(pVoid);
}


#endif //!_NEW_DELETE_OPERATORS_

#define DM_DEBUG_CRITICAL		1	// Used to include critical messages
#define DM_DEBUG_NON_CRITICAL	2	// Used to include level 1 plus important non-critical messages
#define DM_DEBUG_STATUS			3	// Used to include level 1 and level 2 plus status\state messages
#define DM_DEBUG_FUNC_FLOW		4	// Used to include level 1, level 2 and level 3 plus function flow messages
#define DM_DEBUG_ALL			5	// Used to include all debug messages

// Debug trace facility
//
#ifdef DBG
extern void DebugInit(void);
extern void DebugTrace(int iDebugLevel, LPSTR pstrFormat, ...);
#define Trace DebugTrace
#else
#define Trace
#endif

// Paramter validation unused
//
#define V_INAME(x)
#define V_BUFPTR_READ(p,cb)


#endif // _KernHelp_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\XboxSynth\instr.cpp ===
//
// Copyright (c) 1996-2001 Microsoft Corporation
// Instrument.cpp
//

#ifdef DMSYNTH_MINIPORT
#include "common.h"
#else
#include "simple.h"
#include <mmsystem.h>
#include <dmerror.h>
#include "synth.h"
#include "math.h"
#include "debug.h"
#include "validate.h"
#endif

void MemDump(char * prompt);

//#include <windowsx.h>

CSourceLFO::CSourceLFO()

{
    m_pfFrequency = 3804; // f = (256*4096*16*5hz)/(samplerate)
    m_stDelay = 0;
    m_prMWPitchScale = 0;
    m_vrMWVolumeScale = 0;
    m_vrVolumeScale = 0;
    m_prPitchScale = 0;
    m_prCPPitchScale = 0;
    m_vrCPVolumeScale = 0;
    m_prCutoffScale = 0;
    m_prMWCutoffScale = 0;
    m_prCPCutoffScale = 0;
}

void CSourceLFO::Init(DWORD dwSampleRate)

{
    m_pfFrequency = (256 * 4096 * 16 * 5) / dwSampleRate;
    m_stDelay = 0;
    m_prMWPitchScale = 0;
    m_vrMWVolumeScale = 0;
    m_vrVolumeScale = 0;
    m_prPitchScale = 0;
    m_prCPPitchScale = 0;
    m_vrCPVolumeScale = 0;
    m_prCutoffScale = 0;
    m_prMWCutoffScale = 0;
    m_prCPCutoffScale = 0;
}

void CSourceLFO::SetSampleRate(long lChange)

{
    if (lChange > 0)
    {
        m_stDelay <<= lChange;
        m_pfFrequency <<= lChange;
    }
    else
    {
        m_stDelay >>= -lChange;
        m_pfFrequency >>= -lChange;
    }
}

void CSourceLFO::Verify()

{
    FORCEBOUNDS(m_pfFrequency,64,7600);
    FORCEBOUNDS(m_stDelay,0,441000);
    FORCEBOUNDS(m_vrVolumeScale,-1200,1200);
    FORCEBOUNDS(m_vrMWVolumeScale,-1200,1200);
    FORCEBOUNDS(m_prPitchScale,-1200,1200);
    FORCEBOUNDS(m_prMWPitchScale,-1200,1200);
    FORCEBOUNDS(m_prCPPitchScale,-1200,1200);
    FORCEBOUNDS(m_vrCPVolumeScale,-1200,1200);
    FORCEBOUNDS(m_prCutoffScale, -12800, 12800);
    FORCEBOUNDS(m_prMWCutoffScale, -12800, 12800);
    FORCEBOUNDS(m_prCPCutoffScale, -12800, 12800);
}

CSourceEG::CSourceEG()

{
    Init();
}

void CSourceEG::Init()

{
    m_stAttack = 0;
    m_stDecay = 0;
    m_pcSustain = 1000;
    m_stRelease = 0;
    m_trVelAttackScale = 0;
    m_trKeyDecayScale = 0;
    m_sScale = 0;
    m_stDelay = 0;
    m_stHold = 0;
    m_prCutoffScale = 0;
}

void CSourceEG::SetSampleRate(long lChange)

{
    if (lChange > 0)
    {
        m_stAttack <<= lChange;
        m_stDecay <<= lChange;
        m_stRelease <<= lChange;
    }
    else
    {
        m_stAttack >>= -lChange;
        m_stDecay >>= -lChange;
        m_stRelease >>= -lChange;
    }
}

void CSourceEG::Verify()

{
    FORCEBOUNDS(m_stAttack,0,1764000);
    FORCEBOUNDS(m_stDecay,0,1764000);
    FORCEBOUNDS(m_pcSustain,0,1000);
    FORCEBOUNDS(m_stRelease,0,1764000);
    FORCEBOUNDS(m_sScale,-1200,1200);
    FORCEBOUNDS(m_trKeyDecayScale,-12000,12000);
    FORCEBOUNDS(m_trVelAttackScale,-12000,12000);
    FORCEBOUNDS(m_trKeyHoldScale,-12000,12000);
    FORCEBOUNDS(m_prCutoffScale,-12800,12800);
}

CSourceFilter::CSourceFilter()
{
    Init(22050);
}

void CSourceFilter::Init(DWORD dwSampleRate)
{
    // First, calculate the playback samplerate in pitch rels.
    // The reference frequency is a440, which is midi note 69.
    // So, calculate the ratio of the sample rate to 440 and
    // convert into prels (1200 per octave), then add the
    // offset of 6900.
    double fSampleRate = (double)dwSampleRate;

    fSampleRate /= 440.0;
    fSampleRate = log(fSampleRate) / log(2.0);
    fSampleRate *= 1200.0;
    fSampleRate += 6900.0;
    m_prSampleRate = (PRELS)fSampleRate;

    m_prCutoff = (PRELS)0x7FFF;
    m_vrQ = (VRELS)0;
    m_prVelScale = (PRELS)0;
    m_prCutoffSRAdjust = 0;
    m_iQIndex = 0;
}

void CSourceFilter::SetSampleRate(LONG lChange)
{
    // lChange ==  1 -> doubles -> add 1200 cents
    // lChange ==  2 -> quad    -> add 2400 cents
    // lChange == -1 -> halves  -> sub 1200 cents
    // lChange == -2 -> 1/4ths  -> sub 2400 cents
    //
    if (lChange > 0)
    {
        m_prSampleRate += (1200 << (lChange - 1));
    }
    else
    {
        m_prSampleRate -= (1200 << ((-lChange) - 1));
    }

    m_prCutoffSRAdjust = FILTER_FREQ_RANGE - m_prSampleRate + m_prCutoff;
}

void CSourceFilter::Verify()
{
    if ( m_prCutoff == 0x7FFF )
    {
        m_vrQ = 0;
        m_prVelScale = 0;
    }
    else
    {
        FORCEBOUNDS(m_prCutoff, 5535, 11921);
        FORCEBOUNDS(m_vrQ, 0, 225);
        FORCEBOUNDS(m_prVelScale, -12800, 12800);
    }
}

CSourceArticulation::CSourceArticulation()

{
//    m_sVelToVolScale = -9600;
    m_wUsageCount = 0;
    m_sDefaultPan = 0;
    m_dwSampleRate = 22050;
    m_PitchEG.m_sScale = 0; // pitch envelope defaults to off
}

void CSourceArticulation::Init(DWORD dwSampleRate)

{
    m_dwSampleRate = dwSampleRate;
    m_LFO.Init(dwSampleRate);       // Set to default values.
    m_PitchEG.Init();
    m_VolumeEG.Init();
    m_LFO2.Init(dwSampleRate);
    m_Filter.Init(dwSampleRate);
}

void CSourceArticulation::SetSampleRate(DWORD dwSampleRate)

{
    if (dwSampleRate != m_dwSampleRate)
    {
        long lChange;
        if (dwSampleRate > (m_dwSampleRate * 2))
        {
            lChange = 2;        // going from 11 to 44.
        }
        else if (dwSampleRate > m_dwSampleRate)
        {
            lChange = 1;        // must be doubling
        }
        else if ((dwSampleRate * 2) < m_dwSampleRate)
        {
            lChange = -2;       // going from 44 to 11
        }
        else
        {
            lChange = -1;       // that leaves halving.
        }
        m_dwSampleRate = dwSampleRate;
        m_LFO.SetSampleRate(lChange);
        m_PitchEG.SetSampleRate(lChange);
        m_VolumeEG.SetSampleRate(lChange);
        m_LFO2.SetSampleRate(lChange);
        m_Filter.SetSampleRate(lChange);
    }
}

void CSourceArticulation::Verify()

{
    m_LFO.Verify();
    m_PitchEG.Verify();
    m_VolumeEG.Verify();
    m_LFO2.Verify();
    m_Filter.Verify();
}

void CSourceArticulation::AddRef()

{
    m_wUsageCount++;
}

void CSourceArticulation::Release()

{
    m_wUsageCount--;
    if (m_wUsageCount == 0)
    {
        delete this;
    }
}

CSourceSample::CSourceSample()

{
    m_pWave = NULL;
    m_dwLoopStart = 0;
    m_dwLoopEnd = 1;
    m_dwLoopType = WLOOP_TYPE_FORWARD;
    m_dwSampleLength = 0;
    m_prFineTune = 0;
    m_dwSampleRate = 22050;
    m_bMIDIRootKey = 60;
    m_bOneShot = TRUE;
    m_bSampleType = 0;
}

CSourceSample::~CSourceSample()

{
    if (m_pWave != NULL)
    {
        m_pWave->Release();
    }
}

void CSourceSample::Verify()

{
    if (m_pWave != NULL)
    {
        FORCEBOUNDS(m_dwSampleLength,0,m_pWave->m_dwSampleLength);
        FORCEBOUNDS(m_dwLoopEnd,1,m_dwSampleLength);
        FORCEBOUNDS(m_dwLoopStart,0,m_dwLoopEnd);
        if ((m_dwLoopEnd - m_dwLoopStart) < 6)
        {
            m_bOneShot = TRUE;
        }
    }
    FORCEBOUNDS(m_dwSampleRate,3000,200000);
    FORCEBOUNDS(m_bMIDIRootKey,0,127);
    FORCEBOUNDS(m_prFineTune,-1200,1200);
}

BOOL CSourceSample::CopyFromWave()

{
    if (m_pWave == NULL)
    {
        return FALSE;
    }
    m_dwSampleLength = m_pWave->m_dwSampleLength;
    m_dwSampleRate = m_pWave->m_dwSampleRate;
    m_bSampleType = m_pWave->m_bSampleType;
    if (m_bOneShot)
    {
        m_dwSampleLength--;
        if (m_pWave->m_bSampleType & SFORMAT_16)
        {
            m_pWave->m_pnWave[m_dwSampleLength] = 0;
        }
        else
        {
            char *pBuffer = (char *) m_pWave->m_pnWave;
            pBuffer[m_dwSampleLength] = 0;
        }
    }
    else
    {
        if (m_dwLoopStart >= m_dwSampleLength)
        {
            m_dwLoopStart = 0;
        }
        if (m_pWave->m_bSampleType & SFORMAT_16)
        {
            m_pWave->m_pnWave[m_dwSampleLength-1] =
                m_pWave->m_pnWave[m_dwLoopStart];
        }
        else
        {
            char *pBuffer = (char *) m_pWave->m_pnWave;
            pBuffer[m_dwSampleLength-1] =
                pBuffer[m_dwLoopStart];
        }
    }
    Verify();
    return (TRUE);
}


CWave::CWave()
{
    m_hUserData = NULL;
    m_lpFreeHandle = NULL;
    m_pnWave = NULL;
    m_dwSampleRate = 22050;
    m_bSampleType = SFORMAT_16;
    m_dwSampleLength = 0;
    m_wUsageCount = 0;
    m_dwID = 0;
    m_wPlayCount = 0;
    m_bStream = FALSE;
    m_bActive = FALSE;
    m_bLastSampleInit = FALSE;
    m_bValid = FALSE;
}

CWave::~CWave()

{
    if (m_pnWave && m_lpFreeHandle)
    {
        m_lpFreeHandle((HANDLE) this,m_hUserData);
    }
}

void CWave::Verify()

{
    FORCEBOUNDS(m_dwSampleRate,3000,200000);
}

void CWave::PlayOn()

{
    m_wPlayCount++;
    AddRef();
}

void CWave::PlayOff()

{
    m_wPlayCount--;
    Release();
}

BOOL CWave::IsPlaying()

{
    return (m_wPlayCount);
}

void CWave::AddRef()

{
    m_wUsageCount++;
}

void CWave::Release()

{
    m_wUsageCount--;
    if (m_wUsageCount == 0)
    {
        delete this;
    }
}

CWaveArt::CWaveArt()
{
    m_wUsageCount = 1;
    m_dwID = 0;
    m_bSampleType = 0;
    m_bStream = FALSE;
    memset(&m_WaveArtDl,0,sizeof(DMUS_WAVEARTDL));
    memset(&m_WaveformatEx,0,sizeof(WAVEFORMATEX));
}

CWaveArt::~CWaveArt()
{
//>>>>>>>>>> clear list
    while(!m_pWaves.IsEmpty())
    {
        CWaveBuffer* pWaveBuffer = m_pWaves.RemoveHead();
        if(pWaveBuffer)
        {
            pWaveBuffer->m_pWave->Release();
            pWaveBuffer->m_pWave = NULL;
            delete pWaveBuffer;
        }
    }
}

void CWaveArt::AddRef()
{
    m_wUsageCount++;
}

void CWaveArt::Release()
{
    m_wUsageCount--;
    if (m_wUsageCount == 0)
    {
        delete this;
    }
}

void CWaveArt::Verify()
{
}

CSourceRegion::CSourceRegion()
{
    m_pArticulation = NULL;
    m_vrAttenuation = 0;
    m_prTuning = 0;
    m_bKeyHigh = 127;
    m_bKeyLow = 0;
    m_bGroup = 0;
    m_bAllowOverlap = FALSE;
    m_bVelocityHigh = 127;
    m_bVelocityLow  = 0;
    m_dwChannel = 0;
    m_sWaveLinkOptions = 0;
}

CSourceRegion::~CSourceRegion()
{
    if (m_pArticulation)
    {
        m_pArticulation->Release();
    }
}

void CSourceRegion::SetSampleRate(DWORD dwSampleRate)

{
    if (m_pArticulation != NULL)
    {
        m_pArticulation->SetSampleRate(dwSampleRate);
    }
}

void CSourceRegion::Verify()

{
    FORCEBOUNDS(m_bKeyHigh,0,127);
    FORCEBOUNDS(m_bKeyLow,0,127);
    FORCEBOUNDS(m_prTuning,-12000,12000);
    FORCEBOUNDS(m_vrAttenuation,-9600,0);
    m_Sample.Verify();
    if (m_pArticulation != NULL)
    {
        m_pArticulation->Verify();
    }
}

CInstrument::CInstrument()
{
    m_dwProgram = 0;
}

CInstrument::~CInstrument()
{
    while (!m_RegionList.IsEmpty())
    {
        CSourceRegion *pRegion = m_RegionList.RemoveHead();
        delete pRegion;
    }
}

void CInstrument::Verify()

{
    CSourceRegion *pRegion = m_RegionList.GetHead();
    CSourceArticulation *pArticulation = NULL;
    for (;pRegion != NULL;pRegion = pRegion->GetNext())
    {
        if (pRegion->m_pArticulation != NULL)
        {
            pArticulation = pRegion->m_pArticulation;
        }
        pRegion->Verify();
    }
    pRegion = m_RegionList.GetHead();
    for (;pRegion != NULL;pRegion = pRegion->GetNext())
    {
        if (pRegion->m_pArticulation == NULL  && pArticulation)
        {
            pRegion->m_pArticulation = pArticulation;
            pArticulation->AddRef();
        }
    }
}

void CInstrument::SetSampleRate(DWORD dwSampleRate)

{
    CSourceRegion *pRegion = m_RegionList.GetHead();
    for (;pRegion;pRegion = pRegion->GetNext())
    {
        pRegion->SetSampleRate(dwSampleRate);
    }
}

CSourceRegion * CInstrument::ScanForRegion(DWORD dwNoteValue, DWORD dwVelocity, CSourceRegion *pRegion)

{
    if ( pRegion == NULL )
        pRegion = m_RegionList.GetHead(); // Starting search
    else
        pRegion = pRegion->GetNext();     // Continuing search through the rest of the regions

    for (;pRegion;pRegion = pRegion->GetNext())
    {
        if (dwNoteValue >= pRegion->m_bKeyLow  &&
            dwNoteValue <= pRegion->m_bKeyHigh &&
            dwVelocity  >= pRegion->m_bVelocityLow &&
            dwVelocity  <= pRegion->m_bVelocityHigh )
        {
            break ;
        }
    }
    return pRegion;
}

void CInstManager::SetSampleRate(DWORD dwSampleRate)

{
    DWORD dwIndex;
    m_dwSampleRate = dwSampleRate;
    EnterCriticalSection(&m_CriticalSection);
    for (dwIndex = 0; dwIndex < INSTRUMENT_HASH_SIZE; dwIndex++)
    {
        CInstrument *pInstrument = m_InstrumentList[dwIndex].GetHead();
        for (;pInstrument != NULL; pInstrument = pInstrument->GetNext())
        {
            pInstrument->SetSampleRate(dwSampleRate);
        }
    }
    LeaveCriticalSection(&m_CriticalSection);
}

CInstManager::CInstManager()

{
    m_dwSampleRate = 22050;
    m_fCSInitialized = FALSE;
    InitializeCriticalSection(&m_CriticalSection);
    // Note: on pre-Blackcomb OS's, this call can raise an exception; if it
    // ever pops in stress, we can add an exception handler and retry loop.
    m_fCSInitialized = TRUE;
    m_dwSynthMemUse = 0;
}

CInstManager::~CInstManager()

{
    if (m_fCSInitialized)
    {
        DWORD dwIndex;
        for (dwIndex = 0; dwIndex < INSTRUMENT_HASH_SIZE; dwIndex++)
        {
            while (!m_InstrumentList[dwIndex].IsEmpty())
            {
                CInstrument *pInstrument = m_InstrumentList[dwIndex].RemoveHead();
                delete pInstrument;
            }
        }
        for (dwIndex = 0; dwIndex < WAVE_HASH_SIZE; dwIndex++)
        {
            while (!m_WavePool[dwIndex].IsEmpty())
            {
                CWave *pWave = m_WavePool[dwIndex].RemoveHead();
                pWave->Release();
            }
        }
        while (!m_FreeWavePool.IsEmpty())
        {
            CWave *pWave = m_FreeWavePool.RemoveHead();
            pWave->Release();
        }

        for(int nCount = 0; nCount < WAVEART_HASH_SIZE; nCount++)
        {
            while(!m_WaveArtList[nCount].IsEmpty())
            {
                CWaveArt* pWaveArt = m_WaveArtList[nCount].RemoveHead();
                if(pWaveArt)
                {
                    pWaveArt->Release();
                }
            }
        }

        DeleteCriticalSection(&m_CriticalSection);
    }
}

void CInstManager::Verify()

{
    DWORD dwIndex;
    EnterCriticalSection(&m_CriticalSection);
    for (dwIndex = 0;dwIndex < INSTRUMENT_HASH_SIZE; dwIndex++)
    {
        CInstrument *pInstrument = m_InstrumentList[dwIndex].GetHead();
        for (;pInstrument != NULL;pInstrument = pInstrument->GetNext())
        {
            pInstrument->Verify();
        }
    }
    LeaveCriticalSection(&m_CriticalSection);
}

CInstrument * CInstManager::GetInstrument(DWORD dwProgram, DWORD dwKey, DWORD dwVelocity)

{
    EnterCriticalSection(&m_CriticalSection);
    CInstrument *pInstrument = m_InstrumentList[dwProgram % INSTRUMENT_HASH_SIZE].GetHead();
    for (;pInstrument != NULL; pInstrument = pInstrument->GetNext())
    {
        if (pInstrument->m_dwProgram == dwProgram)
        {
            if (pInstrument->ScanForRegion(dwKey, dwVelocity, NULL) != NULL)
            {
                break;
            }
            else
            {
                Trace(2,"Warning: No region was found in instrument # %lx that matched note %ld\n",
                    dwProgram,dwKey);
            }
        }
    }
    LeaveCriticalSection(&m_CriticalSection);
    return (pInstrument);
}


DWORD TimeCents2Samples(long tcTime, DWORD dwSampleRate)
{
    if (tcTime ==  0x80000000) return (0);
    double flTemp = tcTime;
    flTemp /= (65536 * 1200);
    flTemp = pow(2.0,flTemp);
    flTemp *= dwSampleRate;
    return (DWORD) flTemp;
}

DWORD PitchCents2PitchFract(long pcRate,DWORD dwSampleRate)

{
    double fTemp = pcRate;
    fTemp /= 65536;
    fTemp -= 6900;
    fTemp /= 1200;
    fTemp = pow(2.0,fTemp);
    fTemp *= 7381975040.0; // (440*256*16*4096);
    fTemp /= dwSampleRate;
    return (DWORD) (fTemp);
}

HRESULT CSourceArticulation::Download(DMUS_DOWNLOADINFO * pInfo,
                                void * pvOffsetTable[],
                                DWORD dwIndex,
                                DWORD dwSampleRate,
                                BOOL fNewFormat)
{
    if (fNewFormat)
    {
        DMUS_ARTICULATION2 * pdmArtic =
            (DMUS_ARTICULATION2 *) pvOffsetTable[dwIndex];
        while (pdmArtic)
        {
            if (pdmArtic->ulArtIdx)
            {
                if (pdmArtic->ulArtIdx >= pInfo->dwNumOffsetTableEntries)
                {
                    Trace(1,"Error: Download failed because articulation chunk has an error.\n");
                    return DMUS_E_BADARTICULATION;
                }
                DWORD dwPosition;
                void *pData = pvOffsetTable[pdmArtic->ulArtIdx];
                CONNECTIONLIST * pConnectionList =
                    (CONNECTIONLIST *) pData;
                CONNECTION *pConnection;
                dwPosition = sizeof(CONNECTIONLIST);
                for (dwIndex = 0; dwIndex < pConnectionList->cConnections; dwIndex++)
                {
                    pConnection = (CONNECTION *) ((BYTE *)pData + dwPosition);
                    dwPosition += sizeof(CONNECTION);
                    switch (pConnection->usSource)
                    {
                    case CONN_SRC_NONE :
                        switch (pConnection->usDestination)
                        {
                        case CONN_DST_LFO_FREQUENCY :
                            m_LFO.m_pfFrequency = PitchCents2PitchFract(
                                pConnection->lScale,dwSampleRate);
                            break;
                        case CONN_DST_LFO_STARTDELAY :
                            m_LFO.m_stDelay = TimeCents2Samples(
                                (TCENT) pConnection->lScale,dwSampleRate);
                            break;
                        case CONN_DST_EG1_ATTACKTIME :
                            m_VolumeEG.m_stAttack = TimeCents2Samples(
                                (TCENT) pConnection->lScale,dwSampleRate);
                            break;
                        case CONN_DST_EG1_DECAYTIME :
                            m_VolumeEG.m_stDecay = TimeCents2Samples(
                            (TCENT) pConnection->lScale,dwSampleRate);
                            break;
                        case CONN_DST_EG1_SUSTAINLEVEL :
                            m_VolumeEG.m_pcSustain =
                                (SPERCENT) ((long) (pConnection->lScale >> 16));
                            break;
                        case CONN_DST_EG1_RELEASETIME :
                            m_VolumeEG.m_stRelease = TimeCents2Samples(
                                (TCENT) pConnection->lScale,dwSampleRate);
                            break;
                        case CONN_DST_EG2_ATTACKTIME :
                            m_PitchEG.m_stAttack = TimeCents2Samples(
                                (TCENT) pConnection->lScale,dwSampleRate);
                            break;
                        case CONN_DST_EG2_DECAYTIME :
                            m_PitchEG.m_stDecay = TimeCents2Samples(
                                (TCENT) pConnection->lScale,dwSampleRate);
                            break;
                        case CONN_DST_EG2_SUSTAINLEVEL :
                            m_PitchEG.m_pcSustain =
                                (SPERCENT) ((long) (pConnection->lScale >> 16));
                            break;
                        case CONN_DST_EG2_RELEASETIME :
                            m_PitchEG.m_stRelease = TimeCents2Samples(
                                (TCENT) pConnection->lScale,dwSampleRate);
                            break;
                        case CONN_DST_PAN :
                            m_sDefaultPan = (short)
                                ((long) ((long) pConnection->lScale >> 12) / 125);
                            break;

                        /* DLS2 */
                        case CONN_DST_EG1_DELAYTIME:
                            m_VolumeEG.m_stDelay = TimeCents2Samples(
                                (TCENT) pConnection->lScale,dwSampleRate);
                            break;
                        case CONN_DST_EG1_HOLDTIME:
                            m_VolumeEG.m_stHold  = TimeCents2Samples(
                                (TCENT) pConnection->lScale,dwSampleRate);
                            break;
                        case CONN_DST_EG2_DELAYTIME:
                            m_PitchEG.m_stDelay  = TimeCents2Samples(
                                (TCENT) pConnection->lScale,dwSampleRate);
                            break;
                        case CONN_DST_EG2_HOLDTIME:
                            m_PitchEG.m_stHold   = TimeCents2Samples(
                                (TCENT) pConnection->lScale,dwSampleRate);
                            break;
                        case CONN_DST_VIB_FREQUENCY :
                            m_LFO2.m_pfFrequency = PitchCents2PitchFract(
                                pConnection->lScale,dwSampleRate);
                            break;
                        case CONN_DST_VIB_STARTDELAY :
                            m_LFO2.m_stDelay = TimeCents2Samples(
                                (TCENT) pConnection->lScale,dwSampleRate);
                            break;
                        case CONN_DST_FILTER_CUTOFF:
                            // First, get the filter cutoff frequency, which is relative to a440.
                            m_Filter.m_prCutoff = (PRELS)
                                (pConnection->lScale >> 16);
                            // Then, calculate the resulting prel, taking into consideration
                            // the sample rate and the base of the filter coefficient lookup
                            // table, relative to the sample rate (FILTER_FREQ_RANGE).
                            // This number can then be used directly look up the coefficients in the
                            // filter table.
                            m_Filter.m_prCutoffSRAdjust = (PRELS)
                                FILTER_FREQ_RANGE - m_Filter.m_prSampleRate + m_Filter.m_prCutoff;
                            break;
                        case CONN_DST_FILTER_Q:
                            m_Filter.m_vrQ = (VRELS)
                                (pConnection->lScale >> 16); //>>>>>>>> not really VRELS, but 1/10th's
                            m_Filter.m_iQIndex = (DWORD)
                                ((m_Filter.m_vrQ / 15.0f) + 0.5f);
                            break;
                        }
                        break;
                    case CONN_SRC_LFO :
                        switch (pConnection->usControl)
                        {
                        case CONN_SRC_NONE :
                            switch (pConnection->usDestination)
                            {
                            case CONN_DST_ATTENUATION :
                                m_LFO.m_vrVolumeScale = (VRELS)
                                    ((long) ((pConnection->lScale * 10) >> 16));
                                break;
                            case CONN_DST_PITCH :
                                m_LFO.m_prPitchScale = (PRELS)
                                    ((long) (pConnection->lScale >> 16));
                                break;

                            /* DLS2 */
                            case CONN_DST_FILTER_CUTOFF:
                                m_LFO.m_prCutoffScale = (PRELS)
                                    (pConnection->lScale >> 16);
                                break;
                            }
                            break;
                        case CONN_SRC_CC1 :
                            switch (pConnection->usDestination)
                            {
                            case CONN_DST_ATTENUATION :
                                m_LFO.m_vrMWVolumeScale = (VRELS)
                                    ((long) ((pConnection->lScale * 10) >> 16));
                                break;
                            case CONN_DST_PITCH :
                                m_LFO.m_prMWPitchScale = (PRELS)
                                    ((long) (pConnection->lScale >> 16));
                                break;

                            /* DLS2 */
                            case CONN_DST_FILTER_CUTOFF:
                                m_LFO.m_prMWCutoffScale = (PRELS)
                                    ((long) (pConnection->lScale >> 16));
                                break;
                            }
                            break;

                        /* DLS2 */
                        case CONN_SRC_CHANNELPRESSURE :
                            switch (pConnection->usDestination)
                            {
                            case CONN_DST_ATTENUATION :
                                m_LFO.m_vrCPVolumeScale = (VRELS)
                                    ((long) (pConnection->lScale >> 16));
                                break;
                            case CONN_DST_PITCH :
                                m_LFO.m_prCPPitchScale  = (PRELS)
                                    ((long) (pConnection->lScale >> 16));
                                break;

                            /* DLS2 */
                            case CONN_DST_FILTER_CUTOFF:
                                m_LFO.m_prCPCutoffScale = (PRELS)
                                    ((long) (pConnection->lScale >> 16));
                                break;
                            }
                            break;
                        }
                        break;
                    case CONN_SRC_KEYONVELOCITY :
                        switch (pConnection->usDestination)
                        {
                        case CONN_DST_EG1_ATTACKTIME :
                            m_VolumeEG.m_trVelAttackScale = (TRELS)
                                ((long) (pConnection->lScale >> 16));
                            break;
                        case CONN_DST_EG2_ATTACKTIME :
                            m_PitchEG.m_trVelAttackScale = (TRELS)
                                ((long) (pConnection->lScale >> 16));
                            break;

                        /* DLS2 */
                        case CONN_DST_FILTER_CUTOFF:
                            m_Filter.m_prVelScale = (PRELS)
                                ((long) (pConnection->lScale >> 16));
                            break;
                        }
                        break;
                    case CONN_SRC_KEYNUMBER :
                        switch (pConnection->usDestination)
                        {
                        case CONN_DST_EG1_DECAYTIME :
                            m_VolumeEG.m_trKeyDecayScale = (TRELS)
                                ((long) (pConnection->lScale >> 16));
                            break;
                        case CONN_DST_EG2_DECAYTIME :
                            m_PitchEG.m_trKeyDecayScale = (TRELS)
                                ((long) (pConnection->lScale >> 16));
                            break;

                        /* DLS2 */
                        case CONN_DST_EG1_HOLDTIME :
                            m_PitchEG.m_trKeyDecayScale = (TRELS)
                                ((long) (pConnection->lScale >> 16));
                            break;
                        case CONN_DST_EG2_HOLDTIME :
                            m_PitchEG.m_trKeyDecayScale = (TRELS)
                                ((long) (pConnection->lScale >> 16));
                        case CONN_DST_FILTER_CUTOFF :
                            m_Filter.m_prKeyScale = (PRELS)
                                ((long) (pConnection->lScale >> 16));
                            break;
                        }
                        break;
                    case CONN_SRC_EG2 :
                        switch (pConnection->usDestination)
                        {
                        case CONN_DST_PITCH :
                            m_PitchEG.m_sScale = (short)
                                ((long) (pConnection->lScale >> 16));
                            break;

                        /* DLS2 */
                        case CONN_DST_FILTER_CUTOFF:
                            m_PitchEG.m_prCutoffScale = (PRELS)
                                ((long) (pConnection->lScale >> 16));
                            break;
                        }
                        break;

                    /* DLS2 */
                    case CONN_SRC_VIBRATO :
                        switch (pConnection->usControl)
                        {
                        case CONN_SRC_NONE :
                            switch (pConnection->usDestination)
                            {
                            case CONN_DST_PITCH :
                                m_LFO2.m_prPitchScale = (PRELS)
                                    ((long) (pConnection->lScale >> 16));
                                break;
                            }
                            break;
                        case CONN_SRC_CC1 :
                            switch (pConnection->usDestination)
                            {
                            case CONN_DST_PITCH :
                                m_LFO2.m_prMWPitchScale = (PRELS)
                                    ((long) (pConnection->lScale >> 16));
                                break;
                            }
                            break;
                        case CONN_SRC_CHANNELPRESSURE :
                            switch (pConnection->usDestination)
                            {
                            case CONN_DST_PITCH :
                                m_LFO2.m_prCPPitchScale  = (PRELS)
                                    ((long) (pConnection->lScale >> 16));
                                break;
                            }
                            break;
                        }
                        break;
                    }
                }
            }
            if (pdmArtic->ulNextArtIdx)
            {
                if (pdmArtic->ulNextArtIdx >= pInfo->dwNumOffsetTableEntries)
                {
                    Trace(1,"Error: Download failed because articulation chunk has an error.\n");
                    return DMUS_E_BADARTICULATION;
                }
                pdmArtic = (DMUS_ARTICULATION2 *) pvOffsetTable[pdmArtic->ulNextArtIdx];
            }
            else
            {
                pdmArtic = NULL;
            }
        }
    }
    else
    {
        DMUS_ARTICULATION * pdmArtic =
            (DMUS_ARTICULATION *) pvOffsetTable[dwIndex];

        if (pdmArtic->ulArt1Idx)
        {
            if (pdmArtic->ulArt1Idx >= pInfo->dwNumOffsetTableEntries)
            {
                Trace(1,"Error: Download failed because articulation chunk has an error.\n");
                return DMUS_E_BADARTICULATION;
            }
            DMUS_ARTICPARAMS * pdmArticParams =
                (DMUS_ARTICPARAMS *) pvOffsetTable[pdmArtic->ulArt1Idx];

            m_LFO.m_pfFrequency = PitchCents2PitchFract(
                pdmArticParams->LFO.pcFrequency,dwSampleRate);
            m_LFO.m_stDelay = TimeCents2Samples(
                (TCENT) pdmArticParams->LFO.tcDelay,dwSampleRate);
            m_LFO.m_vrVolumeScale = (VRELS)
                ((long) ((pdmArticParams->LFO.gcVolumeScale * 10) >> 16));
            m_LFO.m_prPitchScale = (PRELS)
                ((long) (pdmArticParams->LFO.pcPitchScale >> 16));
            m_LFO.m_vrMWVolumeScale = (VRELS)
                ((long) ((pdmArticParams->LFO.gcMWToVolume * 10) >> 16));
            m_LFO.m_prMWPitchScale = (PRELS)
                ((long) (pdmArticParams->LFO.pcMWToPitch >> 16));

            m_VolumeEG.m_stAttack = TimeCents2Samples(
                (TCENT) pdmArticParams->VolEG.tcAttack,dwSampleRate);
            m_VolumeEG.m_stDecay = TimeCents2Samples(
                (TCENT) pdmArticParams->VolEG.tcDecay,dwSampleRate);
            m_VolumeEG.m_pcSustain =
                (SPERCENT) ((long) (pdmArticParams->VolEG.ptSustain >> 16));
            m_VolumeEG.m_stRelease = TimeCents2Samples(
                (TCENT) pdmArticParams->VolEG.tcRelease,dwSampleRate);
            m_VolumeEG.m_trVelAttackScale = (TRELS)
                ((long) (pdmArticParams->VolEG.tcVel2Attack >> 16));
            m_VolumeEG.m_trKeyDecayScale = (TRELS)
                ((long) (pdmArticParams->VolEG.tcKey2Decay >> 16));

            m_PitchEG.m_trKeyDecayScale = (TRELS)
                ((long) (pdmArticParams->PitchEG.tcKey2Decay >> 16));
            m_PitchEG.m_sScale = (short)
                ((long) (pdmArticParams->PitchEG.pcRange >> 16));
            m_PitchEG.m_trVelAttackScale = (TRELS)
                ((long) (pdmArticParams->PitchEG.tcVel2Attack >> 16));
            m_PitchEG.m_stAttack = TimeCents2Samples(
                (TCENT) pdmArticParams->PitchEG.tcAttack,dwSampleRate);
            m_PitchEG.m_stDecay = TimeCents2Samples(
                (TCENT) pdmArticParams->PitchEG.tcDecay,dwSampleRate);
            m_PitchEG.m_pcSustain =
                (SPERCENT) ((long) (pdmArticParams->PitchEG.ptSustain >> 16));
            m_PitchEG.m_stRelease = TimeCents2Samples(
                (TCENT) pdmArticParams->PitchEG.tcRelease,dwSampleRate);

            m_sDefaultPan = (short)
                ((long) ((long) pdmArticParams->Misc.ptDefaultPan >> 12) / 125);
        }
    }
    Verify();   // Make sure all parameters are legal.

    return S_OK;
}

HRESULT CSourceRegion::Download(DMUS_DOWNLOADINFO * pInfo,
                                void * pvOffsetTable[],
                                DWORD *pdwRegionIX,
                                DWORD dwSampleRate,
                                BOOL fNewFormat)
{
    DMUS_REGION * pdmRegion = (DMUS_REGION *) pvOffsetTable[*pdwRegionIX];
    *pdwRegionIX = pdmRegion->ulNextRegionIdx;  // Clear to avoid loops.
    pdmRegion->ulNextRegionIdx = 0;
    // Read the Region chunk...
    m_bKeyHigh = (BYTE) pdmRegion->RangeKey.usHigh;
    m_bKeyLow  = (BYTE) pdmRegion->RangeKey.usLow;
    m_bVelocityHigh = (BYTE) pdmRegion->RangeVelocity.usHigh;
    m_bVelocityLow  = (BYTE) pdmRegion->RangeVelocity.usLow;

    //
    // Fix DLS Designer bug
    // Designer was putting velocity ranges that fail
    // on DLS2 synths
    //
    if ( m_bVelocityHigh == 0 && m_bVelocityLow == 0 )
        m_bVelocityHigh = 127;

    if (pdmRegion->fusOptions & F_RGN_OPTION_SELFNONEXCLUSIVE)
    {
        m_bAllowOverlap = TRUE;
    }
    else
    {
        m_bAllowOverlap = FALSE;
    }
    m_bGroup = (BYTE) pdmRegion->usKeyGroup;
    // Now, the WSMP and WLOOP chunks...
    m_vrAttenuation = (short) ((long) ((pdmRegion->WSMP.lAttenuation) * 10) >> 16);
    m_Sample.m_prFineTune = pdmRegion->WSMP.sFineTune;
    m_Sample.m_bMIDIRootKey = (BYTE) pdmRegion->WSMP.usUnityNote;
    if (pdmRegion->WSMP.cSampleLoops == 0)
    {
        m_Sample.m_bOneShot = TRUE;
    }
    else
    {
        m_Sample.m_dwLoopStart = pdmRegion->WLOOP[0].ulStart;
        m_Sample.m_dwLoopEnd = m_Sample.m_dwLoopStart + pdmRegion->WLOOP[0].ulLength;
        m_Sample.m_bOneShot = FALSE;
        m_Sample.m_dwLoopType = pdmRegion->WLOOP[0].ulType;
    }
    m_Sample.m_dwSampleRate = dwSampleRate;

    m_sWaveLinkOptions = pdmRegion->WaveLink.fusOptions;
    m_dwChannel = pdmRegion->WaveLink.ulChannel;

    if ( (m_dwChannel != WAVELINK_CHANNEL_LEFT) && !IsMultiChannel() )
    {
        Trace(1, "Download failed: Attempt to use a non-mono channel without setting the multichannel flag.\n");
        return DMUS_E_NOTMONO;
    }

    m_Sample.m_dwID = (DWORD) pdmRegion->WaveLink.ulTableIndex;

    // Does it have its own articulation?
    //
    if (pdmRegion->ulRegionArtIdx )
    {
        if (pdmRegion->ulRegionArtIdx >= pInfo->dwNumOffsetTableEntries)
        {
            Trace(1,"Error: Download failed because articulation chunk has an error.\n");
            return DMUS_E_BADARTICULATION;
        }

        CSourceArticulation *pArticulation = new CSourceArticulation;
        if (pArticulation)
        {
            pArticulation->Init(dwSampleRate);
            HRESULT hr = pArticulation->Download(pInfo, pvOffsetTable,
                    pdmRegion->ulRegionArtIdx, dwSampleRate, fNewFormat);

            if (FAILED(hr))
            {
                delete pArticulation;
                return hr;
            }
            m_pArticulation = pArticulation;
            m_pArticulation->AddRef();
        }
        else
        {
            return E_OUTOFMEMORY;
        }
    }
    return S_OK;
}



HRESULT CInstManager::DownloadInstrument(LPHANDLE phDownload,
                                         DMUS_DOWNLOADINFO *pInfo,
                                         void *pvOffsetTable[],
                                         void *pvData,
                                         BOOL fNewFormat)

{
    DMUS_INSTRUMENT *pdmInstrument = (DMUS_INSTRUMENT *) pvData;
    CInstrument *pInstrument = new CInstrument;
    if (pInstrument)
    {
        Trace(3,"Downloading instrument %lx\n",pdmInstrument->ulPatch);
        pInstrument->m_dwProgram = pdmInstrument->ulPatch;

        DWORD dwRegionIX = pdmInstrument->ulFirstRegionIdx;
        pdmInstrument->ulFirstRegionIdx = 0; // Clear to avoid loops.
        while (dwRegionIX)
        {
            if (dwRegionIX >= pInfo->dwNumOffsetTableEntries)
            {
                Trace(1,"Error: Download failed because instrument has error in region list.\n");
                delete pInstrument;
                return DMUS_E_BADINSTRUMENT;
            }
            CSourceRegion *pRegion = new CSourceRegion;
            if (!pRegion)
            {
                delete pInstrument;
                return E_OUTOFMEMORY;
            }
            pInstrument->m_RegionList.AddHead(pRegion);
            HRESULT hr = pRegion->Download(pInfo, pvOffsetTable, &dwRegionIX, m_dwSampleRate, fNewFormat);
            if (FAILED(hr))
            {
                delete pInstrument;
                return hr;
            }
            EnterCriticalSection(&m_CriticalSection);
            CWave *pWave = m_WavePool[pRegion->m_Sample.m_dwID % WAVE_HASH_SIZE].GetHead();
            for (;pWave;pWave = pWave->GetNext())
            {
                if (pRegion->m_Sample.m_dwID == pWave->m_dwID)
                {
                    pRegion->m_Sample.m_pWave = pWave;
                    pWave->AddRef();
                    pRegion->m_Sample.CopyFromWave();
                    break;
                }
            }
            LeaveCriticalSection(&m_CriticalSection);
        }
        if (pdmInstrument->ulGlobalArtIdx)
        {
            if (pdmInstrument->ulGlobalArtIdx >= pInfo->dwNumOffsetTableEntries)
            {
                Trace(1,"Error: Download failed because of out of range articulation chunk.\n");
                delete pInstrument;
                return DMUS_E_BADARTICULATION;
            }

            CSourceArticulation *pArticulation = new CSourceArticulation;
            if (pArticulation)
            {
                pArticulation->Init(m_dwSampleRate);
                HRESULT hr = pArticulation->Download(pInfo, pvOffsetTable,
                        pdmInstrument->ulGlobalArtIdx, m_dwSampleRate, fNewFormat);
                if (FAILED(hr))
                {
                    delete pArticulation;
                    return hr;
                }
                for (CSourceRegion *pr = pInstrument->m_RegionList.GetHead();
                     pr != NULL;
                     pr = pr->GetNext())
                {
                    if (pr->m_pArticulation == NULL)
                    {
                        pr->m_pArticulation = pArticulation;
                        pArticulation->AddRef();
                    }
                }
                if (!pArticulation->m_wUsageCount)
                {
                    delete pArticulation;
                }
            }
            else
            {
                return E_OUTOFMEMORY;
            }
        }
        else
        {
            for (CSourceRegion *pr = pInstrument->m_RegionList.GetHead();
                 pr != NULL;
                 pr = pr->GetNext())
            {
                if (pr->m_pArticulation == NULL)
                {
                    Trace(1,"Error: Download failed because region has no articulation.\n");
                    delete pInstrument;
                    return DMUS_E_NOARTICULATION;
                }
            }
        }
        EnterCriticalSection(&m_CriticalSection);
        if (pdmInstrument->ulFlags & DMUS_INSTRUMENT_GM_INSTRUMENT)
        {
            pInstrument->SetNext(NULL);
            m_InstrumentList[pInstrument->m_dwProgram % INSTRUMENT_HASH_SIZE].AddTail(pInstrument);
        }
        else
        {
            m_InstrumentList[pInstrument->m_dwProgram % INSTRUMENT_HASH_SIZE].AddHead(pInstrument);
        }
        LeaveCriticalSection(&m_CriticalSection);
        *phDownload = (HANDLE) pInstrument;
        return S_OK;
    }
    return E_OUTOFMEMORY;
}

HRESULT CInstManager::DownloadWave(LPHANDLE phDownload,
                                   DMUS_DOWNLOADINFO *pInfo,
                                   void *pvOffsetTable[],
                                   void *pvData)
{
    DMUS_WAVE *pdmWave = (DMUS_WAVE *) pvData;
    if (pdmWave->WaveformatEx.wFormatTag != WAVE_FORMAT_PCM)
    {
        Trace(1,"Error: Download failed because wave data is not PCM format.\n");
        return DMUS_E_NOTPCM;
    }

    if (pdmWave->WaveformatEx.nChannels != 1)
    {
        Trace(1,"Error: Download failed because wave data is not mono.\n");
        return DMUS_E_NOTMONO;
    }

    if (pdmWave->ulWaveDataIdx >= pInfo->dwNumOffsetTableEntries)
    {
        Trace(1,"Error: Download failed because wave data is at invalid location.\n");
        return DMUS_E_BADWAVE;
    }

    CWave *pWave = new CWave;
    if (pWave)
    {
        DMUS_WAVEDATA *pdmWaveData= (DMUS_WAVEDATA *)
            pvOffsetTable[pdmWave->ulWaveDataIdx];
        pWave->m_dwID = pInfo->dwDLId;
        pWave->m_hUserData = NULL;
        pWave->m_lpFreeHandle = NULL;
        pWave->m_dwSampleLength = pdmWaveData->cbSize;
        pWave->m_pnWave = (short *) &pdmWaveData->byData[0];
        pWave->m_dwSampleRate = pdmWave->WaveformatEx.nSamplesPerSec;

        if (pdmWave->WaveformatEx.wBitsPerSample == 8)
        {
            pWave->m_bSampleType = SFORMAT_8;
            DWORD dwX;
            char *pData = (char *) &pdmWaveData->byData[0];
            for (dwX = 0; dwX < pWave->m_dwSampleLength; dwX++)
            {
                pData[dwX] -= (char) 128;
            }
        }
        else if (pdmWave->WaveformatEx.wBitsPerSample == 16)
        {
            pWave->m_dwSampleLength >>= 1;
            pWave->m_bSampleType = SFORMAT_16;
        }
        else
        {
            Trace(1,"Error: Downloading wave %ld, bad wave format.\n",pInfo->dwDLId);
            delete pWave;
            return DMUS_E_BADWAVE;
        }
        pWave->m_dwSampleLength++;  // We always add one sample to the end for interpolation.
        EnterCriticalSection(&m_CriticalSection);
        m_WavePool[pWave->m_dwID % WAVE_HASH_SIZE].AddHead(pWave);
        LeaveCriticalSection(&m_CriticalSection);
        *phDownload = (HANDLE) pWave;
        pWave->AddRef();

        // Track memory usage
        m_dwSynthMemUse += (pWave->m_bSampleType == SFORMAT_16)?pWave->m_dwSampleLength << 1: pWave->m_dwSampleLength;
        Trace(3,"Downloading wave %ld memory usage %ld\n",pInfo->dwDLId,m_dwSynthMemUse);

        return S_OK;
    }
    return E_OUTOFMEMORY;
}

HRESULT CInstManager::Download(LPHANDLE phDownload,
                               void * pvData,
                               LPBOOL pbFree)


{
    V_INAME(IDirectMusicSynth::Download);
    V_BUFPTR_READ(pvData,sizeof(DMUS_DOWNLOADINFO));

    HRESULT hr = DMUS_E_UNKNOWNDOWNLOAD;
    void ** ppvOffsetTable;     // Array of pointers to chunks in data.
    DMUS_DOWNLOADINFO * pInfo = (DMUS_DOWNLOADINFO *) pvData;
    DMUS_OFFSETTABLE* pOffsetTable = (DMUS_OFFSETTABLE *)(((BYTE*)pvData) + sizeof(DMUS_DOWNLOADINFO));
    char *pcData = (char *) pvData;

    V_BUFPTR_READ(pvData,pInfo->cbSize);

    // Code fails if pInfo->dwNumOffsetTableEntries == 0
    // Sanity check here for debug
    assert(pInfo->dwNumOffsetTableEntries);

    ppvOffsetTable = new void *[pInfo->dwNumOffsetTableEntries];
    if (ppvOffsetTable) // Create the pointer array and validate.
    {
        DWORD dwIndex;
        for (dwIndex = 0; dwIndex < pInfo->dwNumOffsetTableEntries; dwIndex++)
        {
            if (pOffsetTable->ulOffsetTable[dwIndex] >= pInfo->cbSize)
            {
                delete[] ppvOffsetTable;
                Trace(1,"Error: Download failed because of corrupt download tables.\n");
                return DMUS_E_BADOFFSETTABLE;   // Bad!
            }
            ppvOffsetTable[dwIndex] = (void *) &pcData[pOffsetTable->ulOffsetTable[dwIndex]];
        }
        if (pInfo->dwDLType == DMUS_DOWNLOADINFO_INSTRUMENT) // Instrument.
        {
            *pbFree = TRUE;
            hr = DownloadInstrument(phDownload, pInfo, ppvOffsetTable, ppvOffsetTable[0],FALSE);
        }
        else if (pInfo->dwDLType == DMUS_DOWNLOADINFO_INSTRUMENT2) // New instrument format.
        {
            *pbFree = TRUE;
            hr = DownloadInstrument(phDownload, pInfo, ppvOffsetTable, ppvOffsetTable[0],TRUE);
        }
        else if (pInfo->dwDLType == DMUS_DOWNLOADINFO_WAVE) // Wave.
        {
            *pbFree = FALSE;
            hr = DownloadWave(phDownload, pInfo, ppvOffsetTable, ppvOffsetTable[0]);
        }
        else if (pInfo->dwDLType == DMUS_DOWNLOADINFO_WAVEARTICULATION) // Wave onshot & streaming
        {
            *pbFree = TRUE;
            hr = DownloadWaveArticulation(phDownload, pInfo, ppvOffsetTable, ppvOffsetTable[0]);
        }
        else if (pInfo->dwDLType == DMUS_DOWNLOADINFO_STREAMINGWAVE) // Streaming
        {
            *pbFree = FALSE;
            hr = DownloadWaveRaw(phDownload, pInfo, ppvOffsetTable, ppvOffsetTable[0]);
        }
        else if (pInfo->dwDLType == DMUS_DOWNLOADINFO_ONESHOTWAVE) // Wave onshot
        {
            *pbFree = FALSE;
            hr = DownloadWaveRaw(phDownload, pInfo, ppvOffsetTable, ppvOffsetTable[0]);
        }

        delete[] ppvOffsetTable;
    }
    else
    {
        hr = E_OUTOFMEMORY;
    }
    return hr;
}

HRESULT CInstManager::Unload(HANDLE hDownload,
                             HRESULT ( CALLBACK *lpFreeHandle)(HANDLE,HANDLE),
                             HANDLE hUserData)

{
    DWORD dwIndex;
    EnterCriticalSection(&m_CriticalSection);
    for (dwIndex = 0; dwIndex < INSTRUMENT_HASH_SIZE; dwIndex++)
    {
        CInstrument *pInstrument = m_InstrumentList[dwIndex].GetHead();
        for (;pInstrument != NULL; pInstrument = pInstrument->GetNext())
        {
            if (pInstrument == (CInstrument *) hDownload)
            {
                Trace(3,"Unloading instrument %lx\n",pInstrument->m_dwProgram);
                m_InstrumentList[dwIndex].Remove(pInstrument);
                delete pInstrument;
                LeaveCriticalSection(&m_CriticalSection);
                return S_OK;
            }
        }
    }
    for (dwIndex = 0; dwIndex < WAVE_HASH_SIZE; dwIndex++)
    {
        CWave *pWave = m_WavePool[dwIndex].GetHead();
        for (;pWave != NULL;pWave = pWave->GetNext())
        {
            if (pWave == (CWave *) hDownload)
            {
                // Track memory usage
                m_dwSynthMemUse -= (pWave->m_bSampleType == SFORMAT_16)?pWave->m_dwSampleLength << 1: pWave->m_dwSampleLength;

                Trace(3,"Unloading wave %ld memory usage %ld\n",pWave->m_dwID,m_dwSynthMemUse);
                m_WavePool[dwIndex].Remove(pWave);

                pWave->m_hUserData = hUserData;
                pWave->m_lpFreeHandle = lpFreeHandle;
                pWave->Release();
                LeaveCriticalSection(&m_CriticalSection);
                return S_OK;
            }
        }
    }
    for (dwIndex = 0; dwIndex < WAVE_HASH_SIZE; dwIndex++)
    {
        CWaveArt* pWaveArt = m_WaveArtList[dwIndex].GetHead();
        for (;pWaveArt != NULL;pWaveArt = pWaveArt->GetNext())
        {
            if (pWaveArt == (CWaveArt *) hDownload)
            {
                Trace(3,"Unloading wave articulation %ld\n",pWaveArt->m_dwID,m_dwSynthMemUse);
                m_WaveArtList[dwIndex].Remove(pWaveArt);

                pWaveArt->Release();
                LeaveCriticalSection(&m_CriticalSection);
                return S_OK;
            }
        }
    }
    LeaveCriticalSection(&m_CriticalSection);
    Trace(1,"Error: Unload failed - downloaded object not found.\n");
    return E_FAIL;
}

//////////////////////////////////////////////////////////
// Directx8 Methods

CWave * CInstManager::GetWave(DWORD dwDLId)
{
    EnterCriticalSection(&m_CriticalSection);
    CWave *pWave = m_WavePool[dwDLId % WAVE_HASH_SIZE].GetHead();
    for (;pWave;pWave = pWave->GetNext())
    {
        if (dwDLId == pWave->m_dwID)
        {
            break;
        }
    }
    LeaveCriticalSection(&m_CriticalSection);

    return pWave;
}

CWaveArt *  CInstManager::GetWaveArt(DWORD dwDLId)
{
    EnterCriticalSection(&m_CriticalSection);
    CWaveArt *pWaveArt = m_WaveArtList[dwDLId % WAVEART_HASH_SIZE].GetHead();
    for (;pWaveArt;pWaveArt = pWaveArt->GetNext())
    {
        if (dwDLId == pWaveArt->m_dwID)
        {
            break;
        }
    }
    LeaveCriticalSection(&m_CriticalSection);

    return pWaveArt;
}

HRESULT CInstManager::DownloadWaveArticulation(LPHANDLE phDownload,
                                   DMUS_DOWNLOADINFO *pInfo,
                                   void *pvOffsetTable[],
                                   void *pvData)
{
    DMUS_WAVEARTDL* pWaveArtDl  = (DMUS_WAVEARTDL*)pvData;
    WAVEFORMATEX *pWaveformatEx = (WAVEFORMATEX *) pvOffsetTable[1];
    DWORD *dwDlId = (DWORD*)pvOffsetTable[2];
    DWORD i;

    CWaveArt* pWaveArt = new CWaveArt();
    if ( pWaveArt )
    {
        pWaveArt->m_dwID = pInfo->dwDLId;
        pWaveArt->m_WaveArtDl = *pWaveArtDl;;
        pWaveArt->m_WaveformatEx = *pWaveformatEx;
        if (pWaveformatEx->wBitsPerSample == 8)
        {
            pWaveArt->m_bSampleType = SFORMAT_8;
        }
        else if (pWaveformatEx->wBitsPerSample == 16)
        {
            pWaveArt->m_bSampleType = SFORMAT_16;
        }
        else
        {
            Trace(1,"Error: Download failed because wave data is %ld bits instead of 8 or 16.\n",(long) pWaveformatEx->wBitsPerSample);
            delete pWaveArt;
            return DMUS_E_BADWAVE;
        }

        for ( i = 0; i < pWaveArtDl->ulBuffers; i++ )
        {
            // Get wave buffer and fill header with waveformat data
            CWave *pWave = GetWave(dwDlId[i]);
            assert(pWave);

            if (!pWave)
            {
                delete pWaveArt;
                return E_POINTER;
            }

            pWave->m_dwSampleRate = pWaveformatEx->nSamplesPerSec;

            if (pWaveformatEx->wBitsPerSample == 8)
            {
                DWORD dwX;
                char *pData = (char *) pWave->m_pnWave;
                for (dwX = 0; dwX < pWave->m_dwSampleLength; dwX++)
                {
                    pData[dwX] -= (char) 128;
                }
                pWave->m_bSampleType = SFORMAT_8;
            }
            else if (pWaveformatEx->wBitsPerSample == 16)
            {
                pWave->m_dwSampleLength >>= 1;
                pWave->m_bSampleType = SFORMAT_16;
            }
            else
            {
                Trace(1,"Error: Download failed because wave data is %ld bits instead of 8 or 16.\n",(long) pWaveformatEx->wBitsPerSample);
                delete pWaveArt;
                return DMUS_E_BADWAVE;
            }
            pWave->m_dwSampleLength++;  // We always add one sample to the end for interpolation.

            // Default is to duplicate last sample. This will be overrwritten for
            // streaming waves.
            //
            if (pWave->m_dwSampleLength > 1)
            {
                if (pWave->m_bSampleType == SFORMAT_8)
                {
                    char* pb = (char*)pWave->m_pnWave;
                    pb[pWave->m_dwSampleLength - 1] = pb[pWave->m_dwSampleLength - 2];
                }
                else
                {
                    short *pn = pWave->m_pnWave;
                    pn[pWave->m_dwSampleLength - 1] = pn[pWave->m_dwSampleLength - 2];
                }
            }

            // Create a WaveBuffer listitem and save the wave in and add it to the circular buffer list
            CWaveBuffer* pWavBuf = new CWaveBuffer();
            if ( pWavBuf == NULL )
            {
                delete pWaveArt;
                return E_OUTOFMEMORY;
            }
            pWavBuf->m_pWave = pWave;

            // This Articulation will be handling streaming data
            if ( pWave->m_bStream )
                pWaveArt->m_bStream = TRUE;

            pWaveArt->m_pWaves.AddTail(pWavBuf);
        }

        EnterCriticalSection(&m_CriticalSection);
        if (pWaveArt)
        {
            CWaveBuffer* pCurrentBuffer = pWaveArt->m_pWaves.GetHead();
            for (; pCurrentBuffer; pCurrentBuffer = pCurrentBuffer->GetNext() )
            {
                if (pCurrentBuffer->m_pWave)
                {
                    pCurrentBuffer->m_pWave->AddRef();
                }
            }
        }
        m_WaveArtList[pWaveArt->m_dwID % WAVEART_HASH_SIZE].AddHead(pWaveArt);
        LeaveCriticalSection(&m_CriticalSection);

        *phDownload = (HANDLE) pWaveArt;

        return S_OK;
    }
    return E_OUTOFMEMORY;
}

HRESULT CInstManager::DownloadWaveRaw(LPHANDLE phDownload,
                                   DMUS_DOWNLOADINFO *pInfo,
                                   void *pvOffsetTable[],
                                   void *pvData)
{
    CWave *pWave = new CWave;
    if (pWave)
    {
        DMUS_WAVEDATA *pdmWaveData= (DMUS_WAVEDATA *)pvData;
        Trace(3,"Downloading raw wave data%ld\n",pInfo->dwDLId);

        pWave->m_dwID = pInfo->dwDLId;
        pWave->m_hUserData = NULL;
        pWave->m_lpFreeHandle = NULL;
        pWave->m_dwSampleLength = pdmWaveData->cbSize;
        pWave->m_pnWave = (short *) &pdmWaveData->byData[0];

        if ( pInfo->dwDLType == DMUS_DOWNLOADINFO_STREAMINGWAVE )
        {
            pWave->m_bStream = TRUE;
            pWave->m_bValid = TRUE;
        }

        EnterCriticalSection(&m_CriticalSection);
        m_WavePool[pWave->m_dwID % WAVE_HASH_SIZE].AddHead(pWave);
        LeaveCriticalSection(&m_CriticalSection);

        *phDownload = (HANDLE) pWave;
        pWave->AddRef();

        m_dwSynthMemUse += pWave->m_dwSampleLength;

        return S_OK;
    }
    return E_OUTOFMEMORY;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\XboxSynth\midi.cpp ===
//      Copyright (c) 1996-1999 Microsoft Corporation
//      MIDI.cpp
//

#ifdef DMSYNTH_MINIPORT
#include "common.h"
#else
#include "simple.h"
#include <mmsystem.h>
#include "synth.h"
#include "math.h"
#include "debug.h"
#endif
 
CMIDIDataList    CMIDIRecorder::m_sFreeList;
DWORD            CMIDIRecorder::m_sUsageCount = 0;

CMIDIData::CMIDIData() 
{
    m_stTime = 0;
    m_lData = 0;            
}


CMIDIRecorder::CMIDIRecorder()
{
    m_sUsageCount++;
    m_lCurrentData = 0;
    m_stCurrentTime = 0;
}

CMIDIRecorder::~CMIDIRecorder()

{
    ClearMIDI(0x7FFFFFFF);
     m_sUsageCount--;
    // If there are no instances of CMIDIRecorder left, get rid of the free pool.
    if (!m_sUsageCount)
    {
        CMIDIData *pMD;
        while (pMD = m_sFreeList.RemoveHead())
        {
            delete pMD;
        }
    }
}

VREL CMIDIRecorder::m_vrMIDIToVREL[128] = 
{
    -9600, -8415, -7211, -6506, -6006, -5619, -5302, -5034, 
    -4802, -4598, -4415, -4249, -4098, -3959, -3830, -3710, 
    -3598, -3493, -3394, -3300, -3211, -3126, -3045, -2968, 
    -2894, -2823, -2755, -2689, -2626, -2565, -2506, -2449, 
    -2394, -2341, -2289, -2238, -2190, -2142, -2096, -2050, 
    -2006, -1964, -1922, -1881, -1841, -1802, -1764, -1726, 
    -1690, -1654, -1619, -1584, -1551, -1518, -1485, -1453, 
    -1422, -1391, -1361, -1331, -1302, -1273, -1245, -1217, 
    -1190, -1163, -1137, -1110, -1085, -1059, -1034, -1010, 
    -985, -961, -938, -914, -891, -869, -846, -824, 
    -802, -781, -759, -738, -718, -697, -677, -657, 
    -637, -617, -598, -579, -560, -541, -522, -504, 
    -486, -468, -450, -432, -415, -397, -380, -363, 
    -347, -330, -313, -297, -281, -265, -249, -233, 
    -218, -202, -187, -172, -157, -142, -127, -113, 
    -98, -84, -69, -55, -41, -27, -13, 0
};

VREL CMIDIRecorder::m_vrMIDIPercentToVREL[128] = 
{
    -9600, -4207, -3605, -3253, -3003, -2809, -2651, -2517, 
    -2401, -2299, -2207, -2124, -2049, -1979, -1915, -1855, 
    -1799, -1746, -1697, -1650, -1605, -1563, -1522, -1484, 
    -1447, -1411, -1377, -1344, -1313, -1282, -1253, -1224, 
    -1197, -1170, -1144, -1119, -1095, -1071, -1048, -1025, 
    -1003, -982, -961, -940, -920, -901, -882, -863, 
    -845, -827, -809, -792, -775, -759, -742, -726, 
    -711, -695, -680, -665, -651, -636, -622, -608, 
    -595, -581, -568, -555, -542, -529, -517, -505, 
    -492, -480, -469, -457, -445, -434, -423, -412, 
    -401, -390, -379, -369, -359, -348, -338, -328, 
    -318, -308, -299, -289, -280, -270, -261, -252, 
    -243, -234, -225, -216, -207, -198, -190, -181, 
    -173, -165, -156, -148, -140, -132, -124, -116, 
    -109, -101, -93, -86, -78, -71, -63, -56, 
    -49, -42, -34, -27, -20, -13, -6, 0 
};

/*void CMIDIRecorder::Init()
{
    int nIndex;
    static BOOL fAlreadyDone = FALSE;
    if (!fAlreadyDone)
    {
        m_sFreeList.RemoveAll();
        for (nIndex = 0; nIndex < MAX_MIDI_EVENTS; nIndex++)
        {
            m_sFreeList.AddHead(&m_sEventBuffer[nIndex]);
        }
        fAlreadyDone = TRUE;*/
/*		for (nIndex = 1; nIndex < 128; nIndex++)
		{
			double   flTemp;
			flTemp = nIndex;
			flTemp /= 127.0;
			flTemp = pow(flTemp,4.0);
			flTemp = log10(flTemp);
			flTemp *= 1000.0;
            Trace(0,"%ld, ",(long)flTemp);
            if ((nIndex % 8) == 7)
                Trace(0,"\n");
			m_vrMIDIToVREL[nIndex] = (VREL) flTemp;
		}
        Trace(0,"\n");
		m_vrMIDIToVREL[0] = -9600;
        for (nIndex = 1; nIndex < 128; nIndex++)
        {
            double flTemp;
            flTemp = nIndex;
            flTemp /= 127;
            flTemp *= flTemp;
            flTemp = log10(flTemp);
            flTemp *= 1000.0;
            m_vrMIDIPercentToVREL[nIndex] = (VREL) flTemp;
            Trace(0,"%ld, ",(long)flTemp);
            if ((nIndex % 8) == 7)
                Trace(0,"\n");
        }
        m_vrMIDIPercentToVREL[0] = -9600;*/
    /*}
}*/

BOOL CMIDIRecorder::FlushMIDI(STIME stTime)
{
    CMIDIData *pMD;
    CMIDIData *pLast = NULL;
    for (pMD = m_EventList.GetHead();pMD != NULL;pMD = pMD->GetNext())
    {
        if (pMD->m_stTime >= stTime)
        {
            if (pLast == NULL)
            {
                m_EventList.RemoveAll();
            }
            else
            {
                pLast->SetNext(NULL);
            }
            m_sFreeList.Cat(pMD);
            break;
        }
        pLast = pMD;
    }
    return m_EventList.IsEmpty();
}

BOOL CMIDIRecorder::ClearMIDI(STIME stTime)

{
    CMIDIData *pMD;
    for (;pMD = m_EventList.GetHead();)
    {
        if (pMD->m_stTime < stTime)
        {
            m_EventList.RemoveHead();
            m_stCurrentTime = pMD->m_stTime;
            m_lCurrentData = pMD->m_lData;
            m_sFreeList.AddHead(pMD);
            
        }
        else break;
    }
    return m_EventList.IsEmpty();
}

VREL CMIDIRecorder::VelocityToVolume(WORD nVelocity)

{
    return (m_vrMIDIToVREL[nVelocity]);
}

BOOL CMIDIRecorder::RecordMIDINote(STIME stTime, long lData)

{
    CMIDIData *pMD = m_sFreeList.RemoveHead();
    if (!pMD)
    {
        pMD = new CMIDIData;
    }

	CMIDIData *pScan = m_EventList.GetHead();
	CMIDIData *pNext;
    if (pMD)
    {
        pMD->m_stTime = stTime;
        pMD->m_lData = lData;
		if (pScan == NULL)
		{
			m_EventList.AddHead(pMD);
		}
		else
		{
			if (pScan->m_stTime > stTime)
			{
				m_EventList.AddHead(pMD);
			}
			else
			{
				for (;pScan != NULL; pScan = pNext)
				{
					pNext = pScan->GetNext();
					if (pNext == NULL)
					{
						pScan->SetNext(pMD);
					}
					else
					{
						if (pNext->m_stTime > stTime)
						{
							pMD->SetNext(pNext);
							pScan->SetNext(pMD);
							break;
						}
					}
				}
			}
		}
        return (TRUE);
    }
    return (FALSE);
}

BOOL CMIDIRecorder::RecordMIDI(STIME stTime, long lData)

{
    CMIDIData *pMD = m_sFreeList.RemoveHead();
    if (!pMD)
    {
        pMD = new CMIDIData;
    }

	CMIDIData *pScan = m_EventList.GetHead();
	CMIDIData *pNext;
    if (pMD)
    {
        pMD->m_stTime = stTime;
        pMD->m_lData = lData;
		if (pScan == NULL)
		{
			m_EventList.AddHead(pMD);
		}
		else
		{
			if (pScan->m_stTime > stTime)
			{
				m_EventList.AddHead(pMD);
			}
			else
			{
				for (;pScan != NULL; pScan = pNext)
				{
                    if ((pScan->m_stTime == stTime) && 
                        (pScan->m_lData == lData))
                    {
                        m_sFreeList.AddHead(pMD);
                        break;
                    }
					pNext = pScan->GetNext();
					if (pNext == NULL)
					{
						pScan->SetNext(pMD);
					}
					else
					{
						if (pNext->m_stTime > stTime)
						{
							pMD->SetNext(pNext);
							pScan->SetNext(pMD);
							break;
						}
					}
				}
			}
		}
        return (TRUE);
    }
/*#ifdef DBG
    static gWarnCount = 0;
    if (!gWarnCount)
    {
        Trace(1,"Warning: MIDI Free event pool empty. This can be caused by time stamping problems, too much MIDI data, or too many PChannels.\n");
        gWarnCount = 100;
    }
    gWarnCount--;
#endif*/
    return (FALSE);
}

long CMIDIRecorder::GetData(STIME stTime)

{
    CMIDIData *pMD = m_EventList.GetHead();
    long lData = m_lCurrentData;
    for (;pMD;pMD = pMD->GetNext())
    {
        if (pMD->m_stTime > stTime)
        {
            break;
        }
        lData = pMD->m_lData;
    }
    return (lData);
}

BOOL CNoteIn::RecordNote(STIME stTime, CNote * pNote)

{
	long lData = pNote->m_bPart << 16;
	lData |= pNote->m_bKey << 8;
	lData |= pNote->m_bVelocity;
	return (RecordMIDINote(stTime,lData));
}

BOOL CNoteIn::RecordEvent(STIME stTime, DWORD dwPart, DWORD dwCommand, BYTE bData)

{
	long lData = dwPart;
	lData <<= 8;
	lData |= dwCommand;
	lData <<= 8;
	lData |= bData;
	return (RecordMIDINote(stTime,lData));	
}

BOOL CNoteIn::GetNote(STIME stTime, CNote * pNote)

{
    CMIDIData *pMD = m_EventList.GetHead();
	if (pMD != NULL)
	{
		if (pMD->m_stTime <= stTime)
		{
			pNote->m_stTime = pMD->m_stTime;
			pNote->m_bPart = (BYTE) (pMD->m_lData >> 16);
			pNote->m_bKey = (BYTE) (pMD->m_lData >> 8) & 0xFF;
			pNote->m_bVelocity = (BYTE) pMD->m_lData & 0xFF;
            m_EventList.RemoveHead();
            m_sFreeList.AddHead(pMD);
			return (TRUE);
		}
	}
	return (FALSE);
}

void CNoteIn::FlushMIDI(STIME stTime)

{
    CMIDIData *pMD;
    for (pMD = m_EventList.GetHead();pMD != NULL;pMD = pMD->GetNext())
    {
        if (pMD->m_stTime >= stTime)
        {
            pMD->m_stTime = stTime;     // Play now.
            pMD->m_lData &= 0xFFFFFF00; // Clear velocity to make note off.
        }
    }
}


void CNoteIn::FlushPart(STIME stTime, BYTE bChannel)

{
    CMIDIData *pMD;
    for (pMD = m_EventList.GetHead();pMD != NULL;pMD = pMD->GetNext())
    {
        if (pMD->m_stTime >= stTime)
        {
			if (bChannel == (BYTE) (pMD->m_lData >> 16))
			{
				pMD->m_stTime = stTime;     // Play now.
				pMD->m_lData &= 0xFFFFFF00; // Clear velocity to make note off.
			}
		}
    }
}

DWORD CModWheelIn::GetModulation(STIME stTime)

{
    DWORD nResult = CMIDIRecorder::GetData(stTime);
    return (nResult);
}

CPitchBendIn::CPitchBendIn()

{
    m_lCurrentData = 0x2000;	// initially at midpoint, no bend
    m_prRange = 200;           // whole tone range by default.
}

// note (davidmay 8/14/96): we don't keep a time-stamped range.
// if people are changing the pitch bend range often, this won't work right,
// but that didn't seem likely enough to warrant a new list.
PREL CPitchBendIn::GetPitch(STIME stTime)

{
    PREL prResult = (PREL) CMIDIRecorder::GetData(stTime);
    prResult -= 0x2000;         // Subtract MIDI Midpoint.
    prResult *= m_prRange;	// adjust by current range
    prResult >>= 13;
    return (prResult);
}

CVolumeIn::CVolumeIn()

{
    m_lCurrentData = 100;
}

VREL CVolumeIn::GetVolume(STIME stTime)

{
    long lResult = CMIDIRecorder::GetData(stTime);
    return (m_vrMIDIToVREL[lResult]);
}

CExpressionIn::CExpressionIn()

{
    m_lCurrentData = 127;
}

VREL CExpressionIn::GetVolume(STIME stTime)

{
    long lResult = CMIDIRecorder::GetData(stTime);
    return (m_vrMIDIToVREL[lResult]);
}

CPanIn::CPanIn()

{
    m_lCurrentData = 64;
}

long CPanIn::GetPan(STIME stTime)

{
    long lResult = (long) CMIDIRecorder::GetData(stTime);
    return (lResult);
}

//////////////////////////////////////////////////////////
// Directx8 Methods 

DWORD CPressureIn::GetPressure(STIME stTime)

{
    DWORD nResult = CMIDIRecorder::GetData(stTime);
    return (nResult);
}

CReverbIn::CReverbIn()

{
    m_lCurrentData = 40;
}

DWORD CReverbIn::GetVolume(STIME stTime)

{
    return (m_vrMIDIPercentToVREL[CMIDIRecorder::GetData(stTime)]);
}

DWORD CChorusIn::GetVolume(STIME stTime)

{
    return (m_vrMIDIPercentToVREL[CMIDIRecorder::GetData(stTime)]);
}

CCutOffFreqIn::CCutOffFreqIn()
{
	m_lCurrentData = 64;
}

DWORD CCutOffFreqIn::GetFrequency(STIME stTime)
{
    DWORD nResult = CMIDIRecorder::GetData(stTime);
    return (nResult);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\XboxSynth\misc.h ===
//      Copyright (c) 1996-1999 Microsoft Corporation
// Misc.h
//
// functions used in multiple DLL's

#ifndef __MISC_H__
#define __MISC_H__

//LPVOID MemGlobalAllocPtr(UINT uFlags,DWORD dwBytes);
//BOOL MemGlobalFreePtr(LPVOID p);

// memory functions
//HRESULT MemStart();
//void MemEnd();

/*#ifdef _DEBUGMEM
#ifndef new
void* operator new( size_t cb, LPCTSTR pszFileName, WORD wLine );
#define new new( __FILE__, (WORD)__LINE__ )
#endif
#endif*/

#ifdef DBG
#define RELEASE( obj ) ( (obj)->Release(), *((char**)&(obj)) = (char*)0x0bad0bad )
#else
#define RELEASE( obj ) (obj)->Release()
#endif

BOOL GetRegValueDword(
    LPCTSTR szRegPath,
    LPCTSTR szValueName,
    LPDWORD pdwValue);

ULONG GetTheCurrentTime();

#endif // __MISC_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\XboxSynth\oledll.h ===
// Copyright (c) 1998-1999 Microsoft Corporation
//
//
//
#ifndef _OLEDLL_
#define _OLEDLL_

STDAPI
RegisterServer(HMODULE hModule,
               const CLSID &clsid,
               const TCHAR *szFriendlyName,
               const TCHAR *szVerIndProgID,
               const TCHAR *szProgID);

STDAPI
UnregisterServer(const CLSID &clsid,
                 const TCHAR *szFriendlyName,
                 const TCHAR *szVerIndProgID,
                 const TCHAR *szProgID);

BOOL
GetCLSIDRegValue(const CLSID &clsid,
				 const TCHAR *szKey,
				 LPVOID pValue,
				 LPDWORD pcbValue);
				 
HRESULT CLSIDToStr(const CLSID &clsid,
				   TCHAR *szStr,
				   int cbStr);

HRESULT StrToCLSID(TCHAR *szStr,
				   CLSID &clsid,
				   int cbStr);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\XboxSynth\mmdebug.h ===
//      Copyright (c) 1996-1999 Microsoft Corporation
/*
 * johnkn's debug logging and assert macros
 *
 */
 
#ifdef __cplusplus
extern "C" {
#endif // __cplusplus

#if !defined _INC_MMDEBUG_
#define _INC_MMDEBUG_

#if defined _DEBUG && !defined DEBUG
 #define DEBUG
#endif

//
// prototypes for debug functions.
//
    #define SQUAWKNUMZ(num) #num
    #define SQUAWKNUM(num) SQUAWKNUMZ(num)
    #define SQUAWK __FILE__ "(" SQUAWKNUM(__LINE__) ") ----"
    #define DEBUGLINE __FILE__ "(" SQUAWKNUM(__LINE__) ") "
        
    #if defined DEBUG || defined _DEBUG || defined DEBUG_RETAIL

        #define STATICFN

        int  FAR _cdecl AuxDebugEx(int, LPTSTR, ...);
        void FAR _cdecl AuxRip(LPTSTR, ...);
        VOID WINAPI AuxDebugDump (int, LPVOID, int);
        LPCTSTR WINAPI AuxMMErrText(DWORD  mmr);
        int  WINAPI DebugSetOutputLevel (int,int);
        UINT WINAPI AuxFault (DWORD dwFaultMask);

       #if defined DEBUG_RETAIL && !defined DEBUG && !defined _DEBUG
        #define INLINE_BREAK
       #else
        #if !defined _WIN32 || defined _X86_
         #define INLINE_BREAK _asm {int 3}
        #else
         #define INLINE_BREAK DebugBreak()
        #endif
       #endif

        #define FAULT_HERE AuxFault

       #undef  assert
       #define assert(exp) {\
           if (!(exp)) {\
               AuxDebugEx(-2, DEBUGLINE "assert failed: " #exp "\r\n"); \
               INLINE_BREAK;\
               }\
           }
       #undef  assert2
       #define assert2(exp,sz) {\
           if (!(exp)) {\
               AuxDebugEx(-2, DEBUGLINE "assert failed: " sz "\r\n"); \
               INLINE_BREAK;\
               }\
           }
       #undef  assert3
       #define assert3(exp,sz,arg) {\
           if (!(exp)) {\
               AuxDebugEx(-2, DEBUGLINE "assert failed: " sz "\r\n", (arg)); \
               INLINE_BREAK;\
               }\
           }
       #undef  assert4
       #define assert4(exp,sz,arg1,arg2) {\
           if (!(exp)) {\
               AuxDebugEx(-2, DEBUGLINE "assert failed: " sz "\r\n", (arg1),(arg2)); \
               INLINE_BREAK;\
               }\
           }
       #undef  assert5
       #define assert5(exp,sz,arg1,arg2,arg3) {\
           if (!(exp)) {\
               AuxDebugEx(-2, DEBUGLINE "assert failed: " sz "\r\n", (arg1),(arg2),(arg3)); \
               INLINE_BREAK;\
               }\
           }

    #else // defined(DEBUG) || defined(_DEBUG)
                      
       #define AuxDebugEx  1 ? (void)0 :
       #define AuxDebugDump(a,b,c)
       #define AuxMMErrText(m)     NULL
       #define AuxRip  1 ? (void)0 :

       #define assert(a)          ((void)0)
       #define assert2(a,b)       ((void)0)
       #define assert3(a,b,c)     ((void)0)
       #define assert4(a,b,c,d)   ((void)0)
       #define assert5(a,b,c,d,e) ((void)0)

       #define FAULT_HERE    1 ? (void)0 :
       #define INLINE_BREAK
       #define DebugSetOutputLevel(i,j)
       #define STATICFN static

   #endif // defined(DEBUG) || defined _DEBUG || defined DEBUG_RETAIL

   #ifndef DPF_CATEGORY
    #define DPF_CATEGORY 0x0100
   #endif

   // translate DPF's only in internal debug builds
   //
   #if defined DEBUG || defined _DEBUG
       #define DUMP(n,a,b) AuxDebugDump (DPF_CATEGORY | (n), a, b)
       #define RIP AuxDebugEx (0, DEBUGLINE), AuxRip
       #define AuxMMR(api,mmr) (mmr) ? AuxDebugEx(1, DEBUGLINE #api " error %d '%s'\r\n", mmr, AuxMMErrText(mmr)) : (int)0
       #define DPF(n,sz) AuxDebugEx (DPF_CATEGORY | (n), DEBUGLINE sz "\r\n")
       #define DPF1(n,sz,a) AuxDebugEx (DPF_CATEGORY | (n), DEBUGLINE sz "\r\n",(a))
       #define DPF2(n,sz,a,b) AuxDebugEx (DPF_CATEGORY | (n), DEBUGLINE sz "\r\n",(a),(b))
       #define DPF3(n,sz,a,b,c) AuxDebugEx (DPF_CATEGORY | (n), DEBUGLINE sz "\r\n",(a),(b),(c))
       #define DPF4(n,sz,a,b,c,d) AuxDebugEx (DPF_CATEGORY | (n), DEBUGLINE sz "\r\n",(a),(b),(c),(d))
       #define DPF5(n,sz,a,b,c,d,e) AuxDebugEx (DPF_CATEGORY | (n), DEBUGLINE sz "\r\n",(a),(b),(c),(d),(e))
       #define DPF6(n,sz,a,b,c,d,e,f) AuxDebugEx (DPF_CATEGORY | (n), DEBUGLINE sz "\r\n",(a),(b),(c),(d),(d),(f))
       #define DPF7(n,sz,a,b,c,d,e,f,g) AuxDebugEx (DPF_CATEGORY | (n), DEBUGLINE sz "\r\n",(a),(b),(c),(d),(d),(f),(g))
   #else
       #define DUMP(n,a,b)
       #define RIP AuxRip
       #define AuxMMR(api,mmr)
       #define DPF(n,sz)
       #define DPF1(n,sz,a)
       #define DPF2(n,sz,a,b)
       #define DPF3(n,sz,a,b,c)
       #define DPF4(n,sz,a,b,c,d)
       #define DPF5(n,sz,a,b,c,d,e)
       #define DPF6(n,sz,a,b,c,d,e,f)
       #define DPF7(n,sz,a,b,c,d,e,f,g)
   #endif
   
#endif //_INC_MMDEBUG_

// =============================================================================

//
// include this in only one module in a DLL or APP
//   
#if defined DEBUG || defined _DEBUG || defined DEBUG_RETAIL
    #if (defined _INC_MMDEBUG_CODE_) && (_INC_MMDEBUG_CODE_ != FALSE)
    #undef _INC_MMDEBUG_CODE_
    #define _INC_MMDEBUG_CODE_ FALSE
       
    #include <stdarg.h>   

    #if !defined _WIN32 && !defined wvsprintfA
     #define wvsprintfA wvsprintf
    #endif

static struct _mmerrors {
   DWORD    mmr;
   LPCTSTR  psz;
   } aMMErr[] = {
      MMSYSERR_NOERROR      ,"Success",
   #ifdef DEBUG
      MMSYSERR_ERROR        ,"unspecified error",
      MMSYSERR_BADDEVICEID  ,"device ID out of range",
      MMSYSERR_NOTENABLED   ,"driver failed enable",
      MMSYSERR_ALLOCATED    ,"device already allocated",
      MMSYSERR_INVALHANDLE  ,"device handle is invalid",
      MMSYSERR_NODRIVER     ,"no device driver present",
      MMSYSERR_NOMEM        ,"memory allocation error",
      MMSYSERR_NOTSUPPORTED ,"function isn't supported",
      MMSYSERR_BADERRNUM    ,"error value out of range",
      MMSYSERR_INVALFLAG    ,"invalid flag passed",
      MMSYSERR_INVALPARAM   ,"invalid parameter passed",
     #if (WINVER >= 0x0400)
      MMSYSERR_HANDLEBUSY   ,"handle in use by another thread",
      MMSYSERR_INVALIDALIAS ,"specified alias not found",
      MMSYSERR_BADDB        ,"bad registry database",
      MMSYSERR_KEYNOTFOUND  ,"registry key not found",
      MMSYSERR_READERROR    ,"registry read error",
      MMSYSERR_WRITEERROR   ,"registry write error",
      MMSYSERR_DELETEERROR  ,"registry delete error",
      MMSYSERR_VALNOTFOUND  ,"registry value not found",
      MMSYSERR_NODRIVERCB   ,"Never got a 32 bit callback from driver",
     #endif // WINVER >= 0x400

      WAVERR_BADFORMAT      ,"wave:unsupported wave format",
      WAVERR_STILLPLAYING   ,"wave:still something playing",
      WAVERR_UNPREPARED     ,"wave:header not prepared",
      WAVERR_SYNC           ,"wave:device is synchronous",

      MIDIERR_UNPREPARED    ,"midi:header not prepared",
      MIDIERR_STILLPLAYING  ,"midi:still something playing",
      //MIDIERR_NOMAP         ,"midi:no configured instruments",
      MIDIERR_NOTREADY      ,"midi:hardware is still busy",
      MIDIERR_NODEVICE      ,"midi:port no longer connected",
      MIDIERR_INVALIDSETUP  ,"midi:invalid MIF",
      #ifdef CHICAGO
      MIDIERR_BADOPENMODE   ,"midi:operation unsupported w/ open mode",
      #endif

      TIMERR_NOCANDO        ,"timer: request not completed",
      JOYERR_PARMS          ,"joy:bad parameters",
      JOYERR_NOCANDO        ,"joy:request not completed",
      JOYERR_UNPLUGGED      ,"joystick is unplugged",

      MCIERR_INVALID_DEVICE_ID        ,"MCIERR_INVALID_DEVICE_ID",
      MCIERR_UNRECOGNIZED_KEYWORD     ,"MCIERR_UNRECOGNIZED_KEYWORD",
      MCIERR_UNRECOGNIZED_COMMAND     ,"MCIERR_UNRECOGNIZED_COMMAND",
      MCIERR_HARDWARE                 ,"MCIERR_HARDWARE",
      MCIERR_INVALID_DEVICE_NAME      ,"MCIERR_INVALID_DEVICE_NAME",
      MCIERR_OUT_OF_MEMORY            ,"MCIERR_OUT_OF_MEMORY",
      MCIERR_DEVICE_OPEN              ,"MCIERR_DEVICE_OPEN",
      MCIERR_CANNOT_LOAD_DRIVER       ,"MCIERR_CANNOT_LOAD_DRIVER",
      MCIERR_MISSING_COMMAND_STRING   ,"MCIERR_MISSING_COMMAND_STRING",
      MCIERR_PARAM_OVERFLOW           ,"MCIERR_PARAM_OVERFLOW",
      MCIERR_MISSING_STRING_ARGUMENT  ,"MCIERR_MISSING_STRING_ARGUMENT",
      MCIERR_BAD_INTEGER              ,"MCIERR_BAD_INTEGER",
      MCIERR_PARSER_INTERNAL          ,"MCIERR_PARSER_INTERNAL",
      MCIERR_DRIVER_INTERNAL          ,"MCIERR_DRIVER_INTERNAL",
      MCIERR_MISSING_PARAMETER        ,"MCIERR_MISSING_PARAMETER",
      MCIERR_UNSUPPORTED_FUNCTION     ,"MCIERR_UNSUPPORTED_FUNCTION",
      MCIERR_FILE_NOT_FOUND           ,"MCIERR_FILE_NOT_FOUND",
      MCIERR_DEVICE_NOT_READY         ,"MCIERR_DEVICE_NOT_READY",
      MCIERR_INTERNAL                 ,"MCIERR_INTERNAL",
      MCIERR_DRIVER                   ,"MCIERR_DRIVER",
      MCIERR_CANNOT_USE_ALL           ,"MCIERR_CANNOT_USE_ALL",
      MCIERR_MULTIPLE                 ,"MCIERR_MULTIPLE",
      MCIERR_EXTENSION_NOT_FOUND      ,"MCIERR_EXTENSION_NOT_FOUND",
      MCIERR_OUTOFRANGE               ,"MCIERR_OUTOFRANGE",
      MCIERR_FLAGS_NOT_COMPATIBLE     ,"MCIERR_FLAGS_NOT_COMPATIBLE",
      MCIERR_FILE_NOT_SAVED           ,"MCIERR_FILE_NOT_SAVED",
      MCIERR_DEVICE_TYPE_REQUIRED     ,"MCIERR_DEVICE_TYPE_REQUIRED",
      MCIERR_DEVICE_LOCKED            ,"MCIERR_DEVICE_LOCKED",
      MCIERR_DUPLICATE_ALIAS          ,"MCIERR_DUPLICATE_ALIAS",
      MCIERR_BAD_CONSTANT             ,"MCIERR_BAD_CONSTANT",
      MCIERR_MUST_USE_SHAREABLE       ,"MCIERR_MUST_USE_SHAREABLE",
      MCIERR_MISSING_DEVICE_NAME      ,"MCIERR_MISSING_DEVICE_NAME",
      MCIERR_BAD_TIME_FORMAT          ,"MCIERR_BAD_TIME_FORMAT",
      MCIERR_NO_CLOSING_QUOTE         ,"MCIERR_NO_CLOSING_QUOTE",
      MCIERR_DUPLICATE_FLAGS          ,"MCIERR_DUPLICATE_FLAGS",
      MCIERR_INVALID_FILE             ,"MCIERR_INVALID_FILE",
      MCIERR_NULL_PARAMETER_BLOCK     ,"MCIERR_NULL_PARAMETER_BLOCK",
      MCIERR_UNNAMED_RESOURCE         ,"MCIERR_UNNAMED_RESOURCE",
      MCIERR_NEW_REQUIRES_ALIAS       ,"MCIERR_NEW_REQUIRES_ALIAS",
      MCIERR_NOTIFY_ON_AUTO_OPEN      ,"MCIERR_NOTIFY_ON_AUTO_OPEN",
      MCIERR_NO_ELEMENT_ALLOWED       ,"MCIERR_NO_ELEMENT_ALLOWED",
      MCIERR_NONAPPLICABLE_FUNCTION   ,"MCIERR_NONAPPLICABLE_FUNCTION",
      MCIERR_ILLEGAL_FOR_AUTO_OPEN    ,"MCIERR_ILLEGAL_FOR_AUTO_OPEN",
      MCIERR_FILENAME_REQUIRED        ,"MCIERR_FILENAME_REQUIRED",
      MCIERR_EXTRA_CHARACTERS         ,"MCIERR_EXTRA_CHARACTERS",
      MCIERR_DEVICE_NOT_INSTALLED     ,"MCIERR_DEVICE_NOT_INSTALLED",
      MCIERR_GET_CD                   ,"MCIERR_GET_CD",
      MCIERR_SET_CD                   ,"MCIERR_SET_CD",
      MCIERR_SET_DRIVE                ,"MCIERR_SET_DRIVE",
      MCIERR_DEVICE_LENGTH            ,"MCIERR_DEVICE_LENGTH",
      MCIERR_DEVICE_ORD_LENGTH        ,"MCIERR_DEVICE_ORD_LENGTH",
      MCIERR_NO_INTEGER               ,"MCIERR_NO_INTEGER",
      MCIERR_WAVE_OUTPUTSINUSE        ,"MCIERR_WAVE_OUTPUTSINUSE",
      MCIERR_WAVE_SETOUTPUTINUSE      ,"MCIERR_WAVE_SETOUTPUTINUSE",
      MCIERR_WAVE_INPUTSINUSE         ,"MCIERR_WAVE_INPUTSINUSE",
      MCIERR_WAVE_SETINPUTINUSE       ,"MCIERR_WAVE_SETINPUTINUSE",
      MCIERR_WAVE_OUTPUTUNSPECIFIED   ,"MCIERR_WAVE_OUTPUTUNSPECIFIED",
      MCIERR_WAVE_INPUTUNSPECIFIED    ,"MCIERR_WAVE_INPUTUNSPECIFIED",
      MCIERR_WAVE_OUTPUTSUNSUITABLE   ,"MCIERR_WAVE_OUTPUTSUNSUITABLE",
      MCIERR_WAVE_SETOUTPUTUNSUITABLE ,"MCIERR_WAVE_SETOUTPUTUNSUITABLE",
      MCIERR_WAVE_INPUTSUNSUITABLE    ,"MCIERR_WAVE_INPUTSUNSUITABLE",
      MCIERR_WAVE_SETINPUTUNSUITABLE  ,"MCIERR_WAVE_SETINPUTUNSUITABLE",
      MCIERR_SEQ_DIV_INCOMPATIBLE     ,"MCIERR_SEQ_DIV_INCOMPATIBLE",
      MCIERR_SEQ_PORT_INUSE           ,"MCIERR_SEQ_PORT_INUSE",
      MCIERR_SEQ_PORT_NONEXISTENT     ,"MCIERR_SEQ_PORT_NONEXISTENT",
      MCIERR_SEQ_PORT_MAPNODEVICE     ,"MCIERR_SEQ_PORT_MAPNODEVICE",
      MCIERR_SEQ_PORT_MISCERROR       ,"MCIERR_SEQ_PORT_MISCERROR",
      MCIERR_SEQ_TIMER                ,"MCIERR_SEQ_TIMER",
      MCIERR_SEQ_PORTUNSPECIFIED      ,"MCIERR_SEQ_PORTUNSPECIFIED",
      MCIERR_SEQ_NOMIDIPRESENT        ,"MCIERR_SEQ_NOMIDIPRESENT",
      MCIERR_NO_WINDOW                ,"MCIERR_NO_WINDOW",
      MCIERR_CREATEWINDOW             ,"MCIERR_CREATEWINDOW",
      MCIERR_FILE_READ                ,"MCIERR_FILE_READ",
      MCIERR_FILE_WRITE               ,"MCIERR_FILE_WRITE",
     #ifdef CHICAGO
      MCIERR_NO_IDENTITY              ,"MCIERR_NO_IDENTITY",

      MIXERR_INVALLINE            ,"Invalid Mixer Line",
      MIXERR_INVALCONTROL         ,"Invalid Mixer Control",
      MIXERR_INVALVALUE           ,"Invalid Mixer Value",
     #endif // CHICAGO
   #endif // DEBUG
      0xFFFFFFFE                  , "unknown error %d"
      };

    struct _mmdebug {
        int    Level;
        int    Mask;
        int    StopOnRip;
        DWORD  TakeFault;
        struct _mmerrors *paErrs;
        BOOL   Initialized;
        HANDLE hOut;
        } mmdebug = {0, 0xFF, 0, 0xFF, aMMErr};

    /*+ AuxFault
     *
     *-=================================================================*/

     UINT WINAPI AuxFault (
         DWORD dwFaultMask)
     {
         LPUINT pData = NULL;

         if (dwFaultMask & mmdebug.TakeFault)
            return *pData;
         return 0;
     }


    /*+ AuxOut - write a string to designated debug out
     *
     *-=================================================================*/

   void WINAPI AuxOut (
      LPTSTR psz)
      {
     #ifdef WIN32
      if (mmdebug.hOut)
         {
         UINT  cb = lstrlen(psz);
         DWORD dw;
         if (INVALID_HANDLE_VALUE != mmdebug.hOut)
            WriteFile (mmdebug.hOut, psz, cb, &dw, NULL);
         }
      else
     #endif
         {
        #ifdef DbgLog
         DbgOutString (psz); // from \quartz\sdk\classes\base\debug.cpp
        #else
         OutputDebugString (psz);
        #endif
         }
      }

    /*+ AuxDebug - create a formatted string and output to debug terminal
     *
     *-=================================================================*/
    
    int FAR _cdecl AuxDebugEx (
       int    iLevel,
       LPTSTR lpFormat,
       ...)
       {
      #ifdef WIN32
       char     szBuf[1024];
      #else
       static char szBuf[1024];
      #endif
       int      cb;
       va_list  va;
       LPSTR    psz;

       // mask the iLevel passed with mmdebug.Mask. if this ends up
       // clearing the high bits then iLevel has a shot being smaller
       // than mmdebug.Level.  if not, then the second test will always
       // fail.  Thus mmdebug.Mask has bits set to DISABLE that category.
       // 
       // note that we always pass messages that have an iLevel < 0.
       // this level corresponds to Asserts & Rips so we always want to see them.
       //
       if (iLevel < 0 || mmdebug.Level >= (iLevel & mmdebug.Mask))
          {
          va_start (va, lpFormat);
          cb = wvsprintfA (szBuf, lpFormat, va);
          va_end (va);

          // eat leading ..\..\ which we get from __FILE__ since
          // george's wierd generic makefile stuff.
          //
          psz = szBuf;
          while (psz[0] == '.' && psz[1] == '.' && psz[2] == '\\')
             psz += 3;

          // if we begin with a drive letter, strip off all but filename
          //  
          if (psz[0] && psz[1] == ':')
             {
             UINT ii = 2;
             for (ii = 2; psz[ii] != 0; ++ii)
                 if (psz[ii] == '\\')
                    psz += ii+1, ii = 0;
             }

          // write to standard out if we have a handle. otherwise write to 
          // the debugger
          //
         #ifdef MODULE_DEBUG_PREFIX
          if (psz != szBuf)
             AuxOut (MODULE_DEBUG_PREFIX);
         #endif
          AuxOut (psz);
          }

       return cb;
       }

    /*+ AuxRip
     *
     *-=================================================================*/

    void FAR _cdecl AuxRip (
       LPTSTR lpFormat,
       ...)
       {
      #ifdef WIN32
       char     szBuf[1024];
      #else
       static char szBuf[1024];
      #endif
       va_list  va;
       LPSTR    psz;
                
       va_start (va, lpFormat);
       wvsprintfA (szBuf, lpFormat, va);
       va_end (va);

       // eat leading ..\..\ which we get from __FILE__ since
       // george's wierd generic makefile stuff.
       //
       psz = szBuf;
       while (psz[0] == '.' && psz[1] == '.' && psz[2] == '\\')
          psz += 3;

       AuxOut ("RIP: ");
       AuxOut (psz);
       AuxOut ("\r\n");

       if (mmdebug.StopOnRip)
          {
         #if !defined _WIN32 || defined _X86_
          _asm {int 3};
         #else
          DebugBreak();
         #endif
          }
       }

    /*+ AuxDebugDump -
     *
     *-=================================================================*/
    
    VOID WINAPI AuxDebugDump (
       int    iLevel,
       LPVOID lpvData,
       int    nCount)
       {
       LPBYTE   lpData = (LPBYTE)lpvData;
       char     szBuf[128];
       LPSTR    psz;
       int      cb;
       int      ix;
       BYTE     abRow[8];
                
       if ((mmdebug.Level < (iLevel & mmdebug.Mask)) || nCount <= 0)
          return;

       do {
          cb = wsprintf (szBuf, "\t%08X: ", lpData);
          psz = szBuf + cb;

          for (ix = 0; ix < 8; ++ix)
             {
             LPBYTE lpb = lpData;

             abRow[ix] = '.';
             if (IsBadReadPtr (lpData + ix, 1))
                lstrcpy (psz, ".. ");
             else
                {
                wsprintf (psz, "%02X ", lpData[ix]);
                if (lpData[ix] >= 32 && lpData[ix] < 127)
                    abRow[ix] = lpData[ix];
                }
             psz += 3;
             }
          for (ix = 0; ix < 8; ++ix)
             *psz++ = abRow[ix];

          lstrcpy (psz, "\r\n");

          #ifdef MODULE_DEBUG_PREFIX
           AuxOut (MODULE_DEBUG_PREFIX);
          #endif

          AuxOut (szBuf);

          } while (lpData += 8, (nCount -= 8) > 0);

       return;
       }
       
    /*+ AuxMMErrText
     *
     *-=================================================================*/
    
   LPCTSTR WINAPI AuxMMErrText (
      DWORD  mmr)
   {
      UINT uRemain = sizeof(aMMErr)/sizeof(aMMErr[0]);
      UINT uUpper  = uRemain-1;
      UINT uLower  = 0;
      static char szTemp[50];

      if (mmr <= aMMErr[uUpper].mmr)
      {
         // binary search for mmr match, if match
         // return string pointer
         //
         while (--uRemain)
         {
            UINT ii = (uLower + uUpper) >> 1;

            if (aMMErr[ii].mmr < mmr)
            {
               if (uLower == ii)
                  break;
               uLower = ii;
            }
            else if (aMMErr[ii].mmr > mmr)
            {
               if (uUpper == ii)
                  break;
               uUpper = ii;
            }
            else
            {
               return aMMErr[ii].psz;
               break;
            }
         }

         // we can only get to here if no match was found for
         // the error id.
         //
         if ( ! uRemain)
         {
            int ix;

            INLINE_BREAK;

            for (ix = 0; ix < sizeof(aMMErr)/sizeof(aMMErr[0])-1; ++ix)
            {
                assert (aMMErr[ix].mmr < aMMErr[ix+1].mmr);
            }
            wsprintf (szTemp, "error %d 0x%X", mmr, mmr);
            return szTemp;
         }
      }

      wsprintf (szTemp, aMMErr[uUpper].psz, mmr);
      return szTemp;
   }

    /*+ DebugSetOutputLevel
     *
     *-=================================================================*/
    
    BOOL  WINAPI DebugSetOutputLevel (
        int nLevel,
        int nMask)
        {
        int nOldLevel = mmdebug.Level;

        if (!mmdebug.Initialized)
           {
          #ifdef WIN32
           TCHAR szFile[MAX_PATH];
           mmdebug.TakeFault = GetProfileInt("Debug", "FaultMask", 1);

           GetProfileString("Debug", "MMDebugTo", "", szFile, sizeof(szFile));
#if 0
           if (!lstrcmpi(szFile, "Console"))
              {
              mmdebug.hOut = GetStdHandle (STD_OUTPUT_HANDLE);
              if (!mmdebug.hOut || mmdebug.hOut == INVALID_HANDLE_VALUE)
                 {
                 AllocConsole ();
                 mmdebug.hOut = GetStdHandle (STD_OUTPUT_HANDLE);
                 if (mmdebug.hOut == INVALID_HANDLE_VALUE)
                    mmdebug.hOut = NULL;
                 }
              SetConsoleTitle (MODULE_DEBUG_PREFIX " Debug Output");
              }
           else
#endif
           if (szFile[0] &&
                    lstrcmpi(szFile, "Debug") &&
                    lstrcmpi(szFile, "Debugger") &&
                    lstrcmpi(szFile, "Deb"))
              {
              mmdebug.hOut = CreateFile(szFile, GENERIC_WRITE,
                                        FILE_SHARE_READ,
                                        NULL, OPEN_ALWAYS,
                                        FILE_ATTRIBUTE_NORMAL,
                                        NULL);
              if (INVALID_HANDLE_VALUE != mmdebug.hOut)
                 SetFilePointer (mmdebug.hOut, 0, NULL, FILE_END);
              }
          #endif
           mmdebug.Initialized = TRUE;
           }

        mmdebug.Level = (nLevel & 0xFF);
        mmdebug.Mask  = (nMask | 0xFF);
        return nOldLevel;
        }


    #endif // _INC_MMDEBUG_CODE_
#endif // DEBUG || _DEBUG    

#ifdef __cplusplus
}
#endif // _cplusplus
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\XboxSynth\mix.cpp ===
//      Copyright (c) 1996-1999 Microsoft Corporation
//      Mix.cpp
//      Mix engines for MSSynth

#ifdef DMSYNTH_MINIPORT
#include "common.h"
#define STR_MODULENAME "DMusicMix:"
#else
#include "simple.h"
#include <mmsystem.h>
#include "synth.h"
#endif

#pragma warning(disable : 4101 4102 4146)  

#ifdef _ALPHA_

extern "C" {
	int __ADAWI(short, short *);
};
#pragma intrinsic(__ADAWI)

#define ALPHA_OVERFLOW 2 
#define ALPHA_NEGATIVE 8

#else // !_ALPHA_
//  TODO -- overflow detection for ia64 (+ axp64?)
#endif // !_ALPHA_
#ifdef DMSYNTH_MINIPORT
#pragma code_seg("PAGE")
#endif // DMSYNTH_MINIPORT

DWORD CDigitalAudio::Mix8(short * pBuffer, 
						  DWORD dwLength, 
						  DWORD dwDeltaPeriod,
						  VFRACT vfDeltaLVolume, 
						  VFRACT vfDeltaRVolume,
					      VFRACT vfLastVolume[],
						  PFRACT pfDeltaPitch, 
						  PFRACT pfSampleLength, 
						  PFRACT pfLoopLength)
{
    DWORD dwI;
    DWORD dwPosition;
    long lM, lLM;
    DWORD dwIncDelta = dwDeltaPeriod;
    VFRACT dwFract;
    char * pcWave = (char *) m_pnWave;
    PFRACT pfSamplePos = m_pfLastSample;
    VFRACT vfLVolume = vfLastVolume[0];
    VFRACT vfRVolume = vfLastVolume[1];
    PFRACT pfPitch = m_pfLastPitch;
    PFRACT pfPFract = pfPitch << 8;
    VFRACT vfLVFract = vfLVolume << 8;  // Keep high res version around.
    VFRACT vfRVFract = vfRVolume << 8;  
	dwLength <<= 1;

#ifndef _X86_
    for (dwI = 0; dwI < dwLength; )
    {
        if (pfSamplePos >= pfSampleLength)
	    {	
	        if (pfLoopLength)
		    pfSamplePos -= pfLoopLength;
	        else
		    break;
	    }
        dwIncDelta--;
        if (!dwIncDelta)    
        {
            dwIncDelta = dwDeltaPeriod;
            pfPFract += pfDeltaPitch;
            pfPitch = pfPFract >> 8;
            vfLVFract += vfDeltaLVolume;
            vfLVolume = vfLVFract >> 8;
            vfRVFract += vfDeltaRVolume;
            vfRVolume = vfRVFract >> 8;
        }

        dwPosition = pfSamplePos >> 12;
        dwFract = pfSamplePos & 0xFFF;
        pfSamplePos += pfPitch;

        lLM = pcWave[dwPosition];
        lM = ((pcWave[dwPosition + 1] - lLM) * dwFract) >> 12;
        lM += lLM;
        lLM = lM;

        lLM *= vfLVolume;
        lLM >>= 5;         // Signal bumps up to 15 bits.
        lM *= vfRVolume;
        lM >>= 5;

#ifndef _X86_

#ifdef _ALPHA_
		int nBitmask;
		if( ALPHA_OVERFLOW & (nBitmask = __ADAWI( (short) lLM, &pBuffer[dwI] )) )  {
			if( ALPHA_NEGATIVE & nBitmask )  {
				pBuffer[dwI] = 0x7FFF;
			}
			else  pBuffer[dwI] = (short) 0x8000;
		}
		if( ALPHA_OVERFLOW & (nBitmask = __ADAWI( (short) lM, &pBuffer[dwI+1] )) )  {
			if( ALPHA_NEGATIVE & nBitmask )  {
				pBuffer[dwI+1] = 0x7FFF;
			}
			else  pBuffer[dwI+1] = (short) 0x8000;
		}
#else // !_ALPHA_
    // TODO -- overflow detection on ia64 (+ axp64?)
#endif // !_ALPHA_

#else // _X86_  (dead code)
      //  Keep this around so we can use it to generate new assembly code (see below...)
		pBuffer[dwI] += (short) lLM;

        _asm{jno no_oflowl}
        pBuffer[dwI] = 0x7fff;
        _asm{js  no_oflowl}
        pBuffer[dwI] = (short) 0x8000;
no_oflowl:	

		pBuffer[dwI+1] += (short) lM;

        _asm{jno no_oflowr}
        pBuffer[dwI+1] = 0x7fff;
        _asm{js  no_oflowr}
        pBuffer[dwI+1] = (short) 0x8000;
no_oflowr:
#endif // _X86_  (dead code)

		dwI += 2;
    }
#else // _X86_
	int i, a, b, c, total;
	short * pBuf = pBuffer + dwLength, *pBufX;
	dwI = - dwLength;

	_asm {

; 979  :     for (dwI = 0; dwI < dwLength; )

//	Induction variables.
	mov	edi, dwI
	mov	ebx, DWORD PTR pfSamplePos

// Previously set up.
	cmp	DWORD PTR dwLength, 0
	mov	edx, pfPFract

	mov	ecx, DWORD PTR pfPitch
	je	$L30539

$L30536:
	cmp	ebx, DWORD PTR pfSampleLength

; 981  :         if (pfSamplePos >= pfSampleLength)

	mov	esi, DWORD PTR dwIncDelta
	jge	SHORT $L30540_

$L30540:
; 987  : 	        else
; 988  : 		    break;
; 990  :         dwIncDelta--;

	dec	esi
	mov	DWORD PTR dwIncDelta, esi

; 991  :         if (!dwIncDelta)    

	je	SHORT $L30541_

$L30541:
// esi, edx, edi		esi == dwIncDelta

	mov	DWORD PTR i, 0

; 1010 : 	b = dwIncDelta;

// esi = b == dwIncDelta

; 1011 : 	c = (pfSampleLength - pfSamplePos) / pfPitch;
; 1009 : 	a = (dwLength - dwI) / 2;	// Remaining span.

	mov	edx, edi
	neg	edx
	shr	edx, 1		// edx = a

; 1017 : 	if (b < a && b < c)

	cmp	esi, edx
	jge	try_ax

	mov	eax, ecx
	imul	eax, esi
	add	eax, ebx

	cmp eax, DWORD PTR pfSampleLength 
	jge	try_c

; 1019 : 		i = b;

	cmp	esi, 3
	jl	got_it

	mov	DWORD PTR i, esi
	jmp	SHORT got_it

; 1013 : 	if (a < b && a < c)

try_a:

	cmp	edx, esi
	jge	try_c
try_ax:
	mov	eax, edx
	imul	eax, ecx
	add	eax, ebx

	cmp eax, DWORD PTR pfSampleLength
	jge	try_c

; 1015 : 		i = a;

	cmp	edx, 3
	jl	got_it

	mov	DWORD PTR i, edx
	jmp	SHORT got_it

; 1021 : 	else if (c < a && c < b)
try_c:

    push	edx
	mov	eax, DWORD PTR pfSampleLength
	sub	eax, ebx
	cdq
	idiv	ecx		// eax == c
	pop	edx

    cmp	eax, edx
	jge	got_it
try_cx:
	cmp	eax, esi
	jge	got_it

; 1023 : 		i = c;

	cmp	eax, 3
	jl	$L30543	

	mov DWORD PTR i, eax

got_it:
	mov	edx, DWORD PTR i
	mov	eax, DWORD PTR pBuf

	dec	edx
	jl	$L30543

	sub	DWORD PTR dwIncDelta, edx

; 1093 :     return (dwI >> 1);
; 1094 : }

	lea	edx, [edx*2+2]			// Current span.
	lea	eax, [eax+edi*2]		// Starting position.

	add	edi, edx				// Remaining span.
	lea	eax, [eax+edx*2]		// New ending position.

	push	edi
	mov	edi, edx				// Current span.

	mov	DWORD PTR pBufX, eax
	neg	edi

$L30797:
; 1005 : 			do
; 1010 : 				dwPosition = pfSamplePos >> 12;
; 1011 : 				dwFract = pfSamplePos & 0xFFF;

	mov	edx, ebx
	mov	esi, ebx

	add	ebx, ecx
	mov	ecx, DWORD PTR pcWave

; 1012 : 				pfSamplePos += pfPitch;

	sar	edx, 12					; 0000000cH
	and	esi, 4095				; 00000fffH

; 1013 : 
; 1014 : 				lLM = (long) pcWave[dwPosition];

	movsx	eax, BYTE PTR [ecx+edx]

; 1015 : 				lM = ((pcWave[dwPosition+1] - lLM) * dwFract);
; 1016 : 				lM >>= 12;
; 1017 : 				lM += lLM;

	movsx	edx, BYTE PTR [ecx+edx+1]

; 1018 : 				lLM = lM;
; 1019 : 				lLM *= vfLVolume;
; 1020 : 				lLM >>= 5;         // Signal bumps up to 15 bits.
; 1022 : 				pBuffer[dwI] += (short) lLM;
; 1028 : 						lM *= vfRVolume;
; 1029 : 						lM >>= 5;
; 1030 : 				pBuffer[dwI+1] += (short) lM;
; 1036 : 
; 1037 : 				dwI += 2;
	sub	edx, eax

	imul	edx, esi

	sar	edx, 12					; 0000000cH
	mov	esi, DWORD PTR vfLVolume

	add	edx, eax

	imul	esi, edx

	sar	esi, 5					; 00000005H
	mov	eax, DWORD PTR pBufX

	add	WORD PTR [eax+edi*2], si
	mov	esi, DWORD PTR vfRVolume

	jo	overflow_lx
no_oflowlx:

	imul	esi, edx

; 1038 : 			} while (--dwIncDelta);

	sar	esi, 5					; 00000005H
	mov	ecx, DWORD PTR pfPitch

	add	WORD PTR [eax+edi*2+2], si
	jo	overflow_rx

no_oflowrx:

	add	edi, 2
	jne	SHORT $L30797

	pop	edi

; 1039 : 			++dwIncDelta;
; 1040 : 			continue;

	mov	edx, DWORD PTR pfPFract
	cmp	edi, 0

	jl	SHORT $L30536
	jmp	SHORT $L30539

$L30540_:

; 982  : 	    {	
; 983  : 	        if (pfLoopLength)

	cmp	DWORD PTR pfLoopLength, 0
	je	$L30539

; 984  : 			{
; 985  : 				pfSamplePos -= pfLoopLength;

	sub	ebx, DWORD PTR pfLoopLength
	jmp	$L30540

$L30541_:
; 994  :             pfPFract += pfDeltaPitch;

	mov	ecx, DWORD PTR pfDeltaPitch
	mov	esi, DWORD PTR vfDeltaLVolume

	add	ecx, edx
	mov	edx, DWORD PTR vfLVFract

; 995  :             pfPitch = pfPFract >> 8;
; 996  :             vfLVFract += vfDeltaLVolume;

	mov	DWORD PTR pfPFract, ecx
	add	edx, esi

; 997  :             vfLVolume = vfLVFract >> 8;
; 998  :             vfRVFract += vfDeltaRVolume;

	sar	ecx, 8
	mov	DWORD PTR vfLVFract, edx
	
	sar	edx, 8
	mov	esi, DWORD PTR vfDeltaRVolume

	mov	DWORD PTR vfLVolume, edx
	mov	edx, DWORD PTR vfRVFract

	add	edx, esi
	mov	DWORD PTR pfPitch, ecx

	mov	DWORD PTR vfRVFract, edx
	mov	esi, DWORD PTR dwDeltaPeriod

; 999  :             vfRVolume = vfRVFract >> 8;

	sar	edx, 8
	mov	DWORD PTR dwIncDelta, esi

; 993  :             dwIncDelta = dwDeltaPeriod;

	mov	DWORD PTR vfRVolume, edx
	jmp	$L30541

// Handle truncation.

overflow_l:
	mov	WORD PTR [eax+edi*2], 0x7fff
	js	no_oflowl
	mov	WORD PTR [eax+edi*2], 0x8000
	jmp no_oflowl

overflow_r:
	mov	WORD PTR [eax+edi*2+2], 0x7fff
	js	no_oflowr
	mov	WORD PTR [eax+edi*2+2], 0x8000
	jmp	no_oflowr

overflow_lx:
	mov	WORD PTR [eax+edi*2], 0x7fff
	js	no_oflowlx
	mov	WORD PTR [eax+edi*2], 0x8000
	jmp	no_oflowlx

overflow_rx:
	mov	WORD PTR [eax+edi*2+2], 0x7fff
	js	no_oflowrx
	mov	WORD PTR [eax+edi*2+2], 0x8000
	jmp	no_oflowrx

$L30543:
; 1041 : 		}
; 1044 :         dwPosition = pfSamplePos >> 12;

	mov	edx, ebx
	mov	ecx, DWORD PTR pfPitch

; 1045 :         dwFract = pfSamplePos & 0xFFF;

	sar	edx, 12					; 0000000cH
	mov	esi, ebx

	add	ebx, ecx
	and	esi, 4095				; 00000fffH

; 1046 :         pfSamplePos += pfPitch;

	mov	ecx, DWORD PTR pcWave

; 1047 : 
; 1048 :         lLM = (long) pcWave[dwPosition];

	movsx	eax, BYTE PTR [ecx+edx]

; 1049 :         lM = ((pcWave[dwPosition+1] - lLM) * dwFract);
; 1050 :         lM >>= 12;
; 1051 :         lM += lLM;

	movsx	edx, BYTE PTR [ecx+edx+1]

    sub	edx, eax
	
    imul	edx, esi

; 1052 :         lLM = lM;
; 1053 :         lLM *= vfLVolume;
; 1054 :         lLM >>= 5;         // Signal bumps up to 15 bits.

	sar	edx, 12					; 0000000cH
	mov	esi, DWORD PTR vfLVolume

	add	edx, eax

; 1072 : 		pBuffer[dwI] += (short) lLM;

	imul	esi, edx

	sar	esi, 5					; 00000005H
	mov	eax, DWORD PTR pBuf

	add	WORD PTR [eax+edi*2], si
	mov	esi, DWORD PTR vfRVolume

	jo	overflow_l
no_oflowl:

; 1078 :         lM *= vfRVolume;
; 1079 : 		lM >>= 5;

	imul	esi, edx

; 1080 : 		pBuffer[dwI+1] += (short) lM;
; 1085 : no_oflowr:
; 1087 : 		dwI += 2;

	sar	esi, 5					; 00000005H
	mov	ecx, DWORD PTR pfPitch

	add	WORD PTR [eax+edi*2+2], si
	mov	edx, DWORD PTR pfPFract

	jo	overflow_r

no_oflowr:
; 978  : 
; 979  :     for (dwI = 0; dwI < dwLength; )

	add	edi, 2
	jl $L30536

$L30539:
	mov DWORD PTR dwI, edi
	mov DWORD PTR pfSamplePos, ebx
}

	dwI += dwLength;

#endif // _X86_

    vfLastVolume[0] = vfLVolume;
    vfLastVolume[1] = vfRVolume;

    m_pfLastPitch = pfPitch;
    m_pfLastSample = pfSamplePos;
    return (dwI >> 1);
}

#ifdef ORG_MONO_MIXER
DWORD CDigitalAudio::MixMono8(short * pBuffer, 
							  DWORD dwLength,
							  DWORD dwDeltaPeriod,
							  VFRACT vfDeltaVolume,
							  VFRACT vfLastVolume[],
							  PFRACT pfDeltaPitch, 
							  PFRACT pfSampleLength, 
							  PFRACT pfLoopLength)
{
    DWORD dwI;
    DWORD dwPosition;
    long lM;
    DWORD dwIncDelta = dwDeltaPeriod;
    VFRACT dwFract;
    char * pcWave = (char *) m_pnWave;
    PFRACT pfSamplePos = m_pfLastSample;
    VFRACT vfVolume = vfLastVolume[0];
    PFRACT pfPitch = m_pfLastPitch;
    PFRACT pfPFract = pfPitch << 8;
    VFRACT vfVFract = vfVolume << 8;  // Keep high res version around. 

#ifndef _X86_
    for (dwI = 0; dwI < dwLength; )
    {
        if (pfSamplePos >= pfSampleLength)
	    {	
	        if (pfLoopLength)
		    pfSamplePos -= pfLoopLength;
	        else
		    break;
	    }
        dwIncDelta--;
        if (!dwIncDelta) 
        {
            dwIncDelta = dwDeltaPeriod;
            pfPFract += pfDeltaPitch;
            pfPitch = pfPFract >> 8;
            vfVFract += vfDeltaVolume;
            vfVolume = vfVFract >> 8;
        }

	    dwPosition = pfSamplePos >> 12;
	    dwFract = pfSamplePos & 0xFFF;
		pfSamplePos += pfPitch;

	    lM = pcWave[dwPosition];
	    lM += ((pcWave[dwPosition + 1] - lM) * dwFract) >> 12;
		lM *= vfVolume;
		lM >>= 5;

#ifndef _X86_
#ifdef _ALPHA_
		int nBitmask;
		if( ALPHA_OVERFLOW & (nBitmask = __ADAWI( (short) lM, &pBuffer[dwI] )) )  {
			if( ALPHA_NEGATIVE & nBitmask )  {
				pBuffer[dwI] = 0x7FFF;
			}
			else  pBuffer[dwI] = (short) 0x8000;
		}
#else // !_ALPHA_
    //  TODO -- overflow code on ia64 (+ axp64?)
#endif // !_ALPHA_

#else // _X86_  (dead code)
      // Keep this around so we can use it to generate new assembly code (see below...)
		pBuffer[dwI] += (short) lM;
        _asm{jno no_oflow}
        pBuffer[dwI] = 0x7fff;
        _asm{js  no_oflow}
        pBuffer[dwI] = (short) 0x8000;
no_oflow:
#endif  // _X86_  (dead code)
		dwI++;
    }
#else // _X86_
	int i, a, b, c, total;
	short * pBuf = pBuffer + dwLength, *pBufX;
	dwI = - dwLength;

	_asm {

; 979  :     for (dwI = 0; dwI < dwLength; )

//	Induction variables.
	mov	edi, dwI
	mov	ebx, DWORD PTR pfSamplePos

// Previously set up.
	cmp	DWORD PTR dwLength, 0
	mov	edx, pfPFract

	mov	ecx, DWORD PTR pfPitch
	je	$L30539

$L30536:
	cmp	ebx, DWORD PTR pfSampleLength

; 981  :         if (pfSamplePos >= pfSampleLength)

	mov	esi, DWORD PTR dwIncDelta
	jge	SHORT $L30540_

$L30540:

; 987  : 	        else
; 988  : 		    break;
; 990  :         dwIncDelta--;

	dec	esi
	mov	DWORD PTR dwIncDelta, esi

; 991  :         if (!dwIncDelta)    

	je	SHORT $L30541_

$L30541:
// esi, edx, edi		esi == dwIncDelta

	mov	DWORD PTR i, 0

; 1010 : 	b = dwIncDelta;
// esi = b == dwIncDelta

; 1011 : 	c = (pfSampleLength - pfSamplePos) / pfPitch;

; 1009 : 	a = dwLength - dwI;	// Remaining span.

	mov	edx, edi
	neg	edx

; 1017 : 	if (b < a && b < c)

	cmp	esi, edx
	jge	try_ax

	mov	eax, ecx
	imul	eax, esi
	add	eax, ebx

	cmp eax, DWORD PTR pfSampleLength 
	jge	try_c

; 1019 : 		i = b;

	cmp	esi, 3
	jl	got_it

	mov	DWORD PTR i, esi
	jmp	SHORT got_it

; 1013 : 	if (a < b && a < c)

try_a:

	cmp	edx, esi
	jge	try_c
try_ax:
	mov	eax, edx
	imul	eax, ecx
	add	eax, ebx

	cmp eax, DWORD PTR pfSampleLength
	jge	try_c

; 1015 : 		i = a;

	cmp	edx, 3
	jl	got_it

	mov	DWORD PTR i, edx
	jmp	SHORT got_it

; 1021 : 	else if (c < a && c < b)
try_c:

    push	edx
	mov	eax, DWORD PTR pfSampleLength
	sub	eax, ebx
	cdq
	idiv	ecx		// eax == c
	pop	edx

    cmp	eax, edx
	jge	got_it
try_cx:
	cmp	eax, esi
	jge	got_it

; 1023 : 		i = c;

	cmp	eax, 3
	jl	$L30543

	mov DWORD PTR i, eax

got_it:
	mov	edx, DWORD PTR i
	mov	eax, DWORD PTR pBuf

	dec	edx
	jl	$L30543

	sub	DWORD PTR dwIncDelta, edx

; 1093 :     return (dwI);
; 1094 : }

	lea	edx, [edx+1]			// Current span.
	lea	eax, [eax+edi*2]		// Starting position.

	add	edi, edx				// Remaining span.
	lea	eax, [eax+edx*2]		// New ending position.

	push	edi
	mov	edi, edx				// Current span.

	mov	DWORD PTR pBufX, eax
	neg	edi

$L30797:
		
; 1005 : 			do
; 1010 : 				dwPosition = pfSamplePos >> 12;
; 1011 : 				dwFract = pfSamplePos & 0xFFF;

	mov	edx, ebx
	mov	esi, ebx

	add	ebx, ecx
	mov	ecx, DWORD PTR pcWave

; 1012 : 				pfSamplePos += pfPitch;

	sar	edx, 12					; 0000000cH
	and	esi, 4095				; 00000fffH

; 1013 : 
; 1014 : 				lLM = (long) pcWave[dwPosition];

	movsx	eax, BYTE PTR [ecx+edx]

; 1015 : 				lM = ((pcWave[dwPosition+1] - lLM) * dwFract);
; 1016 : 				lM >>= 12;
; 1017 : 				lM += lLM;

	movsx	edx, BYTE PTR [ecx+edx+1]

	sub	edx, eax

; 1018 : 				lLM = lM;
; 1019 : 				lLM *= vfLVolume;
; 1020 : 				lLM >>= 5;         // Signal bumps up to 15 bits.
; 1022 : 				pBuffer[dwI] += (short) lLM;
; 1027 : no_oflowx:	
; 1037 : 				++dwI;

	imul	edx, esi

	sar	edx, 12					; 0000000cH
	mov	esi, DWORD PTR vfVolume

	mov	ecx, DWORD PTR pfPitch
	add	edx, eax

	imul	esi, edx

	sar	esi, 5					; 00000005H
	mov	eax, DWORD PTR pBufX

	add	WORD PTR [eax+edi*2], si
	jo	overflow_x

no_oflowx:

	inc	edi
	jne	SHORT $L30797

	pop	edi

; 1039 : 			++dwIncDelta;
; 1040 : 			continue;

	mov	edx, DWORD PTR pfPFract
	cmp	edi, 0

	jl	SHORT $L30536
	jmp	SHORT $L30539

$L30540_:
; 982  : 	    {	
; 983  : 	        if (pfLoopLength)

	cmp	DWORD PTR pfLoopLength, 0
	je	$L30539

; 984  : 			{
; 985  : 				pfSamplePos -= pfLoopLength;

	sub	ebx, DWORD PTR pfLoopLength
	jmp	$L30540

$L30541_:
; 994  :             pfPFract += pfDeltaPitch;

	mov	ecx, DWORD PTR pfDeltaPitch
	mov	esi, DWORD PTR vfDeltaVolume

	add	ecx, edx
	mov	edx, DWORD PTR vfVFract

; 995  :             pfPitch = pfPFract >> 8;
; 996  :             vfVFract += vfDeltaVolume;

	mov	DWORD PTR pfPFract, ecx
	add	edx, esi

; 997  :             vfLVolume = vfLVFract >> 8;

	sar	ecx, 8
	mov	DWORD PTR vfVFract, edx
	
	sar	edx, 8
	mov	esi, DWORD PTR dwDeltaPeriod


	mov	DWORD PTR vfVolume, edx
	mov	DWORD PTR pfPitch, ecx


	mov	DWORD PTR dwIncDelta, esi

; 993  :             dwIncDelta = dwDeltaPeriod;

	jmp	$L30541

// Handle truncation.

overflow_:
	mov	WORD PTR [eax+edi*2], 0x7fff
	js	no_oflow
	mov	WORD PTR [eax+edi*2], 0x8000
	jmp no_oflow

overflow_x:
	mov	WORD PTR [eax+edi*2], 0x7fff
	js	no_oflowx
	mov	WORD PTR [eax+edi*2], 0x8000
	jmp	no_oflowx

$L30543:
; 1044 :         dwPosition = pfSamplePos >> 12;

	mov	edx, ebx
	mov	ecx, DWORD PTR pfPitch

; 1045 :         dwFract = pfSamplePos & 0xFFF;

	sar	edx, 12					; 0000000cH
	mov	esi, ebx

	add	ebx, ecx
	and	esi, 4095				; 00000fffH

; 1046 :         pfSamplePos += pfPitch;

	mov	ecx, DWORD PTR pcWave

; 1047 : 
; 1048 :         lLM = (long) pcWave[dwPosition];

	movsx	eax, BYTE PTR [ecx+edx]

; 1049 :         lM = ((pcWave[dwPosition+1] - lLM) * dwFract);
; 1050 :         lM >>= 12;
; 1051 :         lM += lLM;

	movsx	edx, BYTE PTR [ecx+edx+1]

	sub	edx, eax

	imul	edx, esi

; 1052 :         lLM = lM;
; 1053 :         lLM *= vfLVolume;
; 1054 :         lLM >>= 5;         // Signal bumps up to 15 bits.

	sar	edx, 12					; 0000000cH
	mov	esi, DWORD PTR vfVolume

	add	edx, eax

; 1072 : 		pBuffer[dwI] += (short) lLM;

	imul	esi, edx

	sar	esi, 5					; 00000005H
	mov	eax, DWORD PTR pBuf

	add	WORD PTR [eax+edi*2], si
	jo	overflow_
no_oflow:
	inc	edi
	mov	edx, DWORD PTR pfPFract

; 979  :     for (dwI = 0; dwI < dwLength; )

	mov	ecx, DWORD PTR pfPitch
	jl $L30536

$L30539:
	mov DWORD PTR dwI, edi
	mov DWORD PTR pfSamplePos, ebx
}

	dwI += dwLength;

#endif // _X86_

    vfLastVolume[0] = vfVolume;
    vfLastVolume[1] = vfVolume; // !!! is this right?
    m_pfLastPitch = pfPitch;
    m_pfLastSample = pfSamplePos;
    return (dwI);
}
#endif

DWORD CDigitalAudio::Mix16(short * pBuffer, 
						   DWORD dwLength, 
						   DWORD dwDeltaPeriod,
						   VFRACT vfDeltaLVolume, 
						   VFRACT vfDeltaRVolume,
						   VFRACT vfLastVolume[],
						   PFRACT pfDeltaPitch, 
						   PFRACT pfSampleLength, 
						   PFRACT pfLoopLength)
{
    DWORD dwI;
    DWORD dwPosition;
    long lA;
    long lM;
    DWORD dwIncDelta = dwDeltaPeriod;
    VFRACT dwFract;
    short * pcWave = m_pnWave;
    PFRACT pfSamplePos = m_pfLastSample;
    VFRACT vfLVolume = vfLastVolume[0];
    VFRACT vfRVolume = vfLastVolume[1];
    PFRACT pfPitch = m_pfLastPitch;
    PFRACT pfPFract = pfPitch << 8;
    VFRACT vfLVFract = vfLVolume << 8;  // Keep high res version around.
    VFRACT vfRVFract = vfRVolume << 8; 
	dwLength <<= 1;

	static int _a = 0, _b = 0, _c = 0;

#ifndef _X86_
    for (dwI = 0; dwI < dwLength; )
    {
        if (pfSamplePos >= pfSampleLength)
	    {	
	        if (pfLoopLength)
			{
				pfSamplePos -= pfLoopLength;
			}
	        else
		    break;
	    }
        dwIncDelta--;
        if (!dwIncDelta)    
        {
            dwIncDelta = dwDeltaPeriod;
            pfPFract += pfDeltaPitch;
            pfPitch = pfPFract >> 8;
            vfLVFract += vfDeltaLVolume;
            vfLVolume = vfLVFract >> 8;
            vfRVFract += vfDeltaRVolume;
            vfRVolume = vfRVFract >> 8;
        }
        dwPosition = pfSamplePos >> 12;
        dwFract = pfSamplePos & 0xFFF;
        pfSamplePos += pfPitch;

        lA = (long) pcWave[dwPosition];
        lM = ((pcWave[dwPosition+1] - lA) * dwFract);
        lM >>= 12;
        lM += lA;
        lA = lM;
        lA *= vfLVolume;
        lA >>= 13;         // Signal bumps up to 15 bits.
		lM *= vfRVolume;
		lM >>= 13;
#ifndef _X86_
#ifdef _ALPHA_
		int nBitmask;
		if( ALPHA_OVERFLOW & (nBitmask = __ADAWI( (short) lA, &pBuffer[dwI] )) )  {
			if( ALPHA_NEGATIVE & nBitmask )  {
				pBuffer[dwI] = 0x7FFF;
			}
			else  pBuffer[dwI] = (short) 0x8000;
		}
		if( ALPHA_OVERFLOW & (nBitmask = __ADAWI( (short) lM, &pBuffer[dwI+1] )) )  {
			if( ALPHA_NEGATIVE & nBitmask )  {
				pBuffer[dwI+1] = 0x7FFF;
			}
			else  pBuffer[dwI+1] = (short) 0x8000;
		}
#else // !_ALPHA_
    //  TODO -- overflow detection on ia64 (+ axp64?)
#endif // !_ALPHA_
#else // _X86_  (dead code)
      //  Keep this around so we can use it to generate new assembly code (see below...)
		pBuffer[dwI] += (short) lA;

        _asm{jno no_oflowl}
        pBuffer[dwI] = 0x7fff;
        _asm{js  no_oflowl}
        pBuffer[dwI] = (short) 0x8000;
no_oflowl:	

		pBuffer[dwI+1] += (short) lM;

        _asm{jno no_oflowr}
        pBuffer[dwI+1] = 0x7fff;
        _asm{js  no_oflowr}
        pBuffer[dwI+1] = (short) 0x8000;
no_oflowr:

#endif // _X86_  (dead code)
		dwI += 2;
    }
#else // _X86_
	int i, a, b, c, total;
	short * pBuf = pBuffer + dwLength, *pBufX;
	dwI = - dwLength;

	_asm {

; 979  :     for (dwI = 0; dwI < dwLength; )

//	Induction variables.
	mov	edi, dwI
	mov	ebx, DWORD PTR pfSamplePos

// Previously set up.
	cmp	DWORD PTR dwLength, 0
	mov	edx, pfPFract

	mov	ecx, DWORD PTR pfPitch
	je	$L30539

$L30536:
	cmp	ebx, DWORD PTR pfSampleLength

; 981  :         if (pfSamplePos >= pfSampleLength)

	mov	esi, DWORD PTR dwIncDelta
	jge	SHORT $L30540_

$L30540:
; 987  : 	        else
; 988  : 		    break;
; 990  :         dwIncDelta--;

	dec	esi
	mov	DWORD PTR dwIncDelta, esi

; 991  :         if (!dwIncDelta)    

	je	SHORT $L30541_

$L30541:
// esi, edx, edi		esi == dwIncDelta

	mov	DWORD PTR i, 0

; 1010 : 	b = dwIncDelta;
// esi = b == dwIncDelta
; 1011 : 	c = (pfSampleLength - pfSamplePos) / pfPitch;
; 1009 : 	a = (dwLength - dwI) / 2;	// Remaining span.

	mov	edx, edi
	neg	edx
	shr	edx, 1		// edx = a

; 1017 : 	if (b < a && b < c)

	cmp	esi, edx
	jge	try_ax

	mov	eax, ecx
	imul	eax, esi
	add	eax, ebx

	cmp eax, DWORD PTR pfSampleLength 
	jge	try_c

; 1019 : 		i = b;

	cmp	esi, 3
	jl	got_it

	mov	DWORD PTR i, esi
	jmp	SHORT got_it

; 1013 : 	if (a < b && a < c)

try_a:

	cmp	edx, esi
	jge	try_c
try_ax:
	mov	eax, edx
	imul	eax, ecx
	add	eax, ebx

	cmp eax, DWORD PTR pfSampleLength
	jge	try_c

; 1015 : 		i = a;

	cmp	edx, 3
	jl	got_it

	mov	DWORD PTR i, edx
	jmp	SHORT got_it

; 1021 : 	else if (c < a && c < b)
try_c:

    push	edx
	mov	eax, DWORD PTR pfSampleLength
	sub	eax, ebx
	cdq
	idiv	ecx		// eax == c
	pop	edx

    cmp	eax, edx
	jge	got_it
try_cx:
	cmp	eax, esi
	jge	got_it

; 1023 : 		i = c;

	cmp	eax, 3
	jl	$L30543

	mov DWORD PTR i, eax

got_it:
	mov	edx, DWORD PTR i
	mov	eax, DWORD PTR pBuf

	dec	edx
	jl	$L30543

	sub	DWORD PTR dwIncDelta, edx

; 1093 :     return (dwI >> 1);
; 1094 : }

	lea	edx, [edx*2+2]			// Current span.
	lea	eax, [eax+edi*2]		// Starting position.

	add	edi, edx				// Remaining span.
	lea	eax, [eax+edx*2]		// New ending position.

	push	edi
	mov	edi, edx				// Current span.

	mov	DWORD PTR pBufX, eax
	neg	edi

$L30797:
		
; 1005 : 			do
; 1010 : 				dwPosition = pfSamplePos >> 12;
; 1011 : 				dwFract = pfSamplePos & 0xFFF;

	mov	edx, ebx
	mov	esi, ebx

	add	ebx, ecx
	mov	ecx, DWORD PTR pcWave

; 1012 : 				pfSamplePos += pfPitch;

	sar	edx, 12					; 0000000cH
	and	esi, 4095				; 00000fffH

; 1014 : 				lA = (long) pcWave[dwPosition];

	movsx	eax, WORD PTR [ecx+edx*2]

; 1015 : 				lM = ((pcWave[dwPosition+1] - lA) * dwFract);
; 1016 : 				lM >>= 12;
; 1017 : 				lM += lA;

	movsx	edx, WORD PTR [ecx+edx*2+2]
	sub	edx, eax

; 1018 : 				lA = lM;
; 1019 : 				lA *= vfLVolume;
; 1020 : 				lA >>= 13;         // Signal bumps up to 15 bits.
; 1022 : 				pBuffer[dwI] += (short) lA;
; 1027 : no_oflowlx:	
; 1028 : 						lM *= vfRVolume;
; 1029 : 						lM >>= 13;
; 1030 : 				pBuffer[dwI+1] += (short) lM;
; 1035 : no_oflowrx:
; 1037 : 				dwI += 2;

	imul	edx, esi

	sar	edx, 12					; 0000000cH
	mov	esi, DWORD PTR vfLVolume

	add	edx, eax
	mov	eax, DWORD PTR pBufX

	imul	esi, edx

	sar	esi, 13					; 0000000dH

	add	WORD PTR [eax+edi*2], si

	mov	esi, DWORD PTR vfRVolume
	jo	overflow_lx
no_oflowlx:

	imul	esi, edx

; 1038 : 			} while (--dwIncDelta);

	sar	esi, 13					; 0000000dH
	mov	ecx, DWORD PTR pfPitch

	add	WORD PTR [eax+edi*2+2], si
	jo	overflow_rx

no_oflowrx:

	add	edi, 2
	jne	SHORT $L30797

	pop	edi

; 1039 : 			++dwIncDelta;
; 1040 : 			continue;

	mov	edx, DWORD PTR pfPFract
	cmp	edi, 0

	jl	SHORT $L30536
	jmp	SHORT $L30539

$L30540_:
; 982  : 	    {	
; 983  : 	        if (pfLoopLength)

	cmp	DWORD PTR pfLoopLength, 0
	je	$L30539

; 985  : 				pfSamplePos -= pfLoopLength;

	sub	ebx, DWORD PTR pfLoopLength
	jmp	$L30540

$L30541_:
; 994  :             pfPFract += pfDeltaPitch;

	mov	ecx, DWORD PTR pfDeltaPitch
	mov	esi, DWORD PTR vfDeltaLVolume

	add	ecx, edx
	mov	edx, DWORD PTR vfLVFract

; 995  :             pfPitch = pfPFract >> 8;
; 996  :             vfLVFract += vfDeltaLVolume;

	mov	DWORD PTR pfPFract, ecx
	add	edx, esi

; 997  :             vfLVolume = vfLVFract >> 8;
; 998  :             vfRVFract += vfDeltaRVolume;

	sar	ecx, 8
	mov	DWORD PTR vfLVFract, edx
	
	sar	edx, 8
	mov	esi, DWORD PTR vfDeltaRVolume

	mov	DWORD PTR vfLVolume, edx
	mov	edx, DWORD PTR vfRVFract

	add	edx, esi
	mov	DWORD PTR pfPitch, ecx

	mov	DWORD PTR vfRVFract, edx
	mov	esi, DWORD PTR dwDeltaPeriod

; 999  :             vfRVolume = vfRVFract >> 8;

	sar	edx, 8
	mov	DWORD PTR dwIncDelta, esi

; 993  :             dwIncDelta = dwDeltaPeriod;

	mov	DWORD PTR vfRVolume, edx
	jmp	$L30541

// Handle truncation.
overflow_l:
	mov	WORD PTR [eax+edi*2], 0x7fff
	js	no_oflowl
	mov	WORD PTR [eax+edi*2], 0x8000
	jmp no_oflowl

overflow_r:
	mov	WORD PTR [eax+edi*2+2], 0x7fff
	js	no_oflowr
	mov	WORD PTR [eax+edi*2+2], 0x8000
	jmp	no_oflowr

overflow_lx:
	mov	WORD PTR [eax+edi*2], 0x7fff
	js	no_oflowlx
	mov	WORD PTR [eax+edi*2], 0x8000
	jmp	no_oflowlx

overflow_rx:
	mov	WORD PTR [eax+edi*2+2], 0x7fff
	js	no_oflowrx
	mov	WORD PTR [eax+edi*2+2], 0x8000
	jmp	no_oflowrx

$L30543:
; 1044 :         dwPosition = pfSamplePos >> 12;

	mov	edx, ebx
	mov	ecx, DWORD PTR pfPitch

; 1045 :         dwFract = pfSamplePos & 0xFFF;

	sar	edx, 12					; 0000000cH
	mov	esi, ebx

	and	esi, 4095				; 00000fffH
	add	ebx, ecx

; 1046 :         pfSamplePos += pfPitch;

	mov	ecx, DWORD PTR pcWave

; 1047 : 
; 1048 :         lA = (long) pcWave[dwPosition];

	movsx	eax, WORD PTR [ecx+edx*2]

; 1049 :         lM = ((pcWave[dwPosition+1] - lA) * dwFract);
; 1050 :         lM >>= 12;
; 1051 :         lM += lA;

	movsx	edx, WORD PTR [ecx+edx*2+2]

	sub	edx, eax

	imul	edx, esi

; 1052 :         lA = lM;
; 1053 :         lA *= vfLVolume;
; 1054 :         lA >>= 13;         // Signal bumps up to 15 bits.

	sar	edx, 12					; 0000000cH
	mov	esi, DWORD PTR vfLVolume

	add	edx, eax

; 1072 : 		pBuffer[dwI] += (short) lA;

	imul	esi, edx

	sar	esi, 13					; 0000000dH
	mov	eax, DWORD PTR pBuf

	add	WORD PTR [eax+edi*2], si
	mov	esi, DWORD PTR vfRVolume

	jo	overflow_l
no_oflowl:

; 1077 : no_oflowl:	
; 1078 :         lM *= vfRVolume;
; 1079 : 		lM >>= 13;

	imul	esi, edx

; 1080 : 		pBuffer[dwI+1] += (short) lM;
; 1085 : no_oflowr:
; 1086 : #endif  /* _ALPHA */
; 1087 : 		dwI += 2;

	sar	esi, 13					; 0000000dH
	mov	ecx, DWORD PTR pfPitch

	add	WORD PTR [eax+edi*2+2], si
	mov	edx, DWORD PTR pfPFract

	jo	overflow_r
no_oflowr:

	add	edi, 2

; 978  : 
; 979  :     for (dwI = 0; dwI < dwLength; )

	jl $L30536

$L30539:
	mov DWORD PTR dwI, edi
	mov DWORD PTR pfSamplePos, ebx
}

	dwI += dwLength;

#endif // _X86_

    vfLastVolume[0] = vfLVolume;
    vfLastVolume[1] = vfRVolume;
    m_pfLastPitch = pfPitch;
    m_pfLastSample = pfSamplePos;
    return (dwI >> 1);
}


#ifdef ORG_MONO_MIXER
DWORD CDigitalAudio::MixMono16(short * pBuffer, 
							   DWORD dwLength,
							   DWORD dwDeltaPeriod,
							   VFRACT vfDeltaVolume,
							   VFRACT vfLastVolume[],
							   PFRACT pfDeltaPitch, 
							   PFRACT pfSampleLength, 
							   PFRACT pfLoopLength)
{
    DWORD dwI;
    DWORD dwPosition;
    long lA;//, lB;
    long lM;
    DWORD dwIncDelta = dwDeltaPeriod;
    VFRACT dwFract;
    short * pcWave = m_pnWave;
    PFRACT pfSamplePos = m_pfLastSample;
    VFRACT vfVolume = vfLastVolume[0];
    PFRACT pfPitch = m_pfLastPitch;
    PFRACT pfPFract = pfPitch << 8;
    VFRACT vfVFract = vfVolume << 8;  // Keep high res version around.

#ifndef _X86_
    for (dwI = 0; dwI < dwLength;)
    {
        if (pfSamplePos >= pfSampleLength)
	    {	
	        if (pfLoopLength)
		    pfSamplePos -= pfLoopLength;
	        else
		    break;
	    }
        dwIncDelta--;
        if (!dwIncDelta)   
        {
            dwIncDelta = dwDeltaPeriod;
            pfPFract += pfDeltaPitch;
            pfPitch = pfPFract >> 8;
            vfVFract += vfDeltaVolume;
            vfVolume = vfVFract >> 8;
        }

        dwPosition = pfSamplePos >> 12;
        dwFract = pfSamplePos & 0xFFF;
        pfSamplePos += pfPitch;

        lA = (long) pcWave[dwPosition];
        lM = (((pcWave[dwPosition+1] - lA) * dwFract) >> 12) + lA;

        lM *= vfVolume; 
        lM >>= 13;         // Signal bumps up to 12 bits.

#ifndef _X86_
#ifdef _ALPHA_
		int nBitmask;
		if( ALPHA_OVERFLOW & (nBitmask = __ADAWI( (short) lM, &pBuffer[dwI] )) )  {
			if( ALPHA_NEGATIVE & nBitmask )  {
				pBuffer[dwI] = 0x7FFF;
			}
			else  pBuffer[dwI] = (short) 0x8000;
		}
#else // !_ALPHA_
    // TODO -- overflow detection for ia64 (+ axp64?)
#endif // !_ALPHA_
#else // _X86_  (dead code)
        // Keep this around so we can use it to generate new assembly code (see below...)
        pBuffer[dwI] += (short) lM;
        _asm{jno no_oflow}
        pBuffer[dwI] = 0x7fff;
        _asm{js  no_oflow}
        pBuffer[dwI] = (short) 0x8000;
no_oflow:	
#endif // _X86  (dead code)
		dwI++;
    }
#else // _X86_
	int i, a, b, c, total;
	short * pBuf = pBuffer + dwLength, *pBufX;
	dwI = - dwLength;

	_asm {

; 979  :     for (dwI = 0; dwI < dwLength; )

//	Induction variables.
	mov	edi, dwI
	mov	ebx, DWORD PTR pfSamplePos

// Previously set up.
	cmp	DWORD PTR dwLength, 0
	mov	edx, pfPFract

	mov	ecx, DWORD PTR pfPitch
	je	$L30539

$L30536:
	cmp	ebx, DWORD PTR pfSampleLength

; 981  :         if (pfSamplePos >= pfSampleLength)

	mov	esi, DWORD PTR dwIncDelta
	jge	SHORT $L30540_

$L30540:
; 987  : 	        else
; 988  : 		    break;
; 990  :         dwIncDelta--;

	dec	esi
	mov	DWORD PTR dwIncDelta, esi

; 991  :         if (!dwIncDelta)    

	je	SHORT $L30541_

$L30541:
// esi, edx, edi		esi == dwIncDelta

	mov	DWORD PTR i, 0

; 1010 : 	b = dwIncDelta;
// esi = b == dwIncDelta
; 1011 : 	c = (pfSampleLength - pfSamplePos) / pfPitch;
; 1009 : 	a = dwLength - dwI;	// Remaining span.

	mov	edx, edi
	neg	edx

; 1017 : 	if (b < a && b < c)

	cmp	esi, edx
	jge	try_ax

	mov	eax, ecx
	imul	eax, esi
	add	eax, ebx

	cmp eax, DWORD PTR pfSampleLength 
	jge	try_c

; 1019 : 		i = b;

	cmp	esi, 3
	jl	got_it

	mov	DWORD PTR i, esi
	jmp	SHORT got_it

; 1013 : 	if (a < b && a < c)

try_a:

	cmp	edx, esi
	jge	try_c
try_ax:
	mov	eax, edx
	imul	eax, ecx
	add	eax, ebx

	cmp eax, DWORD PTR pfSampleLength
	jge	try_c

; 1015 : 		i = a;

	cmp	edx, 3
	jl	got_it

	mov	DWORD PTR i, edx
	jmp	SHORT got_it

; 1021 : 	else if (c < a && c < b)
try_c:
	push	edx
	mov	eax, DWORD PTR pfSampleLength
	sub	eax, ebx
	cdq
	idiv	ecx		// eax == c
	pop	edx

    cmp	eax, edx
	jge	got_it
try_cx:
	cmp	eax, esi
	jge	got_it

; 1023 : 		i = c;

	cmp	eax, 3
	jl	$L30543

	mov DWORD PTR i, eax

got_it:
	mov	edx, DWORD PTR i
	mov	eax, DWORD PTR pBuf

	dec	edx
	jl	$L30543

	sub	DWORD PTR dwIncDelta, edx

; 1093 :     return (dwI);
; 1094 : }

	lea	edx, [edx+1]			// Current span.
	lea	eax, [eax+edi*2]		// Starting position.

	add	edi, edx				// Remaining span.
	lea	eax, [eax+edx*2]		// New ending position.

	push	edi
	mov	edi, edx				// Current span.

	mov	DWORD PTR pBufX, eax
	neg	edi

$L30797:
; 1005 : 			do
; 1010 : 				dwPosition = pfSamplePos >> 12;
; 1011 : 				dwFract = pfSamplePos & 0xFFF;

	mov	edx, ebx
	mov	esi, ebx

	add	ebx, ecx
	mov	ecx, DWORD PTR pcWave

; 1012 : 				pfSamplePos += pfPitch;

	sar	edx, 12					; 0000000cH
	and	esi, 4095				; 00000fffH

; 1013 : 
; 1014 : 				lA = (long) pcWave[dwPosition];

	movsx	eax, WORD PTR [ecx+edx*2]

; 1015 : 				lM = ((pcWave[dwPosition+1] - lA) * dwFract);
; 1016 : 				lM >>= 12;
; 1017 : 				lM += lA;

	movsx	edx, WORD PTR [ecx+edx*2+2]

	sub	edx, eax

; 1018 : 				lA = lM;
; 1019 : 				lA *= vfLVolume;
; 1020 : 				lA >>= 13;         // Signal bumps up to 15 bits.
; 1022 : 				pBuffer[dwI] += (short) lA;
; 1027 : no_oflowx:	
; 1037 : 				++dwI;

	imul	edx, esi

	sar	edx, 12					; 0000000cH
	mov	esi, DWORD PTR vfVolume

	add	edx, eax
	mov	ecx, DWORD PTR pfPitch

	imul	esi, edx

	sar	esi, 13					; 0000000dH
	mov	eax, DWORD PTR pBufX

	add	WORD PTR [eax+edi*2], si
	jo	overflow_x
no_oflowx:

; 1038 : 			} while (--dwIncDelta);

	inc	edi
	jne	SHORT $L30797

	pop	edi

; 1039 : 			++dwIncDelta;
; 1040 : 			continue;

	mov	edx, DWORD PTR pfPFract
	cmp	edi, 0

	jl	SHORT $L30536
	jmp	SHORT $L30539

$L30540_:
; 983  : 	        if (pfLoopLength)

	cmp	DWORD PTR pfLoopLength, 0
	je	$L30539

; 985  : 				pfSamplePos -= pfLoopLength;

	sub	ebx, DWORD PTR pfLoopLength
	jmp	$L30540

$L30541_:
; 994  :             pfPFract += pfDeltaPitch;

	mov	ecx, DWORD PTR pfDeltaPitch
	mov	esi, DWORD PTR vfDeltaVolume

	add	ecx, edx
	mov	edx, DWORD PTR vfVFract

; 995  :             pfPitch = pfPFract >> 8;
; 996  :             vfVFract += vfDeltaVolume;

	mov	DWORD PTR pfPFract, ecx
	add	edx, esi

; 997  :             vfVolume = vfVFract >> 8;

	sar	ecx, 8
	mov	DWORD PTR vfVFract, edx
	
	sar	edx, 8
	mov	esi, DWORD PTR dwDeltaPeriod

	mov	DWORD PTR vfVolume, edx
	mov	DWORD PTR pfPitch, ecx


	mov	DWORD PTR dwIncDelta, esi

; 993  :             dwIncDelta = dwDeltaPeriod;

	jmp	$L30541

// Handle truncation.
overflow_:
	mov	WORD PTR [eax+edi*2], 0x7fff
	js	no_oflow
	mov	WORD PTR [eax+edi*2], 0x8000
	jmp no_oflow

overflow_x:
	mov	WORD PTR [eax+edi*2], 0x7fff
	js	no_oflowx
	mov	WORD PTR [eax+edi*2], 0x8000
	jmp	no_oflowx

$L30543:
; 1044 :         dwPosition = pfSamplePos >> 12;

	mov	edx, ebx
	mov	ecx, DWORD PTR pfPitch

; 1045 :         dwFract = pfSamplePos & 0xFFF;

	sar	edx, 12					; 0000000cH
	mov	esi, ebx

	and	esi, 4095				; 00000fffH
	add	ebx, ecx

; 1046 :         pfSamplePos += pfPitch;

	mov	ecx, DWORD PTR pcWave

; 1047 : 
; 1048 :         lA = (long) pcWave[dwPosition];

	movsx	eax, WORD PTR [ecx+edx*2]

; 1049 :         lM = ((pcWave[dwPosition+1] - lA) * dwFract);
; 1050 :         lM >>= 12;
; 1051 :         lM += lA;

	movsx	edx, WORD PTR [ecx+edx*2+2]

	sub	edx, eax

	imul	edx, esi

; 1052 :         lA = lM;
; 1053 :         lA *= vfVolume;
; 1054 :         lA >>= 13;         // Signal bumps up to 15 bits.

	sar	edx, 12					; 0000000cH
	mov	esi, DWORD PTR vfVolume

	add	edx, eax

; 1072 : 		pBuffer[dwI] += (short) lA;

	imul	esi, edx

	sar	esi, 13					; 0000000dH
	mov	eax, DWORD PTR pBuf

	add	WORD PTR [eax+edi*2], si
	jo	overflow_
no_oflow:
; 1077 : no_oflowl:	
; 1087 : 		++dwI;

	inc	edi
	mov	edx, DWORD PTR pfPFract

; 979  :     for (dwI = 0; dwI < dwLength; )

	mov	ecx, DWORD PTR pfPitch
	jl $L30536

$L30539:
	mov DWORD PTR dwI, edi
	mov DWORD PTR pfSamplePos, ebx
}
	dwI += dwLength;

#endif // _X86_
    vfLastVolume[0] = vfVolume;
    vfLastVolume[1] = vfVolume; // !!! is this right?
    m_pfLastPitch = pfPitch;
    m_pfLastSample = pfSamplePos;
    return (dwI);
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\XboxSynth\mmx.cpp ===
//      Copyright (c) 1996-1999 Microsoft Corporation
//      Mmx.cpp
//      MMX Mix engines for Microsoft synth

/*
Variable useage.

		Variable									register 
		pfSamplePos									eax
		pfPitch										ebx
		dwI											ecx
		dwIncDelta									edx (edx is sometimes a temporary register)
		dwPosition1									esi
		dwPostiion2									edi

		vfRvolume and vfLvolume						mm0		
		vfRVolume, vfLVolume						mm2		

		mm4 - mm7 are temporary mmx registers.
*/

// Notes about calculation.

		// Loop is unrolled once.
		// *1  shifting volumne to 15 bit values to get rid of shifts and simplify code.
		// This make the packed mulitply work better later since I keep the sound interpolated
		// wave value at 16 bit signed value.  For a PMULHW, this results in 15 bit results
		// which is the same as the original code.


		// *2 linear interpolation can be done very quickly with MMX by re-arranging the
		// way that the interpolation is done. Here is code in C that shows the difference.
		// Original C code		
        //lM1 = ((pcWave[dwPosition1 + 1] - pcWave[dwPosition1]) * dwFract1) >> 12;
		//lM2 = ((pcWave[dwPosition2 + 1] - pcWave[dwPosition2]) * dwFract2) >> 12;
        //lM1 += pcWave[dwPosition1];
		//lM2 += pcWave[dwPosition2];

		// Equivalent C Code that can be done with a pmadd
		//lM1 = (pcWave[dwPosition1 + 1] * dwFract1 + pcWave[dwPosition1]*(0x1000-dwFract1)) >> 12;
		//lM2 = (pcWave[dwPosition2 + 1] * dwFract2 + pcWave[dwPosition2]*(0x1000-dwFract2)) >> 12;


#ifdef DMSYNTH_MINIPORT
#include "common.h"
#else
#include "simple.h"
#include <mmsystem.h>
#include "synth.h"
#include "debug.h"
#endif

typedef unsigned __int64 QWORD;

#ifdef ORG_MONO_MIXER
DWORD CDigitalAudio::MixMono8X(short * pBuffer, 
							   DWORD dwLength,
							   DWORD dwDeltaPeriod,
							   VFRACT vfDeltaVolume,
							   VFRACT vfLastVolume[],
							   PFRACT pfDeltaPitch, 
							   PFRACT pfSampleLength, 
							   PFRACT pfLoopLength)
{
    DWORD dwI;    
    DWORD dwIncDelta = dwDeltaPeriod;
    
    char * pcWave = (char *) m_pnWave;
    PFRACT pfSamplePos = m_pfLastSample;
    VFRACT vfVolume = vfLastVolume[0];
    PFRACT pfPitch = m_pfLastPitch;
    PFRACT pfPFract = pfPitch << 8;
    VFRACT vfVFract = vfVolume << 8;  // Keep high res version around.


	QWORD	dwFractMASK =	0x000000000FFF0FFF;
	QWORD	dwFractOne  =	0x0000000010001000;	
	QWORD	wordmask	=	0x0000FFFF0000FFFF;
	QWORD	vfDeltaLandRVolume;

_asm{
				
	// vfLVFract and vfRVFract are in mm0
    //VFRACT vfLVFract = vfLVolume1 << 8;  // Keep high res version around.
    //VFRACT vfRVFract = vfRVolume1 << 8;	
	
	movd	mm0, vfVolume
	movd	mm7, vfVolume

	// vfDeltaLVolume and vfDeltaRVolume are put in mm1 so that they can be stored in vfDeltaLandRVolume
	movd	mm1, vfDeltaVolume
	movd	mm6, vfDeltaVolume

  punpckldq mm1, mm6
	
	// dwI = 0
	mov		ecx, 0
	movq	vfDeltaLandRVolume, mm1


	movq	mm1, dwFractOne
	movq	mm4, dwFractMASK
	
	mov		eax, pfSamplePos


  punpckldq mm0, mm7
  	mov		ebx, pfPitch

	pslld	mm0, 8
	mov		edx, dwIncDelta

	movq	mm2, mm0		// vfLVolume and vfRVolume in mm2
							// need to be set before first pass.
 	
	// *1 I shift by 5 so that volume is a 15 bit value instead of a 12 bit value
	psrld	mm2, 5	
	
    //for (dwI = 0; dwI < dwLength; )
    //{
mainloop:
	cmp		ecx, dwLength
	jae		done

		
		
		cmp		eax, pfSampleLength	//if (pfSamplePos >= pfSampleLength)
		jb		NotPastEndOfSample1	//{	
				        
		cmp		pfLoopLength, 0		//if (!pfLoopLength)
			
		je		done				// break;
			
		sub		eax, pfLoopLength	// else pfSamplePos -= pfLoopLength;
	
NotPastEndOfSample1:				//}
					
		mov		esi, eax			// dwPosition1 = pfSamplePos;
		add		eax, ebx			// pfSamplePos += pfPitch;		
				
		sub		edx, 2				// dwIncDelta-=2;				        		        
		jnz		DontIncreaseValues1	//if (!dwIncDelta) {

			// Since edx was use for dwIncDelta and now its zero, we can use if for a temporary
			// for a bit. All code that TestLVol and TestRVol is doing is zeroing out the volume
			// if it goes below zero.
						
			paddd	mm0, vfDeltaLandRVolume	// vfVFract += vfDeltaVolume;
											// vfVFract += vfDeltaVolume;
			pxor	mm5, mm5				// TestLVol = 0; TestRVol = 0;

			
			mov		edx, pfPFract			// Temp = pfPFract;
			pcmpgtd	mm5, mm0			// if (TestLVol > vfLVFract) TestLVol = 0xffffffff;
										// if (TestRVol > vfRVFract) TestRVol = 0xffffffff;

			add		edx, pfDeltaPitch	// Temp += pfDeltaPitch;
			pandn	mm5, mm0			// TestLVol = vfLVFract & (~TestLVol);
										// TestRVol = vfRVFract & (~TestRVol);

			mov		pfPFract, edx		// pfPFract = Temp;
			movq	mm2, mm5			// vfLVolume = TestLVol;
										// vfRVolume = TestRVol;
			

			shr		edx, 8				// Temp = Temp >> 8;
			psrld	mm2, 5				// vfLVolume = vfLVolume >> 5;
										// vfRVolume = vfRVolume >> 5;						
			
			mov		ebx, edx			// pfPitch = Temp;
			mov		edx, dwDeltaPeriod	//dwIncDelta = dwDeltaPeriod;			
			
        //}
DontIncreaseValues1:

		movd	mm6, esi			// dwFract1 = dwPosition1;
		movq	mm5, mm1			// words in mm5 = 0, 0, 0x1000, 0x1000		
		
		shr		esi, 12				// dwPosition1 = dwPosition1 >> 12;		
		inc		ecx					//dwI++;
						
		// if ( dwI < dwLength) break;						
		cmp		ecx, dwLength
		jae		StoreOne
		
		//if (pfSamplePos >= pfSampleLength)
	    //{	
		cmp		eax, pfSampleLength
		jb		NotPastEndOfSample2

			// Original if in C was not negated
	        //if (!pfLoopLength)		    
			cmp		pfLoopLength, 0
			//break;			
			je		StoreOne
			//else
			//pfSamplePos -= pfLoopLength;
			sub		eax, pfLoopLength
	    //}
NotPastEndOfSample2:

		//shl		esi, 1			// do not shift left since pcWave is array of chars
		mov		edi, eax		// dwPosition2 = pfSamplePos;

		add		esi, pcWave		// Put address of pcWave[dwPosition1] in esi			
		movd	mm7, eax		// dwFract2 = pfSamplePos;

		shr		edi, 12			// dwPosition2 = dwPosition2 >> 12;
	punpcklwd	mm6, mm7		// combine dwFract Values. Words in mm6 after unpack are
								// 0, 0, dwFract2, dwFract1
								
		pand	mm6, mm4		// dwFract2 &= 0xfff; dwFract1 &= 0xfff;
		
		movzx	esi, word ptr[esi]	//lLM1 = pcWave[dwPosition1];
		movd	mm3, esi

		psubw	mm5, mm6		// 0, 0, 0x1000 - dwFract2, 0x1000 - dwFract1

		//shl		edi, 1			//do not shift left since pcWave is array of chars
	punpcklwd	mm5, mm6		// dwFract2, 0x1000 - dwFract2, dwFract1, 0x1000 - dwFract1
								
		add		edi, pcWave		// Put address of pcWave[dwPosition2] in edi
		mov		esi, ecx		// Temp = dWI;
             																									
		shl		esi, 1			// Temp = Temp << 1;
		
		movzx	edi, word ptr[edi]	//lLM2 = pcWave[dwPoisition2];
		movd	mm6, edi

		pxor	mm7, mm7		// zero out mm7 to make 8 bit into 16 bit
					
								// low 4 bytes in mm3
		punpcklwd	mm3, mm6	// pcWave[dwPos2+1], pcWave[dwPos2], pcWave[dwPos1+1], pcWave[dwPos1]											
		
		add		esi, pBuffer	//
	punpcklbw	mm7, mm3		// low four bytes bytes in 
								// pcWave[dwPos2+1], pcWave[dwPos2], pcWave[dwPos1+1], pcWave[dwPos1] 
												
		pmaddwd	mm7, mm5		// high dword = lM2 =
								//(pcWave[dwPosition2 + 1] * dwFract2 + pcWave[dwPosition2]*(0x1000-dwFract2))
								// low dword = lM1 =
								//(pcWave[dwPosition1 + 1] * dwFract1 + pcWave[dwPosition1]*(0x1000-dwFract1))		

		movq	mm3, mm2		// put left and right volume levels in mm3
		add		eax, ebx		//pfSamplePos += pfPitch;

		packssdw	mm3, mm2		// words in mm7
								// vfVolume, vfVolume, vfVolume, vfVolume
									
		movd	mm5, dword ptr[esi-2]	// Load values from buffer
		inc		ecx				// dwI++;
						
		psrad	mm7, 12			// shift back down to 16 bits.

	packssdw	mm7, mm4		// only need one word in mono case.
								// low word are lm2 and lm1
										        
		// above multiplies and shifts are all done with this one pmul. Low two word are only
		// interest in mono case
		pmulhw		mm3, mm7	// lLM1 *= vfVolume;								
								// lLM2 *= vfVolume;
								
								
		paddsw	mm5, mm3				// Add values to buffer with saturation
		movd	dword ptr[esi-2], mm5	// Store values back into buffer.
								
    // }
	jmp		mainloop

	// Need to write only one.
	//if (dwI < dwLength)
	//{
StoreOne:		
#if 1
		// Linearly interpolate between points and store only one value.
		// combine dwFract Values.
	
		// Make mm7 zero for unpacking

		//shl		esi, 1				// do not shift left since pcWave is array of chars
		add		esi, pcWave			// Put address of pcWave[dwPosition1] in esi
		pxor	mm7, mm7
				
		//lLM1 = pcWave[dwPosition1];
		movzx	esi, word ptr[esi]
		
		// Doing AND that was not done for dwFract1 and dwFract2
		pand	mm6, mm4

								// words in MMX register after operation is complete.		
		psubw	mm5, mm6		// 0, 0, 0x1000 - 0, 0x1000 - dwFract1
	punpcklwd	mm5, mm6		// 0 , 0x1000 - 0, dwFract1, 0x1000 - dwFract1
				
		// put values of pcWave into MMX registers.  They are read into a regular register so
		// that the routine does not read past the end of the buffer otherwise, it could read
		// directly into the MMX registers.

								// words in MMX registers
		pxor	mm7, mm7
								// low four bytes
		movd	mm4, esi		// 0, 0, pcWave[dwPos1+1], pcWave[dwPos1] 

								// 8 bytes after unpakc
		punpcklbw	mm7, mm4	// 0, 0, 0, 0, pcWave[dwPos1+1], 0, pcWave[dwPos1], 0
	  	    	
		// *2 pmadd efficent code.
		//lM2 = (pcWave[dwPosition2 + 1] * dwFract2 + pcWave[dwPosition2]*(0x1000-dwFract2)) >> 12;
		//lM1 = (pcWave[dwPosition1 + 1] * dwFract1 + pcWave[dwPosition1]*(0x1000-dwFract1)) >> 12;

		pmaddwd		mm7, mm5// low dword = lM1 =
							//(pcWave[dwPosition1 + 1] * dwFract1 + pcWave[dwPosition1]*(0x1000-dwFract1))
		
		psrad		mm7, 12			// shift back down to 16 bits
				
		movq		mm5, mm2	// move volume into mm5
/*		
		// Set lLM to be same as lM
        lLM1 = lM1;

        lLM1 *= vfLVolume1;
        lLM1 >>= 5;         // Signal bumps up to 15 bits.
        lM1 *= vfRVolume1;
        lM1 >>= 5;

		// Set lLM to be same as lM
        lLM2 = lM2;

        lLM2 *= vfLVolume2;
        lLM2 >>= 5;         // Signal bumps up to 15 bits.
        lM2 *= vfRVolume2;
        lM2 >>= 5;
*/
		// above multiplies and shifts are all done with this one pmul
		pmulhw		mm5, mm7
		
		// calculate buffer location.
		mov		edi, ecx
		shl		edi, 1
		add		edi, pBuffer

		movd	edx, mm5

		//pBuffer[dwI+1] += (short) lM1;
		add		word ptr[edi-2], dx
        jno no_oflowr1
        //pBuffer[dwI+1] = 0x7fff;
		mov		word ptr[edi-2], 0x7fff
        js  no_oflowr1
        //pBuffer[dwI+1] = (short) 0x8000;
		mov		word ptr[edi-2], 0x8000
no_oflowr1:		
	//}
#endif 
done:

	mov		edx, this                       // get address of class object

    //vfLastVolume[0] = vfVolume;
    //vfLastVolume[1] = vfVolume;
	// need to shift volume back down to 12 bits before storing
	psrld	mm2, 3
#if 0 
	movd	[edx]this.m_vfLastVolume[0], mm2	
	movd	[edx]this.m_vfLastVolume[1], mm2
#endif
	movd	vfLastVolume[0], mm2	
	movd	vfLastVolume[1], mm2
	
    //m_pfLastPitch = pfPitch;
	mov		[edx]this.m_pfLastPitch, ebx
	    
	//m_pfLastSample = pfSamplePos;
	mov		[edx]this.m_pfLastSample, eax
		
	// put value back into dwI to be returned. This could just be passed back in eax I think. 	
	mov		dwI, ecx
	emms	
} // ASM block
    return (dwI);
}
#endif

DWORD CDigitalAudio::Mix8X(short * pBuffer, 
						   DWORD dwLength, 
						   DWORD dwDeltaPeriod,
						   VFRACT vfDeltaLVolume, 
						   VFRACT vfDeltaRVolume,
						   VFRACT vfLastVolume[],
						   PFRACT pfDeltaPitch, 
						   PFRACT pfSampleLength, 
						   PFRACT pfLoopLength)

{
    DWORD dwI;
    //DWORD dwPosition1, dwPosition2;
    //long lM1, lLM1;
	//long lM2, lLM2;
    DWORD dwIncDelta = dwDeltaPeriod;
    //VFRACT dwFract1, dwFract2;
    char * pcWave = (char *) m_pnWave;
    PFRACT pfSamplePos = m_pfLastSample;
    VFRACT vfLVolume = vfLastVolume[0];
    VFRACT vfRVolume = vfLastVolume[1];

	VFRACT vfLVolume2 = vfLastVolume[0];
    VFRACT vfRVolume2 = vfLastVolume[1];

    PFRACT pfPitch = m_pfLastPitch;
    PFRACT pfPFract = pfPitch << 8;
	dwLength <<= 1;

	QWORD	dwFractMASK =	0x000000000FFF0FFF;
	QWORD	dwFractOne  =	0x0000000010001000;	
	QWORD	wordmask	=	0x0000FFFF0000FFFF;
	QWORD	vfDeltaLandRVolume;

_asm{
				
	// vfLVFract and vfRVFract are in mm0
    //VFRACT vfLVFract = vfLVolume1 << 8;  // Keep high res version around.
    //VFRACT vfRVFract = vfRVolume1 << 8;	
	
	movd	mm0, vfLVolume
	movd	mm7, vfRVolume

	// vfDeltaLVolume and vfDeltaRVolume are put in mm1 so that they can be stored in vfDeltaLandRVolume
	movd	mm1, vfDeltaLVolume
	movd	mm6, vfDeltaRVolume

  punpckldq mm1, mm6
	
	// dwI = 0
	mov		ecx, 0
	movq	vfDeltaLandRVolume, mm1


	movq	mm1, dwFractOne
	movq	mm4, dwFractMASK
	
	mov		eax, pfSamplePos


  punpckldq mm0, mm7
  	mov		ebx, pfPitch

	pslld	mm0, 8
	mov		edx, dwIncDelta

	movq	mm2, mm0		// vfLVolume and vfRVolume in mm2
							// need to be set before first pass.
 	
	// *1 I shift by 5 so that volume is a 15 bit value instead of a 12 bit value
	psrld	mm2, 5	
	
    //for (dwI = 0; dwI < dwLength; )
    //{
mainloop:
	cmp		ecx, dwLength
	jae		done

		
		
		cmp		eax, pfSampleLength	//if (pfSamplePos >= pfSampleLength)
		jb		NotPastEndOfSample1	//{	
				        
		cmp		pfLoopLength, 0		//if (!pfLoopLength)
			
		je		done				// break;
			
		sub		eax, pfLoopLength	// else pfSamplePos -= pfLoopLength;
	
NotPastEndOfSample1:				//}
					
		mov		esi, eax			// dwPosition1 = pfSamplePos;
		add		eax, ebx			// pfSamplePos += pfPitch;		
				
		sub		edx, 2				// dwIncDelta-=2;				        		        
		jnz		DontIncreaseValues1	//if (!dwIncDelta) {

			// Since edx was use for dwIncDelta and now its zero, we can use if for a temporary
			// for a bit. All code that TestLVol and TestRVol is doing is zeroing out the volume
			// if it goes below zero.
						
			paddd	mm0, vfDeltaLandRVolume	// vfLVFract += vfDeltaLVolume;
											// vfRVFract += vfDeltaRVolume;
			pxor	mm5, mm5				// TestLVol = 0; TestRVol = 0;

			
			mov		edx, pfPFract			// Temp = pfPFract;
			pcmpgtd	mm5, mm0			// if (TestLVol > vfLVFract) TestLVol = 0xffffffff;
										// if (TestRVol > vfRVFract) TestRVol = 0xffffffff;

			add		edx, pfDeltaPitch	// Temp += pfDeltaPitch;
			pandn	mm5, mm0			// TestLVol = vfLVFract & (~TestLVol);
										// TestRVol = vfRVFract & (~TestRVol);

			mov		pfPFract, edx		// pfPFract = Temp;
			movq	mm2, mm5			// vfLVolume = TestLVol;
										// vfRVolume = TestRVol;
			

			shr		edx, 8				// Temp = Temp >> 8;
			psrld	mm2, 5				// vfLVolume = vfLVolume >> 5;
										// vfRVolume = vfRVolume >> 5;						
			
			mov		ebx, edx			// pfPitch = Temp;
			mov		edx, dwDeltaPeriod	//dwIncDelta = dwDeltaPeriod;			
			
        //}
DontIncreaseValues1:

		movd	mm6, esi			// dwFract1 = dwPosition1;
		movq	mm5, mm1			// words in mm5 = 0, 0, 0x1000, 0x1000		
		
		shr		esi, 12				// dwPosition1 = dwPosition1 >> 12;		
		add		ecx, 2				//dwI += 2;
						
		// if ( dwI < dwLength) break;						
		cmp		ecx, dwLength
		jae		StoreOne
		
		//if (pfSamplePos >= pfSampleLength)
	    //{	
		cmp		eax, pfSampleLength
		jb		NotPastEndOfSample2

			// Original if in C was not negated
	        //if (!pfLoopLength)		    
			cmp		pfLoopLength, 0
			//break;			
			je		StoreOne
			//else
			//pfSamplePos -= pfLoopLength;
			sub		eax, pfLoopLength
	    //}
NotPastEndOfSample2:

		//shl		esi, 1			// do not shift left since pcWave is array of chars
		mov		edi, eax		// dwPosition2 = pfSamplePos;

		add		esi, pcWave		// Put address of pcWave[dwPosition1] in esi			
		movd	mm7, eax		// dwFract2 = pfSamplePos;

		shr		edi, 12			// dwPosition2 = dwPosition2 >> 12;
	punpcklwd	mm6, mm7		// combine dwFract Values. Words in mm6 after unpack are
								// 0, 0, dwFract2, dwFract1
								
		pand	mm6, mm4		// dwFract2 &= 0xfff; dwFract1 &= 0xfff;
		
		movzx	esi, word ptr[esi]	//lLM1 = pcWave[dwPosition1];

		movd	mm3, esi

		psubw	mm5, mm6		// 0, 0, 0x1000 - dwFract2, 0x1000 - dwFract1

		//shl		edi, 1			// do not shift left since pcWave is array of chars
	punpcklwd	mm5, mm6		// dwFract2, 0x1000 - dwFract2, dwFract1, 0x1000 - dwFract1
								
		add		edi, pcWave		// Put address of pcWave[dwPosition2] in edi
		mov		esi, ecx		// Temp = dWI;
             																									
		shl		esi, 1			// Temp = Temp << 1;								
		
					
		movzx	edi, word ptr[edi]	//lLM2 = pcWave[dwPosition2];
		movd	mm6, edi
	
		pxor	mm7, mm7		// zero out mm7 to make 8 bit into 16 bit

								// low 4 bytes bytes in mm3
	punpcklwd	mm3, mm6		// pcWave[dwPos2+1], pcWave[dwPos2], pcWave[dwPos1+1], pcWave[dwPos1] 
		
		add		esi, pBuffer	//
	punpcklbw	mm7, mm3		// bytes in mm7
								// pcWave[dwPos2+1], 0, pcWave[dwPos2], 0, pcWave[dwPos1+1], pcWave[dwPos1], 0 
												
		pmaddwd	mm7, mm5		// high dword = lM2 =
								//(pcWave[dwPosition2 + 1] * dwFract2 + pcWave[dwPosition2]*(0x1000-dwFract2))
								// low dword = lM1 =
								//(pcWave[dwPosition1 + 1] * dwFract1 + pcWave[dwPosition1]*(0x1000-dwFract1))		

		movq	mm3, mm2		// put left and right volume levels in mm3

		add		eax, ebx		//pfSamplePos += pfPitch;
	packssdw	mm3, mm2		// words in mm3
								// vfRVolume2, vfLVolume2, vfRVolume1, vfLVolume1
		
		movq	mm5, qword ptr[esi-4]	// Load values from buffer
		add		ecx, 2			// dwI += 2;
						
		psrad	mm7, 12			// shift back down to 16 bits.

		pand	mm7, wordmask	// combine results to get ready to multiply by left and right
		movq	mm6, mm7		// volume levels.
		pslld	mm6, 16			//
		por		mm7, mm6		// words in mm7
								// lM2, lM2, lM1, lM1
										        
		// above multiplies and shifts are all done with this one pmul
		pmulhw		mm3, mm7	// lLM1 *= vfLVolume;
								// lM1 *= vfRVolume;
								// lLM2 *= vfLVolume;
								// lM2 *= vfRVolume;
								
		paddsw	mm5, mm3				// Add values to buffer with saturation
		movq	qword ptr[esi-4], mm5	// Store values back into buffer.
								
    // }
	jmp		mainloop

	// Need to write only one.
	//if (dwI < dwLength)
	//{
StoreOne:		
#if 1
		// Linearly interpolate between points and store only one value.
		// combine dwFract Values.
	
		// Make mm7 zero for unpacking

		//shl		esi, 1				// do not shift left since pcWave is array of chars
		add		esi, pcWave			// Put address of pcWave[dwPosition1] in esi
		pxor	mm7, mm7
				
		//lLM1 = pcWave[dwPosition1];
		movzx	esi, word ptr[esi]
		
		// Doing AND that was not done for dwFract1 and dwFract2
		pand	mm6, mm4

								// words in MMX register after operation is complete.		
		psubw	mm5, mm6		// 0, 0, 0x1000 - 0, 0x1000 - dwFract1
	punpcklwd	mm5, mm6		// 0 , 0x1000 - 0, dwFract1, 0x1000 - dwFract1
				
		// put values of pcWave into MMX registers.  They are read into a regular register so
		// that the routine does not read past the end of the buffer otherwise, it could read
		// directly into the MMX registers.

		pxor	mm7, mm7
								// byte in MMX registers
		movd	mm4, esi		// 0, 0, pcWave[dwPos1+1], pcWave[dwPos1] 

		punpcklbw	mm7, mm4	// 0, 0, 0, 0, pcWave[dwPos1+1], 0, pcWave[dwPos1], 0
	  	    	
		// *2 pmadd efficent code.
		//lM2 = (pcWave[dwPosition2 + 1] * dwFract2 + pcWave[dwPosition2]*(0x1000-dwFract2)) >> 12;
		//lM1 = (pcWave[dwPosition1 + 1] * dwFract1 + pcWave[dwPosition1]*(0x1000-dwFract1)) >> 12;

		pmaddwd		mm7, mm5// low dword = lM1 =
							//(pcWave[dwPosition1 + 1] * dwFract1 + pcWave[dwPosition1]*(0x1000-dwFract1))
		
		psrad		mm7, 12			// shift back down to 16 bits

		pand		mm7, wordmask	// combine results to get ready to multiply by left and right 
		movq		mm6, mm7		// volume levels.
		pslld		mm6, 16			//
		por			mm7, mm6		// words in mm7
									// lM2, lM2, lM1, lM1

		pxor		mm6, mm6

		movq		mm5, mm2	// move volume1 into mm5
								
								// use pack to get 4 volume values together for multiplication.
		packssdw	mm5, mm6    // words in mm7
								// 0, 0, vfRVolume1, vfLVolume1
/*		
		// Set lLM to be same as lM
        lLM1 = lM1;

        lLM1 *= vfLVolume1;
        lLM1 >>= 5;         // Signal bumps up to 15 bits.
        lM1 *= vfRVolume1;
        lM1 >>= 5;

		// Set lLM to be same as lM
        lLM2 = lM2;

        lLM2 *= vfLVolume2;
        lLM2 >>= 5;         // Signal bumps up to 15 bits.
        lM2 *= vfRVolume2;
        lM2 >>= 5;
*/
		// above multiplies and shifts are all done with this one pmul
		pmulhw		mm5, mm7
		
		// calculate buffer location.
		mov		edi, ecx
		shl		edi, 1
		add		edi, pBuffer		

/*
		add		word ptr[edi-4], si
        jno		no_oflowl1
		// pBuffer[dwI] = 0x7fff;
		mov		word ptr[edi-4], 0x7fff
        js  no_oflowl1
        //pBuffer[dwI] = (short) 0x8000;
		mov		word ptr[edi-4], 0x8000
no_oflowl1:
		//pBuffer[dwI+1] += (short) lM1;
		add		word ptr[edi-2], dx
        jno no_oflowr1
        //pBuffer[dwI+1] = 0x7fff;
		mov		word ptr[edi-2], 0x7fff
        js  no_oflowr1
        //pBuffer[dwI+1] = (short) 0x8000;
		mov		word ptr[edi-2], 0x8000
no_oflowr1:
*/
		movd	mm7, dword ptr[edi-4]		
		paddsw	mm7, mm5
		movd	dword ptr[edi-4], mm7
	//}
#endif 
done:

	mov		edx, this                       // get address of class object

    //vfLastVolume[0] = vfLVolume;
    //vfLastVolume[1] = vfRVolume;
	// need to shift volume back down to 12 bits before storing
#if 0
	psrld	mm2, 3
	movd	[edx]this.m_vfLastVolume[0], mm2
	psrlq	mm2, 32
	movd	[edx]this.m_vfLastVolume[1], mm2
#endif
	psrld	mm2, 3
	movd	vfLastVolume[0], mm2
	psrlq	mm2, 32
	movd	vfLastVolume[1], mm2
	
    //m_pfLastPitch = pfPitch;
	mov		[edx]this.m_pfLastPitch, ebx
	    
	//m_pfLastSample = pfSamplePos;
	mov		[edx]this.m_pfLastSample, eax
		
	// put value back into dwI to be returned. This could just be passed back in eax I think. 	
	mov		dwI, ecx
	emms	
} // ASM block
    return (dwI >> 1);
}

#ifdef ORG_MONO_MIXER
DWORD CDigitalAudio::MixMono16X(short * pBuffer, 
								DWORD dwLength,
								DWORD dwDeltaPeriod,
								VFRACT vfDeltaVolume,
							    VFRACT vfLastVolume[],
								PFRACT pfDeltaPitch, 
								PFRACT pfSampleLength, 
								PFRACT pfLoopLength)

{
    DWORD dwI;    
    
    
    DWORD dwIncDelta = dwDeltaPeriod;
    
    short * pcWave = (short*) m_pnWave;
    PFRACT pfSamplePos = m_pfLastSample;
    VFRACT vfVolume = vfLastVolume[0];
    PFRACT pfPitch = m_pfLastPitch;
    PFRACT pfPFract = pfPitch << 8;
    VFRACT vfVFract = vfVolume << 8;  // Keep high res version around.


	QWORD	dwFractMASK =	0x000000000FFF0FFF;
	QWORD	dwFractOne  =	0x0000000010001000;	
	QWORD	wordmask	=	0x0000FFFF0000FFFF;
	QWORD	vfDeltaLandRVolume;

_asm{
				
	// vfLVFract and vfRVFract are in mm0
    //VFRACT vfLVFract = vfLVolume1 << 8;  // Keep high res version around.
    //VFRACT vfRVFract = vfRVolume1 << 8;	
	
	movd	mm0, vfVolume
	movd	mm7, vfVolume

	// vfDeltaLVolume and vfDeltaRVolume are put in mm1 so that they can be stored in vfDeltaLandRVolume
	movd	mm1, vfDeltaVolume
	movd	mm6, vfDeltaVolume

  punpckldq mm1, mm6
	
	// dwI = 0
	mov		ecx, 0
	movq	vfDeltaLandRVolume, mm1


	movq	mm1, dwFractOne
	movq	mm4, dwFractMASK
	
	mov		eax, pfSamplePos


  punpckldq mm0, mm7
  	mov		ebx, pfPitch

	pslld	mm0, 8
	mov		edx, dwIncDelta

	movq	mm2, mm0		// vfLVolume and vfRVolume in mm2
							// need to be set before first pass.
 	
	// *1 I shift by 5 so that volume is a 15 bit value instead of a 12 bit value
	psrld	mm2, 5	
	
    //for (dwI = 0; dwI < dwLength; )
    //{
mainloop:
	cmp		ecx, dwLength
	jae		done

		
		
		cmp		eax, pfSampleLength	//if (pfSamplePos >= pfSampleLength)
		jb		NotPastEndOfSample1	//{	
				        
		cmp		pfLoopLength, 0		//if (!pfLoopLength)
			
		je		done				// break;
			
		sub		eax, pfLoopLength	// else pfSamplePos -= pfLoopLength;
	
NotPastEndOfSample1:				//}
					
		mov		esi, eax			// dwPosition1 = pfSamplePos;
		add		eax, ebx			// pfSamplePos += pfPitch;		
				
		sub		edx, 2				// dwIncDelta-=2;				        		        
		jnz		DontIncreaseValues1	//if (!dwIncDelta) {

			// Since edx was use for dwIncDelta and now its zero, we can use if for a temporary
			// for a bit. All code that TestLVol and TestRVol is doing is zeroing out the volume
			// if it goes below zero.
						
			paddd	mm0, vfDeltaLandRVolume	// vfVFract += vfDeltaVolume;
											// vfVFract += vfDeltaVolume;
			pxor	mm5, mm5				// TestLVol = 0; TestRVol = 0;

			
			mov		edx, pfPFract			// Temp = pfPFract;
			pcmpgtd	mm5, mm0			// if (TestLVol > vfLVFract) TestLVol = 0xffffffff;
										// if (TestRVol > vfRVFract) TestRVol = 0xffffffff;

			add		edx, pfDeltaPitch	// Temp += pfDeltaPitch;
			pandn	mm5, mm0			// TestLVol = vfLVFract & (~TestLVol);
										// TestRVol = vfRVFract & (~TestRVol);

			mov		pfPFract, edx		// pfPFract = Temp;
			movq	mm2, mm5			// vfLVolume = TestLVol;
										// vfRVolume = TestRVol;
			

			shr		edx, 8				// Temp = Temp >> 8;
			psrld	mm2, 5				// vfLVolume = vfLVolume >> 5;
										// vfRVolume = vfRVolume >> 5;						
			
			mov		ebx, edx			// pfPitch = Temp;
			mov		edx, dwDeltaPeriod	//dwIncDelta = dwDeltaPeriod;			
			
        //}
DontIncreaseValues1:

		movd	mm6, esi			// dwFract1 = dwPosition1;
		movq	mm5, mm1			// words in mm5 = 0, 0, 0x1000, 0x1000		
		
		shr		esi, 12				// dwPosition1 = dwPosition1 >> 12;		
		inc		ecx					//dwI++;
						
		// if ( dwI < dwLength) break;						
		cmp		ecx, dwLength
		jae		StoreOne
		
		//if (pfSamplePos >= pfSampleLength)
	    //{	
		cmp		eax, pfSampleLength
		jb		NotPastEndOfSample2

			// Original if in C was not negated
	        //if (!pfLoopLength)		    
			cmp		pfLoopLength, 0
			//break;			
			je		StoreOne
			//else
			//pfSamplePos -= pfLoopLength;
			sub		eax, pfLoopLength
	    //}
NotPastEndOfSample2:

		shl		esi, 1			// shift left since pcWave is array of shorts
		mov		edi, eax		// dwPosition2 = pfSamplePos;

		add		esi, pcWave		// Put address of pcWave[dwPosition1] in esi			
		movd	mm7, eax		// dwFract2 = pfSamplePos;

		shr		edi, 12			// dwPosition2 = dwPosition2 >> 12;
	punpcklwd	mm6, mm7		// combine dwFract Values. Words in mm6 after unpack are
								// 0, 0, dwFract2, dwFract1
								
		pand	mm6, mm4		// dwFract2 &= 0xfff; dwFract1 &= 0xfff;
		
		movd	mm7, dword ptr[esi]	//lLM1 = pcWave[dwPosition1];
		psubw	mm5, mm6		// 0, 0, 0x1000 - dwFract2, 0x1000 - dwFract1

		shl		edi, 1			// shift left since pcWave is array of shorts
	punpcklwd	mm5, mm6		// dwFract2, 0x1000 - dwFract2, dwFract1, 0x1000 - dwFract1
								
		add		edi, pcWave		// Put address of pcWave[dwPosition2] in edi
		mov		esi, ecx		// Temp = dWI;
             																									
		shl		esi, 1			// Temp = Temp << 1;								
		movq	mm3, mm2		// put left and right volume levels in mm3
		
					
		movd	mm6, dword ptr[edi]	//lLM2 = pcWave[dwPosition2];
	packssdw	mm3, mm2		// words in mm7
								// vfRVolume2, vfLVolume2, vfRVolume1, vfLVolume1
		
		add		esi, pBuffer	//
	punpckldq	mm7, mm6		// low four bytes bytes in 
								// pcWave[dwPos2+1], pcWave[dwPos2], pcWave[dwPos1+1], pcWave[dwPos1] 
												
		pmaddwd	mm7, mm5		// high dword = lM2 =
								//(pcWave[dwPosition2 + 1] * dwFract2 + pcWave[dwPosition2]*(0x1000-dwFract2))
								// low dword = lM1 =
								//(pcWave[dwPosition1 + 1] * dwFract1 + pcWave[dwPosition1]*(0x1000-dwFract1))		
		add		eax, ebx		//pfSamplePos += pfPitch;
		
		movd	mm5, dword ptr[esi-2]	// Load values from buffer
		inc		ecx				// dwI++;
						
		psrad	mm7, 12			// shift back down to 16 bits.

	packssdw	mm7, mm4		// only need one word in mono case.
								// low word are lm2 and lm1
										        
		// above multiplies and shifts are all done with this one pmul. Low two word are only
		// interest in mono case
		pmulhw		mm3, mm7	// lLM1 *= vfVolume;								
								// lLM2 *= vfVolume;
								
								
		paddsw	mm5, mm3				// Add values to buffer with saturation
		movd	dword ptr[esi-2], mm5	// Store values back into buffer.
								
    // }
	jmp		mainloop

	// Need to write only one.
	//if (dwI < dwLength)
	//{
StoreOne:		
#if 1
		// Linearly interpolate between points and store only one value.
		// combine dwFract Values.
	
		// Make mm7 zero for unpacking

		shl		esi, 1				// shift left since pcWave is array of shorts
		add		esi, pcWave			// Put address of pcWave[dwPosition1] in esi
		pxor	mm7, mm7
				
		//lLM1 = pcWave[dwPosition1];
		mov		esi, dword ptr[esi]
		
		// Doing AND that was not done for dwFract1 and dwFract2
		pand	mm6, mm4

								// words in MMX register after operation is complete.		
		psubw	mm5, mm6		// 0, 0, 0x1000 - 0, 0x1000 - dwFract1
	punpcklwd	mm5, mm6		// 0 , 0x1000 - 0, dwFract1, 0x1000 - dwFract1
				
		// put values of pcWave into MMX registers.  They are read into a regular register so
		// that the routine does not read past the end of the buffer otherwise, it could read
		// directly into the MMX registers.

								// words in MMX registers
		movd	mm7, esi		// 0, 0, pcWave[dwPos1+1], pcWave[dwPos1] 
	  	    	
		// *2 pmadd efficent code.
		//lM2 = (pcWave[dwPosition2 + 1] * dwFract2 + pcWave[dwPosition2]*(0x1000-dwFract2)) >> 12;
		//lM1 = (pcWave[dwPosition1 + 1] * dwFract1 + pcWave[dwPosition1]*(0x1000-dwFract1)) >> 12;

		pmaddwd		mm7, mm5// low dword = lM1 =
							//(pcWave[dwPosition1 + 1] * dwFract1 + pcWave[dwPosition1]*(0x1000-dwFract1))
		
		psrad		mm7, 12			// shift back down to 16 bits
				
		movq		mm5, mm2	// move volume into mm5
/*		
		// Set lLM to be same as lM
        lLM1 = lM1;

        lLM1 *= vfLVolume1;
        lLM1 >>= 5;         // Signal bumps up to 15 bits.
        lM1 *= vfRVolume1;
        lM1 >>= 5;

		// Set lLM to be same as lM
        lLM2 = lM2;

        lLM2 *= vfLVolume2;
        lLM2 >>= 5;         // Signal bumps up to 15 bits.
        lM2 *= vfRVolume2;
        lM2 >>= 5;
*/
		// above multiplies and shifts are all done with this one pmul
		pmulhw		mm5, mm7
		
		// calculate buffer location.
		mov		edi, ecx
		shl		edi, 1
		add		edi, pBuffer

		movd	edx, mm5

		//pBuffer[dwI+1] += (short) lM1;
		add		word ptr[edi-2], dx
        jno no_oflowr1
        //pBuffer[dwI+1] = 0x7fff;
		mov		word ptr[edi-2], 0x7fff
        js  no_oflowr1
        //pBuffer[dwI+1] = (short) 0x8000;
		mov		word ptr[edi-2], 0x8000
no_oflowr1:		
	//}
#endif 
done:

	mov		edx, this                       // get address of class object

    //vfLastVolume[0] = vfVolume;
    //vfLastVolume[1] = vfVolume;
	// need to shift volume back down to 12 bits before storing
	psrld	mm2, 3
#if 0
	movd	[edx]this.m_vfLastVolume[0], mm2	
	movd	[edx]this.m_vfLastVolume[1], mm2
#endif
	movd	vfLastVolume[0], mm2	
	movd	vfLastVolume[1], mm2
	
    //m_pfLastPitch = pfPitch;
	mov		[edx]this.m_pfLastPitch, ebx
	    
	//m_pfLastSample = pfSamplePos;
	mov		[edx]this.m_pfLastSample, eax
		
	// put value back into dwI to be returned. This could just be passed back in eax I think. 	
	mov		dwI, ecx
	emms	
} // ASM block
    return (dwI);
}
#endif

DWORD CDigitalAudio::Mix16X(short * pBuffer, 
							DWORD dwLength, 
							DWORD dwDeltaPeriod,
							VFRACT vfDeltaLVolume, 
							VFRACT vfDeltaRVolume,
						    VFRACT vfLastVolume[],
							PFRACT pfDeltaPitch, 
							PFRACT pfSampleLength, 
							PFRACT pfLoopLength)
{
    DWORD dwI;
    //DWORD dwPosition1, dwPosition2;
    //long lM1, lLM1;
	//long lM2, lLM2;
    DWORD dwIncDelta = dwDeltaPeriod;
    //VFRACT dwFract1, dwFract2;
    short * pcWave = (short *) m_pnWave;
    PFRACT pfSamplePos = m_pfLastSample;
    VFRACT vfLVolume = vfLastVolume[0];
    VFRACT vfRVolume = vfLastVolume[1];

	VFRACT vfLVolume2 = vfLastVolume[0];
    VFRACT vfRVolume2 = vfLastVolume[1];

    PFRACT pfPitch = m_pfLastPitch;
    PFRACT pfPFract = pfPitch << 8;
	dwLength <<= 1;

	QWORD	dwFractMASK =	0x000000000FFF0FFF;
	QWORD	dwFractOne  =	0x0000000010001000;	
	QWORD	wordmask	=	0x0000FFFF0000FFFF;
	QWORD	vfDeltaLandRVolume;

_asm{
				
	// vfLVFract and vfRVFract are in mm0
    //VFRACT vfLVFract = vfLVolume1 << 8;  // Keep high res version around.
    //VFRACT vfRVFract = vfRVolume1 << 8;	
	
	movd	mm0, vfLVolume
	movd	mm7, vfRVolume

	// vfDeltaLVolume and vfDeltaRVolume are put in mm1 so that they can be stored in vfDeltaLandRVolume
	movd	mm1, vfDeltaLVolume
	movd	mm6, vfDeltaRVolume

  punpckldq mm1, mm6
	
	// dwI = 0
	mov		ecx, 0
	movq	vfDeltaLandRVolume, mm1


	movq	mm1, dwFractOne
	movq	mm4, dwFractMASK
	
	mov		eax, pfSamplePos


  punpckldq mm0, mm7
  	mov		ebx, pfPitch

	pslld	mm0, 8
	mov		edx, dwIncDelta

	movq	mm2, mm0		// vfLVolume and vfRVolume in mm2
							// need to be set before first pass.
 	
	// *1 I shift by 5 so that volume is a 15 bit value instead of a 12 bit value
	psrld	mm2, 5	
	
    //for (dwI = 0; dwI < dwLength; )
    //{
mainloop:
	cmp		ecx, dwLength
	jae		done

		
		
		cmp		eax, pfSampleLength	//if (pfSamplePos >= pfSampleLength)
		jb		NotPastEndOfSample1	//{	
				        
		cmp		pfLoopLength, 0		//if (!pfLoopLength)
			
		je		done				// break;
			
		sub		eax, pfLoopLength	// else pfSamplePos -= pfLoopLength;
	
NotPastEndOfSample1:				//}
					
		mov		esi, eax			// dwPosition1 = pfSamplePos;
		add		eax, ebx			// pfSamplePos += pfPitch;		
				
		sub		edx, 2				// dwIncDelta-=2;				        		        
		jnz		DontIncreaseValues1	//if (!dwIncDelta) {

			// Since edx was use for dwIncDelta and now its zero, we can use if for a temporary
			// for a bit. All code that TestLVol and TestRVol is doing is zeroing out the volume
			// if it goes below zero.
						
			paddd	mm0, vfDeltaLandRVolume	// vfLVFract += vfDeltaLVolume;
											// vfRVFract += vfDeltaRVolume;
			pxor	mm5, mm5				// TestLVol = 0; TestRVol = 0;

			
			mov		edx, pfPFract			// Temp = pfPFract;
			pcmpgtd	mm5, mm0			// if (TestLVol > vfLVFract) TestLVol = 0xffffffff;
										// if (TestRVol > vfRVFract) TestRVol = 0xffffffff;

			add		edx, pfDeltaPitch	// Temp += pfDeltaPitch;
			pandn	mm5, mm0			// TestLVol = vfLVFract & (~TestLVol);
										// TestRVol = vfRVFract & (~TestRVol);

			mov		pfPFract, edx		// pfPFract = Temp;
			movq	mm2, mm5			// vfLVolume = TestLVol;
										// vfRVolume = TestRVol;
			

			shr		edx, 8				// Temp = Temp >> 8;
			psrld	mm2, 5				// vfLVolume = vfLVolume >> 5;
										// vfRVolume = vfRVolume >> 5;						
			
			mov		ebx, edx			// pfPitch = Temp;
			mov		edx, dwDeltaPeriod	//dwIncDelta = dwDeltaPeriod;			
			
        //}
DontIncreaseValues1:

		movd	mm6, esi			// dwFract1 = dwPosition1;
		movq	mm5, mm1			// words in mm5 = 0, 0, 0x1000, 0x1000		
		
		shr		esi, 12				// dwPosition1 = dwPosition1 >> 12;		
		add		ecx, 2				//dwI += 2;
						
		// if ( dwI < dwLength) break;						
		cmp		ecx, dwLength
		jae		StoreOne
		
		//if (pfSamplePos >= pfSampleLength)
	    //{	
		cmp		eax, pfSampleLength
		jb		NotPastEndOfSample2

			// Original if in C was not negated
	        //if (!pfLoopLength)		    
			cmp		pfLoopLength, 0
			//break;			
			je		StoreOne
			//else
			//pfSamplePos -= pfLoopLength;
			sub		eax, pfLoopLength
	    //}
NotPastEndOfSample2:

		shl		esi, 1			// shift left since pcWave is array of shorts
		mov		edi, eax		// dwPosition2 = pfSamplePos;

		add		esi, pcWave		// Put address of pcWave[dwPosition1] in esi			
		movd	mm7, eax		// dwFract2 = pfSamplePos;

		shr		edi, 12			// dwPosition2 = dwPosition2 >> 12;
	punpcklwd	mm6, mm7		// combine dwFract Values. Words in mm6 after unpack are
								// 0, 0, dwFract2, dwFract1
								
		pand	mm6, mm4		// dwFract2 &= 0xfff; dwFract1 &= 0xfff;
		
		movd	mm7, dword ptr[esi]	//lLM1 = pcWave[dwPosition1];
		psubw	mm5, mm6		// 0, 0, 0x1000 - dwFract2, 0x1000 - dwFract1

		shl		edi, 1			// shift left since pcWave is array of shorts
	punpcklwd	mm5, mm6		// dwFract2, 0x1000 - dwFract2, dwFract1, 0x1000 - dwFract1
								
		add		edi, pcWave		// Put address of pcWave[dwPosition2] in edi
		mov		esi, ecx		// Temp = dWI;
             																									
		shl		esi, 1			// Temp = Temp << 1;								
		movq	mm3, mm2		// put left and right volume levels in mm3
		
					
		movd	mm6, dword ptr[edi]	//lLM2 = pcWave[dwPosition2];
	packssdw	mm3, mm2		// words in mm7
								// vfRVolume2, vfLVolume2, vfRVolume1, vfLVolume1
		
		add		esi, pBuffer	//
	punpckldq	mm7, mm6		// low four bytes bytes in 
								// pcWave[dwPos2+1], pcWave[dwPos2], pcWave[dwPos1+1], pcWave[dwPos1] 
												
		pmaddwd	mm7, mm5		// high dword = lM2 =
								//(pcWave[dwPosition2 + 1] * dwFract2 + pcWave[dwPosition2]*(0x1000-dwFract2))
								// low dword = lM1 =
								//(pcWave[dwPosition1 + 1] * dwFract1 + pcWave[dwPosition1]*(0x1000-dwFract1))		
		add		eax, ebx		//pfSamplePos += pfPitch;
		
		movq	mm5, qword ptr[esi-4]	// Load values from buffer
		add		ecx, 2			// dwI += 2;
						
		psrad	mm7, 12			// shift back down to 16 bits.

		pand	mm7, wordmask	// combine results to get ready to multiply by left and right
		movq	mm6, mm7		// volume levels.
		pslld	mm6, 16			//
		por		mm7, mm6		// words in mm7
								// lM2, lM2, lM1, lM1
										        
		// above multiplies and shifts are all done with this one pmul
		pmulhw		mm3, mm7	// lLM1 *= vfLVolume;
								// lM1 *= vfRVolume;
								// lLM2 *= vfLVolume;
								// lM2 *= vfRVolume;
								
		paddsw	mm5, mm3				// Add values to buffer with saturation
		movq	qword ptr[esi-4], mm5	// Store values back into buffer.
								
    // }
	jmp		mainloop

	// Need to write only one.
	//if (dwI < dwLength)
	//{
StoreOne:		
#if 1
		// Linearly interpolate between points and store only one value.
		// combine dwFract Values.
	
		// Make mm7 zero for unpacking

		shl		esi, 1				// shift left since pcWave is array of shorts
		add		esi, pcWave			// Put address of pcWave[dwPosition1] in esi
		pxor	mm7, mm7
				
		//lLM1 = pcWave[dwPosition1];
		mov		esi, dword ptr[esi]
		
		// Doing AND that was not done for dwFract1 and dwFract2
		pand	mm6, mm4

								// words in MMX register after operation is complete.		
		psubw	mm5, mm6		// 0, 0, 0x1000 - 0, 0x1000 - dwFract1
	punpcklwd	mm5, mm6		// 0 , 0x1000 - 0, dwFract1, 0x1000 - dwFract1
				
		// put values of pcWave into MMX registers.  They are read into a regular register so
		// that the routine does not read past the end of the buffer otherwise, it could read
		// directly into the MMX registers.

								// words in MMX registers
		movd	mm7, esi		// 0, 0, pcWave[dwPos1+1], pcWave[dwPos1] 
	  	    	
		// *2 pmadd efficent code.
		//lM2 = (pcWave[dwPosition2 + 1] * dwFract2 + pcWave[dwPosition2]*(0x1000-dwFract2)) >> 12;
		//lM1 = (pcWave[dwPosition1 + 1] * dwFract1 + pcWave[dwPosition1]*(0x1000-dwFract1)) >> 12;

		pmaddwd		mm7, mm5// low dword = lM1 =
							//(pcWave[dwPosition1 + 1] * dwFract1 + pcWave[dwPosition1]*(0x1000-dwFract1))
		
		psrad		mm7, 12			// shift back down to 16 bits

		pand		mm7, wordmask	// combine results to get ready to multiply by left and right 
		movq		mm6, mm7		// volume levels.
		pslld		mm6, 16			//
		por			mm7, mm6		// words in mm7
									// lM2, lM2, lM1, lM1

		pxor		mm6, mm6

		movq		mm5, mm2	// move volume1 into mm5
								
								// use pack to get 4 volume values together for multiplication.
		packssdw	mm5, mm6    // words in mm7
								// 0, 0, vfRVolume1, vfLVolume1
/*		
		// Set lLM to be same as lM
        lLM1 = lM1;

        lLM1 *= vfLVolume1;
        lLM1 >>= 5;         // Signal bumps up to 15 bits.
        lM1 *= vfRVolume1;
        lM1 >>= 5;

		// Set lLM to be same as lM
        lLM2 = lM2;

        lLM2 *= vfLVolume2;
        lLM2 >>= 5;         // Signal bumps up to 15 bits.
        lM2 *= vfRVolume2;
        lM2 >>= 5;
*/
		// above multiplies and shifts are all done with this one pmul
		pmulhw		mm5, mm7
		
		// calculate buffer location.
		mov		edi, ecx
		shl		edi, 1
		add		edi, pBuffer		

/*
		add		word ptr[edi-4], si
        jno		no_oflowl1
		// pBuffer[dwI] = 0x7fff;
		mov		word ptr[edi-4], 0x7fff
        js  no_oflowl1
        //pBuffer[dwI] = (short) 0x8000;
		mov		word ptr[edi-4], 0x8000
no_oflowl1:
		//pBuffer[dwI+1] += (short) lM1;
		add		word ptr[edi-2], dx
        jno no_oflowr1
        //pBuffer[dwI+1] = 0x7fff;
		mov		word ptr[edi-2], 0x7fff
        js  no_oflowr1
        //pBuffer[dwI+1] = (short) 0x8000;
		mov		word ptr[edi-2], 0x8000
no_oflowr1:
*/
		movd	mm7, dword ptr[edi-4]		
		paddsw	mm7, mm5
		movd	dword ptr[edi-4], mm7
	//}
#endif 
done:

	mov		edx, this                       // get address of class object

    //vfLastVolume[0] = vfLVolume;
    //vfLastVolume[1] = vfRVolume;
	// need to shift volume back down to 12 bits before storing
#if 0
	psrld	mm2, 3
	movd	[edx]this.vfLastVolume[0], mm2
	psrlq	mm2, 32
	movd	[edx]this.vfLastVolume[1], mm2
#endif 
	psrld	mm2, 3
	movd	vfLastVolume[0], mm2
	psrlq	mm2, 32
	movd	vfLastVolume[1], mm2
	
    //m_pfLastPitch = pfPitch;
	mov		[edx]this.m_pfLastPitch, ebx
	    
	//m_pfLastSample = pfSamplePos;
	mov		[edx]this.m_pfLastSample, eax
		
	// put value back into dwI to be returned. This could just be passed back in eax I think. 	
	mov		dwI, ecx
	emms	
} // ASM block
    return (dwI >> 1);
}

static BOOL MMXDisabled()
{
    ULONG ulValue = FALSE;

    if (!GetRegValueDword(
            TEXT("Software\\Microsoft\\DirectMusic"),
            TEXT("MMXDisabled"),
            &ulValue))
    {
        return FALSE;
    }

    return (BOOL)ulValue;
}

#define CPU_ID _asm _emit 0x0f _asm _emit 0xa2  

BOOL MultiMediaInstructionsSupported()
{
    static  BOOL bMultiMediaInstructionsSupported = FALSE;
    static  BOOL bFlagNotSetYet = TRUE;
    
    // No need to keep interogating the CPU after it has been checked the first time
    if (bFlagNotSetYet)
    {
        bFlagNotSetYet = FALSE;         // Don't repeat the check for each call
		if (!MMXDisabled())
		{
			_asm 
			{
				pushfd                      // Store original EFLAGS on stack
				pop     eax                 // Get original EFLAGS in EAX
				mov     ecx, eax            // Duplicate original EFLAGS in ECX for toggle check
				xor     eax, 0x00200000L    // Flip ID bit in EFLAGS
				push    eax                 // Save new EFLAGS value on stack
				popfd                       // Replace current EFLAGS value
				pushfd                      // Store new EFLAGS on stack
				pop     eax                 // Get new EFLAGS in EAX
				xor     eax, ecx            // Can we toggle ID bit?
				jz      Done                // Jump if no, Processor is older than a Pentium so CPU_ID is not supported
				mov     eax, 1              // Set EAX to tell the CPUID instruction what to return
				push	ebx
				CPU_ID                      // Get family/model/stepping/features
				pop		ebx
				test    edx, 0x00800000L    // Check if mmx technology available
				jz      Done                // Jump if no
			}
			// Tests have passed, this machine supports the Intel MultiMedia Instruction Set!
			bMultiMediaInstructionsSupported = TRUE;
Done:
			NULL;
		}
    }

#if DBG
	if ( bMultiMediaInstructionsSupported )
	{
		Trace(1,"MMX - Detected, Enabling MMX mixing\n\r");
	}
	else
	{
		Trace(1,"MMX - Not Detected\n\r");
	}
#endif

    return (bMultiMediaInstructionsSupported);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\XboxSynth\stdafx.h ===
//      Copyright (c) 1996-1999 Microsoft Corporation

// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

#if !defined(AFX_STDAFX_H__58C2B4C5_46E7_11D1_89AC_00A0C9054129__INCLUDED_)
#define AFX_STDAFX_H__58C2B4C5_46E7_11D1_89AC_00A0C9054129__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#define STRICT


#define _WIN32_WINNT 0x0400
#define _ATL_APARTMENT_THREADED


#include <atlbase.h>
//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
extern CComModule _Module;
#include <atlcom.h>

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__58C2B4C5_46E7_11D1_89AC_00A0C9054129__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\XboxSynth\mixmulti.cpp ===
//      Mix.cpp
//      Copyright (c) Microsoft Corporation	1996, 1998
//      Mix engines for MSSynth

#define GIVE_ME_i386_ASM

#ifdef DMSYNTH_MINIPORT
#include "common.h"
#define STR_MODULENAME "DMusicMix:"
#else
#include "simple.h"
#include <mmsystem.h>
#include "synth.h"
#endif

///////////////////////////////////////////////////////
// Modifications 
// member m_nChannels => parameter dwBufferCount
//
// Changed number of arguments into Filtered mixers
//
// Remove range checking after filter 

#pragma warning(disable : 4101 4102 4146)  

#ifdef _ALPHA_

extern "C" {
	int __ADAWI(short, short *);
};
#pragma intrinsic(__ADAWI)

#define ALPHA_OVERFLOW 2 
#define ALPHA_NEGATIVE 8

#else // !_ALPHA_
//  TODO -- overflow detection for ia64 (+ axp64?)
#endif // !_ALPHA_
#ifdef DMSYNTH_MINIPORT
#pragma code_seg("PAGE")
#endif // DMSYNTH_MINIPORT

#define USE_MMX
#define USE_MMX_FILTERED

#ifdef GIVE_ME_i386_ASM // {
DWORD CDigitalAudio::MixMulti8(
    short *ppBuffer[], 
	DWORD dwBufferCount,
    DWORD dwLength, 
    DWORD dwDeltaPeriod, 
    VFRACT vfDeltaVolume[], 
    VFRACT vfLastVolume[], 
    PFRACT pfDeltaPitch, 
    PFRACT pfSampleLength, 
    PFRACT pfLoopLength)
{
    DWORD dwI, dwJ;
    DWORD dwPosition;
    long lMInterp;
    long lM;
    long lA;//, lB;
    DWORD dwIncDelta = dwDeltaPeriod;
    VFRACT dwFract;
    char * pcWave = (char *) m_pnWave;
    PFRACT pfSamplePos = m_pfLastSample;
    PFRACT pfPitch = m_pfLastPitch;
    PFRACT pfPFract = pfPitch << 8;

    VFRACT vfVolume[MAX_DAUD_CHAN]; // = m_vfLastLVolume;
    VFRACT vfVFract[MAX_DAUD_CHAN]; // = vfVolume << 8;  // Keep high res version around. 

    for (dwI = 0; dwI < dwBufferCount; dwI++)
    {
        vfVolume[dwI] = vfLastVolume[dwI];
        vfVFract[dwI] = vfVolume[dwI] << 8;
    }   
	
#if 1 // {
	DWORD l_nChannels = dwBufferCount;
#if 1 // {
	DWORD a;
	DWORD One_Channel_1, One_Channel_2;	// Code address locations.
#ifdef USE_MMX // {
	typedef __int64 QWORD;
	QWORD	OneMask	 = 0x0000000010001000;
	QWORD	fffMask  = 0x00000fff00000fff;
	QWORD	ffffMask = 0x0000ffff0000ffff;
	DWORD	UseMmx;
    DWORD   MmxVolume[2];
	int		Use_MMX = m_sfMMXEnabled;

	_asm {
    lea edi, $L43865

    // Turned off    
	cmp	Use_MMX, 0
	je	AssignMmxLabel

    // != 2 channels
	mov	esi, DWORD PTR l_nChannels
	cmp	esi, 2
	jne	AssignMmxLabel

    // Ok, init and use MMX

	lea	edi, UseMmxLabel

	pxor		mm0, mm0
	movq		mm3, QWORD PTR OneMask		// 0, 0, 0x1000, 0x1000

AssignMmxLabel:
	mov	DWORD PTR UseMmx, edi

	}
#endif // }

	_asm {
	mov	edi, DWORD PTR l_nChannels

	cmp	edi, 8
	jna	Start1

	lea	esi, $L44008
	jmp Do_One_Channel_2

	// Put this code more than 127 bytes away from the references.

overflow_x:
	js	overflow_y
	mov	WORD PTR [esi+ebx*2], 0x8000
	jmp	edi

overflow_y:
	mov	WORD PTR [esi+ebx*2], 0x7fff
	jmp	edi

Start1:	
	test	edi, edi
	jne	Start2

	lea	esi, $L43860
	jmp	Do_One_Channel_2

Start2:
	lea	eax, $L43851
	lea	edx, $L43853

	sub	edx, eax
	mov	esi, 8

	sub	esi, edi
	imul	esi, edx
	add	esi, eax

Do_One_Channel_2:
	mov	DWORD PTR One_Channel_1, esi

	//	Create second jump table location.
	
	lea	esi, $L43876
	lea	ecx, $L43880

	sub	ecx, esi

	push ecx				// Span between branches.

	mov	eax, 8
	sub	eax, DWORD PTR l_nChannels

	jge		Start3
	
	lea	ecx, $L44009
	jmp	Done_Do_Channel_2

Start3:
	cmp	eax, 8
	jne	Start4

	lea	ecx, $L43866
	jmp	Done_Do_Channel_2

Start4:
	imul	ecx, eax
	add		ecx, esi

Done_Do_Channel_2:
	mov	DWORD PTR One_Channel_2, ecx


	mov	ecx, DWORD PTR dwLength
	xor	ebx, ebx					// dwI

	test	ecx, ecx
	jbe	Exit_$L43841

	mov	ecx, DWORD PTR ppBuffer
	sub	ecx, 4

	//	ecx == ppBuffer
	//	ebx == dwI
	//	edi == l_nChannels
$L44021:

	mov	edx, DWORD PTR pfSamplePos
	cmp	edx, DWORD PTR pfSampleLength
	jl	SHORT $L43842

	mov	eax, DWORD PTR pfLoopLength
	test	eax, eax
	je	Exit_$L43841

	sub	edx, eax
	mov	DWORD PTR pfSamplePos, edx

$L43842:
	mov	edx, DWORD PTR dwIncDelta
	mov	eax, DWORD PTR pfPFract

	dec	edx

	mov	DWORD PTR dwIncDelta, edx
	jne	$L43860

	mov	edx, DWORD PTR dwDeltaPeriod
	mov	esi, DWORD PTR pfDeltaPitch

	mov	DWORD PTR dwIncDelta, edx
	add	eax, esi

	mov	DWORD PTR pfPFract, eax

	sar	eax, 8
	mov	DWORD PTR pfPitch, eax

	mov	esi, DWORD PTR vfDeltaVolume
	jmp	One_Channel_1

// ONE_CHANNEL
//			vfVFract[dwJ - 1] += vfDeltaVolume[dwJ - 1];
//			vfVolume[dwJ - 1]  = vfVFract     [dwJ - 1] >> 8;

$L44008:

	mov	DWORD PTR dwI, ebx
	lea	ebx, DWORD PTR [edi*4-4]
	add	edi, -8					; fffffff8H
$L43849:

	lea	eax, DWORD PTR vfVFract[ebx]
	mov	ecx, DWORD PTR [esi+ebx]
	sub	ebx, 4
	add	DWORD PTR [eax], ecx
	mov	eax, DWORD PTR [eax]
	sar	eax, 8
	mov	DWORD PTR vfVolume[ebx+4], eax
	dec	edi
	jne	SHORT $L43849

	mov	edi, DWORD PTR l_nChannels
	mov	ecx, DWORD PTR ppBuffer

	mov	ebx, DWORD PTR dwI
	sub	ecx, 4
}
#define ONE_CHANNEL_VOLUME(dwJ) \
	_asm { mov	eax, DWORD PTR vfVFract[(dwJ-1)*4] }; \
	_asm { add	eax, DWORD PTR [esi+(dwJ-1)*4] }; \
	_asm { mov	DWORD PTR vfVFract[(dwJ-1)*4], eax }; \
	_asm { sar	eax, 8 }; \
    _asm { lea  edx, vfVolume }; \
	_asm { mov	DWORD PTR [edx + (dwJ-1)*4], eax };

    //-------------------------------------------------------------------------
    //
    //          ***** ***** ***** DO NOT CHANGE THIS! ***** ***** *****
    //
    // This lovely hack makes sure that all the instructions
    // are the same length for the case (dwJ - 1) == 0. Code depends on this
    // by calculating instruction offsets based on having 8 identical blocks.
    //
    //          ***** ***** ***** DO NOT CHANGE THIS! ***** ***** *****
    //
    //-------------------------------------------------------------------------
#define ONE_CHANNEL_VOLUME_1 \
	_asm { mov	eax, DWORD PTR vfVFract[0] }; \
    _asm _emit 0x03 _asm _emit 0x46 _asm _emit 0x00 \
	_asm { mov	DWORD PTR vfVFract[0], eax }; \
	_asm { sar	eax, 8 }; \
    _asm { lea  edx, vfVolume }; \
    _asm _emit 0x89 _asm _emit 0x42 _asm _emit 0x00

$L43851:
	ONE_CHANNEL_VOLUME(8)
$L43853:
	ONE_CHANNEL_VOLUME(7);
	ONE_CHANNEL_VOLUME(6);
	ONE_CHANNEL_VOLUME(5);
	ONE_CHANNEL_VOLUME(4);
	ONE_CHANNEL_VOLUME(3);
	ONE_CHANNEL_VOLUME(2);
	ONE_CHANNEL_VOLUME_1;
#undef ONE_CHANNEL_VOLUME
#undef ONE_CHANNEL_VOLUME_1
$L43860:
_asm {
; 304  : 		DWORD a = (pfSampleLength - pfSamplePos + pfPitch - 1) / pfPitch;

	mov	esi, DWORD PTR pfPitch
	mov	eax, DWORD PTR pfSampleLength

	dec	esi
	sub	eax, DWORD PTR pfSamplePos

	add	eax, esi
	cdq
	idiv	DWORD PTR pfPitch

	mov	edx, DWORD PTR dwLength
	sub	edx, ebx

	cmp	edx, eax
	jae	SHORT $L43863
	mov	eax, edx

$L43863:
	mov	edx, DWORD PTR dwIncDelta
	cmp	edx, eax
	jae	SHORT $L43864
	mov	eax, edx

$L43864:

; 309  : 
; 310  : 		for (a += dwI; dwI < a; dwI++)

	inc	edx

	sub	edx, eax
	add	eax, ebx

	mov	DWORD PTR dwIncDelta, edx
	cmp	ebx, eax

	mov	DWORD PTR a, eax
	jae	$L43867

#ifdef USE_MMX // {
	// Try to handle two positions at once.

	lea	edx, [eax-3]
	cmp	ebx, edx
	jge	$L43865

	jmp	UseMmx

UseMmxLabel:
	//	Ok, there are at least two samples to handle.

	movd		mm1, DWORD PTR pfPitch
	psllq		mm1, 32						// Pitch,				0
	movd		mm2, DWORD PTR pfSamplePos
	punpckldq	mm2, mm2					// SamplePos,			SamplePos
	paddd		mm2, mm1					// SamplePos + Pitch,	SamplePos
	punpckhdq	mm1, mm1					// Pitch,				Pitch
	pslld		mm1, 1						// Pitch * 2,			Pitch * 2

	mov			eax, DWORD PTR pcWave
#if 0
    movq        mm4, QWORD PTR vfVolume
    pand        mm4, QWORD PTR ffffMask
    movq        mm5, mm4
    pslld       mm4, 16
    por         mm4, mm5
    psllw       mm4, 3
    movq        QWORD PTR MmxVolume, mm4
#endif
	
TwoAtATime:

;					dwPosition = pfSamplePos >> 12;
;					dwFract = pfSamplePos & 0xFFF;
;					pfSamplePos += pfPitch;

	movq		mm4, mm2
	psrad		mm4, 12				// dwPosition + Pitch,	dwPosition

;					lA = (long) pcWave[dwPosition];
;					lMInterp = (((pcWave[dwPosition+1] - lA) * (dwFract)) >> 12) + lA;

	movd		esi, mm4						// dwPosition
	punpckhdq	mm4, mm4						// dwPosition ( + Pitch ) = dwPos2
//	movd		mm5, DWORD PTR [eax+esi*2]		// 0, 0, dwPosition + 1, dwPosition
//	Instead for byte codes
	mov			si, WORD PTR [eax+esi]
	movd		mm6, esi
	punpcklbw	mm5, mm6
	psraw		mm5, 8
	movd		esi, mm4
//	movd		mm4, DWORD PTR [eax+esi*2]		// 0, 0, dwPos2 + 1, dwPos2
//	Instead for byte codes
	mov			si, WORD PTR [eax+esi]
	movd		mm6, esi
	punpcklbw	mm4, mm6
	psraw		mm4, 8
//	This code could be combined with code above, a bit.

	punpckldq	mm5, mm4						// dwPos2 + 1, dwPos2, dwPos1 + 1, dwPos1
	movq		mm4, mm2
	pand		mm4, QWORD PTR fffMask				// dwFract + Pitch,		dwFract
	packssdw	mm4, mm0
	movq		mm6, mm3
	psubw		mm6, mm4							// 0, 0, 1000 - dwFract + Pitch, 1000 - dwFract
	punpcklwd	mm6, mm4
	paddd		mm2, mm1			                // Next iteration
	pmaddwd		mm6, mm5
#if 1
	movq		mm5, QWORD PTR vfVolume 			//	Volume2, Volume1
	psrad		mm6, 12								// lMIntrep2, lMInterp
//	pand		mm6, QWORD PTR ffffMask
//	pand    	mm5, QWORD PTR ffffMask			//	16 bits only.

	movq		mm4, mm5
	mov	esi, DWORD PTR [ecx+4]

	punpckldq	mm4, mm4
	pmaddwd		mm4, mm6
	psrad		mm4, 5
	packssdw	mm4, mm0

	movd		mm7, DWORD PTR [esi+ebx*2]
	paddsw		mm7, mm4
	movd		DWORD PTR [esi+ebx*2], mm7

	//	CHANNEL 2

	punpckhdq	mm5, mm5						// 0, Volume2,   0, Volume2
	mov	esi, DWORD PTR [ecx+8]

	pmaddwd		mm5, mm6
	psrad		mm5, 5
	packssdw	mm5, mm0

	movd		mm7, DWORD PTR [esi+ebx*2]
	paddsw		mm7, mm5
	movd		DWORD PTR [esi+ebx*2], mm7

#else           // There is noise here, probably due to the signed nature of the multiply.
	psrad		mm6, 12								// lMIntrep2, lMInterp
    movq        mm5, QWORD PTR MmxVolume
    packssdw    mm6, mm0
    punpckldq   mm6, mm6
    pmulhw      mm6, mm5
	mov	esi, DWORD PTR [ecx+4]
	movd		mm7, DWORD PTR [esi+ebx*2]
	mov	esi, DWORD PTR [ecx+8]
	movd		mm4, DWORD PTR [esi+ebx*2]
    punpckldq   mm4, mm7
    paddsw      mm4, mm6
    movd        DWORD PTR [esi+ebx*2], mm4
    punpckhdq   mm4, mm4
	mov	esi, DWORD PTR [ecx+4]
    movd        DWORD PTR [esi+ebx*2], mm4

#endif

	add	ebx, 2

	cmp	ebx, edx
	jb	TwoAtATime

	movd	DWORD PTR pfSamplePos, mm2
#endif  // }

$L43865:

;					dwPosition = pfSamplePos >> 12;
;					dwFract = pfSamplePos & 0xFFF;
;					pfSamplePos += pfPitch;
;					lA = (long) pcWave[dwPosition];
;					lMInterp = (((pcWave[dwPosition+1] - lA) * dwFract) >> 12) + lA;

	mov	esi, DWORD PTR pfPitch
	mov	edx, DWORD PTR pfSamplePos

	mov	eax, DWORD PTR pcWave
	mov	edi, edx

	add	esi, edx
	and	edi, 4095

	sar	edx, 12
	mov	DWORD PTR pfSamplePos, esi

	movsx	esi, BYTE PTR [eax+edx]
	movsx	eax, BYTE PTR [eax+edx+1]

	sub	eax, esi

	imul	eax, edi

	sar	eax, 12
	mov	edi, One_Channel_2

	//	ebx, ecx, edx are used in switch branches

	add	eax, esi		// lMInterp
	jmp	edi

// ONE_CHANNEL
//          lM = lMInterp * vfVolume[dwJ - 1];
//          lM >>= 5;
//			ppBuffer[dwJ - 1][dwI] += (short) lM;

$L44009:

; 342  : 			default:
; 343  : 				for (dwJ = l_nChannels; dwJ > 8; dwJ--)

	mov	edi, DWORD PTR l_nChannels

	//	ecx ppBuffer
	//	eax lMInterp
	//	edi counter
	//	ebx dwI

$L43874:
	mov	edx, DWORD PTR vfVolume[edi*4-4]
	mov	esi, DWORD PTR [ecx+edi*4]			// ppBuffer[dwJ - 1]

	imul	edx, eax
	sar	edx, 5
	add	WORD PTR [esi+ebx*2], dx

	jno	no_overflow
	mov	WORD PTR [esi+ebx*2], 0x7fff
	js	no_overflow
	mov	WORD PTR [esi+ebx*2], 0x8000

no_overflow:
	dec	edi
	cmp	edi, 8
	jne	SHORT $L43874

	lea	edi, $L43876
}

#define ONE_CHANNEL_VOLUME(dwJ) \
    _asm { lea  edx, vfVolume } \
	_asm { mov	edx, DWORD PTR [edx + (dwJ-1) * 4] } \
	_asm { mov	esi, DWORD PTR [ecx + (dwJ) * 4] } \
	_asm { imul	edx, eax } \
	_asm { sar	edx, 5 } \
	_asm { add	edi, [esp] } \
	\
	_asm { add	WORD PTR [esi+ebx*2], dx } \
	_asm { jo	FAR overflow_x } 

    //-------------------------------------------------------------------------
    //
    //          ***** ***** ***** DO NOT CHANGE THIS! ***** ***** *****
    //
    // This lovely hack makes sure that all the instructions
    // are the same length for the case (dwJ - 1) == 0. Code depends on this
    // by calculating instruction offsets based on having 8 identical blocks.
    //
    //          ***** ***** ***** DO NOT CHANGE THIS! ***** ***** *****
    //
    //-------------------------------------------------------------------------
#define ONE_CHANNEL_VOLUME_1 \
    _asm { lea  edx, vfVolume } \
    _asm _emit 0x8B _asm _emit 0x52 _asm _emit 0x00 \
	_asm { mov	esi, DWORD PTR [ecx + 4] } \
	_asm { imul	edx, eax } \
	_asm { sar	edx, 5 } \
	_asm { add	edi, [esp] } \
	\
	_asm { add	WORD PTR [esi+ebx*2], dx } \
	_asm { jo	FAR overflow_x } 

$L43876:
	ONE_CHANNEL_VOLUME(8);
$L43880:
	ONE_CHANNEL_VOLUME(7);
	ONE_CHANNEL_VOLUME(6);
	ONE_CHANNEL_VOLUME(5);
	ONE_CHANNEL_VOLUME(4);
	ONE_CHANNEL_VOLUME(3);
	ONE_CHANNEL_VOLUME(2);
	ONE_CHANNEL_VOLUME_1;
#undef ONE_CHANNEL_VOLUME
#undef ONE_CHANNEL_VOLUME_1
$L43866:
_asm {
	mov	eax, DWORD PTR a
	inc	ebx

	cmp	ebx, eax
	jb	$L43865

	mov	edi, DWORD PTR l_nChannels
$L43867:
	cmp	ebx, DWORD PTR dwLength
	jb	$L44021
Exit_$L43841:
	pop eax
	mov	DWORD PTR dwI, ebx

#ifdef USE_MMX
    mov edi, UseMmx
    cmp edi, UseMmxLabel
    jne NoMmxCleanupLabel

	emms
NoMmxCleanupLabel:
#endif
}
#else // }{
    for (dwI = 0; dwI < dwLength;)
    {
        if (pfSamplePos >= pfSampleLength)
	    {	
	        if (pfLoopLength)
    		    pfSamplePos -= pfLoopLength;
	        else
	    	    break;
	    }
        dwIncDelta--;
        if (!dwIncDelta)   
        {
            dwIncDelta = dwDeltaPeriod;
            pfPFract += pfDeltaPitch;
            pfPitch = pfPFract >> 8;

#if 1
#define ONE_CHANNEL_VOLUME(dwJ) \
			vfVFract[dwJ - 1] += vfDeltaVolume[dwJ - 1]; \
			vfVolume[dwJ - 1]  = vfVFract     [dwJ - 1] >> 8;

			switch (l_nChannels)
			{
			default:
				for (dwJ = l_nChannels; dwJ > 8; dwJ--)
				{
					ONE_CHANNEL_VOLUME(dwJ);
				}
			case 8: ONE_CHANNEL_VOLUME(8);
			case 7: ONE_CHANNEL_VOLUME(7);
			case 6: ONE_CHANNEL_VOLUME(6);
			case 5: ONE_CHANNEL_VOLUME(5);
			case 4: ONE_CHANNEL_VOLUME(4);
			case 3: ONE_CHANNEL_VOLUME(3);
			case 2: ONE_CHANNEL_VOLUME(2);
			case 1: ONE_CHANNEL_VOLUME(1);
			case 0:;
			}
#undef ONE_CHANNEL_VOLUME
#else
            for (dwJ = 0; dwJ < l_nChannels; dwJ++)
            {
                vfVFract[dwJ] += vfDeltaVolume[dwJ];
                vfVolume[dwJ] = vfVFract[dwJ] >> 8;
            }
#endif
        }

#if 1 // {
		DWORD a = (pfSampleLength - pfSamplePos + pfPitch - 1) / pfPitch;
		DWORD b = dwLength - dwI;

		if (b < a) a = b;
		if (dwIncDelta < a) a = dwIncDelta;

		dwIncDelta -= a - 1;
		a          += dwI;

		for (; dwI < a; dwI++)
		{
			dwPosition = pfSamplePos >> 12;
			dwFract = pfSamplePos & 0xFFF;
			pfSamplePos += pfPitch;

			lA = (long) pcWave[dwPosition];
			lMInterp = (((pcWave[dwPosition+1] - lA) * dwFract) >> 12) + lA;
#if 1 // {
#if 1
#define ONE_CHANNEL_VOLUME(dwJ) \
		{ \
            lM = lMInterp * vfVolume[dwJ - 1]; \
            lM >>= 5; \
			ppBuffer[dwJ - 1][dwI] += (short) lM;\
			long b = ppBuffer[dwJ - 1][dwI]; \
			if ((short)b != b) { \
				if ((long)b < 0) b = 0x8000; \
				else b = 0x7fff; \
				ppBuffer[dwJ - 1][dwI] = (short) b; \
			} \
 		}
#else
#define ONE_CHANNEL_VOLUME(dwJ) \
		{ \
            lM = lMInterp * vfVolume[dwJ - 1]; \
            lM >>= 5; \
			ppBuffer[dwJ - 1][dwI] += (short) lM;\
 		}
#endif
			switch (l_nChannels)
			{
			default:
				for (dwJ = l_nChannels; dwJ > 8; dwJ--)
				{
					ONE_CHANNEL_VOLUME(dwJ);
				}
			case 8: ONE_CHANNEL_VOLUME(8);
			case 7: ONE_CHANNEL_VOLUME(7);
			case 6: ONE_CHANNEL_VOLUME(6);
			case 5: ONE_CHANNEL_VOLUME(5);
			case 4: ONE_CHANNEL_VOLUME(4);
			case 3: ONE_CHANNEL_VOLUME(3);
			case 2: ONE_CHANNEL_VOLUME(2);
			case 1: ONE_CHANNEL_VOLUME(1);
			case 0:;
			}
#undef ONE_CHANNEL_VOLUME
#else // }{
			for (dwJ = 0; dwJ < l_nChannels; dwJ++)
			{
				lM = lMInterp * vfVolume[dwJ]; 
				lM >>= 5;         // Signal bumps up to 12 bits.

				// Keep this around so we can use it to generate new assembly code (see below...)
#if 1
			{
			long x = ppBuffer[dwJ][dwI];
			
			x += lM;

			if (x != (short)x) {
				if (x > 32767) x = 32767;
				else  x = -32768;
			}

			ppBuffer[dwJ][dwI] = (short)x;
			}
#else
				ppBuffer[dwJ][dwI] += (short) lM;
				_asm{jno no_oflow}
				ppBuffer[dwJ][dwI] = 0x7fff;
				_asm{js  no_oflow}
				ppBuffer[dwJ][dwI] = (short) 0x8000;
no_oflow:	;
#endif
			}
#endif // }
		}
#else // }{
        dwPosition = pfSamplePos >> 12;
        dwFract = pfSamplePos & 0xFFF;
        pfSamplePos += pfPitch;

        lA = (long) pcWave[dwPosition];
        lMInterp = (((pcWave[dwPosition+1] - lA) * dwFract) >> 12) + lA;
#if 1
#if 1
#define ONE_CHANNEL_VOLUME(dwJ) \
		{ \
            lM = lMInterp * vfVolume[dwJ - 1]; \
            lM >>= 5; \
			ppBuffer[dwJ - 1][dwI] += (short) lM;\
			long b = ppBuffer[dwJ - 1][dwI]; \
			if ((short)b != b) { \
				if ((long)b < 0) b = 0x8000; \
				else b = 0x7fff; \
				ppBuffer[dwJ - 1][dwI] = (short) b; \
			} \
 		}
#else
#define ONE_CHANNEL_VOLUME(dwJ) \
		{ \
            lM = lMInterp * vfVolume[dwJ - 1]; \
            lM >>= 5; \
			ppBuffer[dwJ - 1][dwI] += (short) lM;\
 		}
#endif
			switch (l_nChannels)
			{
			default:
				for (dwJ = l_nChannels; dwJ > 8; dwJ--)
				{
					ONE_CHANNEL_VOLUME(dwJ);
				}
			case 8: ONE_CHANNEL_VOLUME(8);
			case 7: ONE_CHANNEL_VOLUME(7);
			case 6: ONE_CHANNEL_VOLUME(6);
			case 5: ONE_CHANNEL_VOLUME(5);
			case 4: ONE_CHANNEL_VOLUME(4);
			case 3: ONE_CHANNEL_VOLUME(3);
			case 2: ONE_CHANNEL_VOLUME(2);
			case 1: ONE_CHANNEL_VOLUME(1);
			case 0:;
			}
#undef ONE_CHANNEL_VOLUME
#else
        for (dwJ = 0; dwJ < l_nChannels; dwJ++)
        {
            lM = lMInterp * vfVolume[dwJ]; 
            lM >>= 5;         // Signal bumps up to 12 bits.

            // Keep this around so we can use it to generate new assembly code (see below...)
#if 1
			{
			long x = ppBuffer[dwJ][dwI];
			
			x += lM;

			if (x != (short)x) {
				if (x > 32767) x = 32767;
				else  x = -32768;
			}

			ppBuffer[dwJ][dwI] = (short)x;
			}
#else
            ppBuffer[dwJ][dwI] += (short) lM;
            _asm{jno no_oflow}
            ppBuffer[dwJ][dwI] = 0x7fff;
            _asm{js  no_oflow}
            ppBuffer[dwJ][dwI] = (short) 0x8000;
no_oflow:	;
#endif
        }
#endif
		dwI++;
#endif // }
    }
#endif // }
#else // }{
    for (dwI = 0; dwI < dwLength; )
    {
        if (pfSamplePos >= pfSampleLength)
	    {	
	        if (pfLoopLength)
		        pfSamplePos -= pfLoopLength;
	        else
		        break;
	    }
        dwIncDelta--;
        if (!dwIncDelta) 
        {
            dwIncDelta = dwDeltaPeriod;
            pfPFract += pfDeltaPitch;
            pfPitch = pfPFract >> 8;
            for (dwJ = 0; dwJ < dwBufferCount; dwJ++)
            {
                vfVFract[dwJ] += vfDeltaVolume[dwJ];
                vfVolume[dwJ] = vfVFract[dwJ] >> 8;
            }
        }

	    dwPosition = pfSamplePos >> 12;
	    dwFract = pfSamplePos & 0xFFF;
		pfSamplePos += pfPitch;

	    lMInterp = pcWave[dwPosition]; // pcWave
	    lMInterp += ((pcWave[dwPosition + 1] - lMInterp) * dwFract) >> 12;

        for (dwJ = 0; dwJ < dwBufferCount; dwJ++)
        {
    		lM = lMInterp * vfVolume[dwJ];
    		lM >>= 5;

            // Keep this around so we can use it to generate new assembly code (see below...)
#if 1
			{
			long x = ppBuffer[dwJ][dwI];
			
			x += lM;

			if (x != (short)x) {
				if (x > 32767) x = 32767;
				else  x = -32768;
			}

			ppBuffer[dwJ][dwI] = (short)x;
			}
#else
		    ppBuffer[dwJ][dwI] += (short) lM;
            _asm{jno no_oflow}
            ppBuffer[dwJ][dwI] = 0x7fff;
            _asm{js  no_oflow}
            ppBuffer[dwJ][dwI] = (short) 0x8000;
no_oflow:   ;
#endif
        }
		dwI++;
    }
#endif // }

    for (dwJ = 0; dwJ < dwBufferCount; dwJ++)
    {
        vfLastVolume[dwJ] = vfVolume[dwJ];
    }

    m_pfLastPitch = pfPitch;
    m_pfLastSample = pfSamplePos;

    return (dwI);
}
                        
DWORD CDigitalAudio::MixMulti8Filter(
    short *ppBuffer[], 
	DWORD dwBufferCount,
    DWORD dwLength, 
    DWORD dwDeltaPeriod, 
    VFRACT vfDeltaVolume[], 
	VFRACT vfLastVolume[], 
    PFRACT pfDeltaPitch, 
    PFRACT pfSampleLength, 
    PFRACT pfLoopLength,
    COEFF cfdK,
    COEFF cfdB1,
    COEFF cfdB2)
{
    DWORD dwI, dwJ;
    DWORD dwPosition;
    long lMInterp;
    long lM;
    DWORD dwIncDelta = dwDeltaPeriod;
    VFRACT dwFract;
    char * pcWave = (char *) m_pnWave;
    PFRACT pfSamplePos = m_pfLastSample;
    PFRACT pfPitch = m_pfLastPitch;
    PFRACT pfPFract = pfPitch << 8;
    COEFF cfK  = m_cfLastK;
    COEFF cfB1 = m_cfLastB1;
    COEFF cfB2 = m_cfLastB2;

    VFRACT vfVolume[MAX_DAUD_CHAN]; // = m_vfLastLVolume;
    VFRACT vfVFract[MAX_DAUD_CHAN]; // = vfVolume << 8;  // Keep high res version around. 
	DWORD dMM6[2];

    for (dwI = 0; dwI < dwBufferCount; dwI++)
    {
        vfVolume[dwI] = vfLastVolume[dwI];
        vfVFract[dwI] = vfVolume[dwI] << 8;
    }    

#if 1 // {
	DWORD l_nChannels = dwBufferCount;
	DWORD a;
	DWORD One_Channel_1, One_Channel_2;	// Code address locations.
	long l_lPrevPrevSample = m_lPrevPrevSample, l_lPrevSample = m_lPrevSample;

#ifdef USE_MMX_FILTERED // {
	typedef __int64 QWORD;
	QWORD	OneMask	 = 0x0000000010001000;
	QWORD	fffMask  = 0x00000fff00000fff;
	QWORD	ffffMask = 0x0000ffff0000ffff;
	DWORD	UseMmx;
    DWORD   MmxVolume[2];
	int		Use_MMX = m_sfMMXEnabled;

	_asm {
    lea edi, $L43865

    // Turned off    
	cmp	Use_MMX, 0
	je	AssignMmxLabel

    // != 2 channels
	mov	esi, DWORD PTR l_nChannels
	cmp	esi, 2
	jne	AssignMmxLabel

    // Ok, init and use MMX

	lea	edi, UseMmxLabel

	pxor		mm0, mm0
	movq		mm3, QWORD PTR OneMask		// 0, 0, 0x1000, 0x1000

AssignMmxLabel:
	mov	DWORD PTR UseMmx, edi

	}
#endif // }

	_asm {
	mov	edi, DWORD PTR l_nChannels

	cmp	edi, 8
	jna	Start1

	lea	esi, $L44008
	jmp Do_One_Channel_2

	// Put this code more than 127 bytes away from the references.

overflow_x:
	js	overflow_y
	mov	WORD PTR [esi+ebx*2], 0x8000
	jmp	edi

overflow_y:
	mov	WORD PTR [esi+ebx*2], 0x7fff
	jmp	edi

Start1:	
	test	edi, edi
	jne	Start2

	lea	esi, $L43860
	jmp	Do_One_Channel_2

Start2:
	lea	eax, $L43851
	lea	edx, $L43853

	sub	edx, eax
	mov	esi, 8

	sub	esi, edi
	imul	esi, edx
	add	esi, eax

Do_One_Channel_2:
	mov	DWORD PTR One_Channel_1, esi

	//	Create second jump table location.
	
	lea	esi, $L43876
	lea	ecx, $L43880

	sub	ecx, esi

	push ecx				// Span between branches.

	mov	eax, 8
	sub	eax, DWORD PTR l_nChannels

	jge		Start3
	
	lea	ecx, $L44009
	jmp	Done_Do_Channel_2

Start3:
	cmp	eax, 8
	jne	Start4

	lea	ecx, $L43866
	jmp	Done_Do_Channel_2

Start4:
	imul	ecx, eax
	add		ecx, esi

Done_Do_Channel_2:
	mov	DWORD PTR One_Channel_2, ecx


	mov	ecx, DWORD PTR dwLength
	xor	ebx, ebx					// dwI

	test	ecx, ecx
	jbe	Exit_$L43841

	mov	ecx, DWORD PTR ppBuffer
	sub	ecx, 4

	//	ecx == ppBuffer
	//	ebx == dwI
	//	edi == l_nChannels
$L44021:

	mov	edx, DWORD PTR pfSamplePos
	cmp	edx, DWORD PTR pfSampleLength
	jl	SHORT $L43842

	mov	eax, DWORD PTR pfLoopLength
	test	eax, eax
	je	Exit_$L43841

	sub	edx, eax
	mov	DWORD PTR pfSamplePos, edx

$L43842:
	mov	edx, DWORD PTR dwIncDelta
	mov	eax, DWORD PTR pfPFract

	dec	edx

	mov	DWORD PTR dwIncDelta, edx
	jne	$L43860

	mov	edx, DWORD PTR dwDeltaPeriod
	mov	esi, DWORD PTR pfDeltaPitch

	mov	DWORD PTR dwIncDelta, edx
	add	eax, esi

	mov	DWORD PTR pfPFract, eax

	sar	eax, 8
	mov	DWORD PTR pfPitch, eax

	mov	esi, DWORD PTR vfDeltaVolume
	jmp	One_Channel_1

// ONE_CHANNEL
//			vfVFract[dwJ - 1] += vfDeltaVolume[dwJ - 1];
//			vfVolume[dwJ - 1]  = vfVFract     [dwJ - 1] >> 8;

$L44008:

	mov	DWORD PTR dwI, ebx
	lea	ebx, DWORD PTR [edi*4-4]
	add	edi, -8					; fffffff8H
$L43849:

	lea	eax, DWORD PTR vfVFract[ebx]
	mov	ecx, DWORD PTR [esi+ebx]
	sub	ebx, 4
	add	DWORD PTR [eax], ecx
	mov	eax, DWORD PTR [eax]
	sar	eax, 8
	mov	DWORD PTR vfVolume[ebx+4], eax
	dec	edi
	jne	SHORT $L43849

	mov	edi, DWORD PTR l_nChannels
	mov	ecx, DWORD PTR ppBuffer

	mov	ebx, DWORD PTR dwI
	sub	ecx, 4
}
#define ONE_CHANNEL_VOLUME(dwJ) \
	_asm { mov	eax, DWORD PTR vfVFract[(dwJ-1)*4] }; \
	_asm { add	eax, DWORD PTR [esi+(dwJ-1)*4] }; \
	_asm { mov	DWORD PTR vfVFract[(dwJ-1)*4], eax }; \
	_asm { sar	eax, 8 }; \
    _asm { lea  edx, vfVolume }; \
	_asm { mov	DWORD PTR [edx + (dwJ-1)*4], eax };

    //-------------------------------------------------------------------------
    //
    //          ***** ***** ***** DO NOT CHANGE THIS! ***** ***** *****
    //
    // This lovely hack makes sure that all the instructions
    // are the same length for the case (dwJ - 1) == 0. Code depends on this
    // by calculating instruction offsets based on having 8 identical blocks.
    //
    //          ***** ***** ***** DO NOT CHANGE THIS! ***** ***** *****
    //
    //-------------------------------------------------------------------------

#define ONE_CHANNEL_VOLUME_1 \
	_asm { mov	eax, DWORD PTR vfVFract[0] }; \
    _asm _emit 0x03 _asm _emit 0x46 _asm _emit 0x00  \
	_asm { mov	DWORD PTR vfVFract[0], eax }; \
	_asm { sar	eax, 8 }; \
    _asm { lea  edx, vfVolume }; \
    _asm _emit 0x89 _asm _emit 0x42 _asm _emit 0x00

$L43851:
	ONE_CHANNEL_VOLUME(8)
$L43853:
	ONE_CHANNEL_VOLUME(7);
	ONE_CHANNEL_VOLUME(6);
	ONE_CHANNEL_VOLUME(5);
	ONE_CHANNEL_VOLUME(4);
	ONE_CHANNEL_VOLUME(3);
	ONE_CHANNEL_VOLUME(2);
	ONE_CHANNEL_VOLUME_1;
#undef ONE_CHANNEL_VOLUME
#undef ONE_CHANNEL_VOLUME_1

_asm {
	//	cfK += cfdK;
	//	cfB1 += cfdB1;
	//	cfB2 += cfdB2;

	mov	eax, DWORD PTR cfdK
	mov	edx, DWORD PTR cfdB1
	
	mov	esi, DWORD PTR cfdB2
	add	DWORD PTR cfK, eax

	add DWORD PTR cfB1, edx
	add	DWORD PTR cfB2, esi

$L43860:
; 304  : 		DWORD a = (pfSampleLength - pfSamplePos + pfPitch - 1) / pfPitch;

	mov	esi, DWORD PTR pfPitch
	mov	eax, DWORD PTR pfSampleLength

	dec	esi
	sub	eax, DWORD PTR pfSamplePos

	add	eax, esi
	cdq
	idiv	DWORD PTR pfPitch

	mov	edx, DWORD PTR dwLength
	sub	edx, ebx

	cmp	edx, eax
	jae	SHORT $L43863
	mov	eax, edx

$L43863:
	mov	edx, DWORD PTR dwIncDelta
	cmp	edx, eax
	jae	SHORT $L43864
	mov	eax, edx

$L43864:

; 309  : 
; 310  : 		for (a += dwI; dwI < a; dwI++)

	inc	edx

	sub	edx, eax
	add	eax, ebx

	mov	DWORD PTR dwIncDelta, edx
	cmp	ebx, eax

	mov	DWORD PTR a, eax
	jae	$L43867

#ifdef USE_MMX_FILTERED // {
	// Try to handle two positions at once.

	lea	edx, [eax-3]
	cmp	ebx, edx
	jge	$L43865

	jmp	UseMmx

UseMmxLabel:
	//	Ok, there are at least two samples to handle.

	movd		mm1, DWORD PTR pfPitch
	psllq		mm1, 32						// Pitch,				0
	movd		mm2, DWORD PTR pfSamplePos
	punpckldq	mm2, mm2					// SamplePos,			SamplePos
	paddd		mm2, mm1					// SamplePos + Pitch,	SamplePos
	punpckhdq	mm1, mm1					// Pitch,				Pitch
	pslld		mm1, 1						// Pitch * 2,			Pitch * 2

	mov			eax, DWORD PTR pcWave
#if 0
    movq        mm4, QWORD PTR vfVolume
    pand        mm4, QWORD PTR ffffMask
    movq        mm5, mm4
    pslld       mm4, 16
    por         mm4, mm5
    psllw       mm4, 3
    movq        QWORD PTR MmxVolume, mm4
#endif
	
TwoAtATime:

;					dwPosition = pfSamplePos >> 12;
;					dwFract = pfSamplePos & 0xFFF;
;					pfSamplePos += pfPitch;

	movq		mm4, mm2
	psrad		mm4, 12				// dwPosition + Pitch,	dwPosition

;					lA = (long) pcWave[dwPosition];
;					lMInterp = (((pcWave[dwPosition+1] - lA) * (dwFract)) >> 12) + lA;

	movd		esi, mm4						// dwPosition
	punpckhdq	mm4, mm4						// dwPosition ( + Pitch ) = dwPos2
//	movd		mm5, DWORD PTR [eax+esi*2]		// 0, 0, dwPosition + 1, dwPosition
//	Instead for byte codes
	mov			si, WORD PTR [eax+esi]
	movd		mm6, esi
	punpcklbw	mm5, mm6
	psraw		mm5, 8
	movd		esi, mm4
//	movd		mm4, DWORD PTR [eax+esi*2]		// 0, 0, dwPos2 + 1, dwPos2
//	Instead for byte codes
	mov			si, WORD PTR [eax+esi]
	movd		mm6, esi
	punpcklbw	mm4, mm6
	psraw		mm4, 8
//	This code could be combined with code above, a bit.

	punpckldq	mm5, mm4						// dwPos2 + 1, dwPos2, dwPos1 + 1, dwPos1
	movq		mm4, mm2
	pand		mm4, QWORD PTR fffMask				// dwFract + Pitch,		dwFract
	packssdw	mm4, mm0
	movq		mm6, mm3
	psubw		mm6, mm4							// 0, 0, 1000 - dwFract + Pitch, 1000 - dwFract
	punpcklwd	mm6, mm4
	paddd		mm2, mm1			                // Next iteration
	pmaddwd		mm6, mm5
#if 1
	psrad		mm6, 12								// lMIntrep2, lMInterp

#if 1
	//	eax, ebx, ecx, edx, esi are used.	edi is free...
	push	eax
	push	ecx
	push	edx

	movq	QWORD PTR dMM6, mm6

	mov		eax, DWORD PTR dMM6
	imul	DWORD PTR cfK		// edx:eax
	
	mov		ecx, eax
	mov		eax, DWORD PTR l_lPrevPrevSample

	mov		edi, edx			// esi:ecx
	imul	DWORD PTR cfB2

	sub		ecx, eax
	mov		eax, DWORD PTR l_lPrevSample

	sbb		edi, edx
	mov		DWORD PTR l_lPrevPrevSample, eax

	imul	DWORD PTR cfB1

	add		eax, ecx
	adc		edx, edi

//>>>>> MOD:PETCHEY 
//	shld	eax, edx, 2
//>>>>> should be 
	shld	edx, eax, 2
	mov		eax, edx


	mov	DWORD PTR dMM6, eax
	mov	DWORD PTR l_lPrevSample, eax

	//	2nd sample

	mov		eax, DWORD PTR dMM6+4
	imul	DWORD PTR cfK		// edx:eax
	
	mov		ecx, eax
	mov		eax, DWORD PTR l_lPrevPrevSample

	mov		edi, edx			// esi:ecx
	imul	DWORD PTR cfB2

	sub		ecx, eax
	mov		eax, DWORD PTR l_lPrevSample

	sbb		edi, edx
	mov		DWORD PTR l_lPrevPrevSample, eax

	imul	DWORD PTR cfB1

	add		eax, ecx
	adc		edx, edi

//>>>>> MOD:PETCHEY 
//	shld	eax, edx, 2
//>>>>> should be 
	shld	edx, eax, 2
	mov		eax, edx

	mov	DWORD PTR dMM6+4, eax
	mov	DWORD PTR l_lPrevSample, eax

	movq	mm6, QWORD PTR dMM6

	pop		edx
	pop		ecx
	pop		eax
#endif
	movq		mm5, QWORD PTR vfVolume 			//	Volume2, Volume1

//	pand		mm6, QWORD PTR ffffMask
	
//	packssdw	mm6, mm0				// 		Saturate to 16 bits, instead.
//	punpcklwd	mm6, mm0

//	pand    	mm5, QWORD PTR ffffMask			//	16 bits only.

	movq		mm4, mm5
	mov	esi, DWORD PTR [ecx+4]

	punpckldq	mm4, mm4
	pmaddwd		mm4, mm6
	psrad		mm4, 5
	packssdw	mm4, mm0

	movd		mm7, DWORD PTR [esi+ebx*2]
	paddsw		mm7, mm4
	movd		DWORD PTR [esi+ebx*2], mm7

	//	CHANNEL 2

	punpckhdq	mm5, mm5						// 0, Volume2,   0, Volume2
	mov	esi, DWORD PTR [ecx+8]

	pmaddwd		mm5, mm6
	psrad		mm5, 5
	packssdw	mm5, mm0

	movd		mm7, DWORD PTR [esi+ebx*2]
	paddsw		mm7, mm5
	movd		DWORD PTR [esi+ebx*2], mm7

#else           // There is noise here, probably due to the signed nature of the multiply.
	psrad		mm6, 12								// lMIntrep2, lMInterp
    movq        mm5, QWORD PTR MmxVolume
    packssdw    mm6, mm0
    punpckldq   mm6, mm6
    pmulhw      mm6, mm5
	mov	esi, DWORD PTR [ecx+4]
	movd		mm7, DWORD PTR [esi+ebx*2]
	mov	esi, DWORD PTR [ecx+8]
	movd		mm4, DWORD PTR [esi+ebx*2]
    punpckldq   mm4, mm7
    paddsw      mm4, mm6
    movd        DWORD PTR [esi+ebx*2], mm4
    punpckhdq   mm4, mm4
	mov	esi, DWORD PTR [ecx+4]
    movd        DWORD PTR [esi+ebx*2], mm4

#endif

	add	ebx, 2

	cmp	ebx, edx
	jb	TwoAtATime

	movd	DWORD PTR pfSamplePos, mm2
#endif  // }

$L43865:

;					dwPosition = pfSamplePos >> 12;
;					dwFract = pfSamplePos & 0xFFF;
;					pfSamplePos += pfPitch;
;					lA = (long) pcWave[dwPosition];
;					lMInterp = (((pcWave[dwPosition+1] - lA) * dwFract) >> 12) + lA;

	mov	esi, DWORD PTR pfPitch
	mov	edx, DWORD PTR pfSamplePos

	mov	eax, DWORD PTR pcWave
	mov	edi, edx

	add	esi, edx
	and	edi, 4095

	sar	edx, 12
	mov	DWORD PTR pfSamplePos, esi

	movsx	esi, BYTE PTR [eax+edx]
	movsx	eax, BYTE PTR [eax+edx+1]

	sub	eax, esi

	imul	eax, edi

	sar	eax, 12
	mov	edi, One_Channel_2

	//	ebx, ecx, edx are used in switch branches

	add	eax, esi		// lMInterp

//	lMInterp =
//		MulDiv(lMInterp, cfK, (1 << 30))
//		- MulDiv(m_lPrevPrevSample, cfB2, (1 << 30))
//		+ MulDiv(m_lPrevSample, cfB1, (1 << 30))

	push	ecx
	imul	DWORD PTR cfK		// edx:eax
	
	mov		ecx, eax
	mov		eax, DWORD PTR l_lPrevPrevSample

	mov		esi, edx			// esi:ecx
	imul	DWORD PTR cfB2

	sub		ecx, eax
	mov		eax, DWORD PTR l_lPrevSample

	sbb		esi, edx
	mov		DWORD PTR l_lPrevPrevSample, eax

	imul	DWORD PTR cfB1

	add		eax, ecx			// esi:eax
	adc		esi, edx

	pop		ecx
//	shrd	eax, esi, 30
		
//>>>>> MOD:PETCHEY 
//	shld	eax, esi, 2
//>>>>> should be 
	shld	esi, eax, 2
	mov		eax, esi

//>>>>>>>>>>>> removed dp
#if 0 
//	if (lMInterp < -32767) lMInterp = -32767;
//	else if (lMInterp > 32767) lMInterp = 32767;

	cmp		eax, -32767
	jl		Less_than
	cmp		eax, 32767
	jg		Greater_than
#endif

//	m_lPrevPrevSample = m_lPrevSample;
//	m_lPrevSample = lMInterp;

	mov	DWORD PTR l_lPrevSample, eax
	jmp	edi

Less_than:
	mov	eax, -32767
	mov	DWORD PTR l_lPrevSample, eax
	jmp	edi

Greater_than:
	mov	eax, 32767
	mov	DWORD PTR l_lPrevSample, eax
	jmp	edi

// ONE_CHANNEL
//          lM = lMInterp * vfVolume[dwJ - 1];
//          lM >>= 5;
//			ppBuffer[dwJ - 1][dwI] += (short) lM;

$L44009:

; 342  : 			default:
; 343  : 				for (dwJ = l_nChannels; dwJ > 8; dwJ--)

	mov	edi, DWORD PTR l_nChannels

	//	ecx ppBuffer
	//	eax lMInterp
	//	edi counter
	//	ebx dwI

$L43874:
	mov	edx, DWORD PTR vfVolume[edi*4-4]
	mov	esi, DWORD PTR [ecx+edi*4]			// ppBuffer[dwJ - 1]

	imul	edx, eax
	sar	edx, 5
	add	WORD PTR [esi+ebx*2], dx

	jno	no_overflow
	mov	WORD PTR [esi+ebx*2], 0x7fff
	js	no_overflow
	mov	WORD PTR [esi+ebx*2], 0x8000

no_overflow:
	dec	edi
	cmp	edi, 8
	jne	SHORT $L43874

	lea	edi, $L43876
}

#define ONE_CHANNEL_VOLUME(dwJ) \
    _asm { lea  edx, vfVolume } \
	_asm { mov	edx, DWORD PTR [edx + (dwJ-1) * 4] } \
	_asm { mov	esi, DWORD PTR [ecx + (dwJ) * 4] } \
	_asm { imul	edx, eax } \
	_asm { sar	edx, 5 } \
	_asm { add	edi, [esp] } \
	\
	_asm { add	WORD PTR [esi+ebx*2], dx } \
	_asm { jo	FAR overflow_x } 

    //-------------------------------------------------------------------------
    //
    //          ***** ***** ***** DO NOT CHANGE THIS! ***** ***** *****
    //
    // This lovely hack makes sure that all the instructions
    // are the same length for the case (dwJ - 1) == 0. Code depends on this
    // by calculating instruction offsets based on having 8 identical blocks.
    //
    //          ***** ***** ***** DO NOT CHANGE THIS! ***** ***** *****
    //
    //-------------------------------------------------------------------------
#define ONE_CHANNEL_VOLUME_1 \
    _asm { lea  edx, vfVolume } \
    _asm _emit 0x8B _asm _emit 0x52 _asm _emit 0x00 \
	_asm { mov	esi, DWORD PTR [ecx + 4] } \
	_asm { imul	edx, eax } \
	_asm { sar	edx, 5 } \
	_asm { add	edi, [esp] } \
	\
	_asm { add	WORD PTR [esi+ebx*2], dx } \
	_asm { jo	FAR overflow_x } 

$L43876:
	ONE_CHANNEL_VOLUME(8);
$L43880:
	ONE_CHANNEL_VOLUME(7);
	ONE_CHANNEL_VOLUME(6);
	ONE_CHANNEL_VOLUME(5);
	ONE_CHANNEL_VOLUME(4);
	ONE_CHANNEL_VOLUME(3);
	ONE_CHANNEL_VOLUME(2);
	ONE_CHANNEL_VOLUME_1;
#undef ONE_CHANNEL_VOLUME
#undef ONE_CHANNEL_VOLUME_1
$L43866:
_asm {
	mov	eax, DWORD PTR a
	inc	ebx

	cmp	ebx, eax
	jb	$L43865

	mov	edi, DWORD PTR l_nChannels
$L43867:
	cmp	ebx, DWORD PTR dwLength
	jb	$L44021
Exit_$L43841:
	pop eax
	mov	DWORD PTR dwI, ebx

#ifdef USE_MMX_FILTERED
    mov edi, UseMmx
    cmp edi, UseMmxLabel
    jne NoMmxCleanupLabel

	emms
NoMmxCleanupLabel:
#endif
}
	m_lPrevPrevSample = l_lPrevPrevSample;
	m_lPrevSample     = l_lPrevSample;
#else // }{
    for (dwI = 0; dwI < dwLength; )
    {
        if (pfSamplePos >= pfSampleLength)
	    {	
	        if (pfLoopLength)
		        pfSamplePos -= pfLoopLength;
	        else
		        break;
	    }
        dwIncDelta--;
        if (!dwIncDelta) 
        {
            dwIncDelta = dwDeltaPeriod;
            pfPFract += pfDeltaPitch;
            pfPitch = pfPFract >> 8;
            for (dwJ = 0; dwJ < dwBufferCount; dwJ++)
            {
                vfVFract[dwJ] += vfDeltaVolume[dwJ];
                vfVolume[dwJ] = vfVFract[dwJ] >> 8;
            }

            cfK += cfdK;
            cfB1 += cfdB1;
            cfB2 += cfdB2;
        }
	    
	    dwPosition = pfSamplePos >> 12;
	    dwFract = pfSamplePos & 0xFFF;
		pfSamplePos += pfPitch;

	    lMInterp = pcWave[dwPosition]; // pcWave
	    lMInterp += ((pcWave[dwPosition + 1] - lMInterp) * dwFract) >> 12;

        // Filter
        //
        lMInterp =
              MulDiv(lMInterp, cfK, (1 << 30))
            - MulDiv(m_lPrevSample, cfB1, (1 << 30))
            + MulDiv(m_lPrevPrevSample, cfB2, (1 << 30));

        m_lPrevPrevSample = m_lPrevSample;
        m_lPrevSample = lMInterp;

        for (dwJ = 0; dwJ < dwBufferCount; dwJ++)
        {
    		lM = lMInterp * vfVolume[dwJ];
    		lM >>= 5;

            // Keep this around so we can use it to generate new assembly code (see below...)
#if 1
			{
			long x = ppBuffer[dwJ][dwI];
			
			x += lM;

			if (x != (short)x) {
				if (x > 32767) x = 32767;
				else  x = -32768;
			}

			ppBuffer[dwJ][dwI] = (short)x;
			}
#else
		    ppBuffer[dwJ][dwI] += (short) lM;
            _asm{jno no_oflow}
            ppBuffer[dwJ][dwI] = 0x7fff;
            _asm{js  no_oflow}
            ppBuffer[dwJ][dwI] = (short) 0x8000;
no_oflow:   ;
#endif
        }
		dwI++;
    }
#endif // }

    for (dwJ = 0; dwJ < dwBufferCount; dwJ++)
    {
        vfLastVolume[dwJ] = vfVolume[dwJ];
    }

    m_pfLastPitch = pfPitch;
    m_pfLastSample = pfSamplePos;

    return (dwI);
}

#if 0
DWORD CDigitalAudio::MixMulti16(
    short *ppBuffer[], 
	DWORD dwBufferCount,
    DWORD dwLength, 
    DWORD dwDeltaPeriod, 
    VFRACT vfDeltaVolume[], 
	VFRACT vfLastVolume[], 
    PFRACT pfDeltaPitch, 
    PFRACT pfSampleLength, 
    PFRACT pfLoopLength)
{
    DWORD dwI, dwJ;
    DWORD dwPosition;
    long lA;//, lB;
    long lM;
    long lMInterp;
    DWORD dwIncDelta = dwDeltaPeriod;
    VFRACT dwFract;
    short * pcWave = m_pnWave;
    PFRACT pfSamplePos = m_pfLastSample;
    PFRACT pfPitch = m_pfLastPitch;
    PFRACT pfPFract = pfPitch << 8;

    VFRACT vfVolume[MAX_DAUD_CHAN]; // = m_vfLastLVolume;
    VFRACT vfVFract[MAX_DAUD_CHAN]; // = vfVolume << 8;  // Keep high res version around. 

    for (dwI = 0; dwI < dwBufferCount; dwI++)
    {
        vfVolume[dwI] = vfLastVolume[dwI];
        vfVFract[dwI] = vfVolume[dwI] << 8;
    }    

    for (dwI = 0; dwI < dwLength;)
    {
        if (pfSamplePos >= pfSampleLength)
	    {	
	        if (pfLoopLength)
    		    pfSamplePos -= pfLoopLength;
	        else
	    	    break;
	    }
        dwIncDelta--;
        if (!dwIncDelta)   
        {
            dwIncDelta = dwDeltaPeriod;
            pfPFract += pfDeltaPitch;
            pfPitch = pfPFract >> 8;
            for (dwJ = 0; dwJ < dwBufferCount; dwJ++)
            {
                vfVFract[dwJ] += vfDeltaVolume[dwJ];
                vfVolume[dwJ] = vfVFract[dwJ] >> 8;
            }
        }

        dwPosition = pfSamplePos >> 12;
        dwFract = pfSamplePos & 0xFFF;
        pfSamplePos += pfPitch;

        lA = (long) pcWave[dwPosition];
        lMInterp = (((pcWave[dwPosition+1] - lA) * dwFract) >> 12) + lA;


        for (dwJ = 0; dwJ < dwBufferCount; dwJ++)
        {
            lM = lMInterp * vfVolume[dwJ]; 
            lM >>= 13;         // Signal bumps up to 12 bits.

            // Keep this around so we can use it to generate new assembly code (see below...)
#if 1
			{
			long x = ppBuffer[dwJ][dwI];
			
			x += lM;

			if (x != (short)x) {
				if (x > 32767) x = 32767;
				else  x = -32768;
			}

			ppBuffer[dwJ][dwI] = (short)x;
			}
#else
            ppBuffer[dwJ][dwI] += (short) lM;
            _asm{jno no_oflow}
            ppBuffer[dwJ][dwI] = 0x7fff;
            _asm{js  no_oflow}
            ppBuffer[dwJ][dwI] = (short) 0x8000;
#endif
no_oflow:	;
        }
		dwI++;
    }
    m_pfLastPitch = pfPitch;
    m_pfLastSample = pfSamplePos;

    for (dwJ = 0; dwJ < dwBufferCount; dwJ++)
    {
        vfLastVolume[dwJ] = vfVolume[dwJ];
    }
    return (dwI);
}
#else
DWORD CDigitalAudio::MixMulti16(
    short *ppBuffer[], 
	DWORD dwBufferCount,
    DWORD dwLength, 
    DWORD dwDeltaPeriod, 
    VFRACT vfDeltaVolume[], 
	VFRACT vfLastVolume[], 
    PFRACT pfDeltaPitch, 
    PFRACT pfSampleLength, 
    PFRACT pfLoopLength)
{
    DWORD dwI, dwJ;
    DWORD dwPosition;
    long lA;//, lB;
    long lM;
    long lMInterp;
    DWORD dwIncDelta = dwDeltaPeriod;
    VFRACT dwFract;
    short * pcWave = m_pnWave;
    PFRACT pfSamplePos = m_pfLastSample;
    PFRACT pfPitch = m_pfLastPitch;
    PFRACT pfPFract = pfPitch << 8;

    VFRACT vfVolume[MAX_DAUD_CHAN]; // = m_vfLastLVolume;
    VFRACT vfVFract[MAX_DAUD_CHAN]; // = vfVolume << 8;  // Keep high res version around. 


    for (dwI = 0; dwI < dwBufferCount; dwI++)
    {
        vfVolume[dwI] = vfLastVolume[dwI];
        vfVFract[dwI] = vfVolume[dwI] << 8;
    }    

#if 1 // {
	DWORD l_nChannels = dwBufferCount;
	DWORD a;
	DWORD One_Channel_1, One_Channel_2;	// Code address locations.
#ifdef USE_MMX // {
	typedef __int64 QWORD;
	QWORD	OneMask	 = 0x0000000010001000;
	QWORD	fffMask  = 0x00000fff00000fff;
	QWORD	ffffMask = 0x0000ffff0000ffff;
	DWORD	UseMmx;
    DWORD   MmxVolume[2];
	int		Use_MMX = m_sfMMXEnabled;

	_asm {
    lea edi, $L43865

    // Turned off
	cmp	Use_MMX, 0
	je	AssignMMXLabel

    // != 2 channels
	mov	esi, DWORD PTR l_nChannels
	cmp	esi, 2
	jne	AssignMmxLabel

    // Ok, init and use MMX
	lea	edi, UseMmxLabel

	pxor		mm0, mm0
	movq		mm3, QWORD PTR OneMask		// 0, 0, 0x1000, 0x1000

AssignMmxLabel:
	mov	DWORD PTR UseMmx, edi

	}
#endif // }

	_asm {
	mov	edi, DWORD PTR l_nChannels

	cmp	edi, 8
	jna	Start1

	lea	esi, $L44008
	jmp Do_One_Channel_2

	// Put this code more than 127 bytes away from the references.

overflow_x:
	js	overflow_y
	mov	WORD PTR [esi+ebx*2], 0x8000
	jmp	edi

overflow_y:
	mov	WORD PTR [esi+ebx*2], 0x7fff
	jmp	edi

Start1:	
	test	edi, edi
	jne	Start2

	lea	esi, $L43860
	jmp	Do_One_Channel_2

Start2:
	lea	eax, $L43851
	lea	edx, $L43853

	sub	edx, eax
	mov	esi, 8

	sub	esi, edi
	imul	esi, edx
	add	esi, eax

Do_One_Channel_2:
	mov	DWORD PTR One_Channel_1, esi

	//	Create second jump table location.
	
	lea	esi, $L43876
	lea	ecx, $L43880

	sub	ecx, esi

	push ecx				// Span between branches.

	mov	eax, 8
	sub	eax, DWORD PTR l_nChannels

	jge		Start3
	
	lea	ecx, $L44009
	jmp	Done_Do_Channel_2

Start3:
	cmp	eax, 8
	jne	Start4

	lea	ecx, $L43866
	jmp	Done_Do_Channel_2

Start4:
	imul	ecx, eax
	add		ecx, esi

Done_Do_Channel_2:
	mov	DWORD PTR One_Channel_2, ecx


	mov	ecx, DWORD PTR dwLength
	xor	ebx, ebx					// dwI

	test	ecx, ecx
	jbe	Exit_$L43841

	mov	ecx, DWORD PTR ppBuffer
	sub	ecx, 4

	//	ecx == ppBuffer
	//	ebx == dwI
	//	edi == l_nChannels
$L44021:

	mov	edx, DWORD PTR pfSamplePos
	cmp	edx, DWORD PTR pfSampleLength
	jl	SHORT $L43842

	mov	eax, DWORD PTR pfLoopLength
	test	eax, eax
	je	Exit_$L43841

	sub	edx, eax
	mov	DWORD PTR pfSamplePos, edx

$L43842:
	mov	edx, DWORD PTR dwIncDelta
	mov	eax, DWORD PTR pfPFract

	dec	edx

	mov	DWORD PTR dwIncDelta, edx
	jne	$L43860

	mov	edx, DWORD PTR dwDeltaPeriod
	mov	esi, DWORD PTR pfDeltaPitch

	mov	DWORD PTR dwIncDelta, edx
	add	eax, esi

	mov	DWORD PTR pfPFract, eax

	sar	eax, 8
	mov	DWORD PTR pfPitch, eax

	mov	esi, DWORD PTR vfDeltaVolume
	jmp	One_Channel_1

// ONE_CHANNEL
//			vfVFract[dwJ - 1] += vfDeltaVolume[dwJ - 1];
//			vfVolume[dwJ - 1]  = vfVFract     [dwJ - 1] >> 8;

$L44008:

	mov	DWORD PTR dwI, ebx
	lea	ebx, DWORD PTR [edi*4-4]
	add	edi, -8					; fffffff8H
$L43849:

	lea	eax, DWORD PTR vfVFract[ebx]
	mov	ecx, DWORD PTR [esi+ebx]
	sub	ebx, 4
	add	DWORD PTR [eax], ecx
	mov	eax, DWORD PTR [eax]
	sar	eax, 8
	mov	DWORD PTR vfVolume[ebx+4], eax
	dec	edi
	jne	SHORT $L43849

	mov	edi, DWORD PTR l_nChannels
	mov	ecx, DWORD PTR ppBuffer

	mov	ebx, DWORD PTR dwI
	sub	ecx, 4
}
#define ONE_CHANNEL_VOLUME(dwJ) \
	_asm { mov	eax, DWORD PTR vfVFract[(dwJ-1)*4] }; \
	_asm { add	eax, DWORD PTR [esi+(dwJ-1)*4] }; \
	_asm { mov	DWORD PTR vfVFract[(dwJ-1)*4], eax }; \
	_asm { sar	eax, 8 }; \
    _asm { lea  edx, vfVolume }; \
	_asm { mov	DWORD PTR [edx + (dwJ-1)*4], eax };

    //-------------------------------------------------------------------------
    //
    //          ***** ***** ***** DO NOT CHANGE THIS! ***** ***** *****
    //
    // This lovely hack makes sure that all the instructions
    // are the same length for the case (dwJ - 1) == 0. Code depends on this
    // by calculating instruction offsets based on having 8 identical blocks.
    //
    //          ***** ***** ***** DO NOT CHANGE THIS! ***** ***** *****
    //
    //-------------------------------------------------------------------------
#define ONE_CHANNEL_VOLUME_1 \
	_asm { mov	eax, DWORD PTR vfVFract[0] }; \
    _asm _emit 0x03 _asm _emit 0x46 _asm _emit 0x00 \
	_asm { mov	DWORD PTR vfVFract[0], eax }; \
	_asm { sar	eax, 8 }; \
    _asm { lea  edx, vfVolume }; \
	_asm { mov	DWORD PTR [edx], eax };

$L43851:
	ONE_CHANNEL_VOLUME(8)
$L43853:
	ONE_CHANNEL_VOLUME(7);
	ONE_CHANNEL_VOLUME(6);
	ONE_CHANNEL_VOLUME(5);
	ONE_CHANNEL_VOLUME(4);
	ONE_CHANNEL_VOLUME(3);
	ONE_CHANNEL_VOLUME(2);
	ONE_CHANNEL_VOLUME_1;
#undef ONE_CHANNEL_VOLUME
#undef ONE_CHANNEL_VOLUME_1
$L43860:
_asm {
; 304  : 		DWORD a = (pfSampleLength - pfSamplePos + pfPitch - 1) / pfPitch;

	mov	esi, DWORD PTR pfPitch
	mov	eax, DWORD PTR pfSampleLength

	dec	esi
	sub	eax, DWORD PTR pfSamplePos

	add	eax, esi
	cdq
	idiv	DWORD PTR pfPitch

	mov	edx, DWORD PTR dwLength
	sub	edx, ebx

	cmp	edx, eax
	jae	SHORT $L43863
	mov	eax, edx

$L43863:
	mov	edx, DWORD PTR dwIncDelta
	cmp	edx, eax
	jae	SHORT $L43864
	mov	eax, edx

$L43864:

; 309  : 
; 310  : 		for (a += dwI; dwI < a; dwI++)

	inc	edx

	sub	edx, eax
	add	eax, ebx

	mov	DWORD PTR dwIncDelta, edx
	cmp	ebx, eax

	mov	DWORD PTR a, eax
	jae	$L43867

#ifdef USE_MMX // {
	// Try to handle two positions at once.

	lea	edx, [eax-3]
	cmp	ebx, edx
	jge	$L43865

	jmp	UseMmx

UseMmxLabel:
	//	Ok, there are at least two samples to handle.

	movd		mm1, DWORD PTR pfPitch
	psllq		mm1, 32						// Pitch,				0
	movd		mm2, DWORD PTR pfSamplePos
	punpckldq	mm2, mm2					// SamplePos,			SamplePos
	paddd		mm2, mm1					// SamplePos + Pitch,	SamplePos
	punpckhdq	mm1, mm1					// Pitch,				Pitch
	pslld		mm1, 1						// Pitch * 2,			Pitch * 2

	mov			eax, DWORD PTR pcWave
#if 0
    movq        mm4, QWORD PTR vfVolume
    pand        mm4, QWORD PTR ffffMask
    movq        mm5, mm4
    pslld       mm4, 16
    por         mm4, mm5
    psllw       mm4, 3
    movq        QWORD PTR MmxVolume, mm4
#endif
	
TwoAtATime:

;					dwPosition = pfSamplePos >> 12;
;					dwFract = pfSamplePos & 0xFFF;
;					pfSamplePos += pfPitch;

	movq		mm4, mm2
	psrad		mm4, 12				// dwPosition + Pitch,	dwPosition

;					lA = (long) pcWave[dwPosition];
;					lMInterp = (((pcWave[dwPosition+1] - lA) * (dwFract)) >> 12) + lA;

	movd		esi, mm4						// dwPosition
	punpckhdq	mm4, mm4						// dwPosition ( + Pitch ) = dwPos2
	movd		mm5, DWORD PTR [eax+esi*2]		// 0, 0, dwPosition + 1, dwPosition
//	Instead for byte codes
//	mov			si, WORD PTR [eax+esi]
//	movd		mm6, esi
//	punpcklbw	mm5, mm6
//	psarw		mm5, 8
	movd		esi, mm4
	movd		mm4, DWORD PTR [eax+esi*2]		// 0, 0, dwPos2 + 1, dwPos2
//	Instead for byte codes
//	mov			si, WORD PTR [eax+esi]
//	movd		mm6, esi
//	punpcklbw	mm4, mm6
//	psarw		mm4, 8
//	This code could be combined with code above, a bit.

	punpckldq	mm5, mm4						// dwPos2 + 1, dwPos2, dwPos1 + 1, dwPos1
	movq		mm4, mm2
	pand		mm4, QWORD PTR fffMask				// dwFract + Pitch,		dwFract
	packssdw	mm4, mm0
	movq		mm6, mm3
	psubw		mm6, mm4							// 0, 0, 1000 - dwFract + Pitch, 1000 - dwFract
	punpcklwd	mm6, mm4
	paddd		mm2, mm1			                // Next iteration
	pmaddwd		mm6, mm5
#if 1
	movq		mm5, QWORD PTR vfVolume 			//	Volume2, Volume1
	psrad		mm6, 12								// lMIntrep2, lMInterp
//	pand		mm6, QWORD PTR ffffMask
//	pand    	mm5, QWORD PTR ffffMask			//	16 bits only.

	movq		mm4, mm5
	mov	esi, DWORD PTR [ecx+4]

	punpckldq	mm4, mm4
	pmaddwd		mm4, mm6
	psrad		mm4, 13
	packssdw	mm4, mm0

	movd		mm7, DWORD PTR [esi+ebx*2]
	paddsw		mm7, mm4
	movd		DWORD PTR [esi+ebx*2], mm7

	//	CHANNEL 2

	punpckhdq	mm5, mm5						// 0, Volume2,   0, Volume2
	mov	esi, DWORD PTR [ecx+8]

	pmaddwd		mm5, mm6
	psrad		mm5, 13
	packssdw	mm5, mm0

	movd		mm7, DWORD PTR [esi+ebx*2]
	paddsw		mm7, mm5
	movd		DWORD PTR [esi+ebx*2], mm7

#else           // There is noise here, probably due to the signed nature of the multiply.
	psrad		mm6, 12								// lMIntrep2, lMInterp
    movq        mm5, QWORD PTR MmxVolume
    packssdw    mm6, mm0
    punpckldq   mm6, mm6
    pmulhw      mm6, mm5
	mov	esi, DWORD PTR [ecx+4]
	movd		mm7, DWORD PTR [esi+ebx*2]
	mov	esi, DWORD PTR [ecx+8]
	movd		mm4, DWORD PTR [esi+ebx*2]
    punpckldq   mm4, mm7
    paddsw      mm4, mm6
    movd        DWORD PTR [esi+ebx*2], mm4
    punpckhdq   mm4, mm4
	mov	esi, DWORD PTR [ecx+4]
    movd        DWORD PTR [esi+ebx*2], mm4

#endif

	add	ebx, 2

	cmp	ebx, edx
	jb	TwoAtATime

	movd	DWORD PTR pfSamplePos, mm2
#endif  // }


$L43865:

;					dwPosition = pfSamplePos >> 12;
;					dwFract = pfSamplePos & 0xFFF;
;					pfSamplePos += pfPitch;
;					lA = (long) pcWave[dwPosition];
;					lMInterp = (((pcWave[dwPosition+1] - lA) * dwFract) >> 12) + lA;

	mov	esi, DWORD PTR pfPitch
	mov	edx, DWORD PTR pfSamplePos

	mov	eax, DWORD PTR pcWave
	mov	edi, edx

	add	esi, edx
	and	edi, 4095

	sar	edx, 12
	mov	DWORD PTR pfSamplePos, esi

	movsx	esi, WORD PTR [eax+edx*2]
	movsx	eax, WORD PTR [eax+edx*2+2]

	sub	eax, esi

	imul	eax, edi

	sar	eax, 12
	mov	edi, One_Channel_2

	//	ebx, ecx, edx are used in switch branches

	add	eax, esi		// lMInterp
	jmp	edi

// ONE_CHANNEL
//          lM = lMInterp * vfVolume[dwJ - 1];
//          lM >>= 13;
//			ppBuffer[dwJ - 1][dwI] += (short) lM;

$L44009:

; 342  : 			default:
; 343  : 				for (dwJ = l_nChannels; dwJ > 8; dwJ--)

	mov	edi, DWORD PTR l_nChannels

	//	ecx ppBuffer
	//	eax lMInterp
	//	edi counter
	//	ebx dwI

$L43874:
	mov	edx, DWORD PTR vfVolume[edi*4-4]
	mov	esi, DWORD PTR [ecx+edi*4]			// ppBuffer[dwJ - 1]

	imul	edx, eax
	sar	edx, 13
	add	WORD PTR [esi+ebx*2], dx

	jno	no_overflow
	mov	WORD PTR [esi+ebx*2], 0x7fff
	js	no_overflow
	mov	WORD PTR [esi+ebx*2], 0x8000

no_overflow:
	dec	edi
	cmp	edi, 8
	jne	SHORT $L43874

	lea	edi, $L43876
}

#define ONE_CHANNEL_VOLUME(dwJ) \
    _asm { lea  edx, vfVolume } \
	_asm { mov	edx, DWORD PTR [edx + (dwJ-1) * 4] } \
	_asm { mov	esi, DWORD PTR [ecx + (dwJ) * 4] } \
	_asm { imul	edx, eax } \
	_asm { sar	edx, 13 } \
	_asm { add	edi, [esp] } \
	\
	_asm { add	WORD PTR [esi+ebx*2], dx } \
	_asm { jo	FAR overflow_x } 

    //-------------------------------------------------------------------------
    //
    //          ***** ***** ***** DO NOT CHANGE THIS! ***** ***** *****
    //
    // This lovely hack makes sure that all the instructions
    // are the same length for the case (dwJ - 1) == 0. Code depends on this
    // by calculating instruction offsets based on having 8 identical blocks.
    //
    //          ***** ***** ***** DO NOT CHANGE THIS! ***** ***** *****
    //
    //-------------------------------------------------------------------------

#define ONE_CHANNEL_VOLUME_1 \
    _asm { lea  edx, vfVolume } \
    _asm _emit 0x8B _asm _emit 0x52 _asm _emit 0x00 \
	_asm { mov	esi, DWORD PTR [ecx + 4] } \
	_asm { imul	edx, eax } \
	_asm { sar	edx, 13 } \
	_asm { add	edi, [esp] } \
	\
	_asm { add	WORD PTR [esi+ebx*2], dx } \
	_asm { jo	FAR overflow_x } 

$L43876:
	ONE_CHANNEL_VOLUME(8);
$L43880:
	ONE_CHANNEL_VOLUME(7);
	ONE_CHANNEL_VOLUME(6);
	ONE_CHANNEL_VOLUME(5);
	ONE_CHANNEL_VOLUME(4);
	ONE_CHANNEL_VOLUME(3);
	ONE_CHANNEL_VOLUME(2);
	ONE_CHANNEL_VOLUME_1;
#undef ONE_CHANNEL_VOLUME
#undef ONE_CHANNEL_VOLUME_1
$L43866:
_asm {
	mov	eax, DWORD PTR a
	inc	ebx

	cmp	ebx, eax
	jb	$L43865

	mov	edi, DWORD PTR l_nChannels
$L43867:
	cmp	ebx, DWORD PTR dwLength
	jb	$L44021
Exit_$L43841:
	pop eax
	mov	DWORD PTR dwI, ebx

#ifdef USE_MMX
    mov edi, UseMmx
    cmp edi, UseMmxLabel
    jne NoMmxCleanupLabel

	emms
NoMmxCleanupLabel:
#endif
}
#else // }{
    for (dwI = 0; dwI < dwLength;)
    {
        if (pfSamplePos >= pfSampleLength)
	    {	
	        if (pfLoopLength)
    		    pfSamplePos -= pfLoopLength;
	        else
	    	    break;
	    }
        dwIncDelta--;
        if (!dwIncDelta)   
        {
            dwIncDelta = dwDeltaPeriod;
            pfPFract += pfDeltaPitch;
            pfPitch = pfPFract >> 8;

#if 1
#define ONE_CHANNEL_VOLUME(dwJ) \
			vfVFract[dwJ - 1] += vfDeltaVolume[dwJ - 1]; \
			vfVolume[dwJ - 1]  = vfVFract     [dwJ - 1] >> 8;

			switch (l_nChannels)
			{
			default:
				for (dwJ = l_nChannels; dwJ > 8; dwJ--)
				{
					ONE_CHANNEL_VOLUME(dwJ);
				}
			case 8: ONE_CHANNEL_VOLUME(8);
			case 7: ONE_CHANNEL_VOLUME(7);
			case 6: ONE_CHANNEL_VOLUME(6);
			case 5: ONE_CHANNEL_VOLUME(5);
			case 4: ONE_CHANNEL_VOLUME(4);
			case 3: ONE_CHANNEL_VOLUME(3);
			case 2: ONE_CHANNEL_VOLUME(2);
			case 1: ONE_CHANNEL_VOLUME(1);
			case 0:;
			}
#undef ONE_CHANNEL_VOLUME
#else
            for (dwJ = 0; dwJ < l_nChannels; dwJ++)
            {
                vfVFract[dwJ] += vfDeltaVolume[dwJ];
                vfVolume[dwJ] = vfVFract[dwJ] >> 8;
            }
#endif
        }

#if 1 // {
		DWORD a = (pfSampleLength - pfSamplePos + pfPitch - 1) / pfPitch;
		DWORD b = dwLength - dwI;

		if (b < a) a = b;
		if (dwIncDelta < a) a = dwIncDelta;

		dwIncDelta -= a - 1;
		a          += dwI;

		for (; dwI < a; dwI++)
		{
			dwPosition = pfSamplePos >> 12;
			dwFract = pfSamplePos & 0xFFF;
			pfSamplePos += pfPitch;

			lA = (long) pcWave[dwPosition];
			lMInterp = (((pcWave[dwPosition+1] - lA) * dwFract) >> 12) + lA;
#if 1 // {
#if 1
#define ONE_CHANNEL_VOLUME(dwJ) \
		{ \
            lM = lMInterp * vfVolume[dwJ - 1]; \
            lM >>= 13; \
			ppBuffer[dwJ - 1][dwI] += (short) lM;\
			long b = ppBuffer[dwJ - 1][dwI]; \
			if ((short)b != b) { \
				if ((long)b < 0) b = 0x8000; \
				else b = 0x7fff; \
				ppBuffer[dwJ - 1][dwI] = (short) b; \
			} \
 		}
#else
#define ONE_CHANNEL_VOLUME(dwJ) \
		{ \
            lM = lMInterp * vfVolume[dwJ - 1]; \
            lM >>= 13; \
			ppBuffer[dwJ - 1][dwI] += (short) lM;\
 		}
#endif
			switch (l_nChannels)
			{
			default:
				for (dwJ = l_nChannels; dwJ > 8; dwJ--)
				{
					ONE_CHANNEL_VOLUME(dwJ);
				}
			case 8: ONE_CHANNEL_VOLUME(8);
			case 7: ONE_CHANNEL_VOLUME(7);
			case 6: ONE_CHANNEL_VOLUME(6);
			case 5: ONE_CHANNEL_VOLUME(5);
			case 4: ONE_CHANNEL_VOLUME(4);
			case 3: ONE_CHANNEL_VOLUME(3);
			case 2: ONE_CHANNEL_VOLUME(2);
			case 1: ONE_CHANNEL_VOLUME(1);
			case 0:;
			}
#undef ONE_CHANNEL_VOLUME
#else // }{
			for (dwJ = 0; dwJ < l_nChannels; dwJ++)
			{
				lM = lMInterp * vfVolume[dwJ]; 
				lM >>= 13;         // Signal bumps up to 12 bits.

				// Keep this around so we can use it to generate new assembly code (see below...)
#if 1
			{
			long x = ppBuffer[dwJ][dwI];
			
			x += lM;

			if (x != (short)x) {
				if (x > 32767) x = 32767;
				else  x = -32768;
			}

			ppBuffer[dwJ][dwI] = (short)x;
			}
#else
				ppBuffer[dwJ][dwI] += (short) lM;
				_asm{jno no_oflow}
				ppBuffer[dwJ][dwI] = 0x7fff;
				_asm{js  no_oflow}
				ppBuffer[dwJ][dwI] = (short) 0x8000;
no_oflow:	;
#endif
			}
#endif // }
		}
#else // }{
        dwPosition = pfSamplePos >> 12;
        dwFract = pfSamplePos & 0xFFF;
        pfSamplePos += pfPitch;

        lA = (long) pcWave[dwPosition];
        lMInterp = (((pcWave[dwPosition+1] - lA) * dwFract) >> 12) + lA;
#if 1
#if 1
#define ONE_CHANNEL_VOLUME(dwJ) \
		{ \
            lM = lMInterp * vfVolume[dwJ - 1]; \
            lM >>= 13; \
			ppBuffer[dwJ - 1][dwI] += (short) lM;\
			long b = ppBuffer[dwJ - 1][dwI]; \
			if ((short)b != b) { \
				if ((long)b < 0) b = 0x8000; \
				else b = 0x7fff; \
				ppBuffer[dwJ - 1][dwI] = (short) b; \
			} \
 		}
#else
#define ONE_CHANNEL_VOLUME(dwJ) \
		{ \
            lM = lMInterp * vfVolume[dwJ - 1]; \
            lM >>= 13; \
			ppBuffer[dwJ - 1][dwI] += (short) lM;\
 		}
#endif
			switch (l_nChannels)
			{
			default:
				for (dwJ = l_nChannels; dwJ > 8; dwJ--)
				{
					ONE_CHANNEL_VOLUME(dwJ);
				}
			case 8: ONE_CHANNEL_VOLUME(8);
			case 7: ONE_CHANNEL_VOLUME(7);
			case 6: ONE_CHANNEL_VOLUME(6);
			case 5: ONE_CHANNEL_VOLUME(5);
			case 4: ONE_CHANNEL_VOLUME(4);
			case 3: ONE_CHANNEL_VOLUME(3);
			case 2: ONE_CHANNEL_VOLUME(2);
			case 1: ONE_CHANNEL_VOLUME(1);
			case 0:;
			}
#undef ONE_CHANNEL_VOLUME
#else
        for (dwJ = 0; dwJ < l_nChannels; dwJ++)
        {
            lM = lMInterp * vfVolume[dwJ]; 
            lM >>= 13;         // Signal bumps up to 12 bits.

            // Keep this around so we can use it to generate new assembly code (see below...)
#if 1
			{
			long x = ppBuffer[dwJ][dwI];
			
			x += lM;

			if (x != (short)x) {
				if (x > 32767) x = 32767;
				else  x = -32768;
			}

			ppBuffer[dwJ][dwI] = (short)x;
			}
#else
            ppBuffer[dwJ][dwI] += (short) lM;
            _asm{jno no_oflow}
            ppBuffer[dwJ][dwI] = 0x7fff;
            _asm{js  no_oflow}
            ppBuffer[dwJ][dwI] = (short) 0x8000;
no_oflow:	;
#endif
        }
#endif
		dwI++;
#endif // }
    }
#endif // }

    m_pfLastPitch = pfPitch;
    m_pfLastSample = pfSamplePos;

    for (dwJ = 0; dwJ < dwBufferCount; dwJ++)
    {
        vfLastVolume[dwJ] = vfVolume[dwJ];
    }

    return (dwI);
}
#endif

DWORD CDigitalAudio::MixMulti16Filter(
    short *ppBuffer[], 
	DWORD dwBufferCount,
    DWORD dwLength, 
    DWORD dwDeltaPeriod, 
    VFRACT vfDeltaVolume[], 
	VFRACT vfLastVolume[], 
    PFRACT pfDeltaPitch, 
    PFRACT pfSampleLength, 
    PFRACT pfLoopLength,
    COEFF cfdK,
    COEFF cfdB1,
    COEFF cfdB2)
{
    DWORD dwI, dwJ;
    DWORD dwPosition;
    long lA;//, lB;
    long lM;
    long lMInterp;
    DWORD dwIncDelta = dwDeltaPeriod;
    VFRACT dwFract;
    short * pcWave = m_pnWave;
    PFRACT pfSamplePos = m_pfLastSample;
    PFRACT pfPitch = m_pfLastPitch;
    PFRACT pfPFract = pfPitch << 8;
    COEFF cfK  = m_cfLastK;
    COEFF cfB1 = m_cfLastB1;
    COEFF cfB2 = m_cfLastB2;
	DWORD dMM6[2];					// Handle filter...
	DWORD dMM4[2];					// Handle filter...
	DWORD dMM5[2];					// Handle filter...
    
    VFRACT vfVolume[MAX_DAUD_CHAN]; // = m_vfLastLVolume;
    VFRACT vfVFract[MAX_DAUD_CHAN]; // = vfVolume << 8;  // Keep high res version around. 

    for (dwI = 0; dwI < dwBufferCount; dwI++)
    {
        vfVolume[dwI] = vfLastVolume[dwI];
        vfVFract[dwI] = vfVolume[dwI] << 8;
    }    

#if 1 // {
	DWORD l_nChannels = dwBufferCount;
	DWORD a;
	DWORD One_Channel_1, One_Channel_2;	// Code address locations.
	long l_lPrevPrevSample = m_lPrevPrevSample, l_lPrevSample = m_lPrevSample;

#ifdef USE_MMX_FILTERED // {
	typedef __int64 QWORD;
	QWORD	OneMask	 = 0x0000000010001000;
	QWORD	fffMask  = 0x00000fff00000fff;
	QWORD	ffffMask = 0x0000ffff0000ffff;
	DWORD	UseMmx;
    DWORD   MmxVolume[2];
	int		Use_MMX = m_sfMMXEnabled;

	_asm {
    lea edi, $L43865

    // Turned off
	cmp	Use_MMX, 0
	je	AssignMMXLabel

    // != 2 channels
	mov	esi, DWORD PTR l_nChannels
	cmp	esi, 2
	jne	AssignMmxLabel

    // Ok, init and use MMX
	lea	edi, UseMmxLabel

	pxor		mm0, mm0
	movq		mm3, QWORD PTR OneMask		// 0, 0, 0x1000, 0x1000

AssignMmxLabel:
	mov	DWORD PTR UseMmx, edi
}
#endif // }

	_asm {
	mov	edi, DWORD PTR l_nChannels

	cmp	edi, 8
	jna	Start1

	lea	esi, $L44008
	jmp Do_One_Channel_2

	// Put this code more than 127 bytes away from the references.

overflow_x:
	js	overflow_y
	mov	WORD PTR [esi+ebx*2], 0x8000
	jmp	edi

overflow_y:
	mov	WORD PTR [esi+ebx*2], 0x7fff
	jmp	edi

Start1:	
	test	edi, edi
	jne	Start2

	lea	esi, $L43860
	jmp	Do_One_Channel_2

Start2:
	lea	eax, $L43851
	lea	edx, $L43853

	sub	edx, eax
	mov	esi, 8

	sub	esi, edi
	imul	esi, edx
	add	esi, eax

Do_One_Channel_2:
	mov	DWORD PTR One_Channel_1, esi

	//	Create second jump table location.
	
	lea	esi, $L43876
	lea	ecx, $L43880

	sub	ecx, esi

	push ecx				// Span between branches.

	mov	eax, 8
	sub	eax, DWORD PTR l_nChannels

	jge		Start3
	
	lea	ecx, $L44009
	jmp	Done_Do_Channel_2

Start3:
	cmp	eax, 8
	jne	Start4

	lea	ecx, $L43866
	jmp	Done_Do_Channel_2

Start4:
	imul	ecx, eax
	add		ecx, esi

Done_Do_Channel_2:
	mov	DWORD PTR One_Channel_2, ecx


	mov	ecx, DWORD PTR dwLength
	xor	ebx, ebx					// dwI

	test	ecx, ecx
	jbe	Exit_$L43841

	mov	ecx, DWORD PTR ppBuffer
	sub	ecx, 4

	//	ecx == ppBuffer - 4
	//	ebx == dwI
	//	edi == l_nChannels
$L44021:

	mov	edx, DWORD PTR pfSamplePos
	cmp	edx, DWORD PTR pfSampleLength
	jl	SHORT $L43842

	mov	eax, DWORD PTR pfLoopLength
	test	eax, eax
	je	Exit_$L43841

	sub	edx, eax
	mov	DWORD PTR pfSamplePos, edx

$L43842:
	mov	edx, DWORD PTR dwIncDelta
	mov	eax, DWORD PTR pfPFract

	dec	edx

	mov	DWORD PTR dwIncDelta, edx
	jne	$L43860

	mov	edx, DWORD PTR dwDeltaPeriod
	mov	esi, DWORD PTR pfDeltaPitch

	mov	DWORD PTR dwIncDelta, edx
	add	eax, esi

	mov	DWORD PTR pfPFract, eax

	sar	eax, 8
	mov	DWORD PTR pfPitch, eax

	mov	esi, DWORD PTR vfDeltaVolume
	jmp	One_Channel_1

// ONE_CHANNEL
//			vfVFract[dwJ - 1] += vfDeltaVolume[dwJ - 1];
//			vfVolume[dwJ - 1]  = vfVFract     [dwJ - 1] >> 8;

$L44008:

	mov	DWORD PTR dwI, ebx
	lea	ebx, DWORD PTR [edi*4-4]
	add	edi, -8					; fffffff8H
$L43849:

	lea	eax, DWORD PTR vfVFract[ebx]
	mov	ecx, DWORD PTR [esi+ebx]
	sub	ebx, 4
	add	DWORD PTR [eax], ecx
	mov	eax, DWORD PTR [eax]
	sar	eax, 8
	mov	DWORD PTR vfVolume[ebx+4], eax
	dec	edi
	jne	SHORT $L43849

	mov	edi, DWORD PTR l_nChannels
	mov	ecx, DWORD PTR ppBuffer

	mov	ebx, DWORD PTR dwI
	sub	ecx, 4
}
#define ONE_CHANNEL_VOLUME(dwJ) \
	_asm { mov	eax, DWORD PTR vfVFract[(dwJ-1)*4] }; \
	_asm { add	eax, DWORD PTR [esi+(dwJ-1)*4] }; \
	_asm { mov	DWORD PTR vfVFract[(dwJ-1)*4], eax }; \
	_asm { sar	eax, 8 }; \
    _asm { lea  edx, vfVolume }; \
	_asm { mov	DWORD PTR [edx + (dwJ-1)*4], eax };

    //-------------------------------------------------------------------------
    //
    //          ***** ***** ***** DO NOT CHANGE THIS! ***** ***** *****
    //
    // This lovely hack makes sure that all the instructions
    // are the same length for the case (dwJ - 1) == 0. Code depends on this
    // by calculating instruction offsets based on having 8 identical blocks.
    //
    //          ***** ***** ***** DO NOT CHANGE THIS! ***** ***** *****
    //
    //-------------------------------------------------------------------------

#define ONE_CHANNEL_VOLUME_1 \
	_asm { mov	eax, DWORD PTR vfVFract[0] }; \
    _asm _emit 0x03 _asm _emit 0x46 _asm _emit 0x00 \
	_asm { mov	DWORD PTR vfVFract[0], eax }; \
	_asm { sar	eax, 8 }; \
    _asm { lea  edx, vfVolume }; \
    _asm _emit 0x89 _asm _emit 0x42 _asm _emit 0x00

$L43851:
	ONE_CHANNEL_VOLUME(8)
$L43853:
	ONE_CHANNEL_VOLUME(7);
	ONE_CHANNEL_VOLUME(6);
	ONE_CHANNEL_VOLUME(5);
	ONE_CHANNEL_VOLUME(4);
	ONE_CHANNEL_VOLUME(3);
	ONE_CHANNEL_VOLUME(2);
	ONE_CHANNEL_VOLUME_1;
#undef ONE_CHANNEL_VOLUME
#undef ONE_CHANNEL_VOLUME_1

_asm {
	//	cfK += cfdK;
	//	cfB1 += cfdB1;
	//	cfB2 += cfdB2;

	mov	eax, DWORD PTR cfdK
	mov	edx, DWORD PTR cfdB1
	
	mov	esi, DWORD PTR cfdB2
	add	DWORD PTR cfK, eax

	add DWORD PTR cfB1, edx
	add	DWORD PTR cfB2, esi

$L43860:
; 304  : 		DWORD a = (pfSampleLength - pfSamplePos + pfPitch - 1) / pfPitch;

	mov	esi, DWORD PTR pfPitch
	mov	eax, DWORD PTR pfSampleLength

	dec	esi
	sub	eax, DWORD PTR pfSamplePos

	add	eax, esi
	cdq
	idiv	DWORD PTR pfPitch

	mov	edx, DWORD PTR dwLength
	sub	edx, ebx

	cmp	edx, eax
	jae	SHORT $L43863
	mov	eax, edx

$L43863:
	mov	edx, DWORD PTR dwIncDelta
	cmp	edx, eax
	jae	SHORT $L43864
	mov	eax, edx

$L43864:

; 309  : 
; 310  : 		for (a += dwI; dwI < a; dwI++)

	inc	edx

	sub	edx, eax
	add	eax, ebx

	mov	DWORD PTR dwIncDelta, edx
	cmp	ebx, eax

	mov	DWORD PTR a, eax
	jae	$L43867

#ifdef USE_MMX_FILTERED // {
	// Try to handle two positions at once.

	lea	edx, [eax-3]
	cmp	ebx, edx
	jge	$L43865

	jmp	UseMmx

UseMmxLabel:
	//	Ok, there are at least two samples to handle.

	movd		mm1, DWORD PTR pfPitch
	psllq		mm1, 32						// Pitch,				0
	movd		mm2, DWORD PTR pfSamplePos
	punpckldq	mm2, mm2					// SamplePos,			SamplePos
	paddd		mm2, mm1					// SamplePos + Pitch,	SamplePos
	punpckhdq	mm1, mm1					// Pitch,				Pitch
	pslld		mm1, 1						// Pitch * 2,			Pitch * 2

	mov			eax, DWORD PTR pcWave
#if 0
    movq        mm4, QWORD PTR vfVolume
    pand        mm4, QWORD PTR ffffMask
    movq        mm5, mm4
    pslld       mm4, 16
    por         mm4, mm5
    psllw       mm4, 3
    movq        QWORD PTR MmxVolume, mm4
#endif
	
TwoAtATime:

;					dwPosition = pfSamplePos >> 12;
;					dwFract = pfSamplePos & 0xFFF;
;					pfSamplePos += pfPitch;

	movq		mm4, mm2
	psrad		mm4, 12				// dwPosition + Pitch,	dwPosition

;					lA = (long) pcWave[dwPosition];
;					lMInterp = (((pcWave[dwPosition+1] - lA) * (dwFract)) >> 12) + lA;

	movd		esi, mm4						// dwPosition
	punpckhdq	mm4, mm4						// dwPosition ( + Pitch ) = dwPos2
	movd		mm5, DWORD PTR [eax+esi*2]		// 0, 0, dwPosition + 1, dwPosition
//	Instead for byte codes
//	mov			si, WORD PTR [eax+esi]
//	movd		mm6, esi
//	punpcklbw	mm5, mm6
//	psarw		mm5, 8
	movd		esi, mm4
	movd		mm4, DWORD PTR [eax+esi*2]		// 0, 0, dwPos2 + 1, dwPos2
//	Instead for byte codes
//	mov			si, WORD PTR [eax+esi]
//	movd		mm6, esi
//	punpcklbw	mm4, mm6
//	psarw		mm4, 8
//	This code could be combined with code above, a bit.

	punpckldq	mm5, mm4						// dwPos2 + 1, dwPos2, dwPos1 + 1, dwPos1
	movq		mm4, mm2
	pand		mm4, QWORD PTR fffMask				// dwFract + Pitch,		dwFract
	packssdw	mm4, mm0
	movq		mm6, mm3
	psubw		mm6, mm4							// 0, 0, 1000 - dwFract + Pitch, 1000 - dwFract
	punpcklwd	mm6, mm4
	paddd		mm2, mm1			                // Next iteration
	pmaddwd		mm6, mm5
#if 1 // {
	psrad		mm6, 12								// lMIntrep2, lMInterp

#if 1 // {
	//	eax, ebx, ecx, edx, esi are used.	edi is free...
	push	eax
	push	ecx
	push	edx

	movq	QWORD PTR dMM6, mm6

	mov		eax, DWORD PTR dMM6
	imul	DWORD PTR cfK		// edx:eax
	
	mov		ecx, eax
	mov		eax, DWORD PTR l_lPrevPrevSample

	mov		edi, edx			// esi:ecx
	imul	DWORD PTR cfB2

	sub		ecx, eax
	mov		eax, DWORD PTR l_lPrevSample

	sbb		edi, edx
	mov		DWORD PTR l_lPrevPrevSample, eax

	imul	DWORD PTR cfB1

	add		eax, ecx
	adc		edx, edi

//>>>>> MOD:PETCHEY 
//	shld	eax, edx, 2
//>>>>> should be 
	shld	edx, eax, 2
	mov		eax, edx

	mov	DWORD PTR dMM6, eax
	mov	DWORD PTR l_lPrevSample, eax

	//	2nd sample

	mov		eax, DWORD PTR dMM6+4
	imul	DWORD PTR cfK		// edx:eax
	
	mov		ecx, eax
	mov		eax, DWORD PTR l_lPrevPrevSample

	mov		edi, edx			// esi:ecx
	imul	DWORD PTR cfB2

	sub		ecx, eax
	mov		eax, DWORD PTR l_lPrevSample

	sbb		edi, edx
	mov		DWORD PTR l_lPrevPrevSample, eax

	imul	DWORD PTR cfB1

	add		eax, ecx
	adc		edx, edi

//>>>>> MOD:PETCHEY 
//	shld	eax, edx, 2
//>>>>> should be 
	shld	edx, eax, 2
	mov		eax, edx

	mov	DWORD PTR dMM6+4, eax
	mov	DWORD PTR l_lPrevSample, eax

	movq	mm6, QWORD PTR dMM6

	pop		edx
	pop		ecx
	pop		eax
#endif // }

#define DO_32BIT_MULTIPLY
#ifndef DO_32BIT_MULTIPLY
	movq		mm5, QWORD PTR vfVolume 			//	Volume2, Volume1
//	pand    	mm5, QWORD PTR ffffMask			//	16 bits only.
#endif

//	pand		mm6, QWORD PTR ffffMask

#ifndef DO_32BIT_MULTIPLY
	movq		mm4, mm5
#endif
	mov	esi, DWORD PTR [ecx+4]

#ifndef DO_32BIT_MULTIPLY
	punpckldq	mm4, mm4
#endif

#ifdef DO_32BIT_MULTIPLY
	mov			edi, DWORD PTR vfVolume
	imul		edi, DWORD PTR dMM6
	sar			edi, 13
	mov			DWORD PTR dMM4, edi

	mov			edi, DWORD PTR vfVolume
	imul		edi, DWORD PTR dMM6+4
	sar			edi, 13
	mov			DWORD PTR dMM4+4, edi

	movq		mm4, QWORD PTR dMM4
#else
	pmaddwd		mm4, mm6
	psrad		mm4, 13
#endif

	packssdw	mm4, mm0

	movd		mm7, DWORD PTR [esi+ebx*2]
	paddsw		mm7, mm4
	movd		DWORD PTR [esi+ebx*2], mm7

	//	CHANNEL 2


#ifndef DO_32BIT_MULTIPLY
	punpckhdq	mm5, mm5						// 0, Volume2,   0, Volume2
#endif
	mov	esi, DWORD PTR [ecx+8]

#ifdef DO_32BIT_MULTIPLY
	mov			edi, DWORD PTR vfVolume+4
	imul		edi, DWORD PTR dMM6
	sar			edi, 13
	mov			DWORD PTR dMM5, edi

	mov			edi, DWORD PTR vfVolume+4
	imul		edi, DWORD PTR dMM6+4
	sar			edi, 13
	mov			DWORD PTR dMM5+4, edi

	movq		mm5, QWORD PTR dMM5
#else
	pmaddwd		mm5, mm6
	psrad		mm5, 13
#endif
	packssdw	mm5, mm0

	movd		mm7, DWORD PTR [esi+ebx*2]
	paddsw		mm7, mm5
	movd		DWORD PTR [esi+ebx*2], mm7

#else           // }{ There is noise here, probably due to the signed nature of the multiply.

	// NOTE the filter is NOT implemented here....

	psrad		mm6, 12								// lMIntrep2, lMInterp
    movq        mm5, QWORD PTR MmxVolume
    packssdw    mm6, mm0
    punpckldq   mm6, mm6
    pmulhw      mm6, mm5
	mov	esi, DWORD PTR [ecx+4]
	movd		mm7, DWORD PTR [esi+ebx*2]
	mov	esi, DWORD PTR [ecx+8]
	movd		mm4, DWORD PTR [esi+ebx*2]
    punpckldq   mm4, mm7
    paddsw      mm4, mm6
    movd        DWORD PTR [esi+ebx*2], mm4
    punpckhdq   mm4, mm4
	mov	esi, DWORD PTR [ecx+4]
    movd        DWORD PTR [esi+ebx*2], mm4

#endif // }

	add	ebx, 2

	cmp	ebx, edx
	jb	TwoAtATime

	movd	DWORD PTR pfSamplePos, mm2
#endif  // }

$L43865:

;					dwPosition = pfSamplePos >> 12;
;					dwFract = pfSamplePos & 0xFFF;
;					pfSamplePos += pfPitch;
;					lA = (long) pcWave[dwPosition];
;					lMInterp = (((pcWave[dwPosition+1] - lA) * dwFract) >> 12) + lA;

	mov	esi, DWORD PTR pfPitch
	mov	edx, DWORD PTR pfSamplePos

	mov	eax, DWORD PTR pcWave
	mov	edi, edx

	add	esi, edx
	and	edi, 4095

	sar	edx, 12
	mov	DWORD PTR pfSamplePos, esi

	movsx	esi, WORD PTR [eax+edx*2]
	movsx	eax, WORD PTR [eax+edx*2+2]

	sub	eax, esi

	imul	eax, edi

	sar	eax, 12
	mov	edi, One_Channel_2

	//	ebx, ecx, edx are used in switch branches
	add	eax, esi		// lMInterp

#if 1 
//	lMInterp =
//		MulDiv(lMInterp, cfK, (1 << 30))
//		- MulDiv(m_lPrevPrevSample, cfB2, (1 << 30))
//		+ MulDiv(m_lPrevSample, cfB1, (1 << 30))

	push	ecx
	imul	DWORD PTR cfK		// edx:eax
	
	mov		ecx, eax
	mov		eax, DWORD PTR l_lPrevPrevSample

	mov		esi, edx			// esi:ecx
	imul	DWORD PTR cfB2

	sub		ecx, eax
	mov		eax, DWORD PTR l_lPrevSample

	sbb		esi, edx
	mov		DWORD PTR l_lPrevPrevSample, eax

	imul	DWORD PTR cfB1

	add		eax, ecx
//	adc		esi, edx
	adc		edx, esi

	pop		ecx
//	shrd	eax, edx, 30
//	mov		esi,0x40000000
//	idiv	esi

//>>>>> MOD:PETCHEY 
//	shld	eax, edx, 2
//>>>>> should be 
	shld	edx, eax, 2
	mov		eax, edx
#endif
	
//>>>>>>>>>>>> removed dp
#if 0 
//	if (lMInterp < -32767) lMInterp = -32767;
//	else if (lMInterp > 32767) lMInterp = 32767;

	cmp		eax, -32767
	jl		Less_than
	cmp		eax, 32767
	jg		Greater_than
#endif

//	m_lPrevPrevSample = m_lPrevSample;
//	m_lPrevSample = lMInterp;

	mov	DWORD PTR l_lPrevSample, eax
	jmp	edi

//>>>>>>>>>>>> removed dp
#if 0 
Less_than:
	mov	eax, -32767
	mov	DWORD PTR l_lPrevSample, eax
	jmp	edi

Greater_than:
	mov	eax, 32767
	mov	DWORD PTR l_lPrevSample, eax
	jmp	edi
#endif

// ONE_CHANNEL
//          lM = lMInterp * vfVolume[dwJ - 1];
//          lM >>= 13;
//			ppBuffer[dwJ - 1][dwI] += (short) lM;

$L44009:

; 342  : 			default:
; 343  : 				for (dwJ = l_nChannels; dwJ > 8; dwJ--)

	mov	edi, DWORD PTR l_nChannels

	//	ecx ppBuffer
	//	eax lMInterp
	//	edi counter
	//	ebx dwI

$L43874:
	mov	edx, DWORD PTR vfVolume[edi*4-4]
	mov	esi, DWORD PTR [ecx+edi*4]			// ppBuffer[dwJ - 1]

	imul	edx, eax
	sar	edx, 13
	add	WORD PTR [esi+ebx*2], dx

	jno	no_overflow
	mov	WORD PTR [esi+ebx*2], 0x7fff
	js	no_overflow
	mov	WORD PTR [esi+ebx*2], 0x8000

no_overflow:
	dec	edi
	cmp	edi, 8
	jne	SHORT $L43874

	lea	edi, $L43876
}

#define ONE_CHANNEL_VOLUME(dwJ) \
    _asm { lea  edx, vfVolume } \
	_asm { mov	edx, DWORD PTR [edx + (dwJ-1) * 4] } \
	_asm { mov	esi, DWORD PTR [ecx + (dwJ) * 4] } \
	_asm { imul	edx, eax } \
	_asm { sar	edx, 13 } \
	_asm { add	edi, [esp] } \
	\
	_asm { add	WORD PTR [esi+ebx*2], dx } \
	_asm { jo	FAR overflow_x } 


    //-------------------------------------------------------------------------
    //
    //          ***** ***** ***** DO NOT CHANGE THIS! ***** ***** *****
    //
    // This lovely hack makes sure that all the instructions
    // are the same length for the case (dwJ - 1) == 0. Code depends on this
    // by calculating instruction offsets based on having 8 identical blocks.
    //
    //          ***** ***** ***** DO NOT CHANGE THIS! ***** ***** *****
    //
    //-------------------------------------------------------------------------

#define ONE_CHANNEL_VOLUME_1 \
    _asm { lea  edx, vfVolume } \
    _asm _emit 0x8B _asm _emit 0x52 _asm _emit 0x00 \
	_asm { mov	esi, DWORD PTR [ecx + 4] } \
	_asm { imul	edx, eax } \
	_asm { sar	edx, 13 } \
	_asm { add	edi, [esp] } \
	\
	_asm { add	WORD PTR [esi+ebx*2], dx } \
	_asm { jo	FAR overflow_x } 

$L43876:
	ONE_CHANNEL_VOLUME(8);
$L43880:
	ONE_CHANNEL_VOLUME(7);
	ONE_CHANNEL_VOLUME(6);
	ONE_CHANNEL_VOLUME(5);
	ONE_CHANNEL_VOLUME(4);
	ONE_CHANNEL_VOLUME(3);
	ONE_CHANNEL_VOLUME(2);
	ONE_CHANNEL_VOLUME_1;
#undef ONE_CHANNEL_VOLUME
#undef ONE_CHANNEL_VOLUME_1
$L43866:
_asm {
	mov	eax, DWORD PTR a
	inc	ebx

	cmp	ebx, eax
	jb	$L43865

	mov	edi, DWORD PTR l_nChannels
$L43867:
	cmp	ebx, DWORD PTR dwLength
	jb	$L44021
Exit_$L43841:
	pop eax
	mov	DWORD PTR dwI, ebx

#ifdef USE_MMX_FILTERED
    mov edi, UseMmx
    cmp edi, UseMmxLabel
    jne NoMmxCleanupLabel

	emms

NoMmxCleanupLabel:
#endif
}

	m_lPrevPrevSample = l_lPrevPrevSample;
	m_lPrevSample     = l_lPrevSample;
#else // }{
    for (dwI = 0; dwI < dwLength;)
    {
        if (pfSamplePos >= pfSampleLength)
	    {	
	        if (pfLoopLength)
    		    pfSamplePos -= pfLoopLength;
	        else
	    	    break;
	    }
        dwIncDelta--;
        if (!dwIncDelta)   
        {
            dwIncDelta = dwDeltaPeriod;
            pfPFract += pfDeltaPitch;
            pfPitch = pfPFract >> 8;
            for (dwJ = 0; dwJ < dwBufferCount; dwJ++)
            {
                vfVFract[dwJ] += vfDeltaVolume[dwJ];
                vfVolume[dwJ] = vfVFract[dwJ] >> 8;
            }

            cfK += cfdK;
            cfB1 += cfdB1;
           cfB2 += cfdB2;
        }

        dwPosition = pfSamplePos >> 12;
        dwFract = pfSamplePos & 0xFFF;
        pfSamplePos += pfPitch;

        lA = (long) pcWave[dwPosition];
        lMInterp = (((pcWave[dwPosition+1] - lA) * dwFract) >> 12) + lA;

        // Filter
        //
		// z = k*s - b1*z1 - b2*b2
		// We store the negative of b1 in the table, so we flip the sign again by
		// adding here
		//
        lMInterp =
              MulDiv(lMInterp, cfK, (1 << 30))
            + MulDiv(m_lPrevSample, cfB1, (1 << 30))
            - MulDiv(m_lPrevPrevSample, cfB2, (1 << 30));

//>>>>>>>>>>>> removed dp
#if 0 
		if (lMInterp < -32767) lMInterp = -32767;
		else if (lMInterp > 32767) lMInterp = 32767;
#endif
        m_lPrevPrevSample = m_lPrevSample;
        m_lPrevSample = lMInterp;

        for (dwJ = 0; dwJ < dwBufferCount; dwJ++)
        {
            lM = lMInterp * vfVolume[dwJ]; 
            lM >>= 13;         // Signal bumps up to 12 bits.

            // Keep this around so we can use it to generate new assembly code (see below...)
#if 1
			{
			long x = ppBuffer[dwJ][dwI];
			
			x += lM;

			if (x != (short)x) {
				if (x > 32767) x = 32767;
				else  x = -32768;
			}

			ppBuffer[dwJ][dwI] = (short)x;
			}
#else
            ppBuffer[dwJ][dwI] += (short) lM;
            _asm{jno no_oflow}
            ppBuffer[dwJ][dwI] = 0x7fff;
            _asm{js  no_oflow}
            ppBuffer[dwJ][dwI] = (short) 0x8000;
no_oflow:	;
#endif
        }
		dwI++;
    }
#endif // }

    m_pfLastPitch = pfPitch;
    m_pfLastSample = pfSamplePos;

	m_cfLastK = cfK;
	m_cfLastB1 = cfB1;
	m_cfLastB2 = cfB2;

    for (dwJ = 0; dwJ < dwBufferCount; dwJ++)
    {
        vfLastVolume[dwJ] = vfVolume[dwJ];
    }

    return (dwI);
}

#else // }{     all assembly code
DWORD CDigitalAudio::MixMulti8(
    short *ppBuffer[], 
	DWORD dwBufferCount,
    DWORD dwLength, 
    DWORD dwDeltaPeriod, 
    VFRACT vfDeltaVolume[], 
    VFRACT vfLastVolume[], 
    PFRACT pfDeltaPitch, 
    PFRACT pfSampleLength, 
    PFRACT pfLoopLength)
{
    DWORD dwI, dwJ;
    DWORD dwPosition;
    long lMInterp;
    long lM;
    long lA;//, lB;
    DWORD dwIncDelta = dwDeltaPeriod;
    VFRACT dwFract;
    char * pcWave = (char *) m_pnWave;
    PFRACT pfSamplePos = m_pfLastSample;
    PFRACT pfPitch = m_pfLastPitch;
    PFRACT pfPFract = pfPitch << 8;

    VFRACT vfVolume[MAX_DAUD_CHAN]; // = m_vfLastLVolume;
    VFRACT vfVFract[MAX_DAUD_CHAN]; // = vfVolume << 8;  // Keep high res version around. 

    for (dwI = 0; dwI < dwBufferCount; dwI++)
    {
        vfVolume[dwI] = vfLastVolume[dwI];
        vfVFract[dwI] = vfVolume[dwI] << 8;
    }   
	
    for (dwI = 0; dwI < dwLength; )
    {
        if (pfSamplePos >= pfSampleLength)
	    {	
	        if (pfLoopLength)
		        pfSamplePos -= pfLoopLength;
	        else
		        break;
	    }
        dwIncDelta--;
        if (!dwIncDelta) 
        {
            dwIncDelta = dwDeltaPeriod;
            pfPFract += pfDeltaPitch;
            pfPitch = pfPFract >> 8;
            for (dwJ = 0; dwJ < dwBufferCount; dwJ++)
            {
                vfVFract[dwJ] += vfDeltaVolume[dwJ];
                vfVolume[dwJ] = vfVFract[dwJ] >> 8;
            }
        }

	    dwPosition = pfSamplePos >> 12;
	    dwFract = pfSamplePos & 0xFFF;
		pfSamplePos += pfPitch;
	    lMInterp = pcWave[dwPosition]; // pcWave
	    lMInterp += ((pcWave[dwPosition + 1] - lMInterp) * dwFract) >> 12;

        for (dwJ = 0; dwJ < dwBufferCount; dwJ++)
        {
    		lM = lMInterp * vfVolume[dwJ];
    		lM >>= 5;

            // Keep this around so we can use it to generate new assembly code (see below...)
#if 1
			{
			long x = ppBuffer[dwJ][dwI];
			
			x += lM;

			if (x != (short)x) {
				if (x > 32767) x = 32767;
				else  x = -32768;
			}

			ppBuffer[dwJ][dwI] = (short)x;
			}
#else
		    ppBuffer[dwJ][dwI] += (short) lM;
#ifdef i386
            _asm{jno no_oflow}
            ppBuffer[dwJ][dwI] = 0x7fff;
            _asm{js  no_oflow}
            ppBuffer[dwJ][dwI] = (short) 0x8000;
no_oflow:   ;
#endif
#endif
        }
		dwI++;
    }

    for (dwJ = 0; dwJ < dwBufferCount; dwJ++)
    {
        vfLastVolume[dwJ] = vfVolume[dwJ];
    }

    m_pfLastPitch = pfPitch;
    m_pfLastSample = pfSamplePos;

    return (dwI);
}
                        
DWORD CDigitalAudio::MixMulti8Filter(
    short *ppBuffer[], 
	DWORD dwBufferCount,
    DWORD dwLength, 
    DWORD dwDeltaPeriod, 
    VFRACT vfDeltaVolume[], 
	VFRACT vfLastVolume[], 
    PFRACT pfDeltaPitch, 
    PFRACT pfSampleLength, 
    PFRACT pfLoopLength,
    COEFF cfdK,
    COEFF cfdB1,
    COEFF cfdB2)
{
    DWORD dwI, dwJ;
    DWORD dwPosition;
    long lMInterp;
    long lM;
    DWORD dwIncDelta = dwDeltaPeriod;
    VFRACT dwFract;
    char * pcWave = (char *) m_pnWave;
    PFRACT pfSamplePos = m_pfLastSample;
    PFRACT pfPitch = m_pfLastPitch;
    PFRACT pfPFract = pfPitch << 8;
    COEFF cfK  = m_cfLastK;
    COEFF cfB1 = m_cfLastB1;
    COEFF cfB2 = m_cfLastB2;

    VFRACT vfVolume[MAX_DAUD_CHAN]; // = m_vfLastLVolume;
    VFRACT vfVFract[MAX_DAUD_CHAN]; // = vfVolume << 8;  // Keep high res version around. 
	DWORD dMM6[2];

    for (dwI = 0; dwI < dwBufferCount; dwI++)
    {
        vfVolume[dwI] = vfLastVolume[dwI];
        vfVFract[dwI] = vfVolume[dwI] << 8;
    }    

    for (dwI = 0; dwI < dwLength; )
    {
        if (pfSamplePos >= pfSampleLength)
	    {	
	        if (pfLoopLength)
		        pfSamplePos -= pfLoopLength;
	        else
		        break;
	    }
        dwIncDelta--;
        if (!dwIncDelta) 
        {
            dwIncDelta = dwDeltaPeriod;
            pfPFract += pfDeltaPitch;
            pfPitch = pfPFract >> 8;
            for (dwJ = 0; dwJ < dwBufferCount; dwJ++)
            {
                vfVFract[dwJ] += vfDeltaVolume[dwJ];
                vfVolume[dwJ] = vfVFract[dwJ] >> 8;
            }

            cfK += cfdK;
            cfB1 += cfdB1;
            cfB2 += cfdB2;
        }
	    
#if 1
		{
			dwPosition = pfSamplePos >> 12;
			dwFract = pfSamplePos & 0xFFF;

			long pfL1 = 0;
			if( dwPosition > 0 )
			{
				pfL1 = pcWave[dwPosition-1];
			}
			long pfL0 = pcWave[dwPosition];
			long pfH0 = pcWave[dwPosition + 1];
			long pfH1 = 0;
			if( dwPosition < unsigned((pfSampleLength >> 12) - 1) )
			{
				pfH1 = pcWave[dwPosition+2];
			}

			long pfT1 = (pfH0 - pfL0)*6 + (pfL1 - pfH1)*2;
			long pfT2 = (pfL0 - pfH0)*15 + (pfH1 -  pfL1)*5 + ((dwFract*pfT1) >> 12);
			long pfT3 = (pfH0 - pfL0)*9 + (pfL1 - pfH1)*3 + ((dwFract*pfT2) >> 12);
			long pfT4 = pfH0 + pfL0*(-2) + pfL1 + ((dwFract*pfT3) >> 12);
			lMInterp = pfL0 + ((dwFract * (pfH0-pfL1 + ((dwFract*pfT4) >> 12))) >> 13);

		}
        pfSamplePos += pfPitch;
#else
	    dwPosition = pfSamplePos >> 12;
	    dwFract = pfSamplePos & 0xFFF;
		pfSamplePos += pfPitch;

	    lMInterp = pcWave[dwPosition]; // pcWave
	    lMInterp += ((pcWave[dwPosition + 1] - lMInterp) * dwFract) >> 12;
#endif

        // Filter
        //
        lMInterp =
              MulDiv(lMInterp, cfK, (1 << 30))
            - MulDiv(m_lPrevSample, cfB1, (1 << 30))
            + MulDiv(m_lPrevPrevSample, cfB2, (1 << 30));

        m_lPrevPrevSample = m_lPrevSample;
        m_lPrevSample = lMInterp;

        for (dwJ = 0; dwJ < dwBufferCount; dwJ++)
        {
    		lM = lMInterp * vfVolume[dwJ];
    		lM >>= 5;

            // Keep this around so we can use it to generate new assembly code (see below...)
#if 1
			{
			long x = ppBuffer[dwJ][dwI];
			
			x += lM;

			if (x != (short)x) {
				if (x > 32767) x = 32767;
				else  x = -32768;
			}

			ppBuffer[dwJ][dwI] = (short)x;
			}
#else
		    ppBuffer[dwJ][dwI] += (short) lM;
#ifdef i386
            _asm{jno no_oflow}
            ppBuffer[dwJ][dwI] = 0x7fff;
            _asm{js  no_oflow}
            ppBuffer[dwJ][dwI] = (short) 0x8000;
no_oflow:   ;
#endif
#endif
        }
		dwI++;
    }

    for (dwJ = 0; dwJ < dwBufferCount; dwJ++)
    {
        vfLastVolume[dwJ] = vfVolume[dwJ];
    }

    m_pfLastPitch = pfPitch;
    m_pfLastSample = pfSamplePos;

    return (dwI);
}

DWORD CDigitalAudio::MixMulti16(
    short *ppBuffer[], 
	DWORD dwBufferCount,
    DWORD dwLength, 
    DWORD dwDeltaPeriod, 
    VFRACT vfDeltaVolume[], 
	VFRACT vfLastVolume[], 
    PFRACT pfDeltaPitch, 
    PFRACT pfSampleLength, 
    PFRACT pfLoopLength)
{
    DWORD dwI = 0;
    DWORD dwJ = 0;
    DWORD dwPosition = 0;
    long lA = 0;//, lB;
    long lM = 0;
    long lMInterp = 0;
    DWORD dwIncDelta = dwDeltaPeriod;
    VFRACT dwFract;
    short * pcWave = m_pnWave;
    PFRACT pfSamplePos = m_pfLastSample;
    PFRACT pfPitch = m_pfLastPitch;
    PFRACT pfPFract = pfPitch << 8;

    VFRACT vfVolume[MAX_DAUD_CHAN]; // = m_vfLastLVolume;
    VFRACT vfVFract[MAX_DAUD_CHAN]; // = vfVolume << 8;  // Keep high res version around. 

    for (dwI = 0; dwI < dwBufferCount; dwI++)
    {
        vfVolume[dwI] = vfLastVolume[dwI];
        vfVFract[dwI] = vfVolume[dwI] << 8;
    }    

    for (dwI = 0; dwI < dwLength;)
    {
        if (pfSamplePos >= pfSampleLength)
	    {	
	        if (pfLoopLength)
    		    pfSamplePos -= pfLoopLength;
	        else
	    	    break;
	    }
        
        dwIncDelta--;
        if (!dwIncDelta)   
        {
            dwIncDelta = dwDeltaPeriod;
            pfPFract += pfDeltaPitch;
            pfPitch = pfPFract >> 8;
            for (dwJ = 0; dwJ < dwBufferCount; dwJ++)
            {
                vfVFract[dwJ] += vfDeltaVolume[dwJ];
                vfVolume[dwJ] = vfVFract[dwJ] >> 8;
            }
        }

#if 1
		/*
        {
			// 4x Oversampling of linear interpolation
            PFRACT pfPitchDiv4 = pfPitch >> 2;
            PFRACT pfSamplePosTmp = pfSamplePos - pfPitchDiv4;
            long lMInterpTmp = 0;
            for( int nIndex = 0; nIndex < 4; nIndex++ )
            {
                dwPosition = pfSamplePosTmp >> 12;
                dwFract = pfSamplePosTmp & 0xFFF;

                lA = (long) pcWave[dwPosition];
                lMInterpTmp += (((pcWave[dwPosition+1] - lA) * dwFract) >> 12) + lA;
            }
            lMInterp = lMInterpTmp >> 2;
        }
		*/
		// const double L1 = floor[-1];
		// const double L0 = floor[ 0];
		// const double H0 = floor[+1];
		// const double H1 = floor[+2];
		// const double x = fractpos;
		//return (float)(L0 + .5f* x*(H0-L1 + x*(H0 + L0*(-2) + L1 + x*( (H0
		// - L0)*9 + (L1 - H1)*3 + x*((L0 - H0)*15 + (H1 -  L1)*5 + x*((H0 -
		// L0)*6 + (L1 - H1)*2))))));
		{
			dwPosition = pfSamplePos >> 12;
			dwFract = pfSamplePos & 0xFFF;

			long pfL1 = 0;
			if( dwPosition > 0 )
			{
				pfL1 = pcWave[dwPosition-1];
			}
			long pfL0 = pcWave[dwPosition];
			long pfH0 = pcWave[dwPosition + 1];
			long pfH1 = 0;
			if( dwPosition < unsigned((pfSampleLength >> 12) - 1) )
			{
				pfH1 = pcWave[dwPosition+2];
			}

			long pfT1 = (pfH0 - pfL0)*6 + (pfL1 - pfH1)*2;
			long pfT2 = (pfL0 - pfH0)*15 + (pfH1 -  pfL1)*5 + ((dwFract*pfT1) >> 12);
			long pfT3 = (pfH0 - pfL0)*9 + (pfL1 - pfH1)*3 + ((dwFract*pfT2) >> 12);
			long pfT4 = pfH0 + pfL0*(-2) + pfL1 + ((dwFract*pfT3) >> 12);
			lMInterp = pfL0 + ((dwFract * (pfH0-pfL1 + ((dwFract*pfT4) >> 12))) >> 13);

		}
        pfSamplePos += pfPitch;
#else
        dwPosition = pfSamplePos >> 12;
        dwFract = pfSamplePos & 0xFFF;
        pfSamplePos += pfPitch;

        lA = (long) pcWave[dwPosition];
        lMInterp = (((pcWave[dwPosition+1] - lA) * dwFract) >> 12) + lA;
#endif

        for (dwJ = 0; dwJ < dwBufferCount; dwJ++)
        {
            lM = lMInterp * vfVolume[dwJ]; 
            lM >>= 13;         // Signal bumps up to 12 bits.

            // Keep this around so we can use it to generate new assembly code (see below...)
#if 1
			{
			long x = ppBuffer[dwJ][dwI];
			
			x += lM;

			if (x != (short)x) {
				if (x > 32767) x = 32767;
				else  x = -32768;
			}

			ppBuffer[dwJ][dwI] = (short)x;
			}
#else
            ppBuffer[dwJ][dwI] += (short) lM;
#ifdef i386
            _asm{jno no_oflow}
            ppBuffer[dwJ][dwI] = 0x7fff;
            _asm{js  no_oflow}
            ppBuffer[dwJ][dwI] = (short) 0x8000;
no_oflow:	;
#endif
#endif
        }
		dwI++;
    }
    m_pfLastPitch = pfPitch;
    m_pfLastSample = pfSamplePos;

    for (dwJ = 0; dwJ < dwBufferCount; dwJ++)
    {
        vfLastVolume[dwJ] = vfVolume[dwJ];
    }
    return (dwI);
}

DWORD CDigitalAudio::MixMulti16Filter(
    short *ppBuffer[], 
	DWORD dwBufferCount,
    DWORD dwLength, 
    DWORD dwDeltaPeriod, 
    VFRACT vfDeltaVolume[], 
	VFRACT vfLastVolume[], 
    PFRACT pfDeltaPitch, 
    PFRACT pfSampleLength, 
    PFRACT pfLoopLength,
    COEFF cfdK,
    COEFF cfdB1,
    COEFF cfdB2)
{
    DWORD dwI, dwJ;
    DWORD dwPosition;
    long lA;//, lB;
    long lM;
    long lMInterp;
    DWORD dwIncDelta = dwDeltaPeriod;
    VFRACT dwFract;
    short * pcWave = m_pnWave;
    PFRACT pfSamplePos = m_pfLastSample;
    PFRACT pfPitch = m_pfLastPitch;
    PFRACT pfPFract = pfPitch << 8;
    COEFF cfK  = m_cfLastK;
    COEFF cfB1 = m_cfLastB1;
    COEFF cfB2 = m_cfLastB2;
	DWORD dMM6[2];					// Handle filter...
    
    VFRACT vfVolume[MAX_DAUD_CHAN]; // = m_vfLastLVolume;
    VFRACT vfVFract[MAX_DAUD_CHAN]; // = vfVolume << 8;  // Keep high res version around. 

    for (dwI = 0; dwI < dwBufferCount; dwI++)
    {
        vfVolume[dwI] = vfLastVolume[dwI];
        vfVFract[dwI] = vfVolume[dwI] << 8;
    }    

    for (dwI = 0; dwI < dwLength;)
    {
        if (pfSamplePos >= pfSampleLength)
	    {	
	        if (pfLoopLength)
    		    pfSamplePos -= pfLoopLength;
	        else
	    	    break;
	    }
        dwIncDelta--;
        if (!dwIncDelta)   
        {
            dwIncDelta = dwDeltaPeriod;
            pfPFract += pfDeltaPitch;
            pfPitch = pfPFract >> 8;
            for (dwJ = 0; dwJ < dwBufferCount; dwJ++)
            {
                vfVFract[dwJ] += vfDeltaVolume[dwJ];
                vfVolume[dwJ] = vfVFract[dwJ] >> 8;
            }

            cfK += cfdK;
            cfB1 += cfdB1;
           cfB2 += cfdB2;
        }

#if 1
		{
			dwPosition = pfSamplePos >> 12;
			dwFract = pfSamplePos & 0xFFF;

			long pfL1 = 0;
			if( dwPosition > 0 )
			{
				pfL1 = pcWave[dwPosition-1];
			}
			long pfL0 = pcWave[dwPosition];
			long pfH0 = pcWave[dwPosition + 1];
			long pfH1 = 0;
			if( dwPosition < unsigned((pfSampleLength >> 12) - 1) )
			{
				pfH1 = pcWave[dwPosition+2];
			}

			long pfT1 = (pfH0 - pfL0)*6 + (pfL1 - pfH1)*2;
			long pfT2 = (pfL0 - pfH0)*15 + (pfH1 -  pfL1)*5 + ((dwFract*pfT1) >> 12);
			long pfT3 = (pfH0 - pfL0)*9 + (pfL1 - pfH1)*3 + ((dwFract*pfT2) >> 12);
			long pfT4 = pfH0 + pfL0*(-2) + pfL1 + ((dwFract*pfT3) >> 12);
			lMInterp = pfL0 + ((dwFract * (pfH0-pfL1 + ((dwFract*pfT4) >> 12))) >> 13);

		}
        pfSamplePos += pfPitch;
#else
        dwPosition = pfSamplePos >> 12;
        dwFract = pfSamplePos & 0xFFF;
        pfSamplePos += pfPitch;

        lA = (long) pcWave[dwPosition];
        lMInterp = (((pcWave[dwPosition+1] - lA) * dwFract) >> 12) + lA;
#endif

        // Filter
        //
		// z = k*s - b1*z1 - b2*b2
		// We store the negative of b1 in the table, so we flip the sign again by
		// adding here
		//
        lMInterp =
              MulDiv(lMInterp, cfK, (1 << 30))
            + MulDiv(m_lPrevSample, cfB1, (1 << 30))
            - MulDiv(m_lPrevPrevSample, cfB2, (1 << 30));

//>>>>>>>>>>>> removed dp
#if 0 
		if (lMInterp < -32767) lMInterp = -32767;
		else if (lMInterp > 32767) lMInterp = 32767;
#endif
        m_lPrevPrevSample = m_lPrevSample;
        m_lPrevSample = lMInterp;

        for (dwJ = 0; dwJ < dwBufferCount; dwJ++)
        {
            lM = lMInterp * vfVolume[dwJ]; 
            lM >>= 13;         // Signal bumps up to 12 bits.

            // Keep this around so we can use it to generate new assembly code (see below...)
#if 1
			{
			long x = ppBuffer[dwJ][dwI];
			
			x += lM;

			if (x != (short)x) {
				if (x > 32767) x = 32767;
				else  x = -32768;
			}

			ppBuffer[dwJ][dwI] = (short)x;
			}
#else
            ppBuffer[dwJ][dwI] += (short) lM;
#ifdef i386
            _asm{jno no_oflow}
            ppBuffer[dwJ][dwI] = 0x7fff;
            _asm{js  no_oflow}
            ppBuffer[dwJ][dwI] = (short) 0x8000;
no_oflow:	;
#endif
#endif
        }
		dwI++;
    }

    m_pfLastPitch = pfPitch;
    m_pfLastSample = pfSamplePos;

	m_cfLastK = cfK;
	m_cfLastB1 = cfB1;
	m_cfLastB2 = cfB2;

    for (dwJ = 0; dwJ < dwBufferCount; dwJ++)
    {
        vfLastVolume[dwJ] = vfVolume[dwJ];
    }

    return (dwI);
}

#endif // }
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\XboxSynth\oledll.cpp ===
// Copyright (c) 1998-1999 Microsoft Corporation
// oledll.cpp
//
// Handle standard methods for OLE server DLL
//
#include <objbase.h>
#include "debug.h"
#include <iostream.h>

#include "oledll.h"

#ifdef UNICODE
#ifndef UNDER_CE
#error DirectMusic Win NT/9x must be compiled without UNICODE
#endif
#endif

static const TCHAR g_szCLSID[]           = TEXT("CLSID");
static const TCHAR g_szCLSIDSlash[]      = TEXT("CLSID\\");
static const TCHAR g_szInProc32[]        = TEXT("InProcServer32");
static const TCHAR g_szProgIDKey[]       = TEXT("ProgID");
static const TCHAR g_szVerIndProgIDKey[] = TEXT("VersionIndependentProgID");
static const TCHAR g_szCurVer[]          = TEXT("CurVer"); 
static const TCHAR g_szThreadingModel[]	= TEXT("ThreadingModel");
static const TCHAR g_szBoth[]		= TEXT("Both");

static const int CLSID_STRING_SIZE = 39;

static LONG RegSetDefValue(LPCTSTR pstrKey, LPCTSTR pstrSubkey, LPCTSTR pstrValueName, LPCTSTR pstrValue);
static void RegRemoveSubtree(HKEY hk, LPCTSTR pstrChild);

STDAPI
RegisterServer(HMODULE hModule,
               const CLSID &clsid,
               const TCHAR *szFriendlyName,
               const TCHAR *szVerIndProgID,
               const TCHAR *szProgID)
{
    TCHAR szCLSID[CLSID_STRING_SIZE];
    HRESULT hr;
    LONG lr;

    hr = CLSIDToStr(clsid, szCLSID, sizeof(szCLSID));
    if (!SUCCEEDED(hr)) {
        return hr;
    }

    TCHAR szClsKey[256];
    lstrcpy(szClsKey, g_szCLSIDSlash);
    lstrcat(szClsKey, szCLSID);

    TCHAR szModule[512];
    lr = ::GetModuleFileName(hModule, szModule, sizeof(szModule));
    assert(lr);

    lr = 0;

    lr |= RegSetDefValue(szClsKey, NULL, NULL, szFriendlyName);
    lr |= RegSetDefValue(szClsKey, g_szInProc32, NULL, szModule);
	lr |= RegSetDefValue(szClsKey, g_szInProc32, g_szThreadingModel, g_szBoth);
    lr |= RegSetDefValue(szClsKey, g_szProgIDKey, NULL, szProgID);
    lr |= RegSetDefValue(szClsKey, g_szVerIndProgIDKey, NULL, szVerIndProgID);

    lr |= RegSetDefValue(szVerIndProgID, NULL, NULL, szFriendlyName);
    lr |= RegSetDefValue(szVerIndProgID, g_szCLSID, NULL, szCLSID);
    lr |= RegSetDefValue(szVerIndProgID, g_szCurVer, NULL, szProgID);
    
	lr |= RegSetDefValue(szProgID, NULL, NULL, szFriendlyName);
    lr |= RegSetDefValue(szProgID, g_szCLSID, NULL, szCLSID);

#if 0 
    if (lr) {
        UnregisterServer(clsid,
                         szFriendlyName,
                         szVerIndProgID,
                         szProgID);
        // ???
        //
        return S_OK;
    }
#endif

    return S_OK;
}

STDAPI
UnregisterServer(const CLSID &clsid,
                 const TCHAR *szFriendlyName,
                 const TCHAR *szVerIndProgID,
                 const TCHAR *szProgID)
{
    TCHAR szCLSID[CLSID_STRING_SIZE];
    HRESULT hr;

    hr = CLSIDToStr(clsid, szCLSID, sizeof(szCLSID));
    if (!SUCCEEDED(hr)) {
        return hr;
    }

    TCHAR szClsKey[256];
    lstrcpy(szClsKey, g_szCLSIDSlash);
    lstrcat(szClsKey, szCLSID);

    RegRemoveSubtree(HKEY_CLASSES_ROOT, szClsKey);
    RegRemoveSubtree(HKEY_CLASSES_ROOT, szVerIndProgID);
    RegRemoveSubtree(HKEY_CLASSES_ROOT, szProgID);

    return S_OK;
}

BOOL
GetCLSIDRegValue(const CLSID &clsid,
				 const TCHAR *szKey,
				 LPVOID pValue,
				 LPDWORD pcbValue)
{
    TCHAR szCLSID[CLSID_STRING_SIZE];
    HRESULT hr;
    HKEY hk;
	DWORD dw;

    hr = CLSIDToStr(clsid, szCLSID, sizeof(szCLSID));
    if (!SUCCEEDED(hr)) {
        return FALSE;
    }

    TCHAR szClsKey[256];
    lstrcpy(szClsKey, g_szCLSIDSlash);
    lstrcat(szClsKey, szCLSID);
	lstrcat(szClsKey, TEXT("\\"));
	lstrcat(szClsKey, szKey);

	if (RegOpenKeyEx(HKEY_CLASSES_ROOT,
					 szClsKey,
					 0,
					 KEY_READ,
					 &hk)) {
		return FALSE;
	}

	if (RegQueryValueEx(hk,
						NULL,
						NULL,
						&dw,
						(LPBYTE)pValue,
						pcbValue)) {
		RegCloseKey(hk);
		return FALSE;
	}

	RegCloseKey(hk);
	
	return TRUE;
}

HRESULT
CLSIDToStr(const CLSID &clsid,
           TCHAR *szStr,
           int cbStr)
{
    // XXX What to return here?
    //
    assert(cbStr >= CLSID_STRING_SIZE);
    
	LPOLESTR wszCLSID = NULL;
	HRESULT hr = StringFromCLSID(clsid, &wszCLSID);
    if (!SUCCEEDED(hr)) {
        return hr;
    }

#ifdef UNICODE
    lstrcpy(szStr, wszCLSID);
#else
	// Covert from wide characters to non-wide.
	wcstombs(szStr, wszCLSID, cbStr);
#endif

	// Free memory.
    CoTaskMemFree(wszCLSID);

    return S_OK;
}

HRESULT
StrToCLSID(TCHAR *szStr,
		   CLSID &clsid,
		   int cbStr)
{
#ifdef UNICODE
    return CLSIDFromString(szStr, &clsid);
#else    
	WCHAR wsz[512];

	mbstowcs(wsz, szStr, cbStr);

	return CLSIDFromString(wsz, &clsid);
#endif
}
   

static LONG
RegSetDefValue(LPCTSTR pstrKey,
               LPCTSTR pstrSubkey,
			   LPCTSTR pstrValueName,
               LPCTSTR pstrValue)
{
    HKEY hk;
    LONG lr;
    TCHAR sz[1024];
    LPCTSTR pstr;

    if (!pstrSubkey) {
        pstr = pstrKey;
    } else {
        lstrcpy(sz, pstrKey);
        lstrcat(sz, TEXT("\\"));
        lstrcat(sz, pstrSubkey);
        pstr = sz;
    }

    lr = RegCreateKeyEx(HKEY_CLASSES_ROOT,
                        pstr,
                        0,
                        NULL,
                        REG_OPTION_NON_VOLATILE,
                        KEY_ALL_ACCESS,
                        NULL,
                        &hk,
                        NULL);
    if (lr) {
        return lr;
    }

    lr = RegSetValueEx(hk,
                       pstrValueName,
                       0,
                       REG_SZ,
                       (CONST BYTE*)pstrValue,
                       1+lstrlen(pstrValue));
    RegCloseKey(hk);

    return lr;
}

static void
RegRemoveSubtree(HKEY hk,
                 LPCTSTR pstrChild)
{
    LONG lResult;
    HKEY hkChild;

    lResult = RegOpenKeyEx(hk,
                           pstrChild,
                           0,
                           KEY_ALL_ACCESS,
                           &hkChild);
    if (lResult) {
        return;
    }

#ifndef UNDER_CE    // CE doesn't support RegEnumKey()
    TCHAR szSubkey[256];

    // NOTE: Unlike regular enumeration, we always grab the 0th item
    // and delete it.
    //
    while (!RegEnumKey(hkChild, 0, szSubkey, sizeof(szSubkey))) {
        RegRemoveSubtree(hkChild, szSubkey);
    }
#endif    

    RegCloseKey(hkChild);
    RegDeleteKey(hk, pstrChild);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\XboxSynth\opnew.cpp ===
// Copyright (c) 1999 Microsoft Corporation
// OpNew.cpp
//
// Override operator new[] so that we ignore the new_handler mechanism.
//
//
#include <windows.h>
#include <stdio.h>
#include <stdlib.h>

#include "Debug.h"

LPVOID __cdecl operator new(size_t cbBuffer)
{
    LPVOID p;

    p = malloc(cbBuffer ? cbBuffer : 1);
    return p;
}

void __cdecl operator delete(LPVOID p)
{
    free(p);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\XboxSynth\plclock.h ===
//      Copyright (c) 1996-1999 Microsoft Corporation
/*	PLClock.h

  */

#ifndef __PLCLOCK_H__
#define __PLCLOCK_H__

class CPhaseLockClock
{
public:
						CPhaseLockClock();
	void				Start(REFERENCE_TIME rfMasterTime, REFERENCE_TIME rfSlaveTime);
	void				GetSlaveTime(REFERENCE_TIME rfSlaveTime,REFERENCE_TIME *prfTime);
	void				SetSlaveTime(REFERENCE_TIME rfSlaveTime,REFERENCE_TIME *prfTime);
	void				SyncToMaster(REFERENCE_TIME rfSlaveTime, REFERENCE_TIME rfMasterTime);
private:
	REFERENCE_TIME		m_rfOffset;
};

class CSampleClock
{
public:
						CSampleClock();
	void				Start(IReferenceClock *pIClock, DWORD dwSampleRate, DWORD dwSamples);
	void				SampleToRefTime(LONGLONG llSampleTime,REFERENCE_TIME *prfTime);
	void				SyncToMaster(LONGLONG llSampleTime, IReferenceClock *pIClock);
	LONGLONG			RefTimeToSample(REFERENCE_TIME rfTime);

private:
	CPhaseLockClock		m_PLClock;
	DWORD				m_dwStart;		// Initial sample offset.
	DWORD				m_dwSampleRate;
};



#endif	// __PLCLOCK_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\XboxSynth\private.h ===
//      Copyright (c) 1996-1999 Microsoft Corporation
//
//
//
#ifndef _PRIVATE
#define _PRIVATE_

NTSTATUS CreateMiniportDmSynth
(
    OUT PUNKNOWN *  Unknown,
    IN  PUNKNOWN    UnknownOuter OPTIONAL,
    IN  POOL_TYPE   PoolType
);


#include <stdunk.h>

class CDmSynthStream;

class CMiniportDmSynth : public IMiniportSynthesizer, public CUnknown
{
friend class CDmSynthStream;

public:
    // IUnknown
    //
    DECLARE_STD_UNKNOWN();
    DEFINE_STD_CONSTRUCTOR(CMiniportDmSynth);

    ~CMiniportDmSynth();

    // IMiniport
    //
    STDMETHOD(GetDescription)
    (   THIS_
        OUT     PPCFILTER_DESCRIPTOR *  OutFilterDescriptor
    );

    STDMETHOD(DataRangeIntersection)
    (   THIS_
        IN      ULONG           PinId,
        IN      PKSDATARANGE    DataRange,
        IN      PKSDATARANGE    MatchingDataRange,
        IN      ULONG           OutputBufferLength,
        OUT     PVOID           ResultantFormat    OPTIONAL,
        OUT     PULONG          ResultantFormatLength
    );

    // IMiniportDmSynth
    //
    STDMETHOD(Init)
    (   THIS_
        IN      PUNKNOWN        UnknownNotUsed  OPTIONAL,
        IN      PRESOURCELIST   ResourceList,
        IN      PPORTSYNTHESIZER Port,
        OUT     PSERVICEGROUP * ServiceGroup
    );  
      
    STDMETHOD(NewStream)
    (   THIS_
        OUT     PMINIPORTSYNTHESIZERSTREAM *   Stream,
        IN      PUNKNOWN                OuterUnknown    OPTIONAL,
        IN      POOL_TYPE               PoolType,
        IN      ULONG                   Pin,
        IN      BOOLEAN                 Capture,
        IN      PKSDATAFORMAT           DataFormat,
        OUT     PSERVICEGROUP *         ServiceGroup
    );

    STDMETHOD_(void, Service)
    (   void
    );

private:
    PPORTSYNTHESIZER        Port;
    CDmSynthStream *        Stream;    
};


class CDmSynthStream : public IMiniportSynthesizerStream, public CUnknown
{
public:
    // IUnknown
    //
    DECLARE_STD_UNKNOWN();
    DEFINE_STD_CONSTRUCTOR(CDmSynthStream);
    ~CDmSynthStream();
    NTSTATUS Init(CMiniportDmSynth *Miniport);

    // IMxfFilter
    //
    STDMETHOD(ConnectOutput)
    (
        PMXFFILTER ConnectionPoint
    );
    
    STDMETHOD(DisconnectOutput)
    (
        PMXFFILTER ConnectionPoint
    );

    STDMETHOD(PutMessage)
    (   THIS_
        IN  PDMUS_KERNEL_EVENT  Event
    ); 

    // IMiniportSynthStream
    //
    STDMETHOD(SetState)
    (   THIS_
        IN      KSSTATE     State
    );

    // Class
    //
    STDMETHOD(HandlePortParams)
    (   THIS_
        IN      PPCPROPERTY_REQUEST pRequest
    );

public:
    CSynth *                Synth;

private:
    CMiniportDmSynth *      Miniport;
    CSysLink *              Sink;
    SYNTH_PORTPARAMS        PortParams;
};

typedef CDmSynthStream *PDMSYNTHSTREAM;

#endif // _PRIVATE_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\XboxSynth\simple.h ===
//      Copyright (c) 1996-1999 Microsoft Corporation

#include <windows.h>
#include <windowsx.h>
#include <stdio.h>
#include "misc.h"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\XboxSynth\plclock.cpp ===
//      Copyright (c) 1996-1999 Microsoft Corporation
/*	CPhaseLockClock

  */

#include <windows.h>
#include <windowsx.h>
#include <stdio.h>
#include "dmusicc.h"
#include "dmusics.h"
#include "plclock.h"
#include "misc.h"
#define MILS_TO_REF	10000

CPhaseLockClock::CPhaseLockClock()

{
	m_rfOffset = 0;
}

void CPhaseLockClock::Start(REFERENCE_TIME rfMasterTime, REFERENCE_TIME rfSlaveTime)

/*	When the clock starts, it needs to mark down the 
	difference between the time it is given and its concept of time. 
*/

{
	m_rfOffset = rfMasterTime - rfSlaveTime;
}	

void CPhaseLockClock::GetSlaveTime(REFERENCE_TIME rfSlaveTime, REFERENCE_TIME *prfTime)

/*	Convert the passed time to use the same base as the master clock.
*/

{
	rfSlaveTime += m_rfOffset;
	*prfTime = rfSlaveTime;
}

void CPhaseLockClock::SetSlaveTime(REFERENCE_TIME rfSlaveTime, REFERENCE_TIME *prfTime)

{
	rfSlaveTime -= m_rfOffset;
	*prfTime = rfSlaveTime;
}

void CPhaseLockClock::SyncToMaster(REFERENCE_TIME rfSlaveTime, REFERENCE_TIME rfMasterTime)

/*	SyncToTime provides the needed magic to keep the clock
	in sync. Since the clock uses its own clock (rfSlaveTime)
	to increment, it can drift. This call provides a reference
	time which the clock compares with its internal 
	concept of time. The difference between the two is
	considered the drift. Since the sync time may increment in
	a lurching way, the correction has to be subtle. 
	So, the difference between the two is divided by
	100 and added to the offset.
*/

{
	rfSlaveTime += m_rfOffset;
	rfSlaveTime -= rfMasterTime;	// Find difference between calculated and expected time.
	rfSlaveTime /= 100;				// Reduce in magnitude.
	m_rfOffset -= rfSlaveTime;		// Subtract that from the original offset.
}

CSampleClock::CSampleClock()

{
	m_dwStart = 0;
	m_dwSampleRate = 22050;
}

void CSampleClock::Start(IReferenceClock *pIClock, DWORD dwSampleRate, DWORD dwSamples)

{
	REFERENCE_TIME rfStart;
	m_dwStart = dwSamples;
	m_dwSampleRate = dwSampleRate;
	if (pIClock)
	{
		pIClock->GetTime(&rfStart);
		m_PLClock.Start(rfStart,0);
	}
}

void CSampleClock::SampleToRefTime(LONGLONG llSampleTime,REFERENCE_TIME *prfTime)

{
	llSampleTime -= m_dwStart;
	llSampleTime *= MILS_TO_REF;
	llSampleTime /= m_dwSampleRate;
	llSampleTime *= 1000;
	m_PLClock.GetSlaveTime(llSampleTime, prfTime);
}

LONGLONG CSampleClock::RefTimeToSample(REFERENCE_TIME rfTime)

{
	m_PLClock.SetSlaveTime(rfTime, &rfTime);
	rfTime /= 1000;
	rfTime *= m_dwSampleRate;
	rfTime /= MILS_TO_REF;
	return rfTime + m_dwStart;
}


void CSampleClock::SyncToMaster(LONGLONG llSampleTime, IReferenceClock *pIClock)

{
	llSampleTime -= m_dwStart;
	llSampleTime *= MILS_TO_REF;
	llSampleTime /= m_dwSampleRate;
	llSampleTime *= 1000;
	if (pIClock)
	{
		REFERENCE_TIME rfMasterTime;
		pIClock->GetTime(&rfMasterTime);
		m_PLClock.SyncToMaster(llSampleTime, rfMasterTime);
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\XboxSynth\sverb.h ===
/***********************************************************
Copyrights : ksWaves Ltd. 1998.

Provided to Microsoft under contract between ksWaves and Microsoft.

************************************************************/

/****************************************************************************
Const defines :
*****************************************************************************/
#define FPU_DENORM_OFFS (float)1.0E-30

#define BASE_REV_DELAY  0x4000
#define BASE_DSPS_DELAY 0x800

#define DSPS_MASK   0x7ff
#define REV_MASK    0x3fff

/****************************************************************************
Coefs Struct :
*****************************************************************************/
typedef struct
{

	long mySize;
	long myVersion;
	float SampleRate;

	float directGain; 
	long  l_directGain; 
	float revGain; 
	long l_revGain; 

	long lDelay1;
	long lDelay2;
	long lDelay3;
	long lDelay4;

	long lDDly1; 
	long lDDly2; 

	float dDsps;
	long l_dDsps;

	float dDG1;
	long l_dDG1;

	float dDG2; 
	long l_dDG2; 

	float dFB11;
	long l_dFB11;
	float dFB12;
	long l_dFB12;
	float dFB21;
	long l_dFB21;
	float dFB22;
	long l_dFB22;
	float dFB31;
	long l_dFB31;
	float dFB32;
	long l_dFB32;
	float dFB41;
	long l_dFB41;
	float dFB42;
	long l_dFB42;

	float dDamp;
	long l_dDamp;


} sCoefsStruct;

/****************************************************************************
Initialization and control functions :
*****************************************************************************/

#ifdef __cplusplus
extern "C"
{
#endif

#define MAX_16 (float)((unsigned long)0x00008000)

void InitSVerbStates( long *pStates );
long DToF32( float dbl  );
void ConvertCoefsToFix( void *pC );
void InitSVerb( float SampleRate, void  *pCoefs);
void SetSVerb( float InGain, float dRevMix,  float dRevTime, 
			    float dHighFreqRTRatio, void  *pCoefs );



long GetCoefsSize(void);
long GetStatesSize(void);
long GetSVerbVersion(void);

float VerifySampleRate(void  *pCoefs);
long VerifyVersion(void  *pCoefs);
long VerifySize(void  *pCoefs);


#define CLIP_SHORT_TO_SHORT(x)\
			if (x>32767)\
				x = 32767;\
			else if (x<-32768)\
				x = -32768;

/****************************************************************************
//Process Functions :
*****************************************************************************/

__inline void dsps( float *pDly, long ref, long delay, float dDG1, float dDsps, float *inL, float *inR );
__inline void dspsL( long *pDly, long ref, long delay, long dDG1, long dDsps, long *inL, long *inR );

void SVerbMonoToMonoShort(long NumInFrames, short *pInShort, short *pOutShort, 
						 void  *pCoefs, long *pStates);

void SVerbMonoToStereoShort(long NumInFrames, short *pInShort, short *pOutShort, 
						 void  *pCoefs, long *pStates);

void SVerbStereoToStereoShort(long NumInFrames, short *pInShort, short *pOutShort, 
						 void  *pCoefs, long *pStates);

void SVerbMonoToMonoFloat(long NumInFrames, float *pInFloat, float *pOutFloat, 
						 void  *pCoefs, float *pStates);

void SVerbMonoToStereoFloat(long NumInFrames, float *pInFloat, float *pOutFloat, 
						 void  *pCoefs, float *pStates);

void SVerbStereoToStereoFloat(long NumInFrames, float *pInFloat, float *pOutFloat, 
						 void  *pCoefs, float *pStates);


#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\XboxSynth\sverb.c ===
/***********************************************************
Copyrights : ksWaves Ltd. 1998.

Provided to Microsoft under contract between ksWaves and Microsoft.

************************************************************/

/***********************************************************
General description :

The functions in this file provides for any apoplication to process audio data
with the SVerb algorithm.

In order to do so the application should :

1. Allocate two chunks of memory for 'Coefs' and 'States' with sizes as returned 
   by the functions 'GetCoefsSize' and 'GetStatesSize' accordingly.
   
2. Initialize these memory chunks using the functions : 'InitSVerb' and 'InitSVerbStates' 
   accordingly.

3. Change the settings of the SVerb sound using the function 'SetSVerb'.

4. Call one of the process functions according to the input/output data format:

   SVerbMonoToMonoShort 
   SVerbMonoToStereoShort
   SVerbStereoToStereoShort 
   SVerbMonoToMonoFloat
   SVerbMonoToStereoFloat
   SVerbStereoToStereoFloat

   The input/output are always the same data type (i.e. both input and output are short integer
   or both are 32bits floats).

   Stereo data format is always'interlaced' left,right samples.

   The 'coefs' and 'states' memory should be passed to the process functions.
   
5. Many coefs structures can be initialized each for different SVerb settings. Passing a different
   coefs structure will cause a real time change of sound quality.

   As long as sound continuity should be maintained the states structure should not be changes or
   re-initialized. Only when a completly new audio sequence is desired should the states be re-initialized.

6. Note that the coefs are valid per sampling rate.

7. Althaugh provisions for coefs compatibility for future versions are provided, it should be avoided to save coefs
   structures to files as-is and re-use them later. Rather the application should save the 'real-world'
   settings of the reverb - namely the parameters passed to 'SetSVerb'. These 'real-world' settings 
   will always be valid for future versions, as well as if other sampling rates are used. The coefs 
   structur(es) should be re-initialized in run time using the real-world settings and call to 
   'SetSverb'.


************************************************************/

#include <windows.h>
#include <String.h>
#include <math.h>
#include "SVerb.h"

#pragma optimize( "ty", on )

/****************************************************************************

Function Name	: GetCoefsSize

Input Arguments : None

Return Value    : The size of memory in bytes, to be allocated in order to hold coefficients.

Description		:  

This function must be called before any calls to other functions that uses the coefs structure.
The calling app must than allocate the returned size of memory and initialize it using 'InitSVerb()'
and 'SetSVerb()'.

The caller should not be botherred by the internals of the coefs structure, rather only konw it's size 
and than allocate enough memory to hold it.

The structure allocated can be used in a very flexible way in order to allow for real-time, pre-computed
changes in Reverb Sound. 

*****************************************************************************/

long GetCoefsSize(void) 
{
	return sizeof(sCoefsStruct); 
};

/****************************************************************************

Function Name	: GetStatesSize

Input Arguments : None

Return Value    : The size of memory in bytes, to be allocated in order to hold states.

Description		:  

This function must be called before any calls to other functions that uses the states structure.
The calling app must than allocate the returned size of memory and initialize it using 'InitSVerbStates()'.

The states allocated are valid in run-time only, and sould be re-initialized only when a complete
new input is to be processed by the SVerb. 

When changing the settings of revevreb in real time while audio is playing, the states should not 
be re-initialized, rather the same passed states must be passed to the process functions in order 
to maintain sound continuity.

*****************************************************************************/

long GetStatesSize(void) 
{
	return sizeof(long)*(BASE_REV_DELAY+2*BASE_DSPS_DELAY+2); 
};

/****************************************************************************

Function Name	: GetSVerbVersion

Input Arguments : None

Return Value    : Version of SVerb implementation - for future compatibility.

Description		:  

Since the caller do not know about the internals of the coefs structure, this function,
together with 'VerifyVersion' function provides a way to verify if a coefs structure
match the version of the reverb used.

This should be needed only if one is using a coefs structure that was saved to file, and 
being used later.

NOTE : In normal operation, this way of usage should be avoided... and only real-world reverb
settings should be saved to files, and re-initialize the coefs in run time.

*****************************************************************************/

long GetSVerbVersion(void) 
{
	return 0x1; 
};

/****************************************************************************

Function Name	: VerifySampleRate

Input Arguments : 

 void *pC		: The pointer to the coefs memory.

Return Value    : The sample rate for which this coefs are valid.

Description		:  

When an application uses different sampling rates, and re-uses same coefs structures, 
it should verify that the coefs match the audio sampling rate.

*****************************************************************************/

float VerifySampleRate(void *pC) {
	return ((sCoefsStruct *)pC)->SampleRate; 
};

/****************************************************************************

Function Name	: VerifyVersion

Input Arguments : 

 void *pC		: The pointer to the coefs memory.

Return Value    : The version of this coefs structure.

Description		:  

When initialized, each coefs structure is 'stamped' with it's version.
The location of this variable in the structure is fixed, and thus all future versions of
SVerb will know to read it.

Note : as explained above, in normal uses coefs should not be saved to files, rather the 
'real-world' settings should be saved and coefs re-initialized in run-time.
*****************************************************************************/

long VerifyVersion(void *pC) {
	return ((sCoefsStruct *)pC)->myVersion; 
};

/****************************************************************************

Function Name	: VerifySize

Input Arguments : 

 void *pC		: The pointer to the coefs memory.

Return Value    : The size of this coefs structure.

Description		:  

When initialized, each coefs structure is 'stamped' with it's size.
The location of this variable in the structure is fixed, and thus all future versions of
SVerb will know to read it.

Note : as explained above, in normal uses coefs should not be saved to files, rather the 
'real-world' settings should be saved and coefs re-initialized in run-time.
*****************************************************************************/

long VerifySize(void *pC) {
	return ((sCoefsStruct *)pC)->mySize; 
};


/****************************************************************************

Function Name	: InitSVerbStates

Input Arguments : 

 float *pStates	: The pointer to the states memory.

Return Value    : none.

Description		:  

After allocating memory for the states, according to thge size returned by 'GetStatesSize'
The application MUST initialize the states using this function. 
Note : in future versions this may be more complex than simply memset to 0...
*****************************************************************************/

void InitSVerbStates( long *pStates )
{
    memset( pStates, 0, GetStatesSize() ) ;
}

/****************************************************************************

Function Name	: DToF16

Input Arguments : 

 float SampleRate	: The sampling rate.
 void *pC			: The pointer to the coefs memory.

Return Value    : none.

Description		:  

Converts a float number between -1.0 .. 1.0 to a 16bits integer 
fixed point representation.
This allows for fix point arithmetics, where two 16bits integers are multiplied to 
a 32bits integer, and we than take the upper 16 bits of the result.

*****************************************************************************/

long DToF16( float dbl  )
{
	dbl *= MAX_16;
	dbl = max(-MAX_16,min(MAX_16-(float)1.0,dbl+(float)0.5));
	return (long)(dbl);
}

/****************************************************************************

Function Name	: ConvertCoefsToFix

Input Arguments : 

 void *pC			: The pointer to the coefs memory.

Return Value    : none.

Description		:  converts coefficients to longs, as fixed point numbers

*****************************************************************************/


void ConvertCoefsToFix( void *pC )
{

	sCoefsStruct *pCoefs = ((sCoefsStruct *)pC);

//		float directGain; 

	pCoefs->l_directGain =  DToF16(pCoefs->directGain);

//		float revGain; 
	pCoefs->l_revGain =  DToF16(pCoefs->revGain);
//		float dDsps;
	pCoefs->l_dDsps =  DToF16(pCoefs->dDsps);
//		float dDG1;
	pCoefs->l_dDG1 =  DToF16(pCoefs->dDG1);
//		float dDG2; 
	pCoefs->l_dDG2 =  DToF16(pCoefs->dDG2);
//	float dFB11;
	pCoefs->l_dFB11 =  DToF16(pCoefs->dFB11);
//		float dFB12;
	pCoefs->l_dFB12 =  DToF16(pCoefs->dFB12);
//		float dFB21;
	pCoefs->l_dFB21 =  DToF16(pCoefs->dFB21);
//		float dFB22;
	pCoefs->l_dFB22 =  DToF16(pCoefs->dFB22);
//		float dFB31;
	pCoefs->l_dFB31 =  DToF16(pCoefs->dFB31);
//		float dFB32;
	pCoefs->l_dFB32 =  DToF16(pCoefs->dFB32);
//		float dFB41;
	pCoefs->l_dFB41 =  DToF16(pCoefs->dFB41);
//		float dFB42;
	pCoefs->l_dFB42 =  DToF16(pCoefs->dFB42);
//		float dDamp;
	pCoefs->l_dDamp =  DToF16(pCoefs->dDamp);



}

/****************************************************************************

Function Name	: InitSVerb

Input Arguments : 

 float SampleRate	: The sampling rate.
 void *pC			: The pointer to the coefs memory.

Return Value    : none.

Description		:  

After allocating memory for the coefs, according to thge size returned by 'GetCoefsSize'
The application MUST initialize the coefs using this function. 
The initialization takes the sampling rate as an argument, ans thus is valid per this
sampling rate only.

It is possible to find out what is the sampling rate a coefs structure is valid for by calling 
the function 'VerifySampleRate'.

This function initialises the SVerb to so reasonable default setting by calling 'SetSVerb' with
the following real-world settings :

InGain				= -3.0dB   (to avoid output overflows)
dRevMix				= -6.0dB   (a reasonable reverb mix)
dRevTime			= 1000.0ms (one second global reverb time)
dHighFreqRTRatio	= 0.001    (the ratio of the high frequencies to the global reverb time) 

*****************************************************************************/

void InitSVerb( float SampleRate, void *pC)
{

	sCoefsStruct *pCoefs = ((sCoefsStruct *)pC);
 	//Magic numbers ...
    long lRefD;
	
	float dRatio =  (float)1.189207115003;
	
	float dD2MRatio = (float)0.2309333333;

	pCoefs->mySize = sizeof(sCoefsStruct);
	pCoefs->myVersion = 0x1;

	pCoefs->dDsps =  (float)0.6180339887499;

	pCoefs->SampleRate = SampleRate;

    lRefD = (long)( 0.5 + 0.045 * pCoefs->SampleRate ) ;

	pCoefs->lDelay1 = lRefD;
	pCoefs->lDelay3 = (long)(0.5 + dRatio * (float)pCoefs->lDelay1);
	pCoefs->lDelay2 = (long)(0.5 + dRatio * (float)pCoefs->lDelay3);
	pCoefs->lDelay4 = (long)(0.5 + dRatio * (float)pCoefs->lDelay2);
  
    pCoefs->lDDly1 = (long)(0.5 + 0.5 * dD2MRatio * (float)(pCoefs->lDelay1+pCoefs->lDelay2));
	pCoefs->lDDly2 = (long)(0.5 + 0.5 * dD2MRatio * (float)(pCoefs->lDelay3+pCoefs->lDelay4));

    pCoefs->lDelay1 -= pCoefs->lDDly1 ;    
    pCoefs->lDelay2 -= pCoefs->lDDly1 ;    
    pCoefs->lDelay3 -= pCoefs->lDDly2 ;    
    pCoefs->lDelay4 -= pCoefs->lDDly2 ;        

    pCoefs->lDelay1 <<= 2;    
    pCoefs->lDelay2 <<= 2;    
    pCoefs->lDelay3 <<= 2;    
    pCoefs->lDelay4 <<= 2;        

	pCoefs->lDDly1 <<= 1;
	pCoefs->lDDly2 <<= 1;

	SetSVerb( (float)0.0, (float)-10.0, (float)1000.0, (float)0.001, pC );

}

/****************************************************************************

Function Name	: SetSVerb

Input Arguments : 

InGain				: input gain in dB (to avoid output overflows)

dRevMix				: Reverb mix in dB. 0dB means 100% wet reverb (no direct signal)
                      Negative values gives less wet signal.
					  The coeficients are calculated so that the overall output level stays 
					  (approximately) constant regardless of the ammount of reverb mix.
dRevTime			: The global reverb time (decay time) in milliseconds.

dHighFreqRTRatio	: The ratio of the high frequencies to the global reverb time. 
					  Unless very 'splashy-bright' reverbs are wanted, this should be set to 
					  a value < 1.0.
					  For example if dRevTime==1000ms and dHighFreqRTRatio=0.1 than the 
					  decay time for high frequencies will be 100ms.

void *pC			: The pointer to the coefs memory.

Return Value    : none.

Description		:  

This function accepts the 'real world' settings or SVerb and computes the corresponding 
coefs structure.

The coefs pointer passed to it MUST have been initialized first by InitSVerb.

In normal uses one coefs structure is allocated, initialized, and than as the user changes 
SVerb settings this function should be called repeatedly with the same coefs pointer and the 
new 'real world' settings. 

And the coefs structure passed to the process function in the next buffer to process.

Also few coefs structures can be pre allocated, and initialized, and than different 'presets' 
can be pre-computed into each of them, and switched in real time. 

The coefs structures should not be saved to files by the application for future uses, rather 
the 'real world' settings them selvs. This way future compatibility is guaranteed.

*****************************************************************************/

void SetSVerb( float InGain, float dRevMix, 
			   float dRevTime, float dHighFreqRTRatio, void *pC )
{


	sCoefsStruct *pCoefs = ((sCoefsStruct *)pC);

    float dD,dTmp,dInGain,dRevGain;

	float dHfR;
    float dAPS;

    if (dHighFreqRTRatio > (float) 0.999)
    {
        dHighFreqRTRatio = (float) 0.999;
    }
    if (dHighFreqRTRatio <= (float) 0.0)
    {
        dHighFreqRTRatio = (float) 0.001;
    }
    dHfR = ( (float)1.0/dHighFreqRTRatio - (float)1.0);

    if (dRevTime < (float) 0.001) 
    {
        dRevTime = (float) 0.001;
    }

    if (InGain > (float) 0.0)
    {
        InGain = (float) 0.0;
    }

    if (dRevMix > (float) 0.0)
    {
        dRevMix = (float) 0.0;
    }

    if (pCoefs->SampleRate < (float) 1.0) 
    {
        pCoefs->SampleRate = (float) 22050.0;
    }

    dAPS = (float)(-3000.0) / (pCoefs->SampleRate * dRevTime);


    pCoefs->dDamp = 0.0;

 	pCoefs->dDG1 = (float)pow((float)10.0,(float)(pCoefs->lDDly1>>1)*dAPS);
 	pCoefs->dDG2 = (float)pow((float)10.0,(float)(pCoefs->lDDly2>>1)*dAPS);

	//////////////////////////////

		pCoefs->dFB11 = (float)pow((float)10.0,(float)(pCoefs->lDelay1>>2)*dAPS);
        
		dD = pCoefs->dFB11 * pCoefs->dDG1;
        dD = (float)1.0+dD*((float)1.0+dD*((float)1.0+dD*((float)1.0 + dD)));
        pCoefs->dDamp += dD *dD;

		dTmp = (float)pow((float)10.0,(float)((pCoefs->lDDly1>>1)+(pCoefs->lDelay1>>2))*dAPS*dHfR);
		dTmp = ((float)1.0 - dTmp)*(float)0.5;

		pCoefs->dFB12 = pCoefs->dFB11 * dTmp;
		pCoefs->dFB11 *= ((float)1.0-dTmp);

	///////////////////////////////

		pCoefs->dFB21 = (float)pow((float)10.0,(float)(pCoefs->lDelay2>>2)*dAPS);
        
		dD = pCoefs->dFB21 * pCoefs->dDG1;
        dD = (float)1.0+dD*((float)1.0+dD*((float)1.0+dD*((float)1.0 + dD)));
        pCoefs->dDamp += dD *dD;

		dTmp = (float)pow((float)10.0,(float)((pCoefs->lDDly1>>1)+(pCoefs->lDelay2>>2))*dAPS*dHfR);
		dTmp = ((float)1.0 - dTmp)*(float)0.5;

		pCoefs->dFB22 = pCoefs->dFB21 * dTmp;
		pCoefs->dFB21 *= ((float)1.0-dTmp);

	////////////////////////////////

		pCoefs->dFB31 = (float)pow((float)10.0,(float)(pCoefs->lDelay3>>2)*dAPS);
        
		dD = pCoefs->dFB31 * pCoefs->dDG2;
        dD = (float)1.0+dD*((float)1.0+dD*((float)1.0+dD*((float)1.0 + dD)));
		    pCoefs->dDamp += dD *dD;

		dTmp = (float)pow((float)10.0,(float)((pCoefs->lDDly2>>1)+(pCoefs->lDelay3>>2))*dAPS*dHfR);
		dTmp = ((float)1.0 - dTmp)*(float)0.5;

		pCoefs->dFB32 = pCoefs->dFB31 * dTmp;
		pCoefs->dFB31 *= ((float)1.0-dTmp);


	//////////////////////////////

		pCoefs->dFB41 = (float)pow((float)10.0,(float)(pCoefs->lDelay4>>2)*dAPS);

        dD = pCoefs->dFB41 * pCoefs->dDG2;
        dD = (float)1.0+dD*((float)1.0+dD*((float)1.0+dD*((float)1.0 + dD)));
        pCoefs->dDamp += dD *dD;

		dTmp = (float)pow((float)10.0,(float)((pCoefs->lDDly2>>1)+(pCoefs->lDelay4>>2))*dAPS*dHfR);
		dTmp = ((float)1.0 - dTmp)*(float)0.5;

		pCoefs->dFB42 = pCoefs->dFB41 * dTmp;
		pCoefs->dFB41 *= ((float)1.0-dTmp);


    pCoefs->dDamp = (float)sqrt(pCoefs->dDamp);

 	dInGain = (float)pow((float)10.0, (float)0.05*InGain ) ;
	dRevMix = (float)pow((float)10.0,(float)0.1*dRevMix);

	dRevGain = (float)4.0 / pCoefs->dDamp * dInGain;

	//in the DSP we used -  	 
	

	pCoefs->directGain = dInGain * (float)sqrt((float)1.0-dRevMix);
	pCoefs->revGain = dRevGain * (float)sqrt(dRevMix);

	ConvertCoefsToFix( pC );

}

///////////////////////////////////////////////////////////////////////////////////////
/**************************************************************************************/
/**************************************************************************************/
/**************************************************************************************/
/**************************************************************************************/
/* Process functions */
/**************************************************************************************/
/**************************************************************************************/
/**************************************************************************************/

/**********************************************************************************

Bellow are 6 different process functions.
The difference between the functions is only in the input/output data formats.

3 functions support short samples input/output.
3 other functions support float samples input/output.

Per each of the data types there are 3 functions :

  Mono-Mono
  Mono-Stereo
  Stereo-Stereo

The names of the functions are clear to which format they apply.

Stereo data is always interlaced left,right samples.

All process functions have basically the same format namely :

  SVerbXXXXXX(long NumInFrames, short *pInShort, short *pOutShort, 
			  void *pC, float *pStates)

Input arguments :

long NumInFrames	: Number of input frames
short *pInXXX		: Pointer to input buffer.
					  Each function expects the data format suggested by it's name in terms of
					  data type (short or float) and mono/stereo.
short *pOutXXX		: Pointer to output buffer.
					  Each function expects the data format suggested by it's name in terms of
					  data type (short or float) and mono/stereo.

void *pC			: The coefs structure allocated and initialized as explained above.
float *pStates		: The states structure allocated and initialized as explained above.

*******************************************************************************************/

void SVerbMonoToMonoShort(long NumInFrames, short *pInShort, short *pOutShort, 
						  void *pC, long *pStates)
{

	sCoefsStruct *pCoefs =  ((sCoefsStruct *)pC);
	long n_sample;
	long In1, In2, Out1, Out2;
	long Indx1,Indx2,Indx3,Indx4;
	long *pNewDll1, *pNewDll2, *pNewDll3, *pNewDll4;
	long *pPrevDll1, *pPrevDll2, *pPrevDll3, *pPrevDll4, *pDelayIn;
	long	*pDelay = pStates+2;
	long	*pDD1	 = pDelay+0x4000;
	long	*pDD2	 = pDD1+0x800;
	long Indx = ((long *)pStates)[0];
	long DIndx = ((long *)pStates)[1] ;

	Indx1 = (Indx+4+pCoefs->lDelay1) & REV_MASK;
	Indx2 = (Indx+4+pCoefs->lDelay2) & REV_MASK;
	Indx3 = (Indx+4+pCoefs->lDelay3) & REV_MASK;
	Indx4 = (Indx+4+pCoefs->lDelay4) & REV_MASK;

	pPrevDll1 = pDelay+Indx1;
	pPrevDll2 = pDelay+Indx2+1;
	pPrevDll3 = pDelay+Indx3+2;
	pPrevDll4 = pDelay+Indx4+3;

	Indx1 = (Indx1-4)&REV_MASK;
	Indx2 = (Indx2-4)&REV_MASK;
	Indx3 = (Indx3-4)&REV_MASK;
	Indx4 = (Indx4-4)&REV_MASK;

		for (n_sample = 0;n_sample < NumInFrames;n_sample++)
		{

			In1 = In2 = (long)(*pInShort++)>>1;

			Out1 = (In1 * pCoefs->l_directGain)>>15;

			Out2 = (In2 * pCoefs->l_directGain)>>15;

			In1 = (In1 * pCoefs->l_revGain)>>15;

			In2 = (In2 * pCoefs->l_revGain)>>15;

			pNewDll1 = pDelay+Indx1;
			pNewDll2 = pDelay+Indx2+1;
			pNewDll3 = pDelay+Indx3+2;
			pNewDll4 = pDelay+Indx4+3;

			dspsL( pDD1, DIndx, pCoefs->lDDly1, pCoefs->l_dDG1, pCoefs->l_dDsps, pNewDll1, pNewDll2 );
			dspsL( pDD2, DIndx, pCoefs->lDDly2, pCoefs->l_dDG2, pCoefs->l_dDsps, pNewDll3, pNewDll4 );

			Out1 += *pNewDll1 + *pNewDll3;
			Out2 += *pNewDll2 + *pNewDll4;

			pDelayIn = pDelay + Indx;

			*pDelayIn++ = In1 + ((*pNewDll1*pCoefs->l_dFB11 + *pPrevDll1*pCoefs->l_dFB12)>>15);
			pPrevDll1 = pNewDll1;
			Indx1 = (Indx1 - 4) & REV_MASK;

			*pDelayIn++ = In2 + ((*pNewDll2*pCoefs->l_dFB21 + *pPrevDll2*pCoefs->l_dFB22)>>15);			
			pPrevDll2 = pNewDll2;
			Indx2 = (Indx2 - 4) & REV_MASK;

			*pDelayIn++ = -In2 + ((*pNewDll3*pCoefs->l_dFB31 + *pPrevDll3*pCoefs->l_dFB32)>>15);
			pPrevDll3 = pNewDll3;
			Indx3 = (Indx3 - 4) & REV_MASK;

			*pDelayIn++ = In1 + ((*pNewDll4*pCoefs->l_dFB41 + *pPrevDll4*pCoefs->l_dFB42)>>15);
			pPrevDll4 = pNewDll4;
			Indx4 = (Indx4 - 4) & REV_MASK;

			Indx = (Indx - 4) & REV_MASK;
			DIndx = (DIndx - 2) & DSPS_MASK;

			Out1 += Out2;
			CLIP_SHORT_TO_SHORT(Out1)

			*pOutShort++ = (short)(Out1);
			
		}

	((long *)pStates)[0] = Indx ;
	((long *)pStates)[1] = DIndx ;

}

#ifdef USE_ALL_VERBS
void SVerbMonoToStereoShort(long NumInFrames, short *pInShort, short *pOutShort, 
						    void *pC, long *pStates)
{

	sCoefsStruct *pCoefs = ((sCoefsStruct *)pC);
	long n_sample;
	long In1, In2, Out1, Out2;
	long Indx1,Indx2,Indx3,Indx4;
	long *pNewDll1, *pNewDll2, *pNewDll3, *pNewDll4;
	long *pPrevDll1, *pPrevDll2, *pPrevDll3, *pPrevDll4, *pDelayIn;
	long	*pDelay = pStates+2;
	long	*pDD1	 = pDelay+0x4000;
	long	*pDD2	 = pDD1+0x800;
	long Indx = ((long *)pStates)[0];
	long DIndx = ((long *)pStates)[1] ;

	Indx1 = (Indx+4+pCoefs->lDelay1) & REV_MASK;
	Indx2 = (Indx+4+pCoefs->lDelay2) & REV_MASK;
	Indx3 = (Indx+4+pCoefs->lDelay3) & REV_MASK;
	Indx4 = (Indx+4+pCoefs->lDelay4) & REV_MASK;

	pPrevDll1 = pDelay+Indx1;
	pPrevDll2 = pDelay+Indx2+1;
	pPrevDll3 = pDelay+Indx3+2;
	pPrevDll4 = pDelay+Indx4+3;

	Indx1 = (Indx1-4)&REV_MASK;
	Indx2 = (Indx2-4)&REV_MASK;
	Indx3 = (Indx3-4)&REV_MASK;
	Indx4 = (Indx4-4)&REV_MASK;

		for (n_sample = 0;n_sample < NumInFrames;n_sample++)
		{

			In1 = (long)(*pInShort++);
			In1 += (In1>>1) - (In1>>2);
			In2 = In1;

			Out1 = (In1 * pCoefs->l_directGain)>>15;

			Out2 = (In2 * pCoefs->l_directGain)>>15;

			In1 = (In1 * pCoefs->l_revGain)>>15;

			In2 = (In2 * pCoefs->l_revGain)>>15;

			pNewDll1 = pDelay+Indx1;
			pNewDll2 = pDelay+Indx2+1;
			pNewDll3 = pDelay+Indx3+2;
			pNewDll4 = pDelay+Indx4+3;

			dspsL( pDD1, DIndx, pCoefs->lDDly1, pCoefs->l_dDG1, pCoefs->l_dDsps, pNewDll1, pNewDll2 );
			dspsL( pDD2, DIndx, pCoefs->lDDly2, pCoefs->l_dDG2, pCoefs->l_dDsps, pNewDll3, pNewDll4 );

			Out1 += *pNewDll1 + *pNewDll3;
			Out2 += *pNewDll2 + *pNewDll4;

			pDelayIn = pDelay + Indx;

			*pDelayIn++ = In1 + ((*pNewDll1*pCoefs->l_dFB11 + *pPrevDll1*pCoefs->l_dFB12)>>15);
			pPrevDll1 = pNewDll1;
			Indx1 = (Indx1 - 4) & REV_MASK;

			*pDelayIn++ = In2 + ((*pNewDll2*pCoefs->l_dFB21 + *pPrevDll2*pCoefs->l_dFB22)>>15);			
			pPrevDll2 = pNewDll2;
			Indx2 = (Indx2 - 4) & REV_MASK;

			*pDelayIn++ = -In2 + ((*pNewDll3*pCoefs->l_dFB31 + *pPrevDll3*pCoefs->l_dFB32)>>15);
			pPrevDll3 = pNewDll3;
			Indx3 = (Indx3 - 4) & REV_MASK;

			*pDelayIn++ = In1 + ((*pNewDll4*pCoefs->l_dFB41 + *pPrevDll4*pCoefs->l_dFB42)>>15);
			pPrevDll4 = pNewDll4;
			Indx4 = (Indx4 - 4) & REV_MASK;

			Indx = (Indx - 4) & REV_MASK;
			DIndx = (DIndx - 2) & DSPS_MASK;

			CLIP_SHORT_TO_SHORT(Out1)
			CLIP_SHORT_TO_SHORT(Out2)

			*pOutShort++ = (short)(Out1);
			*pOutShort++ = (short)(Out2);
			
		}

	((long *)pStates)[0] = Indx ;
	((long *)pStates)[1] = DIndx ;

}
#endif

void SVerbStereoToStereoShort(long NumInFrames, short *pInShort, short *pOutShort, 
						      void *pC, long *pStates)
{

	sCoefsStruct *pCoefs = ((sCoefsStruct *)pC);
	long n_sample;
	long In1, In2, Out1, Out2;
	long Indx1,Indx2,Indx3,Indx4;
	long *pNewDll1, *pNewDll2, *pNewDll3, *pNewDll4;
	long *pPrevDll1, *pPrevDll2, *pPrevDll3, *pPrevDll4, *pDelayIn;
	long	*pDelay = pStates+2;
	long	*pDD1	 = pDelay+0x4000;
	long	*pDD2	 = pDD1+0x800;
	long Indx = ((long *)pStates)[0];
	long DIndx = ((long *)pStates)[1] ;

	Indx1 = (Indx+4+pCoefs->lDelay1) & REV_MASK;
	Indx2 = (Indx+4+pCoefs->lDelay2) & REV_MASK;
	Indx3 = (Indx+4+pCoefs->lDelay3) & REV_MASK;
	Indx4 = (Indx+4+pCoefs->lDelay4) & REV_MASK;

	pPrevDll1 = pDelay+Indx1;
	pPrevDll2 = pDelay+Indx2+1;
	pPrevDll3 = pDelay+Indx3+2;
	pPrevDll4 = pDelay+Indx4+3;

	Indx1 = (Indx1-4)&REV_MASK;
	Indx2 = (Indx2-4)&REV_MASK;
	Indx3 = (Indx3-4)&REV_MASK;
	Indx4 = (Indx4-4)&REV_MASK;

		for (n_sample = 0;n_sample < NumInFrames;n_sample++)
		{

			In1 = (long)(*pInShort++);
			In2 = (long)(*pInShort++);

			Out1 = (In1 * pCoefs->l_directGain)>>15;

			Out2 = (In2 * pCoefs->l_directGain)>>15;

			In1 = (In1 * pCoefs->l_revGain)>>15;

			In2 = (In2 * pCoefs->l_revGain)>>15;

			pNewDll1 = pDelay+Indx1;
			pNewDll2 = pDelay+Indx2+1;
			pNewDll3 = pDelay+Indx3+2;
			pNewDll4 = pDelay+Indx4+3;

			dspsL( pDD1, DIndx, pCoefs->lDDly1, pCoefs->l_dDG1, pCoefs->l_dDsps, pNewDll1, pNewDll2 );
			dspsL( pDD2, DIndx, pCoefs->lDDly2, pCoefs->l_dDG2, pCoefs->l_dDsps, pNewDll3, pNewDll4 );

			Out1 += *pNewDll1 + *pNewDll3;
			Out2 += *pNewDll2 + *pNewDll4;

			pDelayIn = pDelay + Indx;

			*pDelayIn++ = In1 + ((*pNewDll1*pCoefs->l_dFB11 + *pPrevDll1*pCoefs->l_dFB12)>>15);
			pPrevDll1 = pNewDll1;
			Indx1 = (Indx1 - 4) & REV_MASK;

			*pDelayIn++ = In2 + ((*pNewDll2*pCoefs->l_dFB21 + *pPrevDll2*pCoefs->l_dFB22)>>15);			
			pPrevDll2 = pNewDll2;
			Indx2 = (Indx2 - 4) & REV_MASK;

			*pDelayIn++ = -In2 + ((*pNewDll3*pCoefs->l_dFB31 + *pPrevDll3*pCoefs->l_dFB32)>>15);
			pPrevDll3 = pNewDll3;
			Indx3 = (Indx3 - 4) & REV_MASK;

			*pDelayIn++ = In1 + ((*pNewDll4*pCoefs->l_dFB41 + *pPrevDll4*pCoefs->l_dFB42)>>15);
			pPrevDll4 = pNewDll4;
			Indx4 = (Indx4 - 4) & REV_MASK;

			Indx = (Indx - 4) & REV_MASK;
			DIndx = (DIndx - 2) & DSPS_MASK;

			CLIP_SHORT_TO_SHORT(Out1)
			CLIP_SHORT_TO_SHORT(Out2)

			*pOutShort++ = (short)(Out1);
			*pOutShort++ = (short)(Out2);
		}

	((long *)pStates)[0] = Indx ;
	((long *)pStates)[1] = DIndx ;

}

#ifdef USE_ALL_VERBS

void SVerbMonoToMonoFloat(long NumInFrames, float *pInFloat, float *pOutFloat, 
						  void *pC, float *pStates)
{

	sCoefsStruct *pCoefs = ((sCoefsStruct *)pC);
	long n_sample;
	float In1, In2, Out1, Out2;
	long Indx1,Indx2,Indx3,Indx4;
	float *pNewDll1, *pNewDll2, *pNewDll3, *pNewDll4;
	float *pPrevDll1, *pPrevDll2, *pPrevDll3, *pPrevDll4, *pDelayIn;
	float	*pDelay = pStates+2;
	float	*pDD1	 = pDelay+0x4000;
	float	*pDD2	 = pDD1+0x800;
	long Indx = ((long *)pStates)[0];
	long DIndx = ((long *)pStates)[1] ;

	Indx1 = (Indx+4+pCoefs->lDelay1) & REV_MASK;
	Indx2 = (Indx+4+pCoefs->lDelay2) & REV_MASK;
	Indx3 = (Indx+4+pCoefs->lDelay3) & REV_MASK;
	Indx4 = (Indx+4+pCoefs->lDelay4) & REV_MASK;

	pPrevDll1 = pDelay+Indx1;
	pPrevDll2 = pDelay+Indx2+1;
	pPrevDll3 = pDelay+Indx3+2;
	pPrevDll4 = pDelay+Indx4+3;

	Indx1 = (Indx1-4)&REV_MASK;
	Indx2 = (Indx2-4)&REV_MASK;
	Indx3 = (Indx3-4)&REV_MASK;
	Indx4 = (Indx4-4)&REV_MASK;

		for (n_sample = 0;n_sample < NumInFrames;n_sample++)
		{

			In1 = In2 = (float)0.5 * (*pInFloat++) + FPU_DENORM_OFFS;

			Out1 = In1 * pCoefs->directGain;
			Out2 = In2 * pCoefs->directGain;

			In1 *= pCoefs->revGain;
			In2 *= pCoefs->revGain;

			pNewDll1 = pDelay+Indx1;
			pNewDll2 = pDelay+Indx2+1;
			pNewDll3 = pDelay+Indx3+2;
			pNewDll4 = pDelay+Indx4+3;

			dsps( pDD1, DIndx, pCoefs->lDDly1, pCoefs->dDG1, pCoefs->dDsps, pNewDll1, pNewDll2 );
			dsps( pDD2, DIndx, pCoefs->lDDly2, pCoefs->dDG2, pCoefs->dDsps, pNewDll3, pNewDll4 );

			Out1 += *pNewDll1 + *pNewDll3;
			Out2 += *pNewDll2 + *pNewDll4;

			pDelayIn = pDelay + Indx;

			*pDelayIn++ = In1 + *pNewDll1*pCoefs->dFB11 + *pPrevDll1*pCoefs->dFB12;
			pPrevDll1 = pNewDll1;
			Indx1 = (Indx1 - 4) & REV_MASK;

			*pDelayIn++ = In2 + *pNewDll2*pCoefs->dFB21 + *pPrevDll2*pCoefs->dFB22;
			pPrevDll2 = pNewDll2;
			Indx2 = (Indx2 - 4) & REV_MASK;

			*pDelayIn++ = -In2 + *pNewDll3*pCoefs->dFB31 + *pPrevDll3*pCoefs->dFB32;
			pPrevDll3 = pNewDll3;
			Indx3 = (Indx3 - 4) & REV_MASK;

			*pDelayIn++ = In1 + *pNewDll4*pCoefs->dFB41 + *pPrevDll4*pCoefs->dFB42;
			pPrevDll4 = pNewDll4;
			Indx4 = (Indx4 - 4) & REV_MASK;

			Indx = (Indx - 4) & REV_MASK;
			DIndx = (DIndx - 2) & DSPS_MASK;

			*pOutFloat++ = Out1+Out2;
			
		}

	((long *)pStates)[0] = Indx ;
	((long *)pStates)[1] = DIndx ;

}

void SVerbMonoToStereoFloat(long NumInFrames, float *pInFloat, float *pOutFloat, 
						    void *pC, float *pStates)
{

	sCoefsStruct *pCoefs = ((sCoefsStruct *)pC);
	long n_sample;
	float In1, In2, Out1, Out2;
	long Indx1,Indx2,Indx3,Indx4;
	float *pNewDll1, *pNewDll2, *pNewDll3, *pNewDll4;
	float *pPrevDll1, *pPrevDll2, *pPrevDll3, *pPrevDll4, *pDelayIn;
	float	*pDelay = pStates+2;
	float	*pDD1	 = pDelay+0x4000;
	float	*pDD2	 = pDD1+0x800;
	long Indx = ((long *)pStates)[0];
	long DIndx = ((long *)pStates)[1] ;

	Indx1 = (Indx+4+pCoefs->lDelay1) & REV_MASK;
	Indx2 = (Indx+4+pCoefs->lDelay2) & REV_MASK;
	Indx3 = (Indx+4+pCoefs->lDelay3) & REV_MASK;
	Indx4 = (Indx+4+pCoefs->lDelay4) & REV_MASK;

	pPrevDll1 = pDelay+Indx1;
	pPrevDll2 = pDelay+Indx2+1;
	pPrevDll3 = pDelay+Indx3+2;
	pPrevDll4 = pDelay+Indx4+3;

	Indx1 = (Indx1-4)&REV_MASK;
	Indx2 = (Indx2-4)&REV_MASK;
	Indx3 = (Indx3-4)&REV_MASK;
	Indx4 = (Indx4-4)&REV_MASK;

		for (n_sample = 0;n_sample < NumInFrames;n_sample++)
		{

			In1 = In2 = (float)0.7071 * (*pInFloat++) + FPU_DENORM_OFFS;

			Out1 = In1 * pCoefs->directGain;
			Out2 = In2 * pCoefs->directGain;

			In1 *= pCoefs->revGain;
			In2 *= pCoefs->revGain;

			pNewDll1 = pDelay+Indx1;
			pNewDll2 = pDelay+Indx2+1;
			pNewDll3 = pDelay+Indx3+2;
			pNewDll4 = pDelay+Indx4+3;

			dsps( pDD1, DIndx, pCoefs->lDDly1, pCoefs->dDG1, pCoefs->dDsps, pNewDll1, pNewDll2 );
			dsps( pDD2, DIndx, pCoefs->lDDly2, pCoefs->dDG2, pCoefs->dDsps, pNewDll3, pNewDll4 );

			Out1 += *pNewDll1 + *pNewDll3;
			Out2 += *pNewDll2 + *pNewDll4;

			pDelayIn = pDelay + Indx;

			*pDelayIn++ = In1 + *pNewDll1*pCoefs->dFB11 + *pPrevDll1*pCoefs->dFB12;
			pPrevDll1 = pNewDll1;
			Indx1 = (Indx1 - 4) & REV_MASK;

			*pDelayIn++ = In2 + *pNewDll2*pCoefs->dFB21 + *pPrevDll2*pCoefs->dFB22;
			pPrevDll2 = pNewDll2;
			Indx2 = (Indx2 - 4) & REV_MASK;

			*pDelayIn++ = -In2 + *pNewDll3*pCoefs->dFB31 + *pPrevDll3*pCoefs->dFB32;
			pPrevDll3 = pNewDll3;
			Indx3 = (Indx3 - 4) & REV_MASK;

			*pDelayIn++ = In1 + *pNewDll4*pCoefs->dFB41 + *pPrevDll4*pCoefs->dFB42;
			pPrevDll4 = pNewDll4;
			Indx4 = (Indx4 - 4) & REV_MASK;

			Indx = (Indx - 4) & REV_MASK;
			DIndx = (DIndx - 2) & DSPS_MASK;

			*pOutFloat++ = Out1;
			*pOutFloat++ = Out2;
			
		}

	((long *)pStates)[0] = Indx ;
	((long *)pStates)[1] = DIndx ;

}

void SVerbStereoToStereoFloat(long NumInFrames, float *pInFloat, float *pOutFloat, 
						      void *pC, float *pStates)
{

	sCoefsStruct *pCoefs = ((sCoefsStruct *)pC);
	long n_sample;
	float In1, In2, Out1, Out2;
	long Indx1,Indx2,Indx3,Indx4;
	float *pNewDll1, *pNewDll2, *pNewDll3, *pNewDll4;
	float *pPrevDll1, *pPrevDll2, *pPrevDll3, *pPrevDll4, *pDelayIn;
	float	*pDelay = pStates+2;
	float	*pDD1	 = pDelay+0x4000;
	float	*pDD2	 = pDD1+0x800;
	long Indx = ((long *)pStates)[0];
	long DIndx = ((long *)pStates)[1] ;

	Indx1 = (Indx+4+pCoefs->lDelay1) & REV_MASK;
	Indx2 = (Indx+4+pCoefs->lDelay2) & REV_MASK;
	Indx3 = (Indx+4+pCoefs->lDelay3) & REV_MASK;
	Indx4 = (Indx+4+pCoefs->lDelay4) & REV_MASK;

	pPrevDll1 = pDelay+Indx1;
	pPrevDll2 = pDelay+Indx2+1;
	pPrevDll3 = pDelay+Indx3+2;
	pPrevDll4 = pDelay+Indx4+3;

	Indx1 = (Indx1-4)&REV_MASK;
	Indx2 = (Indx2-4)&REV_MASK;
	Indx3 = (Indx3-4)&REV_MASK;
	Indx4 = (Indx4-4)&REV_MASK;

		for (n_sample = 0;n_sample < NumInFrames;n_sample++)
		{

			In1 = (*pInFloat++) + FPU_DENORM_OFFS;
			In2 = (*pInFloat++) + FPU_DENORM_OFFS;

			Out1 = In1 * pCoefs->directGain;
			Out2 = In2 * pCoefs->directGain;

			In1 *= pCoefs->revGain;
			In2 *= pCoefs->revGain;

			pNewDll1 = pDelay+Indx1;
			pNewDll2 = pDelay+Indx2+1;
			pNewDll3 = pDelay+Indx3+2;
			pNewDll4 = pDelay+Indx4+3;

			dsps( pDD1, DIndx, pCoefs->lDDly1, pCoefs->dDG1, pCoefs->dDsps, pNewDll1, pNewDll2 );
			dsps( pDD2, DIndx, pCoefs->lDDly2, pCoefs->dDG2, pCoefs->dDsps, pNewDll3, pNewDll4 );

			Out1 += *pNewDll1 + *pNewDll3;
			Out2 += *pNewDll2 + *pNewDll4;

			pDelayIn = pDelay + Indx;

			*pDelayIn++ = In1 + *pNewDll1*pCoefs->dFB11 + *pPrevDll1*pCoefs->dFB12;
			pPrevDll1 = pNewDll1;
			Indx1 = (Indx1 - 4) & REV_MASK;

			*pDelayIn++ = In2 + *pNewDll2*pCoefs->dFB21 + *pPrevDll2*pCoefs->dFB22;
			pPrevDll2 = pNewDll2;
			Indx2 = (Indx2 - 4) & REV_MASK;

			*pDelayIn++ = -In2 + *pNewDll3*pCoefs->dFB31 + *pPrevDll3*pCoefs->dFB32;
			pPrevDll3 = pNewDll3;
			Indx3 = (Indx3 - 4) & REV_MASK;

			*pDelayIn++ = In1 + *pNewDll4*pCoefs->dFB41 + *pPrevDll4*pCoefs->dFB42;
			pPrevDll4 = pNewDll4;
			Indx4 = (Indx4 - 4) & REV_MASK;

			Indx = (Indx - 4) & REV_MASK;
			DIndx = (DIndx - 2) & DSPS_MASK;

			*pOutFloat++ = Out1;
			*pOutFloat++ = Out2;
			
		}

	((long *)pStates)[0] = Indx ;
	((long *)pStates)[1] = DIndx ;

}

__inline void dsps( float *pDly, long ref, long delay, float dDG1, float dDsps, float *inL, float *inR )
{
	float outL, outR;
	float *pDlyOut; 

    pDlyOut = pDly + ((ref+delay) & DSPS_MASK);
    pDly += (ref & DSPS_MASK);

    outL = dDG1 * (*pDlyOut++) + *inR * dDsps;
	outR = dDG1 * (*pDlyOut) - *inL * dDsps ;

    // here we feed back the output.
	*pDly++ = *inL + dDsps * outR ;
	*pDly = *inR - dDsps * outL ;

	*inL = outL;
	*inR = outR;

}
#endif

__inline void dspsL( long *pDly, long ref, long delay, long dDG1, long dDsps, long *inL, long *inR )
{
	long outL, outR;
	long *pDlyOut; 

    pDlyOut = pDly + ((ref+delay) & DSPS_MASK);
    pDly += (ref & DSPS_MASK);

    outL = (dDG1 * (*pDlyOut++) + *inR * dDsps)>>15;

	outR = (dDG1 * (*pDlyOut) - *inL * dDsps)>>15;

    // here we feed back the output.
	*pDly++ = *inL + ((dDsps * outR)>>15) ;

	*pDly = *inR - ((dDsps * outL)>>15) ;

	*inL = outL;
	*inR = outR;

}
#pragma optimize( "ty", off )
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\XboxSynth\synth.h ===
//      Synth.h
//      Copyright (c) 1996-1999 Microsoft Corporation
//

/*  For internal representation, volume is stored in Volume Cents, 
    where each increment represents 1/100 of a dB.
    Pitch is stored in Pitch Cents, where each increment
    represents 1/100 of a semitone.
*/ 

#ifndef __SYNTH_H__
#define __SYNTH_H__

#pragma warning(disable:4296)

#include "clist.h"
#include "dmdls.h"
#include "dls2.h"
#include "dsound.h"   
#include "dmusicc.h"

#ifdef DBG
extern DWORD sdwDebugLevel;
#endif

#define MIDI_NOTEOFF    0x80
#define MIDI_NOTEON     0x90
#define MIDI_PTOUCH     0xA0
#define MIDI_CCHANGE    0xB0
#define MIDI_PCHANGE    0xC0
#define MIDI_MTOUCH     0xD0
#define MIDI_PBEND      0xE0
#define MIDI_SYSX       0xF0
#define MIDI_MTC        0xF1
#define MIDI_SONGPP     0xF2
#define MIDI_SONGS      0xF3
#define MIDI_EOX        0xF7
#define MIDI_CLOCK      0xF8
#define MIDI_START      0xFA
#define MIDI_CONTINUE   0xFB
#define MIDI_STOP       0xFC
#define MIDI_SENSE      0xFE

// controller numbers
#define CC_BANKSELECTH  0x00
#define CC_BANKSELECTL  0x20

#define CC_MODWHEEL     0x01
#define CC_VOLUME       0x07
#define CC_PAN          0x0A
#define CC_EXPRESSION   0x0B
#define CC_SUSTAIN      0x40
#define CC_CUTOFFFREQ   0x4A
#define CC_REVERB       0x5B
#define CC_CHORUS       0x5D
#define CC_ALLSOUNDSOFF 0x78
#define CC_RESETALL     0x79
#define CC_ALLNOTESOFF  0x7B
#define CC_MONOMODE     0x7E
#define CC_POLYMODE     0x7F

// rpn controllers
#define CC_DATAENTRYMSB 0x06
#define CC_DATAENTRYLSB 0x26
#define CC_NRPN_LSB     0x62
#define CC_NRPN_MSB     0x63
#define CC_RPN_LSB      0x64
#define CC_RPN_MSB      0x65

// registered parameter numbers
#define RPN_PITCHBEND   0x00
#define RPN_FINETUNE    0x01
#define RPN_COARSETUNE  0x02

/*  Sample format and Sample playback flags are organized
    together because together they determine which 
    mix loop to use.
*/

#define SFORMAT_16              1       // Sixteen bit sample.
#define SFORMAT_8               2       // Eight bit sample.
#define SPLAY_MMX               0x10    // Use MMX processor (16 bit only).
#define SPLAY_INTERLEAVED       0x40    // Interleave Buffer 
#define SPLAY_FILTERED          0x80    // Non-trivial filter coeff's


/*  Output buffer format flags, defines whether the buffers being
    played are multi-buffer, interleave or just plain mono
*/
#define BUFFERFLAG_MONO         0x00000000
#define BUFFERFLAG_INTERLEAVED  0x00000001
#define BUFFERFLAG_MULTIBUFFER  0x00000002


typedef long    PREL;   // Pitch cents, for relative pitch.
typedef short   PRELS;  // Pitch cents, in storage form.
typedef long    VREL;   // Volume cents, for relative volume.
typedef short   VRELS;  // Volume cents, in storage form.
typedef long    TREL;   // Time cents, for relative time
typedef short   TRELS;  // Time Cents, in storage form.
typedef LONGLONG    STIME;  // Time value, in samples.
typedef long    MTIME;  // Time value, in milliseconds.
typedef long    PFRACT; // Pitch increment, where upper 20 bits are
                        // the index and the lower 12 are the fractional
                        // component.
typedef long    VFRACT; // Volume, where lower 12 bits are the fraction.

typedef long    TCENT;
typedef short   SPERCENT;

#define COEFF_UNITY 0x40000000  // 1.0 multiplier as a 2.30 number
typedef unsigned long COEFF;    // 2.30 fixed point filter coefficient
typedef long COEFFDELTA;        // 2.30 fixed point filter coefficient delta value

#define FILTER_PARMS_DIM_Q  16      // the number of different resonances in the filter parameter table (rows)
#define FILTER_PARMS_DIM_FC 89      // the number of different cutoff frequencies in the filter parameter table (cols)
#define FILTER_FREQ_RANGE   10688   // the difference in pitch cents between the sample rate of the filter design and the 

#define MAX_VOLUME      0       // No attenuation and no amplification 
#define MIN_VOLUME     -9600    // Below 96 db down is considered off.
#define PERCEIVED_MIN_VOLUME   -8000   // But, we cheat.
#define SAMPLE_RATE_22  22050   // 22 kHz is the standard rate.
#define SAMPLE_RATE_44  44100   // 44 kHz is the high quality rate.
#define SAMPLE_RATE_11  11025   // 11 kHz should not be allowed!
#define STEREO_ON       1
#define STEREO_OFF      0

#define MAX_DAUD_CHAN 32

#define FORCEBOUNDS(data,min,max) {if (data < min) data = min; else if (data > max) data = max;}

class CControlLogic;

/*
>>>>>>>>> comment 
*/

class CBusIds
{
public:
    CBusIds();
    ~CBusIds();

    HRESULT     Initialize();
    HRESULT     AssignBuses(LPDWORD pdwBusIds, DWORD dwBusCount);

public:
    DWORD       m_dwBusCount;               // Number of Bus Id's
    DWORD       m_dwBusIds[MAX_DAUD_CHAN];  // Array of bus IDs 
};

/*  CSourceLFO is the file format definition of the LFO in an
    instrument. This is used to represent an LFO as part of
    a specific articulation set within an instrument that
    has been loaded from disk. Once the instrument is chosen
    to play a note, this is also copied into the CVoice
    object.
*/

class CSourceLFO
{
public:
                CSourceLFO();
    void        Init(DWORD dwSampleRate);
    void        SetSampleRate(long lDirection);
    void        Verify();           // Verifies that the data is valid.
    PFRACT      m_pfFrequency;      // Frequency, in increments through the sine table.
    STIME       m_stDelay;          // How long to delay in sample units.
    VRELS       m_vrMWVolumeScale;  // Scaling of volume LFO by Mod Wheel.
    PRELS       m_prMWPitchScale;   // Scaling of pitch LFO by Mod Wheel.
    VRELS       m_vrVolumeScale;    // Scaling of straight volume signal from LFO.
    PRELS       m_prPitchScale;     // Scaling of straight pitch signal from LFO.

    /* DirectX8 members */
    PRELS       m_prCPPitchScale;   // Scaling of pitch signal from channel pressure. 
    VRELS       m_vrCPVolumeScale;  // Scaling of volume signal from channel pressure.
//>>>>>>>> comments 
    PRELS       m_prCutoffScale;    // Scaling of Cutoff feq >>>>>> 
    PRELS       m_prMWCutoffScale;  // Scaling of Cutoff feq mod wheel
    PRELS       m_prCPCutoffScale;  // Scaling of Cutoff feq channel pressure
};

/*  CSourceEG is the file format definition of an Envelope
    generator in an instrument.
*/

class CSourceEG
{
public:
                CSourceEG();
    void        SetSampleRate(long lDirection);
    void        Init();
    void        Verify();           // Verifies valid data.
    STIME       m_stAttack;         // Attack rate.
    STIME       m_stDecay;          // Decay rate.
    STIME       m_stRelease;        // Release rate.
    TRELS       m_trVelAttackScale; // Scaling of attack by note velocity.
    TRELS       m_trKeyDecayScale;  // Scaling of decay by note value.
    SPERCENT    m_pcSustain;        // Sustain level.
    short       m_sScale;           // Scaling of entire signal.

    /* DLS2 */
    STIME       m_stDelay;          // Delay rate.
    STIME       m_stHold;           // Hold rate.
    TRELS       m_trKeyHoldScale;   // Scaling of Hold by note value.
//>>>>>>>> comments 
    PRELS       m_prCutoffScale;    // Scaling of Cutoff feq >>>>>>
};

//>>>>>>>> comments 

class CSourceFilter
{
public:
                CSourceFilter();
    void        SetSampleRate(long lDirection);          
    void        Init(DWORD dwSampleRate);
    void        Verify();

    PRELS       m_prSampleRate;     // Sample rate in cents
    PRELS       m_prCutoff;         // Cutoff Frequency in absolute pitch
    PRELS       m_prCutoffSRAdjust; // Cutoff Frequency adjusted to the sampel rate
    VRELS       m_vrQ;              // Resonance
    DWORD       m_iQIndex;          // Q index          
    PRELS       m_prVelScale;       // Scale by key velocity
    PRELS       m_prKeyScale;       // Scaling by note value.
};

/*  CSourceArticulation is the file format definition of
    a complete articulation set: the LFO and two
    envelope generators.
    Since several regions within one Instrument can 
    share one articulation, a counter is used to keep
    track of the usage.
*/

class CSourceArticulation

{
public:
                CSourceArticulation();
    HRESULT     Download(DMUS_DOWNLOADINFO * pInfo, 
                    void * pvOffsetTable[], DWORD dwIndex, 
                    DWORD dwSampleRate, BOOL fNewFormat);
#ifdef DDUMP
    void        Dump(DWORD dwIndent,DWORD dwLevel);
#endif
    void        Init(DWORD dwSampleRate);
    void        Verify();           // Verifies valid data.
    void        AddRef();
    void        Release();
    void        SetSampleRate(DWORD dwSampleRate);
    CSourceEG   m_PitchEG;          // Pitch envelope.
    CSourceEG   m_VolumeEG;         // Volume envelope.
    CSourceLFO  m_LFO;              // Low frequency oscillator.
    DWORD       m_dwSampleRate;
    WORD        m_wUsageCount;      // Keeps track of how many times in use.
    short       m_sDefaultPan;      // default pan (for drums)

    /* DLS2 */
    CSourceLFO  m_LFO2;             // Vibrato
    CSourceFilter m_Filter;         // Low pass filter
};

/*  Since multiple regions may reference
    the same Wave, a reference count is maintained to
    keep track of how many regions are using the sample.
*/

class CWave : public CListItem
{
public:
                    CWave();
                    ~CWave();
#ifdef DDUMP
    void            Dump(DWORD dwIndent,DWORD dwLevel);
#endif
    void            Verify();           // Verifies that the data is valid.
    void            Release();          // Remove reference.
    void            AddRef();           // Add reference.
    void            PlayOn();           // Increment play count.
    void            PlayOff();          // Decrement play count.
    BOOL            IsPlaying();        // Is currently playing?
    CWave *         GetNext() {return(CWave *)CListItem::GetNext();};
    DWORD           m_dwSampleLength;   // Length of sample.
    DWORD           m_dwSampleRate;
    HRESULT ( CALLBACK *m_lpFreeHandle)(HANDLE,HANDLE);
    HANDLE          m_hUserData;        // Used to notify app when wave released.
    short *         m_pnWave;
    DWORD           m_dwID;             // ID for matching wave with regions.
    WORD            m_wUsageCount;      // Keeps track of how many times in use.
    WORD            m_wPlayCount;       // Wave is currently being played.
    BYTE            m_bSampleType;

    /* DirectX 8 members */
    BYTE            m_bStream;          // This wave is used as a streaming buffer
    BYTE            m_bActive;          // This buffer is currently be used to play out of
    BYTE            m_bValid;           // Indicates data in the buffer is valid 
    BYTE            m_bLastSampleInit;  // Indicates the the buffers last sample has been initialize
};


class CWavePool : public CList
{
public:
    CWave *      GetHead() {return (CWave *)CList::GetHead();};
    CWave *      GetItem(DWORD dwID) {return (CWave *)CList::GetItem((LONG)dwID);};
    CWave *      RemoveHead() {return (CWave *)CList::RemoveHead();};
};


/*  The CSourceSample class describes one sample in an
    instrument. The sample is referenced by a CSourceRegion
    structure. 
*/
class Collection;

class CSourceSample
{
public:
                CSourceSample();
                ~CSourceSample();
    BOOL        CopyFromWave();
    void        Verify();           // Verifies that the data is valid.
    CWave *     m_pWave;            // Wave in pool.
    DWORD       m_dwLoopStart;      // Index of start of loop.
    DWORD       m_dwLoopEnd;        // Index of end of loop.
    DWORD       m_dwSampleLength;   // Length of sample.
    DWORD       m_dwSampleRate;     // Sample rate of recording.
    PRELS       m_prFineTune;       // Fine tune to correct pitch.
    DWORD       m_dwID;             // Wave pool id.
    BYTE        m_bSampleType;      // 16 or 8.
    BYTE        m_bOneShot;         // Is this a one shot sample?
    BYTE        m_bMIDIRootKey;     // MIDI note number for sample.
    DWORD       m_dwLoopType;       // WLOOP_TYPE_xxx
};

/*  The CSourceRegion class defines a region within an instrument.
    The sample is managed with a pointer instead of an embedded
    sample. This allows multiple regions to use the same
    sample.
    Each region also has an associated articulation. For drums, there
    is a one to one matching. For melodic instruments, all regions
    share the same articulation. So, to manage this, each region
    points to the articulation.
*/

class CSourceRegion : public CListItem
{
public:
                CSourceRegion();
                ~CSourceRegion();
#ifdef DDUMP
    void        Dump(DWORD dwIndent,DWORD dwLevel);
#endif
    CSourceRegion *GetNext() {return(CSourceRegion *)CListItem::GetNext();};
    void        Verify();           // Verifies that the data is valid.
    void        SetSampleRate(DWORD dwSampleRate);
    HRESULT     Download(DMUS_DOWNLOADINFO * pInfo, void * pvOffsetTable[], 
                    DWORD *pdwRegionIX, DWORD dwSampleRate, BOOL fNewFormat);
    CSourceSample m_Sample;       // Sample structure.
    CSourceArticulation * m_pArticulation; // Pointer to associated articulation.
    VRELS       m_vrAttenuation;    // Volume change to apply to sample.
    PRELS       m_prTuning;         // Pitch shift to apply to sample.
    BYTE        m_bAllowOverlap;    // Allow overlapping of note.
    BYTE        m_bKeyHigh;         // Upper note value for region.
    BYTE        m_bKeyLow;          // Lower note value.
    BYTE        m_bGroup;           // Logical group (for drums.)

    /* DLS2 */
    BYTE        m_bVelocityHigh;    // Upper velocity value for region.
    BYTE        m_bVelocityLow;     // Lower velocity value.
    SHORT       m_sWaveLinkOptions; // Wave link chunk option flags
    DWORD       m_dwChannel;        // Region channels, from WAVELINK chunk

    // Channel in m_dwChannel provides voice destination and overrides anything
    // from the articulation.
    //
    inline BOOL IsMultiChannel() const
    { return (BOOL)(m_sWaveLinkOptions & F_WAVELINK_MULTICHANNEL); }
};


class CSourceRegionList : public CList
{
public:
    CSourceRegion *GetHead() {return (CSourceRegion *)CList::GetHead();};
    CSourceRegion *RemoveHead() {return (CSourceRegion *)CList::RemoveHead();};
};


/*  The CInstrument class is really the file format definition
    of an instrument.
    The CInstrument can be either a Drum or a Melodic instrument.
    If a drum, it has up to 128 pairings of articulations and
    regions. If melodic, all regions share the same articulation.
    ScanForRegion is called by ControlLogic to get the region
    that corresponds to a note.
*/

class CInstManager;

class CInstrument : public CListItem
{
public:
                    CInstrument();
                    ~CInstrument();
#ifdef DDUMP
    void            Dump(DWORD dwIndent,DWORD dwLevel);
#endif
    void            Init(DWORD dwSampleRate);
    void            Verify();           // Verifies that the data is valid.
    CInstrument *   GetInstrument(DWORD dwProgram,DWORD dwAccept);
    CInstrument *   GetNext() {return(CInstrument *)CListItem::GetNext();};
    void            SetSampleRate(DWORD dwSampleRate);
    CSourceRegion * ScanForRegion(DWORD dwNoteValue, DWORD dwVelocity, CSourceRegion *pRegion = NULL);
    CSourceRegionList m_RegionList;     // Linked list of regions.
    DWORD           m_dwProgram;        // Which program change it represents.
    HRESULT         LoadRegions( BYTE *p, BYTE *pEnd, DWORD dwSampleRate);
    HRESULT         Load( BYTE *p, BYTE *pEnd, DWORD dwSampleRate);
};

class CInstrumentList : public CList
{
public:
    CInstrument *    GetHead() {return (CInstrument *)CList::GetHead();};
    CInstrument *    RemoveHead() {return (CInstrument *)CList::RemoveHead();};
};

class CWaveBufferList;
class CWaveBuffer : public CListItem 
{
friend CWaveBufferList;
public:
                CWaveBuffer() 
                {
                }
    CWaveBuffer * GetNext() { return (CWaveBuffer *)CListItem::GetNext();};
    CWaveBuffer * GetNextLoop() 
                {
                    // Threat the list as a circular list
                    CWaveBuffer *pbuf;
                    pbuf = (CWaveBuffer *)CListItem::GetNext();
                    if ( pbuf == NULL )
                        pbuf = (CWaveBuffer *)*m_ppHead;

                    return pbuf;
                };

    CWave *     m_pWave;            // pointer to wave object
protected:
    CListItem** m_ppHead;
};

class CWaveBufferList : public CList
{
public:
    CWaveBuffer *GetHead() {return (CWaveBuffer *)CList::GetHead();};
    CWaveBuffer *RemoveHead() {return (CWaveBuffer *)CList::RemoveHead();};

    // Overide these methods so that m_pHead can be added to CWaveBuffer ListItem
    // to allow GetNextLoop() to function as a simple circular buffer list 
    void InsertBefore(CListItem *pItem,CWaveBuffer *pInsert) {pInsert->m_ppHead = &m_pHead; CList::Cat(pItem);};
    void Cat(CWaveBuffer *pItem)     {pItem->m_ppHead = &m_pHead; CList::Cat(pItem);};
    void AddHead(CWaveBuffer *pItem) {pItem->m_ppHead = &m_pHead; CList::AddHead(pItem);};
    void AddTail(CWaveBuffer *pItem) {pItem->m_ppHead = &m_pHead; CList::AddTail(pItem);};
};

class CWaveArt : public CListItem
{
public:
                    CWaveArt();
                    ~CWaveArt();
    void            Release();          // Remove reference.
    void            AddRef();           // Add reference.
    void            Verify();           // Verifies that the data is valid.
    CWaveArt *      GetNext() {return(CWaveArt *)CListItem::GetNext();};
    DWORD           m_dwID;             // ID for matching wave with regions.
    DMUS_WAVEARTDL  m_WaveArtDl;
    WAVEFORMATEX    m_WaveformatEx;
    CWaveBufferList m_pWaves;           // Array of Wave buffers associated with dowload id's
//  DWORD           m_dwSampleLength;
    BYTE            m_bSampleType;
    BOOL            m_bStream;          // Is this a streaming articulation 
    WORD            m_wUsageCount;      // Keeps track of how many times in use.
};

class CWaveArtList : public CList
{
public:
    CWaveArt *      GetHead() {return (CWaveArt *)CList::GetHead();};
    CWaveArt *      RemoveHead() {return (CWaveArt *)CList::RemoveHead();};
};

#define WAVE_HASH_SIZE          31      // Keep waves in a hash table of linked lists to speed access.
#define INSTRUMENT_HASH_SIZE    31      // Same with instruments.
#define WAVEART_HASH_SIZE       31

class CInstManager {
public:
                    CInstManager();
                    ~CInstManager();
#ifdef DDUMP
    void            Dump(DWORD dwIndent,DWORD dwLevel);
#endif
    CInstrument *   GetInstrument(DWORD dwPatch,DWORD dwKey,DWORD dwVelocity);
    void            Verify();           // Verifies that the data is valid.
    void            SetSampleRate(DWORD dwSampleRate);
    HRESULT         Download(LPHANDLE phDownload, 
                            void * pvData,
                            LPBOOL pbFree);
    HRESULT         Unload(HANDLE hDownload,
                            HRESULT ( CALLBACK *lpFreeHandle)(HANDLE,HANDLE),
                            HANDLE hUserData);
    /* DirectX8 Methods */
    CWave *         GetWave(DWORD dwDLId);
    CWaveArt *      GetWaveArt(DWORD dwDLId);

private:
    HRESULT         DownloadInstrument(LPHANDLE phDownload, 
                                         DMUS_DOWNLOADINFO *pInfo, 
                                         void *pvOffsetTable[], 
                                         void *pvData,
                                         BOOL fNewFormat);
    HRESULT         DownloadWave(LPHANDLE phDownload,
                                DMUS_DOWNLOADINFO *pInfo, 
                                void *pvOffsetTable[], 
                                void *pvData);
    /* DirectX8 Private Methods */
    HRESULT         DownloadWaveArticulation(LPHANDLE phDownload, 
                                   DMUS_DOWNLOADINFO *pInfo, 
                                   void *pvOffsetTable[], 
                                   void *pvData);
    HRESULT         DownloadWaveRaw(LPHANDLE phDownload, 
                                   DMUS_DOWNLOADINFO *pInfo, 
                                   void *pvOffsetTable[], 
                                   void *pvData);
    CInstrumentList m_InstrumentList[INSTRUMENT_HASH_SIZE];
    CWavePool       m_WavePool[WAVE_HASH_SIZE];
    CWavePool       m_FreeWavePool;     // Track waves still in use, but unloaded.
    DWORD           m_dwSampleRate;     // Sample rate requested by app.

    /* DirectX8 Private Memmebers */
    CWaveArtList    m_WaveArtList[WAVEART_HASH_SIZE];
public:
    DWORD           m_dwSynthMemUse;        /* Memory used by synth wave data */ 

    CRITICAL_SECTION m_CriticalSection; // Critical section to manage access.
    BOOL             m_fCSInitialized;
};

/*  CMIDIRecorder is used to keep track of a time
    slice of MIDI continuous controller events.
    This is subclassed by the PitchBend, Volume, 
    Expression, and ModWheel Recorder classes, so
    each of them may reliably manage MIDI events
    coming in.
    CMIDIRecorder uses a linked list of CMIDIData
    structures to keep track of the changes within
    the time slice.
    Allocation and freeing of the CMIDIData events 
    is kept fast and efficient because they are
    always pulled from the static pool m_pFreeList,
    which is really a list of events pulled directly
    from the static array m_sEventBuffer. This is
    safe because we can make the assumption that
    the maximum MIDI rate is 1000 events per second.
    Since we are managing time slices of roughly
    1/16 of a second, a buffer of 100 events would
    be overkill.
    Although CMIDIRecorder is subclassed to several 
    different event types, they all share the one
    staticly declared free list. 
*/

class CMIDIData : public CListItem 
{
public:
                CMIDIData();
    CMIDIData *  GetNext() {return (CMIDIData *)CListItem::GetNext();};
    STIME       m_stTime;   // Time this event was recorded.
    long        m_lData;    // Data stored in event.            
};

class CMIDIDataList : public CList
{
public:
    CMIDIData *GetHead() {return (CMIDIData *)CList::GetHead();};
    CMIDIData *RemoveHead() {return (CMIDIData *)CList::RemoveHead();};
};


class CMIDIRecorder
{
public:
                CMIDIRecorder();
                ~CMIDIRecorder();        // Be sure to clear local list.
    BOOL        FlushMIDI(STIME stTime); // Clear after time stamp.
    BOOL        ClearMIDI(STIME stTime); // Clear up to time stamp.
    BOOL        RecordMIDI(STIME stTime, long lData); // MIDI input goes here.
    BOOL        RecordMIDINote(STIME stTime, long lData); // MIDI input goes here.
    long        GetData(STIME stTime);  // Gets data at time.

    static VREL VelocityToVolume(WORD nVelocity);
protected:
    static VREL m_vrMIDIToVREL[128]; // Array for converting MIDI to volume.
    static VREL m_vrMIDIPercentToVREL[128]; // Array for converting MIDI reverb and chorus percentages to volume.
private:
    static DWORD m_sUsageCount;         // Keeps track of how many instances so free list can be released.
public:
    static CMIDIDataList m_sFreeList;    // Global free list of events.
protected:
    CMIDIDataList m_EventList;           // This recorder's list.
    STIME       m_stCurrentTime;        // Time for current value.
    long        m_lCurrentData;         // Current value.
};

class CNote {
public:
    STIME       m_stTime;
    BYTE        m_bPart;
    BYTE        m_bKey;
    BYTE        m_bVelocity;
};


// Fake note values held in CNoteIn's queue
// to indicate changes in the sustain pedal
// and "all notes off".
// This is a grab bag for synchronous events
// that should be queued in time, not simply done as
// soon as received.
// By putting them in the note queue, we ensure
// they are evaluated in the exact same order as
// the notes themselves.

const BYTE NOTE_PROGRAMCHANGE   = 0xF1;
const BYTE NOTE_CC_BANKSELECTH  = 0xF2;
const BYTE NOTE_CC_BANKSELECTL  = 0xF3;
const BYTE NOTE_CC_POLYMODE     = 0xF4;
const BYTE NOTE_CC_MONOMODE     = 0xF5;
const BYTE NOTE_CC_RPN_MSB      = 0xF6;
const BYTE NOTE_CC_RPN_LSB      = 0xF7;
const BYTE NOTE_CC_NRPN         = 0xF8;
const BYTE NOTE_CC_DATAENTRYLSB = 0xF9;
const BYTE NOTE_CC_DATAENTRYMSB = 0xFA;
const BYTE NOTE_ASSIGNRECEIVE   = 0xFB;
const BYTE NOTE_MASTERVOLUME    = 0xFC;
const BYTE NOTE_SOUNDSOFF       = 0xFD;
const BYTE NOTE_SUSTAIN         = 0xFE;
const BYTE NOTE_ALLOFF          = 0xFF;

class CNoteIn : public CMIDIRecorder
{
public:
    void        FlushMIDI(STIME stTime);
    void        FlushPart(STIME stTime, BYTE bChannel);
    BOOL        RecordNote(STIME stTime, CNote * pNote);
    BOOL        RecordEvent(STIME stTime, DWORD dwPart, DWORD dwCommand, BYTE bData);
    BOOL        GetNote(STIME stTime, CNote * pNote); // Gets the next note.
}; 

/*  CModWheelIn handles one channel of Mod Wheel
    input. As such, it is not embedded in the CVoice
    class, rather it is in the Channel class.
    CModWheelIn's task is simple: keep track of MIDI
    Mod Wheel events, each tagged with millisecond
    time and value, and return the value for a specific
    time request.
    CModWheelIn inherits almost all of its functionality
    from the CMIDIRecorder Class.
    CModWheelIn receives MIDI mod wheel events through
    the RecordMIDI() command, which stores the 
    time and value of the event. 
    CModWheelIn is called by CVoiceLFO to get the 
    current values for the mod wheel to set the amount
    of LFO modulation for pitch and volume.
*/

class CModWheelIn : public CMIDIRecorder
{
public:
    DWORD       GetModulation(STIME stTime);    // Gets the current Mod Wheel value.
};       

/*  CPitchBendIn handles one channel of Pitch Bend
    input. Like the Mod Wheel module, it inherits
    its abilities from the CMIDIRecorder class.
    It has one additional routine, GetPitch(),
    which returns the current pitch bend value.
*/

class CPitchBendIn : public CMIDIRecorder
{
public:
                CPitchBendIn();
    PREL        GetPitch(STIME stTime); // Gets the current pitch in pitch cents.

    // current pitch bend range.  Note that this is not timestamped!
    PREL        m_prRange;              
};              

/*  CVolumeIn handles one channel of Volume
    input. It inherits its abilities from 
    the CMIDIRecorder class.
    It has one additional routine, GetVolume(),
    which returns the volume in decibels at the
    specified time.
*/

class CVolumeIn : public CMIDIRecorder
{
public:
                CVolumeIn();
    VREL        GetVolume(STIME stTime);    // Gets the current volume in db cents.
};

/*  CExpressionIn handles one channel of Expression
    input. It inherits its abilities from 
    the CMIDIRecorder class.
    It has one additional routine, GetVolume(),
    which returns the volume in decibels at the
    specified time.
*/

class CExpressionIn : public CMIDIRecorder
{
public:
                CExpressionIn();
    VREL        GetVolume(STIME stTime);    // Gets the current volume in db cents.
};

/*  CPanIn handles one channel of Volume
    input. It inherits its abilities from 
    the CMIDIRecorder class.
    It has one additional routine, GetPan(),
    which returns the pan position (MIDI value)
    at the specified time.
*/

class CPanIn : public CMIDIRecorder
{
public:
                CPanIn();
    long        GetPan(STIME stTime);       // Gets the current pan.
};

/*  CProgramIn handles one channel of Program change
    input. It inherits its abilities from 
    the CMIDIRecorder class.
    Unlike the other controllers, it actually 
    records a series of bank select and program
    change events, so it's job is a little
    more complex. Three routines handle the 
    recording of the three different commands (bank 1,
    bank 2, program change).
*/

/*class CProgramIn : public CMIDIRecorder
{
public:
                CProgramIn();
    DWORD       GetProgram(STIME stTime);       // Gets the current program change.
    BOOL        RecordBankH(BYTE bBank1);
    BOOL        RecordBankL(BYTE bBank2);
    BOOL        RecordProgram(STIME stTime, BYTE bProgram);
private:
    BYTE        m_bBankH;
    BYTE        m_bBankL;
};*/

/*  CPressureIn handles one channel of Channel Pressure
    input. As such, it is not embedded in the CVoice
    class, rather it is in the Channel class.
    CPressureIn's task is simple: keep track of MIDI
    Channel Pressure events, each tagged with millisecond
    time and value, and return the value for a specific
    time request.
    CPressureIn inherits almost all of its functionality
    from the CMIDIRecorder Class.
    CPressureIn receives MIDI Channel Pressure events through
    the RecordMIDI() command, which stores the 
    time and value of the event. 
    CPressureIn is called by CVoiceLFO to get the 
    current values for the channel pressure to set the amount
    of LFO modulation for pitch.
*/

class CPressureIn : public CMIDIRecorder
{
public:
    DWORD       GetPressure(STIME stTime);    // Gets the current channel pressure value.
};       

//>>>> comment
class CReverbIn : public CMIDIRecorder
{
public:
                CReverbIn();
    DWORD       GetVolume(STIME stTime);       // Gets the current reverb attenuation.
};

//>>>> comment
class CChorusIn : public CMIDIRecorder
{
public:
    DWORD       GetVolume(STIME stTime);       // Gets the current chorus attenuation.
};

//>>>> comment
class CCutOffFreqIn : public CMIDIRecorder
{
public:
                CCutOffFreqIn();
    DWORD       GetFrequency(STIME stTime);       // Gets the current pan.
};

class CWaveEvent {
public:
                CWaveEvent() : 
                m_stTime(0),
                m_bPart(0),
                m_dwVoiceId(0),
                m_vrVolume(0),
                m_prPitch(0),
                m_pWaveArt(NULL)
                {}
public:
    STIME       m_stTime;
    BYTE        m_bPart;
    DWORD       m_dwVoiceId;
    VREL        m_vrVolume;
    PREL        m_prPitch;
    SAMPLE_TIME m_stVoiceStart;
    SAMPLE_TIME m_stLoopStart;
    SAMPLE_TIME m_stLoopEnd;
    CWaveArt*   m_pWaveArt;
};

class CWaveData : public CListItem 
{
public:
                CWaveData();
    CWaveData * GetNext() {return (CWaveData *)CListItem::GetNext();};
    STIME       m_stTime;           // Time this event was recorded.
    CWaveEvent  m_WaveEventData;    // Data stored in event.            
};

class CWaveDataList : public CList
{
public:
    CWaveData *GetHead() {return (CWaveData *)CList::GetHead();};
    CWaveData *RemoveHead() {return (CWaveData *)CList::RemoveHead();};
};

class CWaveIn 
{
public:
                CWaveIn();
                ~CWaveIn();              // Be sure to clear local list.
//    BOOL        FlushWave(STIME stTime); // Clear after time stamp.
    BOOL        ClearWave(STIME stTime); // Clear up to time stamp.
    BOOL        RemoveWave(DWORD dwID);  // Remove wave with dwID.
    BOOL        RemoveWaveByStopTime(DWORD dwID, STIME stStopTime);
    BOOL        RecordWave(STIME stTime, CWaveEvent *pWaveData); 
    BOOL        GetWave(STIME stTime, CWaveEvent *pWave); 

private:
    static DWORD     m_sUsageCount;                   // Keeps track of how many instances so free list can be released.
public:
    static CWaveDataList m_sFreeList;   // Global free list of events.

protected:
    CWaveDataList m_EventList;          // This recorder's list.
    STIME         m_stCurrentTime;      // Time for current value.
    CWaveEvent    m_lCurrentData;       // Current value.
}; 

/*  The CVoiceLFO class is used to track the behavior
    of an LFO within a voice. The LFO is hard wired to 
    output both volume and pitch values, through separate
    calls to GetVolume and GetPitch.
    It also manages mixing Mod Wheel control of pitch and
    volume LFO output. It tracks the scaling of Mod Wheel
    for each of these in m_nMWVolumeScale and m_nMWPitchScale.
    It calls the Mod Wheel module to get the current values 
    if the respective scalings are greater than 0.
    All of the preset values for the LFO are carried in
    the m_CSource field, which is a replica of the file
    CSourceLFO structure. This is initialized with the
    StartVoice call.
*/

class CVoiceLFO 
{
public:
                CVoiceLFO();
    static void Init();             // Set up sine table.
    STIME       StartVoice(CSourceLFO *pSource, 
                    STIME stStartTime,CModWheelIn * pModWheelIn, CPressureIn * pPressureIn);
    VREL        GetVolume(STIME stTime, STIME *pstTime);    // Returns volume cents.
    PREL        GetPitch(STIME stTime, STIME *pstTime);     // Returns pitch cents.

    /* DirectX8 Methods */
    void        Enable(BOOL bEnable) {m_bEnable = bEnable;};
    PREL        GetCutoff(STIME stTime);                    // Return filter cutoff

private:
    long        GetLevel(STIME stTime, STIME *pstTime);
    CSourceLFO  m_Source;           // All of the preset information.
    STIME       m_stStartTime;      // Time the voice started playing.
    CModWheelIn *m_pModWheelIn;     // Pointer to Mod Wheel for this channel.
    STIME       m_stRepeatTime;     // Repeat time for LFO.
    static short m_snSineTable[256];    // Sine lookup table.

    /* DirectX8 Memmebers */
    CPressureIn *m_pPressureIn;     // Pointer to Channel Pressure for this channel.
    BOOL        m_bEnable;
};

/*  The CVoiceEG class is used to track the behavior of
    an Envelope Generator within a voice. There are two 
    EG's, one for pitch and one for volume. However, they
    behave identically.
    All of the preset values for the EG are carried in
    the m_Source field, which is a replica of the file
    CSourceEG structure. This is initialized with the
    StartVoice call.
*/

class CVoiceEG
{
public:
    static void Init();             // Set up linear attack table.
                CVoiceEG();
    STIME       StartVoice(CSourceEG *pSource, STIME stStartTime, 
                    WORD nKey, WORD nVelocity, STIME stMinAttack);
    void        StopVoice(STIME stTime);
    void        QuickStopVoice(STIME stTime, DWORD dwSampleRate);
    VREL        GetVolume(STIME stTime, STIME *pstTime);    // Returns volume cents.
    PREL        GetPitch(STIME stTime, STIME *pstTime);     // Returns pitch cents.
    BOOL        InAttack(STIME stTime);     // is voice still in attack?
    BOOL        InRelease(STIME stTime);    // is voice in release?

    /* DirectX8 Methods */
    void        Enable(BOOL bEnable) {m_bEnable = bEnable;};
    PREL        GetCutoff(STIME stTime);                    // Return filter cutoff

private:
    long        GetLevel(STIME stTime, STIME *pstTime, BOOL fVolume);
    CSourceEG   m_Source;           // Preset values for envelope, copied from file.
    STIME       m_stStartTime;      // Time note turned on
    STIME       m_stStopTime;       // Time note turned off
    static short m_snAttackTable[201];

    /* DirectX8 Memmebers */
    BOOL        m_bEnable;
};

//>>>>>>>>>>> comment 
class CVoiceFilter
{
public:
    void        StartVoice(CSourceFilter *pSource, CVoiceLFO *pLFO, CVoiceEG *pEG, WORD nKey, WORD nVelocity);
    void        GetCoeff(STIME stTime, PREL prFreqIn, COEFF &cfK, COEFF &cfB1, COEFF &cfB2);
    BOOL        IsFiltered();
    
public:
    CSourceFilter   m_Source;   
    CVoiceLFO       *m_pLFO;
    CVoiceEG        *m_pEG;
    CPitchBendIn    *m_pPitchBend;

    PREL            m_prVelScale;
    PREL            m_prKeyScale;
    
    static COEFF    m_aK[FILTER_PARMS_DIM_Q][FILTER_PARMS_DIM_FC];
    static COEFF    m_aB1[FILTER_PARMS_DIM_Q][FILTER_PARMS_DIM_FC];
    static COEFF    m_aB2[FILTER_PARMS_DIM_Q][FILTER_PARMS_DIM_FC];
};

/*  The CDigitalAudio class is used to track the playback
    of a sample within a voice.
    It manages the loop points, the pointer to the sample.
    and the base pitch and base volume, which it initially sets 
    when called via StartVoice(). 
    Pitch is stored in a fixed point format, where the leftmost
    20 bits define the sample increment and the right 12 bits
    define the factional increment within the sample. This 
    format is also used to track the position in the sample.
    Mix is a critical routine. It is called by the CVoice to blend
    the instrument into the data buffer. It is handed relative change
    values for pitch and volume (semitone cents and decibel
    cents.) These it converts into three linear values:
    Left volume, Right volume, and Pitch.
    It then compares these new values with the values that existed 
    for the previous slice and divides by the number of samples to 
    determine an incremental change at the sample rate. 
    Then, in the critical mix loop, these are added to the 
    volume and pitch indices to give a smooth linear slope to the
    change in volume and pitch.
*/

#define MAX_SAMPLE    4095
#define MIN_SAMPLE  (-4096)

#define MAXDB            0
#define MINDB           -100
#define TEST_WRITE_SIZE  3000
#define TEST_SOURCE_SIZE 44100

class CSynth;

class CDigitalAudio 
{
public:
                CDigitalAudio();
                ~CDigitalAudio();

    void        ClearVoice();
    STIME       StartVoice(CSynth *pSynth,
                    CSourceSample *pSample,
                    PREL prBasePitch, long lKey);
    STIME       StartWave(CSynth *pSynth,
                    CWaveArt *pWaveArt, 
                    PREL prBasePitch,
                    SAMPLE_TIME stVoiceStart,
                    SAMPLE_TIME stLoopStart,
                    SAMPLE_TIME stLoopEnd);
    BOOL        Mix(short **ppBuffers, 
                    DWORD dwInterleaved, 
                    DWORD dwBufferCount, 
                    DWORD dwLength,
                    VREL vrMaxVolumeDelta,  
                    VFRACT vrNewVolume[],                       
                    VFRACT vrLastVolume[],                      
                    PREL dwPitch,
                    DWORD dwIsFiltered, COEFF cfK, COEFF cfB1, COEFF cfB2);

    inline void BreakLoop()
    { m_bOneShot = TRUE; }

    static void Init();                         // Set up lookup tables.
    static PFRACT PRELToPFRACT(PREL prPitch);   // Pitch cents to pitch.
    static VFRACT VRELToVFRACT(VREL vrVolume);  // dB to absolute.

    SAMPLE_POSITION GetCurrentPos() {return m_ullSamplesSoFar;};

    //
    // Optimized Interleaved mixers 
    //
private:
    DWORD       Mix8(short * pBuffer, 
                    DWORD dwLength,
                    DWORD dwDeltaPeriod,
                    VFRACT vfDeltaLVolume, 
                    VFRACT vfDeltaRVolume,
                    VFRACT vfLastVolume[],
                    PFRACT pfDeltaPitch, 
                    PFRACT pfSampleLength, 
                    PFRACT pfLoopLength);
    DWORD       Mix16(short * pBuffer, 
                    DWORD dwLength,
                    DWORD dwDeltaPeriod,
                    VFRACT vfDeltaLVolume, 
                    VFRACT vfDeltaRVolume,
                    VFRACT vfLastVolume[],
                    PFRACT pfDeltaPitch, 
                    PFRACT pfSampleLength, 
                    PFRACT pfLoopLength);
    DWORD       MixMono8(short * pBuffer, 
                    DWORD dwLength,
                    DWORD dwDeltaPeriod,
                    VFRACT vfDeltaVolume, 
                    VFRACT vfLastVolume[],
                    PFRACT pfDeltaPitch, 
                    PFRACT pfSampleLength, 
                    PFRACT pfLoopLength);
    DWORD       MixMono16(short * pBuffer, 
                    DWORD dwLength,
                    DWORD dwDeltaPeriod,
                    VFRACT vfDeltaVolume, 
                    VFRACT vfLastVolume[],
                    PFRACT pfDeltaPitch, 
                    PFRACT pfSampleLength, 
                    PFRACT pfLoopLength);
    //
    // Optimized MMX Interleaved mixers 
    //
private:
    DWORD _cdecl Mix8X(short * pBuffer, 
                    DWORD dwLength, 
                    DWORD dwDeltaPeriod,
                    VFRACT vfDeltaLVolume, 
                    VFRACT vfDeltaRVolume,
                    VFRACT vfLastVolume[],
                    PFRACT pfDeltaPitch, 
                    PFRACT pfSampleLength, 
                    PFRACT pfLoopLength);
    DWORD _cdecl Mix16X(short * pBuffer, 
                    DWORD dwLength, 
                    DWORD dwDeltaPeriod,
                    VFRACT vfDeltaLVolume, 
                    VFRACT vfDeltaRVolume,
                    VFRACT vfLastVolume[],
                    PFRACT pfDeltaPitch, 
                    PFRACT pfSampleLength, 
                    PFRACT pfLoopLength);
    DWORD       MixMono16X(short * pBuffer, 
                    DWORD dwLength,
                    DWORD dwDeltaPeriod,
                    VFRACT vfDeltaVolume, 
                    VFRACT vfLastVolume[],
                    PFRACT pfDeltaPitch, 
                    PFRACT pfSampleLength,
                    PFRACT pfLoopLength);
    DWORD       MixMono8X(short * pBuffer,
                    DWORD dwLength,
                    DWORD dwDeltaPeriod,
                    VFRACT vfDeltaVolume, 
                    VFRACT vfLastVolume[],
                    PFRACT pfDeltaPitch, 
                    PFRACT pfSampleLength, 
                    PFRACT pfLoopLength);
    //
    // Optimize Multi Buffer versions of the mixer 
    //
private:
    DWORD       MixMulti8(short *ppBuffer[], 
                    DWORD dwBufferCount,
                    DWORD dwLength, 
                    DWORD dwDeltaPeriod, 
                    VFRACT vfDeltaVolume[], 
                    VFRACT vfLastVolume[], 
                    PFRACT pfDeltaPitch, 
                    PFRACT pfSampleLength, 
                    PFRACT pfLoopLength);
    DWORD       MixMulti8Filter(short *ppBuffer[], 
                    DWORD dwBufferCount,
                    DWORD dwLength, 
                    DWORD dwDeltaPeriod, 
                    VFRACT vfDeltaVolume[], 
                    VFRACT vfLastVolume[], 
                    PFRACT pfDeltaPitch, 
                    PFRACT pfSampleLength, 
                    PFRACT pfLoopLength,
                    COEFF cfdK,
                    COEFF cfdB1,
                    COEFF cfdB2);
    DWORD       MixMulti16(short *ppBuffer[], 
                    DWORD dwBufferCount,
                    DWORD dwLength, 
                    DWORD dwDeltaPeriod, 
                    VFRACT vfDeltaVolume[], 
                    VFRACT vfLastVolume[], 
                    PFRACT pfDeltaPitch, 
                    PFRACT pfSampleLength, 
                    PFRACT pfLoopLength);
    DWORD       MixMulti16Filter(short *ppBuffer[], 
                    DWORD dwBufferCount,
                    DWORD dwLength, 
                    DWORD dwDeltaPeriod, 
                    VFRACT vfDeltaVolume[], 
                    VFRACT vfLastVolume[], 
                    PFRACT pfDeltaPitch, 
                    PFRACT pfSampleLength, 
                    PFRACT pfLoopLength,
                    COEFF cfdK,
                    COEFF cfdB1,
                    COEFF cfdB2);
private:
    void        BeforeBigSampleMix();
    void        AfterBigSampleMix();

private:
    CSourceSample   m_Source;           // Preset values for sample.
    CSynth *        m_pSynth;           // For access to sample rate, etc.

    static PFRACT   m_spfCents[201];    // Pitch increment lookup.
    static PFRACT   m_spfSemiTones[97]; // Four octaves up and down.
    static VFRACT   m_svfDbToVolume[(MAXDB - MINDB) * 10 + 1]; // dB conversion table.
    static BOOL     m_sfMMXEnabled;

private:
    short *     m_pnWave;           // Private pointer to wave.

    PFRACT      m_pfBasePitch;      // Overall pitch.
    PFRACT      m_pfLastPitch;      // The last pitch value.
    PREL        m_prLastPitch;      // Same for pitch, in PREL.
    PFRACT      m_pfLastSample;     // The last sample position.
    PFRACT      m_pfLoopStart;      // Start of loop.
    PFRACT      m_pfLoopEnd;        // End of loop.
    PFRACT      m_pfSampleLength;   // Length of sample buffer.
    BOOL        m_fElGrande;        // Indicates larger than 1m wave.
    ULONGLONG   m_ullLastSample;    // Used to track > 1m wave.
    ULONGLONG   m_ullLoopStart;     // Used to track > 1m wave.
    ULONGLONG   m_ullLoopEnd;       // Used to track > 1m wave.
    ULONGLONG   m_ullSampleLength;  // Used to track > 1m wave.
    DWORD       m_dwAddressUpper;   // Temp storage for upper bits of address.
    BOOL        m_bOneShot;         // Is the source region we're mixing a one-shot?

    /* DLS2 filter members */
    COEFF       m_cfLastK;          // Held filter coefficients
    COEFF       m_cfLastB1;
    COEFF       m_cfLastB2;
    long        m_lPrevSample;      // Last two samples, post-filter
    long        m_lPrevPrevSample;

    /* DirectX8 members */
    CWaveBuffer*    m_pCurrentBuffer;
    CWaveArt*       m_pWaveArt;
    ULONGLONG       m_ullSamplesSoFar;
};


/*  The CVoice class pulls together everything needed to perform
    one voice. It has the envelopes, lfo, and sample embedded
    within it. 

    StartVoice() initializes a voice structure for playback. The
    CSourceRegion structure carries the region and sample as well
    as a pointer to the articulation, which is used to set up
    the various articulation modules. It also carries pointers to 
    all the MIDI modulation inputs and the values for the note key
    and channel which are used by the parent ControlLogic object
    to match incoming note off events with the right voice. 
*/

class CVoice : public CListItem
{
public:
                CVoice();
    CVoice *     GetNext() {return (CVoice *)CListItem::GetNext();};

    BOOL        StartVoice(CSynth *pControl,
                    CSourceRegion *pRegion, STIME stStartTime,
                    CModWheelIn * pModWheelIn, 
                    CPitchBendIn * pPitchBendIn,
                    CExpressionIn * pExpressionIn,
                    CVolumeIn * pVolumeIn,
                    CPanIn * pPanIn,
                    CPressureIn * pPressureIn,
                    CReverbIn * pReverbSend,
                    CChorusIn * pChorusSend,
                    CCutOffFreqIn * PCCutOffFreqIn,
                    CBusIds * pBusIds,
                    WORD nKey,WORD nVelocity,
                    VREL vrVolume,      // Added for GS
                    PREL prPitch);      // Added for GS

    BOOL        StartWave(CSynth *pSynth,
                       CWaveArt *pWaveArt,
                       DWORD dwVoiceId,
                       STIME stStartTime,
                       CPitchBendIn * pPitchBendIn,
                       CExpressionIn * pExpressionIn,   
                       CVolumeIn * pVolumeIn,
                       CPanIn * pPanIn,
                       CReverbIn * pReverbSend,
                       CChorusIn * pChorusSend,
                       CCutOffFreqIn * pCCutOffFreqIn,
                       CBusIds * pBusIds,
                       VREL vrVolume,
                       PREL prPitch,
                       SAMPLE_TIME stVoiceStart,
                       SAMPLE_TIME stLoopStart,
                       SAMPLE_TIME stLoopEnd       
                       );
    static void Init();             // Initialize LFO, Digital Audio.
    void  StopVoice(STIME stTime);// Called on note off event.
    void  QuickStopVoice(STIME stTime);// Called to get quick release.
    void  SpeedRelease();     // Force an already off envelope to release quickly.
    void  ClearVoice();       // Release use of sample.
    void  GetNewPitch(STIME stTime, PREL& prPitch);// Return current pitch value
    void  GetNewVolume(STIME stTime, VREL& vrVolume, VREL& vrVolumeL, VREL& vrVolumeR, VREL& vrVolumeReverb, VREL& vrVolumeChorus);
    void  GetNewCoeff(STIME stTime, PREL& prCutOff, COEFF& cfK, COEFF& cfB1, COEFF& cfB2);
    DWORD Mix(short **ppvBuffer, DWORD dwBufferFlags, DWORD dwLength, STIME stStart,STIME stEnd);
    SAMPLE_POSITION GetCurrentPos();

private:
    static VREL m_svrPanToVREL[128];// Converts Pan to db.
    CVoiceLFO   m_LFO;             // LFO.
    CVoiceEG    m_PitchEG;         // Pitch Envelope.
    CVoiceEG    m_VolumeEG;        // Volume Envelope.
    CDigitalAudio m_DigitalAudio;  // The Digital Audio Engine structure.
    CPitchBendIn *  m_pPitchBendIn; // Pitch bend source.
    CExpressionIn * m_pExpressionIn;// Expression source.
    CVolumeIn * m_pVolumeIn;        // Volume source, if allowed to vary
    CPanIn *    m_pPanIn;           // Pan source, if allowed to vary
    CReverbIn * m_pReverbSend;      //>>>> comment 
    CChorusIn * m_pChorusSend;      //>>>> comment 
    CCutOffFreqIn * m_CCutOffFreqIn;//>>>> comment
    CSynth *    m_pSynth;           // To access sample rate, etc.
    STIME       m_stMixTime;        // Next time we need a mix.
    STIME       m_stLastMix;        // Last sample position mixed.
    long        m_lDefaultPan;      // Default pan
    PREL        m_prLastCutOff;     // Last cut off value.

public:
    DWORD       m_dwNoteID;         // Unique id to keep all voices that represent layers of one note connected.
    STIME       m_stStartTime;      // Time the sound starts.
    STIME       m_stStopTime;       // Time the sound stops.
    STIME       m_stWaveStopTime;   // Stop time set by direct call to stop the wave voice.
    BOOL        m_fInUse;           // This is currently in use.
    BOOL        m_fNoteOn;          // Note is considered on.
    BOOL        m_fTag;             // Used to track note stealing.
    VREL        m_vrVolume;         // Volume, used for voice stealing...
    BOOL        m_fSustainOn;       // Sus pedal kept note on after off event.
    WORD        m_nPart;            // Part that is playing this (channel).
    WORD        m_nKey;             // Note played.
    BOOL        m_fAllowOverlap;    // Allow overlapped note.
    DWORD       m_dwGroup;          // Group this voice is playing now
    DWORD       m_dwProgram;        // Bank and Patch choice.
    DWORD       m_dwPriority;       // Priority.
    CControlLogic * m_pControl;     // Which control group is playing voice.
    DWORD       m_dwVoiceId;        // Used to identify a playing wave
    CSourceRegion *m_pRegion;       // Used to determin which region a voice is playing out of 
    CVoiceFilter m_Filter;          // Low pass filter
    CVoiceLFO   m_LFO2;             // Vibrato
    CBusIds     m_BusIds;           // Bus Id's to playe on this voice
    DWORD       m_dwLoopType;       // Loop type
    BOOL        m_fIgnorePan;       // If we're part of a multichannel wave/sample
    VREL        m_vrLastVolume[MAX_DAUD_CHAN];
    VREL        m_vrBaseVolume[MAX_DAUD_CHAN];    
    VFRACT      m_vfLastVolume[MAX_DAUD_CHAN];  
};


class CVoiceList : public CList
{
public:
    CVoice *     GetHead() {return (CVoice *)CList::GetHead();};
    CVoice *     RemoveHead() {return (CVoice *)CList::RemoveHead();};
    CVoice *     GetItem(LONG lIndex) {return (CVoice *) CList::GetItem(lIndex);};
};

/*  Finally, ControlLogic is the big Kahuna that manages 
    the whole system. It parses incoming MIDI events
    by channel and event type. And, it manages the mixing
    of voices into the buffer.

  MIDI Input:

    The most important events are the note on and
    off events. When a note on event comes in, 
    ControlLogic searches for an available voice.
    ControlLogic matches the channel and finds the
    instrument on that channel. It then call the instrument's
    ScanForRegion() command which finds the region 
    that matches the note. At this point, it can copy
    the region and associated articulation into the
    voice, using the StartVoice command.
    When it receives the sustain pedal command,
    it artificially sets all notes on the channel on
    until a sustain off arrives. To keep track of notes
    that have been shut off while the sustain was on
    it uses an array of 128 shorts, with each bit position 
    representing a channel. When the sustain releases,
    it scans through the array and creates a note off for
    each bit that was set.
    It also receives program change events to set the
    instrument choice for the channel. When such
    a command comes in, it consults the softsynth.ini file 
    and loads an instrument with the file name described
    in the ini file.
    Additional continuous controller events are managed
    by the CModWheelIn, CPitchBendIn, etc., MIDI input recording
    modules.

  Mixing:

    Control Logic is also called to mix the instruments into
    a buffer at regular intervals. The buffer is provided by the
    calling sound driver (initially, AudioMan.) 
    Each voice is called to mix its sample into the buffer.
*/

typedef struct PerfStats
{
    DWORD dwTotalTime;
    DWORD dwTotalSamples;
    DWORD dwNotesLost;
    DWORD dwVoices;
    DWORD dwCPU;
    DWORD dwMaxAmplitude;
} PerfStats;

#define MIX_BUFFER_LEN          500 // Set the sample buffer size to 500 mils
#define MAX_NUM_VOICES          32  
#define NUM_EXTRA_VOICES        8   // Extra voices for when we overload.
#define NUM_DEFAULT_BUSES       4


class CControlLogic
{
public:
                    CControlLogic();
                    ~CControlLogic();
    HRESULT         Init(CInstManager *pInstruments, CSynth *pSynth);
    void            ClearAll();
    void            Flush(STIME stTime); // Clears all events after time.
    BOOL            RecordMIDI(STIME stTime,BYTE bStatus, BYTE bData1, BYTE bData2);
    HRESULT         RecordSysEx(DWORD dwSysExLength,BYTE *pSysExData, STIME stTime);
    CSynth *        m_pSynth;
    void            QueueNotes(STIME stStartTime, STIME stEndTime);
    void            ClearMIDI(STIME stEndTime);
    void            SetGainAdjust(VREL vrGainAdjust);
    HRESULT         SetChannelPriority(DWORD dwChannel,DWORD dwPriority);
    HRESULT         GetChannelPriority(DWORD dwChannel,LPDWORD pdwPriority);

    /* DirectX8 methods */
    void            QueueWaves(STIME stEndTime);
    void            FlushWaveByStopTime(DWORD dwID, STIME stStopTime);
    BOOL            RecordWaveEvent(STIME stTime, BYTE bChannel, DWORD dwVoiceId, VREL prVolume, PREL prPitch, SAMPLE_TIME stVoiceStart, SAMPLE_TIME stLoopStart, SAMPLE_TIME stLoopEnd, CWaveArt* pWaveArt);
    HRESULT         AssignChannelToBuses(DWORD dwChannel, LPDWORD pdwBusIds, DWORD dwBusCount);
    
private:
    void            GMReset();
    CInstManager *  m_pInstruments;
    CNoteIn         m_Notes;            // All Note ons and offs.
    CModWheelIn     m_ModWheel[16];     // Sixteen channels of Mod Wheel.
    CPitchBendIn    m_PitchBend[16];    // Sixteen channels of Pitch Bend.
    CVolumeIn       m_Volume[16];       // Sixteen channels of Volume.
    CExpressionIn   m_Expression[16];   // Sixteen channels of Expression.
    CPanIn          m_Pan[16];          // Sixteen channels of Pan.
    CReverbIn       m_ReverbSends[16];  //>>>> comment  
    CChorusIn       m_ChorusSends[16];  //>>>> comment
    CCutOffFreqIn   m_CutOffFreqCC[16]; //>>>> comment
    BOOL            m_fSustain[16];     // Sustain on / off.
    short           m_nCurrentRPN[16];  // RPN number.
    BYTE            m_bBankH[16];       // Bank selects for instrument.
    BYTE            m_bBankL[16];     
    DWORD           m_dwProgram[16];    // Instrument choice.
    BOOL            m_fEmpty;           // Indicates empty lists, no need to flush.
    VREL            m_vrGainAdjust;     // Final stage gain adjust
    DWORD           m_dwPriority[16];   // Priorities for each channel.
    
    BOOL            m_fXGActive;        // Is XG Active?
    BOOL            m_fGSActive;        // Is GS enabled?
    WORD            m_nData[16];        // Used to track RPN reading.
    VREL            m_vrMasterVolume;   // Master Volume.
    PREL            m_prFineTune[16];   // Fine tune for each channel.
    PREL            m_prScaleTune[16][12]; // Alternate scale for each channel.
    PREL            m_prCoarseTune[16]; // Coarse tune.
    BYTE            m_bPartToChannel[16]; // Channel to Part converter.
    BYTE            m_bDrums[16];       // Melodic or which drum?
    BOOL            m_fMono[16];        // Mono mode?

public:
    // This is static to protect the CMIDIRecorder free list, which is also static.
    // 
    static CRITICAL_SECTION s_CriticalSection; // Critical section to manage access.
    static BOOL             s_fCSInitialized;

    static BOOL InitCriticalSection();
    static void KillCriticalSection();

    /* DirectX8 members */
private:
    CWaveIn         m_Waves;            // All waves scheduled to be played
    CPressureIn     m_Pressure[16];     // Sixteen channels of Channel Pressure.
    CBusIds         m_BusIds[16];       // Bus Id's for each channel 
};

#endif // __SYNTH_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\XboxSynth\shared\debug.h ===
//
// debug.h
// 
// Copyright (c) 1997-1999 Microsoft Corporation. All rights reserved.
//
// Note:
//

#ifndef DEBUG_H
#define DEBUG_H

#include <windows.h>

#define DM_DEBUG_CRITICAL		1	// Used to include critical messages
#define DM_DEBUG_NON_CRITICAL	2	// Used to include level 1 plus important non-critical messages
#define DM_DEBUG_STATUS			3	// Used to include level 1 and level 2 plus status\state messages
#define DM_DEBUG_FUNC_FLOW		4	// Used to include level 1, level 2 and level 3 plus function flow messages
#define DM_DEBUG_ALL			5	// Used to include all debug messages

// Default to no debug output compiled
//
#define Trace
#define TraceI
#define assert(exp) ((void)0)

#ifdef DBG

// Checked build: include at least external debug spew
//
extern void DebugInit(void);
extern void DebugTrace(int iDebugLevel, LPSTR pstrFormat, ...);
extern void DebugAssert(LPSTR szExp, LPSTR szFile, ULONG ulLine);

# undef Trace
# define Trace DebugTrace

# undef assert
# define assert(exp) (void)( (exp) || (DebugAssert(#exp, __FILE__, __LINE__), 0) )

// If internal build flag set, include everything
//
# ifdef DMUSIC_INTERNAL
#  undef TraceI
#  define TraceI DebugTrace
# endif

#endif  // #ifdef DBG

#endif  // #ifndef DEBUG_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\XboxSynth\syslink.h ===
// Copyright (c) 1998 Microsoft Corporation
//
//
// 
#ifndef _SYSLINK_
#define _SYSLINK_

#include <mmsystem.h>

#undef  INTERFACE
#define INTERFACE  IReferenceClock
DECLARE_INTERFACE_(IReferenceClock, IUnknown)
{
    /*  IUnknown */
    STDMETHOD(QueryInterface)           (THIS_ REFIID, LPVOID FAR *) PURE;
    STDMETHOD_(ULONG,AddRef)            (THIS) PURE;
    STDMETHOD_(ULONG,Release)           (THIS) PURE;

    /*  IReferenceClock */
    /*  */
    
    /*  get the time now */
    STDMETHOD(GetTime)                  (THIS_ REFERENCE_TIME *pTime) PURE;

    /*  ask for an async notification that a time has elapsed */
    STDMETHOD(AdviseTime)               (THIS_ REFERENCE_TIME baseTime,         /*  base time */
                                               REFERENCE_TIME streamTime,       /*  stream offset time */
                                               HANDLE hEvent,                   /*  advise via this event */
                                               DWORD * pdwAdviseCookie) PURE;   /*  where your cookie goes */

    /*  ask for an async periodic notification that a time has elapsed */
    STDMETHOD(AdvisePeriodic)           (THIS_ REFERENCE_TIME startTime,        /*  starting at this time */
                                               REFERENCE_TIME periodTime,       /*  time between notifications */
                                               HANDLE hSemaphore,               /*  advise via a semaphore */
                                               DWORD * pdwAdviseCookie) PURE;   /*  where your cookie goes */

    /*  cancel a request for notification */
    STDMETHOD(Unadvise)                 (THIS_ DWORD dwAdviseCookie) PURE;
};

#undef  INTERFACE
#define INTERFACE  IDirectMusicSynthSink
DECLARE_INTERFACE_(IDirectMusicSynthSink, IUnknown)
{
    /* IUnknown */
    STDMETHOD(QueryInterface)       (THIS_ REFIID, LPVOID FAR *) PURE;
    STDMETHOD_(ULONG,AddRef)        (THIS) PURE;
    STDMETHOD_(ULONG,Release)       (THIS) PURE;

    /* IDirectMusicSynthSink */
    STDMETHOD(Init)                 (THIS_ CSynth *pSynth) PURE;
    STDMETHOD(SetFormat)            (THIS_ LPCWAVEFORMATEX pWaveFormat) PURE;
    STDMETHOD(SetMasterClock)       (THIS_ IReferenceClock *pClock) PURE;
    STDMETHOD(GetLatencyClock)      (THIS_ IReferenceClock **ppClock) PURE;
    STDMETHOD(Activate)             (THIS_ HWND hWnd, 
                                           BOOL fEnable) PURE;
    STDMETHOD(SampleToRefTime)      (THIS_ LONGLONG llSampleTime,
                                           REFERENCE_TIME *prfTime) PURE;
    STDMETHOD(RefTimeToSample)      (THIS_ REFERENCE_TIME rfTime, 
                                           LONGLONG *pllSampleTime) PURE;
};

typedef IDirectMusicSynthSink *PDIRECTMUSICSYNTHSINK;

class CSysLink : public IDirectMusicSynthSink
{
public:
    // IUnknown
    //
    STDMETHOD(QueryInterface)       (THIS_ REFIID, LPVOID FAR *);
    STDMETHOD_(ULONG, AddRef)       (THIS);
    STDMETHOD_(ULONG, Release)      (THIS);

    // IDirectMusicSynthSink
    //
    STDMETHOD(Init)                 (THIS_ CSynth *pSynth);
    STDMETHOD(SetFormat)            (THIS_ LPCWAVEFORMATEX pWaveFormat);
	STDMETHOD(SetMasterClock)       (THIS_ IReferenceClock *pClock);
	STDMETHOD(GetLatencyClock)      (THIS_ IReferenceClock **ppClock);
	STDMETHOD(Activate)             (THIS_ HWND hWnd, BOOL fEnable);
	STDMETHOD(SampleToRefTime)      (THIS_ LONGLONG llSampleTime,REFERENCE_TIME *prfTime);
	STDMETHOD(RefTimeToSample)      (THIS_ REFERENCE_TIME rfTime, LONGLONG *pllSampleTime);

    // Class
    //
	CSysLink();
	~CSysLink();

private:
    LONG m_cRef;
};

#define STATIC_IID_IDirectMusicSynthSink \
    0xaec17ce3, 0xa514, 0x11d1, 0xaf, 0xa6, 0x00, 0xaa, 0x00, 0x24, 0xd8, 0xb6
DEFINE_GUIDSTRUCT("aec17ce3-a514-11d1-afa6-00aa0024d8b6", IID_IDirectMusicSynthSink);
#define IID_IDirectMusicSynthSink DEFINE_GUIDNAMED(IID_IDirectMusicSynthSink)

#endif // _SYSLINK_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\XboxSynth\umsynth.h ===
//      Copyright (c) 1996-2001 Microsoft Corporation
// UMSynth.h : Declaration of CUserModeSynth

#ifndef __UMSYNTH_H_
#define __UMSYNTH_H_

#include <ks.h>
#include <ksproxy.h>
#include <mmsystem.h>
#include "dsound.h"   
#include "dmusicc.h"
#include "dmusics.h"
#include "CSynth.h"
#include "synth.h"
#include "dsoundp.h"    // For IDirectSoundSource
#include "PLClock.h"

class CUserModeSynth;
typedef struct _DM_CONNECTION *PDM_CONNECTION;

// {AEE78E4D-8818-4020-AA5D-997756AF53FB}
DEFINE_GUID(CLSID_XboxSynth, 
0xaee78e4d, 0x8818, 0x4020, 0xaa, 0x5d, 0x99, 0x77, 0x56, 0xaf, 0x53, 0xfb);

// {E51F2AA9-F7B6-4397-9F70-783FC3642EF8}
DEFINE_GUID(GUID_Xbox_PROP_PCSynth, 
0xe51f2aa9, 0xf7b6, 0x4397, 0x9f, 0x70, 0x78, 0x3f, 0xc3, 0x64, 0x2e, 0xf8);

// {207348EF-09E7-425c-BBBA-94C92FEF09B7}
DEFINE_GUID(GUID_Xbox_PROP_XboxSynth, 
0x207348ef, 0x9e7, 0x425c, 0xbb, 0xba, 0x94, 0xc9, 0x2f, 0xef, 0x9, 0xb7);

DEFINE_GUID(GUID_Xbox_PROP_XboxAudioPath, 
0xa70f376a, 0x49f1, 0x4339, 0xbb, 0x93, 0xb2, 0x9b, 0x67, 0xee, 0xf5, 0x88);


typedef HRESULT (CUserModeSynth::*GENPROPHANDLER)(ULONG ulId, BOOL fSet, LPVOID pbBuffer, PULONG cbBuffer);

#define GENPROP_F_STATIC                0x00000000
#define GENPROP_F_FNHANDLER             0x00000001


#include <pshpack4.h>
struct GENERICPROPERTY
{
    const GUID *pguidPropertySet;       // What property set?
    ULONG       ulId;                   // What item?

    ULONG       ulSupported;            // Get/Set flags for QuerySupported

    ULONG       ulFlags;                // GENPROP_F_xxx

    LPVOID      pPropertyData;          // Data to be returned
    ULONG       cbPropertyData;         // and its size    

    GENPROPHANDLER pfnHandler;          // Handler fn iff GENPROP_F_FNHANDLER
};
#include <poppack.h>

class CDownloadItem : public CListItem
{
public:
	HANDLE	m_hItem;
	DWORD	m_dwID;
    CDownloadItem *GetNext() const {return (CDownloadItem *)CListItem::GetNext();};
};

/////////////////////////////////////////////////////////////////////////////
// CXboxLatencyClock

class CXboxLatencyClock: public IReferenceClock
{
public:
    // IUnknown
    //
    virtual STDMETHODIMP QueryInterface(const IID &iid, void **ppv);
    virtual STDMETHODIMP_(ULONG) AddRef();
    virtual STDMETHODIMP_(ULONG) Release();

    // IReferenceClock methods
    STDMETHODIMP GetTime( REFERENCE_TIME *pTime);
    STDMETHODIMP AdviseTime( REFERENCE_TIME baseTime, REFERENCE_TIME streamTime, HANDLE hEvent, DWORD *pdwAdviseCookie);
    STDMETHODIMP AdvisePeriodic( REFERENCE_TIME startTime, REFERENCE_TIME periodTime, HANDLE hSemaphore, DWORD *pdwAdviseCookie);
    STDMETHODIMP Unadvise( DWORD dwAdviseCookie);

public:
	CXboxLatencyClock();
	~CXboxLatencyClock();
	void SetXboxLatency( REFERENCE_TIME rtLatency );
	void SetSinkLatencyClock( IReferenceClock *pIReferenceClock );
	void SetMasterClock( IReferenceClock *pIReferenceClock );
	REFERENCE_TIME GetXboxLatency( void ) { return m_rtXboxLatency; }

private:
	long			m_cRef;
	IReferenceClock	*m_pSinkLatencyClock;
	IReferenceClock	*m_pMasterClock;
	REFERENCE_TIME	m_rtXboxLatency;
};

#define XBOX_APATH_SHARED_STEREOPLUSREVERB   0xFFFF0002

/////////////////////////////////////////////////////////////////////////////
// CUserModeSynth

class CUserModeSynth : 
#ifdef IMPLEMENT_SYNTH8
public IDirectMusicSynth8,
#else
public IDirectMusicSynth,
#endif
public IDirectSoundSource, public IKsControl
{

public:
    // IUnknown
    //
    virtual STDMETHODIMP QueryInterface(const IID &iid, void **ppv);
    virtual STDMETHODIMP_(ULONG) AddRef();
    virtual STDMETHODIMP_(ULONG) Release();

// IDirectMusicSynth
public:
	virtual STDMETHODIMP Open(LPDMUS_PORTPARAMS pPortParams);
	virtual STDMETHODIMP Close(); 
	virtual STDMETHODIMP SetNumChannelGroups(DWORD dwGroups);
	virtual STDMETHODIMP Download(LPHANDLE phDownload, LPVOID pvData, LPBOOL pbFree);
	virtual STDMETHODIMP Unload(HANDLE hDownload,
								HRESULT ( CALLBACK *lpFreeHandle)(HANDLE,HANDLE),
								HANDLE hUserData);
	virtual STDMETHODIMP PlayBuffer(REFERENCE_TIME rt, LPBYTE pbBuffer, DWORD cbBuffer);
	virtual STDMETHODIMP GetRunningStats(LPDMUS_SYNTHSTATS pStats);
	virtual STDMETHODIMP GetPortCaps(LPDMUS_PORTCAPS pCaps);
	virtual STDMETHODIMP SetMasterClock(IReferenceClock *pClock);
	virtual STDMETHODIMP GetLatencyClock(IReferenceClock **ppClock);
	virtual STDMETHODIMP Activate(BOOL fEnable);
	virtual STDMETHODIMP SetSynthSink(IDirectMusicSynthSink *pSynthSink);
	virtual STDMETHODIMP Render(short *pBuffer, DWORD dwLength, LONGLONG llPosition);
    virtual STDMETHODIMP SetChannelPriority(DWORD dwChannelGroup, DWORD dwChannel, DWORD dwPriority);
    virtual STDMETHODIMP GetChannelPriority(DWORD dwChannelGroup, DWORD dwChannel, LPDWORD pdwPriority);
    virtual STDMETHODIMP GetFormat(LPWAVEFORMATEX pWaveFormatEx, LPDWORD pdwWaveFormatExSize);
    virtual STDMETHODIMP GetAppend(DWORD* pdwAppend);

#ifdef IMPLEMENT_SYNTH8
// IDirectMusicSynth8
public:
	virtual STDMETHODIMP PlayVoice(REFERENCE_TIME rt, DWORD dwVoiceId, DWORD dwChannelGroup, DWORD dwChannel, DWORD dwDLId, PREL prPitch, VREL vrVolume, SAMPLE_TIME stVoiceStart, SAMPLE_TIME stLoopStart, SAMPLE_TIME stLoopEnd );
    virtual STDMETHODIMP StopVoice(REFERENCE_TIME rt, DWORD dwVoiceId );
    virtual STDMETHODIMP GetVoiceState(DWORD dwVoice[], DWORD cbVoice, DMUS_VOICE_STATE VoiceState[] );
    virtual STDMETHODIMP Refresh(DWORD dwDownloadID, DWORD dwFlags );
    virtual STDMETHODIMP AssignChannelToBuses(DWORD dwChannelGroup, DWORD dwChannel, LPDWORD pdwBuses, DWORD cBuses );
#endif

// IDirectSoundSource
public:
    virtual STDMETHODIMP GetFormat(LPWAVEFORMATEX pWaveFormatEx, DWORD dwSizeAllocated, LPDWORD pdwSizeWritten);
    virtual STDMETHODIMP SetSink(IDirectSoundConnect* pSinkConnect);
    virtual STDMETHODIMP Seek(ULONGLONG sp);
    virtual STDMETHODIMP Read(LPVOID *ppvBuffer, LPDWORD pdwIDs, LPDWORD pdwFuncIDs, LPLONG plPitchBends, DWORD cpvBuffer, PULONGLONG pcb);
	virtual STDMETHODIMP GetSize(PULONGLONG pcb);

// IDirectSoundSource : members 
private:
	ULONGLONG m_ullPosition;

// IKsControl
public:
 	virtual STDMETHODIMP KsProperty(
		PKSPROPERTY pPropertyIn, 
		ULONG ulPropertyLength,
		LPVOID pvPropertyData, 
		ULONG ulDataLength,
		PULONG pulBytesReturned);

    virtual STDMETHODIMP KsMethod(
        IN PKSMETHOD Method,
        IN ULONG MethodLength,
        IN OUT LPVOID MethodData,
        IN ULONG DataLength,
        OUT PULONG BytesReturned
    );

    virtual STDMETHODIMP KsEvent(
        IN PKSEVENT Event,
        IN ULONG EventLength,
        IN OUT LPVOID EventData,
        IN ULONG DataLength,
        OUT PULONG BytesReturned
    );
    
	CUserModeSynth();
	~CUserModeSynth();
	HRESULT		Init();

private:
	long		m_cRef;
	IDirectMusicSynthSink *m_pSynthSink;
	IDirectSoundSynthSink *m_pSynthSink8;
	CSynth *	m_pSynth;		// Just one synth engine.
	BOOL		m_fActive;		// Should we be active?
	BOOL		m_fPCActive;	// PC Synth currently active.
	BOOL		m_fXboxActive;	// Xbox Synth currently active.
	BOOL		m_fPCSynth;		// Enable the PC Synth
	BOOL		m_fXboxSynth;	// Enable the Xbox Synth
	DWORD		m_dwSampleRate;	// Synths sample rate 
	DWORD		m_dwChannels;	// number of ouput channels 
    DWORD       m_dwXboxAudioPath; // Default audiopath on xbox
	DWORD 		m_dwBufferFlags;// flags the type of output buffer dssink or interleaved or plain mono
    LONG        m_lVolume;      // in 1/100 dB
    LONG        m_lBoost;       // in 1/100 dB
    LONG        m_lGainAdjust;  // in 1/100 dB
    CRITICAL_SECTION m_CriticalSection; // Critical section to manage access.
    CRITICAL_SECTION m_XboxCriticalSection; // Critical section to manage access to the Xbox
    BOOL        m_fCSInitialized;
	PDM_CONNECTION m_pdmConnection;
	IReferenceClock *m_pMasterClock;
	CPhaseLockClock m_PLCXbox;
	CXboxLatencyClock m_XboxLatencyClock;

    HRESULT HandleSetVolume(ULONG ulId, BOOL fSet, LPVOID pbBuffer, PULONG pcbBuffer);
    HRESULT HandleSetBoost(ULONG ulId, BOOL fSet, LPVOID pbBuffer, PULONG pcbBuffer);
	HRESULT HandleReverb(ULONG ulId, BOOL fSet, LPVOID pbBuffer, PULONG pcbBuffer);
	HRESULT HandleEffects(ULONG ulId, BOOL fSet, LPVOID pbBuffer, PULONG pcbBuffer);
    HRESULT HandleGetSampleRate(ULONG ulId, BOOL fSet, LPVOID pbBuffer, PULONG pcbBuffer);
    HRESULT HandlePCSynth(ULONG ulId, BOOL fSet, LPVOID pbBuffer, PULONG pcbBuffer);
    HRESULT HandleXboxSynth(ULONG ulId, BOOL fSet, LPVOID pbBuffer, PULONG pcbBuffer);
    HRESULT HandleXboxPath(ULONG ulId, BOOL fSet, LPVOID pbBuffer, PULONG pcbBuffer);
	HRESULT HandleLatency(ULONG ulId, BOOL fSet, LPVOID pbBuffer, PULONG pcbBuffer);
    static GENERICPROPERTY m_aProperty[];
    static const int m_nProperty;
    //static GENERICPROPERTY *FindPropertyItem(REFGUID rguid, ULONG ulId);
    GENERICPROPERTY *FindPropertyItem(REFGUID rguid, ULONG ulId);

	HRESULT ActivateXboxSynth(BOOL fEnable);
	HRESULT ActivatePCSynth(BOOL fEnable);
	CList	m_lstDownloadItems;
};

// Class factory
//
// Common to emulation/WDM.
// 
class CDirectMusicSynthFactory : public IClassFactory
{
public:
	// IUnknown
    //
	virtual STDMETHODIMP QueryInterface(const IID &iid, void **ppv);
	virtual STDMETHODIMP_(ULONG) AddRef();
	virtual STDMETHODIMP_(ULONG) Release();

	// Interface IClassFactory
    //
	virtual STDMETHODIMP CreateInstance(IUnknown* pUnknownOuter, const IID& iid, void** ppv);
	virtual STDMETHODIMP LockServer(BOOL bLock); 

	// Constructor
    //
	CDirectMusicSynthFactory();

	// Destructor
	~CDirectMusicSynthFactory();

private:
	long m_cRef;
};



#endif //__UMSYNTH_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\XboxSynth\umsynth.cpp ===
//
// Copyright (c) 1996-2001 Microsoft Corporation
// UMSynth.cpp : Implementation of CUserModeSynth
//
// READ THIS!!!!!!!!!!!!!!!!!!!!!!!!!!!
//
// 4530: C++ exception handler used, but unwind semantics are not enabled. Specify -GX
//
// We disable this because we use exceptions and do *not* specify -GX (USE_NATIVE_EH in
// sources).
//
// The one place we use exceptions is around construction of objects that call
// InitializeCriticalSection. We guarantee that it is safe to use in this case with
// the restriction given by not using -GX (automatic objects in the call chain between
// throw and handler are not destructed). Turning on -GX buys us nothing but +10% to code
// size because of the unwind code.
//
// Any other use of exceptions must follow these restrictions or -GX must be turned on.
//
// READ THIS!!!!!!!!!!!!!!!!!!!!!!!!!!!
//

#pragma warning(disable:4530)

#include <objbase.h>
#include <mmsystem.h>
#include <dsoundp.h>
#include <ks.h>

#include "debug.h"
#include "UMSynth.h"
#include "dmusicc.h"
#include "dmusics.h"
#include "math.h"
#include "misc.h"
#include "dmksctrl.h"
#include "dsoundp.h"    // For IDirectSoundSource
#include "..\shared\dmusiccp.h" // For class ids.

#include <dmusprop.h>
#include <xboxdbg.h>

#include "validate.h"
#include <stdio.h>

extern long g_cComponent;

#define CMD_PREFIX      "XAUD"

/////////////////////////////////////////////////////////////////////
// User mode registry helper
//
BOOL GetRegValueDword(
    LPCTSTR szRegPath,
    LPCTSTR szValueName,
    LPDWORD pdwValue)
{
    HKEY  hKeyOpen;
    DWORD dwType;
    DWORD dwCbData;
    LONG  lResult;
    BOOL  fReturn = FALSE;

    assert(pdwValue);

    lResult = RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                           szRegPath,
                           0, KEY_QUERY_VALUE,
                           &hKeyOpen );

    if (lResult == ERROR_SUCCESS)
    {
        dwCbData = sizeof(DWORD);

        lResult = RegQueryValueEx(hKeyOpen,
                                  szValueName,
                                  NULL,
                                  &dwType,
                                  (LPBYTE)pdwValue,
                                  &dwCbData);

        if (lResult == ERROR_SUCCESS &&
            dwType == REG_DWORD)
        {
            fReturn = TRUE;
        }

        RegCloseKey( hKeyOpen );
    }

    return fReturn;
}

BOOL GetUserRegDWORD( LPCTSTR lpValueName, LPDWORD lpdwValue )
{
    const HKEY hKey = HKEY_CURRENT_USER;
    LPCTSTR lpSubKey = TEXT("Software\\Microsoft\\DMUSProducer\\XboxAddin\\");
	HKEY  hKeyOpen;
	LONG  lResult;
	BOOL  fSuccess = FALSE;
	DWORD dwType;
    DWORD dwSize = sizeof(DWORD);

	lResult = ::RegOpenKeyEx( hKey, lpSubKey, 0, KEY_READ, &hKeyOpen );
	if( lResult == ERROR_SUCCESS )
	{
		lResult = ::RegQueryValueEx( hKeyOpen, lpValueName, 0, &dwType, (BYTE *)lpdwValue, &dwSize );

		if( (dwType == REG_DWORD) && (lResult == ERROR_SUCCESS) && (dwSize == sizeof(DWORD)) )
		{
			fSuccess = TRUE;
		}

		::RegCloseKey( hKeyOpen );
	}

	return fSuccess;
}

BOOL GetUserRegString( LPCTSTR lpValueName, LPTSTR lpszString, LPDWORD lpdwSize )
{
    const HKEY hKey = HKEY_CURRENT_USER;
    LPCTSTR lpSubKey = TEXT("Software\\Microsoft\\DMUSProducer\\XboxAddin\\");
	HKEY  hKeyOpen;
	LONG  lResult;
	BOOL  fSuccess = FALSE;
	DWORD dwType;

	lResult = ::RegOpenKeyEx( hKey, lpSubKey, 0, KEY_READ, &hKeyOpen );
	if( lResult == ERROR_SUCCESS )
	{
		lResult = ::RegQueryValueEx( hKeyOpen, lpValueName, 0, &dwType, (BYTE *)lpszString, lpdwSize );

		if( (dwType == REG_SZ) && (lResult == ERROR_SUCCESS) )
		{
			fSuccess = TRUE;
		}

		::RegCloseKey( hKeyOpen );
	}

	return fSuccess;
}

DWORD GetTheCurrentTime()
{
    static BOOL s_fFirstTime = TRUE;
    static LARGE_INTEGER s_liPerfFrequency;
    static BOOL s_fUsePerfCounter = FALSE;
    if (s_fFirstTime)
    {
        s_fFirstTime = FALSE;
        s_fUsePerfCounter = QueryPerformanceFrequency(&s_liPerfFrequency);
        s_liPerfFrequency.QuadPart /= 1000;
    }
    if (s_fUsePerfCounter)
    {
        LARGE_INTEGER liPerfCounter;
        QueryPerformanceCounter(&liPerfCounter);
        liPerfCounter.QuadPart /= s_liPerfFrequency.QuadPart;
        return (DWORD) liPerfCounter.QuadPart;
    }
    else
    {
        return timeGetTime();
    }
}

/////////////////////////////////////////////////////////////////////////////
// CUserModeSynth

HRESULT CUserModeSynth::Init()
{
	return S_OK;
}


CUserModeSynth::CUserModeSynth()
{
    InterlockedIncrement(&g_cComponent);

    m_fCSInitialized = FALSE;
    ::InitializeCriticalSection(&m_CriticalSection);
    // Note: on pre-Blackcomb OS's, this call can raise an exception; if it
    // ever pops in stress, we can add an exception handler and retry loop.
    m_fCSInitialized = TRUE;
    ::InitializeCriticalSection(&m_XboxCriticalSection);

	m_fPCSynth = TRUE;
    DWORD dwResult;
    if( GetUserRegDWORD( TEXT("EnablePCSynth"), &dwResult ) )
    {
        m_fPCSynth = dwResult ? TRUE : FALSE;
    }
	m_fXboxSynth = TRUE;
    if( GetUserRegDWORD( TEXT("EnableXboxSynth"), &dwResult ) )
    {
        m_fXboxSynth = dwResult ? TRUE : FALSE;
    }
    m_cRef = 0;
    m_dwSampleRate = 22050;
    m_dwChannels = 2;
    m_lVolume = 0;
    m_lBoost = 6 * 100;
    m_lGainAdjust = 6 * 100;            // Default 6 dB boost
	m_fActive = FALSE;
    m_fPCActive = FALSE;
	m_fXboxActive = FALSE;
    m_dwXboxAudioPath = XBOX_APATH_SHARED_STEREOPLUSREVERB;
    m_pSynth = NULL;
    m_pSynthSink = NULL;
    m_pSynthSink8 = NULL;
	m_pMasterClock = NULL;
    m_ullPosition = 0;
    m_dwBufferFlags = BUFFERFLAG_INTERLEAVED;
	m_pdmConnection = NULL;
	m_XboxLatencyClock.SetXboxLatency( 50000 ); // default to 5ms
}

CUserModeSynth::~CUserModeSynth()
{
    Activate(FALSE);

	while( !m_lstDownloadItems.IsEmpty() )
	{
		delete (CDownloadItem *)m_lstDownloadItems.RemoveHead();
	}

    if (m_fCSInitialized)
    {
        ::EnterCriticalSection(&m_XboxCriticalSection);
	    if( m_pdmConnection )
	    {
		    DmCloseConnection(m_pdmConnection);
		    m_pdmConnection = NULL;
	    }
        ::LeaveCriticalSection(&m_XboxCriticalSection);

        ::EnterCriticalSection(&m_CriticalSection);

		if( m_pMasterClock )
		{
			m_pMasterClock->Release();
		}
        if (m_pSynth)
        {
            delete m_pSynth;
            m_pSynth = NULL;
        }

        if (m_pSynthSink)
        {
            m_pSynthSink->Release();
        }

        if (m_pSynthSink8)
        {
            m_pSynthSink8->Release();
        }

        ::LeaveCriticalSection(&m_CriticalSection);
        ::DeleteCriticalSection(&m_CriticalSection);
        ::DeleteCriticalSection(&m_XboxCriticalSection);
    }

      InterlockedDecrement(&g_cComponent);
}


// CUserModeSynth::QueryInterface
//
STDMETHODIMP
CUserModeSynth::QueryInterface(const IID &iid, void **ppv)
{
    V_INAME(IDirectMusicSynth::QueryInterface);
    V_REFGUID(iid);
    V_PTRPTR_WRITE(ppv);

    if (iid == IID_IUnknown || iid == IID_IDirectMusicSynth) {
        *ppv = static_cast<IDirectMusicSynth*>(this);
    }
    else if (iid == IID_IKsControl)
    {
        *ppv = static_cast<IKsControl*>(this);
    }
#ifdef IMPLEMENT_SYNTH8
    else if (iid == IID_IDirectMusicSynth8 )
    {
        *ppv = static_cast<IDirectMusicSynth8*>(this);
    }
#endif
    else if (iid == IID_IDirectSoundSource)
    {
        *ppv = static_cast<IDirectSoundSource*>(this);
    }
    else
    {
        *ppv = NULL;
        return E_NOINTERFACE;
    }

    reinterpret_cast<IUnknown*>(this)->AddRef();
    return S_OK;
}

// CUserModeSynth::AddRef
//
STDMETHODIMP_(ULONG)
CUserModeSynth::AddRef()
{
    return InterlockedIncrement(&m_cRef);
}

// CUserModeSynth::Release
//
STDMETHODIMP_(ULONG)
CUserModeSynth::Release()
{
    if (!InterlockedDecrement(&m_cRef)) {
        delete this;
        return 0;
    }

    return m_cRef;
}

STDMETHODIMP CUserModeSynth::SetSynthSink(
    IDirectMusicSynthSink *pSynthSink)    // <i IDirectMusicSynthSink> to connect to synth, or
                                        // NULL to disconnect.
{
    HRESULT hr = S_OK;
    V_INAME(IDirectMusicSynth::SetSynthSink);
    V_INTERFACE_OPT(pSynthSink);

    ::EnterCriticalSection(&m_CriticalSection);

//>>>>>>>>. RELEASE THE DSINK IF PRESENT !!!!

    if (m_pSynthSink)
    {
        hr = m_pSynthSink->Init(NULL);
        m_pSynthSink->Release();
    }

    m_pSynthSink = pSynthSink;

//>>>>>>>>> the current state of the format of the the synth is
//>>>>>>>>> ambiguos if a sink has been previously applied.
    m_dwBufferFlags &= ~BUFFERFLAG_MULTIBUFFER;    // .... just in case

    if (m_pSynthSink)
    {
        m_pSynthSink->AddRef();
        hr = m_pSynthSink->Init(static_cast<IDirectMusicSynth*>(this));
    }
    ::LeaveCriticalSection(&m_CriticalSection);

    return hr;
}

STDMETHODIMP CUserModeSynth::Open(
    LPDMUS_PORTPARAMS pPortParams)        // <t DMUS_PORTPARAMS> structure for opening the port. If NULL, default settings are used.
{
    V_INAME(IDirectMusicSynth::Open);
    //if (pPortParams == NULL)
    //{
    //    Trace(1, "Error: Open called with NULL PortParams.\n");
    //    return E_FAIL;
    //}

    DWORD cbPortParams = 0;
    DWORD dwVer;

    if (pPortParams)
    {
        V_STRUCTPTR_READ_VER(pPortParams, dwVer);
        V_STRUCTPTR_READ_VER_CASE(DMUS_PORTPARAMS, 7);
        V_STRUCTPTR_READ_VER_CASE(DMUS_PORTPARAMS, 8);
        V_STRUCTPTR_READ_VER_END(DMUS_PORTPARAMS, pPortParams);

        switch (dwVer)
        {
            case 7:
                cbPortParams = sizeof(DMUS_PORTPARAMS7);
                break;

            case 8:
                cbPortParams = sizeof(DMUS_PORTPARAMS8);
                break;
        }
    }

    bool bPartialOpen = false;

    DMUS_PORTPARAMS myParams;
    myParams.dwSize = sizeof (myParams);
    myParams.dwVoices = 32;
    myParams.dwChannelGroups = 2;
    myParams.dwAudioChannels = 2;
    myParams.dwSampleRate = 22050;
#ifdef REVERB_ENABLED
    myParams.dwEffectFlags = DMUS_EFFECT_REVERB;
#else
    myParams.dwEffectFlags = DMUS_EFFECT_NONE;
#endif
    myParams.fShare = FALSE;
    myParams.dwValidParams =
        DMUS_PORTPARAMS_VOICES |
        DMUS_PORTPARAMS_CHANNELGROUPS |
        DMUS_PORTPARAMS_AUDIOCHANNELS |
        DMUS_PORTPARAMS_SAMPLERATE |
        DMUS_PORTPARAMS_EFFECTS |
        DMUS_PORTPARAMS_SHARE;

    if (pPortParams)
    {
        if (pPortParams->dwSize >= sizeof(DMUS_PORTPARAMS8))
        {
            myParams.dwValidParams |= DMUS_PORTPARAMS_FEATURES;
            myParams.dwFeatures = 0;
        }
        if (pPortParams->dwValidParams & DMUS_PORTPARAMS_VOICES)
        {
            if (pPortParams->dwVoices)
            {
                if (pPortParams->dwVoices <= MAX_VOICES)
                {
                    myParams.dwVoices = pPortParams->dwVoices;
                }
                else
                {
                    bPartialOpen = true;
                    myParams.dwVoices = MAX_VOICES;
                }
            }
            else
            {
                bPartialOpen = true;
                myParams.dwVoices = 1; // MIN_VOICES
            }
        }
        if (pPortParams->dwValidParams & DMUS_PORTPARAMS_CHANNELGROUPS)
        {
            if (pPortParams->dwChannelGroups)
            {
                if (pPortParams->dwChannelGroups <= MAX_CHANNEL_GROUPS)
                {
                    myParams.dwChannelGroups = pPortParams->dwChannelGroups;
                }
                else
                {
                    bPartialOpen = true;
                    myParams.dwChannelGroups = MAX_CHANNEL_GROUPS;
                }
            }
            else
            {
                bPartialOpen = true;
                myParams.dwChannelGroups = 1; // MIN_CHANNEL_GROUPS
            }
        }
        if (pPortParams->dwValidParams & DMUS_PORTPARAMS_AUDIOCHANNELS)
        {
            if (pPortParams->dwAudioChannels)
            {
                if (pPortParams->dwAudioChannels <= 2)
                {
                    myParams.dwAudioChannels = pPortParams->dwAudioChannels;
                }
                else
                {
                    bPartialOpen = true;
                    myParams.dwAudioChannels = 2; // MAX_AUDIO_CHANNELS
                }
            }
            else
            {
                bPartialOpen = true;
                myParams.dwAudioChannels = 1; // MIN_AUDIO_CHANNELS
            }
        }
        if (pPortParams->dwValidParams & DMUS_PORTPARAMS_SAMPLERATE)
        {
            if (dwVer == 7)
            {
                // DX-7 compat: clamp sample rate to one of the
                // understood rates.
                //
                if (pPortParams->dwSampleRate > 30000)
                {
                    if(pPortParams->dwSampleRate != 44100)
                    {
                        bPartialOpen = true;
                    }

                    myParams.dwSampleRate = 44100;
                }
                else if (pPortParams->dwSampleRate > 15000)
                {
                    if(pPortParams->dwSampleRate != 22050)
                    {
                        bPartialOpen = true;
                    }

                    myParams.dwSampleRate = 22050;
                }
                else
                {
                    if(pPortParams->dwSampleRate != 11025)
                    {
                        bPartialOpen = true;
                    }

                    myParams.dwSampleRate = 11025;
                }
            }
            else
            {
                if (pPortParams->dwSampleRate > 96000)
                {
                    bPartialOpen = true;
                    myParams.dwSampleRate = 96000;
                }
                else if (pPortParams->dwSampleRate < 11025)
                {
                    bPartialOpen = true;
                    myParams.dwSampleRate = 11025;
                }
                else myParams.dwSampleRate = pPortParams->dwSampleRate;
            }
        }
        if (pPortParams->dwValidParams & DMUS_PORTPARAMS_EFFECTS)
        {
            if (pPortParams->dwEffectFlags & ~DMUS_EFFECT_REVERB)
            {
                bPartialOpen = true;
                pPortParams->dwEffectFlags &= DMUS_EFFECT_REVERB;
            }

#ifdef REVERB_ENABLED
            myParams.dwEffectFlags = pPortParams->dwEffectFlags;
#else
            myParams.dwEffectFlags = DMUS_EFFECT_NONE;
            if (pPortParams->dwEffectFlags & DMUS_EFFECT_REVERB)
            {
                bPartialOpen = true;
            }
#endif
        }
        if (pPortParams->dwValidParams & DMUS_PORTPARAMS_SHARE)
        {
            if (pPortParams->fShare)
            {
                bPartialOpen = true;
            }
        }

        if ((pPortParams->dwValidParams & DMUS_PORTPARAMS_FEATURES) &&
            (pPortParams->dwSize >= sizeof(DMUS_PORTPARAMS8)))
        {
            myParams.dwFeatures = pPortParams->dwFeatures;
        }
    }

    if (pPortParams)
    {
        DWORD dwSize = min(cbPortParams, myParams.dwSize);

        memcpy(pPortParams, &myParams, dwSize);
        pPortParams->dwSize = dwSize;
    }

    m_dwSampleRate = myParams.dwSampleRate;
    m_dwChannels = myParams.dwAudioChannels;
    m_dwBufferFlags = (m_dwChannels==1)?BUFFERFLAG_MONO:BUFFERFLAG_INTERLEAVED;

    ::EnterCriticalSection(&m_CriticalSection);
    HRESULT hr = DMUS_E_ALREADYOPEN;
    if (!m_pSynth)
    {
        try
        {
            m_pSynth = new CSynth;
        }
        catch( ... )
        {
            m_pSynth = NULL;
        }

        if (!m_pSynth)
        {
            hr = E_OUTOFMEMORY;
        }
        else
        {
            hr = m_pSynth->Open(myParams.dwChannelGroups,
                myParams.dwVoices,
                (myParams.dwEffectFlags & DMUS_EFFECT_REVERB) ? TRUE : FALSE);
            if (SUCCEEDED(hr))
            {
                m_pSynth->SetGainAdjust(m_lGainAdjust);
                m_pSynth->Activate(m_dwSampleRate, m_dwBufferFlags);
            }
            else
            {
                delete m_pSynth;
                m_pSynth = NULL;
            }
        }
    }
    ::LeaveCriticalSection(&m_CriticalSection);

    if(SUCCEEDED(hr))
    {
        if(bPartialOpen)
        {
            hr = S_FALSE;
        }
    }

    return hr;
}

STDMETHODIMP CUserModeSynth::SetNumChannelGroups(
    DWORD dwGroups)        // Number of ChannelGroups requested.
{
    ::EnterCriticalSection(&m_CriticalSection);
    HRESULT hr = DMUS_E_SYNTHNOTCONFIGURED;
    if (m_pSynth)
    {
        hr = m_pSynth->SetNumChannelGroups(dwGroups);

/*        ::EnterCriticalSection( &m_XboxCriticalSection );
	    if( m_pdmConnection && m_fXboxActive )
        {
		    char	szCmd[MAX_PATH];
		    char    szResp[MAX_PATH];
		    DWORD   cchResp = MAX_PATH;

		    sprintf(szCmd, TEXT(CMD_PREFIX "!Synth.SetChannelGroups %d"), m_pSynth->m_dwControlCount );
            DmSendCommand(m_pdmConnection, szCmd, szResp, &cchResp);
        }
        ::LeaveCriticalSection( &m_XboxCriticalSection );*/
    }
    ::LeaveCriticalSection(&m_CriticalSection);
    return hr;
}

STDMETHODIMP CUserModeSynth::Close()
{
    ::EnterCriticalSection(&m_CriticalSection);
    HRESULT hr = DMUS_E_ALREADYCLOSED;
    if (m_pSynth)
    {
        hr = m_pSynth->Close();
        delete m_pSynth;
        m_pSynth = NULL;
    }
    ::LeaveCriticalSection(&m_CriticalSection);
    return hr;
}
STDMETHODIMP CUserModeSynth::Download(
    LPHANDLE phDownload,    // Pointer to download handle, to be created by <om IDirectMusicSynth::Download> and used later to unload the data.
    LPVOID pvData,          // Pointer to continuous memory segment with download data.
    LPBOOL pbFree)          // <p pbFree> indicates whether the synthesizer wishes to keep the memory in <p pvData> allocated.
{
    HRESULT hr = DMUS_E_SYNTHNOTCONFIGURED;
    V_INAME(IDirectMusicSynth::Download);
    V_PTR_WRITE(phDownload, HANDLE);
    V_PTR_WRITE(pbFree, BOOL);

    // pvData is validated inside synth while parsing.
    ::EnterCriticalSection(&m_CriticalSection);

	HANDLE *phUpdate = NULL;

	DMUS_DOWNLOADINFO * pInfo = (DMUS_DOWNLOADINFO *)pvData;

    ::EnterCriticalSection( &m_XboxCriticalSection );
	if( m_pdmConnection && m_fXboxActive
	&&	((pInfo->dwDLType == DMUS_DOWNLOADINFO_INSTRUMENT) ||
		 (pInfo->dwDLType == DMUS_DOWNLOADINFO_INSTRUMENT2) ||
		 (pInfo->dwDLType == DMUS_DOWNLOADINFO_WAVE)) )
	{
		static DWORD s_dwID = 0;
		const DWORD cbBuffer = *(((DWORD *)phDownload) + 4);
		char	szCmd[MAX_PATH];
		char    szResp[MAX_PATH];
		DWORD   cchResp = MAX_PATH;

		const DWORD dwDownloadID = s_dwID;

		sprintf(szCmd, TEXT(CMD_PREFIX "!Synth.Download %d %d"), dwDownloadID, cbBuffer );

		s_dwID++;

		//OutputDebugStringA(szCmd);

		// Send the command to the Xbox
		HRESULT hr = DmSendCommand(m_pdmConnection, szCmd, szResp, &cchResp);

		//szResp[cchResp] = '\n';
		//szResp[cchResp+1] = 0;
		//OutputDebugStringA(szResp);

		if( SUCCEEDED(hr) )
		{
			// Send the buffer to the Xbox
			DmSendBinary(m_pdmConnection, pvData, cbBuffer);

			//OutputDebugStringA("Binary - ");

			// Receive the response
			DmReceiveStatusResponse(m_pdmConnection, szResp, &cchResp);

			//szResp[cchResp] = '\n';
			//szResp[cchResp+1] = 0;
			//OutputDebugStringA(szResp);

			CDownloadItem *pDownloadItem = new CDownloadItem;
			if( pDownloadItem )
			{
				phUpdate = &pDownloadItem->m_hItem;
				pDownloadItem->m_hItem = NULL;
				pDownloadItem->m_dwID = dwDownloadID;
				m_lstDownloadItems.AddHead( pDownloadItem );
			}
		}
	}
    ::LeaveCriticalSection( &m_XboxCriticalSection );

    if (m_pSynth)
    {
        hr = m_pSynth->Download(phDownload, pvData, pbFree);
    }

	if( phUpdate )
	{
		*phUpdate = *phDownload;
	}

    ::LeaveCriticalSection(&m_CriticalSection);

    return hr;
}

STDMETHODIMP CUserModeSynth::Unload(
    HANDLE hDownload,   // Handle to data, previously downloaded with a call to <om IDirectMusicSynth::Download>.
    HRESULT ( CALLBACK *lpFreeHandle)(HANDLE, HANDLE), // If the original call to
                        // <om IDirectMusicSynth::Download> returned FALSE in <p pbFree>,
                        // the synthesizer hung onto the memory in the download chunk. If so,
                        // the caller must be notified once the memory has been freed,
                        // but that could occur later than <om IDirectMusicSynth::Download>
                        // since a wave might be currently in use. <p lpFreeHandle> is a
                        // pointer to a callback
                        // function which will be called when the memory is no longer in use.
    HANDLE hUserData)   // Pointer to user data, passed as a parameter to the
                        // <p lpFreeHandle> function, typically used so the callback routine can retrieve
                        // its state.
{
    HRESULT hr = DMUS_E_SYNTHNOTCONFIGURED;
    ::EnterCriticalSection(&m_CriticalSection);

    ::EnterCriticalSection(&m_XboxCriticalSection);
	CDownloadItem *pDownloadItem = (CDownloadItem *)m_lstDownloadItems.GetHead();
	while( pDownloadItem )
	{
		if( pDownloadItem->m_hItem == hDownload )
		{
			m_lstDownloadItems.Remove( pDownloadItem );

	        if( m_pdmConnection )
	        {
			    char	szCmd[MAX_PATH];
			    char    szResp[MAX_PATH];
			    DWORD   cchResp = MAX_PATH;

			    sprintf(szCmd, TEXT(CMD_PREFIX "!Synth.Unload %d"), pDownloadItem->m_dwID );

			    // Send the command to the Xbox
			    DmSendCommand(m_pdmConnection, szCmd, szResp, &cchResp);
            }

			delete pDownloadItem;
			break;
		}
		pDownloadItem = pDownloadItem->GetNext();
	}
    ::LeaveCriticalSection(&m_XboxCriticalSection);

    if (m_pSynth)
    {
        hr = m_pSynth->Unload(hDownload, lpFreeHandle, hUserData);
    }

    ::LeaveCriticalSection(&m_CriticalSection);
    return hr;
}

STDMETHODIMP CUserModeSynth::PlayBuffer(
    REFERENCE_TIME rt,  // Start time of the buffer. This should be in
                        // REFERENCE_TIME units, relative to the master
                        // clock, previously set with a call to <om IDirectMusicSynth::SetMasterClock>.
                        // And, this should be after the time returned by the clock in
                        // <om IDirectMusicSynth::GetLatencyClock>.
    LPBYTE pbBuffer,    // Memory chunk with all the MIDI events, generated by <i IDirectMusicBuffer>.
    DWORD cbBuffer)     // Size of buffer.
{
    class MIDIEVENT : public DMUS_EVENTHEADER {
    public:
         BYTE  abEvent[4];           /* Actual event data, rounded up to be an even number */
                                     /* of QWORD's (8 bytes) */
    };

    typedef class MIDIEVENT FAR  *LPMIDIEVENT;
    #define QWORD_ALIGN(x) (((x) + 7) & ~7)

    HRESULT hr;

    V_INAME(IDirectMusicSynth::PlayBuffer);
    V_BUFPTR_READ(pbBuffer, cbBuffer);

    ::EnterCriticalSection(&m_CriticalSection);

    if (!m_fPCActive && !m_fXboxActive)
    {
        ::LeaveCriticalSection(&m_CriticalSection);
        Trace(3, "Warning: Synth is inactive, can not process MIDI events.\n");
        return DMUS_E_SYNTHINACTIVE;
    }

    ::EnterCriticalSection(&m_XboxCriticalSection);
	if( m_pdmConnection && m_fXboxActive )
	{
		char	szCmd[MAX_PATH];
		char    szResp[MAX_PATH];
		DWORD   cchResp = MAX_PATH;

		REFERENCE_TIME rtNow = 0;
		REFERENCE_TIME rtSlave = 0;
		m_pMasterClock->GetTime( &rtNow );
		if( SUCCEEDED( DmSendCommand(m_pdmConnection, CMD_PREFIX "!Synth.GetTime", szResp, &cchResp) ) )
		{
			if( 1 == sscanf(szResp, "200- %I64d", &rtSlave) )
			{
				m_PLCXbox.SyncToMaster( rtSlave, rtNow );
			}
		}

		// Convert from PC clock to Xbox clock
		REFERENCE_TIME rtXbox = rt;
		m_PLCXbox.SetSlaveTime( rtXbox, &rtXbox);

		//sprintf(szCmd, "PlayBuffer %I64d %I64d %I64d %I64d\n", rtXbox, rtSlave, rt, rtNow );

		//OutputDebugStringA(szCmd);

		sprintf(szCmd, TEXT(CMD_PREFIX "!Synth.PlayBuffer %I64d %I64d %d"), rtXbox, rtNow, cbBuffer );

		//OutputDebugStringA(szCmd);

		// Send the command to the Xbox
		cchResp = MAX_PATH;
		HRESULT hr = DmSendCommand(m_pdmConnection, szCmd, szResp, &cchResp);

		//szResp[cchResp] = '\n';
		//szResp[cchResp+1] = 0;
		//OutputDebugStringA(szResp);

		if( SUCCEEDED(hr) )
		{
			// Send the buffer to the Xbox
			DmSendBinary(m_pdmConnection, pbBuffer, cbBuffer);

			//OutputDebugStringA("Binary - ");

			// Receive the response
			DmReceiveStatusResponse(m_pdmConnection, szResp, &cchResp);

			//szResp[cchResp] = '\n';
			//szResp[cchResp+1] = 0;
			//OutputDebugStringA(szResp);
		}
	}
    ::LeaveCriticalSection(&m_XboxCriticalSection);

    if (!m_fPCActive)
    {
        // m_fXboxActive must be true
        ::LeaveCriticalSection(&m_CriticalSection);
        return S_OK;
    }

    if (!m_pSynthSink && !m_pSynthSink8)
    {
        ::LeaveCriticalSection(&m_CriticalSection);
        return DMUS_E_NOSYNTHSINK;
    }

    LPMIDIEVENT lpEventHdr;
    DWORD cbEvent;

    while (cbBuffer)
    {
        if (cbBuffer < sizeof(DMUS_EVENTHEADER))
        {
            Trace(1, "Error: PlayBuffer called with error in buffer size.\n");
            ::LeaveCriticalSection(&m_CriticalSection);
            return E_INVALIDARG;
        }

        lpEventHdr = (LPMIDIEVENT)pbBuffer;
        cbEvent = DMUS_EVENT_SIZE(lpEventHdr->cbEvent);
        if (cbEvent > cbBuffer)
        {
            Trace(1, "Error: PlayBuffer called with error in event size.\n");
            ::LeaveCriticalSection(&m_CriticalSection);
            return E_INVALIDARG;
        }

        pbBuffer += cbEvent;
        cbBuffer -= cbEvent;
        if ( m_pSynthSink )
        {
            hr = m_pSynth->PlayBuffer(m_pSynthSink,
                                      rt + lpEventHdr->rtDelta,
                                      &lpEventHdr->abEvent[0],
                                      lpEventHdr->cbEvent,
                                      lpEventHdr->dwChannelGroup);
        }

        if ( m_pSynthSink8 )
        {
            hr = m_pSynth->PlayBuffer(m_pSynthSink8,
                                      rt + lpEventHdr->rtDelta,
                                      &lpEventHdr->abEvent[0],
                                      lpEventHdr->cbEvent,
                                      lpEventHdr->dwChannelGroup);
        }

        if (FAILED(hr))
        {
            ::LeaveCriticalSection(&m_CriticalSection);
            return hr;
        }
    }
    ::LeaveCriticalSection(&m_CriticalSection);
    return S_OK;
}


STDMETHODIMP CUserModeSynth::GetPortCaps(
    LPDMUS_PORTCAPS pCaps)    // <t DMUS_PORTCAPS> structure to be filled in by synth.
{
    V_INAME(IDirectMusicSynth::GetPortCaps);
    V_STRUCTPTR_WRITE(pCaps, DMUS_PORTCAPS);

    wcscpy(pCaps->wszDescription, L"Microsoft Xbox Synthesizer");

    pCaps->dwClass = DMUS_PC_OUTPUTCLASS;
    pCaps->dwType = DMUS_PORT_USER_MODE_SYNTH;
    pCaps->dwFlags = DMUS_PC_DLS | DMUS_PC_DLS2 | DMUS_PC_SOFTWARESYNTH | DMUS_PC_DIRECTSOUND | DMUS_PC_EXTERNAL;

    pCaps->guidPort = CLSID_XboxSynth;

    pCaps->dwMemorySize = DMUS_PC_SYSTEMMEMORY;
    pCaps->dwMaxChannelGroups = MAX_CHANNEL_GROUPS;
    pCaps->dwMaxVoices = MAX_VOICES;
    pCaps->dwMaxAudioChannels = 2;

    pCaps->dwEffectFlags = 0;

    return S_OK;
}

STDMETHODIMP CUserModeSynth::SetMasterClock(
    IReferenceClock *pClock)    // Pointer to master <i IReferenceClock>,
                                // used by all devices in current instance of DirectMusic.

{
    V_INAME(IDirectMusicSynth::SetMasterClock);
    V_INTERFACE(pClock);

	if(	m_pMasterClock )
	{
		m_pMasterClock->Release();
	}
	m_pMasterClock = pClock;
	if( m_pMasterClock )
	{
		m_pMasterClock->AddRef();
	}

	m_XboxLatencyClock.SetMasterClock( pClock );

    return S_OK;
}

STDMETHODIMP CUserModeSynth::GetLatencyClock(
    IReferenceClock **ppClock)    // <i IReferenceClock> interface designed to return the current mix time.

{
    IDirectSoundSynthSink* pDSSink = NULL;

    V_INAME(IDirectMusicSynth::GetLatencyClock);
    V_PTR_WRITE(ppClock, IReferenceClock *);

	return m_XboxLatencyClock.QueryInterface( IID_IReferenceClock, (void**)ppClock );
}

STDMETHODIMP CUserModeSynth::Activate(
    BOOL fEnable)            // Whether to activate or deactivate audio.
{
    HRESULT hr = S_OK;

//    ::EnterCriticalSection(&m_CriticalSection);
    if (fEnable && m_fActive)
    {
		Trace(1, "Error: Synth::Activate- synth already active\n");
		hr = S_FALSE;
	}
	else if (!fEnable && !m_fActive)
	{
        Trace(2, "Warning: Synth::Activate- synth already inactive\n");
        hr = S_FALSE;
	}
	else
	{
		if (m_fXboxSynth)
		{
			hr = ActivateXboxSynth( fEnable );
		}
		if (SUCCEEDED(hr) && m_fPCSynth)
		{
			hr = ActivatePCSynth( fEnable );

			// If this failed, undo the XboxSynth activation
			if (FAILED(hr) && m_fXboxSynth)
			{
				ActivateXboxSynth( !fEnable );
			}
		}
		if (SUCCEEDED(hr))
		{
			m_fActive = fEnable;
		}
	}
//    ::LeaveCriticalSection(&m_CriticalSection);
	return hr;
}

HRESULT CUserModeSynth::ActivateXboxSynth(BOOL fEnable)
{
	if( fEnable && m_fXboxActive )
	{
		return S_FALSE;
	}
	
	if( !fEnable && !m_fXboxActive )
	{
		return S_FALSE;
	}

	if( !m_fXboxSynth )
	{
		return S_FALSE;
	}

    ::EnterCriticalSection(&m_XboxCriticalSection);
	HRESULT hr = S_OK;
	if( fEnable )
	{
		bool fWrongVersion = false;

		// If no connection, try and connect to the Xbox
		if( !m_pdmConnection )
		{
        	TCHAR tcstrXboxName[MAX_PATH];
	        ZeroMemory( tcstrXboxName, sizeof(TCHAR) * MAX_PATH );
	        DWORD dwCbData = sizeof(TCHAR) * MAX_PATH;
	        if( GetUserRegString( TEXT("XboxName"), tcstrXboxName, &dwCbData ) )
	        {
        		hr = DmSetXboxNameNoRegister( tcstrXboxName );
	        }

			DmOpenConnection(&m_pdmConnection);

			if( m_pdmConnection )
			{
				// Send a command to the Xbox, to make sure DMConsole is running
				DWORD cchResp = MAX_PATH;
				char szResp[MAX_PATH];

				// If the connection failed
				if( FAILED(DmSendCommand(m_pdmConnection, TEXT(CMD_PREFIX "!__connect__"), szResp, &cchResp)))
				{
					// DMConsole is not running - close the connection
					DmCloseConnection(m_pdmConnection);
					m_pdmConnection = NULL;
				}
				/*
				else if( strcmp(szResp, "200- Version 0.1 Connected.") )
				{
					fWrongVersion = true;

					// Wrong version of DMConsole is running - close the connection
					DmCloseConnection(m_pdmConnection);
					m_pdmConnection = NULL;
				}
				*/
			}
		}

		// If no connection, fail
		if (m_pdmConnection == NULL)
		{
			hr = fWrongVersion ? XBDM_CANNOTACCESS : XBDM_CANNOTCONNECT;
		}
		else
		{
			m_fXboxActive = TRUE;

			// Initialize the AudConsole application
		    char    szResp[MAX_PATH];
		    DWORD   cchResp = MAX_PATH;
            DmSendCommand(m_pdmConnection, TEXT(CMD_PREFIX "!Synth.Initialize"), szResp, &cchResp);

            // Initialize number of channel groups
            if( m_pSynth )
            {
			    char	szCmd[MAX_PATH];
		        sprintf(szCmd, TEXT(CMD_PREFIX "!Synth.SetChannelGroups %d"), m_pSynth->m_dwControlCount );
                DmSendCommand(m_pdmConnection, szCmd, szResp, &cchResp);
            }

            // Initialize default audiopath
	        if( m_pSynth )
            {
		        char	szCmd[MAX_PATH];
		        sprintf(szCmd, TEXT(CMD_PREFIX "!Synth.SetDefaultAudiopath %d"), m_dwXboxAudioPath );
                DmSendCommand(m_pdmConnection, szCmd, szResp, &cchResp);
            }


			// Initialize the PL clock
			REFERENCE_TIME rtNow = 0;
			m_pMasterClock->GetTime( &rtNow );

			cchResp = MAX_PATH;
			if( SUCCEEDED( DmSendCommand(m_pdmConnection, CMD_PREFIX "!Synth.GetTime", szResp, &cchResp) ) )
			{
				REFERENCE_TIME rtSlave;
				if( 1 == sscanf(szResp, "200- %I64d", &rtSlave) )
				{
					m_PLCXbox.Start( rtNow, rtSlave );
				}
			}
		}
	}
	else
	{
	    if( m_pdmConnection )
	    {
            // Unload everything we've downloaded
			char	szCmd[MAX_PATH];
			char    szResp[MAX_PATH];
		    DWORD   cchResp = MAX_PATH;
	        while( !m_lstDownloadItems.IsEmpty() )
	        {
		        CDownloadItem *pDownloadItem = (CDownloadItem *)m_lstDownloadItems.RemoveHead();

			    sprintf(szCmd, TEXT(CMD_PREFIX "!Synth.Unload %d"), pDownloadItem->m_dwID );

			    // Send the command to the Xbox
			    DmSendCommand(m_pdmConnection, szCmd, szResp, &cchResp);

			    delete pDownloadItem;
	        }

            DmSendCommand(m_pdmConnection, TEXT(CMD_PREFIX "!Synth.Uninitialize"), szResp, &cchResp);

			DmCloseConnection(m_pdmConnection);
		    m_pdmConnection = NULL;
	    }

		m_fXboxActive = FALSE;
	}
    ::LeaveCriticalSection(&m_XboxCriticalSection);

	return hr;
}

HRESULT CUserModeSynth::ActivatePCSynth(BOOL fEnable)
{
	if( fEnable && m_fPCActive )
	{
		return S_FALSE;
	}
	
	if( !fEnable && !m_fPCActive )
	{
		return S_FALSE;
	}

	if( !m_fPCSynth )
	{
		return S_FALSE;
	}

	HRESULT hr = DMUS_E_SYNTHNOTCONFIGURED;

    ::EnterCriticalSection(&m_CriticalSection);
    if (m_pSynthSink || m_pSynthSink8)
    {
		if( fEnable )
		{
			if (m_dwSampleRate && m_dwChannels)
			{
				if (m_pSynth)
				{
					m_pSynth->Activate(m_dwSampleRate, m_dwBufferFlags);

					if (m_pSynthSink)
					{
						if (SUCCEEDED(m_pSynthSink->Activate(fEnable)))
						{
							m_fPCActive = TRUE;
							hr = S_OK;

							IReferenceClock *pLatencyClock;
							if( SUCCEEDED( m_pSynthSink->GetLatencyClock( &pLatencyClock ) ) )
							{
								m_XboxLatencyClock.SetSinkLatencyClock( pLatencyClock );
								pLatencyClock->Release();
							}
						}
					}

					if ( m_pSynthSink8 )
					{
						hr = m_pSynthSink8->Activate(fEnable);
						if (SUCCEEDED(hr) || hr == DMUS_E_SYNTHACTIVE)
						{
							m_fPCActive = TRUE;
							hr = S_OK;

							IReferenceClock *pLatencyClock;
							if( SUCCEEDED( m_pSynthSink8->GetLatencyClock( &pLatencyClock ) ) )
							{
								m_XboxLatencyClock.SetSinkLatencyClock( pLatencyClock );
								pLatencyClock->Release();
							}
						}
					}
				}
			}
		}
		else
		{
            m_fPCActive = FALSE;

            if (m_pSynth)
            {
                m_pSynth->Deactivate();
            }

            if (m_pSynthSink)
            {
                if (SUCCEEDED(m_pSynthSink->Activate(fEnable)))
                {
                    hr = S_OK;
                }
            }

            if (m_pSynthSink8)
            {
                hr = m_pSynthSink8->Activate(fEnable);
            }

			m_XboxLatencyClock.SetSinkLatencyClock( NULL );
        }
    }
    else
    {
        Trace(1, "Error: Synth::Activate- sink not connected\n");
        hr = DMUS_E_NOSYNTHSINK;
    }
    ::LeaveCriticalSection(&m_CriticalSection);

    return hr;
}

STDMETHODIMP CUserModeSynth::Render(
    short *pBuffer,        // Pointer to buffer to write into.
    DWORD dwLength,        // Length of buffer, in samples. This is not the
                        // memory size of the buffer. The memory size may vary,
                        // dependant on the buffer format, which the synth
                        // sets when in response to an <om IDirectMusicSynth::Activate>
                        // command.
    LONGLONG llPosition)    // Position in the audio stream, also in samples.
                        // This should always increment by <p dwLength> after
                        // each call.
{
    V_INAME(IDirectMusicSynth::Render);
    V_BUFPTR_WRITE(pBuffer, dwLength << (m_dwBufferFlags&BUFFERFLAG_INTERLEAVED)?1:0 );

    if (!m_pSynthSink)
    {
        Trace(1, "Error: Synth is not configured, can not render.\n");
        return DMUS_E_SYNTHNOTCONFIGURED;
    }
    if (!m_fPCActive)
    {
        Trace(1, "Error: Synth is not inactive, can not render.\n");
        return DMUS_E_SYNTHINACTIVE;
    }

    ::EnterCriticalSection(&m_CriticalSection);
    if (m_pSynth)
    {
        DWORD dwID[2];
        DWORD dwFuncID[2];
        long lPitchBend[2];

        // Setup busid for a Backward compatible DX7 interleaved buffer
        dwID[0]     = DSBUSID_LEFT;
        dwID[1]     = DSBUSID_RIGHT;
        dwFuncID[0] = DSBUSID_LEFT;
        dwFuncID[1] = DSBUSID_RIGHT;
        lPitchBend[0] = lPitchBend[1] = 0;

        DWORD dwChannels = 1;
        if (m_pSynth->m_dwStereo)
        {
            dwChannels = 2;
        }
        m_pSynth->Mix(&pBuffer, dwID, dwFuncID, lPitchBend, dwChannels, m_dwBufferFlags, dwLength, llPosition);
    }
    ::LeaveCriticalSection(&m_CriticalSection);
    return S_OK;
}

STDMETHODIMP CUserModeSynth::SetChannelPriority(
    DWORD dwChannelGroup,
    DWORD dwChannel,
    DWORD dwPriority)
{
    if (m_pSynth)
    {
        return m_pSynth->SetChannelPriority(dwChannelGroup, dwChannel, dwPriority);
    }
    Trace(1, "Error: Synth not initialized.\n");
    return E_FAIL;
}

STDMETHODIMP CUserModeSynth::GetChannelPriority(
    DWORD dwChannelGroup,
    DWORD dwChannel,
    LPDWORD pdwPriority)
{
    if (m_pSynth)
    {
        return m_pSynth->GetChannelPriority(dwChannelGroup, dwChannel, pdwPriority);
    }
    Trace(1, "Error: Synth not initialized.\n");
    return E_FAIL;
}

// IDirectSoundSource version of GetFormat()

STDMETHODIMP CUserModeSynth::GetFormat(
    LPWAVEFORMATEX pWaveFormatEx,
    DWORD dwSizeAllocated,
    LPDWORD pdwSizeWritten)
{
    V_INAME(IDirectMusicSynth::GetFormat);

    if (!m_pSynth)
    {
        Trace(1, "Error: Synth is not configured, can not get format.\n");
        return DMUS_E_SYNTHNOTCONFIGURED;
    }

    if (!pWaveFormatEx && !pdwSizeWritten)
    {
        Trace(1, "Error: GetFormat failed, must request either the format or the required size");
        return E_INVALIDARG;
    }

    if (pdwSizeWritten)
    {
        V_PTR_WRITE(pdwSizeWritten, DWORD);
        *pdwSizeWritten = sizeof(WAVEFORMATEX);
    }

    if (pWaveFormatEx)
    {
        V_BUFPTR_WRITE_OPT(pWaveFormatEx, dwSizeAllocated);
        WAVEFORMATEX wfx;
        memset(&wfx, 0, sizeof(wfx));
        wfx.wFormatTag = WAVE_FORMAT_PCM;
        wfx.nChannels = (WORD)m_dwChannels;
        wfx.nSamplesPerSec = (WORD)m_dwSampleRate;
        wfx.wBitsPerSample = 16;
        wfx.nBlockAlign = wfx.nChannels * (wfx.wBitsPerSample / 8);
        wfx.nAvgBytesPerSec = wfx.nSamplesPerSec * wfx.nBlockAlign;
        wfx.cbSize = 0; // no extra data

        memcpy(pWaveFormatEx, &wfx, min(sizeof wfx, dwSizeAllocated));
    }

    return S_OK;
}

// IDirectMusicSynth8 version of GetFormat()

STDMETHODIMP CUserModeSynth::GetFormat(
    LPWAVEFORMATEX pWaveFormatEx,
    LPDWORD pdwWaveFormatExSize)
{
    V_INAME(IDirectMusicSynth::GetFormat);
    V_PTR_WRITE(pdwWaveFormatExSize, DWORD);
    V_BUFPTR_WRITE_OPT(pWaveFormatEx, *pdwWaveFormatExSize);
    return GetFormat(pWaveFormatEx, *pdwWaveFormatExSize, pdwWaveFormatExSize);
}

STDMETHODIMP CUserModeSynth::GetAppend(
    DWORD* pdwAppend)
{
    V_INAME(IDirectMusicSynth::GetAppend);
    V_PTR_WRITE(pdwAppend, DWORD);

    *pdwAppend = 2; // The synth needs 1 extra sample for loop interpolation.
                    // We're adding one more to be paranoid.
    return S_OK;
}

STDMETHODIMP CUserModeSynth::GetRunningStats(
    LPDMUS_SYNTHSTATS pStats)    // <t DMUS_SYNTHSTATS> structure to fill in.

{
    HRESULT hr = DMUS_E_SYNTHNOTCONFIGURED;
    V_INAME(IDirectMusicSynth::GetRunningStats);
    V_STRUCTPTR_WRITE(pStats, DMUS_SYNTHSTATS);
    if ( pStats->dwSize == sizeof(DMUS_SYNTHSTATS8) )
    {
        V_STRUCTPTR_WRITE(pStats, DMUS_SYNTHSTATS8);
    }

    if (!m_pSynthSink && !m_pSynthSink8)
    {
        Trace(1, "Error: Synth::GetRunningStats failed because synth is inactove.\n");
        return hr;
    }

    if (m_fPCActive)
    {
        ::EnterCriticalSection(&m_CriticalSection);
        if (m_pSynth)
        {
            PerfStats Stats;
            m_pSynth->GetPerformanceStats(&Stats);
            long lCPU = Stats.dwCPU;
            if (Stats.dwVoices)
            {
                lCPU /= Stats.dwVoices;
            }
            else
            {
                lCPU = 0;
            }
            pStats->dwVoices = Stats.dwVoices;
            pStats->dwCPUPerVoice = lCPU * 10;
            pStats->dwTotalCPU = Stats.dwCPU * 10;
            pStats->dwLostNotes = Stats.dwNotesLost;
            long ldB = 6;
            double fLevel = Stats.dwMaxAmplitude;
            if (Stats.dwMaxAmplitude < 1)
            {
                fLevel = -96.0;
            }
            else
            {
                fLevel /= 32768.0;
                fLevel = log10(fLevel);
                fLevel *= 20.0;
            }
            pStats->lPeakVolume = (long) fLevel;
            pStats->dwValidStats = DMUS_SYNTHSTATS_VOICES | DMUS_SYNTHSTATS_TOTAL_CPU |
                DMUS_SYNTHSTATS_CPU_PER_VOICE | DMUS_SYNTHSTATS_LOST_NOTES | DMUS_SYNTHSTATS_PEAK_VOLUME;

            if ( pStats->dwSize == sizeof(DMUS_SYNTHSTATS8) )
            {
                ((DMUS_SYNTHSTATS8*)pStats)->dwSynthMemUse = m_pSynth->m_Instruments.m_dwSynthMemUse;
            }


            hr = S_OK;
        }
        ::LeaveCriticalSection(&m_CriticalSection);
    }
    else
    {
        DWORD dwSize = pStats->dwSize;
        memset(pStats, 0, dwSize);
        pStats->dwSize = dwSize;

        hr = S_OK;
    }
    return hr;
}

static DWORD dwPropFalse = FALSE;
static DWORD dwPropTrue  = TRUE;
static DWORD dwSystemMemory = DMUS_PC_SYSTEMMEMORY;

GENERICPROPERTY CUserModeSynth::m_aProperty[] =
{
    {
        &GUID_DMUS_PROP_GM_Hardware,        // Set
        0,                                  // Item
        KSPROPERTY_SUPPORT_GET,             // KS support flags
        GENPROP_F_STATIC,                   // GENPROP flags
        &dwPropFalse, sizeof(dwPropFalse),  // static data and size
        NULL                                // Handler
    },
    {   &GUID_DMUS_PROP_GS_Hardware,
        0,
        KSPROPERTY_SUPPORT_GET,
        GENPROP_F_STATIC,
        &dwPropFalse, sizeof(dwPropFalse),
        NULL
    },
    {   &GUID_DMUS_PROP_XG_Hardware,
        0,
        KSPROPERTY_SUPPORT_GET,
        GENPROP_F_STATIC,
        &dwPropFalse, sizeof(dwPropFalse),
        NULL
    },
    {   &GUID_DMUS_PROP_XG_Capable,
        0,
        KSPROPERTY_SUPPORT_GET,
        GENPROP_F_STATIC,
        &dwPropTrue, sizeof(dwPropTrue),
        NULL
    },
    {   &GUID_DMUS_PROP_GS_Capable,
        0,
        KSPROPERTY_SUPPORT_GET,
        GENPROP_F_STATIC,
        &dwPropTrue, sizeof(dwPropTrue),
        NULL
    },
    {   &GUID_DMUS_PROP_INSTRUMENT2,
        0,
        KSPROPERTY_SUPPORT_GET,
        GENPROP_F_STATIC,
        &dwPropTrue, sizeof(dwPropTrue),
        NULL
    },
    {
        &GUID_DMUS_PROP_DLS1,
        0,
        KSPROPERTY_SUPPORT_GET,
        GENPROP_F_STATIC,
        &dwPropTrue,  sizeof(dwPropTrue),
        NULL
    },
    {
        &GUID_DMUS_PROP_DLS2,
        0,
        KSPROPERTY_SUPPORT_GET,
        GENPROP_F_STATIC,
        &dwPropTrue,  sizeof(dwPropTrue),
        NULL
    },
    {
        &GUID_DMUS_PROP_SampleMemorySize,
        0,
        KSPROPERTY_SUPPORT_GET,
        GENPROP_F_STATIC,
        &dwSystemMemory,  sizeof(dwSystemMemory),
        NULL
    },
    {
        &KSPROPSETID_Synth,
        KSPROPERTY_SYNTH_VOLUME,
        KSPROPERTY_SUPPORT_SET,
        GENPROP_F_FNHANDLER,
        NULL, 0,
        CUserModeSynth::HandleSetVolume
    },
    {
        &KSPROPSETID_Synth,
        KSPROPERTY_SYNTH_VOLUMEBOOST,
        KSPROPERTY_SUPPORT_SET,
        GENPROP_F_FNHANDLER,
        NULL, 0,
        CUserModeSynth::HandleSetBoost
    },
    {
        &GUID_DMUS_PROP_WavesReverb,
        0,
        KSPROPERTY_SUPPORT_SET | KSPROPERTY_SUPPORT_GET,
        GENPROP_F_FNHANDLER,
        NULL, 0,
        CUserModeSynth::HandleReverb
    },
    {
        &GUID_DMUS_PROP_Effects,
        0,
        KSPROPERTY_SUPPORT_SET | KSPROPERTY_SUPPORT_GET,
        GENPROP_F_FNHANDLER,
        NULL, 0,
        CUserModeSynth::HandleEffects
    },
    {
        &GUID_DMUS_PROP_SamplePlaybackRate,
        0,
        KSPROPERTY_SUPPORT_GET,
        GENPROP_F_FNHANDLER,
        NULL, 0,
        CUserModeSynth::HandleGetSampleRate
    },
    {
        &GUID_Xbox_PROP_PCSynth,
        0,
        KSPROPERTY_SUPPORT_SET | KSPROPERTY_SUPPORT_GET,
        GENPROP_F_FNHANDLER,
        NULL, 0,
        CUserModeSynth::HandlePCSynth
    },
    {
        &GUID_Xbox_PROP_XboxSynth,
        0,
        KSPROPERTY_SUPPORT_SET | KSPROPERTY_SUPPORT_GET,
        GENPROP_F_FNHANDLER,
        NULL, 0,
        CUserModeSynth::HandleXboxSynth
    },
    {
        &GUID_Xbox_PROP_XboxAudioPath,
        0,
        KSPROPERTY_SUPPORT_SET | KSPROPERTY_SUPPORT_GET,
        GENPROP_F_FNHANDLER,
        NULL, 0,
        CUserModeSynth::HandleXboxPath
    },
	{
		&GUID_DMUS_PROP_WriteLatency,
        0,
        KSPROPERTY_SUPPORT_SET | KSPROPERTY_SUPPORT_GET,
        GENPROP_F_FNHANDLER,
        NULL, 0,
        CUserModeSynth::HandleLatency
    }
};

const int CUserModeSynth::m_nProperty = sizeof(m_aProperty) / sizeof(m_aProperty[0]);

HRESULT CUserModeSynth::HandlePCSynth(
        ULONG               ulId,
        BOOL                fSet,
        LPVOID              pbBuffer,
        PULONG              pcbBuffer)
{
    if (*pcbBuffer != sizeof(BOOL))
    {
        return E_INVALIDARG;
    }

	HRESULT hr = S_OK;

    if (fSet)
    {
		if (*(BOOL*)pbBuffer && m_fPCSynth)
		{
			hr = S_FALSE;
		}
		else if (!*(BOOL*)pbBuffer && !m_fPCSynth)
		{
			hr = S_FALSE;
		}
		else // m_fPCSynth will change
		{
			// If enabling PC Synth
			if( *(BOOL*)pbBuffer )
			{
				// Enable PC Synth
				m_fPCSynth = *(BOOL*)pbBuffer;

				// Activate the synth, if necessary
				if( m_fActive )
				{
					hr = ActivatePCSynth( TRUE );

					// If activation failed, reset m_fPCSynth
					if( FAILED(hr) )
					{
						m_fPCSynth = FALSE;
					}
				}
			}
			// If disabling PC Synth
			else
			{
				// Disable PC Synth

				// De-activate the synth, if necessary
				if( m_fPCActive )
				{
					hr = ActivatePCSynth( FALSE );
				}

				// If de-activation succeeded (or wasn't necessary), set m_fPCSynth
				if( SUCCEEDED(hr) )
				{
					m_fPCSynth = FALSE;
				}
			}
		}
    }
	else
	{
        *(BOOL*)pbBuffer = m_fPCSynth;
	}
    return hr;
}

HRESULT CUserModeSynth::HandleXboxSynth(
        ULONG               ulId,
        BOOL                fSet,
        LPVOID              pbBuffer,
        PULONG              pcbBuffer)
{
    if (*pcbBuffer != sizeof(BOOL))
    {
        return E_INVALIDARG;
    }

	HRESULT hr = S_OK;

    if (fSet)
    {
		if (*(BOOL*)pbBuffer && m_fXboxSynth)
		{
			hr = S_FALSE;
		}
		else if (!*(BOOL*)pbBuffer && !m_fXboxSynth)
		{
			hr = S_FALSE;
		}
		else // m_fXboxSynth will change
		{
			// If enabling Xbox Synth
			if( *(BOOL*)pbBuffer )
			{
				// Enable Xbox Synth
				m_fXboxSynth = *(BOOL*)pbBuffer;

				// Activate the synth, if necessary
				if( m_fActive )
				{
					hr = ActivateXboxSynth( TRUE );

					// If activation failed, reset m_fXboxSynth
					if( FAILED(hr) )
					{
						m_fXboxSynth = FALSE;
					}
				}
			}
			// If disabling Xbox Synth
			else
			{
				// Disable Xbox Synth

				// De-activate the synth, if necessary
				if( m_fXboxActive )
				{
					hr = ActivateXboxSynth( FALSE );
				}

				// If de-activation succeeded (or wasn't necessary), set m_fXboxSynth
				if( SUCCEEDED(hr) )
				{
					m_fXboxSynth = FALSE;
				}
			}
		}
    }
	else
	{
        *(BOOL*)pbBuffer = m_fXboxSynth;
	}

    return hr;
}

HRESULT CUserModeSynth::HandleXboxPath(
        ULONG               ulId,
        BOOL                fSet,
        LPVOID              pbBuffer,
        PULONG              pcbBuffer)
{
    if (*pcbBuffer != sizeof(BOOL))
    {
        return E_INVALIDARG;
    }

	HRESULT hr = S_OK;

    if (fSet)
    {
        DWORD *pdwNewPath = (DWORD *) pbBuffer;
        if (*pdwNewPath != m_dwXboxAudioPath)
        {
            ::EnterCriticalSection( &m_XboxCriticalSection );
	        if( m_pdmConnection && m_fXboxActive )
            {
                m_dwXboxAudioPath = *pdwNewPath;
		        char	szCmd[MAX_PATH];
		        char    szResp[MAX_PATH];
		        DWORD   cchResp = MAX_PATH;
		        sprintf(szCmd, TEXT(CMD_PREFIX "!Synth.SetDefaultAudiopath %d"), m_dwXboxAudioPath );
                DmSendCommand(m_pdmConnection, szCmd, szResp, &cchResp);
            }
            ::LeaveCriticalSection( &m_XboxCriticalSection );
        }
    }
	else
	{
        *(DWORD*)pbBuffer = m_dwXboxAudioPath;
	}

    return hr;
}

HRESULT CUserModeSynth::HandleLatency(ULONG ulId, BOOL fSet, LPVOID pbBuffer, PULONG pcbBuffer)
{
    if (*pcbBuffer != sizeof(DWORD))
    {
        return E_INVALIDARG;
    }

    DWORD *pdwLatency = (DWORD *) pbBuffer;

	// If only the Xbox synth is active
    if (m_fXboxSynth && !m_fPCActive)
    {
		// Get or set its latency
        if (fSet)
        {
            m_XboxLatencyClock.SetXboxLatency(*pdwLatency * 10000I64);
        }
        else
        {
			*pdwLatency = DWORD(m_XboxLatencyClock.GetXboxLatency() / 10000I64);
        }
	    return S_OK;
    }

	// Otherwise, fail through to the synth sink
	return DMUS_E_UNKNOWN_PROPERTY;
}

HRESULT CUserModeSynth::HandleGetSampleRate(
        ULONG               ulId,
        BOOL                fSet,
        LPVOID              pbBuffer,
        PULONG              pcbBuffer)
{
    if (*pcbBuffer != sizeof(LONG))
    {
        return E_INVALIDARG;
    }
    if (!fSet)
    {
        *(long*)pbBuffer = m_dwSampleRate;
    }
    return S_OK;
}

HRESULT CUserModeSynth::HandleSetVolume(
        ULONG               ulId,
        BOOL                fSet,
        LPVOID              pbBuffer,
        PULONG              pcbBuffer)
{
    if (*pcbBuffer != sizeof(LONG))
    {
        return E_INVALIDARG;
    }

    m_lVolume =  *(LONG*)pbBuffer;
    m_lGainAdjust = m_lVolume + m_lBoost;

    if (m_pSynth)
    {
        m_pSynth->SetGainAdjust(m_lGainAdjust);
    }
    return S_OK;
}

HRESULT CUserModeSynth::HandleSetBoost(
        ULONG               ulId,
        BOOL                fSet,
        LPVOID              pbBuffer,
        PULONG              pcbBuffer)
{
    if (*pcbBuffer != sizeof(LONG))
    {
        return E_INVALIDARG;
    }

    m_lBoost =  *(LONG*)pbBuffer;
    m_lGainAdjust = m_lVolume + m_lBoost;

    if (m_pSynth)
    {
        m_pSynth->SetGainAdjust(m_lGainAdjust);
    }
    return S_OK;
}

HRESULT CUserModeSynth::HandleReverb(ULONG ulId, BOOL fSet, LPVOID pbBuffer, PULONG pcbBuffer)
{
    DMUS_WAVES_REVERB_PARAMS *pParams;
    if (*pcbBuffer != sizeof(DMUS_WAVES_REVERB_PARAMS))
    {
        return E_INVALIDARG;
    }

    pParams = (DMUS_WAVES_REVERB_PARAMS *) pbBuffer;
    if (m_pSynth)
    {
        if (fSet)
        {
            m_pSynth->SetReverb(pParams);
        }
        else
        {
            m_pSynth->GetReverb(pParams);
        }
    }

    return S_OK;
}

HRESULT CUserModeSynth::HandleEffects(
    ULONG               ulId,
    BOOL                fSet,
    LPVOID              pbBuffer,
    PULONG              pcbBuffer)
{
    if (*pcbBuffer != sizeof(LONG))
    {
        return E_INVALIDARG;
    }
    if (fSet)
    {
        long lEffects = *(long*)pbBuffer;

        if (m_pSynth)
        {
            m_pSynth->SetReverbActive(lEffects & DMUS_EFFECT_REVERB);
        }
    }
    else
    {
        if (m_pSynth && m_pSynth->IsReverbActive())
        {
            *(long*)pbBuffer = DMUS_EFFECT_REVERB;
        }
        else
        {
            *(long*)pbBuffer = 0;
        }
    }
    return S_OK;
}

//
// CDirectMusicEmulatePort::FindPropertyItem
//
// Given a GUID and an item ID, find the associated property item in the synth's
// table of SYNPROPERTY's.
//
// Returns a pointer to the entry or NULL if the item was not found.
//
GENERICPROPERTY *CUserModeSynth::FindPropertyItem(REFGUID rguid, ULONG ulId)
{
    GENERICPROPERTY *pPropertyItem = &m_aProperty[0];
    GENERICPROPERTY *pEndOfItems = pPropertyItem + m_nProperty;

    // Special Case -- We don't support Waves Reverb on a SinthSink8
    if ((rguid == GUID_DMUS_PROP_WavesReverb) && (this->m_pSynthSink8 != NULL))
        return NULL;

    for (; pPropertyItem != pEndOfItems; pPropertyItem++)
    {
        if (*pPropertyItem->pguidPropertySet == rguid &&
             pPropertyItem->ulId == ulId)
        {
            return pPropertyItem;
        }
    }



    return NULL;
}

#define KS_VALID_FLAGS (KSPROPERTY_TYPE_SET | KSPROPERTY_TYPE_GET| KSPROPERTY_TYPE_BASICSUPPORT)

STDMETHODIMP CUserModeSynth::KsProperty(
    PKSPROPERTY pPropertyIn, ULONG ulPropertyLength,
    LPVOID pvPropertyData, ULONG ulDataLength,
    PULONG pulBytesReturned)
{
    V_INAME(DirectMusicSynthPort::IKsContol::KsProperty);
    V_BUFPTR_WRITE(pPropertyIn, ulPropertyLength);

    DWORD dwFlags = pPropertyIn->Flags & KS_VALID_FLAGS;

    switch (dwFlags)
    {
        case KSPROPERTY_TYPE_GET:
            V_BUFPTR_WRITE_OPT(pvPropertyData, ulDataLength);
            break;

        case KSPROPERTY_TYPE_SET:
            V_BUFPTR_READ(pvPropertyData, ulDataLength);
            break;

        case KSPROPERTY_TYPE_BASICSUPPORT:
            V_BUFPTR_WRITE(pvPropertyData, ulDataLength);
            break;
    }


    V_PTR_WRITE(pulBytesReturned, ULONG);

    GENERICPROPERTY *pProperty = FindPropertyItem(pPropertyIn->Set, pPropertyIn->Id);

    if (pProperty == NULL)
    {
        Trace(2, "Warning: KsProperty call requested unknown property.\n");
        return DMUS_E_UNKNOWN_PROPERTY;
    }

    switch (dwFlags)
    {
        case KSPROPERTY_TYPE_GET:
            if (!(pProperty->ulSupported & KSPROPERTY_SUPPORT_GET))
            {
                Trace(1, "Error: SynthSink does not support Get for the requested property.\n");
                return DMUS_E_GET_UNSUPPORTED;
            }

            if (pProperty->ulFlags & GENPROP_F_FNHANDLER)
            {
                GENPROPHANDLER pfn = pProperty->pfnHandler;
                *pulBytesReturned = ulDataLength;
                return (this->*pfn)(pPropertyIn->Id, FALSE, pvPropertyData, pulBytesReturned);
            }

            if (ulDataLength > pProperty->cbPropertyData)
            {
                ulDataLength = pProperty->cbPropertyData;
            }

            if (pvPropertyData != NULL)
            {
                CopyMemory(pvPropertyData, pProperty->pPropertyData, ulDataLength);
            }
            *pulBytesReturned = ulDataLength;

            return S_OK;

        case KSPROPERTY_TYPE_SET:
            if (!(pProperty->ulSupported & KSPROPERTY_SUPPORT_SET))
            {
                Trace(1, "Error: SynthSink does not support Set for the requested property.\n");
                return DMUS_E_SET_UNSUPPORTED;
            }

            if (pProperty->ulFlags & GENPROP_F_FNHANDLER)
            {
                GENPROPHANDLER pfn = pProperty->pfnHandler;
                return (this->*pfn)(pPropertyIn->Id, TRUE, pvPropertyData, &ulDataLength);
            }

            if (ulDataLength > pProperty->cbPropertyData)
            {
                ulDataLength = pProperty->cbPropertyData;
            }

            CopyMemory(pProperty->pPropertyData, pvPropertyData, ulDataLength);

            return S_OK;


        case KSPROPERTY_TYPE_BASICSUPPORT:
            if (pProperty == NULL)
            {
                Trace(1, "Error: Synth does not provide support for requested property type.\n");
                return DMUS_E_UNKNOWN_PROPERTY;
            }

            // XXX Find out what convention is for this!!
            //
            if (ulDataLength < sizeof(DWORD))
            {
                Trace(1, "Error: Data size for property is too small.\n");
                return E_INVALIDARG;
            }

            *(LPDWORD)pvPropertyData = pProperty->ulSupported;
            *pulBytesReturned = sizeof(DWORD);

            return S_OK;
    }

    Trace(1, "Error: KSProperty Flags must contain one of: %s\n"
              "\tKSPROPERTY_TYPE_SET, KSPROPERTY_TYPE_GET, or KSPROPERTY_TYPE_BASICSUPPORT\n");
    return E_INVALIDARG;
}

STDMETHODIMP CUserModeSynth::KsMethod(
    PKSMETHOD pMethod, ULONG ulMethodLength,
    LPVOID pvMethodData, ULONG ulDataLength,
    PULONG pulBytesReturned)
{
    V_INAME(DirectMusicSynth::IKsContol::KsMethod);
    V_BUFPTR_WRITE(pMethod, ulMethodLength);
    V_BUFPTR_WRITE_OPT(pvMethodData, ulDataLength);
    V_PTR_WRITE(pulBytesReturned, ULONG);

    return DMUS_E_UNKNOWN_PROPERTY;
}
STDMETHODIMP CUserModeSynth::KsEvent(
    PKSEVENT pEvent, ULONG ulEventLength,
    LPVOID pvEventData, ULONG ulDataLength,
    PULONG pulBytesReturned)
{
    V_INAME(DirectMusicSynthPort::IKsContol::KsEvent);
    V_BUFPTR_WRITE(pEvent, ulEventLength);
    V_BUFPTR_WRITE_OPT(pvEventData, ulDataLength);
    V_PTR_WRITE(pulBytesReturned, ULONG);

    return DMUS_E_UNKNOWN_PROPERTY;
}

/////////////////////////////////////////////////////////////////////
// Implementation of IDirectMusicSynth8

#ifdef IMPLEMENT_SYNTH8
STDMETHODIMP CUserModeSynth::PlayVoice(REFERENCE_TIME rt, DWORD dwVoiceId, DWORD dwChannelGroup, DWORD dwChannel, DWORD dwDLId, PREL prPitch, VREL vrVolume, SAMPLE_TIME stVoiceStart, SAMPLE_TIME stLoopStart, SAMPLE_TIME stLoopEnd )
{
    HRESULT hr = DMUS_E_SYNTHNOTCONFIGURED;

    ::EnterCriticalSection(&m_CriticalSection);
    if (m_pSynth)
    {
        hr = m_pSynth->PlayVoice(m_pSynthSink8,
                                 rt,
                                 dwVoiceId,
                                 dwChannelGroup,
                                 dwChannel,
                                 dwDLId,
                                 vrVolume,
                                 prPitch,
                                 stVoiceStart,
                                 stLoopStart,
                                 stLoopEnd);
    }
    else
    {
        Trace(1, "Error: Failed wave playback, synth is not properly configured.\n");
    }
    ::LeaveCriticalSection(&m_CriticalSection);

    return hr;
}

STDMETHODIMP CUserModeSynth::StopVoice(REFERENCE_TIME rt, DWORD dwVoiceId )
{
    HRESULT hr = DMUS_E_SYNTHNOTCONFIGURED;

    ::EnterCriticalSection(&m_CriticalSection);
    if (m_pSynth)
    {
        hr = m_pSynth->StopVoice(m_pSynthSink8,
                                 rt,
                                 dwVoiceId);
    }
    else
    {
        Trace(1, "Error: Failed stop of wave playback, synth is not properly configured.\n");
    }
    ::LeaveCriticalSection(&m_CriticalSection);

    return hr;
}

STDMETHODIMP CUserModeSynth::GetVoiceState(DWORD dwVoice[], DWORD cbVoice, DMUS_VOICE_STATE VoiceState[] )
{
    V_INAME(IDirectMusicSynth::GetVoiceState);
    V_PTR_READ(dwVoice, sizeof(DWORD)*cbVoice);

    HRESULT hr = DMUS_E_SYNTHNOTCONFIGURED;

    ::EnterCriticalSection(&m_CriticalSection);
    if (m_pSynth)
    {

        hr = m_pSynth->GetVoiceState(dwVoice,
                                     cbVoice,
                                     VoiceState);

    }
    ::LeaveCriticalSection(&m_CriticalSection);

    return hr;
}

STDMETHODIMP CUserModeSynth::Refresh(DWORD dwDownloadID, DWORD dwFlags )
{
    HRESULT hr = DMUS_E_SYNTHNOTCONFIGURED;

    ::EnterCriticalSection(&m_CriticalSection);
    if (m_pSynth)
    {
        hr = m_pSynth->Refresh(dwDownloadID,
                               dwFlags);
    }
    ::LeaveCriticalSection(&m_CriticalSection);

    return hr;
}

STDMETHODIMP CUserModeSynth::AssignChannelToBuses(DWORD dwChannelGroup, DWORD dwChannel, LPDWORD pdwBuses, DWORD cBuses )
{
    HRESULT hr = DMUS_E_SYNTHNOTCONFIGURED;

    ::EnterCriticalSection(&m_CriticalSection);
    if (m_pSynth)
    {
    hr = m_pSynth->AssignChannelToBuses(dwChannelGroup,
                                         dwChannel,
                                         pdwBuses,
                                         cBuses);
    }
    else
    {
        Trace(1, "Error: Failed synth channel assignment, synth is not properly configured.\n");
    }
    ::LeaveCriticalSection(&m_CriticalSection);

    return hr;
}
#endif

/////////////////////////////////////////////////////////////////////
// Implementation of IDirectSoundSource

STDMETHODIMP CUserModeSynth::SetSink(IDirectSoundConnect* pSinkConnect)
{
    V_INAME(IDirectSoundSink::SetSink);
    V_INTERFACE_OPT(pSinkConnect);

    HRESULT hr = S_OK;

    LPVOID ptr = NULL;
    V_BUFPTR_WRITE_OPT(ptr, 0);

    ::EnterCriticalSection(&m_CriticalSection);

//>>>>>>>> RELEASE THE DSLINK IF PRESENT !!!!

// FIXME: The calls into the SynthSink8 may require the DSound DLL Mutex.  If the Sink
// is making a a call to READ then we end up in a deadlock.  We need to be sure that the
// Synth isn't playing when we do this.

    if (m_pSynthSink8)
    {
        // FIXME: whoever called us->SetSink() should previously have called
        // pOldSink->RemoveSource(us) - it shouldn't be our responsibility to
        // do this call (??):
        // m_pSynthSink8->RemoveSource(this);
        m_pSynthSink8->Release();
        m_pSynthSink8 = NULL;
    }

    if (pSinkConnect)
    {
        // Obtain the IDirectSoundSynthSink interface on the sink
        hr = pSinkConnect->QueryInterface(IID_IDirectSoundSynthSink, (void**)&m_pSynthSink8);

        if (SUCCEEDED(hr))
        {
            //
            // Get the sink's format and validate it
            //
            WAVEFORMATEX wfx;
            DWORD dwSize = sizeof wfx;
            hr = m_pSynthSink8->GetFormat(&wfx, dwSize, NULL);
            if (SUCCEEDED(hr) && wfx.wBitsPerSample != 16 )
            {
                Trace(1, "Error; Synth can not write to any format other than 16 bit PCM.\n");
                hr = DMUS_E_WAVEFORMATNOTSUPPORTED;
            }

            if (SUCCEEDED(hr))
            {
                // Flag the buffer format to be non-interleaved
                m_dwChannels = 1;    // This synth with a sink is concidered a mono source.
                m_dwBufferFlags = BUFFERFLAG_MULTIBUFFER;

                if (m_pSynth)
                {
                    m_pSynth->SetStereoMode(m_dwBufferFlags);

                    // reset sample rate if it has changed
                    if (wfx.nSamplesPerSec != (WORD)m_dwSampleRate)
                    {
                        m_pSynth->SetSampleRate(wfx.nSamplesPerSec);
                    }

                    // disable DX7 Reverb
                    m_pSynth->SetReverbActive(FALSE);
                }
            }
        }
    }

    ::LeaveCriticalSection(&m_CriticalSection);

    return hr;
}

STDMETHODIMP CUserModeSynth::Seek(ULONGLONG sp)
{
    m_ullPosition = sp/2;    // Convert from bytes to samples

    return S_OK;
}

STDMETHODIMP CUserModeSynth::Read(LPVOID *ppvBuffer, LPDWORD pdwIDs, LPDWORD pdwFuncIDs, LPLONG plPitchBends, DWORD dwBufferCount, PULONGLONG pullLength )
{
    V_INAME(IDirectMusicSynth::Read);
    V_PTR_READ(ppvBuffer, sizeof(LPVOID)*dwBufferCount);
    V_PTR_READ(pdwIDs, sizeof(LPDWORD)*dwBufferCount);

    for ( DWORD i = 0; i < dwBufferCount; i++ )
    {
        V_BUFPTR_WRITE(ppvBuffer[i], (DWORD)*pullLength);
        if ( ppvBuffer[i] == NULL )
        {
            Trace(1, "Error: Read called with NULL buffer.\n");
            return E_INVALIDARG;
        }
    }

    if ( *pullLength > 0x00000000FFFFFFFF )    // can't read more than a DWORD's worth of data
    {
        Trace(1, "Error: Read called with invalid buffer length.\n");
        return E_INVALIDARG;
    }

    if ( dwBufferCount == 0 )                // don't read no buffers
    {
        Trace(4, "Warning: Read called with 0 buffers.\n");
        return E_INVALIDARG;
    }
    if (!m_pSynthSink8)
    {
        Trace(1, "Error: Synth is not configured, can not play.\n");
        return DMUS_E_SYNTHNOTCONFIGURED;
    }
    if (!m_fPCActive)
    {
        Trace(3, "Warning: Synth is not active, can not play.\n");
        return DMUS_E_SYNTHINACTIVE;
    }

    ::EnterCriticalSection(&m_CriticalSection);

    if (m_pSynth)
    {
        // Mix
        DWORD dwLength = (DWORD)(*pullLength)/2;    // Convert from bytes to number of samples. Synth assumes 16 bit
        m_pSynth->Mix((short**)ppvBuffer, pdwIDs, pdwFuncIDs, plPitchBends, dwBufferCount, m_dwBufferFlags, dwLength, m_ullPosition);

        // Increment current sample position in the audio stream
        m_ullPosition += dwLength;
    }

    ::LeaveCriticalSection(&m_CriticalSection);

    return S_OK;
}

STDMETHODIMP CUserModeSynth::GetSize(PULONGLONG pcb)
{
    return E_NOTIMPL;
}



/////////////////////////////////////////////////////////////////////////////
// CXboxLatencyClock

CXboxLatencyClock::CXboxLatencyClock()
{
	m_cRef = 1;
	m_pSinkLatencyClock = NULL;
	m_pMasterClock = NULL;
	m_rtXboxLatency = 0;
}

CXboxLatencyClock::~CXboxLatencyClock()
{
	if( m_pSinkLatencyClock )
	{
		m_pSinkLatencyClock->Release();
		m_pSinkLatencyClock = NULL;
	}
	if( m_pMasterClock )
	{
		m_pMasterClock->Release();
		m_pMasterClock = NULL;
	}
}

// CXboxLatencyClock::QueryInterface
//
STDMETHODIMP
CXboxLatencyClock::QueryInterface(const IID &iid, void **ppv)
{
    V_INAME(IReferenceClock::QueryInterface);
    V_REFGUID(iid);
    V_PTRPTR_WRITE(ppv);

    if (iid == IID_IUnknown || iid == IID_IReferenceClock) {
        *ppv = static_cast<IReferenceClock*>(this);
    }
    else
    {
        *ppv = NULL;
        return E_NOINTERFACE;
    }

    reinterpret_cast<IUnknown*>(this)->AddRef();
    return S_OK;
}

// CXboxLatencyClock::AddRef
//
STDMETHODIMP_(ULONG)
CXboxLatencyClock::AddRef()
{
    return InterlockedIncrement(&m_cRef);
}

// CXboxLatencyClock::Release
//
STDMETHODIMP_(ULONG)
CXboxLatencyClock::Release()
{
    if (!InterlockedDecrement(&m_cRef)) {
        delete this;
        return 0;
    }

    return m_cRef;
}

// CXboxLatencyClock::GetTime
//
STDMETHODIMP
CXboxLatencyClock::GetTime(REFERENCE_TIME *pTime)
{
	if( m_pSinkLatencyClock )
	{
		return m_pSinkLatencyClock->GetTime(pTime);
	}
	else if( m_pMasterClock )
	{
		HRESULT hr = m_pMasterClock->GetTime(pTime);
		if( SUCCEEDED(hr) )
		{
			*pTime += m_rtXboxLatency;
		}
		return hr;
	}
	return E_NOTIMPL;
}

// CXboxLatencyClock::AdviseTime
//
STDMETHODIMP
CXboxLatencyClock::AdviseTime(REFERENCE_TIME baseTime, REFERENCE_TIME streamTime, HANDLE hEvent, DWORD *pdwAdviseCookie)
{
	if( m_pSinkLatencyClock )
	{
		return m_pSinkLatencyClock->AdviseTime(baseTime, streamTime, hEvent, pdwAdviseCookie);
	}
	return E_NOTIMPL;
}

// CXboxLatencyClock::AdvisePeriodic
//
STDMETHODIMP
CXboxLatencyClock::AdvisePeriodic(REFERENCE_TIME startTime, REFERENCE_TIME periodTime, HANDLE hSemaphore, DWORD *pdwAdviseCookie)
{
	if( m_pSinkLatencyClock )
	{
		return m_pSinkLatencyClock->AdvisePeriodic(startTime, periodTime, hSemaphore, pdwAdviseCookie);
	}
	return E_NOTIMPL;
}

// CXboxLatencyClock::Unadvise
//
STDMETHODIMP
CXboxLatencyClock::Unadvise(DWORD dwAdviseCookie)
{
	if( m_pSinkLatencyClock )
	{
		return m_pSinkLatencyClock->Unadvise(dwAdviseCookie);
	}
	return E_NOTIMPL;
}

// CXboxLatencyClock::SetXboxLatency
//
void CXboxLatencyClock::SetXboxLatency( REFERENCE_TIME rtLatency )
{
	m_rtXboxLatency = rtLatency;
}

// CXboxLatencyClock::SetSinkLatencyClock
//
void CXboxLatencyClock::SetSinkLatencyClock( IReferenceClock *pIReferenceClock )
{
	if( m_pSinkLatencyClock )
	{
		m_pSinkLatencyClock->Release();
		m_pSinkLatencyClock = NULL;
	}

	m_pSinkLatencyClock = pIReferenceClock;
	if( m_pSinkLatencyClock )
	{
		m_pSinkLatencyClock->AddRef();
	}
}

// CXboxLatencyClock::SetMasterClock
//
void CXboxLatencyClock::SetMasterClock( IReferenceClock *pIReferenceClock )
{
	if( m_pMasterClock )
	{
		m_pMasterClock->Release();
		m_pMasterClock = NULL;
	}

	m_pMasterClock = pIReferenceClock;
	if( m_pMasterClock )
	{
		m_pMasterClock->AddRef();
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\XboxSynth\voice.cpp ===
//
// Voice.cpp
// Copyright (c) 1996-2001 Microsoft Corporation
//

#ifdef DMSYNTH_MINIPORT
#include "common.h"
#include <math.h>
#include "muldiv32.h"
#else
#include "debug.h"
#include "simple.h"
#include <mmsystem.h>
#include <dmusicc.h>
#include <dmusics.h>
#include "synth.h"
#include <math.h>
#include <stdio.h>
#include "csynth.h"
#endif

#include "fparms.h" // Generated filter parameter arrays

#ifdef _X86_
#define MMX_ENABLED 1
#endif

#ifdef DBG
extern DWORD sdwDebugLevel;
#endif

CVoiceLFO::CVoiceLFO()
{
    m_pModWheelIn = NULL;
    m_pPressureIn = NULL;
    m_bEnable = TRUE;
}

short CVoiceLFO::m_snSineTable[256];

void CVoiceLFO::Init()
{
    double flTemp;
    long lIndex;

    for (lIndex = 0;lIndex < 256;lIndex++)
    {
        flTemp = lIndex;
        flTemp *= 6.283185307;
        flTemp /= 256.0;
        flTemp = sin(flTemp);
        flTemp *= 100.0;
        m_snSineTable[lIndex] = (short) flTemp;
    }
}


STIME CVoiceLFO::StartVoice(CSourceLFO *pSource,
                    STIME stStartTime, CModWheelIn * pModWheelIn, CPressureIn * pPressureIn)
{
    m_bEnable = TRUE;

    m_pModWheelIn = pModWheelIn;
    m_pPressureIn = pPressureIn;
    m_Source = *pSource;
    m_stStartTime = stStartTime;
    if ((m_Source.m_prMWPitchScale == 0) && (m_Source.m_vrMWVolumeScale == 0) &&
        (m_Source.m_prPitchScale == 0) && (m_Source.m_vrVolumeScale == 0))
    {
        m_stRepeatTime = 44100;
    }
    else
    {
        m_stRepeatTime = 2097152 / m_Source.m_pfFrequency; // (1/8 * 256 * 4096 * 16)
    }
    return (m_stRepeatTime);
}

long CVoiceLFO::GetLevel(STIME stTime, STIME *pstNextTime)
{
    if ( !m_bEnable )
        return 0;

    stTime -= (m_stStartTime + m_Source.m_stDelay);
    if (stTime < 0)
    {
        *pstNextTime = -stTime;
        return (0);
    }
    *pstNextTime = m_stRepeatTime;
    stTime *= m_Source.m_pfFrequency;
    stTime = stTime >> (12 + 4); // We've added 4 extra bits of resolution...
    return (m_snSineTable[stTime & 0xFF]);
}

VREL CVoiceLFO::GetVolume(STIME stTime, STIME *pstNextTime)
{
    VREL vrVolume;
    VREL vrCPVolume;
    VREL vrMWVolume;

    if ( !m_bEnable )
        return 0;

    vrCPVolume = m_pPressureIn->GetPressure(stTime);
    vrCPVolume *= m_Source.m_vrCPVolumeScale;
    vrCPVolume /= 127;

    vrMWVolume = m_pModWheelIn->GetModulation(stTime);
    vrMWVolume *= m_Source.m_vrMWVolumeScale;
    vrMWVolume /= 127;

    vrVolume  = vrMWVolume;
    vrVolume += vrCPVolume;
    vrVolume += m_Source.m_vrVolumeScale;
    vrVolume *= GetLevel(stTime, pstNextTime);
    vrVolume /= 100;
    return (vrVolume);
}

PREL CVoiceLFO::GetPitch(STIME stTime, STIME *pstNextTime)
{
    PREL prPitch;
    PREL prCPPitch;
    PREL prMWPitch;

    if ( !m_bEnable )
        return 0;

    prCPPitch = m_pPressureIn->GetPressure(stTime);
    prCPPitch *= m_Source.m_prCPPitchScale;
    prCPPitch /= 127;

    prMWPitch = m_pModWheelIn->GetModulation(stTime);
    prMWPitch *= m_Source.m_prMWPitchScale;
    prMWPitch /= 127;

    prPitch  = prMWPitch;
    prPitch += prCPPitch;
    prPitch += m_Source.m_prPitchScale;
    prPitch *= GetLevel(stTime, pstNextTime);
    prPitch /= 100;

    return (prPitch);
}

PREL CVoiceLFO::GetCutoff(STIME stTime)
{
    PREL prPitch;
    PREL prCPPitch;
    PREL prMWPitch;
    STIME stNextTime;

    if ( !m_bEnable )
        return 0;

    prCPPitch = m_pPressureIn->GetPressure(stTime);
    prCPPitch *= m_Source.m_prCPCutoffScale;
    prCPPitch /= 127;

    prMWPitch = m_pModWheelIn->GetModulation(stTime);
    prMWPitch *= m_Source.m_prMWCutoffScale;
    prMWPitch /= 127;

    prPitch  = prMWPitch;
    prPitch += prCPPitch;
    prPitch += m_Source.m_prCutoffScale;
    prPitch *= GetLevel(stTime, &stNextTime);
    prPitch /= 100;

    return (prPitch);
}

CVoiceEG::CVoiceEG()
{
    m_stStopTime = 0;
    m_bEnable = TRUE;
}

short CVoiceEG::m_snAttackTable[201];

void CVoiceEG::Init()
{
    double flTemp;
    long lV;

    m_snAttackTable[0] = 0;
    for (lV = 1;lV <= 200; lV++)
    {
        flTemp = lV;
        flTemp /= 200.0;
        flTemp *= flTemp;
        flTemp = log10(flTemp);
        flTemp *= 10000.0;
        flTemp /= 96.0;
        flTemp += 1000.0;
        m_snAttackTable[lV] = (short) flTemp;
    }
}

void CVoiceEG::StopVoice(STIME stTime)
{
    if ( m_bEnable )
    {
        m_Source.m_stRelease *= GetLevel(stTime, &m_stStopTime, TRUE);    // Adjust for current sustain level.
        m_Source.m_stRelease /= 1000;
    }
    m_stStopTime = stTime;
}

void CVoiceEG::QuickStopVoice(STIME stTime, DWORD dwSampleRate)

{
    if ( m_bEnable )
    {
        m_Source.m_stRelease *= GetLevel(stTime, &m_stStopTime, TRUE);    // Adjust for current sustain level.
        m_Source.m_stRelease /= 1000;
        dwSampleRate /= 70;
        if (m_Source.m_stRelease > (long) dwSampleRate)
        {
            m_Source.m_stRelease = dwSampleRate;
        }
    }
    m_stStopTime = stTime;
}

STIME CVoiceEG::StartVoice(CSourceEG *pSource, STIME stStartTime,
                    WORD nKey, WORD nVelocity, STIME stMinAttack)
{
    m_bEnable = TRUE;

    m_stStartTime = stStartTime;
    m_stStopTime = 0x7fffffffffffffff;      // set to indefinite future
    m_Source = *pSource;
    if (m_Source.m_stAttack < stMinAttack)
    {
        m_Source.m_stAttack = stMinAttack;
    }
    if (m_Source.m_stRelease < stMinAttack)
    {
        m_Source.m_stRelease = stMinAttack;
    }

    // apply velocity to attack length scaling here
    m_Source.m_stAttack *= CDigitalAudio::PRELToPFRACT(nVelocity * m_Source.m_trVelAttackScale / 127);
    m_Source.m_stAttack /= 4096;

    m_Source.m_stHold  *= CDigitalAudio::PRELToPFRACT(nKey * m_Source.m_trKeyDecayScale / 127);
    m_Source.m_stHold  /= 4096;

    m_Source.m_stDecay *= CDigitalAudio::PRELToPFRACT(nKey * m_Source.m_trKeyDecayScale / 127);
    m_Source.m_stDecay /= 4096;

    m_Source.m_stDecay *= (1000 - m_Source.m_pcSustain);
    m_Source.m_stDecay /= 1000;

    if ( m_Source.m_stDelay )
        return ((STIME)m_Source.m_stDelay);
    else
        return ((STIME)m_Source.m_stAttack);
}

//note: appears to not be in use
BOOL CVoiceEG::InAttack(STIME st)
{
    if ( !m_bEnable )
        return FALSE;

    // has note been released?
    if (st >= m_stStopTime)
        return FALSE;

    // past length of attack?
    if (st >= m_stStartTime + m_Source.m_stDelay + m_Source.m_stAttack)
        return FALSE;

    return TRUE;
}

BOOL CVoiceEG::InRelease(STIME st)
{
    if ( !m_bEnable )
        return FALSE;

    // has note been released?
    if (st > m_stStopTime)
        return TRUE;

    return FALSE;
}

long CVoiceEG::GetLevel(STIME stEnd, STIME *pstNext, BOOL fVolume)
{
    long lLevel = 0;

    if (stEnd <= m_stStopTime)
    {
        stEnd -= m_stStartTime;
        if (stEnd < m_Source.m_stDelay )
        {
            lLevel = 0;
            *pstNext = m_Source.m_stDelay - stEnd;
        }
        else
        {
            stEnd -= m_Source.m_stDelay;
            if (stEnd < m_Source.m_stAttack )
            {
                // still in attack
                lLevel = 1000 * (long) stEnd;
                if (m_Source.m_stAttack)
                {
                    lLevel /= (long) m_Source.m_stAttack;
                }
                else // This should never happen, but it does...
                {
                    lLevel = 0;
                }
                *pstNext = m_Source.m_stAttack - stEnd;
                if (lLevel < 0) lLevel = 0;
                if (lLevel > 1000) lLevel = 1000;
                if (fVolume)
                {
                    lLevel = m_snAttackTable[lLevel / 5];
                }
            }
            else
            {
                stEnd -= m_Source.m_stAttack;
                if ( stEnd < m_Source.m_stHold )
                {
                    lLevel = 1000;
                    *pstNext = m_Source.m_stHold - stEnd;
                    if (fVolume)
                    {
                        lLevel = m_snAttackTable[lLevel / 5];
                    }
                }
                else
                {
                    stEnd -= m_Source.m_stHold;
                    if (stEnd < m_Source.m_stDecay)
                    {
                        // still in decay
                        lLevel = (1000 - m_Source.m_pcSustain) * (long) stEnd;
                        lLevel /= (long) m_Source.m_stDecay;
                        lLevel = 1000 - lLevel;
                        // To improve the decay curve, set the next point to be 1/4, 1/2, or end of slope.
                        // To avoid close duplicates, fudge an extra 100 samples.
                        if (stEnd < ((m_Source.m_stDecay >> 2) - 100))
                        {
                            *pstNext = (m_Source.m_stDecay >> 2) - stEnd;
                        }
                        else if (stEnd < ((m_Source.m_stDecay >> 1) - 100))
                        {
                            *pstNext = (m_Source.m_stDecay >> 1) - stEnd;
                        }
                        else
                        {
                            *pstNext = m_Source.m_stDecay - stEnd;  // Next is end of decay.
                        }
                    }
                    else
                    {
                        // in sustain
                        lLevel = m_Source.m_pcSustain;
                        *pstNext = 44100;
                    }
                }
            }
        }
    }
    else
    {
        STIME stBogus;
        // in release
        stEnd -= m_stStopTime;

        if (stEnd < m_Source.m_stRelease)
        {
            lLevel = GetLevel(m_stStopTime, &stBogus, fVolume) * (long) (m_Source.m_stRelease - stEnd);
            lLevel /= (long) m_Source.m_stRelease;
            if (stEnd < ((m_Source.m_stRelease >> 2) - 100))
            {
                *pstNext = (m_Source.m_stRelease >> 2) - stEnd;
            }
            else if (stEnd < ((m_Source.m_stRelease >> 1) - 100))
            {
                *pstNext = (m_Source.m_stRelease >> 1) - stEnd;
            }
            else
            {
                *pstNext = m_Source.m_stRelease - stEnd;  // Next is end of decay.
            }
        }
        else
        {
            lLevel = 0;   // !!! off
            *pstNext = 0x7FFFFFFFFFFFFFFF;
        }
    }

    return lLevel;
}

VREL CVoiceEG::GetVolume(STIME stTime, STIME *pstNextTime)
{
    if ( !m_bEnable )
        return 0;

    VREL vrLevel = GetLevel(stTime, pstNextTime, TRUE) * 96;
    vrLevel /= 10;
    vrLevel = vrLevel - 9600;
    return vrLevel;
}

PREL CVoiceEG::GetPitch(STIME stTime, STIME *pstNextTime)
{
    if ( !m_bEnable )
        return 0;

    PREL prLevel;
    if (m_Source.m_sScale != 0)
    {
        prLevel = GetLevel(stTime, pstNextTime, FALSE);
        prLevel *= m_Source.m_sScale;
        prLevel /= 1000;
    }
    else
    {
        *pstNextTime = 44100;
        prLevel = 0;
    }
    return prLevel;
}

PREL CVoiceEG::GetCutoff(STIME stTime)
{
    if ( !m_bEnable )
        return 0;

    PREL prLevel;
    STIME pstNextTime;  // not used
    if (m_Source.m_prCutoffScale != 0)
    {
        prLevel = GetLevel(stTime, &pstNextTime, FALSE);
        prLevel *= m_Source.m_prCutoffScale;
        prLevel /= 1000;
    }
    else
    {
        prLevel = 0;
    }
    return prLevel;
}

void CVoiceFilter::StartVoice(CSourceFilter *pSource, CVoiceLFO *pLFO, CVoiceEG *pEG, WORD nKey, WORD nVelocity)
{
    m_Source = *pSource;
    m_pLFO = pLFO;
    m_pEG  = pEG;
    m_prVelScale = (nVelocity * m_Source.m_prVelScale) / 127;
    m_prKeyScale = (nKey * m_Source.m_prKeyScale) / 127;
}


/////////////////////////////////////////////////////////////////////////////////
// DLS2 Lowpass Filter Filter
/*

>>>>> finish low pass filter comment

        b1 = -2.0 * r * cos(theta);
        b2 = r * r;
        K  = (1.0 + b1 + b2) * pow(10.0, -qIndex * 0.0375);

  The Filter :

        z  = (K * sample[i]) - (b1 * z1) - (b2 * z2)
        z2 = z1
        z1 = z

>>> B1 negation turned to positive then used as an add instead of subtraction.

  Resonance : Q
    GainUnits

        -qIndex * 0.0375

        0.0375 = 1.5/40 in db's

    Values
        Q min/max Values are 0db to 22.5db
        Q min/max Values are 0   to 225 in 1/10th db's


  Cutoff Fequency : Fc
    Pitch absolute values

        Absolute Pitch = ((1200 * log2(F/440)) + 6900)

    Values
        Initial Fc min/max Values are 200Hz to 7998Hz
        Initial Fc min/max Values are 5535  to 11921 in abosolute pitch cents


  Table Indexs

        65 - entries in the table

                                Hertz   Pitch
        --------------------------------------
        Max Sample Rate     -> 48000Hz (15023) ---|
                               44100Hz (14877)    |
                               22050Hz (13676)    |
                               .......          9488
        Max Cutoff Freq     -> 7999Hz  (11921)    |
                               .......            |
        Min Cutoff Freq     ->  200Hz  (5535)  ---|


        More Acurately .....

        48KHz       15023.26448623030034519401770744100
        200Hz     -  5534.99577150007811000514765931632
                  =====================================
        Feq Range    9488.26871473022223518887004812496

        Feq Range/1200 =  7.906890596 is the Feq Range in octaves
        Feq Range/100  = 94.882687147 is the Feq Range in setimtones


      Behavoir of Fc to indexes according to ouput Sample Rate

        SampleRate of 48k (15023)
            Fc < 5535  (200Hz)   -> fIndex = 0
            Fc = 11921 (7999Hz)  -> fIndex = 63.86
            Fc > 11935 (8064Hz)  -> fIndex = 64

        SampleRate of 41k (14877)
            Fc = 5535  (200Hz)   -> fIndex = 0
            Fc < 5389  (200Hz)   -> fIndex = 0
            Fc > 11789 (7411Hz)  -> fIndex = 64
            Fc = 11921 (7999Hz)  -> fIndex = 65.32

        SampleRate of 22k (13676)
            Fc < 4188  (92Hz)    -> fIndex = 0
            Fc = 5535  (200Hz)   -> fIndex = 13.44
                 10574 (3675Hz)  -> spec min of 1/6th the sample rate
            Fc > 10588 (3704Hz)  -> fIndex = 64
                 11276 (5510Hz)  -> filter fails one octave bellow Nyquist
            Fc = 11921 (7999Hz)  -> fIndex = 77.33
                 12476 (11025Hz) -> nyquist

  Precision

        0.01 - minimal acuracy for interpolation

        9488.2687
        0.00025 +/- error

        m_aB1[0][63] =    0x33ea24fb  = 0.811166044148771133412393865559
        m_aB1[0][64] =  - 0x2fa8ebf5  = 0.744685163483661751713288716704
                        ============
                          0x04413906  = 0.066480880665109381699105148854

        fIndex's fractional constant  = 0.002687147302222351888700481249

        interpolation of
        m_aB1[0][63] + constant       = 0.810987400229642518622447868604

        difference                    = 0.000178643919128614789945996955

        One 2.30 fixpoint bit         = 0.000000000931322575482840254421

        9488.2687147
        7.906890596 * 1200 = 9488.2687152 <-- precision error

        1-bit lossed when going to intger math
*/
//
void CVoiceFilter::GetCoeff(STIME stTime, PREL prFreqIn, COEFF& cfK, COEFF& cfB1, COEFF& cfB2)
{
    PREL prCutoff;
    DWORD dwFract;
    int iQIndex;
    int iIndex;

    //
    // Check if filter is disabled
    //
    if (m_Source.m_prCutoff == 0x7FFF)
    {
        cfK  = 0x40000000;  // is unity in 2.30 fixpoint
        cfB1 = 0;
        cfB2 = 0;
        return;
    }

    //
    // Accumulate the current Cutoff Frequency
    //
    prCutoff  = m_Source.m_prCutoffSRAdjust;
    prCutoff += m_pLFO->GetCutoff(stTime);
    prCutoff += m_pEG->GetCutoff(stTime);
    prCutoff += m_prVelScale;
    prCutoff += prFreqIn;

    //
    // Set the Resonance Q index
    //
    iQIndex = m_Source.m_iQIndex;

    //
    // Set the cutoff frequency index, and retrive
    // the fractional part for interpolation
    //
    iIndex  = prCutoff;
    if ( iIndex >= 0 )
    {
        dwFract = iIndex % 100;
        iIndex /= 100;
    }
    else
    {
        dwFract = 0;
        iIndex  = -1;
    }

    if (iIndex < 0) // Cutoff fequency is less than 100Hz (at 48k Fs)
    {
        cfK  =  m_aK[iQIndex][0];
        cfB1 = m_aB1[iQIndex][0];
        cfB2 = m_aB2[iQIndex][0];
    }
    else if (iIndex >= FILTER_PARMS_DIM_FC - 1)
    {
        cfK  =  m_aK[iQIndex][FILTER_PARMS_DIM_FC - 1];
        cfB1 = m_aB1[iQIndex][FILTER_PARMS_DIM_FC - 1];
        cfB2 = m_aB2[iQIndex][FILTER_PARMS_DIM_FC - 1];
    }
    else if (iIndex >= FILTER_PARMS_DIM_FC - 5)
    {
        //
        // Not enough headroom to handle the calculation,
        // shift the range douwn by half
        //
        cfK  =  m_aK[iQIndex][iIndex] + (((( m_aK[iQIndex][iIndex+1] -  m_aK[iQIndex][iIndex])   >> 1) * dwFract)/50);
        cfB1 = m_aB1[iQIndex][iIndex] - ((((m_aB1[iQIndex][iIndex]   - m_aB1[iQIndex][iIndex+1]) >> 1) * dwFract)/50);
        cfB2 = m_aB2[iQIndex][iIndex] - ((((m_aB2[iQIndex][iIndex]   - m_aB2[iQIndex][iIndex+1]) >> 1) * dwFract)/50);
    }
    else
    {
        cfK  =  m_aK[iQIndex][iIndex] + (((( m_aK[iQIndex][iIndex+1] -  m_aK[iQIndex][iIndex]))   * dwFract)/100);
        cfB1 = m_aB1[iQIndex][iIndex] - ((((m_aB1[iQIndex][iIndex]   - m_aB1[iQIndex][iIndex+1])) * dwFract)/100);
        cfB2 = m_aB2[iQIndex][iIndex] - ((((m_aB2[iQIndex][iIndex]   - m_aB2[iQIndex][iIndex+1])) * dwFract)/100);
    }
}

//------------------------------------------------------------------------------------
// Reference Filter
// Note: This code is used only for testing or to understance the derivation
// of the above filter code. It was the original source for the current implementation
// aboce was optimized
//------------------------------------------------------------------------------------
/*void CVoiceFilter::GetCoeffRef(STIME stTime, COEFF &cfK, COEFF &cfB1, COEFF &cfB2)
{
    PREL prCutoff;
    int iQIndex;
    int iIndex;
    double fIndex;
    double fIntrp;

    //
    // Check if filter is disabled
    //
    if (m_Source.m_prCutoff == 0x7FFF)
    {
        cfK  = 0x40000000;  // unity in 2.30 fixpoint
        cfB1 = 0;
        cfB2 = 0;
        return;
    }

    //
    // Accumulate the current Cutoff Frequency
    //
    prCutoff  = m_Source.m_prCutoff;
    prCutoff += m_pLFO->GetCutoff(stTime);
    prCutoff += m_pEG->GetCutoff(stTime);
    prCutoff += m_prVelScale;

    //
    // There are 16 resonance values spaced 1.5db arpart
    // DLS2's has a minimum 1.5db error tolerance
    // Range of values it  0db to 22.5db
    // m_Source.m_vrQ are in 1/10 db's
    // The 15.0 represents the 1.5db'in 1/10 db's
    // with the 0.5 for rounding to the nearest index
    //
    iQIndex = (int)((m_Source.m_vrQ / 15.0f) + 0.5f);
    if (iQIndex < 0)
        iQIndex = 0;
    if (iQIndex > FILTER_PARMS_DIM_Q-1) // FILTER_PARMS_DIM_Q = 16
        iQIndex = FILTER_PARMS_DIM_Q-1;

    // >>>>> docdoc
    //
    //
    fIndex = 12.0 * (((prCutoff - m_Source.m_prSampleRate) / 1200.0 ) + 7.906890596);
    iIndex = (int)fIndex;
    fIntrp = fIndex - iIndex;

    if (iIndex < 0)
    {
        cfK  = m_aK [iQIndex][0];
        cfB1 = m_aB1[iQIndex][0];
        cfB2 = m_aB2[iQIndex][0];
    }
    else if (iIndex >= FILTER_PARMS_DIM_FC - 1)
    {
        cfK  = m_aK [iQIndex][FILTER_PARMS_DIM_FC - 1];
        cfB1 = m_aB1[iQIndex][FILTER_PARMS_DIM_FC - 1];
        cfB2 = m_aB2[iQIndex][FILTER_PARMS_DIM_FC - 1];
    }
    else
    {
        //
        // Linearly interpolate the fractional part of the index
        // accross two values of the coeficient table
        //
        cfK  = (COEFF)(m_aK[iQIndex][iIndex] * (1.0 - fIntrp) +
                         m_aK[iQIndex][iIndex+1] * fIntrp);

        cfB1 = (COEFF)(m_aB1[iQIndex][iIndex] * (1.0 - fIntrp) +
                         m_aB1[iQIndex][iIndex+1] * fIntrp);

        cfB2 = (COEFF)(m_aB2[iQIndex][iIndex] * (1.0 - fIntrp) +
                         m_aB2[iQIndex][iIndex+1] * fIntrp);
    }
}*/

BOOL CVoiceFilter::IsFiltered()
{
    return (m_Source.m_prCutoff != 0x7FFF);
}

CDigitalAudio::CDigitalAudio()
{
    m_pfBasePitch = 0;
    m_pfLastPitch = 0;
    m_pfLastSample = 0;
    m_pfLoopEnd = 0;
    m_pfLoopStart = 0;
    m_pfSampleLength = 0;
    m_prLastPitch = 0;
    m_ullLastSample = 0;
    m_ullLoopStart = 0;
    m_ullLoopEnd = 0;
    m_ullSampleLength = 0;
    m_fElGrande = FALSE;
    m_pCurrentBuffer = NULL;
    m_pWaveArt = NULL;
    m_ullSamplesSoFar = 0;
    m_lPrevSample = 0;
    m_lPrevPrevSample = 0;
};

CDigitalAudio::~CDigitalAudio()
{
    if (m_pWaveArt)
    {
        m_pWaveArt->Release();
    }
}

PFRACT CDigitalAudio::m_spfCents[201];
PFRACT CDigitalAudio::m_spfSemiTones[97];
VFRACT CDigitalAudio::m_svfDbToVolume[(MAXDB - MINDB) * 10 + 1];
BOOL CDigitalAudio::m_sfMMXEnabled = FALSE;

#ifdef MMX_ENABLED
BOOL MultiMediaInstructionsSupported();
#endif
#pragma optimize("", off) // Optimize causes crash! Argh!

void CDigitalAudio::Init()
{
    double flTemp;
    VREL    vrdB;

#ifdef MMX_ENABLED
    m_sfMMXEnabled = MultiMediaInstructionsSupported();
#endif // MMX_ENABLED
    for (vrdB = MINDB * 10;vrdB <= MAXDB * 10;vrdB++)
    {
        flTemp = vrdB;
        flTemp /= 100.0;
        flTemp = pow(10.0, flTemp);
        flTemp = pow(flTemp, 0.5);   // square root.
        flTemp *= 4095.0; // 2^12th, but avoid overflow...
        m_svfDbToVolume[vrdB - (MINDB * 10)] = (long) flTemp;
    }

    PREL prRatio;

    for (prRatio = -100;prRatio <= 100;prRatio++)
    {
        flTemp = prRatio;
        flTemp /= 1200.0;
        flTemp = pow(2.0, flTemp);
        flTemp *= 4096.0;
        m_spfCents[prRatio + 100] = (long) flTemp;
    }

    for (prRatio = -48;prRatio <= 48;prRatio++)
    {
        flTemp = prRatio;
        flTemp /= 12.0;
        flTemp = pow(2.0, flTemp);
        flTemp *= 4096.0;
        m_spfSemiTones[prRatio + 48] = (long) flTemp;
    }
}
#pragma optimize("", on)

VFRACT CDigitalAudio::VRELToVFRACT(VREL vrVolume)
{
    vrVolume /= 10;

    if (vrVolume < MINDB * 10)
        vrVolume = MINDB * 10;
    else if (vrVolume >= MAXDB * 10)
        vrVolume = MAXDB * 10;

    return (m_svfDbToVolume[vrVolume - MINDB * 10]);
}

PFRACT CDigitalAudio::PRELToPFRACT(PREL prPitch)
{
    PFRACT pfPitch = 0;
    PREL prOctave;
    if (prPitch > 100)
    {
        if (prPitch > 4800)
        {
            prPitch = 4800;
        }
        prOctave = prPitch / 100;
        prPitch = prPitch % 100;
        pfPitch = m_spfCents[prPitch + 100];
        pfPitch <<= prOctave / 12;
        prOctave = prOctave % 12;
        pfPitch *= m_spfSemiTones[prOctave + 48];
        pfPitch >>= 12;
    }
    else if (prPitch < -100)
    {
        if (prPitch < -4800)
        {
            prPitch = -4800;
        }
        prOctave = prPitch / 100;
        prPitch = (-prPitch) % 100;
        pfPitch = m_spfCents[100 - prPitch];
        pfPitch >>= ((-prOctave) / 12);
        prOctave = (-prOctave) % 12;
        pfPitch *= m_spfSemiTones[48 - prOctave];
        pfPitch >>= 12;
    }
    else
    {
        pfPitch = m_spfCents[prPitch + 100];
    }
    return (pfPitch);
}

void CDigitalAudio::ClearVoice()

{
    if (m_Source.m_pWave != NULL)
    {
        m_Source.m_pWave->PlayOff();
        m_Source.m_pWave->Release();    // Releases wave structure.
        m_Source.m_pWave = NULL;
    }
    if (m_pWaveArt)
    {
        m_pWaveArt->Release();
        m_pWaveArt = NULL;
    }
}

STIME CDigitalAudio::StartVoice(CSynth *pSynth,
                               CSourceSample *pSample,
                               PREL prBasePitch,
                               long lKey)
{
    m_prLastPitch = 0;
    m_lPrevSample = 0;
    m_lPrevPrevSample = 0;
    m_cfLastK  = 0;
    m_cfLastB1 = 0;
    m_cfLastB2 = 0;

    m_Source = *pSample;
    m_pnWave = pSample->m_pWave->m_pnWave;
    m_pSynth = pSynth;

    m_bOneShot = m_Source.m_bOneShot;

    pSample->m_pWave->AddRef(); // Keeps track of Wave usage.
    pSample->m_pWave->PlayOn();

    // Set initial pitch
    prBasePitch += pSample->m_prFineTune;
    prBasePitch += ((lKey - pSample->m_bMIDIRootKey) * 100);
    m_pfBasePitch = PRELToPFRACT(prBasePitch);
    m_pfBasePitch *= pSample->m_dwSampleRate;
    m_pfBasePitch /= pSynth->m_dwSampleRate;
    m_pfLastPitch = m_pfBasePitch;

    m_fElGrande = pSample->m_dwSampleLength >= 0x80000;     // Greater than 512k.
    if ((pSample->m_dwLoopEnd - pSample->m_dwLoopStart) >= 0x80000)
    {   // We can't handle loops greater than 1 meg!
        m_bOneShot = TRUE;
    }

    m_ullLastSample = 0;
    m_ullLoopStart = pSample->m_dwLoopStart;
    m_ullLoopStart = m_ullLoopStart << 12;
    m_ullLoopEnd = pSample->m_dwLoopEnd;
    m_ullLoopEnd = m_ullLoopEnd << 12;
    m_ullSampleLength = pSample->m_dwSampleLength;
    m_ullSampleLength = m_ullSampleLength << 12;
    m_pfLastSample = 0;
    m_pfLoopStart = (long) m_ullLoopStart;
    m_pfLoopEnd = (long) m_ullLoopEnd;

    if (m_ullLoopEnd <= m_ullLoopStart) // Should never happen, but death if it does!
    {
        m_bOneShot = TRUE;
    }
    if (m_fElGrande)
    {
        m_pfSampleLength = 0x7FFFFFFF;
    }
    else
    {
        m_pfSampleLength = (long) m_ullSampleLength;
    }

    m_pCurrentBuffer = NULL;    // Used by wave playing must be null for standard sample
    m_pWaveArt = NULL;
    m_ullSamplesSoFar = 0;

    return (0); // !!! what is this return value?
}


STIME CDigitalAudio::StartWave(CSynth *pSynth,
                               CWaveArt *pWaveArt,
                               PREL prBasePitch,
                               SAMPLE_TIME stVoiceStart,
                               SAMPLE_TIME stLoopStart,
                               SAMPLE_TIME stLoopEnd)
{
    m_pSynth   = pSynth;    // Save Synth

    if (pWaveArt)
    {
        pWaveArt->AddRef();
    }
    if (m_pWaveArt)
    {
        m_pWaveArt->Release();
    }
    m_pWaveArt = pWaveArt;  // Save Wave articulation

    // Reset all wave buffer flags
    CWaveBuffer* pWavBuf = pWaveArt->m_pWaves.GetHead();
    while ( pWavBuf )
    {
        pWavBuf->m_pWave->m_bActive = FALSE;
        pWavBuf = pWavBuf->GetNext();
    }

    // Initialize the current play buffer
    m_pCurrentBuffer = pWaveArt->m_pWaves.GetHead();;

    //if m_pCurrentBuffer is NULL the articulation contains
    //no samples... this shouldn't be possible.
    assert(m_pCurrentBuffer);

    m_pCurrentBuffer->m_pWave->m_bActive = TRUE;
    m_pCurrentBuffer->m_pWave->AddRef(); // Keeps track of Wave usage.
    m_pCurrentBuffer->m_pWave->PlayOn();

    // Fill CSourceSample class with CWave Defaults
    m_Source.m_pWave          = m_pCurrentBuffer->m_pWave;
    m_Source.m_dwSampleLength = m_pCurrentBuffer->m_pWave->m_dwSampleLength;
    m_Source.m_dwSampleRate   = m_pCurrentBuffer->m_pWave->m_dwSampleRate;
    m_Source.m_bSampleType    = m_pCurrentBuffer->m_pWave->m_bSampleType;
    m_Source.m_dwID           = m_pCurrentBuffer->m_pWave->m_dwID;
    m_Source.m_dwLoopStart    = 0;
    m_Source.m_dwLoopEnd      = m_pCurrentBuffer->m_pWave->m_dwSampleLength;
    m_Source.m_bMIDIRootKey   = 0;
    m_Source.m_prFineTune     = 0;

    m_bOneShot                = TRUE;

    // The the current sample pointer
    m_pnWave = m_pCurrentBuffer->m_pWave->m_pnWave;

    // Set initial pitch
    m_pfBasePitch = PRELToPFRACT(prBasePitch);
    m_pfBasePitch *= m_Source.m_dwSampleRate;
    m_pfBasePitch /= pSynth->m_dwSampleRate;
    m_pfLastPitch = m_pfBasePitch;
    m_prLastPitch = 0;

    m_fElGrande = m_Source.m_dwSampleLength >= 0x80000;     // Greater than 512k.

    m_ullLastSample = stVoiceStart;
    m_ullLastSample = m_ullLastSample << 12;
    m_ullSamplesSoFar = 0;
    m_ullLoopStart = m_Source.m_dwLoopStart;
    m_ullLoopStart = m_ullLoopStart << 12;
    m_ullLoopEnd = m_Source.m_dwLoopEnd;
    m_ullLoopEnd = m_ullLoopEnd << 12;
    m_ullSampleLength = m_Source.m_dwSampleLength;
    m_ullSampleLength = m_ullSampleLength << 12;
    m_pfLastSample = (long) m_ullLastSample;
    m_pfLoopStart = (long) m_ullLoopStart;
    m_pfLoopEnd = (long) m_ullLoopEnd;

    if (stLoopStart || stLoopEnd)
    {
        m_bOneShot = FALSE;

        m_ullLoopStart = stLoopStart;
        m_ullLoopStart = m_ullLoopStart << 12;
        m_ullLoopEnd = stLoopEnd;
        m_ullLoopEnd = m_ullLoopEnd << 12;
        m_pfLoopStart = (long) m_ullLoopStart;
        m_pfLoopEnd = (long) m_ullLoopEnd;
    }

    if ((stLoopEnd - stLoopStart) >= 0x80000)
    {
        m_bOneShot = TRUE;
    }

    // This could be WAY beyond the actual wave data range
    // So find out the sample we want to start at
    if(stVoiceStart > stLoopStart)
    {
        SAMPLE_TIME stLoopLen = stLoopEnd - stLoopStart;
        if(m_bOneShot == FALSE && stLoopLen != 0)
        {
            m_ullLastSample = stVoiceStart - stLoopStart;
            m_ullLastSample = m_ullLastSample - (stLoopLen * (m_ullLastSample / stLoopLen));
            m_ullLastSample = stLoopStart + m_ullLastSample;
            m_ullLastSample = m_ullLastSample << 12;
            m_pfLastSample = (long) (m_ullLastSample);
        }

        // Must be a wave with an start offset?
        // In any case we need to correct this or else we crash
        if(m_bOneShot && stVoiceStart > m_Source.m_dwSampleLength)
        {
            m_ullLastSample = 0;
            m_pfLastSample = 0;
        }
    }


    if(m_fElGrande)
    {
        m_pfSampleLength = 0x7FFFFFFF;
    }
    else
    {
        m_pfSampleLength = (long) m_ullSampleLength;
    }

    return (0);
}

/*  If the wave is bigger than one meg, the index can overflow.
    Solve this by assuming no mix session will ever be as great
    as one meg AND loops are never that long. We keep all our
    fractional indexes in two variables. In one case, m_pfLastSample,
    is the normal mode where the lower 12 bits are the fraction and
    the upper 20 bits are the index. And, m_ullLastSample
    is a LONGLONG with an extra 32 bits of index. The mix engine
    does not want the LONGLONGs, so we need to track the variables
    in the LONGLONGs and prepare them for the mixer as follows:
    Prior to mixing,
    if the sample is large (m_fElGrande is set), BeforeSampleMix()
    is called. This finds the starting point for the mix, which
    is either the current position or the start of the loop,
    whichever is earlier. It subtracts this starting point from
    the LONGLONG variables and stores an offset in m_dwAddressUpper.
    It also adjusts the pointer to the wave data appropriately.
    AfterSampleMix() does the inverse, reconstructing the the LONGLONG
    indeces and returning everthing back to normal.
*/

void CDigitalAudio::BeforeBigSampleMix()
{
    if (m_fElGrande)
    {
        ULONGLONG ullBase = 0;
        DWORD dwBase;
        if (m_bOneShot)
        {
            ullBase = m_ullLastSample;
        }
        else
        {
            if (m_ullLastSample < m_ullLoopStart)
            {
                ullBase = m_ullLastSample;
            }
            else
            {
                ullBase = m_ullLoopStart;
            }
        }

        // Keep the value as we want to offset into the wave buffer
        ULONGLONG ullWaveOffset = ullBase;

        ullBase >>= 12;
        dwBase = (DWORD) ullBase & 0xFFFFFFFE;      // Clear bottom bit so 8 bit pointer aligns with short.
        ullBase = dwBase;
        ullBase <<= 12;
        m_dwAddressUpper = dwBase;

        m_pfLastSample = (long) (m_ullLastSample - ullBase);

        if ((m_ullLoopEnd - ullBase) < 0x7FFFFFFF)
        {
            m_pfLoopStart = (long) (m_ullLoopStart - ullBase);
            m_pfLoopEnd = (long) (m_ullLoopEnd - ullBase);
        }
        else
        {
            m_pfLoopStart = 0;
            m_pfLoopEnd = 0x7FFFFFFF;
        }

        ullBase = m_ullSampleLength - ullBase;
        dwBase = (DWORD)(ullWaveOffset >> 12);

        if (ullBase > 0x7FFFFFFF)
        {
            m_pfSampleLength = 0x7FFFFFFF;
        }
        else
        {
            m_pfSampleLength = (long) ullBase;
        }
        if (m_Source.m_bSampleType & SFORMAT_8)
        {
            dwBase >>= 1;
        }
        m_pnWave = &m_Source.m_pWave->m_pnWave[dwBase];
    }
}

void CDigitalAudio::AfterBigSampleMix()
{
    m_pnWave = m_Source.m_pWave->m_pnWave;
    if (m_fElGrande)
    {
        ULONGLONG ullBase = m_dwAddressUpper;
        m_ullLastSample = m_pfLastSample;
        m_ullLastSample += (ullBase << 12);
        m_dwAddressUpper = 0;
    }
}

BOOL CDigitalAudio::Mix(short **ppBuffers,      // Array of mix buffers
                        DWORD dwBufferCount,    // Number of mix buffers
                        DWORD dwInterleaved,    // Are the buffers interleaved data?
                        DWORD dwLength,         // Length to mix, in samples
                        VREL  vrMaxVolumeDelta, // Maximum volume accross all buses
                        VFRACT vfNewVolume[],
                        VFRACT vfLastVolume[],
                        PREL  prPitch,          // Pitch to play the sample too
                        DWORD dwIsFiltered,     // Is the mix filtered
                        COEFF cfK,              // filter coeficients
                        COEFF cfB1,
                        COEFF cfB2)
{
    DWORD i;
    PFRACT pfDeltaPitch;
    PFRACT pfEnd;
    PFRACT pfLoopLen;
    PFRACT pfNewPitch;
    VFRACT vfDeltaVolume[MAX_DAUD_CHAN];
    DWORD dwPeriod = 64;
    DWORD dwSoFar;
    DWORD dwStart; // position in WORDs
    DWORD dwMixChoice = 0;
    DWORD dwBuffers;
    PFRACT pfPreMix;
    COEFFDELTA  cfdK  = 0;
    COEFFDELTA  cfdB1 = 0;
    COEFFDELTA  cfdB2 = 0;

    if (dwLength == 0)      // Attack was instant.
    {
        m_pfLastPitch = (m_pfBasePitch * PRELToPFRACT(prPitch)) >> 12;
        m_prLastPitch = prPitch;
        m_cfLastK  = cfK;
        m_cfLastB1 = cfB1;
        m_cfLastB2 = cfB2;

        return TRUE;
    }

    if ( m_pWaveArt ) // Playing a wave or Streaming
    {
        if ( m_pWaveArt->m_bStream )
        {
            // Check if the buffer is valid yet
            if ( !m_pCurrentBuffer->m_pWave->m_bValid )
            {
                Trace(3, "Warning: Synth starting mix with invalid streaming wave buffer\n\r");
                return TRUE; // not valid yet, get out of here
            }
            m_pCurrentBuffer->m_pWave->m_bActive = TRUE;

            if ( m_pCurrentBuffer->m_pWave->m_bLastSampleInit == FALSE )
            {
                CWaveBuffer* pnextbuffer = m_pCurrentBuffer->GetNextLoop();

                if ( pnextbuffer->m_pWave->m_bValid )
                {
                    DWORD dwSampleLength = m_pCurrentBuffer->m_pWave->m_dwSampleLength;   // Length of sample.

                    if ( m_Source.m_bSampleType == SFORMAT_8 )
                    {
                        ((BYTE*)m_pCurrentBuffer->m_pWave->m_pnWave)[dwSampleLength-1] = ((BYTE*)pnextbuffer->m_pWave->m_pnWave)[0];
                    }
                    else
                    {
                        m_pCurrentBuffer->m_pWave->m_pnWave[dwSampleLength-1] = pnextbuffer->m_pWave->m_pnWave[0];
                    }

                    m_pCurrentBuffer->m_pWave->m_bLastSampleInit = TRUE;
                }
            }
        }
    }

    if ((m_Source.m_pWave == NULL) || (m_Source.m_pWave->m_pnWave == NULL))
    {
        return FALSE;
    }

    DWORD dwMax = max(vrMaxVolumeDelta, abs(prPitch - m_prLastPitch) << 1);
    dwMax >>= 1;
    m_prLastPitch = prPitch;

    if (dwMax > 0)
    {
        dwPeriod = (dwLength << 3) / dwMax;
        if (dwPeriod > 512)
        {
            dwPeriod = 512;
        }
        else if (dwPeriod < 1)
        {
            dwPeriod = 1;
        }
    }
    else
    {
        dwPeriod = 512;     // Make it happen anyway.
    }

    // This makes MMX sound a little better (MMX bug will be fixed)
    dwPeriod += 3;
    dwPeriod &= 0xFFFFFFFC;

    pfNewPitch = m_pfBasePitch * PRELToPFRACT(prPitch);
    pfNewPitch >>= 12;

    pfDeltaPitch = MulDiv(pfNewPitch - m_pfLastPitch, dwPeriod << 8, dwLength);


    if ( dwInterleaved )
    {
        vfDeltaVolume[0] = MulDiv(vfNewVolume[0] - vfLastVolume[0], dwPeriod << 8, dwLength);
        vfDeltaVolume[1] = MulDiv(vfNewVolume[1] - vfLastVolume[1], dwPeriod << 8, dwLength);
    }
    else
    {
        for (dwBuffers = 0; dwBuffers < dwBufferCount; dwBuffers++)
        {
            vfDeltaVolume[dwBuffers] = MulDiv(vfNewVolume[dwBuffers] - vfLastVolume[dwBuffers], dwPeriod << 8, dwLength);
        }
    }

    if ( dwInterleaved )
    {
        dwMixChoice |= SPLAY_INTERLEAVED;
    }

    if (m_sfMMXEnabled && (dwLength > 8))
    {
        dwMixChoice |= SPLAY_MMX;
    }

    dwMixChoice |= m_Source.m_bSampleType;
    dwStart = 0;

    if (dwIsFiltered)
    {
        dwMixChoice |= SPLAY_FILTERED;

        //
        // The coeficients have been stored as DWORD's to gain an additional
        // bit of presision when calculating the interpolation between
        // coefiecients in the table.  Since these calcutlations always
        // result in positive coefiecients no greater the 1.9999,
        // we can safely cast to a signed int, from which negative deltas
        // can be correctly determined.
        //
        cfdK =  MulDiv((LONG)cfK  - (LONG)m_cfLastK,  dwPeriod, dwLength);
        cfdB1 = MulDiv((LONG)cfB1 - (LONG)m_cfLastB1, dwPeriod, dwLength);
        cfdB2 = MulDiv((LONG)cfB2 - (LONG)m_cfLastB2, dwPeriod, dwLength);
    }

    for (;;)
    {
        if (dwLength <= 8)
        {
            dwMixChoice &= ~SPLAY_MMX;
        }

        if (m_fElGrande)
        {
            BeforeBigSampleMix();
        }

        if (m_bOneShot)
        {
            pfEnd = m_pfSampleLength;
            if(m_pCurrentBuffer && m_pCurrentBuffer->m_pWave)
            {
                if((pfEnd >> 12) >= (long)(m_pCurrentBuffer->m_pWave->m_dwSampleLength - 1))
                {
                    pfEnd = (m_pCurrentBuffer->m_pWave->m_dwSampleLength - 2) << 12;
                }
            }

            pfLoopLen = 0;
            pfPreMix = m_pfLastSample;      // save off last sample pos
        }
        else
        {
            pfEnd = m_pfLoopEnd;
            pfLoopLen = m_pfLoopEnd - m_pfLoopStart;
            pfPreMix = 0;
            if (pfLoopLen <= pfNewPitch)
            {
                return FALSE;
            }

            if(pfLoopLen > m_pfSampleLength)
            {
                return FALSE;
            }
        }

        switch (dwMixChoice)
        {
        case SFORMAT_8 | SPLAY_INTERLEAVED :
            dwSoFar = Mix8(ppBuffers[0], dwLength, dwPeriod,
                vfDeltaVolume[0], vfDeltaVolume[1],
                vfLastVolume,
                pfDeltaPitch,
                pfEnd, pfLoopLen);
            break;
        case SFORMAT_16 | SPLAY_INTERLEAVED :
            dwSoFar = Mix16(ppBuffers[0], dwLength, dwPeriod,
                vfDeltaVolume[0], vfDeltaVolume[1],
                vfLastVolume,
                pfDeltaPitch,
                pfEnd, pfLoopLen);
            break;
#ifdef MMX_ENABLED
        case SFORMAT_8 | SPLAY_MMX | SPLAY_INTERLEAVED :
            dwSoFar = Mix8X(ppBuffers[0], dwLength, dwPeriod,
                vfDeltaVolume[0], vfDeltaVolume[1],
                vfLastVolume,
                pfDeltaPitch,
                pfEnd, pfLoopLen);

            break;
        case SFORMAT_16 | SPLAY_MMX | SPLAY_INTERLEAVED :
            dwSoFar = Mix16X(ppBuffers[0], dwLength, dwPeriod,
                vfDeltaVolume[0], vfDeltaVolume[1],
                vfLastVolume,
                pfDeltaPitch,
                pfEnd, pfLoopLen);
            break;
#endif
        case SFORMAT_8 :
        case SFORMAT_8 | SPLAY_MMX :
            dwSoFar = MixMulti8(ppBuffers, dwBufferCount,
                dwLength, dwPeriod,
                vfDeltaVolume,
                vfLastVolume,
                pfDeltaPitch,
                pfEnd, pfLoopLen);
            break;
        case SFORMAT_8 | SPLAY_FILTERED :
        case SFORMAT_8 | SPLAY_FILTERED | SPLAY_MMX :
            dwSoFar = MixMulti8Filter(ppBuffers, dwBufferCount,
                dwLength, dwPeriod,
                vfDeltaVolume,
                vfLastVolume,
                pfDeltaPitch,
                pfEnd, pfLoopLen,
                cfdK, cfdB1, cfdB2);
            break;
        case SFORMAT_16 :
        case SFORMAT_16 | SPLAY_MMX :
            dwSoFar = MixMulti16(ppBuffers, dwBufferCount,
                dwLength, dwPeriod,
                vfDeltaVolume,
                vfLastVolume,
                pfDeltaPitch,
                pfEnd, pfLoopLen);
            break;
        case SFORMAT_16 | SPLAY_FILTERED :
        case SFORMAT_16 | SPLAY_FILTERED | SPLAY_MMX :
            dwSoFar = MixMulti16Filter(ppBuffers, dwBufferCount,
                dwLength, dwPeriod,
                vfDeltaVolume,
                vfLastVolume,
                pfDeltaPitch,
                pfEnd, pfLoopLen,
                cfdK, cfdB1, cfdB2);
            break;
        default :
            return (FALSE);
        }

        if (m_fElGrande)
        {
            AfterBigSampleMix();
        }

        if (m_bOneShot)
        {
            // have mixed all we needed at this time to break
            if (dwSoFar >= dwLength)
            {
                m_ullSamplesSoFar += (m_pfLastSample - pfPreMix)>>12;
                break;
            }

            // the mix engine reached the end of the source data
            m_ullSamplesSoFar += ((m_pfLastSample - pfPreMix)>>12)-1;

            if ( m_pWaveArt ) // Playing or Streaming a Wave
            {
                if ( !m_pWaveArt->m_bStream )   // we must be at the end of the buffer
                    return FALSE;

                // Set completion flags
                m_pCurrentBuffer->m_pWave->m_bActive = FALSE;
                m_pCurrentBuffer->m_pWave->m_bValid  = FALSE;
                m_pCurrentBuffer->m_pWave->m_bLastSampleInit = FALSE;

                // Get next buffer
                m_pCurrentBuffer = m_pCurrentBuffer->GetNextLoop();

                // Set new wave pointer to play out of
                m_pnWave = m_pCurrentBuffer->m_pWave->m_pnWave;

                // Check if the buffer is valid yet
                if ( !m_pCurrentBuffer->m_pWave->m_bValid )
                {
                    Trace(2, "Warning: Synth attempting to start invalid streaming wave buffer\n\r");
                    break;  // nothing to play yet, get out of here
                }
                m_pCurrentBuffer->m_pWave->m_bActive = TRUE;

                CWaveBuffer* pnextbuffer = m_pCurrentBuffer->GetNextLoop();
                if ( pnextbuffer->m_pWave->m_bValid )
                {
                    DWORD dwSampleLength = m_pCurrentBuffer->m_pWave->m_dwSampleLength;   // Length of sample.

                    if ( m_Source.m_bSampleType == SFORMAT_8 )
                    {
                        ((BYTE*)m_pCurrentBuffer->m_pWave->m_pnWave)[dwSampleLength-1] = ((BYTE*)pnextbuffer->m_pWave->m_pnWave)[0];
                    }
                    else
                    {
                        m_pCurrentBuffer->m_pWave->m_pnWave[dwSampleLength-1] = pnextbuffer->m_pWave->m_pnWave[0];
                    }

                    m_pCurrentBuffer->m_pWave->m_bLastSampleInit = TRUE;
                }

//>>>>>>>>>> CHECK FOR LOOP POINT, IF SO NOT TRY AGAIN HERE

                dwStart  += dwSoFar << dwInterleaved;
                dwLength -= dwSoFar;
                m_pfLastSample = 0;

//>>>>>>>>>> CHECK INTERLEAVED FLAG FOR CORRECT DISTANCE ????????
                // Move buffer pointers since we are mixing more samples
                for ( i = 0; i < dwBufferCount; i++ )
                    ppBuffers[i] += dwStart;

                continue;   // keep playing
            }
            else
                return FALSE;   // Playing a standard one shot, we hit the end of the buffer
        }
        else
        {
            if (dwSoFar >= dwLength)
                break;

            // Loops are handled in the mix engine, however
            // when you reach the end of source data you will
            // reach this code.

            dwStart  += dwSoFar << dwInterleaved;
            dwLength -= dwSoFar;
            m_pfLastSample -= (m_pfLoopEnd - m_pfLoopStart);

            // Move buffer pointers since we are mixing more samples
            for ( i = 0; i < dwBufferCount; i++ )
                ppBuffers[i] += dwStart;
        }
    }

    m_pfLastPitch = pfNewPitch;
    m_cfLastK  = cfK;
    m_cfLastB1 = cfB1;
    m_cfLastB2 = cfB2;

    return (TRUE);
}

CVoice::CVoice()
{
    m_pControl = NULL;
    m_pPitchBendIn = NULL;
    m_pExpressionIn = NULL;
    m_dwPriority = 0;
    m_nPart = 0;
    m_nKey = 0;
    m_fInUse = FALSE;
    m_fSustainOn = FALSE;
    m_fNoteOn = FALSE;
    m_fTag = FALSE;
    m_stStartTime = 0;
    m_stStopTime = 0x7fffffffffffffff;
    m_stWaveStopTime = 0;
    m_vrVolume = 0;
    m_fAllowOverlap = FALSE;
    m_pRegion = NULL;
    m_pReverbSend = NULL;
    m_pChorusSend = NULL;
    m_dwLoopType = 0;

    for ( int i = 0; i < MAX_DAUD_CHAN; i++ )
    {
        m_vfLastVolume[i] = 0;
        m_vrLastVolume[i] = 0;
    }
}

VREL CVoice::m_svrPanToVREL[128];

void CVoice::Init()
{
    static BOOL fBeenHereBefore = FALSE;
    if (fBeenHereBefore) return;
    fBeenHereBefore = TRUE;
    CVoiceLFO::Init();
    CVoiceEG::Init();
    CDigitalAudio::Init();

    WORD nI;
    for (nI = 1; nI < 128; nI++)
    {
        double flTemp;
        flTemp = nI;
        flTemp /= 127.0;
        flTemp = log10(flTemp);
        flTemp *= 1000.0;
        m_svrPanToVREL[nI] = (long) flTemp;
    }
    m_svrPanToVREL[0] = -2500;
}

void CVoice::StopVoice(STIME stTime)
{
    if (m_fNoteOn)
    {
        if (stTime <= m_stStartTime) stTime = m_stStartTime + 1;
        m_PitchEG.StopVoice(stTime);
        m_VolumeEG.StopVoice(stTime);
        m_fNoteOn = FALSE;
        m_fSustainOn = FALSE;
        m_stStopTime = stTime;
        m_stWaveStopTime = 0;

        if (m_dwLoopType == WLOOP_TYPE_RELEASE)
        {
            m_DigitalAudio.BreakLoop();
        }
    }
}

void CVoice::QuickStopVoice(STIME stTime)
{
    m_fTag = TRUE;
    if (m_fNoteOn || m_fSustainOn)
    {
        if (stTime <= m_stStartTime) stTime = m_stStartTime + 1;
        m_PitchEG.StopVoice(stTime);
        m_VolumeEG.QuickStopVoice(stTime, m_pSynth->m_dwSampleRate);
        m_fNoteOn = FALSE;
        m_fSustainOn = FALSE;
        m_stStopTime = stTime;
    }
    else
    {
        m_VolumeEG.QuickStopVoice(m_stStopTime, m_pSynth->m_dwSampleRate);
    }
}

BOOL CVoice::StartVoice(CSynth *pSynth,
                           CSourceRegion *pRegion,
                           STIME stStartTime,
                           CModWheelIn * pModWheelIn,
                           CPitchBendIn * pPitchBendIn,
                           CExpressionIn * pExpressionIn,
                           CVolumeIn * pVolumeIn,
                           CPanIn * pPanIn,
                           CPressureIn * pPressureIn,
                           CReverbIn * pReverbSend,
                           CChorusIn * pChorusSend,
                           CCutOffFreqIn * pCCutOffFreqIn,
                           CBusIds * pBusIds,
                           WORD nKey,
                           WORD nVelocity,
                           VREL vrVolume,
                           PREL prPitch)
{
    m_pSynth = pSynth;

    CSourceArticulation * pArticulation = pRegion->m_pArticulation;
    if (pArticulation == NULL)
    {
        return FALSE;
    }

    m_dwLoopType = pRegion->m_Sample.m_dwLoopType;

    // if we're going to handle volume later, don't read it now.
    if (!pSynth->m_fAllowVolumeChangeWhilePlayingNote)
        vrVolume += pVolumeIn->GetVolume(stStartTime);

    prPitch += pRegion->m_prTuning;
    m_dwGroup = pRegion->m_bGroup;
    m_fAllowOverlap = pRegion->m_bAllowOverlap;

    vrVolume += CMIDIRecorder::VelocityToVolume(nVelocity);

    vrVolume += pRegion->m_vrAttenuation;

    m_lDefaultPan = pRegion->m_pArticulation->m_sDefaultPan;

    // ignore pan here if allowing pan to vary after note starts
    // or if the source is multichannel or the dest is mono
    //

    m_fIgnorePan = pRegion->IsMultiChannel();
    if (pBusIds->m_dwBusCount == 1)
    {
        DWORD dwFunctionID;
        if (m_pSynth->BusIDToFunctionID(pBusIds->m_dwBusIds[0], &dwFunctionID, NULL, NULL))
        {
            if (dwFunctionID == DSBUSID_LEFT)
            {
                m_fIgnorePan = TRUE;
            }
        }
    }

    VREL vrVolumeL;
    VREL vrVolumeR;
    if ( pSynth->m_dwStereo &&
        !pSynth->m_fAllowPanWhilePlayingNote &&
        !m_fIgnorePan)
    {
        long lPan = pPanIn->GetPan(stStartTime) + m_lDefaultPan;

        if (lPan < 0)
            lPan = 0;

        if (lPan > 127)
            lPan = 127;

        vrVolumeL = m_svrPanToVREL[127 - lPan] + vrVolume;
        vrVolumeR = m_svrPanToVREL[lPan] + vrVolume;
    }
    else
    {
        vrVolumeL = vrVolume;
        vrVolumeR = vrVolume;
    }

    VREL vrVolumeReverb = vrVolume;
    VREL vrVolumeChorus = vrVolume;

    PREL prBusPitchBend = 0;  // This gets a pitch offset that is set by DSound in response to SetFrequency and Doppler commands.
                             // When this is applied to multiple buses, only one of the values can be used, so we always give
                             // preference to the buffer that has DSBUSID_DYNAMIC_0 for the functional id, since that
                             // would most likely be a 3D sound effect.
    BOOL fDynamic = false;

    for( DWORD i = 0; i < pBusIds->m_dwBusCount; i++ )
    {
        DWORD dwFunctionID;
        PREL prGetPitch = 0;
        if (m_pSynth->BusIDToFunctionID(pBusIds->m_dwBusIds[i], &dwFunctionID, &prGetPitch, NULL))
        {
            if (!fDynamic)
            {
                // If no previous bus was dynamic, get this value.
                prBusPitchBend = prGetPitch;
            }
            m_vrBaseVolume[i] = MIN_VOLUME;

            if (DSBUSID_IS_SPKR_LOC(dwFunctionID))
            {
                if (pRegion->IsMultiChannel())
                {
                    // Explicit channel assignment with no pan. For every bus
                    // that matches a bit in the channel mask, turn it on.
                    //
                    if (pRegion->m_dwChannel & (1 << dwFunctionID))
                    {
                        m_vrBaseVolume[i] = vrVolume;
                    }
                }
                else
                {
                    switch(dwFunctionID)
                    {
                    case DSBUSID_LEFT:
                        m_vrBaseVolume[i] = vrVolumeL;
                        break;

                    case DSBUSID_RIGHT:
                        m_vrBaseVolume[i] = vrVolumeR;
                        break;
                    }
                }
            }
            else
            {
                // Not a speaker location, a send or a 3D buffer.
                //
                switch(dwFunctionID)
                {
                case DSBUSID_REVERB_SEND:
                    m_vrBaseVolume[i] = vrVolumeReverb;
                    break;

                case DSBUSID_CHORUS_SEND:
                    m_vrBaseVolume[i] = vrVolumeChorus;
                    break;

                case DSBUSID_NULL:
                    m_vrBaseVolume[i] = MIN_VOLUME;
                    break;

                case DSBUSID_DYNAMIC_0:
                    fDynamic = true;
                default:
                    m_vrBaseVolume[i] = vrVolume;
                }
            }

            m_vrLastVolume[i] = MIN_VOLUME;
            m_vfLastVolume[i] = m_DigitalAudio.VRELToVFRACT(MIN_VOLUME);
        }
    }

    m_stMixTime = m_LFO.StartVoice(&pArticulation->m_LFO,
        stStartTime, pModWheelIn, pPressureIn);

    STIME stMixTime = m_LFO2.StartVoice(&pArticulation->m_LFO2,
        stStartTime, pModWheelIn, pPressureIn);
    if (stMixTime < m_stMixTime)
    {
        m_stMixTime = stMixTime;
    }

    stMixTime = m_PitchEG.StartVoice(&pArticulation->m_PitchEG,
        stStartTime, nKey, nVelocity, 0);
    if (stMixTime < m_stMixTime)
    {
        m_stMixTime = stMixTime;
    }

    // Force attack to never be shorter than a millisecond.
    stMixTime = m_VolumeEG.StartVoice(&pArticulation->m_VolumeEG,
        stStartTime, nKey, nVelocity, pSynth->m_dwSampleRate/1000);
    if (stMixTime < m_stMixTime)
    {
        m_stMixTime = stMixTime;
    }

    if (m_stMixTime > pSynth->m_stMaxSpan)
    {
        m_stMixTime = pSynth->m_stMaxSpan;
    }

    m_Filter.StartVoice(&pArticulation->m_Filter,
        &m_LFO, &m_PitchEG, nKey, nVelocity);

    // Make sure we have a pointer to the wave ready:
    if ((pRegion->m_Sample.m_pWave == NULL) || (pRegion->m_Sample.m_pWave->m_pnWave == NULL))
    {
        return (FALSE);     // Do nothing if no sample.
    }

    m_DigitalAudio.StartVoice(pSynth,
                              &pRegion->m_Sample,
                              prPitch,
                              (long)nKey);

    m_pPitchBendIn = pPitchBendIn;
    m_pExpressionIn = pExpressionIn;
    m_pPanIn = pPanIn;
    m_pReverbSend = pReverbSend;
    m_pChorusSend = pChorusSend;
    m_CCutOffFreqIn = pCCutOffFreqIn;
    m_pVolumeIn = pVolumeIn;
    m_BusIds = *pBusIds;
    m_fNoteOn = TRUE;
    m_fTag = FALSE;
    m_fSustainOn = FALSE;
    m_stStartTime = stStartTime;
    m_stLastMix = stStartTime - 1;
    m_stStopTime = 0x7fffffffffffffff;
    m_stWaveStopTime = 0;

    //
    // Zero length attack,
    // be sure initial settings aren't missed....
    //
    if (m_stMixTime == 0)
    {
        PREL  prNewPitch;
        COEFF cfK, cfB1, cfB2;

        GetNewPitch(stStartTime, prNewPitch);
        GetNewCoeff(stStartTime, m_prLastCutOff, cfK, cfB1, cfB2);

        m_DigitalAudio.Mix(NULL,
                           0,
                           0,
                           0,
                           0,
                           NULL,
                           NULL,
                           prNewPitch + prBusPitchBend,
                           m_Filter.IsFiltered(),
                           cfK, cfB1, cfB2);
    }

    m_vrVolume = MAX_VOLUME;

    return (TRUE);
}

BOOL CVoice::StartWave(CSynth *pSynth,
                       CWaveArt *pWaveArt,
                       DWORD dwVoiceId,
                       STIME stStartTime,
                       CPitchBendIn * pPitchBendIn,
                       CExpressionIn * pExpressionIn,
                       CVolumeIn * pVolumeIn,
                       CPanIn * pPanIn,
                       CReverbIn * pReverbSend,
                       CChorusIn * pChorusSend,
                       CCutOffFreqIn * pCCutOffFreqIn,
                       CBusIds * pBusIds,
                       VREL vrVolume,
                       PREL prPitch,
                       SAMPLE_TIME stVoiceStart,
                       SAMPLE_TIME stLoopStart,
                       SAMPLE_TIME stLoopEnd
                       )
{
    m_pSynth = pSynth;

    DWORD dwFuncId = pWaveArt->m_WaveArtDl.ulBus;

    VREL vrVolumeReverb = vrVolume;
    VREL vrVolumeChorus = vrVolume;

    m_fIgnorePan = (BOOL)(DSBUSID_IS_SPKR_LOC(dwFuncId) && (pWaveArt->m_WaveArtDl.usOptions & F_WAVELINK_MULTICHANNEL));
    if (pBusIds->m_dwBusCount == 1)
    {
        DWORD dwFunctionID;
        if (m_pSynth->BusIDToFunctionID(pBusIds->m_dwBusIds[0], &dwFunctionID, NULL, NULL))
        {
            if (dwFunctionID == DSBUSID_LEFT)
            {
                m_fIgnorePan = TRUE;
            }
        }
    }

    for( DWORD i = 0; i < pBusIds->m_dwBusCount; i++ )
    {
        m_vrBaseVolume[i] = MIN_VOLUME;

        DWORD dwFunctionID;
        if (m_pSynth->BusIDToFunctionID(pBusIds->m_dwBusIds[i], &dwFunctionID, NULL, NULL))
        {
            // If this bus is a speaker location
            //
            if (DSBUSID_IS_SPKR_LOC(dwFunctionID))
            {
                if (pWaveArt->m_WaveArtDl.usOptions & F_WAVELINK_MULTICHANNEL)
                {
                    if (dwFuncId == dwFunctionID)
                    {
                        m_vrBaseVolume[i] = vrVolume;
                    }
                }
                else
                {
                    if (dwFunctionID == DSBUSID_LEFT || dwFunctionID == DSBUSID_RIGHT)
                    {
                        m_vrBaseVolume[i] = vrVolume;
                    }
                }
            }
            else switch (dwFunctionID)
            {
            case DSBUSID_REVERB_SEND:
                m_vrBaseVolume[i] = vrVolumeReverb;
                break;

            case DSBUSID_CHORUS_SEND:
                m_vrBaseVolume[i] = vrVolumeChorus;
                break;

            case DSBUSID_NULL:
                m_vrBaseVolume[i] = MIN_VOLUME;
                break;

            default:
                m_vrBaseVolume[i] = vrVolume;
            }

            m_vrLastVolume[i] = MIN_VOLUME;
            m_vfLastVolume[i] = m_DigitalAudio.VRELToVFRACT(MIN_VOLUME);
        }
    }

    // Initialize an envelope for wave playing
    //
    CSourceEG WaveVolumeEG;
    WaveVolumeEG.Init();
    WaveVolumeEG.m_pcSustain = 1000;
    // Force the envelope attack and release to be no smaller than 4ms. This ensures we won't get
    // clicks if we start and stop at non-zero crossings.
    m_stMixTime = m_VolumeEG.StartVoice(&WaveVolumeEG, stStartTime, 0, 0, pSynth->m_dwSampleRate/250);
    if (m_stMixTime > pSynth->m_stMaxSpan)
    {
        m_stMixTime = pSynth->m_stMaxSpan;
    }

    m_pPitchBendIn = pPitchBendIn;
    m_pExpressionIn = pExpressionIn;
    m_pPanIn = pPanIn;
    m_pReverbSend = pReverbSend;
    m_pChorusSend = pChorusSend;
    m_CCutOffFreqIn = pCCutOffFreqIn;
    m_pVolumeIn = pVolumeIn;
    m_BusIds = *pBusIds;
    m_fNoteOn = TRUE;
    m_fTag = FALSE;
    m_stStartTime = stStartTime;
    m_stLastMix = stStartTime - 1;
    m_stStopTime = 0x7fffffffffffffff;
    m_stWaveStopTime = 0;
    m_dwGroup = 0;
    m_lDefaultPan = 0;
    m_vrVolume = 0;
    m_fAllowOverlap = FALSE;
    m_fSustainOn = FALSE;
    m_dwVoiceId = dwVoiceId;

    m_LFO.Enable(FALSE);             // Disable LFO.
    m_LFO2.Enable(FALSE);            // Disable LFO2.
    m_PitchEG.Enable(FALSE);         // Disable Pitch Envelope.
    m_Filter.m_Source.m_prCutoff = 0x7FFF;

    m_DigitalAudio.StartWave(pSynth,
                             pWaveArt,
                             prPitch,
                             stVoiceStart,
                             stLoopStart,
                             stLoopEnd);

    return (TRUE);
}

SAMPLE_POSITION CVoice::GetCurrentPos()
{
    return m_DigitalAudio.GetCurrentPos();
}

void CVoice::ClearVoice()
{
    m_fInUse = FALSE;
    m_DigitalAudio.ClearVoice();
}

// return the volume delta at time <stTime>.
// volume is sum of volume envelope, LFO, expression, optionally the
// channel volume if we're allowing it to change, and optionally the current
// pan if we're allowing that to change.
// This will be added to the base volume calculated in CVoice::StartVoice().
inline void CVoice::GetNewVolume(STIME stTime, VREL& vrVolume, VREL& vrVolumeL, VREL& vrVolumeR, VREL& vrVolumeReverb, VREL& vrVolumeChorus)
{
    STIME stMixTime = m_stMixTime;

    //
    // the evelope volume is used by code that detects whether this note is off
    // and for voice stealing
    //
    m_vrVolume = m_VolumeEG.GetVolume(stTime, &stMixTime);
    if (stMixTime < m_stMixTime)
        m_stMixTime = stMixTime;

    vrVolume = m_vrVolume;
    vrVolume += m_LFO.GetVolume(stTime, &stMixTime);
    if (stMixTime < m_stMixTime)
        m_stMixTime = stMixTime;

    vrVolume += m_pExpressionIn->GetVolume(stTime);

    if (m_pSynth->m_fAllowVolumeChangeWhilePlayingNote)
        vrVolume += m_pVolumeIn->GetVolume(stTime);

    vrVolume += m_pSynth->m_vrGainAdjust;

    // handle pan here if allowing pan to vary after note starts
    vrVolumeL = vrVolume;
    vrVolumeR = vrVolume;
    if (m_pSynth->m_dwStereo && m_pSynth->m_fAllowPanWhilePlayingNote && !m_fIgnorePan)
    {
        // add current pan & instrument default pan
        LONG lPan;

        if (m_pPanIn)
        {
            lPan = m_pPanIn->GetPan(stTime) + m_lDefaultPan;
        }
        else
        {
            lPan = 63;
        }

        // don't go off either end....
        if (lPan < 0) lPan = 0;
        if (lPan > 127) lPan = 127;
        vrVolumeL += m_svrPanToVREL[127 - lPan];
        vrVolumeR += m_svrPanToVREL[lPan];
    }
    // Get Reverb Send volume
    vrVolumeReverb  = vrVolume + m_pReverbSend->GetVolume(stTime);
    // Get Chorus Send volume
    vrVolumeChorus  = vrVolume + m_pChorusSend->GetVolume(stTime);
}

// Returns the current pitch for time <stTime>.
// Pitch is the sum of the pitch LFO, the pitch envelope, and the current
// pitch bend.
inline void CVoice::GetNewPitch(STIME stTime, PREL& prPitch)
{
    STIME stMixTime = m_stMixTime;

    prPitch = m_LFO.GetPitch(stTime, &stMixTime);
    if (m_stMixTime > stMixTime) m_stMixTime = stMixTime;

    prPitch += m_LFO2.GetPitch(stTime, &stMixTime);
    if (m_stMixTime > stMixTime) m_stMixTime = stMixTime;

    prPitch += m_PitchEG.GetPitch(stTime, &stMixTime);
    if (m_stMixTime > stMixTime) m_stMixTime = stMixTime;

    prPitch += m_pPitchBendIn->GetPitch(stTime);
}

// Returns the current cutoff frequency for time <stTime>.
// cutoff frequency is the sum of the pitch LFO, the pitch envelope, and the current
// MIDI filter CC control.
inline void CVoice::GetNewCoeff(STIME stTime, PREL& prCutOff, COEFF& cfK, COEFF& cfB1, COEFF& cfB2)
{

    DWORD dwfreq;

    // returned frequency is in semitones, where 64 is the mid range
    dwfreq = m_CCutOffFreqIn->GetFrequency(stTime);
    prCutOff = (dwfreq - 64)*100;   // convert to PREL's

    m_Filter.GetCoeff(stTime, prCutOff, cfK, cfB1, cfB2);
}

DWORD CVoice::Mix(short **ppvBuffer,
                  DWORD dwBufferFlags,
                  DWORD dwLength,
                  STIME stStart,
                  STIME stEnd)

{
    BOOL   fInUse    = TRUE;
    BOOL   fFullMix   = TRUE;
    STIME  stEndMix   = stStart;
    STIME  stStartMix = m_stStartTime;
    COEFF  cfK, cfB1, cfB2;
    PREL   prPitch;
    PREL   prCutOff;
    VREL   vrVolume, vrVolumeL, vrVolumeR;
    VREL   vrVolumeReverb, vrVolumeChorus;
    VREL   vrMaxVolumeDelta;
    VFRACT vfNewVolume[MAX_DAUD_CHAN];
    VFRACT vfLastVolume[MAX_DAUD_CHAN];
    short  *ppsMixBuffers[MAX_DAUD_CHAN];

    if (stStartMix < stStart)
    {
        stStartMix = stStart;
    }

    if (m_stLastMix >= stEnd)
    {
        return (0);
    }

    if (m_stLastMix >= stStartMix)
    {
        stStartMix = m_stLastMix;
    }

    while (stStartMix < stEnd && fInUse)
    {
        stEndMix = stStartMix + m_stMixTime;
        if (stEndMix > stEnd)
        {
            stEndMix = stEnd;
        }

        m_stMixTime = m_pSynth->m_stMaxSpan;
        if ((m_stLastMix < m_stStopTime) && (m_stStopTime < stEnd))
        {
            if (m_stMixTime > (m_stStopTime - m_stLastMix))
            {
                m_stMixTime = m_stStopTime - m_stLastMix;
            }
        }

        //
        // Get the new pitch
        //
        GetNewPitch(stEndMix, prPitch);

        //
        // Get the new volume
        //
        GetNewVolume(stEndMix, vrVolume, vrVolumeL, vrVolumeR, vrVolumeReverb, vrVolumeChorus);

        //
        // Get the new filter coeficients
        //
        GetNewCoeff(stEndMix, prCutOff, cfK, cfB1, cfB2);

        //
        // Check to see if the volume is precievable, if not kill voice
        //
        if (m_VolumeEG.InRelease(stEndMix))
        {
            if (m_vrVolume < PERCEIVED_MIN_VOLUME) // End of release slope
            {
                // Breaking the loop ensures that the mixmulti functions don't mix any more samples
                // for looped wave Without this the mix engine will mix a few more samples for
                // looped waves resulting in a pop at the end of the wave.
                m_DigitalAudio.BreakLoop();
                fInUse = FALSE;
            }
        }

        vrMaxVolumeDelta = 0;
        vfNewVolume[0]   = 0;
        ppsMixBuffers[0] = NULL;
        DWORD dwMixBufferCount = 0;
        PREL prBusPitchBend = 0;  // This gets a pitch offset that is set by DSound in response to SetFrequency and Doppler commands.
                                 // When this is applied to multiple buses, only one of the values can be used, so we always give
                                 // preference to the buffer that has DSBUSID_DYNAMIC_0 for the functional id, since that
                                 // would most likely be a 3D sound effect.
        BOOL fDynamic = false;

        if (dwBufferFlags & BUFFERFLAG_MULTIBUFFER)
        {
            // Iterate through each bus id in the voice, assigning a sink bus to each one.
            for ( DWORD nBusID = 0; nBusID < m_BusIds.m_dwBusCount; nBusID++ )
            {
                DWORD dwFunctionalID;
                DWORD dwBusIndex;
                PREL prGetPitch;

                if (m_pSynth->BusIDToFunctionID(m_BusIds.m_dwBusIds[nBusID], &dwFunctionalID, &prGetPitch, &dwBusIndex))
                {
                    if (!fDynamic)
                    {
                        // If no previous bus was dynamic, get this value.
                        prBusPitchBend = prGetPitch;
                    }
                    // Default to original volume (before pan, reverb or chorus modifiers.)
                    VREL vrTemp = vrVolume;
                    // Replace for any of the other cases (left, right, reverb, chorus.)
                    if ( dwFunctionalID == DSBUSID_NULL )
                    {
                        continue;
                    }
                    if ( dwFunctionalID == DSBUSID_LEFT )
                    {
                        vrTemp = vrVolumeL;
                    }
                    if ( dwFunctionalID == DSBUSID_RIGHT )
                    {
                        vrTemp = vrVolumeR;
                    }
                    else if ( dwFunctionalID == DSBUSID_REVERB_SEND )
                    {
                        vrTemp = vrVolumeReverb;
                    }
                    else if ( dwFunctionalID == DSBUSID_CHORUS_SEND )
                    {
                        vrTemp = vrVolumeChorus;
                    }
                    else if ( dwFunctionalID == DSBUSID_DYNAMIC_0 )
                    {
                        fDynamic = true;
                    }

                    vrMaxVolumeDelta = max((long)vrMaxVolumeDelta, abs(vrTemp - m_vrLastVolume[nBusID]));
                    m_vrLastVolume[nBusID] = vrTemp;

                    vrTemp += m_vrBaseVolume[nBusID];
                    vfNewVolume[dwMixBufferCount]  = m_DigitalAudio.VRELToVFRACT(vrTemp);
                    vfLastVolume[dwMixBufferCount] = m_vfLastVolume[nBusID];
                    m_vfLastVolume[nBusID] = vfNewVolume[dwMixBufferCount];
                    ppsMixBuffers[dwMixBufferCount] = &ppvBuffer[dwBusIndex][(stStartMix - stStart)];
                    dwMixBufferCount++;
                }
            }
        }
        else
        {
            // This is the DX7 compatibility case.
            vrMaxVolumeDelta = max((long)vrMaxVolumeDelta, abs(vrVolumeL - m_vrLastVolume[0]));
            m_vrLastVolume[0] = vrVolumeL;
            vfNewVolume[0]  = m_DigitalAudio.VRELToVFRACT(m_vrBaseVolume[0] + vrVolumeL);
            vfLastVolume[0] = m_vfLastVolume[0];
            m_vfLastVolume[0] = vfNewVolume[0];
            dwMixBufferCount = 1;
            if ( dwBufferFlags & BUFFERFLAG_INTERLEAVED )   // Is this a stereo buffer?
            {
                vrMaxVolumeDelta = max((long)vrMaxVolumeDelta, abs(vrVolumeR - m_vrLastVolume[1]));
                m_vrLastVolume[1] = vrVolumeR;
                vfNewVolume[1]  = m_DigitalAudio.VRELToVFRACT(m_vrBaseVolume[1] + vrVolumeR);
                vfLastVolume[1] = m_vfLastVolume[1];
                m_vfLastVolume[1] = vfNewVolume[1];
                ppsMixBuffers[0] = &ppvBuffer[0][(stStartMix - stStart) << 1];
            }
            else    // Or mono?
            {
                ppsMixBuffers[0] = &ppvBuffer[0][(stStartMix - stStart)];
            }
        }
        // If dwMixBufferCount is 0, this indicates there is no buffer available to play into.
        // This is caused by a buffer being deactivated. Under such circumstances, the
        // voice should not continue playing, or it will hold until the buffer reactivates, which
        // doesn't make sense. So, set fInUse to FALSE.
        if (dwMixBufferCount)
        {
            DWORD dwIsFiltered = m_Filter.IsFiltered();
            if (dwIsFiltered)
            {
                vrMaxVolumeDelta = max((long)vrMaxVolumeDelta, abs(prCutOff - m_prLastCutOff));
                m_prLastCutOff = prCutOff;
            }


            //
            // note: mix will in some cases modify the pointers found ppsMixBuffers array
            //
            fFullMix = m_DigitalAudio.Mix(ppsMixBuffers,                    // Array of mix buffers
                                          dwMixBufferCount,                 // Number of mix buffers
                                          (dwBufferFlags & BUFFERFLAG_INTERLEAVED), // Are the buffers interleaved data?
                                          (DWORD) (stEndMix - stStartMix),  // Length to mix in Samples
                                          vrMaxVolumeDelta,                 //
                                          vfNewVolume,
                                          vfLastVolume,
                                          prPitch + prBusPitchBend,         // Pitch to play the sample too
                                          dwIsFiltered,         // Is the mix filtered
                                          cfK, cfB1, cfB2);
            stStartMix = stEndMix;
        }
        else
        {
            fInUse = FALSE;
        }
    }

    m_fInUse = fInUse && fFullMix;
    if (!m_fInUse)
    {
        ClearVoice();
        m_stStopTime = stEndMix;    // For measurement purposes.
    }

    m_stLastMix = stEndMix;

    return (dwLength);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\XboxSynth\shared\alist.cpp ===
// Copyright (c) 1998-1999 Microsoft Corporation
//
// alist.cpp
//
#include "alist.h"

LONG AListItem::GetCount(void) const
{
    LONG l;
    const AListItem *li;

    for(l=0,li=this; li!=NULL ; li=li->m_pNext,++l);
    return l;
}

AListItem* AListItem::Cat(AListItem *pItem)
{
    AListItem *li;

    if(this==NULL)
        return pItem;
    for(li=this ; li->m_pNext!=NULL ; li=li->m_pNext);
    li->m_pNext=pItem;
    return this;
}

AListItem* AListItem::Remove(AListItem *pItem)
{
    AListItem *li,*prev;

    //treat remove(NULL) same as item not found in list
   if (pItem==NULL) 
   return this;

    if(pItem==this)
    {
        li = m_pNext;
        m_pNext = NULL;
        return li;
    }
    prev=NULL;
    for(li=this; li!=NULL && li!=pItem ; li=li->m_pNext)
        prev=li;
    if(li==NULL)     // item not found in list
        return this;

//  here it is guaranteed that prev is non-NULL since we checked for
//  that condition at the very beginning

    prev->SetNext(li->m_pNext);
    li->SetNext(NULL);

    // SetNext on pItem to NULL
    pItem->SetNext(NULL);

    return this;
}

AListItem* AListItem::GetPrev(AListItem *pItem) const
{
    const AListItem *li,*prev;

    prev=NULL;
    for(li=this ; li!=NULL && li!=pItem ; li=li->m_pNext)
        prev=li;
    return (AListItem*)prev;
}

AListItem * AListItem::GetItem(LONG index)

{
	AListItem *scan;
	for (scan = this; scan!=NULL && index; scan = scan->m_pNext) 
	{
		index--;
	}
	return (scan);
}

void AList::InsertBefore(AListItem *pItem,AListItem *pInsert)

{
	AListItem *prev = GetPrev(pItem);
	pInsert->SetNext(pItem);
	if (prev) prev->SetNext(pInsert);
	else m_pHead = pInsert;
}

void AList::AddTail(AListItem *pItem)
{
    if (m_pHead == NULL)
    {
        AddHead(pItem);
    }
    else
    {
        m_pHead = m_pHead->AddTail(pItem);
    }
}

void AList::Reverse()

{
    AList Temp;
    AListItem *pItem;
    while (pItem = RemoveHead())
    {
        Temp.AddHead(pItem);
    }
    m_pHead = Temp.GetHead();
}

BOOL AList::IsMember(AListItem *pItem)

{
    AListItem *pScan = GetHead();
    for (;pScan;pScan = pScan->GetNext())
    {
        if (pItem == pScan) return TRUE;
    }
    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\XboxSynth\shared\alist.h ===
// Copyright (c) 1998-1999 Microsoft Corporation
//
// alist.h
//
#ifndef __ALIST_H__
#define __ALIST_H__

#include <windows.h>

class AListItem
{
public:
    AListItem() { m_pNext=NULL; };
    AListItem *GetNext() const {return m_pNext;};
    void SetNext(AListItem *pNext) {m_pNext=pNext;};
    LONG GetCount() const;
    AListItem* Cat(AListItem* pItem);
    AListItem* AddTail(AListItem* pItem) {return Cat(pItem);};
    AListItem* Remove(AListItem* pItem);
    AListItem* GetPrev(AListItem *pItem) const;
    AListItem* GetItem(LONG index);

protected:
    AListItem *m_pNext;
};

class AList
{
public:
    AList() {m_pHead=NULL;};
    AListItem *GetHead() const { return m_pHead;};

    void RemoveAll() { m_pHead=NULL;};
    LONG GetCount() const {return m_pHead->GetCount();}; 
    AListItem *GetItem(LONG index) { return m_pHead->GetItem(index);}; 
    void InsertBefore(AListItem *pItem,AListItem *pInsert);
    void Cat(AListItem *pItem) {m_pHead=m_pHead->Cat(pItem);};
    void Cat(AList *pList)
        {
//            assert(pList!=NULL);
            if (pList)
            {
                m_pHead=m_pHead->Cat(pList->GetHead());
            }
        };
    void AddHead(AListItem *pItem)
        {
            if (pItem!=NULL)
            {
                pItem->SetNext(m_pHead);
                m_pHead=pItem;
            }
        };
    void AddTail(AListItem *pItem);// {m_pHead=m_pHead->AddTail(pItem);};
    void Remove(AListItem *pItem) 
        {
            if (pItem != NULL)
            {
                m_pHead=m_pHead->Remove(pItem);
            }
        };
    AListItem *GetPrev(AListItem *pItem) const {return m_pHead->GetPrev(pItem);};
    AListItem *GetTail() const {return GetPrev(NULL);};
    BOOL IsEmpty(void) const {return (m_pHead==NULL);};
    BOOL IsMember(AListItem *pItem);
    AListItem *RemoveHead(void)
        {
            AListItem *li;
            li = m_pHead;
            if(m_pHead)
            {
                m_pHead = m_pHead->GetNext();
                li->SetNext(NULL);
            }
            return li;
        }
    void Reverse();

protected:
    AListItem *m_pHead;
};

#endif // __ALIST_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\XboxSynth\shared\oledll.h ===
// Copyright (c) 1998-1999 Microsoft Corporation
//
//
//
#ifndef _OLEDLL_
#define _OLEDLL_

STDAPI
RegisterServer(HMODULE hModule,
               const CLSID &clsid,
               const TCHAR *szFriendlyName,
               const TCHAR *szVerIndProgID,
               const TCHAR *szProgID);

STDAPI
UnregisterServer(const CLSID &clsid,
                 const TCHAR *szFriendlyName,
                 const TCHAR *szVerIndProgID,
                 const TCHAR *szProgID);

BOOL
GetCLSIDRegValue(const CLSID &clsid,
				 const TCHAR *szKey,
				 LPVOID pValue,
				 LPDWORD pcbValue);
				 
HRESULT CLSIDToStr(const CLSID &clsid,
				   TCHAR *szStr,
				   int cbStr);

HRESULT StrToCLSID(TCHAR *szStr,
				   CLSID &clsid,
				   int cbStr);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\XboxSynth\shared\dmscriptautguids.h ===
// Copyright (c) 1999 Microsoft Corporation. All rights reserved.
//
// Declares the CLSIDs for creating the wrapper objects that implement the IDispatch
// interfaces for the various DirectMusic objects.  These CLSIDs are not public --
// they are only needed in the implementation of the DirectMusic objects.  A user of
// the IDispatch interface will get ahold of it by QueryInterface from the associated
// DirectMusic object.

#pragma once

DEFINE_GUID(CLSID_AutDirectMusicPerformance,		0xa861c6e2, 0xfcfc, 0x11d2, 0x8b, 0xc9, 0x0, 0x60, 0x8, 0x93, 0xb1, 0xb6); // {A861C6E2-FCFC-11d2-8BC9-00600893B1B6}
DEFINE_GUID(CLSID_AutDirectMusicSegment,			0x4062c116, 0x0270, 0x11d3, 0x8b, 0xcb, 0x0, 0x60, 0x8, 0x93, 0xb1, 0xb6); // {4062C116-0270-11d3-8BCB-00600893B1B6}
DEFINE_GUID(CLSID_AutDirectMusicSong,				0xa16f1761, 0xb6d8, 0x42eb, 0x8d, 0x57, 0x4a, 0x44, 0xfe, 0xdd, 0x3b, 0xd2);// {A16F1761-B6D8-42eb-8D57-4A44FEDD3BD2}
DEFINE_GUID(CLSID_AutDirectMusicSegmentState,		0xebf2320a, 0x2502, 0x11d3, 0x8b, 0xd1, 0x0, 0x60, 0x8, 0x93, 0xb1, 0xb6); // {EBF2320A-2502-11d3-8BD1-00600893B1B6}
DEFINE_GUID(CLSID_AutDirectMusicAudioPathConfig,	0x1cebde3e, 0x6b91, 0x484a, 0xaf, 0x48, 0x5e, 0x4f, 0x4e, 0xd6, 0xb1, 0xe1);// {1CEBDE3E-6B91-484a-AF48-5E4F4ED6B1E1}
DEFINE_GUID(CLSID_AutDirectMusicAudioPath,			0x2c5f9b72, 0x7148, 0x4d97, 0xbf, 0xc9, 0x68, 0xa0, 0xe0, 0x76, 0xbe, 0xbd);// {2C5F9B72-7148-4d97-BFC9-68A0E076BEBD}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\XboxSynth\shared\dmstrm.h ===
//
// dmstrm.h
// 
// Copyright (c) 1995-1998 Microsoft Corporation. All rights reserved.
//


#ifndef DMSTRM_H
#define DMSTRM_H

DEFINE_GUID(IID_IDMStream, 0x1894c260, 0xaa21, 0x11d1, 0x86, 0xbc, 0x0, 0xc0, 0x4f, 0xbf, 0x8f, 0xef);

DECLARE_INTERFACE_(IDMStream, IUnknown)
{
    // IUnknown
    STDMETHOD(QueryInterface)       (THIS_ REFIID, LPVOID FAR *) PURE;
    STDMETHOD_(ULONG,AddRef)        (THIS) PURE;
    STDMETHOD_(ULONG,Release)       (THIS) PURE;

    // IDMStream
	STDMETHOD(Init)					(THIS_ IStream* pStream) PURE;
    STDMETHOD(Descend)		(THIS_ LPMMCKINFO lpck, LPMMCKINFO lpckParent, UINT wFlags) PURE;
    STDMETHOD(Ascend)		(THIS_ LPMMCKINFO lpck, UINT wFlags) PURE;
    STDMETHOD(CreateChunk)	(THIS_ LPMMCKINFO lpck, UINT wFlags) PURE;
   	STDMETHOD(SetStream)			(THIS_ IStream* pIStream) PURE;
    STDMETHOD_(IStream*, GetStream)	(THIS) PURE;
};

STDAPI AllocDirectMusicStream(IStream* pIStream, IDMStream** ppIDMStream);

class CDirectMusicStream : public IDMStream
{
public:

    CDirectMusicStream();
    ~CDirectMusicStream();
 
	STDMETHODIMP Init(IStream* pStream);
	
	// IUnknown
    STDMETHODIMP QueryInterface(REFIID riid, LPVOID *ppvObj);
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();

    // IDMStream
    STDMETHODIMP Descend(LPMMCKINFO lpck, LPMMCKINFO lpckParent, UINT wFlags);
    STDMETHODIMP Ascend(LPMMCKINFO lpck, UINT wFlags);
    STDMETHODIMP CreateChunk(LPMMCKINFO lpck, UINT wFlags);

	STDMETHODIMP SetStream(IStream* pStream);
    STDMETHODIMP_(IStream*) GetStream();

private:
	long		m_cRef;         // object reference count
    IStream*    m_pStream;      // stream to operate on
};

// Macro to round up an odd size to RIFF 16 bit boundary.
#define RIFF_ALIGN(dwSize) (dwSize + (dwSize & 1))

typedef struct _RIFFIO
{
    FOURCC          ckid;           /* chunk ID */
    long            cksize;         /* chunk size */
    FOURCC          fccType;        /* form type or list type */
    long            lRead;          /* How much of this chunk has been read so far. */
    _RIFFIO *       pParent;        /* pointer to parent chunk */
    LARGE_INTEGER   liPosition;     /* Filled in by MarkPosition() when handing stream to another component. */
} RIFFIO;


class CRiffParser
{
public:
    CRiffParser(IStream *pStream);
    void        DebugOn() { m_fDebugOn = TRUE; } // Turns on tracing of parsing. Only available in debug builds.
    BOOL        NextChunk(HRESULT * pHr); // Does the work of LeaveChunk, MoreChunks, and EnterChunk in one call. 
    void        EnterList(RIFFIO *pChunk); // Descend into a new list.
    void        LeaveList();    // Pop out of the current list. 
    BOOL        MoreChunks();   // Returns true if there are more chunks to process in this LIST or RIFF.
    HRESULT     EnterChunk();   // Reads header of next chunk in this LIST or RIFF container.
    HRESULT     LeaveChunk();   // Move to the end of the current chunk in the LIST or RIFF.
    void        MarkPosition(); // Stores the absolute position of the start of the current chunk.
    HRESULT     SeekBack();     // Scan back to the beginning of the current chunk.
    HRESULT     SeekForward();  // Scan forward to the end of the current chunk.
    HRESULT     Read(void *pv,ULONG cb); // Reads data from stream. 
    HRESULT     Skip(ULONG ulBytes); // Seeks forward ulBytes.
    void        EnteringComponent() { m_fInComponent = true; } 
    BOOL        ComponentFailed() { return m_fComponentFailed; }
    IStream *   GetStream() { return m_pStream; }
private:
    BOOL        m_fDebugOn;     // Set true to turn tracing of parsing on. 
    BOOL        m_fFirstPass;   // Used by NextChunk to understand whether this is the first time in the list.
    IStream *   m_pStream;      // Stream to operate on. 
    RIFFIO *    m_pChunk;       // Current chunk that we are in. 
    RIFFIO *    m_pParent;      // Parent chunk of current chunk.
    long        m_lRead;        // How far we've read in the current chunk.
    BOOL        m_fComponentFailed; // Set true if a component failed to load, yet the file is okay.
    BOOL        m_fInComponent; // Set to true when inside a component's chunk.
};

#endif // #ifndef DMSTRM_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\XboxSynth\shared\dmusicp.h ===
//
// dmusicp.h
//
// Copyright (c) 2000 Microsoft Corporation. All rights reserved.
//
// Private interfaces

#ifndef _DMUSICP_DOT_H_
#define _DMUSICP_DOT_H_

#include <dmusicf.h>

// private guid for script track events
DEFINE_GUID(IID_CScriptTrackEvent, 0x8f42c9da, 0xd37a, 0x499c, 0x85, 0x82, 0x1a, 0x80, 0xeb, 0xf9, 0xb2, 0x3c);

// Stuff used in melody formulation that's currently either not implemented or hidden by Producer.

/* Used to get a playmode to be used for a melody (pParam points to a single byte) */
DEFINE_GUID(GUID_MelodyPlaymode, 0x288ea6ca, 0xaecc, 0x4327, 0x9f, 0x79, 0xfb, 0x46, 0x44, 0x37, 0x4a, 0x65);

#define DMUS_FRAGMENTF_ANTICIPATE      (0x1 << 3) /* Anticipate next chord */
#define DMUS_FRAGMENTF_INVERT          (0x1 << 4) /* Invert the fragment */
#define DMUS_FRAGMENTF_REVERSE         (0x1 << 5) /* Reverse the fragment */
#define DMUS_FRAGMENTF_SCALE           (0x1 << 6) /* Align MIDI values with scale intervals */
#define DMUS_FRAGMENTF_CHORD           (0x1 << 7) /* Align MIDI values with chord intervals */
#define DMUS_FRAGMENTF_USE_PLAYMODE    (0x1 << 8) /* Use playmode to compute MIDI values */

#define DMUS_CONNECTIONF_GHOST         0x1        /* Use ghost notes for transitions */

// flags used in ComposeSegmentFromTemplateEx
typedef enum enumDMUS_COMPOSE_TEMPLATEF_FLAGS
{
    DMUS_COMPOSE_TEMPLATEF_ACTIVITY    = 0x1, // Use activity level (dx7 default)
    DMUS_COMPOSE_TEMPLATEF_CLONE       = 0x2  // Clone a segment from the template (dx7 default)
} DMUS_COMPOSE_TEMPLATEF_FLAGS;

// Interfaces/methods removed from Direct Music Performance layer:

// IDirectMusicSegment8P
interface IDirectMusicSegment8P : IUnknown
{
	// IUnknown
	virtual HRESULT STDMETHODCALLTYPE QueryInterface(REFIID, LPVOID FAR *)=0; 
	virtual ULONG STDMETHODCALLTYPE AddRef()=0; 
	virtual ULONG STDMETHODCALLTYPE Release()=0; 

	// IDirectMusicSegment8P
	virtual HRESULT STDMETHODCALLTYPE GetObjectInPath(
		DWORD dwPChannel,    /* PChannel to search. */
		DWORD dwStage,       /* Which stage in the path. */
		DWORD dwBuffer,      /* Which buffer to address, if more than one. */
		REFGUID guidObject,  /* ClassID of object. */
		DWORD dwIndex,       /* Which object of that class. */
		REFGUID iidInterface,/* Requested COM interface. */
		void ** ppObject)=0; /* Pointer to interface. */
    virtual HRESULT STDMETHODCALLTYPE GetHeaderChunk(
        DWORD *pdwSize,      /* Size of passed header chunk. Also, returns size written. */
        DMUS_IO_SEGMENT_HEADER *pHeader)=0; /* Header chunk to fill. */
    virtual HRESULT STDMETHODCALLTYPE SetHeaderChunk(
        DWORD dwSize,        /* Size of passed header chunk. */
        DMUS_IO_SEGMENT_HEADER *pHeader)=0; /* Header chunk to fill. */
    virtual HRESULT STDMETHODCALLTYPE SetTrackPriority(
        REFGUID rguidTrackClassID,  /* ClassID of Track. */
        DWORD dwGroupBits,          /* Group bits. */
        DWORD dwIndex,              /* Nth track. */
        DWORD dwPriority) = 0;      /* Priority to set. */
    virtual HRESULT STDMETHODCALLTYPE SetAudioPathConfig(
        IUnknown *pAudioPathConfig) = 0; /* Audio path config, from file. */
};


// IDirectMusicComposer8P
interface IDirectMusicComposer8P : IUnknown
{
	// IUnknown
	virtual HRESULT STDMETHODCALLTYPE QueryInterface(REFIID, LPVOID FAR *)=0; 
	virtual ULONG STDMETHODCALLTYPE AddRef()=0; 
	virtual ULONG STDMETHODCALLTYPE Release()=0; 

	// IDirectMusicComposer8P
    // Use style to get embellishment lengths
	virtual HRESULT STDMETHODCALLTYPE ComposeTemplateFromShapeEx(
		WORD wNumMeasures,
		WORD wShape, 
		BOOL fIntro,
		BOOL fEnd,
		IDirectMusicStyle* pStyle, 
		IDirectMusicSegment** ppTemplate)=0;
    // New flags DWORD (discard activity level; compose in place)
    virtual HRESULT STDMETHODCALLTYPE ComposeSegmentFromTemplateEx(
        IDirectMusicStyle* pStyle, 
        IDirectMusicSegment* pTemplate, 
        DWORD dwFlags,
        DWORD dwActivity,
        IDirectMusicChordMap* pChordMap, 
        IDirectMusicSegment** ppSegment)=0;
};

//  IDirectMusicStyle8P
interface IDirectMusicStyle8P : IUnknown
{
	// IUnknown
	virtual HRESULT STDMETHODCALLTYPE QueryInterface(REFIID, LPVOID FAR *)=0; 
	virtual ULONG STDMETHODCALLTYPE AddRef()=0; 
	virtual ULONG STDMETHODCALLTYPE Release()=0; 

	//  IDirectMusicStyle8P
	virtual HRESULT STDMETHODCALLTYPE ComposeMelodyFromTemplate(
		IDirectMusicStyle* pStyle, 
		IDirectMusicSegment* pTemplate, 
        IDirectMusicSegment** ppSegment)=0;
};

// IDirectMusicLoader8P
interface IDirectMusicLoader8P : IUnknown
{
	// IUnknown
	virtual HRESULT STDMETHODCALLTYPE QueryInterface(REFIID, LPVOID FAR *)=0; 
	virtual ULONG STDMETHODCALLTYPE AddRef()=0; 
	virtual ULONG STDMETHODCALLTYPE Release()=0; 

	// IDirectMusicLoader8P
	virtual HRESULT STDMETHODCALLTYPE GetDynamicallyReferencedObject(
		IDirectMusicObject *pSourceObject,
		LPDMUS_OBJECTDESC pDesc,
		REFIID riid,
		LPVOID FAR *ppv)=0;
	virtual HRESULT STDMETHODCALLTYPE ReportDynamicallyReferencedObject(
		IDirectMusicObject *pSourceObject,
		IUnknown *pReferencedObject)=0;

	// These should probably never be exposed publicly.
	// Scripts hold a reference to the loader because they need to be able to inform it
	// when they set variables to reference DirectMusic objects the loader tracks for
	// garbage collection.  However, that would create a circular reference because the
	// loader also holds a reference to scripts in its cache.  Garbage collection can't break
	// a circular reference that the loader itself is involved in.  Instead we use these private
	// ref count methods.  When the app is no longer using the loader (public Release drops
	// to zero) then the loader can clear its cache.  This releases references to scripts
	// (and also to streams, which use the same technique), triggering them to do ReleaseP
	// and everything gets cleaned up.
	virtual ULONG STDMETHODCALLTYPE AddRefP() = 0;	// Private AddRef, for scripts.
	virtual ULONG STDMETHODCALLTYPE ReleaseP() = 0;	// Private Release, for scripts.
};

// IDirectMusicBandP
interface IDirectMusicBandP : IUnknown
{
	// IUnknown
	virtual HRESULT STDMETHODCALLTYPE QueryInterface(REFIID, LPVOID FAR *)=0; 
	virtual ULONG STDMETHODCALLTYPE AddRef()=0; 
	virtual ULONG STDMETHODCALLTYPE Release()=0; 

	// IDirectMusicBandP
	virtual HRESULT STDMETHODCALLTYPE DownloadEx(IUnknown *pAudioPath)=0; 
	virtual HRESULT STDMETHODCALLTYPE UnloadEx(IUnknown *pAudioPath)=0; 
};

// IDirectMusicObjectP
interface IDirectMusicObjectP : IUnknown
{
	// IUnknown
	virtual HRESULT STDMETHODCALLTYPE QueryInterface(REFIID, LPVOID FAR *)=0; 
	virtual ULONG STDMETHODCALLTYPE AddRef()=0; 
	virtual ULONG STDMETHODCALLTYPE Release()=0; 

	// IDirectMusicObjectP
	virtual void STDMETHODCALLTYPE Zombie()=0; 
};

// IDirectMusicPerformanceP
interface IDirectMusicPerformanceP : IUnknown
{
	// IUnknown
	virtual HRESULT STDMETHODCALLTYPE QueryInterface(REFIID, LPVOID FAR *)=0; 
	virtual ULONG STDMETHODCALLTYPE AddRef()=0; 
	virtual ULONG STDMETHODCALLTYPE Release()=0; 

	// IDirectMusicPerformanceP
    virtual HRESULT STDMETHODCALLTYPE GetPortAndFlags(DWORD dwPChannel,IDirectMusicPort **ppPort,DWORD * pdwFlags) = 0;
};

#define DM_PORTFLAGS_GM     1       /* Synth has GM set locally. */
#define DM_PORTFLAGS_GS     2       /* Synth has GS set locally. */
#define DM_PORTFLAGS_XG     4       /* Synth has XG set locally. */


// Private path stage to access the sink.
#define DMUS_PATH_SINK             0x5000      /* Access the DSound Sink interface. */

// GUIDs for new performance layer private interfaces
DEFINE_GUID(IID_IDirectMusicSegment8P, 0x4bd7fb35, 0x8253, 0x48e0, 0x90, 0x64, 0x8a, 0x20, 0x89, 0x82, 0x37, 0xcb);
DEFINE_GUID(IID_IDirectMusicComposer8P, 0xabaf70dc, 0xdfba, 0x4adf, 0xbf, 0xa9, 0x7b, 0x0, 0xe4, 0x19, 0xeb, 0xbb);
DEFINE_GUID(IID_IDirectMusicStyle8P, 0x2b7c5f39, 0x990a, 0x4fd7, 0x9b, 0x70, 0x1e, 0xa3, 0xde, 0x31, 0x55, 0xa5);
DEFINE_GUID(IID_IDirectMusicLoader8P, 0x3939facd, 0xf6ed, 0x4619, 0xbd, 0x16, 0x56, 0x60, 0x3f, 0x1, 0x51, 0xca);
DEFINE_GUID(IID_IDirectMusicBandP, 0xf2e00137, 0xa131, 0x4289, 0xaa, 0x6c, 0xa9, 0x60, 0x7d, 0x4, 0x85, 0xf5);
DEFINE_GUID(IID_IDirectMusicObjectP, 0x6a20c217, 0xeb3e, 0x40ec, 0x9f, 0x3a, 0x92, 0x5, 0x8, 0x70, 0x2b, 0x5e);
DEFINE_GUID(IID_IDirectMusicPerformanceP, 0xe583be58, 0xe93f, 0x4316, 0xbb, 0x6b, 0xcb, 0x2c, 0x71, 0x96, 0x40, 0x44);


/* DMUS_PMSGT_PRIVATE_TYPES fill the DMUS_PMSG's dwType member */
/* These start at 15000 in order to avoid conflicting with public DMUS_PMSGT_TYPES. */
typedef enum enumDMUS_PMSGT_PRIVATE_TYPES
{
    DMUS_PMSGT_SCRIPTTRACKERROR = 15000, /* Sent by the script track when an error occurs in the script. */
} DMUS_PMSGT_PRIVATE_TYPES;

/* DMUS_SCRIPT_TRACK_ERROR_PMSG */
/* These PMsgs are sent by the script track if there is a syntax error in a script it tries to connect to or
   if a routine it calls fails. */
typedef struct _DMUS_SCRIPT_TRACK_ERROR_PMSG
{
    /* begin DMUS_PMSG_PART */
    DMUS_PMSG_PART
    /* end DMUS_PMSG_PART */

    DMUS_SCRIPT_ERRORINFO ErrorInfo; /* The error that occured.  Same as structure returned by IDirectMusicScript's Init and CallRoutine members. */
} DMUS_SCRIPT_TRACK_ERROR_PMSG;

/* Track param type guids */

/* Use (call SetParam on the script track) to turn on PMsgs (DMUS_SCRIPT_TRACK_ERROR_PMSG) the script track sends if there
   is a syntax error in the script it tries to connect to or if one of the routines it calls fails. */
DEFINE_GUID(GUID_EnableScriptTrackError,0x1cc7e0bf, 0x981c, 0x4b9f, 0xbe, 0x17, 0xd5, 0x72, 0xfc, 0x5f, 0xa9, 0x33); // {1CC7E0BF-981C-4b9f-BE17-D572FC5FA933}

#endif          // _DMUSICP_DOT_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\XboxSynth\shared\dmstrm.cpp ===
//
// dmstrm.cpp
// 
// Copyright (c) 1995-2000 Microsoft Corporation
//

#include "debug.h"
#include "dmusicc.h"
#include "..\shared\dmstrm.h"
#include "..\shared\validate.h"

/////////////////////////////////////////////////////////////////////////////
// AllocDIrectMusicStream

STDAPI AllocDirectMusicStream(IStream* pIStream, IDMStream** ppIDMStream)
{
	if(pIStream == NULL || ppIDMStream == NULL)
	{
		return E_INVALIDARG;            
	}

	if((*ppIDMStream = (IDMStream*) new CDirectMusicStream()) == NULL)
    {
		return E_OUTOFMEMORY;
    }
	
	((CDirectMusicStream*)*ppIDMStream)->Init(pIStream);
    
	return S_OK;
}

//////////////////////////////////////////////////////////////////////
// CDirectMusicStream::CDirectMusicStream

CDirectMusicStream::CDirectMusicStream() :
m_cRef(1),
m_pStream(NULL)
{
}

//////////////////////////////////////////////////////////////////////
// CDirectMusicStream::~CDirectMusicStream
   
CDirectMusicStream::~CDirectMusicStream()
{
	if(m_pStream != NULL)
    {
		m_pStream->Release();
    }
}

//////////////////////////////////////////////////////////////////////
// CDirectMusicStream::Init
   
STDMETHODIMP CDirectMusicStream::Init(IStream* pStream)
{
    SetStream(pStream);
	
	return S_OK;
}

//////////////////////////////////////////////////////////////////////
// IUnknown

//////////////////////////////////////////////////////////////////////
// CDirectMusicStream::QueryInterface

STDMETHODIMP CDirectMusicStream::QueryInterface(const IID &iid, void **ppv)
{
	V_INAME(CDirectMusicStream::QueryInterface);
	V_PTRPTR_WRITE(ppv);
	V_REFGUID(iid);

	if(iid == IID_IUnknown || iid == IID_IDMStream)
	{
		*ppv = static_cast<IDMStream*>(this);
    } 
	else 
	{
		*ppv = NULL;
		return E_NOINTERFACE;
    }

    reinterpret_cast<IUnknown*>(this)->AddRef();
    
	return S_OK;
}

//////////////////////////////////////////////////////////////////////
// CDirectMusicStream::AddRef

STDMETHODIMP_(ULONG) CDirectMusicStream::AddRef()
{
	return InterlockedIncrement(&m_cRef);
}

//////////////////////////////////////////////////////////////////////
// CDirectMusicStream::Release

STDMETHODIMP_(ULONG) CDirectMusicStream::Release()
{
    if(!InterlockedDecrement(&m_cRef)) 
	{
		delete this;
		return 0;
    }

    return m_cRef;
}

//////////////////////////////////////////////////////////////////////
// CDirectMusicStream::SetStream

STDMETHODIMP CDirectMusicStream::SetStream(IStream* pStream)
{
    if(m_pStream != NULL)
    {
		m_pStream->Release();
    }

	m_pStream = pStream;
    
	if(m_pStream != NULL)
    {
		m_pStream->AddRef();
    }
    
	return S_OK;
}

//////////////////////////////////////////////////////////////////////
// CDirectMusicStream::GetStream

STDMETHODIMP_(IStream*) CDirectMusicStream::GetStream()
{
	if(m_pStream != NULL)
    {
		m_pStream->AddRef();
    }
    
	return m_pStream;
}

//////////////////////////////////////////////////////////////////////
// IDMStream

//////////////////////////////////////////////////////////////////////
// CDirectMusicStream::Descend

STDMETHODIMP CDirectMusicStream::Descend(LPMMCKINFO lpck, LPMMCKINFO lpckParent, UINT wFlags)
{
    assert(lpck);

	FOURCC ckidFind;           // Chunk ID to find (or NULL)
    FOURCC fccTypeFind;    // Form/list type to find (or NULL)

    // Figure out what chunk id and form/list type for which to search
    if(wFlags & MMIO_FINDCHUNK)
	{
		ckidFind = lpck->ckid;
		fccTypeFind = NULL;
	}
    else if(wFlags & MMIO_FINDRIFF)
    {
		ckidFind = FOURCC_RIFF;
		fccTypeFind = lpck->fccType;
    }
	else if(wFlags & MMIO_FINDLIST)
	{
		ckidFind = FOURCC_LIST;
		fccTypeFind = lpck->fccType;
	}
    else
    {
		ckidFind = fccTypeFind = NULL;
	}

    lpck->dwFlags = 0L;

    for(;;)
    {
		HRESULT hr;
		LARGE_INTEGER li;
		ULARGE_INTEGER uli;
		ULONG cbRead;

		// Read the chunk header
		hr = m_pStream->Read(lpck, 2 * sizeof(DWORD), &cbRead);

        if (FAILED(hr) || (cbRead != 2 * sizeof(DWORD)))
		{
            Trace(1,"Error: Unable to read file.\n");
			return DMUS_E_DESCEND_CHUNK_FAIL;
		}

		// Store the offset of the data part of the chunk
		li.QuadPart = 0;
		hr = m_pStream->Seek(li, STREAM_SEEK_CUR, &uli);

		if(FAILED(hr))
		{
            Trace(1,"Error: Unable to read file.\n");
			return DMUS_E_CANNOTSEEK;
		}
		else
		{
			lpck->dwDataOffset = uli.LowPart;
		}

		// See if the chunk is within the parent chunk (if given)
		if((lpckParent != NULL) &&
		   (lpck->dwDataOffset - 8L >=
		   lpckParent->dwDataOffset + lpckParent->cksize))
		{
            Trace(1,"Error: Unable to read file.\n");
			return DMUS_E_DESCEND_CHUNK_FAIL;
		}

		// If the chunk is a 'RIFF' or 'LIST' chunk, read the
		// form type or list type
		if((lpck->ckid == FOURCC_RIFF) || (lpck->ckid == FOURCC_LIST))
		{

			ULONG cbRead;

			hr = m_pStream->Read(&lpck->fccType, sizeof(DWORD), &cbRead);

			if(FAILED(hr) || (cbRead != sizeof(DWORD)))
			{
                Trace(1,"Error: Unable to read file.\n");
				return DMUS_E_DESCEND_CHUNK_FAIL;
			}
		}
		else
		{
			lpck->fccType = NULL;
		}

		// If this is the chunk we're looking for, stop looking
		if(((ckidFind == NULL) || (ckidFind == lpck->ckid)) &&
		   ((fccTypeFind == NULL) || (fccTypeFind == lpck->fccType)))
		{
			break;
		}

		// Ascend out of the chunk and try again
		HRESULT w = Ascend(lpck, 0);
		if(FAILED(w))
		{
			return w;
		}
	}

    return S_OK;
}


//////////////////////////////////////////////////////////////////////
// CDirectMusicStream::Ascend

STDMETHODIMP CDirectMusicStream::Ascend(LPMMCKINFO lpck, UINT /*wFlags*/)
{
	assert(lpck);

    HRESULT hr;
	LARGE_INTEGER li;
	ULARGE_INTEGER uli;
	
	if (lpck->dwFlags & MMIO_DIRTY)
    {
		// <lpck> refers to a chunk created by CreateChunk();
		// check that the chunk size that was written when
		// CreateChunk() was called is the real chunk size;
		// if not, fix it
		LONG lOffset;           // current offset in file
		LONG lActualSize;   // actual size of chunk data

		li.QuadPart = 0;
		hr = m_pStream->Seek(li, STREAM_SEEK_CUR, &uli);

		if(FAILED(hr))
		{
            Trace(1,"Error: Unable to write file.\n");
			return DMUS_E_CANNOTSEEK;
		}
		else
		{
			lOffset = uli.LowPart;
		}
		
		if((lActualSize = lOffset - lpck->dwDataOffset) < 0)
		{
            Trace(1,"Error: Unable to write file.\n");
			return DMUS_E_CANNOTWRITE;
		}

		if(LOWORD(lActualSize) & 1)
		{
			ULONG cbWritten;

			// Chunk size is odd -- write a null pad byte
			hr = m_pStream->Write("\0", 1, &cbWritten); 
			
			if(FAILED(hr) || cbWritten != 1)
			{
                Trace(1,"Error: Unable to write file.\n");
				return DMUS_E_CANNOTWRITE;
			}
		
		}
	
		if(lpck->cksize == (DWORD)lActualSize)
		{
			return S_OK;
		}

		// Fix the chunk header
		lpck->cksize = lActualSize;

		li.QuadPart = lpck->dwDataOffset - sizeof(DWORD);
		hr = m_pStream->Seek(li, STREAM_SEEK_SET, &uli);

		if(FAILED(hr))
		{
            Trace(1,"Error: Unable to write file.\n");
			return DMUS_E_CANNOTSEEK;
		}

		ULONG cbWritten;

		hr = m_pStream->Write(&lpck->cksize, sizeof(DWORD), &cbWritten); 
		
		if(FAILED(hr) || cbWritten != sizeof(DWORD))
		{
            Trace(1,"Error: Unable to write file.\n");
			return DMUS_E_CANNOTWRITE;
		}
    }

	// Seek to the end of the chunk, past the null pad byte
	// (which is only there if chunk size is odd)
	li.QuadPart = lpck->dwDataOffset + lpck->cksize + (lpck->cksize & 1L);
	hr = m_pStream->Seek(li, STREAM_SEEK_SET, &uli);

	if(FAILED(hr))
	{
        Trace(1,"Error: Unable to write file.\n");
		return DMUS_E_CANNOTSEEK;
	}

	return S_OK;
}

//////////////////////////////////////////////////////////////////////
// CDirectMusicStream::CreateChunk

STDMETHODIMP CDirectMusicStream::CreateChunk(LPMMCKINFO lpck, UINT wFlags)
{
	assert(lpck);

    UINT iBytes;    // Bytes to write
    LONG lOffset;   // Current offset in file

	// Store the offset of the data part of the chunk
	LARGE_INTEGER li;
	ULARGE_INTEGER uli;

	li.QuadPart = 0;
	HRESULT hr = m_pStream->Seek(li, STREAM_SEEK_CUR, &uli);

	if(FAILED(hr))
	{
        Trace(1,"Error: Unable to write file.\n");
		return DMUS_E_CANNOTSEEK;
	}
    else
	{
		lOffset = uli.LowPart;
	}
    
    lpck->dwDataOffset = lOffset + 2 * sizeof(DWORD);

    // figure out if a form/list type needs to be written
    if(wFlags & MMIO_CREATERIFF)
	{
		lpck->ckid = FOURCC_RIFF, iBytes = 3 * sizeof(DWORD);
    }
	else if(wFlags & MMIO_CREATELIST)
	{
		lpck->ckid = FOURCC_LIST, iBytes = 3 * sizeof(DWORD);
	}
    else
    {
		iBytes = 2 * sizeof(DWORD);
	}

    // Write the chunk header
	ULONG cbWritten;

	hr = m_pStream->Write(lpck, iBytes, &cbWritten); 
		
	if(FAILED(hr) || cbWritten != iBytes)
	{
        Trace(1,"Error: Unable to write file.\n");
		return DMUS_E_CANNOTWRITE;
	}

	lpck->dwFlags = MMIO_DIRTY;

    return S_OK;
}

CRiffParser::CRiffParser(IStream *pStream)

{
    assert(pStream);
    m_fDebugOn = FALSE;
    m_pStream = pStream; 
    m_pParent = NULL;
    m_pChunk = NULL;
    m_lRead = 0;
    m_fFirstPass = TRUE;
    m_fComponentFailed = FALSE;
    m_fInComponent = FALSE;
}

void CRiffParser::EnterList(RIFFIO *pChunk)

{
    assert (pChunk);
    pChunk->lRead = 0;
    pChunk->pParent = m_pChunk; // Previous chunk (could be NULL.)
    m_pParent = m_pChunk;
    m_pChunk = pChunk;
    m_fFirstPass = TRUE;
}

void CRiffParser::LeaveList()

{
    assert (m_pChunk);
    if (m_pChunk)
    {
        m_pChunk = m_pChunk->pParent;
        if (m_pChunk)
        {
            m_pParent = m_pChunk->pParent;
        }
    }
}

BOOL CRiffParser::NextChunk(HRESULT * pHr)

{
    BOOL fMore = FALSE;
    if (SUCCEEDED(*pHr))
    {
        // If this is the first time we've entered this list, there is no previous chunk.
        if (m_fFirstPass)
        {
            // Clear the flag.
            m_fFirstPass = FALSE;
        }
        else
        {
            // Clean up the previous pass.
            *pHr = LeaveChunk();
        }
        // Find out if there are more chunks to read.
        fMore = MoreChunks();
        // If so, and we don't have any failure, go ahead and read the next chunk header.
        if (fMore && SUCCEEDED(*pHr))
        {
            *pHr = EnterChunk();
        }
    }
    else
    {
#ifdef DBG
        char szName[5];
        if (m_fDebugOn)
        {
            szName[4] = 0;
            strncpy(szName,(char *)&m_pChunk->ckid,4);
            Trace(0,"Error parsing %s, Read %ld of %ld\n",szName,m_pChunk->lRead,RIFF_ALIGN(m_pChunk->cksize));
        }
#endif
        // If we were in a component, it's okay to fail. Mark that fact by setting
        // m_fComponentFailed then properly pull out of the chunk so we can
        // continue reading.
        if (m_fInComponent) 
        {
            m_fComponentFailed = TRUE;
            // We don't need to check for first pass, because we must have gotten
            // that far. Instead, we just clean up from the failed chunk.
            // Note that this sets the hresult to S_OK, which is what we want.
            // Later, the caller needs to call ComponentFailed() to find out if
            // this error occured.
            *pHr = LeaveChunk();
        }
        else
        {
            // Clean up but leave the error code.
            LeaveChunk();
        }
    }
    return fMore && SUCCEEDED(*pHr);
}

BOOL CRiffParser::MoreChunks()

{
    assert(m_pChunk);
    if (m_pChunk)
    {
        if (m_pParent)
        {
            // Return TRUE if there's enough room for another chunk.
            return (m_pParent->lRead < (m_pParent->cksize - 8));
        }
        else
        {
            // This must be a top level chunk, in which case there would only be one to read.
            return (m_pChunk->lRead == 0);
        }
    }
    // This should never happen unless CRiffParser is used incorrectly, in which 
    // case the assert will help debug. But, in the interest of making Prefix happy...
    return false;
}

HRESULT CRiffParser::EnterChunk()

{
    assert(m_pChunk);
    if (m_pChunk)
    {
        // Read the chunk header
	    HRESULT hr = m_pStream->Read(m_pChunk, 2 * sizeof(DWORD), NULL);
        if (SUCCEEDED(hr))
        {
#ifdef DBG
            char szName[5];
            if (m_fDebugOn)
            {
                szName[4] = 0;
                strncpy(szName,(char *)&m_pChunk->ckid,4);
                ULARGE_INTEGER ul;
                LARGE_INTEGER li;
                li.QuadPart = 0;
                HRESULT hr = m_pStream->Seek(li, STREAM_SEEK_CUR, &ul);

                Trace(0,"Entering %s, Length %ld, File position is %ld",szName,m_pChunk->cksize,(long)ul.QuadPart);
            }
#endif
            // Clear bytes read field.
            m_pChunk->lRead = 0;
            // Check to see if this is a container (LIST or RIFF.)
            if((m_pChunk->ckid == FOURCC_RIFF) || (m_pChunk->ckid == FOURCC_LIST))
		    {
			    hr = m_pStream->Read(&m_pChunk->fccType, sizeof(DWORD), NULL);
                if (SUCCEEDED(hr))
                {
                    m_pChunk->lRead += sizeof(DWORD);
#ifdef DBG
                    if (m_fDebugOn)
                    {
                        strncpy(szName,(char *)&m_pChunk->fccType,4);
                        Trace(0," Type %s",szName);
                    }
#endif
                }
                else
                {
                    Trace(1,"Error: Unable to read file.\n");
                }
		    }
#ifdef DBG
            if (m_fDebugOn) Trace(0,"\n");
#endif
        }
        else
        {
            Trace(1,"Error: Unable to read file.\n");
        }
        return hr;
    }
    // This should never happen unless CRiffParser is used incorrectly, in which 
    // case the assert will help debug. But, in the interest of making Prefix happy...
    return E_FAIL;
}

HRESULT CRiffParser::LeaveChunk()

{
    HRESULT hr = S_OK;
    assert(m_pChunk);
    if (m_pChunk)
    {
        m_fInComponent = false;
        // Get the rounded up size of the chunk.
        long lSize = RIFF_ALIGN(m_pChunk->cksize);
        // Increment the parent's count of bytes read so far.
        if (m_pParent)
        {
            m_pParent->lRead += lSize + (2 * sizeof(DWORD));
            if (m_pParent->lRead > RIFF_ALIGN(m_pParent->cksize))
            {
                Trace(1,"Error: Unable to read file.\n");
                hr = DMUS_E_DESCEND_CHUNK_FAIL; // Goofy error name, but need to be consistent with previous versions.
            }
        }
#ifdef DBG
        char szName[5];
        if (m_fDebugOn)
        {
            szName[4] = 0;
            strncpy(szName,(char *)&m_pChunk->ckid,4);
            ULARGE_INTEGER ul;
            LARGE_INTEGER li;
            li.QuadPart = 0;
            HRESULT hr = m_pStream->Seek(li, STREAM_SEEK_CUR, &ul);

            Trace(0,"Leaving %s, Read %ld of %ld, File Position is %ld\n",szName,m_pChunk->lRead,lSize,(long)ul.QuadPart);
        }
#endif
        // If we haven't actually read this entire chunk, seek to the end of it.
        if (m_pChunk->lRead < lSize)
        {
            LARGE_INTEGER li;
            li.QuadPart = lSize - m_pChunk->lRead;
            hr = m_pStream->Seek(li,STREAM_SEEK_CUR,NULL);
            // There's a chance it could fail because we are at the end of file with an odd length chunk.
            if (FAILED(hr))
            {
                // If there's a parent, see if this is the last chunk.
                if (m_pParent)
                {
                    if (m_pParent->cksize >= (m_pParent->lRead - 1))
                    {
                        hr = S_OK;
                    }
                }
                // Else, see if we are an odd length.
                else if (m_pChunk->cksize & 1)
                {
                    hr = S_OK;
                }
            }
        }
        return hr;
    }
    // This should never happen unless CRiffParser is used incorrectly, in which 
    // case the assert will help debug. But, in the interest of making Prefix happy...
    return E_FAIL;
}

HRESULT CRiffParser::Read(void *pv,ULONG cb)

{
    assert(m_pChunk);
    if (m_pChunk)
    {
        // Make sure we don't read beyond the end of the chunk.
        if (((long)cb + m_pChunk->lRead) > m_pChunk->cksize)
        {
            cb -= (cb - (m_pChunk->cksize - m_pChunk->lRead));
        }
        HRESULT hr = m_pStream->Read(pv,cb,NULL);
        if (SUCCEEDED(hr))
        {
            m_pChunk->lRead += cb;
        }
        else
        {
            Trace(1,"Error: Unable to read %ld bytes from file.\n",cb);
        }
        return hr;
    }
    // This should never happen unless CRiffParser is used incorrectly, in which 
    // case the assert will help debug. But, in the interest of making Prefix happy...
    return E_FAIL;
}

HRESULT CRiffParser::Skip(ULONG ulBytes)

{
    assert(m_pChunk);
    if (m_pChunk)
    {
        // Make sure we don't scan beyond the end of the chunk.
        if (((long)ulBytes + m_pChunk->lRead) > m_pChunk->cksize)
        {
            ulBytes -= (ulBytes - (m_pChunk->cksize - m_pChunk->lRead));
        }
        LARGE_INTEGER li;
        li.HighPart = 0;
		li.LowPart = ulBytes;
        HRESULT hr = m_pStream->Seek( li, STREAM_SEEK_CUR, NULL );
        if (SUCCEEDED(hr))
        {
            m_pChunk->lRead += ulBytes;
        }
        return hr;
    }
    // This should never happen unless CRiffParser is used incorrectly, in which 
    // case the assert will help debug. But, in the interest of making Prefix happy...
    return E_FAIL;
}


void CRiffParser::MarkPosition()

{
    assert(m_pChunk);
    if (m_pChunk)
    {
        LARGE_INTEGER li;
        ULARGE_INTEGER ul;
        li.HighPart = 0;
        li.LowPart = 0;
        m_pStream->Seek(li, STREAM_SEEK_CUR, &ul);
        m_pChunk->liPosition.QuadPart = (LONGLONG) ul.QuadPart;
    }
}

HRESULT CRiffParser::SeekBack()

{
    assert(m_pChunk);
    if (m_pChunk)
    {
        // Move back to the start of the current chunk. Also, store the
        // absolute position because that will be useful later when we need to seek to the
        // end of this chunk.
        ULARGE_INTEGER ul;
        LARGE_INTEGER li;
        li.QuadPart = 0;
        li.QuadPart -= (m_pChunk->lRead + (2 * sizeof(DWORD))); 
        HRESULT hr = m_pStream->Seek(li, STREAM_SEEK_CUR, &ul);
        // Now, save the absolute position for the end of this chunk.
        m_pChunk->liPosition.QuadPart = ul.QuadPart + 
            RIFF_ALIGN(m_pChunk->cksize) + (2 * sizeof(DWORD));
        m_pChunk->lRead = 0;
        return hr;
    }
    return E_FAIL;
}

HRESULT CRiffParser::SeekForward()

{
    assert(m_pChunk);
    if (m_pChunk)
    {
        m_pChunk->lRead = RIFF_ALIGN(m_pChunk->cksize);
        return m_pStream->Seek(m_pChunk->liPosition, STREAM_SEEK_SET, NULL);
    }
    return E_FAIL;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\XboxSynth\shared\tlist.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (c) 1998-1999 Microsoft Corporation
//
//  File:       tlist.cpp
//
//--------------------------------------------------------------------------

//
// tlist.cpp
//

//#include "stdafx.h"
#include "tlist.h"

template <class T>
TListItem<T>::~TListItem()
{
	//if (m_pNext != NULL) { delete m_pNext; }
	// IMPORTANT: user of the list is required to delete content first!
	//ZeroMemory(&m_Tinfo, sizeof(T));
}

template <class T>
void TListItem<T>::Delete(TListItem<T>* pFirst)
{
	TListItem<T>* pScan = pFirst;
	TListItem<T>* pNext = NULL;
	while (pScan)
	{
		pNext = pScan->m_pNext;
		delete pScan;
		pScan = pNext;
	}
}

template <class T>
LONG TListItem<T>::GetCount(void) const
{
    LONG l;
    const TListItem<T> *li;

    for(l=0,li=this; li!=NULL ; li=li->m_pNext,++l);
    return l;
}

template <class T>
TListItem<T>* TListItem<T>::Cat(TListItem<T> *pItem)
{
    TListItem<T> *li;

    if(this==NULL)
        return pItem;
    for(li=this ; li->m_pNext!=NULL ; li=li->m_pNext);
    li->m_pNext=pItem;
    return this;
}

template <class T>
TListItem<T>* TListItem<T>::Remove(TListItem<T> *pItem)
{
    TListItem<T> *li,*prev;

    if(pItem==this)
        return m_pNext;
    prev=NULL;
    for(li=this; li!=NULL && li!=pItem ; li=li->m_pNext)
        prev=li;
    if(li==NULL)     // item not found in list
        return this;

//  here it is guaranteed that prev is non-NULL since we checked for
//  that condition at the very beginning

    prev->SetNext(li->m_pNext);
    li->SetNext(NULL);
    return this;
}

template <class T>
TListItem<T>* TListItem<T>::GetPrev(TListItem<T> *pItem) const
{
    const TListItem<T> *li,*prev;

    prev=NULL;
    for(li=this ; li!=NULL && li!=pItem ; li=li->m_pNext)
        prev=li;
    return (TListItem<T>*)prev;
}

template <class T>
TListItem<T> * TListItem<T>::GetItem(LONG index)

{
	TListItem<T> *scan;
	for (scan = this; scan!=NULL && index; scan = scan->m_pNext) 
	{
		index--;
	}
	return (scan);
}

template <class T>
TListItem<T>* TListItem<T>::MergeSort(BOOL (* fcnCompare) (T&, T&))
{
	if (m_pNext != NULL)
	{
		TListItem<T> *pList1, *pList2;
		Divide(pList1, pList2);
		return pList1->MergeSort(fcnCompare)->Merge(pList2->MergeSort(fcnCompare), fcnCompare);
	}
	return this;
}

template <class T>
void TListItem<T>::Divide(TListItem<T>*& pHead1, TListItem<T>*& pHead2)
{
	TListItem<T> *pCurrent = this, *pTail1 = NULL, *pTail2 = NULL;
	do
	{
		pHead1 = pCurrent;
		pCurrent = pCurrent->m_pNext;
		pHead1->m_pNext = pTail1;
		pTail1 = pHead1;
		if (pCurrent != NULL)
		{
			pHead2 = pCurrent;
			pCurrent = pCurrent->m_pNext;
			pHead2->m_pNext = pTail2;
			pTail2 = pHead2;
		}
	} while (pCurrent != NULL);
}

template <class T>
TListItem<T>* TListItem<T>::Merge(TListItem<T>* pOtherList, BOOL (* fcnCompare) (T&, T&))
{
	if (!pOtherList) return this;
	TListItem<T>
		*pThisList = this, *pResultHead = NULL, *pResultTail = NULL, *pMergeItem = NULL;
	while (pThisList && pOtherList)
	{
		if ( fcnCompare(pThisList->m_Tinfo, pOtherList->m_Tinfo) )
		{
			pMergeItem = pThisList;
			pThisList = pThisList->GetNext();
		}
		else
		{
			pMergeItem = pOtherList;
			pOtherList = pOtherList->GetNext();
		}
		pMergeItem->SetNext(NULL);
		if (!pResultTail)
		{
			pResultHead = pResultTail = pMergeItem;
		}
		else
		{
			pResultTail->SetNext(pMergeItem);
			pResultTail = pMergeItem;
		}
	}
	if (pThisList) pResultTail->SetNext(pThisList);
	else pResultTail->SetNext(pOtherList);
	return pResultHead;
}

template <class T>
void TList<T>::InsertBefore(TListItem<T> *pItem,TListItem<T> *pInsert)

{
	TListItem<T> *prev = GetPrev(pItem);
	pInsert->SetNext(pItem);
	if (prev) prev->SetNext(pInsert);
	else m_pHead = pInsert;
}

template <class T>
void TList<T>::AddTail(TListItem<T> *pItem) 

{
	m_pHead = m_pHead->AddTail(pItem);
}

template <class T>
void TList<T>::MergeSort(BOOL (* fcnCompare) (T&, T&))
{
	if (m_pHead != NULL && m_pHead->GetNext() != NULL)
		m_pHead = m_pHead->MergeSort(fcnCompare);
}

template <class T>
void TList<T>::Reverse(void)
{
	if( m_pHead )
	{
		TListItem<T>* pNewHead = m_pHead;
		TListItem<T>* pNext = m_pHead->GetNext();
		pNewHead->SetNext(NULL);
		for( m_pHead = pNext; m_pHead; m_pHead = pNext )
		{
			pNext = m_pHead->GetNext();
			m_pHead->SetNext(pNewHead);
			pNewHead = m_pHead;
		}
		m_pHead = pNewHead;
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\XboxSynth\shared\dmusiccp.h ===
//
// dmusiccp.h
//
// Copyright (c) 2000 Microsoft Corporation. All rights reserved.
//
// Private interfaces

#ifndef _DMUSICCP_DOT_H_
#define _DMUSICCP_DOT_H_

#include <dsoundp.h>  // For IDirectSoundWave

// Interfaces/methods removed from Direct Music Core layer:

// IDirectMusicVoiceP
interface IDirectMusicVoiceP : IUnknown
{
	// IUnknown
	virtual HRESULT STDMETHODCALLTYPE QueryInterface(REFIID, LPVOID FAR *)=0; 
	virtual ULONG STDMETHODCALLTYPE AddRef()=0; 
	virtual ULONG STDMETHODCALLTYPE Release()=0; 

	// IDirectMusicVoiceP
	virtual HRESULT STDMETHODCALLTYPE Play(
         REFERENCE_TIME rtStart,                // Time to play
         LONG prPitch,                          // Initial pitch
         LONG vrVolume                          // Initial volume
        )=0;
    
	virtual HRESULT STDMETHODCALLTYPE Stop(
          REFERENCE_TIME rtStop                 // When to stop
        )=0;
};


// IDirectSoundDownloadedWaveP
interface IDirectSoundDownloadedWaveP : IUnknown
{
	// IUnknown
	virtual HRESULT STDMETHODCALLTYPE QueryInterface(REFIID, LPVOID FAR *)=0; 
	virtual ULONG STDMETHODCALLTYPE AddRef()=0; 
	virtual ULONG STDMETHODCALLTYPE Release()=0; 

	// IDirectSoundDownloadedWaveP
};

// IDirectMusicPortP
interface IDirectMusicPortP : IUnknown
{
	// IUnknown
	virtual HRESULT STDMETHODCALLTYPE QueryInterface(REFIID, LPVOID FAR *)=0; 
	virtual ULONG STDMETHODCALLTYPE AddRef()=0; 
	virtual ULONG STDMETHODCALLTYPE Release()=0; 

	// IDirectMusicPortP
	virtual HRESULT STDMETHODCALLTYPE DownloadWave(
		IDirectSoundWave *pWave,                // Wave object
        IDirectSoundDownloadedWaveP **ppWave,   // Returned downloaded wave
        REFERENCE_TIME rtStartHint = 0          // Where we're likely to start
        )=0;
        
	virtual HRESULT STDMETHODCALLTYPE UnloadWave(
		IDirectSoundDownloadedWaveP *pWave      // Wave object
        )=0;
            
	virtual HRESULT STDMETHODCALLTYPE AllocVoice(
         IDirectSoundDownloadedWaveP *pWave,    // Wave to play on this voice
         DWORD dwChannel,                       // Channel and channel group
         DWORD dwChannelGroup,                  //  this voice will play on
         REFERENCE_TIME rtStart,                // Start position (stream only)
         SAMPLE_TIME stLoopStart,               // Loop start (one-shot only)
         SAMPLE_TIME stLoopEnd,                 // Loop end (one-shot only)
         IDirectMusicVoiceP **ppVoice           // Returned voice
        )=0;
        
	virtual HRESULT STDMETHODCALLTYPE AssignChannelToBuses(
		DWORD dwChannelGroup,                   // Channel group and
		DWORD dwChannel,                        // channel to assign
		LPDWORD pdwBuses,                       // Array of bus id's to assign
		DWORD cBusCount                         // Count of bus id's           
        )=0;
        
	virtual HRESULT STDMETHODCALLTYPE SetSink(
		IDirectSoundConnect *pSinkConnect       // From IDirectSoundPrivate::AllocSink
        )=0;
        
 	virtual HRESULT STDMETHODCALLTYPE GetSink(
		IDirectSoundConnect **ppSinkConnect     // The sink in use 
        )=0;
};

// GUIDs for new core layer private interfaces
DEFINE_GUID(IID_IDirectMusicVoiceP, 0x827ae928, 0xe44, 0x420d, 0x95, 0x24, 0x56, 0xf4, 0x93, 0x57, 0x8, 0xa6);
DEFINE_GUID(IID_IDirectSoundDownloadedWaveP, 0x3b527b6e, 0x5577, 0x4060, 0xb9, 0x6, 0xcd, 0x34, 0xa, 0x46, 0x71, 0x27);
DEFINE_GUID(IID_IDirectMusicPortP, 0x7048bcd8, 0x43fd, 0x4ca5, 0x93, 0x11, 0xf3, 0x24, 0x8f, 0xa, 0x25, 0x22);

// Class ID for synth sink. We pulled this from public headers since apps should never cocreate this.
DEFINE_GUID(CLSID_DirectMusicSynthSink,0xaec17ce3, 0xa514, 0x11d1, 0xaf, 0xa6, 0x0, 0xaa, 0x0, 0x24, 0xd8, 0xb6);


#endif          // _DMUSICCP_DOT_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\XboxSynth\shared\miscutil.h ===
// Copyright (c) 1999 Microsoft Corporation. All rights reserved.
//
// Misc tiny helper functions.
//

#pragma once

// Releases a COM pointer and then sets it to NULL.  No effect if pointer already was NULL.
template<class T>
void SafeRelease(T *&t) { if (t) t->Release(); t = NULL; }

// Returns the number of elements in an array determined at compile time.
// Note: Only works for variables actually declared as arrays.  Don't try this with a pointer to an array.  There's no way to determine the size at that point.
#define ARRAY_SIZE(array) (sizeof(array) / sizeof(*(array)))

// Zeros memory of struct pointed to.
// Note: This is statically typed.  Don't use it with a pointer to void, pointer to an array, or a pointer to a base class because the size will be too small.
template<class T> void Zero(T *pT) { ZeroMemory(pT, sizeof(*pT)); }

// Zeros memory of the struct pointed to and sets its dwSize field.
template<class T> void ZeroAndSize(T *pT) { Zero(pT); pT->dwSize = sizeof(*pT); }

// Copies one dwSize struct to another dwSize struct without reading/writing beyond either struct
template<class T> void CopySizedStruct(T *ptDest, const T *ptSrc)
{
	assert(ptDest && ptSrc);
	DWORD dwDestSize = ptDest->dwSize;
	memcpy(ptDest, ptSrc, std::_cpp_min(ptDest->dwSize, ptSrc->dwSize));
	ptDest->dwSize = dwDestSize;
}

// Copy pwszSource to pwszDest where pwszDest is a buffer of size uiBufferSize.
// Returns S_OK if successful or DMUS_S_STRING_TRUNCATED if the string had to be truncated.
// Faster then wcsncpy for short strings because the entire buffer isn't padded with nulls.
inline HRESULT wcsTruncatedCopy(WCHAR *pwszDest, const WCHAR *pwszSource, UINT uiBufferSize)
{
    for (UINT i = 0; i < uiBufferSize; ++i)
    {
        if (!(pwszDest[i] = pwszSource[i])) // assign and check for null
            return S_OK; // the whole string copied
    }

    // string needs to be truncated
    pwszDest[uiBufferSize - 1] = L'\0';
    return DMUS_S_STRING_TRUNCATED;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\XboxSynth\shared\oledll.cpp ===
// Copyright (c) 1998-1999 Microsoft Corporation
// oledll.cpp
//
// Handle standard stuff for OLE server DLL
//
#include <objbase.h>
#include <iostream.h>

#include "oledll.h"

#ifdef UNICODE
#ifndef UNDER_CE
#error DirectMusic Win NT/9x must be compiled without UNICODE
#endif
#endif

static const TCHAR g_szCLSID[]           = TEXT("CLSID");
static const TCHAR g_szCLSIDSlash[]      = TEXT("CLSID\\");
static const TCHAR g_szInProc32[]        = TEXT("InProcServer32");
static const TCHAR g_szProgIDKey[]       = TEXT("ProgID");
static const TCHAR g_szVerIndProgIDKey[] = TEXT("VersionIndependentProgID");
static const TCHAR g_szCurVer[]          = TEXT("CurVer"); 
static const TCHAR g_szThreadingModel[]	= TEXT("ThreadingModel");
static const TCHAR g_szApartment[]		= TEXT("Apartment");

static const int CLSID_STRING_SIZE = 39;

static LONG RegSetDefValue(LPCTSTR pstrKey, LPCTSTR pstrSubkey, LPCTSTR pstrValueName, LPCTSTR pstrValue);
static void RegRemoveSubtree(HKEY hk, LPCTSTR pstrChild);

STDAPI
RegisterServer(HMODULE hModule,
               const CLSID &clsid,
               const TCHAR *szFriendlyName,
               const TCHAR *szVerIndProgID,
               const TCHAR *szProgID)
{
    TCHAR szCLSID[CLSID_STRING_SIZE];
    HRESULT hr;
    LONG lr;

    hr = CLSIDToStr(clsid, szCLSID, sizeof(szCLSID));
    if (!SUCCEEDED(hr)) {
        return hr;
    }

    TCHAR szClsKey[256];
    lstrcpy(szClsKey, g_szCLSIDSlash);
    lstrcat(szClsKey, szCLSID);

    TCHAR szModule[512];
    lr = ::GetModuleFileName(hModule, szModule, sizeof(szModule));

    lr = 0;

    lr |= RegSetDefValue(szClsKey, NULL, NULL, szFriendlyName);
    lr |= RegSetDefValue(szClsKey, g_szInProc32, NULL, szModule);
	lr |= RegSetDefValue(szClsKey, g_szInProc32, g_szThreadingModel, g_szApartment);
    lr |= RegSetDefValue(szClsKey, g_szProgIDKey, NULL, szProgID);
    lr |= RegSetDefValue(szClsKey, g_szVerIndProgIDKey, NULL, szVerIndProgID);

    lr |= RegSetDefValue(szVerIndProgID, NULL, NULL, szFriendlyName);
    lr |= RegSetDefValue(szVerIndProgID, g_szCLSID, NULL, szCLSID);
    lr |= RegSetDefValue(szVerIndProgID, g_szCurVer, NULL, szProgID);
    
	lr |= RegSetDefValue(szProgID, NULL, NULL, szFriendlyName);
    lr |= RegSetDefValue(szProgID, g_szCLSID, NULL, szCLSID);

#if 0 
    if (lr) {
        UnregisterServer(clsid,
                         szFriendlyName,
                         szVerIndProgID,
                         szProgID);
        // ???
        //
        return S_OK;
    }
#endif

    return S_OK;
}

STDAPI
UnregisterServer(const CLSID &clsid,
                 const TCHAR *szFriendlyName,
                 const TCHAR *szVerIndProgID,
                 const TCHAR *szProgID)
{
    TCHAR szCLSID[CLSID_STRING_SIZE];
    HRESULT hr;

    hr = CLSIDToStr(clsid, szCLSID, sizeof(szCLSID));
    if (!SUCCEEDED(hr)) {
        return hr;
    }

    TCHAR szClsKey[256];
    lstrcpy(szClsKey, g_szCLSIDSlash);
    lstrcat(szClsKey, szCLSID);

    RegRemoveSubtree(HKEY_CLASSES_ROOT, szClsKey);
    RegRemoveSubtree(HKEY_CLASSES_ROOT, szVerIndProgID);
    RegRemoveSubtree(HKEY_CLASSES_ROOT, szProgID);

    return S_OK;
}

BOOL
GetCLSIDRegValue(const CLSID &clsid,
				 const TCHAR *szKey,
				 LPVOID pValue,
				 LPDWORD pcbValue)
{
    TCHAR szCLSID[CLSID_STRING_SIZE];
    HRESULT hr;
    HKEY hk;
	DWORD dw;

    hr = CLSIDToStr(clsid, szCLSID, sizeof(szCLSID));
    if (!SUCCEEDED(hr)) {
        return FALSE;
    }

    TCHAR szClsKey[256];
    lstrcpy(szClsKey, g_szCLSIDSlash);
    lstrcat(szClsKey, szCLSID);
	lstrcat(szClsKey, TEXT("\\"));
	lstrcat(szClsKey, szKey);

	if (RegOpenKeyEx(HKEY_CLASSES_ROOT,
					 szClsKey,
					 0,
					 KEY_READ,
					 &hk)) {
		return FALSE;
	}

	if (RegQueryValueEx(hk,
						NULL,
						NULL,
						&dw,
						(LPBYTE)pValue,
						pcbValue)) {
		RegCloseKey(hk);
		return FALSE;
	}

	RegCloseKey(hk);
	
	return TRUE;
}

HRESULT
CLSIDToStr(const CLSID &clsid,
           TCHAR *szStr,
           int cbStr)
{
    
	LPOLESTR wszCLSID = NULL;
	HRESULT hr = StringFromCLSID(clsid, &wszCLSID);
    if (!SUCCEEDED(hr)) {
        return hr;
    }

#ifdef UNICODE
    lstrcpy(szStr, wszCLSID);
#else
	// Covert from wide characters to non-wide.
	wcstombs(szStr, wszCLSID, cbStr);
#endif

	// Free memory.
    CoTaskMemFree(wszCLSID);

    return S_OK;
}

HRESULT
StrToCLSID(TCHAR *szStr,
		   CLSID &clsid,
		   int cbStr)
{
#ifdef UNICODE
    return CLSIDFromString(szStr, &clsid);
#else    
	WCHAR wsz[512];

	mbstowcs(wsz, szStr, cbStr);

	return CLSIDFromString(wsz, &clsid);
#endif
}
   

static LONG
RegSetDefValue(LPCTSTR pstrKey,
               LPCTSTR pstrSubkey,
			   LPCTSTR pstrValueName,
               LPCTSTR pstrValue)
{
    HKEY hk;
    LONG lr;
    TCHAR sz[1024];
    LPCTSTR pstr;

    if (!pstrSubkey) {
        pstr = pstrKey;
    } else {
        lstrcpy(sz, pstrKey);
        lstrcat(sz, TEXT("\\"));
        lstrcat(sz, pstrSubkey);
        pstr = sz;
    }

    lr = RegCreateKeyEx(HKEY_CLASSES_ROOT,
                        pstr,
                        0,
                        NULL,
                        REG_OPTION_NON_VOLATILE,
                        KEY_ALL_ACCESS,
                        NULL,
                        &hk,
                        NULL);
    if (lr) {
        return lr;
    }

    lr = RegSetValueEx(hk,
                       pstrValueName,
                       0,
                       REG_SZ,
                       (CONST BYTE*)pstrValue,
                       1+lstrlen(pstrValue));
    RegCloseKey(hk);

    return lr;
}

static void
RegRemoveSubtree(HKEY hk,
                 LPCTSTR pstrChild)
{
    LONG lResult;
    HKEY hkChild;

    lResult = RegOpenKeyEx(hk,
                           pstrChild,
                           0,
                           KEY_ALL_ACCESS,
                           &hkChild);
    if (lResult) {
        return;
    }

#ifndef UNDER_CE    // CE doesn't support RegEnumKey()
    TCHAR szSubkey[256];

    // NOTE: Unlike regular enumeration, we always grab the 0th item
    // and delete it.
    //
    while (!RegEnumKey(hkChild, 0, szSubkey, sizeof(szSubkey))) {
        RegRemoveSubtree(hkChild, szSubkey);
    }
#endif    

    RegCloseKey(hkChild);
    RegDeleteKey(hk, pstrChild);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\XboxSynth\shared\toolprops_i.h ===
#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the IIDs and CLSIDs */

/* link this file in with the server and any clients */


 /* File created by MIDL compiler version 6.00.0328 */
/* at Wed Jun 07 15:59:39 2000
 */
/* Compiler settings for ..\toolprops.idl:
    Os (OptLev=s), W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )

#if !defined(_M_IA64) && !defined(_M_AXP64)

#ifdef __cplusplus
extern "C"{
#endif 


#include <rpc.h>
#include <rpcndr.h>

#ifdef _MIDL_USE_GUIDDEF_

#ifndef INITGUID
#define INITGUID
#include <guiddef.h>
#undef INITGUID
#else
#include <guiddef.h>
#endif

#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
        DEFINE_GUID(name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8)

#else // !_MIDL_USE_GUIDDEF_

#ifndef __IID_DEFINED__
#define __IID_DEFINED__

typedef struct _IID
{
    unsigned long x;
    unsigned short s1;
    unsigned short s2;
    unsigned char  c[8];
} IID;

#endif // __IID_DEFINED__

#ifndef CLSID_DEFINED
#define CLSID_DEFINED
typedef IID CLSID;
#endif // CLSID_DEFINED

#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
        const type name = {l,w1,w2,{b1,b2,b3,b4,b5,b6,b7,b8}}

#endif !_MIDL_USE_GUIDDEF_

MIDL_DEFINE_GUID(IID, LIBID_TOOLPROPSLib,0x2735B8F3,0xFF4A,0x4AF2,0x80,0x53,0xBE,0x22,0xC0,0xCA,0x32,0x32);


MIDL_DEFINE_GUID(CLSID, CLSID_EchoPage,0x5337AF8F,0x3827,0x44DD,0x9E,0xE9,0xAB,0x6E,0x1A,0xAB,0xB6,0x0F);


MIDL_DEFINE_GUID(CLSID, CLSID_TransposePage,0x691BD8C2,0x2B07,0x4C92,0xA8,0x2E,0x92,0xD8,0x58,0xDE,0x23,0xD6);


MIDL_DEFINE_GUID(CLSID, CLSID_DurationPage,0x79D9CAF8,0xDBDA,0x4560,0xA8,0xB0,0x07,0xE7,0x3A,0x79,0xFA,0x6B);


MIDL_DEFINE_GUID(CLSID, CLSID_QuantizePage,0x623286DC,0x67F8,0x4055,0xA9,0xBE,0xF7,0xA7,0x17,0x6B,0xD1,0x50);


MIDL_DEFINE_GUID(CLSID, CLSID_TimeShiftPage,0x7D3BDEE7,0x9557,0x4085,0x82,0xEE,0x1B,0x2F,0x02,0xCE,0x4B,0xA6);


MIDL_DEFINE_GUID(CLSID, CLSID_SwingPage,0x0B237E01,0x062A,0x4A40,0x8D,0x43,0x4B,0x5F,0xCD,0x49,0x96,0x5A);


MIDL_DEFINE_GUID(CLSID, CLSID_VelocityPage,0x30EC7213,0x64BE,0x4EF6,0xBB,0x1B,0x46,0x34,0x27,0xEC,0x86,0x4B);

#undef MIDL_DEFINE_GUID

#ifdef __cplusplus
}
#endif



#endif /* !defined(_M_IA64) && !defined(_M_AXP64)*/


#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the IIDs and CLSIDs */

/* link this file in with the server and any clients */


 /* File created by MIDL compiler version 6.00.0328 */
/* at Wed Jun 07 15:59:39 2000
 */
/* Compiler settings for ..\toolprops.idl:
    Oicf (OptLev=i2), W1, Zp8, env=Win64 (32b run,appending)
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )

#if defined(_M_IA64) || defined(_M_AXP64)

#ifdef __cplusplus
extern "C"{
#endif 


#include <rpc.h>
#include <rpcndr.h>

#ifdef _MIDL_USE_GUIDDEF_

#ifndef INITGUID
#define INITGUID
#include <guiddef.h>
#undef INITGUID
#else
#include <guiddef.h>
#endif

#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
        DEFINE_GUID(name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8)

#else // !_MIDL_USE_GUIDDEF_

#ifndef __IID_DEFINED__
#define __IID_DEFINED__

typedef struct _IID
{
    unsigned long x;
    unsigned short s1;
    unsigned short s2;
    unsigned char  c[8];
} IID;

#endif // __IID_DEFINED__

#ifndef CLSID_DEFINED
#define CLSID_DEFINED
typedef IID CLSID;
#endif // CLSID_DEFINED

#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
        const type name = {l,w1,w2,{b1,b2,b3,b4,b5,b6,b7,b8}}

#endif !_MIDL_USE_GUIDDEF_

MIDL_DEFINE_GUID(IID, LIBID_TOOLPROPSLib,0x2735B8F3,0xFF4A,0x4AF2,0x80,0x53,0xBE,0x22,0xC0,0xCA,0x32,0x32);


MIDL_DEFINE_GUID(CLSID, CLSID_EchoPage,0x5337AF8F,0x3827,0x44DD,0x9E,0xE9,0xAB,0x6E,0x1A,0xAB,0xB6,0x0F);


MIDL_DEFINE_GUID(CLSID, CLSID_TransposePage,0x691BD8C2,0x2B07,0x4C92,0xA8,0x2E,0x92,0xD8,0x58,0xDE,0x23,0xD6);


MIDL_DEFINE_GUID(CLSID, CLSID_DurationPage,0x79D9CAF8,0xDBDA,0x4560,0xA8,0xB0,0x07,0xE7,0x3A,0x79,0xFA,0x6B);


MIDL_DEFINE_GUID(CLSID, CLSID_QuantizePage,0x623286DC,0x67F8,0x4055,0xA9,0xBE,0xF7,0xA7,0x17,0x6B,0xD1,0x50);


MIDL_DEFINE_GUID(CLSID, CLSID_TimeShiftPage,0x7D3BDEE7,0x9557,0x4085,0x82,0xEE,0x1B,0x2F,0x02,0xCE,0x4B,0xA6);


MIDL_DEFINE_GUID(CLSID, CLSID_SwingPage,0x0B237E01,0x062A,0x4A40,0x8D,0x43,0x4B,0x5F,0xCD,0x49,0x96,0x5A);


MIDL_DEFINE_GUID(CLSID, CLSID_VelocityPage,0x30EC7213,0x64BE,0x4EF6,0xBB,0x1B,0x46,0x34,0x27,0xEC,0x86,0x4B);

#undef MIDL_DEFINE_GUID

#ifdef __cplusplus
}
#endif



#endif /* defined(_M_IA64) || defined(_M_AXP64)*/
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\XboxSynth\shared\smartref.h ===
// Copyright (c) 1999 Microsoft Corporation. All rights reserved.
//
// Simple helper classes that use the "resource acquisition is initialization" technique.
// In English, this means they acquire a reference to a resource and the resource is automatically
//    released in the destructor.
//

// This is particularly helpful if you are using exception handling or simulating it (painfully)
//    in OLE by putting "if (FAILED(hr)) return;" after every function call.  In such circumstances
//    it simpler if you know that the resource will be automatically freed no matter how you end
//    up exiting the function.
// Since we're not using exception handling, these classes do not throw.  If resource acquisition
//    could fail, be sure to check for the error before using the resource!
// Sometimes these helper classes are more than just simple wrappers for freeing the resource.
//    They may also provide useful methods that make it easier to perform operations on the resource.
// Everything here is enclosed in the SmartRef namespace.  Thus you can't refer to CritSec directly.
//    Instead you must say SmartRef::CritSec.

#pragma once
#include "debug.h"
#include "mmsystem.h"
#include "dmstrm.h"
#include "dmerror.h"
#include "dmusici.h"

// Place this in the private: section of a class to prevent use of the default C++ copy and assignment.
// Creates an error if someone later tries to use the automatic member-by-member copy that would be incorrect.
// Use this if you don't do the work to implement correct copying or if copying doesn't make sense for this class.
#define NOCOPYANDASSIGN(classname) classname(const classname &o); classname &operator= (const classname &o);

namespace SmartRef
{

	// Enters a critical section on contruction.  Leaves on destruction.
	class CritSec
	{
	public:
		CritSec(CRITICAL_SECTION *pCriticalSection) : m_pCriticalSection(pCriticalSection) { EnterCriticalSection(m_pCriticalSection); }
		~CritSec() { LeaveCriticalSection(m_pCriticalSection); }
	private:
		NOCOPYANDASSIGN(CritSec)
		CRITICAL_SECTION *m_pCriticalSection;
	};

	// Makes a copy of an ANSI string and frees it on destruction.
	// hungarian: astr
	class AString
	{
	public:
		AString(const WCHAR *psz) : m_psz(NULL) { this->AssignFromW(psz); }
		AString(const char *psz = NULL) : m_psz(NULL) { *this = psz; }
		AString(const char *psz, UINT cch); // take first cch characters of psz
		AString(const AString &str) : m_psz(NULL) { *this = str.m_psz; }
		~AString() { *this = NULL; }
		operator const char *() const { return m_psz; }
		AString &operator= (const char *psz);
		AString &operator= (const AString &str) { return *this = str.m_psz; }
		AString &Assign(const char *psz, UINT cch); // take first cch characters of psz
		AString &AssignFromW(const WCHAR *psz);

		char ** operator& () { assert(!m_psz); return &m_psz; } // allows direct setting of psz, adopting a string without copying it

	private:
		char *m_psz;
	};

	// Same as AString for Unicode strings.
	// Also accepts ANSI strings, converting them to Unicode.
	// hungarian: wstr
	class WString
	{
	public:
		WString(const char *psz) : m_psz(NULL) { this->AssignFromA(psz); }
		WString(const WCHAR *psz = NULL) : m_psz(NULL) { *this = psz; }
		WString(const WCHAR *psz, UINT cch) : m_psz(NULL) { this->Assign(psz, cch); }
		WString(const WString &str) : m_psz(NULL) { *this = str.m_psz; }
		~WString() { *this = static_cast<WCHAR *>(NULL); }
		operator const WCHAR *() const { return m_psz; }
		WString &operator= (const WCHAR *psz);
		WString &operator= (const WString &str) { return *this = str.m_psz; }
		WString &Assign(const WCHAR *psz, UINT cch); // take first cch characters of psz
		WString &AssignFromA(const char *psz);

		WCHAR ** operator& () { assert(!m_psz); return &m_psz; } // allows direct setting of psz, adopting a string without copying it

	private:
		WCHAR *m_psz;
	};

	// Allocates a writable buffer of a fixed size and frees it on destruction.
	// (For example, you could use a Buffer<char> to write a string into.)
	// hungarian: buf prefixed by type
	//            use abuf for Buffer<char> and wbuf for Buffer<WCHAR>
	template<class T>
	class Buffer
	{
	public:
		Buffer(UINT uiSize) { m_p = new T[uiSize + 1]; }
		~Buffer() { delete[] m_p; }
		operator T *() { return m_p; }

		// use to defer allocation (say, if you don't know the size at the declaration)
		Buffer() : m_p(NULL) {}
		void Alloc(UINT uiSize) { delete[] m_p; m_p = new T[uiSize + 1]; }
		T* disown() { T *_p = m_p; m_p = NULL; return _p; }
		T** operator& () { assert(!m_p); return &m_p; } // allows direct setting of m_p, adopting a string without copying it

	private:
		NOCOPYANDASSIGN(Buffer)
		T *m_p;
	};

	// Holds an array that grows automatically.
	// Doesn't throw so you must call AccessTo before using a position that might have required
	//    reallocation to ensure that memory didn't run out.
	// Values held in the vector must have value semantics so that they can be copied freely
	//    into reallocated memory slots.
	// hungarian: vec prefixed by type
	//            of just use svec (for smart vector) without specifying the type
	//            use avec for Vector<char> and wvec for Vector<WCHAR>
	template<class T>
	class Vector
	{
	public:
		Vector() : m_pT(NULL), m_size(0), m_capacity(0) {}
		~Vector() { delete[] m_pT; }
		UINT size() { return m_size; }
		operator bool() { return m_fFail; }
		bool AccessTo(UINT uiPos) { return Grow(uiPos + 1); }
		T& operator[](UINT uiPos) { assert(uiPos < m_size); return m_pT[uiPos]; }
		T* GetArray() { return m_pT; } // Danger: only use when needed and don't write past the end.
		void Shrink(UINT uiNewSize) { m_size = uiNewSize; } // Semantically shrinks -- doesn't actually free up any memory

	private:
		NOCOPYANDASSIGN(Vector)
		bool Grow(UINT size)
			{
				if (size > m_size)
				{
					if (size > m_capacity)
					{
						for (UINT capacity = m_capacity ? m_capacity : 1;
								capacity < size;
								capacity *= 2)
						{}
						T *pT = new T[capacity];
						if (!pT)
							return false;
						for (UINT i = 0; i < m_size; ++i)
							pT[i] = m_pT[i];
						delete[] m_pT;
						m_pT = pT;
						m_capacity = capacity;
					}
					m_size = size;
				}
				return true;
			}

		T *m_pT;
		UINT m_size;
		UINT m_capacity;
	};

	// Standard stack abstract data type.
	// Values held in the stack must have value semantics so that they can be copied freely
	//    into reallocated memory slots.
	// hungarian: stack prefixed by type
	template<class T>
	class Stack
	{
	public:
		Stack() : iTop(-1) {}
		bool empty() { return iTop < 0; }
		HRESULT push(const T& t) { if (!m_vec.AccessTo(iTop + 1)) return E_OUTOFMEMORY; m_vec[++iTop] = t; return S_OK; }
		T top() { if (empty()) {assert(false); return T();} return m_vec[iTop]; }
		void pop() { if (empty()) {assert(false); return;} --iTop; }

	private:
		Vector<T> m_vec;
		int iTop;
	};

	// Lookup table that maps keys to values.  Grows automatically as needed.
	// Type K (keys) must support operator =, operator ==. and a Hash function that returns an int.
	// Type V must support operator =.
	template <class K, class V>
	class Hash
	{
	public:
		Hash(HRESULT *phr, int iInitialSize = 2) : m_p(NULL), m_iCapacity(0), m_iSize(0) { *phr = Grow(iInitialSize); }
		~Hash() { delete[] m_p; }

		struct entry
		{
			V v;
			bool fFound() { return iHash != -1; }
		private:
			// only let the hash make them
			friend class Hash<K, V>;
			entry() : iHash(-1) {};
			entry(const entry &o); // disallowed copy constructor

			int iHash;
			K k;
		};

		entry &Find(K k) // if iHash is -1 then it wasn't found and you may immediately add the entry using Add().
		{
			assert(m_p);
			return HashTo(k.Hash(), k, m_p, m_iCapacity);
		}

		// Warning: no intervening additions may have occurred between the time e was returned by Find and the time Add(e, ...) is called.
		// Also k must be the same in both calls.  If you want to be crafty, "same" can be replaced with equivalence in terms of Hash and operator==.
		HRESULT Add(entry &e, K k, V v)
		{
			assert(!e.fFound());
			assert(&e == &Find(k));

			e.v = v;
			e.iHash = k.Hash();
			e.k = k;
			++m_iSize;
			if (m_iSize * 2 > m_iCapacity)
				return Grow(m_iCapacity * 2);
			return S_OK;
		}

		V &operator[](K k)
		{
			entry &e = Find(k);
			assert(e.fFound());
			return e.v;
		}

	private:
		HRESULT Grow(int iCapacity)
		{
#ifdef DBG
			// size must be at least 2 and a power of 2
			for (int iCheckSize = iCapacity; !(iCheckSize & 1); iCheckSize >>= 1)
			{}
			assert(iCapacity > 1 && iCheckSize == 1);
#endif

			// alloc new table
			entry *p = new entry[iCapacity];
			if (!p)
			{
				delete[] m_p;
				return E_OUTOFMEMORY;
			}

			// rehash everything into the larger table
			for (int i = 0; i < m_iCapacity; ++i)
			{
				entry &eSrc = m_p[i];
				if (eSrc.iHash != -1)
				{
					entry &eDst = HashTo(eSrc.iHash, eSrc.k, p, iCapacity);
					assert(eDst.iHash == -1);
					eDst = eSrc;
				}
			}

			delete[] m_p;
			m_p = p;
			m_iCapacity = iCapacity;
			return S_OK;
		}

		entry &HashTo(int iHash, K k, entry *p, int iCapacity)
		{
			// initial hash using modulus, then jump three slots at a time (3 is guaranteed to take us to all slots because capacity is a power of 2)
			assert(iHash >= 0);
			for (int i = iHash % iCapacity;
					p[i].iHash != -1 && (p[i].iHash != iHash || !(p[i].k == k)); // rehash while slot occupied or it doesn't match
					i = (i + 3) % iCapacity)
			{}
			return p[i];
		}
		
		entry *m_p;
		int m_iCapacity;
		int m_iSize;
	};

	// Holds the supplied pointer and frees it on destruction.
	// hungarian: sp (smart pointer)
	template <class T>
	class Ptr
	{
	public:
		Ptr(T *_p) : p(_p) {}
		~Ptr() { delete p; }
		operator T*() { return p; }
		T *operator->() { return p; }

		T* disown() { T *_p = p; p = NULL; return _p; }

	private:
		NOCOPYANDASSIGN(Ptr)
		T* p;
	};

	// Holds the supplied pointer to an array and frees it (with delete[]) on destruction.
	// hungarian: sprg
	template <class T>
	class PtrArray
	{
	public:
		PtrArray(T *_p) : p(_p) {}
		~PtrArray() { delete[] p; }
		operator T*() { return p; }

		T* disown() { T *_p = p; p = NULL; return _p; }

	private:
		NOCOPYANDASSIGN(PtrArray)
		T* p;
	};

	// Holds the supplied COM interface and releases it on destruction.
	// hungarian: scom
	template <class T>
	class ComPtr
	{
	public:
		ComPtr(T *_p = NULL) : p(_p) {}
		~ComPtr() { *this = NULL; }
		operator T*() { return p; }
		T* operator-> () { assert(p); return p; }
		ComPtr &operator= (T *_p) { if (p) p->Release(); p = _p; return *this; }
		T** operator& () { assert(!p); return &p; }

		void Release() { *this = NULL; }
		T* disown() { T *_p = p; p = NULL; return _p; }

	private:
		T* p;
	};

	// Holds the supplied registry key handle and closes it on destruction.
	// hungarian: shkey
	class HKey
	{
	public:
		HKey(HKEY hkey = NULL) : m_hkey(hkey) {}
		~HKey() { *this = NULL; }
		HKey &operator= (HKEY hkey) { if (m_hkey) ::RegCloseKey(m_hkey); m_hkey = hkey; return *this; }
		HKEY *operator& () { assert(!m_hkey); return &m_hkey; }
		operator HKEY() { return m_hkey; }

	private:
		NOCOPYANDASSIGN(HKey)
		HKEY m_hkey;
	};

	// Allocates and clears a one of the DMUS_*_PMSG structures.  You fill out its fields
	// and then call StampAndSend.  The message is automatically cleared after a successful
	// send or freed on destruction.  Be sure the check the hr function for failures.
	// hungarian: pmsg
	template <class T>
	class PMsg
	{
	public:
		T *p; // pointer to the message structure -- use to set the fields before sending
		PMsg(IDirectMusicPerformance *pPerf, UINT cbExtra = 0) // use cbExtra to allocate extra space in the structure, such as for DMUS_SYSEX_PMSG or DMUS_LYRIC_PMSG
		  : m_pPerf(pPerf), m_hr(S_OK), p(NULL)
		{
			const UINT cb = sizeof(T) + cbExtra;
			m_hr = m_pPerf->AllocPMsg(cb, reinterpret_cast<DMUS_PMSG**>(&p));
			if (SUCCEEDED(m_hr))
			{
				assert(p->dwSize == cb);
				ZeroMemory(p, cb);
				p->dwSize = cb;
			}
		}
		~PMsg() { if (p) m_pPerf->FreePMsg(reinterpret_cast<DMUS_PMSG*>(p)); }
		void StampAndSend(IDirectMusicGraph *pGraph)
		{
			m_hr = pGraph->StampPMsg(reinterpret_cast<DMUS_PMSG*>(p));
			if (FAILED(m_hr))
				return;

			m_hr = m_pPerf->SendPMsg(reinterpret_cast<DMUS_PMSG*>(p));
			if (SUCCEEDED(m_hr))
				p = NULL; // PMsg now owned by the performance
		}
		HRESULT hr() { return m_hr; }

	private:
		NOCOPYANDASSIGN(PMsg)
		IDirectMusicPerformance *m_pPerf; // weak ref
		HRESULT m_hr;
	};

	// Walks through the RIFF file structure held in a stream.  Releases it on destruction.
	// Although I found this to be quite useful, it a bit complicated.  You should look over
	//    the source or step through some examples before you use it.  Although I'm not positive
	//    this wouldn't work, it is not designed to have multiple RiffIter's walking over the
	//    same stream at once (see note in Descend).
	// hungarian: ri
	class RiffIter
	{
	public:
		enum RiffType { Riff, List, Chunk };

		RiffIter(IStream *pStream);
		~RiffIter();

		RiffIter &operator ++();
		RiffIter &Find(RiffType t, FOURCC id);
		HRESULT FindRequired(RiffType t, FOURCC id, HRESULT hrOnNotFound) { if (Find(t, id)) return S_OK; HRESULT _hr = hr(); return SUCCEEDED(_hr) ? hrOnNotFound : _hr; } // Attempts to find the expected chunk.  Returns S_OK if found, an error code if there was a problem reading, and hrOnNotFound if reading worked OK but the chunk simply wasn't there.

		// With Descend, use the returned iterator to process the children before resuming use of the parent.  Using both at once won't work.
		RiffIter Descend() { validate(); return RiffIter(*this, m_ckChild); }

		operator bool() const { return SUCCEEDED(m_hr); }
		HRESULT hr() const { return (m_hr == DMUS_E_DESCEND_CHUNK_FAIL) ? S_OK : m_hr; }

		RiffType type() const { validate(); return (m_ckChild.ckid == FOURCC_LIST) ? List : ((m_ckChild.ckid == FOURCC_RIFF) ? Riff : Chunk); }
		FOURCC id() const { validate(); return (type() == Chunk) ? m_ckChild.ckid : m_ckChild.fccType; }

		DWORD size() const { validate(); assert(type() == Chunk); return m_ckChild.cksize; }
		HRESULT ReadChunk(void *pv, UINT cb);
		HRESULT ReadArrayChunk(DWORD cbSize, void **ppv, int *pcRecords); // Reads an array chunk that is an array of records where the first DWORD gives the size of the records.  The records are copied into an array of records of size dwSize (filling with zero if the actual records in the file are smaller and ignoring additional fields if the actual records are larger).  ppv is set to return a pointer to this array, which the caller now owns and must delete.  pcRecords is set to the number of records returned.

		// Find the chunk (or return hrOnNoteFound). Load an object embedded in the stream. Then leaves the iterator on the next chunk.
		HRESULT FindAndGetEmbeddedObject(RiffType t, FOURCC id, HRESULT hrOnNotFound, IDirectMusicLoader *pLoader, REFCLSID rclsid, REFIID riid, LPVOID *ppv);

		// read specific RIFF structures
		HRESULT ReadReference(DMUS_OBJECTDESC *pDESC); // no need to init (zero, set size) the passed descriptor before calling
		HRESULT LoadReference(IDirectMusicLoader *pIDMLoader, const IID &iid, void **ppvObject)
		{
			DMUS_OBJECTDESC desc;
			HRESULT hr = ReadReference(&desc);
			if(SUCCEEDED(hr))
				hr = pIDMLoader->GetObject(&desc, iid, ppvObject);
			return hr;
		}

		struct ObjectInfo
		{
			ObjectInfo() { Clear(); }
			void Clear() { wszName[0] = L'\0'; guid = GUID_NULL; vVersion.dwVersionMS = 0; vVersion.dwVersionLS = 0; }

			WCHAR wszName[DMUS_MAX_NAME];
			GUID guid;
			DMUS_VERSION vVersion;
		};
		HRESULT LoadObjectInfo(ObjectInfo *pObjInfo, RiffType rtypeStop, FOURCC ridStop); // No need to init/zero. Reads from <guid-ck>, <vers-ck>, and <UNFO-list>/<UNAM-ck>. Stops at rtypeStop/ridStop, or returns E_FAIL if not found.

		HRESULT ReadText(WCHAR **ppwsz); // allocates a buffer and reads the current chunk--a NULL-terminated Unicode string--into it
		HRESULT ReadTextTrunc(WCHAR *pwsz, UINT cbBufSize); // reads only as much as it can fit in the buffer with a terminator

		// This is deliberately placed in the public section but never implemented in order to allow statements such as:
		//   SmartRef::RiffIter riChild = ri.Descend();
		// But it is never defined to prevent someone from trying to actually make two copies of a riffiter and then use them, which is not supported.
		// This would yield an unresolved symbol error:
		//   SmartRef::RiffIter riError = ri;
		// We don't allow general copying of RiffIters.  Only used to get the return value of Descend, where it is optimized away.
		RiffIter(const RiffIter &o);

	private:
		RiffIter &operator= (const RiffIter &o); // Also never defined -- don't allow assignment

		RiffIter(const RiffIter &other, MMCKINFO ckParent);
		bool validate() const { if (FAILED(m_hr)) { assert(false); return true; } else return false; }

		HRESULT m_hr;
		IStream *m_pIStream;
		IDMStream *m_pIDMStream;
		bool m_fParent;
		MMCKINFO m_ckParent;
		MMCKINFO m_ckChild;
	};

	// Templated ReadChunk typed helpers (templated member function wasn't working for me on current version of compiler)
	template <class T> HRESULT RiffIterReadChunk(RiffIter &ri, T *pT) { return ri.ReadChunk(pT, sizeof(*pT)); }
	template <class T> HRESULT RiffIterReadArrayChunk(RiffIter &ri, T **ppT, int *pcRecords) { return ri.ReadArrayChunk(sizeof(T), reinterpret_cast<void**>(ppT), pcRecords); }

}; // namespace SmartRef
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\XboxSynth\shared\tpool.h ===
// Copyright (c) 1998 Microsoft Corporation
//
// TPool.h
//
// Template pool memory manager. Efficiently manage requests for many of the same (small) object.
// Named after t'Pool, the Vulcan programmer who invented the technique.
//
#ifndef _TPOOL_H_
#define _TPOOL_H_

#include "debug.h"

#define POOL_DEFAULT_BYTE_PER_BLOCK     4096
#define MIN_ITEMS_PER_BLOCK             4

///////////////////////////////////////////////////////////////////////////////
//
// CPool
//
// A simple memory manager that efficiently handles many objects of the same 
// size by allocating blocks containing multiple objects at once.
//
// 
template<class contained> class CPool
{
public:
    CPool(int nApproxBytesPerBlock = POOL_DEFAULT_BYTE_PER_BLOCK);
    ~CPool();

    contained *Alloc();
    void Free(contained* pToFree);

private:
    union CPoolNode
    {
        CPoolNode       *pNext;
        contained       c;
    };

    class CPoolBlock
    {
    public:
        CPoolBlock      *pNext;
        CPoolNode       *pObjects;
    };

    int                 nItemsPerBlock;             // Based on bytes per block
    int                 nAllocatedBlocks;           // # allocated blocks
    CPoolBlock          *pAllocatedBlocks;          // list of allocated blocks
    int                 nFreeList;                  // # nodes in free list
    CPoolNode           *pFreeList;                 // free list

private:
    bool RefillFreeList();

#ifdef DBG
    bool IsPoolNode(CPoolNode *pNode);
    bool IsInFreeList(CPoolNode *pNode);
#endif

};

///////////////////////////////////////////////////////////////////////////////
//
// CPool::CPool
//
// Figure out the number of contained objects per block based on the requested
// approximate block size. Initialize the free list to contain one block's 
// worth of objects.
// 
//
template<class contained> CPool<contained>::CPool(int nApproxBytesPerBlock)
{
    // Figure out how many items per block and cheat if too small
    //
    nItemsPerBlock = nApproxBytesPerBlock / sizeof(CPoolNode);
    if (nItemsPerBlock < MIN_ITEMS_PER_BLOCK)
    {
        nItemsPerBlock = MIN_ITEMS_PER_BLOCK;
    }

    nAllocatedBlocks = 0;
    pAllocatedBlocks = NULL;
    nFreeList = 0;
    pFreeList = NULL;

    // Fill up with some items ahead of time
    //
    RefillFreeList();
}

///////////////////////////////////////////////////////////////////////////////
//
// CPool::~CPool
//
// Free up all allocated blocks. There should be no outstanding blocks 
// allocated at this point.
//
// 
template<class contained> CPool<contained>::~CPool()
{
#ifdef DBG
    if (nFreeList < nAllocatedBlocks * nItemsPerBlock)
    {
        TraceI(0, "CPool::~Cpool: Warning: free'ing with outstanding objects allocated.\n");
    }
#endif
    
    // Clean up all allocated blocks and contained objects.
    //
    while (pAllocatedBlocks)
    {
        CPoolBlock *pNext = pAllocatedBlocks->pNext;

        delete[] pAllocatedBlocks->pObjects;
        delete pAllocatedBlocks;

        pAllocatedBlocks = pNext;
    }
}

///////////////////////////////////////////////////////////////////////////////
//
// CPool::Alloc
//
// Attempt to allocate a contained object and return NULL if out of memory.
// If the free list is empty then allocate another block.
//
// 
template<class contained> contained *CPool<contained>::Alloc()
{
    if (pFreeList == NULL)
    {
        if (!RefillFreeList())
        {
            return false;
        }
    }

    nFreeList--;
    contained *pAlloc = (contained*)pFreeList;
    pFreeList = pFreeList->pNext;

    return pAlloc;
}

///////////////////////////////////////////////////////////////////////////////
//
// CPool::Free
//
// Return a contained object to the free list. In the debug version make sure
// the object was in fact allocated from this pool in the first place and that
// it isn't already in the free list.
//
// 
template<class contained> void CPool<contained>::Free(contained *pToFree)
{
    CPoolNode *pNode = (CPoolNode*)pToFree;

#ifdef DBG
    if (!IsPoolNode(pNode))
    {
        TraceI(0, "CPool::Free() Object %p is not a pool node; ignored.\n", pToFree);
        return;
    }
    
    if (IsInFreeList(pNode))
    {
        TraceI(0, "CPool::Free() Object %p is already in the free list; ignored.\n", pToFree);
        return;
    }
#endif

    nFreeList++;
    pNode->pNext = pFreeList;
    pFreeList = pNode;
}

///////////////////////////////////////////////////////////////////////////////
//
// CPool::RefillFreeList
//
// Add one block's worth of contained objects to the free list, tracking the 
// allocated memory so we can free it later.
//
// 
template<class contained> bool CPool<contained>::RefillFreeList()
{
    // Allocate a new block and the actual block of objects
    //
    CPoolBlock *pNewBlock = new CPoolBlock;
    if (pNewBlock == NULL)
    {
        return false;
    }

    pNewBlock->pObjects = new CPoolNode[nItemsPerBlock];
    if (pNewBlock->pObjects == NULL)
    {
        delete pNewBlock;
        return false;
    }
    
    TraceI(1, "CPool: Alllocated block %p objects %p for %d bytes\n", 
        pNewBlock, pNewBlock->pObjects, sizeof(CPoolNode) * nItemsPerBlock);

    // Link the block and objects into the right places. First link the new block
    // into the list of allocated blocks.
    //
    pNewBlock->pNext = pAllocatedBlocks;
    pAllocatedBlocks = pNewBlock;

    // Link all the contained object nodes into the free list.
    //
    CPoolNode *pFirstNode = &pNewBlock->pObjects[0];
    CPoolNode *pLastNode  = &pNewBlock->pObjects[nItemsPerBlock - 1];

    for (CPoolNode *pNode = pFirstNode; pNode < pLastNode; pNode++)
    {
        pNode->pNext = pNode + 1;
    }

    pLastNode->pNext = pFreeList;
    pFreeList = pFirstNode;
    
    nFreeList += nItemsPerBlock;
    nAllocatedBlocks++;

    return true;
}

#ifdef DBG
///////////////////////////////////////////////////////////////////////////////
//
// CPool::IsPoolNode (debug)
//
// Verify that the passed pointer is a pointer to a pool node by walking the list
// of allocated blocks.
//
// 
template<class contained> bool CPool<contained>::IsPoolNode(CPoolNode *pTest)
{
    for (CPoolBlock *pBlock = pAllocatedBlocks; pBlock; pBlock = pBlock->pNext)
    {
        CPoolNode *pFirstNode = &pBlock->pObjects[0];
        CPoolNode *pLastNode  = &pBlock->pObjects[nItemsPerBlock - 1];

        for (CPoolNode *pNode = pFirstNode; pNode <= pLastNode; pNode++)
        {
            if (pNode == pTest)
            {
                return true;
            }
        }
    }

    return false;
}

///////////////////////////////////////////////////////////////////////////////
//
// CPool::IsInFreeList (debug)
//
// Verify that the passed pointer points to a node that is already in the free
// list.
//
// 
template<class contained> bool CPool<contained>::IsInFreeList(CPoolNode *pTest)
{
    for (CPoolNode *pNode = pFreeList; pNode; pNode = pNode->pNext)
    {
        if (pTest == pNode)
        {
            return true;
        }
    }
    
    return false;
}
#endif  // DBG
#endif  // _TPOOL_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\XboxSynth\shared\tlist.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (c) 1998-1999 Microsoft Corporation
//
//  File:       tlist.h
//
//--------------------------------------------------------------------------

//
// tlist.h --- template version of AList
//
#ifndef __TLIST_H__
#define __TLIST_H__

//#include "stdafx.h"

//template <class T>
//typedef BOOL (* TRelation) (T, T);

// TListItem<> contains four more members than AListItem: one additional constructor,
// a destructor, one member function, and one data member.
template <class T>
class TListItem
{
public:
    TListItem() { m_pNext=NULL; };
    ~TListItem();												// new destructor
	static void Delete(TListItem<T>* pFirst);                           // new deletion helper
    TListItem(const T& item) { m_Tinfo = item; m_pNext=NULL; };	// additional constructor.
    TListItem<T> *GetNext() const {return m_pNext;};
    void SetNext(TListItem<T> *pNext) {m_pNext=pNext;};
    LONG GetCount() const;
    TListItem<T>* Cat(TListItem<T>* pItem);
    TListItem<T>* AddTail(TListItem<T>* pItem) {return Cat(pItem);};
    TListItem<T>* Remove(TListItem<T>* pItem);
    TListItem<T>* GetPrev(TListItem<T> *pItem) const;
    TListItem<T>* GetItem(LONG index);
    T& GetItemValue() { return m_Tinfo; }  // additional member function
	TListItem<T>* MergeSort(BOOL (* fcnCompare) (T&, T&)); // Destructively mergeSorts the list items 
private:
	void Divide(TListItem<T>* &pHalf1, TListItem<T>* &pHalf2);
	TListItem<T>* Merge(TListItem<T>* pOtherList, BOOL (* fcnCompare) (T&, T&));
	T m_Tinfo;  // additional data member, but memory is the same since in AListItem 
				// you put the extra data member in the derived class 
    TListItem<T> *m_pNext;
};

// TList<> adds a destructor to AList.
template <class T>
class TList
{
public:
    TList() {m_pHead=NULL;}
	~TList()
	{ 
		//if (m_pHead != NULL) delete m_pHead;
		TListItem<T>::Delete(m_pHead);
	} // new destructor
    TListItem<T> *GetHead() const { return m_pHead;};

    void RemoveAll() { m_pHead=NULL;};
    void CleanUp() 
	{ 
		//if (m_pHead) delete m_pHead;
		if (m_pHead) TListItem<T>::Delete(m_pHead);
		m_pHead=NULL;
	}
    LONG GetCount() const {return m_pHead->GetCount();}; 
    TListItem<T> *GetItem(LONG index) { return m_pHead->GetItem(index);}; 
    void InsertBefore(TListItem<T> *pItem,TListItem<T> *pInsert);
    void Cat(TListItem<T> *pItem) {m_pHead=m_pHead->Cat(pItem);};
    void Cat(TList<T> *pList)
        {
//            assert(pList!=NULL);
            m_pHead=m_pHead->Cat(pList->GetHead());
        };
    void AddHead(TListItem<T> *pItem)
        {
//            assert(pItem!=NULL);
            pItem->SetNext(m_pHead);
            m_pHead=pItem;
        }
    void AddTail(TListItem<T> *pItem);// {m_pHead=m_pHead->AddTail(pItem);};
    void Remove(TListItem<T> *pItem) {m_pHead=m_pHead->Remove(pItem);};
    TListItem<T> *GetPrev(TListItem<T> *pItem) const {return m_pHead->GetPrev(pItem);};
    TListItem<T> *GetTail() const {return GetPrev(NULL);};
    BOOL IsEmpty(void) const {return (m_pHead==NULL);};
    TListItem<T> *RemoveHead(void)
        {
            TListItem<T> *li;
            li=m_pHead;
            if(m_pHead)
			{
                m_pHead=m_pHead->GetNext();
				li->SetNext(NULL);
			}
            return li;
        }
	void MergeSort(BOOL (* fcnCompare) (T&, T&)); // Destructively mergeSorts the list
	void Reverse(void); // Reverses the entire list

protected:
    TListItem<T> *m_pHead;
};

#include "tlist.cpp"

#endif // __TLIST_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\XboxSynth\shared\validate.h ===
//
// validate.h
//
// Copyright (c) 1997-1999 Microsoft Corporation. All rights reserved.
//
// Parameter validation macros
//
// Summary:
//
// V_INAME(interfacename)                - Set the interface name for error display
// V_STRUCTPTR_READ(ptr,type)            - A dwSize struct which we will read
// V_STRUCTPTR_WRITE(ptr,type)           - A dwSize struct which we will read/write
// V_PTR_READ(ptr,type)                  - A typed ptr w/o a dwSize which we will read
// V_PTR_WRITE(ptr,type)                 - A typed ptr w/o a dwSize which we will read/write
// V_PTR_WRITE_OPT(ptr,type)             - An optional typed ptr w/o a dwSize which we will read/write
// V_BUFPTR_READ(ptr,size)               - A variable-size buffer that we will read
// V_BUFPTR_READ_OPT(ptr,size)			 - An optional variable-size buffer that we will read
// V_BUFPTR_WRITE(ptr,size)              - A variable-size buffer that we will read/write
// V_BUFPTR_WRITE_OPT(ptr,size)          - An optional variable-size buffer that we will read/write
// V_PTRPTR_WRITE(ptrptr)                - A pointer to a pointer to write to
// V_PTRPTR_WRITE_OPT(ptrptr)            - A pointer to a pointer to write to that is optional
// V_PUNKOUTER(punk)                     - A pointer to a controlling unknown, aggregation supported
// V_PUNKOUTER_NOADD(punk)               - A pointer to a controlling unknown, aggregation not supported
// V_INTERFACE(ptr)                      - A pointer to a COM interface
// V_INTERFACE_OPT(ptr)                  - An optional pointer to a COM interface
// V_REFGUID(ref)                        - A reference to a GUID (type REFGUID)
// V_HWND(hwnd)							 - A window handle
// V_HWNDOPT(hwnd)						 - An optional window handle
//
// For handling different versions of structures:
// 
// V_STRUCTPTR_READ_VER(ptr,ver)         - Begin a struct version block for read access
//                                         At the end, 'ver' will contain the 
//                                         discovered version of the struct
// V_STRUCTPTR_READ_VER_CASE(base,ver)   - Test struct against version ver of
//                                         type 'base'. 
// V_STRUCTPTR_READ_VER_END(base,ptr)    - End a struct version block
//
// V_STRUCTPTR_WRITE_VER(ptr,ver)        - Struct version block for write access
// V_STRUCTPTR_WRITE_VER_CASE(base,ver)
// V_STRUCTPTR_WRITE_VER_END(base,ptr)
//
// The struct version block expects type names of a base type followed by a 
// numeric version, such as
//
// typedef struct { } FOO7;
// typedef struct { } FOO8;
//
// In the header FOO and LPFOO are conditionally typedef'd based on a version
// #define. The DLL will be compiled with the latest version number and hence
// the largest version of the struct.
//
// Since Windows headers are compiled by default with 8-byte alignment, adding
// one DWORD may not cause the size of the structure to change. If this happens
// you will get a 'case label already used' error on one of the VER_CASE macros.
// If this happens, you can get around it by adding a dwReserved field to the 
// end of the struct to force the padding.
//
// 'optional' means the pointer is allowed to be NULL by the interface specification.
//
// Sample usage:
//
// int IDirectMusic::SetFooBarInterface(
//     LPDMUS_REQUESTED_CAPS    pCaps,          // Caps w/ dwSize (read-only)
//     LPVOID                   pBuffer,        // Buffer we will fill in
//     DWORD                    cbSize,         // Size of the buffer
//     PDIRECTMUSICBAR          pBar)           // Callback interface for bar on this buffer
// {
//     V_INTERFACE(IDirectMusic::SetFooBarInterface);
//     V_BUFPTR_WRITE(pBuffer, cbSize);
//     V_INTERFACE(pBar);
//     DWORD dwCapsVer;                         // Must be a DWORD!!!
//
//     V_STRUCTPTR_READ_VER(pCaps, dwCapsVer);
//     V_STRUCTPTR_READ_VER_CASE(DMUS_REQUESTED_CAPS, 7);
//     V_STRUCTPTR_READ_VER_CASE(DMUS_REQUESTED_CAPS, 8);
//     V_STRUCTPTR_READ_VER_END_(DMUS_REQUESTED_CAPS, pCaps);
//
//     // At this point, if we are still in the function we have a valid pCaps
//     // pointer and dwCapsVer is either 7 or 8, indicating the version of
//     // the struct passed in.
//
//     ...
// }
//
#ifndef _VALIDATE_H_
#define _VALIDATE_H_


#ifdef DBG
#include <stddef.h>

#include "debug.h"

// To turn on DebugBreak on parameter error, use the following or -DRIP_BREAK in the build:
//
//#define RIP_BREAK 1

#ifdef RIP_BREAK
#define _RIP_BREAK DebugBreak();
#else
#define _RIP_BREAK 
#endif

#define V_INAME(x) \
    static const char __szValidateInterfaceName[] = #x;                       

#define RIP_E_POINTER(ptr) \
{   Trace(-1, "%s: Invalid pointer " #ptr "\n", __szValidateInterfaceName); \
    _RIP_BREAK \
    return E_POINTER; }

#define RIP_E_INVALIDARG(ptr) \
{   Trace(-1, "%s: Invalid argument " #ptr "\n", __szValidateInterfaceName); \
    _RIP_BREAK \
    return E_INVALIDARG; }

#define RIP_E_HANDLE(h) \
{	Trace(-1, "%s: Invalid handle " #h "\n", __szValidateInterfaceName); \
    _RIP_BREAK \
	return E_HANDLE; }
    
#define RIP_W_INVALIDSIZE(ptr) \
{   Trace(-1, "%s: " #ptr "->dwSize matches no known structure size. Defaulting to oldest structure.\n", \
    __szValidateInterfaceName); \
    _RIP_BREAK \
    }
    
#define RIP_E_INVALIDSIZE(ptr) \
{   Trace(-1, "%s: " #ptr "->dwSize is too small\n", __szValidateInterfaceName); \
    _RIP_BREAK \
    return E_INVALIDARG; }
    
#define RIP_E_BLOCKVSDWSIZE(ptr) \
{   Trace(-1, "%s: " #ptr " does not point to as much memory as " #ptr "->dwSize indicates\n", \
    __szValidateInterfaceName); \
    _RIP_BREAK \
    return E_INVALIDARG; }    

// NOTE: The DebugBreak() not in #ifdef is intentional - this is something that
// must be fixed in our code, not an app-generated error.
//
#define V_ASSERT(exp) \
{   if (!(exp)) { \
        Trace(-1, "%s@%s: %s\n", __FILE__, __LINE__, #exp); \
        DebugBreak(); }}

#else

#define V_INAME(x)
#define RIP_E_POINTER(ptr)          { return E_POINTER; }
#define RIP_E_INVALIDARG(ptr)       { return E_INVALIDARG; }
#define RIP_E_HANDLE(h)	            { return E_HANDLE; }
#define RIP_E_BLOCKVSDWSIZE(ptr)    { return E_INVALIDARG; }
#define RIP_W_INVALIDSIZE(ptr)
#define RIP_E_INVALIDSIZE(ptr)      { return E_INVALIDARG; }
#define V_ASSERT(exp)

#endif          // DBG

// A passed struct we will only read from or may write to. Must be a struct
// with a dwSize.
//
// int foo(CFoo *pFoo)
// ...
// V_STRUCTPTR_READ(pFoo, CFoo);
// V_STRUCTPTR_WRITE(pFoo, CFoo);
//
// Use _PTR_ variants for structs w/o a dwSize
//
#define V_STRUCTPTR_READ(ptr,type) \
{   V_ASSERT(offsetof(type, dwSize) == 0); \
    if (IsBadReadPtr(ptr, sizeof(DWORD)))               RIP_E_BLOCKVSDWSIZE(ptr); \
	if (ptr->dwSize < sizeof(type))						RIP_E_INVALIDSIZE(ptr); \
    if (IsBadReadPtr(ptr, (ptr)->dwSize))               RIP_E_BLOCKVSDWSIZE(ptr); }

#define V_STRUCTPTR_WRITE(ptr,type) \
{   V_ASSERT(offsetof(type, dwSize) == 0); \
    if (IsBadReadPtr(ptr, sizeof(DWORD)))               RIP_E_BLOCKVSDWSIZE(ptr); \
	if (ptr->dwSize < sizeof(type))						RIP_E_INVALIDSIZE(ptr); \
    if (IsBadWritePtr(ptr, (ptr)->dwSize))              RIP_E_BLOCKVSDWSIZE(ptr); }

#define V_PTR_READ(ptr,type) \
{ if (IsBadReadPtr(ptr, sizeof(type)))                  RIP_E_POINTER(ptr); }

#define V_PTR_WRITE(ptr,type) \
{ if (IsBadWritePtr(ptr, sizeof(type)))                 RIP_E_POINTER(ptr); }

#define V_PTR_WRITE_OPT(ptr,type) \
{ if (ptr) if (IsBadWritePtr(ptr, sizeof(type)))        RIP_E_POINTER(ptr); }

// A buffer pointer with separate length (not defined by the pointer type) we will only
// read from or may write to.
//
// int foo(LPVOID *pBuffer, DWORD cbBuffer)
// ...
// V_BUFPTR_READ(pBuffer, cbBuffer);
// V_BUFPTR_WRITE(pBuffer, cbBuffer);
//
#define V_BUFPTR_READ(ptr,len) \
{   if (IsBadReadPtr(ptr, len))                         RIP_E_POINTER(ptr); }

#define V_BUFPTR_READ_OPT(ptr,len) \
{	if (ptr) V_BUFPTR_READ(ptr,len); }

#define V_BUFPTR_WRITE(ptr,len) \
{   if (IsBadWritePtr(ptr, len))                        RIP_E_POINTER(ptr); }

#define V_BUFPTR_WRITE_OPT(ptr,len) \
{	if (ptr) V_BUFPTR_WRITE(ptr,len); }

// A pointer to a pointer (such as a pointer to an interface pointer) to return
//
// int foo(IReturnMe **ppRet)
// ...
// V_PTRPTR_WRITE(ppRet);
// V_PTRPTR_WRITE_OPT(ppRet);
//
#define V_PTRPTR_WRITE(ptr) \
{   if (IsBadWritePtr(ptr, sizeof(void*)))              RIP_E_POINTER(ptr); }

#define V_PTRPTR_WRITE_OPT(ptr) \
{   if (ptr) if (IsBadWritePtr(ptr, sizeof(void*)))     RIP_E_POINTER(ptr); }

// A pointer to a controlling unknown
//
#define V_PUNKOUTER(punk) \
{   if (punk && IsBadCodePtr(punk))                     RIP_E_POINTER(ptr); }

// A pointer to a controlling unknown for which we don't support aggregation
//
#define V_PUNKOUTER_NOAGG(punk) \
{   if (punk && IsBadReadPtr(punk, sizeof(IUnknown)))   RIP_E_POINTER(ptr); \
    if (punk) return CLASS_E_NOAGGREGATION; }

// Validate an incoming interface pointer. 
//
struct _V_GENERIC_INTERFACE
{
    FARPROC *(__vptr[1]);
};

#define V_INTERFACE(ptr) \
{   if (IsBadReadPtr(ptr, sizeof(_V_GENERIC_INTERFACE)))                              RIP_E_POINTER(ptr); \
    if (IsBadReadPtr(*reinterpret_cast<_V_GENERIC_INTERFACE*>(ptr)->__vptr, sizeof(FARPROC))) \
                                                                                      RIP_E_POINTER(ptr); \
    if (IsBadCodePtr(*(reinterpret_cast<_V_GENERIC_INTERFACE*>(ptr)->__vptr)[0]))     RIP_E_POINTER(ptr); }

#define V_INTERFACE_OPT(ptr) \
{   if (ptr) V_INTERFACE(ptr); }

// Validation for a reference to a GUID, which we only ever read. 
//
#define V_REFGUID(ref) \
{   if (IsBadReadPtr((void*)&ref, sizeof(GUID)))        RIP_E_POINTER((void*)&ref); }

// Validation for a window handle
//
#define V_HWND(h) \
{	if (!IsWindow(h))									RIP_E_HANDLE(h); }	

#define V_HWND_OPT(h) \
{	if (h) if (!IsWindow(h))							RIP_E_HANDLE(h); }	

// Validation for multiple sized structs based on version
//
#define V_STRUCTPTR_READ_VER(ptr,ver) \
{   ver = 7; DWORD *pdw = &ver;  \
    if (IsBadReadPtr(ptr, sizeof(DWORD)))               RIP_E_BLOCKVSDWSIZE(ptr); \
    if (IsBadReadPtr(ptr, (ptr)->dwSize))               RIP_E_BLOCKVSDWSIZE(ptr); \
    switch ((ptr)->dwSize) {
    
#define V_STRUCTPTR_READ_VER_CASE(basetype,ver) \
    case sizeof(basetype##ver) : \
    V_ASSERT(offsetof(basetype##ver, dwSize) == 0); \
    *pdw = ver; break;
    
#define V_STRUCTPTR_READ_VER_END(basetype,ptr) \
    default : if ((ptr)->dwSize > sizeof(basetype##7)) \
    { RIP_W_INVALIDSIZE(ptr); } else \
    RIP_E_INVALIDSIZE(ptr); }}


#define V_STRUCTPTR_WRITE_VER(ptr,ver) \
{   ver = 7; DWORD *pdw = &ver;  \
    if (IsBadReadPtr(ptr, sizeof(DWORD)))               RIP_E_BLOCKVSDWSIZE(ptr); \
    if (IsBadWritePtr(ptr, (ptr)->dwSize))              RIP_E_BLOCKVSDWSIZE(ptr); \
    switch ((ptr)->dwSize) {
    
#define V_STRUCTPTR_WRITE_VER_CASE(basetype,ver) \
    case sizeof(basetype##ver) : \
        V_ASSERT(offsetof(basetype##ver, dwSize) == 0); \
        *pdw = ver; break;
    
#define V_STRUCTPTR_WRITE_VER_END(basetype,ptr) \
    default : if ((ptr)->dwSize > sizeof(basetype##7)) \
    { RIP_W_INVALIDSIZE(ptr); } else \
    RIP_E_INVALIDSIZE(ptr); }}



#endif          // _VALIDATE_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\XDmime\alist.cpp ===
// Copyright (c) 1998-1999 Microsoft Corporation
//
// alist.cpp
//
#include "alist.h"

LONG AListItem::GetCount(void) const
{
    LONG l;
    const AListItem *li;

    for(l=0,li=this; li!=NULL ; li=li->m_pNext,++l);
    return l;
}

AListItem* AListItem::Cat(AListItem *pItem)
{
    AListItem *li;

    if(this==NULL)
        return pItem;
    for(li=this ; li->m_pNext!=NULL ; li=li->m_pNext);
    li->m_pNext=pItem;
    return this;
}

AListItem* AListItem::Remove(AListItem *pItem)
{
    AListItem *li,*prev;

    //treat remove(NULL) same as item not found in list
   if (pItem==NULL) 
   return this;

    if(pItem==this)
    {
        li = m_pNext;
        m_pNext = NULL;
        return li;
    }
    prev=NULL;
    for(li=this; li!=NULL && li!=pItem ; li=li->m_pNext)
        prev=li;
    if(li==NULL)     // item not found in list
        return this;

//  here it is guaranteed that prev is non-NULL since we checked for
//  that condition at the very beginning

    prev->SetNext(li->m_pNext);
    li->SetNext(NULL);

    // SetNext on pItem to NULL
    pItem->SetNext(NULL);

    return this;
}

AListItem* AListItem::GetPrev(AListItem *pItem) const
{
    const AListItem *li,*prev;

    prev=NULL;
    for(li=this ; li!=NULL && li!=pItem ; li=li->m_pNext)
        prev=li;
    return (AListItem*)prev;
}

AListItem * AListItem::GetItem(LONG index)

{
	AListItem *scan;
	for (scan = this; scan!=NULL && index; scan = scan->m_pNext) 
	{
		index--;
	}
	return (scan);
}

void AList::InsertBefore(AListItem *pItem,AListItem *pInsert)

{
	AListItem *prev = GetPrev(pItem);
	pInsert->SetNext(pItem);
	if (prev) prev->SetNext(pInsert);
	else m_pHead = pInsert;
}

void AList::AddTail(AListItem *pItem)
{
    if (m_pHead == NULL)
    {
        AddHead(pItem);
    }
    else
    {
        m_pHead = m_pHead->AddTail(pItem);
    }
}

void AList::Reverse()

{
    AList Temp;
    AListItem *pItem;
    while (pItem = RemoveHead())
    {
        Temp.AddHead(pItem);
    }
    m_pHead = Temp.GetHead();
}

BOOL AList::IsMember(AListItem *pItem)

{
    AListItem *pScan = GetHead();
    for (;pScan;pScan = pScan->GetNext())
    {
        if (pItem == pScan) return TRUE;
    }
    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\XDmime\alist.h ===
// Copyright (c) 1998-1999 Microsoft Corporation
//
// alist.h
//
#ifndef __ALIST_H__
#define __ALIST_H__

#include <windows.h>

class AListItem
{
public:
    AListItem() { m_pNext=NULL; };
    AListItem *GetNext() const {return m_pNext;};
    void SetNext(AListItem *pNext) {m_pNext=pNext;};
    LONG GetCount() const;
    AListItem* Cat(AListItem* pItem);
    AListItem* AddTail(AListItem* pItem) {return Cat(pItem);};
    AListItem* Remove(AListItem* pItem);
    AListItem* GetPrev(AListItem *pItem) const;
    AListItem* GetItem(LONG index);

protected:
    AListItem *m_pNext;
};

class AList
{
public:
    AList() {m_pHead=NULL;};
    AListItem *GetHead() const { return m_pHead;};

    void RemoveAll() { m_pHead=NULL;};
    LONG GetCount() const {return m_pHead->GetCount();}; 
    AListItem *GetItem(LONG index) { return m_pHead->GetItem(index);}; 
    void InsertBefore(AListItem *pItem,AListItem *pInsert);
    void Cat(AListItem *pItem) {m_pHead=m_pHead->Cat(pItem);};
    void Cat(AList *pList)
        {
//            assert(pList!=NULL);
            if (pList)
            {
                m_pHead=m_pHead->Cat(pList->GetHead());
            }
        };
    void AddHead(AListItem *pItem)
        {
            if (pItem!=NULL)
            {
                pItem->SetNext(m_pHead);
                m_pHead=pItem;
            }
        };
    void AddTail(AListItem *pItem);// {m_pHead=m_pHead->AddTail(pItem);};
    void Remove(AListItem *pItem) 
        {
            if (pItem != NULL)
            {
                m_pHead=m_pHead->Remove(pItem);
            }
        };
    AListItem *GetPrev(AListItem *pItem) const {return m_pHead->GetPrev(pItem);};
    AListItem *GetTail() const {return GetPrev(NULL);};
    BOOL IsEmpty(void) const {return (m_pHead==NULL);};
    BOOL IsMember(AListItem *pItem);
    AListItem *RemoveHead(void)
        {
            AListItem *li;
            li = m_pHead;
            if(m_pHead)
            {
                m_pHead = m_pHead->GetNext();
                li->SetNext(NULL);
            }
            return li;
        }
    void Reverse();

protected:
    AListItem *m_pHead;
};

#endif // __ALIST_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\XboxSynth\shared\validp.h ===
// Copyright (c) 1998 Microsoft Corporation
// ValidP.h --- An inline function to test for valid pointers

#ifndef __VALID_P__
#define __VALID_P__

// The debug version checks for Null pointers and pointers to unreadable/unwriteable data.
// (NOTE: only the first byte pointed to is checked)
// The non-debug version just checks for Null pointers.

template <class T>
inline BOOL Validate(T *p)
{ 
#ifdef _DEBUG
	return (p != NULL) && !IsBadReadPtr(p, 1) && !IsBadWritePtr(p, 1);
#else
	return p != NULL;
#endif
}

/* Use:

  Foo *pFoo;
  //
  // stuff...
  //
  if (Validate(pFoo))
  {
     // do stuff with the pointer
  }
  else
  {
     // don't do stuff with the pointer
  }

*/

#endif // __VALID_P__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\XboxSynth\shared\trackhelp.inl ===
// Copyright (c) 1999 Microsoft Corporation. All rights reserved.
//
// Base classes that implement aspects of a standard DirectMusic track.
// Implementations for CPlayingTrack.
//

//////////////////////////////////////////////////////////////////////
// Creation

template<class T, class EventItem, class StateData>
CPlayingTrack<T, EventItem, StateData>::CPlayingTrack(
		long *plModuleLockCounter,
		const CLSID &rclsid,
		bool fNeedsLoader,
		bool fPlayInvalidations)
  : m_dwValidate(0),
	m_fNeedsLoader(fNeedsLoader),
	m_fPlayInvalidations(fPlayInvalidations),
	CBasicTrack(plModuleLockCounter, rclsid)
{
}

//////////////////////////////////////////////////////////////////////
// IPersistStream

// Function used to sort the event list according to trigger time.
template<class EventItem>
struct CmpStruct //  shouldn't need this, but I had trouble getting a straight templated function to match the function pointer with the NT compiler.  try again later with the new one.
{
	static BOOL EventCompare(EventItem &ri1, EventItem &ri2)
	{
		return ri1.lTriggerTime < ri2.lTriggerTime;
	}
};

template<class T, class EventItem, class StateData>
STDMETHODIMP
CPlayingTrack<T, EventItem, StateData>::Load(IStream* pIStream)
{
	V_INAME(CPlayingTrack::Load);
	V_INTERFACE(pIStream);
	HRESULT hr = S_OK;

	SmartRef::CritSec CS(&m_CriticalSection);

	// Clear the event list in case we're being reloaded.
	m_EventList.CleanUp();
	// Increment counter so the next play will update state data with the new list.
	++m_dwValidate;

	// Get the loader if requested in constructor
	SmartRef::ComPtr<IDirectMusicLoader> scomLoader;
	if (m_fNeedsLoader)
	{
		IDirectMusicGetLoader *pIGetLoader;
		hr = pIStream->QueryInterface(IID_IDirectMusicGetLoader, reinterpret_cast<void**>(&pIGetLoader));
		if (FAILED(hr))
			return hr;
		hr = pIGetLoader->GetLoader(&scomLoader);
		pIGetLoader->Release();
		if (FAILED(hr))
			return hr;
	}

	SmartRef::RiffIter ri(pIStream);
	if (!ri)
		return ri.hr();

	hr = this->LoadRiff(ri, scomLoader);
	if (FAILED(hr))
		return hr;

	m_EventList.MergeSort(CmpStruct<EventItem>::EventCompare);

	return hr;
}

//////////////////////////////////////////////////////////////////////
// IDirectMusicTrack

template<class T, class EventItem, class StateData>
STDMETHODIMP
CPlayingTrack<T, EventItem, StateData>::InitPlay(
		IDirectMusicSegmentState *pSegmentState,
		IDirectMusicPerformance *pPerformance,
		void **ppStateData,
		DWORD dwTrackID,
		DWORD dwFlags)
{
	V_INAME(CPlayingTrack::InitPlay);
	V_PTRPTR_WRITE(ppStateData);
	V_INTERFACE(pSegmentState);
	V_INTERFACE(pPerformance);

	SmartRef::CritSec CS(&m_CriticalSection);

	// Set up state data
	StateData *pStateData = new StateData;
	if (!pStateData)
		return E_OUTOFMEMORY;

	*ppStateData = pStateData;

	return S_OK;
}

template<class T, class EventItem, class StateData>
STDMETHODIMP
CPlayingTrack<T, EventItem, StateData>::EndPlay(void *pStateData)
{
	V_INAME(CPlayingTrack::EndPlay);
	V_BUFPTR_WRITE(pStateData, sizeof(StateData));

	SmartRef::CritSec CS(&m_CriticalSection);

	StateData *pSD = static_cast<StateData *>(pStateData);
	delete pSD;

	return S_OK;
}

template<class T, class EventItem, class StateData>
STDMETHODIMP
CPlayingTrack<T, EventItem, StateData>::Clone(
		MUSIC_TIME mtStart,
		MUSIC_TIME mtEnd,
		IDirectMusicTrack** ppTrack)
{
	V_INAME(CPlayingTrack::Clone);
	V_PTRPTR_WRITE(ppTrack);

	SmartRef::CritSec CS(&m_CriticalSection);

	HRESULT hr = S_OK;

	T *pTrack = new T(&hr);
	if (FAILED(hr))
		return hr;
	*ppTrack = pTrack;
	if (!pTrack)
		return E_OUTOFMEMORY;

	pTrack->AddRef();
	for (TListItem<EventItem> *pItem = m_EventList.GetHead();
			pItem;
			pItem = pItem->GetNext())
	{
		EventItem &ritem = pItem->GetItemValue();
		if (ritem.lTriggerTime >= mtEnd)
			break;
		if (ritem.lTriggerTime < mtStart)
			continue;

		TListItem<EventItem> *pNewItem = new TListItem<EventItem>;
		if (!pNewItem)
		{
			hr = E_OUTOFMEMORY;
			goto End;
		}

		EventItem &rnew = pNewItem->GetItemValue();
		hr = rnew.Clone(ritem, mtStart);
		if (FAILED(hr))
		{
			delete pNewItem;
			goto End;
		}
		pTrack->m_EventList.AddHead(pNewItem);
	}
	pTrack->m_EventList.Reverse();
	++pTrack->m_dwValidate;

End:
	if (FAILED(hr))
		pTrack->Release();
	return hr;
}

template<class T, class EventItem, class StateData>
HRESULT
CPlayingTrack<T, EventItem, StateData>::PlayMusicOrClock(
	void *pStateData,
	MUSIC_TIME mtStart,
	MUSIC_TIME mtEnd,
	MUSIC_TIME mtOffset,
	REFERENCE_TIME rtOffset,
	DWORD dwFlags,
	IDirectMusicPerformance* pPerf,
	IDirectMusicSegmentState* pSegSt,
	DWORD dwVirtualID,
	bool fClockTime)
{
	V_INAME(CPlayingTrack::Play);
	V_BUFPTR_WRITE( pStateData, sizeof(StateData));
	V_INTERFACE(pPerf);
	V_INTERFACE(pSegSt);

	if (dwFlags & DMUS_TRACKF_PLAY_OFF)
		return S_OK;

	SmartRef::CritSec CS(&m_CriticalSection);

	StateData *pSD = static_cast<StateData *>(pStateData);
	TListItem<EventItem> *li = pSD->pCurrentEvent;

	// Seek through the event list to find the proper first event if
	// the event list pointed to by the state data has been reloaded
	// or if playback has made a jump to a different position in the track.
	if (m_dwValidate != pSD->dwValidate ||
			dwFlags & (DMUS_TRACKF_SEEK | DMUS_TRACKF_LOOP | DMUS_TRACKF_FLUSH))
	{
		assert(m_dwValidate != pSD->dwValidate || dwFlags & DMUS_TRACKF_SEEK); // by contract SEEK should be set whenever the other dwFlags are
		li = this->Seek(mtStart);
		pSD->dwValidate = m_dwValidate;
	}

	if (m_fPlayInvalidations || !(dwFlags & DMUS_TRACKF_FLUSH))
	{
		for (; li; li = li->GetNext())
		{
			EventItem &rinfo = li->GetItemValue();
			if (rinfo.lTriggerTime < mtStart) // this can happen if DMUS_TRACKF_PLAY_OFF was set and the seek pointer remains at events from the past
				continue;
			if (rinfo.lTriggerTime >= mtEnd)
				break;
			if (FAILED(this->PlayItem(rinfo, *pSD, pPerf, pSegSt, dwVirtualID, mtOffset, rtOffset, fClockTime)))
			{
				// Returning an error from Play is not allowed.  Just ignore it and assert
				// so we would detect this while testing.
				assert(false);
				continue;
			}
		}
	}

	pSD->pCurrentEvent = li;
	return li ? S_OK : DMUS_S_END;
}

template<class T, class EventItem, class StateData>
TListItem<EventItem> *
CPlayingTrack<T, EventItem, StateData>::Seek(MUSIC_TIME mtStart)
{
	TListItem<EventItem> *li;
	for (li = m_EventList.GetHead();
			li && li->GetItemValue().lTriggerTime < mtStart;
			li = li->GetNext())
	{}

	return li;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\XboxSynth\shared\trackhelp.h ===
// Copyright (c) 1999 Microsoft Corporation. All rights reserved.
//
// Base classes that implement aspects of a standard DirectMusic track.
// Unless you're doing something pretty unusual, you should be able to inherit from one
//    of these classes and reduce the work needed to implement a new track type.
//
// * CBasicTrack
//    Contains stubs that no-op or return notimpl most track methods.
//    You implement Load, InitPlay, EndPlay, PlayMusicOrClock, and Clone.
//
// * CPlayingTrack
//    CBasicTrack plus standard implementations of InitPlay, EndPlay, Clone.
//    PlayMusicOrClock and Load are partially implemented.  You fill in the rest by implementing
//       the methods PlayItem and LoadRiff.
//    You also must implement classes for event items and (optionally) state data.

#pragma once

#include "dmusici.h"
#include "validate.h"
#include "miscutil.h"
#include "tlist.h"
#include "smartref.h"


const int gc_RefPerMil = 10000; // Value for converting from reference time to milliseconds


//////////////////////////////////////////////////////////////////////
// TrackHelpCreateInstance
// Standard implementation of CreateInstance to call from class factory templated on
// the type of your derived class.  Your class constructor must take an HRESULT pointer
// it can use to return an error.

template <class T>
HRESULT TrackHelpCreateInstance(IUnknown* pUnknownOuter, const IID& iid, void** ppv, T *pUnused = NULL)
{
	// 
	// pUnused is just a dummy to force generation of the correct template type T.
	// Compiler bug?

	*ppv = NULL;
	if (pUnknownOuter)
		 return CLASS_E_NOAGGREGATION;

	HRESULT hr = S_OK;
	T *pInst = new T(&hr);
	if (pInst == NULL)
		return E_OUTOFMEMORY;
	if (FAILED(hr))
		return hr;

	return pInst->QueryInterface(iid, ppv);
}

//////////////////////////////////////////////////////////////////////
// CBasicTrack
//
// Base class with a standard implementation the following aspects of a DirectMusic track:
// - IUnknown: AddRef, Release, and QueryInterface (QI for IUnknown, IDirectMusicTrack, IDirectMusicTrack8, IPersistStream, IPersist)
// - IPersistStrea: stubs out GetClassID, IsDirty, Save, and GetSizeMax.
// - IDirectMusicTrack:
//      stubs out IsParamSupported, Init, GetParam, SetParam, AddNotificationType, RemoveNotificationType.
//      implements millisecond time conversion for PlayEx, GetParamEx, SetParamEx.
// - Declares and initializes a critical section.
//
// Pure virtual functions you must implement:
// - Load
// - InitPlay
// - EndPlay
// - Clone
// - PlayMusicOrClock (single method called by both Play and PlayEx)

class CBasicTrack
  : public IPersistStream,
	public IDirectMusicTrack8
{
public:
	// IUnknown
	STDMETHOD(QueryInterface)(const IID &iid, void **ppv);
	STDMETHOD_(ULONG, AddRef)();
	STDMETHOD_(ULONG, Release)();

	// IPersistStream functions
	STDMETHOD(GetClassID)(CLSID* pClassID);
	STDMETHOD(IsDirty)() {return S_FALSE;}
	STDMETHOD(Load)(IStream* pStream) = 0;
	STDMETHOD(Save)(IStream* pStream, BOOL fClearDirty) {return E_NOTIMPL;}
	STDMETHOD(GetSizeMax)(ULARGE_INTEGER* pcbSize) {return E_NOTIMPL;}

	// IDirectMusicTrack methods
	STDMETHOD(IsParamSupported)(REFGUID rguid) {return DMUS_E_TYPE_UNSUPPORTED;}
	STDMETHOD(Init)(IDirectMusicSegment *pSegment);
	STDMETHOD(InitPlay)(
		IDirectMusicSegmentState *pSegmentState,
		IDirectMusicPerformance *pPerformance,
		void **ppStateData,
		DWORD dwTrackID,
		DWORD dwFlags) = 0;
	STDMETHOD(EndPlay)(void *pStateData) = 0;
	STDMETHOD(Play)(
		void *pStateData,
		MUSIC_TIME mtStart,
		MUSIC_TIME mtEnd,
		MUSIC_TIME mtOffset,
		DWORD dwFlags,
		IDirectMusicPerformance* pPerf,
		IDirectMusicSegmentState* pSegSt,
		DWORD dwVirtualID);
	STDMETHOD(GetParam)(REFGUID rguid,MUSIC_TIME mtTime,MUSIC_TIME* pmtNext,void *pData) {return DMUS_E_GET_UNSUPPORTED;}
	STDMETHOD(SetParam)(REFGUID rguid,MUSIC_TIME mtTime,void *pData) {return DMUS_E_SET_UNSUPPORTED;}
	STDMETHOD(AddNotificationType)(REFGUID rguidNotification) {return E_NOTIMPL;}
	STDMETHOD(RemoveNotificationType)(REFGUID rguidNotification) {return E_NOTIMPL;}
	STDMETHOD(Clone)(MUSIC_TIME mtStart,MUSIC_TIME mtEnd,IDirectMusicTrack** ppTrack) = 0;

	// IDirectMusicTrack8
	STDMETHODIMP PlayEx(
		void* pStateData,
		REFERENCE_TIME rtStart,
		REFERENCE_TIME rtEnd,
		REFERENCE_TIME rtOffset,
		DWORD dwFlags,
		IDirectMusicPerformance* pPerf,
		IDirectMusicSegmentState* pSegSt,
		DWORD dwVirtualID);
	STDMETHODIMP GetParamEx(REFGUID rguidType, REFERENCE_TIME rtTime, REFERENCE_TIME* prtNext, void* pParam, void * pStateData, DWORD dwFlags);
    STDMETHODIMP SetParamEx(REFGUID rguidType,REFERENCE_TIME rtTime,void* pParam, void * pStateData, DWORD dwFlags) ;
    STDMETHODIMP Compose(IUnknown* pContext, 
		DWORD dwTrackGroup,
		IDirectMusicTrack** ppResultTrack) ;
    STDMETHODIMP Join(IDirectMusicTrack* pNewTrack,
		MUSIC_TIME mtJoin,
		IUnknown* pContext,
		DWORD dwTrackGroup,
		IDirectMusicTrack** ppResultTrack) ;

protected:
	// plModuleLockCounter: a pointer to your .dll's lock counter that will be incremented/decremented when the track is created/destroyed
	// rclsid: the classid of your track
	CBasicTrack(long *plModuleLockCounter, const CLSID &rclsid); // Takes pointer to lock counter to increment and decrement on component creation/destruction.  Typically, pass &g_cComponent and the clsid of your track.
	virtual ~CBasicTrack() { InterlockedDecrement(m_plModuleLockCounter); }

	// Shared implentation of play for either music or clock time.
	virtual HRESULT PlayMusicOrClock(
		void *pStateData,
		MUSIC_TIME mtStart,
		MUSIC_TIME mtEnd,
		MUSIC_TIME mtOffset,
		REFERENCE_TIME rtOffset,
		DWORD dwFlags,
		IDirectMusicPerformance* pPerf,
		IDirectMusicSegmentState* pSegSt,
		DWORD dwVirtualID,
		bool fClockTime) = 0;

	// Use this critical section to guard entry points for thread safety
	CRITICAL_SECTION m_CriticalSection;

private:
	long m_cRef;
	long *m_plModuleLockCounter;
	const CLSID &m_rclsid;
};

//////////////////////////////////////////////////////////////////////
// CPlayingTrack
//
// Base class that provides standard implementations of InitPlay, EndPlay, and Clone.
// Also, partially implemented are:
//  - PlayMusicOrClock.  You must implement the pure virual function PlayItem, which is
//    called during play as each event needs to be performed.
//  - Load.  This just does a few standard things (clearing the event list, incrementing the
//    state data counter, optionally getting the loader, and sorting the results).  It
//    depends on your implementation of the pure virtual function LoadRiff that you must
//    implement to do the real processing.
// Template types required:
//    T: Your derived class (needed for New in clone).  Must have a constructor that takes a pointer to an HRESULT.
//    StateData: Type for your state data.  Must contain dwValidate, used to check if the track has been reloaded, and pCurrentEvent, a pointer to the next event item to be played.
//    EventItem: Type for the event items in your track.  Must contain lTriggerTime, which is the time during Play when PlayItem will be called.  Must implement Clone, which copies another EventItem, shifting it back according to a start MUSIC_TIME.

// Standard state data for use with CPlayingTrack.  Or inherit from it and add more information.
template<class EventItem>
struct CStandardStateData
{
	CStandardStateData() : dwValidate(0), pCurrentEvent(NULL) {}
	DWORD dwValidate;
	TListItem<EventItem> *pCurrentEvent;
};

template<class T, class EventItem, class StateData = CStandardStateData<EventItem> >
class CPlayingTrack
  : public CBasicTrack
{
public:
	typedef StateData statedata;

	STDMETHOD(Load)(IStream* pIStream);
	STDMETHOD(InitPlay)(
		IDirectMusicSegmentState *pSegmentState,
		IDirectMusicPerformance *pPerformance,
		void **ppStateData,
		DWORD dwTrackID,
		DWORD dwFlags);
	STDMETHOD(EndPlay)(void *pStateData);
	STDMETHOD(Clone)(MUSIC_TIME mtStart,MUSIC_TIME mtEnd,IDirectMusicTrack** ppTrack);
	virtual HRESULT PlayMusicOrClock(
		void *pStateData,
		MUSIC_TIME mtStart,
		MUSIC_TIME mtEnd,
		MUSIC_TIME mtOffset,
		REFERENCE_TIME rtOffset,
		DWORD dwFlags,
		IDirectMusicPerformance* pPerf,
		IDirectMusicSegmentState* pSegSt,
		DWORD dwVirtualID,
		bool fClockTime);

protected:
	// plModuleLockCounter: a pointer to your .dll's lock counter that will be incremented/decremented when the track is created/destroyed
	// rclsid: the classid of your track
	// fNeedsLoader: pass true if you will need a reference to the loader when your LoadRiff method is called
	// fPlayInvalidations: if true, then your items will be played more than once when an invalidation occurs
	//						pass false if your track doesn't want to respond to invalidations
	CPlayingTrack(long *plModuleLockCounter, const CLSID &rclsid, bool fNeedsLoader, bool fPlayInvalidations);

	virtual HRESULT PlayItem(
		const EventItem &item,
		StateData &state,
		IDirectMusicPerformance *pPerf,
		IDirectMusicSegmentState* pSegSt,
		DWORD dwVirtualID,
		MUSIC_TIME mtOffset,
		REFERENCE_TIME rtOffset,
		bool fClockTime) = 0; // feel free to add additional parameters if you need to pass more information from Play
	virtual HRESULT LoadRiff(SmartRef::RiffIter &ri, IDirectMusicLoader *pIDMLoader) = 0; // note that pIDMLoader will be null unless true is passed for fNeedsLoader in constructor

	virtual TListItem<EventItem> *Seek(MUSIC_TIME mtStart); // this method is provided in case you want to inherit and intercept when a seek is happening

	// Increment this counter in Load, causing the state data to synchonize with the new events
	DWORD m_dwValidate;
	TList<EventItem> m_EventList;
	bool m_fNeedsLoader;
	bool m_fPlayInvalidations;
};

#include "trackhelp.inl"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\XDmime\aariff.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (c) 1998-1998 Microsoft Corporation
//
//  File:       aariff.h
//
//--------------------------------------------------------------------------

//
// aariff.h
//

#ifndef __AARIFF__
#define __AARIFF__
#include <windows.h>
#include <mmsystem.h>
#include <objbase.h>
#define FixBytes(a1,a2)

// {0D5057E1-8889-11CF-B9DA-00AA00C08146}
DEFINE_GUID( IID_IAARIFFStream, 0xd5057e1, 0x8889, 0x11cf, 0xb9, 0xda, 0x0, 0xaa, 0x0, 0xc0, 0x81, 0x46 );
#undef INTERFACE
#define INTERFACE IAARIFFStream
DECLARE_INTERFACE_(IAARIFFStream, IUnknown)
{
    // IUnknown members
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID *ppv) PURE;
    STDMETHOD_(ULONG, AddRef)(THIS) PURE;
    STDMETHOD_(ULONG, Release)(THIS) PURE;

    // IMKRIFFStream members
    STDMETHOD_(UINT, Descend)(LPMMCKINFO lpck, LPMMCKINFO lpckParent, UINT wFlags) PURE;
    STDMETHOD_(UINT, Ascend)(LPMMCKINFO lpck, UINT wFlags) PURE;
    STDMETHOD_(UINT, CreateChunk)(LPMMCKINFO lpck, UINT wFlags) PURE;
    STDMETHOD(SetStream)(LPSTREAM pStream) PURE;
    STDMETHOD_(LPSTREAM, GetStream)() PURE;
};

struct CFileStream : IStream
{
///// object state
    ULONG           m_cRef;         // object reference count
    HANDLE          m_hfile;        // file handle

// construction and destruction
    CFileStream( HANDLE hfile ) : m_cRef( 1 ), m_hfile( hfile ) {}
#ifdef _MAC
    ~CFileStream() { FSClose( (int) m_hfile ); }
#else
    ~CFileStream() { CloseHandle( m_hfile ); }
#endif

///// IUnknown methods
    STDMETHODIMP QueryInterface( REFIID riid, LPVOID FAR* ppvObj )
    {
        if( IsEqualIID( riid, IID_IUnknown ) ||
            IsEqualIID( riid, IID_IStream ) )
        {
            *ppvObj = (IStream *) this;
            AddRef();
            return NOERROR;
        }
        *ppvObj = NULL;
        return E_NOINTERFACE;
    }
    STDMETHODIMP_(ULONG) AddRef()
    {
        return ++m_cRef;
    }
    STDMETHODIMP_(ULONG) Release()
    {
        if( --m_cRef == 0L )
        {
            delete this;
            return 0;
        }
       return m_cRef;
    }

    /* IStream methods */
    STDMETHODIMP Read( void* pv, ULONG cb, ULONG* pcbRead )
    {
		DWORD dw;

		if( ReadFile( m_hfile, pv, cb, &dw, NULL ) &&
			dw == cb )
		{
			if( pcbRead != NULL )
			{
				*pcbRead = dw;
			}
			return S_OK;
		}
		return E_FAIL;
    }
    STDMETHODIMP Write( const void* pv, ULONG cb, ULONG* pcbWritten )
    {
		DWORD dw;

		if( WriteFile( m_hfile, pv, cb, &dw, NULL ) &&
			dw == cb )
		{
			if( pcbWritten != NULL )
			{
				*pcbWritten = dw;
			}
			return S_OK;
		}
        return E_FAIL;
	}
    STDMETHODIMP Seek( LARGE_INTEGER dlibMove, DWORD dwOrigin, ULARGE_INTEGER* plibNewPosition )
    {
		DWORD dw;

		dw = SetFilePointer( m_hfile, dlibMove.LowPart, &dlibMove.HighPart, dwOrigin );
		if( dw == (DWORD)-1 )
		{
			return E_FAIL;
		}
		if( plibNewPosition != NULL )
		{
			plibNewPosition->LowPart = dw;
	        plibNewPosition->HighPart = dlibMove.HighPart;
		}
        return S_OK;
	}
    STDMETHODIMP SetSize( ULARGE_INTEGER /*libNewSize*/ )
    { return E_NOTIMPL; }
    STDMETHODIMP CopyTo( IStream* /*pstm */, ULARGE_INTEGER /*cb*/,
                         ULARGE_INTEGER* /*pcbRead*/,
                         ULARGE_INTEGER* /*pcbWritten*/ )
    { return E_NOTIMPL; }
    STDMETHODIMP Commit( DWORD /*grfCommitFlags*/ )
    { return E_NOTIMPL; }
    STDMETHODIMP Revert()
    { return E_NOTIMPL; }
    STDMETHODIMP LockRegion( ULARGE_INTEGER /*libOffset*/, ULARGE_INTEGER /*cb*/,
                             DWORD /*dwLockType*/ )
    { return E_NOTIMPL; }
    STDMETHODIMP UnlockRegion( ULARGE_INTEGER /*libOffset*/, ULARGE_INTEGER /*cb*/,
                               DWORD /*dwLockType*/)
    { return E_NOTIMPL; }
    STDMETHODIMP Stat( STATSTG* /*pstatstg*/, DWORD /*grfStatFlag*/ )
    { return E_NOTIMPL; }
    STDMETHODIMP Clone( IStream** /*ppstm*/ )
    { return E_NOTIMPL; }
};

struct CRIFFStream : IAARIFFStream
{
///// object state
    ULONG       m_cRef;         // object reference count
    IStream*    m_pStream;      // stream to operate on

///// construction and destruction
    CRIFFStream(IStream* pStream)
    {
        m_cRef = 1;
		// replaced a call to SetStream with the following to avoid releasing an
		// unallocated stream
        m_pStream = pStream;
        if( m_pStream != NULL )
        {
            m_pStream->AddRef();
        }
    }
    ~CRIFFStream()
    {
        if( m_pStream != NULL )
        {
            m_pStream->Release();
        }
    }

///// IUnknown methods
    STDMETHODIMP QueryInterface(REFIID riid, LPVOID *ppvObj)
    {
        if( IsEqualIID( riid, IID_IUnknown ) ||
            IsEqualIID( riid, IID_IAARIFFStream ) )
        {
            *ppvObj = (IAARIFFStream*)this;
            AddRef();
            return NOERROR;
        }
        *ppvObj = NULL;
        return E_NOINTERFACE;
    }
    STDMETHODIMP_(ULONG) AddRef()
    {
        return ++m_cRef;
    }
    STDMETHODIMP_(ULONG) Release()
    {
        if( --m_cRef == 0L )
        {
            delete this;
            return 0;
        }
        return m_cRef;
    }

// IAARIFFStream methods
    STDMETHODIMP_(UINT) Descend( LPMMCKINFO lpck, LPMMCKINFO lpckParent, UINT wFlags );
    STDMETHODIMP_(UINT) Ascend( LPMMCKINFO lpck, UINT wFlags );
    STDMETHODIMP_(UINT) CreateChunk( LPMMCKINFO lpck, UINT wFlags );
    STDMETHOD(SetStream)(LPSTREAM pStream)
    {
        if( m_pStream != NULL )
        {
            m_pStream->Release();
        }
        m_pStream = pStream;
        if( m_pStream != NULL )
        {
            m_pStream->AddRef();
        }
        return S_OK;
    }
    STDMETHOD_(LPSTREAM, GetStream)()
    {
        if( m_pStream != NULL )
        {
            m_pStream->AddRef();
        }
        return m_pStream;
    }

// private methods
    long MyRead( void *pv, long cb );
    long MyWrite( const void *pv, long cb );
    long MySeek( long lOffset, int iOrigin );
};

// seeks to a 32-bit position in a stream.
HRESULT __inline StreamSeek( LPSTREAM pStream, long lSeekTo, DWORD dwOrigin )
{
	LARGE_INTEGER li;

	if( lSeekTo < 0 )
	{
		li.HighPart = -1;
	}
	else
	{
        li.HighPart = 0;
	}
	li.LowPart = lSeekTo;
	return pStream->Seek( li, dwOrigin, NULL );
}

// returns the current 32-bit position in a stream.
DWORD __inline StreamTell( LPSTREAM pStream )
{
	LARGE_INTEGER li;
    ULARGE_INTEGER ul;
#ifdef DBG
    HRESULT hr;
#endif

    li.HighPart = 0;
    li.LowPart = 0;
#ifdef DBG
    hr = pStream->Seek( li, STREAM_SEEK_CUR, &ul );
    if( FAILED( hr ) )
#else
    if( FAILED( pStream->Seek( li, STREAM_SEEK_CUR, &ul ) ) )
#endif
    {
        return 0;
    }
    return ul.LowPart;
}

// this function gets a long that is formatted the correct way
// i.e. the motorola way as opposed to the intel way
BOOL __inline GetMLong( LPSTREAM pStream, DWORD& dw )
{
    union uLong
	{
		unsigned char buf[4];
        DWORD dw;
	} u;
    unsigned char ch;

    if( FAILED( pStream->Read( u.buf, 4, NULL ) ) )
    {
        return FALSE;
    }

#ifndef _MAC
    // swap bytes
    ch = u.buf[0];
    u.buf[0] = u.buf[3];
    u.buf[3] = ch;

    ch = u.buf[1];
    u.buf[1] = u.buf[2];
    u.buf[2] = ch;
#endif

    dw = u.dw;
    return TRUE;
}

BOOL __inline IsGUIDZero( REFGUID guid )
{
    GUID g;

    memset( &g, 0, sizeof( g ) );
    return IsEqualGUID( g, guid );
}

// misc function prototypes

STDAPI AllocFileStream( LPCSTR szFileName, DWORD dwDesiredAccess, IStream **ppstream );
STDAPI AllocRIFFStream( IStream* pStream, IAARIFFStream** ppRiff );

#endif  // __AARIFF_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\XDmime\audpath.cpp ===
// Copyright (c) 1998-1999 Microsoft Corporation
// audpath.cpp : Implementation of CAudioPath

#include <windows.h>
#include <mmsystem.h>
#include "dsoundp.h"
#include "dmsegobj.h"
#include "dmgraph.h"
#include "dmperf.h"
#include "dmusici.h"
#include "Validate.h"
#include "audpath.h"
#include "debug.h"
#include "dmusiccp.h"


#define ASSERT  assert

CBufferNode::CBufferNode()

{
    m_lActivateCount = 0;
    m_cRef = 1;
    m_pBuffer = NULL;
    m_pManager = NULL;
}

CBufferNode::~CBufferNode()

{
    FinalDeactivate();
    if (m_pManager)
    {
        m_pManager->Remove(this);
    }
}

ULONG CBufferNode::AddRef()
{
    return InterlockedIncrement(&m_cRef);
}

ULONG CBufferNode::Release()
{
    if (!InterlockedDecrement(&m_cRef))
    {
        delete this;
        return 0;
    }

    return m_cRef;
}

HRESULT CBufferNode::Activate(BOOL fActivate)

{
    HRESULT hr = S_OK;
    if (m_pBuffer)
    {
        if (fActivate)
        {
            if (!m_lActivateCount)
            {
                // Don't bother starting if the primary buffer.
                if (SUCCEEDED(hr) && !(m_BufferHeader.dwFlags & DMUS_BUFFERF_PRIMARY))
                {
                    TraceI(2,"Play buffer %lx\n",m_pBuffer);
                    hr = m_pBuffer->Play(0,0,DSBPLAY_LOOPING);
#ifdef DBG
                    if (FAILED(hr))
                    {
                        Trace(1,"Error: Activate on audiopath failed because buffer failed Play command.\n");
                    }
#endif
                }
            }
            if (hr == S_OK)
            {
                m_lActivateCount++;
            }
            TraceI(3,"Incrementing %lx to %ld\n",m_pBuffer,m_lActivateCount);
        }
        else
        {
            if (m_lActivateCount > 0)
            {
                m_lActivateCount--;
                if (!m_lActivateCount)
                {
                    // Don't bother stopping the primary buffer.
                    if (!(m_BufferHeader.dwFlags & DMUS_BUFFERF_PRIMARY))
                    {
                        TraceI(2,"Stop buffer %lx\n",m_pBuffer);
                        hr = m_pBuffer->Stop();
                    }
                }
                TraceI(3,"Decrementing %lx to %ld\n",m_pBuffer,m_lActivateCount);
                if (hr != S_OK)
                {
                    m_lActivateCount++;
                }
            }
        }
    }
    return hr;
}


void CBufferNode::FinalDeactivate()

{
    if (m_lActivateCount)
    {
        Activate(FALSE);
    }
    if (m_pBuffer)
    {
        m_pBuffer->Release();
        m_pBuffer = NULL;
    }
}

CBufferManager::CBufferManager()
{
    m_pFirstBuffer = NULL;
    m_pSinkConnect = NULL;
    m_pSynthSink = NULL;
    m_pPerf = NULL;
}

CBufferManager::~CBufferManager()
{
    Clear();
    if (m_pSinkConnect)
    {
        m_pSinkConnect->Release();
    }
    if (m_pSynthSink)
    {
        m_pSynthSink->Release();
    }
}

HRESULT CBufferManager::Init(CPerformance *pPerf, DMUS_AUDIOPARAMS *pAudioParams)

{
    HRESULT hr = S_OK;
    m_pPerf = pPerf;
    m_AudioParams = *pAudioParams;
    CBufferNode *pNode = new CBufferNode;
    if (pNode)
    {
        pNode->m_BufferHeader.guidBufferID = GUID_Buffer_Primary;
        pNode->m_BufferHeader.dwFlags = DMUS_BUFFERF_SHARED | DMUS_BUFFERF_DEFINED | DMUS_BUFFERF_PRIMARY;
        pNode->m_pManager = this;
        AddHead(pNode);
        // Create the primary buffer. This will be used for requests to access the listener.
        DSBUFFERDESC dsbdesc;
        memset(&dsbdesc, 0, sizeof(dsbdesc));
        dsbdesc.dwSize = sizeof(dsbdesc);
        dsbdesc.dwFlags = DSBCAPS_PRIMARYBUFFER | DSBCAPS_CTRL3D;

        // create primary buffer
        if (SUCCEEDED(hr = pPerf->m_pDirectSound->CreateSoundBuffer(&dsbdesc, &pNode->m_pBuffer, NULL)))
        {
            WAVEFORMATEX wfPrimary;
            memset(&wfPrimary, 0, sizeof(wfPrimary));

            if (SUCCEEDED(hr = pNode->m_pBuffer->GetFormat(&wfPrimary, sizeof(wfPrimary), NULL)))
            {
                assert(wfPrimary.wFormatTag == WAVE_FORMAT_PCM);

                BOOL fUpgrade = FALSE;
                if (wfPrimary.nSamplesPerSec < m_AudioParams.dwSampleRate)
                {
                    wfPrimary.nSamplesPerSec = m_AudioParams.dwSampleRate;
                    fUpgrade = TRUE;
                }
                if (wfPrimary.wBitsPerSample < 16)
                {
                    wfPrimary.wBitsPerSample = 16;
                    fUpgrade = TRUE;
                }

                if (fUpgrade)
                {
                    wfPrimary.nBlockAlign = wfPrimary.nChannels * (wfPrimary.wBitsPerSample / 8);
                    wfPrimary.nAvgBytesPerSec = wfPrimary.nSamplesPerSec * wfPrimary.nBlockAlign;

                    // the existing format is of lesser quality than we desire, so let's upgrade it
                    if (FAILED(hr = pNode->m_pBuffer->SetFormat( &wfPrimary )))
                    {
                        if (hr == DSERR_PRIOLEVELNEEDED)
                        {
                            // okay, so maybe the app doen't want us changing primary buffer
                            Trace(0, "SynthSink - SetFormat on primary buffer failed, lacking priority\n");
                        }
                        else
                        {
                            Trace(0, "SynthSink - Activation failed, couldn't set primary buffer format\n");
                        }
                    }
                }
            }
        }
    }
    return hr;
}

HRESULT CBufferManager::InitSink(/*WAVEFORMATEX *pSinkFormat*/)

{
    HRESULT hr = S_OK;
    // Only init the sink if it's needed. If the audiopaths will be using buffers,
    // we need the sink. If not, bypass setting it up.
    if (!m_pSinkConnect && (m_pPerf->m_AudioParams.dwFeatures & DMUS_AUDIOF_BUFFERS))
    {
        static WAVEFORMATEX sDefaultFormat = { WAVE_FORMAT_PCM,1,22050,22050*2,2,16,0 };
        sDefaultFormat.nSamplesPerSec = m_AudioParams.dwSampleRate;
        sDefaultFormat.nAvgBytesPerSec = m_AudioParams.dwSampleRate * 2;
        sDefaultFormat.cbSize = 0;
        sDefaultFormat.nBlockAlign = 2;
        sDefaultFormat.nChannels = 1;
        sDefaultFormat.wBitsPerSample = 16;
        sDefaultFormat.wFormatTag = WAVE_FORMAT_PCM;

        IDirectSoundPrivate* pDSPrivate;
        hr = m_pPerf->m_pDirectSound->QueryInterface(IID_IDirectSoundPrivate, (void**)&pDSPrivate);

        if (SUCCEEDED(hr))
        {
            hr = pDSPrivate->AllocSink(&sDefaultFormat, &m_pSinkConnect);
            pDSPrivate->Release();
        }

        if (SUCCEEDED(hr))
        {
            IReferenceClock *pClock = NULL;
            hr = m_pPerf->m_pDirectMusic->GetMasterClock(NULL, &pClock);
            if (SUCCEEDED(hr))
            {
                hr = m_pSinkConnect->SetMasterClock(pClock);
                pClock->Release();
            }
        }
        if (SUCCEEDED(hr))
        {
            hr = m_pSinkConnect->QueryInterface(IID_IDirectSoundSynthSink,(void **) &m_pSynthSink);
            if (SUCCEEDED(hr))
            {
                hr = m_pSynthSink->Activate(TRUE);
            }
        }
        if (SUCCEEDED(hr))
        {
            // Create a dummy buffer that gets activated at the start and stays active until
            // the sink closes down. This is an unfortunate patch to the "clock-hopping" bug.
            // Once we come up with a better solution for providing timing from the sink, this
            // can go away.
            CBufferConfig Config(BUFFER_MONO);
            hr = CreateBuffer(&Config,&m_pFirstBuffer);
            if (SUCCEEDED(hr))
            {
                hr = m_pFirstBuffer->Activate(TRUE);
            }
        }
    }
    return hr;
}

void CBufferManager::FinalDeactivate()
{
    // Kill dummy buffer.
    if (m_pFirstBuffer)
    {
        m_pFirstBuffer->Activate(FALSE);
        delete m_pFirstBuffer;
        m_pFirstBuffer = NULL;
    }
    CBufferNode *pNode = GetHead();
    for (;pNode;pNode = pNode->GetNext())
    {
        pNode->FinalDeactivate();
    }
    if (m_pSynthSink)
    {
        m_pSynthSink->Activate(FALSE);
        m_pSynthSink->Release();
        m_pSynthSink = NULL;
    }
    if (m_pSinkConnect)
    {
        m_pSinkConnect->SetMasterClock(NULL);
        m_pSinkConnect->Release();
        m_pSinkConnect = NULL;
    }
}

void CBufferManager::Clear()
{
    CBufferNode *pNode;
    FinalDeactivate();
    while (pNode = GetHead())
    {
        delete pNode;
    }
}

CBufferNode *CBufferManager::GetBufferNode(REFGUID guidBufferID)

{
    CBufferNode *pNode = GetHead();
    for (;pNode;pNode = pNode->GetNext())
    {
        if (pNode->m_BufferHeader.guidBufferID == guidBufferID)
        {
            pNode->AddRef();
            break;
        }
    }
    return pNode;
}

HRESULT CBufferManager::CreateBuffer(CBufferConfig *pConfig, CBufferConfig ** ppNew)

{
    HRESULT hr = S_OK;
    if (m_AudioParams.dwFeatures & DMUS_AUDIOF_BUFFERS)
    {
        ASSERT(m_pSinkConnect);

        CBufferConfig *pNew = new CBufferConfig(pConfig->m_dwStandardBufferID);
        if (pNew)
        {
            *ppNew = pNew;
            pNew->m_BufferHeader = pConfig->m_BufferHeader;
            if (pConfig->m_BufferHeader.dwFlags & DMUS_BUFFERF_SHARED)
            {
                // Check to see if there already is a buffer in the list with this GUID.
                CBufferNode *pNode = GetHead();
                for (;pNode;pNode = pNode->GetNext())
                {
                    if (pNode->m_BufferHeader.dwFlags & DMUS_BUFFERF_SHARED)
                    {
                        if (pNode->m_BufferHeader.guidBufferID == pConfig->m_BufferHeader.guidBufferID)
                        {
                            pNew->m_pBufferNode = pNode;
                            pNode->AddRef();
                            TraceI(2,"Found shared Buffer %lx\n",pNode->m_pBuffer);
                            return S_OK;
                        }
                    }
                }
            }
            // Either the buffer does not already exist, or it is not to be shared, so
            // create a new buffer node and requested buffer.
            CBufferNode *pNode = new CBufferNode;
            if (pNode)
            {
                pNode->m_BufferHeader = pConfig->m_BufferHeader;
                // Predefined buffer type?
                if (pConfig->m_BufferHeader.dwFlags & DMUS_BUFFERF_DEFINED)
                {
                    // Must be a standard type. Create by hand.
                    CBufferNode *pSendNode = NULL;
                    DSBUFFERDESC BufferDesc;
                    WAVEFORMATEX WaveFormat;
                    DWORD dwFunctionIDs[2];
                    CLSID clsidDMO;
                    BOOL fDMO = FALSE;
                    DWORD dwNumFunctionIDs;
                    memset(&BufferDesc, 0, sizeof(BufferDesc));
                    BufferDesc.dwSize  = sizeof(BufferDesc);
                    BufferDesc.lpwfxFormat = &WaveFormat;
                    BufferDesc.dwBufferBytes = 0;
                    BufferDesc.dwFlags = 0;
                    memset(&WaveFormat,0,sizeof(WaveFormat));
                    WaveFormat.nChannels = 2;
                    switch (pConfig->m_dwStandardBufferID)
                    {
                    case BUFFER_REVERB :
                        dwFunctionIDs[0] = DSBUSID_REVERB_SEND;
                        dwNumFunctionIDs = 1;
                        WaveFormat.nChannels = 2;
                        BufferDesc.dwFlags = DSBCAPS_GLOBALFOCUS | DSBCAPS_CTRLVOLUME | DSBCAPS_CTRLPAN | DSBCAPS_LOCDEFER;
                        clsidDMO = GUID_DSFX_WAVES_REVERB;
                        fDMO = TRUE;
                        break;
                    case BUFFER_ENVREVERB :
                        dwNumFunctionIDs = 0;
                        WaveFormat.nChannels = 2;
                        BufferDesc.dwFlags = DSBCAPS_MIXIN | DSBCAPS_GLOBALFOCUS | DSBCAPS_CTRLPAN | DSBCAPS_CTRLVOLUME;
                        clsidDMO = GUID_DSFX_STANDARD_I3DL2REVERB;
                        fDMO = TRUE;
                        if (!(m_AudioParams.dwFeatures & DMUS_AUDIOF_BUFFERS))
                        {
                            hr = DMUS_E_AUDIOPATH_NOBUFFER;
                            Trace(1,"Audiopath Creation error: Requested Environmental reverb buffer when DMUS_AUDIOF_ENVIRON not enabled via InitAudio.\n");
                        }
                        break;
                        // Following removed for DX8, should be reintroduced for Whistler and DX8.1...
/*                    case BUFFER_3D :
                        clsidDMO = GUID_DSFX_STANDARD_I3DL2SOURCE;
                        fDMO = TRUE;
                        pSendNode = GetBufferNode(GUID_Buffer_EnvReverb);
                        if (!pSendNode)
                        {
                            Trace(1,"Error: Failed creating 3D audiopath because the environmental reverb audiopath has not been created.\n");
                            hr = DMUS_E_AUDIOPATH_NOGLOBALFXBUFFER;
                            break;
                        }*/
                    case BUFFER_3D_DRY :
                        dwFunctionIDs[0] = DSBUSID_DYNAMIC_0;
                        dwNumFunctionIDs = 1;
                        WaveFormat.nChannels = 1;
                        BufferDesc.dwFlags = DSBCAPS_GLOBALFOCUS | DSBCAPS_CTRLVOLUME | DSBCAPS_CTRLFREQUENCY |
                            DSBCAPS_CTRL3D | DSBCAPS_MUTE3DATMAXDISTANCE | DSBCAPS_LOCDEFER;
                        BufferDesc.guid3DAlgorithm = DS3DALG_NO_VIRTUALIZATION;
                        break;
                    case BUFFER_MONO :
                        dwFunctionIDs[0] = DSBUSID_LEFT;
                        dwNumFunctionIDs = 1;
                        WaveFormat.nChannels = 1;
                        BufferDesc.dwFlags = DSBCAPS_GLOBALFOCUS | DSBCAPS_CTRLVOLUME | DSBCAPS_CTRLFREQUENCY | DSBCAPS_CTRLPAN | DSBCAPS_LOCDEFER;
                        break;
                    case BUFFER_STEREO :
                        BufferDesc.dwFlags = DSBCAPS_CTRLFREQUENCY;
                    case BUFFER_MUSIC :
                        dwFunctionIDs[0] = DSBUSID_LEFT;
                        dwFunctionIDs[1] = DSBUSID_RIGHT;
                        dwNumFunctionIDs = 2;
                        WaveFormat.nChannels = 2;
                        BufferDesc.dwFlags |= DSBCAPS_GLOBALFOCUS | DSBCAPS_CTRLPAN | DSBCAPS_CTRLVOLUME | DSBCAPS_LOCDEFER;
                        break;
                    default:
                        hr = E_INVALIDARG;
                    }
                    if (SUCCEEDED(hr))
                    {
                        WaveFormat.nBlockAlign = WaveFormat.nChannels * 2;
                        WaveFormat.nSamplesPerSec = m_AudioParams.dwSampleRate;
                        WaveFormat.nAvgBytesPerSec = WaveFormat.nChannels * WaveFormat.nSamplesPerSec * 2;
                        WaveFormat.wBitsPerSample = 16;
                        WaveFormat.wFormatTag = WAVE_FORMAT_PCM;
                        // Ensure that the mixin flag and number of bus ids are in sync (you can't combine mixin with buses.)
                        if ((pConfig->m_BufferHeader.dwFlags & DMUS_BUFFERF_MIXIN) || (dwNumFunctionIDs == 0))
                        {
                            dwNumFunctionIDs = 0;
                            BufferDesc.dwFlags |= DSBCAPS_MIXIN;
                            pConfig->m_BufferHeader.dwFlags |= DMUS_BUFFERF_MIXIN;
                            BufferDesc.dwFlags &= ~DSBCAPS_LOCDEFER;
                        }
                        // Always allow effects to be created on the buffer, regardless of whether we need them now.
                        BufferDesc.dwFlags |= DSBCAPS_CTRLFX;
                        hr = m_pSinkConnect->CreateSoundBuffer(&BufferDesc, &dwFunctionIDs[0], dwNumFunctionIDs,
                                                               pConfig->m_BufferHeader.guidBufferID, &pNode->m_pBuffer);
#ifdef DBG
                        if (FAILED(hr))
                        {
                            if (pConfig->m_BufferHeader.dwFlags & DMUS_BUFFERF_MIXIN)
                            {
                                Trace(1,"Error: Failed creating global (MIXIN) buffer for standard path.\n");
                            }
                            else
                            {
                                Trace(1,"Error: Failed creating buffer for standard path.\n");
                            }
                        }
#endif
                    }
                    if (SUCCEEDED(hr))
                    {
                        if (fDMO)
                        {
                            IDirectSoundBuffer8 *pBuff8;
                            if (SUCCEEDED(pNode->m_pBuffer->QueryInterface(IID_IDirectSoundBuffer8,(void **)&pBuff8)))
                            {
                                DWORD dwResult;
                                DSEFFECTDESC FXDesc;
                                FXDesc.dwSize = sizeof(DSEFFECTDESC);
                                FXDesc.dwFlags = 0;
                                FXDesc.guidDSFXClass = clsidDMO;
                                FXDesc.dwReserved1 = 0;
                                FXDesc.dwReserved2 = 0;
                                if (pSendNode)
                                {
                                    FXDesc.dwReserved1 = DWORD(pSendNode->GetBuffer());
                                }
                                hr = pBuff8->SetFX(1, &FXDesc, &dwResult);
                                if (FXDesc.dwReserved1)
                                {
                                    ((IDirectSoundBuffer*)FXDesc.dwReserved1)->Release();
                                }
                                pBuff8->Release();
                            }
                        }
                    }
                    if (pSendNode)
                    {
                        pSendNode->Release();
                    }
                }
                else
                {
                    pConfig->m_BufferHeader.dwFlags &= ~DMUS_BUFFERF_MIXIN;
                    hr = m_pSinkConnect->CreateSoundBufferFromConfig(pConfig->m_pBufferConfig,&pNode->m_pBuffer);
                    if (SUCCEEDED(hr))
                    {
                        // We need to know if this is a mixin buffer so we can identify it later.
                        DWORD dwBusIDs[32];
                        DWORD dwFuncIDs[32];
                        DWORD dwCount = 32;
                        dwFuncIDs[0] = 0;
                        if (SUCCEEDED(m_pSinkConnect->GetSoundBufferBusIDs(pNode->m_pBuffer,dwBusIDs,dwFuncIDs,&dwCount)))
                        {
                            if (dwFuncIDs[0] == 0xFFFFFFFF)
                            {
                                pConfig->m_BufferHeader.dwFlags |= DMUS_BUFFERF_MIXIN;
                            }
                        }
                    }
                    else
                    {
                        Trace(1,"Error: Failed creation of buffer defined in audio path configuration file.\n");
                    }
                }

                if (SUCCEEDED(hr))
                {
                    TraceI(2,"Created Buffer %lx\n",pNode->m_pBuffer);
                    pNew->m_pBufferNode = pNode;
                    pNode->m_pManager = this;
                    AddHead(pNode);
                }
                else
                {
                    delete pNode;
                }
            }
            else
            {
                hr = E_OUTOFMEMORY;
            }
        }
        if (FAILED(hr) && pNew)
        {
            delete pNew;
            *ppNew = NULL;
        }
    }
    else
    {
        hr = DMUS_E_AUDIOPATH_NOBUFFER;
        Trace(0,"Audiopath Creation error: Requested buffer when DMUS_AUDIOF_BUFFERS not enabled via InitAudio.\n");
    }
    return hr;
}

CBufferConnect::CBufferConnect()

{
    m_ppBufferNodes = NULL;
    m_pguidBufferIDs = NULL;
    m_ConnectHeader.dwBufferCount = 0;
}

HRESULT CBufferConnect::Load(CRiffParser *pParser)

{
    HRESULT hr = pParser->Read(&m_ConnectHeader, sizeof(DMUS_IO_PCHANNELTOBUFFER_HEADER));
    if (SUCCEEDED(hr))
    {
        DWORD dwBufferCount = m_ConnectHeader.dwBufferCount;
        m_pguidBufferIDs = new GUID[dwBufferCount];
        if (m_pguidBufferIDs )
        {
            hr = pParser->Read(m_pguidBufferIDs,sizeof(GUID)*dwBufferCount);
        }
        else
        {
            hr = E_OUTOFMEMORY;
        }
    }
    return hr;
}

CBufferConnect *CBufferConnect::CreateRunTimeVersion(CPortConfig *pParent)

{
    CBufferConnect *pCopy = new CBufferConnect;
    if (pCopy && m_pguidBufferIDs)
    {
        pCopy->m_ConnectHeader = m_ConnectHeader;
        pCopy->m_ppBufferNodes = new CBufferNode *[m_ConnectHeader.dwBufferCount];
        if (pCopy->m_ppBufferNodes)
        {
            for (DWORD dwIndex = 0; dwIndex < m_ConnectHeader.dwBufferCount; dwIndex++)
            {
                pCopy->m_ppBufferNodes[dwIndex] = pParent->GetBufferNode(m_pguidBufferIDs[dwIndex]);
            }
        }
        else
        {
            delete pCopy;
            pCopy = NULL;
        }
    }
    return pCopy;
}


CBufferConnect::~CBufferConnect()

{
    if (m_ppBufferNodes)
    {
        for (DWORD dwIndex = 0; dwIndex < m_ConnectHeader.dwBufferCount; dwIndex++)
        {
            if (m_ppBufferNodes[dwIndex]) m_ppBufferNodes[dwIndex]->Release();
        }
        delete [] m_ppBufferNodes;
    }
    if (m_pguidBufferIDs)
    {
        delete [] m_pguidBufferIDs;
    }
}

HRESULT CBufferConnectList::CreateRunTimeVersion(CBufferConnectList *pDestination, CPortConfig *pParent)

{
    CBufferConnect *pScan = GetHead();
    CBufferConnect *pCopy;
    for (;pScan;pScan = pScan->GetNext())
    {
        pCopy = pScan->CreateRunTimeVersion(pParent);
        if (pCopy)
        {
            pDestination->AddTail(pCopy);
        }
        else
        {
            return E_OUTOFMEMORY;
        }
    }
    return S_OK;
}

void CBufferConnectList::Clear()

{
    CBufferConnect *pBuffer;
    while (pBuffer = RemoveHead())
    {
        delete pBuffer;
    }
}

HRESULT CBufferConfig::Activate(BOOL fActivate)

{
    if (m_pBufferNode)
    {
        return m_pBufferNode->Activate(fActivate);
    }
    return S_OK;
}

CBufferConfig::CBufferConfig(DWORD dwType)

{
    m_pBufferNode = NULL;
    m_BufferHeader.guidBufferID = GUID_NULL;
    m_BufferHeader.dwFlags = DMUS_BUFFERF_DEFINED;
    m_dwStandardBufferID = dwType;
    switch (dwType)
    {
    case BUFFER_REVERB :
        m_BufferHeader.guidBufferID = GUID_Buffer_Reverb;
        m_BufferHeader.dwFlags = DMUS_BUFFERF_SHARED | DMUS_BUFFERF_DEFINED;
        break;
    case BUFFER_ENVREVERB :
        m_BufferHeader.guidBufferID = GUID_Buffer_EnvReverb;
        m_BufferHeader.dwFlags = DMUS_BUFFERF_SHARED | DMUS_BUFFERF_DEFINED | DMUS_BUFFERF_MIXIN;
        break;
    // Following removed for DX8, should be reintroduced for Whistler and DX8.1...
//    case BUFFER_3D :
//        m_BufferHeader.guidBufferID = GUID_Buffer_3D;
//        break;
    case BUFFER_3D_DRY :
        m_BufferHeader.guidBufferID = GUID_Buffer_3D_Dry;
        break;
    case BUFFER_MONO :
        m_BufferHeader.guidBufferID = GUID_Buffer_Mono;
        break;
    case BUFFER_STEREO :
        m_BufferHeader.guidBufferID = GUID_Buffer_Stereo;
        break;
    case BUFFER_MUSIC :
        m_BufferHeader.guidBufferID = GUID_Buffer_Stereo;
        m_BufferHeader.dwFlags = DMUS_BUFFERF_SHARED | DMUS_BUFFERF_DEFINED;
        break;
    default:
        m_BufferHeader.dwFlags = 0;
        break;
    }
    m_pBufferConfig = NULL;
}

CBufferConfig::~CBufferConfig()

{
    if (m_pBufferNode)
        m_pBufferNode->Release();
    if (m_pBufferConfig)
        m_pBufferConfig->Release();
}

void CBufferConfig::DecideType()

{
    if (m_BufferHeader.guidBufferID == GUID_Buffer_Reverb)
    {
        m_dwStandardBufferID = BUFFER_REVERB;
    }
    else if (m_BufferHeader.guidBufferID == GUID_Buffer_EnvReverb)
    {
        m_dwStandardBufferID = BUFFER_ENVREVERB;
    }
    // Following removed for DX8, should be reintroduced for Whistler and DX8.1...
/*    else if (m_BufferHeader.guidBufferID == GUID_Buffer_3D)
    {
        m_dwStandardBufferID = BUFFER_3D;
    }*/
    else if (m_BufferHeader.guidBufferID == GUID_Buffer_3D_Dry)
    {
        m_dwStandardBufferID = BUFFER_3D_DRY;
    }
    else if (m_BufferHeader.guidBufferID == GUID_Buffer_Mono)
    {
        m_dwStandardBufferID = BUFFER_MONO;
    }
    else if (m_BufferHeader.guidBufferID == GUID_Buffer_Stereo)
    {
        m_dwStandardBufferID = BUFFER_STEREO;
    }
}



HRESULT CBufferConfig::Load(IStream *pStream)

{
    IPersistStream *pPersist;
    HRESULT hr = CoCreateInstance( CLSID_DirectSoundBufferConfig,
        NULL, CLSCTX_INPROC, IID_IPersistStream,
        (void**)&pPersist );
    if (SUCCEEDED(hr))
    {
        hr = pPersist->Load(pStream);
        if (SUCCEEDED(hr))
        {
            m_pBufferConfig = pPersist;
            IDirectMusicObject *pObject;
            hr = pPersist->QueryInterface(IID_IDirectMusicObject,(void **) &pObject);
            if (SUCCEEDED(hr))
            {
                DMUS_OBJECTDESC Desc;
                Desc.dwSize = sizeof(Desc);
                pObject->GetDescriptor(&Desc);
                if (Desc.dwValidData & DMUS_OBJ_OBJECT)
                {
                    m_BufferHeader.guidBufferID = Desc.guidObject;
                }
                else
                {
                    Trace(1,"Error: Unable to load Buffer Configuration in AudioPath Config - Missing buffer GUID in file.\n");
                    hr = E_FAIL;
                }
                pObject->Release();
            }
        }
        else
        {
            pPersist->Release();
        }
    }
    return hr;
}

void CBufferConfigList::Clear()

{
    CBufferConfig *pBuffer;
    while (pBuffer = RemoveHead())
    {
        delete pBuffer;
    }
}

CBufferNode * CBufferConfigList::GetBufferNode(REFGUID guidBufferID)

{
    CBufferNode *pBuff = NULL;
    CBufferConfig *pBuffer;
    for (pBuffer = GetHead();pBuffer;pBuffer = pBuffer->GetNext())
    {
        if (pBuffer->m_BufferHeader.guidBufferID == guidBufferID)
        {
            if (pBuffer->m_pBufferNode)
            {
                pBuffer->m_pBufferNode->AddRef();
                pBuff = pBuffer->m_pBufferNode;
            }
            break;
        }
    }
    return pBuff;
}

HRESULT CBufferConfigList::Activate(BOOL fActivate)

{
    HRESULT hr = S_OK;
    CBufferConfig *pBuffer;
    for (pBuffer = GetHead();pBuffer;pBuffer = pBuffer->GetNext())
    {
        hr = pBuffer->Activate(fActivate);
        if (FAILED(hr))
        {
            CBufferConfig *pUndo;
            for (pUndo = GetHead();pUndo && (pUndo != pBuffer);pUndo = pUndo->GetNext())
            {
                pUndo->Activate(!fActivate);
            }
            break;
        }
    }
    return hr;
}

HRESULT CBufferConfigList::CreateRunTimeVersion(CBufferConfigList *pCopy, CBufferManager *pManager)

/*  To create a runtime version, we scan through all bufferconfigs and, for each one, we call the
    buffer manager to create a new one, managed by CBufferNode. In the case where the buffer already exists, it just
    addrefs the CBufferNode and returns that.
*/

{
    HRESULT hr = S_OK;
    CBufferConfig *pBuffer;
    for (pBuffer = GetHead();pBuffer;pBuffer = pBuffer->GetNext())
    {
        CBufferConfig *pNew = NULL;
        hr = pManager->CreateBuffer(pBuffer,&pNew);
        if (SUCCEEDED(hr))
        {
            pCopy->AddTail(pNew);
        }
        else
        {
            break;
        }
    }
    return hr;
}


CPortConfig::CPortConfig()

{
    m_fAlreadyHere = FALSE;
    m_pPort = NULL;
    m_dwPortID = 0;
    m_pParent = NULL;
    m_PortHeader.guidPort = GUID_Synth_Default;     // Default synth, as specified by DMUS_AUDPARAMS.
    m_PortHeader.dwFlags = DMUS_PORTCONFIGF_DRUMSON10;
    m_PortHeader.dwPChannelBase = 0;
    m_PortHeader.dwPChannelCount = 32;
    m_PortParams.dwChannelGroups = 2;
    m_PortParams.dwSize = sizeof(DMUS_PORTPARAMS8);
    m_PortParams.dwValidParams = DMUS_PORTPARAMS_CHANNELGROUPS | DMUS_PORTPARAMS_FEATURES;
    m_PortParams.dwFeatures = DMUS_PORT_FEATURE_AUDIOPATH | DMUS_PORT_FEATURE_STREAMING;
}

CPortConfig::~CPortConfig()

{
    if (m_pPort) m_pPort->Release();
    m_BufferConnectList.Clear();
    m_BufferConfigList.Clear();
}


HRESULT CPortConfig::Activate(BOOL fActivate)

{
    HRESULT hr = m_BufferConfigList.Activate(fActivate);
    if (SUCCEEDED(hr) && fActivate && m_pPort)
    {
        HRESULT hrTemp = m_pPort->Activate(TRUE);
        if (FAILED(hrTemp))
        {
            hr = hrTemp;
        }
    }
    return hr;
}

HRESULT CPortConfig::CreateRunTimeVersion(CPortConfig ** ppCopy, CAudioPath *pParent, CBufferManager *pManager)

{
    HRESULT hr = E_OUTOFMEMORY;
    CPortConfig *pCopy = new CPortConfig();
    if (pCopy)
    {
        pCopy->m_pParent = pParent;
        pCopy->m_PortHeader = m_PortHeader;
        pCopy->m_PortParams = m_PortParams;
        hr = m_BufferConfigList.CreateRunTimeVersion(&pCopy->m_BufferConfigList,pManager);
        if (SUCCEEDED(hr))
        {
            hr = m_BufferConnectList.CreateRunTimeVersion(&pCopy->m_BufferConnectList,pCopy);
        }
    }
    *ppCopy = pCopy;
    return hr;
}

CBufferNode * CPortConfig::GetBufferNode(REFGUID guidBuffer)

{
    CBufferNode *pBuff = NULL;
    pBuff = m_BufferConfigList.GetBufferNode(guidBuffer);
    if (!pBuff && !m_fAlreadyHere)
    {
        m_fAlreadyHere = TRUE;
        pBuff = m_pParent->GetBufferNode(guidBuffer);
        m_fAlreadyHere = FALSE;
    }
    return pBuff;
}


HRESULT CPortConfig::Load(CRiffParser *pParser)
{
    RIFFIO ckNext;
    HRESULT hr = S_OK;
    DWORD dwLoadedBoth = 0;
    pParser->EnterList(&ckNext);
    while (pParser->NextChunk(&hr))
    {
        switch(ckNext.ckid)
        {
        case DMUS_FOURCC_PORTCONFIG_ITEM:
            hr = pParser->Read(&m_PortHeader, sizeof(DMUS_IO_PORTCONFIG_HEADER));
            dwLoadedBoth |= 1;
            break;
        case DMUS_FOURCC_PORTPARAMS_ITEM:
            hr = pParser->Read(&m_PortParams, sizeof(DMUS_PORTPARAMS8));
            dwLoadedBoth |= 2;
            break;
        case FOURCC_LIST:
        case FOURCC_RIFF:
            switch(ckNext.fccType)
            {
                RIFFIO ckChild;
                case DMUS_FOURCC_PCHANNELS_LIST:
                    pParser->EnterList(&ckChild);
                    while (pParser->NextChunk(&hr))
                    {
                        switch( ckChild.ckid )
                        {
                        case DMUS_FOURCC_PCHANNELS_ITEM:
                            {
                                CBufferConnect *pBufferConnect = new CBufferConnect;
                                if (pBufferConnect)
                                {
                                    hr = pBufferConnect->Load(pParser);
                                    if (SUCCEEDED(hr))
                                    {
                                        m_BufferConnectList.AddTail(pBufferConnect);
                                    }
                                }
                                else
                                {
                                    hr = E_OUTOFMEMORY;
                                }
                            }
                            break;
                        }
                    }
                    pParser->LeaveList();
                    break;
                case DMUS_FOURCC_DSBUFFER_LIST:
                    {
                        CBufferConfig *pSource = new CBufferConfig(0);
                        if (pSource)
                        {
                            pParser->EnterList(&ckChild);
                            while (pParser->NextChunk(&hr))
                            {
                                switch( ckChild.ckid )
                                {
                                case DMUS_FOURCC_DSBUFFATTR_ITEM:
                                    hr = pParser->Read(&pSource->m_BufferHeader,
                                        sizeof(DMUS_IO_BUFFER_ATTRIBUTES_HEADER));
                                    pSource->DecideType();
                                    break;
                                case FOURCC_LIST:
                                case FOURCC_RIFF:
                                    if ( ckChild.fccType == DMUS_FOURCC_DSBC_FORM)
                                    {
                                        pParser->SeekBack();
                                        hr = pSource->Load(pParser->GetStream());
                                        pParser->SeekForward();
                                        if (FAILED(hr))
                                        {
                                            Trace(1,"AudioPath Configuration failed loading buffer\n");
                                        }
                                    }
                                }
                            }
                            pParser->LeaveList();
                            if (SUCCEEDED(hr))
                            {
                                m_BufferConfigList.AddTail(pSource);
                            }
                            else
                            {
                                delete pSource;
                            }
                        }
                        else
                        {
                            hr = E_OUTOFMEMORY;
                        }
                    }
                    break;
                case DMUS_FOURCC_DSBC_FORM:
                    {
                        CBufferConfig *pSource = new CBufferConfig(0);
                        if (pSource)
                        {
                            pParser->SeekBack();
                            hr = pSource->Load(pParser->GetStream());
                            pParser->SeekForward();
                            if (SUCCEEDED(hr))
                            {
                                m_BufferConfigList.AddTail(pSource);
                            }
                            else
                            {
                                Trace(1,"AudioPath Configuration failed loading buffer\n");
                                delete pSource;
                            }
                        }
                        else
                        {
                            hr = E_OUTOFMEMORY;
                        }
                    }
                    break;
                default:
                    break;
            }
            break;
        default:
            break;
        }
    }
    if (dwLoadedBoth != 3)
    {
        hr = DMUS_E_CHUNKNOTFOUND;
        Trace(1,"Error: Failure loading port configuration chunk in Audio Path Configuration.\n");
    }

    // Make sure the channel groups in the portparams is large enough to handle the requested
    // channels in portheader.
    m_PortParams.dwChannelGroups = (m_PortHeader.dwPChannelCount + 15) / 16;
    m_PortParams.dwValidParams |= DMUS_PORTPARAMS_CHANNELGROUPS;
    pParser->LeaveList();

    return hr;
}

HRESULT CPortConfigList::Activate(BOOL fActivate)

{
    HRESULT hr = S_OK;
    CPortConfig *pPort;
    for (pPort = GetHead();pPort;pPort = pPort->GetNext())
    {
        hr = pPort->Activate(fActivate);
        if (FAILED(hr))
        {
            CPortConfig *pUndo;
            for (pUndo = GetHead();pUndo && (pUndo != pPort);pUndo = pUndo->GetNext())
            {
                pUndo->Activate(!fActivate);
            }
            break;
        }
    }
    return hr;
}

HRESULT CPortConfigList::CreateRunTimeVersion(CPortConfigList *pDestination,CAudioPath *pParent,CBufferManager *pManager)

{
    HRESULT hr = S_OK;
    CPortConfig *pScan = GetHead();
    CPortConfig *pCopy;
    for (;pScan;pScan = pScan->GetNext())
    {
        hr = pScan->CreateRunTimeVersion(&pCopy,pParent,pManager);
        if (pCopy)
        {
            pDestination->AddTail(pCopy);
        }
        else
        {
            break;
        }
    }
    return hr;
}

BOOL CPortConfigList::UsesPort(IDirectMusicPort *pPort)

{
    CPortConfig *pScan = GetHead();
    for (;pScan;pScan = pScan->GetNext())
    {
        if (pScan->m_pPort == pPort) return TRUE;
    }
    return FALSE;
}


void CPortConfigList::Clear()

{
    CPortConfig *pPort;
    while (pPort = RemoveHead())
    {
        delete pPort;
    }
}

CAudioPath::CAudioPath()

{
    TraceI(2,"Creating AudioPath %lx\n",this);
    InitializeCriticalSection(&m_CriticalSection);
    m_fDeactivating = FALSE;
    m_bLastVol = 127;
    m_cRef = 0;
    m_fActive = FALSE;
    m_pdwVChannels = NULL;
    m_pdwPChannels = NULL;
    m_dwChannelCount = 0;
    m_pPerformance = NULL;
    m_pGraph = NULL;
    m_pConfig = NULL;
    m_pUnkDispatch = NULL;
}


CAudioPath::~CAudioPath()
{
    EnterCriticalSection(&m_CriticalSection);
    if (m_pUnkDispatch)
    {
        m_pUnkDispatch->Release(); // free IDispatch implementation we may have borrowed
    }
    LeaveCriticalSection(&m_CriticalSection);
    Deactivate();
    DeleteCriticalSection(&m_CriticalSection);
}

STDMETHODIMP_(ULONG) CAudioPath::AddRef()
{
    return InterlockedIncrement(&m_cRef);
}

STDMETHODIMP_(ULONG) CAudioPath::Release()
{
    if (!InterlockedDecrement(&m_cRef))
    {
        delete this;
        return 0;
    }

    return m_cRef;
}

STDMETHODIMP CAudioPath::QueryInterface(
    const IID &iid,
    void **ppv)
{
    V_INAME(CAudioPath::QueryInterface);
    V_PTRPTR_WRITE(ppv);
    V_REFGUID(iid);

    *ppv = NULL;
    if (iid == IID_IUnknown || iid == IID_IDirectMusicAudioPath)
    {
        *ppv = static_cast<IDirectMusicAudioPath*>(this);
    } else
    if (iid == IID_CAudioPath)
    {
        *ppv = static_cast<CAudioPath*>(this);
    } else
    if (iid == IID_IDirectMusicGraph)
    {
        *ppv = static_cast<IDirectMusicGraph*>(this);
    }
    else if (iid == IID_IDispatch)
    {
        // A helper scripting object implements IDispatch, which we expose via COM aggregation.
        if (!m_pUnkDispatch)
        {
            // Create the helper object
            ::CoCreateInstance(
                CLSID_AutDirectMusicAudioPath,
                static_cast<IDirectMusicAudioPath*>(this),
                CLSCTX_INPROC_SERVER,
                IID_IUnknown,
                reinterpret_cast<void**>(&m_pUnkDispatch));
        }
        if (m_pUnkDispatch)
        {
            return m_pUnkDispatch->QueryInterface(IID_IDispatch, ppv);
        }
    }

    if (*ppv == NULL)
    {
        Trace(4,"Warning: Request to query unknown interface on AudioPath object\n");
        return E_NOINTERFACE;
    }

    reinterpret_cast<IUnknown*>(this)->AddRef();
    return S_OK;
}


static BYTE VolumeToMidi(long lVolume)

{
    static long lDBToMIDI[97] = {        // Array used to convert db to MIDI.
        127, 119, 113, 106, 100, 95, 89, 84, 80, 75,
        71, 67, 63, 60, 56, 53, 50, 47, 45, 42,
        40, 37, 35, 33, 31, 30, 28, 26, 25, 23,
        22, 21, 20, 19, 17, 16, 15, 15, 14, 13,
        12, 11, 11, 10, 10, 9, 8, 8, 8, 7,
        7, 6, 6, 6, 5, 5, 5, 4, 4, 4,
        4, 3, 3, 3, 3, 3, 2, 2, 2, 2,
        2, 2, 2, 1, 1, 1, 1, 1, 1, 1,
        1, 1, 1, 1, 1, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0
    };
    if (lVolume < -9600) lVolume = -9600;
    if (lVolume > 0) lVolume = 0;
    lVolume = -lVolume;
    long lFraction = lVolume % 100;
    lVolume = lVolume / 100;
    long lResult = lDBToMIDI[lVolume];
    lResult += ((lDBToMIDI[lVolume + 1] - lResult) * lFraction) / 100;
    return (BYTE) lResult;
}

STDMETHODIMP CAudioPath::SetVolume(long lVolume,DWORD dwDuration)

{
    if (lVolume < DSBVOLUME_MIN || lVolume > DSBVOLUME_MAX)
    {
        return E_INVALIDARG;
    }
    HRESULT hr = E_FAIL; // This should never happen, since the audiopath is created by the performance.
    BYTE bMIDIVol = VolumeToMidi(lVolume);

    DMUS_CURVE_PMSG *pCurve;
    EnterCriticalSection(&m_CriticalSection);
    if (m_pPerformance)
    {
        hr = m_pPerformance->AllocPMsg(sizeof(DMUS_CURVE_PMSG),(DMUS_PMSG **)&pCurve);
        if (SUCCEEDED(hr))
        {
            REFERENCE_TIME rtTimeNow = 0;
            m_pPerformance->GetLatencyTime(&rtTimeNow);
            pCurve->rtTime = rtTimeNow;
            pCurve->dwFlags = DMUS_PMSGF_REFTIME | DMUS_PMSGF_LOCKTOREFTIME | DMUS_PMSGF_DX8;
            pCurve->dwPChannel = DMUS_PCHANNEL_BROADCAST_AUDIOPATH;
            // dwVirtualTrackID: this isn't a track so leave as 0
            pCurve->dwType = DMUS_PMSGT_CURVE;
            pCurve->dwGroupID = -1; // this isn't a track so just say all groups

            // curve PMsg fields
            pCurve->mtDuration = dwDuration; // setting the DMUS_PMSGF_LOCKTOREFTIME is interpreted by the performance that mtDuration is milliseconds
            // mtResetDuration: no reset so leave as 0
            pCurve->nStartValue = m_bLastVol;
            m_bLastVol = bMIDIVol;
            // nStartValue: will be ignored
            pCurve->nEndValue = bMIDIVol;
            // nResetValue: no reset so leave as 0
            pCurve->bType = DMUS_CURVET_CCCURVE;
            pCurve->bCurveShape = dwDuration ? DMUS_CURVES_LINEAR : DMUS_CURVES_INSTANT;
            pCurve->bCCData = 7; // MIDI volume controller number
            pCurve->bFlags = DMUS_CURVE_START_FROM_CURRENT;
            // wParamType: leave as zero since this isn't a NRPN/RPN curve
            pCurve->wMergeIndex = 0xFFFF; //  special merge index so this won't get stepped on. is a big number OK? define a constant for this value?

            // send it

            StampPMsg((DMUS_PMSG *)pCurve);
            hr = m_pPerformance->SendPMsg((DMUS_PMSG*)pCurve);
        }
    }
    else
    {
        hr = DMUS_E_NOT_INIT;
    }
    LeaveCriticalSection(&m_CriticalSection);
    return hr;
}


STDMETHODIMP CAudioPath::GetObjectInPath( DWORD dwPChannel,DWORD dwStage,
                                          DWORD dwBuffer, REFGUID guidObject,
                                          DWORD dwIndex, REFGUID iidInterface, void ** ppObject)
{
    V_INAME(IDirectMusicAudioPath::GetObjectInPath);
    V_PTRPTR_WRITE(ppObject);
    *ppObject = NULL;
    if (dwBuffer && ((dwStage < DMUS_PATH_BUFFER) || (dwStage >= DMUS_PATH_PRIMARY_BUFFER)))
    {
        return DMUS_E_NOT_FOUND;
    }
    HRESULT hr = DMUS_E_NOT_FOUND;
    CPortConfig *pPortConfig;
    EnterCriticalSection(&m_CriticalSection);
    switch (dwStage)
    {
    case DMUS_PATH_AUDIOPATH:
        if ((dwIndex == 0) && (dwPChannel == 0))
        {
            hr = QueryInterface(iidInterface,ppObject);
        }
        break;
    case DMUS_PATH_AUDIOPATH_GRAPH:
        if ((dwIndex == 0) && (dwPChannel == 0))
        {
            if (!m_pGraph)
            {
                m_pGraph = new CGraph;
            }
            if (m_pGraph)
            {
                hr = m_pGraph->QueryInterface(iidInterface,ppObject);
            }
            else
            {
                hr = E_OUTOFMEMORY;
            }
        }
        break;
    case DMUS_PATH_AUDIOPATH_TOOL:
        if (m_pGraph)
        {
            hr = m_pGraph->GetObjectInPath(dwPChannel,guidObject,dwIndex,iidInterface,ppObject);
        }
        break;
    case DMUS_PATH_PERFORMANCE:
        if (m_pPerformance && (dwIndex == 0) && (dwPChannel == 0))
        {
            hr = m_pPerformance->QueryInterface(iidInterface,ppObject);
        }
        break;
    case DMUS_PATH_PERFORMANCE_GRAPH:
        if (m_pPerformance && (dwIndex == 0) && (dwPChannel == 0))
        {
            IDirectMusicGraph *pGraph;
            if (SUCCEEDED(hr = m_pPerformance->GetGraphInternal(&pGraph)))
            {
                hr = pGraph->QueryInterface(iidInterface,ppObject);
                pGraph->Release();
            }
        }
        break;
    case DMUS_PATH_PERFORMANCE_TOOL:
        if (m_pPerformance)
        {
            IDirectMusicGraph *pGraph;
            if (SUCCEEDED(hr = m_pPerformance->GetGraphInternal(&pGraph)))
            {
                CGraph *pCGraph = (CGraph *) pGraph;
                // Convert from audiopath channel to performance channel.
                ConvertPChannel( dwPChannel,&dwPChannel);
                hr = pCGraph->GetObjectInPath(dwPChannel,guidObject,dwIndex,iidInterface,ppObject);
                pGraph->Release();
            }
        }
        break;
    case DMUS_PATH_PORT:
        pPortConfig = m_PortConfigList.GetHead();
        for (;pPortConfig;pPortConfig = pPortConfig->GetNext())
        {
            // First, see if this matches the port guid.
            if ((pPortConfig->m_PortHeader.guidPort == guidObject) || (guidObject == GUID_All_Objects))
            {
                // Then, see if we have a pchannel match.
                if ((dwPChannel == DMUS_PCHANNEL_ALL) ||
                    ((pPortConfig->m_PortHeader.dwPChannelBase <= dwPChannel) &&
                    ((pPortConfig->m_PortHeader.dwPChannelBase + pPortConfig->m_PortHeader.dwPChannelCount) > dwPChannel)))
                {
                    // If everything matches, there is always the chance that we have multiple instances of
                    // this in the list and we are actually looking at a second or third pointer to the same port.
                    // So, scan through the list again, making the exact same matches. If this port is found in
                    // an earlier instance, fail the match.
                    BOOL fSuccess = true;
                    CPortConfig *pScan = m_PortConfigList.GetHead();
                    for (;pScan;pScan = pScan->GetNext())
                    {
                        // First, see if this matches the port guid.
                        if ((pScan->m_PortHeader.guidPort == guidObject) || (guidObject == GUID_All_Objects))
                        {
                            // Then, see if we have a pchannel match.
                            if ((dwPChannel == DMUS_PCHANNEL_ALL) ||
                                ((pScan->m_PortHeader.dwPChannelBase <= dwPChannel) &&
                                ((pScan->m_PortHeader.dwPChannelBase + pScan->m_PortHeader.dwPChannelCount) > dwPChannel)))
                            {
                                // If this is the same as the outer loop, we have arrived.
                                if (pScan == pPortConfig)
                                {
                                    break;
                                }
                                else
                                {
                                    // Else, if this points to the same port, we have failed.
                                    if (pScan->m_pPort == pPortConfig->m_pPort)
                                    {
                                        fSuccess = false;
                                        break;
                                    }
                                }
                            }
                        }
                    }
                    if (fSuccess)
                    {
                        if (dwIndex)
                        {
                            dwIndex--;
                        }
                        else
                        {
                            IDirectMusicPort *pPort;
                            if (SUCCEEDED(m_pPerformance->GetPort(pPortConfig->m_dwPortID,&pPort)))
                            {
                                hr = pPort->QueryInterface(iidInterface,ppObject);
                                pPort->Release();
                            }
                            break;
                        }
                    }
                }
            }
        }
        break;
    case DMUS_PATH_SINK:
        if (m_pPerformance && (dwIndex == 0) && (dwPChannel == 0) &&
            m_pPerformance->m_BufferManager.m_pSinkConnect)
        {
            hr = m_pPerformance->m_BufferManager.m_pSinkConnect->QueryInterface(iidInterface,ppObject);
        }
        break;
    case DMUS_PATH_BUFFER:
    case DMUS_PATH_BUFFER_DMO:
        {
            CBufferConnect *pConnect = NULL;
            BOOL fAllChannels = (dwPChannel == DMUS_PCHANNEL_ALL);
            pPortConfig = m_PortConfigList.GetHead();
            for (;pPortConfig && FAILED(hr);pPortConfig = pPortConfig->GetNext())
            {
                if (fAllChannels || ((pPortConfig->m_PortHeader.dwPChannelBase <= dwPChannel) &&
                    ((pPortConfig->m_PortHeader.dwPChannelCount +
                    pPortConfig->m_PortHeader.dwPChannelBase) > dwPChannel)))
                {
                    pConnect = pPortConfig->m_BufferConnectList.GetHead();
                    for (;pConnect;)
                    {
                        if (fAllChannels || ((pConnect->m_ConnectHeader.dwPChannelBase <= dwPChannel) &&
                            ((pConnect->m_ConnectHeader.dwPChannelCount +
                            pConnect->m_ConnectHeader.dwPChannelBase) > dwPChannel)))
                        {
                            // Found the buffer connect. Which buffer will be determined
                            // by dwBuffer. If dwBuffer is greater than the count of buffer,
                            // decrement and move on to the next pConnect.
                            if (pConnect->m_ConnectHeader.dwBufferCount > dwBuffer)
                            {
                                if (pConnect->m_ppBufferNodes[dwBuffer])
                                {
                                    IDirectSoundBuffer *pBuffer = pConnect->m_ppBufferNodes[dwBuffer]->GetBuffer();
                                    if (pBuffer)
                                    {
                                        if (dwStage == DMUS_PATH_BUFFER)
                                        {
                                            if (dwIndex == 0)
                                            {
                                                hr = pBuffer->QueryInterface(iidInterface,ppObject);
                                            }
                                        }
                                        else
                                        {
                                            IDirectSoundBuffer8 *pBuffer8;
                                            hr = pBuffer->QueryInterface(IID_IDirectSoundBuffer8,(void **) &pBuffer8);
                                            if (SUCCEEDED(hr))
                                            {
                                                hr = pBuffer8->GetObjectInPath(guidObject,dwIndex,iidInterface,ppObject);
                                                pBuffer8->Release();
                                            }
                                        }
                                        pBuffer->Release();
                                    }
                                }
                                pConnect = NULL;
                            }
                            else
                            {
                                dwBuffer -= pConnect->m_ConnectHeader.dwBufferCount;
                            }
                        }
                        if (pConnect)
                        {
                            pConnect = pConnect->GetNext();
                        }
                    }
                }
            }

        }
        break;
    case DMUS_PATH_MIXIN_BUFFER :
    case DMUS_PATH_MIXIN_BUFFER_DMO :
        if (dwPChannel == 0)
        {
            CBufferConfig *pConfig = m_BufferConfigList.GetHead();
            for (;pConfig; pConfig = pConfig->GetNext())
            {
                if (pConfig->m_BufferHeader.dwFlags & DMUS_BUFFERF_MIXIN)
                {
                    if (!dwBuffer)
                    {
                        IDirectSoundBuffer *pBuffer = pConfig->m_pBufferNode->GetBuffer();
                        if (pBuffer)
                        {
                            if (dwStage == DMUS_PATH_MIXIN_BUFFER)
                            {
                                if (dwIndex == 0)
                                {
                                    hr = pBuffer->QueryInterface(iidInterface,ppObject);
                                }
                            }
                            else
                            {
                                IDirectSoundBuffer8 *pBuffer8;
                                hr = pBuffer->QueryInterface(IID_IDirectSoundBuffer8,(void **) &pBuffer8);
                                if (SUCCEEDED(hr))
                                {
                                    hr = pBuffer8->GetObjectInPath(guidObject,dwIndex,iidInterface,ppObject);
                                    pBuffer8->Release();
                                }
                            }
                            pBuffer->Release();
                        }
                        break;
                    }
                    dwBuffer--;
                }
            }
        }
        break;
    case DMUS_PATH_PRIMARY_BUFFER :
        if ((dwIndex == 0) && (dwPChannel == 0))
        {
            CBufferNode *pNode = m_pPerformance->m_BufferManager.GetBufferNode(GUID_Buffer_Primary);
            if (pNode)
            {
                IDirectSoundBuffer *pBuffer = pNode->GetBuffer();
                if (pBuffer)
                {
                    hr = pBuffer->QueryInterface(iidInterface,ppObject);
                    pBuffer->Release();
                }
                pNode->Release();
            }
        }
        break;
    default:
        hr = E_INVALIDARG;
#ifdef DBG
        Trace(1,"Error: Audiopath does not support stage 0x%lx\n",dwStage);
#endif
    }
    LeaveCriticalSection(&m_CriticalSection);
#ifdef DBG
    if (hr == DMUS_E_NOT_FOUND)
    {
        Trace(3,"Warning: Requested AudioPath object not found\n");
    }
#endif
    return hr;
}

HRESULT STDMETHODCALLTYPE CAudioPath::Activate(BOOL fActivate)

{
    TraceI(2,"Audiopath %lx Activate: %ld\n",this,fActivate);
    if (fActivate == m_fActive)
    {
#ifdef DBG
        if (fActivate) Trace(2,"Warning: Attempt to activate already active audiopath.\n");
        else Trace(2,"Warning: Attempt to deactivate already inactive audiopath.\n");
#endif
        return S_FALSE;
    }
    m_fActive = fActivate;
    if (!fActivate && !m_fDeactivating)
    {
        EnterCriticalSection(&m_CriticalSection);
        CPerformance *pPerf = m_pPerformance;
        LeaveCriticalSection(&m_CriticalSection);
        if (pPerf)
        {
            // Kill anything currently playing on the audiopath.
            pPerf->StopEx(static_cast<IDirectMusicAudioPath*>(this),0,0);
        }
    }
    EnterCriticalSection(&m_CriticalSection);
    HRESULT hr = m_BufferConfigList.Activate(fActivate);
    if (SUCCEEDED(hr))
    {
        hr = m_PortConfigList.Activate(fActivate);
        if (FAILED(hr))
        {
            m_BufferConfigList.Activate(!fActivate);
        }
    }
    LeaveCriticalSection(&m_CriticalSection);
    if (FAILED(hr))
    {
        m_fActive = !fActivate;
    }
    return hr;
}

HRESULT STDMETHODCALLTYPE CAudioPath::ConvertPChannel( DWORD dwPChannelIn,DWORD *pdwPChannelOut)

{
    V_INAME(IDirectMusicAudioPath::ConvertPChannel);
    V_PTR_WRITE(pdwPChannelOut,DWORD);

    // If any special PMsg address (for example, broadcast), leave as is.
    if (dwPChannelIn >= DMUS_PCHANNEL_KILL_ME)
    {
        *pdwPChannelOut = dwPChannelIn;
        return S_OK;
    }
    DWORD dwScan = 0;
    for (;dwScan < m_dwChannelCount;dwScan++)
    {
        if (m_pdwVChannels[dwScan] == dwPChannelIn)
        {
            *pdwPChannelOut = m_pdwPChannels[dwScan];
            return S_OK;
        }
    }
    Trace(1,"Error: Audiopath failed request to convert out of range PChannel %ld\n",dwPChannelIn);
    return DMUS_E_NOT_FOUND;
}

HRESULT STDMETHODCALLTYPE CAudioPath::Shutdown()
{
    return E_NOTIMPL;
}

HRESULT STDMETHODCALLTYPE CAudioPath::InsertTool(
    IDirectMusicTool *pTool,
    DWORD *pdwPChannels,
    DWORD cPChannels,
    LONG lIndex)
{
    return E_NOTIMPL;
}

HRESULT STDMETHODCALLTYPE CAudioPath::GetTool(
    DWORD dwIndex,
    IDirectMusicTool** ppTool)
{
    return E_NOTIMPL;
}

HRESULT STDMETHODCALLTYPE CAudioPath::RemoveTool(
    IDirectMusicTool* pTool)
{
    return E_NOTIMPL;
}

HRESULT STDMETHODCALLTYPE CAudioPath::StampPMsg(
    /* [in */ DMUS_PMSG* pPMsg)
{
    V_INAME(IDirectMusicAudioPath::StampPMsg);
    V_BUFPTR_WRITE(pPMsg,sizeof(DMUS_PMSG));

    HRESULT hr = E_FAIL;

    if (!m_fActive)
    {
        // Only kill notes and wave messages, since they are the only PMsgs that make sound.
        if ((pPMsg->dwType == DMUS_PMSGT_NOTE) || (pPMsg->dwType == DMUS_PMSGT_WAVE))
        {
            pPMsg->dwPChannel = DMUS_PCHANNEL_KILL_ME;
            Trace(1,"Error: Attempting to play on an inactive AudioPath, PMsg being ignored.\n");
            return DMUS_E_AUDIOPATH_INACTIVE;
        }
    }
    EnterCriticalSection(&m_CriticalSection);
    if (!m_pPerformance)
    {
        LeaveCriticalSection(&m_CriticalSection);
        return DMUS_E_NOT_INIT;
    }
    // First, check if the audio path has its own graph.
    if (m_pGraph)
    {
        // Could return DMUS_S_LAST_TOOL, indicating end of graph.
        // If so, we'll treat that as a failure and drop on through to the next graph...
        if( S_OK == ( hr = m_pGraph->StampPMsg( pPMsg )))
        {
            if( pPMsg->pGraph != this ) // Make sure this is set to point to the segstate embedded graph so it will come here again.
            {
                if( pPMsg->pGraph )
                {
                    pPMsg->pGraph->Release();
                    pPMsg->pGraph = NULL;
                }
                pPMsg->pGraph = this;
                AddRef();
            }
        }
    }

    // If done with the graph, send to the performance. Also, check for the special case of
    // DMUS_PCHANNEL_BROADCAST_AUDIOPATH. If so, duplicate the pMsg
    // and send all the copies with the appropriate pchannel values.
    // Otherwise, convert the vchannel to the matching pchannel (this is the
    // point where the pchannel mapping occurs.)
    if( FAILED(hr) || (hr == DMUS_S_LAST_TOOL))
    {
        if (pPMsg->dwPChannel == DMUS_PCHANNEL_BROADCAST_AUDIOPATH)
        {
            DWORD dwIndex;
            for (dwIndex = 1;dwIndex < m_dwChannelCount;dwIndex++)
            {
                DWORD dwNewChannel = m_pdwPChannels[dwIndex];
                // Don't broadcast any broadcast messages!
                // And, if this is a transpose on the drum channel, don't send it.
                if ((dwNewChannel < DMUS_PCHANNEL_BROADCAST_GROUPS) &&
                    ((pPMsg->dwType != DMUS_PMSGT_TRANSPOSE) || ((dwNewChannel & 0xF) != 9)))
                {
                    DMUS_PMSG *pNewMsg;
                    if (SUCCEEDED(m_pPerformance->ClonePMsg(pPMsg,&pNewMsg)))
                    {
                        pNewMsg->dwPChannel = dwNewChannel;
                        m_pPerformance->StampPMsg(pNewMsg);
                        m_pPerformance->SendPMsg(pNewMsg);
                    }
                }
            }
            // Now, set the pchannel for this one. First check that there are any
            // pchannels. If none, mark the PMsg to be deleted by the SendPMsg routine.
            // Also, mark it this way if the PMsg is a broadcast PMsg.
            pPMsg->dwPChannel = DMUS_PCHANNEL_KILL_ME;
            if (m_dwChannelCount)
            {
                if (m_pdwPChannels[0] < DMUS_PCHANNEL_BROADCAST_GROUPS)
                {
                    pPMsg->dwPChannel = m_pdwPChannels[0];
                }
            }
        }
        else
        {
            DWORD dwScan = 0;
            for (;dwScan < m_dwChannelCount;dwScan++)
            {
                if (m_pdwVChannels[dwScan] == pPMsg->dwPChannel)
                {
                    pPMsg->dwPChannel = m_pdwPChannels[dwScan];
                    break;
                }
            }
            // If a map was not found, kill the message.
            // But, ignore for notifications, since they really don't care about pchannel.
            // And, ignore for performance broadcast PMsgs.
            if ((dwScan == m_dwChannelCount) &&
                (pPMsg->dwType != DMUS_PMSGT_NOTIFICATION) &&
                (pPMsg->dwPChannel < DMUS_PCHANNEL_BROADCAST_GROUPS))
            {
                pPMsg->dwPChannel = DMUS_PCHANNEL_KILL_ME;
            }
        }
        hr = m_pPerformance->StampPMsg(pPMsg);
    }
    LeaveCriticalSection(&m_CriticalSection);
    return hr;
}

CGraph *CAudioPath::GetGraph()

{
    CGraph *pGraph;
    EnterCriticalSection(&m_CriticalSection);
    // Return the graph, and AddRef if it exists.
    if (pGraph = m_pGraph)
    {
        m_pGraph->AddRef();
    }
    LeaveCriticalSection(&m_CriticalSection);
    return pGraph;
}

void CAudioPath::Deactivate()
{
    m_fDeactivating = TRUE;
    Activate(FALSE);
    EnterCriticalSection(&m_CriticalSection);
    m_fActive = FALSE;
    m_PortConfigList.Clear();
    m_BufferConfigList.Clear();
    if (m_pGraph)
    {
        m_pGraph->Release();
        m_pGraph = NULL;
    }
    if (m_pConfig)
    {
        m_pConfig->Release();
        m_pConfig = NULL;
    }
    if (m_pPerformance)
    {
        if (m_pdwVChannels && m_pdwPChannels)
        {
            DWORD dwIndex;
            for (dwIndex = 0;dwIndex <m_dwChannelCount;dwIndex++)
            {
                m_pPerformance->ReleasePChannel(m_pdwPChannels[dwIndex]);
            }
            delete [] m_pdwVChannels;
            delete [] m_pdwPChannels;
        }
        m_pPerformance->m_AudioPathList.Remove(this);
        m_pPerformance->RemoveUnusedPorts();
        m_pPerformance->Release();
        m_pPerformance = NULL;
    }
    m_fDeactivating = FALSE;
    LeaveCriticalSection(&m_CriticalSection);
}

void CAudioPath::SetGraph(CGraph *pGraph)

{
    EnterCriticalSection(&m_CriticalSection);
    // Is this a change?
    if (!m_pGraph)
    {
        pGraph->Clone((IDirectMusicGraph **) &m_pGraph);
    }
    LeaveCriticalSection(&m_CriticalSection);
}


CBufferNode * CAudioPath::GetBufferNode(REFGUID guidBuffer)

{
    CBufferNode *pBuff = NULL;
    EnterCriticalSection(&m_CriticalSection);
    pBuff = m_BufferConfigList.GetBufferNode(guidBuffer);
    if (!pBuff)
    {
        CPortConfig *pConfig = m_PortConfigList.GetHead();
        for (;pConfig;pConfig = pConfig->GetNext())
        {
            pBuff = pConfig->GetBufferNode(guidBuffer);
            if (pBuff)
            {
                break;
            }
        }
    }
    LeaveCriticalSection(&m_CriticalSection);
    if (!pBuff)
    {
        pBuff = m_pPerformance->m_BufferManager.GetBufferNode(guidBuffer);
    }
    return pBuff;
}


HRESULT CAudioPath::Init(IUnknown *pSourceConfig,CPerformance *pPerf)

{
    HRESULT hr = E_INVALIDARG;
    EnterCriticalSection(&m_CriticalSection);
    m_pPerformance = pPerf;
    pPerf->m_AudioPathList.AddHead(this);
    pPerf->AddRef();
    if (pPerf && pSourceConfig)
    {
        if (SUCCEEDED(hr = pSourceConfig->QueryInterface(IID_CAudioPathConfig,(void **) &m_pConfig)))
        {
            if (m_pConfig->m_pGraph)
            {
                SetGraph(m_pConfig->m_pGraph);
            }
            // The very first audio path has to create the sink.
            hr = pPerf->m_BufferManager.InitSink();

            if (SUCCEEDED(hr))
            {
                // First, install any global buffers that are required.
                hr = m_pConfig->m_BufferConfigList.CreateRunTimeVersion(&m_BufferConfigList,&pPerf->m_BufferManager);
                if (SUCCEEDED(hr))
                {
                    // Then, install the ports and buffers.
                    hr = m_pConfig->m_PortConfigList.CreateRunTimeVersion(&m_PortConfigList,this,&pPerf->m_BufferManager);
                    if (SUCCEEDED(hr))
                    {
                        hr = ConnectToPorts(pPerf,pPerf->m_AudioParams.dwSampleRate);
                    }
                }
            }
        }
    }
    LeaveCriticalSection(&m_CriticalSection);
    return hr;
}

HRESULT CAudioPath::ConnectToPorts(CPerformance *pPerf,DWORD dwSampleRate)

/*  This must be called from within a critical section.
*/

{
    HRESULT hr = S_OK;
    // Scan through the list of portconfigs and hook them up with active ports
    // in the performance. If a port is not available, create the port.
    CPortConfig *pConfig = m_PortConfigList.GetHead();
    DWORD dwChannelCount = 0;   // Used to add up total PChannels needed.
    for (;pConfig && SUCCEEDED(hr);pConfig = pConfig->GetNext())
    {
        // Given the configuration, either find a port with a matching id, or create one.
        hr = pPerf->GetPathPort(pConfig);
        dwChannelCount += pConfig->m_PortHeader.dwPChannelCount;
    }
    if (SUCCEEDED(hr))
    {
        // Now, allocate the VChannels needed for each portconfig.
        m_pdwVChannels = new DWORD[dwChannelCount];
        if (m_pdwVChannels)
        {
            m_pdwPChannels = new DWORD[dwChannelCount];
            if (!m_pdwPChannels)
            {
                delete [] m_pdwVChannels;
                m_pdwVChannels = NULL;
                hr = E_OUTOFMEMORY;
            }
        }
        else
        {
            hr = E_OUTOFMEMORY;
        }
    }
    if (SUCCEEDED(hr))
    {
        // Scan through the port configs and allocate the pchannels, copying the assignments
        // into virtual channel assignment arrays.
        pConfig = m_PortConfigList.GetHead();
        DWORD dwIndex = 0;
        for (;pConfig;pConfig = pConfig->GetNext())
        {
            // If this port uses buffers, then connect them up.
            if (((pConfig->m_PortParams.dwValidParams & DMUS_PORTPARAMS_FEATURES) &&
                (pConfig->m_PortParams.dwFeatures & DMUS_PORT_FEATURE_AUDIOPATH)))
            {
                CBufferConnect *pConnect = pConfig->m_BufferConnectList.GetHead();
                for (;pConnect && SUCCEEDED(hr);pConnect = pConnect->GetNext())
                {
                    // For each connect block, there should be an array of buffers
                    // to connect the range of PChannels to.
                    // For each PChannel, get a virtual pchannel and then assign
                    // it to the bus ids that belong to the buffers.
                    if (pConnect->m_ppBufferNodes)
                    {
                        DWORD dwCount = 0;
                        DWORD dwBusIDs[32];
                        DWORD *pdwBusIDBase = &dwBusIDs[0];
                        DWORD dwTotalRead = 0;
                        DWORD dwAmountLeft = 32;
                        for (;(dwCount < pConnect->m_ConnectHeader.dwBufferCount) && dwAmountLeft; dwCount++)
                        {
                            if (pConnect->m_ppBufferNodes[dwCount] && !(pConnect->m_ppBufferNodes[dwCount]->m_BufferHeader.dwFlags & DMUS_BUFFERF_PRIMARY))
                            {
                                IDirectSoundBuffer *pBuffer = pConnect->m_ppBufferNodes[dwCount]->GetBuffer();
                                if (pBuffer)
                                {
                                    dwTotalRead = dwAmountLeft;
                                    hr = m_pPerformance->m_BufferManager.m_pSinkConnect->GetSoundBufferBusIDs(pBuffer,pdwBusIDBase,NULL,&dwTotalRead);
                                    pBuffer->Release();
                                    if (FAILED(hr)) break;
                                    pdwBusIDBase += dwTotalRead; // Increment pointer by how many was read.
                                    dwAmountLeft -=  dwTotalRead;
                                }
                            }
                        }
                        if (SUCCEEDED(hr))
                        {
                            dwTotalRead = 32 - dwAmountLeft;
                            // Now, allocate the pchannels and assign them to buses.
                            IDirectMusicPortP* pPortP = NULL;
                            if (SUCCEEDED(pConfig->m_pPort->QueryInterface(IID_IDirectMusicPortP, (void**)&pPortP)))
                            {
                                for (dwCount = 0;dwCount < pConnect->m_ConnectHeader.dwPChannelCount; dwCount++)
                                {
                                    DWORD dwDrumFlags = 0;
                                    m_pdwVChannels[dwIndex] = pConnect->m_ConnectHeader.dwPChannelBase + dwCount;
                                    if (pConfig->m_PortHeader.dwFlags & DMUS_PORTCONFIGF_DRUMSON10)
                                    {
                                        dwDrumFlags = 1;
                                        if (((pConnect->m_ConnectHeader.dwPChannelBase + dwCount) & 0xF) == 9)
                                        {
                                            // This is a drum on channel 10.
                                            dwDrumFlags |= 2;
                                        }
                                    }
                                    // Now, allocate a virtual pchannel for this and get back the equivalent group and midi channel.
                                    DWORD dwGroup;
                                    DWORD dwMChannel;
                                    hr = pPerf->AllocVChannel(pConfig->m_dwPortID,dwDrumFlags,&m_pdwPChannels[dwIndex],&dwGroup,&dwMChannel);
                                    if (dwTotalRead && SUCCEEDED(hr))
                                    {
                                        hr = pPortP->AssignChannelToBuses(dwGroup,dwMChannel,dwBusIDs,dwTotalRead);
                                    }
                                    dwIndex++;
                                }
                                pPortP->Release();
                            }
                        }
                    }
                }
            }
            else
            {
                DWORD dwCount;
                for (dwCount = 0;SUCCEEDED(hr) && (dwCount < pConfig->m_PortHeader.dwPChannelCount); dwCount++)
                {
                    DWORD dwDrumFlags = 0;
                    m_pdwVChannels[dwIndex] = pConfig->m_PortHeader.dwPChannelBase + dwCount;
                    if (pConfig->m_PortHeader.dwFlags & DMUS_PORTCONFIGF_DRUMSON10)
                    {
                        dwDrumFlags = 1;
                        if (((pConfig->m_PortHeader.dwPChannelBase + dwCount) & 0xF) == 9)
                        {
                            // This is a drum on channel 10.
                            dwDrumFlags |= 2;
                        }
                    }
                    // Now, allocate a virtual pchannel for this.
                    DWORD dwGroup; // These won't be used since we won't be assigning pchannels on the port to buffers.
                    DWORD dwMChannel;
                    hr = pPerf->AllocVChannel(pConfig->m_dwPortID,dwDrumFlags,&m_pdwPChannels[dwIndex],&dwGroup,&dwMChannel);
/*                    Trace(0,"%ld: Mapping %ld to %ld (Port %ld, Group %ld, Channel %ld)\n",
                        dwIndex,m_pdwVChannels[dwIndex],m_pdwPChannels[dwIndex],
                        pConfig->m_dwPortID,dwGroup,dwMChannel);*/

                    dwIndex++;
                }
            }
        }
    }
    m_dwChannelCount = dwChannelCount;
    return hr;
}

void CAudioPathList::Clear()
{
    CAudioPath *pPath;
    while (pPath = GetHead())
    {
        pPath->Deactivate(); // This should also remove it from the list.
        assert(pPath != GetHead()); // Make sure this is always the case!
    }
}

CBufferNode * CAudioPathList::GetBufferNode(REFGUID guidBufferID)

{
    CBufferNode *pBuff = NULL;
    CAudioPath *pPath;
    for (pPath = GetHead();pPath;pPath = pPath->GetNext())
    {
        pBuff = pPath->GetBufferNode(guidBufferID);
        if (pBuff)
        {
            break;
        }
    }
    return pBuff;
}

BOOL CAudioPathList::UsesPort(IDirectMusicPort *pPort)

{
    CAudioPath *pPath = GetHead();
    for (;pPath;pPath = pPath->GetNext())
    {
        if (pPath->UsesPort(pPort))
        {
            return TRUE;
        }
    }
    return FALSE;
}

CAudioPathConfig::CAudioPathConfig()
{
    m_pGraph = NULL;
    m_fPartialLoad = 0;
    m_cRef = 1;
    memset(&m_guidObject,0,sizeof(m_guidObject));
    m_dwValidData = DMUS_OBJ_CLASS; // upon creation, only this data is valid
    memset(&m_guidObject,0,sizeof(m_guidObject));
    memset(&m_ftDate, 0,sizeof(m_ftDate));
    memset(&m_vVersion, 0,sizeof(m_vVersion));
    m_pUnkDispatch = NULL;

    InitializeCriticalSection(&m_CriticalSection);
    InterlockedIncrement(&g_cComponent);
}

CAudioPathConfig::~CAudioPathConfig()
{
    if (m_pGraph)
    {
        m_pGraph->Release();
    }
    if (m_pUnkDispatch)
    {
        m_pUnkDispatch->Release(); // free IDispatch implementation we may have borrowed
    }
    m_PortConfigList.Clear();
    m_BufferConfigList.Clear();
    DeleteCriticalSection(&m_CriticalSection);
    InterlockedDecrement(&g_cComponent);
}

CAudioPathConfig *CAudioPathConfig::CreateStandardConfig(DWORD dwType,DWORD dwPChannelCount,DWORD dwSampleRate)

{
    CAudioPathConfig *pConfig = new CAudioPathConfig;
    if (pConfig)
    {
        DWORD dwGlobalType = 0;         // Global mixin buffer.
        DWORD dwTypes[3];               // What types of buffers to create.
        DWORD dwTotal = 0;              // How many buffers.
        GUID  guidBufferIDs[3];         // IDs of buffers that should be connected to.
        DWORD dwConnections = 0;        // How many buffer connections.
        BOOL fCreatePort = TRUE;
        switch (dwType)
        {
        case DMUS_APATH_SHARED_STEREOPLUSREVERB:
            dwTypes[0] = BUFFER_MUSIC;
            dwTypes[1] = BUFFER_REVERB;
            guidBufferIDs[0] = GUID_Buffer_Stereo;
            guidBufferIDs[1] = GUID_Buffer_Reverb;
            dwConnections = 2;
            dwTotal = 2;
            break;
        // Following removed for DX8, should be reintroduced for Whistler and DX8.1...
/*        case DMUS_APATH_DYNAMIC_ENV3D:
            dwGlobalType = BUFFER_ENVREVERB;
            dwTypes[0] = BUFFER_3D;
            guidBufferIDs[0] = GUID_Buffer_3D;
            dwConnections = 1;
            dwTotal = 1;
            break;*/
        case DMUS_APATH_DYNAMIC_3D:
            dwTypes[0] = BUFFER_3D_DRY;
            guidBufferIDs[0] = GUID_Buffer_3D_Dry;
            dwConnections = 1;
            dwTotal = 1;
            break;
        case DMUS_APATH_DYNAMIC_MONO:
            dwTypes[0] = BUFFER_MONO;
            guidBufferIDs[0] = GUID_Buffer_Mono;
            dwConnections = 1;
            dwTotal = 1;
            break;
        case DMUS_APATH_DYNAMIC_STEREO:
            dwTypes[0] = BUFFER_STEREO;
            guidBufferIDs[0] = GUID_Buffer_Stereo;
            dwConnections = 1;
            dwTotal = 1;
            break;
        }
        if (dwGlobalType)
        {
            CBufferConfig *pBuffer = new CBufferConfig(dwGlobalType);
            if (pBuffer)
            {
                // This buffer configuration just has an id to identify which standard
                // buffer, instead of a pointer to a DSoundBufferConfig object,
                // which is what you'd see in the file io case.
                pConfig->m_BufferConfigList.AddHead(pBuffer);
            }
            else
            {
                delete pConfig;
                return NULL;
            }
        }
        if (fCreatePort)
        {
            CPortConfig *pPort = new CPortConfig();
            if (pPort)
            {
                pConfig->m_PortConfigList.AddHead(pPort);
                for (DWORD dwIndex = 0; dwIndex < dwTotal; dwIndex++)
                {
                    CBufferConfig *pBuffer = new CBufferConfig(dwTypes[dwIndex]);
                    if (pBuffer)
                    {
                        // This buffer configuration just has an id to identify which standard
                        // buffer, instead of a pointer to a DSoundBufferConfig object,
                        // which is what you'd see in the file io case.
                        pPort->m_BufferConfigList.AddHead(pBuffer);
                    }
                    else
                    {
                        delete pConfig;
                        return NULL;
                    }
                }
                // If there are connections to buffers, create the connection structure.
                if (dwConnections)
                {
                    CBufferConnect *pConnect = new CBufferConnect;
                    if (pConnect)
                    {
                        pPort->m_BufferConnectList.AddHead(pConnect);
                        pConnect->m_ConnectHeader.dwBufferCount = dwConnections;
                        pConnect->m_ConnectHeader.dwFlags = 0;
                        pConnect->m_ConnectHeader.dwPChannelBase = 0;
                        pConnect->m_ConnectHeader.dwPChannelCount = dwPChannelCount;
                        pConnect->m_pguidBufferIDs = new GUID[dwConnections];
                        if (pConnect->m_pguidBufferIDs)
                        {
                            for (DWORD dwIndex = 0; dwIndex < dwConnections; dwIndex++)
                            {
                                pConnect->m_pguidBufferIDs[dwIndex] = guidBufferIDs[dwIndex];
                            }
                        }
                        else
                        {
                            delete pConfig;
                            return NULL;
                        }
                    }
                }
                pPort->m_PortHeader.dwPChannelCount = dwPChannelCount;
                pPort->m_PortParams.dwChannelGroups = (dwPChannelCount + 15) / 16;
            }
            else
            {
                delete pConfig;
                pConfig = NULL;
            }
        }
    }
    return pConfig;
}



STDMETHODIMP CAudioPathConfig::QueryInterface(
    const IID &iid,
    void **ppv)
{
    V_INAME(CAudioPathConfig::QueryInterface);
    V_PTRPTR_WRITE(ppv);
    V_REFGUID(iid);

    *ppv = NULL;
    if ((iid == IID_IUnknown ) || (iid == IID_IDirectMusicObject))
    {
        *ppv = static_cast<IDirectMusicObject*>(this);
    }
    else if (iid == IID_IPersistStream)
    {
        *ppv = static_cast<IPersistStream*>(this);
    }
    else if (iid == IID_CAudioPathConfig)
    {
        *ppv = static_cast<CAudioPathConfig*>(this);
    }
    else if (iid == IID_IDispatch)
    {
        // A helper scripting object implements IDispatch, which we expose via COM aggregation.
        if (!m_pUnkDispatch)
        {
            // Create the helper object
            ::CoCreateInstance(
                CLSID_AutDirectMusicAudioPathConfig,
                static_cast<IDirectMusicObject*>(this),
                CLSCTX_INPROC_SERVER,
                IID_IUnknown,
                reinterpret_cast<void**>(&m_pUnkDispatch));
        }
        if (m_pUnkDispatch)
        {
            return m_pUnkDispatch->QueryInterface(IID_IDispatch, ppv);
        }
    }

    if (*ppv == NULL)
    {
        Trace(4,"Warning: Request to query unknown interface on AudioPathConfig object\n");
        return E_NOINTERFACE;
    }
    AddRef();
    return S_OK;
}


STDMETHODIMP_(ULONG) CAudioPathConfig::AddRef()
{
    return InterlockedIncrement(&m_cRef);
}

STDMETHODIMP_(ULONG) CAudioPathConfig::Release()
{
    if (!InterlockedDecrement(&m_cRef))
    {
        delete this;
        return 0;
    }

    return m_cRef;
}

STDMETHODIMP CAudioPathConfig::GetDescriptor(LPDMUS_OBJECTDESC pDesc)
{
    // Argument validation
    V_INAME(CAudioPathConfig::GetDescriptor);
    V_STRUCTPTR_WRITE(pDesc, DMUS_OBJECTDESC);
    pDesc->guidClass = CLSID_DirectMusicAudioPathConfig;
    pDesc->guidObject = m_guidObject;
    pDesc->ftDate = m_ftDate;
    pDesc->vVersion = m_vVersion;
    memcpy( pDesc->wszName, m_wszName, sizeof(m_wszName) );
    memcpy( pDesc->wszCategory, m_wszCategory, sizeof(m_wszCategory) );
    memcpy( pDesc->wszFileName, m_wszFileName, sizeof(m_wszFileName) );
    pDesc->dwValidData = ( m_dwValidData | DMUS_OBJ_CLASS );
    return S_OK;
}

STDMETHODIMP CAudioPathConfig::SetDescriptor(LPDMUS_OBJECTDESC pDesc)
{
    // Argument validation
    V_INAME(CAudioPathConfig::SetDescriptor);
    V_STRUCTPTR_READ(pDesc, DMUS_OBJECTDESC);

    HRESULT hr = E_INVALIDARG;
    DWORD dw = 0;

    if( pDesc->dwSize >= sizeof(DMUS_OBJECTDESC) )
    {
        if( pDesc->dwValidData & DMUS_OBJ_OBJECT )
        {
            m_guidObject = pDesc->guidObject;
            dw |= DMUS_OBJ_OBJECT;
        }
        if( pDesc->dwValidData & DMUS_OBJ_NAME )
        {
            memcpy( m_wszName, pDesc->wszName, sizeof(WCHAR)*DMUS_MAX_NAME );
            dw |= DMUS_OBJ_NAME;
        }
        if( pDesc->dwValidData & DMUS_OBJ_CATEGORY )
        {
            memcpy( m_wszCategory, pDesc->wszCategory, sizeof(WCHAR)*DMUS_MAX_CATEGORY );
            dw |= DMUS_OBJ_CATEGORY;
        }
        if( ( pDesc->dwValidData & DMUS_OBJ_FILENAME ) ||
            ( pDesc->dwValidData & DMUS_OBJ_FULLPATH ) )
        {
            memcpy( m_wszFileName, pDesc->wszFileName, sizeof(WCHAR)*DMUS_MAX_FILENAME );
            dw |= (pDesc->dwValidData & (DMUS_OBJ_FILENAME | DMUS_OBJ_FULLPATH));
        }
        if( pDesc->dwValidData & DMUS_OBJ_VERSION )
        {
            m_vVersion = pDesc->vVersion;
            dw |= DMUS_OBJ_VERSION;
        }
        if( pDesc->dwValidData & DMUS_OBJ_DATE )
        {
            m_ftDate = pDesc->ftDate;
            dw |= DMUS_OBJ_DATE;
        }
        m_dwValidData |= dw;
        if( pDesc->dwValidData & (~dw) )
        {
            Trace(2,"Warning: AudioPathConfig::SetDescriptor was not able to handle all passed fields, dwValidData bits %lx.\n",pDesc->dwValidData & (~dw));
            hr = S_FALSE; // there were extra fields we didn't parse;
            pDesc->dwValidData = dw;
        }
        else
        {
            hr = S_OK;
        }
    }
    else
    {
        Trace(1,"Error: Descriptor size is larger than AudioPathConfig::SetDescriptor can handle\n");
    }
    return hr;
}

STDMETHODIMP CAudioPathConfig::ParseDescriptor(LPSTREAM pIStream, LPDMUS_OBJECTDESC pDesc)

{
    V_INAME(CAudioPathConfig::ParseDescriptor);
    V_INTERFACE(pIStream);
    V_STRUCTPTR_WRITE(pDesc, DMUS_OBJECTDESC);

    CRiffParser Parser(pIStream);
    RIFFIO ckMain;
    RIFFIO ckNext;
    RIFFIO ckUNFO;
    HRESULT hr = S_OK;

    Parser.EnterList(&ckMain);
    if (Parser.NextChunk(&hr) && (ckMain.fccType == DMUS_FOURCC_AUDIOPATH_FORM))
    {
        pDesc->dwValidData = DMUS_OBJ_CLASS;
        pDesc->guidClass = CLSID_DirectMusicAudioPathConfig;
        Parser.EnterList(&ckNext);
        while(Parser.NextChunk(&hr))
        {
            switch(ckNext.ckid)
            {
            case DMUS_FOURCC_GUID_CHUNK:
                hr = Parser.Read( &pDesc->guidObject, sizeof(GUID) );
                if( SUCCEEDED(hr) )
                {
                    pDesc->dwValidData |= DMUS_OBJ_OBJECT;
                }
                break;
            case DMUS_FOURCC_VERSION_CHUNK:
                hr = Parser.Read( &pDesc->vVersion, sizeof(DMUS_VERSION) );
                if( SUCCEEDED(hr) )
                {
                    pDesc->dwValidData |= DMUS_OBJ_VERSION;
                }
                break;

            case DMUS_FOURCC_CATEGORY_CHUNK:
                hr = Parser.Read( &pDesc->wszCategory, sizeof(pDesc->wszCategory) );
                if( SUCCEEDED(hr) )
                {
                    pDesc->dwValidData |= DMUS_OBJ_CATEGORY;
                }
                break;

            case DMUS_FOURCC_DATE_CHUNK:
                hr = Parser.Read( &pDesc->ftDate, sizeof(FILETIME) );
                if( SUCCEEDED(hr))
                {
                    pDesc->dwValidData |= DMUS_OBJ_DATE;
                }
                break;
            case FOURCC_LIST:
                switch(ckNext.fccType)
                {
                case DMUS_FOURCC_UNFO_LIST:
                    Parser.EnterList(&ckUNFO);
                    while (Parser.NextChunk(&hr))
                    {
                        switch( ckUNFO.ckid )
                        {
                        case DMUS_FOURCC_UNAM_CHUNK:
                        {
                            hr = Parser.Read(&pDesc->wszName, sizeof(pDesc->wszName));
                            if(SUCCEEDED(hr) )
                            {
                                pDesc->dwValidData |= DMUS_OBJ_NAME;
                            }
                            break;
                        }
                        default:
                            break;
                        }
                    }
                    Parser.LeaveList();
                    break;
                }
                break;

            default:
                break;

            }
        }
        Parser.LeaveList();
    }
    else
    {
        Trace(1,"Error: Failed parsing - file is not AudioPathConfig format.\n");
        hr = DMUS_E_CHUNKNOTFOUND;
    }
    return hr;
}

/////////////////////////////////////////////////////////////////////////////
// IPersist

HRESULT CAudioPathConfig::GetClassID( CLSID* pClassID )
{
    V_INAME(CAudioPathConfig::GetClassID);
    V_PTR_WRITE(pClassID, CLSID);
    *pClassID = CLSID_DirectMusicAudioPathConfig;
    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
// IPersistStream functions

HRESULT CAudioPathConfig::IsDirty()
{
    return S_FALSE;
}

HRESULT CAudioPathConfig::Load( IStream* pIStream )
{
    V_INAME(IPersistStream::Load);
    V_INTERFACE(pIStream);

    CRiffParser Parser(pIStream);
    RIFFIO ckMain;
    HRESULT hr = S_OK;

    Parser.EnterList(&ckMain);
    if (Parser.NextChunk(&hr) && (ckMain.fccType == DMUS_FOURCC_AUDIOPATH_FORM))
    {
        EnterCriticalSection(&m_CriticalSection);
        // Clear out any data that was previously loaded.
        if (m_pGraph)
        {
            m_pGraph->Release();
        }
        m_PortConfigList.Clear();
        m_BufferConfigList.Clear();
        hr = Load(&Parser);
        LeaveCriticalSection(&m_CriticalSection);
    }
    else
    {
        Trace(1,"Error: Failed parsing - file is not AudioPathConfig format.\n");
        hr = DMUS_E_DESCEND_CHUNK_FAIL;
    }
    return hr;
}

HRESULT CAudioPathConfig::Load(CRiffParser *pParser)

{
    RIFFIO ckNext;
    HRESULT hr = S_OK;

    EnterCriticalSection(&m_CriticalSection);

    pParser->EnterList(&ckNext);
    while(pParser->NextChunk(&hr))
    {
        switch(ckNext.ckid)
        {
            case DMUS_FOURCC_GUID_CHUNK:
                hr = pParser->Read( &m_guidObject, sizeof(GUID) );
                if( SUCCEEDED(hr) )
                {
                    m_dwValidData |= DMUS_OBJ_OBJECT;
                }
                break;
            case DMUS_FOURCC_VERSION_CHUNK:
                hr = pParser->Read( &m_vVersion, sizeof(DMUS_VERSION) );
                if( SUCCEEDED(hr) )
                {
                    m_dwValidData |= DMUS_OBJ_VERSION;
                }
                break;

            case DMUS_FOURCC_CATEGORY_CHUNK:
                hr = pParser->Read( &m_wszCategory, sizeof(WCHAR)*DMUS_MAX_CATEGORY );
                if( SUCCEEDED(hr) )
                {
                    m_dwValidData |= DMUS_OBJ_CATEGORY;
                }
                break;

            case DMUS_FOURCC_DATE_CHUNK:
                hr = pParser->Read( &m_ftDate, sizeof(FILETIME) );
                if( SUCCEEDED(hr))
                {
                    m_dwValidData |= DMUS_OBJ_DATE;
                }
                break;
            case FOURCC_LIST:
            case FOURCC_RIFF:
                switch(ckNext.fccType)
                {
                    RIFFIO ckChild;
                    case DMUS_FOURCC_UNFO_LIST:
                        pParser->EnterList(&ckChild);
                        while (pParser->NextChunk(&hr))
                        {
                            switch( ckChild.ckid )
                            {
                                case DMUS_FOURCC_UNAM_CHUNK:
                                {
                                    hr = pParser->Read(&m_wszName, sizeof(m_wszName));
                                    if(SUCCEEDED(hr) )
                                    {
                                        m_dwValidData |= DMUS_OBJ_NAME;
                                    }
                                    break;
                                }
                                default:
                                    break;
                            }
                        }
                        pParser->LeaveList();
                        break;
                    case DMUS_FOURCC_PORTCONFIGS_LIST:
                        pParser->EnterList(&ckChild);
                        while (pParser->NextChunk(&hr))
                        {
                            switch( ckChild.ckid )
                            {
                            case FOURCC_LIST:
                                if (ckChild.fccType == DMUS_FOURCC_PORTCONFIG_LIST)
                                {
                                    CPortConfig *pConfig = new CPortConfig();
                                    if (pConfig)
                                    {
                                        hr = pConfig->Load(pParser);
                                        if (SUCCEEDED(hr))
                                        {
                                            m_PortConfigList.AddTail(pConfig);
                                        }
                                    }
                                    else
                                    {
                                        hr = E_OUTOFMEMORY;
                                    }
                                }
                                break;
                            }
                        }
                        pParser->LeaveList();
                        break;
                    case DMUS_FOURCC_DSBUFFER_LIST:
                        {
                            CBufferConfig *pSource = new CBufferConfig(0);
                            if (pSource)
                            {
                                pParser->EnterList(&ckChild);
                                while (pParser->NextChunk(&hr))
                                {
                                    switch( ckChild.ckid )
                                    {
                                    case DMUS_FOURCC_DSBUFFATTR_ITEM:
                                        hr = pParser->Read(&pSource->m_BufferHeader,
                                            sizeof(DMUS_IO_BUFFER_ATTRIBUTES_HEADER));
                                        pSource->DecideType();
                                        break;
                                    case FOURCC_LIST:
                                    case FOURCC_RIFF:
                                        if ( ckChild.fccType == DMUS_FOURCC_DSBC_FORM)
                                        {
                                            pParser->SeekBack();
                                            hr = pSource->Load(pParser->GetStream());
                                            pParser->SeekForward();
                                        }
                                    }
                                }
                                if (SUCCEEDED(hr))
                                {
                                    m_BufferConfigList.AddTail(pSource);
                                }
                                else
                                {
                                    delete pSource;
                                    Trace(1,"Error: AudioPath Configuration failed loading buffer\n");
                                }
                                pParser->LeaveList();
                            }
                            else
                            {
                                hr = E_OUTOFMEMORY;
                            }
                        }
                        break;
                    case DMUS_FOURCC_DSBC_FORM:
                        {
                            CBufferConfig *pSource = new CBufferConfig(0);
                            if (pSource)
                            {
                                pParser->SeekBack();
                                hr = pSource->Load(pParser->GetStream());
                                pParser->SeekForward();
                                if (SUCCEEDED(hr))
                                {
                                    m_BufferConfigList.AddTail(pSource);
                                }
                                else
                                {
                                    Trace(1,"Error: AudioPath Configuration failed loading buffer\n");
                                    delete pSource;
                                }
                            }
                            else
                            {
                                hr = E_OUTOFMEMORY;
                            }
                        }
                        break;
                    case DMUS_FOURCC_TOOLGRAPH_FORM:
                        {
                            CGraph *pGraph = new CGraph;
                            if (pGraph)
                            {
                                hr = pGraph->Load(pParser);
                                if(m_pGraph)
                                {
                                    m_pGraph->Release();
                                }
                                m_pGraph = pGraph;
                            }
                            else
                            {
                                hr = E_OUTOFMEMORY;
                            }
                        }
                        break;
                }
                break;
        }
    }
    pParser->LeaveList();
    LeaveCriticalSection(&m_CriticalSection);
    return hr;
}

HRESULT CAudioPathConfig::Save( IStream* pIStream, BOOL fClearDirty )
{
    return E_NOTIMPL;
}

HRESULT CAudioPathConfig::GetSizeMax( ULARGE_INTEGER FAR* pcbSize )
{
    return E_NOTIMPL;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\XDmime\bandinst.h ===
//
// bandinst.h
// 
// Copyright (c) 1997-1999 Microsoft Corporation
//
// Note: Originally written by Robert K. Amenn
//

#ifndef BANDINST_H
#define BANDINST_H

#include "dmusicc.h"
#include "alist.h"

struct IDirectMusicPerformance;
struct IDirectMusicPerformanceP;
struct IDirectMusicAudioPath;
class CBandInstrumentList;
class CBand;
class CBandTrk;

class CDownloadedInstrument : public AListItem
{
public:
	CDownloadedInstrument() 
    {
	    m_pDLInstrument = NULL; 
	    m_pPort = NULL; 
	    m_cRef = 1;
    }
	~CDownloadedInstrument();
	CDownloadedInstrument* GetNext(){return(CDownloadedInstrument*)AListItem::GetNext();}

public:
	IDirectMusicDownloadedInstrument* m_pDLInstrument;
	IDirectMusicPort*				  m_pPort;
	long							  m_cRef;

}; 

class CDownloadList : public AList
{
public:
	CDownloadList(){}
    ~CDownloadList() { Clear(); }
    void Clear();
    CDownloadedInstrument* GetHead(){return(CDownloadedInstrument *)AList::GetHead();}
	CDownloadedInstrument* GetItem(LONG lIndex){return(CDownloadedInstrument*)AList::GetItem(lIndex);}
    CDownloadedInstrument* RemoveHead(){return(CDownloadedInstrument *)AList::RemoveHead();}
	void Remove(CDownloadedInstrument* pDownloadedInstrument){AList::Remove((AListItem *)pDownloadedInstrument);}
	void AddTail(CDownloadedInstrument* pDownloadedInstrument){AList::AddTail((AListItem *)pDownloadedInstrument);}
};

//////////////////////////////////////////////////////////////////////
// Class CBandInstrument

class CBandInstrument : public AListItem
{
friend CBand;
friend CBandTrk;

public:
	CBandInstrument();
	~CBandInstrument();
	CBandInstrument* GetNext(){return(CBandInstrument*)AListItem::GetNext();}
    HRESULT Download(IDirectMusicPerformanceP *pPerformance, 
                                  IDirectMusicAudioPath *pPath,
                                  DWORD dwMIDIMode);
    HRESULT Unload(IDirectMusicPerformanceP *pPerformance, IDirectMusicAudioPath *pPath);

private:
    HRESULT DownloadAddRecord(IDirectMusicPort *pPort);
    HRESULT BuildNoteRangeArray(DWORD *pNoteRangeMap, DMUS_NOTERANGE **ppNoteRanges, DWORD *pdwNumNoteRanges);
	DWORD								m_dwPatch;			// Patch used with DLS Collection		
	DWORD								m_dwAssignPatch;	// Patch used with Download overrides m_dwPatch
	DWORD								m_dwChannelPriority;
	BYTE								m_bPan;
	BYTE								m_bVolume;
	short								m_nTranspose;
	BOOL								m_fGMOnly;
	BOOL								m_fNotInFile;
	DWORD								m_dwFullPatch; // if m_fGMOnly is true, this contains the original, premodified, m_dwPatch
	DWORD								m_dwPChannel;
	DWORD								m_dwFlags;
	DWORD								m_dwNoteRanges[4];
	short								m_nPitchBendRange;
	IDirectMusicCollection*				m_pIDMCollection;
	CDownloadList                  		m_DownloadList;
};

//////////////////////////////////////////////////////////////////////
// Class CBandInstrumentList

class CBandInstrumentList : public AList
{
public:
	CBandInstrumentList(){}
    ~CBandInstrumentList() { Clear(); }
    void Clear();
    CBandInstrument* GetHead(){return(CBandInstrument *)AList::GetHead();}
	CBandInstrument* GetItem(LONG lIndex){return(CBandInstrument*)AList::GetItem(lIndex);}
    CBandInstrument* RemoveHead(){return(CBandInstrument *)AList::RemoveHead();}
	void Remove(CBandInstrument* pBandInstrument){AList::Remove((AListItem *)pBandInstrument);}
	void AddTail(CBandInstrument* pBandInstrument){AList::AddTail((AListItem *)pBandInstrument);}
};

// CDestination keeps track of which performance or audiopath the band was downloaded to.

class CDestination : public AListItem
{
public:
	CBandInstrument* GetNext(){return(CBandInstrument*)AListItem::GetNext();}
    IUnknown *          m_pDestination; // Performance or audiopath this download was sent to. This is a weak reference, no AddRef.
};

class CDestinationList : public AList
{
public:
	CDestinationList(){}
    ~CDestinationList() { Clear(); }
    void Clear();
    CDestination* GetHead(){return(CDestination *)AList::GetHead();}
	CDestination* GetItem(LONG lIndex){return(CDestination*)AList::GetItem(lIndex);}
    CDestination* RemoveHead(){return(CDestination *)AList::RemoveHead();}
	void Remove(CDestination* pDestination){AList::Remove((AListItem *)pDestination);}
	void AddTail(CDestination* pDestination){AList::AddTail((AListItem *)pDestination);}
};


#endif // #ifndef BANDINST_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\XDmime\bandtrk.h ===
//
// bandtrk.h
// 
// Copyright (c) 1997-2000 Microsoft Corporation
//

#ifndef BANDTRK_H
#define BANDTRK_H

#include "dmbndtrk.h"
#include "dmbandp.h"

class SeekEvent;

struct IDirectMusicPerformance;
class CRiffParser;

//////////////////////////////////////////////////////////////////////
// Class CBandTrk

class CBandTrk : public IDirectMusicTrack8, public IDirectMusicBandTrk, public IPersistStream
{
    friend CBand;
public:
	// IUnknown
    //
    STDMETHODIMP QueryInterface(const IID &iid, void **ppv);
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();

    // IPersist
    STDMETHODIMP GetClassID(CLSID* pClassID);

    // IPersistStream
    STDMETHODIMP IsDirty() {return S_FALSE;}
    STDMETHODIMP Load(IStream* pStream);
    STDMETHODIMP Save(IStream* pStream, BOOL fClearDirty) {return E_NOTIMPL;}
    STDMETHODIMP GetSizeMax(ULARGE_INTEGER* pcbSize) {return E_NOTIMPL;}

	// IDirectMusicTrack
	STDMETHODIMP Init(IDirectMusicSegment* pSegment);

	STDMETHODIMP InitPlay(IDirectMusicSegmentState* pSegmentState,
						  IDirectMusicPerformance* pPerformance,
						  void** ppStateData,
						  DWORD dwVirtualTrackID,
                          DWORD dwFlags);

	STDMETHODIMP EndPlay(void* pStateData);

	STDMETHODIMP Play(void* pStateData,
					  MUSIC_TIME mtStart,
					  MUSIC_TIME mtEnd,
					  MUSIC_TIME mtOffset,
					  DWORD dwFlags,
					  IDirectMusicPerformance* pPerf, 
					  IDirectMusicSegmentState* pSegSt, 
					  DWORD dwVirtualID);

	STDMETHODIMP GetParam(REFGUID rguidDataType, 
						 MUSIC_TIME mtTime, 
						 MUSIC_TIME* pmtNext,
						 void* pData);

	STDMETHODIMP SetParam(REFGUID rguidDataType, 
						 MUSIC_TIME mtTime, 
						 void* pData);
	
	STDMETHODIMP IsParamSupported(REFGUID rguidDataType);

	STDMETHODIMP AddNotificationType(REFGUID rguidNotify);

	STDMETHODIMP RemoveNotificationType(REFGUID rguidNotify);

	STDMETHODIMP Clone(	MUSIC_TIME mtStart,
						MUSIC_TIME mtEnd,
						IDirectMusicTrack** ppTrack);
// IDirectMusicTrack8 
    STDMETHODIMP PlayEx(void* pStateData,REFERENCE_TIME rtStart, 
                REFERENCE_TIME rtEnd,REFERENCE_TIME rtOffset,
                DWORD dwFlags,IDirectMusicPerformance* pPerf, 
                IDirectMusicSegmentState* pSegSt,DWORD dwVirtualID) ; 
    STDMETHODIMP GetParamEx(REFGUID rguidType,REFERENCE_TIME rtTime, 
                REFERENCE_TIME* prtNext,void* pParam,void * pStateData, DWORD dwFlags) ; 
    STDMETHODIMP SetParamEx(REFGUID rguidType,REFERENCE_TIME rtTime,void* pParam, void * pStateData, DWORD dwFlags) ;
    STDMETHODIMP Compose(IUnknown* pContext, 
		DWORD dwTrackGroup,
		IDirectMusicTrack** ppResultTrack) ;
    STDMETHODIMP Join(IDirectMusicTrack* pNewTrack,
		MUSIC_TIME mtJoin,
		IUnknown* pContext,
		DWORD dwTrackGroup,
		IDirectMusicTrack** ppResultTrack) ;

	// IDirectMusicCommon
	STDMETHODIMP GetName(BSTR* pbstrName);

	// IDirectMusicBandTrk (Private Interface)
	STDMETHODIMP AddBand(DMUS_IO_PATCH_ITEM* BandEvent);
	STDMETHODIMP AddBand(IDirectMusicBand* pIDMBand);
	STDMETHODIMP SetGMGSXGMode(MUSIC_TIME mtTime, DWORD dwMidiMode)
	{
		TListItem<StampedGMGSXG>* pPair = new TListItem<StampedGMGSXG>;
		if (!pPair) return E_OUTOFMEMORY;
		pPair->GetItemValue().mtTime = mtTime;
		pPair->GetItemValue().dwMidiMode = dwMidiMode;

		TListItem<StampedGMGSXG>* pScan = m_MidiModeList.GetHead();
		TListItem<StampedGMGSXG>* pPrev = NULL;
		
		if(!pScan)
		{
			// Empty list
			m_MidiModeList.AddHead(pPair);
		}
		else
		{
			while(pScan && pPair->GetItemValue().mtTime > pScan->GetItemValue().mtTime)
			{
				pPrev = pScan;
				pScan = pScan->GetNext();
			}	
			
			if(pPrev)
			{
				// Insert in the middle or end of list
				pPair->SetNext(pScan);
				pPrev->SetNext(pPair);
			}
			else
			{
				// Insert at beginning
				m_MidiModeList.AddHead(pPair);
			}
		}

		CBand* pBand = BandList.GetHead();
		for(; pBand; pBand = pBand->GetNext())
		{
			// only set bands affected by new mode
			if ( (pBand->m_lTimeLogical >= pPair->GetItemValue().mtTime) &&
				 ( !pScan || pBand->m_lTimeLogical < pScan->GetItemValue().mtTime) )
			{
				pBand->SetGMGSXGMode(dwMidiMode);
			}
		}
		return S_OK;
	}

	// Class
	CBandTrk();
	~CBandTrk();

private:
	HRESULT BuildDirectMusicBandList(CRiffParser *pParser);
	

	HRESULT  ExtractBand(CRiffParser *pParser);

	HRESULT LoadBand(IStream *pIStream, CBand* pBand);

	HRESULT LoadClone(IDirectMusicBandTrk* pBandTrack,
					  MUSIC_TIME mtStart, 
					  MUSIC_TIME mtEnd);

	HRESULT InsertBand(CBand* pNewBand);
	HRESULT Seek(CBandTrkStateData* pBandTrkStateData,
				 MUSIC_TIME mtStart, 
				 MUSIC_TIME mtOffset,
				 REFERENCE_TIME rtOffset,
				 bool fClockTime);

	HRESULT FindSEReplaceInstr(TList<SeekEvent>& SEList,
							   DWORD dwPChannel,
							   CBandInstrument* pInstrument);

	// Shared implentation of play for either music or clock time.
    HRESULT PlayMusicOrClock(
        void *pStateData,	
        MUSIC_TIME mtStart,	
        MUSIC_TIME mtEnd,
        MUSIC_TIME mtOffset,
        REFERENCE_TIME rtOffset,
	    DWORD dwFlags,		
	    IDirectMusicPerformance* pPerf,	
	    IDirectMusicSegmentState* pSegSt,
	    DWORD dwVirtualID,
        bool fClockTime);

	HRESULT CBandTrk::JoinInternal(
		IDirectMusicTrack* pNewTrack,
		MUSIC_TIME mtJoin,
		DWORD dwTrackGroup);

private:
	CRITICAL_SECTION m_CriticalSection;
    BOOL m_fCSInitialized;
	DWORD m_dwValidate; // used to validate state data
	CBandList BandList;
	bool m_bAutoDownload;
	bool m_fLockAutoDownload; // if true, this flag indicates that we've specifically
								// commanded the band to autodownload. Otherwise,
								// it gets its preference from the performance via
								// GetGlobalParam.
	DWORD m_dwFlags;
	TList<StampedGMGSXG> m_MidiModeList; // List of time-stamped midi mode messages
	long m_cRef;
};

//////////////////////////////////////////////////////////////////////
// Class BandTrkStateData

class CBandTrkStateData
{
public: 
	CBandTrkStateData() : 
	m_pSegmentState(NULL),
	m_pPerformance(NULL),
	m_pNextBandToSPE(NULL),
	m_fPlayPreviousInSeek(FALSE),
	m_dwVirtualTrackID(0),
	dwValidate(0){}

	~CBandTrkStateData(){}

public:		
	IDirectMusicSegmentState*	m_pSegmentState;
	IDirectMusicPerformance*	m_pPerformance;
	IDirectMusicBand*			m_pNextBandToSPE;
	DWORD						m_dwVirtualTrackID;
	BOOL						m_fPlayPreviousInSeek;
	DWORD						dwValidate;
};

//////////////////////////////////////////////////////////////////////
// Class SeekEvent

class SeekEvent
{
public:
	SeekEvent() :
	m_pParentBand(NULL),
	m_pInstrument(NULL),
	m_dwPChannel(0) {}
	
	~SeekEvent(){}

public:
	CBand*	m_pParentBand;
	CBandInstrument*	m_pInstrument;
	DWORD				m_dwPChannel;
};

#endif // #ifndef BANDTRK_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\XDmime\curve.h ===
// Copyright (c) 1998 Microsoft Corporation
// curve.h

#ifndef __CURVE_H_
#define __CURVE_H_

#define CT_MAX  192 // curve table maximum
#define CT_FACTOR	100	// curve table multiplication factor
#define CT_DIVFACTOR	( ( CT_MAX ) * CT_FACTOR ) // curve division factor

// linear curves
static short ganCT_Linear[CT_MAX + 1] = {
	0,100,200,300,400,500,600,700,
	800,900,1000,1100,1200,1300,1400,1500,
	1600,1700,1800,1900,2000,2100,2200,2300,
	2400,2500,2600,2700,2800,2900,3000,3100,
	3200,3300,3400,3500,3600,3700,3800,3900,
	4000,4100,4200,4300,4400,4500,4600,4700,
	4800,4900,5000,5100,5200,5300,5400,5500,
	5600,5700,5800,5900,6000,6100,6200,6300,
	6400,6500,6600,6700,6800,6900,7000,7100,
	7200,7300,7400,7500,7600,7700,7800,7900,
	8000,8100,8200,8300,8400,8500,8600,8700,
	8800,8900,9000,9100,9200,9300,9400,9500,
	9600,9700,9800,9900,10000,10100,10200,10300,
	10400,10500,10600,10700,10800,10900,11000,11100,
	11200,11300,11400,11500,11600,11700,11800,11900,
	12000,12100,12200,12300,12400,12500,12600,12700,
	12800,12900,13000,13100,13200,13300,13400,13500,
	13600,13700,13800,13900,14000,14100,14200,14300,
	14400,14500,14600,14700,14800,14900,15000,15100,
	15200,15300,15400,15500,15600,15700,15800,15900,
	16000,16100,16200,16300,16400,16500,16600,16700,
	16800,16900,17000,17100,17200,17300,17400,17500,
	17600,17700,17800,17900,18000,18100,18200,18300,
	18400,18500,18600,18700,18800,18900,19000,19100,19200 };

// sine curves
static short ganCT_Sine[CT_MAX + 1] = {
	0,1,5,11,20,32,46,62,
	82,103,128,155,184,216,250,287,
	327,369,413,460,509,561,615,671,
	730,792,855,921,990,1060,1133,1208,
	1286,1365,1447,1531,1617,1706,1796,1889,
	1983,2080,2179,2279,2382,2486,2593,2701,
	2811,2923,3037,3153,3270,3389,3509,3632,
	3755,3881,4008,4136,4266,4397,4530,4664,
	4799,4936,5074,5213,5354,5495,5638,5781,
	5926,6071,6218,6365,6514,6663,6813,6963,
	7115,7267,7420,7573,7727,7881,8036,8191,
	8346,8502,8659,8815,8972,9128,9285,9442,
	9600,9757,9914,10071,10227,10384,10540,10697,
	10853,11008,11163,11318,11472,11626,11779,11932,
	12084,12236,12386,12536,12685,12834,12981,13128,
	13273,13418,13561,13704,13845,13986,14125,14263,
	14399,14535,14669,14802,14933,15063,15191,15318,
	15444,15567,15690,15810,15929,16046,16162,16276,
	16388,16498,16606,16713,16817,16920,17020,17119,
	17216,17310,17403,17493,17582,17668,17752,17834,
	17913,17991,18066,18139,18209,18278,18344,18407,
	18469,18528,18584,18638,18690,18739,18786,18830,
	18872,18912,18949,18983,19015,19044,19071,19096,
	19117,19137,19153,19167,19179,19188,19194,19198,19200 };

// log curve
static short ganCT_Log[CT_MAX + 1] = {
	0,381,747,1097,1432,1755,2066,2366,
	2655,2934,3205,3467,3721,3967,4207,4439,
	4666,4886,5101,5310,5515,5714,5909,6099,
	6285,6467,6645,6819,6990,7157,7321,7482,
	7640,7795,7947,8096,8243,8387,8529,8668,
	8805,8940,9073,9204,9332,9459,9584,9707,
	9828,9947,10065,10181,10295,10408,10520,10630,
	10738,10845,10951,11056,11159,11261,11361,11461,
	11559,11656,11752,11847,11941,12034,12126,12216,
	12306,12395,12483,12570,12656,12741,12826,12909,
	12992,13074,13155,13235,13315,13394,13472,13549,
	13626,13702,13777,13851,13925,13998,14071,14143,
	14214,14285,14355,14425,14494,14562,14630,14698,
	14764,14831,14896,14962,15026,15091,15154,15218,
	15280,15343,15405,15466,15527,15587,15647,15707,
	15766,15825,15883,15941,15999,16056,16113,16169,
	16225,16281,16336,16391,16446,16500,16554,16607,
	16661,16713,16766,16818,16870,16921,16973,17024,
	17074,17124,17174,17224,17273,17323,17371,17420,
	17468,17516,17564,17611,17658,17705,17752,17798,
	17844,17890,17936,17981,18026,18071,18116,18160,
	18204,18248,18292,18335,18379,18422,18464,18507,
	18549,18592,18634,18675,18717,18758,18799,18840,
	18881,18921,18962,19002,19042,19081,19121,19160,19200 };

// exponential curve
static short ganCT_Exp[CT_MAX + 1] = {
	0,40,79,119,158,198,238,279,
	319,360,401,442,483,525,566,608,
	651,693,736,778,821,865,908,952,
	996,1040,1084,1129,1174,1219,1264,1310,
	1356,1402,1448,1495,1542,1589,1636,1684,
	1732,1780,1829,1877,1927,1976,2026,2076,
	2126,2176,2227,2279,2330,2382,2434,2487,
	2539,2593,2646,2700,2754,2809,2864,2919,
	2975,3031,3087,3144,3201,3259,3317,3375,
	3434,3493,3553,3613,3673,3734,3795,3857,
	3920,3982,4046,4109,4174,4238,4304,4369,
	4436,4502,4570,4638,4706,4775,4845,4915,
	4986,5057,5129,5202,5275,5349,5423,5498,
	5574,5651,5728,5806,5885,5965,6045,6126,
	6208,6291,6374,6459,6544,6630,6717,6805,
	6894,6984,7074,7166,7259,7353,7448,7544,
	7641,7739,7839,7939,8041,8144,8249,8355,
	8462,8570,8680,8792,8905,9019,9135,9253,
	9372,9493,9616,9741,9868,9996,10127,10260,
	10395,10532,10671,10813,10957,11104,11253,11405,
	11560,11718,11879,12043,12210,12381,12555,12733,
	12915,13101,13291,13486,13685,13890,14099,14314,
	14534,14761,14993,15233,15479,15733,15995,16266,
	16545,16834,17134,17445,17768,18103,18453,18819,19200 };

#endif // __CURVE_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\XDmime\debug.h ===
//
// debug.h
// 
// Copyright (c) 1997-1999 Microsoft Corporation. All rights reserved.
//
// Note:
//

#ifndef DEBUG_H
#define DEBUG_H

#include <windows.h>

#define DM_DEBUG_CRITICAL		1	// Used to include critical messages
#define DM_DEBUG_NON_CRITICAL	2	// Used to include level 1 plus important non-critical messages
#define DM_DEBUG_STATUS			3	// Used to include level 1 and level 2 plus status\state messages
#define DM_DEBUG_FUNC_FLOW		4	// Used to include level 1, level 2 and level 3 plus function flow messages
#define DM_DEBUG_ALL			5	// Used to include all debug messages

// Default to no debug output compiled
//
#define Trace
#define TraceI
#define assert(exp) ((void)0)

#ifdef DBG

// Checked build: include at least external debug spew
//
extern void DebugInit(void);
extern void DebugTrace(int iDebugLevel, LPSTR pstrFormat, ...);
extern void DebugAssert(LPSTR szExp, LPSTR szFile, ULONG ulLine);

# undef Trace
# define Trace DebugTrace

# undef assert
# define assert(exp) (void)( (exp) || (DebugAssert(#exp, __FILE__, __LINE__), 0) )

// If internal build flag set, include everything
//
# ifdef DMUSIC_INTERNAL
#  undef TraceI
#  define TraceI DebugTrace
# endif

#endif  // #ifdef DBG

#endif  // #ifndef DEBUG_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\XDmime\audpath.h ===
// Copyright (c) 1998-1999 Microsoft Corporation
// DMSStObj.h : Declaration of the CSegState

#ifndef __AUDIOPATH_H_
#define __AUDIOPATH_H_

#include "dmusici.h"
#include "dmusicf.h"
#include "TrkList.h"
#include "alist.h"
#include "dmstrm.h"
#include "dmscriptautguids.h"
#include "dmusiccp.h"

class CPerformance;
class CSegState;
class CGraph;
class CAudioPathConfig;
class CBufferConfig;
struct IDirectSoundConnect;

class CBufferNode : public AListItem
{
friend class CBufferManager;
friend class CAudioPath;
public:
    CBufferNode();
    ~CBufferNode();
    ULONG AddRef();
    ULONG Release();
    IDirectSoundBuffer *GetBuffer() { if (m_pBuffer) m_pBuffer->AddRef(); return m_pBuffer;}
    HRESULT Activate(BOOL fActivate);
private:
    void FinalDeactivate();
    CBufferNode* GetNext() { return (CBufferNode*)AListItem::GetNext();}
    IDirectSoundBuffer *   m_pBuffer;           // DSound buffer that this manages. 
    DMUS_IO_BUFFER_ATTRIBUTES_HEADER m_BufferHeader;  // GUID that identifies this buffer and flags (can it be shared?).
    CBufferManager * m_pManager; // Pointer to parent list. 
    long m_lActivateCount;  // How many times this has been activated.
    long m_cRef;            // How many objects point at this.
};

class CBufferManager : public AList
{    

public:
    CBufferManager(); 
    ~CBufferManager() ;
    HRESULT Init(CPerformance *pPerf, DMUS_AUDIOPARAMS *pAudioParams) ;
    HRESULT InitSink();
    void AddHead(CBufferNode* pBufferNode) { AList::AddHead((AListItem*)pBufferNode);}
    CBufferNode* GetHead(){return (CBufferNode*)AList::GetHead();}
    CBufferNode* RemoveHead() {return (CBufferNode *) AList::RemoveHead();}
    void Remove(CBufferNode* pBufferNode){AList::Remove((AListItem*)pBufferNode);}
    void AddTail(CBufferNode* pBufferNode){AList::AddTail((AListItem*)pBufferNode);}
    void Clear();
    void FinalDeactivate();
    CBufferNode * GetBufferNode(REFGUID guidBufferID);
    HRESULT CreateBuffer(CBufferConfig *pConfig, CBufferConfig **pNew); 
private:
    CPerformance *m_pPerf;                  // Pointer to parent performance. 
    CBufferConfig *m_pFirstBuffer;          // Actual buffer created by config.
public:
    IDirectSoundConnect* m_pSinkConnect;    // The sink object which manages creation of buffers in dsound.
    IDirectSoundSynthSink *m_pSynthSink;    // Used to activate sink.
    DMUS_AUDIOPARAMS m_AudioParams;
};

#define BUFFER_REVERB       1
#define BUFFER_ENVREVERB    2
#define BUFFER_3D           3
#define BUFFER_3D_DRY       4
#define BUFFER_MONO         6
#define BUFFER_STEREO       7
#define BUFFER_MUSIC        8

DEFINE_GUID(GUID_Buffer_Primary,0x186cc544, 0xdb29, 0x11d3, 0x9b, 0xd1, 0x0, 0x80, 0xc7, 0x15, 0xa, 0x74);

#define DMUS_BUFFERF_PRIMARY    4   // This buffer flag is a private definition.

#define DMUS_STANDARD_PATH_DX7  20 // This is for internal use only.

#define MAX_CONNECTIONS     32  // Maximum of 32 buffers connected to one PChannel.

class CBufferConfig : public AListItem
{
public:
    CBufferConfig(DWORD dwType) ;
    ~CBufferConfig();
    void DecideType();         // Looks at embedded GUID and infers default type, if one exists.
    HRESULT Load(IStream *pStream);
    CBufferConfig* GetNext() { return (CBufferConfig*)AListItem::GetNext();}
    IUnknown *              m_pBufferConfig;     // Buffer definition. 
    CBufferNode *           m_pBufferNode;      // Manages the DSound buffer.
    DMUS_IO_BUFFER_ATTRIBUTES_HEADER m_BufferHeader;  // GUID that identifies this buffer and flags.
    DWORD                   m_dwStandardBufferID;// Optionally, one of the standard buffer types.
    HRESULT Activate(BOOL fActivate);
};

class CBufferConfigList : public AList
{
public:
    void AddHead(CBufferConfig* pBufferConfig) { AList::AddHead((AListItem*)pBufferConfig);}
    CBufferConfig* GetHead(){return (CBufferConfig*)AList::GetHead();}
    CBufferConfig* RemoveHead() {return (CBufferConfig *) AList::RemoveHead();}
    void Remove(CBufferConfig* pBufferConfig){AList::Remove((AListItem*)pBufferConfig);}
    void AddTail(CBufferConfig* pBufferConfig){AList::AddTail((AListItem*)pBufferConfig);}
    void Clear();
    CBufferNode * GetBufferNode(REFGUID guidBufferID);
    HRESULT CreateRunTimeVersion(CBufferConfigList *pCopy, CBufferManager *pManager);
    HRESULT Activate(BOOL fActivate);
};

class CPortConfig;

class CBufferConnect : public AListItem
{
public:
    CBufferConnect() ;
    ~CBufferConnect();
    CBufferConnect *CreateRunTimeVersion(CPortConfig *pParent);
    HRESULT Load(CRiffParser *pParser);
    CBufferConnect* GetNext() { return (CBufferConnect*)AListItem::GetNext();}
    DMUS_IO_PCHANNELTOBUFFER_HEADER m_ConnectHeader;
    GUID *                          m_pguidBufferIDs;// Set of guids identifying buffers to connect to.
    CBufferNode **                  m_ppBufferNodes; // Array of equivalent Buffer nodes. 
};

class CBufferConnectList : public AList
{
public:
    void AddHead(CBufferConnect* pBufferConnect) { AList::AddHead((AListItem*)pBufferConnect);}
    CBufferConnect* GetHead(){return (CBufferConnect*)AList::GetHead();}
    CBufferConnect* RemoveHead() {return (CBufferConnect *) AList::RemoveHead();}
    void Remove(CBufferConnect* pBufferConnect){AList::Remove((AListItem*)pBufferConnect);}
    void AddTail(CBufferConnect* pBufferConnect){AList::AddTail((AListItem*)pBufferConnect);}
    HRESULT CreateRunTimeVersion(CBufferConnectList *pDestination, CPortConfig *pParent);
    void Clear();
};

class CAudioPath;

class CPortConfig : public AListItem
{
public:
    CPortConfig() ;
    ~CPortConfig();
    HRESULT CreateRunTimeVersion(CPortConfig ** ppCopy, CAudioPath *pParent,CBufferManager *pManager);
    CPortConfig* GetNext() { return (CPortConfig*)AListItem::GetNext();}
    CBufferNode * GetBufferNode(REFGUID guidBuffer);
    HRESULT Activate(BOOL fActivate);
    HRESULT CPortConfig::Load(CRiffParser *pParser);
    DMUS_IO_PORTCONFIG_HEADER   m_PortHeader; // Port configuration header, from file.
    DMUS_PORTPARAMS8            m_PortParams; // Port params for opening the port, also from file. 
    DWORD                       m_dwPortID;   // Used to track the index of a created port, once connecting.
    CBufferConnectList          m_BufferConnectList; // Pchannel to buffer mappings. 
    CBufferConfigList           m_BufferConfigList; // List of dsound buffer configurations.
    CAudioPath *                m_pParent;    // Parent audio path.
    IDirectMusicPort *         m_pPort;      // Pointer to port, if run time version.
	BOOL						m_fAlreadyHere; // Check for recursive case looking for buffer nodes.
};

class CPortConfigList : public AList
{
public:
    void AddHead(CPortConfig* pPortConfig) { AList::AddHead((AListItem*)pPortConfig);}
    CPortConfig* GetHead(){return (CPortConfig*)AList::GetHead();}
    CPortConfig* RemoveHead() {return (CPortConfig *) AList::RemoveHead();}
    void Remove(CPortConfig* pPortConfig){AList::Remove((AListItem*)pPortConfig);}
    void AddTail(CPortConfig* pPortConfig){AList::AddTail((AListItem*)pPortConfig);}
    HRESULT CreateRunTimeVersion(CPortConfigList *pDestination,CAudioPath *pParent,CBufferManager *pManager);
    void Clear();
    HRESULT Activate(BOOL fActivate);
    BOOL UsesPort(IDirectMusicPort *pPort);
};

class CAudioPath;

DEFINE_GUID(IID_CAudioPath,0xb06c0c23, 0xd3c7, 0x11d3, 0x9b, 0xd1, 0x44, 0x45, 0x53, 0x54, 0x0, 0x0);


/*  The AudioPath represents a configuration of pchannels, ports, and buffers to play
    segments. The performance creates CAudioPath objects from CAudioPathConfig file
    objects and stores them in a linked list, which it uses to keep track of them.
*/

class CAudioPath : 
    public IDirectMusicAudioPath, 
	public IDirectMusicGraph,
    public AListItem
{
public:
    CAudioPath();
    ~CAudioPath();
    CAudioPath* GetNext() { return (CAudioPath*)AListItem::GetNext();}
// IUnknown
    STDMETHODIMP QueryInterface(const IID &iid, void **ppv);
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();

// IDirectMusicAudioPath 
    STDMETHODIMP GetObjectInPath( DWORD dwPChannel,DWORD dwStage,DWORD dwBuffer, REFGUID guidObject,
                    DWORD dwIndex,REFGUID iidInterface, void ** ppObject);
    STDMETHODIMP Activate(BOOL fActivate) ;
    STDMETHODIMP SetVolume(long lVolume,DWORD dwDuration) ;
    STDMETHODIMP ConvertPChannel( DWORD dwPChannelIn,DWORD *pdwPChannelOut) ; 

// IDirectMusicGraph
	STDMETHODIMP Shutdown();
    STDMETHODIMP InsertTool(IDirectMusicTool *pTool,DWORD *pdwPChannels,DWORD cPChannels,LONG lIndex);
    STDMETHODIMP GetTool(DWORD,IDirectMusicTool**);
    STDMETHODIMP RemoveTool(IDirectMusicTool*);
    STDMETHODIMP StampPMsg(DMUS_PMSG* pEvent);

    HRESULT Init(IUnknown *pSourceConfig,CPerformance *pPerf);
    HRESULT ConnectToPorts(CPerformance *pPerf,DWORD dwSampleRate);
    CBufferNode * GetBufferNode(REFGUID guidBuffer);
    void SetGraph(CGraph *pGraph);
    CGraph *GetGraph();
    void Deactivate();
    BOOL IsActive() { return m_fActive; }
    BOOL NoPorts() { return m_PortConfigList.IsEmpty(); }
    BOOL UsesPort(IDirectMusicPort *pPort) { return m_PortConfigList.UsesPort(pPort); }
private:
    BOOL                m_fDeactivating;    // State variable.
    BYTE                m_bLastVol;         // Last volume change.
    CRITICAL_SECTION    m_CriticalSection;
	BOOL				m_fActive;			// Indicates that the audio path is active.
    long			    m_cRef;             // Reference counter. 
    DWORD *             m_pdwVChannels;     // Array of source VChannels.
    DWORD *             m_pdwPChannels;     // Array of destination PChannels.
    DWORD               m_dwChannelCount;   // Size of arrays.
    CGraph *            m_pGraph;           // Route tool graph.
    CPerformance *      m_pPerformance;     // Pointer to performance, needed to release PChannels.
    CAudioPathConfig *  m_pConfig;          // Source configuration.
    CPortConfigList     m_PortConfigList;   // List of port definitions (copied from source.)
    CBufferConfigList   m_BufferConfigList; // List of DSound buffers connected to the ports.
    IUnknown *          m_pUnkDispatch;     // holds the controlling unknown of the scripting object that implements IDispatch
};

class CAudioPathList : public AList
{
public:
    void Clear();
    void AddHead(CAudioPath* pAudioPath) { AList::AddHead((AListItem*)pAudioPath);}
    CAudioPath* GetHead(){return (CAudioPath*)AList::GetHead();}
    CAudioPath* RemoveHead() {return (CAudioPath *) AList::RemoveHead();}
    void Remove(CAudioPath* pAudioPath){AList::Remove((AListItem*)pAudioPath);}
    void AddTail(CAudioPath* pAudioPath){AList::AddTail((AListItem*)pAudioPath);}
    BOOL IsMember(CAudioPath* pAudioPath){return AList::IsMember((AListItem*)pAudioPath);}
    BOOL UsesPort(IDirectMusicPort *pPort); 
    CBufferNode * GetBufferNode(REFGUID guidBufferID);
};

DEFINE_GUID(IID_CAudioPathConfig,0xe9874261, 0xab52, 0x11d3, 0x9b, 0xd1, 0x44, 0x45, 0x53, 0x54, 0x0, 0x0);

class CAudioPathConfig : 
    public IPersistStream, 
    public IDirectMusicObject
{
friend class CAudioPath;
public:
    CAudioPathConfig();
    ~CAudioPathConfig();
    static CAudioPathConfig *CreateStandardConfig(DWORD dwType,DWORD dwPChannelCount,DWORD dwSampleRate);


// IUnknown
    STDMETHODIMP QueryInterface(const IID &iid, void **ppv);
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();

// IPersist functions
    STDMETHODIMP GetClassID( CLSID* pClsId );
// IPersistStream functions
    STDMETHODIMP IsDirty();
    STDMETHODIMP Load( IStream* pIStream );
    STDMETHODIMP Save( IStream* pIStream, BOOL fClearDirty );
    STDMETHODIMP GetSizeMax( ULARGE_INTEGER FAR* pcbSize );

// IDirectMusicObject 
	STDMETHODIMP GetDescriptor(LPDMUS_OBJECTDESC pDesc);
	STDMETHODIMP SetDescriptor(LPDMUS_OBJECTDESC pDesc);
	STDMETHODIMP ParseDescriptor(LPSTREAM pStream, LPDMUS_OBJECTDESC pDesc);

    HRESULT Load( CRiffParser *pParser);

protected:
    CGraph *            m_pGraph;                   // Audio path tool graph.
    CPortConfigList     m_PortConfigList;           // List of port definitions.
    CBufferConfigList   m_BufferConfigList;         // List of global dsound buffer configurations.
    CRITICAL_SECTION    m_CriticalSection;
	long		        m_cRef;
	DWORD               m_fPartialLoad;
// IDirectMusicObject variables
	DWORD	            m_dwValidData;
	GUID	            m_guidObject;
	FILETIME	        m_ftDate;                       /* Last edited date of object. */
	DMUS_VERSION	    m_vVersion;                 /* Version. */
	WCHAR	            m_wszName[DMUS_MAX_NAME];			/* Name of object.       */
	WCHAR	            m_wszCategory[DMUS_MAX_CATEGORY];	/* Category for object */
	WCHAR               m_wszFileName[DMUS_MAX_FILENAME];	/* File path. */
    IUnknown *          m_pUnkDispatch; // holds the controlling unknown of the scripting object that implements IDispatch
};

#endif // __AUDIOPATH_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\XDmime\curvetrk.h ===
// Copyright (c) 1998 Microsoft Corporation
/* This file no longer needed */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\XDmime\curvetrk.cpp ===
// Copyright (c) 1998 Microsoft Corporation
/* This file no longer needed */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\XDmime\dmbndtrk.h ===
/*
   dmbndtrk.h
   
   Copyright (c) 1997-1998 Microsoft Corporation. All rights reserved.

   Note: Contains private interfaces support by objects contained within 
		 dmband.dll. Originally written by Robert K. Amenn 
*/

#ifndef DMBNDTRK_H
#define DMBNDTRK_H

#include <windows.h>

#define COM_NO_WINDOWS_H
#include <objbase.h>

#ifdef __cplusplus
extern "C" {
#endif

struct IDirectMusicBand;

typedef struct _DMUS_IO_PATCH_ITEM
{
    MUSIC_TIME                  lTime;
    BYTE                        byStatus;
    BYTE                        byPChange;
    BYTE                        byMSB;
    BYTE                        byLSB;
    DWORD                       dwFlags;
	BOOL						fNotInFile; // set to true if this patch item was automatically generated
    IDirectMusicCollection*     pIDMCollection;
    struct _DMUS_IO_PATCH_ITEM* pNext;  
} DMUS_IO_PATCH_ITEM;

typedef enum enumDMUS_MIDIMODEF_FLAGS
{       
    DMUS_MIDIMODEF_GM = 0x1,
    DMUS_MIDIMODEF_GS = 0x2,
    DMUS_MIDIMODEF_XG = 0x4,
} DMUS_MIDIMODEF_FLAGS;

struct StampedGMGSXG
{
	MUSIC_TIME mtTime;
	DWORD dwMidiMode;
};

/* Private Interface IDirectMusicBandTrk */

interface IDirectMusicBandTrk;

#ifndef __cplusplus 
typedef interface IDirectMusicBandTrk IDirectMusicBandTrk;
#endif

typedef IDirectMusicBandTrk __RPC_FAR *LPDIRECTMUSICBANDTRK;

#undef  INTERFACE
#define INTERFACE  IDirectMusicBandTrk
DECLARE_INTERFACE_(IDirectMusicBandTrk, IUnknown)
{
	/* IUnknown */
    STDMETHOD(QueryInterface)       (THIS_ REFIID, LPVOID FAR *) PURE;
    STDMETHOD_(ULONG,AddRef)        (THIS) PURE;
    STDMETHOD_(ULONG,Release)       (THIS) PURE;

	/* IDirectMusicBandTrk */
	STDMETHOD(AddBand)				(THIS_ DMUS_IO_PATCH_ITEM*) PURE;
	STDMETHOD(AddBand)				(THIS_ IDirectMusicBand* pIDMBand) PURE;
	STDMETHOD(SetGMGSXGMode)		(THIS_ MUSIC_TIME mtTime, DWORD dwMidiMode) PURE;
};

/* Private Interface IDirectMusicBandPrivate */

interface IDirectMusicBandPrivate;

#ifndef __cplusplus 
typedef interface IDirectMusicBandPrivate IDirectMusicBandPrivate;
#endif

typedef IDirectMusicBandPrivate __RPC_FAR *LPDIRECTMUSICBANDP;

#undef  INTERFACE
#define INTERFACE  IDirectMusicBandPrivate 
DECLARE_INTERFACE_(IDirectMusicBandPrivate, IUnknown)
{
	/* IUnknown */
    STDMETHOD(QueryInterface)       (THIS_ REFIID, LPVOID FAR *) PURE;
    STDMETHOD_(ULONG,AddRef)        (THIS) PURE;
    STDMETHOD_(ULONG,Release)       (THIS) PURE;

	/* IDirectMusicBandPrivate */
	STDMETHOD(GetFlags)				(THIS_ DWORD* dwFlags) PURE;
	STDMETHOD(SetGMGSXGMode)		(THIS_ DWORD dwMidiMode) PURE;
};

DEFINE_GUID(IID_IDirectMusicBandTrk, 0x53466056, 0x6dc4, 0x11d1, 0xbf, 0x7b, 0x0, 0xc0, 0x4f, 0xbf, 0x8f, 0xef);
DEFINE_GUID(IID_IDirectMusicBandPrivate,0xda54db81, 0x837d, 0x11d1, 0x86, 0xbc, 0x0, 0xc0, 0x4f, 0xbf, 0x8f, 0xef);

#ifdef __cplusplus
}; /* extern "C" */
#endif

#endif /* #ifndef DMBNDTRK_H */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\XDmime\dmgraph.cpp ===
// Copyright (c) 1998-2001 Microsoft Corporation
// DMGraph.cpp : Implementation of CGraph

#include "dmime.h"
#include "DMGraph.h"
#include "dmusicc.h"
#include "dmusici.h"
#include "dmusicf.h"
#include "dmstrm.h"
#include "validp.h"
#include "dls1.h"
#include "debug.h"
#include "Validate.h"
#define ASSERT  assert

CGraph::CGraph()
{
    m_cRef = 1;
    memset(&m_guidObject,0,sizeof(m_guidObject));
    m_dwValidData = DMUS_OBJ_CLASS; // upon creation, only this data is valid
    memset(&m_ftDate, 0,sizeof(m_ftDate));
    memset(&m_vVersion, 0,sizeof(m_vVersion));
    memset(m_wszName, 0, sizeof(WCHAR) * DMUS_MAX_NAME);
    memset(m_wszCategory, 0, sizeof(WCHAR) * DMUS_MAX_CATEGORY);
    memset(m_wszFileName, 0, sizeof(WCHAR) * DMUS_MAX_FILENAME);
    InitializeCriticalSection(&m_CrSec);
    InterlockedIncrement(&g_cComponent);
}

CGraph::~CGraph()
{
    Shutdown();  // shouldn't be needed, but doesn't hurt
    DeleteCriticalSection(&m_CrSec);
    InterlockedDecrement(&g_cComponent);
}

STDMETHODIMP CGraph::QueryInterface(
    const IID &iid,   // @parm Interface to query for
    void **ppv)       // @parm The requested interface will be returned here
{
    V_INAME(CGraph::QueryInterface);
    V_PTRPTR_WRITE(ppv);
    V_REFGUID(iid);

    if (iid == IID_IUnknown || iid == IID_IDirectMusicGraph || iid == IID_IDirectMusicGraph8)
    {
        *ppv = static_cast<IDirectMusicGraph8*>(this);
    }
    else if (iid == IID_CGraph)
    {
        *ppv = static_cast<CGraph*>(this);
    }
    else if (iid == IID_IDirectMusicObject)
    {
        *ppv = static_cast<IDirectMusicObject*>(this);
    }
    else if (iid == IID_IPersistStream)
    {
        *ppv = static_cast<IPersistStream*>(this);
    }
    else if (iid == IID_IGraphClone)
    {
        *ppv = static_cast<IGraphClone*>(this);
    }
    else
    {
        *ppv = NULL;
        Trace(4,"Warning: Request to query unknown interface on ToolGraph object\n");
        return E_NOINTERFACE;
    }

    reinterpret_cast<IUnknown*>(this)->AddRef();
    return S_OK;
}


// @method:(INTERNAL) HRESULT | IDirectMusicGraph | AddRef | Standard AddRef implementation for <i IDirectMusicGraph>
//
// @rdesc Returns the new reference count for this object.
//
STDMETHODIMP_(ULONG) CGraph::AddRef()
{
    return InterlockedIncrement(&m_cRef);
}


// @method:(INTERNAL) HRESULT | IDirectMusicGraph | Release | Standard Release implementation for <i IDirectMusicGraph>
//
// @rdesc Returns the new reference count for this object.
//
STDMETHODIMP_(ULONG) CGraph::Release()
{
    if (!InterlockedDecrement(&m_cRef))
    {
        delete this;
        return 0;
    }

    return m_cRef;
}

/*
Made internal 9/25/98
  method HRESULT | IDirectMusicGraph | Shutdown |
  Shuts down the graph. This must be called when the graph is no longer needed,
  in order to release the tools and other memory. A call to Release is not
  sufficient, because there is circular referencing between the graph and the tools.
  However, only the segment, performance, or whatever owns the graph
  should call this function.
  rvalue S_OK | Success.
  rvalue S_FALSE | Success, but didn't need to do anything.
*/
HRESULT STDMETHODCALLTYPE CGraph::Shutdown()
{
    // release all Tools
    CToolRef*   pObj;
    HRESULT hr = S_OK;
    EnterCriticalSection(&m_CrSec);
    if( IsEmpty() )
    {
        hr = S_FALSE;
    }
    else
    {
        while( pObj = RemoveHead() )
        {
            delete pObj;
        }
    }
    LeaveCriticalSection(&m_CrSec);
    return hr;
}

HRESULT CGraph::InsertTool(
    IDirectMusicTool *pTool,
    DWORD *pdwPChannels,
    DWORD cPChannels,
    LONG lIndex,
    GUID *pguidClassID)
{
    HRESULT hr = S_OK;
    EnterCriticalSection(&m_CrSec);

    CToolRef*   pToolRef;
    // make sure that this Tool instance isn't already in the Graph
    for( pToolRef = GetHead(); pToolRef; pToolRef = pToolRef->GetNext() )
    {
        if( pTool == pToolRef->m_pTool )
        {
            LeaveCriticalSection(&m_CrSec);
            Trace(1,"Error: Multiple install of the same tool in a graph\n");
            return DMUS_E_ALREADY_EXISTS;
        }
    }
    // insert this Tool instance into the Graph
    pToolRef = new CToolRef;
    if( pToolRef )
    {
        DWORD       dwTemp;
        DWORD*      pdwArray = NULL;

        pToolRef->m_pTool = pTool;
        pTool->AddRef();
        pTool->Init(this);
        dwTemp = 0;
        IDirectMusicTool8 *pTool8;
        if (SUCCEEDED(pTool->QueryInterface(IID_IDirectMusicTool8,(void **) &pTool8)))
        {
            pToolRef->m_fSupportsClone = TRUE;
            pTool8->Release();
        }
        if (pguidClassID)
        {
            pToolRef->m_guidClassID = *pguidClassID;
        }
        else
        {
            IPersistStream *pPersist;
            if (SUCCEEDED(pTool->QueryInterface(IID_IPersistStream,(void **) &pPersist)))
            {
                pPersist->GetClassID(&pToolRef->m_guidClassID);
                pPersist->Release();
            }
        }
        pTool->GetMsgDeliveryType(&dwTemp);
        if( (dwTemp != DMUS_PMSGF_TOOL_IMMEDIATE) && (dwTemp != DMUS_PMSGF_TOOL_QUEUE) && (dwTemp != DMUS_PMSGF_TOOL_ATTIME) )
        {
            dwTemp = DMUS_PMSGF_TOOL_IMMEDIATE;
        }
        pToolRef->m_dwQueue = dwTemp;
        if( FAILED( pTool->GetMediaTypeArraySize(&dwTemp)))
        {
            dwTemp = 0;
        }
        pToolRef->m_dwMTArraySize = dwTemp;
        if( dwTemp )
        {
            pdwArray = new DWORD[dwTemp];
            if( pdwArray )
            {
                HRESULT hrTemp = pTool->GetMediaTypes( &pdwArray, dwTemp );
                if( hrTemp == E_NOTIMPL )
                {
                    delete [] pdwArray;
                    pToolRef->m_dwMTArraySize = 0;
                }
                else
                {
                    pToolRef->m_pdwMediaTypes = pdwArray;
                }
            }
            else
            {
                delete pToolRef;
                LeaveCriticalSection(&m_CrSec);
                return E_OUTOFMEMORY;
            }
        }
        if( pdwPChannels )
        {
            pToolRef->m_pdwPChannels = new DWORD[cPChannels];
            if( pToolRef->m_pdwPChannels )
            {
                memcpy( pToolRef->m_pdwPChannels, pdwPChannels, sizeof(DWORD) * cPChannels );
                pToolRef->m_dwPCArraySize = cPChannels;
            }
            else
            {
                delete pToolRef;
                LeaveCriticalSection(&m_CrSec);
                return E_OUTOFMEMORY;
            }
        }

        if (lIndex < 0)
        {
            lIndex += AList::GetCount();       // Make index be offset from end.
        }
        CToolRef *pNext = GetItem(lIndex);
        if (pNext)
        {
            InsertBefore(pNext,pToolRef);
        }
        else
        {
            AList::AddTail(pToolRef);
        }
    }
    else
    {
        hr = E_OUTOFMEMORY;
    }
    LeaveCriticalSection(&m_CrSec);
    return hr;
}
HRESULT STDMETHODCALLTYPE CGraph::InsertTool(
    IDirectMusicTool *pTool,    // @parm The Tool to insert.
    DWORD *pdwPChannels,    // @parm An array of which PChannels to place the tool in. These are
                            // id's which are converted to MIDI Channel + Port on output. If the
                            // tool accepts messages on all PChannels, this is NULL. <p cPChannels>
                            // is the count of how many this array points to.
    DWORD cPChannels,       // @parm Count of how many PChannels are pointed to by <p pdwPChannels>.
    LONG lIndex)            // @parm At what position to place the tool. This is an index from either the start
                            // of the current tool list or, working backwards from the end (in which case, it is
                            // a negative number.) If <p lIndex> is out of range, the Tool will be placed at
                            // the very beginning or end of the Tool list. 0 is the beginning. To place a Tool
                            // at the end of the list, use a number for <p lIndex> that is larger than the number
                            // of tools in the current tool list.
{
    V_INAME(IDirectMusicGraph::InsertTool);
    V_INTERFACE(pTool);
    V_BUFPTR_READ_OPT(pdwPChannels, sizeof(DWORD) * cPChannels);

    return InsertTool(pTool,pdwPChannels,cPChannels,lIndex,NULL);
}

HRESULT CGraph::GetObjectInPath( DWORD dwPChannel,REFGUID guidObject,
                    DWORD dwIndex,REFGUID iidInterface, void ** ppObject)

{
    V_INAME(IDirectMusicGraph::GetObjectInPath);
    V_PTRPTR_WRITE(ppObject);
    HRESULT hr = DMUS_E_NOT_FOUND;
    CToolRef*   pPlace;
    if( !IsEmpty() )
    {
        pPlace = NULL;
        // search for the tool
        EnterCriticalSection(&m_CrSec);
        for( pPlace = GetHead(); pPlace;
            pPlace = pPlace->GetNext() )
        {
            if ((guidObject == pPlace->m_guidClassID) || (guidObject == GUID_All_Objects))
            {
                BOOL fFound = (!pPlace->m_pdwPChannels || (dwPChannel >= DMUS_PCHANNEL_ALL));
                if( !fFound )
                {
                    DWORD cCount;
                    // scan through the array of PChannels to see if this one
                    // supports dwPChannel
                    for( cCount = 0; cCount < pPlace->m_dwPCArraySize; cCount++)
                    {
                        if( dwPChannel == pPlace->m_pdwPChannels[cCount] )
                        {
                            fFound = TRUE;
                            // yep, it supports it
                            break;
                        }
                    }
                }
                if (fFound)
                {
                    if (!dwIndex)
                    {
                        break;
                    }
                    else
                    {
                        dwIndex--;
                    }
                }
            }
        }
        if( pPlace )
        {
            hr = pPlace->m_pTool->QueryInterface(iidInterface,ppObject);
        }
        LeaveCriticalSection(&m_CrSec);
    }
#ifdef DBG
    if (hr == DMUS_E_NOT_FOUND)
    {
        Trace(1,"Error: Requested Tool not found in Graph\n");
    }
#endif
    return hr;

}

/*
  @method HRESULT | IDirectMusicGraph | GetTool |
  Returns the Tool at the specified index.

  @rvalue DMUS_E_NOT_FOUND | Unable to find a Tool at the position described.
  @rvalue E_POINTER | ppTool is NULL or invalid.
  @rvalue S_OK | Success.

  @comm The retrieved tool is AddRef'd by this call, so be sure to Release it.
*/
HRESULT STDMETHODCALLTYPE CGraph::GetTool(
    DWORD dwIndex,              // @parm The index, from the beginning and starting at 0,
                                // at which to retrieve the Tool from the Graph.
    IDirectMusicTool **ppTool)  // @parm The <i IDirectMusicTool> pointer to use
                                // for returning the requested tool.
{
    V_INAME(IDirectMusicGraph::GetTool);
    V_PTRPTR_WRITE(ppTool);
    CToolRef*   pPlace;
    HRESULT hr = S_OK;

    if( IsEmpty() )
    {
        Trace(1,"Error: GetTool failed because the Tool Graph is empty\n");
        return DMUS_E_NOT_FOUND;
    }
    pPlace = NULL;
    // search for the indexed tool
    EnterCriticalSection(&m_CrSec);
    for( pPlace = GetHead(); ( dwIndex > 0 ) && pPlace;
        pPlace = pPlace->GetNext() )
    {
        dwIndex--;
    }
    if( NULL == pPlace )
    {
        hr = DMUS_E_NOT_FOUND;
    }
    else
    {
        *ppTool = pPlace->m_pTool;
        (*ppTool)->AddRef();
    }
    LeaveCriticalSection(&m_CrSec);
    return hr;
}

/*
  @method HRESULT | IDirectMusicGraph | RemoveTool |
  Removes the Tool from the Graph.

  @rvalue DMUS_E_NOT_FOUND | The specified Tool is not in the Graph.
  @rvalue E_POINTER | pTool is NULL or invalid.
  @rvalue S_OK | Success.

  @comm The Tool is removed from the Graph, and the Graph's reference on the Tool
  object is released.
*/
HRESULT STDMETHODCALLTYPE CGraph::RemoveTool(
    IDirectMusicTool *pTool)    // @parm The <i IDirectMusicTool> pointer of the Tool to remove.
{
    V_INAME(IDirectMusicGraph::RemoveTool);
    V_INTERFACE(pTool);
    CToolRef*   pPlace;
    HRESULT hr = S_OK;
    EnterCriticalSection(&m_CrSec);
    // search for the tool
    for( pPlace = GetHead(); pPlace; pPlace = pPlace->GetNext() )
    {
        if( pPlace->m_pTool == pTool )
            break;
    }
    if( NULL == pPlace )
    {
        Trace(1,"Error: RemoveTool - Tool not in Graph.\n");
        hr = DMUS_E_NOT_FOUND;
    }
    else
    {
        AList::Remove(pPlace);
        delete pPlace;
    }
    LeaveCriticalSection(&m_CrSec);
    return hr;
}


STDMETHODIMP CGraph::Clone(IDirectMusicGraph **ppGraph)

{
    V_INAME(IDirectMusicGraph::Clone);
    V_PTRPTR_WRITE(ppGraph);

    HRESULT hr = E_OUTOFMEMORY;
    EnterCriticalSection(&m_CrSec);
    CGraph *pNew = new CGraph;
    if (pNew)
    {
        pNew->m_dwValidData = m_dwValidData;
        pNew->m_ftDate = m_ftDate;
        pNew->m_guidObject = m_guidObject;
        pNew->m_vVersion = m_vVersion;
        wcscpy(pNew->m_wszCategory,m_wszCategory);
        wcscpy(pNew->m_wszFileName,m_wszFileName);
        wcscpy(pNew->m_wszName,m_wszName);
        CToolRef *pSource = GetHead();
        CToolRef *pDest;
        for (;pSource;pSource = pSource->GetNext())
        {
            pDest = new CToolRef;
            if (pDest)
            {
                pNew->AList::AddTail(pDest);
                pDest->m_dwMTArraySize = pSource->m_dwMTArraySize;
                pDest->m_dwPCArraySize = pSource->m_dwPCArraySize;
                pDest->m_dwQueue = pSource->m_dwQueue;
                pDest->m_fSupportsClone = pSource->m_fSupportsClone;
                pDest->m_guidClassID = pSource->m_guidClassID;
                if (pSource->m_dwMTArraySize)
                {
                    pDest->m_pdwMediaTypes = new DWORD[pSource->m_dwMTArraySize];
                    if (pDest->m_pdwMediaTypes)
                    {
                        memcpy(pDest->m_pdwMediaTypes,pSource->m_pdwMediaTypes,
                            sizeof(DWORD)*pDest->m_dwMTArraySize);
                    }
                    else
                    {
                        pDest->m_dwMTArraySize = 0;
                    }
                }
                else
                {
                    pDest->m_pdwMediaTypes = NULL;
                }
                if (pSource->m_dwPCArraySize)
                {
                    pDest->m_pdwPChannels = new DWORD[pSource->m_dwPCArraySize];
                    if (pDest->m_pdwPChannels)
                    {
                        memcpy(pDest->m_pdwPChannels,pSource->m_pdwPChannels,
                            sizeof(DWORD)*pDest->m_dwPCArraySize);
                    }
                    else
                    {
                        pDest->m_dwPCArraySize = 0;
                    }
                }
                else
                {
                    pDest->m_pdwPChannels = NULL;
                }
                if (pSource->m_pTool)
                {
                    if (pDest->m_fSupportsClone)
                    {
                        IDirectMusicTool8 *pTool8 = (IDirectMusicTool8 *) pSource->m_pTool;
                        pTool8->Clone(&pDest->m_pTool);
                    }
                    else
                    {
                        pDest->m_pTool = pSource->m_pTool;
                        pDest->m_pTool->AddRef();
                    }
                }
            }
            else
            {
                delete pNew;
                pNew = NULL;
                break;
            }
        }
    }
    *ppGraph = (IDirectMusicGraph *) pNew;
    if (pNew) hr = S_OK;
    LeaveCriticalSection(&m_CrSec);
    return hr;
}

// returns TRUE if dwType is supported by pToolRef
inline BOOL CGraph::CheckType( DWORD dwType, CToolRef* pToolRef )
{
    BOOL fReturn = FALSE;
    if( pToolRef->m_dwMTArraySize == 0 )
    {
        fReturn = TRUE; // supports all types
    }
    else
    {
        DWORD dw;
        ASSERT( pToolRef->m_pdwMediaTypes );
        for( dw = 0; dw < pToolRef->m_dwMTArraySize; dw++ )
        {
            if( dwType == pToolRef->m_pdwMediaTypes[dw] )
            {
                fReturn = TRUE;
                break;
            }
        }
    }
    return fReturn;
}

HRESULT STDMETHODCALLTYPE CGraph::StampPMsg(
    DMUS_PMSG* pPMsg)   // @parm The message to stamp.
{
    V_INAME(IDirectMusicGraph::StampPMsg);
    V_BUFPTR_WRITE(pPMsg, sizeof(DMUS_PMSG));

    HRESULT hr = S_OK;
    if( NULL == pPMsg )
    {
        return E_INVALIDARG;
    }
    EnterCriticalSection(&m_CrSec);

    CToolRef*   pPlace = GetHead();
    IDirectMusicTool*   pPriorTool;
    DWORD       dwType;
    DWORD       dwPChannel;


    pPriorTool = pPMsg->pTool;
    dwType = pPMsg->dwType;
    dwPChannel = pPMsg->dwPChannel;
    if( pPriorTool )
    {
        for( ; pPlace; pPlace = pPlace->GetNext() )
        {
            if( pPriorTool == pPlace->m_pTool )
            {
                pPlace = pPlace->GetNext();
                break;
            }
        }
    }
    BOOL fFound = FALSE;
    for( ; pPlace ; pPlace = pPlace->GetNext() )
    {
        if( CheckType(dwType, pPlace) )
        {
            if( !pPlace->m_pdwPChannels || (dwPChannel >= DMUS_PCHANNEL_BROADCAST_GROUPS))
            {
                // supports all tracks, or requested channel is broadcast.
                break;
            }
            DWORD cCount;
            // scan through the array of PChannels to see if this one
            // supports dwPChannel
            for( cCount = 0; cCount < pPlace->m_dwPCArraySize; cCount++)
            {
                if( dwPChannel == pPlace->m_pdwPChannels[cCount] )
                {
                    fFound = TRUE;
                    // yep, it supports it
                    break;
                }
            }
        }
        if (fFound) break;
    }
    // release the current tool
    if( pPMsg->pTool )
    {
        pPMsg->pTool->Release();
        pPMsg->pTool = NULL;
    }
    if( NULL == pPlace )
    {
        hr = DMUS_S_LAST_TOOL;
    }
    else
    {
        // if there is no graph pointer, set it to this
        if( NULL == pPMsg->pGraph )
        {
            pPMsg->pGraph = this;
            AddRef();
        }
        // set to the new tool and addref
        if (pPlace->m_pTool) // Just in case, the ptool sometimes goes away in debugging situations after a long break.
        {
            pPMsg->pTool = pPlace->m_pTool;
            pPMsg->pTool->AddRef();
        }
        // set the event's queue type
        pPMsg->dwFlags &= ~(DMUS_PMSGF_TOOL_IMMEDIATE | DMUS_PMSGF_TOOL_QUEUE | DMUS_PMSGF_TOOL_ATTIME);
        pPMsg->dwFlags |= pPlace->m_dwQueue;
    }
    LeaveCriticalSection(&m_CrSec);
    return hr;
}

/////////////////////////////////////////////////////////////////////////////
// IPersist

HRESULT CGraph::GetClassID( CLSID* pClassID )
{
    V_INAME(CGraph::GetClassID);
    V_PTR_WRITE(pClassID, CLSID);
    *pClassID = CLSID_DirectMusicGraph;
    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
// IPersistStream functions

HRESULT CGraph::IsDirty()
{
    return S_FALSE;
}

HRESULT CGraph::Load( IStream* pIStream )
{
    V_INAME(IPersistStream::Load);
    V_INTERFACE(pIStream);

    CRiffParser Parser(pIStream);
    RIFFIO ckMain;
    HRESULT hr = S_OK;

    Parser.EnterList(&ckMain);
    if (Parser.NextChunk(&hr) && (ckMain.fccType == DMUS_FOURCC_TOOLGRAPH_FORM))
    {
        Shutdown(); // Clear out the tools that are currently in the graph.
        hr = Load(&Parser);
    }
    else
    {
        Trace(1,"Error: Unknown file format when parsing Tool Graph\n");
        hr = DMUS_E_DESCEND_CHUNK_FAIL;
    }
    return hr;
}

HRESULT CGraph::Load(CRiffParser *pParser)

{
    RIFFIO ckNext;
    RIFFIO ckChild;
    HRESULT hr = S_OK;
    pParser->EnterList(&ckNext);
    while(pParser->NextChunk(&hr))
    {
        switch(ckNext.ckid)
        {
        case DMUS_FOURCC_GUID_CHUNK:
            hr = pParser->Read( &m_guidObject, sizeof(GUID) );
            m_dwValidData |= DMUS_OBJ_OBJECT;
            break;
        case DMUS_FOURCC_VERSION_CHUNK:
            hr = pParser->Read( &m_vVersion, sizeof(DMUS_VERSION) );
            m_dwValidData |= DMUS_OBJ_VERSION;
            break;
        case DMUS_FOURCC_CATEGORY_CHUNK:
            hr = pParser->Read( &m_wszCategory, sizeof(WCHAR)*DMUS_MAX_CATEGORY );
            m_dwValidData |= DMUS_OBJ_CATEGORY;
            break;
        case DMUS_FOURCC_DATE_CHUNK:
            hr = pParser->Read( &m_ftDate, sizeof(FILETIME) );
            m_dwValidData |= DMUS_OBJ_DATE;
            break;
        case FOURCC_LIST:
            switch(ckNext.fccType)
            {
                case DMUS_FOURCC_UNFO_LIST:
                    pParser->EnterList(&ckChild);
                    while (pParser->NextChunk(&hr))
                    {
                        if ( ckChild.ckid == DMUS_FOURCC_UNAM_CHUNK)
                        {
                            hr = pParser->Read(&m_wszName, sizeof(m_wszName));
                            m_dwValidData |= DMUS_OBJ_NAME;
                        }
                    }
                    pParser->LeaveList();
                    break;
                case DMUS_FOURCC_TOOL_LIST:
                    pParser->EnterList(&ckChild);
                    while(pParser->NextChunk(&hr))
                    {
                        if ((ckChild.ckid == FOURCC_RIFF) &&
                            (ckChild.fccType == DMUS_FOURCC_TOOL_FORM))
                        {
                            hr = LoadTool(pParser);
                        }
                    }
                    pParser->LeaveList();
                    break;
            }
            break;
        }
    }
    pParser->LeaveList();

    return hr;
}

HRESULT CGraph::LoadTool(CRiffParser *pParser)
{
    RIFFIO ckNext;
    DWORD cbSize;

    DMUS_IO_TOOL_HEADER ioDMToolHdr;
    DWORD *pdwPChannels = NULL;

    HRESULT hr = S_OK;

    pParser->EnterList(&ckNext);

    if (pParser->NextChunk(&hr))
    {
        if(ckNext.ckid != DMUS_FOURCC_TOOL_CHUNK)
        {
            pParser->LeaveList();
            Trace(1,"Error: Tool header chunk not first in tool list.\n");
            return DMUS_E_TOOL_HDR_NOT_FIRST_CK;
        }

        hr = pParser->Read(&ioDMToolHdr, sizeof(DMUS_IO_TOOL_HEADER));

        if(ioDMToolHdr.ckid == 0 && ioDMToolHdr.fccType == NULL)
        {
            pParser->LeaveList();
            Trace(1,"Error: Invalid Tool header.\n");
            return DMUS_E_INVALID_TOOL_HDR;
        }

        if(ioDMToolHdr.cPChannels)
        {
            pdwPChannels = new DWORD[ioDMToolHdr.cPChannels];
            // subtract 1 from cPChannels, because 1 element is actually stored
            // in the ioDMToolHdr array.
            cbSize = (ioDMToolHdr.cPChannels - 1) * sizeof(DWORD);
            if(pdwPChannels)
            {
                pdwPChannels[0] = ioDMToolHdr.dwPChannels[0];
                if( cbSize )
                {
                    hr = pParser->Read(&pdwPChannels[1], cbSize);
                    if(FAILED(hr))
                    {
                        delete [] pdwPChannels;
                        pdwPChannels = NULL;
                        pParser->LeaveList();
                        Trace(1,"Error: File read error loading Tool.\n");
                        return DMUS_E_CANNOTREAD;
                    }
                }
            }
            else
            {
                hr = E_OUTOFMEMORY;
            }
        }
    }
    else
    {
        pParser->LeaveList();
        Trace(1,"Error reading Tool chunk - not RIFF format.\n");
        hr = DMUS_E_DESCEND_CHUNK_FAIL;
    }
    while (pParser->NextChunk(&hr))
    {
        if((((ckNext.ckid == FOURCC_LIST) || (ckNext.ckid == FOURCC_RIFF))
            && ckNext.fccType == ioDMToolHdr.fccType) ||
            (ckNext.ckid == ioDMToolHdr.ckid))
        {
            pParser->SeekBack();
            hr = CreateTool(ioDMToolHdr, pParser->GetStream(), pdwPChannels);
            pParser->SeekForward();
        }
    }

    pParser->LeaveList();

    if( pdwPChannels )
    {
        delete [] pdwPChannels;
        pdwPChannels = NULL;
    }

    return hr;
}

HRESULT CGraph::CreateTool(DMUS_IO_TOOL_HEADER ioDMToolHdr, IStream *pStream, DWORD *pdwPChannels)
{
    assert(pStream);

    IDirectMusicTool* pDMTool = NULL;
    HRESULT hr = CoCreateInstance(ioDMToolHdr.guidClassID,
                                  NULL,
                                  CLSCTX_INPROC,
                                  IID_IDirectMusicTool,
                                  (void**)&pDMTool);

    IPersistStream *pIPersistStream = NULL;

    if(SUCCEEDED(hr))
    {
        hr = pDMTool->QueryInterface(IID_IPersistStream, (void **)&pIPersistStream);
    }
    else
    {
        Trace(1,"Error creating tool for loading\n");
    }

    if(SUCCEEDED(hr))
    {
        hr = pIPersistStream->Load(pStream);
        if (FAILED(hr))
        {
            Trace(1,"Error loading data into tool\n");
        }
    }

    if(SUCCEEDED(hr))
    {
        hr = InsertTool(pDMTool, pdwPChannels, ioDMToolHdr.cPChannels, ioDMToolHdr.lIndex, &ioDMToolHdr.guidClassID);
    }

    if(pIPersistStream)
    {
        pIPersistStream->Release();
    }

    if(pDMTool)
    {
        pDMTool->Release();
    }

    return hr;
}

HRESULT CGraph::Save( IStream* pIStream, BOOL fClearDirty )
{
    return E_NOTIMPL;
}

HRESULT CGraph::GetSizeMax( ULARGE_INTEGER FAR* pcbSize )
{
    return E_NOTIMPL;
}

/////////////////////////////////////////////////////////////////////////////
// IDirectMusicObject

STDMETHODIMP CGraph::GetDescriptor(LPDMUS_OBJECTDESC pDesc)
{
    // Argument validation
    V_INAME(CGraph::GetDescriptor);
    V_STRUCTPTR_WRITE(pDesc, DMUS_OBJECTDESC);

    memset( pDesc, 0, sizeof(DMUS_OBJECTDESC));
    pDesc->dwSize = sizeof(DMUS_OBJECTDESC);
    pDesc->guidClass = CLSID_DirectMusicGraph;
    pDesc->guidObject = m_guidObject;
    pDesc->ftDate = m_ftDate;
    pDesc->vVersion = m_vVersion;
    memcpy( pDesc->wszName, m_wszName, sizeof(m_wszName) );
    memcpy( pDesc->wszCategory, m_wszCategory, sizeof(m_wszCategory) );
    memcpy( pDesc->wszFileName, m_wszFileName, sizeof(m_wszFileName) );
    pDesc->dwValidData = ( m_dwValidData | DMUS_OBJ_CLASS );
    return S_OK;
}

STDMETHODIMP CGraph::SetDescriptor(LPDMUS_OBJECTDESC pDesc)
{
    // Argument validation
    V_INAME(CGraph::SetDescriptor);
    V_STRUCTPTR_READ(pDesc, DMUS_OBJECTDESC);

    HRESULT hr = E_INVALIDARG;
    DWORD dw = 0;

    if( pDesc->dwSize >= sizeof(DMUS_OBJECTDESC) )
    {
        if( pDesc->dwValidData & DMUS_OBJ_OBJECT )
        {
            m_guidObject = pDesc->guidObject;
            dw |= DMUS_OBJ_OBJECT;
        }
        if( pDesc->dwValidData & DMUS_OBJ_NAME )
        {
            memcpy( m_wszName, pDesc->wszName, sizeof(WCHAR)*DMUS_MAX_NAME );
            dw |= DMUS_OBJ_NAME;
        }
        if( pDesc->dwValidData & DMUS_OBJ_CATEGORY )
        {
            memcpy( m_wszCategory, pDesc->wszCategory, sizeof(WCHAR)*DMUS_MAX_CATEGORY );
            dw |= DMUS_OBJ_CATEGORY;
        }
        if( ( pDesc->dwValidData & DMUS_OBJ_FILENAME ) ||
            ( pDesc->dwValidData & DMUS_OBJ_FULLPATH ) )
        {
            memcpy( m_wszFileName, pDesc->wszFileName, sizeof(WCHAR)*DMUS_MAX_FILENAME );
            dw |= (pDesc->dwValidData & (DMUS_OBJ_FILENAME | DMUS_OBJ_FULLPATH));
        }
        if( pDesc->dwValidData & DMUS_OBJ_VERSION )
        {
            m_vVersion = pDesc->vVersion;
            dw |= DMUS_OBJ_VERSION;
        }
        if( pDesc->dwValidData & DMUS_OBJ_DATE )
        {
            m_ftDate = pDesc->ftDate;
            dw |= DMUS_OBJ_DATE;
        }
        m_dwValidData |= dw;
        if( pDesc->dwValidData & (~dw) )
        {
            Trace(2,"Warning: ToolGraph::SetDescriptor was not able to handle all passed fields, dwValidData bits %lx.\n",pDesc->dwValidData & (~dw));
            hr = S_FALSE; // there were extra fields we didn't parse;
            pDesc->dwValidData = dw;
        }
        else
        {
            hr = S_OK;
        }
    }
    else
    {
        Trace(1,"Error: Size of descriptor too large for Tool Graph to parse.\n");
    }
    return hr;
}


STDMETHODIMP CGraph::ParseDescriptor(LPSTREAM pIStream, LPDMUS_OBJECTDESC pDesc)
{
    V_INAME(CGraph::ParseDescriptor);
    V_INTERFACE(pIStream);
    V_STRUCTPTR_WRITE(pDesc, DMUS_OBJECTDESC);

    CRiffParser Parser(pIStream);
    RIFFIO ckMain;
    RIFFIO ckNext;
    RIFFIO ckUNFO;
    HRESULT hr = S_OK;
    DWORD dwValidData;

    Parser.EnterList(&ckMain);
    if (Parser.NextChunk(&hr) && (ckMain.fccType == DMUS_FOURCC_TOOLGRAPH_FORM))
    {
        dwValidData = DMUS_OBJ_CLASS;
        pDesc->guidClass = CLSID_DirectMusicGraph;
        Parser.EnterList(&ckNext);
        while(Parser.NextChunk(&hr))
        {
            switch(ckNext.ckid)
            {
            case DMUS_FOURCC_GUID_CHUNK:
                hr = Parser.Read( &pDesc->guidObject, sizeof(GUID) );
                dwValidData |= DMUS_OBJ_OBJECT;
                break;
            case DMUS_FOURCC_VERSION_CHUNK:
                hr = Parser.Read( &pDesc->vVersion, sizeof(DMUS_VERSION) );
                dwValidData |= DMUS_OBJ_VERSION;
                break;
            case DMUS_FOURCC_CATEGORY_CHUNK:
                hr = Parser.Read( &pDesc->wszCategory, sizeof(pDesc->wszCategory) );
                dwValidData |= DMUS_OBJ_CATEGORY;
                break;
            case DMUS_FOURCC_DATE_CHUNK:
                hr = Parser.Read( &pDesc->ftDate, sizeof(FILETIME) );
                dwValidData |= DMUS_OBJ_DATE;
                break;
            case FOURCC_LIST:
                switch(ckNext.fccType)
                {
                case DMUS_FOURCC_UNFO_LIST:
                    Parser.EnterList(&ckUNFO);
                    while (Parser.NextChunk(&hr))
                    {
                        if (ckUNFO.ckid == DMUS_FOURCC_UNAM_CHUNK)
                        {
                            hr = Parser.Read(&pDesc->wszName, sizeof(pDesc->wszName));
                            dwValidData |= DMUS_OBJ_NAME;
                        }
                    }
                    Parser.LeaveList();
                    break;
                }
                break;
            }
        }
        Parser.LeaveList();
    }
    else
    {
        Trace(1,"Error: Parsing Tool Graph - invalid file format\n");
        hr = DMUS_E_CHUNKNOTFOUND;
    }

    if (SUCCEEDED(hr))
    {
        pDesc->dwValidData = dwValidData;
    }
    return hr;
}

void CGraphList::Clear()
{
    CGraph *pGraph;
    while (pGraph = RemoveHead())
    {
        pGraph->Release();
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\XDmime\dmime_i.c ===
/* Copyright (c) 1998-1999 Microsoft Corporation */
/* this file contains the actual definitions of */
/* the IIDs and CLSIDs */

/* link this file in with the server and any clients */
#ifdef __cplusplus
extern "C"{
#endif 


#ifndef __IID_DEFINED__
#define __IID_DEFINED__ 

typedef struct _IID
{
    unsigned long x;
    unsigned short s1;
    unsigned short s2;
    unsigned char  c[8];
} IID;

#endif // __IID_DEFINED__

#ifndef CLSID_DEFINED
#define CLSID_DEFINED
typedef IID CLSID;
#endif // CLSID_DEFINED

const IID IID_IDirectMusicSegmentObject = {0x04742AFE,0x141F,0x11D1,{0xBC,0x1C,0x00,0xA0,0xC9,0x22,0xE6,0xEB}};


const IID IID_ITempoTrack = {0x31A1066B,0x31DD,0x11D1,{0xBC,0x2B,0x00,0xA0,0xC9,0x22,0xE6,0xEB}};


const IID IID_ITimeSigTrack = {0x31A1066D,0x31DD,0x11D1,{0xBC,0x2B,0x00,0xA0,0xC9,0x22,0xE6,0xEB}};


const IID IID_ISeqTrack = {0x30E6B076,0x3B49,0x11D1,{0xBC,0x37,0x00,0xA0,0xC9,0x22,0xE6,0xEB}};


const IID IID_IDMGraph = {0xA1198389,0x4EF1,0x11D1,{0xBC,0x4B,0x00,0xA0,0xC9,0x22,0xE6,0xEB}};


const IID IID_ISysExTrack = {0x4ECFF912,0x56DD,0x11D1,{0xBC,0x50,0x00,0xA0,0xC9,0x22,0xE6,0xEB}};


const IID IID_IPrivatePerformance = { 0xb982d7cb, 0x8177, 0x11d1, { 0xbc, 0x60, 0x0, 0xa0, 0xc9, 0x22, 0xe6, 0xeb } };


#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\XDmime\dmhall.cpp ===
// Copyright (c) 1998 Microsoft Corporation
// dmhall.cpp
// No longer used.
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\XDmime\debug.cpp ===
//
// Debug.CPP
//
// Copyright (c) 1997-1998 Microsoft Corporation
//
// @doc INTERNAL
//
// @module Debug | Debug services for DMusic.DLL
//

#include <windows.h>
#include <stdio.h>
#include <stdarg.h>

#include "debug.h"

#ifdef DBG

#define MODULE "DMIME"

// @globalv Section in WIN.INI for all debug settings
const char szDebugSection[] = "debug";

// @globalv Key in WIN.INI for our debug level. All messages with
// a level of this number or lower will be displayed.
const char szDebugKey[] = MODULE;

// @globalv Key in WIN.INI [debug] section which determines if assert calls
// DebugBreak or not
//
const char szAssertBreak[] = "AssertBreak";

// @globalv Prefix for all debug outputs
//
const char szDebugPrefix[] = MODULE ": ";

// @globalv The current debug level. 
static int giDebugLevel;

// @globalv Do asserts break?
static BOOL gfAssertBreak;

// @func Sets the debug level from WIN.INI
// 
void DebugInit(
    void)
{
    giDebugLevel = GetProfileInt(szDebugSection, szDebugKey, 0);
    gfAssertBreak = GetProfileInt(szDebugSection, szAssertBreak, 0);


    // Nepotism at its finest
    DebugTrace(-1, "Debug level is %d\n", giDebugLevel);
}

// @func Send a debug trace out.
//
// @comm Any message with a level less than or equal to the current debug
// level will be displayed using the OutputDebugString API. This means either
// the IDE Debug window if the app is running in that context or WDEB if
// it's running.
//
static BOOL fNeedPrefix = TRUE;
void DebugTrace(
    int iDebugLevel,        // @parm The debug level of this message
    LPSTR pstrFormat,       // @parm A printf style format string
    ...)                    // @parm | ... | Variable paramters based on <p pstrFormat>
{
    char sz[512];
    

    if (iDebugLevel != -1 && iDebugLevel > giDebugLevel)
    {
        return;
    }

    va_list va;

    va_start(va, pstrFormat);
    vsprintf(sz, pstrFormat, va);
    va_end(va);

    if (fNeedPrefix)
    {
        OutputDebugString(szDebugPrefix);
    }
    
    OutputDebugString(sz);

    // Let them construct multiple piece trace outs w/o
    // prefixing each one
    //
    fNeedPrefix = FALSE;
    for (;*pstrFormat && !fNeedPrefix; ++pstrFormat)
    {
        if (*pstrFormat == '\n')
        {
            fNeedPrefix = TRUE;
        }
    }
}

void DebugAssert(
    LPSTR szExp, 
    LPSTR szFile, 
    ULONG ulLine)
{
    DebugTrace(0, "ASSERT: \"%s\" %s@%lu\n", szExp, szFile, ulLine);
    if (gfAssertBreak)
    {
        DebugBreak();
    }
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\XDmime\dmgraph.h ===
// Copyright (c) 1998-1999 Microsoft Corporation
// DMGraph.h : Declaration of the CGraph

#ifndef __DMGRAPH_H_
#define __DMGRAPH_H_

#include "alist.h"
#include "dmusici.h"
#include "dmusicf.h"

class CRiffParser;

class CToolRef : public AListItem
{
public:
	CToolRef()
	{
        m_fSupportsClone = FALSE;
		m_pTool = NULL;
		m_dwQueue = 0;
		m_dwMTArraySize = 0;
        m_dwPCArraySize = 0;
		m_pdwMediaTypes = NULL;
		m_pdwPChannels = NULL;
        m_guidClassID = GUID_NULL;
	};

	// the memory for pdwTracks and pidType better have been allocated with
	// something compatible with delete!!!
	~CToolRef()
	{
		if( m_pdwPChannels )
		{
			delete [] m_pdwPChannels;
		}
		if( m_pdwMediaTypes )
		{
			delete [] m_pdwMediaTypes;
		}
		if( m_pTool )
		{
			m_pTool->Release();
		}
	};
    CToolRef* GetNext()
	{
		return (CToolRef*)AListItem::GetNext();
	};

    GUID                m_guidClassID;      // Class ID of tool.
    BOOL                m_fSupportsClone;   // Indicates this is a DX8 tool with support for cloning.
	IDirectMusicTool*	m_pTool;
	DWORD	            m_dwQueue;	// type of queue the tool wants messages to be
	DWORD	            m_dwMTArraySize; // size of the pdwMediaTypes array
	DWORD*	            m_pdwMediaTypes; // types of media the tool supports
	DWORD               m_dwPCArraySize;  // size of the pdwPChannels array
	DWORD*	            m_pdwPChannels;	// array of PChannel id's - messages stamped with these id's are
						// sent to the tool

};

class CGraph;

//#undef  INTERFACE
//#define INTERFACE  IGraphClone
DECLARE_INTERFACE_(IGraphClone, IUnknown)
{
    /* IUnknown */
    STDMETHOD(QueryInterface)       (THIS_ REFIID, LPVOID FAR *) PURE;
    STDMETHOD_(ULONG,AddRef)        (THIS) PURE;
    STDMETHOD_(ULONG,Release)       (THIS) PURE;

    /* IGraphClone */
    STDMETHOD(Clone)                (THIS_ IDirectMusicGraph **ppGraph) PURE;
};

DEFINE_GUID(IID_CGraph,0xb06c0c24, 0xd3c7, 0x11d3, 0x9b, 0xd1, 0x44, 0x45, 0x53, 0x54, 0x0, 0x0);
DEFINE_GUID(IID_IGraphClone,0xb06c0c27, 0xd3c7, 0x11d3, 0x9b, 0xd1, 0x44, 0x45, 0x53, 0x54, 0x0, 0x0);


/////////////////////////////////////////////////////////////////////////////
// CGraph
class CGraph :
	public IDirectMusicGraph8,
	public IPersistStream,
    public IDirectMusicObject,
    public IGraphClone,
    public AList,
    public AListItem
{
public:
	CGraph();
	~CGraph();
    CToolRef* GetHead(){return (CToolRef*)AList::GetHead();};
    CToolRef* RemoveHead(){return (CToolRef*)AList::RemoveHead();};
    CToolRef* GetItem(LONG lIndex){return (CToolRef*) AList::GetItem(lIndex);};
    CGraph* GetNext() { return (CGraph*)AListItem::GetNext();}

public:
// IUnknown
    STDMETHODIMP QueryInterface(const IID &iid, void **ppv);
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();

// IDirectMusicGraph
    STDMETHODIMP InsertTool(IDirectMusicTool *pTool,DWORD *pdwPChannels,DWORD cPChannels,LONG lIndex);
    STDMETHODIMP GetTool(DWORD dwPosition,IDirectMusicTool** ppTool);
    STDMETHODIMP RemoveTool(IDirectMusicTool* pTool);
    STDMETHODIMP StampPMsg(DMUS_PMSG* pPMsg);
//  IGraphClone 
    STDMETHODIMP Clone(IDirectMusicGraph **ppGraph); 

// IPersist functions
    STDMETHODIMP GetClassID( CLSID* pClsId );
// IPersistStream functions
    STDMETHODIMP IsDirty();
    STDMETHODIMP Load( IStream* pIStream );
    STDMETHODIMP Save( IStream* pIStream, BOOL fClearDirty );
    STDMETHODIMP GetSizeMax( ULARGE_INTEGER FAR* pcbSize );

// IDirectMusicObject 
	STDMETHODIMP GetDescriptor(LPDMUS_OBJECTDESC pDesc);
	STDMETHODIMP SetDescriptor(LPDMUS_OBJECTDESC pDesc);
	STDMETHODIMP ParseDescriptor(LPSTREAM pStream, LPDMUS_OBJECTDESC pDesc);

    HRESULT GetObjectInPath( DWORD dwPChannel,REFGUID guidObject,
                    DWORD dwIndex,REFGUID iidInterface, void ** ppObject);
    HRESULT Load(CRiffParser *pParser);
protected:
	HRESULT BuildToolList(CRiffParser *pParser);
	HRESULT LoadTool(CRiffParser *pParser);
	HRESULT CreateTool(DMUS_IO_TOOL_HEADER ioDMToolHdr, IStream *pStream, DWORD *pdwPChannels);
	HRESULT STDMETHODCALLTYPE Shutdown();
    HRESULT InsertTool(IDirectMusicTool *pTool,DWORD *pdwPChannels,
                DWORD cPChannels,LONG lIndex, GUID *pguidClassID);
    inline BOOL CheckType( DWORD dwType, CToolRef* pToolRef );
protected:
	CRITICAL_SECTION    m_CrSec;
	long		        m_cRef;
//	DWORD               m_fPartialLoad;
// IDirectMusicObject variables
	DWORD	            m_dwValidData;
	GUID	            m_guidObject;
	FILETIME	        m_ftDate;                       /* Last edited date of object. */
	DMUS_VERSION	    m_vVersion;                 /* Version. */
	WCHAR	            m_wszName[DMUS_MAX_NAME];			/* Name of object.       */
	WCHAR	            m_wszCategory[DMUS_MAX_CATEGORY];	/* Category for object */
	WCHAR               m_wszFileName[DMUS_MAX_FILENAME];	/* File path. */
public:
    DWORD               m_dwLoadID;         // Identifier, used when loaded as part of a song.
};

class CGraphList : public AList
{
public:
    void Clear();
    void AddHead(CGraph* pGraph) { AList::AddHead((AListItem*)pGraph);}
    void Insert(CGraph* pGraph);
    CGraph* GetHead(){return (CGraph*)AList::GetHead();}
    CGraph* GetItem(LONG lIndex){return (CGraph*)AList::GetItem(lIndex);}
    CGraph* RemoveHead() {return (CGraph *) AList::RemoveHead();}
    void Remove(CGraph* pGraph){AList::Remove((AListItem*)pGraph);}
    void AddTail(CGraph* pGraph){AList::AddTail((AListItem*)pGraph);}
    CGraph* GetTail(){ return (CGraph*)AList::GetTail();}
};

#endif //__DMGRAPH_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\XDmime\dmime.h ===
// Copyright (c) 1998-1999 Microsoft Corporation
// dmime.h
//
#ifndef _DMIME_H_
#define _DMIME_H_

// Must be before dmusicc.h, which includes dsound.h
//
#include <windows.h>
#include <mmsystem.h>
#include <dsoundp.h>

#include "dmusici.h"

#define COM_NO_WINDOWS_H
#include <objbase.h>

#include <mmsystem.h>
#define RELEASE(x)	if( NULL != x ) { x->Release(); }

#ifdef __cplusplus
extern "C" {
#endif

extern long g_cComponent;
extern bool g_fInitCS;
extern CRITICAL_SECTION g_CritSec;


#define	PARTIALLOAD_S_OK	(1 << 1)
#define PARTIALLOAD_E_FAIL	(1 << 2)

#ifdef __cplusplus
}; /* extern "C" */
#endif
DEFINE_GUID(IID_IDirectMusicPerformanceStats, 0x9301e312, 0x1f22, 0x11d3, 0x82, 0x26, 0xd2, 0xfa, 0x76, 0x25, 0x5d, 0x47);
DEFINE_GUID(IID_IDirectMusicParamHook,0x58880561, 0x5481, 0x11d3, 0x9b, 0xd1, 0xc2, 0x9f, 0xc4, 0xd1, 0xe6, 0x35);
DEFINE_GUID(IID_IDirectMusicSetParamHook,0x679c4138, 0xc62e, 0x4147, 0xb2, 0xb4, 0x9d, 0x56, 0x9a, 0xcb, 0x25, 0x4c);

#endif // _DMIME_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\XDmime\dmscriptautguids.h ===
// Copyright (c) 1999 Microsoft Corporation. All rights reserved.
//
// Declares the CLSIDs for creating the wrapper objects that implement the IDispatch
// interfaces for the various DirectMusic objects.  These CLSIDs are not public --
// they are only needed in the implementation of the DirectMusic objects.  A user of
// the IDispatch interface will get ahold of it by QueryInterface from the associated
// DirectMusic object.

#pragma once

DEFINE_GUID(CLSID_AutDirectMusicPerformance,		0xa861c6e2, 0xfcfc, 0x11d2, 0x8b, 0xc9, 0x0, 0x60, 0x8, 0x93, 0xb1, 0xb6); // {A861C6E2-FCFC-11d2-8BC9-00600893B1B6}
DEFINE_GUID(CLSID_AutDirectMusicSegment,			0x4062c116, 0x0270, 0x11d3, 0x8b, 0xcb, 0x0, 0x60, 0x8, 0x93, 0xb1, 0xb6); // {4062C116-0270-11d3-8BCB-00600893B1B6}
DEFINE_GUID(CLSID_AutDirectMusicSong,				0xa16f1761, 0xb6d8, 0x42eb, 0x8d, 0x57, 0x4a, 0x44, 0xfe, 0xdd, 0x3b, 0xd2);// {A16F1761-B6D8-42eb-8D57-4A44FEDD3BD2}
DEFINE_GUID(CLSID_AutDirectMusicSegmentState,		0xebf2320a, 0x2502, 0x11d3, 0x8b, 0xd1, 0x0, 0x60, 0x8, 0x93, 0xb1, 0xb6); // {EBF2320A-2502-11d3-8BD1-00600893B1B6}
DEFINE_GUID(CLSID_AutDirectMusicAudioPathConfig,	0x1cebde3e, 0x6b91, 0x484a, 0xaf, 0x48, 0x5e, 0x4f, 0x4e, 0xd6, 0xb1, 0xe1);// {1CEBDE3E-6B91-484a-AF48-5E4F4ED6B1E1}
DEFINE_GUID(CLSID_AutDirectMusicAudioPath,			0x2c5f9b72, 0x7148, 0x4d97, 0xbf, 0xc9, 0x68, 0xa0, 0xe0, 0x76, 0xbe, 0xbd);// {2C5F9B72-7148-4d97-BFC9-68A0E076BEBD}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\XDmime\dmperf.cpp ===
// Copyright (c) 1998-2001 Microsoft Corporation
// dmperf.cpp

#include <windows.h>
#include <mmsystem.h>
typedef long LONG_PTR, *PLONG_PTR;
typedef unsigned long ULONG_PTR, *PULONG_PTR;

#include <time.h>       // To seed random number generator
#include <dsoundp.h>
#include "debug.h"
#define ASSERT assert
#include "dmperf.h"
#include "dmime.h"
#include "dmgraph.h"
#include "dmsegobj.h"
#include "song.h"
#include "curve.h"
#include "math.h"
#include "Validate.h"
#include "dmstylep.h"
#include <ks.h>
#include "dmksctrl.h"
#include <dsound.h>
#include "dmscriptautguids.h"
#include "dmusiccp.h"
#include "wavtrack.h"
#include "tempotrk.h"

#pragma warning(disable:4296)

#define PORT_CHANNEL 0

// @doc EXTERNAL
#define MIDI_NOTEOFF        0x80
#define MIDI_NOTEON         0x90
#define MIDI_PTOUCH         0xA0
#define MIDI_CCHANGE        0xB0
#define MIDI_PCHANGE        0xC0
#define MIDI_MTOUCH         0xD0
#define MIDI_PBEND          0xE0
#define MIDI_SYSX           0xF0
#define MIDI_MTC            0xF1
#define MIDI_SONGPP         0xF2
#define MIDI_SONGS          0xF3
#define MIDI_EOX            0xF7
#define MIDI_CLOCK          0xF8
#define MIDI_START          0xFA
#define MIDI_CONTINUE       0xFB
#define MIDI_STOP           0xFC
#define MIDI_SENSE          0xFE
#define MIDI_CC_BS_MSB      0x00
#define MIDI_CC_BS_LSB      0x20
#define MIDI_CC_DATAENTRYMSB 0x06
#define MIDI_CC_DATAENTRYLSB 0x26
#define MIDI_CC_NRPN_LSB    0x62
#define MIDI_CC_NRPN_MSB    0x63
#define MIDI_CC_RPN_LSB     0x64
#define MIDI_CC_RPN_MSB     0x65
#define MIDI_CC_MOD_WHEEL   0x01
#define MIDI_CC_VOLUME      0x07
#define MIDI_CC_PAN         0x0A
#define MIDI_CC_EXPRESSION  0x0B
#define MIDI_CC_FILTER      0x4A
#define MIDI_CC_REVERB      0x5B
#define MIDI_CC_CHORUS      0x5D
#define MIDI_CC_RESETALL    0x79
#define MIDI_CC_ALLSOUNDSOFF 0x78

#define CLEARTOOLGRAPH(x)   { \
    if( (x)->pTool ) \
    { \
        (x)->pTool->Release(); \
        (x)->pTool = NULL; \
    } \
    if( (x)->pGraph ) \
    { \
        (x)->pGraph->Release(); \
        (x)->pGraph = NULL; }}

#define GetLatencyWithPrePlay() ( GetLatency() + m_rtBumperLength )

void CChannelBlockList::Clear()
{
    CChannelBlock* pCB;
    while( pCB = RemoveHead() )
    {
        delete pCB;
    }
}

void CChannelMap::Clear()

{
    Reset(TRUE);                // Clear all MIDI controllers
    m_TransposeMerger.Clear(0); // No transpose.
    nTranspose = 0;
    wFlags = CMAP_FREE;
}

void CChannelMap::Reset(BOOL fVolumeAndPanToo)

{
    if (fVolumeAndPanToo)
    {
        m_PanMerger.Clear(0);       // Panned to center.
        m_VolumeMerger.Clear(-415); // Equivalent to MIDI value 100.
    }
    m_PitchbendMerger.Clear(0); // No pitch bend.
    m_ExpressionMerger.Clear(0);// Full volume for expression (MIDI 127.)
    m_FilterMerger.Clear(0);    // No filter change.
    m_ReverbMerger.Clear(-87); // Start at default level (MIDI 40).
    m_ChorusMerger.Clear(-127);    // Start with no chorus.
    m_ModWheelMerger.Clear(-127);  // Start with no mod wheel.
}

void CParamMerger::Clear(long lInitValue )

{
    CMergeParam *pParam;
    while (pParam = RemoveHead())
    {
        delete pParam;
    }
    m_lZeroIndexData = lInitValue;
    m_lMergeTotal = 0;
}


long CParamMerger::m_lMIDIToDB[128] = {       // Global array used to convert MIDI to dB.
    -9600, -8415, -7211, -6506, -6006, -5619, -5302, -5034,
    -4802, -4598, -4415, -4249, -4098, -3959, -3830, -3710,
    -3598, -3493, -3394, -3300, -3211, -3126, -3045, -2968,
    -2894, -2823, -2755, -2689, -2626, -2565, -2506, -2449,
    -2394, -2341, -2289, -2238, -2190, -2142, -2096, -2050,
    -2006, -1964, -1922, -1881, -1841, -1802, -1764, -1726,
    -1690, -1654, -1619, -1584, -1551, -1518, -1485, -1453,
    -1422, -1391, -1361, -1331, -1302, -1273, -1245, -1217,
    -1190, -1163, -1137, -1110, -1085, -1059, -1034, -1010,
    -985, -961, -938, -914, -891, -869, -846, -824,
    -802, -781, -759, -738, -718, -697, -677, -657,
    -637, -617, -598, -579, -560, -541, -522, -504,
    -486, -468, -450, -432, -415, -397, -380, -363,
    -347, -330, -313, -297, -281, -265, -249, -233,
    -218, -202, -187, -172, -157, -142, -127, -113,
    -98, -84, -69, -55, -41, -27, -13, 0
};


long CParamMerger::m_lDBToMIDI[97] = {        // Global array used to convert db to MIDI.
    127, 119, 113, 106, 100, 95, 89, 84, 80, 75,
    71, 67, 63, 60, 56, 53, 50, 47, 45, 42,
    40, 37, 35, 33, 31, 30, 28, 26, 25, 23,
    22, 21, 20, 19, 17, 16, 15, 15, 14, 13,
    12, 11, 11, 10, 10, 9, 8, 8, 8, 7,
    7, 6, 6, 6, 5, 5, 5, 4, 4, 4,
    4, 3, 3, 3, 3, 3, 2, 2, 2, 2,
    2, 2, 2, 1, 1, 1, 1, 1, 1, 1,
    1, 1, 1, 1, 1, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0
};


CParamMerger::CParamMerger()
{
    m_lMergeTotal = 0;
    m_lZeroIndexData = 0;
}

BYTE CParamMerger::VolumeToMidi(long lVolume)

{
    if (lVolume < -9600) lVolume = -9600;
    if (lVolume > 0) lVolume = 0;
    lVolume = -lVolume;
    long lFraction = lVolume % 100;
    lVolume = lVolume / 100;
    long lResult = m_lDBToMIDI[lVolume];
    lResult += ((m_lDBToMIDI[lVolume + 1] - lResult) * lFraction) / 100;
    return (BYTE) lResult;
}

/*  MergeMidiVolume() takes an incoming volume and updates the matching
    MergeParam structure (determined by index.) If there is no such matching
    structure, it creates one. Also, the volumes are totaled to create a new
    total volume, which is converted back to MIDI volume and returned.
    This mechanism allows us to introduce additional volume controllers
    that are summed.
*/

BYTE CParamMerger::MergeMidiVolume(DWORD dwIndex, BYTE bMIDIVolume)

{
    long lVolume = MergeData(dwIndex,m_lMIDIToDB[bMIDIVolume]);
    if (m_lMergeTotal || dwIndex) // Optimization for simplest and most frequent case - there are no additional indexes.
    {
        return (BYTE) VolumeToMidi(lVolume);
    }
    return bMIDIVolume;
}

BYTE CParamMerger::GetVolumeStart(DWORD dwIndex)

{
    if (dwIndex == 0)
    {
        return VolumeToMidi(m_lZeroIndexData);
    }
    return VolumeToMidi(GetIndexedValue(dwIndex));
}

/*  MergeValue is used for all data types that have a plus and minus range
    around a center bias. These include pitch bend, pan and filter.
    MergeValue takes an incoming data value, adds the bias (in lRange),
    calls MergeData to combine it with the other merged inputs,
    adds the bias back in and checks for over or underflow.
*/

long CParamMerger::MergeValue(DWORD dwIndex, long lData, long lCenter, long lRange)

{
    lData = MergeData(dwIndex,lData - lCenter) + lCenter;
    if (lData < 0) lData = 0;
    if (lData > lRange) lData = lRange;
    return lData;
}


short CParamMerger::MergeTranspose(DWORD dwIndex, short nTranspose)

{
    return (short) MergeData(dwIndex,nTranspose);
}

long CParamMerger::MergeData(DWORD dwIndex, long lData)

{
    if (dwIndex)
    {
        // If this has an index, scan the indexes. Look
        // for the matching index. If it is found, update it
        // with the new data. Meanwhile, add up all the data fields.
        // If it is not found, add an entry for it.
        m_lMergeTotal = 0;   // Recalculate
        BOOL fNoEntry = TRUE;
        CMergeParam *pParam = GetHead();
        for (;pParam;pParam = pParam->GetNext())
        {
            if (pParam->m_dwIndex == dwIndex)
            {
                // Found the index. Store the new value.
                pParam->m_lData = lData;
                fNoEntry = FALSE;
            }
            // Sum all values to create the merged total.
            m_lMergeTotal += pParam->m_lData;
        }
        if (fNoEntry)
        {
            // Didn't find the index. Create one and store the value.
            pParam = new CMergeParam;
            if (pParam)
            {
                pParam->m_dwIndex = dwIndex;
                pParam->m_lData = lData;
                m_lMergeTotal += lData;
                AddHead(pParam);
            }
        }
        // Add the initial value for merge index 0.
        lData = m_lMergeTotal + m_lZeroIndexData;
    }
    else
    {
        m_lZeroIndexData = lData;
        lData += m_lMergeTotal;
    }
    return lData;
}


long CParamMerger::GetIndexedValue(DWORD dwIndex)

{
    if (dwIndex)
    {
        // If this has an index, scan the indexes. Look
        // for the matching index. If it is found, return its data.
        // If not, return the default 0.
        BOOL fNoEntry = TRUE;
        CMergeParam *pParam = GetHead();
        for (;pParam;pParam = pParam->GetNext())
        {
            if (pParam->m_dwIndex == dwIndex)
            {
                return pParam->m_lData;
            }
        }
        return 0;
    }
    return m_lZeroIndexData;
}

void CChannelBlock::Init(DWORD dwPChannelStart,
                         DWORD dwPortIndex, DWORD dwGroup,
                         WORD wFlags)

{
    DWORD dwIndex;
    m_dwPortIndex = dwPortIndex;
    m_dwPChannelStart = ( dwPChannelStart / PCHANNEL_BLOCKSIZE ) * PCHANNEL_BLOCKSIZE;
    for( dwIndex = 0; dwIndex < PCHANNEL_BLOCKSIZE; dwIndex++ )
    {
        m_aChannelMap[dwIndex].Clear();
        m_aChannelMap[dwIndex].dwPortIndex = dwPortIndex;
        m_aChannelMap[dwIndex].dwGroup = dwGroup;
        m_aChannelMap[dwIndex].dwMChannel = dwIndex;
        m_aChannelMap[dwIndex].nTranspose = 0;
        m_aChannelMap[dwIndex].wFlags = wFlags;
    }
    if (wFlags == CMAP_FREE) m_dwFreeChannels = 16;
    else m_dwFreeChannels = 0;
}


/////////////////////////////////////////////////////////////////////////////
// CPerformance

// Flags for which critical sections have been initialized
//

#define PERF_ICS_SEGMENT        0x0001
#define PERF_ICS_PIPELINE       0x0002
#define PERF_ICS_PCHANNEL       0x0004
#define PERF_ICS_GLOBAL         0x0010
#define PERF_ICS_REALTIME       0x0020
#define PERF_ICS_PORTTABLE      0x0040
#define PERF_ICS_MAIN           0x0100
#define PERF_ICS_PMSGCACHE      0x0200

CPerformance::CPerformance()
{
    m_pGraph = NULL;
    m_dwPrepareTime = 1000;
    m_dwBumperLength = 50;
    m_rtBumperLength = m_dwBumperLength * REF_PER_MIL;
    m_pGlobalData = NULL;
    m_fInTrackPlay = FALSE;
    m_fPlaying = FALSE;
    m_wRollOverCount = 0;
    m_mtTransported = 0;
    m_mtTempoCursor = 0;
    m_pParamHook = NULL;
    m_hNotification = 0;
    m_rtNotificationDiscard = 20000000;
    m_rtStart = 0;
    m_rtAdjust = 0;
    m_mtPlayTo = 0;
    m_cRef = 1;
    m_pUnkDispatch = NULL;
    m_dwVersion = 6;
    m_dwNumPorts = 0;
    m_pPortTable = NULL;
    m_fKillThread = 0;
    m_fKillRealtimeThread = 0;
    m_fInTransportThread = 0;
    m_dwTransportThreadID = 0;
    m_pDirectMusic = NULL;
    m_pDirectSound = NULL;
    m_pClock = NULL;
    m_fReleasedInTransport = false;
    m_fReleasedInRealtime = false;
    InterlockedIncrement(&g_cComponent);

    TraceI(3,"CPerformance %lx\n", this);
    m_dwInitCS = 0;

    InitializeCriticalSection(&m_SegmentCrSec);         m_dwInitCS |= PERF_ICS_SEGMENT;
    InitializeCriticalSection(&m_PipelineCrSec);        m_dwInitCS |= PERF_ICS_PIPELINE;
    InitializeCriticalSection(&m_PChannelInfoCrSec);    m_dwInitCS |= PERF_ICS_PCHANNEL;
    InitializeCriticalSection(&m_GlobalDataCrSec);      m_dwInitCS |= PERF_ICS_GLOBAL;
    InitializeCriticalSection(&m_RealtimeCrSec);        m_dwInitCS |= PERF_ICS_REALTIME;
    InitializeCriticalSection(&m_PMsgCacheCrSec);       m_dwInitCS |= PERF_ICS_PMSGCACHE;
    InitializeCriticalSection(&m_MainCrSec);            m_dwInitCS |= PERF_ICS_MAIN;
    memset( m_apPMsgCache, 0, sizeof(DMUS_PMSG*) * (PERF_PMSG_CB_MAX - PERF_PMSG_CB_MIN) );
    DWORD dwCount;
    for (dwCount = 0; dwCount < SQ_COUNT; dwCount++)
    {
        m_SegStateQueues[dwCount].SetID(dwCount);
    }
    Init();
}

void CPerformance::Init()

{
    m_rtEarliestStartTime = 0;
    m_lMasterVolume = 0;
    if (m_dwVersion >= 8)
    {
        m_rtQueuePosition = 0;
        m_dwPrepareTime = 1000;
        m_dwBumperLength = 50;
        m_rtBumperLength = m_dwBumperLength * REF_PER_MIL;
        if (m_dwAudioPathMode)
        {
            CloseDown();
        }
    }
    m_pDefaultAudioPath = NULL;
    m_fltRelTempo = 1;
    m_pGetParamSegmentState = NULL;
    m_dwGetParamFlags = 0;
    m_rtHighestPackedNoteOn = 0;
    m_dwAudioPathMode = 0;
    m_hTransport = 0;
    m_hTransportThread = 0;
    m_dwRealtimeThreadID = 0;
    m_hRealtime = 0;
    m_hRealtimeThread = 0;
    m_fMusicStopped = TRUE;
    BOOL fAuto = FALSE;
    SetGlobalParam(GUID_PerfAutoDownload,&fAuto,sizeof(BOOL));
    DMUS_TIMESIG_PMSG* pTimeSig;
    if (SUCCEEDED(AllocPMsg(sizeof(DMUS_TIMESIG_PMSG),(DMUS_PMSG **) &pTimeSig)))
    {
        pTimeSig->wGridsPerBeat = 4;
        pTimeSig->bBeatsPerMeasure = 4;
        pTimeSig->bBeat = 4;
        pTimeSig->dwFlags = DMUS_PMSGF_REFTIME;
        pTimeSig->dwType = DMUS_PMSGT_TIMESIG;
        EnterCriticalSection(&m_PipelineCrSec);
        m_TimeSigQueue.Enqueue(  DMUS_TO_PRIV(pTimeSig) );
        LeaveCriticalSection(&m_PipelineCrSec);
    }
}

CPerformance::~CPerformance()
{
    TraceI(3,"~CPerformance %lx\n", this);
    if (m_pParamHook)
    {
        m_pParamHook->Release();
    }
    CloseDown(); // this should have already been called, but just in case...
    if (m_pUnkDispatch)
        m_pUnkDispatch->Release(); // free IDispatch implementation we may have borrowed

    if (m_dwInitCS & PERF_ICS_SEGMENT)  DeleteCriticalSection(&m_SegmentCrSec);
    if (m_dwInitCS & PERF_ICS_PIPELINE) DeleteCriticalSection(&m_PipelineCrSec);
    if (m_dwInitCS & PERF_ICS_PCHANNEL) DeleteCriticalSection(&m_PChannelInfoCrSec);
    if (m_dwInitCS & PERF_ICS_GLOBAL)   DeleteCriticalSection(&m_GlobalDataCrSec);
    if (m_dwInitCS & PERF_ICS_REALTIME) DeleteCriticalSection(&m_RealtimeCrSec);
    if (m_dwInitCS & PERF_ICS_PMSGCACHE)DeleteCriticalSection(&m_PMsgCacheCrSec);
    if (m_dwInitCS & PERF_ICS_MAIN)     DeleteCriticalSection(&m_MainCrSec);

    InterlockedDecrement(&g_cComponent);
}

STDMETHODIMP CPerformance::CloseDown(void)
{
    V_INAME(CPerformance::CloseDown);
    DWORD dwThreadID = GetCurrentThreadId();
    if( m_dwAudioPathMode )
    {
        // kill the transport thread
        m_fKillThread = 1;
        m_fKillRealtimeThread = 1;
        if (dwThreadID != m_dwTransportThreadID)
        {
            // signal the transport thread so we don't have to wait for it to wake up on its own
            if( m_hTransport ) SetEvent( m_hTransport );
            // wait until the transport thread quits
            WaitForSingleObject(m_hTransportThread, INFINITE);
        }
        if (dwThreadID != m_dwRealtimeThreadID)
        {
            // signal the realtime thread so we don't have to wait for it to wake up on its own
            if( m_hRealtime ) SetEvent( m_hRealtime );
            // wait until the realtime thread quits
            WaitForSingleObject(m_hRealtimeThread, INFINITE);
        }
    }

    if (m_pGraph) SetGraph(NULL); // shut down the graph and release it (needs to happen before clearing audio path)

    EnterCriticalSection(&m_SegmentCrSec);
    EnterCriticalSection(&m_RealtimeCrSec);

    m_fPlaying = FALSE; // prevents transport thread from doing anything more
    IDirectMusicPerformance* pPerf = NULL;
    if (SUCCEEDED(QueryInterface(IID_IDirectMusicPerformance, (void**)&pPerf)))
    {
        CWavTrack::UnloadAllWaves(pPerf);
        pPerf->Release();
    }
    DequeueAllSegments();
    if (m_pDefaultAudioPath)
    {
        m_pDefaultAudioPath->Release();
        m_pDefaultAudioPath = NULL;
    }
    m_dwAudioPathMode = 0;
    m_AudioPathList.Clear();
    CNotificationItem* pItem = m_NotificationList.GetHead();
    while( pItem )
    {
        CNotificationItem* pNext = pItem->GetNext();
        m_NotificationList.Remove( pItem );
        delete pItem;
        pItem = pNext;
    }
    LeaveCriticalSection(&m_RealtimeCrSec);
    LeaveCriticalSection(&m_SegmentCrSec);

    EnterCriticalSection(&m_PipelineCrSec);
    PRIV_PMSG* pPMsg;
    while( pPMsg = m_EarlyQueue.Dequeue() )
    {
        FreePMsg(pPMsg);
    }
    while( pPMsg = m_NearTimeQueue.Dequeue() )
    {
        FreePMsg(pPMsg);
    }
    while( pPMsg = m_OnTimeQueue.Dequeue() )
    {
        FreePMsg(pPMsg);
    }
    while( pPMsg = m_TempoMap.Dequeue() )
    {
        FreePMsg(pPMsg);
    }
    while( pPMsg = m_OldTempoMap.Dequeue() )
    {
        FreePMsg(pPMsg);
    }
    while( pPMsg = m_NotificationQueue.Dequeue() )
    {
        FreePMsg(pPMsg);
    }
    while( pPMsg = m_TimeSigQueue.Dequeue() )
    {
        FreePMsg(pPMsg);
    }

    LeaveCriticalSection(&m_PipelineCrSec);

    EnterCriticalSection(&m_GlobalDataCrSec);
    GlobalData* pGD = m_pGlobalData;
    while( pGD )
    {
        m_pGlobalData = pGD->pNext;
        delete pGD;
        pGD = m_pGlobalData;
    }
    LeaveCriticalSection(&m_GlobalDataCrSec);

    EnterCriticalSection(&m_PChannelInfoCrSec);
    // clear out ports, buffers, and pchannel maps
    if( m_pPortTable )
    {
        DWORD dwIndex;
        for( dwIndex = 0; dwIndex < m_dwNumPorts; dwIndex++ )
        {
            if( m_pPortTable[dwIndex].pPort )
            {
                m_pPortTable[dwIndex].pPort->Release();
            }
            if( m_pPortTable[dwIndex].pBuffer )
            {
                m_pPortTable[dwIndex].pBuffer->Release();
            }
            if( m_pPortTable[dwIndex].pLatencyClock )
            {
                m_pPortTable[dwIndex].pLatencyClock->Release();
            }
        }
        delete [] m_pPortTable;
        m_pPortTable = NULL;
        m_dwNumPorts = 0;
    }
    m_ChannelBlockList.Clear();
    LeaveCriticalSection(&m_PChannelInfoCrSec);
    EnterCriticalSection(&m_MainCrSec);
    if( m_pClock )
    {
        m_pClock->Release();
        m_pClock = NULL;
    }
    m_BufferManager.Clear();
    if( m_pDirectMusic )
    {
        m_pDirectMusic->Release();
        m_pDirectMusic = NULL;
    }
    if (m_pDirectSound)
    {
        m_pDirectSound->Release();
        m_pDirectSound = NULL;
    }
    m_hNotification = NULL;
    LeaveCriticalSection(&m_MainCrSec);

    EnterCriticalSection(&m_PMsgCacheCrSec);
    for( int i = 0; i < (PERF_PMSG_CB_MAX - PERF_PMSG_CB_MIN); i++ )
    {
        while( m_apPMsgCache[i] )
        {
            PRIV_PMSG* pPriv = m_apPMsgCache[i];
            m_apPMsgCache[i] = pPriv->pNext;
            delete [] pPriv;
        }
    }
    LeaveCriticalSection(&m_PMsgCacheCrSec);

    DWORD dwExitCode = 0;
    if (m_hTransportThread)
    {
        CloseHandle( m_hTransportThread );
        m_hTransportThread = 0;
    }
    if( m_hTransport )
    {
        CloseHandle( m_hTransport );
        m_hTransport = 0;
    }
    if (m_hRealtimeThread)
    {
        CloseHandle( m_hRealtimeThread );
        m_hRealtimeThread = 0;
    }
    if( m_hRealtime )
    {
        CloseHandle( m_hRealtime );
        m_hRealtime = 0;
    }
    m_mtPlayTo = 0;
    return S_OK;
}

// @method:(INTERNAL) HRESULT | IDirectMusicPerformance | QueryInterface | Standard QueryInterface implementation for <i IDirectMusicPerformance>
//
// @rdesc Returns one of the following:
//
// @flag S_OK | If the interface is supported and was returned
// @flag E_NOINTERFACE | If the object does not support the given interface.
// @flag E_POINTER | <p ppv> is NULL or invalid.
//
STDMETHODIMP CPerformance::QueryInterface(
    const IID &iid,   // @parm Interface to query for
    void **ppv)       // @parm The requested interface will be returned here
{
    V_INAME(CPerformance::QueryInterface);
    V_PTRPTR_WRITE(ppv);
    V_REFGUID(iid);

    *ppv = NULL;
    if (iid == IID_IUnknown || iid == IID_IDirectMusicPerformance)
    {
        *ppv = static_cast<IDirectMusicPerformance*>(this);
    } else
    if (iid == IID_IDirectMusicPerformance8)
    {
        m_dwVersion = 8;
        *ppv = static_cast<IDirectMusicPerformance8*>(this);
    } else
    if (iid == IID_IDirectMusicPerformance2)
    {
        m_dwVersion = 7;
        *ppv = static_cast<IDirectMusicPerformance*>(this);
    } else
    if( iid == IID_IDirectMusicPerformanceStats )
    {
        *ppv = static_cast<IDirectMusicPerformanceStats*>(this);
    } else
    if( iid == IID_IDirectMusicSetParamHook )
    {
        *ppv = static_cast<IDirectMusicSetParamHook*>(this);
    } else
    if (iid == IID_IDirectMusicTool)
    {
        *ppv = static_cast<IDirectMusicTool*>(this);
    } else
    if (iid == IID_CPerformance)
    {
        *ppv = static_cast<CPerformance*>(this);
    }
    if (iid == IID_IDirectMusicGraph)
    {
        *ppv = static_cast<IDirectMusicGraph*>(this);
    }
    if (iid == IID_IDirectMusicPerformanceP)
    {
        *ppv = static_cast<IDirectMusicPerformanceP*>(this);
    } else
    if (iid == IID_IDispatch)
    {
        // A helper scripting object implements IDispatch, which we expose from the
        // Performance object via COM aggregation.
        if (!m_pUnkDispatch)
        {
            // Create the helper object
            ::CoCreateInstance(
                CLSID_AutDirectMusicPerformance,
                static_cast<IDirectMusicPerformance*>(this),
                CLSCTX_INPROC_SERVER,
                IID_IUnknown,
                reinterpret_cast<void**>(&m_pUnkDispatch));
        }
        if (m_pUnkDispatch)
        {
            return m_pUnkDispatch->QueryInterface(IID_IDispatch, ppv);
        }
    }
    if (*ppv == NULL)
    {
        Trace(4,"Warning: Request to query unknown interface on Performance object\n");
        return E_NOINTERFACE;
    }
    reinterpret_cast<IUnknown*>(this)->AddRef();
    return S_OK;
}


// @method:(INTERNAL) HRESULT | IDirectMusicPerformance | AddRef | Standard AddRef implementation for <i IDirectMusicPerformance>
//
// @rdesc Returns the new reference count for this object.
//
STDMETHODIMP_(ULONG) CPerformance::AddRef()
{
    return InterlockedIncrement(&m_cRef);
}


// @method:(INTERNAL) HRESULT | IDirectMusicPerformance | Release | Standard Release implementation for <i IDirectMusicPerformance>
//
// @rdesc Returns the new reference count for this object.
//
STDMETHODIMP_(ULONG) CPerformance::Release()
{
    if (!InterlockedDecrement(&m_cRef))
    {
        DWORD dwThreadID = GetCurrentThreadId();
        m_cRef = 100; // artificial reference count to prevent reentrency due to COM aggregation
        if (dwThreadID == m_dwTransportThreadID)
        {
            m_fReleasedInTransport = true;
            m_fKillThread = TRUE;
        }
        else if (dwThreadID == m_dwRealtimeThreadID)
        {
            m_fReleasedInRealtime = true;
            m_fKillRealtimeThread = TRUE;
        }
        else
        {
            delete this;
        }
        return 0;
    }

    return m_cRef;
}

// call this only from within a m_SegmentCrSec critical section
// if fSendNotify, then send segment end notifications for segments that were
// playing
void CPerformance::DequeueAllSegments()
{
    CSegState *pNode;
    DWORD dwCount;

    for( dwCount = 0; dwCount < SQ_COUNT; dwCount++ )
    {
        while( pNode = m_SegStateQueues[dwCount].RemoveHead())
        {
            pNode->ShutDown();
        }
    }
    while( pNode = m_ShutDownQueue.RemoveHead())
    {
        pNode->ShutDown();
    }
}

// IDirectMusicPerformanceStats

STDMETHODIMP CPerformance::TraceAllSegments()
{
    CSegState *pNode;
    DWORD dwCount;
    for( dwCount = 0; dwCount < SQ_COUNT; dwCount++ )
    {
        EnterCriticalSection(&m_SegmentCrSec);
        for ( pNode = m_SegStateQueues[dwCount].GetHead();pNode;pNode=pNode->GetNext())
        {
            TraceI(0,"%x %ld: Playing: %ld, Start: %ld, Seek: %ld, LastPlayed: %ld\n",
                pNode,dwCount,pNode->m_fStartedPlay, pNode->m_mtResolvedStart,
                pNode->m_mtSeek, pNode->m_mtLastPlayed);
        }
        LeaveCriticalSection(&m_SegmentCrSec);
    }
    return S_OK;
}

STDMETHODIMP CPerformance::CreateSegstateList(DMUS_SEGSTATEDATA ** ppList)

{
    if (!ppList) return E_POINTER;
    CSegState *pNode;
    DWORD dwCount;
    for( dwCount = 0; dwCount < SQ_COUNT; dwCount++ )
    {
        EnterCriticalSection(&m_SegmentCrSec);
        for ( pNode = m_SegStateQueues[dwCount].GetHead();pNode;pNode=pNode->GetNext())
        {
            DMUS_SEGSTATEDATA *pData = new DMUS_SEGSTATEDATA;
            if (pData)
            {
                CSegment *pSegment = pNode->m_pSegment;
                if (pSegment && (pSegment->m_dwValidData & DMUS_OBJ_NAME))
                {
                    wcscpy(pData->wszName,pSegment->m_wszName);
                }
                else
                {
                    pData->wszName[0] = 0;
                }
                pData->dwQueue = dwCount;
                pData->pSegState = (IDirectMusicSegmentState *) pNode;
                pNode->AddRef();
                pData->pNext = *ppList;
                pData->mtLoopEnd = pNode->m_mtLoopEnd;
                pData->mtLoopStart = pNode->m_mtLoopStart;
                pData->dwRepeats = pNode->m_dwRepeats;
                pData->dwPlayFlags = pNode->m_dwPlaySegFlags;
                pData->mtLength = pNode->m_mtLength;
                pData->rtGivenStart = pNode->m_rtGivenStart;
                pData->mtResolvedStart = pNode->m_mtResolvedStart;
                pData->mtOffset = pNode->m_mtOffset;
                pData->mtLastPlayed = pNode->m_mtLastPlayed;
                pData->mtPlayTo = pNode->m_mtStopTime;
                pData->mtSeek = pNode->m_mtSeek;
                pData->mtStartPoint = pNode->m_mtStartPoint;
                pData->dwRepeatsLeft = pNode->m_dwRepeatsLeft;
                pData->fStartedPlay = pNode->m_fStartedPlay;
                *ppList = pData;
            }
        }
        LeaveCriticalSection(&m_SegmentCrSec);
    }
    return S_OK;
}

STDMETHODIMP CPerformance::FreeSegstateList(DMUS_SEGSTATEDATA * pList)

{
    DMUS_SEGSTATEDATA *pState;
    while (pList)
    {
        pState = pList;
        pList = pList->pNext;
        pState->pSegState->Release();
        delete pState;
    }
    return S_OK;
}

void CPerformance::SendBuffers()
{
    DWORD dwIndex;
    PortTable* pPortTable;

#ifdef DBG_PROFILE
    DWORD dwDebugTime;
    dwDebugTime = timeGetTime();
#endif
    EnterCriticalSection(&m_PChannelInfoCrSec);
    for( dwIndex = 0; dwIndex < m_dwNumPorts; dwIndex++ )
    {
        if( m_pPortTable[dwIndex].fBufferFilled && m_pPortTable[dwIndex].pBuffer )
        {
            pPortTable = &m_pPortTable[dwIndex];
            pPortTable->fBufferFilled = FALSE;
            ASSERT( pPortTable->pBuffer );
            if( pPortTable->pPort )
            {
                pPortTable->pPort->PlayBuffer( pPortTable->pBuffer );
//  TraceI(5, "SENT BUFFERS time=%ld latency=%ld\n", (long)(GetTime() / 10000),(long)(GetLatency()/10000));
            }
            pPortTable->pBuffer->Flush();
        }
    }
    LeaveCriticalSection(&m_PChannelInfoCrSec);
#ifdef DBG_PROFILE
    dwDebugTime = timeGetTime() - dwDebugTime;
    if( dwDebugTime > 1 )
    {
        TraceI(5, "Hall, debugtime SendBuffers %u\n", dwDebugTime);
    }
#endif
}

static DWORD WINAPI _Realtime(LPVOID lpParam)
{
    if (SUCCEEDED(::CoInitialize(NULL)))
    {
        ((CPerformance *)lpParam)->Realtime();
        ::CoUninitialize();
    }
    return 0;
}

void CPerformance::Realtime()
{
    while (!m_fKillRealtimeThread)
    {
        EnterCriticalSection(&m_RealtimeCrSec);
        PRIV_PMSG *pEvent;
        HRESULT hr;
        REFERENCE_TIME  rtFirst = 0;
        REFERENCE_TIME  rtEnter = GetLatencyWithPrePlay();
        DWORD   dwTestTime;
        DWORD   dwBeginTime = timeGetTime();
        DWORD   dwLimitLoop = 0;

        if( rtEnter > m_rtQueuePosition )
        {
            m_rtQueuePosition = rtEnter;
        }

        while (1)
        {
            // rtFirst equals the time that the first event was packed into a buffer.
            // Once this time is greater than the latency clock (minus a delay) we need
            // to queue the buffers so the events get down in time to be rendered.
            // If rtFirst is 0 it means it hasn't been initialized yet.
            dwTestTime = timeGetTime();
            if( dwTestTime - dwBeginTime > REALTIME_RES )
            {
                if( ++dwLimitLoop > 10 )
                {
                    TraceI(1,"Error! We've been in the realtime thread too long!!! Breaking out without completing.\n");
                    break;
                }
                SendBuffers();
                dwBeginTime = dwTestTime;
            }
            pEvent = GetNextPMsg();
            if( NULL == pEvent )
            {
                break;
            }
            ASSERT( pEvent->pNext == NULL );
            if( !pEvent->pTool )
            {
                // this event doesn't have a Tool pointer, so stamp it with the
                // final output Tool.
                pEvent->pTool = (IDirectMusicTool*)this;
                AddRef();
            }

            // before processing the event, set rtLast to the event's current time
            pEvent->rtLast = pEvent->rtTime;

            hr = pEvent->pTool->ProcessPMsg( this, PRIV_TO_DMUS(pEvent) );
            if( hr != S_OK ) // S_OK means do nothing
            {
                if( hr == DMUS_S_REQUEUE )
                {
                    if(FAILED(SendPMsg( PRIV_TO_DMUS(pEvent) )))
                    {
                        FreePMsg(pEvent);
                    }
                }
                else // e.g. DMUS_S_FREE or error code
                {
                    FreePMsg( pEvent );
                }
            }
        }
        SendBuffers();
        LeaveCriticalSection(&m_RealtimeCrSec);
        if( m_hRealtime )
        {
            WaitForSingleObject( m_hRealtime, REALTIME_RES );
        }
        else
        {
            Sleep(REALTIME_RES);
        }
    }
    m_fKillRealtimeThread = FALSE;
    TraceI(2, "dmperf: LEAVE realtime\n");
    if (m_fReleasedInRealtime)
    {
        delete this;
    }
}

void CPerformance::GenerateNotification( DWORD dwNotification, MUSIC_TIME mtTime,
                                          IDirectMusicSegmentState* pSegSt)
{
    GUID guid;
    guid = GUID_NOTIFICATION_PERFORMANCE;
    if( FindNotification( guid ))
    {
        DMUS_NOTIFICATION_PMSG* pEvent = NULL;
        if( SUCCEEDED( AllocPMsg( sizeof(DMUS_NOTIFICATION_PMSG),
            (DMUS_PMSG**)&pEvent )))
        {
            pEvent->dwField1 = 0;
            pEvent->dwField2 = 0;
            pEvent->guidNotificationType = GUID_NOTIFICATION_PERFORMANCE;
            pEvent->dwType = DMUS_PMSGT_NOTIFICATION;
            pEvent->mtTime = mtTime;
            pEvent->dwFlags = DMUS_PMSGF_MUSICTIME | DMUS_PMSGF_TOOL_ATTIME;
            pEvent->dwGroupID = 0xffffffff;
            pEvent->dwPChannel = 0;
            pEvent->dwNotificationOption = dwNotification;
            if( pSegSt )
            {
                pSegSt->QueryInterface(IID_IUnknown, (void**)&pEvent->punkUser);
            }
            StampPMsg((DMUS_PMSG*)pEvent);
            if(FAILED(SendPMsg( (DMUS_PMSG*)pEvent )))
            {
                FreePMsg((DMUS_PMSG*)pEvent);
            }
        }
    }
}

void CPerformance::PrepSegToPlay(CSegState *pSegState, bool fQueue)

/*  Called when a segment is first queued, once the start time of the segment is known.
    This calculates various fields that need to be initialized and also regenerates the
    tempo map if the new segment has an active tempo map in it.
*/

{
    if (!pSegState->m_fPrepped)
    {
        pSegState->m_fPrepped = TRUE;
        pSegState->m_mtLastPlayed = pSegState->m_mtResolvedStart;
        // if this is queued to play after the current segment ends, no need to recalc the tempo map;
        // it will be updated as necessary by the transport thread.
        if (!fQueue)
        {
            RecalcTempoMap(pSegState, pSegState->m_mtResolvedStart);
        }
        MusicToReferenceTime(pSegState->m_mtLastPlayed,&pSegState->m_rtLastPlayed);
        // Calculate the total duration of the segment and store in m_mtEndTime.
        pSegState->m_mtEndTime = pSegState->GetEndTime(pSegState->m_mtResolvedStart);
    }
}

/*

  void | CPerformance | PerformSegStNode |
  Perform a Segment State contained in the CSegState.

  Note that this ppSegStNode may be dequeued, so don't depend on it
  staying around!

*/
void CPerformance::PerformSegStNode(
    DWORD dwList,   // The list the segmentstate comes from.
    CSegState* pSegStNode)  // The segmentstate node.
{
    MUSIC_TIME mtMargin; // tracks how much of a segment to play
    HRESULT hr;
    CSegStateList *pList = &m_SegStateQueues[dwList];
    CSegState *pNext;

    if( !m_fPlaying || m_fInTrackPlay )
    {
        return;
    }
    if( pSegStNode )
    {
        m_fInTransportThread = TRUE;    // Disable realtime processing of early queue messages.
        hr = S_OK;
//Trace(0,"%ld: Performing %lx, Active: %ld, Start Time: %ld, End Time: %ld\n",m_mtPlayTo,
//      pSegStNode->m_pSegment,pSegStNode->m_fStartedPlay,pSegStNode->m_mtResolvedStart,pSegStNode->m_mtEndTime);
        if( !pSegStNode->m_fStartedPlay )
        {
            // check to see if this SegState should start playing.
            ASSERT( !(pSegStNode->m_dwPlaySegFlags & DMUS_SEGF_REFTIME ));
            if( pSegStNode->m_mtResolvedStart < m_mtPlayTo )
            {
                pSegStNode->m_fStartedPlay = TRUE;
                PrepSegToPlay(pSegStNode);
                // send a MUSICSTARTED notification if needed
                if(m_fMusicStopped)
                {
                    m_fMusicStopped = FALSE;
                    GenerateNotification( DMUS_NOTIFICATION_MUSICSTARTED, pSegStNode->m_mtResolvedStart, NULL );
                }
                // We don't want the music to start with a big BLURP in track
                // order, so we send a little dribble out on each track.
                mtMargin = m_mtPlayTo - pSegStNode->m_mtLastPlayed;
                if( mtMargin >= 50 )
                {
                    hr = pSegStNode->Play( 50 );
                    ProcessEarlyPMsgs();
                    // Once done processing all the early messages, make sure that the realtime
                    // thread wakes up and does whatever it needs to do. This ensures that the starting
                    // notes in a sequence get to the output port immediately.
                    if( m_hRealtime ) SetEvent( m_hRealtime );
                    mtMargin = m_mtPlayTo - pSegStNode->m_mtLastPlayed;
                    // Then, we send a larger chunk out on each track to catch up a little more...
                    if ((hr == S_OK) && ( mtMargin >= 200 ))
                    {
                        hr = pSegStNode->Play( 200 );
                        ProcessEarlyPMsgs();
                    }
                }
            }
            else
            {
                MusicToReferenceTime(pSegStNode->m_mtLastPlayed,&pSegStNode->m_rtLastPlayed);
            }
        }
        if( pSegStNode->m_fStartedPlay )
        {
            if( pSegStNode->m_mtStopTime && ( pSegStNode->m_mtStopTime < m_mtPlayTo ) )
            {
                mtMargin = pSegStNode->m_mtStopTime - pSegStNode->m_mtLastPlayed;
            }
            else
            {
                mtMargin = m_mtPlayTo - pSegStNode->m_mtLastPlayed;
            }
            while ((hr == S_OK) && (mtMargin > 0))
            {
                // Do not allow more than a quarter note's worth to be done at once.
                MUSIC_TIME mtRange = mtMargin;
                if (mtRange > DMUS_PPQ)
                {
                    mtRange = DMUS_PPQ;
                    mtMargin -= mtRange;
                }
                else
                {
                    mtMargin = 0;
                }
                hr = pSegStNode->Play( mtRange );
                ProcessEarlyPMsgs();
            }
        }
        if( (hr == DMUS_S_END) || ( pSegStNode->m_mtStopTime &&
                                  ( pSegStNode->m_mtStopTime <= pSegStNode->m_mtLastPlayed ) ) )
        {

            if( pSegStNode->m_mtStopTime && (pSegStNode->m_mtStopTime == pSegStNode->m_mtLastPlayed) )
            {
                pSegStNode->AbortPlay(pSegStNode->m_mtStopTime - 1, FALSE);
            }
            MUSIC_TIME mtEnd = pSegStNode->m_mtLastPlayed;
            if( pList == &m_SegStateQueues[SQ_PRI_PLAY] )
            {
                // move primary segments to PriPastList
                pList->Remove(pSegStNode);
                m_SegStateQueues[SQ_PRI_DONE].Insert(pSegStNode);
                pNext = pList->GetHead();
                if( pNext )
                {
                    if (!( pNext->m_dwPlaySegFlags & DMUS_SEGF_NOINVALIDATE ))
                    {
                        if (IsConQueue(dwList))
                        {
                            Invalidate( pNext->m_mtResolvedStart, 0 );
                        }
                    }
                }
                else    // No more primary segments, send DMUS_NOTIFICATION_MUSICALMOSTEND
                {
                    if (m_dwVersion >= 8)
                    {
                        MUSIC_TIME mtNow;
                        GetTime( NULL, &mtNow );
                        GenerateNotification( DMUS_NOTIFICATION_MUSICALMOSTEND, mtNow, pSegStNode );
                    }
                }
                ManageControllingTracks();
            }
            else if ( pList == &m_SegStateQueues[SQ_CON_PLAY] )
            {
                pList->Remove(pSegStNode );
                if (pSegStNode->m_mtStopTime == pSegStNode->m_mtLastPlayed)
                {
                    m_ShutDownQueue.Insert(pSegStNode);
                }
                else
                {
                    m_SegStateQueues[SQ_CON_DONE].Insert(pSegStNode);
                }
            }
            else
            {
                // move 2ndary segments to SecPastList
                pList->Remove(pSegStNode);
                m_SegStateQueues[SQ_SEC_DONE].Insert(pSegStNode);
            }
            // if there aren't any more segments to play, send a Music Stopped
            // notification
            if( (m_SegStateQueues[SQ_PRI_PLAY].IsEmpty() && m_SegStateQueues[SQ_SEC_PLAY].IsEmpty() &&
                m_SegStateQueues[SQ_PRI_WAIT].IsEmpty() && m_SegStateQueues[SQ_SEC_WAIT].IsEmpty() &&
                m_SegStateQueues[SQ_CON_PLAY].IsEmpty() && m_SegStateQueues[SQ_CON_WAIT].IsEmpty()))
            {
                m_fMusicStopped = TRUE;
                GenerateNotification( DMUS_NOTIFICATION_MUSICSTOPPED, mtEnd, NULL );
            }
        }
        m_fInTransportThread = FALSE;
    }
}

static DWORD WINAPI _Transport(LPVOID lpParam)
{
    if (SUCCEEDED(::CoInitialize(NULL)))
    {
        ((CPerformance *)lpParam)->Transport();
        ::CoUninitialize();
    }
    return 0;
}

// call Segment's play code on a periodic basis. This routine is in its
// own thread.
void CPerformance::Transport()
{
    srand((unsigned int)time(NULL));
    while (!m_fKillThread)
    {
        DWORD dwCount;
        CSegState*  pNode;
        CSegState*  pNext;
        CSegState*  pTempQueue = NULL;
        REFERENCE_TIME rtNow = GetTime();

        EnterCriticalSection(&m_SegmentCrSec);
        // Compute the time we should play all the segments to.
        REFERENCE_TIME rtPlayTo = rtNow + PREPARE_TIME;
        MUSIC_TIME mtAmount, mtResult, mtPlayTo;
        mtPlayTo = 0;
        ReferenceToMusicTime( rtPlayTo, &mtPlayTo );
        if (m_fTempoChanged)
        {
            // If there has been a tempo change to slower, any clock time tracks could
            // be delayed to long as the transport holds off sending out events. That's
            // okay for music time tracks, but bad news for clock time tracks. This
            // makes sure that the clock time tracks get a chance to spew.
            if (m_mtPlayTo >= mtPlayTo)
            {
                mtPlayTo = m_mtPlayTo + 10;
            }
            m_fTempoChanged = FALSE;
        }
        IncrementTempoMap();
        while (m_mtPlayTo < mtPlayTo)
        {
            BOOL fDirty = FALSE; // see below
            m_mtPlayTo = mtPlayTo; // Start out optimistic
            // We need to set play boundaries at the end of control segments.
            // The beginnings of control segments are handled inside the segment state code.
            pNode = m_SegStateQueues[SQ_PRI_PLAY].GetHead();
            if( pNode && pNode->m_fStartedPlay )
            {
                mtAmount = m_mtPlayTo - pNode->m_mtLastPlayed;
                pNode->CheckPlay( mtAmount, &mtResult );
                if( mtResult < mtAmount )
                {
                    m_mtPlayTo -= ( mtAmount - mtResult );
                    // don't need dirty flag when primary segment loops or ends normally (bug 30829)
                    // fDirty = TRUE; // see below
                }
            }
            // if a control segment ended prematurely, mtPlayTo will have a value besides 0
            // check for upcoming endings to control segments
            for( pNode = m_SegStateQueues[SQ_CON_PLAY].GetHead(); pNode; pNode = pNode->GetNext() )
            {
                if( pNode->m_fStartedPlay )
                {
                    if( pNode->m_mtStopTime && (m_mtPlayTo > pNode->m_mtStopTime) )
                    {
                        m_mtPlayTo = pNode->m_mtStopTime;
                        fDirty = TRUE; // see below
                    }
                    else
                    {
                        mtAmount = m_mtPlayTo - pNode->m_mtLastPlayed;
                        pNode->CheckPlay( mtAmount, &mtResult );
                        if( mtResult < mtAmount )
                        {
                            m_mtPlayTo -= ( mtAmount - mtResult );
                            fDirty = TRUE; // see below
                        }
                    }
                }
            }
            // play the primary segment
            PerformSegStNode( SQ_PRI_PLAY,m_SegStateQueues[SQ_PRI_PLAY].GetHead() );
            // check to see if the next primary segment in the queue is ready to play
            while( (pNode = m_SegStateQueues[SQ_PRI_PLAY].GetHead()) &&
                (pNext = pNode->GetNext()) &&
                ( pNext->m_mtResolvedStart <= pNode->m_mtLastPlayed ) )
            {
                // the next primary segment is indeed ready to begin playing.
                // save the old one in the primary past list so Tools can reference
                // it if they're looking for chord progressions and such.
                pNode->AbortPlay(pNext->m_mtResolvedStart-1,TRUE && (pNext->m_dwPlaySegFlags & DMUS_SEGF_NOINVALIDATE));
                m_SegStateQueues[SQ_PRI_DONE].Insert(m_SegStateQueues[SQ_PRI_PLAY].RemoveHead());
                ManageControllingTracks();
                // we need to flush primary events after the new start time
                if(!( m_SegStateQueues[SQ_PRI_PLAY].GetHead()->m_dwPlaySegFlags & (DMUS_SEGF_NOINVALIDATE | DMUS_SEGF_INVALIDATE_PRI) ))
                {
                    Invalidate( m_SegStateQueues[SQ_PRI_PLAY].GetHead()->m_mtResolvedStart, 0 );
                }
                // and play the new segment
                PerformSegStNode( SQ_PRI_PLAY,m_SegStateQueues[SQ_PRI_PLAY].GetHead());
            }
            // play the controlling segments
            pNode = m_SegStateQueues[SQ_CON_PLAY].GetHead();
            pNext = NULL;
            for(; pNode != NULL; pNode = pNext)
            {
                pNext = pNode->GetNext();
                PerformSegStNode(SQ_CON_PLAY,pNode );
            }
            // play the secondary segments
            pNode = m_SegStateQueues[SQ_SEC_PLAY].GetHead();
            pNext = NULL;
            for(; pNode != NULL; pNode = pNext)
            {
                pNext = pNode->GetNext();
                PerformSegStNode( SQ_SEC_PLAY,pNode );
            }

            // if we set fDirty above, it means that we truncated the playback of a control
            // segment because of a loop or end condition. Therefore, we want all segments
            // to set the DMUS_TRACKF_DIRTY flag on the next play cycle.
            if( fDirty )
            {
                for (dwCount = SQ_PRI_PLAY; dwCount <= SQ_SEC_PLAY; dwCount++)
                {
                    for( pNode = m_SegStateQueues[dwCount].GetHead(); pNode; pNode = pNode->GetNext() )
                    {
                        if( pNode->m_fStartedPlay )
                        {
                            pNode->m_dwPlayTrackFlags |= DMUS_TRACKF_DIRTY;
                        }
                    }
                }
                ManageControllingTracks();
            }
            m_mtTransported = m_mtPlayTo;

        }

        // check segments queued in ref-time to see if it's time for them to
        // play. Add some extra time just in case. We'll bet that a tempo pmsg won't come
        // in in the intervening 200 ms.
        REFERENCE_TIME rtLatency = GetLatencyWithPrePlay();
        for (dwCount = SQ_PRI_WAIT;dwCount <= SQ_SEC_WAIT; dwCount++)
        {
            while( m_SegStateQueues[dwCount].GetHead() )
            {
                if( m_SegStateQueues[dwCount].GetHead()->m_rtGivenStart > rtLatency + PREPARE_TIME + (200 * REF_PER_MIL) )
                {
                    // it's not yet time to handle this one
                    break;
                }
                if (dwCount == SQ_PRI_WAIT)
                {
                    QueuePrimarySegment( m_SegStateQueues[SQ_PRI_WAIT].RemoveHead());
                }
                else
                {
                    QueueSecondarySegment( m_SegStateQueues[dwCount].RemoveHead());
                }
            }
        }

        // Check to see if Segments in the done queues
        // can be released. They can be released if their
        // final play times are older than the current time.
        for (dwCount = SQ_PRI_DONE;dwCount <= SQ_SEC_DONE; dwCount++)
        {
            for (pNode = m_SegStateQueues[dwCount].GetHead();pNode;pNode = pNext)
            {
                pNext = pNode->GetNext();
                if( pNode->m_rtLastPlayed < rtNow - 1000 * REF_PER_MIL ) // Let it last an additional second
                {
                    m_SegStateQueues[dwCount].Remove(pNode);
                    pNode->ShutDown();
                }
            }
        }
        for (pNode = m_ShutDownQueue.GetHead();pNode;pNode = pNext)
        {
            pNext = pNode->GetNext();
            if( pNode->m_rtLastPlayed < rtNow - 1000 * REF_PER_MIL ) // Let it last an additional second
            {
                m_ShutDownQueue.Remove(pNode);
                pNode->ShutDown();
            }
        }
        LeaveCriticalSection(&m_SegmentCrSec);

        // check to see if there are old notifications that haven't been
        // retrieved by the application and need to be removed.
        EnterCriticalSection(&m_PipelineCrSec);
        while( m_NotificationQueue.GetHead() )
        {
            if( m_NotificationQueue.GetHead()->rtTime <
                (rtNow - m_rtNotificationDiscard) )
            {
                FreePMsg(m_NotificationQueue.Dequeue());
            }
            else
            {
                break;
            }
        }
        LeaveCriticalSection(&m_PipelineCrSec);
        if( m_hTransport )
        {
            WaitForSingleObject( m_hTransport, TRANSPORT_RES );
        }
        else
        {
            Sleep(TRANSPORT_RES);
        }
    }
    m_fKillThread = FALSE;
    if (m_fReleasedInTransport)
    {
        delete this;
    }
}

//////////////////////////////////////////////////////////////////////
// CPerformance::GetNextPMsg
/*
HRESULT | CPerformance | GetNextPMsg |
Returns messages from the queues in priority order.  Any message in the
OnTime queue that is scheduled to be played at the current time is
returned above any other.  Secondly, any message in the NearTime queue
that is scheduled to be played within the next NEARTIME ms is returned.
Lastly, any message in the Early queue is returned.

rvalue PRIV_PMSG* | The message, or NULL if there are no messages.
*/
inline PRIV_PMSG *CPerformance::GetNextPMsg()
{
#ifdef DBG_PROFILE
    DWORD dwDebugTime;
    dwDebugTime = timeGetTime();
#endif
    PRIV_PMSG* pEvent = NULL;

    EnterCriticalSection(&m_PipelineCrSec);
    if (m_OnTimeQueue.GetHead())
    {
        ASSERT( m_OnTimeQueue.GetHead()->dwFlags & DMUS_PMSGF_REFTIME );
        if ( m_OnTimeQueue.GetHead()->rtTime - GetTime() <= 0 )
        {
            pEvent = m_OnTimeQueue.Dequeue();
        }
    }
    if( !pEvent )
    {
        if (m_NearTimeQueue.GetHead())
        {
            ASSERT( m_NearTimeQueue.GetHead()->dwFlags & DMUS_PMSGF_REFTIME );
            if ( m_NearTimeQueue.GetHead()->rtTime < (m_rtQueuePosition + (m_rtBumperLength >> 1)))
            {
                pEvent = m_NearTimeQueue.Dequeue();
            }
        }
        if( !pEvent && !m_fInTransportThread)
        {
            if (m_EarlyQueue.GetHead())
            {
                pEvent = m_EarlyQueue.Dequeue();
            }
        }
    }
    LeaveCriticalSection(&m_PipelineCrSec);
#ifdef DBG_PROFILE
    dwDebugTime = timeGetTime() - dwDebugTime;
    if( dwDebugTime > 1 )
    {
        TraceI(5, "Hall, debugtime GetNextPMsg %u\n", dwDebugTime);
    }
#endif

    return pEvent;
}

/*  This next function is used just by the transport thread
    which can process messages in the early queue, but not
    the other types. This allows all the tools that process
    events right after they are generated by tracks to process
    the events right after they were generated, and in sequential
    order. This allows them to take a little longer, since it's
    not as time critical, and it's much more likely to ensure
    that they are in sequential order. If the realtime thread were
    allowed to process these, it would preempt and process them
    as soon as generated, so they would be processed in the order
    of the tracks. The m_fInTransportThread is set by the
    transport thread when it is generating and processing events
    and this disallows the realtime thread from processing
    early events (but not others.) At other times, the realtime
    thread is welcome to process early events.
*/

void CPerformance::ProcessEarlyPMsgs()
{
    PRIV_PMSG* pEvent;

    //  Exit if the thread is exiting.  If we don't test here
    //  we can actually loop forever because tools and queue more
    //  early PMSGs (the Echo tool does this)
    while (!m_fKillThread)
    {
        EnterCriticalSection(&m_PipelineCrSec);
        pEvent = m_EarlyQueue.Dequeue();
        LeaveCriticalSection(&m_PipelineCrSec);
        if (!pEvent) break; // Done?
        ASSERT( pEvent->pNext == NULL );
        if( !pEvent->pTool )
        {
            // this event doesn't have a Tool pointer, so stamp it with the
            // final output Tool.
            pEvent->pTool = (IDirectMusicTool*)this;
            AddRef();
            // Don't process it. Instead, send to neartime queue so
            // realtime thread will deal with it.
            pEvent->dwFlags &= ~(DMUS_PMSGF_TOOL_IMMEDIATE | DMUS_PMSGF_TOOL_QUEUE | DMUS_PMSGF_TOOL_ATTIME);
            pEvent->dwFlags |= DMUS_PMSGF_TOOL_QUEUE;
            SendPMsg( PRIV_TO_DMUS(pEvent) );
        }
        else
        {
            // before processing the event, set rtLast to the event's current time
            pEvent->rtLast = pEvent->rtTime;

            HRESULT hr = pEvent->pTool->ProcessPMsg( this, PRIV_TO_DMUS(pEvent) );
            if( hr != S_OK ) // S_OK means do nothing
            {
                if( hr == DMUS_S_REQUEUE )
                {
                    if(FAILED(SendPMsg( PRIV_TO_DMUS(pEvent) )))
                    {
                        FreePMsg(pEvent);
                    }
                }
                else // e.g. DMUS_S_FREE or error code
                {
                    FreePMsg( pEvent );
                }
            }
        }
    }
}

REFERENCE_TIME CPerformance::GetTime()
{
    REFERENCE_TIME rtTime;
    REFERENCE_TIME rtCurrent = 0;
    WORD    w;
    HRESULT hr = S_OK;

    EnterCriticalSection(&m_MainCrSec);
    if (m_pClock) hr = m_pClock->GetTime( &rtCurrent );
    if( !m_pClock || FAILED( hr ) || rtCurrent == 0 )
    {
        // this only gets called with machines that don't support m_pClock
        rtTime = timeGetTime();
        rtCurrent = rtTime * REF_PER_MIL; // 100 ns increments
        // take care of timeGetTime rolling over every 49 days
        if( rtCurrent < 0 )
        {
            m_wRollOverCount++;
        }
        for( w = 0; w < m_wRollOverCount; w++ )
        {
            rtCurrent += 4294967296;
        }
        // if rtCurrent is negative, it means we've rolled over rtCurrent. Ignore
        // this case for now, as it will be quite uncommon.
    }
    LeaveCriticalSection(&m_MainCrSec);

    return rtCurrent;
}

REFERENCE_TIME CPerformance::GetLatency(void)
{
    DWORD dwIndex;
    REFERENCE_TIME rtLatency = 0;
    REFERENCE_TIME rtTemp;

#ifdef DBG_PROFILE
    DWORD dwDebugTime;
    dwDebugTime = timeGetTime();
#endif
    EnterCriticalSection(&m_PChannelInfoCrSec);
    if( m_pPortTable )
    {
        for( dwIndex = 0; dwIndex < m_dwNumPorts; dwIndex++ )
        {
            if( m_pPortTable[dwIndex].pLatencyClock )
            {
                if( SUCCEEDED( m_pPortTable[dwIndex].pLatencyClock->GetTime( &rtTemp )))
                {
                    if( rtTemp > rtLatency )
                        rtLatency = rtTemp;
                }
            }
            else if( m_pPortTable[dwIndex].pPort )
            {
                if( SUCCEEDED( m_pPortTable[dwIndex].pPort->GetLatencyClock( &m_pPortTable[dwIndex].pLatencyClock )))
                {
                    if( SUCCEEDED( m_pPortTable[dwIndex].pLatencyClock->GetTime( &rtTemp )))
                    {
                        if( rtTemp > rtLatency )
                            rtLatency = rtTemp;
                    }
                }
            }
        }
    }
    LeaveCriticalSection(&m_PChannelInfoCrSec);
    if( 0 == rtLatency )
    {
        rtLatency = GetTime();
    }
#ifdef DBG_PROFILE
    dwDebugTime = timeGetTime() - dwDebugTime;
    if( dwDebugTime > 1 )
    {
        TraceI(5, "Hall, debugtime GetLatency %u\n", dwDebugTime);
    }
#endif
    if (m_rtEarliestStartTime > rtLatency)
    {
        rtLatency = m_rtEarliestStartTime;
    }
    return rtLatency;
}

// return the most desireable Segment latency, based on which ports this
// segment plays on.
REFERENCE_TIME CPerformance::GetBestSegLatency( CSegState* pSeg )
{
    // If we're using audiopaths, the code below doesn't work because it doesn't
    // take converting pchannels into account. So, just use the worse case
    // latency. 99% of the time, there is only one port, so this results
    // in just a performance enhancement.
    if (m_dwAudioPathMode == 2)
    {
        return GetLatency();
    }
    DWORD dwIndex;
    REFERENCE_TIME rtLatency = 0;
    REFERENCE_TIME rtTemp;
    BOOL* pafIndexUsed = NULL;
    DWORD dwCount;

    if( m_dwNumPorts == 1 )
    {
        return GetLatency();
    }
    pafIndexUsed = new BOOL[m_dwNumPorts];
    if( NULL == pafIndexUsed )
    {
        return GetLatency();
    }
    for( dwCount = 0; dwCount < m_dwNumPorts; dwCount++ )
    {
        pafIndexUsed[dwCount] = FALSE;
    }
    DWORD dwNumPChannels, dwGroup, dwMChannel;
    DWORD* paPChannels;
    pSeg->m_pSegment->GetPChannels( &dwNumPChannels, &paPChannels );
    for( dwCount = 0; dwCount < dwNumPChannels; dwCount++ )
    {
        if( SUCCEEDED( PChannelIndex( paPChannels[dwCount],
            &dwIndex, &dwGroup, &dwMChannel )))
        {
            pafIndexUsed[dwIndex] = TRUE;
        }
    }
    for( dwCount = 0; dwCount < m_dwNumPorts; dwCount++ )
    {
        if( pafIndexUsed[dwCount] )
            break;
    }
    if( dwCount >= m_dwNumPorts )
    {
        delete [] pafIndexUsed;
        return GetLatency();
    }
    EnterCriticalSection(&m_PChannelInfoCrSec);
    for( dwIndex = 0; dwIndex < m_dwNumPorts; dwIndex++ )
    {
        if( pafIndexUsed[dwIndex] )
        {
            if( m_pPortTable[dwIndex].pLatencyClock )
            {
                if( SUCCEEDED( m_pPortTable[dwIndex].pLatencyClock->GetTime( &rtTemp )))
                {
                    if( rtTemp > rtLatency )
                        rtLatency = rtTemp;
                }
            }
            else if( m_pPortTable[dwIndex].pPort )
            {
                if( SUCCEEDED( m_pPortTable[dwIndex].pPort->GetLatencyClock( &m_pPortTable[dwIndex].pLatencyClock )))
                {
                    if( SUCCEEDED( m_pPortTable[dwIndex].pLatencyClock->GetTime( &rtTemp )))
                    {
                        if( rtTemp > rtLatency )
                            rtLatency = rtTemp;
                    }
                }
            }
        }
    }
    LeaveCriticalSection(&m_PChannelInfoCrSec);
    if( 0 == rtLatency )
    {
        rtLatency = GetLatency();
    }
    delete [] pafIndexUsed;
    return rtLatency;
}

/*  Called from either QueuePrimarySegment or QueueSecondarySegment,
    this calculates the appropriate boundary time to start the segment
    playback. Most of the logic takes care of the new DMUS_SEGF_ALIGN
    capabilities.
*/


void CPerformance::CalculateSegmentStartTime( CSegState* pSeg )
{
    BOOL fNoValidStart = TRUE;
    if (pSeg->m_dwPlaySegFlags & DMUS_SEGF_ALIGN)
    {
        // If the ALIGN flag is set, see if we can align with the requested resolution,
        // but switch to the new segment at an earlier point, as defined by
        // a "valid start" point in the new segment.
        DMUS_VALID_START_PARAM ValidStart;    // Used to read start parameter from segment.
        MUSIC_TIME mtIntervalSize = 0;      // Quantization value.
        MUSIC_TIME mtTimeNow = (MUSIC_TIME)pSeg->m_rtGivenStart; // The earliest time this can start.
        // Call resolve time to get the last quantized interval that precedes mtTimeNow.
        MUSIC_TIME mtStartTime = ResolveTime( mtTimeNow, pSeg->m_dwPlaySegFlags, &mtIntervalSize );
        // StartTime actually shows the next time after now, so subtract the interval time to get the previous position.
        mtStartTime -= mtIntervalSize;
        // If the segment was supposed to start after the very beginning, quantize it.
        if (mtIntervalSize && pSeg->m_mtStartPoint)
        {
            pSeg->m_mtStartPoint = ((pSeg->m_mtStartPoint + (mtIntervalSize >> 1))
                / mtIntervalSize) * mtIntervalSize;
            // If this ends up being longer than the segment, do we need to drop back?
        }
        // Now, get the next start point after the point in the segment that
        // corresponds with mtTimeNow, adjusted for the startpoint.
        if (SUCCEEDED(pSeg->m_pSegment->GetParam( GUID_Valid_Start_Time,-1,0,
            pSeg->m_mtStartPoint + mtTimeNow - mtStartTime,NULL,(void *) &ValidStart)))
        {
            // If the valid start point is within the range, we can cut in at the start point.
            if ((mtTimeNow - mtStartTime + ValidStart.mtTime) < (mtIntervalSize + pSeg->m_mtStartPoint))
            {
                pSeg->m_mtResolvedStart = mtTimeNow + ValidStart.mtTime;
                pSeg->m_mtStartPoint += mtTimeNow - mtStartTime + ValidStart.mtTime;
                fNoValidStart = FALSE;
            }
        }
        if (fNoValidStart)
        {
            // Couldn't find a valid start point. Was DMUS_SEGF_VALID_START_XXX set so we can override?
            if (pSeg->m_dwPlaySegFlags &
                (DMUS_SEGF_VALID_START_MEASURE | DMUS_SEGF_VALID_START_BEAT | DMUS_SEGF_VALID_START_GRID | DMUS_SEGF_VALID_START_TICK))
            {
                MUSIC_TIME mtOverrideTime;
                // Depending on the flag, we need to get the appropriate interval resolution.
                if (pSeg->m_dwPlaySegFlags & DMUS_SEGF_VALID_START_MEASURE)
                {
                    mtOverrideTime = ResolveTime( mtTimeNow, DMUS_SEGF_MEASURE, 0 );
                }
                else if (pSeg->m_dwPlaySegFlags & DMUS_SEGF_VALID_START_BEAT)
                {
                    mtOverrideTime = ResolveTime( mtTimeNow, DMUS_SEGF_BEAT, 0 );
                }
                else if (pSeg->m_dwPlaySegFlags & DMUS_SEGF_VALID_START_GRID)
                {
                    mtOverrideTime = ResolveTime( mtTimeNow, DMUS_SEGF_GRID, 0 );
                }
                else
                {
                    mtOverrideTime = mtTimeNow;
                }
                // If the valid start point is within the range, we can cut in at the start point.
                if ((mtOverrideTime - mtTimeNow) < (mtIntervalSize + pSeg->m_mtStartPoint))
                {
                    pSeg->m_mtResolvedStart = mtOverrideTime;
                    if ((mtOverrideTime - mtStartTime) >= mtIntervalSize)
                    {
                        mtOverrideTime -= mtIntervalSize;
                    }
/*Trace(0,"Startpoint %ld plus OverrideTime %ld - StartTime %ld = %ld\n",
      pSeg->m_mtStartPoint, mtOverrideTime - mtSegmentTime, mtStartTime - mtSegmentTime,
        pSeg->m_mtStartPoint + mtOverrideTime - mtStartTime);*/
                    pSeg->m_mtStartPoint += mtOverrideTime - mtStartTime;
                    fNoValidStart = FALSE;
                }
            }
        }
    }
    if (fNoValidStart)
    {
        pSeg->m_mtResolvedStart = ResolveTime( (MUSIC_TIME)pSeg->m_rtGivenStart,
            pSeg->m_dwPlaySegFlags, NULL );
    }
    else
    {
        // If we succeeded in finding a place to switch over, make sure it isn't deep inside
        // a loop. This is specifically a problem when syncing to segment and switching inside
        // or after a loop.
        while (pSeg->m_dwRepeats && (pSeg->m_mtStartPoint >= pSeg->m_mtLoopEnd))
        {
            pSeg->m_dwRepeats--;
            pSeg->m_mtStartPoint -= (pSeg->m_mtLoopEnd - pSeg->m_mtLoopStart);
        }
        // Since we were decrementing the repeats, we need to also decrement the repeats left.
        pSeg->m_dwRepeatsLeft = pSeg->m_dwRepeats;
        // Finally, if the startpoint is after the end of the segment, cut it back to the end of the
        // segment. This will cause it to play for time 0 and, if this is a transition segment, whatever
        // should play after will play immediately.
        if (pSeg->m_mtStartPoint > pSeg->m_mtLength)
        {
            pSeg->m_mtStartPoint = pSeg->m_mtLength;
        }
    }
    pSeg->m_mtOffset = pSeg->m_mtResolvedStart;
    pSeg->m_mtLastPlayed = pSeg->m_mtResolvedStart;
}

// this function should only be called from within a SegmentCrSec
// critical section!
void CPerformance::QueuePrimarySegment( CSegState* pSeg )
{
    CSegState* pTemp;
    BOOL fInCrSec = TRUE;
    BOOL fNotDone = TRUE;
    EnterCriticalSection(&m_PipelineCrSec);
    pSeg->m_dwPlayTrackFlags |= DMUS_TRACKF_DIRTY;
    if( pSeg->m_dwPlaySegFlags & DMUS_SEGF_QUEUE )
    {
        MUSIC_TIME mtStart = 0;

        pTemp = m_SegStateQueues[SQ_PRI_PLAY].GetTail();
        if( pTemp )
        {
            mtStart = pTemp->GetEndTime( pTemp->m_mtResolvedStart );
        }
        else
        {
            pTemp = m_SegStateQueues[SQ_PRI_DONE].GetTail();
            if( pTemp )
            {
                mtStart = pTemp->m_mtLastPlayed;
            }
        }
        pSeg->m_dwPlaySegFlags &= ~DMUS_SEGF_QUEUE;
        if( NULL == pTemp )
        {
            // if there's nothing in the queue, this means play it now
            if( pSeg->m_dwPlaySegFlags & DMUS_SEGF_AFTERPREPARETIME )
            {
                // we want to queue this at the last transported time,
                // so we don't need to do an invalidate
                if( pSeg->m_dwPlaySegFlags & DMUS_SEGF_REFTIME )
                {
                    REFERENCE_TIME rtTrans;
                    MusicToReferenceTime( m_mtTransported, &rtTrans );
                    if( pSeg->m_rtGivenStart < rtTrans )
                    {
                        pSeg->m_dwPlaySegFlags &= ~DMUS_SEGF_REFTIME;
                        pSeg->m_rtGivenStart = m_mtTransported;
                    }
                }
                else
                {
                    if( pSeg->m_rtGivenStart < m_mtTransported )
                    {
                        pSeg->m_rtGivenStart = m_mtTransported;
                    }
                }
            }
            else
            {
                // This will be changed to Queue time below
                pSeg->m_rtGivenStart = 0;
            }
        }
        else
        {
            REFERENCE_TIME rtQueue;

            // otherwise, time stamp it with the time corresponding to
            // the end time of all segments currently in the queue.
            pSeg->m_mtResolvedStart = mtStart;
            // make sure the resolved start time isn't before the latency
            GetQueueTime(&rtQueue);
            ReferenceToMusicTime( rtQueue, &mtStart );
            if( pSeg->m_mtResolvedStart < mtStart )
            {
                pSeg->m_mtResolvedStart = 0; // below code will take care of this case
            }
            else
            {
                pSeg->m_dwPlaySegFlags &= ~DMUS_SEGF_REFTIME;
                pSeg->m_mtOffset = pSeg->m_mtResolvedStart;
                m_SegStateQueues[SQ_PRI_PLAY].Insert(pSeg);
                TraceI(2, "dmperf: queueing primary seg/DMUS_SEGF_QUEUE. Prev time=%ld, this=%ld\n",
                    pTemp->m_mtResolvedStart, pSeg->m_mtResolvedStart);
                fNotDone = FALSE;
                PrepSegToPlay(pSeg, true);
            }
        }
    }
    if( fNotDone && (pSeg->m_rtGivenStart == 0) )
    {
        // if the given start time is 0, it means play now.
        MUSIC_TIME mtStart;
        REFERENCE_TIME rtStart;

        GetQueueTime( &rtStart );
        ReferenceToMusicTime( rtStart, &mtStart );
        pSeg->m_dwPlaySegFlags &= ~DMUS_SEGF_REFTIME;
        pSeg->m_rtGivenStart = mtStart;
        // we definitely want to get rid of all segments following
        // the currently playing segment
        if( m_SegStateQueues[SQ_PRI_PLAY].GetHead() )
        {
            while( pTemp = m_SegStateQueues[SQ_PRI_PLAY].GetHead()->GetNext() )
            {
                m_SegStateQueues[SQ_PRI_PLAY].Remove(pTemp);
                pTemp->AbortPlay(mtStart,FALSE);
                m_ShutDownQueue.Insert(pTemp);
            }
        }
    }
    if( fNotDone && pSeg->m_dwPlaySegFlags & DMUS_SEGF_REFTIME )
    {
        // rtStartTime is in RefTime units.
        // We can convert this to Music Time immediately if either there
        // is no currently playing Primary Segment, or the conversion
        // falls within the time that has already played. If the time
        // falls within PREPARE_TIME, we need to get this Segment
        // playing right away.
        REFERENCE_TIME rtNow = m_rtQueuePosition;
        MUSIC_TIME mtTime;
        if( m_SegStateQueues[SQ_PRI_PLAY].IsEmpty() || ( pSeg->m_rtGivenStart <= rtNow ) )
        {
            ReferenceToMusicTime( pSeg->m_rtGivenStart, &mtTime );
            pSeg->m_dwPlaySegFlags &= ~( DMUS_SEGF_REFTIME );
            pSeg->m_rtGivenStart = mtTime;
            // let the block of code below that handles music time
            // deal with it from here on
        }
        else
        {
            // Otherwise, we must wait until rtStartTime
            // has been performed in order to convert to music time, because
            // we require the tempo map at that time to do the conversion.
            // This will be handled by the Transport code.
            m_SegStateQueues[SQ_PRI_WAIT].Insert(pSeg);
            fNotDone = FALSE; // prevents the next block of code from operating on
                        // this Segment.
        }
    }
    if( fNotDone ) // music time
    {
        // if we're in music time units, we can queue this segment in the
        // main queue, in time order. If this segment's music time is less
        // than the start time of other segments in the queue, all of those
        // segments are removed and discarded. Also, segments that are in
        // the wait queue as RefTime are discarded.

        ASSERT( !(pSeg->m_dwPlaySegFlags & DMUS_SEGF_REFTIME )); // m_rtGivenStart must be in music time
        CalculateSegmentStartTime( pSeg );
        while( (pTemp = m_SegStateQueues[SQ_PRI_WAIT].RemoveHead()) )
        {
            pTemp->AbortPlay(pSeg->m_mtResolvedStart,FALSE);
            m_ShutDownQueue.Insert(pTemp);
        }
        if( pTemp = m_SegStateQueues[SQ_PRI_PLAY].GetHead() )
        {
            if( pSeg->m_mtResolvedStart > pTemp->m_mtResolvedStart )
            {
                while( pTemp->GetNext() )
                {
                    if( pTemp->GetNext()->m_mtResolvedStart >= pSeg->m_mtResolvedStart )
                    {
                        break;
                    }
                    pTemp = pTemp->GetNext();
                }
                pSeg->SetNext(pTemp->GetNext());
                pTemp->SetNext(pSeg);
                while( pTemp = pSeg->GetNext() )
                {
                    // delete the remaining pSegs after this one
                    pSeg->SetNext(pTemp->GetNext());
                    pTemp->AbortPlay(pSeg->m_mtResolvedStart,FALSE);
                    m_ShutDownQueue.Insert(pTemp);
                }
            }
            else
            {
                if( !pTemp->m_fStartedPlay )
                {
                    // blow away the entire queue
                    while( m_SegStateQueues[SQ_PRI_PLAY].GetHead() )
                    {
                        pTemp = m_SegStateQueues[SQ_PRI_PLAY].RemoveHead();
                        pTemp->AbortPlay(pSeg->m_mtResolvedStart,FALSE);
                        m_ShutDownQueue.Insert(pTemp);
                    }
                    m_SegStateQueues[SQ_PRI_PLAY].AddHead(pSeg);
                    // give this a chance to start performing if it's near
                    // enough to time
                    if( fInCrSec )
                    {
                        LeaveCriticalSection(&m_PipelineCrSec);
                        fInCrSec = FALSE;
                    }
                    SyncTimeSig( pSeg );
                    ManageControllingTracks();
                    PerformSegStNode( SQ_PRI_PLAY,pSeg);
                }
                else
                {
                    // else, place this segment after the current one
                    // and count on the routine below to take care of dequeing
                    // the current one, because in this case m_mtLastPlayed
                    // must be greater than m_mtResolvedStart.
                    if ( m_SegStateQueues[SQ_PRI_PLAY].GetHead()->m_mtLastPlayed <=
                        m_SegStateQueues[SQ_PRI_PLAY].GetHead()->m_mtResolvedStart )
                    {
                        TraceI(0,"Current Primary segment has not started playing.\n");
                    }
                    m_SegStateQueues[SQ_PRI_PLAY].AddHead(pSeg);
                    MUSIC_TIME mtTime = pSeg->m_mtResolvedStart;
                    while( pTemp = pSeg->GetNext() )
                    {
                        pTemp->AbortPlay( mtTime, TRUE && (pSeg->m_dwPlaySegFlags & DMUS_SEGF_NOINVALIDATE) );
                        // delete the remaining pSegs after this one
                        pSeg->SetNext(pTemp->GetNext());
                        m_ShutDownQueue.Insert(pTemp);
                    }
                }
            }
            // m_pPriSegQueue could have become NULL from the PerformSegStNode call above.
            if( m_SegStateQueues[SQ_PRI_PLAY].GetHead() && (pSeg != m_SegStateQueues[SQ_PRI_PLAY].GetHead()) )
            {
                CSegState *pCurrentSeg = m_SegStateQueues[SQ_PRI_PLAY].GetHead();
                if( pCurrentSeg->m_fStartedPlay &&
                    ( pSeg->m_mtResolvedStart <= pCurrentSeg->m_mtLastPlayed ))
                {
                    // If Playsegment is recursively called by the end of a previous segment in a song, don't abort.
                    if (!pCurrentSeg->m_fInPlay || !pCurrentSeg->m_fSongMode)
                    {
                        // the new segment wants to play on top of stuff that's
                        // already been transported by the current primary segment.
                        pCurrentSeg->AbortPlay(pSeg->m_mtResolvedStart-1,TRUE && (pSeg->m_dwPlaySegFlags & DMUS_SEGF_NOINVALIDATE));
                        m_SegStateQueues[SQ_PRI_DONE].Insert(m_SegStateQueues[SQ_PRI_PLAY].RemoveHead());
                        // make sure none of the last played times in the past list
                        // are past the resolved start
                        for( CSegState* pSegTemp = m_SegStateQueues[SQ_PRI_DONE].GetHead();
                            pSegTemp; pSegTemp = pSegTemp->GetNext() )
                        {
                            if( pSegTemp->m_mtLastPlayed > pSeg->m_mtResolvedStart )
                            {
                                pSegTemp->m_mtLastPlayed = pSeg->m_mtResolvedStart;
                            }
                        }
                        if( !( pSeg->m_dwPlaySegFlags & (DMUS_SEGF_NOINVALIDATE | DMUS_SEGF_INVALIDATE_PRI) ) )
                        {
                            // if we set the PREPARE flag it means we specifically
                            // don't want to invalidate
                            Invalidate( pSeg->m_mtResolvedStart, pSeg->m_dwPlaySegFlags );
                        }
                        else if ( (pSeg->m_dwPlaySegFlags & DMUS_SEGF_INVALIDATE_PRI) &&
                                 !(pSeg->m_dwPlaySegFlags & DMUS_SEGF_NOINVALIDATE) )
                        {
                            pCurrentSeg->Flush(pSeg->m_mtResolvedStart);
                        }
                        ASSERT( m_SegStateQueues[SQ_PRI_PLAY].GetHead() == pSeg ); // this should be the case
                        if( fInCrSec )
                        {
                            LeaveCriticalSection(&m_PipelineCrSec);
                            fInCrSec = FALSE;
                        }
                        SyncTimeSig( pSeg );
                        ManageControllingTracks();
                        PerformSegStNode( SQ_PRI_PLAY,m_SegStateQueues[SQ_PRI_PLAY].GetHead() );
                    }
                }
                else
                {
                    if( !( pSeg->m_dwPlaySegFlags & (DMUS_SEGF_NOINVALIDATE | DMUS_SEGF_INVALIDATE_PRI) ))
                    {
                        Invalidate( pSeg->m_mtResolvedStart, pSeg->m_dwPlaySegFlags );
                    }
                    else if ( (pSeg->m_dwPlaySegFlags & DMUS_SEGF_INVALIDATE_PRI) &&
                             !(pSeg->m_dwPlaySegFlags & DMUS_SEGF_NOINVALIDATE) )
                    {
                        pCurrentSeg->Flush(pSeg->m_mtResolvedStart);
                    }
                }
            }
        }
        else
        {
            m_SegStateQueues[SQ_PRI_PLAY].AddHead(pSeg);
            // give this a chance to start performing if it's near
            // enough to time
            if( fInCrSec )
            {
                LeaveCriticalSection(&m_PipelineCrSec);
                fInCrSec = FALSE;
            }
            //DWORD dwDebugTime = timeGetTime();
            SyncTimeSig( pSeg );
            //DWORD dwDebugTime2 = timeGetTime();
            //Trace(0, "perf, debugtime SyncTimeSig %u\n", dwDebugTime2 - dwDebugTime);

            ManageControllingTracks();
            //dwDebugTime = timeGetTime();
            //Trace(0, "perf, debugtime ManageControllingTracks %u\n", dwDebugTime - dwDebugTime2);

            PerformSegStNode( SQ_PRI_PLAY,pSeg );
            //dwDebugTime2 = timeGetTime();
            //Trace(0, "perf, debugtime PerformSegStNode %u\n", dwDebugTime2 - dwDebugTime);
        }
    }
    if( fInCrSec )
    {
        LeaveCriticalSection(&m_PipelineCrSec);
    }
}

// this function should only be called from within a SegmentCrSec
// critical section!
void CPerformance::QueueSecondarySegment( CSegState* pSeg)
{
    BOOL fInCrSec = FALSE;
    BOOL fNotDone = TRUE;

    if( pSeg->m_dwPlaySegFlags & DMUS_SEGF_CONTROL )
    {
        EnterCriticalSection(&m_PipelineCrSec);
        fInCrSec = TRUE;
    }
    pSeg->m_dwPlaySegFlags &= ~DMUS_SEGF_QUEUE; // not legal for 2ndary segs.
    if( pSeg->m_rtGivenStart == 0 )
    {
        MUSIC_TIME mtStart;

        if( pSeg->m_dwPlaySegFlags & DMUS_SEGF_CONTROL )
        {
            REFERENCE_TIME rtStart;
            GetQueueTime( &rtStart ); // need queue time because control segments cause invalidations
            ReferenceToMusicTime( rtStart, &mtStart );
        }
        else
        {
            ReferenceToMusicTime( GetBestSegLatency(pSeg), &mtStart );
        }
        pSeg->m_dwPlaySegFlags &= ~DMUS_SEGF_REFTIME;
        pSeg->m_rtGivenStart = mtStart;
    }

    if( pSeg->m_dwPlaySegFlags & DMUS_SEGF_REFTIME )
    {
        // rtStartTime is in RefTime units.
        // We can convert this to Music Time immediately if either there
        // is no currently playing Primary Segment, or the conversion
        // falls within the time that has already played. If the time
        // falls within PREPARE_TIME, we need to get this Segment
        // playing right away.
        REFERENCE_TIME rtNow;
        if( pSeg->m_dwPlaySegFlags & DMUS_SEGF_CONTROL )
        {
            GetQueueTime( &rtNow ); // need queue time because control segments cause invalidations
        }
        else
        {
            rtNow = GetBestSegLatency(pSeg);
        }
        MUSIC_TIME mtTime;
        if( pSeg->m_rtGivenStart <= rtNow )
        {
            ReferenceToMusicTime( rtNow, &mtTime );
            pSeg->m_dwPlaySegFlags &= ~( DMUS_SEGF_REFTIME );
            pSeg->m_rtGivenStart = mtTime;
            // let the block of code below that handles music time
            // deal with it from here on
        }
        else if( m_SegStateQueues[SQ_PRI_PLAY].IsEmpty() )
        {
            ReferenceToMusicTime( pSeg->m_rtGivenStart, &mtTime );
            pSeg->m_dwPlaySegFlags &= ~( DMUS_SEGF_REFTIME );
            pSeg->m_rtGivenStart = mtTime;
        }
        else
        {
            // Otherwise, we must wait until rtStartTime
            // has been performed in order to convert to music time, because
            // we require the tempo map at that time to do the conversion.
            // This will be handled by the Transport code.
            m_SegStateQueues[SQ_SEC_WAIT].Insert(pSeg);
            fNotDone = FALSE; // prevents the next block of code from operating on
                        // this Segment.
        }
    }

    if( fNotDone ) // music time
    {
        // if we're in music time units, we can queue this segment in the
        // main queue, in time order. If this segment's music time is less
        // than the start time of other segments in the queue, all of those
        // segments are removed and discarded.
        ASSERT( !(pSeg->m_dwPlaySegFlags & DMUS_SEGF_REFTIME )); // m_m_rtGivenStart must be in music time
        CalculateSegmentStartTime( pSeg );
        TraceI(2,"Queuing 2ndary seg time %ld\n",pSeg->m_mtResolvedStart);
        if( pSeg->m_dwPlaySegFlags & DMUS_SEGF_CONTROL)
        {
            m_SegStateQueues[SQ_CON_PLAY].Insert( pSeg );
            // If this is a control segment, we need to do an invalidate.
            if(!(pSeg->m_dwPlaySegFlags & DMUS_SEGF_NOINVALIDATE) )
            {
                ManageControllingTracks();
                Invalidate( pSeg->m_mtResolvedStart, 0 );
            }
        }
        else
        {
            m_SegStateQueues[SQ_SEC_PLAY].Insert( pSeg );
        }
        // give this a chance to start performing if it's near
        // enough to time
        if( fInCrSec )
        {
            LeaveCriticalSection(&m_PipelineCrSec);
            fInCrSec = FALSE;
        }
        // play the secondary segments
        CSegState *pNode = m_SegStateQueues[SQ_SEC_PLAY].GetHead();
        CSegState *pNext;
        for(; pNode != NULL; pNode = pNext)
        {
            pNext = pNode->GetNext();
            PerformSegStNode( SQ_SEC_PLAY,pNode );
        }
        // play the controlling segments
        pNode = m_SegStateQueues[SQ_CON_PLAY].GetHead();
        for(; pNode != NULL; pNode = pNext)
        {
            pNext = pNode->GetNext();
            PerformSegStNode( SQ_CON_PLAY,pNode );
        }
    }
    if( fInCrSec )
    {
        LeaveCriticalSection(&m_PipelineCrSec);
    }
}

/*  If a segment is controlling, this establishes which tracks in the currently playing
    primary segment are disabled.
    We store temporary information in each playing track's m_dwInternalFlags, which is not used
    otherwise in segmentstates.

    Four scenarios, each for play and notify:
    1) An officially enabled track is currently enabled and gets disabled.
    2) An officially enabled track is currently disabled and continues to be disabled.
    3) An officially enabled track is currently disabled and gets enabled.
    4) An officially disabled track is left disabled. If none of the CONTROL_ flags are set and the track is disabled,
       set the _WAS_DISABLED flag, which also indicates that this should be left alone.

    This should get called every time a primary or secondary segment starts or stop, so it
    can recalculate the behavior of all tracks in the primary segment.
*/

void CPerformance::ManageControllingTracks()

{
    EnterCriticalSection(&m_SegmentCrSec);
    CSegState* pSegNode;
    // First, prepare all tracks in the primary segment, putting them back to normal.
    // so they are ready to be reset by the controlling tracks.
    // To do this, check for WAS_ENABLED or WAS_DISABLED and set the appropriate flags in m_dwFlags.
    // Else, if these weren't set, then it's time to set them, since this is the first pass through this segment.
    for( pSegNode = m_SegStateQueues[SQ_PRI_PLAY].GetHead(); pSegNode; pSegNode = pSegNode->GetNext() )
    {
        EnterCriticalSection(&pSegNode->m_CriticalSection);
        CTrack *pTrack = pSegNode->m_TrackList.GetHead();
        for (;pTrack;pTrack = pTrack->GetNext())
        {
            if (pTrack->m_dwInternalFlags) // This has been touched before.
            {
                // First transfer and reset the is disabled flags.
                if (pTrack->m_dwInternalFlags & CONTROL_PLAY_IS_DISABLED)
                {
                    pTrack->m_dwInternalFlags |= CONTROL_PLAY_WAS_DISABLED;
                }
                pTrack->m_dwInternalFlags &= ~(CONTROL_PLAY_IS_DISABLED | CONTROL_NTFY_IS_DISABLED);
                // Then, set the play flags based on the original state.
                if (pTrack->m_dwInternalFlags & CONTROL_PLAY_DEFAULT_ENABLED)
                {
                    pTrack->m_dwFlags |= DMUS_TRACKCONFIG_PLAY_ENABLED;
                }
                if (pTrack->m_dwInternalFlags & CONTROL_NTFY_DEFAULT_ENABLED)
                {
                    pTrack->m_dwFlags |= DMUS_TRACKCONFIG_NOTIFICATION_ENABLED;
                }
            }
            else
            {
                // Since this has never been touched before, set the flags so we can know what to return to.
                if (pTrack->m_dwFlags & DMUS_TRACKCONFIG_PLAY_ENABLED)
                {
                    pTrack->m_dwInternalFlags = CONTROL_PLAY_DEFAULT_ENABLED;
                }
                else
                {
                    pTrack->m_dwInternalFlags = CONTROL_PLAY_DEFAULT_DISABLED;
                }
                if (pTrack->m_dwFlags & DMUS_TRACKCONFIG_NOTIFICATION_ENABLED)
                {
                    pTrack->m_dwInternalFlags |= CONTROL_NTFY_DEFAULT_ENABLED;
                }
                else
                {
                    pTrack->m_dwInternalFlags |= CONTROL_NTFY_DEFAULT_DISABLED;
                }
            }
        }
        LeaveCriticalSection(&pSegNode->m_CriticalSection);
    }
    CSegState* pControlNode;
    // Now, go through all the controlling segments and, for each controlling track that matches
    // a primary segment track, clear the enable flags on the segment track.
    for( pControlNode = m_SegStateQueues[SQ_CON_PLAY].GetHead(); pControlNode; pControlNode = pControlNode->GetNext() )
    {
        EnterCriticalSection(&pControlNode->m_CriticalSection);
        CTrack *pTrack = pControlNode->m_TrackList.GetHead();
        for (;pTrack;pTrack = pTrack->GetNext())
        {
            // If the track has never been overridden, the internal flags for IS_DISABLED should be clear.
            // If the track is currently overridden, the internal flags should be CONTROL_PLAY_IS_DISABLED and/or
            // CONTROL_NTFY_IS_DISABLED
            if (pTrack->m_dwFlags & (DMUS_TRACKCONFIG_CONTROL_PLAY | DMUS_TRACKCONFIG_CONTROL_NOTIFICATION)) // This overrides playback and/or notification.
            {
                for( pSegNode = m_SegStateQueues[SQ_PRI_PLAY].GetHead(); pSegNode; pSegNode = pSegNode->GetNext() )
                {
                    EnterCriticalSection(&pSegNode->m_CriticalSection);
                    CTrack *pPrimaryTrack = pSegNode->m_TrackList.GetHead();
                    for (;pPrimaryTrack;pPrimaryTrack = pPrimaryTrack->GetNext())
                    {
                        // A track matches if it has the same class id and overlapping group bits.
                        if ((pPrimaryTrack->m_guidClassID == pTrack->m_guidClassID) &&
                            (pPrimaryTrack->m_dwGroupBits & pTrack->m_dwGroupBits))
                        {
                            if ((pTrack->m_dwFlags & DMUS_TRACKCONFIG_CONTROL_PLAY) &&
                                (pPrimaryTrack->m_dwFlags & DMUS_TRACKCONFIG_PLAY_ENABLED))
                            {
                                pPrimaryTrack->m_dwFlags &= ~DMUS_TRACKCONFIG_PLAY_ENABLED;
                                pPrimaryTrack->m_dwInternalFlags |= CONTROL_PLAY_IS_DISABLED; // Mark so we can turn on later.
                            }
                            if ((pTrack->m_dwFlags & DMUS_TRACKCONFIG_CONTROL_NOTIFICATION) &&
                                (pPrimaryTrack->m_dwFlags & DMUS_TRACKCONFIG_NOTIFICATION_ENABLED))
                            {
                                pPrimaryTrack->m_dwFlags &= ~DMUS_TRACKCONFIG_NOTIFICATION_ENABLED;
                                pPrimaryTrack->m_dwInternalFlags |= CONTROL_NTFY_IS_DISABLED; // Mark so we can turn on later.
                            }
                        }
                    }
                    LeaveCriticalSection(&pSegNode->m_CriticalSection);
                }
            }
        }
        LeaveCriticalSection(&pControlNode->m_CriticalSection);
    }
    // Now, go back to the primary segment and find all tracks that have been reenabled
    // and tag them so they will generate refresh data on the next play (by seeking, as if they
    // were starting or looping playback.) We only do this for play, not notify, because no
    // notifications have state.
    for( pSegNode = m_SegStateQueues[SQ_PRI_PLAY].GetHead(); pSegNode; pSegNode = pSegNode->GetNext() )
    {
        EnterCriticalSection(&pSegNode->m_CriticalSection);
        CTrack *pTrack = pSegNode->m_TrackList.GetHead();
        for (;pTrack;pTrack = pTrack->GetNext())
        {
            if ((pTrack->m_dwInternalFlags & CONTROL_PLAY_DEFAULT_ENABLED) &&
                (pTrack->m_dwInternalFlags & CONTROL_PLAY_WAS_DISABLED) &&
                !(pTrack->m_dwInternalFlags & CONTROL_PLAY_IS_DISABLED))
            {
                pTrack->m_dwInternalFlags |= CONTROL_PLAY_REFRESH; // Mark so we can turn on later.
            }
        }
        LeaveCriticalSection(&pSegNode->m_CriticalSection);
    }
    LeaveCriticalSection(&m_SegmentCrSec);
}

void CPerformance::GetTimeSig( MUSIC_TIME mtTime, DMUS_TIMESIG_PMSG* pTimeSig )
{
    EnterCriticalSection(&m_PipelineCrSec);
    PRIV_PMSG* pEvent = m_TimeSigQueue.GetHead();
    for (;pEvent;pEvent = pEvent->pNext)
    {
        // If this is the last time sig, return it. Or, if the next time sig is after mtTime.
        if (!pEvent->pNext || ( pEvent->pNext->mtTime > mtTime ))
        {
            DMUS_TIMESIG_PMSG* pNewTimeSig = (DMUS_TIMESIG_PMSG*)PRIV_TO_DMUS(pEvent);
            memcpy( pTimeSig, pNewTimeSig, sizeof(DMUS_TIMESIG_PMSG) );
            LeaveCriticalSection(&m_PipelineCrSec);
            return;
        }
    }
    // This should only happen if there is no timesig at all. Should only happen before any segments play.
    memset( pTimeSig, 0, sizeof(DMUS_TIMESIG_PMSG ) );
    pTimeSig->wGridsPerBeat = 4;
    pTimeSig->bBeatsPerMeasure = 4;
    pTimeSig->bBeat = 4;
    LeaveCriticalSection(&m_PipelineCrSec);
}

void CPerformance::SyncTimeSig( CSegState *pSegState )

/*  If a primary segment is played that does not have a time signature track,
    this forces the current time signature to line up with the start of the
    primary segment.
*/

{
    // First, test to see if the segment has a time signature.
    // If it doesn't then we need to do this.
    DMUS_TIMESIGNATURE TimeSig;
    if (FAILED(pSegState->GetParam(this,GUID_TimeSignature,-1,0,0,NULL,(void *)&TimeSig)))
    {
        MUSIC_TIME mtTime = pSegState->m_mtResolvedStart;
        EnterCriticalSection(&m_PipelineCrSec);
        PRIV_PMSG* pEvent = m_TimeSigQueue.GetHead();
        // Scan through the time signatures until the most recent one is found.
        for (;pEvent;pEvent = pEvent->pNext)
        {
            // If this is the last time sig, return it. Or, if the next time sig is after mtTime.
            if (!pEvent->pNext || ( pEvent->pNext->mtTime > mtTime ))
            {
                pEvent->mtTime = mtTime;
                MusicToReferenceTime(mtTime,&pEvent->rtTime);
                break;
            }
        }
        // Should never fall through to here without finding a time signature because Init() creates a timesig.
        LeaveCriticalSection(&m_PipelineCrSec);
    }
}

// Convert mtTime into the resolved time according to the resolution in
// dwResolution.
// This should only be called from within a segment critical section.
MUSIC_TIME CPerformance::ResolveTime( MUSIC_TIME mtTime, DWORD dwResolution, MUSIC_TIME *pmtIntervalSize )
{
    if (pmtIntervalSize)
    {
        *pmtIntervalSize = 0;
    }
    if (dwResolution & DMUS_SEGF_MARKER)
    {
        DMUS_PLAY_MARKER_PARAM Marker;
        MUSIC_TIME mtNext;
        // First, get the time of the marker preceding this one.
        if (SUCCEEDED (GetParam(GUID_Play_Marker,-1,0,mtTime,&mtNext,(void *) &Marker)))
        {
            BOOL fIsMarker = FALSE;
            MUSIC_TIME mtInitialTime = mtTime;
            MUSIC_TIME mtFirst = mtTime + Marker.mtTime; // This is the time of the preceding marker.
            MUSIC_TIME mtSecond = mtTime + mtNext;  // This might be the time of the next marker.
            // Then, scan forward until a marker is found after or equal to this time.
            // If a loop point or end of segment is encountered, the value in Marker.mtTime will
            // continue to be negative. Once we hit the actual marker, it will become 0, since
            // we are asking for the marker at that specific time.
            while (mtNext)
            {
                mtTime += mtNext;
                if (SUCCEEDED(GetParam(GUID_Play_Marker,-1,0,mtTime,&mtNext,(void *) &Marker)))
                {
                    // If the marker time is 0, this means we are sitting right on the marker,
                    // so we are done.
                    if (fIsMarker = (Marker.mtTime == 0))
                    {
                        mtSecond = mtTime;
                        break;
                    }
                    // Otherwise, this was a loop boundary or segment end, so we should continue scanning forward.
                }
                else
                {
                    // GetParam failed, must be nothing more to search.
                    break;
                }
            }
            // If the caller wants the interval size, then we know they are interested in
            // aligning to a previous marker as well as a future one. In that case,
            // if we didn't find a marker in the future, it's okay because it will
            // use the previous marker (mtFirst) anyway.
            // For all other cases, we only return if the upcoming marker is legal.
            // Otherwise, we drop through and try other resolutions.
            if (pmtIntervalSize || fIsMarker)
            {
                if (pmtIntervalSize)
                {
                    *pmtIntervalSize = mtSecond - mtFirst;
                }
                return mtSecond;
            }
            mtTime = mtInitialTime;
        }
        // If marker fails, we can drop down to the other types...
    }
    if( dwResolution & DMUS_SEGF_SEGMENTEND )
    {
        // In this mode, we don't actually get the time signature. Instead, we
        // find out the time of the next segment start after the requested time.
        CSegState *pSegNode = GetPrimarySegmentAtTime( mtTime );
        if( pSegNode )
        {
            // First, calculate the end time of the segment.
            // Include any starting offset so we see the full span of the segment.
            mtTime = pSegNode->GetEndTime( pSegNode->m_mtStartPoint );
            if (pmtIntervalSize)
            {
                // Interval would be the length of the primary segment!
                *pmtIntervalSize = mtTime;
            }
            // Return the end of the segment.
            LONGLONG llEnd = mtTime + (LONGLONG)(pSegNode->m_mtResolvedStart - pSegNode->m_mtStartPoint);
            if(llEnd > 0x7fffffff) llEnd = 0x7fffffff;
            mtTime = (MUSIC_TIME) llEnd;
            return mtTime;
        }
        // If there was no segment, we should fail and try the other flags.
    }
    long        lQuantize;
    MUSIC_TIME  mtNewTime;
    MUSIC_TIME  mtStartOfTimeSig = 0;
    DMUS_TIMESIGNATURE  timeSig;
    if (!(dwResolution & DMUS_SEGF_TIMESIG_ALWAYS))
    {
        if (!GetPrimarySegmentAtTime(mtTime))
        {
            return mtTime;
        }
    }
    GetParam(GUID_TimeSignature,-1,0,mtTime,NULL,(void *) &timeSig);
    mtStartOfTimeSig = timeSig.mtTime + mtTime;
    mtNewTime = mtTime - mtStartOfTimeSig;
    if (dwResolution & DMUS_SEGF_MEASURE)
    {
        lQuantize = ( DMUS_PPQ * 4 * timeSig.bBeatsPerMeasure ) / timeSig.bBeat;
    }
    else if (dwResolution & DMUS_SEGF_BEAT)
    {
        lQuantize = ( DMUS_PPQ * 4 ) / timeSig.bBeat;
    }
    else if (dwResolution & DMUS_SEGF_GRID)
    {
        lQuantize = ( ( DMUS_PPQ * 4 ) / timeSig.bBeat ) / timeSig.wGridsPerBeat;
    }
    else
    {
        lQuantize = 1;
    }
    if (lQuantize == 0) // Avoid divide by 0 error.
    {
        lQuantize = 1;
    }
    if (pmtIntervalSize)
    {
        *pmtIntervalSize = lQuantize;
    }
    if( mtNewTime ) // if it's 0 it stays 0
    {
        // round up to next boundary
        mtNewTime = ((mtNewTime-1) / lQuantize ) * lQuantize;
        mtNewTime += lQuantize;
    }
    return (mtNewTime + mtStartOfTimeSig);
}

// returns:
// true if the note should be invalidated (any other return code will invalidate)
// false if the note should not be invalidated
inline bool GetInvalidationStatus(DMUS_PMSG* pPMsg)
{
    bool fResult = true; // default: invalidate the note

    if( pPMsg->dwType == DMUS_PMSGT_NOTE )
    {
        DMUS_NOTE_PMSG* pNote = (DMUS_NOTE_PMSG*)pPMsg;
        if (pNote->bFlags & DMUS_NOTEF_NOINVALIDATE)
        {
            fResult = false;
        }
    }
    else if( pPMsg->dwType == DMUS_PMSGT_WAVE )
    {
        DMUS_WAVE_PMSG* pWave = (DMUS_WAVE_PMSG*)pPMsg;
        if(pWave->bFlags & DMUS_WAVEF_NOINVALIDATE)
        {
            fResult = false;
        }
    }
    else if( pPMsg->dwType == DMUS_PMSGT_NOTIFICATION )
    {
        // Don't invalidate segment abort messages
        DMUS_NOTIFICATION_PMSG* pNotification = (DMUS_NOTIFICATION_PMSG*) pPMsg;
        if ((pNotification->guidNotificationType == GUID_NOTIFICATION_SEGMENT) &&
            (pNotification->dwNotificationOption == DMUS_NOTIFICATION_SEGABORT))
        {
            fResult = false;
        }
    }
    return fResult;
}

static inline long ComputeCurveTimeSlice(DMUS_CURVE_PMSG* pCurve)
{
    long lTimeIncrement;
    DWORD dwTotalDistance;
    DWORD dwResolution;
    if ((pCurve->bType == DMUS_CURVET_PBCURVE) ||
        (pCurve->bType == DMUS_CURVET_RPNCURVE) ||
        (pCurve->bType == DMUS_CURVET_NRPNCURVE))
    {
        dwResolution = 100;
    }
    else
    {
        dwResolution = 3;
    }
    if (pCurve->nEndValue > pCurve->nStartValue)
        dwTotalDistance = pCurve->nEndValue - pCurve->nStartValue;
    else
        dwTotalDistance = pCurve->nStartValue - pCurve->nEndValue;
    if (dwTotalDistance == 0) dwTotalDistance = 1;
    lTimeIncrement = (pCurve->mtDuration * dwResolution) / dwTotalDistance;
    // Force to no smaller than 192nd note (10ms at 120 bpm.)
    if( lTimeIncrement < (DMUS_PPQ/48) ) lTimeIncrement = DMUS_PPQ/48;
    return lTimeIncrement;
}

static DWORD ComputeCurve( DMUS_CURVE_PMSG* pCurve )
{
    DWORD dwRet;
    short *panTable;
    MUSIC_TIME mtCurrent;
    long lIndex;

    switch( pCurve->bCurveShape )
    {
    case DMUS_CURVES_INSTANT:
    default:
        if( pCurve->dwFlags & DMUS_PMSGF_TOOL_FLUSH )
        {
            pCurve->rtTime = 0;
            return (DWORD)pCurve->nResetValue;
        }
        if( ( pCurve->bFlags & DMUS_CURVE_RESET ) && ( pCurve->mtResetDuration > 0 ) )
        {
            pCurve->mtTime = pCurve->mtResetDuration + pCurve->mtOriginalStart;
            pCurve->mtDuration = 0;
            pCurve->dwFlags &= ~DMUS_PMSGF_REFTIME;
        }
        else
        {
            pCurve->rtTime = 0; // setting this to 0 will free the event upon return
        }
        return (DWORD)pCurve->nEndValue;
        break;
    case DMUS_CURVES_LINEAR:
        panTable = &ganCT_Linear[ 0 ];
        break;
    case DMUS_CURVES_EXP:
        panTable = &ganCT_Exp[ 0 ];
        break;
    case DMUS_CURVES_LOG:
        panTable = &ganCT_Log[ 0 ];
        break;
    case DMUS_CURVES_SINE:
        panTable = &ganCT_Sine[ 0 ];
        break;
    }

    // compute index into table
    // there are CT_MAX + 1 elements in the table.
    mtCurrent = pCurve->mtTime - pCurve->mtOriginalStart;

    // if we're flushing this event, send the reset value
    if( pCurve->dwFlags & DMUS_PMSGF_TOOL_FLUSH )
    {
        // it will only get here if pCurve->bFlags & 1, because that is checked in
        // the :Flush() routine.
        pCurve->rtTime = 0;
        return pCurve->nResetValue;
    }

    // this should now never happen, as a result of fixing 33987: Transition on a beat boundary invalidates CC's right away (doesn't wait for the beat)
    if( (pCurve->bFlags & DMUS_CURVE_RESET) &&
        (pCurve->mtResetDuration < 0 ) && // this can happen from flushing
        (pCurve->mtTime >= pCurve->mtOriginalStart + pCurve->mtDuration + pCurve->mtResetDuration ))
    {
        pCurve->rtTime = 0;
        return pCurve->nResetValue;
    }
    else if( (pCurve->mtDuration == 0) ||
        (pCurve->mtTime - pCurve->mtOriginalStart >= pCurve->mtDuration ))
    {
        // if we're supposed to send the return value (m_bFlags & 1) then
        // set it up to do so. Otherwise, free the event.
        if( pCurve->bFlags & DMUS_CURVE_RESET )
        {
            pCurve->mtTime = pCurve->mtDuration + pCurve->mtResetDuration +
                pCurve->mtOriginalStart;
            pCurve->dwFlags &= ~DMUS_PMSGF_REFTIME;
        }
        else
        {
            pCurve->rtTime = 0; // time to free the event, we're done
        }
        dwRet = pCurve->nEndValue;
    }
    else
    {
        // Calculate how far into the table we should be.
        lIndex = (mtCurrent * (CT_MAX + 1)) / pCurve->mtDuration;

        // find an amount of time to add to the curve event such that there is at
        // least a change by CT_FACTOR. This will be used as the time stamp
        // for the next iteration of the curve.

        // clamp lIndex
        if( lIndex < 0 )
        {
            lIndex = 0;
        }
        if( lIndex >= CT_MAX )
        {
            lIndex = CT_MAX;
            dwRet = pCurve->nEndValue;
        }
        else
        {
            // Okay, in the curve, so calculate the return value.
            dwRet = ((panTable[lIndex] * (pCurve->nEndValue - pCurve->nStartValue)) /
                CT_DIVFACTOR) + pCurve->nStartValue;
        }

        // this should now never happen, as a result of fixing 33987
        if( (pCurve->bFlags & DMUS_CURVE_RESET) && (pCurve->mtResetDuration < 0) )
        {
            // this can happen as a result of flushing. We want to make sure the next
            // time is the reset flush time.
            pCurve->mtTime = pCurve->mtDuration + pCurve->mtResetDuration +
                pCurve->mtOriginalStart;
        }
        else
        {
            // Within curve, so increment time.
            if (!pCurve->wMeasure) // oops --- better compute this.
            {
                TraceI(2, "Warning: Computing curve time slice...\n");
                pCurve->wMeasure = (WORD) ComputeCurveTimeSlice(pCurve);  // Use this to store the time slice interval.
            }
            pCurve->mtTime += pCurve->wMeasure; // We are storing the time increment here.
        }
        if( pCurve->mtTime > pCurve->mtDuration + pCurve->mtOriginalStart )
        {
            pCurve->mtTime = pCurve->mtDuration + pCurve->mtOriginalStart;
        }
        pCurve->dwFlags &= ~DMUS_PMSGF_REFTIME;

    }
    return dwRet;
}

static int RecomputeCurveEnd( DMUS_CURVE_PMSG* pCurve, MUSIC_TIME mtCurrent )
{
    int nRet = 0;
    short *panTable;

    switch( pCurve->bCurveShape )
    {
    case DMUS_CURVES_INSTANT:
    default:
        return pCurve->nEndValue;
        break;
    case DMUS_CURVES_LINEAR:
        panTable = &ganCT_Linear[ 0 ];
        break;
    case DMUS_CURVES_EXP:
        panTable = &ganCT_Exp[ 0 ];
        break;
    case DMUS_CURVES_LOG:
        panTable = &ganCT_Log[ 0 ];
        break;
    case DMUS_CURVES_SINE:
        panTable = &ganCT_Sine[ 0 ];
        break;
    }

    if( (pCurve->mtDuration == 0) || (mtCurrent >= pCurve->mtDuration ))
    {
        return pCurve->nEndValue;
    }
    else
    {
        // Calculate how far into the table we should be.
        long lIndex = (mtCurrent * (CT_MAX + 1)) / pCurve->mtDuration;

        // find an amount of time to add to the curve event such that there is at
        // least a change by CT_FACTOR. This will be used as the time stamp
        // for the next iteration of the curve.

        // clamp lIndex
        if( lIndex < 0 )
        {
            lIndex = 0;
        }
        if( lIndex >= CT_MAX )
        {
            lIndex = CT_MAX;
            nRet = pCurve->nEndValue;
        }
        else
        {
            // Okay, in the curve, so calculate the return value.
            nRet = ((panTable[lIndex] * (pCurve->nEndValue - pCurve->nStartValue)) /
                CT_DIVFACTOR) + pCurve->nStartValue;
        }
    }
    return nRet;
}

void CPerformance::FlushEventQueue( DWORD dwId,
    CPMsgQueue *pQueue,                 // Queue to flush events from.
    REFERENCE_TIME rtFlush,             // Time that flush occurs. This may be resolved to a timing resolution.
    REFERENCE_TIME rtFlushUnresolved,   // Queue time at time flush was requested. This is not resolved to the timing resolution.
                                        // Instead, it is the actual time at which that the flush was requested. This is used only by curves.
    DWORD dwFlushFlags)                 // If notes or waves are currently on, do not cut short their durations.
{
    PRIV_PMSG* pEvent;
    PRIV_PMSG* pNext;
    REFERENCE_TIME rtTemp;
    GetQueueTime(&rtTemp);
    pNext = NULL;
    for(pEvent = pQueue->GetHead(); pEvent; pEvent = pNext )
    {
        pNext = pEvent->pNext;
        // Clear the remove bit. This will be set for each event that should be removed from the queue.
        pEvent->dwPrivFlags &= ~PRIV_FLAG_REMOVE;
        // Also clear the requeue bit, which will be set for each event that needs to be requeued.
        pEvent->dwPrivFlags &= ~PRIV_FLAG_REQUEUE;
        if( ( 0 == dwId ) || ( pEvent->dwVirtualTrackID == dwId ) )
        {
            // First, create the correct mtTime and rtTime for invalidation.
            REFERENCE_TIME rtTime = pEvent->rtTime;
            if( pEvent->dwType == DMUS_PMSGT_NOTE )
            {
                DMUS_NOTE_PMSG* pNote = (DMUS_NOTE_PMSG*)PRIV_TO_DMUS(pEvent);
                if( pNote->bFlags & DMUS_NOTEF_NOTEON )
                {
                    // If this is a note on, we want to take the offset into consideration for
                    // determining whether or not to invalidate. 
                    MUSIC_TIME mtNote = pNote->mtTime - pNote->nOffset; 
                    MusicToReferenceTime( mtNote, &rtTime );
                }
                // If note off and we want to leave notes playing, turn on the noinvalidate flag.
                else if (dwFlushFlags & FLUSH_LEAVE_ON)
                {
                    pNote->bFlags |= DMUS_NOTEF_NOINVALIDATE;
                }
            }
            else if( pEvent->dwType == DMUS_PMSGT_WAVE )
            {
                DMUS_WAVE_PMSG* pWave = (DMUS_WAVE_PMSG*)PRIV_TO_DMUS(pEvent);
                if ((pWave->bFlags & DMUS_WAVEF_IGNORELOOPS) && (dwFlushFlags & FLUSH_ON_REPEAT))
                {
                    // If this invalidation was caused by a loop track repeating and this
                    // is a wave that should continue playing on loop, let it do so.
                    continue;
                }
                if( !(pWave->bFlags & DMUS_WAVEF_OFF) )
                {
                    if (pWave->dwFlags & DMUS_PMSGF_LOCKTOREFTIME)
                    {
                        rtTime = pWave->rtTime;
                    }
                    else
                    {
                        MusicToReferenceTime(pWave->mtTime, &rtTime);
                    }
                }
                // If wave off and we want to leave waves playing, turn on the noinvalidate flag.
                else if (dwFlushFlags & FLUSH_LEAVE_ON)
                {
                    pWave->bFlags |= DMUS_WAVEF_NOINVALIDATE;
                }
            }
            else if( pEvent->dwType == DMUS_PMSGT_CURVE )
            {
                if (dwFlushFlags & FLUSH_LEAVE_ON)
                {
                    rtTime = 0;
                }
                else
                {
                    DMUS_CURVE_PMSG* pCurve = (DMUS_CURVE_PMSG*)PRIV_TO_DMUS(pEvent);
                    MUSIC_TIME mtCurve;
                    MUSIC_TIME mtStart;
                    mtStart = pCurve->mtOriginalStart ? pCurve->mtOriginalStart : pCurve->mtTime;
                
                    // if rtFlush is before the beginning of the curve minus the offset of 
                    // the curve, we want to prevent the curve from playing
                    mtCurve = mtStart - pCurve->nOffset; 
                    MusicToReferenceTime( mtCurve, &rtTime );
                    if( rtFlush > rtTime ) // if it isn't...
                    {
                        // if the curve has a reset value and has already begun,
                        // we may want to flush right away.
                        if( ( pCurve->bFlags & DMUS_CURVE_RESET) && 
                              pCurve->mtOriginalStart && 
                              rtFlush <= rtFlushUnresolved )
                        {
                            mtCurve = mtStart + pCurve->mtDuration;
                            MusicToReferenceTime( mtCurve, &rtTime );
                            if( rtTime >= rtFlush && !(pEvent->dwPrivFlags & PRIV_FLAG_FLUSH) )
                            {
                                MUSIC_TIME mt = 0;
                                ReferenceToMusicTime(rtFlush, &mt);
                                pCurve->mtDuration = (mt - mtStart) - 1;
                                pCurve->mtResetDuration = 1;
                            }
                            else 
                            {
                                mtCurve += pCurve->mtResetDuration;
                                MusicToReferenceTime( mtCurve, &rtTime );
                                if ( rtTime >= rtFlush && !(pEvent->dwPrivFlags & PRIV_FLAG_FLUSH) )
                                {
                                    MUSIC_TIME mt = 0;
                                    ReferenceToMusicTime(rtFlush, &mt);
                                    pCurve->mtResetDuration = mt - (mtStart + pCurve->mtDuration);
                                }
                            }
                        }
                        else 
                        {
                            // Otherwise, we may cut the curve short in the code below.
                            rtTime = 0;
                        }
                    }
                }
            }
            // now flush the event if needed
            if( rtTime >= rtFlush )
            {
                if (!(pEvent->dwPrivFlags & PRIV_FLAG_FLUSH))
                {
                    if( pEvent->pTool)
                    {
                        bool fFlush = false;
                        if (pEvent->dwType == DMUS_PMSGT_WAVE)
                        {
                            DMUS_WAVE_PMSG* pWave = (DMUS_WAVE_PMSG*)PRIV_TO_DMUS(pEvent);
                            if( !(pWave->bFlags & DMUS_WAVEF_OFF) )
                            {
                                // this wave on is due to start after the flush time.
                                // we never want to hear it.
                                fFlush = true;
                            }
                            else 
                            {
                                // cut the duration short, but don't actually flush here,
                                // since it's possible to invalidate the same wave more
                                // than once, and the second invalidation might have a
                                // time prior to the first one (e.g., first is from a loop,
                                // second is from a transition)
                                if (GetInvalidationStatus(PRIV_TO_DMUS(pEvent)) &&
                                    rtFlush < pWave->rtTime)
                                {
                                    pEvent->dwPrivFlags |= PRIV_FLAG_REQUEUE;
                                    MUSIC_TIME mtFlush = 0;
                                    ReferenceToMusicTime(rtFlush, &mtFlush);
                                    pWave->rtTime = rtFlush;
                                    pWave->mtTime = mtFlush;
                                }
                            }
                        }
                        if (fFlush || 
                            (pEvent->dwType != DMUS_PMSGT_WAVE &&
                             GetInvalidationStatus(PRIV_TO_DMUS(pEvent))) )
                        {
                            pEvent->dwPrivFlags |= PRIV_FLAG_REMOVE;
                            pEvent->dwFlags |= DMUS_PMSGF_TOOL_FLUSH;
                            if( rtFlush <= pEvent->rtLast )
                            {
                                pEvent->pTool->Flush( this, PRIV_TO_DMUS(pEvent), pEvent->rtLast + REF_PER_MIL );
                            }
                            else
                            {
                                pEvent->pTool->Flush( this, PRIV_TO_DMUS(pEvent), rtFlush );
                            }
                        }
                    }
                    else
                    {
                        pEvent->dwPrivFlags |= PRIV_FLAG_REMOVE;
                    }
                }
            }
            else // cut notes, waves, and curves short if needed
            {
                if( pEvent->dwType == DMUS_PMSGT_NOTE && !(dwFlushFlags & FLUSH_LEAVE_ON ))
                {
                    DMUS_NOTE_PMSG* pNote = (DMUS_NOTE_PMSG*)PRIV_TO_DMUS(pEvent);
                    if( pNote->bFlags & DMUS_NOTEF_NOTEON )
                    {
                        if (GetInvalidationStatus(PRIV_TO_DMUS(pEvent)))
                        {
                            // subtract 2 from the duration to guarantee the note cuts short
                            // 1 clock before the flush time.
                            MUSIC_TIME mtNoteOff = pNote->mtTime + pNote->mtDuration - 2;
                            REFERENCE_TIME rtNoteOff;
                            MusicToReferenceTime( mtNoteOff, &rtNoteOff );
                            if( rtNoteOff >= rtFlush )
                            {
                                ReferenceToMusicTime( rtFlush, &mtNoteOff );
                                mtNoteOff -= pNote->mtTime;
                                // Make any duration < 1 be 0; this will cause the note not to 
                                // sound.  Can happen if the note's logical time is well before
                                // its physical time.
                                if( mtNoteOff < 1 ) mtNoteOff = 0;
                                pNote->mtDuration = mtNoteOff;
                            }
                        }
                    }
                }
                else if( pEvent->dwType == DMUS_PMSGT_WAVE && !(dwFlushFlags & FLUSH_LEAVE_ON ))
                {
                    DMUS_WAVE_PMSG* pWave = (DMUS_WAVE_PMSG*)PRIV_TO_DMUS(pEvent);
                    if( !(pWave->bFlags & DMUS_WAVEF_OFF) &&
                        (GetInvalidationStatus(PRIV_TO_DMUS(pEvent))) )
                    {
                        if (pWave->dwFlags & DMUS_PMSGF_LOCKTOREFTIME)
                        {
                            // This is a clock time message. 
                            // subtract 2 from the duration to guarantee the wave cuts short
                            // 1 clock before the flush time.
                            if ((rtTime + pWave->rtDuration - 2) >= rtFlush)
                            {
                                pWave->rtDuration = rtFlush - rtTime;
                            }
            
                        }
                        else
                        {
                            MUSIC_TIME mtTime = 0;
                            MUSIC_TIME mtFlush = 0;
                            ReferenceToMusicTime(rtTime, &mtTime);
                            ReferenceToMusicTime(rtFlush, &mtFlush);
                            // subtract 2 from the duration to guarantee the wave cuts short
                            // 1 clock before the flush time.
                            if ((mtTime + (MUSIC_TIME)pWave->rtDuration - 2) >= mtFlush)
                            {
                                pWave->rtDuration = mtFlush - mtTime;
                            }
                        }
                        if (pWave->rtDuration < 1) // disallow durations less than 1. This should never happen anyway.
                        {
                            pWave->rtDuration = 1;
                        }
                    }
                }
                else if( pEvent->dwType == DMUS_PMSGT_CURVE && !(dwFlushFlags & FLUSH_LEAVE_ON ))
                {
                    DMUS_CURVE_PMSG* pCurve = (DMUS_CURVE_PMSG*)PRIV_TO_DMUS(pEvent);
                    MUSIC_TIME mtEnd;
                    MUSIC_TIME mtStart = pCurve->mtOriginalStart ? pCurve->mtOriginalStart : pCurve->mtTime;

                    if( pCurve->bFlags & DMUS_CURVE_RESET )
                    {
                        mtEnd = mtStart + pCurve->mtResetDuration + pCurve->mtDuration;
                    }
                    else
                    {
                        mtEnd = mtStart + pCurve->mtDuration;
                    }
                    REFERENCE_TIME rtEnd;
                    MusicToReferenceTime( mtEnd, &rtEnd );
                    // Note: as a result of fixing 33987, the curve is no longer given
                    // a negative reset duration.  Now, the curve's duration is recomputed
                    // and its time slice is recalculated.
                    if( rtEnd >= rtFlush )
                    {
                        // reset the curve's duration
                        MUSIC_TIME mtFlush;
                        ReferenceToMusicTime( rtFlush, &mtFlush );
                        mtEnd = mtFlush - mtStart;
                        // get the curve value at the flush time, and make that the end value
                        pCurve->nEndValue = (short) RecomputeCurveEnd(pCurve, mtEnd);
                        // subtract 2 from the duration to guarantee the curve cuts short
                        // 1 clock before the flush time.
                        mtEnd -= 2;
                        if ( mtEnd < 1)
                        {
                            mtEnd = 1;
                        }
                        else if (pCurve->bFlags & DMUS_CURVE_RESET) 
                        {
                            if (mtEnd > pCurve->mtDuration)
                            {
                                // curve ends in the reset duration; keep regular duration the
                                // same as it was and adjust reset duration
                                pEvent->dwPrivFlags |= PRIV_FLAG_FLUSH;
                                pCurve->mtResetDuration = mtFlush - (mtStart + pCurve->mtDuration);
                                mtEnd = pCurve->mtDuration;
/* NOTE: I've commented out a bunch of code because it really seems to be redundant.
   And, it was exhibiting the problem of not always reseting before the invalidation.
   By forcing the time stamp to be just before the invalidation for all cases, it seems
   to clear up behavior. But, I'm leaving the old code in comments in case something
   breaks and we have that, "ah, that's what that was doing!" realization.
*/
//                                if (pCurve->mtTime > mtEnd + pCurve->mtResetDuration + mtStart)
//                                {
//                                    pCurve->mtTime = mtEnd + pCurve->mtResetDuration + mtStart;
                                    // Need to requeue since the time stamp has changed.
//                                    pEvent->dwPrivFlags |= PRIV_FLAG_REQUEUE;
//                            MusicToReferenceTime(pCurve->mtTime, &pCurve->rtTime);
//                                }
                            }
                            else 
                            {
                                // curve ends in the regular duration; reduce it by 1 and
                                // give the reset duration a value of 1
                                mtEnd--;
                                pCurve->mtResetDuration = 1;
                                if (mtEnd < 1)
                                {
                                    // this is unlikely, but the curve really should have
                                    // a duration...
                                    mtEnd = 1;
                                }
//                                pEvent->dwPrivFlags |= PRIV_FLAG_FLUSH;
                            }
                            // If this is an instant curve that's already started, we
                            // don't want it to play again, so reset its start time
/*                            if ( pCurve->bCurveShape == DMUS_CURVES_INSTANT && 
                                 pCurve->mtOriginalStart )
                            {
                                pCurve->mtTime = pCurve->mtResetDuration + pCurve->mtOriginalStart + mtEnd;
                                pEvent->dwPrivFlags |= PRIV_FLAG_REQUEUE;
                                MusicToReferenceTime(pCurve->mtTime, &pCurve->rtTime);
                            }*/
                            // Ensure that the end of the curve will play prior to the invalidation.
                            pCurve->rtTime = rtFlush - 10000; // Drop this back 1 ms to ensure rounding errors don't push it up.
                            pCurve->mtTime = mtFlush - 2;
                            pEvent->dwPrivFlags |= PRIV_FLAG_REQUEUE;
                            pCurve->mtDuration = mtEnd;
                        }
                        else
                        {
                            // If this does not have a reset, simply lose it.
                            pEvent->dwPrivFlags |= PRIV_FLAG_REMOVE;
                        }
                    }
                }
            }
        }
    }
    // remove (and unmark) all marked PMsgs from the current queue
    for(pEvent = pQueue->GetHead(); pEvent; pEvent = pNext )
    {
        pNext = pEvent->pNext;
        if (pEvent->dwPrivFlags & (PRIV_FLAG_REMOVE | PRIV_FLAG_REQUEUE))
        {
            pEvent->dwPrivFlags &= ~PRIV_FLAG_REMOVE;
            if (pQueue->Dequeue(pEvent))
            {
                if (pEvent->dwPrivFlags & PRIV_FLAG_REQUEUE)
                {
                    pEvent->dwPrivFlags &= ~PRIV_FLAG_REQUEUE;
                    pQueue->Enqueue(pEvent);
                }
                else
                {
                    FreePMsg(pEvent);
                }
            }
            else
            {
                TraceI(0,"Error dequeing event for flushing\n");
            }
        }
    }
    SendBuffers();
}

/*

  Flushes all events in all queues from time <p mtFlush> on.

  comm Only call this from withing a PipelineCrSec critical section!

*/
void CPerformance::FlushMainEventQueues( 
    DWORD dwId,                      // Virtual Track ID to flush, or zero for all.
    MUSIC_TIME mtFlush,              // Time to flush (resolved to timing resolution).
    MUSIC_TIME mtFlushUnresolved,    // Time to flush (unresolved).
    DWORD dwFlushFlags)              // If true, notes currently on are left to play through their duration.
{
    REFERENCE_TIME rt;
    if( mtFlush )
    {
        MusicToReferenceTime( mtFlush, &rt );
    }
    else
    {
        rt = 0;
    }
    REFERENCE_TIME rtUnresolved;
    if( mtFlushUnresolved && mtFlushUnresolved != mtFlush)
    {
        MusicToReferenceTime( mtFlushUnresolved, &rtUnresolved );
    }
    else
    {
        rtUnresolved = rt;
    }
    FlushEventQueue( dwId, &m_OnTimeQueue, rt, rtUnresolved, dwFlushFlags );
    FlushEventQueue( dwId, &m_NearTimeQueue, rt, rtUnresolved, dwFlushFlags );
    FlushEventQueue( dwId, &m_EarlyQueue, rt, rtUnresolved, dwFlushFlags );
    if (dwId == 0)
    {
        MUSIC_TIME mtTime;
        ReferenceToMusicTime(rt,&mtTime);
        FlushEventQueue( dwId, &m_TempoMap, rt, rtUnresolved, dwFlushFlags );
        RecalcTempoMap(NULL, mtTime );
    }
}

// the only kinds of events we care about are note events.
void CPerformance::OnChordUpdateEventQueue( DMUS_NOTIFICATION_PMSG* pNotify, CPMsgQueue *pQueue, REFERENCE_TIME rtFlush )
{
    PRIV_PMSG* pEvent;
    PRIV_PMSG* pNext;
    HRESULT hr = S_OK;
    DWORD dwId = pNotify->dwVirtualTrackID;
    DWORD dwTrackGroup = pNotify->dwGroupID;
    CPMsgQueue UpdateQueue;        // List of PMsgs to be inserted into a queue during update.

    REFERENCE_TIME rtTemp;
    GetQueueTime(&rtTemp);
    pNext = NULL;
    for(pEvent = pQueue->GetHead(); pEvent; pEvent = pNext )
    {
        pNext = pEvent->pNext;
        pEvent->dwPrivFlags &= ~PRIV_FLAG_REMOVE;
        DMUS_PMSG* pNew = NULL;
        if( ( 0 == dwId || pEvent->dwVirtualTrackID == dwId ) &&
            (pEvent->dwType == DMUS_PMSGT_NOTE) )
        {
            REFERENCE_TIME rtTime = pEvent->rtTime;
            DMUS_NOTE_PMSG* pNote = (DMUS_NOTE_PMSG*)PRIV_TO_DMUS(pEvent);
            if( pNote->bFlags & DMUS_NOTEF_NOTEON )
            {
                MUSIC_TIME mtNote = pNote->mtTime - pNote->nOffset;
                MusicToReferenceTime( mtNote, &rtTime );
            }
            // now flush the event if needed
            if( rtTime >= rtFlush )
            {
                REFERENCE_TIME rtFlushTime = (rtFlush <= pEvent->rtLast) ? pEvent->rtLast + REF_PER_MIL : rtFlush;
                if( pEvent->pTool &&
                    !(pNote->bFlags & DMUS_NOTEF_NOTEON) &&
                    S_OK == (hr = GetChordNotificationStatus(pNote, dwTrackGroup, rtFlushTime, &pNew)))
                {
                    pEvent->dwPrivFlags |= PRIV_FLAG_REMOVE;
                    pEvent->dwFlags |= DMUS_PMSGF_TOOL_FLUSH;
                    pEvent->pTool->Flush( this, PRIV_TO_DMUS(pEvent), rtFlushTime );
                }
                if (SUCCEEDED(hr) && pNew) // add to temp queue for later insertion into regular queue
                {
                    UpdateQueue.Enqueue( DMUS_TO_PRIV(pNew) );
                }
            }
            else // cut notes short if needed
            {
                if( pNote->bFlags & DMUS_NOTEF_NOTEON )
                {
                    if (S_OK == (hr = GetChordNotificationStatus(pNote, dwTrackGroup, rtFlush, &pNew)))
                    {
                        // subtract 2 from the duration to guarantee the note cuts short
                        // 1 clock before the flush time.
                        MUSIC_TIME mtNoteOff = pNote->mtTime + pNote->mtDuration - 2;
                        REFERENCE_TIME rtNoteOff;
                        MusicToReferenceTime( mtNoteOff, &rtNoteOff );
                        if( rtNoteOff >= rtFlush )
                        {
                            ReferenceToMusicTime( rtFlush, &mtNoteOff );
                            mtNoteOff -= pNote->mtTime;
                            if( mtNoteOff < 1 ) mtNoteOff = 1; // disallow durations less than 1. This should never happen anyway.
                            pNote->mtDuration = mtNoteOff;
                        }
                    }
                    if (SUCCEEDED(hr) && pNew) // add to temp queue for later insertion into regular queue
                    {
                        UpdateQueue.Enqueue( DMUS_TO_PRIV(pNew) );
                    }
                }
            }
        }
    }
    // remove (and unmark) all marked PMsgs from the current queue
    for(pEvent = pQueue->GetHead(); pEvent; pEvent = pNext )
    {
        pNext = pEvent->pNext;
        if (pEvent->dwPrivFlags & PRIV_FLAG_REMOVE)
        {
            pEvent->dwPrivFlags &= ~PRIV_FLAG_REMOVE;
            if (pQueue->Dequeue(pEvent))
            {
                FreePMsg(pEvent);
            }
            else
            {
                TraceI(0,"Error dequeing event for flushing\n");
            }
        }
    }
    // empty the Update queue into the current queue
    while( pEvent = UpdateQueue.Dequeue() )
    {
        pQueue->Enqueue(pEvent);
    }
    SendBuffers();
}

/*

  Only call this from withing a PipelineCrSec critical section!

*/
void CPerformance::OnChordUpdateEventQueues(
    DMUS_NOTIFICATION_PMSG* pNotify)    // notification PMsg that caused this to be called
{
    IDirectMusicSegmentState* pSegState = NULL;
    if (!pNotify || !pNotify->punkUser) return;
    REFERENCE_TIME rt = 0;
    if( pNotify->mtTime )
    {
        MusicToReferenceTime( pNotify->mtTime, &rt );
    }
    OnChordUpdateEventQueue( pNotify, &m_OnTimeQueue, rt );
    OnChordUpdateEventQueue( pNotify, &m_NearTimeQueue, rt );
    OnChordUpdateEventQueue( pNotify, &m_EarlyQueue, rt );
}

/////////////////////////////////////////////////////////////////////////////
// IDirectMusicPerformance

HRESULT CPerformance::CreateThreads()

{
    // initialize the realtime thread
    m_hRealtimeThread = CreateThread(NULL, 0, _Realtime, this, 0, &m_dwRealtimeThreadID);
    if( m_hRealtimeThread )
    {
        m_hRealtime = CreateEvent(NULL,FALSE,FALSE,NULL);
        SetThreadPriority( m_hRealtimeThread, THREAD_PRIORITY_TIME_CRITICAL );
    }
    else
    {
        TraceI(0, "Major error! Realtime thread not created.\n");
        return E_OUTOFMEMORY;
    }
    // initialize the transport thread
    m_hTransportThread = CreateThread(NULL, 0, _Transport, this, 0, &m_dwTransportThreadID);
    if( m_hTransportThread )
    {
        m_hTransport = CreateEvent(NULL, FALSE, FALSE, NULL);
        SetThreadPriority( m_hTransportThread, THREAD_PRIORITY_ABOVE_NORMAL );
    }
    else
    {
        TraceI(0, "Major error! Transport thread not created.\n");
        m_fKillRealtimeThread = TRUE;
        if( m_hRealtime ) SetEvent( m_hRealtime );
        return E_OUTOFMEMORY;
    }
    m_pDirectMusic->GetMasterClock( NULL, &m_pClock );
    m_rtStart = GetTime();
    m_rtQueuePosition = m_rtStart;
    return S_OK;
}


STDMETHODIMP CPerformance::InitAudio(IDirectMusic** ppDirectMusic,
                           IDirectSound** ppDirectSound,
                           HWND hWnd,
                           DWORD dwDefaultPathType,
                           DWORD dwPChannelCount,
                           DWORD dwFlags,
                           DMUS_AUDIOPARAMS *pParams)

{
    V_INAME(IDirectMusicPerformance::InitAudio);
    V_PTRPTR_WRITE_OPT(ppDirectMusic);
    V_PTRPTR_WRITE_OPT(ppDirectSound);
    V_HWND_OPT(hWnd);
    HRESULT hr = S_OK;

    // Further validate, checking for a pointer to a bad interface pointer...
    if (ppDirectMusic)
    {
        V_INTERFACE_OPT(*ppDirectMusic);
    }
    if (ppDirectSound)
    {
        V_INTERFACE_OPT(*ppDirectSound);
    }
    if( m_dwAudioPathMode )
    {
        Trace(1,"Error: InitAudio called on an already initialized Performance.\n");
        return DMUS_E_ALREADY_INITED;
    }
    if (dwFlags == 0)
    {
        dwFlags = DMUS_AUDIOF_ALL;
    }
    Init();
    m_AudioParams.dwFeatures = dwFlags;
    m_AudioParams.dwSampleRate = 22050;
    m_AudioParams.dwSize = sizeof (m_AudioParams);
    m_AudioParams.dwValidData = DMUS_AUDIOPARAMS_FEATURES | DMUS_AUDIOPARAMS_VOICES | DMUS_AUDIOPARAMS_SAMPLERATE | DMUS_AUDIOPARAMS_DEFAULTSYNTH;
    m_AudioParams.dwVoices = 64;
    m_AudioParams.fInitNow = TRUE;
    m_AudioParams.clsidDefaultSynth = CLSID_DirectMusicSynth;
    if (pParams)
    {
        if (pParams->dwValidData & DMUS_AUDIOPARAMS_FEATURES)
        {
            m_AudioParams.dwFeatures = pParams->dwFeatures;
        }
        if (pParams->dwValidData & DMUS_AUDIOPARAMS_VOICES)
        {
            m_AudioParams.dwVoices = pParams->dwVoices;
        }
        if (pParams->dwValidData & DMUS_AUDIOPARAMS_DEFAULTSYNTH)
        {
            // If they requested the DX7 default synth and yet also asked for audiopath
            // features, force to DX8 default synth.
            if ((pParams->clsidDefaultSynth != GUID_NULL) ||
                !((m_AudioParams.dwValidData & DMUS_AUDIOPARAMS_FEATURES) &&
                (m_AudioParams.dwFeatures & DMUS_AUDIOF_ALL)))
            {
                m_AudioParams.clsidDefaultSynth = pParams->clsidDefaultSynth;
            }
        }
        if (pParams->dwValidData & DMUS_AUDIOPARAMS_SAMPLERATE)
        {
            if (pParams->dwSampleRate > 96000)
            {
                m_AudioParams.dwSampleRate = 96000;
            }
            else if (pParams->dwSampleRate < 11025)
            {
                m_AudioParams.dwSampleRate = 11025;
            }
            else
            {
                m_AudioParams.dwSampleRate = pParams->dwSampleRate;
            }
        }
    }
    m_dwAudioPathMode = 2;
    EnterCriticalSection(&m_MainCrSec);
    if (ppDirectMusic && *ppDirectMusic)
    {
        hr = (*ppDirectMusic)->QueryInterface(IID_IDirectMusic8,(void **) &m_pDirectMusic);
    }
    if (SUCCEEDED(hr))
    {
        if (ppDirectSound && *ppDirectSound)
        {
            hr = (*ppDirectSound)->QueryInterface(IID_IDirectSound8,(void **) &m_pDirectSound);
        }
        if (SUCCEEDED(hr))
        {
            if (!m_pDirectSound)
            {
                hr = DirectSoundCreate8(NULL,&m_pDirectSound,NULL);
                if (SUCCEEDED(hr))
                {
                    if (!hWnd)
                    {
                        hWnd = GetForegroundWindow();
                        if (!hWnd)
                        {
                            hWnd = GetDesktopWindow();
                        }
                    }
                    m_pDirectSound->SetCooperativeLevel(hWnd, DSSCL_PRIORITY);
                }
            }

            if (SUCCEEDED(hr))
            {
                if (!m_pDirectMusic)
                {
                    hr = CoCreateInstance(CLSID_DirectMusic,
                                          NULL,
                                          CLSCTX_INPROC,
                                          IID_IDirectMusic8,
                                          (LPVOID*)&m_pDirectMusic);
                    if (SUCCEEDED(hr))
                    {
                        hr = m_pDirectMusic->SetDirectSound(m_pDirectSound,hWnd);
                    }
                }
            }
        }
    }
    if (SUCCEEDED(hr))
    {
        hr = m_BufferManager.Init(this,&m_AudioParams);
        if (SUCCEEDED(hr))
        {
            // If we are going to be connecting the synth to Buffers,
            // force the use of the dsound clock.
            if (m_AudioParams.dwFeatures & DMUS_AUDIOF_BUFFERS)
            {
                DMUS_CLOCKINFO ClockInfo;
                ClockInfo.dwSize = sizeof(ClockInfo);
                DWORD dwIndex;
                GUID guidMasterClock = GUID_NULL;
                for (dwIndex = 0; ;dwIndex++)
                {
                    if (S_OK == m_pDirectMusic->EnumMasterClock(dwIndex, &ClockInfo))
                    {
                        if (!wcscmp(ClockInfo.wszDescription, L"DirectSound Clock"))
                        {
                            guidMasterClock = ClockInfo.guidClock;
                            break;
                        }
                    }
                    else
                    {
                        break;
                    }
                }
                m_pDirectMusic->SetMasterClock(guidMasterClock);
            }
            hr = CreateThreads();
            if (SUCCEEDED(hr))
            {
                if (dwDefaultPathType)
                {
                    IDirectMusicAudioPath *pPath;
                    hr = CreateStandardAudioPath(dwDefaultPathType,dwPChannelCount,m_AudioParams.fInitNow,&pPath);
                    if (SUCCEEDED(hr))
                    {
                        hr = SetDefaultAudioPath(pPath);
                        pPath->Release();
                    }
                }
            }
        }
    }
    if (SUCCEEDED(hr))
    {
        if (m_pDirectMusic && ppDirectMusic && !*ppDirectMusic)
        {
            *ppDirectMusic = m_pDirectMusic;
            m_pDirectMusic->AddRef();
        }
        if (m_pDirectSound && ppDirectSound && !*ppDirectSound)
        {
            *ppDirectSound = m_pDirectSound;
            m_pDirectSound->AddRef();
        }
        if (pParams && pParams->fInitNow)
        {
            if (pParams->clsidDefaultSynth != m_AudioParams.clsidDefaultSynth)
            {
                pParams->clsidDefaultSynth = m_AudioParams.clsidDefaultSynth;
                if (pParams->dwValidData & DMUS_AUDIOPARAMS_DEFAULTSYNTH)
                {
                    Trace(2,"Warning: Default synth choice has been changed.\n");
                    hr = S_FALSE;
                }
            }
            if (pParams->dwFeatures != m_AudioParams.dwFeatures)
            {
                pParams->dwFeatures = m_AudioParams.dwFeatures;
                if (pParams->dwValidData & DMUS_AUDIOPARAMS_FEATURES)
                {
                    Trace(2,"Warning: Features flags has been changed to %lx.\n",pParams->dwFeatures);
                    hr = S_FALSE;
                }
            }
            if (pParams->dwSampleRate != m_AudioParams.dwSampleRate)
            {
                pParams->dwSampleRate = m_AudioParams.dwSampleRate;
                if (pParams->dwValidData & DMUS_AUDIOPARAMS_SAMPLERATE)
                {
                    Trace(2,"Warning: Sample rate has been changed to %ld.\n",pParams->dwSampleRate);
                    hr = S_FALSE;
                }
            }
            if (pParams->dwVoices != m_AudioParams.dwVoices)
            {
                pParams->dwVoices = m_AudioParams.dwVoices;
                if (pParams->dwValidData & DMUS_AUDIOPARAMS_VOICES)
                {
                    Trace(2,"Warning: Number of requested voices has been changed to %ld.\n",pParams->dwVoices);
                    hr = S_FALSE;
                }
            }
            pParams->dwValidData = m_AudioParams.dwValidData;
        }
        LeaveCriticalSection(&m_MainCrSec);
    }
    else
    {
        LeaveCriticalSection(&m_MainCrSec);
        CloseDown();
    }
    return hr;
}

HRESULT STDMETHODCALLTYPE CPerformance::Init(
    IDirectMusic** ppDirectMusic,   LPDIRECTSOUND pDirectSound,HWND hWnd)
{
    V_INAME(IDirectMusicPerformance::Init);
    V_PTRPTR_WRITE_OPT(ppDirectMusic);
    V_INTERFACE_OPT(pDirectSound);
    V_HWND_OPT(hWnd);
    HRESULT hr = S_OK;

    // Further validate, checking for a pointer to a bad interface pointer...
    if (ppDirectMusic)
    {
        V_INTERFACE_OPT(*ppDirectMusic);
    }
    if( m_dwAudioPathMode )
    {
        Trace(1,"Error: Init called on an already initialized Performance.\n");
        return DMUS_E_ALREADY_INITED;
    }
    Init();
    m_dwAudioPathMode = 1;
    EnterCriticalSection(&m_MainCrSec);

    if(( NULL == ppDirectMusic ) || ( NULL == *ppDirectMusic ))
    {
        // intialize DirectMusic.

        if( FAILED( CoCreateInstance(CLSID_DirectMusic,
                              NULL,
                              CLSCTX_INPROC,
                              IID_IDirectMusic,
                              (LPVOID*)&m_pDirectMusic)))
        {
            m_pDirectMusic = NULL;
            LeaveCriticalSection(&m_MainCrSec);
            return E_OUTOFMEMORY;
        }

        // If version2 was requested by the app (in the process of requesting the
        // IDirectMusicPerformance2 interface), do the same for IDirectMusic.
        if (m_dwVersion > 6)
        {
            IDirectMusic *pTemp = NULL;
            if (SUCCEEDED(m_pDirectMusic->QueryInterface(
                IID_IDirectMusic2,
                (LPVOID*)&pTemp)))
            {
                // Succeeded in requesting DX7 and up behavior...
                pTemp->Release();
            }
        }

        hr = m_pDirectMusic->SetDirectSound(pDirectSound, hWnd);
        if( FAILED( hr ) )
        {
            m_pDirectMusic->Release();
            m_pDirectMusic = NULL;
            LeaveCriticalSection(&m_MainCrSec);
            return hr;
        }

        if( ppDirectMusic )
        {
            *ppDirectMusic = m_pDirectMusic;
            m_pDirectMusic->AddRef();
        }
    }
    else
    {
        m_pDirectMusic = (IDirectMusic8 *) *ppDirectMusic;
        m_pDirectMusic->AddRef();
    }
    if (FAILED(hr = CreateThreads()))
    {
        if( m_pDirectMusic )
        {
            m_pDirectMusic->Release();
            m_pDirectMusic = NULL;
        }
    }
    LeaveCriticalSection(&m_MainCrSec);
    return hr;
}

CSegState *CPerformance::GetSegmentForTransition(DWORD dwFlags,MUSIC_TIME mtTime, IUnknown *pFrom)

{
    CSegState *pSegState = NULL;

    // If the source segment was provided, use it.
    if (pFrom)
    {
        if (SUCCEEDED(pFrom->QueryInterface(IID_CSegState,(void **) &pSegState)))
        {
            pSegState->Release();
        }
    }
    // Else, if this is a primary segment, get the current primary segment.
    if (!pSegState && !(dwFlags & DMUS_SEGF_SECONDARY))
    {
        pSegState = GetPrimarySegmentAtTime(mtTime);
    }
    return pSegState;
}

void CPerformance::ClearMusicStoppedNotification()

{
    EnterCriticalSection(&m_PipelineCrSec);
    PRIV_PMSG* pPMsg;
    PRIV_PMSG* pNext;
    DMUS_NOTIFICATION_PMSG* pNotification;

    pPMsg = m_OnTimeQueue.GetHead(); // where notifications live normally
    for (; pPMsg ; pPMsg = pNext)
    {
        pNext = pPMsg->pNext;
        pNotification = (DMUS_NOTIFICATION_PMSG*)PRIV_TO_DMUS(pPMsg);
        if( ( pPMsg->dwType == DMUS_PMSGT_NOTIFICATION ) &&
            ( pNotification->guidNotificationType == GUID_NOTIFICATION_PERFORMANCE ) &&
            ( pNotification->dwNotificationOption == DMUS_NOTIFICATION_MUSICSTOPPED ) )
        {
            pPMsg = m_OnTimeQueue.Dequeue(pPMsg);
            if( pPMsg ) // Should always succeeed
            {
                FreePMsg(pPMsg);
            }
            m_fMusicStopped = FALSE;
        }
    }
    LeaveCriticalSection(&m_PipelineCrSec);
}

HRESULT CPerformance::PlayOneSegment(
    CSegment* pSegment,
    DWORD dwFlags,
    __int64 i64StartTime,
    CSegState **ppSegState,
    CAudioPath *pAudioPath)
{
    HRESULT hr;
#ifdef DBG_PROFILE
    DWORD dwDebugTime;
    dwDebugTime = timeGetTime();
#endif

    TraceI(0,"Play Segment %lx (%ls) at time %ld with flags %lx\n",pSegment,pSegment->m_wszName,(long)i64StartTime,dwFlags);
    if( dwFlags & DMUS_SEGF_CONTROL )
    {
        dwFlags |= DMUS_SEGF_SECONDARY;
    }
    if( i64StartTime )
    {
        if(dwFlags & DMUS_SEGF_REFTIME)
        {
            // Give a grace period of 100ms.
            if( i64StartTime < (GetLatency() - (100 * REF_PER_MIL)))
            {
                Trace(1,"Error: Unable to play segment, requested clock time %ld is past current time %ld\n",
                    (long)i64StartTime,(long)(GetLatency() - (100 * REF_PER_MIL)));
                return DMUS_E_TIME_PAST;
            }
        }
        else
        {
            MUSIC_TIME mtPrePlay;
            // Give a grace period of 100ms.
            ReferenceToMusicTime( (GetLatency() - (100 * REF_PER_MIL)), &mtPrePlay );
            if( (MUSIC_TIME)i64StartTime < mtPrePlay )
            {
                Trace(1,"Error: Unable to play segment, requested music time %ld is past current time %ld\n",
                    (long)i64StartTime,(long)mtPrePlay);
                return DMUS_E_TIME_PAST;
            }
        }
    }

    CSegState *pSegState = NULL;
    hr = pSegment->CreateSegmentState( &pSegState, this, pAudioPath, dwFlags);
    *ppSegState = pSegState;
    if (FAILED(hr))
    {
        Trace(1,"Error: Unable to play segment because of failure creating segment state.\n");
        return DMUS_E_SEGMENT_INIT_FAILED;
    }
    pSegState->m_rtGivenStart = i64StartTime;

    pSegState->m_dwPlaySegFlags = dwFlags;

    // add the pSegState to the appropriate queue
    EnterCriticalSection(&m_SegmentCrSec);
    m_fPlaying = 1; // turn on the transport
    // add all notifications to the segment. First, clear it, in case old notifications
    // are in effect.
    pSegment->RemoveNotificationType(GUID_NULL,TRUE);
    CNotificationItem* pItem;
    pItem = m_NotificationList.GetHead();
    while( pItem )
    {
        pSegment->AddNotificationType( pItem->guidNotificationType, TRUE );
        pItem = pItem->GetNext();
    }

    if( pSegState->m_dwPlaySegFlags & DMUS_SEGF_AFTERPREPARETIME )
    {
        // we want to queue this at the last transported time,
        // so we don't need to do an invalidate
        if( pSegState->m_dwPlaySegFlags & DMUS_SEGF_REFTIME )
        {
            REFERENCE_TIME rtTrans;
            MusicToReferenceTime( m_mtTransported, &rtTrans );
            if( pSegState->m_rtGivenStart < rtTrans )
            {
                pSegState->m_dwPlaySegFlags &= ~DMUS_SEGF_REFTIME;
                pSegState->m_rtGivenStart = m_mtTransported;
            }
        }
        else
        {
            if( pSegState->m_rtGivenStart < m_mtTransported )
            {
                pSegState->m_rtGivenStart = m_mtTransported;
            }
        }
    }
    else if( pSegState->m_dwPlaySegFlags & DMUS_SEGF_AFTERQUEUETIME )
    {
        // we want to queue this at the queue time, as opposed to latency time,
        // which is an option for secondary segments.
        REFERENCE_TIME rtStart;
        GetQueueTime( &rtStart ); // need queue time because control segments cause invalidations
        if( pSegState->m_dwPlaySegFlags & DMUS_SEGF_REFTIME )
        {
            if( pSegState->m_rtGivenStart < rtStart )
            {
                pSegState->m_rtGivenStart = rtStart;
            }
        }
        else
        {
            MUSIC_TIME mtStart;
            ReferenceToMusicTime( rtStart, &mtStart );
            if( pSegState->m_rtGivenStart < mtStart )
            {
                pSegState->m_rtGivenStart = mtStart;
            }
        }
    }
    // need to get rid of any pending musicstopped notifications
    ClearMusicStoppedNotification();

    pSegState->AddRef();

    if( dwFlags & DMUS_SEGF_SECONDARY ) // queue a secondary segment
    {
        QueueSecondarySegment( pSegState );
    }
    else // queue a primary segment
    {
        QueuePrimarySegment( pSegState );
    }

    LeaveCriticalSection(&m_SegmentCrSec);

#ifdef DBG_PROFILE
    dwDebugTime = timeGetTime() - dwDebugTime;
    TraceI(5, "perf, debugtime PlaySegment %u\n", dwDebugTime);
#endif

    // signal the transport thread so we don't have to wait for it to wake up on its own
    if( m_hTransport ) SetEvent( m_hTransport );

    return S_OK;
}


HRESULT CPerformance::PlaySegmentInternal(
    CSegment* pSegment,
    CSong * pSong,
    WCHAR *pwzSegmentName,
    CSegment* pTransition,
    DWORD dwFlags,
    __int64 i64StartTime,
    IDirectMusicSegmentState** ppSegmentState,
    IUnknown *pFrom,
    CAudioPath *pAudioPath)
{
    HRESULT hr;
    CAudioPath *pInternalPath = NULL;
    if( m_pClock == NULL )
    {
        Trace(1,"Error: Can not play segment because master clock has not been initialized.\n");
        return DMUS_E_NO_MASTER_CLOCK;
    }
    if (pAudioPath && (pAudioPath->NoPorts()))
    {
        // This audiopath can't be used for playback since it doesn't have any ports.
        Trace(1,"Error: Audiopath can't be used for playback because it doesn't have any ports.\n");
        return DMUS_E_AUDIOPATH_NOPORT;
    }

    // Pointer to segment or song provided audio path config.
    IUnknown *pConfig = NULL;

    /*  If this is a song, use the segment name to get the segment.
        Then, it looks like a normal segment except the
        existence of the pSong will let the segstate know
        that it is a member of a song, so it should chain segments.
    */
    if (pSong)
    {
        IDirectMusicSegment *pISegment = NULL;
        hr = pSong->GetSegment(pwzSegmentName,&pISegment);
        if (hr != S_OK)
        {
            return DMUS_E_NOT_FOUND;
        }
        pSegment = (CSegment *) pISegment;
        // If the app wants an audiopath created dynamically from the song, find it and use it.
        if (dwFlags & DMUS_SEGF_USE_AUDIOPATH)
        {
            pSong->GetAudioPathConfig(&pConfig);
        }
    }
    else if (pSegment)
    {
        // Addref so we can release later.
        pSegment->AddRef();
    }
    else
    {
        // No Segment!
        Trace(1,"Error: No segment - nothing to play!\n");
        return E_FAIL;
    }
    if (dwFlags & DMUS_SEGF_DEFAULT )
    {
        DWORD   dwResTemp;
        pSegment->GetDefaultResolution( &dwResTemp );
        dwFlags &= ~DMUS_SEGF_DEFAULT;
        dwFlags |= dwResTemp;
    }
    // If the app wants an audiopath created dynamically from the segment, find it and use it.
    // Note that this overrides an audiopath created from the song.
    if (dwFlags & DMUS_SEGF_USE_AUDIOPATH)
    {
        IUnknown *pSegConfig;
        if (SUCCEEDED(pSegment->GetAudioPathConfig(&pSegConfig)))
        {
            if (pConfig)
            {
                pConfig->Release();
            }
            pConfig = pSegConfig;
        }
    }

    // If we got an audiopath config from the segment or song, use it.
    if (pConfig)
    {
        IDirectMusicAudioPath *pNewPath;
        if (SUCCEEDED(CreateAudioPath(pConfig,TRUE,&pNewPath)))
        {
            // Now, get the CAudioPath structure.
            if (SUCCEEDED(pNewPath->QueryInterface(IID_CAudioPath,(void **) &pInternalPath)))
            {
                pAudioPath = pInternalPath;
            }
            pNewPath->Release();
        }
        else
        {
            pConfig->Release();
            Trace(1,"Error: Embedded audiopath failed to create, segment will not play.\n");
            return DMUS_E_NO_AUDIOPATH;
        }
        pConfig->Release();
    }

    if (pTransition)
    {
        pTransition->AddRef();
    }

    if ((dwFlags & DMUS_SEGF_SECONDARY) && (dwFlags & DMUS_SEGF_QUEUE))
    {
        // Can only queue if there's a segment to queue after.
        if (pFrom)
        {
            CSegState *pSegFrom = NULL;
            if (SUCCEEDED(pFrom->QueryInterface(IID_CSegState,(void **) &pSegFrom)))
            {
                // Calculate the time at which the preceding segment will stop.
                MUSIC_TIME mtStartTime = pSegFrom->GetEndTime( pSegFrom->m_mtResolvedStart );
                i64StartTime = mtStartTime;
                dwFlags &= ~DMUS_SEGF_REFTIME;
                pSegFrom->Release();
            }
        }
    }

    // If auto-transition is requested,
    // get the transition template, if it exists,
    // and compose a segment with it.
    CSegment *pPlayAfter = NULL;    // This will hold the second segment, if we end up with a transition.
    DWORD dwFlagsAfter = dwFlags & (DMUS_SEGF_SECONDARY | DMUS_SEGF_CONTROL);
    if ( dwFlags & DMUS_SEGF_AUTOTRANSITION )
    {
        // First, calculate the time to start the transition.
        // Note: this will be done again later. We really need to fold this all together.
        REFERENCE_TIME rtTime;
        if (i64StartTime == 0)
        {
            GetQueueTime( &rtTime );
        }
        else if (dwFlags & DMUS_SEGF_REFTIME)
        {
            rtTime = i64StartTime;
        }
        else
        {
            MusicToReferenceTime((MUSIC_TIME) i64StartTime,&rtTime);
        }
        REFERENCE_TIME rtResolved;
        GetResolvedTime(rtTime, &rtResolved,dwFlags);
        MUSIC_TIME mtTime;  // Actual time to start transition.
        ReferenceToMusicTime(rtResolved,&mtTime);

        CSegment *pPriorSeg = NULL;
        // Find the segment that is active at transition time.
        CSegState *pPriorState = GetSegmentForTransition(dwFlags,mtTime,pFrom);
        if (pPriorState)
        {
            pPriorSeg = pPriorState->m_pSegment;
        }
        // If this is a song, use the id to get the transition.
        if (pSong && !pTransition)
        {
            DMUS_IO_TRANSITION_DEF Transition;
            // Now, find out what sort of transition is expected.
            if (SUCCEEDED(pSong->GetTransitionSegment(pPriorSeg,pSegment,&Transition)))
            {
                if (Transition.dwTransitionID != DMUS_SONG_NOSEG)
                {
                    if (S_OK == pSong->GetPlaySegment(Transition.dwTransitionID,&pTransition))
                    {
                        dwFlags = Transition.dwPlayFlags;
                    }
                }
                else
                {
                    dwFlags = Transition.dwPlayFlags;
                }
            }
        }
        if (pTransition)
        {
            IDirectMusicSegment *pITransSegment = NULL;
            if (pPriorState)
            {
                pTransition->Compose(mtTime - pPriorState->m_mtOffset, pPriorSeg, pSegment, &pITransSegment);
            }
            else
            {
                pTransition->Compose(0,pPriorSeg,pSegment,&pITransSegment);
            }
            // Now, if we successfully composed a transition segment, set it up to be the one we
            // will play first. Later, we fill call PlaySegment() with pPlayAfter, to queue it
            // to play after the transition.
            if (pITransSegment)
            {
                pPlayAfter = pSegment;
                pSegment = (CSegment *) pITransSegment;
            }
        }
    }
    if (pSegment)
    {
        CSegState *pSegState;
        if (!pAudioPath)
        {
            pAudioPath = m_pDefaultAudioPath;
        }
        if (pAudioPath && !pAudioPath->IsActive())
        {
            Trace(1,"Error: Can not play segment on inactive audiopath\n");
            hr = DMUS_E_AUDIOPATH_INACTIVE;
        }
        else if ((m_dwAudioPathMode != 1) && !pAudioPath)
        {
            Trace(1,"Error: No audiopath to play segment on.\n");
            hr = DMUS_E_NO_AUDIOPATH;
        }
        else
        {
            if (ppSegmentState)
            {
                *ppSegmentState = NULL;
            }
            hr = PlayOneSegment(
                pSegment,
                dwFlags,
                i64StartTime,
                &pSegState,
                pAudioPath);
            if (SUCCEEDED(hr))
            {
                if (pFrom)
                {
                    pSegState->m_fCanStop = FALSE;
                    StopEx(pFrom, pSegState->m_mtResolvedStart, 0);
                    pSegState->m_fCanStop = TRUE;
                }
                // If this was actually a transition segment, now we need to play the original segment!
                if (pPlayAfter)
                {
                    MUSIC_TIME mtStartTime = pSegState->GetEndTime(pSegState->m_mtResolvedStart );
                    pSegState->Release();
                    hr = PlayOneSegment(pPlayAfter,dwFlagsAfter,mtStartTime,&pSegState,pAudioPath);
                }
                if (SUCCEEDED(hr))
                {
                    if (pSong)
                    {
                        pSegState->m_fSongMode = TRUE;
                    }
                    if (ppSegmentState)
                    {
                        *ppSegmentState = pSegState;
                    }
                    else
                    {
                        pSegState->Release();
                    }
                }
            }
        }
    }
    else
    {
        // There never was a segment to play, not even a transition.
        Trace(1,"Error: No segment to play.\n");
        hr = E_INVALIDARG;
    }
    // Before leaving, reduce the reference counts on variables that have been addref'd.
    if (pSegment)
    {
        pSegment->Release();
    }
    if (pTransition)
    {
        pTransition->Release();
    }
    if (pPlayAfter)
    {
        pPlayAfter->Release();
    }
    if (pInternalPath)
    {
        pInternalPath->Release();
    }
    return hr;
}

HRESULT STDMETHODCALLTYPE CPerformance::PlaySegment(
    IDirectMusicSegment *pSegment,
    DWORD dwFlags,
    __int64 i64StartTime,
    IDirectMusicSegmentState **ppSegmentState)
{
    V_INAME(IDirectMusicPerformance::PlaySegment);
    V_INTERFACE(pSegment);
    V_PTRPTR_WRITE_OPT(ppSegmentState);
    CSegment *pCSourceSegment = NULL;
    if (SUCCEEDED(pSegment->QueryInterface(IID_CSegment,(void **) &pCSourceSegment)))
    {
        pCSourceSegment->Release();
    }
    else
    {
        Trace(1,"Error: Invalid segment object passed to PlaySegment(). Segment must be created using CLSID_DirectMusicSegment object.\n");
        return E_POINTER;
    }
    return PlaySegmentInternal(pCSourceSegment,NULL,0,NULL,dwFlags,i64StartTime,ppSegmentState,NULL,NULL);
}

HRESULT STDMETHODCALLTYPE CPerformance::PlaySegmentEx(
    IUnknown* pSource,
    WCHAR *pwzSegmentName,
    IUnknown* pTransition,
    DWORD dwFlags,
    __int64 i64StartTime,
    IDirectMusicSegmentState** ppSegmentState,
    IUnknown *pFrom,
    IUnknown *pAudioPath)
{
    V_INAME(IDirectMusicPerformance::PlaySegmentEx);
    V_INTERFACE_OPT(pSource);
    V_INTERFACE_OPT(pTransition);
    V_PTRPTR_WRITE_OPT(ppSegmentState);
    V_INTERFACE_OPT(pFrom);
    V_INTERFACE_OPT(pAudioPath);

    CSegment *pCSourceSegment = NULL;
    CSong *pCSourceSong = NULL;
    CSegment *pCTransition = NULL;
    CAudioPath *pCAudioPath = NULL;
//    TraceI(0,"Playing %lx at time %ld, flags %lx, Transition %lx\n",pSource,(long)i64StartTime,dwFlags,pTransition);

    // We may not have a source segment in the special case of transitioning from NULL.
    if (!pSource && !pTransition)
    {
        Trace(1,"Error: Must pass either a segment or transition segment to PlaySegmentEx()\n");
        return E_POINTER;
    }
    if (pSource)
    {
        // Figure out if we have a source song or segment and get the internal representations.
        if (SUCCEEDED(pSource->QueryInterface(IID_CSegment,(void **) &pCSourceSegment)))
        {
            pCSourceSegment->Release();
        }
        else if (SUCCEEDED(pSource->QueryInterface(IID_CSong,(void **) &pCSourceSong)))
        {
            pCSourceSong->Release();
        }
        else
        {
            Trace(1,"Error: Invalid segment or song passed to PlaySegmentEx().\n");
            return E_POINTER;
        }
    }
    // If we have a transition segment, get the CSegment representation.
    if (pTransition)
    {
        if (SUCCEEDED(pTransition->QueryInterface(IID_CSegment,(void **) &pCTransition)))
        {
            pCTransition->Release();
        }
        else
        {
            Trace(1,"Error: Invalid transition passed to PlaySegmentEx().\n");
            return E_POINTER;
        }
    }
    if (pAudioPath)
    {
        if (SUCCEEDED(pAudioPath->QueryInterface(IID_CAudioPath,(void **) &pCAudioPath)))
        {
            pCAudioPath->Release();
        }
        else
        {
            Trace(1,"Error: Invalid audiopath passed to PlaySegmentEx().\n");
            return E_POINTER;
        }
    }
    return PlaySegmentInternal(pCSourceSegment,pCSourceSong,pwzSegmentName,
        pCTransition,dwFlags,i64StartTime,
        ppSegmentState,pFrom,
        pCAudioPath);
}

STDMETHODIMP CPerformance::SetDefaultAudioPath(IDirectMusicAudioPath *pAudioPath)
{
    V_INAME(IDirectMusicPerformance::SetDefaultAudioPath);
    V_INTERFACE_OPT(pAudioPath);
    if (m_dwAudioPathMode == 0)
    {
        Trace(1,"Error: Performance not initialized.\n");
        return DMUS_E_NOT_INIT;
    }
    if (m_dwAudioPathMode == 1)
    {
        Trace(1,"Error: Performance initialized not to support Audiopaths.\n");
        return DMUS_E_AUDIOPATHS_NOT_VALID;
    }
    CAudioPath *pCPath = NULL;
    if (pAudioPath)
    {
        if (SUCCEEDED(pAudioPath->QueryInterface(IID_CAudioPath,(void **) &pCPath)))
        {
            pCPath->Release();
            if (!m_AudioPathList.IsMember(pCPath))
            {
                // This is not a legal audiopath, since it wasn't created by this performance.
                Trace(1,"Error: Invalid audiopath - not created by this Performance.\n");
                return E_INVALIDARG;
            }
            if (pCPath->NoPorts())
            {
                // This is an audiopath that doesn't have any port configurations.
                // For example, it might be environmental reverb.
                Trace(1,"Error: Failure setting default audiopath - does not have any ports, so can not be played on.\n");
                return DMUS_E_AUDIOPATH_NOPORT;
            }
        }
        else
        {
            // This is not a legal audiopath object at all.
            Trace(1,"Error: Invalid audiopath - not created by call to Performance->CreateAudioPath().\n");
            return E_INVALIDARG;
        }
    }
    if (m_pDefaultAudioPath)
    {
        m_pDefaultAudioPath->Release();
        m_pDefaultAudioPath = NULL;
    }
    m_pDefaultAudioPath = pCPath;
    if (pCPath)
    {
        pCPath->AddRef();
        pCPath->Activate(TRUE);
    }
    return S_OK;
}

STDMETHODIMP CPerformance::GetDefaultAudioPath(IDirectMusicAudioPath **ppAudioPath)
{
    V_INAME(IDirectMusicPerformance::GetDefaultAudioPath);
    V_PTRPTR_WRITE(ppAudioPath);
    if (m_dwAudioPathMode == 0)
    {
        Trace(1,"Error: Performance not initialized.\n");
        return DMUS_E_NOT_INIT;
    }
    if (m_dwAudioPathMode == 1)
    {
        Trace(1,"Error: Performance was initialized not to support audiopaths.\n");
        return DMUS_E_AUDIOPATHS_NOT_VALID;
    }
    if (m_pDefaultAudioPath)
    {
        *ppAudioPath = (IDirectMusicAudioPath *) m_pDefaultAudioPath;
        m_pDefaultAudioPath->AddRef();
        return S_OK;
    }
    Trace(3,"Warning: No default audiopath\n");
    return DMUS_E_NOT_FOUND;
}

HRESULT STDMETHODCALLTYPE CPerformance::CreateAudioPath( IUnknown *pSourceConfig,
                                                        BOOL fActivate,
                                                        IDirectMusicAudioPath **ppNewPath)

{
    V_INAME(IDirectMusicPerformance::CreateAudioPath);
    V_INTERFACE(pSourceConfig);
    V_PTRPTR_WRITE_OPT(ppNewPath);

    if (m_dwAudioPathMode == 0)
    {
        Trace(1,"Error: Performance not initialized.\n");
        return DMUS_E_NOT_INIT;
    }
    if (m_dwAudioPathMode == 1)
    {
        Trace(1,"Error: Performance not initialized to support audiopaths (must use InitAudio.)\n");
        return DMUS_E_AUDIOPATHS_NOT_VALID;
    }
    HRESULT hr = E_OUTOFMEMORY;
    CAudioPath *pPath = new CAudioPath;
    if (pPath)
    {
        hr = pPath->Init(pSourceConfig,this);
        if (SUCCEEDED(hr) && fActivate)
        {
            hr = pPath->Activate(TRUE);
#ifdef DBG
            if (FAILED(hr))
            {
                Trace(1,"Error: Audiopath creation failed because one or more buffers could not be activated.\n");
            }
#endif
        }
        if (SUCCEEDED(hr))
        {
            hr = pPath->QueryInterface(IID_IDirectMusicAudioPath,(void **) ppNewPath);
        }
        else
        {
            delete pPath;
        }
    }
    return hr;
}

STDMETHODIMP CPerformance::CreateStandardAudioPath(DWORD dwType,
                                                   DWORD dwPChannelCount,
                                                   BOOL fActivate,
                                                   IDirectMusicAudioPath **ppNewPath)
{
    V_INAME(IDirectMusicPerformance::CreateStandardAudioPath);
    V_PTRPTR_WRITE_OPT(ppNewPath);
    HRESULT hr = S_OK;
    if (m_dwAudioPathMode == 2)
    {
        if ((dwType <= DMUS_APATH_DYNAMIC_STEREO) && (dwType >= DMUS_APATH_DYNAMIC_3D)
            || (dwType == DMUS_APATH_SHARED_STEREOPLUSREVERB))
        {
            if (!(m_AudioParams.dwFeatures & DMUS_AUDIOF_BUFFERS))
            {
                Trace(4,"Warning: Creating a standard audiopath without buffers - InitAudio specified no buffer support.\n");
                // If the default synth doesn't support buffers, then create a simple port with no buffers.
                dwType = 0;
            }
            CAudioPathConfig *pConfig = CAudioPathConfig::CreateStandardConfig(dwType,dwPChannelCount,m_AudioParams.dwSampleRate);
            if (pConfig)
            {
                hr = CreateAudioPath((IPersistStream *) pConfig,fActivate,ppNewPath);
                pConfig->Release();
            }
            else
            {
                // CreateStandardConfig only returns NULL if we've run out of memory.
                hr = E_OUTOFMEMORY;
            }
        }
        else
        {
            Trace(1,"Error: %ld is not a valid predefined audiopath.\n",dwType);
            hr  = E_INVALIDARG;
        }
    }
    else
    {
        Trace(1,"Error: Performance not initialized to support audiopaths.\n");
        hr = DMUS_E_AUDIOPATHS_NOT_VALID;
    }
    return hr;
}

// Stop the segment state at mtTime. If NULL, stop all.
void CPerformance::DoStop( CSegState* pSegState, MUSIC_TIME mtTime,
                                     BOOL fInvalidate)
{
    HRESULT hrAbort = S_OK;
    DWORD dwCount;
    if( NULL == pSegState ) return;
    EnterCriticalSection(&m_SegmentCrSec);
    CSegStateList *pSourceList = NULL;
    CSegStateList *pDestList = NULL;
    CSegState *pNode = NULL;
    // Mark the length of the segstate to be only as far as it played
    // to keep GetParam() from accessing the unplayed portion.
    if (pSegState)
    {
        if (mtTime < pSegState->m_mtEndTime)
        {
            pSegState->m_mtLength = mtTime - pSegState->m_mtResolvedStart +
                pSegState->m_mtStartPoint;
            if (pSegState->m_mtLength < 0)
            {
                pSegState->m_mtLength = 0;
            }
            // Make endtime one greater than mtTime so Abort notification will still happen.
            pSegState->m_mtEndTime = mtTime + 1;
        }
    }
    RecalcTempoMap(pSegState,mtTime);
    // check each play queue
    for (dwCount = SQ_PRI_PLAY; dwCount <= SQ_SEC_PLAY; dwCount++)
    {
        for( pNode = m_SegStateQueues[dwCount].GetHead(); pNode; pNode = pNode->GetNext())
        {
            if( pNode == pSegState )
            {
                // we want to move this to the approprate done queue
                pDestList = &m_SegStateQueues[SQ_PRI_DONE - SQ_PRI_PLAY + dwCount];
                pSourceList = &m_SegStateQueues[dwCount];
                if ((dwCount == SQ_PRI_PLAY) && (m_SegStateQueues[SQ_PRI_PLAY].GetCount() == 1))
                {
                    if (m_dwVersion >= 8)
                    {
                        MUSIC_TIME mtNow;
                        GetTime( NULL, &mtNow );
                        GenerateNotification( DMUS_NOTIFICATION_MUSICALMOSTEND, mtNow, pSegState );
                    }
                }
                dwCount = SQ_SEC_PLAY;  // Force out of outer loop.
                break;
            }
        }
    }
    if (!pNode)
    {
        // check each done queue
        for (dwCount = SQ_PRI_DONE; dwCount <= SQ_SEC_DONE; dwCount++)
        {
            for( pNode = m_SegStateQueues[dwCount].GetHead(); pNode; pNode = pNode->GetNext())
            {
                if( pNode == pSegState )
                {
                    pSourceList = &m_SegStateQueues[dwCount];
                    dwCount = SQ_SEC_DONE;  // Force out of outer loop.
                    break;
                }
            }
        }
    }
    if( pNode && pSourceList)
    {
        REFERENCE_TIME rtTime;
        MusicToReferenceTime(mtTime,&rtTime);
        if( pNode->m_mtLastPlayed >= mtTime )
        {
            pNode->Flush( mtTime );
            pNode->m_mtLastPlayed = mtTime; // must set this to indicate it only played until then
            pNode->m_rtLastPlayed = rtTime;
        }
        if( fInvalidate )
        {
            if( pNode->m_dwPlaySegFlags & DMUS_SEGF_CONTROL )
            {
                Invalidate( mtTime, 0 ); // must call Invalidate before AbortPlay so we don't
                // invalidate the abort notification
            }
            else if ( !(pNode->m_dwPlaySegFlags & DMUS_SEGF_SECONDARY ))
            {
                // If this is a primary segment, kill the tempo map.
                FlushEventQueue( 0, &m_TempoMap, rtTime, rtTime, 0 );
            }
        }
        hrAbort = pNode->AbortPlay( mtTime, FALSE );
        if( pNode->m_dwPlaySegFlags & DMUS_SEGF_CONTROL )
        {
            pSourceList->Remove(pNode);
            m_ShutDownQueue.Insert(pNode); // we're guaranteed to never need this again

            // set dirty flags on all other segments

            for (dwCount = SQ_PRI_PLAY; dwCount <= SQ_SEC_PLAY; dwCount++)
            {
                for( pNode = m_SegStateQueues[dwCount].GetHead(); pNode; pNode = pNode->GetNext() )
                {
                    if( pNode->m_fStartedPlay )
                    {
                        pNode->m_dwPlayTrackFlags |= DMUS_TRACKF_DIRTY;
                    }
                }
            }
        }
        else if( pDestList )
        {
            pSourceList->Remove(pNode);
            pDestList->Insert(pNode);
        }
    }
    else
    {
        // check the wait lists.
        for (dwCount = SQ_PRI_WAIT; dwCount <= SQ_SEC_WAIT; dwCount++)
        {
            for( pNode = m_SegStateQueues[dwCount].GetHead(); pNode; pNode = pNode->GetNext() )
            {
                if( pNode == pSegState )
                {
                    hrAbort = pNode->AbortPlay( mtTime, FALSE );
                    m_SegStateQueues[dwCount].Remove(pNode);
                    RecalcTempoMap(pNode, mtTime);
                    m_ShutDownQueue.Insert(pNode);
                    break;
                }
            }
        }
    }
    // if there aren't any more segments to play, send a Music Stopped
    // notification
    if( m_SegStateQueues[SQ_PRI_PLAY].IsEmpty() && m_SegStateQueues[SQ_SEC_PLAY].IsEmpty() &&
        m_SegStateQueues[SQ_PRI_WAIT].IsEmpty() && m_SegStateQueues[SQ_SEC_WAIT].IsEmpty() &&
        m_SegStateQueues[SQ_CON_PLAY].IsEmpty() && m_SegStateQueues[SQ_CON_WAIT].IsEmpty())
    {
        m_fMusicStopped = TRUE;
        // S_FALSE means we tried to abort this segstate, but it's already been aborted
        if (hrAbort != S_FALSE)
        {
            GenerateNotification( DMUS_NOTIFICATION_MUSICSTOPPED, mtTime, NULL );
        }
    }
    LeaveCriticalSection(&m_SegmentCrSec);
}

// Stop all segment states based off of the segment.
void CPerformance::DoStop( CSegment* pSeg, MUSIC_TIME mtTime, BOOL fInvalidate )
{
    DWORD dwCount;
    CSegState* pNode;
    CSegState* pNext;
    EnterCriticalSection(&m_SegmentCrSec);
    // find all seg pSegStates based off this segment that have played through time mtTime
    // if pSeg is NULL, go through all of the segment lists. Flush any
    // segment that played through time mtTime. Move any active segments
    // into past lists.
    if( pSeg )
    {
        for (dwCount = 0; dwCount < SQ_COUNT; dwCount++)
        {
            pNode = m_SegStateQueues[dwCount].GetHead();
            while( pNode )
            {
                pNext = pNode->GetNext();
                if( pNode->m_pSegment == pSeg )
                {
                    if (IsDoneQueue(dwCount))
                    {
                        if (pNode->m_mtLastPlayed >= mtTime)
                        {
                             DoStop( pNode, mtTime, fInvalidate );
                        }
                    }
                    else
                    {
                        DoStop( pNode, mtTime, fInvalidate );
                    }
                }
                pNode = pNext;
            }
        }
    }
    else // pSeg is NULL, stop everything.
    {
        // go ahead and flush the event queues
        EnterCriticalSection(&m_PipelineCrSec);
        FlushMainEventQueues( 0, mtTime, mtTime, 0 );
        LeaveCriticalSection(&m_PipelineCrSec);
        // clear out the wait lists
        for (dwCount = SQ_PRI_WAIT; dwCount <= SQ_SEC_WAIT; dwCount++)
        {
            while (pNode = m_SegStateQueues[dwCount].GetHead())
            {
                pNode->AbortPlay( mtTime, FALSE );
                m_SegStateQueues[dwCount].RemoveHead();
                m_ShutDownQueue.Insert(pNode);
            }
        }
        // stop any segment that is currently playing.
        for (dwCount = SQ_PRI_DONE; dwCount <= SQ_SEC_DONE; dwCount++)
        {
            for( pNode = m_SegStateQueues[dwCount].GetHead(); pNode; pNode = pNode->GetNext() )
            {
                if( pNode->m_mtLastPlayed >= mtTime )
                {
                    DoStop( pNode, mtTime, fInvalidate );
                }
            }
        }
        for (dwCount = SQ_PRI_PLAY; dwCount <= SQ_SEC_PLAY; dwCount++)
        {
            while( m_SegStateQueues[dwCount].GetHead() )
            {
                DoStop( m_SegStateQueues[dwCount].GetHead(), mtTime, fInvalidate );
            }
        }
        // reset controllers and force all notes off.
        ResetAllControllers( GetLatency() );
    }
    LeaveCriticalSection(&m_SegmentCrSec);
}


STDMETHODIMP CPerformance::StopEx(IUnknown *pObjectToStop,__int64 i64StopTime,DWORD dwFlags)
{
    V_INAME(IDirectMusicPerformance::StopEx);
    V_INTERFACE_OPT(pObjectToStop);
    HRESULT hr = E_INVALIDARG;
    IDirectMusicSegmentState *pState;
    IDirectMusicSegment *pSegment;
    CSong *pSong;
    CAudioPath *pAudioPath;
    if (m_dwAudioPathMode == 0)
    {
        Trace(1,"Error: Performance not initialized.\n");
        return DMUS_E_NOT_INIT;
    }
TraceI(0,"StopExing %lx at time %ld, flags %lx\n",pObjectToStop,(long)i64StopTime,dwFlags);
    if (pObjectToStop == NULL)
    {
        return Stop(NULL,NULL,(MUSIC_TIME)i64StopTime,dwFlags);
    }
    if (dwFlags & DMUS_SEGF_AUTOTRANSITION)
    {
        // I this is an autotransition, it will only work if the currently playing segment in question
        // is a member of a song. So, check the segstate, segment, song, and audiopath
        // to find the segstate. And, if found, see if it is part of a song. If so,
        // then go ahead and do the transition.
        EnterCriticalSection(&m_SegmentCrSec);
        BOOL fTransition = FALSE;
        dwFlags &= ~DMUS_SEGF_AUTOTRANSITION;
        CSegState *pCState = NULL;
        // First, see if this is a segstate.
        HRESULT hrTemp = pObjectToStop->QueryInterface(IID_CSegState,(void **)&pCState);
        if (FAILED(hrTemp))
        {
            // Segstate failed. Is this a Song? If so, find the first correlating segstate.
            CSong *pCSong = NULL;
            CAudioPath *pCAudioPath = NULL;
            CSegment *pCSegment = NULL;
            hrTemp = pObjectToStop->QueryInterface(IID_CSong,(void **)&pCSong);
            if (FAILED(hrTemp))
            {
                hrTemp = pObjectToStop->QueryInterface(IID_CSegment,(void **)&pCSegment);
            }
            if (FAILED(hrTemp))
            {
                hrTemp = pObjectToStop->QueryInterface(IID_CAudioPath,(void **)&pCAudioPath);
            }
            if (SUCCEEDED(hrTemp))
            {
                CSegState *pNode;
                DWORD dwCount;
                for (dwCount = SQ_PRI_WAIT; dwCount <= SQ_SEC_DONE; dwCount++)
                {
                    for( pNode = m_SegStateQueues[dwCount].GetHead(); pNode; pNode = pNode->GetNext() )
                    {
                        if (pNode->m_fCanStop)
                        {
                            // Can only do this if the segstate ultimately points to a song.
                            if (pNode->m_pSegment && pNode->m_pSegment->m_pSong)
                            {
                                if ((pNode->m_pSegment == pCSegment) ||
                                    (pNode->m_pSegment->m_pSong == pCSong) ||
                                    (pCAudioPath && (pNode->m_pAudioPath == pCAudioPath)))
                                {
                                    pCState = pNode;
                                    pCState->AddRef();
                                    break;
                                }
                            }
                        }
                    }
                    if (pCState) break;
                }
            }
            if (pCSong) pCSong->Release();
            else if (pCAudioPath) pCAudioPath->Release();
            else if (pCSegment) pCSegment->Release();
        }
        if (pCState)
        {
            CSegment *pPriorSeg = pCState->m_pSegment;
            if (pPriorSeg)
            {
                pSong = pPriorSeg->m_pSong;
                if (pSong)
                {
                    // If this is an autotransition, compose a transition segment from the
                    // current position in the song and play it.
                    // This will, in turn, call stop on the song, so we don't need to do it here.
                    // First, calculate the time to start the transition.
                    REFERENCE_TIME rtTime;
                    if (i64StopTime == 0)
                    {
                        GetQueueTime( &rtTime );
                    }
                    else if (dwFlags & DMUS_SEGF_REFTIME)
                    {
                        rtTime = i64StopTime;
                    }
                    else
                    {
                        MusicToReferenceTime((MUSIC_TIME) i64StopTime,&rtTime);
                    }
                    REFERENCE_TIME rtResolved;
                    GetResolvedTime(rtTime, &rtResolved,dwFlags);
                    MUSIC_TIME mtTime;  // Actual time to start transition.
                    ReferenceToMusicTime(rtResolved,&mtTime);

                    CSegment *pTransition = NULL;
                    // Now, get the transition.
                    DMUS_IO_TRANSITION_DEF Transition;
                    if (SUCCEEDED(pSong->GetTransitionSegment(pPriorSeg,NULL,&Transition)))
                    {
                        if (Transition.dwTransitionID != DMUS_SONG_NOSEG)
                        {
                            if (S_OK == pSong->GetPlaySegment(Transition.dwTransitionID,&pTransition))
                            {
                                dwFlags = Transition.dwPlayFlags;
                            }
                        }
                    }
                    if (pTransition)
                    {
                        IDirectMusicSegment *pITransSegment = NULL;
                        pTransition->Compose(mtTime - pCState->m_mtOffset, pPriorSeg, NULL, &pITransSegment);
                        // Now, if we successfully composed a transition segment, set it up to be the one we
                        // will play first. Later, we fill call PlaySegment() with pPlayAfter, to queue it
                        // to play after the transition.
                        if (pITransSegment)
                        {
                            hr = PlaySegmentEx(pITransSegment,NULL,NULL,dwFlags,i64StopTime,NULL,(IDirectMusicSegmentState *)pCState,NULL);
                            pITransSegment->Release();
                            fTransition = TRUE;
                        }
                        pTransition->Release();
                    }
                }
            }
            pCState->Release();
        }
        LeaveCriticalSection(&m_SegmentCrSec);
        if (fTransition)
        {
            return hr;
        }
    }
    if (SUCCEEDED(pObjectToStop->QueryInterface(IID_IDirectMusicSegmentState,(void **) &pState)))
    {
        hr = Stop(NULL,pState,(MUSIC_TIME)i64StopTime,dwFlags);
        pState->Release();
    }
    else if (SUCCEEDED(pObjectToStop->QueryInterface(IID_IDirectMusicSegment,(void **) &pSegment)))
    {
        hr = Stop(pSegment,NULL,(MUSIC_TIME)i64StopTime,dwFlags);
        pSegment->Release();
    }
    else if (SUCCEEDED(pObjectToStop->QueryInterface(IID_CAudioPath,(void **) &pAudioPath)))
    {
        pAudioPath->Release();
        EnterCriticalSection(&m_SegmentCrSec);
        CSegState *pNode;
        DWORD dwCount;
        for (dwCount = SQ_PRI_WAIT; dwCount <= SQ_SEC_DONE; dwCount++)
        {
            CSegState *pNext;
            for( pNode = m_SegStateQueues[dwCount].GetHead(); pNode; pNode = pNext )
            {
                pNext = pNode->GetNext();
                if (pNode->m_fCanStop && (pNode->m_pAudioPath == pAudioPath))
                {
                    hr = Stop(NULL,(IDirectMusicSegmentState *)pNode,(MUSIC_TIME)i64StopTime,dwFlags);
                }
            }
        }
        LeaveCriticalSection(&m_SegmentCrSec);
    }
    else if (SUCCEEDED(pObjectToStop->QueryInterface(IID_CSong,(void **) &pSong)))
    {
        pSong->Release();
        EnterCriticalSection(&m_SegmentCrSec);
        CSegState *pNode;
        DWORD dwCount;
        for (dwCount = SQ_PRI_WAIT; dwCount <= SQ_SEC_DONE; dwCount++)
        {
            for( pNode = m_SegStateQueues[dwCount].GetHead(); pNode; pNode = pNode->GetNext() )
            {
                if (pNode->m_fCanStop && pNode->m_pSegment && (pNode->m_pSegment->m_pSong == pSong))
                {
                    hr = Stop(NULL,(IDirectMusicSegmentState *)pNode,(MUSIC_TIME)i64StopTime,dwFlags);
                }
            }
        }
        LeaveCriticalSection(&m_SegmentCrSec);
     }

    return hr;
}


HRESULT STDMETHODCALLTYPE CPerformance::Stop(
    IDirectMusicSegment *pISegment, // @parm The Segment to stop playing. All SegmentState's based upon this Segment are
                                    // stopped playing at time <p mtTime>.
    IDirectMusicSegmentState *pISegmentState, // @parm The SegmentState to stop playing.
    MUSIC_TIME mtTime,  // @parm The time at which to stop the Segments, Segment State, or everything. If
                                    // this time is in the past, stop everything right away. Therefore, a value of
                                    // 0 indicates stop everything NOW.
    DWORD dwFlags)      // @parm Flag that indicates whether we should stop immediately at time <p mtTime>,
                                    // or on the grid, measure, or beat following <p mtTime>. This is only valid in
                                    // relation to the currently playing primary segment. (For flag descriptions,
                                    // see <t DMPLAYSEGFLAGS>.)
{
    V_INAME(IDirectMusicPerformance::Stop);
    V_INTERFACE_OPT(pISegment);
    V_INTERFACE_OPT(pISegmentState);

    EnterCriticalSection(&m_SegmentCrSec);

    CSegment *pSegment = NULL;
    CSegState *pSegmentState = NULL;
TraceI(0,"Stopping Segment %lx, SegState %lx at time %ld, flags %lx\n",pISegment,pISegmentState,mtTime,dwFlags);
    if (pISegmentState)
    {
        if (SUCCEEDED(pISegmentState->QueryInterface(IID_CSegState,(void **)&pSegmentState)))
        {
            pISegmentState->Release();
        }
        else
        {
            Trace(1,"Error: Pointer in SegState parameter to Stop() is invalid.\n");
            return E_INVALIDARG;
        }
    }
    if (pISegment)
    {
        if (SUCCEEDED(pISegment->QueryInterface(IID_CSegment,(void **)&pSegment)))
        {
            pISegment->Release();
        }
        else
        {
            Trace(1,"Error: Pointer in Segment parameter to Stop() is invalid.\n");
            return E_INVALIDARG;
        }
    }
    if (pSegmentState)
    {
        // If this is the starting segstate from a playing song, find the
        // current active segstate within that song.
        // The current active segstate keeps a pointer to
        // this segstate.
        if (pSegmentState->m_fSongMode)
        {
            CSegState* pNode;
            DWORD dwCount;
            for (dwCount = 0; dwCount < SQ_COUNT; dwCount++)
            {
                for( pNode = m_SegStateQueues[dwCount].GetHead(); pNode; pNode = pNode->GetNext() )
                {
                    if (pNode->m_pSongSegState == pSegmentState)
                    {
                        pSegmentState = pNode;
                        dwCount = SQ_COUNT;
                        break;
                    }
                }
            }
        }
    }
    if( dwFlags & DMUS_SEGF_DEFAULT )
    {
        DWORD   dwNewRes = 0;
        if( pSegment )
        {
            pSegment->GetDefaultResolution( &dwNewRes );
        }
        else if( pSegmentState )
        {
            IDirectMusicSegment*    pSegTemp;
            if( SUCCEEDED( pSegmentState->GetSegment( &pSegTemp ) ) )
            {
                pSegTemp->GetDefaultResolution( &dwNewRes );
                pSegTemp->Release();
            }
            else
            {
                dwNewRes = 0;
            }
        }
        else
        {
            dwNewRes = 0;
        }
        dwFlags |= dwNewRes;
        dwFlags &= ~DMUS_SEGF_DEFAULT;
    }
    // Make sure mtTime is greater or equal to QueueTime, which is the last time notes were
    // queued down (or latency time, whichever is later) so we can stop everything after it.
    MUSIC_TIME mtLatency;
    REFERENCE_TIME rtQueueTime;
    GetQueueTime( &rtQueueTime );
    ReferenceToMusicTime( rtQueueTime, &mtLatency );
    if( mtTime < mtLatency ) mtTime = mtLatency;
    // Resolve the time according to the resolution
    mtTime = ResolveTime( mtTime, dwFlags, NULL );
    // if mtTime is less than the current transported time, we can take
    // care of the Stop now. Otherwise, we need to cue a Stop PMsg and
    // take care of it at QUEUE time.
    if( mtTime <= m_mtTransported )
    {
        if( pSegmentState )
        {
            DoStop( pSegmentState, mtTime, TRUE );
            if( pSegment )
            {
                DoStop( pSegment, mtTime, TRUE );
            }
        }
        else
        {
            DoStop( pSegment, mtTime, TRUE );
        }
    }
    else
    {
        // find and mark the segment and/or segment state to not play beyond
        // the stop point.
        CSegState* pNode;
        DWORD dwCount;
        for (dwCount = SQ_PRI_PLAY; dwCount <= SQ_SEC_PLAY; dwCount++)
        {
            for( pNode = m_SegStateQueues[dwCount].GetHead(); pNode; pNode = pNode->GetNext() )
            {
                if( (pNode->m_pSegment == pSegment) ||
                    (pNode == pSegmentState) )
                {
                    if (pNode->m_fCanStop)
                    {
                        pNode->m_mtStopTime = mtTime;
                        // Make sure GetParams ignore the rest of the segment from now on.
                        if (mtTime < pNode->m_mtEndTime)
                        {
                            pNode->m_mtLength = mtTime - pNode->m_mtResolvedStart +
                                pNode->m_mtStartPoint;
                            if (pNode->m_mtLength < 0)
                            {
                                pNode->m_mtLength = 0;
                            }
                            // Make endtime one greater than mtTime so Abort notification will still happen.
                            pNode->m_mtEndTime = mtTime + 1;
                        }
                        // Force the tempo map to be recalculated IF this has a tempo track.
                        RecalcTempoMap(pNode,mtTime);
                    }
                }
            }
        }

        // create a Stop PMsg and cue it for QUEUE time
        // I've removed this to fix bugs. A stop message at queue time, 
        // if in a controlling or primary segment, results in invalidation.
        // This is particularily bad for controlling segments.
        // Can't figure out why we even need the stop message...
/*      DMUS_PMSG* pPMsg;

        if( SUCCEEDED( AllocPMsg( sizeof(DMUS_PMSG), &pPMsg )))
        {
            pPMsg->dwType = DMUS_PMSGT_STOP;
            pPMsg->mtTime = mtTime;
            pPMsg->dwFlags = DMUS_PMSGF_MUSICTIME | DMUS_PMSGF_TOOL_QUEUE;
            if( pSegment )
            {
                pSegment->QueryInterface( IID_IUnknown, (void**)&pPMsg->punkUser );
                if( pSegmentState )
                {
                    // if there is also a segment state pointer, we need to create two
                    // pmsg's
                    DMUS_PMSG* pPMsg2;

                    if( SUCCEEDED( AllocPMsg( sizeof(DMUS_PMSG), &pPMsg2 )))
                    {
                        pPMsg2->dwType = DMUS_PMSGT_STOP;
                        pPMsg2->mtTime = mtTime;
                        pPMsg2->dwFlags = DMUS_PMSGF_MUSICTIME | DMUS_PMSGF_TOOL_QUEUE;
                        pSegmentState->QueryInterface( IID_IUnknown, (void**)&pPMsg2->punkUser );
                        pPMsg2->pTool = this;
                        AddRef();
                        if(FAILED(SendPMsg( pPMsg2 )))
                        {
                            FreePMsg(pPMsg2);
                        }
                    }
                }
            }
            else if( pSegmentState )
            {
                pSegmentState->QueryInterface( IID_IUnknown, (void**)&pPMsg->punkUser );
            }
            pPMsg->pTool = this;
            AddRef();
            if(FAILED(SendPMsg( pPMsg )))
            {
                FreePMsg(pPMsg);
            }
        }*/
    }
    LeaveCriticalSection(&m_SegmentCrSec);
    return S_OK;
}

void CPerformance::ResetAllControllers(CChannelMap* pChannelMap, REFERENCE_TIME rtTime, bool fGMReset)

{
    DWORD dwIndex = pChannelMap->dwPortIndex;
    DWORD dwGroup = pChannelMap->dwGroup;
    DWORD dwMChannel = pChannelMap->dwMChannel;

    EnterCriticalSection(&m_PChannelInfoCrSec);
    IDirectMusicPort* pPort = m_pPortTable[dwIndex].pPort;
    IDirectMusicBuffer* pBuffer = m_pPortTable[dwIndex].pBuffer;
    if( pPort && pBuffer )
    {
        m_pPortTable[dwIndex].fBufferFilled = TRUE;
        if (!rtTime)
        {
            rtTime = m_pPortTable[dwIndex].rtLast + 1;
        }
        else
        {
            m_pPortTable[dwIndex].rtLast = rtTime;
        }
        pChannelMap->Reset(true);
        DWORD dwMsg = dwMChannel | MIDI_CCHANGE | (MIDI_CC_ALLSOUNDSOFF << 8); // 0x78 is all sounds off.
        if( FAILED( pBuffer->PackStructured( rtTime, dwGroup, dwMsg ) ) )
        {
            pPort->PlayBuffer( pBuffer );
            pBuffer->Flush();
            // try one more time
            pBuffer->PackStructured( rtTime, dwGroup, dwMsg );
        }
        dwMsg = dwMChannel | MIDI_CCHANGE | (MIDI_CC_RESETALL << 8) | (1 << 16) ; // 0x79 is reset all controllers. Data byte set to indicate volume and pan too.
        if( FAILED( pBuffer->PackStructured( rtTime + 30 * REF_PER_MIL, dwGroup, dwMsg ) ) )
        {
            pPort->PlayBuffer( pBuffer );
            pBuffer->Flush();
            // try one more time
            pBuffer->PackStructured( rtTime + (30 * REF_PER_MIL), dwGroup, dwMsg );
        }
        // Send one GM Reset per channel group, but only under DX8 (and only if we need to).
        if ((dwMChannel == 0) && (m_dwVersion >= 8) && fGMReset)
        {
            // create a buffer of the right size
            DMUS_BUFFERDESC dmbd;
            IDirectMusicBuffer *pLocalBuffer;
            static BYTE abGMReset[6] = { (BYTE)MIDI_SYSX,0x7E,0x7F,9,1,(BYTE)MIDI_EOX };
            memset( &dmbd, 0, sizeof(DMUS_BUFFERDESC) );
            dmbd.dwSize = sizeof(DMUS_BUFFERDESC);
            dmbd.cbBuffer = 50;

            EnterCriticalSection(&m_MainCrSec);
            if( SUCCEEDED( m_pDirectMusic->CreateMusicBuffer(&dmbd, &pLocalBuffer, NULL)))
            {
                if( SUCCEEDED( pLocalBuffer->PackUnstructured( rtTime + (30 * REF_PER_MIL), dwGroup,
                    6, abGMReset ) ) )
                {
                    pPort->PlayBuffer(pLocalBuffer);
                }
                pLocalBuffer->Release();
            }
            LeaveCriticalSection(&m_MainCrSec);
        }
        m_rtEarliestStartTime = rtTime + (60 * REF_PER_MIL); // Give synth chance to stabilize
                                                             // before next start.
    }
    LeaveCriticalSection(&m_PChannelInfoCrSec);
}


void CPerformance::ResetAllControllers( REFERENCE_TIME rtTime )
{
    EnterCriticalSection(&m_PChannelInfoCrSec);

    CChannelBlock* pChannelBlock;
    SendBuffers();
    for( pChannelBlock = m_ChannelBlockList.GetHead(); pChannelBlock; pChannelBlock = pChannelBlock->GetNext() )
    {
        CChannelMap* pChannelMap;
        for( DWORD dwPChannel = pChannelBlock->m_dwPChannelStart;
            dwPChannel < pChannelBlock->m_dwPChannelStart + PCHANNEL_BLOCKSIZE;
            dwPChannel++ )
        {
            pChannelMap = &pChannelBlock->m_aChannelMap[dwPChannel - pChannelBlock->m_dwPChannelStart];
            if( pChannelMap->dwGroup ) // Valid group?
            {
                // Reset controllers and send a GM reset.
                ResetAllControllers(pChannelMap, rtTime, true);
            }
        }
    }
    SendBuffers();

    LeaveCriticalSection(&m_PChannelInfoCrSec);
}

// internal: return CSegState* at time mtTime
// only call this from within a segment critical section
CSegState* CPerformance::GetPrimarySegmentAtTime( MUSIC_TIME mtTime )
{
    CSegState* pSegNode;
    CSegState* pSegReturn = NULL;
    BOOL fCheckedPri = FALSE;
    for( pSegNode = m_SegStateQueues[SQ_PRI_DONE].GetHead(); pSegNode; pSegNode = pSegNode->GetNext() )
    {
        // if we're checking the past list, only check up until the last time played.
        if( (mtTime >= pSegNode->m_mtResolvedStart) && (mtTime <= pSegNode->m_mtLastPlayed) )
        {
            pSegReturn = pSegNode;
            break;
        }
    }
    for( pSegNode = m_SegStateQueues[SQ_PRI_PLAY].GetHead(); pSegNode; pSegNode = pSegNode->GetNext() )
    {
        MUSIC_TIME mtTest = mtTime;
        MUSIC_TIME mtOffset;
        DWORD dwRepeat;
        // if we're checking the current list, check the full segment time
        if( S_OK == pSegNode->ConvertToSegTime( &mtTest, &mtOffset, &dwRepeat ))
        {
            pSegReturn = pSegNode;
            break;
        }
    }
    if (!pSegReturn)
    {
        for( pSegNode = m_SegStateQueues[SQ_PRI_WAIT].GetHead(); pSegNode; pSegNode = pSegNode->GetNext() )
        {
            MUSIC_TIME mtTest = mtTime;
            MUSIC_TIME mtOffset;
            DWORD dwRepeat;
            // if we're checking the current list, check the full segment time
            if( S_OK == pSegNode->ConvertToSegTime( &mtTest, &mtOffset, &dwRepeat ))
            {
                pSegReturn = pSegNode;
                break;
            }
        }
    }
    return pSegReturn;
}

/*

  @method HRESULT | IDirectMusicPerformance | GetSegmentState |
  Returns the Primary SegmentState at time <p mtTime>.

  @rvalue S_OK | Success.
  @rvalue E_POINTER | ppSegmentState is NULL or invalid.
  @rvalue DMUS_E_NOT_FOUND | There is no currently playing SegmentState or one at <p mtTime>.

  @comm This function is intended for routines that need to access the currently
  playing SegmentState, e.g. to obtain the chord or command track. "Currently
  Playing" in this context means that it is being called into to perform messages.
  I.e., this includes all latencies and doesn't imply that this
  SegmentState is currenty being "heard" through the speakers.

*/
HRESULT STDMETHODCALLTYPE CPerformance::GetSegmentState(
    IDirectMusicSegmentState **ppSegmentState,  // @parm Returns the SegmentState pointer to the one currently playing.
                                                // The caller is responsible for calling Release on this pointer.
    MUSIC_TIME mtTime ) // @parm Return the SegmentState which played, is playing, or will
                        // be playing at mtTime. To get the currently playing segment, pass the
                        // mtTime retrieved from <om .GetTime>.
{
    V_INAME(IDirectMusicPerformance::GetSegmentState);
    V_PTRPTR_WRITE(ppSegmentState);

    CSegState* pSegNode;
    HRESULT hr;
    EnterCriticalSection(&m_SegmentCrSec);
    if( pSegNode = GetPrimarySegmentAtTime( mtTime ))
    {
        *ppSegmentState = pSegNode;
        pSegNode->AddRef();
        hr = S_OK;
    }
    else
    {
        Trace(3,"Unable to find a segment state at time %ld\n",mtTime);
        hr  = DMUS_E_NOT_FOUND;
    }
    LeaveCriticalSection(&m_SegmentCrSec);
    return hr;
}

/*
  @method HRESULT | IDirectMusicPerformance | SetPrepareTime |
  Sets the prepare time. The prepare time is the amount of time ahead that
  <om IDirectMusicTrack.Play> is called before the messages should actually
  be heard through the loudspeaker. The midi messages from the tracks are placed in
  the early queue, are processed by Tools, and then placed in the near-time
  queue to await being sent to the midi ports.

  @rvalue S_OK | Success.
  @comm The default value is 1000 milliseconds.
*/
HRESULT STDMETHODCALLTYPE CPerformance::SetPrepareTime(
    DWORD dwMilliSeconds) // @parm The amount of time.
{
    m_dwPrepareTime = dwMilliSeconds;
    return S_OK;
}

/*
  @method HRESULT | IDirectMusicPerformance | GetPrepareTime |
  Gets the prepare time. The prepare time is the amount of time ahead that
  <om IDirectMusicTrack.Play> is called before the messages should actually
  be heard through the loudspeaker. The midi messages from the tracks are placed in
  the early queue, are processed by Tools, and then placed in the near-time
  queue to await being sent to the midi ports.

  @rvalue S_OK | Success.
  @rvalue E_POINTER | pdwMilliSeconds is NULL or invalid.
  @comm The default value is 1000 milliseconds.
*/
HRESULT STDMETHODCALLTYPE CPerformance::GetPrepareTime(
    DWORD* pdwMilliSeconds) // @parm The amount of time.
{
    V_INAME(IDirectMusicPerformance::GetPrepareTime);
    V_PTR_WRITE(pdwMilliSeconds,DWORD);

    *pdwMilliSeconds = m_dwPrepareTime;
    return S_OK;
}

/*
  @method HRESULT | IDirectMusicPerformance | SetBumperLength |
  Sets the bumper length. The bumper length is the amount of time to buffer ahead
  of the Port's latency for midi messages to be sent to the Port for rendering.

  @rvalue S_OK | Success.
  @comm The default value is 50 milliseconds.
*/
HRESULT STDMETHODCALLTYPE CPerformance::SetBumperLength(
    DWORD dwMilliSeconds)   // @parm The amount of time.
{
    m_dwBumperLength = dwMilliSeconds;
    m_rtBumperLength = m_dwBumperLength * REF_PER_MIL;
    return S_OK;
}

/*
  @method HRESULT | IDirectMusicPerformance | GetBumperLength |
  Gets the bumper length. The bumper length is the amount of time to buffer ahead
  of the Port's latency for midi messages to be sent to the Port for rendering.

  @rvalue S_OK | Success.
  @rvalue E_POINTER | pdwMilliSeconds is NULL or invalid.
  @comm The default value is 50 milliseconds.
*/
HRESULT STDMETHODCALLTYPE CPerformance::GetBumperLength(
    DWORD* pdwMilliSeconds) // @parm The amount of time.
{
    V_INAME(IDirectMusicPerformance::GetBumperLength);
    V_PTR_WRITE(pdwMilliSeconds,DWORD);

    *pdwMilliSeconds = m_dwBumperLength;
    return S_OK;
}

#define RESOLVE_FLAGS (DMUS_TIME_RESOLVE_AFTERPREPARETIME | \
                       DMUS_TIME_RESOLVE_AFTERLATENCYTIME | \
                       DMUS_TIME_RESOLVE_AFTERQUEUETIME | \
                       DMUS_TIME_RESOLVE_BEAT | \
                       DMUS_TIME_RESOLVE_MEASURE | \
                       DMUS_TIME_RESOLVE_GRID | \
                       DMUS_TIME_RESOLVE_MARKER | \
                       DMUS_TIME_RESOLVE_SEGMENTEND)


HRESULT STDMETHODCALLTYPE CPerformance::SendPMsg(
    DMUS_PMSG *pDMUS_PMSG)

{
    V_INAME(IDirectMusicPerformance::SendPMsg);
    if( m_dwVersion < 8)
    {
        V_BUFPTR_WRITE(pDMUS_PMSG,sizeof(DMUS_PMSG));
    }
    else
    {
#ifdef DBG
        V_BUFPTR_WRITE(pDMUS_PMSG,sizeof(DMUS_PMSG));
#else
        if (!pDMUS_PMSG)
        {
            return E_POINTER;
        }
#endif
    }
    EnterCriticalSection(&m_MainCrSec);
    if( m_pClock == NULL )
    {
        LeaveCriticalSection(&m_MainCrSec);
        Trace(1,"Error: Unable to Send PMsg because performance not initialized.\n");
        return DMUS_E_NO_MASTER_CLOCK;
    }
    LeaveCriticalSection(&m_MainCrSec);

    if (pDMUS_PMSG->dwSize < sizeof(DMUS_PMSG))
    {
        TraceI(1,"Warning: PMsg size field has been cleared.\n");
    }

    // If this is a PMsg that was marked by STampPMsg as one that should be removed,
    // do so now.
    if (pDMUS_PMSG->dwPChannel == DMUS_PCHANNEL_KILL_ME)
    {
        FreePMsg(pDMUS_PMSG);
        return S_OK;
    }

    EnterCriticalSection(&m_PipelineCrSec);
    PRIV_PMSG* pPrivPMsg = DMUS_TO_PRIV(pDMUS_PMSG);
    if( ( pPrivPMsg->dwPrivFlags & PRIV_FLAG_QUEUED ) ||
        ( ( pPrivPMsg->dwPrivFlags & PRIV_FLAG_ALLOC_MASK ) != PRIV_FLAG_ALLOC ) )
    {
        Trace(1, "Error: Attempt to send an improperly allocated PMsg, or trying to send it after it is already sent.\n" );
        LeaveCriticalSection(&m_PipelineCrSec);
        return DMUS_E_ALREADY_SENT;
    }

    if (m_dwVersion >= 8)
    {
        // If the music and ref times are both 0, set to latency time.
        if ((pDMUS_PMSG->mtTime == 0) && ( pDMUS_PMSG->rtTime == 0 ))
        {
            // If this needs to resolve, use the worse case latency
            // because this needs to sync with other pmsgs.
            if (pDMUS_PMSG->dwFlags & RESOLVE_FLAGS)
            {
                GetLatencyTime(&pDMUS_PMSG->rtTime);
            }
            else
            {
                // Otherwise, we want to play as soon as possible.
                pDMUS_PMSG->rtTime = GetTime();
            }
            pDMUS_PMSG->dwFlags |= DMUS_PMSGF_REFTIME;
            pDMUS_PMSG->dwFlags &= ~DMUS_PMSGF_MUSICTIME;
        }
    }

    // fill in missing time value
    if (!(pDMUS_PMSG->dwFlags & DMUS_PMSGF_MUSICTIME))
    {
        if( !(pDMUS_PMSG->dwFlags & DMUS_PMSGF_REFTIME ) )
        {
            LeaveCriticalSection(&m_PipelineCrSec);
            Trace(1,"Error: Unable to send PMsg because neither clock time (DMUS_PMSGF_REFTIME) nor music time (DMUS_PMSGF_MUSICTIME) has been set.\n");
            return E_INVALIDARG; // one or the other MUST be set
        }
        // quantize to resolution boundaries
        GetResolvedTime( pDMUS_PMSG->rtTime, &pDMUS_PMSG->rtTime, pDMUS_PMSG->dwFlags );
        pDMUS_PMSG->dwFlags &= ~RESOLVE_FLAGS;
        // if time is zero, set it to time now plus latency
        if( pDMUS_PMSG->rtTime == 0 )
        {
            pDMUS_PMSG->rtTime = GetLatency();
        }
        ReferenceToMusicTime(pDMUS_PMSG->rtTime,
            &pDMUS_PMSG->mtTime);
        pDMUS_PMSG->dwFlags |= DMUS_PMSGF_MUSICTIME;
    }
    else if (!(pDMUS_PMSG->dwFlags & DMUS_PMSGF_REFTIME))
    {
        MusicToReferenceTime(pDMUS_PMSG->mtTime,
            &pDMUS_PMSG->rtTime);
        pDMUS_PMSG->dwFlags |= DMUS_PMSGF_REFTIME;
        // quantize to resolution boundaries
        REFERENCE_TIME rtNew;
        GetResolvedTime( pDMUS_PMSG->rtTime, &rtNew, pDMUS_PMSG->dwFlags );
        pDMUS_PMSG->dwFlags &= ~RESOLVE_FLAGS;
        if( rtNew != pDMUS_PMSG->rtTime )
        {
            pDMUS_PMSG->rtTime = rtNew;
            ReferenceToMusicTime( pDMUS_PMSG->rtTime, &pDMUS_PMSG->mtTime );
        }
    }

    // insert into the proper queue by music value
    if (pDMUS_PMSG->dwFlags & DMUS_PMSGF_TOOL_QUEUE)
    {
        m_NearTimeQueue.Enqueue(pPrivPMsg);
    }
    else if (pDMUS_PMSG->dwFlags & DMUS_PMSGF_TOOL_ATTIME)
    {
        m_OnTimeQueue.Enqueue(pPrivPMsg);
    }
    else // (pDMUS_PMSG->dwFlags & DMUS_PMSGF_TOOL_IMMEDIATE)
    {
        pDMUS_PMSG->dwFlags |= DMUS_PMSGF_TOOL_IMMEDIATE;
        m_EarlyQueue.Enqueue(pPrivPMsg);
    }
    LeaveCriticalSection(&m_PipelineCrSec);
    return S_OK;
}

/*

  Call this only from within a PipelineCrSec.
*/
void CPerformance::RevalidateRefTimes( CPMsgQueue * pList, MUSIC_TIME mtTime )
{
    PRIV_PMSG* pCheck;
    BOOL fError = FALSE;
    for( pCheck = pList->GetHead(); pCheck; pCheck = pCheck->pNext )
    {
        if (pCheck->mtTime > mtTime)
        {
            if (pCheck->dwFlags & DMUS_PMSGF_LOCKTOREFTIME)
            {
                ReferenceToMusicTime(pCheck->rtTime,&pCheck->mtTime);
            }
            else // if(pCheck->dwFlags & DMUS_PMSGF_MUSICTIME)
            {
                MusicToReferenceTime(pCheck->mtTime,&pCheck->rtTime);
            }
        }
    }
    // Make sure that we do not end up with out of order RTimes. This can happen with
    // DMUS_PMSGF_LOCKTOREFTIME messages or very abrupt changes in tempo.
    for( pCheck = pList->GetHead(); pCheck; pCheck = pCheck->pNext )
    {
        if (pCheck->pNext && ( pCheck->rtTime > pCheck->pNext->rtTime ))
        {
            fError = TRUE;  // Need to sort the list.
        }
    }
    if (fError)
    {
        TraceI(2,"Rearrangement of times in message list due to tempo change, resorting\n");
        pList->Sort();
    }
}

void CPerformance::AddToTempoMap( double dblTempo, MUSIC_TIME mtTime, REFERENCE_TIME rtTime )
{
    DMInternalTempo* pITempo = NULL;

    if( FAILED( AllocPMsg( sizeof(DMInternalTempo), (PRIV_PMSG**)&pITempo )))
    {
        return; // out of memory!
    }
    if( dblTempo > DMUS_TEMPO_MAX ) dblTempo = DMUS_TEMPO_MAX;
    else if( dblTempo < DMUS_TEMPO_MIN ) dblTempo = DMUS_TEMPO_MIN;
    pITempo->tempoPMsg.dblTempo = dblTempo;
    pITempo->tempoPMsg.rtTime = rtTime;
    pITempo->tempoPMsg.mtTime = mtTime;
    pITempo->tempoPMsg.dwFlags = DMUS_PMSGF_MUSICTIME | DMUS_PMSGF_REFTIME;
    pITempo->pNext = NULL;
    // set the relative tempo field
    EnterCriticalSection(&m_GlobalDataCrSec);
    pITempo->fltRelTempo = m_fltRelTempo;
    // add the tempo event to the tempo map and clear the tool and graph pointers
    pITempo->tempoPMsg.pTool = NULL;
    EnterCriticalSection(&m_PipelineCrSec);
    // remove stale tempo events from the tempo map.
    // as long as there is another tempo with a time stamp before the current
    // time, get rid of the first in the list.
    REFERENCE_TIME rtNow = GetTime() - (10000 * 1000); // keep around for a second.
    PRIV_PMSG* pCheck;
    while (pCheck = m_TempoMap.FlushOldest(rtNow))
    {
        m_OldTempoMap.Enqueue(pCheck);
    }
    // add the new tempo event to the queue
    m_TempoMap.Enqueue( (PRIV_PMSG*) pITempo );
    // now that it's been added, scan forward from it and change the relative tempo
    // times of everyone after it
    DMInternalTempo* pChange;
    for( pChange = (DMInternalTempo*)pITempo->pNext; pChange;
        pChange = (DMInternalTempo*)pChange->pNext )
    {
        pChange->fltRelTempo = pITempo->fltRelTempo;
    }
    // remove stale tempo events from the old tempo map.
    // as long as there is another tempo with a time stamp before the current
    // time, get rid of the first in the list.
    rtNow = GetTime() - ((REFERENCE_TIME)10000 * 300000); // keep around for five minutes.
    while (pCheck = m_OldTempoMap.FlushOldest(rtNow))
    {
        FreePMsg(pCheck);
    }
    m_fTempoChanged = TRUE;
    LeaveCriticalSection(&m_PipelineCrSec);
    LeaveCriticalSection(&m_GlobalDataCrSec);
}

void CPerformance::AddEventToTempoMap( PRIV_PMSG* pEvent )
{
    PRIV_TEMPO_PMSG* pTempo = (PRIV_TEMPO_PMSG*)pEvent;
    MUSIC_TIME mtTime = pTempo->tempoPMsg.mtTime;
    AddToTempoMap( pTempo->tempoPMsg.dblTempo, mtTime, pTempo->tempoPMsg.rtTime );
    pEvent->dwPrivFlags = PRIV_FLAG_ALLOC;
    EnterCriticalSection(&m_GlobalDataCrSec);
    EnterCriticalSection(&m_PipelineCrSec);
    // revalidate the ref times of the events in the queues
    RevalidateRefTimes( &m_TempoMap, mtTime );
    RevalidateRefTimes( &m_OnTimeQueue, mtTime );
    RevalidateRefTimes( &m_NearTimeQueue, mtTime );
    RevalidateRefTimes( &m_EarlyQueue, mtTime );
    m_fTempoChanged = TRUE;
    LeaveCriticalSection(&m_PipelineCrSec);
    LeaveCriticalSection(&m_GlobalDataCrSec);
    RecalcTempoMap(NULL, mtTime+1, false);
}

#define TEMPO_AHEAD 768 * 4 * 10    // 10 measures ahead is plenty!

void CPerformance::IncrementTempoMap()

{
    if (m_mtTempoCursor <= (m_mtTransported + TEMPO_AHEAD))
    {
        UpdateTempoMap(m_mtTempoCursor, false, NULL);
    }
}

void CPerformance::RecalcTempoMap(CSegState *pSegState, MUSIC_TIME mtStart, bool fAllDeltas)

/*  Called whenever a primary or controlling segment that has a tempo
    track is played or stopped.
    1) Convert the music time at transport time to ref time using the old
    map.
    2) Build a replacement tempo map starting at mtStart, by
    calling GetParam() until there is no next time.
    3) Install the new map.
    4) Convert with the new map.
    5) If the two numbers are not identical, recalculate all message times.
*/

{
    if( mtStart > 0) // Don't do this for invalid values.
    {
        if (!pSegState || (pSegState->m_pSegment && pSegState->m_pSegment->IsTempoSource()))
        {
            REFERENCE_TIME rtCompareTime;
            REFERENCE_TIME rtAfterTime;
            MUSIC_TIME mtCompareTime = m_mtTransported;
            MusicToReferenceTime(mtCompareTime,&rtCompareTime);
            EnterCriticalSection(&m_PipelineCrSec);
            FlushEventQueue( 0, &m_TempoMap, rtCompareTime, rtCompareTime, 0 );
            LeaveCriticalSection(&m_PipelineCrSec);
            UpdateTempoMap(mtStart, true, pSegState, fAllDeltas);
            MusicToReferenceTime(mtCompareTime,&rtAfterTime);
            if (rtAfterTime != rtCompareTime)
            {
                EnterCriticalSection(&m_GlobalDataCrSec);
                EnterCriticalSection(&m_PipelineCrSec);
                // revalidate the ref times of the events in the queues
                RevalidateRefTimes( &m_TempoMap, mtStart );
                RevalidateRefTimes( &m_OnTimeQueue, mtStart );
                RevalidateRefTimes( &m_NearTimeQueue, mtStart );
                RevalidateRefTimes( &m_EarlyQueue, mtStart );
                m_fTempoChanged = TRUE;
                LeaveCriticalSection(&m_PipelineCrSec);
                LeaveCriticalSection(&m_GlobalDataCrSec);
            }
        }
    }
}


void CPerformance::UpdateTempoMap(MUSIC_TIME mtStart, bool fFirst, CSegState *pSegState, bool fAllDeltas)

{
    HRESULT hr = S_OK;
    DWORD dwIndex = 0;
    PrivateTempo Tempo;
    TList<PrivateTempo> TempoList;
    TListItem<PrivateTempo>* pScan = NULL;
    MUSIC_TIME mtNext = 0;
    MUSIC_TIME mtTime = mtStart;
    MUSIC_TIME mtCursor = mtStart;
    REFERENCE_TIME rtTime;
    do
    {
        hr = GetParam(GUID_PrivateTempoParam,-1,dwIndex,mtTime,&mtNext,(void *)&Tempo );
        Tempo.mtTime = mtTime;
        if (hr == S_OK && Tempo.mtDelta > 0)
        {
            mtTime += Tempo.mtDelta;
            hr = GetParam(GUID_PrivateTempoParam,-1,dwIndex,mtTime,&mtNext,(void *)&Tempo );
            Tempo.mtTime = mtTime;
        }
        if (hr == S_FALSE && fFirst && !pSegState)
        {
            // If this was the very first try, there might not be any tempo track, and
            // so global tempo is called. If so, S_FALSE is returned. This is okay
            // for the NULL segstate case where we are recomputing the tempo map in response
            // to a change in global tempo, or stop of all segments.
            if (fAllDeltas) // Never do this in response to adding a new event to the tempo map
            {
                MusicToReferenceTime(mtTime,&rtTime);
                // the rtTime in the tempo map needs to be the non-adjusted value (305694)
                AddToTempoMap( Tempo.dblTempo, mtTime, rtTime + m_rtAdjust );
            }
            break;
        }
        if (hr == S_OK)
        {
            TListItem<PrivateTempo>* pNew = new TListItem<PrivateTempo>(Tempo);
            if (pNew)
            {
                // add to TempoList, replacing duplicate times with the most recent mtDelta
                TListItem<PrivateTempo>* pNext = TempoList.GetHead();
                if (!pNext || Tempo.mtTime < pNext->GetItemValue().mtTime)
                {
                    TempoList.AddHead(pNew);
                }
                else for (pScan = TempoList.GetHead(); pScan; pScan = pNext)
                {
                    pNext = pScan->GetNext();
                    if (Tempo.mtTime == pScan->GetItemValue().mtTime)
                    {
                        if (Tempo.mtDelta > pScan->GetItemValue().mtDelta)
                        {
                            pScan->GetItemValue() = Tempo;
                        }
                        delete pNew;
                        break;
                    }
                    else if (!pNext || Tempo.mtTime < pNext->GetItemValue().mtTime)
                    {
                        pScan->SetNext(pNew);
                        pNew->SetNext(pNext);
                        break;
                    }
                }
            }
            mtTime += mtNext;
            fFirst = false;
            // If this was the last tempo in the track (that we care about),
            // reset the time and bump the track index
            if (Tempo.fLast || mtTime > (m_mtTransported + TEMPO_AHEAD))
            {
                dwIndex++;
                mtCursor = mtTime;
                mtTime = mtStart;
            }
            else if (!mtNext) break; // should never happen but if it does, infinite loop
        }
        else if (Tempo.fLast) // There was an empty tempo track
        {
            dwIndex++;
            hr = S_OK;
        }
        Tempo.fLast = false;
    } while (hr == S_OK);
    if (TempoList.GetHead() && TempoList.GetHead()->GetItemValue().mtTime > mtStart)
    {
        // add a tempo of 120 at time mtStart
        TListItem<PrivateTempo>* pNew = new TListItem<PrivateTempo>();
        if (pNew)
        {
            PrivateTempo& rNew = pNew->GetItemValue();
            rNew.dblTempo = 120.0;
            rNew.mtTime = mtStart;
            TempoList.AddHead(pNew);
        }
        else
        {
#ifdef DBG
            Trace(1, "Error: Out of memory; Tempo map is incomplete.\n");
#endif
            TempoList.GetHead()->GetItemValue().mtTime = mtStart;
        }
    }
    for (pScan = TempoList.GetHead(); pScan; pScan = pScan->GetNext())
    {
        PrivateTempo& rTempo = pScan->GetItemValue();
        if (fAllDeltas || rTempo.mtTime + rTempo.mtDelta >= mtStart)
        {
            MusicToReferenceTime(rTempo.mtTime,&rtTime);
            // the rtTime in the tempo map needs to be the non-adjusted value (305694)
            AddToTempoMap( rTempo.dblTempo, rTempo.mtTime, rtTime + m_rtAdjust );
        }
    }
    m_mtTempoCursor = mtCursor;
}

HRESULT STDMETHODCALLTYPE CPerformance::MusicToReferenceTime(
    MUSIC_TIME mtTime,          // @parm The time in MUSIC_TIME format to convert.
    REFERENCE_TIME *prtTime)    // @parm Returns the converted time in REFERENCE_TIME format.
{
    V_INAME(IDirectMusicPerformance::MusicToReferenceTime);
    V_PTR_WRITE(prtTime,REFERENCE_TIME);

    EnterCriticalSection(&m_MainCrSec);
    if( m_pClock == NULL )
    {
        LeaveCriticalSection(&m_MainCrSec);
        Trace(1,"Error: Unable to convert music to reference time because the performance has not been initialized.\n");
        return DMUS_E_NO_MASTER_CLOCK;
    }
    LeaveCriticalSection(&m_MainCrSec);

    PRIV_PMSG*  pEvent;
    double dbl = 120;
    MUSIC_TIME mtTempo = 0;
    REFERENCE_TIME rtTempo = m_rtStart;
    REFERENCE_TIME rtTemp;

    EnterCriticalSection( &m_PipelineCrSec );
    pEvent = m_TempoMap.GetHead();
    if( pEvent )
    {
        if( mtTime >= pEvent->mtTime )
        {
            while( pEvent->pNext )
            {
                if( pEvent->pNext->mtTime > mtTime )
                {
                    break;
                }
                pEvent = pEvent->pNext;
            }
            DMInternalTempo* pTempo = (DMInternalTempo*)pEvent;
            dbl = pTempo->tempoPMsg.dblTempo * pTempo->fltRelTempo;
            mtTempo = pTempo->tempoPMsg.mtTime;
            rtTempo = pTempo->tempoPMsg.rtTime;
        }
        else
        {
            // If mtTime is less than everything in the tempo map, look in the old tempo map
            // (which goes five minutes into the past).  This keeps the regular tempo map
            // small, but allows us to get a valid tempo in the cases where the regular tempo
            // map no longer contains the tempo we need.
            pEvent = m_OldTempoMap.GetHead();
            if( pEvent )
            {
                if( mtTime >= pEvent->mtTime )
                {
                    while( pEvent->pNext )
                    {
                        if( pEvent->pNext->mtTime > mtTime )
                        {
                            break;
                        }
                        pEvent = pEvent->pNext;
                    }
                    DMInternalTempo* pTempo = (DMInternalTempo*)pEvent;
                    dbl = pTempo->tempoPMsg.dblTempo * pTempo->fltRelTempo;
                    mtTempo = pTempo->tempoPMsg.mtTime;
                    rtTempo = pTempo->tempoPMsg.rtTime;
                }
            }
        }
    }
    LeaveCriticalSection( &m_PipelineCrSec );
    rtTempo -= m_rtAdjust;

    rtTemp = ( mtTime - mtTempo );
    rtTemp *= 600000000;
    rtTemp += (DMUS_PPQ / 2);
    rtTemp /= DMUS_PPQ;
    rtTemp = (REFERENCE_TIME)(rtTemp / dbl);
    *prtTime = rtTempo + rtTemp;
    return S_OK;
}


HRESULT STDMETHODCALLTYPE CPerformance::ReferenceToMusicTime(
    REFERENCE_TIME rtTime,  // @parm The time in REFERENCE_TIME format to convert.
    MUSIC_TIME *pmtTime)    // @parm Returns the converted time in MUSIC_TIME format.
{
    V_INAME(IDirectMusicPerformance::ReferenceToMusicTime);
    V_PTR_WRITE(pmtTime,MUSIC_TIME);

    EnterCriticalSection(&m_MainCrSec);
    if( m_pClock == NULL )
    {
        LeaveCriticalSection(&m_MainCrSec);
        Trace(1,"Error: Unable to convert reference to music time because the performance has not been initialized.\n");
        return DMUS_E_NO_MASTER_CLOCK;
    }
    LeaveCriticalSection(&m_MainCrSec);

    PRIV_PMSG*  pEvent;
    double dbl = 120;
    MUSIC_TIME mtTempo = 0;
    REFERENCE_TIME rtTempo = m_rtStart;

    EnterCriticalSection( &m_PipelineCrSec );
    pEvent = m_TempoMap.GetHead();
    if( pEvent )
    {
        if( rtTime >= pEvent->rtTime )
        {
            while( pEvent->pNext )
            {
                if( pEvent->pNext->rtTime > rtTime )
                {
                    break;
                }
                pEvent = pEvent->pNext;
            }
            DMInternalTempo* pTempo = (DMInternalTempo*)pEvent;
            dbl = pTempo->tempoPMsg.dblTempo * pTempo->fltRelTempo;
            mtTempo = pTempo->tempoPMsg.mtTime;
            rtTempo = pTempo->tempoPMsg.rtTime;
        }
        else
        {
            // If mtTime is less than everything in the tempo map, look in the old tempo map
            // (which goes five minutes into the past).  This keeps the regular tempo map
            // small, but allows us to get a valid tempo in the cases where the regular tempo
            // map no longer contains the tempo we need.
            pEvent = m_OldTempoMap.GetHead();
            if( pEvent )
            {
                if( rtTime >= pEvent->rtTime )
                {
                    while( pEvent->pNext )
                    {
                        if( pEvent->pNext->rtTime > rtTime )
                        {
                            break;
                        }
                        pEvent = pEvent->pNext;
                    }
                    DMInternalTempo* pTempo = (DMInternalTempo*)pEvent;
                    dbl = pTempo->tempoPMsg.dblTempo * pTempo->fltRelTempo;
                    mtTempo = pTempo->tempoPMsg.mtTime;
                    rtTempo = pTempo->tempoPMsg.rtTime;
                }
            }
        }
    }
    LeaveCriticalSection( &m_PipelineCrSec );
    rtTempo -= m_rtAdjust;
    if( rtTime < rtTempo )
    {
        rtTime = rtTempo;
    }
    rtTime -= rtTempo;
    rtTime *= DMUS_PPQ;
    rtTime = (REFERENCE_TIME)(rtTime * dbl);
    rtTime += 300000000;
    rtTime /= 600000000;
#ifdef DBG
    if ( rtTime & 0xFFFFFFFF00000000 )
    {
        Trace(1,"Error: Invalid Reference to Music time conversion resulted in overflow.\n");
    }
#endif
    *pmtTime = (long) (rtTime & 0xFFFFFFFF);
    *pmtTime += mtTempo;
    return S_OK;
}

/*
  @method HRESULT | IDirectMusicPerformance | AdjustTime |
  Adjust the internal Performance time forward or backward. This is mostly used to
  compensate for drift when synchronizing to another source, such as SMPTE.

  @rvalue S_OK | Success.
  @rvalue E_INVALIDARG | rtAmount is too large or too small.
*/
HRESULT STDMETHODCALLTYPE CPerformance::AdjustTime(
    REFERENCE_TIME rtAmount)    // @parm The amount of time to adjust. This may be a
                                // number from -10000000 to 10000000 (-1 second to +1 second.)
{
    if( ( rtAmount < -10000000 ) || ( rtAmount > 10000000 ) )
    {
        Trace(1,"Error: Time parameter passed to AdjustTime() is out of range.\n");
        return E_INVALIDARG;
    }
    m_rtAdjust += rtAmount;
    return S_OK;
}

/*
  @method HRESULT | IDirectMusicPerformance | GetResolvedTime |
  Quantize a time to a resolution boundary. Given a time, in REFERENCE_TIME,
  return the next time on a given boundary after the time given.

  @rvalue S_OK | Success.
  @rvalue E_POINTER <prtResolved> is not valid.
*/
HRESULT STDMETHODCALLTYPE CPerformance::GetResolvedTime(
    REFERENCE_TIME rtTime,
    REFERENCE_TIME* prtResolved,
    DWORD dwResolvedTimeFlags)
{
    V_INAME(IDirectMusicPerformance::GetResolvedTime);
    V_PTR_WRITE(prtResolved,REFERENCE_TIME);

    if (rtTime == 0)
    {
        dwResolvedTimeFlags |= DMUS_TIME_RESOLVE_AFTERQUEUETIME ;
    }
    if( dwResolvedTimeFlags & DMUS_TIME_RESOLVE_AFTERPREPARETIME )
    {
        REFERENCE_TIME rtTrans;
        MusicToReferenceTime( m_mtTransported, &rtTrans );
        if( rtTime < rtTrans ) rtTime = rtTrans;
    }
    else if (dwResolvedTimeFlags & DMUS_TIME_RESOLVE_AFTERLATENCYTIME )
    {
        REFERENCE_TIME rtStart;
        rtStart = GetLatency();
        if( rtTime < rtStart ) rtTime = rtStart;
    }
    else if( dwResolvedTimeFlags & DMUS_TIME_RESOLVE_AFTERQUEUETIME )
    {
        REFERENCE_TIME rtStart;
        GetQueueTime( &rtStart ); // need queue time because control segments cause invalidations
        if( rtTime < rtStart ) rtTime = rtStart;
    }


    if( dwResolvedTimeFlags & ( DMUS_TIME_RESOLVE_BEAT | DMUS_TIME_RESOLVE_MEASURE |
        DMUS_TIME_RESOLVE_GRID | DMUS_TIME_RESOLVE_MARKER | DMUS_TIME_RESOLVE_SEGMENTEND))
    {
        MUSIC_TIME mtTime; //, mtResolved;

        ReferenceToMusicTime( rtTime, &mtTime );
        EnterCriticalSection(&m_SegmentCrSec);
        mtTime = ResolveTime( mtTime, dwResolvedTimeFlags, NULL);
        LeaveCriticalSection(&m_SegmentCrSec);
        MusicToReferenceTime( mtTime, prtResolved );
    }
    else
    {
        *prtResolved = rtTime;
    }
    return S_OK;
}


/*
  @method HRESULT | IDirectMusicPerformance | IsPlaying |
  Find out if a particular Segment or SegmentState is currently playing.

  @rvalue E_POINTER | Both pSegment and pSegState are null, or one or both are invalid.
  @rvalue DMUS_E_NO_MASTER_CLOCK | There is no master clock in the performance.
  Make sure to call <om .Init> before calling this method.
  @rvalue S_OK | Yes, it is playing.
  @rvalue S_FALSE | No, it is not playing.
*/
HRESULT STDMETHODCALLTYPE CPerformance::IsPlaying(
    IDirectMusicSegment *pSegment,          // @parm The Segment to check. If NULL, check
                                            // <p pSegState>.
    IDirectMusicSegmentState *pSegState)    // @parm The SegmentState to check. If NULL,
                                            // check <p pSegment>.
{
    CSegState* pNode;
    DWORD dwCount;

    V_INAME(IDirectMusicPerformance::IsPlaying);
    V_INTERFACE_OPT(pSegment);
    V_INTERFACE_OPT(pSegState);

    EnterCriticalSection(&m_MainCrSec);
    if( m_pClock == NULL )
    {
        LeaveCriticalSection(&m_MainCrSec);
        Trace(1,"Error: IsPlaying() failed because the performance has not been initialized.\n");
        return DMUS_E_NO_MASTER_CLOCK;
    }
    LeaveCriticalSection(&m_MainCrSec);

    if( !pSegment && !pSegState )
    {
        Trace(1,"Error: IsPlaying() failed because segment and segment state are both NULL pointers.\n");
        return E_POINTER;
    }

    MUSIC_TIME mtNow;
    GetTime(NULL, &mtNow);
    EnterCriticalSection(&m_SegmentCrSec);

    for( dwCount = 0; dwCount < SQ_COUNT; dwCount++ )
    {
        for( pNode = m_SegStateQueues[dwCount].GetHead(); pNode; pNode = pNode->GetNext() )
        {
            if( !pNode->m_fStartedPlay )
            {
                continue;
            }
            if( mtNow >= pNode->m_mtResolvedStart )
            {
                if( mtNow < pNode->m_mtLastPlayed )
                {
                    if(( pNode == (CSegState*) pSegState ) ||
                        ( pNode->m_pSegment == (CSegment *) pSegment ))
                    {
                        LeaveCriticalSection(&m_SegmentCrSec);
                        return S_OK;
                    }
                }
            }
            else
            {
                // if mtNow is before this pSegState's resolved start, it is before every
                // pSegState after this too, so break now.
                break;
            }
        }
    }
    LeaveCriticalSection(&m_SegmentCrSec);
    return S_FALSE;
}


HRESULT STDMETHODCALLTYPE CPerformance::GetTime(
        REFERENCE_TIME *prtNow, // @parm Returns the current time in REFERENCE_TIME
                                            // format. May be NULL.
        MUSIC_TIME  *pmtNow)    // @parm Returns the current time in MUSIC_TIME
                                            // format. May be NULL.
{
    V_INAME(IDirectMusicPerformance::GetTime);
    V_PTR_WRITE_OPT(prtNow,REFERENCE_TIME);
    V_PTR_WRITE_OPT(pmtNow,MUSIC_TIME);

    EnterCriticalSection(&m_MainCrSec);
    if( m_pClock == NULL )
    {
        LeaveCriticalSection(&m_MainCrSec);
        Trace(1,"Error: GetTime() failed because the performance has not been initialized.\n");
        return DMUS_E_NO_MASTER_CLOCK;
    }
    LeaveCriticalSection(&m_MainCrSec);

    REFERENCE_TIME rtTime = GetTime();
    if( prtNow )
    {
        *prtNow = rtTime;
    }
    if( pmtNow )
    {
        MUSIC_TIME mtTime;
        ReferenceToMusicTime( rtTime, &mtTime );
        *pmtNow = mtTime;
    }
    return S_OK;
}


HRESULT STDMETHODCALLTYPE CPerformance::GetLatencyTime(
        REFERENCE_TIME *prtTime)    // @parm Returns the current latency time.
{
    V_INAME(IDirectMusicPerformance::GetLatencyTime);
    V_PTR_WRITE(prtTime,REFERENCE_TIME);

    EnterCriticalSection(&m_MainCrSec);
    if( m_pClock == NULL )
    {
        LeaveCriticalSection(&m_MainCrSec);
        Trace(1,"Error: GetLatencyTime() failed because the performance has not been initialized.\n");
        return DMUS_E_NO_MASTER_CLOCK;
    }
    LeaveCriticalSection(&m_MainCrSec);

    *prtTime = GetLatency();
    return S_OK;
}


HRESULT STDMETHODCALLTYPE CPerformance::GetQueueTime(
        REFERENCE_TIME *prtTime)    // @parm Returns the current queue time.
{
    V_INAME(IDirectMusicPerformance::GetQueueTime);
    V_PTR_WRITE(prtTime,REFERENCE_TIME);

    EnterCriticalSection(&m_MainCrSec);
    if( m_pClock == NULL )
    {
        LeaveCriticalSection(&m_MainCrSec);
        Trace(1,"Error: GetQueueTime() failed because the performance has not been initialized.\n");
        return DMUS_E_NO_MASTER_CLOCK;
    }
    LeaveCriticalSection(&m_MainCrSec);

    DWORD dw;
    REFERENCE_TIME rtLatency;

    *prtTime = 0;
    EnterCriticalSection(&m_PChannelInfoCrSec);
    for( dw = 0; dw < m_dwNumPorts; dw++ )
    {
        if( m_pPortTable[dw].rtLast > *prtTime )
            *prtTime = m_pPortTable[dw].rtLast;
    }
    LeaveCriticalSection(&m_PChannelInfoCrSec);
    rtLatency = GetLatency();
    if( *prtTime < rtLatency )
    {
        *prtTime = rtLatency;
    }
    if (m_rtEarliestStartTime > rtLatency)
    {
        rtLatency = m_rtEarliestStartTime;
    }
    return S_OK;
}

// private version of AllocPMsg
HRESULT CPerformance::AllocPMsg(
    ULONG cb,
    PRIV_PMSG** ppPMSG)
{
    ASSERT( cb >= sizeof(PRIV_PMSG) );
    DMUS_PMSG* pDMUS_PMSG;
    HRESULT hr;

    hr = AllocPMsg( cb - PRIV_PART_SIZE, &pDMUS_PMSG );
    if( SUCCEEDED(hr) )
    {
        *ppPMSG = DMUS_TO_PRIV(pDMUS_PMSG);
    }
    return hr;
}

HRESULT STDMETHODCALLTYPE CPerformance::ClonePMsg(DMUS_PMSG* pSourcePMSG,DMUS_PMSG** ppCopyPMSG)
{
    V_INAME(IDirectMusicPerformance::ClonePMsg);
#ifdef DBG
    V_PTRPTR_WRITE(ppCopyPMSG);
    V_BUFPTR_READ(pSourcePMSG,sizeof(DMUS_PMSG));
#else
    if (!ppCopyPMSG || !pSourcePMSG)
    {
        return E_POINTER;
    }
#endif
    HRESULT hr = AllocPMsg(pSourcePMSG->dwSize,ppCopyPMSG);
    if (SUCCEEDED(hr))
    {
        memcpy(*ppCopyPMSG,pSourcePMSG,pSourcePMSG->dwSize);
        if (pSourcePMSG->punkUser)
        {
            pSourcePMSG->punkUser->AddRef();
        }
        if (pSourcePMSG->pTool)
        {
            pSourcePMSG->pTool->AddRef();
        }
        if (pSourcePMSG->pGraph)
        {
            pSourcePMSG->pGraph->AddRef();
        }
    }
    return hr;
}


//////////////////////////////////////////////////////////////////////
// CPerformance::AllocPMsg
/*
  @method HRESULT | IDirectMusicPerformance | AllocPMsg |
  Allocate a DMUS_PMSG.

  @rvalue E_OUTOFMEMORY | Out of memory.
  @rvalue S_OK | Success.
  @rvalue E_INVALIDARG | <p cb> is smaller than sizeof(DMUS_PMSG)
  @rvalue E_POINTER | <p ppPMSG> is NULL or invalid.
*/
HRESULT STDMETHODCALLTYPE CPerformance::AllocPMsg(
    ULONG cb,               // @parm Size of the <p ppPMSG>. Must be equal to or greater
                            // than sizeof(DMUS_PMSG).
    DMUS_PMSG** ppPMSG  // @parm Returns the pointer to the allocated message, which will
                            // be of size <p cb>. All fields are initialized to zero,
                            // except dwSize which is initialized to <p cb>.
    )
{
    V_INAME(IDirectMusicPerformance::AllocPMsg);
    if( m_dwVersion < 8)
    {
        V_PTRPTR_WRITE(ppPMSG);
    }
    else
    {
#ifdef DBG
        V_PTRPTR_WRITE(ppPMSG);
#else
        if (!ppPMSG)
        {
            return E_POINTER;
        }
#endif
    }
    PRIV_PMSG* pPrivPMsg;

    if( cb < sizeof(DMUS_PMSG) )
        return E_INVALIDARG;

    EnterCriticalSection(&m_PMsgCacheCrSec);
    // cached pmsg's are stored in an array based on their public size.
    // If a cached pmsg exists, return it. Otherwise, make a new one.
    if( (cb >= PERF_PMSG_CB_MIN) && (cb < PERF_PMSG_CB_MAX) )
    {
        ULONG cbIndex = cb - PERF_PMSG_CB_MIN;
        if( m_apPMsgCache[ cbIndex ] )
        {
            pPrivPMsg = m_apPMsgCache[ cbIndex ];
            m_apPMsgCache[ cbIndex ] = pPrivPMsg->pNext;
            pPrivPMsg->pNext = NULL;
            if (pPrivPMsg->dwPrivFlags != PRIV_FLAG_FREE)
            {
                Trace(0,"Error - previously freed PMsg has been mangled.\n");
                LeaveCriticalSection(&m_PMsgCacheCrSec);
                return E_FAIL;
            }
            pPrivPMsg->dwPrivFlags = PRIV_FLAG_ALLOC;
            if (m_fInTrackPlay) pPrivPMsg->dwPrivFlags |= PRIV_FLAG_TRACK;
            *ppPMSG = PRIV_TO_DMUS(pPrivPMsg);
            LeaveCriticalSection(&m_PMsgCacheCrSec);
            return S_OK;
        }
    }

    HRESULT hr = S_OK;
    // no cached pmsg exists. Return a new one.
    ULONG cbPriv = cb + PRIV_PART_SIZE;
    pPrivPMsg = (PRIV_PMSG*)(new char[cbPriv]);
    if( pPrivPMsg )
    {
        memset( pPrivPMsg, 0, cbPriv );
        pPrivPMsg->dwSize = pPrivPMsg->dwPrivPubSize = cb; // size of public part only
        pPrivPMsg->dwPrivFlags = PRIV_FLAG_ALLOC;
        if (m_fInTrackPlay) pPrivPMsg->dwPrivFlags |= PRIV_FLAG_TRACK;
        *ppPMSG = PRIV_TO_DMUS(pPrivPMsg);
        hr = S_OK;
    }
    else
    {
        hr = E_OUTOFMEMORY;
    }
    LeaveCriticalSection(&m_PMsgCacheCrSec);
    return hr;
}

// private version of FreePMsg
HRESULT CPerformance::FreePMsg(
    PRIV_PMSG* pPMSG)
{
    return FreePMsg( PRIV_TO_DMUS(pPMSG) );
}


HRESULT STDMETHODCALLTYPE CPerformance::FreePMsg(
    DMUS_PMSG*  pPMSG   // @parm The message to free. This message must have been allocated
                            // using <om .AllocPMsg>.
    )
{
    V_INAME(IDirectMusicPerformance::FreePMsg);
    if( m_dwVersion < 8)
    {
        V_BUFPTR_WRITE(pPMSG,sizeof(DMUS_PMSG));
    }
    else
    {
#ifdef DBG
        V_BUFPTR_WRITE(pPMSG,sizeof(DMUS_PMSG));
#else
        if (!pPMSG)
        {
            return E_POINTER;
        }
#endif
    }

    PRIV_PMSG* pPrivPMsg = DMUS_TO_PRIV(pPMSG);

    if( (pPrivPMsg->dwPrivFlags & PRIV_FLAG_ALLOC_MASK) != PRIV_FLAG_ALLOC )
    {
        Trace(0, "Error --- Attempt to free a PMsg that is not allocated memory.\n");
        // this isn't a msg allocated by AllocPMsg.
        return DMUS_E_CANNOT_FREE;
    }
    if( pPrivPMsg->dwPrivFlags & PRIV_FLAG_QUEUED )
    {
        TraceI(1, "Attempt to free a PMsg that is currently in the Performance queue.\n");
        return DMUS_E_CANNOT_FREE;
    }

    EnterCriticalSection(&m_PMsgCacheCrSec);
    if( pPMSG->pTool )
    {
        pPMSG->pTool->Release();
    }
    if( pPMSG->pGraph )
    {
        pPMSG->pGraph->Release();
    }
    if( pPMSG->punkUser )
    {
        pPMSG->punkUser->Release();
    }

    ULONG cbSize = pPrivPMsg->dwPrivPubSize;
    if( (cbSize >= PERF_PMSG_CB_MIN) && (cbSize < PERF_PMSG_CB_MAX) )
    {
        memset( pPrivPMsg, 0, cbSize + PRIV_PART_SIZE );
        pPrivPMsg->dwPrivFlags = PRIV_FLAG_FREE; // Mark this as in the free queue.
        pPrivPMsg->dwSize = pPrivPMsg->dwPrivPubSize = cbSize;
        pPrivPMsg->pNext = m_apPMsgCache[ cbSize - PERF_PMSG_CB_MIN ];
        m_apPMsgCache[ cbSize - PERF_PMSG_CB_MIN ] = pPrivPMsg;
    }
    else
    {
        delete [] pPrivPMsg;
    }
    LeaveCriticalSection(&m_PMsgCacheCrSec);
    return S_OK;
}

HRESULT CPerformance::FlushVirtualTrack(
    DWORD       dwId,
    MUSIC_TIME  mtTime,
    DWORD dwFlushFlags)
{
    EnterCriticalSection(&m_PipelineCrSec);
    FlushMainEventQueues( dwId, mtTime, mtTime, dwFlushFlags );
    LeaveCriticalSection(&m_PipelineCrSec);
    return S_OK;
}

/*
  Given a time, mtTime, returns the time of the next control segment in pmtNextSeg.
  Returns S_FALSE if none found, and sets pmtNextSeg to zero.
*/

HRESULT CPerformance::GetControlSegTime(
    MUSIC_TIME mtTime,
    MUSIC_TIME* pmtNextSeg)
{
    HRESULT hr = S_FALSE;
    *pmtNextSeg = 0;
    EnterCriticalSection( &m_SegmentCrSec );
    // search the secondary lists for a control segment
    CSegState* pTemp;
    for( pTemp = m_SegStateQueues[SQ_CON_DONE].GetHead(); pTemp; pTemp = pTemp->GetNext() )
    {
        if( pTemp->m_mtResolvedStart >= mtTime )
        {
            *pmtNextSeg = pTemp->m_mtResolvedStart;
            hr = S_OK;
            break;
        }
    }
    if( S_FALSE == hr ) // if this is still zero, check the current queue
    {
        for( pTemp = m_SegStateQueues[SQ_CON_PLAY].GetHead(); pTemp; pTemp = pTemp->GetNext() )
        {
            if( pTemp->m_mtResolvedStart >= mtTime )
            {
                *pmtNextSeg = pTemp->m_mtResolvedStart;
                hr = S_OK;
                break;
            }
        }
    }
    LeaveCriticalSection( &m_SegmentCrSec );
    return hr;
}

/*
  Given a time, mtTime, returns the time of the next primary segment in pmtNextSeg.
  Returns S_FALSE if none found, and sets pmtNextSeg to zero.
*/
HRESULT CPerformance::GetPriSegTime(
    MUSIC_TIME mtTime,
    MUSIC_TIME* pmtNextSeg)
{
    HRESULT hr = S_FALSE;
    *pmtNextSeg = 0;
    EnterCriticalSection( &m_SegmentCrSec );
    CSegState* pTemp;
    for( pTemp = m_SegStateQueues[SQ_PRI_PLAY].GetHead(); pTemp; pTemp = pTemp->GetNext() )
    {
        if( pTemp->m_mtResolvedStart > mtTime )
        {
            *pmtNextSeg = pTemp->m_mtResolvedStart;
            hr = S_OK;
            break;
        }
    }
    LeaveCriticalSection( &m_SegmentCrSec );
    return hr;
}

/*
  @method HRESULT | IDirectMusicPerformance | GetGraph |
  Returns the performance's Tool Graph, AddRef'd.

  @rvalue S_OK | Success.
  @rvalue DMUS_E_NOT_FOUND | There is no graph in the performance, and therefore
  one couldn't be returned.
  @rvalue E_POINTER | <p ppGraph> is NULL or invalid.
*/
HRESULT STDMETHODCALLTYPE CPerformance::GetGraph(
         IDirectMusicGraph** ppGraph // @parm Returns the tool graph pointer.
        )
{
    V_INAME(IDirectMusicPerformance::GetGraph);
    V_PTRPTR_WRITE(ppGraph);

    HRESULT hr;
    if ((m_dwVersion >= 8) && (m_dwAudioPathMode == 0))
    {
        Trace(1,"Error: Performance not initialized.\n");
        return DMUS_E_NOT_INIT;
    }
    EnterCriticalSection(&m_MainCrSec);
    if( m_pGraph )
    {
        *ppGraph = m_pGraph;
        m_pGraph->AddRef();
        hr = S_OK;
    }
    else
    {
        Trace(1,"Error: Performance does not currently have a tool graph installed.\n");
        hr = DMUS_E_NOT_FOUND;
    }
    LeaveCriticalSection(&m_MainCrSec);
    return hr;
}


HRESULT CPerformance::GetGraphInternal(
         IDirectMusicGraph** ppGraph )
{
    EnterCriticalSection(&m_MainCrSec);
    if( !m_pGraph )
    {
        m_pGraph = new CGraph;
    }
    LeaveCriticalSection(&m_MainCrSec);
    return GetGraph(ppGraph);
}

/*
  @method HRESULT | IDirectMusicPerformance | SetGraph |
  Replaces the performance's Tool Graph. <p pGraph> is AddRef'd inside this
  method. Any messages flowing through Tools in the current Tool Graph are deleted.

  @rvalue S_OK | Success.
  @rvalue E_POINTER | <p pGraph> is invalid.
*/
HRESULT STDMETHODCALLTYPE CPerformance::SetGraph(
         IDirectMusicGraph* pGraph  // @parm The tool graph pointer. May be NULL to clear
                                    // the current graph out of the performance.
        )
{
    V_INAME(IDirectMusicPerformance::SetGraph);
    V_INTERFACE_OPT(pGraph);

    if ((m_dwVersion >= 8) && (m_dwAudioPathMode == 0))
    {
        Trace(1,"Error: Performance not initialized.\n");
        return DMUS_E_NOT_INIT;
    }

    EnterCriticalSection(&m_MainCrSec);
    if( m_pGraph )
    {
        m_pGraph->Release();
    }
    m_pGraph = pGraph;
    if( pGraph )
    {
        pGraph->AddRef();
    }
    LeaveCriticalSection(&m_MainCrSec);
    return S_OK;
}


HRESULT STDMETHODCALLTYPE CPerformance::SetNotificationHandle(
     HANDLE hNotification,      // @parm The event handle created by CreateEvent, or
                                // 0 to clear out an existing handle.
     REFERENCE_TIME rtMinimum ) // @parm The minimum amount of time that the
                                // performance should hold notify messages before discarding them.
                                // 0 means to use the default minimum time of 20000000 reference time units,
                                // which is 2 seconds, or the previous value if this API has been called previously.
                                // If the application hasn't called <om .GetNotificationPMsg> by this time, the message is
                                // discarded to free the memory.
{
    EnterCriticalSection(&m_MainCrSec);
    m_hNotification = hNotification;
    if( rtMinimum )
    {
        m_rtNotificationDiscard = rtMinimum;
    }
    LeaveCriticalSection(&m_MainCrSec);
    return S_OK;
}

HRESULT STDMETHODCALLTYPE CPerformance::GetNotificationPMsg(
     DMUS_NOTIFICATION_PMSG** ppNotificationPMsg )

{
    V_INAME(IDirectMusicPerformance::GetNotificationPMsg);
    V_PTRPTR_WRITE(ppNotificationPMsg);

    HRESULT hr;
    EnterCriticalSection(&m_PipelineCrSec);
    if( m_NotificationQueue.GetHead() )
    {
        PRIV_PMSG* pPriv = m_NotificationQueue.Dequeue();
        ASSERT(pPriv);
        *ppNotificationPMsg = (DMUS_NOTIFICATION_PMSG*)PRIV_TO_DMUS(pPriv);
        hr = S_OK;
    }
    else
    {
        *ppNotificationPMsg = NULL;
        hr = S_FALSE;
    }
    LeaveCriticalSection(&m_PipelineCrSec);
    return hr;
}

void CPerformance::AddNotificationTypeToAllSegments( REFGUID rguidNotification )
{
    CSegState* pSegSt;
    DWORD dwCount;
    // Note: might be nice to optimize this so the same segment
    // doesn't get called multiple times
    EnterCriticalSection(&m_SegmentCrSec);
    for (dwCount = 0; dwCount < SQ_COUNT; dwCount++)
    {
        for( pSegSt = m_SegStateQueues[dwCount].GetHead(); pSegSt; pSegSt = pSegSt->GetNext() )
        {
            pSegSt->m_pSegment->AddNotificationType( rguidNotification, TRUE );
        }
    }
    LeaveCriticalSection(&m_SegmentCrSec);
}

void CPerformance::RemoveNotificationTypeFromAllSegments( REFGUID rguidNotification )
{
    CSegState* pSegSt;
    DWORD dwCount;
    // Note: might be nice to optimize this so the same segment
    // doesn't get called multiple times
    EnterCriticalSection(&m_SegmentCrSec);
    for (dwCount = 0; dwCount < SQ_COUNT; dwCount++)
    {
        for( pSegSt = m_SegStateQueues[dwCount].GetHead(); pSegSt; pSegSt = pSegSt->GetNext() )
        {
            pSegSt->m_pSegment->RemoveNotificationType( rguidNotification, TRUE );
        }
    }
    LeaveCriticalSection(&m_SegmentCrSec);
}

/*
  Check to see if this notification is already being tracked.
*/
CNotificationItem* CPerformance::FindNotification( REFGUID rguidNotification )
{
    CNotificationItem* pItem;

    pItem = m_NotificationList.GetHead();
    while(pItem)
    {
        if( rguidNotification == pItem->guidNotificationType )
        {
            break;
        }
        pItem = pItem->GetNext();
    }
    return pItem;
}

/*
  @method HRESULT | IDirectMusicPerformance | AddNotificationType |
  Adds a notification type to the performance. Notifications are identified
  by a guid. When a notification is added to the performance, notify messages
  are sent to the application, which provides a message handle on which to
  block through <om IDirectMusicPerformance.SetNotificationHandle>. All segments
  and tracks are automatically updated with the new notification by calling
  their AddNotificationType methods.

  @rvalue S_OK | Success.
  @rvalue S_FALSE | The requested notification is already on the performance.
  @rvalue E_OUTOFMEMORY | Out of memory.

  @xref <om .SetNotificationHandle>, <om .GetNotificationPMsg>, <om .RemoveNotificationType>
*/
HRESULT STDMETHODCALLTYPE CPerformance::AddNotificationType(
     REFGUID rguidNotification) // @parm The guid of the notification message to add.
{
    V_INAME(IDirectMusicPerformance::AddNotificationType);
    V_REFGUID(rguidNotification);

    CNotificationItem*  pItem;
    HRESULT hr = S_OK;

    EnterCriticalSection(&m_SegmentCrSec);
    if( NULL == FindNotification( rguidNotification ) )
    {
        pItem = new CNotificationItem;
        if( NULL == pItem )
        {
            hr = E_OUTOFMEMORY;
        }
        else
        {
            pItem->guidNotificationType = rguidNotification;
            m_NotificationList.Cat( pItem );
            AddNotificationTypeToAllSegments( rguidNotification );
        }
    }
    else
    {
        hr = S_FALSE;
    }
    LeaveCriticalSection(&m_SegmentCrSec);
    return hr;
}

/*
  @method HRESULT | IDirectMusicPerformance | RemoveNotificationType |
  Removes a previously added notification type from the performance. All
  segments and tracks are updated with the removed notification by calling
  their RemoveNotificationType methods.

  @rvalue S_OK | Success.
  @rvalue S_FALSE | The requested notification isn't currently active.

  @xref <om .SetNotificationHandle>, <om .GetNotificationPMsg>, <om .AddNotificationType>
*/
HRESULT STDMETHODCALLTYPE CPerformance::RemoveNotificationType(
     REFGUID rguidNotification) // @parm The guid of the notification message to remove.
                        // If GUID_NULL, remove all notifications.
{
    V_INAME(IDirectMusicPerformance::RemoveNotificationType);
    V_REFGUID(rguidNotification);

    HRESULT hr = S_OK;
    CNotificationItem* pItem;

    if( GUID_NULL == rguidNotification )
    {
        while (pItem = m_NotificationList.RemoveHead())
        {
            RemoveNotificationTypeFromAllSegments( pItem->guidNotificationType );
            delete pItem;
        }
    }
    else
    {
        if( pItem = FindNotification( rguidNotification ))
        {
            RemoveNotificationTypeFromAllSegments( pItem->guidNotificationType );
            m_NotificationList.Remove( pItem );
            delete pItem;
        }
        else
        {
            Trace(2,"Warning: Unable to remove requested notification because it is not currently installed.\n");
            hr = S_FALSE;
        }
    }
    return hr;
}

void CPerformance::RemoveUnusedPorts()


{
    DWORD dwIndex;
    EnterCriticalSection(&m_PChannelInfoCrSec);
    for( dwIndex = 0; dwIndex < m_dwNumPorts; dwIndex++ )
    {
        if( m_pPortTable[dwIndex].pPort && !m_AudioPathList.UsesPort(m_pPortTable[dwIndex].pPort))
        {
            // release the port and buffer. NULL them in the table. PChannels
            // that map will return an error code.
            ASSERT( m_pPortTable[dwIndex].pBuffer );
            m_pPortTable[dwIndex].pPort->Release();
            m_pPortTable[dwIndex].pBuffer->Release();
            if( m_pPortTable[dwIndex].pLatencyClock )
            {
//                m_pPortTable[dwIndex].pLatencyClock->Release();
            }
            memset( &m_pPortTable[dwIndex], 0, sizeof( PortTable ));
            CChannelBlock *pBlock = m_ChannelBlockList.GetHead();
            CChannelBlock *pNext;
            for(;pBlock;pBlock = pNext)
            {
                pNext = pBlock->GetNext();
                if (pBlock->m_dwPortIndex == dwIndex)
                {
                    m_ChannelBlockList.Remove(pBlock);
                    delete pBlock;
                }
            }
        }
    }
    LeaveCriticalSection(&m_PChannelInfoCrSec);
}

HRESULT CPerformance::GetPathPort(CPortConfig *pConfig)

{
    HRESULT hr = S_OK;
    DWORD dwPort;
    EnterCriticalSection(&m_PChannelInfoCrSec);
    GUID &guidScan = pConfig->m_PortHeader.guidPort;
    // If we are looking for the default synth, get the class id for the default synth.
    BOOL fDefault = (pConfig->m_PortHeader.guidPort == GUID_Synth_Default);
    if (fDefault)
    {
        guidScan = m_AudioParams.clsidDefaultSynth;
    }
    for (dwPort = 0;dwPort < m_dwNumPorts;dwPort++)
    {
        if ((m_pPortTable[dwPort].guidPortID == guidScan) && m_pPortTable[dwPort].pPort)
        {
            pConfig->m_dwPortID = dwPort;
            pConfig->m_pPort = m_pPortTable[dwPort].pPort;
            pConfig->m_PortParams = m_pPortTable[dwPort].PortParams;
            ASSERT(pConfig->m_pPort);
            pConfig->m_pPort->AddRef();
            break;
        }
    }
    LeaveCriticalSection(&m_PChannelInfoCrSec);
    // Failed finding the port, so create it.
    if (dwPort >= m_dwNumPorts)
    {
        BOOL fUseBuffers = FALSE;
        pConfig->m_PortParams.dwSampleRate = m_AudioParams.dwSampleRate;
        if (m_AudioParams.dwFeatures & DMUS_AUDIOF_STREAMING)
        {
            pConfig->m_PortParams.dwFeatures |= DMUS_PORT_FEATURE_STREAMING;
        }
        if (m_AudioParams.dwFeatures & DMUS_AUDIOF_BUFFERS)
        {
            fUseBuffers = TRUE;
            pConfig->m_PortParams.dwFeatures |= DMUS_PORT_FEATURE_AUDIOPATH;
        }
        pConfig->m_PortParams.dwValidParams |= DMUS_PORTPARAMS_SAMPLERATE  | DMUS_PORTPARAMS_FEATURES;
        // If this wants a default synth, consult m_AudioParams and create that synth.
        if (fDefault)
        {
            pConfig->m_PortParams.dwAudioChannels = 1;
            pConfig->m_PortParams.dwVoices = m_AudioParams.dwVoices;
            pConfig->m_PortParams.dwValidParams |= DMUS_PORTPARAMS_AUDIOCHANNELS | DMUS_PORTPARAMS_VOICES;
        }
        hr = m_pDirectMusic->CreatePort(guidScan,&pConfig->m_PortParams,&pConfig->m_pPort, NULL);
        if (SUCCEEDED(hr))
        {
            if ((pConfig->m_PortParams.dwValidParams & DMUS_PORTPARAMS_FEATURES) && (pConfig->m_PortParams.dwFeatures & DMUS_PORT_FEATURE_AUDIOPATH))
            {
                IDirectMusicPortP* pPortP = NULL;
                // QI for the private interface.
                if (SUCCEEDED(pConfig->m_pPort->QueryInterface(IID_IDirectMusicPortP,(void **) &pPortP)))
                {
                    // Connect the port to the sink.
                    hr = pPortP->SetSink(m_BufferManager.m_pSinkConnect);
                    pPortP->Release();
                }
                else
                {
                    Trace(1,"Error: Attempt to create a port with audiopath buffer support failed because synth does not support buffers.\n");
                    hr = E_INVALIDARG;
                }
            }
            else if (fUseBuffers && fDefault)
            {
                Trace(1,"Error: Attempt to create a port with audiopath buffer support failed because default synth does not support buffers.\n");
                hr = E_INVALIDARG;
            }
        }
        if (SUCCEEDED(hr))
        {
            // Now add the port to the performance.
            hr = AddPort(pConfig->m_pPort,&pConfig->m_PortHeader.guidPort,
                &pConfig->m_PortParams,&pConfig->m_dwPortID);
        }
        if (SUCCEEDED(hr))
        {
            // Activate the port.
            hr = pConfig->m_pPort->Activate(TRUE);
            // It's okay if the synth is already active.
            if (hr == DMUS_E_SYNTHACTIVE)
            {
                hr = S_OK;
            }
        }
        if (SUCCEEDED(hr))
        {
            DWORD dwPortID = GetPortID(pConfig->m_pPort);
            // Then create matching channel blocks for all of the channel groups in the port.
            for (DWORD dwGroup = 0;dwGroup < pConfig->m_PortParams.dwChannelGroups; dwGroup++)
            {
                AllocVChannelBlock(dwPortID,dwGroup+1);
            }
        }
    }
    return (hr);
}

HRESULT STDMETHODCALLTYPE CPerformance::AddPort(
            IDirectMusicPort* pPort)
{
    V_INAME(IDirectMusicPerformance::AddPort);
    V_INTERFACE_OPT(pPort);
    if (m_dwAudioPathMode == 2)
    {
        Trace(1,"Error: Can not call AddPort() when using AudioPaths.\n");
        return DMUS_E_AUDIOPATHS_IN_USE;
    }
    m_dwAudioPathMode = 1;
    return AddPort(pPort,NULL,NULL,NULL);
}

HRESULT CPerformance::AddPort(
            IDirectMusicPort* pPort,
            GUID *pguidPortID,
            DMUS_PORTPARAMS8 *pParams,
            DWORD *pdwPortID)
{
    PortTable* pPortTable;
    IDirectMusicBuffer* pBuffer;
    BOOL    fSetUpBlock = FALSE;
    BOOL    fBuiltNewTable = FALSE;
    HRESULT hr = S_OK;
    GUID guidPortID;             // Class ID of port.
    DWORD dwChannelGroups;       // Number of channel groups at initialization.
    DWORD dwNewPortIndex = 0;    // Index into port array for new port.

    EnterCriticalSection(&m_MainCrSec);
    EnterCriticalSection(&m_PChannelInfoCrSec);

    if( NULL == m_pDirectMusic )
    {
        Trace(1,"Error: Performance is not initialized, ports can not be added.\n");
        hr = DMUS_E_NOT_INIT;
        goto END;
    }

    for (;dwNewPortIndex < m_dwNumPorts; dwNewPortIndex++)
    {
        if (!m_pPortTable[dwNewPortIndex].pPort)
        {
            break;
        }
    }

    if (dwNewPortIndex == m_dwNumPorts)
    {
        pPortTable = new PortTable[m_dwNumPorts + 1];
        if( !pPortTable )
        {
            hr = E_OUTOFMEMORY;
            goto END;
        }
        fBuiltNewTable = TRUE;
    }

    // if pPort is NULL, create a software synth port
    DMUS_PORTPARAMS dmpp;
    if( NULL == pPort )
    {
        pParams = &dmpp;
        memset(&dmpp, 0, sizeof(DMUS_PORTPARAMS) );
        dmpp.dwSize = sizeof(DMUS_PORTPARAMS);
        dmpp.dwChannelGroups = dwChannelGroups = 1;
        dmpp.dwValidParams = DMUS_PORTPARAMS_CHANNELGROUPS |
            DMUS_PORTPARAMS_AUDIOCHANNELS;
        dmpp.dwAudioChannels = 2;
        guidPortID = GUID_NULL;
        hr = m_pDirectMusic->CreatePort(GUID_NULL, &dmpp, &pPort, NULL);

        if ( SUCCEEDED( hr ) )
        {
            hr = pPort->Activate(TRUE);
        }


        fSetUpBlock = TRUE;
    }
    else
    {
        if (pguidPortID)
        {
            guidPortID = *pguidPortID;
        }
        else
        {
            DMUS_PORTCAPS PortCaps;
            PortCaps.dwSize = sizeof (PortCaps);
            pPort->GetCaps(&PortCaps);
            guidPortID = PortCaps.guidPort;
        }
        pPort->GetNumChannelGroups(&dwChannelGroups);
        pPort->AddRef();
    }
    if( FAILED(hr) || ( pPort == NULL ) )
    {
        if (fBuiltNewTable) delete [] pPortTable;
        Trace(1,"Error: Unable to open requested port.\n");
        hr = DMUS_E_CANNOT_OPEN_PORT;
        goto END;
    }

    // Create a buffer
    DMUS_BUFFERDESC dmbd;
    memset( &dmbd, 0, sizeof(DMUS_BUFFERDESC) );
    dmbd.dwSize = sizeof(DMUS_BUFFERDESC);
    dmbd.cbBuffer = DEFAULT_BUFFER_SIZE;
    if( FAILED( m_pDirectMusic->CreateMusicBuffer(&dmbd, &pBuffer, NULL)))
    {
        if (fBuiltNewTable) delete [] pPortTable;
        pPort->Release();
        Trace(1,"Error: Unable to create MIDI buffer for port.\n");
        hr = DMUS_E_CANNOT_OPEN_PORT;
        goto END;
    }

    if (fBuiltNewTable)
    {
        // if there is an existing port table, copy its contents to the new, bigger, port table
        if( m_pPortTable )
        {
            if( m_dwNumPorts > 0 )
            {
                memcpy( pPortTable, m_pPortTable, sizeof(PortTable) * ( m_dwNumPorts ) );
            }
            delete [] m_pPortTable;
        }
        m_pPortTable = pPortTable;
    }
    if (pdwPortID)
    {
        *pdwPortID = dwNewPortIndex;
    }
    pPortTable = &m_pPortTable[dwNewPortIndex];
    pPortTable->pPort = pPort;
    // If we have a passed params structure, copy it. This will be used for identifying the
    // params as initialized by the synth.
    if (pParams)
    {
        pPortTable->PortParams = *pParams;
    }
    pPortTable->dwGMFlags = 0;
    //set master volume
    IKsControl *pControl;
    if(SUCCEEDED(pPort->QueryInterface(IID_IKsControl, (void**)&pControl)))
    {
        KSPROPERTY ksp;
        ULONG cb;

        memset(&ksp, 0, sizeof(ksp));
        ksp.Set   = GUID_DMUS_PROP_Volume;
        ksp.Id    = 0;
        ksp.Flags = KSPROPERTY_TYPE_SET;

        pControl->KsProperty(&ksp,
                            sizeof(ksp),
                            (LPVOID)&m_lMasterVolume,
                            sizeof(m_lMasterVolume),
                            &cb);
        // Now, find out if it has a gm, gs, or xg sets in rom...
        BOOL bIsSupported = FALSE;
        ksp.Set     = GUID_DMUS_PROP_GM_Hardware;
        ksp.Flags   = KSPROPERTY_TYPE_GET;

        hr = pControl->KsProperty(&ksp,
                            sizeof(ksp),
                            (LPVOID)&bIsSupported,
                            sizeof(bIsSupported),
                            &cb);
        if (SUCCEEDED(hr) && (bIsSupported))
        {
            pPortTable->dwGMFlags |= DM_PORTFLAGS_GM;
        }
        bIsSupported = FALSE;
        ksp.Set     = GUID_DMUS_PROP_GS_Hardware;
        ksp.Flags   = KSPROPERTY_TYPE_GET;

        hr = pControl->KsProperty(&ksp,
                            sizeof(ksp),
                            (LPVOID)&bIsSupported,
                            sizeof(bIsSupported),
                            &cb);
        if (SUCCEEDED(hr) && (bIsSupported))
        {
            pPortTable->dwGMFlags |= DM_PORTFLAGS_GS;
        }
        bIsSupported = FALSE;
        ksp.Set     = GUID_DMUS_PROP_XG_Hardware;
        ksp.Flags   = KSPROPERTY_TYPE_GET;

        hr = pControl->KsProperty(&ksp,
                            sizeof(ksp),
                            (LPVOID)&bIsSupported,
                            sizeof(bIsSupported),
                            &cb);
        if (SUCCEEDED(hr) && (bIsSupported))
        {
            pPortTable->dwGMFlags |= DM_PORTFLAGS_XG;
        }
        pControl->Release();
    }

    if( FAILED( pPort->GetLatencyClock( &pPortTable->pLatencyClock )))
    {
        pPortTable->pLatencyClock = NULL;
    }
    pPortTable->dwChannelGroups = dwChannelGroups;
    pPortTable->guidPortID = guidPortID;
    pPortTable->pBuffer = pBuffer;
    pPortTable->fBufferFilled = FALSE;
    pPortTable->rtLast = 0;
    if (fBuiltNewTable) m_dwNumPorts++; // must do this before calling AssignPChannelBlock
    if( fSetUpBlock && m_ChannelBlockList.IsEmpty() ) // set up default PChannel map if none already set
    {
        AssignPChannelBlock( 0, pPort, 1);
    }
    hr = S_OK;
END:
    LeaveCriticalSection(&m_PChannelInfoCrSec);
    LeaveCriticalSection(&m_MainCrSec);

    return hr;
}

HRESULT STDMETHODCALLTYPE CPerformance::RemovePort(
            IDirectMusicPort* pPort     // @parm The port to remove.
        )
{
    V_INAME(IDirectMusicPerformance::RemovePort);
    V_INTERFACE(pPort);

    DWORD dwIndex;
    HRESULT hr = E_INVALIDARG;

    EnterCriticalSection(&m_PChannelInfoCrSec);
    for( dwIndex = 0; dwIndex < m_dwNumPorts; dwIndex++ )
    {
        if( m_pPortTable[dwIndex].pPort == pPort )
        {
            // release the port and buffer. NULL them in the table. PChannels
            // that map will return an error code.
            ASSERT( m_pPortTable[dwIndex].pBuffer );
            m_pPortTable[dwIndex].pPort->Release();
            m_pPortTable[dwIndex].pBuffer->Release();
            if( m_pPortTable[dwIndex].pLatencyClock )
            {
                m_pPortTable[dwIndex].pLatencyClock->Release();
            }
            memset( &m_pPortTable[dwIndex], 0, sizeof( PortTable ));
            hr = S_OK;
            break;
        }
    }
#ifdef DBG
    if (hr == E_INVALIDARG)
    {
        Trace(1,"Error: Invalid port passed to RemovePort().\n");
    }
#endif
    LeaveCriticalSection(&m_PChannelInfoCrSec);
    return hr;
}

// this must be called from within a PChannelCrSec critical section.
HRESULT CPerformance::AssignPChannelBlock(
            DWORD dwBlockNum,
            DWORD dwPortIndex,
            DWORD dwGroup,
            WORD wFlags)
{
    // see if we've already allocated this block before
    // blocknum is PChannel / 16, so search on that.
    DWORD dwPChannel = dwBlockNum * 16;
    CChannelBlock* pChannelBlock = m_ChannelBlockList.GetHead();

    for( ; pChannelBlock; pChannelBlock = pChannelBlock->GetNext() )
    {
        if( pChannelBlock->m_dwPChannelStart == dwPChannel )
        {
            pChannelBlock->Init(dwPChannel,dwPortIndex,dwGroup,wFlags);
            break;
        }
    }
    if( !pChannelBlock )
    {
        pChannelBlock = new CChannelBlock;
        if( !pChannelBlock )
        {
            return E_OUTOFMEMORY;
        }
        pChannelBlock->Init(dwPChannel,dwPortIndex,dwGroup,wFlags);
        m_ChannelBlockList.AddHead(pChannelBlock);
        pChannelBlock->m_dwPChannelStart = dwPChannel;
    }
    return S_OK;
}

// this must be called from within a PChannelCrSec critical section.
HRESULT CPerformance::AssignPChannel(
            DWORD dwPChannel,
            DWORD dwPortIndex,
            DWORD dwGroup,
            DWORD dwMChannel,
            WORD wFlags)
{
    DWORD dwIndex;
    CChannelBlock* pChannelBlock = m_ChannelBlockList.GetHead();

    for( ; pChannelBlock; pChannelBlock = pChannelBlock->GetNext() )
    {
        if( pChannelBlock->m_dwPChannelStart <= dwPChannel )
        {
            if( pChannelBlock->m_dwPChannelStart + PCHANNEL_BLOCKSIZE > dwPChannel )
            {
                break;
            }
        }
    }
    if( !pChannelBlock )
    {
        // there is no currently existing block that encompases dwPChannel.
        // Create one.
        pChannelBlock = new CChannelBlock;

        if( !pChannelBlock )
        {
            return E_OUTOFMEMORY;
        }
        pChannelBlock->Init(dwPChannel,0,0,CMAP_FREE);
        m_ChannelBlockList.AddHead(pChannelBlock);
    }

    dwIndex = dwPChannel - pChannelBlock->m_dwPChannelStart;

    ASSERT( dwIndex < PCHANNEL_BLOCKSIZE );
    CChannelMap *pMap = &pChannelBlock->m_aChannelMap[dwIndex];
    pMap->dwPortIndex = dwPortIndex;
    pMap->dwGroup = dwGroup;
    pMap->dwMChannel = dwMChannel;
    pMap->nTranspose = 0;
    if ((pMap->wFlags & CMAP_FREE) && !(wFlags & CMAP_FREE))
        pChannelBlock->m_dwFreeChannels--;
    else if (!(pMap->wFlags & CMAP_FREE) && (wFlags & CMAP_FREE))
        pChannelBlock->m_dwFreeChannels++;
    pMap->wFlags = wFlags;
    return S_OK;
}

HRESULT STDMETHODCALLTYPE CPerformance::AssignPChannelBlock(
            DWORD dwBlockNum,           // @parm The block number. Should be 0 or greater.
            IDirectMusicPort* pPort,    // @parm The port.
            DWORD dwGroup               // @parm The group on the port. Should be 1 or greater.
        )
{
    V_INAME(IDirectMusicPerformance::AssignPChannelBlock);
    V_INTERFACE(pPort);


    if (m_dwAudioPathMode == 2)
    {
        Trace(1,"Error: Can not call AssignPChannelBlock() when using AudioPaths.\n");
        return DMUS_E_AUDIOPATHS_IN_USE;
    }
    m_dwAudioPathMode = 1;
    DWORD dwIndex;
    HRESULT hr = E_INVALIDARG;
    EnterCriticalSection(&m_PChannelInfoCrSec);
    for( dwIndex = 0; dwIndex < m_dwNumPorts; dwIndex++ )
    {
        if( m_pPortTable[dwIndex].pPort == pPort )
        {
            if( SUCCEEDED( hr = AssignPChannelBlock( dwBlockNum, dwIndex, dwGroup, CMAP_STATIC )))
            {
                if (m_pPortTable[dwIndex].dwChannelGroups < dwGroup)
                {
                    hr = S_FALSE;
                }
            }
            break;
        }
    }
#ifdef DBG
    if (hr == E_INVALIDARG)
    {
        Trace(1,"Error: AssignPChannelBlock() called with invalid port.\n");
    }
#endif
    LeaveCriticalSection(&m_PChannelInfoCrSec);
    return hr;
}

HRESULT STDMETHODCALLTYPE CPerformance::AssignPChannel(
            DWORD dwPChannel,           // @parm The PChannel.
            IDirectMusicPort* pPort,    // @parm The port.
            DWORD dwGroup,              // @parm The group on the port.
            DWORD dwMChannel            // @parm The channel on the group.
        )
{
    V_INAME(IDirectMusicPerformance::AssignPChannel);
    V_INTERFACE(pPort);


    if (m_dwAudioPathMode == 2)
    {
        Trace(1,"Error: Can not call AssignPChannel() when using AudioPaths.\n");
        return DMUS_E_AUDIOPATHS_IN_USE;
    }
    m_dwAudioPathMode = 1;
    DWORD dwIndex;
    HRESULT hr = E_INVALIDARG;
    if( (dwMChannel < 0) || (dwMChannel > 15))
    {
        Trace(1,"Error: AssignPChannel() called with invalid MIDI Channel %ld.\n",dwMChannel);
        return E_INVALIDARG;
    }
    EnterCriticalSection(&m_PChannelInfoCrSec);
    for( dwIndex = 0; dwIndex < m_dwNumPorts; dwIndex++ )
    {
        if( m_pPortTable[dwIndex].pPort == pPort )
        {
            if( SUCCEEDED( hr = AssignPChannel( dwPChannel, dwIndex, dwGroup, dwMChannel, CMAP_STATIC )))
            {
                if (m_pPortTable[dwIndex].dwChannelGroups < dwGroup)
                {
                    hr = S_FALSE;
                }
            }
            break;
        }
    }
    LeaveCriticalSection(&m_PChannelInfoCrSec);
    return hr;
}

/*  ReleasePChannel finds the requested PChannel and makes it available
    for reuse.
    It also calls ResetAllControllers(), which sends MIDI CC 121 and 123,
    reset all controllers and all notes off.
*/

HRESULT CPerformance::ReleasePChannel(DWORD dwPChannel)
{
    HRESULT hr = E_INVALIDARG;
    EnterCriticalSection(&m_PChannelInfoCrSec);
    CChannelBlock* pChannelBlock = m_ChannelBlockList.GetHead();
    for( ; pChannelBlock; pChannelBlock = pChannelBlock->GetNext() )
    {
        if( pChannelBlock->m_dwPChannelStart <= dwPChannel )
        {
            if( pChannelBlock->m_dwPChannelStart + PCHANNEL_BLOCKSIZE > dwPChannel )
            {
                break;
            }
        }
    }
    if( pChannelBlock )
    {
        // Only release if this is genuinely a virtual pchannel. Otherwise, leave alone.
        CChannelMap *pMap = &pChannelBlock->m_aChannelMap[dwPChannel - pChannelBlock->m_dwPChannelStart];
        if (pMap->wFlags & CMAP_VIRTUAL)
        {
            pChannelBlock->m_dwFreeChannels++;
            // Clear out all the merge lists, etc.
            pMap->Clear();
            // Reset controllers, but don't send a GM reset.
            ResetAllControllers(pMap,0, false);
        }
        hr = S_OK;
    }
    LeaveCriticalSection(&m_PChannelInfoCrSec);
    return hr;
}

HRESULT CPerformance::GetPort(DWORD dwPortID, IDirectMusicPort **ppPort)

{
    HRESULT hr;
    EnterCriticalSection(&m_PChannelInfoCrSec);
    if (dwPortID < m_dwNumPorts)
    {
        *ppPort = m_pPortTable[dwPortID].pPort;
        (*ppPort)->AddRef();
        hr = S_OK;
    }
    else
    {
        Trace(1,"Error: Unable to find requested port.\n");
        hr = E_FAIL;
    }
    LeaveCriticalSection(&m_PChannelInfoCrSec);
    return hr;
}


HRESULT CPerformance::AllocVChannel(DWORD dwPortID, DWORD dwDrumFlags, DWORD *pdwPChannel, DWORD *pdwGroup,DWORD *pdwMChannel)
{
    // dwDrumsFlags:
    // bit 0 determines whether this port separates out drums on channel 10.
    // bit 1 determines whether this request is for a drum.
    // First, figure out if we are scanning for drums on channel 10, melodic instruments
    // on the other channels, or any on all channels.
    static DWORD sdwSearchForDrums[1] = { 9 };
    static DWORD sdwSearchForAll[16] = { 0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15 };
    static DWORD sdwSearchForMelodic[15] = { 0,1,2,3,4,5,6,7,8,10,11,12,13,14,15 };
    DWORD *pSearchArray = sdwSearchForAll;
    DWORD dwSearchSize = 16;
    if (dwDrumFlags & 1) // Do we handle drums as a special case for channel 10?
    {
        if (dwDrumFlags & 2) // And are we looking for drums on channel 10?
        {
            pSearchArray = sdwSearchForDrums;
            dwSearchSize = 1;
        }
        else
        {
            pSearchArray = sdwSearchForMelodic;
            dwSearchSize = 15;
        }
    }
    HRESULT hr = E_INVALIDARG; // Return this if the vChannel is out of range.
    EnterCriticalSection(&m_PChannelInfoCrSec);

    CChannelBlock* pChannelBlock = m_ChannelBlockList.GetHead();
    BOOL fNotFound = TRUE;              // Use to indicate when we finally find a match.
    DWORD dwHighestPChannel = 0;        // Keep track of the highest PCHannel in use, this will be
                                        // used to create a new PChannel block, if needed.
    DWORD dwChannel;
    for (;fNotFound && pChannelBlock;pChannelBlock = pChannelBlock->GetNext() )
    {
        if (dwHighestPChannel < pChannelBlock->m_dwPChannelStart)
        {
            dwHighestPChannel = pChannelBlock->m_dwPChannelStart;
        }
        if ((pChannelBlock->m_dwPortIndex == dwPortID) && (pChannelBlock->m_dwFreeChannels))
        {
            DWORD dwIndex;
            for (dwIndex = 0; dwIndex < dwSearchSize; dwIndex++)
            {
                dwChannel = pSearchArray[dwIndex];
                if (pChannelBlock->m_aChannelMap[dwChannel].wFlags & CMAP_FREE)
                {
                    *pdwPChannel = pChannelBlock->m_dwPChannelStart + dwChannel;
                    pChannelBlock->m_dwFreeChannels--;
                    pChannelBlock->m_aChannelMap[dwChannel].wFlags = CMAP_VIRTUAL;
                    *pdwGroup = pChannelBlock->m_aChannelMap[dwChannel].dwGroup;
                    *pdwMChannel = pChannelBlock->m_aChannelMap[dwChannel].dwMChannel;
                    fNotFound = FALSE;
                    hr = S_OK;
                    break;
                }
            }
        }
    }
    if( fNotFound )
    {
        // there is no currently existing block that has a free channel.
        // Create one.
        IDirectMusicPort *pPort = m_pPortTable[dwPortID].pPort;
        DWORD dwChannelGroupCount;
        pPort->GetNumChannelGroups(&dwChannelGroupCount);
        dwChannelGroupCount++;
        hr = pPort->SetNumChannelGroups(dwChannelGroupCount);
        if (SUCCEEDED(hr))
        {
            m_pPortTable[dwPortID].dwChannelGroups = dwChannelGroupCount;
            hr = E_OUTOFMEMORY;
            dwHighestPChannel += PCHANNEL_BLOCKSIZE;
            pChannelBlock = new CChannelBlock;
            if (pChannelBlock)
            {
                pChannelBlock->Init(dwHighestPChannel,dwPortID,dwChannelGroupCount,CMAP_FREE);
                m_ChannelBlockList.AddTail(pChannelBlock);
                dwChannel = pSearchArray[0];  // Which channel should we use?
                CChannelMap *pMap = &pChannelBlock->m_aChannelMap[dwChannel];
                pMap->dwMChannel = dwChannel;
                pMap->wFlags = CMAP_VIRTUAL;
                pChannelBlock->m_dwFreeChannels--;
                *pdwPChannel = dwChannel + dwHighestPChannel;
                *pdwGroup = pMap->dwGroup;
                *pdwMChannel = dwChannel;
                hr = S_OK;
            }
        }
    }
#ifdef DBG
    if (hr == E_INVALIDARG)
    {
        Trace(1,"Error: Unable to allocated dynamic PChannel.\n");
    }
#endif
    LeaveCriticalSection(&m_PChannelInfoCrSec);
    return hr;
}

HRESULT CPerformance::AllocVChannelBlock(DWORD dwPortID,DWORD dwGroup)
{
    EnterCriticalSection(&m_PChannelInfoCrSec);

    CChannelBlock* pChannelBlock = m_ChannelBlockList.GetHead();
    long lHighestPChannel = -PCHANNEL_BLOCKSIZE;
    for (;pChannelBlock;pChannelBlock = pChannelBlock->GetNext() )
    {
        if (lHighestPChannel < (long) pChannelBlock->m_dwPChannelStart)
        {
            lHighestPChannel = pChannelBlock->m_dwPChannelStart;
        }
    }
    HRESULT hr = E_OUTOFMEMORY;
    lHighestPChannel += PCHANNEL_BLOCKSIZE;
    pChannelBlock = new CChannelBlock;
    if (pChannelBlock)
    {
        pChannelBlock->Init((DWORD) lHighestPChannel,dwPortID,dwGroup,CMAP_FREE);
        m_ChannelBlockList.AddTail(pChannelBlock);
        hr = S_OK;
    }
    LeaveCriticalSection(&m_PChannelInfoCrSec);
    return hr;
}


#ifdef DBG
void CPerformance::TraceAllChannelMaps()

{
    EnterCriticalSection(&m_PChannelInfoCrSec);
    CChannelBlock* pChannelBlock = m_ChannelBlockList.GetHead();
    for( ; pChannelBlock; pChannelBlock = pChannelBlock->GetNext() )
    {
        TraceI(0,"ChannelBlock %lx, Free %ld\n",pChannelBlock->m_dwPChannelStart,pChannelBlock->m_dwFreeChannels);
        DWORD dwIndex;
        for (dwIndex = 0; dwIndex < PCHANNEL_BLOCKSIZE; dwIndex++)
        {
            CChannelMap *pMap = &pChannelBlock->m_aChannelMap[dwIndex];
            TraceI(0,"\tPort %ld, Group: %ld, MIDI: %ld, Transpose: %ld, Flags: %ld\n",
                pMap->dwPortIndex, pMap->dwGroup, pMap->dwMChannel, (long) pMap->nTranspose, (long) pMap->wFlags);
        }
    }
    LeaveCriticalSection(&m_PChannelInfoCrSec);
}

#endif


/* Note that the following must be called from within a m_PChannelInfoCrSec
   critical section and stay within that critical section for the duration
   of using the returned CChannelMap.
*/


CChannelMap * CPerformance::GetPChannelMap( DWORD dwPChannel )
{
    CChannelBlock*  pChannelBlock = m_ChannelBlockList.GetHead();

    for( ; pChannelBlock; pChannelBlock = pChannelBlock->GetNext() )
    {
        if( ( dwPChannel >= pChannelBlock->m_dwPChannelStart ) &&
            ( dwPChannel < pChannelBlock->m_dwPChannelStart + PCHANNEL_BLOCKSIZE ) )
        {
            CChannelMap* pChannelMap;

            pChannelMap = &pChannelBlock->m_aChannelMap[ dwPChannel - pChannelBlock->m_dwPChannelStart ];
            if( pChannelMap->dwGroup == 0 )
            {
                // this PChannel isn't on a valid group, therefore it hasn't
                // been set.
//              return NULL;
            }
            return pChannelMap;
        }
    }
    return NULL;
}

/*
  internal version
*/

HRESULT CPerformance::PChannelIndex( DWORD dwPChannel, DWORD* pdwIndex,
            DWORD* pdwGroup, DWORD* pdwMChannel, short* pnTranspose )
{
    if (m_dwAudioPathMode == 0)
    {
        Trace(1,"Error: Performance not initialized.\n");
        return DMUS_E_NOT_INIT;
    }
    HRESULT hr;
    EnterCriticalSection(&m_PChannelInfoCrSec);
    CChannelMap *pChannelMap = GetPChannelMap(dwPChannel);
    if (pChannelMap)
    {
        ASSERT( pdwIndex && pdwGroup && pdwMChannel );

        *pdwIndex = pChannelMap->dwPortIndex;
        *pdwGroup = pChannelMap->dwGroup;
        *pdwMChannel = pChannelMap->dwMChannel;
        if( pnTranspose )
        {
            *pnTranspose = pChannelMap->nTranspose;
        }
        hr = S_OK;
    }
    else
    {
        Trace(1,"Error: PChannel %ld has not been assigned to a port.\n",dwPChannel);
        if (m_dwVersion < 8)
        {
            hr = E_INVALIDARG;
        }
        else
        {
            hr = DMUS_E_AUDIOPATH_NOPORT;
        }
    }
    LeaveCriticalSection(&m_PChannelInfoCrSec);
    return hr;
}

DWORD CPerformance::GetPortID(IDirectMusicPort * pPort)

{
    EnterCriticalSection(&m_PChannelInfoCrSec);
    DWORD dwID = 0;
    for (;dwID < m_dwNumPorts; dwID++)
    {
        if (pPort == m_pPortTable[dwID].pPort)
        {
            break;
        }
    }
    LeaveCriticalSection(&m_PChannelInfoCrSec);
    if (dwID == m_dwNumPorts) dwID = 0;
    return dwID;
}

STDMETHODIMP CPerformance::GetPortAndFlags(DWORD dwPChannel,IDirectMusicPort **ppPort,DWORD * pdwFlags)

{

    EnterCriticalSection(&m_PChannelInfoCrSec);
    DWORD dwIndex;
    DWORD dwGroup;
    DWORD dwMChannel;
    HRESULT hr = PChannelIndex( dwPChannel, &dwIndex, &dwGroup, &dwMChannel, NULL );
    if (SUCCEEDED(hr))
    {
        *ppPort = m_pPortTable[dwIndex].pPort;
        if( *ppPort )
        {
            m_pPortTable[dwIndex].pPort->AddRef();
        }
        else
        {
            Trace(1,"Error: Performance does not have a port assigned to PChannel %ld.\n",dwPChannel);
            hr = DMUS_E_NOT_INIT;
        }
        *pdwFlags = m_pPortTable[dwIndex].dwGMFlags;
    }
    LeaveCriticalSection(&m_PChannelInfoCrSec);
    return hr;
}

STDMETHODIMP CPerformance::PChannelInfo(
            DWORD dwPChannel,           // @parm The PChannel to convert.
            IDirectMusicPort** ppPort,  // @parm Returns the port. May be NULL.
            DWORD* pdwGroup,            // @parm Returns the group on the port. May be NULL.
            DWORD* pdwMChannel          // @parm Returns the channel on the group. May be NULL.
        )
{
    V_INAME(IDirectMusicPerformance::PChannelInfo);
    V_PTRPTR_WRITE_OPT(ppPort);
    V_PTR_WRITE_OPT(pdwGroup,DWORD);
    V_PTR_WRITE_OPT(pdwMChannel,DWORD);

    DWORD dwIndex, dwGroup, dwMChannel;
    HRESULT hr;

    if (m_dwAudioPathMode == 0)
    {
        Trace(1,"Error: Performance not initialized.\n");
        return DMUS_E_NOT_INIT;
    }
    EnterCriticalSection(&m_PChannelInfoCrSec);
    if( SUCCEEDED( PChannelIndex( dwPChannel, &dwIndex, &dwGroup, &dwMChannel )))
    {
        if( ppPort )
        {
            *ppPort = m_pPortTable[dwIndex].pPort;
            if( *ppPort )
            {
                m_pPortTable[dwIndex].pPort->AddRef();
            }
        }
        if( pdwGroup )
        {
            *pdwGroup = dwGroup;
        }
        if( pdwMChannel )
        {
            *pdwMChannel = dwMChannel;
        }
        hr = S_OK;
    }
    else
    {
        // No need to print an error message because PChannelIndex() does it.
        hr = E_INVALIDARG;
    }
    LeaveCriticalSection(&m_PChannelInfoCrSec);
    return hr;
}

/*
  @method HRESULT | IDirectMusicPerformance | DownloadInstrument |
  Downloads an IDirectMusicInstrument to the IDirectMusicPort specified by
  the selected PChannel.

  @rvalue E_INVALIDARG | The PChannel isn't assigned to a Port, or the Port failed
  to download the instrument. No return parameter is valid.
  @rvalue S_OK | Success.
  @rvalue E_POINTER | One of the pointers is invalid.
*/
HRESULT STDMETHODCALLTYPE CPerformance::DownloadInstrument(
    IDirectMusicInstrument* pInst,  // @parm The instrument to download.
    DWORD dwPChannel,               // @parm The PChannel to assign the instrument.
    IDirectMusicDownloadedInstrument** ppDownInst,  // @parm Returns the downloaded instrument.
    DMUS_NOTERANGE* pNoteRanges,    // @parm A pointer to an array of DMUS_NOTERANGE structures
    DWORD dwNumNoteRanges,          // @parm Number of DMUS_NOTERANGE structures in array pointed to by pNoteRanges
    IDirectMusicPort** ppPort,      // @parm Returns the port to which the instrument was downloaded.
    DWORD* pdwGroup,                // @parm Returns the group to which the instrument was assigned.
    DWORD* pdwMChannel              // @parm Returns the MChannel to which the instrument was assigned.
        )
{
    V_INAME(IDirectMusicPerformance::DownloadInstrument);
    V_INTERFACE(pInst);
    V_PTRPTR_WRITE(ppDownInst);
    V_BUFPTR_READ_OPT(pNoteRanges, (sizeof(DMUS_NOTERANGE) * dwNumNoteRanges));
    V_PTRPTR_WRITE(ppPort);
    V_PTR_WRITE(pdwGroup,DWORD);
    V_PTR_WRITE(pdwMChannel,DWORD);


    DWORD dwIndex, dwGroup, dwMChannel;
    IDirectMusicPort* pPort = NULL;
    HRESULT hr = E_INVALIDARG;

    if (m_dwAudioPathMode == 0)
    {
        Trace(1,"Error: Performance not initialized.\n");
        return DMUS_E_NOT_INIT;
    }
    EnterCriticalSection(&m_PChannelInfoCrSec);
    if( SUCCEEDED( PChannelIndex( dwPChannel, &dwIndex, &dwGroup, &dwMChannel )))
    {
        pPort = m_pPortTable[dwIndex].pPort;
        if( pPort )
        {
            hr = pPort->DownloadInstrument( pInst, ppDownInst, pNoteRanges, dwNumNoteRanges );
            pPort->AddRef();
        }
    }
    else
    {
        Trace(1,"Error: Download attempted on unassigned PChannel %ld\n",dwPChannel);
    }
    LeaveCriticalSection(&m_PChannelInfoCrSec);
    if( SUCCEEDED(hr) )
    {
        *ppPort = pPort;
        pPort->AddRef();
        *pdwGroup = dwGroup;
        *pdwMChannel = dwMChannel;
    }
    if( pPort )
    {
        pPort->Release();
    }
    return hr;
}

/*
  @method HRESULT | IDirectMusicPerformance | Invalidate |
  Flushes all methods from <p mtTime> forward, and seeks all Segments back
  to <p mtTime>, thereby calling all Tracks to resend their data.

  @rvalue S_OK | Success.
  @rvalue DMUS_E_NO_MASTER_CLOCK | There is no master clock in the performance.
  Make sure to call <om .Init> before calling this method.

  @comm If <p mtTime> is so long ago that it is impossible to invalidate that time,
  the earliest possible time will be used.
*/
HRESULT STDMETHODCALLTYPE CPerformance::Invalidate(
    MUSIC_TIME mtTime,  // @parm The time to invalidate, adjusted by <p dwFlags>. 0 means now.
    DWORD dwFlags)      // @parm Adjusts <p mtTime> to align to measures, beats, etc. See
                        // <t DMPLAYSEGFLAGS>.
{
    EnterCriticalSection(&m_MainCrSec);
    if( m_pClock == NULL )
    {
        LeaveCriticalSection(&m_MainCrSec);
         Trace(1,"Error: Invalidate() failed because the performance has not been initialized.\n");
        return DMUS_E_NO_MASTER_CLOCK;
    }
    LeaveCriticalSection(&m_MainCrSec);

    EnterCriticalSection( &m_SegmentCrSec );
    EnterCriticalSection( &m_PipelineCrSec );

    SendBuffers();

    // make sure mtTime is greater than the current queue time
    REFERENCE_TIME rtQueue;
    MUSIC_TIME mtQueue;
    MUSIC_TIME mtBumperLength;

    GetQueueTime( &rtQueue );
    ReferenceToMusicTime( rtQueue, &mtQueue );
    ReferenceToMusicTime( m_rtBumperLength, &mtBumperLength );
    if( mtTime < mtQueue + mtBumperLength )
    {
        mtTime = mtQueue + mtBumperLength;
    }
    // resolve mtTime to the boundary of dwFlags
    mtTime = ResolveTime( mtTime, dwFlags, NULL );
    // flush messages
    FlushMainEventQueues( 0, mtTime, mtQueue, 0 );
    // move any segments in the past list that are affected into the current list
    CSegState *pSegSt;
    CSegState *pNext;
    for (pSegSt = m_SegStateQueues[SQ_SEC_DONE].GetHead();pSegSt;pSegSt = pNext)
    {
        pNext = pSegSt->GetNext();
        if( pSegSt->m_mtLastPlayed > mtTime )
        {
            m_SegStateQueues[SQ_SEC_DONE].Remove(pSegSt);
            m_SegStateQueues[SQ_SEC_PLAY].Insert( pSegSt );
        }
    }
    for (pSegSt = m_SegStateQueues[SQ_CON_DONE].GetHead();pSegSt;pSegSt = pNext)
    {
        pNext = pSegSt->GetNext();
        if( pSegSt->m_mtLastPlayed > mtTime )
        {
            m_SegStateQueues[SQ_CON_DONE].Remove(pSegSt);
            m_SegStateQueues[SQ_CON_PLAY].Insert( pSegSt );
        }
    }
    pSegSt = m_SegStateQueues[SQ_PRI_DONE].GetTail();
    if(pSegSt)
    {
        // only check the last one in this list
        if( pSegSt->m_mtLastPlayed > mtTime )
        {
            m_SegStateQueues[SQ_PRI_DONE].Remove(pSegSt);
            m_SegStateQueues[SQ_PRI_PLAY].Insert( pSegSt );
        }
    }
    // seek back any affected segmentstates that were playing
    DWORD dwCount;
    for( dwCount = SQ_PRI_PLAY; dwCount <= SQ_SEC_PLAY; dwCount++ )
    {
        for( pSegSt = m_SegStateQueues[dwCount].GetHead(); pSegSt; pSegSt = pSegSt->GetNext() )
        {
            if( pSegSt->m_fStartedPlay && !(pSegSt->m_rtLength && pSegSt->m_rtLoopEnd))
            {
                if (SQ_PRI_PLAY == dwCount && pSegSt->m_mtResolvedStart >= mtTime)
                {
                    // resend the segment start notification
                    pSegSt->GenerateNotification( DMUS_NOTIFICATION_SEGSTART, pSegSt->m_mtResolvedStart );
                    // if this is a primary or controlling segment, resend a DMUS_PMSGT_DIRTY message
                    if( !(pSegSt->m_dwPlaySegFlags & DMUS_SEGF_SECONDARY) || (pSegSt->m_dwPlaySegFlags & DMUS_SEGF_CONTROL) )
                    {
                        TraceI(4, "ReSend Dirty PMsg [3] %d (%d)\n", pSegSt->m_mtSeek, pSegSt->m_mtOffset + pSegSt->m_mtSeek);
                        pSegSt->SendDirtyPMsg( pSegSt->m_mtOffset + pSegSt->m_mtSeek );
                    }
                }
                if( pSegSt->m_mtLastPlayed > mtTime )
                {
                    // if mtTime is after the actual start time of the segment,
                    // set it so the segment has never been played before and
                    // seek the segment to the beginning
                    if( pSegSt->m_mtResolvedStart > mtTime )
                    {
                        pSegSt->m_mtLastPlayed = pSegSt->m_mtResolvedStart;
                        pSegSt->m_fStartedPlay = FALSE;
                    }
                    else
                    {
                        pSegSt->m_mtLastPlayed = mtTime;
                    }
                    pSegSt->SetInvalidate( pSegSt->m_mtLastPlayed );
                }
            }
        }
    }

    LeaveCriticalSection( &m_PipelineCrSec );
    LeaveCriticalSection( &m_SegmentCrSec );
    // signal the transport thread so we don't have to wait for it to wake up on its own
    if( m_hTransport ) SetEvent( m_hTransport );
    return S_OK;
}

STDMETHODIMP CPerformance::SetParamHook(IDirectMusicParamHook *pIHook)

{   V_INAME(IDirectMusicPerformance::SetParamHook);
    V_INTERFACE_OPT(pIHook);

    EnterCriticalSection(&m_MainCrSec);
    if (m_pParamHook)
    {
        m_pParamHook->Release();
    }
    m_pParamHook = pIHook;
    if (pIHook)
    {
        pIHook->AddRef();
    }
    LeaveCriticalSection(&m_MainCrSec);
    return S_OK;
}

HRESULT STDMETHODCALLTYPE CPerformance::GetParamEx(
    REFGUID rguidType,
    DWORD dwTrackID,
    DWORD dwGroupBits,
    DWORD dwIndex,
    MUSIC_TIME mtTime,
    MUSIC_TIME* pmtNext,
    void* pData)

{
    V_INAME(IDirectMusicPerformance::GetParamEx);
    V_PTR_WRITE_OPT(pmtNext,MUSIC_TIME);
    V_PTR_WRITE_OPT(pData,1);
    V_REFGUID(rguidType);

    static DWORD dwSearchOrder[SQ_COUNT] = { SQ_PRI_PLAY, SQ_SEC_PLAY,
                                      SQ_PRI_DONE, SQ_SEC_DONE,
                                      SQ_PRI_WAIT, SQ_SEC_WAIT,
                                      SQ_CON_PLAY, SQ_CON_DONE,
                                      SQ_CON_WAIT };

    DWORD dwIX;
    HRESULT hr;
    CSegState *pSegNode;
    if (dwTrackID)
    {
        EnterCriticalSection(&m_SegmentCrSec);
        for (dwIX = 0; dwIX < SQ_COUNT; dwIX++)
        {
            pSegNode = m_SegStateQueues[dwSearchOrder[dwIX]].GetHead();
            for (;pSegNode;pSegNode = pSegNode->GetNext())
            {
                if ((pSegNode->m_dwFirstTrackID <= dwTrackID) &&
                    (pSegNode->m_dwLastTrackID >= dwTrackID))
                {
                    CTrack* pCTrack;
                    for (pCTrack = pSegNode->m_TrackList.GetHead();pCTrack;pCTrack = pCTrack->GetNext())
                    {
                        if (pCTrack->m_dwVirtualID == dwTrackID)
                        {
                            m_dwGetParamFlags = pCTrack->m_dwFlags;
                            m_pGetParamSegmentState = pSegNode;
                            break;
                        }
                    }
                    break;
                }
            }
        }
        LeaveCriticalSection(&m_SegmentCrSec);
    }
    else
    {
        m_pGetParamSegmentState = NULL;
        m_dwGetParamFlags = 0;
    }
    hr = GetParam(rguidType,dwGroupBits,dwIndex,mtTime,pmtNext,pData);
    m_pGetParamSegmentState = NULL;
    m_dwGetParamFlags = 0;
    return hr;
}

HRESULT STDMETHODCALLTYPE CPerformance::GetParam(
    REFGUID rguidType,
    DWORD dwGroupBits,
    DWORD dwIndex,
    MUSIC_TIME mtTime,
    MUSIC_TIME* pmtNext,
    void* pData)

{
    V_INAME(IDirectMusicPerformance::GetParam);
    V_PTR_WRITE_OPT(pmtNext,MUSIC_TIME);
    V_PTR_WRITE_OPT(pData,1);
    V_REFGUID(rguidType);

    EnterCriticalSection(&m_MainCrSec);
    if( m_pClock == NULL )
    {
        LeaveCriticalSection(&m_MainCrSec);
        Trace(1,"Error: GetParam() failed because the performance has not been initialized.\n");
        return DMUS_E_NO_MASTER_CLOCK;
    }
    LeaveCriticalSection(&m_MainCrSec);

    if( pmtNext )
    {
        *pmtNext = 0; // this will be replaced by calls to IDMSegment::GetParam
    }
    CSegState* pSegNode;
    CSegState* pSegSource = (CSegState *) m_pGetParamSegmentState;
    DWORD dwOverrideFlags;
    HRESULT hr = DMUS_E_NOT_FOUND;
    BOOL fCheckedPast = FALSE;
    MUSIC_TIME mtOffset;
    DWORD dwRepeat = 0;
    MUSIC_TIME mtSegTime = 0;
    MUSIC_TIME mtSegEnd = 0;
    MUSIC_TIME mtLoopEnd = 0;
    DWORD dwRepeatsLeft = 0;
    if (pSegSource)
    {
        dwOverrideFlags = m_dwGetParamFlags & (DMUS_TRACKCONFIG_OVERRIDE_ALL | DMUS_TRACKCONFIG_OVERRIDE_PRIMARY | DMUS_TRACKCONFIG_FALLBACK);
    }
    else
    {
        dwOverrideFlags = 0;
    }

    if (dwOverrideFlags & DMUS_TRACKCONFIG_OVERRIDE_ALL)
    {
        // The calling track wants the controlling param to come from the segment itself
        mtSegTime = mtTime;
        if( S_OK == pSegSource->ConvertToSegTime( &mtSegTime, &mtOffset, &dwRepeat ) )
        {
            hr = pSegSource->GetParam( this, rguidType, dwGroupBits, dwIndex,
                    mtSegTime, pmtNext, pData );
            if( SUCCEEDED(hr) )
            {
                dwRepeatsLeft = pSegSource->m_dwRepeats;
                mtLoopEnd = pSegSource->m_mtLoopEnd;
                mtSegEnd = pSegSource->m_mtLength;
                dwRepeatsLeft -= dwRepeat;
            }
        }
    }
    if (FAILED(hr))
    {
        EnterCriticalSection(&m_SegmentCrSec);
        // we only care about control segments
        if( m_SegStateQueues[SQ_CON_DONE].GetHead() )
        {
            pSegNode = m_SegStateQueues[SQ_CON_DONE].GetHead();
        }
        else
        {
            pSegNode = m_SegStateQueues[SQ_CON_PLAY].GetHead();
            fCheckedPast = TRUE;
        }
        while( pSegNode )
        {
            mtSegTime = mtTime;
            if( S_OK == pSegNode->ConvertToSegTime( &mtSegTime, &mtOffset, &dwRepeat ) )
            {
                hr = pSegNode->GetParam( this, rguidType, dwGroupBits, dwIndex,
                        mtSegTime, pmtNext, pData );
                if( SUCCEEDED(hr) )
                {
                    dwRepeatsLeft = pSegNode->m_dwRepeats;
                    mtLoopEnd = pSegNode->m_mtLoopEnd;
                    mtSegEnd = pSegNode->m_mtLength;
                    dwRepeatsLeft -= dwRepeat;

                    break; // got the param we want. We're outta this loop with a success.
                }
            }
            // we didn't find the param, so try the next segment.
            pSegNode = pSegNode->GetNext();

            // if we're the last segnode in the done queue, we need to
            // check against the time of the first segnode in the control play queue
            if (!pSegNode && !fCheckedPast )
            {
                pSegNode = m_SegStateQueues[SQ_CON_PLAY].GetHead();
                fCheckedPast = TRUE;
            }
        }
        LeaveCriticalSection(&m_SegmentCrSec);
    }

    if( FAILED(hr) && (dwOverrideFlags & DMUS_TRACKCONFIG_OVERRIDE_PRIMARY))
    {
        // The calling track wants the controlling param to come from the segment
        // itself if there was no controlling segment.
        mtSegTime = mtTime;
        if( S_OK == pSegSource->ConvertToSegTime( &mtSegTime, &mtOffset, &dwRepeat ) )
        {
            hr = pSegSource->GetParam( this, rguidType, dwGroupBits, dwIndex,
                    mtSegTime, pmtNext, pData );
            if( SUCCEEDED(hr) )
            {
                dwRepeatsLeft = pSegSource->m_dwRepeats;
                mtLoopEnd = pSegSource->m_mtLoopEnd;
                mtSegEnd = pSegSource->m_mtLength;
                dwRepeatsLeft -= dwRepeat;
            }
        }
    }

    if( FAILED(hr) ) // didn't find one in the previous, so check for a primary segment
    {
        IDirectMusicSegment* pSegment = NULL;
        mtSegTime = mtTime;
        EnterCriticalSection(&m_SegmentCrSec);
        pSegNode = GetPrimarySegmentAtTime( mtTime );
        if( pSegNode )
        {
            pSegment = pSegNode->m_pSegment;
            pSegment->AddRef();
            pSegNode->ConvertToSegTime( &mtSegTime, &mtOffset, &dwRepeat );
            dwRepeatsLeft = pSegNode->m_dwRepeats;
            mtLoopEnd = pSegNode->m_mtLoopEnd;
            mtSegEnd = pSegNode->m_mtLength;
            dwRepeatsLeft -= dwRepeat;
        }
        else
        {
            Trace(4, "Couldn't find SegState in GetParam call.\n");
        }
        LeaveCriticalSection(&m_SegmentCrSec);
        if( pSegment )
        {
            hr = pSegNode->GetParam( this, rguidType, dwGroupBits, dwIndex,
                    mtSegTime, pmtNext, pData );
            pSegment->Release();
        }
    }

    if( FAILED(hr) && (dwOverrideFlags & DMUS_TRACKCONFIG_FALLBACK))
    {
        // The calling track wants the controlling param to come from the segment itself
        mtSegTime = mtTime;
        if( S_OK == pSegSource->ConvertToSegTime( &mtSegTime, &mtOffset, &dwRepeat ) )
        {
            hr = pSegSource->GetParam( this, rguidType, dwGroupBits, dwIndex,
                    mtSegTime, pmtNext, pData );
            if( SUCCEEDED(hr) )
            {
                dwRepeatsLeft = pSegSource->m_dwRepeats;
                mtLoopEnd = pSegSource->m_mtLoopEnd;
                mtSegEnd = pSegSource->m_mtLength;
                dwRepeatsLeft -= dwRepeat;
            }
        }
    }

    if( FAILED(hr) )
    {   // If we failed, fill in the end time of loop or segment anyway.
        if (pmtNext)
        {   // Check to see if the loop end is earlier than end of segment.
            if (dwRepeatsLeft && (mtLoopEnd > mtSegTime))
            {
                *pmtNext = mtLoopEnd - mtSegTime;
            }
            else // Or, mark end of segment.
            {
                *pmtNext = mtSegEnd - mtSegTime;
            }
        }
        // if we're looking for timesig, and didn't find it anywhere,
        // return the Performance timesig
        if( rguidType == GUID_TimeSignature )
        {
            if( NULL == pData )
            {
                Trace(1,"Error: Null pointer for time signature passed to GetParam().\n");
                hr = E_POINTER;
            }
            else
            {
                DMUS_TIMESIGNATURE* pTSigData = (DMUS_TIMESIGNATURE*)pData;
                DMUS_TIMESIG_PMSG timeSig;

                GetTimeSig( mtTime, &timeSig );
                pTSigData->bBeatsPerMeasure = timeSig.bBeatsPerMeasure;
                pTSigData->bBeat = timeSig.bBeat;
                pTSigData->wGridsPerBeat = timeSig.wGridsPerBeat;
                pTSigData->mtTime = timeSig.mtTime - mtTime;
                hr = S_OK;
            }
        }
        // Likewise, if there was no tempo in a segment, we need to read directly from the tempo list.
        else if  ( rguidType == GUID_TempoParam || rguidType == GUID_PrivateTempoParam)
        {
            if( NULL == pData )
            {
                Trace(1,"Error: Null pointer for tempo passed to GetParam().\n");
                hr = E_POINTER;
            }
            else
            {
                DMInternalTempo* pInternalTempo;
                EnterCriticalSection( &m_PipelineCrSec );
                pInternalTempo = (DMInternalTempo*)m_TempoMap.GetHead();
                DMInternalTempo* pNextTempo = NULL;
                for ( ;pInternalTempo;pInternalTempo = pNextTempo )
                {
                    pNextTempo = (DMInternalTempo *) pInternalTempo->pNext;
                    if (pNextTempo && (pNextTempo->tempoPMsg.mtTime <= mtTime))
                    {
                        continue;
                    }
                    if (rguidType == GUID_TempoParam)
                    {
                        DMUS_TEMPO_PARAM* pTempoData = (DMUS_TEMPO_PARAM*)pData;
                        pTempoData->mtTime = pInternalTempo->tempoPMsg.mtTime - mtTime;
                        pTempoData->dblTempo = pInternalTempo->tempoPMsg.dblTempo;
                    }
                    else // rguidType == GUID_PrivateTempoParam
                    {
                        PrivateTempo* pTempoData = (PrivateTempo*)pData;
                        pTempoData->mtTime = pInternalTempo->tempoPMsg.mtTime - mtTime;
                        pTempoData->dblTempo = pInternalTempo->tempoPMsg.dblTempo;
                    }
                    if( pmtNext )
                    {
                        *pmtNext = 0;
                    }
                    break;
                }
                LeaveCriticalSection( &m_PipelineCrSec );
                if (pInternalTempo)
                {
                    hr = S_FALSE;
                }
            }
        }
    }
    else // GetParam from a segment succeeded, so we need to clean up the next time parameter to account
         // for loops and end of segment.
    {
        if (pmtNext) // Check to see if the loop end is earlier than *pmtNext.
        {
            if (dwRepeatsLeft && (*pmtNext > (mtLoopEnd - mtSegTime)))
            {
                if (mtLoopEnd >= mtSegTime) // This should always be true, but test anyway.
                {
                    *pmtNext = mtLoopEnd - mtSegTime;
                }
            }
        }
    }
    EnterCriticalSection(&m_MainCrSec);
    if (m_pParamHook && SUCCEEDED(hr))
    {
        hr = m_pParamHook->GetParam(rguidType,dwGroupBits,dwIndex,mtTime,pmtNext,pData,
            pSegSource,m_dwGetParamFlags,hr);

    }
    LeaveCriticalSection(&m_MainCrSec);
    return hr;
}



/*
  @method HRESULT | IDirectMusicPerformance | SetParam |
  Sets data on a Track inside a Primary Segment in this Performance.

  @rvalue S_OK | Success.
  @rvalue DMUS_E_NO_MASTER_CLOCK | There is no master clock in the performance.
  Make sure to call <om .Init> before calling this method.
*/
HRESULT STDMETHODCALLTYPE CPerformance::SetParam(
    REFGUID rguidType,      // @parm The type of data to set.
    DWORD dwGroupBits,      // @parm The group the desired track is in. Use 0xffffffff
                            // for all groups.
    DWORD dwIndex,          // @parm Identifies which track, by index, in the group
                            // identified by <p dwGroupBits> to set the data.
    MUSIC_TIME mtTime,      // @parm The time at which to set the data. Unlike
                            // <om IDirectMusicSegment.SetParam>, this time is in
                            // performance time. The start time of the segment is
                            // subtracted from this time, and <om IDirectMusicSegment.SetParam>
                            // is called.
    void* pData)            // @parm The struture containing the data to set. Each
                            // <p pGuidType> identifies a particular structure of a
                            // particular size. It is important that this field contain
                            // the correct structure of the correct size. Otherwise,
                            // fatal results can occur.
{
    V_INAME(IDirectMusicPerformance::SetParam);
    V_PTR_WRITE_OPT(pData,1);
    V_REFGUID(rguidType);

    EnterCriticalSection(&m_MainCrSec);
    if( m_pClock == NULL )
    {
        LeaveCriticalSection(&m_MainCrSec);
        Trace(1,"Error: SetParam() failed because the performance has not been initialized.\n");
        return DMUS_E_NO_MASTER_CLOCK;
    }
    LeaveCriticalSection(&m_MainCrSec);

    CSegState* pSegNode;
    IDirectMusicSegment* pSegment = NULL;
    HRESULT hr;

    EnterCriticalSection(&m_SegmentCrSec);
    pSegNode = GetPrimarySegmentAtTime( mtTime );

    MUSIC_TIME mtOffset;
    DWORD dwRepeat;
    if( pSegNode )
    {
        pSegment = pSegNode->m_pSegment;
        pSegment->AddRef();
        pSegNode->ConvertToSegTime( &mtTime, &mtOffset, &dwRepeat );
    }
    LeaveCriticalSection(&m_SegmentCrSec);
    if( pSegment )
    {
        hr = pSegment->SetParam( rguidType, dwGroupBits, dwIndex,
                mtTime, pData );
        pSegment->Release();
    }
    else
    {
        Trace(1,"Error: SetParam failed because there is no segment at requested time.\n");
        hr = DMUS_E_NOT_FOUND;
    }
    return hr;
}

/*
  @method HRESULT | IDirectMusicPerformance | GetGlobalParam |
  Gets global values from the Performance.

  @rvalue S_OK | Success.
  @rvalue E_INVALIDARG | <p pGuidType> isn't in the list of global data being handled by this
  Performance. Make sure to call <om IDirectMusicPerformance.SetGlobalParam> first.  Or,
  the value of <p pData> doesn't point to valid memory. Or, <p dwSize> isn't the size
  originally given in <om .SetGlobalParam>
  @rvalue E_POINTER | <p pData> is NULL or invalid.

  @xref <om .SetGlobalParam>
*/
HRESULT STDMETHODCALLTYPE CPerformance::GetGlobalParam(
    REFGUID rguidType,  // @parm Identifies the type of data.
    void* pData,        // @parm Allocated memory to receive a copy of the data. This must be
                        // the correct size, which is constant for each <p pGuidType> type of
                        // data, and was also passed in to <om .SetGlobalParam>.
    DWORD dwSize        // @parm The size of the data in <p pData>. This should be constant for each
                        // <p pGuidType>. This parameter is needed because the Performance doesn't
                        // know about all types of data, allowing new ones to be created as needed.
    )
{
    V_INAME(IDirectMusicPerformance::GetGlobalParam);
    V_REFGUID(rguidType);

    if( dwSize )
    {
        V_BUFPTR_WRITE( pData, dwSize );
    }

    GlobalData* pGD;
    HRESULT hr = S_OK;
    EnterCriticalSection(&m_GlobalDataCrSec);
    for( pGD = m_pGlobalData; pGD; pGD = pGD->pNext )
    {
        if( pGD->guidType == rguidType )
        {
            break;
        }
    }
    if( pGD && ( dwSize == pGD->dwSize ) )
    {
        memcpy( pData, pGD->pData, pGD->dwSize );
    }
    else
    {
#ifdef DBG
        if (pGD && ( dwSize != pGD->dwSize ))
        {
            Trace(1,"Error: GetGlobalParam() failed because the passed data size %ld was inconsistent with %ld, set previously.\n",
                dwSize, pGD->dwSize);
        }
        else
        {
            Trace(4,"Warning: GetGlobalParam() failed because the parameter had never been set.\n");
        }
#endif
        hr = E_INVALIDARG;
    }
    LeaveCriticalSection(&m_GlobalDataCrSec);
    return hr;
}

/*
  @method HRESULT | IDirectMusicPerformance | SetGlobalParam |
  Set global values on the Performance.

  @rvalue S_OK | Success.
  @rvalue E_POINTER | <p pData> is NULL or invalid.
  @rvalue E_OUTOFMEMORY | Ran out of memory.
  @rvalue E_INVALIDARG | Other failure. pData or dwSize not correct?

  @xref <om .GetGlobalParam>
*/
HRESULT STDMETHODCALLTYPE CPerformance::SetGlobalParam(
    REFGUID rguidType,  // @parm Identifies the type of data.
    void* pData,        // @parm The data itself, which will be copied and stored by the Performance.
    DWORD dwSize        // @parm The size of the data in <p pData>. This should be constant for each
                        // <p pGuidType>. This parameter is needed because the Performance doesn't
                        // know about all types of data, allowing new ones to be created as needed.
    )
{
    V_INAME(IDirectMusicPerformance::SetGlobalParam);
    V_REFGUID(rguidType);

    if( dwSize )
    {
        V_BUFPTR_READ( pData, dwSize );
    }

    GlobalData* pGD;
    // see if this is one of our special Performance globals
    if( rguidType == GUID_PerfMasterTempo )
    {
        if( dwSize == sizeof(float) )
        {
            float flt;
            memcpy( &flt, pData, sizeof(float) );
            if( (flt >= DMUS_MASTERTEMPO_MIN) && (flt <= DMUS_MASTERTEMPO_MAX) )
            {
                if( m_fltRelTempo != flt )
                {
                    m_fltRelTempo = flt;
                    // It's only necessary to recalc the tempo map if something is playing
                    EnterCriticalSection(&m_SegmentCrSec);
                    if (GetPrimarySegmentAtTime(m_mtTransported))
                    {
                        RecalcTempoMap(NULL,m_mtTransported);
                    }
                    LeaveCriticalSection(&m_SegmentCrSec);
                }
            }
        }
        else
        {
            Trace(1,"Error: Attempt to set global tempo failed because dwSize is not size of float.\n");
            return E_INVALIDARG;
        }
    }
    else if( rguidType == GUID_PerfMasterVolume )
    {
        // master volume
        if( dwSize == sizeof(long) )
        {
            memcpy( &m_lMasterVolume, pData, sizeof(long) );
        }
        else
        {
            Trace(1,"Error: Attempt to set global volume failed because dwSize is not size of long.\n");
            return E_INVALIDARG;
        }
        // Go through all Ports and set the master volume.
        // This is also done upon adding a Port.
        IDirectMusicPort* pPort;
        DWORD dw;

        EnterCriticalSection(&m_PChannelInfoCrSec);
        for( dw = 0; dw < m_dwNumPorts; dw++ )
        {
            pPort = m_pPortTable[dw].pPort;
            if( pPort )
            {
                IKsControl *pControl;
                if(SUCCEEDED(pPort->QueryInterface(IID_IKsControl, (void**)&pControl)))
                {
                    KSPROPERTY ksp;
                    ULONG cb;

                    memset(&ksp, 0, sizeof(ksp));
                    ksp.Set   = GUID_DMUS_PROP_Volume;
                    ksp.Id    = 0;
                    ksp.Flags = KSPROPERTY_TYPE_SET;

                    pControl->KsProperty(&ksp,
                                         sizeof(ksp),
                                         (LPVOID)&m_lMasterVolume,
                                         sizeof(m_lMasterVolume),
                                         &cb);
                    pControl->Release();
                }
            }
        }
        LeaveCriticalSection(&m_PChannelInfoCrSec);
    }

    // see if this type is already there. If so, use it.
    EnterCriticalSection(&m_GlobalDataCrSec);
    for( pGD = m_pGlobalData; pGD; pGD = pGD->pNext )
    {
        if( pGD->guidType == rguidType )
        {
            break;
        }
    }
    LeaveCriticalSection(&m_GlobalDataCrSec);
    // if it already exists, just copy the new data into the
    // existing memory block and return
    if( pGD )
    {
        if( pGD->dwSize != dwSize )
        {
            Trace(1,"Error: Attempt to set global parameter failed because dwSize is not consistent with previous SetGlobalParam() call.\n");
            return E_INVALIDARG;
        }
        if( dwSize )
        {
            memcpy( pGD->pData, pData, dwSize );
        }
        return S_OK;
    }

    // otherwise, create new memory
    pGD = new GlobalData;
    if( NULL == pGD )
    {
        return E_OUTOFMEMORY;
    }
    pGD->dwSize = dwSize;
    if( dwSize )
    {
        pGD->pData = (void*)(new char[dwSize]);
        if( NULL == pGD->pData )
        {
            delete pGD;
            return E_OUTOFMEMORY;
        }
        memcpy( pGD->pData, pData, dwSize );
    }
    else
    {
        pGD->pData = NULL;
    }
    pGD->guidType = rguidType;
    EnterCriticalSection(&m_GlobalDataCrSec); // just using this one since it's available and not used much
    pGD->pNext = m_pGlobalData;
    m_pGlobalData = pGD;
    LeaveCriticalSection(&m_GlobalDataCrSec);
    return S_OK;
}

// IDirectMusicTool
/*
  @method HRESULT | IDirectMusicTool | Init |
  Called when the Tool is inserted into the Graph, providing the Tool the opportunity
  to initialize itself.

  @rvalue S_OK | Success.
  @rvalue E_NOTIMPL | Not implemented is a valid return for the method.
*/
HRESULT STDMETHODCALLTYPE CPerformance::Init(
         IDirectMusicGraph* pGraph  // @parm The calling graph.
    )
{
    return E_NOTIMPL;
}

inline bool CPerformance::SendShortMsg( IDirectMusicBuffer* pBuffer,
                                   IDirectMusicPort* pPort,DWORD dwMsg,
                                   REFERENCE_TIME rt, DWORD dwGroup)

{
    if( FAILED( pBuffer->PackStructured( rt, dwGroup, dwMsg ) ) )
    {
        // ran out of room in the buffer
        TraceI(2, "RAN OUT OF ROOM IN THE BUFFER!\n");
        pPort->PlayBuffer( pBuffer );
        pBuffer->Flush();
        // try one more time
        if( FAILED( pBuffer->PackStructured( rt, dwGroup, dwMsg ) ) )
        {
            TraceI(1, "MAJOR BUFFER PACKING FAILURE!\n");
            // if it didn't work this time, free the event because something
            // bad has happened.
            return false;
        }
    }
    return true;
}

//////////////////////////////////////////////////////////////////////
// CPerformance::PackNote
/*
  HRESULT | CPerformance | PackNote |
  Converts the message into a midiShortMsg, midiLongMsg, or user message
  and packs it into the appropriate IDirectMusicBuffer in the PortTable,
  setting the m_fBufferFilled flag.

  DMUS_PMSG* | pPMsg |
  [in] The message to pack into the buffer.

  REFERENCE_TIME | mt |
  [in] The time (in the Buffer's clock coordinates) at which to queue the message.

  E_INVALIDARG | Either pPMsg or pBuffer is NULL.
  E_OUTOFMEMORY | Failed to pack the buffer.
  DMUS_S_REQUEUE | Tells the Pipeline to requeue this message.
  DMUS_S_FREE | Tells the Pipeline to free this message.
*/
HRESULT CPerformance::PackNote(
            DMUS_PMSG* pEvent,
            REFERENCE_TIME rt )
{
    DMUS_NOTE_PMSG* pNote = (DMUS_NOTE_PMSG*)pEvent;
    PRIV_PMSG* pPriv = DMUS_TO_PRIV(pEvent);
    REFERENCE_TIME rtLogical; // the time the note occurs in logical music time (subtract offset)
    IDirectMusicBuffer* pBuffer = NULL;
    IDirectMusicPort* pPort = NULL;
    DWORD dwMsg;
    DWORD dwGroup, dwMChannel, dwPortTableIndex;
    short nTranspose = 0;
    short nValue;
    HRESULT hr = DMUS_S_FREE;

    if( NULL == pEvent )
        return E_INVALIDARG;

    if( FAILED( PChannelIndex( pNote->dwPChannel, &dwPortTableIndex, &dwGroup, &dwMChannel,
        &nTranspose )))
    {
        Trace(1,"Play note failed on unassigned PChannel %ld\n",pNote->dwPChannel);
        return DMUS_S_FREE; // the PChannel map wasn't found. Just free the event.
    }
    EnterCriticalSection(&m_PChannelInfoCrSec);
    if( dwPortTableIndex > m_dwNumPorts )
    {
        pPort = NULL; // the PChannel map is out of range of the number of ports
                    // so return outta here! (see after the LeaveCriticalSection)
    }
    else
    {
        pPort = m_pPortTable[dwPortTableIndex].pPort;
        if( pPort ) pPort->AddRef();
        pBuffer = m_pPortTable[dwPortTableIndex].pBuffer;
        if( pBuffer ) pBuffer->AddRef();
    }
    LeaveCriticalSection(&m_PChannelInfoCrSec);
    if(pPort && pBuffer )
    {
        dwMsg = 0;
        if( pNote->bFlags & DMUS_NOTEF_NOTEON )
        {
            // transpose the note's bMidiValue, and store it in the note so the note off
            // plays the correct pitch.
            nValue = pNote->bMidiValue + nTranspose;
            if( ( nValue > 127 ) || ( nValue < 0 )
                || pNote->mtDuration <= 0 )
            {
                // don't play this out-of-range or 0-duration note
                pPort->Release();
                pBuffer->Release();
                return DMUS_S_FREE;
            }
            pNote->bMidiValue = (BYTE)nValue;
            dwMsg |= pNote->bVelocity << 16;
        }
        else if( rt < pPriv->rtLast )
        {
            // the note off will play before the note on. Bad.
            rt = pPriv->rtLast + REF_PER_MIL;
        }
        dwMsg |= pNote->bMidiValue << 8; // set note value
        dwMsg |= dwMChannel; // MIDI Channel
        if( pNote->bFlags & DMUS_NOTEF_NOTEON )
        {
            dwMsg |= MIDI_NOTEON;
        }
        else
        {
            dwMsg |= MIDI_NOTEOFF;
        }

        if (SendShortMsg(pBuffer,pPort,dwMsg,rt-2,dwGroup))
        {
            EnterCriticalSection(&m_PipelineCrSec); // to prevent deadlock in MusicToReferenceTime
            EnterCriticalSection(&m_PChannelInfoCrSec);
            m_pPortTable[dwPortTableIndex].fBufferFilled = TRUE; // so we send this in SendBuffers
            rtLogical = rt;
            // subtract the offset if needed, but only for a note on.
            if( pNote->nOffset && (pNote->bFlags & DMUS_NOTEF_NOTEON))
            {
                MUSIC_TIME mtTemp = pNote->mtTime - pNote->nOffset + 1;
                REFERENCE_TIME rtTemp;
                MusicToReferenceTime( mtTemp, &rtTemp );
                if( rtTemp > rtLogical )
                {
                    rtLogical = rtTemp;
                }
            }
            if( m_pPortTable[dwPortTableIndex].rtLast < rtLogical )
            {
                m_pPortTable[dwPortTableIndex].rtLast = rtLogical;
            }
            LeaveCriticalSection(&m_PChannelInfoCrSec);
            LeaveCriticalSection(&m_PipelineCrSec);

            if( pNote->bFlags & DMUS_NOTEF_NOTEON )
            {
                pPriv->rtLast = rt;
                m_rtHighestPackedNoteOn = rt;
                if (pNote->dwFlags & DMUS_PMSGF_LOCKTOREFTIME)
                {
                    // This is a clock time message.
                    rt = pNote->rtTime;
                    pNote->rtTime += (pNote->mtDuration * REF_PER_MIL);
                    if (pNote->mtDuration > 1)
                    {
                        pNote->rtTime -= REF_PER_MIL;
                    }
                    // subtract 1 to guarantee that a note off at the same time as a note on doesn't
                    // stop the note on short. It's possible that rt == pNote->rtTime, if the duration
                    // was zero, so be sure to check that.
                    if( pNote->rtTime < rt + 1 )
                    {
                        pNote->rtTime = rt + 1;
                    }
                    pNote->bFlags &= ~DMUS_NOTEF_NOTEON; // make this a note off now
                    pNote->dwFlags &= ~DMUS_PMSGF_MUSICTIME;
                    hr = DMUS_S_REQUEUE;
                }
                else
                {
                    pNote->mtTime += pNote->mtDuration;
                    if (pNote->mtDuration > 1)
                    {
                        pNote->mtTime--;
                    }
                    MusicToReferenceTime( pNote->mtTime, &rt );
                    // subtract 1 to guarantee that a note off at the same time as a note on doesn't
                    // stop the note on short. It's possible that rt == pNote->rtTime, if the duration
                    // was zero, so be sure to check that.
                    if( rt < pNote->rtTime + 2 )
                    {
                        rt = pNote->rtTime + 2;
                    }
                    pNote->rtTime = rt - 1;
                }
                pNote->bFlags &= ~DMUS_NOTEF_NOTEON; // make this a note off now
                hr = DMUS_S_REQUEUE;
            }
        }
    }
    if( pPort ) pPort->Release();
    if( pBuffer ) pBuffer->Release();
    return hr;
}

//////////////////////////////////////////////////////////////////////
// CPerformance::PackCurve
HRESULT CPerformance::PackCurve(
            DMUS_PMSG* pEvent,
            REFERENCE_TIME rt )
{
    DMUS_CURVE_PMSG* pCurve = (DMUS_CURVE_PMSG*)pEvent;
    IDirectMusicBuffer* pBuffer = NULL;
    IDirectMusicPort* pPort = NULL;
    DWORD dwMsg;
    HRESULT hr = DMUS_S_FREE;
    BOOL fCalcStartValue = FALSE;
    CChannelMap *pChannelMap = NULL;

    if( NULL == pEvent )
        return E_INVALIDARG;

    // store the original start time so we know how far into the curve we are
    if( pCurve->mtOriginalStart == 0 )
    {
        // if we're flushing and have never played this curve at all, just free
        // it.
        if( pCurve->dwFlags & DMUS_PMSGF_TOOL_FLUSH )
        {
            return DMUS_S_FREE;
        }
        if (pCurve->dwFlags & DMUS_PMSGF_LOCKTOREFTIME)
        {
            // This is a clock time message. Convert the duration into music time. It will act as
            // a music time message from now on. This does have the downside that if a dramatic tempo
            // change occurs in the middle of a lengthy curve, the end time can be distorted.
            // But, given the purpose of curves, this is really an unlikely issue.
            MUSIC_TIME mtTemp;
            ReferenceToMusicTime(pCurve->rtTime + (pCurve->mtDuration * REF_PER_MIL),&mtTemp);
            mtTemp -= pCurve->mtTime;
            pCurve->mtDuration = mtTemp;
            ReferenceToMusicTime(pCurve->rtTime + (pCurve->mtResetDuration * REF_PER_MIL),&mtTemp);
            mtTemp -= pCurve->mtTime;
            pCurve->mtResetDuration = mtTemp;
            pCurve->dwFlags &= ~DMUS_PMSGF_LOCKTOREFTIME;
        }
        pCurve->mtOriginalStart = pCurve->mtTime;
        // check the latency clock. Adjust pCurve->mtTime if needed. This can happen
        // if the curve is time-stamped for the past. We only need do this for non-instant
        // curve types.
        if( pCurve->bCurveShape != DMUS_CURVES_INSTANT )
        {
            REFERENCE_TIME rtLatency = GetLatency();
            MUSIC_TIME mtLatency;
            ReferenceToMusicTime( rtLatency, &mtLatency );
            if( pCurve->mtTime < mtLatency )
            {
                if( pCurve->mtTime + pCurve->mtDuration < mtLatency )
                {
                    // If it is far enough in the past,
                    // we only need to send out the final value.
                    pCurve->mtTime += pCurve->mtDuration;
                }
                else
                {
                    pCurve->mtTime = mtLatency;
                }
            }
            // If this is the start of a curve and we are supposed to start with the current playing value...
            if (pCurve->bFlags & DMUS_CURVE_START_FROM_CURRENT)
            {
                fCalcStartValue = TRUE;
            }
            else
            {
                pCurve->wMeasure = (WORD) ComputeCurveTimeSlice(pCurve);    // Use this to store the time slice interval.
            }
        }
    }
    // it is necessary to check reset duration >= 0 because it could have been set
    // to be negative by the flushing, and we don't want to toss it in that case.
    // (should no longer be necessary to check, as a result of fixing 33987)
    if( ( pCurve->bFlags & DMUS_CURVE_RESET ) && (pCurve->mtResetDuration >= 0) && ( pCurve->mtTime ==
        pCurve->mtDuration + pCurve->mtResetDuration + pCurve->mtOriginalStart ))
    {
        if( !( pCurve->dwFlags & DMUS_PMSGF_TOOL_FLUSH ) )
        {
            PRIV_PMSG* pPrivPMsg = DMUS_TO_PRIV(pEvent);
            if ( (pPrivPMsg->dwPrivFlags & PRIV_FLAG_FLUSH) )
            {
                pPrivPMsg->dwPrivFlags &= ~PRIV_FLAG_FLUSH;
                pCurve->dwFlags |= DMUS_PMSGF_TOOL_FLUSH;
                MUSIC_TIME mt = 0;
                if( rt <= pPrivPMsg->rtLast )
                {
                    return PackCurve( pEvent, pPrivPMsg->rtLast + REF_PER_MIL );
                }
                else
                {
                    return PackCurve( pEvent, rt );
                }
            }
            else
            {
                // the reset duration has expired, and we're not flushing, so expire the event.
                return DMUS_S_FREE;
            }
        }
    }
    EnterCriticalSection(&m_PChannelInfoCrSec);
    pChannelMap = GetPChannelMap(pCurve->dwPChannel);
    if (!pChannelMap)
    {
        Trace(1,"Play curve failed on unassigned PChannel %ld\n",pCurve->dwPChannel);
        LeaveCriticalSection(&m_PChannelInfoCrSec);
        return DMUS_S_FREE; // the PChannel map wasn't found. Just free the event.
    }
    if( pChannelMap->dwPortIndex > m_dwNumPorts )
    {
        pPort = NULL; // the PChannel map is out of range of the number of ports
                    // so return outta here! (see after the LeaveCriticalSection)
    }
    else
    {
        pPort = m_pPortTable[pChannelMap->dwPortIndex].pPort;
        if( pPort ) pPort->AddRef();
        pBuffer = m_pPortTable[pChannelMap->dwPortIndex].pBuffer;
        if( pBuffer ) pBuffer->AddRef();
    }
    if( pPort && pBuffer)
    {
        DWORD dwCurve;
        DWORD dwMergeIndex = 0;
        dwMsg = 0;
        if (pCurve->dwFlags & DMUS_PMSGF_DX8)
        {
            dwMergeIndex = pCurve->wMergeIndex;
        }
        switch( pCurve->bType )
        {
        case DMUS_CURVET_PBCURVE:
            if (fCalcStartValue)
            {
                pCurve->nStartValue =
                    (short) pChannelMap->m_PitchbendMerger.GetIndexedValue(dwMergeIndex) + 0x2000;
            }
            dwCurve = ComputeCurve( pCurve );
            dwCurve = pChannelMap->m_PitchbendMerger.MergeValue(dwMergeIndex,(long)dwCurve,0x2000,0x3FFF);
            dwMsg = MIDI_PBEND;
            dwMsg |= ( (dwCurve & 0x7F) << 8);
            dwCurve = dwCurve >> 7;
            dwMsg |= ( (dwCurve & 0x7F) << 16);
            break;
        case DMUS_CURVET_CCCURVE:
            switch (pCurve->bCCData)
            {
            case MIDI_CC_MOD_WHEEL:
                if (fCalcStartValue)
                {
                    pCurve->nStartValue =
                        (short) pChannelMap->m_ModWheelMerger.GetIndexedValue(dwMergeIndex) + 0x7F;
                }
                dwCurve = ComputeCurve( pCurve );
                dwCurve = pChannelMap->m_ModWheelMerger.MergeValue(dwMergeIndex,(long)dwCurve,0x7F,0x7F);
                break;
            case MIDI_CC_VOLUME:
                if (fCalcStartValue)
                {
                    pCurve->nStartValue =
                        (short) pChannelMap->m_VolumeMerger.GetVolumeStart(dwMergeIndex);
                }
                dwCurve = ComputeCurve( pCurve );
                dwCurve = pChannelMap->m_VolumeMerger.MergeMidiVolume(dwMergeIndex,(BYTE) dwCurve);
                break;
            case MIDI_CC_PAN:
                if (fCalcStartValue)
                {
                    pCurve->nStartValue =
                        (short) pChannelMap->m_PanMerger.GetIndexedValue(dwMergeIndex) + 0x40;
                }
                dwCurve = ComputeCurve( pCurve );
                dwCurve = pChannelMap->m_PanMerger.MergeValue(dwMergeIndex,(long)dwCurve,0x40,0x7F);
                break;
            case MIDI_CC_EXPRESSION:
                if (fCalcStartValue)
                {
                    pCurve->nStartValue =
                        (short) pChannelMap->m_ExpressionMerger.GetVolumeStart(dwMergeIndex);
                }
                dwCurve = ComputeCurve( pCurve );
                dwCurve = pChannelMap->m_ExpressionMerger.MergeMidiVolume(dwMergeIndex,(BYTE) dwCurve);
                break;
            case MIDI_CC_FILTER:
                if (fCalcStartValue)
                {
                    pCurve->nStartValue =
                        (short) pChannelMap->m_FilterMerger.GetIndexedValue(dwMergeIndex) + 0x40;
                }
                dwCurve = ComputeCurve( pCurve );
                dwCurve = pChannelMap->m_FilterMerger.MergeValue(dwMergeIndex,(long)dwCurve,0x40,0x7F);
                break;
            case MIDI_CC_REVERB:
                if (fCalcStartValue)
                {
                    pCurve->nStartValue =
                        (short) pChannelMap->m_ReverbMerger.GetIndexedValue(dwMergeIndex) + 0x7F;
                }
                dwCurve = ComputeCurve( pCurve );
                dwCurve = pChannelMap->m_ReverbMerger.MergeValue(dwMergeIndex,(long)dwCurve,0x7F,0x7F);
                break;
            case MIDI_CC_CHORUS:
                if (fCalcStartValue)
                {
                    pCurve->nStartValue =
                        (short) pChannelMap->m_ChorusMerger.GetIndexedValue(dwMergeIndex) + 0x7F;
                }
                dwCurve = ComputeCurve( pCurve );
                dwCurve = pChannelMap->m_ChorusMerger.MergeValue(dwMergeIndex,(long)dwCurve,0x7F,0x7F);
                break;
            case MIDI_CC_RESETALL:
                dwCurve = ComputeCurve( pCurve );
                pChannelMap->Reset(pCurve->nEndValue);
                break;
            default:
                dwCurve = ComputeCurve( pCurve );
                break;
            }
            dwMsg = MIDI_CCHANGE;
            dwMsg |= (pCurve->bCCData << 8);
            dwMsg |= (dwCurve << 16);
            break;
        case DMUS_CURVET_MATCURVE:
            dwCurve = ComputeCurve( pCurve );
            dwMsg = MIDI_MTOUCH;
            dwMsg |= (dwCurve << 8);
            break;
        case DMUS_CURVET_PATCURVE:
            dwCurve = ComputeCurve( pCurve );
            dwMsg = MIDI_PTOUCH;
            dwMsg |= (pCurve->bCCData << 8);
            dwMsg |= (dwCurve << 16);
            break;
        case DMUS_CURVET_RPNCURVE:
        case DMUS_CURVET_NRPNCURVE:
            if (pCurve->dwFlags & DMUS_PMSGF_DX8)
            {
                dwCurve = ComputeCurve( pCurve );
                DWORD dwMsg2 = MIDI_CCHANGE;
                dwMsg = MIDI_CCHANGE;
                // First, send the two CC commands to select which RPN or NRPN event.
                if (pCurve->bType == DMUS_CURVET_RPNCURVE)
                {
                    dwMsg |= (MIDI_CC_RPN_MSB << 8);
                    dwMsg2 |= (MIDI_CC_RPN_LSB << 8);
                }
                else
                {
                    dwMsg |= (MIDI_CC_NRPN_MSB << 8);
                    dwMsg2 |= (MIDI_CC_NRPN_LSB << 8);
                }
                dwMsg |= (pCurve->wParamType  & 0x3F80) << 9;  // Upper 8 bits of command #
                dwMsg2 |= (pCurve->wParamType & 0x7F) << 16;   // Lower 8 bits.
                dwMsg |= pChannelMap->dwMChannel; // MIDI Channel
                dwMsg2 |= pChannelMap->dwMChannel; // MIDI Channel
                SendShortMsg(pBuffer,pPort,dwMsg,rt-3,pChannelMap->dwGroup); // Too bad if it fails!
                SendShortMsg(pBuffer,pPort,dwMsg2,rt-2,pChannelMap->dwGroup);
                // Then, send the two data CC commands.
                dwMsg = MIDI_CCHANGE | (MIDI_CC_DATAENTRYMSB << 8);
                dwMsg |= (dwCurve & 0x3F80) << 9;  // Upper 8 bits of data
                dwMsg |= pChannelMap->dwMChannel; // MIDI Channel
                SendShortMsg(pBuffer,pPort,dwMsg,rt-1,pChannelMap->dwGroup);
                dwMsg = MIDI_CCHANGE | (MIDI_CC_DATAENTRYLSB << 8);
                dwMsg |= (dwCurve & 0x7F) << 16;  // Lower 8 bits of data
            }
        }
        if (dwMsg) // Make sure we successfully created a message.
        {
            dwMsg |= pChannelMap->dwMChannel; // MIDI Channel
            if (SendShortMsg(pBuffer,pPort,dwMsg,rt,pChannelMap->dwGroup))
            {
                m_pPortTable[pChannelMap->dwPortIndex].fBufferFilled = TRUE; // so we send this in SendBuffers
                m_pPortTable[pChannelMap->dwPortIndex].rtLast = rt;

                // ComputeCurve() will set this to 0 if it's time to free the event. Otherwise, it
                // will set it to the next time this event should be performed.
                if( pCurve->rtTime )
                {
                    // If we didn't calculate the time slice because we didn't know
                    // what the start value was, do it now.
                    if (fCalcStartValue)
                    {
                        pCurve->wMeasure = (WORD) ComputeCurveTimeSlice(pCurve);    // Use this to store the time slice interval.
                    }
                    hr = DMUS_S_REQUEUE;
                }
            }
        }
    }
    LeaveCriticalSection(&m_PChannelInfoCrSec);
    if( pPort ) pPort->Release();
    if( pBuffer ) pBuffer->Release();
    return hr;
}

//////////////////////////////////////////////////////////////////////
// CPerformance::PackMidi
HRESULT CPerformance::PackMidi(
            DMUS_PMSG* pEvent,
            REFERENCE_TIME rt )
{
    DMUS_MIDI_PMSG* pMidi = (DMUS_MIDI_PMSG*)pEvent;
    IDirectMusicBuffer* pBuffer = NULL;
    IDirectMusicPort* pPort = NULL;
    DWORD dwMsg;
//  DWORD dwGroup, dwMChannel, dwPortTableIndex;
    HRESULT hr = DMUS_S_FREE;
    CChannelMap *pChannelMap = NULL;

    if( NULL == pMidi )
        return E_INVALIDARG;

    EnterCriticalSection(&m_PChannelInfoCrSec);
    pChannelMap = GetPChannelMap(pMidi->dwPChannel);
    if (!pChannelMap)
    {
        Trace(1,"Play MIDI failed on unassigned PChannel %ld\n",pMidi->dwPChannel);
        LeaveCriticalSection(&m_PChannelInfoCrSec);
        return DMUS_S_FREE; // the PChannel map wasn't found. Just free the event.
    }

    if( pChannelMap->dwPortIndex > m_dwNumPorts )
    {
        pPort = NULL; // the PChannel map is out of range of the number of ports
                    // so return outta here! (see after the LeaveCriticalSection)
    }
    else
    {
        pPort = m_pPortTable[pChannelMap->dwPortIndex].pPort;
        if( pPort ) pPort->AddRef();
        pBuffer = m_pPortTable[pChannelMap->dwPortIndex].pBuffer;
        if( pBuffer ) pBuffer->AddRef();
    }
    if(pPort && pBuffer )
    {
        pMidi->bStatus &= 0xF0;
        if (pMidi->bStatus == MIDI_CCHANGE)
        {
            switch (pMidi->bByte1)
            {
            case MIDI_CC_MOD_WHEEL:
                pMidi->bByte2 = (BYTE) pChannelMap->m_ModWheelMerger.MergeValue(0,pMidi->bByte2,0x7F,0x7F);
                break;
            case MIDI_CC_VOLUME:
                pMidi->bByte2 = pChannelMap->m_VolumeMerger.MergeMidiVolume(0,pMidi->bByte2);
                break;
            case MIDI_CC_PAN:
                pMidi->bByte2 = (BYTE) pChannelMap->m_PanMerger.MergeValue(0,pMidi->bByte2,0x40,0x7F);
                break;
            case MIDI_CC_EXPRESSION:
                pMidi->bByte2 = pChannelMap->m_ExpressionMerger.MergeMidiVolume(0,pMidi->bByte2);
                break;
            case MIDI_CC_FILTER:
                pMidi->bByte2 = (BYTE) pChannelMap->m_FilterMerger.MergeValue(0,pMidi->bByte2,0x40,0x7F);
                break;
            case MIDI_CC_REVERB:
                pMidi->bByte2 = (BYTE) pChannelMap->m_ReverbMerger.MergeValue(0,pMidi->bByte2,0x7F,0x7F);
                break;
            case MIDI_CC_CHORUS:
                pMidi->bByte2 = (BYTE) pChannelMap->m_ChorusMerger.MergeValue(0,pMidi->bByte2,0x7F,0x7F);
                break;
            case MIDI_CC_RESETALL:
                pChannelMap->Reset(pMidi->bByte2);
                break;
            }

        }
        else if (pMidi->bStatus == MIDI_PBEND)
        {
            WORD wBend = pMidi->bByte1 | (pMidi->bByte2 << 7);
            wBend = (WORD) pChannelMap->m_PitchbendMerger.MergeValue(0,wBend,0x2000,0x3FFF);
            pMidi->bByte1 = wBend & 0x7F;
            pMidi->bByte2 = (wBend >> 7) & 0x7F;
        }
        dwMsg = pMidi->bByte1 << 8;
        dwMsg |= pMidi->bByte2 << 16;
        dwMsg |= pMidi->bStatus;
        dwMsg |= pChannelMap->dwMChannel;
        if (SendShortMsg(pBuffer,pPort,dwMsg,rt,pChannelMap->dwGroup))
        {
            m_pPortTable[pChannelMap->dwPortIndex].fBufferFilled = TRUE; // so we send this in SendBuffers
            m_pPortTable[pChannelMap->dwPortIndex].rtLast = rt;
        }
    }
    LeaveCriticalSection(&m_PChannelInfoCrSec);
    if( pPort ) pPort->Release();
    if( pBuffer ) pBuffer->Release();
    return hr;
}

//////////////////////////////////////////////////////////////////////
// CPerformance::PackSysEx
HRESULT CPerformance::PackSysEx(
            DMUS_PMSG* pEvent,
            REFERENCE_TIME rt )
{
    DMUS_SYSEX_PMSG* pSysEx = (DMUS_SYSEX_PMSG*)pEvent;
    IDirectMusicBuffer* pBuffer = NULL;
    IDirectMusicPort* pPort = NULL;
    DWORD dwGroup, dwMChannel, dwPortTableIndex;
    HRESULT hr = DMUS_S_FREE;

    if( NULL == pEvent )
        return E_INVALIDARG;

    if( NULL == m_pDirectMusic )
        return DMUS_E_NOT_INIT;

    if( FAILED( PChannelIndex( pSysEx->dwPChannel, &dwPortTableIndex, &dwGroup, &dwMChannel)))
    {
        Trace(1,"Play SysEx failed on unassigned PChannel %ld\n",pSysEx->dwPChannel);
        return DMUS_S_FREE; // the PChannel map wasn't found. Just free the event.
    }
    EnterCriticalSection(&m_PChannelInfoCrSec);
    if( dwPortTableIndex > m_dwNumPorts )
    {
        pPort = NULL; // the PChannel map is out of range of the number of ports
                    // so return outta here! (see after the LeaveCriticalSection)
    }
    else
    {
        pPort = m_pPortTable[dwPortTableIndex].pPort;
        if( pPort ) pPort->AddRef();
    }
    LeaveCriticalSection(&m_PChannelInfoCrSec);
    if( pPort )
    {
        // create a buffer of the right size
        DMUS_BUFFERDESC dmbd;
        memset( &dmbd, 0, sizeof(DMUS_BUFFERDESC) );
        dmbd.dwSize = sizeof(DMUS_BUFFERDESC);
        dmbd.cbBuffer = pSysEx->dwLen + 48;

        EnterCriticalSection(&m_MainCrSec);
        if( SUCCEEDED( m_pDirectMusic->CreateMusicBuffer(&dmbd, &pBuffer, NULL)))
        {
            if( SUCCEEDED( pBuffer->PackUnstructured( rt - 4, dwGroup, pSysEx->dwLen, pSysEx->abData ) ) )
            {
                pPort->PlayBuffer(pBuffer);
            }
            pBuffer->Release();
        }
        LeaveCriticalSection(&m_MainCrSec);
    }
    if( pPort ) pPort->Release();
    return hr;
}

//////////////////////////////////////////////////////////////////////
// CPerformance::PackPatch
HRESULT CPerformance::PackPatch(
            DMUS_PMSG* pEvent,
            REFERENCE_TIME rt )
{
    DMUS_PATCH_PMSG* pPatch = (DMUS_PATCH_PMSG*)pEvent;
    IDirectMusicBuffer* pBuffer = NULL;
    IDirectMusicPort* pPort = NULL;
    DWORD dwGroup, dwMChannel, dwPortTableIndex;
    DWORD dwMsg;
    HRESULT hr = DMUS_S_FREE;

    if( NULL == pEvent )
        return E_INVALIDARG;

    if( FAILED( PChannelIndex( pPatch->dwPChannel, &dwPortTableIndex, &dwGroup, &dwMChannel)))
    {
        Trace(1,"Play Patch failed on unassigned PChannel %ld\n",pPatch->dwPChannel);
        return DMUS_S_FREE; // the PChannel map wasn't found. Just free the event.
    }
    EnterCriticalSection(&m_PChannelInfoCrSec);
    if( dwPortTableIndex > m_dwNumPorts )
    {
        pPort = NULL; // the PChannel map is out of range of the number of ports
                    // so return outta here! (see after the LeaveCriticalSection)
    }
    else
    {
        pPort = m_pPortTable[dwPortTableIndex].pPort;
        if( pPort ) pPort->AddRef();
        pBuffer = m_pPortTable[dwPortTableIndex].pBuffer;
        if( pBuffer ) pBuffer->AddRef();
    }
    if( pPort && pBuffer)
    {
        // subtract 10 from rt to guarantee that patch events always go out earlier than
        // notes with the same time stamp.
        rt -= 10;
        // send the bank select lsb
        dwMsg = MIDI_CCHANGE;
        dwMsg |= ( MIDI_CC_BS_LSB << 8 );
        dwMsg |= (pPatch->byLSB << 16);
        ASSERT( dwMChannel < 16 );
        dwMsg |= dwMChannel;
        SendShortMsg(pBuffer,pPort,dwMsg,rt-2,dwGroup);
        // send the bank select msb
        dwMsg = MIDI_CCHANGE;
        dwMsg |= ( MIDI_CC_BS_MSB << 8 );
        dwMsg |= (pPatch->byMSB << 16);
        dwMsg |= dwMChannel;
        SendShortMsg(pBuffer,pPort,dwMsg,rt-1,dwGroup);
        // send the program change
        dwMsg = MIDI_PCHANGE;
        dwMsg |= (pPatch->byInstrument << 8);
        dwMsg |= dwMChannel;
        if (SendShortMsg(pBuffer,pPort,dwMsg,rt,dwGroup))
        {
            m_pPortTable[dwPortTableIndex].fBufferFilled = TRUE; // so we send this in SendBuffers
            m_pPortTable[dwPortTableIndex].rtLast = rt;
        }
    }
    LeaveCriticalSection(&m_PChannelInfoCrSec);
    if( pPort ) pPort->Release();
    if( pBuffer ) pBuffer->Release();
    return hr;
}

HRESULT CPerformance::PackWave(DMUS_PMSG* pPMsg, REFERENCE_TIME rtTime)
{
    DMUS_WAVE_PMSG* pWave = (DMUS_WAVE_PMSG*)pPMsg;
    HRESULT hr = DMUS_S_FREE;

    IDirectMusicVoiceP *pVoice = (IDirectMusicVoiceP *) pWave->punkUser;
    if (pVoice)
    {
        if (pWave->bFlags & DMUS_WAVEF_OFF)
        {
            pVoice->Stop(rtTime);
            EnterCriticalSection(&m_SegmentCrSec);
            for (DWORD dwCount = 0; dwCount < SQ_COUNT; dwCount++)
            {
                for( CSegState* pSegSt = m_SegStateQueues[dwCount].GetHead(); pSegSt; pSegSt = pSegSt->GetNext() )
                {
                    CTrack* pTrack = pSegSt->m_TrackList.GetHead();
                    while( pTrack )
                    {
                        if (pTrack->m_guidClassID == CLSID_DirectMusicWaveTrack)
                        {
                            IPrivateWaveTrack* pWaveTrack = NULL;
                            if (pTrack->m_pTrack &&
                                SUCCEEDED(pTrack->m_pTrack->QueryInterface(IID_IPrivateWaveTrack, (void**)&pWaveTrack)))
                            {
                                pWaveTrack->OnVoiceEnd(pVoice, pTrack->m_pTrackState);
                                pWaveTrack->Release();
                            }
                        }
                        pTrack = pTrack->GetNext();
                    }
                }
            }
            LeaveCriticalSection(&m_SegmentCrSec);
        }
        else
        {
            if (SUCCEEDED(pVoice->Play(rtTime, pWave->lPitch, pWave->lVolume)))
            {
                if (pWave->dwFlags & DMUS_PMSGF_LOCKTOREFTIME)
                {
                    // This is a clock time message.
                    pWave->rtTime += pWave->rtDuration ;
                    pWave->dwFlags &= ~DMUS_PMSGF_MUSICTIME;

                }
                else
                {
                    pWave->mtTime += (MUSIC_TIME) pWave->rtDuration;
                    pWave->dwFlags &= ~DMUS_PMSGF_REFTIME;
                }
                pWave->bFlags |= DMUS_WAVEF_OFF;   // Queue this back up as a wave off.
                hr = DMUS_S_REQUEUE;
            }
        }
    }
    return hr;
}

HRESULT STDMETHODCALLTYPE CPerformance::ProcessPMsg(
    IDirectMusicPerformance* pPerf, // @parm The performance pointer.
    DMUS_PMSG* pPMsg            // @parm The message to process.
    )
{
    V_INAME(IDirectMusicTool::ProcessPMsg);
    V_INTERFACE(pPerf);
    V_BUFPTR_WRITE(pPMsg,sizeof(DMUS_PMSG));

    if (m_rtQueuePosition > pPMsg->rtTime + 50000000)
    {
        // pMSg is more than 5 seconds in the past; get rid of it unless it's signalling the
        // end of something that's already been started.
        if (pPMsg->dwType == DMUS_PMSGT_NOTIFICATION)
        {
            DMUS_NOTIFICATION_PMSG* pNotify = (DMUS_NOTIFICATION_PMSG*)pPMsg;
            if ( (pNotify->guidNotificationType == GUID_NOTIFICATION_PERFORMANCE &&
                  pNotify->dwNotificationOption != DMUS_NOTIFICATION_MUSICSTOPPED) ||
                 (pNotify->guidNotificationType == GUID_NOTIFICATION_SEGMENT &&
                  pNotify->dwNotificationOption != DMUS_NOTIFICATION_SEGEND) )
            {
                return DMUS_S_FREE;
            }
        }
        else if (pPMsg->dwType == DMUS_PMSGT_NOTE)
        {
            DMUS_NOTE_PMSG* pNote = (DMUS_NOTE_PMSG*)pPMsg;
            if (pNote->bFlags & DMUS_NOTEF_NOTEON)
            {
                return DMUS_S_FREE;
            }
        }
        else if (pPMsg->dwType == DMUS_PMSGT_WAVE)
        {
            DMUS_WAVE_PMSG* pWave = (DMUS_WAVE_PMSG*)pPMsg;
            if (!(pWave->bFlags & DMUS_WAVEF_OFF))
            {
                return DMUS_S_FREE;
            }
        }
        else
        {
            return DMUS_S_FREE;
        }
    }

    HRESULT hr = DMUS_S_FREE;

    ASSERT( pPerf == this );
    if( pPMsg->dwType == DMUS_PMSGT_TEMPO )
    {
        PRIV_PMSG* pPrivPMsg = DMUS_TO_PRIV(pPMsg);
        // If the pmsg was generated by a track, discard it
        // because it was already placed in the tempo map.
        if( pPrivPMsg->dwPrivFlags & PRIV_FLAG_TRACK )
        {
            return DMUS_S_FREE;
        }
        // Otherwise, this was generated by the application, so it's not already
        // in the tempo map and we need to add it.
        AddEventToTempoMap( DMUS_TO_PRIV(pPMsg));
        return DMUS_S_FREE; // OK to free this event; not requeued
    }

    if ((pPMsg->dwPChannel == DMUS_PCHANNEL_BROADCAST_GROUPS) ||
        (pPMsg->dwPChannel == DMUS_PCHANNEL_BROADCAST_PERFORMANCE))
    {
        // Scan through all the pchannels and make copies of the message for each pchannel.
        // Then, release this one.
        DWORD dwMax = PCHANNEL_BLOCKSIZE;
        // If one per channel group (for sysex, for example,) do only one per block.
        if (pPMsg->dwPChannel == DMUS_PCHANNEL_BROADCAST_GROUPS) dwMax = 1;
        EnterCriticalSection(&m_PipelineCrSec); // Make sure we are in this so we don't deadlock in SendPMsg().
        EnterCriticalSection(&m_PChannelInfoCrSec);
        CChannelBlock*  pChannelBlock = m_ChannelBlockList.GetHead();
        for( ; pChannelBlock; pChannelBlock = pChannelBlock->GetNext() )
        {
            DWORD dwIndex;
            for (dwIndex = 0; dwIndex < dwMax; dwIndex++)
            {
                CChannelMap* pChannelMap = &pChannelBlock->m_aChannelMap[ dwIndex ];
                if( pChannelMap->dwGroup &&
                    (pChannelMap->wFlags & (CMAP_STATIC | CMAP_VIRTUAL)))
                {
                    DWORD dwPChannel = dwIndex + pChannelBlock->m_dwPChannelStart;
                    // If this is a transpose on the drum channel, don't send it.
                    if ((pPMsg->dwType != DMUS_PMSGT_TRANSPOSE) || ((dwPChannel & 0xF) != 9))
                    {
                        DMUS_PMSG *pNewMsg;
                        if (SUCCEEDED(ClonePMsg(pPMsg,&pNewMsg)))
                        {
                            pNewMsg->dwPChannel = dwIndex + pChannelBlock->m_dwPChannelStart;
                            SendPMsg(pNewMsg);
                        }
                    }
                }
            }
        }
        LeaveCriticalSection(&m_PChannelInfoCrSec);
        LeaveCriticalSection(&m_PipelineCrSec);
        return DMUS_S_FREE;
    }

    if(pPMsg->dwType == DMUS_PMSGT_TRANSPOSE)
    {
        if( !( pPMsg->dwFlags & DMUS_PMSGF_TOOL_QUEUE ))
        {
            // requeue any tranpose event to be queue time
            pPMsg->dwFlags |= DMUS_PMSGF_TOOL_QUEUE;
            pPMsg->dwFlags &= ~( DMUS_PMSGF_TOOL_ATTIME | DMUS_PMSGF_TOOL_IMMEDIATE );
            return DMUS_S_REQUEUE;
        }
        else
        {
            DMUS_TRANSPOSE_PMSG* pTrans = (DMUS_TRANSPOSE_PMSG*)pPMsg;
            // set the PChannel for this transpose message
            EnterCriticalSection(&m_PChannelInfoCrSec);
            CChannelMap * pChannelMap = GetPChannelMap(pPMsg->dwPChannel);
            if (pChannelMap)
            {
                WORD wMergeIndex = 0;
                if (pPMsg->dwFlags & DMUS_PMSGF_DX8)
                {
                    wMergeIndex = pTrans->wMergeIndex;
                }
                pChannelMap->nTranspose = pChannelMap->m_TransposeMerger.MergeTranspose(
                    wMergeIndex,pTrans->nTranspose);
            }
            LeaveCriticalSection(&m_PChannelInfoCrSec);
            return DMUS_S_FREE;
        }
    }

    if(pPMsg->dwType == DMUS_PMSGT_NOTIFICATION )
    {
        DMUS_NOTIFICATION_PMSG* pNotify = (DMUS_NOTIFICATION_PMSG*)pPMsg;
        if (pNotify->guidNotificationType == GUID_NOTIFICATION_PRIVATE_CHORD)
        {
            // if we've got a GUID_NOTIFICATION_PRIVATE_CHORD,
            // invalidate/regenerate queued note events as necessary
            EnterCriticalSection(&m_PipelineCrSec);
            OnChordUpdateEventQueues(pNotify);
            LeaveCriticalSection(&m_PipelineCrSec);
            return DMUS_S_FREE;
        }
        else if( !( pPMsg->dwFlags & DMUS_PMSGF_TOOL_ATTIME ))
        {
            // requeue any notification event to be ontime
            pPMsg->dwFlags |= DMUS_PMSGF_TOOL_ATTIME;
            pPMsg->dwFlags &= ~( DMUS_PMSGF_TOOL_QUEUE | DMUS_PMSGF_TOOL_IMMEDIATE );
            return DMUS_S_REQUEUE;
        }
        else
        {
            // otherwise, fire the notification
            // first, move the event into the notification queue.
            // The app then calls GetNotificationPMsg to get the event.
            CLEARTOOLGRAPH(pPMsg);
            EnterCriticalSection(&m_PipelineCrSec);
            m_NotificationQueue.Enqueue( DMUS_TO_PRIV(pPMsg) );
            LeaveCriticalSection(&m_PipelineCrSec);
            EnterCriticalSection(&m_MainCrSec);
            if( m_hNotification )
            {
                SetEvent(m_hNotification);
            }
            LeaveCriticalSection(&m_MainCrSec);
            return S_OK; // don't free since we've placed the event into the
            // notification queue
        }
    }

    // add time signature changes to the time sig queue
    if(pPMsg->dwType == DMUS_PMSGT_TIMESIG )
    {
        CLEARTOOLGRAPH(pPMsg);
        DMUS_TIMESIG_PMSG* pTimeSig = (DMUS_TIMESIG_PMSG*)pPMsg;

        // check for a legal time signature, which may not have any
        // members equal to 0, and bBeat must be evenly divisible by 2.
        if( pTimeSig->wGridsPerBeat &&
            pTimeSig->bBeatsPerMeasure &&
            pTimeSig->bBeat &&
            ( 0 == ( pTimeSig->bBeat % 2 )))
        {
            EnterCriticalSection(&m_PipelineCrSec);
            REFERENCE_TIME rtNow = GetTime() - (10000 * 1000); // keep around for a second.
            PRIV_PMSG* pCheck;
            while (pCheck = m_TimeSigQueue.FlushOldest(rtNow))
            {
                FreePMsg(pCheck);
            }
            m_TimeSigQueue.Enqueue(  DMUS_TO_PRIV(pPMsg) );
            LeaveCriticalSection(&m_PipelineCrSec);
            return S_OK;
        }
        else
        {
            return DMUS_S_FREE;
        }
    }

    // requeue anything else that's early to be neartime
    if (pPMsg->dwFlags & DMUS_PMSGF_TOOL_IMMEDIATE)
    {
        // if this is a stop command, make sure the segment state doesn't keep going
        if( pPMsg->dwType == DMUS_PMSGT_STOP )
        {
            IDirectMusicSegment* pSeg = NULL;
            IDirectMusicSegmentState* pSegState = NULL;
            if( pPMsg->punkUser )
            {
                if( FAILED( pPMsg->punkUser->QueryInterface( IID_IDirectMusicSegment,
                    (void**)&pSeg )))
                {
                    pSeg = NULL;
                }
                else if( FAILED( pPMsg->punkUser->QueryInterface( IID_IDirectMusicSegmentState,
                    (void**)&pSegState )))
                {
                    pSegState = NULL;
                }
            }
            if( pSeg || pSegState )
            {
                EnterCriticalSection(&m_SegmentCrSec);
                if( pPMsg->mtTime > m_mtTransported )
                {
                    // find and mark the segment and/or segment state to not play beyond
                    // the stop point.
                    CSegState* pNode;
                    DWORD dwCount;
                    for (dwCount = 0; dwCount < SQ_COUNT; dwCount++)
                    {
                        for( pNode = m_SegStateQueues[dwCount].GetHead(); pNode; pNode = pNode->GetNext() )
                        {
                            if( (pNode->m_pSegment == pSeg) ||
                                (pNode == pSegState) )
                            {
                                pNode->m_mtStopTime = pPMsg->mtTime;
                            }
                        }
                    }
                }
                LeaveCriticalSection(&m_SegmentCrSec);
                if( pSeg )
                {
                    pSeg->Release();
                }
                if( pSegState )
                {
                    pSegState->Release();
                }
            }
        }
        pPMsg->dwFlags |= DMUS_PMSGF_TOOL_QUEUE;
        pPMsg->dwFlags &= ~( DMUS_PMSGF_TOOL_ATTIME | DMUS_PMSGF_TOOL_IMMEDIATE );
        return DMUS_S_REQUEUE;
    }

    switch( pPMsg->dwType )
    {
    case DMUS_PMSGT_NOTE:
        {
            hr = PackNote(  pPMsg, pPMsg->rtTime );
        }
        break;
    case DMUS_PMSGT_CURVE:
        {
            hr = PackCurve( pPMsg, pPMsg->rtTime );
        }
        break;
    case DMUS_PMSGT_SYSEX:
        {
            hr = PackSysEx( pPMsg, pPMsg->rtTime );
        }
        break;
    case DMUS_PMSGT_MIDI:
        {
            hr = PackMidi( pPMsg, pPMsg->rtTime );
        }
        break;
    case DMUS_PMSGT_PATCH:
        {
            hr = PackPatch( pPMsg, pPMsg->rtTime );
        }
        break;
    case DMUS_PMSGT_CHANNEL_PRIORITY:
        {
            DMUS_CHANNEL_PRIORITY_PMSG* pPriPMsg = (DMUS_CHANNEL_PRIORITY_PMSG*)pPMsg;
            DWORD dwPortTableIndex, dwGroup, dwMChannel;
            IDirectMusicPort* pPort;

            hr = DMUS_S_FREE;
            if( SUCCEEDED( PChannelIndex( pPriPMsg->dwPChannel, &dwPortTableIndex, &dwGroup,
                &dwMChannel )))
            {
                EnterCriticalSection(&m_PChannelInfoCrSec);
                if( dwPortTableIndex <= m_dwNumPorts )
                {
                    pPort = m_pPortTable[dwPortTableIndex].pPort;
                    if( pPort )
                    {
                        pPort->SetChannelPriority( dwGroup, dwMChannel,
                            pPriPMsg->dwChannelPriority );
                    }
                }
                LeaveCriticalSection(&m_PChannelInfoCrSec);
            }
        }
        break;
    case DMUS_PMSGT_WAVE:
        {
            hr = PackWave( pPMsg, pPMsg->rtTime );
        }
    default:
        break;
    }
    return hr;
}

HRESULT STDMETHODCALLTYPE CPerformance::Flush(
    IDirectMusicPerformance* pPerf, // @parm The Performance pointer.
     DMUS_PMSG* pPMsg,          // @parm The event to flush.
     REFERENCE_TIME rtTime          // @parm The time at which to flush.
    )
{
    V_INAME(IDirectMusicTool::Flush);
    V_INTERFACE(pPerf);
    V_BUFPTR_WRITE(pPMsg,sizeof(DMUS_PMSG));

    HRESULT hr = S_OK;

    ASSERT( pPerf == this );
    switch( pPMsg->dwType )
    {
    case DMUS_PMSGT_NOTE:
        {
            DMUS_NOTE_PMSG* pNote = (DMUS_NOTE_PMSG*)pPMsg;
            if( !(pNote->bFlags & DMUS_NOTEF_NOTEON) )
            {
                PackNote( pPMsg, rtTime );
            }
        }
        break;
    case DMUS_PMSGT_CURVE:
        {
            DMUS_CURVE_PMSG* pCurve = (DMUS_CURVE_PMSG*)pPMsg;
            if( pCurve->bFlags & DMUS_CURVE_RESET )
            {
                PackCurve( pPMsg, rtTime );
            }
        }
        break;
    case DMUS_PMSGT_WAVE:
        {
            DMUS_WAVE_PMSG* pWave = (DMUS_WAVE_PMSG*)pPMsg;
            if (pWave->bFlags & DMUS_WAVEF_OFF)
            {
                PackWave( pPMsg, rtTime );
            }
        }
    default:
        break;
    }
    return hr;
}

HRESULT STDMETHODCALLTYPE CPerformance::GetMsgDeliveryType(
    DWORD* pdwDeliveryType) // @parm Should return either DMUS_PMSGF_TOOL_IMMEDIATE, DMUS_PMSGF_TOOL_QUEUE, or DMUS_PMSGF_TOOL_ATTIME.
                    // An illegal return value will be treated as DMUS_PMSGF_TOOL_IMMEDIATE by the <i IDirectMusicGraph>.
{
    V_INAME(IDirectMusicTool::GetMsgDeliveryType);
    V_PTR_WRITE(pdwDeliveryType,DWORD);

    *pdwDeliveryType = DMUS_PMSGF_TOOL_IMMEDIATE;
    return S_OK;
}

HRESULT STDMETHODCALLTYPE CPerformance::GetMediaTypeArraySize(
    DWORD* pdwNumElements) // @parm Returns the number of media types, with 0 meaning all.
{
    V_INAME(IDirectMusicTool::GetMediaTypeArraySize);
    V_PTR_WRITE(pdwNumElements,DWORD);

    *pdwNumElements = 0;
    return S_OK;
}

HRESULT STDMETHODCALLTYPE CPerformance::GetMediaTypes(
    DWORD** padwMediaTypes, // @parm This should be a DWORD array of size <p dwNumElements>.
                            // Upon return, the elements will be filled with the media types
                            // this Tool supports.
    DWORD dwNumElements)    // @parm Contains the number of elements, i.e. the size, of the
                            // array <p padwMediaTypes>. <p dwNumElements> should be equal
                            // to the number returned in
                            // <om IDirectMusicTool.GetMediaTypeArraySize>. If dwNumElements
                            // is less than this number, this method can't return all of the
                            // message types that are supported. If it is greater than this
                            // number, the element fields in the array will be set to zero.
{
    return E_NOTIMPL;
}

// IDirectMusicGraph
HRESULT STDMETHODCALLTYPE CPerformance::Shutdown()
{
    return E_NOTIMPL;
}

HRESULT STDMETHODCALLTYPE CPerformance::InsertTool(
    IDirectMusicTool *pTool,
    DWORD *pdwPChannels,
    DWORD cPChannels,
    LONG lIndex)
{
    return E_NOTIMPL;
}

HRESULT STDMETHODCALLTYPE CPerformance::GetTool(
    DWORD dwIndex,
    IDirectMusicTool** ppTool)
{
    return E_NOTIMPL;
}

HRESULT STDMETHODCALLTYPE CPerformance::RemoveTool(
    IDirectMusicTool* pTool)
{
    return E_NOTIMPL;
}

HRESULT STDMETHODCALLTYPE CPerformance::StampPMsg( DMUS_PMSG* pPMsg )
{
    V_INAME(IDirectMusicGraph::StampPMsg);
    if( m_dwVersion < 8)
    {
        V_PTR_WRITE(pPMsg,sizeof(DMUS_PMSG));
    }
    else
    {
#ifdef DBG
        V_PTR_WRITE(pPMsg,sizeof(DMUS_PMSG));
#else
        if (!pPMsg)
        {
            return E_POINTER;
        }
#endif
    }

    EnterCriticalSection(&m_MainCrSec);
    if( m_pGraph && ( S_OK == m_pGraph->StampPMsg( pPMsg )))
    {
        if (pPMsg->pGraph != this)
        {
            if( pPMsg->pGraph )
            {
                pPMsg->pGraph->Release();
                pPMsg->pGraph = NULL;
            }
            pPMsg->pGraph = this;
            pPMsg->pGraph->AddRef();
        }
        LeaveCriticalSection(&m_MainCrSec);
        return S_OK;
    }
    LeaveCriticalSection(&m_MainCrSec);
    if( pPMsg->pGraph )
    {
        pPMsg->pGraph->Release();
        pPMsg->pGraph = NULL;
    }
    if( pPMsg->pTool )
    {
        pPMsg->pTool->Release();
        pPMsg->pTool = NULL;
    }

    //otherwise there is no graph: set it to the internal Performance Tool
    pPMsg->dwFlags &= ~(DMUS_PMSGF_TOOL_IMMEDIATE | DMUS_PMSGF_TOOL_QUEUE | DMUS_PMSGF_TOOL_ATTIME);
    pPMsg->dwFlags |= DMUS_PMSGF_TOOL_QUEUE;
    pPMsg->pTool = this;
    pPMsg->pTool->AddRef();
    return S_OK;
}

// default scale is C Major
const DWORD DEFAULT_SCALE_PATTERN = 0xab5ab5;

inline DWORD BitCount(DWORD dwPattern)

{
    DWORD dwCount = 0;

    while (dwPattern)
    {
        dwPattern &= (dwPattern - 1);
        dwCount++;
    }

    return dwCount;
}

inline bool InScale(BYTE bMIDI, BYTE bRoot, DWORD dwScale)
{
    TraceI(3, "note: %d root: %d scale: %x\n", bMIDI, bRoot, dwScale);
    // shift the note by the scale root, and put it in a one-octave range
    bMIDI = ((bMIDI + 12) - (bRoot % 12)) % 12;
     // merge two octaves of scale into one
    dwScale = (dwScale & 0x0fff) | ((dwScale >> 12) & 0x0fff);
    // note n is in scale if there's a bit in position n
    TraceI(3, "shifted note: %d shifted scale: %x\n", bMIDI, dwScale);
    return ((1 << bMIDI) & dwScale) ? true : false;
}

inline DWORD CleanupScale(DWORD dwPattern)

//  Force scale to be exactly two octaves

{
    dwPattern &= 0x0FFF;            // Clear upper octave.
    dwPattern |= (dwPattern << 12); // Copy lower octave to top.
    return dwPattern;
}

inline DWORD PatternMatch(DWORD dwA, DWORD dwB)

{
    DWORD dwHit = 0;
    DWORD dwIndex = 0;
    for (;dwIndex < 24; dwIndex++)
    {
        if ((dwA & (1 << dwIndex)) == (dwB & (1 << dwIndex)))
        {
            dwHit++;
        }
    }
    return dwHit;
}

static DWORD dwFallbackScales[12] =
{
    0xab5ab5,0x6ad6ad,
    0x5ab5ab,0xad5ad5,
    0x6b56b5,0x5ad5ad,
    0x56b56b,0xd5ad5a,
    0xb56b56,0xd6ad6a,
    0xb5ab5a,0xad6ad6,
};

inline DWORD FixScale(DWORD dwScale)

{
    if (BitCount(dwScale & 0xFFF) > 4)
    {
        return dwScale;
    }
    DWORD dwBest = 0;
    DWORD dwBestPattern = DEFAULT_SCALE_PATTERN;
    DWORD dwX;
    for (dwX = 0;dwX < 12; dwX++)
    {
        DWORD dwTest = PatternMatch(dwScale,dwFallbackScales[dwX]);
        if (dwTest > dwBest)
        {
            dwBestPattern = dwFallbackScales[dwX];
            dwBest = dwTest;
        }
    }
    return dwBestPattern;
}

inline DWORD ThreeOctave(DWORD dwScale)
{
    DWORD dwResult = dwScale;
     // don't change third octave if there's something there
    if ( !(0xFFF000000 & dwScale) )
    {
        // copy second octave to third octave
        dwResult |= (dwScale & 0xFFF000) << 12;
    }
    return dwResult;
}

inline DWORD AddRootToScale(BYTE bScaleRoot, DWORD dwScalePattern)

{
    dwScalePattern = CleanupScale(dwScalePattern);
    dwScalePattern >>= (12 - (bScaleRoot % 12));
    dwScalePattern = CleanupScale(dwScalePattern);
    return dwScalePattern;
}

inline DWORD SubtractRootFromScale(BYTE bScaleRoot, DWORD dwScalePattern)

{
    dwScalePattern = CleanupScale(dwScalePattern);
    dwScalePattern >>= (bScaleRoot % 12);
    dwScalePattern = CleanupScale(dwScalePattern);
    return dwScalePattern;
}

static DWORD ChordFromScale(BYTE bRoot, DWORD dwScalePattern)

{
    DWORD dwChordPattern = CleanupScale(dwScalePattern >> (bRoot % 12));
    DWORD dwX;
    DWORD dwBitCount = 0;
    for (dwX = 0; dwX < 24; dwX++)
    {
        DWORD dwBit = 1 << dwX;
        if (dwChordPattern & dwBit)
        {
            if ((dwBitCount & 1) || (dwBitCount > 7))
            {
                dwChordPattern &= ~dwBit;
            }
            dwBitCount++;
        }
    }
    return dwChordPattern;
}

static DWORD InvertChord(BYTE bKey, BYTE bChordRoot, DWORD dwChordPattern, bool& rfBelowRoot)

{
    // rotate the chord by the difference between the key and chord root
    rfBelowRoot = false;
    bKey %= 12;
    bChordRoot %= 12;
    if (bKey < bChordRoot) bKey += 12;
    BYTE bRotate = bKey - bChordRoot;
    // first check if the whole chord fits into one octave
    if ( !(dwChordPattern & 0xFFF000) )
    {
        dwChordPattern = ThreeOctave(CleanupScale(dwChordPattern));
        dwChordPattern >>= bRotate;
        dwChordPattern &= 0xFFF;
        if (!(dwChordPattern & 0x7) && ((dwChordPattern & 0xc00)) ||
            !(dwChordPattern & 0x3) && ((dwChordPattern & 0x800)))
        {
            dwChordPattern |= (dwChordPattern << 12);
            dwChordPattern &= 0x3FFC00;
            rfBelowRoot = true;
        }
    }
    else
    {
        dwChordPattern &= 0xFFFFFF; // make sure there are only notes in the two-octave range
        // do a circular shift in the closest direction
        BYTE bRotate2 = (bChordRoot + 12) - bKey;
        if (bRotate <= bRotate2)
        {
            dwChordPattern = (dwChordPattern << (24 - bRotate)) | (dwChordPattern >> bRotate);
        }
        else
        {
            dwChordPattern = (dwChordPattern >> (24 - bRotate2)) | (dwChordPattern << bRotate2);
        }
        dwChordPattern &= 0xFFFFFF;
        if (!(dwChordPattern & 0x7) &&
            (!(dwChordPattern & 0x7000) && ((dwChordPattern & 0xc00000)) ||
             !(dwChordPattern & 0x3000) && ((dwChordPattern & 0x800000)) ||
             !(dwChordPattern & 0x1000) && ((dwChordPattern & 0x1000000)) ||
             !(dwChordPattern & 0x7) && (dwChordPattern & 0x7000) && ((dwChordPattern & 0xc00000))) )
        {
            dwChordPattern = (dwChordPattern << 12) | (dwChordPattern >> 12);
            dwChordPattern &= 0xFFFFFF;
        }
        if (!(dwChordPattern & 0x7) && ((dwChordPattern & 0xc00)) ||
            !(dwChordPattern & 0x3) && ((dwChordPattern & 0x800)) ||
            !(dwChordPattern & 0x1) && ((dwChordPattern & 0x1000)) )
        {
            // put everything up to the G in the first octave two octaves up;
            // put G# and A one octave up
            dwChordPattern |= (((dwChordPattern & 0xFF) << 24) | ((dwChordPattern & 0x300) << 12));
            // get rid of everything below A# in the first octave
            dwChordPattern &= 0xFFFFFC00;
            // If there are no notes lower than C2, shift everything back down an octave
            if (!(dwChordPattern & 0xFFF))
            {
                dwChordPattern >>= 12;
            }
            else
            {
                rfBelowRoot = true;
            }
        }
    }
    return dwChordPattern;

}

/*  This is SuperJAM! code */

static unsigned char OldMusicValueToNote(

unsigned short value,   // Music value to convert.
char scalevalue,        // Scale value if chord failes.
long keypattern,        // Description of key as interval pattern.
char keyroot,           // Root note of key.
long chordpattern,      // Description of chord as interval pattern.
char chordroot)         // Root note of chord.

{
    unsigned char   result ;
    char            octpart   = (char)(value >> 12) ;
    char            chordpart = (char)((value >> 8) & 0xF) ;
    char            keypart   = (char)((value >> 4) & 0xF) ;
    char            accpart   = (char)(value & 0xF) ;

    result  = unsigned char(12 * octpart) ;
    result += chordroot ;

    if( accpart > 8 )
        accpart -= 16 ;

    for( ;  chordpattern ;  result++ ) {
        if( chordpattern & 1L ) {
            if( !chordpart )
                break ;
            chordpart-- ;
        }
        chordpattern = chordpattern >> 1L ;
        if( !chordpattern ) {
            if( !scalevalue )
                return( 0 ) ;
            result  = unsigned char(12 * octpart) ;
            result += chordroot ;
            keypart = char(scalevalue >> 4) ;
            accpart = char(scalevalue & 0x0F) ;
            break ;
        }
    }

    if( keypart ) {
        keypattern = CleanupScale(keypattern) ;
        keypattern  = keypattern >> (LONG)((result - keyroot) % 12) ;
        for( ;  keypattern ;  result++ ) {
            if( keypattern & 1L ) {
                if( !keypart )
                    break ;
                keypart-- ;
            }
            keypattern = keypattern >> 1L ;
        }
    }

    result += unsigned char(accpart) ;
    return( result ) ;

}


/*  This is SuperJAM! code */

static unsigned short OldNoteToMusicValue(

unsigned char note,     // MIDI note to convert.
long keypattern,        // Description of key as interval pattern.
char keyroot,           // Root note of key.
long chordpattern,      // Description of chord as interval pattern.
char chordroot)         // Root note of chord.

{
    unsigned char   octpart = 0 ;
    unsigned char   chordpart = 0;
    unsigned char   keypart = (BYTE)-1 ;
    unsigned char   accpart = 0 ;
    unsigned char   scan, test, base, last ;    // was char
    long            pattern ;
    short           testa, testb ;


    scan = chordroot ;

    // If we're trying to play a note below the bottom of our chord, forget it
    if( note < scan)
    {
        return 0;
    }

    while( scan < (note - 24) )
    {
        scan += 12 ;
        octpart++ ;
    }

    base = last = scan ;

    for( ;  base<=note ;  base+=12 )
    {
        chordpart = (unsigned char)-1 ;
        pattern   = chordpattern ;
        scan      = last = base ;
        if( scan == note )
        {
            accpart = 0;
            while (!(pattern & 1) && pattern)
            {
                accpart--;
                pattern >>= 1;
            }
            return( (unsigned short) (octpart << 12) + (accpart & 0xF)) ;           // if octave, return.
        }
        for( ;  pattern ;  pattern=pattern >> 1 )
        {
            if( pattern & 1 )                   // chord interval?
            {
                if( scan == note )              // note in chord?
                {
                    chordpart++ ;
                    return((unsigned short) ((octpart << 12) | (chordpart << 8))) ; // yes, return.
                }
                else if (scan > note)           // above note?
                {
                    test = scan ;
                    break ;                     // go on to key.
                }
                chordpart++ ;
                last = scan ;
            }
            scan++ ;
        }
        if( !pattern )                          // end of chord.
        {
            test = unsigned char(base + 12) ;                  // set to next note.
        }
        octpart++ ;
        if( test > note )
        {
            break ;                             // above our note?
        }
    }

    octpart-- ;

//  To get here, the note is not in the chord.  Scan should show the last
//  note in the chord.  octpart and chordpart have their final values.
//  Now, increment up the key to find the match.

    scan        = last ;
    pattern     = CleanupScale(keypattern);
    pattern     = pattern >> ((scan - keyroot) % 12) ;

    for( ;  pattern ;  pattern=pattern >> 1 )
    {
        if( 1 & pattern )
        {
            keypart++ ;
            accpart = 0 ;
        }
        else
        {
            accpart++ ;
        }
        if( scan == note )
            break ;
        scan++;
    }

    if( accpart && keypart )
    {
        testa = short((octpart << 12) + (chordpart << 8) + (keypart << 4) + accpart + 1);
        testb = short((octpart << 12) + ((chordpart + 1) << 8) + 0);
        testa = OldMusicValueToNote( testa, 0, keypattern, keyroot,
                                     chordpattern, chordroot );
        testb = OldMusicValueToNote( testb, 0, keypattern, keyroot,
                                     chordpattern, chordroot );
        if( testa == testb )
        {
            chordpart++ ;
            keypart = 0 ;
            accpart = -1 ;
        }
    }

    // If the conversion didn't find an exact match, fudge accpart to make it work
    testa = short((octpart << 12) + (chordpart << 8) + (keypart << 4) + (accpart & 0xF));
    testa = OldMusicValueToNote( testa, 0, keypattern, keyroot,
                                 chordpattern, chordroot );

    if( testa != note )
    {
        accpart += note - testa;
    }

    return unsigned short((octpart << 12) + (chordpart << 8) + (keypart << 4) + (accpart & 0xF));

}

inline short MusicValueOctave(WORD wMusicValue)
{ return short((wMusicValue >> 12) & 0xf) * 12; }

inline short MusicValueAccidentals(WORD wMusicValue)
{
    short acc = short(wMusicValue & 0xf);
    return (acc > 8) ? acc - 16 : acc;
}

inline short BitsInChord(DWORD dwChordPattern)
{

    for (short nResult = 0; dwChordPattern != 0; dwChordPattern >>= 1)
        if (dwChordPattern & 1) nResult++;
    return nResult;
}

#define S_OVER_CHORD    0x1000      // Success code to indicate the musicval could not be
                                    // converted because the note is above the top of the chord.

short MusicValueIntervals(WORD wMusicValue, BYTE bPlayModes, DMUS_SUBCHORD *pSubChord, BYTE bRoot)
{
    if ((bPlayModes & DMUS_PLAYMODE_CHORD_INTERVALS) || (bPlayModes & DMUS_PLAYMODE_SCALE_INTERVALS))
    {
        DWORD dwDefaultScale =
            (pSubChord->dwScalePattern) ? (pSubChord->dwScalePattern) : DEFAULT_SCALE_PATTERN;
        dwDefaultScale = AddRootToScale(pSubChord->bScaleRoot, dwDefaultScale);
        dwDefaultScale = ThreeOctave(FixScale(dwDefaultScale));
        DWORD dwChordPattern = pSubChord->dwChordPattern;
        if (!dwChordPattern) dwChordPattern = 1;
        bool fBelowRoot = false;
        if ((bPlayModes & DMUS_PLAYMODE_KEY_ROOT) && bPlayModes != DMUS_PLAYMODE_PEDALPOINT)
        {
            dwChordPattern = InvertChord(bRoot, pSubChord->bChordRoot, dwChordPattern, fBelowRoot);
        }
        const short nChordPosition = (wMusicValue >> 8) & 0xf;
//      const short nScalePosition = (wMusicValue >> 4) & 0xf;
        // ensure that scale position is < 8
        const short nScalePosition = (wMusicValue >> 4) & 0x7;
        const short nChordBits = BitsInChord(dwChordPattern);
        short nSemitones = 0;
        // If the chord doesn't have a root or second, but does have a seventh, it's been inverted and
        // we need to start below the root
        short nTransposetones;
        DWORD dwPattern;
        short nPosition;
        BYTE bOctRoot = bRoot % 12; // root in one octave
        // if using chord intervals and the note is in the chord
        if ((bPlayModes & DMUS_PLAYMODE_CHORD_INTERVALS) &&
            !nScalePosition &&
            (nChordPosition < nChordBits) )
        {
            nTransposetones = bRoot + MusicValueAccidentals(wMusicValue);
            dwPattern = dwChordPattern;
            nPosition = nChordPosition;
        }
        // if using chord intervals and note is inside the chord (including 6ths)
        else if ((bPlayModes & DMUS_PLAYMODE_CHORD_INTERVALS) &&
                 (nChordPosition < nChordBits) )
        {
            dwPattern = dwChordPattern;
            nPosition = nChordPosition;
            if (dwPattern)
            {
                // skip to the first note in the chord
                while (!(dwPattern & 1))
                {
                    dwPattern >>= 1;
                    nSemitones++;
                }
            }
            if (nPosition > 0)
            {
                do
                {
                    dwPattern >>= 1; // this will ignore the first note in the chord
                    nSemitones++;
                    if (dwPattern & 1)
                    {
                        nPosition--;
                    }
                    if (!dwPattern)
                    {
                        nSemitones += nPosition;
//                      assert (0); // This shouldn't happen...
                        break;
                    }
                } while (nPosition > 0);
            }

            nSemitones += bOctRoot;
            nTransposetones = MusicValueAccidentals(wMusicValue) + bRoot - bOctRoot;
            dwPattern = dwDefaultScale >> (nSemitones % 12);  // start comparing partway through the pattern
            nPosition = nScalePosition;
        }
        // if using scale intervals
        else if (bPlayModes & DMUS_PLAYMODE_SCALE_INTERVALS)
        {
            fBelowRoot = false; // forget about chord inversions
            nSemitones = bOctRoot;
            nTransposetones = MusicValueAccidentals(wMusicValue) + bRoot - bOctRoot;
            dwPattern = dwDefaultScale >> bOctRoot;  // start comparing partway through the pattern
            nPosition = nChordPosition * 2 + nScalePosition;
        }
        else
        {
            return S_OVER_CHORD;  //
        }
        nPosition++; // Now nPosition corresponds to actual scale positions
        for (; nPosition > 0; dwPattern >>= 1)
        {
            nSemitones++;
            if (dwPattern & 1)
            {
                nPosition--;
            }
            if (!dwPattern)
            {
                nSemitones += nPosition;
//              assert (0); // This shouldn't happen...
                break;
            }
        }
        nSemitones--; // the loop counts one too many semitones...
        if (fBelowRoot)
        {
            nSemitones -=12;
        }
        return nSemitones + nTransposetones;
    }
    else
    {
        // should be impossible for 2.5 format
        return bRoot + wMusicValue;
    }
}

inline short MusicValueChord(WORD wMusicValue, BYTE bPlayModes, DMUS_SUBCHORD *pSubChord, BYTE bKey)
{
    // first, get the root for transposition.
    BYTE bRoot = 0;
    if (bPlayModes & DMUS_PLAYMODE_CHORD_ROOT)
    {
        bRoot = pSubChord->bChordRoot;
    }
    else if (bPlayModes & DMUS_PLAYMODE_KEY_ROOT)
        bRoot = bKey;
    // Next, get an interval and combine it with the root.
    return MusicValueIntervals(wMusicValue, bPlayModes, pSubChord, bRoot);
}

inline short MusicValueConvert(WORD wMV, BYTE bPlayModes, DMUS_SUBCHORD *pSubChord, BYTE bKey)
{
    short nResult = 0;
    // First, make sure the octave is not negative.
    short nOffset = 0;
    while (wMV >= 0xE000)
    {
        wMV += 0x1000;
        nOffset -= 12;
    }

    // If the music value has a negative scale offset, convert to an equivalent
    // music value with a positive offset (up an octave) and shift the whole thing
    // down an octave
    WORD wTemp = (wMV & 0x00f0) + 0x0070;
    if (wTemp & 0x0f00)
    {
        wMV = (wMV & 0xff0f) | (wTemp & 0x00f0);
        nOffset = -12;
    }

    short nChordValue = MusicValueChord(wMV, bPlayModes, pSubChord, bKey);
    if (nChordValue != S_OVER_CHORD)
    {
        nChordValue += nOffset;
        // If the chord root is < 12, take the result down an octave.
        if ((bPlayModes & DMUS_PLAYMODE_CHORD_ROOT))
            nResult = MusicValueOctave(wMV) + nChordValue - 12;
        else
            nResult = MusicValueOctave(wMV) + nChordValue;
    }
    else
        nResult = S_OVER_CHORD;
    return nResult;
}

HRESULT STDMETHODCALLTYPE CPerformance::MIDIToMusic(
                BYTE bMIDIValue,
                DMUS_CHORD_KEY* pChord,
                BYTE bPlayMode,
                BYTE bChordLevel,
                WORD *pwMusicValue
            )

{
    V_INAME(IDirectMusicPerformance::MIDIToMusic);
    V_BUFPTR_READ( pChord, sizeof(DMUS_CHORD_KEY) );
    V_PTR_WRITE(pwMusicValue,WORD);

    long lMusicValue;
    HRESULT hr = S_OK;
#ifdef DBG
    long lMIDIInTraceValue = bMIDIValue;
#endif

    if ((bPlayMode & DMUS_PLAYMODE_NONE ) || (bMIDIValue & 0x80))
    {
        Trace(1,"Error: MIDIToMusic conversion failed either because there is no playmode or MIDI value %ld is out of range.\n",(long)bMIDIValue);
        return E_INVALIDARG;
    }
    else if( bPlayMode == DMUS_PLAYMODE_FIXED )
    {
        *pwMusicValue = bMIDIValue & 0x7F;
        return S_OK;
    }
    else if (bPlayMode == DMUS_PLAYMODE_FIXEDTOKEY) // fixed to key
    {
        lMusicValue = bMIDIValue - pChord->bKey;
        while (lMusicValue < 0)
        {
            lMusicValue += 12;
            Trace(2,"Warning: MIDIToMusic had to bump the music value up an octave for DMUS_PLAYMODE_FIXEDTOKEY note.\n");
            hr = DMUS_S_UP_OCTAVE;
        }
        while (lMusicValue > 127)
        {
            lMusicValue -= 12;
            Trace(2,"Warning: MIDIToMusic had to bump the music value up an octave for DMUS_PLAYMODE_FIXEDTOKEY note.\n");
            hr = DMUS_S_DOWN_OCTAVE;
        }
        *pwMusicValue = (WORD) lMusicValue;
        return hr;
    }
    else
    {
        DMUS_SUBCHORD *pSubChord;
        DWORD dwLevel = 1 << bChordLevel;
        bool fFoundLevel = false;
        for (int i = 0; i < pChord->bSubChordCount; i++)
        {
            if (dwLevel & pChord->SubChordList[i].dwLevels)
            {
                pSubChord = &pChord->SubChordList[i];
                fFoundLevel = true;
                break;
            }
        }
        if (!fFoundLevel) // No luck? Use first chord.
        {
            pSubChord = &pChord->SubChordList[0];
        }
        if (bPlayMode == DMUS_PLAYMODE_FIXEDTOCHORD) // fixed to chord
        {
            lMusicValue = bMIDIValue - (pSubChord->bChordRoot % 24);
            while (lMusicValue < 0)
            {
                lMusicValue += 12;
                Trace(2,"Warning: MIDIToMusic had to bump the music value up an octave for DMUS_PLAYMODE_FIXEDTOCHORD note.\n");
                hr = DMUS_S_UP_OCTAVE;
            }
            while (lMusicValue > 127)
            {
                lMusicValue -= 12;
                Trace(2,"Warning: MIDIToMusic had to bump the music value down an octave for DMUS_PLAYMODE_FIXEDTOCHORD note.\n");
                hr = DMUS_S_DOWN_OCTAVE;
            }
            *pwMusicValue = (WORD) lMusicValue;
            return hr;
        }
        bool fBelowRoot = false;
        DWORD dwScalePattern = AddRootToScale(pSubChord->bScaleRoot, pSubChord->dwScalePattern);
        DWORD dwChordPattern = pSubChord->dwChordPattern;
        BYTE bKeyRoot = pChord->bKey;
        BYTE bChordRoot = pSubChord->bChordRoot;
        dwScalePattern = FixScale(dwScalePattern);
        bPlayMode &= 0xF;   // We only know about the bottom four flags, at this point.
//        if (bPlayMode == DMUS_PLAYMODE_PEDALPOINT)
        // Do this for any non-fixed key root mode (Pedalpoint, PedalpointChord, PedalpointAlways)
        if (bPlayMode & DMUS_PLAYMODE_KEY_ROOT)
        {
            while (bKeyRoot > bMIDIValue)
            {
                hr = DMUS_S_UP_OCTAVE;
                Trace(2,"Warning: MIDIToMusic had to bump the music value up an octave for DMUS_PLAYMODE_KEY_ROOT note.\n");
                bMIDIValue += 12;
            }
            dwScalePattern = SubtractRootFromScale(bKeyRoot,dwScalePattern);
            if (bPlayMode == DMUS_PLAYMODE_PEDALPOINT || !dwChordPattern)
            {
                bChordRoot = bKeyRoot;
                dwChordPattern = ChordFromScale(0,dwScalePattern);
            }
            else
            {
                dwChordPattern = InvertChord(bKeyRoot, bChordRoot, dwChordPattern, fBelowRoot);
                BYTE bNewChordRoot = 0;
                if (dwChordPattern)
                {
                    for (; !(dwChordPattern & (1 << bNewChordRoot)); bNewChordRoot++);
                }
                bChordRoot = bNewChordRoot + bKeyRoot;
                dwChordPattern >>= bNewChordRoot;
            }
        }
        else if (bPlayMode == DMUS_PLAYMODE_MELODIC)
        {
            bKeyRoot = 0;
            dwChordPattern = ChordFromScale(bChordRoot,dwScalePattern);
        }
        else
        {
            bKeyRoot = 0;
            if (!dwChordPattern)
            {
                dwChordPattern = ChordFromScale(bChordRoot,dwScalePattern);
            }
        }
        BOOL fDropOctave = FALSE;
        if (bMIDIValue < 24)
        {
            fDropOctave = TRUE;
            bMIDIValue += 24;
        }
        WORD wNewMusicValue = OldNoteToMusicValue( bMIDIValue,
            dwScalePattern,
            bKeyRoot,
            dwChordPattern,
            bChordRoot );
        if (fDropOctave)
        {
            wNewMusicValue -= 0x2000;
            bMIDIValue -= 24;
        }

        // If DMUS_PLAYMODE_CHORD_ROOT is set, take the result up an octave.
        // // also take the result up for the new pedalpoint chord modes.
        if( (bPlayMode & DMUS_PLAYMODE_CHORD_ROOT)  ||
            fBelowRoot)
            //((bPlayMode & DMUS_PLAYMODE_KEY_ROOT) && bPlayMode != DMUS_PLAYMODE_PEDALPOINT) )
        {
            wNewMusicValue += 0x1000;
        }
        short nTest =
            MusicValueConvert(wNewMusicValue, bPlayMode,
                pSubChord, pChord->bKey);

        if (nTest == (short) bMIDIValue)
        {
            *pwMusicValue = wNewMusicValue;
        }
        else
        {
            if (nTest == S_OVER_CHORD)
            {
                if (BitCount(pSubChord->dwChordPattern) < 4)
                {
                    DWORD dwOldChordPattern = pSubChord->dwChordPattern;
                    pSubChord->dwChordPattern = ChordFromScale(bChordRoot,dwScalePattern);
                    nTest =
                        MusicValueConvert(wNewMusicValue, bPlayMode,
                            pSubChord, pChord->bKey);
                    pSubChord->dwChordPattern = dwOldChordPattern;
                    if (nTest == (short) bMIDIValue)
                    {
                        *pwMusicValue = wNewMusicValue;
                        return hr;
                    }
                }
            }
            *pwMusicValue = wNewMusicValue;
#ifdef DBG // Put in brackets just in case the compiler is using something different than DBG for turning on Trace.
            Trace(1,"Error: Unable to convert MIDI value %ld to Music value. This usually means the DMUS_CHORD_KEY structure has an invalid chord or scale pattern.\n",
                lMIDIInTraceValue);
#endif
            return DMUS_E_CANNOT_CONVERT;
        }
    }
    return hr;
}


HRESULT STDMETHODCALLTYPE CPerformance::MusicToMIDI(
                WORD wMusicValue,
                DMUS_CHORD_KEY* pChord,
                BYTE bPlayMode,
                BYTE bChordLevel,
                BYTE *pbMIDIValue
            )

{
    V_INAME(IDirectMusicPerformance::MusicToMIDI);
    V_BUFPTR_READ( pChord, sizeof(DMUS_CHORD_KEY) );
    V_PTR_WRITE(pbMIDIValue,BYTE);

    long lReturnVal = wMusicValue;
    HRESULT hr = S_OK;

    if (bPlayMode != DMUS_PLAYMODE_FIXED)
    {
        DMUS_SUBCHORD *pSubChord;
        DWORD dwLevel = 1 << bChordLevel;
        bool fFoundLevel = false;
        for (int i = 0; i < pChord->bSubChordCount; i++)
        {
            if (dwLevel & pChord->SubChordList[i].dwLevels)
            {
                pSubChord = &pChord->SubChordList[i];
                fFoundLevel = true;
                break;
            }
        }
        if (!fFoundLevel) // No luck? Use first chord.
        {
            pSubChord = &pChord->SubChordList[0];
        }
        if (bPlayMode & DMUS_PLAYMODE_NONE )
        {
            *pbMIDIValue = 0;
            Trace(1,"Error: Unable to convert Music value to MIDI because the playmode is DMUS_PLAYMODE_NONE.\n");
            return E_INVALIDARG;
        }
        if (bPlayMode == DMUS_PLAYMODE_FIXEDTOCHORD) // fixed to chord
        {
            lReturnVal += (pSubChord->bChordRoot % 24);
        }
        else if (bPlayMode == DMUS_PLAYMODE_FIXEDTOKEY) // fixed to scale
        {
            lReturnVal += pChord->bKey;
        }
        else
        {
            lReturnVal =
                MusicValueConvert((WORD)lReturnVal, bPlayMode, pSubChord, pChord->bKey);
        }
    }
    if (lReturnVal == S_OVER_CHORD)
    {
        Trace(5,"Warning: MIDIToMusic unable to convert because note out of chord range.\n");
        return DMUS_S_OVER_CHORD;
    }
    while (lReturnVal < 0)
    {
        lReturnVal += 12;
        Trace(2,"Warning: MusicToMIDI had to bump the music value up an octave to stay in MIDI range.\n");
        hr = DMUS_S_UP_OCTAVE;
    }
    while (lReturnVal > 127)
    {
        lReturnVal -= 12;
        Trace(2,"Warning: MusicToMIDI had to bump the music value down an octave to stay in MIDI range.\n");
        hr = DMUS_S_DOWN_OCTAVE;
    }
    *pbMIDIValue = (BYTE) lReturnVal;
    return hr;
}

// returns:
// S_OK if the note should be invalidated (any other return code will not invalidate)
// S_FALSE if processing otherwise succeeded, but the note should not be invalidated
// E_OUTOFMEMORY if allocation of a new note failed
HRESULT CPerformance::GetChordNotificationStatus(DMUS_NOTE_PMSG* pNote,
                                                 //IDirectMusicSegment* pSegment,
                                                 DWORD dwTrackGroup,
                                                 REFERENCE_TIME rtTime,
                                                 DMUS_PMSG** ppNew)
{
    HRESULT hr = S_FALSE; // default: succeed, but don't invalidate the note

    DMUS_CHORD_PARAM CurrentChord;
    MUSIC_TIME mtTime;
    ReferenceToMusicTime(rtTime, &mtTime);

    if (pNote->bFlags & (DMUS_NOTEF_NOINVALIDATE_INSCALE | DMUS_NOTEF_NOINVALIDATE_INCHORD))
    {
        // If the note is inconsistent with the current scale/chord, invalidate it
        if (SUCCEEDED(GetParam(GUID_ChordParam, dwTrackGroup, DMUS_SEG_ANYTRACK,
                                mtTime, NULL, (void*) &CurrentChord)))
        {
            if (CurrentChord.bSubChordCount > 0)
            {
                BYTE bRoot = CurrentChord.SubChordList[0].bChordRoot;
                DWORD dwScale = CurrentChord.SubChordList[0].dwScalePattern;
                if (pNote->bFlags & DMUS_NOTEF_NOINVALIDATE_INCHORD)
                {
                    dwScale = CurrentChord.SubChordList[0].dwChordPattern;
                }
                else
                {
                    dwScale = FixScale(SubtractRootFromScale(bRoot, dwScale));
                }
                if (!InScale(pNote->bMidiValue, bRoot, dwScale))
                {
                    hr = S_OK;
                }
            }
        }
    }
    else if (pNote->bFlags & DMUS_NOTEF_REGENERATE)
    {
        // this always causes an invalidation, and in addition generates a new note event,
        // based on the Music Value of the current one, that starts at rtTime
        // and continues until pNote->mtTime + pNote->Duration
        // EXCEPTION: the newly generated note is the same as the currently playing one
        if (SUCCEEDED(GetParam(GUID_ChordParam, dwTrackGroup, DMUS_SEG_ANYTRACK,
                                mtTime, NULL, (void*) &CurrentChord)))
        {
            BYTE bNewMidiValue = 0;
            if (SUCCEEDED(MusicToMIDI(pNote->wMusicValue, &CurrentChord, pNote->bPlayModeFlags,
                                        pNote->bSubChordLevel, &bNewMidiValue)) &&
                bNewMidiValue != pNote->bMidiValue)
            {
                MUSIC_TIME mtDuration = (pNote->bFlags & DMUS_NOTEF_NOTEON) ? pNote->mtDuration - (mtTime - pNote->mtTime) : pNote->mtTime - mtTime;
                // Make any duration < 1 be 0; this will cause the note not to
                // sound.  Can happen if the note's logical time is well before
                // its physical time.
                if( mtDuration < 1 ) mtDuration = 0;
                DMUS_PMSG* pNewPMsg = NULL;
                if( SUCCEEDED( AllocPMsg( sizeof(DMUS_NOTE_PMSG), &pNewPMsg )))
                {
                    DMUS_NOTE_PMSG* pNewNote = (DMUS_NOTE_PMSG*)pNewPMsg;
                    // start by copying the current note into the new one
                    pNewNote->dwFlags = pNote->dwFlags;
                    pNewNote->dwPChannel = pNote->dwPChannel;
                    pNewNote->dwVirtualTrackID = pNote->dwVirtualTrackID;
                    pNewNote->pTool = pNote->pTool;
                    if (pNewNote->pTool) pNewNote->pTool->AddRef();
                    pNewNote->pGraph = pNote->pGraph;
                    if (pNewNote->pGraph) pNewNote->pGraph->AddRef();
                    pNewNote->dwType = pNote->dwType;
                    pNewNote->dwVoiceID = pNote->dwVoiceID;
                    pNewNote->dwGroupID = pNote->dwGroupID;
                    pNewNote->punkUser = pNote->punkUser;
                    if (pNewNote->punkUser) pNewNote->punkUser->AddRef();
                    pNewNote->wMusicValue = pNote->wMusicValue;
                    pNewNote->wMeasure = pNote->wMeasure;
                    pNewNote->nOffset = pNote->nOffset;
                    pNewNote->bBeat = pNote->bBeat;
                    pNewNote->bGrid = pNote->bGrid;
                    pNewNote->bVelocity = pNote->bVelocity;
                    pNewNote->bTimeRange = pNote->bTimeRange;
                    pNewNote->bDurRange = pNote->bDurRange;
                    pNewNote->bVelRange = pNote->bVelRange;
                    pNewNote->bPlayModeFlags = pNote->bPlayModeFlags;
                    pNewNote->bSubChordLevel = pNote->bSubChordLevel;
                    pNewNote->cTranspose = pNote->cTranspose;
                    // only things that need to change are flags, MIDI value, start time, and duration
                    pNewNote->mtTime = mtTime;
                    MusicToReferenceTime(pNewNote->mtTime, &pNewNote->rtTime);
                    pNewNote->mtDuration = mtDuration;
                    pNewNote->bMidiValue = bNewMidiValue;
                    pNewNote->bFlags = DMUS_NOTEF_NOTEON | DMUS_NOTEF_REGENERATE;
                    PackNote(pNewPMsg, rtTime + 1); // play the note on
                    *ppNew = pNewPMsg;  // PackNote modifies event to be note-off; queue this
                    // invalidate the current note
                    hr = S_OK;
                }
                else hr = E_OUTOFMEMORY;
            }
        }
    }
    return hr;
}

HRESULT STDMETHODCALLTYPE CPerformance::TimeToRhythm(
                MUSIC_TIME mtTime,
                DMUS_TIMESIGNATURE *pTimeSig,
                WORD *pwMeasure,
                BYTE *pbBeat,
                BYTE *pbGrid,
                short *pnOffset
            )

{
    V_INAME(IDirectMusicPerformance::TimeToRhythm);
    V_BUFPTR_READ( pTimeSig, sizeof(DMUS_TIMESIGNATURE) );
    V_PTR_WRITE(pwMeasure,WORD);
    V_PTR_WRITE(pbBeat,BYTE);
    V_PTR_WRITE(pbGrid,BYTE);
    V_PTR_WRITE(pnOffset,short);

    long lMeasureLength;
    long lBeatLength = DMUS_PPQ;
    long lGridLength;

    if( pTimeSig->bBeat )
    {
        lBeatLength = DMUS_PPQ * 4 / pTimeSig->bBeat;
    }
    lMeasureLength = lBeatLength * pTimeSig->bBeatsPerMeasure;
    if( pTimeSig->wGridsPerBeat )
    {
        lGridLength = lBeatLength / pTimeSig->wGridsPerBeat;
    }
    else
    {
        lGridLength = lBeatLength / 256;
    }
    long lTemp = mtTime - pTimeSig->mtTime;
    *pwMeasure = (WORD)((lTemp / lMeasureLength));
    lTemp = lTemp % lMeasureLength;
    *pbBeat = (BYTE)(lTemp / lBeatLength);
    lTemp = lTemp % lBeatLength;
    *pbGrid = (BYTE)(lTemp / lGridLength);
    *pnOffset = (short)(lTemp % lGridLength);
    if (*pnOffset > (lGridLength >> 1))
    {
        *pnOffset -= (short) lGridLength;
        (*pbGrid)++;
        if (*pbGrid == pTimeSig->wGridsPerBeat)
        {
            *pbGrid = 0;
            (*pbBeat)++;
            if (*pbBeat == pTimeSig->bBeatsPerMeasure)
            {
                *pbBeat = 0;
                (*pwMeasure)++;
            }
        }
    }
    return S_OK;
}

HRESULT STDMETHODCALLTYPE CPerformance::RhythmToTime(
                WORD wMeasure,
                BYTE bBeat,
                BYTE bGrid,
                short nOffset,
                DMUS_TIMESIGNATURE *pTimeSig,
                MUSIC_TIME *pmtTime
            )

{
    V_INAME(IDirectMusicPerformance::RhythmToTime);
    V_BUFPTR_READ( pTimeSig, sizeof(DMUS_TIMESIGNATURE) );
    V_PTR_WRITE(pmtTime,MUSIC_TIME);

    long lMeasureLength;
    long lBeatLength = DMUS_PPQ;
    long lGridLength;

    if( pTimeSig->bBeat )
    {
        lBeatLength = DMUS_PPQ * 4 / pTimeSig->bBeat;
    }
    lMeasureLength = lBeatLength * pTimeSig->bBeatsPerMeasure;
    if( pTimeSig->wGridsPerBeat )
    {
        lGridLength = lBeatLength / pTimeSig->wGridsPerBeat;
    }
    else
    {
        lGridLength = lBeatLength / 256;
    }
    long lTemp = nOffset + pTimeSig->mtTime;
    lTemp += wMeasure * lMeasureLength;
    lTemp += bBeat * lBeatLength;
    lTemp += bGrid * lGridLength;
    *pmtTime = lTemp;
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\XDmime\dmprfdll.h ===
// Copyright (c) 1998-1999 Microsoft Corporation
// dmprfdll.h
//
// Class factory
//

#ifndef __DMPRFDLL_H_
#define __DMPRFDLL_H_
 
class CClassFactory : public IClassFactory
{
public:
	// IUnknown
    //
	STDMETHODIMP QueryInterface(const IID &iid, void **ppv);
	STDMETHODIMP_(ULONG) AddRef();
	STDMETHODIMP_(ULONG) Release();

	// Interface IClassFactory
    //
	STDMETHODIMP CreateInstance(IUnknown* pUnknownOuter, const IID& iid, void** ppv);
	STDMETHODIMP LockServer(BOOL bLock); 

	// Constructor
    //
	CClassFactory(DWORD dwToolType);

	// Destructor
	~CClassFactory(); 

private:
	long m_cRef;
    DWORD m_dwClassType;
};

// We use one class factory to create all classes. We need an identifier for each 
// type so the class factory knows what it is creating.

#define CLASS_PERFORMANCE   1
#define CLASS_GRAPH         2
#define CLASS_SEGMENT       3
#define CLASS_SONG          4
#define CLASS_AUDIOPATH     5
#define CLASS_SEQTRACK      6
#define CLASS_SYSEXTRACK    7
#define CLASS_TEMPOTRACK    8
#define CLASS_TIMESIGTRACK  9
#define CLASS_LYRICSTRACK   10
#define CLASS_MARKERTRACK   11
#define CLASS_PARAMSTRACK   12
#define CLASS_TRIGGERTRACK  13
#define CLASS_WAVETRACK     14
#define CLASS_SEGSTATE      15



#endif // __DMPRFDLL_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\XDmime\dmperf.h ===
// Copyright (c) 1998-1999 Microsoft Corporation
// dmperf.h
// @doc EXTERNAL

#ifndef _DMPERF_H_ 
#define _DMPERF_H_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#include "dmusicc.h"
#include "dmusici.h"
#include "dmusicf.h"
#include "dmime.h"
#include "ntfylist.h"
#include "dmsstobj.h"
#include "audpath.h"
#include "dmusicp.h"

#define DMUS_PCHANNEL_KILL_ME   0xFFFFFFF0

typedef struct _DMUS_SEGSTATEDATA
{
    _DMUS_SEGSTATEDATA *    pNext;        // Linked list of these.
    DWORD                   dwQueue;      // Which queue it is in.
    WCHAR                   wszName[DMUS_MAX_NAME]; // Name of object. 
    MUSIC_TIME              mtLoopStart;  // Loop start point.
    MUSIC_TIME              mtLoopEnd;    // Loop end point.
    DWORD                   dwRepeats;    // The original repeat setting (before countdown)
    MUSIC_TIME              mtLength;     // Length of segment.
    REFERENCE_TIME          rtGivenStart; // Start time given in PlaySegment, unquantized
    MUSIC_TIME              mtResolvedStart;// Start time resolved to desired resolution
    MUSIC_TIME              mtOffset;     // Start time of the segment in absolute time, as if it were started from the beginning. 
    MUSIC_TIME              mtLastPlayed; // The last played absolute time
    MUSIC_TIME              mtPlayTo;     // Used to stop play at a specific time. Ignored when 0.
    MUSIC_TIME              mtSeek;       // How far into the segment we are.
    MUSIC_TIME              mtStartPoint; // Point in the segment where playback started
    DWORD                   dwRepeatsLeft;// Current repeats left.
    DWORD                   dwPlayFlags;// Segment playback control flags
    BOOL                    fStartedPlay; // Indicates if the segstate has started to play yet
    IDirectMusicSegmentState *pSegState;  // Pointer to segstate.
} DMUS_SEGSTATEDATA;

/*////////////////////////////////////////////////////////////////////
// IDirectMusicParamHook */
#undef  INTERFACE
#define INTERFACE  IDirectMusicParamHook
DECLARE_INTERFACE_(IDirectMusicParamHook, IUnknown)
{
    /*  IUnknown */
    STDMETHOD(QueryInterface)       (THIS_ REFIID, LPVOID FAR *) PURE;
    STDMETHOD_(ULONG,AddRef)        (THIS) PURE;
    STDMETHOD_(ULONG,Release)       (THIS) PURE;

    /*  IDirectMusicParamHook */
    STDMETHOD(GetParam)             (THIS_ REFGUID rguidType, 
                                           DWORD dwGroupBits, 
                                           DWORD dwIndex, 
                                           MUSIC_TIME mtTime, 
                                           MUSIC_TIME* pmtNext, 
                                           void* pData,
                                           IDirectMusicSegmentState *pSegState,
                                           DWORD dwTrackFlags,
                                           HRESULT hr) PURE;
};

#undef  INTERFACE
#define INTERFACE  IDirectMusicSetParamHook
DECLARE_INTERFACE_(IDirectMusicSetParamHook, IUnknown)
{
    /* IUnknown */
    STDMETHOD(QueryInterface)       (THIS_ REFIID, LPVOID FAR *) PURE;
    STDMETHOD_(ULONG,AddRef)        (THIS) PURE;
    STDMETHOD_(ULONG,Release)       (THIS) PURE;

    /* IDirectMusicSetParamHook */
    STDMETHOD(SetParamHook)         (THIS_ IDirectMusicParamHook *pIHook) PURE; 
};


#undef  INTERFACE
#define INTERFACE  IDirectMusicPerformanceStats
DECLARE_INTERFACE_(IDirectMusicPerformanceStats, IUnknown)
{
    /* IUnknown */
    STDMETHOD(QueryInterface)       (THIS_ REFIID, LPVOID FAR *) PURE;
    STDMETHOD_(ULONG,AddRef)        (THIS) PURE;
    STDMETHOD_(ULONG,Release)       (THIS) PURE;

    /* IDirectMusicPerformanceStats */
    STDMETHOD(TraceAllSegments)     (THIS) PURE;
    STDMETHOD(CreateSegstateList)   (THIS_ DMUS_SEGSTATEDATA ** ppList) PURE;     
    STDMETHOD(FreeSegstateList)     (THIS_ DMUS_SEGSTATEDATA * pList) PURE; 
};



#define DEFAULT_BUFFER_SIZE 1024
// the following constants represent time in milliseconds
#define TRANSPORT_RES 100
#define REALTIME_RES 10

// the following constants represent time in 100 nanosecond increments

#define REF_PER_MIL     10000       // For converting from reference time to mils 
#define MARGIN_MIN      (100 * REF_PER_MIL) // 
#define MARGIN_MAX      (400 * REF_PER_MIL) // 
#define PREPARE_TIME    (m_dwPrepareTime * REF_PER_MIL) // Time
#define NEARTIME        (100 * REF_PER_MIL)
#define NEARMARGIN      (REALTIME_RES * REF_PER_MIL)
/*
// here's a convenience inline function that helps using resolution bits
inline DWORD SIMPLIFY_RESOLUTION(DWORD x)
{   
    if( x & DMUS_SEGF_DEFAULT )     
    {                               
        return DMUS_SEGF_DEFAULT;
    }                               
    else if( x & DMUS_SEGF_SEGMENTEND )
    {
        return DMUS_SEGF_SEGMENTEND;
    }
    else if( x & DMUS_SEGF_MARKER )
    {
        return DMUS_SEGF_MARKER;
    }
    else if( x & DMUS_SEGF_MEASURE )        
    {                               
        return DMUS_SEGF_MEASURE;       
    }                               
    else if( x & DMUS_SEGF_BEAT )   
    {                               
        return DMUS_SEGF_BEAT;          
    }                               
    else if( x & DMUS_SEGF_GRID )   
    {                               
        return DMUS_SEGF_GRID;          
    }   
    else return 0;                      
}
*/

struct PRIV_PMSG;

// pNext contains the next pointer for the next PMsg
// dwPrivFlags contains private flags used by the performance
// rtLast contains the previous time when an event is requeued,
//      which is used by the flush routine
#define PRIV_PART                       \
    struct PRIV_PMSG*   pNext;          \
    DWORD               dwPrivFlags;    \
    DWORD               dwPrivPubSize;  \
    REFERENCE_TIME      rtLast; 

typedef struct PRIV_PART_STRUCT
{
    /* begin PRIV_PART */
    PRIV_PART
    /* end PRIV_PART */
} PRIV_PART_STRUCT;

#define PRIV_PART_SIZE  sizeof(PRIV_PART_STRUCT)
#define PRIV_TO_DMUS(x) ((DMUS_PMSG*)(LPBYTE(x) + PRIV_PART_SIZE))
#define DMUS_TO_PRIV(x) ((PRIV_PMSG*)(LPBYTE(x) - PRIV_PART_SIZE))

typedef struct PRIV_PMSG
{
    /* begin PRIV_PART */
    PRIV_PART
    /* end PRIV_PART */
    /* begin DMUS_PMSG_PART */
    DMUS_PMSG_PART
    /* end DMUS_PMSG_PART */
} PRIV_PMSG;

typedef struct PRIV_TEMPO_PMSG
{
    /* begin PRIV_PART */
    PRIV_PART
    /* end PRIV_PART */
    DMUS_TEMPO_PMSG tempoPMsg;
} PRIV_TEMPO_PMSG;

#define PRIV_FLAG_ALLOC_MASK    0x0000FFFF0 // using 4 bits for this for now
#define PRIV_FLAG_ALLOC         0x0000CAFE0 // arbitrary pattern for allocated
#define PRIV_FLAG_FREE			0x0000DEAD0 // pattern for in free list
#define PRIV_FLAG_QUEUED        0x000000001 // set if in a queue
#define PRIV_FLAG_REMOVE        0x000000002 // set if this needs to be removed from a queue
#define PRIV_FLAG_TRACK 		0x000000004 // indicates this message was generated by a track 
#define PRIV_FLAG_FLUSH 		0x000000008 // this is a curve that needs to be flushed after
                                            // its end value has played 
#define PRIV_FLAG_REQUEUE       0x000100000 // set if this needs to be requeued to a queue


class CPMsgQueue
{
public:
    CPMsgQueue();
    ~CPMsgQueue();
    void            Enqueue(PRIV_PMSG *pItem);
    PRIV_PMSG *     Dequeue();
    PRIV_PMSG *     Dequeue(PRIV_PMSG *pItem);
    PRIV_PMSG *     GetHead() { return (m_pTop);}
    PRIV_PMSG *     FlushOldest(REFERENCE_TIME rtTime);
    long            GetCount();
    void            Sort();
private:
    PRIV_PMSG *     m_pTop;             // Top of list.
    PRIV_PMSG *     m_pLastAccessed;    // Last item access in list.
};

// structure used to hold Ports and Buffers
typedef struct PortTable
{
    REFERENCE_TIME      rtLast; // last message time packed
    IDirectMusicPort*  pPort;
    IDirectMusicBuffer* pBuffer;
    IReferenceClock*    pLatencyClock;
    BOOL                fBufferFilled;   // TRUE if there are messages in the buffer that should be sent to the port
    DWORD               dwChannelGroups; // Number of channel groups active on the port.
    CLSID               guidPortID;      // The class id of the port, for matching with audio path requests.
    DMUS_PORTPARAMS8    PortParams;      // PortParams returned when this port was created.  
    DWORD               dwGMFlags;       // DM_PORTFLAGS_XG, DM_PORTFLAGS_GM, and DM_PORTFLAGS_GS.
} PortTable;

// structure to hold a channel of an accumulated parameter.
// The CChannelMap keeps a linked list of these, one list each
// for each parameter type.

class CMergeParam : public AListItem
{
public:
    CMergeParam* GetNext() { return (CMergeParam*)AListItem::GetNext();}
    long                m_lData;    // Current parameter data.
    DWORD               m_dwIndex;  // Which layer.
};

class CParamMerger : public AList
{
public:
    CParamMerger();
    void Clear(long lInitValue);
    BYTE MergeMidiVolume(DWORD dwIndex, BYTE bMIDIVolume);
    BYTE GetVolumeStart(DWORD dwIndex);
    short MergeTranspose(DWORD dwIndex, short nTranspose);
    long MergeValue(DWORD dwIndex, long lData, long lCenter, long lRange);
    long GetIndexedValue(DWORD dwIndex);
private:
    long MergeData(DWORD dwIndex, long lData);
    void AddHead(CMergeParam* pMergeParam) { AList::AddHead((AListItem*)pMergeParam);}
    CMergeParam* GetHead(){return (CMergeParam*)AList::GetHead();}
    CMergeParam* RemoveHead() {return (CMergeParam *) AList::RemoveHead();}
    void Remove(CMergeParam* pMergeParam){AList::Remove((AListItem*)pMergeParam);}
    void AddTail(CMergeParam* pMergeParam){AList::AddTail((AListItem*)pMergeParam);}
    BYTE VolumeToMidi(long lVolume);
    static long m_lMIDIToDB[128];   // Array for converting MIDI to centibel volume.
    static long m_lDBToMIDI[97];    // For converting volume to MIDI.
    long                m_lMergeTotal;   // Total for all parameters in the list, but not including m_lData.
    long                m_lZeroIndexData;    // Default (no index) data.
};

// structure to hold a single ChannelMap
class CChannelMap
{
public:
    void                Clear();            // Completely clears and resets structure. 
    void                Reset(BOOL fVolumeAndPanToo); // Clears just the midi controllers.
    CParamMerger        m_VolumeMerger;     // Set of volumes to merge.
    CParamMerger        m_ExpressionMerger; // Set of expression controllers to merge.
    CParamMerger        m_TransposeMerger;  // Set of transpositions to merge.
    CParamMerger        m_PitchbendMerger;  // Set of pitchbends to merge.
    CParamMerger        m_PanMerger;        // Set of pans to merge.
    CParamMerger        m_FilterMerger;     // Set of filters to merge.
    CParamMerger        m_ModWheelMerger;   // Set of mod wheel controls to merge.
    CParamMerger        m_ReverbMerger;     // Set of reverb levels to merge.
    CParamMerger        m_ChorusMerger;     // Set of chorus levels to merge.
    DWORD               dwPortIndex;        // index into the PortTable
    DWORD               dwGroup;            // group number of the port
    DWORD               dwMChannel;         // channel number in the group
    short               nTranspose;         // amount to transpose
    WORD                wFlags;             // CMAP_X flags
} ;

#define CMAP_FREE       (WORD) 1        // This channel is currently not in use.
#define CMAP_STATIC     (WORD) 2        // This channel is in use as a regular, static pchannel.
#define CMAP_VIRTUAL    (WORD) 4        // This channel is in use for a dynamic, virtual pchannel.

// structure used to hold a PChannelMap block of 16.
#define PCHANNEL_BLOCKSIZE  16

class CChannelBlock : public AListItem
{
public:
    CChannelBlock* GetNext() { return (CChannelBlock*)AListItem::GetNext();}
    void Init(DWORD dwPChannelStart, DWORD dwPortIndex, DWORD dwGroup, WORD wFlags);
    DWORD               m_dwPChannelStart;  // first PChannel index
    CChannelMap         m_aChannelMap[PCHANNEL_BLOCKSIZE];
    DWORD               m_dwFreeChannels;   // Number of channels currently free.
    DWORD               m_dwPortIndex;      // Port id, if this is completely assigned to one port.
};

class CChannelBlockList : public AList
{
public:
    void Clear();
    void AddHead(CChannelBlock* pChannelBlock) { AList::AddHead((AListItem*)pChannelBlock);}
    CChannelBlock* GetHead(){return (CChannelBlock*)AList::GetHead();}
    CChannelBlock* RemoveHead() {return (CChannelBlock *) AList::RemoveHead();}
    void Remove(CChannelBlock* pChannelBlock){AList::Remove((AListItem*)pChannelBlock);}
    void AddTail(CChannelBlock* pChannelBlock){AList::AddTail((AListItem*)pChannelBlock);}
};

// structure to hold a global GUID and its data
typedef struct GlobalData
{
    ~GlobalData()
    {
        if( pData )
        {
            delete [] pData;
        }
    }
    struct GlobalData*  pNext;
    GUID    guidType;
    void*   pData;
    DWORD   dwSize;
} GlobalData;

// structure to hold internal tempo message with relative tempo
typedef struct DMInternalTempo
{
    /* begin PRIV_PART */
    PRIV_PART
    /* end PRIV_PART */
    DMUS_TEMPO_PMSG tempoPMsg;
    float   fltRelTempo; // the current relative tempo, from .5 to 2
} DMInternalTempo;

/*  Integer constants for defining each segstate queue */

#define SQ_PRI_WAIT     0   
#define SQ_CON_WAIT     1
#define SQ_SEC_WAIT     2
#define SQ_PRI_PLAY     3   
#define SQ_CON_PLAY     4
#define SQ_SEC_PLAY     5
#define SQ_PRI_DONE     6
#define SQ_CON_DONE     7
#define SQ_SEC_DONE     8
#define SQ_COUNT        9

#define IsPriQueue( dwCount ) ((dwCount % 3) == 0)
#define IsConQueue( dwCount ) ((dwCount % 3) == 1)
#define IsSecQueue( dwCount ) ((dwCount % 3) == 2)
#define IsWaitQueue( dwCount ) (dwCount <= SQ_SEC_WAIT)
#define IsPlayQueue( dwCount ) ((dwCount >= SQ_PRI_PLAY) && (dwCount <= SQ_SEC_PLAY))
#define IsDoneQueue( dwCount ) (dwCount >= SQ_PRI_DONE)
 


DEFINE_GUID(IID_CPerformance, 0xade66ea2, 0xe1c5, 0x4552, 0x85, 0x27, 0x1e, 0xef, 0xa5, 0xa, 0xfd, 0x7b);

class CSong;

#define FLUSH_LEAVE_ON      1   
#define FLUSH_ON_REPEAT     2   // Indicates this invalidation occured because of segment loop.


// class CPerformance
class CPerformance : 
    public IDirectMusicPerformance8,
    public IDirectMusicTool,
    public IDirectMusicGraph,
    public IDirectMusicPerformanceStats,
    public IDirectMusicPerformanceP,
    public IDirectMusicSetParamHook
{
    friend class CAudioPath;
    friend class CSegState;
    friend class CBufferManager;

public:
    CPerformance();
    ~CPerformance();

public:
// IUnknown
    STDMETHODIMP QueryInterface(const IID &iid, void **ppv);
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();

    // IDirectMusicPerformance
    STDMETHODIMP Init(IDirectMusic** ppDirectMusic,LPDIRECTSOUND pDSound,HWND hWnd );
    STDMETHODIMP PlaySegment(IDirectMusicSegment *pSegment,DWORD dwFlags,
        __int64 i64StartTime,IDirectMusicSegmentState **ppSegmentState);
    STDMETHODIMP Stop(IDirectMusicSegment *pSegment,
        IDirectMusicSegmentState *pSegmentState,MUSIC_TIME mtTime,DWORD dwFlags);
    STDMETHODIMP GetSegmentState(IDirectMusicSegmentState **ppSegmentState,MUSIC_TIME mtTime);
    STDMETHODIMP SetPrepareTime(DWORD dwMilliSeconds);
    STDMETHODIMP GetPrepareTime(DWORD* pdwMilliSeconds);
    STDMETHODIMP SetBumperLength(DWORD dwMilliSeconds);
    STDMETHODIMP GetBumperLength(DWORD* pdwMilliSeconds);
    STDMETHODIMP SendPMsg(DMUS_PMSG *pPMsg);
    STDMETHODIMP MusicToReferenceTime(MUSIC_TIME mtTime,REFERENCE_TIME *prtTime);
    STDMETHODIMP ReferenceToMusicTime(REFERENCE_TIME rtTime,MUSIC_TIME *pmtTime);
    STDMETHODIMP IsPlaying(IDirectMusicSegment *pSegment,IDirectMusicSegmentState *pSegState);
    STDMETHODIMP GetTime(REFERENCE_TIME *prtNow,MUSIC_TIME  *pmtNow);
    STDMETHODIMP AllocPMsg(ULONG cb,DMUS_PMSG** ppPMsg);
    STDMETHODIMP FreePMsg(DMUS_PMSG* pPMsg);
    STDMETHODIMP SetNotificationHandle(HANDLE hNotificationEvent,REFERENCE_TIME rtMinimum);
    STDMETHODIMP GetNotificationPMsg(DMUS_NOTIFICATION_PMSG** ppNotificationPMsg);
    STDMETHODIMP AddNotificationType(REFGUID rguidNotification);
    STDMETHODIMP RemoveNotificationType(REFGUID rguidNotification);
    STDMETHODIMP GetGraph(IDirectMusicGraph** ppGraph);
    STDMETHODIMP SetGraph(IDirectMusicGraph* pGraph);
    STDMETHODIMP AddPort(IDirectMusicPort* pPort);
    STDMETHODIMP RemovePort(IDirectMusicPort* pPort);
    STDMETHODIMP AssignPChannelBlock(DWORD dwBlockNum,IDirectMusicPort* pPort,DWORD dwGroup);
    STDMETHODIMP AssignPChannel(DWORD dwPChannel,IDirectMusicPort* pPort,DWORD dwGroup,DWORD dwMChannel);
    STDMETHODIMP PChannelInfo(DWORD dwPChannel,IDirectMusicPort** ppPort,DWORD* pdwGroup,DWORD* pdwMChannel);
    STDMETHODIMP DownloadInstrument(IDirectMusicInstrument* pInst,DWORD dwPChannel, 
                IDirectMusicDownloadedInstrument**,DMUS_NOTERANGE* pNoteRanges,
                DWORD dwNumNoteRanges,IDirectMusicPort**,DWORD*,DWORD*);
    STDMETHODIMP Invalidate(MUSIC_TIME mtTime,DWORD dwFlags);
    STDMETHODIMP GetParam(REFGUID rguidDataType,DWORD dwGroupBits,DWORD dwIndex, 
                MUSIC_TIME mtTime,MUSIC_TIME* pmtNext,void* pData); 
    STDMETHODIMP SetParam(REFGUID rguidDataType,DWORD dwGroupBits,DWORD dwIndex, 
                MUSIC_TIME mtTime,void* pData);
    STDMETHODIMP GetGlobalParam(REFGUID rguidType,void* pData,DWORD dwSize);
    STDMETHODIMP SetGlobalParam(REFGUID rguidType,void* pData,DWORD dwSize);
    STDMETHODIMP GetLatencyTime(REFERENCE_TIME* prtTime);
    STDMETHODIMP GetQueueTime(REFERENCE_TIME* prtTime);
    STDMETHODIMP AdjustTime(REFERENCE_TIME rtAmount);
    STDMETHODIMP CloseDown(void);
    STDMETHODIMP GetResolvedTime(REFERENCE_TIME rtTime,REFERENCE_TIME* prtResolved,DWORD dwFlags);
    STDMETHODIMP MIDIToMusic(BYTE bMIDIValue,DMUS_CHORD_KEY* pChord,
                BYTE bPlayMode,BYTE bChordLevel,WORD *pwMusicValue);
    STDMETHODIMP MusicToMIDI(WORD wMusicValue,DMUS_CHORD_KEY* pChord,
                BYTE bPlayMode,BYTE bChordLevel,BYTE *pbMIDIValue);
    STDMETHODIMP TimeToRhythm(MUSIC_TIME mtTime,DMUS_TIMESIGNATURE *pTimeSig,
                WORD *pwMeasure,BYTE *pbBeat,BYTE *pbGrid,short *pnOffset);
    STDMETHODIMP RhythmToTime(WORD wMeasure,BYTE bBeat,BYTE bGrid,
                short nOffset,DMUS_TIMESIGNATURE *pTimeSig,MUSIC_TIME *pmtTime);   
    //  IDirectMusicPerformance8 
    STDMETHODIMP InitAudio(IDirectMusic** ppDirectMusic,
                           IDirectSound** ppDirectSound,
                           HWND hWnd,
                           DWORD dwDefaultPathType,
                           DWORD dwPChannelCount,
                           DWORD dwFlags,                          
                           DMUS_AUDIOPARAMS *pParams);
    STDMETHODIMP PlaySegmentEx(IUnknown* pSource, 
                    WCHAR *pwzSegmentName,
                    IUnknown* pTransition,
                    DWORD dwFlags, 
                    __int64 i64StartTime, 
                    IDirectMusicSegmentState** ppSegmentState,
                    IUnknown *pFrom,
                    IUnknown *pAudioPath); 
    STDMETHODIMP StopEx(IUnknown *pObjectToStop,__int64 i64StopTime,DWORD dwFlags) ;
    STDMETHODIMP ClonePMsg(DMUS_PMSG* pSourcePMSG,DMUS_PMSG** ppCopyPMSG) ;
    STDMETHODIMP CreateAudioPath( IUnknown *pSourceConfig, BOOL fActivate, 
                                           IDirectMusicAudioPath **ppNewPath);
    STDMETHODIMP CreateStandardAudioPath(DWORD dwType, DWORD dwPChannelCount, BOOL fActivate, 
                                           IDirectMusicAudioPath **ppNewPath);    
    STDMETHODIMP SetDefaultAudioPath(IDirectMusicAudioPath *pAudioPath) ;
    STDMETHODIMP GetDefaultAudioPath(IDirectMusicAudioPath **pAudioPath) ;
    STDMETHODIMP GetParamEx(REFGUID rguidType,
                    DWORD dwTrackID,
                    DWORD dwGroupBits,
                    DWORD dwIndex,
                    MUSIC_TIME mtTime,
                    MUSIC_TIME* pmtNext,
                    void* pParam); 

// IDirectMusicTool
    STDMETHODIMP Init(IDirectMusicGraph* pGraph);
    STDMETHODIMP ProcessPMsg(IDirectMusicPerformance* pPerf,DMUS_PMSG* pPMsg);
    STDMETHODIMP Flush(IDirectMusicPerformance* pPerf,DMUS_PMSG* pPMsg,REFERENCE_TIME mtTime);
    STDMETHODIMP GetMsgDeliveryType(DWORD*);
    STDMETHODIMP GetMediaTypeArraySize(DWORD*);
    STDMETHODIMP GetMediaTypes(DWORD**,DWORD);

// IDirectMusicGraph
    STDMETHODIMP Shutdown();
    STDMETHODIMP InsertTool(IDirectMusicTool *pTool,DWORD *pdwPChannels,DWORD cPChannels,LONG lIndex);
    STDMETHODIMP GetTool(DWORD,IDirectMusicTool**);
    STDMETHODIMP RemoveTool(IDirectMusicTool*);
    STDMETHODIMP StampPMsg( DMUS_PMSG* pPMsg );
// IDirectMusicPerformanceStats 
    STDMETHODIMP TraceAllSegments() ;
    STDMETHODIMP CreateSegstateList(DMUS_SEGSTATEDATA ** ppList) ;     
    STDMETHODIMP FreeSegstateList(DMUS_SEGSTATEDATA * pList) ;     
// IDirectMusicPerformanceP
    STDMETHODIMP GetPortAndFlags(DWORD dwPChannel,IDirectMusicPort **ppPort,DWORD * pdwFlags);
// IDirectMusicSetParamHook 
    STDMETHODIMP SetParamHook(IDirectMusicParamHook *pIHook); 

// Access from segstate, audiopath and segment...
    HRESULT GetGraphInternal(IDirectMusicGraph** ppGraph);
    HRESULT FlushVirtualTrack(DWORD dwId,MUSIC_TIME mtTime, DWORD dwFlushFlags);
    HRESULT GetControlSegTime(MUSIC_TIME mtTime,MUSIC_TIME* pmtNextSeg);
    HRESULT GetPriSegTime(MUSIC_TIME mtTime,MUSIC_TIME* pmtNextSeg);
    HRESULT GetPathPort(CPortConfig *pConfig);
    void RemoveUnusedPorts();
    DWORD GetPortID(IDirectMusicPort * pPort);
    HRESULT AddPort(IDirectMusicPort* pPort,GUID *pguidPortID,
        DMUS_PORTPARAMS8 *pParams,DWORD *pdwPortID);
private:
    // private member functions
    void Init();
    friend DWORD WINAPI _Transport(LPVOID);
    friend DWORD WINAPI _Realtime(LPVOID);   
    HRESULT CreateThreads();
    HRESULT AllocPMsg(ULONG cb,PRIV_PMSG** ppPMsg);
    HRESULT FreePMsg(PRIV_PMSG* pPMsg);
    inline bool SendShortMsg(IDirectMusicBuffer* pBuffer,
                               IDirectMusicPort* pPort,DWORD dwMsg,
                               REFERENCE_TIME rt, DWORD dwGroup);
    HRESULT PackNote(DMUS_PMSG* pPMsg,REFERENCE_TIME rt );
    HRESULT PackCurve(DMUS_PMSG* pPMsg,REFERENCE_TIME rt );
    HRESULT PackMidi(DMUS_PMSG* pPMsg,REFERENCE_TIME rt );
    HRESULT PackSysEx(DMUS_PMSG* pPMsg,REFERENCE_TIME rt );
    HRESULT PackPatch(DMUS_PMSG* pPMsg,REFERENCE_TIME rt );
    HRESULT PackWave(DMUS_PMSG* pPMsg,REFERENCE_TIME rt );
    void SendBuffers();
    void Realtime();
    void Transport();
    void ProcessEarlyPMsgs();
    PRIV_PMSG *GetNextPMsg();
    REFERENCE_TIME GetTime();
    REFERENCE_TIME GetLatency();
    REFERENCE_TIME GetBestSegLatency( CSegState* pSeg );
    void PrepSegToPlay(CSegState *pSegState, bool fQueue = false);
    void ManageControllingTracks();
    void PerformSegStNode(DWORD dwList,CSegState* pSegStNode);
    void AddEventToTempoMap( PRIV_PMSG* pPMsg );
    void FlushMainEventQueues( DWORD, MUSIC_TIME mtFlush,  MUSIC_TIME mtFlushUnresolved, DWORD dwFlushFlags); // flush all events in all queues.
    void FlushEventQueue( DWORD dwId,CPMsgQueue *pQueue, REFERENCE_TIME rtFlush, REFERENCE_TIME rtFlushUnresolved, DWORD dwFlushFlags );
    void ClearMusicStoppedNotification();
    HRESULT PlayOneSegment(
        CSegment* pSegment, 
        DWORD dwFlags, 
        __int64 i64StartTime, 
        CSegState **ppSegState,
        CAudioPath *pAudioPath);
    HRESULT PlaySegmentInternal( CSegment* pSegment, 
        CSong * pSong,
        WCHAR *pwzSegmentName,
        CSegment* pTransition,
        DWORD dwFlags, 
        __int64 i64StartTime, 
        IDirectMusicSegmentState** ppSegmentState,
        IUnknown *pFrom,
        CAudioPath *pAudioPath);
    CSegState *GetSegmentForTransition(DWORD dwFlags,MUSIC_TIME mtTime, IUnknown *pFrom);
    void QueuePrimarySegment( CSegState* pSeg );
    void QueueSecondarySegment( CSegState* pSeg );
    void CalculateSegmentStartTime( CSegState* pSeg );
    MUSIC_TIME ResolveTime( MUSIC_TIME mtTime, DWORD dwResolution, MUSIC_TIME *pmtIntervalSize );
    void GetTimeSig( MUSIC_TIME mtTime, DMUS_TIMESIG_PMSG* pTimeSig );
    void SyncTimeSig( CSegState *pSegState );
    void DequeueAllSegments();
    void AddToTempoMap( double dblTempo, MUSIC_TIME mtTime, REFERENCE_TIME rtTime );
    void UpdateTempoMap(MUSIC_TIME mtStart, bool fFirst, CSegState *pSegState, bool fAllDeltas = true);
    void IncrementTempoMap();
    void RecalcTempoMap(CSegState *pSegState, MUSIC_TIME mtOffset, bool fAllDeltas = true);
    void RevalidateRefTimes( CPMsgQueue * pList, MUSIC_TIME mtTime );
    void AddNotificationTypeToAllSegments( REFGUID rguidNotification );
    void RemoveNotificationTypeFromAllSegments( REFGUID rguidNotification );
    CNotificationItem* FindNotification( REFGUID rguidNotification );
    HRESULT GetPort(DWORD dwPortID, IDirectMusicPort **ppPort);
    HRESULT AllocVChannelBlock(DWORD dwPortID,DWORD dwGroup);
    HRESULT AllocVChannel(DWORD dwPortID, DWORD dwDrumFlags, DWORD *pdwPChannel, DWORD *pdwGroup,DWORD *pdwMChannel);
    HRESULT ReleasePChannel(DWORD dwPChannel);
    CChannelMap * GetPChannelMap( DWORD dwPChannel );
    HRESULT AssignPChannelBlock(DWORD dwBlockNum,DWORD dwPortIndex,DWORD dwGroup,WORD wFlags);
    HRESULT AssignPChannel(DWORD dwPChannel,DWORD dwPortIndex,DWORD dwGroup,DWORD dwMChannel,WORD wFlags);
    HRESULT PChannelIndex( DWORD dwPChannel, DWORD* pdwIndex,
                DWORD* pdwGroup, DWORD* pdwMChannel, short* pnTranspose = NULL );
    void GenerateNotification( DWORD dwNotification, MUSIC_TIME mtTime, IDirectMusicSegmentState* pSegSt );
    CSegState* GetPrimarySegmentAtTime( MUSIC_TIME mtTime );
    void ResetAllControllers( REFERENCE_TIME rtTime);
    void ResetAllControllers(CChannelMap* pChannelMap, REFERENCE_TIME rtTime, bool fGMReset);
    void DoStop( CSegState* pSegState, MUSIC_TIME mtTime, BOOL fInvalidate );
    void DoStop( CSegment* pSeg, MUSIC_TIME mtTime, BOOL fInvalidate );
    HRESULT GetChordNotificationStatus(
		DMUS_NOTE_PMSG* pNote, 
		DWORD dwTrackGroup, 
		REFERENCE_TIME rtTime, 
		DMUS_PMSG** ppNew);
	void OnChordUpdateEventQueues( DMUS_NOTIFICATION_PMSG* pNotify);
	void OnChordUpdateEventQueue( DMUS_NOTIFICATION_PMSG* pNotify, CPMsgQueue *pQueue, REFERENCE_TIME rtFlush );
#ifdef DBG
    void TraceAllChannelMaps();
#endif

    // private member variables
    IDirectMusic8*      m_pDirectMusic;
    IDirectSound8*      m_pDirectSound;
    IReferenceClock*    m_pClock;
    IDirectMusicGraph*  m_pGraph;
    CAudioPath *        m_pDefaultAudioPath; // Default audio path.
    DWORD               m_dwNumPorts; // the number of ports
    PortTable*          m_pPortTable; // array of ports, number equals m_dwNumPorts
    CChannelBlockList   m_ChannelBlockList; // List of pchannel maps, in blocks of 16
    CChannelBlockList   m_FreeChannelBlockList; // List of pchannel maps that are no longer in use
    CSegStateList       m_SegStateQueues[SQ_COUNT]; // Lists of all active segment states.
    CSegStateList       m_ShutDownQueue;    // List of segments that are pending shutdown.

    CAudioPathList      m_AudioPathList; // List of all active audio paths in this performance.
    CBufferManager      m_BufferManager; // List of all buffers currently in use.
    DMUS_AUDIOPARAMS    m_AudioParams;  // Initial requirements, as set in InitAudio, by app. 

    HANDLE      m_hNotification; // notification handle set in SetNotificationHandle
    REFERENCE_TIME  m_rtNotificationDiscard; // minimum time to hold onto a notification message
    CNotificationList   m_NotificationList;
    GlobalData* m_pGlobalData; // list of global data structs

    DWORD       m_dwAudioPathMode;  // 0 for not yet set, 1 for old methods, 2 for using AudioPaths.
    BOOL        m_fInTransportThread; // This is used to signal that the transport thread
                                     // is active and the realtime thread should hold
                                     // off on processing the early queue.
	BOOL		m_fInTrackPlay;		// This is used to signal that a track is in the process of
									// generating events. These will have the PRIV_FLAG_TRACK flag set.
    CPMsgQueue m_EarlyQueue;        // List of PMsgs that play immediately.
    CPMsgQueue m_NearTimeQueue;     // List of PMsgs that play a little early.
    CPMsgQueue m_OnTimeQueue;       // List of PMsgs that play exactly when due.
    CPMsgQueue m_TempoMap;          // List of tempo changes.
    CPMsgQueue m_OldTempoMap;       // List of old tempo changes.
    CPMsgQueue m_NotificationQueue; // List of notification messages.
    CPMsgQueue m_TimeSigQueue;      // List of time signature changes.

    // cache of allocated pmsg's
#define PERF_PMSG_CB_MIN 48
#define PERF_PMSG_CB_MAX 101
    PRIV_PMSG* m_apPMsgCache[ PERF_PMSG_CB_MAX - PERF_PMSG_CB_MIN ];

    DWORD            m_dwInitCS;
    CRITICAL_SECTION m_PMsgCacheCrSec;
    CRITICAL_SECTION m_SegmentCrSec;
    CRITICAL_SECTION m_PipelineCrSec;   // For all the CPMsgQueues
    CRITICAL_SECTION m_PChannelInfoCrSec;
    CRITICAL_SECTION m_GlobalDataCrSec;
    CRITICAL_SECTION m_RealtimeCrSec;
    CRITICAL_SECTION m_MainCrSec;

    HANDLE          m_hTransport;       // to wake up the Transport thread when needed
    HANDLE          m_hRealtime;
    HANDLE          m_hTransportThread; // to kill the Transport thread if needed
    HANDLE          m_hRealtimeThread;

    REFERENCE_TIME  m_rtStart;          // time when this performance started
    REFERENCE_TIME  m_rtAdjust;         // adjustment time to compensate for e.g. smpte drift
    REFERENCE_TIME  m_rtHighestPackedNoteOn; // highest time of packed note on
    REFERENCE_TIME  m_rtEarliestStartTime; // Time of last Stop(0,0,0). New segment can not start before this.
    REFERENCE_TIME  m_rtQueuePosition;  // the highest time a message has been packed, or the latency + m_rtBumperLength, whichever is greater
    REFERENCE_TIME  m_rtNextWakeUp;     // Next time the pipeline thread needs to wake up to deliver a message.
    REFERENCE_TIME  m_rtBumperLength;   // Distance ahead of latency clock to send events down to synth.
    MUSIC_TIME      m_mtTransported;    // the highest time transported
    MUSIC_TIME      m_mtPlayTo;         // the time to play to on the next transport cycle
    MUSIC_TIME      m_mtTempoCursor;    // Tempo map has been generated up to this point.
    DWORD           m_dwPrepareTime;    // time ahead, in milliseconds, to transport
    DWORD           m_dwBumperLength;   // Millisecond version of m_rtBumperLength. 
    long            m_lMasterVolume;    // master volume.
    float           m_fltRelTempo;      // relative tempo, can be from 0 to 200
    long            m_cRef;
    WORD            m_wRollOverCount;   // tracks when timeGetTime rolls over
    DWORD           m_dwTransportThreadID;  // transport thread id
    DWORD           m_dwRealtimeThreadID;
    BOOL            m_fKillThread;      // signal to transport thread to die
    BOOL            m_fKillRealtimeThread;
    BOOL            m_fPlaying;
    BOOL            m_fMusicStopped;
    BOOL            m_fTempoChanged;    // When a tempo change occurs, refresh transport so clock time tracks don't get clobbered.

    IUnknown *      m_pUnkDispatch;     // holds the controlling unknown of the scripting object that implements IDispatch

    DWORD           m_dwVersion;        // Version number, indicating DX6, DX7, or DX8. Determined by which interface requested.
    IDirectMusicSegmentState * m_pGetParamSegmentState; // Set prior to playing a segment, so GetParam() can know which segment called it.
    DWORD           m_dwGetParamFlags;  // Set prior to playing a segment track, so GetParam() can know how to search for the parameter.
    IDirectMusicParamHook * m_pParamHook;
    bool            m_fReleasedInTransport; // The performance had its final release in the transport thread
    bool            m_fReleasedInRealtime; // The performance had its final release in the realtime thread
};

#endif // _DMPERF_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\XDmime\dmprfdll.cpp ===
//
// dmprfdll.cpp
// 
// Copyright (c) 1997-1999 Microsoft Corporation
//
// Note: Dll entry points as well as class factory implementations.
//

// READ THIS!!!!!!!!!!!!!!!!!!!!!!!!!!!
//
// 4530: C++ exception handler used, but unwind semantics are not enabled. Specify -GX
//
// We disable this because we use exceptions and do *not* specify -GX (USE_NATIVE_EH in
// sources).
//
// The one place we use exceptions is around construction of objects that call 
// InitializeCriticalSection. We guarantee that it is safe to use in this case with
// the restriction given by not using -GX (automatic objects in the call chain between
// throw and handler are not destructed). Turning on -GX buys us nothing but +10% to code
// size because of the unwind code.
//
// Any other use of exceptions must follow these restrictions or -GX must be turned on.
//
// READ THIS!!!!!!!!!!!!!!!!!!!!!!!!!!!
//
#pragma warning(disable:4530)

#include <objbase.h>
#include <initguid.h>
#include <mmsystem.h>
#include <dsoundp.h>

#include "debug.h"
#define ASSERT  assert 
#include "debug.h"
#include "dmprfdll.h"
#include "dmperf.h"
#include "dmsegobj.h"
#include "song.h"
#include "seqtrack.h"
#include "sysextrk.h"
#include "tempotrk.h"
#include "tsigtrk.h"
#include "marktrk.h"
#include "wavtrack.h"
#include "segtrtrk.h"
#include "lyrictrk.h"
#include "ParamTrk.h"
#include "dmgraph.h"
#include "dmusicc.h"
#include "dmusici.h"
#include "dmusicf.h"
#include "oledll.h"
#include "dmstylep.h"
#include "dmbndtrk.h"
#include "dmstrm.h"
#include "Validate.h"
#include "dmksctrl.h"
#include "dmscriptautguids.h"
#include "audpath.h"
#include "dswave.h"
#include "dsoundp.h"            // For IDirectSoundPrivate
#include "..\shared\xguids.h"

bool g_fInitCS = false;
CRITICAL_SECTION g_CritSec;


//////////////////////////////////////////////////////////////////////
// Globals

// Dll's hModule
//
HMODULE g_hModule = NULL;

// Count of active components and class factory server locks
//
long g_cComponent = 0;
long g_cLock = 0;

// Flags DMI_F_xxx from dmusicp.h
//
DWORD g_fFlags;

static char const g_szDoEmulation[] = "DoEmulation";

// CClassFactory::QueryInterface
//
HRESULT __stdcall
CClassFactory::QueryInterface(const IID &iid,
                                    void **ppv)
{
    if (iid == IID_IUnknown || iid == IID_IClassFactory) {
        *ppv = static_cast<IClassFactory*>(this);
    } else {
        *ppv = NULL;
        return E_NOINTERFACE;
    }

    reinterpret_cast<IUnknown*>(*ppv)->AddRef();
    return S_OK;
}

CClassFactory::CClassFactory(DWORD dwClassType)

{
    m_cRef = 1;
    m_dwClassType = dwClassType;
    InterlockedIncrement(&g_cLock);
}

CClassFactory::~CClassFactory()

{
    InterlockedDecrement(&g_cLock);
}

// CClassFactory::AddRef
//
ULONG __stdcall
CClassFactory::AddRef()
{
    return InterlockedIncrement(&m_cRef);
}

// CClassFactory::Release
//
ULONG __stdcall
CClassFactory::Release()
{
    if (!InterlockedDecrement(&m_cRef)) {
        delete this;
        return 0;
    }

    return m_cRef;
}

// CClassFactory::CreateInstance
//
//
HRESULT __stdcall
CClassFactory::CreateInstance(IUnknown* pUnknownOuter,
                                    const IID& iid,
                                    void** ppv)
{
    HRESULT hr;

    if (pUnknownOuter) {
         return CLASS_E_NOAGGREGATION;
    }

    switch (m_dwClassType)
    {
    case CLASS_PERFORMANCE:
        {
            CPerformance *pInst;

            try
            {
                pInst = new CPerformance;
            }
            catch( ... )
            {
                hr = E_OUTOFMEMORY;
                break;
            }

            if (pInst == NULL) {
                hr = E_OUTOFMEMORY;
                break;
            }

            hr = pInst->QueryInterface(iid, ppv);
            pInst->Release();
        }
        break;
    case CLASS_GRAPH:
        {
            CGraph *pInst = new CGraph;
            if (pInst == NULL) {
                hr = E_OUTOFMEMORY;
                break;
            }

            hr = pInst->QueryInterface(iid, ppv);
            pInst->Release();
        }
        break;
    case CLASS_SEGMENT:
        {
            CSegment *pInst = new CSegment;
            if (pInst == NULL) {
                hr = E_OUTOFMEMORY;
                break;
            }
            // The segment is initialized with a ref count of 0, so QI will set it to 1.
            hr = pInst->QueryInterface(iid, ppv);
        }
        break;
    case CLASS_SONG:
        {
            CSong *pInst = new CSong;
            if (pInst == NULL) {
                hr = E_OUTOFMEMORY;
                break;
            }

            hr = pInst->QueryInterface(iid, ppv);
            pInst->Release();
        }
        break;
    case CLASS_AUDIOPATH:
        {
            CAudioPathConfig *pInst;

            try
            {
                pInst = new CAudioPathConfig;
            }
            catch( ... )
            {
                hr = E_OUTOFMEMORY;
                break;
            }

            if (pInst == NULL) {
                hr = E_OUTOFMEMORY;
                break;
            }

            hr = pInst->QueryInterface(iid, ppv);
            pInst->Release();
        }
        break;
    case CLASS_SEQTRACK:
        {
            CSeqTrack *pInst;

            try
            {
                pInst = new CSeqTrack;
            }
            catch( ... )
            {
                hr = E_OUTOFMEMORY;
                break;
            }

            if (pInst == NULL) {
                hr = E_OUTOFMEMORY;
                break;
            }

            hr = pInst->QueryInterface(iid, ppv);
            pInst->Release();
        }
        break;
    case CLASS_SYSEXTRACK:
        {
            CSysExTrack *pInst;

            try
            {
                pInst = new CSysExTrack;
            }
            catch( ... )
            {
                hr = E_OUTOFMEMORY;
                break;
            }
            if (pInst == NULL) {
                hr = E_OUTOFMEMORY;
                break;
            }

            hr = pInst->QueryInterface(iid, ppv);
            pInst->Release();
        }
        break;
    case CLASS_TEMPOTRACK:
        {
            CTempoTrack *pInst;

            try
            {
                pInst = new CTempoTrack;
            }
            catch( ... )
            {
                hr = E_OUTOFMEMORY;
                break;
            }

            if (pInst == NULL) {
                hr = E_OUTOFMEMORY;
                break;
            }

            hr = pInst->QueryInterface(iid, ppv);
            pInst->Release();
        }
        break;
    case CLASS_TIMESIGTRACK:
        {
            CTimeSigTrack *pInst;
    
            try
            {
                pInst = new CTimeSigTrack;
            }
            catch( ... )
            {
                hr = E_OUTOFMEMORY;
                break;
            }

            if (pInst == NULL) {
                hr = E_OUTOFMEMORY;
                break;
            }

            hr = pInst->QueryInterface(iid, ppv);
            pInst->Release();
        }
        break;
    case CLASS_MARKERTRACK:
        {
            CMarkerTrack *pInst;
    
            try
            {
                pInst = new CMarkerTrack;
            }
            catch( ... )
            {
                hr = E_OUTOFMEMORY;
                break;
            }

            if (pInst == NULL) {
                hr = E_OUTOFMEMORY;
                break;
            }
            hr = pInst->QueryInterface(iid, ppv);
            pInst->Release();
        }
        break;
    case CLASS_WAVETRACK:
        {
            CWavTrack *pInst;
    
            try
            {
                pInst = new CWavTrack;
            }
            catch( ... )
            {
                hr = E_OUTOFMEMORY;
                break;
            }

            if (pInst == NULL) {
                hr = E_OUTOFMEMORY;
                break;
            }
            hr = pInst->QueryInterface(iid, ppv);
            pInst->Release();
        }
        break;
    case CLASS_TRIGGERTRACK:
        {
            try
            {
                hr = TrackHelpCreateInstance<CSegTriggerTrack>(pUnknownOuter, iid, ppv);
            }
            catch( ... )
            {
                hr = E_OUTOFMEMORY;
            }
        }
        break;
    case CLASS_LYRICSTRACK:
        {
            try
            {
                hr = TrackHelpCreateInstance<CLyricsTrack>(pUnknownOuter, iid, ppv);
            }
            catch( ... )
            {
                hr = E_OUTOFMEMORY;
            }
        }
        break;
    case CLASS_PARAMSTRACK:
        {
            try
            {
                hr = TrackHelpCreateInstance<CParamControlTrack>(pUnknownOuter, iid, ppv);
            }
            catch( ... )
            {
                hr = E_OUTOFMEMORY;
            }
        }
        break;
    case CLASS_SEGSTATE:
        {
            CSegState *pInst = new CSegState;
            if (pInst == NULL) {
                hr = E_OUTOFMEMORY;
                break;
            }

            hr = pInst->QueryInterface(iid, ppv);
            pInst->Release();
        }
    }
    return hr;
}

// CClassFactory::LockServer
//
HRESULT __stdcall
CClassFactory::LockServer(BOOL bLock)
{
    if (bLock) {
        InterlockedIncrement(&g_cLock);
    } else {
        InterlockedDecrement(&g_cLock);
    }

    return S_OK;
}


// Version information for our class
//
TCHAR g_szDMPerformanceFriendlyName[]    = TEXT("DirectMusicPerformance");
TCHAR g_szDMPerformanceVerIndProgID[]    = TEXT("Microsoft.DirectMusicPerformance");
TCHAR g_szDMPerformanceProgID[]          = TEXT("Microsoft.DirectMusicPerformance.1");

TCHAR g_szDMSegmentFriendlyName[]    = TEXT("DirectMusicSegment");
TCHAR g_szDMSegmentVerIndProgID[]    = TEXT("Microsoft.DirectMusicSegment");
TCHAR g_szDMSegmentProgID[]          = TEXT("Microsoft.DirectMusicSegment.1");

TCHAR g_szDMSegmentStateFriendlyName[]    = TEXT("DirectMusicSegmentState");
TCHAR g_szDMSegmentStateVerIndProgID[]    = TEXT("Microsoft.DirectMusicSegmentState");
TCHAR g_szDMSegmentStateProgID[]          = TEXT("Microsoft.DirectMusicSegmentState.1");

TCHAR g_szSongFriendlyName[]    = TEXT("DirectMusicSong");
TCHAR g_szSongVerIndProgID[]    = TEXT("Microsoft.DirectMusicSong");
TCHAR g_szSongProgID[]          = TEXT("Microsoft.DirectMusicSong.1");

TCHAR g_szAudioPathFriendlyName[]    = TEXT("DirectMusicAudioPath");
TCHAR g_szAudioPathVerIndProgID[]    = TEXT("Microsoft.DirectMusicAudioPath");
TCHAR g_szAudioPathProgID[]          = TEXT("Microsoft.DirectMusicAudioPath.1");

TCHAR g_szDMGraphFriendlyName[]    = TEXT("DirectMusicGraph");
TCHAR g_szDMGraphVerIndProgID[]    = TEXT("Microsoft.DirectMusicGraph");
TCHAR g_szDMGraphProgID[]          = TEXT("Microsoft.DirectMusicGraph.1");

TCHAR g_szDMSeqTrackFriendlyName[]    = TEXT("DirectMusicSeqTrack");
TCHAR g_szDMSeqTrackVerIndProgID[]    = TEXT("Microsoft.DirectMusicSeqTrack");
TCHAR g_szDMSeqTrackProgID[]          = TEXT("Microsoft.DirectMusicSeqTrack.1");

TCHAR g_szDMSysExTrackFriendlyName[]    = TEXT("DirectMusicSysExTrack");
TCHAR g_szDMSysExTrackVerIndProgID[]    = TEXT("Microsoft.DirectMusicSysExTrack");
TCHAR g_szDMSysExTrackProgID[]          = TEXT("Microsoft.DirectMusicSysExTrack.1");

TCHAR g_szDMTempoTrackFriendlyName[]    = TEXT("DirectMusicTempoTrack");
TCHAR g_szDMTempoTrackVerIndProgID[]    = TEXT("Microsoft.DirectMusicTempoTrack");
TCHAR g_szDMTempoTrackProgID[]          = TEXT("Microsoft.DirectMusicTempoTrack.1");

TCHAR g_szDMTimeSigTrackFriendlyName[]    = TEXT("DirectMusicTimeSigTrack");
TCHAR g_szDMTimeSigTrackVerIndProgID[]    = TEXT("Microsoft.DirectMusicTimeSigTrack");
TCHAR g_szDMTimeSigTrackProgID[]          = TEXT("Microsoft.DirectMusicTimeSigTrack.1");

TCHAR g_szMarkerTrackFriendlyName[]    = TEXT("DirectMusicMarkerTrack");
TCHAR g_szMarkerTrackVerIndProgID[]    = TEXT("Microsoft.DirectMusicMarkerTrack");
TCHAR g_szMarkerTrackProgID[]          = TEXT("Microsoft.DirectMusicMarkerTrack.1");

TCHAR g_szWaveTrackFriendlyName[]    = TEXT("DirectMusicWaveTrack");
TCHAR g_szWaveTrackVerIndProgID[]    = TEXT("Microsoft.DirectMusicWaveTrack");
TCHAR g_szWaveTrackProgID[]          = TEXT("Microsoft.DirectMusicWaveTrack.1");

TCHAR g_szSegTriggerTrackFriendlyName[]    = TEXT("DirectMusicSegTriggerTrack");
TCHAR g_szSegTriggerTrackVerIndProgID[]    = TEXT("Microsoft.DirectMusicSegTriggerTrack");
TCHAR g_szSegTriggerTrackProgID[]          = TEXT("Microsoft.DirectMusicSegTriggerTrack.1");

TCHAR g_szLyricsTrackFriendlyName[]    = TEXT("DirectMusicLyricsTrack");
TCHAR g_szLyricsTrackVerIndProgID[]    = TEXT("Microsoft.DirectMusicLyricsTrack");
TCHAR g_szLyricsTrackProgID[]          = TEXT("Microsoft.DirectMusicLyricsTrack.1");

TCHAR g_szParamControlTrackFriendlyName[]    = TEXT("DirectMusicParamControlTrack");
TCHAR g_szParamControlTrackVerIndProgID[]    = TEXT("Microsoft.DirectMusicParamControlTrack");
TCHAR g_szParamControlTrackProgID[]          = TEXT("Microsoft.DirectMusicParamControlTrack.1");

//////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////
// Standard calls needed to be an inproc server

//////////////////////////////////////////////////////////////////////
// DllCanUnloadNow

STDAPI DllCanUnloadNow()
{
    if (g_cComponent || g_cLock) {
        return S_FALSE;
    }

    return S_OK;
}

//////////////////////////////////////////////////////////////////////
// DllGetClassObject

STDAPI DllGetClassObject(const CLSID& clsid,
                         const IID& iid,
                         void** ppv)
{
    IUnknown* pIUnknown = NULL;
    DWORD dwTypeID = 0;

    if(clsid == CLSID_XDirectMusicPerformance)
    {
        dwTypeID = CLASS_PERFORMANCE;
    }
    else if(clsid == CLSID_XDirectMusicSegment) 
    {
        dwTypeID = CLASS_SEGMENT;
    }
    else if(clsid == CLSID_XDirectMusicSong) 
    {
        dwTypeID = CLASS_SONG;
    }
    else if(clsid == CLSID_XDirectMusicAudioPathConfig) 
    {
        dwTypeID = CLASS_AUDIOPATH;
    }
    else if(clsid == CLSID_XDirectMusicSeqTrack) 
    {
        dwTypeID = CLASS_SEQTRACK;
    }
    else if(clsid == CLSID_XDirectMusicGraph) 
    {
        dwTypeID = CLASS_GRAPH;
    }
    else if(clsid == CLSID_XDirectMusicSysExTrack) 
    {
        dwTypeID = CLASS_SYSEXTRACK;
    }
    else if(clsid == CLSID_XDirectMusicTempoTrack) 
    {
        dwTypeID = CLASS_TEMPOTRACK;
    }
    else if(clsid == CLSID_XDirectMusicTimeSigTrack) 
    {
        dwTypeID = CLASS_TIMESIGTRACK;
    }
    else if(clsid == CLSID_XDirectMusicMarkerTrack) 
    {
        dwTypeID = CLASS_MARKERTRACK;
    }
    else if(clsid == CLSID_XDirectMusicWaveTrack) 
    {
        dwTypeID = CLASS_WAVETRACK;
    }
    else if(clsid == CLSID_XDirectMusicSegmentTriggerTrack)
    {
        dwTypeID = CLASS_TRIGGERTRACK;
    }
    else if(clsid == CLSID_XDirectMusicLyricsTrack)
    {
        dwTypeID = CLASS_LYRICSTRACK;
    }
    else if(clsid == CLSID_XDirectMusicParamControlTrack)
    {
        dwTypeID = CLASS_PARAMSTRACK;
    }
    else if(clsid == CLSID_XDirectMusicSegmentState)
    {
        dwTypeID = CLASS_SEGSTATE;
    }
    else
    {
        return CLASS_E_CLASSNOTAVAILABLE;
    }
    pIUnknown = static_cast<IUnknown*> (new CClassFactory(dwTypeID));
    if(pIUnknown) 
    {
        HRESULT hr = pIUnknown->QueryInterface(iid, ppv);
        pIUnknown->Release();
        return hr;
    }
    return E_OUTOFMEMORY;
}

//////////////////////////////////////////////////////////////////////
// DllUnregisterServer

STDAPI DllUnregisterServer()
{
    UnregisterServer(CLSID_XDirectMusicPerformance,
                     g_szDMPerformanceFriendlyName,
                     g_szDMPerformanceVerIndProgID,
                     g_szDMPerformanceProgID);

    UnregisterServer(CLSID_XDirectMusicSegment,
                     g_szDMSegmentFriendlyName,
                     g_szDMSegmentVerIndProgID,
                     g_szDMSegmentProgID);

    UnregisterServer(CLSID_XDirectMusicSegmentState,
                     g_szDMSegmentStateFriendlyName,
                     g_szDMSegmentStateVerIndProgID,
                     g_szDMSegmentStateProgID);

    UnregisterServer(CLSID_XDirectMusicSong,
                     g_szSongFriendlyName,
                     g_szSongVerIndProgID,
                     g_szSongProgID);

    UnregisterServer(CLSID_XDirectMusicAudioPathConfig,
                     g_szAudioPathFriendlyName,
                     g_szAudioPathVerIndProgID,
                     g_szAudioPathProgID);
    
    UnregisterServer(CLSID_XDirectMusicGraph,
                     g_szDMGraphFriendlyName,
                     g_szDMGraphVerIndProgID,
                     g_szDMGraphProgID);

    UnregisterServer(CLSID_XDirectMusicSeqTrack,
                     g_szDMSeqTrackFriendlyName,
                     g_szDMSeqTrackVerIndProgID,
                     g_szDMSeqTrackProgID);

    UnregisterServer(CLSID_XDirectMusicSysExTrack,
                     g_szDMSysExTrackFriendlyName,
                     g_szDMSysExTrackVerIndProgID,
                     g_szDMSysExTrackProgID);

    UnregisterServer(CLSID_XDirectMusicTempoTrack,
                     g_szDMTempoTrackFriendlyName,
                     g_szDMTempoTrackVerIndProgID,
                     g_szDMTempoTrackProgID);

    UnregisterServer(CLSID_XDirectMusicTimeSigTrack,
                     g_szDMTimeSigTrackFriendlyName,
                     g_szDMTimeSigTrackVerIndProgID,
                     g_szDMTimeSigTrackProgID);

    UnregisterServer(CLSID_XDirectMusicMarkerTrack,
                     g_szMarkerTrackFriendlyName,
                     g_szMarkerTrackVerIndProgID,
                     g_szMarkerTrackProgID);

    UnregisterServer(CLSID_XDirectMusicWaveTrack,
                     g_szWaveTrackFriendlyName,
                     g_szWaveTrackVerIndProgID,
                     g_szWaveTrackProgID);

    UnregisterServer(CLSID_XDirectMusicSegmentTriggerTrack,
                     g_szSegTriggerTrackFriendlyName,
                     g_szSegTriggerTrackVerIndProgID,
                     g_szSegTriggerTrackProgID);

    UnregisterServer(CLSID_XDirectMusicLyricsTrack,
                     g_szLyricsTrackFriendlyName,
                     g_szLyricsTrackVerIndProgID,
                     g_szLyricsTrackProgID);

    UnregisterServer(CLSID_XDirectMusicParamControlTrack,
                     g_szParamControlTrackFriendlyName,
                     g_szParamControlTrackVerIndProgID,
                     g_szParamControlTrackProgID);

    return S_OK;
}

//////////////////////////////////////////////////////////////////////
// DllRegisterServer

STDAPI DllRegisterServer()
{
    RegisterServer(g_hModule,
                   CLSID_XDirectMusicPerformance,
                     g_szDMPerformanceFriendlyName,
                     g_szDMPerformanceVerIndProgID,
                     g_szDMPerformanceProgID);

    RegisterServer(g_hModule,
                   CLSID_XDirectMusicSegment,
                     g_szDMSegmentFriendlyName,
                     g_szDMSegmentVerIndProgID,
                     g_szDMSegmentProgID);

    RegisterServer(g_hModule,
                   CLSID_XDirectMusicSegmentState,
                     g_szDMSegmentStateFriendlyName,
                     g_szDMSegmentStateVerIndProgID,
                     g_szDMSegmentStateProgID);

    RegisterServer(g_hModule,
                   CLSID_XDirectMusicSong,
                     g_szSongFriendlyName,
                     g_szSongVerIndProgID,
                     g_szSongProgID);

    RegisterServer(g_hModule,
                   CLSID_XDirectMusicAudioPathConfig,
                     g_szAudioPathFriendlyName,
                     g_szAudioPathVerIndProgID,
                     g_szAudioPathProgID);

    RegisterServer(g_hModule,
                   CLSID_XDirectMusicGraph,
                     g_szDMGraphFriendlyName,
                     g_szDMGraphVerIndProgID,
                     g_szDMGraphProgID);

    RegisterServer(g_hModule,
                   CLSID_XDirectMusicSeqTrack,
                     g_szDMSeqTrackFriendlyName,
                     g_szDMSeqTrackVerIndProgID,
                     g_szDMSeqTrackProgID);

    RegisterServer(g_hModule,
                   CLSID_XDirectMusicSysExTrack,
                     g_szDMSysExTrackFriendlyName,
                     g_szDMSysExTrackVerIndProgID,
                     g_szDMSysExTrackProgID);

    RegisterServer(g_hModule,
                   CLSID_XDirectMusicTempoTrack,
                     g_szDMTempoTrackFriendlyName,
                     g_szDMTempoTrackVerIndProgID,
                     g_szDMTempoTrackProgID);

    RegisterServer(g_hModule,
                   CLSID_XDirectMusicTimeSigTrack,
                     g_szDMTimeSigTrackFriendlyName,
                     g_szDMTimeSigTrackVerIndProgID,
                     g_szDMTimeSigTrackProgID);
    RegisterServer(g_hModule,
                   CLSID_XDirectMusicMarkerTrack,
                     g_szMarkerTrackFriendlyName,
                     g_szMarkerTrackVerIndProgID,
                     g_szMarkerTrackProgID);
    RegisterServer(g_hModule,
                   CLSID_XDirectMusicWaveTrack,
                     g_szWaveTrackFriendlyName,
                     g_szWaveTrackVerIndProgID,
                     g_szWaveTrackProgID);
    RegisterServer(g_hModule,
                   CLSID_XDirectMusicSegmentTriggerTrack,
                     g_szSegTriggerTrackFriendlyName,
                     g_szSegTriggerTrackVerIndProgID,
                     g_szSegTriggerTrackProgID);
    RegisterServer(g_hModule,
                   CLSID_XDirectMusicLyricsTrack,
                     g_szLyricsTrackFriendlyName,
                     g_szLyricsTrackVerIndProgID,
                     g_szLyricsTrackProgID);
    RegisterServer(g_hModule,
                   CLSID_XDirectMusicParamControlTrack,
                     g_szParamControlTrackFriendlyName,
                     g_szParamControlTrackVerIndProgID,
                     g_szParamControlTrackProgID);
    return S_OK;
}

//////////////////////////////////////////////////////////////////////
// Standard Win32 DllMain

//////////////////////////////////////////////////////////////////////
// DllMain

#ifdef DBG
static char* aszReasons[] =
{
    "DLL_PROCESS_DETACH",
    "DLL_PROCESS_ATTACH",
    "DLL_THREAD_ATTACH",
    "DLL_THREAD_DETACH"
};
const DWORD nReasons = (sizeof(aszReasons) / sizeof(char*));
#endif

BOOL APIENTRY DllMain(HINSTANCE hModule,
                      DWORD dwReason,
                      void *lpReserved)
{
    static int nReferenceCount = 0;

#ifdef DBG
    if (dwReason < nReasons)
    {
        TraceI(0, "DllMain: %s\n", (LPSTR)aszReasons[dwReason]);
    }
    else
    {
        TraceI(0, "DllMain: Unknown dwReason <%u>\n", dwReason);
    }
#endif

    switch(dwReason)
    {
        case DLL_PROCESS_ATTACH:
            if (++nReferenceCount == 1)
            {
                g_fInitCS = false;
                try
                {
                    InitializeCriticalSection(&g_CritSec);
                    InitializeCriticalSection(&WaveItem::st_WaveListCritSect);
                }
                catch( ... )
                {
                    TraceI(0, "InitializeCriticalSection failed.\n");
                    return FALSE;
                }
                g_fInitCS = true;

                #ifdef DBG
                    DebugInit();
                #endif

                if (!DisableThreadLibraryCalls(hModule))
                {
                    TraceI(1, "DisableThreadLibraryCalls failed.\n");
                }

                g_hModule = hModule;
            }
            break;

        case DLL_PROCESS_DETACH:
            if (--nReferenceCount == 0)
            {
                TraceI(-1, "Unloading g_cLock %d  g_cComponent %d\n", g_cLock, g_cComponent);
                if (g_fInitCS)
                {
                    DeleteCriticalSection(&g_CritSec);
                    DeleteCriticalSection(&WaveItem::st_WaveListCritSect);
                }

                // Assert if we still have some objects hanging around
                assert(g_cComponent == 0);
                assert(g_cLock == 0);
            }
            break;
            
    }
        
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\XDmime\dmsegobj.cpp ===
// Copyright (c) 1998-2001 Microsoft Corporation
// dmsegobj.cpp : Implementation of CSegment

#include "dmime.h"
#include "DMSegObj.h"
#include "DMSStObj.h"
#include "DMGraph.h"
#include "dmusici.h"
#include "tlist.h"
#include "midifile.h"
#include "dmusicc.h"
#include "dmusicf.h"
#include "dmperf.h"
#include "wavtrack.h"
#include "validp.h"
#include "dmstrm.h"
#include "Validate.h"
#include "dmstyle.h"
#include "dmcompp.h"
#include "debug.h"
#include "dmscriptautguids.h"
#include "tempotrk.h"
#define ASSERT assert

// @doc EXTERNAL

long g_lNewTrackID = 0; // shared by all instances of Segments, this keeps track of the
    // next available TrackID when creating new Track states.

/////////////////////////////////////////////////////////////////////////////
// CSegment

void CSegment::Init()
{
    InitializeCriticalSection(&m_CriticalSection);
    m_pSong = NULL;
    m_dwNextPlayFlags = 0;
    m_dwNextPlayID = 0xFFFFFFFF;
    m_dwPlayID = 0;
    m_mtLength = 1;
    m_mtStart = 0;
    m_mtLoopStart = 0;
    m_mtLoopEnd = 0;
    m_rtLoopStart = 0;
    m_rtLoopEnd = 0;
    m_rtLength = 0;
    m_dwRepeats = 0;
    m_dwResolution = 0;
    m_dwNumPChannels = 0;
    m_paPChannels = NULL;
    m_pGraph = NULL;
    m_pAudioPathConfig = NULL;
    m_pUnkDispatch = NULL;
    m_dwSegFlags = 0;
    m_cRef = 0;
    m_dwVersion = 0; // Init to 6.1 behavior.
    m_dwValidData = DMUS_OBJ_CLASS; // upon creation, only this data is valid
    memset(&m_guidObject,0,sizeof(m_guidObject));
    memset(&m_ftDate, 0,sizeof(m_ftDate));
    memset(&m_vVersion, 0,sizeof(m_vVersion));
    m_fZombie = false;
    InterlockedIncrement(&g_cComponent);
    TraceI(2, "Segment %lx created\n", this );
}

CSegment::CSegment()
{
    Init();
}

CSegment::CSegment(DMUS_IO_SEGMENT_HEADER *pHeader, CSegment *pSource)
{
    Init();
    AddRef(); // so that this doesn't get deleted in Track::Init...
    // Force the version to at least 8 so audiopath functionality will be turned on.
    m_dwVersion = 8;
    m_dwResolution = pHeader->dwResolution;
    m_mtLength = pHeader->mtLength;
    m_mtStart = pHeader->mtPlayStart;
    m_mtLoopStart = pHeader->mtLoopStart;
    m_mtLoopEnd = pHeader->mtLoopEnd;
    m_dwRepeats = pHeader->dwRepeats;
    m_dwSegFlags = pHeader->dwFlags;
    if (m_dwSegFlags & DMUS_SEGIOF_REFLENGTH)
    {
        m_rtLength = pHeader->rtLength;
    }
    else
    {
        m_rtLength = 0;
    }
    if (pSource)
    {
        pSource->m_TrackList.CreateCopyWithBlankState(&m_TrackList);
        CTrack *pTrack = m_TrackList.GetHead();
        for (;pTrack;pTrack = pTrack->GetNext())
        {
            pTrack->m_pTrack->Init( this );
        }
    }
}

CSegment::~CSegment()
{
    if (m_pUnkDispatch)
        m_pUnkDispatch->Release(); // free IDispatch implementation we may have borrowed
    Clear(false);
    DeleteCriticalSection(&m_CriticalSection);
    InterlockedDecrement(&g_cComponent);
    TraceI(2, "Segment %lx destroyed\n", this );
}

void CSegment::Clear(bool fZombie)
{
    m_TrackList.Clear();
    if (m_pAudioPathConfig)
    {
        m_pAudioPathConfig->Release();
        m_pAudioPathConfig = NULL;
    }
    SetGraph(NULL); // shut down the graph and release it
    // We need the following stuff to hang around if the segment is being zombied.
    if (!fZombie)
    {
        // remove all notifies
        CNotificationItem* pItem = m_NotificationList.GetHead();
        while( pItem )
        {
            CNotificationItem* pNext = pItem->GetNext();
            m_NotificationList.Remove( pItem );
            delete pItem;
            pItem = pNext;
        }
        if( m_paPChannels )
        {
            delete [] m_paPChannels;
            m_paPChannels = NULL;
        }
        m_dwNumPChannels = 0;
    }
}

STDMETHODIMP_(void) CSegment::Zombie()
{
    Clear(true);
    m_fZombie = true;
}

STDMETHODIMP CSegment::QueryInterface(
    const IID &iid,   // @parm Interface to query for
    void **ppv)       // @parm The requested interface will be returned here
{
    V_INAME(CSegment::QueryInterface);
    V_PTRPTR_WRITE(ppv);
    V_REFGUID(iid);

    *ppv = NULL;
    if (iid == IID_IUnknown || iid == IID_IDirectMusicSegment)
    {
        *ppv = static_cast<IDirectMusicSegment*>(this);
    }
    else if (iid == IID_CSegment)
    {
        *ppv = static_cast<CSegment*>(this);
    }
    else if (iid == IID_IDirectMusicSegment8)
    {
        m_dwVersion = 8;
        *ppv = static_cast<IDirectMusicSegment*>(this);
    }
    else if (iid == IID_IDirectMusicSegment8P)
    {
        *ppv = static_cast<IDirectMusicSegment8P*>(this);
    }
    else if (iid == IID_IDirectMusicSegment2)
    {
        m_dwVersion = 2;
        *ppv = static_cast<IDirectMusicSegment*>(this);
    }
    else if (iid == IID_IPersistStream)
    {
        *ppv = static_cast<IPersistStream*>(this);
    }
    else if(iid == IID_IDirectMusicObject)
    {
        *ppv = static_cast<IDirectMusicObject*>(this);
    }
    else if (iid == IID_IDirectMusicObjectP)
    {
        *ppv = static_cast<IDirectMusicObjectP*>(this);
    }
    else if (iid == IID_IDispatch)
    {
        // A helper scripting object implements IDispatch, which we expose from the
        // Performance object via COM aggregation.
        if (!m_pUnkDispatch)
        {
            // Create the helper object
            ::CoCreateInstance(
                CLSID_AutDirectMusicSegment,
                static_cast<IDirectMusicSegment*>(this),
                CLSCTX_INPROC_SERVER,
                IID_IUnknown,
                reinterpret_cast<void**>(&m_pUnkDispatch));
        }
        if (m_pUnkDispatch)
        {
            return m_pUnkDispatch->QueryInterface(IID_IDispatch, ppv);
        }
    }

    if (*ppv == NULL)
    {
        Trace(4,"Warning: Segment queried for unknown interface.\n");
        return E_NOINTERFACE;
    }

    reinterpret_cast<IUnknown*>(this)->AddRef();
    return S_OK;
}


STDMETHODIMP_(ULONG) CSegment::AddRef()
{
    return InterlockedIncrement(&m_cRef);
}

STDMETHODIMP_(ULONG) CSegment::Release()
{
    if (!InterlockedDecrement(&m_cRef))
    {
        m_cRef = 100; // artificial reference count to prevent reentrency due to COM aggregation
        delete this;
        return 0;
    }

    return m_cRef;
}

STDMETHODIMP CSegment::GetLength(
    MUSIC_TIME *pmtLength) // @parm Returns the Segment's length.
{
    V_INAME(IDirectMusicSegment::GetLength);
    V_PTR_WRITE(pmtLength, MUSIC_TIME);

    if (m_fZombie)
    {
        Trace(2, "Warning: Call of IDirectMusicSegment::GetLength after the segment has been garbage collected.\n");
        return DMUS_S_GARBAGE_COLLECTED;
    }

    *pmtLength = m_mtLength;
    return S_OK;
}


STDMETHODIMP CSegment::SetLength(
    MUSIC_TIME mtLength) // @parm The desired length.
{
    if( mtLength <=0 )
    {
        Trace(1,"Error: Can not set segment length to a negative number (%ld.)\n",mtLength);
        return E_INVALIDARG;
    }
    if(( mtLength <= m_mtStart ) || ( mtLength < m_mtLoopEnd ))
    {
        Trace(1,"Error: Can not set segment length to %ld, which is either less that the start time %ld or the loop end %ld\n",
            mtLength,m_mtStart,m_mtLoopEnd);
        return DMUS_E_OUT_OF_RANGE;
    }

    if (m_fZombie)
    {
        Trace(2, "Warning: Call of IDirectMusicSegment::SetLength after the segment has been garbage collected.\n");
        return DMUS_S_GARBAGE_COLLECTED;
    }

    m_mtLength = mtLength;
    return S_OK;
}

STDMETHODIMP CSegment::GetRepeats(
    DWORD *pdwRepeats) // @parm Returns the number of repeats.
{
    V_INAME(IDirectMusicSegment::GetRepeats);
    V_PTR_WRITE(pdwRepeats, DWORD);

    if (m_fZombie)
    {
        Trace(2, "Warning: Call of IDirectMusicSegment::GetRepeats after the segment has been garbage collected.\n");
        return DMUS_S_GARBAGE_COLLECTED;
    }

    *pdwRepeats = m_dwRepeats;
    return S_OK;
}

STDMETHODIMP CSegment::SetRepeats(
    DWORD dwRepeats)    // @parm The desired number of repeats.
{
    if (m_fZombie)
    {
        Trace(2, "Warning: Call of IDirectMusicSegment::SetRepeats after the segment has been garbage collected.\n");
        return DMUS_S_GARBAGE_COLLECTED;
    }

    m_dwRepeats = dwRepeats;
    return S_OK;
}

STDMETHODIMP CSegment::GetDefaultResolution(
    DWORD *pdwResolution)    // @parm Returns the default resolution. (See <t DMPLAYSEGFLAGS>.)
{
    V_INAME(IDirectMusicSegment::GetDefaultResolution);
    V_PTR_WRITE(pdwResolution, DWORD);

    if (m_fZombie)
    {
        Trace(2, "Warning: Call of IDirectMusicSegment::GetDefaultResolution after the segment has been garbage collected.\n");

        return DMUS_S_GARBAGE_COLLECTED;
    }

    *pdwResolution = m_dwResolution;
    return S_OK;
}

#define LEGAL_RES_FLAGS (DMUS_SEGF_SECONDARY | \
                        DMUS_SEGF_QUEUE | \
                        DMUS_SEGF_CONTROL | \
                        DMUS_SEGF_AFTERPREPARETIME  | \
                        DMUS_SEGF_GRID | \
                        DMUS_SEGF_BEAT | \
                        DMUS_SEGF_MEASURE | \
                        DMUS_SEGF_NOINVALIDATE | \
                        DMUS_SEGF_ALIGN | \
                        DMUS_SEGF_VALID_START_BEAT | \
                        DMUS_SEGF_VALID_START_GRID | \
                        DMUS_SEGF_VALID_START_TICK | \
                        DMUS_SEGF_AFTERQUEUETIME | \
                        DMUS_SEGF_AFTERLATENCYTIME | \
                        DMUS_SEGF_SEGMENTEND | \
                        DMUS_SEGF_MARKER | \
                        DMUS_SEGF_TIMESIG_ALWAYS | \
                        DMUS_SEGF_USE_AUDIOPATH | \
                        DMUS_SEGF_VALID_START_MEASURE)

STDMETHODIMP CSegment::SetDefaultResolution(
    DWORD dwResolution)    // @parm The desired default resolution. (See <t DMPLAYSEGFLAGS>.)
{
    if (m_fZombie)
    {
        Trace(2, "Warning: Call of IDirectMusicSegment::SetDefaultResolution after the segment has been garbage collected.\n");
        return DMUS_S_GARBAGE_COLLECTED;
    }
#ifdef DBG
    if ((dwResolution & LEGAL_RES_FLAGS) != dwResolution)
    {
        Trace(1,"Warning: Attempt to set resolution includes inappropriate or non-existant flag: %lx\n",
            dwResolution & ~LEGAL_RES_FLAGS);
    }
#endif
    m_dwResolution = dwResolution;
    return S_OK;
}

STDMETHODIMP CSegment::GetHeaderChunk(
        DWORD *pdwSize,      /* Size of passed header chunk. Also, returns size written. */
        DMUS_IO_SEGMENT_HEADER *pHeader)
{
    if (m_fZombie)
    {
        Trace(2, "Warning: Call of IDirectMusicSegment::GetHeaderChunk after the segment has been garbage collected.\n");
        return DMUS_S_GARBAGE_COLLECTED;
    }

    DMUS_IO_SEGMENT_HEADER Header;
    Header.dwFlags = m_dwSegFlags;
    Header.dwRepeats = m_dwRepeats;
    Header.dwResolution = m_dwResolution;
    Header.mtLength = m_mtLength;
    Header.mtLoopEnd = m_mtLoopEnd;
    Header.mtLoopStart = m_mtLoopStart;
    Header.mtPlayStart = m_mtStart;
    Header.dwReserved = 0;
    Header.rtLength = m_rtLength;
    if (pdwSize && pHeader)
    {
        *pdwSize = min(sizeof(Header),*pdwSize);
        memcpy(pHeader,&Header,*pdwSize);
        return S_OK;
    }
    Trace(1,"Error: GetHeaderChunk() was passed a NULL for either pdwSize or pHeader.\n");
    return E_POINTER;
}

STDMETHODIMP CSegment::SetHeaderChunk(
        DWORD dwSize,        /* Size of passed header chunk. */
        DMUS_IO_SEGMENT_HEADER *pHeader)
{
    if (m_fZombie)
    {
        Trace(2, "Warning: Call of IDirectMusicSegment::SetHeaderChunk after the segment has been garbage collected.\n");
        return DMUS_S_GARBAGE_COLLECTED;
    }

    if (pHeader)
    {
        DMUS_IO_SEGMENT_HEADER Header;
        dwSize = min(sizeof(Header),dwSize);
        // Initialize all fields so we don't have to worry about the passed size.
        Header.dwFlags = m_dwSegFlags;
        Header.dwRepeats = m_dwRepeats;
        Header.dwResolution = m_dwResolution;
        Header.mtLength = m_mtLength;
        Header.mtLoopEnd = m_mtLoopEnd;
        Header.mtLoopStart = m_mtLoopStart;
        Header.mtPlayStart = m_mtStart;
        Header.dwReserved = 0;
        Header.rtLength = m_rtLength;
        Header.rtLoopStart = m_rtLoopStart;
        Header.rtLoopEnd = m_rtLoopEnd;
        memcpy(&Header,pHeader,dwSize);
        m_dwSegFlags = Header.dwFlags;
        m_dwRepeats = Header.dwRepeats;
        m_dwResolution = Header.dwResolution;
        m_mtLength = Header.mtLength;
        m_mtLoopEnd = Header.mtLoopEnd;
        m_mtLoopStart = Header.mtLoopStart;
        m_mtStart = Header.mtPlayStart;
        m_rtLength = Header.rtLength;
        if (m_dwSegFlags & DMUS_SEGIOF_REFLOOP)
        {
            m_rtLoopStart = Header.rtLoopStart;
            m_rtLoopEnd = Header.rtLoopEnd;
        }
        else
        {
            m_rtLoopEnd = m_rtLoopStart = 0;
        }
        return S_OK;
    }
    Trace(1,"Error: SetHeaderChunk() was passed a NULL for pHeader.\n");
    return E_POINTER;
}

STDMETHODIMP CSegment::SetTrackPriority(
        REFGUID rguidTrackClassID,  /* ClassID of Track. */
        DWORD dwGroupBits,          /* Group bits. */
        DWORD dwIndex,              /* Nth track. */
        DWORD dwPriority)       /* Priority to set. */
{
    if (m_fZombie)
    {
        Trace(2, "Warning: Call of IDirectMusicSegment::SetTrackPriority after the segment has been garbage collected.\n");
        return DMUS_S_GARBAGE_COLLECTED;
    }

    HRESULT hr = DMUS_E_TRACK_NOT_FOUND;
    CTrack* pCTrack;
    DWORD dwCounter = dwIndex;
    DWORD dwMax = dwIndex;
    if (dwIndex == DMUS_SEG_ALLTRACKS)
    {
        dwCounter = 0;
        dwMax = DMUS_SEG_ALLTRACKS;
    }
    EnterCriticalSection(&m_CriticalSection);
    while (pCTrack = GetTrack(rguidTrackClassID,dwGroupBits,dwCounter))
    {
        pCTrack->m_dwPriority = dwPriority;
        hr = S_OK;
        dwCounter++;
        if (dwCounter > dwMax) break;
    }
    LeaveCriticalSection(&m_CriticalSection);
    return hr;
}

STDMETHODIMP CSegment::SetAudioPathConfig(
        IUnknown *pAudioPathConfig)
{
    if (m_fZombie)
    {
        Trace(2, "Warning: Call of IDirectMusicSegment::SetAudioPathConfig after the segment has been garbage collected.\n");
        return DMUS_S_GARBAGE_COLLECTED;
    }

    if (m_dwVersion < 8) m_dwVersion = 8;
    if (m_pAudioPathConfig)
    {
        m_pAudioPathConfig->Release();
        m_pAudioPathConfig = NULL;
    }
    if (pAudioPathConfig)
    {
        return pAudioPathConfig->QueryInterface(IID_CAudioPathConfig,(void **) &m_pAudioPathConfig);
    }
    return S_OK;
}

STDMETHODIMP CSegment::GetTrack(
    REFCLSID rType,
    DWORD dwGroupBits,
    DWORD dwIndex,
    IDirectMusicTrack **ppTrack)
{
    V_INAME(IDirectMusicSegment::GetTrack);
    V_PTRPTR_WRITE(ppTrack);

    if (m_fZombie)
    {
        Trace(2, "Warning: Call of IDirectMusicSegment::GetTrack after the segment has been garbage collected.\n");
        return DMUS_S_GARBAGE_COLLECTED;
    }

    CTrack* pCTrack;
    HRESULT hr;
    EnterCriticalSection(&m_CriticalSection);
    pCTrack = GetTrack(rType,dwGroupBits,dwIndex);
    if (pCTrack)
    {
        *ppTrack = pCTrack->m_pTrack;
        pCTrack->m_pTrack->AddRef();
        hr = S_OK;
    }
    else
    {
        Trace(1,"Error: GetTrack could not find the requested track at index %ld.\n",dwIndex);
        hr = DMUS_E_NOT_FOUND;
    }
    LeaveCriticalSection(&m_CriticalSection);
    return hr;
}

CTrack *CSegment::GetTrack(
    REFCLSID rType,
    DWORD dwGroupBits,
    DWORD dwIndex)
{
    CTrack* pCTrack;
    pCTrack = m_TrackList.GetHead();
    while( pCTrack )
    {
        ASSERT(pCTrack->m_pTrack);
        if( pCTrack->m_dwGroupBits & dwGroupBits )
        {
            if( (GUID_NULL == rType) || (pCTrack->m_guidClassID == rType))
            {
                if( 0 == dwIndex )
                {
                    break;
                }
                dwIndex--;
            }
        }
        pCTrack = pCTrack->GetNext();
    }
    return pCTrack;
}

BOOL CSegment::IsTempoSource()

{
    EnterCriticalSection(&m_CriticalSection);
    BOOL fHasTempo = (NULL != GetTrackByParam(NULL, GUID_TempoParam,-1,0, FALSE));
    LeaveCriticalSection(&m_CriticalSection);
    return fHasTempo;
}

STDMETHODIMP CSegment::GetTrackGroup(
    IDirectMusicTrack* pTrack,    // @parm The Track to find the group bits.
    DWORD* pdwGroupBits)// @parm Returns the group(s) to which a Track belongs.
                        // Each bit in <p pdwGroupBits> corresponds to a Track
                        // group.
{
    V_INAME(IDirectMusicSegment::GetTrackGroup);
    V_INTERFACE(pTrack);
    V_PTR_WRITE(pdwGroupBits,DWORD);

    if (m_fZombie)
    {
        Trace(2, "Warning: Call of IDirectMusicSegment::GetTrackGroup after the segment has been garbage collected.\n");
        return DMUS_S_GARBAGE_COLLECTED;
    }

    CTrack* pCTrack;
    HRESULT hr = DMUS_E_NOT_FOUND;
    EnterCriticalSection(&m_CriticalSection);
    pCTrack = m_TrackList.GetHead();
    while( pCTrack )
    {
        ASSERT(pCTrack->m_pTrack);
        if( pCTrack->m_pTrack == pTrack )
        {
            *pdwGroupBits = pCTrack->m_dwGroupBits;
            hr = S_OK;
            break;
        }
        pCTrack = pCTrack->GetNext();
    }
#ifdef DBG
    if (hr == DMUS_E_NOT_FOUND)
    {
        Trace(1,"Error: GetTrackGroup could not find the requested track.\n");
    }
#endif
    LeaveCriticalSection(&m_CriticalSection);
    return hr;
}

CTrack * CSegment::GetTrackByParam( CTrack * pCTrack,
    REFGUID rguidType,DWORD dwGroupBits,DWORD dwIndex, BOOL fDontCheck)
{
    // If the caller was already part way through the list, it passes the current
    // track. Otherwise, NULL to indicate start at the top.
    if (pCTrack)
    {
        pCTrack = pCTrack->GetNext();
    }
    else
    {
        pCTrack = m_TrackList.GetHead();
    }
    while( pCTrack )
    {
        ASSERT(pCTrack->m_pTrack);
        if( (pCTrack->m_dwGroupBits & dwGroupBits ) && (fDontCheck ||
            (pCTrack->m_dwFlags & DMUS_TRACKCONFIG_CONTROL_ENABLED)))
        {
            if( (GUID_NULL == rguidType) ||
                (pCTrack->m_pTrack->IsParamSupported( rguidType ) == S_OK ))
            {
                if( 0 == dwIndex )
                {
                    return pCTrack;
                }
                dwIndex--;
            }
        }
        pCTrack = pCTrack->GetNext();
    }
    return NULL;
}

HRESULT CSegment::GetTrackByParam(
    REFGUID rguidType,    // The command type of the Track to find. A value of GUID_NULL
                        // will get any track.
    DWORD dwGroupBits,    // Which track groups to scan for the track in. A value of 0
                        // is invalid. Each bit in <p dwGroupBits> corresponds to a Track
                        // group. To scan all tracks regardless of groups, set all bits in
                        // this parameter (0xffffffff).
    DWORD dwIndex,        // The index into the list of tracks of type <p rguidType>
                        // and in group <p dwGroupBits> to return. 0 means the first
                        // one found, 1 would be the second, etc. If multiple groups are
                        // selected in <p dwGroupBits>, this index will indicate the nth
                        // track of type <p pCommandGuid> encountered in the union
                        // of the groups selected.
    IDirectMusicTrack **ppTrack)    // Returns the Track (AddRef'd), or NULL if the
                                    // Track isn't found.
{
    HRESULT hr;
    CTrack* pCTrack;
    EnterCriticalSection(&m_CriticalSection);
    pCTrack = GetTrackByParam(NULL,rguidType,dwGroupBits,dwIndex,TRUE);
    if (pCTrack)
    {
        *ppTrack = pCTrack->m_pTrack;
        pCTrack->m_pTrack->AddRef();
        hr = S_OK;
    }
    else
    {
        hr = DMUS_E_NOT_FOUND;
        // Don't think we need an error message here since SetParam also does one...
        // Trace(1,"Error: Could not find the requested track for SetParam.\n");
    }
    LeaveCriticalSection(&m_CriticalSection);
    return hr;
}

STDMETHODIMP CSegment::InsertTrack(
    IDirectMusicTrack *pTrack,    // @parm The Track to add to the Segment.
    DWORD dwGroupBits )            // @parm Identifies the group(s) this should be inserted into.
                                // May not be 0.
{
    V_INAME(IDirectMusicSegment::InsertTrack);
    V_INTERFACE(pTrack);

    if (m_fZombie)
    {
        Trace(2, "Warning: Call of IDirectMusicSegment::InsertTrack after the segment has been garbage collected.\n");
        return DMUS_S_GARBAGE_COLLECTED;
    }

    return InsertTrack(pTrack,dwGroupBits,DMUS_TRACKCONFIG_DEFAULT,0, 0);
}

HRESULT CSegment::InsertTrack(
    IDirectMusicTrack *pTrack,
    DWORD dwGroupBits,
    DWORD dwFlags,
    DWORD dwPriority,
    DWORD dwPosition)
{
    CTrack* pCTrack;

    if( 0 == dwGroupBits )
    {
        Trace(1,"Error: InsertTrack called with dwGroupBits set to 0.\n");
        return E_INVALIDARG;
    }
    if( FAILED( pTrack->Init( this ) ))
    {
        TraceI(1,"Error: Track failed to initialize\n");
        return DMUS_E_NOT_INIT;
    }
    pCTrack = new CTrack;
    if( NULL == pCTrack )
    {
        return E_OUTOFMEMORY;
    }
    pCTrack->m_pTrack = pTrack;
    pTrack->QueryInterface(IID_IDirectMusicTrack8,(void **) &pCTrack->m_pTrack8);
    IPersist *pPersist;
    if (S_OK == pTrack->QueryInterface(IID_IPersistStream,(void **) &pPersist))
    {
        pPersist->GetClassID( &pCTrack->m_guidClassID );
        pPersist->Release();
    }
    pCTrack->m_dwGroupBits = dwGroupBits;
    pCTrack->m_dwFlags = dwFlags;
    pCTrack->m_dwPriority = dwPriority;
    pCTrack->m_dwPosition = dwPosition;
    pTrack->AddRef();
    EnterCriticalSection(&m_CriticalSection);
    // Add the track based on position.
    CTrack* pScan = m_TrackList.GetHead();
    CTrack* pPrevTrack = NULL;
    for (; pScan; pScan = pScan->GetNext())
    {
        if (pCTrack->Less(pScan))
        {
            break;
        }
        pPrevTrack = pScan;
    }
    if (pPrevTrack)
    {
        pPrevTrack->SetNext(pCTrack);
        pCTrack->SetNext(pScan);
    }
    else
    {
        m_TrackList.AddHead( pCTrack );
    }

    // send notifications to track
    CNotificationItem* pItem = m_NotificationList.GetHead();
    while( pItem )
    {
        pTrack->AddNotificationType( pItem->guidNotificationType );
        pItem = pItem->GetNext();
    }
    LeaveCriticalSection(&m_CriticalSection);
    return S_OK;
}

STDMETHODIMP CSegment::RemoveTrack(
    IDirectMusicTrack *pTrack)    // @parm The Track to remove from the Segment's Track list.
{
    V_INAME(IDirectMusicSegment::RemoveTrack);
    V_INTERFACE(pTrack);

    if (m_fZombie)
    {
        Trace(2, "Warning: Call of IDirectMusicSegment::RemoveTrack after the segment has been garbage collected.\n");
        return DMUS_S_GARBAGE_COLLECTED;
    }

    HRESULT hr = S_FALSE;
    EnterCriticalSection(&m_CriticalSection);
    CTrack* pCTrackTemp;
    pCTrackTemp = m_TrackList.GetHead();
    while( pCTrackTemp )
    {
        if( pTrack == pCTrackTemp->m_pTrack )
        {
            hr = S_OK;
            m_TrackList.Remove( pCTrackTemp );
            delete pCTrackTemp;
            break;
        }
        pCTrackTemp = pCTrackTemp->GetNext();
    }
    LeaveCriticalSection(&m_CriticalSection);
#ifdef DBG
    if (hr == S_FALSE)
    {
        Trace(1,"Warning: RemoveTrack failed because the requested track is not in the segment.\n");
    }
#endif
    return hr;
}

HRESULT CSegment::CreateSegmentState(
    CSegState **ppSegState,
    CPerformance *pPerformance,
    IDirectMusicAudioPath *pAudioPath,
    DWORD dwFlags)

{
    IDirectMusicSegmentState* pSegmentState;
    CSegState *pState = new CSegState;
    if (pState)
    {
        pState->QueryInterface( IID_IDirectMusicSegmentState,
            (void**)&pSegmentState);
        pState->m_dwVersion = m_dwVersion;
        pState->Release();
    }
    else
    {
        return E_OUTOFMEMORY;
    }
    EnterCriticalSection(&m_CriticalSection);
    if( FAILED( m_TrackList.CreateCopyWithBlankState(&pState->m_TrackList)))
    {
        LeaveCriticalSection(&m_CriticalSection);
        pState->Release();
        return E_OUTOFMEMORY;
    }
    // set the segstate's parent and performance
    pState->PrivateInit( this, pPerformance );

    if (m_pGraph)
    {
        m_pGraph->Clone((IDirectMusicGraph **) &pState->m_pGraph);
    }
    pState->InitRoute(pAudioPath);
    CTrack* pCTrack = pState->m_TrackList.GetHead();
    while( pCTrack )
    {
        DWORD dwTempID;
        InterlockedIncrement(&g_lNewTrackID);
        dwTempID = g_lNewTrackID;
        if (!pState->m_dwFirstTrackID)
            pState->m_dwFirstTrackID = dwTempID;
        pState->m_dwLastTrackID = dwTempID;
        ASSERT(pCTrack->m_pTrack);
        if( FAILED(pCTrack->m_pTrack->InitPlay(
            pSegmentState, (IDirectMusicPerformance *) pPerformance,
            &pCTrack->m_pTrackState, dwTempID, dwFlags )))
        {
            pCTrack->m_pTrackState = NULL;
        }
        pCTrack->m_dwVirtualID = dwTempID;
        pCTrack = pCTrack->GetNext();
    }
    *ppSegState = pState;
    LeaveCriticalSection(&m_CriticalSection);
    return S_OK;
}

/*  The following function is kept around only for DX6.1 compatibility just
    in case some mindless bureaucrat actually uses this somehow.
    For internal use, we've switched to the function above.
*/

STDMETHODIMP CSegment::InitPlay(
    IDirectMusicSegmentState **ppSegState,    // @parm Returns the SegmentState created
            // by this method call. It is returned with a reference count of 1, thus a
            // call to its Release will fully release it.
    IDirectMusicPerformance *pPerformance,    // @parm The IDirectMusicPerformance pointer.
            // This is needed by the Segment and SegmentState in order to call methods on
            // the Performance object. This pointer is not AddRef'd. It is a weak reference
            // because it is assumed that the Performance will outlive the Segment.
    DWORD dwFlags)                          // @parm Same flags that were set with the call
            // to PlaySegment. These are passed to the tracks, who may want to know
            // if the track was played as a primary, controlling, or secondary segment.
{
    V_INAME(IDirectMusicSegment::InitPlay);
    V_INTERFACE(pPerformance);
    V_PTRPTR_WRITE(ppSegState);

    if (m_dwVersion)
    {
        return E_NOTIMPL;
    }

    IDirectMusicSegmentState* pSegmentState;
    CSegState *pState = new CSegState;
    if (pState)
    {
        pState->QueryInterface( IID_IDirectMusicSegmentState,
            (void**)&pSegmentState);
        pState->m_dwVersion = m_dwVersion;
        pState->Release();
        if (pPerformance)
        {
            // QI addref's the performance but we want only a weak refrenece with the segment state
            HRESULT hr = pPerformance->QueryInterface(IID_CPerformance,(void **) &pState->m_pPerformance);
            if(FAILED(hr))
            {
                return E_FAIL;
            }

            pPerformance->Release();
        }
    }
    else
    {
        return E_OUTOFMEMORY;
    }
    *ppSegState = pSegmentState;
    return S_OK;
}

STDMETHODIMP CSegment::GetGraph(
    IDirectMusicGraph**    ppGraph    // @parm Returns the Tool Graph pointer.
        )
{
    V_INAME(IDirectMusicSegment::GetGraph);
    V_PTRPTR_WRITE(ppGraph);

    if (m_fZombie)
    {
        Trace(2, "Warning: Call of IDirectMusicSegment::GetGraph after the segment has been garbage collected.\n");
        return DMUS_S_GARBAGE_COLLECTED;
    }

    if( NULL == m_pGraph )
    {
        Trace(1,"Error: GetGraph failed because segment does not have a tool graph.\n");
        return DMUS_E_NOT_FOUND;
    }
    EnterCriticalSection(&m_CriticalSection);
    *ppGraph = m_pGraph;
    m_pGraph->AddRef();
    LeaveCriticalSection(&m_CriticalSection);
    return S_OK;
}

STDMETHODIMP CSegment::SetGraph(
    IDirectMusicGraph*    pGraph    // @parm The Tool Graph pointer. May be NULL to
                                // clear out the Segment graph.
        )
{
    V_INAME(IDirectMusicSegment::SetGraph);
    V_INTERFACE_OPT(pGraph);

    if (m_fZombie)
    {
        Trace(2, "Warning: Call of IDirectMusicSegment::SetGraph after the segment has been garbage collected.\n");
        return DMUS_S_GARBAGE_COLLECTED;
    }

    EnterCriticalSection(&m_CriticalSection);
    if( m_pGraph )
    {
        m_pGraph->Release();
    }
    m_pGraph = (CGraph *) pGraph;
    if( pGraph )
    {
        pGraph->AddRef();
    }
    LeaveCriticalSection(&m_CriticalSection);
    return S_OK;
}

HRESULT CSegment::SetClockTimeDuration(REFERENCE_TIME rtDuration)

{
    m_rtLength = rtDuration;
    return S_OK;
}

HRESULT CSegment::SetFlags(DWORD dwFlags)

{
    m_dwSegFlags = dwFlags;
    return S_OK;
}

/*
  Check to see if this notification is already being tracked.
*/
CNotificationItem* CSegment::FindNotification( REFGUID rguidNotification )
{
    CNotificationItem* pItem;

    pItem = m_NotificationList.GetHead();
    while(pItem)
    {
        if( rguidNotification == pItem->guidNotificationType )
        {
            break;
        }
        pItem = pItem->GetNext();
    }
    return pItem;
}

void CSegment::AddNotificationTypeToAllTracks( REFGUID rguidNotification )
{
    CTrack* pTrack;

    // add the notify to the tracks
    pTrack = m_TrackList.GetHead();
    while( pTrack )
    {
        pTrack->m_pTrack->AddNotificationType( rguidNotification );
        pTrack = pTrack->GetNext();
    }
}

void CSegment::RemoveNotificationTypeFromAllTracks( REFGUID rguidNotification )
{
    CTrack* pTrack;

    // add the notify to the tracks
    pTrack = m_TrackList.GetHead();
    while( pTrack )
    {
        pTrack->m_pTrack->RemoveNotificationType( rguidNotification );
        pTrack = pTrack->GetNext();
    }
}

HRESULT CSegment::AddNotificationType(
     REFGUID rguidNotification, BOOL fFromPerformance)
{
    CNotificationItem* pItem;
    HRESULT hr = S_OK;
    EnterCriticalSection(&m_CriticalSection);
    pItem = FindNotification( rguidNotification );
    if (pItem)
    {
        // If the item was installed previously, but by
        // a difference source (performance vs. app)
        // then treat this as a normal addition.
        // Otherwise, indicate that the same operation
        // was done twice.
        if (pItem->fFromPerformance == fFromPerformance)
        {
            hr = S_FALSE;
        }
        else
        {
            // Clear the fFromPerformance flag since this has
            // now been added by the app and the performance.
            pItem->fFromPerformance = FALSE;
        }
    }
    else
    {
        pItem = new CNotificationItem;
        if( NULL == pItem )
        {
            hr = E_OUTOFMEMORY;
        }
        else
        {
            pItem->fFromPerformance = fFromPerformance;
            pItem->guidNotificationType = rguidNotification;
            m_NotificationList.Cat( pItem );
            AddNotificationTypeToAllTracks( rguidNotification );
        }
    }
    LeaveCriticalSection(&m_CriticalSection);
    return hr;
}

STDMETHODIMP CSegment::AddNotificationType(
     REFGUID rguidNotification)    // @parm The notification guid to add.
{
    V_INAME(IDirectMusicSegment::AddNotificationType);
    V_REFGUID(rguidNotification);

    if (m_fZombie)
    {
        Trace(2, "Warning: Call of IDirectMusicSegment::AddNotificationType after the segment has been garbage collected.\n");
        return DMUS_S_GARBAGE_COLLECTED;
    }

    return AddNotificationType(rguidNotification,FALSE);
}

HRESULT CSegment::RemoveNotificationType(
     REFGUID rguidNotification,BOOL fFromPerformance)
{

    CNotificationItem* pItem;
    HRESULT hr = S_OK;
    EnterCriticalSection(&m_CriticalSection);
    if( GUID_NULL == rguidNotification )
    {
        CNotificationList TempList;
        while( pItem = m_NotificationList.RemoveHead() )
        {
            // If this is being called on an item that was installed by the
            // performance OR we are calling this directly from the app,
            // go ahead and remove. However, do not remove in the specific
            // case where the app installed the notification and the performance
            // is clearing notifications.
            if (pItem->fFromPerformance || !fFromPerformance)
            {
                RemoveNotificationTypeFromAllTracks( pItem->guidNotificationType );
                delete pItem;
            }
            else
            {
                TempList.AddHead(pItem);
            }
        }
        // Now, put the saved notifications back.
        while (pItem = TempList.RemoveHead())
        {
            m_NotificationList.AddHead(pItem);
        }
    }
    else if( pItem = FindNotification( rguidNotification ))
    {
        m_NotificationList.Remove( pItem );
        delete pItem;
        RemoveNotificationTypeFromAllTracks( rguidNotification );
    }
    else
    {
        Trace(2,"Warning: Unable to remove requested notification from segment, it was not currently installed.\n");
        hr = S_FALSE;
    }
    LeaveCriticalSection(&m_CriticalSection);
    return hr;
}

STDMETHODIMP CSegment::RemoveNotificationType(
     REFGUID rguidNotification)    // @parm The notification guid to remove. GUID_NULL to remove all notifies.
{
    V_INAME(IDirectMusicSegment::RemoveNotificationType);
    V_REFGUID(rguidNotification);

    if (m_fZombie)
    {
        Trace(2, "Warning: Call of IDirectMusicSegment::RemoveNotificationType after the segment has been garbage collected.\n");
        return DMUS_S_GARBAGE_COLLECTED;
    }

    return RemoveNotificationType(rguidNotification,FALSE);
}

STDMETHODIMP CSegment::GetParam(
    REFGUID rguidType,        // @parm The type of data to obtain.
    DWORD dwGroupBits,        // @parm The group the desired track is in. Use 0xffffffff
                            // for all groups.
    DWORD dwIndex,            // @parm Identifies which track, by index, in the group
                            // identified by <p dwGroupBits> to obtain the data from.
    MUSIC_TIME mtTime,        // @parm The segment time from which to obtain the data.
    MUSIC_TIME* pmtNext,    // @parm Returns the segment time until which the data is valid. <p pmtNext>
                            // may be NULL. If this returns a value of 0, it means that this
                            // data will either be always valid, or it is unknown when it will
                            // become invalid.
    void* pParam)            // @parm The struture in which to return the data. Each
                            // <p rguidType> identifies a particular structure of a
                            // particular size. It is important that this field contain
                            // the correct structure of the correct size. Otherwise,
                            // fatal results can occur.
{
    V_INAME(IDirectMusicSegment::GetParam);
    V_REFGUID(rguidType);

    if (m_fZombie)
    {
        Trace(2, "Warning: Call of IDirectMusicSegment::GetParam after the segment has been garbage collected.\n");
        return DMUS_S_GARBAGE_COLLECTED;
    }

    HRESULT hr = DMUS_E_TRACK_NOT_FOUND;
    BOOL fMultipleTry = FALSE;
    if (dwIndex == DMUS_SEG_ANYTRACK)
    {
        dwIndex = 0;
        // App must be using IDirectMusicSegment8 interface for this to be enabled...
        // Nah, nobody would ever have a use for an index that high, so this is safe.
        fMultipleTry = TRUE; // (m_dwVersion > 2);
    }
    CTrack* pCTrack;
    EnterCriticalSection(&m_CriticalSection);
    pCTrack = GetTrackByParam(NULL,rguidType,dwGroupBits,dwIndex,FALSE);
    while (pCTrack)
    {
        if (pCTrack->m_pTrack8)
        {
            REFERENCE_TIME rtNext, *prtNext;
            // We need to store the next time in a 64 bit pointer. But, don't
            // make 'em fill it in unless the caller requested it.
            if (pmtNext)
            {
                prtNext = &rtNext;
            }
            else
            {
                prtNext = NULL;
            }
            hr = pCTrack->m_pTrack8->GetParamEx( rguidType, mtTime, prtNext, pParam, NULL, 0 );
            if (pmtNext)
            {
                *pmtNext = (MUSIC_TIME) rtNext;
            }
        }
        else
        {
            hr = pCTrack->m_pTrack->GetParam( rguidType, mtTime, pmtNext, pParam );
            if( pmtNext && (( *pmtNext == 0 ) || (*pmtNext > (m_mtLength - mtTime))))
            {
                *pmtNext = m_mtLength - mtTime;
            }
        }
        // If nothing was found and dwIndex was DMUS_SEG_ANYTRACK, try again...
        if (fMultipleTry && (hr == DMUS_E_NOT_FOUND))
        {
            pCTrack = GetTrackByParam( pCTrack, rguidType, dwGroupBits, 0, FALSE);
        }
        else
        {
            pCTrack = NULL;
        }
    }
    LeaveCriticalSection(&m_CriticalSection);
#ifdef DBG
    if (hr == DMUS_E_TRACK_NOT_FOUND)
    {
        Trace(2,"Warning: Segment GetParam failed to find a track.\n");
    }
#endif
    return hr;
}


STDMETHODIMP CSegment::SetParam(
    REFGUID rguidType,        // @parm The type of data to set.
    DWORD dwGroupBits,        // @parm The group the desired track is in. Use 0xffffffff
                            // for all groups.
    DWORD dwIndex,            // @parm Identifies which track, by index, in the group
                            // identified by <p dwGroupBits> to set the data.
    MUSIC_TIME mtTime,        // @parm The time at which to set the data.
    void* pParam)            // @parm The struture containing the data to set. Each
                            // <p rguidType> identifies a particular structure of a
                            // particular size. It is important that this field contain
                            // the correct structure of the correct size. Otherwise,
                            // fatal results can occur.
{
    V_INAME(IDirectMusicSegment::SetParam);
    V_REFGUID(rguidType);

    if (m_fZombie)
    {
        Trace(2, "Warning: Call of IDirectMusicSegment::SetParam after the segment has been garbage collected.\n");
        return DMUS_S_GARBAGE_COLLECTED;
    }

    HRESULT hr = DMUS_E_TRACK_NOT_FOUND;
    IDirectMusicTrack* pTrack;
    DWORD dwCounter = dwIndex;
    DWORD dwMax = dwIndex;
    if (dwIndex == DMUS_SEG_ALLTRACKS)
    {
        dwCounter = 0;
        dwMax = DMUS_SEG_ALLTRACKS;
    }
    while (SUCCEEDED( GetTrackByParam( rguidType, dwGroupBits, dwCounter, &pTrack )))
    {
        hr = pTrack->SetParam( rguidType, mtTime, pParam );
        pTrack->Release();
        dwCounter++;
        if (dwCounter > dwMax) break;
    }
#ifdef DBG
    if (hr == DMUS_E_TRACK_NOT_FOUND)
    {
        Trace(2,"Warning: Segment SetParam failed to find the requested track.\n");
    }
#endif
    return hr;
}

STDMETHODIMP CSegment::Download(IUnknown *pAudioPath)

{
    V_INAME(IDirectMusicSegment::Download);
    V_INTERFACE(pAudioPath);
    HRESULT hr = S_OK;

    if (m_fZombie)
    {
        Trace(2, "Warning: Call of IDirectMusicSegment::Download after the segment has been garbage collected.\n");
        return DMUS_S_GARBAGE_COLLECTED;
    }

    // Validate that pAudioPath is either a performance or an audio path
    IDirectMusicPerformance* pPerf = NULL;
    if ( FAILED(hr = pAudioPath->QueryInterface(IID_IDirectMusicPerformance, (void**)&pPerf)) )
    {
        IDirectMusicAudioPath* pAP = NULL;
        if ( FAILED(hr = pAudioPath->QueryInterface(IID_IDirectMusicAudioPath, (void**)&pAP)) )
        {
            return hr; // nothing to release, since all the QI's failed.
        }
        else
        {
            pAP->Release();
        }
    }
    else
    {
        pPerf->Release();
    }

    hr = SetParam(GUID_DownloadToAudioPath,-1,DMUS_SEG_ALLTRACKS,0,pAudioPath);
    if (hr == DMUS_E_TRACK_NOT_FOUND)
    {
        Trace(2,"Attempted download to a segment that has no tracks that support downloading (wave and band tracks.)\n");
        hr = S_OK;
    }
    return hr;
}

STDMETHODIMP CSegment::Unload(IUnknown *pAudioPath)

{
    V_INAME(IDirectMusicSegment::Unload);
    V_INTERFACE(pAudioPath);

    if (m_fZombie)
    {
        Trace(2, "Warning: Call of IDirectMusicSegment::Unload after the segment has been garbage collected.\n");
        return DMUS_S_GARBAGE_COLLECTED;
    }

    HRESULT hr = SetParam(GUID_UnloadFromAudioPath,-1,DMUS_SEG_ALLTRACKS,0,pAudioPath);
    if (hr == DMUS_E_TRACK_NOT_FOUND)
    {
        Trace(2,"Attempted unload from a segment that has no tracks that support downloading (wave and band tracks.)\n");
        hr = S_OK;
    }
    return hr;
}

STDMETHODIMP CSegment::SetTrackConfig(REFGUID rguidTrackClassID,
                                      DWORD dwGroup, DWORD dwIndex,
                                      DWORD dwFlagsOn, DWORD dwFlagsOff)
{
    V_INAME(IDirectMusicSegment::SetTrackConfig);
    V_REFGUID(rguidTrackClassID);
    if (rguidTrackClassID == GUID_NULL)
    {
        return E_INVALIDARG;
    }

    if (m_fZombie)
    {
        Trace(2, "Warning: Call of IDirectMusicSegment::SetTrackConfig after the segment has been garbage collected.\n");
        return DMUS_S_GARBAGE_COLLECTED;
    }

    HRESULT hr = DMUS_E_TRACK_NOT_FOUND;
    CTrack* pCTrack;
    DWORD dwCounter = dwIndex;
    DWORD dwMax = dwIndex;
    if (dwIndex == DMUS_SEG_ALLTRACKS)
    {
        dwCounter = 0;
        dwMax = DMUS_SEG_ALLTRACKS;
    }
    EnterCriticalSection(&m_CriticalSection);
    while (pCTrack = GetTrack(rguidTrackClassID,dwGroup,dwCounter))
    {
        pCTrack->m_dwFlags &= ~dwFlagsOff;
        pCTrack->m_dwFlags |= dwFlagsOn;
        hr = S_OK;
        dwCounter++;
        if (dwCounter > dwMax) break;
    }
    LeaveCriticalSection(&m_CriticalSection);
#ifdef DBG
    if (hr == DMUS_E_TRACK_NOT_FOUND)
    {
        Trace(1,"Error: Segment SetTrackConfig failed to find the requested track.\n");
    }
#endif
    return hr;
}

HRESULT CSegment::GetTrackConfig(REFGUID rguidTrackClassID,
                                      DWORD dwGroup, DWORD dwIndex, DWORD *pdwFlags)
{

    HRESULT hr = DMUS_E_TRACK_NOT_FOUND;
    CTrack* pCTrack;
    EnterCriticalSection(&m_CriticalSection);
    pCTrack = GetTrack(rguidTrackClassID,dwGroup,dwIndex);
    if (pCTrack)
    {
        *pdwFlags = pCTrack->m_dwFlags;
        hr = S_OK;
    }
    LeaveCriticalSection(&m_CriticalSection);
    return hr;
}


STDMETHODIMP CSegment::Clone(
            MUSIC_TIME mtStart,    // @parm The start of the part to clone. If less than 0,
                                // or greater than the length of the Segment, 0 will be used.
            MUSIC_TIME mtEnd,    // @parm The end of the part to clone. If past the end of the
                                // Segment, it will clone to the end. Also, a value of 0 or
                                // anything less than <p mtStart> will also clone to the end.
            IDirectMusicSegment** ppSegment    // @parm Returns the created Segment, if successful.
                                // It is caller's responsibility to call Release() when finished
                                // with it.
        )
{
    V_INAME(IDirectMusicSegment::Clone);
    V_PTRPTR_WRITE(ppSegment);

    if (m_fZombie)
    {
        Trace(2, "Warning: Call of IDirectMusicSegment::Clone after the segment has been garbage collected.\n");
        return DMUS_S_GARBAGE_COLLECTED;
    }

    CSegment* pCSegment;
    HRESULT hr = S_OK;

    if( (mtEnd < mtStart) || (mtEnd > m_mtLength) )
    {
        mtEnd = m_mtLength;
    }
    if( ( mtEnd == 0 ) && ( mtStart == 0 ))
    {
        mtEnd = m_mtLength;
    }
    if( (mtStart < 0) || (mtStart > m_mtLength) )
    {
        mtStart = 0;
    }
    pCSegment = new CSegment;
    if (pCSegment == NULL) {
        return E_OUTOFMEMORY;
    }
    // Addref to 1 and assign to ppSegment.
    pCSegment->AddRef();
    (*ppSegment) = (IDirectMusicSegment *) pCSegment;
    if( m_pGraph )
    {
        pCSegment->m_pGraph = m_pGraph;
        m_pGraph->AddRef();
    }
    if (m_pAudioPathConfig)
    {
        pCSegment->m_pAudioPathConfig = m_pAudioPathConfig;
        m_pAudioPathConfig->AddRef();
    }
    pCSegment->m_dwRepeats = m_dwRepeats;
    pCSegment->m_dwResolution = m_dwResolution;
    pCSegment->m_dwSegFlags = m_dwSegFlags;
    pCSegment->m_mtLength = mtEnd - mtStart;
    pCSegment->m_rtLength = m_rtLength;
    pCSegment->m_mtStart = m_mtStart;
    pCSegment->m_mtLoopStart = m_mtLoopStart;
    pCSegment->m_mtLoopEnd = m_mtLoopEnd;
    pCSegment->m_dwValidData = m_dwValidData;
    pCSegment->m_guidObject = m_guidObject;
    pCSegment->m_ftDate = m_ftDate;
    pCSegment->m_vVersion = m_vVersion;
    wcscpy(pCSegment->m_wszName,m_wszName);
    wcscpy(pCSegment->m_wszCategory,m_wszCategory);
    wcscpy(pCSegment->m_wszFileName,m_wszFileName);
    pCSegment->m_dwVersion = m_dwVersion;
    pCSegment->m_dwLoadID = m_dwLoadID;
    pCSegment->m_dwPlayID = m_dwPlayID;
    pCSegment->m_dwNextPlayID = m_dwNextPlayID;
    pCSegment->m_dwNextPlayFlags = m_dwNextPlayFlags;

    CTrack* pCTrack;
    IDirectMusicTrack* pTrack;
    EnterCriticalSection(&m_CriticalSection);
    pCTrack = m_TrackList.GetHead();
    while( pCTrack )
    {
        if( SUCCEEDED( pCTrack->m_pTrack->Clone( mtStart, mtEnd, &pTrack )))
        {
            if( FAILED( pCSegment->InsertTrack( pTrack, pCTrack->m_dwGroupBits, pCTrack->m_dwFlags, pCTrack->m_dwPriority, pCTrack->m_dwPosition )))
            {
                Trace(1,"Warning: Insertion of cloned track failed, cloned segment is incomplete.\n");
                hr = S_FALSE;
            }
            pTrack->Release();
        }
        else
        {
            Trace(1,"Warning: Track clone failed, cloned segment is incomplete.\n");
            hr = S_FALSE;
        }
        pCTrack = pCTrack->GetNext();
    }
    LeaveCriticalSection(&m_CriticalSection);
    return hr;
}

STDMETHODIMP CSegment::GetAudioPathConfig(IUnknown ** ppAudioPathConfig)

{
    V_INAME(IDirectMusicSegment::GetAudioPathConfig);
    V_PTRPTR_WRITE(ppAudioPathConfig);

    if (m_fZombie)
    {
        Trace(2, "Warning: Call of IDirectMusicSegment::GetAudioPathConfig after the segment has been garbage collected.\n");
        return DMUS_S_GARBAGE_COLLECTED;
    }

    HRESULT hr;
    EnterCriticalSection(&m_CriticalSection);
    if (m_pAudioPathConfig)
    {
        hr = m_pAudioPathConfig->QueryInterface(IID_IUnknown,(void **)ppAudioPathConfig);
    }
    else
    {
        Trace(2,"Warning: No embedded audiopath configuration in the segment.\n");
        hr = DMUS_E_NO_AUDIOPATH_CONFIG;
    }
    LeaveCriticalSection(&m_CriticalSection);
    return hr;
}


STDMETHODIMP CSegment::GetObjectInPath(DWORD dwPChannel,    /* PChannel to search. */
                                DWORD dwStage,       /* Which stage in the path. */
                                DWORD dwBuffer,
                                REFGUID guidObject,  /* ClassID of object. */
                                DWORD dwIndex,       /* Which object of that class. */
                                REFGUID iidInterface,/* Requested COM interface. */
                                void ** ppObject)

{
    V_INAME(IDirectMusicSegment::GetObjectInPath);
    V_PTRPTR_WRITE(ppObject);

    if (m_fZombie)
    {
        Trace(2, "Warning: Call of IDirectMusicSegment::GetObjectInPath after the segment has been garbage collected.\n");
        return DMUS_S_GARBAGE_COLLECTED;
    }

    HRESULT hr = DMUS_E_NOT_FOUND;
    EnterCriticalSection(&m_CriticalSection);
    if (dwStage == DMUS_PATH_SEGMENT_TRACK)
    {
        CTrack * pCTrack = GetTrack(guidObject,-1,dwIndex);
        if (pCTrack)
        {
            if (pCTrack->m_pTrack)
            {
                hr = pCTrack->m_pTrack->QueryInterface(iidInterface,ppObject);
            }
        }
    }
    else if (dwStage == DMUS_PATH_SEGMENT_GRAPH)
    {
        if (dwIndex == 0)
        {
            if (!m_pGraph)
            {
                m_pGraph = new CGraph;
            }
            if (m_pGraph)
            {
                hr = m_pGraph->QueryInterface(iidInterface,ppObject);
            }
            else
            {
                hr = E_OUTOFMEMORY;
            }
        }
    }
    else if (dwStage == DMUS_PATH_SEGMENT_TOOL)
    {
        if (!m_pGraph)
        {
            m_pGraph = new CGraph;
        }
        if (m_pGraph)
        {
            hr = m_pGraph->GetObjectInPath(dwPChannel,guidObject,dwIndex,iidInterface,ppObject);
        }
        else
        {
            hr = E_OUTOFMEMORY;
        }
    }
    else if (dwStage >= DMUS_PATH_BUFFER)
    {
        // Nothing here now. But, in DX9, we may add support for addressing the buffer configuration
        // and DMOS in it.
    }
    LeaveCriticalSection(&m_CriticalSection);
    return hr;
}

STDMETHODIMP CSegment::Compose(MUSIC_TIME mtTime,
                                IDirectMusicSegment* pFromSegment,
                                IDirectMusicSegment* pToSegment,
                                IDirectMusicSegment** ppComposedSegment)

{
    V_INAME(IDirectMusicSegment::Compose);
    V_INTERFACE_OPT(pFromSegment);
    V_INTERFACE_OPT(pToSegment);
    V_PTRPTR_WRITE_OPT(ppComposedSegment);
#ifdef DBG
    if (pFromSegment)
    {
        MUSIC_TIME mtLength, mtLoopEnd, mtLoopStart;
        DWORD dwRepeats;
        // To calculate the full length, we need to access the loop parameters.
        pFromSegment->GetLoopPoints(&mtLoopStart,&mtLoopEnd);
        pFromSegment->GetRepeats(&dwRepeats);
        pFromSegment->GetLength(&mtLength);
        // If repeats is set to infinite, the total length will be greater than 32 bits.
        LONGLONG llTotalLength = dwRepeats * (mtLoopEnd - mtLoopStart) + mtLength;
        if (mtTime >= (llTotalLength & 0x7FFFFFFF))
        {
            Trace(2,"Warning: A time value of %ld was passed to Compose for a segment of length %ld.\n",
                mtTime, (long) llTotalLength);
        }
    }
#endif
    if (m_fZombie)
    {
        Trace(2, "Warning: Call of IDirectMusicSegment::Compose after the segment has been garbage collected.\n");
        return DMUS_S_GARBAGE_COLLECTED;
    }

    HRESULT hr = S_OK;
    EnterCriticalSection(&m_CriticalSection);

    if (ppComposedSegment)
    {
        hr = Clone(0, m_mtLength, ppComposedSegment);
        if (SUCCEEDED(hr))
        {
            hr = ((CSegment*)*ppComposedSegment)->ComposeTransition(mtTime, pFromSegment, pToSegment);
        }
    }
    else
    {
        hr = ComposeTransition(mtTime, pFromSegment, pToSegment);
    }

    LeaveCriticalSection(&m_CriticalSection);
    return hr;
}

HRESULT CSegment::ComposeTransition(MUSIC_TIME mtTime,
                                    IDirectMusicSegment* pFromSegment,
                                    IDirectMusicSegment* pToSegment)
{
    HRESULT hr = S_OK;
    bool fTrackPadded = false;

    // Compute amount of time to pad any tracks that need padding.
    DMUS_TIMESIGNATURE TimeSig;
    if (!pFromSegment ||
        FAILED(pFromSegment->GetParam(GUID_TimeSignature, 0xffffffff, 0, mtTime, NULL, (void*) &TimeSig)))
    {
        TimeSig.mtTime = 0;
        TimeSig.bBeatsPerMeasure = 4;
        TimeSig.bBeat = 4;
        TimeSig.wGridsPerBeat = 4;
    }
    else // avoid divide-by-zero
    {
        if (!TimeSig.bBeat) TimeSig.bBeat = 4;
    }
    MUSIC_TIME mtBar = ( DMUS_PPQ * 4 * TimeSig.bBeatsPerMeasure ) / TimeSig.bBeat;
    MUSIC_TIME mtStartPad = min(mtBar, mtTime);
    if (!pFromSegment) mtStartPad = 0;
    MUSIC_TIME mtToLength = 0;
    if (pToSegment) pToSegment->GetLength(&mtToLength);
    MUSIC_TIME mtEndPad = min(mtBar, mtToLength);

    // Instantiate tracks
    CTrack* pTrack = m_TrackList.GetHead();
    for (; pTrack; pTrack = pTrack->GetNext())
    {
        pTrack->m_dwInternalFlags &= ~(TRACKINTERNAL_START_PADDED | TRACKINTERNAL_END_PADDED);
        IDirectMusicTrack* pTransTrack1 = NULL;
        IDirectMusicTrack* pTransTrack2 = NULL;
        GUID guidClassID;
        memset(&guidClassID, 0, sizeof(guidClassID));
        IPersist* pPersist = NULL;
        if (SUCCEEDED(pTrack->m_pTrack->QueryInterface(IID_IPersistStream, (void**)&pPersist)))
        {
            pPersist->GetClassID(&guidClassID);
            pPersist->Release();
        }
        DWORD dwTrackGroup = 0;
        GetTrackGroup(pTrack->m_pTrack, &dwTrackGroup);

        // Get track info
        if (pTrack->m_dwFlags & COMPOSE_TRANSITION1)
        {
            // Clone the appropriate track, with length m_mtLength
            MUSIC_TIME mtStart = 0;
            if (pTrack->m_dwFlags & DMUS_TRACKCONFIG_TRANS1_FROMSEGCURRENT)
            {
                mtStart = mtTime;
            }
            MUSIC_TIME mtEnd = mtStart + m_mtLength;
            IDirectMusicTrack* pSourceTrack = NULL;
            if ( (pTrack->m_dwFlags & DMUS_TRACKCONFIG_TRANS1_FROMSEGSTART) ||
                 (pTrack->m_dwFlags & DMUS_TRACKCONFIG_TRANS1_FROMSEGCURRENT) )
            {
                if (pFromSegment)
                {
                    hr = pFromSegment->GetTrack(guidClassID, dwTrackGroup, 0, &pSourceTrack);
                }
            }
            else if (pTrack->m_dwFlags & DMUS_TRACKCONFIG_TRANS1_TOSEGSTART)
            {
                if (pToSegment)
                {
                    hr = pToSegment->GetTrack(guidClassID, dwTrackGroup, 0, &pSourceTrack);
                }
            }
            if (pSourceTrack)
            {
                hr = pSourceTrack->Clone(mtStart, mtEnd, &pTransTrack1);
                pSourceTrack->Release();
                pSourceTrack = NULL;
            }
        }
        if (!pTransTrack1)
        {
            pTransTrack1 = pTrack->m_pTrack;
            pTransTrack1->AddRef();

        }
        if (pTransTrack1)
        {
            // Pad the track with an extra bar of header and trailer, by cloning header and trailer
            // tracks (from From and To segments, respectively --- *not* using transition flags) and
            // joining them onto the transition segment track.
            IDirectMusicTrack* pStartPadTrack = NULL;
            IDirectMusicTrack* pEndPadTrack = NULL;
            IDirectMusicTrack* pSourceTrack = NULL;
            if (pFromSegment && mtStartPad)
            {
                hr = pFromSegment->GetTrack(guidClassID, dwTrackGroup, 0, &pSourceTrack);
                if (SUCCEEDED(hr))
                {
                    pSourceTrack->Clone(mtTime - mtStartPad, mtTime, &pStartPadTrack);
                    pSourceTrack->Release();
                    pSourceTrack = NULL;
                }
            }
            if (pToSegment && mtEndPad)
            {
                hr = pToSegment->GetTrack(guidClassID, dwTrackGroup, 0, &pSourceTrack);
                if (SUCCEEDED(hr))
                {
                    pSourceTrack->Clone(0, mtEndPad, &pEndPadTrack);
                    pSourceTrack->Release();
                    pSourceTrack = NULL;
                }
            }
            IDirectMusicTrack8* pTrack8 = NULL;
            if (pEndPadTrack)
            {
                if (SUCCEEDED(pTransTrack1->QueryInterface(IID_IDirectMusicTrack8, (void**)&pTrack8)))
                {
                    if (SUCCEEDED(pTrack8->Join(pEndPadTrack, m_mtLength, (IDirectMusicSegment*)this, dwTrackGroup, NULL)))
                    {
                        fTrackPadded = true;
                        pTrack->m_dwInternalFlags |= TRACKINTERNAL_END_PADDED;
                    }
                    pTrack8->Release();
                }
                pEndPadTrack->Release();
            }
            if (SUCCEEDED(hr) && pStartPadTrack)
            {
                if (SUCCEEDED(hr = pStartPadTrack->QueryInterface(IID_IDirectMusicTrack8, (void**)&pTrack8)))
                {
                    if (SUCCEEDED(pTrack8->Join(pTransTrack1, mtStartPad, (IDirectMusicSegment*)this, dwTrackGroup, NULL)))
                    {
                        fTrackPadded = true;
                        pTrack->m_dwInternalFlags |= TRACKINTERNAL_START_PADDED;
                        pTransTrack1->Release();
                        pTransTrack1 = pStartPadTrack;
                    }
                    else
                    {
                        pStartPadTrack->Release();
                    }
                    pTrack8->Release();
                }
                else
                {
                    pStartPadTrack->Release();
                }
            }
            else if(pStartPadTrack)
            {
                pStartPadTrack->Release();
            }

            // Replace the current track with the instantiated one
            IDirectMusicTrack8* pTempTrack8 = NULL;
            pTransTrack1->QueryInterface(IID_IDirectMusicTrack8, (void**)&pTempTrack8);
            if (pTrack->m_pTrack) pTrack->m_pTrack->Release();
            pTrack->m_pTrack = pTransTrack1;
            pTrack->m_pTrack->Init( this );
            if (pTrack->m_pTrack8) pTrack->m_pTrack8->Release();
            pTrack->m_pTrack8 = pTempTrack8;
        }

        if (FAILED(hr)) break;
    }
    MUSIC_TIME mtOldLength = m_mtLength;
    if (fTrackPadded) // any tracks got joined with header/trailer info
    {
        // pad the length of the segment, to account for the header/trailer
        m_mtLength += mtStartPad + mtEndPad;
    }

    // Compose
    if (SUCCEEDED(hr))
    {
        hr = ComposeInternal();
    }

    // Back end
    if (fTrackPadded) // any tracks got joined with header/trailer info
    {
        // Trim header and trailer from each track that was joined, using Clone.
        pTrack = m_TrackList.GetHead();
        for (; pTrack; pTrack = pTrack->GetNext())
        {
            if ( (pTrack->m_pTrack) && (pTrack->m_dwInternalFlags & TRACKINTERNAL_START_PADDED) )
            {
                IDirectMusicTrack* pTempTrack = NULL;
                IDirectMusicTrack8* pTempTrack8 = NULL;
                pTrack->m_pTrack->Clone(mtStartPad, mtOldLength + mtStartPad, &pTempTrack);
                pTempTrack->QueryInterface(IID_IDirectMusicTrack8, (void**)&pTempTrack8);
                pTrack->m_pTrack->Release();
                pTrack->m_pTrack = pTempTrack;
                pTrack->m_pTrack->Init( this );
                if (pTrack->m_pTrack8) pTrack->m_pTrack8->Release();
                pTrack->m_pTrack8 = pTempTrack8;
            }
            else if ( (pTrack->m_pTrack) && (pTrack->m_dwInternalFlags & TRACKINTERNAL_END_PADDED) )
            {
                IDirectMusicTrack* pTempTrack = NULL;
                IDirectMusicTrack8* pTempTrack8 = NULL;
                pTrack->m_pTrack->Clone(0, mtOldLength, &pTempTrack);
                pTempTrack->QueryInterface(IID_IDirectMusicTrack8, (void**)&pTempTrack8);
                pTrack->m_pTrack->Release();
                pTrack->m_pTrack = pTempTrack;
                pTrack->m_pTrack->Init( this );
                if (pTrack->m_pTrack8) pTrack->m_pTrack8->Release();
                pTrack->m_pTrack8 = pTempTrack8;
            }
            pTrack->m_dwInternalFlags &= ~(TRACKINTERNAL_START_PADDED | TRACKINTERNAL_END_PADDED);
        }
        // Return the length of the segment to its original value.
         m_mtLength = mtOldLength;
    }

    return hr;
}

HRESULT CSegment::ComposeInternal()
{
    HRESULT hr = S_OK;
    TList<CTrack*> TrackList;
    // Find the composing tracks and put them in priority order
    CTrack* pTrack = m_TrackList.GetHead();
    for (; pTrack; pTrack = pTrack->GetNext())
    {
        if (pTrack->m_dwFlags & DMUS_TRACKCONFIG_COMPOSING)
        {
            TListItem<CTrack*>* pTrackItem = new TListItem<CTrack*>(pTrack);
            if (!pTrackItem)
            {
                hr = E_OUTOFMEMORY;
            }
            else
            {
                TListItem<CTrack*>* pMaster = TrackList.GetHead();
                TListItem<CTrack*>* pPrevious = NULL;
                for (; pMaster; pMaster = pMaster->GetNext())
                {
                    CTrack*& rpMaster = pMaster->GetItemValue();
                    if (pTrack->m_dwPriority > rpMaster->m_dwPriority) break;
                    pPrevious = pMaster;
                }
                if (!pPrevious) // this has higher priority than anything in the list
                {
                    TrackList.AddHead(pTrackItem);
                }
                else // lower priority than pPrevious, higher than pMaster
                {
                    pTrackItem->SetNext(pMaster);
                    pPrevious->SetNext(pTrackItem);
                }
            }
        }
        if (FAILED(hr)) break;
    }
    // Compose a new track from each from each composing track; put the results
    // in the segment (remove any existing composed tracks)
    if (SUCCEEDED(hr))
    {
        TListItem<CTrack*>* pTrackItem = TrackList.GetHead();
        for (; pTrackItem; pTrackItem = pTrackItem->GetNext())
        {
            CTrack*& rpTrack = pTrackItem->GetItemValue();
            IDirectMusicTrack8* pComposedTrack = NULL;
            hr = rpTrack->m_pTrack8->Compose((IDirectMusicSegment*)this, rpTrack->m_dwGroupBits, (IDirectMusicTrack**)&pComposedTrack);
            if (SUCCEEDED(hr))
            {
                // Remove any tracks of this type (in the same group) from the segment.
                IDirectMusicTrack* pOldTrack = NULL;
                GUID guidClassId;
                memset(&guidClassId, 0, sizeof(guidClassId));
                IPersistStream* pPersist = NULL;
                if (SUCCEEDED(pComposedTrack->QueryInterface(IID_IPersistStream, (void**)&pPersist)) )
                {
                    if (SUCCEEDED(pPersist->GetClassID(&guidClassId)) &&
                        SUCCEEDED( GetTrack( guidClassId, rpTrack->m_dwGroupBits, 0, &pOldTrack ) ) )
                    {
                        RemoveTrack( pOldTrack );
                        pOldTrack->Release();
                    }
                    pPersist->Release();
                }
                hr = InsertTrack(pComposedTrack, rpTrack->m_dwGroupBits);
                pComposedTrack->Release();
            }
            if (FAILED(hr)) break;
        }
    }
    return hr;
}


STDMETHODIMP CSegment::GetStartPoint(
            MUSIC_TIME* pmtStart    // @parm Returns the Segment's start point.
        )
{
    V_INAME(IDirectMusicSegment::GetStartPoint);

    if (m_fZombie)
    {
        Trace(2, "Warning: Call of IDirectMusicSegment::GetStartPoint after the segment has been garbage collected.\n");
        return DMUS_S_GARBAGE_COLLECTED;
    }

    *pmtStart = m_mtStart;
    return S_OK;
}

STDMETHODIMP CSegment::SetStartPoint(
            MUSIC_TIME mtStart    // @parm The start point at which to begin playing the
                                // Segment. If it is less than zero or greater than the
                                // length of the Segment, the start point will be set
                                // to zero.
        )
{
    if( (mtStart < 0) || (mtStart >= m_mtLength) )
    {
        Trace(1,"Error: Unable to set start point %ld because not within the range of the segment, which is %ld.\n",
            mtStart,m_mtLength);
        return DMUS_E_OUT_OF_RANGE;
    }

    if (m_fZombie)
    {
        Trace(2, "Warning: Call of IDirectMusicSegment::SetStartPoint after the segment has been garbage collected.\n");
        return DMUS_S_GARBAGE_COLLECTED;
    }

    m_mtStart = mtStart;
    return S_OK;
}

STDMETHODIMP CSegment::GetLoopPoints(
            MUSIC_TIME* pmtStart,    // @parm Returns the start point of the loop.
            MUSIC_TIME* pmtEnd        // @parm Returns the end point of the loop. A value of
                                    // 0 indicates that the entire Segment will loop.
        )
{
    V_INAME(IDirectMusicSegment::GetLoopPoints);
    V_PTR_WRITE(pmtStart, MUSIC_TIME);
    V_PTR_WRITE(pmtEnd, MUSIC_TIME);

    if (m_fZombie)
    {
        Trace(2, "Warning: Call of IDirectMusicSegment::GetLoopPoints after the segment has been garbage collected.\n");
        return DMUS_S_GARBAGE_COLLECTED;
    }

    *pmtStart = m_mtLoopStart;
    *pmtEnd = m_mtLoopEnd;
    return S_OK;
}

STDMETHODIMP CSegment::SetLoopPoints(
            MUSIC_TIME mtStart,    // @parm The start point at which to begin the loop.
            MUSIC_TIME mtEnd    // @parm The end point at which to begin the loop. Set
                                // <p mtStart> and <p mtEnd> to 0
                                // to loop the entire Segment.
        )
{
    if( (mtStart < 0) || (mtEnd > m_mtLength) || (mtStart > mtEnd) )
    {
        Trace(1,"Error: Unable to set loop points %ld, %ld because they are not within the range of the segment, which is %ld.\n",
            mtStart,mtStart,mtEnd,m_mtLength);
        return DMUS_E_OUT_OF_RANGE;
    }

    if (m_fZombie)
    {
        Trace(2, "Warning: Call of IDirectMusicSegment::SetLoopPoints after the segment has been garbage collected.\n");
        return DMUS_S_GARBAGE_COLLECTED;
    }

    m_mtLoopStart = mtStart;
    m_mtLoopEnd = mtEnd;
    return S_OK;
}

STDMETHODIMP CSegment::SetPChannelsUsed(
    DWORD dwNumPChannels,    // @parm The number of PChannels to set. This must be equal
                            // to the number of members in the array pointed to by
                            // <p paPChannels>.
    DWORD* paPChannels        // @parm Points to an array of PChannels. The array should
                            // have the same number of elements as specified by <p dwNumPChannels>.
    )
{
    V_INAME(IDirectMusicSegment::SetPChannelsUsed);

    if (m_fZombie)
    {
        Trace(2, "Warning: Call of IDirectMusicSegment::SetPChannelsUsed after the segment has been garbage collected.\n");
        return DMUS_S_GARBAGE_COLLECTED;
    }

    if( dwNumPChannels )
    {
        if( NULL == paPChannels )
        {
            Trace(1,"Error: Bad call to SetPChannelsUsed, pointer to PChannel array is NULL.\n");
            return E_INVALIDARG;
        }
        V_BUFPTR_READ(paPChannels, sizeof(DWORD)*dwNumPChannels);

        DWORD* padwTemp = new DWORD[dwNumPChannels]; // temp array
        DWORD dwTotalNum = 0;
        if( NULL == padwTemp )
        {
            return E_OUTOFMEMORY;
        }
        // count the number of unique PChannels are in the array. That is, the ones
        // that we don't already have stored.
        DWORD dwCount;
        for( dwCount = 0; dwCount < dwNumPChannels; dwCount++ )
        {
            DWORD dwCurrent;
            for( dwCurrent = 0; dwCurrent < m_dwNumPChannels; dwCurrent++ )
            {
                if( m_paPChannels[dwCurrent] == paPChannels[dwCount] )
                {
                    // we already track this one
                    break;
                }
            }
            if( dwCurrent >= m_dwNumPChannels )
            {
                // we're not already tracking this one
                padwTemp[dwTotalNum] = paPChannels[dwCount];
                dwTotalNum++;
            }
        }
        // dwTotalNum equals the total number of new PChannels, and they are indexed
        // inside adwTemp.
        DWORD* paNewPChannels = new DWORD[m_dwNumPChannels + dwTotalNum];
        if( NULL == paNewPChannels )
        {
            delete [] padwTemp;
            return E_OUTOFMEMORY;
        }
        if( m_paPChannels )
        {
            memcpy( paNewPChannels, m_paPChannels, sizeof(DWORD) * m_dwNumPChannels );
            delete [] m_paPChannels;
        }
        memcpy( &paNewPChannels[m_dwNumPChannels], padwTemp, sizeof(DWORD) * dwTotalNum );
        delete [] padwTemp;
        m_dwNumPChannels += dwTotalNum;
        m_paPChannels = paNewPChannels;
    }
    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
// IDirectMusicSegmentObject (private)
HRESULT CSegment::GetPChannels(
    DWORD* pdwNumPChannels,    // returns the number of pchannels
    DWORD** ppaPChannels)    // returns a pointer to the array of pchannels. Don't free this
                            // memory or keep it, as it is owned by the Segment.
{
    ASSERT(pdwNumPChannels && ppaPChannels);
    *pdwNumPChannels = m_dwNumPChannels;
    *ppaPChannels = m_paPChannels;
    return S_OK;
}

// return S_OK if the notification is active, S_FALSE if not.
HRESULT CSegment::CheckNotification( REFGUID rguid )
{
    if( NULL == FindNotification( rguid ) )
    {
        return S_FALSE;
    }
    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
// IPersist

HRESULT CSegment::GetClassID( CLSID* pClassID )
{
    V_INAME(CSegment::GetClassID);
    V_PTR_WRITE(pClassID, CLSID);

    if (m_fZombie)
    {
        Trace(2, "Warning: Call of IDirectMusicSegment::GetClassID after the segment has been garbage collected.\n");
        return DMUS_S_GARBAGE_COLLECTED;
    }

    *pClassID = CLSID_DirectMusicSegment;
    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
// IPersistStream functions

HRESULT CSegment::IsDirty()
{
    if (m_fZombie)
    {
        Trace(2, "Warning: Call of IDirectMusicSegment::IsDirty after the segment has been garbage collected.\n");
        return DMUS_S_GARBAGE_COLLECTED;
    }

    return S_FALSE;
}

#define DMUS_FOURCC_RMID_FORM    mmioFOURCC('R','M','I','D')
#define DMUS_FOURCC_data_FORM    mmioFOURCC('d','a','t','a')
#define DMUS_FOURCC_DLS_FORM    mmioFOURCC('D','L','S',' ')
#define FOURCC_SECTION_FORM     mmioFOURCC('A','A','S','E')

HRESULT CSegment::Load( IStream* pIStream )
{
    V_INAME(CSegment::Load);
    V_INTERFACE(pIStream);

    if (m_fZombie)
    {
        Trace(2, "Warning: Call of IDirectMusicSegment::Load after the segment has been garbage collected.\n");
        return DMUS_S_GARBAGE_COLLECTED;
    }

    // Save stream's current position
    LARGE_INTEGER li;
    ULARGE_INTEGER ul;

    li.HighPart = 0;
    li.LowPart = 0;

    HRESULT hr = pIStream->Seek(li, STREAM_SEEK_CUR, &ul);

    if(FAILED(hr))
    {
        return hr;
    }

    EnterCriticalSection(&m_CriticalSection);
    Clear(false);

    DWORD dwSavedPos = ul.LowPart;

    // Read first 4 bytes to determine what type of stream we
    // have been passed

    FOURCC type;
    DWORD dwRead;
    hr = pIStream->Read(&type, sizeof(FOURCC), &dwRead);

    if(SUCCEEDED(hr) && dwRead == sizeof(FOURCC))
    {
        // Check for a RIFF file
        if(type == mmioFOURCC( 'R', 'I', 'F', 'F' ))
        {
            long lFileLength = 0;
            pIStream->Read(&lFileLength, sizeof(long), &dwRead);
            // Check to see if what type of RIFF file we have
            hr = pIStream->Read(&type, sizeof(FOURCC), &dwRead);

            if(SUCCEEDED(hr) && dwRead == sizeof(FOURCC))
            {
                if(type == DMUS_FOURCC_SEGMENT_FORM)    // We have a DirectMusic segment
                {
                    // Since we now know what type of stream we need to
                    // seek back to saved position
                    li.HighPart = 0;
                    li.LowPart = dwSavedPos;
                    hr = pIStream->Seek(li, STREAM_SEEK_SET, NULL);

                    hr = LoadDirectMusicSegment(pIStream);
                }
                else if(type == FOURCC_SECTION_FORM)    // We have section
                {
                    // Since we now know what type of stream we need to seek back to saved position
                    li.HighPart = 0;
                    li.LowPart = dwSavedPos;
                    hr = pIStream->Seek(li, STREAM_SEEK_SET, NULL);

                    // Create Section
                    IDMSection* pSection;
                    if(SUCCEEDED(hr))
                    {
                        hr = ::CoCreateInstance(CLSID_DMSection,
                                                NULL,
                                                CLSCTX_INPROC,
                                                IID_IDMSection,
                                                (void**)&pSection);
                    }

                    if(SUCCEEDED(hr))
                    {
                        // Load Section
                        IPersistStream* pIPersistStream;
                        hr = pSection->QueryInterface(IID_IPersistStream, (void **)&pIPersistStream);

                        if(SUCCEEDED(hr))
                        {
                            hr = pIPersistStream->Load(pIStream);
                            pIPersistStream->Release();
                        }

                        if(SUCCEEDED(hr))
                        {
                            HRESULT hrTemp = pSection->CreateSegment(static_cast<IDirectMusicSegment*>(this));
                            if (hrTemp != S_OK)
                            {
                                hr = hrTemp;
                            }
                        }

                        pSection->Release();
                    }
                }
                else if(type == DMUS_FOURCC_RMID_FORM)    // We have an RMID MIDI file
                {
                    IDirectMusicCollection *pCollection = NULL;
                    BOOL fLoadedMIDI = FALSE;
                    // Since it's a RIFF file, it could have more than one top level chunk.
                    while (SUCCEEDED(hr) && (lFileLength > 8))
                    {
                        FOURCC dwType = 0;
                        DWORD dwLength;
                        pIStream->Read(&dwType, sizeof(FOURCC), &dwRead);
                        hr = pIStream->Read(&dwLength, sizeof(DWORD), &dwRead);
                        lFileLength -= 8;
                        if (FAILED(hr))
                        {
                            break;
                        }
                        ULARGE_INTEGER ulPosition;  // Memorize start of chunk.
                        LARGE_INTEGER liStart;
                        liStart.QuadPart = 0;
                        hr = pIStream->Seek(liStart, STREAM_SEEK_CUR, &ulPosition);
                        liStart.QuadPart = ulPosition.QuadPart;
                        if (dwType == DMUS_FOURCC_data_FORM)
                        {   // Get MIDI file header.
                            hr = pIStream->Read(&dwType, sizeof(FOURCC), &dwRead);
                            if(SUCCEEDED(hr) && (dwType == mmioFOURCC( 'M', 'T', 'h', 'd' )))
                            {
                                // Since we now know what type of stream we need to seek back to saved position
                                hr = pIStream->Seek(liStart, STREAM_SEEK_SET, NULL);

                                if(SUCCEEDED(hr))
                                {
                                    hr = CreateSegmentFromMIDIStream(pIStream,
                                                                      static_cast<IDirectMusicSegment*>(this));
                                }
                                if (SUCCEEDED(hr)) fLoadedMIDI = TRUE;
                            }
                        }
                        else if ((dwType == mmioFOURCC( 'R', 'I', 'F', 'F' ) ||
                            (dwType == mmioFOURCC( 'L', 'I', 'S', 'T' ))))
                        {
                            pIStream->Read(&dwType, sizeof(FOURCC), &dwRead);
                            if (dwType == DMUS_FOURCC_DLS_FORM)
                            {
                                hr = CoCreateInstance(CLSID_DirectMusicCollection,
                                        NULL,
                                        CLSCTX_INPROC_SERVER,
                                        IID_IDirectMusicCollection,
                                        (void**)&pCollection);
                                if (SUCCEEDED(hr))
                                {
                                    IPersistStream* pIPS;
                                    hr = pCollection->QueryInterface( IID_IPersistStream, (void**)&pIPS );
                                    if (SUCCEEDED(hr))
                                    {
                                        // We need to seek back to start of chunk
                                        liStart.QuadPart -= 8;
                                        pIStream->Seek(liStart, STREAM_SEEK_SET, NULL);

                                        hr = pIPS->Load( pIStream );
                                        pIPS->Release();
                                    }
                                    if (FAILED(hr))
                                    {
                                        pCollection->Release();
                                        pCollection = NULL;
                                    }
                                }
                            }
                        }
                        if (SUCCEEDED(hr))
                        {
                            if (dwLength & 1) ++dwLength;
                            ulPosition.QuadPart += dwLength; // Point to start of next chunk.
                            liStart.QuadPart = ulPosition.QuadPart;
                            hr = pIStream->Seek(liStart, STREAM_SEEK_SET, NULL);
                            lFileLength -= dwLength; // Decrement amount left in file.
                        }
                    }
                    if (pCollection)
                    {
                        if (fLoadedMIDI)
                        {
                            SetParam(GUID_ConnectToDLSCollection,-1,0,0,(void *) pCollection);
                        }
                        pCollection->Release();
                    }
                }
                else if (type == mmioFOURCC('W','A','V','E')) // we have a wave file
                {
                    IDirectSoundWave* pWave = NULL;
                    // Seek back to saved position
                    li.HighPart = 0;
                    li.LowPart = dwSavedPos;
                    hr = pIStream->Seek(li, STREAM_SEEK_SET, NULL);

                    // Check to see if this wave is embedded
                    if (dwSavedPos == 0)
                    {
                        // CoCreate the wave and load it from the stream
                        if (SUCCEEDED(hr))
                        {
                            hr = CoCreateInstance(CLSID_DirectSoundWave,
                                    NULL,
                                    CLSCTX_INPROC_SERVER,
                                    IID_IDirectSoundWave,
                                    (void**)&pWave);

                            if (SUCCEEDED(hr))
                            {
                                IPersistStream* pIPS = NULL;

                                hr = pWave->QueryInterface(IID_IPersistStream, (void**)&pIPS);
                                if (SUCCEEDED(hr))
                                {
                                    hr = pIPS->Load( pIStream );
                                    pIPS->Release();
                                }

                                if (FAILED(hr))
                                {
                                    pWave->Release();
                                    pWave = NULL;
                                }
                            }
                        }
                    }
                    else
                    {
                        // Have the loader load the wave object from the stream
                        DMUS_OBJECTDESC descWave;
                        ZeroMemory(&descWave, sizeof(descWave));
                        descWave.dwSize = sizeof(descWave);
                        descWave.dwValidData = DMUS_OBJ_CLASS | DMUS_OBJ_STREAM;
                        descWave.guidClass = CLSID_DirectSoundWave;
                        descWave.pStream = pIStream;
                        IDirectMusicLoader *pLoader = NULL;
                        IDirectMusicGetLoader *pGetLoader = NULL;
                        hr = pIStream->QueryInterface(IID_IDirectMusicGetLoader,(void **)&pGetLoader);
                        if (SUCCEEDED(hr))
                        {
                            if (SUCCEEDED(pGetLoader->GetLoader(&pLoader)))
                            {
                                hr = pLoader->GetObject(&descWave, IID_IDirectSoundWave, (void **)&pWave);
                                descWave.pStream = NULL;
                                descWave.dwValidData &= ~DMUS_OBJ_STREAM;
                                if (SUCCEEDED(hr))
                                {
                                    IDirectMusicObject* pObject = NULL;
                                    hr = pWave->QueryInterface(IID_IDirectMusicObject, (void **)&pObject);
                                    if (SUCCEEDED(hr))
                                    {
                                        // set this object to be a segment with the same GUID
                                        pObject->GetDescriptor(&descWave);
                                        descWave.guidClass = CLSID_DirectMusicSegment;
                                        SetDescriptor(&descWave);
                                        pObject->Release();
                                    }
                                }
                                pLoader->Release();
                            }
                            pGetLoader->Release();
                        }
                    }

                    if(pWave)
                    {

                        // CoCreate a wave track
                        IDirectMusicTrack* pWaveTrack = NULL;
                        if (SUCCEEDED(hr))
                        {
                            hr = ::CoCreateInstance(CLSID_DirectMusicWaveTrack,
                                                    NULL,
                                                    CLSCTX_INPROC,
                                                    IID_IDirectMusicTrack,
                                                    (void**)&pWaveTrack);
                        }

                        // Add the wave object to the wave track, and insert the track in the segment.
                        if (SUCCEEDED(hr))
                        {
                            IPrivateWaveTrack* pPrivateWave = NULL;
                            hr = pWaveTrack->QueryInterface(IID_IPrivateWaveTrack, (void**)&pPrivateWave);
                            if (SUCCEEDED(hr))
                            {
                                REFERENCE_TIME rt = 0;
                                hr = pPrivateWave->AddWave(pWave, 0, 0, 0, &rt);
                                if (SUCCEEDED(hr))
                                {
                                    SetClockTimeDuration(rt * REF_PER_MIL);
                                    SetFlags(DMUS_SEGIOF_REFLENGTH);
                                }
                                InsertTrack(pWaveTrack, 1);
                                SetTrackConfig(CLSID_DirectMusicWaveTrack, 1, 0, DMUS_TRACKCONFIG_DEFAULT | DMUS_TRACKCONFIG_PLAY_CLOCKTIME,0);
                                pPrivateWave->Release();
                            }
                        }

                        // Clean up anything that's still hanging around
                        if (pWaveTrack) pWaveTrack->Release();
                        if (pWave) pWave->Release();
                    }
                }
            }
            else
            {
                hr = DMUS_E_CANNOTREAD;
            }
        }
        // Check for a template file
        else if(type == mmioFOURCC('L', 'P', 'T', 's'))
        {
            // Since we now know what type of stream we need to seek back to saved position
            li.HighPart = 0;
            li.LowPart = dwSavedPos;
            hr = pIStream->Seek(li, STREAM_SEEK_SET, NULL);

            // Create Template
            IDMTempl* pTemplate;
            if(SUCCEEDED(hr))
            {
                hr = ::CoCreateInstance(CLSID_DMTempl,
                                        NULL,
                                        CLSCTX_INPROC,
                                        IID_IDMTempl,
                                        (void**)&pTemplate);
            }

            if(SUCCEEDED(hr))
            {
                // Load Template
                IPersistStream* pIPersistStream;
                hr = pTemplate->QueryInterface(IID_IPersistStream, (void **)&pIPersistStream);

                if(SUCCEEDED(hr))
                {
                    hr = pIPersistStream->Load(pIStream);
                    pIPersistStream->Release();
                }

                if(SUCCEEDED(hr))
                {
                    hr = pTemplate->CreateSegment(static_cast<IDirectMusicSegment*>(this));
                }

                pTemplate->Release();
            }
        }
        // Check for normal MIDI file
        else if(type == mmioFOURCC('M', 'T', 'h', 'd'))
        {
            // Since we now know what type of stream we need to seek back to saved position
            li.HighPart = 0;
            li.LowPart = dwSavedPos;
            hr = pIStream->Seek(li, STREAM_SEEK_SET, NULL);

            if(SUCCEEDED(hr))
            {
                hr = CreateSegmentFromMIDIStream(pIStream,
                                                  static_cast<IDirectMusicSegment*>(this));
            }
        }
        else
        {
            // Not a DirectMusic Segment file, MIDI file or section or
            // template; unsupported
            Trace(1,"Error: Segment unable to parse file. Must be segment, midi, wave, or rmi file format.\n");
            hr = DMUS_E_UNSUPPORTED_STREAM;
        }
    }
    else
    {
        hr = DMUS_E_CANNOTREAD;
    }
    if( SUCCEEDED(hr) )
    {
        m_dwValidData |= DMUS_OBJ_LOADED;
    }
    LeaveCriticalSection(&m_CriticalSection);
    return hr;
}


HRESULT CSegment::Save( IStream* pIStream, BOOL fClearDirty )
{
    return E_NOTIMPL;
}

HRESULT CSegment::GetSizeMax( ULARGE_INTEGER FAR* pcbSize )
{
    return E_NOTIMPL;
}

HRESULT CSegment::LoadDirectMusicSegment(IStream* pIStream)
{
    // Argument validation
    assert(pIStream);
    CRiffParser Parser(pIStream);
    RIFFIO ckMain;
    HRESULT hr = S_OK;
    Parser.EnterList(&ckMain);
    if (Parser.NextChunk(&hr))
    {
        if (ckMain.fccType == DMUS_FOURCC_SEGMENT_FORM)
        {
            RIFFIO ckNext;    // Descends into the next chunk.
            RIFFIO ckChild;   // For scanning through children lists.
            IDirectMusicContainer *pContainer = NULL; // For handling embedded container with linked objects.
            Parser.EnterList(&ckNext);
            while(Parser.NextChunk(&hr))
            {
                switch(ckNext.ckid)
                {
                case DMUS_FOURCC_SEGMENT_CHUNK:
                    DMUS_IO_SEGMENT_HEADER ioSegHdr;
                    ioSegHdr.rtLoopStart = 0;
                    ioSegHdr.rtLoopEnd = 0;
                    ioSegHdr.rtLength = 0;
                    ioSegHdr.dwFlags = 0;
                    hr = Parser.Read(&ioSegHdr, sizeof(DMUS_IO_SEGMENT_HEADER));
                    if(SUCCEEDED(hr))
                    {
                        m_dwResolution = ioSegHdr.dwResolution;
                        m_mtLength = ioSegHdr.mtLength;
                        m_mtStart = ioSegHdr.mtPlayStart;
                        m_mtLoopStart = ioSegHdr.mtLoopStart;
                        m_mtLoopEnd = ioSegHdr.mtLoopEnd;
                        m_dwRepeats = ioSegHdr.dwRepeats;
                        m_dwSegFlags = ioSegHdr.dwFlags;
                        if (m_dwSegFlags & DMUS_SEGIOF_REFLENGTH)
                        {
                            m_rtLength = ioSegHdr.rtLength;
                        }
                        else
                        {
                            m_rtLength = 0;
                        }
                        if (m_dwSegFlags & DMUS_SEGIOF_REFLOOP)
                        {
                            m_rtLoopStart = ioSegHdr.rtLoopStart;
                            m_rtLoopEnd = ioSegHdr.rtLoopEnd;
                        }
                        else
                        {
                            m_rtLoopStart = m_rtLoopEnd = 0;
                        }
                    }
                    break;

                case DMUS_FOURCC_GUID_CHUNK:
                    if( ckNext.cksize == sizeof(GUID) )
                    {
                        hr = Parser.Read(&m_guidObject, sizeof(GUID));
                        if( SUCCEEDED(hr) )
                        {
                            m_dwValidData |= DMUS_OBJ_OBJECT;
                        }
                    }
                    break;

                case DMUS_FOURCC_VERSION_CHUNK:
                    hr = Parser.Read(&m_vVersion, sizeof(DMUS_VERSION) );
                    if( SUCCEEDED(hr) )
                    {
                        m_dwValidData |= DMUS_OBJ_VERSION;
                    }
                    break;

                case DMUS_FOURCC_CATEGORY_CHUNK:
                    hr = Parser.Read( m_wszCategory, sizeof(WCHAR)*DMUS_MAX_CATEGORY );
                    if( SUCCEEDED(hr) )
                    {
                        m_dwValidData |= DMUS_OBJ_CATEGORY;
                    }
                    break;

                case DMUS_FOURCC_DATE_CHUNK:
                    if( sizeof(FILETIME) == ckNext.cksize )
                    {
                        hr = Parser.Read( &m_ftDate, sizeof(FILETIME));
                        if( SUCCEEDED(hr) )
                        {
                            m_dwValidData |= DMUS_OBJ_DATE;
                        }
                    }
                    break;

                case FOURCC_LIST:
                case FOURCC_RIFF:
                    switch(ckNext.fccType)
                    {
                        case DMUS_FOURCC_UNFO_LIST:
                            Parser.EnterList(&ckChild);
                            while (Parser.NextChunk(&hr))
                            {
                                switch( ckChild.ckid )
                                {
                                    case DMUS_FOURCC_UNAM_CHUNK:
                                    {
                                        hr = Parser.Read(&m_wszName, sizeof(m_wszName));
                                        if(SUCCEEDED(hr) )
                                        {
                                            m_dwValidData |= DMUS_OBJ_NAME;
                                        }
                                        break;
                                    }
                                    default:
                                        break;
                                }
                            }
                            Parser.LeaveList();
                            break;
                        case DMUS_FOURCC_CONTAINER_FORM:
                            // An embedded container RIFF chunk which includes a bunch
                            // of objects referenced by the segment. This should precede the
                            // tracks and gets loaded prior to the tracks. Loading this
                            // causes all of its objects to get SetObject'd in the loader,
                            // so they later get pulled in as requested by the tracks.
                            // After the tracks are loaded, the loader references are
                            // released by a call to release the IDirectMusicContainer.
                            {
                                DMUS_OBJECTDESC Desc;
                                IDirectMusicLoader *pLoader;
                                IDirectMusicGetLoader *pGetLoader;
                                HRESULT hrTemp = pIStream->QueryInterface(IID_IDirectMusicGetLoader,(void **) &pGetLoader);
                                if (SUCCEEDED(hrTemp))
                                {
                                    if (SUCCEEDED(pGetLoader->GetLoader(&pLoader)))
                                    {
                                        // Move back stream's current position
                                        Parser.SeekBack();
                                        Desc.dwSize = sizeof(Desc);
                                        Desc.dwValidData = DMUS_OBJ_CLASS | DMUS_OBJ_STREAM;
                                        Desc.guidClass = CLSID_DirectMusicContainer;
                                        Desc.pStream = pIStream;
                                        pLoader->GetObject(&Desc,IID_IDirectMusicContainer,(void **) &pContainer);
                                        if (pContainer)
                                        {
                                            // Don't cache the container object! We want it and the
                                            // objects it references to go away when the segment is done loading.
                                            IDirectMusicObject *pObject = NULL;
                                            pContainer->QueryInterface(IID_IDirectMusicObject,(void **)&pObject);
                                            if (pObject)
                                            {
                                                pLoader->ReleaseObject(pObject);
                                                pObject->Release();
                                            }
                                        }
                                        // Now, seek to the end of this chunk.
                                        Parser.SeekForward();
                                        pLoader->Release();
                                    }
                                    pGetLoader->Release();
                                }
                            }
                            break;
                        case DMUS_FOURCC_TRACK_LIST:
                            Parser.EnterList(&ckChild);
                            while(Parser.NextChunk(&hr))
                            {
                                if ((ckChild.ckid == FOURCC_RIFF) && (ckChild.fccType == DMUS_FOURCC_TRACK_FORM))
                                {
                                    hr = LoadTrack(&Parser);
                                }
                            }
                            Parser.LeaveList();
                            break;
                        case DMUS_FOURCC_TOOLGRAPH_FORM:
                            hr = LoadGraph(&Parser,&m_pGraph);
                            break;
                        case DMUS_FOURCC_AUDIOPATH_FORM:
                            // Move back to start of this chunk.
                            Parser.SeekBack();
                            hr = LoadAudioPath(pIStream);
                            // Now, seek to the end of this chunk.
                            Parser.SeekForward();
                            break;
                    }
                    break;
                }
            }
            Parser.LeaveList();
            if (pContainer)
            {
                pContainer->Release();
            }
        }
        else
        {
            Trace(1,"Error: Unknown file format.\n");
            hr = DMUS_E_DESCEND_CHUNK_FAIL;
        }
    }
    Parser.LeaveList();
    if (SUCCEEDED(hr) && Parser.ComponentFailed())
    {
        Trace(1,"Warning: Segment successfully loaded but one or more tracks within it did not.\n");
        hr = DMUS_S_PARTIALLOAD;
    }

    return hr;
}

HRESULT CSegment::LoadTrack(CRiffParser *pParser)
{
    BOOL fHeaderRead = FALSE;

    DMUS_IO_TRACK_HEADER ioTrackHdr;
    DMUS_IO_TRACK_EXTRAS_HEADER ioTrackExtrasHdr;
    ioTrackExtrasHdr.dwPriority = 0;
    ioTrackExtrasHdr.dwFlags = DMUS_TRACKCONFIG_DEFAULT;
    ioTrackHdr.ckid = 0;
    ioTrackHdr.fccType = 0;
    ioTrackHdr.dwPosition = 0;

    RIFFIO ckNext;
    HRESULT hr = S_OK;
    pParser->EnterList(&ckNext);
    while(pParser->NextChunk(&hr))
    {
        if (ckNext.ckid == DMUS_FOURCC_TRACK_CHUNK)
        {
            fHeaderRead = TRUE;
            hr = pParser->Read(&ioTrackHdr, sizeof(DMUS_IO_TRACK_HEADER));
            if(ioTrackHdr.ckid == 0 && ioTrackHdr.fccType == NULL)
            {
                Trace(1,"Error: Invalid track header in Segment.\n");
                hr = DMUS_E_INVALID_TRACK_HDR;
            }
        }
        else if (ckNext.ckid == DMUS_FOURCC_TRACK_EXTRAS_CHUNK)
        {
            hr = pParser->Read(&ioTrackExtrasHdr, sizeof(DMUS_IO_TRACK_EXTRAS_HEADER));
        }
        else if((((ckNext.ckid == FOURCC_LIST) || (ckNext.ckid == FOURCC_RIFF))
            && ckNext.fccType == ioTrackHdr.fccType) ||
            (ckNext.ckid == ioTrackHdr.ckid))
        {
            if (fHeaderRead)
            {
                // Okay, this is the chunk we are looking for.
                // Seek back to start of chunk.
                pParser->SeekBack();
                // Let the parser know it's okay to fail this.
                pParser->EnteringComponent();
                hr = CreateTrack(ioTrackHdr, ioTrackExtrasHdr.dwFlags, ioTrackExtrasHdr.dwPriority, pParser->GetStream());
                // Now, make sure we are at the end of the chunk.
                pParser->SeekForward();
            }
            else
            {
                Trace(1,"Error: Invalid track in Segment - track header is not before track data.\n");
                hr = DMUS_E_TRACK_HDR_NOT_FIRST_CK;
            }

        }
    }
    pParser->LeaveList();
    return hr;
}

HRESULT CSegment::CreateTrack(DMUS_IO_TRACK_HEADER& ioTrackHdr, DWORD dwFlags, DWORD dwPriority, IStream *pStream)
{
    assert(pStream);

    IDirectMusicTrack* pDMTrack = NULL;
    HRESULT hrTrack = S_OK;
    HRESULT hr = CoCreateInstance(ioTrackHdr.guidClassID,
                                  NULL,
                                  CLSCTX_INPROC,
                                  IID_IDirectMusicTrack,
                                  (void**)&pDMTrack);

    IPersistStream *pIPersistStream = NULL;

    if(SUCCEEDED(hr))
    {
        hr = pDMTrack->QueryInterface(IID_IPersistStream, (void **)&pIPersistStream);
    }

    if(SUCCEEDED(hr))
    {
        hr = hrTrack = pIPersistStream->Load(pStream);
    }

    if(SUCCEEDED(hr))
    {
        hr = InsertTrack(pDMTrack, ioTrackHdr.dwGroup, dwFlags, dwPriority, ioTrackHdr.dwPosition);
    }

    if(pIPersistStream)
    {
        pIPersistStream->Release();
    }

    if(pDMTrack)
    {
        pDMTrack->Release();
    }

    if (hr == S_OK && hrTrack != S_OK)
    {
        hr = hrTrack;
    }
    return hr;
}

HRESULT CSegment::LoadGraph(CRiffParser *pParser,CGraph **ppGraph)
{
    CGraph *pGraph = new CGraph;
    if (pGraph == NULL) {
        return E_OUTOFMEMORY;
    }

    HRESULT hr = pGraph->Load(pParser);

    EnterCriticalSection(&m_CriticalSection);
    if(*ppGraph)
    {
        (*ppGraph)->Release();
    }
    *ppGraph = pGraph;
    LeaveCriticalSection(&m_CriticalSection);

    return hr;
}

HRESULT CSegment::LoadAudioPath(IStream *pStream)
{
    assert(pStream);

    CAudioPathConfig *pPath = new CAudioPathConfig;
    if (pPath == NULL) {
        return E_OUTOFMEMORY;
    }

    HRESULT hr = pPath->Load(pStream);

    if (FAILED(hr))
    {
        Trace(1,"Segment failed loading embedded AudioPath Configuration\n");
    }

    EnterCriticalSection(&m_CriticalSection);
    if(m_pAudioPathConfig)
    {
        m_pAudioPathConfig->Release();
    }
    m_pAudioPathConfig = pPath;
    if (m_dwVersion < 8) m_dwVersion = 8;
    LeaveCriticalSection(&m_CriticalSection);

    return hr;
}

/////////////////////////////////////////////////////////////////////////////
// IDirectMusicObject

STDMETHODIMP CSegment::GetDescriptor(LPDMUS_OBJECTDESC pDesc)
{
    // Argument validation
    V_INAME(CSegment::GetDescriptor);
    V_PTR_WRITE(pDesc, DMUS_OBJECTDESC);

    if (m_fZombie)
    {
        Trace(2, "Warning: Call of IDirectMusicSegment::GetDescriptor after the segment has been garbage collected.\n");
        return DMUS_S_GARBAGE_COLLECTED;
    }

    if (pDesc->dwSize)
    {
        V_STRUCTPTR_WRITE(pDesc, DMUS_OBJECTDESC);
    }
    else
    {
        pDesc->dwSize = sizeof(DMUS_OBJECTDESC);
    }

    pDesc->guidClass = CLSID_DirectMusicSegment;
    pDesc->guidObject = m_guidObject;
    pDesc->ftDate = m_ftDate;
    pDesc->vVersion = m_vVersion;
    memcpy( pDesc->wszName, m_wszName, sizeof(m_wszName) );
    memcpy( pDesc->wszCategory, m_wszCategory, sizeof(m_wszCategory) );
    memcpy( pDesc->wszFileName, m_wszFileName, sizeof(m_wszFileName) );
    pDesc->dwValidData = ( m_dwValidData | DMUS_OBJ_CLASS );

    return S_OK;
}

STDMETHODIMP CSegment::SetDescriptor(LPDMUS_OBJECTDESC pDesc)
{
    // Argument validation
    V_INAME(CSegment::SetDescriptor);
    V_PTR_READ(pDesc, DMUS_OBJECTDESC);

    if (m_fZombie)
    {
        Trace(2, "Warning: Call of IDirectMusicSegment::SetDescriptor after the segment has been garbage collected.\n");
        return DMUS_S_GARBAGE_COLLECTED;
    }

    if (pDesc->dwSize)
    {
        V_STRUCTPTR_READ(pDesc, DMUS_OBJECTDESC);
    }

    HRESULT hr = E_INVALIDARG;
    DWORD dw = 0;

    if( pDesc->dwSize >= sizeof(DMUS_OBJECTDESC) )
    {
        if(pDesc->dwValidData & DMUS_OBJ_CLASS)
        {
            dw |= DMUS_OBJ_CLASS;
        }

        if(pDesc->dwValidData & DMUS_OBJ_LOADED)
        {
            dw |= DMUS_OBJ_LOADED;
        }

        if( pDesc->dwValidData & DMUS_OBJ_OBJECT )
        {
            m_guidObject = pDesc->guidObject;
            dw |= DMUS_OBJ_OBJECT;
        }
        if( pDesc->dwValidData & DMUS_OBJ_NAME )
        {
            memcpy( m_wszName, pDesc->wszName, sizeof(WCHAR)*DMUS_MAX_NAME );
            dw |= DMUS_OBJ_NAME;
        }
        if( pDesc->dwValidData & DMUS_OBJ_CATEGORY )
        {
            memcpy( m_wszCategory, pDesc->wszCategory, sizeof(WCHAR)*DMUS_MAX_CATEGORY );
            dw |= DMUS_OBJ_CATEGORY;
        }
        if( ( pDesc->dwValidData & DMUS_OBJ_FILENAME ) ||
            ( pDesc->dwValidData & DMUS_OBJ_FULLPATH ) )
        {
            memcpy( m_wszFileName, pDesc->wszFileName, sizeof(WCHAR)*DMUS_MAX_FILENAME );
            dw |= (pDesc->dwValidData & (DMUS_OBJ_FILENAME | DMUS_OBJ_FULLPATH));
        }
        if( pDesc->dwValidData & DMUS_OBJ_VERSION )
        {
            m_vVersion = pDesc->vVersion;
            dw |= DMUS_OBJ_VERSION;
        }
        if( pDesc->dwValidData & DMUS_OBJ_DATE )
        {
            m_ftDate = pDesc->ftDate;
            dw |= DMUS_OBJ_DATE;
        }
        m_dwValidData |= dw;
        if( pDesc->dwValidData & (~dw) )
        {
            Trace(2,"Warning: Segment::SetDescriptor was not able to handle all passed fields, dwValidData bits %lx.\n",pDesc->dwValidData & (~dw));
            hr = S_FALSE; // there were extra fields we didn't parse;
            pDesc->dwValidData = dw;
        }
        else
        {
            hr = S_OK;
        }
    }
    else
    {
        Trace(1,"Error: Unable to set segment descriptor, size field is too small.\n");
    }
    return hr;
}

STDMETHODIMP CSegment::ParseDescriptor(LPSTREAM pStream, LPDMUS_OBJECTDESC pDesc)
{
    V_INAME(CSegment::ParseDescriptor);
    V_INTERFACE(pStream);
    V_PTR_WRITE(pDesc, DMUS_OBJECTDESC);
    if (pDesc->dwSize)
    {
        V_STRUCTPTR_WRITE(pDesc, DMUS_OBJECTDESC);
    }
    else
    {
        pDesc->dwSize = sizeof(DMUS_OBJECTDESC);
    }

    if (m_fZombie)
    {
        Trace(2, "Warning: Call of IDirectMusicSegment::ParseDescriptor after the segment has been garbage collected.\n");
        return DMUS_S_GARBAGE_COLLECTED;
    }

    HRESULT hret = E_FAIL;
    // Save stream's current position
    LARGE_INTEGER li;
    ULARGE_INTEGER ul;

    li.HighPart = 0;
    li.LowPart = 0;

    HRESULT hr = pStream->Seek(li, STREAM_SEEK_CUR, &ul);

    if(FAILED(hr))
    {
        return hr;
    }
    pDesc->dwValidData = 0;
    DWORD dwSavedPos = ul.LowPart;

    // Read first 4 bytes to determine what type of stream we
    // have been passed

    FOURCC type;
    DWORD dwRead;
    hr = pStream->Read(&type, sizeof(FOURCC), &dwRead);

    if(SUCCEEDED(hr) && dwRead == sizeof(FOURCC))
    {
        // Check for a RIFF file
        if(type == mmioFOURCC( 'R', 'I', 'F', 'F' ))
        {
            // Check to see if what type of RIFF file we have
            li.HighPart = 0;
            li.LowPart = dwSavedPos + 8; // Length needed to seek to form type of RIFF chunk

            hr = pStream->Seek(li, STREAM_SEEK_SET, NULL);
            if(SUCCEEDED(hr))
            {
                hr = pStream->Read(&type, sizeof(FOURCC), &dwRead);
            }

            if(SUCCEEDED(hr) && dwRead == sizeof(FOURCC))
            {
                if(type == DMUS_FOURCC_SEGMENT_FORM)    // We have a DirectMusic segment
                {
                    // Since we now know what type of stream we need to
                    // seek back to saved position
                    li.HighPart = 0;
                    li.LowPart = dwSavedPos;
                    hr = pStream->Seek(li, STREAM_SEEK_SET, NULL);
                    if( SUCCEEDED(hr) ) // should always succeed.
                    {
                        hret = ParseSegment(pStream, pDesc);
                    }
                }
                else if(type == FOURCC_SECTION_FORM)    // We have section
                {
                    long lTemp;
                    hr = pStream->Read(&lTemp, sizeof(long), &dwRead);
                    if( lTemp == mmioFOURCC('s','e','c','n') )
                    {
                        hr = pStream->Read(&lTemp, sizeof(long), &dwRead); // length
                        hr = pStream->Read(&lTemp, sizeof(long), &dwRead); // time
                        if( SUCCEEDED(hr) && (dwRead == sizeof(long) ))
                        {
                            hr = pStream->Read(&pDesc->wszName, sizeof(wchar_t)*16, &dwRead);
                            if(SUCCEEDED(hr) && (dwRead == sizeof(wchar_t)*16))
                            {
                                pDesc->dwValidData |= DMUS_OBJ_NAME;
                            }
                        }
                        hret = S_OK;
                    }
                }
                else if (type == mmioFOURCC('W','A','V','E')) // we have a wave file
                {
                    // Create a wave object and have it parse the file.
                    IDirectMusicObject *pObject;
                    hret = CoCreateInstance(CLSID_DirectSoundWave,NULL,CLSCTX_INPROC_SERVER,
                        IID_IDirectMusicObject,(void **) &pObject);
                    if(SUCCEEDED(hret))
                    {
                        // seek back to saved position
                        li.HighPart = 0;
                        li.LowPart = dwSavedPos;
                        hret = pStream->Seek(li, STREAM_SEEK_SET, NULL);
                        if (SUCCEEDED(hret))
                        {
                            hret = pObject->ParseDescriptor(pStream,pDesc);
                        }
                        pObject->Release();
                    }
                }
                // Check to see if we have a MIDI file
                else
                {
                    li.HighPart = 0;
                    li.LowPart = dwSavedPos + 20; // Length needed to seek to start of normal MIDI file
                                                  // contained within the Riff chunk

                    hr = pStream->Seek(li, STREAM_SEEK_SET, NULL);

                    if(SUCCEEDED(hr))
                    {
                        hr = pStream->Read(&type, sizeof(FOURCC), &dwRead);
                    }

                    if(SUCCEEDED(hr) && dwRead == sizeof(FOURCC))
                    {
                        if(type == mmioFOURCC( 'M', 'T', 'h', 'd' ))
                        {
                            hret = S_OK;
                        }
                    }
                }
            }
        }
        // Check for a template file
        else if(type == mmioFOURCC('L', 'P', 'T', 's'))
        {
            hret = S_OK;
        }
        // Check for normal MIDI file
        else if(type == mmioFOURCC('M', 'T', 'h', 'd'))
        {
            hret = S_OK;
        }
    }
    if (SUCCEEDED(hret))
    {
        pDesc->dwValidData |= DMUS_OBJ_CLASS;
        pDesc->guidClass = CLSID_DirectMusicSegment;
    }
#ifdef DBG
    if (hret == E_FAIL)
    {
        Trace(1,"Error: Segment unable to parse file - unknown format.\n");
    }
#endif
    return hret;
}

HRESULT CSegment::ParseSegment(IStream* pIStream, LPDMUS_OBJECTDESC pDesc)
{
    CRiffParser Parser(pIStream);
    RIFFIO ckMain;
    RIFFIO ckNext;
    RIFFIO ckUNFO;
    HRESULT hr = S_OK;

    Parser.EnterList(&ckMain);
    if (Parser.NextChunk(&hr) && (ckMain.fccType == DMUS_FOURCC_SEGMENT_FORM))
    {
        Parser.EnterList(&ckNext);
        while(Parser.NextChunk(&hr))
        {
            switch(ckNext.ckid)
            {
            case DMUS_FOURCC_GUID_CHUNK:
                hr = Parser.Read( &pDesc->guidObject, sizeof(GUID) );
                if( SUCCEEDED(hr) )
                {
                    pDesc->dwValidData |= DMUS_OBJ_OBJECT;
                }
                break;
            case DMUS_FOURCC_VERSION_CHUNK:
                hr = Parser.Read( &pDesc->vVersion, sizeof(DMUS_VERSION) );
                if( SUCCEEDED(hr) )
                {
                    pDesc->dwValidData |= DMUS_OBJ_VERSION;
                }
                break;

            case DMUS_FOURCC_CATEGORY_CHUNK:
                hr = Parser.Read( &pDesc->wszCategory, sizeof(pDesc->wszCategory) );
                if( SUCCEEDED(hr) )
                {
                    pDesc->dwValidData |= DMUS_OBJ_CATEGORY;
                }
                break;

            case DMUS_FOURCC_DATE_CHUNK:
                hr = Parser.Read( &pDesc->ftDate, sizeof(FILETIME) );
                if( SUCCEEDED(hr))
                {
                    pDesc->dwValidData |= DMUS_OBJ_DATE;
                }
                break;
            case FOURCC_LIST:
                switch(ckNext.fccType)
                {
                case DMUS_FOURCC_UNFO_LIST:
                    Parser.EnterList(&ckUNFO);
                    while (Parser.NextChunk(&hr))
                    {
                        switch( ckUNFO.ckid )
                        {
                        case DMUS_FOURCC_UNAM_CHUNK:
                        {
                            hr = Parser.Read(&pDesc->wszName, sizeof(pDesc->wszName));
                            if(SUCCEEDED(hr) )
                            {
                                pDesc->dwValidData |= DMUS_OBJ_NAME;
                            }
                            break;
                        }
                        default:
                            break;
                        }
                    }
                    Parser.LeaveList();
                    break;
                }
                break;

            default:
                break;

            }
        }
        Parser.LeaveList();
    }
    return hr;
}

void CSegmentList::Clear()
{
    CSegment *pSeg;
    while (pSeg = RemoveHead())
    {
        pSeg->SetNext(NULL);
        pSeg->m_pSong = NULL;
        pSeg->Release();
    }
}

inline REFERENCE_TIME ConvertToReference(MUSIC_TIME mtSpan, double dblTempo)
{
    REFERENCE_TIME rtTemp = mtSpan;
    rtTemp *= 600000000;
    rtTemp += (DMUS_PPQ / 2);
    rtTemp /= DMUS_PPQ;
    rtTemp = (REFERENCE_TIME)(rtTemp / dblTempo);
    return rtTemp;
}

inline MUSIC_TIME ConvertToMusic(REFERENCE_TIME rtSpan, double dblTempo)
{
    rtSpan *= DMUS_PPQ;
    rtSpan = (REFERENCE_TIME)(rtSpan * dblTempo);
    rtSpan += 300000000;
    rtSpan /= 600000000;
#ifdef DBG
    if ( rtSpan & 0xFFFFFFFF00000000 )
    {
        Trace(1,"Error: Invalid Reference to Music time conversion resulted in overflow.\n");
    }
#endif
    return (MUSIC_TIME) (rtSpan & 0xFFFFFFFF);
}

HRESULT CSegment::MusicToReferenceTime(MUSIC_TIME mtTime, REFERENCE_TIME *prtTime)
{
    double dbl = 120;
    MUSIC_TIME mtTempo = 0;
    REFERENCE_TIME rtTempo = 0;
    MUSIC_TIME mtNext = 0;
    PrivateTempo Tempo;
    HRESULT hr;

    do
    {
        hr = GetParam(GUID_PrivateTempoParam, -1, 0, mtTempo, &mtNext,(void *)&Tempo );
        if (hr == S_OK)
        {
            dbl = Tempo.dblTempo;
            if (Tempo.fLast || mtTempo + mtNext >= mtTime) break;
            rtTempo += ConvertToReference(mtNext, dbl);
            mtTempo += mtNext;
        }

    } while (hr == S_OK);

    *prtTime = rtTempo + ConvertToReference(mtTime - mtTempo, dbl);
    return S_OK;
}

HRESULT CSegment::ReferenceToMusicTime(REFERENCE_TIME rtTime, MUSIC_TIME *pmtTime)
{
    double dbl = 120;
    MUSIC_TIME mtTempo = 0;
    REFERENCE_TIME rtTempo = 0;
    MUSIC_TIME mtNext = 0;
    PrivateTempo Tempo;
    HRESULT hr;

    do
    {
        hr = GetParam(GUID_PrivateTempoParam, -1, 0, mtTempo, &mtNext,(void *)&Tempo );
        if (hr == S_OK)
        {
            REFERENCE_TIME rtNext = rtTempo + ConvertToReference(mtNext, dbl);
            dbl = Tempo.dblTempo;
            if (Tempo.fLast || rtNext >= rtTime) break;
            rtTempo = rtNext;
            mtTempo += mtNext;
        }

    } while (hr == S_OK);

    *pmtTime = mtTempo + ConvertToMusic(rtTime - rtTempo, dbl);
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\XDmime\dmsstobj.cpp ===
// Copyright (c) 1998-2001 Microsoft Corporation
// dmsstobj.cpp : Implementation of CSegState

#include "dmime.h"
#include "DMSStObj.h"
#include "dmsegobj.h"
#include "song.h"
#include "dmgraph.h"
#include "dmperf.h"
#include "dmusici.h"
#include "Validate.h"
#include "debug.h"
#include "dmscriptautguids.h"
#include "paramtrk.h"
#define ASSERT assert

CSegState::CSegState()
{
    InitializeCriticalSection(&m_CriticalSection);
    InterlockedIncrement(&g_cComponent);
    m_fDelayShutDown = false;
    m_fInPlay = false;
    m_cRef = 1;
    m_dwPlayTrackFlags = DMUS_TRACKF_START | DMUS_TRACKF_SEEK;
    m_dwFirstTrackID = 0; 
    m_dwLastTrackID = 0;
    m_mtEndTime = 0;
    m_mtAbortTime = 0;
    m_mtOffset = 0;
    m_rtOffset = 0;
    m_rtEndTime = 0;
    m_mtStartPoint = 0;
    m_rtStartPoint = 0;
    m_mtSeek = 0;
    m_rtSeek = 0;
    m_rtFirstLoopStart = 0;
    m_rtCurLoopStart = 0;
    m_rtCurLoopEnd = 0;
    m_mtFirstLoopStart = 0;
    m_mtLength = 0;
    m_rtLength = 0;
    m_mtLoopStart = 0;
    m_mtLoopEnd = 0;
    m_mtCurLoopStart = 0;
    m_mtCurLoopEnd = 0;
    m_rtLoopStart = 0;
    m_rtLoopEnd = 0;
    m_dwRepeatsLeft = 0;
    m_dwRepeats = 0;
    m_dwVersion = 0; // Init to 6.1 behavior.
    m_fPrepped = FALSE;
    m_fCanStop = TRUE;
    m_rtGivenStart = -1;
    m_mtResolvedStart = -1;
    m_mtLastPlayed = 0;
    m_rtLastPlayed = 0;
    m_mtStopTime = 0;
    m_dwPlaySegFlags = 0;
    m_dwSegFlags = 0;
    m_fStartedPlay = FALSE;
    m_pUnkDispatch = NULL;
    m_pSegment = NULL;
    m_pPerformance = NULL;
    m_pAudioPath = NULL;
    m_pGraph = NULL;
    m_fSongMode = FALSE;
    m_pSongSegState = NULL;
    TraceI(2, "SegmentState %lx created\n", this );
}

CSegState::~CSegState()
{
    if (m_pUnkDispatch)
        m_pUnkDispatch->Release(); // free IDispatch implementation we may have borrowed
    if (m_pAudioPath) m_pAudioPath->Release();
    if (m_pGraph) m_pGraph->Release();
    if (m_pSongSegState) m_pSongSegState->Release();
    InterlockedDecrement(&g_cComponent);
    DeleteCriticalSection(&m_CriticalSection);
    TraceI(2, "SegmentState %lx destroyed with %ld releases outstanding\n", this, m_cRef );
}


STDMETHODIMP CSegState::QueryInterface(
    const IID &iid,   // @parm Interface to query for
    void **ppv)       // @parm The requested interface will be returned here
{
    V_INAME(CSegState::QueryInterface);
    V_PTRPTR_WRITE(ppv);
    V_REFGUID(iid);

    *ppv = NULL;

    if (iid == IID_IUnknown || iid == IID_IDirectMusicSegmentState || 
        iid == IID_IDirectMusicSegmentState8)
    {
        *ppv = static_cast<IDirectMusicSegmentState*>(this);
    } else
    if (iid == IID_CSegState)
    {
        *ppv = static_cast<CSegState*>(this);
    } else 
    if (iid == IID_IDirectMusicGraph)
    {
        *ppv = static_cast<IDirectMusicGraph*>(this);
    } else
    if (iid == IID_IDispatch)
    {
        // A helper scripting object implements IDispatch, which we expose from the
        // Performance object via COM aggregation.
        if (!m_pUnkDispatch)
        {
            // Create the helper object
            ::CoCreateInstance(
                CLSID_AutDirectMusicSegmentState,
                static_cast<IDirectMusicSegmentState*>(this),
                CLSCTX_INPROC_SERVER,
                IID_IUnknown,
                reinterpret_cast<void**>(&m_pUnkDispatch));
        }
        if (m_pUnkDispatch)
        {
            return m_pUnkDispatch->QueryInterface(IID_IDispatch, ppv);
        }
    }

    if (*ppv == NULL)
    {
        Trace(4,"Warning: Request to query unknown interface on SegmentState object\n");
        return E_NOINTERFACE;
    }
    reinterpret_cast<IUnknown*>(this)->AddRef();
    return S_OK;
}

STDMETHODIMP_(ULONG) CSegState::AddRef()
{
    return InterlockedIncrement(&m_cRef);
}

STDMETHODIMP_(ULONG) CSegState::Release()
{
    if (!InterlockedDecrement(&m_cRef))
    {
        m_cRef = 100; // artificial reference count to prevent reentrency due to COM aggregation
        delete this;
        return 0;
    }

    return m_cRef;
}

/*
  Private initialization function called by IDirectMusicSegment to set this
  state object's parent segment and performance. Addref's the parent segment
  but only retains a weak reference to the performance.
*/
HRESULT CSegState::PrivateInit(
    CSegment *pParentSegment,
    CPerformance *pPerformance)
{
    HRESULT hr = S_OK;
    ASSERT(pParentSegment);
    ASSERT(pPerformance);

    m_pSegment = pParentSegment;
    pParentSegment->AddRef();
    m_pPerformance = pPerformance; // retain only a weak reference
    m_rtLength = pParentSegment->m_rtLength;
    m_mtStartPoint = pParentSegment->m_mtStart;
    pParentSegment->MusicToReferenceTime(m_mtStartPoint, &m_rtStartPoint);
    m_mtLoopStart = pParentSegment->m_mtLoopStart;
    m_mtLoopEnd = pParentSegment->m_mtLoopEnd;
    m_dwSegFlags = pParentSegment->m_dwSegFlags;
    m_dwRepeats = pParentSegment->m_dwRepeats;
    m_rtLoopStart = pParentSegment->m_rtLoopStart;
    m_rtLoopEnd = pParentSegment->m_rtLoopEnd;
    if (m_rtLoopEnd)
    {
        // Don't allow a music time start point on a clock time looping segment.
        m_mtStartPoint = 0;
        m_rtStartPoint = 0;
        // Don't allow the clock time loop length to be shorter than the length of the segment.
        if (m_rtLoopEnd > m_rtLength)
        {
//            m_rtLength = ((m_rtLoopEnd - m_rtLoopStart) * m_dwRepeats) + m_rtLoopEnd;
            m_rtLength = m_rtLoopEnd; // This should never happen, so just clamp when it does.
        }
//        m_dwRepeats++; // This is a hack to get around the play code not repeating enough times.
    }
    if (m_rtLength) // It's a ref time segment, so convert the length to music time
    {
        pParentSegment->ReferenceToMusicTime(m_rtLength, &m_mtLength);
    }
    else
    {
        m_mtLength = pParentSegment->m_mtLength;
    }
    // Don't allow repeat count to overflow and cause mathematical errors. 
    // Make it so it can't create a segment length larger than 0x3FFFFFFF, 
    // which would last for 8 days at 120 bpm!
    if (m_dwRepeats)
    {
        if ((m_mtLoopEnd == 0) && (m_mtLoopStart == 0))
        {
            // This happens when loading waves and MIDI files. 
            m_mtLoopEnd = m_mtLength;

            // zero rtLoopEnd so we dont try to do clock time looping on a wave
            m_rtLoopEnd = 0;
        }
        // Make sure the loop is real.
        if (m_rtLoopEnd > m_rtLoopStart)
        {
            // probably need some test code for now, but at least this enables clock time looping...
        }
        else if (m_mtLoopEnd > m_mtLoopStart)
        {
            // Take the maximum length, subtract out the full length, then divide by the loop size.
            DWORD dwMax = (0x3FFFFFFF - m_mtLength) / (m_mtLoopEnd - m_mtLoopStart);
            // dwMax is the maximum number of loops that can be done without overflowing the time.
            if (m_dwRepeats > dwMax)
            {
                m_dwRepeats = dwMax;
            }
        }
        else
        {
            m_dwRepeats = 0;
        }
    }
    m_dwRepeatsLeft = m_dwRepeats;
    if( m_mtLoopEnd == 0 )
    {
        m_mtLoopEnd = m_mtLength;
    }
    if( m_mtStartPoint >= m_mtLoopEnd )
    {
        // in this case, we're not doing any looping.
        m_mtLoopEnd = m_mtLoopStart = 0;
        m_dwRepeats = m_dwRepeatsLeft = 0;
    }
    return hr;
}

HRESULT CSegState::InitRoute(IDirectMusicAudioPath *pAudioPath)

{
    HRESULT hr = E_INVALIDARG;
    EnterCriticalSection(&m_CriticalSection);
    if (pAudioPath)
    {
        if (m_dwVersion < 8) m_dwVersion = 8;
        m_pAudioPath = (CAudioPath *) pAudioPath;
        pAudioPath->AddRef();
        hr = S_OK;
    }
    LeaveCriticalSection(&m_CriticalSection);
    return hr;
}

/*
  This is called from the performance when it wants to release a
  segmentstate. This ensures that the segstate is
  no longer valid once outside the Performance.
*/
HRESULT CSegState::ShutDown(void)
{
    if (this)
    {
        if (m_fInPlay)
        {
            m_fDelayShutDown = true;
            return S_OK;
        }
        EnterCriticalSection(&m_CriticalSection);
        m_TrackList.Clear();
        if( m_pSegment )
        {
            m_pSegment->Release();
            m_pSegment = NULL;
        }
        if( m_pAudioPath)
        {
            m_pAudioPath->Release();
            m_pAudioPath = NULL;
        }
        if (m_pSongSegState)
        {
            m_pSongSegState->Release();
            m_pSongSegState = NULL;
        }
        m_pPerformance = NULL;
        LeaveCriticalSection(&m_CriticalSection);
        if( int nCount = Release() )
        {
            TraceI( 2, "Warning! SegmentState %lx still referenced %d times after Performance has released it.\n", this, nCount );
        }

        return S_OK;
    }
    TraceI(0,"Attempting to delete a NULL SegmentState!\n");
    return E_FAIL;
}

/*
  Retrieve the internal track list. Used by IDirectMusicSegment.
*/
HRESULT CSegState::GetTrackList(
    void** ppTrackList)
{
    ASSERT(ppTrackList);
    *ppTrackList = (void*)&m_TrackList;
    return S_OK;
}

/*
  Computes the length of the segmentstate using the internal length, loop points,
  and repeat count. This is the length of the segstate that will actually play,
  not necessarily the length if it played from the beginning.
*/
MUSIC_TIME CSegState::GetEndTime(MUSIC_TIME mtStartTime)
{
    EnterCriticalSection(&m_CriticalSection);
    if (m_rtLength && m_pPerformance)
    {
        // If there is a reference time length, convert it into Music Time.
        // ALSO: convert m_mtLength and re-adjust loop points.
        MUSIC_TIME mtOffset = m_mtResolvedStart;
        REFERENCE_TIME rtOffset = 0;
        m_pPerformance->MusicToReferenceTime(mtOffset, &rtOffset);
        REFERENCE_TIME rtEndTime = (m_rtLength - m_rtStartPoint) + rtOffset; // Convert from length to actual end time.
        m_pPerformance->ReferenceToMusicTime(rtEndTime, &m_mtEndTime);
        MUSIC_TIME mtOldLength = m_mtLength;
        m_mtLength = m_mtEndTime - mtOffset + m_mtStartPoint;
        if (m_mtLoopEnd >= mtOldLength) // keep loop end equal to length
        {
            m_mtLoopEnd = m_mtLength;
        }
        if( m_mtLoopEnd > m_mtLength ) // shrink loop end to equal length
        {
            m_mtLoopEnd = m_mtLength;
            if( m_mtStartPoint >= m_mtLoopEnd )
            {
                // in this case, we're not doing any looping.
                m_mtLoopEnd = m_mtLoopStart = 0;
                m_dwRepeats = m_dwRepeatsLeft = 0;
            }
        }
    }
    LeaveCriticalSection(&m_CriticalSection);
    LONGLONG length;
    length = m_mtLength + ((m_mtLoopEnd - m_mtLoopStart) * m_dwRepeats);
    length -= m_mtStartPoint;
    length += mtStartTime;
    if(length > 0x7fffffff) length = 0x7fffffff;
    return (MUSIC_TIME)length;
}

/*
  Converts an absolute Performance time to the index into the SegmentState, using
  the SegmentState's offset, internal length, loop points, and repeat count.
  Also returns the offset and repeat count for that time.
*/
HRESULT CSegState::ConvertToSegTime(
    MUSIC_TIME* pmtTime, MUSIC_TIME* pmtOffset, DWORD* pdwRepeat )
{
    ASSERT( pmtTime );
    ASSERT( pmtOffset );
    ASSERT( pdwRepeat );

    MUSIC_TIME mtPos = *pmtTime - m_mtResolvedStart + m_mtStartPoint;
    MUSIC_TIME mtLoopLength = m_mtLoopEnd - m_mtLoopStart;
    DWORD dwRepeat = 0;
    DWORD mtOffset = m_mtResolvedStart - m_mtStartPoint;

    while( mtPos >= m_mtLoopEnd )
    {
        if( dwRepeat >= m_dwRepeats ) break;
        mtPos -= mtLoopLength;
        mtOffset += mtLoopLength;
        dwRepeat++;
    }
    *pmtTime = mtPos;
    *pmtOffset = mtOffset;
    *pdwRepeat = dwRepeat;
    if( (mtPos >= 0) && (mtPos < m_mtLength) )
    {
        return S_OK;    // time is in range of the Segment
    }
    else
    {
        return S_FALSE; // time is out of range of the Segment
    }
}

void CSegState::GenerateNotification( DWORD dwNotification, MUSIC_TIME mtTime )
{
    GUID guid;
    HRESULT hr;
    guid = GUID_NOTIFICATION_SEGMENT;

    hr = m_pSegment->CheckNotification( guid );

    if( S_FALSE != hr )
    {
        DMUS_NOTIFICATION_PMSG* pEvent = NULL;
        if( SUCCEEDED( m_pPerformance->AllocPMsg( sizeof(DMUS_NOTIFICATION_PMSG), 
            (DMUS_PMSG**)&pEvent )))
        {
            pEvent->dwField1 = 0;
            pEvent->dwField2 = 0;
            pEvent->guidNotificationType = GUID_NOTIFICATION_SEGMENT;
            pEvent->dwType = DMUS_PMSGT_NOTIFICATION;
            pEvent->mtTime = mtTime;
            pEvent->dwFlags = DMUS_PMSGF_MUSICTIME | DMUS_PMSGF_TOOL_ATTIME;
            pEvent->dwPChannel = 0;
            pEvent->dwNotificationOption = dwNotification;
            pEvent->dwGroupID = 0xffffffff;
            pEvent->punkUser = (IUnknown*)(IDirectMusicSegmentState*)this;
            AddRef();
            StampPMsg((DMUS_PMSG*)pEvent);
            if(FAILED(m_pPerformance->SendPMsg( (DMUS_PMSG*)pEvent )))
            {
                m_pPerformance->FreePMsg((DMUS_PMSG*) pEvent );
            }
        }
    }
}

/* 
  Called to send the tools in the tool graph a dirty pmsg so they update any
  cached GetParam() info.
*/
void CSegState::SendDirtyPMsg( MUSIC_TIME mtTime )
{
    DMUS_PMSG* pEvent = NULL;
    if (m_pPerformance)
    {
        if( SUCCEEDED( m_pPerformance->AllocPMsg( sizeof(DMUS_PMSG), 
            (DMUS_PMSG**)&pEvent )))
        {
            pEvent->mtTime = mtTime;
            pEvent->dwFlags = DMUS_PMSGF_MUSICTIME | DMUS_PMSGF_TOOL_IMMEDIATE;
            pEvent->dwGroupID = 0xffffffff;
            pEvent->dwType = DMUS_PMSGT_DIRTY;
            StampPMsg((DMUS_PMSG*)pEvent);
            if( FAILED( m_pPerformance->SendPMsg( pEvent )))
            {
                m_pPerformance->FreePMsg( pEvent );
            }
        }
    }
}

/*
  Called when the SegState is stopped prematurely, so we can send a SEGABORT
  Notification.
  Also, flushes all events that were sent after the stop time. 
*/
HRESULT CSegState::AbortPlay( MUSIC_TIME mtTime, BOOL fLeaveNotesOn )
{
    EnterCriticalSection(&m_CriticalSection);
    if (m_pPerformance)
    {
        if( m_mtLastPlayed > mtTime )
        {
            // If we've played past the abort time, we need to flush messages. 
            // Note that if we were aborted by playing another segment that had
            // the DMUS_SEGF_NOINVALIDATE flag set, don't truncate notes
            // that are currently on.
            CTrack* pTrack;
            pTrack = m_TrackList.GetHead();
            while( pTrack )
            {
                m_pPerformance->FlushVirtualTrack( pTrack->m_dwVirtualID, mtTime, fLeaveNotesOn? FLUSH_LEAVE_ON:0 );
                pTrack = pTrack->GetNext();
            }
            m_mtLastPlayed = mtTime;
        }
        // Always fill in the updated value for lastplayed so the ShutDown or Done queue will flush this
        // at the right time.
        m_pPerformance->MusicToReferenceTime(mtTime,&m_rtLastPlayed);
    }
    LeaveCriticalSection(&m_CriticalSection);
    // Always generate an abort for a segment that has not started playing yet. 

    if (m_fStartedPlay && (m_mtEndTime <= mtTime))
    {
        return S_FALSE; // Abort was too late to matter.
    }
    if (m_mtAbortTime)  // Previous abort.
    {
        if (m_mtAbortTime <= mtTime) // Is this earlier?
        {
            return S_FALSE;     // No, don't send abort message.
        }
    }
    m_mtAbortTime = mtTime;
    // Find all the parameter control tracks and invalidate any parameter envelopes
    // that need invalidation.
    CTrack* pTrack = m_TrackList.GetHead();
    while( pTrack )
    {
        if (pTrack->m_guidClassID == CLSID_DirectMusicParamControlTrack)
        {
            CParamControlTrack* pParamTrack = NULL;
            if (pTrack->m_pTrack &&
                SUCCEEDED(pTrack->m_pTrack->QueryInterface(IID_CParamControlTrack, (void**)&pParamTrack)))
            {
                pParamTrack->OnSegmentEnd(m_rtLastPlayed, pTrack->m_pTrackState);
                pParamTrack->Release();
            }
        }
        pTrack = pTrack->GetNext();
    }
    GenerateNotification( DMUS_NOTIFICATION_SEGABORT, mtTime );
    // if this is a primary or controlling segment, send a DMUS_PMSGT_DIRTY message
    if( !(m_dwPlaySegFlags & DMUS_SEGF_SECONDARY) || (m_dwPlaySegFlags & DMUS_SEGF_CONTROL) )
    {
        TraceI(4, "Send Dirty PMsg [4] %d (%d)\n", m_mtSeek, m_mtOffset + m_mtSeek);
        SendDirtyPMsg( m_mtOffset + m_mtSeek );
    }
    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
// IDirectMusicSegmentState

//////////////////////////////////////////////////////////////////////
// IDirectMusicSegmentState::GetRepeats
/*
@method HRESULT | IDirectMusicSegmentState | GetRepeats |
Returns the number of times the SegmentState is set to repeat. A value of zero indicates
to play through only once (no repeats.) This value remains constant throughout the life
of the SegmentState.

@rvalue E_POINTER | if <p pdwRepeats> is NULL or invalid.
@rvalue S_OK | Success.
*/
HRESULT STDMETHODCALLTYPE CSegState::GetRepeats( 
    DWORD *pdwRepeats)  // @parm Returns the repeat count.
{
    V_INAME(IDirectMusicSegmentState::GetRepeats);
    V_PTR_WRITE(pdwRepeats,DWORD);

    *pdwRepeats = m_dwRepeats;
    return S_OK;
}

///////////////////////////////////////////////////////////////////////
// IDirectMusicSegmentState::GetSegment
/*
@method HRESULT | IDirectMusicSegmentState | GetSegment |
Returns a pointer to the Segment that owns this SegmentState.

@rvalue E_POINTER | if ppSegment is NULL or invalid.
@rvalue S_OK | Success.
*/
HRESULT STDMETHODCALLTYPE CSegState::GetSegment( 
    IDirectMusicSegment **ppSegment)    // @parm The Segment interface pointer to this
                                        // SegmentState. Call Release() on this pointer when
                                        // through.
{
    V_INAME(IDirectMusicSegmentState::GetSegment);
    V_PTRPTR_WRITE(ppSegment);

    *ppSegment = (IDirectMusicSegment *) m_pSegment;
    if( m_pSegment )
    {
        m_pSegment->AddRef();
    }
    else
    {
        Trace(1,"Error: Segmentstate doesn't have an associated segment.\n");
        return DMUS_E_NOT_FOUND;
    }
    return S_OK;
}

///////////////////////////////////////////////////////////////////////
// IDirectMusicSegmentState::Play
/*
method (INTERNAL) HRESULT | IDirectMusicSegmentState | Play |
<om IDirectMusicSegmentState.Play> is called regularly by the Performance object, 
usually every 200 ms or so, at a time ahead of playback that is set by 
<om IDirectMusicPerformance.SetPerformTime>
.
parm MUSIC_TIME | mtAmount |
    [in] The length of time to play, starting at the current Seek time.
    The SegmentState updates its Seek time to be the current Seek time
    plus mtAmount. Therefore, the SegmentState should play from the current
    Seek time to Seek time plus mtAmount, not including the last clock.

comm 
Play calls each Track's Play method in priority order, instructing the Track to 
create events from the current Seek time up to, but not including the current Seek
time plus <p mtAmount.>
Since the Segment started at the point designated by m_mtOffset (set by
<im IDirectMusicSegmentState.SetOffset>
m_mtOffset sets the starting offset to add to the times of all events.

rvalue E_INVALIDARG | mtAmount <= 0
rvalue S_OK | Success.
*/

HRESULT STDMETHODCALLTYPE CSegState::Play( 
    /* [in] */ MUSIC_TIME mtAmount, MUSIC_TIME* pmtPlayed )
{
    return E_FAIL;      // We don't want to support this publicly!
}

HRESULT CSegState::Play( MUSIC_TIME mtAmount )
{
    CTrack* pCTrack;
    MUSIC_TIME mtMyAmount = mtAmount;
    REFERENCE_TIME rtMyAmount;
    HRESULT hr = DMUS_S_END;
    BOOL fUseClockTime = FALSE;

    if( mtAmount <= 0 )
        return E_INVALIDARG;

    if (m_rtLength && m_rtLoopEnd)
    {
        m_pPerformance->MusicToReferenceTime(m_mtLastPlayed + mtMyAmount,&rtMyAmount);
        rtMyAmount -= m_rtLastPlayed;
        return PlayClockTime(rtMyAmount);
    }

    EnterCriticalSection(&m_CriticalSection);
    if (m_fInPlay)
    {
        LeaveCriticalSection(&m_CriticalSection);
        return S_OK;
    }
    m_fInPlay = true;
    m_pPerformance->m_pGetParamSegmentState = (IDirectMusicSegmentState *) this;
    // if this is the first call to play, we need to send a SegStart notification.
    // We also need to check to see if we are supposed to start at the beginning,
    // or at an offset.
    if( m_dwPlayTrackFlags & DMUS_TRACKF_START )
    {
        // send a segment start notification
        GenerateNotification( DMUS_NOTIFICATION_SEGSTART, m_mtOffset );
        // if this is a primary or controlling segment, send a DMUS_PMSGT_DIRTY message
        if( !(m_dwPlaySegFlags & DMUS_SEGF_SECONDARY) || (m_dwPlaySegFlags & DMUS_SEGF_CONTROL) )
        {
            TraceI(4, "Send Dirty PMsg [1] %d (%d)\n", m_mtSeek, m_mtOffset + m_mtSeek);
            SendDirtyPMsg( m_mtOffset + m_mtSeek );
        }
        // set the current seek to the start point
        m_mtSeek = m_mtStartPoint;
        // convert current offset to ref time
        m_pPerformance->MusicToReferenceTime(m_mtOffset,&m_rtOffset);
        m_rtEndTime = m_rtOffset + m_rtLength;
        // subtract the start points from the offsets
        m_mtOffset -= m_mtStartPoint;
        m_rtOffset -= m_rtStartPoint;
        m_rtEndTime -= m_rtStartPoint;
        m_rtSeek = m_rtLastPlayed - m_rtOffset;

        m_rtFirstLoopStart = 0;
    }
    if (m_rtLength)
    {
        // If there is a reference time length, convert it into mtTime.
        // Because there's always the danger of a tempo change, we do this every
        // time. It doesn't require the tight precision that song time
        // requires, so that's okay.
        // ALSO: convert m_mtLength and re-adjust loop points. (RSW)
        m_pPerformance->ReferenceToMusicTime(m_rtEndTime, &m_mtEndTime);
        MUSIC_TIME mtOldLength = m_mtLength;
        m_mtLength = m_mtEndTime - m_mtOffset; 
        // georgioc HACK follows to make this work
        if (m_mtLength <= 0 ) 
        {
            m_mtLength = mtOldLength;
        }
        if (m_mtLoopEnd >= mtOldLength) // keep loop end equal to length
        {
            m_mtLoopEnd = m_mtLength;
        }
        if( m_mtLoopEnd > m_mtLength )
        {
            m_mtLoopEnd = m_mtLength;
            if( m_mtStartPoint >= m_mtLoopEnd )
            {
                // in this case, we're not doing any looping.
                m_mtLoopEnd = m_mtLoopStart = 0;
                m_dwRepeats = m_dwRepeatsLeft = 0;
            }
        }
        
        //m_mtEndTime += (m_mtLoopEnd - m_mtLoopStart) * m_dwRepeats;

        fUseClockTime = TRUE;
    }
    // if we need to do a loop or the end is near, restrict mtMyAmount
//  ASSERT( m_mtLength ); // length is 0, this segment won't do anything
    if( m_dwRepeatsLeft )
    {
        if( mtMyAmount > m_mtLoopEnd - m_mtSeek )
        {
            mtMyAmount = m_mtLoopEnd - m_mtSeek;
        }
    }
    else 
    {
        if (fUseClockTime)
        {
            if (mtMyAmount > (m_mtEndTime - (m_mtOffset + m_mtSeek)))
            {
                mtMyAmount = m_mtEndTime - (m_mtOffset + m_mtSeek);
            }
        }
        else if( mtMyAmount > m_mtLength - m_mtSeek )
        {
            mtMyAmount = m_mtLength - m_mtSeek;
        }
    }
    if (mtMyAmount <= 0)
    {
        hr = DMUS_S_END;
    }
    else
    {
        // check the primary segment queue for a segment that might begin 
        // before mtMyAmount is up
        MUSIC_TIME mtNextPri;
        if (S_OK == m_pPerformance->GetPriSegTime( m_mtOffset + m_mtSeek, &mtNextPri ))
        {
            if( m_mtOffset + m_mtSeek + mtMyAmount > mtNextPri )
            {
                mtMyAmount = mtNextPri - m_mtOffset - m_mtSeek;
            }
        }
        TraceI(3, "SegState %ld Play from %ld to %ld at %ld = %ld - %ld\n", this, m_mtSeek, m_mtSeek + mtMyAmount, m_mtOffset, m_mtSeek + m_mtOffset, m_mtSeek + mtMyAmount + m_mtOffset );
        
        // find out if there's a control segment interrupting this period of time.
        MUSIC_TIME mtControlSeg;
        if( S_OK == m_pPerformance->GetControlSegTime( m_mtOffset + m_mtSeek, &mtControlSeg ))
        {
            if( m_mtOffset + m_mtSeek == mtControlSeg )
            {
                // we're at the beginning of a new control seg, so tell the tracks
                m_dwPlayTrackFlags |= DMUS_TRACKF_DIRTY;
            }
            else if( m_mtOffset + m_mtSeek + mtMyAmount > mtControlSeg )
            {
                mtMyAmount = mtControlSeg - m_mtOffset - m_mtSeek;
            }
        }
        // Now that mtMyAmount is calculated for how far to play in music time,
        // create the equivalent value in reference time.
        m_pPerformance->MusicToReferenceTime(m_mtLastPlayed + mtMyAmount,&rtMyAmount);
        rtMyAmount -= m_rtLastPlayed;
        pCTrack = m_TrackList.GetHead();
        while( pCTrack )
        {
            if( mtMyAmount )
            {
                m_pPerformance->m_fInTrackPlay = TRUE; // This causes the Pmsgs to be stamped with PRIV_FLAG_TRACK.
                ASSERT( pCTrack->m_pTrack );
                // If either notification or play are enabled, we need to call the play method and set the behavior
                // with the DMUS_TRACKF_NOTIFY_OFF and DMUS_TRACKF_PLAY_OFF flags. 
                if (pCTrack->m_dwFlags & (DMUS_TRACKCONFIG_PLAY_ENABLED | DMUS_TRACKCONFIG_NOTIFICATION_ENABLED))
                {
                    DWORD dwAdditionalFlags = 0;
                    if (!(pCTrack->m_dwFlags & DMUS_TRACKCONFIG_NOTIFICATION_ENABLED))
                    {
                        dwAdditionalFlags = DMUS_TRACKF_NOTIFY_OFF;
                    }
                    if (!(pCTrack->m_dwFlags & DMUS_TRACKCONFIG_PLAY_ENABLED))
                    {
                        dwAdditionalFlags |= DMUS_TRACKF_PLAY_OFF;
                    }
                    // If the track was authored to generate new data on start or loop, let it know.
                    if ( ((m_dwPlayTrackFlags & DMUS_TRACKF_START) && (pCTrack->m_dwFlags & DMUS_TRACKCONFIG_PLAY_COMPOSE)) ||
                        ((m_dwPlayTrackFlags & DMUS_TRACKF_LOOP) && (pCTrack->m_dwFlags & DMUS_TRACKCONFIG_LOOP_COMPOSE)) )
                    {
                        dwAdditionalFlags |= DMUS_TRACKF_RECOMPOSE;
                    }
                    if (pCTrack->m_dwInternalFlags & CONTROL_PLAY_REFRESH)
                    {
                        dwAdditionalFlags |= DMUS_TRACKF_START;
                        pCTrack->m_dwInternalFlags &= ~CONTROL_PLAY_REFRESH;
                    }
                    // Let performance know what the priority should be in ensuing GetParam() calls from the track.
                    m_pPerformance->m_dwGetParamFlags = pCTrack->m_dwFlags;
                    // If track has DX8 interface, use it.
                    if (pCTrack->m_pTrack8)
                    {
                        //  The track can call GetParam on the segment which locks the segment so
                        //  we have to lock the segment before calling PlayEx or we'll deadlock
                        //  with a thread that's calling PlayOneSegment which locks the segment
                        //  before playing the tracks.
                        if (m_pSegment) 
                        {
                            EnterCriticalSection(&m_pSegment->m_CriticalSection);
                        }
                        // If track plays in clock time, set time variables appropriately.
                        if (pCTrack->m_dwFlags & DMUS_TRACKCONFIG_PLAY_CLOCKTIME)
                        {
                            if( ( S_OK == (pCTrack->m_pTrack8->PlayEx(pCTrack->m_pTrackState,
                                m_rtSeek,m_rtSeek + rtMyAmount, m_rtOffset, m_dwPlayTrackFlags | dwAdditionalFlags | DMUS_TRACKF_CLOCK,
                                m_pPerformance, this, pCTrack->m_dwVirtualID ))))
                            {
                                hr = S_OK; // if even one track isn't done playing,
                                // keep going
                            }
                            else 
                            {
                                pCTrack->m_bDone = TRUE;
                            }
                        }
                        else
                        {
                            if( ( S_OK == (pCTrack->m_pTrack8->PlayEx(pCTrack->m_pTrackState,
                                m_mtSeek,m_mtSeek + mtMyAmount, m_mtOffset, m_dwPlayTrackFlags | dwAdditionalFlags,
                                m_pPerformance, this, pCTrack->m_dwVirtualID ))))
                            {
                                hr = S_OK; // if even one track isn't done playing,
                                // keep going
                            }
                            else 
                            {
                                pCTrack->m_bDone = TRUE;
                            }
                        }

                        if (m_pSegment) 
                        {
                            LeaveCriticalSection(&m_pSegment->m_CriticalSection);
                        }
                    }
                    else
                    {
                        if( ( S_OK == ( pCTrack->m_pTrack->Play( pCTrack->m_pTrackState, 
                            m_mtSeek, m_mtSeek + mtMyAmount, m_mtOffset, m_dwPlayTrackFlags | dwAdditionalFlags,
                            m_pPerformance, this, pCTrack->m_dwVirtualID ))))
                        {
                            hr = S_OK; // if even one track isn't done playing,
                            // keep going
                        }
                        else
                        {
                            pCTrack->m_bDone = TRUE;
                        }
                    }
                }
                m_pPerformance->m_fInTrackPlay = FALSE;
            }
            pCTrack = pCTrack->GetNext();
            if( pCTrack == NULL )
            {
                // none of the play flags are persistent
                m_dwPlayTrackFlags = 0;
                m_mtLastPlayed += mtMyAmount;   // increment play pointer
                m_rtLastPlayed += rtMyAmount;   // same in ref time
                m_mtSeek += mtMyAmount;         // increment seek pointer
                m_rtSeek += rtMyAmount;
                hr = S_OK;

                // If we're looping....
                // And if this is the first repeat
                if(m_dwRepeats > 0 && m_dwRepeats == m_dwRepeatsLeft)
                {
                    // If we're playing the loop start remember it's reftime value
                    if(m_mtSeek >= m_mtLoopStart && m_rtFirstLoopStart == 0)
                    {
                        m_pPerformance->MusicToReferenceTime(m_mtLoopStart + m_mtOffset + m_mtStartPoint, &m_rtFirstLoopStart);
                        m_rtFirstLoopStart -= m_rtStartPoint;
                        m_rtCurLoopStart = m_rtFirstLoopStart;
                    }
                }

                // take into account repeats if necessary
                if( m_mtSeek >= m_mtLoopEnd )
                {
                    // Remember the current loop end
                    m_pPerformance->MusicToReferenceTime(m_mtLoopEnd + m_mtOffset + m_mtStartPoint, &m_rtCurLoopEnd);
                    m_rtCurLoopEnd -= m_rtStartPoint;

                    if(m_dwRepeatsLeft)
                    {
                        m_dwPlayTrackFlags |= DMUS_TRACKF_LOOP | DMUS_TRACKF_SEEK;
                        m_dwRepeatsLeft--;
                        pCTrack = m_TrackList.GetHead();
                        while( pCTrack )
                        {
                            pCTrack->m_bDone = FALSE;
                            pCTrack = pCTrack->GetNext();
                        }
                        
                        m_mtSeek = m_mtLoopStart;
                        m_mtOffset += ( m_mtLoopEnd - m_mtLoopStart);
                        
                        
                        m_rtOffset += (m_rtCurLoopEnd - m_rtCurLoopStart);
                        m_rtFirstLoopStart += (m_rtCurLoopEnd - m_rtCurLoopStart);
                        m_rtSeek = m_rtFirstLoopStart - m_rtOffset;

                        m_rtEndTime += (m_rtCurLoopEnd - m_rtCurLoopStart);
                   
                        m_rtCurLoopStart = m_rtCurLoopEnd;

                        if( mtMyAmount < mtAmount )
                        {
                            pCTrack = m_TrackList.GetHead(); // cause outer while loop to start over
                            mtMyAmount = mtAmount - mtMyAmount;
                            mtAmount = mtMyAmount;
                            // if we need to do a loop or the end is near, restrict mtMyAmount
                            if( m_dwRepeatsLeft )
                            {
                                if( mtMyAmount > m_mtLoopEnd - m_mtSeek )
                                {
                                    mtMyAmount = m_mtLoopEnd - m_mtSeek;
                                }
                            }
                            else 
                            {
                                if (fUseClockTime)
                                {
                                    if (mtMyAmount > (m_mtEndTime - (m_mtOffset + m_mtSeek)))
                                    {
                                        mtMyAmount = m_mtEndTime - (m_mtOffset + m_mtSeek);
                                    }
                                }
                                else if( mtMyAmount > m_mtLength - m_mtSeek )
                                {
                                    mtMyAmount = m_mtLength - m_mtSeek;
                                }
                            }
                        }
                        // send a segment looped notification
                        GenerateNotification( DMUS_NOTIFICATION_SEGLOOP, m_mtOffset + m_mtSeek );
                        // find out if there's a control segment interrupting this period of time
                        if( S_OK == m_pPerformance->GetControlSegTime( m_mtOffset + m_mtSeek, &mtControlSeg ))
                        {
                            if( m_mtOffset + m_mtSeek == mtControlSeg ) 
                            {
                                // we're at the beginning of a new control seg, so tell the tracks
                                m_dwPlayTrackFlags |= DMUS_TRACKF_DIRTY; 
                            }
                            else if( m_mtOffset + m_mtSeek + mtMyAmount < mtControlSeg )
                            {
                                mtMyAmount = mtControlSeg - m_mtOffset - m_mtSeek;
                            }
                        }
                        m_pPerformance->MusicToReferenceTime(m_mtLastPlayed + mtMyAmount,&rtMyAmount);
                        rtMyAmount -= m_rtLastPlayed;
                    }
                    else if( m_mtSeek == m_mtLength )
                    {
                        // no more repeats.
                        hr = DMUS_S_END;
                    }
                }
            }
        }
    }
    if (hr == DMUS_S_END)
    {
        // send a segment end notification
        GenerateNotification( DMUS_NOTIFICATION_SEGEND, m_mtOffset + m_mtSeek );
        // also queue the almost ended for now
        MUSIC_TIME mtNow;
        m_pPerformance->GetTime( NULL, &mtNow );
        GenerateNotification( DMUS_NOTIFICATION_SEGALMOSTEND, mtNow );
        // if this is a primary or controlling segment, send a DMUS_PMSGT_DIRTY message
        if( !(m_dwPlaySegFlags & DMUS_SEGF_SECONDARY) || (m_dwPlaySegFlags & DMUS_SEGF_CONTROL) )
        {
            TraceI(4, "Send Dirty PMsg [2] %d (%d)\n", m_mtSeek, m_mtOffset + m_mtSeek);
            SendDirtyPMsg( m_mtOffset + m_mtSeek );
        }
        // If this is part of a song, we need to queue the next segment.
        if (m_fSongMode)
        {
            if (m_pSegment)
            {
                CSong *pSong = m_pSegment->m_pSong;
                if (pSong)
                {
                    // Get the next segment from the song.
                    CSegment *pSegment;
                    if (S_OK == pSong->GetPlaySegment(m_pSegment->m_dwNextPlayID,&pSegment))
                    {
                        // Now, play it.
                        // Unless DMUS_SEGF_USE_AUDIOPATH is set, play it on the same audiopath. 
                        // And, make sure that it plays at the same level (control, secondary, or primary.)
                        CSegState *pCSegState = NULL;
                        CAudioPath *pPath = m_pAudioPath;
                        CAudioPath *pInternalPath = NULL;
                        DWORD dwFlags = m_dwPlaySegFlags & (DMUS_SEGF_CONTROL | DMUS_SEGF_SECONDARY);
                        dwFlags &= ~DMUS_SEGF_REFTIME;
                        if (dwFlags & DMUS_SEGF_USE_AUDIOPATH)
                        {
                            IUnknown *pConfig;
                            if (SUCCEEDED(pSegment->GetAudioPathConfig(&pConfig)))
                            {
                                IDirectMusicAudioPath *pNewPath;
                                if (SUCCEEDED(m_pPerformance->CreateAudioPath(pConfig,TRUE,&pNewPath)))
                                {
                                    // Now, get the CAudioPath structure.
                                    pConfig->QueryInterface(IID_CAudioPath,(void **) &pInternalPath);
                                    pPath = pInternalPath;
                                }
                                pConfig->Release();
                            }
                        }
                        if (SUCCEEDED(m_pPerformance->PlayOneSegment((CSegment *)pSegment,dwFlags,m_mtEndTime,&pCSegState,pPath)))
                        {
                            if (m_pSongSegState)
                            {
                                // This is not the first, so transfer the segstate pointer.
                                pCSegState->m_pSongSegState = m_pSongSegState;
                                m_pSongSegState = NULL;
                            }
                            else
                            {
                                // This is the first, so have the next segstate point to this.
                                pCSegState->m_pSongSegState = this;
                                AddRef();
                            }
                            pCSegState->m_fSongMode = TRUE;
                            pCSegState->Release();
                        }
                        if (pInternalPath)
                        {
                            pInternalPath->Release();
                        }
                        pSegment->Release();
                    }
                }
            }
        }
    }
    m_dwPlayTrackFlags &= ~DMUS_TRACKF_DIRTY;
    m_pPerformance->m_dwGetParamFlags = 0;
    m_pPerformance->m_pGetParamSegmentState = NULL;
    m_fInPlay = false;
    if (m_fDelayShutDown)
    {
        Shutdown();
        m_fDelayShutDown = false;
    }
    LeaveCriticalSection(&m_CriticalSection);
    return hr;
}

#ifdef oldversion

HRESULT CSegState::Play( MUSIC_TIME mtAmount )
{
    CTrack* pCTrack;
    MUSIC_TIME mtMyAmount = mtAmount;
    REFERENCE_TIME rtMyAmount;
    HRESULT hr = DMUS_S_END;
    BOOL fUseClockTime = FALSE;

    if( mtAmount <= 0 )
        return E_INVALIDARG;

    EnterCriticalSection(&m_CriticalSection);
    if (m_fInPlay)
    {
        LeaveCriticalSection(&m_CriticalSection);
        return S_OK;
    }
    m_fInPlay = true;
    m_pPerformance->m_pGetParamSegmentState = (IDirectMusicSegmentState *) this;
    // if this is the first call to play, we need to send a SegStart notification.
    // We also need to check to see if we are supposed to start at the beginning,
    // or at an offset.
    if( m_dwPlayTrackFlags & DMUS_TRACKF_START )
    {
        // send a segment start notification
        GenerateNotification( DMUS_NOTIFICATION_SEGSTART, m_mtOffset );
        // if this is a primary or controlling segment, send a DMUS_PMSGT_DIRTY message
        if( !(m_dwPlaySegFlags & DMUS_SEGF_SECONDARY) || (m_dwPlaySegFlags & DMUS_SEGF_CONTROL) )
        {
            TraceI(4, "Send Dirty PMsg [1] %d (%d)\n", m_mtSeek, m_mtOffset + m_mtSeek);
            SendDirtyPMsg( m_mtOffset + m_mtSeek );
        }
        // set the current seek to the start point
        m_mtSeek = m_mtStartPoint;
        // convert current offset to ref time
        m_pPerformance->MusicToReferenceTime(m_mtOffset,&m_rtOffset);
        m_rtEndTime = m_rtOffset + m_rtLength;
        // subtract the start points from the offsets
        m_mtOffset -= m_mtStartPoint;
        m_rtOffset -= m_rtStartPoint;
        m_rtEndTime -= m_rtStartPoint;
        m_rtSeek = m_rtLastPlayed - m_rtOffset;

        m_rtFirstLoopStart = 0;
    }
    if (m_rtLength)
    {
        // If there is a reference time length, convert it into mtTime.
        // Because there's always the danger of a tempo change, we do this every
        // time. It doesn't require the tight precision that song time
        // requires, so that's okay.
        // ALSO: convert m_mtLength and re-adjust loop points. (RSW)
        m_pPerformance->ReferenceToMusicTime(m_rtEndTime, &m_mtEndTime);
        MUSIC_TIME mtOldLength = m_mtLength;
        m_mtLength = m_mtEndTime - m_mtOffset; 
        // georgioc HACK follows to make this work

        if (m_mtLength <= 0) {

            m_mtLength = mtOldLength;

        }


        if (m_mtLoopEnd >= mtOldLength) // keep loop end equal to length
        {
            m_mtLoopEnd = m_mtLength;
        }
        if( m_mtLoopEnd > m_mtLength )
        {
            m_mtLoopEnd = m_mtLength;
            if( m_mtStartPoint >= m_mtLoopEnd )
            {
                // in this case, we're not doing any looping.
                m_mtLoopEnd = m_mtLoopStart = 0;
                m_dwRepeats = m_dwRepeatsLeft = 0;
            }
        }
        
        //m_mtEndTime += (m_mtLoopEnd - m_mtLoopStart) * m_dwRepeats;

        fUseClockTime = TRUE;
    }

    // if we need to do a loop or the end is near, restrict mtMyAmount
//  ASSERT( m_mtLength ); // length is 0, this segment won't do anything
    if( m_dwRepeatsLeft )
    {
        if (m_rtLoopEnd)    // Is this a clock time looped segment?
        {
            REFERENCE_TIME rtCalcAmount;
            m_pPerformance->MusicToReferenceTime(m_mtLastPlayed + mtMyAmount,&rtCalcAmount);
            rtCalcAmount -= m_rtLastPlayed;
            if (rtCalcAmount > m_rtLoopEnd - m_rtSeek)
            {
                rtCalcAmount = m_rtLoopEnd - m_rtSeek;
                m_pPerformance->ReferenceToMusicTime(m_rtLastPlayed + rtCalcAmount,&mtMyAmount);
                mtMyAmount -= m_mtLastPlayed;
                if (!mtMyAmount && (m_rtLoopEnd > m_rtSeek))
                {
                    mtMyAmount = 1;
                }
            }
        }
        else if( mtMyAmount > m_mtLoopEnd - m_mtSeek )
        {
            mtMyAmount = m_mtLoopEnd - m_mtSeek;
        }
    }
    else 
    {
        if (fUseClockTime)
        {
            if (mtMyAmount > (m_mtEndTime - (m_mtOffset + m_mtSeek)))
            {
                mtMyAmount = m_mtEndTime - (m_mtOffset + m_mtSeek);
            }
        }
        else if( mtMyAmount > m_mtLength - m_mtSeek )
        {
            mtMyAmount = m_mtLength - m_mtSeek;
        }
    }
    if (mtMyAmount <= 0)
    {
        hr = DMUS_S_END;
    }
    else
    {
        // check the primary segment queue for a segment that might begin 
        // before mtMyAmount is up
        MUSIC_TIME mtNextPri;
        if (S_OK == m_pPerformance->GetPriSegTime( m_mtOffset + m_mtSeek, &mtNextPri ))
        {
            if( m_mtOffset + m_mtSeek + mtMyAmount > mtNextPri )
            {
                mtMyAmount = mtNextPri - m_mtOffset - m_mtSeek;
            }
        }
        TraceI(3, "SegState %ld Play from %ld to %ld at %ld = %ld - %ld\n", this, m_mtSeek, m_mtSeek + mtMyAmount, m_mtOffset, m_mtSeek + m_mtOffset, m_mtSeek + mtMyAmount + m_mtOffset );
        
        // find out if there's a control segment interrupting this period of time.
        MUSIC_TIME mtControlSeg;
        if( S_OK == m_pPerformance->GetControlSegTime( m_mtOffset + m_mtSeek, &mtControlSeg ))
        {
            if( m_mtOffset + m_mtSeek == mtControlSeg )
            {
                // we're at the beginning of a new control seg, so tell the tracks
                m_dwPlayTrackFlags |= DMUS_TRACKF_DIRTY;
            }
            else if( m_mtOffset + m_mtSeek + mtMyAmount > mtControlSeg )
            {
                mtMyAmount = mtControlSeg - m_mtOffset - m_mtSeek;
            }
        }
        // Now that mtMyAmount is calculated for how far to play in music time,
        // create the equivalent value in reference time.
        m_pPerformance->MusicToReferenceTime(m_mtLastPlayed + mtMyAmount,&rtMyAmount);
        rtMyAmount -= m_rtLastPlayed;
        pCTrack = m_TrackList.GetHead();
        while( pCTrack )
        {
            if( mtMyAmount )
            {
                m_pPerformance->m_fInTrackPlay = TRUE; // This causes the Pmsgs to be stamped with PRIV_FLAG_TRACK.
                ASSERT( pCTrack->m_pTrack );
                // If either notification or play are enabled, we need to call the play method and set the behavior
                // with the DMUS_TRACKF_NOTIFY_OFF and DMUS_TRACKF_PLAY_OFF flags. 
                if (pCTrack->m_dwFlags & (DMUS_TRACKCONFIG_PLAY_ENABLED | DMUS_TRACKCONFIG_NOTIFICATION_ENABLED))
                {
                    DWORD dwAdditionalFlags = 0;
                    if (!(pCTrack->m_dwFlags & DMUS_TRACKCONFIG_NOTIFICATION_ENABLED))
                    {
                        dwAdditionalFlags = DMUS_TRACKF_NOTIFY_OFF;
                    }
                    if (!(pCTrack->m_dwFlags & DMUS_TRACKCONFIG_PLAY_ENABLED))
                    {
                        dwAdditionalFlags |= DMUS_TRACKF_PLAY_OFF;
                    }
                    // If the track was authored to generate new data on start or loop, let it know.
                    if ( ((m_dwPlayTrackFlags & DMUS_TRACKF_START) && (pCTrack->m_dwFlags & DMUS_TRACKCONFIG_PLAY_COMPOSE)) ||
                        ((m_dwPlayTrackFlags & DMUS_TRACKF_LOOP) && (pCTrack->m_dwFlags & DMUS_TRACKCONFIG_LOOP_COMPOSE)) )
                    {
                        dwAdditionalFlags |= DMUS_TRACKF_RECOMPOSE;
                    }
                    if (pCTrack->m_dwInternalFlags & CONTROL_PLAY_REFRESH)
                    {
                        dwAdditionalFlags |= DMUS_TRACKF_START;
                        pCTrack->m_dwInternalFlags &= ~CONTROL_PLAY_REFRESH;
                    }
                    // Let performance know what the priority should be in ensuing GetParam() calls from the track.
                    m_pPerformance->m_dwGetParamFlags = pCTrack->m_dwFlags;
                    // If track has DX8 interface, use it.
                    if (pCTrack->m_pTrack8)
                    {
                        //  The track can call GetParam on the segment which locks the segment so
                        //  we have to lock the segment before calling PlayEx or we'll deadlock
                        //  with a thread that's calling PlayOneSegment which locks the segment
                        //  before playing the tracks.
                        if (m_pSegment) 
                        {
                            EnterCriticalSection(&m_pSegment->m_CriticalSection);
                        }
                        // If track plays in clock time, set time variables appropriately.
                        if (pCTrack->m_dwFlags & DMUS_TRACKCONFIG_PLAY_CLOCKTIME)
                        {
                            if( ( S_OK == (pCTrack->m_pTrack8->PlayEx(pCTrack->m_pTrackState,
                                m_rtSeek,m_rtSeek + rtMyAmount, m_rtOffset, m_dwPlayTrackFlags | dwAdditionalFlags | DMUS_TRACKF_CLOCK,
                                m_pPerformance, this, pCTrack->m_dwVirtualID ))))
                            {
                                hr = S_OK; // if even one track isn't done playing,
                                // keep going
                            }
                            else 
                            {
                                pCTrack->m_bDone = TRUE;
                            }
                        }
                        else
                        {
                            if( ( S_OK == (pCTrack->m_pTrack8->PlayEx(pCTrack->m_pTrackState,
                                m_mtSeek,m_mtSeek + mtMyAmount, m_mtOffset, m_dwPlayTrackFlags | dwAdditionalFlags,
                                m_pPerformance, this, pCTrack->m_dwVirtualID ))))
                            {
                                hr = S_OK; // if even one track isn't done playing,
                                // keep going
                            }
                            else 
                            {
                                pCTrack->m_bDone = TRUE;
                            }
                        }

                        if (m_pSegment) 
                        {
                            LeaveCriticalSection(&m_pSegment->m_CriticalSection);
                        }
                    }
                    else 
                    {
                        if( ( S_OK == ( pCTrack->m_pTrack->Play( pCTrack->m_pTrackState, 
                            m_mtSeek, m_mtSeek + mtMyAmount, m_mtOffset, m_dwPlayTrackFlags | dwAdditionalFlags,
                            m_pPerformance, this, pCTrack->m_dwVirtualID ))))
                        {
                            hr = S_OK; // if even one track isn't done playing,
                            // keep going
                        }
                        else
                        {
                            pCTrack->m_bDone = TRUE;
                        }
                    }
                }
                m_pPerformance->m_fInTrackPlay = FALSE;
            }
            pCTrack = pCTrack->GetNext();
            if( pCTrack == NULL )
            {
                // none of the play flags are persistent
                m_dwPlayTrackFlags = 0;
                m_mtLastPlayed += mtMyAmount;   // increment play pointer
                m_rtLastPlayed += rtMyAmount;   // same in ref time
                m_mtSeek += mtMyAmount;         // increment seek pointer
                m_rtSeek += rtMyAmount;
                hr = S_OK;

                // If we're looping....
                // And if this is the first repeat
                if(m_dwRepeats > 0 && m_dwRepeats == m_dwRepeatsLeft)
                {
                    if (m_rtLoopEnd)
                    {
                        // If we're playing the loop start, remember it's musictime value
                        if(m_rtSeek >= m_rtLoopStart && m_rtFirstLoopStart == 0)
                        {
                            m_rtFirstLoopStart = m_rtLoopStart + m_rtOffset;
                            m_pPerformance->ReferenceToMusicTime(m_rtFirstLoopStart,&m_mtFirstLoopStart);
                            m_mtCurLoopStart = m_mtFirstLoopStart;
                        }
                    }
                    else
                    {
                        // If we're playing the loop start, remember it's reftime value
                        if(m_mtSeek >= m_mtLoopStart && m_rtFirstLoopStart == 0)
                        {
                            m_mtFirstLoopStart = m_mtLoopStart + m_mtOffset;
                            // Huh? Why are we including the startpoint in this calculation? I talked with Bob and it's
                            // to work around a problem with a tempo map in a clock time segment. 
                            // But, even this solution can cause flawed results. 
                            // Truth is, you should never have a tempo map in a clock time segment, but we'll need to 
                            // keep this for regression reasons. 
                            m_pPerformance->MusicToReferenceTime(m_mtLoopStart + m_mtOffset + m_mtStartPoint, &m_rtFirstLoopStart);
                            m_rtFirstLoopStart -= m_rtStartPoint;
                            m_rtCurLoopStart = m_rtFirstLoopStart;
                        }
                    }
                }

                // take into account repeats if necessary
                if(( m_mtSeek >= m_mtLoopEnd ) || (m_rtLoopEnd && (m_rtSeek >= m_rtLoopEnd)))
                {
                    // Remember the current loop end
                    if (m_rtLoopEnd)
                    {
                        m_pPerformance->ReferenceToMusicTime(m_rtLoopEnd + m_rtOffset,&m_mtCurLoopEnd);
                    }
                    else
                    {
                        // Again, we have this weirdness with startpoint that should not be...
                        m_pPerformance->MusicToReferenceTime(m_mtLoopEnd + m_mtOffset + m_mtStartPoint, &m_rtCurLoopEnd);
                        m_rtCurLoopEnd -= m_rtStartPoint;
                    }

                    if(m_dwRepeatsLeft)
                    {
                        m_dwPlayTrackFlags |= DMUS_TRACKF_LOOP | DMUS_TRACKF_SEEK;
                        m_dwRepeatsLeft--;
                        pCTrack = m_TrackList.GetHead();
                        while( pCTrack )
                        {
                            pCTrack->m_bDone = FALSE;
                            pCTrack = pCTrack->GetNext();
                        }
                        
                        if (m_rtLoopEnd)
                        {
                            m_rtSeek = m_rtLoopStart;
                            m_rtOffset += ( m_rtLoopEnd - m_rtLoopStart);
                        
                            m_mtOffset += (m_mtCurLoopEnd - m_mtCurLoopStart);
                            m_mtFirstLoopStart += (m_mtCurLoopEnd - m_mtCurLoopStart);
                            m_mtSeek = m_mtFirstLoopStart - m_mtOffset;

                            m_mtEndTime += (m_mtCurLoopEnd - m_mtCurLoopStart);
                   
                            m_mtCurLoopStart = m_mtCurLoopEnd;
                        }
                        else
                        {    
                            m_mtSeek = m_mtLoopStart;
                            m_mtOffset += ( m_mtLoopEnd - m_mtLoopStart);
                        
                            m_rtOffset += (m_rtCurLoopEnd - m_rtCurLoopStart);
                            m_rtFirstLoopStart += (m_rtCurLoopEnd - m_rtCurLoopStart);
                            m_rtSeek = m_rtFirstLoopStart - m_rtOffset;

                            m_rtEndTime += (m_rtCurLoopEnd - m_rtCurLoopStart);
                   
                            m_rtCurLoopStart = m_rtCurLoopEnd;
                        }


                        if( mtMyAmount < mtAmount )
                        {
                            pCTrack = m_TrackList.GetHead(); // cause outer while loop to start over
                            mtMyAmount = mtAmount - mtMyAmount;
                            mtAmount = mtMyAmount;
                            // if we need to do a loop or the end is near, restrict mtMyAmount
                            if( m_dwRepeatsLeft )
                            {
                                if (m_rtLoopEnd)    // Is this a clock time looped segment?
                                {
                                    // If so, convert from clock time to music time.
                                    REFERENCE_TIME rtCalcAmount;
                                    m_pPerformance->MusicToReferenceTime(m_mtLastPlayed + mtMyAmount,&rtCalcAmount);
                                    rtCalcAmount -= m_rtLastPlayed;
                                    if (rtCalcAmount > m_rtLoopEnd - m_rtSeek)
                                    {
                                        rtCalcAmount = m_rtLoopEnd - m_rtSeek;
                                        m_pPerformance->ReferenceToMusicTime(m_rtLastPlayed + rtCalcAmount,&mtMyAmount);
                                        mtMyAmount -= m_mtLastPlayed;
                                        // It's possible to have a rounding error because reference time is so mcuh
                                        // higher than music time. If so, a value of 0 is not appropriate if loopend
                                        // is greater than seek, so fudge by providing one clock to get us there.
                                        if (!mtMyAmount && (m_rtLoopEnd > m_rtSeek))
                                        {
                                            mtMyAmount = 1;
                                        }
                                    }
                                }
                                else if( mtMyAmount > m_mtLoopEnd - m_mtSeek )
                                {
                                    mtMyAmount = m_mtLoopEnd - m_mtSeek;
                                }
                            }
                            else 
                            {
                                if (fUseClockTime)
                                {
                                    if (mtMyAmount > (m_mtEndTime - (m_mtOffset + m_mtSeek)))
                                    {
                                        mtMyAmount = m_mtEndTime - (m_mtOffset + m_mtSeek);
                                    }
                                }
                                else if( mtMyAmount > m_mtLength - m_mtSeek )
                                {
                                    mtMyAmount = m_mtLength - m_mtSeek;
                                }
                            }
                        }
                        // send a segment looped notification
                        GenerateNotification( DMUS_NOTIFICATION_SEGLOOP, m_mtOffset + m_mtSeek );
                        // find out if there's a control segment interrupting this period of time
                        if( S_OK == m_pPerformance->GetControlSegTime( m_mtOffset + m_mtSeek, &mtControlSeg ))
                        {
                            if( m_mtOffset + m_mtSeek == mtControlSeg ) 
                            {
                                // we're at the beginning of a new control seg, so tell the tracks
                                m_dwPlayTrackFlags |= DMUS_TRACKF_DIRTY; 
                            }
                            else if( m_mtOffset + m_mtSeek + mtMyAmount < mtControlSeg )
                            {
                                mtMyAmount = mtControlSeg - m_mtOffset - m_mtSeek;
                            }
                        }
                        m_pPerformance->MusicToReferenceTime(m_mtLastPlayed + mtMyAmount,&rtMyAmount);
                        rtMyAmount -= m_rtLastPlayed;
                    }
                    else if( m_mtSeek == m_mtLength )
                    {
                        // no more repeats.
                        hr = DMUS_S_END;
                    }
                }
            }
        }
    }
    if (hr == DMUS_S_END)
    {
        // send a segment end notification
        GenerateNotification( DMUS_NOTIFICATION_SEGEND, m_mtOffset + m_mtSeek );
        // also queue the almost ended for now
        MUSIC_TIME mtNow;
        m_pPerformance->GetTime( NULL, &mtNow );
        GenerateNotification( DMUS_NOTIFICATION_SEGALMOSTEND, mtNow );
        // if this is a primary or controlling segment, send a DMUS_PMSGT_DIRTY message
        if( !(m_dwPlaySegFlags & DMUS_SEGF_SECONDARY) || (m_dwPlaySegFlags & DMUS_SEGF_CONTROL) )
        {
            TraceI(4, "Send Dirty PMsg [2] %d (%d)\n", m_mtSeek, m_mtOffset + m_mtSeek);
            SendDirtyPMsg( m_mtOffset + m_mtSeek );
        }
        // If this is part of a song, we need to queue the next segment.
        if (m_fSongMode)
        {
            if (m_pSegment)
            {
                CSong *pSong = m_pSegment->m_pSong;
                if (pSong)
                {
                    // Get the next segment from the song.
                    CSegment *pSegment;
                    if (S_OK == pSong->GetPlaySegment(m_pSegment->m_dwNextPlayID,&pSegment))
                    {
                        // Now, play it.
                        // Unless DMUS_SEGF_USE_AUDIOPATH is set, play it on the same audiopath. 
                        // And, make sure that it plays at the same level (control, secondary, or primary.)
                        CSegState *pCSegState = NULL;
                        CAudioPath *pPath = m_pAudioPath;
                        CAudioPath *pInternalPath = NULL;
                        DWORD dwFlags = m_dwPlaySegFlags & (DMUS_SEGF_CONTROL | DMUS_SEGF_SECONDARY);
                        dwFlags &= ~DMUS_SEGF_REFTIME;
                        if (dwFlags & DMUS_SEGF_USE_AUDIOPATH)
                        {
                            IUnknown *pConfig;
                            if (SUCCEEDED(pSegment->GetAudioPathConfig(&pConfig)))
                            {
                                IDirectMusicAudioPath *pNewPath;
                                if (SUCCEEDED(m_pPerformance->CreateAudioPath(pConfig,TRUE,&pNewPath)))
                                {
                                    // Now, get the CAudioPath structure.
                                    pConfig->QueryInterface(IID_CAudioPath,(void **) &pInternalPath);
                                    pPath = pInternalPath;
                                }
                                pConfig->Release();
                            }
                        }
                        if (SUCCEEDED(m_pPerformance->PlayOneSegment((CSegment *)pSegment,dwFlags,m_mtEndTime,&pCSegState,pPath)))
                        {
                            if (m_pSongSegState)
                            {
                                // This is not the first, so transfer the segstate pointer.
                                pCSegState->m_pSongSegState = m_pSongSegState;
                                m_pSongSegState = NULL;
                            }
                            else
                            {
                                // This is the first, so have the next segstate point to this.
                                pCSegState->m_pSongSegState = this;
                                AddRef();
                            }
                            pCSegState->m_fSongMode = TRUE;
                            pCSegState->Release();
                        }
                        if (pInternalPath)
                        {
                            pInternalPath->Release();
                        }
                        pSegment->Release();
                    }
                }
            }
        }
    }
    m_dwPlayTrackFlags &= ~DMUS_TRACKF_DIRTY;
    m_pPerformance->m_dwGetParamFlags = 0;
    m_pPerformance->m_pGetParamSegmentState = NULL;
    m_fInPlay = false;
    if (m_fDelayShutDown)
    {
        Shutdown();
        m_fDelayShutDown = false;
    }
    LeaveCriticalSection(&m_CriticalSection);
    return hr;
}
#endif

HRESULT CSegState::PlayClockTime( REFERENCE_TIME rtAmount )
{
    CTrack* pCTrack;
    MUSIC_TIME mtMyAmount;; // = mtAmount;
    REFERENCE_TIME rtMyAmount = rtAmount;
    HRESULT hr = DMUS_S_END;
//    BOOL fUseClockTime = FALSE;

    if( rtAmount <= 0 )
        return E_INVALIDARG;

    EnterCriticalSection(&m_CriticalSection);
    if (m_fInPlay)
    {
        LeaveCriticalSection(&m_CriticalSection);
        return S_OK;
    }
    m_fInPlay = true;
    m_pPerformance->m_pGetParamSegmentState = (IDirectMusicSegmentState *) this;
    // if this is the first call to play, we need to send a SegStart notification.
    // We also need to check to see if we are supposed to start at the beginning,
    // or at an offset.
    if( m_dwPlayTrackFlags & DMUS_TRACKF_START )
    {
        // send a segment start notification
        GenerateNotification( DMUS_NOTIFICATION_SEGSTART, m_mtOffset );
        // if this is a primary or controlling segment, send a DMUS_PMSGT_DIRTY message
        if( !(m_dwPlaySegFlags & DMUS_SEGF_SECONDARY) || (m_dwPlaySegFlags & DMUS_SEGF_CONTROL) )
        {
            TraceI(4, "Send Dirty PMsg [1] %d (%d)\n", m_mtSeek, m_mtOffset + m_mtSeek);
            SendDirtyPMsg( m_mtOffset + m_mtSeek );
        }
        // set the current seek to the start point
        m_mtSeek = m_mtStartPoint;
        // convert current offset to ref time
        m_pPerformance->MusicToReferenceTime(m_mtOffset,&m_rtOffset);
        m_rtEndTime = m_rtOffset + m_rtLength;
        // subtract the start points from the offsets
        m_mtOffset -= m_mtStartPoint;
        m_rtOffset -= m_rtStartPoint;
        m_rtEndTime -= m_rtStartPoint;
        m_rtSeek = m_rtLastPlayed - m_rtOffset;

    }
    // If there is a reference time length, convert it into mtTime.
    // Because there's always the danger of a tempo change, we do this every
    // time. It doesn't require the tight precision that song time
    // requires, so that's okay.
    m_pPerformance->ReferenceToMusicTime(m_rtEndTime, &m_mtEndTime);
    // if we need to do a loop or the end is near, restrict rtMyAmount
//  ASSERT( m_mtLength ); // length is 0, this segment won't do anything
    if( m_dwRepeatsLeft )
    {
        if( rtMyAmount > m_rtLoopEnd - m_rtSeek )
        {
            rtMyAmount = m_rtLoopEnd - m_rtSeek;
        }
    }
    else 
    {
        if( rtMyAmount > m_rtLength - m_rtSeek )
        {
            rtMyAmount = m_rtLength - m_rtSeek;
        }
    }
    if (rtMyAmount <= 0)
    {
        hr = DMUS_S_END;
    }
    else
    {
        // Now that rtMyAmount is calculated for how far to play in reference time,
        // create the equivalent value in music time.
        m_pPerformance->ReferenceToMusicTime(m_rtLastPlayed + rtMyAmount,&mtMyAmount);
        mtMyAmount -= m_mtLastPlayed;
        pCTrack = m_TrackList.GetHead();
        while( pCTrack )
        {
            if( rtMyAmount )
            {
                m_pPerformance->m_fInTrackPlay = TRUE; // This causes the Pmsgs to be stamped with PRIV_FLAG_TRACK.
                ASSERT( pCTrack->m_pTrack );
                // If either notification or play are enabled, we need to call the play method and set the behavior
                // with the DMUS_TRACKF_NOTIFY_OFF and DMUS_TRACKF_PLAY_OFF flags. 
                if (pCTrack->m_dwFlags & (DMUS_TRACKCONFIG_PLAY_ENABLED | DMUS_TRACKCONFIG_NOTIFICATION_ENABLED))
                {
                    DWORD dwAdditionalFlags = 0;
                    if (!(pCTrack->m_dwFlags & DMUS_TRACKCONFIG_NOTIFICATION_ENABLED))
                    {
                        dwAdditionalFlags = DMUS_TRACKF_NOTIFY_OFF;
                    }
                    if (!(pCTrack->m_dwFlags & DMUS_TRACKCONFIG_PLAY_ENABLED))
                    {
                        dwAdditionalFlags |= DMUS_TRACKF_PLAY_OFF;
                    }
                    // If the track was authored to generate new data on start or loop, let it know.
                    if ( ((m_dwPlayTrackFlags & DMUS_TRACKF_START) && (pCTrack->m_dwFlags & DMUS_TRACKCONFIG_PLAY_COMPOSE)) ||
                        ((m_dwPlayTrackFlags & DMUS_TRACKF_LOOP) && (pCTrack->m_dwFlags & DMUS_TRACKCONFIG_LOOP_COMPOSE)) )
                    {
                        dwAdditionalFlags |= DMUS_TRACKF_RECOMPOSE;
                    }
                    if (pCTrack->m_dwInternalFlags & CONTROL_PLAY_REFRESH)
                    {
                        dwAdditionalFlags |= DMUS_TRACKF_START;
                        pCTrack->m_dwInternalFlags &= ~CONTROL_PLAY_REFRESH;
                    }
                    // Let performance know what the priority should be in ensuing GetParam() calls from the track.
                    m_pPerformance->m_dwGetParamFlags = pCTrack->m_dwFlags;
                    // If track has DX8 interface, use it.
                    if (pCTrack->m_pTrack8)
                    {
                        //  The track can call GetParam on the segment which locks the segment so
                        //  we have to lock the segment before calling PlayEx or we'll deadlock
                        //  with a thread that's calling PlayOneSegment which locks the segment
                        //  before playing the tracks.
                        if (m_pSegment) 
                        {
                            EnterCriticalSection(&m_pSegment->m_CriticalSection);
                        }
                        // If track plays in clock time, use it, otherwise ignore it.
                        if (pCTrack->m_dwFlags & DMUS_TRACKCONFIG_PLAY_CLOCKTIME)
                        {
                            if( ( S_OK == (pCTrack->m_pTrack8->PlayEx(pCTrack->m_pTrackState,
                                m_rtSeek,m_rtSeek + rtMyAmount, m_rtOffset, m_dwPlayTrackFlags | dwAdditionalFlags | DMUS_TRACKF_CLOCK,
                                m_pPerformance, this, pCTrack->m_dwVirtualID ))))
                            {
                                hr = S_OK; // if even one track isn't done playing,
                                // keep going
                            }
                            else 
                            {
                                pCTrack->m_bDone = TRUE;
                            }
                        }
                        if (m_pSegment) 
                        {
                            LeaveCriticalSection(&m_pSegment->m_CriticalSection);
                        }
                    }
                }
                m_pPerformance->m_fInTrackPlay = FALSE;
            }
            pCTrack = pCTrack->GetNext();
            if( pCTrack == NULL )
            {
                // none of the play flags are persistent
                m_dwPlayTrackFlags = 0;
                m_mtLastPlayed += mtMyAmount;   // increment play pointer
                m_rtLastPlayed += rtMyAmount;   // same in ref time
                m_mtSeek += mtMyAmount;         // increment seek pointer
                m_rtSeek += rtMyAmount;
                hr = S_OK;

                // If we're looping....
                // take into account repeats if necessary
                if( m_rtSeek >= m_rtLoopEnd )
                {
                    if(m_dwRepeatsLeft)
                    {
                        m_dwPlayTrackFlags |= DMUS_TRACKF_LOOP | DMUS_TRACKF_SEEK;
                        m_dwRepeatsLeft--;
                        pCTrack = m_TrackList.GetHead();
                        while( pCTrack )
                        {
                            pCTrack->m_bDone = FALSE;
                            pCTrack = pCTrack->GetNext();
                        }
                        
                        m_rtSeek = m_rtLoopStart;
                        m_rtOffset += ( m_rtLoopEnd - m_rtLoopStart);
                    
                        if( rtMyAmount < rtAmount )
                        {
                            pCTrack = m_TrackList.GetHead(); // cause outer while loop to start over
                            rtMyAmount = rtAmount - rtMyAmount;
                            rtAmount = rtMyAmount;
                            // if we need to do a loop or the end is near, restrict rtMyAmount
                            if( m_dwRepeatsLeft )
                            {
                                if( rtMyAmount > m_rtLoopEnd - m_rtSeek )
                                {
                                    rtMyAmount = m_rtLoopEnd - m_rtSeek;
                                }
                            }
                            else 
                            {
                                if (rtMyAmount > (m_rtEndTime - (m_rtOffset + m_rtSeek)))
                                {
                                    rtMyAmount = m_rtEndTime - (m_rtOffset + m_rtSeek);
                                }
                            }
                        }
                        // send a segment looped notification
                        m_pPerformance->ReferenceToMusicTime(m_rtOffset + m_rtSeek,&mtMyAmount);
                        GenerateNotification( DMUS_NOTIFICATION_SEGLOOP, mtMyAmount );
                        m_pPerformance->ReferenceToMusicTime(m_rtLastPlayed + rtMyAmount,&mtMyAmount);
                        mtMyAmount -= m_mtLastPlayed;
                    }
                    else if( m_rtSeek == m_rtLength )
                    {
                        // no more repeats.
                        hr = DMUS_S_END;
                    }
                }
            }
        }
    }
    if (hr == DMUS_S_END)
    {
        // send a segment end notification
        m_pPerformance->ReferenceToMusicTime(m_rtOffset + m_rtSeek,&mtMyAmount);
        GenerateNotification( DMUS_NOTIFICATION_SEGEND, mtMyAmount );
        // also queue the almost ended for now
        MUSIC_TIME mtNow;
        m_pPerformance->GetTime( NULL, &mtNow );
        GenerateNotification( DMUS_NOTIFICATION_SEGALMOSTEND, mtNow );
    }
    m_dwPlayTrackFlags &= ~DMUS_TRACKF_DIRTY;
    m_pPerformance->m_dwGetParamFlags = 0;
    m_pPerformance->m_pGetParamSegmentState = NULL;
    m_fInPlay = false;
    if (m_fDelayShutDown)
    {
        Shutdown();
        m_fDelayShutDown = false;
    }
    LeaveCriticalSection(&m_CriticalSection);
    return hr;
}



CTrack * CSegState::GetTrackByParam( CTrack * pCTrack,
    REFGUID rguidType,DWORD dwGroupBits,DWORD dwIndex)
{
    // If the caller was already part way through the list, it passes the current
    // track. Otherwise, NULL to indicate start at the top.
    if (pCTrack)
    {
        pCTrack = pCTrack->GetNext();
    }
    else
    {
        pCTrack = m_TrackList.GetHead();
    }
    while( pCTrack )
    {
        ASSERT(pCTrack->m_pTrack);
        if( (pCTrack->m_dwGroupBits & dwGroupBits ) && 
            (pCTrack->m_dwFlags & DMUS_TRACKCONFIG_CONTROL_ENABLED))
        {
            if( (GUID_NULL == rguidType) || (pCTrack->m_pTrack->IsParamSupported( rguidType ) == S_OK ))
            {
                if( 0 == dwIndex )
                {
                    return pCTrack;
                }
                dwIndex--;
            }
        }
        pCTrack = pCTrack->GetNext();
    }
    return NULL;
}

/* GetParam() is called by the performance in response to a GetParam() call
   on the performance. This needs the performance pointer so it can handle
   clock time to music time conversion and back, in case the source track is a
   clock time track.
*/

HRESULT CSegState::GetParam(
    CPerformance *pPerf,
    REFGUID rguidType,
    DWORD dwGroupBits,      
    DWORD dwIndex,          
    MUSIC_TIME mtTime,      
    MUSIC_TIME* pmtNext,    
    void* pParam)           
{
    HRESULT hr = DMUS_E_TRACK_NOT_FOUND;
    BOOL fMultipleTry = FALSE;
    if (dwIndex == DMUS_SEG_ANYTRACK)
    {
        dwIndex = 0;
        // Even though DX7 didn't support this, this is always safe because an index this high could never happen.
        fMultipleTry = TRUE; 
    }
    CTrack * pTrack = GetTrackByParam( NULL, rguidType, dwGroupBits, dwIndex);
    while (pTrack)
    {
        if (pTrack->m_pTrack8)
        {
            if (pTrack->m_dwFlags & DMUS_TRACKCONFIG_PLAY_CLOCKTIME)
            {
                REFERENCE_TIME rtTime, rtNext;
                // Convert mtTime into reference time units:
                pPerf->MusicToReferenceTime(m_mtOffset + mtTime,&rtTime);
                rtTime -= m_rtOffset;
                hr = pTrack->m_pTrack8->GetParamEx( rguidType, rtTime, &rtNext, 
                    pParam, pTrack->m_pTrackState, DMUS_TRACK_PARAMF_CLOCK );
                if (pmtNext)
                {
                    if (rtNext == 0) *pmtNext = 0;
                    else
                    {
                        rtNext += m_rtOffset;
                        pPerf->ReferenceToMusicTime(rtNext,pmtNext);
                        *pmtNext -= m_mtOffset;
                    }
                }
            }
            else
            {
                REFERENCE_TIME rtNext, *prtNext;
                // We need to store the next time in a 64 bit pointer. But, don't
                // make 'em fill it in unless the caller requested it. 
                if (pmtNext)
                {
                    prtNext = &rtNext;
                }
                else
                {
                    prtNext = NULL;
                }
                hr = pTrack->m_pTrack8->GetParamEx( rguidType, mtTime, prtNext, pParam,
                    pTrack->m_pTrackState, 0 );
                if (pmtNext)
                {
                    *pmtNext = (MUSIC_TIME) rtNext;
                }
            }
        }
        else
        {
            // This is a pre DX8 track...
            hr = pTrack->m_pTrack->GetParam( rguidType, mtTime, pmtNext, pParam );
        }
        if (SUCCEEDED(hr))
        {
            if( pmtNext )
            { 
                if(( *pmtNext == 0 ) || (*pmtNext > (m_mtLength - mtTime)))
                {
                    // If no next was found OR it's greater than the end of the segment, set 
                    // it to the end of the segment. 
                    *pmtNext = m_mtLength - mtTime;
                }
            }
            pTrack = NULL;
        }
        // If nothing was found and dwIndex was DMUS_SEG_ANYTRACK, try again...
        else if (fMultipleTry && (hr == DMUS_E_NOT_FOUND))
        {
            pTrack = GetTrackByParam( pTrack, rguidType, dwGroupBits, 0);
        }
        else
        {
            pTrack = NULL;
        }
    }
#ifdef DBG
    if (hr == DMUS_E_TRACK_NOT_FOUND)
    {
        Trace(4,"Warning: Segmentstate::GetParam failed, unable to find a track that supports the requested param.\n");
    }
#endif
    return hr;
}


CTrack *CSegState::GetTrack( 
    REFCLSID rType,     
    DWORD dwGroupBits,  
    DWORD dwIndex)
{
    CTrack* pCTrack;
    pCTrack = m_TrackList.GetHead();
    while( pCTrack )
    {
        ASSERT(pCTrack->m_pTrack);
        if( pCTrack->m_dwGroupBits & dwGroupBits )
        {
            if( (GUID_All_Objects == rType) || (pCTrack->m_guidClassID == rType))
            {
                if( 0 == dwIndex )
                {
                    break;
                }
                dwIndex--;
            }
        }
        pCTrack = pCTrack->GetNext();
    }
    return pCTrack;
}

STDMETHODIMP CSegState::SetTrackConfig(REFGUID rguidTrackClassID,
                                      DWORD dwGroup, DWORD dwIndex, 
                                      DWORD dwFlagsOn, DWORD dwFlagsOff) 
{
    V_INAME(IDirectMusicSegment::SetTrackConfig);
    V_REFGUID(rguidTrackClassID);
    if (rguidTrackClassID == GUID_NULL)
    {
        return E_INVALIDARG;
    }
    HRESULT hr = DMUS_E_TRACK_NOT_FOUND;
    CTrack* pCTrack;
    DWORD dwCounter = dwIndex;
    DWORD dwMax = dwIndex;
    if (dwIndex == DMUS_SEG_ALLTRACKS)
    {
        dwCounter = 0;
        dwMax = DMUS_SEG_ALLTRACKS;
    }
    EnterCriticalSection(&m_CriticalSection);
    while (pCTrack = GetTrack(rguidTrackClassID,dwGroup,dwIndex))
    {
        pCTrack->m_dwFlags &= ~dwFlagsOff;
        pCTrack->m_dwFlags |= dwFlagsOn; 
        hr = S_OK;
        dwCounter++;
        if (dwCounter > dwMax) break;
    }
    LeaveCriticalSection(&m_CriticalSection);
#ifdef DBG
    if (hr == DMUS_E_TRACK_NOT_FOUND)
    {
        Trace(1,"Error: Segmentstate::SetTrackConfig failed, unable to find the requested track.\n");
    }
#endif
    return hr;
}

HRESULT CSegState::CheckPlay( 
    MUSIC_TIME mtAmount, MUSIC_TIME* pmtResult )
{
    MUSIC_TIME mtMyAmount = mtAmount;
    MUSIC_TIME mtSeek = m_mtSeek;
    MUSIC_TIME mtOffset = m_mtOffset;

    ASSERT(pmtResult);
    if (m_rtLength && m_rtLoopEnd)
    {
        // This is using the clock time code. In that case, 
        // we aren't worrying about controlling segments, so we can simply
        // return the time unchanged.
        *pmtResult = mtAmount;
        return S_OK;
    }

    // if this is the first call to play,
    // We also need to check to see if we are supposed to start at the beginning,
    // or at an offset.
    if( m_dwPlayTrackFlags & DMUS_TRACKF_START )
    {
        // set the current seek to the start point
        mtSeek = m_mtStartPoint;
    }
    // if we need to do a loop or the end is near, restrict mtMyAmount
    ASSERT( m_mtLength ); // length is 0, this segment won't do anything
    if( m_dwRepeatsLeft )
    {
        if( mtMyAmount > m_mtLoopEnd - mtSeek )
        {
            mtMyAmount = m_mtLoopEnd - mtSeek;
        }
    }
    else if( mtMyAmount > m_mtLength - mtSeek )
    {
        mtMyAmount = m_mtLength - mtSeek;
    }
    
    // take into account repeats if necessary
    *pmtResult = mtMyAmount;
    return S_OK;
}

///////////////////////////////////////////////////////////////////////
// IDirectMusicSegmentState::GetStartTime
/*
@method HRESULT | IDirectMusicSegmentState | GetStartTime |
Gets the music time this SegmentState started playing.

@rvalue E_POINTER | <p pmtStart> is NULL or invalid.
@rvalue S_OK | Success.

@xref <om IDirectMusicPerformance.PlaySegment>
*/
HRESULT STDMETHODCALLTYPE CSegState::GetStartTime( 
    MUSIC_TIME *pmtStart)   // @parm Returns the music time of the start of this SegmentState.
                            // This is the music time, in Performance time, that the SegmentState
                            // started or will start playing.
{
    V_INAME(IDirectMusicSegmentState::GetStartTime);
    V_PTR_WRITE(pmtStart,MUSIC_TIME);

    *pmtStart = m_mtResolvedStart;
    return S_OK;
}

///////////////////////////////////////////////////////////////////////
// IDirectMusicSegmentState::GetStartPoint
/*
@method HRESULT | IDirectMusicSegmentState | GetStartPoint |
Calling <om IDirectMusicSegment.SetStartPoint> causes the SegmentState to begin
playing from the middle instead of from the beginning. <om .GetStartPoint>
returns the amount of time from the beginning of the SegmentState that it
plays.

@rvalue E_POINTER | <p pmtStart> is NULL or invalid.
@rvalue S_OK | Success.

@xref <om IDirectMusicSegment.SetStartPoint>,
<om IDirectMusicPerformance.PlaySegment>
*/
HRESULT STDMETHODCALLTYPE CSegState::GetStartPoint( 
    MUSIC_TIME *pmtStart)   // @parm Returns the music time offset from the start of the
                            // SegmentState at which the SegmentState initially plays.
{
    V_INAME(IDirectMusicSegmentState::GetStartPoint);
    V_PTR_WRITE(pmtStart,MUSIC_TIME);

    *pmtStart = m_mtStartPoint;
    return S_OK;
}

///////////////////////////////////////////////////////////////////////
// IDirectMusicSegmentState::SetSeek
/*
method (INTERNAL) HRESULT | IDirectMusicSegmentState | SetSeek |
Sets the music time Seek maintained by this SegmentState.

parm MUSIC_TIME | mtSeek |
    [in] The music time Seek to store in this SegmentState.

comm The SegmentState passes this Seek value to <im IDirectMusicTrack.Play>
Note that newly created SegmentState's start with a Seek time of 0.
rvalue S_OK | Success.
*/
HRESULT CSegState::SetSeek( 
    MUSIC_TIME mtSeek, DWORD dwPlayFlags)
{
    m_mtSeek = mtSeek;
    m_dwPlayTrackFlags |= dwPlayFlags | DMUS_TRACKF_SEEK;
    return S_OK;
}

/*
Called from IDirectMusicPerformance::Invalidate, this routine helps set
the current seek pointer. Done here instead of directly inside Performance
because it's easier to compute the repeats, etc. here.
*/
HRESULT CSegState::SetInvalidate(
    MUSIC_TIME mtTime) // mtTime is in Performance time
{
    MUSIC_TIME mtOffset;
    DWORD dwRepeat;
    DWORD dwFlags = DMUS_TRACKF_FLUSH | DMUS_TRACKF_SEEK;

    if (m_rtLength && m_rtLoopEnd)
    {
        return S_OK;
    }
    HRESULT hr = ConvertToSegTime( &mtTime, &mtOffset, &dwRepeat );
    if( hr != S_OK )
    {
        mtTime = 0;
        m_dwRepeatsLeft = m_dwRepeats;
        m_mtOffset = m_mtResolvedStart;
        dwFlags |= DMUS_TRACKF_START;
    }
    else
    {
        m_dwRepeatsLeft = m_dwRepeats - dwRepeat;
        m_mtOffset = mtOffset;
    }
    EnterCriticalSection(&m_CriticalSection);
    CTrack* pCTrack = m_TrackList.GetHead();
    while( pCTrack )
    {
        pCTrack->m_bDone = FALSE;
        pCTrack = pCTrack->GetNext();
    }
    LeaveCriticalSection(&m_CriticalSection);
    return SetSeek( mtTime, dwFlags );
}

///////////////////////////////////////////////////////////////////////
// IDirectMusicSegmentState::GetSeek

HRESULT STDMETHODCALLTYPE CSegState::GetSeek( 
    MUSIC_TIME *pmtSeek) // @parm Returns the current seek pointer, which indicates
                        // the next time that will be called inside <om IDirectMusicTrack.Play>.
{
    V_INAME(IDirectMusicSegmentState::GetSeek);
    V_PTR_WRITE(pmtSeek, MUSIC_TIME);

    *pmtSeek = m_mtSeek;
    return S_OK;
}

HRESULT STDMETHODCALLTYPE CSegState::Flush(MUSIC_TIME mtTime) // The time on and after which to flush.
{
    CTrack* pTrack;
    EnterCriticalSection(&m_CriticalSection);
    pTrack = m_TrackList.GetHead();
    while( pTrack )
    {
        m_pPerformance->FlushVirtualTrack( pTrack->m_dwVirtualID, mtTime, 0 );
        pTrack = pTrack->GetNext();
    }
    LeaveCriticalSection(&m_CriticalSection);
    return S_OK;
}

HRESULT STDMETHODCALLTYPE CSegState::Shutdown()
{
    return E_NOTIMPL;
}

HRESULT STDMETHODCALLTYPE CSegState::InsertTool( 
    IDirectMusicTool *pTool,
    DWORD *pdwPChannels,
    DWORD cPChannels,
    LONG lIndex)
{
    return E_NOTIMPL;
}

HRESULT STDMETHODCALLTYPE CSegState::GetTool(
    DWORD dwIndex,
    IDirectMusicTool** ppTool)
{
    return E_NOTIMPL;
}

HRESULT STDMETHODCALLTYPE CSegState::RemoveTool(
    IDirectMusicTool* pTool)
{
    return E_NOTIMPL;
}

HRESULT STDMETHODCALLTYPE CSegState::StampPMsg( 
    /* [in */ DMUS_PMSG* pPMsg)
{
    V_INAME(IDirectMusicSegmentState::StampPMsg);
    if( m_dwVersion < 8)
    {
        V_BUFPTR_WRITE(pPMsg,sizeof(DMUS_PMSG));
    }
    else
    {
#ifdef DBG
        V_BUFPTR_WRITE(pPMsg,sizeof(DMUS_PMSG));
#else
        if (!pPMsg)
        {
            return E_POINTER;
        }
#endif
    }
    HRESULT hr = E_FAIL;
    EnterCriticalSection(&m_CriticalSection);

    if (m_pPerformance) 

    {
        // First, check if the segmentstate has its own graph.
        if (m_pGraph)
        {
            // Could return DMUS_S_LAST_TOOL, indicating end of graph. 
            // If so, we'll treat that as a failure and drop on through to the next graph...
            if( S_OK == ( hr = m_pGraph->StampPMsg( pPMsg )))
            {
                if( pPMsg->pGraph != this ) // Make sure this is set to point to the segstate embedded graph so it will come here again.
                {
                    if( pPMsg->pGraph )
                    {
                        pPMsg->pGraph->Release();
                        pPMsg->pGraph = NULL;
                    }
                    pPMsg->pGraph = this;
                    AddRef();
                }
            }
        }
        // If done with the graph, send to the audio path, if it exists,
        // else the performance. Also, check for the special case of 
        // DMUS_PCHANNEL_BROADCAST_SEGMENT. If so, duplicate the pMsg
        // and send all the copies with the appropriate pchannel values.
        if( FAILED(hr) || (m_dwVersion && (hr == DMUS_S_LAST_TOOL)))
        {
            if (pPMsg->dwPChannel == DMUS_PCHANNEL_BROADCAST_SEGMENT)
            {
                CSegment *pSegment = m_pSegment;
                EnterCriticalSection(&pSegment->m_CriticalSection);
                DWORD dwIndex;
                // Create new messages with new pchannels for all but one, which will
                // be assigned to this message.
                for (dwIndex = 1;dwIndex < pSegment->m_dwNumPChannels;dwIndex++)
                {
                    DWORD dwNewChannel = pSegment->m_paPChannels[dwIndex];
                    // Don't broadcast any broadcast messages!
                    // And, if this is a transpose on the drum channel, don't send it.
                    if ((dwNewChannel < DMUS_PCHANNEL_BROADCAST_GROUPS) &&
                        ((pPMsg->dwType != DMUS_PMSGT_TRANSPOSE) || ((dwNewChannel & 0xF) != 9)))
                    {
                        DMUS_PMSG *pNewMsg;
                        if (SUCCEEDED(m_pPerformance->ClonePMsg(pPMsg,&pNewMsg)))
                        {
                            HRESULT hrTemp;
                            pNewMsg->dwPChannel = dwNewChannel;
                            if (m_pAudioPath)
                            {
                                hrTemp = m_pAudioPath->StampPMsg(pNewMsg);
                            }
                            else
                            {
                                hrTemp = m_pPerformance->StampPMsg(pNewMsg);
                            }
                            if (SUCCEEDED(hrTemp))
                            {
                                m_pPerformance->SendPMsg(pNewMsg);
                            }
                            else
                            {
                                m_pPerformance->FreePMsg(pNewMsg);
                            }
                        }
                    }
                }
                // Now, set the pchannel for this one. First check that there are any
                // pchannels. If none, mark the PMsg to be deleted by the SendPMsg routine.
                // Also, mark it this way if the PMsg is a broadcast PMsg.
                pPMsg->dwPChannel = DMUS_PCHANNEL_KILL_ME;
                if (pSegment->m_dwNumPChannels)
                {
                    if (pSegment->m_paPChannels[0] < DMUS_PCHANNEL_BROADCAST_GROUPS)
                    {
                        pPMsg->dwPChannel = pSegment->m_paPChannels[0];
                    }
                }
                LeaveCriticalSection(&pSegment->m_CriticalSection);
            }
            if (m_pAudioPath)
            {
                hr = m_pAudioPath->StampPMsg(pPMsg);
            }
            else
            {
                hr = m_pPerformance->StampPMsg(pPMsg);
            }
        }

    }
    else
    {
        hr = DMUS_E_NOT_INIT;
        Trace(1,"Error: Segmentstate::StampPMsg failed because the segmentstate is not properly initialized.\n");
    }
    LeaveCriticalSection(&m_CriticalSection);
    return hr;
}


STDMETHODIMP CSegState::GetObjectInPath( DWORD dwPChannel,DWORD dwStage,DWORD dwBuffer, REFGUID guidObject,
                    DWORD dwIndex,REFGUID iidInterface, void ** ppObject)
{
    V_INAME(IDirectMusicSegmentState::GetObjectInPath);
    V_PTRPTR_WRITE(ppObject);
    *ppObject = NULL;
    if (dwBuffer && ((dwStage < DMUS_PATH_BUFFER) || (dwStage >= DMUS_PATH_PRIMARY_BUFFER)))
    {
        return DMUS_E_NOT_FOUND;
    }
    HRESULT hr = DMUS_E_NOT_FOUND;
    EnterCriticalSection(&m_CriticalSection);
    switch (dwStage)
    {
    case DMUS_PATH_SEGMENT:
        if (m_pSegment && (dwIndex == 0) && (dwPChannel == 0))
        {
            hr = m_pSegment->QueryInterface(iidInterface,ppObject);
        }
        break;
    case DMUS_PATH_SEGMENT_TRACK:
        if (dwPChannel == 0)
        {
            CTrack * pCTrack = GetTrack(guidObject,-1,dwIndex);
            if (pCTrack)
            {
                if (pCTrack->m_pTrack)
                {
                    hr = pCTrack->m_pTrack->QueryInterface(iidInterface,ppObject);
                }
            }
        }
        break;
    case DMUS_PATH_SEGMENT_GRAPH:
        if ((dwIndex == 0) && (dwPChannel == 0))
        {
            if (!m_pGraph)
            {
                m_pGraph = new CGraph;
            }
            if (m_pGraph)
            {
                hr = m_pGraph->QueryInterface(iidInterface,ppObject);
            }
            else
            {
                hr = E_OUTOFMEMORY;
            }
        }
        break;
    case DMUS_PATH_SEGMENT_TOOL:
        if (!m_pGraph)
        {
            m_pGraph = new CGraph;
        }
        if (m_pGraph)
        {
            hr = m_pGraph->GetObjectInPath(dwPChannel,guidObject,dwIndex,iidInterface,ppObject);
        }
        else
        {
            hr = E_OUTOFMEMORY;
        }
        break;
    case DMUS_PATH_PERFORMANCE:
        if (m_pPerformance && (dwIndex == 0) && (dwPChannel == 0))
        {
            hr = m_pPerformance->QueryInterface(iidInterface,ppObject);
        }
        break;
    case DMUS_PATH_PERFORMANCE_GRAPH:
        if (m_pPerformance && (dwIndex == 0) && (dwPChannel == 0))
        {
            IDirectMusicGraph *pGraph;
            if (SUCCEEDED(hr = m_pPerformance->GetGraphInternal(&pGraph)))
            {
                hr = pGraph->QueryInterface(iidInterface,ppObject);
                pGraph->Release();
            }
        }
        break;
    case DMUS_PATH_PERFORMANCE_TOOL:
        if (m_pPerformance)
        {
            IDirectMusicGraph *pGraph;
            if (SUCCEEDED(hr = m_pPerformance->GetGraphInternal(&pGraph)))
            {
                CGraph *pCGraph = (CGraph *) pGraph;
                hr = pCGraph->GetObjectInPath(dwPChannel,guidObject,dwIndex,iidInterface,ppObject);
                pGraph->Release();
            }
        }
        break;
    default:
        if (m_pAudioPath)
        {
            hr = m_pAudioPath->GetObjectInPath(dwPChannel,dwStage,dwBuffer,guidObject,dwIndex,iidInterface,ppObject);
        }
        else
        {
            Trace(1,"Error: Unable to access audiopath components of segmentstate.\n");
        }
    }
    LeaveCriticalSection(&m_CriticalSection);
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\XDmime\dmusiccp.h ===
//
// dmusiccp.h
//
// Copyright (c) 2000 Microsoft Corporation. All rights reserved.
//
// Private interfaces

#ifndef _DMUSICCP_DOT_H_
#define _DMUSICCP_DOT_H_

#include <dsoundp.h>  // For IDirectSoundWave

// Interfaces/methods removed from Direct Music Core layer:

// IDirectMusicVoiceP
interface IDirectMusicVoiceP : IUnknown
{
	// IUnknown
	virtual HRESULT STDMETHODCALLTYPE QueryInterface(REFIID, LPVOID FAR *)=0; 
	virtual ULONG STDMETHODCALLTYPE AddRef()=0; 
	virtual ULONG STDMETHODCALLTYPE Release()=0; 

	// IDirectMusicVoiceP
	virtual HRESULT STDMETHODCALLTYPE Play(
         REFERENCE_TIME rtStart,                // Time to play
         LONG prPitch,                          // Initial pitch
         LONG vrVolume                          // Initial volume
        )=0;
    
	virtual HRESULT STDMETHODCALLTYPE Stop(
          REFERENCE_TIME rtStop                 // When to stop
        )=0;
};


// IDirectSoundDownloadedWaveP
interface IDirectSoundDownloadedWaveP : IUnknown
{
	// IUnknown
	virtual HRESULT STDMETHODCALLTYPE QueryInterface(REFIID, LPVOID FAR *)=0; 
	virtual ULONG STDMETHODCALLTYPE AddRef()=0; 
	virtual ULONG STDMETHODCALLTYPE Release()=0; 

	// IDirectSoundDownloadedWaveP
};

// IDirectMusicPortP
interface IDirectMusicPortP : IUnknown
{
	// IUnknown
	virtual HRESULT STDMETHODCALLTYPE QueryInterface(REFIID, LPVOID FAR *)=0; 
	virtual ULONG STDMETHODCALLTYPE AddRef()=0; 
	virtual ULONG STDMETHODCALLTYPE Release()=0; 

	// IDirectMusicPortP
	virtual HRESULT STDMETHODCALLTYPE DownloadWave(
		IDirectSoundWave *pWave,                // Wave object
        IDirectSoundDownloadedWaveP **ppWave,   // Returned downloaded wave
        REFERENCE_TIME rtStartHint = 0          // Where we're likely to start
        )=0;
        
	virtual HRESULT STDMETHODCALLTYPE UnloadWave(
		IDirectSoundDownloadedWaveP *pWave      // Wave object
        )=0;
            
	virtual HRESULT STDMETHODCALLTYPE AllocVoice(
         IDirectSoundDownloadedWaveP *pWave,    // Wave to play on this voice
         DWORD dwChannel,                       // Channel and channel group
         DWORD dwChannelGroup,                  //  this voice will play on
         REFERENCE_TIME rtStart,                // Start position (stream only)
         SAMPLE_TIME stLoopStart,               // Loop start (one-shot only)
         SAMPLE_TIME stLoopEnd,                 // Loop end (one-shot only)
         IDirectMusicVoiceP **ppVoice           // Returned voice
        )=0;
        
	virtual HRESULT STDMETHODCALLTYPE AssignChannelToBuses(
		DWORD dwChannelGroup,                   // Channel group and
		DWORD dwChannel,                        // channel to assign
		LPDWORD pdwBuses,                       // Array of bus id's to assign
		DWORD cBusCount                         // Count of bus id's           
        )=0;
        
	virtual HRESULT STDMETHODCALLTYPE SetSink(
		IDirectSoundConnect *pSinkConnect       // From IDirectSoundPrivate::AllocSink
        )=0;
        
 	virtual HRESULT STDMETHODCALLTYPE GetSink(
		IDirectSoundConnect **ppSinkConnect     // The sink in use 
        )=0;
};

// GUIDs for new core layer private interfaces
DEFINE_GUID(IID_IDirectMusicVoiceP, 0x827ae928, 0xe44, 0x420d, 0x95, 0x24, 0x56, 0xf4, 0x93, 0x57, 0x8, 0xa6);
DEFINE_GUID(IID_IDirectSoundDownloadedWaveP, 0x3b527b6e, 0x5577, 0x4060, 0xb9, 0x6, 0xcd, 0x34, 0xa, 0x46, 0x71, 0x27);
DEFINE_GUID(IID_IDirectMusicPortP, 0x7048bcd8, 0x43fd, 0x4ca5, 0x93, 0x11, 0xf3, 0x24, 0x8f, 0xa, 0x25, 0x22);

// Class ID for synth sink. We pulled this from public headers since apps should never cocreate this.
DEFINE_GUID(CLSID_DirectMusicSynthSink,0xaec17ce3, 0xa514, 0x11d1, 0xaf, 0xa6, 0x0, 0xaa, 0x0, 0x24, 0xd8, 0xb6);


#endif          // _DMUSICCP_DOT_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\XDmime\dmsegobj.h ===
// Copyright (c) 1998-1999 Microsoft Corporation
// DMSegObj.h : Declaration of the CSegment

#ifndef __DIRECTMUSICSEGMENTOBJECT_H_
#define __DIRECTMUSICSEGMENTOBJECT_H_

#include "dmusici.h"
#include "dmusicf.h"
#include "dmime.h"

#include "TrkList.h"
#include "ntfylist.h"
#include "dmsstobj.h"
#include "dmusicp.h"

#define COMPOSE_TRANSITION1 (DMUS_TRACKCONFIG_TRANS1_FROMSEGSTART | DMUS_TRACKCONFIG_TRANS1_FROMSEGCURRENT | DMUS_TRACKCONFIG_TRANS1_TOSEGSTART)

class CSegment;

DEFINE_GUID(IID_CSegment,0xb06c0c21, 0xd3c7, 0x11d3, 0x9b, 0xd1, 0x44, 0x45, 0x53, 0x54, 0x0, 0x0);

/////////////////////////////////////////////////////////////////////////////
// CSegment
class CSegment : 
	public IDirectMusicSegment8,
	public IDirectMusicSegment8P,
	public IPersistStream,
	public IDirectMusicObject,
    public AListItem,
    public IDirectMusicObjectP
{
friend class CPerformance;
friend class CSegState;
friend class CSong;
public:
	CSegment();
    CSegment(DMUS_IO_SEGMENT_HEADER *pHeader, CSegment *pSource);
	~CSegment();
    CSegment* GetNext() { return (CSegment*)AListItem::GetNext();}

public:
// IUnknown
    STDMETHODIMP QueryInterface(const IID &iid, void **ppv);
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();
// IDirectMusicSegment
    STDMETHODIMP GetLength(MUSIC_TIME *pmtLength);
    STDMETHODIMP SetLength(MUSIC_TIME pmtLength);
    STDMETHODIMP GetRepeats(DWORD *pdwRepeats);
    STDMETHODIMP SetRepeats(DWORD dwRepeats);
    STDMETHODIMP GetDefaultResolution(DWORD *pdwResolution);
    STDMETHODIMP SetDefaultResolution(DWORD dwResolution);
    STDMETHODIMP GetTrack(REFCLSID rType,DWORD dwGroupBits,DWORD dwIndex,IDirectMusicTrack **ppTrack);
    STDMETHODIMP GetTrackGroup(IDirectMusicTrack* pTrack,DWORD* pdwGroupBits);
    STDMETHODIMP InsertTrack(IDirectMusicTrack *pTrack,DWORD dwGroupBits);
    STDMETHODIMP RemoveTrack(IDirectMusicTrack *pTrack);
    STDMETHODIMP InitPlay(IDirectMusicSegmentState **ppSegState,IDirectMusicPerformance *pPerformance,DWORD dwFlags);
    STDMETHODIMP GetGraph(IDirectMusicGraph** ppGraph);
    STDMETHODIMP SetGraph(IDirectMusicGraph* pGraph);
    STDMETHODIMP AddNotificationType(REFGUID rguidNotification);
    STDMETHODIMP RemoveNotificationType(REFGUID rguidNotification);
	STDMETHODIMP GetParam(REFGUID rguidDataType,DWORD dwGroupBits,
                    DWORD dwIndex,MUSIC_TIME mtTime, 
				    MUSIC_TIME* pmtNext,void* pData); 
    STDMETHODIMP SetParam(REFGUID rguidDataType,DWORD dwGroupBits, 
				    DWORD dwIndex,MUSIC_TIME mtTime,void* pData);
    STDMETHODIMP Clone(MUSIC_TIME mtStart,MUSIC_TIME mtEnd,IDirectMusicSegment** ppSegment);
	STDMETHODIMP GetStartPoint(MUSIC_TIME* pmtStart);
    STDMETHODIMP SetStartPoint(MUSIC_TIME mtStart);
    STDMETHODIMP GetLoopPoints(MUSIC_TIME* pmtStart,MUSIC_TIME* pmtEnd);
    STDMETHODIMP SetLoopPoints(MUSIC_TIME mtStart,MUSIC_TIME mtEnd);
    STDMETHODIMP SetPChannelsUsed(DWORD dwNumPChannels,DWORD* paPChannels);
//  IDirectMusicSegment8 
    STDMETHODIMP SetTrackConfig(REFGUID rguidTrackClassID,DWORD dwGroup, DWORD dwIndex, DWORD dwFlagsOn, DWORD dwFlagsOff) ;
    STDMETHODIMP GetAudioPathConfig(IUnknown ** ppIAudioPathConfig);
    STDMETHODIMP Compose(MUSIC_TIME mtTime,
		IDirectMusicSegment* pFromSegment,
		IDirectMusicSegment* pToSegment,
		IDirectMusicSegment** ppComposedSegment);
    STDMETHODIMP Download(IUnknown *pAudioPath);
    STDMETHODIMP Unload(IUnknown *pAudioPath);
// IDirectMusicSegment8P
    STDMETHODIMP GetObjectInPath(DWORD dwPChannel,    /* PChannel to search. */
                                    DWORD dwStage,       /* Which stage in the path. */
                                    DWORD dwBuffer,
                                    REFGUID guidObject,  /* ClassID of object. */
                                    DWORD dwIndex,       /* Which object of that class. */
                                    REFGUID iidInterface,/* Requested COM interface. */
                                    void ** ppObject) ; /* Pointer to interface. */
    STDMETHODIMP GetHeaderChunk(
        DWORD *pdwSize,      /* Size of passed header chunk. Also, returns size written. */
        DMUS_IO_SEGMENT_HEADER *pHeader); /* Header chunk to fill. */
    STDMETHODIMP SetHeaderChunk(
        DWORD dwSize,        /* Size of passed header chunk. */
        DMUS_IO_SEGMENT_HEADER *pHeader); /* Header chunk to fill. */
    STDMETHODIMP SetTrackPriority(
        REFGUID rguidTrackClassID,  /* ClassID of Track. */
        DWORD dwGroupBits,          /* Group bits. */
        DWORD dwIndex,              /* Nth track. */
        DWORD dwPriority);       /* Priority to set. */
    STDMETHODIMP SetAudioPathConfig(
        IUnknown *pAudioPathConfig);

// IPersist 
    STDMETHODIMP GetClassID( CLSID* pClsId );

// IPersistStream 
    STDMETHODIMP IsDirty();
    STDMETHODIMP Load( IStream* pIStream );
    STDMETHODIMP Save( IStream* pIStream, BOOL fClearDirty );
    STDMETHODIMP GetSizeMax( ULARGE_INTEGER FAR* pcbSize );

// IDirectMusicObject 
	STDMETHODIMP GetDescriptor(LPDMUS_OBJECTDESC pDesc);
	STDMETHODIMP SetDescriptor(LPDMUS_OBJECTDESC pDesc);
	STDMETHODIMP ParseDescriptor(LPSTREAM pStream, LPDMUS_OBJECTDESC pDesc);

	HRESULT GetPChannels( DWORD* pdwNumPChannels, DWORD** ppaPChannels );
	HRESULT CheckNotification( REFGUID );

// IDirectMusicObjectP
	STDMETHOD_(void, Zombie)();

public:
    HRESULT GetTrackConfig(REFGUID rguidTrackClassID,DWORD dwGroup, DWORD dwIndex, DWORD *pdwFlags) ;
    HRESULT AddNotificationType(REFGUID rguidNotification, BOOL fFromPerformance);
    HRESULT RemoveNotificationType(REFGUID rguidNotification, BOOL fFromPerformance);
    BOOL IsTempoSource();	
    HRESULT CreateSegmentState(CSegState **ppSegState,CPerformance *pPerformance, 
        IDirectMusicAudioPath *pAudioPath, DWORD dwFlags); 
    CTrack *GetTrack(REFCLSID rType,DWORD dwGroupBits,DWORD dwIndex);
    CTrack * GetTrackByParam(CTrack * pCTrack,REFGUID rguidType,DWORD dwGroupBits,DWORD dwIndex, BOOL fDontCheck);
    HRESULT GetTrackByParam(REFGUID rgCommandGuid,DWORD dwGroupBits,
        DWORD dwIndex,IDirectMusicTrack **ppTrack);
	HRESULT LoadDirectMusicSegment(IStream* pIStream);	
	void AddNotificationTypeToAllTracks( REFGUID rguidNotification );
	void RemoveNotificationTypeFromAllTracks( REFGUID rguidNotification );
	CNotificationItem* FindNotification( REFGUID rguidNotification );
	HRESULT LoadTrack(CRiffParser *pParser);
	HRESULT CreateTrack(DMUS_IO_TRACK_HEADER& ioDMHdr, DWORD dwFlags, DWORD dwPriority, IStream *pStream);
    HRESULT InsertTrack(IDirectMusicTrack *pTrack,DWORD dwGroupBits, DWORD dwFlags, DWORD dwPriority, DWORD dwPosition);
	HRESULT LoadGraph(CRiffParser *pParser,CGraph **ppGraph);
    HRESULT LoadAudioPath(IStream *pStream);
	HRESULT ParseSegment(IStream* pIStream, LPDMUS_OBJECTDESC pDesc);
    void Init();
    HRESULT ComposeTransition(MUSIC_TIME mtTime,
		IDirectMusicSegment* pFromSegment,
		IDirectMusicSegment* pToSegment);
    HRESULT ComposeInternal();
	HRESULT SetClockTimeDuration(REFERENCE_TIME rtDuration);
	HRESULT SetFlags(DWORD dwFlags);
    void Clear(bool fZombie);
    HRESULT MusicToReferenceTime(MUSIC_TIME mtTime, REFERENCE_TIME *prtTime);
    HRESULT ReferenceToMusicTime(REFERENCE_TIME rtTime, MUSIC_TIME *pmtTime);

// Attributes
protected:
    CRITICAL_SECTION    m_CriticalSection;
	DWORD	            m_dwRepeats;	// # of times to repeat the segment. 0xffffffff is infinite
	DWORD	            m_dwResolution; // the default resolution to start motifs and such.
    DWORD               m_dwSegFlags;   // Flags loaded in with segment. 
	CTrackList	        m_TrackList;	// list of Tracks held in this Segment
    CAudioPathConfig*   m_pAudioPathConfig; // Optional audio path loaded from file. 
    CGraph*	            m_pGraph;       // Optional tool graph for segment.
	CNotificationList	m_NotificationList;
    REFERENCE_TIME      m_rtLength;     // Optional length in reference time units. 
    REFERENCE_TIME      m_rtLoopStart;
    REFERENCE_TIME      m_rtLoopEnd;
	MUSIC_TIME	        m_mtLength;
	MUSIC_TIME	        m_mtStart;
	MUSIC_TIME	        m_mtLoopStart;
	MUSIC_TIME	        m_mtLoopEnd;
	DWORD	            m_dwNumPChannels;
	DWORD*	            m_paPChannels;
	long                m_cRef;
    IUnknown *          m_pUnkDispatch; // holds the controlling unknown of the scripting object that implements IDispatch
// IDirectMusicObject variables
	DWORD	            m_dwValidData;
	GUID	            m_guidObject;
	FILETIME	        m_ftDate;                       /* Last edited date of object. */
	DMUS_VERSION	    m_vVersion;                 /* Version. */
	WCHAR	            m_wszName[DMUS_MAX_NAME];			/* Name of object.       */
	WCHAR	            m_wszCategory[DMUS_MAX_CATEGORY];	/* Category for object */
	WCHAR               m_wszFileName[DMUS_MAX_FILENAME];	/* File path. */
    DWORD               m_dwVersion;        // Which version of the interfaces is the app requesting?

    bool                m_fZombie;

public:
    DWORD               m_dwLoadID;     // Identifier, used when loaded as part of a song.
    CSong*              m_pSong;        // Optional parent song that segment belongs to. This is not AddRef'd.
    DWORD               m_dwPlayID;     // ID of segment, if within a song.
    DWORD               m_dwNextPlayID; // ID of next segment, if within a song.
    DWORD               m_dwNextPlayFlags; // DMUS_SEGF flags for playing next segment, if within a song.
    BOOL                m_fPlayNext;    // Whether the next segment should be played.
};

class CSegmentList : public AList
{
public:
    void Clear();
    void AddHead(CSegment* pSegment) { AList::AddHead((AListItem*)pSegment);}
    void Insert(CSegment* pSegment);
    BOOL IsMember(CSegment *pSegment) { return AList::IsMember((AListItem*)pSegment);}
    CSegment* GetHead(){return (CSegment*)AList::GetHead();}
    CSegment* GetItem(LONG lIndex){return (CSegment*)AList::GetItem(lIndex);}
    CSegment* RemoveHead() {return (CSegment *) AList::RemoveHead();}
    void Remove(CSegment* pSegment){AList::Remove((AListItem*)pSegment);}
    void AddTail(CSegment* pSegment){AList::AddTail((AListItem*)pSegment);}
    CSegment* GetTail(){ return (CSegment*)AList::GetTail();}
};


#endif //__DIRECTMUSICSEGMENTOBJECT_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\XDmime\dmsstobj.h ===
// Copyright (c) 1998-1999 Microsoft Corporation
// DMSStObj.h : Declaration of the CSegState

#ifndef __DIRECTMUSICSEGMENTSTATEOBJECT_H_
#define __DIRECTMUSICSEGMENTSTATEOBJECT_H_

#include "dmusici.h"
#include "TrkList.h"
#include "alist.h"
#include "audpath.h"

class CPerformance;
class CSegState;
class CGraph;

// Control flags, placed in track->m_dwInternalFlags by ManageControllingTracks().

#define CONTROL_PLAY_IS_DISABLED       0x1   // Indicates the track is already disabled.
#define CONTROL_PLAY_WAS_DISABLED      0x2   // Indicates the track was previously disabled.
#define CONTROL_PLAY_REFRESH           0x4   // Indicates it has been reenabled and needs to be refreshed.
#define CONTROL_PLAY_DEFAULT_DISABLED  0x8   // Indicates it was disabled for playback anyway.
#define CONTROL_PLAY_DEFAULT_ENABLED   0x10  // Indicates it was enabled for playback.

#define CONTROL_NTFY_IS_DISABLED       0x20  // Indicates the track is already disabled for notifications.
#define CONTROL_NTFY_DEFAULT_DISABLED  0x40  // Indicates it was disabled for notifications anyway.
#define CONTROL_NTFY_DEFAULT_ENABLED   0x80  // Indicates it was enabled for notifications.

DEFINE_GUID(IID_CSegState,0xb06c0c26, 0xd3c7, 0x11d3, 0x9b, 0xd1, 0x44, 0x45, 0x53, 0x54, 0x0, 0x0);

/////////////////////////////////////////////////////////////////////////////
// CSegState
class CSegState : 
	public IDirectMusicSegmentState8,
	public IDirectMusicGraph,
    public AListItem
{
friend class CSegment;
friend class CAudioPath;
friend class CPerformance;
public:
	CSegState();
	~CSegState();

// IUnknown
    virtual STDMETHODIMP QueryInterface(const IID &iid, void **ppv);
    virtual STDMETHODIMP_(ULONG) AddRef();
    virtual STDMETHODIMP_(ULONG) Release();

    // IDirectMusicSegmentState
    STDMETHODIMP GetRepeats(DWORD *pdwRepeats);
	STDMETHODIMP GetSegment(IDirectMusicSegment **ppSegment);
    STDMETHODIMP GetStartTime(MUSIC_TIME __RPC_FAR *);
	STDMETHODIMP Play(MUSIC_TIME mtAmount,MUSIC_TIME *pmtPlayed); // No longer supported.
    STDMETHODIMP GetSeek(MUSIC_TIME *pmtSeek);
	STDMETHODIMP GetStartPoint(MUSIC_TIME *pmtStart);
	STDMETHODIMP Flush(MUSIC_TIME mtTime);
    // IDirectMusicSegmentState8 
    STDMETHODIMP SetTrackConfig( REFGUID rguidTrackClassID,DWORD dwGroup, DWORD dwIndex, DWORD dwFlagsOn, DWORD dwFlagsOff) ;
    STDMETHODIMP GetObjectInPath( DWORD dwPChannel,DWORD dwStage,DWORD dwBuffer, REFGUID guidObject,
                    DWORD dwIndex,REFGUID iidInterface, void ** ppObject);

    // IDirectMusicGraph
	STDMETHODIMP Shutdown();
    STDMETHODIMP InsertTool(IDirectMusicTool *pTool,DWORD *pdwPChannels,DWORD cPChannels,LONG lIndex);
    STDMETHODIMP GetTool(DWORD,IDirectMusicTool**);
    STDMETHODIMP RemoveTool(IDirectMusicTool*);
    STDMETHODIMP StampPMsg(DMUS_PMSG* pEvent);

    // Methods used by performance to access SegmentState.
	HRESULT PrivateInit(CSegment *pParentSegment,CPerformance *pPerformance);
    HRESULT InitRoute(IDirectMusicAudioPath *pAudioPath);
    HRESULT ShutDown(void); // called from ~SEGSTNODE in dmperf.h
	HRESULT GetTrackList(void** ppTrackList);
    HRESULT SetSeek(MUSIC_TIME mtSeek,DWORD dwPlayFlags);
    HRESULT SetInvalidate(MUSIC_TIME mtTime);
	MUSIC_TIME GetEndTime(MUSIC_TIME mtStartTime);
	HRESULT ConvertToSegTime(MUSIC_TIME* pmtTime, MUSIC_TIME* pmtOffset, DWORD* pdwRepeat);
	HRESULT AbortPlay( MUSIC_TIME mtTime, BOOL fLeaveNotesOn ); // called when the segstate is stopped prematurely
	HRESULT CheckPlay( MUSIC_TIME mtAmount, MUSIC_TIME* pmtResult );
    HRESULT Play(MUSIC_TIME mtAmount);  
    HRESULT PlayClockTime( REFERENCE_TIME rtAmount );
    HRESULT GetParam( CPerformance *pPerf,REFGUID rguidType,DWORD dwGroupBits,
        DWORD dwIndex,MUSIC_TIME mtTime,MUSIC_TIME* pmtNext,void* pParam);	

    CSegState* GetNext() { return (CSegState*)AListItem::GetNext();}
private:
    CTrack *GetTrackByParam(CTrack * pCTrack,REFGUID rguidType,DWORD dwGroupBits,DWORD dwIndex);
    CTrack *GetTrack(REFCLSID rType,DWORD dwGroupBits,DWORD dwIndex);
	void GenerateNotification( DWORD dwNotification, MUSIC_TIME mtTime );
	void SendDirtyPMsg( MUSIC_TIME mtTime );
public:
// Attributes
    CRITICAL_SECTION            m_CriticalSection;
	IUnknown*					m_pUnkDispatch; // holds the controlling unknown of the scripting object that implements IDispatch
	CPerformance*	            m_pPerformance;
	CSegment*		            m_pSegment;     // Holds the parent segment pointer, weak reference, for convenience
    CAudioPath*                 m_pAudioPath;   // Maps vchannels to pchannels, if requested.
    CGraph*                     m_pGraph;       // Temp graph is a copy of the segment's graph.
    CTrackList	                m_TrackList;	// list of Tracks held in this SegmentState
    MUSIC_TIME					m_mtLoopStart;  // Loop start point.
	MUSIC_TIME					m_mtLoopEnd;    // Loop end point.
	DWORD						m_dwRepeats;    // The original repeat setting (before countdown)
	MUSIC_TIME					m_mtLength;     // Length of segment.
	DWORD						m_dwPlayTrackFlags;// Track playback controlflags.
    DWORD						m_dwPlaySegFlags;// Segment playback control flags.
    DWORD                       m_dwSegFlags;   // New Segment Flags from file.
    MUSIC_TIME					m_mtResolvedStart;// Start time resolved to desired resolution
	MUSIC_TIME					m_mtEndTime;    // End time that the segment should play to if not stopped. 
	MUSIC_TIME					m_mtOffset;     // Start time of the segment in absolute time, as if it were started from the beginning. 
    MUSIC_TIME					m_mtLastPlayed; // the last played absolute time
	MUSIC_TIME					m_mtStopTime;     // Used to stop play at a specific time. Ignored when 0.
	MUSIC_TIME					m_mtSeek;       // How far into the segment we are.
	MUSIC_TIME					m_mtStartPoint; // Point in the segment where playback started
    MUSIC_TIME                  m_mtAbortTime;  // Time a sudden stop occured.
    MUSIC_TIME                  m_mtFirstLoopStart; // The music time for the loop start when it starts looping the VERY FIRST time 
    MUSIC_TIME                  m_mtCurLoopStart; // The music time for the loop start when clock time looping is enforced.
    MUSIC_TIME                  m_mtCurLoopEnd; // The music time for the loop end when clock time looping is enforced.
    REFERENCE_TIME              m_rtLoopStart;  // Clock time loop start.
    REFERENCE_TIME              m_rtLoopEnd;    // Clock time loop end. 
    REFERENCE_TIME				m_rtGivenStart; // Start time given in PlaySegment, unquantized
    REFERENCE_TIME              m_rtLastPlayed; // Clock time version of the last played absolute time
	REFERENCE_TIME				m_rtStartPoint; // Clock time version of point in the segment where playback started
	REFERENCE_TIME				m_rtOffset;     // Clock time version of start time of the segment in absolute time, as if it were started from the beginning. 
    REFERENCE_TIME              m_rtEndTime;    // Clock time version of full length.
    REFERENCE_TIME				m_rtSeek;       // Clock time version of how far into the segment we are.
    REFERENCE_TIME              m_rtLength;     // Clock time length, read from file. If 0, ignore.
    REFERENCE_TIME              m_rtFirstLoopStart; // The clock time for the loop start when it starts looping the VERY FIRST time 
    REFERENCE_TIME              m_rtCurLoopStart;// The clock time for the loop start for the current loop repetition
    REFERENCE_TIME              m_rtCurLoopEnd; // The clock time for the loop end in the current loop repetition
    DWORD						m_dwRepeatsLeft;// Current repeats left.
	BOOL						m_fStartedPlay; // indicates if the segstate has started to play yet
    DWORD                       m_dwVersion;    // Which release does the app think it is using - 6, 7, or 8..
    DWORD                       m_dwFirstTrackID;// Virtual ID of first track in segstate.
    DWORD                       m_dwLastTrackID;// Last track's virtual id.
    BOOL                        m_fPrepped;     // Used to track whether PrepSegToPlay has been called.
    BOOL                        m_fSongMode;    // True if part of a playing song. If so, this should queue the next segment when done.
	BOOL						m_fCanStop;		// If false, Stop() should ignore this segment (it was just queued to play by PlaySegmentEx().)
    BOOL                        m_fInPlay;      // Segmentstate is currently playing.   
    BOOL                        m_fDelayShutDown;
    CSegState *                 m_pSongSegState;// Used to track the starting segstate in a song.
    long						m_cRef;         // COM reference counter.
};

class CSegStateList : public AList
{
public:
    void AddHead(CSegState* pSegState) { AList::AddHead((AListItem*)pSegState);}
    void Insert(CSegState* pSegState);
    CSegState* GetHead(){return (CSegState*)AList::GetHead();}
    CSegState* GetItem(LONG lIndex){return (CSegState*)AList::GetItem(lIndex);}
    CSegState* RemoveHead() {return (CSegState *) AList::RemoveHead();}
    void Remove(CSegState* pSegState){AList::Remove((AListItem*)pSegState);}
    void AddTail(CSegState* pSegState){AList::AddTail((AListItem*)pSegState);}
    CSegState* GetTail(){ return (CSegState*)AList::GetTail();}
    void SetID(DWORD dwID) { m_dwID = dwID; }
    DWORD GetID() { return m_dwID; }
private:
    DWORD       m_dwID;         // Identifies which segstate list this is.
};

#endif //__DIRECTMUSICSEGMENTSTATEOBJECT_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\XDmime\dmstrm.h ===
//
// dmstrm.h
// 
// Copyright (c) 1995-1998 Microsoft Corporation. All rights reserved.
//


#ifndef DMSTRM_H
#define DMSTRM_H

#include <unknwn.h>

DEFINE_GUID(IID_IDMStream, 0x1894c260, 0xaa21, 0x11d1, 0x86, 0xbc, 0x0, 0xc0, 0x4f, 0xbf, 0x8f, 0xef);

DECLARE_INTERFACE_(IDMStream, IUnknown)
{
    // IUnknown
    STDMETHOD(QueryInterface)       (THIS_ REFIID, LPVOID FAR *) PURE;
    STDMETHOD_(ULONG,AddRef)        (THIS) PURE;
    STDMETHOD_(ULONG,Release)       (THIS) PURE;

    // IDMStream
	STDMETHOD(Init)					(THIS_ IStream* pStream) PURE;
    STDMETHOD(Descend)		(THIS_ LPMMCKINFO lpck, LPMMCKINFO lpckParent, UINT wFlags) PURE;
    STDMETHOD(Ascend)		(THIS_ LPMMCKINFO lpck, UINT wFlags) PURE;
    STDMETHOD(CreateChunk)	(THIS_ LPMMCKINFO lpck, UINT wFlags) PURE;
   	STDMETHOD(SetStream)			(THIS_ IStream* pIStream) PURE;
    STDMETHOD_(IStream*, GetStream)	(THIS) PURE;
};

STDAPI AllocDirectMusicStream(IStream* pIStream, IDMStream** ppIDMStream);

class CDirectMusicStream : public IDMStream
{
public:

    CDirectMusicStream();
    ~CDirectMusicStream();
 
	STDMETHODIMP Init(IStream* pStream);
	
	// IUnknown
    STDMETHODIMP QueryInterface(REFIID riid, LPVOID *ppvObj);
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();

    // IDMStream
    STDMETHODIMP Descend(LPMMCKINFO lpck, LPMMCKINFO lpckParent, UINT wFlags);
    STDMETHODIMP Ascend(LPMMCKINFO lpck, UINT wFlags);
    STDMETHODIMP CreateChunk(LPMMCKINFO lpck, UINT wFlags);

	STDMETHODIMP SetStream(IStream* pStream);
    STDMETHODIMP_(IStream*) GetStream();

private:
	long		m_cRef;         // object reference count
    IStream*    m_pStream;      // stream to operate on
};

// Macro to round up an odd size to RIFF 16 bit boundary.
#define RIFF_ALIGN(dwSize) (dwSize + (dwSize & 1))

typedef struct _RIFFIO
{
    FOURCC          ckid;           /* chunk ID */
    long            cksize;         /* chunk size */
    FOURCC          fccType;        /* form type or list type */
    long            lRead;          /* How much of this chunk has been read so far. */
    _RIFFIO *       pParent;        /* pointer to parent chunk */
    LARGE_INTEGER   liPosition;     /* Filled in by MarkPosition() when handing stream to another component. */
} RIFFIO;


class CRiffParser
{
public:
    CRiffParser(IStream *pStream);
    void        DebugOn() { m_fDebugOn = TRUE; } // Turns on tracing of parsing. Only available in debug builds.
    BOOL        NextChunk(HRESULT * pHr); // Does the work of LeaveChunk, MoreChunks, and EnterChunk in one call. 
    void        EnterList(RIFFIO *pChunk); // Descend into a new list.
    void        LeaveList();    // Pop out of the current list. 
    BOOL        MoreChunks();   // Returns true if there are more chunks to process in this LIST or RIFF.
    HRESULT     EnterChunk();   // Reads header of next chunk in this LIST or RIFF container.
    HRESULT     LeaveChunk();   // Move to the end of the current chunk in the LIST or RIFF.
    void        MarkPosition(); // Stores the absolute position of the start of the current chunk.
    HRESULT     SeekBack();     // Scan back to the beginning of the current chunk.
    HRESULT     SeekForward();  // Scan forward to the end of the current chunk.
    HRESULT     Read(void *pv,ULONG cb); // Reads data from stream. 
    HRESULT     Skip(ULONG ulBytes); // Seeks forward ulBytes.
    void        EnteringComponent() { m_fInComponent = true; } 
    BOOL        ComponentFailed() { return m_fComponentFailed; }
    IStream *   GetStream() { return m_pStream; }
private:
    BOOL        m_fDebugOn;     // Set true to turn tracing of parsing on. 
    BOOL        m_fFirstPass;   // Used by NextChunk to understand whether this is the first time in the list.
    IStream *   m_pStream;      // Stream to operate on. 
    RIFFIO *    m_pChunk;       // Current chunk that we are in. 
    RIFFIO *    m_pParent;      // Parent chunk of current chunk.
    long        m_lRead;        // How far we've read in the current chunk.
    BOOL        m_fComponentFailed; // Set true if a component failed to load, yet the file is okay.
    BOOL        m_fInComponent; // Set to true when inside a component's chunk.
};

#endif // #ifndef DMSTRM_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\XDmime\dmstyle.h ===
// DMStyle.h : Declaration of the CDMStyle
//
// Copyright (c) 1997-1999 Microsoft Corporation
//
// @doc EXTERNAL
//
// 

#ifndef __DMSTYLE_H_
#define __DMSTYLE_H_


#include "dmusici.h"

#include "sjdefs.h"
#include "iostru.h"
#include "AARiff.h"
#include "str.h"
#include "tlist.h"
#include "alist.h"
#include "dmstylep.h"
#include "filter.h"
#include "dmusicp.h"

#include "timesig.h"

#include "debug.h"

// default scale is C Major
const DWORD DEFAULT_SCALE_PATTERN = 0xab5ab5;
// default chord is major 7
const DWORD DEFAULT_CHORD_PATTERN = 0x891;
const int MAX_VARIATION_LOCKS = 255;  // max number of variation lock ids

extern DirectMusicTimeSig DefaultTimeSig;

struct CompositionFragment;
struct StyleTrackState;

#define EMB_NORMAL	0
#define EMB_FILL	1
#define EMB_BREAK	2
#define EMB_INTRO	4
#define EMB_END		8
#define EMB_MOTIF	16
// User-defined embellishments live in the high byte of the embellishment word
#define EMB_USER_DEFINED	0xff00

// #defines to replace need for dynamic casts
#define DMUS_EVENT_NOTE				1
#define DMUS_EVENT_CURVE			2
#define DMUS_EVENT_MARKER			3
#define DMUS_EVENT_ANTICIPATION		4

// Curve flip flags
#define CURVE_FLIPTIME	1
#define CURVE_FLIPVALUE	2

#define STYLEF_USING_DX8 1

struct DirectMusicPart;
struct DirectMusicPartRef;
class CDMStyle;
struct DMStyleStruct;
struct CDirectMusicPattern;

struct CDirectMusicEventItem : public AListItem
{
//friend class CDirectMusicPattern;
//public:
	CDirectMusicEventItem* MergeSort(DirectMusicTimeSig& TimeSig); 
//protected:
	void Divide(CDirectMusicEventItem* &pHalf1, CDirectMusicEventItem* &pHalf2);
	CDirectMusicEventItem* Merge(CDirectMusicEventItem* pOtherList, DirectMusicTimeSig& TimeSig);
	CDirectMusicEventItem* GetNext() { return (CDirectMusicEventItem*) AListItem::GetNext(); }
	CDirectMusicEventItem* ReviseEvent(short nGrid, 
										short nOffset, 
										DWORD* pdwVariation = NULL, 
										DWORD* pdwID = NULL, 
										WORD* pwMusic = NULL, 
										BYTE* pbPlaymode = NULL,
                                        BYTE* pbFlags = NULL);

//protected:
	short		m_nGridStart;		// Grid position in track that this event belogs to.
	short		m_nTimeOffset;		// Offset, in music time, of event from designated grid position.
	DWORD		m_dwVariation;		// variation bits
	DWORD		m_dwEventTag;		// what type of event this is (note, curve, ...)
};

struct CDirectMusicEventList : public AList
{
//public:
	~CDirectMusicEventList();
    CDirectMusicEventItem *GetHead() { return (CDirectMusicEventItem *)AList::GetHead();};
    CDirectMusicEventItem *RemoveHead() { return (CDirectMusicEventItem *)AList::RemoveHead();};
	void MergeSort(DirectMusicTimeSig& TimeSig); // Destructively mergeSorts the list
};

struct CDMStyleNote : public CDirectMusicEventItem
{
//friend class CDirectMusicPattern;
//public:
	CDMStyleNote() : m_bPlayModeFlags(0), m_bFlags(0), m_dwFragmentID(0)
	{
		m_dwEventTag = DMUS_EVENT_NOTE;
	}
	CDirectMusicEventItem* ReviseEvent(short nGrid, 
										short nOffset, 
									    DWORD* pdwVariation, 
										DWORD* pdwID, 
										WORD* pwMusic, 
										BYTE* pbPlaymode,
                                        BYTE* pbFlags);
//protected:
	MUSIC_TIME	m_mtDuration;		// how long this note lasts
    WORD		m_wMusicValue;		// Position in scale.
    BYTE		m_bVelocity;		// Note velocity.
    BYTE		m_bTimeRange;		// Range to randomize start time.
    BYTE		m_bDurRange;		// Range to randomize duration.
    BYTE		m_bVelRange;		// Range to randomize velocity.
	BYTE		m_bInversionId;		// Identifies inversion group to which this note belongs
	BYTE		m_bPlayModeFlags;	// can override part ref
	DWORD		m_dwFragmentID;		// for melody formulation, the fragment this note came from
	BYTE		m_bFlags;			// values from DMUS_NOTEF_FLAGS
};

struct CDMStyleCurve : public CDirectMusicEventItem
{
	CDMStyleCurve()
	{
		m_dwEventTag = DMUS_EVENT_CURVE;
	}
	CDirectMusicEventItem* ReviseEvent(short nGrid, short nOffset);
	MUSIC_TIME	m_mtDuration;	// how long this curve lasts
	MUSIC_TIME	m_mtResetDuration;	// how long after the end of the curve to reset it
	short		m_StartValue;	// curve's start value
	short		m_EndValue;		// curve's end value
	short		m_nResetValue;	// curve's reset value
    BYTE		m_bEventType;	// type of curve
	BYTE		m_bCurveShape;	// shape of curve
	BYTE		m_bCCData;		// CC#
	BYTE		m_bFlags;		// flags. Bit 1=TRUE means to send the reset value. Other bits reserved.
	WORD		m_wParamType;		// RPN or NRPN parameter number.
	WORD		m_wMergeIndex;		// Allows multiple parameters to be merged (pitchbend, volume, and expression.)
};

struct CDMStyleMarker : public CDirectMusicEventItem
{
	CDMStyleMarker()
	{
		m_dwEventTag = DMUS_EVENT_MARKER;
	}
	CDirectMusicEventItem* ReviseEvent(short nGrid);
	WORD	m_wFlags;		// flags for how to interpret this marker.
};

struct CDMStyleAnticipation : public CDirectMusicEventItem
{
	CDMStyleAnticipation()
	{
		m_dwEventTag = DMUS_EVENT_ANTICIPATION;
	}
	CDirectMusicEventItem* ReviseEvent(short nGrid);
    BYTE		m_bTimeRange;		// Range to randomize start time.
};

struct Marker
{
	MUSIC_TIME	mtTime;
	WORD		wFlags;
};

struct DirectMusicPart
{
	DirectMusicPart(DirectMusicTimeSig *pTimeSig = NULL);
	~DirectMusicPart() { }
	STDMETHODIMP_(ULONG) AddRef();
	STDMETHODIMP_(ULONG) Release();
	HRESULT DM_LoadPart(  
		IAARIFFStream* pIRiffStream, MMCKINFO* pckMain, DMStyleStruct* pStyle );
	HRESULT DM_SavePart( IAARIFFStream* pIRiffStream );
	HRESULT DM_SaveNoteList( IAARIFFStream* pIRiffStream );
	HRESULT DM_SaveCurveList( IAARIFFStream* pIRiffStream );
	HRESULT DM_SaveMarkerList( IAARIFFStream* pIRiffStream );
	HRESULT DM_SaveAnticipationList( IAARIFFStream* pIRiffStream );
	HRESULT DM_SaveResolutionList( IAARIFFStream* pIRiffStream );
	HRESULT MergeMarkerEvents( DMStyleStruct* pStyle, CDirectMusicPattern* pPattern );
	HRESULT GetClosestTime(int nVariation, MUSIC_TIME mtTime, DWORD dwFlags, bool fChord, MUSIC_TIME& rmtResult);
	bool IsMarkerAtTime(int nVariation, MUSIC_TIME mtTime, DWORD dwFlags, bool fChord);
	DirectMusicTimeSig& TimeSignature( DMStyleStruct* pStyle, CDirectMusicPattern* pPattern ); 

	long m_cRef;
	GUID							m_guidPartID;
	DirectMusicTimeSig				m_timeSig;			// can override pattern's
	WORD							m_wNumMeasures;		// length of the Part
	DWORD							m_dwVariationChoices[32];	// MOAW choices bitfield
	BYTE							m_bPlayModeFlags;	// see PLAYMODE flags (in ioDMStyle.h)
	BYTE							m_bInvertUpper;		// inversion upper limit
	BYTE							m_bInvertLower;		// inversion lower limit
	DWORD							m_dwFlags;   		// various flags
	CDirectMusicEventList			EventList;			// list of events (notes, curves, etc.)
	TList<Marker>					m_StartTimes[32];	// Array of start time lists (1 per variation)
	TList<DMUS_IO_STYLERESOLUTION>	m_ResolutionList;	// list of variation resolutions
};

struct InversionGroup 
{
	// Inversion groups are used for keeping track of groups of notes to be played
	// without inversion
	WORD		m_wGroupID;	// Group this represents.
	WORD		m_wCount;	// How many are in the group, still waiting to be played.
	short		m_nOffset;	// Number to add to all notes for offsetting.
};

const short INVERSIONGROUPLIMIT = 16;

short FindGroup(InversionGroup aGroup[], WORD wID);
short AddGroup(InversionGroup aGroup[], WORD wID, WORD wCount, short m_nOffset);

struct PatternTrackState;

struct DirectMusicPartRef
{
	DirectMusicPartRef() : 
		m_bPriority(100), 
		m_pDMPart(NULL), 
		m_bVariationLockID(0), 
		//m_wLogicalPartID(LOGICAL_PART_PIANO),
		m_bSubChordLevel(SUBCHORD_STANDARD_CHORD)
	{  }
	~DirectMusicPartRef() { if (m_pDMPart) m_pDMPart->Release(); }
	HRESULT DM_LoadPartRef( IAARIFFStream* pIRiffStream, MMCKINFO* pckMain, DMStyleStruct* pStyle);
	HRESULT DM_SavePartRef( IAARIFFStream* pIRiffStream );
	void SetPart( DirectMusicPart* pPart );

	HRESULT ConvertMusicValue(CDMStyleNote* pNoteEvent, 
							  DMUS_CHORD_PARAM& rCurrentChord,
							  BYTE bPlaymode,
							  BOOL fPlayAsIs,
							  InversionGroup aInversionGroups[],
							  IDirectMusicPerformance* pPerformance,
							  BYTE& rbMidiValue,
							  short& rnMidiOffset);
	HRESULT ConvertMIDIValue(BYTE bMIDI, 
							  DMUS_CHORD_PARAM& rCurrentChord,
							  BYTE bPlayModeFlags,
							  IDirectMusicPerformance* pPerformance,
							  WORD& rwMusicValue);

	DirectMusicPart* m_pDMPart; // the Part to which this refers
	DWORD	m_dwLogicalPartID;	// corresponds to port/device/midi channel
	BYTE	m_bVariationLockID; // parts with the same ID lock variations.
								// high bit is used to identify master Part
	BYTE	m_bSubChordLevel;	// tells which sub chord level this part wants
	BYTE	m_bPriority;		// Priority levels. Parts with lower priority
								// aren't played first when a device runs out of
								// notes
	BYTE	m_bRandomVariation;		// Determines order in which variations are played.
};

#define COMPUTE_VARIATIONSF_USE_MASK	0x1
#define COMPUTE_VARIATIONSF_NEW_PATTERN	0x2
#define COMPUTE_VARIATIONSF_CHORD_ALIGN	0x4
#define COMPUTE_VARIATIONSF_MARKER		0x8
#define COMPUTE_VARIATIONSF_START		0x10
#define COMPUTE_VARIATIONSF_DX8			0x20
#define COMPUTE_VARIATIONSF_CHANGED		0x40

struct CDirectMusicPattern
{
friend class CDMStyle;
//public:
	CDirectMusicPattern( DirectMusicTimeSig* pTimeSig = NULL, BOOL fMotif = FALSE );
	~CDirectMusicPattern() { CleanUp(); }
	STDMETHODIMP_(ULONG) AddRef();
	STDMETHODIMP_(ULONG) Release();
	CDirectMusicPattern* Clone(MUSIC_TIME mtStart, MUSIC_TIME mtEnd, BOOL fMotif);
	void CleanUp();
	HRESULT DM_LoadPattern(
		IAARIFFStream* pIRiffStream, MMCKINFO* pckMain, DMStyleStruct* pStyle );

	HRESULT LoadPattern(
		IAARIFFStream* pRIFF, 
		MMCKINFO* pckMain,
		TList<DirectMusicPart*> &partList,
		DMStyleStruct& rStyleStruct
	);
	HRESULT AllocPartRef(TListItem<DirectMusicPartRef>*& rpPartRefItem);
	void DeletePartRef(TListItem<DirectMusicPartRef>* pPartRefItem);
	void DMusMoawFlags(MUSIC_TIME mtTime, 
					   MUSIC_TIME mtNextChord,
					   DMUS_CHORD_PARAM& rCurrentChord, 
					   DMUS_CHORD_PARAM& rNextChord,
					   bool fIsDX8,
					   DWORD& dwNaturals,
					   DWORD& dwSharps,
					   DWORD& dwFlats);
	DWORD IMA25MoawFlags(MUSIC_TIME mtTime, 
						 MUSIC_TIME mtNextChord,
						 DMUS_CHORD_PARAM& rCurrentChord,
						 DMUS_CHORD_PARAM& rNextChord);
	HRESULT ComputeVariations(DWORD dwFlags,
							  DMUS_CHORD_PARAM& rCurrentChord, 
							  DMUS_CHORD_PARAM& rNextChord,
							  BYTE abVariationGroups[],
							  DWORD adwVariationMask[],
							  DWORD adwRemoveVariations[],
							  BYTE abVariation[],
							  MUSIC_TIME mtTime,
							  MUSIC_TIME mtNextChord,
							  PatternTrackState* pState = NULL);
	HRESULT ComputeVariationGroup(DirectMusicPartRef& rPartRef,
							 int nPartIndex,
							 DWORD dwFlags,
							 DMUS_CHORD_PARAM& rCurrentChord,
							 DMUS_CHORD_PARAM& rNextChord,
							 BYTE abVariationGroups[],
							 DWORD adwVariationMask[],
							 DWORD adwRemoveVariations[],
							 BYTE abVariation[],
							 MUSIC_TIME mtTime,
							 MUSIC_TIME mtNextChord,
							 PatternTrackState* pState);
	HRESULT ComputeVariation(DirectMusicPartRef& rPartRef,
							 int nPartIndex,
							 DWORD dwFlags,
							 DMUS_CHORD_PARAM& rCurrentChord,
							 DMUS_CHORD_PARAM& rNextChord,
							 BYTE abVariationGroups[],
							 DWORD adwVariationMask[],
							 DWORD adwRemoveVariations[],
							 BYTE abVariation[],
							 MUSIC_TIME mtTime,
							 MUSIC_TIME mtNextChord,
							 PatternTrackState* pState);
	BOOL MatchCommand(DMUS_COMMAND_PARAM_2 pCommands[], short nLength);
	void MatchRhythm(DWORD pRhythms[], short nPatternLength, short& nBits);
	BOOL MatchGrooveLevel(DMUS_COMMAND_PARAM_2& rCommand);
	BOOL MatchEmbellishment(DMUS_COMMAND_PARAM_2& rCommand);
	BOOL MatchNextCommand(DMUS_COMMAND_PARAM_2& rNextCommand);

	HRESULT LoadEvents(IAARIFFStream* pRIFF, MMCKINFO* pckMain);
	HRESULT LoadNoteList(LPSTREAM pStream, MMCKINFO* pckMain, short nClickTime);
	HRESULT LoadCurveList(LPSTREAM pStream, MMCKINFO* pckMain, short nClickTime);
	DirectMusicPart* FindPart(BYTE bChannelID);
	TListItem<DirectMusicPartRef>* FindPartRefByPChannel(DWORD dwPChannel);
	TListItem<DirectMusicPartRef>* CreatePart( DirectMusicPartRef& rPartRef, BYTE bPlaymode, WORD wMeasures = 1 );
	HRESULT Save( IStream* pIStream );
	HRESULT DM_SaveSinglePattern( IAARIFFStream* pIRiffStream );
	HRESULT DM_SavePatternChunk( IAARIFFStream* pIRiffStream );
	HRESULT DM_SavePatternRhythm( IAARIFFStream* pIRiffStream );
	HRESULT DM_SavePatternInfoList( IAARIFFStream* pIRiffStream );
	HRESULT MergeMarkerEvents( DMStyleStruct* pStyle );
	DirectMusicTimeSig& TimeSignature( DMStyleStruct* pStyle ); 

    long				m_cRef;
	String				m_strName;			// pattern name
	DirectMusicTimeSig	m_timeSig;			// Patterns can override the Style's Time sig.
	WORD				m_wID;				// ID to identify for pattern playback (instead of name)
	BYTE				m_bGrooveBottom;	// bottom of groove range
	BYTE				m_bGrooveTop;		// top of groove range
	BYTE				m_bDestGrooveBottom;	// bottom of groove range for next pattern
	BYTE				m_bDestGrooveTop;		// top of groove range for next pattern
	WORD				m_wEmbellishment;	// Fill, Break, Intro, End, Normal, Motif
	WORD				m_wNumMeasures;		// length in measures
	DWORD*				m_pRhythmMap;		// variable array of rhythms for chord matching
	TList<DirectMusicPartRef> m_PartRefList;	// list of part references
	//////// motif settings:
	BOOL		m_fSettings;	  // Have these been set?
	DWORD       m_dwRepeats;      // Number of repeats. By default, 0.
    MUSIC_TIME  m_mtPlayStart;    // Start of playback. By default, 0.
    MUSIC_TIME  m_mtLoopStart;    // Start of looping portion. By default, 0.
    MUSIC_TIME  m_mtLoopEnd;      // End of loop. Must be greater than dwPlayStart. By default equal to length of motif.
    DWORD       m_dwResolution;   // Default resolution.
	//////// motif band:
	IDirectMusicBand*	m_pMotifBand;
	TList<MUSIC_TIME>	m_StartTimeList;	// list of valid start times for this pattern
	DWORD		m_dwFlags;		// various flags 
};

HRESULT AdjoinPChannel(TList<DWORD>& rPChannelList, DWORD dwPChannel);

struct DMStyleStruct
{
	DirectMusicPart* AllocPart(  );
	void DeletePart( DirectMusicPart* pPart );

	HRESULT GetCommand(
		MUSIC_TIME mtTime, 
		MUSIC_TIME mtOffset, 
		IDirectMusicPerformance* pPerformance,
		IDirectMusicSegment* pSegment,
		DWORD dwGroupID,
		DMUS_COMMAND_PARAM_2* pCommand,
		BYTE& rbActualCommand);

	DirectMusicPart* FindPartByGUID( GUID guidPartID );
	DirectMusicTimeSig& TimeSignature() { return m_TimeSignature; }
	bool UsingDX8() { return (m_dwFlags & STYLEF_USING_DX8) ? true : false; }

	CDirectMusicPattern* SelectPattern(bool fNewMode, 
								   DMUS_COMMAND_PARAM_2* pCommands, 
								   StyleTrackState* StyleTrackState, 
								   PatternDispatcher& rDispatcher);

	HRESULT GetPattern(
		bool fNewMode,
		MUSIC_TIME mtNow, 
		MUSIC_TIME mtOffset, 
		StyleTrackState* pStyleTrackState,
		IDirectMusicPerformance* pPerformance,
		IDirectMusicSegment* pSegment,
		CDirectMusicPattern*& rpTargetPattern,
		MUSIC_TIME& rmtMeasureTime, 
		MUSIC_TIME& rmtNextCommand);


	bool				m_fLoaded;				// is the style loaded in memory?
    GUID				m_guid;					// the style's GUID
    String				m_strCategory;			// Describes musical category of style
	String				m_strName;				// style name
	DWORD				m_dwVersionMS;			// Version # high-order 32 bits
	DWORD				m_dwVersionLS;			// Version # low-order 32 bits
	DirectMusicTimeSig	m_TimeSignature;		// The style's time signature
	double				m_dblTempo;				// The style's tempo
	TList<DirectMusicPart*> m_PartList;			// Parts used by the style
	TList<CDirectMusicPattern*> m_PatternList;	// Patterns used by the style
	TList<CDirectMusicPattern*> m_MotifList;		// Motifs used by the style
	TList<IDirectMusicBand *>  m_BandList;		// Bands used by the style
	IDirectMusicBand*		   m_pDefaultBand;   // Default band for style
	TList<IDirectMusicChordMap *>  m_PersList;		// Personalities used by the style
	IDirectMusicChordMap*		  m_pDefaultPers;   // Default Personality for style
	TList<DWORD>  m_PChannelList;		// PChannels used by the style
	DWORD				m_dwFlags;			// various flags
	//TList<MUSIC_TIME>	m_StartTimeList;	// list of valid start times for this style
};

/*
@interface IDirectMusicStyle | 
The <i IDirectMusicStyle> interface provides access to a Style object. 
The Style provides the Interactive Music Engine with the information it needs to perform 
a style of music (hence the name.) 
The application can also access information about the style, including the name, 
time signature, and recommended tempo.
Since styles usually include sets of Personalities, Bands, and Motifs, the <i IDirectMusicStyle> interface 
also provides functions for accessing them.

It also supports the <i IPersistStream> and <i IDirectMusicObject> interfaces for loading 
its data.


@base public | IUnknown

@meth HRESULT | EnumMotif | Returns the name of a motif, by location, from a Style's list of motifs.
@meth HRESULT | GetMotif | Returns a motif, by name, from a Style's list of motifs.
@meth HRESULT | EnumBand |  Returns the name of a band, by location, from a Style's list of bands.
@meth HRESULT | GetBand | Returns a band, by name, from a Style's list of bands. 
@meth HRESULT | GetDefaultBand | Returns a Style's default band. 
@meth HRESULT | EnumChordMap | Returns the name of a ChordMap, by location, from a Style's list of personalities.
@meth HRESULT | GetChordMap | Returns a ChordMap, by name, from a Style's list of personalities. 
@meth HRESULT | GetDefaultChordMap | Returns a Style's default ChordMap.  
@meth HRESULT | GetTimeSignature | Returns the time signature of a Style.
@meth HRESULT | GetEmbellishmentLength | Determines the length of a particular embellishment
in a Style. 
@meth HRESULT | GetTempo | Returns the recommended tempo of a Style. 

*/

/////////////////////////////////////////////////////////////////////////////
// CDMStyle
class CDMStyle : 
	public IDMStyle,
	public IDirectMusicStyle8,
	public IDirectMusicStyle8P,
	public IDirectMusicObject,
	public IPersistStream
{
public:
    CDMStyle();
    ~CDMStyle();
	HRESULT CreateMotifSegment(CDirectMusicPattern* pPattern, IUnknown * * ppSegment,
		DWORD dwRepeats);

// IDMStyle
public:
    // IUnknown
    //
    virtual STDMETHODIMP QueryInterface(const IID &iid, void **ppv);
    virtual STDMETHODIMP_(ULONG) AddRef();
    virtual STDMETHODIMP_(ULONG) Release();

	// IDirectMusicStyle methods
	// Returns: S_OK if the index refers to a motif; S_FALSE if it doesn't
	HRESULT STDMETHODCALLTYPE EnumMotif(
		/*in*/	DWORD dwIndex,			// index into the motif list
		/*out*/	WCHAR *pwszName			// name of the indexed motif
	);
	HRESULT STDMETHODCALLTYPE GetMotif(
		/*in*/	WCHAR* pwszName,			// name of the motif for a secondary segment
		/*out*/	IDirectMusicSegment** ppSegment
	);
	HRESULT STDMETHODCALLTYPE GetBand(
		/*in*/	WCHAR* pwszName,
		/*out*/	IDirectMusicBand **ppBand
	);

	HRESULT STDMETHODCALLTYPE EnumBand(
		/*in*/	DWORD dwIndex,
		/*out*/	WCHAR *pwszName
	);

	HRESULT STDMETHODCALLTYPE GetDefaultBand(
		/*out*/	IDirectMusicBand **ppBand
	);

	HRESULT STDMETHODCALLTYPE GetChordMap(
		/*in*/	WCHAR* pwszName,
		/*out*/	IDirectMusicChordMap** ppChordMap	
	);

	HRESULT STDMETHODCALLTYPE EnumChordMap(
		/*in*/	DWORD dwIndex,
		/*out*/	WCHAR *pwszName
	);

	HRESULT STDMETHODCALLTYPE GetDefaultChordMap(
		/*out*/	IDirectMusicChordMap **ppChordMap
	);

	HRESULT STDMETHODCALLTYPE GetTimeSignature(
		/*out*/	DMUS_TIMESIGNATURE* pTimeSig			
	);

	HRESULT STDMETHODCALLTYPE GetEmbellishmentLength(
		/*in*/	DWORD dwType,			
		/*in*/	DWORD dwLevel,			
		/*out*/	DWORD* pdwMin,			
		/*out*/	DWORD* pdwMax
	);

	HRESULT STDMETHODCALLTYPE GetTempo(double* pTempo);

	// IDirectMusicStyle8 methods
	HRESULT STDMETHODCALLTYPE ComposeMelodyFromTemplate(
		IDirectMusicStyle*			pStyle,
		IDirectMusicSegment*		pTempSeg,
		IDirectMusicSegment**		ppSeqSeg
	);

	HRESULT STDMETHODCALLTYPE EnumPattern(
		/*in*/	DWORD dwIndex,			// index into the motif list
		/*in*/  DWORD dwPatternType,	// type of pattern
		/*out*/	WCHAR *wszName			// name of the indexed motif
	);

	// IDirectMusicObject methods
	HRESULT STDMETHODCALLTYPE GetDescriptor(LPDMUS_OBJECTDESC pDesc) ;
	HRESULT STDMETHODCALLTYPE SetDescriptor(LPDMUS_OBJECTDESC pDesc) ;
	HRESULT STDMETHODCALLTYPE ParseDescriptor(LPSTREAM pStream, LPDMUS_OBJECTDESC pDesc) ;

	/* IPersist methods */
    // Retrieves the Style's Class ID.
    STDMETHOD(GetClassID)(THIS_ LPCLSID pclsid);

    /* IPersistStream methods */
    // Determines if the Style has been modified by simply checking the Style's m_fDirty flag.  This flag is cleared
    // when a Style is saved or has just been created.
    STDMETHOD(IsDirty)(THIS);
    // Loads a Style from a stream.
    STDMETHOD(Load)(THIS_ LPSTREAM pStream);
    // Saves a Style to a stream in RIFF format.
    STDMETHOD(Save)(THIS_ LPSTREAM pStream, BOOL fClearDirty);
    STDMETHOD(GetSizeMax)(THIS_ ULARGE_INTEGER FAR* pcbSize);

	// IDMStyle
	HRESULT STDMETHODCALLTYPE GetPatternStream(WCHAR* wszName, DWORD dwPatternType, IStream** ppStream);
	HRESULT STDMETHODCALLTYPE GetStyleInfo(void **pData);
	HRESULT STDMETHODCALLTYPE IsDX8();
	HRESULT STDMETHODCALLTYPE CritSec(bool fEnter);
	HRESULT STDMETHODCALLTYPE EnumPartGuid(
		DWORD dwIndex, WCHAR* wszName, DWORD dwPatternType, GUID& rGuid);
	HRESULT STDMETHODCALLTYPE GenerateTrack(//IDirectMusicTrack* pChordTrack,
								IDirectMusicSegment* pTempSeg,
								IDirectMusicSong* pSong,
								DWORD dwTrackGroup,
								IDirectMusicStyle* pStyle,
								IDirectMusicTrack* pMelGenTrack,
								MUSIC_TIME mtLength,
								IDirectMusicTrack*& pNewTrack);


protected: /* methods */
    void CleanUp();
	HRESULT DM_ParseDescriptor( IAARIFFStream* pIRiffStream, MMCKINFO* pckMain, LPDMUS_OBJECTDESC pDesc  );
	HRESULT IMA25_LoadPersonalityReference( IStream* pStream, MMCKINFO* pck );
    HRESULT IMA25_LoadStyle( IAARIFFStream* pRIFF, MMCKINFO* pckMain );
	HRESULT DM_LoadPersonalityReference( IAARIFFStream* pIRiffStream, MMCKINFO* pckParent);
	HRESULT LoadReference(IStream *pStream,
						  IAARIFFStream *pIRiffStream,
						  MMCKINFO& ckParent,
						  BOOL fDefault);
	HRESULT IncorporatePersonality( IDirectMusicChordMap* pPers, String strName, BOOL fDefault );
    HRESULT DM_LoadStyle( IAARIFFStream* pRIFF, MMCKINFO* pckMain );
	HRESULT GetStyle(IDirectMusicSegment* pFromSeg, MUSIC_TIME mt, DWORD dwTrackGroup, IDirectMusicStyle*& rpStyle);
	HRESULT CopySegment(IDirectMusicSegment* pTempSeg,
						IDirectMusicStyle* pStyle,
						IDirectMusicTrack* pSequenceTrack,
						DWORD dwTrackGroup,
						IDirectMusicSegment** ppSectionSeg);

	HRESULT CreateSequenceTrack(TList<CompositionFragment>& rlistFragments,
								IDirectMusicTrack*& pSequenceTrack);

	HRESULT CreatePatternTrack(TList<CompositionFragment>& rlistFragments,
								DirectMusicTimeSig& rTimeSig,
								double dblTempo,
								MUSIC_TIME mtLength,
								BYTE bPlaymode,
								IDirectMusicTrack*& pPatternTrack);

	HRESULT STDMETHODCALLTYPE EnumRegularPattern(
		/*in*/	DWORD dwIndex,			// index into the motif list
		/*out*/	WCHAR *pwszName			// name of the indexed motif
	);

	HRESULT STDMETHODCALLTYPE EnumStartTime(DWORD dwIndex, DMUS_COMMAND_PARAM* pCommand, MUSIC_TIME* pmtStartTime);

protected: /* attributes */
    long m_cRef;
	BOOL				m_fDirty;				// has the style been modified?
    CRITICAL_SECTION	m_CriticalSection;		// for i/o
    BOOL                m_fCSInitialized;
	DMStyleStruct		m_StyleInfo;			// The details of the style
	InversionGroup		m_aInversionGroups[INVERSIONGROUPLIMIT]; // Inversion Groups for composing melodies
};

#endif //__DMSTYLE_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\XDmime\dmstylep.h ===
//
// DMStyleP.H
//
// Private include for DMStyle.DLL
//
// Copyright (c) 1997-1999 Microsoft Corporation
//
//

#ifndef _DMSTYLEP_
#define _DMSTYLEP_

#include "dmusicf.h"

#define SUBCHORD_BASS				0
#define SUBCHORD_STANDARD_CHORD		1

extern long g_cComponent;

// Class factory
//
class CDirectMusicStyleFactory : public IClassFactory
{
public:
    // IUnknown
    //
    virtual STDMETHODIMP QueryInterface(const IID &iid, void **ppv);
    virtual STDMETHODIMP_(ULONG) AddRef();
    virtual STDMETHODIMP_(ULONG) Release();

    // Interface IClassFactory
    //
    virtual STDMETHODIMP CreateInstance(IUnknown* pUnknownOuter, const IID& iid, void** ppv);
    virtual STDMETHODIMP LockServer(BOOL bLock); 

    // Constructor
    //
    CDirectMusicStyleFactory() : m_cRef(1) {}

    // Destructor
    // ~CDirectMusicStyleFactory() {} 

private:
    long m_cRef;
};

class CDirectMusicSectionFactory : public IClassFactory
{
public:
    // IUnknown
    //
    virtual STDMETHODIMP QueryInterface(const IID &iid, void **ppv);
    virtual STDMETHODIMP_(ULONG) AddRef();
    virtual STDMETHODIMP_(ULONG) Release();

    // Interface IClassFactory
    //
    virtual STDMETHODIMP CreateInstance(IUnknown* pUnknownOuter, const IID& iid, void** ppv);
    virtual STDMETHODIMP LockServer(BOOL bLock); 

    // Constructor
    //
    CDirectMusicSectionFactory() : m_cRef(1) {}

    // Destructor
    // ~CDirectMusicSectionFactory() {} 

private:
    long m_cRef;
};

class CDirectMusicStyleTrackFactory : public IClassFactory
{
public:
    // IUnknown
    //
    virtual STDMETHODIMP QueryInterface(const IID &iid, void **ppv);
    virtual STDMETHODIMP_(ULONG) AddRef();
    virtual STDMETHODIMP_(ULONG) Release();

    // Interface IClassFactory
    //
    virtual STDMETHODIMP CreateInstance(IUnknown* pUnknownOuter, const IID& iid, void** ppv);
    virtual STDMETHODIMP LockServer(BOOL bLock); 

    // Constructor
    //
    CDirectMusicStyleTrackFactory() : m_cRef(1) {}

    // Destructor
    // ~CDirectMusicStyleTrackFactory() {} 

private:
    long m_cRef;
};

class CDirectMusicCommandTrackFactory : public IClassFactory
{
public:
    // IUnknown
    //
    virtual STDMETHODIMP QueryInterface(const IID &iid, void **ppv);
    virtual STDMETHODIMP_(ULONG) AddRef();
    virtual STDMETHODIMP_(ULONG) Release();

    // Interface IClassFactory
    //
    virtual STDMETHODIMP CreateInstance(IUnknown* pUnknownOuter, const IID& iid, void** ppv);
    virtual STDMETHODIMP LockServer(BOOL bLock); 

    // Constructor
    //
    CDirectMusicCommandTrackFactory() : m_cRef(1) {}

    // Destructor
    // ~CDirectMusicCommandTrackFactory() {} 

private:
    long m_cRef;
};

class CDirectMusicChordTrackFactory : public IClassFactory
{
public:
    // IUnknown
    //
    virtual STDMETHODIMP QueryInterface(const IID &iid, void **ppv);
    virtual STDMETHODIMP_(ULONG) AddRef();
    virtual STDMETHODIMP_(ULONG) Release();

    // Interface IClassFactory
    //
    virtual STDMETHODIMP CreateInstance(IUnknown* pUnknownOuter, const IID& iid, void** ppv);
    virtual STDMETHODIMP LockServer(BOOL bLock); 

    // Constructor
    //
    CDirectMusicChordTrackFactory() : m_cRef(1) {}

    // Destructor
    // ~CDirectMusicChordTrackFactory() {} 

private:
    long m_cRef;
};

class CDirectMusicMotifTrackFactory : public IClassFactory
{
public:
    // IUnknown
    //
    virtual STDMETHODIMP QueryInterface(const IID &iid, void **ppv);
    virtual STDMETHODIMP_(ULONG) AddRef();
    virtual STDMETHODIMP_(ULONG) Release();

    // Interface IClassFactory
    //
    virtual STDMETHODIMP CreateInstance(IUnknown* pUnknownOuter, const IID& iid, void** ppv);
    virtual STDMETHODIMP LockServer(BOOL bLock); 

    // Constructor
    //
    CDirectMusicMotifTrackFactory() : m_cRef(1) {}

    // Destructor
    // ~CDirectMusicMotifTrackFactory() {} 

private:
    long m_cRef;
};

class CDirectMusicMuteTrackFactory : public IClassFactory
{
public:
    // IUnknown
    //
    virtual STDMETHODIMP QueryInterface(const IID &iid, void **ppv);
    virtual STDMETHODIMP_(ULONG) AddRef();
    virtual STDMETHODIMP_(ULONG) Release();

    // Interface IClassFactory
    //
    virtual STDMETHODIMP CreateInstance(IUnknown* pUnknownOuter, const IID& iid, void** ppv);
    virtual STDMETHODIMP LockServer(BOOL bLock); 

    // Constructor
    //
    CDirectMusicMuteTrackFactory() : m_cRef(1) {}

    // Destructor
    // ~CDirectMusicMuteTrackFactory() {} 

private:
    long m_cRef;
};

class CDirectMusicAuditionTrackFactory : public IClassFactory
{
public:
    // IUnknown
    //
    virtual STDMETHODIMP QueryInterface(const IID &iid, void **ppv);
    virtual STDMETHODIMP_(ULONG) AddRef();
    virtual STDMETHODIMP_(ULONG) Release();

    // Interface IClassFactory
    //
    virtual STDMETHODIMP CreateInstance(IUnknown* pUnknownOuter, const IID& iid, void** ppv);
    virtual STDMETHODIMP LockServer(BOOL bLock); 

    // Constructor
    //
    CDirectMusicAuditionTrackFactory() : m_cRef(1) {}

    // Destructor
    // ~CDirectMusicAuditionTrackFactory() {} 

private:
    long m_cRef;
};

class CDirectMusicMelodyFormulationTrackFactory : public IClassFactory
{
public:
    // IUnknown
    //
    virtual STDMETHODIMP QueryInterface(const IID &iid, void **ppv);
    virtual STDMETHODIMP_(ULONG) AddRef();
    virtual STDMETHODIMP_(ULONG) Release();

    // Interface IClassFactory
    //
    virtual STDMETHODIMP CreateInstance(IUnknown* pUnknownOuter, const IID& iid, void** ppv);
    virtual STDMETHODIMP LockServer(BOOL bLock); 

    // Constructor
    //
    CDirectMusicMelodyFormulationTrackFactory() : m_cRef(1) {}

private:
    long m_cRef;
};

// private interfaces
interface IDMSection : IUnknown
{
	virtual HRESULT STDMETHODCALLTYPE CreateSegment(IDirectMusicSegment* pSegment)=0;
	virtual HRESULT STDMETHODCALLTYPE GetStyle(IUnknown** ppStyle)=0;
};

interface IStyleTrack : IUnknown
{
	virtual HRESULT STDMETHODCALLTYPE SetTrack(IUnknown *pStyle)=0;

	virtual HRESULT STDMETHODCALLTYPE GetStyle(IUnknown **ppStyle)=0;
};

interface IDMStyle : IUnknown
{
//	virtual HRESULT STDMETHODCALLTYPE GetPatternName (DWORD dwIndex, WCHAR *wszName)=0;
	virtual HRESULT STDMETHODCALLTYPE EnumPartGuid(
		DWORD dwIndex, WCHAR* wszName, DWORD dwPatternType, GUID& rGuid)=0;
	virtual HRESULT STDMETHODCALLTYPE GetPatternStream(
		WCHAR* wszName, DWORD dwPatternType, IStream** ppStream)=0;
	virtual HRESULT STDMETHODCALLTYPE GetStyleInfo(void **pData)=0;
	virtual HRESULT STDMETHODCALLTYPE IsDX8()=0;
	virtual HRESULT STDMETHODCALLTYPE CritSec(bool fEnter)=0;
	virtual HRESULT STDMETHODCALLTYPE EnumStartTime(DWORD dwIndex, DMUS_COMMAND_PARAM* pCommand, MUSIC_TIME* pmtStartTime)=0;
	virtual HRESULT STDMETHODCALLTYPE GenerateTrack(
								IDirectMusicSegment* pTempSeg,
								IDirectMusicSong* pSong,
								DWORD dwTrackGroup,
								IDirectMusicStyle* pStyle,
								IDirectMusicTrack* pMelGenTrack,
								MUSIC_TIME mtLength,
								IDirectMusicTrack*& pNewTrack)=0;
	// this will go into dmusici.h when melody formulation is made public
/*	virtual HRESULT STDMETHODCALLTYPE ComposeMelodyFromTemplate(
		IDirectMusicStyle* pStyle,
		IDirectMusicSegment* pTemplate,
		IDirectMusicSegment** ppSegment) = 0;*/
    /* Interface needs to look like this in dmusici.h
	STDMETHOD(ComposeMelodyFromTemplate)   (THIS_ IDirectMusicStyle* pStyle, 
                                                   IDirectMusicSegment* pTemplate, 
                                                   IDirectMusicSegment** ppSegment) PURE;
	*/
};

interface IMotifTrack : IUnknown
{
	virtual HRESULT STDMETHODCALLTYPE SetTrack(IUnknown *pStyle, void* pPattern)=0;
};

interface IPrivatePatternTrack : IUnknown
{
    virtual HRESULT STDMETHODCALLTYPE SetPattern(
		IDirectMusicSegmentState* pSegState,
		IStream* pStream,
		DWORD* pdwLength)=0;
    virtual HRESULT STDMETHODCALLTYPE SetVariationByGUID(
		IDirectMusicSegmentState* pSegState,
		DWORD dwVariationFlags,
		REFGUID rguidPart,
		DWORD dwPChannel)=0;
};

///////////////////////////////////////////////////////////////////////////////////////

/*
#define IAuditionTrack IDirectMusicPatternTrack

#define IID_IAuditionTrack IID_IDirectMusicPatternTrack
*/

DEFINE_GUID( IID_IAuditionTrack, 
			 0x9dc278c0, 0x9cb0, 0x11d1, 0xa7, 0xce, 0x0, 0xa0, 0xc9, 0x13, 0xf7, 0x3c );

interface IAuditionTrack : IUnknown
{
	virtual HRESULT STDMETHODCALLTYPE CreateSegment(
		IDirectMusicStyle* pStyle, IDirectMusicSegment** ppSegment)=0;
	virtual HRESULT STDMETHODCALLTYPE SetPattern(
		IDirectMusicSegmentState* pSegState, IStream* pStream, DWORD* pdwLength)=0;
	virtual HRESULT STDMETHODCALLTYPE SetVariation(
		IDirectMusicSegmentState* pSegState, DWORD dwVariationFlags, WORD wPart)=0;
};

#define CLSID_DirectMusicAuditionTrack CLSID_DirectMusicPatternTrack

#define DMUS_PCHANNEL_MUTE 0xffffffff

// the following constants represent time in 100 nanosecond increments

#define REF_PER_MIL		10000		// For converting from reference time to mils 
#define MARGIN_MIN		(100 * REF_PER_MIL) // 
#define MARGIN_MAX		(400 * REF_PER_MIL) // 
#define PREPARE_TIME	(m_dwPrepareTime * REF_PER_MIL)	// Time
#define NEARTIME		(100 * REF_PER_MIL)
#define NEARMARGIN      (REALTIME_RES * REF_PER_MIL)


// private CLSIDs and IIDs

DEFINE_GUID(IID_IDMSection,
	0x3F037240,0x414E,0x11D1, 0xA7,0xCE,0x00,0xA0,0xC9,0x13,0xF7,0x3C);
DEFINE_GUID(IID_IStyleTrack,
	0x3F037246,0x414E,0x11D1, 0xA7,0xCE,0x00,0xA0,0xC9,0x13,0xF7,0x3C);
DEFINE_GUID(IID_IDMStyle,
	0x4D7F3661,0x43D6,0x11D1, 0xA7,0xCE,0x00,0xA0,0xC9,0x13,0xF7,0x3C);
DEFINE_GUID(IID_IMotifTrack,
	0x7AE499C1,0x51FE,0x11D1, 0xA7,0xCE,0x00,0xA0,0xC9,0x13,0xF7,0x3C);
DEFINE_GUID(IID_IMuteTrack, 
	0xbc242fc1, 0xad1d, 0x11d1, 0xa7, 0xce, 0x0, 0xa0, 0xc9, 0x13, 0xf7, 0x3c);
DEFINE_GUID(IID_IPrivatePatternTrack, 
	0x7a8e9c33, 0x5901, 0x4f20, 0x92, 0xde, 0x3a, 0x5b, 0x3e, 0x33, 0xe2, 0x14);

DEFINE_GUID(CLSID_DMSection,
	0x3F037241,0x414E,0x11D1, 0xA7,0xCE,0x00,0xA0,0xC9,0x13,0xF7,0x3C);

// GUID and param struct for private version of GetParam (get style Time Signature,
// getting commands and chords from current segment)

struct SegmentTimeSig
{
    IDirectMusicSegment* pSegment;  // Segment passed in
    DMUS_TIMESIGNATURE  TimeSig;    // Time sig returned
};

DEFINE_GUID(GUID_SegmentTimeSig, 0x76612507, 0x4f37, 0x4b35, 0x80, 0x92, 0x50, 0x48, 0x4e, 0xd4, 0xba, 0x92);

// Private melody fragment stuff

// Used to get a repeated melody fragment
DEFINE_GUID(GUID_MelodyFragmentRepeat, 0x8cc92764, 0xf81c, 0x11d2, 0x81, 0x45, 0x0, 0xc0, 0x4f, 0xa3, 0x6e, 0x58);

// This is obslolete and should not be public
#define DMUS_FOURCC_MELODYGEN_TRACK_CHUNK     mmioFOURCC( 'm', 'g', 'e', 'n' )

/*
// This is obslolete and should not be public
    // <mgen-ck>
    'mgen'
    (
        //sizeof DMUS_IO_MELODY_FRAGMENT: DWORD
        <DMUS_IO_MELODY_FRAGMENT>...
    )
*/

// GUID for private chord notifications
DEFINE_GUID(GUID_NOTIFICATION_PRIVATE_CHORD, 0xf5c19571, 0x7e1e, 0x4fff, 0xb9, 0x49, 0x7f, 0x74, 0xa6, 0x6f, 0xdf, 0xc0);

// (Private) Guid for getting a style from a pattern track
DEFINE_GUID(GUID_IDirectMusicPatternStyle, 0x689821f4, 0xb3bc, 0x44dd, 0x80, 0xd4, 0xc, 0xf3, 0x2f, 0xe4, 0xd2, 0x1b);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\XDmime\dmusicp.h ===
//
// dmusicp.h
//
// Copyright (c) 2000 Microsoft Corporation. All rights reserved.
//
// Private interfaces

#ifndef _DMUSICP_DOT_H_
#define _DMUSICP_DOT_H_

#include <dmusicf.h>

// private guid for script track events
DEFINE_GUID(IID_CScriptTrackEvent, 0x8f42c9da, 0xd37a, 0x499c, 0x85, 0x82, 0x1a, 0x80, 0xeb, 0xf9, 0xb2, 0x3c);

// Stuff used in melody formulation that's currently either not implemented or hidden by Producer.

/* Used to get a playmode to be used for a melody (pParam points to a single byte) */
DEFINE_GUID(GUID_MelodyPlaymode, 0x288ea6ca, 0xaecc, 0x4327, 0x9f, 0x79, 0xfb, 0x46, 0x44, 0x37, 0x4a, 0x65);

#define DMUS_FRAGMENTF_ANTICIPATE      (0x1 << 3) /* Anticipate next chord */
#define DMUS_FRAGMENTF_INVERT          (0x1 << 4) /* Invert the fragment */
#define DMUS_FRAGMENTF_REVERSE         (0x1 << 5) /* Reverse the fragment */
#define DMUS_FRAGMENTF_SCALE           (0x1 << 6) /* Align MIDI values with scale intervals */
#define DMUS_FRAGMENTF_CHORD           (0x1 << 7) /* Align MIDI values with chord intervals */
#define DMUS_FRAGMENTF_USE_PLAYMODE    (0x1 << 8) /* Use playmode to compute MIDI values */

#define DMUS_CONNECTIONF_GHOST         0x1        /* Use ghost notes for transitions */

// flags used in ComposeSegmentFromTemplateEx
typedef enum enumDMUS_COMPOSE_TEMPLATEF_FLAGS
{
    DMUS_COMPOSE_TEMPLATEF_ACTIVITY    = 0x1, // Use activity level (dx7 default)
    DMUS_COMPOSE_TEMPLATEF_CLONE       = 0x2  // Clone a segment from the template (dx7 default)
} DMUS_COMPOSE_TEMPLATEF_FLAGS;

// Interfaces/methods removed from Direct Music Performance layer:

// IDirectMusicSegment8P
interface IDirectMusicSegment8P : IUnknown
{
	// IUnknown
	virtual HRESULT STDMETHODCALLTYPE QueryInterface(REFIID, LPVOID FAR *)=0; 
	virtual ULONG STDMETHODCALLTYPE AddRef()=0; 
	virtual ULONG STDMETHODCALLTYPE Release()=0; 

	// IDirectMusicSegment8P
	virtual HRESULT STDMETHODCALLTYPE GetObjectInPath(
		DWORD dwPChannel,    /* PChannel to search. */
		DWORD dwStage,       /* Which stage in the path. */
		DWORD dwBuffer,      /* Which buffer to address, if more than one. */
		REFGUID guidObject,  /* ClassID of object. */
		DWORD dwIndex,       /* Which object of that class. */
		REFGUID iidInterface,/* Requested COM interface. */
		void ** ppObject)=0; /* Pointer to interface. */
    virtual HRESULT STDMETHODCALLTYPE GetHeaderChunk(
        DWORD *pdwSize,      /* Size of passed header chunk. Also, returns size written. */
        DMUS_IO_SEGMENT_HEADER *pHeader)=0; /* Header chunk to fill. */
    virtual HRESULT STDMETHODCALLTYPE SetHeaderChunk(
        DWORD dwSize,        /* Size of passed header chunk. */
        DMUS_IO_SEGMENT_HEADER *pHeader)=0; /* Header chunk to fill. */
    virtual HRESULT STDMETHODCALLTYPE SetTrackPriority(
        REFGUID rguidTrackClassID,  /* ClassID of Track. */
        DWORD dwGroupBits,          /* Group bits. */
        DWORD dwIndex,              /* Nth track. */
        DWORD dwPriority) = 0;      /* Priority to set. */
    virtual HRESULT STDMETHODCALLTYPE SetAudioPathConfig(
        IUnknown *pAudioPathConfig) = 0; /* Audio path config, from file. */
};


// IDirectMusicComposer8P
interface IDirectMusicComposer8P : IUnknown
{
	// IUnknown
	virtual HRESULT STDMETHODCALLTYPE QueryInterface(REFIID, LPVOID FAR *)=0; 
	virtual ULONG STDMETHODCALLTYPE AddRef()=0; 
	virtual ULONG STDMETHODCALLTYPE Release()=0; 

	// IDirectMusicComposer8P
    // Use style to get embellishment lengths
	virtual HRESULT STDMETHODCALLTYPE ComposeTemplateFromShapeEx(
		WORD wNumMeasures,
		WORD wShape, 
		BOOL fIntro,
		BOOL fEnd,
		IDirectMusicStyle* pStyle, 
		IDirectMusicSegment** ppTemplate)=0;
    // New flags DWORD (discard activity level; compose in place)
    virtual HRESULT STDMETHODCALLTYPE ComposeSegmentFromTemplateEx(
        IDirectMusicStyle* pStyle, 
        IDirectMusicSegment* pTemplate, 
        DWORD dwFlags,
        DWORD dwActivity,
        IDirectMusicChordMap* pChordMap, 
        IDirectMusicSegment** ppSegment)=0;
};

//  IDirectMusicStyle8P
interface IDirectMusicStyle8P : IUnknown
{
	// IUnknown
	virtual HRESULT STDMETHODCALLTYPE QueryInterface(REFIID, LPVOID FAR *)=0; 
	virtual ULONG STDMETHODCALLTYPE AddRef()=0; 
	virtual ULONG STDMETHODCALLTYPE Release()=0; 

	//  IDirectMusicStyle8P
	virtual HRESULT STDMETHODCALLTYPE ComposeMelodyFromTemplate(
		IDirectMusicStyle* pStyle, 
		IDirectMusicSegment* pTemplate, 
        IDirectMusicSegment** ppSegment)=0;
};

// IDirectMusicLoader8P
interface IDirectMusicLoader8P : IUnknown
{
	// IUnknown
	virtual HRESULT STDMETHODCALLTYPE QueryInterface(REFIID, LPVOID FAR *)=0; 
	virtual ULONG STDMETHODCALLTYPE AddRef()=0; 
	virtual ULONG STDMETHODCALLTYPE Release()=0; 

	// IDirectMusicLoader8P
	virtual HRESULT STDMETHODCALLTYPE GetDynamicallyReferencedObject(
		IDirectMusicObject *pSourceObject,
		LPDMUS_OBJECTDESC pDesc,
		REFIID riid,
		LPVOID FAR *ppv)=0;
	virtual HRESULT STDMETHODCALLTYPE ReportDynamicallyReferencedObject(
		IDirectMusicObject *pSourceObject,
		IUnknown *pReferencedObject)=0;

	// These should probably never be exposed publicly.
	// Scripts hold a reference to the loader because they need to be able to inform it
	// when they set variables to reference DirectMusic objects the loader tracks for
	// garbage collection.  However, that would create a circular reference because the
	// loader also holds a reference to scripts in its cache.  Garbage collection can't break
	// a circular reference that the loader itself is involved in.  Instead we use these private
	// ref count methods.  When the app is no longer using the loader (public Release drops
	// to zero) then the loader can clear its cache.  This releases references to scripts
	// (and also to streams, which use the same technique), triggering them to do ReleaseP
	// and everything gets cleaned up.
	virtual ULONG STDMETHODCALLTYPE AddRefP() = 0;	// Private AddRef, for scripts.
	virtual ULONG STDMETHODCALLTYPE ReleaseP() = 0;	// Private Release, for scripts.
};

// IDirectMusicBandP
interface IDirectMusicBandP : IUnknown
{
	// IUnknown
	virtual HRESULT STDMETHODCALLTYPE QueryInterface(REFIID, LPVOID FAR *)=0; 
	virtual ULONG STDMETHODCALLTYPE AddRef()=0; 
	virtual ULONG STDMETHODCALLTYPE Release()=0; 

	// IDirectMusicBandP
	virtual HRESULT STDMETHODCALLTYPE DownloadEx(IUnknown *pAudioPath)=0; 
	virtual HRESULT STDMETHODCALLTYPE UnloadEx(IUnknown *pAudioPath)=0; 
};

// IDirectMusicObjectP
interface IDirectMusicObjectP : IUnknown
{
	// IUnknown
	virtual HRESULT STDMETHODCALLTYPE QueryInterface(REFIID, LPVOID FAR *)=0; 
	virtual ULONG STDMETHODCALLTYPE AddRef()=0; 
	virtual ULONG STDMETHODCALLTYPE Release()=0; 

	// IDirectMusicObjectP
	virtual void STDMETHODCALLTYPE Zombie()=0; 
};

// IDirectMusicPerformanceP
interface IDirectMusicPerformanceP : IUnknown
{
	// IUnknown
	virtual HRESULT STDMETHODCALLTYPE QueryInterface(REFIID, LPVOID FAR *)=0; 
	virtual ULONG STDMETHODCALLTYPE AddRef()=0; 
	virtual ULONG STDMETHODCALLTYPE Release()=0; 

	// IDirectMusicPerformanceP
    virtual HRESULT STDMETHODCALLTYPE GetPortAndFlags(DWORD dwPChannel,IDirectMusicPort **ppPort,DWORD * pdwFlags) = 0;
};

#define DM_PORTFLAGS_GM     1       /* Synth has GM set locally. */
#define DM_PORTFLAGS_GS     2       /* Synth has GS set locally. */
#define DM_PORTFLAGS_XG     4       /* Synth has XG set locally. */


// Private path stage to access the sink.
#define DMUS_PATH_SINK             0x5000      /* Access the DSound Sink interface. */

// GUIDs for new performance layer private interfaces
DEFINE_GUID(IID_IDirectMusicSegment8P, 0x4bd7fb35, 0x8253, 0x48e0, 0x90, 0x64, 0x8a, 0x20, 0x89, 0x82, 0x37, 0xcb);
DEFINE_GUID(IID_IDirectMusicComposer8P, 0xabaf70dc, 0xdfba, 0x4adf, 0xbf, 0xa9, 0x7b, 0x0, 0xe4, 0x19, 0xeb, 0xbb);
DEFINE_GUID(IID_IDirectMusicStyle8P, 0x2b7c5f39, 0x990a, 0x4fd7, 0x9b, 0x70, 0x1e, 0xa3, 0xde, 0x31, 0x55, 0xa5);
DEFINE_GUID(IID_IDirectMusicLoader8P, 0x3939facd, 0xf6ed, 0x4619, 0xbd, 0x16, 0x56, 0x60, 0x3f, 0x1, 0x51, 0xca);
DEFINE_GUID(IID_IDirectMusicBandP, 0xf2e00137, 0xa131, 0x4289, 0xaa, 0x6c, 0xa9, 0x60, 0x7d, 0x4, 0x85, 0xf5);
DEFINE_GUID(IID_IDirectMusicObjectP, 0x6a20c217, 0xeb3e, 0x40ec, 0x9f, 0x3a, 0x92, 0x5, 0x8, 0x70, 0x2b, 0x5e);
DEFINE_GUID(IID_IDirectMusicPerformanceP, 0xe583be58, 0xe93f, 0x4316, 0xbb, 0x6b, 0xcb, 0x2c, 0x71, 0x96, 0x40, 0x44);


/* DMUS_PMSGT_PRIVATE_TYPES fill the DMUS_PMSG's dwType member */
/* These start at 15000 in order to avoid conflicting with public DMUS_PMSGT_TYPES. */
typedef enum enumDMUS_PMSGT_PRIVATE_TYPES
{
    DMUS_PMSGT_SCRIPTTRACKERROR = 15000, /* Sent by the script track when an error occurs in the script. */
} DMUS_PMSGT_PRIVATE_TYPES;

/* DMUS_SCRIPT_TRACK_ERROR_PMSG */
/* These PMsgs are sent by the script track if there is a syntax error in a script it tries to connect to or
   if a routine it calls fails. */
typedef struct _DMUS_SCRIPT_TRACK_ERROR_PMSG
{
    /* begin DMUS_PMSG_PART */
    DMUS_PMSG_PART
    /* end DMUS_PMSG_PART */

    DMUS_SCRIPT_ERRORINFO ErrorInfo; /* The error that occured.  Same as structure returned by IDirectMusicScript's Init and CallRoutine members. */
} DMUS_SCRIPT_TRACK_ERROR_PMSG;

/* Track param type guids */

/* Use (call SetParam on the script track) to turn on PMsgs (DMUS_SCRIPT_TRACK_ERROR_PMSG) the script track sends if there
   is a syntax error in the script it tries to connect to or if one of the routines it calls fails. */
DEFINE_GUID(GUID_EnableScriptTrackError,0x1cc7e0bf, 0x981c, 0x4b9f, 0xbe, 0x17, 0xd5, 0x72, 0xfc, 0x5f, 0xa9, 0x33); // {1CC7E0BF-981C-4b9f-BE17-D572FC5FA933}

#endif          // _DMUSICP_DOT_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\XDmime\dmstrm.cpp ===
//
// dmstrm.cpp
//
// Copyright (c) 1995-2000 Microsoft Corporation
//

#include "debug.h"
#include "dmusicc.h"
#include "dmstrm.h"
#include "validate.h"

/////////////////////////////////////////////////////////////////////////////
// AllocDIrectMusicStream

STDAPI AllocDirectMusicStream(IStream* pIStream, IDMStream** ppIDMStream)
{
    if(pIStream == NULL || ppIDMStream == NULL)
    {
        return E_INVALIDARG;
    }

    if((*ppIDMStream = (IDMStream*) new CDirectMusicStream()) == NULL)
    {
        return E_OUTOFMEMORY;
    }

    ((CDirectMusicStream*)*ppIDMStream)->Init(pIStream);

    return S_OK;
}

//////////////////////////////////////////////////////////////////////
// CDirectMusicStream::CDirectMusicStream

CDirectMusicStream::CDirectMusicStream() :
m_cRef(1),
m_pStream(NULL)
{
}

//////////////////////////////////////////////////////////////////////
// CDirectMusicStream::~CDirectMusicStream

CDirectMusicStream::~CDirectMusicStream()
{
    if(m_pStream != NULL)
    {
        m_pStream->Release();
    }
}

//////////////////////////////////////////////////////////////////////
// CDirectMusicStream::Init

STDMETHODIMP CDirectMusicStream::Init(IStream* pStream)
{
    SetStream(pStream);

    return S_OK;
}

//////////////////////////////////////////////////////////////////////
// IUnknown

//////////////////////////////////////////////////////////////////////
// CDirectMusicStream::QueryInterface

STDMETHODIMP CDirectMusicStream::QueryInterface(const IID &iid, void **ppv)
{
    V_INAME(CDirectMusicStream::QueryInterface);
    V_PTRPTR_WRITE(ppv);
    V_REFGUID(iid);

    if(iid == IID_IUnknown || iid == IID_IDMStream)
    {
        *ppv = static_cast<IDMStream*>(this);
    }
    else
    {
        *ppv = NULL;
        return E_NOINTERFACE;
    }

    reinterpret_cast<IUnknown*>(this)->AddRef();

    return S_OK;
}

//////////////////////////////////////////////////////////////////////
// CDirectMusicStream::AddRef

STDMETHODIMP_(ULONG) CDirectMusicStream::AddRef()
{
    return InterlockedIncrement(&m_cRef);
}

//////////////////////////////////////////////////////////////////////
// CDirectMusicStream::Release

STDMETHODIMP_(ULONG) CDirectMusicStream::Release()
{
    if(!InterlockedDecrement(&m_cRef))
    {
        delete this;
        return 0;
    }

    return m_cRef;
}

//////////////////////////////////////////////////////////////////////
// CDirectMusicStream::SetStream

STDMETHODIMP CDirectMusicStream::SetStream(IStream* pStream)
{
    if(m_pStream != NULL)
    {
        m_pStream->Release();
    }

    m_pStream = pStream;

    if(m_pStream != NULL)
    {
        m_pStream->AddRef();
    }

    return S_OK;
}

//////////////////////////////////////////////////////////////////////
// CDirectMusicStream::GetStream

STDMETHODIMP_(IStream*) CDirectMusicStream::GetStream()
{
    if(m_pStream != NULL)
    {
        m_pStream->AddRef();
    }

    return m_pStream;
}

//////////////////////////////////////////////////////////////////////
// IDMStream

//////////////////////////////////////////////////////////////////////
// CDirectMusicStream::Descend

STDMETHODIMP CDirectMusicStream::Descend(LPMMCKINFO lpck, LPMMCKINFO lpckParent, UINT wFlags)
{
    assert(lpck);

    FOURCC ckidFind;           // Chunk ID to find (or NULL)
    FOURCC fccTypeFind;    // Form/list type to find (or NULL)

    // Figure out what chunk id and form/list type for which to search
    if(wFlags & MMIO_FINDCHUNK)
    {
        ckidFind = lpck->ckid;
        fccTypeFind = NULL;
    }
    else if(wFlags & MMIO_FINDRIFF)
    {
        ckidFind = FOURCC_RIFF;
        fccTypeFind = lpck->fccType;
    }
    else if(wFlags & MMIO_FINDLIST)
    {
        ckidFind = FOURCC_LIST;
        fccTypeFind = lpck->fccType;
    }
    else
    {
        ckidFind = fccTypeFind = NULL;
    }

    lpck->dwFlags = 0L;

    for(;;)
    {
        HRESULT hr;
        LARGE_INTEGER li;
        ULARGE_INTEGER uli;
        ULONG cbRead;

        // Read the chunk header
        hr = m_pStream->Read(lpck, 2 * sizeof(DWORD), &cbRead);

        if (FAILED(hr) || (cbRead != 2 * sizeof(DWORD)))
        {
            Trace(3,"Warning: Reached end of file.\n");
            return DMUS_E_DESCEND_CHUNK_FAIL;
        }

        // Store the offset of the data part of the chunk
        li.QuadPart = 0;
        hr = m_pStream->Seek(li, STREAM_SEEK_CUR, &uli);

        if(FAILED(hr))
        {
            Trace(1,"Error: Unable to read file.\n");
            return DMUS_E_CANNOTSEEK;
        }
        else
        {
            lpck->dwDataOffset = uli.LowPart;
        }

        // See if the chunk is within the parent chunk (if given)
        if((lpckParent != NULL) &&
           (lpck->dwDataOffset - 8L >=
           lpckParent->dwDataOffset + lpckParent->cksize))
        {
            // This is not really a failure, just indicating we've reached the end of the list.
            return DMUS_E_DESCEND_CHUNK_FAIL;
        }

        // If the chunk is a 'RIFF' or 'LIST' chunk, read the
        // form type or list type
        if((lpck->ckid == FOURCC_RIFF) || (lpck->ckid == FOURCC_LIST))
        {
            hr = m_pStream->Read(&lpck->fccType, sizeof(DWORD), &cbRead);

            if(FAILED(hr) || (cbRead != sizeof(DWORD)))
            {
                Trace(1,"Error: Unable to read file.\n");
                return DMUS_E_DESCEND_CHUNK_FAIL;
            }
        }
        else
        {
            lpck->fccType = NULL;
        }

        // If this is the chunk we're looking for, stop looking
        if(((ckidFind == NULL) || (ckidFind == lpck->ckid)) &&
           ((fccTypeFind == NULL) || (fccTypeFind == lpck->fccType)))
        {
            break;
        }

        // Ascend out of the chunk and try again
        HRESULT w = Ascend(lpck, 0);
        if(FAILED(w))
        {
            return w;
        }
    }

    return S_OK;
}


//////////////////////////////////////////////////////////////////////
// CDirectMusicStream::Ascend

STDMETHODIMP CDirectMusicStream::Ascend(LPMMCKINFO lpck, UINT /*wFlags*/)
{
    assert(lpck);

    HRESULT hr;
    LARGE_INTEGER li;
    ULARGE_INTEGER uli;

    if (lpck->dwFlags & MMIO_DIRTY)
    {
        // <lpck> refers to a chunk created by CreateChunk();
        // check that the chunk size that was written when
        // CreateChunk() was called is the real chunk size;
        // if not, fix it
        LONG lOffset;           // current offset in file
        LONG lActualSize;   // actual size of chunk data

        li.QuadPart = 0;
        hr = m_pStream->Seek(li, STREAM_SEEK_CUR, &uli);

        if(FAILED(hr))
        {
            Trace(1,"Error: Unable to write file.\n");
            return DMUS_E_CANNOTSEEK;
        }
        else
        {
            lOffset = uli.LowPart;
        }

        if((lActualSize = lOffset - lpck->dwDataOffset) < 0)
        {
            Trace(1,"Error: Unable to write file.\n");
            return DMUS_E_CANNOTWRITE;
        }

        if(LOWORD(lActualSize) & 1)
        {
            ULONG cbWritten;

            // Chunk size is odd -- write a null pad byte
            hr = m_pStream->Write("\0", 1, &cbWritten);

            if(FAILED(hr) || cbWritten != 1)
            {
                Trace(1,"Error: Unable to write file.\n");
                return DMUS_E_CANNOTWRITE;
            }

        }

        if(lpck->cksize == (DWORD)lActualSize)
        {
            return S_OK;
        }

        // Fix the chunk header
        lpck->cksize = lActualSize;

        li.QuadPart = lpck->dwDataOffset - sizeof(DWORD);
        hr = m_pStream->Seek(li, STREAM_SEEK_SET, &uli);

        if(FAILED(hr))
        {
            Trace(1,"Error: Unable to write file.\n");
            return DMUS_E_CANNOTSEEK;
        }

        ULONG cbWritten;

        hr = m_pStream->Write(&lpck->cksize, sizeof(DWORD), &cbWritten);

        if(FAILED(hr) || cbWritten != sizeof(DWORD))
        {
            Trace(1,"Error: Unable to write file.\n");
            return DMUS_E_CANNOTWRITE;
        }
    }

    // Seek to the end of the chunk, past the null pad byte
    // (which is only there if chunk size is odd)
    li.QuadPart = lpck->dwDataOffset + lpck->cksize + (lpck->cksize & 1L);
    hr = m_pStream->Seek(li, STREAM_SEEK_SET, &uli);

    if(FAILED(hr))
    {
        Trace(1,"Error: Unable to write file.\n");
        return DMUS_E_CANNOTSEEK;
    }

    return S_OK;
}

//////////////////////////////////////////////////////////////////////
// CDirectMusicStream::CreateChunk

STDMETHODIMP CDirectMusicStream::CreateChunk(LPMMCKINFO lpck, UINT wFlags)
{
    assert(lpck);

    UINT iBytes;    // Bytes to write
    LONG lOffset;   // Current offset in file

    // Store the offset of the data part of the chunk
    LARGE_INTEGER li;
    ULARGE_INTEGER uli;

    li.QuadPart = 0;
    HRESULT hr = m_pStream->Seek(li, STREAM_SEEK_CUR, &uli);

    if(FAILED(hr))
    {
        Trace(1,"Error: Unable to write file.\n");
        return DMUS_E_CANNOTSEEK;
    }
    else
    {
        lOffset = uli.LowPart;
    }

    lpck->dwDataOffset = lOffset + 2 * sizeof(DWORD);

    // figure out if a form/list type needs to be written
    if(wFlags & MMIO_CREATERIFF)
    {
        lpck->ckid = FOURCC_RIFF, iBytes = 3 * sizeof(DWORD);
    }
    else if(wFlags & MMIO_CREATELIST)
    {
        lpck->ckid = FOURCC_LIST, iBytes = 3 * sizeof(DWORD);
    }
    else
    {
        iBytes = 2 * sizeof(DWORD);
    }

    // Write the chunk header
    ULONG cbWritten;

    hr = m_pStream->Write(lpck, iBytes, &cbWritten);

    if(FAILED(hr) || cbWritten != iBytes)
    {
        Trace(1,"Error: Unable to write file.\n");
        return DMUS_E_CANNOTWRITE;
    }

    lpck->dwFlags = MMIO_DIRTY;

    return S_OK;
}

CRiffParser::CRiffParser(IStream *pStream)

{
    assert(pStream);
    m_fDebugOn = FALSE;
    m_pStream = pStream;
    m_pParent = NULL;
    m_pChunk = NULL;
    m_lRead = 0;
    m_fFirstPass = TRUE;
    m_fComponentFailed = FALSE;
    m_fInComponent = FALSE;
}

void CRiffParser::EnterList(RIFFIO *pChunk)

{
    assert (pChunk);
    pChunk->lRead = 0;
    pChunk->pParent = m_pChunk; // Previous chunk (could be NULL.)
    m_pParent = m_pChunk;
    m_pChunk = pChunk;
    m_fFirstPass = TRUE;
}

void CRiffParser::LeaveList()

{
    assert (m_pChunk);
    if (m_pChunk)
    {
        m_pChunk = m_pChunk->pParent;
        if (m_pChunk)
        {
            m_pParent = m_pChunk->pParent;
        }
    }
}

BOOL CRiffParser::NextChunk(HRESULT * pHr)

{
    BOOL fMore = FALSE;
    if (SUCCEEDED(*pHr))
    {
        // If this is the first time we've entered this list, there is no previous chunk.
        if (m_fFirstPass)
        {
            // Clear the flag.
            m_fFirstPass = FALSE;
        }
        else
        {
            // Clean up the previous pass.
            *pHr = LeaveChunk();
        }
        // Find out if there are more chunks to read.
        fMore = MoreChunks();
        // If so, and we don't have any failure, go ahead and read the next chunk header.
        if (fMore && SUCCEEDED(*pHr))
        {
            *pHr = EnterChunk();
        }
    }
    else
    {
#ifdef DBG
        char szName[5];
        if (m_fDebugOn)
        {
            szName[4] = 0;
            strncpy(szName,(char *)&m_pChunk->ckid,4);
            Trace(0,"Error parsing %s, Read %ld of %ld\n",szName,m_pChunk->lRead,RIFF_ALIGN(m_pChunk->cksize));
        }
#endif
        // If we were in a component, it's okay to fail. Mark that fact by setting
        // m_fComponentFailed then properly pull out of the chunk so we can
        // continue reading.
        if (m_fInComponent)
        {
            m_fComponentFailed = TRUE;
            // We don't need to check for first pass, because we must have gotten
            // that far. Instead, we just clean up from the failed chunk.
            // Note that this sets the hresult to S_OK, which is what we want.
            // Later, the caller needs to call ComponentFailed() to find out if
            // this error occured.
            *pHr = LeaveChunk();
        }
        else
        {
            // Clean up but leave the error code.
            LeaveChunk();
        }
    }
    return fMore && SUCCEEDED(*pHr);
}

BOOL CRiffParser::MoreChunks()

{
    assert(m_pChunk);
    if (m_pChunk)
    {
        if (m_pParent)
        {
            // Return TRUE if there's enough room for another chunk.
            return (m_pParent->lRead < (m_pParent->cksize - 8));
        }
        else
        {
            // This must be a top level chunk, in which case there would only be one to read.
            return (m_pChunk->lRead == 0);
        }
    }
    // This should never happen unless CRiffParser is used incorrectly, in which
    // case the assert will help debug. But, in the interest of making Prefix happy...
    return false;
}

HRESULT CRiffParser::EnterChunk()

{
    assert(m_pChunk);
    if (m_pChunk)
    {
        // Read the chunk header
        HRESULT hr = m_pStream->Read(m_pChunk, 2 * sizeof(DWORD), NULL);
        if (SUCCEEDED(hr))
        {
#ifdef DBG
            char szName[5];
            if (m_fDebugOn)
            {
                szName[4] = 0;
                strncpy(szName,(char *)&m_pChunk->ckid,4);
                ULARGE_INTEGER ul;
                LARGE_INTEGER li;
                li.QuadPart = 0;
                m_pStream->Seek(li, STREAM_SEEK_CUR, &ul);

                Trace(0,"Entering %s, Length %ld, File position is %ld",szName,m_pChunk->cksize,(long)ul.QuadPart);
            }
#endif
            // Clear bytes read field.
            m_pChunk->lRead = 0;
            // Check to see if this is a container (LIST or RIFF.)
            if((m_pChunk->ckid == FOURCC_RIFF) || (m_pChunk->ckid == FOURCC_LIST))
            {
                hr = m_pStream->Read(&m_pChunk->fccType, sizeof(DWORD), NULL);
                if (SUCCEEDED(hr))
                {
                    m_pChunk->lRead += sizeof(DWORD);
#ifdef DBG
                    if (m_fDebugOn)
                    {
                        strncpy(szName,(char *)&m_pChunk->fccType,4);
                        Trace(0," Type %s",szName);
                    }
#endif
                }
                else
                {
                    Trace(1,"Error: Unable to read file.\n");
                }
            }
#ifdef DBG
            if (m_fDebugOn) Trace(0,"\n");
#endif
        }
        else
        {
            Trace(1,"Error: Unable to read file.\n");
        }
        return hr;
    }
    // This should never happen unless CRiffParser is used incorrectly, in which
    // case the assert will help debug. But, in the interest of making Prefix happy...
    return E_FAIL;
}

HRESULT CRiffParser::LeaveChunk()

{
    HRESULT hr = S_OK;
    assert(m_pChunk);
    if (m_pChunk)
    {
        m_fInComponent = false;
        // Get the rounded up size of the chunk.
        long lSize = RIFF_ALIGN(m_pChunk->cksize);
        // Increment the parent's count of bytes read so far.
        if (m_pParent)
        {
            m_pParent->lRead += lSize + (2 * sizeof(DWORD));
            if (m_pParent->lRead > RIFF_ALIGN(m_pParent->cksize))
            {
                Trace(1,"Error: Unable to read file.\n");
                hr = DMUS_E_DESCEND_CHUNK_FAIL; // Goofy error name, but need to be consistent with previous versions.
            }
        }
#ifdef DBG
        char szName[5];
        if (m_fDebugOn)
        {
            szName[4] = 0;
            strncpy(szName,(char *)&m_pChunk->ckid,4);
            ULARGE_INTEGER ul;
            LARGE_INTEGER li;
            li.QuadPart = 0;
            m_pStream->Seek(li, STREAM_SEEK_CUR, &ul);

            Trace(0,"Leaving %s, Read %ld of %ld, File Position is %ld\n",szName,m_pChunk->lRead,lSize,(long)ul.QuadPart);
        }
#endif
        // If we haven't actually read this entire chunk, seek to the end of it.
        if (m_pChunk->lRead < lSize)
        {
            LARGE_INTEGER li;
            li.QuadPart = lSize - m_pChunk->lRead;
            hr = m_pStream->Seek(li,STREAM_SEEK_CUR,NULL);
            // There's a chance it could fail because we are at the end of file with an odd length chunk.
            if (FAILED(hr))
            {
                // If there's a parent, see if this is the last chunk.
                if (m_pParent)
                {
                    if (m_pParent->cksize >= (m_pParent->lRead - 1))
                    {
                        hr = S_OK;
                    }
                }
                // Else, see if we are an odd length.
                else if (m_pChunk->cksize & 1)
                {
                    hr = S_OK;
                }
            }
        }
        return hr;
    }
    // This should never happen unless CRiffParser is used incorrectly, in which
    // case the assert will help debug. But, in the interest of making Prefix happy...
    return E_FAIL;
}

HRESULT CRiffParser::Read(void *pv,ULONG cb)

{
    assert(m_pChunk);
    if (m_pChunk)
    {
        // Make sure we don't read beyond the end of the chunk.
        if (((long)cb + m_pChunk->lRead) > m_pChunk->cksize)
        {
            cb -= (cb - (m_pChunk->cksize - m_pChunk->lRead));
        }
        HRESULT hr = m_pStream->Read(pv,cb,NULL);
        if (SUCCEEDED(hr))
        {
            m_pChunk->lRead += cb;
        }
        else
        {
            Trace(1,"Error: Unable to read %ld bytes from file.\n",cb);
        }
        return hr;
    }
    // This should never happen unless CRiffParser is used incorrectly, in which
    // case the assert will help debug. But, in the interest of making Prefix happy...
    return E_FAIL;
}

HRESULT CRiffParser::Skip(ULONG ulBytes)

{
    assert(m_pChunk);
    if (m_pChunk)
    {
        // Make sure we don't scan beyond the end of the chunk.
        if (((long)ulBytes + m_pChunk->lRead) > m_pChunk->cksize)
        {
            ulBytes -= (ulBytes - (m_pChunk->cksize - m_pChunk->lRead));
        }
        LARGE_INTEGER li;
        li.HighPart = 0;
        li.LowPart = ulBytes;
        HRESULT hr = m_pStream->Seek( li, STREAM_SEEK_CUR, NULL );
        if (SUCCEEDED(hr))
        {
            m_pChunk->lRead += ulBytes;
        }
        return hr;
    }
    // This should never happen unless CRiffParser is used incorrectly, in which
    // case the assert will help debug. But, in the interest of making Prefix happy...
    return E_FAIL;
}


void CRiffParser::MarkPosition()

{
    assert(m_pChunk);
    if (m_pChunk)
    {
        LARGE_INTEGER li;
        ULARGE_INTEGER ul;
        li.HighPart = 0;
        li.LowPart = 0;
        m_pStream->Seek(li, STREAM_SEEK_CUR, &ul);
        m_pChunk->liPosition.QuadPart = (LONGLONG) ul.QuadPart;
    }
}

HRESULT CRiffParser::SeekBack()

{
    assert(m_pChunk);
    if (m_pChunk)
    {
        // Move back to the start of the current chunk. Also, store the
        // absolute position because that will be useful later when we need to seek to the
        // end of this chunk.
        ULARGE_INTEGER ul;
        LARGE_INTEGER li;
        li.QuadPart = 0;
        li.QuadPart -= (m_pChunk->lRead + (2 * sizeof(DWORD)));
        HRESULT hr = m_pStream->Seek(li, STREAM_SEEK_CUR, &ul);
        // Now, save the absolute position for the end of this chunk.
        m_pChunk->liPosition.QuadPart = ul.QuadPart +
            RIFF_ALIGN(m_pChunk->cksize) + (2 * sizeof(DWORD));
        m_pChunk->lRead = 0;
        return hr;
    }
    return E_FAIL;
}

HRESULT CRiffParser::SeekForward()

{
    assert(m_pChunk);
    if (m_pChunk)
    {
        m_pChunk->lRead = RIFF_ALIGN(m_pChunk->cksize);
        return m_pStream->Seek(m_pChunk->liPosition, STREAM_SEEK_SET, NULL);
    }
    return E_FAIL;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\XDmime\dsoundp.h ===
/*==========================================================================;
 *
 *  Copyright (C) 1995-2001 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       dsound.h
 *  Content:    DirectSound include file
 *@@BEGIN_MSINTERNAL
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *  2/10/96     angusm  Added CLSID for DirectSound
 *  2/11/96     angusm  Added DSERR_UNINITIALIZED
 *  2/12/96     angusm  Added DSSCL_UNINITIALIZED
 *  3/5/96      angusm  Removed DSSCL_UNINITIALIZED
 *  1/29/97     dereks  Added boundaries, LPC* and REFGUIDs
 *  4/10/97     dereks  Added IDirectSoundCapture
 *  4/11/97     dereks  Added IKsPropertySet
 *  4/25/97     johnnyl Added DSCCREATE_WAVEMAPPED flag
 *  5/7/97      johnnyl Added DirectSoundCaptureBuffer::Initialize method
 *  5/8/97      dereks  Backed out REFGUIDs
 *  5/9/97      johnnyl Changed DSCCREATE_WAVEMAPPED to DSCBCAPS_WAVEMAPPED
 *                      Added DSCBLOCK_ENTIREBUFFER flag
 *  5/29/97     dereks  IDirectSoundPropertySet => IKsPropertySet
 *  7/10/98     dereks  Added DirectX 6.1 features
 *  8/19/98     dereks  Moved private object to dsprv.h
 *  9/15/98     dereks  Added DirectX 7.0 features
 *  7/6/99      duganp  Added DirectX 8.0 features
 *  10/29/99    duganp  Added DirectX 7.1 features (sic)
 *  06/06/00    alanlu  Cleaned up DSFX_I3DL2* constants
 *@@END_MSINTERNAL
 *
 **************************************************************************/

#define COM_NO_WINDOWS_H
#include <objbase.h>
#include <float.h>

#ifndef DIRECTSOUND_VERSION
#define DIRECTSOUND_VERSION 0x0800  /* Version 8.0 */
#endif

#ifdef __cplusplus
extern "C" {
#endif // __cplusplus

#ifndef __DSOUND_INCLUDED__
#define __DSOUND_INCLUDED__

/* Type definitions shared with Direct3D */

#ifndef DX_SHARED_DEFINES

typedef float D3DVALUE, *LPD3DVALUE;

#ifndef D3DCOLOR_DEFINED
typedef DWORD D3DCOLOR;
#define D3DCOLOR_DEFINED
#endif

#ifndef LPD3DCOLOR_DEFINED
typedef DWORD *LPD3DCOLOR;
#define LPD3DCOLOR_DEFINED
#endif

#ifndef D3DVECTOR_DEFINED
typedef struct _D3DVECTOR {
    float x;
    float y;
    float z;
} D3DVECTOR;
#define D3DVECTOR_DEFINED
#endif

#ifndef LPD3DVECTOR_DEFINED
typedef D3DVECTOR *LPD3DVECTOR;
#define LPD3DVECTOR_DEFINED
#endif

#define DX_SHARED_DEFINES
#endif // DX_SHARED_DEFINES

#define _FACDS  0x878   /* DirectSound's facility code */
#define MAKE_DSHRESULT(code)  MAKE_HRESULT(1, _FACDS, code)

// DirectSound Component GUID {47D4D946-62E8-11CF-93BC-444553540000}
DEFINE_GUID(CLSID_DirectSound, 0x47d4d946, 0x62e8, 0x11cf, 0x93, 0xbc, 0x44, 0x45, 0x53, 0x54, 0x0, 0x0);

// DirectSound 8.0 Component GUID {3901CC3F-84B5-4FA4-BA35-AA8172B8A09B}
DEFINE_GUID(CLSID_DirectSound8, 0x3901cc3f, 0x84b5, 0x4fa4, 0xba, 0x35, 0xaa, 0x81, 0x72, 0xb8, 0xa0, 0x9b);

// DirectSound Capture Component GUID {B0210780-89CD-11D0-AF08-00A0C925CD16}
DEFINE_GUID(CLSID_DirectSoundCapture, 0xb0210780, 0x89cd, 0x11d0, 0xaf, 0x8, 0x0, 0xa0, 0xc9, 0x25, 0xcd, 0x16);

// DirectSound 8.0 Capture Component GUID {E4BCAC13-7F99-4908-9A8E-74E3BF24B6E1}
DEFINE_GUID(CLSID_DirectSoundCapture8, 0xe4bcac13, 0x7f99, 0x4908, 0x9a, 0x8e, 0x74, 0xe3, 0xbf, 0x24, 0xb6, 0xe1);

// DirectSound Full Duplex Component GUID {FEA4300C-7959-4147-B26A-2377B9E7A91D}
DEFINE_GUID(CLSID_DirectSoundFullDuplex, 0xfea4300c, 0x7959, 0x4147, 0xb2, 0x6a, 0x23, 0x77, 0xb9, 0xe7, 0xa9, 0x1d);

//@@BEGIN_MSINTERNAL
// DirectSound Buffer Descriptor GUID {B2F586D4-5558-49D1-A07B3249DBBB33C2}
DEFINE_GUID(CLSID_DirectSoundBufferConfig, 0xb2f586d4, 0x5558, 0x49d1, 0xa0, 0x7b, 0x32, 0x49, 0xdb, 0xbb, 0x33, 0xc2);
//@@END_MSINTERNAL

//@@BEGIN_MSINTERNAL
// Magic private DirectSound buffer descriptor GUID {74A794F9-FDD2-4684-88831CB3CA6E6DA6}
DEFINE_GUID(CLSID_PRIVATE_CDirectSoundBufferConfig, 0x74a794f9, 0xfdd2, 0x4684, 0x88, 0x83, 0x1c, 0xb3, 0xca, 0x6e, 0x6d, 0xa6);
//@@END_MSINTERNAL

// DirectSound default playback device GUID {DEF00000-9C6D-47ED-AAF1-4DDA8F2B5C03}
DEFINE_GUID(DSDEVID_DefaultPlayback, 0xdef00000, 0x9c6d, 0x47ed, 0xaa, 0xf1, 0x4d, 0xda, 0x8f, 0x2b, 0x5c, 0x03);

// DirectSound default capture device GUID {DEF00001-9C6D-47ED-AAF1-4DDA8F2B5C03}
DEFINE_GUID(DSDEVID_DefaultCapture, 0xdef00001, 0x9c6d, 0x47ed, 0xaa, 0xf1, 0x4d, 0xda, 0x8f, 0x2b, 0x5c, 0x03);

// DirectSound default device for voice playback {DEF00002-9C6D-47ED-AAF1-4DDA8F2B5C03}
DEFINE_GUID(DSDEVID_DefaultVoicePlayback, 0xdef00002, 0x9c6d, 0x47ed, 0xaa, 0xf1, 0x4d, 0xda, 0x8f, 0x2b, 0x5c, 0x03);

// DirectSound default device for voice capture {DEF00003-9C6D-47ED-AAF1-4DDA8F2B5C03}
DEFINE_GUID(DSDEVID_DefaultVoiceCapture, 0xdef00003, 0x9c6d, 0x47ed, 0xaa, 0xf1, 0x4d, 0xda, 0x8f, 0x2b, 0x5c, 0x03);


//
// Forward declarations for interfaces.
// 'struct' not 'class' per the way DECLARE_INTERFACE_ is defined
//

#ifdef __cplusplus
struct IDirectSound;
struct IDirectSoundBuffer;
struct IDirectSound3DListener;
struct IDirectSound3DBuffer;
struct IDirectSoundCapture;
struct IDirectSoundCaptureBuffer;
struct IDirectSoundNotify;
#endif // __cplusplus

//@@BEGIN_MSINTERNAL

//
// DirectSound 7.1 (Windows ME) interface.
//

#if DIRECTSOUND_VERSION >= 0x0701
#ifdef __cplusplus
struct IDirectSoundCaptureBuffer7_1;
#endif
#endif

//@@END_MSINTERNAL

//
// DirectSound 8.0 interfaces.
//

#if DIRECTSOUND_VERSION >= 0x0800

#ifdef __cplusplus
struct IDirectSound8;
struct IDirectSoundBuffer8;
struct IDirectSoundCaptureBuffer8;
//@@BEGIN_MSINTERNAL
struct IDirectSoundFXSend;
//@@END_MSINTERNAL
struct IDirectSoundFXGargle;
struct IDirectSoundFXChorus;
struct IDirectSoundFXFlanger;
struct IDirectSoundFXEcho;
struct IDirectSoundFXDistortion;
struct IDirectSoundFXCompressor;
struct IDirectSoundFXParamEq;
struct IDirectSoundFXWavesReverb;
//@@BEGIN_MSINTERNAL
///struct IDirectSoundFXI3DL2Source;
//@@END_MSINTERNAL
struct IDirectSoundFXI3DL2Reverb;
struct IDirectSoundCaptureFXAec;
struct IDirectSoundCaptureFXNoiseSuppress;
//@@BEGIN_MSINTERNAL
struct IDirectSoundCaptureFXAgc;
struct IDirectSoundCaptureFXMicArray;
struct IDirectSoundDMOProxy;
struct IDirectSoundFXI3DL2SourceEnv;
struct IDirectSound3DBufferPrivate;
//@@END_MSINTERNAL
struct IDirectSoundFullDuplex;
#endif // __cplusplus

// IDirectSound8, IDirectSoundBuffer8 and IDirectSoundCaptureBuffer8 are the
// only DirectSound 7.0 interfaces with changed functionality in version 8.0.
// The other level 8 interfaces as equivalent to their level 7 counterparts:

#define IDirectSoundCapture8            IDirectSoundCapture
#define IDirectSound3DListener8         IDirectSound3DListener
#define IDirectSound3DBuffer8           IDirectSound3DBuffer
#define IDirectSoundNotify8             IDirectSoundNotify
//@@BEGIN_MSINTERNAL
#define IDirectSoundFXSend8             IDirectSoundFXSend
//@@END_MSINTERNAL
#define IDirectSoundFXGargle8           IDirectSoundFXGargle
#define IDirectSoundFXChorus8           IDirectSoundFXChorus
#define IDirectSoundFXFlanger8          IDirectSoundFXFlanger
#define IDirectSoundFXEcho8             IDirectSoundFXEcho
#define IDirectSoundFXDistortion8       IDirectSoundFXDistortion
#define IDirectSoundFXCompressor8       IDirectSoundFXCompressor
#define IDirectSoundFXParamEq8          IDirectSoundFXParamEq
#define IDirectSoundFXWavesReverb8      IDirectSoundFXWavesReverb
//@@BEGIN_MSINTERNAL
///#define IDirectSoundFXI3DL2Source8      IDirectSoundFXI3DL2Source
//@@END_MSINTERNAL
#define IDirectSoundFXI3DL2Reverb8      IDirectSoundFXI3DL2Reverb
#define IDirectSoundCaptureFXAec8       IDirectSoundCaptureFXAec
#define IDirectSoundCaptureFXNoiseSuppress8 IDirectSoundCaptureFXNoiseSuppress
//@@BEGIN_MSINTERNAL
#define IDirectSoundCaptureFXAgc8       IDirectSoundCaptureFXAgc
#define IDirectSoundCaptureFXMicArray8  IDirectSoundCaptureFXMicArray
#define IDirectSoundDMOProxy8           IDirectSoundDMOProxy
#define IDirectSoundFXI3DL2SourceEnv8   IDirectSoundFXI3DL2SourceEnv
#define IDirectSound3DBufferPrivate8    IDirectSound3DBufferPrivate
//@@END_MSINTERNAL
#define IDirectSoundFullDuplex8         IDirectSoundFullDuplex

#endif // DIRECTSOUND_VERSION >= 0x0800


typedef struct IDirectSound                 *LPDIRECTSOUND;
typedef struct IDirectSoundBuffer           *LPDIRECTSOUNDBUFFER;
typedef struct IDirectSound3DListener       *LPDIRECTSOUND3DLISTENER;
typedef struct IDirectSound3DBuffer         *LPDIRECTSOUND3DBUFFER;
typedef struct IDirectSoundCapture          *LPDIRECTSOUNDCAPTURE;
typedef struct IDirectSoundCaptureBuffer    *LPDIRECTSOUNDCAPTUREBUFFER;
typedef struct IDirectSoundNotify           *LPDIRECTSOUNDNOTIFY;

//@@BEGIN_MSINTERNAL
#if DIRECTSOUND_VERSION >= 0x0701
typedef struct IDirectSoundCaptureBuffer7_1 *LPDIRECTSOUNDCAPTUREBUFFER7_1;
#endif
//@@END_MSINTERNAL

#if DIRECTSOUND_VERSION >= 0x0800
//@@BEGIN_MSINTERNAL
typedef struct IDirectSoundFXSend           *LPDIRECTSOUNDFXSEND;
//@@END_MSINTERNAL
typedef struct IDirectSoundFXGargle         *LPDIRECTSOUNDFXGARGLE;
typedef struct IDirectSoundFXChorus         *LPDIRECTSOUNDFXCHORUS;
typedef struct IDirectSoundFXFlanger        *LPDIRECTSOUNDFXFLANGER;
typedef struct IDirectSoundFXEcho           *LPDIRECTSOUNDFXECHO;
typedef struct IDirectSoundFXDistortion     *LPDIRECTSOUNDFXDISTORTION;
typedef struct IDirectSoundFXCompressor     *LPDIRECTSOUNDFXCOMPRESSOR;
typedef struct IDirectSoundFXParamEq        *LPDIRECTSOUNDFXPARAMEQ;
typedef struct IDirectSoundFXWavesReverb    *LPDIRECTSOUNDFXWAVESREVERB;
//@@BEGIN_MSINTERNAL
///typedef struct IDirectSoundFXI3DL2Source    *LPDIRECTSOUNDFXI3DL2SOURCE;
//@@END_MSINTERNAL
typedef struct IDirectSoundFXI3DL2Reverb    *LPDIRECTSOUNDFXI3DL2REVERB;
typedef struct IDirectSoundCaptureFXAec     *LPDIRECTSOUNDCAPTUREFXAEC;
typedef struct IDirectSoundCaptureFXNoiseSuppress *LPDIRECTSOUNDCAPTUREFXNOISESUPPRESS;
//@@BEGIN_MSINTERNAL
typedef struct IDirectSoundCaptureFXAgc     *LPDIRECTSOUNDCAPTUREFXAGC;
typedef struct IDirectSoundCaptureFXMicArray *LPDIRECTSOUNDCAPTUREFXMICARRAY;
typedef struct IDirectSoundDMOProxy         *LPDIRECTSOUNDDMOPROXY;
typedef struct IDirectSoundFXI3DL2SourceEnv *LPDIRECTSOUNDFXI3DL2SOURCEENV;
typedef struct IDirectSound3DBufferPrivate  *LPDIRECTSOUND3DBUFFERPRIVATE;
//@@END_MSINTERNAL
typedef struct IDirectSoundFullDuplex       *LPDIRECTSOUNDFULLDUPLEX;

typedef struct IDirectSound8                *LPDIRECTSOUND8;
typedef struct IDirectSoundBuffer8          *LPDIRECTSOUNDBUFFER8;
typedef struct IDirectSound3DListener8      *LPDIRECTSOUND3DLISTENER8;
typedef struct IDirectSound3DBuffer8        *LPDIRECTSOUND3DBUFFER8;
typedef struct IDirectSoundCapture8         *LPDIRECTSOUNDCAPTURE8;
typedef struct IDirectSoundCaptureBuffer8   *LPDIRECTSOUNDCAPTUREBUFFER8;
typedef struct IDirectSoundNotify8          *LPDIRECTSOUNDNOTIFY8;
//@@BEGIN_MSINTERNAL
typedef struct IDirectSoundFXSend8          *LPDIRECTSOUNDFXSEND8;
//@@END_MSINTERNAL
typedef struct IDirectSoundFXGargle8        *LPDIRECTSOUNDFXGARGLE8;
typedef struct IDirectSoundFXChorus8        *LPDIRECTSOUNDFXCHORUS8;
typedef struct IDirectSoundFXFlanger8       *LPDIRECTSOUNDFXFLANGER8;
typedef struct IDirectSoundFXEcho8          *LPDIRECTSOUNDFXECHO8;
typedef struct IDirectSoundFXDistortion8    *LPDIRECTSOUNDFXDISTORTION8;
typedef struct IDirectSoundFXCompressor8    *LPDIRECTSOUNDFXCOMPRESSOR8;
typedef struct IDirectSoundFXParamEq8       *LPDIRECTSOUNDFXPARAMEQ8;
typedef struct IDirectSoundFXWavesReverb8   *LPDIRECTSOUNDFXWAVESREVERB8;
//@@BEGIN_MSINTERNAL
///typedef struct IDirectSoundFXI3DL2Source8   *LPDIRECTSOUNDFXI3DL2SOURCE8;
//@@END_MSINTERNAL
typedef struct IDirectSoundFXI3DL2Reverb8   *LPDIRECTSOUNDFXI3DL2REVERB8;
typedef struct IDirectSoundCaptureFXAec8    *LPDIRECTSOUNDCAPTUREFXAEC8;
typedef struct IDirectSoundCaptureFXNoiseSuppress8 *LPDIRECTSOUNDCAPTUREFXNOISESUPPRESS8;
//@@BEGIN_MSINTERNAL
typedef struct IDirectSoundCaptureFXAgc8    *LPDIRECTSOUNDCAPTUREFXAGC8;
typedef struct IDirectSoundCaptureFXMicArray8 *LPDIRECTSOUNDCAPTUREFXMICARRAY8;
typedef struct IDirectSoundDMOProxy8        *LPDIRECTSOUNDDMOPROXY8;
typedef struct IDirectSoundFXI3DL2SourceEnv8 *LPDIRECTSOUNDFXI3DL2SOURCEENV8;
typedef struct IDirectSound3DBufferPrivate8 *LPDIRECTSOUND3DBUFFERPRIVATE8;
//@@END_MSINTERNAL
typedef struct IDirectSoundFullDuplex8      *LPDIRECTSOUNDFULLDUPLEX8;

#endif // DIRECTSOUND_VERSION >= 0x0800

//
// IID definitions for the unchanged DirectSound 8.0 interfaces
//

#if DIRECTSOUND_VERSION >= 0x0800
#define IID_IDirectSoundCapture8            IID_IDirectSoundCapture
#define IID_IDirectSound3DListener8         IID_IDirectSound3DListener
#define IID_IDirectSound3DBuffer8           IID_IDirectSound3DBuffer
#define IID_IDirectSoundNotify8             IID_IDirectSoundNotify
//@@BEGIN_MSINTERNAL
#define IID_IDirectSoundFXSend8             IID_IDirectSoundFXSend
//@@END_MSINTERNAL
#define IID_IDirectSoundFXGargle8           IID_IDirectSoundFXGargle
#define IID_IDirectSoundFXChorus8           IID_IDirectSoundFXChorus
#define IID_IDirectSoundFXFlanger8          IID_IDirectSoundFXFlanger
#define IID_IDirectSoundFXEcho8             IID_IDirectSoundFXEcho
#define IID_IDirectSoundFXDistortion8       IID_IDirectSoundFXDistortion
#define IID_IDirectSoundFXCompressor8       IID_IDirectSoundFXCompressor
#define IID_IDirectSoundFXParamEq8          IID_IDirectSoundFXParamEq
#define IID_IDirectSoundFXWavesReverb8      IID_IDirectSoundFXWavesReverb
//@@BEGIN_MSINTERNAL
///#define IID_IDirectSoundFXI3DL2Source8      IID_IDirectSoundFXI3DL2Source
//@@END_MSINTERNAL
#define IID_IDirectSoundFXI3DL2Reverb8      IID_IDirectSoundFXI3DL2Reverb
#define IID_IDirectSoundCaptureFXAec8       IID_IDirectSoundCaptureFXAec
#define IID_IDirectSoundCaptureFXNoiseSuppress8 IID_IDirectSoundCaptureFXNoiseSuppress
//@@BEGIN_MSINTERNAL
#define IID_IDirectSoundCaptureFXAgc8       IID_IDirectSoundCaptureFXAgc
#define IID_IDirectSoundCaptureFXMicArray8  IID_IDirectSoundCaptureFXMicArray
#define IID_IDirectSoundDMOProxy8           IID_IDirectSoundDMOProxy
#define IID_IDirectSoundFXI3DL2SourceEnv8   IID_IDirectSoundFXI3DL2SourceEnv
#define IID_IDirectSound3DBufferPrivate8    IID_IDirectSound3DBufferPrivate
//@@END_MSINTERNAL
#define IID_IDirectSoundFullDuplex8         IID_IDirectSoundFullDuplex
#endif // DIRECTSOUND_VERSION >= 0x0800

//
// Compatibility typedefs
//

#ifndef _LPCWAVEFORMATEX_DEFINED
#define _LPCWAVEFORMATEX_DEFINED
typedef const WAVEFORMATEX *LPCWAVEFORMATEX;
#endif // _LPCWAVEFORMATEX_DEFINED

#ifndef __LPCGUID_DEFINED__
#define __LPCGUID_DEFINED__
typedef const GUID *LPCGUID;
#endif // __LPCGUID_DEFINED__

typedef LPDIRECTSOUND *LPLPDIRECTSOUND;
typedef LPDIRECTSOUNDBUFFER *LPLPDIRECTSOUNDBUFFER;
typedef LPDIRECTSOUND3DLISTENER *LPLPDIRECTSOUND3DLISTENER;
typedef LPDIRECTSOUND3DBUFFER *LPLPDIRECTSOUND3DBUFFER;
typedef LPDIRECTSOUNDCAPTURE *LPLPDIRECTSOUNDCAPTURE;
typedef LPDIRECTSOUNDCAPTUREBUFFER *LPLPDIRECTSOUNDCAPTUREBUFFER;
typedef LPDIRECTSOUNDNOTIFY *LPLPDIRECTSOUNDNOTIFY;

#if DIRECTSOUND_VERSION >= 0x0800
typedef LPDIRECTSOUND8 *LPLPDIRECTSOUND8;
typedef LPDIRECTSOUNDBUFFER8 *LPLPDIRECTSOUNDBUFFER8;
typedef LPDIRECTSOUNDCAPTURE8 *LPLPDIRECTSOUNDCAPTURE8;
typedef LPDIRECTSOUNDCAPTUREBUFFER8 *LPLPDIRECTSOUNDCAPTUREBUFFER8;
#endif // DIRECTSOUND_VERSION >= 0x0800

//
// Structures
//

typedef struct _DSCAPS
{
    DWORD           dwSize;
    DWORD           dwFlags;
    DWORD           dwMinSecondarySampleRate;
    DWORD           dwMaxSecondarySampleRate;
    DWORD           dwPrimaryBuffers;
    DWORD           dwMaxHwMixingAllBuffers;
    DWORD           dwMaxHwMixingStaticBuffers;
    DWORD           dwMaxHwMixingStreamingBuffers;
    DWORD           dwFreeHwMixingAllBuffers;
    DWORD           dwFreeHwMixingStaticBuffers;
    DWORD           dwFreeHwMixingStreamingBuffers;
    DWORD           dwMaxHw3DAllBuffers;
    DWORD           dwMaxHw3DStaticBuffers;
    DWORD           dwMaxHw3DStreamingBuffers;
    DWORD           dwFreeHw3DAllBuffers;
    DWORD           dwFreeHw3DStaticBuffers;
    DWORD           dwFreeHw3DStreamingBuffers;
    DWORD           dwTotalHwMemBytes;
    DWORD           dwFreeHwMemBytes;
    DWORD           dwMaxContigFreeHwMemBytes;
    DWORD           dwUnlockTransferRateHwBuffers;
    DWORD           dwPlayCpuOverheadSwBuffers;
//@@BEGIN_MSINTERNAL
    // dwReserved1 == minor ver number, dwReserved2 == major ver number.
//@@END_MSINTERNAL
    DWORD           dwReserved1;
    DWORD           dwReserved2;
} DSCAPS, *LPDSCAPS;

typedef const DSCAPS *LPCDSCAPS;

typedef struct _DSBCAPS
{
    DWORD           dwSize;
    DWORD           dwFlags;
    DWORD           dwBufferBytes;
    DWORD           dwUnlockTransferRate;
    DWORD           dwPlayCpuOverhead;
} DSBCAPS, *LPDSBCAPS;

typedef const DSBCAPS *LPCDSBCAPS;

#if DIRECTSOUND_VERSION >= 0x0800

    typedef struct _DSEFFECTDESC
    {
        DWORD       dwSize;
        DWORD       dwFlags;
        GUID        guidDSFXClass;
        DWORD       dwReserved1;
        DWORD       dwReserved2;
    } DSEFFECTDESC, *LPDSEFFECTDESC;
    typedef const DSEFFECTDESC *LPCDSEFFECTDESC;

    #define DSFX_LOCHARDWARE    0x00000001
    #define DSFX_LOCSOFTWARE    0x00000002
//@@BEGIN_MSINTERNAL
    #define DSFX_OPTIONAL       0x00000004
    #define DSFX_VALIDFLAGS     (DSFX_LOCHARDWARE | DSFX_LOCSOFTWARE)
//@@END_MSINTERNAL

    enum
    {
        DSFXR_PRESENT,          // 0
        DSFXR_LOCHARDWARE,      // 1
        DSFXR_LOCSOFTWARE,      // 2
        DSFXR_UNALLOCATED,      // 3
        DSFXR_FAILED,           // 4
        DSFXR_UNKNOWN,          // 5
        DSFXR_SENDLOOP          // 6
    };

    typedef struct _DSCEFFECTDESC
    {
        DWORD       dwSize;
        DWORD       dwFlags;
        GUID        guidDSCFXClass;
        GUID        guidDSCFXInstance;
        DWORD       dwReserved1;
        DWORD       dwReserved2;
    } DSCEFFECTDESC, *LPDSCEFFECTDESC;
    typedef const DSCEFFECTDESC *LPCDSCEFFECTDESC;

    #define DSCFX_LOCHARDWARE   0x00000001
    #define DSCFX_LOCSOFTWARE   0x00000002
//@@BEGIN_MSINTERNAL
    #define DSCFX_RESERVED      0x00000020
//@@END_MSINTERNAL

//@@BEGIN_MSINTERNAL
    #define DSCFX_LOCMASK         (DSCFX_LOCHARDWARE | DSCFX_LOCSOFTWARE )
    #define DSCFX_VALIDFLAGS      (DSCFX_LOCMASK)
//@@END_MSINTERNAL

    #define DSCFXR_LOCHARDWARE  0x00000010
    #define DSCFXR_LOCSOFTWARE  0x00000020
//@@BEGIN_MSINTERNAL
// Since we don't support LOCDEFER-style voice management on capture,
// and we don't have a DSCFX_OPTIONAL flag at the moment, none of the
// flags below can ever be returned.  So they're private for now.
    #define DSCFXR_UNALLOCATED  0x00000040
    #define DSCFXR_FAILED       0x00000080
    #define DSCFXR_UNKNOWN      0x00000100
//@@END_MSINTERNAL

#endif // DIRECTSOUND_VERSION >= 0x0800

typedef struct _DSBUFFERDESC
{
    DWORD           dwSize;
    DWORD           dwFlags;
    DWORD           dwBufferBytes;
    DWORD           dwReserved;
    LPWAVEFORMATEX  lpwfxFormat;
#if DIRECTSOUND_VERSION >= 0x0700
    GUID            guid3DAlgorithm;
#endif
} DSBUFFERDESC, *LPDSBUFFERDESC;

typedef const DSBUFFERDESC *LPCDSBUFFERDESC;

// Older version of this structure:

typedef struct _DSBUFFERDESC1
{
    DWORD           dwSize;
    DWORD           dwFlags;
    DWORD           dwBufferBytes;
    DWORD           dwReserved;
    LPWAVEFORMATEX  lpwfxFormat;
} DSBUFFERDESC1, *LPDSBUFFERDESC1;

typedef const DSBUFFERDESC1 *LPCDSBUFFERDESC1;

typedef struct _DS3DBUFFER
{
    DWORD           dwSize;
    D3DVECTOR       vPosition;
    D3DVECTOR       vVelocity;
    DWORD           dwInsideConeAngle;
    DWORD           dwOutsideConeAngle;
    D3DVECTOR       vConeOrientation;
    LONG            lConeOutsideVolume;
    D3DVALUE        flMinDistance;
    D3DVALUE        flMaxDistance;
    DWORD           dwMode;
} DS3DBUFFER, *LPDS3DBUFFER;

typedef const DS3DBUFFER *LPCDS3DBUFFER;

typedef struct _DS3DLISTENER
{
    DWORD           dwSize;
    D3DVECTOR       vPosition;
    D3DVECTOR       vVelocity;
    D3DVECTOR       vOrientFront;
    D3DVECTOR       vOrientTop;
    D3DVALUE        flDistanceFactor;
    D3DVALUE        flRolloffFactor;
    D3DVALUE        flDopplerFactor;
} DS3DLISTENER, *LPDS3DLISTENER;

typedef const DS3DLISTENER *LPCDS3DLISTENER;

typedef struct _DSCCAPS
{
    DWORD           dwSize;
    DWORD           dwFlags;
    DWORD           dwFormats;
    DWORD           dwChannels;
} DSCCAPS, *LPDSCCAPS;

typedef const DSCCAPS *LPCDSCCAPS;

typedef struct _DSCBUFFERDESC1
{
    DWORD           dwSize;
    DWORD           dwFlags;
    DWORD           dwBufferBytes;
    DWORD           dwReserved;
    LPWAVEFORMATEX  lpwfxFormat;
} DSCBUFFERDESC1, *LPDSCBUFFERDESC1;

typedef struct _DSCBUFFERDESC
{
    DWORD           dwSize;
    DWORD           dwFlags;
    DWORD           dwBufferBytes;
    DWORD           dwReserved;
    LPWAVEFORMATEX  lpwfxFormat;
#if DIRECTSOUND_VERSION >= 0x0800
    DWORD           dwFXCount;
    LPDSCEFFECTDESC lpDSCFXDesc;
#endif
} DSCBUFFERDESC, *LPDSCBUFFERDESC;

typedef const DSCBUFFERDESC *LPCDSCBUFFERDESC;

typedef struct _DSCBCAPS
{
    DWORD           dwSize;
    DWORD           dwFlags;
    DWORD           dwBufferBytes;
    DWORD           dwReserved;
} DSCBCAPS, *LPDSCBCAPS;

typedef const DSCBCAPS *LPCDSCBCAPS;

typedef struct _DSBPOSITIONNOTIFY
{
    DWORD           dwOffset;
    HANDLE          hEventNotify;
} DSBPOSITIONNOTIFY, *LPDSBPOSITIONNOTIFY;

typedef const DSBPOSITIONNOTIFY *LPCDSBPOSITIONNOTIFY;

//
// DirectSound API
//

typedef BOOL (CALLBACK *LPDSENUMCALLBACKA)(LPGUID, LPCSTR, LPCSTR, LPVOID);
typedef BOOL (CALLBACK *LPDSENUMCALLBACKW)(LPGUID, LPCWSTR, LPCWSTR, LPVOID);

extern HRESULT WINAPI DirectSoundCreate(LPCGUID pcGuidDevice, LPDIRECTSOUND *ppDS, LPUNKNOWN pUnkOuter);
extern HRESULT WINAPI DirectSoundEnumerateA(LPDSENUMCALLBACKA pDSEnumCallback, LPVOID pContext);
extern HRESULT WINAPI DirectSoundEnumerateW(LPDSENUMCALLBACKW pDSEnumCallback, LPVOID pContext);

extern HRESULT WINAPI DirectSoundCaptureCreate(LPCGUID pcGuidDevice, LPDIRECTSOUNDCAPTURE *ppDSC, LPUNKNOWN pUnkOuter);
extern HRESULT WINAPI DirectSoundCaptureEnumerateA(LPDSENUMCALLBACKA pDSEnumCallback, LPVOID pContext);
extern HRESULT WINAPI DirectSoundCaptureEnumerateW(LPDSENUMCALLBACKW pDSEnumCallback, LPVOID pContext);

#if DIRECTSOUND_VERSION >= 0x0800
extern HRESULT WINAPI DirectSoundCreate8(LPCGUID pcGuidDevice, LPDIRECTSOUND8 *ppDS8, LPUNKNOWN pUnkOuter);
extern HRESULT WINAPI DirectSoundCaptureCreate8(LPCGUID pcGuidDevice, LPDIRECTSOUNDCAPTURE8 *ppDSC8, LPUNKNOWN pUnkOuter);
extern HRESULT WINAPI DirectSoundFullDuplexCreate(LPCGUID pcGuidCaptureDevice, LPCGUID pcGuidRenderDevice,
        LPCDSCBUFFERDESC pcDSCBufferDesc, LPCDSBUFFERDESC pcDSBufferDesc, HWND hWnd,
        DWORD dwLevel, LPDIRECTSOUNDFULLDUPLEX* ppDSFD, LPDIRECTSOUNDCAPTUREBUFFER8 *ppDSCBuffer8,
        LPDIRECTSOUNDBUFFER8 *ppDSBuffer8, LPUNKNOWN pUnkOuter);
#define DirectSoundFullDuplexCreate8 DirectSoundFullDuplexCreate

extern HRESULT WINAPI GetDeviceID(LPCGUID pGuidSrc, LPGUID pGuidDest);
#endif // DIRECTSOUND_VERSION >= 0x0800

#ifdef UNICODE
#define LPDSENUMCALLBACK            LPDSENUMCALLBACKW
#define DirectSoundEnumerate        DirectSoundEnumerateW
#define DirectSoundCaptureEnumerate DirectSoundCaptureEnumerateW
#else // UNICODE
#define LPDSENUMCALLBACK            LPDSENUMCALLBACKA
#define DirectSoundEnumerate        DirectSoundEnumerateA
#define DirectSoundCaptureEnumerate DirectSoundCaptureEnumerateA
#endif // UNICODE

//
// IUnknown
//

#if !defined(__cplusplus) || defined(CINTERFACE)
#ifndef IUnknown_QueryInterface
#define IUnknown_QueryInterface(p,a,b)  (p)->lpVtbl->QueryInterface(p,a,b)
#endif // IUnknown_QueryInterface
#ifndef IUnknown_AddRef
#define IUnknown_AddRef(p)              (p)->lpVtbl->AddRef(p)
#endif // IUnknown_AddRef
#ifndef IUnknown_Release
#define IUnknown_Release(p)             (p)->lpVtbl->Release(p)
#endif // IUnknown_Release
#else // !defined(__cplusplus) || defined(CINTERFACE)
#ifndef IUnknown_QueryInterface
#define IUnknown_QueryInterface(p,a,b)  (p)->QueryInterface(a,b)
#endif // IUnknown_QueryInterface
#ifndef IUnknown_AddRef
#define IUnknown_AddRef(p)              (p)->AddRef()
#endif // IUnknown_AddRef
#ifndef IUnknown_Release
#define IUnknown_Release(p)             (p)->Release()
#endif // IUnknown_Release
#endif // !defined(__cplusplus) || defined(CINTERFACE)

#ifndef __IReferenceClock_INTERFACE_DEFINED__
#define __IReferenceClock_INTERFACE_DEFINED__

typedef LONGLONG REFERENCE_TIME;
typedef REFERENCE_TIME *LPREFERENCE_TIME;

DEFINE_GUID(IID_IReferenceClock, 0x56a86897, 0x0ad4, 0x11ce, 0xb0, 0x3a, 0x00, 0x20, 0xaf, 0x0b, 0xa7, 0x70);

#undef INTERFACE
#define INTERFACE IReferenceClock

DECLARE_INTERFACE_(IReferenceClock, IUnknown)
{
    // IUnknown methods
    STDMETHOD(QueryInterface)       (THIS_ REFIID, LPVOID *) PURE;
    STDMETHOD_(ULONG,AddRef)        (THIS) PURE;
    STDMETHOD_(ULONG,Release)       (THIS) PURE;

    // IReferenceClock methods
    STDMETHOD(GetTime)              (THIS_ REFERENCE_TIME *pTime) PURE;
    STDMETHOD(AdviseTime)           (THIS_ REFERENCE_TIME rtBaseTime, REFERENCE_TIME rtStreamTime,
                                           HANDLE hEvent, LPDWORD pdwAdviseCookie) PURE;
    STDMETHOD(AdvisePeriodic)       (THIS_ REFERENCE_TIME rtStartTime, REFERENCE_TIME rtPeriodTime,
                                           HANDLE hSemaphore, LPDWORD pdwAdviseCookie) PURE;
    STDMETHOD(Unadvise)             (THIS_ DWORD dwAdviseCookie) PURE;
};

#endif // __IReferenceClock_INTERFACE_DEFINED__

#ifndef IReferenceClock_QueryInterface

#define IReferenceClock_QueryInterface(p,a,b)      IUnknown_QueryInterface(p,a,b)
#define IReferenceClock_AddRef(p)                  IUnknown_AddRef(p)
#define IReferenceClock_Release(p)                 IUnknown_Release(p)

#if !defined(__cplusplus) || defined(CINTERFACE)
#define IReferenceClock_GetTime(p,a)               (p)->lpVtbl->GetTime(p,a)
#define IReferenceClock_AdviseTime(p,a,b,c,d)      (p)->lpVtbl->AdviseTime(p,a,b,c,d)
#define IReferenceClock_AdvisePeriodic(p,a,b,c,d)  (p)->lpVtbl->AdvisePeriodic(p,a,b,c,d)
#define IReferenceClock_Unadvise(p,a)              (p)->lpVtbl->Unadvise(p,a)
#else // !defined(__cplusplus) || defined(CINTERFACE)
#define IReferenceClock_GetTime(p,a)               (p)->GetTime(a)
#define IReferenceClock_AdviseTime(p,a,b,c,d)      (p)->AdviseTime(a,b,c,d)
#define IReferenceClock_AdvisePeriodic(p,a,b,c,d)  (p)->AdvisePeriodic(a,b,c,d)
#define IReferenceClock_Unadvise(p,a)              (p)->Unadvise(a)
#endif // !defined(__cplusplus) || defined(CINTERFACE)

#endif // IReferenceClock_QueryInterface

//
// IDirectSound
//

DEFINE_GUID(IID_IDirectSound, 0x279AFA83, 0x4981, 0x11CE, 0xA5, 0x21, 0x00, 0x20, 0xAF, 0x0B, 0xE5, 0x60);

#undef INTERFACE
#define INTERFACE IDirectSound

DECLARE_INTERFACE_(IDirectSound, IUnknown)
{
    // IUnknown methods
    STDMETHOD(QueryInterface)       (THIS_ REFIID, LPVOID *) PURE;
    STDMETHOD_(ULONG,AddRef)        (THIS) PURE;
    STDMETHOD_(ULONG,Release)       (THIS) PURE;

    // IDirectSound methods
    STDMETHOD(CreateSoundBuffer)    (THIS_ LPCDSBUFFERDESC pcDSBufferDesc, LPDIRECTSOUNDBUFFER *ppDSBuffer, LPUNKNOWN pUnkOuter) PURE;
    STDMETHOD(GetCaps)              (THIS_ LPDSCAPS pDSCaps) PURE;
    STDMETHOD(DuplicateSoundBuffer) (THIS_ LPDIRECTSOUNDBUFFER pDSBufferOriginal, LPDIRECTSOUNDBUFFER *ppDSBufferDuplicate) PURE;
    STDMETHOD(SetCooperativeLevel)  (THIS_ HWND hwnd, DWORD dwLevel) PURE;
    STDMETHOD(Compact)              (THIS) PURE;
    STDMETHOD(GetSpeakerConfig)     (THIS_ LPDWORD pdwSpeakerConfig) PURE;
    STDMETHOD(SetSpeakerConfig)     (THIS_ DWORD dwSpeakerConfig) PURE;
    STDMETHOD(Initialize)           (THIS_ LPCGUID pcGuidDevice) PURE;
};

#define IDirectSound_QueryInterface(p,a,b)       IUnknown_QueryInterface(p,a,b)
#define IDirectSound_AddRef(p)                   IUnknown_AddRef(p)
#define IDirectSound_Release(p)                  IUnknown_Release(p)

#if !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectSound_CreateSoundBuffer(p,a,b,c)  (p)->lpVtbl->CreateSoundBuffer(p,a,b,c)
#define IDirectSound_GetCaps(p,a)                (p)->lpVtbl->GetCaps(p,a)
#define IDirectSound_DuplicateSoundBuffer(p,a,b) (p)->lpVtbl->DuplicateSoundBuffer(p,a,b)
#define IDirectSound_SetCooperativeLevel(p,a,b)  (p)->lpVtbl->SetCooperativeLevel(p,a,b)
#define IDirectSound_Compact(p)                  (p)->lpVtbl->Compact(p)
#define IDirectSound_GetSpeakerConfig(p,a)       (p)->lpVtbl->GetSpeakerConfig(p,a)
#define IDirectSound_SetSpeakerConfig(p,b)       (p)->lpVtbl->SetSpeakerConfig(p,b)
#define IDirectSound_Initialize(p,a)             (p)->lpVtbl->Initialize(p,a)
#else // !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectSound_CreateSoundBuffer(p,a,b,c)  (p)->CreateSoundBuffer(a,b,c)
#define IDirectSound_GetCaps(p,a)                (p)->GetCaps(a)
#define IDirectSound_DuplicateSoundBuffer(p,a,b) (p)->DuplicateSoundBuffer(a,b)
#define IDirectSound_SetCooperativeLevel(p,a,b)  (p)->SetCooperativeLevel(a,b)
#define IDirectSound_Compact(p)                  (p)->Compact()
#define IDirectSound_GetSpeakerConfig(p,a)       (p)->GetSpeakerConfig(a)
#define IDirectSound_SetSpeakerConfig(p,b)       (p)->SetSpeakerConfig(b)
#define IDirectSound_Initialize(p,a)             (p)->Initialize(a)
#endif // !defined(__cplusplus) || defined(CINTERFACE)

#if DIRECTSOUND_VERSION >= 0x0800

//
// IDirectSound8
//

DEFINE_GUID(IID_IDirectSound8, 0xC50A7E93, 0xF395, 0x4834, 0x9E, 0xF6, 0x7F, 0xA9, 0x9D, 0xE5, 0x09, 0x66);

#undef INTERFACE
#define INTERFACE IDirectSound8

DECLARE_INTERFACE_(IDirectSound8, IDirectSound)
{
    // IUnknown methods
    STDMETHOD(QueryInterface)       (THIS_ REFIID, LPVOID *) PURE;
    STDMETHOD_(ULONG,AddRef)        (THIS) PURE;
    STDMETHOD_(ULONG,Release)       (THIS) PURE;

    // IDirectSound methods
    STDMETHOD(CreateSoundBuffer)    (THIS_ LPCDSBUFFERDESC pcDSBufferDesc, LPDIRECTSOUNDBUFFER *ppDSBuffer, LPUNKNOWN pUnkOuter) PURE;
    STDMETHOD(GetCaps)              (THIS_ LPDSCAPS pDSCaps) PURE;
    STDMETHOD(DuplicateSoundBuffer) (THIS_ LPDIRECTSOUNDBUFFER pDSBufferOriginal, LPDIRECTSOUNDBUFFER *ppDSBufferDuplicate) PURE;
    STDMETHOD(SetCooperativeLevel)  (THIS_ HWND hwnd, DWORD dwLevel) PURE;
    STDMETHOD(Compact)              (THIS) PURE;
    STDMETHOD(GetSpeakerConfig)     (THIS_ LPDWORD pdwSpeakerConfig) PURE;
    STDMETHOD(SetSpeakerConfig)     (THIS_ DWORD dwSpeakerConfig) PURE;
    STDMETHOD(Initialize)           (THIS_ LPCGUID pcGuidDevice) PURE;

    // IDirectSound8 methods
    STDMETHOD(VerifyCertification)  (THIS_ LPDWORD pdwCertified) PURE;
//@@BEGIN_MSINTERNAL
#ifdef FUTURE_WAVE_SUPPORT
    STDMETHOD(CreateSoundBufferFromWave) (THIS_ LPUNKNOWN pDSWave, DWORD dwFlags, LPDIRECTSOUNDBUFFER *ppDSBuffer) PURE;
#endif
//@@END_MSINTERNAL
};

#define IDirectSound8_QueryInterface(p,a,b)       IDirectSound_QueryInterface(p,a,b)
#define IDirectSound8_AddRef(p)                   IDirectSound_AddRef(p)
#define IDirectSound8_Release(p)                  IDirectSound_Release(p)
#define IDirectSound8_CreateSoundBuffer(p,a,b,c)  IDirectSound_CreateSoundBuffer(p,a,b,c)
#define IDirectSound8_GetCaps(p,a)                IDirectSound_GetCaps(p,a)
#define IDirectSound8_DuplicateSoundBuffer(p,a,b) IDirectSound_DuplicateSoundBuffer(p,a,b)
#define IDirectSound8_SetCooperativeLevel(p,a,b)  IDirectSound_SetCooperativeLevel(p,a,b)
#define IDirectSound8_Compact(p)                  IDirectSound_Compact(p)
#define IDirectSound8_GetSpeakerConfig(p,a)       IDirectSound_GetSpeakerConfig(p,a)
#define IDirectSound8_SetSpeakerConfig(p,a)       IDirectSound_SetSpeakerConfig(p,a)
#define IDirectSound8_Initialize(p,a)             IDirectSound_Initialize(p,a)

#if !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectSound8_VerifyCertification(p,a)           (p)->lpVtbl->VerifyCertification(p,a)
//@@BEGIN_MSINTERNAL
#ifdef FUTURE_WAVE_SUPPORT
#define IDirectSound8_CreateSoundBufferFromWave(p,a,b,c) (p)->lpVtbl->CreateSoundBufferFromWave(p,a,b,c)
#endif
//@@END_MSINTERNAL
#else // !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectSound8_VerifyCertification(p,a)           (p)->VerifyCertification(a)
//@@BEGIN_MSINTERNAL
#ifdef FUTURE_WAVE_SUPPORT
#define IDirectSound8_CreateSoundBufferFromWave(p,a,b,c) (p)->CreateSoundBufferFromWave(a,b,c)
#endif
//@@END_MSINTERNAL
#endif // !defined(__cplusplus) || defined(CINTERFACE)

#endif // DIRECTSOUND_VERSION >= 0x0800

//
// IDirectSoundBuffer
//

DEFINE_GUID(IID_IDirectSoundBuffer, 0x279AFA85, 0x4981, 0x11CE, 0xA5, 0x21, 0x00, 0x20, 0xAF, 0x0B, 0xE5, 0x60);

#undef INTERFACE
#define INTERFACE IDirectSoundBuffer

DECLARE_INTERFACE_(IDirectSoundBuffer, IUnknown)
{
    // IUnknown methods
    STDMETHOD(QueryInterface)       (THIS_ REFIID, LPVOID *) PURE;
    STDMETHOD_(ULONG,AddRef)        (THIS) PURE;
    STDMETHOD_(ULONG,Release)       (THIS) PURE;

    // IDirectSoundBuffer methods
    STDMETHOD(GetCaps)              (THIS_ LPDSBCAPS pDSBufferCaps) PURE;
    STDMETHOD(GetCurrentPosition)   (THIS_ LPDWORD pdwCurrentPlayCursor, LPDWORD pdwCurrentWriteCursor) PURE;
    STDMETHOD(GetFormat)            (THIS_ LPWAVEFORMATEX pwfxFormat, DWORD dwSizeAllocated, LPDWORD pdwSizeWritten) PURE;
    STDMETHOD(GetVolume)            (THIS_ LPLONG plVolume) PURE;
    STDMETHOD(GetPan)               (THIS_ LPLONG plPan) PURE;
    STDMETHOD(GetFrequency)         (THIS_ LPDWORD pdwFrequency) PURE;
    STDMETHOD(GetStatus)            (THIS_ LPDWORD pdwStatus) PURE;
    STDMETHOD(Initialize)           (THIS_ LPDIRECTSOUND pDirectSound, LPCDSBUFFERDESC pcDSBufferDesc) PURE;
    STDMETHOD(Lock)                 (THIS_ DWORD dwOffset, DWORD dwBytes, LPVOID *ppvAudioPtr1, LPDWORD pdwAudioBytes1,
                                           LPVOID *ppvAudioPtr2, LPDWORD pdwAudioBytes2, DWORD dwFlags) PURE;
    STDMETHOD(Play)                 (THIS_ DWORD dwReserved1, DWORD dwPriority, DWORD dwFlags) PURE;
    STDMETHOD(SetCurrentPosition)   (THIS_ DWORD dwNewPosition) PURE;
    STDMETHOD(SetFormat)            (THIS_ LPCWAVEFORMATEX pcfxFormat) PURE;
    STDMETHOD(SetVolume)            (THIS_ LONG lVolume) PURE;
    STDMETHOD(SetPan)               (THIS_ LONG lPan) PURE;
    STDMETHOD(SetFrequency)         (THIS_ DWORD dwFrequency) PURE;
    STDMETHOD(Stop)                 (THIS) PURE;
    STDMETHOD(Unlock)               (THIS_ LPVOID pvAudioPtr1, DWORD dwAudioBytes1, LPVOID pvAudioPtr2, DWORD dwAudioBytes2) PURE;
    STDMETHOD(Restore)              (THIS) PURE;
};

#define IDirectSoundBuffer_QueryInterface(p,a,b)        IUnknown_QueryInterface(p,a,b)
#define IDirectSoundBuffer_AddRef(p)                    IUnknown_AddRef(p)
#define IDirectSoundBuffer_Release(p)                   IUnknown_Release(p)

#if !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectSoundBuffer_GetCaps(p,a)                 (p)->lpVtbl->GetCaps(p,a)
#define IDirectSoundBuffer_GetCurrentPosition(p,a,b)    (p)->lpVtbl->GetCurrentPosition(p,a,b)
#define IDirectSoundBuffer_GetFormat(p,a,b,c)           (p)->lpVtbl->GetFormat(p,a,b,c)
#define IDirectSoundBuffer_GetVolume(p,a)               (p)->lpVtbl->GetVolume(p,a)
#define IDirectSoundBuffer_GetPan(p,a)                  (p)->lpVtbl->GetPan(p,a)
#define IDirectSoundBuffer_GetFrequency(p,a)            (p)->lpVtbl->GetFrequency(p,a)
#define IDirectSoundBuffer_GetStatus(p,a)               (p)->lpVtbl->GetStatus(p,a)
#define IDirectSoundBuffer_Initialize(p,a,b)            (p)->lpVtbl->Initialize(p,a,b)
#define IDirectSoundBuffer_Lock(p,a,b,c,d,e,f,g)        (p)->lpVtbl->Lock(p,a,b,c,d,e,f,g)
#define IDirectSoundBuffer_Play(p,a,b,c)                (p)->lpVtbl->Play(p,a,b,c)
#define IDirectSoundBuffer_SetCurrentPosition(p,a)      (p)->lpVtbl->SetCurrentPosition(p,a)
#define IDirectSoundBuffer_SetFormat(p,a)               (p)->lpVtbl->SetFormat(p,a)
#define IDirectSoundBuffer_SetVolume(p,a)               (p)->lpVtbl->SetVolume(p,a)
#define IDirectSoundBuffer_SetPan(p,a)                  (p)->lpVtbl->SetPan(p,a)
#define IDirectSoundBuffer_SetFrequency(p,a)            (p)->lpVtbl->SetFrequency(p,a)
#define IDirectSoundBuffer_Stop(p)                      (p)->lpVtbl->Stop(p)
#define IDirectSoundBuffer_Unlock(p,a,b,c,d)            (p)->lpVtbl->Unlock(p,a,b,c,d)
#define IDirectSoundBuffer_Restore(p)                   (p)->lpVtbl->Restore(p)
#else // !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectSoundBuffer_GetCaps(p,a)                 (p)->GetCaps(a)
#define IDirectSoundBuffer_GetCurrentPosition(p,a,b)    (p)->GetCurrentPosition(a,b)
#define IDirectSoundBuffer_GetFormat(p,a,b,c)           (p)->GetFormat(a,b,c)
#define IDirectSoundBuffer_GetVolume(p,a)               (p)->GetVolume(a)
#define IDirectSoundBuffer_GetPan(p,a)                  (p)->GetPan(a)
#define IDirectSoundBuffer_GetFrequency(p,a)            (p)->GetFrequency(a)
#define IDirectSoundBuffer_GetStatus(p,a)               (p)->GetStatus(a)
#define IDirectSoundBuffer_Initialize(p,a,b)            (p)->Initialize(a,b)
#define IDirectSoundBuffer_Lock(p,a,b,c,d,e,f,g)        (p)->Lock(a,b,c,d,e,f,g)
#define IDirectSoundBuffer_Play(p,a,b,c)                (p)->Play(a,b,c)
#define IDirectSoundBuffer_SetCurrentPosition(p,a)      (p)->SetCurrentPosition(a)
#define IDirectSoundBuffer_SetFormat(p,a)               (p)->SetFormat(a)
#define IDirectSoundBuffer_SetVolume(p,a)               (p)->SetVolume(a)
#define IDirectSoundBuffer_SetPan(p,a)                  (p)->SetPan(a)
#define IDirectSoundBuffer_SetFrequency(p,a)            (p)->SetFrequency(a)
#define IDirectSoundBuffer_Stop(p)                      (p)->Stop()
#define IDirectSoundBuffer_Unlock(p,a,b,c,d)            (p)->Unlock(a,b,c,d)
#define IDirectSoundBuffer_Restore(p)                   (p)->Restore()
#endif // !defined(__cplusplus) || defined(CINTERFACE)

#if DIRECTSOUND_VERSION >= 0x0800

//
// IDirectSoundBuffer8
//

DEFINE_GUID(IID_IDirectSoundBuffer8, 0x6825a449, 0x7524, 0x4d82, 0x92, 0x0f, 0x50, 0xe3, 0x6a, 0xb3, 0xab, 0x1e);

#undef INTERFACE
#define INTERFACE IDirectSoundBuffer8

DECLARE_INTERFACE_(IDirectSoundBuffer8, IDirectSoundBuffer)
{
    // IUnknown methods
    STDMETHOD(QueryInterface)       (THIS_ REFIID, LPVOID *) PURE;
    STDMETHOD_(ULONG,AddRef)        (THIS) PURE;
    STDMETHOD_(ULONG,Release)       (THIS) PURE;

    // IDirectSoundBuffer methods
    STDMETHOD(GetCaps)              (THIS_ LPDSBCAPS pDSBufferCaps) PURE;
    STDMETHOD(GetCurrentPosition)   (THIS_ LPDWORD pdwCurrentPlayCursor, LPDWORD pdwCurrentWriteCursor) PURE;
    STDMETHOD(GetFormat)            (THIS_ LPWAVEFORMATEX pwfxFormat, DWORD dwSizeAllocated, LPDWORD pdwSizeWritten) PURE;
    STDMETHOD(GetVolume)            (THIS_ LPLONG plVolume) PURE;
    STDMETHOD(GetPan)               (THIS_ LPLONG plPan) PURE;
    STDMETHOD(GetFrequency)         (THIS_ LPDWORD pdwFrequency) PURE;
    STDMETHOD(GetStatus)            (THIS_ LPDWORD pdwStatus) PURE;
    STDMETHOD(Initialize)           (THIS_ LPDIRECTSOUND pDirectSound, LPCDSBUFFERDESC pcDSBufferDesc) PURE;
    STDMETHOD(Lock)                 (THIS_ DWORD dwOffset, DWORD dwBytes, LPVOID *ppvAudioPtr1, LPDWORD pdwAudioBytes1,
                                           LPVOID *ppvAudioPtr2, LPDWORD pdwAudioBytes2, DWORD dwFlags) PURE;
    STDMETHOD(Play)                 (THIS_ DWORD dwReserved1, DWORD dwPriority, DWORD dwFlags) PURE;
    STDMETHOD(SetCurrentPosition)   (THIS_ DWORD dwNewPosition) PURE;
    STDMETHOD(SetFormat)            (THIS_ LPCWAVEFORMATEX pcfxFormat) PURE;
    STDMETHOD(SetVolume)            (THIS_ LONG lVolume) PURE;
    STDMETHOD(SetPan)               (THIS_ LONG lPan) PURE;
    STDMETHOD(SetFrequency)         (THIS_ DWORD dwFrequency) PURE;
    STDMETHOD(Stop)                 (THIS) PURE;
    STDMETHOD(Unlock)               (THIS_ LPVOID pvAudioPtr1, DWORD dwAudioBytes1, LPVOID pvAudioPtr2, DWORD dwAudioBytes2) PURE;
    STDMETHOD(Restore)              (THIS) PURE;

    // IDirectSoundBuffer8 methods
    STDMETHOD(SetFX)                (THIS_ DWORD dwEffectsCount, LPDSEFFECTDESC pDSFXDesc, LPDWORD pdwResultCodes) PURE;
    STDMETHOD(AcquireResources)     (THIS_ DWORD dwFlags, DWORD dwEffectsCount, LPDWORD pdwResultCodes) PURE;
    STDMETHOD(GetObjectInPath)      (THIS_ REFGUID rguidObject, DWORD dwIndex, REFGUID rguidInterface, LPVOID *ppObject) PURE;
//@@BEGIN_MSINTERNAL
#ifdef FUTURE_MULTIPAN_SUPPORT
    STDMETHOD(SetChannelVolume)     (THIS_ DWORD dwChannelCount, LPDWORD pdwChannels, LPLONG plVolumes) PURE;
#endif
//@@END_MSINTERNAL
};

// Special GUID meaning "select all objects" for use in GetObjectInPath()
DEFINE_GUID(GUID_All_Objects, 0xaa114de5, 0xc262, 0x4169, 0xa1, 0xc8, 0x23, 0xd6, 0x98, 0xcc, 0x73, 0xb5);

#define IDirectSoundBuffer8_QueryInterface(p,a,b)           IUnknown_QueryInterface(p,a,b)
#define IDirectSoundBuffer8_AddRef(p)                       IUnknown_AddRef(p)
#define IDirectSoundBuffer8_Release(p)                      IUnknown_Release(p)

#define IDirectSoundBuffer8_GetCaps(p,a)                    IDirectSoundBuffer_GetCaps(p,a)
#define IDirectSoundBuffer8_GetCurrentPosition(p,a,b)       IDirectSoundBuffer_GetCurrentPosition(p,a,b)
#define IDirectSoundBuffer8_GetFormat(p,a,b,c)              IDirectSoundBuffer_GetFormat(p,a,b,c)
#define IDirectSoundBuffer8_GetVolume(p,a)                  IDirectSoundBuffer_GetVolume(p,a)
#define IDirectSoundBuffer8_GetPan(p,a)                     IDirectSoundBuffer_GetPan(p,a)
#define IDirectSoundBuffer8_GetFrequency(p,a)               IDirectSoundBuffer_GetFrequency(p,a)
#define IDirectSoundBuffer8_GetStatus(p,a)                  IDirectSoundBuffer_GetStatus(p,a)
#define IDirectSoundBuffer8_Initialize(p,a,b)               IDirectSoundBuffer_Initialize(p,a,b)
#define IDirectSoundBuffer8_Lock(p,a,b,c,d,e,f,g)           IDirectSoundBuffer_Lock(p,a,b,c,d,e,f,g)
#define IDirectSoundBuffer8_Play(p,a,b,c)                   IDirectSoundBuffer_Play(p,a,b,c)
#define IDirectSoundBuffer8_SetCurrentPosition(p,a)         IDirectSoundBuffer_SetCurrentPosition(p,a)
#define IDirectSoundBuffer8_SetFormat(p,a)                  IDirectSoundBuffer_SetFormat(p,a)
#define IDirectSoundBuffer8_SetVolume(p,a)                  IDirectSoundBuffer_SetVolume(p,a)
#define IDirectSoundBuffer8_SetPan(p,a)                     IDirectSoundBuffer_SetPan(p,a)
#define IDirectSoundBuffer8_SetFrequency(p,a)               IDirectSoundBuffer_SetFrequency(p,a)
#define IDirectSoundBuffer8_Stop(p)                         IDirectSoundBuffer_Stop(p)
#define IDirectSoundBuffer8_Unlock(p,a,b,c,d)               IDirectSoundBuffer_Unlock(p,a,b,c,d)
#define IDirectSoundBuffer8_Restore(p)                      IDirectSoundBuffer_Restore(p)

#if !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectSoundBuffer8_SetFX(p,a,b,c)                  (p)->lpVtbl->SetFX(p,a,b,c)
#define IDirectSoundBuffer8_AcquireResources(p,a,b,c)       (p)->lpVtbl->AcquireResources(p,a,b,c)
#define IDirectSoundBuffer8_GetObjectInPath(p,a,b,c,d)      (p)->lpVtbl->GetObjectInPath(p,a,b,c,d)
#else // !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectSoundBuffer8_SetFX(p,a,b,c)                  (p)->SetFX(a,b,c)
#define IDirectSoundBuffer8_AcquireResources(p,a,b,c)       (p)->AcquireResources(a,b,c)
#define IDirectSoundBuffer8_GetObjectInPath(p,a,b,c,d)      (p)->GetObjectInPath(a,b,c,d)
#endif // !defined(__cplusplus) || defined(CINTERFACE)

#endif // DIRECTSOUND_VERSION >= 0x0800

//
// IDirectSound3DListener
//

DEFINE_GUID(IID_IDirectSound3DListener, 0x279AFA84, 0x4981, 0x11CE, 0xA5, 0x21, 0x00, 0x20, 0xAF, 0x0B, 0xE5, 0x60);

#undef INTERFACE
#define INTERFACE IDirectSound3DListener

DECLARE_INTERFACE_(IDirectSound3DListener, IUnknown)
{
    // IUnknown methods
    STDMETHOD(QueryInterface)           (THIS_ REFIID, LPVOID *) PURE;
    STDMETHOD_(ULONG,AddRef)            (THIS) PURE;
    STDMETHOD_(ULONG,Release)           (THIS) PURE;

    // IDirectSound3DListener methods
    STDMETHOD(GetAllParameters)         (THIS_ LPDS3DLISTENER pListener) PURE;
    STDMETHOD(GetDistanceFactor)        (THIS_ D3DVALUE* pflDistanceFactor) PURE;
    STDMETHOD(GetDopplerFactor)         (THIS_ D3DVALUE* pflDopplerFactor) PURE;
    STDMETHOD(GetOrientation)           (THIS_ D3DVECTOR* pvOrientFront, D3DVECTOR* pvOrientTop) PURE;
    STDMETHOD(GetPosition)              (THIS_ D3DVECTOR* pvPosition) PURE;
    STDMETHOD(GetRolloffFactor)         (THIS_ D3DVALUE* pflRolloffFactor) PURE;
    STDMETHOD(GetVelocity)              (THIS_ D3DVECTOR* pvVelocity) PURE;
    STDMETHOD(SetAllParameters)         (THIS_ LPCDS3DLISTENER pcListener, DWORD dwApply) PURE;
    STDMETHOD(SetDistanceFactor)        (THIS_ D3DVALUE flDistanceFactor, DWORD dwApply) PURE;
    STDMETHOD(SetDopplerFactor)         (THIS_ D3DVALUE flDopplerFactor, DWORD dwApply) PURE;
    STDMETHOD(SetOrientation)           (THIS_ D3DVALUE xFront, D3DVALUE yFront, D3DVALUE zFront,
                                               D3DVALUE xTop, D3DVALUE yTop, D3DVALUE zTop, DWORD dwApply) PURE;
    STDMETHOD(SetPosition)              (THIS_ D3DVALUE x, D3DVALUE y, D3DVALUE z, DWORD dwApply) PURE;
    STDMETHOD(SetRolloffFactor)         (THIS_ D3DVALUE flRolloffFactor, DWORD dwApply) PURE;
    STDMETHOD(SetVelocity)              (THIS_ D3DVALUE x, D3DVALUE y, D3DVALUE z, DWORD dwApply) PURE;
    STDMETHOD(CommitDeferredSettings)   (THIS) PURE;
};

#define IDirectSound3DListener_QueryInterface(p,a,b)            IUnknown_QueryInterface(p,a,b)
#define IDirectSound3DListener_AddRef(p)                        IUnknown_AddRef(p)
#define IDirectSound3DListener_Release(p)                       IUnknown_Release(p)

#if !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectSound3DListener_GetAllParameters(p,a)            (p)->lpVtbl->GetAllParameters(p,a)
#define IDirectSound3DListener_GetDistanceFactor(p,a)           (p)->lpVtbl->GetDistanceFactor(p,a)
#define IDirectSound3DListener_GetDopplerFactor(p,a)            (p)->lpVtbl->GetDopplerFactor(p,a)
#define IDirectSound3DListener_GetOrientation(p,a,b)            (p)->lpVtbl->GetOrientation(p,a,b)
#define IDirectSound3DListener_GetPosition(p,a)                 (p)->lpVtbl->GetPosition(p,a)
#define IDirectSound3DListener_GetRolloffFactor(p,a)            (p)->lpVtbl->GetRolloffFactor(p,a)
#define IDirectSound3DListener_GetVelocity(p,a)                 (p)->lpVtbl->GetVelocity(p,a)
#define IDirectSound3DListener_SetAllParameters(p,a,b)          (p)->lpVtbl->SetAllParameters(p,a,b)
#define IDirectSound3DListener_SetDistanceFactor(p,a,b)         (p)->lpVtbl->SetDistanceFactor(p,a,b)
#define IDirectSound3DListener_SetDopplerFactor(p,a,b)          (p)->lpVtbl->SetDopplerFactor(p,a,b)
#define IDirectSound3DListener_SetOrientation(p,a,b,c,d,e,f,g)  (p)->lpVtbl->SetOrientation(p,a,b,c,d,e,f,g)
#define IDirectSound3DListener_SetPosition(p,a,b,c,d)           (p)->lpVtbl->SetPosition(p,a,b,c,d)
#define IDirectSound3DListener_SetRolloffFactor(p,a,b)          (p)->lpVtbl->SetRolloffFactor(p,a,b)
#define IDirectSound3DListener_SetVelocity(p,a,b,c,d)           (p)->lpVtbl->SetVelocity(p,a,b,c,d)
#define IDirectSound3DListener_CommitDeferredSettings(p)        (p)->lpVtbl->CommitDeferredSettings(p)
#else // !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectSound3DListener_GetAllParameters(p,a)            (p)->GetAllParameters(a)
#define IDirectSound3DListener_GetDistanceFactor(p,a)           (p)->GetDistanceFactor(a)
#define IDirectSound3DListener_GetDopplerFactor(p,a)            (p)->GetDopplerFactor(a)
#define IDirectSound3DListener_GetOrientation(p,a,b)            (p)->GetOrientation(a,b)
#define IDirectSound3DListener_GetPosition(p,a)                 (p)->GetPosition(a)
#define IDirectSound3DListener_GetRolloffFactor(p,a)            (p)->GetRolloffFactor(a)
#define IDirectSound3DListener_GetVelocity(p,a)                 (p)->GetVelocity(a)
#define IDirectSound3DListener_SetAllParameters(p,a,b)          (p)->SetAllParameters(a,b)
#define IDirectSound3DListener_SetDistanceFactor(p,a,b)         (p)->SetDistanceFactor(a,b)
#define IDirectSound3DListener_SetDopplerFactor(p,a,b)          (p)->SetDopplerFactor(a,b)
#define IDirectSound3DListener_SetOrientation(p,a,b,c,d,e,f,g)  (p)->SetOrientation(a,b,c,d,e,f,g)
#define IDirectSound3DListener_SetPosition(p,a,b,c,d)           (p)->SetPosition(a,b,c,d)
#define IDirectSound3DListener_SetRolloffFactor(p,a,b)          (p)->SetRolloffFactor(a,b)
#define IDirectSound3DListener_SetVelocity(p,a,b,c,d)           (p)->SetVelocity(a,b,c,d)
#define IDirectSound3DListener_CommitDeferredSettings(p)        (p)->CommitDeferredSettings()
#endif // !defined(__cplusplus) || defined(CINTERFACE)

//
// IDirectSound3DBuffer
//

DEFINE_GUID(IID_IDirectSound3DBuffer, 0x279AFA86, 0x4981, 0x11CE, 0xA5, 0x21, 0x00, 0x20, 0xAF, 0x0B, 0xE5, 0x60);

#undef INTERFACE
#define INTERFACE IDirectSound3DBuffer

DECLARE_INTERFACE_(IDirectSound3DBuffer, IUnknown)
{
    // IUnknown methods
    STDMETHOD(QueryInterface)       (THIS_ REFIID, LPVOID *) PURE;
    STDMETHOD_(ULONG,AddRef)        (THIS) PURE;
    STDMETHOD_(ULONG,Release)       (THIS) PURE;

    // IDirectSound3DBuffer methods
    STDMETHOD(GetAllParameters)     (THIS_ LPDS3DBUFFER pDs3dBuffer) PURE;
    STDMETHOD(GetConeAngles)        (THIS_ LPDWORD pdwInsideConeAngle, LPDWORD pdwOutsideConeAngle) PURE;
    STDMETHOD(GetConeOrientation)   (THIS_ D3DVECTOR* pvOrientation) PURE;
    STDMETHOD(GetConeOutsideVolume) (THIS_ LPLONG plConeOutsideVolume) PURE;
    STDMETHOD(GetMaxDistance)       (THIS_ D3DVALUE* pflMaxDistance) PURE;
    STDMETHOD(GetMinDistance)       (THIS_ D3DVALUE* pflMinDistance) PURE;
    STDMETHOD(GetMode)              (THIS_ LPDWORD pdwMode) PURE;
    STDMETHOD(GetPosition)          (THIS_ D3DVECTOR* pvPosition) PURE;
    STDMETHOD(GetVelocity)          (THIS_ D3DVECTOR* pvVelocity) PURE;
    STDMETHOD(SetAllParameters)     (THIS_ LPCDS3DBUFFER pcDs3dBuffer, DWORD dwApply) PURE;
    STDMETHOD(SetConeAngles)        (THIS_ DWORD dwInsideConeAngle, DWORD dwOutsideConeAngle, DWORD dwApply) PURE;
    STDMETHOD(SetConeOrientation)   (THIS_ D3DVALUE x, D3DVALUE y, D3DVALUE z, DWORD dwApply) PURE;
    STDMETHOD(SetConeOutsideVolume) (THIS_ LONG lConeOutsideVolume, DWORD dwApply) PURE;
    STDMETHOD(SetMaxDistance)       (THIS_ D3DVALUE flMaxDistance, DWORD dwApply) PURE;
    STDMETHOD(SetMinDistance)       (THIS_ D3DVALUE flMinDistance, DWORD dwApply) PURE;
    STDMETHOD(SetMode)              (THIS_ DWORD dwMode, DWORD dwApply) PURE;
    STDMETHOD(SetPosition)          (THIS_ D3DVALUE x, D3DVALUE y, D3DVALUE z, DWORD dwApply) PURE;
    STDMETHOD(SetVelocity)          (THIS_ D3DVALUE x, D3DVALUE y, D3DVALUE z, DWORD dwApply) PURE;
};

#define IDirectSound3DBuffer_QueryInterface(p,a,b)          IUnknown_QueryInterface(p,a,b)
#define IDirectSound3DBuffer_AddRef(p)                      IUnknown_AddRef(p)
#define IDirectSound3DBuffer_Release(p)                     IUnknown_Release(p)

#if !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectSound3DBuffer_GetAllParameters(p,a)          (p)->lpVtbl->GetAllParameters(p,a)
#define IDirectSound3DBuffer_GetConeAngles(p,a,b)           (p)->lpVtbl->GetConeAngles(p,a,b)
#define IDirectSound3DBuffer_GetConeOrientation(p,a)        (p)->lpVtbl->GetConeOrientation(p,a)
#define IDirectSound3DBuffer_GetConeOutsideVolume(p,a)      (p)->lpVtbl->GetConeOutsideVolume(p,a)
#define IDirectSound3DBuffer_GetPosition(p,a)               (p)->lpVtbl->GetPosition(p,a)
#define IDirectSound3DBuffer_GetMinDistance(p,a)            (p)->lpVtbl->GetMinDistance(p,a)
#define IDirectSound3DBuffer_GetMaxDistance(p,a)            (p)->lpVtbl->GetMaxDistance(p,a)
#define IDirectSound3DBuffer_GetMode(p,a)                   (p)->lpVtbl->GetMode(p,a)
#define IDirectSound3DBuffer_GetVelocity(p,a)               (p)->lpVtbl->GetVelocity(p,a)
#define IDirectSound3DBuffer_SetAllParameters(p,a,b)        (p)->lpVtbl->SetAllParameters(p,a,b)
#define IDirectSound3DBuffer_SetConeAngles(p,a,b,c)         (p)->lpVtbl->SetConeAngles(p,a,b,c)
#define IDirectSound3DBuffer_SetConeOrientation(p,a,b,c,d)  (p)->lpVtbl->SetConeOrientation(p,a,b,c,d)
#define IDirectSound3DBuffer_SetConeOutsideVolume(p,a,b)    (p)->lpVtbl->SetConeOutsideVolume(p,a,b)
#define IDirectSound3DBuffer_SetPosition(p,a,b,c,d)         (p)->lpVtbl->SetPosition(p,a,b,c,d)
#define IDirectSound3DBuffer_SetMinDistance(p,a,b)          (p)->lpVtbl->SetMinDistance(p,a,b)
#define IDirectSound3DBuffer_SetMaxDistance(p,a,b)          (p)->lpVtbl->SetMaxDistance(p,a,b)
#define IDirectSound3DBuffer_SetMode(p,a,b)                 (p)->lpVtbl->SetMode(p,a,b)
#define IDirectSound3DBuffer_SetVelocity(p,a,b,c,d)         (p)->lpVtbl->SetVelocity(p,a,b,c,d)
#else // !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectSound3DBuffer_GetAllParameters(p,a)          (p)->GetAllParameters(a)
#define IDirectSound3DBuffer_GetConeAngles(p,a,b)           (p)->GetConeAngles(a,b)
#define IDirectSound3DBuffer_GetConeOrientation(p,a)        (p)->GetConeOrientation(a)
#define IDirectSound3DBuffer_GetConeOutsideVolume(p,a)      (p)->GetConeOutsideVolume(a)
#define IDirectSound3DBuffer_GetPosition(p,a)               (p)->GetPosition(a)
#define IDirectSound3DBuffer_GetMinDistance(p,a)            (p)->GetMinDistance(a)
#define IDirectSound3DBuffer_GetMaxDistance(p,a)            (p)->GetMaxDistance(a)
#define IDirectSound3DBuffer_GetMode(p,a)                   (p)->GetMode(a)
#define IDirectSound3DBuffer_GetVelocity(p,a)               (p)->GetVelocity(a)
#define IDirectSound3DBuffer_SetAllParameters(p,a,b)        (p)->SetAllParameters(a,b)
#define IDirectSound3DBuffer_SetConeAngles(p,a,b,c)         (p)->SetConeAngles(a,b,c)
#define IDirectSound3DBuffer_SetConeOrientation(p,a,b,c,d)  (p)->SetConeOrientation(a,b,c,d)
#define IDirectSound3DBuffer_SetConeOutsideVolume(p,a,b)    (p)->SetConeOutsideVolume(a,b)
#define IDirectSound3DBuffer_SetPosition(p,a,b,c,d)         (p)->SetPosition(a,b,c,d)
#define IDirectSound3DBuffer_SetMinDistance(p,a,b)          (p)->SetMinDistance(a,b)
#define IDirectSound3DBuffer_SetMaxDistance(p,a,b)          (p)->SetMaxDistance(a,b)
#define IDirectSound3DBuffer_SetMode(p,a,b)                 (p)->SetMode(a,b)
#define IDirectSound3DBuffer_SetVelocity(p,a,b,c,d)         (p)->SetVelocity(a,b,c,d)
#endif // !defined(__cplusplus) || defined(CINTERFACE)

//
// IDirectSoundCapture
//

DEFINE_GUID(IID_IDirectSoundCapture, 0xb0210781, 0x89cd, 0x11d0, 0xaf, 0x8, 0x0, 0xa0, 0xc9, 0x25, 0xcd, 0x16);

#undef INTERFACE
#define INTERFACE IDirectSoundCapture

DECLARE_INTERFACE_(IDirectSoundCapture, IUnknown)
{
    // IUnknown methods
    STDMETHOD(QueryInterface)       (THIS_ REFIID, LPVOID *) PURE;
    STDMETHOD_(ULONG,AddRef)        (THIS) PURE;
    STDMETHOD_(ULONG,Release)       (THIS) PURE;

    // IDirectSoundCapture methods
    STDMETHOD(CreateCaptureBuffer)  (THIS_ LPCDSCBUFFERDESC pcDSCBufferDesc, LPDIRECTSOUNDCAPTUREBUFFER *ppDSCBuffer, LPUNKNOWN pUnkOuter) PURE;
    STDMETHOD(GetCaps)              (THIS_ LPDSCCAPS pDSCCaps) PURE;
    STDMETHOD(Initialize)           (THIS_ LPCGUID pcGuidDevice) PURE;
};

#define IDirectSoundCapture_QueryInterface(p,a,b)           IUnknown_QueryInterface(p,a,b)
#define IDirectSoundCapture_AddRef(p)                       IUnknown_AddRef(p)
#define IDirectSoundCapture_Release(p)                      IUnknown_Release(p)

#if !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectSoundCapture_CreateCaptureBuffer(p,a,b,c)    (p)->lpVtbl->CreateCaptureBuffer(p,a,b,c)
#define IDirectSoundCapture_GetCaps(p,a)                    (p)->lpVtbl->GetCaps(p,a)
#define IDirectSoundCapture_Initialize(p,a)                 (p)->lpVtbl->Initialize(p,a)
#else // !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectSoundCapture_CreateCaptureBuffer(p,a,b,c)    (p)->CreateCaptureBuffer(a,b,c)
#define IDirectSoundCapture_GetCaps(p,a)                    (p)->GetCaps(a)
#define IDirectSoundCapture_Initialize(p,a)                 (p)->Initialize(a)
#endif // !defined(__cplusplus) || defined(CINTERFACE)

//
// IDirectSoundCaptureBuffer
//

DEFINE_GUID(IID_IDirectSoundCaptureBuffer, 0xb0210782, 0x89cd, 0x11d0, 0xaf, 0x8, 0x0, 0xa0, 0xc9, 0x25, 0xcd, 0x16);

#undef INTERFACE
#define INTERFACE IDirectSoundCaptureBuffer

DECLARE_INTERFACE_(IDirectSoundCaptureBuffer, IUnknown)
{
    // IUnknown methods
    STDMETHOD(QueryInterface)       (THIS_ REFIID, LPVOID *) PURE;
    STDMETHOD_(ULONG,AddRef)        (THIS) PURE;
    STDMETHOD_(ULONG,Release)       (THIS) PURE;

    // IDirectSoundCaptureBuffer methods
    STDMETHOD(GetCaps)              (THIS_ LPDSCBCAPS pDSCBCaps) PURE;
    STDMETHOD(GetCurrentPosition)   (THIS_ LPDWORD pdwCapturePosition, LPDWORD pdwReadPosition) PURE;
    STDMETHOD(GetFormat)            (THIS_ LPWAVEFORMATEX pwfxFormat, DWORD dwSizeAllocated, LPDWORD pdwSizeWritten) PURE;
    STDMETHOD(GetStatus)            (THIS_ LPDWORD pdwStatus) PURE;
    STDMETHOD(Initialize)           (THIS_ LPDIRECTSOUNDCAPTURE pDirectSoundCapture, LPCDSCBUFFERDESC pcDSCBufferDesc) PURE;
    STDMETHOD(Lock)                 (THIS_ DWORD dwOffset, DWORD dwBytes, LPVOID *ppvAudioPtr1, LPDWORD pdwAudioBytes1,
                                           LPVOID *ppvAudioPtr2, LPDWORD pdwAudioBytes2, DWORD dwFlags) PURE;
    STDMETHOD(Start)                (THIS_ DWORD dwFlags) PURE;
    STDMETHOD(Stop)                 (THIS) PURE;
    STDMETHOD(Unlock)               (THIS_ LPVOID pvAudioPtr1, DWORD dwAudioBytes1, LPVOID pvAudioPtr2, DWORD dwAudioBytes2) PURE;
};

#define IDirectSoundCaptureBuffer_QueryInterface(p,a,b)         IUnknown_QueryInterface(p,a,b)
#define IDirectSoundCaptureBuffer_AddRef(p)                     IUnknown_AddRef(p)
#define IDirectSoundCaptureBuffer_Release(p)                    IUnknown_Release(p)

#if !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectSoundCaptureBuffer_GetCaps(p,a)                  (p)->lpVtbl->GetCaps(p,a)
#define IDirectSoundCaptureBuffer_GetCurrentPosition(p,a,b)     (p)->lpVtbl->GetCurrentPosition(p,a,b)
#define IDirectSoundCaptureBuffer_GetFormat(p,a,b,c)            (p)->lpVtbl->GetFormat(p,a,b,c)
#define IDirectSoundCaptureBuffer_GetStatus(p,a)                (p)->lpVtbl->GetStatus(p,a)
#define IDirectSoundCaptureBuffer_Initialize(p,a,b)             (p)->lpVtbl->Initialize(p,a,b)
#define IDirectSoundCaptureBuffer_Lock(p,a,b,c,d,e,f,g)         (p)->lpVtbl->Lock(p,a,b,c,d,e,f,g)
#define IDirectSoundCaptureBuffer_Start(p,a)                    (p)->lpVtbl->Start(p,a)
#define IDirectSoundCaptureBuffer_Stop(p)                       (p)->lpVtbl->Stop(p)
#define IDirectSoundCaptureBuffer_Unlock(p,a,b,c,d)             (p)->lpVtbl->Unlock(p,a,b,c,d)
#else // !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectSoundCaptureBuffer_GetCaps(p,a)                  (p)->GetCaps(a)
#define IDirectSoundCaptureBuffer_GetCurrentPosition(p,a,b)     (p)->GetCurrentPosition(a,b)
#define IDirectSoundCaptureBuffer_GetFormat(p,a,b,c)            (p)->GetFormat(a,b,c)
#define IDirectSoundCaptureBuffer_GetStatus(p,a)                (p)->GetStatus(a)
#define IDirectSoundCaptureBuffer_Initialize(p,a,b)             (p)->Initialize(a,b)
#define IDirectSoundCaptureBuffer_Lock(p,a,b,c,d,e,f,g)         (p)->Lock(a,b,c,d,e,f,g)
#define IDirectSoundCaptureBuffer_Start(p,a)                    (p)->Start(a)
#define IDirectSoundCaptureBuffer_Stop(p)                       (p)->Stop()
#define IDirectSoundCaptureBuffer_Unlock(p,a,b,c,d)             (p)->Unlock(a,b,c,d)
#endif // !defined(__cplusplus) || defined(CINTERFACE)

//@@BEGIN_MSINTERNAL
#if DIRECTSOUND_VERSION >= 0x0701

//
// IDirectSoundCaptureBuffer7_1
//

DEFINE_GUID(IID_IDirectSoundCaptureBuffer7_1, 0xd6b2a50d, 0x918e, 0x47de, 0x9b, 0xcd, 0x64, 0xd4, 0x9c, 0x5b, 0x1d, 0x75);

#undef INTERFACE
#define INTERFACE IDirectSoundCaptureBuffer7_1

DECLARE_INTERFACE_(IDirectSoundCaptureBuffer7_1, IDirectSoundCaptureBuffer)
{
    // IUnknown methods
    STDMETHOD(QueryInterface)       (THIS_ REFIID, LPVOID *) PURE;
    STDMETHOD_(ULONG,AddRef)        (THIS) PURE;
    STDMETHOD_(ULONG,Release)       (THIS) PURE;

    // IDirectSoundCaptureBuffer methods
    STDMETHOD(GetCaps)              (THIS_ LPDSCBCAPS pDSCBCaps) PURE;
    STDMETHOD(GetCurrentPosition)   (THIS_ LPDWORD pdwCapturePosition, LPDWORD pdwReadPosition) PURE;
    STDMETHOD(GetFormat)            (THIS_ LPWAVEFORMATEX pwfxFormat, DWORD dwSizeAllocated, LPDWORD pdwSizeWritten) PURE;
    STDMETHOD(GetStatus)            (THIS_ LPDWORD pdwStatus) PURE;
    STDMETHOD(Initialize)           (THIS_ LPDIRECTSOUNDCAPTURE pDirectSoundCapture, LPCDSCBUFFERDESC pcDSCBufferDesc) PURE;
    STDMETHOD(Lock)                 (THIS_ DWORD dwOffset, DWORD dwBytes, LPVOID *ppvAudioPtr1, LPDWORD pdwAudioBytes1,
                                           LPVOID *ppvAudioPtr2, LPDWORD pdwAudioBytes2, DWORD dwFlags) PURE;
    STDMETHOD(Start)                (THIS_ DWORD dwFlags) PURE;
    STDMETHOD(Stop)                 (THIS) PURE;
    STDMETHOD(Unlock)               (THIS_ LPVOID pvAudioPtr1, DWORD dwAudioBytes1, LPVOID pvAudioPtr2, DWORD dwAudioBytes2) PURE;

    // IDirectSoundCaptureBuffer7_1 methods
    STDMETHOD(SetVolume)            (THIS_ LONG lVolume) PURE;
    STDMETHOD(GetVolume)            (THIS_ LPLONG plVolume) PURE;
    STDMETHOD(SetMicVolume)         (THIS_ LONG lVolume) PURE;
    STDMETHOD(GetMicVolume)         (THIS_ LPLONG plVolume) PURE;
    STDMETHOD(EnableMic)            (THIS_ BOOL fEnable) PURE;
    STDMETHOD(YieldFocus)           (THIS) PURE;
    STDMETHOD(ClaimFocus)           (THIS) PURE;
    STDMETHOD(SetFocusHWND)         (THIS_ HWND hwndMainWindow) PURE;
    STDMETHOD(GetFocusHWND)         (THIS_ HWND *phwndMainWindow) PURE;
    STDMETHOD(EnableFocusNotifications) (THIS_ HANDLE hFocusEvent) PURE;
};

#define IDirectSoundCaptureBuffer7_1_QueryInterface(p,a,b)            IUnknown_QueryInterface(p,a,b)
#define IDirectSoundCaptureBuffer7_1_AddRef(p)                        IUnknown_AddRef(p)
#define IDirectSoundCaptureBuffer7_1_Release(p)                       IUnknown_Release(p)

#if !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectSoundCaptureBuffer7_1_GetCaps(p,a)                     (p)->lpVtbl->GetCaps(p,a)
#define IDirectSoundCaptureBuffer7_1_GetCurrentPosition(p,a,b)        (p)->lpVtbl->GetCurrentPosition(p,a,b)
#define IDirectSoundCaptureBuffer7_1_GetFormat(p,a,b,c)               (p)->lpVtbl->GetFormat(p,a,b,c)
#define IDirectSoundCaptureBuffer7_1_GetStatus(p,a)                   (p)->lpVtbl->GetStatus(p,a)
#define IDirectSoundCaptureBuffer7_1_Initialize(p,a,b)                (p)->lpVtbl->Initialize(p,a,b)
#define IDirectSoundCaptureBuffer7_1_Lock(p,a,b,c,d,e,f,g)            (p)->lpVtbl->Lock(p,a,b,c,d,e,f,g)
#define IDirectSoundCaptureBuffer7_1_Start(p,a)                       (p)->lpVtbl->Start(p,a)
#define IDirectSoundCaptureBuffer7_1_Stop(p)                          (p)->lpVtbl->Stop(p)
#define IDirectSoundCaptureBuffer7_1_Unlock(p,a,b,c,d)                (p)->lpVtbl->Unlock(p,a,b,c,d)
#define IDirectSoundCaptureBuffer7_1_SetMicVolume(p,a)                (p)->lpVtbl->SetMicVolume(p,a)
#define IDirectSoundCaptureBuffer7_1_GetMicVolume(p,a)                (p)->lpVtbl->GetMicVolume(p,a)
#define IDirectSoundCaptureBuffer7_1_YieldFocus(p)                    (p)->lpVtbl->YieldFocus(p)
#define IDirectSoundCaptureBuffer7_1_ClaimFocus(p)                    (p)->lpVtbl->ClaimFocus(p)
#define IDirectSoundCaptureBuffer7_1_SetFocusHWND(p,a)                (p)->lpVtbl->SetFocusHWND(p,a)
#define IDirectSoundCaptureBuffer7_1_GetFocusHWND(p,a)                (p)->lpVtbl->GetFocusHWND(p,a)
#define IDirectSoundCaptureBuffer7_1_SetFocusNotificationHandler(p,a) (p)->lpVtbl->EnableFocusNotifications(p,a)
#else // !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectSoundCaptureBuffer7_1_GetCaps(p,a)                     (p)->GetCaps(a)
#define IDirectSoundCaptureBuffer7_1_GetCurrentPosition(p,a,b)        (p)->GetCurrentPosition(a,b)
#define IDirectSoundCaptureBuffer7_1_GetFormat(p,a,b,c)               (p)->GetFormat(a,b,c)
#define IDirectSoundCaptureBuffer7_1_GetStatus(p,a)                   (p)->GetStatus(a)
#define IDirectSoundCaptureBuffer7_1_Initialize(p,a,b)                (p)->Initialize(a,b)
#define IDirectSoundCaptureBuffer7_1_Lock(p,a,b,c,d,e,f,g)            (p)->Lock(a,b,c,d,e,f,g)
#define IDirectSoundCaptureBuffer7_1_Start(p,a)                       (p)->Start(a)
#define IDirectSoundCaptureBuffer7_1_Stop(p)                          (p)->Stop()
#define IDirectSoundCaptureBuffer7_1_Unlock(p,a,b,c,d)                (p)->Unlock(a,b,c,d)
#define IDirectSoundCaptureBuffer7_1_SetMicVolume(p,a)                (p)->SetMicVolume(a)
#define IDirectSoundCaptureBuffer7_1_GetMicVolume(p,a)                (p)->GetMicVolume(a)
#define IDirectSoundCaptureBuffer7_1_YieldFocus(p)                    (p)->YieldFocus()
#define IDirectSoundCaptureBuffer7_1_ClaimFocus(p)                    (p)->ClaimFocus()
#define IDirectSoundCaptureBuffer7_1_SetFocusHWND(p,a)                (p)->SetFocusHWND(a)
#define IDirectSoundCaptureBuffer7_1_GetFocusHWND(p,a)                (p)->GetFocusHWND(a)
#define IDirectSoundCaptureBuffer7_1_SetFocusNotificationHandler(p,a) (p)->EnableFocusNotifications(a)
#endif // !defined(__cplusplus) || defined(CINTERFACE)

#endif // DIRECTSOUND_VERSION >= 0x0701
//@@END_MSINTERNAL

#if DIRECTSOUND_VERSION >= 0x0800

//
// IDirectSoundCaptureBuffer8
//

DEFINE_GUID(IID_IDirectSoundCaptureBuffer8, 0x990df4, 0xdbb, 0x4872, 0x83, 0x3e, 0x6d, 0x30, 0x3e, 0x80, 0xae, 0xb6);

#undef INTERFACE
#define INTERFACE IDirectSoundCaptureBuffer8

DECLARE_INTERFACE_(IDirectSoundCaptureBuffer8, IDirectSoundCaptureBuffer)
{
    // IUnknown methods
    STDMETHOD(QueryInterface)       (THIS_ REFIID, LPVOID *) PURE;
    STDMETHOD_(ULONG,AddRef)        (THIS) PURE;
    STDMETHOD_(ULONG,Release)       (THIS) PURE;

    // IDirectSoundCaptureBuffer methods
    STDMETHOD(GetCaps)              (THIS_ LPDSCBCAPS pDSCBCaps) PURE;
    STDMETHOD(GetCurrentPosition)   (THIS_ LPDWORD pdwCapturePosition, LPDWORD pdwReadPosition) PURE;
    STDMETHOD(GetFormat)            (THIS_ LPWAVEFORMATEX pwfxFormat, DWORD dwSizeAllocated, LPDWORD pdwSizeWritten) PURE;
    STDMETHOD(GetStatus)            (THIS_ LPDWORD pdwStatus) PURE;
    STDMETHOD(Initialize)           (THIS_ LPDIRECTSOUNDCAPTURE pDirectSoundCapture, LPCDSCBUFFERDESC pcDSCBufferDesc) PURE;
    STDMETHOD(Lock)                 (THIS_ DWORD dwOffset, DWORD dwBytes, LPVOID *ppvAudioPtr1, LPDWORD pdwAudioBytes1,
                                           LPVOID *ppvAudioPtr2, LPDWORD pdwAudioBytes2, DWORD dwFlags) PURE;
    STDMETHOD(Start)                (THIS_ DWORD dwFlags) PURE;
    STDMETHOD(Stop)                 (THIS) PURE;
    STDMETHOD(Unlock)               (THIS_ LPVOID pvAudioPtr1, DWORD dwAudioBytes1, LPVOID pvAudioPtr2, DWORD dwAudioBytes2) PURE;

    // IDirectSoundCaptureBuffer8 methods
    STDMETHOD(GetObjectInPath)      (THIS_ REFGUID rguidObject, DWORD dwIndex, REFGUID rguidInterface, LPVOID *ppObject) PURE;
    STDMETHOD(GetFXStatus)          (DWORD dwFXCount, LPDWORD pdwFXStatus) PURE;
};

#define IDirectSoundCaptureBuffer8_QueryInterface(p,a,b)            IUnknown_QueryInterface(p,a,b)
#define IDirectSoundCaptureBuffer8_AddRef(p)                        IUnknown_AddRef(p)
#define IDirectSoundCaptureBuffer8_Release(p)                       IUnknown_Release(p)

#define IDirectSoundCaptureBuffer8_GetCaps(p,a)                     IDirectSoundCaptureBuffer_GetCaps(p,a)
#define IDirectSoundCaptureBuffer8_GetCurrentPosition(p,a,b)        IDirectSoundCaptureBuffer_GetCurrentPosition(p,a,b)
#define IDirectSoundCaptureBuffer8_GetFormat(p,a,b,c)               IDirectSoundCaptureBuffer_GetFormat(p,a,b,c)
#define IDirectSoundCaptureBuffer8_GetStatus(p,a)                   IDirectSoundCaptureBuffer_GetStatus(p,a)
#define IDirectSoundCaptureBuffer8_Initialize(p,a,b)                IDirectSoundCaptureBuffer_Initialize(p,a,b)
#define IDirectSoundCaptureBuffer8_Lock(p,a,b,c,d,e,f,g)            IDirectSoundCaptureBuffer_Lock(p,a,b,c,d,e,f,g)
#define IDirectSoundCaptureBuffer8_Start(p,a)                       IDirectSoundCaptureBuffer_Start(p,a)
#define IDirectSoundCaptureBuffer8_Stop(p)                          IDirectSoundCaptureBuffer_Stop(p))
#define IDirectSoundCaptureBuffer8_Unlock(p,a,b,c,d)                IDirectSoundCaptureBuffer_Unlock(p,a,b,c,d)

#if !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectSoundCaptureBuffer8_GetObjectInPath(p,a,b,c,d)       (p)->lpVtbl->GetObjectInPath(p,a,b,c,d)
#define IDirectSoundCaptureBuffer8_GetFXStatus(p,a,b)               (p)->lpVtbl->GetFXStatus(p,a,b)
#else // !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectSoundCaptureBuffer8_GetObjectInPath(p,a,b,c,d)       (p)->GetObjectInPath(a,b,c,d)
#define IDirectSoundCaptureBuffer8_GetFXStatus(p,a,b)               (p)->GetFXStatus(a,b)
#endif // !defined(__cplusplus) || defined(CINTERFACE)

#endif // DIRECTSOUND_VERSION >= 0x0800

//
// IDirectSoundNotify
//

DEFINE_GUID(IID_IDirectSoundNotify, 0xb0210783, 0x89cd, 0x11d0, 0xaf, 0x8, 0x0, 0xa0, 0xc9, 0x25, 0xcd, 0x16);

#undef INTERFACE
#define INTERFACE IDirectSoundNotify

DECLARE_INTERFACE_(IDirectSoundNotify, IUnknown)
{
    // IUnknown methods
    STDMETHOD(QueryInterface)           (THIS_ REFIID, LPVOID *) PURE;
    STDMETHOD_(ULONG,AddRef)            (THIS) PURE;
    STDMETHOD_(ULONG,Release)           (THIS) PURE;

    // IDirectSoundNotify methods
    STDMETHOD(SetNotificationPositions) (THIS_ DWORD dwPositionNotifies, LPCDSBPOSITIONNOTIFY pcPositionNotifies) PURE;
};

#define IDirectSoundNotify_QueryInterface(p,a,b)            IUnknown_QueryInterface(p,a,b)
#define IDirectSoundNotify_AddRef(p)                        IUnknown_AddRef(p)
#define IDirectSoundNotify_Release(p)                       IUnknown_Release(p)

#if !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectSoundNotify_SetNotificationPositions(p,a,b)  (p)->lpVtbl->SetNotificationPositions(p,a,b)
#else // !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectSoundNotify_SetNotificationPositions(p,a,b)  (p)->SetNotificationPositions(a,b)
#endif // !defined(__cplusplus) || defined(CINTERFACE)

//
// IKsPropertySet
//

#ifndef _IKsPropertySet_
#define _IKsPropertySet_

#ifdef __cplusplus
// 'struct' not 'class' per the way DECLARE_INTERFACE_ is defined
struct IKsPropertySet;
#endif // __cplusplus

typedef struct IKsPropertySet *LPKSPROPERTYSET;

#define KSPROPERTY_SUPPORT_GET  0x00000001
#define KSPROPERTY_SUPPORT_SET  0x00000002

DEFINE_GUID(IID_IKsPropertySet, 0x31efac30, 0x515c, 0x11d0, 0xa9, 0xaa, 0x00, 0xaa, 0x00, 0x61, 0xbe, 0x93);

#undef INTERFACE
#define INTERFACE IKsPropertySet

DECLARE_INTERFACE_(IKsPropertySet, IUnknown)
{
    // IUnknown methods
    STDMETHOD(QueryInterface)   (THIS_ REFIID, LPVOID *) PURE;
    STDMETHOD_(ULONG,AddRef)    (THIS) PURE;
    STDMETHOD_(ULONG,Release)   (THIS) PURE;

    // IKsPropertySet methods
    STDMETHOD(Get)              (THIS_ REFGUID rguidPropSet, ULONG ulId, LPVOID pInstanceData, ULONG ulInstanceLength,
                                       LPVOID pPropertyData, ULONG ulDataLength, PULONG pulBytesReturned) PURE;
    STDMETHOD(Set)              (THIS_ REFGUID rguidPropSet, ULONG ulId, LPVOID pInstanceData, ULONG ulInstanceLength,
                                       LPVOID pPropertyData, ULONG ulDataLength) PURE;
    STDMETHOD(QuerySupport)     (THIS_ REFGUID rguidPropSet, ULONG ulId, PULONG pulTypeSupport) PURE;
};

#define IKsPropertySet_QueryInterface(p,a,b)       IUnknown_QueryInterface(p,a,b)
#define IKsPropertySet_AddRef(p)                   IUnknown_AddRef(p)
#define IKsPropertySet_Release(p)                  IUnknown_Release(p)

#if !defined(__cplusplus) || defined(CINTERFACE)
#define IKsPropertySet_Get(p,a,b,c,d,e,f,g)        (p)->lpVtbl->Get(p,a,b,c,d,e,f,g)
#define IKsPropertySet_Set(p,a,b,c,d,e,f)          (p)->lpVtbl->Set(p,a,b,c,d,e,f)
#define IKsPropertySet_QuerySupport(p,a,b,c)       (p)->lpVtbl->QuerySupport(p,a,b,c)
#else // !defined(__cplusplus) || defined(CINTERFACE)
#define IKsPropertySet_Get(p,a,b,c,d,e,f,g)        (p)->Get(a,b,c,d,e,f,g)
#define IKsPropertySet_Set(p,a,b,c,d,e,f)          (p)->Set(a,b,c,d,e,f)
#define IKsPropertySet_QuerySupport(p,a,b,c)       (p)->QuerySupport(a,b,c)
#endif // !defined(__cplusplus) || defined(CINTERFACE)

#endif // _IKsPropertySet_

#if DIRECTSOUND_VERSION >= 0x0800
//@@BEGIN_MSINTERNAL

//
// IDirectSoundFXSend
//

DEFINE_GUID(IID_IDirectSoundFXSend, 0xb30f3564, 0x1698, 0x45ba, 0x9f, 0x75, 0xfc, 0x3c, 0x6c, 0x3b, 0x28, 0x10);

typedef struct _DSFXSend
{
    LONG lSendLevel;
} DSFXSend, *LPDSFXSend;

typedef const DSFXSend *LPCDSFXSend;

#undef INTERFACE
#define INTERFACE IDirectSoundFXSend

DECLARE_INTERFACE_(IDirectSoundFXSend, IUnknown)
{
    // IUnknown methods
    STDMETHOD(QueryInterface)       (THIS_ REFIID, LPVOID *) PURE;
    STDMETHOD_(ULONG,AddRef)        (THIS) PURE;
    STDMETHOD_(ULONG,Release)       (THIS) PURE;

    // IDirectSoundFXSend methods
    STDMETHOD(SetAllParameters)     (THIS_ LPCDSFXSend pcDsFxSend) PURE;
    STDMETHOD(GetAllParameters)     (THIS_ LPDSFXSend pDsFxSend) PURE;
};

#define IDirectSoundFXSend_QueryInterface(p,a,b)            IUnknown_QueryInterface(p,a,b)
#define IDirectSoundFXSend_AddRef(p)                        IUnknown_AddRef(p)
#define IDirectSoundFXSend_Release(p)                       IUnknown_Release(p)

#if !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectSoundFXSend_SetAllParameters(p,a)            (p)->lpVtbl->SetAllParameters(p,a)
#define IDirectSoundFXSend_GetAllParameters(p,a)            (p)->lpVtbl->GetAllParameters(p,a)
#else // !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectSoundFXSend_SetAllParameters(p,a)            (p)->SetAllParameters(a)
#define IDirectSoundFXSend_GetAllParameters(p,a)            (p)->GetAllParameters(a)
#endif // !defined(__cplusplus) || defined(CINTERFACE)
//@@END_MSINTERNAL

//
// IDirectSoundFXGargle
//

DEFINE_GUID(IID_IDirectSoundFXGargle, 0xd616f352, 0xd622, 0x11ce, 0xaa, 0xc5, 0x00, 0x20, 0xaf, 0x0b, 0x99, 0xa3);

typedef struct _DSFXGargle
{
    DWORD       dwRateHz;               // Rate of modulation in hz
    DWORD       dwWaveShape;            // DSFXGARGLE_WAVE_xxx
} DSFXGargle, *LPDSFXGargle;

#define DSFXGARGLE_WAVE_TRIANGLE        0
#define DSFXGARGLE_WAVE_SQUARE          1

typedef const DSFXGargle *LPCDSFXGargle;

#define DSFXGARGLE_RATEHZ_MIN           1
#define DSFXGARGLE_RATEHZ_MAX           1000

#undef INTERFACE
#define INTERFACE IDirectSoundFXGargle

DECLARE_INTERFACE_(IDirectSoundFXGargle, IUnknown)
{
    // IUnknown methods
    STDMETHOD(QueryInterface)       (THIS_ REFIID, LPVOID *) PURE;
    STDMETHOD_(ULONG,AddRef)        (THIS) PURE;
    STDMETHOD_(ULONG,Release)       (THIS) PURE;

    // IDirectSoundFXGargle methods
    STDMETHOD(SetAllParameters)     (THIS_ LPCDSFXGargle pcDsFxGargle) PURE;
    STDMETHOD(GetAllParameters)     (THIS_ LPDSFXGargle pDsFxGargle) PURE;
};

#define IDirectSoundFXGargle_QueryInterface(p,a,b)          IUnknown_QueryInterface(p,a,b)
#define IDirectSoundFXGargle_AddRef(p)                      IUnknown_AddRef(p)
#define IDirectSoundFXGargle_Release(p)                     IUnknown_Release(p)

#if !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectSoundFXGargle_SetAllParameters(p,a)          (p)->lpVtbl->SetAllParameters(p,a)
#define IDirectSoundFXGargle_GetAllParameters(p,a)          (p)->lpVtbl->GetAllParameters(p,a)
#else // !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectSoundFXGargle_SetAllParameters(p,a)          (p)->SetAllParameters(a)
#define IDirectSoundFXGargle_GetAllParameters(p,a)          (p)->GetAllParameters(a)
#endif // !defined(__cplusplus) || defined(CINTERFACE)

//
// IDirectSoundFXChorus
//

DEFINE_GUID(IID_IDirectSoundFXChorus, 0x880842e3, 0x145f, 0x43e6, 0xa9, 0x34, 0xa7, 0x18, 0x06, 0xe5, 0x05, 0x47);

typedef struct _DSFXChorus
{
    FLOAT       fWetDryMix;
    FLOAT       fDepth;
    FLOAT       fFeedback;
    FLOAT       fFrequency;
    LONG        lWaveform;          // LFO shape; DSFXCHORUS_WAVE_xxx
    FLOAT       fDelay;
    LONG        lPhase;
} DSFXChorus, *LPDSFXChorus;

typedef const DSFXChorus *LPCDSFXChorus;

#define DSFXCHORUS_WAVE_TRIANGLE        0
#define DSFXCHORUS_WAVE_SIN             1

#define DSFXCHORUS_WETDRYMIX_MIN        0.0f
#define DSFXCHORUS_WETDRYMIX_MAX        100.0f
#define DSFXCHORUS_DEPTH_MIN            0.0f
#define DSFXCHORUS_DEPTH_MAX            100.0f
#define DSFXCHORUS_FEEDBACK_MIN         -99.0f
#define DSFXCHORUS_FEEDBACK_MAX         99.0f
#define DSFXCHORUS_FREQUENCY_MIN        0.0f
#define DSFXCHORUS_FREQUENCY_MAX        10.0f
#define DSFXCHORUS_DELAY_MIN            0.0f
#define DSFXCHORUS_DELAY_MAX            20.0f
#define DSFXCHORUS_PHASE_MIN            0
#define DSFXCHORUS_PHASE_MAX            4

#define DSFXCHORUS_PHASE_NEG_180        0
#define DSFXCHORUS_PHASE_NEG_90         1
#define DSFXCHORUS_PHASE_ZERO           2
#define DSFXCHORUS_PHASE_90             3
#define DSFXCHORUS_PHASE_180            4

#undef INTERFACE
#define INTERFACE IDirectSoundFXChorus

DECLARE_INTERFACE_(IDirectSoundFXChorus, IUnknown)
{
    // IUnknown methods
    STDMETHOD(QueryInterface)       (THIS_ REFIID, LPVOID *) PURE;
    STDMETHOD_(ULONG,AddRef)        (THIS) PURE;
    STDMETHOD_(ULONG,Release)       (THIS) PURE;

    // IDirectSoundFXChorus methods
    STDMETHOD(SetAllParameters)     (THIS_ LPCDSFXChorus pcDsFxChorus) PURE;
    STDMETHOD(GetAllParameters)     (THIS_ LPDSFXChorus pDsFxChorus) PURE;
};

#define IDirectSoundFXChorus_QueryInterface(p,a,b)          IUnknown_QueryInterface(p,a,b)
#define IDirectSoundFXChorus_AddRef(p)                      IUnknown_AddRef(p)
#define IDirectSoundFXChorus_Release(p)                     IUnknown_Release(p)

#if !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectSoundFXChorus_SetAllParameters(p,a)          (p)->lpVtbl->SetAllParameters(p,a)
#define IDirectSoundFXChorus_GetAllParameters(p,a)          (p)->lpVtbl->GetAllParameters(p,a)
#else // !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectSoundFXChorus_SetAllParameters(p,a)          (p)->SetAllParameters(a)
#define IDirectSoundFXChorus_GetAllParameters(p,a)          (p)->GetAllParameters(a)
#endif // !defined(__cplusplus) || defined(CINTERFACE)

//
// IDirectSoundFXFlanger
//

DEFINE_GUID(IID_IDirectSoundFXFlanger, 0x903e9878, 0x2c92, 0x4072, 0x9b, 0x2c, 0xea, 0x68, 0xf5, 0x39, 0x67, 0x83);

typedef struct _DSFXFlanger
{
    FLOAT       fWetDryMix;
    FLOAT       fDepth;
    FLOAT       fFeedback;
    FLOAT       fFrequency;
    LONG        lWaveform;
    FLOAT       fDelay;
    LONG        lPhase;
} DSFXFlanger, *LPDSFXFlanger;

typedef const DSFXFlanger *LPCDSFXFlanger;

#define DSFXFLANGER_WAVE_TRIANGLE       0
#define DSFXFLANGER_WAVE_SIN            1

#define DSFXFLANGER_WETDRYMIX_MIN       0.0f
#define DSFXFLANGER_WETDRYMIX_MAX       100.0f
#define DSFXFLANGER_FREQUENCY_MIN       0.0f
#define DSFXFLANGER_FREQUENCY_MAX       10.0f
#define DSFXFLANGER_DEPTH_MIN           0.0f
#define DSFXFLANGER_DEPTH_MAX           100.0f
#define DSFXFLANGER_PHASE_MIN           0
#define DSFXFLANGER_PHASE_MAX           4
#define DSFXFLANGER_FEEDBACK_MIN        -99.0f
#define DSFXFLANGER_FEEDBACK_MAX        99.0f
#define DSFXFLANGER_DELAY_MIN           0.0f
#define DSFXFLANGER_DELAY_MAX           4.0f

#define DSFXFLANGER_PHASE_NEG_180       0
#define DSFXFLANGER_PHASE_NEG_90        1
#define DSFXFLANGER_PHASE_ZERO          2
#define DSFXFLANGER_PHASE_90            3
#define DSFXFLANGER_PHASE_180           4

#undef INTERFACE
#define INTERFACE IDirectSoundFXFlanger

DECLARE_INTERFACE_(IDirectSoundFXFlanger, IUnknown)
{
    // IUnknown methods
    STDMETHOD(QueryInterface)       (THIS_ REFIID, LPVOID *) PURE;
    STDMETHOD_(ULONG,AddRef)        (THIS) PURE;
    STDMETHOD_(ULONG,Release)       (THIS) PURE;

    // IDirectSoundFXFlanger methods
    STDMETHOD(SetAllParameters)     (THIS_ LPCDSFXFlanger pcDsFxFlanger) PURE;
    STDMETHOD(GetAllParameters)     (THIS_ LPDSFXFlanger pDsFxFlanger) PURE;
};

#define IDirectSoundFXFlanger_QueryInterface(p,a,b)         IUnknown_QueryInterface(p,a,b)
#define IDirectSoundFXFlanger_AddRef(p)                     IUnknown_AddRef(p)
#define IDirectSoundFXFlanger_Release(p)                    IUnknown_Release(p)

#if !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectSoundFXFlanger_SetAllParameters(p,a)         (p)->lpVtbl->SetAllParameters(p,a)
#define IDirectSoundFXFlanger_GetAllParameters(p,a)         (p)->lpVtbl->GetAllParameters(p,a)
#else // !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectSoundFXFlanger_SetAllParameters(p,a)         (p)->SetAllParameters(a)
#define IDirectSoundFXFlanger_GetAllParameters(p,a)         (p)->GetAllParameters(a)
#endif // !defined(__cplusplus) || defined(CINTERFACE)

//
// IDirectSoundFXEcho
//

DEFINE_GUID(IID_IDirectSoundFXEcho, 0x8bd28edf, 0x50db, 0x4e92, 0xa2, 0xbd, 0x44, 0x54, 0x88, 0xd1, 0xed, 0x42);

typedef struct _DSFXEcho
{
    FLOAT   fWetDryMix;
    FLOAT   fFeedback;
    FLOAT   fLeftDelay;
    FLOAT   fRightDelay;
    LONG    lPanDelay;
} DSFXEcho, *LPDSFXEcho;

typedef const DSFXEcho *LPCDSFXEcho;

#define DSFXECHO_WETDRYMIX_MIN      0.0f
#define DSFXECHO_WETDRYMIX_MAX      100.0f
#define DSFXECHO_FEEDBACK_MIN       0.0f
#define DSFXECHO_FEEDBACK_MAX       100.0f
#define DSFXECHO_LEFTDELAY_MIN      1.0f
#define DSFXECHO_LEFTDELAY_MAX      2000.0f
#define DSFXECHO_RIGHTDELAY_MIN     1.0f
#define DSFXECHO_RIGHTDELAY_MAX     2000.0f
#define DSFXECHO_PANDELAY_MIN       0
#define DSFXECHO_PANDELAY_MAX       1

#undef INTERFACE
#define INTERFACE IDirectSoundFXEcho

DECLARE_INTERFACE_(IDirectSoundFXEcho, IUnknown)
{
    // IUnknown methods
    STDMETHOD(QueryInterface)       (THIS_ REFIID, LPVOID *) PURE;
    STDMETHOD_(ULONG,AddRef)        (THIS) PURE;
    STDMETHOD_(ULONG,Release)       (THIS) PURE;

    // IDirectSoundFXEcho methods
    STDMETHOD(SetAllParameters)     (THIS_ LPCDSFXEcho pcDsFxEcho) PURE;
    STDMETHOD(GetAllParameters)     (THIS_ LPDSFXEcho pDsFxEcho) PURE;
};

#define IDirectSoundFXEcho_QueryInterface(p,a,b)            IUnknown_QueryInterface(p,a,b)
#define IDirectSoundFXEcho_AddRef(p)                        IUnknown_AddRef(p)
#define IDirectSoundFXEcho_Release(p)                       IUnknown_Release(p)

#if !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectSoundFXEcho_SetAllParameters(p,a)            (p)->lpVtbl->SetAllParameters(p,a)
#define IDirectSoundFXEcho_GetAllParameters(p,a)            (p)->lpVtbl->GetAllParameters(p,a)
#else // !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectSoundFXEcho_SetAllParameters(p,a)            (p)->SetAllParameters(a)
#define IDirectSoundFXEcho_GetAllParameters(p,a)            (p)->GetAllParameters(a)
#endif // !defined(__cplusplus) || defined(CINTERFACE)

//
// IDirectSoundFXDistortion
//

DEFINE_GUID(IID_IDirectSoundFXDistortion, 0x8ecf4326, 0x455f, 0x4d8b, 0xbd, 0xa9, 0x8d, 0x5d, 0x3e, 0x9e, 0x3e, 0x0b);

typedef struct _DSFXDistortion
{
    FLOAT   fGain;
    FLOAT   fEdge;
    FLOAT   fPostEQCenterFrequency;
    FLOAT   fPostEQBandwidth;
    FLOAT   fPreLowpassCutoff;
} DSFXDistortion, *LPDSFXDistortion;

typedef const DSFXDistortion *LPCDSFXDistortion;

#define DSFXDISTORTION_GAIN_MIN                     -60.0f
#define DSFXDISTORTION_GAIN_MAX                     0.0f
#define DSFXDISTORTION_EDGE_MIN                     0.0f
#define DSFXDISTORTION_EDGE_MAX                     100.0f
#define DSFXDISTORTION_POSTEQCENTERFREQUENCY_MIN    100.0f
#define DSFXDISTORTION_POSTEQCENTERFREQUENCY_MAX    8000.0f
#define DSFXDISTORTION_POSTEQBANDWIDTH_MIN          100.0f
#define DSFXDISTORTION_POSTEQBANDWIDTH_MAX          8000.0f
#define DSFXDISTORTION_PRELOWPASSCUTOFF_MIN         100.0f
#define DSFXDISTORTION_PRELOWPASSCUTOFF_MAX         8000.0f

#undef INTERFACE
#define INTERFACE IDirectSoundFXDistortion

DECLARE_INTERFACE_(IDirectSoundFXDistortion, IUnknown)
{
    // IUnknown methods
    STDMETHOD(QueryInterface)       (THIS_ REFIID, LPVOID *) PURE;
    STDMETHOD_(ULONG,AddRef)        (THIS) PURE;
    STDMETHOD_(ULONG,Release)       (THIS) PURE;

    // IDirectSoundFXDistortion methods
    STDMETHOD(SetAllParameters)     (THIS_ LPCDSFXDistortion pcDsFxDistortion) PURE;
    STDMETHOD(GetAllParameters)     (THIS_ LPDSFXDistortion pDsFxDistortion) PURE;
};

#define IDirectSoundFXDistortion_QueryInterface(p,a,b)      IUnknown_QueryInterface(p,a,b)
#define IDirectSoundFXDistortion_AddRef(p)                  IUnknown_AddRef(p)
#define IDirectSoundFXDistortion_Release(p)                 IUnknown_Release(p)

#if !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectSoundFXDistortion_SetAllParameters(p,a)      (p)->lpVtbl->SetAllParameters(p,a)
#define IDirectSoundFXDistortion_GetAllParameters(p,a)      (p)->lpVtbl->GetAllParameters(p,a)
#else // !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectSoundFXDistortion_SetAllParameters(p,a)      (p)->SetAllParameters(a)
#define IDirectSoundFXDistortion_GetAllParameters(p,a)      (p)->GetAllParameters(a)
#endif // !defined(__cplusplus) || defined(CINTERFACE)

//
// IDirectSoundFXCompressor
//

DEFINE_GUID(IID_IDirectSoundFXCompressor, 0x4bbd1154, 0x62f6, 0x4e2c, 0xa1, 0x5c, 0xd3, 0xb6, 0xc4, 0x17, 0xf7, 0xa0);

typedef struct _DSFXCompressor
{
    FLOAT   fGain;
    FLOAT   fAttack;
    FLOAT   fRelease;
    FLOAT   fThreshold;
    FLOAT   fRatio;
    FLOAT   fPredelay;
} DSFXCompressor, *LPDSFXCompressor;

typedef const DSFXCompressor *LPCDSFXCompressor;

#define DSFXCOMPRESSOR_GAIN_MIN             -60.0f
#define DSFXCOMPRESSOR_GAIN_MAX             60.0f
#define DSFXCOMPRESSOR_ATTACK_MIN           0.01f
#define DSFXCOMPRESSOR_ATTACK_MAX           500.0f
#define DSFXCOMPRESSOR_RELEASE_MIN          50.0f
#define DSFXCOMPRESSOR_RELEASE_MAX          3000.0f
#define DSFXCOMPRESSOR_THRESHOLD_MIN        -60.0f
#define DSFXCOMPRESSOR_THRESHOLD_MAX        0.0f
#define DSFXCOMPRESSOR_RATIO_MIN            1.0f
#define DSFXCOMPRESSOR_RATIO_MAX            100.0f
#define DSFXCOMPRESSOR_PREDELAY_MIN         0.0f
#define DSFXCOMPRESSOR_PREDELAY_MAX         4.0f

#undef INTERFACE
#define INTERFACE IDirectSoundFXCompressor

DECLARE_INTERFACE_(IDirectSoundFXCompressor, IUnknown)
{
    // IUnknown methods
    STDMETHOD(QueryInterface)       (THIS_ REFIID, LPVOID *) PURE;
    STDMETHOD_(ULONG,AddRef)        (THIS) PURE;
    STDMETHOD_(ULONG,Release)       (THIS) PURE;

    // IDirectSoundFXCompressor methods
    STDMETHOD(SetAllParameters)     (THIS_ LPCDSFXCompressor pcDsFxCompressor) PURE;
    STDMETHOD(GetAllParameters)     (THIS_ LPDSFXCompressor pDsFxCompressor) PURE;
};

#define IDirectSoundFXCompressor_QueryInterface(p,a,b)      IUnknown_QueryInterface(p,a,b)
#define IDirectSoundFXCompressor_AddRef(p)                  IUnknown_AddRef(p)
#define IDirectSoundFXCompressor_Release(p)                 IUnknown_Release(p)

#if !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectSoundFXCompressor_SetAllParameters(p,a)      (p)->lpVtbl->SetAllParameters(p,a)
#define IDirectSoundFXCompressor_GetAllParameters(p,a)      (p)->lpVtbl->GetAllParameters(p,a)
#else // !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectSoundFXCompressor_SetAllParameters(p,a)      (p)->SetAllParameters(a)
#define IDirectSoundFXCompressor_GetAllParameters(p,a)      (p)->GetAllParameters(a)
#endif // !defined(__cplusplus) || defined(CINTERFACE)

//
// IDirectSoundFXParamEq
//

DEFINE_GUID(IID_IDirectSoundFXParamEq, 0xc03ca9fe, 0xfe90, 0x4204, 0x80, 0x78, 0x82, 0x33, 0x4c, 0xd1, 0x77, 0xda);

typedef struct _DSFXParamEq
{
    FLOAT   fCenter;
    FLOAT   fBandwidth;
    FLOAT   fGain;
} DSFXParamEq, *LPDSFXParamEq;

typedef const DSFXParamEq *LPCDSFXParamEq;

#define DSFXPARAMEQ_CENTER_MIN      80.0f
#define DSFXPARAMEQ_CENTER_MAX      16000.0f
#define DSFXPARAMEQ_BANDWIDTH_MIN   1.0f
#define DSFXPARAMEQ_BANDWIDTH_MAX   36.0f
#define DSFXPARAMEQ_GAIN_MIN        -15.0f
#define DSFXPARAMEQ_GAIN_MAX        15.0f

#undef INTERFACE
#define INTERFACE IDirectSoundFXParamEq

DECLARE_INTERFACE_(IDirectSoundFXParamEq, IUnknown)
{
    // IUnknown methods
    STDMETHOD(QueryInterface)       (THIS_ REFIID, LPVOID *) PURE;
    STDMETHOD_(ULONG,AddRef)        (THIS) PURE;
    STDMETHOD_(ULONG,Release)       (THIS) PURE;

    // IDirectSoundFXParamEq methods
    STDMETHOD(SetAllParameters)     (THIS_ LPCDSFXParamEq pcDsFxParamEq) PURE;
    STDMETHOD(GetAllParameters)     (THIS_ LPDSFXParamEq pDsFxParamEq) PURE;
};

#define IDirectSoundFXParamEq_QueryInterface(p,a,b)      IUnknown_QueryInterface(p,a,b)
#define IDirectSoundFXParamEq_AddRef(p)                  IUnknown_AddRef(p)
#define IDirectSoundFXParamEq_Release(p)                 IUnknown_Release(p)

#if !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectSoundFXParamEq_SetAllParameters(p,a)      (p)->lpVtbl->SetAllParameters(p,a)
#define IDirectSoundFXParamEq_GetAllParameters(p,a)      (p)->lpVtbl->GetAllParameters(p,a)
#else // !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectSoundFXParamEq_SetAllParameters(p,a)      (p)->SetAllParameters(a)
#define IDirectSoundFXParamEq_GetAllParameters(p,a)      (p)->GetAllParameters(a)
#endif // !defined(__cplusplus) || defined(CINTERFACE)

//@@BEGIN_MSINTERNAL
#if 0
//
// IDirectSoundFXI3DL2Source
//

DEFINE_GUID(IID_IDirectSoundFXI3DL2Source, 0x4363ff5c, 0x0410, 0x4507, 0xb3, 0x21, 0xea, 0x09, 0xf8, 0xf4, 0x56, 0x99);

typedef struct _DSFXI3DL2Obstruction
{
    LONG    lHFLevel;   // [-10000, 0] default: 0 mB
    FLOAT   flLFRatio;  // [0.0, 1.0]  default: 0.0
} DSFXI3DL2Obstruction, *LPDSFXI3DL2Obstruction;

typedef const DSFXI3DL2Obstruction *LPCDSFXI3DL2Obstruction;

typedef struct _DSFXI3DL2Occlusion
{
    LONG    lHFLevel;   // [-10000, 0] default: 0 mB
    FLOAT   flLFRatio;  // [0.0, 1.0]  default: 0.25
} DSFXI3DL2Occlusion, *LPDSFXI3DL2Occlusion;

typedef const DSFXI3DL2Occlusion *LPCDSFXI3DL2Occlusion;

typedef struct _DSFXI3DL2Source
{
    LONG                    lDirect;                // [-10000, 1000] default: 0 mB
    LONG                    lDirectHF;              // [-10000, 0]    default: 0 mB
    LONG                    lRoom;                  // [-10000, 1000] default: 0 mB
    LONG                    lRoomHF;                // [-10000, 0]    default: 0 mB
    FLOAT                   flRoomRolloffFactor;    // [0.0, 10.0]    default: 0.0
    DSFXI3DL2Obstruction  Obstruction;
    DSFXI3DL2Occlusion    Occlusion;
    DWORD                   dwFlags;                // default: DSFX_I3DL2SOURCE_OCC_LPF
} DSFXI3DL2Source, *LPDSFXI3DL2Source;

typedef const DSFXI3DL2Source *LPCDSFXI3DL2Source;

#define DSFX_I3DL2SOURCE_DIRECT_MIN                     (-10000)
#define DSFX_I3DL2SOURCE_DIRECT_MAX                     1000
#define DSFX_I3DL2SOURCE_DIRECT_DEFAULT                 0
                                                        
#define DSFX_I3DL2SOURCE_DIRECTHF_MIN                   (-10000)
#define DSFX_I3DL2SOURCE_DIRECTHF_MAX                   0
#define DSFX_I3DL2SOURCE_DIRECTHF_DEFAULT               0
                                                        
#define DSFX_I3DL2SOURCE_ROOM_MIN                       (-10000)
#define DSFX_I3DL2SOURCE_ROOM_MAX                        1000
#define DSFX_I3DL2SOURCE_ROOM_DEFAULT                   0
                                                        
#define DSFX_I3DL2SOURCE_ROOMHF_MIN                     (-10000)
#define DSFX_I3DL2SOURCE_ROOMHF_MAX                     0
#define DSFX_I3DL2SOURCE_ROOMHF_DEFAULT                 0
                                                        
#define DSFX_I3DL2SOURCE_ROOMROLLOFFFACTOR_MIN          0.0f
#define DSFX_I3DL2SOURCE_ROOMROLLOFFFACTOR_MAX          10.0f
#define DSFX_I3DL2SOURCE_ROOMROLLOFFFACTOR_DEFAULT      0.0f
                                                        
#define DSFX_I3DL2SOURCE_OBSTRUCTION_HFLEVEL_MIN        (-10000)
#define DSFX_I3DL2SOURCE_OBSTRUCTION_HFLEVEL_MAX        0
#define DSFX_I3DL2SOURCE_OBSTRUCTION_HFLEVEL_DEFAULT    0

#define DSFX_I3DL2SOURCE_OBSTRUCTION_LFRATIO_MIN        0.0f
#define DSFX_I3DL2SOURCE_OBSTRUCTION_LFRATIO_MAX        1.0f
#define DSFX_I3DL2SOURCE_OBSTRUCTION_LFRATIO_DEFAULT    0.0f

#define DSFX_I3DL2SOURCE_OCCLUSION_HFLEVEL_MIN          (-10000)
#define DSFX_I3DL2SOURCE_OCCLUSION_HFLEVEL_MAX          0
#define DSFX_I3DL2SOURCE_OCCLUSION_HFLEVEL_DEFAULT      0
                                                        
#define DSFX_I3DL2SOURCE_OCCLUSION_LFRATIO_MIN          0.0f
#define DSFX_I3DL2SOURCE_OCCLUSION_LFRATIO_MAX          1.0f
#define DSFX_I3DL2SOURCE_OCCLUSION_LFRATIO_DEFAULT      0.25f

#undef INTERFACE
#define INTERFACE IDirectSoundFXI3DL2Source

DECLARE_INTERFACE_(IDirectSoundFXI3DL2Source, IUnknown)
{
    // IUnknown methods
    STDMETHOD(QueryInterface)       (THIS_ REFIID, LPVOID *) PURE;
    STDMETHOD_(ULONG,AddRef)        (THIS) PURE;
    STDMETHOD_(ULONG,Release)       (THIS) PURE;

    // IDirectSoundFXI3DL2Source methods
    STDMETHOD(SetAllParameters)     (THIS_ LPCDSFXI3DL2Source pcDsFxI3DL2Source) PURE;
    STDMETHOD(GetAllParameters)     (THIS_ LPDSFXI3DL2Source pDsFxI3DL2Source) PURE;
    STDMETHOD(SetObstructionPreset) (THIS_ DWORD dwPreset) PURE;
    STDMETHOD(GetObstructionPreset) (THIS_ LPDWORD pdwPreset) PURE;
    STDMETHOD(SetOcclusionPreset)   (THIS_ DWORD dwPreset) PURE;
    STDMETHOD(GetOcclusionPreset)   (THIS_ LPDWORD pdwPreset) PURE;
};

#define IDirectSoundFXI3DL2Source_QueryInterface(p,a,b)     IUnknown_QueryInterface(p,a,b)
#define IDirectSoundFXI3DL2Source_AddRef(p)                 IUnknown_AddRef(p)
#define IDirectSoundFXI3DL2Source_Release(p)                IUnknown_Release(p)

#if !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectSoundFXI3DL2Source_SetAllParameters(p,a)     (p)->lpVtbl->SetAllParameters(p,a)
#define IDirectSoundFXI3DL2Source_GetAllParameters(p,a)     (p)->lpVtbl->GetAllParameters(p,a)
#define IDirectSoundFXI3DL2Source_SetObstructionPreset(p,a) (p)->lpVtbl->SetObstructionPreset(p,a)
#define IDirectSoundFXI3DL2Source_GetObstructionPreset(p,a) (p)->lpVtbl->GetObstructionPreset(p,a)
#define IDirectSoundFXI3DL2Source_SetOcclusionPreset(p,a)   (p)->lpVtbl->SetOcclusionPreset(p,a)
#define IDirectSoundFXI3DL2Source_GetOcclusionPreset(p,a)   (p)->lpVtbl->GetOcclusionPreset(p,a)
#else // !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectSoundFXI3DL2Source_SetAllParameters(p,a)     (p)->SetAllParameters(a)
#define IDirectSoundFXI3DL2Source_GetAllParameters(p,a)     (p)->GetAllParameters(a)
#define IDirectSoundFXI3DL2Source_SetObstructionPreset(p,a) (p)->SetObstructionPreset(a)
#define IDirectSoundFXI3DL2Source_GetObstructionPreset(p,a) (p)->GetObstructionPreset(a)
#define IDirectSoundFXI3DL2Source_SetOcclusionPreset(p,a)   (p)->SetOcclusionPreset(a)
#define IDirectSoundFXI3DL2Source_GetOcclusionPreset(p,a)   (p)->GetOcclusionPreset(a)
#endif // !defined(__cplusplus) || defined(CINTERFACE)
#endif // 0
//@@END_MSINTERNAL

//
// IDirectSoundFXI3DL2Reverb
//

DEFINE_GUID(IID_IDirectSoundFXI3DL2Reverb, 0x4b166a6a, 0x0d66, 0x43f3, 0x80, 0xe3, 0xee, 0x62, 0x80, 0xde, 0xe1, 0xa4);

typedef struct _DSFXI3DL2Reverb
{
    LONG    lRoom;                  // [-10000, 0]      default: -1000 mB
    LONG    lRoomHF;                // [-10000, 0]      default: 0 mB
    FLOAT   flRoomRolloffFactor;    // [0.0, 10.0]      default: 0.0
    FLOAT   flDecayTime;            // [0.1, 20.0]      default: 1.49s
    FLOAT   flDecayHFRatio;         // [0.1, 2.0]       default: 0.83
    LONG    lReflections;           // [-10000, 1000]   default: -2602 mB
    FLOAT   flReflectionsDelay;     // [0.0, 0.3]       default: 0.007 s
    LONG    lReverb;                // [-10000, 2000]   default: 200 mB
    FLOAT   flReverbDelay;          // [0.0, 0.1]       default: 0.011 s
    FLOAT   flDiffusion;            // [0.0, 100.0]     default: 100.0 %
    FLOAT   flDensity;              // [0.0, 100.0]     default: 100.0 %
    FLOAT   flHFReference;          // [20.0, 20000.0]  default: 5000.0 Hz
} DSFXI3DL2Reverb, *LPDSFXI3DL2Reverb;

typedef const DSFXI3DL2Reverb *LPCDSFXI3DL2Reverb;

#define DSFX_I3DL2REVERB_ROOM_MIN                   (-10000)
#define DSFX_I3DL2REVERB_ROOM_MAX                   0
#define DSFX_I3DL2REVERB_ROOM_DEFAULT               (-1000)
                                                    
#define DSFX_I3DL2REVERB_ROOMHF_MIN                 (-10000)
#define DSFX_I3DL2REVERB_ROOMHF_MAX                 0
#define DSFX_I3DL2REVERB_ROOMHF_DEFAULT             (-100)
                                                    
#define DSFX_I3DL2REVERB_ROOMROLLOFFFACTOR_MIN      0.0f
#define DSFX_I3DL2REVERB_ROOMROLLOFFFACTOR_MAX      10.0f
#define DSFX_I3DL2REVERB_ROOMROLLOFFFACTOR_DEFAULT  0.0f

#define DSFX_I3DL2REVERB_DECAYTIME_MIN              0.1f
#define DSFX_I3DL2REVERB_DECAYTIME_MAX              20.0f
#define DSFX_I3DL2REVERB_DECAYTIME_DEFAULT          1.49f
                                                    
#define DSFX_I3DL2REVERB_DECAYHFRATIO_MIN           0.1f
#define DSFX_I3DL2REVERB_DECAYHFRATIO_MAX           2.0f
#define DSFX_I3DL2REVERB_DECAYHFRATIO_DEFAULT       0.83f
                                                    
#define DSFX_I3DL2REVERB_REFLECTIONS_MIN            (-10000)
#define DSFX_I3DL2REVERB_REFLECTIONS_MAX            1000
#define DSFX_I3DL2REVERB_REFLECTIONS_DEFAULT        (-2602)
                                                    
#define DSFX_I3DL2REVERB_REFLECTIONSDELAY_MIN       0.0f
#define DSFX_I3DL2REVERB_REFLECTIONSDELAY_MAX       0.3f
#define DSFX_I3DL2REVERB_REFLECTIONSDELAY_DEFAULT   0.007f

#define DSFX_I3DL2REVERB_REVERB_MIN                 (-10000)
#define DSFX_I3DL2REVERB_REVERB_MAX                 2000
#define DSFX_I3DL2REVERB_REVERB_DEFAULT             (200)
                                                    
#define DSFX_I3DL2REVERB_REVERBDELAY_MIN            0.0f
#define DSFX_I3DL2REVERB_REVERBDELAY_MAX            0.1f
#define DSFX_I3DL2REVERB_REVERBDELAY_DEFAULT        0.011f
                                                    
#define DSFX_I3DL2REVERB_DIFFUSION_MIN              0.0f
#define DSFX_I3DL2REVERB_DIFFUSION_MAX              100.0f
#define DSFX_I3DL2REVERB_DIFFUSION_DEFAULT          100.0f
                                                    
#define DSFX_I3DL2REVERB_DENSITY_MIN                0.0f
#define DSFX_I3DL2REVERB_DENSITY_MAX                100.0f
#define DSFX_I3DL2REVERB_DENSITY_DEFAULT            100.0f
                                                    
#define DSFX_I3DL2REVERB_HFREFERENCE_MIN            20.0f
#define DSFX_I3DL2REVERB_HFREFERENCE_MAX            20000.0f
#define DSFX_I3DL2REVERB_HFREFERENCE_DEFAULT        5000.0f
                                                    
#define DSFX_I3DL2REVERB_QUALITY_MIN                0
#define DSFX_I3DL2REVERB_QUALITY_MAX                3
#define DSFX_I3DL2REVERB_QUALITY_DEFAULT            2

#undef INTERFACE
#define INTERFACE IDirectSoundFXI3DL2Reverb

DECLARE_INTERFACE_(IDirectSoundFXI3DL2Reverb, IUnknown)
{
    // IUnknown methods
    STDMETHOD(QueryInterface)       (THIS_ REFIID, LPVOID *) PURE;
    STDMETHOD_(ULONG,AddRef)        (THIS) PURE;
    STDMETHOD_(ULONG,Release)       (THIS) PURE;

    // IDirectSoundFXI3DL2Reverb methods
    STDMETHOD(SetAllParameters)     (THIS_ LPCDSFXI3DL2Reverb pcDsFxI3DL2Reverb) PURE;
    STDMETHOD(GetAllParameters)     (THIS_ LPDSFXI3DL2Reverb pDsFxI3DL2Reverb) PURE;
    STDMETHOD(SetPreset)            (THIS_ DWORD dwPreset) PURE;
    STDMETHOD(GetPreset)            (THIS_ LPDWORD pdwPreset) PURE;
    STDMETHOD(SetQuality)           (THIS_ LONG lQuality) PURE;
    STDMETHOD(GetQuality)           (THIS_ LONG *plQuality) PURE;
};

#define IDirectSoundFXI3DL2Reverb_QueryInterface(p,a,b)     IUnknown_QueryInterface(p,a,b)
#define IDirectSoundFXI3DL2Reverb_AddRef(p)                 IUnknown_AddRef(p)
#define IDirectSoundFXI3DL2Reverb_Release(p)                IUnknown_Release(p)

#if !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectSoundFXI3DL2Reverb_SetAllParameters(p,a)     (p)->lpVtbl->SetAllParameters(p,a)
#define IDirectSoundFXI3DL2Reverb_GetAllParameters(p,a)     (p)->lpVtbl->GetAllParameters(p,a)
#define IDirectSoundFXI3DL2Reverb_SetPreset(p,a)            (p)->lpVtbl->SetPreset(p,a)
#define IDirectSoundFXI3DL2Reverb_GetPreset(p,a)            (p)->lpVtbl->GetPreset(p,a)
#else // !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectSoundFXI3DL2Reverb_SetAllParameters(p,a)     (p)->SetAllParameters(a)
#define IDirectSoundFXI3DL2Reverb_GetAllParameters(p,a)     (p)->GetAllParameters(a)
#define IDirectSoundFXI3DL2Reverb_SetPreset(p,a)            (p)->SetPreset(a)
#define IDirectSoundFXI3DL2Reverb_GetPreset(p,a)            (p)->GetPreset(a)
#endif // !defined(__cplusplus) || defined(CINTERFACE)

//@@BEGIN_MSINTERNAL
//
// IDirectSoundFXI3DL2SourceEnv - A private interface used by the I3DL2 source DMO
// to receive various bits of information about the environment it's operating in.
//

DEFINE_GUID(IID_IDirectSoundFXI3DL2SourceEnv, 0xf6c55470, 0x7706, 0x4ce1, 0xa3, 0x54, 0x74, 0xb2, 0xf0, 0x3, 0x25, 0xe2);

#undef INTERFACE
#define INTERFACE IDirectSoundFXI3DL2SourceEnv

DECLARE_INTERFACE_(IDirectSoundFXI3DL2SourceEnv, IUnknown)
{
    // IUnknown methods
    STDMETHOD(QueryInterface)       (THIS_ REFIID, LPVOID *) PURE;
    STDMETHOD_(ULONG,AddRef)        (THIS) PURE;
    STDMETHOD_(ULONG,Release)       (THIS) PURE;

    // IDirectSoundFXI3DL2SourceEnv methods
    STDMETHOD(SetEnvironmentReverb) (THIS_ LPDIRECTSOUNDFXI3DL2REVERB8) PURE;
    STDMETHOD(SetDS3DBuffer)        (THIS_ LPDIRECTSOUND3DBUFFER) PURE;
    STDMETHOD(SetDS3DListener)      (THIS_ LPDIRECTSOUND3DLISTENER) PURE;
};

#define IDirectSoundFXI3DL2SourceEnv_QueryInterface(p,a,b)      IUnknown_QueryInterface(p,a,b)
#define IDirectSoundFXI3DL2SourceEnv_AddRef(p)                  IUnknown_AddRef(p)
#define IDirectSoundFXI3DL2SourceEnv_Release(p)                 IUnknown_Release(p)

#if !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectSoundFXI3DL2SourceEnv_SetEnvironmentReverb(p,a)  (p)->lpVtbl->SetEnvironmentReverb(p,a)
#define IDirectSoundFXI3DL2SourceEnv_SetDS3DBuffer(p,a)         (p)->lpVtbl->SetDS3DBuffer(p,a)
#define IDirectSoundFXI3DL2SourceEnv_SetDS3DListener(p,a)       (p)->lpVtbl->SetDS3DListener(p,a)
#else // !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectSoundFXI3DL2SourceEnv_SetEnvironmentReverb(p,a)  (p)->SetEnvironmentReverb(a)
#define IDirectSoundFXI3DL2SourceEnv_SetDS3DBuffer(p,a)         (p)->SetDS3DBuffer(a)
#define IDirectSoundFXI3DL2SourceEnv_SetDS3DListener(p,a)       (p)->SetDS3DListener(a)
#endif // !defined(__cplusplus) || defined(CINTERFACE)

//
// IDirectSound3DBufferPrivate - provided by our 3D buffer object so that the
// I3DL2 source DMO can discover the current attenuation of its host buffer.
//

DEFINE_GUID(IID_IDirectSound3DBufferPrivate, 0x7d8ef383, 0xca05, 0x4593, 0x82, 0xa1, 0x44, 0x4e, 0x80, 0x08, 0x71, 0xe1);

#undef INTERFACE
#define INTERFACE IDirectSound3DBufferPrivate

DECLARE_INTERFACE_(IDirectSound3DBufferPrivate, IUnknown)
{
    // IUnknown methods
    STDMETHOD(QueryInterface)       (THIS_ REFIID, LPVOID *) PURE;
    STDMETHOD_(ULONG,AddRef)        (THIS) PURE;
    STDMETHOD_(ULONG,Release)       (THIS) PURE;

    // IDirectSound3DBufferPrivate methods
    STDMETHOD(GetAttenuation)       (THIS_ FLOAT*) PURE;
};

#define IDirectSound3DBufferPrivate_QueryInterface(p,a,b)   IUnknown_QueryInterface(p,a,b)
#define IDirectSound3DBufferPrivate_AddRef(p)               IUnknown_AddRef(p)
#define IDirectSound3DBufferPrivate_Release(p)              IUnknown_Release(p)

#if !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectSound3DBufferPrivate_GetAttenuation(p,a)     (p)->lpVtbl->GetAttenuation(p,a)
#else // !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectSound3DBufferPrivate_GetAttenuation(p,a)     (p)->GetAttenuation(a)
#endif // !defined(__cplusplus) || defined(CINTERFACE)
//@@END_MSINTERNAL

//
// IDirectSoundFXWavesReverb
//

DEFINE_GUID(IID_IDirectSoundFXWavesReverb,0x46858c3a,0x0dc6,0x45e3,0xb7,0x60,0xd4,0xee,0xf1,0x6c,0xb3,0x25);

typedef struct _DSFXWavesReverb
{
    FLOAT   fInGain;                // [-96.0,0.0]            default: 0.0 dB
    FLOAT   fReverbMix;             // [-96.0,0.0]            default: 0.0 db
    FLOAT   fReverbTime;            // [0.001,3000.0]         default: 1000.0 ms
    FLOAT   fHighFreqRTRatio;       // [0.001,0.999]          default: 0.001
} DSFXWavesReverb, *LPDSFXWavesReverb;

typedef const DSFXWavesReverb *LPCDSFXWavesReverb;

#define DSFX_WAVESREVERB_INGAIN_MIN                 -96.0f
#define DSFX_WAVESREVERB_INGAIN_MAX                 0.0f
#define DSFX_WAVESREVERB_INGAIN_DEFAULT             0.0f
#define DSFX_WAVESREVERB_REVERBMIX_MIN              -96.0f
#define DSFX_WAVESREVERB_REVERBMIX_MAX              0.0f
#define DSFX_WAVESREVERB_REVERBMIX_DEFAULT          0.0f
#define DSFX_WAVESREVERB_REVERBTIME_MIN             0.001f
#define DSFX_WAVESREVERB_REVERBTIME_MAX             3000.0f
#define DSFX_WAVESREVERB_REVERBTIME_DEFAULT         1000.0f
#define DSFX_WAVESREVERB_HIGHFREQRTRATIO_MIN        0.001f
#define DSFX_WAVESREVERB_HIGHFREQRTRATIO_MAX        0.999f
#define DSFX_WAVESREVERB_HIGHFREQRTRATIO_DEFAULT    0.001f

#undef INTERFACE
#define INTERFACE IDirectSoundFXWavesReverb

DECLARE_INTERFACE_(IDirectSoundFXWavesReverb, IUnknown)
{
    // IUnknown methods
    STDMETHOD(QueryInterface)       (THIS_ REFIID, LPVOID *) PURE;
    STDMETHOD_(ULONG,AddRef)        (THIS) PURE;
    STDMETHOD_(ULONG,Release)       (THIS) PURE;

    // IDirectSoundFXWavesReverb methods
    STDMETHOD(SetAllParameters)     (THIS_ LPCDSFXWavesReverb pcDsFxWavesReverb) PURE;
    STDMETHOD(GetAllParameters)     (THIS_ LPDSFXWavesReverb pDsFxWavesReverb) PURE;
};

#define IDirectSoundFXWavesReverb_QueryInterface(p,a,b)     IUnknown_QueryInterface(p,a,b)
#define IDirectSoundFXWavesReverb_AddRef(p)                 IUnknown_AddRef(p)
#define IDirectSoundFXWavesReverb_Release(p)                IUnknown_Release(p)

#if !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectSoundFXWavesReverb_SetAllParameters(p,a)     (p)->lpVtbl->SetAllParameters(p,a)
#define IDirectSoundFXWavesReverb_GetAllParameters(p,a)     (p)->lpVtbl->GetAllParameters(p,a)
#else // !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectSoundFXWavesReverb_SetAllParameters(p,a)     (p)->SetAllParameters(a)
#define IDirectSoundFXWavesReverb_GetAllParameters(p,a)     (p)->GetAllParameters(a)
#endif // !defined(__cplusplus) || defined(CINTERFACE)

//
// IDirectSoundCaptureFXAec
//

DEFINE_GUID(IID_IDirectSoundCaptureFXAec, 0xad74143d, 0x903d, 0x4ab7, 0x80, 0x66, 0x28, 0xd3, 0x63, 0x03, 0x6d, 0x65);

typedef struct _DSCFXAec
{
    BOOL    fEnable;
    BOOL    fNoiseFill;
    DWORD   dwMode;
} DSCFXAec, *LPDSCFXAec;

typedef const DSCFXAec *LPCDSCFXAec;

// These match the AEC_MODE_* constants in the DDK's ksmedia.h file
#define DSCFX_AEC_MODE_PASS_THROUGH                     0x0
#define DSCFX_AEC_MODE_HALF_DUPLEX                      0x1
#define DSCFX_AEC_MODE_FULL_DUPLEX                      0x2

// These match the AEC_STATUS_* constants in ksmedia.h
#define DSCFX_AEC_STATUS_HISTORY_UNINITIALIZED          0x0
#define DSCFX_AEC_STATUS_HISTORY_CONTINUOUSLY_CONVERGED 0x1
#define DSCFX_AEC_STATUS_HISTORY_PREVIOUSLY_DIVERGED    0x2
#define DSCFX_AEC_STATUS_CURRENTLY_CONVERGED            0x8

#undef INTERFACE
#define INTERFACE IDirectSoundCaptureFXAec

DECLARE_INTERFACE_(IDirectSoundCaptureFXAec, IUnknown)
{
    // IUnknown methods
    STDMETHOD(QueryInterface)       (THIS_ REFIID, LPVOID *) PURE;
    STDMETHOD_(ULONG,AddRef)        (THIS) PURE;
    STDMETHOD_(ULONG,Release)       (THIS) PURE;

    // IDirectSoundCaptureFXAec methods
    STDMETHOD(SetAllParameters)     (THIS_ LPCDSCFXAec pDscFxAec) PURE;
    STDMETHOD(GetAllParameters)     (THIS_ LPDSCFXAec pDscFxAec) PURE;
    STDMETHOD(GetStatus)            (THIS_ PDWORD pdwStatus) PURE;
    STDMETHOD(Reset)                (THIS) PURE;
};

#define IDirectSoundCaptureFXAec_QueryInterface(p,a,b)     IUnknown_QueryInterface(p,a,b)
#define IDirectSoundCaptureFXAec_AddRef(p)                 IUnknown_AddRef(p)
#define IDirectSoundCaptureFXAec_Release(p)                IUnknown_Release(p)

#if !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectSoundCaptureFXAec_SetAllParameters(p,a)     (p)->lpVtbl->SetAllParameters(p,a)
#define IDirectSoundCaptureFXAec_GetAllParameters(p,a)     (p)->lpVtbl->GetAllParameters(p,a)
#else // !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectSoundCaptureFXAec_SetAllParameters(p,a)     (p)->SetAllParameters(a)
#define IDirectSoundCaptureFXAec_GetAllParameters(p,a)     (p)->GetAllParameters(a)
#endif // !defined(__cplusplus) || defined(CINTERFACE)


//
// IDirectSoundCaptureFXNoiseSuppress
//

DEFINE_GUID(IID_IDirectSoundCaptureFXNoiseSuppress, 0xed311e41, 0xfbae, 0x4175, 0x96, 0x25, 0xcd, 0x8, 0x54, 0xf6, 0x93, 0xca);

typedef struct _DSCFXNoiseSuppress
{
    BOOL    fEnable;
} DSCFXNoiseSuppress, *LPDSCFXNoiseSuppress;

typedef const DSCFXNoiseSuppress *LPCDSCFXNoiseSuppress;

#undef INTERFACE
#define INTERFACE IDirectSoundCaptureFXNoiseSuppress

DECLARE_INTERFACE_(IDirectSoundCaptureFXNoiseSuppress, IUnknown)
{
    // IUnknown methods
    STDMETHOD(QueryInterface)       (THIS_ REFIID, LPVOID *) PURE;
    STDMETHOD_(ULONG,AddRef)        (THIS) PURE;
    STDMETHOD_(ULONG,Release)       (THIS) PURE;

    // IDirectSoundCaptureFXNoiseSuppress methods
    STDMETHOD(SetAllParameters)     (THIS_ LPCDSCFXNoiseSuppress pcDscFxNoiseSuppress) PURE;
    STDMETHOD(GetAllParameters)     (THIS_ LPDSCFXNoiseSuppress pDscFxNoiseSuppress) PURE;
    STDMETHOD(Reset)                (THIS) PURE;
};

#define IDirectSoundCaptureFXNoiseSuppress_QueryInterface(p,a,b)     IUnknown_QueryInterface(p,a,b)
#define IDirectSoundCaptureFXNoiseSuppress_AddRef(p)                 IUnknown_AddRef(p)
#define IDirectSoundCaptureFXNoiseSuppress_Release(p)                IUnknown_Release(p)

#if !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectSoundCaptureFXNoiseSuppress_SetAllParameters(p,a)     (p)->lpVtbl->SetAllParameters(p,a)
#define IDirectSoundCaptureFXNoiseSuppress_GetAllParameters(p,a)     (p)->lpVtbl->GetAllParameters(p,a)
#else // !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectSoundCaptureFXNoiseSuppress_SetAllParameters(p,a)     (p)->SetAllParameters(a)
#define IDirectSoundCaptureFXNoiseSuppress_GetAllParameters(p,a)     (p)->GetAllParameters(a)
#endif // !defined(__cplusplus) || defined(CINTERFACE)

//@@BEGIN_MSINTERNAL

//
// IDirectSoundCaptureFXAgc
//

DEFINE_GUID(IID_IDirectSoundCaptureFXAgc, 0xe54f76b8, 0xe48f, 0x427b, 0xb7, 0xf7, 0xaf, 0xb8, 0xc7, 0x13, 0xa1, 0x25);

typedef struct _DSCFXAgc
{
    BOOL    fEnable;
    BOOL    fReset;
} DSCFXAgc, *LPDSCFXAgc;

typedef const DSCFXAgc *LPCDSCFXAgc;

#undef INTERFACE
#define INTERFACE IDirectSoundCaptureFXAgc

DECLARE_INTERFACE_(IDirectSoundCaptureFXAgc, IUnknown)
{
    // IUnknown methods
    STDMETHOD(QueryInterface)       (THIS_ REFIID, LPVOID *) PURE;
    STDMETHOD_(ULONG,AddRef)        (THIS) PURE;
    STDMETHOD_(ULONG,Release)       (THIS) PURE;

    // IDirectSoundCaptureFXAgc methods
    STDMETHOD(SetAllParameters)     (THIS_ LPCDSCFXAgc pcDscFxAgc) PURE;
    STDMETHOD(GetAllParameters)     (THIS_ LPDSCFXAgc pDscFxAgc) PURE;
};

#define IDirectSoundCaptureFXAgc_QueryInterface(p,a,b)     IUnknown_QueryInterface(p,a,b)
#define IDirectSoundCaptureFXAgc_AddRef(p)                 IUnknown_AddRef(p)
#define IDirectSoundCaptureFXAgc_Release(p)                IUnknown_Release(p)

#if !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectSoundCaptureFXAgc_SetAllParameters(p,a)     (p)->lpVtbl->SetAllParameters(p,a)
#define IDirectSoundCaptureFXAgc_GetAllParameters(p,a)     (p)->lpVtbl->GetAllParameters(p,a)
#else // !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectSoundCaptureFXAgc_SetAllParameters(p,a)     (p)->SetAllParameters(a)
#define IDirectSoundCaptureFXAgc_GetAllParameters(p,a)     (p)->GetAllParameters(a)
#endif // !defined(__cplusplus) || defined(CINTERFACE)

//
// IDirectSoundCaptureFXMicArray
//

DEFINE_GUID(IID_IDirectSoundCaptureFXMicArray, 0x9AAB5F95, 0xCAF6, 0x4e2a, 0x9D, 0x16, 0x24, 0x5E, 0xBF, 0xDC, 0xFB, 0xE9);

typedef struct _DSCFXMicArray
{
    BOOL    fEnable;
    BOOL    fReset;
} DSCFXMicArray, *LPDSCFXMicArray;

typedef const DSCFXMicArray *LPCDSCFXMicArray;

#undef INTERFACE
#define INTERFACE IDirectSoundCaptureFXMicArray

DECLARE_INTERFACE_(IDirectSoundCaptureFXMicArray, IUnknown)
{
    // IUnknown methods
    STDMETHOD(QueryInterface)       (THIS_ REFIID, LPVOID *) PURE;
    STDMETHOD_(ULONG,AddRef)        (THIS) PURE;
    STDMETHOD_(ULONG,Release)       (THIS) PURE;

    // IDirectSoundCaptureFXMicArray methods
    STDMETHOD(SetAllParameters)     (THIS_ LPCDSCFXMicArray pcDscFxMicArray) PURE;
    STDMETHOD(GetAllParameters)     (THIS_ LPDSCFXMicArray pDscFxMicArray) PURE;
};

#define IDirectSoundCaptureFXMicArray_QueryInterface(p,a,b)     IUnknown_QueryInterface(p,a,b)
#define IDirectSoundCaptureFXMicArray_AddRef(p)                 IUnknown_AddRef(p)
#define IDirectSoundCaptureFXMicArray_Release(p)                IUnknown_Release(p)

#if !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectSoundCaptureFXMicArray_SetAllParameters(p,a)     (p)->lpVtbl->SetAllParameters(p,a)
#define IDirectSoundCaptureFXMicArray_GetAllParameters(p,a)     (p)->lpVtbl->GetAllParameters(p,a)
#else // !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectSoundCaptureFXMicArray_SetAllParameters(p,a)     (p)->SetAllParameters(a)
#define IDirectSoundCaptureFXMicArray_GetAllParameters(p,a)     (p)->GetAllParameters(a)
#endif // !defined(__cplusplus) || defined(CINTERFACE)

//
// IDirectSoundDMOProxy
//

DEFINE_GUID(IID_IDirectSoundDMOProxy,0xe782c03b,0x8187,0x4110,0xb6,0x53,0xd1,0x53,0xff,0x8f,0x42,0xc7);

#undef INTERFACE
#define INTERFACE IDirectSoundDMOProxy

DECLARE_INTERFACE_(IDirectSoundDMOProxy, IUnknown)
{
    // IUnknown methods
    STDMETHOD(QueryInterface)       (THIS_ REFIID, LPVOID *) PURE;
    STDMETHOD_(ULONG,AddRef)        (THIS) PURE;
    STDMETHOD_(ULONG,Release)       (THIS) PURE;

    // IDirectSoundDMOProxy methods
    STDMETHOD(AcquireResources)     (THIS_ IKsPropertySet *pKsPropertySet) PURE;
    STDMETHOD(ReleaseResources)     (THIS) PURE;
    STDMETHOD(InitializeNode)       (THIS_ HANDLE hPin, ULONG ulNodeId) PURE;
};

#define IDirectSoundDMOProxy_QueryInterface(p,a,b)     IUnknown_QueryInterface(p,a,b)
#define IDirectSoundDMOProxy_AddRef(p)                 IUnknown_AddRef(p)
#define IDirectSoundDMOProxy_Release(p)                IUnknown_Release(p)

#if !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectSoundDMOProxy_AcquireResources(p,a)     (p)->lpVtbl->AcquireResources(p,a)
#define IDirectSoundDMOProxy_ReleaseResources(p)       (p)->lpVtbl->ReleaseResources(p)
#define IDirectSoundDMOProxy_InitializeNode(p,a,b)     (p)->lpVtbl->InitializeNode(p,a,b)
#else // !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectSoundDMOProxy_AcquireResources(p,a)     (p)->AcquireResources(a)
#define IDirectSoundDMOProxy_ReleaseResources(p)       (p)->ReleaseResources()
#define IDirectSoundDMOProxy_InitializeNode(p,a,b)     (p)->InitializeNode(a,b)
#endif // !defined(__cplusplus) || defined(CINTERFACE)

//@@END_MSINTERNAL

//
// IDirectSoundFullDuplex
//

#ifndef _IDirectSoundFullDuplex_
#define _IDirectSoundFullDuplex_

#ifdef __cplusplus
// 'struct' not 'class' per the way DECLARE_INTERFACE_ is defined
struct IDirectSoundFullDuplex;
#endif // __cplusplus

typedef struct IDirectSoundFullDuplex *LPDIRECTSOUNDFULLDUPLEX;

DEFINE_GUID(IID_IDirectSoundFullDuplex, 0xedcb4c7a, 0xdaab, 0x4216, 0xa4, 0x2e, 0x6c, 0x50, 0x59, 0x6d, 0xdc, 0x1d);

#undef INTERFACE
#define INTERFACE IDirectSoundFullDuplex

DECLARE_INTERFACE_(IDirectSoundFullDuplex, IUnknown)
{
    // IUnknown methods
    STDMETHOD(QueryInterface)   (THIS_ REFIID, LPVOID *) PURE;
    STDMETHOD_(ULONG,AddRef)    (THIS) PURE;
    STDMETHOD_(ULONG,Release)   (THIS) PURE;

    // IDirectSoundFullDuplex methods 
    STDMETHOD(Initialize)     (THIS_ LPCGUID pCaptureGuid, LPCGUID pRenderGuid, LPCDSCBUFFERDESC lpDscBufferDesc, LPCDSBUFFERDESC lpDsBufferDesc, HWND hWnd, DWORD dwLevel, LPLPDIRECTSOUNDCAPTUREBUFFER8 lplpDirectSoundCaptureBuffer8, LPLPDIRECTSOUNDBUFFER8 lplpDirectSoundBuffer8) PURE;
};

#define IDirectSoundFullDuplex_QueryInterface(p,a,b)    IUnknown_QueryInterface(p,a,b)
#define IDirectSoundFullDuplex_AddRef(p)                IUnknown_AddRef(p)
#define IDirectSoundFullDuplex_Release(p)               IUnknown_Release(p)

#if !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectSoundFullDuplex_Initialize(p,a,b,c,d,e,f,g,h)     (p)->lpVtbl->Initialize(p,a,b,c,d,e,f,g,h)
#else // !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectSoundFullDuplex_Initialize(p,a,b,c,d,e,f,g,h)     (p)->Initialize(a,b,c,d,e,f,g,h)
#endif // !defined(__cplusplus) || defined(CINTERFACE)

#endif // _IDirectSoundFullDuplex_

#endif // DIRECTSOUND_VERSION >= 0x0800

//
// Return Codes
//

// The function completed successfully
#define DS_OK                           S_OK
//@@BEGIN_MSINTERNAL
#define DS_OK_EXPLANATION TEXT("The function completed successfully")
//@@END_MSINTERNAL

// The call succeeded, but we had to substitute the 3D algorithm
#define DS_NO_VIRTUALIZATION            MAKE_HRESULT(0, _FACDS, 10)
//@@BEGIN_MSINTERNAL
#define DS_NO_VIRTUALIZATION_EXPLANATION TEXT("The function succeeded, substituting the Pan3D algorithm")
//@@END_MSINTERNAL

// The call succeeded, but not all of the optional effects were obtained.
#define DS_INCOMPLETE                   MAKE_HRESULT(0, _FACDS, 20)
//@@BEGIN_MSINTERNAL
#define DS_INCOMPLETE_EXPLANATION TEXT("The function succeeded, but not all of the optional effects requested could be obtained")
//@@END_MSINTERNAL

// The call failed because resources (such as a priority level)
// were already being used by another caller
#define DSERR_ALLOCATED                 MAKE_DSHRESULT(10)
//@@BEGIN_MSINTERNAL
#define DSERR_ALLOCATED_EXPLANATION TEXT("The call failed because resources (such as a priority level) were already being used by another caller")
//@@END_MSINTERNAL
//@@BEGIN_MSINTERNAL
// An attempt was made to lock the area between the play and write cursors
#define DSERR_CANTLOCKPLAYCURSOR        MAKE_DSHRESULT(20)
//@@END_MSINTERNAL
//@@BEGIN_MSINTERNAL
#define DSERR_CANTLOCKPLAYCURSOR_EXPLANATION TEXT("An attempt was made to lock the area between the play and write cursors")
//@@END_MSINTERNAL

// The control (vol, pan, etc.) requested by the caller is not available
#define DSERR_CONTROLUNAVAIL            MAKE_DSHRESULT(30)
//@@BEGIN_MSINTERNAL
#define DSERR_CONTROLUNAVAIL_EXPLANATION TEXT("The control (vol, pan, etc.) requested by the caller is not available")
//@@END_MSINTERNAL

// An invalid parameter was passed to the returning function
#define DSERR_INVALIDPARAM              E_INVALIDARG
//@@BEGIN_MSINTERNAL
#define DSERR_INVALIDPARAM_EXPLANATION TEXT("An invalid parameter was passed to the returning function")
//@@END_MSINTERNAL

// This call is not valid for the current state of this object
#define DSERR_INVALIDCALL               MAKE_DSHRESULT(50)
//@@BEGIN_MSINTERNAL
#define DSERR_INVALIDCALL_EXPLANATION TEXT("This call is not valid for the current state of this object")
//@@END_MSINTERNAL

// An undetermined error occurred inside the DirectSound subsystem
#define DSERR_GENERIC                   E_FAIL
//@@BEGIN_MSINTERNAL
#define DSERR_GENERIC_EXPLANATION TEXT("An undetermined error occurred inside the DirectSound subsystem")
//@@END_MSINTERNAL

// The caller does not have the priority level required for the function to
// succeed
#define DSERR_PRIOLEVELNEEDED           MAKE_DSHRESULT(70)
//@@BEGIN_MSINTERNAL
#define DSERR_PRIOLEVELNEEDED_EXPLANATION TEXT("The caller does not have the priority level required for the function to succeed")
//@@END_MSINTERNAL

// Not enough free memory is available to complete the operation
#define DSERR_OUTOFMEMORY               E_OUTOFMEMORY
//@@BEGIN_MSINTERNAL
#define DSERR_OUTOFMEMORY_EXPLANATION TEXT("Not enough free memory is available to complete the operation")
//@@END_MSINTERNAL

// The specified WAVE format is not supported
#define DSERR_BADFORMAT                 MAKE_DSHRESULT(100)
//@@BEGIN_MSINTERNAL
#define DSERR_BADFORMAT_EXPLANATION TEXT("The specified WAVE format is not supported")
//@@END_MSINTERNAL

// The function called is not supported at this time
#define DSERR_UNSUPPORTED               E_NOTIMPL
//@@BEGIN_MSINTERNAL
#define DSERR_UNSUPPORTED_EXPLANATION TEXT("The function called is not supported at this time")
//@@END_MSINTERNAL

// No sound driver is available for use
#define DSERR_NODRIVER                  MAKE_DSHRESULT(120)
//@@BEGIN_MSINTERNAL
#define DSERR_NODRIVER_EXPLANATION TEXT("No sound device is available for use, or the given device ID isn't valid")
//@@END_MSINTERNAL

// This object is already initialized
#define DSERR_ALREADYINITIALIZED        MAKE_DSHRESULT(130)
//@@BEGIN_MSINTERNAL
#define DSERR_ALREADYINITIALIZED_EXPLANATION TEXT("This object is already initialized")
//@@END_MSINTERNAL

// This object does not support aggregation
#define DSERR_NOAGGREGATION             CLASS_E_NOAGGREGATION
//@@BEGIN_MSINTERNAL
#define DSERR_NOAGGREGATION_EXPLANATION TEXT("This object does not support aggregation")
//@@END_MSINTERNAL

// The buffer memory has been lost, and must be restored
#define DSERR_BUFFERLOST                MAKE_DSHRESULT(150)
//@@BEGIN_MSINTERNAL
#define DSERR_BUFFERLOST_EXPLANATION TEXT("The buffer memory has been lost, and must be restored")
//@@END_MSINTERNAL

// Another app has a higher priority level, preventing this call from
// succeeding
#define DSERR_OTHERAPPHASPRIO           MAKE_DSHRESULT(160)
//@@BEGIN_MSINTERNAL
#define DSERR_OTHERAPPHASPRIO_EXPLANATION TEXT("Another app has a higher priority level, preventing this call from succeeding")
//@@END_MSINTERNAL

// This object has not been initialized
#define DSERR_UNINITIALIZED             MAKE_DSHRESULT(170)
//@@BEGIN_MSINTERNAL
#define DSERR_UNINITIALIZED_EXPLANATION TEXT("This object has not been initialized")
//@@END_MSINTERNAL

// The requested COM interface is not available
#define DSERR_NOINTERFACE               E_NOINTERFACE
//@@BEGIN_MSINTERNAL
#define DSERR_NOINTERFACE_EXPLANATION TEXT("The requested COM interface is not available")
//@@END_MSINTERNAL

// Access is denied
#define DSERR_ACCESSDENIED              E_ACCESSDENIED
//@@BEGIN_MSINTERNAL
#define DSERR_ACCESSDENIED_EXPLANATION TEXT("Access is denied")
//@@END_MSINTERNAL

// Tried to create a DSBCAPS_CTRLFX buffer shorter than DSBSIZE_FX_MIN milliseconds
#define DSERR_BUFFERTOOSMALL            MAKE_DSHRESULT(180)
//@@BEGIN_MSINTERNAL
#define DSERR_BUFFERTOOSMALL_EXPLANATION TEXT("Tried to create a CTRLFX buffer shorter than DSBSIZE_FX_MIN milliseconds")
//@@END_MSINTERNAL

// Attempt to use DirectSound 8 functionality on an older DirectSound object
#define DSERR_DS8_REQUIRED              MAKE_DSHRESULT(190)
//@@BEGIN_MSINTERNAL
#define DSERR_DS8_REQUIRED_EXPLANATION TEXT("Attempt to use DirectSound 8 functionality on an older DirectSound object")
//@@END_MSINTERNAL

// A circular loop of send effects was detected
#define DSERR_SENDLOOP                  MAKE_DSHRESULT(200)
//@@BEGIN_MSINTERNAL
#define DSERR_SENDLOOP_EXPLANATION TEXT("A circular loop of send effects was detected")
//@@END_MSINTERNAL

// The GUID specified in an audiopath file does not match a valid MIXIN buffer
#define DSERR_BADSENDBUFFERGUID         MAKE_DSHRESULT(210)
//@@BEGIN_MSINTERNAL
#define DSERR_BADSENDBUFFERGUID_EXPLANATION TEXT("The GUID specified does not match a valid MIXIN buffer")
//@@END_MSINTERNAL

// The object requested was not found (numerically equal to DMUS_E_NOT_FOUND)
#define DSERR_OBJECTNOTFOUND            MAKE_DSHRESULT(4449)
//@@BEGIN_MSINTERNAL
// Can't just be #defined to DMUS_E_NOTFOUND because we don't include the header
#define DSERR_OBJECTNOTFOUND_EXPLANATION TEXT("The object was not found")
//@@END_MSINTERNAL

// The effects requested could not be found on the system, or they were found
// but in the wrong order, or in the wrong hardware/software locations.
#define DSERR_FXUNAVAILABLE             MAKE_DSHRESULT(220)
//@@BEGIN_MSINTERNAL
#define DSERR_FXUNAVAILABLE_EXPLANATION TEXT("The effects could not be found in the order and location requested")
//@@END_MSINTERNAL

//
// Flags
//

#define DSCAPS_PRIMARYMONO          0x00000001
#define DSCAPS_PRIMARYSTEREO        0x00000002
#define DSCAPS_PRIMARY8BIT          0x00000004
#define DSCAPS_PRIMARY16BIT         0x00000008
#define DSCAPS_CONTINUOUSRATE       0x00000010
#define DSCAPS_EMULDRIVER           0x00000020
#define DSCAPS_CERTIFIED            0x00000040
#define DSCAPS_SECONDARYMONO        0x00000100
#define DSCAPS_SECONDARYSTEREO      0x00000200
#define DSCAPS_SECONDARY8BIT        0x00000400
#define DSCAPS_SECONDARY16BIT       0x00000800
//@@BEGIN_MSINTERNAL
#define DSCAPS_PRIMARYFLAGS         (DSCAPS_PRIMARYMONO | DSCAPS_PRIMARYSTEREO | DSCAPS_PRIMARY8BIT | DSCAPS_PRIMARY16BIT)
#define DSCAPS_SECONDARYFLAGS       (DSCAPS_SECONDARYMONO | DSCAPS_SECONDARYSTEREO | DSCAPS_SECONDARY8BIT | DSCAPS_SECONDARY16BIT)
#define DSCAPS_VALIDDRIVERFLAGS     (DSCAPS_PRIMARYFLAGS | DSCAPS_SECONDARYFLAGS | DSCAPS_CONTINUOUSRATE)
#define DSCAPS_VALIDFLAGS           (DSCAPS_VALIDDRIVERFLAGS | DSCAPS_EMULDRIVER | DSCAPS_CERTIFIED)
#define DSCAPS_FILENAMECOOKIE       179  // Must be less than 256.
#define DSCAPS_FILENAMEMODVALUE     247  // Must be less that 256.
//@@END_MSINTERNAL

#define DSSCL_NORMAL                0x00000001
#define DSSCL_PRIORITY              0x00000002
#define DSSCL_EXCLUSIVE             0x00000003
#define DSSCL_WRITEPRIMARY          0x00000004
//@@BEGIN_MSINTERNAL
#define DSSCL_NONE                  0x00000000
#define DSSCL_FIRST                 DSSCL_NORMAL
#define DSSCL_LAST                  DSSCL_WRITEPRIMARY
//@@END_MSINTERNAL

#define DSSPEAKER_DIRECTOUT         0x00000000
#define DSSPEAKER_HEADPHONE         0x00000001
#define DSSPEAKER_MONO              0x00000002
#define DSSPEAKER_QUAD              0x00000003
#define DSSPEAKER_STEREO            0x00000004
#define DSSPEAKER_SURROUND          0x00000005
#define DSSPEAKER_5POINT1           0x00000006
#define DSSPEAKER_7POINT1           0x00000007
//@@BEGIN_MSINTERNAL
#define DSSPEAKER_FIRST             DSSPEAKER_DIRECTOUT
#define DSSPEAKER_LAST              DSSPEAKER_7POINT1
#define DSSPEAKER_DEFAULT           DSSPEAKER_STEREO
//@@END_MSINTERNAL

#define DSSPEAKER_GEOMETRY_MIN      0x00000005  //   5 degrees
#define DSSPEAKER_GEOMETRY_NARROW   0x0000000A  //  10 degrees
#define DSSPEAKER_GEOMETRY_WIDE     0x00000014  //  20 degrees
#define DSSPEAKER_GEOMETRY_MAX      0x000000B4  // 180 degrees

#define DSSPEAKER_COMBINED(c, g)    ((DWORD)(((BYTE)(c)) | ((DWORD)((BYTE)(g))) << 16))
#define DSSPEAKER_CONFIG(a)         ((BYTE)(a))
#define DSSPEAKER_GEOMETRY(a)       ((BYTE)(((DWORD)(a) >> 16) & 0x00FF))
//@@BEGIN_MSINTERNAL
#define DSSPEAKER_CONFIG_MASK       0x000000FF
#define DSSPEAKER_GEOMETRY_MASK     0x00FF0000
//@@END_MSINTERNAL

//@@BEGIN_MSINTERNAL
#ifdef FUTURE_MULTIPAN_SUPPORT
#ifndef _SPEAKER_POSITIONS_

// Speaker positions for SetChannelVolume()
#define _SPEAKER_POSITIONS_
#define SPEAKER_FRONT_LEFT              0x1
#define SPEAKER_FRONT_RIGHT             0x2
#define SPEAKER_FRONT_CENTER            0x4
#define SPEAKER_LOW_FREQUENCY           0x8
#define SPEAKER_BACK_LEFT               0x10
#define SPEAKER_BACK_RIGHT              0x20
#define SPEAKER_FRONT_LEFT_OF_CENTER    0x40
#define SPEAKER_FRONT_RIGHT_OF_CENTER   0x80
#define SPEAKER_BACK_CENTER             0x100
#define SPEAKER_SIDE_LEFT               0x200
#define SPEAKER_SIDE_RIGHT              0x400
#define SPEAKER_TOP_CENTER              0x800
#define SPEAKER_TOP_FRONT_LEFT          0x1000
#define SPEAKER_TOP_FRONT_CENTER        0x2000
#define SPEAKER_TOP_FRONT_RIGHT         0x4000
#define SPEAKER_TOP_BACK_LEFT           0x8000
#define SPEAKER_TOP_BACK_CENTER         0x10000
#define SPEAKER_TOP_BACK_RIGHT          0x20000

// Bit mask locations reserved for future use
#define SPEAKER_RESERVED                0x7FFC0000

// Not used in the DirectSound API
#define SPEAKER_ALL                     0x80000000

#endif // _SPEAKER_POSITIONS_
#endif // FUTURE_MULTIPAN_SUPPORT
//@@END_MSINTERNAL

#define DSBCAPS_PRIMARYBUFFER       0x00000001
#define DSBCAPS_STATIC              0x00000002
#define DSBCAPS_LOCHARDWARE         0x00000004
#define DSBCAPS_LOCSOFTWARE         0x00000008
#define DSBCAPS_CTRL3D              0x00000010
#define DSBCAPS_CTRLFREQUENCY       0x00000020
#define DSBCAPS_CTRLPAN             0x00000040
#define DSBCAPS_CTRLVOLUME          0x00000080
#define DSBCAPS_CTRLPOSITIONNOTIFY  0x00000100
#define DSBCAPS_CTRLFX              0x00000200
//@@BEGIN_MSINTERNAL
#ifdef FUTURE_MULTIPAN_SUPPORT
#define DSBCAPS_CTRLCHANNELVOLUME   0x00000400
#endif
#define DSBCAPS_MIXIN               0x00002000
//@@END_MSINTERNAL
#define DSBCAPS_STICKYFOCUS         0x00004000
#define DSBCAPS_GLOBALFOCUS         0x00008000
#define DSBCAPS_GETCURRENTPOSITION2 0x00010000
#define DSBCAPS_MUTE3DATMAXDISTANCE 0x00020000
#define DSBCAPS_LOCDEFER            0x00040000
//@@BEGIN_MSINTERNAL
#define DSBCAPS_SINKIN              0x00001000  // Means buffer will receive data from a DirectSound sink
#ifdef FUTURE_WAVE_SUPPORT
#define DSBCAPS_FROMWAVEOBJECT      0x00080000  // Means buffer was created with CreateSoundBufferFromWave()
#endif
#define DSBCAPS_DSBUFFERDESC1MASK   0x0003C1FF  // Flags valid for pre-DX7 applications
#define DSBCAPS_DSBUFFERDESC7MASK   (DSBCAPS_DSBUFFERDESC1MASK | DSBCAPS_LOCDEFER)  // Flags valid for DX7 apps
#define DSBCAPS_VALIDFLAGS          (DSBCAPS_DSBUFFERDESC7MASK | DSBCAPS_CTRLFX | DSBCAPS_MIXIN)  //...DX8 apps
#define DSBCAPS_CTRLATTENUATION     (DSBCAPS_CTRLVOLUME | DSBCAPS_CTRLPAN)
#define DSBCAPS_CTRLNOVIRT          (DSBCAPS_CTRLVOLUME | DSBCAPS_CTRLPAN | DSBCAPS_CTRLFREQUENCY)
#define DSBCAPS_LOCMASK             (DSBCAPS_LOCHARDWARE | DSBCAPS_LOCSOFTWARE)  // All valid location flags
#define DSBCAPS_FOCUSMASK           (DSBCAPS_STICKYFOCUS | DSBCAPS_GLOBALFOCUS)  // All valid focus flags
#define DSBCAPS_DRIVERFLAGSMASK     (DSBCAPS_PRIMARYBUFFER | DSBCAPS_CTRLPOSITIONNOTIFY | DSBCAPS_CTRLATTENUATION | \
                                     DSBCAPS_CTRL3D | DSBCAPS_CTRLFREQUENCY)  // Flags of interest to a VxD driver
#define DSBCAPS_STREAMINGVALIDFLAGS (DSBCAPS_LOCMASK | DSBCAPS_FOCUSMASK | DSBCAPS_MIXIN | \
                                     DSBCAPS_CTRLPAN | DSBCAPS_CTRLVOLUME | DSBCAPS_CTRLFX | \
                                     DSBCAPS_CTRL3D | DSBCAPS_MUTE3DATMAXDISTANCE )
#define DSBCAPS_CHANVOLVALIDFLAGS   (DSBCAPS_VALIDFLAGS & ~(DSBCAPS_PRIMARYBUFFER | DSBCAPS_CTRLPAN | \
                                                            DSBCAPS_CTRL3D | DSBCAPS_MUTE3DATMAXDISTANCE))
#define DSBCAPS_FROMWAVEVALIDFLAGS  (DSBCAPS_LOCMASK | DSBCAPS_LOCDEFER | DSBCAPS_FOCUSMASK | DSBCAPS_CTRLPAN | \
                                     DSBCAPS_CTRLVOLUME | DSBCAPS_CTRLFX | DSBCAPS_CTRLFREQUENCY)
//@@END_MSINTERNAL

#define DSBPLAY_LOOPING             0x00000001
#define DSBPLAY_LOCHARDWARE         0x00000002
#define DSBPLAY_LOCSOFTWARE         0x00000004
#define DSBPLAY_TERMINATEBY_TIME    0x00000008
#define DSBPLAY_TERMINATEBY_DISTANCE    0x000000010
#define DSBPLAY_TERMINATEBY_PRIORITY    0x000000020
//@@BEGIN_MSINTERNAL
#define DSBPLAY_LOCMASK             (DSBPLAY_LOCHARDWARE | DSBPLAY_LOCSOFTWARE)  // All valid location flags
#define DSBPLAY_TERMINATEBY_MASK    (DSBPLAY_TERMINATEBY_TIME | DSBPLAY_TERMINATEBY_DISTANCE | DSBPLAY_TERMINATEBY_PRIORITY)
#define DSBPLAY_LOCDEFERMASK        (DSBPLAY_LOCMASK | DSBPLAY_TERMINATEBY_MASK)
#define DSBPLAY_VALIDFLAGS          (DSBPLAY_LOCDEFERMASK | DSBPLAY_LOOPING)
//@@END_MSINTERNAL

#define DSBSTATUS_PLAYING           0x00000001
#define DSBSTATUS_BUFFERLOST        0x00000002
#define DSBSTATUS_LOOPING           0x00000004
#define DSBSTATUS_LOCHARDWARE       0x00000008
#define DSBSTATUS_LOCSOFTWARE       0x00000010
#define DSBSTATUS_TERMINATED        0x00000020
//@@BEGIN_MSINTERNAL
#define DSBSTATUS_ACTIVE            0x00000040
#define DSBSTATUS_RESOURCESACQUIRED 0x00000080
#define DSBSTATUS_STOPPEDBYFOCUS    0x00000100
#define DSBSTATUS_LOCMASK           (DSBSTATUS_LOCHARDWARE | DSBSTATUS_LOCSOFTWARE)
#define DSBSTATUS_LOCDEFERMASK      (DSBSTATUS_LOCMASK | DSBSTATUS_TERMINATED)
#define DSBSTATUS_USERMASK          (DSBSTATUS_LOCDEFERMASK | DSBSTATUS_PLAYING | DSBSTATUS_BUFFERLOST | DSBSTATUS_LOOPING)
//@@END_MSINTERNAL

#define DSBLOCK_FROMWRITECURSOR     0x00000001
#define DSBLOCK_ENTIREBUFFER        0x00000002
//@@BEGIN_MSINTERNAL
#define DSBLOCK_VALIDFLAGS          (DSBLOCK_FROMWRITECURSOR | DSBLOCK_ENTIREBUFFER)
//@@END_MSINTERNAL

#define DSBFREQUENCY_MIN            100
#define DSBFREQUENCY_MAX            100000
#define DSBFREQUENCY_ORIGINAL       0

#define DSBPAN_LEFT                 -10000
#define DSBPAN_CENTER               0
#define DSBPAN_RIGHT                10000

#define DSBVOLUME_MIN               -10000
#define DSBVOLUME_MAX               0

#define DSBSIZE_MIN                 4
#define DSBSIZE_MAX                 0x0FFFFFFF
#define DSBSIZE_FX_MIN              150  // NOTE: Milliseconds, not bytes

#define DS3DMODE_NORMAL             0x00000000
#define DS3DMODE_HEADRELATIVE       0x00000001
#define DS3DMODE_DISABLE            0x00000002
//@@BEGIN_MSINTERNAL
#define DS3DMODE_FIRST              DS3DMODE_NORMAL
#define DS3DMODE_LAST               DS3DMODE_DISABLE
//@@END_MSINTERNAL

#define DS3D_IMMEDIATE              0x00000000
#define DS3D_DEFERRED               0x00000001
//@@BEGIN_MSINTERNAL
#define DS3D_VALIDFLAGS             0x00000001
//@@END_MSINTERNAL

#define DS3D_MINDISTANCEFACTOR      FLT_MIN
#define DS3D_MAXDISTANCEFACTOR      FLT_MAX
#define DS3D_DEFAULTDISTANCEFACTOR  1.0f

#define DS3D_MINROLLOFFFACTOR       0.0f
#define DS3D_MAXROLLOFFFACTOR       10.0f
#define DS3D_DEFAULTROLLOFFFACTOR   1.0f

#define DS3D_MINDOPPLERFACTOR       0.0f
#define DS3D_MAXDOPPLERFACTOR       10.0f
#define DS3D_DEFAULTDOPPLERFACTOR   1.0f

#define DS3D_DEFAULTMINDISTANCE     1.0f
#define DS3D_DEFAULTMAXDISTANCE     1000000000.0f

#define DS3D_MINCONEANGLE           0
#define DS3D_MAXCONEANGLE           360
#define DS3D_DEFAULTCONEANGLE       360

#define DS3D_DEFAULTCONEOUTSIDEVOLUME DSBVOLUME_MAX

// IDirectSoundCapture attributes

#define DSCCAPS_EMULDRIVER          DSCAPS_EMULDRIVER
#define DSCCAPS_CERTIFIED           DSCAPS_CERTIFIED
//@@BEGIN_MSINTERNAL
#if DIRECTSOUND_VERSION >= 0x0701
#define DSCCAPS_MULTIPLECAPTURE     0x00000001
#endif
//@@END_MSINTERNAL

// IDirectSoundCaptureBuffer attributes

#define DSCBCAPS_WAVEMAPPED         0x80000000

#if DIRECTSOUND_VERSION >= 0x0800
#define DSCBCAPS_CTRLFX             0x00000200
#endif

//@@BEGIN_MSINTERNAL
#define DSCBCAPS_LOCHARDWARE        0x00000004
#define DSCBCAPS_LOCSOFTWARE        0x00000008

#if DIRECTSOUND_VERSION >= 0x0701
#define DSCBCAPS_CTRLVOLUME         0x10000000
#define DSCBCAPS_FOCUSAWARE         0x20000000
#define DSCBCAPS_STRICTFOCUS        0x40000000
#endif

#define DSCBCAPS_VALIDFLAGS         (DSCBCAPS_WAVEMAPPED | DSCBCAPS_STRICTFOCUS | DSCBCAPS_FOCUSAWARE | DSCBCAPS_CTRLVOLUME | DSCBCAPS_CTRLFX)
//@@END_MSINTERNAL

#define DSCBLOCK_ENTIREBUFFER       0x00000001
//@@BEGIN_MSINTERNAL
#define DSCBLOCK_VALIDFLAGS         0x00000001
//@@END_MSINTERNAL

#define DSCBSTATUS_CAPTURING        0x00000001
#define DSCBSTATUS_LOOPING          0x00000002
//@@BEGIN_MSINTERNAL
#if DIRECTSOUND_VERSION >= 0x0701
#define DSCBSTATUS_INFOCUS          0x00000004
#define DSCBSTATUS_LOSTFOCUS        0x00000008
#endif
#define DSCBSTATUS_STOPPING         0x80000000
#define DSCBSTATUS_STOPPED          0x40000000

#define DSCBSTATUS_USERMASK         0x0000FFFF
//@@END_MSINTERNAL

#define DSCBSTART_LOOPING           0x00000001
//@@BEGIN_MSINTERNAL
#define DSCBSTART_VALIDFLAGS        DSCBSTART_LOOPING
//@@END_MSINTERNAL

#define DSBPN_OFFSETSTOP            0xFFFFFFFF

#define DS_CERTIFIED                0x00000000
#define DS_UNCERTIFIED              0x00000001

//@@BEGIN_MSINTERNAL

// Dsound system resource constants: these match the
// KSAUDIO_CPU_RESOURCES_xxx_HOST_CPU values in ksmedia.h
#define DS_SYSTEM_RESOURCES_NO_HOST_RESOURCES  0x00000000
#define DS_SYSTEM_RESOURCES_ALL_HOST_RESOURCES 0x7FFFFFFF
#define DS_SYSTEM_RESOURCES_UNDEFINED          0x80000000

#if 0
//
// Flags for the I3DL2 reverberation effect
//

enum
{
    DSFX_I3DL2SOURCE_OCC_LPF,
    DSFX_I3DL2SOURCE_OCC_VOLUME
};
#endif
//@@END_MSINTERNAL

//
// I3DL2 Material Presets
//

enum
{
    DSFX_I3DL2_MATERIAL_PRESET_SINGLEWINDOW,
    DSFX_I3DL2_MATERIAL_PRESET_DOUBLEWINDOW,
    DSFX_I3DL2_MATERIAL_PRESET_THINDOOR,
    DSFX_I3DL2_MATERIAL_PRESET_THICKDOOR,
    DSFX_I3DL2_MATERIAL_PRESET_WOODWALL,
    DSFX_I3DL2_MATERIAL_PRESET_BRICKWALL,
    DSFX_I3DL2_MATERIAL_PRESET_STONEWALL,
    DSFX_I3DL2_MATERIAL_PRESET_CURTAIN
//@@BEGIN_MSINTERNAL
    ,DSFX_I3DL2_MATERIAL_PRESET_MAX
//@@END_MSINTERNAL
};

#define I3DL2_MATERIAL_PRESET_SINGLEWINDOW    -2800,0.71f
#define I3DL2_MATERIAL_PRESET_DOUBLEWINDOW    -5000,0.40f
#define I3DL2_MATERIAL_PRESET_THINDOOR        -1800,0.66f
#define I3DL2_MATERIAL_PRESET_THICKDOOR       -4400,0.64f
#define I3DL2_MATERIAL_PRESET_WOODWALL        -4000,0.50f
#define I3DL2_MATERIAL_PRESET_BRICKWALL       -5000,0.60f
#define I3DL2_MATERIAL_PRESET_STONEWALL       -6000,0.68f
#define I3DL2_MATERIAL_PRESET_CURTAIN         -1200,0.15f


enum
{
    DSFX_I3DL2_ENVIRONMENT_PRESET_DEFAULT,
    DSFX_I3DL2_ENVIRONMENT_PRESET_GENERIC,
    DSFX_I3DL2_ENVIRONMENT_PRESET_PADDEDCELL,
    DSFX_I3DL2_ENVIRONMENT_PRESET_ROOM,
    DSFX_I3DL2_ENVIRONMENT_PRESET_BATHROOM,
    DSFX_I3DL2_ENVIRONMENT_PRESET_LIVINGROOM,
    DSFX_I3DL2_ENVIRONMENT_PRESET_STONEROOM,
    DSFX_I3DL2_ENVIRONMENT_PRESET_AUDITORIUM,
    DSFX_I3DL2_ENVIRONMENT_PRESET_CONCERTHALL,
    DSFX_I3DL2_ENVIRONMENT_PRESET_CAVE,
    DSFX_I3DL2_ENVIRONMENT_PRESET_ARENA,
    DSFX_I3DL2_ENVIRONMENT_PRESET_HANGAR,
    DSFX_I3DL2_ENVIRONMENT_PRESET_CARPETEDHALLWAY,
    DSFX_I3DL2_ENVIRONMENT_PRESET_HALLWAY,
    DSFX_I3DL2_ENVIRONMENT_PRESET_STONECORRIDOR,
    DSFX_I3DL2_ENVIRONMENT_PRESET_ALLEY,
    DSFX_I3DL2_ENVIRONMENT_PRESET_FOREST,
    DSFX_I3DL2_ENVIRONMENT_PRESET_CITY,
    DSFX_I3DL2_ENVIRONMENT_PRESET_MOUNTAINS,
    DSFX_I3DL2_ENVIRONMENT_PRESET_QUARRY,
    DSFX_I3DL2_ENVIRONMENT_PRESET_PLAIN,
    DSFX_I3DL2_ENVIRONMENT_PRESET_PARKINGLOT,
    DSFX_I3DL2_ENVIRONMENT_PRESET_SEWERPIPE,
    DSFX_I3DL2_ENVIRONMENT_PRESET_UNDERWATER,
    DSFX_I3DL2_ENVIRONMENT_PRESET_SMALLROOM,
    DSFX_I3DL2_ENVIRONMENT_PRESET_MEDIUMROOM,
    DSFX_I3DL2_ENVIRONMENT_PRESET_LARGEROOM,
    DSFX_I3DL2_ENVIRONMENT_PRESET_MEDIUMHALL,
    DSFX_I3DL2_ENVIRONMENT_PRESET_LARGEHALL,
    DSFX_I3DL2_ENVIRONMENT_PRESET_PLATE
//@@BEGIN_MSINTERNAL
    ,DSFX_I3DL2_ENVIRONMENT_PRESET_MAX
//@@END_MSINTERNAL
};

//
// I3DL2 Reverberation Presets Values
//

#define I3DL2_ENVIRONMENT_PRESET_DEFAULT         -1000, -100, 0.0f, 1.49f, 0.83f, -2602, 0.007f,   200, 0.011f, 100.0f, 100.0f, 5000.0f
#define I3DL2_ENVIRONMENT_PRESET_GENERIC         -1000, -100, 0.0f, 1.49f, 0.83f, -2602, 0.007f,   200, 0.011f, 100.0f, 100.0f, 5000.0f
#define I3DL2_ENVIRONMENT_PRESET_PADDEDCELL      -1000,-6000, 0.0f, 0.17f, 0.10f, -1204, 0.001f,   207, 0.002f, 100.0f, 100.0f, 5000.0f
#define I3DL2_ENVIRONMENT_PRESET_ROOM            -1000, -454, 0.0f, 0.40f, 0.83f, -1646, 0.002f,    53, 0.003f, 100.0f, 100.0f, 5000.0f
#define I3DL2_ENVIRONMENT_PRESET_BATHROOM        -1000,-1200, 0.0f, 1.49f, 0.54f,  -370, 0.007f,  1030, 0.011f, 100.0f,  60.0f, 5000.0f
#define I3DL2_ENVIRONMENT_PRESET_LIVINGROOM      -1000,-6000, 0.0f, 0.50f, 0.10f, -1376, 0.003f, -1104, 0.004f, 100.0f, 100.0f, 5000.0f
#define I3DL2_ENVIRONMENT_PRESET_STONEROOM       -1000, -300, 0.0f, 2.31f, 0.64f,  -711, 0.012f,    83, 0.017f, 100.0f, 100.0f, 5000.0f
#define I3DL2_ENVIRONMENT_PRESET_AUDITORIUM      -1000, -476, 0.0f, 4.32f, 0.59f,  -789, 0.020f,  -289, 0.030f, 100.0f, 100.0f, 5000.0f
#define I3DL2_ENVIRONMENT_PRESET_CONCERTHALL     -1000, -500, 0.0f, 3.92f, 0.70f, -1230, 0.020f,    -2, 0.029f, 100.0f, 100.0f, 5000.0f
#define I3DL2_ENVIRONMENT_PRESET_CAVE            -1000,    0, 0.0f, 2.91f, 1.30f,  -602, 0.015f,  -302, 0.022f, 100.0f, 100.0f, 5000.0f
#define I3DL2_ENVIRONMENT_PRESET_ARENA           -1000, -698, 0.0f, 7.24f, 0.33f, -1166, 0.020f,    16, 0.030f, 100.0f, 100.0f, 5000.0f
#define I3DL2_ENVIRONMENT_PRESET_HANGAR          -1000,-1000, 0.0f,10.05f, 0.23f,  -602, 0.020f,   198, 0.030f, 100.0f, 100.0f, 5000.0f
#define I3DL2_ENVIRONMENT_PRESET_CARPETEDHALLWAY -1000,-4000, 0.0f, 0.30f, 0.10f, -1831, 0.002f, -1630, 0.030f, 100.0f, 100.0f, 5000.0f
#define I3DL2_ENVIRONMENT_PRESET_HALLWAY         -1000, -300, 0.0f, 1.49f, 0.59f, -1219, 0.007f,   441, 0.011f, 100.0f, 100.0f, 5000.0f
#define I3DL2_ENVIRONMENT_PRESET_STONECORRIDOR   -1000, -237, 0.0f, 2.70f, 0.79f, -1214, 0.013f,   395, 0.020f, 100.0f, 100.0f, 5000.0f
#define I3DL2_ENVIRONMENT_PRESET_ALLEY           -1000, -270, 0.0f, 1.49f, 0.86f, -1204, 0.007f,    -4, 0.011f, 100.0f, 100.0f, 5000.0f
#define I3DL2_ENVIRONMENT_PRESET_FOREST          -1000,-3300, 0.0f, 1.49f, 0.54f, -2560, 0.162f,  -613, 0.088f,  79.0f, 100.0f, 5000.0f
#define I3DL2_ENVIRONMENT_PRESET_CITY            -1000, -800, 0.0f, 1.49f, 0.67f, -2273, 0.007f, -2217, 0.011f,  50.0f, 100.0f, 5000.0f
#define I3DL2_ENVIRONMENT_PRESET_MOUNTAINS       -1000,-2500, 0.0f, 1.49f, 0.21f, -2780, 0.300f, -2014, 0.100f,  27.0f, 100.0f, 5000.0f
#define I3DL2_ENVIRONMENT_PRESET_QUARRY          -1000,-1000, 0.0f, 1.49f, 0.83f,-10000, 0.061f,   500, 0.025f, 100.0f, 100.0f, 5000.0f
#define I3DL2_ENVIRONMENT_PRESET_PLAIN           -1000,-2000, 0.0f, 1.49f, 0.50f, -2466, 0.179f, -2514, 0.100f,  21.0f, 100.0f, 5000.0f
#define I3DL2_ENVIRONMENT_PRESET_PARKINGLOT      -1000,    0, 0.0f, 1.65f, 1.50f, -1363, 0.008f, -1153, 0.012f, 100.0f, 100.0f, 5000.0f
#define I3DL2_ENVIRONMENT_PRESET_SEWERPIPE       -1000,-1000, 0.0f, 2.81f, 0.14f,   429, 0.014f,   648, 0.021f,  80.0f,  60.0f, 5000.0f
#define I3DL2_ENVIRONMENT_PRESET_UNDERWATER      -1000,-4000, 0.0f, 1.49f, 0.10f,  -449, 0.007f,  1700, 0.011f, 100.0f, 100.0f, 5000.0f

//
// Examples simulating 'musical' reverb presets
//
// Name       Decay time   Description
// Small Room    1.1s      A small size room with a length of 5m or so.
// Medium Room   1.3s      A medium size room with a length of 10m or so.
// Large Room    1.5s      A large size room suitable for live performances.
// Medium Hall   1.8s      A medium size concert hall.
// Large Hall    1.8s      A large size concert hall suitable for a full orchestra.
// Plate         1.3s      A plate reverb simulation.
//

#define I3DL2_ENVIRONMENT_PRESET_SMALLROOM       -1000, -600, 0.0f, 1.10f, 0.83f,  -400, 0.005f,   500, 0.010f, 100.0f, 100.0f, 5000.0f
#define I3DL2_ENVIRONMENT_PRESET_MEDIUMROOM      -1000, -600, 0.0f, 1.30f, 0.83f, -1000, 0.010f,  -200, 0.020f, 100.0f, 100.0f, 5000.0f
#define I3DL2_ENVIRONMENT_PRESET_LARGEROOM       -1000, -600, 0.0f, 1.50f, 0.83f, -1600, 0.020f, -1000, 0.040f, 100.0f, 100.0f, 5000.0f
#define I3DL2_ENVIRONMENT_PRESET_MEDIUMHALL      -1000, -600, 0.0f, 1.80f, 0.70f, -1300, 0.015f,  -800, 0.030f, 100.0f, 100.0f, 5000.0f
#define I3DL2_ENVIRONMENT_PRESET_LARGEHALL       -1000, -600, 0.0f, 1.80f, 0.70f, -2000, 0.030f, -1400, 0.060f, 100.0f, 100.0f, 5000.0f
#define I3DL2_ENVIRONMENT_PRESET_PLATE           -1000, -200, 0.0f, 1.30f, 0.90f,     0, 0.002f,     0, 0.010f, 100.0f,  75.0f, 5000.0f

//
// DirectSound3D Algorithms
//

// Default DirectSound3D algorithm {00000000-0000-0000-0000-000000000000}
#define DS3DALG_DEFAULT GUID_NULL

// No virtualization (Pan3D) {C241333F-1C1B-11d2-94F5-00C04FC28ACA}
DEFINE_GUID(DS3DALG_NO_VIRTUALIZATION, 0xc241333f, 0x1c1b, 0x11d2, 0x94, 0xf5, 0x0, 0xc0, 0x4f, 0xc2, 0x8a, 0xca);

// High-quality HRTF algorithm {C2413340-1C1B-11d2-94F5-00C04FC28ACA}
DEFINE_GUID(DS3DALG_HRTF_FULL, 0xc2413340, 0x1c1b, 0x11d2, 0x94, 0xf5, 0x0, 0xc0, 0x4f, 0xc2, 0x8a, 0xca);

// Lower-quality HRTF algorithm {C2413342-1C1B-11d2-94F5-00C04FC28ACA}
DEFINE_GUID(DS3DALG_HRTF_LIGHT, 0xc2413342, 0x1c1b, 0x11d2, 0x94, 0xf5, 0x0, 0xc0, 0x4f, 0xc2, 0x8a, 0xca);

//@@BEGIN_MSINTERNAL
// Original DirectSound3D ITD algorithm {1B5C9566-5E20-11d2-91BD-00C04FC28ACA}
DEFINE_GUID(DS3DALG_ITD, 0x1b5c9566, 0x5e20, 0x11d2, 0x91, 0xbd, 0x0, 0xc0, 0x4f, 0xc2, 0x8a, 0xca);
//@@END_MSINTERNAL

#if DIRECTSOUND_VERSION >= 0x0800

//
// DirectSound Internal Effect Algorithms
//

//@@BEGIN_MSINTERNAL
// Buffer Send {EF602176-BCBB-49E0-8CCA-E09A5A152B33}
DEFINE_GUID(GUID_DSFX_SEND, 0xef602176, 0xbcbb, 0x49e0, 0x8c, 0xca, 0xe0, 0x9a, 0x5a, 0x15, 0x2b, 0x33);
//@@END_MSINTERNAL

// Gargle {DAFD8210-5711-4B91-9FE3-F75B7AE279BF}
DEFINE_GUID(GUID_DSFX_STANDARD_GARGLE, 0xdafd8210, 0x5711, 0x4b91, 0x9f, 0xe3, 0xf7, 0x5b, 0x7a, 0xe2, 0x79, 0xbf);

// Chorus {EFE6629C-81F7-4281-BD91-C9D604A95AF6}
DEFINE_GUID(GUID_DSFX_STANDARD_CHORUS, 0xefe6629c, 0x81f7, 0x4281, 0xbd, 0x91, 0xc9, 0xd6, 0x04, 0xa9, 0x5a, 0xf6);

// Flanger {EFCA3D92-DFD8-4672-A603-7420894BAD98}
DEFINE_GUID(GUID_DSFX_STANDARD_FLANGER, 0xefca3d92, 0xdfd8, 0x4672, 0xa6, 0x03, 0x74, 0x20, 0x89, 0x4b, 0xad, 0x98);

// Echo/Delay {EF3E932C-D40B-4F51-8CCF-3F98F1B29D5D}
DEFINE_GUID(GUID_DSFX_STANDARD_ECHO, 0xef3e932c, 0xd40b, 0x4f51, 0x8c, 0xcf, 0x3f, 0x98, 0xf1, 0xb2, 0x9d, 0x5d);

// Distortion {EF114C90-CD1D-484E-96E5-09CFAF912A21}
DEFINE_GUID(GUID_DSFX_STANDARD_DISTORTION, 0xef114c90, 0xcd1d, 0x484e, 0x96, 0xe5, 0x09, 0xcf, 0xaf, 0x91, 0x2a, 0x21);

// Compressor/Limiter {EF011F79-4000-406D-87AF-BFFB3FC39D57}
DEFINE_GUID(GUID_DSFX_STANDARD_COMPRESSOR, 0xef011f79, 0x4000, 0x406d, 0x87, 0xaf, 0xbf, 0xfb, 0x3f, 0xc3, 0x9d, 0x57);

// Parametric Equalization {120CED89-3BF4-4173-A132-3CB406CF3231}
DEFINE_GUID(GUID_DSFX_STANDARD_PARAMEQ, 0x120ced89, 0x3bf4, 0x4173, 0xa1, 0x32, 0x3c, 0xb4, 0x06, 0xcf, 0x32, 0x31);

//@@BEGIN_MSINTERNAL
// I3DL2 Environmental Reverberation: Source Effect {EFBA364A-E606-451C-8E97-07D508119C65}
///DEFINE_GUID(GUID_DSFX_STANDARD_I3DL2SOURCE, 0xefba364a, 0xe606, 0x451c, 0x8e, 0x97, 0x07, 0xd5, 0x08, 0x11, 0x9c, 0x65);
//@@END_MSINTERNAL

// I3DL2 Environmental Reverberation: Reverb (Listener) Effect {EF985E71-D5C7-42D4-BA4D-2D073E2E96F4}
DEFINE_GUID(GUID_DSFX_STANDARD_I3DL2REVERB, 0xef985e71, 0xd5c7, 0x42d4, 0xba, 0x4d, 0x2d, 0x07, 0x3e, 0x2e, 0x96, 0xf4);

// Waves Reverberation {87FC0268-9A55-4360-95AA-004A1D9DE26C}
DEFINE_GUID(GUID_DSFX_WAVES_REVERB, 0x87fc0268, 0x9a55, 0x4360, 0x95, 0xaa, 0x00, 0x4a, 0x1d, 0x9d, 0xe2, 0x6c);

//
// DirectSound Capture Effect Algorithms
//

//@@BEGIN_MSINTERNAL
// Microphone Array Processor {830A44f2-A32D-476B-BE97-42845673B35A}
// Matches KSNODETYPE_MICROPHONE_ARRAY_PROCESSOR in ksmedia.h
DEFINE_GUID(GUID_DSCFX_CLASS_MA, 0x830A44F2, 0xA32D, 0x476B,  0xBE, 0x97, 0x42, 0x84, 0x56, 0x73, 0xB3, 0x5A);

// Microsoft Microphone Array Processor {F4A49496-1481-44d7-9C4E-A0269CAF0597}
DEFINE_GUID(GUID_DSCFX_MS_MA, 0xF4A49496, 0x1481, 0x44d7, 0x9C, 0x4E, 0xA0, 0x26, 0x9C, 0xAF, 0x5, 0x97);

// System Microphone Array Processor {B6F5A0A0-9E61-4f8c-91E3-76CF0F3C471F}
DEFINE_GUID(GUID_DSCFX_SYSTEM_MA, 0xB6F5A0A0, 0x9E61, 0x4F8C, 0x91, 0xE3, 0x76, 0xCF, 0xF, 0x3C, 0x47, 0x1F );

// Automatic Gain Control {E88C9BA0-C557-11D0-8A2B-00A0C9255AC1}
// Matches KSNODETYPE_AGC in ksmedia.h
DEFINE_GUID(GUID_DSCFX_CLASS_AGC, 0xE88C9BA0L, 0xC557, 0x11D0, 0x8A, 0x2B, 0x00, 0xA0, 0xC9, 0x25, 0x5A, 0xC1);

// Microsoft Automatic Gain Control {5A86531E-8E2A-419f-B4CC-18EB8E891796}
DEFINE_GUID(GUID_DSCFX_MS_AGC, 0x5a86531e, 0x8e2a, 0x419f, 0xb4, 0xcc, 0x18, 0xeb, 0x8e, 0x89, 0x17, 0x96);

// System Automatic Gain Control {950E55B9-877C-4c67-BE08-E47B5611130A}
DEFINE_GUID(GUID_DSCFX_SYSTEM_AGC, 0x950e55b9, 0x877c, 0x4c67, 0xbe, 0x8, 0xe4, 0x7b, 0x56, 0x11, 0x13, 0xa);
//@@END_MSINTERNAL

// Acoustic Echo Canceller {BF963D80-C559-11D0-8A2B-00A0C9255AC1}
// Matches KSNODETYPE_ACOUSTIC_ECHO_CANCEL in ksmedia.h
DEFINE_GUID(GUID_DSCFX_CLASS_AEC, 0xBF963D80L, 0xC559, 0x11D0, 0x8A, 0x2B, 0x00, 0xA0, 0xC9, 0x25, 0x5A, 0xC1);

// Microsoft AEC {CDEBB919-379A-488a-8765-F53CFD36DE40}
DEFINE_GUID(GUID_DSCFX_MS_AEC, 0xcdebb919, 0x379a, 0x488a, 0x87, 0x65, 0xf5, 0x3c, 0xfd, 0x36, 0xde, 0x40);

// System AEC {1C22C56D-9879-4f5b-A389-27996DDC2810}
DEFINE_GUID(GUID_DSCFX_SYSTEM_AEC, 0x1c22c56d, 0x9879, 0x4f5b, 0xa3, 0x89, 0x27, 0x99, 0x6d, 0xdc, 0x28, 0x10);

// Noise Supression {E07F903F-62FD-4e60-8CDD-DEA7236665B5}
// Matches KSNODETYPE_NOISE_SUPPRESS in post Windows ME DDK's ksmedia.h
DEFINE_GUID(GUID_DSCFX_CLASS_NS, 0xe07f903f, 0x62fd, 0x4e60, 0x8c, 0xdd, 0xde, 0xa7, 0x23, 0x66, 0x65, 0xb5);

// Microsoft Noise Suppresion {11C5C73B-66E9-4ba1-A0BA-E814C6EED92D}
DEFINE_GUID(GUID_DSCFX_MS_NS, 0x11c5c73b, 0x66e9, 0x4ba1, 0xa0, 0xba, 0xe8, 0x14, 0xc6, 0xee, 0xd9, 0x2d);

// System Noise Suppresion {5AB0882E-7274-4516-877D-4EEE99BA4FD0}
DEFINE_GUID(GUID_DSCFX_SYSTEM_NS, 0x5ab0882e, 0x7274, 0x4516, 0x87, 0x7d, 0x4e, 0xee, 0x99, 0xba, 0x4f, 0xd0);

#endif // DIRECTSOUND_VERSION >= 0x0800

#endif // __DSOUND_INCLUDED__


//@@BEGIN_MSINTERNAL

#ifndef __DSOUNDP_INCLUDED__
#define __DSOUNDP_INCLUDED__

#if DIRECTSOUND_VERSION >= 0x0800

//
// Private DirectSound interfaces used by DMusic, DPlayVoice, etc.
// Eventually much of the MSINTERNAL stuff above should migrate here.
//

#ifdef __cplusplus
struct IDirectSoundPrivate;
struct IDirectSoundSynthSink;
struct IDirectSoundConnect;
struct IDirectSoundSinkSync;
struct IDirectSoundSource;
struct IDirectSoundWave;
#endif // __cplusplus

#define IDirectSoundPrivate8          IDirectSoundPrivate
#define IDirectSoundSynthSink8        IDirectSoundSynthSink
#define IDirectSoundConnect8          IDirectSoundConnect
#define IDirectSoundSinkSync8         IDirectSoundSinkSync
#define IDirectSoundSource8           IDirectSoundSource
#define IDirectSoundWave8             IDirectSoundWave

#define IID_IDirectSoundPrivate8      IID_IDirectSoundPrivate
#define IID_IDirectSoundSynthSink8    IID_IDirectSoundSynthSink
#define IID_IDirectSoundConnect8      IID_IDirectSoundConnect
#define IID_IDirectSoundSinkSync8     IID_IDirectSoundSinkSync
#define IID_IDirectSoundSource8       IID_IDirectSoundSource
#define IID_IDirectSoundWave8         IID_IDirectSoundWave

typedef struct IDirectSoundPrivate    *LPDIRECTSOUNDPRIVATE;
typedef struct IDirectSoundSynthSink  *LPDIRECTSOUNDSYNTHSINK;
typedef struct IDirectSoundConnect    *LPDIRECTSOUNDCONNECT;
typedef struct IDirectSoundSinkSync   *LPDIRECTSOUNDSINKSYNC;
typedef struct IDirectSoundSource     *LPDIRECTSOUNDSOURCE;
typedef struct IDirectSoundWave       *LPDIRECTSOUNDWAVE;

typedef struct IDirectSoundPrivate8   *LPDIRECTSOUNDPRIVATE8;
typedef struct IDirectSoundSynthSink8 *LPDIRECTSOUNDSYNTHSINK8;
typedef struct IDirectSoundConnect8   *LPDIRECTSOUNDCONNECT8;
typedef struct IDirectSoundSinkSync8  *LPDIRECTSOUNDSINKSYNC8;
typedef struct IDirectSoundSource8    *LPDIRECTSOUNDSOURCE8;
typedef struct IDirectSoundWave8      *LPDIRECTSOUNDWAVE8;

//
// IDirectSoundPrivate: used by DirectMusic to create DirectSoundSink objects
//

DEFINE_GUID(IID_IDirectSoundPrivate, 0xd6e525ae, 0xb125, 0x4ec4, 0xbe, 0x13, 0x12, 0x6d, 0x0c, 0xf7, 0xaf, 0xb6);

#undef INTERFACE
#define INTERFACE IDirectSoundPrivate

DECLARE_INTERFACE_(IDirectSoundPrivate, IUnknown)
{
    // IUnknown methods
    STDMETHOD(QueryInterface)       (THIS_ REFIID, LPVOID FAR *) PURE;
    STDMETHOD_(ULONG,AddRef)        (THIS) PURE;
    STDMETHOD_(ULONG,Release)       (THIS) PURE;

    // IDirectSoundPrivate methods
    STDMETHOD(AllocSink)            (THIS_ LPWAVEFORMATEX pwfxFormat, LPDIRECTSOUNDCONNECT *ppSinkConnect) PURE;
};

#define IDirectSoundPrivate_QueryInterface(p,a,b)       IUnknown_QueryInterface(p,a,b)
#define IDirectSoundPrivate_AddRef(p)                   IUnknown_AddRef(p)
#define IDirectSoundPrivate_Release(p)                  IUnknown_Release(p)

#if !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectSoundPrivate_AllocSink(p,a,b)            (p)->lpVtbl->AllocSink(p,a,b)
#else // !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectSoundPrivate_AllocSink(p,a,b)            (p)->AllocSink(a,b)
#endif // !defined(__cplusplus) || defined(CINTERFACE)

//
// IDirectSoundSynthSink: used by the DirectMusic synthesiser
//

DEFINE_GUID(IID_IDirectSoundSynthSink, 0x73a6a85a, 0x493e, 0x4c87, 0xb4, 0xa5, 0xbe, 0x53, 0xeb, 0x92, 0x74, 0x4b);

#undef INTERFACE
#define INTERFACE IDirectSoundSynthSink

DECLARE_INTERFACE_(IDirectSoundSynthSink, IUnknown)
{
    // IUnknown methods
    STDMETHOD(QueryInterface)       (THIS_ REFIID, LPVOID FAR *) PURE;
  