D))
	msoridPhdSettingsCamera,
#endif
#if (defined(PHOTODRAW_BUILD))
	msoridPhdDefaultCamera,
#endif
#if (defined(PHOTODRAW_BUILD))
	msoridPhdDefaultOtherDevice,
#endif
#if (defined(PHOTODRAW_BUILD))
	msoridPhdLoadedAddons,
#endif
#if (defined(PHOTODRAW_BUILD))
	msoridPhdLoadedAddonsSimpleCommands,
#endif
#if (defined(PHOTODRAW_BUILD))
	msoridPhdLoadedAddonsCacheValid,
#endif
#if ((defined(EXCEL_BUILD) && defined(XL)))
	msoridExcelSortTextAsNumbers,
#endif
#if (defined(DESIGNER_BUILD))
	msoridDsrEditorType,
#endif
#if ((defined(EXCEL_BUILD) && defined(XL)) || defined(SETLANG_BUILD))
	msoridExcelLastUILang,
#endif
#if (defined(SETLANG_BUILD) || defined(DESIGNER_BUILD))
	msoridDesignerLastUILang,
#endif
#if (defined(WORD_BUILD) || defined(SETLANG_BUILD))
	msoridWordLastUILang,
#endif
#if (defined(ACCESS_BUILD) || defined(SETLANG_BUILD))
	msoridAccessLastUILang,
#endif
#if (defined(PPT_BUILD) || defined(SETLANG_BUILD))
	msoridPPTLastUILang,
#endif
#if (defined(OUTLOOK_BUILD) || defined(SETLANG_BUILD))
	msoridOutlookLastUILang,
#endif
#if (defined(PUBLISHER_BUILD) || defined(SETLANG_BUILD))
	msoridPublisherLastUILang,
#endif
#if ( (defined(VSMSODEBUG)) && (defined(WORD_BUILD)) )
	msoridWordFReports,
#endif
#if (defined(WORD_BUILD))
	msoridWordAskPrnPict,
#endif
#if (defined(WORD_BUILD))
	msoridWordCacheSize,
#endif
#if (defined(WORD_BUILD))
	msoridWordBmpMem,
#endif
#if ( (defined(VSMSODEBUG)) && (defined(WORD_BUILD)) )
	msoridWordFieldTableSave,
#endif
#if ( (defined(VSMSODEBUG)) && (defined(WORD_BUILD)) )
	msoridWordFieldTableLoad,
#endif
#if (defined(WORD_BUILD))
	msoridWordQuickPreview,
#endif
#if (defined(WORD_BUILD) || (defined(EXCEL_BUILD) && defined(XL)) || defined(PPT_BUILD) || defined(OUTLOOK_BUILD))
	msoridOriginalAttachmentPath,
#endif
#if (defined(WORD_BUILD) || (defined(EXCEL_BUILD) && defined(XL)) || defined(PPT_BUILD) || defined(OUTLOOK_BUILD))
	msoridTemporaryAttachmentName,
#endif
#if (defined(WORD_BUILD) || defined(OUTLOOK_BUILD))
	msoridMailIgnoreReplySpelling,
#endif
#if (defined(OUTLOOK_BUILD))
	msoridOutlookCUApptColor1,
#endif
#if (defined(OUTLOOK_BUILD))
	msoridOutlookCUApptColor2,
#endif
#if (defined(OUTLOOK_BUILD))
	msoridOutlookCUApptColor3,
#endif
#if (defined(OUTLOOK_BUILD))
	msoridOutlookCUApptColor4,
#endif
#if (defined(OUTLOOK_BUILD))
	msoridOutlookCUApptColor5,
#endif
#if (defined(OUTLOOK_BUILD))
	msoridOutlookCUApptColor6,
#endif
#if (defined(OUTLOOK_BUILD))
	msoridOutlookCUApptColor7,
#endif
#if (defined(OUTLOOK_BUILD))
	msoridOutlookCUApptColor8,
#endif
#if (defined(OUTLOOK_BUILD))
	msoridOutlookCUApptColor9,
#endif
#if (defined(OUTLOOK_BUILD))
	msoridOutlookCUApptColor10,
#endif
#if (defined(PPT_BUILD))
	msoridPptTipsHistory,
#endif
#if (defined(DESIGNER_BUILD))
	msoridDesignerUserData,
#endif
#if (defined(OSB_BUILD))
	msoridOSBRefresh,
#endif
#if ((defined(EXCEL_BUILD) && defined(XL)) || defined(OUTLOOK_BUILD))
	msoridCollabExcelUnsharedWorkbookPrompt,
#endif
#if (defined(OFFICE_BUILD))
	msoridSignatureDefaults,
#endif
#if ( (defined(VSMSODEBUG)) && (defined(OFFICE_BUILD)) )
	msoridDisableFbc,
#endif
#if (defined(OUTLOOK_BUILD))
	msoridOutlookCUP2WBgGraphic,
#endif
#if (defined(OUTLOOK_BUILD))
	msoridOutlookCUP2WFileName,
#endif
#if (defined(OUTLOOK_BUILD))
	msoridOutlookCUP2WShowDetails,
#endif
#if (defined(OUTLOOK_BUILD))
	msoridOutlookCUP2WUseBgGraphic,
#endif
#if (defined(OUTLOOK_BUILD))
	msoridOutlookCUP2WCalTitle,
#endif
#if ( (defined(VSMSODEBUG)) && (defined(OFFICE_BUILD)) )
	msoridDebugAppServer,
#endif
#if ( (defined(VSMSODEBUG)) && (defined(OFFICE_BUILD)) )
	msoridDebugRemoteUI,
#endif
#if (defined(OFFICE_BUILD))
	msoridSoftClientsMail,
#endif
#if (defined(OFFICE_BUILD))
	msoridTempProductKey,
#endif
#if (defined(OFFICE_BUILD))
	msoridGlobalMRU,
#endif
#if (defined(OUTLOOK_BUILD))
	msoridOutlookSecureTempFolder,
#endif
#if (defined(OFFICE_BUILD))
	msoridLMRegistrationHook,
#endif
#if (defined(OFFICE_BUILD))
	msoridCommonLMHook,
#endif
#if (defined(OFFICE_BUILD))
	msoridCounterCU,
#endif
#if (defined(OFFICE_BUILD))
	msoridCounterLM,
#endif
#if (defined(OFFICE_BUILD))
	msoridClockTamperingLM,
#endif
#if (defined(OFFICE_BUILD))
	msoridOfficeUpTimeLM,
#endif
#if (defined(OFFICE_BUILD))
	msoridClockBootHistoryLM,
#endif
#if (defined(OFFICE_BUILD))
	msoridLicenseSelCache,
#endif
#if (defined(OFFICE_BUILD))
	msoridOfficeInstallCount,
#endif
#if (defined(OFFICE_BUILD))
	msoridLicenseStorePath,
#endif
#if (defined(OFFICE_BUILD) || defined(WORD_BUILD))
	msoridIMEUseAIMM12,
#endif
#if ((defined(EXCEL_BUILD) && defined(XL)))
	msoridExcelWebQueryHomePage,
#endif
#if (defined(PPT_BUILD))
	msoridPPTOptionAfaytBullets,
#endif
#if (defined(PPT_BUILD))
	msoridPPTOptionAfaytFractions,
#endif
#if (defined(PPT_BUILD))
	msoridPPTOptionAfaytHyperlink,
#endif
#if (defined(PPT_BUILD))
	msoridPPTOptionAfaytOrdinals,
#endif
#if (defined(PPT_BUILD))
	msoridPPTOptionAfaytSmiley,
#endif
#if (defined(PPT_BUILD))
	msoridPPTOptionAfaytSymbols,
#endif
#if (defined(OFFICE_BUILD))
	msoridLMCryptDefProv,
#endif
#if (defined(OFFICE_BUILD))
	msoridDisableCustomEncryption,
#endif
#if (defined(OFFICE_BUILD))
	msoridOfficeSecurity,
#endif
#if (defined(OFFICE_BUILD))
	msoridSearchInstallPath,
#endif
#if (defined(OFFICE_BUILD))
	msoridRunServicesMOSearch,
#endif
#if (defined(OFFICE_BUILD))
	msoridAsstWebAddress,
#endif
#if ((defined(EXCEL_BUILD) && defined(XL)) || defined(PPT_BUILD))
	msoridOfficePublishFormat,
#endif
#if (defined(PPT_BUILD))
	msoridPowerPointAllowNonV4MHTML,
#endif
#if ((defined(EXCEL_BUILD) && defined(XL)))
	msoridExcelErrChkBackground,
#endif
#if ((defined(EXCEL_BUILD) && defined(XL)))
	msoridExcelErrChkEvalError,
#endif
#if ((defined(EXCEL_BUILD) && defined(XL)))
	msoridExcelErrChkTextDate,
#endif
#if ((defined(EXCEL_BUILD) && defined(XL)))
	msoridExcelErrChkNumAsText,
#endif
#if ((defined(EXCEL_BUILD) && defined(XL)))
	msoridExcelErrChkInconsistFmla,
#endif
#if ((defined(EXCEL_BUILD) && defined(XL)))
	msoridExcelErrChkOmittedCells,
#endif
#if ((defined(EXCEL_BUILD) && defined(XL)))
	msoridExcelErrChkUnlockedFmla,
#endif
#if ((defined(EXCEL_BUILD) && defined(XL)))
	msoridExcelErrChkEmptyCellRef,
#endif
#if (defined(OFFICE_BUILD) || defined(SETLANG_BUILD))
	msoridPreviousInstall,
#endif
#if (defined(OFFICE_BUILD) || defined(SETLANG_BUILD))
	msoridSKULanguage,
#endif
#if (defined(OFFICE_BUILD) || defined(SETLANG_BUILD))
	msoridWebLocale,
#endif
#if (defined(OFFICE_BUILD) || defined(SETLANG_BUILD))
	msoridDesignerChangeInstallLanguage,
#endif
#if (defined(OFFICE_BUILD) || defined(SETLANG_BUILD))
	msoridWordChangeInstallLanguage,
#endif
#if (defined(OFFICE_BUILD) || defined(SETLANG_BUILD))
	msoridXLChangeInstallLanguage,
#endif
#if (defined(OFFICE_BUILD) || defined(SETLANG_BUILD))
	msoridPPTChangeInstallLanguage,
#endif
#if (defined(OFFICE_BUILD) || defined(SETLANG_BUILD))
	msoridAccessChangeInstallLanguage,
#endif
#if (defined(OFFICE_BUILD) || defined(OUTLOOK_BUILD) || defined(SETLANG_BUILD))
	msoridOutlookChangeInstallLanguage,
#endif
#if (defined(OFFICE_BUILD) || defined(SETLANG_BUILD))
	msoridFrontPageChangeInstallLanguage,
#endif
#if (defined(SETLANG_BUILD))
	msoridPhotoDrawChangeInstallLanguage,
#endif
#if (defined(OFFICE_BUILD) || defined(SETLANG_BUILD))
	msoridPublisherChangeInstallLanguage,
#endif
#if (defined(OFFICE_BUILD) || defined(SETLANG_BUILD))
	msoridProjectChangeInstallLanguage,
#endif
#if (defined(OFFICE_BUILD))
	msoridOfficeOpenFindCenterX,
#endif
#if (defined(OFFICE_BUILD))
	msoridOfficeOpenFindCenterY,
#endif
#if (defined(OFFICE_BUILD))
	msoridACIac,
#endif
#if (defined(OFFICE_BUILD))
	msoridACExAutoOC,
#endif
#if (defined(OFFICE_BUILD))
	msoridReviewDefaultSubject,
#endif
#if (defined(OFFICE_BUILD))
	msoridAttachmentBody,
#endif
#if (defined(OFFICE_BUILD))
	msoridLinkBody,
#endif
#if (defined(OFFICE_BUILD))
	msoridLinkPlusAttachmentBody,
#endif
#if (defined(OFFICE_BUILD))
	msoridLinkPlusDiscussionsBody,
#endif
#if (defined(OFFICE_BUILD))
	msoridLinkPlusDiscussionsPlusAttachmentBody,
#endif
#if (defined(OFFICE_BUILD))
	msoridLinkPlusDiscussionsReply,
#endif
#if (defined(OFFICE_BUILD))
	msoridLinkReply,
#endif
#if (defined(OFFICE_BUILD))
	msoridAttachmentReply,
#endif
#if (defined(OFFICE_BUILD) || defined(WORD_BUILD) || (defined(EXCEL_BUILD) && defined(XL)) || defined(PPT_BUILD) || defined(FRONTPAGE_BUILD))
	msoridPasteRecovery,
#endif
#if (defined(ACCESS_BUILD))
	msoridAccPromptDAPJetLocalPaths,
#endif
#if (defined(OFFICE_BUILD))
	msoridClassElm,
#endif
#if (defined(ACCESS_BUILD) || defined(PUBLISHER_BUILD))
	msoridElmfileShellOpenCommand,
#endif
#if (defined(OFFICE_BUILD))
	msoridAdHocReviewMaxDocSlots,
#endif
#if (defined(OUTLOOK_BUILD))
	msoridAdHocReviewBehavior,
#endif
#if (defined(OFFICE_BUILD) || defined(OUTLOOK_BUILD))
	msoridExplicitReviewBehavior,
#endif
#if (defined(OFFICE_BUILD))
	msoridScreenReaderPresent,
#endif
#if (defined(OUTLOOK_BUILD))
	msoridOutlookMigration,
#endif
#if (defined(OFFICE_BUILD))
	msoridLicOSACompIDKey,
#endif
#if (defined(OFFICE_BUILD))
	msoridLicRenewRegisterURL,
#endif
#if ((defined(EXCEL_BUILD) && defined(XL)))
	msoridExcelOLAPVersionDep,
#endif
#if ((defined(EXCEL_BUILD) && defined(XL)))
	msoridExcelPivotTableNetworkResiliency,
#endif
#if ( (defined(VSMSODEBUG)) && (defined(OFFICE_BUILD)) )
	msoridOOCLightTcidOffsetFactoid,
#endif
#if ( (defined(VSMSODEBUG)) && (defined(OFFICE_BUILD)) )
	msoridOOCHeavyTcidOffsetFactoid,
#endif
#if ( (defined(VSMSODEBUG)) && (defined(OFFICE_BUILD)) )
	msoridOOCDefPosFactoid,
#endif
#if (defined(OFFICE_BUILD))
	msoridAccessStartWorking,
#endif
#if (defined(OFFICE_BUILD))
	msoridExcelStartWorking,
#endif
#if (defined(OFFICE_BUILD))
	msoridFrontPageStartWorking,
#endif
#if (defined(OFFICE_BUILD))
	msoridPowerPointStartWorking,
#endif
#if (defined(OFFICE_BUILD))
	msoridWordStartWorking,
#endif
#if (defined(OFFICE_BUILD))
	msoridPolicyAccessStartWorking,
#endif
#if (defined(OFFICE_BUILD))
	msoridPolicyExcelStartWorking,
#endif
#if (defined(OFFICE_BUILD))
	msoridPolicyFrontPageStartWorking,
#endif
#if (defined(OFFICE_BUILD))
	msoridPolicyPowerPointStartWorking,
#endif
#if (defined(OFFICE_BUILD))
	msoridPolicyWordStartWorking,
#endif
#if (defined(PPT_BUILD))
	msoridPPTOptionAutoKeyboardSwitch,
#endif
#if ((defined(EXCEL_BUILD) && defined(XL)))
	msoridExcelAutoRecoverDelay,
#endif
#if (defined(PUBLISHER_BUILD))
	msoridPublisherPrefFontscmOptions,
#endif
#if (defined(OFFICE_BUILD))
	msoridOfficeWebComponent,
#endif
#if (defined(OFFICE_BUILD))
	msoridWebComponentNavigation,
#endif
#if (defined(OFFICE_BUILD))
	msoridWebComponentListView,
#endif
#if (defined(PPT_BUILD))
	msoridPPTOptionACDlgCurTab,
#endif
#if (defined(OFFICE_BUILD) || defined(PUBLISHER_BUILD))
	msoridACShowAutoFineTuner,
#endif
#if (defined(OUTLOOK_BUILD))
	msoridSowFbSignupAlert,
#endif
#if (defined(OUTLOOK_BUILD))
	msoridSowFbRequestFb,
#endif
#if ( (defined(VSMSODEBUG)) && (defined(OUTLOOK_BUILD)) )
	msoridSowFbDisableContacts,
#endif
#if (defined(WORD_BUILD))
	msoridWordOptionsAssistWM,
#endif
#if ((defined(EXCEL_BUILD) && defined(XL)))
	msoridPrefACHyperlink,
#endif
#if (defined(OFFICE_BUILD))
	msoridOOCAnimAuto,
#endif
#if (defined(OFFICE_BUILD))
	msoridOOCAnimPaste,
#endif
#if (defined(OFFICE_BUILD))
	msoridOOCAnimXLErr,
#endif
#if (defined(OFFICE_BUILD))
	msoridOOCAnimXLIns,
#endif
#if (defined(OFFICE_BUILD))
	msoridOOCAnimFact,
#endif
#if (defined(OFFICE_BUILD))
	msoridOOCAnimAFit,
#endif
#if (defined(OFFICE_BUILD))
	msoridOOCAnimAutoList,
#endif
#if (defined(OFFICE_BUILD))
	msoridOOCAnimDragFill,
#endif
#if (defined(OFFICE_BUILD))
	msoridOOCAnimHL,
#endif
#if (defined(OFFICE_BUILD))
	msoridOOCAnimAFlow,
#endif
#if (defined(OFFICE_BUILD))
	msoridOOCAnimPictResize,
#endif
#if (defined(OFFICE_BUILD))
	msoridOOCAnimOther,
#endif
#if (defined(OFFICE_BUILD))
	msoridOOCMaxLoops,
#endif
#if (defined(ACCESS_BUILD))
	msoridAccDefaultFileFmt,
#endif
#if (defined(OFFICE_BUILD))
	msoridCUExplorer,
#endif
#if (defined(OUTLOOK_BUILD))
	msoridCUExplorerFileExts,
#endif
#if (defined(OFFICE_BUILD))
	msoridOfficeEnableLICTrace,
#endif
#if ( (defined(VSMSODEBUG) || defined(LICENSE_TEST_HARNESS)) && (defined(OFFICE_BUILD)) )
	msoridOfficeEnableHWIDTrace,
#endif
#if ( (defined(LICENSE_TEST_HARNESS)) && (defined(OFFICE_BUILD)) )
	msoridLICTestEnum,
#endif
#if ( (defined(LICENSE_TEST_HARNESS)) && (defined(OFFICE_BUILD)) )
	msoridLICTestDPC,
#endif
#if ( (defined(LICENSE_TEST_HARNESS)) && (defined(OFFICE_BUILD)) )
	msoridLICTestBPC,
#endif
#if ( (defined(LICENSE_TEST_HARNESS)) && (defined(OFFICE_BUILD)) )
	msoridLICTestWizard,
#endif
#if (defined(OFFICE_BUILD))
	msoridLICTestSCP,
#endif
#if ( (defined(LICENSE_TEST_HARNESS)) && (defined(OFFICE_BUILD)) )
	msoridLICDisCount,
#endif
#if ( (defined(LICENSE_TEST_HARNESS)) && (defined(OFFICE_BUILD)) )
	msoridLICDisClock,
#endif
#if ( (defined(LICENSE_TEST_HARNESS)) && (defined(OFFICE_BUILD)) )
	msoridLICTestClock,
#endif
#if ( (defined(LICENSE_TEST_HARNESS)) && (defined(OFFICE_BUILD)) )
	msoridLICTestHWID,
#endif
#if (defined(OFFICE_BUILD))
	msoridLICTestKey,
#endif
#if ( (defined(LICENSE_TEST_HARNESS)) && (defined(OFFICE_BUILD)) )
	msoridLICHwidCDROMDevice,
#endif
#if ( (defined(LICENSE_TEST_HARNESS)) && (defined(OFFICE_BUILD)) )
	msoridLICHwidDiskAdapter,
#endif
#if ( (defined(LICENSE_TEST_HARNESS)) && (defined(OFFICE_BUILD)) )
	msoridLICHwidDiskDevice,
#endif
#if ( (defined(LICENSE_TEST_HARNESS)) && (defined(OFFICE_BUILD)) )
	msoridLICHwidDisplayAdapter,
#endif
#if ( (defined(LICENSE_TEST_HARNESS)) && (defined(OFFICE_BUILD)) )
	msoridLICHwidFirstDriveSerial,
#endif
#if ( (defined(LICENSE_TEST_HARNESS)) && (defined(OFFICE_BUILD)) )
	msoridLICHwidMACAddress,
#endif
#if ( (defined(LICENSE_TEST_HARNESS)) && (defined(OFFICE_BUILD)) )
	msoridLICHwidProcessorSerial,
#endif
#if ( (defined(LICENSE_TEST_HARNESS)) && (defined(OFFICE_BUILD)) )
	msoridLICHwidProcessorType,
#endif
#if ( (defined(LICENSE_TEST_HARNESS)) && (defined(OFFICE_BUILD)) )
	msoridLICHwidRAMSizeMb,
#endif
#if ( (defined(LICENSE_TEST_HARNESS)) && (defined(OFFICE_BUILD)) )
	msoridLICHwidSCSIAdapter,
#endif
#if (defined(OFFICE_BUILD))
	msoridOfficeAuditMode,
#endif
#if ((defined(EXCEL_BUILD) && defined(XL)))
	msoridGenerateGetPivotDataXL,
#endif
#if (defined(ACCESS_BUILD))
	msoridAccSectionIndent,
#endif
#if (defined(ACCESS_BUILD))
	msoridAccAlternateRowColor,
#endif
#if (defined(ACCESS_BUILD))
	msoridAccCaptionSectionStyle,
#endif
#if (defined(ACCESS_BUILD))
	msoridAccFooterSectionStyle,
#endif
#if (defined(OFFICE_BUILD))
	msoridOfficeSymbolMRU,
#endif
#if (defined(PHOTODRAW_BUILD))
	msoridPhd1SettingsUILanuage,
#endif
#if (defined(PHOTODRAW_BUILD))
	msoridPhd1SettingsFillColor,
#endif
#if (defined(PHOTODRAW_BUILD))
	msoridPhd1SettingsLineColor,
#endif
#if (defined(PHOTODRAW_BUILD))
	msoridPhd1SettingsGettingStartedDialogSelection,
#endif
#if (defined(PHOTODRAW_BUILD))
	msoridPhd1SettingsGettingStartedDialog,
#endif
#if (defined(PHOTODRAW_BUILD))
	msoridPhd1SettingsFileNewSelection,
#endif
#if (defined(PHOTODRAW_BUILD))
	msoridPhd1SettingsDisplaySettingsChangeAlert,
#endif
#if (defined(PHOTODRAW_BUILD))
	msoridPhd1SettingsFontPreview,
#endif
#if (defined(PHOTODRAW_BUILD))
	msoridPhd1SettingsHelpfulTips,
#endif
#if (defined(PHOTODRAW_BUILD))
	msoridPhd1SettingsPanZoomColor,
#endif
#if (defined(PHOTODRAW_BUILD))
	msoridPhd1SettingsUserName,
#endif
#if (defined(PHOTODRAW_BUILD))
	msoridPhd1SettingsFileMRUListMaxCount,
#endif
#if (defined(PHOTODRAW_BUILD))
	msoridPhd1SettingsIntelliMouseWheelAction,
#endif
#if (defined(PHOTODRAW_BUILD))
	msoridPhd1SettingsSmallNudgePixels,
#endif
#if (defined(PHOTODRAW_BUILD))
	msoridPhd1SettingsLargeNudgePixels,
#endif
#if (defined(PHOTODRAW_BUILD))
	msoridPhd1SettingsLargeIcons,
#endif
#if (defined(PHOTODRAW_BUILD))
	msoridPhd1SettingsScreenTips,
#endif
#if (defined(PHOTODRAW_BUILD))
	msoridPhd1SettingsShortcutsInScreenTips,
#endif
#if (defined(PHOTODRAW_BUILD))
	msoridPhd1SettingsMenuAnimation,
#endif
#if (defined(PHOTODRAW_BUILD))
	msoridPhd1SettingsShouldPromptForCD,
#endif
#if (defined(PHOTODRAW_BUILD))
	msoridPhd1SettingsQuality,
#endif
#if (defined(PHOTODRAW_BUILD))
	msoridPhd1SettingsCompressionLevel,
#endif
#if (defined(PHOTODRAW_BUILD))
	msoridPhd2SettingsAdditionalPluginPath,
#endif
#if (defined(PHOTODRAW_BUILD))
	msoridPhd2SettingsCompressionLevel,
#endif
#if (defined(PHOTODRAW_BUILD))
	msoridPhd2SettingsDisplaySettingsChangeAlert,
#endif
#if (defined(PHOTODRAW_BUILD))
	msoridPhd2SettingsFileMRUList,
#endif
#if (defined(PHOTODRAW_BUILD))
	msoridPhd2SettingsFillColor,
#endif
#if (defined(PHOTODRAW_BUILD))
	msoridPhd2SettingsFontPreview,
#endif
#if (defined(PHOTODRAW_BUILD))
	msoridPhd2SettingsGettingStartedDialog,
#endif
#if (defined(PHOTODRAW_BUILD))
	msoridPhd2SettingsGridHorizontalSpacing,
#endif
#if (defined(PHOTODRAW_BUILD))
	msoridPhd2SettingsGridVerticalSpacing,
#endif
#if (defined(PHOTODRAW_BUILD))
	msoridPhd2SettingsHelpfulTips,
#endif
#if (defined(PHOTODRAW_BUILD))
	msoridPhd2SettingsIntelliMouseWheelAction,
#endif
#if (defined(PHOTODRAW_BUILD))
	msoridPhd2SettingsUILanguage,
#endif
#if (defined(PHOTODRAW_BUILD))
	msoridPhd2SettingsLargeIcons,
#endif
#if (defined(PHOTODRAW_BUILD))
	msoridPhd2SettingsLargeNudgePixels,
#endif
#if (defined(PHOTODRAW_BUILD))
	msoridPhd2SettingsLineColor,
#endif
#if (defined(PHOTODRAW_BUILD))
	msoridPhd2SettingsLockPictureGuides,
#endif
#if (defined(PHOTODRAW_BUILD))
	msoridPhd2SettingsMenuAnimation,
#endif
#if (defined(PHOTODRAW_BUILD))
	msoridPhd2SettingsNewPaperColor,
#endif
#if (defined(PHOTODRAW_BUILD))
	msoridPhd2SettingsNewPictureHeight,
#endif
#if (defined(PHOTODRAW_BUILD))
	msoridPhd2SettingsNewPictureWidth,
#endif
#if (defined(PHOTODRAW_BUILD))
	msoridPhd2SettingsPanZoomColor,
#endif
#if (defined(PHOTODRAW_BUILD))
	msoridPhd2SettingsPicturesPath,
#endif
#if (defined(PHOTODRAW_BUILD))
	msoridPhd2SettingsPrintStruct,
#endif
#if (defined(PHOTODRAW_BUILD))
	msoridPhd2SettingsPrintToFileDir,
#endif
#if (defined(PHOTODRAW_BUILD))
	msoridPhd2SettingsQuality,
#endif
#if (defined(PHOTODRAW_BUILD))
	msoridPhd2SettingsRemoteCDPath,
#endif
#if (defined(PHOTODRAW_BUILD))
	msoridPhd2SettingsScreenTips,
#endif
#if (defined(PHOTODRAW_BUILD))
	msoridPhd2SettingsShortcutsInScreenTips,
#endif
#if (defined(PHOTODRAW_BUILD))
	msoridPhd2SettingsShouldPromptForCD,
#endif
#if (defined(PHOTODRAW_BUILD))
	msoridPhd2SettingsSmallNudgePixels,
#endif
#if (defined(PHOTODRAW_BUILD))
	msoridPhd2SettingsUnitsOfMeasure,
#endif
#if (defined(PHOTODRAW_BUILD))
	msoridPhd2SettingsUserName,
#endif
#if (defined(OFFICE_BUILD))
	msoridJet4TextFormat,
#endif
#if (defined(OFFICE_BUILD))
	msoridJet4TextMaxScanRows,
#endif
#if (defined(OFFICE_BUILD))
	msoridAcbSystrayTips,
#endif
#if (defined(OFFICE_BUILD))
	msoridAcbAlwaysCollect,
#endif
#if (defined(OFFICE_BUILD))
	msoridAcbSystrayIcon,
#endif
#if ((defined(EXCEL_BUILD) && defined(XL)) || (defined(EXCEL_BUILD) && defined(GRAF)))
	msoridDefaultURLPathXL,
#endif
#if (defined(OFFICE_BUILD))
	msoridOfficeUseClearType,
#endif
#if (defined(OFFICE_BUILD))
	msoridShowAllFilesAndFolders,
#endif
#if (defined(OUTLOOK_BUILD))
	msoridEncodingAutodetection,
#endif
#if (defined(OUTLOOK_BUILD))
	msoridAutodetectDowngrade,
#endif
#if (defined(OUTLOOK_BUILD))
	msoridLunarRokuyou,
#endif
#if (defined(OUTLOOK_BUILD))
	msoridRokuyou,
#endif
#if ((defined(EXCEL_BUILD) && defined(XL)))
	msoridExcelFactoidRecognize,
#endif
#if (defined(WORD_BUILD) || (defined(EXCEL_BUILD) && defined(XL)))
	msoridFactoidCheckForNewActions,
#endif
#if (defined(OFFICE_BUILD) || defined(WORD_BUILD))
	msoridFactoidCheckForNewFactoids,
#endif
#if (defined(OFFICE_BUILD))
	msoridNavCurrentVersion,
#endif
#if (defined(OFFICE_BUILD))
	msoridNetNav,
#endif
#if (defined(OFFICE_BUILD))
	msoridNetNavGold,
#endif
#if (defined(OFFICE_BUILD))
	msoridSearchMRU,
#endif
#if (defined(OFFICE_BUILD))
	msoridSearchSearchText,
#endif
#if (defined(PPT_BUILD))
	msoridPPTOptionLargeGalleryPreviews,
#endif
#if ((defined(EXCEL_BUILD) && defined(XL)))
	msoridExcelExtractDataMode,
#endif
#if (defined(CLIPGALLERY_BUILD))
	msoridCAGDefaultView,
#endif
#if (defined(CLIPGALLERY_BUILD))
	msoridCAGWindowPos,
#endif
#if (defined(WORD_BUILD))
	msoridWordMT,
#endif
#if (defined(OFFICE_BUILD))
	msoridExcelProjectTemplateLocation,
#endif
#if (defined(OFFICE_BUILD))
	msoridPowerPointProjectTemplateLocation,
#endif
#if (defined(OFFICE_BUILD))
	msoridWordProjectTemplateLocation,
#endif
#if (defined(OFFICE_BUILD))
	msoridLicenseExpiredCU,
#endif
#if (defined(OFFICE_BUILD))
	msoridCUVbaOff,
#endif
#if (defined(OFFICE_BUILD))
	msoridOfficeTwainDevices,
#endif
#if (defined(OUTLOOK_BUILD))
	msoridMailRTFFmt,
#endif
#if (defined(OFFICE_BUILD))
	msoridSpeechOverrideKeyboard,
#endif
#if (defined(OFFICE_BUILD))
	msoridSpeechOverrideCmdBars,
#endif
#if (defined(OFFICE_BUILD))
	msoridSpeechOverrideShortcuts,
#endif
#if (defined(OFFICE_BUILD))
	msoridSpeechSAPI5CheckOverride,
#endif
#if (defined(ACCESS_BUILD))
	msoridAccDAPWarnMailSecurity,
#endif
#if (defined(OFFICE_BUILD))
	msoridSvcCatalogUrl,
#endif
#if (defined(OFFICE_BUILD))
	msoridDoNotForceUSASCIIForMHTML,
#endif
#if (defined(PPT_BUILD))
	msoridPPTPathToAutoRecoveryInfo,
#endif
#if (defined(OFFICE_BUILD))
	msoridDocsForMergeMaxDocSlots,
#endif
#if (defined(WORD_BUILD))
	msoridOptionsNoPromptToForkDocuments,
#endif
#if (defined(WORD_BUILD))
	msoridSpellSquiggleColor,
#endif
#if (defined(WORD_BUILD))
	msoridGrammarSquiggleColor,
#endif
#if (defined(WORD_BUILD))
	msoridFormatConsistencySquiggleColor,
#endif
#if (defined(OFFICE_BUILD))
	msoridTBTransparent,
#endif
#if (defined(PUBLISHER_BUILD))
	msoridPublisherPrefUpdateStyle,
#endif
#if ((defined(EXCEL_BUILD) && defined(XL)) || (defined(EXCEL_BUILD) && defined(GRAF)))
	msoridExcelOptionsXl9_Hijri,
#endif
#if (defined(OUTLOOK_BUILD))
	msoridOutlookImportPRF,
#endif
#if (defined(OFFICE_BUILD))
	msoridOOCUltraLWColor,
#endif
#if (defined(OFFICE_BUILD))
	msoridOOCLightWidth,
#endif
#if (defined(OFFICE_BUILD))
	msoridOOCLightHeight,
#endif
#if (defined(OFFICE_BUILD))
	msoridCollabReviewToken,
#endif
#if (defined(OFFICE_BUILD))
	msoridResetSettings,
#endif
#if ((defined(EXCEL_BUILD) && defined(XL)))
	msoridDisableAutoRepublishWarning,
#endif
#if ((defined(EXCEL_BUILD) && defined(XL)))
	msoridDisableAutoRepublish,
#endif
#if ((defined(EXCEL_BUILD) && defined(XL)))
	msoridExcelErrChkIndicatorColor,
#endif
#if (defined(ACCESS_BUILD))
	msoridAccessSpellCustomDict,
#endif
#if (defined(ACCESS_BUILD))
	msoridAccessSpellIgnoreAllCaps,
#endif
#if (defined(ACCESS_BUILD))
	msoridAccessSpellIgnoreInternetFileAddress,
#endif
#if (defined(ACCESS_BUILD))
	msoridAccessSpellIgnoreMixedDigits,
#endif
#if (defined(ACCESS_BUILD))
	msoridAccessSpellSuggestMainDictOnly,
#endif
#if (defined(ACCESS_BUILD))
	msoridAccessSpellMainDict,
#endif
#if (defined(OFFICE_BUILD))
	msoridSvWowCMRU,
#endif
#if (defined(OFFICE_BUILD))
	msoridSvWowMRU,
#endif
#if (defined(OUTLOOK_BUILD))
	msoridOutlookInstantMessaging,
#endif
#if (defined(OUTLOOK_BUILD))
	msoridOutlookIMInstallURL,
#endif
#if (defined(OUTLOOK_BUILD))
	msoridOutlookForceDisableIM,
#endif
#if ((defined(EXCEL_BUILD) && defined(XL)))
	msoridExcelSpeakDirection,
#endif
#if (defined(PUBLISHER_BUILD))
	msoridPublisherPrefConvWizRTL,
#endif
#if (defined(OFFICE_BUILD) || defined(CLIPGALLERY_BUILD))
	msoridCagSearchMRU,
#endif
#if (defined(OFFICE_BUILD) || defined(CLIPGALLERY_BUILD))
	msoridCagSearchSearchText,
#endif
#if (defined(OFFICE_BUILD) || defined(CLIPGALLERY_BUILD))
	msoridCagSearchLastQuery,
#endif
#if (defined(PPT_BUILD))
	msoridPPTOptionDisablePasswordUI,
#endif
#if (defined(PPT_BUILD))
	msoridPPTOptionDisableNewAnimationUI,
#endif
#if (defined(ACCESS_BUILD))
	msoridAccPromptDAPsDontRoundTrip,
#endif
#if (defined(OFFICE_BUILD))
	msoridDisableFontLinking,
#endif
#if (defined(OFFICE_BUILD))
	msoridOWSCollabObject,
#endif
#if (defined(OFFICE_BUILD))
	msoridOWSCollabObjects,
#endif
#if (defined(CLIPGALLERY_BUILD))
	msoridCagUserData,
#endif
#if (defined(CLIPGALLERY_BUILD))
	msoridCagCatUserData,
#endif
#if (defined(CLIPGALLERY_BUILD))
	msoridCagWebUserData,
#endif
#if (defined(OFFICE_BUILD))
	msoridCagKeywordsMRU,
#endif
#if (defined(OFFICE_BUILD))
	msoridCagCaptionsMRU,
#endif
#if (defined(PPT_BUILD))
	msoridPPTOptionUserViewDefaults,
#endif
#if (defined(PPT_BUILD))
	msoridPPTOptionsJGrammarBackground,
#endif
#if (defined(PPT_BUILD))
	msoridPPTOptionsJGrammarHideErrors,
#endif
#if (defined(ACCESS_BUILD))
	msoridAccCSDefaultFieldType,
#endif
#if (defined(ACCESS_BUILD))
	msoridAccCSDefaultTextFieldSize,
#endif
#if ((defined(EXCEL_BUILD) && defined(XL)))
	msoridExcelA4Letter,
#endif
#if (defined(WORD_BUILD))
	msoridWordOptionNoFactoidRecog,
#endif
#if (defined(WORD_BUILD))
	msoridWordOptionNoFactoidAction,
#endif
#if (defined(OFFICE_BUILD))
	msoridSearchResults,
#endif
#if (defined(OFFICE_BUILD))
	msoridPublisherRelyOnCSSForLayout,
#endif
#if (defined(OFFICE_BUILD) || defined(CLIPGALLERY_BUILD))
	msoridCagShowAutoImport,
#endif
#if (defined(PUBLISHER_BUILD))
	msoridPublisherPoliciesWCIDisabled,
#endif
#if (defined(PUBLISHER_BUILD))
	msoridPublisherPoliciesWCIPreventOMAccess,
#endif
#if (defined(PUBLISHER_BUILD))
	msoridPublisherPoliciesWCIPreventAddNew,
#endif
#if (defined(CLIPGALLERY_BUILD))
	msoridCagAlwaysApplyKeywordEdits,
#endif
#if (defined(PPT_BUILD))
	msoridPPTOptionsNoSlideCaching,
#endif
#if (defined(OFFICE_BUILD))
	msoridSearchSearchIn,
#endif
#if (defined(DESIGNER_BUILD))
	msoridTbxInitialized,
#endif
#if (defined(OFFICE_BUILD) || defined(DESIGNER_BUILD))
	msoridDefaultTemplateServer,
#endif
#if (defined(PPT_BUILD))
	msoridPPTOptionAutoLayout,
#endif
#if ((defined(EXCEL_BUILD) && defined(XL)) || (defined(EXCEL_BUILD) && defined(GRAF)))
	msoridXLFontAnyMode,
#endif
#if (defined(OUTLOOK_BUILD))
	msoridOutlookPSTtoLIS,
#endif
#if (defined(OUTLOOK_BUILD))
	msoridOutlookPSTDeletionDelay,
#endif
#if (defined(OUTLOOK_BUILD))
	msoridOutlookSuppressPSTDeletionPrompt,
#endif
#if (defined(OFFICE_BUILD) || defined(WORD_BUILD) || (defined(EXCEL_BUILD) && defined(XL)) || defined(PPT_BUILD) || defined(OUTLOOK_BUILD))
	msoridOfficeMachineUFIControls,
#endif
#if (defined(OFFICE_BUILD) || defined(WORD_BUILD) || (defined(EXCEL_BUILD) && defined(XL)) || defined(PPT_BUILD) || defined(OUTLOOK_BUILD))
	msoridOfficeUserUFIControls,
#endif
#if ((defined(EXCEL_BUILD) && defined(XL)))
	msoridExcelSpeakOnCommit,
#endif
#if (defined(OUTLOOK_BUILD))
	msoridOutlookAutoCorrect,
#endif
#if (defined(OUTLOOK_BUILD))
	msoridOutlookWordmailTrouble,
#endif
#if (defined(OFFICE_BUILD))
	msoridIEAnchorColor,
#endif
#if (defined(OFFICE_BUILD))
	msoridIEAnchorColorVisited,
#endif
#if ((defined(EXCEL_BUILD) && defined(XL)))
	msoridExcelDisablePasteAsWebQuery,
#endif
#if (defined(WORD_BUILD))
	msoridLMSharedMHTMLDefEdShellEditCmd,
#endif
#if (defined(WORD_BUILD))
	msoridCUSharedMHTMLDefEdShellEditCmd,
#endif
#if ((defined(EXCEL_BUILD) && defined(XL)))
	msoridExcelExtractDataFormulas,
#endif
#if ((defined(EXCEL_BUILD) && defined(XL)))
	msoridExcelExtractDataDisableUI,
#endif
#if (defined(OFFICE_BUILD))
	msoridTemplatesOnWeb,
#endif
#if (defined(OFFICE_BUILD))
	msoridOfficeDataServicesAutoCreateODC,
#endif
#if (defined(OFFICE_BUILD))
	msoridOfficeDataServicesMyDataName,
#endif
#if (defined(OFFICE_BUILD))
	msoridSearchFolderCache,
#endif
#if (defined(OFFICE_BUILD))
	msoridLMSharedHTML,
#endif
#if (defined(OFFICE_BUILD))
	msoridLMSharedMHTML,
#endif
#if (defined(OUTLOOK_BUILD))
	msoridForcePSTPath,
#endif
#if (defined(OUTLOOK_BUILD))
	msoridAutodinCr,
#endif
#if (defined(OUTLOOK_BUILD))
	msoridOutlookUseDocObj,
#endif
#if ((defined(EXCEL_BUILD) && defined(XL)))
	msoridExcelRTDThrottleInterval,
#endif
#if (defined(OFFICE_BUILD))
	msoridOfficeSCPPopup,
#endif
#if (defined(OFFICE_BUILD))
	msoridOfficeSCPTrace,
#endif
#if (defined(WORD_BUILD))
	msoridWordIndexCrossRef,
#endif
#if (defined(WORD_BUILD))
	msoridWordIndexSortLetter,
#endif
#if (defined(PPT_BUILD))
	msoridPPTAnimFxEntranceMRU,
#endif
#if (defined(PPT_BUILD))
	msoridPPTAnimFxEmphasisMRU,
#endif
#if (defined(PPT_BUILD))
	msoridPPTAnimFxExitMRU,
#endif
#if (defined(PPT_BUILD))
	msoridPPTAnimFxMotionPathMRU,
#endif
#if (defined(PPT_BUILD))
	msoridPPTAnimFxScheme1,
#endif
#if (defined(PPT_BUILD))
	msoridPPTAnimFxScheme2,
#endif
#if (defined(PPT_BUILD))
	msoridPPTAnimFxScheme3,
#endif
#if (defined(PPT_BUILD))
	msoridPPTAnimFxScheme4,
#endif
#if (defined(PPT_BUILD))
	msoridPPTAnimFxScheme5,
#endif
#if (defined(PPT_BUILD))
	msoridPPTOptionAutoPreview,
#endif
#if (defined(PHOTODRAW_BUILD))
	msoridPhdSettingsRenderACBOnExit,
#endif
#if (defined(OUTLOOK_BUILD))
	msoridOutlookSearchStrip,
#endif
#if (defined(OFFICE_BUILD))
	msoridEnterprise,
#endif
#if (defined(WORD_BUILD))
	msoridCMWWordOptionsVPref,
#endif
#if (defined(OUTLOOK_BUILD))
	msoridOutlookCUP2WOpenInBrowser,
#endif
#if (defined(PUBLISHER_BUILD))
	msoridPublisherSpellArabicMode,
#endif
#if (defined(PUBLISHER_BUILD))
	msoridPublisherSpellHebrewMode,
#endif
#if (defined(WORD_BUILD))
	msoridWordOptionsBkgndOpen,
#endif
#if (defined(OFFICE_BUILD))
	msoridMSProjectDontTrustInstalledFiles,
#endif
#if (defined(OFFICE_BUILD))
	msoridLMMSProjectDontTrustInstalledFiles,
#endif
#if (defined(OFFICE_BUILD))
	msoridMSProjectSecurityLevel,
#endif
#if (defined(OFFICE_BUILD))
	msoridMSProjectLMSecurityLevel,
#endif
#if (defined(OFFICE_BUILD))
	msoridLMPoliciesVBATrusted,
#endif
#if ((defined(EXCEL_BUILD) && defined(XL)))
	msoridLMPoliciesExcelSecurityLevel,
#endif
#if ((defined(EXCEL_BUILD) && defined(XL)))
	msoridLMPoliciesExcelDontTrustInstalledFiles,
#endif
#if (defined(OFFICE_BUILD))
	msoridLMPoliciesMSProjectSecurityLevel,
#endif
#if (defined(OFFICE_BUILD))
	msoridLMPoliciesMSProjectDontTrustInstalledFiles,
#endif
#if (defined(OFFICE_BUILD) || defined(OUTLOOK_BUILD))
	msoridLMPoliciesOutlookSecurityLevel,
#endif
#if (defined(OFFICE_BUILD))
	msoridLMPoliciesOutlookDontTrustInstalledFiles,
#endif
#if (defined(PPT_BUILD))
	msoridLMPoliciesPPTSecurityLevel,
#endif
#if (defined(PPT_BUILD))
	msoridLMPoliciesPPTDontTrustInstalledFiles,
#endif
#if (defined(WORD_BUILD))
	msoridLMPoliciesWordSecurityLevel,
#endif
#if (defined(WORD_BUILD))
	msoridLMPoliciesWordDontTrustInstalledFiles,
#endif
#if (defined(ACCESS_BUILD))
	msoridLMAccessNoRepairNeeded,
#endif
#if (defined(OFFICE_BUILD))
	msoridDrawHideAlertOrgChartLeaf,
#endif
#if (defined(OFFICE_BUILD))
	msoridDrawHideAlertOrgChartLayouts,
#endif
#if (defined(OFFICE_BUILD))
	msoridDrawHideAlertDiagramMove,
#endif
#if (defined(OFFICE_BUILD))
	msoridDrawHideAlertDiagramChange,
#endif
#if (defined(WORD_BUILD))
	msoridCMWWordOptionsVPrsu,
#endif
#if (defined(WORD_BUILD))
	msoridCMWWordOptionsVPreffuz,
#endif
#if (defined(WORD_BUILD))
	msoridCMWWordOptionsAssist,
#endif
#if ((defined(EXCEL_BUILD) && defined(XL)))
	msoridCMWXLBinaryOptions2,
#endif
#if (defined(OFFICE_BUILD))
	msoridLinkPlusSimpleDiscussionsBody,
#endif
#if (defined(OFFICE_BUILD))
	msoridLinkPlusSimpleDiscussionsPlusAttachmentBody,
#endif
#if (defined(OFFICE_BUILD))
	msoridLinkPlusSimpleDiscussionsReply,
#endif
#if (defined(OFFICE_BUILD))
	msoridReviewingLinks,
#endif
#if (defined(ACCESS_BUILD))
	msoridAccOptionNumberofUndos,
#endif
#if (defined(OFFICE_BUILD))
	msoridOfficeSpeechBoot,
#endif
#if (defined(OFFICE_BUILD) || defined(SETLANG_BUILD))
	msoridCUSharedOfficeUILanguage,
#endif
#if (defined(OUTLOOK_BUILD))
	msoridOutlookEnableLogging,
#endif
#if (defined(OFFICE_BUILD))
	msoridOfficeSymbolNameDisplay,
#endif
#if (defined(OUTLOOK_BUILD))
	msoridAppPathsDesignerExe,
#endif
#if (defined(OFFICE_BUILD))
	msoridDrawHideAlertOptPict,
#endif
#if (defined(OFFICE_BUILD))
	msoridWordMRUTemplateFriendly1,
#endif
#if (defined(OFFICE_BUILD))
	msoridWordMRUTemplateFriendly2,
#endif
#if (defined(OFFICE_BUILD))
	msoridWordMRUTemplateFriendly3,
#endif
#if (defined(OFFICE_BUILD))
	msoridWordMRUTemplateFriendly4,
#endif
#if (defined(OFFICE_BUILD))
	msoridWordMRUTemplateFriendly5,
#endif
#if (defined(OFFICE_BUILD))
	msoridWordMRUTemplateFriendly6,
#endif
#if (defined(OFFICE_BUILD))
	msoridWordMRUTemplateFriendly7,
#endif
#if (defined(OFFICE_BUILD))
	msoridWordMRUTemplateFriendly8,
#endif
#if (defined(OFFICE_BUILD))
	msoridWordMRUTemplateFriendly9,
#endif
#if (defined(OFFICE_BUILD))
	msoridExcelMRUTemplateFriendly1,
#endif
#if (defined(OFFICE_BUILD))
	msoridExcelMRUTemplateFriendly2,
#endif
#if (defined(OFFICE_BUILD))
	msoridExcelMRUTemplateFriendly3,
#endif
#if (defined(OFFICE_BUILD))
	msoridExcelMRUTemplateFriendly4,
#endif
#if (defined(OFFICE_BUILD))
	msoridExcelMRUTemplateFriendly5,
#endif
#if (defined(OFFICE_BUILD))
	msoridExcelMRUTemplateFriendly6,
#endif
#if (defined(OFFICE_BUILD))
	msoridExcelMRUTemplateFriendly7,
#endif
#if (defined(OFFICE_BUILD))
	msoridExcelMRUTemplateFriendly8,
#endif
#if (defined(OFFICE_BUILD))
	msoridExcelMRUTemplateFriendly9,
#endif
#if (defined(OFFICE_BUILD))
	msoridAccessMRUTemplateFriendly1,
#endif
#if (defined(OFFICE_BUILD))
	msoridAccessMRUTemplateFriendly2,
#endif
#if (defined(OFFICE_BUILD))
	msoridAccessMRUTemplateFriendly3,
#endif
#if (defined(OFFICE_BUILD))
	msoridAccessMRUTemplateFriendly4,
#endif
#if (defined(OFFICE_BUILD))
	msoridAccessMRUTemplateFriendly5,
#endif
#if (defined(OFFICE_BUILD))
	msoridAccessMRUTemplateFriendly6,
#endif
#if (defined(OFFICE_BUILD))
	msoridAccessMRUTemplateFriendly7,
#endif
#if (defined(OFFICE_BUILD))
	msoridAccessMRUTemplateFriendly8,
#endif
#if (defined(OFFICE_BUILD))
	msoridAccessMRUTemplateFriendly9,
#endif
#if (defined(OFFICE_BUILD))
	msoridPowerPointMRUTemplateFriendly1,
#endif
#if (defined(OFFICE_BUILD))
	msoridPowerPointMRUTemplateFriendly2,
#endif
#if (defined(OFFICE_BUILD))
	msoridPowerPointMRUTemplateFriendly3,
#endif
#if (defined(OFFICE_BUILD))
	msoridPowerPointMRUTemplateFriendly4,
#endif
#if (defined(OFFICE_BUILD))
	msoridPowerPointMRUTemplateFriendly5,
#endif
#if (defined(OFFICE_BUILD))
	msoridPowerPointMRUTemplateFriendly6,
#endif
#if (defined(OFFICE_BUILD))
	msoridPowerPointMRUTemplateFriendly7,
#endif
#if (defined(OFFICE_BUILD))
	msoridPowerPointMRUTemplateFriendly8,
#endif
#if (defined(OFFICE_BUILD))
	msoridPowerPointMRUTemplateFriendly9,
#endif
#if ((defined(EXCEL_BUILD) && defined(XL)))
	msoridExcelShareDeleteMode,
#endif
#if ( (defined(SRDIALOG_SUPPORT)) && (defined(OFFICE_BUILD)) )
	msoridSpeechOverrideDialogs,
#endif
#if (defined(OFFICE_BUILD))
	msoridFontLinkFont1,
#endif
#if (defined(OFFICE_BUILD))
	msoridFontLinkFont2,
#endif
#if (defined(OFFICE_BUILD))
	msoridFontLinkFont3,
#endif
#if (defined(OFFICE_BUILD))
	msoridFontLinkFont4,
#endif
#if (defined(OFFICE_BUILD))
	msoridFontLinkFont5,
#endif
#if (defined(OFFICE_BUILD))
	msoridFontLinkFont6,
#endif
#if (defined(OFFICE_BUILD))
	msoridFontLinkFont7,
#endif
#if (defined(OFFICE_BUILD))
	msoridFontLinkFont8,
#endif
#if (defined(OFFICE_BUILD))
	msoridFontLinkFont9,
#endif
#if (defined(OUTLOOK_BUILD))
	msoridPrevMailClient,
#endif
#if (defined(OFFICE_BUILD) || defined(DESIGNER_BUILD))
	msoridDefaultNewProjLocation,
#endif
#if (defined(OUTLOOK_BUILD))
	msoridLMOutlookScriptingThreshold,
#endif
#if (defined(WORD_BUILD))
	msoridWordTerminalServerSpellStart,
#endif
#if (defined(WORD_BUILD))
	msoridSmartTagUnderlineColor,
#endif
#if ((defined(EXCEL_BUILD) && defined(XL)))
	msoridExcelUseSystemSeparators,
#endif
#if ((defined(EXCEL_BUILD) && defined(XL)))
	msoridExcelDecimalSeparator,
#endif
#if ((defined(EXCEL_BUILD) && defined(XL)))
	msoridExcelThousandsSeparator,
#endif
#if (defined(OFFICE_BUILD))
	msoridMsiidDPCDirs,
#endif
#if (defined(OFFICE_BUILD))
	msoridDoNotAllowOrgChartConversion,
#endif
#if (defined(OFFICE_BUILD))
	msoridHEVVersion,
#endif
#if ((defined(EXCEL_BUILD) && defined(XL)))
	msoridExcelUseSentinelFile,
#endif
#if (defined(OFFICE_BUILD))
	msoridPassportName,
#endif
#if (defined(OFFICE_BUILD))
	msoridPassportLogoutIconUrl,
#endif
#if (defined(DESIGNER_BUILD))
	msoridDesignerFieldTips,
#endif
#if (defined(CLIPGALLERY_BUILD))
	msoridCagLastImportDir,
#endif
#if (defined(OFFICE_BUILD))
	msoridOfficeIWPCRect,
#endif
#if (defined(OUTLOOK_BUILD))
	msoridOutlookMinimizeToTray,
#endif
#if (defined(OFFICE_BUILD))
	msoridMSProjectMRUTemplate1,
#endif
#if (defined(OFFICE_BUILD))
	msoridMSProjectMRUTemplate2,
#endif
#if (defined(OFFICE_BUILD))
	msoridMSProjectMRUTemplate3,
#endif
#if (defined(OFFICE_BUILD))
	msoridMSProjectMRUTemplate4,
#endif
#if (defined(OFFICE_BUILD))
	msoridMSProjectMRUTemplate5,
#endif
#if (defined(OFFICE_BUILD))
	msoridMSProjectMRUTemplate6,
#endif
#if (defined(OFFICE_BUILD))
	msoridMSProjectMRUTemplate7,
#endif
#if (defined(OFFICE_BUILD))
	msoridMSProjectMRUTemplate8,
#endif
#if (defined(OFFICE_BUILD))
	msoridMSProjectMRUTemplate9,
#endif
#if (defined(OFFICE_BUILD))
	msoridMSProjectMRUTemplateFriendly1,
#endif
#if (defined(OFFICE_BUILD))
	msoridMSProjectMRUTemplateFriendly2,
#endif
#if (defined(OFFICE_BUILD))
	msoridMSProjectMRUTemplateFriendly3,
#endif
#if (defined(OFFICE_BUILD))
	msoridMSProjectMRUTemplateFriendly4,
#endif
#if (defined(OFFICE_BUILD))
	msoridMSProjectMRUTemplateFriendly5,
#endif
#if (defined(OFFICE_BUILD))
	msoridMSProjectMRUTemplateFriendly6,
#endif
#if (defined(OFFICE_BUILD))
	msoridMSProjectMRUTemplateFriendly7,
#endif
#if (defined(OFFICE_BUILD))
	msoridMSProjectMRUTemplateFriendly8,
#endif
#if (defined(OFFICE_BUILD))
	msoridMSProjectMRUTemplateFriendly9,
#endif
#if (defined(OFFICE_BUILD))
	msoridMSProjectProjectTemplateLocation,
#endif
#if (defined(WORD_BUILD))
	msoridWordTerminalServerOtherProofStart,
#endif
#if (defined(OFFICE_BUILD))
	msoridSearchScopeLocal,
#endif
#if (defined(OFFICE_BUILD))
	msoridSearchScopeEmail,
#endif
#if (defined(OFFICE_BUILD))
	msoridSearchScopeProjects,
#endif
#if (defined(WORD_BUILD) || defined(OUTLOOK_BUILD))
	msoridMailPlainWrap,
#endif
#if (defined(OFFICE_BUILD) || defined(ACCESS_BUILD))
	msoridLMPoliciesAccessSecurityLevel,
#endif
#if (defined(OFFICE_BUILD) || defined(ACCESS_BUILD))
	msoridLMPoliciesAccessDontTrustInstalledFiles,
#endif
#if (defined(OUTLOOK_BUILD))
	msoridOutlookDisableAddinBtns,
#endif
#if (defined(PUBLISHER_BUILD))
	msoridPublisherPrefUseFontLink,
#endif
#if (defined(PPT_BUILD))
	msoridPPTOptionMonitor,
#endif
#if (defined(PPT_BUILD))
	msoridPPTOptionUseMultiMgr,
#endif
#if (defined(OFFICE_BUILD))
	msoridCAGDisableScanCameriaPic,
#endif
#if (defined(OFFICE_BUILD))
	msoridCAGDisableAutoDialUp,
#endif
#if (defined(OFFICE_BUILD))
	msoridCAGDisableAutoImport,
#endif
#if (defined(OFFICE_BUILD))
	msoridCAGDisablePrimaryChange,
#endif
#if (defined(OFFICE_BUILD))
	msoridCAGClipsOnlineURL,
#endif
#if (defined(OFFICE_BUILD))
	msoridCAGClipsServerURL,
#endif
#if (defined(OFFICE_BUILD))
	msoridCAGDisableClipServerUpdate,
#endif
#if (defined(OFFICE_BUILD))
	msoridCAGDisableClipsOnline,
#endif
#if (defined(OFFICE_BUILD))
	msoridCAGDisableUserImport,
#endif
#if (defined(OFFICE_BUILD))
	msoridCAGDisableLegacyImport,
#endif
#if (defined(OFFICE_BUILD))
	msoridCAGDisableOpenClipsIn,
#endif
#if (defined(OFFICE_BUILD))
	msoridCAGDisablePreviews,
#endif
#if (defined(OFFICE_BUILD))
	msoridCAGEnableSoundMotion,
#endif
#if (defined(OFFICE_BUILD))
	msoridCAGDisablePublish,
#endif
#if (defined(OFFICE_BUILD))
	msoridCAGDisableMyCol,
#endif
#if (defined(OFFICE_BUILD))
	msoridCAGDisablePreviousCol,
#endif
#if (defined(OFFICE_BUILD))
	msoridCAGDisableOfficeCol,
#endif
#if (defined(OFFICE_BUILD))
	msoridCAGDisableSharedCol,
#endif
#if (defined(OFFICE_BUILD))
	msoridCAGDisableWebCol,
#endif
#if (defined(OFFICE_BUILD))
	msoridCAGDisableMailAttach,
#endif
#if (defined(OFFICE_BUILD))
	msoridCAGDisableToolsOptions,
#endif
#if (defined(OFFICE_BUILD))
	msoridCAGDisableWebServices,
#endif
#if (defined(OFFICE_BUILD))
	msoridSvWowLameTips,
#endif
#if ( (defined(VSMSODEBUG)) && (defined(OFFICE_BUILD)) )
	msoridEServicesStartPage,
#endif
#if (defined(OFFICE_BUILD))
	msoridEServicesEnable,
#endif
#if (defined(DESIGNER_BUILD))
	msoridLMOfficeDeveloperOfficeIDE,
#endif
#if ((defined(EXCEL_BUILD) && defined(XL)))
	msoridExcelRTDAuto,
#endif
#if ((defined(EXCEL_BUILD) && defined(XL)))
	msoridExcelRTDPromptOnLoad,
#endif
#if ((defined(EXCEL_BUILD) && defined(XL)))
	msoridExcelPlatoSecurityOptions,
#endif
#if ((defined(EXCEL_BUILD) && defined(XL)))
	msoridExcelMacrosDisabledSuppress,
#endif
#if (defined(OFFICE_BUILD))
	msoridIsPortable,
#endif
#if ((defined(EXCEL_BUILD) && defined(GRAF)))
	msoridGraphFontSub,
#endif
#if (defined(OFFICE_BUILD))
	msoridCUVisioAddins,
#endif
#if (defined(OFFICE_BUILD))
	msoridLMVisioAddins,
#endif
#if (defined(OFFICE_BUILD))
	msoridCUVisioSecurityLevel,
#endif
#if (defined(OFFICE_BUILD))
	msoridLMVisioSecurityLevel,
#endif
#if (defined(OFFICE_BUILD))
	msoridCUPoliciesVisioSecurityLevel,
#endif
#if (defined(OFFICE_BUILD))
	msoridLMPoliciesVisioSecurityLevel,
#endif
#if (defined(OFFICE_BUILD))
	msoridCUVisioAccessVBOM,
#endif
#if (defined(OFFICE_BUILD))
	msoridLMVisioAccessVBOM,
#endif
#if (defined(CLIPGALLERY_BUILD))
	msoridCAGWindowState,
#endif
#if (defined(WORD_BUILD))
	msoridWordMTReload,
#endif
#if (defined(OFFICE_BUILD))
	msoridDoNotAllowDrawOLEConversion,
#endif
#if (defined(OFFICE_BUILD) || defined(CLIPGALLERY_BUILD))
	msoridCagLastImportedPrimaryVersion,
#endif
#if (defined(DESIGNER_BUILD))
	msoridDesignerSuccessBoot,
#endif
#if (defined(DESIGNER_BUILD))
	msoridDesignerPontFocusFCTip,
#endif
#if (defined(DESIGNER_BUILD))
	msoridDesignerPonts,
#endif
#if (defined(OFFICE_BUILD))
	msoridOfficeClearTypeGamma,
#endif
#if (defined(PPT_BUILD))
	msoridPPTSSSystemState,
#endif
#if (defined(PPT_BUILD))
	msoridPPTOptionSlideShowResolutionX,
#endif
#if (defined(PPT_BUILD))
	msoridPPTOptionSlideShowResolutionY,
#endif
#if (defined(PPT_BUILD))
	msoridPPTOptionSlideShowUseDirect3D,
#endif
#if (defined(OFFICE_BUILD))
	msoridLMVbaOff,
#endif
#if (defined(OFFICE_BUILD))
	msoridLMPolicyVbaOff,
#endif
#if (defined(WORD_BUILD))
	msoridLMPoliciesWordSecurityAccessVBOM,
#endif
#if ((defined(EXCEL_BUILD) && defined(XL)))
	msoridLMPoliciesExcelSecurityAccessVBOM,
#endif
#if (defined(PPT_BUILD))
	msoridLMPoliciesPPTSecurityAccessVBOM,
#endif
#if (defined(PUBLISHER_BUILD))
	msoridPublisherPrefDefTextFlow,
#endif
#if ( (defined(LICENSE_TEST_HARNESS)) && (defined(OFFICE_BUILD)) )
	msoridLICHwidVersion,
#endif
#if ( (defined(LICENSE_TEST_HARNESS)) && (defined(OFFICE_BUILD)) )
	msoridLICHwidDockable,
#endif
#if (defined(PPT_BUILD))
	msoridPPTOptionAutoPreviewEffect,
#endif
#if (defined(OFFICE_BUILD))
	msoridExplorerSystem,
#endif
#if (defined(OFFICE_BUILD))
	msoridDrawHideAlertDiagramConvert,
#endif
#if (defined(OFFICE_BUILD))
	msoridDrawHideAlertDiagramAddNode,
#endif
#if (defined(OFFICE_BUILD))
	msoridUseRWHlinkNavigation,
#endif
#if (defined(OUTLOOK_BUILD))
	msoridOutlookResetFolderNames,
#endif
#if (defined(OFFICE_BUILD))
	msoridLeaveFileNewUp,
#endif
#if (defined(OFFICE_BUILD))
	msoridMsoTypelib,
#endif
#if (defined(MSQUERY_BUILD))
	msoridQueryAllowAlias,
#endif
#if (defined(OUTLOOK_BUILD))
	msoridForceLISPath,
#endif
#if (defined(DESIGNER_BUILD))
	msoridDesignerPontBaseSchemaLink,
#endif
#if (defined(ACCESS_BUILD))
	msoridAccessRestrictStartupCode,
#endif
#if (defined(OFFICE_BUILD))
	msoridProcessorSpeed,
#endif
#if (defined(OUTLOOK_BUILD))
	msoridOutlookRulesMachineID,
#endif
#if ((defined(EXCEL_BUILD) && defined(XL)) || defined(ACCESS_BUILD) || defined(OUTLOOK_BUILD) || defined(PUBLISHER_BUILD))
	msoridCustomDictionaryUnicode,
#endif
#if (defined(OUTLOOK_BUILD))
	msoridLISSupported,
#endif
#if (defined(DESIGNER_BUILD))
	msoridDesignerPontMultiForm,
#endif
#if (defined(OUTLOOK_BUILD))
	msoridOutlookDontCheckMem,
#endif
#if (defined(OFFICE_BUILD))
	msoridOfficeOpenDocsReadWriteWhileBrowsing,
#endif
#if (defined(OFFICE_BUILD))
	msoridOfficeNoOfflineDocumentEdit,
#endif
#if (defined(OFFICE_BUILD))
	msoridSpeechShowMSAADialogAlert,
#endif
#if (defined(OFFICE_BUILD))
	msoridMachineInstalledOnWin2K,
#endif
#if (defined(OFFICE_BUILD))
	msoridUserInstalledOnWin2K,
#endif
#if (defined(OFFICE_BUILD))
	msoridMachineInstalledOnWinME,
#endif
#if (defined(OFFICE_BUILD))
	msoridUserInstalledOnWinME,
#endif
#if (defined(OFFICE_BUILD))
	msoridOfficeSpeechMicLevelNoDictation,
#endif
#if (defined(OFFICE_BUILD))
	msoridOfficeSpeechMicLevelNoCC,
#endif
#if (defined(OFFICE_BUILD))
	msoridOfficeSpeechMicLevelNoTest,
#endif
#if (defined(OFFICE_BUILD))
	msoridSearchTracking,
#endif
#if (defined(OFFICE_BUILD))
	msoridSearchCurrentFile,
#endif
#if (defined(OUTLOOK_BUILD))
	msoridOutlookMaxCacheSize,
#endif
#if (defined(WORD_BUILD))
	msoridShowFormsInWordMail,
#endif
#if (defined(OUTLOOK_BUILD))
	msoridOutlookDisallowAttachmentCustomization,
#endif
#if (defined(OUTLOOK_BUILD))
	msoridOutlookSecurityLevel1Remove,
#endif
#if (defined(OUTLOOK_BUILD))
	msoridOutlookUseSecurityIcon,
#endif
#if (defined(OFFICE_BUILD))
	msoridBlockHTTPImages,
#endif
#if (defined(OUTLOOK_BUILD))
	msoridCUFRMigrateIARules,
#endif
#if (defined(OFFICE_BUILD))
	msoridProjectStartWorking,
#endif
#if (defined(OFFICE_BUILD))
	msoridPolicyProjectStartWorking,
#endif
#if (defined(OUTLOOK_BUILD))
	msoridICQPath,
#endif
#if (defined(OUTLOOK_BUILD))
	msoridCUOutlookDisabledICQ,
#endif
#if (defined(OUTLOOK_BUILD))
	msoridICQFriendlyName,
#endif
} ;

// put it back to how it was
#if defined(PPT_VBA_BUILD)
#undef PPT_BUILD
#define PPT_BUILD PPT_BUILD_ORAPI_OLD
#endif

#endif // !MSOREG_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Inc\office10\msoiv.h ===
/*-----------------------------------------------------------------------------
 filename: msoiv.h
 summary : This file contains the #defines used for the Office 9 Instrumented
           version.
 last mod: July 9, 1998
------------------------------------------------------------------- t-benyu -*/
#ifndef MSOIV
#define MSOIV

#define PROFILE_ASSISTANT_QUERY 10
#define PROFILE_ALERT_MESSAGE	22
/*
   Format of Logging Callback (PFCNIVLoggingCallback)
   This typedef is also defined in Profiler.h of the Test Wizard project.
   Any changes made here must also be made in profiler.h
*/
typedef void (__cdecl *PFCNIVLoggingCallback)(DWORD dwTime, WORD wType, WORD wDataLength, void *pData);

#endif /* MSOIV */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Inc\office10\msoprops.h ===
#pragma once

/****************************************************************************
	msoprops.h

	Owner: MartinTh
 	Copyright (c) 1994-95 Microsoft Corporation

	This file contains the exported interfaces and declarations for
	the Extended OLE Properties.
****************************************************************************/
#ifndef MSOPROPS_H
#define MSOPROPS_H
#include <msodig.h>
#include <msobp.h>
#pragma pack( push, msoprops, 4 )

//	Call back functions implemented by client apps (those will be passed to mso96(95).dll
//	as function pointers) must explicitly declare its calling convention using the
//	OFC_CALLBACK macro
//	TODO: 	Will investigate if we define OFC_CALLBACK as  MSOSTDAPICALLTYPE, they are
//			defined as the same except in Mac builds, (of course Mso95 doesn't have a Mac
//			build, yet)
//	PRIORITY:6
//	DIFFICULTY:1

#define OFC_CALLBACK __stdcall

////////////////////////////////////////////////////////////////////////////////
// EXTENDED OLE DOC PROPERTIES APIs
// Overview:
//              To use extended ole properties do the following
//              1.Open your file
//              2.Call FOfficeCreateAndInitObjects: This will create 3 objects which are
//                      siobj (sum info obj
//                      dsiobj (doc sum info obj)
//                      udobj (user defined data or custom obj)
//               and provides a pointer to each of these.
//               To make any subsequent calls, you will have to provide the pointer to the
//               appropriate object.
//              3.Before you close a file call FOfficeDestroyObjects.
////////////////////////////////////////////////////////////////////////////////
//
// Summary Information interface API.
//
// Notes:
//  - define OLE_PROPS to build OLE 2 interface objects too.
//
// The actual data is stored in SUMINFO.  The layout of the first
// 3 entries must not be changed, since it will be overlayed with
// other structures.  All property exchange data structures have
// this format.
//
// The first parameter of all functions must be LPSIOBJ in order for these
// functions to work as OLE objects.
//
// All functions defined here have "SumInfo" in them.
//
// Several macros are used to hide the stuff that changes in this
// file when it is used to support OLE 2 objects.
// They are:
//   SIVTBLSTRUCT - For OLE, expands to the pointer to the interface Vtbl
//              - Otherwise, expands to dummy struct same size as Vtbl
//   LPSIOBJ    - For OLE, expands to a pointer to the interface which is
//                just the lpVtbl portion of the data, to be overlayed later.
//              - Otherwise, expands to a pointer to the whole data
//
////////////////////////////////////////////////////////////////////////////////

  // Apps should use these for "Create" calls to fill out rglpfn
#define ifnCPConvert    0               // Index of Code Page Converter
#define ifnFWzToNum     1               // Index of Sz To Num routine
#define ifnFNumToWz     2               // Index of Num To Sz routine
#define ifnFUpdateStats 3               // Index of routine to update statistics
#define ifnMax          4               // Max index

  // Predefined Security level values for Property Sets in the standard
#define SECURITY_NONE                   0x0     /* No security */
#define SECURITY_PASSWORD               0x1     /* Password-protected */
#define SECURITY_READONLYRECOMMEND      0x2     /* Read-only access recommened */
#define SECURITY_READONLYENFORCED       0x4     /* Read-only access enforced */
#define SECURITY_LOCKED                 0x8     /* Locked for annotations */

  // The types supported by the User-Defined properties
typedef enum _UDTYPES
{
  wUDlpsz    = VT_LPSTR,  // In Office 97 we are actually unicode...
  wUDdate    = VT_FILETIME,
  wUDdw      = VT_I4,
  wUDfloat   = VT_R8,
  wUDbool    = VT_BOOL,
  wUDinvalid = VT_VARIANT        // VT_VARIANT is invalid because it
				 // must always be combined with VT_VECTOR
} UDTYPES;

  // Create a placeholder Vtbl for non-OLE objects.
#define SIVTBLSTRUCT struct _SIVTBLSTRUCT { void FAR *lpVtbl; } SIVTBLSTRUCT

  // For non-OLE objects, first param is pointer to real data.
#define LPSIOBJ LPOFFICESUMINFO

// For more information on the thumbnail look in OLE 2 Programmer's Reference, Volume 1, pp 874-875.

typedef struct tagSINAIL
{
   DWORD cbData;     // size of *pdata
   DWORD cftag;      // either 0,-1,-2,-3, or positive. This decides the size of pFMTID.
   BYTE *pbFMTID;    // bytes representing the FMTID
   BYTE *pbData;     // bytes representing the data
} SINAIL;

typedef SINAIL FAR * LPSINAIL;

// Note about tagSINAIL:
//
// if cftag is
//             0 - pFMTID is NULL i.e. no format name
//            -1 - Windows built-in Clipboard format. pFMTID points to a DWORD (e.g. CF_DIB)
//            -2 - Macintosh Format Value.            pFMTID points to a DWORD
//            -3 - FMTID.                             pFMTID points to 16 bytes
//            >0 - Length of string.                  pFMTID points to cftag bytes
//

  // Summary info data.  Callers should *never* access this data directly,
  // always use the supplied API's.
typedef struct _OFFICESUMINFO {

  SIVTBLSTRUCT;                             // Vtbl goes here for OLE objs,
					    // Must be here for overlays to work!
  BOOL                m_fObjChanged;        // Indicates the object has changed
  LPVOID              m_lpData;             // Pointer to the real data

} OFFICESUMINFO, FAR * LPOFFICESUMINFO;

#ifdef __cplusplus
extern "C" {
#endif // __cplusplus

//
// Indices to pass to API routines to get the specifc data.
//
  // Strings
#define SI_TITLE        0
#define SI_SUBJECT      1
#define SI_AUTHOR       2
#define SI_KEYWORDS     3
#define SI_COMMENTS     4
#define SI_TEMPLATE     5
#define SI_LASTAUTH     6
#define SI_REVISION     7
#define SI_APPNAME      8
#define SI_STRINGLAST   8

  // Times
#define SI_TOTALEDIT    0
#define SI_LASTPRINT    1
#define SI_CREATION     2
#define SI_LASTSAVE     3
#define SI_TIMELAST     3

  // Integer stats
#define SI_PAGES        0
#define SI_WORDS        1
#define SI_CHARS        2
#define SI_SECURITY     3
#define SI_INTLAST      3

//
// Standard I/O routines
//
    // Indicates if the summary info data has changed.
    //
    // Parameters:
    //
    //   lpSIObj - pointer to Summary Info object
    //
    // Return value:
    //
    //   TRUE -- the data has changed, and should be saved.
    //   FALSE -- the data has not changed.
    //

MSOAPI_(BOOL ) MsoFSumInfoShouldSave (LPSIOBJ lpSIObj);

//
// Data manipulation
//
    // Get the size of a given string (UNICODE) property.
    //
    // Parameters:
    //
    //   lpSIObj - pointer to Summary Info object.
    //   iw - specifies which string to get the size of and should be
    //        one of the following values:
    //      SI_TITLE
    //      SI_SUBJECT
    //      SI_AUTHOR
    //      SI_KEYWORDS
    //      SI_COMMENTS
    //      SI_TEMPLATE
    //      SI_LASTAUTH
    //      SI_REVISION
    //      SI_APPNAME
    //
    //   pdw - pointer to a dword, will contain cb on return
    //
    // Return value:
    //
    //   The function returns TRUE on success, FALSE on error.

MSOAPI_(BOOL) MsoFCbSumInfoString
  (LPSIOBJ lpSIObj,                     // Pointer to object
   WORD iw,                             // Index of string to get size of
   DWORD *pdw);                         // Pointer to dword

    // Get a given string (UNICODE) property.
    //
    // Parameters:
    //
    //   lpSIObj - pointer to Summary Info object
    //   wz - buffer to hold string (allocated by caller)
    //   iw - specifies which string to get and should be
    //        one of the following values:
    //      SI_TITLE
    //      SI_SUBJECT
    //      SI_AUTHOR
    //      SI_KEYWORDS
    //      SI_COMMENTS
    //      SI_TEMPLATE
    //      SI_LASTAUTH
    //      SI_REVISION
    //      SI_APPNAME
    //
    //   cbMax - size of buffer
    //
    // Return value:
    //
    //   The function returns TRUE on success, FALSE on error.
    //

MSOAPI_(BOOL) MsoFSumInfoGetString
  (LPSIOBJ lpSIObj,                     // Pointer to object
   WORD iw,                             // Index of string to get
   DWORD cbMax,                         // Size of lpsz
   WCHAR *wz);                        // Pointer to buffer

    // Set a string (UNICODE) property to a given value
    //
    // Parameters:
    //
    //   lpSIObj - pointer to Summary Info object
    //   iw - specifies which string to set and should be
    //        one of the following values:
    //      SI_TITLE
    //      SI_SUBJECT
    //      SI_AUTHOR
    //      SI_KEYWORDS
    //      SI_COMMENTS
    //      SI_TEMPLATE
    //      SI_LASTAUTH
    //      SI_REVISION
    //      SI_APPNAME
    //
    //   wz - buffer containing string value
    //
    // Return value:
    //
    //   The function returns TRUE on success.
    //   The function returns FALSE on error.
    //
    //   If SI_REVISION is passed, the string must point to a whole number.
    //   If not, the function will return FALSE.
    //
    // Note: The function will dirty the object on success.
    //
MSOAPI_(BOOL) MsoFSumInfoSetString
  (LPSIOBJ lpSIObj,                     // Pointer to object
   WORD iw,                             // Index of string to set
   const WCHAR *wz);                          // Pointer to new title


    // Get a given time property.
    //
    // Parameters:
    //
    //   lpSIObj - pointer to a Summary Info object
    //   iw - specifies which time to get and should be
    //        one of the following values:
    //      SI_TOTALEDIT
    //      SI_LASTPRINT
    //      SI_CREATION
    //      SI_LASTSAVE
    //
    //   lpTime - buffer to hold filetime
    //
    // Return value:
    //
    //   The function returns TRUE on succes.
    //   The function returns FALSE on error (bogus argument, or the time
    //   requested doesn't exist - i.e. has not been set, or loaded).
    //
    //  NOTE:    The filetime will be based Coordinated Universal Time (UTC).
    //           This ensures that the time is displayed correctly all over the
    //           world.
    //
    // NOTE: FOR SI_TOTALEDIT lpTime WILL ACTUALLY BE THE TIME
    //       THE FILE HAS BEEN EDITED, NOT A DATE.  THE TIME
    //       WILL BE EXPRESSED IN UNITS OF 100ns.  I KNOW THIS IS
    //       A WEIRD UNIT TO USE, BUT WE HAVE TO DO THAT FOR BACK-
    //       WARDS COMPATABILITY REASONS WITH 16-BIT WORD 6.
    //
    //       OFFICE provides a utility routine to convert a number of
    //       units of 100ns into minutes. Call Convert100nsToMin.
    //
MSOAPI_(BOOL ) MsoFSumInfoGetTime (LPSIOBJ lpSIObj,
					   WORD iw,
					   LPFILETIME lpTime);

    // Set the time property to a given value
    //
    // Parameters:
    //
    //   lpSIObj - pointer to a Summary Info object
    //   iw - specifies which time to set and should be
    //        one of the following values:
    //      SI_TOTALEDIT
    //      SI_LASTPRINT
    //      SI_CREATION
    //      SI_LASTSAVE
    //
    //   lpTime - buffer containing new filetime
    //
    //   NOTE:    The filetime should be based Coordinated Universal Time (UTC).
    //            This ensures that the time is displayed correctly all over the
    //            world.
    //
    // Return value:
    //
    //   The function returns TRUE on succes.
    //   The function returns FALSE on error.
    //
    // Note: The function will dirty the object on success.
    //
    // NOTE: FOR SI_TOTALEDIT lpTime WILL BE INTERPRETED AS THE TIME
    //       THE FILE HAS BEEN EDITED, NOT A DATE.  THE TIME SHOULD
    //       BE EXPRESSED IN UNITS OF 100ns.  I KNOW THIS IS
    //       A WEIRD UNIT TO USE, BUT WE HAVE TO DO THAT FOR BACK-
    //       WARDS COMPATABILITY REASONS WITH 16-BIT WORD 6.
    //
    //       ALSO NOTE THAT THE TIME WILL BE SHOW IN MINUTES IN THE
    //       PROPERTIES DIALOG.
    //
    //       OFFICE provides a utility routine to convert a number of
    //       minutes into units of 100ns. Call ConvertMinTo100ns
    //
MSOAPI_(BOOL ) MsoFSumInfoSetTime (LPSIOBJ lpSIObj, WORD iw, LPFILETIME lpTime);

  // Convert a number of minutes into units of 100ns.
  //
  // Parameters:
  //
  //     lpTime - on intput: contains the number of minutes.
  //     lptime - on output: contains the equivalent number expressed in 100ns.
  //
  // Return value:
  //
  //     None.
  //
MSOAPI_(VOID ) MsoConvertMinTo100ns(LPFILETIME lpTime);

  // Convert a number in units of 100ns into number of minutes.
  //
  // Parameters:
  //
  //     lptime - on input: contains a number expressed in 100ns.
  //              on output: contains the equivalent number of minutes.
  //
  // Return value:
  //
  //     None.
  //
MSOAPI_(VOID ) MsoConvert100nsToMin(LPFILETIME lpTime);

    // Get an integer property
    //
    // Parameters:
    //
    //   lpSIObj - pointer to Summary Info object
    //   iw - specifies which integer to get and should be
    //        one of the following values:
    //      SI_PAGES
    //      SI_WORDS
    //      SI_CHARS
    //      SI_SECURITY
    //
    //   pdw - pointer to a dword, will contain the int on return
    // Return value:
    //
    //   The function returns TRUE on succes, FALSE on error.
MSOAPI_(BOOL ) MsoFDwSumInfoGetInt (LPSIOBJ lpSIObj, WORD iw, DWORD *pdw);

    // Set an integer property to a given value
    //
    // Parameters:
    //
    //   lpSIObj - pointer to Summary Info object
    //   iw - specifies which integer to set and should be
    //        one of the following values:
    //      SI_PAGES
    //      SI_WORDS
    //      SI_CHARS
    //      SI_SECURITY
    //
    //   dw - the value 
    //
    // Return value:
    //
    //   The function returns TRUE on success.
    //   The function returns FALSE on error.
    //
    // Note: The function will dirty the object on success.
    //
MSOAPI_(BOOL ) MsoFSumInfoSetInt (LPSIOBJ lpSIObj, WORD iw, DWORD dw);


    // Get the thumbnail property.
    //
    // Parameters:
    //   lpSIObj - pointer to Summary Info object
    //   lpSINail - will hold the SINAIL information
    //
    // Return value:
    //
    //   The function returns TRUE on success.
    //   The function returns FALSE on error.  The caller should ignore values
    //   set in the SINAIL struct.
    //
    // Note1: The function will allocate memory to hold the data.
    // Note2: lpSINail->cbData can be 0, in which case lpSINail->pData is NULL.
    //        This is legal.
    // Note3: lpSINail->cftag can be 0, in which case lpSINail->pFMTID is NULL.
    //        This is legal.
    //
    // Note4: You must call FreeThumbnailData before freeing the lpSINail you
    //        passed to this function.  You must do this since Office will
    //        allocate the pointers in the structure, so Office must also free
    //        them to avoid memory leaks.
    //
MSOAPI_(BOOL ) MsoFSumInfoGetThumbnail (LPSIOBJ lpSIObj, LPSINAIL lpSINail);

    // Free the data hanging of the SINail struct.
    //
    // Parameters:
    //   lpSINail - pointer to a SINAIL structure.
    //
    // Return Value:
    //   None.
    //
    // Note: This should only be called for Thumbnails obtained through
    //       FSumInfoGetThumbnail.
    //
MSOAPI_(VOID ) MsoFreeThumbnailData (LPSINAIL lpSINail);

    // Set the thumbnail property
    //
    // Parameters:
    //
    //   lpSIObj - pointer to Summary Info object
    //   lpSINail - holds the SINAIL information
    //
    // Return value:
    //
    //   The function returns TRUE on success.
    //   The function returns FALSE on error.
    //
    // Note: The function wil dirty the object on success.
    //
MSOAPI_(BOOL ) MsoFSumInfoSetThumbnail (LPSIOBJ lpSIObj, LPSINAIL lpSINail);

    // Should the thumbnail property be saved
    //
    // Parameters:
    //
    //   lpSIObj - pointer to Summary Info object
    //
    // Return value:
    //
    //   The function returns TRUE on success.
    //   The function returns FALSE is there is no thumbnail.
    //   The function returns FALSE on error.
    //
MSOAPI_(BOOL ) MsoFSumInfoShouldSaveThumbnail (LPSIOBJ lpSIObj);

    // Set the flag deciding whether the thumbnail property should be saved
    //
    // Parameters:
    //
    //   lpSIObj - pointer to Summary Info object
	//	 fSave   - TRUE (should save), FALSE (don't save)
    //
    // Return value:
    //
	//	 None.
    //
MSOAPI_(VOID) MsoSumInfoSetSaveThumbnail (LPSIOBJ lpSIObj, BOOL fSave);

MSOAPI_(BPSC) MsoBpscBulletProofSinfo(MSOBPCB *pmsobpcb, LPSIOBJ *ppsiobj);

#ifdef __cplusplus
}; // extern "C"
#endif // __cplusplus


////////////////////////////////////////////////////////////////////////////////
//
// MS Office Document Summary Information
//
// The Document Summary Information follows the serialized format for
// property sets defined in Appendix B ("OLE Property Sets") of
// "OLE 2 Programmer's Reference, Volume 1"
//
// Notes:
//  - define OLE_PROPS to build OLE 2 interface objects too.
//
// The actual data is stored in DOCSUMINFO.  The layout of the first
// 3 entries must not be changed, since it will be overlayed with
// other structures.  All property exchange data structures have
// this format.
//
// The first parameter of all functions must be LPDSIOBJ in order for these
// functions to work as OLE objects.
//
// All functions defined here have "DocSum" in them.
//
// Several macros are used to hide the stuff that changes in this
// file when it is used to support OLE 2 objects.
// They are:
//   DSIVTBLSTRUCT - For OLE, expands to the pointer to the interface Vtbl
//              - Otherwise, expands to dummy struct same size as Vtbl
//   LPDSIOBJ   - For OLE, expands to a pointer to the interface which is
//                just the lpVtbl portion of the data, to be overlayed later.
//              - Otherwise, expands to a pointer to the whole data
//
////////////////////////////////////////////////////////////////////////////////

  // Create a placeholder Vtbl for non-OLE objects.
#define DSIVTBLSTRUCT struct _DSIVTBLSTRUCT { void FAR *lpVtbl; } DSIVTBLSTRUCT

  // For non-OLE objects, first param is pointer to real data.
#define LPDSIOBJ LPDOCSUMINFO

  // Our object
typedef struct _DOCSUMINFO {

  DSIVTBLSTRUCT;                            // Vtbl goes here for OLE objs,
					    // Must be here for overlays to work!
  BOOL                m_fObjChanged;        // Indicates the object has changed
  LPVOID              m_lpData;             // Pointer to the real data

} DOCSUMINFO, FAR * LPDOCSUMINFO;


#ifdef __cplusplus
extern "C" {
#endif

//
// Indices to pass to API routines to get the specifc data.
//

  // Strings
#define DSI_CATEGORY    0
#define DSI_FORMAT      1
#define DSI_MANAGER     2
#define DSI_COMPANY     3
#define DSI_GUID		4
#define DSI_LINKBASE    5
#define DSI_STRINGLAST  5

  // Integer statistics
#define DSI_BYTES       0
#define DSI_LINES       1
#define DSI_PARAS       2
#define DSI_SLIDES      3
#define DSI_NOTES       4
#define DSI_HIDDENSLIDES 5
#define DSI_MMCLIPS     6
#define DSI_CCHWSPACES	7	// count of characters including spaces
#define DSI_VERSION		8	// Stream format version
#define DSI_INTLAST     8

  // Booleans
#define DSI_SHAREDDOC   	  0
#define DSI_HYPERLINKSCHANGED 1
#define DSI_BOOLLAST    	  1

  // Arrays
#define DSI_HLINKS	0		// Array of hyperlinks
#define DSI_RGLAST  0

  // HLINKS array element
typedef struct _hlinkprop
{
	DWORD dwHash;
	DWORD dwApp;
	DWORD dwEscher;
	DWORD dwInfo;
	WCHAR *wzHlink1;
	WCHAR *wzHlink2;
} HLINKPROP;

/* LiNK Kind -- stored in LOWORD(dwInfo) */
#define lnkkBackground		0	// graphic shown as background of doc
#define lnkkPicture			1	// graphic shown in doc
#define lnkkFill			2	// graphic used to fill a shape
#define lnkkLine			3	// graphic used for shape outline
#define lnkkHlinkShape		4	// hyperlink attached to a shape
#define lnkkHlinkField		5	// hyperlink attached to a (Word) field
#define lnkkHlinkRange		6	// hyperlink attached to an (Excel) range

/* LiNK Action -- stored in HIWORD(dwInfo) */
#define lnkaNil				0	// nothing to do
#define lnkaChange			1	// change link to new wzHlink value
#define lnkaRemove			2	// remove link from object

// VBA Project digital signature info structure
typedef struct _DIGSIGBLOB {
	DWORD	cbData;
	BYTE	*pbData;
} DIGSIGBLOB, *PDIGSIGBLOB;

//
// Given a null terminated string, computes a hash value.
//
// Parameters:
//
//		wz  - pointer to null terminated string
//		pdw - pointer to an integer
//
// Returns:
//
//		The hash value in pdw.
//
// Notes:
//
//	1. The function uses a lower-case version of the string.
//  2. Only the first 255 characters of the string are used.
//
MSOAPI_(VOID) HashWzToInt(const WCHAR *wz, DWORD *pdw);

//
// Standard I/O routines
//

    // Indicates if the Document Summary Infodata has changed.
    //
    // Parameters:
    //
    //   lpDSIObj - pointer to Document Summary Info object
    //
    // Return value:
    //
    //   TRUE -- the data has changed, and should be saved.
    //   FALSE -- the data has not changed.
    //
MSOAPI_(BOOL ) MsoFDocSumShouldSave (LPDSIOBJ lpDSIObj);

//
// Data manipulation routines
//

    // Get the size of a given string (UNICODE) property.
    //
    // Parameters:
    //
    //   lpDSIObj - pointer to Document Summary Info object.
    //   iw - specifies which string to get the size of and should be
    //        one of the following values:
    //      DSI_CATEGORY
    //      DSI_FORMAT
    //      DSI_MANAGER
    //      DSI_COMPANY
    //
    //   pdw - pointer to a dword, will contain the cb on return
    // Return value:
    //
	// 		True on success, false otherwise
	//
MSOAPI_(BOOL)  MsoFCbDocSumString(LPDSIOBJ lpDSIObj, WORD iw, DWORD *pdw);

    // Get a given string (UNICODE) property.
    //
    // Parameters:
    //
    //   lpDSIObj - pointer to Document Summary Info object
    //   iw - specifies which string to set and should be
    //        one of the following values:
    //      DSI_CATEGORY
    //      DSI_FORMAT
    //      DSI_MANAGER
    //      DSI_COMPANY
    //
    //   wz - buffer to hold string (allocated by caller)
    //   cbMax - size of buffer
    //
    // Return value:
    //
	//	True on success, False otherwise
    //
MSOAPI_(BOOL) MsoFDocSumGetString (LPDSIOBJ lpDSIObj,
				       WORD iw,
				       DWORD cbMax,
				       WCHAR *wz);

    // Set a string (UNICODE) property to a given value
    //
    // Parameters:
    //
    //   lpDSIObj - pointer to Document Summary Info object
    //   iw - specifies which string to set and should be
    //        one of the following values:
    //      DSI_CATEGORY
    //      DSI_FORMAT
    //      DSI_MANAGER
    //      DSI_COMPANY
    //
    //   wz - buffer containing string value
    //
    // Return value:
    //
    //   The function returns TRUE on success.
    //   The function returns FALSE on error.
    //
    // Note: The function will dirty the object on success.
    //
MSOAPI_(BOOL ) MsoFDocSumSetString(LPDSIOBJ lpDSIObj, WORD iw, const WCHAR *wz);

  //
  // How Heading and Document parts work:
  //
  // Heading:
  // --------
  // Heading is a list of non-indented headings that will be
  // displayed in the "Contents" ply.
  //
  // Associated with each Heading is the number of document parts
  // that goes with the particular heading -- this is the concept of a
  // Heading Pair.
  //
  // Document Parts:
  // ---------------
  // Document Parts is a list of parts associated with a heading.
  //
  // Example (as it could be implemented in Microsoft Excel):
  // ----------------------------------------------
  // Worksheets
  //     Sheet1
  //     Sheet2
  // Modules
  //     Module1                             Figure 1
  // Charts
  //     Chart1
  //     Chart2
  //     Chart3
  //
  // Thus the Heading Pairs would be:
  //
  // Heading Pair
  //    string                           count
  //------------------------------------
  // Worksheets            2
  // Modules               1                 Figure 2
  // Charts                3
  //
  //
  // And the Document Parts would be:
  //
  // Document Parts
  //--------------------------
  // Sheet1
  // Sheet2
  // Module1
  // Chart1                                  Figure 3
  // Chart2
  // Chart3
  //
  //
  // Note: Headings and Document Parts are not restricted to be parts of
  //       a document, but can be whatever the client wants.  Car models,
  //       car makes, customers, etc...
  //
  //       The above is just an example.
  //

    // Determine how many Document Parts there are total.
    //
    // Parameters:
    //
    //   lpDSIObj - pointer to Document Summary Info object
    //   pdw      - pointer to dword, will contain the count on return
    //
    // Return value:
    //
    //   The function returns TRUE on success, FALSE on error.
    //
MSOAPIX_(BOOL ) MsoFCDocSumDocParts (LPDSIOBJ lpDSIObj, DWORD *pdw);

    // Determine how many Document Parts there are for a given heading.
    //
    // Parameters:
    //
    //   lpDSIObj    - pointer to Document Summary Info object
    //   idwHeading  - 1-based index of Heading
    //   wzHeading   - name of Heading (UNICODE)
    //   pdw         - pointer to dword, will contain the count on return
    //
    //   If wzHeading is non-null, this value will be used to look up
    //   the heading. Otherwise idwHeading will be used.
    //
    // Return value:
    //
    //   The function returns TRUE on success, FALSE on error.
    //
MSOAPI_(BOOL ) MsoFCDocSumDocPartsByHeading(LPDSIOBJ lpDSIObj,
						       DWORD idwHeading,
						       const WCHAR *wzHeading,
						       DWORD *pdw);

    // Determine the size of a specific (one) Document Part
    // for a given heading.
    //
    // Parameters:
    //
    //   lpDSIObj    - pointer to Document Summary Info object.
    //   idwPart     - 1-based index of Document part.
    //   idwHeading  - 1-based index of Heading
    //   wzHeading   - name of Heading (UNICODE)
    //   pdw         - pointer to dword, will contain cb
    //
    //   If wzHeading is non-null, this value will be used to look up
    //   the heading. Otherwise idwHeading will be used.
    //
    // Return value:
    //
    //   The function returns TRUE on success, FALSE on error
    //   (including non-existing Heading).
    //
MSOAPIX_(BOOL ) MsoFCbDocSumDocPart(LPDSIOBJ lpDSIObj,
					      DWORD idwPart,
					      DWORD idwHeading,
					      const WCHAR *wzHeading,
					      DWORD *pdw);

    // Get one of the Document Parts for a given Heading.
    //
    // Parameters:
    //
    //   lpDSIObj    - pointer to Document Summary Info object
    //   idwPart     - 1-based index of Document part
    //   idwHeading  - 1-based index of Heading
    //   wzHeading   - name of Heading (UNICODE)
    //   cbMax       -  number of bytes in wz
    //   wz          -  buffer to hold Document part (allocated by caller)
    //
    //   If wzHeading is non-null, this value will be used to look up
    //   the heading. Otherwise idwHeading will be used.
    //
    // Return value:
    //
    //   The function returns lpsz on success.
    //   The function returns NULL on errors.
    //
MSOAPI_(BOOL) MsoFDocSumGetDocPart(LPDSIOBJ lpDSIObj,
						   DWORD idwPart,
						   DWORD idwHeading,
						   const WCHAR *wzHeading,
						   DWORD cbMax,
						   WCHAR *wz);

    // Set one (existing) Document Part by heading
    //
    // Parameters:
    //
    //   lpDSIObj    - pointer to Document Summary Info object
    //   idwPart     - 1-based index of Document part
    //   idwHeading  - 1-based index of Heading
    //   wzHeading   - name of Heading
    //   wz          - buffer containing new Document Part
    //
    //   If wzHeading is non-null, this value will be used to look up
    //   the heading. Otherwise idwHeading will be used.
    //
    // Return value:
    //
    //   The function returns TRUE on success.
    //   The function returns FALSE on error.
    //
MSOAPI_(BOOL ) MsoFDocSumSetDocPart(LPDSIOBJ lpDSIObj,
					       DWORD idwPart,
					       DWORD idwHeading,
					       const WCHAR *wzHeading,
					       const WCHAR *wz);

    // Remove one (existing) Document Part by heading.
    //
    // Parameters:
    //
    //   lpDSIObj    - pointer to Document Summary Info object
    //   idwPart     - 1-based index of Document part
    //   idwHeading  - 1-based index of Heading
    //   wzHeading   - name of Heading
    //
    //   If wzHeading is non-null, this value will be used to look up
    //   the heading. Otherwise idwHeading will be used.
    //
    // Return value:
    //
    //   The function returns TRUE on success.
    //   The function returns FALSE on error.
    //
    // Note: The count for the Heading will be adjusted on success.
    //
MSOAPIX_(BOOL ) MsoFDocSumDeleteDocPart(LPDSIOBJ lpDSIObj,
						  DWORD idwPart,
						  DWORD idwHeading,
						  const WCHAR *wzHeading);

    // Insert a Document Part at the given location for a given Heading.
    //
    // Parameters:
    //
    //   lpDSIObj    - pointer to Document Summary Info object
    //   idwPart     - 1-based index of Document part to insert at
    //                   1 <= idwPart <= FCDocSumDocPartsByHeading(...)+1
    //                   idwPart = FCDocSumDocPartsByHeading(...)+1 will append a Document Part
    //   idwHeading  - 1-based index of Heading
    //   wzHeading   - name of Heading
    //   wz          - buffer containing new Document Part
    //
    //   If wzHeading is non-null, this value will be used to look up
    //   the heading. Otherwise idwHeading will be used.
    //
    // Note: If the Heading doesn't exist, the heading will be created and inserted
    //       at idwHeaing.
    //       1 <= idwHeading <= FCDocSumHeadingPairs(..)+1
    //       idwHeading = FCDocSumHeadingPairs(...)+1 will append a Heading Pair
    //
    //       In this case wzHeading should contain the heading name.
    //       idwPart will be ignored, and the docpart will be added as the first docpart
    //       for the heading.
    //
    // Return value:
    //
    //   The function returns TRUE on success.
    //   The function returns FALSE on error.
    //
    // Note: The count for the Heading will be adjusted on success.
    //
MSOAPI_(BOOL ) MsoFDocSumInsertDocPart(LPDSIOBJ lpDSIObj,
						  DWORD idwPart,
						  DWORD idwHeading,
						  const WCHAR *wzHeading,
						  const WCHAR *wz);

    // Determine how many Heading Pairs there are.
    //
    // Parameters:
    //
    //   lpDSIObj - pointer to Document Summary Info object
    //   pdw      - pointer to dword, will contain count
    //
    // Return value:
    //
    //   The function returns TRUE on success, FALSE on error.
    //
MSOAPI_(BOOL ) MsoFCDocSumHeadingPairs (LPDSIOBJ lpDSIObj, DWORD *pdw);

    // Get the size of one heading string
    //
    // Parameters:
    //
    //   lpDSIObj    - pointer to Document Summary Info object.
    //   idwHeading  - 1-based index of heading
    //   pdw         - pointer to dword, will contain cb
    //
    // Return value:
    //
    //   The function returns TRUE on success, FALSE on error.
    //
MSOAPIX_(BOOL ) MsoFCbDocSumHeadingPair (LPDSIOBJ lpDSIObj,
						  DWORD idwHeading,
						  DWORD *pdw);

    // Get one heading pair.
    //
    // Parameters:
    //
    //   lpDSIObj    - pointer to Document Summary Info object
    //   idwheading  - 1-based index of heading pair
    //   wzHeading   - name of Heading
    //   cbMax       - number of bytes in lpsz
    //   wz          - buffer to hold heading string (allocated by user)
    //   pdwcParts   - will be set to number of document parts for the heading
    //
    //   If wzHeading is non-null, this value will be used to look up
    //   the heading (could be only dwcParts is wanted).
    //   Otherwise idwHeading will be used.
    //
    // Return value:
    //
    //   The function will return TRUE on success.
    //   The function will return FALSE on error.
    //
MSOAPIX_(BOOL) MsoFDocSumGetHeadingPair(LPDSIOBJ lpDSIObj,
					    DWORD idwHeading,
					    const WCHAR *wzHeading,
					    DWORD cbMax,
					    WCHAR *wz,
					    DWORD *pdwcParts);

// #ifdef UNUSED
// Used in Binder
    // Set one heading pair
    //
    // Parameters:
    //
    //   lpDSIObj    - pointer to Document Summary Info object
    //   idwheading  - 1-based index of heading pair
    //   wzHeading   - name of Heading
    //   wz          - buffer containing heading string
    //
    //   If wzHeading is non-null, this value will be used to look up
    //   the heading (could be only dwcParts should be set).
    //   Otherwise idwHeading will be used.
    //
    // Return value:
    //
    //   The function will return TRUE on success.
    //   The function will return FALSE on error.
    //
MSOAPIX_(BOOL ) MsoFDocSumSetHeadingPair(LPDSIOBJ lpDSIObj,
						   DWORD idwHeading,
						   const WCHAR *wzHeading,
						   const WCHAR *wz);
//#endif // UNUSED

    // Delete a heading pair
    //
    // Note:  This will also delete ALL document parts associated
    //        with the heading.
    //
    // Parameters:
    //
    //   lpDSIObj    - pointer to Document Summary Info object
    //   idwheading  - 1-based index of heading pair
    //   wzHeading - name of Heading
    //
    //   If wzHeading is non-null, this value will be used to look up
    //   the heading.  Otherwise idwHeading will be used.
    //
    // Return value:
    //
    //   The function will return TRUE on success.
    //   The function will return FALSE on error.
    //
MSOAPI_(BOOL ) MsoFDocSumDeleteHeadingPair(LPDSIOBJ lpDSIObj,
						      DWORD idwHeading,
						      const WCHAR *wzHeading);

    // Delete all heading pair and all their document parts. I.e.
    // clear the contents data.
    //
    // Parameters:
    //
    //   lpDSIObj    - pointer to Document Summary Info object
    //
    // Return value:
    //
    //   The function will return TRUE on success.
    //   The function will return FALSE on error.
    //
MSOAPI_(BOOL ) MsoFDocSumDeleteAllHeadingPair (LPDSIOBJ lpDSIObj);

    // Insert a heading pair at the given location
    //
    // Parameters:
    //
    //   lpDSIObj          - pointer to Document Summary Info object
    //   idwHeading        - 1-based index of Heading pair to insert at
    //                        1 <= idwHeading <= FCDocSumHeadingPairs(..)+1
    //                        idwHeading = FCDocSumHeadingPairs(...)+1 will append a Heading Pair
    //   wzHeadingBefore   - name of a Heading
    //   wzNewHeading      - buffer containing new Heading string
    //
    //   If wzHeadingBefore is non-null, the new Heading will be inserted right before
    //   wzHeadingBefore.  To insert at the end of the list pass NULL for this parameter,
    //   and set idwHeading = cDocSumHeadingPairs+1.
    //
    // Return value:
    //
    //   The function returns TRUE on success.
    //   The function returns FALSE on error.
    //
MSOAPI_(BOOL ) MsoFDocSumInsertHeadingPair(LPDSIOBJ lpDSIObj,
					   DWORD idwHeading,
					   const WCHAR *wzHeadingBefore,
					   const WCHAR *wzNewHeading);

    // Get an integer property
    //
    // Parameters:
    //
    //   lpDSIObj - pointer to Document Summary Info object
    //   iw - specifies which integer to get and should be
    //        one of the following values:
    //      DSI_BYTES
    //      DSI_LINES
    //      DSI_PARAS
    //      DSI_SLIDES
    //      DSI_NOTES
    //      DSI_HIDDENSLIDES
    //      DSI_MMCLIPS
	//		DSI_CCHWSPACES
	//		DSI_VERSION
    //
    //   pdw - pointer to dword, will contain integer
    //
    // Return value:
    //
    //   The function returns TRUE on success, FALSE on error
	//
	//	Note: If you ask for DSI_VERSION and the function returns false
	//		  that means (assuming all parameters are valid) that the property
	//		  wasn't in the stream, and as such the property data was originally 
	//		  in the Office 95 property format.
	//		
MSOAPI_(BOOL ) MsoFDwDocSumGetInt (LPDSIOBJ lpDSIObj, WORD iw, DWORD *pdw);

    // Set an integer property to a given value
    //
    // Parameters:
    //
    //   lpDSIObj - pointer to Document Summary Info object
    //   iw - specifies which integer to set and should be
    //        one of the following values:
    //      DSI_BYTES
    //      DSI_LINES
    //      DSI_PARAS
    //      DSI_SLIDES
    //      DSI_NOTES
    //      DSI_HIDDENSLIDES
    //      DSI_MMCLIPS
	//		DSI_CCHWSPACES
    //
    //   dw - the value 
    //
    // Return value:
    //
    //   The function returns TRUE on success.
    //   The function returns FALSE on error.
    //
    // Note: The function will dirty the object on success.
    //
	// Note: You cannot set DSI_VERSION
	//	
MSOAPI_(BOOL ) MsoFDocSumSetInt (LPDSIOBJ lpDSIObj, WORD iw, DWORD dw);


// #ifdef UNUSED
// Used in Binder
    // Get the Scalability property
    //
    // Parameters:
    //
    //   lpDSIObj - pointer to Document Summary Info object
    //
    // Return value:
    //
    //   The function returns TRUE when scaling, FALSE when cropping.
    //
    //   The function will also return FALSE on error, i.e. if lpDSIObj is null
    //   or there is no data in the object.
    //
MSOAPIX_(BOOL ) MsoFDocSumGetScalability (LPDSIOBJ lpDSIObj);
//#endif // UNUSED

    // Determine if the object has the Scalable property
    //
    // Parameters:
    //
    //   lpDSIObj - pointer to Document Summary Info object
    //
    // Return value:
    //
    //   The function returns TRUE if scaling, FALSE otherwise.
    //
    //   The function will also return FALSE on error, i.e. if lpDSIObj is null
    //   or there is no data in the object.
    //
MSOAPIX_(BOOL ) MsoFDocSumIsScalable (LPDSIOBJ lpDSIObj);

    // Determine if the object has the Croppable property
    //
    // Parameters:
    //
    //   lpDSIObj - pointer to Document Summary Info object
    //
    // Return value:
    //
    //   The function returns TRUE when cropping, FALSE otherwise.
    //
    //   The function will also return FALSE on error, i.e. if lpDSIObj is null
    //   or there is no data in the object.
    //
MSOAPIX_(BOOL ) MsoFDocSumIsCroppable (LPDSIOBJ lpDSIObj);

    // Set the Scalability property
    //
    // Parameters:
    //
    //   lpDSIObj - pointer to Document Summary Info object
    //   fScalable - should be set to TRUE if setting to scalable,
    //               should be set to FALSE if setting to cropping
    // Return value:
    //
    //   The function returns TRUE on success.
    //   The function returns FALSE on error.
    //
    // Note: The function dirties the object on success.
    //
MSOAPIX_(BOOL ) MsoFDocSumSetScalability (LPDSIOBJ lpDSIObj, BOOL fScalable);

    // Determine if the actual values of the LINKED user defined properties has changed
	 // This function should only be called right after loading the properties to
	 // see if the caller should update the link values.
	 //
	 // NOTE: The function works by checking the value of the PID_LINKSDIRTY property.
	 //       When this function is called the property will be set to FALSE, so that
	 //       flag is cleared next time the properties are saved.
	 //
	 // NOTE: Only the app that created the file that are being loaded should call this
	 //       function.  I.e. Excel calls this for .xls files, noone else does, etc...
     //
     // Parameters:
     //
     //     lpDSIObj - pointer to Document Summary Info object
     //
     // Return value:
     //
     //     The function returns TRUE if the link values have changed.
     //     The function returns FALSE if the link value have not
     //     changed, or on error.
     //
MSOAPI_(BOOL ) MsoFLinkValsChanged(LPDSIOBJ lpDSIObj);

    // Set the DSI_GUID string (UNICODE) property to the value of a newly 
    // created GUID.  Applications should call this function only when saving
    // a document for the first time (such as during File-SaveAs).  
    // This function allocates a new GUID via CoCreateGuid, converts the GUID
    // to a string, and sets the DSI_GUID property to this string. 
    //
    // Parameters:
    //
    //   lpDSIObj - pointer to Document Summary Info object
    //
    // Return value:
    //
    //   The function returns TRUE on success.
    //   The function returns FALSE on error.
    //
    // Note: The function dirties the object on success.
    //
MSOAPI_(BOOL ) MsoFDocSumSetGUID(LPDSIOBJ lpDSIObj);

    // Get a boolean property
    //
    // Parameters:
    //
    //   lpDSIObj - pointer to Document Summary Info object
    //   iw - specifies which boolean to get and should be
    //        one of the following values:
    //      DSI_SHAREDDOC - is the document shared or not
    //		DSI_HYPERLINKSCHANGED - did the hyperlinks change
	//
    //   pf - pointer to BOOL, will contain boolean
    //
    // Return value:
    //
    //   The function returns TRUE on success, FALSE on error
    //
MSOAPI_(BOOL ) MsoFDocSumGetBool (LPDSIOBJ lpDSIObj, WORD iw, BOOL *pf);

    // Set a boolean property 
    //
    // Parameters:
    //
    //   lpDSIObj - pointer to Document Summary Info object
    //   iw - specifies which boolean to set and should be
    //        one of the following values:
    //      DSI_SHAREDDOC - is the document shared or not
    //		DSI_HYPERLINKSCHANGED - did the hyperlinks change
    //
    //   f - the value 
    //
    // Return value:
    //
    //   The function returns TRUE on success.
    //   The function returns FALSE on error.
    //
    // Note: The function will dirty the object on success.
    //
MSOAPI_(BOOL ) MsoFDocSumSetBool (LPDSIOBJ lpDSIObj, WORD iw, BOOL f);


	//
	// Get the count of elements in an array
	//
	// Parameters:
	//
	//		lpDSIObj   - pointer to a Document Summary Info object
	//		iArray     - specifies the array
	//		pcElements - will hold the count of elements, 0 if none
	//
	// Return value:
	//
	//		The function returns TRUE on success (even if count is 0)
	//		The function returns FALSE on error.
	//
	// Notes:
	//	
	// 1. Legal values for iArray are:
	//
	//		DSI_HLINKS
	//
MSOAPI_(BOOL) MsoFDocSumGetArrayElementCount(LPDSIOBJ lpDSIObj, DWORD iArray, DWORD *pcElements);

	//
	// Set the ith element in an array.
	//
	// Parameters:
	//
	//		lpDSIObj   - pointer to a Document Summary Info object
	//		iArray     - specifies the array
	//		iElement   - specifies the element
	//		pvData	   - points to the data (array element)
	//
	// Return value:
	//
	//		The function returns TRUE on success
	//		The function returns FALSE on error.
	//
	// Notes:
	//
	// 1. Legal values for iArray are:
	//
	//		DSI_HLINKS
	//
	// 2. If iElement == -1, the element will be added to the end of the array.
	// 3. iElement is 0-based.
	// 4. You can always set an element at position 0 or -1.  This is equivalent
	//    to creating the array if it doesn't exist.
	// 5. If iElement already exists in the array, the data will be replaced.
	// 6. pvData will be typecast to the correct type of array element.
	//
MSOAPI_(BOOL) MsoFDocSumSetArrayElement(LPDSIOBJ lpDSIObj, DWORD iArray, DWORD iElement, PVOID pvData);

	//
	// Get the ith element in an array.
	//
	// Parameters:
	//
	//		lpDSIObj   - pointer to a Document Summary Info object
	//		iArray     - specifies the array
	//		iElement   - specifies the element
	//		pvData	   - will point to the data (array element)
	//
	// Return value:
	//
	//		The function returns TRUE on success
	//		The function returns FALSE on error.
	//
	// Notes:
	//
	// 1. Legal values for iArray are:
	//
	//		DSI_HLINKS
	//
	// 2. iElement is 0-based.
	// 3. pvData can be typecast to the appropriate type of array element.
	//    The caller should not free any memory hanging off of pvData.
	// 4. It's the caller's resposibility to make sure that pvData points
	//    to the correct data structure.
	//
MSOAPI_(BOOL) MsoFDocSumGetArrayElement(LPDSIOBJ lpDSIObj, DWORD iArray, DWORD iElement, PVOID pvData);

	//
	// Delete the ith element from an array
	//
	// Parameters:
	//
	//		lpDSIObj   - pointer to a Document Summary Info object
	//		iArray     - specifies the array
	//		iElement   - specifies the element
	//
	// Return value:
	//
	//		The function returns TRUE on success
	//		The function returns FALSE on error.
	//
	// Notes:
	//
	// 1. Legal values for iArray are:
	//
	//		DSI_HLINKS
	//
	// 2. iElement is 0-based.
	//
MSOAPI_(BOOL) MsoFDocSumDeleteArrayElement(LPDSIOBJ lpDSIObj, DWORD iArray, DWORD iElement);

	// 
	// Delete the entire array
	//
	// Parameters:
	//
	//		lpDSIObj   - pointer to a Document Summary Info object
	//		iArray     - specifies the array
	//
	// Return value:
	//
	//		The function returns TRUE on success
	//		The function returns FALSE on error.
	//
	// Notes:

	// 1. Legal values for iArray are:
	//
	//		DSI_HLINKS
	//
	// 2. Deleting the last element from the array also deletes the array.
	//
MSOAPI_(BOOL) MsoFDocSumDeleteArray(LPDSIOBJ lpDSIObj, DWORD iArray);

    // Set the digital signature property to a given value
    //
    // Parameters:
    //
    //   lpDSIObj - pointer to Document Summary Info object
    //
    //   pDigSig - the value 
    //
    // Return value:
    //
    //   The function returns TRUE on success.
    //   The function returns FALSE on error.
    //
    // Note: The function will dirty the object on success.
    //
MSOAPI_(BOOL) MsoFDocSumSetDigSig (LPDSIOBJ lpDSIObj, PDIGSIGBLOB pDigSig);

    // Get the digital signature property
    //
    // Parameters:
    //
    //   lpDSIObj - pointer to Document Summary Info object
    //
    //   pDigSig - the value 
    //
    // Return value:
    //
    //   The function returns TRUE on success.
    //   The function returns FALSE on error.
    //
MSOAPI_(BOOL) MsoFDocSumGetDigSig (LPDSIOBJ lpDSIObj, PDIGSIGBLOB *ppDigSig);

MSOAPI_(BPSC) MsoBpscBulletProofDsinfo(MSOBPCB *pmsobpcb, LPDSIOBJ *ppdsiobj);

#ifdef __cplusplus
}; // extern "C"
#endif


////////////////////////////////////////////////////////////////////////////////
//
// MS Office User Defined Property Information
//
// The User Defined Property Information follows the serialized format for
// property sets defined in Appendix B ("OLE Property Sets") of
// "OLE 2 Programmer's Reference, Volume 1"
//
// Notes:
//  - define OLE_PROPS to build OLE 2 interface objects too.
//
// The actual data is stored in USERPROP.  The layout of the first
// 3 entries must not be changed, since it will be overlayed with
// other structures.  All property exchange data structures have
// this format.
//
// The first parameter of all functions must be LPUDOBJ in order for these
// functions to work as OLE objects.
//
// All functions defined here have "UserDef" in them.
//
// Several macros are used to hide the stuff that changes in this
// file when it is used to support OLE 2 objects.
// They are:
//   UDPVTBLSTRUCT - For OLE, expands to the pointer to the interface Vtbl
//              - Otherwise, expands to dummy struct same size as Vtbl
//   LPUDOBJ    - For OLE, expands to a pointer to the interface which is
//                just the lpVtbl portion of the data, to be overlayed later.
//              - Otherwise, expands to a pointer to the whole data
//
////////////////////////////////////////////////////////////////////////////////

  // Create a placeholder Vtbl for non-OLE objects.
#define UDPVTBLSTRUCT struct _UDPVTBLSTRUCT { void FAR *lpVtbl; } UDPVTBLSTRUCT

  // For non-OLE objects, first param is pointer to real data.
#define LPUDOBJ LPUSERPROP

  // User-defined property data.  Callers should *never* access this
  // data directly, always use the supplied API's.

typedef struct _USERPROP {

  UDPVTBLSTRUCT;                            // Vtbl goes here for OLE objs,
					    // Must be here for overlays to work!
  BOOL                m_fObjChanged;        // Indicates the object has changed
  LPVOID              m_lpData;             // Pointer to the real data

} USERPROP, FAR * LPUSERPROP;


//
// Interface API's for User Property Information.
//
#ifdef __cplusplus
extern "C" {
#endif

//
// Standard I/O routines
//
    // Indicates if the data has changed, meaning a write is needed.
MSOAPI_(BOOL ) MsoFUserDefShouldSave (LPUDOBJ lpUDObj);

//
// Routines to query and modify data.
//
  //
  // How User-defined properties work:
  //
  // See the OLE Property Exchange spec for full details.
  //
  // Each User-defined type has a string "Name" and integer Property Id
  // value associated with it.  The Property Id's are sequential, but
  // are only good for the current object in memory (i.e. you can't count
  // on the Property Id value remaining the same between loads of the
  // data.  The string will remain the same, if it has not been changed
  // or deleted.)
  // Currently, the User-defined types can have 5 types for the value:
  // String, Date, Integer, float and boolean.  When setting and getting the values, you
  // must make sure that the type stored matches what you expect to
  // retreive.  For Int's, the LPVOID should be the int itself, not
  // a pointer.  In all other cases, the LPVOID should point to a buffer
  // of appropriate size for the type.
  //

  // Masks used for querying property data.  Note that these are
  // mutually exclusive.
#define UD_STATIC       0x00
#define UD_LINK         0x01
#define UD_IMONIKER     0x10

    // Determine the number of user-defined properties for the object.
    // Returns -1 on error
MSOAPI_(BOOL ) MsoFCUserDefNumProps (LPUDOBJ lpUDObj, DWORD *pdw);

    // Determine the size of the Property Value for the given Property string
    // Note that for types other that wUDlpsz, this will return the size
    // of the structure that holds the data.
    // dwMask is used to specify whether the cb is for the static value
    //   or for the link or IMoniker name.  For Links & IMonikers,
    //   the type is wUDlpsz.
    // pcb - will hold the cb
    // Returns FALSE on error, TRUE on success
	//
	// Note that all strings are UNICODE
	//
MSOAPI_(BOOL) MsoFCbUserDefPropVal
  (LPUDOBJ lpUDObj,             // Pointer to object
   const WCHAR *wz,                   // Pointer to string
   DWORD dwMask,                // Mask telling what value to get cb for
   DWORD *pdw);                 // Pointer to dword

    // Returns the type of the given Property Value from the string
    // Returns wUDInvalid on error
	// 
MSOAPI_(UDTYPES) MsoUdtypesUserDefType(LPUDOBJ lpUDObj, const WCHAR *wz);

    // This will return the Property Value for the given Property string.
    // lpszProp is the property string
    // lpv is a buffer to hold the value, of size cbMax.
    // pfLink tells if the value is a link,
    // pfIMoniker tells if the value is a moniker.
    // pfLinkInvalid tells if the link is invalid
    // dwMask is used to specify whether the value returned is the
    //  static value, link name or IMoniker name.
	//
    // Function returns NULL on error.
	//
    // WARNING! Be very careful calling this.  Be sure that the
    // buffer and return value match the type for the Property Value!
	//

MSOAPI_(LPVOID) MsoLpvoidUserDefGetPropVal
  (LPUDOBJ lpUDObj,             // Pointer to object
   const WCHAR *wzProp,               // Property string
   DWORD cbMax,                 // Size of lpv
   LPVOID lpv,                  // Buffer for prop val
   DWORD dwMask,                // Mask for what value is needed
   BOOL *pfLink,                // Indicates a link
   BOOL *pfIMoniker,            // Indicates an IMoniker
   BOOL *pfLinkInvalid);        // Is the link invalid

    // Set the value of a given property to a new value.
    // Be careful when setting properties that are linked - be sure
    // that the type the iterator is set to matches what the link is to.
    // If udtype == wUDinvalid, the type of the iterator will not change,
    // the value will be assumed to be the current type.
    //
	// fLinkInvalid : If the link is no longer valid, set this flag to true.
 	//                A special icon will displayed in the listview and the last
	//                known value and type will be used.  Thus the values passed
	//                to this function will be ignored in this case.
	//
	//                If fLinkInvalid is true, but the iterator is not a link,
	//                the function will return FALSE
    //
    //                If fLinkInvalid is true the value will _not_ be changed.
	//
	// NOTE: If udtype == wUDDate you can set the value to 0 (not NULL)
	//       This will be interpreted as an invalid date and the date will
	//              be displayed as the empty string in the list box.
MSOAPI_( BOOL ) MsoFUserDefChangeVal
  (LPUDOBJ lpUDObj,                     // Pointer to object
   const WCHAR *wzProp,                       // Property string
   UDTYPES udtype,                      // Type of new value
   LPVOID lpv,                          // New value.
   BOOL fLinkInvalid);				    // Is the link still valid?

    // Set the string (i.e. the name) for the given Property String (lpszOld) 
    // to the new string (lpszNew).
MSOAPIX_(BOOL) MsoFUserDefSetPropString
  (LPUDOBJ lpUDObj,             // Pointer to object
   const WCHAR *wzOld,                // Old prop string
   const WCHAR *wzNew);               // New prop string

//
// Routines to create and remove data from the Property Set.
//

    // This will add a new Property to the set, with the given
    // Property string.  This function can also be used to modify
    // an existing property.
    //
    // lpUDObj      - pointer to the UD properties
    // wzPropName   - name of property to be added/modified
    // lpvVal       - value of the property
    // udtype       - value type
    // wzLinkMonik  - name of the link/moniker
    // fLink        - true if the property is a link
    // fIMoniker    - true if the property is an imoniker
    // fHidden      - true if the property is hidden
    //
    // NOTE: fLink and fIMoniker cannot be true at the same time.  If
    //       so, the property will not be added and the function will
    //       return FALSE.
    //
    //
    // NOTE: If udtype == wUDbool, lpv must point to a DWORD, but the
    //       HIWORD must be 0.
    //
    // WARNING: Be sure that the type matches what the lpv really is!
    //
    // The caller is responsible for freeing any memory
    // associated with a property value after it is added to the
    // User-defined Property object.
    //
	// NOTE: If udtype == wUDDate you can set the value to 0 (not NULL)
	//       This will be interpreted as an invalid date and the date will
	//              be displayed as the empty string in the list box.
    //
    // The function returns TRUE if the property was succesfully added,
    // FALSE otherwise.
    //
MSOAPI_(BOOL) MsoFUserDefAddProp
  (LPUDOBJ lpUDObj,             // Pointer to object
   const WCHAR *wzPropName,           // Property string
   LPVOID lpv,                  // Property value
   UDTYPES udtype,              // Property type
   const WCHAR *wzLinkMonik,          // The link/imoniker name
   BOOL fLink,                  // Indicates the property is a link
   BOOL fHidden,                // Indicates the property is hidden
   BOOL fIMoniker);             // Indicates the property is a moniker.

    // This will delete a Property from the set given a Property string.
MSOAPI_(BOOL ) MsoFUserDefDeleteProp (LPUDOBJ lpUDObj, const WCHAR *wz);

//
// Routines to iterate through the User-defined properties
//
// Notes: Adding and deleting elements invalidates the iterator.
//
    // An iterator for User-defined Properties
  typedef struct _UDITER FAR * LPUDITER;

    // Create a User-defined Properties iterator
MSOAPI_(LPUDITER ) MsoLpudiUserDefCreateIterator (LPUDOBJ lpUDObj);

    // Destroy a User-defined Properties iterator
MSOAPI_(BOOL ) MsoFUserDefDestroyIterator (LPUDITER *lplpUDIter);

    // Determine if an iterator is still valid
MSOAPI_(BOOL ) MsoFUserDefIteratorValid (LPUDITER lpUDIter);

    // Iterate to the next element
	 // Returns TRUE if we could get to the next element, FALSE otherwise.
MSOAPI_(BOOL ) MsoFUserDefIteratorNext (LPUDITER lpUDIter);

    // Returns true if the iterator is a link, false otherwise
MSOAPI_(BOOL) MsoFUserDefIteratorIsLink (LPUDITER lpUDIter);

    // Returns true if the iterator is an invalid link, returns false if the
    // iterator is not a link or if the iterator is a valid link
MSOAPI_(BOOL) MsoFUserDefIteratorIsLinkInvalid (LPUDITER lpUDIter);

    // Determine the size of the Property Value for the given iterator
    // Note that for types other that UDlpsz, this will return the size
    // of the structure that holds the data.
    // dwMask is used to specify whether the cb is for the static value
    //   or for the link or IMoniker name.  For Links & IMonikers,
    //   the type is wUDlpsz.
    // Returns 0 on error
MSOAPI_(BOOL ) MsoFCbUserDefIteratorVal (LPUDITER lpUDIter, DWORD dwMask, DWORD *pcb);

    // Returns the type of the given Property Value from the iterator
    // Returns wUDInvalid on error
MSOAPI_(UDTYPES ) MsoUdtypesUserDefIteratorType (LPUDITER lpUDIter);

    // This will return the Property Value for the given iterator
    // lpv is a buffer to hold the value, of size cbMax.
    // dwMask is used to specify whether the value returned is the
    //  static value, link name or IMoniker name.
    // pfLink tells if the value is a link,
    // pfIMoniker tells if the value is a moniker.
	 // pfLinkInvalid tells if the link is invalid.
    // Function returns NULL on error.
    // WARNING! Be very careful calling this.  Be sure that the
    // buffer and return value match the type for the Property Value!
	// 
	// Note that strings are UNICODE
	//
MSOAPI_(LPVOID ) MsoLpvoidUserDefGetIteratorVal (LPUDITER lpUDIter,
						DWORD cbMax,
						LPVOID lpv,
						DWORD dwMask,
						BOOL *pfLink,
						BOOL *pfIMoniker,
						BOOL *pfLinkInvalid);

    // Set the value of the iterator item to a new value.
    // Be careful when setting properties that are linked - be sure
    // that the type the iterator is set to matches what the link is to.
    // If udtype == wUDinvalid, the type of the iterator will not change,
    // the value will be assumed to be the current type.
    //
	// fLinkInvalid : If the link is no longer valid, set this flag to true.
	//                A special icon will displayed in the listview and the last
	//                known value and type will be used.  Thus the values passed
	//                to this function will be ignored in this case.
	//
	//                If fLinkInvalid is true, but the iterator is not a link,
	//                the function will return FALSE
    //
    //                If fLinkInvalid is true the value will _not_ be changed.
    //
    //                If fLinkInvalid is false, the value _will_ be changed.
	//
	// NOTE: If udtype == wUDDate you can set the value to 0 (not NULL)
	//       This will be interpreted as an invalid date and the date will
	//              be displayed as the empty string in the list box.

MSOAPI_(BOOL ) MsoFUserDefIteratorChangeVal (LPUDOBJ lpUDObj,
						   LPUDITER lpUDIter,
						   UDTYPES udtype,
						   LPVOID lpv,
						   BOOL fLinkInvalid);

    // This will return the size of the Property string for the property
MSOAPI_(BOOL ) MsoFCbUserDefIteratorName (LPUDITER lpUDIter, DWORD *pcb);

    // This will return the Property String (name) for the property
MSOAPI_(BOOL) MsoFUserDefIteratorName
  (LPUDITER lpUDIter,                   // Pointer to iterator
   DWORD cbMax,                         // Max size of lpsz
   WCHAR *wz);                          // Buffer to copy into

    // Set the string (i.e. property name) for the given Property String (lpszOld) 
    // to the new string (lpszNew).
MSOAPIX_( BOOL ) MsoFUserDefIteratorSetPropString
  (LPUDOBJ lpUDObj,                     // Pointer to object
   LPUDITER lpUDIter,                   // Pointer to iterator
   const WCHAR *wzNew);                  // Pointer to new name

//
// Misc. utility routines
//

  // Routines dealing with hidden Properties.

    // Determine if a Property string is hidden.
MSOAPI_(BOOL) MsoFUserDefIsHidden
  (LPUDOBJ lpUDObj,             // Pointer to object
   const WCHAR *wz);                  // Property string

    // Make a property visible based on the Property string
MSOAPIX_(BOOL) MsoFUserDefMakeVisible
  (LPUDOBJ lpUDObj,             // Pointer to object
   const WCHAR *wz);                  // String to show.

    // Hide a Property based on the Property string.
MSOAPIX_(BOOL) MsoFUserDefMakeHidden
  (LPUDOBJ lpUDObj,             // Pointer to object
   const WCHAR *wz);                  // String to hide

MSOAPI_(BPSC) MsoBpscBulletProofUdinfo
  (MSOBPCB *pmsobpcb,
  LPUDOBJ *ppudobj);

#ifdef __cplusplus
}; // extern "C"
#endif

#ifdef __cplusplus
extern "C" {
#endif

  // Commands for DWQUERYLD
#define QLD_CLINKS      1  /* Return the number of links */
#define QLD_LINKNAME    2  /* Return a pointer to the string for index */
#define QLD_LINKTYPE    3  /* Returns the type of the value of the index */
#define QLD_LINKVAL     4  /* Return value for the index, use same
						      rules as for LPVOIDs in UserDef functions */

  // This functions should respond to the above commands by returning the
  // appropriate value.  For commands that require an index, the
  // wzName parameter will be the Name of the link item previously
  // retrieved from the index, if it is not NULL.
  // lplpvBuf is the buffer supplied by "us" (the dll) to copy the
  // value to.  Use the function LpvOfficeCopyValToBuffer() to 
  // copy the data.  This parameter will be NULL for QLD_CLINKS and
  // QLD_VALTYPE
typedef DWORD_PTR (OFC_CALLBACK *DWQUERYLD)(DWORD dwCommand, DWORD_PTR dwi, LPVOID *lplpvBuf, WCHAR *wzName);


    // Copies the given data to the given buffer.  Pointer to the
    // buffer is returned.
    // lpvVal - Value to copy into buffer
    // udtype - Type for the value
    // lplpvBuf - Buffer to copy into
	//
MSOAPI_(LPVOID ) MsoLpvOfficeCopyValToBuffer (LPVOID lpvVal,
				 							  UDTYPES udtype,
						    				  LPVOID *lplpvBuf);

  // Masks for different options
#define OSPD_ALLOWLINKS         0x01   // The Custom dialog will allow fields to be linked if this is set.
#define OSPD_NOSAVEPREVIEW      0x02   // Don't show the Save Preview Picture checkbox
#define OSPD_SAVEPREVIEW_ON     0x04   // Save Preview Picture should be on by default
#define OSPD_CAPTIONFORFILENAME 0x08   // Display the caption as the filename too.
#define OSPD_NOLASTACCESSED     0x10   // Don't display the Last Accessed field on the Statistics tab.
#define OSPD_NOLASTPRINT        0x20   // Don't display the Last Print field on the Statistics tab.
#define OSPD_READONLY           0x40   // Display the dialog in read-only mode

    // LPUDObj is a pointer to a pointer to a user-defined property object.
    // If *lplpUDObj == NULL, an object will be created by the dialog as needed.
    // Note that the object will use the same malloc & free routines as
    // the lpSIObj uses.
    //
    // wzFileName is the fully qualified name of the storage as it appears
    // in the filesystem.  This can be NULL if no file exists.
    //
    // dwMask contains either 0 or a set of valid flags for various options.
    //
    // LPFN_DWQLD is a callback, that when given a dwCommand of 0
    // returns the number of links, and for any other number 0 < NumLinks,
    // places the link data & static value in the lpld buffer and returns non-0
    // if the function succeeded.
    //
    // The storage for the buffer is to be allocated by the app, and a pointer
    // to that storage passed back.
    //
    // pptCtr - POINT struct filled with the coordinates of the center 
    //          of the dialog.  Used to make sure we are using sticky
    //          dialog coordinates.  If pPoint->x == -1, we ignore and use
    //          the default position for the dialog.
    //
    //          pptCtr will be filled with the coordinates of the new position
    //          of the dialog on returning.
    //
    //          The coordinates should be in client area coordinates, i.e. in
    //          hWndParent coordinates.
    //
    // wzCaption - caption for the dialog.  This should be the filename as it is
    //             displayed in the apps document title bar.
    //             The properties dialog caption will be as follows:
    //
    //               <foo> Properties
    //
    //               where foo is the string pointed to by wzCaption.
    //
	// wzFileType - Override for the file type field on the General tab.
	//              If NULL is passed in, the system will determine the file type.
	//
    // The function returns TRUE on success, FALSE on error or if the user hit Cancel.
    //
    // Note: It's the caller's resposibility to invalidate any links (if appropriate)
    //       before calling this function.
    //
    // Note: If lpfnDwQueryLinkData is NULL, the caller must invalidate any linked properties.
    //
MSOAPI_(BOOL ) MsoFOfficeShowPropDlg (HWND hWndParent,
				     				  const WCHAR *wzFileName,
				     				  LPSIOBJ lpSIObj,
				     				  LPDSIOBJ lpDSIObj,
				     				  LPUDOBJ FAR *lplpUDObj,
					      			  DWORD dwMask,
				     				  DWQUERYLD lpfnDwQueryLinkData,
				     				  LPPOINT pptCtr,
				     				  const WCHAR *wzCaption,
				     				  const WCHAR *wzFileType);


/*-----------------------------------------------------------------------------
	MsoFOfficeShowPropDlgEx

	Same as MsoFOfficeShowPropDlg with addition of the "signatures" tab if
	pissc is not NULL

	new params:
	[in] pissc --> signature set client implemented by client app
	[in] pvSignatureClient --> client specific data
	[in] fSigOnly --> TRUE if only want to show the signatrue tab, set
	                  when calling this API through sigature toolbar button.
	                  reuse the code whenever we can (not elegant design, but
	                  cheap in terms of dev time)
-------------------------------------------------------------------- HAILIU -*/
MSOAPI_(BOOL) MsoFOfficeShowPropDlgEx(HWND hWndParent,
				     				  const WCHAR *wzFileName,
				     				  LPSIOBJ lpSIObj,
				     				  LPDSIOBJ lpDSIObj,
				     				  LPUDOBJ FAR *lplpUDObj,
					      			  DWORD dwMask,
				     				  DWQUERYLD lpfnDwQueryLinkData,
				     				  LPPOINT pptCtr,
				     				  const WCHAR *wzCaption,
				     				  const WCHAR *wzFileType,
									  IMsoSignatureSetClient *pissc,
									  LPVOID pvSignatureClient,
									  BOOL fSigOnly
				     				  );
				     				  
    // Creates and initializes all non-NULL objects.
    // Create the object and return it.  Caller responsible for destruction.
    //
    // rglpfn is an array, with the following callbacks supplied by the user:
    //
    //  Code Page Conversion
    //
    //  rglpfn[ifnCPConvert] = (BOOL) (OFC_CALLBACK *lpfnFCPConvert) (LPSTR lpsz,
    //                                                  DWORD dwFrom,
    //                                                  DWORD dwTo,
    //                                                  BOOL fMacintosh)
    //    lpsz is a 0 terminated C string, dwFrom is the code page
    //    lpsz is currently stored as, dwTo is the code page it should
    //    be converted to, fMacintosh indicates whether dwFrom is a Mac
    //    or Windows code page identifier.
	//
	//	  For the MAC, the following code page indentifiers are used for dwTo.
	//	  (Mac code pages (10000+script ids))
	//
	//	  To determine if dwTo is Mac or Win, use MsoFMacCp defined below.
	//
#define msocpidMac		(10000)			/* Mac, smRoman */
#define msocpidMacSJIS ((10000+1))		/* Mac, smJapanese */
#define msocpidMacBIG5 ((10000+2))		/* Mac, smTradChinese */
#define msocpidMacKSC  ((10000+3))		/* Mac, smKorean */
#define msocpidMArab	((10000+4))		/* Mac, smArabic */
#define msocpidMHebr	((10000+5))		/* Mac, smHebrew */
#define msocpidMGreek	((10000+6))		/* Mac, smGreek */
#define msocpidMCyril	((10000+7))		/* Mac, smCyrillic */
#define msocpidMacPRC  ((10000+25))		/* Mac, smSimpChinese */
#define msocpidMSlavic	((10000+29))		/* Mac, smEastEurRoman */
#define msocpidMIce    ((10000+64+15))	/* Mac, smRoman,langIcelandic */
#define msocpidMTurk   ((10000+64+17))	/* Mac, smRoman,langTurkish */
#define msocpidMacGB2312	((10000+31))		/* Mac, smChinese */

#define msocpidMacLast	((10000+64+256))	/* highest Mac msocpid (just a guess) */

#define MsoFMacCp(cp) ((cp) >= msocpidMac && (cp) <= msocpidMacLast)

    //
    //  Convert an sz to a double
    //
    //  rglpfn[ifnFWzToNum] = (BOOL) (OFC_CALLBACK *lpfnFWzToNum)(
    //                                   double *lpdbl,
    //                                   LPSTR lpszNum)
    //
    //   lpdbl - pointer to a double, this is set by the app
    //   lpszNum - zero-terminated string representing the number
    //
    //  Convert a double to an sz
    //
    //  rglpfn[ifnFNumToWz] = (BOOL) (OFC_CALLBACK *lpfnFNumToWz)(
    //                                   double *lpdbl,
    //                                   LPSTR lpszNum,
    //                                   DWORD cbMax)
    //   lpdbl   - pointer to a double
    //   lpszNum - on return a zero-terminated string representing the number
    //   cbMax   - Max number of bytes in lpszNum
    //
    //   Update the statistics on the Statistics tab
    //
    //   rglpfn[ifnFUpdateStats] = (BOOL) (OFC_CALLBACK *lpfnFUpdateStats)(
    //                                       HWND hwndParent,
    //                                       LPSIOBJ lpSIObj,
    //                                       LPDSIOBJ lpDSIObj)
    //
    //      hwndParent - window of the properties dialog, so that the app
    //                   can put up an alert, letting the user know the the
    //                   data is being updated.
    //
    //      lpSIObj, lpDSIObj - objects to update
    //
    //   Note:  If the app does not want to set the statistics before bringing up
    //          the dialog, they can provide this callback function.  If the
    //          function pointer is not NULL, the function will be called the first
    //          time the user clicks on the Statistics tab.  The app should then update
    //          all appropriate statistics for the tab and return TRUE on success, FALSE
    //          on failure.  If the function pointer is NULL, the existing data will be
    //          used.
    //
    //  Note:
    //         Only rglpfn[ifnCPConvert] must be non-NULL.  If it is NULL, the
    //         function will return FALSE, and the objects will not be created.
    //
    //         rglpfn[ifnFWzToNum] and rglpfn[ifnFNumToWz] must either both be
    //         non-NULL, or NULL.  Otherwise, the function will return FALSE, and
    //         the objects will not be created.  If both functions are NULL, there
    //         will be no floating point support in OLE Extended Properties (i.e. on
    //         the Custom tab), but integers will be supported.
	//
	//  Note:  hinst must be non-NULL.
    //
MSOAPI_(BOOL ) MsoFOfficeCreateAndInitObjects (LPSIOBJ *lplpSIObj,
										     LPDSIOBJ *lplpDSIObj,
										     LPUDOBJ *lplpUDObj,
										     void *prglpfn[],
										     HMSOINST hinst);

    // Clear any non-null objects
MSOAPI_(BOOL ) MsoFOfficeClearObjects (LPSIOBJ lpSIObj,
								     LPDSIOBJ lpDSIObj,
								     LPUDOBJ lpUDObj);

    // Destroy any non-null objects
MSOAPI_(BOOL ) MsoFOfficeDestroyObjects (LPSIOBJ *lplpSIObj,
								       LPDSIOBJ *lplpDSIObj,
					    			   LPUDOBJ *lplpUDObj);

  // Use these functions to set the dirty flag of the given object.
  // Note: It's the caller's responsibility to make sure that the
  //       object is non-NULL
MSOAPI_(VOID ) MsoOfficeDirtySIObj(LPSIOBJ lpSIObj, BOOL fDirty);

MSOAPI_(VOID ) MsoOfficeDirtyDSIObj(LPDSIOBJ lpDSIObj, BOOL fDirty);

MSOAPI_(VOID ) MsoOfficeDirtyUDObj(LPUDOBJ lpUDObj, BOOL fDirty);


// Flags for Load & Save
#define OIO_ANSI                0x0001 // The storage is an ANSI storage (UNICODE is the default)
#define OIO_SAVEIFCHANGEONLY    0x0002 // Only streams that are dirty should be saved.
#define OIO_SAVESIMPLEDOCFILE   0x0004 // The storage is a simple DOC file.
#define OIO_SAVE_AS_95          0x0008 // Save the properties in the 95 format
#define OIO_SAVE_AS_UNICODE     0x0010 // Save the properties in UNICODE format. 
                                       // Not supported in 97!!!
#define OIO_LINKSCHANGED        0x0020 // Added for Outlook.  Force the links changed flag to be TRUE
#define OIO_SAVE_AS_HTML        0x0040 // Save the properties in HTML format
#define OIO_SAVE_ONLY_VBASIG    0x0080 // When the doc is encrypted, only save VBA signature unencrypted
                                       // this flag used internally, client app should not use it.
#define OIO_SAVE_TITLE_XML      0x0100 // Save the title prop in the xml collection (if OIO_SAVE_AS_HTML set)
#define OIO_SKIP_VBASIG         0x0200 // Skip the SAVE_ONLY_VBASIG logic, client will do a separate step
#define OIO_SAVE_LINKBASE_XML   0x0400 // Save the hyperlink base prop in the xml collection (if OIO_SAVE_AS_HTML set)

    // Populate the objects with data.  lpStg is the root stream.
    // Returns the number of streams loaded.
    // dwFlags: OIO_ANSI specifies that lpStg is an ANSI storage (UNICODE is the default)
    //
    // The function returns the following:
    //
#define MSO_IO_ERROR   0     // The stream(s) were found, but the load failed
#define MSO_IO_NOSTM   1     // The stream(s) were not found
#define MSO_IO_SUCCESS 2     // The stream(s) were found, and the load succeeded
    //
    // NOTE: The caller can load either the summary info stream (lpSIObj != NULL), or
    //       the Document Summary Info stream (lpDSIObj != NULL && lpUDObj != NULL) or
    //       both.
    //
    // NOTE: If the caller asks to load both streams, MSO_IO_NOSTM will not be returned, as
    //       long as one of the streams exists.

MSOAPI_(DWORD ) MsoDwOfficeLoadProperties (LPSTORAGE lpStg,
						 LPSIOBJ lpSIObj,
						 LPDSIOBJ lpDSIObj,
						 LPUDOBJ lpUDObj,
						 DWORD dwFlags);


/*-----------------------------------------------------------------------------
	MsoDwOfficeLoadPropertiesEx

	same as MsoDwOfficeLoadProperties, but with the option for encryption
	MsoDwOfficeLoadProperties calls MsoDwOfficeLoadPropertiesEx
-------------------------------------------------------------------- HAILIU -*/
MSOAPI_(DWORD ) MsoDwOfficeLoadPropertiesEx (LPSTORAGE lpStg,
						 LPSIOBJ lpSIObj,
						 LPDSIOBJ lpDSIObj,
						 LPUDOBJ lpUDObj,
						 IMsoCryptSession *pics,
						 DWORD dwFlags);


MSOAPIX_(DWORD ) MsoDwOfficeLoadIntProperties (LPSTORAGE lpStg,
						 LPSIOBJ lpSIObj,
						 LPDSIOBJ lpDSIObj,
						 LPUDOBJ lpUDObj,

						 DWORD dwFlags);
//
// Do a normal load (like calling MsoDwOfficeLoadProperties),
// but also return the codepage.
//
// Used by the Office Compatible dudes...
//
MSOAPIMX_(DWORD)  MsoDwLoadPropertiesCodePage(LPSTORAGE lpStg,
						 LPSIOBJ lpSIObj,
						 LPDSIOBJ lpDSIObj,
						 LPUDOBJ lpUDObj,
						 DWORD dwFlags,
						 ULONG *pdwCodePage);

    // Write the data in the given objects.
    // pvContent is either the root stream or IMsoHtmlExport.
    // Returns the number of streams saved.
    // dwFlags: OIO_ANSI specifies that root stream is an ANSI storage (UNICODE is the default)
    //
    //          OIO_SAVEIFCHANGEONLY specificies that only streams that are
    //           "dirty" will be saved.  Do NOT specify this if you are 
    //           saving to a tmp file.  Also do not attempt to "outsmart"
    //           the save by passing NULL objects, use this flag instead.
    //
    //          OIO_SAVESIMPLEDOCFILE specifies that the storage is a simple DOC file.
	//
	//			OIO_SAVE_AS_HTML specifies that pvContent is an IMsoHtmlExport and
	//			 we will be exporting as html.  If not set, then pvContent is an
	//			 LPSTORAGE and we will be saving as binary.
    //
MSOAPI_(DWORD ) MsoDwOfficeSaveProperties (LPVOID pvContent,
						 LPSIOBJ lpSIObj,
						 LPDSIOBJ lpDSIObj,
						 LPUDOBJ lpUDObj,
						 DWORD dwFlags);


/*-----------------------------------------------------------------------------
	MsoDwOfficeSavePropertiesEx

	Same as MsoDwOfficeSaveProperties but with option for encryption
	MsoDwOfficeSaveProperties now calls MsoDwOfficeSavePropertiesEx with NULL for pics
-------------------------------------------------------------------- HAILIU -*/
MSOAPI_( DWORD ) MsoDwOfficeSavePropertiesEx
  (LPVOID pvContent,							 // Pointer to root storage or pihe
   LPSIOBJ lpSIObj,                     // Pointer to Summary Obj
   LPDSIOBJ lpDSIObj,                   // Pointer to Document Summary obj
   LPUDOBJ lpUDObj,                     // Pointer to User-defined Obj
   IMsoCryptSession *pics,              // non=NULL, if the property should be encrypted
   DWORD dwFlags);                      // Flags
   
 
/*-----------------------------------------------------------------------------
	MsoDwOfficeSaveVBASig
 
 	A lot like MsoDwOfficeSaveProperties, but only saves the VBASig property
 	in the stream.  Gives the client a chance to close down the flattening stream
 	during encryption before creating the property stream.
------------------------------------------------------------------- MarkWal -*/
MSOAPI_(DWORD) MsoDwOfficeSaveVBASig
	(LPVOID pvContent,
	 LPDSIOBJ lpdsiobj,
	 DWORD dwFlags);

#ifdef VSMSODEBUG

/*-----------------------------------------------------------------------------
	MsoFWriteOlePropBe

	Account for memory allocated for the OLE Properties objects.

	Will only check non-NULL paramters (lpSIObj, lpDSIObj, lpUDObj)

------------------------------------------------------------------ MARTINTH -*/
MSOAPI_(BOOL) MsoFWriteOlePropBe(LPSIOBJ lpSIObj, LPDSIOBJ lpDSIObj, LPUDOBJ lpUDObj);

#endif // VSMSODEBUG

////////////////////////////////////////////////////
// VB support routines - see spec for details.
////////////////////////////////////////////////////

//
//  Used by Office Compatible.  Don't unexport.
// 

// Converts a FileTime to a VariantDate
//
MSOAPIX_(BOOL) FFtToVariantDate(LPFILETIME lpft, LPVARIANTARG lpvarg);
MSOAPIX_(BOOL) FVariantDateToSt(LPVARIANTARG lpvarg, LPSYSTEMTIME lpst);

// Converts a VariantDate to a FileTime.
//
MSOAPIX_(BOOL) FVariantDateToFt(LPVARIANTARG lpvarg, LPFILETIME lpft);

    // Creates a Builtin property collection and returns it.
    // pParent is the parent IDispatch object.
    // The new IDispatch object is returned via pvarg.
MSOAPI_(BOOL ) MsoFGetBuiltinPropCollection (LCID lcid,
						   LPSIOBJ lpSIObj,
						   LPDSIOBJ lpDSIObj,
						   IDispatch *pParent,
						   VARIANT *pvarg,
						   HMSOINST hinst);

    // Creates a Custom property collection and returns it.
    // pParent is the parent IDispatch object.
    // The new IDispatch object is returned via pvarg.
MSOAPI_(BOOL ) MsoFGetCustomPropCollection (LCID lcid,
						  LPUDOBJ lpUDObj,
						  IDispatch *pParent,
						  VARIANT *pvarg,
						  HMSOINST hinst);

/*-----------------------------------------------------------------------------
	MsoFRemovePrivateProperties

	Clears properties with private information
-------------------------------------------------------------------- JORGEF -*/
MSOAPI_(BOOL) MsoFRemovePrivateProperties(LPSIOBJ lpSIObj, LPDSIOBJ lpDSIObj, LPUDOBJ lpUDObj);

#ifdef __cplusplus
}; // extern "C"
#endif

#pragma pack( pop, msoprops )
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Inc\office10\msosdm.h ===
#pragma once

/*------------------------------------------------------------------------*
 * msosdm.h (previously known as sdm.h): SDM Main PUBLIC include file.    *
 *                                                                        *
 * Please do not modify or check in this file without contacting MsoSdmQs.*
 *------------------------------------------------------------------------*/


//----------------------------------------------------------------------//
// #IFDEF       Use when...
// ------------ ----------------------------------------
// WIN32        Always true	for WIN
// DEBUG
// TSMTE        FE version
//
//----------------------------------------------------------------------//

#ifndef	SDM_INCLUDED	// Entire file.
#define	SDM_INCLUDED

#include <msostd.h>
#include <msouser.h>
#include <msoswct.h>
#define SDMPUBLIC MSOAPICALLTYPE

//============================
// who's not defined?
#ifdef SDM_TYPES_DEFINED
#error
#endif
#ifdef DBCS
// REVIEW KirkG: DBCS is not defined for Mso.  It is defined for Word
//  (in word.h), but I don't think anything in Word's build uses it.
// What does this mean for its use in the TMW struct below?  Does the 
//   client indeed allocate those things?
//#error
#endif
// who's already defined?
#ifndef SDM_WCT_DEFINED
#error
#endif
//============================

///////////////////////////////////////////////////////////////////////////////
// Standard types and values.						     

#ifndef CSTD_H
typedef	char * LSZ;
typedef char * SZ;
#endif
typedef WCHAR * LWZ;
typedef WCHAR *	WZ;

typedef const char * CONST_SZ;
typedef const WCHAR * CONST_WZ;

#ifndef	SDM_TYPES_DEFINED
#define	SDM_TYPES_DEFINED
typedef	unsigned char	U8_SDM;
typedef	char		S8_SDM;
typedef	unsigned short	U16_SDM;
typedef	short		S16_SDM;
typedef	unsigned short	BIT_SDM;	// short ==> better packing in Win32


// AKadatch: all these types hold pointers
// typedef	long		S32_SDM;
// typedef	unsigned long	U32_SDM;
// typedef int INT_SDM;
// typedef unsigned int UINT_SDM;
// typedef	unsigned long	BARG_SDM;


// AKadatch: some apps use obsolete and/or modified WinNT.h
// *_PTR types should be declared manually
#include <basetsd.h>

typedef	LONG_PTR	S32_SDM;
typedef	ULONG_PTR	U32_SDM;
typedef INT_PTR		INT_SDM;
typedef UINT_PTR	UINT_SDM;
typedef	ULONG_PTR	BARG_SDM;

//FEH: typedef short INT_SDM;
//FEH: typedef unsigned short UINT_SDM;
typedef UINT_SDM UCAB_SDM;	//cab arg
typedef UINT_SDM UCBK_SDM;	//callback parameter/return

// FUTURE Should we change Win to also define ILBE_SDM as INT_SDM?
//
// The Mac needsILBE_SDM to signed, since ilbeFirst can be < 0 in
// droplists, since there can be blank list items above the first
// real list item.  However changing ILBE_SDM to INT_SDM on the
// Windows side caused problems in WinWord16, since ilbeNil was
// being sign-extended in longs in some structures.  I tried to 
// change ilbeNil and uNinchList to 0x7fff but ran into many places 
// which hard-coded returning -1 instead of ilbeNil or that counted 
// on ilbeNil+1==0
typedef UINT_SDM ILBE_SDM;  // first entry in listbox

typedef int BOOL_SDM;	//BOOL

typedef int XY_SDM;		//screen coordinate
#endif	//SDM_TYPES_DEFINED
///////////////////////////////////////////////////////////////////////////////
//	Function storage class.

#define SDM_MAC_EXPORT

typedef union _pnt
	{
	struct
		{
		XY_SDM	x;
		XY_SDM	y;
		};
	XY_SDM	rgxy[2];
	} PNT;

typedef struct _rec
	{
	XY_SDM	x;
	XY_SDM	y;
	XY_SDM	dx;
	XY_SDM	dy;
	} REC;				// Rectangle. 

typedef POINTS	PT_SDM;


///////////////////////////////////////////////////////////////////////////////
// Convert RECT's to REC's, and vice-versa.

// Environment independant conversion.
#define	RectOfRec(P1, P2) \
	{ \
	(P1).left = (P2).x; \
	(P1).top = (P2).y; \
	(P1).right = (P2).x + (P2).dx; \
	(P1).bottom = (P2).y + (P2).dy; \
	}

// Environment dependant conversion.
#define RecOfRect(P1, P2) \
	{ \
	(P1).x = ((P2).left); \
	(P1).dx = ((P2).right - (P2).left); \
	(P1).dy = ((P2).bottom - (P2).top); \
	(P1).y = ((P2).top); \
	}

#define FPtInRec(P1, P2) \
	( \
	(P1).x >= (P2).x && \
	(P1).x < (P2).x + (P2).dx && \
	(P1).y >= (P2).y && \
	(P1).y < (P2).y + (P2).dy \
	)


///////////////////////////////////////////////////////////////////////////////
// Text Selection.							     
typedef U32_SDM	TXS;

#define	ichLimLast	0x7fff		// Go to end of edit item. 
#define TxsOfFirstLim(f, l)	((TXS)MAKELONG((f), (l)))
#define TxsAll()		TxsOfFirstLim(0, ichLimLast)
#define IchFirstOfTxs(txs)	LOWORD(txs)
#define IchLimOfTxs(txs)	HIWORD(txs)



///////////////////////////////////////////////////////////////////////////////
// Base dialog types.							     

typedef VOID **	HDLG;		// A near handle. 

#define	HdlgOfWNewWOld(wNew, wOld)	((HDLG)(wOld))
#define	HdlgOfWNewWOldFar(wNew, wOld)	((HDLG)MAKELONG((wNew), (wOld)))

typedef char * STR;            // String (SZ or STZ).
#define strNull		(char *)NULL	// (Use "char *" instead of SZ since 
					// not all apps. use cstd.h.)

typedef WCHAR * WSTR;
#define wstrNull (WCHAR *)NULL

#define hdlgNull	((HDLG) NULL)
#define hdlgError	((HDLG) -1)
#define hdlgCabError	((HDLG) -1)
#define hdltNull	((struct _dlt * *) NULL)



///////////////////////////////////////////////////////////////////////////////
// TMC.									     

typedef UINT_SDM	TMC;			// Item codes. 

// Standard item codes (tmc). 
#define	tmcNull		((TMC)0)
#define tmcError	((TMC)-1)
#define	tmcOK		((TMC)1)
#define	tmcOk		tmcOK
#define	tmcCancel	((TMC)2)
#define	tmcSysMin	((TMC)0x10)
#define	tmcSysMax	((TMC)0x400)
#define	ftmcGrouped	0x8000		// OR'd to specify whole group as 
					// opposed to first item. 
#define	tmcUserMin	tmcSysMax
#define	tmcUserMax	((TMC)ftmcGrouped)



///////////////////////////////////////////////////////////////////////////////
// Tmc macros. 

#define	TmcValue(tmc)		((tmc) & ~ftmcGrouped)
#define FIsGroupTmc(tmc)	((tmc & ftmcGrouped) != fFalse)


///////////////////////////////////////////////////////////////////////////////
// TMT
typedef	UINT_SDM	TMT;		/* TM types */


///////////////////////////////////////////////////////////////////////////////
// DLM.									     

typedef UINT_SDM	DLM;			// Dialog proc / item proc messages. 

// Global Messages. 
#define	dlmInit 	((DLM)0x0001)	// Do custom initialization. 
#define	dlmPlayBackInit ((DLM)0x0002)	// Do custom noninteractive init. 
#define	dlmTerm 	((DLM)0x0003)	// Termination for one of many 
					// reasons. 
#define	dlmExit		((DLM)0x0004)	// Dialog is about to be blown away. 

// Item messages. 
#define	dlmChange	((DLM)0x0005)	// Edit control may have changed. 
#define	dlmClick	((DLM)0x0006)	// Item was clicked. 
#define	dlmDblClk	((DLM)0x0007)	// Double click in listbox/radio. 
#define dlmClickDisabled ((DLM)0x0008)	// Noninteractive Dialog-sessions
					// only, the button passed to
					// FSetNoninteractive() has been 
					// disabled by a call to 
					// EnableNoninteractiveTmc() at dlmInit
					// time. 

// Rare Item Messages. 
#define dlmTab		((DLM)0x0009)	// Tab key intercept
#define	dlmKey		((DLM)0x000a)	// Any untrapped key. 
#define	dlmSetItmFocus	((DLM)0x000b)	// Item gets focus. 
#define	dlmKillItmFocus	((DLM)0x000c)	// Item loses focus. 

// Rare Dialog Proc Messages. 
#define dlmSetDlgFocus         ((DLM)0x000d)  // Dialog gets focus. 
#define dlmKillDlgFocus        ((DLM)0x000e)  // Dialog loses focus. 
#define dlmAdjustPos           ((DLM)0x000f)  // Adjust item's rec?
#define dlmTabOut              ((DLM)0x0010)  // Tab out of dialog? 
#define dlmIdle                ((DLM)0x0011)  // Idle for modal dialogs. 
#define dlmDlgClick            ((DLM)0x0012)  // Click in dialog's window. 
#define dlmDlgDblClick         ((DLM)0x0013)  // Double click in dialog's window. 
#define dlmShowCaret           ((DLM)0x0014)  // Show a caret.
#define dlmHideCaret           ((DLM)0x0015)  // Hide a caret.
#define dlmButtonDown          ((DLM)0x0016)  // Sent at mousedown on a button
#define dlmCreate              ((DLM)0x0017)  // Items are about to be created
#define dlmDlgMove             ((DLM)0x0018)  // Dialog window was just moved by user (JOHNTE)
#define dlmQueryNewPalette     ((DLM)0x0019)  // WM_QUERYNEWPALETTE (Win only)
#define dlmPaletteChanged      ((DLM)0x001a)  // WM_PALETTECHANGED (Win only)
#define dlmSubDialog           ((DLM)0x001b)  // New subdialog is about to appear
#define dlmFilterKey           ((DLM)0x001c)  // Dialog key message detected
#define dlmContextHelp         ((DLM)0x001d)  // Context Help (QuickTip)
#define dlmCtrlTab             ((DLM)0x001e)  // Ctrl+Tab pressed
#define dlmUpdateDefault       ((DLM)0x001f)  // give the app a chance
#define dlmDrag                ((DLM)0x0020)  // for Owner Drag listboxes
#define dlmRefEditShrink       ((DLM)0x0021)  //for notifying app of a dialog shrinking for ref edits
#define dlmChangeCheckBox      ((DLM)0x0022)  // for querying App if the Check box should be changed
#define dlmGetRefEditBmp       ((DLM)0x0023)
#define dlmGetRefEditBmpShrunk ((DLM)0x0024)
#define dlmSemiSubDialog       ((DLM)0x0025)  // half way through a sub dialog
#define dlmActivateApp         ((DLM)0x0026)  // Recieved WM_ACTIVATEAPP TRUE. 
#define dlmAskEnable           ((DLM)0x0027)  // Give a app to disallow enabling of TMC
#define dlmClickNotify         ((DLM)0x0028)  // User click on a disabled item
#define dlmRedisplayLbx        ((DLM)0x0029)  // Redisplay of list requested
#define dlmContextHelpOverride ((DLM)0x0030)  // Redisplay of list requested
#define dlmAutoLayout          ((DLM)0x0031)  // Called to invoke AutoLayout code
#define dlmComboBoxDrop            ((DLM)0x0032)  // Called when lbox is dropped down
#define dlmUserMin             ((DLM)0x0040)  // For App use. 


///////////////////////////////////////////////////////////////////////////////
// TMM Messages.							     

typedef UINT_SDM	TMM;			// Control proc messages.

// ListboxProc messages. 
#define	tmmCount	((TMM)0x0002)	// Return # of items. 
#define	tmmText 	((TMM)0x0003)	// Return text of n'th item. (always sent sequentially). 
#define	tmmEditText	((TMM)0x0004)	// Like tmmText but send randomly. 
#define tmmTooltipText ((TMM)0x0005) // Return tooltip for nth item (sent randomly)
// DON'T USE 0X0009.  (See tmm's for both general pictures and listboxes below.)
#define	cszUnknown	((UINT_SDM) -1)	// Return to tmmCount if unknown. 

// Gallery control context menu messages (a Gallery is a type of Listbox)
#define	tmmCountContext	((TMM)0x0006)	// Context menu entries this ilbe.
#define	tmmContextSTCR		((TMM)0x0007)	// The n'th Simple Toolbar Control Record.
#define	tmmContextClicked	((TMM)0x0008)	// Which STCR was clicked. 

// ParseProc messages. 
#define	tmmFormat	((TMM)0x0001)	// Format data. 
#define	tmmParse	((TMM)0x0002)	// Parse data. 

// Render Procs 
#define	tmmRender	((TMM)0x0001)	// Repaint entire item. 
#define tmmNewState	((TMM)0x0002)	// State has changed. 
#define tmmRepaint	((TMM)0x0003)	// Repaint everything but text.
#define tmmNewText	((TMM)0x0004)	// Repaint text alone

// GeneralPictures and ListboxProc 
#define	tmmCreate        ((TMM)0x0001)	// Create windows and such. 
#define	tmmAboutToResize ((TMM)0x0009)	// Listbox or general picture is about to resize.

// General Pictures 
// don't use the value 2 since tmmNewState is also used
// by general pictures
#define tmmPaint         ((TMM)0x0003)   // Paint yourself. 
#define tmmFocus         ((TMM)0x0004)   // Show yourself with/without focus.
#define tmmInput         ((TMM)0x0005)   // User input received.
#define tmmMeasure       ((TMM)0x0006)   // Provide optimal default control size based on content (DAL)
#define tmmResize        ((TMM)0x0007)   // Alert the control that its size has changed.
#define tmmMetricsChange ((TMM)0x0008)   // Alert the control that system metrics
                                         // have changed (as SDM is notified through
                                         // a WM_WININICHANGE message)
// DON'T USE 0X0009.  (See tmm's for both general pictures and listboxes above.)

#define tmmTabStop		((TMM)0x000a)	// Query if item is tabstop 
#define tmmDestroy		((TMM)0x000b)	// Inform item is being destroyed.
#define tmmMatchAccel	((TMM)0x000c)	// Attempt to match accelerator key
#define tmmWctControl	((TMM)0x000d)	// Complete a WPCTL structure (WM_GETCONTROLS)
#define tmmWctText		((TMM)0x000e)	// Fill a WTXI structure (WM_GETTEXT)
#define tmmWctListCount	((TMM)0x000f)	// Get list count (WM_GETLISTCOUNT)
#define tmmCtrlTab		((TMM)0x0010)	// Ctrl+Tab pressed
#define tmmAccelerate	((TMM)0x0011)	// picture was just sent focus by an accelerator key
#define tmmFilterKey	((TMM)0x0012)	// allows pictures to filter their keystrokes before SDM mucks with them.
#define tmmGccKeydown	((TMM)0x0013)	// keydowns for gcc color dropdowns
#define tmmGccDefaultChanged	((TMM)0x0014)	//default tmc changed, so gcc doesn't need to reset it
#define tmmGccClick     ((TMM)0x0015)   // a buttondown occured while a picture has the focus
#define tmmSysInput     ((TMM)0x0016)   // User input (syskeydown) received

#if VSMSODEBUG
#define tmmSaveBe	((TMM)0x003f)	// debug memory accounting
#endif

#define	tmmUserMin	((TMM)0x0040)	// For user extensions. 

#define wFilterEaten	((UINT_SDM)0xFFED)	// return value for tmmFilterKey when
											// the event was handled by the picture proc

typedef	struct _drm_sdm
	{
	WCHAR *	wzTmpl;
	WCHAR *	wzName;
	WCHAR *	wzType;
	} DRM_SDM;



///////////////////////////////////////////////////////////////////////////////
// FTMS - Item States.							     

typedef UINT_SDM	FTMS;

#define ftmsNull	((FTMS)0x0000)	// None of the following. 

// The folowing four alignment bits are specific to static text
// Note: the contiguity and ordering of the following 3 is assumed. 

#define ftmsLeft		((FTMS)0x0000)	// left aligned	(default)
#define ftmsCenter		((FTMS)0x0001)	// centered
#define ftmsRight		((FTMS)0x0002)	// right aligned
#define	ftmsAlt			((FTMS)(ftmsLeft|ftmsCenter|ftmsRight))

#define ftmsDefault		((FTMS)0x0002)	// Item is default pushbutton. 
#define ftmsPushed		((FTMS)0x0004)	// Button is "depressed".
#define ftmsMouseDown   ftmsPushed	// newer name for ftmsPushed
#define ftmsInvert		ftmsPushed	// Old name for ftmsPushed.
#define ftmsOn			((FTMS)0x0008)	// Item is "on". 
#define ftmsNinch		((FTMS)0x0010)	// Tri-state only - third state. 

// Note: the contiguity and ordering of the following 4 is assumed. 
#define ftmsEnable		((FTMS)0x0020)	// Item is enabled. 
#define ftmsVisible		((FTMS)0x0040)	// Item is invisible. 
#define ftmsMember		((FTMS)0x0080)	// Member of current subdialog. 

#define ftmsNewText		((FTMS)0x0100)	// Text has changed

//The following ftms are for drawing static text

#define ftmsMultiline	((FTMS)0x0200)	// multiline static text
#define ftmsBorder		((FTMS)0x0400)	// has a border
#define ftmsNoPrefix	((FTMS)0x0800)	// don't treat chAccel as a prefix

#define ftmsNoRedraw	((FTMS)0x1000)	// don't redraw until clear

#define ftmsLight		((FTMS)0x2000)	// use light font (sdi.hfontLight)

#define ftmsFocus		((FTMS)0x4000)	// Item has the focus.

#define ftmsTempHidden	((FTMS)0x8000)	// Item is temporarily hidden 
/* FMidEast */
#define ftmsHasReo		ftmsMultiline	// make edit item respect ftmsRTLReo
#define ftmsRTLReo		((FTMS)0x10000)	// draw static strings with RTL reading 
										// order. edit text requires ftmsHasReo
/* FMidEast End */

#define ftmsHyperlink   ((FTMS)0x20000) // Draw this control as a hyperlink
#define ftmsMouseOver	((FTMS)0x80000) // Draws control in the mouse over state

///////////////////////////////////////////////////////////////////////////////
// TMV - Item Values.							     

typedef UINT_SDM	TMV;

#define	tmvNoType	((TMV)0)
#define	tmvWord		((TMV)1)
#define	tmvFixed	((TMV)2)
#define	tmvString	((TMV)3)
#define tmvRgw		((TMV)4)


///////////////////////////////////////////////////////////////////////////////
// dlmChange notifications

typedef	UINT_SDM	FTMN;

#define	ftmnNull		((FTMN)0x0000)
#define	ftmnCombo		((FTMN)0x0001)
#define	ftmnCharValidated	((FTMN)0x0002)
#define	ftmnKillFocus		((FTMN)0x0004)
#define	ftmnCabVal		((FTMN)0x0008)


///////////////////////////////////////////////////////////////////////////////
// CAB info.								     

typedef void * * * PCABH;	// Pointer to a handle value inside of a CAB.
typedef void * * HCAB;	// CAB is an abstract data type. 
typedef void * PCAB;	// Pointer to arbitrary CAB.
typedef UINT_SDM			CABI;	// CAB initializer.
typedef UINT_SDM			IAG;  // Iag 
#define	Cabi(cwTotal, cHandle)		((cwTotal) + (cHandle << 8))
#define hcabNull	((HCAB)NULL)
#define hcabNonNull	((HCAB)1)
#define hcabNotFilled	((HCAB)-1)	// Could be returned by HcabFromDlg().

typedef unsigned SAB_SDM;

// Command argument block header. 
typedef struct _cabh
	{
	UINT_SDM	cwSimple;		// Total size of CAB less CABH. 
	UINT_SDM	cHandle;		// # of handles. 
	} CABH;

// Minimum CAB size : header + sab. 
#define	cwCabMin	((sizeof(CABH) + sizeof(SAB_SDM)) / sizeof(UCAB_SDM))
#define	cbCabMin	(cwCabMin * sizeof(UCAB_SDM))
#define	cbCabOverhead	(cwCabMin * sizeof(UCAB_SDM))

// Iag macro - returns iag corresponding to field fld in application structure
#define iagNil		((UINT_SDM)0x00ff)

// AKadatch: use FIELD_OFFSET
// #define Iag(sz, fld)	\
// 	((BARG_SDM)((BARG_SDM)&(((sz *)0)->fld) / sizeof(UCAB_SDM) - cwCabMin))
#define Iag(sz, fld)	\
	((BARG_SDM)((BARG_SDM)FIELD_OFFSET(sz,fld) / sizeof(UCAB_SDM) - cwCabMin))

// Macro to get void pointer to general CAB arg given offset.
#define	PvParseArg(hv, bArg)					\
	(((hv) == (VOID **)NULL) ? (VOID *)(bArg) :	\
		(VOID *)(*(char * *)(hv) + (bArg)))

//----------originally in sdmparse.h----------
#define SetPpvBToW(ppv, bArg, w) *((UCAB_SDM *) PvParseArg(ppv, bArg)) = w
#define WFromPpvB(ppv, bArg) *((UCAB_SDM *) PvParseArg(ppv, bArg))

/* Dialog Parse Values */

// Publisher has a conflict with the typedef of DPV, so in some cases, they
// need to be able to remove it by #defining REMOVE_TYPEDEF_DPV
#ifndef REMOVE_TYPEDEF_DPV
typedef int DPV;
#endif // REMOVE_TYPEDEF_DPV

#define dpvError	0x00
#define dpvNormal	0x01
#define dpvBlank	0x02
#define dpvAuto		0x04
#define dpvDouble	0x08
#define dpvSpaces	0x10 
//--------------------------------------------

// Macro to get void pointer to general CAB arg given iag.
#define PvFromCabIag(hcab, iag)					\
	((VOID *)(*((UCAB_SDM * *)(hcab)) + cwCabMin + (iag)))
		
// Cab string/data pointers. 
typedef	WCHAR *	WTZ_CAB;
typedef const WCHAR * CONST_WTZ_CAB;

typedef WCHAR * WZ_CAB;
typedef const WCHAR * CONST_WZ_CAB;

typedef char * SZ_CAB;
typedef const char * CONST_SZ_CAB;

typedef WCHAR * RGB_CAB;
typedef const WCHAR * CONST_RGB_CAB;

typedef WCHAR * WT_CAB;
typedef WCHAR * LWTZ_CAB;
typedef WCHAR * LRGB_CAB;


///////////////////////////////////////////////////////////////////////////////
// structure passed with dlmInit message

typedef struct _dmi_sdm
	{
	HDC	hpdc;
	HCAB	hcab;
	} DMI_SDM;



///////////////////////////////////////////////////////////////////////////////
// Other special values.

// Special ninch (No Input, No CHange) value. 
#define	wNinch		(-32767)	// Ints. 
#define	uNinch		((UINT_SDM)-1)	// Unsigned. 
#define	uNinchRadio	uNinch		// RadioGroups. 
#define	uNinchCheck	uNinch		// CheckBoxes 
#define	wNinchCheck	uNinchCheck	// Old name. 
#define	uNinchList 	((ILBE_SDM)-1) // Listboxes. 

#define	iszNinchList uNinchList		// Other name. 

// Special parse error values. 
#define	wError		(-32766)	// Ints. 
//original source: #define	uError		(0xfffe)	// Unsigneds. 
//current source:  #define	uError		((short)0xfffe)	// Unsigneds. 
#define	uError		((UINT_SDM)-2)	// Unsigneds. 

// Default no help. 
#define	hidDlgNull	0		// For no help.


// For Memory allocation callbacks
typedef U32_SDM 	SB_SDM;


// Scroll Bar notification messages (wNew in dlmClick)
typedef unsigned SBN_SDM;
#define sbnLineUp			SB_LINEUP
#define sbnLineDown			SB_LINEDOWN
#define sbnPageUp			SB_PAGEUP
#define sbnPageDown			SB_PAGEDOWN
#define sbnThumbPosition	SB_THUMBPOSITION
#define sbnThumbTrack		SB_THUMBTRACK
#define sbnTop				SB_TOP
#define sbnBottom			SB_BOTTOM
#define sbnEndScroll		SB_ENDSCROLL


//
// Max size of SDM strings, and the buffer size w/ zero term.
//
#define cchSDMWzMax    MSO_MAX_PATH
#define cchSDMWzBufMax (MSO_MAX_PATH + 1)
//
// This is our old string size, so that we can keep things the same for
// legacy dialogs, and so that we can use short strings if we'll never
// need anything larger than 255, like on tab controls.
//
#define cchSDMWzMaxShort 255
#define cchSDMWzBufMaxShort 256



///////////////////////////////////////////////////////////////////////////////
// Dialog Initialization.						     

typedef	U32_SDM	FDLG;

#define fdlgNull				((FDLG)0x00000000)

#define fdlgModal				((FDLG)0x00000001)	// Create Modal.
#define fdlgInvisible			((FDLG)0x00000002)	// Start invisible.
#define	fdlgEnableTabOut		((FDLG)0x00000004)	// Send dlmTabOut.

#define fdlgPopup				((FDLG)0x00000008)	// Popup dialog - Win only
#define fdlgScreenCoords		fdlgPopup			// Mac: same as above.

#define fdlgClipChildren		((FDLG)0x00000020)	// Clip controls - Win only
#define fdlgFedt				((FDLG)0x00000040)	// EditItem is FEDT - Win only
#define fdlgAdjustPos			((FDLG)0x00000080)	// Adjust item rec's.
#define fdlgOwnDC				((FDLG)0x00000100)	// Dialog owns a DC.
#define fdlgNoHelpIcon		   	((FDLG)0x00000200)	// No Win95 Help Icon - Win only
#define fdlgNoMvDefBut			((FDLG)0x00000400)	// Don't move defaultness

#define fdlgRepainting			((FDLG)0x00000800)	// currently processing WM_PAINT - Win only

#define fdlgEditConvert			((FDLG)0x00001000)	// ANSI -=> OEM -=> ANSI :-P  - !MAC only

#define fdlgSysModal			((FDLG)0x00002000)	// Sys modal dialog

#define fdlgEditMenu			((FDLG)0x00004000)	// TEs respond to edit menu - MAC only
#ifndef fdlgNoSabResize
#define fdlgNoSabResize			fdlgEditMenu		// let app resize on sab switch - !MAC only
#endif

#define fdlgDelayListbox		((FDLG)0x00008000)	// Delay listbox fill
#define fdlgHideAccel			((FDLG)0x00010000)	// No accel underlines
#define fdlgOnDemandSubdlg		((FDLG)0x00020000)	// Init only member controls
#define fdlgNoUpdate			((FDLG)0x00040000)	// Don't UpdateWindow
#define fdlgShrunk				((FDLG)0x00080000)	// RefEdits
#define fdlgRefEditEnabled	fdlgShrunk		// RefEdits - initialization, dialog is refedit enabled

#define fdlgUseTrueTypeFonts	((FDLG)0x00100000)	// MAC only, use truetype fonts for drawing
#define fdlgImeOff				fdlgUseTrueTypeFonts // FE - WinOnly, turn on DES IME control.

// This was added to help with SW Pane's perf wrt hidden controls. Since 
// SDM can't dynamically create controls, the maximum was allocated in 
// the resource file, but we don't need to show all of them most of the time.
// Note: same as the old fdlgMacDisabled, which is not referenced by MSO at all.
// (Raid O10 223434)
// Note: This flag is mutually exclusive of fdlgOnDemandSubdlg
// Note; O10 257833 Using this to lazy create tmw's can cause FEnumTmw to return fFalse for
// some functions. Check enormous for details.
#define fdlgCreateOnDemand      ((FDLG)0x00200000)	// Create and init only controls that are needed

// WARNING:  The following bits are private to SDM -- do not
// set these bits in dli.fdlg!  Additionally, support for these
// bits are not guaranteed.
// REVIEW fdlgSendUpdDflt isn't private.  We are out of bits, and need more!
#define fdlgDisabled		((FDLG)0x80000000)
#define fdlgHasButtons		((FDLG)0x40000000)	// Has a pushbutton.
#define fdlgInitializing	((FDLG)0x20000000)	// Is initializing.
#define fdlgAbort			((FDLG)0x10000000)	// Being destroyed.
#define fdlgListOOM			((FDLG)0x08000000)	// sevList hit.
#define fdlgCreating		((FDLG)0x04000000)	// Creating dialog.
#define fdlgNoninteractive	((FDLG)0x02000000)	// Non-Interactive?
#define fdlgDestroyed		((FDLG)0x01000000)	// Non-Interactive?
#define fdlgNoPaint			((FDLG)0x00800000)	// Don't paint dialog
#define fdlgChildDlg		((FDLG)0x00400000)	// MAC only, Dialog is item of parent
#define fdlgSendUpdDflt		fdlgChildDlg		// !MAC only, notify to update default ring
#define fdlgImeOn			fdlgMacDisabled		// FE - Turn On IME when a dialog gets focus.
#define fdlgPrivateMask		((FDLG)0xff800000)	// All private bits.

// REVIEW old FDLGS included so that we link properly
// with older applications

// all dialogs do this now
#define fdlgNoPopupRetDismiss	fdlgNull	// return in dropped does not dismiss popups
#define fdlgNoKey				fdlgNull	// keyboard interface for controls

#define FDlgCurNoKey() (fFalse)


#define FTestFdlg(fdlg, fdlgTest)	(((fdlg) & (fdlgTest)) != fdlgNull)
#define ClearFdlg(fdlg, fdlgClear)	((fdlg) &= ~(fdlgClear))
#define SetFdlg(fdlg, fdlgSet)		((fdlg) |= (fdlgSet))
#define	FlipFdlg(fdlg, fdlgFlip)	((fdlg) ^= (fdlgFlip))

typedef struct _dli			// DiaLog Initializer. 
	{
	HWND		hwnd;
	XY_SDM		dx, dy;
	FDLG		fdlg;
	UINT_SDM	wRef;
	BYTE *	rgb;			// App-supplied rgtmw (in sbDlg).
	DWORD	clrWindow;	// not used yet on the Mac
	SB_SDM		sb; // majic number to pass back to mem alloc callbacks
	}  DLI;
#define pdliNull	((DLI *)0)



///////////////////////////////////////////////////////////////////////////////
// Misc Functions .

extern UINT_SDM wRefDlgCur;		// Cached value. 
extern HCAB	hcabDlgCur;		// Cached value.

#define HcabDlgCur()	HcabQueryCur()
#define WRefDlgCur()	WRefQueryCur()

///////////////////////////////////////////////////////////////////////////////
// RenderProc environment-specific Draw Structure.			     

typedef struct _rds
	{
	HDC	hpdc;
	HWND		hwnd;
	RECT	rect;

	WCHAR * *	pwz;
	BOOL_SDM	fNoKey;	//no keybd interface
	} RDS;

#define SM_SETSECRET		0x800a	// Tell (any) FEDT text is "secret". 
#define SM_GETSECRET		0x800b  // Is the FEDT secret?

// Private message sent from fedt to dialog window.
#define SM_USER			0x8005


///////////////////////////////////////////////////////////////////////////////
// PictureProc message-specific parameter.				     

typedef struct _sdmp
	{
	HWND hwnd;
	REC *	prec;
	FTMS	ftms;
	union
		{
		LPMSG	lpmsg;                 // tmmInput
		unsigned chAccel;              // tmmMatchAccel
		BOOL_SDM fBackTab;             // tmmCtrlTab
		struct
			{
			BOOL_SDM fAction;          // tmmCreate
			BOOL_SDM fHelp;            // tmmCreate
			};
#ifdef SDM_WCT_DEFINED	//msoswct.h included
		LPWCTL lpwctl;                 // tmmWctControl
		struct
			{
			LPWTXI lpwtxi;             // tmmWctText
			int cch;                   // tmmWctText output
			};
		int cwz;                       // tmmWctListCount output
#endif //SDM_WCT_DEFINED
		struct                         
			{
			HDC   hpdc;                // tmmPaint, tmmMeasure
			POINT ptDesiredDimensions; // tmmMeasure, tmmAboutToResize
			};
		};
	} SDMP;

#define	psdmpNull	((SDMP *)NULL)

///////////////////////////////////////////////////////////////////////////////
// Procedure templates (for callbacks).					     

#define	SDM_CALLBACK	PASCAL	// Far callback.

typedef BOOL_SDM (SDM_CALLBACK * PFN_DIALOG)(DLM, TMC, UCBK_SDM, UCBK_SDM, UCBK_SDM);
typedef PFN_DIALOG	PFN_ITEM;

// EB/EL Cab Save CallBack. 

typedef VOID (SDM_CALLBACK * PFN_SAVECAB)(HCAB, UINT_SDM, TMC, BOOL_SDM);
#define pfnSaveCabNull	((PFN_SAVECAB)0)

// Top level Modal Message Filter. 
typedef BOOL_SDM (SDM_CALLBACK * PFN_FILTERMSG)(LPMSG);

#define pfnFilterMsgNull	((PFN_FILTERMSG)0)

typedef int (WINAPI * PFN_ALERT)(HWND, LPCWSTR, LPCWSTR, UINT);
#define pfnAlertNull		((PFN_ALERT)NULL)

// General control proc template. 
typedef UCBK_SDM (SDM_CALLBACK * PFN_CTRL)(TMM, VOID *, UCBK_SDM, UCBK_SDM, TMC, UCBK_SDM);
#define pfnCtrlNull	((PFN_CTRL)0)

typedef UCBK_SDM (SDM_CALLBACK * PFN_PIC)(TMM, SDMP *, UCBK_SDM, UCBK_SDM, TMC, UCBK_SDM);
typedef UCBK_SDM (SDM_CALLBACK * PFN_PARSE)(TMM, WCHAR *, VOID * *, BARG_SDM, TMC, UCBK_SDM);
typedef UCBK_SDM (SDM_CALLBACK * PFN_LISTBOX)(TMM, WCHAR *, ILBE_SDM, UCBK_SDM, TMC, UCBK_SDM);
typedef UCBK_SDM (SDM_CALLBACK * PFN_RENDER)(TMM, RDS *, FTMS, FTMS, TMC, UCBK_SDM);
typedef PFN_PARSE	PFN_FORMAT;

// Autocomplete call back
// Second Argument(WCHAR *) is the string to be autocompleted
// Third Argument(WCHAR *) is the return string by the function
// Return TRUE if autocompleting should occur
// Return FALSE if no changes(i.e. autocompletion) should occur
typedef BOOL_SDM (SDM_CALLBACK * PFN_AUTOCOMPLETE)(void *, TMC, WCHAR *, WCHAR *);

// Resize callback
// first arg = tmc of control being moved
// second arg = REC pointing at move location
typedef void (SDM_CALLBACK * PFN_RESIZE)(TMC, REC *);


// Dialog Creation callback
// Argument is the new dialog hwnd which might be useful for subclassing.
typedef void (SDM_CALLBACK * PFN_DLGCREATED)(HWND);

// Peek/GetMessage callback
// 
typedef BOOL_SDM (SDM_CALLBACK *SDM_PFNPEEKMESSAGE)(MSG *, HWND, UINT, UINT, UINT);
typedef BOOL_SDM (SDM_CALLBACK *SDM_PFNGETMESSAGE)(MSG *, HWND, UINT, UINT);
///////////////////////////////////////////////////////////////////////////////
// Procedure Templates.							     


MSOAPI_(HDLG) HdlgGetCur( void );
MSOAPI_(HDLG) HdlgGetFocus( void );
MSOAPI_(BOOL) MsoFDlgIsWorkpane(HDLG hdlg);
MSOAPI_(void) MsoProtectSDMInWorkpane(void);
MSOAPIX_(void) MsoUnprotectSDMInWorkpane(void);
MSOAPI_(void) MsoNotifySdmOfFocus(TMC tmc, BOOL fFocus);
MSOAPI_(FARPROC) LpfnMsoSetSdmMessageWrap(FARPROC lpfn, int fUnicode, int fPeek);


///////////////////////////////////////////////////////////////////////////////
// FtmeIsSdmMessage() return values.					     

// Need special return values for functions that normally return fTrue/fFalse.
typedef UINT_SDM		FTME;
#define ftmeNull	((FTME)0)
#define ftmeTrue	((FTME)1)
#define ftmeError	((FTME)2)
#define ftmeDone	((FTME)4)
#define ftmeEaten	((FTME)8)	// modal dialog is front window,
					// and received click on other 
					// window.  App should beep.b




///////////////////////////////////////////////////////////////////////////////
// Hard-coded callbacks.						     

// Out Of Memory Support. 
typedef	UINT_SDM		SEV;
#define	sevMinor	1		// Minor (painting) error.
					// don't cast, since used in MASM
#define sevMajor	((SEV)2)	// Major error.
#define sevLmem		((SEV)3)	// Out of LMEM memory.
#define sevHcabFromDlg	((SEV)4)	// HcabFromDlg() failure.
#define sevList		((SEV)6)	// ListBox fill failure.

/* Current SDM mem functions. */
#ifndef PpvSdmAllocCb
MSOMACAPI_(VOID**) 	SDM_CALLBACK PpvSdmAllocCb(SB_SDM, UINT_SDM);
MSOMACAPI_(BOOL_SDM) SDM_CALLBACK FSdmReallocPpv(SB_SDM, VOID **, UINT_SDM);
MSOMACAPI_(VOID)		SDM_CALLBACK FreeSdmPpv(SB_SDM, VOID **);
#if VSMSODEBUG
MSOMACAPI_(BOOL_SDM) SDM_CALLBACK FSaveSdmBe(HMSOINST hinst, LPARAM lparam, VOID** ppv, int bt);
#endif
MSOMACAPI_(UINT_SDM)	SDM_CALLBACK CbSdmSizePpv(SB_SDM, VOID **);
MSOMACAPI_(BOOL_SDM)	SDM_CALLBACK FSdmDoIdle(BOOL_SDM);
MSOMACAPI_(BOOL_SDM)	SDM_CALLBACK FRetrySdmError(UINT_SDM, HDLG, SEV);
#endif

/* Default SDM mem functions. */
MSOMACAPIX_(VOID**) 	SDM_CALLBACK MsoPpvSdmAllocCb(SB_SDM, UINT_SDM);
BOOL_SDM SDM_CALLBACK MsoFSdmReallocPpv(SB_SDM, VOID **, UINT_SDM);
VOID		SDM_CALLBACK MsoFreeSdmPpv(SB_SDM, VOID **);
UINT_SDM	SDM_CALLBACK MsoCbSdmSizePpv(SB_SDM, VOID **);
#if VSMSODEBUG
BOOL_SDM SDM_CALLBACK MsoFSaveSdmBe(HMSOINST hinst, LPARAM lparam, VOID** ppv, int bt);
#endif
BOOL_SDM	SDM_CALLBACK MsoFSdmDoIdle(BOOL_SDM);
BOOL_SDM	SDM_CALLBACK MsoFRetrySdmError(UINT_SDM, HDLG, SEV);

// Bitmap support - handle from id. 

typedef	HBITMAP	HBITMAP_SDM;

HBITMAP_SDM	SDM_CALLBACK	MsoHbmpFromIBmp(UINT_SDM);
#ifndef HbmpFromIBmp
MSOMACAPI_(HBITMAP_SDM)	SDM_CALLBACK HbmpFromIBmp(UINT_SDM);
#endif
#define	hbmpNull	((HBITMAP_SDM)NULL)


///////////////////////////////////////////////////////////////////////////////
// Misc types.								     

#define hNull		NULL                    	// Generic null handle.
#define	ppvNull		NULL                    	// Null lmem handle.

#define hfontNull	((HFONT)NULL)



///////////////////////////////////////////////////////////////////////////////
// SDM Initialization structure.					     

typedef FARPROC	SDM_FARPROC;

#ifndef	lpfncompNull
#define	lpfncompNull	((SDM_FARPROC)NULL)
#endif	//!lpfncompNull


typedef struct _sdi
	{
	char *	szApp;			// Unique application name. 
	HANDLE	hinstCur;		// Current application instance. 
	HANDLE	hinstPrev;		// Previous application instance. 
	HCURSOR	hcursorArrow;		// For dialog class
	HDC	hdcMem;			// Memory DC.
	XY_SDM	dyLeading;		// TextMetrics tmExternalLeading.

	HWND	hwndApp;		// Application's main window.
	XY_SDM	dxSysFontChar;		// Width of system font (average).
	XY_SDM	dySysFontChar;		// Height of system font (maximum).
	XY_SDM	dySysFontAscent;	// Height of system font ascenders.

	PFN_FILTERMSG	pfnFilterMsg;	// Message filter callback.
	PFN_ALERT		pfnAlert;	// client supplied replacement for MessageBox

	SB_SDM	sbEL;	// majic number

	char *	szFedtClass;		// Class name for FEDT. 

	SDM_FARPROC	lpfncomp;
	char *	szScrollClass;		// class for listbox scrollbars

	HFONT	hfont;			// Font for dialogs; use system font if NULL
	HFONT	hfontLight;		// Font for "light" text items; use hfont if NULL
	HFONT	hfontBold;		// Bold font; is hfont for FE

	BOOL_SDM (SDM_CALLBACK *pfnDlmDlgFilter) (DLM, TMC, UCBK_SDM, UCBK_SDM, UCBK_SDM);
	BOOL_SDM (SDM_CALLBACK *pfnDlmItemFilter) (TMM, TMC, UCBK_SDM, UCBK_SDM, UCBK_SDM);
	BOOL_SDM (SDM_CALLBACK *pfnDlmEmDlgFilter) (TMM, TMC, UCBK_SDM, UCBK_SDM, UCBK_SDM);

	HBITMAP_SDM (SDM_CALLBACK *pfnHbmpFromIBmp) (UINT_SDM);
	BOOL_SDM	(SDM_CALLBACK *pfnFSdmDoIdle)(BOOL_SDM);
	BOOL_SDM	(SDM_CALLBACK *pfnFRetrySdmError)(UINT_SDM, HDLG, SEV);
	UINT_SDM	cbWndExtraClient;
	BOOL_SDM	fChisled;	//that gratuitous "chisled" look
	BOOL_SDM	fPixelScale;	// no scaling (JOHNTE)
	BOOL_SDM	fExtendedTmm;	// extended listboxes get tmmCount?
	int		iDBCSCtry;

	WNDPROC pfnLSdmWP; // class window proc
	UINT_SDM	lid;				// Language for dialogs
	UINT_SDM	uCodePage;			// Code page for dialogs

	SDM_PFNPEEKMESSAGE pfnPeekMessageW;
	SDM_PFNPEEKMESSAGE pfnPeekMessageA;
	SDM_PFNGETMESSAGE  pfnGetMessageW;
	SDM_PFNGETMESSAGE  pfnGetMessageA;
	} SDI;

#define psdiNull	((SDI *)0)



///////////////////////////////////////////////////////////////////////////////
// DLG access. defined here for the following macros that are defined        

typedef	struct _dlh
	{
	struct _dlt * * hdlt; // Dialog Template. 
	HCAB	hcab;			// Initial CAB for Dialog.
	HWND	hwndDlg;		// Dialog's (frame) window. 

#define	hwndDlgClient	hwndDlg		// I know its gross, but it saves a lot
					// of mess in the sdm .c files. 

	UINT_SDM wRef;		// User supplied Dialog word. 
	FDLG	fdlg;			// Dialog flags. 
	UINT_SDM	hid;			// Help ID.
	UINT_SDM	hidBase;	  	// Base Help ID.
	TMC tmcContext;	// tmc that was clicked in QuickTip mode
	BOOL_SDM fTmcContextEnabled;	// was that tmc enabled or not?
	PT_SDM ptClick;     // Mouse position of click for QuickTip
	} DLH;				// Public part of DLG structure.



///////////////////////////////////////////////////////////////////////////////
// SDS access. (Only defined here for the following macros that are defined  
// by the SDM project.  This struct is NOT for public use!)                  


typedef struct _sds_sdm			// State of SDM. 
	{
	SB_SDM	sbDlgCur;		// SbDds if not SDM_MULTI_SB. 
	SB_SDM	sbDlgFocus;
	void * * ppdlgCur;	// Current Dialog.
	void * * ppdlgFocus; // Dialog with input focus.
	} SDS_SDM;
#define SbsdmDlgCur()	sds.sbDlgCur

///////////////////////////////////////////////////////////////////////////////
// Other common functions 

// Return the value TMC (first TMC in group usually) or do nothing if not
//	grouped.
#define	TmcValue(tmcG)	((tmcG) & ~ftmcGrouped)
#define FIsGroupTmc(tmc)	((tmc & ftmcGrouped) != fFalse)



///////////////////////////////////////////////////////////////////////////////
// General objects support.

typedef VOID **	HOBJ_SDM;			// A near handle.

#define hobjNull	((HOBJ_SDM) NULL)

typedef struct _gobj
	{
	HOBJ_SDM	hobjBase;	// Handle to base object.
	BARG_SDM	bArg;		// Offset from that object.
	} GOBJ;			// Reference to any object.

#define	GobjToGobj(g1, g2)	(g2 = g1)

#define FIsNullGobj(g)		((g).hobjBase == hobjNull && (g).bArg == 0)
#define	FIsNullHobjbArg(h, b)	((h) == hobjNull && (b) == 0)
#define PvFromGobj(h, b)	\
	((h) == hobjNull ? (VOID *)(b) : *(VOID * *)(h) + (b))

#define	FIsEmptyGobj(g)		FIsEmptyHobjBArg((g).hobjBase, (g).bArg)

#define FIsEmptyHobjBArg(h, b)	((h) == hobjNull && (b) == 0)

///////////////////////////////////////////////////////////////////////////////
// Miscellaneous LBOX stuff (for apps that don't include msolbox.h but use the  //
// toolbox.								     //
///////////////////////////////////////////////////////////////////////////////

typedef	struct	_LBX * *	HLBX;

typedef	RECT	LBR;

typedef	UINT_SDM	LBC;

#define	LBOX_CALLBACK		SDM_CALLBACK
#define	LBOX_CALLBACK_NAT	SDM_CALLBACK


typedef struct _lbm
	{
	HLBX hlbx;
	ILBE_SDM cEntryVisible;	// Number of entries visible in list
	XY_SDM dySmall;			// Height of small list
	} LBM;

#define	cEntryVariable	((ILBE_SDM)0x8000)

#include "msosproc.h"


///////////////////////////////////////////////////////////////////////////////
// rgtmw allocataion stuff
///////////////////////////////////////////////////////////////////////////////

// DOUBLE SUPER WARNING - this is a private SDM structure, here only
// because the client has to allocate these things. Use these fields,
// and it's guaranteed you will get broken.
//
// Sizeof runtime space.
// WARNING WARNING WARNING WARNING WARNING WARNING WARNING WARNING
// This structure is also defined in sdmnat.asm.  If you change it here,
// then change it there!!
// WARNING WARNING WARNING WARNING WARNING WARNING WARNING WARNING
typedef U32_SDM	FTMW_SDM;

typedef struct _tmw
	{
	//WARNING: for 32 bit alignment, the items in this structure must
	// be ordered with all 32-bit data before any 16-bit data
	// (so the hokey CbRuntimeCtm will work out right)

	union
		{
		HWND		     hwnd;	// Window handle for edit.

		HLBX	hlbx;	//list
		WCHAR * * pwzTitle;	// Control text.
		UCAB_SDM ibmp;		//non-CAB bitmap id
		} ctl;

	union
		{
		GOBJ	gobjTitle;		// Item title.
		};
	GOBJ	gobjData;		// CAB (or other) data.

	REC	rec;			// Scaled rectangle.
#ifdef DBCS
	BYTE bCharSet;
#endif
	DWORD himcOld;		//Original himc assosiated to edit contorol.

	U32_SDM	lUser;			// User dword

	FTMS	ftms;			// DialogItem state - see list.
	FTMS	ftmsOld;		// Previous state (for buttons).
	FTMW_SDM	ftmw;			// DialogItem flags.

	TMC	tmc;			// iTeM Code.
	TMT	tmt;			// Item type.
	UINT_SDM	cwVal;			// Data size (-1=> var length).
	TMC	tmcGroup;		// tmcNull or TMC of group (for Combo/
					// ListBox/RadioButton).
	int	tcidIcon;	// tcid of icon used inside a button
	int iWidth;		// width of the galley control.

	WCHAR *wtzTooltip; // wtz of the tooltip for this item or NULL
	int    fmtTip;     // format of the tip

	int cdxText;	// Used for caching text dimensions for DAL.
	int cdyText;	// these are only valid if != TEXT_MEASURE_NOT_CACHED
	DWORD grfSDMTextMeasure;

// SDM_PRIVATE

///////////////////////////////////////////////////////////////////////////////
// -- Private part of TMW_SDM, only used by sdmtmw

	// The following 4/5 fields are indices back into the template.
	UINT_SDM itmBase;		// Index of base tm for item.
/* FMidEast */
	U16_SDM itmExt2;		// Extension #2 or itmNil.
	U16_SDM itmExt3;		// Extension #3 or itmNil.
/* FMidEast End */
	U16_SDM itmExt4;
	UINT_SDM itmTmxdFirst;		// First dummy item or itmNil.
	UINT_SDM itmTmxiFirst;		// First item proc or itmNil or itmUnknown.

	WCHAR	ch;			// Accelerator.
	WCHAR	ch2;			// Kana Accelerator.
	BYTE	iagData;		// CAB index of value.
	BYTE	fNonseqTmc:1;		// => Special or Imported TMC.
	BYTE	fHandleData:1;		// If iagData != iagNil, => if data is
					// handle.
	BYTE	fAction:1;		// => call dialog proc.
	BYTE	fHelp:1;		// => wants context help
	BYTE	fRichEdit :1; //Indicates the genralpicture is for Word's RTE.
	BYTE	fSpecialTab :1;		// => wants the special autocomplete tab behaviour
	BYTE	fUnused :2;
//SDM_PRIVATE
	} TMW_SDM_PRIVATE;

#define CbRuntimeCtm(ctm) ((ctm) * sizeof(TMW_SDM_PRIVATE))

#define iFENone		0
#define iFEJapan	81
#define iFEKorea	82
#define iFETaiwan	886
#define iFEPRChina	86

// Flags that can be passed in as a grf to MsoUPicContainerEx
#define msoupicExtended         0x00000001
#define msoupicNoResize         0x00000002

MSOAPI_(UCBK_SDM SDM_CALLBACK) MsoWPicContainer(HMSOINST pinst,
												void **hwndDlg,
												TMM tmm, SDMP *psdmp,
												UCBK_SDM rsvd2, UCBK_SDM rsvd,
												TMC tmc, UCBK_SDM wBtn,
												/* PFNFFillPictureContainer */ void *pfnFPC);

MSOAPI_(UCBK_SDM SDM_CALLBACK) MsoUPicContainerEx(HMSOINST pinst,
												void **hwndDlg,
												TMM tmm, SDMP *psdmp,
												UCBK_SDM rsvd2, UCBK_SDM rsvd,
												TMC tmc, UCBK_SDM wBtn,
												void *pfnFPC, UINT grf);

// Call to set the contexthelp override
MSOAPIX_(void) MsoSetContextOverride(BOOL fContextHelpOverride);

// Call to set the autocomplete function for a dialog.
MSOAPI_(void) MsoSetPfnAutoComplete(/*PFN_AUTOCOMPLETE*/ void *pfnAutoComplete, void *pvData);

// Return the WhatsThis status
MSOAPIX_(int) MsoSDMWhatsThis();

//Following is the private message sent by sdm to edit filter 
//it sends unicode string
#define msoWmSdmPrivSetTextMsg	(WM_USER+289)
#define msoWmSdmPrivGetTextMsg	(WM_USER+290)

#endif	//!SDM_INCLUDED		Entire file.
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Inc\office10\msostd.h ===
#pragma once

/*************************************************************************
	msostd.h

	Owner: rickp
	Copyright (c) 1994 Microsoft Corporation

	Standard common definitions shared by all office stuff
*************************************************************************/

#if !defined(MSOSTD_H)
#define MSOSTD_H

#ifdef PPCMAC
#error
#endif

#ifdef PPCLIB
#error
#endif

#ifdef M68K
#error
#endif

/*************************************************************************
	make sure we have our processor type set up right - note that we
	now have three - count 'em, three - different symbols defined for
	each processor we support (e.g., X86, _X86_, and _M_IX386)
*************************************************************************/

#if defined(X86)
	// intentionally blank...
#elif defined(ALPHA)			
	#undef ALPHA
	#ifndef _ALPHA_
		#define _ALPHA_ 1
	#endif
#elif defined(_IA64_)
	// intentionally blank...
#elif defined(_AXP64_)			
	// intentionally blank...
#elif defined(_ALPHA_)
	// intentionally blank...
#elif defined(_M_IX86)
	#define X86 1
#elif defined(_M_IA64)
	#define _IA64_ 1
#elif defined(_M_ALPHA)
	#ifndef _ALPHA_
		#define _ALPHA_ 1
	#endif
#else
	#error Must define a target architecture
#endif

/*************************************************************************
	Pull in standard Windows and C definitions.
*************************************************************************/

// Warning pragmas for /W4 /WX compatability
#include <msowarn.h>

/*	make sure the compiler generates intrinsic calls of all crt functions,
	or else we'll pull in a ton of crt stuff we probably don't want. */
#ifndef RC_INVOKED
	#include <string.h>
#if !defined(_CRT_SECURE_CPP_OVERLOAD_STANDARD_NAMES) || !_CRT_SECURE_CPP_OVERLOAD_STANDARD_NAMES
		#pragma intrinsic(strcpy,strcat)
#endif
	#pragma intrinsic(strlen, memcpy, memset, memcmp)
#endif

#define OEMRESOURCE

#include <windows.h>
#if !defined(RC_INVOKED)
	#include <ole2.h>
#endif

#include <stdarg.h>

#define MsoStrcpy strcpy
#define MsoStrcat strcat
#define MsoStrlen strlen
#define MsoMemcpy memcpy
#define MsoMemset memset
#define MsoMemcmp memcmp
#define MsoMemmove memmove

/*************************************************************************
	Pre-processor magic to simplify Mac vs. Windows expressions.
*************************************************************************/

#define Mac(mac)
#define MacElse(mac, win) win
#define NotMac(win) win
#define Win(win) win
#define WinMac(win, mac) win


/*************************************************************************
	Calling conventions 

	If you futz with these, check the cloned copies in inc\msosdm.h
	
*************************************************************************/

#if STATIC_LIB_DEF
	#define MSOPUB
	#define MSOPUBDATA
#else
#if !defined(OFFICE_BUILD)
	#define MSOPUB __declspec(dllimport)
	#define MSOPUBDATA __declspec(dllimport)
#else
	#define MSOPUB __declspec(dllexport)
	#define MSOPUBDATA __declspec(dllexport)
#endif
#endif

/* MSOPUBX are APIs that used to be public but no one currently uses,
	so we've unexported them.  If someone decides they want/need one of
	these APIs, we should feel free to re-export them */

#if GELTEST
	#define MSOPUBX MSOPUB
	#define MSOPUBDATAX MSOPUBDATA
#else
	#define MSOPUBX
	#define MSOPUBDATAX
#endif

/* used for interface that rely on using the OS (stdcall) convention */
#define MSOSTDAPICALLTYPE __stdcall

/* used for interfaces that don't depend on using the OS (stdcall) convention */
#define MSOAPICALLTYPE __stdcall

#if defined(__cplusplus)
	#define MSOEXTERN_C extern "C"
	#define MSOEXTERN_C_BEGIN extern "C" {
	#define MSOEXTERN_C_END }
#else
	#define MSOEXTERN_C 
	#define MSOEXTERN_C_BEGIN
	#define MSOEXTERN_C_END
#endif
#define MSOAPI_(t)      MSOEXTERN_C MSOPUB t MSOAPICALLTYPE 
#define MSOSTDAPI_(t)   MSOEXTERN_C MSOPUB t MSOSTDAPICALLTYPE 
#define MSOAPIX_(t)     MSOEXTERN_C MSOPUBX t MSOAPICALLTYPE 
#define MSOSTDAPIX_(t)  MSOEXTERN_C MSOPUBX t MSOSTDAPICALLTYPE 
#define MSOCDECLAPI_(t) MSOEXTERN_C MSOPUB t MSOCDECLCALLTYPE 
#define MSOAPIMX_(t) MSOAPIX_(t)
#define MSOAPIXX_(t) MSOAPI_(t)
#if VSMSODEBUG
#define MSOAPIDBG_(t)   MSOAPI_(t)
#else
#define MSOAPIDBG_(t)   MSOAPIX_(t)
#endif

#define MSOMETHOD(m)      STDMETHOD(m)
#define MSOMETHOD_(t,m)   STDMETHOD_(t,m)
#define MSOMETHODIMP      STDMETHODIMP
#define MSOMETHODIMP_(t)  STDMETHODIMP_(t)

/* Interfaces derived from IUnknown behave in funny ways on the Mac */
#define BEGIN_MSOINTERFACE

#define MSOMACPUB 
#define MSOMACPUBDATA
#define MSOMACAPI_(t) t
#define MSOMACAPIX_(t) t 
	
#if X86 && !VSMSODEBUG
	#define MSOPRIVCALLTYPE __fastcall
#else
	#define MSOPRIVCALLTYPE __cdecl
#endif

#define MSOCDECLCALLTYPE __cdecl

#define MSOCONSTFIXUP(t) const t 

/*************************************************************************
	Extensions to systems headers from the MSAA (Accessibility) SDK
***************************************************************** DAVEPA */

// Extensions to winuser.h from \\ole\access\inc\winuser.h
#define WM_GETOBJECT	   0x003D
#define WMOBJ_ID        0x0000
#define WMOBJ_POINT     0x0001
#define WMOBJID_SELF    0x00000000

// Extensions to winable.h
#ifndef OBJID_NATIVEOM
#define OBJID_NATIVEOM	0xFFFFFFF0
#endif


/*************************************************************************
	Common #define section
*************************************************************************/

/* All Microsoft Office specific windows messages should use WM_MSO.
   Submessages passed through wParam should be defined in offpch.h.     */

// Note: This value needs to be free in all apps that use Mso.  
// It has been validated by all the 97 apps.  It would be safer to use
// RegisterWindowMessage, but this is more efficient and convenient.
#define WM_MSO (WM_USER + 0x0900)

#define MSOCHILDACTIVATE 23

// NA means not applicable. Use NA to help document parameters to functions.
#undef  NA
#define NA 0L

#ifndef MKCSM
// Section added to allow communication between Office 9 (pluggable UI) apps
// and the UI switching applet, Setlang
#define PUI_OFFICE_COMMAND (WM_USER + 0x0901)

#define PLUGUI_CMD_SHUTDOWN		0 // wParam value
#define PLUGUI_CMD_QUERY		1 // wParam value
#define OFFICE_VERSION_9		9 // standardized value to return for Office 9 apps
#define OFFICE_MAJOR_VERSION	10 // Current version of Office; used for communication with Setlang only

typedef struct _PLUGUI_INFO
{
	unsigned uMajorVersion : 8;	// Used to indicate App;s major version number
	unsigned uNoAppReboot : 1;	// BOOL, if FALSE, allows reboot by Setlang. TRUE means we don't want to be rebooted now
	unsigned uUnused : 23;		// not used
} PLUGUI_INFO;

typedef union _PLUGUI_QUERY
{
	UINT uQueryVal;
	PLUGUI_INFO PlugUIInfo;
} PLUGUI_QUERY;
// End of Pluggable UI section
#endif

/* End of common #define section */


/*************************************************************************
	Common segmentation definitions 
*************************************************************************/

/*	Used with #pragma to swap-tune global variables into the boot section
	of the data segment.  Should link with -merge:.bootdata=.data when
	using these pragmas */
	
#if VSMSODEBUG
	#define MSO_BOOTDATA
	#define MSO_ENDBOOTDATA
#else
	#define MSO_BOOTDATA data_seg(".bootdata")
	#define MSO_ENDBOOTDATA data_seg()
#endif


/*************************************************************************
	Stuff for Performance marker support - Don't mess with these in 
	your code unless you really know what you are doing.
*************************************************************************/
#define MSO_PERFMARKON  warning(disable: 4102)
#define MSO_PERFMARKOFF warning(default: 4102)
#define MsoPerformanceMarkerLabel()

/*---------------------------------------------------------------------------
	RISC alignment defines
--------------------------------------------------------------- BrianWen ---*/
#ifndef UNALIGNED
#if defined(_M_ALPHA)
#define UNALIGNED __unaligned
#else
#define UNALIGNED
#endif	/* (_M_ALPHA) */
#endif	/* UNALIGNED */

/*----------------------------------------------------------------------------
	COM IUnknown methods utilities
------------------------------------------------------------------- HAILIU -*/
#ifdef __cplusplus
#define MsoComAddRef(punk)   ((punk)->AddRef())
#define MsoComRelease(punk)  ((punk)->Release())
#define MsoComQueryInterface(punk, riid, ppv)   \
	((punk)->QueryInterface((riid), (LPVOID*)(ppv)))
#else
#define MsoComAddRef(punk)   ((punk)->lpVtbl->AddRef((punk)))
#define MsoComRelease(punk)  ((punk)->lpVtbl->Release((punk)))
#define MsoComQueryInterface(punk, riid, ppv)   \
	((punk)->lpVtbl->QueryInterface((punk), (riid), (LPVOID*)(ppv)))
#endif //__cplusplus


/// WARNING WARNING WARNING WARNING WARNING WARNING WARNING WARNING 
/// WARNING WARNING WARNING WARNING WARNING WARNING WARNING WARNING 
/// WARNING WARNING WARNING WARNING WARNING WARNING WARNING WARNING 


// for set {a,b[,c...]} in range 0..31
#define InSetOf9(v, a,b,c,d,e,f,g,h,i)	(!((v)&(~0x1fL)) && ((1<<(v)) & ((1<<(a))|(1<<(b))|(1<<(c))|(1<<(d))|(1<<(e))|(1<<(f))|(1<<(g))|(1<<(h))|(1<<(i)))))
#define InSetOf2(v, a,b)				InSetOf9(v, a,b,-1,-1,-1,-1,-1,-1,-1)
#define InSetOf3(v, a,b,c)				InSetOf9(v, a,b,c,-1,-1,-1,-1,-1,-1)
#define InSetOf4(v, a,b,c,d)			InSetOf9(v, a,b,c,d,-1,-1,-1,-1,-1)
#define InSetOf5(v, a,b,c,d,e)			InSetOf9(v, a,b,c,d,e,-1,-1,-1,-1)
#define InSetOf6(v, a,b,c,d,e,f)		InSetOf9(v, a,b,c,d,e,f,-1,-1,-1)
#define InSetOf7(v, a,b,c,d,e,f,g)		InSetOf9(v, a,b,c,d,e,f,g,-1,-1)
#define InSetOf8(v, a,b,c,d,e,f,g,h)	InSetOf9(v, a,b,c,d,e,f,g,h,-1)

// for set {a,b[,c...]} within 31 of each other, but not 0..31.  'a' must be smallest
#define InBiasSetOf2(v, a,b)				InSetOf2(v-(a), 0,b-(a))
#define InBiasSetOf3(v, a,b,c)				InSetOf3(v-(a), 0,b-(a),c-(a))
#define InBiasSetOf4(v, a,b,c,d)			InSetOf4(v-(a), 0,b-(a),c-(a),d-(a))
#define InBiasSetOf5(v, a,b,c,d,e)			InSetOf5(v-(a), 0,b-(a),c-(a),d-(a),e-(a))
#define InBiasSetOf6(v, a,b,c,d,e,f)		InSetOf6(v-(a), 0,b-(a),c-(a),d-(a),e-(a),f-(a))
#define InBiasSetOf7(v, a,b,c,d,e,f,g)		InSetOf7(v-(a), 0,b-(a),c-(a),d-(a),e-(a),f-(a),g-(a))
#define InBiasSetOf8(v, a,b,c,d,e,f,g,h)	InSetOf8(v-(a), 0,b-(a),c-(a),d-(a),e-(a),f-(a),g-(a),h-(a))
#define InBiasSetOf9(v, a,b,c,d,e,f,g,h,i)	InSetOf9(v-(a), 0,b-(a),c-(a),d-(a),e-(a),f-(a),g-(a),h-(a),i-(a))


#if VSMSODEBUG
#define MSOFORCECONST const
#else
#define MSOFORCECONST
#endif // VSMSODEBUG

#endif // MSOSTD_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Inc\office10\msoswct.h ===
#pragma once

/*------------------------------------------------------------------------*
 * msoswct.h (previously known as sdmtowct.h): SDM PUBLIC include file    *
 *   containing the interface to be used for communication from outside   *
 *   applications with SDM dialogs.                                       *
 *                                                                        *
 * Please do not modify or check in this file without contacting NicoleP. *
 *------------------------------------------------------------------------*/


#ifndef SDM_WCT_DEFINED
#define SDM_WCT_DEFINED

//------------------------------------------------------------------------
// WCT/SDM Values - Definitions and descriptions
//------------------------------------------------------------------------
#define wVerAnsi			2		// Ansi strings
#define wVerUnicode			3		// Unicode strings
#define wVerWord			wVerAnsi	//historical -- this should be removed at some point
#define wVerAnsiExt			4		// Ansi with extened functionality. (off10 and beyond)
#define wVerUnicodeExt		5	// Unicode with extended functionality. (off10 and beyond)

#define FIsWVerAnsi(wVer) (((WORD)(wVer) == wVerAnsi) || ((WORD)(wVer) == wVerAnsiExt))
#define FIsWVerUnicode(wVer) (((WORD)(wVer) == wVerUnicode) || ((WORD)(wVer) == wVerUnicodeExt))
#define FIsWVerExt(wVer) (((WORD)(wVer) == wVerAnsiExt) || ((WORD)(wVer) == wVerUnicodeExt))
#define FIsWVerValid(wVer) (((WORD)(wVer) == wVerAnsi) || ((WORD)(wVer) == wVerAnsiExt) || ((WORD)(wVer) == wVerUnicode) || ((WORD)(wVer) == wVerUnicodeExt))

// A pointer to an array of WCTL structures is passed as the lParam
//  in a WM_GETCONTROLS message
//
typedef struct _wctl
	{
	WORD wtp;				// Item type
	WORD wId;				// Unique identifier within this dialog (TMC)
	WORD wState;			// Current value if fHasState
	WORD cchText;			// Size of text value, if fHasText
	WORD cchTitle;			// Size of title, if fHasTitle
	RECT rect;				// Rectangle in dialog window
	LONG fHasState:1;		// Can this type of item have a numeric state?
	LONG fHasText:1;		// Can this type of item have a text value?
	LONG fHasTitle:1;		// Does the item have a title?
	LONG fEnabled:1;		// Is the item currently enabled?
	LONG fVisible:1;		// Is the item visible?
	LONG fCombo:1;			// Is the item a combo edit or listbox?
	LONG fSpin:1;			// Is the item a spin edit?
	LONG fOwnerDraw:1;	// Is the item owner-draw (or extended listbox)?
	LONG fCanFocus:1;		// Can the item receive focus?
	LONG fHasFocus:1;		// Does the item have focus?
	LONG fList:1;			// Supports wtxi.wIndex, WM_GETLISTCOUNT
	LONG fPageTabs:1;	  	// Is the item a page tab list?
	LONG fSelected:1;	  	// Is the item selected (for general pictures)?
	LONG fIsSecret:1;		// is a secret (passworded) edit control.
	LONG lReserved:18;	// A bunch o' bits
	WORD wParam1;			// for tmtStaticText, tmtFormattedText
	union
		{
		struct
			{
			WORD wParam2;	// as above
			WORD wParam3;	// yet another spare value for drawing routines
			};
		LONG lParam;		// long version of spare value
		HWND hwnd;			// hwnd of general picture control, if any
		};
	} WCTL, *PWCTL, FAR *LPWCTL;

/* Possible values for wctl.wtp */
#define wtpMin				1
#define wtpStaticText		1
#define wtpPushButton		2
#define wtpCheckBox			3
#define wtpRadioButton		4
#define wtpGroupBox			5
#define wtpEdit				6
#define wtpFormattedText	7
#define wtpListBox			8
#define wtpDropList			9
#define wtpBitmap			10
#define wtpGeneralPicture	11
#define wtpScroll			12
#define wtpHyperlink		13
#define wtpMax				14

// A pointer to a WTXI structure is passed as the lParam of
//  a WM_GETCTLTEXT or WM_GETCTLTITLE message.
// DONT change this structure EVER.
typedef struct _wtxi		// WinWord text info
	{
	LPWSTR	lpszBuffer;		// Buffer to receive string
	WORD	cch;			// Size of buffer to receive string, in chars
	WORD	wId;			// Item identifier (TMC) (as in wctl.wId)
	RECT	rect;			// Used for WM_GETCTLTITLE and general picture lists
	WORD	wIndex;		// Used for WM_GETCTLTEXT on ListBoxes or if WCTL.fList
	} WTXI, *PWTXI, FAR *LPWTXI;

// Don't change this structure without checking with PaulCole (RCA: sjade, peterth)
// Because of external dependencies entries may only be added to the end of 
// the extended structure and may only be used intereally if the 
// wVerId version flag is Extended.
typedef struct _wtxi_extended
	{
	// Everything in the WTXI struct... don't ever alter this
	LPWSTR	lpszBuffer;		// Buffer to receive string
	WORD	cch;			// Size of buffer to receive string, in chars
	WORD	wId;			// Item identifier (TMC) (as in wctl.wId)
	RECT	rect;			// Used for WM_GETCTLTITLE and general picture lists
	WORD	wIndex;		// Used for WM_GETCTLTEXT on ListBoxes or if WCTL.fList

	// OK you can add things below here, but when accessing them you must
	// ensure that the ver ID is one of the extended versions.
	union
		{
		LONG lFlags;

		struct
			{		
			LONG fIsSecret:1;	// Use only with a password edit field.
			LONG unused:31;
			};
		};		
	} WTXI_EXTENDED, *PWTXI_EXTENDED, FAR *LPWTXI_EXTENDED;



//------------------------------------------------------------------------
// WCT/SDM MESSAGES - Definitions and descriptions
//------------------------------------------------------------------------

#define WM_GETCOUNT		0x7FFE
	// Returns the number of bytes needed to store control info.
	//	wParam	- the version id
	//		Must be wVerAnsi[Ext] or wVerUnicode[Ext]
	//	lParam	- Unused
	//		Must be 0

#define WM_GETCONTROLMSAA 0x7FF3
#define WM_GETCONTROLSSHAREDMEM 0x7FF6
#define WM_GETCONTROLS	0x7FF7
	// Retrieves control information for the dialog.
	//	wParam	- the version id
	//		Must be wVerAnsi[Ext] or wVerUnicode[Ext]
	//	lParam	- LPWCTL
	//		Must be at least the size returned by WM_GETCOUNT
	// Return value is the number of WCTL structures filled.

#define WM_GETCTLTEXT	0x7FFD
	// Retrieves the text value for the specified control
	//	wParam	- the version id
	//		Must be wVerAnsi[Ext] or wVerUnicode[Ext]
	//	lParam	- LPWTXI
	//		(*lParam)->wId is the wctl.wId retrieved by WM_GETCONTROLS.
	//		For a listbox (wtpListBox or wtpDropList) (*lParam)->wIndex
	//		  must be the index of the listbox entry to be retrieved.

#define WM_GETCTLTITLE	0x7FFC
	// Retrieves the title of the specified control
	//	wParam	- the version id
	//		Must be wVerAnsi[Ext] or wVerUnicode[Ext]
	//	lParam	- LPWTXI
	//		(*lParam)->wId is the wctl.wId retrieved by WM_GETCONTROLS

#define WM_GETCTLFOCUS	0x7FFB
	// Returns the wId (TMC) (as in wctl.wId) of the control with focus.
	//	wParam	- the version id
	//		Must be wVerAnsi[Ext] or wVerUnicode[Ext]
	//	lParam	- Unused
	//		Must be 0

#define WM_SETCTLFOCUS	0x7FFA
	// Sets focus to the specified control
	//	wParam	- the version id
	//		Must be wVerAnsi[Ext] or wVerUnicode[Ext]
	//	lParam	- a wId value as retrieved by WM_GETCONTROLS

#define WM_GETLISTCOUNT 0x7FF9
	// Returns the number of entries in a listbox
	// wParam	- the version id
	//		Must be wVerAnsi[Ext] or wVerUnicode[Ext]
	//	lParam	- a wId value as retrieved by WM_GETCONTROLS
	//		Must be a listbox (wtpListBox or wtpDropList)

#define WM_GETHELPID	0x7FF8
	// Returns the dialog's Help ID
	// wParam	- the version id
	//		Must be wVerAnsi[Ext] or wVerUnicode[Ext]
	//	lParam	- Unused
	//		Must be 0

#define WM_GETCONTROLSMOUSEDRV 0x7FFF
	// special "light" version of WM_GETCONTROLS used by the mouse 9.01 driver

#define WM_GETCONTROLSMSAA 0x7FF4
	// version of WM_GETCONTROLS used by MSAA 

#define WM_GETDROPDOWNID 0x7FF5
	//Returns the item identifier (TMC) of the control that currently owns the dropdown list window
	//This message should be sent directly to the dropdown list window.
	// wParam	- the version id
	//		Must be wVerAnsi[Ext] or wVerUnicode[Ext]
	//	lParam	- Unused
	//		Must be 0

//------------------------------------------------------------------------
// WIN32 Memory Access
//------------------------------------------------------------------------

#define SZWCTNAME "SDMWCT"
#define hFileNoneWct -1

//------------------------------------------------------------------------
// WCT/SDM error return values.
//------------------------------------------------------------------------

#define	errWctOOM			0xfffc	// Out o' memory!
#define	errNoCurrentDlg	0xfffd	// Attempt to get info for non-existent dialog
#define errCountCtls	0xfffe	// Invalid buffer size
#define	errInvalidVerId	0xffff	// Invalid Version of the data structure
#define errNotSDM		0x0000	// WinPRocs return 0 for unknown msgs by default

#define	uNoValue		0x000e	// Value of control where control has no numeric value

#endif //SDM_WCT_DEFINED
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Inc\office10\msosproc.h ===
/*------------------------------------------------------------------------*
 * msosproc.h (prevously known as sdmproc.h): SDM PUBLIC include file     *
 *  -- SDM function prototypes.                                           *
 *                                                                        *
 * Please do not modify or check in this file without contacting MsoSdmQs.*
 *------------------------------------------------------------------------*/

#pragma once
#ifndef NO_SDM

//============================
// who's not defined?
#ifdef IME_OLD
#error
#endif
#ifdef BACKGROUND_PATTERN
#error
#endif
#ifdef IME32
// REVIEW KirkG: This is not defined for Mso.  It is defined for Word
//  (in word.h), but I don't think anything in Word's build uses it.
//#error
#endif
#ifdef DBCS
// REVIEW KirkG: This is not defined for Mso.  It is defined for Word
//  (in word.h), but I don't think anything in Word's build uses it.
//#error
#endif
#ifdef EXTCHAR
// REVIEW KirkG: This is not defined for Mso.  It is defined for Word
//  (in word.h), but I don't think anything in Word's build uses it.
//#error
#endif
//============================

typedef int (*MSO_PFN)(); // Pointer to function
 
///////////////////////////////////////////////////////////////////////////////
// Common calls.

// Initialization and main control.

MSOAPI_(BOOL_SDM)	FValidTmc(TMC);	//new 96: executes for ship and debug versions

#ifdef	VSMSODEBUG
MSOAPIX_(VOID)	EnableReports(BOOL_SDM);
#else
#define			EnableReports(f)	
#endif

MSOAPI_(FTME)	FtmeIsSdmMessage(LPMSG);

MSOAPI_(VOID)	ChangeColors(void);
MSOAPIX_(VOID)	SetDlgColor(HDLG, DWORD);
MSOAPIX_(DWORD)	ClrGetDlgColor(HDLG);

MSOAPI_(BOOL_SDM)	FInitSdm(SDI *);
MSOAPI_(VOID)	EndSdm(void);
MSOAPI_(BOOL) MsoFSetHMsoinstOfSdm(HMSOINST hinst);
MSOAPI_(BOOL) MsoFSetSdmNoModalComponent(BOOL fNoModalComp);
MSOAPI_(BOOL) MsoFSetSdmDontShowInvisibleWindow(BOOL fDontShow);
MSOAPI_(HMSOINST) HMsoinstGetFromSdm(void);
MSOAPI_(void)	MsoSetBidiRtlSdm(BOOL fRTL);	

// Help Support.
MSOAPI_(DWORD)	ContextPosOfDlg(HDLG);
MSOAPIXX_(UINT_SDM)	ContextHidOfDlg(HDLG);
MSOAPI_(UINT_SDM)	HidOfDlg(HDLG);
MSOAPIX_(UINT_SDM)	BaseHidOfDlg(HDLG);
MSOAPI_(BOOL_SDM)	FSetDlgHid(HDLG, UINT_SDM);
MSOAPI_(BOOL_SDM)	FIsOfficeDlg(HDLG);

// CAB Control.
MSOAPI_(HCAB)	HcabAlloc(UINT_SDM, SB_SDM);
MSOAPI_(VOID)	InitCab(HCAB, UINT_SDM);
MSOAPI_(VOID)	InitCabWords(HCAB, UINT_SDM);
MSOAPI_(VOID)	FreeCab(HCAB, SB_SDM);
MSOAPI_(VOID)	MsoFreeCabData(HCAB, SB_SDM);

__inline PCAB PcabLockCab(HCAB hcab, SB_SDM sb) { return (*(hcab)); }
#define UnlockCab(hcab, sb)

#ifdef VSMSODEBUG
// Use this one to mark dynamically allocated CAB's (most apps)
MSOAPIXX_(BOOL_SDM) MsoFWriteCabBe(HCAB hcab, LPARAM lParam);
// Use this one to mark statically allocated CAB's (special case)
MSOAPIXX_(BOOL_SDM) MsoFWriteCabHandlesBe(HCAB hcab, LPARAM lParam);
#endif
MSOAPI_(BOOL_SDM)	FSetCabWt(HCAB, CONST_WTZ_CAB, UINT_SDM, SB_SDM);
MSOAPI_(VOID)	GetCabWtz(HCAB, WTZ_CAB, UINT_SDM, UINT_SDM);
MSOAPI_(BOOL_SDM)	FSetCabWz(HCAB, CONST_WZ_CAB, UINT_SDM, SB_SDM);
MSOAPI_(UINT_SDM)	CchOfCabWz(HCAB, UINT_SDM);
MSOAPI_(VOID)	GetCabWz(HCAB, WZ_CAB, UINT_SDM, UINT_SDM);
MSOAPI_(BOOL_SDM)	FSetCabRgb(HCAB, CONST_RGB_CAB, UINT_SDM, UINT_SDM, SB_SDM);
MSOAPI_(VOID)	GetCabWt(HCAB, WTZ_CAB, UINT_SDM, UINT_SDM);
MSOAPI_(BOOL_SDM)	GetCabRgb(HCAB, RGB_CAB, UINT_SDM, UINT_SDM, SB_SDM);
#define FGetCabRgb GetCabRgb

MSOAPI_(BOOL_SDM) MsoFSetCabHandleWt(PCABH, CONST_WTZ_CAB, SB_SDM);
MSOAPI_(BOOL_SDM) MsoFSetCabHandleWz(PCABH, CONST_WZ_CAB, SB_SDM);
MSOAPI_(BOOL_SDM) MsoFSetCabHandleRgb(PCABH, CONST_RGB_CAB, UINT_SDM, SB_SDM);
MSOAPI_(VOID)	  MsoGetCabHandleWtz(PCABH, WTZ_CAB, UINT_SDM);
MSOAPI_(VOID)	  MsoGetCabHandleWz(PCABH, WZ_CAB, UINT_SDM);
MSOAPI_(VOID)	  MsoGetCabHandleWt(PCABH, WT_CAB, UINT_SDM);
MSOAPI_(BOOL_SDM) MsoFGetCabHandleRgb(PCABH, RGB_CAB, UINT_SDM, SB_SDM);

// Generic Dialog Control
MSOAPI_(void) 	MsoInitDli(DLI *, HWND, FDLG, UINT_SDM);
MSOAPI_(short) 	MsoCbOfDlt(long, HINSTANCE);
MSOAPI_(BOOL) 	MsoFBltDlt(long, void *, HINSTANCE);
MSOAPI_(TMC)	MsoTmcStartDlt(long, HCAB, UINT_SDM, FDLG, HWND, HINSTANCE, const MSO_PFN *, UINT_SDM);
//OAPI_(void) 	MsoStartModelessDlt(long, HCAB, UINT_SDM, FDLG, HWND, MLDComp *, HINSTANCE, PFN*, UINT_SDM);
MSOAPI_(void)	MsoFixDltPfns(void *, const MSO_PFN *);
MSOAPI_(void)	MsoConvertRecToRc(REC *, RECT *);
MSOAPIX_(BOOL) 	MsoFSetupDlgResizing(long dlt, XY_SDM dx, XY_SDM dy, PFN_RESIZE pfnResize, HINSTANCE hinst);
MSOAPI_(BOOL)   MsoFSetupDalResizing(XY_SDM dx, XY_SDM dy, BOOL fResizeBorder);
MSOAPI_(BOOL)   MsoFResetDalResizing();
MSOAPI_(BOOL)   MsoFFixResizedRect(HWND hwnd, TMC tmc); // Resizes an SDM picture's
                                                        // window if necessary.  This
                                                        // should be called on tmmPaint
                                                        // messages.
MSOAPI_(BOOL) MsoFFixResizedIndentedRect(HWND hwnd, TMC tmc, RECT rectIndents);

MSOAPI_(LPVOID) MsoLoadPres(HINSTANCE hinst, int resType, int resId);

MSOAPI_(VOID) MsoSetDefaultButtonIndication(HDLG hdlg, BOOL fUseDefault);

// Resize handles (grippies)
MSOAPI_(VOID) MsoSetGrippiesDlg(HDLG hdlg, BOOL fUseGrippies);
MSOAPI_(BOOL) MsoFGetGrippiesDlg(HDLG hdlg);
#define msoGrippieSize 11

// Define some macros
#define MsoTmcPerformDlg(Dlt, hcab, fdlg, hParent, hinst, rgpfn, wRef) \
	MsoTmcStartDlt((long)dlt##Dlt, (HCAB)(hcab), ctmDlt##Dlt, (fdlg), hParent, hinst, rgpfn, wRef)
#define MsoPerformModelessDlg(Dlt, hcab, fdlg, hParent, pmdlc, hinst, rgpfn, wRef) \
	MsoStartModelessDlt((long)dlt##Dlt, (HCAB)(hcab), ctmDlt##Dlt, (fdlg), hParent, pmdlc, hinst, rgpfn, wRef, fFalse)

// Dialog Control.
MSOAPI_(UINT_SDM)	IdDoMsgBox(const WCHAR *, const WCHAR *, UINT_SDM);
MSOAPI_(BOOL_SDM)	FSetDlgSab(SAB_SDM);

// Flags for bringing up a dialog.
#define msogrfHdlgStartDefault        0x00000000 // Default settings.
#define msogrfHdlgStartWorkPane       0x00000001 // Start a WorkPane dialog.

#define msogrfHdlgStartRepositionLeft 0x00000010 // For AutoLayout dialogs only:  The
#define msogrfHdlgStartRepositionTop  0x00000100 // given position of the dialog is
                                                 // actually the center point of the
                                                 // dialog, so the dialog will need
                                                 // to be repositioned around that
                                                 // point once the size of the dialog
                                                 // is known.  Not pretty, I know, but
                                                 // it's the best we could come up
                                                 // with to allow for sticky points
                                                 // in DAL dialogs.  NB:  If the
                                                 // bdrAutoPosX border style is set
                                                 // for the dialog, it doesn't make
                                                 // sense to make use of
                                                 // msogrfHdlgStartRepositionLeft,
                                                 // and if the bdrAutoPosY
                                                 // border style is set for the
                                                 // dialog, it doesn't make sense
                                                 // to make use of
                                                 // msogrfHdlgStartRepositionTop.
                                                 

MSOAPI_(TMC) TmcDoDlgDliEx(struct _dlt **, HCAB hcab, DLI *pdli, DWORD grfHdlgStart);
MSOAPIX_(TMC)	TmcDoDlg(struct _dlt * *, HCAB, BYTE *);
MSOAPI_(TMC)	TmcDoDlgDli(struct _dlt * *, HCAB, DLI *);
MSOAPI_(HDLG)	HdlgStartDlg(struct _dlt * *, HCAB, DLI *);
MSOAPI_(HDLG) HdlgStartDlgEx(struct _dlt * *, HCAB, DLI *, DWORD);

#ifdef VSMSODEBUG
MSOAPIXX_(BOOL_SDM) MsoFWriteDlgBe(HDLG hdlg, LPARAM lParam);
#endif
MSOAPI_(VOID)	EndDlg(TMC);
MSOAPIX_(TMC)	TmcEndedDlg(VOID);
MSOAPI_(BOOL_SDM)	FFreeDlg(void);
MSOAPI_(SAB_SDM)	SabGetDlg(void);
MSOAPI_(SAB_SDM)	MsoSabGetDlgEx(HDLG hdlg);
MSOAPI_(UINT_SDM) MsoItmBaseGetDlgTmc(HDLG hdlg, TMC tmc);

MSOAPI_(VOID)	SetTmcVal(TMC, UINT_SDM);
MSOAPI_(UINT_SDM)	ValGetTmc(TMC);
MSOAPI_(VOID)	GetTmcLargeVal(TMC, VOID *, UINT_SDM);
MSOAPI_(BOOL_SDM)	FSetTmcLargeVal(TMC, VOID *);
MSOAPI_(VOID)	SetTmcText(TMC, const WCHAR *);
MSOAPI_(VOID)	SetTmcTextNoRedraw(TMC, const WCHAR *);
MSOAPI_(VOID)	GetTmcText(TMC, WCHAR *, UINT_SDM);
MSOAPI_(UINT_SDM)	CchGetTmcText(TMC, WCHAR *, UINT_SDM);
MSOAPI_(VOID) SetTmcTextFromDw(TMC tmc, DWORD dw);
MSOAPI_(DWORD) DwFromTmcText(TMC tmc);

MSOAPI_(BOOL_SDM)	SetFocusTmc(TMC);
#define FSetFocusTmc(tmc) SetFocusTmc(tmc)

MSOAPI_(BOOL_SDM)	SetFocusTmcEx(TMC tmc, DWORD msogrfSFT);

// Nothing
#define msogrfSFTNone 		0

// Use when you want to move focus because of a mouse click. Will stop scrolling
// the control into view if in the workpane.
#define msogrfSFTClick		1
#define msogrfSFTNoScroll	msogrfSFTClick 
#define msogrfSFTAll		msogrfSFTNone | msogrfSFTClick | msogrfSFTNoScroll

MSOAPI_(TMC)	TmcGetFocus(VOID);
MSOAPI_(TMC)	TmcGetAccelerator(UINT_SDM);

MSOAPIX_(VOID)	SpinTmc(TMC, UINT_SDM, INT_SDM, INT_SDM, INT_SDM);
MSOAPI_(VOID)	SetReadOnlyTmc(TMC, BOOL_SDM);

MSOAPIMX_(BOOL_SDM)	FIsMultiLineEditTmc(TMC);
MSOAPI_(VOID)	SetTmcTxs(TMC, TXS);
MSOAPIMX_(VOID) SetTmcTxsNoFocus(TMC tmc, TXS txs);
MSOAPI_(TXS)	TxsGetTmc(TMC);
MSOAPI_(VOID)	RedisplayTmc(TMC);
MSOAPIMX_(VOID) MsoInvalidateTmc(TMC tmc, BOOL fErase);

MSOAPI_(BOOL_SDM)	FEnabledTmc(TMC);
MSOAPI_(VOID)	EnableTmc(TMC, BOOL_SDM);
MSOAPIX_(VOID)	AdminEnableTmc(TMC, BOOL_SDM);
MSOAPIX_(VOID)	EnableNoninteractiveTmc(TMC, BOOL_SDM);

MSOAPI_(U32_SDM)	LUserFromTmc(TMC);
MSOAPI_(VOID)	SetTmcLUser(TMC, U32_SDM);

#define SetScrollRangeTmc(tmc, iMin, iMax) \
		SetScrollRange(WindowOfTmc(tmc), SB_CTL, iMin, iMax, fTrue)
#define GetScrollRangeTmc(tmc, piMin, piMax) \
		GetScrollRange(WindowOfTmc(tmc), SB_CTL, piMin, piMax)
#define SetScrollPosTmc(tmc, iPos) \
		SetScrollPos(WindowOfTmc(tmc), SB_CTL, iPos)
MSOAPI_(VOID)	SetScrollPageTmc(INT_SDM nPage, TMC tmc);
MSOAPI_(HWND) WindowOfDlgCur(void);

MSOAPI_(VOID) CaptureMouseTmc(TMC, BOOL_SDM);

MSOAPIMX_(VOID) SetLightFontTmc(TMC, BOOL_SDM);

MSOAPIX_(PFN_FILTERMSG) PfnSetPfnFilterMsg(PFN_FILTERMSG);
MSOAPI_(PFN_DLGCREATED) MsoPfnSetDlgCreated(PFN_DLGCREATED);

MSOAPIX_(VOID)	SetModeBiasTmc(TMC, BOOL_SDM);
MSOAPIX_(VOID)	SetTmcSpecialTab(TMC tmc, BOOL fFlag);

///////////////////////////////////////////////////////////////////////////////
// Rare Calls.

// CAB Control.
MSOAPI_(HCAB)	HcabFromDlg(BOOL_SDM);
MSOAPI_(VOID)	NinchCab(HCAB);
MSOAPI_(VOID)	MsoZeroCab(HCAB);

// Dialog Control.
MSOAPI_(HDLG)	HdlgSetCurDlg(HDLG);
MSOAPI_(VOID)	ShowDlg(BOOL_SDM);
MSOAPI_(BOOL_SDM)	FVisibleDlg(void);
MSOAPI_(VOID)	ResizeDlg(XY_SDM, XY_SDM);
MSOAPI_(VOID)	ResizeDlgEx(XY_SDM, XY_SDM, BOOL_SDM);

MSOAPI_(VOID)	MoveDlg(XY_SDM, XY_SDM);
MSOAPI_(VOID)	SdmScaleRec(REC *);
MSOAPI_(HDLG)	HdlgSetFocusDlg(HDLG);
MSOAPI_(VOID)	SetTabOrder(TMC *, UINT_SDM);
MSOAPI_(int) 	SwapTabOrder(TMC tmc1, TMC tmc2);
MSOAPI_(VOID)	UpdateWindowDlg(HDLG);

MSOAPI_(VOID)	GetListBoxEntry(TMC, ILBE_SDM, WCHAR *, UINT_SDM);
MSOAPI_(UINT_SDM)	CchGetListBoxEntry(TMC, ILBE_SDM, WCHAR *, UINT_SDM);

MSOAPI_(VOID)	AddListBoxEntry(TMC, const WCHAR *);
MSOAPI_(VOID)	InsertListBoxEntry(TMC, const WCHAR *, ILBE_SDM);
MSOAPI_(VOID)	DeleteListBoxEntry(TMC, ILBE_SDM);
MSOAPI_(ILBE_SDM)	CentryListBoxTmc(TMC);
MSOAPI_(VOID)	StartListBoxUpdate(TMC);
MSOAPI_(VOID)	BeginListBoxUpdate(TMC, BOOL_SDM);
MSOAPI_(VOID)	EndListBoxUpdate(TMC);
MSOAPI_(ILBE_SDM)	IEntryFindListBox(TMC, const WCHAR *, UINT_SDM *);
MSOAPI_(ILBE_SDM)	IEntryListBoxCursorTmc(TMC);
MSOAPI_(BOOL) MsoFSetGalleryColumnWidth(HLBX hlbx, XY_SDM dxPreferred);
MSOAPI_(ILBE_SDM)	IselListBoxTmc(TMC);
MSOAPI_(BOOL) MsoFSetLastMruEntry(HLBX hlbx, ILBE_SDM ilbeMRU);
MSOAPIX_(BOOL) MsoFRemoveMruLine(HLBX hlbx, ILBE_SDM ilbeMRU);

// Set the height of a combo or droplist control's dropdown.
MSOAPI_(void) MsoSDMSetDropdownHeightLines(TMC tmc, int nLines);

MSOAPIMX_(BOOL_SDM) FExtendedTmmSet(BOOL_SDM);
MSOAPI_(HDLG) HdlgQueryCur(void);
MSOAPI_(HCAB) HcabQueryCur(void);
MSOAPI_(UINT_SDM) WRefQueryCur(void);
MSOAPI_(VOID)	EnsureVisibleDlgRec(REC *);
MSOAPIX_(TMC) TmcSetTmcContext(TMC tmc);
MSOAPI_(void) MsoSdmNotifyWinEvent(DWORD dwEvent, TMC tmc, BOOL fChildOnly);

// Command Bar Visuals ('new look')
MSOAPI_(int) MsoIHyperlinkIconMarginGet();
MSOAPIX_(VOID) MsoSdmCtrlCrGet(FTMS ftms, COLORREF *pcrBackground, COLORREF *pcrBorder, COLORREF *pcrText);
MSOAPIX_(VOID) MsoSdmCtrlCbvCrGet(FTMS ftms, int *pmsocbvcrBackground, int *pmsocbvcrBorder, int *pmsocbvcrText);

///////////////////////////////////////////////////////////////////////////////
// Very Rare.

MSOAPI_(BOOL) BidiDropsToLeft(TMC tmc);	// Test Wizard called helper API
MSOAPIX_(BOOL_SDM) MsoFExecuteTmc(TMC, UINT_SDM);
MSOAPI_(BOOL_SDM)	FSendDlm(DLM, TMC, UCBK_SDM, UCBK_SDM, UCBK_SDM);

MSOAPI_(BOOL_SDM)	FIsDialogWindow(HWND);

// CAB Control.
MSOAPI_(HCAB)	HcabDupeCab(HCAB, SB_SDM);

// Dialog Control.
MSOAPI_(BOOL_SDM)	FKillDlgFocus(void);
MSOAPI_(BOOL_SDM)	FModalDlg(HDLG);
MSOAPI_(BOOL_SDM)	FIsDlgDying(VOID);
MSOAPIX_(VOID)	ClearListError(HDLG);

MSOAPI_(ILBE_SDM)	CselListBoxTmc(TMC);
MSOAPIX_(TMV)	TmvGetTmc(TMC);
MSOAPI_(TMT)	TmtGetTmc(TMC);
MSOAPI_(BOOL_SDM)	FReturnDlgControl(TMC, BOOL_SDM);
MSOAPI_(VOID)	SetDefaultTmc(TMC);
MSOAPI_(TMC)	TmcGetDefault(BOOL_SDM);

MSOAPI_(TMC)	TmcGetDropped(VOID);
MSOAPI_(VOID)	GrowDropTmc(TMC);
#if SDMMSAA_TROBWIS_UPDATE
MSOAPIX_(VOID) ShrinkDropTmc(TMC tmc, BARG_SDM fSel);
#else
MSOAPIX_(VOID) ShrinkDropTmc(TMC tmc);
#endif

MSOAPI_(VOID)	SetSecretEditTmc(TMC);

MSOAPI_(VOID)	CompleteComboTmc(TMC);
MSOAPI_(VOID)	LimitTextTmc(TMC, UINT_SDM);
MSOAPI_(VOID)	SetVisibleTmc(TMC, BOOL_SDM);
MSOAPI_(BOOL_SDM)	FIsVisibleTmc(TMC);
MSOAPI_(VOID)	GetTmcRec(TMC, REC *);
MSOAPI_(VOID)	SetTmcRec(TMC, REC *);
MSOAPI_(int)    MsoSDMGetListboxBorder(TMC tmc);


MSOAPI_(HWND)	WindowOfTmc(TMC);

MSOAPIX_(BOOL_SDM)	FIsDlgInteractive(VOID);
MSOAPI_(VOID)	SetDlgCaption(CONST_WZ);

MSOAPI_(HLBX)	HlbxFromTmc(TMC);
MSOAPIX_(BOOL_SDM)	SetTmcFlbx(TMC, UINT_SDM);
MSOAPIX_(BOOL_SDM) GetTmcFlbx(TMC tmc, UINT_SDM  *pflbx);

MSOAPI_(HDLG)	HdlgFromWindow(HWND);
MSOAPI_(HWND)	WindowSwapSdmParent(HWND);
MSOAPI_(HWND)	WindowFromDlg(HDLG);

MSOAPI_(UINT_SDM)	CchGetTmc(TMC);
MSOAPIX_(VOID)	SetFdlgOfHdlgCur(FDLG);

MSOAPIX_(VOID)	SetEditTmcHandle(TMC, HANDLE);
MSOAPIX_(HANDLE)	HGetEditTmc(TMC);
MSOAPIX_(FARPROC)	LpfnSetEditFilter(FARPROC);

MSOAPI_(BOOL_SDM) FShrinkRefEdit(TMC);
MSOAPI_(BOOL_SDM) FDlgShrunk(VOID);
MSOAPI_(BOOL_SDM) MsoFSetSdmNotifyOnActivation(BOOL fNotifyOnActivation);

MSOAPI_(void) MsoSetDialogPositionViaFrame(BOOL fDialogPositionViaFrame);

///////////////////////////////////////////////////////////////////////////////
// Restore state.

MSOAPI_(BOOL_SDM)	FRestoreDlg(BOOL_SDM);
MSOAPI_(BOOL_SDM)	FRestoreTmc(TMC, BOOL_SDM);


///////////////////////////////////////////////////////////////////////////////
// EB/EL Support.

MSOAPIX_(BOOL_SDM)	FSetNoninteractive(UINT_SDM, TMC);

#endif //!NO_SDM


///////////////////////////////////////////////////////////////////////////////
// Common interface to button drawing code.

MSOAPIX_(VOID)	SdmBeginPaint(VOID);
MSOAPIX_(VOID)	SdmEndPaint(VOID);

// Draw a control's focus rect in SDM's own special way.
MSOAPI_(VOID) DrawSDMFocusRect(HDC hdc, RECT *pRect, COLORREF crFore, COLORREF crBkg);
MSOAPI_(VOID)	InvertCaret(HWND, HDC, XY_SDM, XY_SDM, XY_SDM, XY_SDM);
MSOAPI_(HANDLE) MsoHdibFromHbitmap(HBITMAP hbmp, HDC hdc, HPALETTE hpal);

// Draw the assistant button face
UCBK_SDM SDM_CALLBACK MsoDrawAsstBtn(TMM tmm, RDS *prds, FTMS ftmsNew,
									 FTMS ftmsOld, TMC tmc, UCBK_SDM wParam);

UCBK_SDM SDM_CALLBACK	WRenderPush(TMM, RDS *, FTMS, FTMS, TMC, UCBK_SDM);
UCBK_SDM SDM_CALLBACK	WRenderWorkPanePush(TMM tmm, RDS *prds, FTMS ftmsNew, FTMS ftmsOld, TMC tmc, UCBK_SDM wParam);
UCBK_SDM SDM_CALLBACK	WRenderStaticText(TMM, RDS *, FTMS, FTMS, TMC, UCBK_SDM);

MSOAPI_(void) MsoMeasureSDMWorkPanePush(TMC tmc, int *pWidth, int *pHeight);

// t-tomker: these functions are necessary for the Dialog Editor, but evidently
// nothing else, so they should only be exported in the internal (debug) library
#ifdef VSMSODEBUG
	MSOAPI_(UCBK_SDM) SDM_CALLBACK	WRenderRadio(TMM, RDS *, FTMS, FTMS, TMC, UCBK_SDM);
	MSOAPI_(UCBK_SDM) SDM_CALLBACK	WRenderCheck(TMM, RDS *, FTMS, FTMS, TMC, UCBK_SDM);
	MSOAPI_(UCBK_SDM) SDM_CALLBACK	WRenderGroup(TMM, RDS *, FTMS, FTMS, TMC, UCBK_SDM);
#else
	UCBK_SDM SDM_CALLBACK	WRenderRadio(TMM, RDS *, FTMS, FTMS, TMC, UCBK_SDM);
	UCBK_SDM SDM_CALLBACK	WRenderCheck(TMM, RDS *, FTMS, FTMS, TMC, UCBK_SDM);
	UCBK_SDM SDM_CALLBACK	WRenderGroup(TMM, RDS *, FTMS, FTMS, TMC, UCBK_SDM);
#endif

MSOAPIDBG_(UCBK_SDM) SDM_CALLBACK	WRenderDropIcon(TMM, RDS *, FTMS, FTMS, TMC, UCBK_SDM);
MSOAPIMX_(VOID) CalcDropIconRecGccRec( REC *oprecIcon, REC *oprecGcc );
MSOAPIXX_(VOID) SetPictureDropped(BOOL fDropped);

MSOAPI_(HFONT) HSdmDlgFontNormal(); //in dmfont.cpp
MSOAPI_(HFONT) GetHFontSdm( void );
MSOAPI_(HFONT) GetHFontLightSdm( void );
MSOAPI_(HFONT) GetHFontBoldSdm( void );


// Sdm Toolbar-like Button flags - see MsoWRenderAsTbButton()
#define msogrfstbNil				0x00000000
#define msofstbDrawDropdown	0x00000001 // Should we draw a dropdown arrow?
#define msofstbSplitDepressed	0x00000002 // Is the dropdown dropped?
#define msofstbNoBorder			0x00000004 // Draw no border (hyperlinks)
#define msofstbHyperlink		0x00000008 // Draw as hyperlink - underlined blue
#define msofstbNoCenter			0x00000010 // Left justify instead of centering
#define msofstbWPIconTextGap	0x00000020 // Uses ICON_TEXT_GAP spacing in drawing icons with text

MSOAPI_(UCBK_SDM) SDM_CALLBACK MsoWRenderAsTbButton(
	TMM			tmm,				// Passed by SDM
	RDS			*prds,				// Passed by SDM
	FTMS		ftmsNew,			// Passed by SDM
	FTMS		ftmsOld,			// Passed by SDM
	TMC			tmc,				// Passed by SDM
	UCBK_SDM	jc,					// Passed by SDM
	int			tcid,				// TCID of icon: msotcidNil for none
	HANDLE  	hdibCustom,			// handle to bitmap icon (HICON, BITMAPINFO, etc)
	HANDLE  	hmaskCustom,		// handle to bitmap icon mask (HICON, BITMAPINFO, etc)
	WCHAR		*wtzLabel,			// Button text
	DWORD		grfstb);			// see msofstb flags

// Sets the icon for the given pushbutton control
MSOAPI_(BOOL) MsoFSetTmcIcon(TMC tmc, int msotcid, BOOL fNoTooltipSet);

#ifdef IME32
MSOAPIX_(VOID) SdmRichEditCtrlIME(TMC, HWND);
MSOAPIX_(VOID) SdmSetImeHwnd(HWND);
MSOAPIX_(VOID) SetImeOption(BOOL_SDM, BOOL_SDM);
#endif //IME32
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Inc\office10\msotc.h ===
/****************************************************************************
	Msotc.h

	Owner: EricSchr
 	Copyright (c) 1997 Microsoft Corporation

	Declarations for functions related to TCO
****************************************************************************/

#pragma once

#ifndef MSOTC_H
#define MSOTC_H 1




/*------------------------------------------------------------------------
	MsoGetPathPreference

	0 - Default behavior (whatever was given)
	1 - Prefer Drive Letter
	2 - Prefer UNC name

---------------------------------------------------------------- AndrewH -*/
MSOAPI_(BYTE) MsoGetPathPreference();

enum
{
	msoNoPathPreference	= 0,
	msoPathPreferLetter	= 1,
	msoPathPreferUNC	= 2
};


#ifdef OFFICE10
// Stuff from tcpush.cpp cut from office9:

/*------------------------------------------------------------------------
	MsoFCheckForUpdate

	Check the registry for the product of szPID for a software update
	if returns true lpwzAbstract and lpwzInfoUrl must be deallocated unless
	MsoFAlertForUpdate is called (in which case they are deallocated there)
---------------------------------------------------------------- t-andreh -*/
MSOAPI_(BOOL) MsoFCheckForUpdate(char* szPID, LPWSTR *lpwzAbstract, LPWSTR *lpwzInfoUrl);

/*------------------------------------------------------------------------
	MsoFFAlertForUpdate

	Do an alert box with the agent prompting the user about a software
	update, using the given strings for the abstract and url to a web
	page with information.  
	The strings are deallocated by this function.
---------------------------------------------------------------- t-andreh -*/
MSOAPI_(BOOL) MsoFAlertForUpdate(char* szPID, LPWSTR *lpwzAbstract, LPWSTR *lpwzInfoUrl);

#endif // OFFICE10

/*---------------------------------------------------------------------------
	MsoAppendToPath

	Append a string, ensuring that there's the proper slash in between.
------------------------------------------------------------------ JJames -*/
MSOAPI_(void) MsoAppendToPath(const WCHAR *wzSub, WCHAR *wzPath);

/*-----------------------------------------------------------------------------
	MsoWzAfterPath

	Return a pointer after the last backslash, or the start if there is none.
------------------------------------------------------------------ JJames ---*/
MSOAPI_(WCHAR *) MsoWzAfterPath(const WCHAR *wzPathName);

/*-----------------------------------------------------------------------------
	MsoWzBeforeExt

	Return a pointer just before extension.
	Return NULL if there is no extension.
------------------------------------------------------------------ IgorZ ---*/
MSOAPI_(WCHAR *) MsoWzBeforeExt(const WCHAR *wzPathName);

/*-----------------------------------------------------------------------------
	MsoFFileExist

	Returns fTrue iff the file exists and is not a directory.
------------------------------------------------------------------ JJames ---*/
MSOAPI_(BOOL) MsoFFileExist(const WCHAR *wzFile);


/*---------------------------------------------------------------------------
	MsoFDirExist

	Return fTrue if and only if wzDir exists and is a directory.
---------------------------------------------------------------- EricSchr -*/
MSOAPI_(BOOL) MsoFDirExist(const WCHAR *wzDir);


/*---------------------------------------------------------------------------
	MsoFCreateFullDirectory

	Create directory wzDir, creating subdirectories as necessary.
	Return fTrue if successful.
---------------------------------------------------------------- EricSchr -*/
MSOAPI_(BOOL) MsoFCreateFullDirectory(const WCHAR *wzDir);


// MSOADF (MSO Application Data Folder)
// The subfolder under the App Data folder
typedef enum
	{
	msoadfFirst, msoadfMin = msoadfFirst, msoadfMinLessOne = msoadfMin - 1,
	
	msoadfMicrosoft,	// Application Data\Microsoft
	msoadfWord,			// msoadfMicrosoft\Word
	msoadfExcel,		// msoadfMicrosoft\Excel
	msoadfGraph,		// msoadfMicrosoft\Graph
	msoadfAccess,		// msoadfMicrosoft\Access
	msoadfOutlook,		// msoadfMicrosoft\Outlook
	msoadfPowerPoint,	// msoadfMicrosoft\PowerPoint
	msoadfOffice,		// msoadfMicrosoft\Office
	msoadfStartup,		// msoadfWord\Startup
	msoadfXlstart,		// msoadfExcel\Xlstart
	msoadfXlURL,		// msoadfExcel\URL
	msoadfAddins,		// msoadfMicrosoft\Addins
	msoadfQueries,		// msoadfMicrosoft\Queries
	msoadfProof,		// msoadfMicrosoft\Proof
	msoadfTemplates,	// msoadfMicrosoft\Templates
	msoadfRecentFiles,	// msoadfOffice\Recent Files
	msoadfActors,		// msoadfOffice\Actors
	msoadfThemes,		// msoadfMicrosoft\Themes
	msoadfOSB,			// msoadfOffice\OSB
	msoadfStationery,	// msoadfMicrosoft\Stationery
	msoadfSignatures,	// msoadfMicrosoft\Signatures
	msoadfPublisher,	// msoadfMicrosoft\Publisher
	msoadfDesigner,		// msoadfMicrosoft\Designer
	msoadfDesignerServers, // msoadfDesigner\My Servers
	msoadfDesignerPersonalFolders, // msoadfDesigner\Personal Folders
	msoadfMse, 			// msoadfMicrosoft\Mse

	msoadfMax, msoadfLast = msoadfMax - 1
	} MSOADF;


/*---------------------------------------------------------------------------
	MsoHrGetAppDataFolder

	Return the location of the user's Application Data folder in his/her
	profile.  It appends (and creates) the subdirectory specified by adf.
	'wz' is the buffer where the result will go.  'wz' should be at least
	MAX_PATH in size.  Use 'fCreate' to specify if the folder should be
	created if it doesn't exist already.  If fCreate is FALSE and the
	directory doesn't exist, return E_FAIL, otherwise return S_OK.
---------------------------------------------------------------- EricSchr -*/
MSOAPI_(HRESULT) MsoHrGetAppDataFolder(WCHAR *wz, MSOADF adf, BOOL fCreate);


/*---------------------------------------------------------------------------
	MsoHrGetCommonAppDataFolder

	Same as MsoHrGetAppDataFolder, but takes the All Users\Application Data
	directory as opposed to the <username>\Application Data directory.
------------------------------------------------------------------ DVierz -*/
MSOAPI_(HRESULT) MsoHrGetCommonAppDataFolder(WCHAR *wz, MSOADF adf, BOOL fCreate);

/*---------------------------------------------------------------------------
	MsoHrGetLocalAppDataFolder

	Same as MsoHrGetAppDataFolder, but returns the local (NON-roaming)
    [...\<username>\Local Settings\Application Data] directory as 
    opposed to the [...\<username>\Application Data] directory.
---------------------------------------------------------------- camerost -*/
MSOAPI_(HRESULT) MsoHrGetLocalAppDataFolder(WCHAR *wz, MSOADF adf, BOOL fCreate);

// behavioral flags
#define fadfCheckExist 0x01
#define fadfCreate     0x02
#define grfadfDefault  (fadfCheckExist | fadfCreate)

// specific folder type flags
#define fadftRoamingAppData  0
#define fadftCommonAppData   1
#define fadftLocalAppData    2

/*---------------------------------------------------------------------------
	MsoHrGetAppDataFolderEx
------------------------------------------------------- HAILIU / camerost -*/
MSOAPI_(HRESULT) MsoHrGetAppDataFolderEx(WCHAR *wz, MSOADF adf, DWORD grf, int adfType);

/*---------------------------------------------------------------------------
	MsoHrGetMyDocumentsFolder

	Return the location of the user's My Documents folder in their profile.
	'wz' is the buffer where the result will go.  It must be at least
	MAX_PATH in size.  Always return S_OK.
---------------------------------------------------------------- EricSchr -*/
MSOAPI_(HRESULT) MsoHrGetMyDocumentsFolder(WCHAR *wz);


/*---------------------------------------------------------------------------
	MsoHrGetFavoritesFolder

	Return the location of the user's Favorites folder in their profile.
	'wz' is the buffer where the result will go.  It must be at least
	MAX_PATH in size.  Always return S_OK.
---------------------------------------------------------------- EricSchr -*/
MSOAPI_(HRESULT) MsoHrGetFavoritesFolder(WCHAR *wz);


/*---------------------------------------------------------------------------
	MsoHrGetDesktopFolder

	Return the location of the user's Desktop folder in their profile.
	'wa' is the place where the result will go.  It must be at least
	MAX_PATH in size.  Always return S_OK.
---------------------------------------------------------------- EricSchr -*/
MSOAPI_(HRESULT) MsoHrGetDesktopFolder(WCHAR *wz);


/*---------------------------------------------------------------------------
	MsoFIsAppDataFolder

	Determine if 'wz' is the application data folder specified by 'msoadf'.
---------------------------------------------------------------- EricSchr -*/
MSOAPI_(BOOL) MsoFIsAppDataFolder(const WCHAR *wz, MSOADF adf);


/*---------------------------------------------------------------------------
	MsoFIsMyDocumentsFolder

	Determine if 'wz' is the My Documents folder.
---------------------------------------------------------------- EricSchr -*/
MSOAPI_(BOOL) MsoFIsMyDocumentsFolder(const WCHAR *wz);


/*---------------------------------------------------------------------------
	MsoFFileInAppDataFolder

	Determine if the non-leaf part of 'wz' is the app data folder specified
	by 'adf'.
---------------------------------------------------------------- EricSchr -*/
MSOAPIX_(BOOL) MsoFFileInAppDataFolder(const WCHAR *wz, MSOADF adf);
	

/*---------------------------------------------------------------------------
	MsoFStripAppDataFolder

	If the non-leaf path is the app data folder specified by 'adf',
	remove it.  Return fTrue if the removal occurs, fFalse otherwise.
---------------------------------------------------------------- EricSchr -*/
MSOAPI_(BOOL) MsoFStripAppDataFolder(WCHAR *wz, MSOADF adf);


/*---------------------------------------------------------------------------
	MsoFAddAppDataFolder

	If 'wz' is just a filename (determined by searching for a backslash),
	then prepend the app data folder specified by 'msoadf'.  Return fTrue if
	the folder is added, fFalse otherwise.  Do nothing and return fFalse
	if 'wz' is empty.
---------------------------------------------------------------- EricSchr -*/
MSOAPI_(BOOL) MsoFAddAppDataFolder(WCHAR *wz, MSOADF adf);


/*---------------------------------------------------------------------------
	MsoHrGetUserQueriesFolder

	Look in the registry for the Queries folder (can be set only by
	policy).  If not there, return the Queries folder from
	Application Data.  Return S_OK.
---------------------------------------------------------------- EricSchr -*/
MSOAPI_(HRESULT) MsoHrGetUserQueriesFolder(WCHAR *wz);


#ifdef LVP
// HwndForLVType is a callback function type to be implemented by the
// application.  If it is set, LV will call it to get an hwnd to parent
// off of instead of trying to figure it out.  If the function returns
// NULL, the LV code will not bring up the dialog but instead make
// the callback again later.
typedef HWND (CALLBACK *PfnHwndForLV)(void);
#endif	// LVP

// MSOLVP (MSO License Verification Property)
// Used with MsoSetLVProperty.
typedef enum
	{
	msolvpFirst, msolvpMin = msolvpFirst, msolvpMinLessOne = msolvpMin - 1,

	msolvpNoLV,		// Turns off License Verification, pv should be NULL.
	msolvpNoModal,	// Tells LV that can't go modal yet and when it can,
					// pv should be a BOOL.  Its primary purpose is to
					// prevent a modal dialog during OLE interactions.
					// Call with TRUE to disable any modal dialog, FALSE
					// to turn back on.  It is also used by the Gimme
					// layer (including Darwin dialogs).
	msolvpPfnHwnd,	// Passes to LV a callback function which it can
					// use to ask the app for a window to parent off
					// of. 'pv' should be a function of type PfnHwndForLV.

	msolvpMax, msolvpLast = msolvpMax - 1
	} MSOLVP;

/*---------------------------------------------------------------------------
	MsoSetLVProperty

	Use this function to set specific properties for License Verification to
	use.  See the MSOLVP declaration to determine what 'pv' should be.
---------------------------------------------------------------- EricSchr -*/
MSOAPI_(void) MsoSetLVProperty(MSOLVP lvp, void *pv);


#ifdef LVP
/*---------------------------------------------------------------------------
	MsoFDoLV

	For applications that don't participate in the component manager, they
	need a way to fire off the License Verification dialog.  This is a single
	API that they can call.  Note that a TRUE return value means that the
	application can run, while a FALSE return value means that the
	application needs to call again at a later time.  If the verification
	fails, there is no return value because the code will automatically
	exit.
---------------------------------------------------------------- EricSchr -*/
MSOAPIX_(BOOL) MsoFDoLV(void);
#endif	// LVP



/*---------------------------------------------------------------------------
	 MsoFixMeDlg
	
	 Bring up the Office FixMe dialog.
---------------------------------------------------------------- NancyDo -*/
MSOAPI_(HRESULT) MsoFixMeDlg(HMSOINST hinst, HWND hwndOwner);


/*---------------------------------------------------------------------------
	 MsoHrFixMe
	
	 Skip the Office FixMe dialog and just do the fixing, using the two
	 settings as indicated.
---------------------------------------------------------------- BrianHi -*/
MSOAPI_(HRESULT) MsoHrFixMe(BOOL fRestoreShortcuts, BOOL fResetSettings);



/****************************************************************************
	Office layer over Darwin (GimmeFile and friends).

	* DO NOT EVER CALL DARWIN DIRECTLY. ALWAYS GO THROUGH OFFICE. *
	All MsoGimme* APIs are provided for overall performance, extra resiliency,
	and for your convenience. Gimme(TM) is a trademark of KirkG.

	The structures below add up to a MSOTCFCF structure which you have
	to give to IMsoUser::FHookDarwinTables.

	This structure holds tables which describe to MsoFGimmeFile and
	associated APIs the structure of files, components, and features, as
	authored in Setup. From the app's point of view, instead of accessing
	files by name, you access them by fid (file id). Some files are
	known by Office and the id is built in (see msotcdar.h). Others used
	only by your app need to be hooked up to Office so that the Office
	code can apply the same resiliency rules as with its own files.

	The tcmsi.exe tool (in otools) takes as input files which describe the
	Setup database layout, and output two files:
	- a header, which lists fid's local to your app (and cid's for
		components, and ftid's for features).
	- a C file, which contains the MSOTCFCF structure for your app.

	Note that Office itself uses this tool to generate msotcdar.h (included
	below) and tcdar.inc (included in the bowels of Office code).

	Expect the internals of the MSOTCFCF structure to move around a lot
	as we figure out boot, string loading, etc.
****************************************************************************/


// this flag controls whether we build a single table with enums (1)
// or externs to individual structs per row (0)
#define MSOGIMME_INDEXIDS 1

typedef int msofidT;
typedef int msocidT;
typedef int msoftidT;

// must be in ssync with otcdarmake's output
#define msoidstcoGeneric 0

typedef enum
	{
	msotcidmin = 0,
	msofid = 0,
	msocid,
	msoftid,
	msoqcid,
	msoqfid,
	msotcidmax = msoqfid
	} MSOTCID;

typedef	enum { // default language
	msolangNone, 
	msolangInstall, 
	msolangUI, 
	msolangHelp,
	msolangInstallFlavor,
	msolangPreviousUI,
	msolangPreviousInstallFlavor
	} msolangT;

typedef struct _msotcfileinfo {
	CHAR *szFilename;		// filename
	msocidT cid;			// component ID
} MSOTCFILEINFO;

typedef struct _msotccomponentinfo {
	GUID msoguid;
	CHAR *szKeyFile;		// name of keyfile or static qualifier
	msoftidT ftid;			// feature ID, -1 if belongs to multiple features
	int idsInstall;			// string id, msoidstcoGeneric if none
	int idsRepair;			// TODO(JBelt): delete (otcdarmake, ssync with VB)
	unsigned langDefault : 2;
	unsigned fLcidQualified : 1;
	unsigned fFilenameQualified : 1;
	unsigned fOtherQualified : 1;
	unsigned fStaticQualified : 1;
} MSOTCCOMPONENTINFO;

typedef struct _msotcfeatureinfo {
	CHAR *szFtid;			// GUID
	msocidT qcid;			// publish component for cross-product features, -1 if none
	int idsInstall;			// string id, msoidstcoGeneric if none
	int idsRepair;			// TODO(JBelt): delete (otcdarmake, ssync with VB)
} MSOTCFEATUREINFO;

typedef struct _msotcclassinfo {
	CLSID clsid;	// GUID constant 
	DWORD dwClsCtx;	// Class Context
	msocidT cid;	// Feature ID;
} MSOTCCLASSINFO;

typedef struct _msotcbackdoorinfo {
	msocidT cid;
	void *pReserved;
	CHAR *szRelativePath;
	CHAR *szQualifier;
	CHAR *szAppData;
} MSOTCBACKDOORINFO;

#define MSOTCFILEINFO_NIL { "invalidFid", msocidNil }
#define MSOTCCOMPONENTINFO_NIL { {0,0,0,0}, "invalidCid", msoftidNil, -1 }
#define MSOTCFEATUREINFO_NIL { "invalidFtid", msoftidNil }
#define MSOTCCLASSINFO_NIL { {0,0,0,0}, 0, msocidNil }
#define MSOTCBACKDOORINFO_NIL { msocidNil, 0, "", "", "" }

typedef struct _msotcfcf {
	DWORD dwVersion;				// version
	int iTableIndex;
	const MSOTCFILEINFO *rgfi;		// file table
	const MSOTCCOMPONENTINFO *rgci;	// component table
	const MSOTCFEATUREINFO *rgfti;	// feature table
	const MSOTCBACKDOORINFO *rgbdi;	// backdoor data
	int cfi, cci, cfti, cbdi;		// counts
} MSOTCFCF;

/* Edit language info */
typedef struct _msoeli
	{
	UCHAR	fExplicit;
	LCID	lcid;
	}MSOELI;
	
// include file, component, and feature id's from Darwin
#include "msotcdar.h"

// Maximum length of a GUID string in the standard format,
// "{000Cxxxx-0000-0000-C000-000000000046}"
#define MAX_GUID 39


/*---------------------------------------------------------------------------
	dwGimmeFlags

	These flags specify options for the MsoFGimme*Ex functions below.
	Each functions always checks the install state of the object.
------------------------------------------------------------------ JJames -*/
#define msotcogfDemandInstall			0x0001	// install if not already
#define msotcogfSearchForFile			0x0002	// check file system if darwin fails
#define msotcogfTryOtherLanguages		0x0004	// try backup lcid's if requested one fails
#define msotcogfVerifyFileExists		0x0008	// verify that the requested file exists
#define msotcogfFixIfNecessary			0x0010	// call darwin fix functions if necessary
#define msotcogfForceFix				0x0020	// call darwin fix functions
#define msotcogfTrueIfAdvertised		0x0040	// return TRUE if the object is advertised
#define msotcogfForceFixMachineRegistry    0x0080	// force repair of user registry data
#define msotcogfNoInstallUI				0x0100	// no install confirmation UI (assume Yes)
#define msotcogfNoRepairUI				0x0200	// no repair confirmation UI (assume Yes)
#define msotcogfNoRetryUI				0x0400	// no retry on busy UI (assume Cancel)
#define msotcogfNoDisabledUI			0x0800	// no disabled feature UI (assume Ok)
#define msotcogfValidate				0x1000  // call MsiUseFeature instead of QueryFeature
#define msotcogfUninstall				0x2000  // change feature to advertised
#define msotcogfForceFixUserRegistry	0x4000  // force repair of machine registry data
#define msotcogfSearchFirst             0x8000  // check file system before querying Darwin (boot perf.)
#define msotcogfNoSourceDialog		   	0x10000  // suppress Darwin's source dialog
#define msotcogfNoCustomUI			   	0x20000  // Disable Office demandinstallUI dialog
#define msotcogfNoAutoApprove		   	0x40000  // Don't say "Yes" automatically
#define msotcogfNoAutoReject		   	0x80000  // Don't say "No" automatically
#define msotcogfForceUI				   0x100000  // Ignore the app callback
// reserved for Gimme internal     		0xF0000000

// preserve ForceFixRegistry option
#define msotcogfForceFixRegistry (msotcogfForceFixUserRegistry | msotcogfForceFixMachineRegistry)

#define msotcogfResiliency (msotcogfSearchForFile | msotcogfTryOtherLanguages)
	
// test whether the associated feature is enabled for install
#define msotcogfEnabled (msotcogfTrueIfAdvertised | msotcogfResiliency)

// test whether the file or component is already installed on the machine
#define msotcogfInstalled (msotcogfResiliency)
#define msotcogfInstalledNoResiliency (0)

// request the file or component, installing if necessary
#define msotcogfProvide (msotcogfDemandInstall | msotcogfResiliency)

// do whatever it takes to get the file or component
#define msotcogfRequired (msotcogfDemandInstall | msotcogfResiliency | msotcogfVerifyFileExists | msotcogfFixIfNecessary)
#define msotcogfRequiredNoResiliency (msotcogfDemandInstall | msotcogfVerifyFileExists | msotcogfFixIfNecessary)

// don't display any UI
// TODO(JBelt): merge all UI flags into one?
#define msotcogfQuiet (msotcogfNoInstallUI | msotcogfNoRepairUI | msotcogfNoRetryUI | msotcogfNoDisabledUI)

// don't automatically approve or deny an install or repair
#define msotcogfNoAutoReponse (msotcogfNoAutoApprove | msotcogfNoAutoReject)

/*---------------------------------------------------------------------------
	MsoFGimmeFeatureEx

	Perform an operation on a Darwin feature, as specified in
	%otools%\inc\misc\tcinuse.txt.  Will demand install, search, fix, check 
	advertisement, etc. according to options in dwGimmeFlags.

	Returns TRUE on success, which usually means the feature is installed and 
	enabled.  However, some flags affect this return.

	Use the Wz version only when absolutely necessary.
------------------------------------------------------------------ JJames -*/
MSOAPI_(BOOL) MsoFGimmeFeatureEx(msoftidT ftid, DWORD dwGimmeFlags);
MSOAPI_(BOOL) MsoFGimmeFeatureExWz(const WCHAR *wzFeature, DWORD dwGimmeFlags);

#define MsoFGimmeFeature(ftid) MsoFGimmeFeatureEx(ftid, msotcogfProvide)
#define _MsoFGimmeFeature(wzFeature) MsoFGimmeFeatureExWz(wzFeature, msotcogfProvide)
#define MsoFEnabledFeature(ftid) MsoFGimmeFeatureEx(ftid, msotcogfEnabled)
#define _MsoFEnabledFeature(wzFeature) MsoFGimmeFeatureExWz(wzFeature, msotcogfEnabled)
#define MsoFInstalledFeature(ftid) MsoFGimmeFeatureEx(ftid, msotcogfInstalled)
#define _MsoFInstalledFeature(wzFeature) MsoFGimmeFeatureExWz(wzFeature, msotcogfInstalled)
#define MsoFFixFeature(ftid) MsoFGimmeFeatureEx(ftid, msotcogfForceFix)

/*---------------------------------------------------------------------------
	MsoFGimmeComponentEx

	Returns a full pathname to the component keyfile specified by the component
	id with possible language and string qualification according to the cid 
	specification found in %otools%\inc\misc\tcinuse.txt.  Will demand install,
	search, fix, check advertisement, etc. according to options in dwGimmeFlags.

	Since components don't always have keyfiles (or they can be misauthored),
	you should generally use MsoFGimmeFileEx if you are relying on the pathname return.
	
	wzPath must be NULL or MAX_PATH characters in size.
	Returns TRUE on success, which usually means the component is installed and 
	enabled.  However, some flags affect this return.
------------------------------------------------------------------ JJames -*/
MSOAPI_(BOOL) MsoFGimmeComponentEx(msocidT cid, LCID lcid, const WCHAR *wzQualifier, WCHAR *wzPath, DWORD dwGimmeFlags);

#define MsoFGimmeComponent(cid, wzPath) MsoFGimmeComponentEx(cid, 0, NULL, wzPath, msotcogfProvide)
#define MsoFGimmeComponentQualified(cid, wzQualifier, wzPath) MsoFGimmeComponentEx(cid, 0, wzQualifier, wzPath, msotcogfProvide)
#define MsoFGimmeLocalizedComponent(cid, lcid, wzPath) MsoFGimmeComponentEx(cid, lcid, NULL, wzPath, msotcogfProvide)
#define MsoFFixLocalizedComponent(cid, lcid, wzPath) MsoFGimmeComponentEx(cid, lcid, NULL, wzPath, msotcogfForceFix)

/*---------------------------------------------------------------------------
	MsoFGimmeFileEx
	
	Returns a full pathname to the file specified by the file id with possible
	language and string qualification according to the fid specification found
	in %otools%\inc\misc\tcinuse.txt.  Will demand install,	search, fix, check 
	advertisement, etc. according to options in dwGimmeFlags.
	
	wzPath must be NULL or MAX_PATH characters in size.
	Returns TRUE on success, which usually means the file is installed and 
	enabled.  However, some flags affect this return.
------------------------------------------------------------------ JJames -*/
MSOAPI_(BOOL) MsoFGimmeFileEx(msofidT fid, LCID lcid, const WCHAR *wzQualifier, WCHAR *wzPath, DWORD dwGimmeFlags);

#define MsoFGimmeFile(fid, wzPath) MsoFGimmeFileEx(fid, 0, NULL, wzPath, msotcogfProvide)
#define MsoFGimmeFileQualified(fid, wzQualifier, wzPath) MsoFGimmeFileEx(fid, 0, wzQualifier, wzPath, msotcogfProvide)
#define MsoFGimmeLocalizedFile(fid, lcid, wzPath) MsoFGimmeFileEx(fid, lcid, NULL, wzPath, msotcogfProvide)
#define MsoFGimmeAdvertisedFile(qcid, wzFilename, wzPath, fDemandInstall) MsoFGimmeComponentEx(qcid, 0, wzFilename, wzPath, \
	(fDemandInstall) ? msotcogfProvide : msotcogfInstalled)
#define MsoFFixFile(fid, wzPath) MsoFGimmeFileEx(fid, 0, NULL, wzPath, msotcogfForceFix)
#define MsoFEnabledFile(fid) MsoFGimmeFileEx(fid, 0, NULL, NULL, msotcogfEnabled)
#define MsoFInstalledFile(fid) MsoFGimmeFileEx(fid, 0, NULL, NULL, msotcogfInstalled)

/*-----------------------------------------------------------------------------
	MsoFGimmeFileVersion

	In addition to grabbing file (modeled after MsoFGimmeFileFull), this checks 
	version of the file that we get and calls a more agressive repair if the
	version is less that the one expected.
  
	*** Inherited from MsoFGimmeFileFull ***
	Returns a full pathname to the file specified by the file id with possible
	language and string qualification according to the fid specification found
	in %otools%\inc\misc\tcinuse.txt.  Will demand install, search, fix, check 
	advertisement, etc. according to options in dwGimmeFlags.

	wzPath must be NULL or MAX_PATH characters in size.
	Returns the language used in *plcid.
	*** Inherited from MsoFGimmeFileFull ***

	Returns TRUE on success, which usually means the file is installed, enabled,
	and at least the version requested.  However, some flags affect this return.
  
---------------------------------------------------------------- RFlaming ---*/
MSOAPI_(BOOL) MsoFGimmeFileVersion(msofidT fid, LCID lcid, const WCHAR *wzQualifier,
	WCHAR *wzPath, DWORD dwGimmeFlags, DWORD dwTargetVersionMS, DWORD dwTargetVersionLS);


/*----------------------------------------------------------------------------
	MsoFGimmeComponentPathEx

	Thin wrapper around MsoFGimmeComponent, which strips out the keyfile if
	there is one.
-------------------------------------------------------------------- JBelt --*/
MSOAPI_(BOOL) MsoFGimmeComponentPathEx(msocidT cid, LCID lcid, const WCHAR *wzQualifier, WCHAR *wzPath, DWORD dwGimmeFlags);
#define MsoFGimmeComponentPath(cid, wzPath) MsoFGimmeComponentPathEx(cid, 0, NULL, wzPath, msotcogfProvide)


/*---------------------------------------------------------------------------
	MsoFEnumComponentQualifiers

	Enumerate the qualifiers advertised under this qcid.
	Begin with iIndex = 0 and increase until the function returns FALSE.
	String args except wzQualifier can be NULL.
	Non-NULL string args must be at least MAX_PATH characters long.
	Can pass qcid and wzQualifier to MsoFGimmeComponentQualified.
	Returns FALSE when there are no more to be had.
---------------------------------------------------------------- JJames -*/
MSOAPI_(BOOL) MsoFEnumComponentQualifiers(msocidT qcid, DWORD iIndex, WCHAR *wzQualifier, 
	WCHAR *wzAppData);


/*---------------------------------------------------------------------------
	MsoFEnumGraphicFilters

	Specialized graphic filter enumeration routine.

	Input:
	- qcid: qualified component to enumerate
	- piIndex: fill with 0 prior to initial call

	Output (all strings must be 256 chars, including terminator)
	- piIndex: incremented internally, do not modify
	- wzClass: class name
	- wzName: friendly display name
	- wzDarwinPath: Gimme token representing the path. Give this path to
		MsoFGimmeComponentQcidQualifierEx to get the real path, and possibly
		install on demand. This string is guaranteed to start with '{'.
	- wzExtensions: extensions, separated by spaces. No lowercase / uppercase
		assumptions can be made.
	- pgfo: bit field representing graphic filter options. Use msogfoxxx flags
		below. May be NULL.
-------------------------------------------------------------------- JBelt --*/
#define msogfoShowOptionsDialog  0x0001
#define msogfoShowProgressDialog 0x0002
MSOAPI_(BOOL) MsoFEnumGraphicFilters(msocidT qcid, int *piIndex,
	WCHAR *wzClass, WCHAR *wzName, WCHAR *wzDarwinPath, WCHAR *wzExtensions,
	DWORD *pgfo);


/*---------------------------------------------------------------------------
	MsoEnumComponentQualifiersEx

	Enumerate the qualifiers advertised under this qcid.
	lcid identifies a language for doubly qualified components and should
	be the same throughout a sequence of calls.	wzAppData can be null. 
	Begin with *pdwIterator = 0, the function will increment on success, 
	possibly by more than +1.

	Pass the lcid and wzQualifier to MsoFGimmeComponentQualifiedEx to
	retrieve the component.
---------------------------------------------------------------- JJames -*/
MSOAPI_(UINT) MsoEnumComponentQualifiersEx(
	msocidT qcid,         // gimme id
	LCID lcid,            // language id for double-qualified components, 0 if not
	WCHAR *wzQualifier,   // buffer for to receive qualifier
	DWORD *pcchQualifier, // pointer to size of buffer, receives resulting size
	WCHAR *wzAppData,     // buffer to receive application data (can be NULL)
	DWORD *pcchAppData,   // pointer to size of buffer, receives resulting size
	DWORD *pdwIterator);  // internally incremented iterator 

#if 0
MSOAPI_(UINT) MsoEnumComponentQualifiersExEx(
	msocidT qcid,         // gimme id
	LCID lcid,            // language id for double-qualified components, 0 if not
	WCHAR *wzQualifier,   // buffer for to receive qualifier
	DWORD *pcchQualifier, // pointer to size of buffer, receives resulting size
	WCHAR *wzAppData,     // buffer to receive application data (can be NULL)
	DWORD *pcchAppData,   // pointer to size of buffer, receives resulting size
	DWORD *pdwIterator,   // internally incremented iterator 
	DWORD fAnsiCPConversion);
#endif

/*---------------------------------------------------------------------------
	MsoFGimmeComponentQualifiedData

	Get the wzAppData field for this qualified component.
	Returns TRUE and sets wzAppData if the the qualifier was found.
------------------------------------------------------------------ JJames -*/
MSOAPI_(BOOL) MsoFGimmeComponentQualifiedData(msocidT qcid, const WCHAR *wzQualifier, WCHAR *wzAppData);

/*---------------------------------------------------------------------------
	MsoFGimmeAdvertisedName

	Returns the filename qualifier for a given pathname, verifying that the
	darwin entry for that qualifier is installed at that path.
	Reverse of MsoFGimmeAdvertisedFile.
	Returns TRUE if the path proved to be a darwin aware file.
------------------------------------------------------------------ JJames -*/
MSOAPIX_(BOOL) MsoFGimmeAdvertisedName(msocidT qcid, const WCHAR *wzPath, WCHAR *wzQualifier);

/*---------------------------------------------------------------------------
	MsoFGimmeProductCode

	Copies the 39 character product code into wzPath if true is returned
------------------------------------------------------------------ AndrewH -*/
MSOAPI_(BOOL) MsoFGimmeProductCode(WCHAR *wzPath);


/*-----------------------------------------------------------------------------
	MsoFGimmeOleServer

	Demand load a server based on an OLE object.
------------------------------------------------------------------ JJames ---*/
MSOAPI_(BOOL) MsoFGimmeOleServer(IOleObject *pOleObject, DWORD dwGimmeFlags);


/*----------------------------------------------------------------------------
	MsoFidToFilename

	Returns the filename corresponding to qcid. The filename can be NULL.
------------------------------------------------------------------ JJames --*/
MSOAPI_(VOID) MsoFidToFilename(msofidT fid, WCHAR *wzFilename);
MSOAPI_(VOID) MsoCidToFilename(msocidT cid, WCHAR *wzFilename);

#define MsoQfidToFilename MsoFidToFilename
#define MsoQcidToFilename MsoCidToFilename


/*----------------------------------------------------------------------------
	MsoFidToGuid

	Returns the GUID corresponding to the component the file belongs to.
	wzGuid must should be at least MAX_GUID characters long (39)
-------------------------------------------------------------------- JBelt --*/
MSOAPIX_(void) MsoFidToGuid(msofidT fid, WCHAR *wzGuid);

/*----------------------------------------------------------------------------
	MsoFindFid

	Returns the fid corresponding to a known filename.
	Returns msofidNil if not found.
	These should be used ONLY when filenames are given from outside sources.
------------------------------------------------------------------ JJames --*/
MSOAPIX_(msofidT) MsoFindFid(const WCHAR *wzFile);

#define MsoFindQfid MsoFindFid

/*----------------------------------------------------------------------------
	MsoFindFidInList

	Returns one of the fid's in the msofidNil terminated list according
	to equivalent filenames.  Returns msofidNil if not found.
	This should be used ONLY when filenames are given from outside sources.
------------------------------------------------------------------ JJames --*/
MSOAPI_(msofidT) MsoFindFidInList(const WCHAR *wzFile, msofidT *pfid);


/*----------------------------------------------------------------------------
	MsoFFirstRun

	Performs Office first run if necessary. Call this only if your app has
	already detected that *it* needs to do a first run. This saves one boot
	registry lookup. If this returns FALSE, you must refuse to boot.
------------------------------------------------------------------- JBelt --*/
MSOAPI_(BOOL) MsoFFirstRun(HMSOINST hinst);


/*----------------------------------------------------------------------------
	MsoFReinstallProduct

	Reinstall the product.
-------------------------------------------------------------------- KirkG --*/
MSOAPIX_(BOOL) MsoFReinstallProduct(void);

/*---------------------------------------------------------------------------
	MsoFGetUserInfo

	Returns name, company, and serial number (CD key). Each string must be at
	as long msocch[Username|UserInitials|Company|Serial]Max. Pass in NULL if
	not interested in a particular string.
------------------------------------------------------------------- JBelt -*/
MSOAPI_(BOOL) MsoFGetUserInfo(WCHAR *wzName, WCHAR *wzInitials,
	WCHAR *wzCompany, WCHAR *wzSerial);


// string size limits, not including null terminator
#define msocchUsernameMax		52
#define msocchUserInitialsMax	9
#define msocchCompanyMax		52
#define msocchSerialMax			23	// RPCNO-LOC-SERIALX-SEQNC

// for compatibility
#define cbCDUserNameMax 		msocchUsernameMax
#define cbCDOrgNameMax  		msocchCompanyMax
#define cbFormattedPID  		msocchSerialMax


/*---------------------------------------------------------------------------
	MsoLGetProductInfo

	An Office wrapper around MsiGetProductInfoW().
---------------------------------------------------------------- EricSchr -*/
MSOAPIX_(LONG) MsoLGetProductInfo(const WCHAR *wzProperty,
	WCHAR *wzValueBuf, DWORD *pcchValueBuf);


/*-----------------------------------------------------------------------------
	MsoLoadLocalizedLibraryFull

	LoadLibraryEx's the file fid and language plcid (if non NULL).

	If dwFlags is zero, does the equivalent of a simple LoadLibrary.

	If wzFullPath is non NULL, returns the path of the module loaded (max
	length MAX_PATH + null char).
------------------------------------------------------------------- JBelt ---*/
MSOAPI_(HMODULE) MsoLoadLocalizedLibraryFull(msofidT fid, LCID *plcid,
	const DWORD dwFlags, WCHAR *wzFullPath);


/*-----------------------------------------------------------------------------
	MsoLoadLocalizedLibraryEx

	Thin wrapper around MsoLoadLocalizedLibraryFull.
------------------------------------------------------------------- JBelt ---*/
MSOAPI_(HMODULE) MsoLoadLocalizedLibraryEx(msofidT fid, LCID lcid, DWORD dwFlags);

#define MsoLoadLibrary(fid) MsoLoadLocalizedLibraryEx(fid, 0, 0)
#define MsoLoadLibraryEx(fid, dwFlags) MsoLoadLocalizedLibraryEx(fid, 0, dwFlags)
#define MsoLoadLocalizedLibrary(fid, lcid) MsoLoadLocalizedLibraryEx(fid, lcid, 0)


/*----------------------------------------------------------------------------
	MsoWzEncodeQcidQualifier

	From a qcid and a qualifier, fills wzQC with {Qcid\Qualifier. This lets
	you store both inside a single string. wzQC must be at least 256
	characters long. Returns a pointer to the end of the string.
-------------------------------------------------------------------- JBelt --*/
MSOAPI_(WCHAR *) MsoWzEncodeQcidQualifier(msocidT qcid, WCHAR *wzQualifier, WCHAR *wzQC);


/*----------------------------------------------------------------------------
	MsoFGimmeComponentQcidQualifierEx

	Decodes the qcid and qualifier encoded in wzQC, and calls
	MsoFGimmeComponentQualifier on the results. wzPath must be at least
	MAX_PATH+1 characters long.
-------------------------------------------------------------------- JBelt --*/
MSOAPI_(BOOL) MsoFGimmeComponentQcidQualifierEx(WCHAR *wzQC, WCHAR *wzPath,
	DWORD dwGimmeFlags);

#define MsoFGimmeComponentQcidQualifier(wzQC, wzPath) MsoFGimmeComponentQcidQualifierEx(wzQC, wzPath, msotcogfProvide)


/*----------------------------------------------------------------------------
	MsoFGimmeComponentQcidQualifierDp

	Wrapper around MsoFGimmeComponentQcidQualifierEx, which also takes into
	account the dp variable passed in (see msotcodpxxx below). Used in loops,
	to carry the user choice to the first Gimme prompt through all subsequent
	prompts.
-------------------------------------------------------------------- JBelt --*/
MSOAPI_(BOOL) MsoFGimmeComponentQcidQualifierDp(WCHAR *wzQC, WCHAR *wzPath,
	int *pdp);

#define msotcodpNotAsked    0
#define msotcodpInstall     1
#define msotcodpDontInstall 2


/*-----------------------------------------------------------------------------
	MsoForgetLastGimme

	The Gimme API automatically approves or rejects subsequent calls
	within 10 seconds and before the event monitor picks up a user action.
	Successful installs turn on automatic approval, failures and user-cancels
	turn on automatic rejection.  This function resets that memory and should
	be used in cases where events don't get to the monitor.
------------------------------------------------------------------ JJames ---*/
MSOAPI_(void) MsoForgetLastGimme(void);


/*----------------------------------------------------------------------------
	MsoFFormatMessage

	Formats an appropriate error message for the last Gimme error.
	Returns FALSE if unknown.
	NOT REALLY USED.
------------------------------------------------------------------ JJames --*/
MSOAPI_(BOOL) MsoFFormatMessage(DWORD dwError, WCHAR *wzMessage);


/*------------------------------------------------------------------------
	MsoLaunchFid

	Given a FID for a file that represents a setup-installed EXE,
	ShellExec it and return the hinstance.  Pases arguments specified
	in character string, if any (may be NULL)
---------------------------------------------------------------- MikeKell -*/
MSOAPI_(HINSTANCE) MsoLaunchFid(msofidT fid, const WCHAR *wzArguments, int sw);


/*------------------------------------------------------------------------
	MsoFLaunchMsInfo

	Launches MSInfo.  Does some extra checking like bringing it forward
	if if is already there.  wzArguments should contain the name of the
	application invoking MSInfo.
---------------------------------------------------------------- MikeKell -*/
MSOAPI_(BOOL) MsoFLaunchMsInfo(const WCHAR *wzArguments);


/*----------------------------------------------------------------------------
	MsoFEnsureUserData

	If the registry referenced by rid than 1, ensures the user data in ftid
	is on the machine, then writes 1 in the registry. Call this after initing
	ORAPI, but before reading anything, to make sure Setup-time user data has
	been written for this particular user.
-------------------------------------------------------------------- JBelt --*/
MSOAPI_(BOOL) MsoFEnsureUserData(int rid, msoftidT ftid);


/*----------------------------------------------------------------------------
	MsoFEnsureTypelib

	1) Detect Mso Typelib key existence: 
	[HKEY_CLASSES_ROOT\TypeLib\{2DF8D04C-5BFA-101B-BDE5-00AA0044DE52}\2.2\0\win32]
    2) call Darwin to repair the feature that contains the typelib (ProductFiles)
	Note: Call this after initing ORAPI and Gimme. 
---------------------------------------------------------------- (EricLam) --*/
MSOAPI_(BOOL) MsoFEnsureMsoTypelib();


/*----------------------------------------------------------------------------
	MsoFInGimme

	Returns TRUE if we're currently stuck in a potentially long Darwin call.
	Be patient if you get called in a message filter and this returns TRUE.
	Fix Office 9 24103.
-------------------------------------------------------------------- JBelt --*/
MSOAPI_(BOOL) MsoFInGimme();


/*----------------------------------------------------------------------------
	MsoDwGetGimmeTableVersion

	Returns the version number of the passed-in Gimme table.
-------------------------------------------------------------------- JBelt --*/
MSOAPIX_(DWORD) MsoDwGetGimmeTableVersion(MSOTCFCF *pfcf);


/*------------------------------------------------------------------------
	MsoFIsOLEAwareDarwin

	Returns TRUE if OS recognizes Darwin descriptors in the OLE registry.
---------------------------------------------------------------- WesYang -*/
MSOAPIX_(BOOL) MsoFIsOLEAwareDarwin ();


/*------------------------------------------------------------------------
	Obsolete Gimme wrapper to the standard OLE calls
---------------------------------------------------------------- JJames -*/

#define MsoFGimmeCoCreateInstance(rclsid,pUnkOuter,dwClsContext,riid,ppv) \
		         CoCreateInstance(rclsid,pUnkOuter,dwClsContext,riid,ppv)
#define MsoFGimmeCoGetClassObject(rclsid,dwClsContext,pServerInfo,riid,ppv) \
		         CoGetClassObject(rclsid,dwClsContext,pServerInfo,riid,ppv)
#define MsoHrCoCreateInstance(rclsid,pUnkOuter,dwClsContext,riid,ppv) \
		     CoCreateInstance(rclsid,pUnkOuter,dwClsContext,riid,ppv)
#define MsoHrCoGetClassObject(rclsid,dwClsContext,pServerInfo,riid,ppv) \
		     CoGetClassObject(rclsid,dwClsContext,pServerInfo,riid,ppv)
#define MsoHrOleCreate(rclsid,rrid,renderopt,pFormatEtc,pClientSite,pStg,ppvObject) \
		     OleCreate(rclsid,rrid,renderopt,pFormatEtc,pClientSite,pStg,ppvObject)
#define MsoHrOleCreateLink(pmkLinkSrc,rrid,renderopt,pFormatEtc,pClientSite,pStg,ppvObj) \
		     OleCreateLink(pmkLinkSrc,rrid,renderopt,pFormatEtc,pClientSite,pStg,ppvObj)
#define MsoHrOleCreateFromFile(rclsid,lpszFileName,rrid,renderopt,pFormatEtc,pClientSite,pStg,ppvObject) \
		     OleCreateFromFile(rclsid,lpszFileName,rrid,renderopt,pFormatEtc,pClientSite,pStg,ppvObject)
#define MsoHrOleCreateLinkToFile(lpszFileName,rrid,renderopt,pFormatEtc,pClientSite,pStg,ppvObject) \
		     OleCreateLinkToFile(lpszFileName,rrid,renderopt,pFormatEtc,pClientSite,pStg,ppvObject)
#define MsoHrOleCreateFromData(pSrcDataObj,rrid,renderopt,pFormatEtc,pClientSite,pStg,ppvObject) \
		     OleCreateFromData(pSrcDataObj,rrid,renderopt,pFormatEtc,pClientSite,pStg,ppvObject)
#define MsoHrOleCreateStaticFromData(pSrcDataObj,rrid,renderopt,pFormatEtc,pClientSite,pStg,ppvObject) \
		     OleCreateStaticFromData(pSrcDataObj,rrid,renderopt,pFormatEtc,pClientSite,pStg,ppvObject)
#define MsoHrOleCreateLinkFromData(pSrcDataObj,rrid,renderopt,pFormatEtc,pClientSite,pStg,ppvObject) \
		     OleCreateLinkFromData(pSrcDataObj,rrid,renderopt,pFormatEtc,pClientSite,pStg,ppvObject)
#define MsoHrOleLoad(pStg,riid,pClientSite,ppvObj) \
		     OleLoad(pStg,riid,pClientSite,ppvObj)
#define MsoHrOleLoadFromStream(pStm,iidInterface,ppvObj) \
		     OleLoadFromStream(pStm,iidInterface,ppvObj)

                            
/*---------------------------------------------------------------------------
	IMsoGimmeUser callback for Gimme clients.
------------------------------------------------------------------- JBelt -*/

#undef  INTERFACE
#define INTERFACE  IMsoGimmeUser

#define	cchMaxMsoGimmeUserFGetString	300	// maximum length of returned string
											// from IMsoGimmeUser::FGetString
#define GIMMEUSER_INSTALL	0x01	// ok to install
#define GIMMEUSER_GIMMEUI	0x02	// ok to display Gimme UI (install prompt, etc)
#define GIMMEUSER_DARWINUI	0x04	// ok to display Darwin UI
#define GIMMEUSER_DEFAULT   (GIMMEUSER_INSTALL | GIMMEUSER_GIMMEUI | GIMMEUSER_DARWINUI)

DECLARE_INTERFACE(IMsoGimmeUser)
{

	/* Debugging interface for this interface */
	MSODEBUGMETHOD

	/* If Darwin is on the machine, but your app doesn't have a product code,
		Office will look for a MSI to install on the fly, and call you.
		If you return FALSE, Office immediately gives up looking for a MSI.
		If you return TRUE, Office will look for the MSI.
		- If you set *pfPattern to TRUE, wtzPattern is assumed to be a file
			pattern (with wildcards). If you set *pfPattern to FALSE, wtzPattern
			is assumed to be a fully qualified path to the file, and is
			used as is.
		- Office prefills wtzPattern with a suggested search pattern, and
			pfPattern with TRUE. */
	MSOMETHOD_(BOOL, FSearchMSI) (THIS_ WCHAR *wtzPattern, BOOL *pfPattern) PURE;

	/* Gimme is ready to demand install something. Return a combination of
		GIMMEUSER_xxx flags declared above, or GIMMEUSER_DEFAULT. */
	MSOMETHOD_(DWORD, DwInstallBehavior) (THIS) PURE;

	/* The Gimme layer needs the string corresponding to the string identifier
		corresponding to an id you have specified in your tcinuse.txt. Fill
		wtz with the string and return TRUE; return FALSE if unable to fill
		the string, and Gimme will default to a generic string.  Note the
		buffer is a wtz, i.e. the first entry is the length of the string,
		not including the terminating null.  The size of the buffer is
		cchMaxMsoGimmeUserFGetString.  */
	MSOMETHOD_(BOOL, FGetString) (THIS_ int ids, WCHAR *wtz) PURE;

	/* Return the directory in which most of your files live (your main, or bin,
		directory), and TRUE. The Gimme layer uses this directory for search for
		files for dev override (oprep machines), and resiliency (if Darwin is
		dead, there's a MSI mismatch, etc). Office prefills wtzDir with the
		directory where the EXE which launched the process lives. wtzDir is
		MAX_PATH+1 long. Returning FALSE turns off override / resiliency.
		Hint: use MsoGetModuleFilenameW to get your main DLL / EXE path. */
	MSOMETHOD_(BOOL, FGetRootDirectory) (THIS_ WCHAR *wtzDir) PURE;
};

/*----------------------------------------------------------------------------
	MsoDwGimmeUserInstallBehavior

	This code generates the behavior flags needed for DarwinOK
------------------------------------------------------------------- ARSHADA --*/
MSOAPI_(DWORD) MsoDwGimmeUserInstallBehavior(WORD FeatureInstall, BOOL fDisplayAlerts);

// OBSOLETE, DO NOT CALL. Use MsoDwGimmeUserInstallBehavior instead
// TODO(JBelt): delete, ssync with VB
MSOAPIX_(BOOL) MsoFGimmeUserInstallBehavior(WORD FeatureInstall, BOOL fDisplayAlerts, WORD *pwFlag);


/*---------------------------------------------------------------------------
	MsoInitGimme

	Hook up your own Gimme tables, if you have any. If you don't, you don't
	need to call this API.
	
	cidCore is a Gimme component ID to your core component.  It must be given.
	pGimmeTables is build by otcdarmake.exe as "vfcf" and can be NULL.
	If your cid is not in the Office tables, then you must build your own
	using otcdarmake.exe from a version of %otools%\inc\misc\tcinuse.txt.
	See http://officedev/tco/gimmehelp.htm for details.

	See IMsoGimmeUser above for description of pigu. You must implement this
	interface, or some Darwin features will be disabled.
------------------------------------------------------------------- JBelt -*/
MSOAPI_(void) MsoInitGimmeEx(msocidT cidCore, MSOTCFCF *pGimmeTables,
		IMsoGimmeUser *pigu, msocidT cidFull, DWORD dwUnused);
MSOAPI_(void) MsoInitGimme(msocidT cidCore, MSOTCFCF *pGimmeTables,
	IMsoGimmeUser *pigu);


// 
// This enum list which is used for the MsoGimmePublishComponentString() API
// below is to be mapped with the %OTOOLS%\inc\misc\msistr.pp list of
// string identifiers.  This list is on a "fill in as you go" basis if 
// other clients wish to access certain strings of the MSI string table.
enum {
	msiIndexDesignTemplates = 4, // msiidsDesignTemplates
};

MSOAPI_(void) MsoGimmePublishComponentString(DWORD dwIndex, LPWSTR pwzBuffer, DWORD *pcchBuffer);

/****************************************************************************
 World-Wide Exe
****************************************************************************/

/*----------------------------------------------------------------------------
	MsoInitPluggableUI

	Init and cache the language settings used by pluggable UI
------------------------------------------------------------------- ZIYIW --*/
MSOAPI_(BOOL) MsoInitPluggableUI(void);

/*-----------------------------------------------------------------------------
	MsoSetupFontLink

	Setup the global Fontlink switch : vfDoFontLink
--------------------------------------------------------------------- ZIYIW -*/
MSOAPIX_(void) MsoSetupFontLink(LCID lcidUINew);

#ifdef FUTURE
/*-----------------------------------------------------------------------------
	MsoMarkFontForInstall

	Marks specified font for demand installation upon next boot. 
------------------------------------------------------------------- NobuyaH -*/
MSOAPIX_(VOID) MsoMarkFontForInstall(WCHAR *wzFont);

/*-----------------------------------------------------------------------------
	MsoCommitFontForInstall

	Commits marked fonts for demand installation into registry so they will be
	demand installed upon next boot.
------------------------------------------------------------------- NobuyaH -*/
MSOAPIX_(VOID) MsoCommitFontForInstall();
#endif // FUTURE

/*----------------------------------------------------------------------------
	MsoAnsiCodePageLimited

	Declare that your application is code page limited.
	Must be called before MsoInitPluggableUI.
------------------------------------------------------------------- ZIYIW --*/
MSOAPI_(VOID) MsoAnsiCodePageLimited(BOOL fLimited);

/*----------------------------------------------------------------------------
	MsoFAnsiCodePageSupportsLCID

	Test whether the code page supports the lcid for an ANSI application.
	Typically, cp = GetACP().
------------------------------------------------------------------- ZIYIW --*/
MSOAPI_(BOOL) MsoFAnsiCodePageSupportsLCID(UINT cp, LCID lcid);


/*----------------------------------------------------------------------------
	MsoFValidLocale

	Test whether this lcid is valid on this machine.
------------------------------------------------------------------- JJames --*/
MSOAPI_(BOOL) MsoFValidLocale(LCID lcid);

#define ILS_NOTCHANGED				0
#define ILS_CHANGED_NOT_PROCESSED	1
#define ILS_CHANGED_PROCESSED		2
#define ILS_CHANGED_PROCESSING		3

#define APPID_WORD					0
#define APPID_XL					1
#define APPID_PPT					2
#define APPID_ACCESS				3
#define APPID_OUTLOOK				4
#define APPID_FRONTPAGE				5
#define APPID_PUBLISHER				6
#define APPID_PROJECT				7
#define APPID_DESIGNER				8
/*----------------------------------------------------------------------------
	MsoAppSetChangeInstallLanguageState
	MsoAppGetChangeInstallLanguageState

	Get/Set Application based install language change state.
------------------------------------------------------------------- ZIYIW --*/
MSOAPI_(int) MsoAppSetChangeInstallLanguageState(int idApp, int ils);
MSOAPI_(int) MsoAppGetChangeInstallLanguageState(int idApp);

/*----------------------------------------------------------------------------
	MsoGetInstallLcid

	return the cached office install lcid
------------------------------------------------------------------- ZIYIW --*/
MSOAPI_(LCID) MsoGetInstallLcid(void);

/*----------------------------------------------------------------------------
	MsoGetInstallLcid

	return the cached office install lcid
------------------------------------------------------------------- ZIYIW --*/
MSOAPI_(LCID) MsoGetInstallLcid2000Compatible(void);

/*-----------------------------------------------------------------------------
	MsoGetInstallFlavor

	return the cached office install flavor lcid
--------------------------------------------------------------------- ZIYIW -*/
MSOAPI_(LCID) MsoGetInstallFlavor(void);

/*-----------------------------------------------------------------------------
	MsoFLangChanged

	return a flag whether or not the UI lang has been changed since last time
--------------------------------------------------------------------- ZIYIW -*/
MSOAPIX_(int) MsoFLangChanged(LCID *plcid);

/*-----------------------------------------------------------------------------
	MsoGetPreviousUILcid 
	
	return the cached previous ui lcid
--------------------------------------------------------------------- ZIYIW -*/
MSOAPIX_(LCID) MsoGetPreviousUILcid(void);

/*-----------------------------------------------------------------------------
	MsoGetPreviousInstallFlavor 
	
	return the cached previous install flavor
--------------------------------------------------------------------- ZIYIW -*/
MSOAPI_(LCID) MsoGetPreviousInstallFlavor(void);

/*----------------------------------------------------------------------------
	MsoGetUILcid

	return the cached office UI lcid
------------------------------------------------------------------- ZIYIW --*/
MSOAPI_(LCID) MsoGetUILcid(void);

/*----------------------------------------------------------------------------
	MsoGetHelpLcid

	return the cached office Help lcid
------------------------------------------------------------------- ZIYIW --*/
MSOAPI_(LCID) MsoGetHelpLcid(void);

/*-----------------------------------------------------------------------------
	MsoGetExeModeLcid
	
	return the cached ExeMode lcid
-------------------------------------------------------------------- IrfanGo -*/
MSOAPI_(LCID) MsoGetExeModeLcid(void);

/*----------------------------------------------------------------------------
	MsoGetSKULcid

	return the cached office installed SKU lcid
------------------------------------------------------------------- ZIYIW --*/
MSOAPI_(LCID) MsoGetSKULcid(void);

/*-----------------------------------------------------------------------------
	MsoGetWebLocale -  return the cached weblocale lcid
-------------------------------------------------------------------- ZIYIW -*/
MSOAPI_(LCID) MsoGetWebLocale(void);

/*----------------------------------------------------------------------------
	MsoEnumEditLcid

	enumerate throught the cached office edit lcids
------------------------------------------------------------------- ZIYIW --*/
MSOAPI_(BOOL) MsoEnumEditLcid(LCID*, int);

/*----------------------------------------------------------------------------
	MsoFAddRemoveEditLcidFromReg

	Turn On/Off a edit langauge in reg
	You generally want to avoid the Ex version
------------------------------------------------------------------- ZIYIW --*/
MSOAPI_(int) MsoFAddRemoveEditLcidFromReg(LCID lcid, int fAdd, int fExplicit);
MSOAPI_(int) MsoFAddRemoveEditLcidFromRegEx(LCID lcid, int fAdd, int fExplicit, int fOverride);

// Return a best-guess LCID for the current keyboard and the optional character
MSOAPI_(LCID) MsoLcidKeyboard(
	HMSOINST			hinst,
	LCID				lcidFEDefault,
	WCHAR               *pwch,                           // Optional, or NULL
	int                  cch
	);

/*----------------------------------------------------------------------------
	MsoLcidGetLanguages

	read various language settings from the registry throught ORAPI
----------------------------------------------------------- ZIYIW/irfango --*/
BOOL MsoLcidGetLanguages(LCID*, LCID*, LCID*, MSOELI*, int*, MSOELI*, int*, LCID*);

/*-----------------------------------------------------------------------------
	MsoPropagateInstallFlavor

	Setup InstallFlavor reg setting for ENG/FRN/GER SKU
--------------------------------------------------------------------- ZIYIW -*/
void MsoPropagateInstallFlavor(LCID lcidInstall);

/*-----------------------------------------------------------------------------
	MsoHrCreateLanguageSettingsObject

	creates a new instance of the LanguageSettings OLE object
--------------------------------------------------------------------- ZIYIW -*/
MSOAPI_(int) MsoHrCreateLanguageSettingsObject(HMSOINST hmsoinst, void **pplss);

/*-----------------------------------------------------------------------------
	MsoDialogFontNameLid

	get the Localized/EUC dialog font name based on UI lid passed in. 
--------------------------------------------------------------------- ZIYIW -*/
MSOAPI_(void) MsoDialogFontNameLid(WCHAR *wzName, LCID lid);

/*-----------------------------------------------------------------------------
	MsoDialogFontJpnAlt

	get the Localied/EUC alternate dialog font name for JPN.
------------------------------------------------------------------- NobuyaH -*/
MSOAPI_(void) MsoDialogFontJpnAlt(WCHAR *wzName);


/*-----------------------------------------------------------------------------
	MsoSetPureReg/MsoGetPureReg

	Operations on the Pure language resource registry
--------------------------------------------------------------------- ZIYIW -*/
#define REG_PURE_UNKNOWN		0
#define REG_PURE_OFF			1
#define REG_PURE_COMPLETED		2
#define REG_PURE_PROHIBITED		3
#define REG_PURE_ON             REG_PURE_PROHIBITED

MSOAPIX_(int) MsoSetPureReg(int iState);
MSOAPI_(int) MsoGetPureReg(void);

/****************************************************************************
 Migration
****************************************************************************/

enum
{
	msoFirstApp  = 0,
	msoWord      = 0,
	msoExcel     = 1,
	msoAccess    = 2,
	msoPPT       = 3,
	msoOffice    = 4,
	msoGraph     = 5,
	msoOutlook   = 6,
	msoFrontPage = 7,
	msoPublisher = 8,
	msoProject   = 9,
	msoVisio     = 10,
	msoDesigner  = 11,
	msoOSA		 = 12,
	msoLastApp   = msoOSA
};

#define msoNoCmwPopulate 0x80000000

enum
{
	msoOfficeCurrentVersion = 0,
	msoOffice10Version      = 0,
	msoOffice9Version       = 1,
	msoOffice97Version      = 2
};

enum
{
	msoNoMigration		= 0,
	msoOfficeVersion6	= 6,
	msoOfficeVersion7	= 7,
	msoOfficeVersion8	= 8,
	msoOfficeVersion9	= 9
};

MSOAPI_(BOOL) MsoMigrate(int iApp, DWORD *pdwMigrationVersion);


/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
	The New New New  O R A P I   A P I s
- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */

#include "msoreg.h"


/*-----------------------------------------------------------------------------
	ORAPI Cache data
--------------------------------------------------------------------dgray----*/
typedef struct KEYNODE_S {
	HKEY	hKey;                   // handle to the key
	int		keyID;                  // enum ID number for this key
	union
		{
		int		Options;            // ORAPICacheOptionFlags
		struct
			{
			BOOL fPersist  : 1;
			BOOL fRWAccess : 1;
			BOOL fIsPolicy : 1;
			BOOL fIsApp    : 1;
			BOOL fIsValid  : 1;
			// if the ref count is changed, make sure 
			// ORAPI_MAX_REF_COUNT in tcorapi.cpp matches
			int nRefCount  : 3;
			// TODO DGray : Pad this to 32 bits
			// int pad        : 24;
			};
		};
#ifdef VSMSODEBUG
	CHAR	szKeyName[MAX_PATH];  // Name of the key
	int		nTimesUsed;           // Number of times this key has been hit
#endif // VSMSODEBUG
	struct KEYNODE_S* pNext;      // The next keyID in the cache
	struct KEYNODE_S* pPrev;      // The next keyID in the cache
} KEYNODE;


/*

 PERSIST    - When set, Do not remove this key from the cache
 RW_ACCESS  - When set, key opened with READ/WRITE access, otherwise just read
 IS_POLICY  - Set, this key exists in the policy tree, otherwise user tree
 IS_APP_KEY - Set, this key is from the APP, otherwise from MSO
 KEY_VALID  - The hkey attached to this node is valid

*/
enum ORAPICacheOptionFlags
{
	PERSIST			= 0x01,
	RW_ACCESS		= 0x02,
	IS_POLICY		= 0x04,
	IS_APP_KEY		= 0x08,
	KEY_VALID		= 0x10,

	MASK_PERSIST	= 0xFFFFFFFE,
	MASK_RW			= 0xFFFFFFFD,
	MASK_POLICY		= 0xFFFFFFFB,
	MASK_APP		= 0xFFFFFFF7,
};



/*-----------------------------------------------------------------------------
	MsoFOrapiPrimeKeyCache

	Prime a root of the registry tree in the cache
	Used only in the init
--------------------------------------------------------------------dgray----*/
MSOAPI_(BOOL) MsoFOrapiPrimeKeyCache(int keyID, int Options, HKEY hKey,
                                     BOOL fHoldRef, KEYNODE** ppkn, PCSTR sz);
//#ifdef VSMSODEBUG
//MSOAPI_(BOOL) MsoFOrapiPrimeKeyCache(int keyID, int Options, HKEY hKey,
//                                     BOOL fHoldRef, KEYNODE** ppkn,
//                                     PCSTR sz);
//#else  // ! DEBUG
//#define MsoFOrapiPrimeKeyCache(keyID,Options,hKey,fHoldRef,ppkn,sz) \
//        MsoFOrapiPrimeKeyCache(keyID,Options,hKey,fHoldRef,ppkn)
//MSOAPI_(BOOL) MsoFOrapiPrimeKeyCache(int keyID, int Options, HKEY hKey,
//                                     BOOL fHoldRef, KEYNODE** ppkn);
//#endif // ! VSMSODEBUG


/*-----------------------------------------------------------------------------
	ORAPI App init routines
--------------------------------------------------------------------dgray----*/

/*-----------------------------------------------------------------------------
   MsoFRegHookAppTables

   Hooks the application data tables into ORAPI.  Needs to be called before 
   any ORAPI calls are made by an application.
   Returns TRUE if policy is in effect, FALSE if no policy.
--------------------------------------------------------------------dgray----*/
MSOAPI_(BOOL) MsoFRegHookAppTables(const void* pAppReg, const void* pAppOrkey,
                                   int cNumRegs, int cNumKeys);



/*-----------------------------------------------------------------------------
	These ORAPI functions are used to get a handle to a HKEY.  This should 
	only be used when you are using orapi to open the key, and then you are
	using the HKEY to do something ORAPI doesn't handle, such as enumeration.

	ALWAYS close the key through ORAPI with MsoRegCloseKeyHkey().

--------------------------------------------------------------------dgray----*/
MSOAPI_(LONG) MsoRegOpenKey(int msorid, PHKEY phkResult);
MSOAPI_(LONG) MsoRegOpenKeyEx (int msorid, REGSAM samDesired, PHKEY phkResult);
MSOAPI_(LONG) MsoRegCreateKeyEx(int msorid, PHKEY phkResult,
                                LPDWORD lpdwDisposition);
MSOAPI_(LONG) MsoRegCreateKey(int msorid, PHKEY phkResult);



/*-----------------------------------------------------------------------------
   MsoRegDeleteValue

   This function deletes a value from the registry.
--------------------------------------------------------------------dgray----*/
MSOAPI_(LONG) MsoRegDeleteValue(int msorid);



/*-----------------------------------------------------------------------------
   MsoRegDeleteKey

   This function deletes a registry key from the users registry tree.
   It also clears the value in the cache if there is one.

--------------------------------------------------------------------dgray----*/
MSOAPI_(LONG) MsoRegDeleteKey(int msorid);



/*-----------------------------------------------------------------------------
	MsoCbRegGetBufferSize*

	Use these functions to mimic the win32 RegQueryValueEx() call to get
	buffer size.  RegQueryValueEx(phkey, pValueName, NULL, NULL, NULL, &Size);
	Use the function suited to the type accessed.
	
  MsoCbRegGetBufferSizeCore
  MsoCbRegGetBufferSizeDefaultCore
    Don't use these.  Other funcions wrap or #define to them.

  MsoCbRegGetBufferSizeSz
    Use this function to query for the size you need to allocate in order
    to query for a REG_SZ in ansi space.  Returns the size in bytes.

  MsoCbRegGetBufferSizeDefaultSz
    Use this function to query for the size you need to allocate in order
    to query for the default value of a REG_SZ in ansi space.  
    Returns the size in bytes.

  MsoCbRegGetBufferSizeWz
    Use this function to query for the size you need to allocate in order
    to query for a REG_SZ in unicode space.  Returns the size in bytes.

  MsoCbRegGetBufferSizeDefaultWz
    Use this function to query for the size you need to allocate in order
    to query for the default value of a REG_SZ in unicode space.  
    Returns the size in bytes.

  MsoCbRegGetBufferSizeBinary
    Use this function to query for the size you need to allocate in order
    to query for a REG_BINARY value data.  Returns size in bytes.
--------------------------------------------------------------------dgray----*/
MSOAPI_(DWORD) MsoCbRegGetBufferSizeCore(int msorid);
MSOAPIX_(DWORD) MsoCbRegGetBufferSizeDefaultCore(int msorid);
MSOAPI_(DWORD) MsoCbRegGetBufferSizeSz(int msorid);
MSOAPIX_(DWORD) MsoCbRegGetBufferSizeDefaultSz(int msorid);
MSOAPI_(DWORD) MsoCbRegGetBufferSizeWz(int msorid);
MSOAPIX_(DWORD) MsoCbRegGetBufferSizeDefaultWz(int msorid);
#ifdef VSMSODEBUG
MSOAPI_(DWORD) MsoCbRegGetBufferSizeBinary(int msorid);
#else  // ! DEBUG
#define MsoCbRegGetBufferSizeBinary(msorid) MsoCbRegGetBufferSizeCore(msorid)
#endif // ! VSMSODEBUG



/*-----------------------------------------------------------------------------
   MsoRegForceWriteDefaultValue

   DO NOT USE THIS FUNCTION!  It is not safe for general consumption.  This
   should only be used by JJames.  See the comments in tcorapi.cpp
--------------------------------------------------------------------dgray----*/
MSOAPIX_(LONG) MsoRegForceWriteDefaultValue(int msorid);



/*-----------------------------------------------------------------------------
	MsoFRegGetDw

	Gets the REG_DWORD value for this msorid and puts it in *pdwData.
	MsoFRegGetDw
		Returns TRUE if succeeded, FALSE if failed.  Assert if default value
		is not NO_DEFAULT
--------------------------------------------------------------------dgray----*/
MSOAPI_(BOOL)  MsoFRegGetDwCore(int msorid, DWORD* pdwData);
#ifdef VSMSODEBUG
MSOAPI_(BOOL)  MsoFRegGetDw(int msorid, DWORD* pdwData);
#else  // ! DEBUG
#define MsoFRegGetDw(msorid, pdwData) MsoFRegGetDwCore(msorid, pdwData)
#endif // ! VSMSODEBUG



/*-----------------------------------------------------------------------------
	MsoDwRegGetDw

	Returns the REG_DWORD value for this msorid.
	Does not check for failure, which is fine if default values are defined.
--------------------------------------------------------------------dgray----*/
MSOAPI_(DWORD) MsoDwRegGetDw(int msorid);



/*-----------------------------------------------------------------------------
	These should be used in only select cases!  These functions should be
	used only in cases where we know that a DWORD may be written out as a
	REG_BINARY type.  In general, we will accept a REG_BINARY if it is the 
	correct size, but we will assert if the type does not match.  These
	functions turn that assert off and back on.  Use like so:
		MsoRegDwTypeMatchAssertOff();
		dw = MsoDwRegGetDw(msoridFoo);
		MsoRegDwTypeMatchAssertOn();

	ALWAYS CALL THIS IN PAIRS SO THE ASSERT GETS RE-ENABLED!
--------------------------------------------------------------------dgray----*/
#ifdef VSMSODEBUG
MSOAPI_(void) MsoRegDwTypeMatchAssertOff();
MSOAPI_(void) MsoRegDwTypeMatchAssertOn();
#else  // ! DEBUG
#define MsoRegDwTypeMatchAssertOff()
#define MsoRegDwTypeMatchAssertOn()
#endif // ! VSMSODEBUG



/*-----------------------------------------------------------------------------
	These should be used in only select cases!  These functions should be
	used when we're calling MsoFRegGetDw, but the rid may have Orapi
	default-value-data.  In general, MsoFRegGetDw will assert if the rid has 
	def-value-data, since the code could call MsoDwRegGetDw instead (guaranteed 
	not to fail). 
	These functions turn that assert off and back on.  Use like so:
		MsoRegDefValAssertOff();
		if (MsoFDwRegGetDw(msoridFoo)) blah;
		MsoRegDefValAssertOn();

	ALWAYS CALL THIS IN PAIRS SO THE ASSERT GETS RE-ENABLED!
--------------------------------------------------------------------dgray----*/
#ifdef VSMSODEBUG
MSOAPI_(void) MsoRegDefValAssertOff();
MSOAPI_(void) MsoRegDefValAssertOn();
#else  // ! DEBUG
#define MsoRegDefValAssertOff()
#define MsoRegDefValAssertOn()
#endif // ! VSMSODEBUG



/*-----------------------------------------------------------------------------
	MsoFRegSetDw

	Sets the REG_DWORD value for this msorid.
	Returns TRUE if succeeded, FALSE if failed.
--------------------------------------------------------------------dgray----*/
MSOAPI_(BOOL)  MsoFRegSetDw(int msorid, DWORD dwData);



/*-----------------------------------------------------------------------------
	MsoFRegGetBinary

	Gets the REG_BINARY value for this msorid. pCb should be set to the size
	of the buffer passed in.  (pCb needed can be queried with GetBufferSize
	functions)
	
	Returns:	TRUE if succeeded, FALSE if failed.
	Sides:		*pbData is filled with the binary data retrieved.
				*pCb is filled with the size of the returned binary.
--------------------------------------------------------------------dgray----*/
MSOAPI_(BOOL)  MsoFRegGetBinary(int msorid, LPBYTE pbData, DWORD* pCb);



/*-----------------------------------------------------------------------------
	MsoFRegSetBinary

	Sets the REG_BINARY value for this msorid. Cb should be set to the size
	of the buffer passed in to be written.
	
	Returns:	TRUE if succeeded, FALSE if failed.
--------------------------------------------------------------------dgray----*/
MSOAPI_(BOOL)  MsoFRegSetBinary(int msorid, const BYTE *pbData, DWORD Cb);



/*-----------------------------------------------------------------------------
	Mso*RegGetSz

	Gets the REG_SZ value for this msorid. 

	Input Parameters:
						Cb should be set to the size of the buffer passed
							in in bytes
						sz should be the character buffer to be filled.
	
	Sides:		*sz is filled with the ansi string data retrieved.

	MsoFRegGetSz
		Returns TRUE if success, FALSE if failed.  Asserts is default value
		is not NO_DEFAULT
	MsoRegGetSz
		No return value.  Used if there is a default value in the database.
--------------------------------------------------------------------dgray----*/
MSOAPI_(BOOL)  MsoFRegGetSzCore(int msorid, PSTR sz, DWORD Cb);
#ifdef VSMSODEBUG
MSOAPI_(VOID)  MsoRegGetSz (int msorid, PSTR sz, DWORD Cb);
MSOAPI_(BOOL)  MsoFRegGetSz(int msorid, PSTR sz, DWORD Cb);
#else  // ! DEBUG
#define MsoFRegGetSz(msorid, sz, Cb) MsoFRegGetSzCore(msorid, sz, Cb)
#define MsoRegGetSz(msorid, sz, Cb)  MsoFRegGetSzCore(msorid, sz, Cb)
#endif // ! VSMSODEBUG



/*-----------------------------------------------------------------------------
	Mso*RegGetWz

	Gets the REG_SZ value for this msorid.

	Input Parameters:
						Cb should be set to the size of the buffer passed
							in in bytes
						wz should be the character buffer to be filled.
	
	Sides:		*wz is filled with the wide string data retrieved.

	MsoFRegGetWz
		Returns TRUE if success, FALSE if failed.  Asserts is default value
		is not NO_DEFAULT
	MsoRegGetWz
		No return value.  Used if there is a default value in the database.
--------------------------------------------------------------------dgray----*/
MSOAPI_(BOOL)  MsoFRegGetWzCore(int msorid, PWSTR wz, DWORD Cb);
#ifdef VSMSODEBUG
MSOAPI_(VOID)  MsoRegGetWz (int msorid, PWSTR wz, DWORD Cb);
MSOAPI_(BOOL)  MsoFRegGetWz(int msorid, PWSTR wz, DWORD Cb);
#else  // ! DEBUG
#define MsoFRegGetWz(msorid, wz, Cb) MsoFRegGetWzCore(msorid, wz, Cb)
#define MsoRegGetWz(msorid, wz, Cb)  MsoFRegGetWzCore(msorid, wz, Cb)
#endif // ! VSMSODEBUG
MSOAPI_(DWORD) MsoCchRegGetWz(int msorid, PWSTR wz, DWORD Cb);



/*-----------------------------------------------------------------------------
	MsoFRegSetSz

	Sets the REG_SZ registry value for this msorid using sz as the input.

	Input Parameters:
						*sz is the buffer containing the ansi string to write.

	Returns:	TRUE if succeeded, FALSE if failed.	
--------------------------------------------------------------------dgray----*/
MSOAPI_(BOOL)  MsoFRegSetSz(int msorid, PCSTR sz);



/*-----------------------------------------------------------------------------
	MsoFRegSetWz

	Sets the REG_SZ registry value for this msorid using a wz as the input.

	Input Parameters:
						*wz is the buffer containing the wide string to write.

	Returns:	TRUE if succeeded, FALSE if failed.	
--------------------------------------------------------------------dgray----*/
MSOAPI_(BOOL)  MsoFRegSetWz(int msorid, PCWSTR wz);



/*-----------------------------------------------------------------------------
	MsoFRegKeyExists

	Returns true if the key for this msorid exists in the registry.
	This could be in either the policy tree or the user reg tree.
	Returns false if there is no value in the registry.
--------------------------------------------------------------------dgray----*/
MSOAPI_(BOOL) MsoFRegKeyExists(int msorid);



/*-----------------------------------------------------------------------------
	Mso*RegGetDefault*

	Retrieves the DEFAULT value for a particular rid, in the same method as the 
	other retrieval functions above.

	False if failed (no default value)
--------------------------------------------------------------------dgray----*/
MSOAPIX_(BOOL) MsoFRegGetDefaultSz(int msorid, PSTR sz, DWORD Cb);
MSOAPI_(BOOL) MsoFRegGetDefaultWz(int msorid, PWSTR wz, DWORD Cb);
MSOAPI_(DWORD) MsoDwRegGetDefaultDw(int msorid);



/*-----------------------------------------------------------------------------
	MsoFRegValueExists

	Returns true if value data for this msorid exists in the registry.
	This could be in either the policy tree or the user reg tree.
	Returns false if there is no value in the registry.

--------------------------------------------------------------------dgray----*/
MSOAPI_(BOOL) MsoFRegValueExists(int msorid);



/*-----------------------------------------------------------------------------
	MsoFRegDefaultValueExists

	Returns > 0 if default value exists, returns 0 if no default exists.
--------------------------------------------------------------------dgray----*/
MSOAPIDBG_(BOOL) MsoFRegValueExistsDefault(int msorid);



/*-----------------------------------------------------------------------------
	MsoFRegPolicyValueExists

	Returns TRUE if there is a value in the Policies tree to return. 
	FALSE otherwise.
--------------------------------------------------------------------dgray----*/
MSOAPI_(BOOL) MsoFRegPolicyValueExists(int msorid);



/*-----------------------------------------------------------------------------
	OrapiSetVal

	Sets a Generic ORAPI value

	Don't use this function if you just check for ERROR_SUCCESS.  It is
	wrapped for each type.

	Returns:	Win32 error code
	Sides:		None.
--------------------------------------------------------------------dgray----*/
MSOAPIX_(LONG) OrapiSetVal(int msorid, const BYTE* pbData, DWORD Cb);



/*-----------------------------------------------------------------------------
	OrapiQueryVal

	Queries for a Generic ORAPI value, not a string
	Order of how it gets the value
			1) Query Software/Policy Tree
			2) Query Software Tree
			3) Use Default Value
			4) Fill with empty value (0; 0x00, 0x00;)

	Returns:	Win32 error code (ERROR_SUCCESS except in case 4, but never
					use to check for ERROR_MORE_DATA, or 
					ERROR_INSUFFICIENT_BUFFER.
					(Use the GetBufferSize functions)
	Sides:		Fills wzData with a valid wz string
				Fills *pCb with the size in bytes returned.

REVIEW DGray: 
		Is there a way I can make this function even more compact by
		using a pointer to a function to make the query calls, 
		and dynamically setting it to either the W or A version, based 
		on vfUnicodeAPI?  The only thing holding my up is the type checking for 
		the wzValueName or rgMsoReg[msorid].szValue
--------------------------------------------------------------------dgray----*/
MSOAPIX_(LONG) OrapiQueryVal(int msorid, LPBYTE pbData, LPDWORD pCb);



/*-----------------------------------------------------------------------------
	OrapiQuerySzVal

	Queries for an ORAPI string value, to be returned as an sz
	Order of how it gets the string:
			1) Query Software/Policy Tree
			2) Query Software Tree
			3) Use Default Value
			4) Fill with empty string ("\0")


	Returns:	Win32 error code (ERROR_SUCCESS except in case 4, but never
					use to check for ERROR_MORE_DATA, or 
					ERROR_INSUFFICIENT_BUFFER.
					(Use the GetBufferSize functions)
	Sides:		Fills szData with a valid sz string
--------------------------------------------------------------------dgray----*/
MSOAPI_(LONG) OrapiQuerySzVal(int msorid, PSTR szData, DWORD Cb);



/*-----------------------------------------------------------------------------
	OrapiQueryWzVal

	Queries for an ORAPI string value, to be returned as a wz
	Order of how it gets the string:
			1) Query Software/Policy Tree
			2) Query Software Tree
			3) Use Default Value
			4) Fill with empty string (L"\0")


	Returns:	Win32 error code (ERROR_SUCCESS except in case 4, but never
					use to check for ERROR_MORE_DATA, or 
					ERROR_INSUFFICIENT_BUFFER.  
					(Use the GetBufferSize functions)

	Sides:		Fills wzData with a valid wz string
--------------------------------------------------------------------dgray----*/
MSOAPI_(LONG) OrapiQueryWzVal(int msorid, PWSTR wzData, DWORD Cb);



/*-----------------------------------------------------------------------------
	OrapiGetRid

	Given a value name, what is the rid associated with it.
--------------------------------------------------------------------dgray----*/
MSOAPIX_(BOOL) OrapiGetRidForValueEx(PSTR pszValueName, PSTR pszKeyName,
                                    BOOL fUseApp, DWORD *pdwMsoRid,
                                    DWORD *pdwRegType);
MSOAPI_(BOOL) OrapiGetRidForValueExW(PWSTR pwzValueName, PWSTR pwzKeyName, BOOL fUseApp, DWORD *pdwMsoRid, DWORD *pdwRegType);
#define OrapiGetRidForValue(pszValueName, pszKeyName, fUseApp, pdwMsoRid) \
	OrapiGetRidForValueEx(pszValueName, pszKeyName, fUseApp, pdwMsoRid, NULL)


/*-----------------------------------------------------------------------------
	FOfficePolicyKeyExists

	Determines if registry policy is being applied by reading the hkey.  Also
	inserts the key into the cache.
--------------------------------------------------------------------dgray----*/
BOOL FOfficePolicyKeyExists(HKEY hHive, int keyID);


/*-----------------------------------------------------------------------------
	When dealing with shared Excel and Graph code, use this to distinguish 
	between places where a single reg call is used to access graph in some
	cases and excel in others.  Tag on a rid that is msorid*XL to see an
	example.
--------------------------------------------------------------------dgray----*/
#ifdef EXCEL_BUILD
#ifdef GRAF
#define GetRid(x) x##GR
#else
#define GetRid(x) x##XL
#endif
#endif



/*-----------------------------------------------------------------------------
	MsoFRegCheckKeyPath

	Fills a buffer with the Ansi key path to a rid.  Used to make sure
	certain paths don't get accidentally changed.  Note: This path does NOT
	include the root, that is, HKEY_CURRENT_USER, HKEY_LOCAL_MACHINE, etc.
	So "Software\\Policies" would match "HKEY_CURRENT_USER\\Software\\Policies"
	and also "HKEY_LOCAL_MACHINE\\Software\\Policies", but that is not where 
	these key mishaps that we are trying to catch actually happen, so this is
	fine.  If msoridRoot is specified, we build the string up only until that
	key.
	
	Returns:
		TRUE  if the rid's key matches the expected string
		FALSE if the rid's key does not match the expected string.
--------------------------------------------------------------------dgray----*/
#ifdef VSMSODEBUG
MSOAPI_(LONG) MsoFRegCheckKeyPath(int msorid, int msoridRoot, const CHAR* sz);
#endif // VSMSODEBUG



/*----------------------------------------------------------------------------
	Experimental code to detect unused rids.
-------------------------------------------------------------------- KirKG--*/
// REVIEW: KirkG (DGray)  This is gone now, so we should rip it out, yes?
#ifdef ORAPI_RIDCHECK
#define MsoRegFGetSz(rid,b,c,d)	(ORAPI_##rid(), MsoFRegGetSzCore(rid,b,c,d)) 
MSOAPI_(LONG) MsoFRegGetSzCore(int msorid, LPDWORD lpType, LPBYTE lpData, LPDWORD lpcbData);
#endif


/****************************************************************************
	Binary Policy Routines (for Word and Excel)
****************************************************************************/

/*---------------------------------------------------------------------------
	MsoPolicyApplyBinary

	Applies policy settings to bitmapped members of a structure.  Stores
	a history list of changes so that policy changes are rolled back and
	don't infect the app's user preference settings in the registry.
-------------------------------------------------------------------JoelDow-*/	
MSOAPI_(void) MsoPolicyApplyBinary(void* pvStruct, int msoridKey, 
	WORD wcbStruct, HANDLE* phRestore);


/*---------------------------------------------------------------------------
	MsoApplyAppBinarySettings

	Similar in concept to MsoPolicyApplyBinary, this API will apply, on a ONE
	time basis, bits to certain app structures. After it finishes, it deletes
	the key containing the bits. ( msoridKey ) Used for CMW settings.
-------------------------------------------------------------------MattP-*/	
MSOAPI_(void) MsoApplyAppBinarySettings(void* pvStruct, int msoridKey, 
	WORD wcbStruct);

/*---------------------------------------------------------------------------
	MsoPolicyRestoreBinary
	
	"Undoes" previous changes to bitmapped members of a structure to 
	prevent policy settings from infecting a user's configuration
	options in the registry.
-------------------------------------------------------------------JoelDow-*/	
MSOAPI_(void) MsoPolicyRestoreBinary(void* pvStruct, WORD wcbStruct, HANDLE hRestore);

#ifdef VSMSODEBUG
/*---------------------------------------------------------------------------
	MsoPolicyDumpBinary
	
	Outputs a list of active policy overrides for the context provided
	in hRestore.  Intended for use in a debug-only status dump.
-------------------------------------------------------------------JoelDow-*/	

MSOAPI_(void) MsoPolicyDumpBinary(HANDLE fhOut, HANDLE hRestore);
#endif


/****************************************************************************
	Terminal Server (Hydra) Support/Detection
****************************************************************************/

/*------------------------------------------------------------

	MsoFIsTerminalServer

	Old API to detect Hydra.  I'm keeping this function here
	to maintain binary compatibility with all MSO clients.

	IT IS OBSOLETE.  PLEASE DO NOT USE THIS FUNCTION.

	This function will assert and ask everyone to use the 
	new behavior modification API's. However, to maintain 
	some semblance of backward compatibility, we will return 
	assume that what the caller wants to know is whether or
	not this code is running on an AppServer, since that's
	really the only interesting way WTS 4 was used and WTS 5
	hadn't shipped when Office 9 did.

	It's just an incomplete answer, since now there are more
	"flavors" of Terminal Server, and we may want to modify
	our behavior on the Console vs. when we're running with 
	graphics over the wire, etc.

----------------------------------------------- (FrankRon) -*/
MSOAPI_(BOOL) MsoFIsTerminalServer(void);



/*------------------------------------------------------------

	MsoFTSAppServer

	Use this routine to fork behavior based on whether or not
	we're running on a regular TS App Server machine (console
	or not).  TS-Lite/Remote-Admin and regular non-TS work-
	stations return FALSE here.
----------------------------------------------- (FrankRon) -*/
MSOAPI_(BOOL) MsoFTSAppServer(void);

/*------------------------------------------------------------

	MsoFEnableComplexGraphics

	Use this routine to fork behavior on animation/sound-
	intensive features (e.g., splashes) to minimize unnecessary 
	graphics "candy."  Basically this is important for Hydra
	systems were we're transmitting lots of graphics bits
	over the wire, but it's also useful if the Shell ever
	implements a "Simplify Graphics" key in their Display
	Properties that may actually be exposed on all systems
----------------------------------------------- (FrankRon) -*/
MSOAPI_(BOOL) MsoFEnableComplexGraphics(void);

/*------------------------------------------------------------

	MsoFAllowIOD

	Use this routine to determine if Darwin is going to let
	us do an Install-On-Demand. Especially useful for TS.

	Basically, we allow IOD for non-TS systems, TS-Lite/RA,
	or when the user is an admin and the Policy to allow
	remote installs on TS is set.

	Note that usually Darwin will allow an admin to do an 
	install at the console even if the policy is not set,
	but we don't allow this.  Dynamic installation of Office
	is generally not a good idea, and we will respect admin
	policy, but we aren't going to allow admin console install
	without the policy setting.
----------------------------------------------- (FrankRon) -*/
MSOAPI_(BOOL) MsoFAllowIOD(void);

/*------------------------------------------------------------

	MsoFRemoteUI

	Use this routine if a feature needs to know if it's UI
	is running remotely (as is the case on TS non-Console
	sessions).
----------------------------------------------- (FrankRon) -*/
MSOAPI_(BOOL) MsoFRemoteUI(void);

/*---------------------------------------------------------------------------
	MsoFIEPolicyAndVersion

	Put the current version of IE in 'plMajor' and 'plMinor, with a zero
	meaning that IE is not currently installed.  Return TRUE is policy is set
	to disable just-in-time installation of IE, FALSE otherwise.
---------------------------------------------------------------- EricSchr -*/
MSOAPI_(BOOL) MsoFIEPolicyAndVersion(long *plMajor, long *plMinor);


/*-----------------------------------------------------------------------------
	MsoFCheckIEVersion

	Return TRUE if we have an IE of at least the version passed in.
	Don't worry about policy or prompting in case it isn't.  MsoFIEPolicyAndVersion()
	and MsoFUseIEFeature() are for that.

-------------------------------------------------------------------- KBrown -*/
MSOAPI_(BOOL) MsoFCheckIEVersion(long lMajor, long lMinor);

/*---------------------------------------------------------------------------
	MsoFUseIEFeature

	Return TRUE if the version of IE installed on the machine is high enough
	to use a feature requiring version 'lMajor' and 'lMinor'.  Return
	FALSE otherwise.  Note that 'lMinor' could be a two digit number, so
	that version 4.1 is actually lMajor == 4 and lMinor == 10, since
	lMinor == 1 implies 4.01.  The function will not do a demand
	installation, but it does warn about not having a new enough version
	and about admin disabling.
---------------------------------------------------------------- EricSchr -*/
MSOAPI_(BOOL) MsoFUseIEFeature(long lMajor, long lMinor);


/*---------------------------------------------------------------------------
	MsoCheckHEVReg

	Calls the Self-registration routine for the HEV project.
---------------------------------------------------------------- A-GordRo -*/
MSOAPI_(void) MsoCheckHEVReg(void);

/*-----------------------------------------------------------------------------
	MsoFSupportThisEditLID
	
	return whether the editing of specified lang is supported
-------------------------------------------------------------------- IrfanGo -*/
MSOAPI_(BOOL) MsoFSupportThisEditLID(UINT lid);

/*-----------------------------------------------------------------------------
	MsoFSupportThisEditBaseLID
	
	return whether the editing of specified lang is supported
-------------------------------------------------------------------- katsun -*/
MSOAPIX_(BOOL) MsoFSupportThisEditBaseLID(UINT lid);

/*----------------------------------------------------------------------------
	MsoSetInstallingState

	Tell Office that app is starting/finsihing installing components.
-------------------------------------------------------------------- MattP --*/
MSOAPIX_(BOOL) MsoSetInstallingState(BOOL fStartInstall);

/*----------------------------------------------------------------------------
	MsoFGetInstallingState

	Returns what the current global install state is.
-------------------------------------------------------------------- MattP --*/
MSOAPIX_(BOOL) MsoFGetInstallingState(void);

/*-----------------------------------------------------------------------------
	MsoFSupportFEEditLID - 

	return fTrue if one of the FE lids are among the editing languages 
	specified by the langtool
------------------------------------------------------------------ JeffreyK -*/
MSOAPI_(BOOL) MsoFSupportFEEditLID(void);

/*-----------------------------------------------------------------------------
	MsoFSupportFEEditBaseLID - 

	return fTrue if one of the FE lids are among the editing languages 
	specified by the langtool
------------------------------------------------------------------ katsun -*/
MSOAPIX_(BOOL) MsoFSupportFEEditBaseLID(void);

/*-----------------------------------------------------------------------------
	MsoGimmeLocalizedLibrary
	
	Extended entry-point for MsoLoadLocalizedLibraryFull -- allows user to
	pass flags requesting check of file system before calling Darwin.  Intended
	for use in boot optimization.

	Supports msotcgfProvide (same behavior as MsoLoadLocalizedLibraryFull,
	and msotcogfProvide | msotcogfSearchFirst (check file system).
----------------------------------------------------------------- JoelDow ---*/
MSOAPI_(HMODULE) MsoGimmeLocalizedLibrary(msofidT fid, LCID *plcid,
	const DWORD dwFlags, WCHAR *wzFullPath, DWORD dwGimmeFlags);

/*----------------------------------------------------------------------------
	Find out version of the CLSID's OLE server and append it to the given string
	in the form of "#version=X.X.X.X"
---------------------------------------------------------------- vadimc ----*/
MSOAPI_(BOOL) MsoFAppendCodebaseVer(const CLSID* pclsid, WCHAR* wzBuff, int cchMax);

/*---------------------------------------------------------------------------------------------------
	MsoFOsChange() is designed to let the apps tell minor differences in the OS since they last booted, i.e. 
	a new service pack or minor version.  Note that these structures will be identical the very first time 
	this API is called by anyapp after installation.
	   hmsoinst may be NULL. If so, wzHostName must be non-NULL and must give the short name
	of the application, i.e. the name passed to MsoFInitOffice.  If hmsoinst is non-NULL,
	wzHostName may be NULL.  This scheme is designed to allow apps to call this function
	before calling MsoFInitOffice if necessary and in that case an HMSOINST will not be
	available.
	   If poviOld is non-NULL, it will be filled with the OSVERSIONINFOA structure cached for this application
	the last time this API was called.  If this is the first time the API was called, it will be filled with
	current OSVERSIONINFOA information.
	   If poviNew is non-NULL, it will be filled with the current return from GetVersionExA, i.e. the current 
	OSVERSIONINFOA information.  
	Either or both of poviOld and poviNew may be NULL if that information is not needed.

	Returns TRUE if anything has changed in the OSVERSIONINFOA structure between the 
	cached copy	from the last time this API was called by this appplication and this call.
-------------------------------------------------------------------------- VadimC ------------------*/
MSOAPIX_(BOOL) MsoFOsChange(const HMSOINST hmsoinst, const WCHAR* wzHostName, 
							OSVERSIONINFOA* poviOld, OSVERSIONINFOA* poviNew);

/*---------------------------------------------------------------------------------------------------
	Returns	TRUE if the platform changed from VER_PLATFORM_WIN32_WINDOWS to VER_PLATFORM_WIN32_NT 
	and the major version of NT is greater than or equal to 5, i.e. we upgraded from Win9X to NT 5.0.
-------------------------------------------------------------------------- VadimC ------------------*/
MSOAPIX_(BOOL) MsoFOsPlatformChanged(const HMSOINST hmsoinst, const WCHAR* wzHostName);


/*----------------------------------------------------------------------------
 MSOAPI_(BOOL) MsoFSystemPolicyEnabled(int msorid) 
 Returns TRUE if Windows2000 policy corresponding to the msorid is enabled, 
 FALSE if disabled or not configured. 
 
 The following msorids are currently passed to this macro:
  	msoridNoDrives
  	msoridRestrictRun
  	msoridNoRecentDocsHistory
  	msoridNoPlacesBar 
  	msoridNoBackButton
  	msoridNoFileMru
  	msoridNoNetConnectDisconnect  

 All these msorids have an Orapi DEFAULT-VALUE-DATA of 0 (false).

------------------------------------------------------------------ AnzhelN  */
#define MsoFSystemPolicyEnabled(msorid)	MsoDwRegGetDw(msorid)


/*----------------------------------------------------------------------------
 MSOAPI_(BOOL) MsoFCanBrowse(void)

 Returns TRUE if  default browser is allowed to run by 
 "Run only allowed applications" Windows2000 policy.

 ----------------------------------------------------------------- AnzhelN  */
 MSOAPI_(BOOL) MsoFCanBrowse(void);  

/*----------------------------------------------------------------------------
MSOAPI_(BOOL) MsoFCanLaunch(WCHAR * wzAppName)

This API checks the list of allowed apps for wzAppName. Returns TRUE if it's on 
the list, FALSE otherwize
------------------------------------------------------------------ AnzhelN -*/
MSOAPI_(BOOL) MsoFCanLaunch(WCHAR * wzAppName);

//AnzhelN: ERROR_RESTRICTED_APP is an internally defined system error which is 
//returned by GetLastError() in case if ShellExecute or ShellExecuteEx failed 
//for the reason of RestrictRun system policy
#define ERROR_RESTRICTED_APP ((UINT)-1)

/*----------------------------------------------------------------------------
MSOAPI_(void) MsoSystemPolicyAlert(void);

Displays an Alert message analogious to the system Restrictions alert for
System Policy restricted applications
------------------------------------------------------------------ AnzhelN -*/
MSOAPI_(void) MsoSystemPolicyAlert(void);

/*----------------------------------------------------------------------------
MSOAPI_(WCHAR*) MsoWzGetAppNameFromPath(WCHAR * wzAppPath)

Given application path wzAppPath as stored in the registry 
returns its name without a path
------------------------------------------------------------------ AnzhelN -*/
MSOAPI_(WCHAR*) MsoWzGetAppNameFromPath(WCHAR * wzAppPath);

/*----------------------------------------------------------------------------
MSOAPI_(BOOL) MsoFHistoryPolicyEnabled(void);

Checks if NoRecentDocsHistory is enabled. Called in FrontPage.
------------------------------------------------------------------ AnzhelN -*/
MSOAPI_(BOOL) MsoFHistoryPolicyEnabled(void);

/*---------------------------------------------------------------------------
MSOAPI_(VOID) MsoSetPolicyTooltip(unsigned int tmc)

The tooltip text is from 
HKEY_CURRENT_USER\Software\Policies\Microsoft\Office\10.0\Common\
Toolbars\AttemptDisabledActionMessage
which is set by Admin through the policy editor
The tooltip is set only if EnableWPFeatures regkey is 1. 
For SDM dialogs only.
------------------------------------------------------------------ AnzhelN -*/
MSOAPI_(VOID) MsoSetPolicyTooltip(unsigned int tmc);

/*-----------------------------------------------------------------------------
	MsoEnsureValidDocObj

	make sure docobj.dll (for ie4) or actxprxy.dll (for ie5) are correctly
	registered
-------------------------------------------------------------------- HAILIU -*/
MSOAPI_(VOID) MsoEnsureValidDocObj(void);

/*-----------------------------------------------------------------------------
MSOAPI_(BOOL) MsoFQueryPhotoDraw(UINT32 grfqphd)

Asks various interesting things about the installed PhotoDraw and image
editing.
* msofqphdMayEditPictures asks whether or not PhotoDraw should edit raster
  images from Office Drawing.  It's just a thin wrapper on the Gimme API
  to verify PhotoDraw is available (at least advertised.)
------------------------------------------------------------------- JustinV -*/
#define msofqphdMayEditPictures (1<<0)
MSOAPI_(BOOL) MsoFQueryPhotoDraw(UINT32 grfqphd);

#endif // MSOTC_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Inc\office10\msotcdar.h ===
/******************************************************************************
 * Gimme Header File
 * Automatically generated by %OTOOLS%\bin\GimmeBuild.bat
 *
 * Owner: JJames and Office TCO
 * (C) Copyright 1997 - 1999, Microsoft Corporation
 ******************************************************************************/

#ifndef TCDARO_H
#define TCDARO_H

#define msodwGimmeTableVersion 2

enum {
	msofidNil = -1,
	msoqfidNil = -1,
	msofidMsoDll           = 0x00000,	// (0) mso$d.dll
	msofidRiched20Dll      = 0x00001,	// (1) riched20.dll
	msofidUser32Dll        = 0x00002,	// (2) USER32.dll
	msofidGdi32Dll         = 0x00003,	// (3) GDI32.dll
	msofidWinnlsDll        = 0x00004,	// (4) WINNLS.dll
	msofidShell32Dll       = 0x00005,	// (5) SHELL32.dll
	msofidComctl32Dll      = 0x00006,	// (6) COMCTL32.dll
	msofidOleaut32Dll      = 0x00007,	// (7) OLEAUT32.dll
	msofidComDlg32Dll      = 0x00008,	// (8) COMDLG32.dll
	msofidKernel32Dll      = 0x00009,	// (9) KERNEL32.dll
	msofidVersionDll       = 0x0000a,	// (10) VERSION.dll
	msofidWinmmDll         = 0x0000b,	// (11) WINMM.dll
	msofidMapi32Dll        = 0x0000c,	// (12) MAPI32.dll
	msofidHlinkDll         = 0x0000d,	// (13) HLINK.dll
	msofidUrlmonDll        = 0x0000e,	// (14) URLMON.dll
	msofidOleAccDll        = 0x0000f,	// (15) OLEACC.dll
	msofidWsock32Dll       = 0x00010,	// (16) WSOCK32.dll
	msofidMprDll           = 0x00011,	// (17) MPR.dll
	msofidOdma32Dll        = 0x00012,	// (18) ODMA32.dll
	msofidWininetDll       = 0x00013,	// (19) wininet.dll
	msofidRpcrt4Dll        = 0x00014,	// (20) RPCRT4.dll
	msofidImm32Dll         = 0x00015,	// (21) imm32.dll
	msofidShlwapiDll       = 0x00016,	// (22) shlwapi.dll
	msofidMscat32Dll       = 0x00017,	// (23) mscat32.dll
	msofidUcscribeDll      = 0x00018,	// (24) UCSCRIBE.DLL
	msofidImeShareDll      = 0x00019,	// (25) MSOSTYLE.dll
	msofidAWJIMECLPath     = 0x0001a,	// (26) imejpcl.aw
	msofidAWJIMESMPath     = 0x0001b,	// (27) imejpsm.aw
	msofidUDateDll         = 0x0001c,	// (28) IntlDate.DLL
	msofidUspDll           = 0x0001d,	// (29) usp10.dll
	msofidBidi32Dll        = 0x0001e,	// (30) BIDI32.DLL
	msofidSelfRegDll       = 0x0001f,	// (31) SelfReg$D.dll
	msofidT2EmbedDll       = 0x00020,	// (32) T2EMBED.DLL
	msofidOdbc32Dll        = 0x00021,	// (33) ODBC32.DLL
	msofidOdbccp32Dll      = 0x00022,	// (34) ODBCCP32.dll
	msofidMLangDll         = 0x00023,	// (35) mlang.dll
	msofidWinspoolDll      = 0x00024,	// (36) winspool.drv
	msofidUnlockDll        = 0x00025,	// (37) unlock.dll
	msofidFtpSiteExe       = 0x00026,	// (38) mso7ftp.exe
	msofidAddSiteExe       = 0x00027,	// (39) mso7ftpa.exe
	msofidFtpSitesExe      = 0x00028,	// (40) mso7ftps.exe
	msofidmsoDll           = 0x00029,	// (41) mso$d#h.dll
	msofidMsJet40Dll       = 0x0002a,	// (42) MSJET40.dll
	msoqfidMsoIntlDll      = 0x0002b,	// (43) msointl$d#h.dll
	msoqfidMsoACL          = 0x0002c,	// (44) mso.acl
	msofidavifil32Dll      = 0x0002d,	// (45) avifil32.dll
	msofidmsvfw32Dll       = 0x0002e,	// (46) msvfw32.dll
	msofidMsacm32Dll       = 0x0002f,	// (47) msacm32.dll
	msofidIppWFFDll        = 0x00030,	// (48) ippwff.dll
	msofidNetApi32Dll      = 0x00031,	// (49) netapi32.dll
	msofidVbeDll           = 0x00032,	// (50) vbe6.dll
	msoqfidMsoHelp         = 0x00033,	// (51) msohelp$d.exe
	msoqfidOfficeTipHelp   = 0x00034,	// (52) oftip10.hlp
	msoqfidOfficePssHelp   = 0x00035,	// (53) pss10r.chm
	msoqfidOfficePssOEMHelp = 0x00036,	// (54) pss10o.chm
	msoqfidOfficeMainHelp  = 0x00037,	// (55) ofmain10.chm
	msoqfidDaoHelp         = 0x00038,	// (56) dao360.chm
	msoqfidVbaHelp         = 0x00039,	// (57) vblr6.chm
	msoqfidAWFeedback      = 0x0003a,	// (58) Feedback.htm
	msoqfidAWThankYou      = 0x0003b,	// (59) ThankYou.htm
	msofidNLGSpellGlue     = 0x0003c,	// (60) csapi3t1.dll
	msofidNLGThesaurusGlue = 0x0003d,	// (61) ctapi3t2.dll
	msofidNLGHyphenatorGlue = 0x0003e,	// (62) chapi3t1.dll
	msoqfidMSRouteDLL      = 0x0003f,	// (63) MSROUTE.DLL
	msofidHlinkPrxDll      = 0x00040,	// (64) hlinkprx.dll
	msofidOsbExe           = 0x00041,	// (65) msoffice.exe|msofficd.exe
	msofidOsbIntlDll       = 0x00042,	// (66) osbintl$d.dll
	msofidMSQuery          = 0x00043,	// (67) msqry32.exe
	msoqfidOrgChartCnv     = 0x00044,	// (68) orgcnv.dll
	msoqfidDrawCnv         = 0x00045,	// (69) drawcnv.dll
	msofidPubPrtf9         = 0x00046,	// (70) prtf9$d.dll
	msofidPubPtxt9         = 0x00047,	// (71) ptxt9$d.dll
	msofidMsInfoExe        = 0x00048,	// (72) msinfo32.exe
	msofidAccessExe        = 0x00049,	// (73) msaccess.exe
	msofidExcelExe         = 0x0004a,	// (74) excel.exe
	msofidWordExe          = 0x0004b,	// (75) winword$d#h.exe
	msofidPowerPointExe    = 0x0004c,	// (76) powerpnt.exe
	msofidOutlookExe       = 0x0004d,	// (77) outlook.exe
	msofidBinderExe        = 0x0004e,	// (78) binder$d#h.exe
	msofidWord9Exe         = 0x0004f,	// (79) winword.exe
	msofidFrontPageExe     = 0x00050,	// (80) frontpg.exe
	msofidPublisherExe     = 0x00051,	// (81) mspub.exe
	msofidProjectExe       = 0x00052,	// (82) winproj.exe
	msofidFoxProExe        = 0x00053,	// (83) vfp.exe
	msofidOsaExe           = 0x00054,	// (84) osa$d.exe
	msofidPhotoDrawExe     = 0x00055,	// (85) photodrw.exe
	msofidDesignerExe      = 0x00056,	// (86) designer.exe
	msofidVisioExe         = 0x00057,	// (87) visio.exe
	msofidThemesFontMap    = 0x00058,	// (88) themes.inf
	msofidMsLid            = 0x00059,	// (89) mslid.dll
	msofidCrypt32Dll       = 0x0005a,	// (90) crypt32.dll
	msofidWintrustDll      = 0x0005b,	// (91) wintrust.dll
	msofidCryptdlgDll      = 0x0005c,	// (92) cryptdlg.dll
	msofidSignerDll        = 0x0005d,	// (93) signer.dll
	msofidSoftpubDll       = 0x0005e,	// (94) softpub.dll
	msofidAdvapi32Dll      = 0x0005f,	// (95) advapi32.dll
	msofidTypeLibStd2      = 0x00060,	// (96) stdole2.tlb
	msofidTypeLibVba       = 0x00061,	// (97) vbaen32.olb
	msofidMsowcDll         = 0x00062,	// (98) owc10$d.dll
	msofidAnswerWizard     = 0x00063,	// (99) aw$d.dll
	msofidFindFastExe      = 0x00064,	// (100) findfast.exe|ffastd.exe
	msofidMSE10            = 0x00065,	// (101) mse7.exe
	msofidWWordBreakerJ    = 0x00066,	// (102) msgr3jp.dll
	msofidSCWrdBkrDll      = 0x00067,	// (103) msgr3sc.dll
	msofidTCWrdBkrDll      = 0x00068,	// (104) wdbrkcht.dll
	msoqfidVIM             = 0x00069,	// (105) mapivi32.dll
	msofidMsoHevDll        = 0x0006a,	// (106) msohev.dll
	msofidStemmerDll       = 0x0006b,	// (107) msstko32.dll
	msoqfidEnvelopeIntlDll = 0x0006c,	// (108) envelopr.dll
	msoqfidEnvOutlHelp     = 0x0006d,	// (109) oltip10.hlp
	msoqfidMSQueryTips     = 0x0006e,	// (110) msqry32.hlp
	msofidMssign32Dll      = 0x0006f,	// (111) mssign32.dll
	msoqfidOBalloon        = 0x00070,	// (112) oballoon$d.dll
	msofidOlepro32Dll      = 0x00071,	// (113) OLEPRO32.DLL
	msofidCryptuiDll       = 0x00072,	// (114) cryptui.dll
	msoqfidSpeechGrammars  = 0x00073,	// (115) srintl.dll
	msoqfidSpeechTrainingVideo = 0x00074,	// (116) video.mht
	msoqfidSpeechTrainingText = 0x00075,	// (117) offtext.txt
	msofidSimSunFont       = 0x00076,	// (118) simsun.ttf
	msofidPMingLiUFont     = 0x00077,	// (119) pmingliu.ttf
	msofidCenturyFont      = 0x00078,	// (120) century.ttf
	msofidMsMinchoFont     = 0x00079,	// (121) msmincho.ttf
	msofidBatangCheFont    = 0x0007a,	// (122) batang.ttf
	msofidSetupddDll       = 0x0007b,	// (123) setupdd.dll
	msofidMyPictures       = 0x0007c,	// (124) shfolder.dll
	msofidSimSunTTCFont    = 0x0007d,	// (125) simsun.ttc
	msofidMingLiUTTCFont   = 0x0007e,	// (126) mingliu.ttc
	msofidMsMinchoTTCFont  = 0x0007f,	// (127) msmincho.ttc
	msofidBatangCheTTCFont = 0x00080,	// (128) batang.ttc
	msofidSAExtDll         = 0x00081,	// (129) saext.dll
	msofidCSSeqChkDll      = 0x00082,	// (130) seqchk10.dll
	msofidUcs20Dll         = 0x00083,	// (131) UCS20.DLL
	msofidWdbImpDll        = 0x00084,	// (132) wdbimp.dll
	msofidMsoSvDll         = 0x00085,	// (133) msosv$d.dll
	msoqfidMsoSvIntlDll    = 0x00086,	// (134) msosvint.dll
	msoqfidMsoICCEnRGBCMYK = 0x00087,	// (135) rswop.icm
	msoqfidMsoPantoneDLL   = 0x00088,	// (136) poce98.dll
	msofidCtryInfo         = 0x00089,	// (137) ctryinfo.txt
	msofidLicenseStore     = 0x0008a,	// (138) data.bak
	msoqfidmstoreIntlDLL   = 0x0008b,	// (139) mstintl.dll|MSTIntlD.dll
	msofidmstoreSearchDLL  = 0x0008c,	// (140) mstores.dll|MStoreSD.dll
	msofidActivedsDll      = 0x0008d,	// (141) activeds.dll
	msofidTypeLibFactoid   = 0x0008e,	// (142) mstag.tlb
	msofidViniutilDll      = 0x0008f,	// (143) fpcutl.dll
	msoqfidFPUtlIntlDll    = 0x00090,	// (144) fputlsat.dll
	msoqfidFPPageKey       = 0x00091,	// (145) normal.htm
	msoqfidFPFrameKey      = 0x00092,	// (146) bantoc.htm
	msoqfidFPCSSKey        = 0x00093,	// (147) normal.inf_0002
	msoqfidFPWebKey        = 0x00094,	// (148) empty.inf
	msofidDocumentImagingExe = 0x00095,	// (149) mspview.exe
	msoqfidNavBarStyles    = 0x00096,	// (150) navbars.ini
	msoqfidListViewStyles  = 0x00097,	// (151) lstviews.ini
	msofidVC7Runtime       = 0x00098,	// (152) FL_msvcr70$d_dll_____X86.3643236F_FC70_11D3_A536_0090278A1BB8
	msofidVC7CPPRuntime    = 0x00099,	// (153) FL_msvcp70$d_dll_____X86.3643236F_FC70_11D3_A536_0090278A1BB8
	msofidTcpTest          = 0x0009a,	// (154) tcptest.exe
	msofidVSAnsi           = 0x0009b,	// (155) FL_vsansi_dll_____X86.3643236F_FC70_11D3_A536_0090278A1BB8
	msofidVSAssert         = 0x0009c,	// (156) Vsassert_dll_2_____X86.3643236F_FC70_11D3_A536_0090278A1BB8
	msofidATL70Unicode     = 0x0009d,	// (157) FL_atl70_dll_1_____X86.3643236F_FC70_11D3_A536_0090278A1BB8
	msofidATL70Ansi        = 0x0009e,	// (158) FL_atl70_dll_____X86.3643236F_FC70_11D3_A536_0090278A1BB8
	msofidATL70Debug       = 0x0009f,	// (159) atl70dbg_dll_5_____X86.3643236F_FC70_11D3_A536_0090278A1BB8
	msoqfidmstoreMainHelp  = 0x000a0,	// (160) mstore10.chm
	msoqfidmstoreTipHelp   = 0x000a1,	// (161) mstip10.hlp
	msoqfidmstoreCagCat    = 0x000a2,	// (162) cagcat.mml
	msoqfidmstoreCagCat10  = 0x000a3,	// (163) cagcat10.mml
	msoqfidmstoreOffice10  = 0x000a4,	// (164) office10.mml
	msoqfidMsoOutlcmRDLL   = 0x000a5,	// (165) OutlcmR.dll
	msoqfidDigiDash        = 0x000a6,	// (166) digidash.dll
	msoqfidDiscussion      = 0x000a7,	// (167) discuss.dll
	msoqfidDocLib          = 0x000a8,	// (168) doclib.dll
	msoqfidIssue           = 0x000a9,	// (169) issue.dll
	msoqfidProject         = 0x000aa,	// (170) project.dll
	msoqfidSimpleList      = 0x000ab,	// (171) simple.dll
	msoqfidSurvey          = 0x000ac,	// (172) survey.dll
	msoqfidWorkflow        = 0x000ad,	// (173) workflow.dll
	msofidMOSearchExe      = 0x000ae,	// (174) mosearch.exe
	msofidWtsapi32Dll      = 0x000af,	// (175) wtsapi32.dll
	msofidMediaGallery     = 0x000b0,	// (176) mstore$d.exe
	msofidConverterWord97  = 0x000b1,	// (177) mswrd832.cnv
	msofidConverterCore    = 0x000b2,	// (178) msconv97.dll
};

enum {
	msocidNonSetup = -2,
	msocidNil = -1,
	msoqcidNil = -1,
	msocidOffice           = 0x00000,	// (0) mso$d#h.dll
	msoqcidMsoIntlDll      = 0x00001,	// (1) msointl$d#h.dll
	msoqcidHelpFiles       = 0x00002,	// (2) msohelp$d.exe
	msoqcidNLGSpellingV1   = 0x00003,	// (3) _
	msoqcidNLGSpellingV3   = 0x00004,	// (4) msspell3.dll
	msoqcidNLGGrammarV3    = 0x00005,	// (5) msgr3en.dll
	msoqcidNLGGrammarV2    = 0x00006,	// (6) _
	msoqcidNLGGrammarV1    = 0x00007,	// (7) _
	msoqcidNLGThesaurusV3  = 0x00008,	// (8) msthes3.dll
	msoqcidNLGThesaurusV1  = 0x00009,	// (9) _
	msoqcidNLGHyphenatorV2 = 0x0000a,	// (10) mshyph2.dll
	msoqcidNLGHyphenatorV1 = 0x0000b,	// (11) _
	msoqcidNLGDictionary   = 0x0000c,	// (12) msdi_enh.dll
	msoqcidNLGSpellingDataV3 = 0x0000d,	// (13) mssp3en.lex
	msoqcidNLGSpellingDataV1 = 0x0000e,	// (14) _
	msoqcidNLGGrammarDataV3 = 0x0000f,	// (15) msgr3en.lex
	msoqcidNLGGrammarDataV2 = 0x00010,	// (16) _
	msoqcidNLGGrammarDataV1 = 0x00011,	// (17) _
	msoqcidNLGThesaurusDataV3 = 0x00012,	// (18) msth3am.lex
	msoqcidNLGThesaurusDataV1 = 0x00013,	// (19) _
	msoqcidNLGHyphenatorDataV2 = 0x00014,	// (20) mshy2_en.lex
	msoqcidNLGHyphenatorDataV1 = 0x00015,	// (21) _
	msoqcidNLGDictionaryData = 0x00016,	// (22) msdi_hbe.lex
	msoqcidNLGMorphoLex    = 0x00017,	// (23) mswds_en.lex
	msocidProfWiz          = 0x00018,	// (24) proflwiz.exe
	msocidOsa              = 0x00019,	// (25) osa$d.exe
	msocidOsb              = 0x0001a,	// (26) msoffice.exe|msofficd.exe
	msocidInstallLoc       = 0x0001b,	// (27) Global_Office_InstallLocation
	msocidMsInfoOcx        = 0x0001c,	// (28) msioff9.ocx
	msoqcidTemplates       = 0x0001d,	// (29) Global_PowerPoint_DesignTemplateMaple
	msocidOEMEula          = 0x0001e,	// (30) oemeula.txt
	msocidExcelQueries     = 0x0001f,	// (31) Global_Excel_WebQueries
	msoqcidOfficeDataServices = 0x00020,	// (32) Global_Office_DataServices
	msoqcidOutlookStationery = 0x00021,	// (33) _
	msoqcidOutlookStationeryBG = 0x00022,	// (34) _
	msoqcidThemes          = 0x00023,	// (35) artsy.inf
	msoqcidSharedImportConverter = 0x00024,	// (36) recovr32.cnv
	msoqcidSharedExportConverter = 0x00025,	// (37) wrd6ex32.cnv
	msocidFtpIcons         = 0x00026,	// (38) mso7ftp.exe
	msocidActorPreviews    = 0x00027,	// (39) blnmgr.dll
	msoqcidFullActors      = 0x00028,	// (40) rocky.acs
	msoqcidImportGraphicFilter = 0x00029,	// (41) _
	msoqcidExportGraphicFilter = 0x0002a,	// (42) _
	msocidFindFastFilters  = 0x0002b,	// (43) offfilt.dll
	msocidFindFastHtmlFilter = 0x0002c,	// (44) nlhtml.dll
	msocidWTCSCTranslator  = 0x0002d,	// (45) _
	msoqcidHHC32Dll        = 0x0002e,	// (46) hhc32.dll
	msoqcidHHCData         = 0x0002f,	// (47) hhc.lex
	msoqcidVbaIntlDLL      = 0x00030,	// (48) Global_VBA_Intl
	msoqcidMSE_VSPkgsIntl  = 0x00031,	// (49) msenvui.dll
	msoqcidMSE_UA_MSECore  = 0x00032,	// (50) Global_UserAssistance_MSECore
	msoqcidMSE_AW_MSEDefault = 0x00033,	// (51) Global_AnswerWiz_MSEDefault
	msoqcidMSE_DebuggerIntl = 0x00034,	// (52) Global_Vse_DebuggerIntl
	msoqcidServerByClsid   = 0x00035,	// (53) -
	msoqcidVBAHelp         = 0x00036,	// (54) {CC4932ED-A4EC-11d2-B8E2-@0$1#3000F806A77F}
	msocidDpcFile          = 0x00037,	// (55) -
	msocidMediaStoreCore   = 0x00038,	// (56) mstore$d.exe
	msoqcidWebComponents   = 0x00039,	// (57) Global_FrontPageCore_PageComponentsIntl
	msocidmstoreThemesLines = 0x0003a,	// (58) Global_MediaStore_Office10ClipsLines
	msocidmstoreThemesBullets = 0x0003b,	// (59) Global_MediaStore_Office10ClipsBullets
	msoqcidmstoreAW        = 0x0003c,	// (60) mstore10.aw
	msoqcidCAGMMW          = 0x0003d,	// (61) _
	msoqcidCAGMML          = 0x0003e,	// (62) _
	msoqcidCAGAssets       = 0x0003f,	// (63) _
	msoqcidODTemplateEndUser = 0x00040,	// (64) digidash.dll
	msoqcidODTemplateSampleCode = 0x00041,	// (65) discuss.dll
	msocidCheckForOSUpgrade = 0x00042,	// (66) Global_Office_CheckForOSUpgrade
};

enum {
	msoftidNil = -1,
	msoftidVBAHelp         = 0x00000,	// (0) VBAHelpFiles
	msoftidFFMorph         = 0x00001,	// (1) mswds_en.lex
	msoftidProfWiz         = 0x00002,	// (2) proflwiz.exe
	msoftidThemes          = 0x00003,	// (3) THEMESFiles
	msoftidMSAgent         = 0x00004,	// (4) ASSISTANTFiles
	msoftidMSGraph         = 0x00005,	// (5) graph.exe
	msoftidMSEquation      = 0x00006,	// (6) eqnedt32.exe
	msoftidMSQuery         = 0x00007,	// (7) msqry32.exe
	msoftidWebDrive        = 0x00008,	// (8) WebDriveFiles
	msoftidWebDriveUserData = 0x00009,	// (9) WebDriveUserData
	msoftidOfficeUserData  = 0x0000a,	// (10) OfficeUserData
	msoftidMsoCore         = 0x0000b,	// (11) Global_Office_Core
	msoftidHTMLSourceEditing = 0x0000c,	// (12) HTMLSourceEditing
	msoftidWebScripting    = 0x0000d,	// (13) WebScripting
	msoftidSpeechFeature   = 0x0000e,	// (14) SpeechFiles
	msoftidCiceroFeature   = 0x0000f,	// (15) CiceroFiles
	msoftidOWSWebDiscussions = 0x00010,	// (16) owsclt.dll
	msoftidMediaStore      = 0x00011,	// (17) CAGFiles
	msoftidCAGCategoryFiles = 0x00012,	// (18) CAGCategoryFiles
	msoftidmstoreOfficeThemes = 0x00013,	// (19) CAGOffice10
	msoftidVBAFiles        = 0x00014,	// (20) VBAFiles
	msoftidWebDebugging    = 0x00015,	// (21) WebDebugging
	msoftidCAGCat10        = 0x00016,	// (22) CAGCat10
	msoftidCAGCat10Clips   = 0x00017,	// (23) CAGCat10Clips
	msoftidCAGOffice10Clips = 0x00018,	// (24) CAGOffice10Clips
	msoftidDesignerTemplates = 0x00019,	// (25) DesignerTemplateFiles
};

// Remapped identifiers
#define CVT_CORE_VERSION_LS 0x00090000
#define CVT_CORE_VERSION_MS 0x07D0000B
#define CVT_CORE_VERSION_STRING L"2000.11.9.0"
#define CVT_WORD97_VERSION_LS 0x00090000
#define CVT_WORD97_VERSION_MS 0x07D0000B
#define CVT_WORD97_VERSION_STRING L"2000.11.9.0"
#define VBA_VERSION_LS 0x005B0008
#define VBA_VERSION_MS 0x00060003
#define VBA_VERSION_STRING L"6.3.91.8"
#define msofidMSE msofidMSE10
#define msoqfidVbaErrorHelp msoqfidVbaHelp

// GUID defines
#ifndef VSMSODEBUG
#define ACCESS_CORE_GUID L"{CC29E967-7BC2-11D1-A921-00A0C91E2AA3}"
#define DESIGNER_CORE_GUID L"{D0CC86C2-4C60-11D3-B37F-00C04F68712C}"
#define EXCEL_CORE_GUID L"{5572D282-F5E5-11D3-A8E8-0060083FD8D3}"
#define OUTLOOK_CORE_GUID L"{DE6A97CD-93BF-455C-A45F-7694344B686F}"
#define POWERPNT_CORE_GUID L"{FC780C4C-F066-40E0-B720-DA0F779B81A9}"
#define PUBLISHER_CORE_GUID L"{CEC0B86F-7548-4BC0-B05C-E7150E4397E3}"
#define WORD_CORE_GUID L"{8E46FEFA-D973-6294-B305-E968CEDFFCB9}"
#else
#define ACCESS_CORE_GUID L"{CC29E967-7BC2-11D1-A921-10A0C91E2AA3}"
#define DESIGNER_CORE_GUID L"{D0CC86C2-4C60-11D3-B37F-10C04F68712C}"
#define EXCEL_CORE_GUID L"{5572D282-F5E5-11D3-A8E8-1060083FD8D3}"
#define OUTLOOK_CORE_GUID L"{DE6A97CD-93BF-455C-A45F-1694344B686F}"
#define POWERPNT_CORE_GUID L"{FC780C4C-F066-40E0-B720-1A0F779B81A9}"
#define PUBLISHER_CORE_GUID L"{CEC0B86F-7548-4BC0-B05C-17150E4397E3}"
#define WORD_CORE_GUID L"{8E46FEFA-D973-6294-B305-1968CEDFFCB9}"
#endif

#endif // TCDARO_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Inc\office10\msotl.h ===
//-----------------------------------------------------------------------------
// Copyright 1994-2000 Microsoft Corporation.  All Rights Reserved.
//
// File:		msotl.h
// Contents:	This file describes the MSO interfaces.
//-----------------------------------------------------------------------------
/* This header file machine-generated by mktyplib.exe */
/* Interface to type library: Office */

#ifndef _Office_H_
#define _Office_H_

#define IAccessible IAccessible_MSO

DEFINE_GUID(LIBID_Office,0x2DF8D04CL,0x5BFA,0x101B,0xBD,0xE5,0x00,0xAA,0x00,0x44,0xDE,0x52);
#ifndef BEGIN_INTERFACE
#define BEGIN_INTERFACE
#endif

typedef enum {
    msoLineDashStyleMixed = -2,
    msoLineSolid = 1,
    msoLineSquareDot,
    msoLineRoundDot,
    msoLineDash,
    msoLineDashDot,
    msoLineDashDotDot,
    msoLineLongDash,
    msoLineLongDashDot
} MsoLineDashStyle;

typedef enum {
    msoLineStyleMixed = -2,
    msoLineSingle = 1,
    msoLineThinThin,
    msoLineThinThick,
    msoLineThickThin,
    msoLineThickBetweenThin
} MsoLineStyle;

typedef enum {
    msoArrowheadStyleMixed = -2,
    msoArrowheadNone = 1,
    msoArrowheadTriangle,
    msoArrowheadOpen,
    msoArrowheadStealth,
    msoArrowheadDiamond,
    msoArrowheadOval
} MsoArrowheadStyle;

typedef enum {
    msoArrowheadWidthMixed = -2,
    msoArrowheadNarrow = 1,
    msoArrowheadWidthMedium,
    msoArrowheadWide
} MsoArrowheadWidth;

typedef enum {
    msoArrowheadLengthMixed = -2,
    msoArrowheadShort = 1,
    msoArrowheadLengthMedium,
    msoArrowheadLong
} MsoArrowheadLength;

typedef enum {
    msoFillMixed = -2,
    msoFillSolid = 1,
    msoFillPatterned,
    msoFillGradient,
    msoFillTextured,
    msoFillBackground,
    msoFillPicture
} MsoFillType;

typedef enum {
    msoGradientMixed = -2,
    msoGradientHorizontal = 1,
    msoGradientVertical,
    msoGradientDiagonalUp,
    msoGradientDiagonalDown,
    msoGradientFromCorner,
    msoGradientFromTitle,
    msoGradientFromCenter
} MsoGradientStyle;

typedef enum {
    msoGradientColorMixed = -2,
    msoGradientOneColor = 1,
    msoGradientTwoColors,
    msoGradientPresetColors
} MsoGradientColorType;

typedef enum {
    msoTextureTypeMixed = -2,
    msoTexturePreset = 1,
    msoTextureUserDefined
} MsoTextureType;

typedef enum {
    msoPresetTextureMixed = -2,
    msoTexturePapyrus = 1,
    msoTextureCanvas,
    msoTextureDenim,
    msoTextureWovenMat,
    msoTextureWaterDroplets,
    msoTexturePaperBag,
    msoTextureFishFossil,
    msoTextureSand,
    msoTextureGreenMarble,
    msoTextureWhiteMarble,
    msoTextureBrownMarble,
    msoTextureGranite,
    msoTextureNewsprint,
    msoTextureRecycledPaper,
    msoTextureParchment,
    msoTextureStationery,
    msoTextureBlueTissuePaper,
    msoTexturePinkTissuePaper,
    msoTexturePurpleMesh,
    msoTextureBouquet,
    msoTextureCork,
    msoTextureWalnut,
    msoTextureOak,
    msoTextureMediumWood
} MsoPresetTexture;

typedef enum {
    msoPatternMixed = -2,
    msoPattern5Percent = 1,
    msoPattern10Percent,
    msoPattern20Percent,
    msoPattern25Percent,
    msoPattern30Percent,
    msoPattern40Percent,
    msoPattern50Percent,
    msoPattern60Percent,
    msoPattern70Percent,
    msoPattern75Percent,
    msoPattern80Percent,
    msoPattern90Percent,
    msoPatternDarkHorizontal,
    msoPatternDarkVertical,
    msoPatternDarkDownwardDiagonal,
    msoPatternDarkUpwardDiagonal,
    msoPatternSmallCheckerBoard,
    msoPatternTrellis,
    msoPatternLightHorizontal,
    msoPatternLightVertical,
    msoPatternLightDownwardDiagonal,
    msoPatternLightUpwardDiagonal,
    msoPatternSmallGrid,
    msoPatternDottedDiamond,
    msoPatternWideDownwardDiagonal,
    msoPatternWideUpwardDiagonal,
    msoPatternDashedUpwardDiagonal,
    msoPatternDashedDownwardDiagonal,
    msoPatternNarrowVertical,
    msoPatternNarrowHorizontal,
    msoPatternDashedVertical,
    msoPatternDashedHorizontal,
    msoPatternLargeConfetti,
    msoPatternLargeGrid,
    msoPatternHorizontalBrick,
    msoPatternLargeCheckerBoard,
    msoPatternSmallConfetti,
    msoPatternZigZag,
    msoPatternSolidDiamond,
    msoPatternDiagonalBrick,
    msoPatternOutlinedDiamond,
    msoPatternPlaid,
    msoPatternSphere,
    msoPatternWeave,
    msoPatternDottedGrid,
    msoPatternDivot,
    msoPatternShingle,
    msoPatternWave
} MsoPatternType;

typedef enum {
    msoPresetGradientMixed = -2,
    msoGradientEarlySunset = 1,
    msoGradientLateSunset,
    msoGradientNightfall,
    msoGradientDaybreak,
    msoGradientHorizon,
    msoGradientDesert,
    msoGradientOcean,
    msoGradientCalmWater,
    msoGradientFire,
    msoGradientFog,
    msoGradientMoss,
    msoGradientPeacock,
    msoGradientWheat,
    msoGradientParchment,
    msoGradientMahogany,
    msoGradientRainbow,
    msoGradientRainbowII,
    msoGradientGold,
    msoGradientGoldII,
    msoGradientBrass,
    msoGradientChrome,
    msoGradientChromeII,
    msoGradientSilver,
    msoGradientSapphire
} MsoPresetGradientType;

typedef enum {
    msoShadowMixed = -2,
    msoShadow1 = 1,
    msoShadow2,
    msoShadow3,
    msoShadow4,
    msoShadow5,
    msoShadow6,
    msoShadow7,
    msoShadow8,
    msoShadow9,
    msoShadow10,
    msoShadow11,
    msoShadow12,
    msoShadow13,
    msoShadow14,
    msoShadow15,
    msoShadow16,
    msoShadow17,
    msoShadow18,
    msoShadow19,
    msoShadow20
} MsoShadowType;

typedef enum {
    msoTextEffectMixed = -2,
    msoTextEffect1 = 0,
    msoTextEffect2,
    msoTextEffect3,
    msoTextEffect4,
    msoTextEffect5,
    msoTextEffect6,
    msoTextEffect7,
    msoTextEffect8,
    msoTextEffect9,
    msoTextEffect10,
    msoTextEffect11,
    msoTextEffect12,
    msoTextEffect13,
    msoTextEffect14,
    msoTextEffect15,
    msoTextEffect16,
    msoTextEffect17,
    msoTextEffect18,
    msoTextEffect19,
    msoTextEffect20,
    msoTextEffect21,
    msoTextEffect22,
    msoTextEffect23,
    msoTextEffect24,
    msoTextEffect25,
    msoTextEffect26,
    msoTextEffect27,
    msoTextEffect28,
    msoTextEffect29,
    msoTextEffect30
} MsoPresetTextEffect;

typedef enum {
    msoTextEffectShapeMixed = -2,
    msoTextEffectShapePlainText = 1,
    msoTextEffectShapeStop,
    msoTextEffectShapeTriangleUp,
    msoTextEffectShapeTriangleDown,
    msoTextEffectShapeChevronUp,
    msoTextEffectShapeChevronDown,
    msoTextEffectShapeRingInside,
    msoTextEffectShapeRingOutside,
    msoTextEffectShapeArchUpCurve,
    msoTextEffectShapeArchDownCurve,
    msoTextEffectShapeCircleCurve,
    msoTextEffectShapeButtonCurve,
    msoTextEffectShapeArchUpPour,
    msoTextEffectShapeArchDownPour,
    msoTextEffectShapeCirclePour,
    msoTextEffectShapeButtonPour,
    msoTextEffectShapeCurveUp,
    msoTextEffectShapeCurveDown,
    msoTextEffectShapeCanUp,
    msoTextEffectShapeCanDown,
    msoTextEffectShapeWave1,
    msoTextEffectShapeWave2,
    msoTextEffectShapeDoubleWave1,
    msoTextEffectShapeDoubleWave2,
    msoTextEffectShapeInflate,
    msoTextEffectShapeDeflate,
    msoTextEffectShapeInflateBottom,
    msoTextEffectShapeDeflateBottom,
    msoTextEffectShapeInflateTop,
    msoTextEffectShapeDeflateTop,
    msoTextEffectShapeDeflateInflate,
    msoTextEffectShapeDeflateInflateDeflate,
    msoTextEffectShapeFadeRight,
    msoTextEffectShapeFadeLeft,
    msoTextEffectShapeFadeUp,
    msoTextEffectShapeFadeDown,
    msoTextEffectShapeSlantUp,
    msoTextEffectShapeSlantDown,
    msoTextEffectShapeCascadeUp,
    msoTextEffectShapeCascadeDown
} MsoPresetTextEffectShape;

typedef enum {
    msoTextEffectAlignmentMixed = -2,
    msoTextEffectAlignmentLeft = 1,
    msoTextEffectAlignmentCentered,
    msoTextEffectAlignmentRight,
    msoTextEffectAlignmentLetterJustify,
    msoTextEffectAlignmentWordJustify,
    msoTextEffectAlignmentStretchJustify
} MsoTextEffectAlignment;

typedef enum {
    msoPresetLightingDirectionMixed = -2,
    msoLightingTopLeft = 1,
    msoLightingTop,
    msoLightingTopRight,
    msoLightingLeft,
    msoLightingNone,
    msoLightingRight,
    msoLightingBottomLeft,
    msoLightingBottom,
    msoLightingBottomRight
} MsoPresetLightingDirection;

typedef enum {
    msoPresetLightingSoftnessMixed = -2,
    msoLightingDim = 1,
    msoLightingNormal,
    msoLightingBright
} MsoPresetLightingSoftness;

typedef enum {
    msoPresetMaterialMixed = -2,
    msoMaterialMatte = 1,
    msoMaterialPlastic,
    msoMaterialMetal,
    msoMaterialWireFrame
} MsoPresetMaterial;

typedef enum {
    msoPresetExtrusionDirectionMixed = -2,
    msoExtrusionBottomRight = 1,
    msoExtrusionBottom,
    msoExtrusionBottomLeft,
    msoExtrusionRight,
    msoExtrusionNone,
    msoExtrusionLeft,
    msoExtrusionTopRight,
    msoExtrusionTop,
    msoExtrusionTopLeft
} MsoPresetExtrusionDirection;

typedef enum {
    msoPresetThreeDFormatMixed = -2,
    msoThreeD1 = 1,
    msoThreeD2,
    msoThreeD3,
    msoThreeD4,
    msoThreeD5,
    msoThreeD6,
    msoThreeD7,
    msoThreeD8,
    msoThreeD9,
    msoThreeD10,
    msoThreeD11,
    msoThreeD12,
    msoThreeD13,
    msoThreeD14,
    msoThreeD15,
    msoThreeD16,
    msoThreeD17,
    msoThreeD18,
    msoThreeD19,
    msoThreeD20
} MsoPresetThreeDFormat;

typedef enum {
    msoExtrusionColorTypeMixed = -2,
    msoExtrusionColorAutomatic = 1,
    msoExtrusionColorCustom
} MsoExtrusionColorType;

typedef enum {
    msoAlignLefts = 0,
    msoAlignCenters,
    msoAlignRights,
    msoAlignTops,
    msoAlignMiddles,
    msoAlignBottoms
} MsoAlignCmd;

typedef enum {
    msoDistributeHorizontally = 0,
    msoDistributeVertically
} MsoDistributeCmd;

typedef enum {
    msoConnectorTypeMixed = -2,
    msoConnectorStraight = 1,
    msoConnectorElbow,
    msoConnectorCurve
} MsoConnectorType;

typedef enum {
    msoHorizontalAnchorMixed = -2,
    msoAnchorNone = 1,
    msoAnchorCenter
} MsoHorizontalAnchor;

typedef enum {
    msoVerticalAnchorMixed = -2,
    msoAnchorTop = 1,
    msoAnchorTopBaseline,
    msoAnchorMiddle,
    msoAnchorBottom,
    msoAnchorBottomBaseLine
} MsoVerticalAnchor;

typedef enum {
    msoOrientationMixed = -2,
    msoOrientationHorizontal = 1,
    msoOrientationVertical
} MsoOrientation;

typedef enum {
    msoBringToFront = 0,
    msoSendToBack,
    msoBringForward,
    msoSendBackward,
    msoBringInFrontOfText,
    msoSendBehindText
} MsoZOrderCmd;

typedef enum {
    msoSegmentLine = 0,
    msoSegmentCurve
} MsoSegmentType;

typedef enum {
    msoEditingAuto = 0,
    msoEditingCorner,
    msoEditingSmooth,
    msoEditingSymmetric
} MsoEditingType;

typedef enum {
    msoShapeMixed = -2,
    msoShapeRectangle = 1,
    msoShapeParallelogram,
    msoShapeTrapezoid,
    msoShapeDiamond,
    msoShapeRoundedRectangle,
    msoShapeOctagon,
    msoShapeIsoscelesTriangle,
    msoShapeRightTriangle,
    msoShapeOval,
    msoShapeHexagon,
    msoShapeCross,
    msoShapeRegularPentagon,
    msoShapeCan,
    msoShapeCube,
    msoShapeBevel,
    msoShapeFoldedCorner,
    msoShapeSmileyFace,
    msoShapeDonut,
    msoShapeNoSymbol,
    msoShapeBlockArc,
    msoShapeHeart,
    msoShapeLightningBolt,
    msoShapeSun,
    msoShapeMoon,
    msoShapeArc,
    msoShapeDoubleBracket,
    msoShapeDoubleBrace,
    msoShapePlaque,
    msoShapeLeftBracket,
    msoShapeRightBracket,
    msoShapeLeftBrace,
    msoShapeRightBrace,
    msoShapeRightArrow,
    msoShapeLeftArrow,
    msoShapeUpArrow,
    msoShapeDownArrow,
    msoShapeLeftRightArrow,
    msoShapeUpDownArrow,
    msoShapeQuadArrow,
    msoShapeLeftRightUpArrow,
    msoShapeBentArrow,
    msoShapeUTurnArrow,
    msoShapeLeftUpArrow,
    msoShapeBentUpArrow,
    msoShapeCurvedRightArrow,
    msoShapeCurvedLeftArrow,
    msoShapeCurvedUpArrow,
    msoShapeCurvedDownArrow,
    msoShapeStripedRightArrow,
    msoShapeNotchedRightArrow,
    msoShapePentagon,
    msoShapeChevron,
    msoShapeRightArrowCallout,
    msoShapeLeftArrowCallout,
    msoShapeUpArrowCallout,
    msoShapeDownArrowCallout,
    msoShapeLeftRightArrowCallout,
    msoShapeUpDownArrowCallout,
    msoShapeQuadArrowCallout,
    msoShapeCircularArrow,
    msoShapeFlowchartProcess,
    msoShapeFlowchartAlternateProcess,
    msoShapeFlowchartDecision,
    msoShapeFlowchartData,
    msoShapeFlowchartPredefinedProcess,
    msoShapeFlowchartInternalStorage,
    msoShapeFlowchartDocument,
    msoShapeFlowchartMultidocument,
    msoShapeFlowchartTerminator,
    msoShapeFlowchartPreparation,
    msoShapeFlowchartManualInput,
    msoShapeFlowchartManualOperation,
    msoShapeFlowchartConnector,
    msoShapeFlowchartOffpageConnector,
    msoShapeFlowchartCard,
    msoShapeFlowchartPunchedTape,
    msoShapeFlowchartSummingJunction,
    msoShapeFlowchartOr,
    msoShapeFlowchartCollate,
    msoShapeFlowchartSort,
    msoShapeFlowchartExtract,
    msoShapeFlowchartMerge,
    msoShapeFlowchartStoredData,
    msoShapeFlowchartDelay,
    msoShapeFlowchartSequentialAccessStorage,
    msoShapeFlowchartMagneticDisk,
    msoShapeFlowchartDirectAccessStorage,
    msoShapeFlowchartDisplay,
    msoShapeExplosion1,
    msoShapeExplosion2,
    msoShape4pointStar,
    msoShape5pointStar,
    msoShape8pointStar,
    msoShape16pointStar,
    msoShape24pointStar,
    msoShape32pointStar,
    msoShapeUpRibbon,
    msoShapeDownRibbon,
    msoShapeCurvedUpRibbon,
    msoShapeCurvedDownRibbon,
    msoShapeVerticalScroll,
    msoShapeHorizontalScroll,
    msoShapeWave,
    msoShapeDoubleWave,
    msoShapeRectangularCallout,
    msoShapeRoundedRectangularCallout,
    msoShapeOvalCallout,
    msoShapeCloudCallout,
    msoShapeLineCallout1,
    msoShapeLineCallout2,
    msoShapeLineCallout3,
    msoShapeLineCallout4,
    msoShapeLineCallout1AccentBar,
    msoShapeLineCallout2AccentBar,
    msoShapeLineCallout3AccentBar,
    msoShapeLineCallout4AccentBar,
    msoShapeLineCallout1NoBorder,
    msoShapeLineCallout2NoBorder,
    msoShapeLineCallout3NoBorder,
    msoShapeLineCallout4NoBorder,
    msoShapeLineCallout1BorderandAccentBar,
    msoShapeLineCallout2BorderandAccentBar,
    msoShapeLineCallout3BorderandAccentBar,
    msoShapeLineCallout4BorderandAccentBar,
    msoShapeActionButtonCustom,
    msoShapeActionButtonHome,
    msoShapeActionButtonHelp,
    msoShapeActionButtonInformation,
    msoShapeActionButtonBackorPrevious,
    msoShapeActionButtonForwardorNext,
    msoShapeActionButtonBeginning,
    msoShapeActionButtonEnd,
    msoShapeActionButtonReturn,
    msoShapeActionButtonDocument,
    msoShapeActionButtonSound,
    msoShapeActionButtonMovie,
    msoShapeBalloon,
    msoShapeNotPrimitive
} MsoAutoShapeType;

typedef enum {
    msoShapeTypeMixed = -2,
    msoAutoShape = 1,
    msoCallout,
    msoChart,
    msoComment,
    msoFreeform,
    msoGroup,
    msoEmbeddedOLEObject,
    msoFormControl,
    msoLine,
    msoLinkedOLEObject,
    msoLinkedPicture,
    msoOLEControlObject,
    msoPicture,
    msoPlaceholder,
    msoTextEffect,
    msoMedia,
    msoTextBox,
    msoScriptAnchor,
    msoTable,
    msoCanvas,
    msoDiagram
} MsoShapeType;

typedef enum {
    msoFlipHorizontal = 0,
    msoFlipVertical
} MsoFlipCmd;

typedef enum {
    msoTrue = -1,
    msoFalse,
    msoCTrue,
    msoTriStateToggle = -3,
    msoTriStateMixed = -2
} MsoTriState;

typedef enum {
    msoColorTypeMixed = -2,
    msoColorTypeRGB = 1,
    msoColorTypeScheme,
    msoColorTypeCMYK,
    msoColorTypeCMS,
    msoColorTypeInk
} MsoColorType;

typedef enum {
    msoPictureMixed = -2,
    msoPictureAutomatic = 1,
    msoPictureGrayscale,
    msoPictureBlackAndWhite,
    msoPictureWatermark
} MsoPictureColorType;

typedef enum {
    msoCalloutAngleMixed = -2,
    msoCalloutAngleAutomatic = 1,
    msoCalloutAngle30,
    msoCalloutAngle45,
    msoCalloutAngle60,
    msoCalloutAngle90
} MsoCalloutAngleType;

typedef enum {
    msoCalloutDropMixed = -2,
    msoCalloutDropCustom = 1,
    msoCalloutDropTop,
    msoCalloutDropCenter,
    msoCalloutDropBottom
} MsoCalloutDropType;

typedef enum {
    msoCalloutMixed = -2,
    msoCalloutOne = 1,
    msoCalloutTwo,
    msoCalloutThree,
    msoCalloutFour
} MsoCalloutType;

typedef enum {
    msoBlackWhiteMixed = -2,
    msoBlackWhiteAutomatic = 1,
    msoBlackWhiteGrayScale,
    msoBlackWhiteLightGrayScale,
    msoBlackWhiteInverseGrayScale,
    msoBlackWhiteGrayOutline,
    msoBlackWhiteBlackTextAndLine,
    msoBlackWhiteHighContrast,
    msoBlackWhiteBlack,
    msoBlackWhiteWhite,
    msoBlackWhiteDontShow
} MsoBlackWhiteMode;

typedef enum {
    msoIntegerMixed = 32768,
    msoSingleMixed = 0x80000000
} MsoMixedType;

typedef enum {
    msoTextOrientationMixed = -2,
    msoTextOrientationHorizontal = 1,
    msoTextOrientationUpward,
    msoTextOrientationDownward,
    msoTextOrientationVerticalFarEast,
    msoTextOrientationVertical,
    msoTextOrientationHorizontalRotatedFarEast
} MsoTextOrientation;

typedef enum {
    msoScaleFromTopLeft = 0,
    msoScaleFromMiddle,
    msoScaleFromBottomRight
} MsoScaleFrom;

typedef long MsoRGBType;

typedef enum {
    msoBarLeft = 0,
    msoBarTop,
    msoBarRight,
    msoBarBottom,
    msoBarFloating,
    msoBarPopup,
    msoBarMenuBar
} MsoBarPosition;

typedef enum {
    msoBarNoProtection = 0,
    msoBarNoCustomize = 1,
    msoBarNoResize = 2,
    msoBarNoMove = 4,
    msoBarNoChangeVisible = 8,
    msoBarNoChangeDock = 16,
    msoBarNoVerticalDock = 32,
    msoBarNoHorizontalDock = 64
} MsoBarProtection;

typedef enum {
    msoBarTypeNormal = 0,
    msoBarTypeMenuBar,
    msoBarTypePopup
} MsoBarType;

typedef enum {
    msoControlCustom = 0,
    msoControlButton,
    msoControlEdit,
    msoControlDropdown,
    msoControlComboBox,
    msoControlButtonDropdown,
    msoControlSplitDropdown,
    msoControlOCXDropdown,
    msoControlGenericDropdown,
    msoControlGraphicDropdown,
    msoControlPopup,
    msoControlGraphicPopup,
    msoControlButtonPopup,
    msoControlSplitButtonPopup,
    msoControlSplitButtonMRUPopup,
    msoControlLabel,
    msoControlExpandingGrid,
    msoControlSplitExpandingGrid,
    msoControlGrid,
    msoControlGauge,
    msoControlGraphicCombo,
    msoControlPane,
    msoControlActiveX,
    msoControlSpinner,
    msoControlLabelEx,
    msoControlWorkPane,
    msoControlAutoCompleteCombo
} MsoControlType;

typedef enum {
    msoButtonUp = 0,
    msoButtonDown = -1,
    msoButtonMixed = 2
} MsoButtonState;

typedef enum {
    msoControlOLEUsageNeither = 0,
    msoControlOLEUsageServer,
    msoControlOLEUsageClient,
    msoControlOLEUsageBoth
} MsoControlOLEUsage;

typedef enum {
    msoButtonWrapText = 4,
    msoButtonTextBelow = 8
} MsoButtonStyleHidden;

typedef enum {
    msoButtonAutomatic = 0,
    msoButtonIcon = 1,
    msoButtonCaption = 2,
    msoButtonIconAndCaption = 3,
    msoButtonIconAndWrapCaption = 7,
    msoButtonIconAndCaptionBelow = 11,
    msoButtonWrapCaption = 14,
    msoButtonIconAndWrapCaptionBelow = 15
} MsoButtonStyle;

typedef enum {
    msoComboNormal = 0,
    msoComboLabel = 1
} MsoComboStyle;

typedef enum {
    msoOLEMenuGroupNone = -1,
    msoOLEMenuGroupFile = 0,
    msoOLEMenuGroupEdit,
    msoOLEMenuGroupContainer,
    msoOLEMenuGroupObject,
    msoOLEMenuGroupWindow,
    msoOLEMenuGroupHelp
} MsoOLEMenuGroup;

typedef enum {
    msoMenuAnimationNone = 0,
    msoMenuAnimationRandom,
    msoMenuAnimationUnfold,
    msoMenuAnimationSlide
} MsoMenuAnimation;

typedef enum {
    msoBarRowFirst = 0,
    msoBarRowLast = -1
} MsoBarRow;

typedef enum {
    msoCommandBarButtonHyperlinkNone = 0,
    msoCommandBarButtonHyperlinkOpen,
    msoCommandBarButtonHyperlinkInsertPicture
} MsoCommandBarButtonHyperlinkType;

typedef enum {
    msoHyperlinkRange = 0,
    msoHyperlinkShape = 1,
    msoHyperlinkInlineShape = 2
} MsoHyperlinkType;

typedef enum {
    msoMethodGet = 0,
    msoMethodPost = 1
} MsoExtraInfoMethod;

typedef enum {
    msoAnimationIdle = 1,
    msoAnimationGreeting = 2,
    msoAnimationGoodbye = 3,
    msoAnimationBeginSpeaking = 4,
    msoAnimationRestPose = 5,
    msoAnimationCharacterSuccessMajor = 6,
    msoAnimationGetAttentionMajor = 11,
    msoAnimationGetAttentionMinor = 12,
    msoAnimationSearching = 13,
    msoAnimationPrinting = 18,
    msoAnimationGestureRight = 19,
    msoAnimationWritingNotingSomething = 22,
    msoAnimationWorkingAtSomething = 23,
    msoAnimationThinking = 24,
    msoAnimationSendingMail = 25,
    msoAnimationListensToComputer = 26,
    msoAnimationDisappear = 31,
    msoAnimationAppear = 32,
    msoAnimationGetArtsy = 100,
    msoAnimationGetTechy = 101,
    msoAnimationGetWizardy = 102,
    msoAnimationCheckingSomething = 103,
    msoAnimationLookDown = 104,
    msoAnimationLookDownLeft = 105,
    msoAnimationLookDownRight = 106,
    msoAnimationLookLeft = 107,
    msoAnimationLookRight = 108,
    msoAnimationLookUp = 109,
    msoAnimationLookUpLeft = 110,
    msoAnimationLookUpRight = 111,
    msoAnimationSaving = 112,
    msoAnimationGestureDown = 113,
    msoAnimationGestureLeft = 114,
    msoAnimationGestureUp = 115,
    msoAnimationEmptyTrash = 116
} MsoAnimationType;

typedef enum {
    msoButtonSetNone = 0,
    msoButtonSetOK = 1,
    msoButtonSetCancel = 2,
    msoButtonSetOkCancel = 3,
    msoButtonSetYesNo = 4,
    msoButtonSetYesNoCancel = 5,
    msoButtonSetBackClose = 6,
    msoButtonSetNextClose = 7,
    msoButtonSetBackNextClose = 8,
    msoButtonSetRetryCancel = 9,
    msoButtonSetAbortRetryIgnore = 10,
    msoButtonSetSearchClose = 11,
    msoButtonSetBackNextSnooze = 12,
    msoButtonSetTipsOptionsClose = 13,
    msoButtonSetYesAllNoCancel = 14
} MsoButtonSetType;

typedef enum {
    msoIconNone = 0,
    msoIconAlert = 2,
    msoIconTip,
    msoIconAlertInfo,
    msoIconAlertWarning,
    msoIconAlertQuery,
    msoIconAlertCritical
} MsoIconType;

typedef enum {
    msoBalloonTypeButtons = 0,
    msoBalloonTypeBullets,
    msoBalloonTypeNumbers
} MsoBalloonType;

typedef enum {
    msoModeModal = 0,
    msoModeAutoDown,
    msoModeModeless
} MsoModeType;

typedef enum {
    msoBalloonErrorNone = 0,
    msoBalloonErrorOther = 1,
    msoBalloonErrorTooBig = 2,
    msoBalloonErrorOutOfMemory = 3,
    msoBalloonErrorBadPictureRef = 4,
    msoBalloonErrorBadReference = 5,
    msoBalloonErrorButtonlessModal = 6,
    msoBalloonErrorButtonModeless = 7,
    msoBalloonErrorBadCharacter = 8,
    msoBalloonErrorCOMFailure = 9,
    msoBalloonErrorCharNotTopmostForModal = 10,
    msoBalloonErrorTooManyControls = 11
} MsoBalloonErrorType;

typedef enum {
    msoWizardActInactive = 0,
    msoWizardActActive = 1,
    msoWizardActSuspend = 2,
    msoWizardActResume = 3
} MsoWizardActType;

typedef enum {
    msoWizardMsgLocalStateOn = 1,
    msoWizardMsgLocalStateOff = 2,
    msoWizardMsgShowHelp = 3,
    msoWizardMsgSuspending = 4,
    msoWizardMsgResuming = 5
} MsoWizardMsgType;

typedef enum {
    msoBalloonButtonYesToAll = -15,
    msoBalloonButtonOptions = -14,
    msoBalloonButtonTips = -13,
    msoBalloonButtonClose = -12,
    msoBalloonButtonSnooze = -11,
    msoBalloonButtonSearch = -10,
    msoBalloonButtonIgnore = -9,
    msoBalloonButtonAbort = -8,
    msoBalloonButtonRetry = -7,
    msoBalloonButtonNext = -6,
    msoBalloonButtonBack = -5,
    msoBalloonButtonNo = -4,
    msoBalloonButtonYes = -3,
    msoBalloonButtonCancel = -2,
    msoBalloonButtonOK = -1,
    msoBalloonButtonNull = 0
} MsoBalloonButtonType;

typedef enum {
    offPropertyTypeNumber = 1,
    offPropertyTypeBoolean = 2,
    offPropertyTypeDate = 3,
    offPropertyTypeString = 4,
    offPropertyTypeFloat = 5
} DocProperties;

typedef enum {
    msoPropertyTypeNumber = 1,
    msoPropertyTypeBoolean = 2,
    msoPropertyTypeDate = 3,
    msoPropertyTypeString = 4,
    msoPropertyTypeFloat = 5
} MsoDocProperties;

typedef enum {
    msoLanguageIDInstall = 1,
    msoLanguageIDUI = 2,
    msoLanguageIDHelp = 3,
    msoLanguageIDExeMode = 4,
    msoLanguageIDUIPrevious = 5
} MsoAppLanguageID;

typedef enum {
    MsoFarEastLineBreakLanguageJapanese = 1041,
    MsoFarEastLineBreakLanguageKorean = 1042,
    MsoFarEastLineBreakLanguageSimplifiedChinese = 2052,
    MsoFarEastLineBreakLanguageTraditionalChinese = 1028
} MsoFarEastLineBreakLanguageID;

typedef enum tagMsoOrgChartOrientation MsoOrgChartOrientation;

typedef enum tagMsoDiagramType MsoDiagramType;

typedef enum tagMsoDiagramNodeType MsoDiagramNodeType;

typedef enum {
    msoFeatureInstallNone = 0,
    msoFeatureInstallOnDemand = 1,
    msoFeatureInstallOnDemandWithUI = 2
} MsoFeatureInstall;

interface CommandBars;

#ifdef __cplusplus
class MsoCommandBars;
#endif

interface CommandBar;

interface CommandBarControls;

interface CommandBarControl;

interface COMAddIn;

interface COMAddIns;

interface Adjustments;

interface CalloutFormat;

interface ColorFormat;

interface ConnectorFormat;

interface FillFormat;

interface FreeformBuilder;

interface GroupShapes;

interface CanvasShapes;

interface LineFormat;

interface ShapeNode;

interface ShapeNodes;

interface PictureFormat;

interface ShadowFormat;

interface Shape;

interface ShapeRange;

interface Shapes;

interface Signature;

interface TextEffectFormat;

interface TextFrame;

interface ThreeDFormat;

interface IMsoDiagram;

interface DiagramNode;

interface DiagramNodes;

interface DiagramNodeChildren;

interface FileDialogFilter;

interface FileDialogFilters;

interface FileDialogSelectedItems;

interface FileDialog;

interface ScopeFolder;

interface SearchScopes;

interface SearchFolders;

interface FileTypes;

DEFINE_GUID(IID_IAccessible,0x618736E0L,0x3C3D,0x11CF,0x81,0x0C,0x00,0xAA,0x00,0x38,0x9B,0x71);

/* Definition of interface: IAccessible */
#undef INTERFACE
#define INTERFACE IAccessible

DECLARE_INTERFACE_(IAccessible, IDispatch)
{
BEGIN_INTERFACE
#ifndef NO_BASEINTERFACE_FUNCS

    /* IUnknown methods */
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG, AddRef)(THIS) PURE;
    STDMETHOD_(ULONG, Release)(THIS) PURE;

    /* IDispatch methods */
    STDMETHOD(GetTypeInfoCount)(THIS_ UINT FAR* pctinfo) PURE;

    STDMETHOD(GetTypeInfo)(
      THIS_
      UINT itinfo,
      LCID lcid,
      ITypeInfo FAR* FAR* pptinfo) PURE;

    STDMETHOD(GetIDsOfNames)(
      THIS_
      REFIID riid,
      OLECHAR FAR* FAR* rgszNames,
      UINT cNames,
      LCID lcid,
      DISPID FAR* rgdispid) PURE;

    STDMETHOD(Invoke)(
      THIS_
      DISPID dispidMember,
      REFIID riid,
      LCID lcid,
      WORD wFlags,
      DISPPARAMS FAR* pdispparams,
      VARIANT FAR* pvarResult,
      EXCEPINFO FAR* pexcepinfo,
      UINT FAR* puArgErr) PURE;
#endif

    /* IAccessible methods */
    STDMETHOD(get_accParent)(THIS_ IDispatch * FAR* ppdispParent) PURE;
    STDMETHOD(get_accChildCount)(THIS_ long FAR* pcountChildren) PURE;
    STDMETHOD(get_accChild)(THIS_ VARIANT varChild, IDispatch * FAR* ppdispChild) PURE;
    STDMETHOD(get_accName)(THIS_ VARIANT varChild, BSTR FAR* pszName) PURE;
    STDMETHOD(get_accValue)(THIS_ VARIANT varChild, BSTR FAR* pszValue) PURE;
    STDMETHOD(get_accDescription)(THIS_ VARIANT varChild, BSTR FAR* pszDescription) PURE;
    STDMETHOD(get_accRole)(THIS_ VARIANT varChild, VARIANT FAR* pvarRole) PURE;
    STDMETHOD(get_accState)(THIS_ VARIANT varChild, VARIANT FAR* pvarState) PURE;
    STDMETHOD(get_accHelp)(THIS_ VARIANT varChild, BSTR FAR* pszHelp) PURE;
    STDMETHOD(get_accHelpTopic)(THIS_ BSTR FAR* pszHelpFile, VARIANT varChild, long FAR* pidTopic) PURE;
    STDMETHOD(get_accKeyboardShortcut)(THIS_ VARIANT varChild, BSTR FAR* pszKeyboardShortcut) PURE;
    STDMETHOD(get_accFocus)(THIS_ VARIANT FAR* pvarChild) PURE;
    STDMETHOD(get_accSelection)(THIS_ VARIANT FAR* pvarChildren) PURE;
    STDMETHOD(get_accDefaultAction)(THIS_ VARIANT varChild, BSTR FAR* pszDefaultAction) PURE;
    STDMETHOD(accSelect)(THIS_ long flagsSelect, VARIANT varChild) PURE;
    STDMETHOD(accLocation)(THIS_ long FAR* pxLeft, long FAR* pyTop, long FAR* pcxWidth, long FAR* pcyHeight, VARIANT varChild) PURE;
    STDMETHOD(accNavigate)(THIS_ long navDir, VARIANT varStart, VARIANT FAR* pvarEndUpAt) PURE;
    STDMETHOD(accHitTest)(THIS_ long xLeft, long yTop, VARIANT FAR* pvarChild) PURE;
    STDMETHOD(accDoDefaultAction)(THIS_ VARIANT varChild) PURE;
    STDMETHOD(put_accName)(THIS_ VARIANT varChild, BSTR szName) PURE;
    STDMETHOD(put_accValue)(THIS_ VARIANT varChild, BSTR szValue) PURE;
};

DEFINE_GUID(IID__IMsoDispObj,0x000C0300L,0x0000,0x0000,0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46);

/* Definition of interface: _IMsoDispObj */
#undef INTERFACE
#define INTERFACE _IMsoDispObj

DECLARE_INTERFACE_(_IMsoDispObj, IDispatch)
{
BEGIN_INTERFACE
#ifndef NO_BASEINTERFACE_FUNCS

    /* IUnknown methods */
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG, AddRef)(THIS) PURE;
    STDMETHOD_(ULONG, Release)(THIS) PURE;

    /* IDispatch methods */
    STDMETHOD(GetTypeInfoCount)(THIS_ UINT FAR* pctinfo) PURE;

    STDMETHOD(GetTypeInfo)(
      THIS_
      UINT itinfo,
      LCID lcid,
      ITypeInfo FAR* FAR* pptinfo) PURE;

    STDMETHOD(GetIDsOfNames)(
      THIS_
      REFIID riid,
      OLECHAR FAR* FAR* rgszNames,
      UINT cNames,
      LCID lcid,
      DISPID FAR* rgdispid) PURE;

    STDMETHOD(Invoke)(
      THIS_
      DISPID dispidMember,
      REFIID riid,
      LCID lcid,
      WORD wFlags,
      DISPPARAMS FAR* pdispparams,
      VARIANT FAR* pvarResult,
      EXCEPINFO FAR* pexcepinfo,
      UINT FAR* puArgErr) PURE;
#endif

    /* _IMsoDispObj methods */
    STDMETHOD(get_Application)(THIS_ IDispatch * FAR* ppidisp) PURE;
    STDMETHOD(get_Creator)(THIS_ long FAR* plCreator) PURE;
};

DEFINE_GUID(IID__IMsoOleAccDispObj,0x000C0301L,0x0000,0x0000,0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46);

/* Definition of interface: _IMsoOleAccDispObj */
#undef INTERFACE
#define INTERFACE _IMsoOleAccDispObj

DECLARE_INTERFACE_(_IMsoOleAccDispObj, IAccessible)
{
BEGIN_INTERFACE
#ifndef NO_BASEINTERFACE_FUNCS

    /* IUnknown methods */
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG, AddRef)(THIS) PURE;
    STDMETHOD_(ULONG, Release)(THIS) PURE;

    /* IDispatch methods */
    STDMETHOD(GetTypeInfoCount)(THIS_ UINT FAR* pctinfo) PURE;

    STDMETHOD(GetTypeInfo)(
      THIS_
      UINT itinfo,
      LCID lcid,
      ITypeInfo FAR* FAR* pptinfo) PURE;

    STDMETHOD(GetIDsOfNames)(
      THIS_
      REFIID riid,
      OLECHAR FAR* FAR* rgszNames,
      UINT cNames,
      LCID lcid,
      DISPID FAR* rgdispid) PURE;

    STDMETHOD(Invoke)(
      THIS_
      DISPID dispidMember,
      REFIID riid,
      LCID lcid,
      WORD wFlags,
      DISPPARAMS FAR* pdispparams,
      VARIANT FAR* pvarResult,
      EXCEPINFO FAR* pexcepinfo,
      UINT FAR* puArgErr) PURE;

    /* IAccessible methods */
    STDMETHOD(get_accParent)(THIS_ IDispatch * FAR* ppdispParent) PURE;
    STDMETHOD(get_accChildCount)(THIS_ long FAR* pcountChildren) PURE;
    STDMETHOD(get_accChild)(THIS_ VARIANT varChild, IDispatch * FAR* ppdispChild) PURE;
    STDMETHOD(get_accName)(THIS_ VARIANT varChild, BSTR FAR* pszName) PURE;
    STDMETHOD(get_accValue)(THIS_ VARIANT varChild, BSTR FAR* pszValue) PURE;
    STDMETHOD(get_accDescription)(THIS_ VARIANT varChild, BSTR FAR* pszDescription) PURE;
    STDMETHOD(get_accRole)(THIS_ VARIANT varChild, VARIANT FAR* pvarRole) PURE;
    STDMETHOD(get_accState)(THIS_ VARIANT varChild, VARIANT FAR* pvarState) PURE;
    STDMETHOD(get_accHelp)(THIS_ VARIANT varChild, BSTR FAR* pszHelp) PURE;
    STDMETHOD(get_accHelpTopic)(THIS_ BSTR FAR* pszHelpFile, VARIANT varChild, long FAR* pidTopic) PURE;
    STDMETHOD(get_accKeyboardShortcut)(THIS_ VARIANT varChild, BSTR FAR* pszKeyboardShortcut) PURE;
    STDMETHOD(get_accFocus)(THIS_ VARIANT FAR* pvarChild) PURE;
    STDMETHOD(get_accSelection)(THIS_ VARIANT FAR* pvarChildren) PURE;
    STDMETHOD(get_accDefaultAction)(THIS_ VARIANT varChild, BSTR FAR* pszDefaultAction) PURE;
    STDMETHOD(accSelect)(THIS_ long flagsSelect, VARIANT varChild) PURE;
    STDMETHOD(accLocation)(THIS_ long FAR* pxLeft, long FAR* pyTop, long FAR* pcxWidth, long FAR* pcyHeight, VARIANT varChild) PURE;
    STDMETHOD(accNavigate)(THIS_ long navDir, VARIANT varStart, VARIANT FAR* pvarEndUpAt) PURE;
    STDMETHOD(accHitTest)(THIS_ long xLeft, long yTop, VARIANT FAR* pvarChild) PURE;
    STDMETHOD(accDoDefaultAction)(THIS_ VARIANT varChild) PURE;
    STDMETHOD(put_accName)(THIS_ VARIANT varChild, BSTR szName) PURE;
    STDMETHOD(put_accValue)(THIS_ VARIANT varChild, BSTR szValue) PURE;
#endif

    /* _IMsoOleAccDispObj methods */
    STDMETHOD(get_Application)(THIS_ IDispatch * FAR* ppidisp) PURE;
    STDMETHOD(get_Creator)(THIS_ long FAR* plCreator) PURE;
};

DEFINE_GUID(IID_CommandBars,0x000C0302L,0x0000,0x0000,0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46);

/* Definition of interface: CommandBars */
#undef INTERFACE
#define INTERFACE CommandBars

DECLARE_INTERFACE_(CommandBars, _IMsoDispObj)
{
BEGIN_INTERFACE
#ifndef NO_BASEINTERFACE_FUNCS

    /* IUnknown methods */
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG, AddRef)(THIS) PURE;
    STDMETHOD_(ULONG, Release)(THIS) PURE;

    /* IDispatch methods */
    STDMETHOD(GetTypeInfoCount)(THIS_ UINT FAR* pctinfo) PURE;

    STDMETHOD(GetTypeInfo)(
      THIS_
      UINT itinfo,
      LCID lcid,
      ITypeInfo FAR* FAR* pptinfo) PURE;

    STDMETHOD(GetIDsOfNames)(
      THIS_
      REFIID riid,
      OLECHAR FAR* FAR* rgszNames,
      UINT cNames,
      LCID lcid,
      DISPID FAR* rgdispid) PURE;

    STDMETHOD(Invoke)(
      THIS_
      DISPID dispidMember,
      REFIID riid,
      LCID lcid,
      WORD wFlags,
      DISPPARAMS FAR* pdispparams,
      VARIANT FAR* pvarResult,
      EXCEPINFO FAR* pexcepinfo,
      UINT FAR* puArgErr) PURE;

    /* _IMsoDispObj methods */
    STDMETHOD(get_Application)(THIS_ IDispatch * FAR* ppidisp) PURE;
    STDMETHOD(get_Creator)(THIS_ long FAR* plCreator) PURE;
#endif

    /* CommandBars methods */
    STDMETHOD(get_ActionControl)(THIS_ CommandBarControl FAR* FAR* ppcbc) PURE;
    STDMETHOD(get_ActiveMenuBar)(THIS_ CommandBar FAR* FAR* ppcb) PURE;
    STDMETHOD(Add)(THIS_ VARIANT Name, VARIANT Position, VARIANT MenuBar, VARIANT Temporary, CommandBar FAR* FAR* ppcb) PURE;
    STDMETHOD(get_Count)(THIS_ int FAR* pcToolbars) PURE;
    STDMETHOD(get_DisplayTooltips)(THIS_ VARIANT_BOOL FAR* pvarfDisplayTooltips) PURE;
    STDMETHOD(put_DisplayTooltips)(THIS_ VARIANT_BOOL varfDisplayTooltips) PURE;
    STDMETHOD(get_DisplayKeysInTooltips)(THIS_ VARIANT_BOOL FAR* pvarfDisplayKeys) PURE;
    STDMETHOD(put_DisplayKeysInTooltips)(THIS_ VARIANT_BOOL varfDisplayKeys) PURE;
    STDMETHOD(FindControl)(THIS_ VARIANT Type, VARIANT Id, VARIANT Tag, VARIANT Visible, CommandBarControl FAR* FAR* ppcbc) PURE;
    STDMETHOD(get_Item)(THIS_ VARIANT Index, CommandBar FAR* FAR* ppcb) PURE;
    STDMETHOD(get_LargeButtons)(THIS_ VARIANT_BOOL FAR* pvarfLargeButtons) PURE;
    STDMETHOD(put_LargeButtons)(THIS_ VARIANT_BOOL varfLargeButtons) PURE;
    STDMETHOD(get_MenuAnimationStyle)(THIS_ MsoMenuAnimation FAR* pma) PURE;
    STDMETHOD(put_MenuAnimationStyle)(THIS_ MsoMenuAnimation ma) PURE;
    STDMETHOD(get__NewEnum)(THIS_ IUnknown * FAR* ppienum) PURE;
    STDMETHOD(get_Parent)(THIS_ IDispatch * FAR* ppidisp) PURE;
    STDMETHOD(ReleaseFocus)(THIS) PURE;
    STDMETHOD(get_IdsString)(THIS_ int ids, BSTR FAR* pbstrName, int FAR* pcch) PURE;
    STDMETHOD(get_TmcGetName)(THIS_ int tmc, BSTR FAR* pbstrName, int FAR* pcch) PURE;
    STDMETHOD(get_AdaptiveMenus)(THIS_ VARIANT_BOOL FAR* pvarfAdaptiveMenus) PURE;
    STDMETHOD(put_AdaptiveMenus)(THIS_ VARIANT_BOOL varfAdaptiveMenus) PURE;
    STDMETHOD(FindControls)(THIS_ VARIANT Type, VARIANT Id, VARIANT Tag, VARIANT Visible, CommandBarControls FAR* FAR* ppcbcs) PURE;
    STDMETHOD(AddEx)(THIS_ VARIANT TbidOrName, VARIANT Position, VARIANT MenuBar, VARIANT Temporary, VARIANT TbtrProtection, CommandBar FAR* FAR* ppcb) PURE;
    STDMETHOD(get_DisplayFonts)(THIS_ VARIANT_BOOL FAR* pvarfDisplayFonts) PURE;
    STDMETHOD(put_DisplayFonts)(THIS_ VARIANT_BOOL varfDisplayFonts) PURE;
    STDMETHOD(get_DisableCustomize)(THIS_ VARIANT_BOOL FAR* pvarfDisableCustomize) PURE;
    STDMETHOD(put_DisableCustomize)(THIS_ VARIANT_BOOL varfDisableCustomize) PURE;
    STDMETHOD(get_DisableAskAQuestionDropdown)(THIS_ VARIANT_BOOL FAR* pvarfDisableAskAQuestionDropdown) PURE;
    STDMETHOD(put_DisableAskAQuestionDropdown)(THIS_ VARIANT_BOOL varfDisableAskAQuestionDropdown) PURE;
};

DEFINE_GUID(IID_CommandBar,0x000C0304L,0x0000,0x0000,0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46);

/* Definition of interface: CommandBar */
#undef INTERFACE
#define INTERFACE CommandBar

DECLARE_INTERFACE_(CommandBar, _IMsoOleAccDispObj)
{
BEGIN_INTERFACE
#ifndef NO_BASEINTERFACE_FUNCS

    /* IUnknown methods */
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG, AddRef)(THIS) PURE;
    STDMETHOD_(ULONG, Release)(THIS) PURE;

    /* IDispatch methods */
    STDMETHOD(GetTypeInfoCount)(THIS_ UINT FAR* pctinfo) PURE;

    STDMETHOD(GetTypeInfo)(
      THIS_
      UINT itinfo,
      LCID lcid,
      ITypeInfo FAR* FAR* pptinfo) PURE;

    STDMETHOD(GetIDsOfNames)(
      THIS_
      REFIID riid,
      OLECHAR FAR* FAR* rgszNames,
      UINT cNames,
      LCID lcid,
      DISPID FAR* rgdispid) PURE;

    STDMETHOD(Invoke)(
      THIS_
      DISPID dispidMember,
      REFIID riid,
      LCID lcid,
      WORD wFlags,
      DISPPARAMS FAR* pdispparams,
      VARIANT FAR* pvarResult,
      EXCEPINFO FAR* pexcepinfo,
      UINT FAR* puArgErr) PURE;

    /* IAccessible methods */
    STDMETHOD(get_accParent)(THIS_ IDispatch * FAR* ppdispParent) PURE;
    STDMETHOD(get_accChildCount)(THIS_ long FAR* pcountChildren) PURE;
    STDMETHOD(get_accChild)(THIS_ VARIANT varChild, IDispatch * FAR* ppdispChild) PURE;
    STDMETHOD(get_accName)(THIS_ VARIANT varChild, BSTR FAR* pszName) PURE;
    STDMETHOD(get_accValue)(THIS_ VARIANT varChild, BSTR FAR* pszValue) PURE;
    STDMETHOD(get_accDescription)(THIS_ VARIANT varChild, BSTR FAR* pszDescription) PURE;
    STDMETHOD(get_accRole)(THIS_ VARIANT varChild, VARIANT FAR* pvarRole) PURE;
    STDMETHOD(get_accState)(THIS_ VARIANT varChild, VARIANT FAR* pvarState) PURE;
    STDMETHOD(get_accHelp)(THIS_ VARIANT varChild, BSTR FAR* pszHelp) PURE;
    STDMETHOD(get_accHelpTopic)(THIS_ BSTR FAR* pszHelpFile, VARIANT varChild, long FAR* pidTopic) PURE;
    STDMETHOD(get_accKeyboardShortcut)(THIS_ VARIANT varChild, BSTR FAR* pszKeyboardShortcut) PURE;
    STDMETHOD(get_accFocus)(THIS_ VARIANT FAR* pvarChild) PURE;
    STDMETHOD(get_accSelection)(THIS_ VARIANT FAR* pvarChildren) PURE;
    STDMETHOD(get_accDefaultAction)(THIS_ VARIANT varChild, BSTR FAR* pszDefaultAction) PURE;
    STDMETHOD(accSelect)(THIS_ long flagsSelect, VARIANT varChild) PURE;
    STDMETHOD(accLocation)(THIS_ long FAR* pxLeft, long FAR* pyTop, long FAR* pcxWidth, long FAR* pcyHeight, VARIANT varChild) PURE;
    STDMETHOD(accNavigate)(THIS_ long navDir, VARIANT varStart, VARIANT FAR* pvarEndUpAt) PURE;
    STDMETHOD(accHitTest)(THIS_ long xLeft, long yTop, VARIANT FAR* pvarChild) PURE;
    STDMETHOD(accDoDefaultAction)(THIS_ VARIANT varChild) PURE;
    STDMETHOD(put_accName)(THIS_ VARIANT varChild, BSTR szName) PURE;
    STDMETHOD(put_accValue)(THIS_ VARIANT varChild, BSTR szValue) PURE;

    /* _IMsoOleAccDispObj methods */
    STDMETHOD(get_Application)(THIS_ IDispatch * FAR* ppidisp) PURE;
    STDMETHOD(get_Creator)(THIS_ long FAR* plCreator) PURE;
#endif

    /* CommandBar methods */
    STDMETHOD(get_BuiltIn)(THIS_ VARIANT_BOOL FAR* pvarfBuiltIn) PURE;
    STDMETHOD(get_Context)(THIS_ BSTR FAR* pbstrContext) PURE;
    STDMETHOD(put_Context)(THIS_ BSTR Context) PURE;
    STDMETHOD(get_Controls)(THIS_ CommandBarControls FAR* FAR* ppcbcs) PURE;
    STDMETHOD(Delete)(THIS) PURE;
    STDMETHOD(get_Enabled)(THIS_ VARIANT_BOOL FAR* pvarfEnabled) PURE;
    STDMETHOD(put_Enabled)(THIS_ VARIANT_BOOL varfEnabled) PURE;
    STDMETHOD(FindControl)(THIS_ VARIANT Type, VARIANT Id, VARIANT Tag, VARIANT Visible, VARIANT Recursive, CommandBarControl FAR* FAR* ppcbc) PURE;
    STDMETHOD(get_Height)(THIS_ int FAR* pdy) PURE;
    STDMETHOD(put_Height)(THIS_ int dy) PURE;
    STDMETHOD(get_Index)(THIS_ int FAR* pi) PURE;
    STDMETHOD(get_InstanceId)(THIS_ long FAR* pid) PURE;
    STDMETHOD(get_Left)(THIS_ int FAR* pxpLeft) PURE;
    STDMETHOD(put_Left)(THIS_ int xpLeft) PURE;
    STDMETHOD(get_Name)(THIS_ BSTR FAR* pbstrName) PURE;
    STDMETHOD(put_Name)(THIS_ BSTR Name) PURE;
    STDMETHOD(get_NameLocal)(THIS_ BSTR FAR* pbstrNameLocal) PURE;
    STDMETHOD(put_NameLocal)(THIS_ BSTR NameLocal) PURE;
    STDMETHOD(get_Parent)(THIS_ IDispatch * FAR* ppidisp) PURE;
    STDMETHOD(get_Position)(THIS_ MsoBarPosition FAR* ppos) PURE;
    STDMETHOD(put_Position)(THIS_ MsoBarPosition pos) PURE;
    STDMETHOD(get_RowIndex)(THIS_ int FAR* piRow) PURE;
    STDMETHOD(put_RowIndex)(THIS_ int iRow) PURE;
    STDMETHOD(get_Protection)(THIS_ MsoBarProtection FAR* pprot) PURE;
    STDMETHOD(put_Protection)(THIS_ MsoBarProtection prot) PURE;
    STDMETHOD(Reset)(THIS) PURE;
    STDMETHOD(ShowPopup)(THIS_ VARIANT x, VARIANT y) PURE;
    STDMETHOD(get_Top)(THIS_ int FAR* pypTop) PURE;
    STDMETHOD(put_Top)(THIS_ int ypTop) PURE;
    STDMETHOD(get_Type)(THIS_ MsoBarType FAR* ptype) PURE;
    STDMETHOD(get_Visible)(THIS_ VARIANT_BOOL FAR* pvarfVisible) PURE;
    STDMETHOD(put_Visible)(THIS_ VARIANT_BOOL Visible) PURE;
    STDMETHOD(get_Width)(THIS_ int FAR* pdx) PURE;
    STDMETHOD(put_Width)(THIS_ int dx) PURE;
    STDMETHOD(get_AdaptiveMenu)(THIS_ VARIANT_BOOL FAR* pvarfAdaptiveMenu) PURE;
    STDMETHOD(put_AdaptiveMenu)(THIS_ VARIANT_BOOL varfAdaptiveMenu) PURE;
    STDMETHOD(get_Id)(THIS_ int FAR* pid) PURE;
};

DEFINE_GUID(IID_CommandBarControls,0x000C0306L,0x0000,0x0000,0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46);

/* Definition of interface: CommandBarControls */
#undef INTERFACE
#define INTERFACE CommandBarControls

DECLARE_INTERFACE_(CommandBarControls, _IMsoDispObj)
{
BEGIN_INTERFACE
#ifndef NO_BASEINTERFACE_FUNCS

    /* IUnknown methods */
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG, AddRef)(THIS) PURE;
    STDMETHOD_(ULONG, Release)(THIS) PURE;

    /* IDispatch methods */
    STDMETHOD(GetTypeInfoCount)(THIS_ UINT FAR* pctinfo) PURE;

    STDMETHOD(GetTypeInfo)(
      THIS_
      UINT itinfo,
      LCID lcid,
      ITypeInfo FAR* FAR* pptinfo) PURE;

    STDMETHOD(GetIDsOfNames)(
      THIS_
      REFIID riid,
      OLECHAR FAR* FAR* rgszNames,
      UINT cNames,
      LCID lcid,
      DISPID FAR* rgdispid) PURE;

    STDMETHOD(Invoke)(
      THIS_
      DISPID dispidMember,
      REFIID riid,
      LCID lcid,
      WORD wFlags,
      DISPPARAMS FAR* pdispparams,
      VARIANT FAR* pvarResult,
      EXCEPINFO FAR* pexcepinfo,
      UINT FAR* puArgErr) PURE;

    /* _IMsoDispObj methods */
    STDMETHOD(get_Application)(THIS_ IDispatch * FAR* ppidisp) PURE;
    STDMETHOD(get_Creator)(THIS_ long FAR* plCreator) PURE;
#endif

    /* CommandBarControls methods */
    STDMETHOD(Add)(THIS_ VARIANT Type, VARIANT Id, VARIANT Parameter, VARIANT Before, VARIANT Temporary, CommandBarControl FAR* FAR* ppcbc) PURE;
    STDMETHOD(get_Count)(THIS_ int FAR* pcToolbarControls) PURE;
    STDMETHOD(get_Item)(THIS_ VARIANT Index, CommandBarControl FAR* FAR* ppcbc) PURE;
    STDMETHOD(get__NewEnum)(THIS_ IUnknown * FAR* ppienum) PURE;
    STDMETHOD(get_Parent)(THIS_ CommandBar FAR* FAR* ppcb) PURE;
};

DEFINE_GUID(IID_CommandBarControl,0x000C0308L,0x0000,0x0000,0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46);

/* Definition of interface: CommandBarControl */
#undef INTERFACE
#define INTERFACE CommandBarControl

DECLARE_INTERFACE_(CommandBarControl, _IMsoOleAccDispObj)
{
BEGIN_INTERFACE
#ifndef NO_BASEINTERFACE_FUNCS

    /* IUnknown methods */
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG, AddRef)(THIS) PURE;
    STDMETHOD_(ULONG, Release)(THIS) PURE;

    /* IDispatch methods */
    STDMETHOD(GetTypeInfoCount)(THIS_ UINT FAR* pctinfo) PURE;

    STDMETHOD(GetTypeInfo)(
      THIS_
      UINT itinfo,
      LCID lcid,
      ITypeInfo FAR* FAR* pptinfo) PURE;

    STDMETHOD(GetIDsOfNames)(
      THIS_
      REFIID riid,
      OLECHAR FAR* FAR* rgszNames,
      UINT cNames,
      LCID lcid,
      DISPID FAR* rgdispid) PURE;

    STDMETHOD(Invoke)(
      THIS_
      DISPID dispidMember,
      REFIID riid,
      LCID lcid,
      WORD wFlags,
      DISPPARAMS FAR* pdispparams,
      VARIANT FAR* pvarResult,
      EXCEPINFO FAR* pexcepinfo,
      UINT FAR* puArgErr) PURE;

    /* IAccessible methods */
    STDMETHOD(get_accParent)(THIS_ IDispatch * FAR* ppdispParent) PURE;
    STDMETHOD(get_accChildCount)(THIS_ long FAR* pcountChildren) PURE;
    STDMETHOD(get_accChild)(THIS_ VARIANT varChild, IDispatch * FAR* ppdispChild) PURE;
    STDMETHOD(get_accName)(THIS_ VARIANT varChild, BSTR FAR* pszName) PURE;
    STDMETHOD(get_accValue)(THIS_ VARIANT varChild, BSTR FAR* pszValue) PURE;
    STDMETHOD(get_accDescription)(THIS_ VARIANT varChild, BSTR FAR* pszDescription) PURE;
    STDMETHOD(get_accRole)(THIS_ VARIANT varChild, VARIANT FAR* pvarRole) PURE;
    STDMETHOD(get_accState)(THIS_ VARIANT varChild, VARIANT FAR* pvarState) PURE;
    STDMETHOD(get_accHelp)(THIS_ VARIANT varChild, BSTR FAR* pszHelp) PURE;
    STDMETHOD(get_accHelpTopic)(THIS_ BSTR FAR* pszHelpFile, VARIANT varChild, long FAR* pidTopic) PURE;
    STDMETHOD(get_accKeyboardShortcut)(THIS_ VARIANT varChild, BSTR FAR* pszKeyboardShortcut) PURE;
    STDMETHOD(get_accFocus)(THIS_ VARIANT FAR* pvarChild) PURE;
    STDMETHOD(get_accSelection)(THIS_ VARIANT FAR* pvarChildren) PURE;
    STDMETHOD(get_accDefaultAction)(THIS_ VARIANT varChild, BSTR FAR* pszDefaultAction) PURE;
    STDMETHOD(accSelect)(THIS_ long flagsSelect, VARIANT varChild) PURE;
    STDMETHOD(accLocation)(THIS_ long FAR* pxLeft, long FAR* pyTop, long FAR* pcxWidth, long FAR* pcyHeight, VARIANT varChild) PURE;
    STDMETHOD(accNavigate)(THIS_ long navDir, VARIANT varStart, VARIANT FAR* pvarEndUpAt) PURE;
    STDMETHOD(accHitTest)(THIS_ long xLeft, long yTop, VARIANT FAR* pvarChild) PURE;
    STDMETHOD(accDoDefaultAction)(THIS_ VARIANT varChild) PURE;
    STDMETHOD(put_accName)(THIS_ VARIANT varChild, BSTR szName) PURE;
    STDMETHOD(put_accValue)(THIS_ VARIANT varChild, BSTR szValue) PURE;

    /* _IMsoOleAccDispObj methods */
    STDMETHOD(get_Application)(THIS_ IDispatch * FAR* ppidisp) PURE;
    STDMETHOD(get_Creator)(THIS_ long FAR* plCreator) PURE;
#endif

    /* CommandBarControl methods */
    STDMETHOD(get_BeginGroup)(THIS_ VARIANT_BOOL FAR* pvarfBeginGroup) PURE;
    STDMETHOD(put_BeginGroup)(THIS_ VARIANT_BOOL varfBeginGroup) PURE;
    STDMETHOD(get_BuiltIn)(THIS_ VARIANT_BOOL FAR* pvarfBuiltIn) PURE;
    STDMETHOD(get_Caption)(THIS_ BSTR FAR* pbstrCaption) PURE;
    STDMETHOD(put_Caption)(THIS_ BSTR bstrCaption) PURE;
    STDMETHOD(get_Control)(THIS_ IDispatch * FAR* ppidisp) PURE;
    STDMETHOD(Copy)(THIS_ VARIANT Bar, VARIANT Before, CommandBarControl FAR* FAR* ppcbc) PURE;
    STDMETHOD(Delete)(THIS_ VARIANT Temporary) PURE;
    STDMETHOD(get_DescriptionText)(THIS_ BSTR FAR* pbstrText) PURE;
    STDMETHOD(put_DescriptionText)(THIS_ BSTR bstrText) PURE;
    STDMETHOD(get_Enabled)(THIS_ VARIANT_BOOL FAR* pvarfEnabled) PURE;
    STDMETHOD(put_Enabled)(THIS_ VARIANT_BOOL varfEnabled) PURE;
    STDMETHOD(Execute)(THIS) PURE;
    STDMETHOD(get_Height)(THIS_ int FAR* pdy) PURE;
    STDMETHOD(put_Height)(THIS_ int dy) PURE;
    STDMETHOD(get_HelpContextId)(THIS_ int FAR* pid) PURE;
    STDMETHOD(put_HelpContextId)(THIS_ int id) PURE;
    STDMETHOD(get_HelpFile)(THIS_ BSTR FAR* pbstrFilename) PURE;
    STDMETHOD(put_HelpFile)(THIS_ BSTR bstrFilename) PURE;
    STDMETHOD(get_Id)(THIS_ int FAR* pid) PURE;
    STDMETHOD(get_Index)(THIS_ int FAR* pi) PURE;
    STDMETHOD(get_InstanceId)(THIS_ long FAR* pid) PURE;
    STDMETHOD(Move)(THIS_ VARIANT Bar, VARIANT Before, CommandBarControl FAR* FAR* ppcbc) PURE;
    STDMETHOD(get_Left)(THIS_ int FAR* px) PURE;
    STDMETHOD(get_OLEUsage)(THIS_ MsoControlOLEUsage FAR* pcou) PURE;
    STDMETHOD(put_OLEUsage)(THIS_ MsoControlOLEUsage cou) PURE;
    STDMETHOD(get_OnAction)(THIS_ BSTR FAR* pbstrOnAction) PURE;
    STDMETHOD(put_OnAction)(THIS_ BSTR bstrOnAction) PURE;
    STDMETHOD(get_Parent)(THIS_ CommandBar FAR* FAR* ppcb) PURE;
    STDMETHOD(get_Parameter)(THIS_ BSTR FAR* pbstrParam) PURE;
    STDMETHOD(put_Parameter)(THIS_ BSTR bstrParam) PURE;
    STDMETHOD(get_Priority)(THIS_ int FAR* pnPri) PURE;
    STDMETHOD(put_Priority)(THIS_ int nPri) PURE;
    STDMETHOD(Reset)(THIS) PURE;
    STDMETHOD(SetFocus)(THIS) PURE;
    STDMETHOD(get_Tag)(THIS_ BSTR FAR* pbstrTag) PURE;
    STDMETHOD(put_Tag)(THIS_ BSTR bstrTag) PURE;
    STDMETHOD(get_TooltipText)(THIS_ BSTR FAR* pbstrTooltip) PURE;
    STDMETHOD(put_TooltipText)(THIS_ BSTR bstrTooltip) PURE;
    STDMETHOD(get_Top)(THIS_ int FAR* py) PURE;
    STDMETHOD(get_Type)(THIS_ MsoControlType FAR* ptype) PURE;
    STDMETHOD(get_Visible)(THIS_ VARIANT_BOOL FAR* pvarfVisible) PURE;
    STDMETHOD(put_Visible)(THIS_ VARIANT_BOOL varfVisible) PURE;
    STDMETHOD(get_Width)(THIS_ int FAR* pdx) PURE;
    STDMETHOD(put_Width)(THIS_ int dx) PURE;
    STDMETHOD(get_IsPriorityDropped)(THIS_ VARIANT_BOOL FAR* pvarfDropped) PURE;
    STDMETHOD(Reserved1)(THIS) PURE;
    STDMETHOD(Reserved2)(THIS) PURE;
    STDMETHOD(Reserved3)(THIS) PURE;
    STDMETHOD(Reserved4)(THIS) PURE;
    STDMETHOD(Reserved5)(THIS) PURE;
    STDMETHOD(Reserved6)(THIS) PURE;
    STDMETHOD(Reserved7)(THIS) PURE;
};

DEFINE_GUID(IID_CommandBarButton,0x000C030EL,0x0000,0x0000,0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46);

/* Definition of interface: CommandBarButton */
#undef INTERFACE
#define INTERFACE CommandBarButton

DECLARE_INTERFACE_(CommandBarButton, CommandBarControl)
{
BEGIN_INTERFACE
#ifndef NO_BASEINTERFACE_FUNCS

    /* IUnknown methods */
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG, AddRef)(THIS) PURE;
    STDMETHOD_(ULONG, Release)(THIS) PURE;

    /* IDispatch methods */
    STDMETHOD(GetTypeInfoCount)(THIS_ UINT FAR* pctinfo) PURE;

    STDMETHOD(GetTypeInfo)(
      THIS_
      UINT itinfo,
      LCID lcid,
      ITypeInfo FAR* FAR* pptinfo) PURE;

    STDMETHOD(GetIDsOfNames)(
      THIS_
      REFIID riid,
      OLECHAR FAR* FAR* rgszNames,
      UINT cNames,
      LCID lcid,
      DISPID FAR* rgdispid) PURE;

    STDMETHOD(Invoke)(
      THIS_
      DISPID dispidMember,
      REFIID riid,
      LCID lcid,
      WORD wFlags,
      DISPPARAMS FAR* pdispparams,
      VARIANT FAR* pvarResult,
      EXCEPINFO FAR* pexcepinfo,
      UINT FAR* puArgErr) PURE;

    /* IAccessible methods */
    STDMETHOD(get_accParent)(THIS_ IDispatch * FAR* ppdispParent) PURE;
    STDMETHOD(get_accChildCount)(THIS_ long FAR* pcountChildren) PURE;
    STDMETHOD(get_accChild)(THIS_ VARIANT varChild, IDispatch * FAR* ppdispChild) PURE;
    STDMETHOD(get_accName)(THIS_ VARIANT varChild, BSTR FAR* pszName) PURE;
    STDMETHOD(get_accValue)(THIS_ VARIANT varChild, BSTR FAR* pszValue) PURE;
    STDMETHOD(get_accDescription)(THIS_ VARIANT varChild, BSTR FAR* pszDescription) PURE;
    STDMETHOD(get_accRole)(THIS_ VARIANT varChild, VARIANT FAR* pvarRole) PURE;
    STDMETHOD(get_accState)(THIS_ VARIANT varChild, VARIANT FAR* pvarState) PURE;
    STDMETHOD(get_accHelp)(THIS_ VARIANT varChild, BSTR FAR* pszHelp) PURE;
    STDMETHOD(get_accHelpTopic)(THIS_ BSTR FAR* pszHelpFile, VARIANT varChild, long FAR* pidTopic) PURE;
    STDMETHOD(get_accKeyboardShortcut)(THIS_ VARIANT varChild, BSTR FAR* pszKeyboardShortcut) PURE;
    STDMETHOD(get_accFocus)(THIS_ VARIANT FAR* pvarChild) PURE;
    STDMETHOD(get_accSelection)(THIS_ VARIANT FAR* pvarChildren) PURE;
    STDMETHOD(get_accDefaultAction)(THIS_ VARIANT varChild, BSTR FAR* pszDefaultAction) PURE;
    STDMETHOD(accSelect)(THIS_ long flagsSelect, VARIANT varChild) PURE;
    STDMETHOD(accLocation)(THIS_ long FAR* pxLeft, long FAR* pyTop, long FAR* pcxWidth, long FAR* pcyHeight, VARIANT varChild) PURE;
    STDMETHOD(accNavigate)(THIS_ long navDir, VARIANT varStart, VARIANT FAR* pvarEndUpAt) PURE;
    STDMETHOD(accHitTest)(THIS_ long xLeft, long yTop, VARIANT FAR* pvarChild) PURE;
    STDMETHOD(accDoDefaultAction)(THIS_ VARIANT varChild) PURE;
    STDMETHOD(put_accName)(THIS_ VARIANT varChild, BSTR szName) PURE;
    STDMETHOD(put_accValue)(THIS_ VARIANT varChild, BSTR szValue) PURE;

    /* _IMsoOleAccDispObj methods */
    STDMETHOD(get_Application)(THIS_ IDispatch * FAR* ppidisp) PURE;
    STDMETHOD(get_Creator)(THIS_ long FAR* plCreator) PURE;

    /* CommandBarControl methods */
    STDMETHOD(get_BeginGroup)(THIS_ VARIANT_BOOL FAR* pvarfBeginGroup) PURE;
    STDMETHOD(put_BeginGroup)(THIS_ VARIANT_BOOL varfBeginGroup) PURE;
    STDMETHOD(get_BuiltIn)(THIS_ VARIANT_BOOL FAR* pvarfBuiltIn) PURE;
    STDMETHOD(get_Caption)(THIS_ BSTR FAR* pbstrCaption) PURE;
    STDMETHOD(put_Caption)(THIS_ BSTR bstrCaption) PURE;
    STDMETHOD(get_Control)(THIS_ IDispatch * FAR* ppidisp) PURE;
    STDMETHOD(Copy)(THIS_ VARIANT Bar, VARIANT Before, CommandBarControl FAR* FAR* ppcbc) PURE;
    STDMETHOD(Delete)(THIS_ VARIANT Temporary) PURE;
    STDMETHOD(get_DescriptionText)(THIS_ BSTR FAR* pbstrText) PURE;
    STDMETHOD(put_DescriptionText)(THIS_ BSTR bstrText) PURE;
    STDMETHOD(get_Enabled)(THIS_ VARIANT_BOOL FAR* pvarfEnabled) PURE;
    STDMETHOD(put_Enabled)(THIS_ VARIANT_BOOL varfEnabled) PURE;
    STDMETHOD(Execute)(THIS) PURE;
    STDMETHOD(get_Height)(THIS_ int FAR* pdy) PURE;
    STDMETHOD(put_Height)(THIS_ int dy) PURE;
    STDMETHOD(get_HelpContextId)(THIS_ int FAR* pid) PURE;
    STDMETHOD(put_HelpContextId)(THIS_ int id) PURE;
    STDMETHOD(get_HelpFile)(THIS_ BSTR FAR* pbstrFilename) PURE;
    STDMETHOD(put_HelpFile)(THIS_ BSTR bstrFilename) PURE;
    STDMETHOD(get_Id)(THIS_ int FAR* pid) PURE;
    STDMETHOD(get_Index)(THIS_ int FAR* pi) PURE;
    STDMETHOD(get_InstanceId)(THIS_ long FAR* pid) PURE;
    STDMETHOD(Move)(THIS_ VARIANT Bar, VARIANT Before, CommandBarControl FAR* FAR* ppcbc) PURE;
    STDMETHOD(get_Left)(THIS_ int FAR* px) PURE;
    STDMETHOD(get_OLEUsage)(THIS_ MsoControlOLEUsage FAR* pcou) PURE;
    STDMETHOD(put_OLEUsage)(THIS_ MsoControlOLEUsage cou) PURE;
    STDMETHOD(get_OnAction)(THIS_ BSTR FAR* pbstrOnAction) PURE;
    STDMETHOD(put_OnAction)(THIS_ BSTR bstrOnAction) PURE;
    STDMETHOD(get_Parent)(THIS_ CommandBar FAR* FAR* ppcb) PURE;
    STDMETHOD(get_Parameter)(THIS_ BSTR FAR* pbstrParam) PURE;
    STDMETHOD(put_Parameter)(THIS_ BSTR bstrParam) PURE;
    STDMETHOD(get_Priority)(THIS_ int FAR* pnPri) PURE;
    STDMETHOD(put_Priority)(THIS_ int nPri) PURE;
    STDMETHOD(Reset)(THIS) PURE;
    STDMETHOD(SetFocus)(THIS) PURE;
    STDMETHOD(get_Tag)(THIS_ BSTR FAR* pbstrTag) PURE;
    STDMETHOD(put_Tag)(THIS_ BSTR bstrTag) PURE;
    STDMETHOD(get_TooltipText)(THIS_ BSTR FAR* pbstrTooltip) PURE;
    STDMETHOD(put_TooltipText)(THIS_ BSTR bstrTooltip) PURE;
    STDMETHOD(get_Top)(THIS_ int FAR* py) PURE;
    STDMETHOD(get_Type)(THIS_ MsoControlType FAR* ptype) PURE;
    STDMETHOD(get_Visible)(THIS_ VARIANT_BOOL FAR* pvarfVisible) PURE;
    STDMETHOD(put_Visible)(THIS_ VARIANT_BOOL varfVisible) PURE;
    STDMETHOD(get_Width)(THIS_ int FAR* pdx) PURE;
    STDMETHOD(put_Width)(THIS_ int dx) PURE;
    STDMETHOD(get_IsPriorityDropped)(THIS_ VARIANT_BOOL FAR* pvarfDropped) PURE;
    STDMETHOD(Reserved1)(THIS) PURE;
    STDMETHOD(Reserved2)(THIS) PURE;
    STDMETHOD(Reserved3)(THIS) PURE;
    STDMETHOD(Reserved4)(THIS) PURE;
    STDMETHOD(Reserved5)(THIS) PURE;
    STDMETHOD(Reserved6)(THIS) PURE;
    STDMETHOD(Reserved7)(THIS) PURE;
#endif

    /* CommandBarButton methods */
    STDMETHOD(get_BuiltInFace)(THIS_ VARIANT_BOOL FAR* pvarfBuiltIn) PURE;
    STDMETHOD(put_BuiltInFace)(THIS_ VARIANT_BOOL varfBuiltIn) PURE;
    STDMETHOD(CopyFace)(THIS) PURE;
    STDMETHOD(get_FaceId)(THIS_ int FAR* pid) PURE;
    STDMETHOD(put_FaceId)(THIS_ int id) PURE;
    STDMETHOD(PasteFace)(THIS) PURE;
    STDMETHOD(get_ShortcutText)(THIS_ BSTR FAR* pbstrText) PURE;
    STDMETHOD(put_ShortcutText)(THIS_ BSTR bstrText) PURE;
    STDMETHOD(get_State)(THIS_ MsoButtonState FAR* pstate) PURE;
    STDMETHOD(put_State)(THIS_ MsoButtonState state) PURE;
    STDMETHOD(get_Style)(THIS_ MsoButtonStyle FAR* pstyle) PURE;
    STDMETHOD(put_Style)(THIS_ MsoButtonStyle style) PURE;
    STDMETHOD(get_HyperlinkType)(THIS_ MsoCommandBarButtonHyperlinkType FAR* phlType) PURE;
    STDMETHOD(put_HyperlinkType)(THIS_ MsoCommandBarButtonHyperlinkType hlType) PURE;
    STDMETHOD(get_Picture)(THIS_ IPictureDisp FAR* FAR* ppdispPicture) PURE;
    STDMETHOD(put_Picture)(THIS_ IPictureDisp FAR* pdispPicture) PURE;
    STDMETHOD(get_Mask)(THIS_ IPictureDisp FAR* FAR* ppipictdispMask) PURE;
    STDMETHOD(put_Mask)(THIS_ IPictureDisp FAR* pipictdispMask) PURE;
};

DEFINE_GUID(IID_CommandBarPopup,0x000C030AL,0x0000,0x0000,0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46);

/* Definition of interface: CommandBarPopup */
#undef INTERFACE
#define INTERFACE CommandBarPopup

DECLARE_INTERFACE_(CommandBarPopup, CommandBarControl)
{
BEGIN_INTERFACE
#ifndef NO_BASEINTERFACE_FUNCS

    /* IUnknown methods */
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG, AddRef)(THIS) PURE;
    STDMETHOD_(ULONG, Release)(THIS) PURE;

    /* IDispatch methods */
    STDMETHOD(GetTypeInfoCount)(THIS_ UINT FAR* pctinfo) PURE;

    STDMETHOD(GetTypeInfo)(
      THIS_
      UINT itinfo,
      LCID lcid,
      ITypeInfo FAR* FAR* pptinfo) PURE;

    STDMETHOD(GetIDsOfNames)(
      THIS_
      REFIID riid,
      OLECHAR FAR* FAR* rgszNames,
      UINT cNames,
      LCID lcid,
      DISPID FAR* rgdispid) PURE;

    STDMETHOD(Invoke)(
      THIS_
      DISPID dispidMember,
      REFIID riid,
      LCID lcid,
      WORD wFlags,
      DISPPARAMS FAR* pdispparams,
      VARIANT FAR* pvarResult,
      EXCEPINFO FAR* pexcepinfo,
      UINT FAR* puArgErr) PURE;

    /* IAccessible methods */
    STDMETHOD(get_accParent)(THIS_ IDispatch * FAR* ppdispParent) PURE;
    STDMETHOD(get_accChildCount)(THIS_ long FAR* pcountChildren) PURE;
    STDMETHOD(get_accChild)(THIS_ VARIANT varChild, IDispatch * FAR* ppdispChild) PURE;
    STDMETHOD(get_accName)(THIS_ VARIANT varChild, BSTR FAR* pszName) PURE;
    STDMETHOD(get_accValue)(THIS_ VARIANT varChild, BSTR FAR* pszValue) PURE;
    STDMETHOD(get_accDescription)(THIS_ VARIANT varChild, BSTR FAR* pszDescription) PURE;
    STDMETHOD(get_accRole)(THIS_ VARIANT varChild, VARIANT FAR* pvarRole) PURE;
    STDMETHOD(get_accState)(THIS_ VARIANT varChild, VARIANT FAR* pvarState) PURE;
    STDMETHOD(get_accHelp)(THIS_ VARIANT varChild, BSTR FAR* pszHelp) PURE;
    STDMETHOD(get_accHelpTopic)(THIS_ BSTR FAR* pszHelpFile, VARIANT varChild, long FAR* pidTopic) PURE;
    STDMETHOD(get_accKeyboardShortcut)(THIS_ VARIANT varChild, BSTR FAR* pszKeyboardShortcut) PURE;
    STDMETHOD(get_accFocus)(THIS_ VARIANT FAR* pvarChild) PURE;
    STDMETHOD(get_accSelection)(THIS_ VARIANT FAR* pvarChildren) PURE;
    STDMETHOD(get_accDefaultAction)(THIS_ VARIANT varChild, BSTR FAR* pszDefaultAction) PURE;
    STDMETHOD(accSelect)(THIS_ long flagsSelect, VARIANT varChild) PURE;
    STDMETHOD(accLocation)(THIS_ long FAR* pxLeft, long FAR* pyTop, long FAR* pcxWidth, long FAR* pcyHeight, VARIANT varChild) PURE;
    STDMETHOD(accNavigate)(THIS_ long navDir, VARIANT varStart, VARIANT FAR* pvarEndUpAt) PURE;
    STDMETHOD(accHitTest)(THIS_ long xLeft, long yTop, VARIANT FAR* pvarChild) PURE;
    STDMETHOD(accDoDefaultAction)(THIS_ VARIANT varChild) PURE;
    STDMETHOD(put_accName)(THIS_ VARIANT varChild, BSTR szName) PURE;
    STDMETHOD(put_accValue)(THIS_ VARIANT varChild, BSTR szValue) PURE;

    /* _IMsoOleAccDispObj methods */
    STDMETHOD(get_Application)(THIS_ IDispatch * FAR* ppidisp) PURE;
    STDMETHOD(get_Creator)(THIS_ long FAR* plCreator) PURE;

    /* CommandBarControl methods */
    STDMETHOD(get_BeginGroup)(THIS_ VARIANT_BOOL FAR* pvarfBeginGroup) PURE;
    STDMETHOD(put_BeginGroup)(THIS_ VARIANT_BOOL varfBeginGroup) PURE;
    STDMETHOD(get_BuiltIn)(THIS_ VARIANT_BOOL FAR* pvarfBuiltIn) PURE;
    STDMETHOD(get_Caption)(THIS_ BSTR FAR* pbstrCaption) PURE;
    STDMETHOD(put_Caption)(THIS_ BSTR bstrCaption) PURE;
    STDMETHOD(get_Control)(THIS_ IDispatch * FAR* ppidisp) PURE;
    STDMETHOD(Copy)(THIS_ VARIANT Bar, VARIANT Before, CommandBarControl FAR* FAR* ppcbc) PURE;
    STDMETHOD(Delete)(THIS_ VARIANT Temporary) PURE;
    STDMETHOD(get_DescriptionText)(THIS_ BSTR FAR* pbstrText) PURE;
    STDMETHOD(put_DescriptionText)(THIS_ BSTR bstrText) PURE;
    STDMETHOD(get_Enabled)(THIS_ VARIANT_BOOL FAR* pvarfEnabled) PURE;
    STDMETHOD(put_Enabled)(THIS_ VARIANT_BOOL varfEnabled) PURE;
    STDMETHOD(Execute)(THIS) PURE;
    STDMETHOD(get_Height)(THIS_ int FAR* pdy) PURE;
    STDMETHOD(put_Height)(THIS_ int dy) PURE;
    STDMETHOD(get_HelpContextId)(THIS_ int FAR* pid) PURE;
    STDMETHOD(put_HelpContextId)(THIS_ int id) PURE;
    STDMETHOD(get_HelpFile)(THIS_ BSTR FAR* pbstrFilename) PURE;
    STDMETHOD(put_HelpFile)(THIS_ BSTR bstrFilename) PURE;
    STDMETHOD(get_Id)(THIS_ int FAR* pid) PURE;
    STDMETHOD(get_Index)(THIS_ int FAR* pi) PURE;
    STDMETHOD(get_InstanceId)(THIS_ long FAR* pid) PURE;
    STDMETHOD(Move)(THIS_ VARIANT Bar, VARIANT Before, CommandBarControl FAR* FAR* ppcbc) PURE;
    STDMETHOD(get_Left)(THIS_ int FAR* px) PURE;
    STDMETHOD(get_OLEUsage)(THIS_ MsoControlOLEUsage FAR* pcou) PURE;
    STDMETHOD(put_OLEUsage)(THIS_ MsoControlOLEUsage cou) PURE;
    STDMETHOD(get_OnAction)(THIS_ BSTR FAR* pbstrOnAction) PURE;
    STDMETHOD(put_OnAction)(THIS_ BSTR bstrOnAction) PURE;
    STDMETHOD(get_Parent)(THIS_ CommandBar FAR* FAR* ppcb) PURE;
    STDMETHOD(get_Parameter)(THIS_ BSTR FAR* pbstrParam) PURE;
    STDMETHOD(put_Parameter)(THIS_ BSTR bstrParam) PURE;
    STDMETHOD(get_Priority)(THIS_ int FAR* pnPri) PURE;
    STDMETHOD(put_Priority)(THIS_ int nPri) PURE;
    STDMETHOD(Reset)(THIS) PURE;
    STDMETHOD(SetFocus)(THIS) PURE;
    STDMETHOD(get_Tag)(THIS_ BSTR FAR* pbstrTag) PURE;
    STDMETHOD(put_Tag)(THIS_ BSTR bstrTag) PURE;
    STDMETHOD(get_TooltipText)(THIS_ BSTR FAR* pbstrTooltip) PURE;
    STDMETHOD(put_TooltipText)(THIS_ BSTR bstrTooltip) PURE;
    STDMETHOD(get_Top)(THIS_ int FAR* py) PURE;
    STDMETHOD(get_Type)(THIS_ MsoControlType FAR* ptype) PURE;
    STDMETHOD(get_Visible)(THIS_ VARIANT_BOOL FAR* pvarfVisible) PURE;
    STDMETHOD(put_Visible)(THIS_ VARIANT_BOOL varfVisible) PURE;
    STDMETHOD(get_Width)(THIS_ int FAR* pdx) PURE;
    STDMETHOD(put_Width)(THIS_ int dx) PURE;
    STDMETHOD(get_IsPriorityDropped)(THIS_ VARIANT_BOOL FAR* pvarfDropped) PURE;
    STDMETHOD(Reserved1)(THIS) PURE;
    STDMETHOD(Reserved2)(THIS) PURE;
    STDMETHOD(Reserved3)(THIS) PURE;
    STDMETHOD(Reserved4)(THIS) PURE;
    STDMETHOD(Reserved5)(THIS) PURE;
    STDMETHOD(Reserved6)(THIS) PURE;
    STDMETHOD(Reserved7)(THIS) PURE;
#endif

    /* CommandBarPopup methods */
    STDMETHOD(get_CommandBar)(THIS_ CommandBar FAR* FAR* ppcb) PURE;
    STDMETHOD(get_Controls)(THIS_ CommandBarControls FAR* FAR* ppcbcs) PURE;
    STDMETHOD(get_OLEMenuGroup)(THIS_ MsoOLEMenuGroup FAR* pomg) PURE;
    STDMETHOD(put_OLEMenuGroup)(THIS_ MsoOLEMenuGroup omg) PURE;
};

DEFINE_GUID(IID_CommandBarComboBox,0x000C030CL,0x0000,0x0000,0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46);

/* Definition of interface: CommandBarComboBox */
#undef INTERFACE
#define INTERFACE CommandBarComboBox

DECLARE_INTERFACE_(CommandBarComboBox, CommandBarControl)
{
BEGIN_INTERFACE
#ifndef NO_BASEINTERFACE_FUNCS

    /* IUnknown methods */
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG, AddRef)(THIS) PURE;
    STDMETHOD_(ULONG, Release)(THIS) PURE;

    /* IDispatch methods */
    STDMETHOD(GetTypeInfoCount)(THIS_ UINT FAR* pctinfo) PURE;

    STDMETHOD(GetTypeInfo)(
      THIS_
      UINT itinfo,
      LCID lcid,
      ITypeInfo FAR* FAR* pptinfo) PURE;

    STDMETHOD(GetIDsOfNames)(
      THIS_
      REFIID riid,
      OLECHAR FAR* FAR* rgszNames,
      UINT cNames,
      LCID lcid,
      DISPID FAR* rgdispid) PURE;

    STDMETHOD(Invoke)(
      THIS_
      DISPID dispidMember,
      REFIID riid,
      LCID lcid,
      WORD wFlags,
      DISPPARAMS FAR* pdispparams,
      VARIANT FAR* pvarResult,
      EXCEPINFO FAR* pexcepinfo,
      UINT FAR* puArgErr) PURE;

    /* IAccessible methods */
    STDMETHOD(get_accParent)(THIS_ IDispatch * FAR* ppdispParent) PURE;
    STDMETHOD(get_accChildCount)(THIS_ long FAR* pcountChildren) PURE;
    STDMETHOD(get_accChild)(THIS_ VARIANT varChild, IDispatch * FAR* ppdispChild) PURE;
    STDMETHOD(get_accName)(THIS_ VARIANT varChild, BSTR FAR* pszName) PURE;
    STDMETHOD(get_accValue)(THIS_ VARIANT varChild, BSTR FAR* pszValue) PURE;
    STDMETHOD(get_accDescription)(THIS_ VARIANT varChild, BSTR FAR* pszDescription) PURE;
    STDMETHOD(get_accRole)(THIS_ VARIANT varChild, VARIANT FAR* pvarRole) PURE;
    STDMETHOD(get_accState)(THIS_ VARIANT varChild, VARIANT FAR* pvarState) PURE;
    STDMETHOD(get_accHelp)(THIS_ VARIANT varChild, BSTR FAR* pszHelp) PURE;
    STDMETHOD(get_accHelpTopic)(THIS_ BSTR FAR* pszHelpFile, VARIANT varChild, long FAR* pidTopic) PURE;
    STDMETHOD(get_accKeyboardShortcut)(THIS_ VARIANT varChild, BSTR FAR* pszKeyboardShortcut) PURE;
    STDMETHOD(get_accFocus)(THIS_ VARIANT FAR* pvarChild) PURE;
    STDMETHOD(get_accSelection)(THIS_ VARIANT FAR* pvarChildren) PURE;
    STDMETHOD(get_accDefaultAction)(THIS_ VARIANT varChild, BSTR FAR* pszDefaultAction) PURE;
    STDMETHOD(accSelect)(THIS_ long flagsSelect, VARIANT varChild) PURE;
    STDMETHOD(accLocation)(THIS_ long FAR* pxLeft, long FAR* pyTop, long FAR* pcxWidth, long FAR* pcyHeight, VARIANT varChild) PURE;
    STDMETHOD(accNavigate)(THIS_ long navDir, VARIANT varStart, VARIANT FAR* pvarEndUpAt) PURE;
    STDMETHOD(accHitTest)(THIS_ long xLeft, long yTop, VARIANT FAR* pvarChild) PURE;
    STDMETHOD(accDoDefaultAction)(THIS_ VARIANT varChild) PURE;
    STDMETHOD(put_accName)(THIS_ VARIANT varChild, BSTR szName) PURE;
    STDMETHOD(put_accValue)(THIS_ VARIANT varChild, BSTR szValue) PURE;

    /* _IMsoOleAccDispObj methods */
    STDMETHOD(get_Application)(THIS_ IDispatch * FAR* ppidisp) PURE;
    STDMETHOD(get_Creator)(THIS_ long FAR* plCreator) PURE;

    /* CommandBarControl methods */
    STDMETHOD(get_BeginGroup)(THIS_ VARIANT_BOOL FAR* pvarfBeginGroup) PURE;
    STDMETHOD(put_BeginGroup)(THIS_ VARIANT_BOOL varfBeginGroup) PURE;
    STDMETHOD(get_BuiltIn)(THIS_ VARIANT_BOOL FAR* pvarfBuiltIn) PURE;
    STDMETHOD(get_Caption)(THIS_ BSTR FAR* pbstrCaption) PURE;
    STDMETHOD(put_Caption)(THIS_ BSTR bstrCaption) PURE;
    STDMETHOD(get_Control)(THIS_ IDispatch * FAR* ppidisp) PURE;
    STDMETHOD(Copy)(THIS_ VARIANT Bar, VARIANT Before, CommandBarControl FAR* FAR* ppcbc) PURE;
    STDMETHOD(Delete)(THIS_ VARIANT Temporary) PURE;
    STDMETHOD(get_DescriptionText)(THIS_ BSTR FAR* pbstrText) PURE;
    STDMETHOD(put_DescriptionText)(THIS_ BSTR bstrText) PURE;
    STDMETHOD(get_Enabled)(THIS_ VARIANT_BOOL FAR* pvarfEnabled) PURE;
    STDMETHOD(put_Enabled)(THIS_ VARIANT_BOOL varfEnabled) PURE;
    STDMETHOD(Execute)(THIS) PURE;
    STDMETHOD(get_Height)(THIS_ int FAR* pdy) PURE;
    STDMETHOD(put_Height)(THIS_ int dy) PURE;
    STDMETHOD(get_HelpContextId)(THIS_ int FAR* pid) PURE;
    STDMETHOD(put_HelpContextId)(THIS_ int id) PURE;
    STDMETHOD(get_HelpFile)(THIS_ BSTR FAR* pbstrFilename) PURE;
    STDMETHOD(put_HelpFile)(THIS_ BSTR bstrFilename) PURE;
    STDMETHOD(get_Id)(THIS_ int FAR* pid) PURE;
    STDMETHOD(get_Index)(THIS_ int FAR* pi) PURE;
    STDMETHOD(get_InstanceId)(THIS_ long FAR* pid) PURE;
    STDMETHOD(Move)(THIS_ VARIANT Bar, VARIANT Before, CommandBarControl FAR* FAR* ppcbc) PURE;
    STDMETHOD(get_Left)(THIS_ int FAR* px) PURE;
    STDMETHOD(get_OLEUsage)(THIS_ MsoControlOLEUsage FAR* pcou) PURE;
    STDMETHOD(put_OLEUsage)(THIS_ MsoControlOLEUsage cou) PURE;
    STDMETHOD(get_OnAction)(THIS_ BSTR FAR* pbstrOnAction) PURE;
    STDMETHOD(put_OnAction)(THIS_ BSTR bstrOnAction) PURE;
    STDMETHOD(get_Parent)(THIS_ CommandBar FAR* FAR* ppcb) PURE;
    STDMETHOD(get_Parameter)(THIS_ BSTR FAR* pbstrParam) PURE;
    STDMETHOD(put_Parameter)(THIS_ BSTR bstrParam) PURE;
    STDMETHOD(get_Priority)(THIS_ int FAR* pnPri) PURE;
    STDMETHOD(put_Priority)(THIS_ int nPri) PURE;
    STDMETHOD(Reset)(THIS) PURE;
    STDMETHOD(SetFocus)(THIS) PURE;
    STDMETHOD(get_Tag)(THIS_ BSTR FAR* pbstrTag) PURE;
    STDMETHOD(put_Tag)(THIS_ BSTR bstrTag) PURE;
    STDMETHOD(get_TooltipText)(THIS_ BSTR FAR* pbstrTooltip) PURE;
    STDMETHOD(put_TooltipText)(THIS_ BSTR bstrTooltip) PURE;
    STDMETHOD(get_Top)(THIS_ int FAR* py) PURE;
    STDMETHOD(get_Type)(THIS_ MsoControlType FAR* ptype) PURE;
    STDMETHOD(get_Visible)(THIS_ VARIANT_BOOL FAR* pvarfVisible) PURE;
    STDMETHOD(put_Visible)(THIS_ VARIANT_BOOL varfVisible) PURE;
    STDMETHOD(get_Width)(THIS_ int FAR* pdx) PURE;
    STDMETHOD(put_Width)(THIS_ int dx) PURE;
    STDMETHOD(get_IsPriorityDropped)(THIS_ VARIANT_BOOL FAR* pvarfDropped) PURE;
    STDMETHOD(Reserved1)(THIS) PURE;
    STDMETHOD(Reserved2)(THIS) PURE;
    STDMETHOD(Reserved3)(THIS) PURE;
    STDMETHOD(Reserved4)(THIS) PURE;
    STDMETHOD(Reserved5)(THIS) PURE;
    STDMETHOD(Reserved6)(THIS) PURE;
    STDMETHOD(Reserved7)(THIS) PURE;
#endif

    /* CommandBarComboBox methods */
    STDMETHOD(AddItem)(THIS_ BSTR Text, VARIANT Index) PURE;
    STDMETHOD(Clear)(THIS) PURE;
    STDMETHOD(get_DropDownLines)(THIS_ int FAR* pcLines) PURE;
    STDMETHOD(put_DropDownLines)(THIS_ int cLines) PURE;
    STDMETHOD(get_DropDownWidth)(THIS_ int FAR* pdx) PURE;
    STDMETHOD(put_DropDownWidth)(THIS_ int dx) PURE;
    STDMETHOD(get_List)(THIS_ int Index, BSTR FAR* pbstrItem) PURE;
    STDMETHOD(put_List)(THIS_ int Index, BSTR bstrItem) PURE;
    STDMETHOD(get_ListCount)(THIS_ int FAR* pcItems) PURE;
    STDMETHOD(get_ListHeaderCount)(THIS_ int FAR* pcItems) PURE;
    STDMETHOD(put_ListHeaderCount)(THIS_ int cItems) PURE;
    STDMETHOD(get_ListIndex)(THIS_ int FAR* pi) PURE;
    STDMETHOD(put_ListIndex)(THIS_ int i) PURE;
    STDMETHOD(RemoveItem)(THIS_ int Index) PURE;
    STDMETHOD(get_Style)(THIS_ MsoComboStyle FAR* pstyle) PURE;
    STDMETHOD(put_Style)(THIS_ MsoComboStyle style) PURE;
    STDMETHOD(get_Text)(THIS_ BSTR FAR* pbstrText) PURE;
    STDMETHOD(put_Text)(THIS_ BSTR bstrText) PURE;
};

DEFINE_GUID(IID__CommandBarActiveX,0x000C030DL,0x0000,0x0000,0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46);

/* Definition of interface: _CommandBarActiveX */
#undef INTERFACE
#define INTERFACE _CommandBarActiveX

DECLARE_INTERFACE_(_CommandBarActiveX, CommandBarControl)
{
BEGIN_INTERFACE
#ifndef NO_BASEINTERFACE_FUNCS

    /* IUnknown methods */
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG, AddRef)(THIS) PURE;
    STDMETHOD_(ULONG, Release)(THIS) PURE;

    /* IDispatch methods */
    STDMETHOD(GetTypeInfoCount)(THIS_ UINT FAR* pctinfo) PURE;

    STDMETHOD(GetTypeInfo)(
      THIS_
      UINT itinfo,
      LCID lcid,
      ITypeInfo FAR* FAR* pptinfo) PURE;

    STDMETHOD(GetIDsOfNames)(
      THIS_
      REFIID riid,
      OLECHAR FAR* FAR* rgszNames,
      UINT cNames,
      LCID lcid,
      DISPID FAR* rgdispid) PURE;

    STDMETHOD(Invoke)(
      THIS_
      DISPID dispidMember,
      REFIID riid,
      LCID lcid,
      WORD wFlags,
      DISPPARAMS FAR* pdispparams,
      VARIANT FAR* pvarResult,
      EXCEPINFO FAR* pexcepinfo,
      UINT FAR* puArgErr) PURE;

    /* IAccessible methods */
    STDMETHOD(get_accParent)(THIS_ IDispatch * FAR* ppdispParent) PURE;
    STDMETHOD(get_accChildCount)(THIS_ long FAR* pcountChildren) PURE;
    STDMETHOD(get_accChild)(THIS_ VARIANT varChild, IDispatch * FAR* ppdispChild) PURE;
    STDMETHOD(get_accName)(THIS_ VARIANT varChild, BSTR FAR* pszName) PURE;
    STDMETHOD(get_accValue)(THIS_ VARIANT varChild, BSTR FAR* pszValue) PURE;
    STDMETHOD(get_accDescription)(THIS_ VARIANT varChild, BSTR FAR* pszDescription) PURE;
    STDMETHOD(get_accRole)(THIS_ VARIANT varChild, VARIANT FAR* pvarRole) PURE;
    STDMETHOD(get_accState)(THIS_ VARIANT varChild, VARIANT FAR* pvarState) PURE;
    STDMETHOD(get_accHelp)(THIS_ VARIANT varChild, BSTR FAR* pszHelp) PURE;
    STDMETHOD(get_accHelpTopic)(THIS_ BSTR FAR* pszHelpFile, VARIANT varChild, long FAR* pidTopic) PURE;
    STDMETHOD(get_accKeyboardShortcut)(THIS_ VARIANT varChild, BSTR FAR* pszKeyboardShortcut) PURE;
    STDMETHOD(get_accFocus)(THIS_ VARIANT FAR* pvarChild) PURE;
    STDMETHOD(get_accSelection)(THIS_ VARIANT FAR* pvarChildren) PURE;
    STDMETHOD(get_accDefaultAction)(THIS_ VARIANT varChild, BSTR FAR* pszDefaultAction) PURE;
    STDMETHOD(accSelect)(THIS_ long flagsSelect, VARIANT varChild) PURE;
    STDMETHOD(accLocation)(THIS_ long FAR* pxLeft, long FAR* pyTop, long FAR* pcxWidth, long FAR* pcyHeight, VARIANT varChild) PURE;
    STDMETHOD(accNavigate)(THIS_ long navDir, VARIANT varStart, VARIANT FAR* pvarEndUpAt) PURE;
    STDMETHOD(accHitTest)(THIS_ long xLeft, long yTop, VARIANT FAR* pvarChild) PURE;
    STDMETHOD(accDoDefaultAction)(THIS_ VARIANT varChild) PURE;
    STDMETHOD(put_accName)(THIS_ VARIANT varChild, BSTR szName) PURE;
    STDMETHOD(put_accValue)(THIS_ VARIANT varChild, BSTR szValue) PURE;

    /* _IMsoOleAccDispObj methods */
    STDMETHOD(get_Application)(THIS_ IDispatch * FAR* ppidisp) PURE;
    STDMETHOD(get_Creator)(THIS_ long FAR* plCreator) PURE;

    /* CommandBarControl methods */
    STDMETHOD(get_BeginGroup)(THIS_ VARIANT_BOOL FAR* pvarfBeginGroup) PURE;
    STDMETHOD(put_BeginGroup)(THIS_ VARIANT_BOOL varfBeginGroup) PURE;
    STDMETHOD(get_BuiltIn)(THIS_ VARIANT_BOOL FAR* pvarfBuiltIn) PURE;
    STDMETHOD(get_Caption)(THIS_ BSTR FAR* pbstrCaption) PURE;
    STDMETHOD(put_Caption)(THIS_ BSTR bstrCaption) PURE;
    STDMETHOD(get_Control)(THIS_ IDispatch * FAR* ppidisp) PURE;
    STDMETHOD(Copy)(THIS_ VARIANT Bar, VARIANT Before, CommandBarControl FAR* FAR* ppcbc) PURE;
    STDMETHOD(Delete)(THIS_ VARIANT Temporary) PURE;
    STDMETHOD(get_DescriptionText)(THIS_ BSTR FAR* pbstrText) PURE;
    STDMETHOD(put_DescriptionText)(THIS_ BSTR bstrText) PURE;
    STDMETHOD(get_Enabled)(THIS_ VARIANT_BOOL FAR* pvarfEnabled) PURE;
    STDMETHOD(put_Enabled)(THIS_ VARIANT_BOOL varfEnabled) PURE;
    STDMETHOD(Execute)(THIS) PURE;
    STDMETHOD(get_Height)(THIS_ int FAR* pdy) PURE;
    STDMETHOD(put_Height)(THIS_ int dy) PURE;
    STDMETHOD(get_HelpContextId)(THIS_ int FAR* pid) PURE;
    STDMETHOD(put_HelpContextId)(THIS_ int id) PURE;
    STDMETHOD(get_HelpFile)(THIS_ BSTR FAR* pbstrFilename) PURE;
    STDMETHOD(put_HelpFile)(THIS_ BSTR bstrFilename) PURE;
    STDMETHOD(get_Id)(THIS_ int FAR* pid) PURE;
    STDMETHOD(get_Index)(THIS_ int FAR* pi) PURE;
    STDMETHOD(get_InstanceId)(THIS_ long FAR* pid) PURE;
    STDMETHOD(Move)(THIS_ VARIANT Bar, VARIANT Before, CommandBarControl FAR* FAR* ppcbc) PURE;
    STDMETHOD(get_Left)(THIS_ int FAR* px) PURE;
    STDMETHOD(get_OLEUsage)(THIS_ MsoControlOLEUsage FAR* pcou) PURE;
    STDMETHOD(put_OLEUsage)(THIS_ MsoControlOLEUsage cou) PURE;
    STDMETHOD(get_OnAction)(THIS_ BSTR FAR* pbstrOnAction) PURE;
    STDMETHOD(put_OnAction)(THIS_ BSTR bstrOnAction) PURE;
    STDMETHOD(get_Parent)(THIS_ CommandBar FAR* FAR* ppcb) PURE;
    STDMETHOD(get_Parameter)(THIS_ BSTR FAR* pbstrParam) PURE;
    STDMETHOD(put_Parameter)(THIS_ BSTR bstrParam) PURE;
    STDMETHOD(get_Priority)(THIS_ int FAR* pnPri) PURE;
    STDMETHOD(put_Priority)(THIS_ int nPri) PURE;
    STDMETHOD(Reset)(THIS) PURE;
    STDMETHOD(SetFocus)(THIS) PURE;
    STDMETHOD(get_Tag)(THIS_ BSTR FAR* pbstrTag) PURE;
    STDMETHOD(put_Tag)(THIS_ BSTR bstrTag) PURE;
    STDMETHOD(get_TooltipText)(THIS_ BSTR FAR* pbstrTooltip) PURE;
    STDMETHOD(put_TooltipText)(THIS_ BSTR bstrTooltip) PURE;
    STDMETHOD(get_Top)(THIS_ int FAR* py) PURE;
    STDMETHOD(get_Type)(THIS_ MsoControlType FAR* ptype) PURE;
    STDMETHOD(get_Visible)(THIS_ VARIANT_BOOL FAR* pvarfVisible) PURE;
    STDMETHOD(put_Visible)(THIS_ VARIANT_BOOL varfVisible) PURE;
    STDMETHOD(get_Width)(THIS_ int FAR* pdx) PURE;
    STDMETHOD(put_Width)(THIS_ int dx) PURE;
    STDMETHOD(get_IsPriorityDropped)(THIS_ VARIANT_BOOL FAR* pvarfDropped) PURE;
    STDMETHOD(Reserved1)(THIS) PURE;
    STDMETHOD(Reserved2)(THIS) PURE;
    STDMETHOD(Reserved3)(THIS) PURE;
    STDMETHOD(Reserved4)(THIS) PURE;
    STDMETHOD(Reserved5)(THIS) PURE;
    STDMETHOD(Reserved6)(THIS) PURE;
    STDMETHOD(Reserved7)(THIS) PURE;
#endif

    /* _CommandBarActiveX methods */
    STDMETHOD(get_ControlCLSID)(THIS_ BSTR FAR* pbstrClsid) PURE;
    STDMETHOD(put_ControlCLSID)(THIS_ BSTR bstrClsid) PURE;
    STDMETHOD(get_QueryControlInterface)(THIS_ BSTR bstrIid, IUnknown * FAR* ppUnk) PURE;
    STDMETHOD(SetInnerObjectFactory)(THIS_ IUnknown * pUnk) PURE;
    STDMETHOD(EnsureControl)(THIS) PURE;
    STDMETHOD(put_InitWith)(THIS_ IUnknown * pStm) PURE;
};

DEFINE_GUID(IID_Adjustments,0x000C0310L,0x0000,0x0000,0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46);

/* Definition of interface: Adjustments */
#undef INTERFACE
#define INTERFACE Adjustments

DECLARE_INTERFACE_(Adjustments, _IMsoDispObj)
{
BEGIN_INTERFACE
#ifndef NO_BASEINTERFACE_FUNCS

    /* IUnknown methods */
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG, AddRef)(THIS) PURE;
    STDMETHOD_(ULONG, Release)(THIS) PURE;

    /* IDispatch methods */
    STDMETHOD(GetTypeInfoCount)(THIS_ UINT FAR* pctinfo) PURE;

    STDMETHOD(GetTypeInfo)(
      THIS_
      UINT itinfo,
      LCID lcid,
      ITypeInfo FAR* FAR* pptinfo) PURE;

    STDMETHOD(GetIDsOfNames)(
      THIS_
      REFIID riid,
      OLECHAR FAR* FAR* rgszNames,
      UINT cNames,
      LCID lcid,
      DISPID FAR* rgdispid) PURE;

    STDMETHOD(Invoke)(
      THIS_
      DISPID dispidMember,
      REFIID riid,
      LCID lcid,
      WORD wFlags,
      DISPPARAMS FAR* pdispparams,
      VARIANT FAR* pvarResult,
      EXCEPINFO FAR* pexcepinfo,
      UINT FAR* puArgErr) PURE;

    /* _IMsoDispObj methods */
    STDMETHOD(get_Application)(THIS_ IDispatch * FAR* ppidisp) PURE;
    STDMETHOD(get_Creator)(THIS_ long FAR* plCreator) PURE;
#endif

    /* Adjustments methods */
    STDMETHOD(get_Parent)(THIS_ IDispatch * FAR* Parent) PURE;
    STDMETHOD(get_Count)(THIS_ int FAR* Count) PURE;
    STDMETHOD(get_Item)(THIS_ int Index, float FAR* Val) PURE;
    STDMETHOD(put_Item)(THIS_ int Index, float Val) PURE;
};

DEFINE_GUID(IID_CalloutFormat,0x000C0311L,0x0000,0x0000,0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46);

/* Definition of interface: CalloutFormat */
#undef INTERFACE
#define INTERFACE CalloutFormat

DECLARE_INTERFACE_(CalloutFormat, _IMsoDispObj)
{
BEGIN_INTERFACE
#ifndef NO_BASEINTERFACE_FUNCS

    /* IUnknown methods */
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG, AddRef)(THIS) PURE;
    STDMETHOD_(ULONG, Release)(THIS) PURE;

    /* IDispatch methods */
    STDMETHOD(GetTypeInfoCount)(THIS_ UINT FAR* pctinfo) PURE;

    STDMETHOD(GetTypeInfo)(
      THIS_
      UINT itinfo,
      LCID lcid,
      ITypeInfo FAR* FAR* pptinfo) PURE;

    STDMETHOD(GetIDsOfNames)(
      THIS_
      REFIID riid,
      OLECHAR FAR* FAR* rgszNames,
      UINT cNames,
      LCID lcid,
      DISPID FAR* rgdispid) PURE;

    STDMETHOD(Invoke)(
      THIS_
      DISPID dispidMember,
      REFIID riid,
      LCID lcid,
      WORD wFlags,
      DISPPARAMS FAR* pdispparams,
      VARIANT FAR* pvarResult,
      EXCEPINFO FAR* pexcepinfo,
      UINT FAR* puArgErr) PURE;

    /* _IMsoDispObj methods */
    STDMETHOD(get_Application)(THIS_ IDispatch * FAR* ppidisp) PURE;
    STDMETHOD(get_Creator)(THIS_ long FAR* plCreator) PURE;
#endif

    /* CalloutFormat methods */
    STDMETHOD(get_Parent)(THIS_ IDispatch * FAR* Parent) PURE;
    STDMETHOD(AutomaticLength)(THIS) PURE;
    STDMETHOD(CustomDrop)(THIS_ float Drop) PURE;
    STDMETHOD(CustomLength)(THIS_ float Length) PURE;
    STDMETHOD(PresetDrop)(THIS_ MsoCalloutDropType DropType) PURE;
    STDMETHOD(get_Accent)(THIS_ MsoTriState FAR* Accent) PURE;
    STDMETHOD(put_Accent)(THIS_ MsoTriState Accent) PURE;
    STDMETHOD(get_Angle)(THIS_ MsoCalloutAngleType FAR* Angle) PURE;
    STDMETHOD(put_Angle)(THIS_ MsoCalloutAngleType Angle) PURE;
    STDMETHOD(get_AutoAttach)(THIS_ MsoTriState FAR* AutoAttach) PURE;
    STDMETHOD(put_AutoAttach)(THIS_ MsoTriState AutoAttach) PURE;
    STDMETHOD(get_AutoLength)(THIS_ MsoTriState FAR* AutoLength) PURE;
    STDMETHOD(get_Border)(THIS_ MsoTriState FAR* Border) PURE;
    STDMETHOD(put_Border)(THIS_ MsoTriState Border) PURE;
    STDMETHOD(get_Drop)(THIS_ float FAR* Drop) PURE;
    STDMETHOD(get_DropType)(THIS_ MsoCalloutDropType FAR* DropType) PURE;
    STDMETHOD(get_Gap)(THIS_ float FAR* Gap) PURE;
    STDMETHOD(put_Gap)(THIS_ float Gap) PURE;
    STDMETHOD(get_Length)(THIS_ float FAR* Length) PURE;
    STDMETHOD(get_Type)(THIS_ MsoCalloutType FAR* Type) PURE;
    STDMETHOD(put_Type)(THIS_ MsoCalloutType Type) PURE;
};

DEFINE_GUID(IID_ColorFormat,0x000C0312L,0x0000,0x0000,0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46);

/* Definition of interface: ColorFormat */
#undef INTERFACE
#define INTERFACE ColorFormat

DECLARE_INTERFACE_(ColorFormat, _IMsoDispObj)
{
BEGIN_INTERFACE
#ifndef NO_BASEINTERFACE_FUNCS

    /* IUnknown methods */
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG, AddRef)(THIS) PURE;
    STDMETHOD_(ULONG, Release)(THIS) PURE;

    /* IDispatch methods */
    STDMETHOD(GetTypeInfoCount)(THIS_ UINT FAR* pctinfo) PURE;

    STDMETHOD(GetTypeInfo)(
      THIS_
      UINT itinfo,
      LCID lcid,
      ITypeInfo FAR* FAR* pptinfo) PURE;

    STDMETHOD(GetIDsOfNames)(
      THIS_
      REFIID riid,
      OLECHAR FAR* FAR* rgszNames,
      UINT cNames,
      LCID lcid,
      DISPID FAR* rgdispid) PURE;

    STDMETHOD(Invoke)(
      THIS_
      DISPID dispidMember,
      REFIID riid,
      LCID lcid,
      WORD wFlags,
      DISPPARAMS FAR* pdispparams,
      VARIANT FAR* pvarResult,
      EXCEPINFO FAR* pexcepinfo,
      UINT FAR* puArgErr) PURE;

    /* _IMsoDispObj methods */
    STDMETHOD(get_Application)(THIS_ IDispatch * FAR* ppidisp) PURE;
    STDMETHOD(get_Creator)(THIS_ long FAR* plCreator) PURE;
#endif

    /* ColorFormat methods */
    STDMETHOD(get_Parent)(THIS_ IDispatch * FAR* Parent) PURE;
    STDMETHOD(get_RGB)(THIS_ MsoRGBType FAR* RGB) PURE;
    STDMETHOD(put_RGB)(THIS_ MsoRGBType RGB) PURE;
    STDMETHOD(get_SchemeColor)(THIS_ int FAR* SchemeColor) PURE;
    STDMETHOD(put_SchemeColor)(THIS_ int SchemeColor) PURE;
    STDMETHOD(get_Type)(THIS_ MsoColorType FAR* Type) PURE;
    STDMETHOD(get_TintAndShade)(THIS_ float FAR* pValue) PURE;
    STDMETHOD(put_TintAndShade)(THIS_ float value) PURE;
};

DEFINE_GUID(IID_ConnectorFormat,0x000C0313L,0x0000,0x0000,0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46);

/* Definition of interface: ConnectorFormat */
#undef INTERFACE
#define INTERFACE ConnectorFormat

DECLARE_INTERFACE_(ConnectorFormat, _IMsoDispObj)
{
BEGIN_INTERFACE
#ifndef NO_BASEINTERFACE_FUNCS

    /* IUnknown methods */
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG, AddRef)(THIS) PURE;
    STDMETHOD_(ULONG, Release)(THIS) PURE;

    /* IDispatch methods */
    STDMETHOD(GetTypeInfoCount)(THIS_ UINT FAR* pctinfo) PURE;

    STDMETHOD(GetTypeInfo)(
      THIS_
      UINT itinfo,
      LCID lcid,
      ITypeInfo FAR* FAR* pptinfo) PURE;

    STDMETHOD(GetIDsOfNames)(
      THIS_
      REFIID riid,
      OLECHAR FAR* FAR* rgszNames,
      UINT cNames,
      LCID lcid,
      DISPID FAR* rgdispid) PURE;

    STDMETHOD(Invoke)(
      THIS_
      DISPID dispidMember,
      REFIID riid,
      LCID lcid,
      WORD wFlags,
      DISPPARAMS FAR* pdispparams,
      VARIANT FAR* pvarResult,
      EXCEPINFO FAR* pexcepinfo,
      UINT FAR* puArgErr) PURE;

    /* _IMsoDispObj methods */
    STDMETHOD(get_Application)(THIS_ IDispatch * FAR* ppidisp) PURE;
    STDMETHOD(get_Creator)(THIS_ long FAR* plCreator) PURE;
#endif

    /* ConnectorFormat methods */
    STDMETHOD(get_Parent)(THIS_ IDispatch * FAR* Parent) PURE;
    STDMETHOD(BeginConnect)(THIS_ Shape FAR* ConnectedShape, int ConnectionSite) PURE;
    STDMETHOD(BeginDisconnect)(THIS) PURE;
    STDMETHOD(EndConnect)(THIS_ Shape FAR* ConnectedShape, int ConnectionSite) PURE;
    STDMETHOD(EndDisconnect)(THIS) PURE;
    STDMETHOD(get_BeginConnected)(THIS_ MsoTriState FAR* BeginConnected) PURE;
    STDMETHOD(get_BeginConnectedShape)(THIS_ Shape FAR* FAR* BeginConnectedShape) PURE;
    STDMETHOD(get_BeginConnectionSite)(THIS_ int FAR* BeginConnectionSite) PURE;
    STDMETHOD(get_EndConnected)(THIS_ MsoTriState FAR* EndConnected) PURE;
    STDMETHOD(get_EndConnectedShape)(THIS_ Shape FAR* FAR* EndConnectedShape) PURE;
    STDMETHOD(get_EndConnectionSite)(THIS_ int FAR* EndConnectionSite) PURE;
    STDMETHOD(get_Type)(THIS_ MsoConnectorType FAR* Type) PURE;
    STDMETHOD(put_Type)(THIS_ MsoConnectorType Type) PURE;
};

DEFINE_GUID(IID_FillFormat,0x000C0314L,0x0000,0x0000,0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46);

/* Definition of interface: FillFormat */
#undef INTERFACE
#define INTERFACE FillFormat

DECLARE_INTERFACE_(FillFormat, _IMsoDispObj)
{
BEGIN_INTERFACE
#ifndef NO_BASEINTERFACE_FUNCS

    /* IUnknown methods */
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG, AddRef)(THIS) PURE;
    STDMETHOD_(ULONG, Release)(THIS) PURE;

    /* IDispatch methods */
    STDMETHOD(GetTypeInfoCount)(THIS_ UINT FAR* pctinfo) PURE;

    STDMETHOD(GetTypeInfo)(
      THIS_
      UINT itinfo,
      LCID lcid,
      ITypeInfo FAR* FAR* pptinfo) PURE;

    STDMETHOD(GetIDsOfNames)(
      THIS_
      REFIID riid,
      OLECHAR FAR* FAR* rgszNames,
      UINT cNames,
      LCID lcid,
      DISPID FAR* rgdispid) PURE;

    STDMETHOD(Invoke)(
      THIS_
      DISPID dispidMember,
      REFIID riid,
      LCID lcid,
      WORD wFlags,
      DISPPARAMS FAR* pdispparams,
      VARIANT FAR* pvarResult,
      EXCEPINFO FAR* pexcepinfo,
      UINT FAR* puArgErr) PURE;

    /* _IMsoDispObj methods */
    STDMETHOD(get_Application)(THIS_ IDispatch * FAR* ppidisp) PURE;
    STDMETHOD(get_Creator)(THIS_ long FAR* plCreator) PURE;
#endif

    /* FillFormat methods */
    STDMETHOD(get_Parent)(THIS_ IDispatch * FAR* Parent) PURE;
    STDMETHOD(Background)(THIS) PURE;
    STDMETHOD(OneColorGradient)(THIS_ MsoGradientStyle Style, int Variant, float Degree) PURE;
    STDMETHOD(Patterned)(THIS_ MsoPatternType Pattern) PURE;
    STDMETHOD(PresetGradient)(THIS_ MsoGradientStyle Style, int Variant, MsoPresetGradientType PresetGradientType) PURE;
    STDMETHOD(PresetTextured)(THIS_ MsoPresetTexture PresetTexture) PURE;
    STDMETHOD(Solid)(THIS) PURE;
    STDMETHOD(TwoColorGradient)(THIS_ MsoGradientStyle Style, int Variant) PURE;
    STDMETHOD(UserPicture)(THIS_ BSTR PictureFile) PURE;
    STDMETHOD(UserTextured)(THIS_ BSTR TextureFile) PURE;
    STDMETHOD(get_BackColor)(THIS_ ColorFormat FAR* FAR* BackColor) PURE;
    STDMETHOD(put_BackColor)(THIS_ ColorFormat FAR* BackColor) PURE;
    STDMETHOD(get_ForeColor)(THIS_ ColorFormat FAR* FAR* ForeColor) PURE;
    STDMETHOD(put_ForeColor)(THIS_ ColorFormat FAR* ForeColor) PURE;
    STDMETHOD(get_GradientColorType)(THIS_ MsoGradientColorType FAR* GradientColorType) PURE;
    STDMETHOD(get_GradientDegree)(THIS_ float FAR* GradientDegree) PURE;
    STDMETHOD(get_GradientStyle)(THIS_ MsoGradientStyle FAR* GradientStyle) PURE;
    STDMETHOD(get_GradientVariant)(THIS_ int FAR* GradientVariant) PURE;
    STDMETHOD(get_Pattern)(THIS_ MsoPatternType FAR* Pattern) PURE;
    STDMETHOD(get_PresetGradientType)(THIS_ MsoPresetGradientType FAR* PresetGradientType) PURE;
    STDMETHOD(get_PresetTexture)(THIS_ MsoPresetTexture FAR* PresetTexture) PURE;
    STDMETHOD(get_TextureName)(THIS_ BSTR FAR* TextureName) PURE;
    STDMETHOD(get_TextureType)(THIS_ MsoTextureType FAR* TextureType) PURE;
    STDMETHOD(get_Transparency)(THIS_ float FAR* Transparency) PURE;
    STDMETHOD(put_Transparency)(THIS_ float Transparency) PURE;
    STDMETHOD(get_Type)(THIS_ MsoFillType FAR* Type) PURE;
    STDMETHOD(get_Visible)(THIS_ MsoTriState FAR* Visible) PURE;
    STDMETHOD(put_Visible)(THIS_ MsoTriState Visible) PURE;
};

DEFINE_GUID(IID_FreeformBuilder,0x000C0315L,0x0000,0x0000,0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46);

/* Definition of interface: FreeformBuilder */
#undef INTERFACE
#define INTERFACE FreeformBuilder

DECLARE_INTERFACE_(FreeformBuilder, _IMsoDispObj)
{
BEGIN_INTERFACE
#ifndef NO_BASEINTERFACE_FUNCS

    /* IUnknown methods */
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG, AddRef)(THIS) PURE;
    STDMETHOD_(ULONG, Release)(THIS) PURE;

    /* IDispatch methods */
    STDMETHOD(GetTypeInfoCount)(THIS_ UINT FAR* pctinfo) PURE;

    STDMETHOD(GetTypeInfo)(
      THIS_
      UINT itinfo,
      LCID lcid,
      ITypeInfo FAR* FAR* pptinfo) PURE;

    STDMETHOD(GetIDsOfNames)(
      THIS_
      REFIID riid,
      OLECHAR FAR* FAR* rgszNames,
      UINT cNames,
      LCID lcid,
      DISPID FAR* rgdispid) PURE;

    STDMETHOD(Invoke)(
      THIS_
      DISPID dispidMember,
      REFIID riid,
      LCID lcid,
      WORD wFlags,
      DISPPARAMS FAR* pdispparams,
      VARIANT FAR* pvarResult,
      EXCEPINFO FAR* pexcepinfo,
      UINT FAR* puArgErr) PURE;

    /* _IMsoDispObj methods */
    STDMETHOD(get_Application)(THIS_ IDispatch * FAR* ppidisp) PURE;
    STDMETHOD(get_Creator)(THIS_ long FAR* plCreator) PURE;
#endif

    /* FreeformBuilder methods */
    STDMETHOD(get_Parent)(THIS_ IDispatch * FAR* Parent) PURE;
    STDMETHOD(AddNodes)(THIS_ MsoSegmentType SegmentType, MsoEditingType EditingType, float X1, float Y1, float X2, float Y2, float X3, float Y3) PURE;
    STDMETHOD(ConvertToShape)(THIS_ Shape FAR* FAR* Freeform) PURE;
};

DEFINE_GUID(IID_GroupShapes,0x000C0316L,0x0000,0x0000,0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46);

/* Definition of interface: GroupShapes */
#undef INTERFACE
#define INTERFACE GroupShapes

DECLARE_INTERFACE_(GroupShapes, _IMsoDispObj)
{
BEGIN_INTERFACE
#ifndef NO_BASEINTERFACE_FUNCS

    /* IUnknown methods */
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG, AddRef)(THIS) PURE;
    STDMETHOD_(ULONG, Release)(THIS) PURE;

    /* IDispatch methods */
    STDMETHOD(GetTypeInfoCount)(THIS_ UINT FAR* pctinfo) PURE;

    STDMETHOD(GetTypeInfo)(
      THIS_
      UINT itinfo,
      LCID lcid,
      ITypeInfo FAR* FAR* pptinfo) PURE;

    STDMETHOD(GetIDsOfNames)(
      THIS_
      REFIID riid,
      OLECHAR FAR* FAR* rgszNames,
      UINT cNames,
      LCID lcid,
      DISPID FAR* rgdispid) PURE;

    STDMETHOD(Invoke)(
      THIS_
      DISPID dispidMember,
      REFIID riid,
      LCID lcid,
      WORD wFlags,
      DISPPARAMS FAR* pdispparams,
      VARIANT FAR* pvarResult,
      EXCEPINFO FAR* pexcepinfo,
      UINT FAR* puArgErr) PURE;

    /* _IMsoDispObj methods */
    STDMETHOD(get_Application)(THIS_ IDispatch * FAR* ppidisp) PURE;
    STDMETHOD(get_Creator)(THIS_ long FAR* plCreator) PURE;
#endif

    /* GroupShapes methods */
    STDMETHOD(get_Parent)(THIS_ IDispatch * FAR* ppidisp) PURE;
    STDMETHOD(get_Count)(THIS_ int FAR* pnShapes) PURE;
    STDMETHOD(Item)(THIS_ VARIANT Index, Shape FAR* FAR* Item) PURE;
    STDMETHOD(get__NewEnum)(THIS_ IUnknown * FAR* ppienum) PURE;
    STDMETHOD(Range)(THIS_ VARIANT Index, ShapeRange FAR* FAR* Range) PURE;
};

DEFINE_GUID(IID_LineFormat,0x000C0317L,0x0000,0x0000,0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46);

/* Definition of interface: LineFormat */
#undef INTERFACE
#define INTERFACE LineFormat

DECLARE_INTERFACE_(LineFormat, _IMsoDispObj)
{
BEGIN_INTERFACE
#ifndef NO_BASEINTERFACE_FUNCS

    /* IUnknown methods */
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG, AddRef)(THIS) PURE;
    STDMETHOD_(ULONG, Release)(THIS) PURE;

    /* IDispatch methods */
    STDMETHOD(GetTypeInfoCount)(THIS_ UINT FAR* pctinfo) PURE;

    STDMETHOD(GetTypeInfo)(
      THIS_
      UINT itinfo,
      LCID lcid,
      ITypeInfo FAR* FAR* pptinfo) PURE;

    STDMETHOD(GetIDsOfNames)(
      THIS_
      REFIID riid,
      OLECHAR FAR* FAR* rgszNames,
      UINT cNames,
      LCID lcid,
      DISPID FAR* rgdispid) PURE;

    STDMETHOD(Invoke)(
      THIS_
      DISPID dispidMember,
      REFIID riid,
      LCID lcid,
      WORD wFlags,
      DISPPARAMS FAR* pdispparams,
      VARIANT FAR* pvarResult,
      EXCEPINFO FAR* pexcepinfo,
      UINT FAR* puArgErr) PURE;

    /* _IMsoDispObj methods */
    STDMETHOD(get_Application)(THIS_ IDispatch * FAR* ppidisp) PURE;
    STDMETHOD(get_Creator)(THIS_ long FAR* plCreator) PURE;
#endif

    /* LineFormat methods */
    STDMETHOD(get_Parent)(THIS_ IDispatch * FAR* Parent) PURE;
    STDMETHOD(get_BackColor)(THIS_ ColorFormat FAR* FAR* BackColor) PURE;
    STDMETHOD(put_BackColor)(THIS_ ColorFormat FAR* BackColor) PURE;
    STDMETHOD(get_BeginArrowheadLength)(THIS_ MsoArrowheadLength FAR* BeginArrowheadLength) PURE;
    STDMETHOD(put_BeginArrowheadLength)(THIS_ MsoArrowheadLength BeginArrowheadLength) PURE;
    STDMETHOD(get_BeginArrowheadStyle)(THIS_ MsoArrowheadStyle FAR* BeginArrowheadStyle) PURE;
    STDMETHOD(put_BeginArrowheadStyle)(THIS_ MsoArrowheadStyle BeginArrowheadStyle) PURE;
    STDMETHOD(get_BeginArrowheadWidth)(THIS_ MsoArrowheadWidth FAR* BeginArrowheadWidth) PURE;
    STDMETHOD(put_BeginArrowheadWidth)(THIS_ MsoArrowheadWidth BeginArrowheadWidth) PURE;
    STDMETHOD(get_DashStyle)(THIS_ MsoLineDashStyle FAR* DashStyle) PURE;
    STDMETHOD(put_DashStyle)(THIS_ MsoLineDashStyle DashStyle) PURE;
    STDMETHOD(get_EndArrowheadLength)(THIS_ MsoArrowheadLength FAR* EndArrowheadLength) PURE;
    STDMETHOD(put_EndArrowheadLength)(THIS_ MsoArrowheadLength EndArrowheadLength) PURE;
    STDMETHOD(get_EndArrowheadStyle)(THIS_ MsoArrowheadStyle FAR* EndArrowheadStyle) PURE;
    STDMETHOD(put_EndArrowheadStyle)(THIS_ MsoArrowheadStyle EndArrowheadStyle) PURE;
    STDMETHOD(get_EndArrowheadWidth)(THIS_ MsoArrowheadWidth FAR* EndArrowheadWidth) PURE;
    STDMETHOD(put_EndArrowheadWidth)(THIS_ MsoArrowheadWidth EndArrowheadWidth) PURE;
    STDMETHOD(get_ForeColor)(THIS_ ColorFormat FAR* FAR* ForeColor) PURE;
    STDMETHOD(put_ForeColor)(THIS_ ColorFormat FAR* ForeColor) PURE;
    STDMETHOD(get_Pattern)(THIS_ MsoPatternType FAR* Pattern) PURE;
    STDMETHOD(put_Pattern)(THIS_ MsoPatternType Pattern) PURE;
    STDMETHOD(get_Style)(THIS_ MsoLineStyle FAR* Style) PURE;
    STDMETHOD(put_Style)(THIS_ MsoLineStyle Style) PURE;
    STDMETHOD(get_Transparency)(THIS_ float FAR* Transparency) PURE;
    STDMETHOD(put_Transparency)(THIS_ float Transparency) PURE;
    STDMETHOD(get_Visible)(THIS_ MsoTriState FAR* Visible) PURE;
    STDMETHOD(put_Visible)(THIS_ MsoTriState Visible) PURE;
    STDMETHOD(get_Weight)(THIS_ float FAR* Weight) PURE;
    STDMETHOD(put_Weight)(THIS_ float Weight) PURE;
    STDMETHOD(get_InsetPen)(THIS_ MsoTriState FAR* InsetPen) PURE;
    STDMETHOD(put_InsetPen)(THIS_ MsoTriState InsetPen) PURE;
};

DEFINE_GUID(IID_ShapeNode,0x000C0318L,0x0000,0x0000,0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46);

/* Definition of interface: ShapeNode */
#undef INTERFACE
#define INTERFACE ShapeNode

DECLARE_INTERFACE_(ShapeNode, _IMsoDispObj)
{
BEGIN_INTERFACE
#ifndef NO_BASEINTERFACE_FUNCS

    /* IUnknown methods */
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG, AddRef)(THIS) PURE;
    STDMETHOD_(ULONG, Release)(THIS) PURE;

    /* IDispatch methods */
    STDMETHOD(GetTypeInfoCount)(THIS_ UINT FAR* pctinfo) PURE;

    STDMETHOD(GetTypeInfo)(
      THIS_
      UINT itinfo,
      LCID lcid,
      ITypeInfo FAR* FAR* pptinfo) PURE;

    STDMETHOD(GetIDsOfNames)(
      THIS_
      REFIID riid,
      OLECHAR FAR* FAR* rgszNames,
      UINT cNames,
      LCID lcid,
      DISPID FAR* rgdispid) PURE;

    STDMETHOD(Invoke)(
      THIS_
      DISPID dispidMember,
      REFIID riid,
      LCID lcid,
      WORD wFlags,
      DISPPARAMS FAR* pdispparams,
      VARIANT FAR* pvarResult,
      EXCEPINFO FAR* pexcepinfo,
      UINT FAR* puArgErr) PURE;

    /* _IMsoDispObj methods */
    STDMETHOD(get_Application)(THIS_ IDispatch * FAR* ppidisp) PURE;
    STDMETHOD(get_Creator)(THIS_ long FAR* plCreator) PURE;
#endif

    /* ShapeNode methods */
    STDMETHOD(get_Parent)(THIS_ IDispatch * FAR* Parent) PURE;
    STDMETHOD(get_EditingType)(THIS_ MsoEditingType FAR* EditingType) PURE;
    STDMETHOD(get_Points)(THIS_ VARIANT FAR* Points) PURE;
    STDMETHOD(get_SegmentType)(THIS_ MsoSegmentType FAR* SegmentType) PURE;
};

DEFINE_GUID(IID_ShapeNodes,0x000C0319L,0x0000,0x0000,0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46);

/* Definition of interface: ShapeNodes */
#undef INTERFACE
#define INTERFACE ShapeNodes

DECLARE_INTERFACE_(ShapeNodes, _IMsoDispObj)
{
BEGIN_INTERFACE
#ifndef NO_BASEINTERFACE_FUNCS

    /* IUnknown methods */
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG, AddRef)(THIS) PURE;
    STDMETHOD_(ULONG, Release)(THIS) PURE;

    /* IDispatch methods */
    STDMETHOD(GetTypeInfoCount)(THIS_ UINT FAR* pctinfo) PURE;

    STDMETHOD(GetTypeInfo)(
      THIS_
      UINT itinfo,
      LCID lcid,
      ITypeInfo FAR* FAR* pptinfo) PURE;

    STDMETHOD(GetIDsOfNames)(
      THIS_
      REFIID riid,
      OLECHAR FAR* FAR* rgszNames,
      UINT cNames,
      LCID lcid,
      DISPID FAR* rgdispid) PURE;

    STDMETHOD(Invoke)(
      THIS_
      DISPID dispidMember,
      REFIID riid,
      LCID lcid,
      WORD wFlags,
      DISPPARAMS FAR* pdispparams,
      VARIANT FAR* pvarResult,
      EXCEPINFO FAR* pexcepinfo,
      UINT FAR* puArgErr) PURE;

    /* _IMsoDispObj methods */
    STDMETHOD(get_Application)(THIS_ IDispatch * FAR* ppidisp) PURE;
    STDMETHOD(get_Creator)(THIS_ long FAR* plCreator) PURE;
#endif

    /* ShapeNodes methods */
    STDMETHOD(get_Parent)(THIS_ IDispatch * FAR* Parent) PURE;
    STDMETHOD(get_Count)(THIS_ int FAR* Count) PURE;
    STDMETHOD(Item)(THIS_ VARIANT Index, ShapeNode FAR* FAR* Item) PURE;
    STDMETHOD(get__NewEnum)(THIS_ IUnknown * FAR* _NewEnum) PURE;
    STDMETHOD(Delete)(THIS_ int Index) PURE;
    STDMETHOD(Insert)(THIS_ int Index, MsoSegmentType SegmentType, MsoEditingType EditingType, float X1, float Y1, float X2, float Y2, float X3, float Y3) PURE;
    STDMETHOD(SetEditingType)(THIS_ int Index, MsoEditingType EditingType) PURE;
    STDMETHOD(SetPosition)(THIS_ int Index, float X1, float Y1) PURE;
    STDMETHOD(SetSegmentType)(THIS_ int Index, MsoSegmentType SegmentType) PURE;
};

DEFINE_GUID(IID_PictureFormat,0x000C031AL,0x0000,0x0000,0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46);

/* Definition of interface: PictureFormat */
#undef INTERFACE
#define INTERFACE PictureFormat

DECLARE_INTERFACE_(PictureFormat, _IMsoDispObj)
{
BEGIN_INTERFACE
#ifndef NO_BASEINTERFACE_FUNCS

    /* IUnknown methods */
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG, AddRef)(THIS) PURE;
    STDMETHOD_(ULONG, Release)(THIS) PURE;

    /* IDispatch methods */
    STDMETHOD(GetTypeInfoCount)(THIS_ UINT FAR* pctinfo) PURE;

    STDMETHOD(GetTypeInfo)(
      THIS_
      UINT itinfo,
      LCID lcid,
      ITypeInfo FAR* FAR* pptinfo) PURE;

    STDMETHOD(GetIDsOfNames)(
      THIS_
      REFIID riid,
      OLECHAR FAR* FAR* rgszNames,
      UINT cNames,
      LCID lcid,
      DISPID FAR* rgdispid) PURE;

    STDMETHOD(Invoke)(
      THIS_
      DISPID dispidMember,
      REFIID riid,
      LCID lcid,
      WORD wFlags,
      DISPPARAMS FAR* pdispparams,
      VARIANT FAR* pvarResult,
      EXCEPINFO FAR* pexcepinfo,
      UINT FAR* puArgErr) PURE;

    /* _IMsoDispObj methods */
    STDMETHOD(get_Application)(THIS_ IDispatch * FAR* ppidisp) PURE;
    STDMETHOD(get_Creator)(THIS_ long FAR* plCreator) PURE;
#endif

    /* PictureFormat methods */
    STDMETHOD(get_Parent)(THIS_ IDispatch * FAR* Parent) PURE;
    STDMETHOD(IncrementBrightness)(THIS_ float Increment) PURE;
    STDMETHOD(IncrementContrast)(THIS_ float Increment) PURE;
    STDMETHOD(get_Brightness)(THIS_ float FAR* Brightness) PURE;
    STDMETHOD(put_Brightness)(THIS_ float Brightness) PURE;
    STDMETHOD(get_ColorType)(THIS_ MsoPictureColorType FAR* ColorType) PURE;
    STDMETHOD(put_ColorType)(THIS_ MsoPictureColorType ColorType) PURE;
    STDMETHOD(get_Contrast)(THIS_ float FAR* Contrast) PURE;
    STDMETHOD(put_Contrast)(THIS_ float Contrast) PURE;
    STDMETHOD(get_CropBottom)(THIS_ float FAR* CropBottom) PURE;
    STDMETHOD(put_CropBottom)(THIS_ float CropBottom) PURE;
    STDMETHOD(get_CropLeft)(THIS_ float FAR* CropLeft) PURE;
    STDMETHOD(put_CropLeft)(THIS_ float CropLeft) PURE;
    STDMETHOD(get_CropRight)(THIS_ float FAR* CropRight) PURE;
    STDMETHOD(put_CropRight)(THIS_ float CropRight) PURE;
    STDMETHOD(get_CropTop)(THIS_ float FAR* CropTop) PURE;
    STDMETHOD(put_CropTop)(THIS_ float CropTop) PURE;
    STDMETHOD(get_TransparencyColor)(THIS_ MsoRGBType FAR* TransparencyColor) PURE;
    STDMETHOD(put_TransparencyColor)(THIS_ MsoRGBType TransparencyColor) PURE;
    STDMETHOD(get_TransparentBackground)(THIS_ MsoTriState FAR* TransparentBackground) PURE;
    STDMETHOD(put_TransparentBackground)(THIS_ MsoTriState TransparentBackground) PURE;
};

DEFINE_GUID(IID_ShadowFormat,0x000C031BL,0x0000,0x0000,0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46);

/* Definition of interface: ShadowFormat */
#undef INTERFACE
#define INTERFACE ShadowFormat

DECLARE_INTERFACE_(ShadowFormat, _IMsoDispObj)
{
BEGIN_INTERFACE
#ifndef NO_BASEINTERFACE_FUNCS

    /* IUnknown methods */
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG, AddRef)(THIS) PURE;
    STDMETHOD_(ULONG, Release)(THIS) PURE;

    /* IDispatch methods */
    STDMETHOD(GetTypeInfoCount)(THIS_ UINT FAR* pctinfo) PURE;

    STDMETHOD(GetTypeInfo)(
      THIS_
      UINT itinfo,
      LCID lcid,
      ITypeInfo FAR* FAR* pptinfo) PURE;

    STDMETHOD(GetIDsOfNames)(
      THIS_
      REFIID riid,
      OLECHAR FAR* FAR* rgszNames,
      UINT cNames,
      LCID lcid,
      DISPID FAR* rgdispid) PURE;

    STDMETHOD(Invoke)(
      THIS_
      DISPID dispidMember,
      REFIID riid,
      LCID lcid,
      WORD wFlags,
      DISPPARAMS FAR* pdispparams,
      VARIANT FAR* pvarResult,
      EXCEPINFO FAR* pexcepinfo,
      UINT FAR* puArgErr) PURE;

    /* _IMsoDispObj methods */
    STDMETHOD(get_Application)(THIS_ IDispatch * FAR* ppidisp) PURE;
    STDMETHOD(get_Creator)(THIS_ long FAR* plCreator) PURE;
#endif

    /* ShadowFormat methods */
    STDMETHOD(get_Parent)(THIS_ IDispatch * FAR* Parent) PURE;
    STDMETHOD(IncrementOffsetX)(THIS_ float Increment) PURE;
    STDMETHOD(IncrementOffsetY)(THIS_ float Increment) PURE;
    STDMETHOD(get_ForeColor)(THIS_ ColorFormat FAR* FAR* ForeColor) PURE;
    STDMETHOD(put_ForeColor)(THIS_ ColorFormat FAR* ForeColor) PURE;
    STDMETHOD(get_Obscured)(THIS_ MsoTriState FAR* Obscured) PURE;
    STDMETHOD(put_Obscured)(THIS_ MsoTriState Obscured) PURE;
    STDMETHOD(get_OffsetX)(THIS_ float FAR* OffsetX) PURE;
    STDMETHOD(put_OffsetX)(THIS_ float OffsetX) PURE;
    STDMETHOD(get_OffsetY)(THIS_ float FAR* OffsetY) PURE;
    STDMETHOD(put_OffsetY)(THIS_ float OffsetY) PURE;
    STDMETHOD(get_Transparency)(THIS_ float FAR* Transparency) PURE;
    STDMETHOD(put_Transparency)(THIS_ float Transparency) PURE;
    STDMETHOD(get_Type)(THIS_ MsoShadowType FAR* Type) PURE;
    STDMETHOD(put_Type)(THIS_ MsoShadowType Type) PURE;
    STDMETHOD(get_Visible)(THIS_ MsoTriState FAR* Visible) PURE;
    STDMETHOD(put_Visible)(THIS_ MsoTriState Visible) PURE;
};

typedef enum {
    msoScriptLanguageJava = 1,
    msoScriptLanguageVisualBasic = 2,
    msoScriptLanguageASP = 3,
    msoScriptLanguageOther = 4
} MsoScriptLanguage;

typedef enum {
    msoScriptLocationInHead = 1,
    msoScriptLocationInBody = 2
} MsoScriptLocation;

DEFINE_GUID(IID_Script,0x000C0341L,0x0000,0x0000,0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46);

/* Definition of interface: Script */
#undef INTERFACE
#define INTERFACE Script

DECLARE_INTERFACE_(Script, _IMsoDispObj)
{
BEGIN_INTERFACE
#ifndef NO_BASEINTERFACE_FUNCS

    /* IUnknown methods */
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG, AddRef)(THIS) PURE;
    STDMETHOD_(ULONG, Release)(THIS) PURE;

    /* IDispatch methods */
    STDMETHOD(GetTypeInfoCount)(THIS_ UINT FAR* pctinfo) PURE;

    STDMETHOD(GetTypeInfo)(
      THIS_
      UINT itinfo,
      LCID lcid,
      ITypeInfo FAR* FAR* pptinfo) PURE;

    STDMETHOD(GetIDsOfNames)(
      THIS_
      REFIID riid,
      OLECHAR FAR* FAR* rgszNames,
      UINT cNames,
      LCID lcid,
      DISPID FAR* rgdispid) PURE;

    STDMETHOD(Invoke)(
      THIS_
      DISPID dispidMember,
      REFIID riid,
      LCID lcid,
      WORD wFlags,
      DISPPARAMS FAR* pdispparams,
      VARIANT FAR* pvarResult,
      EXCEPINFO FAR* pexcepinfo,
      UINT FAR* puArgErr) PURE;

    /* _IMsoDispObj methods */
    STDMETHOD(get_Application)(THIS_ IDispatch * FAR* ppidisp) PURE;
    STDMETHOD(get_Creator)(THIS_ long FAR* plCreator) PURE;
#endif

    /* Script methods */
    STDMETHOD(get_Parent)(THIS_ IDispatch * FAR* Parent) PURE;
    STDMETHOD(get_Extended)(THIS_ BSTR FAR* Extended) PURE;
    STDMETHOD(put_Extended)(THIS_ BSTR Extended) PURE;
    STDMETHOD(get_Id)(THIS_ BSTR FAR* Id) PURE;
    STDMETHOD(put_Id)(THIS_ BSTR Id) PURE;
    STDMETHOD(get_Language)(THIS_ MsoScriptLanguage FAR* Language) PURE;
    STDMETHOD(put_Language)(THIS_ MsoScriptLanguage Language) PURE;
    STDMETHOD(get_Location)(THIS_ MsoScriptLocation FAR* Location) PURE;
    STDMETHOD(Delete)(THIS) PURE;
    STDMETHOD(get_Shape)(THIS_ IDispatch * FAR* Object) PURE;
    STDMETHOD(get_ScriptText)(THIS_ BSTR FAR* Script) PURE;
    STDMETHOD(put_ScriptText)(THIS_ BSTR Script) PURE;
};

DEFINE_GUID(IID_Scripts,0x000C0340L,0x0000,0x0000,0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46);

/* Definition of interface: Scripts */
#undef INTERFACE
#define INTERFACE Scripts

DECLARE_INTERFACE_(Scripts, _IMsoDispObj)
{
BEGIN_INTERFACE
#ifndef NO_BASEINTERFACE_FUNCS

    /* IUnknown methods */
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG, AddRef)(THIS) PURE;
    STDMETHOD_(ULONG, Release)(THIS) PURE;

    /* IDispatch methods */
    STDMETHOD(GetTypeInfoCount)(THIS_ UINT FAR* pctinfo) PURE;

    STDMETHOD(GetTypeInfo)(
      THIS_
      UINT itinfo,
      LCID lcid,
      ITypeInfo FAR* FAR* pptinfo) PURE;

    STDMETHOD(GetIDsOfNames)(
      THIS_
      REFIID riid,
      OLECHAR FAR* FAR* rgszNames,
      UINT cNames,
      LCID lcid,
      DISPID FAR* rgdispid) PURE;

    STDMETHOD(Invoke)(
      THIS_
      DISPID dispidMember,
      REFIID riid,
      LCID lcid,
      WORD wFlags,
      DISPPARAMS FAR* pdispparams,
      VARIANT FAR* pvarResult,
      EXCEPINFO FAR* pexcepinfo,
      UINT FAR* puArgErr) PURE;

    /* _IMsoDispObj methods */
    STDMETHOD(get_Application)(THIS_ IDispatch * FAR* ppidisp) PURE;
    STDMETHOD(get_Creator)(THIS_ long FAR* plCreator) PURE;
#endif

    /* Scripts methods */
    STDMETHOD(get_Parent)(THIS_ IDispatch * FAR* Parent) PURE;
    STDMETHOD(get_Count)(THIS_ long FAR* Count) PURE;
    STDMETHOD(get__NewEnum)(THIS_ IUnknown * FAR* _NewEnum) PURE;
    STDMETHOD(Item)(THIS_ VARIANT Index, Script FAR* FAR* Item) PURE;
    STDMETHOD(Add)(THIS_ IDispatch * Anchor, MsoScriptLocation Location, MsoScriptLanguage Language, BSTR Id, BSTR Extended, BSTR ScriptText, Script FAR* FAR* Add) PURE;
    STDMETHOD(Delete)(THIS) PURE;
};

DEFINE_GUID(IID_Shape,0x000C031CL,0x0000,0x0000,0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46);

/* Definition of interface: Shape */
#undef INTERFACE
#define INTERFACE Shape

DECLARE_INTERFACE_(Shape, _IMsoDispObj)
{
BEGIN_INTERFACE
#ifndef NO_BASEINTERFACE_FUNCS

    /* IUnknown methods */
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG, AddRef)(THIS) PURE;
    STDMETHOD_(ULONG, Release)(THIS) PURE;

    /* IDispatch methods */
    STDMETHOD(GetTypeInfoCount)(THIS_ UINT FAR* pctinfo) PURE;

    STDMETHOD(GetTypeInfo)(
      THIS_
      UINT itinfo,
      LCID lcid,
      ITypeInfo FAR* FAR* pptinfo) PURE;

    STDMETHOD(GetIDsOfNames)(
      THIS_
      REFIID riid,
      OLECHAR FAR* FAR* rgszNames,
      UINT cNames,
      LCID lcid,
      DISPID FAR* rgdispid) PURE;

    STDMETHOD(Invoke)(
      THIS_
      DISPID dispidMember,
      REFIID riid,
      LCID lcid,
      WORD wFlags,
      DISPPARAMS FAR* pdispparams,
      VARIANT FAR* pvarResult,
      EXCEPINFO FAR* pexcepinfo,
      UINT FAR* puArgErr) PURE;

    /* _IMsoDispObj methods */
    STDMETHOD(get_Application)(THIS_ IDispatch * FAR* ppidisp) PURE;
    STDMETHOD(get_Creator)(THIS_ long FAR* plCreator) PURE;
#endif

    /* Shape methods */
    STDMETHOD(get_Parent)(THIS_ IDispatch * FAR* Parent) PURE;
    STDMETHOD(Apply)(THIS) PURE;
    STDMETHOD(Delete)(THIS) PURE;
    STDMETHOD(Duplicate)(THIS_ Shape FAR* FAR* Duplicate) PURE;
    STDMETHOD(Flip)(THIS_ MsoFlipCmd FlipCmd) PURE;
    STDMETHOD(IncrementLeft)(THIS_ float Increment) PURE;
    STDMETHOD(IncrementRotation)(THIS_ float Increment) PURE;
    STDMETHOD(IncrementTop)(THIS_ float Increment) PURE;
    STDMETHOD(PickUp)(THIS) PURE;
    STDMETHOD(RerouteConnections)(THIS) PURE;
    STDMETHOD(ScaleHeight)(THIS_ float Factor, MsoTriState RelativeToOriginalSize, MsoScaleFrom fScale) PURE;
    STDMETHOD(ScaleWidth)(THIS_ float Factor, MsoTriState RelativeToOriginalSize, MsoScaleFrom fScale) PURE;
    STDMETHOD(Select)(THIS_ VARIANT Replace) PURE;
    STDMETHOD(SetShapesDefaultProperties)(THIS) PURE;
    STDMETHOD(Ungroup)(THIS_ ShapeRange FAR* FAR* Ungroup) PURE;
    STDMETHOD(ZOrder)(THIS_ MsoZOrderCmd ZOrderCmd) PURE;
    STDMETHOD(get_Adjustments)(THIS_ Adjustments FAR* FAR* Adjustments) PURE;
    STDMETHOD(get_AutoShapeType)(THIS_ MsoAutoShapeType FAR* AutoShapeType) PURE;
    STDMETHOD(put_AutoShapeType)(THIS_ MsoAutoShapeType AutoShapeType) PURE;
    STDMETHOD(get_BlackWhiteMode)(THIS_ MsoBlackWhiteMode FAR* BlackWhiteMode) PURE;
    STDMETHOD(put_BlackWhiteMode)(THIS_ MsoBlackWhiteMode BlackWhiteMode) PURE;
    STDMETHOD(get_Callout)(THIS_ CalloutFormat FAR* FAR* Callout) PURE;
    STDMETHOD(get_ConnectionSiteCount)(THIS_ int FAR* ConnectionSiteCount) PURE;
    STDMETHOD(get_Connector)(THIS_ MsoTriState FAR* Connector) PURE;
    STDMETHOD(get_ConnectorFormat)(THIS_ ConnectorFormat FAR* FAR* ConnectorFormat) PURE;
    STDMETHOD(get_Fill)(THIS_ FillFormat FAR* FAR* Fill) PURE;
    STDMETHOD(get_GroupItems)(THIS_ GroupShapes FAR* FAR* GroupItems) PURE;
    STDMETHOD(get_Height)(THIS_ float FAR* Height) PURE;
    STDMETHOD(put_Height)(THIS_ float Height) PURE;
    STDMETHOD(get_HorizontalFlip)(THIS_ MsoTriState FAR* HorizontalFlip) PURE;
    STDMETHOD(get_Left)(THIS_ float FAR* Left) PURE;
    STDMETHOD(put_Left)(THIS_ float Left) PURE;
    STDMETHOD(get_Line)(THIS_ LineFormat FAR* FAR* Line) PURE;
    STDMETHOD(get_LockAspectRatio)(THIS_ MsoTriState FAR* LockAspectRatio) PURE;
    STDMETHOD(put_LockAspectRatio)(THIS_ MsoTriState LockAspectRatio) PURE;
    STDMETHOD(get_Name)(THIS_ BSTR FAR* Name) PURE;
    STDMETHOD(put_Name)(THIS_ BSTR Name) PURE;
    STDMETHOD(get_Nodes)(THIS_ ShapeNodes FAR* FAR* Nodes) PURE;
    STDMETHOD(get_Rotation)(THIS_ float FAR* Rotation) PURE;
    STDMETHOD(put_Rotation)(THIS_ float Rotation) PURE;
    STDMETHOD(get_PictureFormat)(THIS_ PictureFormat FAR* FAR* Picture) PURE;
    STDMETHOD(get_Shadow)(THIS_ ShadowFormat FAR* FAR* Shadow) PURE;
    STDMETHOD(get_TextEffect)(THIS_ TextEffectFormat FAR* FAR* TextEffect) PURE;
    STDMETHOD(get_TextFrame)(THIS_ TextFrame FAR* FAR* TextFrame) PURE;
    STDMETHOD(get_ThreeD)(THIS_ ThreeDFormat FAR* FAR* ThreeD) PURE;
    STDMETHOD(get_Top)(THIS_ float FAR* Top) PURE;
    STDMETHOD(put_Top)(THIS_ float Top) PURE;
    STDMETHOD(get_Type)(THIS_ MsoShapeType FAR* Type) PURE;
    STDMETHOD(get_VerticalFlip)(THIS_ MsoTriState FAR* VerticalFlip) PURE;
    STDMETHOD(get_Vertices)(THIS_ VARIANT FAR* Vertices) PURE;
    STDMETHOD(get_Visible)(THIS_ MsoTriState FAR* Visible) PURE;
    STDMETHOD(put_Visible)(THIS_ MsoTriState Visible) PURE;
    STDMETHOD(get_Width)(THIS_ float FAR* Width) PURE;
    STDMETHOD(put_Width)(THIS_ float Width) PURE;
    STDMETHOD(get_ZOrderPosition)(THIS_ int FAR* ZOrderPosition) PURE;
    STDMETHOD(get_Script)(THIS_ Script FAR* FAR* Script) PURE;
    STDMETHOD(get_AlternativeText)(THIS_ BSTR FAR* AlternativeText) PURE;
    STDMETHOD(put_AlternativeText)(THIS_ BSTR AlternativeText) PURE;
    STDMETHOD(get_HasDiagram)(THIS_ MsoTriState FAR* pHasDiagram) PURE;
    STDMETHOD(get_Diagram)(THIS_ IMsoDiagram FAR* FAR* Diagram) PURE;
    STDMETHOD(get_HasDiagramNode)(THIS_ MsoTriState FAR* pHasDiagram) PURE;
    STDMETHOD(get_DiagramNode)(THIS_ DiagramNode FAR* FAR* DiagramNode) PURE;
    STDMETHOD(get_Child)(THIS_ MsoTriState FAR* Child) PURE;
    STDMETHOD(get_ParentGroup)(THIS_ Shape FAR* FAR* Parent) PURE;
    STDMETHOD(get_CanvasItems)(THIS_ CanvasShapes FAR* FAR* CanvasShapes) PURE;
    STDMETHOD(get_Id)(THIS_ int FAR* pid) PURE;
    STDMETHOD(CanvasCropLeft)(THIS_ float Increment) PURE;
    STDMETHOD(CanvasCropTop)(THIS_ float Increment) PURE;
    STDMETHOD(CanvasCropRight)(THIS_ float Increment) PURE;
    STDMETHOD(CanvasCropBottom)(THIS_ float Increment) PURE;
    STDMETHOD(put_RTF)(THIS_ BSTR Text) PURE;
};

DEFINE_GUID(IID_ShapeRange,0x000C031DL,0x0000,0x0000,0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46);

/* Definition of interface: ShapeRange */
#undef INTERFACE
#define INTERFACE ShapeRange

DECLARE_INTERFACE_(ShapeRange, _IMsoDispObj)
{
BEGIN_INTERFACE
#ifndef NO_BASEINTERFACE_FUNCS

    /* IUnknown methods */
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG, AddRef)(THIS) PURE;
    STDMETHOD_(ULONG, Release)(THIS) PURE;

    /* IDispatch methods */
    STDMETHOD(GetTypeInfoCount)(THIS_ UINT FAR* pctinfo) PURE;

    STDMETHOD(GetTypeInfo)(
      THIS_
      UINT itinfo,
      LCID lcid,
      ITypeInfo FAR* FAR* pptinfo) PURE;

    STDMETHOD(GetIDsOfNames)(
      THIS_
      REFIID riid,
      OLECHAR FAR* FAR* rgszNames,
      UINT cNames,
      LCID lcid,
      DISPID FAR* rgdispid) PURE;

    STDMETHOD(Invoke)(
      THIS_
      DISPID dispidMember,
      REFIID riid,
      LCID lcid,
      WORD wFlags,
      DISPPARAMS FAR* pdispparams,
      VARIANT FAR* pvarResult,
      EXCEPINFO FAR* pexcepinfo,
      UINT FAR* puArgErr) PURE;

    /* _IMsoDispObj methods */
    STDMETHOD(get_Application)(THIS_ IDispatch * FAR* ppidisp) PURE;
    STDMETHOD(get_Creator)(THIS_ long FAR* plCreator) PURE;
#endif

    /* ShapeRange methods */
    STDMETHOD(get_Parent)(THIS_ IDispatch * FAR* Parent) PURE;
    STDMETHOD(get_Count)(THIS_ int FAR* Count) PURE;
    STDMETHOD(Item)(THIS_ VARIANT Index, Shape FAR* FAR* Item) PURE;
    STDMETHOD(get__NewEnum)(THIS_ IUnknown * FAR* _NewEnum) PURE;
    STDMETHOD(Align)(THIS_ MsoAlignCmd AlignCmd, MsoTriState RelativeTo) PURE;
    STDMETHOD(Apply)(THIS) PURE;
    STDMETHOD(Delete)(THIS) PURE;
    STDMETHOD(Distribute)(THIS_ MsoDistributeCmd DistributeCmd, MsoTriState RelativeTo) PURE;
    STDMETHOD(Duplicate)(THIS_ ShapeRange FAR* FAR* Duplicate) PURE;
    STDMETHOD(Flip)(THIS_ MsoFlipCmd FlipCmd) PURE;
    STDMETHOD(IncrementLeft)(THIS_ float Increment) PURE;
    STDMETHOD(IncrementRotation)(THIS_ float Increment) PURE;
    STDMETHOD(IncrementTop)(THIS_ float Increment) PURE;
    STDMETHOD(Group)(THIS_ Shape FAR* FAR* Group) PURE;
    STDMETHOD(PickUp)(THIS) PURE;
    STDMETHOD(Regroup)(THIS_ Shape FAR* FAR* Regroup) PURE;
    STDMETHOD(RerouteConnections)(THIS) PURE;
    STDMETHOD(ScaleHeight)(THIS_ float Factor, MsoTriState RelativeToOriginalSize, MsoScaleFrom fScale) PURE;
    STDMETHOD(ScaleWidth)(THIS_ float Factor, MsoTriState RelativeToOriginalSize, MsoScaleFrom fScale) PURE;
    STDMETHOD(Select)(THIS_ VARIANT Replace) PURE;
    STDMETHOD(SetShapesDefaultProperties)(THIS) PURE;
    STDMETHOD(Ungroup)(THIS_ ShapeRange FAR* FAR* Ungroup) PURE;
    STDMETHOD(ZOrder)(THIS_ MsoZOrderCmd ZOrderCmd) PURE;
    STDMETHOD(get_Adjustments)(THIS_ Adjustments FAR* FAR* Adjustments) PURE;
    STDMETHOD(get_AutoShapeType)(THIS_ MsoAutoShapeType FAR* AutoShapeType) PURE;
    STDMETHOD(put_AutoShapeType)(THIS_ MsoAutoShapeType AutoShapeType) PURE;
    STDMETHOD(get_BlackWhiteMode)(THIS_ MsoBlackWhiteMode FAR* BlackWhiteMode) PURE;
    STDMETHOD(put_BlackWhiteMode)(THIS_ MsoBlackWhiteMode BlackWhiteMode) PURE;
    STDMETHOD(get_Callout)(THIS_ CalloutFormat FAR* FAR* Callout) PURE;
    STDMETHOD(get_ConnectionSiteCount)(THIS_ int FAR* ConnectionSiteCount) PURE;
    STDMETHOD(get_Connector)(THIS_ MsoTriState FAR* Connector) PURE;
    STDMETHOD(get_ConnectorFormat)(THIS_ ConnectorFormat FAR* FAR* ConnectorFormat) PURE;
    STDMETHOD(get_Fill)(THIS_ FillFormat FAR* FAR* Fill) PURE;
    STDMETHOD(get_GroupItems)(THIS_ GroupShapes FAR* FAR* GroupItems) PURE;
    STDMETHOD(get_Height)(THIS_ float FAR* Height) PURE;
    STDMETHOD(put_Height)(THIS_ float Height) PURE;
    STDMETHOD(get_HorizontalFlip)(THIS_ MsoTriState FAR* HorizontalFlip) PURE;
    STDMETHOD(get_Left)(THIS_ float FAR* Left) PURE;
    STDMETHOD(put_Left)(THIS_ float Left) PURE;
    STDMETHOD(get_Line)(THIS_ LineFormat FAR* FAR* Line) PURE;
    STDMETHOD(get_LockAspectRatio)(THIS_ MsoTriState FAR* LockAspectRatio) PURE;
    STDMETHOD(put_LockAspectRatio)(THIS_ MsoTriState LockAspectRatio) PURE;
    STDMETHOD(get_Name)(THIS_ BSTR FAR* Name) PURE;
    STDMETHOD(put_Name)(THIS_ BSTR Name) PURE;
    STDMETHOD(get_Nodes)(THIS_ ShapeNodes FAR* FAR* Nodes) PURE;
    STDMETHOD(get_Rotation)(THIS_ float FAR* Rotation) PURE;
    STDMETHOD(put_Rotation)(THIS_ float Rotation) PURE;
    STDMETHOD(get_PictureFormat)(THIS_ PictureFormat FAR* FAR* Picture) PURE;
    STDMETHOD(get_Shadow)(THIS_ ShadowFormat FAR* FAR* Shadow) PURE;
    STDMETHOD(get_TextEffect)(THIS_ TextEffectFormat FAR* FAR* TextEffect) PURE;
    STDMETHOD(get_TextFrame)(THIS_ TextFrame FAR* FAR* TextFrame) PURE;
    STDMETHOD(get_ThreeD)(THIS_ ThreeDFormat FAR* FAR* ThreeD) PURE;
    STDMETHOD(get_Top)(THIS_ float FAR* Top) PURE;
    STDMETHOD(put_Top)(THIS_ float Top) PURE;
    STDMETHOD(get_Type)(THIS_ MsoShapeType FAR* Type) PURE;
    STDMETHOD(get_VerticalFlip)(THIS_ MsoTriState FAR* VerticalFlip) PURE;
    STDMETHOD(get_Vertices)(THIS_ VARIANT FAR* Vertices) PURE;
    STDMETHOD(get_Visible)(THIS_ MsoTriState FAR* Visible) PURE;
    STDMETHOD(put_Visible)(THIS_ MsoTriState Visible) PURE;
    STDMETHOD(get_Width)(THIS_ float FAR* Width) PURE;
    STDMETHOD(put_Width)(THIS_ float Width) PURE;
    STDMETHOD(get_ZOrderPosition)(THIS_ int FAR* ZOrderPosition) PURE;
    STDMETHOD(get_Script)(THIS_ Script FAR* FAR* Script) PURE;
    STDMETHOD(get_AlternativeText)(THIS_ BSTR FAR* AlternativeText) PURE;
    STDMETHOD(put_AlternativeText)(THIS_ BSTR AlternativeText) PURE;
    STDMETHOD(get_HasDiagram)(THIS_ MsoTriState FAR* pHasDiagram) PURE;
    STDMETHOD(get_Diagram)(THIS_ IMsoDiagram FAR* FAR* Diagram) PURE;
    STDMETHOD(get_HasDiagramNode)(THIS_ MsoTriState FAR* pHasDiagram) PURE;
    STDMETHOD(get_DiagramNode)(THIS_ DiagramNode FAR* FAR* DiagramNode) PURE;
    STDMETHOD(get_Child)(THIS_ MsoTriState FAR* Child) PURE;
    STDMETHOD(get_ParentGroup)(THIS_ Shape FAR* FAR* Parent) PURE;
    STDMETHOD(get_CanvasItems)(THIS_ CanvasShapes FAR* FAR* CanvasShapes) PURE;
    STDMETHOD(get_Id)(THIS_ int FAR* pid) PURE;
    STDMETHOD(CanvasCropLeft)(THIS_ float Increment) PURE;
    STDMETHOD(CanvasCropTop)(THIS_ float Increment) PURE;
    STDMETHOD(CanvasCropRight)(THIS_ float Increment) PURE;
    STDMETHOD(CanvasCropBottom)(THIS_ float Increment) PURE;
    STDMETHOD(put_RTF)(THIS_ BSTR Text) PURE;
};

DEFINE_GUID(IID_Shapes,0x000C031EL,0x0000,0x0000,0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46);

/* Definition of interface: Shapes */
#undef INTERFACE
#define INTERFACE Shapes

DECLARE_INTERFACE_(Shapes, _IMsoDispObj)
{
BEGIN_INTERFACE
#ifndef NO_BASEINTERFACE_FUNCS

    /* IUnknown methods */
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG, AddRef)(THIS) PURE;
    STDMETHOD_(ULONG, Release)(THIS) PURE;

    /* IDispatch methods */
    STDMETHOD(GetTypeInfoCount)(THIS_ UINT FAR* pctinfo) PURE;

    STDMETHOD(GetTypeInfo)(
      THIS_
      UINT itinfo,
      LCID lcid,
      ITypeInfo FAR* FAR* pptinfo) PURE;

    STDMETHOD(GetIDsOfNames)(
      THIS_
      REFIID riid,
      OLECHAR FAR* FAR* rgszNames,
      UINT cNames,
      LCID lcid,
      DISPID FAR* rgdispid) PURE;

    STDMETHOD(Invoke)(
      THIS_
      DISPID dispidMember,
      REFIID riid,
      LCID lcid,
      WORD wFlags,
      DISPPARAMS FAR* pdispparams,
      VARIANT FAR* pvarResult,
      EXCEPINFO FAR* pexcepinfo,
      UINT FAR* puArgErr) PURE;

    /* _IMsoDispObj methods */
    STDMETHOD(get_Application)(THIS_ IDispatch * FAR* ppidisp) PURE;
    STDMETHOD(get_Creator)(THIS_ long FAR* plCreator) PURE;
#endif

    /* Shapes methods */
    STDMETHOD(get_Parent)(THIS_ IDispatch * FAR* Parent) PURE;
    STDMETHOD(get_Count)(THIS_ int FAR* Count) PURE;
    STDMETHOD(Item)(THIS_ VARIANT Index, Shape FAR* FAR* Item) PURE;
    STDMETHOD(get__NewEnum)(THIS_ IUnknown * FAR* _NewEnum) PURE;
    STDMETHOD(AddCallout)(THIS_ MsoCalloutType Type, float Left, float Top, float Width, float Height, Shape FAR* FAR* Callout) PURE;
    STDMETHOD(AddConnector)(THIS_ MsoConnectorType Type, float BeginX, float BeginY, float EndX, float EndY, Shape FAR* FAR* Connector) PURE;
    STDMETHOD(AddCurve)(THIS_ VARIANT SafeArrayOfPoints, Shape FAR* FAR* Curve) PURE;
    STDMETHOD(AddLabel)(THIS_ MsoTextOrientation Orientation, float Left, float Top, float Width, float Height, Shape FAR* FAR* Label) PURE;
    STDMETHOD(AddLine)(THIS_ float BeginX, float BeginY, float EndX, float EndY, Shape FAR* FAR* Line) PURE;
    STDMETHOD(AddPicture)(THIS_ BSTR FileName, MsoTriState LinkToFile, MsoTriState SaveWithDocument, float Left, float Top, float Width, float Height, Shape FAR* FAR* Picture) PURE;
    STDMETHOD(AddPolyline)(THIS_ VARIANT SafeArrayOfPoints, Shape FAR* FAR* Polyline) PURE;
    STDMETHOD(AddShape)(THIS_ MsoAutoShapeType Type, float Left, float Top, float Width, float Height, Shape FAR* FAR* Shape) PURE;
    STDMETHOD(AddTextEffect)(THIS_ MsoPresetTextEffect PresetTextEffect, BSTR Text, BSTR FontName, float FontSize, MsoTriState FontBold, MsoTriState FontItalic, float Left, float Top, Shape FAR* FAR* TextEffect) PURE;
    STDMETHOD(AddTextbox)(THIS_ MsoTextOrientation Orientation, float Left, float Top, float Width, float Height, Shape FAR* FAR* Textbox) PURE;
    STDMETHOD(BuildFreeform)(THIS_ MsoEditingType EditingType, float X1, float Y1, FreeformBuilder FAR* FAR* FreeformBuilder) PURE;
    STDMETHOD(Range)(THIS_ VARIANT Index, ShapeRange FAR* FAR* Range) PURE;
    STDMETHOD(SelectAll)(THIS) PURE;
    STDMETHOD(get_Background)(THIS_ Shape FAR* FAR* Background) PURE;
    STDMETHOD(get_Default)(THIS_ Shape FAR* FAR* Default) PURE;
    STDMETHOD(AddDiagram)(THIS_ enum tagMsoDiagramType Type, float Left, float Top, float Width, float Height, Shape FAR* FAR* Diagram) PURE;
    STDMETHOD(AddCanvas)(THIS_ float Left, float Top, float Width, float Height, Shape FAR* FAR* Shape) PURE;
};

DEFINE_GUID(IID_TextEffectFormat,0x000C031FL,0x0000,0x0000,0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46);

/* Definition of interface: TextEffectFormat */
#undef INTERFACE
#define INTERFACE TextEffectFormat

DECLARE_INTERFACE_(TextEffectFormat, _IMsoDispObj)
{
BEGIN_INTERFACE
#ifndef NO_BASEINTERFACE_FUNCS

    /* IUnknown methods */
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG, AddRef)(THIS) PURE;
    STDMETHOD_(ULONG, Release)(THIS) PURE;

    /* IDispatch methods */
    STDMETHOD(GetTypeInfoCount)(THIS_ UINT FAR* pctinfo) PURE;

    STDMETHOD(GetTypeInfo)(
      THIS_
      UINT itinfo,
      LCID lcid,
      ITypeInfo FAR* FAR* pptinfo) PURE;

    STDMETHOD(GetIDsOfNames)(
      THIS_
      REFIID riid,
      OLECHAR FAR* FAR* rgszNames,
      UINT cNames,
      LCID lcid,
      DISPID FAR* rgdispid) PURE;

    STDMETHOD(Invoke)(
      THIS_
      DISPID dispidMember,
      REFIID riid,
      LCID lcid,
      WORD wFlags,
      DISPPARAMS FAR* pdispparams,
      VARIANT FAR* pvarResult,
      EXCEPINFO FAR* pexcepinfo,
      UINT FAR* puArgErr) PURE;

    /* _IMsoDispObj methods */
    STDMETHOD(get_Application)(THIS_ IDispatch * FAR* ppidisp) PURE;
    STDMETHOD(get_Creator)(THIS_ long FAR* plCreator) PURE;
#endif

    /* TextEffectFormat methods */
    STDMETHOD(get_Parent)(THIS_ IDispatch * FAR* Parent) PURE;
    STDMETHOD(ToggleVerticalText)(THIS) PURE;
    STDMETHOD(get_Alignment)(THIS_ MsoTextEffectAlignment FAR* Alignment) PURE;
    STDMETHOD(put_Alignment)(THIS_ MsoTextEffectAlignment Alignment) PURE;
    STDMETHOD(get_FontBold)(THIS_ MsoTriState FAR* FontBold) PURE;
    STDMETHOD(put_FontBold)(THIS_ MsoTriState FontBold) PURE;
    STDMETHOD(get_FontItalic)(THIS_ MsoTriState FAR* FontItalic) PURE;
    STDMETHOD(put_FontItalic)(THIS_ MsoTriState FontItalic) PURE;
    STDMETHOD(get_FontName)(THIS_ BSTR FAR* FontName) PURE;
    STDMETHOD(put_FontName)(THIS_ BSTR FontName) PURE;
    STDMETHOD(get_FontSize)(THIS_ float FAR* FontSize) PURE;
    STDMETHOD(put_FontSize)(THIS_ float FontSize) PURE;
    STDMETHOD(get_KernedPairs)(THIS_ MsoTriState FAR* KernedPairs) PURE;
    STDMETHOD(put_KernedPairs)(THIS_ MsoTriState KernedPairs) PURE;
    STDMETHOD(get_NormalizedHeight)(THIS_ MsoTriState FAR* NormalizedHeight) PURE;
    STDMETHOD(put_NormalizedHeight)(THIS_ MsoTriState NormalizedHeight) PURE;
    STDMETHOD(get_PresetShape)(THIS_ MsoPresetTextEffectShape FAR* PresetShape) PURE;
    STDMETHOD(put_PresetShape)(THIS_ MsoPresetTextEffectShape PresetShape) PURE;
    STDMETHOD(get_PresetTextEffect)(THIS_ MsoPresetTextEffect FAR* Preset) PURE;
    STDMETHOD(put_PresetTextEffect)(THIS_ MsoPresetTextEffect Preset) PURE;
    STDMETHOD(get_RotatedChars)(THIS_ MsoTriState FAR* RotatedChars) PURE;
    STDMETHOD(put_RotatedChars)(THIS_ MsoTriState RotatedChars) PURE;
    STDMETHOD(get_Text)(THIS_ BSTR FAR* Text) PURE;
    STDMETHOD(put_Text)(THIS_ BSTR Text) PURE;
    STDMETHOD(get_Tracking)(THIS_ float FAR* Tracking) PURE;
    STDMETHOD(put_Tracking)(THIS_ float Tracking) PURE;
};

DEFINE_GUID(IID_TextFrame,0x000C0320L,0x0000,0x0000,0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46);

/* Definition of interface: TextFrame */
#undef INTERFACE
#define INTERFACE TextFrame

DECLARE_INTERFACE_(TextFrame, _IMsoDispObj)
{
BEGIN_INTERFACE
#ifndef NO_BASEINTERFACE_FUNCS

    /* IUnknown methods */
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG, AddRef)(THIS) PURE;
    STDMETHOD_(ULONG, Release)(THIS) PURE;

    /* IDispatch methods */
    STDMETHOD(GetTypeInfoCount)(THIS_ UINT FAR* pctinfo) PURE;

    STDMETHOD(GetTypeInfo)(
      THIS_
      UINT itinfo,
      LCID lcid,
      ITypeInfo FAR* FAR* pptinfo) PURE;

    STDMETHOD(GetIDsOfNames)(
      THIS_
      REFIID riid,
      OLECHAR FAR* FAR* rgszNames,
      UINT cNames,
      LCID lcid,
      DISPID FAR* rgdispid) PURE;

    STDMETHOD(Invoke)(
      THIS_
      DISPID dispidMember,
      REFIID riid,
      LCID lcid,
      WORD wFlags,
      DISPPARAMS FAR* pdispparams,
      VARIANT FAR* pvarResult,
      EXCEPINFO FAR* pexcepinfo,
      UINT FAR* puArgErr) PURE;

    /* _IMsoDispObj methods */
    STDMETHOD(get_Application)(THIS_ IDispatch * FAR* ppidisp) PURE;
    STDMETHOD(get_Creator)(THIS_ long FAR* plCreator) PURE;
#endif

    /* TextFrame methods */
    STDMETHOD(get_Parent)(THIS_ IDispatch * FAR* Parent) PURE;
    STDMETHOD(get_MarginBottom)(THIS_ float FAR* MarginBottom) PURE;
    STDMETHOD(put_MarginBottom)(THIS_ float MarginBottom) PURE;
    STDMETHOD(get_MarginLeft)(THIS_ float FAR* MarginLeft) PURE;
    STDMETHOD(put_MarginLeft)(THIS_ float MarginLeft) PURE;
    STDMETHOD(get_MarginRight)(THIS_ float FAR* MarginRight) PURE;
    STDMETHOD(put_MarginRight)(THIS_ float MarginRight) PURE;
    STDMETHOD(get_MarginTop)(THIS_ float FAR* MarginTop) PURE;
    STDMETHOD(put_MarginTop)(THIS_ float MarginTop) PURE;
    STDMETHOD(get_Orientation)(THIS_ MsoTextOrientation FAR* Orientation) PURE;
    STDMETHOD(put_Orientation)(THIS_ MsoTextOrientation Orientation) PURE;
};

DEFINE_GUID(IID_ThreeDFormat,0x000C0321L,0x0000,0x0000,0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46);

/* Definition of interface: ThreeDFormat */
#undef INTERFACE
#define INTERFACE ThreeDFormat

DECLARE_INTERFACE_(ThreeDFormat, _IMsoDispObj)
{
BEGIN_INTERFACE
#ifndef NO_BASEINTERFACE_FUNCS

    /* IUnknown methods */
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG, AddRef)(THIS) PURE;
    STDMETHOD_(ULONG, Release)(THIS) PURE;

    /* IDispatch methods */
    STDMETHOD(GetTypeInfoCount)(THIS_ UINT FAR* pctinfo) PURE;

    STDMETHOD(GetTypeInfo)(
      THIS_
      UINT itinfo,
      LCID lcid,
      ITypeInfo FAR* FAR* pptinfo) PURE;

    STDMETHOD(GetIDsOfNames)(
      THIS_
      REFIID riid,
      OLECHAR FAR* FAR* rgszNames,
      UINT cNames,
      LCID lcid,
      DISPID FAR* rgdispid) PURE;

    STDMETHOD(Invoke)(
      THIS_
      DISPID dispidMember,
      REFIID riid,
      LCID lcid,
      WORD wFlags,
      DISPPARAMS FAR* pdispparams,
      VARIANT FAR* pvarResult,
      EXCEPINFO FAR* pexcepinfo,
      UINT FAR* puArgErr) PURE;

    /* _IMsoDispObj methods */
    STDMETHOD(get_Application)(THIS_ IDispatch * FAR* ppidisp) PURE;
    STDMETHOD(get_Creator)(THIS_ long FAR* plCreator) PURE;
#endif

    /* ThreeDFormat methods */
    STDMETHOD(get_Parent)(THIS_ IDispatch * FAR* Parent) PURE;
    STDMETHOD(IncrementRotationX)(THIS_ float Increment) PURE;
    STDMETHOD(IncrementRotationY)(THIS_ float Increment) PURE;
    STDMETHOD(ResetRotation)(THIS) PURE;
    STDMETHOD(SetThreeDFormat)(THIS_ MsoPresetThreeDFormat PresetThreeDFormat) PURE;
    STDMETHOD(SetExtrusionDirection)(THIS_ MsoPresetExtrusionDirection PresetExtrusionDirection) PURE;
    STDMETHOD(get_Depth)(THIS_ float FAR* Depth) PURE;
    STDMETHOD(put_Depth)(THIS_ float Depth) PURE;
    STDMETHOD(get_ExtrusionColor)(THIS_ ColorFormat FAR* FAR* ExtrusionColor) PURE;
    STDMETHOD(get_ExtrusionColorType)(THIS_ MsoExtrusionColorType FAR* ExtrusionColorType) PURE;
    STDMETHOD(put_ExtrusionColorType)(THIS_ MsoExtrusionColorType ExtrusionColorType) PURE;
    STDMETHOD(get_Perspective)(THIS_ MsoTriState FAR* Perspective) PURE;
    STDMETHOD(put_Perspective)(THIS_ MsoTriState Perspective) PURE;
    STDMETHOD(get_PresetExtrusionDirection)(THIS_ MsoPresetExtrusionDirection FAR* PresetExtrusionDirection) PURE;
    STDMETHOD(get_PresetLightingDirection)(THIS_ MsoPresetLightingDirection FAR* PresetLightingDirection) PURE;
    STDMETHOD(put_PresetLightingDirection)(THIS_ MsoPresetLightingDirection PresetLightingDirection) PURE;
    STDMETHOD(get_PresetLightingSoftness)(THIS_ MsoPresetLightingSoftness FAR* PresetLightingSoftness) PURE;
    STDMETHOD(put_PresetLightingSoftness)(THIS_ MsoPresetLightingSoftness PresetLightingSoftness) PURE;
    STDMETHOD(get_PresetMaterial)(THIS_ MsoPresetMaterial FAR* PresetMaterial) PURE;
    STDMETHOD(put_PresetMaterial)(THIS_ MsoPresetMaterial PresetMaterial) PURE;
    STDMETHOD(get_PresetThreeDFormat)(THIS_ MsoPresetThreeDFormat FAR* PresetThreeDFormat) PURE;
    STDMETHOD(get_RotationX)(THIS_ float FAR* RotationX) PURE;
    STDMETHOD(put_RotationX)(THIS_ float RotationX) PURE;
    STDMETHOD(get_RotationY)(THIS_ float FAR* RotationY) PURE;
    STDMETHOD(put_RotationY)(THIS_ float RotationY) PURE;
    STDMETHOD(get_Visible)(THIS_ MsoTriState FAR* Visible) PURE;
    STDMETHOD(put_Visible)(THIS_ MsoTriState Visible) PURE;
};

DEFINE_GUID(IID_IMsoDispCagNotifySink,0x000C0359L,0x0000,0x0000,0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46);

/* Definition of interface: IMsoDispCagNotifySink */
#undef INTERFACE
#define INTERFACE IMsoDispCagNotifySink

DECLARE_INTERFACE_(IMsoDispCagNotifySink, IDispatch)
{
BEGIN_INTERFACE
#ifndef NO_BASEINTERFACE_FUNCS

    /* IUnknown methods */
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG, AddRef)(THIS) PURE;
    STDMETHOD_(ULONG, Release)(THIS) PURE;

    /* IDispatch methods */
    STDMETHOD(GetTypeInfoCount)(THIS_ UINT FAR* pctinfo) PURE;

    STDMETHOD(GetTypeInfo)(
      THIS_
      UINT itinfo,
      LCID lcid,
      ITypeInfo FAR* FAR* pptinfo) PURE;

    STDMETHOD(GetIDsOfNames)(
      THIS_
      REFIID riid,
      OLECHAR FAR* FAR* rgszNames,
      UINT cNames,
      LCID lcid,
      DISPID FAR* rgdispid) PURE;

    STDMETHOD(Invoke)(
      THIS_
      DISPID dispidMember,
      REFIID riid,
      LCID lcid,
      WORD wFlags,
      DISPPARAMS FAR* pdispparams,
      VARIANT FAR* pvarResult,
      EXCEPINFO FAR* pexcepinfo,
      UINT FAR* puArgErr) PURE;
#endif

    /* IMsoDispCagNotifySink methods */
    STDMETHOD(InsertClip)(THIS_ IUnknown * pClipMoniker, IUnknown * pItemMoniker) PURE;
    STDMETHOD(WindowIsClosing)(THIS) PURE;
};

DEFINE_GUID(IID_Balloon,0x000C0324L,0x0000,0x0000,0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46);

/* Definition of interface: Balloon */
#undef INTERFACE
#define INTERFACE Balloon

DECLARE_INTERFACE_(Balloon, _IMsoDispObj)
{
BEGIN_INTERFACE
#ifndef NO_BASEINTERFACE_FUNCS

    /* IUnknown methods */
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG, AddRef)(THIS) PURE;
    STDMETHOD_(ULONG, Release)(THIS) PURE;

    /* IDispatch methods */
    STDMETHOD(GetTypeInfoCount)(THIS_ UINT FAR* pctinfo) PURE;

    STDMETHOD(GetTypeInfo)(
      THIS_
      UINT itinfo,
      LCID lcid,
      ITypeInfo FAR* FAR* pptinfo) PURE;

    STDMETHOD(GetIDsOfNames)(
      THIS_
      REFIID riid,
      OLECHAR FAR* FAR* rgszNames,
      UINT cNames,
      LCID lcid,
      DISPID FAR* rgdispid) PURE;

    STDMETHOD(Invoke)(
      THIS_
      DISPID dispidMember,
      REFIID riid,
      LCID lcid,
      WORD wFlags,
      DISPPARAMS FAR* pdispparams,
      VARIANT FAR* pvarResult,
      EXCEPINFO FAR* pexcepinfo,
      UINT FAR* puArgErr) PURE;

    /* _IMsoDispObj methods */
    STDMETHOD(get_Application)(THIS_ IDispatch * FAR* ppidisp) PURE;
    STDMETHOD(get_Creator)(THIS_ long FAR* plCreator) PURE;
#endif

    /* Balloon methods */
    STDMETHOD(get_Parent)(THIS_ IDispatch * FAR* ppidisp) PURE;
    STDMETHOD(get_Checkboxes)(THIS_ IDispatch * FAR* ppidisp) PURE;
    STDMETHOD(get_Labels)(THIS_ IDispatch * FAR* ppidisp) PURE;
    STDMETHOD(put_BalloonType)(THIS_ MsoBalloonType bty) PURE;
    STDMETHOD(get_BalloonType)(THIS_ MsoBalloonType FAR* pbty) PURE;
    STDMETHOD(put_Icon)(THIS_ MsoIconType icn) PURE;
    STDMETHOD(get_Icon)(THIS_ MsoIconType FAR* picn) PURE;
    STDMETHOD(put_Heading)(THIS_ BSTR bstr) PURE;
    STDMETHOD(get_Heading)(THIS_ BSTR FAR* pbstr) PURE;
    STDMETHOD(put_Text)(THIS_ BSTR bstr) PURE;
    STDMETHOD(get_Text)(THIS_ BSTR FAR* pbstr) PURE;
    STDMETHOD(put_Mode)(THIS_ MsoModeType md) PURE;
    STDMETHOD(get_Mode)(THIS_ MsoModeType FAR* pmd) PURE;
    STDMETHOD(put_Animation)(THIS_ MsoAnimationType fca) PURE;
    STDMETHOD(get_Animation)(THIS_ MsoAnimationType FAR* pfca) PURE;
    STDMETHOD(put_Button)(THIS_ MsoButtonSetType sbs) PURE;
    STDMETHOD(get_Button)(THIS_ MsoButtonSetType FAR* psbs) PURE;
    STDMETHOD(put_Callback)(THIS_ BSTR bstr) PURE;
    STDMETHOD(get_Callback)(THIS_ BSTR FAR* pbstr) PURE;
    STDMETHOD(put_Private)(THIS_ long lPrivate) PURE;
    STDMETHOD(get_Private)(THIS_ long FAR* plPrivate) PURE;
    STDMETHOD(SetAvoidRectangle)(THIS_ int Left, int Top, int Right, int Bottom) PURE;
    STDMETHOD(get_Name)(THIS_ BSTR FAR* pbstrName) PURE;
    STDMETHOD(Show)(THIS_ MsoBalloonButtonType FAR* pibtn) PURE;
    STDMETHOD(Close)(THIS) PURE;
};

DEFINE_GUID(IID_BalloonCheckboxes,0x000C0326L,0x0000,0x0000,0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46);

/* Definition of interface: BalloonCheckboxes */
#undef INTERFACE
#define INTERFACE BalloonCheckboxes

DECLARE_INTERFACE_(BalloonCheckboxes, _IMsoDispObj)
{
BEGIN_INTERFACE
#ifndef NO_BASEINTERFACE_FUNCS

    /* IUnknown methods */
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG, AddRef)(THIS) PURE;
    STDMETHOD_(ULONG, Release)(THIS) PURE;

    /* IDispatch methods */
    STDMETHOD(GetTypeInfoCount)(THIS_ UINT FAR* pctinfo) PURE;

    STDMETHOD(GetTypeInfo)(
      THIS_
      UINT itinfo,
      LCID lcid,
      ITypeInfo FAR* FAR* pptinfo) PURE;

    STDMETHOD(GetIDsOfNames)(
      THIS_
      REFIID riid,
      OLECHAR FAR* FAR* rgszNames,
      UINT cNames,
      LCID lcid,
      DISPID FAR* rgdispid) PURE;

    STDMETHOD(Invoke)(
      THIS_
      DISPID dispidMember,
      REFIID riid,
      LCID lcid,
      WORD wFlags,
      DISPPARAMS FAR* pdispparams,
      VARIANT FAR* pvarResult,
      EXCEPINFO FAR* pexcepinfo,
      UINT FAR* puArgErr) PURE;

    /* _IMsoDispObj methods */
    STDMETHOD(get_Application)(THIS_ IDispatch * FAR* ppidisp) PURE;
    STDMETHOD(get_Creator)(THIS_ long FAR* plCreator) PURE;
#endif

    /* BalloonCheckboxes methods */
    STDMETHOD(get_Name)(THIS_ BSTR FAR* pbstrName) PURE;
    STDMETHOD(get_Parent)(THIS_ IDispatch * FAR* ppidisp) PURE;
    STDMETHOD(get_Item)(THIS_ int Index, IDispatch * FAR* ppidisp) PURE;
    STDMETHOD(get_Count)(THIS_ int FAR* pccbx) PURE;
    STDMETHOD(put_Count)(THIS_ int ccbx) PURE;
    STDMETHOD(get__NewEnum)(THIS_ IUnknown * FAR* ppienum) PURE;
};

DEFINE_GUID(IID_BalloonCheckbox,0x000C0328L,0x0000,0x0000,0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46);

/* Definition of interface: BalloonCheckbox */
#undef INTERFACE
#define INTERFACE BalloonCheckbox

DECLARE_INTERFACE_(BalloonCheckbox, _IMsoDispObj)
{
BEGIN_INTERFACE
#ifndef NO_BASEINTERFACE_FUNCS

    /* IUnknown methods */
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG, AddRef)(THIS) PURE;
    STDMETHOD_(ULONG, Release)(THIS) PURE;

    /* IDispatch methods */
    STDMETHOD(GetTypeInfoCount)(THIS_ UINT FAR* pctinfo) PURE;

    STDMETHOD(GetTypeInfo)(
      THIS_
      UINT itinfo,
      LCID lcid,
      ITypeInfo FAR* FAR* pptinfo) PURE;

    STDMETHOD(GetIDsOfNames)(
      THIS_
      REFIID riid,
      OLECHAR FAR* FAR* rgszNames,
      UINT cNames,
      LCID lcid,
      DISPID FAR* rgdispid) PURE;

    STDMETHOD(Invoke)(
      THIS_
      DISPID dispidMember,
      REFIID riid,
      LCID lcid,
      WORD wFlags,
      DISPPARAMS FAR* pdispparams,
      VARIANT FAR* pvarResult,
      EXCEPINFO FAR* pexcepinfo,
      UINT FAR* puArgErr) PURE;

    /* _IMsoDispObj methods */
    STDMETHOD(get_Application)(THIS_ IDispatch * FAR* ppidisp) PURE;
    STDMETHOD(get_Creator)(THIS_ long FAR* plCreator) PURE;
#endif

    /* BalloonCheckbox methods */
    STDMETHOD(get_Item)(THIS_ BSTR FAR* pbstrName) PURE;
    STDMETHOD(get_Name)(THIS_ BSTR FAR* pbstrName) PURE;
    STDMETHOD(get_Parent)(THIS_ IDispatch * FAR* ppidisp) PURE;
    STDMETHOD(put_Checked)(THIS_ VARIANT_BOOL varfChecked) PURE;
    STDMETHOD(get_Checked)(THIS_ VARIANT_BOOL FAR* pvarfChecked) PURE;
    STDMETHOD(put_Text)(THIS_ BSTR bstr) PURE;
    STDMETHOD(get_Text)(THIS_ BSTR FAR* pbstr) PURE;
};

DEFINE_GUID(IID_BalloonLabels,0x000C032EL,0x0000,0x0000,0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46);

/* Definition of interface: BalloonLabels */
#undef INTERFACE
#define INTERFACE BalloonLabels

DECLARE_INTERFACE_(BalloonLabels, _IMsoDispObj)
{
BEGIN_INTERFACE
#ifndef NO_BASEINTERFACE_FUNCS

    /* IUnknown methods */
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG, AddRef)(THIS) PURE;
    STDMETHOD_(ULONG, Release)(THIS) PURE;

    /* IDispatch methods */
    STDMETHOD(GetTypeInfoCount)(THIS_ UINT FAR* pctinfo) PURE;

    STDMETHOD(GetTypeInfo)(
      THIS_
      UINT itinfo,
      LCID lcid,
      ITypeInfo FAR* FAR* pptinfo) PURE;

    STDMETHOD(GetIDsOfNames)(
      THIS_
      REFIID riid,
      OLECHAR FAR* FAR* rgszNames,
      UINT cNames,
      LCID lcid,
      DISPID FAR* rgdispid) PURE;

    STDMETHOD(Invoke)(
      THIS_
      DISPID dispidMember,
      REFIID riid,
      LCID lcid,
      WORD wFlags,
      DISPPARAMS FAR* pdispparams,
      VARIANT FAR* pvarResult,
      EXCEPINFO FAR* pexcepinfo,
      UINT FAR* puArgErr) PURE;

    /* _IMsoDispObj methods */
    STDMETHOD(get_Application)(THIS_ IDispatch * FAR* ppidisp) PURE;
    STDMETHOD(get_Creator)(THIS_ long FAR* plCreator) PURE;
#endif

    /* BalloonLabels methods */
    STDMETHOD(get_Name)(THIS_ BSTR FAR* pbstrName) PURE;
    STDMETHOD(get_Parent)(THIS_ IDispatch * FAR* ppidisp) PURE;
    STDMETHOD(get_Item)(THIS_ int Index, IDispatch * FAR* ppidisp) PURE;
    STDMETHOD(get_Count)(THIS_ int FAR* pcwz) PURE;
    STDMETHOD(put_Count)(THIS_ int cwz) PURE;
    STDMETHOD(get__NewEnum)(THIS_ IUnknown * FAR* ppienum) PURE;
};

DEFINE_GUID(IID_BalloonLabel,0x000C0330L,0x0000,0x0000,0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46);

/* Definition of interface: BalloonLabel */
#undef INTERFACE
#define INTERFACE BalloonLabel

DECLARE_INTERFACE_(BalloonLabel, _IMsoDispObj)
{
BEGIN_INTERFACE
#ifndef NO_BASEINTERFACE_FUNCS

    /* IUnknown methods */
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG, AddRef)(THIS) PURE;
    STDMETHOD_(ULONG, Release)(THIS) PURE;

    /* IDispatch methods */
    STDMETHOD(GetTypeInfoCount)(THIS_ UINT FAR* pctinfo) PURE;

    STDMETHOD(GetTypeInfo)(
      THIS_
      UINT itinfo,
      LCID lcid,
      ITypeInfo FAR* FAR* pptinfo) PURE;

    STDMETHOD(GetIDsOfNames)(
      THIS_
      REFIID riid,
      OLECHAR FAR* FAR* rgszNames,
      UINT cNames,
      LCID lcid,
      DISPID FAR* rgdispid) PURE;

    STDMETHOD(Invoke)(
      THIS_
      DISPID dispidMember,
      REFIID riid,
      LCID lcid,
      WORD wFlags,
      DISPPARAMS FAR* pdispparams,
      VARIANT FAR* pvarResult,
      EXCEPINFO FAR* pexcepinfo,
      UINT FAR* puArgErr) PURE;

    /* _IMsoDispObj methods */
    STDMETHOD(get_Application)(THIS_ IDispatch * FAR* ppidisp) PURE;
    STDMETHOD(get_Creator)(THIS_ long FAR* plCreator) PURE;
#endif

    /* BalloonLabel methods */
    STDMETHOD(get_Item)(THIS_ BSTR FAR* pbstrName) PURE;
    STDMETHOD(get_Name)(THIS_ BSTR FAR* pbstrName) PURE;
    STDMETHOD(get_Parent)(THIS_ IDispatch * FAR* ppidisp) PURE;
    STDMETHOD(put_Text)(THIS_ BSTR bstr) PURE;
    STDMETHOD(get_Text)(THIS_ BSTR FAR* pbstr) PURE;
};

DEFINE_GUID(IID_AnswerWizardFiles,0x000C0361L,0x0000,0x0000,0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46);

/* Definition of interface: AnswerWizardFiles */
#undef INTERFACE
#define INTERFACE AnswerWizardFiles

DECLARE_INTERFACE_(AnswerWizardFiles, _IMsoDispObj)
{
BEGIN_INTERFACE
#ifndef NO_BASEINTERFACE_FUNCS

    /* IUnknown methods */
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG, AddRef)(THIS) PURE;
    STDMETHOD_(ULONG, Release)(THIS) PURE;

    /* IDispatch methods */
    STDMETHOD(GetTypeInfoCount)(THIS_ UINT FAR* pctinfo) PURE;

    STDMETHOD(GetTypeInfo)(
      THIS_
      UINT itinfo,
      LCID lcid,
      ITypeInfo FAR* FAR* pptinfo) PURE;

    STDMETHOD(GetIDsOfNames)(
      THIS_
      REFIID riid,
      OLECHAR FAR* FAR* rgszNames,
      UINT cNames,
      LCID lcid,
      DISPID FAR* rgdispid) PURE;

    STDMETHOD(Invoke)(
      THIS_
      DISPID dispidMember,
      REFIID riid,
      LCID lcid,
      WORD wFlags,
      DISPPARAMS FAR* pdispparams,
      VARIANT FAR* pvarResult,
      EXCEPINFO FAR* pexcepinfo,
      UINT FAR* puArgErr) PURE;

    /* _IMsoDispObj methods */
    STDMETHOD(get_Application)(THIS_ IDispatch * FAR* ppidisp) PURE;
    STDMETHOD(get_Creator)(THIS_ long FAR* plCreator) PURE;
#endif

    /* AnswerWizardFiles methods */
    STDMETHOD(get_Parent)(THIS_ IDispatch * FAR* ppidisp) PURE;
    STDMETHOD(get_Item)(THIS_ int Index, BSTR FAR* pbstr) PURE;
    STDMETHOD(get_Count)(THIS_ int FAR* pCount) PURE;
    STDMETHOD(Add)(THIS_ BSTR FileName) PURE;
    STDMETHOD(Delete)(THIS_ BSTR FileName) PURE;
};

DEFINE_GUID(IID_AnswerWizard,0x000C0360L,0x0000,0x0000,0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46);

/* Definition of interface: AnswerWizard */
#undef INTERFACE
#define INTERFACE AnswerWizard

DECLARE_INTERFACE_(AnswerWizard, _IMsoDispObj)
{
BEGIN_INTERFACE
#ifndef NO_BASEINTERFACE_FUNCS

    /* IUnknown methods */
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG, AddRef)(THIS) PURE;
    STDMETHOD_(ULONG, Release)(THIS) PURE;

    /* IDispatch methods */
    STDMETHOD(GetTypeInfoCount)(THIS_ UINT FAR* pctinfo) PURE;

    STDMETHOD(GetTypeInfo)(
      THIS_
      UINT itinfo,
      LCID lcid,
      ITypeInfo FAR* FAR* pptinfo) PURE;

    STDMETHOD(GetIDsOfNames)(
      THIS_
      REFIID riid,
      OLECHAR FAR* FAR* rgszNames,
      UINT cNames,
      LCID lcid,
      DISPID FAR* rgdispid) PURE;

    STDMETHOD(Invoke)(
      THIS_
      DISPID dispidMember,
      REFIID riid,
      LCID lcid,
      WORD wFlags,
      DISPPARAMS FAR* pdispparams,
      VARIANT FAR* pvarResult,
      EXCEPINFO FAR* pexcepinfo,
      UINT FAR* puArgErr) PURE;

    /* _IMsoDispObj methods */
    STDMETHOD(get_Application)(THIS_ IDispatch * FAR* ppidisp) PURE;
    STDMETHOD(get_Creator)(THIS_ long FAR* plCreator) PURE;
#endif

    /* AnswerWizard methods */
    STDMETHOD(get_Parent)(THIS_ IDispatch * FAR* ppidisp) PURE;
    STDMETHOD(get_Files)(THIS_ AnswerWizardFiles FAR* FAR* Files) PURE;
    STDMETHOD(ClearFileList)(THIS) PURE;
    STDMETHOD(ResetFileList)(THIS) PURE;
};

typedef enum tagMsoAlertButtonType MsoAlertButtonType;

typedef enum tagMsoAlertIconType MsoAlertIconType;

typedef enum tagMsoAlertDefaultType MsoAlertDefaultType;

typedef enum tagMsoAlertCancelType MsoAlertCancelType;

DEFINE_GUID(IID_Assistant,0x000C0322L,0x0000,0x0000,0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46);

/* Definition of interface: Assistant */
#undef INTERFACE
#define INTERFACE Assistant

DECLARE_INTERFACE_(Assistant, _IMsoDispObj)
{
BEGIN_INTERFACE
#ifndef NO_BASEINTERFACE_FUNCS

    /* IUnknown methods */
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG, AddRef)(THIS) PURE;
    STDMETHOD_(ULONG, Release)(THIS) PURE;

    /* IDispatch methods */
    STDMETHOD(GetTypeInfoCount)(THIS_ UINT FAR* pctinfo) PURE;

    STDMETHOD(GetTypeInfo)(
      THIS_
      UINT itinfo,
      LCID lcid,
      ITypeInfo FAR* FAR* pptinfo) PURE;

    STDMETHOD(GetIDsOfNames)(
      THIS_
      REFIID riid,
      OLECHAR FAR* FAR* rgszNames,
      UINT cNames,
      LCID lcid,
      DISPID FAR* rgdispid) PURE;

    STDMETHOD(Invoke)(
      THIS_
      DISPID dispidMember,
      REFIID riid,
      LCID lcid,
      WORD wFlags,
      DISPPARAMS FAR* pdispparams,
      VARIANT FAR* pvarResult,
      EXCEPINFO FAR* pexcepinfo,
      UINT FAR* puArgErr) PURE;

    /* _IMsoDispObj methods */
    STDMETHOD(get_Application)(THIS_ IDispatch * FAR* ppidisp) PURE;
    STDMETHOD(get_Creator)(THIS_ long FAR* plCreator) PURE;
#endif

    /* Assistant methods */
    STDMETHOD(get_Parent)(THIS_ IDispatch * FAR* ppidisp) PURE;
    STDMETHOD(Move)(THIS_ int xLeft, int yTop) PURE;
    STDMETHOD(put_Top)(THIS_ int yTop) PURE;
    STDMETHOD(get_Top)(THIS_ int FAR* pyTop) PURE;
    STDMETHOD(put_Left)(THIS_ int xLeft) PURE;
    STDMETHOD(get_Left)(THIS_ int FAR* pxLeft) PURE;
    STDMETHOD(Help)(THIS) PURE;
    STDMETHOD(StartWizard)(THIS_ VARIANT_BOOL On, BSTR Callback, long PrivateX, VARIANT Animation, VARIANT CustomTeaser, VARIANT Top, VARIANT Left, VARIANT Bottom, VARIANT Right, long FAR* plWizID) PURE;
    STDMETHOD(EndWizard)(THIS_ long WizardID, VARIANT_BOOL varfSuccess, VARIANT Animation) PURE;
    STDMETHOD(ActivateWizard)(THIS_ long WizardID, MsoWizardActType act, VARIANT Animation) PURE;
    STDMETHOD(ResetTips)(THIS) PURE;
    STDMETHOD(get_NewBalloon)(THIS_ Balloon FAR* FAR* ppibal) PURE;
    STDMETHOD(get_BalloonError)(THIS_ MsoBalloonErrorType FAR* pbne) PURE;
    STDMETHOD(get_Visible)(THIS_ VARIANT_BOOL FAR* pvarfVisible) PURE;
    STDMETHOD(put_Visible)(THIS_ VARIANT_BOOL varfVisible) PURE;
    STDMETHOD(get_Animation)(THIS_ MsoAnimationType FAR* pfca) PURE;
    STDMETHOD(put_Animation)(THIS_ MsoAnimationType fca) PURE;
    STDMETHOD(get_Reduced)(THIS_ VARIANT_BOOL FAR* pvarfReduced) PURE;
    STDMETHOD(put_Reduced)(THIS_ VARIANT_BOOL varfReduced) PURE;
    STDMETHOD(put_AssistWithHelp)(THIS_ VARIANT_BOOL varfAssistWithHelp) PURE;
    STDMETHOD(get_AssistWithHelp)(THIS_ VARIANT_BOOL FAR* pvarfAssistWithHelp) PURE;
    STDMETHOD(put_AssistWithWizards)(THIS_ VARIANT_BOOL varfAssistWithWizards) PURE;
    STDMETHOD(get_AssistWithWizards)(THIS_ VARIANT_BOOL FAR* pvarfAssistWithWizards) PURE;
    STDMETHOD(put_AssistWithAlerts)(THIS_ VARIANT_BOOL varfAssistWithAlerts) PURE;
    STDMETHOD(get_AssistWithAlerts)(THIS_ VARIANT_BOOL FAR* pvarfAssistWithAlerts) PURE;
    STDMETHOD(put_MoveWhenInTheWay)(THIS_ VARIANT_BOOL varfMove) PURE;
    STDMETHOD(get_MoveWhenInTheWay)(THIS_ VARIANT_BOOL FAR* pvarfMove) PURE;
    STDMETHOD(put_Sounds)(THIS_ VARIANT_BOOL varfSounds) PURE;
    STDMETHOD(get_Sounds)(THIS_ VARIANT_BOOL FAR* pvarfSounds) PURE;
    STDMETHOD(put_FeatureTips)(THIS_ VARIANT_BOOL varfFeatures) PURE;
    STDMETHOD(get_FeatureTips)(THIS_ VARIANT_BOOL FAR* pvarfFeatures) PURE;
    STDMETHOD(put_MouseTips)(THIS_ VARIANT_BOOL varfMouse) PURE;
    STDMETHOD(get_MouseTips)(THIS_ VARIANT_BOOL FAR* pvarfMouse) PURE;
    STDMETHOD(put_KeyboardShortcutTips)(THIS_ VARIANT_BOOL varfKeyboardShortcuts) PURE;
    STDMETHOD(get_KeyboardShortcutTips)(THIS_ VARIANT_BOOL FAR* pvarfKeyboardShortcuts) PURE;
    STDMETHOD(put_HighPriorityTips)(THIS_ VARIANT_BOOL varfHighPriorityTips) PURE;
    STDMETHOD(get_HighPriorityTips)(THIS_ VARIANT_BOOL FAR* pvarfHighPriorityTips) PURE;
    STDMETHOD(put_TipOfDay)(THIS_ VARIANT_BOOL varfTipOfDay) PURE;
    STDMETHOD(get_TipOfDay)(THIS_ VARIANT_BOOL FAR* pvarfTipOfDay) PURE;
    STDMETHOD(put_GuessHelp)(THIS_ VARIANT_BOOL varfGuessHelp) PURE;
    STDMETHOD(get_GuessHelp)(THIS_ VARIANT_BOOL FAR* pvarfGuessHelp) PURE;
    STDMETHOD(put_SearchWhenProgramming)(THIS_ VARIANT_BOOL varfSearchInProgram) PURE;
    STDMETHOD(get_SearchWhenProgramming)(THIS_ VARIANT_BOOL FAR* pvarfSearchInProgram) PURE;
    STDMETHOD(get_Item)(THIS_ BSTR FAR* pbstrName) PURE;
    STDMETHOD(get_FileName)(THIS_ BSTR FAR* pbstr) PURE;
    STDMETHOD(put_FileName)(THIS_ BSTR bstr) PURE;
    STDMETHOD(get_Name)(THIS_ BSTR FAR* pbstrName) PURE;
    STDMETHOD(get_On)(THIS_ VARIANT_BOOL FAR* pvarfOn) PURE;
    STDMETHOD(put_On)(THIS_ VARIANT_BOOL varfOn) PURE;
    STDMETHOD(DoAlert)(THIS_ BSTR bstrAlertTitle, BSTR bstrAlertText, enum tagMsoAlertButtonType alb, enum tagMsoAlertIconType alc, enum tagMsoAlertDefaultType ald, enum tagMsoAlertCancelType alq, VARIANT_BOOL varfSysAlert, int FAR* pibtn) PURE;
};

DEFINE_GUID(IID_DocumentProperty,0x2DF8D04EL,0x5BFA,0x101B,0xBD,0xE5,0x00,0xAA,0x00,0x44,0xDE,0x52);

/* Definition of interface: MsoDocumentProperty */
#undef INTERFACE
#define INTERFACE MsoDocumentProperty

DECLARE_INTERFACE_(MsoDocumentProperty, IDispatch)
{
BEGIN_INTERFACE
#ifndef NO_BASEINTERFACE_FUNCS

    /* IUnknown methods */
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG, AddRef)(THIS) PURE;
    STDMETHOD_(ULONG, Release)(THIS) PURE;

    /* IDispatch methods */
    STDMETHOD(GetTypeInfoCount)(THIS_ UINT FAR* pctinfo) PURE;

    STDMETHOD(GetTypeInfo)(
      THIS_
      UINT itinfo,
      LCID lcid,
      ITypeInfo FAR* FAR* pptinfo) PURE;

    STDMETHOD(GetIDsOfNames)(
      THIS_
      REFIID riid,
      OLECHAR FAR* FAR* rgszNames,
      UINT cNames,
      LCID lcid,
      DISPID FAR* rgdispid) PURE;

    STDMETHOD(Invoke)(
      THIS_
      DISPID dispidMember,
      REFIID riid,
      LCID lcid,
      WORD wFlags,
      DISPPARAMS FAR* pdispparams,
      VARIANT FAR* pvarResult,
      EXCEPINFO FAR* pexcepinfo,
      UINT FAR* puArgErr) PURE;
#endif

    /* MsoDocumentProperty methods */
    STDMETHOD_(IDispatch *, get_Parent)(THIS) PURE;
    STDMETHOD(Delete)(THIS) PURE;
    STDMETHOD(get_Name)(THIS_ long lcid, BSTR FAR* pbstrRetVal) PURE;
    STDMETHOD(put_Name)(THIS_ long lcid, BSTR bstrName) PURE;
    STDMETHOD(get_Value)(THIS_ long lcid, VARIANT FAR* pvargRetVal) PURE;
    STDMETHOD(put_Value)(THIS_ long lcid, VARIANT vargVal) PURE;
    STDMETHOD(get_Type)(THIS_ long lcid, MsoDocProperties FAR* ptypeRetVal) PURE;
    STDMETHOD(put_Type)(THIS_ long lcid, MsoDocProperties type) PURE;
    STDMETHOD(get_LinkToContent)(THIS_ VARIANT_BOOL FAR* pfLinkRetVal) PURE;
    STDMETHOD(put_LinkToContent)(THIS_ VARIANT_BOOL fLink) PURE;
    STDMETHOD(get_LinkSource)(THIS_ BSTR FAR* pbstrSourceRetVal) PURE;
    STDMETHOD(put_LinkSource)(THIS_ BSTR bstrSource) PURE;
    STDMETHOD(get_Application)(THIS_ IDispatch * FAR* ppidisp) PURE;
    STDMETHOD(get_Creator)(THIS_ long FAR* plCreator) PURE;
};

DEFINE_GUID(IID_DocumentProperties,0x2DF8D04DL,0x5BFA,0x101B,0xBD,0xE5,0x00,0xAA,0x00,0x44,0xDE,0x52);

/* Definition of interface: MsoDocumentProperties */
#undef INTERFACE
#define INTERFACE MsoDocumentProperties

DECLARE_INTERFACE_(MsoDocumentProperties, IDispatch)
{
BEGIN_INTERFACE
#ifndef NO_BASEINTERFACE_FUNCS

    /* IUnknown methods */
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG, AddRef)(THIS) PURE;
    STDMETHOD_(ULONG, Release)(THIS) PURE;

    /* IDispatch methods */
    STDMETHOD(GetTypeInfoCount)(THIS_ UINT FAR* pctinfo) PURE;

    STDMETHOD(GetTypeInfo)(
      THIS_
      UINT itinfo,
      LCID lcid,
      ITypeInfo FAR* FAR* pptinfo) PURE;

    STDMETHOD(GetIDsOfNames)(
      THIS_
      REFIID riid,
      OLECHAR FAR* FAR* rgszNames,
      UINT cNames,
      LCID lcid,
      DISPID FAR* rgdispid) PURE;

    STDMETHOD(Invoke)(
      THIS_
      DISPID dispidMember,
      REFIID riid,
      LCID lcid,
      WORD wFlags,
      DISPPARAMS FAR* pdispparams,
      VARIANT FAR* pvarResult,
      EXCEPINFO FAR* pexcepinfo,
      UINT FAR* puArgErr) PURE;
#endif

    /* MsoDocumentProperties methods */
    STDMETHOD_(IDispatch *, get_Parent)(THIS) PURE;
    STDMETHOD(get_Item)(THIS_ VARIANT Index, long lcid, MsoDocumentProperty FAR* FAR* ppIDocProp) PURE;
    STDMETHOD(get_Count)(THIS_ long FAR* pc) PURE;
    STDMETHOD(Add)(THIS_ BSTR Name, VARIANT_BOOL LinkToContent, VARIANT Type, VARIANT Value, VARIANT LinkSource, long lcid, MsoDocumentProperty FAR* FAR* ppIDocProp) PURE;
    STDMETHOD(get__NewEnum)(THIS_ IUnknown * FAR* ppunkEnum) PURE;
    STDMETHOD(get_Application)(THIS_ IDispatch * FAR* ppidisp) PURE;
    STDMETHOD(get_Creator)(THIS_ long FAR* plCreator) PURE;
};

typedef enum {
    msoOptionsNew = 1,
    msoOptionsAdd,
    msoOptionsWithin
} MsoFileFindOptions;

typedef enum {
    msoViewFileInfo = 1,
    msoViewPreview,
    msoViewSummaryInfo
} MsoFileFindView;

typedef enum {
    msoFileFindSortbyAuthor = 1,
    msoFileFindSortbyDateCreated,
    msoFileFindSortbyLastSavedBy,
    msoFileFindSortbyDateSaved,
    msoFileFindSortbyFileName,
    msoFileFindSortbySize,
    msoFileFindSortbyTitle
} MsoFileFindSortBy;

typedef enum {
    msoListbyName = 1,
    msoListbyTitle
} MsoFileFindListBy;

DEFINE_GUID(IID_IFoundFiles,0x000C0338L,0x0000,0x0000,0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46);

/* Definition of interface: IFoundFiles */
#undef INTERFACE
#define INTERFACE IFoundFiles

DECLARE_INTERFACE_(IFoundFiles, IDispatch)
{
BEGIN_INTERFACE
#ifndef NO_BASEINTERFACE_FUNCS

    /* IUnknown methods */
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG, AddRef)(THIS) PURE;
    STDMETHOD_(ULONG, Release)(THIS) PURE;

    /* IDispatch methods */
    STDMETHOD(GetTypeInfoCount)(THIS_ UINT FAR* pctinfo) PURE;

    STDMETHOD(GetTypeInfo)(
      THIS_
      UINT itinfo,
      LCID lcid,
      ITypeInfo FAR* FAR* pptinfo) PURE;

    STDMETHOD(GetIDsOfNames)(
      THIS_
      REFIID riid,
      OLECHAR FAR* FAR* rgszNames,
      UINT cNames,
      LCID lcid,
      DISPID FAR* rgdispid) PURE;

    STDMETHOD(Invoke)(
      THIS_
      DISPID dispidMember,
      REFIID riid,
      LCID lcid,
      WORD wFlags,
      DISPPARAMS FAR* pdispparams,
      VARIANT FAR* pvarResult,
      EXCEPINFO FAR* pexcepinfo,
      UINT FAR* puArgErr) PURE;
#endif

    /* IFoundFiles methods */
    STDMETHOD(get_Item)(THIS_ int Index, BSTR FAR* pbstr) PURE;
    STDMETHOD(get_Count)(THIS_ int FAR* pCount) PURE;
    STDMETHOD(get__NewEnum)(THIS_ IUnknown * FAR* ppunkEnum) PURE;
};

DEFINE_GUID(IID_IFind,0x000C0337L,0x0000,0x0000,0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46);

/* Definition of interface: IFind */
#undef INTERFACE
#define INTERFACE IFind

DECLARE_INTERFACE_(IFind, IDispatch)
{
BEGIN_INTERFACE
#ifndef NO_BASEINTERFACE_FUNCS

    /* IUnknown methods */
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG, AddRef)(THIS) PURE;
    STDMETHOD_(ULONG, Release)(THIS) PURE;

    /* IDispatch methods */
    STDMETHOD(GetTypeInfoCount)(THIS_ UINT FAR* pctinfo) PURE;

    STDMETHOD(GetTypeInfo)(
      THIS_
      UINT itinfo,
      LCID lcid,
      ITypeInfo FAR* FAR* pptinfo) PURE;

    STDMETHOD(GetIDsOfNames)(
      THIS_
      REFIID riid,
      OLECHAR FAR* FAR* rgszNames,
      UINT cNames,
      LCID lcid,
      DISPID FAR* rgdispid) PURE;

    STDMETHOD(Invoke)(
      THIS_
      DISPID dispidMember,
      REFIID riid,
      LCID lcid,
      WORD wFlags,
      DISPPARAMS FAR* pdispparams,
      VARIANT FAR* pvarResult,
      EXCEPINFO FAR* pexcepinfo,
      UINT FAR* puArgErr) PURE;
#endif

    /* IFind methods */
    STDMETHOD(get_SearchPath)(THIS_ BSTR FAR* pbstr) PURE;
    STDMETHOD(get_Name)(THIS_ BSTR FAR* pbstr) PURE;
    STDMETHOD(get_SubDir)(THIS_ VARIANT_BOOL FAR* retval) PURE;
    STDMETHOD(get_Title)(THIS_ BSTR FAR* pbstr) PURE;
    STDMETHOD(get_Author)(THIS_ BSTR FAR* pbstr) PURE;
    STDMETHOD(get_Keywords)(THIS_ BSTR FAR* pbstr) PURE;
    STDMETHOD(get_Subject)(THIS_ BSTR FAR* pbstr) PURE;
    STDMETHOD(get_Options)(THIS_ MsoFileFindOptions FAR* penmOptions) PURE;
    STDMETHOD(get_MatchCase)(THIS_ VARIANT_BOOL FAR* retval) PURE;
    STDMETHOD(get_Text)(THIS_ BSTR FAR* pbstr) PURE;
    STDMETHOD(get_PatternMatch)(THIS_ VARIANT_BOOL FAR* retval) PURE;
    STDMETHOD(get_DateSavedFrom)(THIS_ VARIANT FAR* pdatSavedFrom) PURE;
    STDMETHOD(get_DateSavedTo)(THIS_ VARIANT FAR* pdatSavedTo) PURE;
    STDMETHOD(get_SavedBy)(THIS_ BSTR FAR* pbstr) PURE;
    STDMETHOD(get_DateCreatedFrom)(THIS_ VARIANT FAR* pdatCreatedFrom) PURE;
    STDMETHOD(get_DateCreatedTo)(THIS_ VARIANT FAR* pdatCreatedTo) PURE;
    STDMETHOD(get_View)(THIS_ MsoFileFindView FAR* penmView) PURE;
    STDMETHOD(get_SortBy)(THIS_ MsoFileFindSortBy FAR* penmSortBy) PURE;
    STDMETHOD(get_ListBy)(THIS_ MsoFileFindListBy FAR* penmListBy) PURE;
    STDMETHOD(get_SelectedFile)(THIS_ int FAR* pintSelectedFile) PURE;
    STDMETHOD(get_Results)(THIS_ IFoundFiles FAR* FAR* pdisp) PURE;
    STDMETHOD(Show)(THIS_ int FAR* pRows) PURE;
    STDMETHOD(put_SearchPath)(THIS_ BSTR bstrSearchPath) PURE;
    STDMETHOD(put_Name)(THIS_ BSTR bstrName) PURE;
    STDMETHOD(put_SubDir)(THIS_ VARIANT_BOOL fSubDir) PURE;
    STDMETHOD(put_Title)(THIS_ BSTR bstrTitle) PURE;
    STDMETHOD(put_Author)(THIS_ BSTR bstrAuthor) PURE;
    STDMETHOD(put_Keywords)(THIS_ BSTR bstrKeywords) PURE;
    STDMETHOD(put_Subject)(THIS_ BSTR bstrSubject) PURE;
    STDMETHOD(put_Options)(THIS_ MsoFileFindOptions enmOptions) PURE;
    STDMETHOD(put_MatchCase)(THIS_ VARIANT_BOOL fOptions) PURE;
    STDMETHOD(put_Text)(THIS_ BSTR bstrText) PURE;
    STDMETHOD(put_PatternMatch)(THIS_ VARIANT_BOOL fPatternMatch) PURE;
    STDMETHOD(put_DateSavedFrom)(THIS_ VARIANT datSavedFrom) PURE;
    STDMETHOD(put_DateSavedTo)(THIS_ VARIANT datSavedTo) PURE;
    STDMETHOD(put_SavedBy)(THIS_ BSTR bstrSavedBy) PURE;
    STDMETHOD(put_DateCreatedFrom)(THIS_ VARIANT datCreatedFrom) PURE;
    STDMETHOD(put_DateCreatedTo)(THIS_ VARIANT datCreatedTo) PURE;
    STDMETHOD(put_View)(THIS_ MsoFileFindView enmView) PURE;
    STDMETHOD(put_SortBy)(THIS_ MsoFileFindSortBy enmSortBy) PURE;
    STDMETHOD(put_ListBy)(THIS_ MsoFileFindListBy enmListBy) PURE;
    STDMETHOD(put_SelectedFile)(THIS_ int intSelectedFile) PURE;
    STDMETHOD(Execute)(THIS) PURE;
    STDMETHOD(Load)(THIS_ BSTR bstrQueryName) PURE;
    STDMETHOD(Save)(THIS_ BSTR bstrQueryName) PURE;
    STDMETHOD(Delete)(THIS_ BSTR bstrQueryName) PURE;
    STDMETHOD(get_FileType)(THIS_ long FAR* plFileType) PURE;
    STDMETHOD(put_FileType)(THIS_ long lFileType) PURE;
};

typedef enum {
    msoLastModifiedYesterday = 1,
    msoLastModifiedToday,
    msoLastModifiedLastWeek,
    msoLastModifiedThisWeek,
    msoLastModifiedLastMonth,
    msoLastModifiedThisMonth,
    msoLastModifiedAnyTime
} MsoLastModified;

typedef enum {
    msoSortByFileName = 1,
    msoSortBySize,
    msoSortByFileType,
    msoSortByLastModified,
    msoSortByNone
} MsoSortBy;

typedef enum {
    msoSortOrderAscending = 1,
    msoSortOrderDescending
} MsoSortOrder;

typedef enum {
    msoConnectorAnd = 1,
    msoConnectorOr
} MsoConnector;

typedef enum {
    msoConditionFileTypeAllFiles = 1,
    msoConditionFileTypeOfficeFiles,
    msoConditionFileTypeWordDocuments,
    msoConditionFileTypeExcelWorkbooks,
    msoConditionFileTypePowerPointPresentations,
    msoConditionFileTypeBinders,
    msoConditionFileTypeDatabases,
    msoConditionFileTypeTemplates,
    msoConditionIncludes,
    msoConditionIncludesPhrase,
    msoConditionBeginsWith,
    msoConditionEndsWith,
    msoConditionIncludesNearEachOther,
    msoConditionIsExactly,
    msoConditionIsNot,
    msoConditionYesterday,
    msoConditionToday,
    msoConditionTomorrow,
    msoConditionLastWeek,
    msoConditionThisWeek,
    msoConditionNextWeek,
    msoConditionLastMonth,
    msoConditionThisMonth,
    msoConditionNextMonth,
    msoConditionAnytime,
    msoConditionAnytimeBetween,
    msoConditionOn,
    msoConditionOnOrAfter,
    msoConditionOnOrBefore,
    msoConditionInTheNext,
    msoConditionInTheLast,
    msoConditionEquals,
    msoConditionDoesNotEqual,
    msoConditionAnyNumberBetween,
    msoConditionAtMost,
    msoConditionAtLeast,
    msoConditionMoreThan,
    msoConditionLessThan,
    msoConditionIsYes,
    msoConditionIsNo,
    msoConditionIncludesFormsOf,
    msoConditionFreeText,
    msoConditionFileTypeOutlookItems,
    msoConditionFileTypeMailItem,
    msoConditionFileTypeCalendarItem,
    msoConditionFileTypeContactItem,
    msoConditionFileTypeNoteItem,
    msoConditionFileTypeJournalItem,
    msoConditionFileTypeTaskItem,
    msoConditionFileTypePhotoDrawFiles,
    msoConditionFileTypeDataConnectionFiles,
    msoConditionFileTypePublisherFiles,
    msoConditionFileTypeProjectFiles,
    msoConditionFileTypeDocumentImagingFiles,
    msoConditionFileTypeVisioFiles,
    msoConditionFileTypeDesignerFiles,
    msoConditionFileTypeWebPages,
    msoConditionEqualsLow,
    msoConditionEqualsNormal,
    msoConditionEqualsHigh,
    msoConditionNotEqualToLow,
    msoConditionNotEqualToNormal,
    msoConditionNotEqualToHigh,
    msoConditionEqualsNotStarted,
    msoConditionEqualsInProgress,
    msoConditionEqualsCompleted,
    msoConditionEqualsWaitingForSomeoneElse,
    msoConditionEqualsDeferred,
    msoConditionNotEqualToNotStarted,
    msoConditionNotEqualToInProgress,
    msoConditionNotEqualToCompleted,
    msoConditionNotEqualToWaitingForSomeoneElse,
    msoConditionNotEqualToDeferred
} MsoCondition;

typedef enum {
    msoFileTypeAllFiles = 1,
    msoFileTypeOfficeFiles,
    msoFileTypeWordDocuments,
    msoFileTypeExcelWorkbooks,
    msoFileTypePowerPointPresentations,
    msoFileTypeBinders,
    msoFileTypeDatabases,
    msoFileTypeTemplates,
    msoFileTypeOutlookItems,
    msoFileTypeMailItem,
    msoFileTypeCalendarItem,
    msoFileTypeContactItem,
    msoFileTypeNoteItem,
    msoFileTypeJournalItem,
    msoFileTypeTaskItem,
    msoFileTypePhotoDrawFiles,
    msoFileTypeDataConnectionFiles,
    msoFileTypePublisherFiles,
    msoFileTypeProjectFiles,
    msoFileTypeDocumentImagingFiles,
    msoFileTypeVisioFiles,
    msoFileTypeDesignerFiles,
    msoFileTypeWebPages
} MsoFileType;

DEFINE_GUID(IID_FoundFiles,0x000C0331L,0x0000,0x0000,0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46);

/* Definition of interface: FoundFiles */
#undef INTERFACE
#define INTERFACE FoundFiles

DECLARE_INTERFACE_(FoundFiles, _IMsoDispObj)
{
BEGIN_INTERFACE
#ifndef NO_BASEINTERFACE_FUNCS

    /* IUnknown methods */
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG, AddRef)(THIS) PURE;
    STDMETHOD_(ULONG, Release)(THIS) PURE;

    /* IDispatch methods */
    STDMETHOD(GetTypeInfoCount)(THIS_ UINT FAR* pctinfo) PURE;

    STDMETHOD(GetTypeInfo)(
      THIS_
      UINT itinfo,
      LCID lcid,
      ITypeInfo FAR* FAR* pptinfo) PURE;

    STDMETHOD(GetIDsOfNames)(
      THIS_
      REFIID riid,
      OLECHAR FAR* FAR* rgszNames,
      UINT cNames,
      LCID lcid,
      DISPID FAR* rgdispid) PURE;

    STDMETHOD(Invoke)(
      THIS_
      DISPID dispidMember,
      REFIID riid,
      LCID lcid,
      WORD wFlags,
      DISPPARAMS FAR* pdispparams,
      VARIANT FAR* pvarResult,
      EXCEPINFO FAR* pexcepinfo,
      UINT FAR* puArgErr) PURE;

    /* _IMsoDispObj methods */
    STDMETHOD(get_Application)(THIS_ IDispatch * FAR* ppidisp) PURE;
    STDMETHOD(get_Creator)(THIS_ long FAR* plCreator) PURE;
#endif

    /* FoundFiles methods */
    STDMETHOD(get_Item)(THIS_ int Index, long lcid, BSTR FAR* pbstrFile) PURE;
    STDMETHOD(get_Count)(THIS_ long FAR* pc) PURE;
    STDMETHOD(get__NewEnum)(THIS_ IUnknown * FAR* ppunkEnum) PURE;
};

DEFINE_GUID(IID_PropertyTest,0x000C0333L,0x0000,0x0000,0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46);

/* Definition of interface: PropertyTest */
#undef INTERFACE
#define INTERFACE PropertyTest

DECLARE_INTERFACE_(PropertyTest, _IMsoDispObj)
{
BEGIN_INTERFACE
#ifndef NO_BASEINTERFACE_FUNCS

    /* IUnknown methods */
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG, AddRef)(THIS) PURE;
    STDMETHOD_(ULONG, Release)(THIS) PURE;

    /* IDispatch methods */
    STDMETHOD(GetTypeInfoCount)(THIS_ UINT FAR* pctinfo) PURE;

    STDMETHOD(GetTypeInfo)(
      THIS_
      UINT itinfo,
      LCID lcid,
      ITypeInfo FAR* FAR* pptinfo) PURE;

    STDMETHOD(GetIDsOfNames)(
      THIS_
      REFIID riid,
      OLECHAR FAR* FAR* rgszNames,
      UINT cNames,
      LCID lcid,
      DISPID FAR* rgdispid) PURE;

    STDMETHOD(Invoke)(
      THIS_
      DISPID dispidMember,
      REFIID riid,
      LCID lcid,
      WORD wFlags,
      DISPPARAMS FAR* pdispparams,
      VARIANT FAR* pvarResult,
      EXCEPINFO FAR* pexcepinfo,
      UINT FAR* puArgErr) PURE;

    /* _IMsoDispObj methods */
    STDMETHOD(get_Application)(THIS_ IDispatch * FAR* ppidisp) PURE;
    STDMETHOD(get_Creator)(THIS_ long FAR* plCreator) PURE;
#endif

    /* PropertyTest methods */
    STDMETHOD(get_Name)(THIS_ BSTR FAR* pbstrRetVal) PURE;
    STDMETHOD(get_Condition)(THIS_ MsoCondition FAR* pConditionRetVal) PURE;
    STDMETHOD(get_Value)(THIS_ VARIANT FAR* pvargRetVal) PURE;
    STDMETHOD(get_SecondValue)(THIS_ VARIANT FAR* pvargRetVal2) PURE;
    STDMETHOD(get_Connector)(THIS_ MsoConnector FAR* pConnector) PURE;
};

DEFINE_GUID(IID_PropertyTests,0x000C0334L,0x0000,0x0000,0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46);

/* Definition of interface: PropertyTests */
#undef INTERFACE
#define INTERFACE PropertyTests

DECLARE_INTERFACE_(PropertyTests, _IMsoDispObj)
{
BEGIN_INTERFACE
#ifndef NO_BASEINTERFACE_FUNCS

    /* IUnknown methods */
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG, AddRef)(THIS) PURE;
    STDMETHOD_(ULONG, Release)(THIS) PURE;

    /* IDispatch methods */
    STDMETHOD(GetTypeInfoCount)(THIS_ UINT FAR* pctinfo) PURE;

    STDMETHOD(GetTypeInfo)(
      THIS_
      UINT itinfo,
      LCID lcid,
      ITypeInfo FAR* FAR* pptinfo) PURE;

    STDMETHOD(GetIDsOfNames)(
      THIS_
      REFIID riid,
      OLECHAR FAR* FAR* rgszNames,
      UINT cNames,
      LCID lcid,
      DISPID FAR* rgdispid) PURE;

    STDMETHOD(Invoke)(
      THIS_
      DISPID dispidMember,
      REFIID riid,
      LCID lcid,
      WORD wFlags,
      DISPPARAMS FAR* pdispparams,
      VARIANT FAR* pvarResult,
      EXCEPINFO FAR* pexcepinfo,
      UINT FAR* puArgErr) PURE;

    /* _IMsoDispObj methods */
    STDMETHOD(get_Application)(THIS_ IDispatch * FAR* ppidisp) PURE;
    STDMETHOD(get_Creator)(THIS_ long FAR* plCreator) PURE;
#endif

    /* PropertyTests methods */
    STDMETHOD(get_Item)(THIS_ int Index, long lcid, PropertyTest FAR* FAR* ppIDocProp) PURE;
    STDMETHOD(get_Count)(THIS_ long FAR* pc) PURE;
    STDMETHOD(Add)(THIS_ BSTR Name, MsoCondition Condition, VARIANT Value, VARIANT SecondValue, MsoConnector Connector) PURE;
    STDMETHOD(Remove)(THIS_ int Index) PURE;
    STDMETHOD(get__NewEnum)(THIS_ IUnknown * FAR* ppunkEnum) PURE;
};

DEFINE_GUID(IID_FileSearch,0x000C0332L,0x0000,0x0000,0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46);

/* Definition of interface: FileSearch */
#undef INTERFACE
#define INTERFACE FileSearch

DECLARE_INTERFACE_(FileSearch, _IMsoDispObj)
{
BEGIN_INTERFACE
#ifndef NO_BASEINTERFACE_FUNCS

    /* IUnknown methods */
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG, AddRef)(THIS) PURE;
    STDMETHOD_(ULONG, Release)(THIS) PURE;

    /* IDispatch methods */
    STDMETHOD(GetTypeInfoCount)(THIS_ UINT FAR* pctinfo) PURE;

    STDMETHOD(GetTypeInfo)(
      THIS_
      UINT itinfo,
      LCID lcid,
      ITypeInfo FAR* FAR* pptinfo) PURE;

    STDMETHOD(GetIDsOfNames)(
      THIS_
      REFIID riid,
      OLECHAR FAR* FAR* rgszNames,
      UINT cNames,
      LCID lcid,
      DISPID FAR* rgdispid) PURE;

    STDMETHOD(Invoke)(
      THIS_
      DISPID dispidMember,
      REFIID riid,
      LCID lcid,
      WORD wFlags,
      DISPPARAMS FAR* pdispparams,
      VARIANT FAR* pvarResult,
      EXCEPINFO FAR* pexcepinfo,
      UINT FAR* puArgErr) PURE;

    /* _IMsoDispObj methods */
    STDMETHOD(get_Application)(THIS_ IDispatch * FAR* ppidisp) PURE;
    STDMETHOD(get_Creator)(THIS_ long FAR* plCreator) PURE;
#endif

    /* FileSearch methods */
    STDMETHOD(get_SearchSubFolders)(THIS_ VARIANT_BOOL FAR* SearchSubFoldersRetVal) PURE;
    STDMETHOD(put_SearchSubFolders)(THIS_ VARIANT_BOOL SearchSubFolders) PURE;
    STDMETHOD(get_MatchTextExactly)(THIS_ VARIANT_BOOL FAR* MatchTextRetVal) PURE;
    STDMETHOD(put_MatchTextExactly)(THIS_ VARIANT_BOOL MatchText) PURE;
    STDMETHOD(get_MatchAllWordForms)(THIS_ VARIANT_BOOL FAR* MatchAllWordFormsRetVal) PURE;
    STDMETHOD(put_MatchAllWordForms)(THIS_ VARIANT_BOOL MatchAllWordForms) PURE;
    STDMETHOD(get_FileName)(THIS_ BSTR FAR* FileNameRetVal) PURE;
    STDMETHOD(put_FileName)(THIS_ BSTR FileName) PURE;
    STDMETHOD(get_FileType)(THIS_ MsoFileType FAR* FileTypeRetVal) PURE;
    STDMETHOD(put_FileType)(THIS_ MsoFileType FileType) PURE;
    STDMETHOD(get_LastModified)(THIS_ MsoLastModified FAR* LastModifiedRetVal) PURE;
    STDMETHOD(put_LastModified)(THIS_ MsoLastModified LastModified) PURE;
    STDMETHOD(get_TextOrProperty)(THIS_ BSTR FAR* TextOrProperty) PURE;
    STDMETHOD(put_TextOrProperty)(THIS_ BSTR TextOrProperty) PURE;
    STDMETHOD(get_LookIn)(THIS_ BSTR FAR* LookInRetVal) PURE;
    STDMETHOD(put_LookIn)(THIS_ BSTR LookIn) PURE;
    STDMETHOD(Execute)(THIS_ MsoSortBy SortBy, MsoSortOrder SortOrder, VARIANT_BOOL AlwaysAccurate, int FAR* pRet) PURE;
    STDMETHOD(NewSearch)(THIS) PURE;
    STDMETHOD(get_FoundFiles)(THIS_ FoundFiles FAR* FAR* FoundFilesRet) PURE;
    STDMETHOD(get_PropertyTests)(THIS_ PropertyTests FAR* FAR* PropTestsRet) PURE;
    STDMETHOD(get_SearchScopes)(THIS_ SearchScopes FAR* FAR* SearchScopesRet) PURE;
    STDMETHOD(get_SearchFolders)(THIS_ SearchFolders FAR* FAR* SearchFoldersRet) PURE;
    STDMETHOD(get_FileTypes)(THIS_ FileTypes FAR* FAR* FileTypesRet) PURE;
    STDMETHOD(RefreshScopes)(THIS) PURE;
};

DEFINE_GUID(IID_COMAddIn,0x000C033AL,0x0000,0x0000,0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46);

/* Definition of interface: COMAddIn */
#undef INTERFACE
#define INTERFACE COMAddIn

DECLARE_INTERFACE_(COMAddIn, _IMsoDispObj)
{
BEGIN_INTERFACE
#ifndef NO_BASEINTERFACE_FUNCS

    /* IUnknown methods */
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG, AddRef)(THIS) PURE;
    STDMETHOD_(ULONG, Release)(THIS) PURE;

    /* IDispatch methods */
    STDMETHOD(GetTypeInfoCount)(THIS_ UINT FAR* pctinfo) PURE;

    STDMETHOD(GetTypeInfo)(
      THIS_
      UINT itinfo,
      LCID lcid,
      ITypeInfo FAR* FAR* pptinfo) PURE;

    STDMETHOD(GetIDsOfNames)(
      THIS_
      REFIID riid,
      OLECHAR FAR* FAR* rgszNames,
      UINT cNames,
      LCID lcid,
      DISPID FAR* rgdispid) PURE;

    STDMETHOD(Invoke)(
      THIS_
      DISPID dispidMember,
      REFIID riid,
      LCID lcid,
      WORD wFlags,
      DISPPARAMS FAR* pdispparams,
      VARIANT FAR* pvarResult,
      EXCEPINFO FAR* pexcepinfo,
      UINT FAR* puArgErr) PURE;

    /* _IMsoDispObj methods */
    STDMETHOD(get_Application)(THIS_ IDispatch * FAR* ppidisp) PURE;
    STDMETHOD(get_Creator)(THIS_ long FAR* plCreator) PURE;
#endif

    /* COMAddIn methods */
    STDMETHOD(get_Description)(THIS_ BSTR FAR* RetValue) PURE;
    STDMETHOD(put_Description)(THIS_ BSTR Value) PURE;
    STDMETHOD(get_ProgId)(THIS_ BSTR FAR* RetValue) PURE;
    STDMETHOD(get_Guid)(THIS_ BSTR FAR* RetValue) PURE;
    STDMETHOD(get_Connect)(THIS_ VARIANT_BOOL FAR* RetValue) PURE;
    STDMETHOD(put_Connect)(THIS_ VARIANT_BOOL Value) PURE;
    STDMETHOD(get_Object)(THIS_ IDispatch * FAR* RetValue) PURE;
    STDMETHOD(put_Object)(THIS_ IDispatch * Value) PURE;
    STDMETHOD(get_Parent)(THIS_ IDispatch * FAR* RetVal) PURE;
};

DEFINE_GUID(IID_COMAddIns,0x000C0339L,0x0000,0x0000,0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46);

/* Definition of interface: COMAddIns */
#undef INTERFACE
#define INTERFACE COMAddIns

DECLARE_INTERFACE_(COMAddIns, _IMsoDispObj)
{
BEGIN_INTERFACE
#ifndef NO_BASEINTERFACE_FUNCS

    /* IUnknown methods */
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG, AddRef)(THIS) PURE;
    STDMETHOD_(ULONG, Release)(THIS) PURE;

    /* IDispatch methods */
    STDMETHOD(GetTypeInfoCount)(THIS_ UINT FAR* pctinfo) PURE;

    STDMETHOD(GetTypeInfo)(
      THIS_
      UINT itinfo,
      LCID lcid,
      ITypeInfo FAR* FAR* pptinfo) PURE;

    STDMETHOD(GetIDsOfNames)(
      THIS_
      REFIID riid,
      OLECHAR FAR* FAR* rgszNames,
      UINT cNames,
      LCID lcid,
      DISPID FAR* rgdispid) PURE;

    STDMETHOD(Invoke)(
      THIS_
      DISPID dispidMember,
      REFIID riid,
      LCID lcid,
      WORD wFlags,
      DISPPARAMS FAR* pdispparams,
      VARIANT FAR* pvarResult,
      EXCEPINFO FAR* pexcepinfo,
      UINT FAR* puArgErr) PURE;

    /* _IMsoDispObj methods */
    STDMETHOD(get_Application)(THIS_ IDispatch * FAR* ppidisp) PURE;
    STDMETHOD(get_Creator)(THIS_ long FAR* plCreator) PURE;
#endif

    /* COMAddIns methods */
    STDMETHOD(Item)(THIS_ VARIANT FAR* Index, COMAddIn FAR* FAR* RetValue) PURE;
    STDMETHOD(get_Count)(THIS_ long FAR* RetValue) PURE;
    STDMETHOD(get__NewEnum)(THIS_ IUnknown * FAR* RetValue) PURE;
    STDMETHOD(Update)(THIS) PURE;
    STDMETHOD(get_Parent)(THIS_ IDispatch * FAR* ppidisp) PURE;
    STDMETHOD(SetAppModal)(THIS_ VARIANT_BOOL varfModal) PURE;
};

typedef enum {
    msoLanguageIDMixed = -2,
    msoLanguageIDNone = 0,
    msoLanguageIDNoProofing = 1024,
    msoLanguageIDAfrikaans = 1078,
    msoLanguageIDAlbanian = 1052,
    msoLanguageIDAmharic = 1118,
    msoLanguageIDArabicAlgeria = 5121,
    msoLanguageIDArabicBahrain = 15361,
    msoLanguageIDArabicEgypt = 3073,
    msoLanguageIDArabicIraq = 2049,
    msoLanguageIDArabicJordan = 11265,
    msoLanguageIDArabicKuwait = 13313,
    msoLanguageIDArabicLebanon = 12289,
    msoLanguageIDArabicLibya = 4097,
    msoLanguageIDArabicMorocco = 6145,
    msoLanguageIDArabicOman = 8193,
    msoLanguageIDArabicQatar = 16385,
    msoLanguageIDArabic = 1025,
    msoLanguageIDArabicSyria = 10241,
    msoLanguageIDArabicTunisia = 7169,
    msoLanguageIDArabicUAE = 14337,
    msoLanguageIDArabicYemen = 9217,
    msoLanguageIDArmenian = 1067,
    msoLanguageIDAssamese = 1101,
    msoLanguageIDAzeriCyrillic = 2092,
    msoLanguageIDAzeriLatin = 1068,
    msoLanguageIDBasque = 1069,
    msoLanguageIDByelorussian = 1059,
    msoLanguageIDBengali = 1093,
    msoLanguageIDBulgarian = 1026,
    msoLanguageIDBurmese = 1109,
    msoLanguageIDCatalan = 1027,
    msoLanguageIDChineseHongKongSAR = 3076,
    msoLanguageIDChineseMacaoSAR = 5124,
    msoLanguageIDSimplifiedChinese = 2052,
    msoLanguageIDChineseSingapore = 4100,
    msoLanguageIDTraditionalChinese = 1028,
    msoLanguageIDCherokee = 1116,
    msoLanguageIDCroatian = 1050,
    msoLanguageIDCzech = 1029,
    msoLanguageIDDanish = 1030,
    msoLanguageIDDivehi = 1125,
    msoLanguageIDBelgianDutch = 2067,
    msoLanguageIDDutch = 1043,
    msoLanguageIDDzongkhaBhutan = 2129,
    msoLanguageIDEdo = 1126,
    msoLanguageIDEnglishAUS = 3081,
    msoLanguageIDEnglishBelize = 10249,
    msoLanguageIDEnglishCanadian = 4105,
    msoLanguageIDEnglishCaribbean = 9225,
    msoLanguageIDEnglishIndonesia = 14345,
    msoLanguageIDEnglishIreland = 6153,
    msoLanguageIDEnglishJamaica = 8201,
    msoLanguageIDEnglishNewZealand = 5129,
    msoLanguageIDEnglishPhilippines = 13321,
    msoLanguageIDEnglishSouthAfrica = 7177,
    msoLanguageIDEnglishTrinidadTobago = 11273,
    msoLanguageIDEnglishUK = 2057,
    msoLanguageIDEnglishUS = 1033,
    msoLanguageIDEnglishZimbabwe = 12297,
    msoLanguageIDEstonian = 1061,
    msoLanguageIDFaeroese = 1080,
    msoLanguageIDFarsi = 1065,
    msoLanguageIDFilipino = 1124,
    msoLanguageIDFinnish = 1035,
    msoLanguageIDBelgianFrench = 2060,
    msoLanguageIDFrenchCameroon = 11276,
    msoLanguageIDFrenchCanadian = 3084,
    msoLanguageIDFrenchCotedIvoire = 12300,
    msoLanguageIDFrench = 1036,
    msoLanguageIDFrenchHaiti = 15372,
    msoLanguageIDFrenchLuxembourg = 5132,
    msoLanguageIDFrenchMali = 13324,
    msoLanguageIDFrenchMonaco = 6156,
    msoLanguageIDFrenchMorocco = 14348,
    msoLanguageIDFrenchReunion = 8204,
    msoLanguageIDFrenchSenegal = 10252,
    msoLanguageIDSwissFrench = 4108,
    msoLanguageIDFrenchWestIndies = 7180,
    msoLanguageIDFrenchZaire = 9228,
    msoLanguageIDFrisianNetherlands = 1122,
    msoLanguageIDFulfulde = 1127,
    msoLanguageIDGaelicIreland = 2108,
    msoLanguageIDGaelicScotland = 1084,
    msoLanguageIDGalician = 1110,
    msoLanguageIDGeorgian = 1079,
    msoLanguageIDGermanAustria = 3079,
    msoLanguageIDGerman = 1031,
    msoLanguageIDGermanLiechtenstein = 5127,
    msoLanguageIDGermanLuxembourg = 4103,
    msoLanguageIDSwissGerman = 2055,
    msoLanguageIDGreek = 1032,
    msoLanguageIDGuarani = 1140,
    msoLanguageIDGujarati = 1095,
    msoLanguageIDHausa = 1128,
    msoLanguageIDHawaiian = 1141,
    msoLanguageIDHebrew = 1037,
    msoLanguageIDHindi = 1081,
    msoLanguageIDHungarian = 1038,
    msoLanguageIDIbibio = 1129,
    msoLanguageIDIcelandic = 1039,
    msoLanguageIDIgbo = 1136,
    msoLanguageIDIndonesian = 1057,
    msoLanguageIDInuktitut = 1117,
    msoLanguageIDItalian = 1040,
    msoLanguageIDSwissItalian = 2064,
    msoLanguageIDJapanese = 1041,
    msoLanguageIDKannada = 1099,
    msoLanguageIDKanuri = 1137,
    msoLanguageIDKazakh = 1087,
    msoLanguageIDKhmer = 1107,
    msoLanguageIDKirghiz = 1088,
    msoLanguageIDKonkani = 1111,
    msoLanguageIDKorean = 1042,
    msoLanguageIDKyrgyz = 1088,
    msoLanguageIDLatin = 1142,
    msoLanguageIDLao = 1108,
    msoLanguageIDLatvian = 1062,
    msoLanguageIDLithuanian = 1063,
    msoLanguageIDMacedonian = 1071,
    msoLanguageIDMalaysian = 1086,
    msoLanguageIDMalayBruneiDarussalam = 2110,
    msoLanguageIDMalayalam = 1100,
    msoLanguageIDMaltese = 1082,
    msoLanguageIDManipuri = 1112,
    msoLanguageIDMarathi = 1102,
    msoLanguageIDMongolian = 1104,
    msoLanguageIDNepali = 1121,
    msoLanguageIDNorwegianBokmol = 1044,
    msoLanguageIDNorwegianNynorsk = 2068,
    msoLanguageIDOriya = 1096,
    msoLanguageIDOromo = 1138,
    msoLanguageIDPashto = 1123,
    msoLanguageIDPolish = 1045,
    msoLanguageIDBrazilianPortuguese = 1046,
    msoLanguageIDPortuguese = 2070,
    msoLanguageIDPunjabi = 1094,
    msoLanguageIDRhaetoRomanic = 1047,
    msoLanguageIDRomanianMoldova = 2072,
    msoLanguageIDRomanian = 1048,
    msoLanguageIDRussianMoldova = 2073,
    msoLanguageIDRussian = 1049,
    msoLanguageIDSamiLappish = 1083,
    msoLanguageIDSanskrit = 1103,
    msoLanguageIDSerbianCyrillic = 3098,
    msoLanguageIDSerbianLatin = 2074,
    msoLanguageIDSesotho = 1072,
    msoLanguageIDSindhi = 1113,
    msoLanguageIDSindhiPakistan = 2137,
    msoLanguageIDSinhalese = 1115,
    msoLanguageIDSlovak = 1051,
    msoLanguageIDSlovenian = 1060,
    msoLanguageIDSomali = 1143,
    msoLanguageIDSorbian = 1070,
    msoLanguageIDSpanishArgentina = 11274,
    msoLanguageIDSpanishBolivia = 16394,
    msoLanguageIDSpanishChile = 13322,
    msoLanguageIDSpanishColombia = 9226,
    msoLanguageIDSpanishCostaRica = 5130,
    msoLanguageIDSpanishDominicanRepublic = 7178,
    msoLanguageIDSpanishEcuador = 12298,
    msoLanguageIDSpanishElSalvador = 17418,
    msoLanguageIDSpanishGuatemala = 4106,
    msoLanguageIDSpanishHonduras = 18442,
    msoLanguageIDMexicanSpanish = 2058,
    msoLanguageIDSpanishNicaragua = 19466,
    msoLanguageIDSpanishPanama = 6154,
    msoLanguageIDSpanishParaguay = 15370,
    msoLanguageIDSpanishPeru = 10250,
    msoLanguageIDSpanishPuertoRico = 20490,
    msoLanguageIDSpanishModernSort = 3082,
    msoLanguageIDSpanish = 1034,
    msoLanguageIDSpanishUruguay = 14346,
    msoLanguageIDSpanishVenezuela = 8202,
    msoLanguageIDSutu = 1072,
    msoLanguageIDSwahili = 1089,
    msoLanguageIDSwedishFinland = 2077,
    msoLanguageIDSwedish = 1053,
    msoLanguageIDSyriac = 1114,
    msoLanguageIDTajik = 1064,
    msoLanguageIDTamil = 1097,
    msoLanguageIDTamazight = 1119,
    msoLanguageIDTamazightLatin = 2143,
    msoLanguageIDTatar = 1092,
    msoLanguageIDTelugu = 1098,
    msoLanguageIDThai = 1054,
    msoLanguageIDTibetan = 1105,
    msoLanguageIDTigrignaEthiopic = 1139,
    msoLanguageIDTigrignaEritrea = 2163,
    msoLanguageIDTsonga = 1073,
    msoLanguageIDTswana = 1074,
    msoLanguageIDTurkish = 1055,
    msoLanguageIDTurkmen = 1090,
    msoLanguageIDUkrainian = 1058,
    msoLanguageIDUrdu = 1056,
    msoLanguageIDUzbekCyrillic = 2115,
    msoLanguageIDUzbekLatin = 1091,
    msoLanguageIDVenda = 1075,
    msoLanguageIDVietnamese = 1066,
    msoLanguageIDWelsh = 1106,
    msoLanguageIDXhosa = 1076,
    msoLanguageIDYi = 1144,
    msoLanguageIDYiddish = 1085,
    msoLanguageIDYoruba = 1130,
    msoLanguageIDZulu = 1077
} MsoLanguageID;

DEFINE_GUID(IID_LanguageSettings,0x000C0353L,0x0000,0x0000,0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46);

/* Definition of interface: LanguageSettings */
#undef INTERFACE
#define INTERFACE LanguageSettings

DECLARE_INTERFACE_(LanguageSettings, _IMsoDispObj)
{
BEGIN_INTERFACE
#ifndef NO_BASEINTERFACE_FUNCS

    /* IUnknown methods */
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG, AddRef)(THIS) PURE;
    STDMETHOD_(ULONG, Release)(THIS) PURE;

    /* IDispatch methods */
    STDMETHOD(GetTypeInfoCount)(THIS_ UINT FAR* pctinfo) PURE;

    STDMETHOD(GetTypeInfo)(
      THIS_
      UINT itinfo,
      LCID lcid,
      ITypeInfo FAR* FAR* pptinfo) PURE;

    STDMETHOD(GetIDsOfNames)(
      THIS_
      REFIID riid,
      OLECHAR FAR* FAR* rgszNames,
      UINT cNames,
      LCID lcid,
      DISPID FAR* rgdispid) PURE;

    STDMETHOD(Invoke)(
      THIS_
      DISPID dispidMember,
      REFIID riid,
      LCID lcid,
      WORD wFlags,
      DISPPARAMS FAR* pdispparams,
      VARIANT FAR* pvarResult,
      EXCEPINFO FAR* pexcepinfo,
      UINT FAR* puArgErr) PURE;

    /* _IMsoDispObj methods */
    STDMETHOD(get_Application)(THIS_ IDispatch * FAR* ppidisp) PURE;
    STDMETHOD(get_Creator)(THIS_ long FAR* plCreator) PURE;
#endif

    /* LanguageSettings methods */
    STDMETHOD(get_LanguageID)(THIS_ MsoAppLanguageID id, int FAR* plid) PURE;
    STDMETHOD(get_LanguagePreferredForEditing)(THIS_ MsoLanguageID lid, VARIANT_BOOL FAR* pf) PURE;
    STDMETHOD(get_Parent)(THIS_ IDispatch * FAR* ppidisp) PURE;
};

DEFINE_GUID(IID_ICommandBarsEvents,0x55F88892L,0x7708,0x11D1,0xAC,0xEB,0x00,0x60,0x08,0x96,0x1D,0xA5);

/* Definition of interface: ICommandBarsEvents */
#undef INTERFACE
#define INTERFACE ICommandBarsEvents

DECLARE_INTERFACE_(ICommandBarsEvents, IDispatch)
{
BEGIN_INTERFACE
#ifndef NO_BASEINTERFACE_FUNCS

    /* IUnknown methods */
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG, AddRef)(THIS) PURE;
    STDMETHOD_(ULONG, Release)(THIS) PURE;

    /* IDispatch methods */
    STDMETHOD(GetTypeInfoCount)(THIS_ UINT FAR* pctinfo) PURE;

    STDMETHOD(GetTypeInfo)(
      THIS_
      UINT itinfo,
      LCID lcid,
      ITypeInfo FAR* FAR* pptinfo) PURE;

    STDMETHOD(GetIDsOfNames)(
      THIS_
      REFIID riid,
      OLECHAR FAR* FAR* rgszNames,
      UINT cNames,
      LCID lcid,
      DISPID FAR* rgdispid) PURE;

    STDMETHOD(Invoke)(
      THIS_
      DISPID dispidMember,
      REFIID riid,
      LCID lcid,
      WORD wFlags,
      DISPPARAMS FAR* pdispparams,
      VARIANT FAR* pvarResult,
      EXCEPINFO FAR* pexcepinfo,
      UINT FAR* puArgErr) PURE;
#endif

    /* ICommandBarsEvents methods */
    STDMETHOD_(void, OnUpdate)(THIS) PURE;
};

DEFINE_GUID(DIID__CommandBarsEvents,0x000C0352L,0x0000,0x0000,0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46);

/* Definition of dispatch interface: CommandBarsEvents */
#undef INTERFACE
#define INTERFACE CommandBarsEvents

DECLARE_INTERFACE_(CommandBarsEvents, IDispatch)
{
BEGIN_INTERFACE
#ifndef NO_BASEINTERFACE_FUNCS

    /* IUnknown methods */
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG, AddRef)(THIS) PURE;
    STDMETHOD_(ULONG, Release)(THIS) PURE;

    /* IDispatch methods */
    STDMETHOD(GetTypeInfoCount)(THIS_ UINT FAR* pctinfo) PURE;

    STDMETHOD(GetTypeInfo)(
      THIS_
      UINT itinfo,
      LCID lcid,
      ITypeInfo FAR* FAR* pptinfo) PURE;

    STDMETHOD(GetIDsOfNames)(
      THIS_
      REFIID riid,
      OLECHAR FAR* FAR* rgszNames,
      UINT cNames,
      LCID lcid,
      DISPID FAR* rgdispid) PURE;

    STDMETHOD(Invoke)(
      THIS_
      DISPID dispidMember,
      REFIID riid,
      LCID lcid,
      WORD wFlags,
      DISPPARAMS FAR* pdispparams,
      VARIANT FAR* pvarResult,
      EXCEPINFO FAR* pexcepinfo,
      UINT FAR* puArgErr) PURE;
#endif

/* Capable of dispatching all the methods of interface ICommandBarsEvents */
};

DEFINE_GUID(CLSID_CommandBars,0x55F88893L,0x7708,0x11D1,0xAC,0xEB,0x00,0x60,0x08,0x96,0x1D,0xA5);

#ifdef __cplusplus
class MsoCommandBars;
#endif

#ifdef __cplusplus
class MsoCommandBarComboBox;
#endif

DEFINE_GUID(IID_ICommandBarComboBoxEvents,0x55F88896L,0x7708,0x11D1,0xAC,0xEB,0x00,0x60,0x08,0x96,0x1D,0xA5);

/* Definition of interface: ICommandBarComboBoxEvents */
#undef INTERFACE
#define INTERFACE ICommandBarComboBoxEvents

DECLARE_INTERFACE_(ICommandBarComboBoxEvents, IDispatch)
{
BEGIN_INTERFACE
#ifndef NO_BASEINTERFACE_FUNCS

    /* IUnknown methods */
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG, AddRef)(THIS) PURE;
    STDMETHOD_(ULONG, Release)(THIS) PURE;

    /* IDispatch methods */
    STDMETHOD(GetTypeInfoCount)(THIS_ UINT FAR* pctinfo) PURE;

    STDMETHOD(GetTypeInfo)(
      THIS_
      UINT itinfo,
      LCID lcid,
      ITypeInfo FAR* FAR* pptinfo) PURE;

    STDMETHOD(GetIDsOfNames)(
      THIS_
      REFIID riid,
      OLECHAR FAR* FAR* rgszNames,
      UINT cNames,
      LCID lcid,
      DISPID FAR* rgdispid) PURE;

    STDMETHOD(Invoke)(
      THIS_
      DISPID dispidMember,
      REFIID riid,
      LCID lcid,
      WORD wFlags,
      DISPPARAMS FAR* pdispparams,
      VARIANT FAR* pvarResult,
      EXCEPINFO FAR* pexcepinfo,
      UINT FAR* puArgErr) PURE;
#endif

    /* ICommandBarComboBoxEvents methods */
    STDMETHOD_(void, Change)(THIS_ CommandBarComboBox FAR* Ctrl) PURE;
};

DEFINE_GUID(DIID__CommandBarComboBoxEvents,0x000C0354L,0x0000,0x0000,0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46);

/* Definition of dispatch interface: CommandBarComboBoxEvents */
#undef INTERFACE
#define INTERFACE CommandBarComboBoxEvents

DECLARE_INTERFACE_(CommandBarComboBoxEvents, IDispatch)
{
BEGIN_INTERFACE
#ifndef NO_BASEINTERFACE_FUNCS

    /* IUnknown methods */
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG, AddRef)(THIS) PURE;
    STDMETHOD_(ULONG, Release)(THIS) PURE;

    /* IDispatch methods */
    STDMETHOD(GetTypeInfoCount)(THIS_ UINT FAR* pctinfo) PURE;

    STDMETHOD(GetTypeInfo)(
      THIS_
      UINT itinfo,
      LCID lcid,
      ITypeInfo FAR* FAR* pptinfo) PURE;

    STDMETHOD(GetIDsOfNames)(
      THIS_
      REFIID riid,
      OLECHAR FAR* FAR* rgszNames,
      UINT cNames,
      LCID lcid,
      DISPID FAR* rgdispid) PURE;

    STDMETHOD(Invoke)(
      THIS_
      DISPID dispidMember,
      REFIID riid,
      LCID lcid,
      WORD wFlags,
      DISPPARAMS FAR* pdispparams,
      VARIANT FAR* pvarResult,
      EXCEPINFO FAR* pexcepinfo,
      UINT FAR* puArgErr) PURE;
#endif

/* Capable of dispatching all the methods of interface ICommandBarComboBoxEvents */
};

DEFINE_GUID(CLSID_CommandBarComboBox,0x55F88897L,0x7708,0x11D1,0xAC,0xEB,0x00,0x60,0x08,0x96,0x1D,0xA5);

#ifdef __cplusplus
class MsoCommandBarComboBox;
#endif

#ifdef __cplusplus
class MsoCommandBarButton;
#endif

DEFINE_GUID(IID_ICommandBarButtonEvents,0x55F88890L,0x7708,0x11D1,0xAC,0xEB,0x00,0x60,0x08,0x96,0x1D,0xA5);

/* Definition of interface: ICommandBarButtonEvents */
#undef INTERFACE
#define INTERFACE ICommandBarButtonEvents

DECLARE_INTERFACE_(ICommandBarButtonEvents, IDispatch)
{
BEGIN_INTERFACE
#ifndef NO_BASEINTERFACE_FUNCS

    /* IUnknown methods */
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG, AddRef)(THIS) PURE;
    STDMETHOD_(ULONG, Release)(THIS) PURE;

    /* IDispatch methods */
    STDMETHOD(GetTypeInfoCount)(THIS_ UINT FAR* pctinfo) PURE;

    STDMETHOD(GetTypeInfo)(
      THIS_
      UINT itinfo,
      LCID lcid,
      ITypeInfo FAR* FAR* pptinfo) PURE;

    STDMETHOD(GetIDsOfNames)(
      THIS_
      REFIID riid,
      OLECHAR FAR* FAR* rgszNames,
      UINT cNames,
      LCID lcid,
      DISPID FAR* rgdispid) PURE;

    STDMETHOD(Invoke)(
      THIS_
      DISPID dispidMember,
      REFIID riid,
      LCID lcid,
      WORD wFlags,
      DISPPARAMS FAR* pdispparams,
      VARIANT FAR* pvarResult,
      EXCEPINFO FAR* pexcepinfo,
      UINT FAR* puArgErr) PURE;
#endif

    /* ICommandBarButtonEvents methods */
    STDMETHOD_(void, Click)(THIS_ CommandBarButton FAR* Ctrl, VARIANT_BOOL FAR* CancelDefault) PURE;
};

DEFINE_GUID(DIID__CommandBarButtonEvents,0x000C0351L,0x0000,0x0000,0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46);

/* Definition of dispatch interface: CommandBarButtonEvents */
#undef INTERFACE
#define INTERFACE CommandBarButtonEvents

DECLARE_INTERFACE_(CommandBarButtonEvents, IDispatch)
{
BEGIN_INTERFACE
#ifndef NO_BASEINTERFACE_FUNCS

    /* IUnknown methods */
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG, AddRef)(THIS) PURE;
    STDMETHOD_(ULONG, Release)(THIS) PURE;

    /* IDispatch methods */
    STDMETHOD(GetTypeInfoCount)(THIS_ UINT FAR* pctinfo) PURE;

    STDMETHOD(GetTypeInfo)(
      THIS_
      UINT itinfo,
      LCID lcid,
      ITypeInfo FAR* FAR* pptinfo) PURE;

    STDMETHOD(GetIDsOfNames)(
      THIS_
      REFIID riid,
      OLECHAR FAR* FAR* rgszNames,
      UINT cNames,
      LCID lcid,
      DISPID FAR* rgdispid) PURE;

    STDMETHOD(Invoke)(
      THIS_
      DISPID dispidMember,
      REFIID riid,
      LCID lcid,
      WORD wFlags,
      DISPPARAMS FAR* pdispparams,
      VARIANT FAR* pvarResult,
      EXCEPINFO FAR* pexcepinfo,
      UINT FAR* puArgErr) PURE;
#endif

/* Capable of dispatching all the methods of interface ICommandBarButtonEvents */
};

DEFINE_GUID(CLSID_CommandBarButton,0x55F88891L,0x7708,0x11D1,0xAC,0xEB,0x00,0x60,0x08,0x96,0x1D,0xA5);

#ifdef __cplusplus
class MsoCommandBarButton;
#endif

typedef enum {
    msoScreenSize544x376 = 0,
    msoScreenSize640x480,
    msoScreenSize720x512,
    msoScreenSize800x600,
    msoScreenSize1024x768,
    msoScreenSize1152x882,
    msoScreenSize1152x900,
    msoScreenSize1280x1024,
    msoScreenSize1600x1200,
    msoScreenSize1800x1440,
    msoScreenSize1920x1200
} MsoScreenSize;

typedef enum {
    msoCharacterSetArabic = 1,
    msoCharacterSetCyrillic,
    msoCharacterSetEnglishWesternEuropeanOtherLatinScript,
    msoCharacterSetGreek,
    msoCharacterSetHebrew,
    msoCharacterSetJapanese,
    msoCharacterSetKorean,
    msoCharacterSetMultilingualUnicode,
    msoCharacterSetSimplifiedChinese,
    msoCharacterSetThai,
    msoCharacterSetTraditionalChinese,
    msoCharacterSetVietnamese
} MsoCharacterSet;

typedef enum {
    msoEncodingThai = 874,
    msoEncodingJapaneseShiftJIS = 932,
    msoEncodingSimplifiedChineseGBK = 936,
    msoEncodingKorean = 949,
    msoEncodingTraditionalChineseBig5 = 950,
    msoEncodingUnicodeLittleEndian = 1200,
    msoEncodingUnicodeBigEndian = 1201,
    msoEncodingCentralEuropean = 1250,
    msoEncodingCyrillic = 1251,
    msoEncodingWestern = 1252,
    msoEncodingGreek = 1253,
    msoEncodingTurkish = 1254,
    msoEncodingHebrew = 1255,
    msoEncodingArabic = 1256,
    msoEncodingBaltic = 1257,
    msoEncodingVietnamese = 1258,
    msoEncodingAutoDetect = 50001,
    msoEncodingJapaneseAutoDetect = 50932,
    msoEncodingSimplifiedChineseAutoDetect = 50936,
    msoEncodingKoreanAutoDetect = 50949,
    msoEncodingTraditionalChineseAutoDetect = 50950,
    msoEncodingCyrillicAutoDetect = 51251,
    msoEncodingGreekAutoDetect = 51253,
    msoEncodingArabicAutoDetect = 51256,
    msoEncodingISO88591Latin1 = 28591,
    msoEncodingISO88592CentralEurope = 28592,
    msoEncodingISO88593Latin3 = 28593,
    msoEncodingISO88594Baltic = 28594,
    msoEncodingISO88595Cyrillic = 28595,
    msoEncodingISO88596Arabic = 28596,
    msoEncodingISO88597Greek = 28597,
    msoEncodingISO88598Hebrew = 28598,
    msoEncodingISO88599Turkish = 28599,
    msoEncodingISO885915Latin9 = 28605,
    msoEncodingISO2022JPNoHalfwidthKatakana = 50220,
    msoEncodingISO2022JPJISX02021984 = 50221,
    msoEncodingISO2022JPJISX02011989 = 50222,
    msoEncodingISO2022KR = 50225,
    msoEncodingISO2022CNTraditionalChinese = 50227,
    msoEncodingISO2022CNSimplifiedChinese = 50229,
    msoEncodingMacRoman = 10000,
    msoEncodingMacJapanese = 10001,
    msoEncodingMacTraditionalChineseBig5 = 10002,
    msoEncodingMacKorean = 10003,
    msoEncodingMacArabic = 10004,
    msoEncodingMacHebrew = 10005,
    msoEncodingMacGreek1 = 10006,
    msoEncodingMacCyrillic = 10007,
    msoEncodingMacSimplifiedChineseGB2312 = 10008,
    msoEncodingMacRomania = 10010,
    msoEncodingMacUkraine = 10017,
    msoEncodingMacLatin2 = 10029,
    msoEncodingMacIcelandic = 10079,
    msoEncodingMacTurkish = 10081,
    msoEncodingMacCroatia = 10082,
    msoEncodingEBCDICUSCanada = 37,
    msoEncodingEBCDICInternational = 500,
    msoEncodingEBCDICMultilingualROECELatin2 = 870,
    msoEncodingEBCDICGreekModern = 875,
    msoEncodingEBCDICTurkishLatin5 = 1026,
    msoEncodingEBCDICGermany = 20273,
    msoEncodingEBCDICDenmarkNorway = 20277,
    msoEncodingEBCDICFinlandSweden = 20278,
    msoEncodingEBCDICItaly = 20280,
    msoEncodingEBCDICLatinAmericaSpain = 20284,
    msoEncodingEBCDICUnitedKingdom = 20285,
    msoEncodingEBCDICJapaneseKatakanaExtended = 20290,
    msoEncodingEBCDICFrance = 20297,
    msoEncodingEBCDICArabic = 20420,
    msoEncodingEBCDICGreek = 20423,
    msoEncodingEBCDICHebrew = 20424,
    msoEncodingEBCDICKoreanExtended = 20833,
    msoEncodingEBCDICThai = 20838,
    msoEncodingEBCDICIcelandic = 20871,
    msoEncodingEBCDICTurkish = 20905,
    msoEncodingEBCDICRussian = 20880,
    msoEncodingEBCDICSerbianBulgarian = 21025,
    msoEncodingEBCDICJapaneseKatakanaExtendedAndJapanese = 50930,
    msoEncodingEBCDICUSCanadaAndJapanese = 50931,
    msoEncodingEBCDICKoreanExtendedAndKorean = 50933,
    msoEncodingEBCDICSimplifiedChineseExtendedAndSimplifiedChinese = 50935,
    msoEncodingEBCDICUSCanadaAndTraditionalChinese = 50937,
    msoEncodingEBCDICJapaneseLatinExtendedAndJapanese = 50939,
    msoEncodingOEMUnitedStates = 437,
    msoEncodingOEMGreek437G = 737,
    msoEncodingOEMBaltic = 775,
    msoEncodingOEMMultilingualLatinI = 850,
    msoEncodingOEMMultilingualLatinII = 852,
    msoEncodingOEMCyrillic = 855,
    msoEncodingOEMTurkish = 857,
    msoEncodingOEMPortuguese = 860,
    msoEncodingOEMIcelandic = 861,
    msoEncodingOEMHebrew = 862,
    msoEncodingOEMCanadianFrench = 863,
    msoEncodingOEMArabic = 864,
    msoEncodingOEMNordic = 865,
    msoEncodingOEMCyrillicII = 866,
    msoEncodingOEMModernGreek = 869,
    msoEncodingEUCJapanese = 51932,
    msoEncodingEUCChineseSimplifiedChinese = 51936,
    msoEncodingEUCKorean = 51949,
    msoEncodingEUCTaiwaneseTraditionalChinese = 51950,
    msoEncodingISCIIDevanagari = 57002,
    msoEncodingISCIIBengali = 57003,
    msoEncodingISCIITamil = 57004,
    msoEncodingISCIITelugu = 57005,
    msoEncodingISCIIAssamese = 57006,
    msoEncodingISCIIOriya = 57007,
    msoEncodingISCIIKannada = 57008,
    msoEncodingISCIIMalayalam = 57009,
    msoEncodingISCIIGujarati = 57010,
    msoEncodingISCIIPunjabi = 57011,
    msoEncodingArabicASMO = 708,
    msoEncodingArabicTransparentASMO = 720,
    msoEncodingKoreanJohab = 1361,
    msoEncodingTaiwanCNS = 20000,
    msoEncodingTaiwanTCA = 20001,
    msoEncodingTaiwanEten = 20002,
    msoEncodingTaiwanIBM5550 = 20003,
    msoEncodingTaiwanTeleText = 20004,
    msoEncodingTaiwanWang = 20005,
    msoEncodingIA5IRV = 20105,
    msoEncodingIA5German = 20106,
    msoEncodingIA5Swedish = 20107,
    msoEncodingIA5Norwegian = 20108,
    msoEncodingUSASCII = 20127,
    msoEncodingT61 = 20261,
    msoEncodingISO6937NonSpacingAccent = 20269,
    msoEncodingKOI8R = 20866,
    msoEncodingExtAlphaLowercase = 21027,
    msoEncodingKOI8U = 21866,
    msoEncodingEuropa3 = 29001,
    msoEncodingHZGBSimplifiedChinese = 52936,
    msoEncodingUTF7 = 65000,
    msoEncodingUTF8 = 65001
} MsoEncoding;

DEFINE_GUID(IID_WebPageFont,0x000C0913L,0x0000,0x0000,0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46);

/* Definition of interface: WebPageFont */
#undef INTERFACE
#define INTERFACE WebPageFont

DECLARE_INTERFACE_(WebPageFont, _IMsoDispObj)
{
BEGIN_INTERFACE
#ifndef NO_BASEINTERFACE_FUNCS

    /* IUnknown methods */
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG, AddRef)(THIS) PURE;
    STDMETHOD_(ULONG, Release)(THIS) PURE;

    /* IDispatch methods */
    STDMETHOD(GetTypeInfoCount)(THIS_ UINT FAR* pctinfo) PURE;

    STDMETHOD(GetTypeInfo)(
      THIS_
      UINT itinfo,
      LCID lcid,
      ITypeInfo FAR* FAR* pptinfo) PURE;

    STDMETHOD(GetIDsOfNames)(
      THIS_
      REFIID riid,
      OLECHAR FAR* FAR* rgszNames,
      UINT cNames,
      LCID lcid,
      DISPID FAR* rgdispid) PURE;

    STDMETHOD(Invoke)(
      THIS_
      DISPID dispidMember,
      REFIID riid,
      LCID lcid,
      WORD wFlags,
      DISPPARAMS FAR* pdispparams,
      VARIANT FAR* pvarResult,
      EXCEPINFO FAR* pexcepinfo,
      UINT FAR* puArgErr) PURE;

    /* _IMsoDispObj methods */
    STDMETHOD(get_Application)(THIS_ IDispatch * FAR* ppidisp) PURE;
    STDMETHOD(get_Creator)(THIS_ long FAR* plCreator) PURE;
#endif

    /* WebPageFont methods */
    STDMETHOD(get_ProportionalFont)(THIS_ BSTR FAR* pstr) PURE;
    STDMETHOD(put_ProportionalFont)(THIS_ BSTR str) PURE;
    STDMETHOD(get_ProportionalFontSize)(THIS_ float FAR* pf) PURE;
    STDMETHOD(put_ProportionalFontSize)(THIS_ float f) PURE;
    STDMETHOD(get_FixedWidthFont)(THIS_ BSTR FAR* pstr) PURE;
    STDMETHOD(put_FixedWidthFont)(THIS_ BSTR str) PURE;
    STDMETHOD(get_FixedWidthFontSize)(THIS_ float FAR* pf) PURE;
    STDMETHOD(put_FixedWidthFontSize)(THIS_ float f) PURE;
};

DEFINE_GUID(IID_WebPageFonts,0x000C0914L,0x0000,0x0000,0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46);

/* Definition of interface: WebPageFonts */
#undef INTERFACE
#define INTERFACE WebPageFonts

DECLARE_INTERFACE_(WebPageFonts, _IMsoDispObj)
{
BEGIN_INTERFACE
#ifndef NO_BASEINTERFACE_FUNCS

    /* IUnknown methods */
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG, AddRef)(THIS) PURE;
    STDMETHOD_(ULONG, Release)(THIS) PURE;

    /* IDispatch methods */
    STDMETHOD(GetTypeInfoCount)(THIS_ UINT FAR* pctinfo) PURE;

    STDMETHOD(GetTypeInfo)(
      THIS_
      UINT itinfo,
      LCID lcid,
      ITypeInfo FAR* FAR* pptinfo) PURE;

    STDMETHOD(GetIDsOfNames)(
      THIS_
      REFIID riid,
      OLECHAR FAR* FAR* rgszNames,
      UINT cNames,
      LCID lcid,
      DISPID FAR* rgdispid) PURE;

    STDMETHOD(Invoke)(
      THIS_
      DISPID dispidMember,
      REFIID riid,
      LCID lcid,
      WORD wFlags,
      DISPPARAMS FAR* pdispparams,
      VARIANT FAR* pvarResult,
      EXCEPINFO FAR* pexcepinfo,
      UINT FAR* puArgErr) PURE;

    /* _IMsoDispObj methods */
    STDMETHOD(get_Application)(THIS_ IDispatch * FAR* ppidisp) PURE;
    STDMETHOD(get_Creator)(THIS_ long FAR* plCreator) PURE;
#endif

    /* WebPageFonts methods */
    STDMETHOD(get_Count)(THIS_ int FAR* Count) PURE;
    STDMETHOD(get_Item)(THIS_ MsoCharacterSet Index, WebPageFont FAR* FAR* Item) PURE;
    STDMETHOD(get__NewEnum)(THIS_ IUnknown * FAR* _NewEnum) PURE;
};

typedef enum {
    msoHTMLProjectOpenSourceView = 1,
    msoHTMLProjectOpenTextView = 2
} MsoHTMLProjectOpen;

typedef enum {
    msoHTMLProjectStateDocumentLocked = 1,
    msoHTMLProjectStateProjectLocked = 2,
    msoHTMLProjectStateDocumentProjectUnlocked = 3
} MsoHTMLProjectState;

DEFINE_GUID(IID_HTMLProjectItem,0x000C0358L,0x0000,0x0000,0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46);

/* Definition of interface: HTMLProjectItem */
#undef INTERFACE
#define INTERFACE HTMLProjectItem

DECLARE_INTERFACE_(HTMLProjectItem, _IMsoDispObj)
{
BEGIN_INTERFACE
#ifndef NO_BASEINTERFACE_FUNCS

    /* IUnknown methods */
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG, AddRef)(THIS) PURE;
    STDMETHOD_(ULONG, Release)(THIS) PURE;

    /* IDispatch methods */
    STDMETHOD(GetTypeInfoCount)(THIS_ UINT FAR* pctinfo) PURE;

    STDMETHOD(GetTypeInfo)(
      THIS_
      UINT itinfo,
      LCID lcid,
      ITypeInfo FAR* FAR* pptinfo) PURE;

    STDMETHOD(GetIDsOfNames)(
      THIS_
      REFIID riid,
      OLECHAR FAR* FAR* rgszNames,
      UINT cNames,
      LCID lcid,
      DISPID FAR* rgdispid) PURE;

    STDMETHOD(Invoke)(
      THIS_
      DISPID dispidMember,
      REFIID riid,
      LCID lcid,
      WORD wFlags,
      DISPPARAMS FAR* pdispparams,
      VARIANT FAR* pvarResult,
      EXCEPINFO FAR* pexcepinfo,
      UINT FAR* puArgErr) PURE;

    /* _IMsoDispObj methods */
    STDMETHOD(get_Application)(THIS_ IDispatch * FAR* ppidisp) PURE;
    STDMETHOD(get_Creator)(THIS_ long FAR* plCreator) PURE;
#endif

    /* HTMLProjectItem methods */
    STDMETHOD(get_Name)(THIS_ BSTR FAR* RetValue) PURE;
    STDMETHOD(get_IsOpen)(THIS_ VARIANT_BOOL FAR* RetValue) PURE;
    STDMETHOD(LoadFromFile)(THIS_ BSTR FileName) PURE;
    STDMETHOD(Open)(THIS_ MsoHTMLProjectOpen OpenKind) PURE;
    STDMETHOD(SaveCopyAs)(THIS_ BSTR FileName) PURE;
    STDMETHOD(get_Text)(THIS_ BSTR FAR* Text) PURE;
    STDMETHOD(put_Text)(THIS_ BSTR Text) PURE;
    STDMETHOD(get_Parent)(THIS_ IDispatch * FAR* ppidisp) PURE;
};

DEFINE_GUID(IID_HTMLProjectItems,0x000C0357L,0x0000,0x0000,0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46);

/* Definition of interface: HTMLProjectItems */
#undef INTERFACE
#define INTERFACE HTMLProjectItems

DECLARE_INTERFACE_(HTMLProjectItems, _IMsoDispObj)
{
BEGIN_INTERFACE
#ifndef NO_BASEINTERFACE_FUNCS

    /* IUnknown methods */
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG, AddRef)(THIS) PURE;
    STDMETHOD_(ULONG, Release)(THIS) PURE;

    /* IDispatch methods */
    STDMETHOD(GetTypeInfoCount)(THIS_ UINT FAR* pctinfo) PURE;

    STDMETHOD(GetTypeInfo)(
      THIS_
      UINT itinfo,
      LCID lcid,
      ITypeInfo FAR* FAR* pptinfo) PURE;

    STDMETHOD(GetIDsOfNames)(
      THIS_
      REFIID riid,
      OLECHAR FAR* FAR* rgszNames,
      UINT cNames,
      LCID lcid,
      DISPID FAR* rgdispid) PURE;

    STDMETHOD(Invoke)(
      THIS_
      DISPID dispidMember,
      REFIID riid,
      LCID lcid,
      WORD wFlags,
      DISPPARAMS FAR* pdispparams,
      VARIANT FAR* pvarResult,
      EXCEPINFO FAR* pexcepinfo,
      UINT FAR* puArgErr) PURE;

    /* _IMsoDispObj methods */
    STDMETHOD(get_Application)(THIS_ IDispatch * FAR* ppidisp) PURE;
    STDMETHOD(get_Creator)(THIS_ long FAR* plCreator) PURE;
#endif

    /* HTMLProjectItems methods */
    STDMETHOD(Item)(THIS_ VARIANT FAR* Index, HTMLProjectItem FAR* FAR* RetValue) PURE;
    STDMETHOD(get_Count)(THIS_ long FAR* RetValue) PURE;
    STDMETHOD(get__NewEnum)(THIS_ IUnknown * FAR* RetValue) PURE;
    STDMETHOD(get_Parent)(THIS_ IDispatch * FAR* ppidisp) PURE;
};

DEFINE_GUID(IID_HTMLProject,0x000C0356L,0x0000,0x0000,0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46);

/* Definition of interface: HTMLProject */
#undef INTERFACE
#define INTERFACE HTMLProject

DECLARE_INTERFACE_(HTMLProject, _IMsoDispObj)
{
BEGIN_INTERFACE
#ifndef NO_BASEINTERFACE_FUNCS

    /* IUnknown methods */
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG, AddRef)(THIS) PURE;
    STDMETHOD_(ULONG, Release)(THIS) PURE;

    /* IDispatch methods */
    STDMETHOD(GetTypeInfoCount)(THIS_ UINT FAR* pctinfo) PURE;

    STDMETHOD(GetTypeInfo)(
      THIS_
      UINT itinfo,
      LCID lcid,
      ITypeInfo FAR* FAR* pptinfo) PURE;

    STDMETHOD(GetIDsOfNames)(
      THIS_
      REFIID riid,
      OLECHAR FAR* FAR* rgszNames,
      UINT cNames,
      LCID lcid,
      DISPID FAR* rgdispid) PURE;

    STDMETHOD(Invoke)(
      THIS_
      DISPID dispidMember,
      REFIID riid,
      LCID lcid,
      WORD wFlags,
      DISPPARAMS FAR* pdispparams,
      VARIANT FAR* pvarResult,
      EXCEPINFO FAR* pexcepinfo,
      UINT FAR* puArgErr) PURE;

    /* _IMsoDispObj methods */
    STDMETHOD(get_Application)(THIS_ IDispatch * FAR* ppidisp) PURE;
    STDMETHOD(get_Creator)(THIS_ long FAR* plCreator) PURE;
#endif

    /* HTMLProject methods */
    STDMETHOD(get_State)(THIS_ MsoHTMLProjectState FAR* State) PURE;
    STDMETHOD(RefreshProject)(THIS_ VARIANT_BOOL Refresh) PURE;
    STDMETHOD(RefreshDocument)(THIS_ VARIANT_BOOL Refresh) PURE;
    STDMETHOD(get_HTMLProjectItems)(THIS_ HTMLProjectItems FAR* FAR* HTMLProjectItems) PURE;
    STDMETHOD(get_Parent)(THIS_ IDispatch * FAR* ppidisp) PURE;
    STDMETHOD(Open)(THIS_ MsoHTMLProjectOpen OpenKind) PURE;
};

DEFINE_GUID(IID_MsoDebugOptions,0x000C035AL,0x0000,0x0000,0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46);

/* Definition of interface: MsoDebugOptions */
#undef INTERFACE
#define INTERFACE MsoDebugOptions

DECLARE_INTERFACE_(MsoDebugOptions, _IMsoDispObj)
{
BEGIN_INTERFACE
#ifndef NO_BASEINTERFACE_FUNCS

    /* IUnknown methods */
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG, AddRef)(THIS) PURE;
    STDMETHOD_(ULONG, Release)(THIS) PURE;

    /* IDispatch methods */
    STDMETHOD(GetTypeInfoCount)(THIS_ UINT FAR* pctinfo) PURE;

    STDMETHOD(GetTypeInfo)(
      THIS_
      UINT itinfo,
      LCID lcid,
      ITypeInfo FAR* FAR* pptinfo) PURE;

    STDMETHOD(GetIDsOfNames)(
      THIS_
      REFIID riid,
      OLECHAR FAR* FAR* rgszNames,
      UINT cNames,
      LCID lcid,
      DISPID FAR* rgdispid) PURE;

    STDMETHOD(Invoke)(
      THIS_
      DISPID dispidMember,
      REFIID riid,
      LCID lcid,
      WORD wFlags,
      DISPPARAMS FAR* pdispparams,
      VARIANT FAR* pvarResult,
      EXCEPINFO FAR* pexcepinfo,
      UINT FAR* puArgErr) PURE;

    /* _IMsoDispObj methods */
    STDMETHOD(get_Application)(THIS_ IDispatch * FAR* ppidisp) PURE;
    STDMETHOD(get_Creator)(THIS_ long FAR* plCreator) PURE;
#endif

    /* MsoDebugOptions methods */
    STDMETHOD(get_FeatureReports)(THIS_ int FAR* puintFeatureReports) PURE;
    STDMETHOD(put_FeatureReports)(THIS_ int uintFeatureReports) PURE;
    STDMETHOD(get_OutputToDebugger)(THIS_ VARIANT_BOOL FAR* pvarfOutputToDebugger) PURE;
    STDMETHOD(put_OutputToDebugger)(THIS_ VARIANT_BOOL varfOutputToDebugger) PURE;
    STDMETHOD(get_OutputToFile)(THIS_ VARIANT_BOOL FAR* pvarfOutputToFile) PURE;
    STDMETHOD(put_OutputToFile)(THIS_ VARIANT_BOOL varfOutputToFile) PURE;
    STDMETHOD(get_OutputToMessageBox)(THIS_ VARIANT_BOOL FAR* pvarfOutputToMessageBox) PURE;
    STDMETHOD(put_OutputToMessageBox)(THIS_ VARIANT_BOOL varfOutputToMessageBox) PURE;
};

typedef enum {
    msoFileDialogOpen = 1,
    msoFileDialogSaveAs,
    msoFileDialogFilePicker,
    msoFileDialogFolderPicker
} MsoFileDialogType;

typedef enum {
    msoFileDialogViewList = 1,
    msoFileDialogViewDetails,
    msoFileDialogViewProperties,
    msoFileDialogViewPreview,
    msoFileDialogViewThumbnail,
    msoFileDialogViewLargeIcons,
    msoFileDialogViewSmallIcons,
    msoFileDialogViewWebView
} MsoFileDialogView;

DEFINE_GUID(IID_FileDialogSelectedItems,0x000C0363L,0x0000,0x0000,0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46);

/* Definition of interface: FileDialogSelectedItems */
#undef INTERFACE
#define INTERFACE FileDialogSelectedItems

DECLARE_INTERFACE_(FileDialogSelectedItems, _IMsoDispObj)
{
BEGIN_INTERFACE
#ifndef NO_BASEINTERFACE_FUNCS

    /* IUnknown methods */
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG, AddRef)(THIS) PURE;
    STDMETHOD_(ULONG, Release)(THIS) PURE;

    /* IDispatch methods */
    STDMETHOD(GetTypeInfoCount)(THIS_ UINT FAR* pctinfo) PURE;

    STDMETHOD(GetTypeInfo)(
      THIS_
      UINT itinfo,
      LCID lcid,
      ITypeInfo FAR* FAR* pptinfo) PURE;

    STDMETHOD(GetIDsOfNames)(
      THIS_
      REFIID riid,
      OLECHAR FAR* FAR* rgszNames,
      UINT cNames,
      LCID lcid,
      DISPID FAR* rgdispid) PURE;

    STDMETHOD(Invoke)(
      THIS_
      DISPID dispidMember,
      REFIID riid,
      LCID lcid,
      WORD wFlags,
      DISPPARAMS FAR* pdispparams,
      VARIANT FAR* pvarResult,
      EXCEPINFO FAR* pexcepinfo,
      UINT FAR* puArgErr) PURE;

    /* _IMsoDispObj methods */
    STDMETHOD(get_Application)(THIS_ IDispatch * FAR* ppidisp) PURE;
    STDMETHOD(get_Creator)(THIS_ long FAR* plCreator) PURE;
#endif

    /* FileDialogSelectedItems methods */
    STDMETHOD(get_Parent)(THIS_ IDispatch * FAR* Parent) PURE;
    STDMETHOD(get__NewEnum)(THIS_ IUnknown * FAR* ppienum) PURE;
    STDMETHOD(get_Count)(THIS_ long FAR* pcFiles) PURE;
    STDMETHOD(Item)(THIS_ int Index, BSTR FAR* Item) PURE;
};

DEFINE_GUID(IID_FileDialogFilter,0x000C0364L,0x0000,0x0000,0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46);

/* Definition of interface: FileDialogFilter */
#undef INTERFACE
#define INTERFACE FileDialogFilter

DECLARE_INTERFACE_(FileDialogFilter, _IMsoDispObj)
{
BEGIN_INTERFACE
#ifndef NO_BASEINTERFACE_FUNCS

    /* IUnknown methods */
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG, AddRef)(THIS) PURE;
    STDMETHOD_(ULONG, Release)(THIS) PURE;

    /* IDispatch methods */
    STDMETHOD(GetTypeInfoCount)(THIS_ UINT FAR* pctinfo) PURE;

    STDMETHOD(GetTypeInfo)(
      THIS_
      UINT itinfo,
      LCID lcid,
      ITypeInfo FAR* FAR* pptinfo) PURE;

    STDMETHOD(GetIDsOfNames)(
      THIS_
      REFIID riid,
      OLECHAR FAR* FAR* rgszNames,
      UINT cNames,
      LCID lcid,
      DISPID FAR* rgdispid) PURE;

    STDMETHOD(Invoke)(
      THIS_
      DISPID dispidMember,
      REFIID riid,
      LCID lcid,
      WORD wFlags,
      DISPPARAMS FAR* pdispparams,
      VARIANT FAR* pvarResult,
      EXCEPINFO FAR* pexcepinfo,
      UINT FAR* puArgErr) PURE;

    /* _IMsoDispObj methods */
    STDMETHOD(get_Application)(THIS_ IDispatch * FAR* ppidisp) PURE;
    STDMETHOD(get_Creator)(THIS_ long FAR* plCreator) PURE;
#endif

    /* FileDialogFilter methods */
    STDMETHOD(get_Parent)(THIS_ IDispatch * FAR* Parent) PURE;
    STDMETHOD(get_Extensions)(THIS_ BSTR FAR* Extensions) PURE;
    STDMETHOD(get_Description)(THIS_ BSTR FAR* Description) PURE;
};

DEFINE_GUID(IID_FileDialogFilters,0x000C0365L,0x0000,0x0000,0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46);

/* Definition of interface: FileDialogFilters */
#undef INTERFACE
#define INTERFACE FileDialogFilters

DECLARE_INTERFACE_(FileDialogFilters, _IMsoDispObj)
{
BEGIN_INTERFACE
#ifndef NO_BASEINTERFACE_FUNCS

    /* IUnknown methods */
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG, AddRef)(THIS) PURE;
    STDMETHOD_(ULONG, Release)(THIS) PURE;

    /* IDispatch methods */
    STDMETHOD(GetTypeInfoCount)(THIS_ UINT FAR* pctinfo) PURE;

    STDMETHOD(GetTypeInfo)(
      THIS_
      UINT itinfo,
      LCID lcid,
      ITypeInfo FAR* FAR* pptinfo) PURE;

    STDMETHOD(GetIDsOfNames)(
      THIS_
      REFIID riid,
      OLECHAR FAR* FAR* rgszNames,
      UINT cNames,
      LCID lcid,
      DISPID FAR* rgdispid) PURE;

    STDMETHOD(Invoke)(
      THIS_
      DISPID dispidMember,
      REFIID riid,
      LCID lcid,
      WORD wFlags,
      DISPPARAMS FAR* pdispparams,
      VARIANT FAR* pvarResult,
      EXCEPINFO FAR* pexcepinfo,
      UINT FAR* puArgErr) PURE;

    /* _IMsoDispObj methods */
    STDMETHOD(get_Application)(THIS_ IDispatch * FAR* ppidisp) PURE;
    STDMETHOD(get_Creator)(THIS_ long FAR* plCreator) PURE;
#endif

    /* FileDialogFilters methods */
    STDMETHOD(get_Parent)(THIS_ IDispatch * FAR* Parent) PURE;
    STDMETHOD(get__NewEnum)(THIS_ IUnknown * FAR* ppienum) PURE;
    STDMETHOD(get_Count)(THIS_ long FAR* pcFilters) PURE;
    STDMETHOD(Item)(THIS_ int Index, FileDialogFilter FAR* FAR* Item) PURE;
    STDMETHOD(Delete)(THIS_ VARIANT filter) PURE;
    STDMETHOD(Clear)(THIS) PURE;
    STDMETHOD(Add)(THIS_ BSTR Description, BSTR Extensions, VARIANT Position, FileDialogFilter FAR* FAR* Add) PURE;
};

DEFINE_GUID(IID_FileDialog,0x000C0362L,0x0000,0x0000,0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46);

/* Definition of interface: FileDialog */
#undef INTERFACE
#define INTERFACE FileDialog

DECLARE_INTERFACE_(FileDialog, _IMsoDispObj)
{
BEGIN_INTERFACE
#ifndef NO_BASEINTERFACE_FUNCS

    /* IUnknown methods */
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG, AddRef)(THIS) PURE;
    STDMETHOD_(ULONG, Release)(THIS) PURE;

    /* IDispatch methods */
    STDMETHOD(GetTypeInfoCount)(THIS_ UINT FAR* pctinfo) PURE;

    STDMETHOD(GetTypeInfo)(
      THIS_
      UINT itinfo,
      LCID lcid,
      ITypeInfo FAR* FAR* pptinfo) PURE;

    STDMETHOD(GetIDsOfNames)(
      THIS_
      REFIID riid,
      OLECHAR FAR* FAR* rgszNames,
      UINT cNames,
      LCID lcid,
      DISPID FAR* rgdispid) PURE;

    STDMETHOD(Invoke)(
      THIS_
      DISPID dispidMember,
      REFIID riid,
      LCID lcid,
      WORD wFlags,
      DISPPARAMS FAR* pdispparams,
      VARIANT FAR* pvarResult,
      EXCEPINFO FAR* pexcepinfo,
      UINT FAR* puArgErr) PURE;

    /* _IMsoDispObj methods */
    STDMETHOD(get_Application)(THIS_ IDispatch * FAR* ppidisp) PURE;
    STDMETHOD(get_Creator)(THIS_ long FAR* plCreator) PURE;
#endif

    /* FileDialog methods */
    STDMETHOD(get_Parent)(THIS_ IDispatch * FAR* Parent) PURE;
    STDMETHOD(get_Filters)(THIS_ FileDialogFilters FAR* FAR* Filters) PURE;
    STDMETHOD(get_FilterIndex)(THIS_ int FAR* FilterIndex) PURE;
    STDMETHOD(put_FilterIndex)(THIS_ int FilterIndex) PURE;
    STDMETHOD(get_Title)(THIS_ BSTR FAR* Title) PURE;
    STDMETHOD(put_Title)(THIS_ BSTR Title) PURE;
    STDMETHOD(get_ButtonName)(THIS_ BSTR FAR* ButtonName) PURE;
    STDMETHOD(put_ButtonName)(THIS_ BSTR ButtonName) PURE;
    STDMETHOD(get_AllowMultiSelect)(THIS_ VARIANT_BOOL FAR* pvarfAllowMultiSelect) PURE;
    STDMETHOD(put_AllowMultiSelect)(THIS_ VARIANT_BOOL varfAllowMultiSelect) PURE;
    STDMETHOD(get_InitialView)(THIS_ MsoFileDialogView FAR* pinitialview) PURE;
    STDMETHOD(put_InitialView)(THIS_ MsoFileDialogView initialview) PURE;
    STDMETHOD(get_InitialFileName)(THIS_ BSTR FAR* InitialFileName) PURE;
    STDMETHOD(put_InitialFileName)(THIS_ BSTR InitialFileName) PURE;
    STDMETHOD(get_SelectedItems)(THIS_ FileDialogSelectedItems FAR* FAR* Files) PURE;
    STDMETHOD(get_DialogType)(THIS_ MsoFileDialogType FAR* pdialogtype) PURE;
    STDMETHOD(get_Item)(THIS_ BSTR FAR* Name) PURE;
    STDMETHOD(Show)(THIS_ int FAR* rval) PURE;
    STDMETHOD(Execute)(THIS) PURE;
};

typedef enum {
    msoAutomationSecurityLow = 1,
    msoAutomationSecurityByUI = 2,
    msoAutomationSecurityForceDisable = 3
} MsoAutomationSecurity;

DEFINE_GUID(IID_SignatureSet,0x000C0410L,0x0000,0x0000,0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46);

/* Definition of interface: SignatureSet */
#undef INTERFACE
#define INTERFACE SignatureSet

DECLARE_INTERFACE_(SignatureSet, _IMsoDispObj)
{
BEGIN_INTERFACE
#ifndef NO_BASEINTERFACE_FUNCS

    /* IUnknown methods */
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG, AddRef)(THIS) PURE;
    STDMETHOD_(ULONG, Release)(THIS) PURE;

    /* IDispatch methods */
    STDMETHOD(GetTypeInfoCount)(THIS_ UINT FAR* pctinfo) PURE;

    STDMETHOD(GetTypeInfo)(
      THIS_
      UINT itinfo,
      LCID lcid,
      ITypeInfo FAR* FAR* pptinfo) PURE;

    STDMETHOD(GetIDsOfNames)(
      THIS_
      REFIID riid,
      OLECHAR FAR* FAR* rgszNames,
      UINT cNames,
      LCID lcid,
      DISPID FAR* rgdispid) PURE;

    STDMETHOD(Invoke)(
      THIS_
      DISPID dispidMember,
      REFIID riid,
      LCID lcid,
      WORD wFlags,
      DISPPARAMS FAR* pdispparams,
      VARIANT FAR* pvarResult,
      EXCEPINFO FAR* pexcepinfo,
      UINT FAR* puArgErr) PURE;

    /* _IMsoDispObj methods */
    STDMETHOD(get_Application)(THIS_ IDispatch * FAR* ppidisp) PURE;
    STDMETHOD(get_Creator)(THIS_ long FAR* plCreator) PURE;
#endif

    /* SignatureSet methods */
    STDMETHOD(get__NewEnum)(THIS_ IUnknown * FAR* ppienum) PURE;
    STDMETHOD(get_Count)(THIS_ int FAR* pcSig) PURE;
    STDMETHOD(get_Item)(THIS_ int iSig, Signature FAR* FAR* ppidisp) PURE;
    STDMETHOD(Add)(THIS_ Signature FAR* FAR* ppidisp) PURE;
    STDMETHOD(Commit)(THIS) PURE;
    STDMETHOD(get_Parent)(THIS_ IDispatch * FAR* ppidisp) PURE;
};

DEFINE_GUID(IID_Signature,0x000C0411L,0x0000,0x0000,0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46);

/* Definition of interface: Signature */
#undef INTERFACE
#define INTERFACE Signature

DECLARE_INTERFACE_(Signature, _IMsoDispObj)
{
BEGIN_INTERFACE
#ifndef NO_BASEINTERFACE_FUNCS

    /* IUnknown methods */
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG, AddRef)(THIS) PURE;
    STDMETHOD_(ULONG, Release)(THIS) PURE;

    /* IDispatch methods */
    STDMETHOD(GetTypeInfoCount)(THIS_ UINT FAR* pctinfo) PURE;

    STDMETHOD(GetTypeInfo)(
      THIS_
      UINT itinfo,
      LCID lcid,
      ITypeInfo FAR* FAR* pptinfo) PURE;

    STDMETHOD(GetIDsOfNames)(
      THIS_
      REFIID riid,
      OLECHAR FAR* FAR* rgszNames,
      UINT cNames,
      LCID lcid,
      DISPID FAR* rgdispid) PURE;

    STDMETHOD(Invoke)(
      THIS_
      DISPID dispidMember,
      REFIID riid,
      LCID lcid,
      WORD wFlags,
      DISPPARAMS FAR* pdispparams,
      VARIANT FAR* pvarResult,
      EXCEPINFO FAR* pexcepinfo,
      UINT FAR* puArgErr) PURE;

    /* _IMsoDispObj methods */
    STDMETHOD(get_Application)(THIS_ IDispatch * FAR* ppidisp) PURE;
    STDMETHOD(get_Creator)(THIS_ long FAR* plCreator) PURE;
#endif

    /* Signature methods */
    STDMETHOD(get_Signer)(THIS_ BSTR FAR* pbstr) PURE;
    STDMETHOD(get_Issuer)(THIS_ BSTR FAR* pbstr) PURE;
    STDMETHOD(get_ExpireDate)(THIS_ VARIANT FAR* pvarDate) PURE;
    STDMETHOD(get_IsValid)(THIS_ VARIANT_BOOL FAR* pfValid) PURE;
    STDMETHOD(get_AttachCertificate)(THIS_ VARIANT_BOOL FAR* pfAttach) PURE;
    STDMETHOD(put_AttachCertificate)(THIS_ VARIANT_BOOL fAttach) PURE;
    STDMETHOD(Delete)(THIS) PURE;
    STDMETHOD(get_Parent)(THIS_ IDispatch * FAR* ppidisp) PURE;
    STDMETHOD(get_IsCertificateExpired)(THIS_ VARIANT_BOOL FAR* pfExpired) PURE;
    STDMETHOD(get_IsCertificateRevoked)(THIS_ VARIANT_BOOL FAR* pfExpired) PURE;
    STDMETHOD(get_SignDate)(THIS_ VARIANT FAR* pvarDate) PURE;
};

typedef enum {
    mfPlainText = 1,
    mfHTML = 2,
    mfRTF = 3
} MailFormat;

DEFINE_GUID(IID_IMsoEnvelopeVB,0x000672ACL,0x0000,0x0000,0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46);

/* Definition of interface: IMsoEnvelopeVB */
#undef INTERFACE
#define INTERFACE IMsoEnvelopeVB

DECLARE_INTERFACE_(IMsoEnvelopeVB, IDispatch)
{
BEGIN_INTERFACE
#ifndef NO_BASEINTERFACE_FUNCS

    /* IUnknown methods */
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG, AddRef)(THIS) PURE;
    STDMETHOD_(ULONG, Release)(THIS) PURE;

    /* IDispatch methods */
    STDMETHOD(GetTypeInfoCount)(THIS_ UINT FAR* pctinfo) PURE;

    STDMETHOD(GetTypeInfo)(
      THIS_
      UINT itinfo,
      LCID lcid,
      ITypeInfo FAR* FAR* pptinfo) PURE;

    STDMETHOD(GetIDsOfNames)(
      THIS_
      REFIID riid,
      OLECHAR FAR* FAR* rgszNames,
      UINT cNames,
      LCID lcid,
      DISPID FAR* rgdispid) PURE;

    STDMETHOD(Invoke)(
      THIS_
      DISPID dispidMember,
      REFIID riid,
      LCID lcid,
      WORD wFlags,
      DISPPARAMS FAR* pdispparams,
      VARIANT FAR* pvarResult,
      EXCEPINFO FAR* pexcepinfo,
      UINT FAR* puArgErr) PURE;
#endif

    /* IMsoEnvelopeVB methods */
    STDMETHOD(get_Introduction)(THIS_ BSTR FAR* pbstrIntro) PURE;
    STDMETHOD(put_Introduction)(THIS_ BSTR bstrIntro) PURE;
    STDMETHOD(get_Item)(THIS_ IDispatch * FAR* ppdisp) PURE;
    STDMETHOD(get_Parent)(THIS_ IDispatch * FAR* ppdisp) PURE;
    STDMETHOD(get_CommandBars)(THIS_ IDispatch * FAR* ppdisp) PURE;
};

DEFINE_GUID(DIID_IMsoEnvelopeVBEvents,0x000672ADL,0x0000,0x0000,0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46);

/* Definition of dispatch interface: IMsoEnvelopeVBEvents */
#undef INTERFACE
#define INTERFACE IMsoEnvelopeVBEvents

DECLARE_INTERFACE_(IMsoEnvelopeVBEvents, IDispatch)
{
BEGIN_INTERFACE
#ifndef NO_BASEINTERFACE_FUNCS

    /* IUnknown methods */
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG, AddRef)(THIS) PURE;
    STDMETHOD_(ULONG, Release)(THIS) PURE;

    /* IDispatch methods */
    STDMETHOD(GetTypeInfoCount)(THIS_ UINT FAR* pctinfo) PURE;

    STDMETHOD(GetTypeInfo)(
      THIS_
      UINT itinfo,
      LCID lcid,
      ITypeInfo FAR* FAR* pptinfo) PURE;

    STDMETHOD(GetIDsOfNames)(
      THIS_
      REFIID riid,
      OLECHAR FAR* FAR* rgszNames,
      UINT cNames,
      LCID lcid,
      DISPID FAR* rgdispid) PURE;

    STDMETHOD(Invoke)(
      THIS_
      DISPID dispidMember,
      REFIID riid,
      LCID lcid,
      WORD wFlags,
      DISPPARAMS FAR* pdispparams,
      VARIANT FAR* pvarResult,
      EXCEPINFO FAR* pexcepinfo,
      UINT FAR* puArgErr) PURE;
#endif

    /* IMsoEnvelopeVBEvents methods:
    void EnvelopeShow(void);
    void EnvelopeHide(void);
    */
};

DEFINE_GUID(CLSID_MsoEnvelope,0x0006F01AL,0x0000,0x0000,0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46);

#ifdef __cplusplus
class MsoEnvelope;
#endif

typedef enum tagMsoAlertButtonType {
    msoAlertButtonOK = 0,
    msoAlertButtonOKCancel = 1,
    msoAlertButtonAbortRetryIgnore = 2,
    msoAlertButtonYesNoCancel = 3,
    msoAlertButtonYesNo = 4,
    msoAlertButtonRetryCancel = 5,
    msoAlertButtonYesAllNoCancel = 6
} MsoAlertButtonType;

typedef enum tagMsoAlertIconType {
    msoAlertIconNoIcon = 0,
    msoAlertIconCritical = 1,
    msoAlertIconQuery = 2,
    msoAlertIconWarning = 3,
    msoAlertIconInfo = 4
} MsoAlertIconType;

typedef enum tagMsoAlertDefaultType {
    msoAlertDefaultFirst = 0,
    msoAlertDefaultSecond = 1,
    msoAlertDefaultThird = 2,
    msoAlertDefaultFourth = 3,
    msoAlertDefaultFifth = 4
} MsoAlertDefaultType;

typedef enum tagMsoAlertCancelType {
    msoAlertCancelDefault = -1,
    msoAlertCancelFirst = 0,
    msoAlertCancelSecond = 1,
    msoAlertCancelThird = 2,
    msoAlertCancelFourth = 3,
    msoAlertCancelFifth = 4
} MsoAlertCancelType;

typedef enum {
    msoSearchInMyComputer = 0,
    msoSearchInOutlook = 1,
    msoSearchInMyNetworkPlaces = 2,
    msoSearchInCustom = 3
} MsoSearchIn;

typedef enum {
    msoTargetBrowserV3,
    msoTargetBrowserV4,
    msoTargetBrowserIE4,
    msoTargetBrowserIE5,
    msoTargetBrowserIE6
} MsoTargetBrowser;

DEFINE_GUID(IID_FileTypes,0x000C036CL,0x0000,0x0000,0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46);

/* Definition of interface: FileTypes */
#undef INTERFACE
#define INTERFACE FileTypes

DECLARE_INTERFACE_(FileTypes, _IMsoDispObj)
{
BEGIN_INTERFACE
#ifndef NO_BASEINTERFACE_FUNCS

    /* IUnknown methods */
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG, AddRef)(THIS) PURE;
    STDMETHOD_(ULONG, Release)(THIS) PURE;

    /* IDispatch methods */
    STDMETHOD(GetTypeInfoCount)(THIS_ UINT FAR* pctinfo) PURE;

    STDMETHOD(GetTypeInfo)(
      THIS_
      UINT itinfo,
      LCID lcid,
      ITypeInfo FAR* FAR* pptinfo) PURE;

    STDMETHOD(GetIDsOfNames)(
      THIS_
      REFIID riid,
      OLECHAR FAR* FAR* rgszNames,
      UINT cNames,
      LCID lcid,
      DISPID FAR* rgdispid) PURE;

    STDMETHOD(Invoke)(
      THIS_
      DISPID dispidMember,
      REFIID riid,
      LCID lcid,
      WORD wFlags,
      DISPPARAMS FAR* pdispparams,
      VARIANT FAR* pvarResult,
      EXCEPINFO FAR* pexcepinfo,
      UINT FAR* puArgErr) PURE;

    /* _IMsoDispObj methods */
    STDMETHOD(get_Application)(THIS_ IDispatch * FAR* ppidisp) PURE;
    STDMETHOD(get_Creator)(THIS_ long FAR* plCreator) PURE;
#endif

    /* FileTypes methods */
    STDMETHOD(get_Item)(THIS_ int Index, MsoFileType FAR* MsoFileTypeRet) PURE;
    STDMETHOD(get_Count)(THIS_ int FAR* iCountRetVal) PURE;
    STDMETHOD(Add)(THIS_ MsoFileType FileType) PURE;
    STDMETHOD(Remove)(THIS_ int Index) PURE;
    STDMETHOD(get__NewEnum)(THIS_ IUnknown * FAR* ppunkEnum) PURE;
};

DEFINE_GUID(IID_SearchFolders,0x000C036AL,0x0000,0x0000,0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46);

/* Definition of interface: SearchFolders */
#undef INTERFACE
#define INTERFACE SearchFolders

DECLARE_INTERFACE_(SearchFolders, _IMsoDispObj)
{
BEGIN_INTERFACE
#ifndef NO_BASEINTERFACE_FUNCS

    /* IUnknown methods */
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG, AddRef)(THIS) PURE;
    STDMETHOD_(ULONG, Release)(THIS) PURE;

    /* IDispatch methods */
    STDMETHOD(GetTypeInfoCount)(THIS_ UINT FAR* pctinfo) PURE;

    STDMETHOD(GetTypeInfo)(
      THIS_
      UINT itinfo,
      LCID lcid,
      ITypeInfo FAR* FAR* pptinfo) PURE;

    STDMETHOD(GetIDsOfNames)(
      THIS_
      REFIID riid,
      OLECHAR FAR* FAR* rgszNames,
      UINT cNames,
      LCID lcid,
      DISPID FAR* rgdispid) PURE;

    STDMETHOD(Invoke)(
      THIS_
      DISPID dispidMember,
      REFIID riid,
      LCID lcid,
      WORD wFlags,
      DISPPARAMS FAR* pdispparams,
      VARIANT FAR* pvarResult,
      EXCEPINFO FAR* pexcepinfo,
      UINT FAR* puArgErr) PURE;

    /* _IMsoDispObj methods */
    STDMETHOD(get_Application)(THIS_ IDispatch * FAR* ppidisp) PURE;
    STDMETHOD(get_Creator)(THIS_ long FAR* plCreator) PURE;
#endif

    /* SearchFolders methods */
    STDMETHOD(get_Item)(THIS_ int Index, ScopeFolder FAR* FAR* ScopeFolderRet) PURE;
    STDMETHOD(get_Count)(THIS_ int FAR* iCountRetVal) PURE;
    STDMETHOD(Add)(THIS_ ScopeFolder FAR* ScopeFolder) PURE;
    STDMETHOD(Remove)(THIS_ int Index) PURE;
    STDMETHOD(get__NewEnum)(THIS_ IUnknown * FAR* ppunkEnum) PURE;
};

DEFINE_GUID(IID_ScopeFolders,0x000C0369L,0x0000,0x0000,0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46);

/* Definition of interface: ScopeFolders */
#undef INTERFACE
#define INTERFACE ScopeFolders

DECLARE_INTERFACE_(ScopeFolders, _IMsoDispObj)
{
BEGIN_INTERFACE
#ifndef NO_BASEINTERFACE_FUNCS

    /* IUnknown methods */
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG, AddRef)(THIS) PURE;
    STDMETHOD_(ULONG, Release)(THIS) PURE;

    /* IDispatch methods */
    STDMETHOD(GetTypeInfoCount)(THIS_ UINT FAR* pctinfo) PURE;

    STDMETHOD(GetTypeInfo)(
      THIS_
      UINT itinfo,
      LCID lcid,
      ITypeInfo FAR* FAR* pptinfo) PURE;

    STDMETHOD(GetIDsOfNames)(
      THIS_
      REFIID riid,
      OLECHAR FAR* FAR* rgszNames,
      UINT cNames,
      LCID lcid,
      DISPID FAR* rgdispid) PURE;

    STDMETHOD(Invoke)(
      THIS_
      DISPID dispidMember,
      REFIID riid,
      LCID lcid,
      WORD wFlags,
      DISPPARAMS FAR* pdispparams,
      VARIANT FAR* pvarResult,
      EXCEPINFO FAR* pexcepinfo,
      UINT FAR* puArgErr) PURE;

    /* _IMsoDispObj methods */
    STDMETHOD(get_Application)(THIS_ IDispatch * FAR* ppidisp) PURE;
    STDMETHOD(get_Creator)(THIS_ long FAR* plCreator) PURE;
#endif

    /* ScopeFolders methods */
    STDMETHOD(get_Item)(THIS_ int Index, ScopeFolder FAR* FAR* ScopeFolderRet) PURE;
    STDMETHOD(get_Count)(THIS_ int FAR* iCountRetVal) PURE;
    STDMETHOD(get__NewEnum)(THIS_ IUnknown * FAR* ppunkEnum) PURE;
};

DEFINE_GUID(IID_ScopeFolder,0x000C0368L,0x0000,0x0000,0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46);

/* Definition of interface: ScopeFolder */
#undef INTERFACE
#define INTERFACE ScopeFolder

DECLARE_INTERFACE_(ScopeFolder, _IMsoDispObj)
{
BEGIN_INTERFACE
#ifndef NO_BASEINTERFACE_FUNCS

    /* IUnknown methods */
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG, AddRef)(THIS) PURE;
    STDMETHOD_(ULONG, Release)(THIS) PURE;

    /* IDispatch methods */
    STDMETHOD(GetTypeInfoCount)(THIS_ UINT FAR* pctinfo) PURE;

    STDMETHOD(GetTypeInfo)(
      THIS_
      UINT itinfo,
      LCID lcid,
      ITypeInfo FAR* FAR* pptinfo) PURE;

    STDMETHOD(GetIDsOfNames)(
      THIS_
      REFIID riid,
      OLECHAR FAR* FAR* rgszNames,
      UINT cNames,
      LCID lcid,
      DISPID FAR* rgdispid) PURE;

    STDMETHOD(Invoke)(
      THIS_
      DISPID dispidMember,
      REFIID riid,
      LCID lcid,
      WORD wFlags,
      DISPPARAMS FAR* pdispparams,
      VARIANT FAR* pvarResult,
      EXCEPINFO FAR* pexcepinfo,
      UINT FAR* puArgErr) PURE;

    /* _IMsoDispObj methods */
    STDMETHOD(get_Application)(THIS_ IDispatch * FAR* ppidisp) PURE;
    STDMETHOD(get_Creator)(THIS_ long FAR* plCreator) PURE;
#endif

    /* ScopeFolder methods */
    STDMETHOD(get_Name)(THIS_ BSTR FAR* pbstrName) PURE;
    STDMETHOD(get_Path)(THIS_ BSTR FAR* pbstrPath) PURE;
    STDMETHOD(get_ScopeFolders)(THIS_ ScopeFolders FAR* FAR* ScopeFoldersRet) PURE;
    STDMETHOD(AddToSearchFolders)(THIS) PURE;
};

DEFINE_GUID(IID_SearchScope,0x000C0367L,0x0000,0x0000,0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46);

/* Definition of interface: SearchScope */
#undef INTERFACE
#define INTERFACE SearchScope

DECLARE_INTERFACE_(SearchScope, _IMsoDispObj)
{
BEGIN_INTERFACE
#ifndef NO_BASEINTERFACE_FUNCS

    /* IUnknown methods */
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG, AddRef)(THIS) PURE;
    STDMETHOD_(ULONG, Release)(THIS) PURE;

    /* IDispatch methods */
    STDMETHOD(GetTypeInfoCount)(THIS_ UINT FAR* pctinfo) PURE;

    STDMETHOD(GetTypeInfo)(
      THIS_
      UINT itinfo,
      LCID lcid,
      ITypeInfo FAR* FAR* pptinfo) PURE;

    STDMETHOD(GetIDsOfNames)(
      THIS_
      REFIID riid,
      OLECHAR FAR* FAR* rgszNames,
      UINT cNames,
      LCID lcid,
      DISPID FAR* rgdispid) PURE;

    STDMETHOD(Invoke)(
      THIS_
      DISPID dispidMember,
      REFIID riid,
      LCID lcid,
      WORD wFlags,
      DISPPARAMS FAR* pdispparams,
      VARIANT FAR* pvarResult,
      EXCEPINFO FAR* pexcepinfo,
      UINT FAR* puArgErr) PURE;

    /* _IMsoDispObj methods */
    STDMETHOD(get_Application)(THIS_ IDispatch * FAR* ppidisp) PURE;
    STDMETHOD(get_Creator)(THIS_ long FAR* plCreator) PURE;
#endif

    /* SearchScope methods */
    STDMETHOD(get_Type)(THIS_ MsoSearchIn FAR* MsoSearchInRetVal) PURE;
    STDMETHOD(get_ScopeFolder)(THIS_ ScopeFolder FAR* FAR* ScopeFolderRet) PURE;
};

DEFINE_GUID(IID_SearchScopes,0x000C0366L,0x0000,0x0000,0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46);

/* Definition of interface: SearchScopes */
#undef INTERFACE
#define INTERFACE SearchScopes

DECLARE_INTERFACE_(SearchScopes, _IMsoDispObj)
{
BEGIN_INTERFACE
#ifndef NO_BASEINTERFACE_FUNCS

    /* IUnknown methods */
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG, AddRef)(THIS) PURE;
    STDMETHOD_(ULONG, Release)(THIS) PURE;

    /* IDispatch methods */
    STDMETHOD(GetTypeInfoCount)(THIS_ UINT FAR* pctinfo) PURE;

    STDMETHOD(GetTypeInfo)(
      THIS_
      UINT itinfo,
      LCID lcid,
      ITypeInfo FAR* FAR* pptinfo) PURE;

    STDMETHOD(GetIDsOfNames)(
      THIS_
      REFIID riid,
      OLECHAR FAR* FAR* rgszNames,
      UINT cNames,
      LCID lcid,
      DISPID FAR* rgdispid) PURE;

    STDMETHOD(Invoke)(
      THIS_
      DISPID dispidMember,
      REFIID riid,
      LCID lcid,
      WORD wFlags,
      DISPPARAMS FAR* pdispparams,
      VARIANT FAR* pvarResult,
      EXCEPINFO FAR* pexcepinfo,
      UINT FAR* puArgErr) PURE;

    /* _IMsoDispObj methods */
    STDMETHOD(get_Application)(THIS_ IDispatch * FAR* ppidisp) PURE;
    STDMETHOD(get_Creator)(THIS_ long FAR* plCreator) PURE;
#endif

    /* SearchScopes methods */
    STDMETHOD(get_Item)(THIS_ int Index, SearchScope FAR* FAR* SearchScopeRet) PURE;
    STDMETHOD(get_Count)(THIS_ int FAR* iCountRetVal) PURE;
    STDMETHOD(get__NewEnum)(THIS_ IUnknown * FAR* ppunkEnum) PURE;
};

typedef enum tagMsoOrgChartOrientation {
    msoOrgChartOrientationMixed = -2,
    msoOrgChartOrientationVertical = 1
} MsoOrgChartOrientation;

typedef enum {
    msoOrgChartLayoutMixed = -2,
    msoOrgChartLayoutStandard = 1,
    msoOrgChartLayoutBothHanging,
    msoOrgChartLayoutLeftHanging,
    msoOrgChartLayoutRightHanging
} MsoOrgChartLayoutType;

typedef enum {
    msoBeforeNode = 1,
    msoAfterNode,
    msoBeforeFirstSibling,
    msoAfterLastSibling
} MsoRelativeNodePosition;

typedef enum tagMsoDiagramType {
    msoDiagramMixed = -2,
    msoDiagramOrgChart = 1,
    msoDiagramCycle,
    msoDiagramRadial,
    msoDiagramPyramid,
    msoDiagramVenn,
    msoDiagramTarget
} MsoDiagramType;

typedef enum tagMsoDiagramNodeType {
    msoDiagramNode = 1,
    msoDiagramAssistant
} MsoDiagramNodeType;

DEFINE_GUID(IID_IMsoDiagram,0x000C036DL,0x0000,0x0000,0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46);

/* Definition of interface: IMsoDiagram */
#undef INTERFACE
#define INTERFACE IMsoDiagram

DECLARE_INTERFACE_(IMsoDiagram, _IMsoDispObj)
{
BEGIN_INTERFACE
#ifndef NO_BASEINTERFACE_FUNCS

    /* IUnknown methods */
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG, AddRef)(THIS) PURE;
    STDMETHOD_(ULONG, Release)(THIS) PURE;

    /* IDispatch methods */
    STDMETHOD(GetTypeInfoCount)(THIS_ UINT FAR* pctinfo) PURE;

    STDMETHOD(GetTypeInfo)(
      THIS_
      UINT itinfo,
      LCID lcid,
      ITypeInfo FAR* FAR* pptinfo) PURE;

    STDMETHOD(GetIDsOfNames)(
      THIS_
      REFIID riid,
      OLECHAR FAR* FAR* rgszNames,
      UINT cNames,
      LCID lcid,
      DISPID FAR* rgdispid) PURE;

    STDMETHOD(Invoke)(
      THIS_
      DISPID dispidMember,
      REFIID riid,
      LCID lcid,
      WORD wFlags,
      DISPPARAMS FAR* pdispparams,
      VARIANT FAR* pvarResult,
      EXCEPINFO FAR* pexcepinfo,
      UINT FAR* puArgErr) PURE;

    /* _IMsoDispObj methods */
    STDMETHOD(get_Application)(THIS_ IDispatch * FAR* ppidisp) PURE;
    STDMETHOD(get_Creator)(THIS_ long FAR* plCreator) PURE;
#endif

    /* IMsoDiagram methods */
    STDMETHOD(get_Parent)(THIS_ IDispatch * FAR* Parent) PURE;
    STDMETHOD(get_Nodes)(THIS_ DiagramNodes FAR* FAR* Nodes) PURE;
    STDMETHOD(get_Type)(THIS_ enum tagMsoDiagramType FAR* Type) PURE;
    STDMETHOD(get_AutoLayout)(THIS_ MsoTriState FAR* AutoLayout) PURE;
    STDMETHOD(put_AutoLayout)(THIS_ MsoTriState AutoLayout) PURE;
    STDMETHOD(get_Reverse)(THIS_ MsoTriState FAR* Reverse) PURE;
    STDMETHOD(put_Reverse)(THIS_ MsoTriState Reverse) PURE;
    STDMETHOD(get_AutoFormat)(THIS_ MsoTriState FAR* AutoFormat) PURE;
    STDMETHOD(put_AutoFormat)(THIS_ MsoTriState AutoFormat) PURE;
    STDMETHOD(Convert)(THIS_ enum tagMsoDiagramType Type) PURE;
};

DEFINE_GUID(IID_DiagramNodes,0x000C036EL,0x0000,0x0000,0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46);

/* Definition of interface: DiagramNodes */
#undef INTERFACE
#define INTERFACE DiagramNodes

DECLARE_INTERFACE_(DiagramNodes, _IMsoDispObj)
{
BEGIN_INTERFACE
#ifndef NO_BASEINTERFACE_FUNCS

    /* IUnknown methods */
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG, AddRef)(THIS) PURE;
    STDMETHOD_(ULONG, Release)(THIS) PURE;

    /* IDispatch methods */
    STDMETHOD(GetTypeInfoCount)(THIS_ UINT FAR* pctinfo) PURE;

    STDMETHOD(GetTypeInfo)(
      THIS_
      UINT itinfo,
      LCID lcid,
      ITypeInfo FAR* FAR* pptinfo) PURE;

    STDMETHOD(GetIDsOfNames)(
      THIS_
      REFIID riid,
      OLECHAR FAR* FAR* rgszNames,
      UINT cNames,
      LCID lcid,
      DISPID FAR* rgdispid) PURE;

    STDMETHOD(Invoke)(
      THIS_
      DISPID dispidMember,
      REFIID riid,
      LCID lcid,
      WORD wFlags,
      DISPPARAMS FAR* pdispparams,
      VARIANT FAR* pvarResult,
      EXCEPINFO FAR* pexcepinfo,
      UINT FAR* puArgErr) PURE;

    /* _IMsoDispObj methods */
    STDMETHOD(get_Application)(THIS_ IDispatch * FAR* ppidisp) PURE;
    STDMETHOD(get_Creator)(THIS_ long FAR* plCreator) PURE;
#endif

    /* DiagramNodes methods */
    STDMETHOD(get__NewEnum)(THIS_ IUnknown * FAR* ppunkEnum) PURE;
    STDMETHOD(Item)(THIS_ VARIANT Index, DiagramNode FAR* FAR* ppdn) PURE;
    STDMETHOD(SelectAll)(THIS) PURE;
    STDMETHOD(get_Parent)(THIS_ IDispatch * FAR* Parent) PURE;
    STDMETHOD(get_Count)(THIS_ int FAR* iDiagramNodes) PURE;
};

DEFINE_GUID(IID_DiagramNodeChildren,0x000C036FL,0x0000,0x0000,0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46);

/* Definition of interface: DiagramNodeChildren */
#undef INTERFACE
#define INTERFACE DiagramNodeChildren

DECLARE_INTERFACE_(DiagramNodeChildren, _IMsoDispObj)
{
BEGIN_INTERFACE
#ifndef NO_BASEINTERFACE_FUNCS

    /* IUnknown methods */
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG, AddRef)(THIS) PURE;
    STDMETHOD_(ULONG, Release)(THIS) PURE;

    /* IDispatch methods */
    STDMETHOD(GetTypeInfoCount)(THIS_ UINT FAR* pctinfo) PURE;

    STDMETHOD(GetTypeInfo)(
      THIS_
      UINT itinfo,
      LCID lcid,
      ITypeInfo FAR* FAR* pptinfo) PURE;

    STDMETHOD(GetIDsOfNames)(
      THIS_
      REFIID riid,
      OLECHAR FAR* FAR* rgszNames,
      UINT cNames,
      LCID lcid,
      DISPID FAR* rgdispid) PURE;

    STDMETHOD(Invoke)(
      THIS_
      DISPID dispidMember,
      REFIID riid,
      LCID lcid,
      WORD wFlags,
      DISPPARAMS FAR* pdispparams,
      VARIANT FAR* pvarResult,
      EXCEPINFO FAR* pexcepinfo,
      UINT FAR* puArgErr) PURE;

    /* _IMsoDispObj methods */
    STDMETHOD(get_Application)(THIS_ IDispatch * FAR* ppidisp) PURE;
    STDMETHOD(get_Creator)(THIS_ long FAR* plCreator) PURE;
#endif

    /* DiagramNodeChildren methods */
    STDMETHOD(get__NewEnum)(THIS_ IUnknown * FAR* ppunkEnum) PURE;
    STDMETHOD(Item)(THIS_ VARIANT Index, DiagramNode FAR* FAR* Node) PURE;
    STDMETHOD(AddNode)(THIS_ VARIANT Index, enum tagMsoDiagramNodeType NodeType, DiagramNode FAR* FAR* NewNode) PURE;
    STDMETHOD(SelectAll)(THIS) PURE;
    STDMETHOD(get_Parent)(THIS_ IDispatch * FAR* Parent) PURE;
    STDMETHOD(get_Count)(THIS_ int FAR* iDiagramNodes) PURE;
    STDMETHOD(get_FirstChild)(THIS_ DiagramNode FAR* FAR* First) PURE;
    STDMETHOD(get_LastChild)(THIS_ DiagramNode FAR* FAR* Last) PURE;
};

DEFINE_GUID(IID_DiagramNode,0x000C0370L,0x0000,0x0000,0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46);

/* Definition of interface: DiagramNode */
#undef INTERFACE
#define INTERFACE DiagramNode

DECLARE_INTERFACE_(DiagramNode, _IMsoDispObj)
{
BEGIN_INTERFACE
#ifndef NO_BASEINTERFACE_FUNCS

    /* IUnknown methods */
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG, AddRef)(THIS) PURE;
    STDMETHOD_(ULONG, Release)(THIS) PURE;

    /* IDispatch methods */
    STDMETHOD(GetTypeInfoCount)(THIS_ UINT FAR* pctinfo) PURE;

    STDMETHOD(GetTypeInfo)(
      THIS_
      UINT itinfo,
      LCID lcid,
      ITypeInfo FAR* FAR* pptinfo) PURE;

    STDMETHOD(GetIDsOfNames)(
      THIS_
      REFIID riid,
      OLECHAR FAR* FAR* rgszNames,
      UINT cNames,
      LCID lcid,
      DISPID FAR* rgdispid) PURE;

    STDMETHOD(Invoke)(
      THIS_
      DISPID dispidMember,
      REFIID riid,
      LCID lcid,
      WORD wFlags,
      DISPPARAMS FAR* pdispparams,
      VARIANT FAR* pvarResult,
      EXCEPINFO FAR* pexcepinfo,
      UINT FAR* puArgErr) PURE;

    /* _IMsoDispObj methods */
    STDMETHOD(get_Application)(THIS_ IDispatch * FAR* ppidisp) PURE;
    STDMETHOD(get_Creator)(THIS_ long FAR* plCreator) PURE;
#endif

    /* DiagramNode methods */
    STDMETHOD(AddNode)(THIS_ MsoRelativeNodePosition Pos, enum tagMsoDiagramNodeType NodeType, DiagramNode FAR* FAR* NewNode) PURE;
    STDMETHOD(Delete)(THIS) PURE;
    STDMETHOD(MoveNode)(THIS_ DiagramNode FAR* TargetNode, MsoRelativeNodePosition Pos) PURE;
    STDMETHOD(ReplaceNode)(THIS_ DiagramNode FAR* TargetNode) PURE;
    STDMETHOD(SwapNode)(THIS_ DiagramNode FAR* TargetNode, VARIANT_BOOL SwapChildren) PURE;
    STDMETHOD(CloneNode)(THIS_ VARIANT_BOOL CopyChildren, DiagramNode FAR* TargetNode, MsoRelativeNodePosition Pos, DiagramNode FAR* FAR* Node) PURE;
    STDMETHOD(TransferChildren)(THIS_ DiagramNode FAR* ReceivingNode) PURE;
    STDMETHOD(NextNode)(THIS_ DiagramNode FAR* FAR* NextNode) PURE;
    STDMETHOD(PrevNode)(THIS_ DiagramNode FAR* FAR* PrevNode) PURE;
    STDMETHOD(get_Parent)(THIS_ IDispatch * FAR* Parent) PURE;
    STDMETHOD(get_Children)(THIS_ DiagramNodeChildren FAR* FAR* Children) PURE;
    STDMETHOD(get_Shape)(THIS_ Shape FAR* FAR* Shape) PURE;
    STDMETHOD(get_Root)(THIS_ DiagramNode FAR* FAR* Root) PURE;
    STDMETHOD(get_Diagram)(THIS_ IMsoDiagram FAR* FAR* Diagram) PURE;
    STDMETHOD(get_Layout)(THIS_ MsoOrgChartLayoutType FAR* Type) PURE;
    STDMETHOD(put_Layout)(THIS_ MsoOrgChartLayoutType Type) PURE;
    STDMETHOD(get_TextShape)(THIS_ Shape FAR* FAR* Shape) PURE;
};

DEFINE_GUID(IID_CanvasShapes,0x000C0371L,0x0000,0x0000,0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46);

/* Definition of interface: CanvasShapes */
#undef INTERFACE
#define INTERFACE CanvasShapes

DECLARE_INTERFACE_(CanvasShapes, _IMsoDispObj)
{
BEGIN_INTERFACE
#ifndef NO_BASEINTERFACE_FUNCS

    /* IUnknown methods */
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG, AddRef)(THIS) PURE;
    STDMETHOD_(ULONG, Release)(THIS) PURE;

    /* IDispatch methods */
    STDMETHOD(GetTypeInfoCount)(THIS_ UINT FAR* pctinfo) PURE;

    STDMETHOD(GetTypeInfo)(
      THIS_
      UINT itinfo,
      LCID lcid,
      ITypeInfo FAR* FAR* pptinfo) PURE;

    STDMETHOD(GetIDsOfNames)(
      THIS_
      REFIID riid,
      OLECHAR FAR* FAR* rgszNames,
      UINT cNames,
      LCID lcid,
      DISPID FAR* rgdispid) PURE;

    STDMETHOD(Invoke)(
      THIS_
      DISPID dispidMember,
      REFIID riid,
      LCID lcid,
      WORD wFlags,
      DISPPARAMS FAR* pdispparams,
      VARIANT FAR* pvarResult,
      EXCEPINFO FAR* pexcepinfo,
      UINT FAR* puArgErr) PURE;

    /* _IMsoDispObj methods */
    STDMETHOD(get_Application)(THIS_ IDispatch * FAR* ppidisp) PURE;
    STDMETHOD(get_Creator)(THIS_ long FAR* plCreator) PURE;
#endif

    /* CanvasShapes methods */
    STDMETHOD(get_Parent)(THIS_ IDispatch * FAR* Parent) PURE;
    STDMETHOD(get_Count)(THIS_ int FAR* Count) PURE;
    STDMETHOD(Item)(THIS_ VARIANT Index, Shape FAR* FAR* Item) PURE;
    STDMETHOD(get__NewEnum)(THIS_ IUnknown * FAR* _NewEnum) PURE;
    STDMETHOD(AddCallout)(THIS_ MsoCalloutType Type, float Left, float Top, float Width, float Height, Shape FAR* FAR* Callout) PURE;
    STDMETHOD(AddConnector)(THIS_ MsoConnectorType Type, float BeginX, float BeginY, float EndX, float EndY, Shape FAR* FAR* Connector) PURE;
    STDMETHOD(AddCurve)(THIS_ VARIANT SafeArrayOfPoints, Shape FAR* FAR* Curve) PURE;
    STDMETHOD(AddLabel)(THIS_ MsoTextOrientation Orientation, float Left, float Top, float Width, float Height, Shape FAR* FAR* Label) PURE;
    STDMETHOD(AddLine)(THIS_ float BeginX, float BeginY, float EndX, float EndY, Shape FAR* FAR* Line) PURE;
    STDMETHOD(AddPicture)(THIS_ BSTR FileName, MsoTriState LinkToFile, MsoTriState SaveWithDocument, float Left, float Top, float Width, float Height, Shape FAR* FAR* Picture) PURE;
    STDMETHOD(AddPolyline)(THIS_ VARIANT SafeArrayOfPoints, Shape FAR* FAR* Polyline) PURE;
    STDMETHOD(AddShape)(THIS_ MsoAutoShapeType Type, float Left, float Top, float Width, float Height, Shape FAR* FAR* Shape) PURE;
    STDMETHOD(AddTextEffect)(THIS_ MsoPresetTextEffect PresetTextEffect, BSTR Text, BSTR FontName, float FontSize, MsoTriState FontBold, MsoTriState FontItalic, float Left, float Top, Shape FAR* FAR* TextEffect) PURE;
    STDMETHOD(AddTextbox)(THIS_ MsoTextOrientation Orientation, float Left, float Top, float Width, float Height, Shape FAR* FAR* Textbox) PURE;
    STDMETHOD(BuildFreeform)(THIS_ MsoEditingType EditingType, float X1, float Y1, FreeformBuilder FAR* FAR* FreeformBuilder) PURE;
    STDMETHOD(Range)(THIS_ VARIANT Index, ShapeRange FAR* FAR* Range) PURE;
    STDMETHOD(SelectAll)(THIS) PURE;
    STDMETHOD(get_Background)(THIS_ Shape FAR* FAR* Background) PURE;
};

typedef enum {
    msoMoveRowFirst = -4,
    msoMoveRowPrev = -3,
    msoMoveRowNext = -2,
    msoMoveRowNbr = -1
} MsoMoveRow;

DEFINE_GUID(IID_OfficeDataSourceObject,0x000C1530L,0x0000,0x0000,0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46);

/* Definition of interface: OfficeDataSourceObject */
#undef INTERFACE
#define INTERFACE OfficeDataSourceObject

DECLARE_INTERFACE_(OfficeDataSourceObject, IDispatch)
{
BEGIN_INTERFACE
#ifndef NO_BASEINTERFACE_FUNCS

    /* IUnknown methods */
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG, AddRef)(THIS) PURE;
    STDMETHOD_(ULONG, Release)(THIS) PURE;

    /* IDispatch methods */
    STDMETHOD(GetTypeInfoCount)(THIS_ UINT FAR* pctinfo) PURE;

    STDMETHOD(GetTypeInfo)(
      THIS_
      UINT itinfo,
      LCID lcid,
      ITypeInfo FAR* FAR* pptinfo) PURE;

    STDMETHOD(GetIDsOfNames)(
      THIS_
      REFIID riid,
      OLECHAR FAR* FAR* rgszNames,
      UINT cNames,
      LCID lcid,
      DISPID FAR* rgdispid) PURE;

    STDMETHOD(Invoke)(
      THIS_
      DISPID dispidMember,
      REFIID riid,
      LCID lcid,
      WORD wFlags,
      DISPPARAMS FAR* pdispparams,
      VARIANT FAR* pvarResult,
      EXCEPINFO FAR* pexcepinfo,
      UINT FAR* puArgErr) PURE;
#endif

    /* OfficeDataSourceObject methods */
    STDMETHOD(get_ConnectString)(THIS_ BSTR FAR* pbstrConnect) PURE;
    STDMETHOD(put_ConnectString)(THIS_ BSTR bstrConnect) PURE;
    STDMETHOD(get_Table)(THIS_ BSTR FAR* pbstrTable) PURE;
    STDMETHOD(put_Table)(THIS_ BSTR bstrTable) PURE;
    STDMETHOD(get_DataSource)(THIS_ BSTR FAR* pbstrSrc) PURE;
    STDMETHOD(put_DataSource)(THIS_ BSTR bstrSrc) PURE;
    STDMETHOD(get_Columns)(THIS_ IDispatch * FAR* ppColumns) PURE;
    STDMETHOD(get_RowCount)(THIS_ long FAR* pcRows) PURE;
    STDMETHOD(get_Filters)(THIS_ IDispatch * FAR* ppFilters) PURE;
    STDMETHOD(Move)(THIS_ MsoMoveRow msoMoveRow, int RowNbr, int FAR* rval) PURE;
    STDMETHOD(Open)(THIS_ BSTR bstrSrc, BSTR bstrConnect, BSTR bstrTable, long fOpenExclusive, long fNeverPrompt) PURE;
    STDMETHOD(SetSortOrder)(THIS_ BSTR SortField1, VARIANT_BOOL SortAscending1, BSTR SortField2, VARIANT_BOOL SortAscending2, BSTR SortField3, VARIANT_BOOL SortAscending3) PURE;
    STDMETHOD(ApplyFilter)(THIS) PURE;
};

DEFINE_GUID(IID_ODSOColumn,0x000C1531L,0x0000,0x0000,0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46);

/* Definition of interface: ODSOColumn */
#undef INTERFACE
#define INTERFACE ODSOColumn

DECLARE_INTERFACE_(ODSOColumn, _IMsoDispObj)
{
BEGIN_INTERFACE
#ifndef NO_BASEINTERFACE_FUNCS

    /* IUnknown methods */
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG, AddRef)(THIS) PURE;
    STDMETHOD_(ULONG, Release)(THIS) PURE;

    /* IDispatch methods */
    STDMETHOD(GetTypeInfoCount)(THIS_ UINT FAR* pctinfo) PURE;

    STDMETHOD(GetTypeInfo)(
      THIS_
      UINT itinfo,
      LCID lcid,
      ITypeInfo FAR* FAR* pptinfo) PURE;

    STDMETHOD(GetIDsOfNames)(
      THIS_
      REFIID riid,
      OLECHAR FAR* FAR* rgszNames,
      UINT cNames,
      LCID lcid,
      DISPID FAR* rgdispid) PURE;

    STDMETHOD(Invoke)(
      THIS_
      DISPID dispidMember,
      REFIID riid,
      LCID lcid,
      WORD wFlags,
      DISPPARAMS FAR* pdispparams,
      VARIANT FAR* pvarResult,
      EXCEPINFO FAR* pexcepinfo,
      UINT FAR* puArgErr) PURE;

    /* _IMsoDispObj methods */
    STDMETHOD(get_Application)(THIS_ IDispatch * FAR* ppidisp) PURE;
    STDMETHOD(get_Creator)(THIS_ long FAR* plCreator) PURE;
#endif

    /* ODSOColumn methods */
    STDMETHOD(get_Index)(THIS_ long FAR* plIndex) PURE;
    STDMETHOD(get_Name)(THIS_ BSTR FAR* pbstrName) PURE;
    STDMETHOD(get_Parent)(THIS_ IDispatch * FAR* ppParent) PURE;
    STDMETHOD(get_Value)(THIS_ BSTR FAR* pbstrValue) PURE;
};

DEFINE_GUID(IID_ODSOColumns,0x000C1532L,0x0000,0x0000,0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46);

/* Definition of interface: ODSOColumns */
#undef INTERFACE
#define INTERFACE ODSOColumns

DECLARE_INTERFACE_(ODSOColumns, _IMsoDispObj)
{
BEGIN_INTERFACE
#ifndef NO_BASEINTERFACE_FUNCS

    /* IUnknown methods */
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG, AddRef)(THIS) PURE;
    STDMETHOD_(ULONG, Release)(THIS) PURE;

    /* IDispatch methods */
    STDMETHOD(GetTypeInfoCount)(THIS_ UINT FAR* pctinfo) PURE;

    STDMETHOD(GetTypeInfo)(
      THIS_
      UINT itinfo,
      LCID lcid,
      ITypeInfo FAR* FAR* pptinfo) PURE;

    STDMETHOD(GetIDsOfNames)(
      THIS_
      REFIID riid,
      OLECHAR FAR* FAR* rgszNames,
      UINT cNames,
      LCID lcid,
      DISPID FAR* rgdispid) PURE;

    STDMETHOD(Invoke)(
      THIS_
      DISPID dispidMember,
      REFIID riid,
      LCID lcid,
      WORD wFlags,
      DISPPARAMS FAR* pdispparams,
      VARIANT FAR* pvarResult,
      EXCEPINFO FAR* pexcepinfo,
      UINT FAR* puArgErr) PURE;

    /* _IMsoDispObj methods */
    STDMETHOD(get_Application)(THIS_ IDispatch * FAR* ppidisp) PURE;
    STDMETHOD(get_Creator)(THIS_ long FAR* plCreator) PURE;
#endif

    /* ODSOColumns methods */
    STDMETHOD(get_Count)(THIS_ long FAR* plCount) PURE;
    STDMETHOD(get_Parent)(THIS_ IDispatch * FAR* ppParentOdso) PURE;
    STDMETHOD(Item)(THIS_ VARIANT varIndex, IDispatch * FAR* ppColumn) PURE;
};

typedef enum {
    msoFilterComparisonEqual = 0,
    msoFilterComparisonNotEqual = 1,
    msoFilterComparisonLessThan = 2,
    msoFilterComparisonGreaterThan = 3,
    msoFilterComparisonLessThanEqual = 4,
    msoFilterComparisonGreaterThanEqual = 5,
    msoFilterComparisonIsBlank = 6,
    msoFilterComparisonIsNotBlank = 7,
    msoFilterComparisonContains = 8,
    msoFilterComparisonNotContains = 9
} MsoFilterComparison;

typedef enum {
    msoFilterConjunctionAnd = 0,
    msoFilterConjunctionOr = 1
} MsoFilterConjunction;

DEFINE_GUID(IID_ODSOFilter,0x000C1533L,0x0000,0x0000,0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46);

/* Definition of interface: ODSOFilter */
#undef INTERFACE
#define INTERFACE ODSOFilter

DECLARE_INTERFACE_(ODSOFilter, _IMsoDispObj)
{
BEGIN_INTERFACE
#ifndef NO_BASEINTERFACE_FUNCS

    /* IUnknown methods */
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG, AddRef)(THIS) PURE;
    STDMETHOD_(ULONG, Release)(THIS) PURE;

    /* IDispatch methods */
    STDMETHOD(GetTypeInfoCount)(THIS_ UINT FAR* pctinfo) PURE;

    STDMETHOD(GetTypeInfo)(
      THIS_
      UINT itinfo,
      LCID lcid,
      ITypeInfo FAR* FAR* pptinfo) PURE;

    STDMETHOD(GetIDsOfNames)(
      THIS_
      REFIID riid,
      OLECHAR FAR* FAR* rgszNames,
      UINT cNames,
      LCID lcid,
      DISPID FAR* rgdispid) PURE;

    STDMETHOD(Invoke)(
      THIS_
      DISPID dispidMember,
      REFIID riid,
      LCID lcid,
      WORD wFlags,
      DISPPARAMS FAR* pdispparams,
      VARIANT FAR* pvarResult,
      EXCEPINFO FAR* pexcepinfo,
      UINT FAR* puArgErr) PURE;

    /* _IMsoDispObj methods */
    STDMETHOD(get_Application)(THIS_ IDispatch * FAR* ppidisp) PURE;
    STDMETHOD(get_Creator)(THIS_ long FAR* plCreator) PURE;
#endif

    /* ODSOFilter methods */
    STDMETHOD(get_Index)(THIS_ long FAR* plIndex) PURE;
    STDMETHOD(get_Parent)(THIS_ IDispatch * FAR* ppParent) PURE;
    STDMETHOD(get_Column)(THIS_ BSTR FAR* pbstrCol) PURE;
    STDMETHOD(put_Column)(THIS_ BSTR bstrCol) PURE;
    STDMETHOD(get_Comparison)(THIS_ MsoFilterComparison FAR* pComparison) PURE;
    STDMETHOD(put_Comparison)(THIS_ MsoFilterComparison Comparison) PURE;
    STDMETHOD(get_CompareTo)(THIS_ BSTR FAR* pbstrCompareTo) PURE;
    STDMETHOD(put_CompareTo)(THIS_ BSTR bstrCompareTo) PURE;
    STDMETHOD(get_Conjunction)(THIS_ MsoFilterConjunction FAR* pConjunction) PURE;
    STDMETHOD(put_Conjunction)(THIS_ MsoFilterConjunction Conjunction) PURE;
};

DEFINE_GUID(IID_ODSOFilters,0x000C1534L,0x0000,0x0000,0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46);

/* Definition of interface: ODSOFilters */
#undef INTERFACE
#define INTERFACE ODSOFilters

DECLARE_INTERFACE_(ODSOFilters, _IMsoDispObj)
{
BEGIN_INTERFACE
#ifndef NO_BASEINTERFACE_FUNCS

    /* IUnknown methods */
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG, AddRef)(THIS) PURE;
    STDMETHOD_(ULONG, Release)(THIS) PURE;

    /* IDispatch methods */
    STDMETHOD(GetTypeInfoCount)(THIS_ UINT FAR* pctinfo) PURE;

    STDMETHOD(GetTypeInfo)(
      THIS_
      UINT itinfo,
      LCID lcid,
      ITypeInfo FAR* FAR* pptinfo) PURE;

    STDMETHOD(GetIDsOfNames)(
      THIS_
      REFIID riid,
      OLECHAR FAR* FAR* rgszNames,
      UINT cNames,
      LCID lcid,
      DISPID FAR* rgdispid) PURE;

    STDMETHOD(Invoke)(
      THIS_
      DISPID dispidMember,
      REFIID riid,
      LCID lcid,
      WORD wFlags,
      DISPPARAMS FAR* pdispparams,
      VARIANT FAR* pvarResult,
      EXCEPINFO FAR* pexcepinfo,
      UINT FAR* puArgErr) PURE;

    /* _IMsoDispObj methods */
    STDMETHOD(get_Application)(THIS_ IDispatch * FAR* ppidisp) PURE;
    STDMETHOD(get_Creator)(THIS_ long FAR* plCreator) PURE;
#endif

    /* ODSOFilters methods */
    STDMETHOD(get_Count)(THIS_ long FAR* plCount) PURE;
    STDMETHOD(get_Parent)(THIS_ IDispatch * FAR* ppParentOdso) PURE;
    STDMETHOD(Item)(THIS_ long Index, IDispatch * FAR* ppColumn) PURE;
    STDMETHOD(Add)(THIS_ BSTR column, MsoFilterComparison Comparison, MsoFilterConjunction Conjunction, BSTR bstrCompareTo, VARIANT_BOOL DeferUpdate) PURE;
    STDMETHOD(Delete)(THIS_ long Index, VARIANT_BOOL DeferUpdate) PURE;
};

typedef enum {
    msoOpenDocument = 0,
    msoNew,
    msoNewfromExistingFile,
    msoNewfromTemplate,
    msoBottomSection
} MsoFileNewSection;

typedef enum {
    msoEditFile = 0,
    msoCreateNewFile,
    msoOpenFile
} MsoFileNewAction;

DEFINE_GUID(IID_NewFile,0x000C0936L,0x0000,0x0000,0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46);

/* Definition of interface: NewFile */
#undef INTERFACE
#define INTERFACE NewFile

DECLARE_INTERFACE_(NewFile, _IMsoDispObj)
{
BEGIN_INTERFACE
#ifndef NO_BASEINTERFACE_FUNCS

    /* IUnknown methods */
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG, AddRef)(THIS) PURE;
    STDMETHOD_(ULONG, Release)(THIS) PURE;

    /* IDispatch methods */
    STDMETHOD(GetTypeInfoCount)(THIS_ UINT FAR* pctinfo) PURE;

    STDMETHOD(GetTypeInfo)(
      THIS_
      UINT itinfo,
      LCID lcid,
      ITypeInfo FAR* FAR* pptinfo) PURE;

    STDMETHOD(GetIDsOfNames)(
      THIS_
      REFIID riid,
      OLECHAR FAR* FAR* rgszNames,
      UINT cNames,
      LCID lcid,
      DISPID FAR* rgdispid) PURE;

    STDMETHOD(Invoke)(
      THIS_
      DISPID dispidMember,
      REFIID riid,
      LCID lcid,
      WORD wFlags,
      DISPPARAMS FAR* pdispparams,
      VARIANT FAR* pvarResult,
      EXCEPINFO FAR* pexcepinfo,
      UINT FAR* puArgErr) PURE;

    /* _IMsoDispObj methods */
    STDMETHOD(get_Application)(THIS_ IDispatch * FAR* ppidisp) PURE;
    STDMETHOD(get_Creator)(THIS_ long FAR* plCreator) PURE;
#endif

    /* NewFile methods */
    STDMETHOD(Add)(THIS_ BSTR Filename, VARIANT Section, VARIANT DisplayName, VARIANT Action, VARIANT_BOOL FAR* pvarf) PURE;
    STDMETHOD(Remove)(THIS_ BSTR Filename, VARIANT Section, VARIANT DisplayName, VARIANT Action, VARIANT_BOOL FAR* pvarf) PURE;
};

DEFINE_GUID(IID_WebComponent,0x000CD100L,0x0000,0x0000,0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46);

/* Definition of interface: WebComponent */
#undef INTERFACE
#define INTERFACE WebComponent

DECLARE_INTERFACE_(WebComponent, IDispatch)
{
BEGIN_INTERFACE
#ifndef NO_BASEINTERFACE_FUNCS

    /* IUnknown methods */
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG, AddRef)(THIS) PURE;
    STDMETHOD_(ULONG, Release)(THIS) PURE;

    /* IDispatch methods */
    STDMETHOD(GetTypeInfoCount)(THIS_ UINT FAR* pctinfo) PURE;

    STDMETHOD(GetTypeInfo)(
      THIS_
      UINT itinfo,
      LCID lcid,
      ITypeInfo FAR* FAR* pptinfo) PURE;

    STDMETHOD(GetIDsOfNames)(
      THIS_
      REFIID riid,
      OLECHAR FAR* FAR* rgszNames,
      UINT cNames,
      LCID lcid,
      DISPID FAR* rgdispid) PURE;

    STDMETHOD(Invoke)(
      THIS_
      DISPID dispidMember,
      REFIID riid,
      LCID lcid,
      WORD wFlags,
      DISPPARAMS FAR* pdispparams,
      VARIANT FAR* pvarResult,
      EXCEPINFO FAR* pexcepinfo,
      UINT FAR* puArgErr) PURE;
#endif

    /* WebComponent methods */
    STDMETHOD(get_Shape)(THIS_ IDispatch * FAR* RetValue) PURE;
    STDMETHOD(get_URL)(THIS_ BSTR FAR* RetValue) PURE;
    STDMETHOD(put_URL)(THIS_ BSTR URL) PURE;
    STDMETHOD(get_HTML)(THIS_ BSTR FAR* RetValue) PURE;
    STDMETHOD(put_HTML)(THIS_ BSTR HTML) PURE;
    STDMETHOD(get_Name)(THIS_ BSTR FAR* RetValue) PURE;
    STDMETHOD(put_Name)(THIS_ BSTR Name) PURE;
    STDMETHOD(get_Width)(THIS_ long FAR* RetValue) PURE;
    STDMETHOD(put_Width)(THIS_ long Width) PURE;
    STDMETHOD(get_Height)(THIS_ long FAR* RetValue) PURE;
    STDMETHOD(put_Height)(THIS_ long Height) PURE;
    STDMETHOD(SetPlaceHolderGraphic)(THIS_ BSTR PlaceHolderGraphic) PURE;
    STDMETHOD(Commit)(THIS) PURE;
    STDMETHOD(Revert)(THIS) PURE;
};

DEFINE_GUID(IID_WebComponentWindowExternal,0x000CD101L,0x0000,0x0000,0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46);

/* Definition of interface: WebComponentWindowExternal */
#undef INTERFACE
#define INTERFACE WebComponentWindowExternal

DECLARE_INTERFACE_(WebComponentWindowExternal, IDispatch)
{
BEGIN_INTERFACE
#ifndef NO_BASEINTERFACE_FUNCS

    /* IUnknown methods */
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG, AddRef)(THIS) PURE;
    STDMETHOD_(ULONG, Release)(THIS) PURE;

    /* IDispatch methods */
    STDMETHOD(GetTypeInfoCount)(THIS_ UINT FAR* pctinfo) PURE;

    STDMETHOD(GetTypeInfo)(
      THIS_
      UINT itinfo,
      LCID lcid,
      ITypeInfo FAR* FAR* pptinfo) PURE;

    STDMETHOD(GetIDsOfNames)(
      THIS_
      REFIID riid,
      OLECHAR FAR* FAR* rgszNames,
      UINT cNames,
      LCID lcid,
      DISPID FAR* rgdispid) PURE;

    STDMETHOD(Invoke)(
      THIS_
      DISPID dispidMember,
      REFIID riid,
      LCID lcid,
      WORD wFlags,
      DISPPARAMS FAR* pdispparams,
      VARIANT FAR* pvarResult,
      EXCEPINFO FAR* pexcepinfo,
      UINT FAR* puArgErr) PURE;
#endif

    /* WebComponentWindowExternal methods */
    STDMETHOD(get_InterfaceVersion)(THIS_ long FAR* RetValue) PURE;
    STDMETHOD(get_ApplicationName)(THIS_ BSTR FAR* RetValue) PURE;
    STDMETHOD(get_ApplicationVersion)(THIS_ long FAR* RetValue) PURE;
    STDMETHOD(get_Application)(THIS_ IDispatch * FAR* RetValue) PURE;
    STDMETHOD(CloseWindow)(THIS) PURE;
    STDMETHOD(get_WebComponent)(THIS_ WebComponent FAR* FAR* RetValue) PURE;
};

DEFINE_GUID(IID_WebComponentFormat,0x000CD102L,0x0000,0x0000,0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46);

/* Definition of interface: WebComponentFormat */
#undef INTERFACE
#define INTERFACE WebComponentFormat

DECLARE_INTERFACE_(WebComponentFormat, IDispatch)
{
BEGIN_INTERFACE
#ifndef NO_BASEINTERFACE_FUNCS

    /* IUnknown methods */
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG, AddRef)(THIS) PURE;
    STDMETHOD_(ULONG, Release)(THIS) PURE;

    /* IDispatch methods */
    STDMETHOD(GetTypeInfoCount)(THIS_ UINT FAR* pctinfo) PURE;

    STDMETHOD(GetTypeInfo)(
      THIS_
      UINT itinfo,
      LCID lcid,
      ITypeInfo FAR* FAR* pptinfo) PURE;

    STDMETHOD(GetIDsOfNames)(
      THIS_
      REFIID riid,
      OLECHAR FAR* FAR* rgszNames,
      UINT cNames,
      LCID lcid,
      DISPID FAR* rgdispid) PURE;

    STDMETHOD(Invoke)(
      THIS_
      DISPID dispidMember,
      REFIID riid,
      LCID lcid,
      WORD wFlags,
      DISPPARAMS FAR* pdispparams,
      VARIANT FAR* pvarResult,
      EXCEPINFO FAR* pexcepinfo,
      UINT FAR* puArgErr) PURE;
#endif

    /* WebComponentFormat methods */
    STDMETHOD(get_Application)(THIS_ IDispatch * FAR* RetValue) PURE;
    STDMETHOD(get_Parent)(THIS_ IDispatch * FAR* Parent) PURE;
    STDMETHOD(get_URL)(THIS_ BSTR FAR* RetValue) PURE;
    STDMETHOD(put_URL)(THIS_ BSTR URL) PURE;
    STDMETHOD(get_HTML)(THIS_ BSTR FAR* RetValue) PURE;
    STDMETHOD(put_HTML)(THIS_ BSTR HTML) PURE;
    STDMETHOD(get_Name)(THIS_ BSTR FAR* RetValue) PURE;
    STDMETHOD(put_Name)(THIS_ BSTR Name) PURE;
    STDMETHOD(get_Width)(THIS_ long FAR* RetValue) PURE;
    STDMETHOD(put_Width)(THIS_ long Width) PURE;
    STDMETHOD(get_Height)(THIS_ long FAR* RetValue) PURE;
    STDMETHOD(put_Height)(THIS_ long Height) PURE;
    STDMETHOD(get_PreviewGraphic)(THIS_ BSTR FAR* RetVal) PURE;
    STDMETHOD(put_PreviewGraphic)(THIS_ BSTR PreviewGraphic) PURE;
    STDMETHOD(LaunchPropertiesWindow)(THIS) PURE;
};

typedef enum {
    msoLanguageIDChineseHongKong = 3076,
    msoLanguageIDChineseMacao = 5124,
    msoLanguageIDEnglishTrinidad = 11273
} MsoLanguageIDHidden;

typedef unsigned long DWORD;

typedef int BOOL;

DEFINE_GUID(IID_ILicWizExternal,0x4CAC6328L,0xB9B0,0x11D3,0x8D,0x59,0x00,0x50,0x04,0x83,0x84,0xE3);

/* Definition of interface: ILicWizExternal */
#undef INTERFACE
#define INTERFACE ILicWizExternal

DECLARE_INTERFACE_(ILicWizExternal, IDispatch)
{
BEGIN_INTERFACE
#ifndef NO_BASEINTERFACE_FUNCS

    /* IUnknown methods */
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG, AddRef)(THIS) PURE;
    STDMETHOD_(ULONG, Release)(THIS) PURE;

    /* IDispatch methods */
    STDMETHOD(GetTypeInfoCount)(THIS_ UINT FAR* pctinfo) PURE;

    STDMETHOD(GetTypeInfo)(
      THIS_
      UINT itinfo,
      LCID lcid,
      ITypeInfo FAR* FAR* pptinfo) PURE;

    STDMETHOD(GetIDsOfNames)(
      THIS_
      REFIID riid,
      OLECHAR FAR* FAR* rgszNames,
      UINT cNames,
      LCID lcid,
      DISPID FAR* rgdispid) PURE;

    STDMETHOD(Invoke)(
      THIS_
      DISPID dispidMember,
      REFIID riid,
      LCID lcid,
      WORD wFlags,
      DISPPARAMS FAR* pdispparams,
      VARIANT FAR* pvarResult,
      EXCEPINFO FAR* pexcepinfo,
      UINT FAR* puArgErr) PURE;
#endif

    /* ILicWizExternal methods */
    STDMETHOD(PrintHtmlDocument)(THIS_ IUnknown * punkHtmlDoc) PURE;
    STDMETHOD(InvokeDateTimeApplet)(THIS) PURE;
    STDMETHOD(FormatDate)(THIS_ DATE date, BSTR pFormat, BSTR FAR* pDateString) PURE;
    STDMETHOD(ShowHelp)(THIS_ VARIANT FAR* pvarId) PURE;
    STDMETHOD(Terminate)(THIS) PURE;
    STDMETHOD(DisableVORWReminder)(THIS_ long BPC) PURE;
    STDMETHOD(SaveReceipt)(THIS_ BSTR bstrReceipt, BSTR FAR* pbstrPath) PURE;
    STDMETHOD(OpenInDefaultBrowser)(THIS_ BSTR bstrUrl) PURE;
    STDMETHOD(MsoAlert)(THIS_ BSTR bstrText, BSTR bstrButtons, BSTR bstrIcon, long FAR* plRet) PURE;
    STDMETHOD(DepositPidKey)(THIS_ BSTR bstrKey, BOOL fMORW, long FAR* plRet) PURE;
    STDMETHOD(WriteLog)(THIS_ BSTR bstrMessage) PURE;
    STDMETHOD(ResignDpc)(THIS_ BSTR bstrProductCode) PURE;
    STDMETHOD(ResetPID)(THIS) PURE;
    STDMETHOD(SetDialogSize)(THIS_ long dx, long dy) PURE;
    STDMETHOD(VerifyClock)(THIS_ long lMode, long FAR* plRet) PURE;
    STDMETHOD(SortSelectOptions)(THIS_ IDispatch * pdispSelect) PURE;
    STDMETHOD(InternetDisconnect)(THIS) PURE;
    STDMETHOD(GetConnectedState)(THIS_ BOOL FAR* pfConnected) PURE;
    STDMETHOD(get_Context)(THIS_ long FAR* plwctx) PURE;
    STDMETHOD(get_Validator)(THIS_ IDispatch * FAR* ppdispValidator) PURE;
    STDMETHOD(get_LicAgent)(THIS_ IDispatch * FAR* ppdispLicAgent) PURE;
    STDMETHOD(get_CountryInfo)(THIS_ BSTR FAR* pbstrUrl) PURE;
    STDMETHOD(put_WizardVisible)(THIS_ BOOL fVisible) PURE;
    STDMETHOD(put_WizardTitle)(THIS_ BSTR bstrTitle) PURE;
    STDMETHOD(get_AnimationEnabled)(THIS_ BOOL FAR* fEnabled) PURE;
    STDMETHOD(put_CurrentHelpId)(THIS_ long lHelpId) PURE;
    STDMETHOD(get_OfficeOnTheWebUrl)(THIS_ BSTR FAR* bstrUrl) PURE;
};

DEFINE_GUID(IID_ILicValidator,0x919AA22CL,0xB9AD,0x11D3,0x8D,0x59,0x00,0x50,0x04,0x83,0x84,0xE3);

/* Definition of interface: ILicValidator */
#undef INTERFACE
#define INTERFACE ILicValidator

DECLARE_INTERFACE_(ILicValidator, IDispatch)
{
BEGIN_INTERFACE
#ifndef NO_BASEINTERFACE_FUNCS

    /* IUnknown methods */
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG, AddRef)(THIS) PURE;
    STDMETHOD_(ULONG, Release)(THIS) PURE;

    /* IDispatch methods */
    STDMETHOD(GetTypeInfoCount)(THIS_ UINT FAR* pctinfo) PURE;

    STDMETHOD(GetTypeInfo)(
      THIS_
      UINT itinfo,
      LCID lcid,
      ITypeInfo FAR* FAR* pptinfo) PURE;

    STDMETHOD(GetIDsOfNames)(
      THIS_
      REFIID riid,
      OLECHAR FAR* FAR* rgszNames,
      UINT cNames,
      LCID lcid,
      DISPID FAR* rgdispid) PURE;

    STDMETHOD(Invoke)(
      THIS_
      DISPID dispidMember,
      REFIID riid,
      LCID lcid,
      WORD wFlags,
      DISPPARAMS FAR* pdispparams,
      VARIANT FAR* pvarResult,
      EXCEPINFO FAR* pexcepinfo,
      UINT FAR* puArgErr) PURE;
#endif

    /* ILicValidator methods */
    STDMETHOD(get_Products)(THIS_ VARIANT FAR* pVariant) PURE;
    STDMETHOD(get_Selection)(THIS_ int FAR* piSel) PURE;
    STDMETHOD(put_Selection)(THIS_ int iSel) PURE;
};

DEFINE_GUID(IID_ILicAgent,0x00194002L,0xD9C3,0x11D3,0x8D,0x59,0x00,0x50,0x04,0x83,0x84,0xE3);

/* Definition of interface: ILicAgent */
#undef INTERFACE
#define INTERFACE ILicAgent

DECLARE_INTERFACE_(ILicAgent, IDispatch)
{
BEGIN_INTERFACE
#ifndef NO_BASEINTERFACE_FUNCS

    /* IUnknown methods */
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG, AddRef)(THIS) PURE;
    STDMETHOD_(ULONG, Release)(THIS) PURE;

    /* IDispatch methods */
    STDMETHOD(GetTypeInfoCount)(THIS_ UINT FAR* pctinfo) PURE;

    STDMETHOD(GetTypeInfo)(
      THIS_
      UINT itinfo,
      LCID lcid,
      ITypeInfo FAR* FAR* pptinfo) PURE;

    STDMETHOD(GetIDsOfNames)(
      THIS_
      REFIID riid,
      OLECHAR FAR* FAR* rgszNames,
      UINT cNames,
      LCID lcid,
      DISPID FAR* rgdispid) PURE;

    STDMETHOD(Invoke)(
      THIS_
      DISPID dispidMember,
      REFIID riid,
      LCID lcid,
      WORD wFlags,
      DISPPARAMS FAR* pdispparams,
      VARIANT FAR* pvarResult,
      EXCEPINFO FAR* pexcepinfo,
      UINT FAR* puArgErr) PURE;
#endif

    /* ILicAgent methods */
    STDMETHOD(Initialize)(THIS_ DWORD dwBPC, DWORD dwMode, BSTR bstrLicSource, DWORD FAR* pdwRetCode) PURE;
    STDMETHOD(GetFirstName)(THIS_ BSTR FAR* pbstrVal) PURE;
    STDMETHOD(SetFirstName)(THIS_ BSTR bstrNewVal) PURE;
    STDMETHOD(GetLastName)(THIS_ BSTR FAR* pbstrVal) PURE;
    STDMETHOD(SetLastName)(THIS_ BSTR bstrNewVal) PURE;
    STDMETHOD(GetOrgName)(THIS_ BSTR FAR* pbstrVal) PURE;
    STDMETHOD(SetOrgName)(THIS_ BSTR bstrNewVal) PURE;
    STDMETHOD(GetEmail)(THIS_ BSTR FAR* pbstrVal) PURE;
    STDMETHOD(SetEmail)(THIS_ BSTR bstrNewVal) PURE;
    STDMETHOD(GetPhone)(THIS_ BSTR FAR* pbstrVal) PURE;
    STDMETHOD(SetPhone)(THIS_ BSTR bstrNewVal) PURE;
    STDMETHOD(GetAddress1)(THIS_ BSTR FAR* pbstrVal) PURE;
    STDMETHOD(SetAddress1)(THIS_ BSTR bstrNewVal) PURE;
    STDMETHOD(GetCity)(THIS_ BSTR FAR* pbstrVal) PURE;
    STDMETHOD(SetCity)(THIS_ BSTR bstrNewVal) PURE;
    STDMETHOD(GetState)(THIS_ BSTR FAR* pbstrVal) PURE;
    STDMETHOD(SetState)(THIS_ BSTR bstrNewVal) PURE;
    STDMETHOD(GetCountryCode)(THIS_ BSTR FAR* pbstrVal) PURE;
    STDMETHOD(SetCountryCode)(THIS_ BSTR bstrNewVal) PURE;
    STDMETHOD(GetCountryDesc)(THIS_ BSTR FAR* pbstrVal) PURE;
    STDMETHOD(SetCountryDesc)(THIS_ BSTR bstrNewVal) PURE;
    STDMETHOD(GetZip)(THIS_ BSTR FAR* pbstrVal) PURE;
    STDMETHOD(SetZip)(THIS_ BSTR bstrNewVal) PURE;
    STDMETHOD(GetIsoLanguage)(THIS_ DWORD FAR* pdwVal) PURE;
    STDMETHOD(SetIsoLanguage)(THIS_ DWORD dwNewVal) PURE;
    STDMETHOD(GetMSUpdate)(THIS_ BSTR FAR* pbstrVal) PURE;
    STDMETHOD(SetMSUpdate)(THIS_ BSTR bstrNewVal) PURE;
    STDMETHOD(GetMSOffer)(THIS_ BSTR FAR* pbstrVal) PURE;
    STDMETHOD(SetMSOffer)(THIS_ BSTR bstrNewVal) PURE;
    STDMETHOD(GetOtherOffer)(THIS_ BSTR FAR* pbstrVal) PURE;
    STDMETHOD(SetOtherOffer)(THIS_ BSTR bstrNewVal) PURE;
    STDMETHOD(GetAddress2)(THIS_ BSTR FAR* pbstrVal) PURE;
    STDMETHOD(SetAddress2)(THIS_ BSTR bstrNewVal) PURE;
    STDMETHOD(CheckSystemClock)(THIS_ DWORD FAR* pdwRetCode) PURE;
    STDMETHOD(GetExistingExpiryDate)(THIS_ DATE FAR* pDateVal) PURE;
    STDMETHOD(GetNewExpiryDate)(THIS_ DATE FAR* pDateVal) PURE;
    STDMETHOD(GetBillingFirstName)(THIS_ BSTR FAR* pbstrVal) PURE;
    STDMETHOD(SetBillingFirstName)(THIS_ BSTR bstrNewVal) PURE;
    STDMETHOD(GetBillingLastName)(THIS_ BSTR FAR* pbstrVal) PURE;
    STDMETHOD(SetBillingLastName)(THIS_ BSTR bstrNewVal) PURE;
    STDMETHOD(GetBillingPhone)(THIS_ BSTR FAR* pbstrVal) PURE;
    STDMETHOD(SetBillingPhone)(THIS_ BSTR bstrNewVal) PURE;
    STDMETHOD(GetBillingAddress1)(THIS_ BSTR FAR* pbstrVal) PURE;
    STDMETHOD(SetBillingAddress1)(THIS_ BSTR bstrNewVal) PURE;
    STDMETHOD(GetBillingAddress2)(THIS_ BSTR FAR* pbstrVal) PURE;
    STDMETHOD(SetBillingAddress2)(THIS_ BSTR bstrNewVal) PURE;
    STDMETHOD(GetBillingCity)(THIS_ BSTR FAR* pbstrVal) PURE;
    STDMETHOD(SetBillingCity)(THIS_ BSTR bstrNewVal) PURE;
    STDMETHOD(GetBillingState)(THIS_ BSTR FAR* pbstrVal) PURE;
    STDMETHOD(SetBillingState)(THIS_ BSTR bstrNewVal) PURE;
    STDMETHOD(GetBillingCountryCode)(THIS_ BSTR FAR* pbstrVal) PURE;
    STDMETHOD(SetBillingCountryCode)(THIS_ BSTR bstrNewVal) PURE;
    STDMETHOD(GetBillingZip)(THIS_ BSTR FAR* pbstrVal) PURE;
    STDMETHOD(SetBillingZip)(THIS_ BSTR bstrNewVal) PURE;
    STDMETHOD(SaveBillingInfo)(THIS_ BOOL bSave, DWORD FAR* pdwRetVal) PURE;
    STDMETHOD(IsCCRenewalCountry)(THIS_ BSTR bstrCountryCode, BOOL FAR* pbRetVal) PURE;
    STDMETHOD(GetVATLabel)(THIS_ BSTR bstrCountryCode, BSTR FAR* pbstrVATLabel) PURE;
    STDMETHOD(GetCCRenewalExpiryDate)(THIS_ DATE FAR* pDateVal) PURE;
    STDMETHOD(SetVATNumber)(THIS_ BSTR bstrVATNumber) PURE;
    STDMETHOD(SetCreditCardType)(THIS_ BSTR bstrCCCode) PURE;
    STDMETHOD(SetCreditCardNumber)(THIS_ BSTR bstrCCNumber) PURE;
    STDMETHOD(SetCreditCardExpiryYear)(THIS_ DWORD dwCCYear) PURE;
    STDMETHOD(SetCreditCardExpiryMonth)(THIS_ DWORD dwCCMonth) PURE;
    STDMETHOD(GetCreditCardCount)(THIS_ DWORD FAR* pdwCount) PURE;
    STDMETHOD(GetCreditCardCode)(THIS_ DWORD dwIndex, BSTR FAR* pbstrCode) PURE;
    STDMETHOD(GetCreditCardName)(THIS_ DWORD dwIndex, BSTR FAR* pbstrName) PURE;
    STDMETHOD(GetVATNumber)(THIS_ BSTR FAR* pbstrVATNumber) PURE;
    STDMETHOD(GetCreditCardType)(THIS_ BSTR FAR* pbstrCCCode) PURE;
    STDMETHOD(GetCreditCardNumber)(THIS_ BSTR FAR* pbstrCCNumber) PURE;
    STDMETHOD(GetCreditCardExpiryYear)(THIS_ DWORD FAR* pdwCCYear) PURE;
    STDMETHOD(GetCreditCardExpiryMonth)(THIS_ DWORD FAR* pdwCCMonth) PURE;
    STDMETHOD(GetDisconnectOption)(THIS_ BOOL FAR* pbRetVal) PURE;
    STDMETHOD(SetDisconnectOption)(THIS_ BOOL bNewVal) PURE;
    STDMETHOD(AsyncProcessHandshakeRequest)(THIS_ BOOL bReviseCustInfo) PURE;
    STDMETHOD(AsyncProcessNewLicenseRequest)(THIS) PURE;
    STDMETHOD(AsyncProcessReissueLicenseRequest)(THIS) PURE;
    STDMETHOD(AsyncProcessRetailRenewalLicenseRequest)(THIS) PURE;
    STDMETHOD(AsyncProcessReviseCustInfoRequest)(THIS) PURE;
    STDMETHOD(AsyncProcessCCRenewalPriceRequest)(THIS) PURE;
    STDMETHOD(AsyncProcessCCRenewalLicenseRequest)(THIS) PURE;
    STDMETHOD(GetAsyncProcessReturnCode)(THIS_ DWORD FAR* pdwRetCode) PURE;
    STDMETHOD(IsUpgradeAvailable)(THIS_ BOOL FAR* pbUpgradeAvailable) PURE;
    STDMETHOD(WantUpgrade)(THIS_ BOOL bWantUpgrade) PURE;
    STDMETHOD(AsyncProcessDroppedLicenseRequest)(THIS) PURE;
    STDMETHOD(GenerateInstallationId)(THIS_ BSTR FAR* pbstrVal) PURE;
    STDMETHOD(DepositConfirmationId)(THIS_ BSTR bstrVal, DWORD FAR* pdwRetCode) PURE;
    STDMETHOD(VerifyCheckDigits)(THIS_ BSTR bstrCIDIID, BOOL FAR* pbValue) PURE;
    STDMETHOD(GetCurrentExpiryDate)(THIS_ DATE FAR* pDateVal) PURE;
    STDMETHOD(CancelAsyncProcessRequest)(THIS_ BOOL bIsLicenseRequest) PURE;
    STDMETHOD(GetCurrencyDescription)(THIS_ DWORD dwCurrencyIndex, BSTR FAR* pbstrVal) PURE;
    STDMETHOD(GetPriceItemCount)(THIS_ DWORD FAR* pdwCount) PURE;
    STDMETHOD(GetPriceItemLabel)(THIS_ DWORD dwIndex, BSTR FAR* pbstrVal) PURE;
    STDMETHOD(GetPriceItemValue)(THIS_ DWORD dwCurrencyIndex, DWORD dwIndex, BSTR FAR* pbstrVal) PURE;
    STDMETHOD(GetInvoiceText)(THIS_ BSTR FAR* pNewVal) PURE;
    STDMETHOD(GetBackendErrorMsg)(THIS_ BSTR FAR* pbstrErrMsg) PURE;
    STDMETHOD(GetCurrencyOption)(THIS_ DWORD FAR* dwCurrencyOption) PURE;
    STDMETHOD(SetCurrencyOption)(THIS_ DWORD dwCurrencyOption) PURE;
    STDMETHOD(GetEndOfLifeHtmlText)(THIS_ BSTR FAR* pbstrHtmlText) PURE;
    STDMETHOD(DisplaySSLCert)(THIS_ DWORD FAR* dwRetCode) PURE;
};

DEFINE_GUID(IID_IMsoEServicesDialog,0x000C0372L,0x0000,0x0000,0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46);

/* Definition of interface: IMsoEServicesDialog */
#undef INTERFACE
#define INTERFACE IMsoEServicesDialog

DECLARE_INTERFACE_(IMsoEServicesDialog, IDispatch)
{
BEGIN_INTERFACE
#ifndef NO_BASEINTERFACE_FUNCS

    /* IUnknown methods */
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG, AddRef)(THIS) PURE;
    STDMETHOD_(ULONG, Release)(THIS) PURE;

    /* IDispatch methods */
    STDMETHOD(GetTypeInfoCount)(THIS_ UINT FAR* pctinfo) PURE;

    STDMETHOD(GetTypeInfo)(
      THIS_
      UINT itinfo,
      LCID lcid,
      ITypeInfo FAR* FAR* pptinfo) PURE;

    STDMETHOD(GetIDsOfNames)(
      THIS_
      REFIID riid,
      OLECHAR FAR* FAR* rgszNames,
      UINT cNames,
      LCID lcid,
      DISPID FAR* rgdispid) PURE;

    STDMETHOD(Invoke)(
      THIS_
      DISPID dispidMember,
      REFIID riid,
      LCID lcid,
      WORD wFlags,
      DISPPARAMS FAR* pdispparams,
      VARIANT FAR* pvarResult,
      EXCEPINFO FAR* pexcepinfo,
      UINT FAR* puArgErr) PURE;
#endif

    /* IMsoEServicesDialog methods */
    STDMETHOD(Close)(THIS_ VARIANT_BOOL ApplyWebComponentChanges) PURE;
    STDMETHOD(AddTrustedDomain)(THIS_ BSTR Domain) PURE;
    STDMETHOD(get_ApplicationName)(THIS_ BSTR FAR* RetVal) PURE;
    STDMETHOD(get_Application)(THIS_ IDispatch * FAR* ppdisp) PURE;
    STDMETHOD(get_WebComponent)(THIS_ IDispatch * FAR* ppdisp) PURE;
    STDMETHOD(get_ClipArt)(THIS_ IDispatch * FAR* ppdisp) PURE;
};

DEFINE_GUID(IID_WebComponentProperties,0x000C0373L,0x0000,0x0000,0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46);

/* Definition of interface: WebComponentProperties */
#undef INTERFACE
#define INTERFACE WebComponentProperties

DECLARE_INTERFACE_(WebComponentProperties, IDispatch)
{
BEGIN_INTERFACE
#ifndef NO_BASEINTERFACE_FUNCS

    /* IUnknown methods */
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG, AddRef)(THIS) PURE;
    STDMETHOD_(ULONG, Release)(THIS) PURE;

    /* IDispatch methods */
    STDMETHOD(GetTypeInfoCount)(THIS_ UINT FAR* pctinfo) PURE;

    STDMETHOD(GetTypeInfo)(
      THIS_
      UINT itinfo,
      LCID lcid,
      ITypeInfo FAR* FAR* pptinfo) PURE;

    STDMETHOD(GetIDsOfNames)(
      THIS_
      REFIID riid,
      OLECHAR FAR* FAR* rgszNames,
      UINT cNames,
      LCID lcid,
      DISPID FAR* rgdispid) PURE;

    STDMETHOD(Invoke)(
      THIS_
      DISPID dispidMember,
      REFIID riid,
      LCID lcid,
      WORD wFlags,
      DISPPARAMS FAR* pdispparams,
      VARIANT FAR* pvarResult,
      EXCEPINFO FAR* pexcepinfo,
      UINT FAR* puArgErr) PURE;
#endif

    /* WebComponentProperties methods */
    STDMETHOD(get_Shape)(THIS_ IDispatch * FAR* RetValue) PURE;
    STDMETHOD(get_Name)(THIS_ BSTR FAR* RetValue) PURE;
    STDMETHOD(put_Name)(THIS_ BSTR Name) PURE;
    STDMETHOD(get_URL)(THIS_ BSTR FAR* RetValue) PURE;
    STDMETHOD(put_URL)(THIS_ BSTR URL) PURE;
    STDMETHOD(get_HTML)(THIS_ BSTR FAR* RetValue) PURE;
    STDMETHOD(put_HTML)(THIS_ BSTR HTML) PURE;
    STDMETHOD(get_PreviewGraphic)(THIS_ BSTR FAR* RetValue) PURE;
    STDMETHOD(put_PreviewGraphic)(THIS_ BSTR PreviewGraphic) PURE;
    STDMETHOD(get_PreviewHTML)(THIS_ BSTR FAR* RetValue) PURE;
    STDMETHOD(put_PreviewHTML)(THIS_ BSTR PreviewHTML) PURE;
    STDMETHOD(get_Width)(THIS_ long FAR* RetValue) PURE;
    STDMETHOD(put_Width)(THIS_ long Width) PURE;
    STDMETHOD(get_Height)(THIS_ long FAR* RetValue) PURE;
    STDMETHOD(put_Height)(THIS_ long Height) PURE;
    STDMETHOD(get_Tag)(THIS_ BSTR FAR* RetValue) PURE;
    STDMETHOD(put_Tag)(THIS_ BSTR Tag) PURE;
};

#undef IAccessible

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Inc\office10\msouser.h ===
#pragma once

/****************************************************************************
	MsoUser.h

	Owner: DavePa
 	Copyright (c) 1994 Microsoft Corporation

	Declarations for common functions and interfaces required for apps
	to use the Office DLL.
****************************************************************************/

#ifndef MSOUSER_H
#define MSOUSER_H

#include "msodebug.h"

#include "msoiv.h" // Instrumented Version for Office9 #defines and typedef

#ifndef MSO_NO_INTERFACES
interface IMsoControlContainer;
#endif // MSO_NO_INTERFACES

/****************************************************************************
	The ISimpleUnknown interface is a variant on IUnknown which supports
	QueryInterface but not reference counts.  All objects of this type
	are owned by their primary user and freed in an object-specific way.
	Objects are allowed to extend themselves by supporting other interfaces
	(or other versions of the primary interface), but these interfaces
	cannot be freed without the knowledge and cooperation of the object's
	owner.  Hey, it's just like a good old fashioned data structure except
	now you can extend the interfaces.
****************************************************************** DAVEPA **/

#undef  INTERFACE
#define INTERFACE  ISimpleUnknown

DECLARE_INTERFACE(ISimpleUnknown)
{
	/* ISimpleUnknown's QueryInterface has the same semantics as the one in
		IUnknown, except that QI(IUnknown) succeeds if and only if the object
		also supports any real IUnknown interfaces, QI(ISimpleUnknown) always
		succeeds, and there is no implicit AddRef when an non-IUnknown-derived
		interface is requested.  If an object supports both IUnknown-derived
		and ISimpleUnknown-derived interfaces, then it must implement a
		reference count, but all active ISimpleUnknown-derived interfaces count
		as a single reference count. */
	MSOMETHOD(QueryInterface) (THIS_ REFIID riid, void **ppvObj) PURE;
};


/****************************************************************************
	HMSOINST is an opaque reference to an Office instance record.  Each
	thread of each EXE or DLL that uses Office must call MsoFInitOffice
	to init Office and get an HMSOINST.
****************************************************************** DAVEPA **/
#ifndef HMSOINST
typedef struct MSOINST *HMSOINST;  // MSOINST is defined only within Office
#endif

#include "msotc.h"

/****************************************************************************
	The IMsoUser interface has methods for Office to call back to the
	app for general information that is common across Office features.
****************************************************************** DAVEPA **/

#undef  INTERFACE
#define INTERFACE  IMsoUser

enum {
	msofmGrowZone = 1,
};

enum {
	msocchMaxShortAppId = 15
};


/*	dlgType sent to IMsoUser::FPrepareForDialog. Modal dialogs have LSB 0.*/
#define msodlgWindowsModal			0x00000000
#define msodlgWindowsModeless		0x00000001
#define msodlgSdmModal				0x00000010
#define msodlgSdmModeless			0x00000011
#define msodlgUIModalWinModeless	0x00000101
#define msodlgUIModalSdmModeless	0x00000111
#define msodlgSdmModalNWaitAct	0x00001000


// Notification codes for FNotifyAction methods
// Names containing 'Query' indicate app's return value is sought.  Other
// values are strictly to notify app.
enum
	{
	msonaStartHelpMode = 0,			// User entered Quick tip mode (Shift-F1).  App should update any internal state
	msonaEndHelpMode,					// Quick tip was displayed.  App should restore cursor.
	msonaBeforePaletteRealize,		// Office is going to realize one or more palettes, see comment below
	msonaQueryDisablePip,			// Gives the app the chance to refuse a .PIP file, should it not want one.
	msonaQueryInsertPicture,		// Asks the app if we can insert a picture
	msonaQueryAcbAware,				// Asks the app if it's fully aware of the Active ClipBoard
	msonaBeforeInitTFCBalloons,	// tells the app that TFC balloons are about to be initialized
	msonaAfterInitTFCBalloons,		// tells the app that TFC balloon initialization is over
	msonaAddinBeforeConnect,
	msonaAddinAfterConnect,
	msonaAddinBeforeDisconnect,
	msonaAddinAfterDisconnect
	};

// Subsystem classifications for FEmNotifyAction methods
enum
	{
	msoemssToolbar = 0,			// Command bars
	msoemssAppEm,					// App Event Monitor
	msoemssTip,						// Possible future feature: tip interface
	msoemssTimer,					// Possible future feature: timer notify
	};

/* About msonaBeforePaletteRealize:

	Office will call FNotifyAction(msonaBeforePaletteRealize) to let the app
	it's going to realize a palette. The app should start palette management
	if it has delayed doing so until it absolutely needs to.
	
	The app should select and realize a palette, and from now on, should
	respond to palette messages WM_QUERYNEWPALETTE and WM_PALETTECHANGED.
*/


DECLARE_INTERFACE(IMsoUser)
{
   /* Debuging interfacing for this interface */
   MSODEBUGMETHOD

	/* Return an IDispatch object for the Application object in 'ppidisp'
		Return fSuccess. */
	MSOMETHOD_(BOOL, FGetIDispatchApp) (THIS_ IDispatch **ppidisp) PURE;

	/* Return the long representing the application, as required by the
		"Creator" method of VBA objects. */
	MSOMETHOD_(LONG, LAppCreatorCode) (THIS) PURE;		//  REVIEW:  PETERO:  Is this MAC only?

	/* If the host does not support running macros then return FALSE,
		else check the macro reference in wtzMacro, which is in a 257 char buffer,
		for validity, modify it in-place if desired, and return TRUE if valid. 
		The object trying to attach the macro, if any, is given by 'pisu'.
		The format of macro references is defined by the host, but the typical
		simple case would be the name of a VBA Sub.  The host may delay
		expensive validation checks until FRunMacro as desired. */
	MSOMETHOD_(BOOL, FCheckMacro) (THIS_ WCHAR *wtzMacro, ISimpleUnknown *pisu) PURE;

	/* Run the macro given by the reference wtz (which has been checked for
		validity by FCheckMacro).  The object to which the macro is attached, 
		if any, is given by 'pisu'.  Return TRUE if successful (FALSE if the
		host does not support running macros). */
	MSOMETHOD_(BOOL, FRunMacro) (THIS_ WCHAR *wtzMacro, ISimpleUnknown *pisu,
										 VARIANT *pvarResult, VARIANT *rgvar,
										 int cvar) PURE;

	/* When a low memory condition occurs this callback method will be invoked.  The
		Application should free up cbBytesNeeded or more if it can.  Return back the
		actual number of bytes that were freed. */
	MSOMETHOD_(int, CbFreeMem) (THIS_ int cbBytesNeeded, int msofm) PURE;

	/* Office will call this in deciding whether or not to do certain actions
		that require OLE. */
	MSOMETHOD_(BOOL, FIsOleStarted) (THIS) PURE;

	/* Office will call this in deciding whether or not to do certain actions
		that require OLE. If the Application supports delayed OLE initialization
		and OLE has not been started, try to start OLE now.  Office makes no
		guarantee that it will cache the value returned here, so this may be
		called even after OLE has been started. */
	MSOMETHOD_(BOOL, FStartOle) (THIS) PURE;
	/* If a Picture Container is being created Office will call back to the IMsoUser
		to fill the Picture Container with control(s). */
	// TODO: TCoon unsigned int should be UCBK_SDM
	MSOMETHOD_(BOOL, FFillPictureContainer) (THIS_ interface IMsoControlContainer *picc,
															unsigned int tmc, unsigned int wBtn,
															BOOL *pfStop, int *pdx, int *pdy) PURE;
	/* The app should pass thru the parameters to WinHelp or the equivalent
		on the Mac */
	MSOMETHOD_(void, CallHelp)(THIS_ HWND hwnd, WCHAR *wzHelpFile, 
			UINT uCommand, DWORD dwData) PURE;
	// WHAT IS THIS? 
	/* The init call to initialize sdm. Get called when first sdm
	   dialog needs to come up. */
	MSOMETHOD_(BOOL, FInitDialog)(THIS) PURE;

	/* AutoCorrect functions. Used to inegrate this feature with the apps
		undo functionality and extended AC functionality in Word. */
	MSOMETHOD_(void, ACRecordVars)(THIS_ DWORD dwVars) PURE;
	MSOMETHOD_(BOOL, ACFFullService)(THIS) PURE;
	MSOMETHOD_(void, ACRecordRepl)(THIS_ int, WCHAR *wzFrom, WCHAR *wzTo) PURE;
	MSOMETHOD_(void, ACAdjustAC)(THIS_ int iwz, int idiwz) PURE;

	/* Return the CLSID of the application */
	MSOMETHOD_(void, GetAppClsid) (THIS_ LPCLSID *) PURE;

	/* Before and After doing a sdm dialog, call back to the application for
		them to do their own init and cleanup.
		The dlg parameter is a bitmap flags defined here as msodlgXXXX
		*/
 	MSOMETHOD_(BOOL, FPrepareForDialog) (THIS_ void **ppvDlg, int dlgType) PURE;
 	MSOMETHOD_(void, CleanupFromDialog) (THIS_ void *pvDlg) PURE;

	// Applications must provide a short (max 15 char + '\0') string which
	// identifies the application.  This string is used as the application ID
	// with ODMA.  This string may be displayed to the user, so it should be
	// localized.  But strings should be chosen so that localized versions
	// can often use the same string.  (For example, "MS Excel" would be a
	// good string for Excel to use with most Western-language versions.)  If
	// the file format changes for a localized version (eg. for Far East or
	// bi-di versions), a different string should be used for the localized
	// versions whose file format is different.  (It is assumed that all
	// versions with the same localized string can read each other's files.)
	// The application should copy the string into the buffer provided.
	// This string cannot begin with a digit.  The application can assume
	// that wzShortAppId points to a buffer which can hold msocchMaxShortAppId
	// Unicode characters plus a terminating '\0' character.
	// If you have questions, contact erikhan.
	MSOMETHOD_(void, GetWzShortAppId) (THIS_ WCHAR *wzShortAppId) PURE;

	MSOMETHOD_(void, GetStickyDialogInfo) (THIS_ int hidDlg, POINT *ppt) PURE;
	MSOMETHOD_(void, SetPointStickyDialog) (THIS_ int hidDlg, POINT *ppt) PURE;

	/* Called before command bars start tracking, and after they stop. Note
		that this will be called even in the HMenu cases, and on the Mac.
		Also, when real command bars start tracking, you are called on
		OnComponentActivate by the Component Manager. Make sure you know which
		callback you want to use.
		This callback is used by Excel to remove/put back a keyboard change they
		have on the Mac. */
	MSOMETHOD_(void, OnToolbarTrack) (THIS_ BOOL fStart) PURE;
	
	/* Notification that the action given by 'na' occurred.
		Return TRUE if the
		notification was processed.
	*/
	MSOMETHOD_(BOOL, FNotifyAction) (THIS_ int na) PURE;

	// TODO(JBelt): this callback is obsolete
	/* Called back by the Office Darwin layer to let the app hook up its additional
		Darwin tables. The MSOTCFCF structure is explained in detail in msotc.h.
		Fill pfcf with the structure.
		You will be called on this API the very first time Office encounters a
		file id which is outside its scope. This can't happen unless you called
		MsoFGimmeFile or one of its friends with such an id in the first place.
		Non-Darwinized apps can just do nothing here. */
	MSOMETHOD_(void, HookDarwinTables) (THIS_ MSOTCFCF *pfcf) PURE;

	/*  Handle all event monitor notifications.
		There was an action of interest to the event monitor in Office, such as
		toolbar	activity.  The 'subsystem' in which the action occurs is
		indicated by emss.  na is a subsystem-specific notify action
		identifier.  A negative valued na indicates a pre-action notification
		to the event monitor.  Not all events generate a pre-action, but all do
		generate a post-action.  Arguments are packed into the structure at
		pvArgs, in a subsystem and na-specific fashion.  pvArgs is maintained
		(i.e. allocated and freed, if necessary) entirely on the Office side.
		ppvEmNotify is provided for app-side communication between pre- and
		post-action notifications.  ppvEmNotify is maintained entirely by the
		application.
		Return TRUE from FEmNotifyAction if the notification was processed.
		Currently, the return value is only relevant in the case where TRUE
		is returned from a pre-action notification, in which case no
		post-action notification is sent for that event.
	*/
	MSOMETHOD_(BOOL, FEmNotifyAction) (THIS_ int emss, int na,
										void **ppvEmNotify, void *pvArgs) PURE;

	/* Called by an office for a button customized to be hyperlink passing the
	   mode in which the App should open the hyperlink provided in pwzSource
	   Return TRUE if app opened Hyperlink for the given mode
	          FALSE if hyperlink could not be opened/app doesn't care about it */
	MSOMETHOD_(BOOL, FOpenHyperlink) (THIS_ LPCWSTR pwzSource,LPCWSTR pwzLocation,
									  DWORD grfwtbnt,int mode) PURE;
};


/****************************************************************************
	IMsoUser10 is an Office10 extension of IMsoUser interface

	Office code cannot assume that clients implement IMsoUser10 interface.

****************************************************************** IgorZ **/

#undef  INTERFACE
#define INTERFACE  IMsoUser10

DECLARE_INTERFACE(IMsoUser10)
{
	MSOMETHOD_(HRESULT, HrOnMsoFInitOffice)(
		HWND hwndMain, 
		HINSTANCE hinstClient, 
		IMsoUser *piuser, 
		const WCHAR *wzHostName,
		HMSOINST *phinst,
		BOOL *pfHandled) PURE;

	MSOMETHOD_(void, OnMsoUninitOffice)(HMSOINST hinst, BOOL *pfHandled) PURE;
};


MSOAPI_(BOOL) MsoFSetInstIMsoUser10(HMSOINST hinst, IMsoUser10 *pUser10);


// NOTE: Another copy of this definition is in msosdm.h
#ifndef PFNFFillPictureContainer
typedef BOOL (MSOSTDAPICALLTYPE *PFNFFillPictureContainer) (interface IMsoControlContainer *picc,
														unsigned int tmc, unsigned int wBtn,
														BOOL *pfStop, int *pdx, int *pdy);
#endif
#ifndef PFNFFillPictureContainerEx
typedef BOOL (MSOSTDAPICALLTYPE *PFNFFillPictureContainerEx) (interface IMsoControlContainer *picc,
														unsigned int tmc, unsigned int wBtn,
														BOOL *pfStop, int *pdx, int *pdy, UINT *pufFlags);
#endif



// What does an application do when it needs mso to call it back sometime?
// It registers a callback, of course.  We have callbacks all over the place
// and it's about time they started coming together.  Here's a mechanism
// for registering a callback in a common way.
//
// First, the callback of interest is identified by an msocb constant.  The app
// determines which callback(s) it wants to register, and calls MsoFSetCallback.
// This will return the previously registered callback for that msocb.
//
// The callback signature should be defined for each msocb.
//
// --brianhi

typedef void (MSOSTDAPICALLTYPE * PFNGENERICCALLBACK)(void);

enum
{
	// msocbAddinGetIDispatch:  The addins object uses this callback to obtain
	// an IDispatch object from a host application.

	msocbAddinGetIDispatch = 0,		// use PFNADDINGETIDISPATCH

	// Add new callback types here

	msocbCallbackCount
};

typedef IDispatch * (MSOSTDAPICALLTYPE * PFNADDINGETIDISPATCH)(const WCHAR * pwzAddinPath);


MSOAPI_(PFNGENERICCALLBACK) MsoPfnSetCallback(UINT msocb, PFNGENERICCALLBACK pfn);	// returns previous callback
MSOAPI_(PFNGENERICCALLBACK) MsoPfnGetCallback(UINT msocb);



/*****************************************************************************
	Registry structure for initing MSO for MsoFLangChanged
*****************************************************************************/
typedef struct _MSOREGLANG
{
	int msoridAppRegistryLang;	// For ORAPI apps
	WCHAR* pwzAppRegistryLang;	// If above 0, used to get registry entry (FP)
}MSOREGLANG; 

#if VSMSODEBUG

/*****************************************************************************
	Block Entry structure for Memory Checking
*****************************************************************************/
typedef struct _MSOBE
{
	void* hp;
	int bt;
	unsigned cb;
	BOOL fAllocHasSize;
	HMSOINST pinst;
}MSOBE;


/****************************************************************************
	The IMsoDebugUser interface has Debug methods for Office to call back
   to the app for debugging information that is common across Office features.
****************************************************************** JIMMUR **/

#undef  INTERFACE
#define INTERFACE  IMsoDebugUser

DECLARE_INTERFACE(IMsoDebugUser)
{
   /* Call the MsoFSaveBe API for all of the structures in this application 
		so that leak detection can be preformed.  If this function returns 
		FALSE the memory check will be aborted. The lparam parameter if the 
		same lparam value passed to the MsoFChkMem API.  This parameter should 
		in turn be passed to the MsoFSaveBe API which this method should call 
		to write out its stuctures. */
   MSOMETHOD_(BOOL, FWriteBe) (THIS_ LPARAM) PURE;

   /* This callback allows the application to abort an on going memory check.
	   If this function return TRUE the memory check will be aborted.  
		If FALSE then the memory check will continue.  The application should 
		check its message queue to determine if the memory check should 
		continue.  The lparam paramater if the same lparam value passed to the 
		MsoFChkMem API.  This allows the application to supply some context if 
		it is required. */
   MSOMETHOD_(BOOL, FCheckAbort) (THIS_ LPARAM) PURE;

   /* This callback is called when duplicate items are  found in the heap.
      This provides a way for an applications to manage its referenced counted
		items.  The prgbe parameter is a pointer to the array of MSOBE records. The
		ibe parameter is the current index into that array.  The cbe parameter
		is the count of BEs in the array.  This method should look at the MSOBE in
		question and return back the next index that should checked.  A value of
		0 for the return value will designate that an error has occured.*/
   MSOMETHOD_(int, IbeCheckItem) (THIS_ LPARAM lParam, MSOBE *prgbe, int ibe, int cbe) PURE;

	/* This call back is used to aquire the strigstring name of a Bt. This is used
		when an error occurs during a memory integrity check.  Returning FALSE means
		that there is no string.*/
	MSOMETHOD_(BOOL, FGetSzForBt) (THIS_ LPARAM lParam, MSOBE *pbe, int *pcbsz,
												char **ppszbt) PURE;

	/* This callback is used to signal to the application that an assert is
		about to come up.  szTitle is the title of the assert, and szMsg is the
		message to be displayed in the assert, pmb contains the messagebox
		flags that will be used for the assert.  Return a MessageBox return code
		(IDABORT, IDRETRY, IDIGNORE) to stop the current assert processing and
		simulate the given return behavior.  Returns 0 to proceed with default
		assert processing.  The messagebox type can be changed by modifying
		the MB at *pmb.  iaso contains the type of assert being performed */
	MSOMETHOD_(int, PreAssert) (THIS_ int iaso, char* szTitle, char* szMsg, UINT* pmb) PURE;

	/* This callback is used to signal to the application that an assert has 
		gone away.  id is the MessageBox return code for the assert.  The return
		value is used to modify the MessageBox return code behavior of the
		assert handler */
	MSOMETHOD_(int, PostAssert) (THIS_ int id) PURE;
};

MSOAPI_(BOOL) MsoFWriteHMSOINSTBe(LPARAM lParam, HMSOINST hinst);
#endif // VSMSODEBUG


/****************************************************************************
	Initialization of the Office DLL
****************************************************************************/

/* Initialize the Office DLL.  Each thread of each EXE or DLL using the
	Office DLL must call this function.  On Windows, 'hwndMain' is the hwnd of
	the app's main window, and is used to detect context switches to other 
	Office apps, and to send RPC-styles messages from one office dll to another.
	On the Mac, this used to establish window ownership (for WLM apps), and can
	be NULL for non-WLM apps.  The 'hinst' is the HINSTANCE of 
	the EXE or DLL.  The interface 'piuser' must implement the IMsoUser 
	interface for this use of Office.  wzHostName is a pointer to the short name
	of the host to be used in menu item text. It must be no longer than 32
	characters including the null terminator.
	The HMSOINST instance reference
	for this use of Office is returned in 'phinst'.  Return fSuccess. */
MSOAPI_(BOOL) MsoFInitOffice(HWND hwndMain, HINSTANCE hinstClient, 
									  IMsoUser *piuser, const WCHAR *wzHostName,
									  HMSOINST *phinst);

/* As above, but establishes a app specific registry entry to check an apps last
	UI Language.  This is compared to the current UI lang and can then correctly
	tell the app and COM addins when the lang has changed under it. */
MSOAPI_(BOOL) MsoFInitOfficeEx(HWND hwndMain, HINSTANCE hinstClient, 
									  IMsoUser *piuser, const WCHAR *wzHostName,
									  HMSOINST *phinst, MSOREGLANG* pMLRApp);

/* Uninitialize the Office DLL given the HMSOINST as returned by
	MsoFInitOffice.  The 'hinst' is no longer valid after this call. */
MSOAPI_(void) MsoUninitOffice(HMSOINST hinst);

/* This API is called by when a new thread is created which may use the
   Office memory allocation functions. */
MSOAPI_(BOOL) MsoFInitThread(HANDLE hThread);

/* This API is called by when a thread is which may use the Office memory
	allocation functions is about to be destroyed. */
MSOAPI_(void) MsoUninitThread(void);

/* These APIs are called when a thread which may use the Office memory
   allocation functions has been suspended/resumed. */
MSOAPI_(void) MsoThreadSuspended(void);
MSOAPI_(void) MsoThreadResumed(void);

/* Load and register the Office OLE Automation Type Library by searching
	for the appropriate resource or file (don't use existing registry entries).  
	Return typelib in ppitl or just register and release if ppitl is NULL.
	Return HRESULT returned	from LoadTypeLib/RegisterTypeLib. */
MSOAPI_(HRESULT) MsoHrLoadTypeLib(ITypeLib **ppitl);

/* This API is used by Office clients in their implementation of 
	IVbaProjecSite::HostCheckReference. This API returns Minor version of a typelib
	that is still 100% binary compatible with the current version of a typelib 

	return HRESULT is:
		NOERROR if rgguid was handled.
		S_FALSE	if rgguid is not handled
*/
MSOAPI_(HRESULT) MsoHrCheckMsoTypeLibReference(int fSave, REFGUID rgguid, UINT *puMajor, UINT* puMinor);

/* Register everything that Office needs in the registry for a normal user
	setup (e.g. typelib, proxy interfaces).  Return NOERROR or an HRESULT
	error code. */
MSOAPI_(HRESULT) MsoHrRegisterAll();

/* Same as MsoHrRegisterAll except takes the szPathOleAut param which specifies 
	the path name to an alternate version of oleaut32.dll to load and use. */
MSOAPIX_(HRESULT) MsoHrRegisterAllEx(char *szPathOleAut);

/* Unregister anything that is safe and easy to unregister.
	Return NOERROR or an HRESULT error code. */
MSOAPIX_(HRESULT) MsoHrUnregisterAll();

/* Reset the hwndMain of the hinst to the passed in hwndMain.  -- Word::Stevera */
MSOAPI_(BOOL) MsoFSetInstHwndMain(HMSOINST hinst, HWND hwndMain);

/*	Apps can call this when they start to shutdown.  Office can use this to
	ignore subsequent clicks on the assistant, etc. */
MSOAPI_(void) MsoStartShutdown(void);

/* Apps can call this to get an IDispatch interface to the Answer Wizard object. */
MSOAPI_(BOOL) MsoFGetIDispatchAnswerWizard(HMSOINST hinst, IDispatch **ppidisp);

#if VSMSODEBUG
	/* Add the IMsoDebugUser interface to the HMSOINST instance reference.
	   Return fSuccess. */
	MSOAPI_(BOOL) MsoFSetDebugInterface(HMSOINST hinst, IMsoDebugUser *piodu);
	MSOAPI_(BOOL) MsoFGetDebugInterface(HMSOINST hinst, IMsoDebugUser **ppiodu);

#endif

#define msopuigrfFreeCtlMem  0x00000001

/* Used to Clean up the Office dll before calling MsoUninitOffice. Only called
	in rare or catastrophic events. 

	If you are planning to add a new grf, then you should make sure that there
	is NO other way of doing what you want to do before adding the new grf. 

	If you are planning to call MsoPreUnInitOffice you should try to find a
	better way to accomplish this and just let MsoUninitOffice do its job
	like it is supposed to.

	msopuigrfFreeCtlMem - used to free the CtlMem chain since app is dying 
					in a catastrophic way. Needs to be called before they
					overflow the stack.
	
*/
MSOAPI_(void) MsoPreUnInitOffice(HMSOINST hinst, DWORD grfUninit);

/****************************************************************************
	Other APIs of global interest
****************************************************************************/

/* A generic implementation of QueryInterface for an object given by pisu
	with a single ISimpleUnknown-derived interface given by riidObj.  
	Succeeds only if riidQuery == riidObj or ISimpleUnknown.  
	Returns NOERROR and pisu in *ppvObj if success, else E_NOINTERFACE. */
MSOAPI_(HRESULT) MsoHrSimpleQueryInterface(ISimpleUnknown *pisu, 
							REFIID riidObj, REFIID riidQuery, void **ppvObj);

/* Like MsoHrSimpleQueryInterface except succeeds for either riidObj1
	or riidObj2, returning pisu in both cases and therefore useful for
	inherited interfaces. */
MSOAPI_(HRESULT) MsoHrSimpleQueryInterface2(ISimpleUnknown *pisu, 
							REFIID riidObj1, REFIID riidObj2, REFIID riidQuery, 
							void **ppvObj);

/* This message filter is called for EVERY message the host app receives.
	If the procedure processes it should return TRUE otw FALSE. */
MSOAPI_(BOOL) FHandledLimeMsg(MSG *pmsg);


/*************************************************************************
	MSOGV -- Generic Value

	Currently we have a bunch of fields in Office-defined structures
	with names like pvClient, pvDgs, etc.  These are all declared as
	void *'s, but really they're just for the user of Office to stick
	some data in an Office structure.

	The problem with using void * and calling these fields pvFoo is that
	people keep assuming that you could legitimately compare them against
	NULL and draw some conclusion (like that you didn't need to call the
	host back to free	stuff).  This tended to break hosts who were storing
	indices in these fields.

	So I invented "generic value" (great name, huh?)  Variables of this
	type are named gvFoo.  Almost by definition, there is NO gvNil.

	This type will always be unsigned and always big enough to contain
	either a uint or a pointer.  We don't promise that this stays the
	same length forever, so don't go saving them in files.
************************************************************ PeterEn ****/
typedef void *MSOGV;
#define msocbMSOGV (sizeof(MSOGV))


/*************************************************************************
	MSOCLR -- Color

	This contains "typed" colors.  The high byte is the type,
	the low three are the data.  RGB colors have a "type" of zero.
	It'd be cool you could just cast a COLORREF to an MSOCR and have it
	work (for that to work we'd have to define RGB colors by something
	other than a zero high byte)

	TODO peteren:  These used to be called MSOCR, but cr was a really bad
	hungarian choice for this, it intersects with COLORREF all over the
	place an in the hosts.  I renamed it MSOCLR.  See if we can replace
	some of the "cr" with "clr"

	TODO peteren
	TODO johnbo

	We don't really use this type everywhere we should yet.
************************************************************ PeterEn ****/
typedef ULONG MSOCLR;
#define msocbMSOCLR (sizeof(MSOCLR))
#define msoclrNil   (0xFFFFFFFF)
#define msoclrBlack (0x00000000)
#define msoclrWhite (0x00FFFFFF)
#define msoclrNinch (0x80000001)
#define MsoClrFromCr(cr) ((MSOCLR)(cr & 0x00FFFFFF))
	/* Converts a Win32 COLORREF to an MSOCLR */

/* Old names, remove these */
#define MSOCR MSOCLR
#define msocbMSOCR msocbMSOCLR
#define msocrNil   msoclrNil
#define msocrBlack msoclrBlack
#define msocrWhite msoclrWhite
#define msocrNinch msoclrNinch

/* MsoFGetColorString returns the name of a color. We'll fill out WZ
	with a string of at most cchMax character, not counting the 0 at the end.
	We return TRUE on success.  If you give us a non-NULL pcch will set *pcch
	to the number of characters in the string.
	If you have a COLORREF you can convert with MsoClrFromCr(cr). */
MSOAPI_(BOOL) MsoFGetColorString(MSOCLR clr, WCHAR *wz, int cchMax, int *pcch);

/* MsoFGetSplitMenuColorString returns a string for a split menu.

	If idsItem is not msoidsNil, we'll just insert the string for idsItem
	into the string for idsPattern and return the result in wz.
	
	If idsItem is msoidsNil, we'll try to get a string from the MSOCLR
	using MsoFGetColorString.  If that fails, we'll use
	msoidsSplitMenuCustomItem. */
MSOAPI_(BOOL) MsoFGetSplitMenuColorString(int tcidPattern, int fItem, MSOCLR clr, 
												  WCHAR *wz, int cchMax, int *pcch);


/*************************************************************************
	Stream I/O Support Functions

  	MsoFByteLoad, MsoFByteSave, MsoFWordLoad, MsoFWordSave, etc.
	The following functions are helper functions to be used when loading or
	saving toolbar data using an OLE 2 Stream.  They take care of the stream
	I/O, byte swapping for consistency between Mac and Windows, and error
	checking.  They should be used in all FLoad/FSave callback functions. 
	MsoFWtzLoad expects wtz to point at an array of 257 WCHARs.  MsoFWtzSave
	will save an empty string if wtz is passed as NULL.
	
	SetLastError:  can be set to values from IStream's Read and Write methods
************************************************************ WAHHABB ****/
MSOAPIX_(BOOL) MsoFByteLoad(LPSTREAM pistm, BYTE *pb);
MSOAPIX_(BOOL) MsoFByteSave(LPSTREAM pistm, const BYTE b);
MSOAPI_(BOOL) MsoFWordLoad(LPSTREAM pistm, WORD *pw);
MSOAPI_(BOOL) MsoFWordSave(LPSTREAM pistm, const WORD w);
MSOAPI_(BOOL) MsoFLongLoad(LPSTREAM pistm, LONG *pl);
MSOAPI_(BOOL) MsoFLongSave(LPSTREAM pistm, const LONG l);
MSOAPIX_(BOOL) MsoFWtzLoad(LPSTREAM pistm, WCHAR *wtz);
MSOAPIX_(BOOL) MsoFWtzSave(LPSTREAM pistm, const WCHAR *wtz);


/****************************************************************************
	The IMSoPref (Preferences File) Interface provides a platform independent
	way to maintain settings, using a preferences file on the Macintosh, and
	a registry subkey on Windows
************************************************************** BenW ********/

#define inifAppOnly   1	// tons of these
#define inifExcelOnly 1 // tons of these.  Old comment:  /* EXCEL.INI only */
#define inifSysOnly   2	// only one use of this: xl\dde2.c
#define inifCache     4 // tons of these, but always ORed with inifApp|ExcelOnly?

// This order is assumed in util.cpp SET::CbQueryProfileItemIndex
enum
{
	msoprfNil = 0,
	msoprfInt = 1,
	msoprfString = 2,
	msoprfBlob = 3
};

#undef  INTERFACE
#define INTERFACE  IMsoPref

DECLARE_INTERFACE(IMsoPref)
{
	//*** FDebugMessage method ***
	MSODEBUGMETHOD

	// IMsoPref methods
	MSOMETHOD_(int, LQueryProfileInt) (THIS_ const WCHAR *, const WCHAR *, int, int) PURE;
	MSOMETHOD_(int, CchQueryProfileString) (THIS_ const WCHAR *wzSection,
			const WCHAR *wzKey, const WCHAR *wzDefault, WCHAR *wzValue,
			int cchMax, int inif) PURE;
	MSOMETHOD_(int, CbQueryProfileBlob) (THIS_ const WCHAR *, const WCHAR *, BYTE *, int, BYTE *, int, int) PURE;
	MSOMETHOD_(BOOL, FWriteProfileInt) (THIS_ const WCHAR *, const WCHAR *, int, int) PURE;
	MSOMETHOD_(BOOL, FWriteProfileString) (THIS_ const WCHAR *, const WCHAR *, const WCHAR *, int) PURE;
	MSOMETHOD_(BOOL, FWriteProfileBlob)(THIS_ const WCHAR *, const WCHAR *, const BYTE *, int, int) PURE;
	MSOMETHOD_(BOOL, FDelProfileSection)(THIS_ const WCHAR *) PURE;
	MSOMETHOD_(BOOL, CbQueryProfileItemIndex)	(THIS_ const WCHAR *wzSection, int ikey, WCHAR *wzKey, int cchMaxKey, BYTE *pbValue, int cbMaxValue, int *pprf, int inif) PURE;
};

enum
{
	msoprfUser = 0x0000,	// use HKEY_CURRENT_USER
	msoprfMachine = 0x0001,	// use HKEY_LOCAL_MACHINE
	msoprfIgnoreReg = 0x8000,	// always return defaults
};

MSOAPI_(BOOL) MsoFCreateIPref(const WCHAR *wzPref, 
		const WCHAR *wzUnused, long lUnused1, long lUnused2, 
		int prf, int wUnused3, IMsoPref **ppipref);

MSOAPI_(void) MsoDestroyIPref(IMsoPref *);

MSOAPIMX_(int) MsoCchGetUsersFilesFolder(WCHAR *wzFilename);

#ifdef MAPIVIM
/*	Returns the a full pathname to the MAPIVIM DLL in wzPath.   */
MSOAPI_(int) MsoFGetMapiPath(WCHAR* wzPath, BOOL fInstall);
#endif // MAPIVIM

MSOAPIMX_(WCHAR *) MsoWzGetKey(const WCHAR *wzApp, const WCHAR *wzSection, WCHAR *wzKey);


/*-------------------------------------------------------------------------
	MsoFGetCursorLocation

	Given the name of an animated cursor, returns the file where that cursor
	is found by looking up the name in the Cursors section of the Office prefs.
	
	On Windows, we return the name of a .CUR or .ANI file.
	On the Mac, we return the name of a single file which contains all the cursors.
	NULL means to use the cursors in the Office Shared Library.
	
	For Office 97, this is NYI on the Mac

	Returns fTrue is a cursor was found, fFalse otherwise.

------------------------------------------------------------------ BENW -*/
MSOAPI_(BOOL) MsoFGetCursorLocation(WCHAR *wzCursorName, WCHAR *wzFile);

/****************************************************************************
	The IMsoSplashUser interface is implemented by a user wishing to
	display a splash screen
************************************************************** SHAMIKB *****/

#undef  INTERFACE
#define INTERFACE  IMsoSplashUser

DECLARE_INTERFACE(IMsoSplashUser)
{
	MSOMETHOD_(BOOL, FCreateBmp) (THIS_ BITMAPINFO** pbi, void** pBits) PURE;
	MSOMETHOD_(BOOL, FDestroyBmp) (THIS_ BITMAPINFO* pbi, void* pBits) PURE;
	MSOMETHOD_(void, PreBmpDisplay) (THIS_ HDC hdcScreen, HWND hwnd, BITMAPINFO* pbi, void* pBits) PURE;
	MSOMETHOD_(void, PostBmpDisplay) (THIS_ HDC hdcScreen, HWND hwnd, BITMAPINFO *pbi, void* pBits) PURE;
	MSOMETHOD_(void, ProvideTextSize) (THIS_ HDC hdcScreen, HWND hwnd, DWORD* cxSize, DWORD* cySize) PURE;
	MSOMETHOD_(void, TextOnlyDisplay) (THIS_ HDC hdcScreen, HWND hwnd) PURE;
	MSOMETHOD_(void, TextDispose) (THIS) PURE;
};

// APIs for displaying splash screen

// Note:  The fDoHydra parameter for MsoFShowStartup is used to indicate support for the ProvideTextSize
// and TextOnlyDisplay interfaces, which are used to generate a text-only splash screen under Hydra.
// Passing FALSE will force full-bitmap splash screen display even under Hydra.
MSOAPI_(BOOL) MsoFShowStartup(HWND hwndMain, BITMAPINFO* pbi, void* pBits, IMsoSplashUser *pSplshUser, BOOL fDoHydra);
//MSOAPI_(void) MsoUpdateStartup();
#define MsoUpdateStartup()
MSOAPI_(void) MsoDestroyStartup();


/****************************************************************************
	Stuff about File IO
************************************************************** PeterEn *****/

/* MSOFO = File Offset.  This is the type in which Office stores seek
	positions in files/streams.  I kinda wanted to use FP but that's already
	a floating point quantity. Note that the IStream interfaces uses
	64-bit quantities to store these; for now we're just using 32.  These
	are exactly the same thing as FCs in Word. */
typedef ULONG MSOFO;
#define msofoFirst ((MSOFO)0x00000000)
#define msofoLast  ((MSOFO)0xFFFFFFFC)
#define msofoMax   ((MSOFO)0xFFFFFFFD)
#define msofoNil   ((MSOFO)0xFFFFFFFF)

/* MSODFO = Delta File Offset.  A difference between two MSOFOs. */
typedef MSOFO MSODFO;
#define msodfoFirst ((MSODFO)0x00000000)
#define msodfoLast  ((MSODFO)0xFFFFFFFC)
#define msodfoMax   ((MSODFO)0xFFFFFFFD)
#define msodfoNil   ((MSODFO)0xFFFFFFFF)


/*-----------------------------------------------------------------------------
	MSOEAD (Mso Encrytion Algorithm Descriptor
-------------------------------------------------------------------- HAILIU -*/
#define msoeadfOffice   0x1  // office implemented RC4 encryption
#define msoeadfXor      0x2  // very weak XOR encryption
#define msoeadfCryptAPI 0x4  // CryptAPI implemented encryption (could be any algorithm)
#define msoeadfExcludeDocProps 0x8 // Don't encrypt doc properterties
#define msoeadfMask     0x7  // mask to get the encryption type

typedef struct _msoead
	{
	DWORD   dwEadf;
	DWORD   cbExtra;   // forward compatibility
	int     algid;     // encryption algo id
	int     algidHash; // hashing algo id
	UINT    cbitKey;   // encryption key length
	DWORD   dwProvType;// provider type
	LPCWSTR wzProv;    // Crypt Service Provider name
	LPBYTE  pbExtra;   // forward compatibility
	} MSOEAD;


/****************************************************************************
	Defines the IMsoCryptSession interface

	Use this interface to encrypt or decrypt data.  In the future, perhaps
	the Crypto API can be hooked up underneath.  For now, the encryption will
	be linked to office directly.
***************************************************************** MarkWal **/
#undef INTERFACE
#define INTERFACE IMsoCryptSession

DECLARE_INTERFACE(IMsoCryptSession)
{
	MSODEBUGMETHOD

	/* discard this crypt session */
	MSOMETHOD_(void, Free) (THIS) PURE;

	/* reset the encryptor to a boundary state vs. continuing current
		stream.  iBlock indicates which block boundary to reset to. */
	MSOMETHOD_(void, Reset) (THIS_ unsigned long iBlock) PURE;

	/* encrypts the buffer indicated by pv inplace.  cb indicates
		how long the data is.  Encryption can change the length of the
		data if block algorithms are allowed via cbBlock non-zero on
		the call to MsoFCreateCryptSession.  In that case, *pcbNew is set
		to the new size of the buffer.  In any other case pcbNew may be NULL. */
	MSOMETHOD_(void, Crypt) (THIS_ unsigned char *pb, int cb, int *pcbNew) PURE;
	/* decrypts the buffer indicated by pv inplace.  cb indicates
		how long the data is.  Encryption can change the length of the
		data if block algorithms are allowed via cbBlock non-zero on
		the call to MsoFCreateCryptSession.  In that case, *pcbNew is set
		to the new size of the buffer.  In any other case pcbNew may be NULL. */
	MSOMETHOD_(void, Decrypt) (THIS_ PBYTE pb, int cb, int *pcbNew) PURE;

	/* set the password to the indicated string.  Also, resets the algorithm */
	MSOMETHOD_(BOOL, FSetPass) (THIS_ const WCHAR *wtzPass) PURE;

	/* if the encryption algorithm is a block algorithm, CbBlock indicates the
		block size.  A buffer passed in to Encrypt may grow to a CbBlock
		boundary. */
	MSOMETHOD_(int, CbBlock) (THIS) PURE;

	/* make this crypt session persistent so it can be loaded by 
		MsoFLoadCryptSession, stream should be positioned correctly
		before calling FSave and it will be positioned at the next byte
		when it returns */
	MSOMETHOD_(BOOL, FSave) (THIS_ LPSTREAM pistm) PURE;

	/* make a duplicate of this crypt session */
	MSOMETHOD_(BOOL, FClone) (THIS_ interface IMsoCryptSession **ppics) PURE;

	/* return the pead */
	MSOMETHOD_(MSOEAD*, Pead) (THIS) PURE;

	/* Set the encrpytion stream which contains all the encrypted sub storage
		When passed in, the stream pointer is assumed to be at 0. Caller must
		set fCreate to TRUE if the stream passed in is a blank stream (in save
		scenario). In load scenario, fCreate should be FALSE */
	MSOMETHOD(HrSetEncryptionStream)(THIS_ LPSTREAM pistm, BOOL fCreate) PURE;
	
	/* For encryption, add the storage to the encryption stream. If fReserve is
		TRUE, the function simply reserve the name wzStg so no one else can get
		use it. pistg is ignored in this case can be NULL. If fReserve is FALSE,
		then pistg can not be NULL, this method will stream pistg and encrypted
		the result stream in the encryption stream set through
		HrSetEncryptionStream */
	MSOMETHOD(HrAddStg)(THIS_ LPCWSTR wzStg, LPSTORAGE pistg, BOOL fReserve) PURE;
	
	/* For decryption, get the storage from the encrpytion stream
		This should be called to load back the stg saved through HrAddStg */
	MSOMETHOD(HrGetStg)(THIS_ LPCWSTR wzStg, LPSTORAGE *ppistg) PURE;

	/* Same as HrAddStg but with IStream */
	MSOMETHOD(HrAddStm)(THIS_ LPCWSTR wzStm, LPSTREAM pistm, BOOL fReserve) PURE;

	/* Same as HrGetStg but with IStream */
	MSOMETHOD(HrGetStm)(THIS_ LPCWSTR wzStm, LPSTREAM *ppistm) PURE;

	/* Write the lookup table for the encrypted sub-storage/stream. No more sub
		Elements can be added once this method is called */
	MSOMETHOD(HrWriteSubTable)(THIS) PURE;

	/* Get the stream back, the app usually doesn't need to call this method.
		The only exception is XL which use to method to enable it to save to a
		stg opened with STGM_SIMPLE */
	MSOMETHOD(HrGetEncryptionStream)(THIS_ LPSTREAM *ppistm) PURE;
};


/*-----------------------------------------------------------------------------
|	MSOAPI_	MsoFEncrypt
| Determine whether the languauge is French Standard	
|	
|	
|	Arguments:
|		None
|	
|	Returns:
|			BOOL: True if Language != French (Standard); else false
|	Keywords:
|	
------------------------------------------------------------SALIMI-----------*/
MSOAPI_(BOOL) MsoFEncrypt();


/*-----------------------------------------------------------------------------
	MsoFreePead
-------------------------------------------------------------------- HAILIU -*/
MSOAPI_(VOID) MsoFreePead(MSOEAD *pead);	


/*-----------------------------------------------------------------------------
	MsoPeadClone
-------------------------------------------------------------------- HAILIU -*/
MSOAPI_(MSOEAD*) MsoPeadClone(MSOEAD *pead);


#if VSMSODEBUG
/*-----------------------------------------------------------------------------
	MsoDebugPead
-------------------------------------------------------------------- HAILIU -*/
MSOAPI_(BOOL) MsoDebugPead(MSOEAD *pead, HMSOINST hinst, UINT dm, WPARAM wparam,
	LPARAM lparam);
#endif // VSMSODEBUG

/*-----------------------------------------------------------------------------
	MsoFChooseEncryptionAllowed

	Check registry setting and see if the admin has disabled user from choosing
	encryption algorithms. 
-------------------------------------------------------------------- HAILIU -*/
MSOAPI_(BOOL) MsoFChooseEncryptionAllowed(void);


/*-----------------------------------------------------------------------------
	MsoPeadGetDefault
-------------------------------------------------------------------- HAILIU -*/
MSOAPI_(MSOEAD*) MsoPeadGetDefault(DWORD grfead);


/*-----------------------------------------------------------------------------
	MsoPeadChoose
-------------------------------------------------------------------- HAILIU -*/
MSOAPI_(MSOEAD*) MsoPeadChoose(HWND hwndParent, HMSOINST hinst,
	MSOEAD *peadDefault, DWORD grfead);

/*-----------------------------------------------------------------------------
	MsoFCreateCryptSession

	Create a new crypt session accodring to pead. The created session will
	take owner ship of the pead (even if it fails). Therefore the caller should
	not call MsoFreePead or MsoDebugPead after calling this function. This is
	done to avoid cloning pead
-------------------------------------------------------------------- HAILIU -*/
MSOAPI_(BOOL) MsoFCreateCryptSession(const WCHAR *wtzPass, MSOEAD *pead,
	interface IMsoCryptSession **ppics, int cbBlock);


/*-----------------------------------------------------------------------------
	MsoFLoadCryptSession

	Load a crypt session
-------------------------------------------------------------------- HAILIU -*/
MSOAPI_(BOOL) MsoFLoadCryptSession(const WCHAR *wtzPass, IStream *pistm,
	interface IMsoCryptSession **ppics, MSOEAD **ppead, int cbBlock);


/*-----------------------------------------------------------------------------
	MsoBstrAlgoFromPead
-------------------------------------------------------------------- HAILIU -*/
MSOAPI_(BSTR) MsoBstrAlgoFromPead(MSOEAD *pead);


/*-----------------------------------------------------------------------------
	MsoBstrProvFromPead
-------------------------------------------------------------------- HAILIU -*/
MSOAPI_(BSTR) MsoBstrProvFromPead(MSOEAD *pead);

/*-----------------------------------------------------------------------------
	MsoPeadFromWzs
-------------------------------------------------------------------- HAILIU -*/
MSOAPI_(MSOEAD *) MsoPeadFromWzs(DWORD grfead, LPCWSTR wzProv, LPCWSTR wzAlgo,
	int cbitKey, BOOL fEncryptDocProps);
	

/*-----------------------------------------------------------------------------
	MsoFRecordPead
-------------------------------------------------------------------- HAILIU -*/
MSOAPI_(BOOL) MsoFRecordPead(MSOEAD *pead, UINT appId);


/****************************************************************************
	Office ZoomRect animation code
****************************************************************************/
MSOAPI_(void) MsoZoomRect(RECT *prcFrom, RECT *prcTo, BOOL fAccelerate, HRGN hrgnClip);
MSOAPI_(void) MsoZoomRectEx(RECT *prcFrom, RECT *prcTo, BOOL fAccelerate, HRGN hrgnClip, int delay);

// Idle Initialization stuff

// Idle Init structure
typedef struct tagMSOIDLEINIT
{
	BOOL (*pfnIdleInit)(void);
} MSOIDLEINIT;

/*---------------------------------------------------------------------------
	MsoFRegisterAppIdleInitTasks

	Register the app's idle init task list with the idle init manager.
---------------------------------------------------------------- EricSchr -*/
MSOAPIX_(BOOL) MsoFRegisterAppIdleInitTasks(MSOIDLEINIT *pAppIdleInit,
	DWORD cItems);

#if VSMSODEBUG
/*	Allows testing to turn off idle initialization at any desired point. */
MSOAPIXX_(void) MsoDisableIdleInit();
/*	Simulates plenty of idle time so that all idle init tasks are executed
	- tests that they all work. */
MSOAPIXX_(void) MsoDoAllIdleInit();
#endif

// Idle Init helper macros
#define IndexFromIif(iif)   ((iif) >> 8)
#define MaskFromIif(iif) ((iif) & 0xFF)

#define MsoMarkIdleInitDone(rgIdle, iif) \
	(rgIdle[IndexFromIif(iif)] |= MaskFromIif(iif))

#define MsoFIdleInitDone(rgIdle, iif) \
	(rgIdle[IndexFromIif(iif)] & MaskFromIif(iif))


/*---------------------------------------------------------------------------
	Office Reoccuring Idle definitions
----------------------------------------------------------------- MRuhlen -*/

EXTERN_C void __stdcall DeQueueDoAddCFF(void);  // defined in dmuoldoc.cpp
MSOAPI_(void) MsoDrawingDownloadIdle(void);     // defined in drevent.cpp

typedef struct tagMSOIDLEREOCCUR
{
	void (*pfnIdleReoccur)(void);
	DWORD msec;						// Minimum app uptime before calling
} MSOIDLEREOCCUR;

BOOL MsoFKickStartIdle(void);
void MsoResetIdleTickCount(void);

EXTERN_C DWORD vgffMsoIdleReoccur;
EXTERN_C BOOL  vgfIdleReoccurShutdown;

// idle reoccur flags
// one bit for each reoccuring idle task.


#define irfIdleReoccurStop              0x80000000
#define irfDeQueueDoAddCFF              0x00000001
#define irfAlertIdsCannotSuspendAtIdle  0x00000002
#define irfDRDownloadIdle               0x00000004
#define irfMsoForgetLastGimme           0x00000008
#define irfLicenseSelect                0x00000010
#define irfLicenseAction                0x00000020
#define irfAcbRenderThumbnails          0x00000040
#define irfLicenseEnsurePID             0x00000080
#define irfLicenseValidate              0x00000100
#define irfLicenseWizard                0x00000200
#define irfLicClockChecks               0x00000400


// Helper functions to remove and add a reoccuring idle task.  Pass one of the
// flags above to these to add or remove it from the reoccuring idle list.
// DO NOT USE THESE FROM OUTSIDE MSO.DLL

__inline void RemoveReoccuringIdleIrf(unsigned irf)
{
	vgffMsoIdleReoccur &= ~irf;
}

__inline void AddReoccuringIdleIrf(unsigned irf)
{
	vgffMsoIdleReoccur |= irf;
}

// Office10.233220 -- Access needs to know if reoccuring tasks are left
MSOAPI_(BOOL) MsoFHasReoccuringIdleTasks();


/*	On the Windows side we don't call OleInitialize at boot time - only
	CoInitialize. On the Mac side this is currently not being done because
	the Running Object Table is tied in with OleInitialize - so we can't
	call RegisterActiveObject if OleInitialize is not called - may
	want to revisit this issue. */

/*	Should be called before every call that requires OleInitialize to have
	been called previously. This function calls OleInitialize if it hasn't
	already been called. */
MSOAPI_(BOOL) MsoFEnsureOleInited();
/*	If OleInitialize has been called then calls OleUninitialize */
MSOAPI_(void) MsoOleUninitialize();

// Delayed Drag Drop Registration
/*	These routines are unnecessary on the Mac since Mac OLE doesn't require OLE
    to be initialized prior to using the drag/drop routines */
/*	All calls to RegisterDragDrop should be replaced by
	MsoHrRegisterDragDrop. RegisterDragDrop requires OleInitialize so
	during boot RegisterDragDrop should not be called. This function
	adds the drop target to a queue if OleInitialize hasn't already been
	called. If it has then it just calls RegisterDragDrop. */
MSOAPI_(HRESULT) MsoHrRegisterDragDrop(HWND hwnd, IDropTarget *pDropTarget);

/*	All calls to RevokeDragDrop should be replaced by
	MsoHrRevokeDragDrop. If a delayed queue of drop targets exists
	then this checks the queue first for the target. */
MSOAPI_(HRESULT) MsoHrRevokeDragDrop(HWND hwnd);

/*	Since all drop targets previously registered at boot time are now
	stored in a queue, we need to make sure we register them sometime.
	These can become drop targets
	a. if we are initiating a drag and drop - in which case we call this
	function before calling DoDragDrop (inside MsoHrDoDragDrop).
	b. while losing activation - so we might become the drop target of
	another app. So this function is called from the WM_ACTIVATEAPP
	message handler. */
MSOAPI_(BOOL) MsoFRegisterDragDropList();

/*	This function should be called instead of DoDragDrop - it first
	registers any drop targets that may be in the lazy init queue. */
MSOAPI_(HRESULT) MsoHrDoDragDrop(IDataObject *pDataObject,
	IDropSource *pDropSource, DWORD dwOKEffect, DWORD *pdwEffect);


/*	Module names MsoLoadModule supports */
/*  IF ANY THING IS CHANGED HERE - CHANGE GLOBALS.CPP! */

enum
{
	msoimodUser,		// System User
	msoimodGdi,			// System GDI
	msoimodWinnls,		// System International utilities
	#define msoimodGetMax (msoimodWinnls+1)
	
	msoimodShell,		// System Shell
	msoimodCommctrl,	// System Common controls
	msoimodOleAuto,		// System OLE automation
	msoimodCommdlg,		// System common dialogs
	msoimodVersion,		// System version APIs
	msoimodWinmm,		// System multimedia
	msoimodMapi,		// Mail
	msoimodHlink,		// Hyperlink APIs
	msoimodUrlmon,		// Url moniker APIs
	msoimodJet,			// Jet database
	msoimodOleAcc,		// OLE Accessibility
	msoimodWinsock,		// Network Sockets
	msoimodMpr,			// Windows Network
	msoimodOdma,		// odma
	msoimodWininet,		// internet stuff
	msoimodRpcrt4,		// RPC
	msoimodDarwin,		// Darwin
	msoimodCrypt32,	// crypto dll - digital signing
	msoimodWintrust,	// wintrust.dll - digital signing
	msoimodCryptdlg,	// cryptdlg.dll - digital signing
	msoimodSigner,		// signer.dll - digital signing
	msoimodSoftpub,	// softpub.dll - digital signing
	msoimodAdvapi32,	// advapi32.dll - digital signing
	msoimodVbe,
	msoimodRichEdit,    // Richedit dll 
	msoimodMsoHev,		// Msohev.dll
	msoimodMssign32,	// mssign32.dll - digital signing
	msoimodOlepro32,    // olepro32.dll - OleCreateFontIndirect & OldCreatePictureIndirect
	msoimodCryptui,	// cryptui.dll - IE5 digital signing
	msoimodIE5Crypt32,	// IE5 crypto dll - digital signing
	msoimodWinspool,    // winspool.drv
	msoimodKernel32,    // kernel32.dll
	msoimodShlwapi,		// shlwapi.dll
	msoimodActiveds,        // activeds.dll - Active Directory dll
	msoimodWFF,         // ippwff.dll - IWebFolderForms dll
	msoimodNetapi32,        // netapi32.dll - Network API
	msoimodWtsapi32,	// WTS Api's
	msoimodMscat32,     // mscat32.dll - digital signing
	msoimodMax,
};

/* ifn enums for Modules loaded by MsoLoadModule */
/* THE ORDER MUST MATCH THAT IN GLOBALS.CPP! -- MRuhlen */

enum
{
	ifnFindTextA,
	ifnFindTextW,
	ifnReplaceTextA,
	ifnReplaceTextW,
	ifnGetFileTitleA,
	ifnGetFileTitleW,
	ifnCommDlgExtendedError,

	cfnCommdlg
};	


enum
{
	ifnGetFileVersionInfoA,
	ifnGetFileVersionInfoSizeA,
	ifnVerQueryValueA,
	ifnGetFileVersionInfoW,
	ifnGetFileVersionInfoSizeW,
	ifnVerQueryValueW,

	cfnVersion
};

enum
{
	ifnSHGetDesktopFolder,
	ifnSHGetMalloc,
	ifnSHGetPathFromIDList,
	ifnSHGetPathFromIDListW,
	ifnSHGetDataFromIDListA,
	ifnSHGetDataFromIDListW,
	ifnSHBrowseForFolderA,
	ifnSHBrowseForFolderW,
	ifnSHGetSpecialFolderLocation,
	ifnSHGetFileInfoA,
	ifnSHGetFileInfoW,
	ifnExtractIconExA,
	ifnExtractIconW,
	ifnDllGetClassObject,
	ifnDragQueryPoint,
	ifnDragQueryFileA,
	ifnDragQueryFileW,
	ifnDragFinish,
	ifnDragAcceptFiles,
	ifnExtractIconA,
	ifnShellExecuteA,
	ifnShellExecuteW,
	ifnShellExecuteExA,
	ifnShellExecuteExW,
	ifnSHAppBarMessage,
	ifnFindExecutableA,
	ifnFindExecutableW,
	ifnInvalidateDriveType,
	ifnSHGetSpecialFolderPath,
	ifnSHChangeNotify,
	ifnSHAddToRecentDocs,
	ifnSHFileOperationA,
	ifnSHFileOperationW,
	ifnExtractIconExW,
	ifnSHCoCreateInstance,
	ifnCIDLData_CreateFromIDArray,
	ifnSHCreateLinks,
	ifnShell_NotifyIconA,
	cfnShell
};

enum
{
	ifnVariantInit,
	ifnVariantClear,
	ifnVariantChangeType,
	ifnVariantChangeTypeEx,
	ifnVariantTimeToDosDateTime,
	ifnDosDateTimeToVariantTime,
	ifnSysAllocString,
	ifnSysAllocStringLen,
	ifnSysFreeString,
	ifnSysStringLen,
	ifnSafeArrayGetDim,
	ifnSafeArrayAccessData,
	ifnSafeArrayUnaccessData,
	ifnSafeArrayGetUBound,
	ifnSafeArrayGetLBound,
	ifnLoadRegTypeLib,
	ifnLoadTypeLib,
	ifnQueryPathOfRegTypeLib,
	ifnVariantCopy,
	ifnSafeArrayCreate,
	ifnSafeArrayDestroy,
	ifnSafeArrayGetElement,
	ifnRegisterTypeLib,
	ifnCreateErrorInfo,
	ifnSetErrorInfo,
	ifnGetErrorInfo,
	ifnGetActiveObject,
	ifnSysReAllocStringLen,
	ifnSysReAllocString,
	ifnSysAllocStringByteLen,
	ifnSafeArrayUnlock,
	ifnSafeArrayLock,
	ifnOleCreatePropertyFrameIndirect,
	ifnSysStringByteLen,
	ifnSafeArrayRedim,
	ifnSystemTimeToVariantTime,
	ifnSafeArrayGetElemsize,
	ifnVarBstrFromR8,
	ifnOleLoadPicture,
	ifnRevokeActiveObject,
	ifnRegisterActiveObject,
	ifnDispGetIDsOfNames,
	ifnDispInvoke,
	ifnCreateTypeLib2,
	ifnLHashValOfNameSys,
	ifnVarDateFromUdate,
	ifnVarUdateFromDate,
	ifnGetAltMonthNames,
	ifnSafeArrayPutElement,
	ifnVariantCopyInd,
	ifnSafeArrayAllocData,
	ifnSafeArrayDestroyData,
	ifnVarR4FromR8,
	ifnVarR8FromR4,
	ifnOaBuildVersion,
	ifnLoadTypeLibEx,
	ifnVariantTimeToSystemTime,
	ifnSafeArrayCopy,
	ifnUnRegisterTypeLib,
	ifnSafeArrayPtrOfIndex,
	cfnOleAuto
};

enum
{
	ifnImageList_Destroy,
	ifnImageList_Create,
	ifnImageList_Replace,
	ifnImageList_ReplaceIcon,
	ifnImageList_GetImageCount,
	ifnPropertySheetA,
	ifnPropertySheetW,
	ifnCreateToolbarEx,
	ifnImageList_SetBkColor,
	ifnImageList_GetBkColor,
	ifnImageList_Draw,
	ifnImageList_DrawEx,
	ifnImageList_GetIconSize,
	ifnImageList_SetIconSize,
	ifnImageList_AddMasked,
	ifnInitCommonControls,
	ifnInitCommonControlsEx,
	ifnImageList_LoadImageA,
	ifnImageList_LoadImageW,
	ifnImageList_Add,
	ifnImageList_AddIcon,
	ifnImageList_Merge,
	ifnImageList_GetIcon,
	ifnImageList_SetImageCount,
	ifnImageList_Read,
	ifnImageList_Write,
	ifnImageList_Copy,
	ifnImageList_SetOverlayImage,
	ifnImageList_Remove,
	ifnImageList_BeginDrag,
	ifnImageList_DragEnter,
	ifnImageList_DragLeave,
	ifnImageList_DragMove,
	ifnImageList_EndDrag,
	ifnTrackMouseEvent,
	
	cfnCommctrl
};

enum
{
	ifnHlinkCreateFromMoniker,
	ifnHlinkCreateFromString,
	ifnHlinkCreateFromData,
	ifnHlinkCreateBrowseContext,
	ifnHlinkClone,
	ifnHlinkNavigateToStringReference,
	ifnHlinkOnNavigate,
	ifnHlinkUpdateStackItem,
	ifnHlinkOnRenameDocument,
	ifnHlinkNavigate,
	ifnHlinkResolveMonikerForData,
	ifnHlinkResolveStringForData,
	ifnHlinkParseDisplayName,
	ifnHlinkQueryCreateFromData,
	ifnHlinkSetSpecialReference,
	ifnHlinkGetSpecialReference,
	ifnHlinkCreateShortcut,
	ifnHlinkResolveShortcut,
	ifnHlinkIsShortcut,
	ifnHlinkResolveShortcutToString,
	ifnHlinkCreateShortcutFromString,
	ifnHlinkGetValueFromParams,
	ifnHlinkCreateShortcutFromMoniker,
	ifnHlinkResolveShortcutToMoniker,
	ifnHlinkTranslateURL,
	ifnHlinkCreateExtensionServices,
	ifnHlinkPreprocessMoniker,
	cfnHlink
};

enum
{
	ifnCreateURLMoniker,
	ifnIsValidURL,
	ifnRegisterMediaTypeClass,
	ifnRegisterBindStatusCallback,
	ifnURLOpenBlockingStreamW,
	ifnRevokeBindStatusCallback,
#ifdef UNUSED
	ifnURLDownloadToFileW,
	ifnURLDownloadToCacheFileW,
#endif // UNUSED
	ifnCoInternetCombineUrl,
	ifnCoInternetGetSession,
	ifnFindMimeFromData,
	ifnCoInternetCreateZoneManager,
	ifnCoInternetParseUrl,
	ifnCreateAsyncBindCtxEx,
	ifnUrlMkGetSessionOption,
	ifnUrlMkSetSessionOption,
	ifnCoInternetCompareUrl,
	ifnCopyStgMedium,
	ifnReleaseBindInfo,
	ifnCoInternetQueryInfo,
	cfnUrlmon
};

enum
{
	ifnMAPIAllocateBuffer,
	ifnMAPIFreeBuffer,
	ifnHrQueryAllRows,
	ifnMAPIAllocateMore,
	ifnMAPILogon,
	ifnMAPILogoff,
	ifnMAPIAddress,
	ifnMAPIResolveName,
	ifnMAPISendMail,
	ifnMAPIInitialize,
	ifnMAPIUninitialize,
	ifnMAPILogonEx,
	ifnMAPIOpenFormMgr,
	ifnMAPIAdminProfiles,
	cfnMapi
};

enum
{
	ifnJetBeginSession,
	ifnJetCloseDatabase,
	ifnJetCloseTable,
	ifnJetEndSession,
	ifnJetGetObjectInfo,
	ifnJetInit,
	ifnJetMove,
	ifnJetOpenDatabase,
	ifnJetRetrieveColumn,
	ifnJetRetrieveProperty,
	ifnJetTerm,
	ifnJetGetTableColumnInfo,
	cfnJet
};

enum
{
	ifnLresultFromObject,
	ifnObjectFromLresult,
	ifnAccessibleObjectFromWindow,
	ifnCreateStdAccessibleObject,
	cfnOleAcc
};

enum
{
	ifnGetAddressByNameA,
	ifnGetAddressByNameW,
	ifnWSAStartup,
	ifnWSACleanup,
	cfnWinsock
};

enum
{
	ifnWNetAddConnection2W,
	ifnWNetAddConnection3W,
	ifnWNetAddConnectionW,
	ifnWNetCancelConnectionW,
	ifnWNetConnectionDialog,
	ifnWNetEnumResourceW,
	ifnWNetGetConnectionW,
	ifnWNetOpenEnumW,
	ifnWNetCloseEnum,
	ifnWNetGetLastErrorW,
	ifnWNetUseConnectionW,
	ifnWNetGetNetworkInformationW,
	ifnWNetAddConnection2A,
	ifnWNetAddConnection3A,
	ifnWNetAddConnectionA,
	ifnWNetCancelConnectionA,
	ifnWNetEnumResourceA,
	ifnWNetGetConnectionA,
	ifnWNetOpenEnumA,
	ifnWNetGetLastErrorA,
	ifnWNetUseConnectionA,
	ifnWNetGetNetworkInformationA,
	ifnWNetGetResourceInformationW,
	ifnWNetGetResourceInformationA,
	cfnMpr
};

enum
{
	ifnInternetCloseHandle,
	ifnInternetWriteFile,
	ifnInternetOpenA,
	ifnInternetOpenW,
	ifnInternetConnectA,
	ifnInternetConnectW,
	ifnFtpOpenFileA,
	ifnFtpGetFileA,
	ifnFtpSetCurrentDirectoryA,
	ifnFtpGetCurrentDirectoryA,
	ifnInternetFindNextFileA,
	ifnFtpFindFirstFileA,
	ifnInternetCombineUrlA,
	ifnGetUrlCacheConfigInfoA,
	ifnInternetCanonicalizeUrlA,
	ifnInternetCanonicalizeUrlW,
	ifnFtpRenameFileA,
	ifnFtpDeleteFileA,
	ifnFtpCreateDirectoryA,
	ifnFtpRemoveDirectoryA,
	ifnInternetCrackUrlA,
	ifnInternetCrackUrlW,
	ifnInternetGetLastResponseInfoW,
	ifnInternetReadFile,
	ifnHttpOpenRequestW,
	ifnHttpOpenRequestA,
	ifnHttpSendRequestW,
	ifnHttpSendRequestA,
	ifnHttpQueryInfoW,
	ifnHttpQueryInfoA,
	ifnInternetGetCookieW,
	ifnInternetSetOptionW,
	ifnInternetSetOptionA,
	ifnCreateUrlCacheEntryW,
	ifnCreateUrlCacheEntryA,
	ifnCommitUrlCacheEntryW,
	ifnCommitUrlCacheEntryA,
	ifnGetUrlCacheEntryInfoW,
	ifnGetUrlCacheEntryInfoA,
	ifnFindFirstUrlCacheEntryExW,
	ifnFindFirstUrlCacheEntryExA,
	ifnFindNextUrlCacheEntryExW,
	ifnFindNextUrlCacheEntryExA,
	ifnFindFirstUrlCacheEntryA,
	ifnFindNextUrlCacheEntryA,
	ifnFindFirstUrlCacheEntryW,
	ifnFindNextUrlCacheEntryW,
	ifnFindCloseUrlCache,
	ifnSetUrlCacheEntryGroupW,
	ifnSetUrlCacheEntryGroupA,
	ifnInternetQueryOptionW,
	ifnInternetQueryOptionA,
	ifnInternetOpenUrlW,
	ifnInternetOpenUrlA,
	ifnInternetGetConnectedState,
	ifnInternetAutodial,
	ifnInternetAutodialHangup,
	ifnInternetErrorDlg,
	ifnInternetGoOnlineA,
	ifnInternetGetConnectedStateExW,
	cfnWininet
};

enum
{
	ifnODMSelectDoc,
	cfnOdma
};

enum
{
	ifnPlaySoundA,
	ifnPlaySoundW,
	ifnwaveOutGetNumDevs,
	cfnWinMM
};

enum
{
	ifnNdrDllGetClassObject,
	ifnNdrDllCanUnloadNow,
	ifnNdrCStdStubBuffer_Release,
	ifnCStdStubBuffer_DebugServerRelease,
	ifnCStdStubBuffer_DebugServerQueryInterface,
	ifnCStdStubBuffer_CountRefs,
	ifnCStdStubBuffer_IsIIDSupported,
	ifnCStdStubBuffer_Invoke,
	ifnCStdStubBuffer_Disconnect,
	ifnCStdStubBuffer_Connect,
	ifnCStdStubBuffer_AddRef,
	ifnCStdStubBuffer_QueryInterface,
	ifnIUnknown_Release_Proxy,
	ifnIUnknown_AddRef_Proxy,
	ifnIUnknown_QueryInterface_Proxy,
	ifnNdrOleFree,
	ifnNdrOleAllocate,
	ifnNdrClientCall,
	cfnRpcrt4
};

enum
{
	ifnMsiGetProductCodeW,
	ifnMsiGetComponentPathW,
	ifnMsiReinstallFeatureW,
	ifnMsiReinstallProductW,
	ifnMsiQueryFeatureStateW,
	ifnMsiQueryProductStateW,
	ifnMsiUseFeatureW,
	ifnMsiGetUserInfoW,
	ifnMsiInstallMissingFileW,
	ifnMsiSetInternalUI,
	ifnMsiInstallProductW,
	ifnMsiEnumComponentQualifiersW,
	ifnMsiProvideQualifiedComponentW,
	ifnMsiVerifyPackageW,
	ifnMsiConfigureFeatureW,
	ifnMsiConfigureProductW,
	ifnMsiConfigureProductExW,
	ifnMsiProvideComponentW,
	ifnMsiInstallMissingComponentW,
	ifnMsiEnableLogW,
	ifnMsiCollectUserInfoW,
	ifnMsiGetProductInfoW,
	ifnMsiSetExternalUIW,
	ifnMsiUseFeatureExW,
	ifnMsiProvideQualifiedComponentExW,
	ifnMsiLocateComponentW,
	ifnMsiEnumComponentQualifiersA,
	ifnMsiEnumClientsW,
	ifnMsiEnumFeaturesW,
	ifnMsiGetFeatureUsageW,
	ifnMsiViewExecute,
	ifnMsiDatabaseOpenViewW,
	ifnMsiOpenDatabaseW,
	ifnMsiCloseHandle,
	ifnMsiRecordGetStringW,
	ifnMsiViewFetch,
	ifnMsiRecordIsNull,
	ifnMsiEnumComponentsW,
	cfnDarwin
};

enum
{
	ifnCertCloseStore,
	ifnCertFreeCertificateContext,
	ifnCertSaveStore,
	ifnCertAddCertificateContextToStore,
	ifnCertOpenStore,
	ifnCertFindCertificateInStore,
	ifnCertAlgIdToOID,
	ifnCryptExportPublicKeyInfo,
	ifnCertGetCertificateContextProperty,
	ifnCryptSIPAddProvider,
	ifnCryptSIPRemoveProvider,
	ifnCertNameToStrW,
	ifnCryptHashCertificate,
	ifnCertOpenSystemStoreA,
	ifnCertGetEnhancedKeyUsage,
	ifnCryptImportPublicKeyInfo,
	ifnCertAddEncodedCertificateToStore,
	ifnCertVerifyTimeValidity,
	ifnCertCompareCertificate,
	ifnCertEnumCertificatesInStore,
	ifnCertDuplicateCertificateContext,
	ifnCertDeleteCertificateFromStore,
	ifnCertGetSubjectCertificateFromStore,
	ifnCertCompareCertificateName,
	ifnCertGetIssuerCertificateFromStore,
	ifnCertVerifySubjectCertificateContext,
	ifnCryptDecodeObject,
	ifnCryptMsgGetParam,
	ifnCryptMsgClose,
	ifnCryptMsgUpdate,
	ifnCryptMsgOpenToDecode,
	ifnCryptImportPublicKeyInfoEx,
	ifnCertComparePublicKeyInfo,
	ifnCertCreateCertificateContext,
	ifnCertFindExtension,
	ifnCryptSignCertificate,
	ifnCryptEncodeObject,
	cfnCrypt32
};

enum
{
	ifnCertFreeCertificateChain,
	ifnCertGetCertificateChain,
	ifnCertVerifyCertificateChainPolicy,
	ifnCertFreeCertificateChainEngine,
	ifnCertCreateCertificateChainEngine,
	ifnCryptQueryObject,
	ifnCertGetNameStringW,
	ifnCryptFindCertificateKeyProvInfo,
	cfnIE5Crypt32
};

enum
{
	ifnWinVerifyTrust,
	ifnWintrustAddActionID,
	ifnWTHelperGetProvCertFromChain,
	ifnWTHelperGetProvSignerFromChain,
	ifnWintrustLoadFunctionPointers,
	ifnWTHelperCertIsSelfSigned,
	ifnWTHelperProvDataFromStateData,
	cfnWintrust
};

enum
{
	ifnCertSelectCertificateA,
	ifnGetFriendlyNameOfCertW,
	ifnCertViewPropertiesA,
	cfnCryptdlg
};

enum
{
	ifnSignerSign,
	ifnSignerTimeStamp,
	cfnSigner
};

enum
{
	ifnSoftpubAuthenticode,
	cfnSoftpub
};

enum
{
	ifnCryptAcquireContextA,
	ifnCryptReleaseContext,
	ifnCheckTokenMembership,
	ifnCryptAcquireContextW,
	cfnAdvapi32
};

enum
{
	ifnDllVbeGetHashOfCode,
	cfnVbe
};

enum
{
	ifnPHevCreateFileInfo,
	ifnWHevParseFile,
	ifnFHevActivateApp,
	ifnHevDestroyFileInfo,
	ifnFHevRegister,
	ifnFHevSetDefaultEditor,
	ifnWHeviAppFromProgId,
	ifnFHevAddToFileInfo,
	ifnHevFGetProgIDFromFile,
	ifnHevFGetCreatorAppIcon,
	ifnHevFGetCreatorAppName,
	ifnHevFQueryDefaultEditor,
	ifnHevFSetExtraData,
	ifnHevFCheckNonMSApp,
	cfnMsoHev
};

enum
{
	ifnSignerSignEx,
	ifnSignerFreeSignerContext,
	ifnSignerTimeStampEx,
	cfnMssign32
};

enum
{
    ifnOleCreateFontIndirect,
    ifnOleCreatePictureIndirect,
    cfnOlepro32
};

enum
{
	ifnCryptUIDlgViewCertificateA,
	ifnCryptUIDlgSelectCertificateA,
	ifnCryptUIDlgViewSignerInfoA,
	cfnCryptui
};

enum
{
	ifnGetPrinterW,
	ifnGetPrinterA,
	ifnDeviceCapabilitiesW,
	ifnDeviceCapabilitiesA,
	ifnOpenPrinterW,
	ifnOpenPrinterA,
	ifnDocumentPropertiesW,
	ifnDocumentPropertiesA,
	ifnEnumPrintersA,
	ifnEnumJobsA,
	ifnGetPrinterDriverA,
	ifnClosePrinter,
	ifnEnumPrintersW,
	ifnEnumJobsW,
	ifnGetPrinterDriverW,
	ifnAddPrinterDriverA,
	ifnAddPrinterDriverW,
	ifnGetPrinterDriverDirectoryA,
	ifnGetPrinterDriverDirectoryW,
	ifnDeletePrinter,
	ifnAddPrinterA,
	ifnAddPrinterW,
	ifnAddPrinterConnectionW,
	cfnWinspool
};

enum
{
	ifnGetLongPathNameA,
	ifnGetLongPathNameW,
	ifnProcessIdToSessionId,
	cfnKernel32
};

enum
{
	ifnPathQuoteSpacesW,
	ifnPathFindFileNameW,
	ifnPathRemoveArgsW,
	ifnPathUnquoteSpacesW,
	ifnPathRemoveFileSpecW,
	ifnPathIsURLW,
	ifnSHOpenRegStreamA,
	ifnSHOpenRegStreamW,

	cfnShlwapi
};

enum
{
	ifnADsOpenObject,

	cfnActiveds
};

enum
{
	ifnGetIWFFPtr,
	cfnWFF
};

enum
{
   ifnNetbios,
   cfnNetapi32
};

enum
{
	ifnWTSQuerySessionInformationW,
	ifnWTSFreeMemory,
	cfnWtsapi32
};

enum
{
	ifnCryptCATAdminCalcHashFromFileHandle,
	cfnMscat32
};

// we don't bother loading any functions out of these modules
#define cfnUser 0
#define cfnGdi 0
#define cfnWinnls 0
#define cfnWinmm 0
#define cfnRichEdit 0


/*	Returns the module handle of the given module imod. Loads it if it is
	not loaded already.  fForceLoad will force a LoadLibrary on the DLL
	even if it is already in memory. */
MSOAPI_(HINSTANCE) MsoLoadModule(int imod, BOOL fForceLoad);

MSOAPIX_(void) MsoFreeModule(int imod);

MSOAPI_(BOOL) MsoFModuleLoaded(int imod);

/*	Returns the proc address in the module imod of the function
	szName.  Returns NULL if the module is not found or if the entry
	point does not exist in the module. */
MSOAPI_(FARPROC) MsoGetProcAddress(int imod, const char* szName);


/*	This API should be called by the client before MsoFInitOffice to set
	our locale id so that we can load the correct international dll.
	Defaults to the user default locale if app doesn't call this API before. */
MSOAPI_(void) MsoSetLocale(LCID dwLCID);


#define msobtaNone			0
#define msobtaPreRelease	1
#define msobtaOEM			2
#define msobtaOEMCD			3
#define msobtaOEMFixed		4
#define msobtaUnlock			5

/*	Puts the Office DLL in "beta-mode".  When we're in beta mode, we do
	our beta expiration test in MsoFInitOffice. There are 2 kinds of betas:
	msobtaPreRelease:	look in the intl DLL for a hardcoded expiration date
						(Apps should make this call if they ship a beta after
						mso97.dll RTM, i.e. FE betas)
	msobtaOEM:			apps expire 90 days after first boot
	msobtaOEMCD:		same as msobtaOEM, except setup sets the date -- UNUSED FOR NOW
	msobtaOEMFixed:		same as msobtaPreRelease, except a different string
	msobtaNone:			No effect */
MSOAPIX_(void) MsoSetBetaMode(int bta);

/* Cover for standard GetTextExtentPointW that:
	1. Uses GetTextExtentPoint32W on Win32 (more accurate)
	2. Fixes Windows bug	when cch is 0.  If cch is 0 then the correct dy 
		is returned and dx will be 0.  Also, if cch is 0 then wz can be NULL. */
MSOAPI_(BOOL) MsoFGetTextExtentPointW(HDC hdc, const WCHAR *wz, int cch, LPSIZE lpSize);

/* Covers for Windows APIs that need to call the W versions if on a 
	Unicode system, else the A version. */
MSOAPI_(LRESULT) MsoDispatchMessage(const MSG *pmsg);
MSOAPI_(LRESULT) MsoSendMessage(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam);
MSOAPI_(LONG) MsoPostMessage(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam);
MSOAPI_(LRESULT) MsoCallWindowProc(WNDPROC pPrevWndFunc, HWND hwnd, UINT msg, 
		WPARAM wParam, LPARAM lParam);

MSOAPIX_(LONG) MsoGetWindowLong(HWND hwnd, int nIndex);
MSOAPI_(LONG) MsoSetWindowLong(HWND hwnd, int nIndex, LONG dwNewLong);

#ifdef _WIN64
MSOAPIX_(LONG_PTR) MsoGetWindowLongPtr(HWND hwnd, int nIndex);
MSOAPIX_(LONG_PTR) MsoSetWindowLongPtr(HWND hwnd, int nIndex, LONG_PTR dwNewLong);
#else
#define MsoGetWindowLongPtr(hwnd, nIndex) MsoGetWindowLong(hwnd, nIndex)
#define MsoSetWindowLongPtr(hwnd, nIndex, dwNewLong) MsoSetWindowLong(hwnd, nIndex, dwNewLong)
#endif // _WIN64

#define ETO_MSO_IME_UL_WORKAROUND 0x0800000
#define ETO_MSO_NO_GLYPH 0x1000000
#define ETO_MSO_DISPLAY_HOTKEY 0x2000000
#define ETO_MSO_NO_FONTLINK	0x20000000
#define	ETO_MSO_DONT_CALL_UCSCRIBE	0x40000000
#define ETO_MSO_FORCE_ENHMETAFILE 0x80000000
MSOAPI_(int) MsoGetWindowTextWtz(HWND hwnd, WCHAR *wtz, int cchMax);
MSOAPIX_(BOOL) MsoSetWindowTextWtz(HWND hwnd, WCHAR *wtz);
MSOAPI_(BOOL) MsoAppendMenuW(HMENU hMenu, UINT uFlags, UINT uIDNewItem,
								LPCWSTR lpNewItem);
MSOAPI_(BOOL) MsoInsertMenuW(HMENU hMenu, UINT uPosition, UINT uFlags,
								UINT uIDNewItem, LPCWSTR lpNewItem);

/*	Return the facename of the system UI (dialog) font in wtzFaceName. */
MSOAPI_(VOID) MsoGetSystemUIFont(WCHAR *wtzFaceName);

/*	Return TRUE if the user settings indicate that we should not use Tahoma
	and instead use the system UI font.  If we should use the system font 
	and plf is non-NULL and points at a font with facename currently equal 
	to "Tahoma", then overwrite it with the the appropriate system UI 
	font (e.g. "MS Sans Serif" or "MS Dialog") with the same attributes. */
MSOAPI_(BOOL) MsoFOverrideOfficeUIFont(LOGFONT *plf);

/*	Return TRUE if the user settings indicate that we should not use Tahoma
	and instead use the system UI font.  If we should use the system font 
	and the Windows dialog at hwndDlg is using the Tahoma font, then set 
	the font for all controls in the dialog to the default system dialog font.  
	Call this in WM_INITDIALOG for Windows dialogs.
		If this function creates a new font, it returns that font in *phfont.
	In this case, the caller is responsible for deleting the font when the
	dialog is closed. */
MSOAPI_(BOOL) MsoFOverrideOfficeUIWinDlgFont(HWND hwndDlg, HFONT *phfont);

/* If the LOGFONT at plf is a default system UI font then change *plf 
	to substitute the Tahoma font as appropriate for the system.
	Return TRUE if *plf was changed. */
MSOAPI_(BOOL) MsoFSubstituteTahomaLogfont(LOGFONT *plf);

/*	Some Far East languages need a minimum 9 point UI font size because 
	otherwise the glyphs are unreadable.  On other languages, we want to go 
	no lower than 8 pt (even if buggy system settings return a smaller value).
	This is controlled by a resource.  If the the font at plf describes a 
	smaller size, increase it to the minimum. */
MSOAPI_(void) MsoEnsureMinUIFontSize(LOGFONT *plf);

// Fonts supported by MsoFGetFontSettings
enum
	{
	msofntMenu,
	msofntTooltip,
	};

/* Return font and color info for the font given by 'fnt' (see msofntXXX).
	If fVertical, then the font is rotated 90 degrees if this fnt type
	supports rotation in Office.  If phfont is non-NULL, return the HFONT used 
	for this item.  This font is owned and cached by Office and should not 
	be deleted.  If phbrBk is non-NULL, return a brush used for the 
	background of this item	(owned by Office and should not be deleted).  
	If pcrText is non-NULL,	return the COLOREF used for the text color for 
	this item. Return TRUE if all requested info was returned. */
MSOAPI_(BOOL) MsoFGetFontSettings(int fnt, BOOL fVertical, HFONT *phfont, 
		HBRUSH *phbrBk, COLORREF *pcrText);

/* If the system suppports NotifyWinEvent, then call it with the given
	parameters (see \otools\inc\win\winable.h). */
MSOAPI_(void) MsoNotifyWinEvent(DWORD dwEvent, HWND hwnd, LONG idObject, LONG idChild);

/* Return FALSE iff we don't need to call MsoNotifyWinEvent.  This is only an
	optimization to avoid prep work in the caller since calling MsoNotifyWinEvent
	is always safe and fast if nobody is listening. */
MSOAPIX_(BOOL) MsoFNotifyWinEvents();

/* Return TRUE if an Accessibility screen reader is running. */
MSOAPI_(BOOL) MsoFScreenReaderPresent();

/* Call LResultFromObject in oleacc.dll to thunk an IUnknown object into
   an LRESULT to allow for cross-process access.  The wParam is the parameter
   as passed to WM_GETOBJECT. */
MSOAPI_(LRESULT) MsoLThunkIUnknown(IUnknown *punk, WPARAM wParam);

/*	Return TRUE if build version of OleAcc.Dll is greater than or equal to
	the version number passed in (in the form A.B.C.D). */
MSOAPIX_(BOOL) MsoFOleAccDllVersion(short A, short B, short C, short D);

/* Put up an alert that says that a help ghosting or shortcut could not 
	be performed because the app is in a bad state. */
MSOAPI_(void) MsoDoGhostingAlert();

/*	Constructs the name of the international dll from the locale passed in.	*/
#define MsoGetIntlName(wz) \
	MsoQfidToFilename(msoqfidMsoIntlDll, wz)

/****************************************************************************
   MsoNotifyIMEWindowChange

	This function should be called whenever the set of visible IME windows
	changes.	Usually, calling this function in response to IMN_OPENCANDIDATE
	and IMN_CHANGECANDIDATE messages is sufficient. Unfortunately, Office is
	unable to catch these messages itself because they go to the window that
	has focus, not to the top-level window of the application.
		By calling this function, the application allows Office to do useful
	things like move the assistant off of the IME windows.
****************************************************************************/
MSOAPI_(void) MsoNotifyIMEWindowChange(void);

/*-----------------------------------------------------------------------------
	MsoWzAppendVer

	Places the current build version into wz of the form (maj.min.rup)
	String is 0 terminated, returns a pointer to the null for subsequent
	append operations.  The buffer is assumed to be long enough for this
	concatination.
-------------------------------------------------------------------- JEFFJO -*/
MSOAPI_(WCHAR *) MsoWzAppendVer(WCHAR *wz);

/****************************************************************************
	MsoFInitDisableUI

	This function must be called to activate the ADMIN disabled UI. It must
	called AFTER calling MsoFCreateStdComponentManager.

	This function will parse the registry for ADMIN disabled keystrokes and
	tcid's. It will register a master component to intercept the offending 
	keystrokes and banish them to the bit bucket.
****************************************************************************/
MSOAPI_(BOOL) MsoFInitDisableUI(HMSOINST hinst);

/****************************************************************************
	MsoHtmlHelp

	This function is the replacement for WinHelp. It will display the HTMLHelp
	Appbar.
****************************************************************************/
MSOAPI_(BOOL) MsoHtmlHelp(HWND hwndMain, LPWSTR lpszHelp, UINT usCommand, DWORD dwData);

/****************************************************************************
	MsoHelpSetLeftPane

	Normally MsoHtmlHelp will cause msohelp to launch with the tabs
	extended or not depending on the current assistant state.  This function
	affects the next call to MsoHtmlHelp such that the tabs can be forced to
	be extended or not regardless of the assistant state.  
****************************************************************************/
MSOAPI_(void) MsoHelpSetLeftPane(BOOL fShow);

/*-------------------------------------------------------------------------*/

#define HELP_VBA_COMMAND   0x10000

typedef enum
{
	msoargtSwitch,
	msoargtFile,
	msoargtString,
	msoargtProfile,
	msoargtAutomation,
	msoargtRegserver,
	msoargtUnregserver,
	msoargtSwitchData,
	msoargtEmbedding,
	msoargtSafe,
	msoargtDDE,
} ARGT;

typedef struct
{
	ARGT argt;
	int ch;  // NOTE: don't change this to a CHAR since ARGC is overloaded to handle WCHAR cmdline
	union
		{
		CHAR *szData;
		int fFound;
		WCHAR *wzData;
		};
} ARGC;

MSOAPI_(int) MsoParseCommandLine(ARGC *pargc, unsigned int carg, CHAR **pszCmdLine, int fDestructive);
MSOAPI_(int) MsoParseCommandLineW(ARGC *pargc, unsigned int carg, WCHAR **pszCmdLine, int fDestructive);

/****************************************************************************
	MsoGetIntlSysSettings

	This API is important to non-US apps, namely MidEast and FarEast.  It takes
	a BOOL param, fRefresh, which will be FALSE most of the time--which is at the 
	init time.  Apps will only set it to TRUE when they think that System settings 
	have been changed.

	BIDI_TODO: It would be a good idea to remove the fRefresh param, and refresh it 
	automatically when WM_SETTINGCHANGE is sent.  Where should we trap it?
****************************************************************************/
MSOAPI_(DWORD) MsoGetIntlSysSettings(BOOL fRefresh);
MSOAPI_(BOOL) MsoFEditLangSupported(WORD lid);

#define MSOI_ARABIC_SYSTEM_INSTALLED		0x00000001	// Arabic APIs
#define MSOI_ARABIC_FONTS_INSTALLED			0x00000002	// Arabic Fonts
#define MSOI_ARABIC_KBD_INSTALLED			0x00000004	// Arabic Keyboards



//SOUTHASIA
// These uses the higher nibble of the second byte to define for SOUTHASIA.
#define MSOI_HINDI_FULLY_INSTALLED			0x00001000
#define MSOI_THAI_FULLY_INSTALLED			0x00002000
#define MSOI_VIETNAMESE_FULLY_INSTALLED		0x00004000
#define MSOI_MSO9SA_RUNNING                 0x00008000 // use to mark this MSO version as SA enabled
//SOUTHASIA

#define MSOI_ARABIC_FULLY_INSTALLED			(MSOI_ARABIC_SYSTEM_INSTALLED \
											| MSOI_ARABIC_FONTS_INSTALLED \
											| MSOI_ARABIC_KBD_INSTALLED)
											// Full Arabic system (0x00000007)

#define MSOI_HEBREW_SYSTEM_INSTALLED		0x00000010	// Hebrew APIs
#define MSOI_HEBREW_FONTS_INSTALLED			0x00000020	// Hebrew Fonts
#define MSOI_HEBREW_KBD_INSTALLED			0x00000040	// Hebrew Keyboard

#define MSOI_HEBREW_FULLY_INSTALLED			(MSOI_HEBREW_SYSTEM_INSTALLED \
											| MSOI_HEBREW_FONTS_INSTALLED \
											| MSOI_HEBREW_KBD_INSTALLED)
											// Full Hebrew system (0x00000070)

#define MSOI_NT4_RUNNING					0x00000100	// Either Windows NT 4
#define MSOI_NT5_RUNNING					0x00000200	// Or Windows NT 5
#define MSOI_WIN95_RUNNING					0x00000400	// Or Windows 95
#define MSOI_WIN98_RUNNING					0x00000800	// Or Windows 98

// Does it support Unicode?
MSOAPI_(BOOL) MsoFUnicodeCommCtrl();





/*-----------------------------------------------------------------------
 IV Declarations
 Last Modifiied July 9, 1998
-------------------------------------------------------------- t-benyu -*/

/*- MsoIVLogCheck --------------------------------------------

  An API to determine if the current build of office is
  an IV version.

  Input : none
  Return: DWORD, 1  - Yes we are IV
                 0 - Not the IV.
  Memory: no modification
-------------------------------------------------- t-benyu -*/
MSOAPI_(DWORD) MsoIVLogCheck();

/*- MsoIVLogInit ---------------------------------------------

  MSO API to register the test wizard callback function.
 
  Input : pointer to function of type PFCNIVLoggingCallback
  Return: NONE
  Memory: Modifies the 'vgpfnIVLogCallback' variable to the
          value of 'vgpfnIVnewLogCallback' of type
          PFCNIVLoggingCallback 
-------------------------------------------------- t-benyu -*/
MSOAPIX_(void) MsoIVLogInit(PFCNIVLoggingCallback);

/* extern declaration for Callback function pointer. 
  Actually declared in office.cpp*/
extern PFCNIVLoggingCallback vgpfnIVLogCallback;

/*-----------------------------------------------------------------------
 END IV Declarations
-------------------------------------------------------------- t-benyu -*/


/*-----------------------------------------------------------------------------
	MsoFNetFile

	Determines if a file name is on the network.

	NOTE:
	Local UNC names (like \\<LocalMachine>\<Share>\<File>)
	are treated as network names.
-------------------------------------------------------------------- ArthurZ -*/

MSOAPIX_(BOOL) MsoFNetFile(const WCHAR *wz);



/*-----------------------------------------------------------------------------
	MsoFNetModules

	Determines if there are any EXEs/DLLs loaded across the network.
-------------------------------------------------------------------- ArthurZ -*/
MSOAPI_(BOOL) MsoFNetModules(BOOL fDisplayMessage, BOOL fNetDocsOpen);

#define fvokNil     0
#define fvokNoIOD   1
MSOAPI_(int) MsoFVbaOK(int *pfCopyDoc, int fvok);
MSOAPI_(void) MsoRegisterVbe(void);

#endif // MSOUSER_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Inc\office10\tmpbtn.h ===
//
// This file was machine generated by MkTmpID.bat.
// Do not modify.
// 
// Contact: msotbqs, "Office Commandbar questions"
//

#ifndef TMPBTN_H
#define TMPBTN_H

enum
	{
	msotcidTemporaryMin = msotcidBtnRealMax,
#ifdef VSMSODEBUG
	msotcidWebServerDumpDocColl,
	msotcidWebServerDumpBandHtml,
	msotcidWebServerDebugMenu,
	msotcidSampleDialog,
	msotcidDebugCrashRecovery,
	msotcidDebugCrash,
	msotcidDebugRemoveDrps,
	msotcidNewToolsOptions,
#endif
#ifdef HYBRID
	msotcidDebugToggleProfiling,
#endif // HYBRID
	msotcidBtnMax
	};

#endif // TMPBTN_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Inc\office10\msowarn.h ===
/*************************************************************************
	msowarn.h
	
	Owner: michmarc
	Copyright (c) 1999 Microsoft Corporation
	
	File that contains all of the pragmas necessary to make
	/W4 /WX work with Office builds
*************************************************************************/

#ifndef _MSO_WARN
#define _MSO_WARN
#pragma once

// Warnings that need fixing to make things /W4 clean

// Always useless
#pragma warning(disable:4049)   // Compiler limit -- no more line number info
#pragma warning(disable:4054)   // Casting function pointer to data pointer
#pragma warning(disable:4055)   // Casting data pointer to function pointer
#pragma warning(disable:4100)   // Unreferenced formal parameter
#pragma warning(disable:4102)   // Unreferenced label
#pragma warning(disable:4115)   // Named type definition in parenthesis
#pragma warning(disable:4121)   // structure sensitive to packing
#pragma warning(disable:4152)   // Microsoft extension -- fn/data pointer conv
#pragma warning(disable:4168)   // Compiler limit -- out of debug types
#pragma warning(disable:4200)   // Microsoft extension -- Zero sized array
#pragma warning(disable:4201)   // Microsoft extension -- Nameless struct/union
#pragma warning(disable:4204)   // Microsoft extension -- Nonconst agg initializer
#pragma warning(disable:4206)   // Microsoft extension -- Source file is empty
#pragma warning(disable:4207)   // Microsoft extension -- Extended initializer form
#pragma warning(disable:4211)   // Microsoft extension -- Extern to static
#pragma warning(disable:4213)   // Microsoft extension -- Cast on LValue
#pragma warning(disable:4214)   // Microsoft extension -- Bitfield not int
#pragma warning(disable:4221)   // Microsoft extension -- Init with addr of local
#pragma warning(disable:4239)   // Microsoft extension -- nonconst reference to nonlvalue
#pragma warning(disable:4238)   // Microsoft extension -- class rvalue as lvalue
#pragma warning(disable:4305)   // Casting causes truncation
#pragma warning(disable:4509)   // Microsoft extension -- SEH and destructors
#pragma warning(disable:4510)   // Default constructor could not be generated
#pragma warning(disable:4511)   // Copy constructor could not be generated
#pragma warning(disable:4512)   // Assignment operator could not be generated
#pragma warning(disable:4513)   // Destructor could not be generated
#pragma warning(disable:4514)   // Unreferenced inline function removed
#pragma warning(disable:4527)   // User defined destructor required
#pragma warning(disable:4610)   // User defined constructor required
#pragma warning(disable:4611)   // Setjmp/C++ destruction interaction unportable
#pragma warning(disable:4710)   // Inline function not inlined
#pragma warning(disable:4798)   // Native code instead of PCode generated

#if VSMSODEBUG
#pragma warning(disable:4124)	  // Stack checking and __fastcall mixed
#endif

// Currently useless, but could be made useful
#pragma warning(disable:4018)   // Signed/unsigned comparison mismatch.  Might be useful, except that all
                                // arguments smaller than int are promoted to signed int, so byte==(byte+byte) generates this.
#pragma warning(disable:4127)   // Conditional is constant.  Might be useful, but many asserts are constantly true
                                //    and "while (1) {}" and "for(A;;B)" constructs generate this warning as well.
#pragma warning(disable:4245)   // Signed/unsigned asignment mismatch.  Might be useful, except that all
                                // arguments smaller than int are promoted to signed int, so byte=byte+byte generates this.
#pragma warning(disable:4268)   // const static/global initilzed with compiler generated default constructor
                                //    seems that "extern "C" const ClassName cn;" can generate this, even though this is
                                //    a declaration, not a definition
#pragma warning(disable:4310)   // Cast truncates constant value (problem because LOBYTE(0x113) generates this)
                                // and there is often no way to work around the warning
#pragma warning(disable:4414)   // __asm short jump converted to near jump.  Currently a compiler bug causes
								// the 'near' and 'far' keywords to be thrown out, making it impossible to declare
								// a jump in inline assembly that is anything except short.
#pragma warning(disable:4702)   // Unreachable code.  Can't be eliminated because this warning
                                // can be generated against compiler created code at the end of a block

// REVIEW -- should these be re-enabled?
#pragma warning(disable:4211)   // Redefined extern to static 
#pragma warning(disable:4505)   // Unreferenced static function removed (happens in ATL code)

#endif /* _MSO_WARN */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\Include\VSL.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef VSL_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define VSL_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#ifndef __cplusplus
	#error VSL requires C++; use a .cpp extension instead of .c
#endif

/*
FUTURE - the global disabling of the following warnings could be removed if it is causing
anyone hardship.
*/

// 'int' : forcing value to bool 'true' or 'false' (performance warning)
// This fires even with an explicit cast!!!
#pragma warning(disable : 4800)

#define VSL VSL

// forward declration of the namespace
namespace VSL {}

// By default debug builds contain source line information in exception objects
// which makes the binary larger.  By default retail builds do not contain source line
// information inorder to save both size and avoid having source file information in the binary,
// can be considered a security or legal risk.
#if !defined(DEBUG) && !defined(_DEBUG) && !defined(DBG) && !defined(_VSL_RETAIL_SOURCE_INFO)
#define _VSL_NO_SOURCE_INFO
#endif

// Used to prepend L a literal string
#ifndef WIDEN2
#define WIDEN2(x) L ## x
#endif

#ifndef WIDEN
#define WIDEN(x) WIDEN2(x)
#endif

// Compiler doesn't provide this so we define it here.
#ifndef __WFILE__
#define __WFILE__ WIDEN(__FILE__)
#endif

/*
Placing the following code in each object file making use of the Visual Studio
Library can reduce the size of the compiled executable, if the string pooling 
optimization is not enabled.

static const TCHAR cszObjectFilename[] = _T(__FILE__);
#undef __VSL_FILE__
#define __VSL_FILE__ cszObjectFilename
*/

#ifndef __VSL_FILE__
#if defined(_UNICODE) || defined(UNICODE)
#define __VSL_FILE__ __WFILE__
#else
#define __VSL_FILE__ __FILE__
#endif
#endif // __VSL_FILE__

// It is left to the consumer of the VSL library to define the assertion mechanism
// of their choosing
#ifndef VSL_ASSERT
#define VSL_ASSERT(exp) ((void)0)
#endif

#ifndef VSL_ASSERTEX
#define VSL_ASSERTEX(exp, szMsg) VSL_ASSERT(exp)
#endif

#ifndef VSL_ERROR_PROCESSOR_ASSERTEX
#define VSL_ERROR_PROCESSOR_ASSERTEX(exp, szMsg) VSL_ASSERTEX(exp, szMsg)
#endif

// It is left to the consumer of the VSL library to define the tracing mechanism
// of their choosing
#ifndef VSL_TRACE
#define VSL_TRACE __noop
#endif // VSL_TRACE

// ARRAY_SIZE is supplied by newer Windows Platform SDKs only.
#ifndef ARRAYSIZE 
#define ARRAYSIZE(A) (sizeof(A)/sizeof((A)[0]))
#endif ARRAYSIZE

#ifndef VSL_STDMETHOD_NOTIMPL 
#define VSL_STDMETHOD_NOTIMPL { return E_NOTIMPL; }
#endif

#define VSL_DECLARE_ASSIGNMENT_OPERATOR(type) const type& operator=(const type& rToCopy)

#define VSL_DECLARE_COPY_CONSTRUCTOR(type) type(const type& rToCopy)

#define VSL_DECLARE_NOT_COPYABLE(type) \
private: \
	VSL_DECLARE_ASSIGNMENT_OPERATOR(type); \
	VSL_DECLARE_COPY_CONSTRUCTOR(type);

#define VSL_DEFINE_BINARY_COPY_THROUGH_DERIVED_ONLY(type) \
protected: \
	const type& operator=(const type& rToCopy) \
	{ \
		if(&rToCopy != this) \
		{ \
			::memcpy(this, &rToCopy, sizeof(this)); \
		} \
		return *this; \
	} \
	type(const type& rToCopy) \
	{ \
		::memcpy(this, &rToCopy, sizeof(this)); \
	}

#define VSL_DECLARE_PRIVATE_DEFAULT_CONSTURCTOR_AND_DESTRUCTOR(type) \
private: \
	type(); \
	~type();

#define VSL_DEFINE_NON_DEFAULT_CONSTRUCTABLE_BASE_CLASS_WITH_PROTECTED_COPY(type) \
protected: \
	type() {} \
	~type() {} \
VSL_DEFINE_BINARY_COPY_THROUGH_DERIVED_ONLY(type)

#define VSL_DEFINE_DEFAULT_CONSTRUCTOR_AND_PURE_VIRTUAL_DESTRUCTOR(type) \
	type() {} \
	virtual ~type() = 0 {}

#define VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(type) \
VSL_DECLARE_NOT_COPYABLE(type) \
\
protected: \
\
	type() {} \
	~type() {} // Not virtual, but it is protected, so it can't be accessed through a pointer to type, except by derived classes, which can delete using their own this pointer.

#define VSL_DECLARE_NONINSTANTIABLE_CLASS(type) \
VSL_DECLARE_NOT_COPYABLE(type) \
VSL_DECLARE_PRIVATE_DEFAULT_CONSTURCTOR_AND_DESTRUCTOR(type)

// DEPRECATED - 5/18/2006 - this will be removed in the future
#define VSL_DECLARE_NONINSTANTIABLE_NONBASE_CLASS VSL_DECLARE_NONINSTANTIABLE_CLASS

#define VSL_DECLARE_NOT_COPYABLE_OR_DEFAULT_CONSTRUCTABLE(type) \
VSL_DECLARE_NOT_COPYABLE(type) \
	type(); \

#endif // VSL_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\Include\mscomctl_i.c ===
/* this ALWAYS GENERATED file contains the IIDs and CLSIDs */

/* link this file in with the server and any clients */


 /* File created by MIDL compiler version 6.00.0366 */
/* at Mon Aug 22 18:05:57 2005
 */
/* Compiler settings for ..\..\..\..\..\Common\Source\CPP\VSL\Include\mscomctl.IDL:
    Oicf, W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )

#pragma warning( disable: 4049 )  /* more than 64k source lines */


#ifdef __cplusplus
extern "C"{
#endif 


#include <rpc.h>
#include <rpcndr.h>

#ifdef _MIDL_USE_GUIDDEF_

#ifndef INITGUID
#define INITGUID
#include <guiddef.h>
#undef INITGUID
#else
#include <guiddef.h>
#endif

#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
        DEFINE_GUID(name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8)

#else // !_MIDL_USE_GUIDDEF_

#ifndef __IID_DEFINED__
#define __IID_DEFINED__

typedef struct _IID
{
    unsigned long x;
    unsigned short s1;
    unsigned short s2;
    unsigned char  c[8];
} IID;

#endif // __IID_DEFINED__

#ifndef CLSID_DEFINED
#define CLSID_DEFINED
typedef IID CLSID;
#endif // CLSID_DEFINED

#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
        const type name = {l,w1,w2,{b1,b2,b3,b4,b5,b6,b7,b8}}

#endif !_MIDL_USE_GUIDDEF_

MIDL_DEFINE_GUID(IID, LIBID_MSComctlLib,0x831FDD16,0x0C5C,0x11D2,0xA9,0xFC,0x00,0x00,0xF8,0x75,0x4D,0xA1);


MIDL_DEFINE_GUID(IID, IID_IVBDataObject,0x2334D2B1,0x713E,0x11CF,0x8A,0xE5,0x00,0xAA,0x00,0xC0,0x09,0x05);


MIDL_DEFINE_GUID(IID, IID_IVBDataObjectFiles,0x2334D2B3,0x713E,0x11CF,0x8A,0xE5,0x00,0xAA,0x00,0xC0,0x09,0x05);


MIDL_DEFINE_GUID(IID, IID_ITabStrip,0x1EFB6594,0x857C,0x11D1,0xB1,0x6A,0x00,0xC0,0xF0,0x28,0x36,0x28);


MIDL_DEFINE_GUID(IID, DIID_ITabStripEvents,0x1EFB6595,0x857C,0x11D1,0xB1,0x6A,0x00,0xC0,0xF0,0x28,0x36,0x28);


MIDL_DEFINE_GUID(IID, IID_ITabs,0x1EFB6597,0x857C,0x11D1,0xB1,0x6A,0x00,0xC0,0xF0,0x28,0x36,0x28);


MIDL_DEFINE_GUID(IID, IID_ITab,0x1EFB6599,0x857C,0x11D1,0xB1,0x6A,0x00,0xC0,0xF0,0x28,0x36,0x28);


MIDL_DEFINE_GUID(IID, IID_IToolbar,0x66833FE4,0x8583,0x11D1,0xB1,0x6A,0x00,0xC0,0xF0,0x28,0x36,0x28);


MIDL_DEFINE_GUID(IID, DIID_IToolbarEvents,0x66833FE5,0x8583,0x11D1,0xB1,0x6A,0x00,0xC0,0xF0,0x28,0x36,0x28);


MIDL_DEFINE_GUID(IID, IID_IButtons,0x66833FE7,0x8583,0x11D1,0xB1,0x6A,0x00,0xC0,0xF0,0x28,0x36,0x28);


MIDL_DEFINE_GUID(IID, IID_IButton,0x66833FE9,0x8583,0x11D1,0xB1,0x6A,0x00,0xC0,0xF0,0x28,0x36,0x28);


MIDL_DEFINE_GUID(IID, IID_IButtonMenus,0x66833FEB,0x8583,0x11D1,0xB1,0x6A,0x00,0xC0,0xF0,0x28,0x36,0x28);


MIDL_DEFINE_GUID(IID, IID_IButtonMenu,0x66833FED,0x8583,0x11D1,0xB1,0x6A,0x00,0xC0,0xF0,0x28,0x36,0x28);


MIDL_DEFINE_GUID(IID, IID_IStatusBar,0x8E3867A1,0x8586,0x11D1,0xB1,0x6A,0x00,0xC0,0xF0,0x28,0x36,0x28);


MIDL_DEFINE_GUID(IID, DIID_IStatusBarEvents,0x8E3867A2,0x8586,0x11D1,0xB1,0x6A,0x00,0xC0,0xF0,0x28,0x36,0x28);


MIDL_DEFINE_GUID(IID, IID_IPanels,0x8E3867A4,0x8586,0x11D1,0xB1,0x6A,0x00,0xC0,0xF0,0x28,0x36,0x28);


MIDL_DEFINE_GUID(IID, IID_IPanel,0x8E3867AA,0x8586,0x11D1,0xB1,0x6A,0x00,0xC0,0xF0,0x28,0x36,0x28);


MIDL_DEFINE_GUID(IID, IID_IProgressBar,0x35053A20,0x8589,0x11D1,0xB1,0x6A,0x00,0xC0,0xF0,0x28,0x36,0x28);


MIDL_DEFINE_GUID(IID, DIID_IProgressBarEvents,0x35053A21,0x8589,0x11D1,0xB1,0x6A,0x00,0xC0,0xF0,0x28,0x36,0x28);


MIDL_DEFINE_GUID(IID, IID_ITreeView,0xC74190B4,0x8589,0x11D1,0xB1,0x6A,0x00,0xC0,0xF0,0x28,0x36,0x28);


MIDL_DEFINE_GUID(IID, DIID_ITreeViewEvents,0xC74190B5,0x8589,0x11D1,0xB1,0x6A,0x00,0xC0,0xF0,0x28,0x36,0x28);


MIDL_DEFINE_GUID(IID, IID_INodes,0xC74190B7,0x8589,0x11D1,0xB1,0x6A,0x00,0xC0,0xF0,0x28,0x36,0x28);


MIDL_DEFINE_GUID(IID, IID_INode,0xC74190B8,0x8589,0x11D1,0xB1,0x6A,0x00,0xC0,0xF0,0x28,0x36,0x28);


MIDL_DEFINE_GUID(IID, IID_IListView,0xBDD1F049,0x858B,0x11D1,0xB1,0x6A,0x00,0xC0,0xF0,0x28,0x36,0x28);


MIDL_DEFINE_GUID(IID, DIID_ListViewEvents,0xBDD1F04A,0x858B,0x11D1,0xB1,0x6A,0x00,0xC0,0xF0,0x28,0x36,0x28);


MIDL_DEFINE_GUID(IID, IID_IListItems,0xBDD1F04C,0x858B,0x11D1,0xB1,0x6A,0x00,0xC0,0xF0,0x28,0x36,0x28);


MIDL_DEFINE_GUID(IID, IID_IListItem,0xBDD1F04E,0x858B,0x11D1,0xB1,0x6A,0x00,0xC0,0xF0,0x28,0x36,0x28);


MIDL_DEFINE_GUID(IID, IID_IColumnHeaders,0xBDD1F050,0x858B,0x11D1,0xB1,0x6A,0x00,0xC0,0xF0,0x28,0x36,0x28);


MIDL_DEFINE_GUID(IID, IID_IColumnHeader,0xBDD1F051,0x858B,0x11D1,0xB1,0x6A,0x00,0xC0,0xF0,0x28,0x36,0x28);


MIDL_DEFINE_GUID(IID, IID_IListSubItems,0xBDD1F053,0x858B,0x11D1,0xB1,0x6A,0x00,0xC0,0xF0,0x28,0x36,0x28);


MIDL_DEFINE_GUID(IID, IID_IListSubItem,0xBDD1F055,0x858B,0x11D1,0xB1,0x6A,0x00,0xC0,0xF0,0x28,0x36,0x28);


MIDL_DEFINE_GUID(IID, IID_IImageList,0x2C247F21,0x8591,0x11D1,0xB1,0x6A,0x00,0xC0,0xF0,0x28,0x36,0x28);


MIDL_DEFINE_GUID(IID, DIID_ImageListEvents,0x2C247F22,0x8591,0x11D1,0xB1,0x6A,0x00,0xC0,0xF0,0x28,0x36,0x28);


MIDL_DEFINE_GUID(IID, IID_IImages,0x2C247F24,0x8591,0x11D1,0xB1,0x6A,0x00,0xC0,0xF0,0x28,0x36,0x28);


MIDL_DEFINE_GUID(IID, IID_IImage,0x2C247F26,0x8591,0x11D1,0xB1,0x6A,0x00,0xC0,0xF0,0x28,0x36,0x28);


MIDL_DEFINE_GUID(IID, IID_ISlider,0xF08DF952,0x8592,0x11D1,0xB1,0x6A,0x00,0xC0,0xF0,0x28,0x36,0x28);


MIDL_DEFINE_GUID(IID, DIID_ISliderEvents,0xF08DF953,0x8592,0x11D1,0xB1,0x6A,0x00,0xC0,0xF0,0x28,0x36,0x28);


MIDL_DEFINE_GUID(IID, IID_IControls,0xC8A3DC00,0x8593,0x11D1,0xB1,0x6A,0x00,0xC0,0xF0,0x28,0x36,0x28);


MIDL_DEFINE_GUID(IID, IID_IComboItem,0xDD9DA660,0x8594,0x11D1,0xB1,0x6A,0x00,0xC0,0xF0,0x28,0x36,0x28);


MIDL_DEFINE_GUID(IID, IID_IComboItems,0xDD9DA662,0x8594,0x11D1,0xB1,0x6A,0x00,0xC0,0xF0,0x28,0x36,0x28);


MIDL_DEFINE_GUID(IID, IID_IImageCombo,0xDD9DA664,0x8594,0x11D1,0xB1,0x6A,0x00,0xC0,0xF0,0x28,0x36,0x28);


MIDL_DEFINE_GUID(IID, DIID_DImageComboEvents,0xDD9DA665,0x8594,0x11D1,0xB1,0x6A,0x00,0xC0,0xF0,0x28,0x36,0x28);


MIDL_DEFINE_GUID(CLSID, CLSID_DataObject,0x2334D2B2,0x713E,0x11CF,0x8A,0xE5,0x00,0xAA,0x00,0xC0,0x09,0x05);


MIDL_DEFINE_GUID(CLSID, CLSID_DataObjectFiles,0x2334D2B4,0x713E,0x11CF,0x8A,0xE5,0x00,0xAA,0x00,0xC0,0x09,0x05);


MIDL_DEFINE_GUID(CLSID, CLSID_TabStrip,0x1EFB6596,0x857C,0x11D1,0xB1,0x6A,0x00,0xC0,0xF0,0x28,0x36,0x28);


MIDL_DEFINE_GUID(CLSID, CLSID_Tabs,0x1EFB6598,0x857C,0x11D1,0xB1,0x6A,0x00,0xC0,0xF0,0x28,0x36,0x28);


MIDL_DEFINE_GUID(CLSID, CLSID_Tab,0x1EFB659A,0x857C,0x11D1,0xB1,0x6A,0x00,0xC0,0xF0,0x28,0x36,0x28);


MIDL_DEFINE_GUID(CLSID, CLSID_Toolbar,0x66833FE6,0x8583,0x11D1,0xB1,0x6A,0x00,0xC0,0xF0,0x28,0x36,0x28);


MIDL_DEFINE_GUID(CLSID, CLSID_Buttons,0x66833FE8,0x8583,0x11D1,0xB1,0x6A,0x00,0xC0,0xF0,0x28,0x36,0x28);


MIDL_DEFINE_GUID(CLSID, CLSID_ButtonMenus,0x66833FEC,0x8583,0x11D1,0xB1,0x6A,0x00,0xC0,0xF0,0x28,0x36,0x28);


MIDL_DEFINE_GUID(CLSID, CLSID_StatusBar,0x8E3867A3,0x8586,0x11D1,0xB1,0x6A,0x00,0xC0,0xF0,0x28,0x36,0x28);


MIDL_DEFINE_GUID(CLSID, CLSID_Panels,0x8E3867A5,0x8586,0x11D1,0xB1,0x6A,0x00,0xC0,0xF0,0x28,0x36,0x28);


MIDL_DEFINE_GUID(CLSID, CLSID_ProgressBar,0x35053A22,0x8589,0x11D1,0xB1,0x6A,0x00,0xC0,0xF0,0x28,0x36,0x28);


MIDL_DEFINE_GUID(CLSID, CLSID_TreeView,0xC74190B6,0x8589,0x11D1,0xB1,0x6A,0x00,0xC0,0xF0,0x28,0x36,0x28);


MIDL_DEFINE_GUID(CLSID, CLSID_Nodes,0x0713E8C0,0x850A,0x101B,0xAF,0xC0,0x42,0x10,0x10,0x2A,0x8D,0xA7);


MIDL_DEFINE_GUID(CLSID, CLSID_ListView,0xBDD1F04B,0x858B,0x11D1,0xB1,0x6A,0x00,0xC0,0xF0,0x28,0x36,0x28);


MIDL_DEFINE_GUID(CLSID, CLSID_ListItems,0xBDD1F04D,0x858B,0x11D1,0xB1,0x6A,0x00,0xC0,0xF0,0x28,0x36,0x28);


MIDL_DEFINE_GUID(CLSID, CLSID_ColumnHeaders,0x0713E8C6,0x850A,0x101B,0xAF,0xC0,0x42,0x10,0x10,0x2A,0x8D,0xA7);


MIDL_DEFINE_GUID(CLSID, CLSID_ListSubItems,0xBDD1F054,0x858B,0x11D1,0xB1,0x6A,0x00,0xC0,0xF0,0x28,0x36,0x28);


MIDL_DEFINE_GUID(CLSID, CLSID_ListSubItem,0xBDD1F056,0x858B,0x11D1,0xB1,0x6A,0x00,0xC0,0xF0,0x28,0x36,0x28);


MIDL_DEFINE_GUID(CLSID, CLSID_ImageList,0x2C247F23,0x8591,0x11D1,0xB1,0x6A,0x00,0xC0,0xF0,0x28,0x36,0x28);


MIDL_DEFINE_GUID(CLSID, CLSID_ListImages,0x2C247F25,0x8591,0x11D1,0xB1,0x6A,0x00,0xC0,0xF0,0x28,0x36,0x28);


MIDL_DEFINE_GUID(CLSID, CLSID_ListImage,0x2C247F27,0x8591,0x11D1,0xB1,0x6A,0x00,0xC0,0xF0,0x28,0x36,0x28);


MIDL_DEFINE_GUID(CLSID, CLSID_Slider,0xF08DF954,0x8592,0x11D1,0xB1,0x6A,0x00,0xC0,0xF0,0x28,0x36,0x28);


MIDL_DEFINE_GUID(CLSID, CLSID_Controls,0xC8A3DC01,0x8593,0x11D1,0xB1,0x6A,0x00,0xC0,0xF0,0x28,0x36,0x28);


MIDL_DEFINE_GUID(CLSID, CLSID_ComboItem,0xDD9DA661,0x8594,0x11D1,0xB1,0x6A,0x00,0xC0,0xF0,0x28,0x36,0x28);


MIDL_DEFINE_GUID(CLSID, CLSID_ComboItems,0xDD9DA663,0x8594,0x11D1,0xB1,0x6A,0x00,0xC0,0xF0,0x28,0x36,0x28);


MIDL_DEFINE_GUID(CLSID, CLSID_ImageCombo,0xDD9DA666,0x8594,0x11D1,0xB1,0x6A,0x00,0xC0,0xF0,0x28,0x36,0x28);

#undef MIDL_DEFINE_GUID

#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\Include\mscomctl.h ===
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 6.00.0366 */
/* at Mon Aug 22 18:05:57 2005
 */
/* Compiler settings for ..\..\..\..\..\Common\Source\CPP\VSL\Include\mscomctl.IDL:
    Oicf, W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )

#pragma warning( disable: 4049 )  /* more than 64k source lines */


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 475
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__


#ifndef __mscomctl_h__
#define __mscomctl_h__

#if defined(_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

/* Forward Declarations */ 

#ifndef __IVBDataObject_FWD_DEFINED__
#define __IVBDataObject_FWD_DEFINED__
typedef interface IVBDataObject IVBDataObject;
#endif 	/* __IVBDataObject_FWD_DEFINED__ */


#ifndef __IVBDataObjectFiles_FWD_DEFINED__
#define __IVBDataObjectFiles_FWD_DEFINED__
typedef interface IVBDataObjectFiles IVBDataObjectFiles;
#endif 	/* __IVBDataObjectFiles_FWD_DEFINED__ */


#ifndef __ITabStrip_FWD_DEFINED__
#define __ITabStrip_FWD_DEFINED__
typedef interface ITabStrip ITabStrip;
#endif 	/* __ITabStrip_FWD_DEFINED__ */


#ifndef __ITabStripEvents_FWD_DEFINED__
#define __ITabStripEvents_FWD_DEFINED__
typedef interface ITabStripEvents ITabStripEvents;
#endif 	/* __ITabStripEvents_FWD_DEFINED__ */


#ifndef __ITabs_FWD_DEFINED__
#define __ITabs_FWD_DEFINED__
typedef interface ITabs ITabs;
#endif 	/* __ITabs_FWD_DEFINED__ */


#ifndef __ITab_FWD_DEFINED__
#define __ITab_FWD_DEFINED__
typedef interface ITab ITab;
#endif 	/* __ITab_FWD_DEFINED__ */


#ifndef __IToolbar_FWD_DEFINED__
#define __IToolbar_FWD_DEFINED__
typedef interface IToolbar IToolbar;
#endif 	/* __IToolbar_FWD_DEFINED__ */


#ifndef __IToolbarEvents_FWD_DEFINED__
#define __IToolbarEvents_FWD_DEFINED__
typedef interface IToolbarEvents IToolbarEvents;
#endif 	/* __IToolbarEvents_FWD_DEFINED__ */


#ifndef __IButtons_FWD_DEFINED__
#define __IButtons_FWD_DEFINED__
typedef interface IButtons IButtons;
#endif 	/* __IButtons_FWD_DEFINED__ */


#ifndef __IButton_FWD_DEFINED__
#define __IButton_FWD_DEFINED__
typedef interface IButton IButton;
#endif 	/* __IButton_FWD_DEFINED__ */


#ifndef __IButtonMenus_FWD_DEFINED__
#define __IButtonMenus_FWD_DEFINED__
typedef interface IButtonMenus IButtonMenus;
#endif 	/* __IButtonMenus_FWD_DEFINED__ */


#ifndef __IButtonMenu_FWD_DEFINED__
#define __IButtonMenu_FWD_DEFINED__
typedef interface IButtonMenu IButtonMenu;
#endif 	/* __IButtonMenu_FWD_DEFINED__ */


#ifndef __IStatusBar_FWD_DEFINED__
#define __IStatusBar_FWD_DEFINED__
typedef interface IStatusBar IStatusBar;
#endif 	/* __IStatusBar_FWD_DEFINED__ */


#ifndef __IStatusBarEvents_FWD_DEFINED__
#define __IStatusBarEvents_FWD_DEFINED__
typedef interface IStatusBarEvents IStatusBarEvents;
#endif 	/* __IStatusBarEvents_FWD_DEFINED__ */


#ifndef __IPanels_FWD_DEFINED__
#define __IPanels_FWD_DEFINED__
typedef interface IPanels IPanels;
#endif 	/* __IPanels_FWD_DEFINED__ */


#ifndef __IPanel_FWD_DEFINED__
#define __IPanel_FWD_DEFINED__
typedef interface IPanel IPanel;
#endif 	/* __IPanel_FWD_DEFINED__ */


#ifndef __IProgressBar_FWD_DEFINED__
#define __IProgressBar_FWD_DEFINED__
typedef interface IProgressBar IProgressBar;
#endif 	/* __IProgressBar_FWD_DEFINED__ */


#ifndef __IProgressBarEvents_FWD_DEFINED__
#define __IProgressBarEvents_FWD_DEFINED__
typedef interface IProgressBarEvents IProgressBarEvents;
#endif 	/* __IProgressBarEvents_FWD_DEFINED__ */


#ifndef __ITreeView_FWD_DEFINED__
#define __ITreeView_FWD_DEFINED__
typedef interface ITreeView ITreeView;
#endif 	/* __ITreeView_FWD_DEFINED__ */


#ifndef __ITreeViewEvents_FWD_DEFINED__
#define __ITreeViewEvents_FWD_DEFINED__
typedef interface ITreeViewEvents ITreeViewEvents;
#endif 	/* __ITreeViewEvents_FWD_DEFINED__ */


#ifndef __INodes_FWD_DEFINED__
#define __INodes_FWD_DEFINED__
typedef interface INodes INodes;
#endif 	/* __INodes_FWD_DEFINED__ */


#ifndef __INode_FWD_DEFINED__
#define __INode_FWD_DEFINED__
typedef interface INode INode;
#endif 	/* __INode_FWD_DEFINED__ */


#ifndef __IListView_FWD_DEFINED__
#define __IListView_FWD_DEFINED__
typedef interface IListView IListView;
#endif 	/* __IListView_FWD_DEFINED__ */


#ifndef __ListViewEvents_FWD_DEFINED__
#define __ListViewEvents_FWD_DEFINED__
typedef interface ListViewEvents ListViewEvents;
#endif 	/* __ListViewEvents_FWD_DEFINED__ */


#ifndef __IListItems_FWD_DEFINED__
#define __IListItems_FWD_DEFINED__
typedef interface IListItems IListItems;
#endif 	/* __IListItems_FWD_DEFINED__ */


#ifndef __IListItem_FWD_DEFINED__
#define __IListItem_FWD_DEFINED__
typedef interface IListItem IListItem;
#endif 	/* __IListItem_FWD_DEFINED__ */


#ifndef __IColumnHeaders_FWD_DEFINED__
#define __IColumnHeaders_FWD_DEFINED__
typedef interface IColumnHeaders IColumnHeaders;
#endif 	/* __IColumnHeaders_FWD_DEFINED__ */


#ifndef __IColumnHeader_FWD_DEFINED__
#define __IColumnHeader_FWD_DEFINED__
typedef interface IColumnHeader IColumnHeader;
#endif 	/* __IColumnHeader_FWD_DEFINED__ */


#ifndef __IListSubItems_FWD_DEFINED__
#define __IListSubItems_FWD_DEFINED__
typedef interface IListSubItems IListSubItems;
#endif 	/* __IListSubItems_FWD_DEFINED__ */


#ifndef __IListSubItem_FWD_DEFINED__
#define __IListSubItem_FWD_DEFINED__
typedef interface IListSubItem IListSubItem;
#endif 	/* __IListSubItem_FWD_DEFINED__ */


#ifndef __IImageList_FWD_DEFINED__
#define __IImageList_FWD_DEFINED__
typedef interface IImageList IImageList;
#endif 	/* __IImageList_FWD_DEFINED__ */


#ifndef __ImageListEvents_FWD_DEFINED__
#define __ImageListEvents_FWD_DEFINED__
typedef interface ImageListEvents ImageListEvents;
#endif 	/* __ImageListEvents_FWD_DEFINED__ */


#ifndef __IImages_FWD_DEFINED__
#define __IImages_FWD_DEFINED__
typedef interface IImages IImages;
#endif 	/* __IImages_FWD_DEFINED__ */


#ifndef __IImage_FWD_DEFINED__
#define __IImage_FWD_DEFINED__
typedef interface IImage IImage;
#endif 	/* __IImage_FWD_DEFINED__ */


#ifndef __ISlider_FWD_DEFINED__
#define __ISlider_FWD_DEFINED__
typedef interface ISlider ISlider;
#endif 	/* __ISlider_FWD_DEFINED__ */


#ifndef __ISliderEvents_FWD_DEFINED__
#define __ISliderEvents_FWD_DEFINED__
typedef interface ISliderEvents ISliderEvents;
#endif 	/* __ISliderEvents_FWD_DEFINED__ */


#ifndef __IControls_FWD_DEFINED__
#define __IControls_FWD_DEFINED__
typedef interface IControls IControls;
#endif 	/* __IControls_FWD_DEFINED__ */


#ifndef __IComboItem_FWD_DEFINED__
#define __IComboItem_FWD_DEFINED__
typedef interface IComboItem IComboItem;
#endif 	/* __IComboItem_FWD_DEFINED__ */


#ifndef __IComboItems_FWD_DEFINED__
#define __IComboItems_FWD_DEFINED__
typedef interface IComboItems IComboItems;
#endif 	/* __IComboItems_FWD_DEFINED__ */


#ifndef __IImageCombo_FWD_DEFINED__
#define __IImageCombo_FWD_DEFINED__
typedef interface IImageCombo IImageCombo;
#endif 	/* __IImageCombo_FWD_DEFINED__ */


#ifndef __DImageComboEvents_FWD_DEFINED__
#define __DImageComboEvents_FWD_DEFINED__
typedef interface DImageComboEvents DImageComboEvents;
#endif 	/* __DImageComboEvents_FWD_DEFINED__ */


#ifndef __DataObject_FWD_DEFINED__
#define __DataObject_FWD_DEFINED__

#ifdef __cplusplus
typedef class DataObject DataObject;
#else
typedef struct DataObject DataObject;
#endif /* __cplusplus */

#endif 	/* __DataObject_FWD_DEFINED__ */


#ifndef __DataObjectFiles_FWD_DEFINED__
#define __DataObjectFiles_FWD_DEFINED__

#ifdef __cplusplus
typedef class DataObjectFiles DataObjectFiles;
#else
typedef struct DataObjectFiles DataObjectFiles;
#endif /* __cplusplus */

#endif 	/* __DataObjectFiles_FWD_DEFINED__ */


#ifndef __TabStrip_FWD_DEFINED__
#define __TabStrip_FWD_DEFINED__

#ifdef __cplusplus
typedef class TabStrip TabStrip;
#else
typedef struct TabStrip TabStrip;
#endif /* __cplusplus */

#endif 	/* __TabStrip_FWD_DEFINED__ */


#ifndef __Tabs_FWD_DEFINED__
#define __Tabs_FWD_DEFINED__

#ifdef __cplusplus
typedef class Tabs Tabs;
#else
typedef struct Tabs Tabs;
#endif /* __cplusplus */

#endif 	/* __Tabs_FWD_DEFINED__ */


#ifndef __Tab_FWD_DEFINED__
#define __Tab_FWD_DEFINED__

#ifdef __cplusplus
typedef class Tab Tab;
#else
typedef struct Tab Tab;
#endif /* __cplusplus */

#endif 	/* __Tab_FWD_DEFINED__ */


#ifndef __Toolbar_FWD_DEFINED__
#define __Toolbar_FWD_DEFINED__

#ifdef __cplusplus
typedef class Toolbar Toolbar;
#else
typedef struct Toolbar Toolbar;
#endif /* __cplusplus */

#endif 	/* __Toolbar_FWD_DEFINED__ */


#ifndef __Buttons_FWD_DEFINED__
#define __Buttons_FWD_DEFINED__

#ifdef __cplusplus
typedef class Buttons Buttons;
#else
typedef struct Buttons Buttons;
#endif /* __cplusplus */

#endif 	/* __Buttons_FWD_DEFINED__ */


#ifndef __ButtonMenus_FWD_DEFINED__
#define __ButtonMenus_FWD_DEFINED__

#ifdef __cplusplus
typedef class ButtonMenus ButtonMenus;
#else
typedef struct ButtonMenus ButtonMenus;
#endif /* __cplusplus */

#endif 	/* __ButtonMenus_FWD_DEFINED__ */


#ifndef __StatusBar_FWD_DEFINED__
#define __StatusBar_FWD_DEFINED__

#ifdef __cplusplus
typedef class StatusBar StatusBar;
#else
typedef struct StatusBar StatusBar;
#endif /* __cplusplus */

#endif 	/* __StatusBar_FWD_DEFINED__ */


#ifndef __Panels_FWD_DEFINED__
#define __Panels_FWD_DEFINED__

#ifdef __cplusplus
typedef class Panels Panels;
#else
typedef struct Panels Panels;
#endif /* __cplusplus */

#endif 	/* __Panels_FWD_DEFINED__ */


#ifndef __ProgressBar_FWD_DEFINED__
#define __ProgressBar_FWD_DEFINED__

#ifdef __cplusplus
typedef class ProgressBar ProgressBar;
#else
typedef struct ProgressBar ProgressBar;
#endif /* __cplusplus */

#endif 	/* __ProgressBar_FWD_DEFINED__ */


#ifndef __TreeView_FWD_DEFINED__
#define __TreeView_FWD_DEFINED__

#ifdef __cplusplus
typedef class TreeView TreeView;
#else
typedef struct TreeView TreeView;
#endif /* __cplusplus */

#endif 	/* __TreeView_FWD_DEFINED__ */


#ifndef __Nodes_FWD_DEFINED__
#define __Nodes_FWD_DEFINED__

#ifdef __cplusplus
typedef class Nodes Nodes;
#else
typedef struct Nodes Nodes;
#endif /* __cplusplus */

#endif 	/* __Nodes_FWD_DEFINED__ */


#ifndef __ListView_FWD_DEFINED__
#define __ListView_FWD_DEFINED__

#ifdef __cplusplus
typedef class ListView ListView;
#else
typedef struct ListView ListView;
#endif /* __cplusplus */

#endif 	/* __ListView_FWD_DEFINED__ */


#ifndef __ListItems_FWD_DEFINED__
#define __ListItems_FWD_DEFINED__

#ifdef __cplusplus
typedef class ListItems ListItems;
#else
typedef struct ListItems ListItems;
#endif /* __cplusplus */

#endif 	/* __ListItems_FWD_DEFINED__ */


#ifndef __ColumnHeaders_FWD_DEFINED__
#define __ColumnHeaders_FWD_DEFINED__

#ifdef __cplusplus
typedef class ColumnHeaders ColumnHeaders;
#else
typedef struct ColumnHeaders ColumnHeaders;
#endif /* __cplusplus */

#endif 	/* __ColumnHeaders_FWD_DEFINED__ */


#ifndef __ListSubItems_FWD_DEFINED__
#define __ListSubItems_FWD_DEFINED__

#ifdef __cplusplus
typedef class ListSubItems ListSubItems;
#else
typedef struct ListSubItems ListSubItems;
#endif /* __cplusplus */

#endif 	/* __ListSubItems_FWD_DEFINED__ */


#ifndef __ListSubItem_FWD_DEFINED__
#define __ListSubItem_FWD_DEFINED__

#ifdef __cplusplus
typedef class ListSubItem ListSubItem;
#else
typedef struct ListSubItem ListSubItem;
#endif /* __cplusplus */

#endif 	/* __ListSubItem_FWD_DEFINED__ */


#ifndef __ImageList_FWD_DEFINED__
#define __ImageList_FWD_DEFINED__

#ifdef __cplusplus
typedef class ImageList ImageList;
#else
typedef struct ImageList ImageList;
#endif /* __cplusplus */

#endif 	/* __ImageList_FWD_DEFINED__ */


#ifndef __ListImages_FWD_DEFINED__
#define __ListImages_FWD_DEFINED__

#ifdef __cplusplus
typedef class ListImages ListImages;
#else
typedef struct ListImages ListImages;
#endif /* __cplusplus */

#endif 	/* __ListImages_FWD_DEFINED__ */


#ifndef __ListImage_FWD_DEFINED__
#define __ListImage_FWD_DEFINED__

#ifdef __cplusplus
typedef class ListImage ListImage;
#else
typedef struct ListImage ListImage;
#endif /* __cplusplus */

#endif 	/* __ListImage_FWD_DEFINED__ */


#ifndef __Slider_FWD_DEFINED__
#define __Slider_FWD_DEFINED__

#ifdef __cplusplus
typedef class Slider Slider;
#else
typedef struct Slider Slider;
#endif /* __cplusplus */

#endif 	/* __Slider_FWD_DEFINED__ */


#ifndef __Controls_FWD_DEFINED__
#define __Controls_FWD_DEFINED__

#ifdef __cplusplus
typedef class Controls Controls;
#else
typedef struct Controls Controls;
#endif /* __cplusplus */

#endif 	/* __Controls_FWD_DEFINED__ */


#ifndef __ComboItem_FWD_DEFINED__
#define __ComboItem_FWD_DEFINED__

#ifdef __cplusplus
typedef class ComboItem ComboItem;
#else
typedef struct ComboItem ComboItem;
#endif /* __cplusplus */

#endif 	/* __ComboItem_FWD_DEFINED__ */


#ifndef __ComboItems_FWD_DEFINED__
#define __ComboItems_FWD_DEFINED__

#ifdef __cplusplus
typedef class ComboItems ComboItems;
#else
typedef struct ComboItems ComboItems;
#endif /* __cplusplus */

#endif 	/* __ComboItems_FWD_DEFINED__ */


#ifndef __ImageCombo_FWD_DEFINED__
#define __ImageCombo_FWD_DEFINED__

#ifdef __cplusplus
typedef class ImageCombo ImageCombo;
#else
typedef struct ImageCombo ImageCombo;
#endif /* __cplusplus */

#endif 	/* __ImageCombo_FWD_DEFINED__ */


#ifdef __cplusplus
extern "C"{
#endif 

// Conflict with public annotations
#pragma warning(suppress:26022)
void * __RPC_USER MIDL_user_allocate(size_t);
// Conflict with public annotations
#pragma warning(suppress:26023)
#pragma warning(suppress: 4985)		// Windows annotates with declspecs
void __RPC_USER MIDL_user_free( _Inout_ void * ); 


#ifndef __MSComctlLib_LIBRARY_DEFINED__
#define __MSComctlLib_LIBRARY_DEFINED__

/* library MSComctlLib */
/* [helpcontext][helpfile][helpstring][version][uuid] */ 










































typedef float single;

typedef IButton Button;

typedef IButtonMenu ButtonMenu;

typedef IPanel Panel;

typedef INode Node;

typedef IColumnHeader ColumnHeader;

typedef IListItem ListItem;

typedef /* [public][public][public][public][public][public][public][public][public][public][public][helpcontext][helpstring][uuid] */  DECLSPEC_UUID("76B523C0-8579-11D1-B16A-00C0F0283628") 
enum __MIDL___MIDL_itf_mscomctl_0116_0001
    {	ccNone	= 0,
	ccFixedSingle	= 1
    } 	BorderStyleConstants;

typedef /* [public][public][public][public][public][public][public][public][public][public][public][public][public][public][public][public][public][helpcontext][helpstring][uuid] */  DECLSPEC_UUID("76B523C1-8579-11D1-B16A-00C0F0283628") 
enum __MIDL___MIDL_itf_mscomctl_0116_0002
    {	ccDefault	= 0,
	ccArrow	= 1,
	ccCross	= 2,
	ccIBeam	= 3,
	ccIcon	= 4,
	ccSize	= 5,
	ccSizeNESW	= 6,
	ccSizeNS	= 7,
	ccSizeNWSE	= 8,
	ccSizeEW	= 9,
	ccUpArrow	= 10,
	ccHourglass	= 11,
	ccNoDrop	= 12,
	ccArrowHourglass	= 13,
	ccArrowQuestion	= 14,
	ccSizeAll	= 15,
	ccCustom	= 99
    } 	MousePointerConstants;

typedef /* [public][public][public][public][public][public][public][public][public][helpcontext][helpstring][uuid] */  DECLSPEC_UUID("76B523C2-8579-11D1-B16A-00C0F0283628") 
enum __MIDL___MIDL_itf_mscomctl_0116_0003
    {	ccFlat	= 0,
	cc3D	= 1
    } 	AppearanceConstants;

typedef /* [public] */ 
enum __MIDL___MIDL_itf_mscomctl_0116_0004
    {	vbFlat	= 0,
	vb3D	= 1
    } 	VB4AppearanceConstants;

typedef /* [public][public][public][helpcontext][helpstring][uuid] */  DECLSPEC_UUID("76B523C3-8579-11D1-B16A-00C0F0283628") 
enum __MIDL___MIDL_itf_mscomctl_0116_0005
    {	ccScrollingStandard	= 0,
	ccScrollingSmooth	= 1
    } 	ScrollingConstants;

typedef /* [public][public][public][public][public][helpcontext][helpstring][uuid] */  DECLSPEC_UUID("76B523C4-8579-11D1-B16A-00C0F0283628") 
enum __MIDL___MIDL_itf_mscomctl_0116_0006
    {	ccOrientationHorizontal	= 0,
	ccOrientationVertical	= 1
    } 	OrientationConstants;

typedef /* [public][public][public][public][public][public][public][helpcontext][helpstring][uuid] */  DECLSPEC_UUID("D8898460-742F-11CF-8AEA-00AA00C00905") 
enum __MIDL___MIDL_itf_mscomctl_0116_0007
    {	ccOLEDragManual	= 0,
	ccOLEDragAutomatic	= 1
    } 	OLEDragConstants;

typedef /* [public][public][public][public][public][public][public][public][public][public][public][public][public][public][public][public][public][helpcontext][helpstring][uuid] */  DECLSPEC_UUID("D8898461-742F-11CF-8AEA-00AA00C00905") 
enum __MIDL___MIDL_itf_mscomctl_0116_0008
    {	ccOLEDropNone	= 0,
	ccOLEDropManual	= 1
    } 	OLEDropConstants;

typedef /* [public][helpcontext][helpstring][uuid] */  DECLSPEC_UUID("D8898464-742F-11CF-8AEA-00AA00C00905") 
enum __MIDL___MIDL_itf_mscomctl_0116_0009
    {	ccEnter	= 0,
	ccLeave	= 1,
	ccOver	= 2
    } 	DragOverConstants;

typedef /* [public][helpcontext][helpstring][uuid] */  DECLSPEC_UUID("D8898462-742F-11CF-8AEA-00AA00C00905") 
enum __MIDL___MIDL_itf_mscomctl_0116_0010
    {	ccCFText	= 1,
	ccCFBitmap	= 2,
	ccCFMetafile	= 3,
	ccCFDIB	= 8,
	ccCFPalette	= 9,
	ccCFEMetafile	= 14,
	ccCFFiles	= 15,
	ccCFRTF	= 0xffffbf01
    } 	ClipBoardConstants;

typedef /* [public][helpcontext][helpstring][uuid] */  DECLSPEC_UUID("D8898463-742F-11CF-8AEA-00AA00C00905") 
enum __MIDL___MIDL_itf_mscomctl_0116_0011
    {	ccOLEDropEffectNone	= 0,
	ccOLEDropEffectCopy	= 1,
	ccOLEDropEffectMove	= 2,
	ccOLEDropEffectScroll	= 0x80000000
    } 	OLEDropEffectConstants;

typedef /* [public][helpcontext][helpstring][uuid] */  DECLSPEC_UUID("76B523C5-8579-11D1-B16A-00C0F0283628") 
enum __MIDL___MIDL_itf_mscomctl_0116_0012
    {	ccInvalidProcedureCall	= 5,
	ccOutOfMemory	= 7,
	ccTypeMismatch	= 13,
	ccObjectVariableNotSet	= 91,
	ccInvalidPropertyValue	= 380,
	ccSetNotSupportedAtRuntime	= 382,
	ccSetNotSupported	= 383,
	ccSetNotPermitted	= 387,
	ccGetNotSupported	= 394,
	ccInvalidPicture	= 481,
	ccInvalidObjectUse	= 425,
	ccWrongClipboardFormat	= 461,
	ccDataObjectLocked	= 672,
	ccExpectedAnArgument	= 673,
	ccRecursiveOleDrag	= 674,
	ccFormatNotByteArray	= 675,
	ccDataNotSetForFormat	= 676,
	ccIndexOutOfBounds	= 35600,
	ccElemNotFound	= 35601,
	ccNonUniqueKey	= 35602,
	ccInvalidKey	= 35603,
	ccElemNotPartOfCollection	= 35605,
	ccCollectionChangedDuringEnum	= 35606,
	ccWouldIntroduceCycle	= 35614,
	ccMissingRequiredArg	= 35607,
	ccBadObjectReference	= 35610,
	ccCircularReference	= 35700,
	ccCol1MustBeLeftAligned	= 35604,
	ccReadOnlyIfHasImages	= 35611,
	ccImageListMustBeInitialized	= 35613,
	ccNotSameSize	= 35615,
	ccImageListLocked	= 35617,
	ccMaxPanelsExceeded	= 35616,
	ccMaxButtonsExceeded	= 35619,
	ccInvalidSafeModeProcCall	= 680
    } 	ErrorConstants;

typedef /* [public][public][public][helpcontext][helpstring][uuid] */  DECLSPEC_UUID("1EFB6590-857C-11D1-B16A-00C0F0283628") 
enum __MIDL___MIDL_itf_mscomctl_0116_0013
    {	tabJustified	= 0,
	tabNonJustified	= 1,
	tabFixed	= 2
    } 	TabWidthStyleConstants;

typedef /* [public][public][public][helpcontext][helpstring][uuid] */  DECLSPEC_UUID("1EFB6591-857C-11D1-B16A-00C0F0283628") 
enum __MIDL___MIDL_itf_mscomctl_0116_0014
    {	tabTabs	= 0,
	tabButtons	= 1,
	tabFlatButtons	= 2
    } 	TabStyleConstants;

typedef /* [public][public][public][helpcontext][helpstring][uuid] */  DECLSPEC_UUID("1EFB6592-857C-11D1-B16A-00C0F0283628") 
enum __MIDL___MIDL_itf_mscomctl_0116_0015
    {	tabPlacementTop	= 0,
	tabPlacementBottom	= 1,
	tabPlacementLeft	= 2,
	tabPlacementRight	= 3
    } 	PlacementConstants;

typedef /* [public][public][public][helpcontext][helpstring][uuid] */  DECLSPEC_UUID("1EFB6593-857C-11D1-B16A-00C0F0283628") 
enum __MIDL___MIDL_itf_mscomctl_0116_0016
    {	tabTabStandard	= 0,
	tabTabOpposite	= 1
    } 	TabSelStyleConstants;

typedef /* [public][public][public][helpcontext][helpstring][uuid] */  DECLSPEC_UUID("66833FE0-8583-11D1-B16A-00C0F0283628") 
enum __MIDL___MIDL_itf_mscomctl_0120_0001
    {	tbrDefault	= 0,
	tbrCheck	= 1,
	tbrButtonGroup	= 2,
	tbrSeparator	= 3,
	tbrPlaceholder	= 4,
	tbrDropdown	= 5
    } 	ButtonStyleConstants;

typedef /* [public][public][public][helpcontext][helpstring][uuid] */  DECLSPEC_UUID("66833FE1-8583-11D1-B16A-00C0F0283628") 
enum __MIDL___MIDL_itf_mscomctl_0120_0002
    {	tbrUnpressed	= 0,
	tbrPressed	= 1
    } 	ValueConstants;

typedef /* [public][public][public][helpcontext][helpstring][uuid] */  DECLSPEC_UUID("66833FE2-8583-11D1-B16A-00C0F0283628") 
enum __MIDL___MIDL_itf_mscomctl_0120_0003
    {	tbrStandard	= 0,
	tbrFlat	= 1
    } 	ToolbarStyleConstants;

typedef /* [public][public][public][helpcontext][helpstring][uuid] */  DECLSPEC_UUID("66833FE3-8583-11D1-B16A-00C0F0283628") 
enum __MIDL___MIDL_itf_mscomctl_0120_0004
    {	tbrTextAlignBottom	= 0,
	tbrTextAlignRight	= 1
    } 	ToolbarTextAlignConstants;

typedef /* [public][public][public][helpcontext][helpstring][uuid] */  DECLSPEC_UUID("8E3867A0-8586-11D1-B16A-00C0F0283628") 
enum __MIDL___MIDL_itf_mscomctl_0126_0001
    {	sbrNormal	= 0,
	sbrSimple	= 1
    } 	SbarStyleConstants;

typedef /* [public][public][public][helpcontext][helpstring][uuid] */  DECLSPEC_UUID("8E3867A6-8586-11D1-B16A-00C0F0283628") 
enum __MIDL___MIDL_itf_mscomctl_0129_0001
    {	sbrLeft	= 0,
	sbrCenter	= 1,
	sbrRight	= 2
    } 	PanelAlignmentConstants;

typedef /* [public][public][public][helpcontext][helpstring][uuid] */  DECLSPEC_UUID("8E3867A7-8586-11D1-B16A-00C0F0283628") 
enum __MIDL___MIDL_itf_mscomctl_0129_0002
    {	sbrNoAutoSize	= 0,
	sbrSpring	= 1,
	sbrContents	= 2
    } 	PanelAutoSizeConstants;

typedef /* [public][public][public][helpcontext][helpstring][uuid] */  DECLSPEC_UUID("8E3867A8-8586-11D1-B16A-00C0F0283628") 
enum __MIDL___MIDL_itf_mscomctl_0129_0003
    {	sbrNoBevel	= 0,
	sbrInset	= 1,
	sbrRaised	= 2
    } 	PanelBevelConstants;

typedef /* [public][public][public][helpcontext][helpstring][uuid] */  DECLSPEC_UUID("8E3867A9-8586-11D1-B16A-00C0F0283628") 
enum __MIDL___MIDL_itf_mscomctl_0129_0004
    {	sbrText	= 0,
	sbrCaps	= 1,
	sbrNum	= 2,
	sbrIns	= 3,
	sbrScrl	= 4,
	sbrTime	= 5,
	sbrDate	= 6,
	sbrKana	= 7
    } 	PanelStyleConstants;

typedef /* [public][public][public][helpcontext][helpstring][uuid] */  DECLSPEC_UUID("C74190B0-8589-11D1-B16A-00C0F0283628") 
enum __MIDL___MIDL_itf_mscomctl_0132_0001
    {	tvwAutomatic	= 0,
	tvwManual	= 1
    } 	LabelEditConstants;

typedef /* [public][public][public][helpcontext][helpstring][uuid] */  DECLSPEC_UUID("C74190B1-8589-11D1-B16A-00C0F0283628") 
enum __MIDL___MIDL_itf_mscomctl_0132_0002
    {	tvwTreeLines	= 0,
	tvwRootLines	= 1
    } 	TreeLineStyleConstants;

typedef /* [public][public][public][helpcontext][helpstring][uuid] */  DECLSPEC_UUID("C74190B2-8589-11D1-B16A-00C0F0283628") 
enum __MIDL___MIDL_itf_mscomctl_0132_0003
    {	tvwTextOnly	= 0,
	tvwPictureText	= 1,
	tvwPlusMinusText	= 2,
	tvwPlusPictureText	= 3,
	tvwTreelinesText	= 4,
	tvwTreelinesPictureText	= 5,
	tvwTreelinesPlusMinusText	= 6,
	tvwTreelinesPlusMinusPictureText	= 7
    } 	TreeStyleConstants;

typedef /* [public][helpcontext][helpstring][uuid] */  DECLSPEC_UUID("C74190B3-8589-11D1-B16A-00C0F0283628") 
enum __MIDL___MIDL_itf_mscomctl_0132_0004
    {	tvwFirst	= 0,
	tvwLast	= 1,
	tvwNext	= 2,
	tvwPrevious	= 3,
	tvwChild	= 4
    } 	TreeRelationshipConstants;

typedef /* [public][public][public][helpcontext][helpstring][uuid] */  DECLSPEC_UUID("BDD1F040-858B-11D1-B16A-00C0F0283628") 
enum __MIDL___MIDL_itf_mscomctl_0136_0001
    {	lvwTransparent	= 0,
	lvwOpaque	= 1
    } 	ListTextBackgroundConstants;

typedef /* [public][public][public][helpcontext][helpstring][uuid] */  DECLSPEC_UUID("BDD1F041-858B-11D1-B16A-00C0F0283628") 
enum __MIDL___MIDL_itf_mscomctl_0136_0002
    {	lvwNone	= 0,
	lvwAutoLeft	= 1,
	lvwAutoTop	= 2
    } 	ListArrangeConstants;

typedef /* [public][public][public][helpcontext][helpstring][uuid] */  DECLSPEC_UUID("BDD1F042-858B-11D1-B16A-00C0F0283628") 
enum __MIDL___MIDL_itf_mscomctl_0136_0003
    {	lvwTopLeft	= 0,
	lvwTopRight	= 1,
	lvwBottomLeft	= 2,
	lvwBottomRight	= 3,
	lvwCenter	= 4,
	lvwTile	= 5
    } 	ListPictureAlignmentConstants;

typedef /* [public][public][public][helpcontext][helpstring][uuid] */  DECLSPEC_UUID("BDD1F043-858B-11D1-B16A-00C0F0283628") 
enum __MIDL___MIDL_itf_mscomctl_0136_0004
    {	lvwAutomatic	= 0,
	lvwManual	= 1
    } 	ListLabelEditConstants;

typedef /* [public][public][public][helpcontext][helpstring][uuid] */  DECLSPEC_UUID("BDD1F044-858B-11D1-B16A-00C0F0283628") 
enum __MIDL___MIDL_itf_mscomctl_0136_0005
    {	lvwAscending	= 0,
	lvwDescending	= 1
    } 	ListSortOrderConstants;

typedef /* [public][public][public][helpcontext][helpstring][uuid] */  DECLSPEC_UUID("BDD1F045-858B-11D1-B16A-00C0F0283628") 
enum __MIDL___MIDL_itf_mscomctl_0136_0006
    {	lvwIcon	= 0,
	lvwSmallIcon	= 1,
	lvwList	= 2,
	lvwReport	= 3
    } 	ListViewConstants;

typedef /* [public][public][public][helpcontext][helpstring][uuid] */  DECLSPEC_UUID("BDD1F046-858B-11D1-B16A-00C0F0283628") 
enum __MIDL___MIDL_itf_mscomctl_0136_0007
    {	lvwColumnLeft	= 0,
	lvwColumnRight	= 1,
	lvwColumnCenter	= 2
    } 	ListColumnAlignmentConstants;

typedef /* [public][helpcontext][helpstring][uuid] */  DECLSPEC_UUID("BDD1F047-858B-11D1-B16A-00C0F0283628") 
enum __MIDL___MIDL_itf_mscomctl_0136_0008
    {	lvwText	= 0,
	lvwSubItem	= 1,
	lvwTag	= 2
    } 	ListFindItemWhereConstants;

typedef /* [public][helpcontext][helpstring][uuid] */  DECLSPEC_UUID("BDD1F048-858B-11D1-B16A-00C0F0283628") 
enum __MIDL___MIDL_itf_mscomctl_0136_0009
    {	lvwWhole	= 0,
	lvwPartial	= 1
    } 	ListFindItemHowConstants;

typedef /* [public][helpcontext][helpstring][uuid] */  DECLSPEC_UUID("2C247F20-8591-11D1-B16A-00C0F0283628") 
enum __MIDL___MIDL_itf_mscomctl_0144_0001
    {	imlNormal	= 0,
	imlTransparent	= 1,
	imlSelected	= 2,
	imlFocus	= 3
    } 	ImageDrawConstants;

typedef /* [public][public][public][helpcontext][helpstring][uuid] */  DECLSPEC_UUID("F08DF950-8592-11D1-B16A-00C0F0283628") 
enum __MIDL___MIDL_itf_mscomctl_0148_0001
    {	sldBottomRight	= 0,
	sldTopLeft	= 1,
	sldBoth	= 2,
	sldNoTicks	= 3
    } 	TickStyleConstants;

typedef /* [public][public][public][helpcontext][helpstring][uuid] */  DECLSPEC_UUID("F08DF951-8592-11D1-B16A-00C0F0283628") 
enum __MIDL___MIDL_itf_mscomctl_0148_0002
    {	sldAboveLeft	= 0,
	sldBelowRight	= 1
    } 	TextPositionConstants;

typedef /* [public][public][public][helpcontext][helpstring][uuid] */  DECLSPEC_UUID("DD9DA667-8594-11D1-B16A-00C0F0283628") 
enum __MIDL___MIDL_itf_mscomctl_0153_0001
    {	ImgCboDropdownCombo	= 0,
	ImgCboSimpleCombo	= 1,
	ImgCboDropdownList	= 2
    } 	ImageComboStyleConstants;


EXTERN_C const IID LIBID_MSComctlLib;

#ifndef __IVBDataObject_INTERFACE_DEFINED__
#define __IVBDataObject_INTERFACE_DEFINED__

/* interface IVBDataObject */
/* [object][oleautomation][nonextensible][dual][hidden][uuid] */ 


EXTERN_C const IID IID_IVBDataObject;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("2334D2B1-713E-11CF-8AE5-00AA00C00905")
    IVBDataObject : public IDispatch
    {
    public:
        virtual /* [helpcontext][helpstring][id] */ HRESULT STDMETHODCALLTYPE Clear( void) = 0;
        
        virtual /* [helpcontext][helpstring][id] */ HRESULT STDMETHODCALLTYPE GetData( 
            /* [in] */ short sFormat,
            /* [retval][out] */ VARIANT *pvData) = 0;
        
        virtual /* [helpcontext][helpstring][id] */ HRESULT STDMETHODCALLTYPE GetFormat( 
            /* [in] */ short sFormat,
            /* [retval][out] */ VARIANT_BOOL *pbFormatSupported) = 0;
        
        virtual /* [helpcontext][helpstring][id] */ HRESULT STDMETHODCALLTYPE SetData( 
            /* [optional][in] */ VARIANT vValue,
            /* [optional][in] */ VARIANT vFormat) = 0;
        
        virtual /* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_Files( 
            /* [retval][out] */ IVBDataObjectFiles **pFiles) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IVBDataObjectVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IVBDataObject * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IVBDataObject * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IVBDataObject * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IVBDataObject * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IVBDataObject * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IVBDataObject * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IVBDataObject * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpcontext][helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Clear )( 
            IVBDataObject * This);
        
        /* [helpcontext][helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *GetData )( 
            IVBDataObject * This,
            /* [in] */ short sFormat,
            /* [retval][out] */ VARIANT *pvData);
        
        /* [helpcontext][helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *GetFormat )( 
            IVBDataObject * This,
            /* [in] */ short sFormat,
            /* [retval][out] */ VARIANT_BOOL *pbFormatSupported);
        
        /* [helpcontext][helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *SetData )( 
            IVBDataObject * This,
            /* [optional][in] */ VARIANT vValue,
            /* [optional][in] */ VARIANT vFormat);
        
        /* [helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_Files )( 
            IVBDataObject * This,
            /* [retval][out] */ IVBDataObjectFiles **pFiles);
        
        END_INTERFACE
    } IVBDataObjectVtbl;

    interface IVBDataObject
    {
        CONST_VTBL struct IVBDataObjectVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IVBDataObject_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IVBDataObject_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IVBDataObject_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IVBDataObject_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IVBDataObject_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IVBDataObject_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IVBDataObject_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IVBDataObject_Clear(This)	\
    (This)->lpVtbl -> Clear(This)

#define IVBDataObject_GetData(This,sFormat,pvData)	\
    (This)->lpVtbl -> GetData(This,sFormat,pvData)

#define IVBDataObject_GetFormat(This,sFormat,pbFormatSupported)	\
    (This)->lpVtbl -> GetFormat(This,sFormat,pbFormatSupported)

#define IVBDataObject_SetData(This,vValue,vFormat)	\
    (This)->lpVtbl -> SetData(This,vValue,vFormat)

#define IVBDataObject_get_Files(This,pFiles)	\
    (This)->lpVtbl -> get_Files(This,pFiles)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpcontext][helpstring][id] */ HRESULT STDMETHODCALLTYPE IVBDataObject_Clear_Proxy( 
    IVBDataObject * This);


void __RPC_STUB IVBDataObject_Clear_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][id] */ HRESULT STDMETHODCALLTYPE IVBDataObject_GetData_Proxy( 
    IVBDataObject * This,
    /* [in] */ short sFormat,
    /* [retval][out] */ VARIANT *pvData);


void __RPC_STUB IVBDataObject_GetData_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][id] */ HRESULT STDMETHODCALLTYPE IVBDataObject_GetFormat_Proxy( 
    IVBDataObject * This,
    /* [in] */ short sFormat,
    /* [retval][out] */ VARIANT_BOOL *pbFormatSupported);


void __RPC_STUB IVBDataObject_GetFormat_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][id] */ HRESULT STDMETHODCALLTYPE IVBDataObject_SetData_Proxy( 
    IVBDataObject * This,
    /* [optional][in] */ VARIANT vValue,
    /* [optional][in] */ VARIANT vFormat);


void __RPC_STUB IVBDataObject_SetData_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IVBDataObject_get_Files_Proxy( 
    IVBDataObject * This,
    /* [retval][out] */ IVBDataObjectFiles **pFiles);


void __RPC_STUB IVBDataObject_get_Files_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IVBDataObject_INTERFACE_DEFINED__ */


#ifndef __IVBDataObjectFiles_INTERFACE_DEFINED__
#define __IVBDataObjectFiles_INTERFACE_DEFINED__

/* interface IVBDataObjectFiles */
/* [object][oleautomation][nonextensible][dual][hidden][uuid] */ 


EXTERN_C const IID IID_IVBDataObjectFiles;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("2334D2B3-713E-11CF-8AE5-00AA00C00905")
    IVBDataObjectFiles : public IDispatch
    {
    public:
        virtual /* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_Item( 
            /* [in] */ long lIndex,
            /* [retval][out] */ BSTR *bstrItem) = 0;
        
        virtual /* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_Count( 
            /* [retval][out] */ long *plCount) = 0;
        
        virtual /* [helpcontext][helpstring][id] */ HRESULT STDMETHODCALLTYPE Add( 
            /* [in] */ BSTR bstrFilename,
            /* [optional][in] */ VARIANT vIndex) = 0;
        
        virtual /* [helpcontext][helpstring][id] */ HRESULT STDMETHODCALLTYPE Clear( void) = 0;
        
        virtual /* [helpcontext][helpstring][id] */ HRESULT STDMETHODCALLTYPE Remove( 
            /* [in] */ VARIANT vIndex) = 0;
        
        virtual /* [hidden][id] */ HRESULT STDMETHODCALLTYPE _NewEnum( 
            /* [retval][out] */ IUnknown **ppUnk) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IVBDataObjectFilesVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IVBDataObjectFiles * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IVBDataObjectFiles * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IVBDataObjectFiles * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IVBDataObjectFiles * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IVBDataObjectFiles * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IVBDataObjectFiles * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IVBDataObjectFiles * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_Item )( 
            IVBDataObjectFiles * This,
            /* [in] */ long lIndex,
            /* [retval][out] */ BSTR *bstrItem);
        
        /* [helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_Count )( 
            IVBDataObjectFiles * This,
            /* [retval][out] */ long *plCount);
        
        /* [helpcontext][helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Add )( 
            IVBDataObjectFiles * This,
            /* [in] */ BSTR bstrFilename,
            /* [optional][in] */ VARIANT vIndex);
        
        /* [helpcontext][helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Clear )( 
            IVBDataObjectFiles * This);
        
        /* [helpcontext][helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Remove )( 
            IVBDataObjectFiles * This,
            /* [in] */ VARIANT vIndex);
        
        /* [hidden][id] */ HRESULT ( STDMETHODCALLTYPE *_NewEnum )( 
            IVBDataObjectFiles * This,
            /* [retval][out] */ IUnknown **ppUnk);
        
        END_INTERFACE
    } IVBDataObjectFilesVtbl;

    interface IVBDataObjectFiles
    {
        CONST_VTBL struct IVBDataObjectFilesVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IVBDataObjectFiles_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IVBDataObjectFiles_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IVBDataObjectFiles_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IVBDataObjectFiles_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IVBDataObjectFiles_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IVBDataObjectFiles_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IVBDataObjectFiles_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IVBDataObjectFiles_get_Item(This,lIndex,bstrItem)	\
    (This)->lpVtbl -> get_Item(This,lIndex,bstrItem)

#define IVBDataObjectFiles_get_Count(This,plCount)	\
    (This)->lpVtbl -> get_Count(This,plCount)

#define IVBDataObjectFiles_Add(This,bstrFilename,vIndex)	\
    (This)->lpVtbl -> Add(This,bstrFilename,vIndex)

#define IVBDataObjectFiles_Clear(This)	\
    (This)->lpVtbl -> Clear(This)

#define IVBDataObjectFiles_Remove(This,vIndex)	\
    (This)->lpVtbl -> Remove(This,vIndex)

#define IVBDataObjectFiles__NewEnum(This,ppUnk)	\
    (This)->lpVtbl -> _NewEnum(This,ppUnk)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IVBDataObjectFiles_get_Item_Proxy( 
    IVBDataObjectFiles * This,
    /* [in] */ long lIndex,
    /* [retval][out] */ BSTR *bstrItem);


void __RPC_STUB IVBDataObjectFiles_get_Item_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IVBDataObjectFiles_get_Count_Proxy( 
    IVBDataObjectFiles * This,
    /* [retval][out] */ long *plCount);


void __RPC_STUB IVBDataObjectFiles_get_Count_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][id] */ HRESULT STDMETHODCALLTYPE IVBDataObjectFiles_Add_Proxy( 
    IVBDataObjectFiles * This,
    /* [in] */ BSTR bstrFilename,
    /* [optional][in] */ VARIANT vIndex);


void __RPC_STUB IVBDataObjectFiles_Add_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][id] */ HRESULT STDMETHODCALLTYPE IVBDataObjectFiles_Clear_Proxy( 
    IVBDataObjectFiles * This);


void __RPC_STUB IVBDataObjectFiles_Clear_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][id] */ HRESULT STDMETHODCALLTYPE IVBDataObjectFiles_Remove_Proxy( 
    IVBDataObjectFiles * This,
    /* [in] */ VARIANT vIndex);


void __RPC_STUB IVBDataObjectFiles_Remove_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [hidden][id] */ HRESULT STDMETHODCALLTYPE IVBDataObjectFiles__NewEnum_Proxy( 
    IVBDataObjectFiles * This,
    /* [retval][out] */ IUnknown **ppUnk);


void __RPC_STUB IVBDataObjectFiles__NewEnum_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IVBDataObjectFiles_INTERFACE_DEFINED__ */


#ifndef __ITabStrip_INTERFACE_DEFINED__
#define __ITabStrip_INTERFACE_DEFINED__

/* interface ITabStrip */
/* [object][oleautomation][nonextensible][dual][helpcontext][helpstring][uuid] */ 


EXTERN_C const IID IID_ITabStrip;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("1EFB6594-857C-11D1-B16A-00C0F0283628")
    ITabStrip : public IDispatch
    {
    public:
        virtual /* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_Tabs( 
            /* [retval][out] */ ITabs **ppTabs) = 0;
        
        virtual /* [helpcontext][helpstring][propputref][id] */ HRESULT STDMETHODCALLTYPE putref_Tabs( 
            /* [in] */ ITabs *ppTabs) = 0;
        
        virtual /* [helpcontext][helpstring][requestedit][bindable][propget][id] */ HRESULT STDMETHODCALLTYPE get_Enabled( 
            /* [retval][out] */ VARIANT_BOOL *pbEnabled) = 0;
        
        virtual /* [helpcontext][helpstring][requestedit][bindable][propput][id] */ HRESULT STDMETHODCALLTYPE put_Enabled( 
            /* [in] */ VARIANT_BOOL pbEnabled) = 0;
        
        virtual /* [helpcontext][helpstring][bindable][propget][id] */ HRESULT STDMETHODCALLTYPE get_Font( 
            /* [retval][out] */ /* external definition not present */ IFontDisp **ppFontDisp) = 0;
        
        virtual /* [helpcontext][helpstring][bindable][propputref][id] */ HRESULT STDMETHODCALLTYPE putref_Font( 
            /* [in] */ /* external definition not present */ IFontDisp *ppFontDisp) = 0;
        
        virtual /* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_hWnd( 
            /* [retval][out] */ /* external definition not present */ OLE_HANDLE *phWnd) = 0;
        
        virtual /* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_hWnd( 
            /* [in] */ /* external definition not present */ OLE_HANDLE phWnd) = 0;
        
        virtual /* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_MouseIcon( 
            /* [retval][out] */ /* external definition not present */ IPictureDisp **ppMouseIcon) = 0;
        
        virtual /* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_MouseIcon( 
            /* [in] */ /* external definition not present */ IPictureDisp *ppMouseIcon) = 0;
        
        virtual /* [helpcontext][helpstring][propputref][id] */ HRESULT STDMETHODCALLTYPE putref_MouseIcon( 
            /* [in] */ /* external definition not present */ IPictureDisp *ppMouseIcon) = 0;
        
        virtual /* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_MultiRow( 
            /* [retval][out] */ VARIANT_BOOL *pbMultiRow) = 0;
        
        virtual /* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_MultiRow( 
            /* [in] */ VARIANT_BOOL pbMultiRow) = 0;
        
        virtual /* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_Style( 
            /* [retval][out] */ TabStyleConstants *psStyle) = 0;
        
        virtual /* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_Style( 
            /* [in] */ TabStyleConstants psStyle) = 0;
        
        virtual /* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_TabFixedWidth( 
            /* [retval][out] */ short *psTabFixedWidth) = 0;
        
        virtual /* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_TabFixedWidth( 
            /* [in] */ short psTabFixedWidth) = 0;
        
        virtual /* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_TabWidthStyle( 
            /* [retval][out] */ TabWidthStyleConstants *psTabWidthStyle) = 0;
        
        virtual /* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_TabWidthStyle( 
            /* [in] */ TabWidthStyleConstants psTabWidthStyle) = 0;
        
        virtual /* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_ClientTop( 
            /* [retval][out] */ single *pfClientTop) = 0;
        
        virtual /* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_ClientTop( 
            /* [in] */ single pfClientTop) = 0;
        
        virtual /* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_ClientLeft( 
            /* [retval][out] */ single *pfClientLeft) = 0;
        
        virtual /* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_ClientLeft( 
            /* [in] */ single pfClientLeft) = 0;
        
        virtual /* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_ClientHeight( 
            /* [retval][out] */ single *pfClientHeight) = 0;
        
        virtual /* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_ClientHeight( 
            /* [in] */ single pfClientHeight) = 0;
        
        virtual /* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_ClientWidth( 
            /* [retval][out] */ single *pfClientWidth) = 0;
        
        virtual /* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_ClientWidth( 
            /* [in] */ single pfClientWidth) = 0;
        
        virtual /* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_MousePointer( 
            /* [retval][out] */ MousePointerConstants *psMousePointer) = 0;
        
        virtual /* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_MousePointer( 
            /* [in] */ MousePointerConstants psMousePointer) = 0;
        
        virtual /* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_ImageList( 
            /* [retval][out] */ IDispatch **ppImageList) = 0;
        
        virtual /* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_ImageList( 
            /* [in] */ IDispatch *ppImageList) = 0;
        
        virtual /* [helpcontext][helpstring][propputref][id] */ HRESULT STDMETHODCALLTYPE putref_ImageList( 
            /* [in] */ IDispatch *ppImageList) = 0;
        
        virtual /* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_TabFixedHeight( 
            /* [retval][out] */ short *psTabFixedHeight) = 0;
        
        virtual /* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_TabFixedHeight( 
            /* [in] */ short psTabFixedHeight) = 0;
        
        virtual /* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_ShowTips( 
            /* [retval][out] */ VARIANT_BOOL *pbShowTips) = 0;
        
        virtual /* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_ShowTips( 
            /* [in] */ VARIANT_BOOL pbShowTips) = 0;
        
        virtual /* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_SelectedItem( 
            /* [retval][out] */ ITab **ppSelectedItem) = 0;
        
        virtual /* [helpcontext][helpstring][propputref][id] */ HRESULT STDMETHODCALLTYPE putref_SelectedItem( 
            /* [in] */ ITab *ppSelectedItem) = 0;
        
        virtual /* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_SelectedItem( 
            /* [in] */ VARIANT *ppSelectedItem) = 0;
        
        virtual /* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_OLEDropMode( 
            /* [retval][out] */ OLEDropConstants *psOLEDropMode) = 0;
        
        virtual /* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_OLEDropMode( 
            /* [in] */ OLEDropConstants psOLEDropMode) = 0;
        
        virtual /* [helpcontext][helpstring][id] */ HRESULT STDMETHODCALLTYPE Refresh( void) = 0;
        
        virtual /* [helpcontext][helpstring][id] */ HRESULT STDMETHODCALLTYPE OLEDrag( void) = 0;
        
        virtual /* [hidden][id] */ HRESULT STDMETHODCALLTYPE AboutBox( void) = 0;
        
        virtual /* [helpcontext][helpstring][requestedit][bindable][propget][id] */ HRESULT STDMETHODCALLTYPE get_HotTracking( 
            /* [retval][out] */ VARIANT_BOOL *pbHotTracking) = 0;
        
        virtual /* [helpcontext][helpstring][requestedit][bindable][propput][id] */ HRESULT STDMETHODCALLTYPE put_HotTracking( 
            /* [in] */ VARIANT_BOOL pbHotTracking) = 0;
        
        virtual /* [helpcontext][helpstring][requestedit][bindable][propget][id] */ HRESULT STDMETHODCALLTYPE get_MultiSelect( 
            /* [retval][out] */ VARIANT_BOOL *pbMultiSelect) = 0;
        
        virtual /* [helpcontext][helpstring][requestedit][bindable][propput][id] */ HRESULT STDMETHODCALLTYPE put_MultiSelect( 
            /* [in] */ VARIANT_BOOL pbMultiSelect) = 0;
        
        virtual /* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_Placement( 
            /* [retval][out] */ PlacementConstants *penumPlacement) = 0;
        
        virtual /* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_Placement( 
            /* [in] */ PlacementConstants penumPlacement) = 0;
        
        virtual /* [helpcontext][helpstring][requestedit][bindable][propget][id] */ HRESULT STDMETHODCALLTYPE get_Separators( 
            /* [retval][out] */ VARIANT_BOOL *pbSeparators) = 0;
        
        virtual /* [helpcontext][helpstring][requestedit][bindable][propput][id] */ HRESULT STDMETHODCALLTYPE put_Separators( 
            /* [in] */ VARIANT_BOOL pbSeparators) = 0;
        
        virtual /* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_TabMinWidth( 
            /* [retval][out] */ single *pflTabMinWidth) = 0;
        
        virtual /* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_TabMinWidth( 
            /* [in] */ single pflTabMinWidth) = 0;
        
        virtual /* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_TabStyle( 
            /* [retval][out] */ TabSelStyleConstants *penumTabStyle) = 0;
        
        virtual /* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_TabStyle( 
            /* [in] */ TabSelStyleConstants penumTabStyle) = 0;
        
        virtual /* [helpcontext][helpstring][id] */ HRESULT STDMETHODCALLTYPE DeselectAll( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITabStripVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ITabStrip * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ITabStrip * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ITabStrip * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            ITabStrip * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            ITabStrip * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            ITabStrip * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            ITabStrip * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_Tabs )( 
            ITabStrip * This,
            /* [retval][out] */ ITabs **ppTabs);
        
        /* [helpcontext][helpstring][propputref][id] */ HRESULT ( STDMETHODCALLTYPE *putref_Tabs )( 
            ITabStrip * This,
            /* [in] */ ITabs *ppTabs);
        
        /* [helpcontext][helpstring][requestedit][bindable][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_Enabled )( 
            ITabStrip * This,
            /* [retval][out] */ VARIANT_BOOL *pbEnabled);
        
        /* [helpcontext][helpstring][requestedit][bindable][propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_Enabled )( 
            ITabStrip * This,
            /* [in] */ VARIANT_BOOL pbEnabled);
        
        /* [helpcontext][helpstring][bindable][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_Font )( 
            ITabStrip * This,
            /* [retval][out] */ /* external definition not present */ IFontDisp **ppFontDisp);
        
        /* [helpcontext][helpstring][bindable][propputref][id] */ HRESULT ( STDMETHODCALLTYPE *putref_Font )( 
            ITabStrip * This,
            /* [in] */ /* external definition not present */ IFontDisp *ppFontDisp);
        
        /* [helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_hWnd )( 
            ITabStrip * This,
            /* [retval][out] */ /* external definition not present */ OLE_HANDLE *phWnd);
        
        /* [helpcontext][helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_hWnd )( 
            ITabStrip * This,
            /* [in] */ /* external definition not present */ OLE_HANDLE phWnd);
        
        /* [helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_MouseIcon )( 
            ITabStrip * This,
            /* [retval][out] */ /* external definition not present */ IPictureDisp **ppMouseIcon);
        
        /* [helpcontext][helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_MouseIcon )( 
            ITabStrip * This,
            /* [in] */ /* external definition not present */ IPictureDisp *ppMouseIcon);
        
        /* [helpcontext][helpstring][propputref][id] */ HRESULT ( STDMETHODCALLTYPE *putref_MouseIcon )( 
            ITabStrip * This,
            /* [in] */ /* external definition not present */ IPictureDisp *ppMouseIcon);
        
        /* [helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_MultiRow )( 
            ITabStrip * This,
            /* [retval][out] */ VARIANT_BOOL *pbMultiRow);
        
        /* [helpcontext][helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_MultiRow )( 
            ITabStrip * This,
            /* [in] */ VARIANT_BOOL pbMultiRow);
        
        /* [helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_Style )( 
            ITabStrip * This,
            /* [retval][out] */ TabStyleConstants *psStyle);
        
        /* [helpcontext][helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_Style )( 
            ITabStrip * This,
            /* [in] */ TabStyleConstants psStyle);
        
        /* [helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_TabFixedWidth )( 
            ITabStrip * This,
            /* [retval][out] */ short *psTabFixedWidth);
        
        /* [helpcontext][helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_TabFixedWidth )( 
            ITabStrip * This,
            /* [in] */ short psTabFixedWidth);
        
        /* [helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_TabWidthStyle )( 
            ITabStrip * This,
            /* [retval][out] */ TabWidthStyleConstants *psTabWidthStyle);
        
        /* [helpcontext][helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_TabWidthStyle )( 
            ITabStrip * This,
            /* [in] */ TabWidthStyleConstants psTabWidthStyle);
        
        /* [helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_ClientTop )( 
            ITabStrip * This,
            /* [retval][out] */ single *pfClientTop);
        
        /* [helpcontext][helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_ClientTop )( 
            ITabStrip * This,
            /* [in] */ single pfClientTop);
        
        /* [helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_ClientLeft )( 
            ITabStrip * This,
            /* [retval][out] */ single *pfClientLeft);
        
        /* [helpcontext][helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_ClientLeft )( 
            ITabStrip * This,
            /* [in] */ single pfClientLeft);
        
        /* [helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_ClientHeight )( 
            ITabStrip * This,
            /* [retval][out] */ single *pfClientHeight);
        
        /* [helpcontext][helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_ClientHeight )( 
            ITabStrip * This,
            /* [in] */ single pfClientHeight);
        
        /* [helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_ClientWidth )( 
            ITabStrip * This,
            /* [retval][out] */ single *pfClientWidth);
        
        /* [helpcontext][helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_ClientWidth )( 
            ITabStrip * This,
            /* [in] */ single pfClientWidth);
        
        /* [helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_MousePointer )( 
            ITabStrip * This,
            /* [retval][out] */ MousePointerConstants *psMousePointer);
        
        /* [helpcontext][helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_MousePointer )( 
            ITabStrip * This,
            /* [in] */ MousePointerConstants psMousePointer);
        
        /* [helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_ImageList )( 
            ITabStrip * This,
            /* [retval][out] */ IDispatch **ppImageList);
        
        /* [helpcontext][helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_ImageList )( 
            ITabStrip * This,
            /* [in] */ IDispatch *ppImageList);
        
        /* [helpcontext][helpstring][propputref][id] */ HRESULT ( STDMETHODCALLTYPE *putref_ImageList )( 
            ITabStrip * This,
            /* [in] */ IDispatch *ppImageList);
        
        /* [helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_TabFixedHeight )( 
            ITabStrip * This,
            /* [retval][out] */ short *psTabFixedHeight);
        
        /* [helpcontext][helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_TabFixedHeight )( 
            ITabStrip * This,
            /* [in] */ short psTabFixedHeight);
        
        /* [helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_ShowTips )( 
            ITabStrip * This,
            /* [retval][out] */ VARIANT_BOOL *pbShowTips);
        
        /* [helpcontext][helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_ShowTips )( 
            ITabStrip * This,
            /* [in] */ VARIANT_BOOL pbShowTips);
        
        /* [helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_SelectedItem )( 
            ITabStrip * This,
            /* [retval][out] */ ITab **ppSelectedItem);
        
        /* [helpcontext][helpstring][propputref][id] */ HRESULT ( STDMETHODCALLTYPE *putref_SelectedItem )( 
            ITabStrip * This,
            /* [in] */ ITab *ppSelectedItem);
        
        /* [helpcontext][helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_SelectedItem )( 
            ITabStrip * This,
            /* [in] */ VARIANT *ppSelectedItem);
        
        /* [helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_OLEDropMode )( 
            ITabStrip * This,
            /* [retval][out] */ OLEDropConstants *psOLEDropMode);
        
        /* [helpcontext][helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_OLEDropMode )( 
            ITabStrip * This,
            /* [in] */ OLEDropConstants psOLEDropMode);
        
        /* [helpcontext][helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Refresh )( 
            ITabStrip * This);
        
        /* [helpcontext][helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *OLEDrag )( 
            ITabStrip * This);
        
        /* [hidden][id] */ HRESULT ( STDMETHODCALLTYPE *AboutBox )( 
            ITabStrip * This);
        
        /* [helpcontext][helpstring][requestedit][bindable][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_HotTracking )( 
            ITabStrip * This,
            /* [retval][out] */ VARIANT_BOOL *pbHotTracking);
        
        /* [helpcontext][helpstring][requestedit][bindable][propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_HotTracking )( 
            ITabStrip * This,
            /* [in] */ VARIANT_BOOL pbHotTracking);
        
        /* [helpcontext][helpstring][requestedit][bindable][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_MultiSelect )( 
            ITabStrip * This,
            /* [retval][out] */ VARIANT_BOOL *pbMultiSelect);
        
        /* [helpcontext][helpstring][requestedit][bindable][propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_MultiSelect )( 
            ITabStrip * This,
            /* [in] */ VARIANT_BOOL pbMultiSelect);
        
        /* [helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_Placement )( 
            ITabStrip * This,
            /* [retval][out] */ PlacementConstants *penumPlacement);
        
        /* [helpcontext][helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_Placement )( 
            ITabStrip * This,
            /* [in] */ PlacementConstants penumPlacement);
        
        /* [helpcontext][helpstring][requestedit][bindable][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_Separators )( 
            ITabStrip * This,
            /* [retval][out] */ VARIANT_BOOL *pbSeparators);
        
        /* [helpcontext][helpstring][requestedit][bindable][propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_Separators )( 
            ITabStrip * This,
            /* [in] */ VARIANT_BOOL pbSeparators);
        
        /* [helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_TabMinWidth )( 
            ITabStrip * This,
            /* [retval][out] */ single *pflTabMinWidth);
        
        /* [helpcontext][helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_TabMinWidth )( 
            ITabStrip * This,
            /* [in] */ single pflTabMinWidth);
        
        /* [helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_TabStyle )( 
            ITabStrip * This,
            /* [retval][out] */ TabSelStyleConstants *penumTabStyle);
        
        /* [helpcontext][helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_TabStyle )( 
            ITabStrip * This,
            /* [in] */ TabSelStyleConstants penumTabStyle);
        
        /* [helpcontext][helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *DeselectAll )( 
            ITabStrip * This);
        
        END_INTERFACE
    } ITabStripVtbl;

    interface ITabStrip
    {
        CONST_VTBL struct ITabStripVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITabStrip_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ITabStrip_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ITabStrip_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ITabStrip_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define ITabStrip_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define ITabStrip_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define ITabStrip_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define ITabStrip_get_Tabs(This,ppTabs)	\
    (This)->lpVtbl -> get_Tabs(This,ppTabs)

#define ITabStrip_putref_Tabs(This,ppTabs)	\
    (This)->lpVtbl -> putref_Tabs(This,ppTabs)

#define ITabStrip_get_Enabled(This,pbEnabled)	\
    (This)->lpVtbl -> get_Enabled(This,pbEnabled)

#define ITabStrip_put_Enabled(This,pbEnabled)	\
    (This)->lpVtbl -> put_Enabled(This,pbEnabled)

#define ITabStrip_get_Font(This,ppFontDisp)	\
    (This)->lpVtbl -> get_Font(This,ppFontDisp)

#define ITabStrip_putref_Font(This,ppFontDisp)	\
    (This)->lpVtbl -> putref_Font(This,ppFontDisp)

#define ITabStrip_get_hWnd(This,phWnd)	\
    (This)->lpVtbl -> get_hWnd(This,phWnd)

#define ITabStrip_put_hWnd(This,phWnd)	\
    (This)->lpVtbl -> put_hWnd(This,phWnd)

#define ITabStrip_get_MouseIcon(This,ppMouseIcon)	\
    (This)->lpVtbl -> get_MouseIcon(This,ppMouseIcon)

#define ITabStrip_put_MouseIcon(This,ppMouseIcon)	\
    (This)->lpVtbl -> put_MouseIcon(This,ppMouseIcon)

#define ITabStrip_putref_MouseIcon(This,ppMouseIcon)	\
    (This)->lpVtbl -> putref_MouseIcon(This,ppMouseIcon)

#define ITabStrip_get_MultiRow(This,pbMultiRow)	\
    (This)->lpVtbl -> get_MultiRow(This,pbMultiRow)

#define ITabStrip_put_MultiRow(This,pbMultiRow)	\
    (This)->lpVtbl -> put_MultiRow(This,pbMultiRow)

#define ITabStrip_get_Style(This,psStyle)	\
    (This)->lpVtbl -> get_Style(This,psStyle)

#define ITabStrip_put_Style(This,psStyle)	\
    (This)->lpVtbl -> put_Style(This,psStyle)

#define ITabStrip_get_TabFixedWidth(This,psTabFixedWidth)	\
    (This)->lpVtbl -> get_TabFixedWidth(This,psTabFixedWidth)

#define ITabStrip_put_TabFixedWidth(This,psTabFixedWidth)	\
    (This)->lpVtbl -> put_TabFixedWidth(This,psTabFixedWidth)

#define ITabStrip_get_TabWidthStyle(This,psTabWidthStyle)	\
    (This)->lpVtbl -> get_TabWidthStyle(This,psTabWidthStyle)

#define ITabStrip_put_TabWidthStyle(This,psTabWidthStyle)	\
    (This)->lpVtbl -> put_TabWidthStyle(This,psTabWidthStyle)

#define ITabStrip_get_ClientTop(This,pfClientTop)	\
    (This)->lpVtbl -> get_ClientTop(This,pfClientTop)

#define ITabStrip_put_ClientTop(This,pfClientTop)	\
    (This)->lpVtbl -> put_ClientTop(This,pfClientTop)

#define ITabStrip_get_ClientLeft(This,pfClientLeft)	\
    (This)->lpVtbl -> get_ClientLeft(This,pfClientLeft)

#define ITabStrip_put_ClientLeft(This,pfClientLeft)	\
    (This)->lpVtbl -> put_ClientLeft(This,pfClientLeft)

#define ITabStrip_get_ClientHeight(This,pfClientHeight)	\
    (This)->lpVtbl -> get_ClientHeight(This,pfClientHeight)

#define ITabStrip_put_ClientHeight(This,pfClientHeight)	\
    (This)->lpVtbl -> put_ClientHeight(This,pfClientHeight)

#define ITabStrip_get_ClientWidth(This,pfClientWidth)	\
    (This)->lpVtbl -> get_ClientWidth(This,pfClientWidth)

#define ITabStrip_put_ClientWidth(This,pfClientWidth)	\
    (This)->lpVtbl -> put_ClientWidth(This,pfClientWidth)

#define ITabStrip_get_MousePointer(This,psMousePointer)	\
    (This)->lpVtbl -> get_MousePointer(This,psMousePointer)

#define ITabStrip_put_MousePointer(This,psMousePointer)	\
    (This)->lpVtbl -> put_MousePointer(This,psMousePointer)

#define ITabStrip_get_ImageList(This,ppImageList)	\
    (This)->lpVtbl -> get_ImageList(This,ppImageList)

#define ITabStrip_put_ImageList(This,ppImageList)	\
    (This)->lpVtbl -> put_ImageList(This,ppImageList)

#define ITabStrip_putref_ImageList(This,ppImageList)	\
    (This)->lpVtbl -> putref_ImageList(This,ppImageList)

#define ITabStrip_get_TabFixedHeight(This,psTabFixedHeight)	\
    (This)->lpVtbl -> get_TabFixedHeight(This,psTabFixedHeight)

#define ITabStrip_put_TabFixedHeight(This,psTabFixedHeight)	\
    (This)->lpVtbl -> put_TabFixedHeight(This,psTabFixedHeight)

#define ITabStrip_get_ShowTips(This,pbShowTips)	\
    (This)->lpVtbl -> get_ShowTips(This,pbShowTips)

#define ITabStrip_put_ShowTips(This,pbShowTips)	\
    (This)->lpVtbl -> put_ShowTips(This,pbShowTips)

#define ITabStrip_get_SelectedItem(This,ppSelectedItem)	\
    (This)->lpVtbl -> get_SelectedItem(This,ppSelectedItem)

#define ITabStrip_putref_SelectedItem(This,ppSelectedItem)	\
    (This)->lpVtbl -> putref_SelectedItem(This,ppSelectedItem)

#define ITabStrip_put_SelectedItem(This,ppSelectedItem)	\
    (This)->lpVtbl -> put_SelectedItem(This,ppSelectedItem)

#define ITabStrip_get_OLEDropMode(This,psOLEDropMode)	\
    (This)->lpVtbl -> get_OLEDropMode(This,psOLEDropMode)

#define ITabStrip_put_OLEDropMode(This,psOLEDropMode)	\
    (This)->lpVtbl -> put_OLEDropMode(This,psOLEDropMode)

#define ITabStrip_Refresh(This)	\
    (This)->lpVtbl -> Refresh(This)

#define ITabStrip_OLEDrag(This)	\
    (This)->lpVtbl -> OLEDrag(This)

#define ITabStrip_AboutBox(This)	\
    (This)->lpVtbl -> AboutBox(This)

#define ITabStrip_get_HotTracking(This,pbHotTracking)	\
    (This)->lpVtbl -> get_HotTracking(This,pbHotTracking)

#define ITabStrip_put_HotTracking(This,pbHotTracking)	\
    (This)->lpVtbl -> put_HotTracking(This,pbHotTracking)

#define ITabStrip_get_MultiSelect(This,pbMultiSelect)	\
    (This)->lpVtbl -> get_MultiSelect(This,pbMultiSelect)

#define ITabStrip_put_MultiSelect(This,pbMultiSelect)	\
    (This)->lpVtbl -> put_MultiSelect(This,pbMultiSelect)

#define ITabStrip_get_Placement(This,penumPlacement)	\
    (This)->lpVtbl -> get_Placement(This,penumPlacement)

#define ITabStrip_put_Placement(This,penumPlacement)	\
    (This)->lpVtbl -> put_Placement(This,penumPlacement)

#define ITabStrip_get_Separators(This,pbSeparators)	\
    (This)->lpVtbl -> get_Separators(This,pbSeparators)

#define ITabStrip_put_Separators(This,pbSeparators)	\
    (This)->lpVtbl -> put_Separators(This,pbSeparators)

#define ITabStrip_get_TabMinWidth(This,pflTabMinWidth)	\
    (This)->lpVtbl -> get_TabMinWidth(This,pflTabMinWidth)

#define ITabStrip_put_TabMinWidth(This,pflTabMinWidth)	\
    (This)->lpVtbl -> put_TabMinWidth(This,pflTabMinWidth)

#define ITabStrip_get_TabStyle(This,penumTabStyle)	\
    (This)->lpVtbl -> get_TabStyle(This,penumTabStyle)

#define ITabStrip_put_TabStyle(This,penumTabStyle)	\
    (This)->lpVtbl -> put_TabStyle(This,penumTabStyle)

#define ITabStrip_DeselectAll(This)	\
    (This)->lpVtbl -> DeselectAll(This)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE ITabStrip_get_Tabs_Proxy( 
    ITabStrip * This,
    /* [retval][out] */ ITabs **ppTabs);


void __RPC_STUB ITabStrip_get_Tabs_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propputref][id] */ HRESULT STDMETHODCALLTYPE ITabStrip_putref_Tabs_Proxy( 
    ITabStrip * This,
    /* [in] */ ITabs *ppTabs);


void __RPC_STUB ITabStrip_putref_Tabs_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][requestedit][bindable][propget][id] */ HRESULT STDMETHODCALLTYPE ITabStrip_get_Enabled_Proxy( 
    ITabStrip * This,
    /* [retval][out] */ VARIANT_BOOL *pbEnabled);


void __RPC_STUB ITabStrip_get_Enabled_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][requestedit][bindable][propput][id] */ HRESULT STDMETHODCALLTYPE ITabStrip_put_Enabled_Proxy( 
    ITabStrip * This,
    /* [in] */ VARIANT_BOOL pbEnabled);


void __RPC_STUB ITabStrip_put_Enabled_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][bindable][propget][id] */ HRESULT STDMETHODCALLTYPE ITabStrip_get_Font_Proxy( 
    ITabStrip * This,
    /* [retval][out] */ /* external definition not present */ IFontDisp **ppFontDisp);


void __RPC_STUB ITabStrip_get_Font_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][bindable][propputref][id] */ HRESULT STDMETHODCALLTYPE ITabStrip_putref_Font_Proxy( 
    ITabStrip * This,
    /* [in] */ /* external definition not present */ IFontDisp *ppFontDisp);


void __RPC_STUB ITabStrip_putref_Font_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE ITabStrip_get_hWnd_Proxy( 
    ITabStrip * This,
    /* [retval][out] */ /* external definition not present */ OLE_HANDLE *phWnd);


void __RPC_STUB ITabStrip_get_hWnd_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE ITabStrip_put_hWnd_Proxy( 
    ITabStrip * This,
    /* [in] */ /* external definition not present */ OLE_HANDLE phWnd);


void __RPC_STUB ITabStrip_put_hWnd_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE ITabStrip_get_MouseIcon_Proxy( 
    ITabStrip * This,
    /* [retval][out] */ /* external definition not present */ IPictureDisp **ppMouseIcon);


void __RPC_STUB ITabStrip_get_MouseIcon_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE ITabStrip_put_MouseIcon_Proxy( 
    ITabStrip * This,
    /* [in] */ /* external definition not present */ IPictureDisp *ppMouseIcon);


void __RPC_STUB ITabStrip_put_MouseIcon_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propputref][id] */ HRESULT STDMETHODCALLTYPE ITabStrip_putref_MouseIcon_Proxy( 
    ITabStrip * This,
    /* [in] */ /* external definition not present */ IPictureDisp *ppMouseIcon);


void __RPC_STUB ITabStrip_putref_MouseIcon_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE ITabStrip_get_MultiRow_Proxy( 
    ITabStrip * This,
    /* [retval][out] */ VARIANT_BOOL *pbMultiRow);


void __RPC_STUB ITabStrip_get_MultiRow_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE ITabStrip_put_MultiRow_Proxy( 
    ITabStrip * This,
    /* [in] */ VARIANT_BOOL pbMultiRow);


void __RPC_STUB ITabStrip_put_MultiRow_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE ITabStrip_get_Style_Proxy( 
    ITabStrip * This,
    /* [retval][out] */ TabStyleConstants *psStyle);


void __RPC_STUB ITabStrip_get_Style_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE ITabStrip_put_Style_Proxy( 
    ITabStrip * This,
    /* [in] */ TabStyleConstants psStyle);


void __RPC_STUB ITabStrip_put_Style_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE ITabStrip_get_TabFixedWidth_Proxy( 
    ITabStrip * This,
    /* [retval][out] */ short *psTabFixedWidth);


void __RPC_STUB ITabStrip_get_TabFixedWidth_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE ITabStrip_put_TabFixedWidth_Proxy( 
    ITabStrip * This,
    /* [in] */ short psTabFixedWidth);


void __RPC_STUB ITabStrip_put_TabFixedWidth_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE ITabStrip_get_TabWidthStyle_Proxy( 
    ITabStrip * This,
    /* [retval][out] */ TabWidthStyleConstants *psTabWidthStyle);


void __RPC_STUB ITabStrip_get_TabWidthStyle_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE ITabStrip_put_TabWidthStyle_Proxy( 
    ITabStrip * This,
    /* [in] */ TabWidthStyleConstants psTabWidthStyle);


void __RPC_STUB ITabStrip_put_TabWidthStyle_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE ITabStrip_get_ClientTop_Proxy( 
    ITabStrip * This,
    /* [retval][out] */ single *pfClientTop);


void __RPC_STUB ITabStrip_get_ClientTop_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE ITabStrip_put_ClientTop_Proxy( 
    ITabStrip * This,
    /* [in] */ single pfClientTop);


void __RPC_STUB ITabStrip_put_ClientTop_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE ITabStrip_get_ClientLeft_Proxy( 
    ITabStrip * This,
    /* [retval][out] */ single *pfClientLeft);


void __RPC_STUB ITabStrip_get_ClientLeft_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE ITabStrip_put_ClientLeft_Proxy( 
    ITabStrip * This,
    /* [in] */ single pfClientLeft);


void __RPC_STUB ITabStrip_put_ClientLeft_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE ITabStrip_get_ClientHeight_Proxy( 
    ITabStrip * This,
    /* [retval][out] */ single *pfClientHeight);


void __RPC_STUB ITabStrip_get_ClientHeight_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE ITabStrip_put_ClientHeight_Proxy( 
    ITabStrip * This,
    /* [in] */ single pfClientHeight);


void __RPC_STUB ITabStrip_put_ClientHeight_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE ITabStrip_get_ClientWidth_Proxy( 
    ITabStrip * This,
    /* [retval][out] */ single *pfClientWidth);


void __RPC_STUB ITabStrip_get_ClientWidth_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE ITabStrip_put_ClientWidth_Proxy( 
    ITabStrip * This,
    /* [in] */ single pfClientWidth);


void __RPC_STUB ITabStrip_put_ClientWidth_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE ITabStrip_get_MousePointer_Proxy( 
    ITabStrip * This,
    /* [retval][out] */ MousePointerConstants *psMousePointer);


void __RPC_STUB ITabStrip_get_MousePointer_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE ITabStrip_put_MousePointer_Proxy( 
    ITabStrip * This,
    /* [in] */ MousePointerConstants psMousePointer);


void __RPC_STUB ITabStrip_put_MousePointer_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE ITabStrip_get_ImageList_Proxy( 
    ITabStrip * This,
    /* [retval][out] */ IDispatch **ppImageList);


void __RPC_STUB ITabStrip_get_ImageList_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE ITabStrip_put_ImageList_Proxy( 
    ITabStrip * This,
    /* [in] */ IDispatch *ppImageList);


void __RPC_STUB ITabStrip_put_ImageList_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propputref][id] */ HRESULT STDMETHODCALLTYPE ITabStrip_putref_ImageList_Proxy( 
    ITabStrip * This,
    /* [in] */ IDispatch *ppImageList);


void __RPC_STUB ITabStrip_putref_ImageList_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE ITabStrip_get_TabFixedHeight_Proxy( 
    ITabStrip * This,
    /* [retval][out] */ short *psTabFixedHeight);


void __RPC_STUB ITabStrip_get_TabFixedHeight_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE ITabStrip_put_TabFixedHeight_Proxy( 
    ITabStrip * This,
    /* [in] */ short psTabFixedHeight);


void __RPC_STUB ITabStrip_put_TabFixedHeight_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE ITabStrip_get_ShowTips_Proxy( 
    ITabStrip * This,
    /* [retval][out] */ VARIANT_BOOL *pbShowTips);


void __RPC_STUB ITabStrip_get_ShowTips_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE ITabStrip_put_ShowTips_Proxy( 
    ITabStrip * This,
    /* [in] */ VARIANT_BOOL pbShowTips);


void __RPC_STUB ITabStrip_put_ShowTips_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE ITabStrip_get_SelectedItem_Proxy( 
    ITabStrip * This,
    /* [retval][out] */ ITab **ppSelectedItem);


void __RPC_STUB ITabStrip_get_SelectedItem_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propputref][id] */ HRESULT STDMETHODCALLTYPE ITabStrip_putref_SelectedItem_Proxy( 
    ITabStrip * This,
    /* [in] */ ITab *ppSelectedItem);


void __RPC_STUB ITabStrip_putref_SelectedItem_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE ITabStrip_put_SelectedItem_Proxy( 
    ITabStrip * This,
    /* [in] */ VARIANT *ppSelectedItem);


void __RPC_STUB ITabStrip_put_SelectedItem_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE ITabStrip_get_OLEDropMode_Proxy( 
    ITabStrip * This,
    /* [retval][out] */ OLEDropConstants *psOLEDropMode);


void __RPC_STUB ITabStrip_get_OLEDropMode_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE ITabStrip_put_OLEDropMode_Proxy( 
    ITabStrip * This,
    /* [in] */ OLEDropConstants psOLEDropMode);


void __RPC_STUB ITabStrip_put_OLEDropMode_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][id] */ HRESULT STDMETHODCALLTYPE ITabStrip_Refresh_Proxy( 
    ITabStrip * This);


void __RPC_STUB ITabStrip_Refresh_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][id] */ HRESULT STDMETHODCALLTYPE ITabStrip_OLEDrag_Proxy( 
    ITabStrip * This);


void __RPC_STUB ITabStrip_OLEDrag_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [hidden][id] */ HRESULT STDMETHODCALLTYPE ITabStrip_AboutBox_Proxy( 
    ITabStrip * This);


void __RPC_STUB ITabStrip_AboutBox_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][requestedit][bindable][propget][id] */ HRESULT STDMETHODCALLTYPE ITabStrip_get_HotTracking_Proxy( 
    ITabStrip * This,
    /* [retval][out] */ VARIANT_BOOL *pbHotTracking);


void __RPC_STUB ITabStrip_get_HotTracking_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][requestedit][bindable][propput][id] */ HRESULT STDMETHODCALLTYPE ITabStrip_put_HotTracking_Proxy( 
    ITabStrip * This,
    /* [in] */ VARIANT_BOOL pbHotTracking);


void __RPC_STUB ITabStrip_put_HotTracking_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][requestedit][bindable][propget][id] */ HRESULT STDMETHODCALLTYPE ITabStrip_get_MultiSelect_Proxy( 
    ITabStrip * This,
    /* [retval][out] */ VARIANT_BOOL *pbMultiSelect);


void __RPC_STUB ITabStrip_get_MultiSelect_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][requestedit][bindable][propput][id] */ HRESULT STDMETHODCALLTYPE ITabStrip_put_MultiSelect_Proxy( 
    ITabStrip * This,
    /* [in] */ VARIANT_BOOL pbMultiSelect);


void __RPC_STUB ITabStrip_put_MultiSelect_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE ITabStrip_get_Placement_Proxy( 
    ITabStrip * This,
    /* [retval][out] */ PlacementConstants *penumPlacement);


void __RPC_STUB ITabStrip_get_Placement_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE ITabStrip_put_Placement_Proxy( 
    ITabStrip * This,
    /* [in] */ PlacementConstants penumPlacement);


void __RPC_STUB ITabStrip_put_Placement_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][requestedit][bindable][propget][id] */ HRESULT STDMETHODCALLTYPE ITabStrip_get_Separators_Proxy( 
    ITabStrip * This,
    /* [retval][out] */ VARIANT_BOOL *pbSeparators);


void __RPC_STUB ITabStrip_get_Separators_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][requestedit][bindable][propput][id] */ HRESULT STDMETHODCALLTYPE ITabStrip_put_Separators_Proxy( 
    ITabStrip * This,
    /* [in] */ VARIANT_BOOL pbSeparators);


void __RPC_STUB ITabStrip_put_Separators_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE ITabStrip_get_TabMinWidth_Proxy( 
    ITabStrip * This,
    /* [retval][out] */ single *pflTabMinWidth);


void __RPC_STUB ITabStrip_get_TabMinWidth_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE ITabStrip_put_TabMinWidth_Proxy( 
    ITabStrip * This,
    /* [in] */ single pflTabMinWidth);


void __RPC_STUB ITabStrip_put_TabMinWidth_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE ITabStrip_get_TabStyle_Proxy( 
    ITabStrip * This,
    /* [retval][out] */ TabSelStyleConstants *penumTabStyle);


void __RPC_STUB ITabStrip_get_TabStyle_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE ITabStrip_put_TabStyle_Proxy( 
    ITabStrip * This,
    /* [in] */ TabSelStyleConstants penumTabStyle);


void __RPC_STUB ITabStrip_put_TabStyle_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][id] */ HRESULT STDMETHODCALLTYPE ITabStrip_DeselectAll_Proxy( 
    ITabStrip * This);


void __RPC_STUB ITabStrip_DeselectAll_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ITabStrip_INTERFACE_DEFINED__ */


#ifndef __ITabStripEvents_DISPINTERFACE_DEFINED__
#define __ITabStripEvents_DISPINTERFACE_DEFINED__

/* dispinterface ITabStripEvents */
/* [nonextensible][uuid] */ 


EXTERN_C const IID DIID_ITabStripEvents;

#if defined(__cplusplus) && !defined(CINTERFACE)

    MIDL_INTERFACE("1EFB6595-857C-11D1-B16A-00C0F0283628")
    ITabStripEvents : public IDispatch
    {
    };
    
#else 	/* C style interface */

    typedef struct ITabStripEventsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ITabStripEvents * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ITabStripEvents * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ITabStripEvents * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            ITabStripEvents * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            ITabStripEvents * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            ITabStripEvents * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            ITabStripEvents * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        END_INTERFACE
    } ITabStripEventsVtbl;

    interface ITabStripEvents
    {
        CONST_VTBL struct ITabStripEventsVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITabStripEvents_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ITabStripEvents_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ITabStripEvents_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ITabStripEvents_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define ITabStripEvents_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define ITabStripEvents_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define ITabStripEvents_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)

#endif /* COBJMACROS */


#endif 	/* C style interface */


#endif 	/* __ITabStripEvents_DISPINTERFACE_DEFINED__ */


#ifndef __ITabs_INTERFACE_DEFINED__
#define __ITabs_INTERFACE_DEFINED__

/* interface ITabs */
/* [object][oleautomation][nonextensible][dual][hidden][helpcontext][helpstring][uuid] */ 


EXTERN_C const IID IID_ITabs;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("1EFB6597-857C-11D1-B16A-00C0F0283628")
    ITabs : public IDispatch
    {
    public:
        virtual /* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_Count( 
            /* [retval][out] */ short *psCount) = 0;
        
        virtual /* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_Count( 
            /* [in] */ short psCount) = 0;
        
        virtual /* [hidden][propget][id] */ HRESULT STDMETHODCALLTYPE get_ControlDefault( 
            /* [in] */ VARIANT *pvIndex,
            /* [retval][out] */ ITab **ppTab) = 0;
        
        virtual /* [hidden][propputref][id] */ HRESULT STDMETHODCALLTYPE putref_ControlDefault( 
            /* [in] */ VARIANT *pvIndex,
            /* [in] */ ITab *ppTab) = 0;
        
        virtual /* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_Item( 
            /* [in] */ VARIANT *pvIndex,
            /* [retval][out] */ ITab **ppTab) = 0;
        
        virtual /* [helpcontext][helpstring][propputref][id] */ HRESULT STDMETHODCALLTYPE putref_Item( 
            /* [in] */ VARIANT *pvIndex,
            /* [in] */ ITab *ppTab) = 0;
        
        virtual /* [helpcontext][helpstring][id] */ HRESULT STDMETHODCALLTYPE Remove( 
            /* [in] */ VARIANT *pvIndex) = 0;
        
        virtual /* [helpcontext][helpstring][id] */ HRESULT STDMETHODCALLTYPE Clear( void) = 0;
        
        virtual /* [helpcontext][helpstring][id] */ HRESULT STDMETHODCALLTYPE Add( 
            /* [optional][in] */ VARIANT *pvIndex,
            /* [optional][in] */ VARIANT *pvKey,
            /* [optional][in] */ VARIANT *pvCaption,
            /* [optional][in] */ VARIANT *pvImage,
            /* [retval][out] */ ITab **ppTab) = 0;
        
        virtual /* [hidden][id] */ HRESULT STDMETHODCALLTYPE _NewEnum( 
            /* [retval][out] */ IDispatch **ppNewEnum) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITabsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ITabs * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ITabs * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ITabs * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            ITabs * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            ITabs * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            ITabs * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            ITabs * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_Count )( 
            ITabs * This,
            /* [retval][out] */ short *psCount);
        
        /* [helpcontext][helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_Count )( 
            ITabs * This,
            /* [in] */ short psCount);
        
        /* [hidden][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_ControlDefault )( 
            ITabs * This,
            /* [in] */ VARIANT *pvIndex,
            /* [retval][out] */ ITab **ppTab);
        
        /* [hidden][propputref][id] */ HRESULT ( STDMETHODCALLTYPE *putref_ControlDefault )( 
            ITabs * This,
            /* [in] */ VARIANT *pvIndex,
            /* [in] */ ITab *ppTab);
        
        /* [helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_Item )( 
            ITabs * This,
            /* [in] */ VARIANT *pvIndex,
            /* [retval][out] */ ITab **ppTab);
        
        /* [helpcontext][helpstring][propputref][id] */ HRESULT ( STDMETHODCALLTYPE *putref_Item )( 
            ITabs * This,
            /* [in] */ VARIANT *pvIndex,
            /* [in] */ ITab *ppTab);
        
        /* [helpcontext][helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Remove )( 
            ITabs * This,
            /* [in] */ VARIANT *pvIndex);
        
        /* [helpcontext][helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Clear )( 
            ITabs * This);
        
        /* [helpcontext][helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Add )( 
            ITabs * This,
            /* [optional][in] */ VARIANT *pvIndex,
            /* [optional][in] */ VARIANT *pvKey,
            /* [optional][in] */ VARIANT *pvCaption,
            /* [optional][in] */ VARIANT *pvImage,
            /* [retval][out] */ ITab **ppTab);
        
        /* [hidden][id] */ HRESULT ( STDMETHODCALLTYPE *_NewEnum )( 
            ITabs * This,
            /* [retval][out] */ IDispatch **ppNewEnum);
        
        END_INTERFACE
    } ITabsVtbl;

    interface ITabs
    {
        CONST_VTBL struct ITabsVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITabs_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ITabs_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ITabs_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ITabs_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define ITabs_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define ITabs_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define ITabs_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define ITabs_get_Count(This,psCount)	\
    (This)->lpVtbl -> get_Count(This,psCount)

#define ITabs_put_Count(This,psCount)	\
    (This)->lpVtbl -> put_Count(This,psCount)

#define ITabs_get_ControlDefault(This,pvIndex,ppTab)	\
    (This)->lpVtbl -> get_ControlDefault(This,pvIndex,ppTab)

#define ITabs_putref_ControlDefault(This,pvIndex,ppTab)	\
    (This)->lpVtbl -> putref_ControlDefault(This,pvIndex,ppTab)

#define ITabs_get_Item(This,pvIndex,ppTab)	\
    (This)->lpVtbl -> get_Item(This,pvIndex,ppTab)

#define ITabs_putref_Item(This,pvIndex,ppTab)	\
    (This)->lpVtbl -> putref_Item(This,pvIndex,ppTab)

#define ITabs_Remove(This,pvIndex)	\
    (This)->lpVtbl -> Remove(This,pvIndex)

#define ITabs_Clear(This)	\
    (This)->lpVtbl -> Clear(This)

#define ITabs_Add(This,pvIndex,pvKey,pvCaption,pvImage,ppTab)	\
    (This)->lpVtbl -> Add(This,pvIndex,pvKey,pvCaption,pvImage,ppTab)

#define ITabs__NewEnum(This,ppNewEnum)	\
    (This)->lpVtbl -> _NewEnum(This,ppNewEnum)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE ITabs_get_Count_Proxy( 
    ITabs * This,
    /* [retval][out] */ short *psCount);


void __RPC_STUB ITabs_get_Count_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE ITabs_put_Count_Proxy( 
    ITabs * This,
    /* [in] */ short psCount);


void __RPC_STUB ITabs_put_Count_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [hidden][propget][id] */ HRESULT STDMETHODCALLTYPE ITabs_get_ControlDefault_Proxy( 
    ITabs * This,
    /* [in] */ VARIANT *pvIndex,
    /* [retval][out] */ ITab **ppTab);


void __RPC_STUB ITabs_get_ControlDefault_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [hidden][propputref][id] */ HRESULT STDMETHODCALLTYPE ITabs_putref_ControlDefault_Proxy( 
    ITabs * This,
    /* [in] */ VARIANT *pvIndex,
    /* [in] */ ITab *ppTab);


void __RPC_STUB ITabs_putref_ControlDefault_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE ITabs_get_Item_Proxy( 
    ITabs * This,
    /* [in] */ VARIANT *pvIndex,
    /* [retval][out] */ ITab **ppTab);


void __RPC_STUB ITabs_get_Item_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propputref][id] */ HRESULT STDMETHODCALLTYPE ITabs_putref_Item_Proxy( 
    ITabs * This,
    /* [in] */ VARIANT *pvIndex,
    /* [in] */ ITab *ppTab);


void __RPC_STUB ITabs_putref_Item_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][id] */ HRESULT STDMETHODCALLTYPE ITabs_Remove_Proxy( 
    ITabs * This,
    /* [in] */ VARIANT *pvIndex);


void __RPC_STUB ITabs_Remove_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][id] */ HRESULT STDMETHODCALLTYPE ITabs_Clear_Proxy( 
    ITabs * This);


void __RPC_STUB ITabs_Clear_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][id] */ HRESULT STDMETHODCALLTYPE ITabs_Add_Proxy( 
    ITabs * This,
    /* [optional][in] */ VARIANT *pvIndex,
    /* [optional][in] */ VARIANT *pvKey,
    /* [optional][in] */ VARIANT *pvCaption,
    /* [optional][in] */ VARIANT *pvImage,
    /* [retval][out] */ ITab **ppTab);


void __RPC_STUB ITabs_Add_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [hidden][id] */ HRESULT STDMETHODCALLTYPE ITabs__NewEnum_Proxy( 
    ITabs * This,
    /* [retval][out] */ IDispatch **ppNewEnum);


void __RPC_STUB ITabs__NewEnum_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ITabs_INTERFACE_DEFINED__ */


#ifndef __ITab_INTERFACE_DEFINED__
#define __ITab_INTERFACE_DEFINED__

/* interface ITab */
/* [object][oleautomation][nonextensible][dual][helpcontext][helpstring][uuid] */ 


EXTERN_C const IID IID_ITab;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("1EFB6599-857C-11D1-B16A-00C0F0283628")
    ITab : public IDispatch
    {
    public:
        virtual /* [hidden][propget][id] */ HRESULT STDMETHODCALLTYPE get__ObjectDefault( 
            /* [retval][out] */ BSTR *pbstrCaption) = 0;
        
        virtual /* [hidden][propput][id] */ HRESULT STDMETHODCALLTYPE put__ObjectDefault( 
            /* [in] */ BSTR pbstrCaption) = 0;
        
        virtual /* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_Caption( 
            /* [retval][out] */ BSTR *pbstrCaption) = 0;
        
        virtual /* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_Caption( 
            /* [in] */ BSTR pbstrCaption) = 0;
        
        virtual /* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_Tag( 
            /* [retval][out] */ VARIANT *pvTag) = 0;
        
        virtual /* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_Tag( 
            /* [in] */ VARIANT pvTag) = 0;
        
        virtual /* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_Index( 
            /* [retval][out] */ short *psIndex) = 0;
        
        virtual /* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_Index( 
            /* [in] */ short psIndex) = 0;
        
        virtual /* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_Key( 
            /* [retval][out] */ BSTR *pbstrKey) = 0;
        
        virtual /* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_Key( 
            /* [in] */ BSTR pbstrKey) = 0;
        
        virtual /* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_ToolTipText( 
            /* [retval][out] */ BSTR *pbstrToolTipText) = 0;
        
        virtual /* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_ToolTipText( 
            /* [in] */ BSTR pbstrToolTipText) = 0;
        
        virtual /* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_Width( 
            /* [retval][out] */ single *pfWidth) = 0;
        
        virtual /* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_Width( 
            /* [in] */ single pfWidth) = 0;
        
        virtual /* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_Height( 
            /* [retval][out] */ single *pfHeight) = 0;
        
        virtual /* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_Height( 
            /* [in] */ single pfHeight) = 0;
        
        virtual /* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_Top( 
            /* [retval][out] */ single *pfTop) = 0;
        
        virtual /* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_Top( 
            /* [in] */ single pfTop) = 0;
        
        virtual /* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_Left( 
            /* [retval][out] */ single *pfLeft) = 0;
        
        virtual /* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_Left( 
            /* [in] */ single pfLeft) = 0;
        
        virtual /* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_Selected( 
            /* [retval][out] */ VARIANT_BOOL *pbSelected) = 0;
        
        virtual /* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_Selected( 
            /* [in] */ VARIANT_BOOL pbSelected) = 0;
        
        virtual /* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_Image( 
            /* [retval][out] */ VARIANT *pvImage) = 0;
        
        virtual /* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_Image( 
            /* [in] */ VARIANT pvImage) = 0;
        
        virtual /* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_HighLighted( 
            /* [retval][out] */ VARIANT_BOOL *pbHighLighted) = 0;
        
        virtual /* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_HighLighted( 
            /* [in] */ VARIANT_BOOL pbHighLighted) = 0;
        
        virtual /* [helpcontext][helpstring][propputref][id] */ HRESULT STDMETHODCALLTYPE putref_Tag( 
            /* [in] */ VARIANT pvTag) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITabVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ITab * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ITab * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ITab * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            ITab * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            ITab * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            ITab * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            ITab * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [hidden][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get__ObjectDefault )( 
            ITab * This,
            /* [retval][out] */ BSTR *pbstrCaption);
        
        /* [hidden][propput][id] */ HRESULT ( STDMETHODCALLTYPE *put__ObjectDefault )( 
            ITab * This,
            /* [in] */ BSTR pbstrCaption);
        
        /* [helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_Caption )( 
            ITab * This,
            /* [retval][out] */ BSTR *pbstrCaption);
        
        /* [helpcontext][helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_Caption )( 
            ITab * This,
            /* [in] */ BSTR pbstrCaption);
        
        /* [helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_Tag )( 
            ITab * This,
            /* [retval][out] */ VARIANT *pvTag);
        
        /* [helpcontext][helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_Tag )( 
            ITab * This,
            /* [in] */ VARIANT pvTag);
        
        /* [helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_Index )( 
            ITab * This,
            /* [retval][out] */ short *psIndex);
        
        /* [helpcontext][helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_Index )( 
            ITab * This,
            /* [in] */ short psIndex);
        
        /* [helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_Key )( 
            ITab * This,
            /* [retval][out] */ BSTR *pbstrKey);
        
        /* [helpcontext][helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_Key )( 
            ITab * This,
            /* [in] */ BSTR pbstrKey);
        
        /* [helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_ToolTipText )( 
            ITab * This,
            /* [retval][out] */ BSTR *pbstrToolTipText);
        
        /* [helpcontext][helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_ToolTipText )( 
            ITab * This,
            /* [in] */ BSTR pbstrToolTipText);
        
        /* [helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_Width )( 
            ITab * This,
            /* [retval][out] */ single *pfWidth);
        
        /* [helpcontext][helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_Width )( 
            ITab * This,
            /* [in] */ single pfWidth);
        
        /* [helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_Height )( 
            ITab * This,
            /* [retval][out] */ single *pfHeight);
        
        /* [helpcontext][helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_Height )( 
            ITab * This,
            /* [in] */ single pfHeight);
        
        /* [helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_Top )( 
            ITab * This,
            /* [retval][out] */ single *pfTop);
        
        /* [helpcontext][helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_Top )( 
            ITab * This,
            /* [in] */ single pfTop);
        
        /* [helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_Left )( 
            ITab * This,
            /* [retval][out] */ single *pfLeft);
        
        /* [helpcontext][helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_Left )( 
            ITab * This,
            /* [in] */ single pfLeft);
        
        /* [helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_Selected )( 
            ITab * This,
            /* [retval][out] */ VARIANT_BOOL *pbSelected);
        
        /* [helpcontext][helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_Selected )( 
            ITab * This,
            /* [in] */ VARIANT_BOOL pbSelected);
        
        /* [helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_Image )( 
            ITab * This,
            /* [retval][out] */ VARIANT *pvImage);
        
        /* [helpcontext][helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_Image )( 
            ITab * This,
            /* [in] */ VARIANT pvImage);
        
        /* [helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_HighLighted )( 
            ITab * This,
            /* [retval][out] */ VARIANT_BOOL *pbHighLighted);
        
        /* [helpcontext][helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_HighLighted )( 
            ITab * This,
            /* [in] */ VARIANT_BOOL pbHighLighted);
        
        /* [helpcontext][helpstring][propputref][id] */ HRESULT ( STDMETHODCALLTYPE *putref_Tag )( 
            ITab * This,
            /* [in] */ VARIANT pvTag);
        
        END_INTERFACE
    } ITabVtbl;

    interface ITab
    {
        CONST_VTBL struct ITabVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITab_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ITab_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ITab_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ITab_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define ITab_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define ITab_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define ITab_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define ITab_get__ObjectDefault(This,pbstrCaption)	\
    (This)->lpVtbl -> get__ObjectDefault(This,pbstrCaption)

#define ITab_put__ObjectDefault(This,pbstrCaption)	\
    (This)->lpVtbl -> put__ObjectDefault(This,pbstrCaption)

#define ITab_get_Caption(This,pbstrCaption)	\
    (This)->lpVtbl -> get_Caption(This,pbstrCaption)

#define ITab_put_Caption(This,pbstrCaption)	\
    (This)->lpVtbl -> put_Caption(This,pbstrCaption)

#define ITab_get_Tag(This,pvTag)	\
    (This)->lpVtbl -> get_Tag(This,pvTag)

#define ITab_put_Tag(This,pvTag)	\
    (This)->lpVtbl -> put_Tag(This,pvTag)

#define ITab_get_Index(This,psIndex)	\
    (This)->lpVtbl -> get_Index(This,psIndex)

#define ITab_put_Index(This,psIndex)	\
    (This)->lpVtbl -> put_Index(This,psIndex)

#define ITab_get_Key(This,pbstrKey)	\
    (This)->lpVtbl -> get_Key(This,pbstrKey)

#define ITab_put_Key(This,pbstrKey)	\
    (This)->lpVtbl -> put_Key(This,pbstrKey)

#define ITab_get_ToolTipText(This,pbstrToolTipText)	\
    (This)->lpVtbl -> get_ToolTipText(This,pbstrToolTipText)

#define ITab_put_ToolTipText(This,pbstrToolTipText)	\
    (This)->lpVtbl -> put_ToolTipText(This,pbstrToolTipText)

#define ITab_get_Width(This,pfWidth)	\
    (This)->lpVtbl -> get_Width(This,pfWidth)

#define ITab_put_Width(This,pfWidth)	\
    (This)->lpVtbl -> put_Width(This,pfWidth)

#define ITab_get_Height(This,pfHeight)	\
    (This)->lpVtbl -> get_Height(This,pfHeight)

#define ITab_put_Height(This,pfHeight)	\
    (This)->lpVtbl -> put_Height(This,pfHeight)

#define ITab_get_Top(This,pfTop)	\
    (This)->lpVtbl -> get_Top(This,pfTop)

#define ITab_put_Top(This,pfTop)	\
    (This)->lpVtbl -> put_Top(This,pfTop)

#define ITab_get_Left(This,pfLeft)	\
    (This)->lpVtbl -> get_Left(This,pfLeft)

#define ITab_put_Left(This,pfLeft)	\
    (This)->lpVtbl -> put_Left(This,pfLeft)

#define ITab_get_Selected(This,pbSelected)	\
    (This)->lpVtbl -> get_Selected(This,pbSelected)

#define ITab_put_Selected(This,pbSelected)	\
    (This)->lpVtbl -> put_Selected(This,pbSelected)

#define ITab_get_Image(This,pvImage)	\
    (This)->lpVtbl -> get_Image(This,pvImage)

#define ITab_put_Image(This,pvImage)	\
    (This)->lpVtbl -> put_Image(This,pvImage)

#define ITab_get_HighLighted(This,pbHighLighted)	\
    (This)->lpVtbl -> get_HighLighted(This,pbHighLighted)

#define ITab_put_HighLighted(This,pbHighLighted)	\
    (This)->lpVtbl -> put_HighLighted(This,pbHighLighted)

#define ITab_putref_Tag(This,pvTag)	\
    (This)->lpVtbl -> putref_Tag(This,pvTag)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [hidden][propget][id] */ HRESULT STDMETHODCALLTYPE ITab_get__ObjectDefault_Proxy( 
    ITab * This,
    /* [retval][out] */ BSTR *pbstrCaption);


void __RPC_STUB ITab_get__ObjectDefault_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [hidden][propput][id] */ HRESULT STDMETHODCALLTYPE ITab_put__ObjectDefault_Proxy( 
    ITab * This,
    /* [in] */ BSTR pbstrCaption);


void __RPC_STUB ITab_put__ObjectDefault_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE ITab_get_Caption_Proxy( 
    ITab * This,
    /* [retval][out] */ BSTR *pbstrCaption);


void __RPC_STUB ITab_get_Caption_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE ITab_put_Caption_Proxy( 
    ITab * This,
    /* [in] */ BSTR pbstrCaption);


void __RPC_STUB ITab_put_Caption_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE ITab_get_Tag_Proxy( 
    ITab * This,
    /* [retval][out] */ VARIANT *pvTag);


void __RPC_STUB ITab_get_Tag_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE ITab_put_Tag_Proxy( 
    ITab * This,
    /* [in] */ VARIANT pvTag);


void __RPC_STUB ITab_put_Tag_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE ITab_get_Index_Proxy( 
    ITab * This,
    /* [retval][out] */ short *psIndex);


void __RPC_STUB ITab_get_Index_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE ITab_put_Index_Proxy( 
    ITab * This,
    /* [in] */ short psIndex);


void __RPC_STUB ITab_put_Index_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE ITab_get_Key_Proxy( 
    ITab * This,
    /* [retval][out] */ BSTR *pbstrKey);


void __RPC_STUB ITab_get_Key_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE ITab_put_Key_Proxy( 
    ITab * This,
    /* [in] */ BSTR pbstrKey);


void __RPC_STUB ITab_put_Key_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE ITab_get_ToolTipText_Proxy( 
    ITab * This,
    /* [retval][out] */ BSTR *pbstrToolTipText);


void __RPC_STUB ITab_get_ToolTipText_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE ITab_put_ToolTipText_Proxy( 
    ITab * This,
    /* [in] */ BSTR pbstrToolTipText);


void __RPC_STUB ITab_put_ToolTipText_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE ITab_get_Width_Proxy( 
    ITab * This,
    /* [retval][out] */ single *pfWidth);


void __RPC_STUB ITab_get_Width_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE ITab_put_Width_Proxy( 
    ITab * This,
    /* [in] */ single pfWidth);


void __RPC_STUB ITab_put_Width_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE ITab_get_Height_Proxy( 
    ITab * This,
    /* [retval][out] */ single *pfHeight);


void __RPC_STUB ITab_get_Height_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE ITab_put_Height_Proxy( 
    ITab * This,
    /* [in] */ single pfHeight);


void __RPC_STUB ITab_put_Height_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE ITab_get_Top_Proxy( 
    ITab * This,
    /* [retval][out] */ single *pfTop);


void __RPC_STUB ITab_get_Top_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE ITab_put_Top_Proxy( 
    ITab * This,
    /* [in] */ single pfTop);


void __RPC_STUB ITab_put_Top_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE ITab_get_Left_Proxy( 
    ITab * This,
    /* [retval][out] */ single *pfLeft);


void __RPC_STUB ITab_get_Left_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE ITab_put_Left_Proxy( 
    ITab * This,
    /* [in] */ single pfLeft);


void __RPC_STUB ITab_put_Left_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE ITab_get_Selected_Proxy( 
    ITab * This,
    /* [retval][out] */ VARIANT_BOOL *pbSelected);


void __RPC_STUB ITab_get_Selected_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE ITab_put_Selected_Proxy( 
    ITab * This,
    /* [in] */ VARIANT_BOOL pbSelected);


void __RPC_STUB ITab_put_Selected_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE ITab_get_Image_Proxy( 
    ITab * This,
    /* [retval][out] */ VARIANT *pvImage);


void __RPC_STUB ITab_get_Image_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE ITab_put_Image_Proxy( 
    ITab * This,
    /* [in] */ VARIANT pvImage);


void __RPC_STUB ITab_put_Image_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE ITab_get_HighLighted_Proxy( 
    ITab * This,
    /* [retval][out] */ VARIANT_BOOL *pbHighLighted);


void __RPC_STUB ITab_get_HighLighted_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE ITab_put_HighLighted_Proxy( 
    ITab * This,
    /* [in] */ VARIANT_BOOL pbHighLighted);


void __RPC_STUB ITab_put_HighLighted_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propputref][id] */ HRESULT STDMETHODCALLTYPE ITab_putref_Tag_Proxy( 
    ITab * This,
    /* [in] */ VARIANT pvTag);


void __RPC_STUB ITab_putref_Tag_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ITab_INTERFACE_DEFINED__ */


#ifndef __IToolbar_INTERFACE_DEFINED__
#define __IToolbar_INTERFACE_DEFINED__

/* interface IToolbar */
/* [object][oleautomation][nonextensible][dual][hidden][helpcontext][helpstring][uuid] */ 


EXTERN_C const IID IID_IToolbar;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("66833FE4-8583-11D1-B16A-00C0F0283628")
    IToolbar : public IDispatch
    {
    public:
        virtual /* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_Appearance( 
            /* [retval][out] */ AppearanceConstants *pnAppearance) = 0;
        
        virtual /* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_Appearance( 
            /* [in] */ AppearanceConstants pnAppearance) = 0;
        
        virtual /* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_AllowCustomize( 
            /* [retval][out] */ VARIANT_BOOL *pbAllowCustomize) = 0;
        
        virtual /* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_AllowCustomize( 
            /* [in] */ VARIANT_BOOL pbAllowCustomize) = 0;
        
        virtual /* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_Buttons( 
            /* [retval][out] */ IButtons **ppButtons) = 0;
        
        virtual /* [helpcontext][helpstring][propputref][id] */ HRESULT STDMETHODCALLTYPE putref_Buttons( 
            /* [in] */ IButtons *ppButtons) = 0;
        
        virtual /* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_Controls( 
            /* [retval][out] */ IControls **ppControls) = 0;
        
        virtual /* [helpcontext][helpstring][requestedit][bindable][propget][id] */ HRESULT STDMETHODCALLTYPE get_Enabled( 
            /* [retval][out] */ VARIANT_BOOL *pbEnabled) = 0;
        
        virtual /* [helpcontext][helpstring][requestedit][bindable][propput][id] */ HRESULT STDMETHODCALLTYPE put_Enabled( 
            /* [in] */ VARIANT_BOOL pbEnabled) = 0;
        
        virtual /* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_hWnd( 
            /* [retval][out] */ /* external definition not present */ OLE_HANDLE *phWnd) = 0;
        
        virtual /* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_hWnd( 
            /* [in] */ /* external definition not present */ OLE_HANDLE phWnd) = 0;
        
        virtual /* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_MouseIcon( 
            /* [retval][out] */ /* external definition not present */ IPictureDisp **ppMouseIcon) = 0;
        
        virtual /* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_MouseIcon( 
            /* [in] */ /* external definition not present */ IPictureDisp *ppMouseIcon) = 0;
        
        virtual /* [helpcontext][helpstring][propputref][id] */ HRESULT STDMETHODCALLTYPE putref_MouseIcon( 
            /* [in] */ /* external definition not present */ IPictureDisp *ppMouseIcon) = 0;
        
        virtual /* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_MousePointer( 
            /* [retval][out] */ MousePointerConstants *psMousePointer) = 0;
        
        virtual /* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_MousePointer( 
            /* [in] */ MousePointerConstants psMousePointer) = 0;
        
        virtual /* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_ImageList( 
            /* [retval][out] */ IDispatch **ppImageList) = 0;
        
        virtual /* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_ImageList( 
            /* [in] */ IDispatch *ppImageList) = 0;
        
        virtual /* [helpcontext][helpstring][propputref][id] */ HRESULT STDMETHODCALLTYPE putref_ImageList( 
            /* [in] */ IDispatch *ppImageList) = 0;
        
        virtual /* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_ShowTips( 
            /* [retval][out] */ VARIANT_BOOL *bShowTips) = 0;
        
        virtual /* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_ShowTips( 
            /* [in] */ VARIANT_BOOL bShowTips) = 0;
        
        virtual /* [helpcontext][helpstring][requestedit][bindable][propget][id] */ HRESULT STDMETHODCALLTYPE get_BorderStyle( 
            /* [retval][out] */ BorderStyleConstants *psBorderStyle) = 0;
        
        virtual /* [helpcontext][helpstring][requestedit][bindable][propput][id] */ HRESULT STDMETHODCALLTYPE put_BorderStyle( 
            /* [in] */ BorderStyleConstants psBorderStyle) = 0;
        
        virtual /* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_Wrappable( 
            /* [retval][out] */ VARIANT_BOOL *pbWrappable) = 0;
        
        virtual /* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_Wrappable( 
            /* [in] */ VARIANT_BOOL pbWrappable) = 0;
        
        virtual /* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_ButtonHeight( 
            /* [retval][out] */ single *pfButtonHeight) = 0;
        
        virtual /* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_ButtonHeight( 
            /* [in] */ single pfButtonHeight) = 0;
        
        virtual /* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_ButtonWidth( 
            /* [retval][out] */ single *pfButtonWidth) = 0;
        
        virtual /* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_ButtonWidth( 
            /* [in] */ single pfButtonWidth) = 0;
        
        virtual /* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_HelpContextID( 
            /* [retval][out] */ long *plHelpContextID) = 0;
        
        virtual /* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_HelpContextID( 
            /* [in] */ long plHelpContextID) = 0;
        
        virtual /* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_HelpFile( 
            /* [retval][out] */ BSTR *pbstrHelpFile) = 0;
        
        virtual /* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_HelpFile( 
            /* [in] */ BSTR pbstrHelpFile) = 0;
        
        virtual /* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_OLEDropMode( 
            /* [retval][out] */ OLEDropConstants *psOLEDropMode) = 0;
        
        virtual /* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_OLEDropMode( 
            /* [in] */ OLEDropConstants psOLEDropMode) = 0;
        
        virtual /* [helpcontext][helpstring][id] */ HRESULT STDMETHODCALLTYPE Refresh( void) = 0;
        
        virtual /* [helpcontext][helpstring][id] */ HRESULT STDMETHODCALLTYPE Customize( void) = 0;
        
        virtual /* [helpcontext][helpstring][id] */ HRESULT STDMETHODCALLTYPE SaveToolbar( 
            /* [in] */ BSTR Key,
            /* [in] */ BSTR Subkey,
            /* [in] */ BSTR Value) = 0;
        
        virtual /* [helpcontext][helpstring][id] */ HRESULT STDMETHODCALLTYPE RestoreToolbar( 
            /* [in] */ BSTR Key,
            /* [in] */ BSTR Subkey,
            /* [in] */ BSTR Value) = 0;
        
        virtual /* [helpcontext][helpstring][id] */ HRESULT STDMETHODCALLTYPE OLEDrag( void) = 0;
        
        virtual /* [hidden][id] */ HRESULT STDMETHODCALLTYPE AboutBox( void) = 0;
        
        virtual /* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_DisabledImageList( 
            /* [retval][out] */ IDispatch **ppDisabledImageList) = 0;
        
        virtual /* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_DisabledImageList( 
            /* [in] */ IDispatch *ppDisabledImageList) = 0;
        
        virtual /* [helpcontext][helpstring][propputref][id] */ HRESULT STDMETHODCALLTYPE putref_DisabledImageList( 
            /* [in] */ IDispatch *ppDisabledImageList) = 0;
        
        virtual /* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_HotImageList( 
            /* [retval][out] */ IDispatch **ppHotImageList) = 0;
        
        virtual /* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_HotImageList( 
            /* [in] */ IDispatch *ppHotImageList) = 0;
        
        virtual /* [helpcontext][helpstring][propputref][id] */ HRESULT STDMETHODCALLTYPE putref_HotImageList( 
            /* [in] */ IDispatch *ppHotImageList) = 0;
        
        virtual /* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_Style( 
            /* [retval][out] */ ToolbarStyleConstants *penumStyle) = 0;
        
        virtual /* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_Style( 
            /* [in] */ ToolbarStyleConstants penumStyle) = 0;
        
        virtual /* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_TextAlignment( 
            /* [retval][out] */ ToolbarTextAlignConstants *penumTextAlignment) = 0;
        
        virtual /* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_TextAlignment( 
            /* [in] */ ToolbarTextAlignConstants penumTextAlignment) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IToolbarVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IToolbar * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IToolbar * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IToolbar * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IToolbar * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IToolbar * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IToolbar * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IToolbar * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_Appearance )( 
            IToolbar * This,
            /* [retval][out] */ AppearanceConstants *pnAppearance);
        
        /* [helpcontext][helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_Appearance )( 
            IToolbar * This,
            /* [in] */ AppearanceConstants pnAppearance);
        
        /* [helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_AllowCustomize )( 
            IToolbar * This,
            /* [retval][out] */ VARIANT_BOOL *pbAllowCustomize);
        
        /* [helpcontext][helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_AllowCustomize )( 
            IToolbar * This,
            /* [in] */ VARIANT_BOOL pbAllowCustomize);
        
        /* [helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_Buttons )( 
            IToolbar * This,
            /* [retval][out] */ IButtons **ppButtons);
        
        /* [helpcontext][helpstring][propputref][id] */ HRESULT ( STDMETHODCALLTYPE *putref_Buttons )( 
            IToolbar * This,
            /* [in] */ IButtons *ppButtons);
        
        /* [helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_Controls )( 
            IToolbar * This,
            /* [retval][out] */ IControls **ppControls);
        
        /* [helpcontext][helpstring][requestedit][bindable][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_Enabled )( 
            IToolbar * This,
            /* [retval][out] */ VARIANT_BOOL *pbEnabled);
        
        /* [helpcontext][helpstring][requestedit][bindable][propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_Enabled )( 
            IToolbar * This,
            /* [in] */ VARIANT_BOOL pbEnabled);
        
        /* [helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_hWnd )( 
            IToolbar * This,
            /* [retval][out] */ /* external definition not present */ OLE_HANDLE *phWnd);
        
        /* [helpcontext][helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_hWnd )( 
            IToolbar * This,
            /* [in] */ /* external definition not present */ OLE_HANDLE phWnd);
        
        /* [helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_MouseIcon )( 
            IToolbar * This,
            /* [retval][out] */ /* external definition not present */ IPictureDisp **ppMouseIcon);
        
        /* [helpcontext][helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_MouseIcon )( 
            IToolbar * This,
            /* [in] */ /* external definition not present */ IPictureDisp *ppMouseIcon);
        
        /* [helpcontext][helpstring][propputref][id] */ HRESULT ( STDMETHODCALLTYPE *putref_MouseIcon )( 
            IToolbar * This,
            /* [in] */ /* external definition not present */ IPictureDisp *ppMouseIcon);
        
        /* [helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_MousePointer )( 
            IToolbar * This,
            /* [retval][out] */ MousePointerConstants *psMousePointer);
        
        /* [helpcontext][helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_MousePointer )( 
            IToolbar * This,
            /* [in] */ MousePointerConstants psMousePointer);
        
        /* [helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_ImageList )( 
            IToolbar * This,
            /* [retval][out] */ IDispatch **ppImageList);
        
        /* [helpcontext][helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_ImageList )( 
            IToolbar * This,
            /* [in] */ IDispatch *ppImageList);
        
        /* [helpcontext][helpstring][propputref][id] */ HRESULT ( STDMETHODCALLTYPE *putref_ImageList )( 
            IToolbar * This,
            /* [in] */ IDispatch *ppImageList);
        
        /* [helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_ShowTips )( 
            IToolbar * This,
            /* [retval][out] */ VARIANT_BOOL *bShowTips);
        
        /* [helpcontext][helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_ShowTips )( 
            IToolbar * This,
            /* [in] */ VARIANT_BOOL bShowTips);
        
        /* [helpcontext][helpstring][requestedit][bindable][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_BorderStyle )( 
            IToolbar * This,
            /* [retval][out] */ BorderStyleConstants *psBorderStyle);
        
        /* [helpcontext][helpstring][requestedit][bindable][propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_BorderStyle )( 
            IToolbar * This,
            /* [in] */ BorderStyleConstants psBorderStyle);
        
        /* [helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_Wrappable )( 
            IToolbar * This,
            /* [retval][out] */ VARIANT_BOOL *pbWrappable);
        
        /* [helpcontext][helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_Wrappable )( 
            IToolbar * This,
            /* [in] */ VARIANT_BOOL pbWrappable);
        
        /* [helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_ButtonHeight )( 
            IToolbar * This,
            /* [retval][out] */ single *pfButtonHeight);
        
        /* [helpcontext][helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_ButtonHeight )( 
            IToolbar * This,
            /* [in] */ single pfButtonHeight);
        
        /* [helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_ButtonWidth )( 
            IToolbar * This,
            /* [retval][out] */ single *pfButtonWidth);
        
        /* [helpcontext][helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_ButtonWidth )( 
            IToolbar * This,
            /* [in] */ single pfButtonWidth);
        
        /* [helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_HelpContextID )( 
            IToolbar * This,
            /* [retval][out] */ long *plHelpContextID);
        
        /* [helpcontext][helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_HelpContextID )( 
            IToolbar * This,
            /* [in] */ long plHelpContextID);
        
        /* [helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_HelpFile )( 
            IToolbar * This,
            /* [retval][out] */ BSTR *pbstrHelpFile);
        
        /* [helpcontext][helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_HelpFile )( 
            IToolbar * This,
            /* [in] */ BSTR pbstrHelpFile);
        
        /* [helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_OLEDropMode )( 
            IToolbar * This,
            /* [retval][out] */ OLEDropConstants *psOLEDropMode);
        
        /* [helpcontext][helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_OLEDropMode )( 
            IToolbar * This,
            /* [in] */ OLEDropConstants psOLEDropMode);
        
        /* [helpcontext][helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Refresh )( 
            IToolbar * This);
        
        /* [helpcontext][helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Customize )( 
            IToolbar * This);
        
        /* [helpcontext][helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *SaveToolbar )( 
            IToolbar * This,
            /* [in] */ BSTR Key,
            /* [in] */ BSTR Subkey,
            /* [in] */ BSTR Value);
        
        /* [helpcontext][helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *RestoreToolbar )( 
            IToolbar * This,
            /* [in] */ BSTR Key,
            /* [in] */ BSTR Subkey,
            /* [in] */ BSTR Value);
        
        /* [helpcontext][helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *OLEDrag )( 
            IToolbar * This);
        
        /* [hidden][id] */ HRESULT ( STDMETHODCALLTYPE *AboutBox )( 
            IToolbar * This);
        
        /* [helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_DisabledImageList )( 
            IToolbar * This,
            /* [retval][out] */ IDispatch **ppDisabledImageList);
        
        /* [helpcontext][helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_DisabledImageList )( 
            IToolbar * This,
            /* [in] */ IDispatch *ppDisabledImageList);
        
        /* [helpcontext][helpstring][propputref][id] */ HRESULT ( STDMETHODCALLTYPE *putref_DisabledImageList )( 
            IToolbar * This,
            /* [in] */ IDispatch *ppDisabledImageList);
        
        /* [helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_HotImageList )( 
            IToolbar * This,
            /* [retval][out] */ IDispatch **ppHotImageList);
        
        /* [helpcontext][helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_HotImageList )( 
            IToolbar * This,
            /* [in] */ IDispatch *ppHotImageList);
        
        /* [helpcontext][helpstring][propputref][id] */ HRESULT ( STDMETHODCALLTYPE *putref_HotImageList )( 
            IToolbar * This,
            /* [in] */ IDispatch *ppHotImageList);
        
        /* [helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_Style )( 
            IToolbar * This,
            /* [retval][out] */ ToolbarStyleConstants *penumStyle);
        
        /* [helpcontext][helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_Style )( 
            IToolbar * This,
            /* [in] */ ToolbarStyleConstants penumStyle);
        
        /* [helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_TextAlignment )( 
            IToolbar * This,
            /* [retval][out] */ ToolbarTextAlignConstants *penumTextAlignment);
        
        /* [helpcontext][helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_TextAlignment )( 
            IToolbar * This,
            /* [in] */ ToolbarTextAlignConstants penumTextAlignment);
        
        END_INTERFACE
    } IToolbarVtbl;

    interface IToolbar
    {
        CONST_VTBL struct IToolbarVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IToolbar_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IToolbar_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IToolbar_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IToolbar_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IToolbar_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IToolbar_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IToolbar_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IToolbar_get_Appearance(This,pnAppearance)	\
    (This)->lpVtbl -> get_Appearance(This,pnAppearance)

#define IToolbar_put_Appearance(This,pnAppearance)	\
    (This)->lpVtbl -> put_Appearance(This,pnAppearance)

#define IToolbar_get_AllowCustomize(This,pbAllowCustomize)	\
    (This)->lpVtbl -> get_AllowCustomize(This,pbAllowCustomize)

#define IToolbar_put_AllowCustomize(This,pbAllowCustomize)	\
    (This)->lpVtbl -> put_AllowCustomize(This,pbAllowCustomize)

#define IToolbar_get_Buttons(This,ppButtons)	\
    (This)->lpVtbl -> get_Buttons(This,ppButtons)

#define IToolbar_putref_Buttons(This,ppButtons)	\
    (This)->lpVtbl -> putref_Buttons(This,ppButtons)

#define IToolbar_get_Controls(This,ppControls)	\
    (This)->lpVtbl -> get_Controls(This,ppControls)

#define IToolbar_get_Enabled(This,pbEnabled)	\
    (This)->lpVtbl -> get_Enabled(This,pbEnabled)

#define IToolbar_put_Enabled(This,pbEnabled)	\
    (This)->lpVtbl -> put_Enabled(This,pbEnabled)

#define IToolbar_get_hWnd(This,phWnd)	\
    (This)->lpVtbl -> get_hWnd(This,phWnd)

#define IToolbar_put_hWnd(This,phWnd)	\
    (This)->lpVtbl -> put_hWnd(This,phWnd)

#define IToolbar_get_MouseIcon(This,ppMouseIcon)	\
    (This)->lpVtbl -> get_MouseIcon(This,ppMouseIcon)

#define IToolbar_put_MouseIcon(This,ppMouseIcon)	\
    (This)->lpVtbl -> put_MouseIcon(This,ppMouseIcon)

#define IToolbar_putref_MouseIcon(This,ppMouseIcon)	\
    (This)->lpVtbl -> putref_MouseIcon(This,ppMouseIcon)

#define IToolbar_get_MousePointer(This,psMousePointer)	\
    (This)->lpVtbl -> get_MousePointer(This,psMousePointer)

#define IToolbar_put_MousePointer(This,psMousePointer)	\
    (This)->lpVtbl -> put_MousePointer(This,psMousePointer)

#define IToolbar_get_ImageList(This,ppImageList)	\
    (This)->lpVtbl -> get_ImageList(This,ppImageList)

#define IToolbar_put_ImageList(This,ppImageList)	\
    (This)->lpVtbl -> put_ImageList(This,ppImageList)

#define IToolbar_putref_ImageList(This,ppImageList)	\
    (This)->lpVtbl -> putref_ImageList(This,ppImageList)

#define IToolbar_get_ShowTips(This,bShowTips)	\
    (This)->lpVtbl -> get_ShowTips(This,bShowTips)

#define IToolbar_put_ShowTips(This,bShowTips)	\
    (This)->lpVtbl -> put_ShowTips(This,bShowTips)

#define IToolbar_get_BorderStyle(This,psBorderStyle)	\
    (This)->lpVtbl -> get_BorderStyle(This,psBorderStyle)

#define IToolbar_put_BorderStyle(This,psBorderStyle)	\
    (This)->lpVtbl -> put_BorderStyle(This,psBorderStyle)

#define IToolbar_get_Wrappable(This,pbWrappable)	\
    (This)->lpVtbl -> get_Wrappable(This,pbWrappable)

#define IToolbar_put_Wrappable(This,pbWrappable)	\
    (This)->lpVtbl -> put_Wrappable(This,pbWrappable)

#define IToolbar_get_ButtonHeight(This,pfButtonHeight)	\
    (This)->lpVtbl -> get_ButtonHeight(This,pfButtonHeight)

#define IToolbar_put_ButtonHeight(This,pfButtonHeight)	\
    (This)->lpVtbl -> put_ButtonHeight(This,pfButtonHeight)

#define IToolbar_get_ButtonWidth(This,pfButtonWidth)	\
    (This)->lpVtbl -> get_ButtonWidth(This,pfButtonWidth)

#define IToolbar_put_ButtonWidth(This,pfButtonWidth)	\
    (This)->lpVtbl -> put_ButtonWidth(This,pfButtonWidth)

#define IToolbar_get_HelpContextID(This,plHelpContextID)	\
    (This)->lpVtbl -> get_HelpContextID(This,plHelpContextID)

#define IToolbar_put_HelpContextID(This,plHelpContextID)	\
    (This)->lpVtbl -> put_HelpContextID(This,plHelpContextID)

#define IToolbar_get_HelpFile(This,pbstrHelpFile)	\
    (This)->lpVtbl -> get_HelpFile(This,pbstrHelpFile)

#define IToolbar_put_HelpFile(This,pbstrHelpFile)	\
    (This)->lpVtbl -> put_HelpFile(This,pbstrHelpFile)

#define IToolbar_get_OLEDropMode(This,psOLEDropMode)	\
    (This)->lpVtbl -> get_OLEDropMode(This,psOLEDropMode)

#define IToolbar_put_OLEDropMode(This,psOLEDropMode)	\
    (This)->lpVtbl -> put_OLEDropMode(This,psOLEDropMode)

#define IToolbar_Refresh(This)	\
    (This)->lpVtbl -> Refresh(This)

#define IToolbar_Customize(This)	\
    (This)->lpVtbl -> Customize(This)

#define IToolbar_SaveToolbar(This,Key,Subkey,Value)	\
    (This)->lpVtbl -> SaveToolbar(This,Key,Subkey,Value)

#define IToolbar_RestoreToolbar(This,Key,Subkey,Value)	\
    (This)->lpVtbl -> RestoreToolbar(This,Key,Subkey,Value)

#define IToolbar_OLEDrag(This)	\
    (This)->lpVtbl -> OLEDrag(This)

#define IToolbar_AboutBox(This)	\
    (This)->lpVtbl -> AboutBox(This)

#define IToolbar_get_DisabledImageList(This,ppDisabledImageList)	\
    (This)->lpVtbl -> get_DisabledImageList(This,ppDisabledImageList)

#define IToolbar_put_DisabledImageList(This,ppDisabledImageList)	\
    (This)->lpVtbl -> put_DisabledImageList(This,ppDisabledImageList)

#define IToolbar_putref_DisabledImageList(This,ppDisabledImageList)	\
    (This)->lpVtbl -> putref_DisabledImageList(This,ppDisabledImageList)

#define IToolbar_get_HotImageList(This,ppHotImageList)	\
    (This)->lpVtbl -> get_HotImageList(This,ppHotImageList)

#define IToolbar_put_HotImageList(This,ppHotImageList)	\
    (This)->lpVtbl -> put_HotImageList(This,ppHotImageList)

#define IToolbar_putref_HotImageList(This,ppHotImageList)	\
    (This)->lpVtbl -> putref_HotImageList(This,ppHotImageList)

#define IToolbar_get_Style(This,penumStyle)	\
    (This)->lpVtbl -> get_Style(This,penumStyle)

#define IToolbar_put_Style(This,penumStyle)	\
    (This)->lpVtbl -> put_Style(This,penumStyle)

#define IToolbar_get_TextAlignment(This,penumTextAlignment)	\
    (This)->lpVtbl -> get_TextAlignment(This,penumTextAlignment)

#define IToolbar_put_TextAlignment(This,penumTextAlignment)	\
    (This)->lpVtbl -> put_TextAlignment(This,penumTextAlignment)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IToolbar_get_Appearance_Proxy( 
    IToolbar * This,
    /* [retval][out] */ AppearanceConstants *pnAppearance);


void __RPC_STUB IToolbar_get_Appearance_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE IToolbar_put_Appearance_Proxy( 
    IToolbar * This,
    /* [in] */ AppearanceConstants pnAppearance);


void __RPC_STUB IToolbar_put_Appearance_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IToolbar_get_AllowCustomize_Proxy( 
    IToolbar * This,
    /* [retval][out] */ VARIANT_BOOL *pbAllowCustomize);


void __RPC_STUB IToolbar_get_AllowCustomize_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE IToolbar_put_AllowCustomize_Proxy( 
    IToolbar * This,
    /* [in] */ VARIANT_BOOL pbAllowCustomize);


void __RPC_STUB IToolbar_put_AllowCustomize_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IToolbar_get_Buttons_Proxy( 
    IToolbar * This,
    /* [retval][out] */ IButtons **ppButtons);


void __RPC_STUB IToolbar_get_Buttons_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propputref][id] */ HRESULT STDMETHODCALLTYPE IToolbar_putref_Buttons_Proxy( 
    IToolbar * This,
    /* [in] */ IButtons *ppButtons);


void __RPC_STUB IToolbar_putref_Buttons_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IToolbar_get_Controls_Proxy( 
    IToolbar * This,
    /* [retval][out] */ IControls **ppControls);


void __RPC_STUB IToolbar_get_Controls_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][requestedit][bindable][propget][id] */ HRESULT STDMETHODCALLTYPE IToolbar_get_Enabled_Proxy( 
    IToolbar * This,
    /* [retval][out] */ VARIANT_BOOL *pbEnabled);


void __RPC_STUB IToolbar_get_Enabled_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][requestedit][bindable][propput][id] */ HRESULT STDMETHODCALLTYPE IToolbar_put_Enabled_Proxy( 
    IToolbar * This,
    /* [in] */ VARIANT_BOOL pbEnabled);


void __RPC_STUB IToolbar_put_Enabled_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IToolbar_get_hWnd_Proxy( 
    IToolbar * This,
    /* [retval][out] */ /* external definition not present */ OLE_HANDLE *phWnd);


void __RPC_STUB IToolbar_get_hWnd_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE IToolbar_put_hWnd_Proxy( 
    IToolbar * This,
    /* [in] */ /* external definition not present */ OLE_HANDLE phWnd);


void __RPC_STUB IToolbar_put_hWnd_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IToolbar_get_MouseIcon_Proxy( 
    IToolbar * This,
    /* [retval][out] */ /* external definition not present */ IPictureDisp **ppMouseIcon);


void __RPC_STUB IToolbar_get_MouseIcon_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE IToolbar_put_MouseIcon_Proxy( 
    IToolbar * This,
    /* [in] */ /* external definition not present */ IPictureDisp *ppMouseIcon);


void __RPC_STUB IToolbar_put_MouseIcon_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propputref][id] */ HRESULT STDMETHODCALLTYPE IToolbar_putref_MouseIcon_Proxy( 
    IToolbar * This,
    /* [in] */ /* external definition not present */ IPictureDisp *ppMouseIcon);


void __RPC_STUB IToolbar_putref_MouseIcon_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IToolbar_get_MousePointer_Proxy( 
    IToolbar * This,
    /* [retval][out] */ MousePointerConstants *psMousePointer);


void __RPC_STUB IToolbar_get_MousePointer_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE IToolbar_put_MousePointer_Proxy( 
    IToolbar * This,
    /* [in] */ MousePointerConstants psMousePointer);


void __RPC_STUB IToolbar_put_MousePointer_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IToolbar_get_ImageList_Proxy( 
    IToolbar * This,
    /* [retval][out] */ IDispatch **ppImageList);


void __RPC_STUB IToolbar_get_ImageList_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE IToolbar_put_ImageList_Proxy( 
    IToolbar * This,
    /* [in] */ IDispatch *ppImageList);


void __RPC_STUB IToolbar_put_ImageList_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propputref][id] */ HRESULT STDMETHODCALLTYPE IToolbar_putref_ImageList_Proxy( 
    IToolbar * This,
    /* [in] */ IDispatch *ppImageList);


void __RPC_STUB IToolbar_putref_ImageList_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IToolbar_get_ShowTips_Proxy( 
    IToolbar * This,
    /* [retval][out] */ VARIANT_BOOL *bShowTips);


void __RPC_STUB IToolbar_get_ShowTips_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE IToolbar_put_ShowTips_Proxy( 
    IToolbar * This,
    /* [in] */ VARIANT_BOOL bShowTips);


void __RPC_STUB IToolbar_put_ShowTips_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][requestedit][bindable][propget][id] */ HRESULT STDMETHODCALLTYPE IToolbar_get_BorderStyle_Proxy( 
    IToolbar * This,
    /* [retval][out] */ BorderStyleConstants *psBorderStyle);


void __RPC_STUB IToolbar_get_BorderStyle_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][requestedit][bindable][propput][id] */ HRESULT STDMETHODCALLTYPE IToolbar_put_BorderStyle_Proxy( 
    IToolbar * This,
    /* [in] */ BorderStyleConstants psBorderStyle);


void __RPC_STUB IToolbar_put_BorderStyle_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IToolbar_get_Wrappable_Proxy( 
    IToolbar * This,
    /* [retval][out] */ VARIANT_BOOL *pbWrappable);


void __RPC_STUB IToolbar_get_Wrappable_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE IToolbar_put_Wrappable_Proxy( 
    IToolbar * This,
    /* [in] */ VARIANT_BOOL pbWrappable);


void __RPC_STUB IToolbar_put_Wrappable_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IToolbar_get_ButtonHeight_Proxy( 
    IToolbar * This,
    /* [retval][out] */ single *pfButtonHeight);


void __RPC_STUB IToolbar_get_ButtonHeight_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE IToolbar_put_ButtonHeight_Proxy( 
    IToolbar * This,
    /* [in] */ single pfButtonHeight);


void __RPC_STUB IToolbar_put_ButtonHeight_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IToolbar_get_ButtonWidth_Proxy( 
    IToolbar * This,
    /* [retval][out] */ single *pfButtonWidth);


void __RPC_STUB IToolbar_get_ButtonWidth_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE IToolbar_put_ButtonWidth_Proxy( 
    IToolbar * This,
    /* [in] */ single pfButtonWidth);


void __RPC_STUB IToolbar_put_ButtonWidth_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IToolbar_get_HelpContextID_Proxy( 
    IToolbar * This,
    /* [retval][out] */ long *plHelpContextID);


void __RPC_STUB IToolbar_get_HelpContextID_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE IToolbar_put_HelpContextID_Proxy( 
    IToolbar * This,
    /* [in] */ long plHelpContextID);


void __RPC_STUB IToolbar_put_HelpContextID_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IToolbar_get_HelpFile_Proxy( 
    IToolbar * This,
    /* [retval][out] */ BSTR *pbstrHelpFile);


void __RPC_STUB IToolbar_get_HelpFile_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE IToolbar_put_HelpFile_Proxy( 
    IToolbar * This,
    /* [in] */ BSTR pbstrHelpFile);


void __RPC_STUB IToolbar_put_HelpFile_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IToolbar_get_OLEDropMode_Proxy( 
    IToolbar * This,
    /* [retval][out] */ OLEDropConstants *psOLEDropMode);


void __RPC_STUB IToolbar_get_OLEDropMode_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE IToolbar_put_OLEDropMode_Proxy( 
    IToolbar * This,
    /* [in] */ OLEDropConstants psOLEDropMode);


void __RPC_STUB IToolbar_put_OLEDropMode_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][id] */ HRESULT STDMETHODCALLTYPE IToolbar_Refresh_Proxy( 
    IToolbar * This);


void __RPC_STUB IToolbar_Refresh_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][id] */ HRESULT STDMETHODCALLTYPE IToolbar_Customize_Proxy( 
    IToolbar * This);


void __RPC_STUB IToolbar_Customize_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][id] */ HRESULT STDMETHODCALLTYPE IToolbar_SaveToolbar_Proxy( 
    IToolbar * This,
    /* [in] */ BSTR Key,
    /* [in] */ BSTR Subkey,
    /* [in] */ BSTR Value);


void __RPC_STUB IToolbar_SaveToolbar_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][id] */ HRESULT STDMETHODCALLTYPE IToolbar_RestoreToolbar_Proxy( 
    IToolbar * This,
    /* [in] */ BSTR Key,
    /* [in] */ BSTR Subkey,
    /* [in] */ BSTR Value);


void __RPC_STUB IToolbar_RestoreToolbar_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][id] */ HRESULT STDMETHODCALLTYPE IToolbar_OLEDrag_Proxy( 
    IToolbar * This);


void __RPC_STUB IToolbar_OLEDrag_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [hidden][id] */ HRESULT STDMETHODCALLTYPE IToolbar_AboutBox_Proxy( 
    IToolbar * This);


void __RPC_STUB IToolbar_AboutBox_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IToolbar_get_DisabledImageList_Proxy( 
    IToolbar * This,
    /* [retval][out] */ IDispatch **ppDisabledImageList);


void __RPC_STUB IToolbar_get_DisabledImageList_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE IToolbar_put_DisabledImageList_Proxy( 
    IToolbar * This,
    /* [in] */ IDispatch *ppDisabledImageList);


void __RPC_STUB IToolbar_put_DisabledImageList_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propputref][id] */ HRESULT STDMETHODCALLTYPE IToolbar_putref_DisabledImageList_Proxy( 
    IToolbar * This,
    /* [in] */ IDispatch *ppDisabledImageList);


void __RPC_STUB IToolbar_putref_DisabledImageList_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IToolbar_get_HotImageList_Proxy( 
    IToolbar * This,
    /* [retval][out] */ IDispatch **ppHotImageList);


void __RPC_STUB IToolbar_get_HotImageList_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE IToolbar_put_HotImageList_Proxy( 
    IToolbar * This,
    /* [in] */ IDispatch *ppHotImageList);


void __RPC_STUB IToolbar_put_HotImageList_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propputref][id] */ HRESULT STDMETHODCALLTYPE IToolbar_putref_HotImageList_Proxy( 
    IToolbar * This,
    /* [in] */ IDispatch *ppHotImageList);


void __RPC_STUB IToolbar_putref_HotImageList_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IToolbar_get_Style_Proxy( 
    IToolbar * This,
    /* [retval][out] */ ToolbarStyleConstants *penumStyle);


void __RPC_STUB IToolbar_get_Style_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE IToolbar_put_Style_Proxy( 
    IToolbar * This,
    /* [in] */ ToolbarStyleConstants penumStyle);


void __RPC_STUB IToolbar_put_Style_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IToolbar_get_TextAlignment_Proxy( 
    IToolbar * This,
    /* [retval][out] */ ToolbarTextAlignConstants *penumTextAlignment);


void __RPC_STUB IToolbar_get_TextAlignment_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE IToolbar_put_TextAlignment_Proxy( 
    IToolbar * This,
    /* [in] */ ToolbarTextAlignConstants penumTextAlignment);


void __RPC_STUB IToolbar_put_TextAlignment_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IToolbar_INTERFACE_DEFINED__ */


#ifndef __IToolbarEvents_DISPINTERFACE_DEFINED__
#define __IToolbarEvents_DISPINTERFACE_DEFINED__

/* dispinterface IToolbarEvents */
/* [helpcontext][helpstring][uuid] */ 


EXTERN_C const IID DIID_IToolbarEvents;

#if defined(__cplusplus) && !defined(CINTERFACE)

    MIDL_INTERFACE("66833FE5-8583-11D1-B16A-00C0F0283628")
    IToolbarEvents : public IDispatch
    {
    };
    
#else 	/* C style interface */

    typedef struct IToolbarEventsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IToolbarEvents * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IToolbarEvents * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IToolbarEvents * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IToolbarEvents * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IToolbarEvents * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IToolbarEvents * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IToolbarEvents * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        END_INTERFACE
    } IToolbarEventsVtbl;

    interface IToolbarEvents
    {
        CONST_VTBL struct IToolbarEventsVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IToolbarEvents_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IToolbarEvents_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IToolbarEvents_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IToolbarEvents_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IToolbarEvents_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IToolbarEvents_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IToolbarEvents_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)

#endif /* COBJMACROS */


#endif 	/* C style interface */


#endif 	/* __IToolbarEvents_DISPINTERFACE_DEFINED__ */


#ifndef __IButtons_INTERFACE_DEFINED__
#define __IButtons_INTERFACE_DEFINED__

/* interface IButtons */
/* [object][oleautomation][nonextensible][dual][helpcontext][helpstring][uuid] */ 


EXTERN_C const IID IID_IButtons;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("66833FE7-8583-11D1-B16A-00C0F0283628")
    IButtons : public IDispatch
    {
    public:
        virtual /* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_Count( 
            /* [retval][out] */ short *psCount) = 0;
        
        virtual /* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_Count( 
            /* [in] */ short psCount) = 0;
        
        virtual /* [hidden][propget][id] */ HRESULT STDMETHODCALLTYPE get_ControlDefault( 
            /* [in] */ VARIANT *Index,
            /* [retval][out] */ IButton **ppButton) = 0;
        
        virtual /* [hidden][propputref][id] */ HRESULT STDMETHODCALLTYPE putref_ControlDefault( 
            /* [in] */ VARIANT *Index,
            /* [in] */ IButton *ppButton) = 0;
        
        virtual /* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_Item( 
            /* [in] */ VARIANT *Index,
            /* [retval][out] */ IButton **ppButton) = 0;
        
        virtual /* [helpcontext][helpstring][propputref][id] */ HRESULT STDMETHODCALLTYPE putref_Item( 
            /* [in] */ VARIANT *Index,
            /* [in] */ IButton *ppButton) = 0;
        
        virtual /* [helpcontext][helpstring][id] */ HRESULT STDMETHODCALLTYPE Remove( 
            /* [in] */ VARIANT *Index) = 0;
        
        virtual /* [helpcontext][helpstring][id] */ HRESULT STDMETHODCALLTYPE Clear( void) = 0;
        
        virtual /* [helpcontext][helpstring][id] */ HRESULT STDMETHODCALLTYPE Add( 
            /* [optional][in] */ VARIANT *Index,
            /* [optional][in] */ VARIANT *Key,
            /* [optional][in] */ VARIANT *Caption,
            /* [optional][in] */ VARIANT *Style,
            /* [optional][in] */ VARIANT *Image,
            /* [retval][out] */ IButton **ppButton) = 0;
        
        virtual /* [hidden][id] */ HRESULT STDMETHODCALLTYPE _NewEnum( 
            /* [retval][out] */ IDispatch **ppDispatch) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IButtonsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IButtons * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IButtons * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IButtons * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IButtons * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IButtons * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IButtons * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IButtons * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_Count )( 
            IButtons * This,
            /* [retval][out] */ short *psCount);
        
        /* [helpcontext][helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_Count )( 
            IButtons * This,
            /* [in] */ short psCount);
        
        /* [hidden][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_ControlDefault )( 
            IButtons * This,
            /* [in] */ VARIANT *Index,
            /* [retval][out] */ IButton **ppButton);
        
        /* [hidden][propputref][id] */ HRESULT ( STDMETHODCALLTYPE *putref_ControlDefault )( 
            IButtons * This,
            /* [in] */ VARIANT *Index,
            /* [in] */ IButton *ppButton);
        
        /* [helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_Item )( 
            IButtons * This,
            /* [in] */ VARIANT *Index,
            /* [retval][out] */ IButton **ppButton);
        
        /* [helpcontext][helpstring][propputref][id] */ HRESULT ( STDMETHODCALLTYPE *putref_Item )( 
            IButtons * This,
            /* [in] */ VARIANT *Index,
            /* [in] */ IButton *ppButton);
        
        /* [helpcontext][helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Remove )( 
            IButtons * This,
            /* [in] */ VARIANT *Index);
        
        /* [helpcontext][helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Clear )( 
            IButtons * This);
        
        /* [helpcontext][helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Add )( 
            IButtons * This,
            /* [optional][in] */ VARIANT *Index,
            /* [optional][in] */ VARIANT *Key,
            /* [optional][in] */ VARIANT *Caption,
            /* [optional][in] */ VARIANT *Style,
            /* [optional][in] */ VARIANT *Image,
            /* [retval][out] */ IButton **ppButton);
        
        /* [hidden][id] */ HRESULT ( STDMETHODCALLTYPE *_NewEnum )( 
            IButtons * This,
            /* [retval][out] */ IDispatch **ppDispatch);
        
        END_INTERFACE
    } IButtonsVtbl;

    interface IButtons
    {
        CONST_VTBL struct IButtonsVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IButtons_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IButtons_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IButtons_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IButtons_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IButtons_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IButtons_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IButtons_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IButtons_get_Count(This,psCount)	\
    (This)->lpVtbl -> get_Count(This,psCount)

#define IButtons_put_Count(This,psCount)	\
    (This)->lpVtbl -> put_Count(This,psCount)

#define IButtons_get_ControlDefault(This,Index,ppButton)	\
    (This)->lpVtbl -> get_ControlDefault(This,Index,ppButton)

#define IButtons_putref_ControlDefault(This,Index,ppButton)	\
    (This)->lpVtbl -> putref_ControlDefault(This,Index,ppButton)

#define IButtons_get_Item(This,Index,ppButton)	\
    (This)->lpVtbl -> get_Item(This,Index,ppButton)

#define IButtons_putref_Item(This,Index,ppButton)	\
    (This)->lpVtbl -> putref_Item(This,Index,ppButton)

#define IButtons_Remove(This,Index)	\
    (This)->lpVtbl -> Remove(This,Index)

#define IButtons_Clear(This)	\
    (This)->lpVtbl -> Clear(This)

#define IButtons_Add(This,Index,Key,Caption,Style,Image,ppButton)	\
    (This)->lpVtbl -> Add(This,Index,Key,Caption,Style,Image,ppButton)

#define IButtons__NewEnum(This,ppDispatch)	\
    (This)->lpVtbl -> _NewEnum(This,ppDispatch)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IButtons_get_Count_Proxy( 
    IButtons * This,
    /* [retval][out] */ short *psCount);


void __RPC_STUB IButtons_get_Count_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE IButtons_put_Count_Proxy( 
    IButtons * This,
    /* [in] */ short psCount);


void __RPC_STUB IButtons_put_Count_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [hidden][propget][id] */ HRESULT STDMETHODCALLTYPE IButtons_get_ControlDefault_Proxy( 
    IButtons * This,
    /* [in] */ VARIANT *Index,
    /* [retval][out] */ IButton **ppButton);


void __RPC_STUB IButtons_get_ControlDefault_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [hidden][propputref][id] */ HRESULT STDMETHODCALLTYPE IButtons_putref_ControlDefault_Proxy( 
    IButtons * This,
    /* [in] */ VARIANT *Index,
    /* [in] */ IButton *ppButton);


void __RPC_STUB IButtons_putref_ControlDefault_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IButtons_get_Item_Proxy( 
    IButtons * This,
    /* [in] */ VARIANT *Index,
    /* [retval][out] */ IButton **ppButton);


void __RPC_STUB IButtons_get_Item_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propputref][id] */ HRESULT STDMETHODCALLTYPE IButtons_putref_Item_Proxy( 
    IButtons * This,
    /* [in] */ VARIANT *Index,
    /* [in] */ IButton *ppButton);


void __RPC_STUB IButtons_putref_Item_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][id] */ HRESULT STDMETHODCALLTYPE IButtons_Remove_Proxy( 
    IButtons * This,
    /* [in] */ VARIANT *Index);


void __RPC_STUB IButtons_Remove_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][id] */ HRESULT STDMETHODCALLTYPE IButtons_Clear_Proxy( 
    IButtons * This);


void __RPC_STUB IButtons_Clear_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][id] */ HRESULT STDMETHODCALLTYPE IButtons_Add_Proxy( 
    IButtons * This,
    /* [optional][in] */ VARIANT *Index,
    /* [optional][in] */ VARIANT *Key,
    /* [optional][in] */ VARIANT *Caption,
    /* [optional][in] */ VARIANT *Style,
    /* [optional][in] */ VARIANT *Image,
    /* [retval][out] */ IButton **ppButton);


void __RPC_STUB IButtons_Add_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [hidden][id] */ HRESULT STDMETHODCALLTYPE IButtons__NewEnum_Proxy( 
    IButtons * This,
    /* [retval][out] */ IDispatch **ppDispatch);


void __RPC_STUB IButtons__NewEnum_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IButtons_INTERFACE_DEFINED__ */


#ifndef __IButton_INTERFACE_DEFINED__
#define __IButton_INTERFACE_DEFINED__

/* interface IButton */
/* [object][oleautomation][nonextensible][dual][helpcontext][helpstring][uuid] */ 


EXTERN_C const IID IID_IButton;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("66833FE9-8583-11D1-B16A-00C0F0283628")
    IButton : public IDispatch
    {
    public:
        virtual /* [hidden][propget][id] */ HRESULT STDMETHODCALLTYPE get__ObjectDefault( 
            /* [retval][out] */ BSTR *pbstr_ObjectDefault) = 0;
        
        virtual /* [hidden][propput][id] */ HRESULT STDMETHODCALLTYPE put__ObjectDefault( 
            /* [in] */ BSTR pbstr_ObjectDefault) = 0;
        
        virtual /* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_Caption( 
            /* [retval][out] */ BSTR *pbstrCaption) = 0;
        
        virtual /* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_Caption( 
            /* [in] */ BSTR pbstrCaption) = 0;
        
        virtual /* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_Tag( 
            /* [retval][out] */ VARIANT *pvTag) = 0;
        
        virtual /* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_Tag( 
            /* [in] */ VARIANT pvTag) = 0;
        
        virtual /* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_Enabled( 
            /* [retval][out] */ VARIANT_BOOL *pbEnabled) = 0;
        
        virtual /* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_Enabled( 
            /* [in] */ VARIANT_BOOL pbEnabled) = 0;
        
        virtual /* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_Index( 
            /* [retval][out] */ short *psIndex) = 0;
        
        virtual /* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_Index( 
            /* [in] */ short psIndex) = 0;
        
        virtual /* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_Key( 
            /* [retval][out] */ BSTR *pbstrKey) = 0;
        
        virtual /* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_Key( 
            /* [in] */ BSTR pbstrKey) = 0;
        
        virtual /* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_ToolTipText( 
            /* [retval][out] */ BSTR *pbstrToolTipText) = 0;
        
        virtual /* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_ToolTipText( 
            /* [in] */ BSTR pbstrToolTipText) = 0;
        
        virtual /* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_Visible( 
            /* [retval][out] */ VARIANT_BOOL *pbVisible) = 0;
        
        virtual /* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_Visible( 
            /* [in] */ VARIANT_BOOL pbVisible) = 0;
        
        virtual /* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_Width( 
            /* [retval][out] */ single *pfWidth) = 0;
        
        virtual /* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_Width( 
            /* [in] */ single pfWidth) = 0;
        
        virtual /* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_Height( 
            /* [retval][out] */ single *pfHeight) = 0;
        
        virtual /* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_Height( 
            /* [in] */ single pfHeight) = 0;
        
        virtual /* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_Top( 
            /* [retval][out] */ single *pfTop) = 0;
        
        virtual /* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_Top( 
            /* [in] */ single pfTop) = 0;
        
        virtual /* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_Left( 
            /* [retval][out] */ single *pfLeft) = 0;
        
        virtual /* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_Left( 
            /* [in] */ single pfLeft) = 0;
        
        virtual /* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_Value( 
            /* [retval][out] */ ValueConstants *psValue) = 0;
        
        virtual /* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_Value( 
            /* [in] */ ValueConstants psValue) = 0;
        
        virtual /* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_Style( 
            /* [retval][out] */ ButtonStyleConstants *psStyle) = 0;
        
        virtual /* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_Style( 
            /* [in] */ ButtonStyleConstants psStyle) = 0;
        
        virtual /* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_Description( 
            /* [retval][out] */ BSTR *pbstrDescription) = 0;
        
        virtual /* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_Description( 
            /* [in] */ BSTR pbstrDescription) = 0;
        
        virtual /* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_Image( 
            /* [retval][out] */ VARIANT *pvImage) = 0;
        
        virtual /* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_Image( 
            /* [in] */ VARIANT pvImage) = 0;
        
        virtual /* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_MixedState( 
            /* [retval][out] */ VARIANT_BOOL *pbMixedState) = 0;
        
        virtual /* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_MixedState( 
            /* [in] */ VARIANT_BOOL pbMixedState) = 0;
        
        virtual /* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_ButtonMenus( 
            /* [retval][out] */ IButtonMenus **ppButtonMenus) = 0;
        
        virtual /* [helpcontext][helpstring][propputref][id] */ HRESULT STDMETHODCALLTYPE putref_ButtonMenus( 
            /* [in] */ IButtonMenus *ppButtonMenus) = 0;
        
        virtual /* [helpcontext][helpstring][propputref][id] */ HRESULT STDMETHODCALLTYPE putref_Tag( 
            /* [in] */ VARIANT pvTag) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IButtonVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IButton * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IButton * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IButton * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IButton * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IButton * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IButton * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IButton * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [hidden][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get__ObjectDefault )( 
            IButton * This,
            /* [retval][out] */ BSTR *pbstr_ObjectDefault);
        
        /* [hidden][propput][id] */ HRESULT ( STDMETHODCALLTYPE *put__ObjectDefault )( 
            IButton * This,
            /* [in] */ BSTR pbstr_ObjectDefault);
        
        /* [helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_Caption )( 
            IButton * This,
            /* [retval][out] */ BSTR *pbstrCaption);
        
        /* [helpcontext][helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_Caption )( 
            IButton * This,
            /* [in] */ BSTR pbstrCaption);
        
        /* [helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_Tag )( 
            IButton * This,
            /* [retval][out] */ VARIANT *pvTag);
        
        /* [helpcontext][helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_Tag )( 
            IButton * This,
            /* [in] */ VARIANT pvTag);
        
        /* [helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_Enabled )( 
            IButton * This,
            /* [retval][out] */ VARIANT_BOOL *pbEnabled);
        
        /* [helpcontext][helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_Enabled )( 
            IButton * This,
            /* [in] */ VARIANT_BOOL pbEnabled);
        
        /* [helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_Index )( 
            IButton * This,
            /* [retval][out] */ short *psIndex);
        
        /* [helpcontext][helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_Index )( 
            IButton * This,
            /* [in] */ short psIndex);
        
        /* [helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_Key )( 
            IButton * This,
            /* [retval][out] */ BSTR *pbstrKey);
        
        /* [helpcontext][helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_Key )( 
            IButton * This,
            /* [in] */ BSTR pbstrKey);
        
        /* [helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_ToolTipText )( 
            IButton * This,
            /* [retval][out] */ BSTR *pbstrToolTipText);
        
        /* [helpcontext][helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_ToolTipText )( 
            IButton * This,
            /* [in] */ BSTR pbstrToolTipText);
        
        /* [helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_Visible )( 
            IButton * This,
            /* [retval][out] */ VARIANT_BOOL *pbVisible);
        
        /* [helpcontext][helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_Visible )( 
            IButton * This,
            /* [in] */ VARIANT_BOOL pbVisible);
        
        /* [helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_Width )( 
            IButton * This,
            /* [retval][out] */ single *pfWidth);
        
        /* [helpcontext][helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_Width )( 
            IButton * This,
            /* [in] */ single pfWidth);
        
        /* [helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_Height )( 
            IButton * This,
            /* [retval][out] */ single *pfHeight);
        
        /* [helpcontext][helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_Height )( 
            IButton * This,
            /* [in] */ single pfHeight);
        
        /* [helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_Top )( 
            IButton * This,
            /* [retval][out] */ single *pfTop);
        
        /* [helpcontext][helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_Top )( 
            IButton * This,
            /* [in] */ single pfTop);
        
        /* [helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_Left )( 
            IButton * This,
            /* [retval][out] */ single *pfLeft);
        
        /* [helpcontext][helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_Left )( 
            IButton * This,
            /* [in] */ single pfLeft);
        
        /* [helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_Value )( 
            IButton * This,
            /* [retval][out] */ ValueConstants *psValue);
        
        /* [helpcontext][helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_Value )( 
            IButton * This,
            /* [in] */ ValueConstants psValue);
        
        /* [helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_Style )( 
            IButton * This,
            /* [retval][out] */ ButtonStyleConstants *psStyle);
        
        /* [helpcontext][helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_Style )( 
            IButton * This,
            /* [in] */ ButtonStyleConstants psStyle);
        
        /* [helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_Description )( 
            IButton * This,
            /* [retval][out] */ BSTR *pbstrDescription);
        
        /* [helpcontext][helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_Description )( 
            IButton * This,
            /* [in] */ BSTR pbstrDescription);
        
        /* [helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_Image )( 
            IButton * This,
            /* [retval][out] */ VARIANT *pvImage);
        
        /* [helpcontext][helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_Image )( 
            IButton * This,
            /* [in] */ VARIANT pvImage);
        
        /* [helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_MixedState )( 
            IButton * This,
            /* [retval][out] */ VARIANT_BOOL *pbMixedState);
        
        /* [helpcontext][helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_MixedState )( 
            IButton * This,
            /* [in] */ VARIANT_BOOL pbMixedState);
        
        /* [helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_ButtonMenus )( 
            IButton * This,
            /* [retval][out] */ IButtonMenus **ppButtonMenus);
        
        /* [helpcontext][helpstring][propputref][id] */ HRESULT ( STDMETHODCALLTYPE *putref_ButtonMenus )( 
            IButton * This,
            /* [in] */ IButtonMenus *ppButtonMenus);
        
        /* [helpcontext][helpstring][propputref][id] */ HRESULT ( STDMETHODCALLTYPE *putref_Tag )( 
            IButton * This,
            /* [in] */ VARIANT pvTag);
        
        END_INTERFACE
    } IButtonVtbl;

    interface IButton
    {
        CONST_VTBL struct IButtonVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IButton_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IButton_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IButton_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IButton_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IButton_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IButton_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IButton_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IButton_get__ObjectDefault(This,pbstr_ObjectDefault)	\
    (This)->lpVtbl -> get__ObjectDefault(This,pbstr_ObjectDefault)

#define IButton_put__ObjectDefault(This,pbstr_ObjectDefault)	\
    (This)->lpVtbl -> put__ObjectDefault(This,pbstr_ObjectDefault)

#define IButton_get_Caption(This,pbstrCaption)	\
    (This)->lpVtbl -> get_Caption(This,pbstrCaption)

#define IButton_put_Caption(This,pbstrCaption)	\
    (This)->lpVtbl -> put_Caption(This,pbstrCaption)

#define IButton_get_Tag(This,pvTag)	\
    (This)->lpVtbl -> get_Tag(This,pvTag)

#define IButton_put_Tag(This,pvTag)	\
    (This)->lpVtbl -> put_Tag(This,pvTag)

#define IButton_get_Enabled(This,pbEnabled)	\
    (This)->lpVtbl -> get_Enabled(This,pbEnabled)

#define IButton_put_Enabled(This,pbEnabled)	\
    (This)->lpVtbl -> put_Enabled(This,pbEnabled)

#define IButton_get_Index(This,psIndex)	\
    (This)->lpVtbl -> get_Index(This,psIndex)

#define IButton_put_Index(This,psIndex)	\
    (This)->lpVtbl -> put_Index(This,psIndex)

#define IButton_get_Key(This,pbstrKey)	\
    (This)->lpVtbl -> get_Key(This,pbstrKey)

#define IButton_put_Key(This,pbstrKey)	\
    (This)->lpVtbl -> put_Key(This,pbstrKey)

#define IButton_get_ToolTipText(This,pbstrToolTipText)	\
    (This)->lpVtbl -> get_ToolTipText(This,pbstrToolTipText)

#define IButton_put_ToolTipText(This,pbstrToolTipText)	\
    (This)->lpVtbl -> put_ToolTipText(This,pbstrToolTipText)

#define IButton_get_Visible(This,pbVisible)	\
    (This)->lpVtbl -> get_Visible(This,pbVisible)

#define IButton_put_Visible(This,pbVisible)	\
    (This)->lpVtbl -> put_Visible(This,pbVisible)

#define IButton_get_Width(This,pfWidth)	\
    (This)->lpVtbl -> get_Width(This,pfWidth)

#define IButton_put_Width(This,pfWidth)	\
    (This)->lpVtbl -> put_Width(This,pfWidth)

#define IButton_get_Height(This,pfHeight)	\
    (This)->lpVtbl -> get_Height(This,pfHeight)

#define IButton_put_Height(This,pfHeight)	\
    (This)->lpVtbl -> put_Height(This,pfHeight)

#define IButton_get_Top(This,pfTop)	\
    (This)->lpVtbl -> get_Top(This,pfTop)

#define IButton_put_Top(This,pfTop)	\
    (This)->lpVtbl -> put_Top(This,pfTop)

#define IButton_get_Left(This,pfLeft)	\
    (This)->lpVtbl -> get_Left(This,pfLeft)

#define IButton_put_Left(This,pfLeft)	\
    (This)->lpVtbl -> put_Left(This,pfLeft)

#define IButton_get_Value(This,psValue)	\
    (This)->lpVtbl -> get_Value(This,psValue)

#define IButton_put_Value(This,psValue)	\
    (This)->lpVtbl -> put_Value(This,psValue)

#define IButton_get_Style(This,psStyle)	\
    (This)->lpVtbl -> get_Style(This,psStyle)

#define IButton_put_Style(This,psStyle)	\
    (This)->lpVtbl -> put_Style(This,psStyle)

#define IButton_get_Description(This,pbstrDescription)	\
    (This)->lpVtbl -> get_Description(This,pbstrDescription)

#define IButton_put_Description(This,pbstrDescription)	\
    (This)->lpVtbl -> put_Description(This,pbstrDescription)

#define IButton_get_Image(This,pvImage)	\
    (This)->lpVtbl -> get_Image(This,pvImage)

#define IButton_put_Image(This,pvImage)	\
    (This)->lpVtbl -> put_Image(This,pvImage)

#define IButton_get_MixedState(This,pbMixedState)	\
    (This)->lpVtbl -> get_MixedState(This,pbMixedState)

#define IButton_put_MixedState(This,pbMixedState)	\
    (This)->lpVtbl -> put_MixedState(This,pbMixedState)

#define IButton_get_ButtonMenus(This,ppButtonMenus)	\
    (This)->lpVtbl -> get_ButtonMenus(This,ppButtonMenus)

#define IButton_putref_ButtonMenus(This,ppButtonMenus)	\
    (This)->lpVtbl -> putref_ButtonMenus(This,ppButtonMenus)

#define IButton_putref_Tag(This,pvTag)	\
    (This)->lpVtbl -> putref_Tag(This,pvTag)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [hidden][propget][id] */ HRESULT STDMETHODCALLTYPE IButton_get__ObjectDefault_Proxy( 
    IButton * This,
    /* [retval][out] */ BSTR *pbstr_ObjectDefault);


void __RPC_STUB IButton_get__ObjectDefault_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [hidden][propput][id] */ HRESULT STDMETHODCALLTYPE IButton_put__ObjectDefault_Proxy( 
    IButton * This,
    /* [in] */ BSTR pbstr_ObjectDefault);


void __RPC_STUB IButton_put__ObjectDefault_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IButton_get_Caption_Proxy( 
    IButton * This,
    /* [retval][out] */ BSTR *pbstrCaption);


void __RPC_STUB IButton_get_Caption_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE IButton_put_Caption_Proxy( 
    IButton * This,
    /* [in] */ BSTR pbstrCaption);


void __RPC_STUB IButton_put_Caption_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IButton_get_Tag_Proxy( 
    IButton * This,
    /* [retval][out] */ VARIANT *pvTag);


void __RPC_STUB IButton_get_Tag_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE IButton_put_Tag_Proxy( 
    IButton * This,
    /* [in] */ VARIANT pvTag);


void __RPC_STUB IButton_put_Tag_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IButton_get_Enabled_Proxy( 
    IButton * This,
    /* [retval][out] */ VARIANT_BOOL *pbEnabled);


void __RPC_STUB IButton_get_Enabled_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE IButton_put_Enabled_Proxy( 
    IButton * This,
    /* [in] */ VARIANT_BOOL pbEnabled);


void __RPC_STUB IButton_put_Enabled_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IButton_get_Index_Proxy( 
    IButton * This,
    /* [retval][out] */ short *psIndex);


void __RPC_STUB IButton_get_Index_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE IButton_put_Index_Proxy( 
    IButton * This,
    /* [in] */ short psIndex);


void __RPC_STUB IButton_put_Index_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IButton_get_Key_Proxy( 
    IButton * This,
    /* [retval][out] */ BSTR *pbstrKey);


void __RPC_STUB IButton_get_Key_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE IButton_put_Key_Proxy( 
    IButton * This,
    /* [in] */ BSTR pbstrKey);


void __RPC_STUB IButton_put_Key_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IButton_get_ToolTipText_Proxy( 
    IButton * This,
    /* [retval][out] */ BSTR *pbstrToolTipText);


void __RPC_STUB IButton_get_ToolTipText_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE IButton_put_ToolTipText_Proxy( 
    IButton * This,
    /* [in] */ BSTR pbstrToolTipText);


void __RPC_STUB IButton_put_ToolTipText_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IButton_get_Visible_Proxy( 
    IButton * This,
    /* [retval][out] */ VARIANT_BOOL *pbVisible);


void __RPC_STUB IButton_get_Visible_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE IButton_put_Visible_Proxy( 
    IButton * This,
    /* [in] */ VARIANT_BOOL pbVisible);


void __RPC_STUB IButton_put_Visible_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IButton_get_Width_Proxy( 
    IButton * This,
    /* [retval][out] */ single *pfWidth);


void __RPC_STUB IButton_get_Width_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE IButton_put_Width_Proxy( 
    IButton * This,
    /* [in] */ single pfWidth);


void __RPC_STUB IButton_put_Width_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IButton_get_Height_Proxy( 
    IButton * This,
    /* [retval][out] */ single *pfHeight);


void __RPC_STUB IButton_get_Height_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE IButton_put_Height_Proxy( 
    IButton * This,
    /* [in] */ single pfHeight);


void __RPC_STUB IButton_put_Height_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IButton_get_Top_Proxy( 
    IButton * This,
    /* [retval][out] */ single *pfTop);


void __RPC_STUB IButton_get_Top_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE IButton_put_Top_Proxy( 
    IButton * This,
    /* [in] */ single pfTop);


void __RPC_STUB IButton_put_Top_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IButton_get_Left_Proxy( 
    IButton * This,
    /* [retval][out] */ single *pfLeft);


void __RPC_STUB IButton_get_Left_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE IButton_put_Left_Proxy( 
    IButton * This,
    /* [in] */ single pfLeft);


void __RPC_STUB IButton_put_Left_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IButton_get_Value_Proxy( 
    IButton * This,
    /* [retval][out] */ ValueConstants *psValue);


void __RPC_STUB IButton_get_Value_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE IButton_put_Value_Proxy( 
    IButton * This,
    /* [in] */ ValueConstants psValue);


void __RPC_STUB IButton_put_Value_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IButton_get_Style_Proxy( 
    IButton * This,
    /* [retval][out] */ ButtonStyleConstants *psStyle);


void __RPC_STUB IButton_get_Style_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE IButton_put_Style_Proxy( 
    IButton * This,
    /* [in] */ ButtonStyleConstants psStyle);


void __RPC_STUB IButton_put_Style_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IButton_get_Description_Proxy( 
    IButton * This,
    /* [retval][out] */ BSTR *pbstrDescription);


void __RPC_STUB IButton_get_Description_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE IButton_put_Description_Proxy( 
    IButton * This,
    /* [in] */ BSTR pbstrDescription);


void __RPC_STUB IButton_put_Description_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IButton_get_Image_Proxy( 
    IButton * This,
    /* [retval][out] */ VARIANT *pvImage);


void __RPC_STUB IButton_get_Image_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE IButton_put_Image_Proxy( 
    IButton * This,
    /* [in] */ VARIANT pvImage);


void __RPC_STUB IButton_put_Image_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IButton_get_MixedState_Proxy( 
    IButton * This,
    /* [retval][out] */ VARIANT_BOOL *pbMixedState);


void __RPC_STUB IButton_get_MixedState_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE IButton_put_MixedState_Proxy( 
    IButton * This,
    /* [in] */ VARIANT_BOOL pbMixedState);


void __RPC_STUB IButton_put_MixedState_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IButton_get_ButtonMenus_Proxy( 
    IButton * This,
    /* [retval][out] */ IButtonMenus **ppButtonMenus);


void __RPC_STUB IButton_get_ButtonMenus_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propputref][id] */ HRESULT STDMETHODCALLTYPE IButton_putref_ButtonMenus_Proxy( 
    IButton * This,
    /* [in] */ IButtonMenus *ppButtonMenus);


void __RPC_STUB IButton_putref_ButtonMenus_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propputref][id] */ HRESULT STDMETHODCALLTYPE IButton_putref_Tag_Proxy( 
    IButton * This,
    /* [in] */ VARIANT pvTag);


void __RPC_STUB IButton_putref_Tag_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IButton_INTERFACE_DEFINED__ */


#ifndef __IButtonMenus_INTERFACE_DEFINED__
#define __IButtonMenus_INTERFACE_DEFINED__

/* interface IButtonMenus */
/* [object][oleautomation][nonextensible][dual][helpcontext][helpstring][uuid] */ 


EXTERN_C const IID IID_IButtonMenus;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("66833FEB-8583-11D1-B16A-00C0F0283628")
    IButtonMenus : public IDispatch
    {
    public:
        virtual /* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_Count( 
            /* [retval][out] */ short *psCount) = 0;
        
        virtual /* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_Count( 
            /* [in] */ short psCount) = 0;
        
        virtual /* [hidden][propget][id] */ HRESULT STDMETHODCALLTYPE get_ControlDefault( 
            /* [in] */ VARIANT *Index,
            /* [retval][out] */ IButtonMenu **ppButtonMenu) = 0;
        
        virtual /* [hidden][propputref][id] */ HRESULT STDMETHODCALLTYPE putref_ControlDefault( 
            /* [in] */ VARIANT *Index,
            /* [in] */ IButtonMenu *ppButtonMenu) = 0;
        
        virtual /* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_Item( 
            /* [in] */ VARIANT *Index,
            /* [retval][out] */ IButtonMenu **ppButtonMenu) = 0;
        
        virtual /* [helpcontext][helpstring][propputref][id] */ HRESULT STDMETHODCALLTYPE putref_Item( 
            /* [in] */ VARIANT *Index,
            /* [in] */ IButtonMenu *ppButtonMenu) = 0;
        
        virtual /* [helpcontext][helpstring][id] */ HRESULT STDMETHODCALLTYPE Remove( 
            /* [in] */ VARIANT *Index) = 0;
        
        virtual /* [helpcontext][helpstring][id] */ HRESULT STDMETHODCALLTYPE Clear( void) = 0;
        
        virtual /* [helpcontext][helpstring][id] */ HRESULT STDMETHODCALLTYPE Add( 
            /* [optional][in] */ VARIANT *Index,
            /* [optional][in] */ VARIANT *Key,
            /* [optional][in] */ VARIANT *Text,
            /* [retval][out] */ IButtonMenu **ppButtonMenu) = 0;
        
        virtual /* [hidden][id] */ HRESULT STDMETHODCALLTYPE _NewEnum( 
            /* [retval][out] */ IDispatch **ppDispatch) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IButtonMenusVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IButtonMenus * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IButtonMenus * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IButtonMenus * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IButtonMenus * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IButtonMenus * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IButtonMenus * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IButtonMenus * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_Count )( 
            IButtonMenus * This,
            /* [retval][out] */ short *psCount);
        
        /* [helpcontext][helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_Count )( 
            IButtonMenus * This,
            /* [in] */ short psCount);
        
        /* [hidden][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_ControlDefault )( 
            IButtonMenus * This,
            /* [in] */ VARIANT *Index,
            /* [retval][out] */ IButtonMenu **ppButtonMenu);
        
        /* [hidden][propputref][id] */ HRESULT ( STDMETHODCALLTYPE *putref_ControlDefault )( 
            IButtonMenus * This,
            /* [in] */ VARIANT *Index,
            /* [in] */ IButtonMenu *ppButtonMenu);
        
        /* [helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_Item )( 
            IButtonMenus * This,
            /* [in] */ VARIANT *Index,
            /* [retval][out] */ IButtonMenu **ppButtonMenu);
        
        /* [helpcontext][helpstring][propputref][id] */ HRESULT ( STDMETHODCALLTYPE *putref_Item )( 
            IButtonMenus * This,
            /* [in] */ VARIANT *Index,
            /* [in] */ IButtonMenu *ppButtonMenu);
        
        /* [helpcontext][helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Remove )( 
            IButtonMenus * This,
            /* [in] */ VARIANT *Index);
        
        /* [helpcontext][helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Clear )( 
            IButtonMenus * This);
        
        /* [helpcontext][helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Add )( 
            IButtonMenus * This,
            /* [optional][in] */ VARIANT *Index,
            /* [optional][in] */ VARIANT *Key,
            /* [optional][in] */ VARIANT *Text,
            /* [retval][out] */ IButtonMenu **ppButtonMenu);
        
        /* [hidden][id] */ HRESULT ( STDMETHODCALLTYPE *_NewEnum )( 
            IButtonMenus * This,
            /* [retval][out] */ IDispatch **ppDispatch);
        
        END_INTERFACE
    } IButtonMenusVtbl;

    interface IButtonMenus
    {
        CONST_VTBL struct IButtonMenusVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IButtonMenus_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IButtonMenus_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IButtonMenus_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IButtonMenus_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IButtonMenus_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IButtonMenus_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IButtonMenus_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IButtonMenus_get_Count(This,psCount)	\
    (This)->lpVtbl -> get_Count(This,psCount)

#define IButtonMenus_put_Count(This,psCount)	\
    (This)->lpVtbl -> put_Count(This,psCount)

#define IButtonMenus_get_ControlDefault(This,Index,ppButtonMenu)	\
    (This)->lpVtbl -> get_ControlDefault(This,Index,ppButtonMenu)

#define IButtonMenus_putref_ControlDefault(This,Index,ppButtonMenu)	\
    (This)->lpVtbl -> putref_ControlDefault(This,Index,ppButtonMenu)

#define IButtonMenus_get_Item(This,Index,ppButtonMenu)	\
    (This)->lpVtbl -> get_Item(This,Index,ppButtonMenu)

#define IButtonMenus_putref_Item(This,Index,ppButtonMenu)	\
    (This)->lpVtbl -> putref_Item(This,Index,ppButtonMenu)

#define IButtonMenus_Remove(This,Index)	\
    (This)->lpVtbl -> Remove(This,Index)

#define IButtonMenus_Clear(This)	\
    (This)->lpVtbl -> Clear(This)

#define IButtonMenus_Add(This,Index,Key,Text,ppButtonMenu)	\
    (This)->lpVtbl -> Add(This,Index,Key,Text,ppButtonMenu)

#define IButtonMenus__NewEnum(This,ppDispatch)	\
    (This)->lpVtbl -> _NewEnum(This,ppDispatch)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IButtonMenus_get_Count_Proxy( 
    IButtonMenus * This,
    /* [retval][out] */ short *psCount);


void __RPC_STUB IButtonMenus_get_Count_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE IButtonMenus_put_Count_Proxy( 
    IButtonMenus * This,
    /* [in] */ short psCount);


void __RPC_STUB IButtonMenus_put_Count_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [hidden][propget][id] */ HRESULT STDMETHODCALLTYPE IButtonMenus_get_ControlDefault_Proxy( 
    IButtonMenus * This,
    /* [in] */ VARIANT *Index,
    /* [retval][out] */ IButtonMenu **ppButtonMenu);


void __RPC_STUB IButtonMenus_get_ControlDefault_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [hidden][propputref][id] */ HRESULT STDMETHODCALLTYPE IButtonMenus_putref_ControlDefault_Proxy( 
    IButtonMenus * This,
    /* [in] */ VARIANT *Index,
    /* [in] */ IButtonMenu *ppButtonMenu);


void __RPC_STUB IButtonMenus_putref_ControlDefault_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IButtonMenus_get_Item_Proxy( 
    IButtonMenus * This,
    /* [in] */ VARIANT *Index,
    /* [retval][out] */ IButtonMenu **ppButtonMenu);


void __RPC_STUB IButtonMenus_get_Item_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propputref][id] */ HRESULT STDMETHODCALLTYPE IButtonMenus_putref_Item_Proxy( 
    IButtonMenus * This,
    /* [in] */ VARIANT *Index,
    /* [in] */ IButtonMenu *ppButtonMenu);


void __RPC_STUB IButtonMenus_putref_Item_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][id] */ HRESULT STDMETHODCALLTYPE IButtonMenus_Remove_Proxy( 
    IButtonMenus * This,
    /* [in] */ VARIANT *Index);


void __RPC_STUB IButtonMenus_Remove_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][id] */ HRESULT STDMETHODCALLTYPE IButtonMenus_Clear_Proxy( 
    IButtonMenus * This);


void __RPC_STUB IButtonMenus_Clear_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][id] */ HRESULT STDMETHODCALLTYPE IButtonMenus_Add_Proxy( 
    IButtonMenus * This,
    /* [optional][in] */ VARIANT *Index,
    /* [optional][in] */ VARIANT *Key,
    /* [optional][in] */ VARIANT *Text,
    /* [retval][out] */ IButtonMenu **ppButtonMenu);


void __RPC_STUB IButtonMenus_Add_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [hidden][id] */ HRESULT STDMETHODCALLTYPE IButtonMenus__NewEnum_Proxy( 
    IButtonMenus * This,
    /* [retval][out] */ IDispatch **ppDispatch);


void __RPC_STUB IButtonMenus__NewEnum_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IButtonMenus_INTERFACE_DEFINED__ */


#ifndef __IButtonMenu_INTERFACE_DEFINED__
#define __IButtonMenu_INTERFACE_DEFINED__

/* interface IButtonMenu */
/* [object][oleautomation][nonextensible][dual][helpcontext][helpstring][uuid] */ 


EXTERN_C const IID IID_IButtonMenu;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("66833FED-8583-11D1-B16A-00C0F0283628")
    IButtonMenu : public IDispatch
    {
    public:
        virtual /* [hidden][propget][id] */ HRESULT STDMETHODCALLTYPE get__ObjectDefault( 
            /* [retval][out] */ BSTR *pbstrObjectDefault) = 0;
        
        virtual /* [hidden][propput][id] */ HRESULT STDMETHODCALLTYPE put__ObjectDefault( 
            /* [in] */ BSTR pbstrObjectDefault) = 0;
        
        virtual /* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_Enabled( 
            /* [retval][out] */ VARIANT_BOOL *pbEnabled) = 0;
        
        virtual /* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_Enabled( 
            /* [in] */ VARIANT_BOOL pbEnabled) = 0;
        
        virtual /* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_Index( 
            /* [retval][out] */ short *psIndex) = 0;
        
        virtual /* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_Index( 
            /* [in] */ short psIndex) = 0;
        
        virtual /* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_Key( 
            /* [retval][out] */ BSTR *pbstrKey) = 0;
        
        virtual /* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_Key( 
            /* [in] */ BSTR pbstrKey) = 0;
        
        virtual /* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_Parent( 
            /* [retval][out] */ IButton **ppParent) = 0;
        
        virtual /* [helpcontext][helpstring][propputref][id] */ HRESULT STDMETHODCALLTYPE putref_Parent( 
            /* [in] */ IButton *ppParent) = 0;
        
        virtual /* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_Tag( 
            /* [retval][out] */ VARIANT *pvTag) = 0;
        
        virtual /* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_Tag( 
            /* [in] */ VARIANT pvTag) = 0;
        
        virtual /* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_Text( 
            /* [retval][out] */ BSTR *pbstrText) = 0;
        
        virtual /* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_Text( 
            /* [in] */ BSTR pbstrText) = 0;
        
        virtual /* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_Visible( 
            /* [retval][out] */ VARIANT_BOOL *pbVisible) = 0;
        
        virtual /* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_Visible( 
            /* [in] */ VARIANT_BOOL pbVisible) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IButtonMenuVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IButtonMenu * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IButtonMenu * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IButtonMenu * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IButtonMenu * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IButtonMenu * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IButtonMenu * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IButtonMenu * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [hidden][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get__ObjectDefault )( 
            IButtonMenu * This,
            /* [retval][out] */ BSTR *pbstrObjectDefault);
        
        /* [hidden][propput][id] */ HRESULT ( STDMETHODCALLTYPE *put__ObjectDefault )( 
            IButtonMenu * This,
            /* [in] */ BSTR pbstrObjectDefault);
        
        /* [helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_Enabled )( 
            IButtonMenu * This,
            /* [retval][out] */ VARIANT_BOOL *pbEnabled);
        
        /* [helpcontext][helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_Enabled )( 
            IButtonMenu * This,
            /* [in] */ VARIANT_BOOL pbEnabled);
        
        /* [helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_Index )( 
            IButtonMenu * This,
            /* [retval][out] */ short *psIndex);
        
        /* [helpcontext][helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_Index )( 
            IButtonMenu * This,
            /* [in] */ short psIndex);
        
        /* [helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_Key )( 
            IButtonMenu * This,
            /* [retval][out] */ BSTR *pbstrKey);
        
        /* [helpcontext][helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_Key )( 
            IButtonMenu * This,
            /* [in] */ BSTR pbstrKey);
        
        /* [helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_Parent )( 
            IButtonMenu * This,
            /* [retval][out] */ IButton **ppParent);
        
        /* [helpcontext][helpstring][propputref][id] */ HRESULT ( STDMETHODCALLTYPE *putref_Parent )( 
            IButtonMenu * This,
            /* [in] */ IButton *ppParent);
        
        /* [helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_Tag )( 
            IButtonMenu * This,
            /* [retval][out] */ VARIANT *pvTag);
        
        /* [helpcontext][helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_Tag )( 
            IButtonMenu * This,
            /* [in] */ VARIANT pvTag);
        
        /* [helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_Text )( 
            IButtonMenu * This,
            /* [retval][out] */ BSTR *pbstrText);
        
        /* [helpcontext][helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_Text )( 
            IButtonMenu * This,
            /* [in] */ BSTR pbstrText);
        
        /* [helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_Visible )( 
            IButtonMenu * This,
            /* [retval][out] */ VARIANT_BOOL *pbVisible);
        
        /* [helpcontext][helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_Visible )( 
            IButtonMenu * This,
            /* [in] */ VARIANT_BOOL pbVisible);
        
        END_INTERFACE
    } IButtonMenuVtbl;

    interface IButtonMenu
    {
        CONST_VTBL struct IButtonMenuVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IButtonMenu_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IButtonMenu_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IButtonMenu_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IButtonMenu_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IButtonMenu_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IButtonMenu_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IButtonMenu_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IButtonMenu_get__ObjectDefault(This,pbstrObjectDefault)	\
    (This)->lpVtbl -> get__ObjectDefault(This,pbstrObjectDefault)

#define IButtonMenu_put__ObjectDefault(This,pbstrObjectDefault)	\
    (This)->lpVtbl -> put__ObjectDefault(This,pbstrObjectDefault)

#define IButtonMenu_get_Enabled(This,pbEnabled)	\
    (This)->lpVtbl -> get_Enabled(This,pbEnabled)

#define IButtonMenu_put_Enabled(This,pbEnabled)	\
    (This)->lpVtbl -> put_Enabled(This,pbEnabled)

#define IButtonMenu_get_Index(This,psIndex)	\
    (This)->lpVtbl -> get_Index(This,psIndex)

#define IButtonMenu_put_Index(This,psIndex)	\
    (This)->lpVtbl -> put_Index(This,psIndex)

#define IButtonMenu_get_Key(This,pbstrKey)	\
    (This)->lpVtbl -> get_Key(This,pbstrKey)

#define IButtonMenu_put_Key(This,pbstrKey)	\
    (This)->lpVtbl -> put_Key(This,pbstrKey)

#define IButtonMenu_get_Parent(This,ppParent)	\
    (This)->lpVtbl -> get_Parent(This,ppParent)

#define IButtonMenu_putref_Parent(This,ppParent)	\
    (This)->lpVtbl -> putref_Parent(This,ppParent)

#define IButtonMenu_get_Tag(This,pvTag)	\
    (This)->lpVtbl -> get_Tag(This,pvTag)

#define IButtonMenu_put_Tag(This,pvTag)	\
    (This)->lpVtbl -> put_Tag(This,pvTag)

#define IButtonMenu_get_Text(This,pbstrText)	\
    (This)->lpVtbl -> get_Text(This,pbstrText)

#define IButtonMenu_put_Text(This,pbstrText)	\
    (This)->lpVtbl -> put_Text(This,pbstrText)

#define IButtonMenu_get_Visible(This,pbVisible)	\
    (This)->lpVtbl -> get_Visible(This,pbVisible)

#define IButtonMenu_put_Visible(This,pbVisible)	\
    (This)->lpVtbl -> put_Visible(This,pbVisible)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [hidden][propget][id] */ HRESULT STDMETHODCALLTYPE IButtonMenu_get__ObjectDefault_Proxy( 
    IButtonMenu * This,
    /* [retval][out] */ BSTR *pbstrObjectDefault);


void __RPC_STUB IButtonMenu_get__ObjectDefault_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [hidden][propput][id] */ HRESULT STDMETHODCALLTYPE IButtonMenu_put__ObjectDefault_Proxy( 
    IButtonMenu * This,
    /* [in] */ BSTR pbstrObjectDefault);


void __RPC_STUB IButtonMenu_put__ObjectDefault_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IButtonMenu_get_Enabled_Proxy( 
    IButtonMenu * This,
    /* [retval][out] */ VARIANT_BOOL *pbEnabled);


void __RPC_STUB IButtonMenu_get_Enabled_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE IButtonMenu_put_Enabled_Proxy( 
    IButtonMenu * This,
    /* [in] */ VARIANT_BOOL pbEnabled);


void __RPC_STUB IButtonMenu_put_Enabled_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IButtonMenu_get_Index_Proxy( 
    IButtonMenu * This,
    /* [retval][out] */ short *psIndex);


void __RPC_STUB IButtonMenu_get_Index_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE IButtonMenu_put_Index_Proxy( 
    IButtonMenu * This,
    /* [in] */ short psIndex);


void __RPC_STUB IButtonMenu_put_Index_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IButtonMenu_get_Key_Proxy( 
    IButtonMenu * This,
    /* [retval][out] */ BSTR *pbstrKey);


void __RPC_STUB IButtonMenu_get_Key_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE IButtonMenu_put_Key_Proxy( 
    IButtonMenu * This,
    /* [in] */ BSTR pbstrKey);


void __RPC_STUB IButtonMenu_put_Key_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IButtonMenu_get_Parent_Proxy( 
    IButtonMenu * This,
    /* [retval][out] */ IButton **ppParent);


void __RPC_STUB IButtonMenu_get_Parent_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propputref][id] */ HRESULT STDMETHODCALLTYPE IButtonMenu_putref_Parent_Proxy( 
    IButtonMenu * This,
    /* [in] */ IButton *ppParent);


void __RPC_STUB IButtonMenu_putref_Parent_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IButtonMenu_get_Tag_Proxy( 
    IButtonMenu * This,
    /* [retval][out] */ VARIANT *pvTag);


void __RPC_STUB IButtonMenu_get_Tag_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE IButtonMenu_put_Tag_Proxy( 
    IButtonMenu * This,
    /* [in] */ VARIANT pvTag);


void __RPC_STUB IButtonMenu_put_Tag_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IButtonMenu_get_Text_Proxy( 
    IButtonMenu * This,
    /* [retval][out] */ BSTR *pbstrText);


void __RPC_STUB IButtonMenu_get_Text_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE IButtonMenu_put_Text_Proxy( 
    IButtonMenu * This,
    /* [in] */ BSTR pbstrText);


void __RPC_STUB IButtonMenu_put_Text_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IButtonMenu_get_Visible_Proxy( 
    IButtonMenu * This,
    /* [retval][out] */ VARIANT_BOOL *pbVisible);


void __RPC_STUB IButtonMenu_get_Visible_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE IButtonMenu_put_Visible_Proxy( 
    IButtonMenu * This,
    /* [in] */ VARIANT_BOOL pbVisible);


void __RPC_STUB IButtonMenu_put_Visible_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IButtonMenu_INTERFACE_DEFINED__ */


#ifndef __IStatusBar_INTERFACE_DEFINED__
#define __IStatusBar_INTERFACE_DEFINED__

/* interface IStatusBar */
/* [object][oleautomation][nonextensible][dual][hidden][helpcontext][helpstring][uuid] */ 


EXTERN_C const IID IID_IStatusBar;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("8E3867A1-8586-11D1-B16A-00C0F0283628")
    IStatusBar : public IDispatch
    {
    public:
        virtual /* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_SimpleText( 
            /* [retval][out] */ BSTR *pbstrSimpleText) = 0;
        
        virtual /* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_SimpleText( 
            /* [in] */ BSTR pbstrSimpleText) = 0;
        
        virtual /* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_Style( 
            /* [retval][out] */ SbarStyleConstants *psStyle) = 0;
        
        virtual /* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_Style( 
            /* [in] */ SbarStyleConstants psStyle) = 0;
        
        virtual /* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_Panels( 
            /* [retval][out] */ IPanels **ppPanels) = 0;
        
        virtual /* [helpcontext][helpstring][propputref][id] */ HRESULT STDMETHODCALLTYPE putref_Panels( 
            /* [in] */ IPanels *ppPanels) = 0;
        
        virtual /* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_MousePointer( 
            /* [retval][out] */ MousePointerConstants *psMousePointer) = 0;
        
        virtual /* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_MousePointer( 
            /* [in] */ MousePointerConstants psMousePointer) = 0;
        
        virtual /* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_MouseIcon( 
            /* [retval][out] */ /* external definition not present */ IPictureDisp **ppMouseIcon) = 0;
        
        virtual /* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_MouseIcon( 
            /* [in] */ /* external definition not present */ IPictureDisp *ppMouseIcon) = 0;
        
        virtual /* [helpcontext][helpstring][propputref][id] */ HRESULT STDMETHODCALLTYPE putref_MouseIcon( 
            /* [in] */ /* external definition not present */ IPictureDisp *ppMouseIcon) = 0;
        
        virtual /* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_ShowTips( 
            /* [retval][out] */ VARIANT_BOOL *bShowTips) = 0;
        
        virtual /* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_ShowTips( 
            /* [in] */ VARIANT_BOOL bShowTips) = 0;
        
        virtual /* [helpcontext][helpstring][hidden][propget][id] */ HRESULT STDMETHODCALLTYPE get_PanelProperties( 
            /* [retval][out] */ BSTR *pbstrPanelProperties) = 0;
        
        virtual /* [helpcontext][helpstring][hidden][propput][id] */ HRESULT STDMETHODCALLTYPE put_PanelProperties( 
            /* [in] */ BSTR pbstrPanelProperties) = 0;
        
        virtual /* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_OLEDropMode( 
            /* [retval][out] */ OLEDropConstants *psOLEDropMode) = 0;
        
        virtual /* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_OLEDropMode( 
            /* [in] */ OLEDropConstants psOLEDropMode) = 0;
        
        virtual /* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_Enabled( 
            /* [retval][out] */ VARIANT_BOOL *pbEnabled) = 0;
        
        virtual /* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_Enabled( 
            /* [in] */ VARIANT_BOOL pbEnabled) = 0;
        
        virtual /* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_Font( 
            /* [retval][out] */ /* external definition not present */ IFontDisp **ppFont) = 0;
        
        virtual /* [helpcontext][helpstring][propputref][id] */ HRESULT STDMETHODCALLTYPE putref_Font( 
            /* [in] */ /* external definition not present */ IFontDisp *ppFont) = 0;
        
        virtual /* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_hWnd( 
            /* [retval][out] */ /* external definition not present */ OLE_HANDLE *phWnd) = 0;
        
        virtual /* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_hWnd( 
            /* [in] */ /* external definition not present */ OLE_HANDLE phWnd) = 0;
        
        virtual /* [helpcontext][helpstring][id] */ HRESULT STDMETHODCALLTYPE Refresh( void) = 0;
        
        virtual /* [helpcontext][helpstring][id] */ HRESULT STDMETHODCALLTYPE OLEDrag( void) = 0;
        
        virtual /* [hidden][id] */ HRESULT STDMETHODCALLTYPE AboutBox( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IStatusBarVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IStatusBar * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IStatusBar * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IStatusBar * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IStatusBar * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IStatusBar * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IStatusBar * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IStatusBar * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_SimpleText )( 
            IStatusBar * This,
            /* [retval][out] */ BSTR *pbstrSimpleText);
        
        /* [helpcontext][helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_SimpleText )( 
            IStatusBar * This,
            /* [in] */ BSTR pbstrSimpleText);
        
        /* [helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_Style )( 
            IStatusBar * This,
            /* [retval][out] */ SbarStyleConstants *psStyle);
        
        /* [helpcontext][helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_Style )( 
            IStatusBar * This,
            /* [in] */ SbarStyleConstants psStyle);
        
        /* [helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_Panels )( 
            IStatusBar * This,
            /* [retval][out] */ IPanels **ppPanels);
        
        /* [helpcontext][helpstring][propputref][id] */ HRESULT ( STDMETHODCALLTYPE *putref_Panels )( 
            IStatusBar * This,
            /* [in] */ IPanels *ppPanels);
        
        /* [helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_MousePointer )( 
            IStatusBar * This,
            /* [retval][out] */ MousePointerConstants *psMousePointer);
        
        /* [helpcontext][helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_MousePointer )( 
            IStatusBar * This,
            /* [in] */ MousePointerConstants psMousePointer);
        
        /* [helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_MouseIcon )( 
            IStatusBar * This,
            /* [retval][out] */ /* external definition not present */ IPictureDisp **ppMouseIcon);
        
        /* [helpcontext][helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_MouseIcon )( 
            IStatusBar * This,
            /* [in] */ /* external definition not present */ IPictureDisp *ppMouseIcon);
        
        /* [helpcontext][helpstring][propputref][id] */ HRESULT ( STDMETHODCALLTYPE *putref_MouseIcon )( 
            IStatusBar * This,
            /* [in] */ /* external definition not present */ IPictureDisp *ppMouseIcon);
        
        /* [helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_ShowTips )( 
            IStatusBar * This,
            /* [retval][out] */ VARIANT_BOOL *bShowTips);
        
        /* [helpcontext][helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_ShowTips )( 
            IStatusBar * This,
            /* [in] */ VARIANT_BOOL bShowTips);
        
        /* [helpcontext][helpstring][hidden][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_PanelProperties )( 
            IStatusBar * This,
            /* [retval][out] */ BSTR *pbstrPanelProperties);
        
        /* [helpcontext][helpstring][hidden][propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_PanelProperties )( 
            IStatusBar * This,
            /* [in] */ BSTR pbstrPanelProperties);
        
        /* [helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_OLEDropMode )( 
            IStatusBar * This,
            /* [retval][out] */ OLEDropConstants *psOLEDropMode);
        
        /* [helpcontext][helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_OLEDropMode )( 
            IStatusBar * This,
            /* [in] */ OLEDropConstants psOLEDropMode);
        
        /* [helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_Enabled )( 
            IStatusBar * This,
            /* [retval][out] */ VARIANT_BOOL *pbEnabled);
        
        /* [helpcontext][helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_Enabled )( 
            IStatusBar * This,
            /* [in] */ VARIANT_BOOL pbEnabled);
        
        /* [helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_Font )( 
            IStatusBar * This,
            /* [retval][out] */ /* external definition not present */ IFontDisp **ppFont);
        
        /* [helpcontext][helpstring][propputref][id] */ HRESULT ( STDMETHODCALLTYPE *putref_Font )( 
            IStatusBar * This,
            /* [in] */ /* external definition not present */ IFontDisp *ppFont);
        
        /* [helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_hWnd )( 
            IStatusBar * This,
            /* [retval][out] */ /* external definition not present */ OLE_HANDLE *phWnd);
        
        /* [helpcontext][helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_hWnd )( 
            IStatusBar * This,
            /* [in] */ /* external definition not present */ OLE_HANDLE phWnd);
        
        /* [helpcontext][helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Refresh )( 
            IStatusBar * This);
        
        /* [helpcontext][helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *OLEDrag )( 
            IStatusBar * This);
        
        /* [hidden][id] */ HRESULT ( STDMETHODCALLTYPE *AboutBox )( 
            IStatusBar * This);
        
        END_INTERFACE
    } IStatusBarVtbl;

    interface IStatusBar
    {
        CONST_VTBL struct IStatusBarVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IStatusBar_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IStatusBar_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IStatusBar_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IStatusBar_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IStatusBar_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IStatusBar_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IStatusBar_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IStatusBar_get_SimpleText(This,pbstrSimpleText)	\
    (This)->lpVtbl -> get_SimpleText(This,pbstrSimpleText)

#define IStatusBar_put_SimpleText(This,pbstrSimpleText)	\
    (This)->lpVtbl -> put_SimpleText(This,pbstrSimpleText)

#define IStatusBar_get_Style(This,psStyle)	\
    (This)->lpVtbl -> get_Style(This,psStyle)

#define IStatusBar_put_Style(This,psStyle)	\
    (This)->lpVtbl -> put_Style(This,psStyle)

#define IStatusBar_get_Panels(This,ppPanels)	\
    (This)->lpVtbl -> get_Panels(This,ppPanels)

#define IStatusBar_putref_Panels(This,ppPanels)	\
    (This)->lpVtbl -> putref_Panels(This,ppPanels)

#define IStatusBar_get_MousePointer(This,psMousePointer)	\
    (This)->lpVtbl -> get_MousePointer(This,psMousePointer)

#define IStatusBar_put_MousePointer(This,psMousePointer)	\
    (This)->lpVtbl -> put_MousePointer(This,psMousePointer)

#define IStatusBar_get_MouseIcon(This,ppMouseIcon)	\
    (This)->lpVtbl -> get_MouseIcon(This,ppMouseIcon)

#define IStatusBar_put_MouseIcon(This,ppMouseIcon)	\
    (This)->lpVtbl -> put_MouseIcon(This,ppMouseIcon)

#define IStatusBar_putref_MouseIcon(This,ppMouseIcon)	\
    (This)->lpVtbl -> putref_MouseIcon(This,ppMouseIcon)

#define IStatusBar_get_ShowTips(This,bShowTips)	\
    (This)->lpVtbl -> get_ShowTips(This,bShowTips)

#define IStatusBar_put_ShowTips(This,bShowTips)	\
    (This)->lpVtbl -> put_ShowTips(This,bShowTips)

#define IStatusBar_get_PanelProperties(This,pbstrPanelProperties)	\
    (This)->lpVtbl -> get_PanelProperties(This,pbstrPanelProperties)

#define IStatusBar_put_PanelProperties(This,pbstrPanelProperties)	\
    (This)->lpVtbl -> put_PanelProperties(This,pbstrPanelProperties)

#define IStatusBar_get_OLEDropMode(This,psOLEDropMode)	\
    (This)->lpVtbl -> get_OLEDropMode(This,psOLEDropMode)

#define IStatusBar_put_OLEDropMode(This,psOLEDropMode)	\
    (This)->lpVtbl -> put_OLEDropMode(This,psOLEDropMode)

#define IStatusBar_get_Enabled(This,pbEnabled)	\
    (This)->lpVtbl -> get_Enabled(This,pbEnabled)

#define IStatusBar_put_Enabled(This,pbEnabled)	\
    (This)->lpVtbl -> put_Enabled(This,pbEnabled)

#define IStatusBar_get_Font(This,ppFont)	\
    (This)->lpVtbl -> get_Font(This,ppFont)

#define IStatusBar_putref_Font(This,ppFont)	\
    (This)->lpVtbl -> putref_Font(This,ppFont)

#define IStatusBar_get_hWnd(This,phWnd)	\
    (This)->lpVtbl -> get_hWnd(This,phWnd)

#define IStatusBar_put_hWnd(This,phWnd)	\
    (This)->lpVtbl -> put_hWnd(This,phWnd)

#define IStatusBar_Refresh(This)	\
    (This)->lpVtbl -> Refresh(This)

#define IStatusBar_OLEDrag(This)	\
    (This)->lpVtbl -> OLEDrag(This)

#define IStatusBar_AboutBox(This)	\
    (This)->lpVtbl -> AboutBox(This)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IStatusBar_get_SimpleText_Proxy( 
    IStatusBar * This,
    /* [retval][out] */ BSTR *pbstrSimpleText);


void __RPC_STUB IStatusBar_get_SimpleText_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE IStatusBar_put_SimpleText_Proxy( 
    IStatusBar * This,
    /* [in] */ BSTR pbstrSimpleText);


void __RPC_STUB IStatusBar_put_SimpleText_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IStatusBar_get_Style_Proxy( 
    IStatusBar * This,
    /* [retval][out] */ SbarStyleConstants *psStyle);


void __RPC_STUB IStatusBar_get_Style_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE IStatusBar_put_Style_Proxy( 
    IStatusBar * This,
    /* [in] */ SbarStyleConstants psStyle);


void __RPC_STUB IStatusBar_put_Style_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IStatusBar_get_Panels_Proxy( 
    IStatusBar * This,
    /* [retval][out] */ IPanels **ppPanels);


void __RPC_STUB IStatusBar_get_Panels_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propputref][id] */ HRESULT STDMETHODCALLTYPE IStatusBar_putref_Panels_Proxy( 
    IStatusBar * This,
    /* [in] */ IPanels *ppPanels);


void __RPC_STUB IStatusBar_putref_Panels_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IStatusBar_get_MousePointer_Proxy( 
    IStatusBar * This,
    /* [retval][out] */ MousePointerConstants *psMousePointer);


void __RPC_STUB IStatusBar_get_MousePointer_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE IStatusBar_put_MousePointer_Proxy( 
    IStatusBar * This,
    /* [in] */ MousePointerConstants psMousePointer);


void __RPC_STUB IStatusBar_put_MousePointer_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IStatusBar_get_MouseIcon_Proxy( 
    IStatusBar * This,
    /* [retval][out] */ /* external definition not present */ IPictureDisp **ppMouseIcon);


void __RPC_STUB IStatusBar_get_MouseIcon_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE IStatusBar_put_MouseIcon_Proxy( 
    IStatusBar * This,
    /* [in] */ /* external definition not present */ IPictureDisp *ppMouseIcon);


void __RPC_STUB IStatusBar_put_MouseIcon_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propputref][id] */ HRESULT STDMETHODCALLTYPE IStatusBar_putref_MouseIcon_Proxy( 
    IStatusBar * This,
    /* [in] */ /* external definition not present */ IPictureDisp *ppMouseIcon);


void __RPC_STUB IStatusBar_putref_MouseIcon_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IStatusBar_get_ShowTips_Proxy( 
    IStatusBar * This,
    /* [retval][out] */ VARIANT_BOOL *bShowTips);


void __RPC_STUB IStatusBar_get_ShowTips_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE IStatusBar_put_ShowTips_Proxy( 
    IStatusBar * This,
    /* [in] */ VARIANT_BOOL bShowTips);


void __RPC_STUB IStatusBar_put_ShowTips_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][hidden][propget][id] */ HRESULT STDMETHODCALLTYPE IStatusBar_get_PanelProperties_Proxy( 
    IStatusBar * This,
    /* [retval][out] */ BSTR *pbstrPanelProperties);


void __RPC_STUB IStatusBar_get_PanelProperties_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][hidden][propput][id] */ HRESULT STDMETHODCALLTYPE IStatusBar_put_PanelProperties_Proxy( 
    IStatusBar * This,
    /* [in] */ BSTR pbstrPanelProperties);


void __RPC_STUB IStatusBar_put_PanelProperties_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IStatusBar_get_OLEDropMode_Proxy( 
    IStatusBar * This,
    /* [retval][out] */ OLEDropConstants *psOLEDropMode);


void __RPC_STUB IStatusBar_get_OLEDropMode_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE IStatusBar_put_OLEDropMode_Proxy( 
    IStatusBar * This,
    /* [in] */ OLEDropConstants psOLEDropMode);


void __RPC_STUB IStatusBar_put_OLEDropMode_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IStatusBar_get_Enabled_Proxy( 
    IStatusBar * This,
    /* [retval][out] */ VARIANT_BOOL *pbEnabled);


void __RPC_STUB IStatusBar_get_Enabled_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE IStatusBar_put_Enabled_Proxy( 
    IStatusBar * This,
    /* [in] */ VARIANT_BOOL pbEnabled);


void __RPC_STUB IStatusBar_put_Enabled_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IStatusBar_get_Font_Proxy( 
    IStatusBar * This,
    /* [retval][out] */ /* external definition not present */ IFontDisp **ppFont);


void __RPC_STUB IStatusBar_get_Font_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propputref][id] */ HRESULT STDMETHODCALLTYPE IStatusBar_putref_Font_Proxy( 
    IStatusBar * This,
    /* [in] */ /* external definition not present */ IFontDisp *ppFont);


void __RPC_STUB IStatusBar_putref_Font_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IStatusBar_get_hWnd_Proxy( 
    IStatusBar * This,
    /* [retval][out] */ /* external definition not present */ OLE_HANDLE *phWnd);


void __RPC_STUB IStatusBar_get_hWnd_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE IStatusBar_put_hWnd_Proxy( 
    IStatusBar * This,
    /* [in] */ /* external definition not present */ OLE_HANDLE phWnd);


void __RPC_STUB IStatusBar_put_hWnd_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][id] */ HRESULT STDMETHODCALLTYPE IStatusBar_Refresh_Proxy( 
    IStatusBar * This);


void __RPC_STUB IStatusBar_Refresh_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][id] */ HRESULT STDMETHODCALLTYPE IStatusBar_OLEDrag_Proxy( 
    IStatusBar * This);


void __RPC_STUB IStatusBar_OLEDrag_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [hidden][id] */ HRESULT STDMETHODCALLTYPE IStatusBar_AboutBox_Proxy( 
    IStatusBar * This);


void __RPC_STUB IStatusBar_AboutBox_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IStatusBar_INTERFACE_DEFINED__ */


#ifndef __IStatusBarEvents_DISPINTERFACE_DEFINED__
#define __IStatusBarEvents_DISPINTERFACE_DEFINED__

/* dispinterface IStatusBarEvents */
/* [nonextensible][helpcontext][helpstring][uuid] */ 


EXTERN_C const IID DIID_IStatusBarEvents;

#if defined(__cplusplus) && !defined(CINTERFACE)

    MIDL_INTERFACE("8E3867A2-8586-11D1-B16A-00C0F0283628")
    IStatusBarEvents : public IDispatch
    {
    };
    
#else 	/* C style interface */

    typedef struct IStatusBarEventsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IStatusBarEvents * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IStatusBarEvents * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IStatusBarEvents * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IStatusBarEvents * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IStatusBarEvents * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IStatusBarEvents * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IStatusBarEvents * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        END_INTERFACE
    } IStatusBarEventsVtbl;

    interface IStatusBarEvents
    {
        CONST_VTBL struct IStatusBarEventsVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IStatusBarEvents_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IStatusBarEvents_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IStatusBarEvents_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IStatusBarEvents_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IStatusBarEvents_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IStatusBarEvents_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IStatusBarEvents_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)

#endif /* COBJMACROS */


#endif 	/* C style interface */


#endif 	/* __IStatusBarEvents_DISPINTERFACE_DEFINED__ */


#ifndef __IPanels_INTERFACE_DEFINED__
#define __IPanels_INTERFACE_DEFINED__

/* interface IPanels */
/* [object][oleautomation][nonextensible][dual][hidden][helpcontext][helpstring][uuid] */ 


EXTERN_C const IID IID_IPanels;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("8E3867A4-8586-11D1-B16A-00C0F0283628")
    IPanels : public IDispatch
    {
    public:
        virtual /* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_Count( 
            /* [retval][out] */ short *sCount) = 0;
        
        virtual /* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_Count( 
            /* [in] */ short sCount) = 0;
        
        virtual /* [hidden][propget][id] */ HRESULT STDMETHODCALLTYPE get_ControlDefault( 
            /* [in] */ VARIANT *Index,
            /* [retval][out] */ IPanel **ppPanel) = 0;
        
        virtual /* [hidden][propputref][id] */ HRESULT STDMETHODCALLTYPE putref_ControlDefault( 
            /* [in] */ VARIANT *Index,
            /* [in] */ IPanel *ppPanel) = 0;
        
        virtual /* [helpcontext][helpstring][id] */ HRESULT STDMETHODCALLTYPE Add( 
            /* [optional][in] */ VARIANT *Index,
            /* [optional][in] */ VARIANT *Key,
            /* [optional][in] */ VARIANT *Text,
            /* [optional][in] */ VARIANT *Style,
            /* [optional][in] */ VARIANT *Picture,
            /* [retval][out] */ IPanel **ppPanel) = 0;
        
        virtual /* [helpcontext][helpstring][id] */ HRESULT STDMETHODCALLTYPE Clear( void) = 0;
        
        virtual /* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_Item( 
            /* [in] */ VARIANT *Index,
            /* [retval][out] */ IPanel **ppPanel) = 0;
        
        virtual /* [helpcontext][helpstring][propputref][id] */ HRESULT STDMETHODCALLTYPE putref_Item( 
            /* [in] */ VARIANT *Index,
            /* [in] */ IPanel *ppPanel) = 0;
        
        virtual /* [helpcontext][helpstring][id] */ HRESULT STDMETHODCALLTYPE Remove( 
            /* [in] */ VARIANT *Index) = 0;
        
        virtual /* [hidden][id] */ HRESULT STDMETHODCALLTYPE _NewEnum( 
            /* [retval][out] */ IDispatch **ppNewEnum) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IPanelsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IPanels * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IPanels * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IPanels * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IPanels * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IPanels * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IPanels * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IPanels * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_Count )( 
            IPanels * This,
            /* [retval][out] */ short *sCount);
        
        /* [helpcontext][helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_Count )( 
            IPanels * This,
            /* [in] */ short sCount);
        
        /* [hidden][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_ControlDefault )( 
            IPanels * This,
            /* [in] */ VARIANT *Index,
            /* [retval][out] */ IPanel **ppPanel);
        
        /* [hidden][propputref][id] */ HRESULT ( STDMETHODCALLTYPE *putref_ControlDefault )( 
            IPanels * This,
            /* [in] */ VARIANT *Index,
            /* [in] */ IPanel *ppPanel);
        
        /* [helpcontext][helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Add )( 
            IPanels * This,
            /* [optional][in] */ VARIANT *Index,
            /* [optional][in] */ VARIANT *Key,
            /* [optional][in] */ VARIANT *Text,
            /* [optional][in] */ VARIANT *Style,
            /* [optional][in] */ VARIANT *Picture,
            /* [retval][out] */ IPanel **ppPanel);
        
        /* [helpcontext][helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Clear )( 
            IPanels * This);
        
        /* [helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_Item )( 
            IPanels * This,
            /* [in] */ VARIANT *Index,
            /* [retval][out] */ IPanel **ppPanel);
        
        /* [helpcontext][helpstring][propputref][id] */ HRESULT ( STDMETHODCALLTYPE *putref_Item )( 
            IPanels * This,
            /* [in] */ VARIANT *Index,
            /* [in] */ IPanel *ppPanel);
        
        /* [helpcontext][helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Remove )( 
            IPanels * This,
            /* [in] */ VARIANT *Index);
        
        /* [hidden][id] */ HRESULT ( STDMETHODCALLTYPE *_NewEnum )( 
            IPanels * This,
            /* [retval][out] */ IDispatch **ppNewEnum);
        
        END_INTERFACE
    } IPanelsVtbl;

    interface IPanels
    {
        CONST_VTBL struct IPanelsVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IPanels_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IPanels_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IPanels_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IPanels_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IPanels_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IPanels_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IPanels_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IPanels_get_Count(This,sCount)	\
    (This)->lpVtbl -> get_Count(This,sCount)

#define IPanels_put_Count(This,sCount)	\
    (This)->lpVtbl -> put_Count(This,sCount)

#define IPanels_get_ControlDefault(This,Index,ppPanel)	\
    (This)->lpVtbl -> get_ControlDefault(This,Index,ppPanel)

#define IPanels_putref_ControlDefault(This,Index,ppPanel)	\
    (This)->lpVtbl -> putref_ControlDefault(This,Index,ppPanel)

#define IPanels_Add(This,Index,Key,Text,Style,Picture,ppPanel)	\
    (This)->lpVtbl -> Add(This,Index,Key,Text,Style,Picture,ppPanel)

#define IPanels_Clear(This)	\
    (This)->lpVtbl -> Clear(This)

#define IPanels_get_Item(This,Index,ppPanel)	\
    (This)->lpVtbl -> get_Item(This,Index,ppPanel)

#define IPanels_putref_Item(This,Index,ppPanel)	\
    (This)->lpVtbl -> putref_Item(This,Index,ppPanel)

#define IPanels_Remove(This,Index)	\
    (This)->lpVtbl -> Remove(This,Index)

#define IPanels__NewEnum(This,ppNewEnum)	\
    (This)->lpVtbl -> _NewEnum(This,ppNewEnum)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IPanels_get_Count_Proxy( 
    IPanels * This,
    /* [retval][out] */ short *sCount);


void __RPC_STUB IPanels_get_Count_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE IPanels_put_Count_Proxy( 
    IPanels * This,
    /* [in] */ short sCount);


void __RPC_STUB IPanels_put_Count_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [hidden][propget][id] */ HRESULT STDMETHODCALLTYPE IPanels_get_ControlDefault_Proxy( 
    IPanels * This,
    /* [in] */ VARIANT *Index,
    /* [retval][out] */ IPanel **ppPanel);


void __RPC_STUB IPanels_get_ControlDefault_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [hidden][propputref][id] */ HRESULT STDMETHODCALLTYPE IPanels_putref_ControlDefault_Proxy( 
    IPanels * This,
    /* [in] */ VARIANT *Index,
    /* [in] */ IPanel *ppPanel);


void __RPC_STUB IPanels_putref_ControlDefault_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][id] */ HRESULT STDMETHODCALLTYPE IPanels_Add_Proxy( 
    IPanels * This,
    /* [optional][in] */ VARIANT *Index,
    /* [optional][in] */ VARIANT *Key,
    /* [optional][in] */ VARIANT *Text,
    /* [optional][in] */ VARIANT *Style,
    /* [optional][in] */ VARIANT *Picture,
    /* [retval][out] */ IPanel **ppPanel);


void __RPC_STUB IPanels_Add_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][id] */ HRESULT STDMETHODCALLTYPE IPanels_Clear_Proxy( 
    IPanels * This);


void __RPC_STUB IPanels_Clear_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IPanels_get_Item_Proxy( 
    IPanels * This,
    /* [in] */ VARIANT *Index,
    /* [retval][out] */ IPanel **ppPanel);


void __RPC_STUB IPanels_get_Item_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propputref][id] */ HRESULT STDMETHODCALLTYPE IPanels_putref_Item_Proxy( 
    IPanels * This,
    /* [in] */ VARIANT *Index,
    /* [in] */ IPanel *ppPanel);


void __RPC_STUB IPanels_putref_Item_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][id] */ HRESULT STDMETHODCALLTYPE IPanels_Remove_Proxy( 
    IPanels * This,
    /* [in] */ VARIANT *Index);


void __RPC_STUB IPanels_Remove_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [hidden][id] */ HRESULT STDMETHODCALLTYPE IPanels__NewEnum_Proxy( 
    IPanels * This,
    /* [retval][out] */ IDispatch **ppNewEnum);


void __RPC_STUB IPanels__NewEnum_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IPanels_INTERFACE_DEFINED__ */


#ifndef __IPanel_INTERFACE_DEFINED__
#define __IPanel_INTERFACE_DEFINED__

/* interface IPanel */
/* [object][oleautomation][nonextensible][dual][hidden][helpcontext][helpstring][uuid] */ 


EXTERN_C const IID IID_IPanel;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("8E3867AA-8586-11D1-B16A-00C0F0283628")
    IPanel : public IDispatch
    {
    public:
        virtual /* [hidden][propget][id] */ HRESULT STDMETHODCALLTYPE get__ObjectDefault( 
            /* [retval][out] */ BSTR *pbstrText) = 0;
        
        virtual /* [hidden][propput][id] */ HRESULT STDMETHODCALLTYPE put__ObjectDefault( 
            /* [in] */ BSTR pbstrText) = 0;
        
        virtual /* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_Alignment( 
            /* [retval][out] */ PanelAlignmentConstants *psAlignment) = 0;
        
        virtual /* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_Alignment( 
            /* [in] */ PanelAlignmentConstants psAlignment) = 0;
        
        virtual /* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_AutoSize( 
            /* [retval][out] */ PanelAutoSizeConstants *psAutoSize) = 0;
        
        virtual /* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_AutoSize( 
            /* [in] */ PanelAutoSizeConstants psAutoSize) = 0;
        
        virtual /* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_Bevel( 
            /* [retval][out] */ PanelBevelConstants *psBevel) = 0;
        
        virtual /* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_Bevel( 
            /* [in] */ PanelBevelConstants psBevel) = 0;
        
        virtual /* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_Enabled( 
            /* [retval][out] */ VARIANT_BOOL *pbEnabled) = 0;
        
        virtual /* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_Enabled( 
            /* [in] */ VARIANT_BOOL pbEnabled) = 0;
        
        virtual /* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_Index( 
            /* [retval][out] */ short *sIndex) = 0;
        
        virtual /* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_Index( 
            /* [in] */ short sIndex) = 0;
        
        virtual /* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_Key( 
            /* [retval][out] */ BSTR *pbstrKey) = 0;
        
        virtual /* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_Key( 
            /* [in] */ BSTR pbstrKey) = 0;
        
        virtual /* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_Left( 
            /* [retval][out] */ single *pfLeft) = 0;
        
        virtual /* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_Left( 
            /* [in] */ single pfLeft) = 0;
        
        virtual /* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_MinWidth( 
            /* [retval][out] */ single *pfMinWidth) = 0;
        
        virtual /* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_MinWidth( 
            /* [in] */ single pfMinWidth) = 0;
        
        virtual /* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_Picture( 
            /* [retval][out] */ /* external definition not present */ IPictureDisp **ppPicture) = 0;
        
        virtual /* [helpcontext][helpstring][propputref][id] */ HRESULT STDMETHODCALLTYPE putref_Picture( 
            /* [in] */ /* external definition not present */ IPictureDisp *ppPicture) = 0;
        
        virtual /* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_Style( 
            /* [retval][out] */ PanelStyleConstants *psStyle) = 0;
        
        virtual /* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_Style( 
            /* [in] */ PanelStyleConstants psStyle) = 0;
        
        virtual /* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_Tag( 
            /* [retval][out] */ VARIANT *pvTag) = 0;
        
        virtual /* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_Tag( 
            /* [in] */ VARIANT pvTag) = 0;
        
        virtual /* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_Text( 
            /* [retval][out] */ BSTR *pbstrText) = 0;
        
        virtual /* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_Text( 
            /* [in] */ BSTR pbstrText) = 0;
        
        virtual /* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_ToolTipText( 
            /* [retval][out] */ BSTR *pbstrToolTipText) = 0;
        
        virtual /* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_ToolTipText( 
            /* [in] */ BSTR pbstrToolTipText) = 0;
        
        virtual /* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_Visible( 
            /* [retval][out] */ VARIANT_BOOL *pbVisible) = 0;
        
        virtual /* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_Visible( 
            /* [in] */ VARIANT_BOOL pbVisible) = 0;
        
        virtual /* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_Width( 
            /* [retval][out] */ single *pfWidth) = 0;
        
        virtual /* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_Width( 
            /* [in] */ single pfWidth) = 0;
        
        virtual /* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_Picture( 
            /* [in] */ /* external definition not present */ IPictureDisp *ppPicture) = 0;
        
        virtual /* [helpcontext][helpstring][propputref][id] */ HRESULT STDMETHODCALLTYPE putref_Tag( 
            /* [in] */ VARIANT pvTag) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IPanelVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IPanel * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IPanel * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IPanel * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IPanel * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IPanel * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IPanel * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IPanel * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [hidden][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get__ObjectDefault )( 
            IPanel * This,
            /* [retval][out] */ BSTR *pbstrText);
        
        /* [hidden][propput][id] */ HRESULT ( STDMETHODCALLTYPE *put__ObjectDefault )( 
            IPanel * This,
            /* [in] */ BSTR pbstrText);
        
        /* [helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_Alignment )( 
            IPanel * This,
            /* [retval][out] */ PanelAlignmentConstants *psAlignment);
        
        /* [helpcontext][helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_Alignment )( 
            IPanel * This,
            /* [in] */ PanelAlignmentConstants psAlignment);
        
        /* [helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_AutoSize )( 
            IPanel * This,
            /* [retval][out] */ PanelAutoSizeConstants *psAutoSize);
        
        /* [helpcontext][helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_AutoSize )( 
            IPanel * This,
            /* [in] */ PanelAutoSizeConstants psAutoSize);
        
        /* [helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_Bevel )( 
            IPanel * This,
            /* [retval][out] */ PanelBevelConstants *psBevel);
        
        /* [helpcontext][helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_Bevel )( 
            IPanel * This,
            /* [in] */ PanelBevelConstants psBevel);
        
        /* [helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_Enabled )( 
            IPanel * This,
            /* [retval][out] */ VARIANT_BOOL *pbEnabled);
        
        /* [helpcontext][helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_Enabled )( 
            IPanel * This,
            /* [in] */ VARIANT_BOOL pbEnabled);
        
        /* [helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_Index )( 
            IPanel * This,
            /* [retval][out] */ short *sIndex);
        
        /* [helpcontext][helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_Index )( 
            IPanel * This,
            /* [in] */ short sIndex);
        
        /* [helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_Key )( 
            IPanel * This,
            /* [retval][out] */ BSTR *pbstrKey);
        
        /* [helpcontext][helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_Key )( 
            IPanel * This,
            /* [in] */ BSTR pbstrKey);
        
        /* [helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_Left )( 
            IPanel * This,
            /* [retval][out] */ single *pfLeft);
        
        /* [helpcontext][helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_Left )( 
            IPanel * This,
            /* [in] */ single pfLeft);
        
        /* [helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_MinWidth )( 
            IPanel * This,
            /* [retval][out] */ single *pfMinWidth);
        
        /* [helpcontext][helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_MinWidth )( 
            IPanel * This,
            /* [in] */ single pfMinWidth);
        
        /* [helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_Picture )( 
            IPanel * This,
            /* [retval][out] */ /* external definition not present */ IPictureDisp **ppPicture);
        
        /* [helpcontext][helpstring][propputref][id] */ HRESULT ( STDMETHODCALLTYPE *putref_Picture )( 
            IPanel * This,
            /* [in] */ /* external definition not present */ IPictureDisp *ppPicture);
        
        /* [helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_Style )( 
            IPanel * This,
            /* [retval][out] */ PanelStyleConstants *psStyle);
        
        /* [helpcontext][helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_Style )( 
            IPanel * This,
            /* [in] */ PanelStyleConstants psStyle);
        
        /* [helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_Tag )( 
            IPanel * This,
            /* [retval][out] */ VARIANT *pvTag);
        
        /* [helpcontext][helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_Tag )( 
            IPanel * This,
            /* [in] */ VARIANT pvTag);
        
        /* [helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_Text )( 
            IPanel * This,
            /* [retval][out] */ BSTR *pbstrText);
        
        /* [helpcontext][helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_Text )( 
            IPanel * This,
            /* [in] */ BSTR pbstrText);
        
        /* [helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_ToolTipText )( 
            IPanel * This,
            /* [retval][out] */ BSTR *pbstrToolTipText);
        
        /* [helpcontext][helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_ToolTipText )( 
            IPanel * This,
            /* [in] */ BSTR pbstrToolTipText);
        
        /* [helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_Visible )( 
            IPanel * This,
            /* [retval][out] */ VARIANT_BOOL *pbVisible);
        
        /* [helpcontext][helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_Visible )( 
            IPanel * This,
            /* [in] */ VARIANT_BOOL pbVisible);
        
        /* [helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_Width )( 
            IPanel * This,
            /* [retval][out] */ single *pfWidth);
        
        /* [helpcontext][helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_Width )( 
            IPanel * This,
            /* [in] */ single pfWidth);
        
        /* [helpcontext][helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_Picture )( 
            IPanel * This,
            /* [in] */ /* external definition not present */ IPictureDisp *ppPicture);
        
        /* [helpcontext][helpstring][propputref][id] */ HRESULT ( STDMETHODCALLTYPE *putref_Tag )( 
            IPanel * This,
            /* [in] */ VARIANT pvTag);
        
        END_INTERFACE
    } IPanelVtbl;

    interface IPanel
    {
        CONST_VTBL struct IPanelVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IPanel_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IPanel_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IPanel_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IPanel_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IPanel_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IPanel_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IPanel_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IPanel_get__ObjectDefault(This,pbstrText)	\
    (This)->lpVtbl -> get__ObjectDefault(This,pbstrText)

#define IPanel_put__ObjectDefault(This,pbstrText)	\
    (This)->lpVtbl -> put__ObjectDefault(This,pbstrText)

#define IPanel_get_Alignment(This,psAlignment)	\
    (This)->lpVtbl -> get_Alignment(This,psAlignment)

#define IPanel_put_Alignment(This,psAlignment)	\
    (This)->lpVtbl -> put_Alignment(This,psAlignment)

#define IPanel_get_AutoSize(This,psAutoSize)	\
    (This)->lpVtbl -> get_AutoSize(This,psAutoSize)

#define IPanel_put_AutoSize(This,psAutoSize)	\
    (This)->lpVtbl -> put_AutoSize(This,psAutoSize)

#define IPanel_get_Bevel(This,psBevel)	\
    (This)->lpVtbl -> get_Bevel(This,psBevel)

#define IPanel_put_Bevel(This,psBevel)	\
    (This)->lpVtbl -> put_Bevel(This,psBevel)

#define IPanel_get_Enabled(This,pbEnabled)	\
    (This)->lpVtbl -> get_Enabled(This,pbEnabled)

#define IPanel_put_Enabled(This,pbEnabled)	\
    (This)->lpVtbl -> put_Enabled(This,pbEnabled)

#define IPanel_get_Index(This,sIndex)	\
    (This)->lpVtbl -> get_Index(This,sIndex)

#define IPanel_put_Index(This,sIndex)	\
    (This)->lpVtbl -> put_Index(This,sIndex)

#define IPanel_get_Key(This,pbstrKey)	\
    (This)->lpVtbl -> get_Key(This,pbstrKey)

#define IPanel_put_Key(This,pbstrKey)	\
    (This)->lpVtbl -> put_Key(This,pbstrKey)

#define IPanel_get_Left(This,pfLeft)	\
    (This)->lpVtbl -> get_Left(This,pfLeft)

#define IPanel_put_Left(This,pfLeft)	\
    (This)->lpVtbl -> put_Left(This,pfLeft)

#define IPanel_get_MinWidth(This,pfMinWidth)	\
    (This)->lpVtbl -> get_MinWidth(This,pfMinWidth)

#define IPanel_put_MinWidth(This,pfMinWidth)	\
    (This)->lpVtbl -> put_MinWidth(This,pfMinWidth)

#define IPanel_get_Picture(This,ppPicture)	\
    (This)->lpVtbl -> get_Picture(This,ppPicture)

#define IPanel_putref_Picture(This,ppPicture)	\
    (This)->lpVtbl -> putref_Picture(This,ppPicture)

#define IPanel_get_Style(This,psStyle)	\
    (This)->lpVtbl -> get_Style(This,psStyle)

#define IPanel_put_Style(This,psStyle)	\
    (This)->lpVtbl -> put_Style(This,psStyle)

#define IPanel_get_Tag(This,pvTag)	\
    (This)->lpVtbl -> get_Tag(This,pvTag)

#define IPanel_put_Tag(This,pvTag)	\
    (This)->lpVtbl -> put_Tag(This,pvTag)

#define IPanel_get_Text(This,pbstrText)	\
    (This)->lpVtbl -> get_Text(This,pbstrText)

#define IPanel_put_Text(This,pbstrText)	\
    (This)->lpVtbl -> put_Text(This,pbstrText)

#define IPanel_get_ToolTipText(This,pbstrToolTipText)	\
    (This)->lpVtbl -> get_ToolTipText(This,pbstrToolTipText)

#define IPanel_put_ToolTipText(This,pbstrToolTipText)	\
    (This)->lpVtbl -> put_ToolTipText(This,pbstrToolTipText)

#define IPanel_get_Visible(This,pbVisible)	\
    (This)->lpVtbl -> get_Visible(This,pbVisible)

#define IPanel_put_Visible(This,pbVisible)	\
    (This)->lpVtbl -> put_Visible(This,pbVisible)

#define IPanel_get_Width(This,pfWidth)	\
    (This)->lpVtbl -> get_Width(This,pfWidth)

#define IPanel_put_Width(This,pfWidth)	\
    (This)->lpVtbl -> put_Width(This,pfWidth)

#define IPanel_put_Picture(This,ppPicture)	\
    (This)->lpVtbl -> put_Picture(This,ppPicture)

#define IPanel_putref_Tag(This,pvTag)	\
    (This)->lpVtbl -> putref_Tag(This,pvTag)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [hidden][propget][id] */ HRESULT STDMETHODCALLTYPE IPanel_get__ObjectDefault_Proxy( 
    IPanel * This,
    /* [retval][out] */ BSTR *pbstrText);


void __RPC_STUB IPanel_get__ObjectDefault_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [hidden][propput][id] */ HRESULT STDMETHODCALLTYPE IPanel_put__ObjectDefault_Proxy( 
    IPanel * This,
    /* [in] */ BSTR pbstrText);


void __RPC_STUB IPanel_put__ObjectDefault_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IPanel_get_Alignment_Proxy( 
    IPanel * This,
    /* [retval][out] */ PanelAlignmentConstants *psAlignment);


void __RPC_STUB IPanel_get_Alignment_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE IPanel_put_Alignment_Proxy( 
    IPanel * This,
    /* [in] */ PanelAlignmentConstants psAlignment);


void __RPC_STUB IPanel_put_Alignment_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IPanel_get_AutoSize_Proxy( 
    IPanel * This,
    /* [retval][out] */ PanelAutoSizeConstants *psAutoSize);


void __RPC_STUB IPanel_get_AutoSize_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE IPanel_put_AutoSize_Proxy( 
    IPanel * This,
    /* [in] */ PanelAutoSizeConstants psAutoSize);


void __RPC_STUB IPanel_put_AutoSize_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IPanel_get_Bevel_Proxy( 
    IPanel * This,
    /* [retval][out] */ PanelBevelConstants *psBevel);


void __RPC_STUB IPanel_get_Bevel_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE IPanel_put_Bevel_Proxy( 
    IPanel * This,
    /* [in] */ PanelBevelConstants psBevel);


void __RPC_STUB IPanel_put_Bevel_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IPanel_get_Enabled_Proxy( 
    IPanel * This,
    /* [retval][out] */ VARIANT_BOOL *pbEnabled);


void __RPC_STUB IPanel_get_Enabled_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE IPanel_put_Enabled_Proxy( 
    IPanel * This,
    /* [in] */ VARIANT_BOOL pbEnabled);


void __RPC_STUB IPanel_put_Enabled_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IPanel_get_Index_Proxy( 
    IPanel * This,
    /* [retval][out] */ short *sIndex);


void __RPC_STUB IPanel_get_Index_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE IPanel_put_Index_Proxy( 
    IPanel * This,
    /* [in] */ short sIndex);


void __RPC_STUB IPanel_put_Index_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IPanel_get_Key_Proxy( 
    IPanel * This,
    /* [retval][out] */ BSTR *pbstrKey);


void __RPC_STUB IPanel_get_Key_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE IPanel_put_Key_Proxy( 
    IPanel * This,
    /* [in] */ BSTR pbstrKey);


void __RPC_STUB IPanel_put_Key_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IPanel_get_Left_Proxy( 
    IPanel * This,
    /* [retval][out] */ single *pfLeft);


void __RPC_STUB IPanel_get_Left_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE IPanel_put_Left_Proxy( 
    IPanel * This,
    /* [in] */ single pfLeft);


void __RPC_STUB IPanel_put_Left_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IPanel_get_MinWidth_Proxy( 
    IPanel * This,
    /* [retval][out] */ single *pfMinWidth);


void __RPC_STUB IPanel_get_MinWidth_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE IPanel_put_MinWidth_Proxy( 
    IPanel * This,
    /* [in] */ single pfMinWidth);


void __RPC_STUB IPanel_put_MinWidth_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IPanel_get_Picture_Proxy( 
    IPanel * This,
    /* [retval][out] */ /* external definition not present */ IPictureDisp **ppPicture);


void __RPC_STUB IPanel_get_Picture_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propputref][id] */ HRESULT STDMETHODCALLTYPE IPanel_putref_Picture_Proxy( 
    IPanel * This,
    /* [in] */ /* external definition not present */ IPictureDisp *ppPicture);


void __RPC_STUB IPanel_putref_Picture_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IPanel_get_Style_Proxy( 
    IPanel * This,
    /* [retval][out] */ PanelStyleConstants *psStyle);


void __RPC_STUB IPanel_get_Style_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE IPanel_put_Style_Proxy( 
    IPanel * This,
    /* [in] */ PanelStyleConstants psStyle);


void __RPC_STUB IPanel_put_Style_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IPanel_get_Tag_Proxy( 
    IPanel * This,
    /* [retval][out] */ VARIANT *pvTag);


void __RPC_STUB IPanel_get_Tag_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE IPanel_put_Tag_Proxy( 
    IPanel * This,
    /* [in] */ VARIANT pvTag);


void __RPC_STUB IPanel_put_Tag_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IPanel_get_Text_Proxy( 
    IPanel * This,
    /* [retval][out] */ BSTR *pbstrText);


void __RPC_STUB IPanel_get_Text_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE IPanel_put_Text_Proxy( 
    IPanel * This,
    /* [in] */ BSTR pbstrText);


void __RPC_STUB IPanel_put_Text_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IPanel_get_ToolTipText_Proxy( 
    IPanel * This,
    /* [retval][out] */ BSTR *pbstrToolTipText);


void __RPC_STUB IPanel_get_ToolTipText_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE IPanel_put_ToolTipText_Proxy( 
    IPanel * This,
    /* [in] */ BSTR pbstrToolTipText);


void __RPC_STUB IPanel_put_ToolTipText_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IPanel_get_Visible_Proxy( 
    IPanel * This,
    /* [retval][out] */ VARIANT_BOOL *pbVisible);


void __RPC_STUB IPanel_get_Visible_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE IPanel_put_Visible_Proxy( 
    IPanel * This,
    /* [in] */ VARIANT_BOOL pbVisible);


void __RPC_STUB IPanel_put_Visible_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IPanel_get_Width_Proxy( 
    IPanel * This,
    /* [retval][out] */ single *pfWidth);


void __RPC_STUB IPanel_get_Width_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE IPanel_put_Width_Proxy( 
    IPanel * This,
    /* [in] */ single pfWidth);


void __RPC_STUB IPanel_put_Width_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE IPanel_put_Picture_Proxy( 
    IPanel * This,
    /* [in] */ /* external definition not present */ IPictureDisp *ppPicture);


void __RPC_STUB IPanel_put_Picture_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propputref][id] */ HRESULT STDMETHODCALLTYPE IPanel_putref_Tag_Proxy( 
    IPanel * This,
    /* [in] */ VARIANT pvTag);


void __RPC_STUB IPanel_putref_Tag_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IPanel_INTERFACE_DEFINED__ */


#ifndef __IProgressBar_INTERFACE_DEFINED__
#define __IProgressBar_INTERFACE_DEFINED__

/* interface IProgressBar */
/* [object][oleautomation][nonextensible][dual][hidden][helpcontext][helpstring][uuid] */ 


EXTERN_C const IID IID_IProgressBar;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("35053A20-8589-11D1-B16A-00C0F0283628")
    IProgressBar : public IDispatch
    {
    public:
        virtual /* [hidden][propget][id] */ HRESULT STDMETHODCALLTYPE get_ControlDefault( 
            /* [retval][out] */ single *pfValue) = 0;
        
        virtual /* [hidden][propput][id] */ HRESULT STDMETHODCALLTYPE put_ControlDefault( 
            /* [in] */ single pfValue) = 0;
        
        virtual /* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_Max( 
            /* [retval][out] */ single *pfMax) = 0;
        
        virtual /* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_Max( 
            /* [in] */ single pfMax) = 0;
        
        virtual /* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_Min( 
            /* [retval][out] */ single *pfMin) = 0;
        
        virtual /* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_Min( 
            /* [in] */ single pfMin) = 0;
        
        virtual /* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_MousePointer( 
            /* [retval][out] */ MousePointerConstants *pMousePointers) = 0;
        
        virtual /* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_MousePointer( 
            /* [in] */ MousePointerConstants pMousePointers) = 0;
        
        virtual /* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_MouseIcon( 
            /* [retval][out] */ /* external definition not present */ IPictureDisp **ppPictureDisp) = 0;
        
        virtual /* [helpcontext][helpstring][propputref][id] */ HRESULT STDMETHODCALLTYPE putref_MouseIcon( 
            /* [in] */ /* external definition not present */ IPictureDisp *ppPictureDisp) = 0;
        
        virtual /* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_MouseIcon( 
            /* [in] */ /* external definition not present */ IPictureDisp *ppPictureDisp) = 0;
        
        virtual /* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_Value( 
            /* [retval][out] */ single *pfValue) = 0;
        
        virtual /* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_Value( 
            /* [in] */ single pfValue) = 0;
        
        virtual /* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_OLEDropMode( 
            /* [retval][out] */ OLEDropConstants *psOLEDropMode) = 0;
        
        virtual /* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_OLEDropMode( 
            /* [in] */ OLEDropConstants psOLEDropMode) = 0;
        
        virtual /* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_Appearance( 
            /* [retval][out] */ AppearanceConstants *penumAppearances) = 0;
        
        virtual /* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_Appearance( 
            /* [in] */ AppearanceConstants penumAppearances) = 0;
        
        virtual /* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_BorderStyle( 
            /* [retval][out] */ BorderStyleConstants *penumBorderStyles) = 0;
        
        virtual /* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_BorderStyle( 
            /* [in] */ BorderStyleConstants penumBorderStyles) = 0;
        
        virtual /* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_Enabled( 
            /* [retval][out] */ VARIANT_BOOL *bEnabled) = 0;
        
        virtual /* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_Enabled( 
            /* [in] */ VARIANT_BOOL bEnabled) = 0;
        
        virtual /* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_hWnd( 
            /* [retval][out] */ /* external definition not present */ OLE_HANDLE *phWnd) = 0;
        
        virtual /* [helpcontext][helpstring][id] */ HRESULT STDMETHODCALLTYPE OLEDrag( void) = 0;
        
        virtual /* [hidden][id] */ HRESULT STDMETHODCALLTYPE AboutBox( void) = 0;
        
        virtual /* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_Orientation( 
            /* [retval][out] */ OrientationConstants *penumOrientation) = 0;
        
        virtual /* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_Orientation( 
            /* [in] */ OrientationConstants penumOrientation) = 0;
        
        virtual /* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_Scrolling( 
            /* [retval][out] */ ScrollingConstants *penumScrolling) = 0;
        
        virtual /* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_Scrolling( 
            /* [in] */ ScrollingConstants penumScrolling) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE Refresh( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IProgressBarVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IProgressBar * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IProgressBar * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IProgressBar * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IProgressBar * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IProgressBar * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IProgressBar * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IProgressBar * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [hidden][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_ControlDefault )( 
            IProgressBar * This,
            /* [retval][out] */ single *pfValue);
        
        /* [hidden][propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_ControlDefault )( 
            IProgressBar * This,
            /* [in] */ single pfValue);
        
        /* [helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_Max )( 
            IProgressBar * This,
            /* [retval][out] */ single *pfMax);
        
        /* [helpcontext][helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_Max )( 
            IProgressBar * This,
            /* [in] */ single pfMax);
        
        /* [helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_Min )( 
            IProgressBar * This,
            /* [retval][out] */ single *pfMin);
        
        /* [helpcontext][helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_Min )( 
            IProgressBar * This,
            /* [in] */ single pfMin);
        
        /* [helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_MousePointer )( 
            IProgressBar * This,
            /* [retval][out] */ MousePointerConstants *pMousePointers);
        
        /* [helpcontext][helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_MousePointer )( 
            IProgressBar * This,
            /* [in] */ MousePointerConstants pMousePointers);
        
        /* [helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_MouseIcon )( 
            IProgressBar * This,
            /* [retval][out] */ /* external definition not present */ IPictureDisp **ppPictureDisp);
        
        /* [helpcontext][helpstring][propputref][id] */ HRESULT ( STDMETHODCALLTYPE *putref_MouseIcon )( 
            IProgressBar * This,
            /* [in] */ /* external definition not present */ IPictureDisp *ppPictureDisp);
        
        /* [helpcontext][helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_MouseIcon )( 
            IProgressBar * This,
            /* [in] */ /* external definition not present */ IPictureDisp *ppPictureDisp);
        
        /* [helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_Value )( 
            IProgressBar * This,
            /* [retval][out] */ single *pfValue);
        
        /* [helpcontext][helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_Value )( 
            IProgressBar * This,
            /* [in] */ single pfValue);
        
        /* [helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_OLEDropMode )( 
            IProgressBar * This,
            /* [retval][out] */ OLEDropConstants *psOLEDropMode);
        
        /* [helpcontext][helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_OLEDropMode )( 
            IProgressBar * This,
            /* [in] */ OLEDropConstants psOLEDropMode);
        
        /* [helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_Appearance )( 
            IProgressBar * This,
            /* [retval][out] */ AppearanceConstants *penumAppearances);
        
        /* [helpcontext][helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_Appearance )( 
            IProgressBar * This,
            /* [in] */ AppearanceConstants penumAppearances);
        
        /* [helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_BorderStyle )( 
            IProgressBar * This,
            /* [retval][out] */ BorderStyleConstants *penumBorderStyles);
        
        /* [helpcontext][helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_BorderStyle )( 
            IProgressBar * This,
            /* [in] */ BorderStyleConstants penumBorderStyles);
        
        /* [helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_Enabled )( 
            IProgressBar * This,
            /* [retval][out] */ VARIANT_BOOL *bEnabled);
        
        /* [helpcontext][helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_Enabled )( 
            IProgressBar * This,
            /* [in] */ VARIANT_BOOL bEnabled);
        
        /* [helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_hWnd )( 
            IProgressBar * This,
            /* [retval][out] */ /* external definition not present */ OLE_HANDLE *phWnd);
        
        /* [helpcontext][helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *OLEDrag )( 
            IProgressBar * This);
        
        /* [hidden][id] */ HRESULT ( STDMETHODCALLTYPE *AboutBox )( 
            IProgressBar * This);
        
        /* [helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_Orientation )( 
            IProgressBar * This,
            /* [retval][out] */ OrientationConstants *penumOrientation);
        
        /* [helpcontext][helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_Orientation )( 
            IProgressBar * This,
            /* [in] */ OrientationConstants penumOrientation);
        
        /* [helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_Scrolling )( 
            IProgressBar * This,
            /* [retval][out] */ ScrollingConstants *penumScrolling);
        
        /* [helpcontext][helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_Scrolling )( 
            IProgressBar * This,
            /* [in] */ ScrollingConstants penumScrolling);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE *Refresh )( 
            IProgressBar * This);
        
        END_INTERFACE
    } IProgressBarVtbl;

    interface IProgressBar
    {
        CONST_VTBL struct IProgressBarVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IProgressBar_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IProgressBar_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IProgressBar_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IProgressBar_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IProgressBar_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IProgressBar_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IProgressBar_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IProgressBar_get_ControlDefault(This,pfValue)	\
    (This)->lpVtbl -> get_ControlDefault(This,pfValue)

#define IProgressBar_put_ControlDefault(This,pfValue)	\
    (This)->lpVtbl -> put_ControlDefault(This,pfValue)

#define IProgressBar_get_Max(This,pfMax)	\
    (This)->lpVtbl -> get_Max(This,pfMax)

#define IProgressBar_put_Max(This,pfMax)	\
    (This)->lpVtbl -> put_Max(This,pfMax)

#define IProgressBar_get_Min(This,pfMin)	\
    (This)->lpVtbl -> get_Min(This,pfMin)

#define IProgressBar_put_Min(This,pfMin)	\
    (This)->lpVtbl -> put_Min(This,pfMin)

#define IProgressBar_get_MousePointer(This,pMousePointers)	\
    (This)->lpVtbl -> get_MousePointer(This,pMousePointers)

#define IProgressBar_put_MousePointer(This,pMousePointers)	\
    (This)->lpVtbl -> put_MousePointer(This,pMousePointers)

#define IProgressBar_get_MouseIcon(This,ppPictureDisp)	\
    (This)->lpVtbl -> get_MouseIcon(This,ppPictureDisp)

#define IProgressBar_putref_MouseIcon(This,ppPictureDisp)	\
    (This)->lpVtbl -> putref_MouseIcon(This,ppPictureDisp)

#define IProgressBar_put_MouseIcon(This,ppPictureDisp)	\
    (This)->lpVtbl -> put_MouseIcon(This,ppPictureDisp)

#define IProgressBar_get_Value(This,pfValue)	\
    (This)->lpVtbl -> get_Value(This,pfValue)

#define IProgressBar_put_Value(This,pfValue)	\
    (This)->lpVtbl -> put_Value(This,pfValue)

#define IProgressBar_get_OLEDropMode(This,psOLEDropMode)	\
    (This)->lpVtbl -> get_OLEDropMode(This,psOLEDropMode)

#define IProgressBar_put_OLEDropMode(This,psOLEDropMode)	\
    (This)->lpVtbl -> put_OLEDropMode(This,psOLEDropMode)

#define IProgressBar_get_Appearance(This,penumAppearances)	\
    (This)->lpVtbl -> get_Appearance(This,penumAppearances)

#define IProgressBar_put_Appearance(This,penumAppearances)	\
    (This)->lpVtbl -> put_Appearance(This,penumAppearances)

#define IProgressBar_get_BorderStyle(This,penumBorderStyles)	\
    (This)->lpVtbl -> get_BorderStyle(This,penumBorderStyles)

#define IProgressBar_put_BorderStyle(This,penumBorderStyles)	\
    (This)->lpVtbl -> put_BorderStyle(This,penumBorderStyles)

#define IProgressBar_get_Enabled(This,bEnabled)	\
    (This)->lpVtbl -> get_Enabled(This,bEnabled)

#define IProgressBar_put_Enabled(This,bEnabled)	\
    (This)->lpVtbl -> put_Enabled(This,bEnabled)

#define IProgressBar_get_hWnd(This,phWnd)	\
    (This)->lpVtbl -> get_hWnd(This,phWnd)

#define IProgressBar_OLEDrag(This)	\
    (This)->lpVtbl -> OLEDrag(This)

#define IProgressBar_AboutBox(This)	\
    (This)->lpVtbl -> AboutBox(This)

#define IProgressBar_get_Orientation(This,penumOrientation)	\
    (This)->lpVtbl -> get_Orientation(This,penumOrientation)

#define IProgressBar_put_Orientation(This,penumOrientation)	\
    (This)->lpVtbl -> put_Orientation(This,penumOrientation)

#define IProgressBar_get_Scrolling(This,penumScrolling)	\
    (This)->lpVtbl -> get_Scrolling(This,penumScrolling)

#define IProgressBar_put_Scrolling(This,penumScrolling)	\
    (This)->lpVtbl -> put_Scrolling(This,penumScrolling)

#define IProgressBar_Refresh(This)	\
    (This)->lpVtbl -> Refresh(This)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [hidden][propget][id] */ HRESULT STDMETHODCALLTYPE IProgressBar_get_ControlDefault_Proxy( 
    IProgressBar * This,
    /* [retval][out] */ single *pfValue);


void __RPC_STUB IProgressBar_get_ControlDefault_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [hidden][propput][id] */ HRESULT STDMETHODCALLTYPE IProgressBar_put_ControlDefault_Proxy( 
    IProgressBar * This,
    /* [in] */ single pfValue);


void __RPC_STUB IProgressBar_put_ControlDefault_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IProgressBar_get_Max_Proxy( 
    IProgressBar * This,
    /* [retval][out] */ single *pfMax);


void __RPC_STUB IProgressBar_get_Max_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE IProgressBar_put_Max_Proxy( 
    IProgressBar * This,
    /* [in] */ single pfMax);


void __RPC_STUB IProgressBar_put_Max_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IProgressBar_get_Min_Proxy( 
    IProgressBar * This,
    /* [retval][out] */ single *pfMin);


void __RPC_STUB IProgressBar_get_Min_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE IProgressBar_put_Min_Proxy( 
    IProgressBar * This,
    /* [in] */ single pfMin);


void __RPC_STUB IProgressBar_put_Min_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IProgressBar_get_MousePointer_Proxy( 
    IProgressBar * This,
    /* [retval][out] */ MousePointerConstants *pMousePointers);


void __RPC_STUB IProgressBar_get_MousePointer_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE IProgressBar_put_MousePointer_Proxy( 
    IProgressBar * This,
    /* [in] */ MousePointerConstants pMousePointers);


void __RPC_STUB IProgressBar_put_MousePointer_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IProgressBar_get_MouseIcon_Proxy( 
    IProgressBar * This,
    /* [retval][out] */ /* external definition not present */ IPictureDisp **ppPictureDisp);


void __RPC_STUB IProgressBar_get_MouseIcon_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propputref][id] */ HRESULT STDMETHODCALLTYPE IProgressBar_putref_MouseIcon_Proxy( 
    IProgressBar * This,
    /* [in] */ /* external definition not present */ IPictureDisp *ppPictureDisp);


void __RPC_STUB IProgressBar_putref_MouseIcon_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE IProgressBar_put_MouseIcon_Proxy( 
    IProgressBar * This,
    /* [in] */ /* external definition not present */ IPictureDisp *ppPictureDisp);


void __RPC_STUB IProgressBar_put_MouseIcon_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IProgressBar_get_Value_Proxy( 
    IProgressBar * This,
    /* [retval][out] */ single *pfValue);


void __RPC_STUB IProgressBar_get_Value_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE IProgressBar_put_Value_Proxy( 
    IProgressBar * This,
    /* [in] */ single pfValue);


void __RPC_STUB IProgressBar_put_Value_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IProgressBar_get_OLEDropMode_Proxy( 
    IProgressBar * This,
    /* [retval][out] */ OLEDropConstants *psOLEDropMode);


void __RPC_STUB IProgressBar_get_OLEDropMode_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE IProgressBar_put_OLEDropMode_Proxy( 
    IProgressBar * This,
    /* [in] */ OLEDropConstants psOLEDropMode);


void __RPC_STUB IProgressBar_put_OLEDropMode_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IProgressBar_get_Appearance_Proxy( 
    IProgressBar * This,
    /* [retval][out] */ AppearanceConstants *penumAppearances);


void __RPC_STUB IProgressBar_get_Appearance_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE IProgressBar_put_Appearance_Proxy( 
    IProgressBar * This,
    /* [in] */ AppearanceConstants penumAppearances);


void __RPC_STUB IProgressBar_put_Appearance_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IProgressBar_get_BorderStyle_Proxy( 
    IProgressBar * This,
    /* [retval][out] */ BorderStyleConstants *penumBorderStyles);


void __RPC_STUB IProgressBar_get_BorderStyle_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE IProgressBar_put_BorderStyle_Proxy( 
    IProgressBar * This,
    /* [in] */ BorderStyleConstants penumBorderStyles);


void __RPC_STUB IProgressBar_put_BorderStyle_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IProgressBar_get_Enabled_Proxy( 
    IProgressBar * This,
    /* [retval][out] */ VARIANT_BOOL *bEnabled);


void __RPC_STUB IProgressBar_get_Enabled_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE IProgressBar_put_Enabled_Proxy( 
    IProgressBar * This,
    /* [in] */ VARIANT_BOOL bEnabled);


void __RPC_STUB IProgressBar_put_Enabled_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IProgressBar_get_hWnd_Proxy( 
    IProgressBar * This,
    /* [retval][out] */ /* external definition not present */ OLE_HANDLE *phWnd);


void __RPC_STUB IProgressBar_get_hWnd_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][id] */ HRESULT STDMETHODCALLTYPE IProgressBar_OLEDrag_Proxy( 
    IProgressBar * This);


void __RPC_STUB IProgressBar_OLEDrag_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [hidden][id] */ HRESULT STDMETHODCALLTYPE IProgressBar_AboutBox_Proxy( 
    IProgressBar * This);


void __RPC_STUB IProgressBar_AboutBox_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IProgressBar_get_Orientation_Proxy( 
    IProgressBar * This,
    /* [retval][out] */ OrientationConstants *penumOrientation);


void __RPC_STUB IProgressBar_get_Orientation_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE IProgressBar_put_Orientation_Proxy( 
    IProgressBar * This,
    /* [in] */ OrientationConstants penumOrientation);


void __RPC_STUB IProgressBar_put_Orientation_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IProgressBar_get_Scrolling_Proxy( 
    IProgressBar * This,
    /* [retval][out] */ ScrollingConstants *penumScrolling);


void __RPC_STUB IProgressBar_get_Scrolling_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE IProgressBar_put_Scrolling_Proxy( 
    IProgressBar * This,
    /* [in] */ ScrollingConstants penumScrolling);


void __RPC_STUB IProgressBar_put_Scrolling_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE IProgressBar_Refresh_Proxy( 
    IProgressBar * This);


void __RPC_STUB IProgressBar_Refresh_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IProgressBar_INTERFACE_DEFINED__ */


#ifndef __IProgressBarEvents_DISPINTERFACE_DEFINED__
#define __IProgressBarEvents_DISPINTERFACE_DEFINED__

/* dispinterface IProgressBarEvents */
/* [nonextensible][helpcontext][helpstring][uuid] */ 


EXTERN_C const IID DIID_IProgressBarEvents;

#if defined(__cplusplus) && !defined(CINTERFACE)

    MIDL_INTERFACE("35053A21-8589-11D1-B16A-00C0F0283628")
    IProgressBarEvents : public IDispatch
    {
    };
    
#else 	/* C style interface */

    typedef struct IProgressBarEventsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IProgressBarEvents * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IProgressBarEvents * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IProgressBarEvents * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IProgressBarEvents * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IProgressBarEvents * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IProgressBarEvents * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IProgressBarEvents * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        END_INTERFACE
    } IProgressBarEventsVtbl;

    interface IProgressBarEvents
    {
        CONST_VTBL struct IProgressBarEventsVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IProgressBarEvents_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IProgressBarEvents_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IProgressBarEvents_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IProgressBarEvents_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IProgressBarEvents_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IProgressBarEvents_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IProgressBarEvents_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)

#endif /* COBJMACROS */


#endif 	/* C style interface */


#endif 	/* __IProgressBarEvents_DISPINTERFACE_DEFINED__ */


#ifndef __ITreeView_INTERFACE_DEFINED__
#define __ITreeView_INTERFACE_DEFINED__

/* interface ITreeView */
/* [object][oleautomation][nonextensible][dual][hidden][helpcontext][helpstring][uuid] */ 


EXTERN_C const IID IID_ITreeView;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("C74190B4-8589-11D1-B16A-00C0F0283628")
    ITreeView : public IDispatch
    {
    public:
        virtual /* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_DropHighlight( 
            /* [retval][out] */ INode **ppNode) = 0;
        
        virtual /* [helpcontext][helpstring][propputref][id] */ HRESULT STDMETHODCALLTYPE putref_DropHighlight( 
            /* [in] */ INode *ppNode) = 0;
        
        virtual /* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_DropHighlight( 
            /* [in] */ VARIANT *ppNode) = 0;
        
        virtual /* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_HideSelection( 
            /* [retval][out] */ VARIANT_BOOL *pbHideSelection) = 0;
        
        virtual /* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_HideSelection( 
            /* [in] */ VARIANT_BOOL pbHideSelection) = 0;
        
        virtual /* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_ImageList( 
            /* [retval][out] */ IDispatch **ppImageList) = 0;
        
        virtual /* [helpcontext][helpstring][propputref][id] */ HRESULT STDMETHODCALLTYPE putref_ImageList( 
            /* [in] */ IDispatch *ppImageList) = 0;
        
        virtual /* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_ImageList( 
            /* [in] */ IDispatch *ppImageList) = 0;
        
        virtual /* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_Indentation( 
            /* [retval][out] */ single *pfIndentation) = 0;
        
        virtual /* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_Indentation( 
            /* [in] */ single pfIndentation) = 0;
        
        virtual /* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_LabelEdit( 
            /* [retval][out] */ LabelEditConstants *psLabelEdit) = 0;
        
        virtual /* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_LabelEdit( 
            /* [in] */ LabelEditConstants psLabelEdit) = 0;
        
        virtual /* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_LineStyle( 
            /* [retval][out] */ TreeLineStyleConstants *psLineStyle) = 0;
        
        virtual /* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_LineStyle( 
            /* [in] */ TreeLineStyleConstants psLineStyle) = 0;
        
        virtual /* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_MousePointer( 
            /* [retval][out] */ MousePointerConstants *psMousePointer) = 0;
        
        virtual /* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_MousePointer( 
            /* [in] */ MousePointerConstants psMousePointer) = 0;
        
        virtual /* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_MouseIcon( 
            /* [retval][out] */ /* external definition not present */ IPictureDisp **ppMouseIcon) = 0;
        
        virtual /* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_MouseIcon( 
            /* [in] */ /* external definition not present */ IPictureDisp *ppMouseIcon) = 0;
        
        virtual /* [helpcontext][helpstring][propputref][id] */ HRESULT STDMETHODCALLTYPE putref_MouseIcon( 
            /* [in] */ /* external definition not present */ IPictureDisp *ppMouseIcon) = 0;
        
        virtual /* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_Nodes( 
            /* [retval][out] */ INodes **ppNode) = 0;
        
        virtual /* [helpcontext][helpstring][propputref][id] */ HRESULT STDMETHODCALLTYPE putref_Nodes( 
            /* [in] */ INodes *ppNode) = 0;
        
        virtual /* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_PathSeparator( 
            /* [retval][out] */ BSTR *pbstrPathSeparator) = 0;
        
        virtual /* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_PathSeparator( 
            /* [in] */ BSTR pbstrPathSeparator) = 0;
        
        virtual /* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_SelectedItem( 
            /* [retval][out] */ INode **ppNode) = 0;
        
        virtual /* [helpcontext][helpstring][propputref][id] */ HRESULT STDMETHODCALLTYPE putref_SelectedItem( 
            /* [in] */ INode *ppNode) = 0;
        
        virtual /* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_SelectedItem( 
            /* [in] */ VARIANT *ppNode) = 0;
        
        virtual /* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_Sorted( 
            /* [retval][out] */ VARIANT_BOOL *pbSorted) = 0;
        
        virtual /* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_Sorted( 
            /* [in] */ VARIANT_BOOL pbSorted) = 0;
        
        virtual /* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_Style( 
            /* [retval][out] */ TreeStyleConstants *psStyle) = 0;
        
        virtual /* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_Style( 
            /* [in] */ TreeStyleConstants psStyle) = 0;
        
        virtual /* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_OLEDragMode( 
            /* [retval][out] */ OLEDragConstants *psOLEDragMode) = 0;
        
        virtual /* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_OLEDragMode( 
            /* [in] */ OLEDragConstants psOLEDragMode) = 0;
        
        virtual /* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_OLEDropMode( 
            /* [retval][out] */ OLEDropConstants *psOLEDropMode) = 0;
        
        virtual /* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_OLEDropMode( 
            /* [in] */ OLEDropConstants psOLEDropMode) = 0;
        
        virtual /* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_Appearance( 
            /* [retval][out] */ AppearanceConstants *psAppearance) = 0;
        
        virtual /* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_Appearance( 
            /* [in] */ AppearanceConstants psAppearance) = 0;
        
        virtual /* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_BorderStyle( 
            /* [retval][out] */ BorderStyleConstants *psBorderStyle) = 0;
        
        virtual /* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_BorderStyle( 
            /* [in] */ BorderStyleConstants psBorderStyle) = 0;
        
        virtual /* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_Enabled( 
            /* [retval][out] */ VARIANT_BOOL *pbEnabled) = 0;
        
        virtual /* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_Enabled( 
            /* [in] */ VARIANT_BOOL pbEnabled) = 0;
        
        virtual /* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_Font( 
            /* [retval][out] */ /* external definition not present */ IFontDisp **ppFont) = 0;
        
        virtual /* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_Font( 
            /* [in] */ /* external definition not present */ IFontDisp *ppFont) = 0;
        
        virtual /* [helpcontext][helpstring][propputref][id] */ HRESULT STDMETHODCALLTYPE putref_Font( 
            /* [in] */ /* external definition not present */ IFontDisp *ppFont) = 0;
        
        virtual /* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_hWnd( 
            /* [retval][out] */ /* external definition not present */ OLE_HANDLE *phWnd) = 0;
        
        virtual /* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_hWnd( 
            /* [in] */ /* external definition not present */ OLE_HANDLE phWnd) = 0;
        
        virtual /* [helpcontext][helpstring][id] */ HRESULT STDMETHODCALLTYPE HitTest( 
            /* [in] */ single x,
            /* [in] */ single y,
            /* [retval][out] */ INode **ppNode) = 0;
        
        virtual /* [helpcontext][helpstring][id] */ HRESULT STDMETHODCALLTYPE GetVisibleCount( 
            /* [retval][out] */ long *plVisibleCount) = 0;
        
        virtual /* [helpcontext][helpstring][id] */ HRESULT STDMETHODCALLTYPE StartLabelEdit( void) = 0;
        
        virtual /* [helpcontext][helpstring][id] */ HRESULT STDMETHODCALLTYPE Refresh( void) = 0;
        
        virtual /* [hidden][id] */ HRESULT STDMETHODCALLTYPE AboutBox( void) = 0;
        
        virtual /* [helpcontext][helpstring][id] */ HRESULT STDMETHODCALLTYPE OLEDrag( void) = 0;
        
        virtual /* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_Checkboxes( 
            /* [retval][out] */ VARIANT_BOOL *pbCheckboxes) = 0;
        
        virtual /* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_Checkboxes( 
            /* [in] */ VARIANT_BOOL pbCheckboxes) = 0;
        
        virtual /* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_FullRowSelect( 
            /* [retval][out] */ VARIANT_BOOL *pbFullRowSelect) = 0;
        
        virtual /* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_FullRowSelect( 
            /* [in] */ VARIANT_BOOL pbFullRowSelect) = 0;
        
        virtual /* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_HotTracking( 
            /* [retval][out] */ VARIANT_BOOL *pbHotTracking) = 0;
        
        virtual /* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_HotTracking( 
            /* [in] */ VARIANT_BOOL pbHotTracking) = 0;
        
        virtual /* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_Scroll( 
            /* [retval][out] */ VARIANT_BOOL *pbScroll) = 0;
        
        virtual /* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_Scroll( 
            /* [in] */ VARIANT_BOOL pbScroll) = 0;
        
        virtual /* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_SingleSel( 
            /* [retval][out] */ VARIANT_BOOL *pbSingleSel) = 0;
        
        virtual /* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_SingleSel( 
            /* [in] */ VARIANT_BOOL pbSingleSel) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITreeViewVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ITreeView * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ITreeView * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ITreeView * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            ITreeView * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            ITreeView * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            ITreeView * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            ITreeView * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_DropHighlight )( 
            ITreeView * This,
            /* [retval][out] */ INode **ppNode);
        
        /* [helpcontext][helpstring][propputref][id] */ HRESULT ( STDMETHODCALLTYPE *putref_DropHighlight )( 
            ITreeView * This,
            /* [in] */ INode *ppNode);
        
        /* [helpcontext][helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_DropHighlight )( 
            ITreeView * This,
            /* [in] */ VARIANT *ppNode);
        
        /* [helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_HideSelection )( 
            ITreeView * This,
            /* [retval][out] */ VARIANT_BOOL *pbHideSelection);
        
        /* [helpcontext][helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_HideSelection )( 
            ITreeView * This,
            /* [in] */ VARIANT_BOOL pbHideSelection);
        
        /* [helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_ImageList )( 
            ITreeView * This,
            /* [retval][out] */ IDispatch **ppImageList);
        
        /* [helpcontext][helpstring][propputref][id] */ HRESULT ( STDMETHODCALLTYPE *putref_ImageList )( 
            ITreeView * This,
            /* [in] */ IDispatch *ppImageList);
        
        /* [helpcontext][helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_ImageList )( 
            ITreeView * This,
            /* [in] */ IDispatch *ppImageList);
        
        /* [helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_Indentation )( 
            ITreeView * This,
            /* [retval][out] */ single *pfIndentation);
        
        /* [helpcontext][helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_Indentation )( 
            ITreeView * This,
            /* [in] */ single pfIndentation);
        
        /* [helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_LabelEdit )( 
            ITreeView * This,
            /* [retval][out] */ LabelEditConstants *psLabelEdit);
        
        /* [helpcontext][helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_LabelEdit )( 
            ITreeView * This,
            /* [in] */ LabelEditConstants psLabelEdit);
        
        /* [helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_LineStyle )( 
            ITreeView * This,
            /* [retval][out] */ TreeLineStyleConstants *psLineStyle);
        
        /* [helpcontext][helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_LineStyle )( 
            ITreeView * This,
            /* [in] */ TreeLineStyleConstants psLineStyle);
        
        /* [helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_MousePointer )( 
            ITreeView * This,
            /* [retval][out] */ MousePointerConstants *psMousePointer);
        
        /* [helpcontext][helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_MousePointer )( 
            ITreeView * This,
            /* [in] */ MousePointerConstants psMousePointer);
        
        /* [helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_MouseIcon )( 
            ITreeView * This,
            /* [retval][out] */ /* external definition not present */ IPictureDisp **ppMouseIcon);
        
        /* [helpcontext][helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_MouseIcon )( 
            ITreeView * This,
            /* [in] */ /* external definition not present */ IPictureDisp *ppMouseIcon);
        
        /* [helpcontext][helpstring][propputref][id] */ HRESULT ( STDMETHODCALLTYPE *putref_MouseIcon )( 
            ITreeView * This,
            /* [in] */ /* external definition not present */ IPictureDisp *ppMouseIcon);
        
        /* [helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_Nodes )( 
            ITreeView * This,
            /* [retval][out] */ INodes **ppNode);
        
        /* [helpcontext][helpstring][propputref][id] */ HRESULT ( STDMETHODCALLTYPE *putref_Nodes )( 
            ITreeView * This,
            /* [in] */ INodes *ppNode);
        
        /* [helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_PathSeparator )( 
            ITreeView * This,
            /* [retval][out] */ BSTR *pbstrPathSeparator);
        
        /* [helpcontext][helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_PathSeparator )( 
            ITreeView * This,
            /* [in] */ BSTR pbstrPathSeparator);
        
        /* [helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_SelectedItem )( 
            ITreeView * This,
            /* [retval][out] */ INode **ppNode);
        
        /* [helpcontext][helpstring][propputref][id] */ HRESULT ( STDMETHODCALLTYPE *putref_SelectedItem )( 
            ITreeView * This,
            /* [in] */ INode *ppNode);
        
        /* [helpcontext][helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_SelectedItem )( 
            ITreeView * This,
            /* [in] */ VARIANT *ppNode);
        
        /* [helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_Sorted )( 
            ITreeView * This,
            /* [retval][out] */ VARIANT_BOOL *pbSorted);
        
        /* [helpcontext][helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_Sorted )( 
            ITreeView * This,
            /* [in] */ VARIANT_BOOL pbSorted);
        
        /* [helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_Style )( 
            ITreeView * This,
            /* [retval][out] */ TreeStyleConstants *psStyle);
        
        /* [helpcontext][helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_Style )( 
            ITreeView * This,
            /* [in] */ TreeStyleConstants psStyle);
        
        /* [helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_OLEDragMode )( 
            ITreeView * This,
            /* [retval][out] */ OLEDragConstants *psOLEDragMode);
        
        /* [helpcontext][helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_OLEDragMode )( 
            ITreeView * This,
            /* [in] */ OLEDragConstants psOLEDragMode);
        
        /* [helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_OLEDropMode )( 
            ITreeView * This,
            /* [retval][out] */ OLEDropConstants *psOLEDropMode);
        
        /* [helpcontext][helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_OLEDropMode )( 
            ITreeView * This,
            /* [in] */ OLEDropConstants psOLEDropMode);
        
        /* [helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_Appearance )( 
            ITreeView * This,
            /* [retval][out] */ AppearanceConstants *psAppearance);
        
        /* [helpcontext][helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_Appearance )( 
            ITreeView * This,
            /* [in] */ AppearanceConstants psAppearance);
        
        /* [helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_BorderStyle )( 
            ITreeView * This,
            /* [retval][out] */ BorderStyleConstants *psBorderStyle);
        
        /* [helpcontext][helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_BorderStyle )( 
            ITreeView * This,
            /* [in] */ BorderStyleConstants psBorderStyle);
        
        /* [helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_Enabled )( 
            ITreeView * This,
            /* [retval][out] */ VARIANT_BOOL *pbEnabled);
        
        /* [helpcontext][helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_Enabled )( 
            ITreeView * This,
            /* [in] */ VARIANT_BOOL pbEnabled);
        
        /* [helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_Font )( 
            ITreeView * This,
            /* [retval][out] */ /* external definition not present */ IFontDisp **ppFont);
        
        /* [helpcontext][helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_Font )( 
            ITreeView * This,
            /* [in] */ /* external definition not present */ IFontDisp *ppFont);
        
        /* [helpcontext][helpstring][propputref][id] */ HRESULT ( STDMETHODCALLTYPE *putref_Font )( 
            ITreeView * This,
            /* [in] */ /* external definition not present */ IFontDisp *ppFont);
        
        /* [helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_hWnd )( 
            ITreeView * This,
            /* [retval][out] */ /* external definition not present */ OLE_HANDLE *phWnd);
        
        /* [helpcontext][helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_hWnd )( 
            ITreeView * This,
            /* [in] */ /* external definition not present */ OLE_HANDLE phWnd);
        
        /* [helpcontext][helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *HitTest )( 
            ITreeView * This,
            /* [in] */ single x,
            /* [in] */ single y,
            /* [retval][out] */ INode **ppNode);
        
        /* [helpcontext][helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *GetVisibleCount )( 
            ITreeView * This,
            /* [retval][out] */ long *plVisibleCount);
        
        /* [helpcontext][helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *StartLabelEdit )( 
            ITreeView * This);
        
        /* [helpcontext][helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Refresh )( 
            ITreeView * This);
        
        /* [hidden][id] */ HRESULT ( STDMETHODCALLTYPE *AboutBox )( 
            ITreeView * This);
        
        /* [helpcontext][helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *OLEDrag )( 
            ITreeView * This);
        
        /* [helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_Checkboxes )( 
            ITreeView * This,
            /* [retval][out] */ VARIANT_BOOL *pbCheckboxes);
        
        /* [helpcontext][helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_Checkboxes )( 
            ITreeView * This,
            /* [in] */ VARIANT_BOOL pbCheckboxes);
        
        /* [helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_FullRowSelect )( 
            ITreeView * This,
            /* [retval][out] */ VARIANT_BOOL *pbFullRowSelect);
        
        /* [helpcontext][helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_FullRowSelect )( 
            ITreeView * This,
            /* [in] */ VARIANT_BOOL pbFullRowSelect);
        
        /* [helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_HotTracking )( 
            ITreeView * This,
            /* [retval][out] */ VARIANT_BOOL *pbHotTracking);
        
        /* [helpcontext][helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_HotTracking )( 
            ITreeView * This,
            /* [in] */ VARIANT_BOOL pbHotTracking);
        
        /* [helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_Scroll )( 
            ITreeView * This,
            /* [retval][out] */ VARIANT_BOOL *pbScroll);
        
        /* [helpcontext][helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_Scroll )( 
            ITreeView * This,
            /* [in] */ VARIANT_BOOL pbScroll);
        
        /* [helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_SingleSel )( 
            ITreeView * This,
            /* [retval][out] */ VARIANT_BOOL *pbSingleSel);
        
        /* [helpcontext][helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_SingleSel )( 
            ITreeView * This,
            /* [in] */ VARIANT_BOOL pbSingleSel);
        
        END_INTERFACE
    } ITreeViewVtbl;

    interface ITreeView
    {
        CONST_VTBL struct ITreeViewVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITreeView_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ITreeView_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ITreeView_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ITreeView_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define ITreeView_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define ITreeView_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define ITreeView_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define ITreeView_get_DropHighlight(This,ppNode)	\
    (This)->lpVtbl -> get_DropHighlight(This,ppNode)

#define ITreeView_putref_DropHighlight(This,ppNode)	\
    (This)->lpVtbl -> putref_DropHighlight(This,ppNode)

#define ITreeView_put_DropHighlight(This,ppNode)	\
    (This)->lpVtbl -> put_DropHighlight(This,ppNode)

#define ITreeView_get_HideSelection(This,pbHideSelection)	\
    (This)->lpVtbl -> get_HideSelection(This,pbHideSelection)

#define ITreeView_put_HideSelection(This,pbHideSelection)	\
    (This)->lpVtbl -> put_HideSelection(This,pbHideSelection)

#define ITreeView_get_ImageList(This,ppImageList)	\
    (This)->lpVtbl -> get_ImageList(This,ppImageList)

#define ITreeView_putref_ImageList(This,ppImageList)	\
    (This)->lpVtbl -> putref_ImageList(This,ppImageList)

#define ITreeView_put_ImageList(This,ppImageList)	\
    (This)->lpVtbl -> put_ImageList(This,ppImageList)

#define ITreeView_get_Indentation(This,pfIndentation)	\
    (This)->lpVtbl -> get_Indentation(This,pfIndentation)

#define ITreeView_put_Indentation(This,pfIndentation)	\
    (This)->lpVtbl -> put_Indentation(This,pfIndentation)

#define ITreeView_get_LabelEdit(This,psLabelEdit)	\
    (This)->lpVtbl -> get_LabelEdit(This,psLabelEdit)

#define ITreeView_put_LabelEdit(This,psLabelEdit)	\
    (This)->lpVtbl -> put_LabelEdit(This,psLabelEdit)

#define ITreeView_get_LineStyle(This,psLineStyle)	\
    (This)->lpVtbl -> get_LineStyle(This,psLineStyle)

#define ITreeView_put_LineStyle(This,psLineStyle)	\
    (This)->lpVtbl -> put_LineStyle(This,psLineStyle)

#define ITreeView_get_MousePointer(This,psMousePointer)	\
    (This)->lpVtbl -> get_MousePointer(This,psMousePointer)

#define ITreeView_put_MousePointer(This,psMousePointer)	\
    (This)->lpVtbl -> put_MousePointer(This,psMousePointer)

#define ITreeView_get_MouseIcon(This,ppMouseIcon)	\
    (This)->lpVtbl -> get_MouseIcon(This,ppMouseIcon)

#define ITreeView_put_MouseIcon(This,ppMouseIcon)	\
    (This)->lpVtbl -> put_MouseIcon(This,ppMouseIcon)

#define ITreeView_putref_MouseIcon(This,ppMouseIcon)	\
    (This)->lpVtbl -> putref_MouseIcon(This,ppMouseIcon)

#define ITreeView_get_Nodes(This,ppNode)	\
    (This)->lpVtbl -> get_Nodes(This,ppNode)

#define ITreeView_putref_Nodes(This,ppNode)	\
    (This)->lpVtbl -> putref_Nodes(This,ppNode)

#define ITreeView_get_PathSeparator(This,pbstrPathSeparator)	\
    (This)->lpVtbl -> get_PathSeparator(This,pbstrPathSeparator)

#define ITreeView_put_PathSeparator(This,pbstrPathSeparator)	\
    (This)->lpVtbl -> put_PathSeparator(This,pbstrPathSeparator)

#define ITreeView_get_SelectedItem(This,ppNode)	\
    (This)->lpVtbl -> get_SelectedItem(This,ppNode)

#define ITreeView_putref_SelectedItem(This,ppNode)	\
    (This)->lpVtbl -> putref_SelectedItem(This,ppNode)

#define ITreeView_put_SelectedItem(This,ppNode)	\
    (This)->lpVtbl -> put_SelectedItem(This,ppNode)

#define ITreeView_get_Sorted(This,pbSorted)	\
    (This)->lpVtbl -> get_Sorted(This,pbSorted)

#define ITreeView_put_Sorted(This,pbSorted)	\
    (This)->lpVtbl -> put_Sorted(This,pbSorted)

#define ITreeView_get_Style(This,psStyle)	\
    (This)->lpVtbl -> get_Style(This,psStyle)

#define ITreeView_put_Style(This,psStyle)	\
    (This)->lpVtbl -> put_Style(This,psStyle)

#define ITreeView_get_OLEDragMode(This,psOLEDragMode)	\
    (This)->lpVtbl -> get_OLEDragMode(This,psOLEDragMode)

#define ITreeView_put_OLEDragMode(This,psOLEDragMode)	\
    (This)->lpVtbl -> put_OLEDragMode(This,psOLEDragMode)

#define ITreeView_get_OLEDropMode(This,psOLEDropMode)	\
    (This)->lpVtbl -> get_OLEDropMode(This,psOLEDropMode)

#define ITreeView_put_OLEDropMode(This,psOLEDropMode)	\
    (This)->lpVtbl -> put_OLEDropMode(This,psOLEDropMode)

#define ITreeView_get_Appearance(This,psAppearance)	\
    (This)->lpVtbl -> get_Appearance(This,psAppearance)

#define ITreeView_put_Appearance(This,psAppearance)	\
    (This)->lpVtbl -> put_Appearance(This,psAppearance)

#define ITreeView_get_BorderStyle(This,psBorderStyle)	\
    (This)->lpVtbl -> get_BorderStyle(This,psBorderStyle)

#define ITreeView_put_BorderStyle(This,psBorderStyle)	\
    (This)->lpVtbl -> put_BorderStyle(This,psBorderStyle)

#define ITreeView_get_Enabled(This,pbEnabled)	\
    (This)->lpVtbl -> get_Enabled(This,pbEnabled)

#define ITreeView_put_Enabled(This,pbEnabled)	\
    (This)->lpVtbl -> put_Enabled(This,pbEnabled)

#define ITreeView_get_Font(This,ppFont)	\
    (This)->lpVtbl -> get_Font(This,ppFont)

#define ITreeView_put_Font(This,ppFont)	\
    (This)->lpVtbl -> put_Font(This,ppFont)

#define ITreeView_putref_Font(This,ppFont)	\
    (This)->lpVtbl -> putref_Font(This,ppFont)

#define ITreeView_get_hWnd(This,phWnd)	\
    (This)->lpVtbl -> get_hWnd(This,phWnd)

#define ITreeView_put_hWnd(This,phWnd)	\
    (This)->lpVtbl -> put_hWnd(This,phWnd)

#define ITreeView_HitTest(This,x,y,ppNode)	\
    (This)->lpVtbl -> HitTest(This,x,y,ppNode)

#define ITreeView_GetVisibleCount(This,plVisibleCount)	\
    (This)->lpVtbl -> GetVisibleCount(This,plVisibleCount)

#define ITreeView_StartLabelEdit(This)	\
    (This)->lpVtbl -> StartLabelEdit(This)

#define ITreeView_Refresh(This)	\
    (This)->lpVtbl -> Refresh(This)

#define ITreeView_AboutBox(This)	\
    (This)->lpVtbl -> AboutBox(This)

#define ITreeView_OLEDrag(This)	\
    (This)->lpVtbl -> OLEDrag(This)

#define ITreeView_get_Checkboxes(This,pbCheckboxes)	\
    (This)->lpVtbl -> get_Checkboxes(This,pbCheckboxes)

#define ITreeView_put_Checkboxes(This,pbCheckboxes)	\
    (This)->lpVtbl -> put_Checkboxes(This,pbCheckboxes)

#define ITreeView_get_FullRowSelect(This,pbFullRowSelect)	\
    (This)->lpVtbl -> get_FullRowSelect(This,pbFullRowSelect)

#define ITreeView_put_FullRowSelect(This,pbFullRowSelect)	\
    (This)->lpVtbl -> put_FullRowSelect(This,pbFullRowSelect)

#define ITreeView_get_HotTracking(This,pbHotTracking)	\
    (This)->lpVtbl -> get_HotTracking(This,pbHotTracking)

#define ITreeView_put_HotTracking(This,pbHotTracking)	\
    (This)->lpVtbl -> put_HotTracking(This,pbHotTracking)

#define ITreeView_get_Scroll(This,pbScroll)	\
    (This)->lpVtbl -> get_Scroll(This,pbScroll)

#define ITreeView_put_Scroll(This,pbScroll)	\
    (This)->lpVtbl -> put_Scroll(This,pbScroll)

#define ITreeView_get_SingleSel(This,pbSingleSel)	\
    (This)->lpVtbl -> get_SingleSel(This,pbSingleSel)

#define ITreeView_put_SingleSel(This,pbSingleSel)	\
    (This)->lpVtbl -> put_SingleSel(This,pbSingleSel)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE ITreeView_get_DropHighlight_Proxy( 
    ITreeView * This,
    /* [retval][out] */ INode **ppNode);


void __RPC_STUB ITreeView_get_DropHighlight_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propputref][id] */ HRESULT STDMETHODCALLTYPE ITreeView_putref_DropHighlight_Proxy( 
    ITreeView * This,
    /* [in] */ INode *ppNode);


void __RPC_STUB ITreeView_putref_DropHighlight_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE ITreeView_put_DropHighlight_Proxy( 
    ITreeView * This,
    /* [in] */ VARIANT *ppNode);


void __RPC_STUB ITreeView_put_DropHighlight_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE ITreeView_get_HideSelection_Proxy( 
    ITreeView * This,
    /* [retval][out] */ VARIANT_BOOL *pbHideSelection);


void __RPC_STUB ITreeView_get_HideSelection_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE ITreeView_put_HideSelection_Proxy( 
    ITreeView * This,
    /* [in] */ VARIANT_BOOL pbHideSelection);


void __RPC_STUB ITreeView_put_HideSelection_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE ITreeView_get_ImageList_Proxy( 
    ITreeView * This,
    /* [retval][out] */ IDispatch **ppImageList);


void __RPC_STUB ITreeView_get_ImageList_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propputref][id] */ HRESULT STDMETHODCALLTYPE ITreeView_putref_ImageList_Proxy( 
    ITreeView * This,
    /* [in] */ IDispatch *ppImageList);


void __RPC_STUB ITreeView_putref_ImageList_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE ITreeView_put_ImageList_Proxy( 
    ITreeView * This,
    /* [in] */ IDispatch *ppImageList);


void __RPC_STUB ITreeView_put_ImageList_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE ITreeView_get_Indentation_Proxy( 
    ITreeView * This,
    /* [retval][out] */ single *pfIndentation);


void __RPC_STUB ITreeView_get_Indentation_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE ITreeView_put_Indentation_Proxy( 
    ITreeView * This,
    /* [in] */ single pfIndentation);


void __RPC_STUB ITreeView_put_Indentation_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE ITreeView_get_LabelEdit_Proxy( 
    ITreeView * This,
    /* [retval][out] */ LabelEditConstants *psLabelEdit);


void __RPC_STUB ITreeView_get_LabelEdit_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE ITreeView_put_LabelEdit_Proxy( 
    ITreeView * This,
    /* [in] */ LabelEditConstants psLabelEdit);


void __RPC_STUB ITreeView_put_LabelEdit_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE ITreeView_get_LineStyle_Proxy( 
    ITreeView * This,
    /* [retval][out] */ TreeLineStyleConstants *psLineStyle);


void __RPC_STUB ITreeView_get_LineStyle_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE ITreeView_put_LineStyle_Proxy( 
    ITreeView * This,
    /* [in] */ TreeLineStyleConstants psLineStyle);


void __RPC_STUB ITreeView_put_LineStyle_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE ITreeView_get_MousePointer_Proxy( 
    ITreeView * This,
    /* [retval][out] */ MousePointerConstants *psMousePointer);


void __RPC_STUB ITreeView_get_MousePointer_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE ITreeView_put_MousePointer_Proxy( 
    ITreeView * This,
    /* [in] */ MousePointerConstants psMousePointer);


void __RPC_STUB ITreeView_put_MousePointer_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE ITreeView_get_MouseIcon_Proxy( 
    ITreeView * This,
    /* [retval][out] */ /* external definition not present */ IPictureDisp **ppMouseIcon);


void __RPC_STUB ITreeView_get_MouseIcon_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE ITreeView_put_MouseIcon_Proxy( 
    ITreeView * This,
    /* [in] */ /* external definition not present */ IPictureDisp *ppMouseIcon);


void __RPC_STUB ITreeView_put_MouseIcon_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propputref][id] */ HRESULT STDMETHODCALLTYPE ITreeView_putref_MouseIcon_Proxy( 
    ITreeView * This,
    /* [in] */ /* external definition not present */ IPictureDisp *ppMouseIcon);


void __RPC_STUB ITreeView_putref_MouseIcon_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE ITreeView_get_Nodes_Proxy( 
    ITreeView * This,
    /* [retval][out] */ INodes **ppNode);


void __RPC_STUB ITreeView_get_Nodes_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propputref][id] */ HRESULT STDMETHODCALLTYPE ITreeView_putref_Nodes_Proxy( 
    ITreeView * This,
    /* [in] */ INodes *ppNode);


void __RPC_STUB ITreeView_putref_Nodes_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE ITreeView_get_PathSeparator_Proxy( 
    ITreeView * This,
    /* [retval][out] */ BSTR *pbstrPathSeparator);


void __RPC_STUB ITreeView_get_PathSeparator_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE ITreeView_put_PathSeparator_Proxy( 
    ITreeView * This,
    /* [in] */ BSTR pbstrPathSeparator);


void __RPC_STUB ITreeView_put_PathSeparator_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE ITreeView_get_SelectedItem_Proxy( 
    ITreeView * This,
    /* [retval][out] */ INode **ppNode);


void __RPC_STUB ITreeView_get_SelectedItem_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propputref][id] */ HRESULT STDMETHODCALLTYPE ITreeView_putref_SelectedItem_Proxy( 
    ITreeView * This,
    /* [in] */ INode *ppNode);


void __RPC_STUB ITreeView_putref_SelectedItem_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE ITreeView_put_SelectedItem_Proxy( 
    ITreeView * This,
    /* [in] */ VARIANT *ppNode);


void __RPC_STUB ITreeView_put_SelectedItem_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE ITreeView_get_Sorted_Proxy( 
    ITreeView * This,
    /* [retval][out] */ VARIANT_BOOL *pbSorted);


void __RPC_STUB ITreeView_get_Sorted_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE ITreeView_put_Sorted_Proxy( 
    ITreeView * This,
    /* [in] */ VARIANT_BOOL pbSorted);


void __RPC_STUB ITreeView_put_Sorted_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE ITreeView_get_Style_Proxy( 
    ITreeView * This,
    /* [retval][out] */ TreeStyleConstants *psStyle);


void __RPC_STUB ITreeView_get_Style_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE ITreeView_put_Style_Proxy( 
    ITreeView * This,
    /* [in] */ TreeStyleConstants psStyle);


void __RPC_STUB ITreeView_put_Style_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE ITreeView_get_OLEDragMode_Proxy( 
    ITreeView * This,
    /* [retval][out] */ OLEDragConstants *psOLEDragMode);


void __RPC_STUB ITreeView_get_OLEDragMode_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE ITreeView_put_OLEDragMode_Proxy( 
    ITreeView * This,
    /* [in] */ OLEDragConstants psOLEDragMode);


void __RPC_STUB ITreeView_put_OLEDragMode_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE ITreeView_get_OLEDropMode_Proxy( 
    ITreeView * This,
    /* [retval][out] */ OLEDropConstants *psOLEDropMode);


void __RPC_STUB ITreeView_get_OLEDropMode_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE ITreeView_put_OLEDropMode_Proxy( 
    ITreeView * This,
    /* [in] */ OLEDropConstants psOLEDropMode);


void __RPC_STUB ITreeView_put_OLEDropMode_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE ITreeView_get_Appearance_Proxy( 
    ITreeView * This,
    /* [retval][out] */ AppearanceConstants *psAppearance);


void __RPC_STUB ITreeView_get_Appearance_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE ITreeView_put_Appearance_Proxy( 
    ITreeView * This,
    /* [in] */ AppearanceConstants psAppearance);


void __RPC_STUB ITreeView_put_Appearance_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE ITreeView_get_BorderStyle_Proxy( 
    ITreeView * This,
    /* [retval][out] */ BorderStyleConstants *psBorderStyle);


void __RPC_STUB ITreeView_get_BorderStyle_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE ITreeView_put_BorderStyle_Proxy( 
    ITreeView * This,
    /* [in] */ BorderStyleConstants psBorderStyle);


void __RPC_STUB ITreeView_put_BorderStyle_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE ITreeView_get_Enabled_Proxy( 
    ITreeView * This,
    /* [retval][out] */ VARIANT_BOOL *pbEnabled);


void __RPC_STUB ITreeView_get_Enabled_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE ITreeView_put_Enabled_Proxy( 
    ITreeView * This,
    /* [in] */ VARIANT_BOOL pbEnabled);


void __RPC_STUB ITreeView_put_Enabled_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE ITreeView_get_Font_Proxy( 
    ITreeView * This,
    /* [retval][out] */ /* external definition not present */ IFontDisp **ppFont);


void __RPC_STUB ITreeView_get_Font_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE ITreeView_put_Font_Proxy( 
    ITreeView * This,
    /* [in] */ /* external definition not present */ IFontDisp *ppFont);


void __RPC_STUB ITreeView_put_Font_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propputref][id] */ HRESULT STDMETHODCALLTYPE ITreeView_putref_Font_Proxy( 
    ITreeView * This,
    /* [in] */ /* external definition not present */ IFontDisp *ppFont);


void __RPC_STUB ITreeView_putref_Font_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE ITreeView_get_hWnd_Proxy( 
    ITreeView * This,
    /* [retval][out] */ /* external definition not present */ OLE_HANDLE *phWnd);


void __RPC_STUB ITreeView_get_hWnd_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE ITreeView_put_hWnd_Proxy( 
    ITreeView * This,
    /* [in] */ /* external definition not present */ OLE_HANDLE phWnd);


void __RPC_STUB ITreeView_put_hWnd_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][id] */ HRESULT STDMETHODCALLTYPE ITreeView_HitTest_Proxy( 
    ITreeView * This,
    /* [in] */ single x,
    /* [in] */ single y,
    /* [retval][out] */ INode **ppNode);


void __RPC_STUB ITreeView_HitTest_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][id] */ HRESULT STDMETHODCALLTYPE ITreeView_GetVisibleCount_Proxy( 
    ITreeView * This,
    /* [retval][out] */ long *plVisibleCount);


void __RPC_STUB ITreeView_GetVisibleCount_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][id] */ HRESULT STDMETHODCALLTYPE ITreeView_StartLabelEdit_Proxy( 
    ITreeView * This);


void __RPC_STUB ITreeView_StartLabelEdit_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][id] */ HRESULT STDMETHODCALLTYPE ITreeView_Refresh_Proxy( 
    ITreeView * This);


void __RPC_STUB ITreeView_Refresh_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [hidden][id] */ HRESULT STDMETHODCALLTYPE ITreeView_AboutBox_Proxy( 
    ITreeView * This);


void __RPC_STUB ITreeView_AboutBox_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][id] */ HRESULT STDMETHODCALLTYPE ITreeView_OLEDrag_Proxy( 
    ITreeView * This);


void __RPC_STUB ITreeView_OLEDrag_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE ITreeView_get_Checkboxes_Proxy( 
    ITreeView * This,
    /* [retval][out] */ VARIANT_BOOL *pbCheckboxes);


void __RPC_STUB ITreeView_get_Checkboxes_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE ITreeView_put_Checkboxes_Proxy( 
    ITreeView * This,
    /* [in] */ VARIANT_BOOL pbCheckboxes);


void __RPC_STUB ITreeView_put_Checkboxes_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE ITreeView_get_FullRowSelect_Proxy( 
    ITreeView * This,
    /* [retval][out] */ VARIANT_BOOL *pbFullRowSelect);


void __RPC_STUB ITreeView_get_FullRowSelect_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE ITreeView_put_FullRowSelect_Proxy( 
    ITreeView * This,
    /* [in] */ VARIANT_BOOL pbFullRowSelect);


void __RPC_STUB ITreeView_put_FullRowSelect_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE ITreeView_get_HotTracking_Proxy( 
    ITreeView * This,
    /* [retval][out] */ VARIANT_BOOL *pbHotTracking);


void __RPC_STUB ITreeView_get_HotTracking_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE ITreeView_put_HotTracking_Proxy( 
    ITreeView * This,
    /* [in] */ VARIANT_BOOL pbHotTracking);


void __RPC_STUB ITreeView_put_HotTracking_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE ITreeView_get_Scroll_Proxy( 
    ITreeView * This,
    /* [retval][out] */ VARIANT_BOOL *pbScroll);


void __RPC_STUB ITreeView_get_Scroll_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE ITreeView_put_Scroll_Proxy( 
    ITreeView * This,
    /* [in] */ VARIANT_BOOL pbScroll);


void __RPC_STUB ITreeView_put_Scroll_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE ITreeView_get_SingleSel_Proxy( 
    ITreeView * This,
    /* [retval][out] */ VARIANT_BOOL *pbSingleSel);


void __RPC_STUB ITreeView_get_SingleSel_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE ITreeView_put_SingleSel_Proxy( 
    ITreeView * This,
    /* [in] */ VARIANT_BOOL pbSingleSel);


void __RPC_STUB ITreeView_put_SingleSel_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ITreeView_INTERFACE_DEFINED__ */


#ifndef __ITreeViewEvents_DISPINTERFACE_DEFINED__
#define __ITreeViewEvents_DISPINTERFACE_DEFINED__

/* dispinterface ITreeViewEvents */
/* [nonextensible][helpcontext][helpstring][uuid] */ 


EXTERN_C const IID DIID_ITreeViewEvents;

#if defined(__cplusplus) && !defined(CINTERFACE)

    MIDL_INTERFACE("C74190B5-8589-11D1-B16A-00C0F0283628")
    ITreeViewEvents : public IDispatch
    {
    };
    
#else 	/* C style interface */

    typedef struct ITreeViewEventsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ITreeViewEvents * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ITreeViewEvents * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ITreeViewEvents * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            ITreeViewEvents * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            ITreeViewEvents * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            ITreeViewEvents * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            ITreeViewEvents * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        END_INTERFACE
    } ITreeViewEventsVtbl;

    interface ITreeViewEvents
    {
        CONST_VTBL struct ITreeViewEventsVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITreeViewEvents_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ITreeViewEvents_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ITreeViewEvents_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ITreeViewEvents_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define ITreeViewEvents_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define ITreeViewEvents_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define ITreeViewEvents_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)

#endif /* COBJMACROS */


#endif 	/* C style interface */


#endif 	/* __ITreeViewEvents_DISPINTERFACE_DEFINED__ */


#ifndef __INodes_INTERFACE_DEFINED__
#define __INodes_INTERFACE_DEFINED__

/* interface INodes */
/* [object][oleautomation][nonextensible][dual][hidden][helpcontext][helpstring][uuid] */ 


EXTERN_C const IID IID_INodes;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("C74190B7-8589-11D1-B16A-00C0F0283628")
    INodes : public IDispatch
    {
    public:
        virtual /* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_Count( 
            /* [retval][out] */ short *psCount) = 0;
        
        virtual /* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_Count( 
            /* [in] */ short psCount) = 0;
        
        virtual /* [hidden][propget][id] */ HRESULT STDMETHODCALLTYPE get_ControlDefault( 
            /* [in] */ VARIANT *Index,
            /* [retval][out] */ INode **ppNode) = 0;
        
        virtual /* [hidden][propput][id] */ HRESULT STDMETHODCALLTYPE put_ControlDefault( 
            /* [in] */ VARIANT *Index,
            /* [in] */ INode *ppNode) = 0;
        
        virtual /* [helpcontext][helpstring][id] */ HRESULT STDMETHODCALLTYPE Add( 
            /* [optional][in] */ VARIANT *Relative,
            /* [optional][in] */ VARIANT *Relationship,
            /* [optional][in] */ VARIANT *Key,
            /* [optional][in] */ VARIANT *Text,
            /* [optional][in] */ VARIANT *Image,
            /* [optional][in] */ VARIANT *SelectedImage,
            /* [retval][out] */ INode **ppNode) = 0;
        
        virtual /* [helpcontext][helpstring][id] */ HRESULT STDMETHODCALLTYPE Clear( void) = 0;
        
        virtual /* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_Item( 
            /* [in] */ VARIANT *Index,
            /* [retval][out] */ INode **ppNode) = 0;
        
        virtual /* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_Item( 
            /* [in] */ VARIANT *Index,
            /* [in] */ INode *ppNode) = 0;
        
        virtual /* [helpcontext][helpstring][id] */ HRESULT STDMETHODCALLTYPE Remove( 
            /* [in] */ VARIANT *Index) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE _NewEnum( 
            /* [retval][out] */ IDispatch **ppNewEnum) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct INodesVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            INodes * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            INodes * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            INodes * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            INodes * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            INodes * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            INodes * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            INodes * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_Count )( 
            INodes * This,
            /* [retval][out] */ short *psCount);
        
        /* [helpcontext][helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_Count )( 
            INodes * This,
            /* [in] */ short psCount);
        
        /* [hidden][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_ControlDefault )( 
            INodes * This,
            /* [in] */ VARIANT *Index,
            /* [retval][out] */ INode **ppNode);
        
        /* [hidden][propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_ControlDefault )( 
            INodes * This,
            /* [in] */ VARIANT *Index,
            /* [in] */ INode *ppNode);
        
        /* [helpcontext][helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Add )( 
            INodes * This,
            /* [optional][in] */ VARIANT *Relative,
            /* [optional][in] */ VARIANT *Relationship,
            /* [optional][in] */ VARIANT *Key,
            /* [optional][in] */ VARIANT *Text,
            /* [optional][in] */ VARIANT *Image,
            /* [optional][in] */ VARIANT *SelectedImage,
            /* [retval][out] */ INode **ppNode);
        
        /* [helpcontext][helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Clear )( 
            INodes * This);
        
        /* [helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_Item )( 
            INodes * This,
            /* [in] */ VARIANT *Index,
            /* [retval][out] */ INode **ppNode);
        
        /* [helpcontext][helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_Item )( 
            INodes * This,
            /* [in] */ VARIANT *Index,
            /* [in] */ INode *ppNode);
        
        /* [helpcontext][helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Remove )( 
            INodes * This,
            /* [in] */ VARIANT *Index);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE *_NewEnum )( 
            INodes * This,
            /* [retval][out] */ IDispatch **ppNewEnum);
        
        END_INTERFACE
    } INodesVtbl;

    interface INodes
    {
        CONST_VTBL struct INodesVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define INodes_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define INodes_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define INodes_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define INodes_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define INodes_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define INodes_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define INodes_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define INodes_get_Count(This,psCount)	\
    (This)->lpVtbl -> get_Count(This,psCount)

#define INodes_put_Count(This,psCount)	\
    (This)->lpVtbl -> put_Count(This,psCount)

#define INodes_get_ControlDefault(This,Index,ppNode)	\
    (This)->lpVtbl -> get_ControlDefault(This,Index,ppNode)

#define INodes_put_ControlDefault(This,Index,ppNode)	\
    (This)->lpVtbl -> put_ControlDefault(This,Index,ppNode)

#define INodes_Add(This,Relative,Relationship,Key,Text,Image,SelectedImage,ppNode)	\
    (This)->lpVtbl -> Add(This,Relative,Relationship,Key,Text,Image,SelectedImage,ppNode)

#define INodes_Clear(This)	\
    (This)->lpVtbl -> Clear(This)

#define INodes_get_Item(This,Index,ppNode)	\
    (This)->lpVtbl -> get_Item(This,Index,ppNode)

#define INodes_put_Item(This,Index,ppNode)	\
    (This)->lpVtbl -> put_Item(This,Index,ppNode)

#define INodes_Remove(This,Index)	\
    (This)->lpVtbl -> Remove(This,Index)

#define INodes__NewEnum(This,ppNewEnum)	\
    (This)->lpVtbl -> _NewEnum(This,ppNewEnum)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE INodes_get_Count_Proxy( 
    INodes * This,
    /* [retval][out] */ short *psCount);


void __RPC_STUB INodes_get_Count_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE INodes_put_Count_Proxy( 
    INodes * This,
    /* [in] */ short psCount);


void __RPC_STUB INodes_put_Count_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [hidden][propget][id] */ HRESULT STDMETHODCALLTYPE INodes_get_ControlDefault_Proxy( 
    INodes * This,
    /* [in] */ VARIANT *Index,
    /* [retval][out] */ INode **ppNode);


void __RPC_STUB INodes_get_ControlDefault_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [hidden][propput][id] */ HRESULT STDMETHODCALLTYPE INodes_put_ControlDefault_Proxy( 
    INodes * This,
    /* [in] */ VARIANT *Index,
    /* [in] */ INode *ppNode);


void __RPC_STUB INodes_put_ControlDefault_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][id] */ HRESULT STDMETHODCALLTYPE INodes_Add_Proxy( 
    INodes * This,
    /* [optional][in] */ VARIANT *Relative,
    /* [optional][in] */ VARIANT *Relationship,
    /* [optional][in] */ VARIANT *Key,
    /* [optional][in] */ VARIANT *Text,
    /* [optional][in] */ VARIANT *Image,
    /* [optional][in] */ VARIANT *SelectedImage,
    /* [retval][out] */ INode **ppNode);


void __RPC_STUB INodes_Add_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][id] */ HRESULT STDMETHODCALLTYPE INodes_Clear_Proxy( 
    INodes * This);


void __RPC_STUB INodes_Clear_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE INodes_get_Item_Proxy( 
    INodes * This,
    /* [in] */ VARIANT *Index,
    /* [retval][out] */ INode **ppNode);


void __RPC_STUB INodes_get_Item_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE INodes_put_Item_Proxy( 
    INodes * This,
    /* [in] */ VARIANT *Index,
    /* [in] */ INode *ppNode);


void __RPC_STUB INodes_put_Item_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][id] */ HRESULT STDMETHODCALLTYPE INodes_Remove_Proxy( 
    INodes * This,
    /* [in] */ VARIANT *Index);


void __RPC_STUB INodes_Remove_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE INodes__NewEnum_Proxy( 
    INodes * This,
    /* [retval][out] */ IDispatch **ppNewEnum);


void __RPC_STUB INodes__NewEnum_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __INodes_INTERFACE_DEFINED__ */


#ifndef __INode_INTERFACE_DEFINED__
#define __INode_INTERFACE_DEFINED__

/* interface INode */
/* [object][oleautomation][nonextensible][dual][hidden][helpcontext][helpstring][uuid] */ 


EXTERN_C const IID IID_INode;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("C74190B8-8589-11D1-B16A-00C0F0283628")
    INode : public IDispatch
    {
    public:
        virtual /* [hidden][propget][id] */ HRESULT STDMETHODCALLTYPE get__ObjectDefault( 
            /* [retval][out] */ BSTR *pbstrText) = 0;
        
        virtual /* [hidden][propput][id] */ HRESULT STDMETHODCALLTYPE put__ObjectDefault( 
            /* [in] */ BSTR pbstrText) = 0;
        
        virtual /* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_Child( 
            /* [retval][out] */ INode **ppChild) = 0;
        
        virtual /* [helpcontext][helpstring][propputref][id] */ HRESULT STDMETHODCALLTYPE putref_Child( 
            /* [in] */ INode *ppChild) = 0;
        
        virtual /* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_Children( 
            /* [retval][out] */ short *psChildren) = 0;
        
        virtual /* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_Children( 
            /* [in] */ short psChildren) = 0;
        
        virtual /* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_Expanded( 
            /* [retval][out] */ VARIANT_BOOL *pbExpanded) = 0;
        
        virtual /* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_Expanded( 
            /* [in] */ VARIANT_BOOL pbExpanded) = 0;
        
        virtual /* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_ExpandedImage( 
            /* [retval][out] */ VARIANT *pExpandedImage) = 0;
        
        virtual /* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_ExpandedImage( 
            /* [in] */ VARIANT pExpandedImage) = 0;
        
        virtual /* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_FirstSibling( 
            /* [retval][out] */ INode **ppFirstSibling) = 0;
        
        virtual /* [helpcontext][helpstring][propputref][id] */ HRESULT STDMETHODCALLTYPE putref_FirstSibling( 
            /* [in] */ INode *ppFirstSibling) = 0;
        
        virtual /* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_FullPath( 
            /* [retval][out] */ BSTR *pbstrFullPath) = 0;
        
        virtual /* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_FullPath( 
            /* [in] */ BSTR pbstrFullPath) = 0;
        
        virtual /* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_Image( 
            /* [retval][out] */ VARIANT *pImage) = 0;
        
        virtual /* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_Image( 
            /* [in] */ VARIANT pImage) = 0;
        
        virtual /* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_Index( 
            /* [retval][out] */ short *psIndex) = 0;
        
        virtual /* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_Index( 
            /* [in] */ short psIndex) = 0;
        
        virtual /* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_Key( 
            /* [retval][out] */ BSTR *pbstrKey) = 0;
        
        virtual /* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_Key( 
            /* [in] */ BSTR pbstrKey) = 0;
        
        virtual /* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_LastSibling( 
            /* [retval][out] */ INode **ppLastSibling) = 0;
        
        virtual /* [helpcontext][helpstring][propputref][id] */ HRESULT STDMETHODCALLTYPE putref_LastSibling( 
            /* [in] */ INode *ppLastSibling) = 0;
        
        virtual /* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_Next( 
            /* [retval][out] */ INode **ppNext) = 0;
        
        virtual /* [helpcontext][helpstring][propputref][id] */ HRESULT STDMETHODCALLTYPE putref_Next( 
            /* [in] */ INode *ppNext) = 0;
        
        virtual /* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_Parent( 
            /* [retval][out] */ INode **ppParent) = 0;
        
        virtual /* [helpcontext][helpstring][propputref][id] */ HRESULT STDMETHODCALLTYPE putref_Parent( 
            /* [in] */ INode *ppParent) = 0;
        
        virtual /* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_Previous( 
            /* [retval][out] */ INode **ppPrevious) = 0;
        
        virtual /* [helpcontext][helpstring][propputref][id] */ HRESULT STDMETHODCALLTYPE putref_Previous( 
            /* [in] */ INode *ppPrevious) = 0;
        
        virtual /* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_Root( 
            /* [retval][out] */ INode **ppRoot) = 0;
        
        virtual /* [helpcontext][helpstring][propputref][id] */ HRESULT STDMETHODCALLTYPE putref_Root( 
            /* [in] */ INode *ppRoot) = 0;
        
        virtual /* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_Selected( 
            /* [retval][out] */ VARIANT_BOOL *pbSelected) = 0;
        
        virtual /* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_Selected( 
            /* [in] */ VARIANT_BOOL pbSelected) = 0;
        
        virtual /* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_SelectedImage( 
            /* [retval][out] */ VARIANT *pSelectedImage) = 0;
        
        virtual /* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_SelectedImage( 
            /* [in] */ VARIANT pSelectedImage) = 0;
        
        virtual /* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_Sorted( 
            /* [retval][out] */ VARIANT_BOOL *pbSorted) = 0;
        
        virtual /* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_Sorted( 
            /* [in] */ VARIANT_BOOL pbSorted) = 0;
        
        virtual /* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_Tag( 
            /* [retval][out] */ VARIANT *pvTag) = 0;
        
        virtual /* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_Tag( 
            /* [in] */ VARIANT pvTag) = 0;
        
        virtual /* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_Text( 
            /* [retval][out] */ BSTR *bstrText) = 0;
        
        virtual /* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_Text( 
            /* [in] */ BSTR bstrText) = 0;
        
        virtual /* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_Visible( 
            /* [retval][out] */ VARIANT_BOOL *pbVisible) = 0;
        
        virtual /* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_Visible( 
            /* [in] */ VARIANT_BOOL pbVisible) = 0;
        
        virtual /* [helpcontext][helpstring][id] */ HRESULT STDMETHODCALLTYPE CreateDragImage( 
            /* [retval][out] */ /* external definition not present */ IPictureDisp **ppDragImage) = 0;
        
        virtual /* [helpcontext][helpstring][id] */ HRESULT STDMETHODCALLTYPE EnsureVisible( 
            /* [retval][out] */ VARIANT_BOOL *pbEnsureVisible) = 0;
        
        virtual /* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_BackColor( 
            /* [retval][out] */ /* external definition not present */ OLE_COLOR *pocBackColor) = 0;
        
        virtual /* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_BackColor( 
            /* [in] */ /* external definition not present */ OLE_COLOR pocBackColor) = 0;
        
        virtual /* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_Bold( 
            /* [retval][out] */ VARIANT_BOOL *pbBold) = 0;
        
        virtual /* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_Bold( 
            /* [in] */ VARIANT_BOOL pbBold) = 0;
        
        virtual /* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_Checked( 
            /* [retval][out] */ VARIANT_BOOL *pbChecked) = 0;
        
        virtual /* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_Checked( 
            /* [in] */ VARIANT_BOOL pbChecked) = 0;
        
        virtual /* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_ForeColor( 
            /* [retval][out] */ /* external definition not present */ OLE_COLOR *pocForeColor) = 0;
        
        virtual /* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_ForeColor( 
            /* [in] */ /* external definition not present */ OLE_COLOR pocForeColor) = 0;
        
        virtual /* [helpcontext][helpstring][propputref][id] */ HRESULT STDMETHODCALLTYPE putref_Tag( 
            /* [in] */ VARIANT pvTag) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct INodeVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            INode * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            INode * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            INode * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            INode * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            INode * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            INode * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            INode * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [hidden][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get__ObjectDefault )( 
            INode * This,
            /* [retval][out] */ BSTR *pbstrText);
        
        /* [hidden][propput][id] */ HRESULT ( STDMETHODCALLTYPE *put__ObjectDefault )( 
            INode * This,
            /* [in] */ BSTR pbstrText);
        
        /* [helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_Child )( 
            INode * This,
            /* [retval][out] */ INode **ppChild);
        
        /* [helpcontext][helpstring][propputref][id] */ HRESULT ( STDMETHODCALLTYPE *putref_Child )( 
            INode * This,
            /* [in] */ INode *ppChild);
        
        /* [helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_Children )( 
            INode * This,
            /* [retval][out] */ short *psChildren);
        
        /* [helpcontext][helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_Children )( 
            INode * This,
            /* [in] */ short psChildren);
        
        /* [helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_Expanded )( 
            INode * This,
            /* [retval][out] */ VARIANT_BOOL *pbExpanded);
        
        /* [helpcontext][helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_Expanded )( 
            INode * This,
            /* [in] */ VARIANT_BOOL pbExpanded);
        
        /* [helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_ExpandedImage )( 
            INode * This,
            /* [retval][out] */ VARIANT *pExpandedImage);
        
        /* [helpcontext][helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_ExpandedImage )( 
            INode * This,
            /* [in] */ VARIANT pExpandedImage);
        
        /* [helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_FirstSibling )( 
            INode * This,
            /* [retval][out] */ INode **ppFirstSibling);
        
        /* [helpcontext][helpstring][propputref][id] */ HRESULT ( STDMETHODCALLTYPE *putref_FirstSibling )( 
            INode * This,
            /* [in] */ INode *ppFirstSibling);
        
        /* [helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_FullPath )( 
            INode * This,
            /* [retval][out] */ BSTR *pbstrFullPath);
        
        /* [helpcontext][helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_FullPath )( 
            INode * This,
            /* [in] */ BSTR pbstrFullPath);
        
        /* [helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_Image )( 
            INode * This,
            /* [retval][out] */ VARIANT *pImage);
        
        /* [helpcontext][helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_Image )( 
            INode * This,
            /* [in] */ VARIANT pImage);
        
        /* [helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_Index )( 
            INode * This,
            /* [retval][out] */ short *psIndex);
        
        /* [helpcontext][helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_Index )( 
            INode * This,
            /* [in] */ short psIndex);
        
        /* [helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_Key )( 
            INode * This,
            /* [retval][out] */ BSTR *pbstrKey);
        
        /* [helpcontext][helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_Key )( 
            INode * This,
            /* [in] */ BSTR pbstrKey);
        
        /* [helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_LastSibling )( 
            INode * This,
            /* [retval][out] */ INode **ppLastSibling);
        
        /* [helpcontext][helpstring][propputref][id] */ HRESULT ( STDMETHODCALLTYPE *putref_LastSibling )( 
            INode * This,
            /* [in] */ INode *ppLastSibling);
        
        /* [helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_Next )( 
            INode * This,
            /* [retval][out] */ INode **ppNext);
        
        /* [helpcontext][helpstring][propputref][id] */ HRESULT ( STDMETHODCALLTYPE *putref_Next )( 
            INode * This,
            /* [in] */ INode *ppNext);
        
        /* [helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_Parent )( 
            INode * This,
            /* [retval][out] */ INode **ppParent);
        
        /* [helpcontext][helpstring][propputref][id] */ HRESULT ( STDMETHODCALLTYPE *putref_Parent )( 
            INode * This,
            /* [in] */ INode *ppParent);
        
        /* [helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_Previous )( 
            INode * This,
            /* [retval][out] */ INode **ppPrevious);
        
        /* [helpcontext][helpstring][propputref][id] */ HRESULT ( STDMETHODCALLTYPE *putref_Previous )( 
            INode * This,
            /* [in] */ INode *ppPrevious);
        
        /* [helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_Root )( 
            INode * This,
            /* [retval][out] */ INode **ppRoot);
        
        /* [helpcontext][helpstring][propputref][id] */ HRESULT ( STDMETHODCALLTYPE *putref_Root )( 
            INode * This,
            /* [in] */ INode *ppRoot);
        
        /* [helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_Selected )( 
            INode * This,
            /* [retval][out] */ VARIANT_BOOL *pbSelected);
        
        /* [helpcontext][helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_Selected )( 
            INode * This,
            /* [in] */ VARIANT_BOOL pbSelected);
        
        /* [helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_SelectedImage )( 
            INode * This,
            /* [retval][out] */ VARIANT *pSelectedImage);
        
        /* [helpcontext][helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_SelectedImage )( 
            INode * This,
            /* [in] */ VARIANT pSelectedImage);
        
        /* [helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_Sorted )( 
            INode * This,
            /* [retval][out] */ VARIANT_BOOL *pbSorted);
        
        /* [helpcontext][helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_Sorted )( 
            INode * This,
            /* [in] */ VARIANT_BOOL pbSorted);
        
        /* [helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_Tag )( 
            INode * This,
            /* [retval][out] */ VARIANT *pvTag);
        
        /* [helpcontext][helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_Tag )( 
            INode * This,
            /* [in] */ VARIANT pvTag);
        
        /* [helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_Text )( 
            INode * This,
            /* [retval][out] */ BSTR *bstrText);
        
        /* [helpcontext][helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_Text )( 
            INode * This,
            /* [in] */ BSTR bstrText);
        
        /* [helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_Visible )( 
            INode * This,
            /* [retval][out] */ VARIANT_BOOL *pbVisible);
        
        /* [helpcontext][helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_Visible )( 
            INode * This,
            /* [in] */ VARIANT_BOOL pbVisible);
        
        /* [helpcontext][helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *CreateDragImage )( 
            INode * This,
            /* [retval][out] */ /* external definition not present */ IPictureDisp **ppDragImage);
        
        /* [helpcontext][helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *EnsureVisible )( 
            INode * This,
            /* [retval][out] */ VARIANT_BOOL *pbEnsureVisible);
        
        /* [helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_BackColor )( 
            INode * This,
            /* [retval][out] */ /* external definition not present */ OLE_COLOR *pocBackColor);
        
        /* [helpcontext][helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_BackColor )( 
            INode * This,
            /* [in] */ /* external definition not present */ OLE_COLOR pocBackColor);
        
        /* [helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_Bold )( 
            INode * This,
            /* [retval][out] */ VARIANT_BOOL *pbBold);
        
        /* [helpcontext][helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_Bold )( 
            INode * This,
            /* [in] */ VARIANT_BOOL pbBold);
        
        /* [helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_Checked )( 
            INode * This,
            /* [retval][out] */ VARIANT_BOOL *pbChecked);
        
        /* [helpcontext][helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_Checked )( 
            INode * This,
            /* [in] */ VARIANT_BOOL pbChecked);
        
        /* [helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_ForeColor )( 
            INode * This,
            /* [retval][out] */ /* external definition not present */ OLE_COLOR *pocForeColor);
        
        /* [helpcontext][helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_ForeColor )( 
            INode * This,
            /* [in] */ /* external definition not present */ OLE_COLOR pocForeColor);
        
        /* [helpcontext][helpstring][propputref][id] */ HRESULT ( STDMETHODCALLTYPE *putref_Tag )( 
            INode * This,
            /* [in] */ VARIANT pvTag);
        
        END_INTERFACE
    } INodeVtbl;

    interface INode
    {
        CONST_VTBL struct INodeVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define INode_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define INode_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define INode_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define INode_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define INode_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define INode_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define INode_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define INode_get__ObjectDefault(This,pbstrText)	\
    (This)->lpVtbl -> get__ObjectDefault(This,pbstrText)

#define INode_put__ObjectDefault(This,pbstrText)	\
    (This)->lpVtbl -> put__ObjectDefault(This,pbstrText)

#define INode_get_Child(This,ppChild)	\
    (This)->lpVtbl -> get_Child(This,ppChild)

#define INode_putref_Child(This,ppChild)	\
    (This)->lpVtbl -> putref_Child(This,ppChild)

#define INode_get_Children(This,psChildren)	\
    (This)->lpVtbl -> get_Children(This,psChildren)

#define INode_put_Children(This,psChildren)	\
    (This)->lpVtbl -> put_Children(This,psChildren)

#define INode_get_Expanded(This,pbExpanded)	\
    (This)->lpVtbl -> get_Expanded(This,pbExpanded)

#define INode_put_Expanded(This,pbExpanded)	\
    (This)->lpVtbl -> put_Expanded(This,pbExpanded)

#define INode_get_ExpandedImage(This,pExpandedImage)	\
    (This)->lpVtbl -> get_ExpandedImage(This,pExpandedImage)

#define INode_put_ExpandedImage(This,pExpandedImage)	\
    (This)->lpVtbl -> put_ExpandedImage(This,pExpandedImage)

#define INode_get_FirstSibling(This,ppFirstSibling)	\
    (This)->lpVtbl -> get_FirstSibling(This,ppFirstSibling)

#define INode_putref_FirstSibling(This,ppFirstSibling)	\
    (This)->lpVtbl -> putref_FirstSibling(This,ppFirstSibling)

#define INode_get_FullPath(This,pbstrFullPath)	\
    (This)->lpVtbl -> get_FullPath(This,pbstrFullPath)

#define INode_put_FullPath(This,pbstrFullPath)	\
    (This)->lpVtbl -> put_FullPath(This,pbstrFullPath)

#define INode_get_Image(This,pImage)	\
    (This)->lpVtbl -> get_Image(This,pImage)

#define INode_put_Image(This,pImage)	\
    (This)->lpVtbl -> put_Image(This,pImage)

#define INode_get_Index(This,psIndex)	\
    (This)->lpVtbl -> get_Index(This,psIndex)

#define INode_put_Index(This,psIndex)	\
    (This)->lpVtbl -> put_Index(This,psIndex)

#define INode_get_Key(This,pbstrKey)	\
    (This)->lpVtbl -> get_Key(This,pbstrKey)

#define INode_put_Key(This,pbstrKey)	\
    (This)->lpVtbl -> put_Key(This,pbstrKey)

#define INode_get_LastSibling(This,ppLastSibling)	\
    (This)->lpVtbl -> get_LastSibling(This,ppLastSibling)

#define INode_putref_LastSibling(This,ppLastSibling)	\
    (This)->lpVtbl -> putref_LastSibling(This,ppLastSibling)

#define INode_get_Next(This,ppNext)	\
    (This)->lpVtbl -> get_Next(This,ppNext)

#define INode_putref_Next(This,ppNext)	\
    (This)->lpVtbl -> putref_Next(This,ppNext)

#define INode_get_Parent(This,ppParent)	\
    (This)->lpVtbl -> get_Parent(This,ppParent)

#define INode_putref_Parent(This,ppParent)	\
    (This)->lpVtbl -> putref_Parent(This,ppParent)

#define INode_get_Previous(This,ppPrevious)	\
    (This)->lpVtbl -> get_Previous(This,ppPrevious)

#define INode_putref_Previous(This,ppPrevious)	\
    (This)->lpVtbl -> putref_Previous(This,ppPrevious)

#define INode_get_Root(This,ppRoot)	\
    (This)->lpVtbl -> get_Root(This,ppRoot)

#define INode_putref_Root(This,ppRoot)	\
    (This)->lpVtbl -> putref_Root(This,ppRoot)

#define INode_get_Selected(This,pbSelected)	\
    (This)->lpVtbl -> get_Selected(This,pbSelected)

#define INode_put_Selected(This,pbSelected)	\
    (This)->lpVtbl -> put_Selected(This,pbSelected)

#define INode_get_SelectedImage(This,pSelectedImage)	\
    (This)->lpVtbl -> get_SelectedImage(This,pSelectedImage)

#define INode_put_SelectedImage(This,pSelectedImage)	\
    (This)->lpVtbl -> put_SelectedImage(This,pSelectedImage)

#define INode_get_Sorted(This,pbSorted)	\
    (This)->lpVtbl -> get_Sorted(This,pbSorted)

#define INode_put_Sorted(This,pbSorted)	\
    (This)->lpVtbl -> put_Sorted(This,pbSorted)

#define INode_get_Tag(This,pvTag)	\
    (This)->lpVtbl -> get_Tag(This,pvTag)

#define INode_put_Tag(This,pvTag)	\
    (This)->lpVtbl -> put_Tag(This,pvTag)

#define INode_get_Text(This,bstrText)	\
    (This)->lpVtbl -> get_Text(This,bstrText)

#define INode_put_Text(This,bstrText)	\
    (This)->lpVtbl -> put_Text(This,bstrText)

#define INode_get_Visible(This,pbVisible)	\
    (This)->lpVtbl -> get_Visible(This,pbVisible)

#define INode_put_Visible(This,pbVisible)	\
    (This)->lpVtbl -> put_Visible(This,pbVisible)

#define INode_CreateDragImage(This,ppDragImage)	\
    (This)->lpVtbl -> CreateDragImage(This,ppDragImage)

#define INode_EnsureVisible(This,pbEnsureVisible)	\
    (This)->lpVtbl -> EnsureVisible(This,pbEnsureVisible)

#define INode_get_BackColor(This,pocBackColor)	\
    (This)->lpVtbl -> get_BackColor(This,pocBackColor)

#define INode_put_BackColor(This,pocBackColor)	\
    (This)->lpVtbl -> put_BackColor(This,pocBackColor)

#define INode_get_Bold(This,pbBold)	\
    (This)->lpVtbl -> get_Bold(This,pbBold)

#define INode_put_Bold(This,pbBold)	\
    (This)->lpVtbl -> put_Bold(This,pbBold)

#define INode_get_Checked(This,pbChecked)	\
    (This)->lpVtbl -> get_Checked(This,pbChecked)

#define INode_put_Checked(This,pbChecked)	\
    (This)->lpVtbl -> put_Checked(This,pbChecked)

#define INode_get_ForeColor(This,pocForeColor)	\
    (This)->lpVtbl -> get_ForeColor(This,pocForeColor)

#define INode_put_ForeColor(This,pocForeColor)	\
    (This)->lpVtbl -> put_ForeColor(This,pocForeColor)

#define INode_putref_Tag(This,pvTag)	\
    (This)->lpVtbl -> putref_Tag(This,pvTag)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [hidden][propget][id] */ HRESULT STDMETHODCALLTYPE INode_get__ObjectDefault_Proxy( 
    INode * This,
    /* [retval][out] */ BSTR *pbstrText);


void __RPC_STUB INode_get__ObjectDefault_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [hidden][propput][id] */ HRESULT STDMETHODCALLTYPE INode_put__ObjectDefault_Proxy( 
    INode * This,
    /* [in] */ BSTR pbstrText);


void __RPC_STUB INode_put__ObjectDefault_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE INode_get_Child_Proxy( 
    INode * This,
    /* [retval][out] */ INode **ppChild);


void __RPC_STUB INode_get_Child_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propputref][id] */ HRESULT STDMETHODCALLTYPE INode_putref_Child_Proxy( 
    INode * This,
    /* [in] */ INode *ppChild);


void __RPC_STUB INode_putref_Child_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE INode_get_Children_Proxy( 
    INode * This,
    /* [retval][out] */ short *psChildren);


void __RPC_STUB INode_get_Children_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE INode_put_Children_Proxy( 
    INode * This,
    /* [in] */ short psChildren);


void __RPC_STUB INode_put_Children_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE INode_get_Expanded_Proxy( 
    INode * This,
    /* [retval][out] */ VARIANT_BOOL *pbExpanded);


void __RPC_STUB INode_get_Expanded_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE INode_put_Expanded_Proxy( 
    INode * This,
    /* [in] */ VARIANT_BOOL pbExpanded);


void __RPC_STUB INode_put_Expanded_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE INode_get_ExpandedImage_Proxy( 
    INode * This,
    /* [retval][out] */ VARIANT *pExpandedImage);


void __RPC_STUB INode_get_ExpandedImage_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE INode_put_ExpandedImage_Proxy( 
    INode * This,
    /* [in] */ VARIANT pExpandedImage);


void __RPC_STUB INode_put_ExpandedImage_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE INode_get_FirstSibling_Proxy( 
    INode * This,
    /* [retval][out] */ INode **ppFirstSibling);


void __RPC_STUB INode_get_FirstSibling_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propputref][id] */ HRESULT STDMETHODCALLTYPE INode_putref_FirstSibling_Proxy( 
    INode * This,
    /* [in] */ INode *ppFirstSibling);


void __RPC_STUB INode_putref_FirstSibling_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE INode_get_FullPath_Proxy( 
    INode * This,
    /* [retval][out] */ BSTR *pbstrFullPath);


void __RPC_STUB INode_get_FullPath_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE INode_put_FullPath_Proxy( 
    INode * This,
    /* [in] */ BSTR pbstrFullPath);


void __RPC_STUB INode_put_FullPath_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE INode_get_Image_Proxy( 
    INode * This,
    /* [retval][out] */ VARIANT *pImage);


void __RPC_STUB INode_get_Image_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE INode_put_Image_Proxy( 
    INode * This,
    /* [in] */ VARIANT pImage);


void __RPC_STUB INode_put_Image_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE INode_get_Index_Proxy( 
    INode * This,
    /* [retval][out] */ short *psIndex);


void __RPC_STUB INode_get_Index_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE INode_put_Index_Proxy( 
    INode * This,
    /* [in] */ short psIndex);


void __RPC_STUB INode_put_Index_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE INode_get_Key_Proxy( 
    INode * This,
    /* [retval][out] */ BSTR *pbstrKey);


void __RPC_STUB INode_get_Key_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE INode_put_Key_Proxy( 
    INode * This,
    /* [in] */ BSTR pbstrKey);


void __RPC_STUB INode_put_Key_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE INode_get_LastSibling_Proxy( 
    INode * This,
    /* [retval][out] */ INode **ppLastSibling);


void __RPC_STUB INode_get_LastSibling_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propputref][id] */ HRESULT STDMETHODCALLTYPE INode_putref_LastSibling_Proxy( 
    INode * This,
    /* [in] */ INode *ppLastSibling);


void __RPC_STUB INode_putref_LastSibling_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE INode_get_Next_Proxy( 
    INode * This,
    /* [retval][out] */ INode **ppNext);


void __RPC_STUB INode_get_Next_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propputref][id] */ HRESULT STDMETHODCALLTYPE INode_putref_Next_Proxy( 
    INode * This,
    /* [in] */ INode *ppNext);


void __RPC_STUB INode_putref_Next_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE INode_get_Parent_Proxy( 
    INode * This,
    /* [retval][out] */ INode **ppParent);


void __RPC_STUB INode_get_Parent_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propputref][id] */ HRESULT STDMETHODCALLTYPE INode_putref_Parent_Proxy( 
    INode * This,
    /* [in] */ INode *ppParent);


void __RPC_STUB INode_putref_Parent_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE INode_get_Previous_Proxy( 
    INode * This,
    /* [retval][out] */ INode **ppPrevious);


void __RPC_STUB INode_get_Previous_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propputref][id] */ HRESULT STDMETHODCALLTYPE INode_putref_Previous_Proxy( 
    INode * This,
    /* [in] */ INode *ppPrevious);


void __RPC_STUB INode_putref_Previous_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE INode_get_Root_Proxy( 
    INode * This,
    /* [retval][out] */ INode **ppRoot);


void __RPC_STUB INode_get_Root_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propputref][id] */ HRESULT STDMETHODCALLTYPE INode_putref_Root_Proxy( 
    INode * This,
    /* [in] */ INode *ppRoot);


void __RPC_STUB INode_putref_Root_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE INode_get_Selected_Proxy( 
    INode * This,
    /* [retval][out] */ VARIANT_BOOL *pbSelected);


void __RPC_STUB INode_get_Selected_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE INode_put_Selected_Proxy( 
    INode * This,
    /* [in] */ VARIANT_BOOL pbSelected);


void __RPC_STUB INode_put_Selected_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE INode_get_SelectedImage_Proxy( 
    INode * This,
    /* [retval][out] */ VARIANT *pSelectedImage);


void __RPC_STUB INode_get_SelectedImage_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE INode_put_SelectedImage_Proxy( 
    INode * This,
    /* [in] */ VARIANT pSelectedImage);


void __RPC_STUB INode_put_SelectedImage_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE INode_get_Sorted_Proxy( 
    INode * This,
    /* [retval][out] */ VARIANT_BOOL *pbSorted);


void __RPC_STUB INode_get_Sorted_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE INode_put_Sorted_Proxy( 
    INode * This,
    /* [in] */ VARIANT_BOOL pbSorted);


void __RPC_STUB INode_put_Sorted_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE INode_get_Tag_Proxy( 
    INode * This,
    /* [retval][out] */ VARIANT *pvTag);


void __RPC_STUB INode_get_Tag_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE INode_put_Tag_Proxy( 
    INode * This,
    /* [in] */ VARIANT pvTag);


void __RPC_STUB INode_put_Tag_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE INode_get_Text_Proxy( 
    INode * This,
    /* [retval][out] */ BSTR *bstrText);


void __RPC_STUB INode_get_Text_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE INode_put_Text_Proxy( 
    INode * This,
    /* [in] */ BSTR bstrText);


void __RPC_STUB INode_put_Text_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE INode_get_Visible_Proxy( 
    INode * This,
    /* [retval][out] */ VARIANT_BOOL *pbVisible);


void __RPC_STUB INode_get_Visible_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE INode_put_Visible_Proxy( 
    INode * This,
    /* [in] */ VARIANT_BOOL pbVisible);


void __RPC_STUB INode_put_Visible_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][id] */ HRESULT STDMETHODCALLTYPE INode_CreateDragImage_Proxy( 
    INode * This,
    /* [retval][out] */ /* external definition not present */ IPictureDisp **ppDragImage);


void __RPC_STUB INode_CreateDragImage_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][id] */ HRESULT STDMETHODCALLTYPE INode_EnsureVisible_Proxy( 
    INode * This,
    /* [retval][out] */ VARIANT_BOOL *pbEnsureVisible);


void __RPC_STUB INode_EnsureVisible_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE INode_get_BackColor_Proxy( 
    INode * This,
    /* [retval][out] */ /* external definition not present */ OLE_COLOR *pocBackColor);


void __RPC_STUB INode_get_BackColor_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE INode_put_BackColor_Proxy( 
    INode * This,
    /* [in] */ /* external definition not present */ OLE_COLOR pocBackColor);


void __RPC_STUB INode_put_BackColor_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE INode_get_Bold_Proxy( 
    INode * This,
    /* [retval][out] */ VARIANT_BOOL *pbBold);


void __RPC_STUB INode_get_Bold_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE INode_put_Bold_Proxy( 
    INode * This,
    /* [in] */ VARIANT_BOOL pbBold);


void __RPC_STUB INode_put_Bold_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE INode_get_Checked_Proxy( 
    INode * This,
    /* [retval][out] */ VARIANT_BOOL *pbChecked);


void __RPC_STUB INode_get_Checked_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE INode_put_Checked_Proxy( 
    INode * This,
    /* [in] */ VARIANT_BOOL pbChecked);


void __RPC_STUB INode_put_Checked_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE INode_get_ForeColor_Proxy( 
    INode * This,
    /* [retval][out] */ /* external definition not present */ OLE_COLOR *pocForeColor);


void __RPC_STUB INode_get_ForeColor_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE INode_put_ForeColor_Proxy( 
    INode * This,
    /* [in] */ /* external definition not present */ OLE_COLOR pocForeColor);


void __RPC_STUB INode_put_ForeColor_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propputref][id] */ HRESULT STDMETHODCALLTYPE INode_putref_Tag_Proxy( 
    INode * This,
    /* [in] */ VARIANT pvTag);


void __RPC_STUB INode_putref_Tag_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __INode_INTERFACE_DEFINED__ */


#ifndef __IListView_INTERFACE_DEFINED__
#define __IListView_INTERFACE_DEFINED__

/* interface IListView */
/* [object][oleautomation][nonextensible][dual][hidden][helpcontext][helpstring][uuid] */ 


EXTERN_C const IID IID_IListView;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("BDD1F049-858B-11D1-B16A-00C0F0283628")
    IListView : public IDispatch
    {
    public:
        virtual /* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_Arrange( 
            /* [retval][out] */ ListArrangeConstants *pArrange) = 0;
        
        virtual /* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_Arrange( 
            /* [in] */ ListArrangeConstants pArrange) = 0;
        
        virtual /* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_ColumnHeaders( 
            /* [retval][out] */ IColumnHeaders **ppIColumnHeaders) = 0;
        
        virtual /* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_ColumnHeaders( 
            /* [in] */ IColumnHeaders *ppIColumnHeaders) = 0;
        
        virtual /* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_DropHighlight( 
            /* [retval][out] */ IListItem **ppIListItem) = 0;
        
        virtual /* [helpcontext][helpstring][propputref][id] */ HRESULT STDMETHODCALLTYPE putref_DropHighlight( 
            /* [in] */ IListItem *ppIListItem) = 0;
        
        virtual /* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_DropHighlight( 
            /* [in] */ VARIANT *ppIListItem) = 0;
        
        virtual /* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_HideColumnHeaders( 
            /* [retval][out] */ VARIANT_BOOL *pfHide) = 0;
        
        virtual /* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_HideColumnHeaders( 
            /* [in] */ VARIANT_BOOL pfHide) = 0;
        
        virtual /* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_HideSelection( 
            /* [retval][out] */ VARIANT_BOOL *pfHide) = 0;
        
        virtual /* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_HideSelection( 
            /* [in] */ VARIANT_BOOL pfHide) = 0;
        
        virtual /* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_Icons( 
            /* [retval][out] */ IDispatch **ppIcons) = 0;
        
        virtual /* [helpcontext][helpstring][propputref][id] */ HRESULT STDMETHODCALLTYPE putref_Icons( 
            /* [in] */ IDispatch *ppIcons) = 0;
        
        virtual /* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_Icons( 
            /* [in] */ IDispatch *ppIcons) = 0;
        
        virtual /* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_ListItems( 
            /* [retval][out] */ IListItems **ppListItems) = 0;
        
        virtual /* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_ListItems( 
            /* [in] */ IListItems *ppListItems) = 0;
        
        virtual /* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_LabelEdit( 
            /* [retval][out] */ ListLabelEditConstants *pRet) = 0;
        
        virtual /* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_LabelEdit( 
            /* [in] */ ListLabelEditConstants pRet) = 0;
        
        virtual /* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_LabelWrap( 
            /* [retval][out] */ VARIANT_BOOL *pfOn) = 0;
        
        virtual /* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_LabelWrap( 
            /* [in] */ VARIANT_BOOL pfOn) = 0;
        
        virtual /* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_MouseIcon( 
            /* [retval][out] */ /* external definition not present */ IPictureDisp **ppMouseIcon) = 0;
        
        virtual /* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_MouseIcon( 
            /* [in] */ /* external definition not present */ IPictureDisp *ppMouseIcon) = 0;
        
        virtual /* [helpcontext][helpstring][propputref][id] */ HRESULT STDMETHODCALLTYPE putref_MouseIcon( 
            /* [in] */ /* external definition not present */ IPictureDisp *ppMouseIcon) = 0;
        
        virtual /* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_MousePointer( 
            /* [retval][out] */ MousePointerConstants *pnIndex) = 0;
        
        virtual /* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_MousePointer( 
            /* [in] */ MousePointerConstants pnIndex) = 0;
        
        virtual /* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_MultiSelect( 
            /* [retval][out] */ VARIANT_BOOL *pfOn) = 0;
        
        virtual /* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_MultiSelect( 
            /* [in] */ VARIANT_BOOL pfOn) = 0;
        
        virtual /* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_SelectedItem( 
            /* [retval][out] */ IListItem **ppListItem) = 0;
        
        virtual /* [helpcontext][helpstring][propputref][id] */ HRESULT STDMETHODCALLTYPE putref_SelectedItem( 
            /* [in] */ IListItem *ppListItem) = 0;
        
        virtual /* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_SelectedItem( 
            /* [in] */ VARIANT *ppListItem) = 0;
        
        virtual /* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_SmallIcons( 
            /* [retval][out] */ IDispatch **ppImageList) = 0;
        
        virtual /* [helpcontext][helpstring][propputref][id] */ HRESULT STDMETHODCALLTYPE putref_SmallIcons( 
            /* [in] */ IDispatch *ppImageList) = 0;
        
        virtual /* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_SmallIcons( 
            /* [in] */ IDispatch *ppImageList) = 0;
        
        virtual /* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_Sorted( 
            /* [retval][out] */ VARIANT_BOOL *pfOn) = 0;
        
        virtual /* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_Sorted( 
            /* [in] */ VARIANT_BOOL pfOn) = 0;
        
        virtual /* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_SortKey( 
            /* [retval][out] */ short *psKey) = 0;
        
        virtual /* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_SortKey( 
            /* [in] */ short psKey) = 0;
        
        virtual /* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_SortOrder( 
            /* [retval][out] */ ListSortOrderConstants *pOrder) = 0;
        
        virtual /* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_SortOrder( 
            /* [in] */ ListSortOrderConstants pOrder) = 0;
        
        virtual /* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_View( 
            /* [retval][out] */ ListViewConstants *pnView) = 0;
        
        virtual /* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_View( 
            /* [in] */ ListViewConstants pnView) = 0;
        
        virtual /* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_OLEDragMode( 
            /* [retval][out] */ OLEDragConstants *psOLEDragMode) = 0;
        
        virtual /* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_OLEDragMode( 
            /* [in] */ OLEDragConstants psOLEDragMode) = 0;
        
        virtual /* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_OLEDropMode( 
            /* [retval][out] */ OLEDropConstants *psOLEDropMode) = 0;
        
        virtual /* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_OLEDropMode( 
            /* [in] */ OLEDropConstants psOLEDropMode) = 0;
        
        virtual /* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_Appearance( 
            /* [retval][out] */ AppearanceConstants *pnAppearance) = 0;
        
        virtual /* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_Appearance( 
            /* [in] */ AppearanceConstants pnAppearance) = 0;
        
        virtual /* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_BackColor( 
            /* [retval][out] */ /* external definition not present */ OLE_COLOR *pcrBack) = 0;
        
        virtual /* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_BackColor( 
            /* [in] */ /* external definition not present */ OLE_COLOR pcrBack) = 0;
        
        virtual /* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_BorderStyle( 
            /* [retval][out] */ BorderStyleConstants *pnStyle) = 0;
        
        virtual /* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_BorderStyle( 
            /* [in] */ BorderStyleConstants pnStyle) = 0;
        
        virtual /* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_Enabled( 
            /* [retval][out] */ VARIANT_BOOL *pfEnabled) = 0;
        
        virtual /* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_Enabled( 
            /* [in] */ VARIANT_BOOL pfEnabled) = 0;
        
        virtual /* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_Font( 
            /* [retval][out] */ /* external definition not present */ IFontDisp **ppFontDisp) = 0;
        
        virtual /* [helpcontext][helpstring][propputref][id] */ HRESULT STDMETHODCALLTYPE putref_Font( 
            /* [in] */ /* external definition not present */ IFontDisp *ppFontDisp) = 0;
        
        virtual /* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_ForeColor( 
            /* [retval][out] */ /* external definition not present */ OLE_COLOR *pcrFore) = 0;
        
        virtual /* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_ForeColor( 
            /* [in] */ /* external definition not present */ OLE_COLOR pcrFore) = 0;
        
        virtual /* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_hWnd( 
            /* [retval][out] */ /* external definition not present */ OLE_HANDLE *phWnd) = 0;
        
        virtual /* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_hWnd( 
            /* [in] */ /* external definition not present */ OLE_HANDLE phWnd) = 0;
        
        virtual /* [helpcontext][helpstring][id] */ HRESULT STDMETHODCALLTYPE FindItem( 
            /* [in] */ BSTR sz,
            /* [optional][in] */ VARIANT *Where,
            /* [optional][in] */ VARIANT *Index,
            /* [optional][in] */ VARIANT *fPartial,
            /* [retval][out] */ IListItem **ppIListItem) = 0;
        
        virtual /* [helpcontext][helpstring][id] */ HRESULT STDMETHODCALLTYPE GetFirstVisible( 
            /* [retval][out] */ IListItem **ppIListItem) = 0;
        
        virtual /* [helpcontext][helpstring][id] */ HRESULT STDMETHODCALLTYPE HitTest( 
            /* [in] */ single x,
            /* [in] */ single y,
            /* [retval][out] */ IListItem **ppListItem) = 0;
        
        virtual /* [helpcontext][helpstring][id] */ HRESULT STDMETHODCALLTYPE StartLabelEdit( void) = 0;
        
        virtual /* [helpcontext][helpstring][id] */ HRESULT STDMETHODCALLTYPE OLEDrag( void) = 0;
        
        virtual /* [helpcontext][helpstring][id] */ void STDMETHODCALLTYPE Refresh( void) = 0;
        
        virtual /* [hidden][id] */ void STDMETHODCALLTYPE AboutBox( void) = 0;
        
        virtual /* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_AllowColumnReorder( 
            /* [retval][out] */ VARIANT_BOOL *pfAllowColumnReorder) = 0;
        
        virtual /* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_AllowColumnReorder( 
            /* [in] */ VARIANT_BOOL pfAllowColumnReorder) = 0;
        
        virtual /* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_Checkboxes( 
            /* [retval][out] */ VARIANT_BOOL *pfCheckboxes) = 0;
        
        virtual /* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_Checkboxes( 
            /* [in] */ VARIANT_BOOL pfCheckboxes) = 0;
        
        virtual /* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_FlatScrollBar( 
            /* [retval][out] */ VARIANT_BOOL *pfFlatScrollBar) = 0;
        
        virtual /* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_FlatScrollBar( 
            /* [in] */ VARIANT_BOOL pfFlatScrollBar) = 0;
        
        virtual /* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_FullRowSelect( 
            /* [retval][out] */ VARIANT_BOOL *pfFullRowSelect) = 0;
        
        virtual /* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_FullRowSelect( 
            /* [in] */ VARIANT_BOOL pfFullRowSelect) = 0;
        
        virtual /* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_GridLines( 
            /* [retval][out] */ VARIANT_BOOL *pfGridLines) = 0;
        
        virtual /* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_GridLines( 
            /* [in] */ VARIANT_BOOL pfGridLines) = 0;
        
        virtual /* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_HotTracking( 
            /* [retval][out] */ VARIANT_BOOL *pfHotTracking) = 0;
        
        virtual /* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_HotTracking( 
            /* [in] */ VARIANT_BOOL pfHotTracking) = 0;
        
        virtual /* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_HoverSelection( 
            /* [retval][out] */ VARIANT_BOOL *pfHoverSelection) = 0;
        
        virtual /* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_HoverSelection( 
            /* [in] */ VARIANT_BOOL pfHoverSelection) = 0;
        
        virtual /* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_Picture( 
            /* [retval][out] */ /* external definition not present */ IPictureDisp **ppPictureDisp) = 0;
        
        virtual /* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_Picture( 
            /* [in] */ /* external definition not present */ IPictureDisp *ppPictureDisp) = 0;
        
        virtual /* [helpcontext][helpstring][propputref][id] */ HRESULT STDMETHODCALLTYPE putref_Picture( 
            /* [in] */ /* external definition not present */ IPictureDisp *ppPictureDisp) = 0;
        
        virtual /* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_PictureAlignment( 
            /* [retval][out] */ ListPictureAlignmentConstants *psAlignment) = 0;
        
        virtual /* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_PictureAlignment( 
            /* [in] */ ListPictureAlignmentConstants psAlignment) = 0;
        
        virtual /* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_ColumnHeaderIcons( 
            /* [retval][out] */ IDispatch **ppImageList) = 0;
        
        virtual /* [helpcontext][helpstring][propputref][id] */ HRESULT STDMETHODCALLTYPE putref_ColumnHeaderIcons( 
            /* [in] */ IDispatch *ppImageList) = 0;
        
        virtual /* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_ColumnHeaderIcons( 
            /* [in] */ IDispatch *ppImageList) = 0;
        
        virtual /* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_TextBackground( 
            /* [retval][out] */ ListTextBackgroundConstants *penumTextBackground) = 0;
        
        virtual /* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_TextBackground( 
            /* [in] */ ListTextBackgroundConstants penumTextBackground) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IListViewVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IListView * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IListView * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IListView * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IListView * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IListView * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IListView * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IListView * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_Arrange )( 
            IListView * This,
            /* [retval][out] */ ListArrangeConstants *pArrange);
        
        /* [helpcontext][helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_Arrange )( 
            IListView * This,
            /* [in] */ ListArrangeConstants pArrange);
        
        /* [helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_ColumnHeaders )( 
            IListView * This,
            /* [retval][out] */ IColumnHeaders **ppIColumnHeaders);
        
        /* [helpcontext][helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_ColumnHeaders )( 
            IListView * This,
            /* [in] */ IColumnHeaders *ppIColumnHeaders);
        
        /* [helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_DropHighlight )( 
            IListView * This,
            /* [retval][out] */ IListItem **ppIListItem);
        
        /* [helpcontext][helpstring][propputref][id] */ HRESULT ( STDMETHODCALLTYPE *putref_DropHighlight )( 
            IListView * This,
            /* [in] */ IListItem *ppIListItem);
        
        /* [helpcontext][helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_DropHighlight )( 
            IListView * This,
            /* [in] */ VARIANT *ppIListItem);
        
        /* [helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_HideColumnHeaders )( 
            IListView * This,
            /* [retval][out] */ VARIANT_BOOL *pfHide);
        
        /* [helpcontext][helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_HideColumnHeaders )( 
            IListView * This,
            /* [in] */ VARIANT_BOOL pfHide);
        
        /* [helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_HideSelection )( 
            IListView * This,
            /* [retval][out] */ VARIANT_BOOL *pfHide);
        
        /* [helpcontext][helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_HideSelection )( 
            IListView * This,
            /* [in] */ VARIANT_BOOL pfHide);
        
        /* [helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_Icons )( 
            IListView * This,
            /* [retval][out] */ IDispatch **ppIcons);
        
        /* [helpcontext][helpstring][propputref][id] */ HRESULT ( STDMETHODCALLTYPE *putref_Icons )( 
            IListView * This,
            /* [in] */ IDispatch *ppIcons);
        
        /* [helpcontext][helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_Icons )( 
            IListView * This,
            /* [in] */ IDispatch *ppIcons);
        
        /* [helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_ListItems )( 
            IListView * This,
            /* [retval][out] */ IListItems **ppListItems);
        
        /* [helpcontext][helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_ListItems )( 
            IListView * This,
            /* [in] */ IListItems *ppListItems);
        
        /* [helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_LabelEdit )( 
            IListView * This,
            /* [retval][out] */ ListLabelEditConstants *pRet);
        
        /* [helpcontext][helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_LabelEdit )( 
            IListView * This,
            /* [in] */ ListLabelEditConstants pRet);
        
        /* [helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_LabelWrap )( 
            IListView * This,
            /* [retval][out] */ VARIANT_BOOL *pfOn);
        
        /* [helpcontext][helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_LabelWrap )( 
            IListView * This,
            /* [in] */ VARIANT_BOOL pfOn);
        
        /* [helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_MouseIcon )( 
            IListView * This,
            /* [retval][out] */ /* external definition not present */ IPictureDisp **ppMouseIcon);
        
        /* [helpcontext][helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_MouseIcon )( 
            IListView * This,
            /* [in] */ /* external definition not present */ IPictureDisp *ppMouseIcon);
        
        /* [helpcontext][helpstring][propputref][id] */ HRESULT ( STDMETHODCALLTYPE *putref_MouseIcon )( 
            IListView * This,
            /* [in] */ /* external definition not present */ IPictureDisp *ppMouseIcon);
        
        /* [helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_MousePointer )( 
            IListView * This,
            /* [retval][out] */ MousePointerConstants *pnIndex);
        
        /* [helpcontext][helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_MousePointer )( 
            IListView * This,
            /* [in] */ MousePointerConstants pnIndex);
        
        /* [helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_MultiSelect )( 
            IListView * This,
            /* [retval][out] */ VARIANT_BOOL *pfOn);
        
        /* [helpcontext][helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_MultiSelect )( 
            IListView * This,
            /* [in] */ VARIANT_BOOL pfOn);
        
        /* [helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_SelectedItem )( 
            IListView * This,
            /* [retval][out] */ IListItem **ppListItem);
        
        /* [helpcontext][helpstring][propputref][id] */ HRESULT ( STDMETHODCALLTYPE *putref_SelectedItem )( 
            IListView * This,
            /* [in] */ IListItem *ppListItem);
        
        /* [helpcontext][helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_SelectedItem )( 
            IListView * This,
            /* [in] */ VARIANT *ppListItem);
        
        /* [helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_SmallIcons )( 
            IListView * This,
            /* [retval][out] */ IDispatch **ppImageList);
        
        /* [helpcontext][helpstring][propputref][id] */ HRESULT ( STDMETHODCALLTYPE *putref_SmallIcons )( 
            IListView * This,
            /* [in] */ IDispatch *ppImageList);
        
        /* [helpcontext][helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_SmallIcons )( 
            IListView * This,
            /* [in] */ IDispatch *ppImageList);
        
        /* [helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_Sorted )( 
            IListView * This,
            /* [retval][out] */ VARIANT_BOOL *pfOn);
        
        /* [helpcontext][helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_Sorted )( 
            IListView * This,
            /* [in] */ VARIANT_BOOL pfOn);
        
        /* [helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_SortKey )( 
            IListView * This,
            /* [retval][out] */ short *psKey);
        
        /* [helpcontext][helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_SortKey )( 
            IListView * This,
            /* [in] */ short psKey);
        
        /* [helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_SortOrder )( 
            IListView * This,
            /* [retval][out] */ ListSortOrderConstants *pOrder);
        
        /* [helpcontext][helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_SortOrder )( 
            IListView * This,
            /* [in] */ ListSortOrderConstants pOrder);
        
        /* [helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_View )( 
            IListView * This,
            /* [retval][out] */ ListViewConstants *pnView);
        
        /* [helpcontext][helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_View )( 
            IListView * This,
            /* [in] */ ListViewConstants pnView);
        
        /* [helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_OLEDragMode )( 
            IListView * This,
            /* [retval][out] */ OLEDragConstants *psOLEDragMode);
        
        /* [helpcontext][helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_OLEDragMode )( 
            IListView * This,
            /* [in] */ OLEDragConstants psOLEDragMode);
        
        /* [helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_OLEDropMode )( 
            IListView * This,
            /* [retval][out] */ OLEDropConstants *psOLEDropMode);
        
        /* [helpcontext][helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_OLEDropMode )( 
            IListView * This,
            /* [in] */ OLEDropConstants psOLEDropMode);
        
        /* [helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_Appearance )( 
            IListView * This,
            /* [retval][out] */ AppearanceConstants *pnAppearance);
        
        /* [helpcontext][helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_Appearance )( 
            IListView * This,
            /* [in] */ AppearanceConstants pnAppearance);
        
        /* [helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_BackColor )( 
            IListView * This,
            /* [retval][out] */ /* external definition not present */ OLE_COLOR *pcrBack);
        
        /* [helpcontext][helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_BackColor )( 
            IListView * This,
            /* [in] */ /* external definition not present */ OLE_COLOR pcrBack);
        
        /* [helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_BorderStyle )( 
            IListView * This,
            /* [retval][out] */ BorderStyleConstants *pnStyle);
        
        /* [helpcontext][helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_BorderStyle )( 
            IListView * This,
            /* [in] */ BorderStyleConstants pnStyle);
        
        /* [helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_Enabled )( 
            IListView * This,
            /* [retval][out] */ VARIANT_BOOL *pfEnabled);
        
        /* [helpcontext][helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_Enabled )( 
            IListView * This,
            /* [in] */ VARIANT_BOOL pfEnabled);
        
        /* [helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_Font )( 
            IListView * This,
            /* [retval][out] */ /* external definition not present */ IFontDisp **ppFontDisp);
        
        /* [helpcontext][helpstring][propputref][id] */ HRESULT ( STDMETHODCALLTYPE *putref_Font )( 
            IListView * This,
            /* [in] */ /* external definition not present */ IFontDisp *ppFontDisp);
        
        /* [helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_ForeColor )( 
            IListView * This,
            /* [retval][out] */ /* external definition not present */ OLE_COLOR *pcrFore);
        
        /* [helpcontext][helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_ForeColor )( 
            IListView * This,
            /* [in] */ /* external definition not present */ OLE_COLOR pcrFore);
        
        /* [helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_hWnd )( 
            IListView * This,
            /* [retval][out] */ /* external definition not present */ OLE_HANDLE *phWnd);
        
        /* [helpcontext][helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_hWnd )( 
            IListView * This,
            /* [in] */ /* external definition not present */ OLE_HANDLE phWnd);
        
        /* [helpcontext][helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *FindItem )( 
            IListView * This,
            /* [in] */ BSTR sz,
            /* [optional][in] */ VARIANT *Where,
            /* [optional][in] */ VARIANT *Index,
            /* [optional][in] */ VARIANT *fPartial,
            /* [retval][out] */ IListItem **ppIListItem);
        
        /* [helpcontext][helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *GetFirstVisible )( 
            IListView * This,
            /* [retval][out] */ IListItem **ppIListItem);
        
        /* [helpcontext][helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *HitTest )( 
            IListView * This,
            /* [in] */ single x,
            /* [in] */ single y,
            /* [retval][out] */ IListItem **ppListItem);
        
        /* [helpcontext][helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *StartLabelEdit )( 
            IListView * This);
        
        /* [helpcontext][helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *OLEDrag )( 
            IListView * This);
        
        /* [helpcontext][helpstring][id] */ void ( STDMETHODCALLTYPE *Refresh )( 
            IListView * This);
        
        /* [hidden][id] */ void ( STDMETHODCALLTYPE *AboutBox )( 
            IListView * This);
        
        /* [helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_AllowColumnReorder )( 
            IListView * This,
            /* [retval][out] */ VARIANT_BOOL *pfAllowColumnReorder);
        
        /* [helpcontext][helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_AllowColumnReorder )( 
            IListView * This,
            /* [in] */ VARIANT_BOOL pfAllowColumnReorder);
        
        /* [helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_Checkboxes )( 
            IListView * This,
            /* [retval][out] */ VARIANT_BOOL *pfCheckboxes);
        
        /* [helpcontext][helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_Checkboxes )( 
            IListView * This,
            /* [in] */ VARIANT_BOOL pfCheckboxes);
        
        /* [helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_FlatScrollBar )( 
            IListView * This,
            /* [retval][out] */ VARIANT_BOOL *pfFlatScrollBar);
        
        /* [helpcontext][helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_FlatScrollBar )( 
            IListView * This,
            /* [in] */ VARIANT_BOOL pfFlatScrollBar);
        
        /* [helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_FullRowSelect )( 
            IListView * This,
            /* [retval][out] */ VARIANT_BOOL *pfFullRowSelect);
        
        /* [helpcontext][helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_FullRowSelect )( 
            IListView * This,
            /* [in] */ VARIANT_BOOL pfFullRowSelect);
        
        /* [helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_GridLines )( 
            IListView * This,
            /* [retval][out] */ VARIANT_BOOL *pfGridLines);
        
        /* [helpcontext][helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_GridLines )( 
            IListView * This,
            /* [in] */ VARIANT_BOOL pfGridLines);
        
        /* [helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_HotTracking )( 
            IListView * This,
            /* [retval][out] */ VARIANT_BOOL *pfHotTracking);
        
        /* [helpcontext][helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_HotTracking )( 
            IListView * This,
            /* [in] */ VARIANT_BOOL pfHotTracking);
        
        /* [helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_HoverSelection )( 
            IListView * This,
            /* [retval][out] */ VARIANT_BOOL *pfHoverSelection);
        
        /* [helpcontext][helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_HoverSelection )( 
            IListView * This,
            /* [in] */ VARIANT_BOOL pfHoverSelection);
        
        /* [helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_Picture )( 
            IListView * This,
            /* [retval][out] */ /* external definition not present */ IPictureDisp **ppPictureDisp);
        
        /* [helpcontext][helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_Picture )( 
            IListView * This,
            /* [in] */ /* external definition not present */ IPictureDisp *ppPictureDisp);
        
        /* [helpcontext][helpstring][propputref][id] */ HRESULT ( STDMETHODCALLTYPE *putref_Picture )( 
            IListView * This,
            /* [in] */ /* external definition not present */ IPictureDisp *ppPictureDisp);
        
        /* [helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_PictureAlignment )( 
            IListView * This,
            /* [retval][out] */ ListPictureAlignmentConstants *psAlignment);
        
        /* [helpcontext][helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_PictureAlignment )( 
            IListView * This,
            /* [in] */ ListPictureAlignmentConstants psAlignment);
        
        /* [helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_ColumnHeaderIcons )( 
            IListView * This,
            /* [retval][out] */ IDispatch **ppImageList);
        
        /* [helpcontext][helpstring][propputref][id] */ HRESULT ( STDMETHODCALLTYPE *putref_ColumnHeaderIcons )( 
            IListView * This,
            /* [in] */ IDispatch *ppImageList);
        
        /* [helpcontext][helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_ColumnHeaderIcons )( 
            IListView * This,
            /* [in] */ IDispatch *ppImageList);
        
        /* [helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_TextBackground )( 
            IListView * This,
            /* [retval][out] */ ListTextBackgroundConstants *penumTextBackground);
        
        /* [helpcontext][helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_TextBackground )( 
            IListView * This,
            /* [in] */ ListTextBackgroundConstants penumTextBackground);
        
        END_INTERFACE
    } IListViewVtbl;

    interface IListView
    {
        CONST_VTBL struct IListViewVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IListView_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IListView_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IListView_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IListView_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IListView_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IListView_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IListView_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IListView_get_Arrange(This,pArrange)	\
    (This)->lpVtbl -> get_Arrange(This,pArrange)

#define IListView_put_Arrange(This,pArrange)	\
    (This)->lpVtbl -> put_Arrange(This,pArrange)

#define IListView_get_ColumnHeaders(This,ppIColumnHeaders)	\
    (This)->lpVtbl -> get_ColumnHeaders(This,ppIColumnHeaders)

#define IListView_put_ColumnHeaders(This,ppIColumnHeaders)	\
    (This)->lpVtbl -> put_ColumnHeaders(This,ppIColumnHeaders)

#define IListView_get_DropHighlight(This,ppIListItem)	\
    (This)->lpVtbl -> get_DropHighlight(This,ppIListItem)

#define IListView_putref_DropHighlight(This,ppIListItem)	\
    (This)->lpVtbl -> putref_DropHighlight(This,ppIListItem)

#define IListView_put_DropHighlight(This,ppIListItem)	\
    (This)->lpVtbl -> put_DropHighlight(This,ppIListItem)

#define IListView_get_HideColumnHeaders(This,pfHide)	\
    (This)->lpVtbl -> get_HideColumnHeaders(This,pfHide)

#define IListView_put_HideColumnHeaders(This,pfHide)	\
    (This)->lpVtbl -> put_HideColumnHeaders(This,pfHide)

#define IListView_get_HideSelection(This,pfHide)	\
    (This)->lpVtbl -> get_HideSelection(This,pfHide)

#define IListView_put_HideSelection(This,pfHide)	\
    (This)->lpVtbl -> put_HideSelection(This,pfHide)

#define IListView_get_Icons(This,ppIcons)	\
    (This)->lpVtbl -> get_Icons(This,ppIcons)

#define IListView_putref_Icons(This,ppIcons)	\
    (This)->lpVtbl -> putref_Icons(This,ppIcons)

#define IListView_put_Icons(This,ppIcons)	\
    (This)->lpVtbl -> put_Icons(This,ppIcons)

#define IListView_get_ListItems(This,ppListItems)	\
    (This)->lpVtbl -> get_ListItems(This,ppListItems)

#define IListView_put_ListItems(This,ppListItems)	\
    (This)->lpVtbl -> put_ListItems(This,ppListItems)

#define IListView_get_LabelEdit(This,pRet)	\
    (This)->lpVtbl -> get_LabelEdit(This,pRet)

#define IListView_put_LabelEdit(This,pRet)	\
    (This)->lpVtbl -> put_LabelEdit(This,pRet)

#define IListView_get_LabelWrap(This,pfOn)	\
    (This)->lpVtbl -> get_LabelWrap(This,pfOn)

#define IListView_put_LabelWrap(This,pfOn)	\
    (This)->lpVtbl -> put_LabelWrap(This,pfOn)

#define IListView_get_MouseIcon(This,ppMouseIcon)	\
    (This)->lpVtbl -> get_MouseIcon(This,ppMouseIcon)

#define IListView_put_MouseIcon(This,ppMouseIcon)	\
    (This)->lpVtbl -> put_MouseIcon(This,ppMouseIcon)

#define IListView_putref_MouseIcon(This,ppMouseIcon)	\
    (This)->lpVtbl -> putref_MouseIcon(This,ppMouseIcon)

#define IListView_get_MousePointer(This,pnIndex)	\
    (This)->lpVtbl -> get_MousePointer(This,pnIndex)

#define IListView_put_MousePointer(This,pnIndex)	\
    (This)->lpVtbl -> put_MousePointer(This,pnIndex)

#define IListView_get_MultiSelect(This,pfOn)	\
    (This)->lpVtbl -> get_MultiSelect(This,pfOn)

#define IListView_put_MultiSelect(This,pfOn)	\
    (This)->lpVtbl -> put_MultiSelect(This,pfOn)

#define IListView_get_SelectedItem(This,ppListItem)	\
    (This)->lpVtbl -> get_SelectedItem(This,ppListItem)

#define IListView_putref_SelectedItem(This,ppListItem)	\
    (This)->lpVtbl -> putref_SelectedItem(This,ppListItem)

#define IListView_put_SelectedItem(This,ppListItem)	\
    (This)->lpVtbl -> put_SelectedItem(This,ppListItem)

#define IListView_get_SmallIcons(This,ppImageList)	\
    (This)->lpVtbl -> get_SmallIcons(This,ppImageList)

#define IListView_putref_SmallIcons(This,ppImageList)	\
    (This)->lpVtbl -> putref_SmallIcons(This,ppImageList)

#define IListView_put_SmallIcons(This,ppImageList)	\
    (This)->lpVtbl -> put_SmallIcons(This,ppImageList)

#define IListView_get_Sorted(This,pfOn)	\
    (This)->lpVtbl -> get_Sorted(This,pfOn)

#define IListView_put_Sorted(This,pfOn)	\
    (This)->lpVtbl -> put_Sorted(This,pfOn)

#define IListView_get_SortKey(This,psKey)	\
    (This)->lpVtbl -> get_SortKey(This,psKey)

#define IListView_put_SortKey(This,psKey)	\
    (This)->lpVtbl -> put_SortKey(This,psKey)

#define IListView_get_SortOrder(This,pOrder)	\
    (This)->lpVtbl -> get_SortOrder(This,pOrder)

#define IListView_put_SortOrder(This,pOrder)	\
    (This)->lpVtbl -> put_SortOrder(This,pOrder)

#define IListView_get_View(This,pnView)	\
    (This)->lpVtbl -> get_View(This,pnView)

#define IListView_put_View(This,pnView)	\
    (This)->lpVtbl -> put_View(This,pnView)

#define IListView_get_OLEDragMode(This,psOLEDragMode)	\
    (This)->lpVtbl -> get_OLEDragMode(This,psOLEDragMode)

#define IListView_put_OLEDragMode(This,psOLEDragMode)	\
    (This)->lpVtbl -> put_OLEDragMode(This,psOLEDragMode)

#define IListView_get_OLEDropMode(This,psOLEDropMode)	\
    (This)->lpVtbl -> get_OLEDropMode(This,psOLEDropMode)

#define IListView_put_OLEDropMode(This,psOLEDropMode)	\
    (This)->lpVtbl -> put_OLEDropMode(This,psOLEDropMode)

#define IListView_get_Appearance(This,pnAppearance)	\
    (This)->lpVtbl -> get_Appearance(This,pnAppearance)

#define IListView_put_Appearance(This,pnAppearance)	\
    (This)->lpVtbl -> put_Appearance(This,pnAppearance)

#define IListView_get_BackColor(This,pcrBack)	\
    (This)->lpVtbl -> get_BackColor(This,pcrBack)

#define IListView_put_BackColor(This,pcrBack)	\
    (This)->lpVtbl -> put_BackColor(This,pcrBack)

#define IListView_get_BorderStyle(This,pnStyle)	\
    (This)->lpVtbl -> get_BorderStyle(This,pnStyle)

#define IListView_put_BorderStyle(This,pnStyle)	\
    (This)->lpVtbl -> put_BorderStyle(This,pnStyle)

#define IListView_get_Enabled(This,pfEnabled)	\
    (This)->lpVtbl -> get_Enabled(This,pfEnabled)

#define IListView_put_Enabled(This,pfEnabled)	\
    (This)->lpVtbl -> put_Enabled(This,pfEnabled)

#define IListView_get_Font(This,ppFontDisp)	\
    (This)->lpVtbl -> get_Font(This,ppFontDisp)

#define IListView_putref_Font(This,ppFontDisp)	\
    (This)->lpVtbl -> putref_Font(This,ppFontDisp)

#define IListView_get_ForeColor(This,pcrFore)	\
    (This)->lpVtbl -> get_ForeColor(This,pcrFore)

#define IListView_put_ForeColor(This,pcrFore)	\
    (This)->lpVtbl -> put_ForeColor(This,pcrFore)

#define IListView_get_hWnd(This,phWnd)	\
    (This)->lpVtbl -> get_hWnd(This,phWnd)

#define IListView_put_hWnd(This,phWnd)	\
    (This)->lpVtbl -> put_hWnd(This,phWnd)

#define IListView_FindItem(This,sz,Where,Index,fPartial,ppIListItem)	\
    (This)->lpVtbl -> FindItem(This,sz,Where,Index,fPartial,ppIListItem)

#define IListView_GetFirstVisible(This,ppIListItem)	\
    (This)->lpVtbl -> GetFirstVisible(This,ppIListItem)

#define IListView_HitTest(This,x,y,ppListItem)	\
    (This)->lpVtbl -> HitTest(This,x,y,ppListItem)

#define IListView_StartLabelEdit(This)	\
    (This)->lpVtbl -> StartLabelEdit(This)

#define IListView_OLEDrag(This)	\
    (This)->lpVtbl -> OLEDrag(This)

#define IListView_Refresh(This)	\
    (This)->lpVtbl -> Refresh(This)

#define IListView_AboutBox(This)	\
    (This)->lpVtbl -> AboutBox(This)

#define IListView_get_AllowColumnReorder(This,pfAllowColumnReorder)	\
    (This)->lpVtbl -> get_AllowColumnReorder(This,pfAllowColumnReorder)

#define IListView_put_AllowColumnReorder(This,pfAllowColumnReorder)	\
    (This)->lpVtbl -> put_AllowColumnReorder(This,pfAllowColumnReorder)

#define IListView_get_Checkboxes(This,pfCheckboxes)	\
    (This)->lpVtbl -> get_Checkboxes(This,pfCheckboxes)

#define IListView_put_Checkboxes(This,pfCheckboxes)	\
    (This)->lpVtbl -> put_Checkboxes(This,pfCheckboxes)

#define IListView_get_FlatScrollBar(This,pfFlatScrollBar)	\
    (This)->lpVtbl -> get_FlatScrollBar(This,pfFlatScrollBar)

#define IListView_put_FlatScrollBar(This,pfFlatScrollBar)	\
    (This)->lpVtbl -> put_FlatScrollBar(This,pfFlatScrollBar)

#define IListView_get_FullRowSelect(This,pfFullRowSelect)	\
    (This)->lpVtbl -> get_FullRowSelect(This,pfFullRowSelect)

#define IListView_put_FullRowSelect(This,pfFullRowSelect)	\
    (This)->lpVtbl -> put_FullRowSelect(This,pfFullRowSelect)

#define IListView_get_GridLines(This,pfGridLines)	\
    (This)->lpVtbl -> get_GridLines(This,pfGridLines)

#define IListView_put_GridLines(This,pfGridLines)	\
    (This)->lpVtbl -> put_GridLines(This,pfGridLines)

#define IListView_get_HotTracking(This,pfHotTracking)	\
    (This)->lpVtbl -> get_HotTracking(This,pfHotTracking)

#define IListView_put_HotTracking(This,pfHotTracking)	\
    (This)->lpVtbl -> put_HotTracking(This,pfHotTracking)

#define IListView_get_HoverSelection(This,pfHoverSelection)	\
    (This)->lpVtbl -> get_HoverSelection(This,pfHoverSelection)

#define IListView_put_HoverSelection(This,pfHoverSelection)	\
    (This)->lpVtbl -> put_HoverSelection(This,pfHoverSelection)

#define IListView_get_Picture(This,ppPictureDisp)	\
    (This)->lpVtbl -> get_Picture(This,ppPictureDisp)

#define IListView_put_Picture(This,ppPictureDisp)	\
    (This)->lpVtbl -> put_Picture(This,ppPictureDisp)

#define IListView_putref_Picture(This,ppPictureDisp)	\
    (This)->lpVtbl -> putref_Picture(This,ppPictureDisp)

#define IListView_get_PictureAlignment(This,psAlignment)	\
    (This)->lpVtbl -> get_PictureAlignment(This,psAlignment)

#define IListView_put_PictureAlignment(This,psAlignment)	\
    (This)->lpVtbl -> put_PictureAlignment(This,psAlignment)

#define IListView_get_ColumnHeaderIcons(This,ppImageList)	\
    (This)->lpVtbl -> get_ColumnHeaderIcons(This,ppImageList)

#define IListView_putref_ColumnHeaderIcons(This,ppImageList)	\
    (This)->lpVtbl -> putref_ColumnHeaderIcons(This,ppImageList)

#define IListView_put_ColumnHeaderIcons(This,ppImageList)	\
    (This)->lpVtbl -> put_ColumnHeaderIcons(This,ppImageList)

#define IListView_get_TextBackground(This,penumTextBackground)	\
    (This)->lpVtbl -> get_TextBackground(This,penumTextBackground)

#define IListView_put_TextBackground(This,penumTextBackground)	\
    (This)->lpVtbl -> put_TextBackground(This,penumTextBackground)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IListView_get_Arrange_Proxy( 
    IListView * This,
    /* [retval][out] */ ListArrangeConstants *pArrange);


void __RPC_STUB IListView_get_Arrange_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE IListView_put_Arrange_Proxy( 
    IListView * This,
    /* [in] */ ListArrangeConstants pArrange);


void __RPC_STUB IListView_put_Arrange_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IListView_get_ColumnHeaders_Proxy( 
    IListView * This,
    /* [retval][out] */ IColumnHeaders **ppIColumnHeaders);


void __RPC_STUB IListView_get_ColumnHeaders_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE IListView_put_ColumnHeaders_Proxy( 
    IListView * This,
    /* [in] */ IColumnHeaders *ppIColumnHeaders);


void __RPC_STUB IListView_put_ColumnHeaders_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IListView_get_DropHighlight_Proxy( 
    IListView * This,
    /* [retval][out] */ IListItem **ppIListItem);


void __RPC_STUB IListView_get_DropHighlight_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propputref][id] */ HRESULT STDMETHODCALLTYPE IListView_putref_DropHighlight_Proxy( 
    IListView * This,
    /* [in] */ IListItem *ppIListItem);


void __RPC_STUB IListView_putref_DropHighlight_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE IListView_put_DropHighlight_Proxy( 
    IListView * This,
    /* [in] */ VARIANT *ppIListItem);


void __RPC_STUB IListView_put_DropHighlight_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IListView_get_HideColumnHeaders_Proxy( 
    IListView * This,
    /* [retval][out] */ VARIANT_BOOL *pfHide);


void __RPC_STUB IListView_get_HideColumnHeaders_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE IListView_put_HideColumnHeaders_Proxy( 
    IListView * This,
    /* [in] */ VARIANT_BOOL pfHide);


void __RPC_STUB IListView_put_HideColumnHeaders_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IListView_get_HideSelection_Proxy( 
    IListView * This,
    /* [retval][out] */ VARIANT_BOOL *pfHide);


void __RPC_STUB IListView_get_HideSelection_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE IListView_put_HideSelection_Proxy( 
    IListView * This,
    /* [in] */ VARIANT_BOOL pfHide);


void __RPC_STUB IListView_put_HideSelection_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IListView_get_Icons_Proxy( 
    IListView * This,
    /* [retval][out] */ IDispatch **ppIcons);


void __RPC_STUB IListView_get_Icons_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propputref][id] */ HRESULT STDMETHODCALLTYPE IListView_putref_Icons_Proxy( 
    IListView * This,
    /* [in] */ IDispatch *ppIcons);


void __RPC_STUB IListView_putref_Icons_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE IListView_put_Icons_Proxy( 
    IListView * This,
    /* [in] */ IDispatch *ppIcons);


void __RPC_STUB IListView_put_Icons_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IListView_get_ListItems_Proxy( 
    IListView * This,
    /* [retval][out] */ IListItems **ppListItems);


void __RPC_STUB IListView_get_ListItems_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE IListView_put_ListItems_Proxy( 
    IListView * This,
    /* [in] */ IListItems *ppListItems);


void __RPC_STUB IListView_put_ListItems_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IListView_get_LabelEdit_Proxy( 
    IListView * This,
    /* [retval][out] */ ListLabelEditConstants *pRet);


void __RPC_STUB IListView_get_LabelEdit_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE IListView_put_LabelEdit_Proxy( 
    IListView * This,
    /* [in] */ ListLabelEditConstants pRet);


void __RPC_STUB IListView_put_LabelEdit_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IListView_get_LabelWrap_Proxy( 
    IListView * This,
    /* [retval][out] */ VARIANT_BOOL *pfOn);


void __RPC_STUB IListView_get_LabelWrap_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE IListView_put_LabelWrap_Proxy( 
    IListView * This,
    /* [in] */ VARIANT_BOOL pfOn);


void __RPC_STUB IListView_put_LabelWrap_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IListView_get_MouseIcon_Proxy( 
    IListView * This,
    /* [retval][out] */ /* external definition not present */ IPictureDisp **ppMouseIcon);


void __RPC_STUB IListView_get_MouseIcon_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE IListView_put_MouseIcon_Proxy( 
    IListView * This,
    /* [in] */ /* external definition not present */ IPictureDisp *ppMouseIcon);


void __RPC_STUB IListView_put_MouseIcon_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propputref][id] */ HRESULT STDMETHODCALLTYPE IListView_putref_MouseIcon_Proxy( 
    IListView * This,
    /* [in] */ /* external definition not present */ IPictureDisp *ppMouseIcon);


void __RPC_STUB IListView_putref_MouseIcon_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IListView_get_MousePointer_Proxy( 
    IListView * This,
    /* [retval][out] */ MousePointerConstants *pnIndex);


void __RPC_STUB IListView_get_MousePointer_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE IListView_put_MousePointer_Proxy( 
    IListView * This,
    /* [in] */ MousePointerConstants pnIndex);


void __RPC_STUB IListView_put_MousePointer_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IListView_get_MultiSelect_Proxy( 
    IListView * This,
    /* [retval][out] */ VARIANT_BOOL *pfOn);


void __RPC_STUB IListView_get_MultiSelect_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE IListView_put_MultiSelect_Proxy( 
    IListView * This,
    /* [in] */ VARIANT_BOOL pfOn);


void __RPC_STUB IListView_put_MultiSelect_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IListView_get_SelectedItem_Proxy( 
    IListView * This,
    /* [retval][out] */ IListItem **ppListItem);


void __RPC_STUB IListView_get_SelectedItem_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propputref][id] */ HRESULT STDMETHODCALLTYPE IListView_putref_SelectedItem_Proxy( 
    IListView * This,
    /* [in] */ IListItem *ppListItem);


void __RPC_STUB IListView_putref_SelectedItem_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE IListView_put_SelectedItem_Proxy( 
    IListView * This,
    /* [in] */ VARIANT *ppListItem);


void __RPC_STUB IListView_put_SelectedItem_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IListView_get_SmallIcons_Proxy( 
    IListView * This,
    /* [retval][out] */ IDispatch **ppImageList);


void __RPC_STUB IListView_get_SmallIcons_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propputref][id] */ HRESULT STDMETHODCALLTYPE IListView_putref_SmallIcons_Proxy( 
    IListView * This,
    /* [in] */ IDispatch *ppImageList);


void __RPC_STUB IListView_putref_SmallIcons_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE IListView_put_SmallIcons_Proxy( 
    IListView * This,
    /* [in] */ IDispatch *ppImageList);


void __RPC_STUB IListView_put_SmallIcons_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IListView_get_Sorted_Proxy( 
    IListView * This,
    /* [retval][out] */ VARIANT_BOOL *pfOn);


void __RPC_STUB IListView_get_Sorted_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE IListView_put_Sorted_Proxy( 
    IListView * This,
    /* [in] */ VARIANT_BOOL pfOn);


void __RPC_STUB IListView_put_Sorted_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IListView_get_SortKey_Proxy( 
    IListView * This,
    /* [retval][out] */ short *psKey);


void __RPC_STUB IListView_get_SortKey_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE IListView_put_SortKey_Proxy( 
    IListView * This,
    /* [in] */ short psKey);


void __RPC_STUB IListView_put_SortKey_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IListView_get_SortOrder_Proxy( 
    IListView * This,
    /* [retval][out] */ ListSortOrderConstants *pOrder);


void __RPC_STUB IListView_get_SortOrder_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE IListView_put_SortOrder_Proxy( 
    IListView * This,
    /* [in] */ ListSortOrderConstants pOrder);


void __RPC_STUB IListView_put_SortOrder_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IListView_get_View_Proxy( 
    IListView * This,
    /* [retval][out] */ ListViewConstants *pnView);


void __RPC_STUB IListView_get_View_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE IListView_put_View_Proxy( 
    IListView * This,
    /* [in] */ ListViewConstants pnView);


void __RPC_STUB IListView_put_View_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IListView_get_OLEDragMode_Proxy( 
    IListView * This,
    /* [retval][out] */ OLEDragConstants *psOLEDragMode);


void __RPC_STUB IListView_get_OLEDragMode_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE IListView_put_OLEDragMode_Proxy( 
    IListView * This,
    /* [in] */ OLEDragConstants psOLEDragMode);


void __RPC_STUB IListView_put_OLEDragMode_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IListView_get_OLEDropMode_Proxy( 
    IListView * This,
    /* [retval][out] */ OLEDropConstants *psOLEDropMode);


void __RPC_STUB IListView_get_OLEDropMode_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE IListView_put_OLEDropMode_Proxy( 
    IListView * This,
    /* [in] */ OLEDropConstants psOLEDropMode);


void __RPC_STUB IListView_put_OLEDropMode_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IListView_get_Appearance_Proxy( 
    IListView * This,
    /* [retval][out] */ AppearanceConstants *pnAppearance);


void __RPC_STUB IListView_get_Appearance_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE IListView_put_Appearance_Proxy( 
    IListView * This,
    /* [in] */ AppearanceConstants pnAppearance);


void __RPC_STUB IListView_put_Appearance_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IListView_get_BackColor_Proxy( 
    IListView * This,
    /* [retval][out] */ /* external definition not present */ OLE_COLOR *pcrBack);


void __RPC_STUB IListView_get_BackColor_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE IListView_put_BackColor_Proxy( 
    IListView * This,
    /* [in] */ /* external definition not present */ OLE_COLOR pcrBack);


void __RPC_STUB IListView_put_BackColor_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IListView_get_BorderStyle_Proxy( 
    IListView * This,
    /* [retval][out] */ BorderStyleConstants *pnStyle);


void __RPC_STUB IListView_get_BorderStyle_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE IListView_put_BorderStyle_Proxy( 
    IListView * This,
    /* [in] */ BorderStyleConstants pnStyle);


void __RPC_STUB IListView_put_BorderStyle_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IListView_get_Enabled_Proxy( 
    IListView * This,
    /* [retval][out] */ VARIANT_BOOL *pfEnabled);


void __RPC_STUB IListView_get_Enabled_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE IListView_put_Enabled_Proxy( 
    IListView * This,
    /* [in] */ VARIANT_BOOL pfEnabled);


void __RPC_STUB IListView_put_Enabled_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IListView_get_Font_Proxy( 
    IListView * This,
    /* [retval][out] */ /* external definition not present */ IFontDisp **ppFontDisp);


void __RPC_STUB IListView_get_Font_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propputref][id] */ HRESULT STDMETHODCALLTYPE IListView_putref_Font_Proxy( 
    IListView * This,
    /* [in] */ /* external definition not present */ IFontDisp *ppFontDisp);


void __RPC_STUB IListView_putref_Font_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IListView_get_ForeColor_Proxy( 
    IListView * This,
    /* [retval][out] */ /* external definition not present */ OLE_COLOR *pcrFore);


void __RPC_STUB IListView_get_ForeColor_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE IListView_put_ForeColor_Proxy( 
    IListView * This,
    /* [in] */ /* external definition not present */ OLE_COLOR pcrFore);


void __RPC_STUB IListView_put_ForeColor_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IListView_get_hWnd_Proxy( 
    IListView * This,
    /* [retval][out] */ /* external definition not present */ OLE_HANDLE *phWnd);


void __RPC_STUB IListView_get_hWnd_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE IListView_put_hWnd_Proxy( 
    IListView * This,
    /* [in] */ /* external definition not present */ OLE_HANDLE phWnd);


void __RPC_STUB IListView_put_hWnd_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][id] */ HRESULT STDMETHODCALLTYPE IListView_FindItem_Proxy( 
    IListView * This,
    /* [in] */ BSTR sz,
    /* [optional][in] */ VARIANT *Where,
    /* [optional][in] */ VARIANT *Index,
    /* [optional][in] */ VARIANT *fPartial,
    /* [retval][out] */ IListItem **ppIListItem);


void __RPC_STUB IListView_FindItem_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][id] */ HRESULT STDMETHODCALLTYPE IListView_GetFirstVisible_Proxy( 
    IListView * This,
    /* [retval][out] */ IListItem **ppIListItem);


void __RPC_STUB IListView_GetFirstVisible_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][id] */ HRESULT STDMETHODCALLTYPE IListView_HitTest_Proxy( 
    IListView * This,
    /* [in] */ single x,
    /* [in] */ single y,
    /* [retval][out] */ IListItem **ppListItem);


void __RPC_STUB IListView_HitTest_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][id] */ HRESULT STDMETHODCALLTYPE IListView_StartLabelEdit_Proxy( 
    IListView * This);


void __RPC_STUB IListView_StartLabelEdit_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][id] */ HRESULT STDMETHODCALLTYPE IListView_OLEDrag_Proxy( 
    IListView * This);


void __RPC_STUB IListView_OLEDrag_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][id] */ void STDMETHODCALLTYPE IListView_Refresh_Proxy( 
    IListView * This);


void __RPC_STUB IListView_Refresh_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [hidden][id] */ void STDMETHODCALLTYPE IListView_AboutBox_Proxy( 
    IListView * This);


void __RPC_STUB IListView_AboutBox_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IListView_get_AllowColumnReorder_Proxy( 
    IListView * This,
    /* [retval][out] */ VARIANT_BOOL *pfAllowColumnReorder);


void __RPC_STUB IListView_get_AllowColumnReorder_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE IListView_put_AllowColumnReorder_Proxy( 
    IListView * This,
    /* [in] */ VARIANT_BOOL pfAllowColumnReorder);


void __RPC_STUB IListView_put_AllowColumnReorder_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IListView_get_Checkboxes_Proxy( 
    IListView * This,
    /* [retval][out] */ VARIANT_BOOL *pfCheckboxes);


void __RPC_STUB IListView_get_Checkboxes_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE IListView_put_Checkboxes_Proxy( 
    IListView * This,
    /* [in] */ VARIANT_BOOL pfCheckboxes);


void __RPC_STUB IListView_put_Checkboxes_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IListView_get_FlatScrollBar_Proxy( 
    IListView * This,
    /* [retval][out] */ VARIANT_BOOL *pfFlatScrollBar);


void __RPC_STUB IListView_get_FlatScrollBar_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE IListView_put_FlatScrollBar_Proxy( 
    IListView * This,
    /* [in] */ VARIANT_BOOL pfFlatScrollBar);


void __RPC_STUB IListView_put_FlatScrollBar_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IListView_get_FullRowSelect_Proxy( 
    IListView * This,
    /* [retval][out] */ VARIANT_BOOL *pfFullRowSelect);


void __RPC_STUB IListView_get_FullRowSelect_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE IListView_put_FullRowSelect_Proxy( 
    IListView * This,
    /* [in] */ VARIANT_BOOL pfFullRowSelect);


void __RPC_STUB IListView_put_FullRowSelect_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IListView_get_GridLines_Proxy( 
    IListView * This,
    /* [retval][out] */ VARIANT_BOOL *pfGridLines);


void __RPC_STUB IListView_get_GridLines_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE IListView_put_GridLines_Proxy( 
    IListView * This,
    /* [in] */ VARIANT_BOOL pfGridLines);


void __RPC_STUB IListView_put_GridLines_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IListView_get_HotTracking_Proxy( 
    IListView * This,
    /* [retval][out] */ VARIANT_BOOL *pfHotTracking);


void __RPC_STUB IListView_get_HotTracking_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE IListView_put_HotTracking_Proxy( 
    IListView * This,
    /* [in] */ VARIANT_BOOL pfHotTracking);


void __RPC_STUB IListView_put_HotTracking_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IListView_get_HoverSelection_Proxy( 
    IListView * This,
    /* [retval][out] */ VARIANT_BOOL *pfHoverSelection);


void __RPC_STUB IListView_get_HoverSelection_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE IListView_put_HoverSelection_Proxy( 
    IListView * This,
    /* [in] */ VARIANT_BOOL pfHoverSelection);


void __RPC_STUB IListView_put_HoverSelection_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IListView_get_Picture_Proxy( 
    IListView * This,
    /* [retval][out] */ /* external definition not present */ IPictureDisp **ppPictureDisp);


void __RPC_STUB IListView_get_Picture_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE IListView_put_Picture_Proxy( 
    IListView * This,
    /* [in] */ /* external definition not present */ IPictureDisp *ppPictureDisp);


void __RPC_STUB IListView_put_Picture_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propputref][id] */ HRESULT STDMETHODCALLTYPE IListView_putref_Picture_Proxy( 
    IListView * This,
    /* [in] */ /* external definition not present */ IPictureDisp *ppPictureDisp);


void __RPC_STUB IListView_putref_Picture_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IListView_get_PictureAlignment_Proxy( 
    IListView * This,
    /* [retval][out] */ ListPictureAlignmentConstants *psAlignment);


void __RPC_STUB IListView_get_PictureAlignment_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE IListView_put_PictureAlignment_Proxy( 
    IListView * This,
    /* [in] */ ListPictureAlignmentConstants psAlignment);


void __RPC_STUB IListView_put_PictureAlignment_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IListView_get_ColumnHeaderIcons_Proxy( 
    IListView * This,
    /* [retval][out] */ IDispatch **ppImageList);


void __RPC_STUB IListView_get_ColumnHeaderIcons_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propputref][id] */ HRESULT STDMETHODCALLTYPE IListView_putref_ColumnHeaderIcons_Proxy( 
    IListView * This,
    /* [in] */ IDispatch *ppImageList);


void __RPC_STUB IListView_putref_ColumnHeaderIcons_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE IListView_put_ColumnHeaderIcons_Proxy( 
    IListView * This,
    /* [in] */ IDispatch *ppImageList);


void __RPC_STUB IListView_put_ColumnHeaderIcons_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IListView_get_TextBackground_Proxy( 
    IListView * This,
    /* [retval][out] */ ListTextBackgroundConstants *penumTextBackground);


void __RPC_STUB IListView_get_TextBackground_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE IListView_put_TextBackground_Proxy( 
    IListView * This,
    /* [in] */ ListTextBackgroundConstants penumTextBackground);


void __RPC_STUB IListView_put_TextBackground_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IListView_INTERFACE_DEFINED__ */


#ifndef __ListViewEvents_DISPINTERFACE_DEFINED__
#define __ListViewEvents_DISPINTERFACE_DEFINED__

/* dispinterface ListViewEvents */
/* [nonextensible][helpcontext][helpstring][uuid] */ 


EXTERN_C const IID DIID_ListViewEvents;

#if defined(__cplusplus) && !defined(CINTERFACE)

    MIDL_INTERFACE("BDD1F04A-858B-11D1-B16A-00C0F0283628")
    ListViewEvents : public IDispatch
    {
    };
    
#else 	/* C style interface */

    typedef struct ListViewEventsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ListViewEvents * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ListViewEvents * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ListViewEvents * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            ListViewEvents * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            ListViewEvents * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            ListViewEvents * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            ListViewEvents * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        END_INTERFACE
    } ListViewEventsVtbl;

    interface ListViewEvents
    {
        CONST_VTBL struct ListViewEventsVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ListViewEvents_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ListViewEvents_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ListViewEvents_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ListViewEvents_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define ListViewEvents_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define ListViewEvents_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define ListViewEvents_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)

#endif /* COBJMACROS */


#endif 	/* C style interface */


#endif 	/* __ListViewEvents_DISPINTERFACE_DEFINED__ */


#ifndef __IListItems_INTERFACE_DEFINED__
#define __IListItems_INTERFACE_DEFINED__

/* interface IListItems */
/* [object][oleautomation][nonextensible][dual][hidden][helpcontext][helpstring][uuid] */ 


EXTERN_C const IID IID_IListItems;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("BDD1F04C-858B-11D1-B16A-00C0F0283628")
    IListItems : public IDispatch
    {
    public:
        virtual /* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_Count( 
            /* [retval][out] */ long *plCount) = 0;
        
        virtual /* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_Count( 
            /* [in] */ long plCount) = 0;
        
        virtual /* [hidden][propget][id] */ HRESULT STDMETHODCALLTYPE get_ControlDefault( 
            /* [in] */ VARIANT *Index,
            /* [retval][out] */ IListItem **ppIListItem) = 0;
        
        virtual /* [helpcontext][helpstring][id] */ HRESULT STDMETHODCALLTYPE Add( 
            /* [optional][in] */ VARIANT *Index,
            /* [optional][in] */ VARIANT *Key,
            /* [optional][in] */ VARIANT *Text,
            /* [optional][in] */ VARIANT *Icon,
            /* [optional][in] */ VARIANT *SmallIcon,
            /* [retval][out] */ IListItem **ppIListItem) = 0;
        
        virtual /* [helpcontext][helpstring][id] */ HRESULT STDMETHODCALLTYPE Clear( void) = 0;
        
        virtual /* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_Item( 
            /* [in] */ VARIANT *Index,
            /* [retval][out] */ IListItem **ppIListItem) = 0;
        
        virtual /* [helpcontext][helpstring][id] */ HRESULT STDMETHODCALLTYPE Remove( 
            /* [in] */ VARIANT *Index) = 0;
        
        virtual /* [hidden][id] */ HRESULT STDMETHODCALLTYPE _NewEnum( 
            /* [retval][out] */ IUnknown **ppNewEnum) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IListItemsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IListItems * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IListItems * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IListItems * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IListItems * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IListItems * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IListItems * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IListItems * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_Count )( 
            IListItems * This,
            /* [retval][out] */ long *plCount);
        
        /* [helpcontext][helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_Count )( 
            IListItems * This,
            /* [in] */ long plCount);
        
        /* [hidden][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_ControlDefault )( 
            IListItems * This,
            /* [in] */ VARIANT *Index,
            /* [retval][out] */ IListItem **ppIListItem);
        
        /* [helpcontext][helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Add )( 
            IListItems * This,
            /* [optional][in] */ VARIANT *Index,
            /* [optional][in] */ VARIANT *Key,
            /* [optional][in] */ VARIANT *Text,
            /* [optional][in] */ VARIANT *Icon,
            /* [optional][in] */ VARIANT *SmallIcon,
            /* [retval][out] */ IListItem **ppIListItem);
        
        /* [helpcontext][helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Clear )( 
            IListItems * This);
        
        /* [helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_Item )( 
            IListItems * This,
            /* [in] */ VARIANT *Index,
            /* [retval][out] */ IListItem **ppIListItem);
        
        /* [helpcontext][helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Remove )( 
            IListItems * This,
            /* [in] */ VARIANT *Index);
        
        /* [hidden][id] */ HRESULT ( STDMETHODCALLTYPE *_NewEnum )( 
            IListItems * This,
            /* [retval][out] */ IUnknown **ppNewEnum);
        
        END_INTERFACE
    } IListItemsVtbl;

    interface IListItems
    {
        CONST_VTBL struct IListItemsVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IListItems_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IListItems_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IListItems_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IListItems_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IListItems_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IListItems_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IListItems_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IListItems_get_Count(This,plCount)	\
    (This)->lpVtbl -> get_Count(This,plCount)

#define IListItems_put_Count(This,plCount)	\
    (This)->lpVtbl -> put_Count(This,plCount)

#define IListItems_get_ControlDefault(This,Index,ppIListItem)	\
    (This)->lpVtbl -> get_ControlDefault(This,Index,ppIListItem)

#define IListItems_Add(This,Index,Key,Text,Icon,SmallIcon,ppIListItem)	\
    (This)->lpVtbl -> Add(This,Index,Key,Text,Icon,SmallIcon,ppIListItem)

#define IListItems_Clear(This)	\
    (This)->lpVtbl -> Clear(This)

#define IListItems_get_Item(This,Index,ppIListItem)	\
    (This)->lpVtbl -> get_Item(This,Index,ppIListItem)

#define IListItems_Remove(This,Index)	\
    (This)->lpVtbl -> Remove(This,Index)

#define IListItems__NewEnum(This,ppNewEnum)	\
    (This)->lpVtbl -> _NewEnum(This,ppNewEnum)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IListItems_get_Count_Proxy( 
    IListItems * This,
    /* [retval][out] */ long *plCount);


void __RPC_STUB IListItems_get_Count_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE IListItems_put_Count_Proxy( 
    IListItems * This,
    /* [in] */ long plCount);


void __RPC_STUB IListItems_put_Count_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [hidden][propget][id] */ HRESULT STDMETHODCALLTYPE IListItems_get_ControlDefault_Proxy( 
    IListItems * This,
    /* [in] */ VARIANT *Index,
    /* [retval][out] */ IListItem **ppIListItem);


void __RPC_STUB IListItems_get_ControlDefault_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][id] */ HRESULT STDMETHODCALLTYPE IListItems_Add_Proxy( 
    IListItems * This,
    /* [optional][in] */ VARIANT *Index,
    /* [optional][in] */ VARIANT *Key,
    /* [optional][in] */ VARIANT *Text,
    /* [optional][in] */ VARIANT *Icon,
    /* [optional][in] */ VARIANT *SmallIcon,
    /* [retval][out] */ IListItem **ppIListItem);


void __RPC_STUB IListItems_Add_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][id] */ HRESULT STDMETHODCALLTYPE IListItems_Clear_Proxy( 
    IListItems * This);


void __RPC_STUB IListItems_Clear_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IListItems_get_Item_Proxy( 
    IListItems * This,
    /* [in] */ VARIANT *Index,
    /* [retval][out] */ IListItem **ppIListItem);


void __RPC_STUB IListItems_get_Item_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][id] */ HRESULT STDMETHODCALLTYPE IListItems_Remove_Proxy( 
    IListItems * This,
    /* [in] */ VARIANT *Index);


void __RPC_STUB IListItems_Remove_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [hidden][id] */ HRESULT STDMETHODCALLTYPE IListItems__NewEnum_Proxy( 
    IListItems * This,
    /* [retval][out] */ IUnknown **ppNewEnum);


void __RPC_STUB IListItems__NewEnum_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IListItems_INTERFACE_DEFINED__ */


#ifndef __IListItem_INTERFACE_DEFINED__
#define __IListItem_INTERFACE_DEFINED__

/* interface IListItem */
/* [object][oleautomation][nonextensible][dual][hidden][helpcontext][helpstring][uuid] */ 


EXTERN_C const IID IID_IListItem;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("BDD1F04E-858B-11D1-B16A-00C0F0283628")
    IListItem : public IDispatch
    {
    public:
        virtual /* [hidden][propget][id] */ HRESULT STDMETHODCALLTYPE get_Default( 
            /* [retval][out] */ BSTR *pbstrText) = 0;
        
        virtual /* [hidden][propput][id] */ HRESULT STDMETHODCALLTYPE put_Default( 
            /* [in] */ BSTR pbstrText) = 0;
        
        virtual /* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_Text( 
            /* [retval][out] */ BSTR *pbstrText) = 0;
        
        virtual /* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_Text( 
            /* [in] */ BSTR pbstrText) = 0;
        
        virtual /* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_Ghosted( 
            /* [retval][out] */ VARIANT_BOOL *pfOn) = 0;
        
        virtual /* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_Ghosted( 
            /* [in] */ VARIANT_BOOL pfOn) = 0;
        
        virtual /* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_Height( 
            /* [retval][out] */ single *pflHeight) = 0;
        
        virtual /* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_Height( 
            /* [in] */ single pflHeight) = 0;
        
        virtual /* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_Icon( 
            /* [retval][out] */ VARIANT *pnIndex) = 0;
        
        virtual /* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_Icon( 
            /* [in] */ VARIANT pnIndex) = 0;
        
        virtual /* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_Index( 
            /* [retval][out] */ long *plIndex) = 0;
        
        virtual /* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_Index( 
            /* [in] */ long plIndex) = 0;
        
        virtual /* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_Key( 
            /* [retval][out] */ BSTR *pbstrKey) = 0;
        
        virtual /* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_Key( 
            /* [in] */ BSTR pbstrKey) = 0;
        
        virtual /* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_Left( 
            /* [retval][out] */ single *pflLeft) = 0;
        
        virtual /* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_Left( 
            /* [in] */ single pflLeft) = 0;
        
        virtual /* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_Selected( 
            /* [retval][out] */ VARIANT_BOOL *pfOn) = 0;
        
        virtual /* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_Selected( 
            /* [in] */ VARIANT_BOOL pfOn) = 0;
        
        virtual /* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_SmallIcon( 
            /* [retval][out] */ VARIANT *pnIndex) = 0;
        
        virtual /* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_SmallIcon( 
            /* [in] */ VARIANT pnIndex) = 0;
        
        virtual /* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_Tag( 
            /* [retval][out] */ VARIANT *pvTag) = 0;
        
        virtual /* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_Tag( 
            /* [in] */ VARIANT pvTag) = 0;
        
        virtual /* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_Top( 
            /* [retval][out] */ single *pflTop) = 0;
        
        virtual /* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_Top( 
            /* [in] */ single pflTop) = 0;
        
        virtual /* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_Width( 
            /* [retval][out] */ single *pflWidth) = 0;
        
        virtual /* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_Width( 
            /* [in] */ single pflWidth) = 0;
        
        virtual /* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_SubItems( 
            /* [in] */ short Index,
            /* [retval][out] */ BSTR *pbstrItem) = 0;
        
        virtual /* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_SubItems( 
            /* [in] */ short Index,
            /* [in] */ BSTR pbstrItem) = 0;
        
        virtual /* [helpcontext][helpstring][id] */ HRESULT STDMETHODCALLTYPE CreateDragImage( 
            /* [retval][out] */ /* external definition not present */ IPictureDisp **ppImage) = 0;
        
        virtual /* [helpcontext][helpstring][id] */ HRESULT STDMETHODCALLTYPE EnsureVisible( 
            /* [retval][out] */ VARIANT_BOOL *pfVisible) = 0;
        
        virtual /* [helpcontext][helpstring][propputref][id] */ HRESULT STDMETHODCALLTYPE putref_Tag( 
            /* [in] */ VARIANT pvTag) = 0;
        
        virtual /* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_ListSubItems( 
            /* [retval][out] */ IListSubItems **ppSubItems) = 0;
        
        virtual /* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_ListSubItems( 
            /* [in] */ IListSubItems *ppSubItems) = 0;
        
        virtual /* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_Checked( 
            /* [retval][out] */ VARIANT_BOOL *pfChecked) = 0;
        
        virtual /* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_Checked( 
            /* [in] */ VARIANT_BOOL pfChecked) = 0;
        
        virtual /* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_ForeColor( 
            /* [retval][out] */ /* external definition not present */ OLE_COLOR *pcrFore) = 0;
        
        virtual /* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_ForeColor( 
            /* [in] */ /* external definition not present */ OLE_COLOR pcrFore) = 0;
        
        virtual /* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_ToolTipText( 
            /* [retval][out] */ BSTR *pbstrToolTipText) = 0;
        
        virtual /* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_ToolTipText( 
            /* [in] */ BSTR pbstrToolTipText) = 0;
        
        virtual /* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_Bold( 
            /* [retval][out] */ VARIANT_BOOL *pfBold) = 0;
        
        virtual /* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_Bold( 
            /* [in] */ VARIANT_BOOL pfBold) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IListItemVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IListItem * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IListItem * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IListItem * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IListItem * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IListItem * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IListItem * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IListItem * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [hidden][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_Default )( 
            IListItem * This,
            /* [retval][out] */ BSTR *pbstrText);
        
        /* [hidden][propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_Default )( 
            IListItem * This,
            /* [in] */ BSTR pbstrText);
        
        /* [helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_Text )( 
            IListItem * This,
            /* [retval][out] */ BSTR *pbstrText);
        
        /* [helpcontext][helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_Text )( 
            IListItem * This,
            /* [in] */ BSTR pbstrText);
        
        /* [helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_Ghosted )( 
            IListItem * This,
            /* [retval][out] */ VARIANT_BOOL *pfOn);
        
        /* [helpcontext][helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_Ghosted )( 
            IListItem * This,
            /* [in] */ VARIANT_BOOL pfOn);
        
        /* [helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_Height )( 
            IListItem * This,
            /* [retval][out] */ single *pflHeight);
        
        /* [helpcontext][helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_Height )( 
            IListItem * This,
            /* [in] */ single pflHeight);
        
        /* [helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_Icon )( 
            IListItem * This,
            /* [retval][out] */ VARIANT *pnIndex);
        
        /* [helpcontext][helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_Icon )( 
            IListItem * This,
            /* [in] */ VARIANT pnIndex);
        
        /* [helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_Index )( 
            IListItem * This,
            /* [retval][out] */ long *plIndex);
        
        /* [helpcontext][helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_Index )( 
            IListItem * This,
            /* [in] */ long plIndex);
        
        /* [helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_Key )( 
            IListItem * This,
            /* [retval][out] */ BSTR *pbstrKey);
        
        /* [helpcontext][helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_Key )( 
            IListItem * This,
            /* [in] */ BSTR pbstrKey);
        
        /* [helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_Left )( 
            IListItem * This,
            /* [retval][out] */ single *pflLeft);
        
        /* [helpcontext][helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_Left )( 
            IListItem * This,
            /* [in] */ single pflLeft);
        
        /* [helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_Selected )( 
            IListItem * This,
            /* [retval][out] */ VARIANT_BOOL *pfOn);
        
        /* [helpcontext][helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_Selected )( 
            IListItem * This,
            /* [in] */ VARIANT_BOOL pfOn);
        
        /* [helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_SmallIcon )( 
            IListItem * This,
            /* [retval][out] */ VARIANT *pnIndex);
        
        /* [helpcontext][helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_SmallIcon )( 
            IListItem * This,
            /* [in] */ VARIANT pnIndex);
        
        /* [helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_Tag )( 
            IListItem * This,
            /* [retval][out] */ VARIANT *pvTag);
        
        /* [helpcontext][helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_Tag )( 
            IListItem * This,
            /* [in] */ VARIANT pvTag);
        
        /* [helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_Top )( 
            IListItem * This,
            /* [retval][out] */ single *pflTop);
        
        /* [helpcontext][helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_Top )( 
            IListItem * This,
            /* [in] */ single pflTop);
        
        /* [helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_Width )( 
            IListItem * This,
            /* [retval][out] */ single *pflWidth);
        
        /* [helpcontext][helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_Width )( 
            IListItem * This,
            /* [in] */ single pflWidth);
        
        /* [helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_SubItems )( 
            IListItem * This,
            /* [in] */ short Index,
            /* [retval][out] */ BSTR *pbstrItem);
        
        /* [helpcontext][helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_SubItems )( 
            IListItem * This,
            /* [in] */ short Index,
            /* [in] */ BSTR pbstrItem);
        
        /* [helpcontext][helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *CreateDragImage )( 
            IListItem * This,
            /* [retval][out] */ /* external definition not present */ IPictureDisp **ppImage);
        
        /* [helpcontext][helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *EnsureVisible )( 
            IListItem * This,
            /* [retval][out] */ VARIANT_BOOL *pfVisible);
        
        /* [helpcontext][helpstring][propputref][id] */ HRESULT ( STDMETHODCALLTYPE *putref_Tag )( 
            IListItem * This,
            /* [in] */ VARIANT pvTag);
        
        /* [helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_ListSubItems )( 
            IListItem * This,
            /* [retval][out] */ IListSubItems **ppSubItems);
        
        /* [helpcontext][helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_ListSubItems )( 
            IListItem * This,
            /* [in] */ IListSubItems *ppSubItems);
        
        /* [helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_Checked )( 
            IListItem * This,
            /* [retval][out] */ VARIANT_BOOL *pfChecked);
        
        /* [helpcontext][helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_Checked )( 
            IListItem * This,
            /* [in] */ VARIANT_BOOL pfChecked);
        
        /* [helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_ForeColor )( 
            IListItem * This,
            /* [retval][out] */ /* external definition not present */ OLE_COLOR *pcrFore);
        
        /* [helpcontext][helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_ForeColor )( 
            IListItem * This,
            /* [in] */ /* external definition not present */ OLE_COLOR pcrFore);
        
        /* [helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_ToolTipText )( 
            IListItem * This,
            /* [retval][out] */ BSTR *pbstrToolTipText);
        
        /* [helpcontext][helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_ToolTipText )( 
            IListItem * This,
            /* [in] */ BSTR pbstrToolTipText);
        
        /* [helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_Bold )( 
            IListItem * This,
            /* [retval][out] */ VARIANT_BOOL *pfBold);
        
        /* [helpcontext][helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_Bold )( 
            IListItem * This,
            /* [in] */ VARIANT_BOOL pfBold);
        
        END_INTERFACE
    } IListItemVtbl;

    interface IListItem
    {
        CONST_VTBL struct IListItemVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IListItem_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IListItem_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IListItem_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IListItem_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IListItem_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IListItem_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IListItem_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IListItem_get_Default(This,pbstrText)	\
    (This)->lpVtbl -> get_Default(This,pbstrText)

#define IListItem_put_Default(This,pbstrText)	\
    (This)->lpVtbl -> put_Default(This,pbstrText)

#define IListItem_get_Text(This,pbstrText)	\
    (This)->lpVtbl -> get_Text(This,pbstrText)

#define IListItem_put_Text(This,pbstrText)	\
    (This)->lpVtbl -> put_Text(This,pbstrText)

#define IListItem_get_Ghosted(This,pfOn)	\
    (This)->lpVtbl -> get_Ghosted(This,pfOn)

#define IListItem_put_Ghosted(This,pfOn)	\
    (This)->lpVtbl -> put_Ghosted(This,pfOn)

#define IListItem_get_Height(This,pflHeight)	\
    (This)->lpVtbl -> get_Height(This,pflHeight)

#define IListItem_put_Height(This,pflHeight)	\
    (This)->lpVtbl -> put_Height(This,pflHeight)

#define IListItem_get_Icon(This,pnIndex)	\
    (This)->lpVtbl -> get_Icon(This,pnIndex)

#define IListItem_put_Icon(This,pnIndex)	\
    (This)->lpVtbl -> put_Icon(This,pnIndex)

#define IListItem_get_Index(This,plIndex)	\
    (This)->lpVtbl -> get_Index(This,plIndex)

#define IListItem_put_Index(This,plIndex)	\
    (This)->lpVtbl -> put_Index(This,plIndex)

#define IListItem_get_Key(This,pbstrKey)	\
    (This)->lpVtbl -> get_Key(This,pbstrKey)

#define IListItem_put_Key(This,pbstrKey)	\
    (This)->lpVtbl -> put_Key(This,pbstrKey)

#define IListItem_get_Left(This,pflLeft)	\
    (This)->lpVtbl -> get_Left(This,pflLeft)

#define IListItem_put_Left(This,pflLeft)	\
    (This)->lpVtbl -> put_Left(This,pflLeft)

#define IListItem_get_Selected(This,pfOn)	\
    (This)->lpVtbl -> get_Selected(This,pfOn)

#define IListItem_put_Selected(This,pfOn)	\
    (This)->lpVtbl -> put_Selected(This,pfOn)

#define IListItem_get_SmallIcon(This,pnIndex)	\
    (This)->lpVtbl -> get_SmallIcon(This,pnIndex)

#define IListItem_put_SmallIcon(This,pnIndex)	\
    (This)->lpVtbl -> put_SmallIcon(This,pnIndex)

#define IListItem_get_Tag(This,pvTag)	\
    (This)->lpVtbl -> get_Tag(This,pvTag)

#define IListItem_put_Tag(This,pvTag)	\
    (This)->lpVtbl -> put_Tag(This,pvTag)

#define IListItem_get_Top(This,pflTop)	\
    (This)->lpVtbl -> get_Top(This,pflTop)

#define IListItem_put_Top(This,pflTop)	\
    (This)->lpVtbl -> put_Top(This,pflTop)

#define IListItem_get_Width(This,pflWidth)	\
    (This)->lpVtbl -> get_Width(This,pflWidth)

#define IListItem_put_Width(This,pflWidth)	\
    (This)->lpVtbl -> put_Width(This,pflWidth)

#define IListItem_get_SubItems(This,Index,pbstrItem)	\
    (This)->lpVtbl -> get_SubItems(This,Index,pbstrItem)

#define IListItem_put_SubItems(This,Index,pbstrItem)	\
    (This)->lpVtbl -> put_SubItems(This,Index,pbstrItem)

#define IListItem_CreateDragImage(This,ppImage)	\
    (This)->lpVtbl -> CreateDragImage(This,ppImage)

#define IListItem_EnsureVisible(This,pfVisible)	\
    (This)->lpVtbl -> EnsureVisible(This,pfVisible)

#define IListItem_putref_Tag(This,pvTag)	\
    (This)->lpVtbl -> putref_Tag(This,pvTag)

#define IListItem_get_ListSubItems(This,ppSubItems)	\
    (This)->lpVtbl -> get_ListSubItems(This,ppSubItems)

#define IListItem_put_ListSubItems(This,ppSubItems)	\
    (This)->lpVtbl -> put_ListSubItems(This,ppSubItems)

#define IListItem_get_Checked(This,pfChecked)	\
    (This)->lpVtbl -> get_Checked(This,pfChecked)

#define IListItem_put_Checked(This,pfChecked)	\
    (This)->lpVtbl -> put_Checked(This,pfChecked)

#define IListItem_get_ForeColor(This,pcrFore)	\
    (This)->lpVtbl -> get_ForeColor(This,pcrFore)

#define IListItem_put_ForeColor(This,pcrFore)	\
    (This)->lpVtbl -> put_ForeColor(This,pcrFore)

#define IListItem_get_ToolTipText(This,pbstrToolTipText)	\
    (This)->lpVtbl -> get_ToolTipText(This,pbstrToolTipText)

#define IListItem_put_ToolTipText(This,pbstrToolTipText)	\
    (This)->lpVtbl -> put_ToolTipText(This,pbstrToolTipText)

#define IListItem_get_Bold(This,pfBold)	\
    (This)->lpVtbl -> get_Bold(This,pfBold)

#define IListItem_put_Bold(This,pfBold)	\
    (This)->lpVtbl -> put_Bold(This,pfBold)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [hidden][propget][id] */ HRESULT STDMETHODCALLTYPE IListItem_get_Default_Proxy( 
    IListItem * This,
    /* [retval][out] */ BSTR *pbstrText);


void __RPC_STUB IListItem_get_Default_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [hidden][propput][id] */ HRESULT STDMETHODCALLTYPE IListItem_put_Default_Proxy( 
    IListItem * This,
    /* [in] */ BSTR pbstrText);


void __RPC_STUB IListItem_put_Default_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IListItem_get_Text_Proxy( 
    IListItem * This,
    /* [retval][out] */ BSTR *pbstrText);


void __RPC_STUB IListItem_get_Text_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE IListItem_put_Text_Proxy( 
    IListItem * This,
    /* [in] */ BSTR pbstrText);


void __RPC_STUB IListItem_put_Text_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IListItem_get_Ghosted_Proxy( 
    IListItem * This,
    /* [retval][out] */ VARIANT_BOOL *pfOn);


void __RPC_STUB IListItem_get_Ghosted_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE IListItem_put_Ghosted_Proxy( 
    IListItem * This,
    /* [in] */ VARIANT_BOOL pfOn);


void __RPC_STUB IListItem_put_Ghosted_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IListItem_get_Height_Proxy( 
    IListItem * This,
    /* [retval][out] */ single *pflHeight);


void __RPC_STUB IListItem_get_Height_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE IListItem_put_Height_Proxy( 
    IListItem * This,
    /* [in] */ single pflHeight);


void __RPC_STUB IListItem_put_Height_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IListItem_get_Icon_Proxy( 
    IListItem * This,
    /* [retval][out] */ VARIANT *pnIndex);


void __RPC_STUB IListItem_get_Icon_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE IListItem_put_Icon_Proxy( 
    IListItem * This,
    /* [in] */ VARIANT pnIndex);


void __RPC_STUB IListItem_put_Icon_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IListItem_get_Index_Proxy( 
    IListItem * This,
    /* [retval][out] */ long *plIndex);


void __RPC_STUB IListItem_get_Index_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE IListItem_put_Index_Proxy( 
    IListItem * This,
    /* [in] */ long plIndex);


void __RPC_STUB IListItem_put_Index_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IListItem_get_Key_Proxy( 
    IListItem * This,
    /* [retval][out] */ BSTR *pbstrKey);


void __RPC_STUB IListItem_get_Key_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE IListItem_put_Key_Proxy( 
    IListItem * This,
    /* [in] */ BSTR pbstrKey);


void __RPC_STUB IListItem_put_Key_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IListItem_get_Left_Proxy( 
    IListItem * This,
    /* [retval][out] */ single *pflLeft);


void __RPC_STUB IListItem_get_Left_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE IListItem_put_Left_Proxy( 
    IListItem * This,
    /* [in] */ single pflLeft);


void __RPC_STUB IListItem_put_Left_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IListItem_get_Selected_Proxy( 
    IListItem * This,
    /* [retval][out] */ VARIANT_BOOL *pfOn);


void __RPC_STUB IListItem_get_Selected_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE IListItem_put_Selected_Proxy( 
    IListItem * This,
    /* [in] */ VARIANT_BOOL pfOn);


void __RPC_STUB IListItem_put_Selected_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IListItem_get_SmallIcon_Proxy( 
    IListItem * This,
    /* [retval][out] */ VARIANT *pnIndex);


void __RPC_STUB IListItem_get_SmallIcon_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE IListItem_put_SmallIcon_Proxy( 
    IListItem * This,
    /* [in] */ VARIANT pnIndex);


void __RPC_STUB IListItem_put_SmallIcon_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IListItem_get_Tag_Proxy( 
    IListItem * This,
    /* [retval][out] */ VARIANT *pvTag);


void __RPC_STUB IListItem_get_Tag_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE IListItem_put_Tag_Proxy( 
    IListItem * This,
    /* [in] */ VARIANT pvTag);


void __RPC_STUB IListItem_put_Tag_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IListItem_get_Top_Proxy( 
    IListItem * This,
    /* [retval][out] */ single *pflTop);


void __RPC_STUB IListItem_get_Top_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE IListItem_put_Top_Proxy( 
    IListItem * This,
    /* [in] */ single pflTop);


void __RPC_STUB IListItem_put_Top_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IListItem_get_Width_Proxy( 
    IListItem * This,
    /* [retval][out] */ single *pflWidth);


void __RPC_STUB IListItem_get_Width_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE IListItem_put_Width_Proxy( 
    IListItem * This,
    /* [in] */ single pflWidth);


void __RPC_STUB IListItem_put_Width_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IListItem_get_SubItems_Proxy( 
    IListItem * This,
    /* [in] */ short Index,
    /* [retval][out] */ BSTR *pbstrItem);


void __RPC_STUB IListItem_get_SubItems_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE IListItem_put_SubItems_Proxy( 
    IListItem * This,
    /* [in] */ short Index,
    /* [in] */ BSTR pbstrItem);


void __RPC_STUB IListItem_put_SubItems_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][id] */ HRESULT STDMETHODCALLTYPE IListItem_CreateDragImage_Proxy( 
    IListItem * This,
    /* [retval][out] */ /* external definition not present */ IPictureDisp **ppImage);


void __RPC_STUB IListItem_CreateDragImage_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][id] */ HRESULT STDMETHODCALLTYPE IListItem_EnsureVisible_Proxy( 
    IListItem * This,
    /* [retval][out] */ VARIANT_BOOL *pfVisible);


void __RPC_STUB IListItem_EnsureVisible_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propputref][id] */ HRESULT STDMETHODCALLTYPE IListItem_putref_Tag_Proxy( 
    IListItem * This,
    /* [in] */ VARIANT pvTag);


void __RPC_STUB IListItem_putref_Tag_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IListItem_get_ListSubItems_Proxy( 
    IListItem * This,
    /* [retval][out] */ IListSubItems **ppSubItems);


void __RPC_STUB IListItem_get_ListSubItems_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE IListItem_put_ListSubItems_Proxy( 
    IListItem * This,
    /* [in] */ IListSubItems *ppSubItems);


void __RPC_STUB IListItem_put_ListSubItems_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IListItem_get_Checked_Proxy( 
    IListItem * This,
    /* [retval][out] */ VARIANT_BOOL *pfChecked);


void __RPC_STUB IListItem_get_Checked_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE IListItem_put_Checked_Proxy( 
    IListItem * This,
    /* [in] */ VARIANT_BOOL pfChecked);


void __RPC_STUB IListItem_put_Checked_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IListItem_get_ForeColor_Proxy( 
    IListItem * This,
    /* [retval][out] */ /* external definition not present */ OLE_COLOR *pcrFore);


void __RPC_STUB IListItem_get_ForeColor_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE IListItem_put_ForeColor_Proxy( 
    IListItem * This,
    /* [in] */ /* external definition not present */ OLE_COLOR pcrFore);


void __RPC_STUB IListItem_put_ForeColor_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IListItem_get_ToolTipText_Proxy( 
    IListItem * This,
    /* [retval][out] */ BSTR *pbstrToolTipText);


void __RPC_STUB IListItem_get_ToolTipText_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE IListItem_put_ToolTipText_Proxy( 
    IListItem * This,
    /* [in] */ BSTR pbstrToolTipText);


void __RPC_STUB IListItem_put_ToolTipText_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IListItem_get_Bold_Proxy( 
    IListItem * This,
    /* [retval][out] */ VARIANT_BOOL *pfBold);


void __RPC_STUB IListItem_get_Bold_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE IListItem_put_Bold_Proxy( 
    IListItem * This,
    /* [in] */ VARIANT_BOOL pfBold);


void __RPC_STUB IListItem_put_Bold_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IListItem_INTERFACE_DEFINED__ */


#ifndef __IColumnHeaders_INTERFACE_DEFINED__
#define __IColumnHeaders_INTERFACE_DEFINED__

/* interface IColumnHeaders */
/* [object][oleautomation][nonextensible][dual][hidden][helpcontext][helpstring][uuid] */ 


EXTERN_C const IID IID_IColumnHeaders;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("BDD1F050-858B-11D1-B16A-00C0F0283628")
    IColumnHeaders : public IDispatch
    {
    public:
        virtual /* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_Count( 
            /* [retval][out] */ long *plCount) = 0;
        
        virtual /* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_Count( 
            /* [in] */ long plCount) = 0;
        
        virtual /* [hidden][propget][id] */ HRESULT STDMETHODCALLTYPE get_ControlDefault( 
            /* [in] */ VARIANT *Index,
            /* [retval][out] */ IColumnHeader **ppIColumnHeader) = 0;
        
        virtual /* [helpcontext][helpstring][hidden][id] */ HRESULT STDMETHODCALLTYPE Add_PreVB98( 
            /* [optional][in] */ VARIANT *Index,
            /* [optional][in] */ VARIANT *Key,
            /* [optional][in] */ VARIANT *Text,
            /* [optional][in] */ VARIANT *Width,
            /* [optional][in] */ VARIANT *Alignment,
            /* [retval][out] */ IColumnHeader **ppIColumnHeader) = 0;
        
        virtual /* [helpcontext][helpstring][id] */ HRESULT STDMETHODCALLTYPE Clear( void) = 0;
        
        virtual /* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_Item( 
            /* [in] */ VARIANT *Index,
            /* [retval][out] */ IColumnHeader **ppIColumnHeader) = 0;
        
        virtual /* [helpcontext][helpstring][id] */ HRESULT STDMETHODCALLTYPE Remove( 
            /* [in] */ VARIANT *Index) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE _NewEnum( 
            /* [retval][out] */ IUnknown **ppUnknown) = 0;
        
        virtual /* [helpcontext][helpstring][id] */ HRESULT STDMETHODCALLTYPE Add( 
            /* [optional][in] */ VARIANT *Index,
            /* [optional][in] */ VARIANT *Key,
            /* [optional][in] */ VARIANT *Text,
            /* [optional][in] */ VARIANT *Width,
            /* [optional][in] */ VARIANT *Alignment,
            /* [optional][in] */ VARIANT *Icon,
            /* [retval][out] */ IColumnHeader **ppIColumnHeader) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IColumnHeadersVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IColumnHeaders * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IColumnHeaders * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IColumnHeaders * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IColumnHeaders * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IColumnHeaders * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IColumnHeaders * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IColumnHeaders * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_Count )( 
            IColumnHeaders * This,
            /* [retval][out] */ long *plCount);
        
        /* [helpcontext][helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_Count )( 
            IColumnHeaders * This,
            /* [in] */ long plCount);
        
        /* [hidden][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_ControlDefault )( 
            IColumnHeaders * This,
            /* [in] */ VARIANT *Index,
            /* [retval][out] */ IColumnHeader **ppIColumnHeader);
        
        /* [helpcontext][helpstring][hidden][id] */ HRESULT ( STDMETHODCALLTYPE *Add_PreVB98 )( 
            IColumnHeaders * This,
            /* [optional][in] */ VARIANT *Index,
            /* [optional][in] */ VARIANT *Key,
            /* [optional][in] */ VARIANT *Text,
            /* [optional][in] */ VARIANT *Width,
            /* [optional][in] */ VARIANT *Alignment,
            /* [retval][out] */ IColumnHeader **ppIColumnHeader);
        
        /* [helpcontext][helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Clear )( 
            IColumnHeaders * This);
        
        /* [helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_Item )( 
            IColumnHeaders * This,
            /* [in] */ VARIANT *Index,
            /* [retval][out] */ IColumnHeader **ppIColumnHeader);
        
        /* [helpcontext][helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Remove )( 
            IColumnHeaders * This,
            /* [in] */ VARIANT *Index);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE *_NewEnum )( 
            IColumnHeaders * This,
            /* [retval][out] */ IUnknown **ppUnknown);
        
        /* [helpcontext][helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Add )( 
            IColumnHeaders * This,
            /* [optional][in] */ VARIANT *Index,
            /* [optional][in] */ VARIANT *Key,
            /* [optional][in] */ VARIANT *Text,
            /* [optional][in] */ VARIANT *Width,
            /* [optional][in] */ VARIANT *Alignment,
            /* [optional][in] */ VARIANT *Icon,
            /* [retval][out] */ IColumnHeader **ppIColumnHeader);
        
        END_INTERFACE
    } IColumnHeadersVtbl;

    interface IColumnHeaders
    {
        CONST_VTBL struct IColumnHeadersVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IColumnHeaders_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IColumnHeaders_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IColumnHeaders_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IColumnHeaders_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IColumnHeaders_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IColumnHeaders_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IColumnHeaders_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IColumnHeaders_get_Count(This,plCount)	\
    (This)->lpVtbl -> get_Count(This,plCount)

#define IColumnHeaders_put_Count(This,plCount)	\
    (This)->lpVtbl -> put_Count(This,plCount)

#define IColumnHeaders_get_ControlDefault(This,Index,ppIColumnHeader)	\
    (This)->lpVtbl -> get_ControlDefault(This,Index,ppIColumnHeader)

#define IColumnHeaders_Add_PreVB98(This,Index,Key,Text,Width,Alignment,ppIColumnHeader)	\
    (This)->lpVtbl -> Add_PreVB98(This,Index,Key,Text,Width,Alignment,ppIColumnHeader)

#define IColumnHeaders_Clear(This)	\
    (This)->lpVtbl -> Clear(This)

#define IColumnHeaders_get_Item(This,Index,ppIColumnHeader)	\
    (This)->lpVtbl -> get_Item(This,Index,ppIColumnHeader)

#define IColumnHeaders_Remove(This,Index)	\
    (This)->lpVtbl -> Remove(This,Index)

#define IColumnHeaders__NewEnum(This,ppUnknown)	\
    (This)->lpVtbl -> _NewEnum(This,ppUnknown)

#define IColumnHeaders_Add(This,Index,Key,Text,Width,Alignment,Icon,ppIColumnHeader)	\
    (This)->lpVtbl -> Add(This,Index,Key,Text,Width,Alignment,Icon,ppIColumnHeader)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IColumnHeaders_get_Count_Proxy( 
    IColumnHeaders * This,
    /* [retval][out] */ long *plCount);


void __RPC_STUB IColumnHeaders_get_Count_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE IColumnHeaders_put_Count_Proxy( 
    IColumnHeaders * This,
    /* [in] */ long plCount);


void __RPC_STUB IColumnHeaders_put_Count_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [hidden][propget][id] */ HRESULT STDMETHODCALLTYPE IColumnHeaders_get_ControlDefault_Proxy( 
    IColumnHeaders * This,
    /* [in] */ VARIANT *Index,
    /* [retval][out] */ IColumnHeader **ppIColumnHeader);


void __RPC_STUB IColumnHeaders_get_ControlDefault_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][hidden][id] */ HRESULT STDMETHODCALLTYPE IColumnHeaders_Add_PreVB98_Proxy( 
    IColumnHeaders * This,
    /* [optional][in] */ VARIANT *Index,
    /* [optional][in] */ VARIANT *Key,
    /* [optional][in] */ VARIANT *Text,
    /* [optional][in] */ VARIANT *Width,
    /* [optional][in] */ VARIANT *Alignment,
    /* [retval][out] */ IColumnHeader **ppIColumnHeader);


void __RPC_STUB IColumnHeaders_Add_PreVB98_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][id] */ HRESULT STDMETHODCALLTYPE IColumnHeaders_Clear_Proxy( 
    IColumnHeaders * This);


void __RPC_STUB IColumnHeaders_Clear_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IColumnHeaders_get_Item_Proxy( 
    IColumnHeaders * This,
    /* [in] */ VARIANT *Index,
    /* [retval][out] */ IColumnHeader **ppIColumnHeader);


void __RPC_STUB IColumnHeaders_get_Item_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][id] */ HRESULT STDMETHODCALLTYPE IColumnHeaders_Remove_Proxy( 
    IColumnHeaders * This,
    /* [in] */ VARIANT *Index);


void __RPC_STUB IColumnHeaders_Remove_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE IColumnHeaders__NewEnum_Proxy( 
    IColumnHeaders * This,
    /* [retval][out] */ IUnknown **ppUnknown);


void __RPC_STUB IColumnHeaders__NewEnum_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][id] */ HRESULT STDMETHODCALLTYPE IColumnHeaders_Add_Proxy( 
    IColumnHeaders * This,
    /* [optional][in] */ VARIANT *Index,
    /* [optional][in] */ VARIANT *Key,
    /* [optional][in] */ VARIANT *Text,
    /* [optional][in] */ VARIANT *Width,
    /* [optional][in] */ VARIANT *Alignment,
    /* [optional][in] */ VARIANT *Icon,
    /* [retval][out] */ IColumnHeader **ppIColumnHeader);


void __RPC_STUB IColumnHeaders_Add_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IColumnHeaders_INTERFACE_DEFINED__ */


#ifndef __IColumnHeader_INTERFACE_DEFINED__
#define __IColumnHeader_INTERFACE_DEFINED__

/* interface IColumnHeader */
/* [object][oleautomation][nonextensible][dual][hidden][helpcontext][helpstring][uuid] */ 


EXTERN_C const IID IID_IColumnHeader;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("BDD1F051-858B-11D1-B16A-00C0F0283628")
    IColumnHeader : public IDispatch
    {
    public:
        virtual /* [hidden][propget][id] */ HRESULT STDMETHODCALLTYPE get_Default( 
            /* [retval][out] */ BSTR *pbstrText) = 0;
        
        virtual /* [hidden][propput][id] */ HRESULT STDMETHODCALLTYPE put_Default( 
            /* [in] */ BSTR pbstrText) = 0;
        
        virtual /* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_Text( 
            /* [retval][out] */ BSTR *pbstrText) = 0;
        
        virtual /* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_Text( 
            /* [in] */ BSTR pbstrText) = 0;
        
        virtual /* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_Alignment( 
            /* [retval][out] */ ListColumnAlignmentConstants *pnAlignment) = 0;
        
        virtual /* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_Alignment( 
            /* [in] */ ListColumnAlignmentConstants pnAlignment) = 0;
        
        virtual /* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_Index( 
            /* [retval][out] */ long *plIndex) = 0;
        
        virtual /* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_Index( 
            /* [in] */ long plIndex) = 0;
        
        virtual /* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_Key( 
            /* [retval][out] */ BSTR *pbstrKey) = 0;
        
        virtual /* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_Key( 
            /* [in] */ BSTR pbstrKey) = 0;
        
        virtual /* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_Left( 
            /* [retval][out] */ single *pflLeft) = 0;
        
        virtual /* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_Left( 
            /* [in] */ single pflLeft) = 0;
        
        virtual /* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_SubItemIndex( 
            /* [retval][out] */ short *psIndex) = 0;
        
        virtual /* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_SubItemIndex( 
            /* [in] */ short psIndex) = 0;
        
        virtual /* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_Tag( 
            /* [retval][out] */ VARIANT *pvTag) = 0;
        
        virtual /* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_Tag( 
            /* [in] */ VARIANT pvTag) = 0;
        
        virtual /* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_Width( 
            /* [retval][out] */ single *pflWidth) = 0;
        
        virtual /* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_Width( 
            /* [in] */ single pflWidth) = 0;
        
        virtual /* [helpcontext][helpstring][propputref][id] */ HRESULT STDMETHODCALLTYPE putref_Tag( 
            /* [in] */ VARIANT pvTag) = 0;
        
        virtual /* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_Icon( 
            /* [retval][out] */ VARIANT *pnIndex) = 0;
        
        virtual /* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_Icon( 
            /* [in] */ VARIANT pnIndex) = 0;
        
        virtual /* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_Position( 
            /* [retval][out] */ short *piPosition) = 0;
        
        virtual /* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_Position( 
            /* [in] */ short piPosition) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IColumnHeaderVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IColumnHeader * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IColumnHeader * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IColumnHeader * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IColumnHeader * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IColumnHeader * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IColumnHeader * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IColumnHeader * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [hidden][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_Default )( 
            IColumnHeader * This,
            /* [retval][out] */ BSTR *pbstrText);
        
        /* [hidden][propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_Default )( 
            IColumnHeader * This,
            /* [in] */ BSTR pbstrText);
        
        /* [helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_Text )( 
            IColumnHeader * This,
            /* [retval][out] */ BSTR *pbstrText);
        
        /* [helpcontext][helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_Text )( 
            IColumnHeader * This,
            /* [in] */ BSTR pbstrText);
        
        /* [helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_Alignment )( 
            IColumnHeader * This,
            /* [retval][out] */ ListColumnAlignmentConstants *pnAlignment);
        
        /* [helpcontext][helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_Alignment )( 
            IColumnHeader * This,
            /* [in] */ ListColumnAlignmentConstants pnAlignment);
        
        /* [helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_Index )( 
            IColumnHeader * This,
            /* [retval][out] */ long *plIndex);
        
        /* [helpcontext][helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_Index )( 
            IColumnHeader * This,
            /* [in] */ long plIndex);
        
        /* [helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_Key )( 
            IColumnHeader * This,
            /* [retval][out] */ BSTR *pbstrKey);
        
        /* [helpcontext][helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_Key )( 
            IColumnHeader * This,
            /* [in] */ BSTR pbstrKey);
        
        /* [helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_Left )( 
            IColumnHeader * This,
            /* [retval][out] */ single *pflLeft);
        
        /* [helpcontext][helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_Left )( 
            IColumnHeader * This,
            /* [in] */ single pflLeft);
        
        /* [helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_SubItemIndex )( 
            IColumnHeader * This,
            /* [retval][out] */ short *psIndex);
        
        /* [helpcontext][helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_SubItemIndex )( 
            IColumnHeader * This,
            /* [in] */ short psIndex);
        
        /* [helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_Tag )( 
            IColumnHeader * This,
            /* [retval][out] */ VARIANT *pvTag);
        
        /* [helpcontext][helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_Tag )( 
            IColumnHeader * This,
            /* [in] */ VARIANT pvTag);
        
        /* [helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_Width )( 
            IColumnHeader * This,
            /* [retval][out] */ single *pflWidth);
        
        /* [helpcontext][helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_Width )( 
            IColumnHeader * This,
            /* [in] */ single pflWidth);
        
        /* [helpcontext][helpstring][propputref][id] */ HRESULT ( STDMETHODCALLTYPE *putref_Tag )( 
            IColumnHeader * This,
            /* [in] */ VARIANT pvTag);
        
        /* [helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_Icon )( 
            IColumnHeader * This,
            /* [retval][out] */ VARIANT *pnIndex);
        
        /* [helpcontext][helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_Icon )( 
            IColumnHeader * This,
            /* [in] */ VARIANT pnIndex);
        
        /* [helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_Position )( 
            IColumnHeader * This,
            /* [retval][out] */ short *piPosition);
        
        /* [helpcontext][helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_Position )( 
            IColumnHeader * This,
            /* [in] */ short piPosition);
        
        END_INTERFACE
    } IColumnHeaderVtbl;

    interface IColumnHeader
    {
        CONST_VTBL struct IColumnHeaderVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IColumnHeader_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IColumnHeader_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IColumnHeader_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IColumnHeader_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IColumnHeader_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IColumnHeader_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IColumnHeader_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IColumnHeader_get_Default(This,pbstrText)	\
    (This)->lpVtbl -> get_Default(This,pbstrText)

#define IColumnHeader_put_Default(This,pbstrText)	\
    (This)->lpVtbl -> put_Default(This,pbstrText)

#define IColumnHeader_get_Text(This,pbstrText)	\
    (This)->lpVtbl -> get_Text(This,pbstrText)

#define IColumnHeader_put_Text(This,pbstrText)	\
    (This)->lpVtbl -> put_Text(This,pbstrText)

#define IColumnHeader_get_Alignment(This,pnAlignment)	\
    (This)->lpVtbl -> get_Alignment(This,pnAlignment)

#define IColumnHeader_put_Alignment(This,pnAlignment)	\
    (This)->lpVtbl -> put_Alignment(This,pnAlignment)

#define IColumnHeader_get_Index(This,plIndex)	\
    (This)->lpVtbl -> get_Index(This,plIndex)

#define IColumnHeader_put_Index(This,plIndex)	\
    (This)->lpVtbl -> put_Index(This,plIndex)

#define IColumnHeader_get_Key(This,pbstrKey)	\
    (This)->lpVtbl -> get_Key(This,pbstrKey)

#define IColumnHeader_put_Key(This,pbstrKey)	\
    (This)->lpVtbl -> put_Key(This,pbstrKey)

#define IColumnHeader_get_Left(This,pflLeft)	\
    (This)->lpVtbl -> get_Left(This,pflLeft)

#define IColumnHeader_put_Left(This,pflLeft)	\
    (This)->lpVtbl -> put_Left(This,pflLeft)

#define IColumnHeader_get_SubItemIndex(This,psIndex)	\
    (This)->lpVtbl -> get_SubItemIndex(This,psIndex)

#define IColumnHeader_put_SubItemIndex(This,psIndex)	\
    (This)->lpVtbl -> put_SubItemIndex(This,psIndex)

#define IColumnHeader_get_Tag(This,pvTag)	\
    (This)->lpVtbl -> get_Tag(This,pvTag)

#define IColumnHeader_put_Tag(This,pvTag)	\
    (This)->lpVtbl -> put_Tag(This,pvTag)

#define IColumnHeader_get_Width(This,pflWidth)	\
    (This)->lpVtbl -> get_Width(This,pflWidth)

#define IColumnHeader_put_Width(This,pflWidth)	\
    (This)->lpVtbl -> put_Width(This,pflWidth)

#define IColumnHeader_putref_Tag(This,pvTag)	\
    (This)->lpVtbl -> putref_Tag(This,pvTag)

#define IColumnHeader_get_Icon(This,pnIndex)	\
    (This)->lpVtbl -> get_Icon(This,pnIndex)

#define IColumnHeader_put_Icon(This,pnIndex)	\
    (This)->lpVtbl -> put_Icon(This,pnIndex)

#define IColumnHeader_get_Position(This,piPosition)	\
    (This)->lpVtbl -> get_Position(This,piPosition)

#define IColumnHeader_put_Position(This,piPosition)	\
    (This)->lpVtbl -> put_Position(This,piPosition)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [hidden][propget][id] */ HRESULT STDMETHODCALLTYPE IColumnHeader_get_Default_Proxy( 
    IColumnHeader * This,
    /* [retval][out] */ BSTR *pbstrText);


void __RPC_STUB IColumnHeader_get_Default_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [hidden][propput][id] */ HRESULT STDMETHODCALLTYPE IColumnHeader_put_Default_Proxy( 
    IColumnHeader * This,
    /* [in] */ BSTR pbstrText);


void __RPC_STUB IColumnHeader_put_Default_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IColumnHeader_get_Text_Proxy( 
    IColumnHeader * This,
    /* [retval][out] */ BSTR *pbstrText);


void __RPC_STUB IColumnHeader_get_Text_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE IColumnHeader_put_Text_Proxy( 
    IColumnHeader * This,
    /* [in] */ BSTR pbstrText);


void __RPC_STUB IColumnHeader_put_Text_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IColumnHeader_get_Alignment_Proxy( 
    IColumnHeader * This,
    /* [retval][out] */ ListColumnAlignmentConstants *pnAlignment);


void __RPC_STUB IColumnHeader_get_Alignment_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE IColumnHeader_put_Alignment_Proxy( 
    IColumnHeader * This,
    /* [in] */ ListColumnAlignmentConstants pnAlignment);


void __RPC_STUB IColumnHeader_put_Alignment_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IColumnHeader_get_Index_Proxy( 
    IColumnHeader * This,
    /* [retval][out] */ long *plIndex);


void __RPC_STUB IColumnHeader_get_Index_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE IColumnHeader_put_Index_Proxy( 
    IColumnHeader * This,
    /* [in] */ long plIndex);


void __RPC_STUB IColumnHeader_put_Index_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IColumnHeader_get_Key_Proxy( 
    IColumnHeader * This,
    /* [retval][out] */ BSTR *pbstrKey);


void __RPC_STUB IColumnHeader_get_Key_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE IColumnHeader_put_Key_Proxy( 
    IColumnHeader * This,
    /* [in] */ BSTR pbstrKey);


void __RPC_STUB IColumnHeader_put_Key_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IColumnHeader_get_Left_Proxy( 
    IColumnHeader * This,
    /* [retval][out] */ single *pflLeft);


void __RPC_STUB IColumnHeader_get_Left_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE IColumnHeader_put_Left_Proxy( 
    IColumnHeader * This,
    /* [in] */ single pflLeft);


void __RPC_STUB IColumnHeader_put_Left_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IColumnHeader_get_SubItemIndex_Proxy( 
    IColumnHeader * This,
    /* [retval][out] */ short *psIndex);


void __RPC_STUB IColumnHeader_get_SubItemIndex_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE IColumnHeader_put_SubItemIndex_Proxy( 
    IColumnHeader * This,
    /* [in] */ short psIndex);


void __RPC_STUB IColumnHeader_put_SubItemIndex_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IColumnHeader_get_Tag_Proxy( 
    IColumnHeader * This,
    /* [retval][out] */ VARIANT *pvTag);


void __RPC_STUB IColumnHeader_get_Tag_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE IColumnHeader_put_Tag_Proxy( 
    IColumnHeader * This,
    /* [in] */ VARIANT pvTag);


void __RPC_STUB IColumnHeader_put_Tag_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IColumnHeader_get_Width_Proxy( 
    IColumnHeader * This,
    /* [retval][out] */ single *pflWidth);


void __RPC_STUB IColumnHeader_get_Width_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE IColumnHeader_put_Width_Proxy( 
    IColumnHeader * This,
    /* [in] */ single pflWidth);


void __RPC_STUB IColumnHeader_put_Width_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propputref][id] */ HRESULT STDMETHODCALLTYPE IColumnHeader_putref_Tag_Proxy( 
    IColumnHeader * This,
    /* [in] */ VARIANT pvTag);


void __RPC_STUB IColumnHeader_putref_Tag_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IColumnHeader_get_Icon_Proxy( 
    IColumnHeader * This,
    /* [retval][out] */ VARIANT *pnIndex);


void __RPC_STUB IColumnHeader_get_Icon_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE IColumnHeader_put_Icon_Proxy( 
    IColumnHeader * This,
    /* [in] */ VARIANT pnIndex);


void __RPC_STUB IColumnHeader_put_Icon_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IColumnHeader_get_Position_Proxy( 
    IColumnHeader * This,
    /* [retval][out] */ short *piPosition);


void __RPC_STUB IColumnHeader_get_Position_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE IColumnHeader_put_Position_Proxy( 
    IColumnHeader * This,
    /* [in] */ short piPosition);


void __RPC_STUB IColumnHeader_put_Position_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IColumnHeader_INTERFACE_DEFINED__ */


#ifndef __IListSubItems_INTERFACE_DEFINED__
#define __IListSubItems_INTERFACE_DEFINED__

/* interface IListSubItems */
/* [object][oleautomation][nonextensible][dual][helpcontext][helpstring][uuid] */ 


EXTERN_C const IID IID_IListSubItems;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("BDD1F053-858B-11D1-B16A-00C0F0283628")
    IListSubItems : public IDispatch
    {
    public:
        virtual /* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_Count( 
            /* [retval][out] */ long *plCount) = 0;
        
        virtual /* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_Count( 
            /* [in] */ long plCount) = 0;
        
        virtual /* [hidden][propget][id] */ HRESULT STDMETHODCALLTYPE get_ControlDefault( 
            /* [in] */ VARIANT *Index,
            /* [retval][out] */ IListSubItem **ppIListSubItem) = 0;
        
        virtual /* [helpcontext][helpstring][id] */ HRESULT STDMETHODCALLTYPE Add( 
            /* [optional][in] */ VARIANT *Index,
            /* [optional][in] */ VARIANT *Key,
            /* [optional][in] */ VARIANT *Text,
            /* [optional][in] */ VARIANT *ReportIcon,
            /* [optional][in] */ VARIANT *ToolTipText,
            /* [retval][out] */ IListSubItem **ppIListSubItem) = 0;
        
        virtual /* [helpcontext][helpstring][id] */ HRESULT STDMETHODCALLTYPE Clear( void) = 0;
        
        virtual /* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_Item( 
            /* [in] */ VARIANT *Index,
            /* [retval][out] */ IListSubItem **ppIListSubItem) = 0;
        
        virtual /* [helpcontext][helpstring][id] */ HRESULT STDMETHODCALLTYPE Remove( 
            /* [in] */ VARIANT *Index) = 0;
        
        virtual /* [hidden][id] */ HRESULT STDMETHODCALLTYPE _NewEnum( 
            /* [retval][out] */ IUnknown **ppNewEnum) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IListSubItemsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IListSubItems * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IListSubItems * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IListSubItems * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IListSubItems * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IListSubItems * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IListSubItems * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IListSubItems * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_Count )( 
            IListSubItems * This,
            /* [retval][out] */ long *plCount);
        
        /* [helpcontext][helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_Count )( 
            IListSubItems * This,
            /* [in] */ long plCount);
        
        /* [hidden][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_ControlDefault )( 
            IListSubItems * This,
            /* [in] */ VARIANT *Index,
            /* [retval][out] */ IListSubItem **ppIListSubItem);
        
        /* [helpcontext][helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Add )( 
            IListSubItems * This,
            /* [optional][in] */ VARIANT *Index,
            /* [optional][in] */ VARIANT *Key,
            /* [optional][in] */ VARIANT *Text,
            /* [optional][in] */ VARIANT *ReportIcon,
            /* [optional][in] */ VARIANT *ToolTipText,
            /* [retval][out] */ IListSubItem **ppIListSubItem);
        
        /* [helpcontext][helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Clear )( 
            IListSubItems * This);
        
        /* [helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_Item )( 
            IListSubItems * This,
            /* [in] */ VARIANT *Index,
            /* [retval][out] */ IListSubItem **ppIListSubItem);
        
        /* [helpcontext][helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Remove )( 
            IListSubItems * This,
            /* [in] */ VARIANT *Index);
        
        /* [hidden][id] */ HRESULT ( STDMETHODCALLTYPE *_NewEnum )( 
            IListSubItems * This,
            /* [retval][out] */ IUnknown **ppNewEnum);
        
        END_INTERFACE
    } IListSubItemsVtbl;

    interface IListSubItems
    {
        CONST_VTBL struct IListSubItemsVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IListSubItems_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IListSubItems_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IListSubItems_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IListSubItems_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IListSubItems_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IListSubItems_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IListSubItems_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IListSubItems_get_Count(This,plCount)	\
    (This)->lpVtbl -> get_Count(This,plCount)

#define IListSubItems_put_Count(This,plCount)	\
    (This)->lpVtbl -> put_Count(This,plCount)

#define IListSubItems_get_ControlDefault(This,Index,ppIListSubItem)	\
    (This)->lpVtbl -> get_ControlDefault(This,Index,ppIListSubItem)

#define IListSubItems_Add(This,Index,Key,Text,ReportIcon,ToolTipText,ppIListSubItem)	\
    (This)->lpVtbl -> Add(This,Index,Key,Text,ReportIcon,ToolTipText,ppIListSubItem)

#define IListSubItems_Clear(This)	\
    (This)->lpVtbl -> Clear(This)

#define IListSubItems_get_Item(This,Index,ppIListSubItem)	\
    (This)->lpVtbl -> get_Item(This,Index,ppIListSubItem)

#define IListSubItems_Remove(This,Index)	\
    (This)->lpVtbl -> Remove(This,Index)

#define IListSubItems__NewEnum(This,ppNewEnum)	\
    (This)->lpVtbl -> _NewEnum(This,ppNewEnum)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IListSubItems_get_Count_Proxy( 
    IListSubItems * This,
    /* [retval][out] */ long *plCount);


void __RPC_STUB IListSubItems_get_Count_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE IListSubItems_put_Count_Proxy( 
    IListSubItems * This,
    /* [in] */ long plCount);


void __RPC_STUB IListSubItems_put_Count_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [hidden][propget][id] */ HRESULT STDMETHODCALLTYPE IListSubItems_get_ControlDefault_Proxy( 
    IListSubItems * This,
    /* [in] */ VARIANT *Index,
    /* [retval][out] */ IListSubItem **ppIListSubItem);


void __RPC_STUB IListSubItems_get_ControlDefault_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][id] */ HRESULT STDMETHODCALLTYPE IListSubItems_Add_Proxy( 
    IListSubItems * This,
    /* [optional][in] */ VARIANT *Index,
    /* [optional][in] */ VARIANT *Key,
    /* [optional][in] */ VARIANT *Text,
    /* [optional][in] */ VARIANT *ReportIcon,
    /* [optional][in] */ VARIANT *ToolTipText,
    /* [retval][out] */ IListSubItem **ppIListSubItem);


void __RPC_STUB IListSubItems_Add_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][id] */ HRESULT STDMETHODCALLTYPE IListSubItems_Clear_Proxy( 
    IListSubItems * This);


void __RPC_STUB IListSubItems_Clear_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IListSubItems_get_Item_Proxy( 
    IListSubItems * This,
    /* [in] */ VARIANT *Index,
    /* [retval][out] */ IListSubItem **ppIListSubItem);


void __RPC_STUB IListSubItems_get_Item_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][id] */ HRESULT STDMETHODCALLTYPE IListSubItems_Remove_Proxy( 
    IListSubItems * This,
    /* [in] */ VARIANT *Index);


void __RPC_STUB IListSubItems_Remove_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [hidden][id] */ HRESULT STDMETHODCALLTYPE IListSubItems__NewEnum_Proxy( 
    IListSubItems * This,
    /* [retval][out] */ IUnknown **ppNewEnum);


void __RPC_STUB IListSubItems__NewEnum_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IListSubItems_INTERFACE_DEFINED__ */


#ifndef __IListSubItem_INTERFACE_DEFINED__
#define __IListSubItem_INTERFACE_DEFINED__

/* interface IListSubItem */
/* [object][oleautomation][nonextensible][dual][helpcontext][helpstring][uuid] */ 


EXTERN_C const IID IID_IListSubItem;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("BDD1F055-858B-11D1-B16A-00C0F0283628")
    IListSubItem : public IDispatch
    {
    public:
        virtual /* [hidden][propget][id] */ HRESULT STDMETHODCALLTYPE get_Default( 
            /* [retval][out] */ BSTR *pbstrText) = 0;
        
        virtual /* [hidden][propput][id] */ HRESULT STDMETHODCALLTYPE put_Default( 
            /* [in] */ BSTR pbstrText) = 0;
        
        virtual /* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_Text( 
            /* [retval][out] */ BSTR *pbstrText) = 0;
        
        virtual /* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_Text( 
            /* [in] */ BSTR pbstrText) = 0;
        
        virtual /* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_ForeColor( 
            /* [retval][out] */ /* external definition not present */ OLE_COLOR *pcrFore) = 0;
        
        virtual /* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_ForeColor( 
            /* [in] */ /* external definition not present */ OLE_COLOR pcrFore) = 0;
        
        virtual /* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_Bold( 
            /* [retval][out] */ VARIANT_BOOL *pfBold) = 0;
        
        virtual /* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_Bold( 
            /* [in] */ VARIANT_BOOL pfBold) = 0;
        
        virtual /* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_ReportIcon( 
            /* [retval][out] */ VARIANT *pnIndex) = 0;
        
        virtual /* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_ReportIcon( 
            /* [in] */ VARIANT pnIndex) = 0;
        
        virtual /* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_ToolTipText( 
            /* [retval][out] */ BSTR *pbstrToolTipText) = 0;
        
        virtual /* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_ToolTipText( 
            /* [in] */ BSTR pbstrToolTipText) = 0;
        
        virtual /* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_Index( 
            /* [retval][out] */ long *plIndex) = 0;
        
        virtual /* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_Index( 
            /* [in] */ long plIndex) = 0;
        
        virtual /* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_Key( 
            /* [retval][out] */ BSTR *pbstrKey) = 0;
        
        virtual /* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_Key( 
            /* [in] */ BSTR pbstrKey) = 0;
        
        virtual /* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_Tag( 
            /* [retval][out] */ VARIANT *pvTag) = 0;
        
        virtual /* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_Tag( 
            /* [in] */ VARIANT pvTag) = 0;
        
        virtual /* [helpcontext][helpstring][propputref][id] */ HRESULT STDMETHODCALLTYPE putref_Tag( 
            /* [in] */ VARIANT pvTag) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IListSubItemVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IListSubItem * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IListSubItem * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IListSubItem * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IListSubItem * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IListSubItem * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IListSubItem * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IListSubItem * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [hidden][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_Default )( 
            IListSubItem * This,
            /* [retval][out] */ BSTR *pbstrText);
        
        /* [hidden][propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_Default )( 
            IListSubItem * This,
            /* [in] */ BSTR pbstrText);
        
        /* [helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_Text )( 
            IListSubItem * This,
            /* [retval][out] */ BSTR *pbstrText);
        
        /* [helpcontext][helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_Text )( 
            IListSubItem * This,
            /* [in] */ BSTR pbstrText);
        
        /* [helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_ForeColor )( 
            IListSubItem * This,
            /* [retval][out] */ /* external definition not present */ OLE_COLOR *pcrFore);
        
        /* [helpcontext][helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_ForeColor )( 
            IListSubItem * This,
            /* [in] */ /* external definition not present */ OLE_COLOR pcrFore);
        
        /* [helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_Bold )( 
            IListSubItem * This,
            /* [retval][out] */ VARIANT_BOOL *pfBold);
        
        /* [helpcontext][helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_Bold )( 
            IListSubItem * This,
            /* [in] */ VARIANT_BOOL pfBold);
        
        /* [helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_ReportIcon )( 
            IListSubItem * This,
            /* [retval][out] */ VARIANT *pnIndex);
        
        /* [helpcontext][helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_ReportIcon )( 
            IListSubItem * This,
            /* [in] */ VARIANT pnIndex);
        
        /* [helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_ToolTipText )( 
            IListSubItem * This,
            /* [retval][out] */ BSTR *pbstrToolTipText);
        
        /* [helpcontext][helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_ToolTipText )( 
            IListSubItem * This,
            /* [in] */ BSTR pbstrToolTipText);
        
        /* [helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_Index )( 
            IListSubItem * This,
            /* [retval][out] */ long *plIndex);
        
        /* [helpcontext][helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_Index )( 
            IListSubItem * This,
            /* [in] */ long plIndex);
        
        /* [helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_Key )( 
            IListSubItem * This,
            /* [retval][out] */ BSTR *pbstrKey);
        
        /* [helpcontext][helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_Key )( 
            IListSubItem * This,
            /* [in] */ BSTR pbstrKey);
        
        /* [helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_Tag )( 
            IListSubItem * This,
            /* [retval][out] */ VARIANT *pvTag);
        
        /* [helpcontext][helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_Tag )( 
            IListSubItem * This,
            /* [in] */ VARIANT pvTag);
        
        /* [helpcontext][helpstring][propputref][id] */ HRESULT ( STDMETHODCALLTYPE *putref_Tag )( 
            IListSubItem * This,
            /* [in] */ VARIANT pvTag);
        
        END_INTERFACE
    } IListSubItemVtbl;

    interface IListSubItem
    {
        CONST_VTBL struct IListSubItemVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IListSubItem_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IListSubItem_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IListSubItem_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IListSubItem_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IListSubItem_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IListSubItem_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IListSubItem_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IListSubItem_get_Default(This,pbstrText)	\
    (This)->lpVtbl -> get_Default(This,pbstrText)

#define IListSubItem_put_Default(This,pbstrText)	\
    (This)->lpVtbl -> put_Default(This,pbstrText)

#define IListSubItem_get_Text(This,pbstrText)	\
    (This)->lpVtbl -> get_Text(This,pbstrText)

#define IListSubItem_put_Text(This,pbstrText)	\
    (This)->lpVtbl -> put_Text(This,pbstrText)

#define IListSubItem_get_ForeColor(This,pcrFore)	\
    (This)->lpVtbl -> get_ForeColor(This,pcrFore)

#define IListSubItem_put_ForeColor(This,pcrFore)	\
    (This)->lpVtbl -> put_ForeColor(This,pcrFore)

#define IListSubItem_get_Bold(This,pfBold)	\
    (This)->lpVtbl -> get_Bold(This,pfBold)

#define IListSubItem_put_Bold(This,pfBold)	\
    (This)->lpVtbl -> put_Bold(This,pfBold)

#define IListSubItem_get_ReportIcon(This,pnIndex)	\
    (This)->lpVtbl -> get_ReportIcon(This,pnIndex)

#define IListSubItem_put_ReportIcon(This,pnIndex)	\
    (This)->lpVtbl -> put_ReportIcon(This,pnIndex)

#define IListSubItem_get_ToolTipText(This,pbstrToolTipText)	\
    (This)->lpVtbl -> get_ToolTipText(This,pbstrToolTipText)

#define IListSubItem_put_ToolTipText(This,pbstrToolTipText)	\
    (This)->lpVtbl -> put_ToolTipText(This,pbstrToolTipText)

#define IListSubItem_get_Index(This,plIndex)	\
    (This)->lpVtbl -> get_Index(This,plIndex)

#define IListSubItem_put_Index(This,plIndex)	\
    (This)->lpVtbl -> put_Index(This,plIndex)

#define IListSubItem_get_Key(This,pbstrKey)	\
    (This)->lpVtbl -> get_Key(This,pbstrKey)

#define IListSubItem_put_Key(This,pbstrKey)	\
    (This)->lpVtbl -> put_Key(This,pbstrKey)

#define IListSubItem_get_Tag(This,pvTag)	\
    (This)->lpVtbl -> get_Tag(This,pvTag)

#define IListSubItem_put_Tag(This,pvTag)	\
    (This)->lpVtbl -> put_Tag(This,pvTag)

#define IListSubItem_putref_Tag(This,pvTag)	\
    (This)->lpVtbl -> putref_Tag(This,pvTag)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [hidden][propget][id] */ HRESULT STDMETHODCALLTYPE IListSubItem_get_Default_Proxy( 
    IListSubItem * This,
    /* [retval][out] */ BSTR *pbstrText);


void __RPC_STUB IListSubItem_get_Default_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [hidden][propput][id] */ HRESULT STDMETHODCALLTYPE IListSubItem_put_Default_Proxy( 
    IListSubItem * This,
    /* [in] */ BSTR pbstrText);


void __RPC_STUB IListSubItem_put_Default_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IListSubItem_get_Text_Proxy( 
    IListSubItem * This,
    /* [retval][out] */ BSTR *pbstrText);


void __RPC_STUB IListSubItem_get_Text_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE IListSubItem_put_Text_Proxy( 
    IListSubItem * This,
    /* [in] */ BSTR pbstrText);


void __RPC_STUB IListSubItem_put_Text_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IListSubItem_get_ForeColor_Proxy( 
    IListSubItem * This,
    /* [retval][out] */ /* external definition not present */ OLE_COLOR *pcrFore);


void __RPC_STUB IListSubItem_get_ForeColor_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE IListSubItem_put_ForeColor_Proxy( 
    IListSubItem * This,
    /* [in] */ /* external definition not present */ OLE_COLOR pcrFore);


void __RPC_STUB IListSubItem_put_ForeColor_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IListSubItem_get_Bold_Proxy( 
    IListSubItem * This,
    /* [retval][out] */ VARIANT_BOOL *pfBold);


void __RPC_STUB IListSubItem_get_Bold_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE IListSubItem_put_Bold_Proxy( 
    IListSubItem * This,
    /* [in] */ VARIANT_BOOL pfBold);


void __RPC_STUB IListSubItem_put_Bold_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IListSubItem_get_ReportIcon_Proxy( 
    IListSubItem * This,
    /* [retval][out] */ VARIANT *pnIndex);


void __RPC_STUB IListSubItem_get_ReportIcon_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE IListSubItem_put_ReportIcon_Proxy( 
    IListSubItem * This,
    /* [in] */ VARIANT pnIndex);


void __RPC_STUB IListSubItem_put_ReportIcon_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IListSubItem_get_ToolTipText_Proxy( 
    IListSubItem * This,
    /* [retval][out] */ BSTR *pbstrToolTipText);


void __RPC_STUB IListSubItem_get_ToolTipText_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE IListSubItem_put_ToolTipText_Proxy( 
    IListSubItem * This,
    /* [in] */ BSTR pbstrToolTipText);


void __RPC_STUB IListSubItem_put_ToolTipText_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IListSubItem_get_Index_Proxy( 
    IListSubItem * This,
    /* [retval][out] */ long *plIndex);


void __RPC_STUB IListSubItem_get_Index_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE IListSubItem_put_Index_Proxy( 
    IListSubItem * This,
    /* [in] */ long plIndex);


void __RPC_STUB IListSubItem_put_Index_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IListSubItem_get_Key_Proxy( 
    IListSubItem * This,
    /* [retval][out] */ BSTR *pbstrKey);


void __RPC_STUB IListSubItem_get_Key_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE IListSubItem_put_Key_Proxy( 
    IListSubItem * This,
    /* [in] */ BSTR pbstrKey);


void __RPC_STUB IListSubItem_put_Key_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IListSubItem_get_Tag_Proxy( 
    IListSubItem * This,
    /* [retval][out] */ VARIANT *pvTag);


void __RPC_STUB IListSubItem_get_Tag_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE IListSubItem_put_Tag_Proxy( 
    IListSubItem * This,
    /* [in] */ VARIANT pvTag);


void __RPC_STUB IListSubItem_put_Tag_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propputref][id] */ HRESULT STDMETHODCALLTYPE IListSubItem_putref_Tag_Proxy( 
    IListSubItem * This,
    /* [in] */ VARIANT pvTag);


void __RPC_STUB IListSubItem_putref_Tag_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IListSubItem_INTERFACE_DEFINED__ */


#ifndef __IImageList_INTERFACE_DEFINED__
#define __IImageList_INTERFACE_DEFINED__

/* interface IImageList */
/* [object][oleautomation][nonextensible][dual][hidden][helpcontext][helpstring][uuid] */ 


EXTERN_C const IID IID_IImageList;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("2C247F21-8591-11D1-B16A-00C0F0283628")
    IImageList : public IDispatch
    {
    public:
        virtual /* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_ImageHeight( 
            /* [retval][out] */ short *psImageHeight) = 0;
        
        virtual /* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_ImageHeight( 
            /* [in] */ short psImageHeight) = 0;
        
        virtual /* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_ImageWidth( 
            /* [retval][out] */ short *psImageWidth) = 0;
        
        virtual /* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_ImageWidth( 
            /* [in] */ short psImageWidth) = 0;
        
        virtual /* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_MaskColor( 
            /* [retval][out] */ /* external definition not present */ OLE_COLOR *pclrMaskColor) = 0;
        
        virtual /* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_MaskColor( 
            /* [in] */ /* external definition not present */ OLE_COLOR pclrMaskColor) = 0;
        
        virtual /* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_UseMaskColor( 
            /* [retval][out] */ VARIANT_BOOL *pbState) = 0;
        
        virtual /* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_UseMaskColor( 
            /* [in] */ VARIANT_BOOL pbState) = 0;
        
        virtual /* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_ListImages( 
            /* [retval][out] */ IImages **ppListImages) = 0;
        
        virtual /* [helpcontext][helpstring][propputref][id] */ HRESULT STDMETHODCALLTYPE putref_ListImages( 
            /* [in] */ IImages *ppListImages) = 0;
        
        virtual /* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_hImageList( 
            /* [retval][out] */ /* external definition not present */ OLE_HANDLE *phImageList) = 0;
        
        virtual /* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_hImageList( 
            /* [in] */ /* external definition not present */ OLE_HANDLE phImageList) = 0;
        
        virtual /* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_BackColor( 
            /* [retval][out] */ /* external definition not present */ OLE_COLOR *pclrBackColor) = 0;
        
        virtual /* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_BackColor( 
            /* [in] */ /* external definition not present */ OLE_COLOR pclrBackColor) = 0;
        
        virtual /* [helpcontext][helpstring][id] */ HRESULT STDMETHODCALLTYPE Overlay( 
            /* [in] */ VARIANT *Key1,
            /* [in] */ VARIANT *Key2,
            /* [retval][out] */ /* external definition not present */ IPictureDisp **ppPictureDisp) = 0;
        
        virtual /* [hidden][id] */ HRESULT STDMETHODCALLTYPE AboutBox( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IImageListVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IImageList * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IImageList * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IImageList * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IImageList * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IImageList * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IImageList * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IImageList * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_ImageHeight )( 
            IImageList * This,
            /* [retval][out] */ short *psImageHeight);
        
        /* [helpcontext][helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_ImageHeight )( 
            IImageList * This,
            /* [in] */ short psImageHeight);
        
        /* [helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_ImageWidth )( 
            IImageList * This,
            /* [retval][out] */ short *psImageWidth);
        
        /* [helpcontext][helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_ImageWidth )( 
            IImageList * This,
            /* [in] */ short psImageWidth);
        
        /* [helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_MaskColor )( 
            IImageList * This,
            /* [retval][out] */ /* external definition not present */ OLE_COLOR *pclrMaskColor);
        
        /* [helpcontext][helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_MaskColor )( 
            IImageList * This,
            /* [in] */ /* external definition not present */ OLE_COLOR pclrMaskColor);
        
        /* [helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_UseMaskColor )( 
            IImageList * This,
            /* [retval][out] */ VARIANT_BOOL *pbState);
        
        /* [helpcontext][helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_UseMaskColor )( 
            IImageList * This,
            /* [in] */ VARIANT_BOOL pbState);
        
        /* [helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_ListImages )( 
            IImageList * This,
            /* [retval][out] */ IImages **ppListImages);
        
        /* [helpcontext][helpstring][propputref][id] */ HRESULT ( STDMETHODCALLTYPE *putref_ListImages )( 
            IImageList * This,
            /* [in] */ IImages *ppListImages);
        
        /* [helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_hImageList )( 
            IImageList * This,
            /* [retval][out] */ /* external definition not present */ OLE_HANDLE *phImageList);
        
        /* [helpcontext][helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_hImageList )( 
            IImageList * This,
            /* [in] */ /* external definition not present */ OLE_HANDLE phImageList);
        
        /* [helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_BackColor )( 
            IImageList * This,
            /* [retval][out] */ /* external definition not present */ OLE_COLOR *pclrBackColor);
        
        /* [helpcontext][helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_BackColor )( 
            IImageList * This,
            /* [in] */ /* external definition not present */ OLE_COLOR pclrBackColor);
        
        /* [helpcontext][helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Overlay )( 
            IImageList * This,
            /* [in] */ VARIANT *Key1,
            /* [in] */ VARIANT *Key2,
            /* [retval][out] */ /* external definition not present */ IPictureDisp **ppPictureDisp);
        
        /* [hidden][id] */ HRESULT ( STDMETHODCALLTYPE *AboutBox )( 
            IImageList * This);
        
        END_INTERFACE
    } IImageListVtbl;

    interface IImageList
    {
        CONST_VTBL struct IImageListVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IImageList_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IImageList_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IImageList_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IImageList_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IImageList_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IImageList_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IImageList_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IImageList_get_ImageHeight(This,psImageHeight)	\
    (This)->lpVtbl -> get_ImageHeight(This,psImageHeight)

#define IImageList_put_ImageHeight(This,psImageHeight)	\
    (This)->lpVtbl -> put_ImageHeight(This,psImageHeight)

#define IImageList_get_ImageWidth(This,psImageWidth)	\
    (This)->lpVtbl -> get_ImageWidth(This,psImageWidth)

#define IImageList_put_ImageWidth(This,psImageWidth)	\
    (This)->lpVtbl -> put_ImageWidth(This,psImageWidth)

#define IImageList_get_MaskColor(This,pclrMaskColor)	\
    (This)->lpVtbl -> get_MaskColor(This,pclrMaskColor)

#define IImageList_put_MaskColor(This,pclrMaskColor)	\
    (This)->lpVtbl -> put_MaskColor(This,pclrMaskColor)

#define IImageList_get_UseMaskColor(This,pbState)	\
    (This)->lpVtbl -> get_UseMaskColor(This,pbState)

#define IImageList_put_UseMaskColor(This,pbState)	\
    (This)->lpVtbl -> put_UseMaskColor(This,pbState)

#define IImageList_get_ListImages(This,ppListImages)	\
    (This)->lpVtbl -> get_ListImages(This,ppListImages)

#define IImageList_putref_ListImages(This,ppListImages)	\
    (This)->lpVtbl -> putref_ListImages(This,ppListImages)

#define IImageList_get_hImageList(This,phImageList)	\
    (This)->lpVtbl -> get_hImageList(This,phImageList)

#define IImageList_put_hImageList(This,phImageList)	\
    (This)->lpVtbl -> put_hImageList(This,phImageList)

#define IImageList_get_BackColor(This,pclrBackColor)	\
    (This)->lpVtbl -> get_BackColor(This,pclrBackColor)

#define IImageList_put_BackColor(This,pclrBackColor)	\
    (This)->lpVtbl -> put_BackColor(This,pclrBackColor)

#define IImageList_Overlay(This,Key1,Key2,ppPictureDisp)	\
    (This)->lpVtbl -> Overlay(This,Key1,Key2,ppPictureDisp)

#define IImageList_AboutBox(This)	\
    (This)->lpVtbl -> AboutBox(This)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IImageList_get_ImageHeight_Proxy( 
    IImageList * This,
    /* [retval][out] */ short *psImageHeight);


void __RPC_STUB IImageList_get_ImageHeight_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE IImageList_put_ImageHeight_Proxy( 
    IImageList * This,
    /* [in] */ short psImageHeight);


void __RPC_STUB IImageList_put_ImageHeight_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IImageList_get_ImageWidth_Proxy( 
    IImageList * This,
    /* [retval][out] */ short *psImageWidth);


void __RPC_STUB IImageList_get_ImageWidth_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE IImageList_put_ImageWidth_Proxy( 
    IImageList * This,
    /* [in] */ short psImageWidth);


void __RPC_STUB IImageList_put_ImageWidth_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IImageList_get_MaskColor_Proxy( 
    IImageList * This,
    /* [retval][out] */ /* external definition not present */ OLE_COLOR *pclrMaskColor);


void __RPC_STUB IImageList_get_MaskColor_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE IImageList_put_MaskColor_Proxy( 
    IImageList * This,
    /* [in] */ /* external definition not present */ OLE_COLOR pclrMaskColor);


void __RPC_STUB IImageList_put_MaskColor_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IImageList_get_UseMaskColor_Proxy( 
    IImageList * This,
    /* [retval][out] */ VARIANT_BOOL *pbState);


void __RPC_STUB IImageList_get_UseMaskColor_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE IImageList_put_UseMaskColor_Proxy( 
    IImageList * This,
    /* [in] */ VARIANT_BOOL pbState);


void __RPC_STUB IImageList_put_UseMaskColor_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IImageList_get_ListImages_Proxy( 
    IImageList * This,
    /* [retval][out] */ IImages **ppListImages);


void __RPC_STUB IImageList_get_ListImages_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propputref][id] */ HRESULT STDMETHODCALLTYPE IImageList_putref_ListImages_Proxy( 
    IImageList * This,
    /* [in] */ IImages *ppListImages);


void __RPC_STUB IImageList_putref_ListImages_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IImageList_get_hImageList_Proxy( 
    IImageList * This,
    /* [retval][out] */ /* external definition not present */ OLE_HANDLE *phImageList);


void __RPC_STUB IImageList_get_hImageList_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE IImageList_put_hImageList_Proxy( 
    IImageList * This,
    /* [in] */ /* external definition not present */ OLE_HANDLE phImageList);


void __RPC_STUB IImageList_put_hImageList_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IImageList_get_BackColor_Proxy( 
    IImageList * This,
    /* [retval][out] */ /* external definition not present */ OLE_COLOR *pclrBackColor);


void __RPC_STUB IImageList_get_BackColor_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE IImageList_put_BackColor_Proxy( 
    IImageList * This,
    /* [in] */ /* external definition not present */ OLE_COLOR pclrBackColor);


void __RPC_STUB IImageList_put_BackColor_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][id] */ HRESULT STDMETHODCALLTYPE IImageList_Overlay_Proxy( 
    IImageList * This,
    /* [in] */ VARIANT *Key1,
    /* [in] */ VARIANT *Key2,
    /* [retval][out] */ /* external definition not present */ IPictureDisp **ppPictureDisp);


void __RPC_STUB IImageList_Overlay_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [hidden][id] */ HRESULT STDMETHODCALLTYPE IImageList_AboutBox_Proxy( 
    IImageList * This);


void __RPC_STUB IImageList_AboutBox_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IImageList_INTERFACE_DEFINED__ */


#ifndef __ImageListEvents_DISPINTERFACE_DEFINED__
#define __ImageListEvents_DISPINTERFACE_DEFINED__

/* dispinterface ImageListEvents */
/* [helpcontext][helpstring][uuid] */ 


EXTERN_C const IID DIID_ImageListEvents;

#if defined(__cplusplus) && !defined(CINTERFACE)

    MIDL_INTERFACE("2C247F22-8591-11D1-B16A-00C0F0283628")
    ImageListEvents : public IDispatch
    {
    };
    
#else 	/* C style interface */

    typedef struct ImageListEventsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ImageListEvents * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ImageListEvents * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ImageListEvents * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            ImageListEvents * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            ImageListEvents * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            ImageListEvents * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            ImageListEvents * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        END_INTERFACE
    } ImageListEventsVtbl;

    interface ImageListEvents
    {
        CONST_VTBL struct ImageListEventsVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ImageListEvents_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ImageListEvents_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ImageListEvents_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ImageListEvents_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define ImageListEvents_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define ImageListEvents_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define ImageListEvents_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)

#endif /* COBJMACROS */


#endif 	/* C style interface */


#endif 	/* __ImageListEvents_DISPINTERFACE_DEFINED__ */


#ifndef __IImages_INTERFACE_DEFINED__
#define __IImages_INTERFACE_DEFINED__

/* interface IImages */
/* [object][oleautomation][nonextensible][dual][hidden][helpcontext][helpstring][uuid] */ 


EXTERN_C const IID IID_IImages;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("2C247F24-8591-11D1-B16A-00C0F0283628")
    IImages : public IDispatch
    {
    public:
        virtual /* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_Count( 
            /* [retval][out] */ short *psCount) = 0;
        
        virtual /* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_Count( 
            /* [in] */ short psCount) = 0;
        
        virtual /* [hidden][propget][id] */ HRESULT STDMETHODCALLTYPE get_ControlDefault( 
            /* [in] */ VARIANT *Index,
            /* [retval][out] */ IImage **ppListImage) = 0;
        
        virtual /* [hidden][propputref][id] */ HRESULT STDMETHODCALLTYPE putref_ControlDefault( 
            /* [in] */ VARIANT *Index,
            /* [in] */ IImage *ppListImage) = 0;
        
        virtual /* [helpcontext][helpstring][id] */ HRESULT STDMETHODCALLTYPE Add( 
            /* [optional][in] */ VARIANT *Index,
            /* [optional][in] */ VARIANT *Key,
            /* [optional][in] */ VARIANT *Picture,
            /* [retval][out] */ IImage **ppListImage) = 0;
        
        virtual /* [helpcontext][helpstring][id] */ HRESULT STDMETHODCALLTYPE Clear( void) = 0;
        
        virtual /* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_Item( 
            /* [in] */ VARIANT *Index,
            /* [retval][out] */ IImage **Item) = 0;
        
        virtual /* [helpcontext][helpstring][propputref][id] */ HRESULT STDMETHODCALLTYPE putref_Item( 
            /* [in] */ VARIANT *Index,
            /* [in] */ IImage *Item) = 0;
        
        virtual /* [helpcontext][helpstring][id] */ HRESULT STDMETHODCALLTYPE Remove( 
            /* [in] */ VARIANT *Index) = 0;
        
        virtual /* [hidden][id] */ HRESULT STDMETHODCALLTYPE _NewEnum( 
            /* [retval][out] */ IDispatch **ppNewEnum) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IImagesVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IImages * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IImages * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IImages * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IImages * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IImages * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IImages * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IImages * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_Count )( 
            IImages * This,
            /* [retval][out] */ short *psCount);
        
        /* [helpcontext][helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_Count )( 
            IImages * This,
            /* [in] */ short psCount);
        
        /* [hidden][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_ControlDefault )( 
            IImages * This,
            /* [in] */ VARIANT *Index,
            /* [retval][out] */ IImage **ppListImage);
        
        /* [hidden][propputref][id] */ HRESULT ( STDMETHODCALLTYPE *putref_ControlDefault )( 
            IImages * This,
            /* [in] */ VARIANT *Index,
            /* [in] */ IImage *ppListImage);
        
        /* [helpcontext][helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Add )( 
            IImages * This,
            /* [optional][in] */ VARIANT *Index,
            /* [optional][in] */ VARIANT *Key,
            /* [optional][in] */ VARIANT *Picture,
            /* [retval][out] */ IImage **ppListImage);
        
        /* [helpcontext][helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Clear )( 
            IImages * This);
        
        /* [helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_Item )( 
            IImages * This,
            /* [in] */ VARIANT *Index,
            /* [retval][out] */ IImage **Item);
        
        /* [helpcontext][helpstring][propputref][id] */ HRESULT ( STDMETHODCALLTYPE *putref_Item )( 
            IImages * This,
            /* [in] */ VARIANT *Index,
            /* [in] */ IImage *Item);
        
        /* [helpcontext][helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Remove )( 
            IImages * This,
            /* [in] */ VARIANT *Index);
        
        /* [hidden][id] */ HRESULT ( STDMETHODCALLTYPE *_NewEnum )( 
            IImages * This,
            /* [retval][out] */ IDispatch **ppNewEnum);
        
        END_INTERFACE
    } IImagesVtbl;

    interface IImages
    {
        CONST_VTBL struct IImagesVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IImages_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IImages_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IImages_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IImages_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IImages_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IImages_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IImages_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IImages_get_Count(This,psCount)	\
    (This)->lpVtbl -> get_Count(This,psCount)

#define IImages_put_Count(This,psCount)	\
    (This)->lpVtbl -> put_Count(This,psCount)

#define IImages_get_ControlDefault(This,Index,ppListImage)	\
    (This)->lpVtbl -> get_ControlDefault(This,Index,ppListImage)

#define IImages_putref_ControlDefault(This,Index,ppListImage)	\
    (This)->lpVtbl -> putref_ControlDefault(This,Index,ppListImage)

#define IImages_Add(This,Index,Key,Picture,ppListImage)	\
    (This)->lpVtbl -> Add(This,Index,Key,Picture,ppListImage)

#define IImages_Clear(This)	\
    (This)->lpVtbl -> Clear(This)

#define IImages_get_Item(This,Index,Item)	\
    (This)->lpVtbl -> get_Item(This,Index,Item)

#define IImages_putref_Item(This,Index,Item)	\
    (This)->lpVtbl -> putref_Item(This,Index,Item)

#define IImages_Remove(This,Index)	\
    (This)->lpVtbl -> Remove(This,Index)

#define IImages__NewEnum(This,ppNewEnum)	\
    (This)->lpVtbl -> _NewEnum(This,ppNewEnum)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IImages_get_Count_Proxy( 
    IImages * This,
    /* [retval][out] */ short *psCount);


void __RPC_STUB IImages_get_Count_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE IImages_put_Count_Proxy( 
    IImages * This,
    /* [in] */ short psCount);


void __RPC_STUB IImages_put_Count_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [hidden][propget][id] */ HRESULT STDMETHODCALLTYPE IImages_get_ControlDefault_Proxy( 
    IImages * This,
    /* [in] */ VARIANT *Index,
    /* [retval][out] */ IImage **ppListImage);


void __RPC_STUB IImages_get_ControlDefault_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [hidden][propputref][id] */ HRESULT STDMETHODCALLTYPE IImages_putref_ControlDefault_Proxy( 
    IImages * This,
    /* [in] */ VARIANT *Index,
    /* [in] */ IImage *ppListImage);


void __RPC_STUB IImages_putref_ControlDefault_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][id] */ HRESULT STDMETHODCALLTYPE IImages_Add_Proxy( 
    IImages * This,
    /* [optional][in] */ VARIANT *Index,
    /* [optional][in] */ VARIANT *Key,
    /* [optional][in] */ VARIANT *Picture,
    /* [retval][out] */ IImage **ppListImage);


void __RPC_STUB IImages_Add_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][id] */ HRESULT STDMETHODCALLTYPE IImages_Clear_Proxy( 
    IImages * This);


void __RPC_STUB IImages_Clear_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IImages_get_Item_Proxy( 
    IImages * This,
    /* [in] */ VARIANT *Index,
    /* [retval][out] */ IImage **Item);


void __RPC_STUB IImages_get_Item_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propputref][id] */ HRESULT STDMETHODCALLTYPE IImages_putref_Item_Proxy( 
    IImages * This,
    /* [in] */ VARIANT *Index,
    /* [in] */ IImage *Item);


void __RPC_STUB IImages_putref_Item_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][id] */ HRESULT STDMETHODCALLTYPE IImages_Remove_Proxy( 
    IImages * This,
    /* [in] */ VARIANT *Index);


void __RPC_STUB IImages_Remove_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [hidden][id] */ HRESULT STDMETHODCALLTYPE IImages__NewEnum_Proxy( 
    IImages * This,
    /* [retval][out] */ IDispatch **ppNewEnum);


void __RPC_STUB IImages__NewEnum_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IImages_INTERFACE_DEFINED__ */


#ifndef __IImage_INTERFACE_DEFINED__
#define __IImage_INTERFACE_DEFINED__

/* interface IImage */
/* [object][oleautomation][nonextensible][dual][hidden][helpcontext][helpstring][uuid] */ 


EXTERN_C const IID IID_IImage;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("2C247F26-8591-11D1-B16A-00C0F0283628")
    IImage : public IDispatch
    {
    public:
        virtual /* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_Index( 
            /* [retval][out] */ short *psIndex) = 0;
        
        virtual /* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_Index( 
            /* [in] */ short psIndex) = 0;
        
        virtual /* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_Key( 
            /* [retval][out] */ BSTR *pbstrKey) = 0;
        
        virtual /* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_Key( 
            /* [in] */ BSTR pbstrKey) = 0;
        
        virtual /* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_Tag( 
            /* [retval][out] */ VARIANT *pvTag) = 0;
        
        virtual /* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_Tag( 
            /* [in] */ VARIANT pvTag) = 0;
        
        virtual /* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_Picture( 
            /* [retval][out] */ /* external definition not present */ IPictureDisp **ppPictureDisp) = 0;
        
        virtual /* [helpcontext][helpstring][propputref][id] */ HRESULT STDMETHODCALLTYPE putref_Picture( 
            /* [in] */ /* external definition not present */ IPictureDisp *ppPictureDisp) = 0;
        
        virtual /* [helpcontext][helpstring][id] */ HRESULT STDMETHODCALLTYPE Draw( 
            /* [in] */ /* external definition not present */ OLE_HANDLE hDC,
            /* [optional][in] */ VARIANT *x,
            /* [optional][in] */ VARIANT *y,
            /* [optional][in] */ VARIANT *Style) = 0;
        
        virtual /* [helpcontext][helpstring][id] */ HRESULT STDMETHODCALLTYPE ExtractIcon( 
            /* [retval][out] */ /* external definition not present */ IPictureDisp **ppIconDisp) = 0;
        
        virtual /* [helpcontext][helpstring][propputref][id] */ HRESULT STDMETHODCALLTYPE putref_Tag( 
            /* [in] */ VARIANT pvTag) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IImageVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IImage * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IImage * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IImage * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IImage * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IImage * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IImage * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IImage * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_Index )( 
            IImage * This,
            /* [retval][out] */ short *psIndex);
        
        /* [helpcontext][helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_Index )( 
            IImage * This,
            /* [in] */ short psIndex);
        
        /* [helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_Key )( 
            IImage * This,
            /* [retval][out] */ BSTR *pbstrKey);
        
        /* [helpcontext][helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_Key )( 
            IImage * This,
            /* [in] */ BSTR pbstrKey);
        
        /* [helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_Tag )( 
            IImage * This,
            /* [retval][out] */ VARIANT *pvTag);
        
        /* [helpcontext][helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_Tag )( 
            IImage * This,
            /* [in] */ VARIANT pvTag);
        
        /* [helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_Picture )( 
            IImage * This,
            /* [retval][out] */ /* external definition not present */ IPictureDisp **ppPictureDisp);
        
        /* [helpcontext][helpstring][propputref][id] */ HRESULT ( STDMETHODCALLTYPE *putref_Picture )( 
            IImage * This,
            /* [in] */ /* external definition not present */ IPictureDisp *ppPictureDisp);
        
        /* [helpcontext][helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Draw )( 
            IImage * This,
            /* [in] */ /* external definition not present */ OLE_HANDLE hDC,
            /* [optional][in] */ VARIANT *x,
            /* [optional][in] */ VARIANT *y,
            /* [optional][in] */ VARIANT *Style);
        
        /* [helpcontext][helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *ExtractIcon )( 
            IImage * This,
            /* [retval][out] */ /* external definition not present */ IPictureDisp **ppIconDisp);
        
        /* [helpcontext][helpstring][propputref][id] */ HRESULT ( STDMETHODCALLTYPE *putref_Tag )( 
            IImage * This,
            /* [in] */ VARIANT pvTag);
        
        END_INTERFACE
    } IImageVtbl;

    interface IImage
    {
        CONST_VTBL struct IImageVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IImage_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IImage_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IImage_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IImage_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IImage_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IImage_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IImage_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IImage_get_Index(This,psIndex)	\
    (This)->lpVtbl -> get_Index(This,psIndex)

#define IImage_put_Index(This,psIndex)	\
    (This)->lpVtbl -> put_Index(This,psIndex)

#define IImage_get_Key(This,pbstrKey)	\
    (This)->lpVtbl -> get_Key(This,pbstrKey)

#define IImage_put_Key(This,pbstrKey)	\
    (This)->lpVtbl -> put_Key(This,pbstrKey)

#define IImage_get_Tag(This,pvTag)	\
    (This)->lpVtbl -> get_Tag(This,pvTag)

#define IImage_put_Tag(This,pvTag)	\
    (This)->lpVtbl -> put_Tag(This,pvTag)

#define IImage_get_Picture(This,ppPictureDisp)	\
    (This)->lpVtbl -> get_Picture(This,ppPictureDisp)

#define IImage_putref_Picture(This,ppPictureDisp)	\
    (This)->lpVtbl -> putref_Picture(This,ppPictureDisp)

#define IImage_Draw(This,hDC,x,y,Style)	\
    (This)->lpVtbl -> Draw(This,hDC,x,y,Style)

#define IImage_ExtractIcon(This,ppIconDisp)	\
    (This)->lpVtbl -> ExtractIcon(This,ppIconDisp)

#define IImage_putref_Tag(This,pvTag)	\
    (This)->lpVtbl -> putref_Tag(This,pvTag)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IImage_get_Index_Proxy( 
    IImage * This,
    /* [retval][out] */ short *psIndex);


void __RPC_STUB IImage_get_Index_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE IImage_put_Index_Proxy( 
    IImage * This,
    /* [in] */ short psIndex);


void __RPC_STUB IImage_put_Index_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IImage_get_Key_Proxy( 
    IImage * This,
    /* [retval][out] */ BSTR *pbstrKey);


void __RPC_STUB IImage_get_Key_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE IImage_put_Key_Proxy( 
    IImage * This,
    /* [in] */ BSTR pbstrKey);


void __RPC_STUB IImage_put_Key_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IImage_get_Tag_Proxy( 
    IImage * This,
    /* [retval][out] */ VARIANT *pvTag);


void __RPC_STUB IImage_get_Tag_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE IImage_put_Tag_Proxy( 
    IImage * This,
    /* [in] */ VARIANT pvTag);


void __RPC_STUB IImage_put_Tag_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IImage_get_Picture_Proxy( 
    IImage * This,
    /* [retval][out] */ /* external definition not present */ IPictureDisp **ppPictureDisp);


void __RPC_STUB IImage_get_Picture_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propputref][id] */ HRESULT STDMETHODCALLTYPE IImage_putref_Picture_Proxy( 
    IImage * This,
    /* [in] */ /* external definition not present */ IPictureDisp *ppPictureDisp);


void __RPC_STUB IImage_putref_Picture_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][id] */ HRESULT STDMETHODCALLTYPE IImage_Draw_Proxy( 
    IImage * This,
    /* [in] */ /* external definition not present */ OLE_HANDLE hDC,
    /* [optional][in] */ VARIANT *x,
    /* [optional][in] */ VARIANT *y,
    /* [optional][in] */ VARIANT *Style);


void __RPC_STUB IImage_Draw_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][id] */ HRESULT STDMETHODCALLTYPE IImage_ExtractIcon_Proxy( 
    IImage * This,
    /* [retval][out] */ /* external definition not present */ IPictureDisp **ppIconDisp);


void __RPC_STUB IImage_ExtractIcon_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propputref][id] */ HRESULT STDMETHODCALLTYPE IImage_putref_Tag_Proxy( 
    IImage * This,
    /* [in] */ VARIANT pvTag);


void __RPC_STUB IImage_putref_Tag_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IImage_INTERFACE_DEFINED__ */


#ifndef __ISlider_INTERFACE_DEFINED__
#define __ISlider_INTERFACE_DEFINED__

/* interface ISlider */
/* [object][oleautomation][nonextensible][dual][hidden][helpcontext][helpstring][uuid] */ 


EXTERN_C const IID IID_ISlider;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("F08DF952-8592-11D1-B16A-00C0F0283628")
    ISlider : public IDispatch
    {
    public:
        virtual /* [hidden][propget][id] */ HRESULT STDMETHODCALLTYPE get__Value( 
            /* [retval][out] */ long *plValue) = 0;
        
        virtual /* [hidden][propput][id] */ HRESULT STDMETHODCALLTYPE put__Value( 
            /* [in] */ long plValue) = 0;
        
        virtual /* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_LargeChange( 
            /* [retval][out] */ long *plLargeChange) = 0;
        
        virtual /* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_LargeChange( 
            /* [in] */ long plLargeChange) = 0;
        
        virtual /* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_SmallChange( 
            /* [retval][out] */ long *plSmallChange) = 0;
        
        virtual /* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_SmallChange( 
            /* [in] */ long plSmallChange) = 0;
        
        virtual /* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_Max( 
            /* [retval][out] */ long *plMax) = 0;
        
        virtual /* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_Max( 
            /* [in] */ long plMax) = 0;
        
        virtual /* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_Min( 
            /* [retval][out] */ long *plMin) = 0;
        
        virtual /* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_Min( 
            /* [in] */ long plMin) = 0;
        
        virtual /* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_Orientation( 
            /* [retval][out] */ OrientationConstants *pOrientation) = 0;
        
        virtual /* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_Orientation( 
            /* [in] */ OrientationConstants pOrientation) = 0;
        
        virtual /* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_SelectRange( 
            /* [retval][out] */ VARIANT_BOOL *pbSelectRange) = 0;
        
        virtual /* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_SelectRange( 
            /* [in] */ VARIANT_BOOL pbSelectRange) = 0;
        
        virtual /* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_SelStart( 
            /* [retval][out] */ long *plSelStart) = 0;
        
        virtual /* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_SelStart( 
            /* [in] */ long plSelStart) = 0;
        
        virtual /* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_SelLength( 
            /* [retval][out] */ long *plSelLength) = 0;
        
        virtual /* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_SelLength( 
            /* [in] */ long plSelLength) = 0;
        
        virtual /* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_TickStyle( 
            /* [retval][out] */ TickStyleConstants *pTickStyle) = 0;
        
        virtual /* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_TickStyle( 
            /* [in] */ TickStyleConstants pTickStyle) = 0;
        
        virtual /* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_TickFrequency( 
            /* [retval][out] */ long *plTickFrequency) = 0;
        
        virtual /* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_TickFrequency( 
            /* [in] */ long plTickFrequency) = 0;
        
        virtual /* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_Value( 
            /* [retval][out] */ long *plValue) = 0;
        
        virtual /* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_Value( 
            /* [in] */ long plValue) = 0;
        
        virtual /* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_MouseIcon( 
            /* [retval][out] */ /* external definition not present */ IPictureDisp **ppMouseIcon) = 0;
        
        virtual /* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_MouseIcon( 
            /* [in] */ /* external definition not present */ IPictureDisp *ppMouseIcon) = 0;
        
        virtual /* [helpcontext][helpstring][propputref][id] */ HRESULT STDMETHODCALLTYPE putref_MouseIcon( 
            /* [in] */ /* external definition not present */ IPictureDisp *ppMouseIcon) = 0;
        
        virtual /* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_MousePointer( 
            /* [retval][out] */ MousePointerConstants *psMousePointer) = 0;
        
        virtual /* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_MousePointer( 
            /* [in] */ MousePointerConstants psMousePointer) = 0;
        
        virtual /* [helpcontext][helpstring][requestedit][bindable][propget][id] */ HRESULT STDMETHODCALLTYPE get_Enabled( 
            /* [retval][out] */ VARIANT_BOOL *pbEnabled) = 0;
        
        virtual /* [helpcontext][helpstring][requestedit][bindable][propput][id] */ HRESULT STDMETHODCALLTYPE put_Enabled( 
            /* [in] */ VARIANT_BOOL pbEnabled) = 0;
        
        virtual /* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_hWnd( 
            /* [retval][out] */ /* external definition not present */ OLE_HANDLE *phWnd) = 0;
        
        virtual /* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_hWnd( 
            /* [in] */ /* external definition not present */ OLE_HANDLE phWnd) = 0;
        
        virtual /* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_BorderStyle( 
            /* [retval][out] */ BorderStyleConstants *psBorderStyle) = 0;
        
        virtual /* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_BorderStyle( 
            /* [in] */ BorderStyleConstants psBorderStyle) = 0;
        
        virtual /* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_OLEDropMode( 
            /* [retval][out] */ OLEDropConstants *psOLEDropMode) = 0;
        
        virtual /* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_OLEDropMode( 
            /* [in] */ OLEDropConstants psOLEDropMode) = 0;
        
        virtual /* [helpcontext][helpstring][id] */ void STDMETHODCALLTYPE Refresh( void) = 0;
        
        virtual /* [helpcontext][helpstring][id] */ void STDMETHODCALLTYPE ClearSel( void) = 0;
        
        virtual /* [helpcontext][helpstring][hidden][id] */ void STDMETHODCALLTYPE DoClick( void) = 0;
        
        virtual /* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_GetNumTicks( 
            /* [retval][out] */ long *plNumTicks) = 0;
        
        virtual /* [helpcontext][helpstring][id] */ HRESULT STDMETHODCALLTYPE OLEDrag( void) = 0;
        
        virtual /* [hidden][id] */ void STDMETHODCALLTYPE AboutBox( void) = 0;
        
        virtual /* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_Text( 
            /* [retval][out] */ BSTR *pbstrText) = 0;
        
        virtual /* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_Text( 
            /* [in] */ BSTR pbstrText) = 0;
        
        virtual /* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_TextPosition( 
            /* [retval][out] */ TextPositionConstants *penumTextPosition) = 0;
        
        virtual /* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_TextPosition( 
            /* [in] */ TextPositionConstants penumTextPosition) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ISliderVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ISlider * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ISlider * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ISlider * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            ISlider * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            ISlider * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            ISlider * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            ISlider * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [hidden][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get__Value )( 
            ISlider * This,
            /* [retval][out] */ long *plValue);
        
        /* [hidden][propput][id] */ HRESULT ( STDMETHODCALLTYPE *put__Value )( 
            ISlider * This,
            /* [in] */ long plValue);
        
        /* [helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_LargeChange )( 
            ISlider * This,
            /* [retval][out] */ long *plLargeChange);
        
        /* [helpcontext][helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_LargeChange )( 
            ISlider * This,
            /* [in] */ long plLargeChange);
        
        /* [helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_SmallChange )( 
            ISlider * This,
            /* [retval][out] */ long *plSmallChange);
        
        /* [helpcontext][helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_SmallChange )( 
            ISlider * This,
            /* [in] */ long plSmallChange);
        
        /* [helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_Max )( 
            ISlider * This,
            /* [retval][out] */ long *plMax);
        
        /* [helpcontext][helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_Max )( 
            ISlider * This,
            /* [in] */ long plMax);
        
        /* [helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_Min )( 
            ISlider * This,
            /* [retval][out] */ long *plMin);
        
        /* [helpcontext][helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_Min )( 
            ISlider * This,
            /* [in] */ long plMin);
        
        /* [helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_Orientation )( 
            ISlider * This,
            /* [retval][out] */ OrientationConstants *pOrientation);
        
        /* [helpcontext][helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_Orientation )( 
            ISlider * This,
            /* [in] */ OrientationConstants pOrientation);
        
        /* [helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_SelectRange )( 
            ISlider * This,
            /* [retval][out] */ VARIANT_BOOL *pbSelectRange);
        
        /* [helpcontext][helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_SelectRange )( 
            ISlider * This,
            /* [in] */ VARIANT_BOOL pbSelectRange);
        
        /* [helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_SelStart )( 
            ISlider * This,
            /* [retval][out] */ long *plSelStart);
        
        /* [helpcontext][helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_SelStart )( 
            ISlider * This,
            /* [in] */ long plSelStart);
        
        /* [helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_SelLength )( 
            ISlider * This,
            /* [retval][out] */ long *plSelLength);
        
        /* [helpcontext][helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_SelLength )( 
            ISlider * This,
            /* [in] */ long plSelLength);
        
        /* [helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_TickStyle )( 
            ISlider * This,
            /* [retval][out] */ TickStyleConstants *pTickStyle);
        
        /* [helpcontext][helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_TickStyle )( 
            ISlider * This,
            /* [in] */ TickStyleConstants pTickStyle);
        
        /* [helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_TickFrequency )( 
            ISlider * This,
            /* [retval][out] */ long *plTickFrequency);
        
        /* [helpcontext][helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_TickFrequency )( 
            ISlider * This,
            /* [in] */ long plTickFrequency);
        
        /* [helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_Value )( 
            ISlider * This,
            /* [retval][out] */ long *plValue);
        
        /* [helpcontext][helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_Value )( 
            ISlider * This,
            /* [in] */ long plValue);
        
        /* [helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_MouseIcon )( 
            ISlider * This,
            /* [retval][out] */ /* external definition not present */ IPictureDisp **ppMouseIcon);
        
        /* [helpcontext][helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_MouseIcon )( 
            ISlider * This,
            /* [in] */ /* external definition not present */ IPictureDisp *ppMouseIcon);
        
        /* [helpcontext][helpstring][propputref][id] */ HRESULT ( STDMETHODCALLTYPE *putref_MouseIcon )( 
            ISlider * This,
            /* [in] */ /* external definition not present */ IPictureDisp *ppMouseIcon);
        
        /* [helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_MousePointer )( 
            ISlider * This,
            /* [retval][out] */ MousePointerConstants *psMousePointer);
        
        /* [helpcontext][helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_MousePointer )( 
            ISlider * This,
            /* [in] */ MousePointerConstants psMousePointer);
        
        /* [helpcontext][helpstring][requestedit][bindable][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_Enabled )( 
            ISlider * This,
            /* [retval][out] */ VARIANT_BOOL *pbEnabled);
        
        /* [helpcontext][helpstring][requestedit][bindable][propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_Enabled )( 
            ISlider * This,
            /* [in] */ VARIANT_BOOL pbEnabled);
        
        /* [helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_hWnd )( 
            ISlider * This,
            /* [retval][out] */ /* external definition not present */ OLE_HANDLE *phWnd);
        
        /* [helpcontext][helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_hWnd )( 
            ISlider * This,
            /* [in] */ /* external definition not present */ OLE_HANDLE phWnd);
        
        /* [helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_BorderStyle )( 
            ISlider * This,
            /* [retval][out] */ BorderStyleConstants *psBorderStyle);
        
        /* [helpcontext][helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_BorderStyle )( 
            ISlider * This,
            /* [in] */ BorderStyleConstants psBorderStyle);
        
        /* [helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_OLEDropMode )( 
            ISlider * This,
            /* [retval][out] */ OLEDropConstants *psOLEDropMode);
        
        /* [helpcontext][helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_OLEDropMode )( 
            ISlider * This,
            /* [in] */ OLEDropConstants psOLEDropMode);
        
        /* [helpcontext][helpstring][id] */ void ( STDMETHODCALLTYPE *Refresh )( 
            ISlider * This);
        
        /* [helpcontext][helpstring][id] */ void ( STDMETHODCALLTYPE *ClearSel )( 
            ISlider * This);
        
        /* [helpcontext][helpstring][hidden][id] */ void ( STDMETHODCALLTYPE *DoClick )( 
            ISlider * This);
        
        /* [helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_GetNumTicks )( 
            ISlider * This,
            /* [retval][out] */ long *plNumTicks);
        
        /* [helpcontext][helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *OLEDrag )( 
            ISlider * This);
        
        /* [hidden][id] */ void ( STDMETHODCALLTYPE *AboutBox )( 
            ISlider * This);
        
        /* [helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_Text )( 
            ISlider * This,
            /* [retval][out] */ BSTR *pbstrText);
        
        /* [helpcontext][helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_Text )( 
            ISlider * This,
            /* [in] */ BSTR pbstrText);
        
        /* [helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_TextPosition )( 
            ISlider * This,
            /* [retval][out] */ TextPositionConstants *penumTextPosition);
        
        /* [helpcontext][helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_TextPosition )( 
            ISlider * This,
            /* [in] */ TextPositionConstants penumTextPosition);
        
        END_INTERFACE
    } ISliderVtbl;

    interface ISlider
    {
        CONST_VTBL struct ISliderVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ISlider_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ISlider_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ISlider_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ISlider_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define ISlider_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define ISlider_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define ISlider_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define ISlider_get__Value(This,plValue)	\
    (This)->lpVtbl -> get__Value(This,plValue)

#define ISlider_put__Value(This,plValue)	\
    (This)->lpVtbl -> put__Value(This,plValue)

#define ISlider_get_LargeChange(This,plLargeChange)	\
    (This)->lpVtbl -> get_LargeChange(This,plLargeChange)

#define ISlider_put_LargeChange(This,plLargeChange)	\
    (This)->lpVtbl -> put_LargeChange(This,plLargeChange)

#define ISlider_get_SmallChange(This,plSmallChange)	\
    (This)->lpVtbl -> get_SmallChange(This,plSmallChange)

#define ISlider_put_SmallChange(This,plSmallChange)	\
    (This)->lpVtbl -> put_SmallChange(This,plSmallChange)

#define ISlider_get_Max(This,plMax)	\
    (This)->lpVtbl -> get_Max(This,plMax)

#define ISlider_put_Max(This,plMax)	\
    (This)->lpVtbl -> put_Max(This,plMax)

#define ISlider_get_Min(This,plMin)	\
    (This)->lpVtbl -> get_Min(This,plMin)

#define ISlider_put_Min(This,plMin)	\
    (This)->lpVtbl -> put_Min(This,plMin)

#define ISlider_get_Orientation(This,pOrientation)	\
    (This)->lpVtbl -> get_Orientation(This,pOrientation)

#define ISlider_put_Orientation(This,pOrientation)	\
    (This)->lpVtbl -> put_Orientation(This,pOrientation)

#define ISlider_get_SelectRange(This,pbSelectRange)	\
    (This)->lpVtbl -> get_SelectRange(This,pbSelectRange)

#define ISlider_put_SelectRange(This,pbSelectRange)	\
    (This)->lpVtbl -> put_SelectRange(This,pbSelectRange)

#define ISlider_get_SelStart(This,plSelStart)	\
    (This)->lpVtbl -> get_SelStart(This,plSelStart)

#define ISlider_put_SelStart(This,plSelStart)	\
    (This)->lpVtbl -> put_SelStart(This,plSelStart)

#define ISlider_get_SelLength(This,plSelLength)	\
    (This)->lpVtbl -> get_SelLength(This,plSelLength)

#define ISlider_put_SelLength(This,plSelLength)	\
    (This)->lpVtbl -> put_SelLength(This,plSelLength)

#define ISlider_get_TickStyle(This,pTickStyle)	\
    (This)->lpVtbl -> get_TickStyle(This,pTickStyle)

#define ISlider_put_TickStyle(This,pTickStyle)	\
    (This)->lpVtbl -> put_TickStyle(This,pTickStyle)

#define ISlider_get_TickFrequency(This,plTickFrequency)	\
    (This)->lpVtbl -> get_TickFrequency(This,plTickFrequency)

#define ISlider_put_TickFrequency(This,plTickFrequency)	\
    (This)->lpVtbl -> put_TickFrequency(This,plTickFrequency)

#define ISlider_get_Value(This,plValue)	\
    (This)->lpVtbl -> get_Value(This,plValue)

#define ISlider_put_Value(This,plValue)	\
    (This)->lpVtbl -> put_Value(This,plValue)

#define ISlider_get_MouseIcon(This,ppMouseIcon)	\
    (This)->lpVtbl -> get_MouseIcon(This,ppMouseIcon)

#define ISlider_put_MouseIcon(This,ppMouseIcon)	\
    (This)->lpVtbl -> put_MouseIcon(This,ppMouseIcon)

#define ISlider_putref_MouseIcon(This,ppMouseIcon)	\
    (This)->lpVtbl -> putref_MouseIcon(This,ppMouseIcon)

#define ISlider_get_MousePointer(This,psMousePointer)	\
    (This)->lpVtbl -> get_MousePointer(This,psMousePointer)

#define ISlider_put_MousePointer(This,psMousePointer)	\
    (This)->lpVtbl -> put_MousePointer(This,psMousePointer)

#define ISlider_get_Enabled(This,pbEnabled)	\
    (This)->lpVtbl -> get_Enabled(This,pbEnabled)

#define ISlider_put_Enabled(This,pbEnabled)	\
    (This)->lpVtbl -> put_Enabled(This,pbEnabled)

#define ISlider_get_hWnd(This,phWnd)	\
    (This)->lpVtbl -> get_hWnd(This,phWnd)

#define ISlider_put_hWnd(This,phWnd)	\
    (This)->lpVtbl -> put_hWnd(This,phWnd)

#define ISlider_get_BorderStyle(This,psBorderStyle)	\
    (This)->lpVtbl -> get_BorderStyle(This,psBorderStyle)

#define ISlider_put_BorderStyle(This,psBorderStyle)	\
    (This)->lpVtbl -> put_BorderStyle(This,psBorderStyle)

#define ISlider_get_OLEDropMode(This,psOLEDropMode)	\
    (This)->lpVtbl -> get_OLEDropMode(This,psOLEDropMode)

#define ISlider_put_OLEDropMode(This,psOLEDropMode)	\
    (This)->lpVtbl -> put_OLEDropMode(This,psOLEDropMode)

#define ISlider_Refresh(This)	\
    (This)->lpVtbl -> Refresh(This)

#define ISlider_ClearSel(This)	\
    (This)->lpVtbl -> ClearSel(This)

#define ISlider_DoClick(This)	\
    (This)->lpVtbl -> DoClick(This)

#define ISlider_get_GetNumTicks(This,plNumTicks)	\
    (This)->lpVtbl -> get_GetNumTicks(This,plNumTicks)

#define ISlider_OLEDrag(This)	\
    (This)->lpVtbl -> OLEDrag(This)

#define ISlider_AboutBox(This)	\
    (This)->lpVtbl -> AboutBox(This)

#define ISlider_get_Text(This,pbstrText)	\
    (This)->lpVtbl -> get_Text(This,pbstrText)

#define ISlider_put_Text(This,pbstrText)	\
    (This)->lpVtbl -> put_Text(This,pbstrText)

#define ISlider_get_TextPosition(This,penumTextPosition)	\
    (This)->lpVtbl -> get_TextPosition(This,penumTextPosition)

#define ISlider_put_TextPosition(This,penumTextPosition)	\
    (This)->lpVtbl -> put_TextPosition(This,penumTextPosition)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [hidden][propget][id] */ HRESULT STDMETHODCALLTYPE ISlider_get__Value_Proxy( 
    ISlider * This,
    /* [retval][out] */ long *plValue);


void __RPC_STUB ISlider_get__Value_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [hidden][propput][id] */ HRESULT STDMETHODCALLTYPE ISlider_put__Value_Proxy( 
    ISlider * This,
    /* [in] */ long plValue);


void __RPC_STUB ISlider_put__Value_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE ISlider_get_LargeChange_Proxy( 
    ISlider * This,
    /* [retval][out] */ long *plLargeChange);


void __RPC_STUB ISlider_get_LargeChange_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE ISlider_put_LargeChange_Proxy( 
    ISlider * This,
    /* [in] */ long plLargeChange);


void __RPC_STUB ISlider_put_LargeChange_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE ISlider_get_SmallChange_Proxy( 
    ISlider * This,
    /* [retval][out] */ long *plSmallChange);


void __RPC_STUB ISlider_get_SmallChange_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE ISlider_put_SmallChange_Proxy( 
    ISlider * This,
    /* [in] */ long plSmallChange);


void __RPC_STUB ISlider_put_SmallChange_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE ISlider_get_Max_Proxy( 
    ISlider * This,
    /* [retval][out] */ long *plMax);


void __RPC_STUB ISlider_get_Max_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE ISlider_put_Max_Proxy( 
    ISlider * This,
    /* [in] */ long plMax);


void __RPC_STUB ISlider_put_Max_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE ISlider_get_Min_Proxy( 
    ISlider * This,
    /* [retval][out] */ long *plMin);


void __RPC_STUB ISlider_get_Min_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE ISlider_put_Min_Proxy( 
    ISlider * This,
    /* [in] */ long plMin);


void __RPC_STUB ISlider_put_Min_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE ISlider_get_Orientation_Proxy( 
    ISlider * This,
    /* [retval][out] */ OrientationConstants *pOrientation);


void __RPC_STUB ISlider_get_Orientation_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE ISlider_put_Orientation_Proxy( 
    ISlider * This,
    /* [in] */ OrientationConstants pOrientation);


void __RPC_STUB ISlider_put_Orientation_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE ISlider_get_SelectRange_Proxy( 
    ISlider * This,
    /* [retval][out] */ VARIANT_BOOL *pbSelectRange);


void __RPC_STUB ISlider_get_SelectRange_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE ISlider_put_SelectRange_Proxy( 
    ISlider * This,
    /* [in] */ VARIANT_BOOL pbSelectRange);


void __RPC_STUB ISlider_put_SelectRange_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE ISlider_get_SelStart_Proxy( 
    ISlider * This,
    /* [retval][out] */ long *plSelStart);


void __RPC_STUB ISlider_get_SelStart_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE ISlider_put_SelStart_Proxy( 
    ISlider * This,
    /* [in] */ long plSelStart);


void __RPC_STUB ISlider_put_SelStart_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE ISlider_get_SelLength_Proxy( 
    ISlider * This,
    /* [retval][out] */ long *plSelLength);


void __RPC_STUB ISlider_get_SelLength_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE ISlider_put_SelLength_Proxy( 
    ISlider * This,
    /* [in] */ long plSelLength);


void __RPC_STUB ISlider_put_SelLength_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE ISlider_get_TickStyle_Proxy( 
    ISlider * This,
    /* [retval][out] */ TickStyleConstants *pTickStyle);


void __RPC_STUB ISlider_get_TickStyle_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE ISlider_put_TickStyle_Proxy( 
    ISlider * This,
    /* [in] */ TickStyleConstants pTickStyle);


void __RPC_STUB ISlider_put_TickStyle_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE ISlider_get_TickFrequency_Proxy( 
    ISlider * This,
    /* [retval][out] */ long *plTickFrequency);


void __RPC_STUB ISlider_get_TickFrequency_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE ISlider_put_TickFrequency_Proxy( 
    ISlider * This,
    /* [in] */ long plTickFrequency);


void __RPC_STUB ISlider_put_TickFrequency_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE ISlider_get_Value_Proxy( 
    ISlider * This,
    /* [retval][out] */ long *plValue);


void __RPC_STUB ISlider_get_Value_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE ISlider_put_Value_Proxy( 
    ISlider * This,
    /* [in] */ long plValue);


void __RPC_STUB ISlider_put_Value_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE ISlider_get_MouseIcon_Proxy( 
    ISlider * This,
    /* [retval][out] */ /* external definition not present */ IPictureDisp **ppMouseIcon);


void __RPC_STUB ISlider_get_MouseIcon_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE ISlider_put_MouseIcon_Proxy( 
    ISlider * This,
    /* [in] */ /* external definition not present */ IPictureDisp *ppMouseIcon);


void __RPC_STUB ISlider_put_MouseIcon_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propputref][id] */ HRESULT STDMETHODCALLTYPE ISlider_putref_MouseIcon_Proxy( 
    ISlider * This,
    /* [in] */ /* external definition not present */ IPictureDisp *ppMouseIcon);


void __RPC_STUB ISlider_putref_MouseIcon_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE ISlider_get_MousePointer_Proxy( 
    ISlider * This,
    /* [retval][out] */ MousePointerConstants *psMousePointer);


void __RPC_STUB ISlider_get_MousePointer_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE ISlider_put_MousePointer_Proxy( 
    ISlider * This,
    /* [in] */ MousePointerConstants psMousePointer);


void __RPC_STUB ISlider_put_MousePointer_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][requestedit][bindable][propget][id] */ HRESULT STDMETHODCALLTYPE ISlider_get_Enabled_Proxy( 
    ISlider * This,
    /* [retval][out] */ VARIANT_BOOL *pbEnabled);


void __RPC_STUB ISlider_get_Enabled_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][requestedit][bindable][propput][id] */ HRESULT STDMETHODCALLTYPE ISlider_put_Enabled_Proxy( 
    ISlider * This,
    /* [in] */ VARIANT_BOOL pbEnabled);


void __RPC_STUB ISlider_put_Enabled_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE ISlider_get_hWnd_Proxy( 
    ISlider * This,
    /* [retval][out] */ /* external definition not present */ OLE_HANDLE *phWnd);


void __RPC_STUB ISlider_get_hWnd_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE ISlider_put_hWnd_Proxy( 
    ISlider * This,
    /* [in] */ /* external definition not present */ OLE_HANDLE phWnd);


void __RPC_STUB ISlider_put_hWnd_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE ISlider_get_BorderStyle_Proxy( 
    ISlider * This,
    /* [retval][out] */ BorderStyleConstants *psBorderStyle);


void __RPC_STUB ISlider_get_BorderStyle_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE ISlider_put_BorderStyle_Proxy( 
    ISlider * This,
    /* [in] */ BorderStyleConstants psBorderStyle);


void __RPC_STUB ISlider_put_BorderStyle_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE ISlider_get_OLEDropMode_Proxy( 
    ISlider * This,
    /* [retval][out] */ OLEDropConstants *psOLEDropMode);


void __RPC_STUB ISlider_get_OLEDropMode_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE ISlider_put_OLEDropMode_Proxy( 
    ISlider * This,
    /* [in] */ OLEDropConstants psOLEDropMode);


void __RPC_STUB ISlider_put_OLEDropMode_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][id] */ void STDMETHODCALLTYPE ISlider_Refresh_Proxy( 
    ISlider * This);


void __RPC_STUB ISlider_Refresh_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][id] */ void STDMETHODCALLTYPE ISlider_ClearSel_Proxy( 
    ISlider * This);


void __RPC_STUB ISlider_ClearSel_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][hidden][id] */ void STDMETHODCALLTYPE ISlider_DoClick_Proxy( 
    ISlider * This);


void __RPC_STUB ISlider_DoClick_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE ISlider_get_GetNumTicks_Proxy( 
    ISlider * This,
    /* [retval][out] */ long *plNumTicks);


void __RPC_STUB ISlider_get_GetNumTicks_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][id] */ HRESULT STDMETHODCALLTYPE ISlider_OLEDrag_Proxy( 
    ISlider * This);


void __RPC_STUB ISlider_OLEDrag_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [hidden][id] */ void STDMETHODCALLTYPE ISlider_AboutBox_Proxy( 
    ISlider * This);


void __RPC_STUB ISlider_AboutBox_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE ISlider_get_Text_Proxy( 
    ISlider * This,
    /* [retval][out] */ BSTR *pbstrText);


void __RPC_STUB ISlider_get_Text_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE ISlider_put_Text_Proxy( 
    ISlider * This,
    /* [in] */ BSTR pbstrText);


void __RPC_STUB ISlider_put_Text_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE ISlider_get_TextPosition_Proxy( 
    ISlider * This,
    /* [retval][out] */ TextPositionConstants *penumTextPosition);


void __RPC_STUB ISlider_get_TextPosition_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE ISlider_put_TextPosition_Proxy( 
    ISlider * This,
    /* [in] */ TextPositionConstants penumTextPosition);


void __RPC_STUB ISlider_put_TextPosition_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ISlider_INTERFACE_DEFINED__ */


#ifndef __ISliderEvents_DISPINTERFACE_DEFINED__
#define __ISliderEvents_DISPINTERFACE_DEFINED__

/* dispinterface ISliderEvents */
/* [helpcontext][helpstring][uuid] */ 


EXTERN_C const IID DIID_ISliderEvents;

#if defined(__cplusplus) && !defined(CINTERFACE)

    MIDL_INTERFACE("F08DF953-8592-11D1-B16A-00C0F0283628")
    ISliderEvents : public IDispatch
    {
    };
    
#else 	/* C style interface */

    typedef struct ISliderEventsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ISliderEvents * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ISliderEvents * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ISliderEvents * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            ISliderEvents * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            ISliderEvents * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            ISliderEvents * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            ISliderEvents * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        END_INTERFACE
    } ISliderEventsVtbl;

    interface ISliderEvents
    {
        CONST_VTBL struct ISliderEventsVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ISliderEvents_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ISliderEvents_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ISliderEvents_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ISliderEvents_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define ISliderEvents_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define ISliderEvents_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define ISliderEvents_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)

#endif /* COBJMACROS */


#endif 	/* C style interface */


#endif 	/* __ISliderEvents_DISPINTERFACE_DEFINED__ */


#ifndef __IControls_INTERFACE_DEFINED__
#define __IControls_INTERFACE_DEFINED__

/* interface IControls */
/* [object][oleautomation][nonextensible][dual][hidden][helpcontext][helpstring][uuid] */ 


EXTERN_C const IID IID_IControls;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("C8A3DC00-8593-11D1-B16A-00C0F0283628")
    IControls : public IDispatch
    {
    public:
        virtual /* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_Count( 
            /* [retval][out] */ long *plCount) = 0;
        
        virtual /* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_Item( 
            /* [in] */ long Index,
            /* [retval][out] */ IDispatch **ppDisp) = 0;
        
        virtual /* [hidden][id] */ HRESULT STDMETHODCALLTYPE _NewEnum( 
            /* [retval][out] */ IUnknown **ppUnk) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IControlsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IControls * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IControls * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IControls * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IControls * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IControls * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IControls * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IControls * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_Count )( 
            IControls * This,
            /* [retval][out] */ long *plCount);
        
        /* [helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_Item )( 
            IControls * This,
            /* [in] */ long Index,
            /* [retval][out] */ IDispatch **ppDisp);
        
        /* [hidden][id] */ HRESULT ( STDMETHODCALLTYPE *_NewEnum )( 
            IControls * This,
            /* [retval][out] */ IUnknown **ppUnk);
        
        END_INTERFACE
    } IControlsVtbl;

    interface IControls
    {
        CONST_VTBL struct IControlsVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IControls_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IControls_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IControls_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IControls_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IControls_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IControls_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IControls_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IControls_get_Count(This,plCount)	\
    (This)->lpVtbl -> get_Count(This,plCount)

#define IControls_get_Item(This,Index,ppDisp)	\
    (This)->lpVtbl -> get_Item(This,Index,ppDisp)

#define IControls__NewEnum(This,ppUnk)	\
    (This)->lpVtbl -> _NewEnum(This,ppUnk)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IControls_get_Count_Proxy( 
    IControls * This,
    /* [retval][out] */ long *plCount);


void __RPC_STUB IControls_get_Count_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IControls_get_Item_Proxy( 
    IControls * This,
    /* [in] */ long Index,
    /* [retval][out] */ IDispatch **ppDisp);


void __RPC_STUB IControls_get_Item_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [hidden][id] */ HRESULT STDMETHODCALLTYPE IControls__NewEnum_Proxy( 
    IControls * This,
    /* [retval][out] */ IUnknown **ppUnk);


void __RPC_STUB IControls__NewEnum_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IControls_INTERFACE_DEFINED__ */


#ifndef __IComboItem_INTERFACE_DEFINED__
#define __IComboItem_INTERFACE_DEFINED__

/* interface IComboItem */
/* [object][oleautomation][nonextensible][dual][hidden][helpcontext][helpstring][uuid] */ 


EXTERN_C const IID IID_IComboItem;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("DD9DA660-8594-11D1-B16A-00C0F0283628")
    IComboItem : public IDispatch
    {
    public:
        virtual /* [hidden][propget][id] */ HRESULT STDMETHODCALLTYPE get__ObjectDefault( 
            /* [retval][out] */ BSTR *pbstrText) = 0;
        
        virtual /* [hidden][propput][id] */ HRESULT STDMETHODCALLTYPE put__ObjectDefault( 
            /* [in] */ BSTR pbstrText) = 0;
        
        virtual /* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_Image( 
            /* [retval][out] */ VARIANT *pvImage) = 0;
        
        virtual /* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_Image( 
            /* [in] */ VARIANT pvImage) = 0;
        
        virtual /* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_Indentation( 
            /* [retval][out] */ short *psIndent) = 0;
        
        virtual /* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_Indentation( 
            /* [in] */ short psIndent) = 0;
        
        virtual /* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_Index( 
            /* [retval][out] */ long *plIndex) = 0;
        
        virtual /* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_Index( 
            /* [in] */ long plIndex) = 0;
        
        virtual /* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_Key( 
            /* [retval][out] */ BSTR *pbstrKey) = 0;
        
        virtual /* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_Key( 
            /* [in] */ BSTR pbstrKey) = 0;
        
        virtual /* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_Selected( 
            /* [retval][out] */ VARIANT_BOOL *pbSelected) = 0;
        
        virtual /* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_Selected( 
            /* [in] */ VARIANT_BOOL pbSelected) = 0;
        
        virtual /* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_SelImage( 
            /* [retval][out] */ VARIANT *pvImage) = 0;
        
        virtual /* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_SelImage( 
            /* [in] */ VARIANT pvImage) = 0;
        
        virtual /* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_Tag( 
            /* [retval][out] */ VARIANT *pvTag) = 0;
        
        virtual /* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_Tag( 
            /* [in] */ VARIANT pvTag) = 0;
        
        virtual /* [helpcontext][helpstring][propputref][id] */ HRESULT STDMETHODCALLTYPE putref_Tag( 
            /* [in] */ VARIANT pvTag) = 0;
        
        virtual /* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_Text( 
            /* [retval][out] */ BSTR *pbstrText) = 0;
        
        virtual /* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_Text( 
            /* [in] */ BSTR pbstrText) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IComboItemVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IComboItem * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IComboItem * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IComboItem * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IComboItem * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IComboItem * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IComboItem * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IComboItem * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [hidden][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get__ObjectDefault )( 
            IComboItem * This,
            /* [retval][out] */ BSTR *pbstrText);
        
        /* [hidden][propput][id] */ HRESULT ( STDMETHODCALLTYPE *put__ObjectDefault )( 
            IComboItem * This,
            /* [in] */ BSTR pbstrText);
        
        /* [helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_Image )( 
            IComboItem * This,
            /* [retval][out] */ VARIANT *pvImage);
        
        /* [helpcontext][helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_Image )( 
            IComboItem * This,
            /* [in] */ VARIANT pvImage);
        
        /* [helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_Indentation )( 
            IComboItem * This,
            /* [retval][out] */ short *psIndent);
        
        /* [helpcontext][helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_Indentation )( 
            IComboItem * This,
            /* [in] */ short psIndent);
        
        /* [helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_Index )( 
            IComboItem * This,
            /* [retval][out] */ long *plIndex);
        
        /* [helpcontext][helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_Index )( 
            IComboItem * This,
            /* [in] */ long plIndex);
        
        /* [helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_Key )( 
            IComboItem * This,
            /* [retval][out] */ BSTR *pbstrKey);
        
        /* [helpcontext][helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_Key )( 
            IComboItem * This,
            /* [in] */ BSTR pbstrKey);
        
        /* [helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_Selected )( 
            IComboItem * This,
            /* [retval][out] */ VARIANT_BOOL *pbSelected);
        
        /* [helpcontext][helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_Selected )( 
            IComboItem * This,
            /* [in] */ VARIANT_BOOL pbSelected);
        
        /* [helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_SelImage )( 
            IComboItem * This,
            /* [retval][out] */ VARIANT *pvImage);
        
        /* [helpcontext][helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_SelImage )( 
            IComboItem * This,
            /* [in] */ VARIANT pvImage);
        
        /* [helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_Tag )( 
            IComboItem * This,
            /* [retval][out] */ VARIANT *pvTag);
        
        /* [helpcontext][helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_Tag )( 
            IComboItem * This,
            /* [in] */ VARIANT pvTag);
        
        /* [helpcontext][helpstring][propputref][id] */ HRESULT ( STDMETHODCALLTYPE *putref_Tag )( 
            IComboItem * This,
            /* [in] */ VARIANT pvTag);
        
        /* [helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_Text )( 
            IComboItem * This,
            /* [retval][out] */ BSTR *pbstrText);
        
        /* [helpcontext][helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_Text )( 
            IComboItem * This,
            /* [in] */ BSTR pbstrText);
        
        END_INTERFACE
    } IComboItemVtbl;

    interface IComboItem
    {
        CONST_VTBL struct IComboItemVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IComboItem_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IComboItem_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IComboItem_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IComboItem_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IComboItem_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IComboItem_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IComboItem_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IComboItem_get__ObjectDefault(This,pbstrText)	\
    (This)->lpVtbl -> get__ObjectDefault(This,pbstrText)

#define IComboItem_put__ObjectDefault(This,pbstrText)	\
    (This)->lpVtbl -> put__ObjectDefault(This,pbstrText)

#define IComboItem_get_Image(This,pvImage)	\
    (This)->lpVtbl -> get_Image(This,pvImage)

#define IComboItem_put_Image(This,pvImage)	\
    (This)->lpVtbl -> put_Image(This,pvImage)

#define IComboItem_get_Indentation(This,psIndent)	\
    (This)->lpVtbl -> get_Indentation(This,psIndent)

#define IComboItem_put_Indentation(This,psIndent)	\
    (This)->lpVtbl -> put_Indentation(This,psIndent)

#define IComboItem_get_Index(This,plIndex)	\
    (This)->lpVtbl -> get_Index(This,plIndex)

#define IComboItem_put_Index(This,plIndex)	\
    (This)->lpVtbl -> put_Index(This,plIndex)

#define IComboItem_get_Key(This,pbstrKey)	\
    (This)->lpVtbl -> get_Key(This,pbstrKey)

#define IComboItem_put_Key(This,pbstrKey)	\
    (This)->lpVtbl -> put_Key(This,pbstrKey)

#define IComboItem_get_Selected(This,pbSelected)	\
    (This)->lpVtbl -> get_Selected(This,pbSelected)

#define IComboItem_put_Selected(This,pbSelected)	\
    (This)->lpVtbl -> put_Selected(This,pbSelected)

#define IComboItem_get_SelImage(This,pvImage)	\
    (This)->lpVtbl -> get_SelImage(This,pvImage)

#define IComboItem_put_SelImage(This,pvImage)	\
    (This)->lpVtbl -> put_SelImage(This,pvImage)

#define IComboItem_get_Tag(This,pvTag)	\
    (This)->lpVtbl -> get_Tag(This,pvTag)

#define IComboItem_put_Tag(This,pvTag)	\
    (This)->lpVtbl -> put_Tag(This,pvTag)

#define IComboItem_putref_Tag(This,pvTag)	\
    (This)->lpVtbl -> putref_Tag(This,pvTag)

#define IComboItem_get_Text(This,pbstrText)	\
    (This)->lpVtbl -> get_Text(This,pbstrText)

#define IComboItem_put_Text(This,pbstrText)	\
    (This)->lpVtbl -> put_Text(This,pbstrText)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [hidden][propget][id] */ HRESULT STDMETHODCALLTYPE IComboItem_get__ObjectDefault_Proxy( 
    IComboItem * This,
    /* [retval][out] */ BSTR *pbstrText);


void __RPC_STUB IComboItem_get__ObjectDefault_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [hidden][propput][id] */ HRESULT STDMETHODCALLTYPE IComboItem_put__ObjectDefault_Proxy( 
    IComboItem * This,
    /* [in] */ BSTR pbstrText);


void __RPC_STUB IComboItem_put__ObjectDefault_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IComboItem_get_Image_Proxy( 
    IComboItem * This,
    /* [retval][out] */ VARIANT *pvImage);


void __RPC_STUB IComboItem_get_Image_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE IComboItem_put_Image_Proxy( 
    IComboItem * This,
    /* [in] */ VARIANT pvImage);


void __RPC_STUB IComboItem_put_Image_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IComboItem_get_Indentation_Proxy( 
    IComboItem * This,
    /* [retval][out] */ short *psIndent);


void __RPC_STUB IComboItem_get_Indentation_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE IComboItem_put_Indentation_Proxy( 
    IComboItem * This,
    /* [in] */ short psIndent);


void __RPC_STUB IComboItem_put_Indentation_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IComboItem_get_Index_Proxy( 
    IComboItem * This,
    /* [retval][out] */ long *plIndex);


void __RPC_STUB IComboItem_get_Index_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE IComboItem_put_Index_Proxy( 
    IComboItem * This,
    /* [in] */ long plIndex);


void __RPC_STUB IComboItem_put_Index_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IComboItem_get_Key_Proxy( 
    IComboItem * This,
    /* [retval][out] */ BSTR *pbstrKey);


void __RPC_STUB IComboItem_get_Key_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE IComboItem_put_Key_Proxy( 
    IComboItem * This,
    /* [in] */ BSTR pbstrKey);


void __RPC_STUB IComboItem_put_Key_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IComboItem_get_Selected_Proxy( 
    IComboItem * This,
    /* [retval][out] */ VARIANT_BOOL *pbSelected);


void __RPC_STUB IComboItem_get_Selected_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE IComboItem_put_Selected_Proxy( 
    IComboItem * This,
    /* [in] */ VARIANT_BOOL pbSelected);


void __RPC_STUB IComboItem_put_Selected_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IComboItem_get_SelImage_Proxy( 
    IComboItem * This,
    /* [retval][out] */ VARIANT *pvImage);


void __RPC_STUB IComboItem_get_SelImage_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE IComboItem_put_SelImage_Proxy( 
    IComboItem * This,
    /* [in] */ VARIANT pvImage);


void __RPC_STUB IComboItem_put_SelImage_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IComboItem_get_Tag_Proxy( 
    IComboItem * This,
    /* [retval][out] */ VARIANT *pvTag);


void __RPC_STUB IComboItem_get_Tag_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE IComboItem_put_Tag_Proxy( 
    IComboItem * This,
    /* [in] */ VARIANT pvTag);


void __RPC_STUB IComboItem_put_Tag_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propputref][id] */ HRESULT STDMETHODCALLTYPE IComboItem_putref_Tag_Proxy( 
    IComboItem * This,
    /* [in] */ VARIANT pvTag);


void __RPC_STUB IComboItem_putref_Tag_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IComboItem_get_Text_Proxy( 
    IComboItem * This,
    /* [retval][out] */ BSTR *pbstrText);


void __RPC_STUB IComboItem_get_Text_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE IComboItem_put_Text_Proxy( 
    IComboItem * This,
    /* [in] */ BSTR pbstrText);


void __RPC_STUB IComboItem_put_Text_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IComboItem_INTERFACE_DEFINED__ */


#ifndef __IComboItems_INTERFACE_DEFINED__
#define __IComboItems_INTERFACE_DEFINED__

/* interface IComboItems */
/* [object][oleautomation][nonextensible][dual][hidden][helpcontext][helpstring][uuid] */ 


EXTERN_C const IID IID_IComboItems;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("DD9DA662-8594-11D1-B16A-00C0F0283628")
    IComboItems : public IDispatch
    {
    public:
        virtual /* [hidden][propget][id] */ HRESULT STDMETHODCALLTYPE get__CollectionDefault( 
            /* [in] */ VARIANT *Index,
            /* [retval][out] */ IComboItem **ppComboItem) = 0;
        
        virtual /* [hidden][propput][id] */ HRESULT STDMETHODCALLTYPE put__CollectionDefault( 
            /* [in] */ VARIANT *Index,
            /* [in] */ IComboItem *ppComboItem) = 0;
        
        virtual /* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_Count( 
            /* [retval][out] */ long *plCount) = 0;
        
        virtual /* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_Count( 
            /* [in] */ long plCount) = 0;
        
        virtual /* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_Item( 
            /* [in] */ VARIANT *Index,
            /* [retval][out] */ IComboItem **ppComboItem) = 0;
        
        virtual /* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_Item( 
            /* [in] */ VARIANT *Index,
            /* [in] */ IComboItem *ppComboItem) = 0;
        
        virtual /* [helpcontext][helpstring][id] */ HRESULT STDMETHODCALLTYPE Add( 
            /* [optional][in] */ VARIANT *Index,
            /* [optional][in] */ VARIANT *Key,
            /* [optional][in] */ VARIANT *Text,
            /* [optional][in] */ VARIANT *Image,
            /* [optional][in] */ VARIANT *SelImage,
            /* [optional][in] */ VARIANT *Indentation,
            /* [retval][out] */ IComboItem **ppComboItem) = 0;
        
        virtual /* [helpcontext][helpstring][id] */ HRESULT STDMETHODCALLTYPE Clear( void) = 0;
        
        virtual /* [helpcontext][helpstring][id] */ HRESULT STDMETHODCALLTYPE Remove( 
            /* [in] */ VARIANT *Index) = 0;
        
        virtual /* [hidden][id] */ HRESULT STDMETHODCALLTYPE _NewEnum( 
            /* [retval][out] */ IDispatch **ppNewEnum) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IComboItemsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IComboItems * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IComboItems * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IComboItems * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IComboItems * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IComboItems * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IComboItems * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IComboItems * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [hidden][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get__CollectionDefault )( 
            IComboItems * This,
            /* [in] */ VARIANT *Index,
            /* [retval][out] */ IComboItem **ppComboItem);
        
        /* [hidden][propput][id] */ HRESULT ( STDMETHODCALLTYPE *put__CollectionDefault )( 
            IComboItems * This,
            /* [in] */ VARIANT *Index,
            /* [in] */ IComboItem *ppComboItem);
        
        /* [helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_Count )( 
            IComboItems * This,
            /* [retval][out] */ long *plCount);
        
        /* [helpcontext][helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_Count )( 
            IComboItems * This,
            /* [in] */ long plCount);
        
        /* [helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_Item )( 
            IComboItems * This,
            /* [in] */ VARIANT *Index,
            /* [retval][out] */ IComboItem **ppComboItem);
        
        /* [helpcontext][helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_Item )( 
            IComboItems * This,
            /* [in] */ VARIANT *Index,
            /* [in] */ IComboItem *ppComboItem);
        
        /* [helpcontext][helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Add )( 
            IComboItems * This,
            /* [optional][in] */ VARIANT *Index,
            /* [optional][in] */ VARIANT *Key,
            /* [optional][in] */ VARIANT *Text,
            /* [optional][in] */ VARIANT *Image,
            /* [optional][in] */ VARIANT *SelImage,
            /* [optional][in] */ VARIANT *Indentation,
            /* [retval][out] */ IComboItem **ppComboItem);
        
        /* [helpcontext][helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Clear )( 
            IComboItems * This);
        
        /* [helpcontext][helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Remove )( 
            IComboItems * This,
            /* [in] */ VARIANT *Index);
        
        /* [hidden][id] */ HRESULT ( STDMETHODCALLTYPE *_NewEnum )( 
            IComboItems * This,
            /* [retval][out] */ IDispatch **ppNewEnum);
        
        END_INTERFACE
    } IComboItemsVtbl;

    interface IComboItems
    {
        CONST_VTBL struct IComboItemsVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IComboItems_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IComboItems_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IComboItems_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IComboItems_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IComboItems_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IComboItems_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IComboItems_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IComboItems_get__CollectionDefault(This,Index,ppComboItem)	\
    (This)->lpVtbl -> get__CollectionDefault(This,Index,ppComboItem)

#define IComboItems_put__CollectionDefault(This,Index,ppComboItem)	\
    (This)->lpVtbl -> put__CollectionDefault(This,Index,ppComboItem)

#define IComboItems_get_Count(This,plCount)	\
    (This)->lpVtbl -> get_Count(This,plCount)

#define IComboItems_put_Count(This,plCount)	\
    (This)->lpVtbl -> put_Count(This,plCount)

#define IComboItems_get_Item(This,Index,ppComboItem)	\
    (This)->lpVtbl -> get_Item(This,Index,ppComboItem)

#define IComboItems_put_Item(This,Index,ppComboItem)	\
    (This)->lpVtbl -> put_Item(This,Index,ppComboItem)

#define IComboItems_Add(This,Index,Key,Text,Image,SelImage,Indentation,ppComboItem)	\
    (This)->lpVtbl -> Add(This,Index,Key,Text,Image,SelImage,Indentation,ppComboItem)

#define IComboItems_Clear(This)	\
    (This)->lpVtbl -> Clear(This)

#define IComboItems_Remove(This,Index)	\
    (This)->lpVtbl -> Remove(This,Index)

#define IComboItems__NewEnum(This,ppNewEnum)	\
    (This)->lpVtbl -> _NewEnum(This,ppNewEnum)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [hidden][propget][id] */ HRESULT STDMETHODCALLTYPE IComboItems_get__CollectionDefault_Proxy( 
    IComboItems * This,
    /* [in] */ VARIANT *Index,
    /* [retval][out] */ IComboItem **ppComboItem);


void __RPC_STUB IComboItems_get__CollectionDefault_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [hidden][propput][id] */ HRESULT STDMETHODCALLTYPE IComboItems_put__CollectionDefault_Proxy( 
    IComboItems * This,
    /* [in] */ VARIANT *Index,
    /* [in] */ IComboItem *ppComboItem);


void __RPC_STUB IComboItems_put__CollectionDefault_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IComboItems_get_Count_Proxy( 
    IComboItems * This,
    /* [retval][out] */ long *plCount);


void __RPC_STUB IComboItems_get_Count_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE IComboItems_put_Count_Proxy( 
    IComboItems * This,
    /* [in] */ long plCount);


void __RPC_STUB IComboItems_put_Count_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IComboItems_get_Item_Proxy( 
    IComboItems * This,
    /* [in] */ VARIANT *Index,
    /* [retval][out] */ IComboItem **ppComboItem);


void __RPC_STUB IComboItems_get_Item_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE IComboItems_put_Item_Proxy( 
    IComboItems * This,
    /* [in] */ VARIANT *Index,
    /* [in] */ IComboItem *ppComboItem);


void __RPC_STUB IComboItems_put_Item_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][id] */ HRESULT STDMETHODCALLTYPE IComboItems_Add_Proxy( 
    IComboItems * This,
    /* [optional][in] */ VARIANT *Index,
    /* [optional][in] */ VARIANT *Key,
    /* [optional][in] */ VARIANT *Text,
    /* [optional][in] */ VARIANT *Image,
    /* [optional][in] */ VARIANT *SelImage,
    /* [optional][in] */ VARIANT *Indentation,
    /* [retval][out] */ IComboItem **ppComboItem);


void __RPC_STUB IComboItems_Add_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][id] */ HRESULT STDMETHODCALLTYPE IComboItems_Clear_Proxy( 
    IComboItems * This);


void __RPC_STUB IComboItems_Clear_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][id] */ HRESULT STDMETHODCALLTYPE IComboItems_Remove_Proxy( 
    IComboItems * This,
    /* [in] */ VARIANT *Index);


void __RPC_STUB IComboItems_Remove_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [hidden][id] */ HRESULT STDMETHODCALLTYPE IComboItems__NewEnum_Proxy( 
    IComboItems * This,
    /* [retval][out] */ IDispatch **ppNewEnum);


void __RPC_STUB IComboItems__NewEnum_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IComboItems_INTERFACE_DEFINED__ */


#ifndef __IImageCombo_INTERFACE_DEFINED__
#define __IImageCombo_INTERFACE_DEFINED__

/* interface IImageCombo */
/* [object][oleautomation][nonextensible][dual][hidden][helpcontext][helpstring][uuid] */ 


EXTERN_C const IID IID_IImageCombo;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("DD9DA664-8594-11D1-B16A-00C0F0283628")
    IImageCombo : public IDispatch
    {
    public:
        virtual /* [helpcontext][helpstring][defaultbind][displaybind][requestedit][bindable][propget][id] */ HRESULT STDMETHODCALLTYPE get_Text( 
            /* [retval][out] */ BSTR *pbstrText) = 0;
        
        virtual /* [helpcontext][helpstring][defaultbind][displaybind][requestedit][bindable][propput][id] */ HRESULT STDMETHODCALLTYPE put_Text( 
            /* [in] */ BSTR pbstrText) = 0;
        
        virtual /* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_BackColor( 
            /* [retval][out] */ /* external definition not present */ OLE_COLOR *pocBackColor) = 0;
        
        virtual /* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_BackColor( 
            /* [in] */ /* external definition not present */ OLE_COLOR pocBackColor) = 0;
        
        virtual /* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_Enabled( 
            /* [retval][out] */ VARIANT_BOOL *pbEnabled) = 0;
        
        virtual /* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_Enabled( 
            /* [in] */ VARIANT_BOOL pbEnabled) = 0;
        
        virtual /* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_Font( 
            /* [retval][out] */ /* external definition not present */ IFontDisp **ppFont) = 0;
        
        virtual /* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_Font( 
            /* [in] */ /* external definition not present */ IFontDisp *ppFont) = 0;
        
        virtual /* [helpcontext][helpstring][propputref][id] */ HRESULT STDMETHODCALLTYPE putref_Font( 
            /* [in] */ /* external definition not present */ IFontDisp *ppFont) = 0;
        
        virtual /* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_ForeColor( 
            /* [retval][out] */ /* external definition not present */ OLE_COLOR *pocForeColor) = 0;
        
        virtual /* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_ForeColor( 
            /* [in] */ /* external definition not present */ OLE_COLOR pocForeColor) = 0;
        
        virtual /* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_hWnd( 
            /* [retval][out] */ /* external definition not present */ OLE_HANDLE *phWnd) = 0;
        
        virtual /* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_hWnd( 
            /* [in] */ /* external definition not present */ OLE_HANDLE phWnd) = 0;
        
        virtual /* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_ImageList( 
            /* [retval][out] */ IDispatch **ppImageList) = 0;
        
        virtual /* [helpcontext][helpstring][propputref][id] */ HRESULT STDMETHODCALLTYPE putref_ImageList( 
            /* [in] */ IDispatch *ppImageList) = 0;
        
        virtual /* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_ImageList( 
            /* [in] */ IDispatch *ppImageList) = 0;
        
        virtual /* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_Indentation( 
            /* [retval][out] */ short *psIndent) = 0;
        
        virtual /* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_Indentation( 
            /* [in] */ short psIndent) = 0;
        
        virtual /* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_ComboItems( 
            /* [retval][out] */ IComboItems **ppComboItems) = 0;
        
        virtual /* [helpcontext][helpstring][propputref][id] */ HRESULT STDMETHODCALLTYPE putref_ComboItems( 
            /* [in] */ IComboItems *ppComboItems) = 0;
        
        virtual /* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_Locked( 
            /* [retval][out] */ VARIANT_BOOL *pbLocked) = 0;
        
        virtual /* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_Locked( 
            /* [in] */ VARIANT_BOOL pbLocked) = 0;
        
        virtual /* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_MouseIcon( 
            /* [retval][out] */ /* external definition not present */ IPictureDisp **ppMouseIcon) = 0;
        
        virtual /* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_MouseIcon( 
            /* [in] */ /* external definition not present */ IPictureDisp *ppMouseIcon) = 0;
        
        virtual /* [helpcontext][helpstring][propputref][id] */ HRESULT STDMETHODCALLTYPE putref_MouseIcon( 
            /* [in] */ /* external definition not present */ IPictureDisp *ppMouseIcon) = 0;
        
        virtual /* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_MousePointer( 
            /* [retval][out] */ MousePointerConstants *penumMousePointer) = 0;
        
        virtual /* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_MousePointer( 
            /* [in] */ MousePointerConstants penumMousePointer) = 0;
        
        virtual /* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_OLEDragMode( 
            /* [retval][out] */ OLEDragConstants *psOLEDragMode) = 0;
        
        virtual /* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_OLEDragMode( 
            /* [in] */ OLEDragConstants psOLEDragMode) = 0;
        
        virtual /* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_OLEDropMode( 
            /* [retval][out] */ OLEDropConstants *psOLEDropMode) = 0;
        
        virtual /* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_OLEDropMode( 
            /* [in] */ OLEDropConstants psOLEDropMode) = 0;
        
        virtual /* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_SelectedItem( 
            /* [retval][out] */ IComboItem **ppIComboItem) = 0;
        
        virtual /* [helpcontext][helpstring][propputref][id] */ HRESULT STDMETHODCALLTYPE putref_SelectedItem( 
            /* [in] */ IComboItem *ppIComboItem) = 0;
        
        virtual /* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_SelectedItem( 
            /* [in] */ VARIANT *ppIComboItem) = 0;
        
        virtual /* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_SelLength( 
            /* [retval][out] */ long *plSelLength) = 0;
        
        virtual /* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_SelLength( 
            /* [in] */ long plSelLength) = 0;
        
        virtual /* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_SelStart( 
            /* [retval][out] */ long *plSelStart) = 0;
        
        virtual /* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_SelStart( 
            /* [in] */ long plSelStart) = 0;
        
        virtual /* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_SelText( 
            /* [retval][out] */ BSTR *pbstrText) = 0;
        
        virtual /* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_SelText( 
            /* [in] */ BSTR pbstrText) = 0;
        
        virtual /* [helpcontext][helpstring][hidden][restricted][propget][id] */ HRESULT STDMETHODCALLTYPE get_Style( 
            /* [retval][out] */ ImageComboStyleConstants *penumStyle) = 0;
        
        virtual /* [helpcontext][helpstring][hidden][restricted][propput][id] */ HRESULT STDMETHODCALLTYPE put_Style( 
            /* [in] */ ImageComboStyleConstants penumStyle) = 0;
        
        virtual /* [helpcontext][helpstring][hidden][restricted][propget][id] */ HRESULT STDMETHODCALLTYPE get_UsePathSep( 
            /* [retval][out] */ VARIANT_BOOL *pbUsePathSep) = 0;
        
        virtual /* [helpcontext][helpstring][hidden][restricted][propput][id] */ HRESULT STDMETHODCALLTYPE put_UsePathSep( 
            /* [in] */ VARIANT_BOOL pbUsePathSep) = 0;
        
        virtual /* [hidden][id] */ HRESULT STDMETHODCALLTYPE AboutBox( void) = 0;
        
        virtual /* [helpcontext][helpstring][id] */ HRESULT STDMETHODCALLTYPE GetFirstVisible( 
            /* [retval][out] */ IComboItem **ppIComboItem) = 0;
        
        virtual /* [helpcontext][helpstring][id] */ HRESULT STDMETHODCALLTYPE Refresh( void) = 0;
        
        virtual /* [helpcontext][helpstring][id] */ HRESULT STDMETHODCALLTYPE OLEDrag( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IImageComboVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IImageCombo * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IImageCombo * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IImageCombo * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IImageCombo * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IImageCombo * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IImageCombo * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IImageCombo * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpcontext][helpstring][defaultbind][displaybind][requestedit][bindable][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_Text )( 
            IImageCombo * This,
            /* [retval][out] */ BSTR *pbstrText);
        
        /* [helpcontext][helpstring][defaultbind][displaybind][requestedit][bindable][propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_Text )( 
            IImageCombo * This,
            /* [in] */ BSTR pbstrText);
        
        /* [helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_BackColor )( 
            IImageCombo * This,
            /* [retval][out] */ /* external definition not present */ OLE_COLOR *pocBackColor);
        
        /* [helpcontext][helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_BackColor )( 
            IImageCombo * This,
            /* [in] */ /* external definition not present */ OLE_COLOR pocBackColor);
        
        /* [helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_Enabled )( 
            IImageCombo * This,
            /* [retval][out] */ VARIANT_BOOL *pbEnabled);
        
        /* [helpcontext][helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_Enabled )( 
            IImageCombo * This,
            /* [in] */ VARIANT_BOOL pbEnabled);
        
        /* [helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_Font )( 
            IImageCombo * This,
            /* [retval][out] */ /* external definition not present */ IFontDisp **ppFont);
        
        /* [helpcontext][helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_Font )( 
            IImageCombo * This,
            /* [in] */ /* external definition not present */ IFontDisp *ppFont);
        
        /* [helpcontext][helpstring][propputref][id] */ HRESULT ( STDMETHODCALLTYPE *putref_Font )( 
            IImageCombo * This,
            /* [in] */ /* external definition not present */ IFontDisp *ppFont);
        
        /* [helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_ForeColor )( 
            IImageCombo * This,
            /* [retval][out] */ /* external definition not present */ OLE_COLOR *pocForeColor);
        
        /* [helpcontext][helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_ForeColor )( 
            IImageCombo * This,
            /* [in] */ /* external definition not present */ OLE_COLOR pocForeColor);
        
        /* [helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_hWnd )( 
            IImageCombo * This,
            /* [retval][out] */ /* external definition not present */ OLE_HANDLE *phWnd);
        
        /* [helpcontext][helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_hWnd )( 
            IImageCombo * This,
            /* [in] */ /* external definition not present */ OLE_HANDLE phWnd);
        
        /* [helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_ImageList )( 
            IImageCombo * This,
            /* [retval][out] */ IDispatch **ppImageList);
        
        /* [helpcontext][helpstring][propputref][id] */ HRESULT ( STDMETHODCALLTYPE *putref_ImageList )( 
            IImageCombo * This,
            /* [in] */ IDispatch *ppImageList);
        
        /* [helpcontext][helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_ImageList )( 
            IImageCombo * This,
            /* [in] */ IDispatch *ppImageList);
        
        /* [helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_Indentation )( 
            IImageCombo * This,
            /* [retval][out] */ short *psIndent);
        
        /* [helpcontext][helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_Indentation )( 
            IImageCombo * This,
            /* [in] */ short psIndent);
        
        /* [helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_ComboItems )( 
            IImageCombo * This,
            /* [retval][out] */ IComboItems **ppComboItems);
        
        /* [helpcontext][helpstring][propputref][id] */ HRESULT ( STDMETHODCALLTYPE *putref_ComboItems )( 
            IImageCombo * This,
            /* [in] */ IComboItems *ppComboItems);
        
        /* [helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_Locked )( 
            IImageCombo * This,
            /* [retval][out] */ VARIANT_BOOL *pbLocked);
        
        /* [helpcontext][helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_Locked )( 
            IImageCombo * This,
            /* [in] */ VARIANT_BOOL pbLocked);
        
        /* [helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_MouseIcon )( 
            IImageCombo * This,
            /* [retval][out] */ /* external definition not present */ IPictureDisp **ppMouseIcon);
        
        /* [helpcontext][helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_MouseIcon )( 
            IImageCombo * This,
            /* [in] */ /* external definition not present */ IPictureDisp *ppMouseIcon);
        
        /* [helpcontext][helpstring][propputref][id] */ HRESULT ( STDMETHODCALLTYPE *putref_MouseIcon )( 
            IImageCombo * This,
            /* [in] */ /* external definition not present */ IPictureDisp *ppMouseIcon);
        
        /* [helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_MousePointer )( 
            IImageCombo * This,
            /* [retval][out] */ MousePointerConstants *penumMousePointer);
        
        /* [helpcontext][helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_MousePointer )( 
            IImageCombo * This,
            /* [in] */ MousePointerConstants penumMousePointer);
        
        /* [helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_OLEDragMode )( 
            IImageCombo * This,
            /* [retval][out] */ OLEDragConstants *psOLEDragMode);
        
        /* [helpcontext][helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_OLEDragMode )( 
            IImageCombo * This,
            /* [in] */ OLEDragConstants psOLEDragMode);
        
        /* [helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_OLEDropMode )( 
            IImageCombo * This,
            /* [retval][out] */ OLEDropConstants *psOLEDropMode);
        
        /* [helpcontext][helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_OLEDropMode )( 
            IImageCombo * This,
            /* [in] */ OLEDropConstants psOLEDropMode);
        
        /* [helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_SelectedItem )( 
            IImageCombo * This,
            /* [retval][out] */ IComboItem **ppIComboItem);
        
        /* [helpcontext][helpstring][propputref][id] */ HRESULT ( STDMETHODCALLTYPE *putref_SelectedItem )( 
            IImageCombo * This,
            /* [in] */ IComboItem *ppIComboItem);
        
        /* [helpcontext][helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_SelectedItem )( 
            IImageCombo * This,
            /* [in] */ VARIANT *ppIComboItem);
        
        /* [helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_SelLength )( 
            IImageCombo * This,
            /* [retval][out] */ long *plSelLength);
        
        /* [helpcontext][helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_SelLength )( 
            IImageCombo * This,
            /* [in] */ long plSelLength);
        
        /* [helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_SelStart )( 
            IImageCombo * This,
            /* [retval][out] */ long *plSelStart);
        
        /* [helpcontext][helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_SelStart )( 
            IImageCombo * This,
            /* [in] */ long plSelStart);
        
        /* [helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_SelText )( 
            IImageCombo * This,
            /* [retval][out] */ BSTR *pbstrText);
        
        /* [helpcontext][helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_SelText )( 
            IImageCombo * This,
            /* [in] */ BSTR pbstrText);
        
        /* [helpcontext][helpstring][hidden][restricted][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_Style )( 
            IImageCombo * This,
            /* [retval][out] */ ImageComboStyleConstants *penumStyle);
        
        /* [helpcontext][helpstring][hidden][restricted][propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_Style )( 
            IImageCombo * This,
            /* [in] */ ImageComboStyleConstants penumStyle);
        
        /* [helpcontext][helpstring][hidden][restricted][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_UsePathSep )( 
            IImageCombo * This,
            /* [retval][out] */ VARIANT_BOOL *pbUsePathSep);
        
        /* [helpcontext][helpstring][hidden][restricted][propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_UsePathSep )( 
            IImageCombo * This,
            /* [in] */ VARIANT_BOOL pbUsePathSep);
        
        /* [hidden][id] */ HRESULT ( STDMETHODCALLTYPE *AboutBox )( 
            IImageCombo * This);
        
        /* [helpcontext][helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *GetFirstVisible )( 
            IImageCombo * This,
            /* [retval][out] */ IComboItem **ppIComboItem);
        
        /* [helpcontext][helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Refresh )( 
            IImageCombo * This);
        
        /* [helpcontext][helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *OLEDrag )( 
            IImageCombo * This);
        
        END_INTERFACE
    } IImageComboVtbl;

    interface IImageCombo
    {
        CONST_VTBL struct IImageComboVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IImageCombo_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IImageCombo_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IImageCombo_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IImageCombo_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IImageCombo_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IImageCombo_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IImageCombo_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IImageCombo_get_Text(This,pbstrText)	\
    (This)->lpVtbl -> get_Text(This,pbstrText)

#define IImageCombo_put_Text(This,pbstrText)	\
    (This)->lpVtbl -> put_Text(This,pbstrText)

#define IImageCombo_get_BackColor(This,pocBackColor)	\
    (This)->lpVtbl -> get_BackColor(This,pocBackColor)

#define IImageCombo_put_BackColor(This,pocBackColor)	\
    (This)->lpVtbl -> put_BackColor(This,pocBackColor)

#define IImageCombo_get_Enabled(This,pbEnabled)	\
    (This)->lpVtbl -> get_Enabled(This,pbEnabled)

#define IImageCombo_put_Enabled(This,pbEnabled)	\
    (This)->lpVtbl -> put_Enabled(This,pbEnabled)

#define IImageCombo_get_Font(This,ppFont)	\
    (This)->lpVtbl -> get_Font(This,ppFont)

#define IImageCombo_put_Font(This,ppFont)	\
    (This)->lpVtbl -> put_Font(This,ppFont)

#define IImageCombo_putref_Font(This,ppFont)	\
    (This)->lpVtbl -> putref_Font(This,ppFont)

#define IImageCombo_get_ForeColor(This,pocForeColor)	\
    (This)->lpVtbl -> get_ForeColor(This,pocForeColor)

#define IImageCombo_put_ForeColor(This,pocForeColor)	\
    (This)->lpVtbl -> put_ForeColor(This,pocForeColor)

#define IImageCombo_get_hWnd(This,phWnd)	\
    (This)->lpVtbl -> get_hWnd(This,phWnd)

#define IImageCombo_put_hWnd(This,phWnd)	\
    (This)->lpVtbl -> put_hWnd(This,phWnd)

#define IImageCombo_get_ImageList(This,ppImageList)	\
    (This)->lpVtbl -> get_ImageList(This,ppImageList)

#define IImageCombo_putref_ImageList(This,ppImageList)	\
    (This)->lpVtbl -> putref_ImageList(This,ppImageList)

#define IImageCombo_put_ImageList(This,ppImageList)	\
    (This)->lpVtbl -> put_ImageList(This,ppImageList)

#define IImageCombo_get_Indentation(This,psIndent)	\
    (This)->lpVtbl -> get_Indentation(This,psIndent)

#define IImageCombo_put_Indentation(This,psIndent)	\
    (This)->lpVtbl -> put_Indentation(This,psIndent)

#define IImageCombo_get_ComboItems(This,ppComboItems)	\
    (This)->lpVtbl -> get_ComboItems(This,ppComboItems)

#define IImageCombo_putref_ComboItems(This,ppComboItems)	\
    (This)->lpVtbl -> putref_ComboItems(This,ppComboItems)

#define IImageCombo_get_Locked(This,pbLocked)	\
    (This)->lpVtbl -> get_Locked(This,pbLocked)

#define IImageCombo_put_Locked(This,pbLocked)	\
    (This)->lpVtbl -> put_Locked(This,pbLocked)

#define IImageCombo_get_MouseIcon(This,ppMouseIcon)	\
    (This)->lpVtbl -> get_MouseIcon(This,ppMouseIcon)

#define IImageCombo_put_MouseIcon(This,ppMouseIcon)	\
    (This)->lpVtbl -> put_MouseIcon(This,ppMouseIcon)

#define IImageCombo_putref_MouseIcon(This,ppMouseIcon)	\
    (This)->lpVtbl -> putref_MouseIcon(This,ppMouseIcon)

#define IImageCombo_get_MousePointer(This,penumMousePointer)	\
    (This)->lpVtbl -> get_MousePointer(This,penumMousePointer)

#define IImageCombo_put_MousePointer(This,penumMousePointer)	\
    (This)->lpVtbl -> put_MousePointer(This,penumMousePointer)

#define IImageCombo_get_OLEDragMode(This,psOLEDragMode)	\
    (This)->lpVtbl -> get_OLEDragMode(This,psOLEDragMode)

#define IImageCombo_put_OLEDragMode(This,psOLEDragMode)	\
    (This)->lpVtbl -> put_OLEDragMode(This,psOLEDragMode)

#define IImageCombo_get_OLEDropMode(This,psOLEDropMode)	\
    (This)->lpVtbl -> get_OLEDropMode(This,psOLEDropMode)

#define IImageCombo_put_OLEDropMode(This,psOLEDropMode)	\
    (This)->lpVtbl -> put_OLEDropMode(This,psOLEDropMode)

#define IImageCombo_get_SelectedItem(This,ppIComboItem)	\
    (This)->lpVtbl -> get_SelectedItem(This,ppIComboItem)

#define IImageCombo_putref_SelectedItem(This,ppIComboItem)	\
    (This)->lpVtbl -> putref_SelectedItem(This,ppIComboItem)

#define IImageCombo_put_SelectedItem(This,ppIComboItem)	\
    (This)->lpVtbl -> put_SelectedItem(This,ppIComboItem)

#define IImageCombo_get_SelLength(This,plSelLength)	\
    (This)->lpVtbl -> get_SelLength(This,plSelLength)

#define IImageCombo_put_SelLength(This,plSelLength)	\
    (This)->lpVtbl -> put_SelLength(This,plSelLength)

#define IImageCombo_get_SelStart(This,plSelStart)	\
    (This)->lpVtbl -> get_SelStart(This,plSelStart)

#define IImageCombo_put_SelStart(This,plSelStart)	\
    (This)->lpVtbl -> put_SelStart(This,plSelStart)

#define IImageCombo_get_SelText(This,pbstrText)	\
    (This)->lpVtbl -> get_SelText(This,pbstrText)

#define IImageCombo_put_SelText(This,pbstrText)	\
    (This)->lpVtbl -> put_SelText(This,pbstrText)

#define IImageCombo_get_Style(This,penumStyle)	\
    (This)->lpVtbl -> get_Style(This,penumStyle)

#define IImageCombo_put_Style(This,penumStyle)	\
    (This)->lpVtbl -> put_Style(This,penumStyle)

#define IImageCombo_get_UsePathSep(This,pbUsePathSep)	\
    (This)->lpVtbl -> get_UsePathSep(This,pbUsePathSep)

#define IImageCombo_put_UsePathSep(This,pbUsePathSep)	\
    (This)->lpVtbl -> put_UsePathSep(This,pbUsePathSep)

#define IImageCombo_AboutBox(This)	\
    (This)->lpVtbl -> AboutBox(This)

#define IImageCombo_GetFirstVisible(This,ppIComboItem)	\
    (This)->lpVtbl -> GetFirstVisible(This,ppIComboItem)

#define IImageCombo_Refresh(This)	\
    (This)->lpVtbl -> Refresh(This)

#define IImageCombo_OLEDrag(This)	\
    (This)->lpVtbl -> OLEDrag(This)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpcontext][helpstring][defaultbind][displaybind][requestedit][bindable][propget][id] */ HRESULT STDMETHODCALLTYPE IImageCombo_get_Text_Proxy( 
    IImageCombo * This,
    /* [retval][out] */ BSTR *pbstrText);


void __RPC_STUB IImageCombo_get_Text_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][defaultbind][displaybind][requestedit][bindable][propput][id] */ HRESULT STDMETHODCALLTYPE IImageCombo_put_Text_Proxy( 
    IImageCombo * This,
    /* [in] */ BSTR pbstrText);


void __RPC_STUB IImageCombo_put_Text_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IImageCombo_get_BackColor_Proxy( 
    IImageCombo * This,
    /* [retval][out] */ /* external definition not present */ OLE_COLOR *pocBackColor);


void __RPC_STUB IImageCombo_get_BackColor_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE IImageCombo_put_BackColor_Proxy( 
    IImageCombo * This,
    /* [in] */ /* external definition not present */ OLE_COLOR pocBackColor);


void __RPC_STUB IImageCombo_put_BackColor_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IImageCombo_get_Enabled_Proxy( 
    IImageCombo * This,
    /* [retval][out] */ VARIANT_BOOL *pbEnabled);


void __RPC_STUB IImageCombo_get_Enabled_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE IImageCombo_put_Enabled_Proxy( 
    IImageCombo * This,
    /* [in] */ VARIANT_BOOL pbEnabled);


void __RPC_STUB IImageCombo_put_Enabled_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IImageCombo_get_Font_Proxy( 
    IImageCombo * This,
    /* [retval][out] */ /* external definition not present */ IFontDisp **ppFont);


void __RPC_STUB IImageCombo_get_Font_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE IImageCombo_put_Font_Proxy( 
    IImageCombo * This,
    /* [in] */ /* external definition not present */ IFontDisp *ppFont);


void __RPC_STUB IImageCombo_put_Font_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propputref][id] */ HRESULT STDMETHODCALLTYPE IImageCombo_putref_Font_Proxy( 
    IImageCombo * This,
    /* [in] */ /* external definition not present */ IFontDisp *ppFont);


void __RPC_STUB IImageCombo_putref_Font_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IImageCombo_get_ForeColor_Proxy( 
    IImageCombo * This,
    /* [retval][out] */ /* external definition not present */ OLE_COLOR *pocForeColor);


void __RPC_STUB IImageCombo_get_ForeColor_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE IImageCombo_put_ForeColor_Proxy( 
    IImageCombo * This,
    /* [in] */ /* external definition not present */ OLE_COLOR pocForeColor);


void __RPC_STUB IImageCombo_put_ForeColor_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IImageCombo_get_hWnd_Proxy( 
    IImageCombo * This,
    /* [retval][out] */ /* external definition not present */ OLE_HANDLE *phWnd);


void __RPC_STUB IImageCombo_get_hWnd_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE IImageCombo_put_hWnd_Proxy( 
    IImageCombo * This,
    /* [in] */ /* external definition not present */ OLE_HANDLE phWnd);


void __RPC_STUB IImageCombo_put_hWnd_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IImageCombo_get_ImageList_Proxy( 
    IImageCombo * This,
    /* [retval][out] */ IDispatch **ppImageList);


void __RPC_STUB IImageCombo_get_ImageList_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propputref][id] */ HRESULT STDMETHODCALLTYPE IImageCombo_putref_ImageList_Proxy( 
    IImageCombo * This,
    /* [in] */ IDispatch *ppImageList);


void __RPC_STUB IImageCombo_putref_ImageList_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE IImageCombo_put_ImageList_Proxy( 
    IImageCombo * This,
    /* [in] */ IDispatch *ppImageList);


void __RPC_STUB IImageCombo_put_ImageList_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IImageCombo_get_Indentation_Proxy( 
    IImageCombo * This,
    /* [retval][out] */ short *psIndent);


void __RPC_STUB IImageCombo_get_Indentation_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE IImageCombo_put_Indentation_Proxy( 
    IImageCombo * This,
    /* [in] */ short psIndent);


void __RPC_STUB IImageCombo_put_Indentation_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IImageCombo_get_ComboItems_Proxy( 
    IImageCombo * This,
    /* [retval][out] */ IComboItems **ppComboItems);


void __RPC_STUB IImageCombo_get_ComboItems_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propputref][id] */ HRESULT STDMETHODCALLTYPE IImageCombo_putref_ComboItems_Proxy( 
    IImageCombo * This,
    /* [in] */ IComboItems *ppComboItems);


void __RPC_STUB IImageCombo_putref_ComboItems_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IImageCombo_get_Locked_Proxy( 
    IImageCombo * This,
    /* [retval][out] */ VARIANT_BOOL *pbLocked);


void __RPC_STUB IImageCombo_get_Locked_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE IImageCombo_put_Locked_Proxy( 
    IImageCombo * This,
    /* [in] */ VARIANT_BOOL pbLocked);


void __RPC_STUB IImageCombo_put_Locked_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IImageCombo_get_MouseIcon_Proxy( 
    IImageCombo * This,
    /* [retval][out] */ /* external definition not present */ IPictureDisp **ppMouseIcon);


void __RPC_STUB IImageCombo_get_MouseIcon_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE IImageCombo_put_MouseIcon_Proxy( 
    IImageCombo * This,
    /* [in] */ /* external definition not present */ IPictureDisp *ppMouseIcon);


void __RPC_STUB IImageCombo_put_MouseIcon_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propputref][id] */ HRESULT STDMETHODCALLTYPE IImageCombo_putref_MouseIcon_Proxy( 
    IImageCombo * This,
    /* [in] */ /* external definition not present */ IPictureDisp *ppMouseIcon);


void __RPC_STUB IImageCombo_putref_MouseIcon_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IImageCombo_get_MousePointer_Proxy( 
    IImageCombo * This,
    /* [retval][out] */ MousePointerConstants *penumMousePointer);


void __RPC_STUB IImageCombo_get_MousePointer_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE IImageCombo_put_MousePointer_Proxy( 
    IImageCombo * This,
    /* [in] */ MousePointerConstants penumMousePointer);


void __RPC_STUB IImageCombo_put_MousePointer_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IImageCombo_get_OLEDragMode_Proxy( 
    IImageCombo * This,
    /* [retval][out] */ OLEDragConstants *psOLEDragMode);


void __RPC_STUB IImageCombo_get_OLEDragMode_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE IImageCombo_put_OLEDragMode_Proxy( 
    IImageCombo * This,
    /* [in] */ OLEDragConstants psOLEDragMode);


void __RPC_STUB IImageCombo_put_OLEDragMode_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IImageCombo_get_OLEDropMode_Proxy( 
    IImageCombo * This,
    /* [retval][out] */ OLEDropConstants *psOLEDropMode);


void __RPC_STUB IImageCombo_get_OLEDropMode_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE IImageCombo_put_OLEDropMode_Proxy( 
    IImageCombo * This,
    /* [in] */ OLEDropConstants psOLEDropMode);


void __RPC_STUB IImageCombo_put_OLEDropMode_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IImageCombo_get_SelectedItem_Proxy( 
    IImageCombo * This,
    /* [retval][out] */ IComboItem **ppIComboItem);


void __RPC_STUB IImageCombo_get_SelectedItem_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propputref][id] */ HRESULT STDMETHODCALLTYPE IImageCombo_putref_SelectedItem_Proxy( 
    IImageCombo * This,
    /* [in] */ IComboItem *ppIComboItem);


void __RPC_STUB IImageCombo_putref_SelectedItem_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE IImageCombo_put_SelectedItem_Proxy( 
    IImageCombo * This,
    /* [in] */ VARIANT *ppIComboItem);


void __RPC_STUB IImageCombo_put_SelectedItem_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IImageCombo_get_SelLength_Proxy( 
    IImageCombo * This,
    /* [retval][out] */ long *plSelLength);


void __RPC_STUB IImageCombo_get_SelLength_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE IImageCombo_put_SelLength_Proxy( 
    IImageCombo * This,
    /* [in] */ long plSelLength);


void __RPC_STUB IImageCombo_put_SelLength_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IImageCombo_get_SelStart_Proxy( 
    IImageCombo * This,
    /* [retval][out] */ long *plSelStart);


void __RPC_STUB IImageCombo_get_SelStart_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE IImageCombo_put_SelStart_Proxy( 
    IImageCombo * This,
    /* [in] */ long plSelStart);


void __RPC_STUB IImageCombo_put_SelStart_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IImageCombo_get_SelText_Proxy( 
    IImageCombo * This,
    /* [retval][out] */ BSTR *pbstrText);


void __RPC_STUB IImageCombo_get_SelText_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE IImageCombo_put_SelText_Proxy( 
    IImageCombo * This,
    /* [in] */ BSTR pbstrText);


void __RPC_STUB IImageCombo_put_SelText_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][hidden][restricted][propget][id] */ HRESULT STDMETHODCALLTYPE IImageCombo_get_Style_Proxy( 
    IImageCombo * This,
    /* [retval][out] */ ImageComboStyleConstants *penumStyle);


void __RPC_STUB IImageCombo_get_Style_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][hidden][restricted][propput][id] */ HRESULT STDMETHODCALLTYPE IImageCombo_put_Style_Proxy( 
    IImageCombo * This,
    /* [in] */ ImageComboStyleConstants penumStyle);


void __RPC_STUB IImageCombo_put_Style_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][hidden][restricted][propget][id] */ HRESULT STDMETHODCALLTYPE IImageCombo_get_UsePathSep_Proxy( 
    IImageCombo * This,
    /* [retval][out] */ VARIANT_BOOL *pbUsePathSep);


void __RPC_STUB IImageCombo_get_UsePathSep_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][hidden][restricted][propput][id] */ HRESULT STDMETHODCALLTYPE IImageCombo_put_UsePathSep_Proxy( 
    IImageCombo * This,
    /* [in] */ VARIANT_BOOL pbUsePathSep);


void __RPC_STUB IImageCombo_put_UsePathSep_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [hidden][id] */ HRESULT STDMETHODCALLTYPE IImageCombo_AboutBox_Proxy( 
    IImageCombo * This);


void __RPC_STUB IImageCombo_AboutBox_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][id] */ HRESULT STDMETHODCALLTYPE IImageCombo_GetFirstVisible_Proxy( 
    IImageCombo * This,
    /* [retval][out] */ IComboItem **ppIComboItem);


void __RPC_STUB IImageCombo_GetFirstVisible_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][id] */ HRESULT STDMETHODCALLTYPE IImageCombo_Refresh_Proxy( 
    IImageCombo * This);


void __RPC_STUB IImageCombo_Refresh_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][id] */ HRESULT STDMETHODCALLTYPE IImageCombo_OLEDrag_Proxy( 
    IImageCombo * This);


void __RPC_STUB IImageCombo_OLEDrag_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IImageCombo_INTERFACE_DEFINED__ */


#ifndef __DImageComboEvents_DISPINTERFACE_DEFINED__
#define __DImageComboEvents_DISPINTERFACE_DEFINED__

/* dispinterface DImageComboEvents */
/* [hidden][helpcontext][helpstring][uuid] */ 


EXTERN_C const IID DIID_DImageComboEvents;

#if defined(__cplusplus) && !defined(CINTERFACE)

    MIDL_INTERFACE("DD9DA665-8594-11D1-B16A-00C0F0283628")
    DImageComboEvents : public IDispatch
    {
    };
    
#else 	/* C style interface */

    typedef struct DImageComboEventsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            DImageComboEvents * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            DImageComboEvents * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            DImageComboEvents * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            DImageComboEvents * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            DImageComboEvents * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            DImageComboEvents * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            DImageComboEvents * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        END_INTERFACE
    } DImageComboEventsVtbl;

    interface DImageComboEvents
    {
        CONST_VTBL struct DImageComboEventsVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define DImageComboEvents_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define DImageComboEvents_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define DImageComboEvents_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define DImageComboEvents_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define DImageComboEvents_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define DImageComboEvents_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define DImageComboEvents_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)

#endif /* COBJMACROS */


#endif 	/* C style interface */


#endif 	/* __DImageComboEvents_DISPINTERFACE_DEFINED__ */


EXTERN_C const CLSID CLSID_DataObject;

#ifdef __cplusplus

class DECLSPEC_UUID("2334D2B2-713E-11CF-8AE5-00AA00C00905")
DataObject;
#endif

EXTERN_C const CLSID CLSID_DataObjectFiles;

#ifdef __cplusplus

class DECLSPEC_UUID("2334D2B4-713E-11CF-8AE5-00AA00C00905")
DataObjectFiles;
#endif

EXTERN_C const CLSID CLSID_TabStrip;

#ifdef __cplusplus

class DECLSPEC_UUID("1EFB6596-857C-11D1-B16A-00C0F0283628")
TabStrip;
#endif

EXTERN_C const CLSID CLSID_Tabs;

#ifdef __cplusplus

class DECLSPEC_UUID("1EFB6598-857C-11D1-B16A-00C0F0283628")
Tabs;
#endif

EXTERN_C const CLSID CLSID_Tab;

#ifdef __cplusplus

class DECLSPEC_UUID("1EFB659A-857C-11D1-B16A-00C0F0283628")
Tab;
#endif

EXTERN_C const CLSID CLSID_Toolbar;

#ifdef __cplusplus

class DECLSPEC_UUID("66833FE6-8583-11D1-B16A-00C0F0283628")
Toolbar;
#endif

EXTERN_C const CLSID CLSID_Buttons;

#ifdef __cplusplus

class DECLSPEC_UUID("66833FE8-8583-11D1-B16A-00C0F0283628")
Buttons;
#endif

EXTERN_C const CLSID CLSID_ButtonMenus;

#ifdef __cplusplus

class DECLSPEC_UUID("66833FEC-8583-11D1-B16A-00C0F0283628")
ButtonMenus;
#endif

EXTERN_C const CLSID CLSID_StatusBar;

#ifdef __cplusplus

class DECLSPEC_UUID("8E3867A3-8586-11D1-B16A-00C0F0283628")
StatusBar;
#endif

EXTERN_C const CLSID CLSID_Panels;

#ifdef __cplusplus

class DECLSPEC_UUID("8E3867A5-8586-11D1-B16A-00C0F0283628")
Panels;
#endif

EXTERN_C const CLSID CLSID_ProgressBar;

#ifdef __cplusplus

class DECLSPEC_UUID("35053A22-8589-11D1-B16A-00C0F0283628")
ProgressBar;
#endif

EXTERN_C const CLSID CLSID_TreeView;

#ifdef __cplusplus

class DECLSPEC_UUID("C74190B6-8589-11D1-B16A-00C0F0283628")
TreeView;
#endif

EXTERN_C const CLSID CLSID_Nodes;

#ifdef __cplusplus

class DECLSPEC_UUID("0713E8C0-850A-101B-AFC0-4210102A8DA7")
Nodes;
#endif

EXTERN_C const CLSID CLSID_ListView;

#ifdef __cplusplus

class DECLSPEC_UUID("BDD1F04B-858B-11D1-B16A-00C0F0283628")
ListView;
#endif

EXTERN_C const CLSID CLSID_ListItems;

#ifdef __cplusplus

class DECLSPEC_UUID("BDD1F04D-858B-11D1-B16A-00C0F0283628")
ListItems;
#endif

EXTERN_C const CLSID CLSID_ColumnHeaders;

#ifdef __cplusplus

class DECLSPEC_UUID("0713E8C6-850A-101B-AFC0-4210102A8DA7")
ColumnHeaders;
#endif

EXTERN_C const CLSID CLSID_ListSubItems;

#ifdef __cplusplus

class DECLSPEC_UUID("BDD1F054-858B-11D1-B16A-00C0F0283628")
ListSubItems;
#endif

EXTERN_C const CLSID CLSID_ListSubItem;

#ifdef __cplusplus

class DECLSPEC_UUID("BDD1F056-858B-11D1-B16A-00C0F0283628")
ListSubItem;
#endif

EXTERN_C const CLSID CLSID_ImageList;

#ifdef __cplusplus

class DECLSPEC_UUID("2C247F23-8591-11D1-B16A-00C0F0283628")
ImageList;
#endif

EXTERN_C const CLSID CLSID_ListImages;

#ifdef __cplusplus

class DECLSPEC_UUID("2C247F25-8591-11D1-B16A-00C0F0283628")
ListImages;
#endif

EXTERN_C const CLSID CLSID_ListImage;

#ifdef __cplusplus

class DECLSPEC_UUID("2C247F27-8591-11D1-B16A-00C0F0283628")
ListImage;
#endif

EXTERN_C const CLSID CLSID_Slider;

#ifdef __cplusplus

class DECLSPEC_UUID("F08DF954-8592-11D1-B16A-00C0F0283628")
Slider;
#endif

EXTERN_C const CLSID CLSID_Controls;

#ifdef __cplusplus

class DECLSPEC_UUID("C8A3DC01-8593-11D1-B16A-00C0F0283628")
Controls;
#endif

EXTERN_C const CLSID CLSID_ComboItem;

#ifdef __cplusplus

class DECLSPEC_UUID("DD9DA661-8594-11D1-B16A-00C0F0283628")
ComboItem;
#endif

EXTERN_C const CLSID CLSID_ComboItems;

#ifdef __cplusplus

class DECLSPEC_UUID("DD9DA663-8594-11D1-B16A-00C0F0283628")
ComboItems;
#endif

EXTERN_C const CLSID CLSID_ImageCombo;

#ifdef __cplusplus

class DECLSPEC_UUID("DD9DA666-8594-11D1-B16A-00C0F0283628")
ImageCombo;
#endif
#endif /* __MSComctlLib_LIBRARY_DEFINED__ */

/* Additional Prototypes for ALL interfaces */

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\Include\VSLAutomation.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef VSLAUTOMATION_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define VSLAUTOMATION_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

// VSL includes
#include <VSLErrorHandlers.h>
#include <VSLExceptionHandlers.h>

// VS Platform includes
#include <vbapkg.h> // for IVsMacroRecorder

namespace VSL
{

template <class Derived_T>
class IExtensibleObjectImpl :
	public IExtensibleObject
{

VSL_DECLARE_NOT_COPYABLE(IExtensibleObjectImpl)

public:

	STDMETHOD(GetAutomationObject)(_In_z_ BSTR bstrName, _In_ IExtensibleObjectSite* pParent, _Deref_out_ IDispatch** ppDisp)
	{
		VSL_STDMETHODTRY{

		VSL_CHECKPOINTER(ppDisp, E_INVALIDARG);

		*ppDisp = NULL;

		Derived_T& rDerived = *(static_cast<Derived_T*>(this));
		*ppDisp = rDerived.GetNamedAutomationObject(bstrName);
		VSL_ASSERT(NULL != *ppDisp);
#if defined(_DEBUG) || defined(DEBUG)
		ATL::CComPtr<IUnknown> spIUnknown(this);
		VSL_ASSERT(spIUnknown.IsEqualObject(ppDisp));
#endif // _DEBUG

		if(NULL != pParent)
		{
			// Do not AddRef m_pParent, as doing so will create a circular dependency
			m_pParent = pParent;
		}

		}VSL_STDMETHODCATCH()

		return VSL_GET_STDMETHOD_HRESULT();
	}

protected:

	IExtensibleObjectImpl():
		 m_pParent(NULL)
	{
	}

	~IExtensibleObjectImpl()
	{
		if(NULL != m_pParent)
		{
			// Pass the IUnknown for identity, in case a comparison is made in NotifyDelete without
			// QI'ing for the IUnknown for identity first
			HRESULT hr = m_pParent->NotifyDelete(static_cast<Derived_T*>(this)->_GetRawUnknown());
			VSL_ASSERT(SUCCEEDED(hr));
			(hr);
			// Do not Release m_pParent, since it was not AddRef'ed above
			m_pParent = NULL;
		}
	}

private:

	IExtensibleObjectSite* m_pParent;
};

template <const GUID* pguidEmitter_T, class Macro_T, Macro_T NoLastMacroRecorded_T>
class VsMacroRecorder
{

VSL_DECLARE_NOT_COPYABLE(VsMacroRecorder)

public:

	VsMacroRecorder():
		m_spIVsMacroRecorder(),
		m_iLastMacroRecorded(NoLastMacroRecorded_T),
		m_iTimesPreviouslyRecorded(0)
	{
	}

	// Compiler generated destructor is fine

    void Reset()    
    { 
        m_iLastMacroRecorded = NoLastMacroRecorded_T;
        m_iTimesPreviouslyRecorded = 0;
    }

	void Stop()
	{
		Reset();
		m_spIVsMacroRecorder.Release();
	}

	bool IsLastRecordedMacro(Macro_T iMacro)
	{
		return (iMacro == m_iLastMacroRecorded && ObjectIsLastMacroEmitter()) ? true : false;
	}

	template <class VsSiteCache_T>
	bool IsRecording(VsSiteCache_T &rVsSiteCache)
	{
		// If the property can not be retreived it is assumeed no macro is being recorded.
		VSRECORDSTATE recordState = VSRECORDSTATE_OFF;

		// Retrieve the macro recording state.
		ATL::CComVariant var;
		if(SUCCEEDED((rVsSiteCache.GetCachedService<IVsShell, SID_SVsShell>()->GetProperty(VSSPROPID_RecordState, &var))))
		{
			recordState = static_cast<VSRECORDSTATE>(var.lVal);
		}
		
		// If there is a change in the record state to OFF or ON we must either obtain
		// or release the macro recorder. 
		if(recordState == VSRECORDSTATE_ON && !m_spIVsMacroRecorder)
		{
			// If this QueryService fails we no macro recording
			HRESULT hr = rVsSiteCache.QueryService(SID_SVsMacroRecorder, &m_spIVsMacroRecorder);
			VSL_ASSERT(SUCCEEDED(hr));
			if(FAILED(hr))
			{
				// Ensure value is NULL on failure
				m_spIVsMacroRecorder = NULL;
			}
		}
		else if(recordState == VSRECORDSTATE_OFF && !!m_spIVsMacroRecorder)
		{
			// If the macro recording state has been switched off then we can release
			// the service. Note that if the state has become paused we take no action.
			Stop();
		}
		return !!m_spIVsMacroRecorder;
	}

	void RecordLine(LPCOLESTR szLine)
	{
		VSL_CHECKHRESULT(m_spIVsMacroRecorder->RecordLine(szLine, *pguidEmitter_T));
		Reset();
	}

	bool RecordBatchedLine(Macro_T iMacroRecorded, ATL::CStringW strLine, int iMaxLineLength = 0)
	{
		if(iMaxLineLength > 0 && strLine.GetLength() >= iMaxLineLength)
		{
			// Reset the state after recording the line, so it will not be appended to further
			RecordLine(strLine);
			// Notify the caller that the this line will not be appended to further
			return true;
		}

		if(IsLastRecordedMacro(iMacroRecorded))
		{
			VSL_CHECKHRESULT(m_spIVsMacroRecorder->ReplaceLine(strLine, *pguidEmitter_T));
			// m_iLastMacroRecorded can stay the same
			++m_iTimesPreviouslyRecorded;
		}
		else
		{
			VSL_CHECKHRESULT(m_spIVsMacroRecorder->RecordLine(strLine, *pguidEmitter_T));
			m_iLastMacroRecorded = iMacroRecorded;
			m_iTimesPreviouslyRecorded = 1;
		}

		return false;
	}

	unsigned int GetTimesPreviouslyRecorded(Macro_T iMacro)
	{
		return IsLastRecordedMacro(iMacro) ? m_iTimesPreviouslyRecorded : 0;
	}

private:

    // This function determines if the last line sent to the macro recorder was
    // sent from this emitter. Note it is not valid to call this function if
    // macro recording is switched off.
    BOOL ObjectIsLastMacroEmitter()
    {
        GUID guid;
        VSL_CHECKHRESULT(m_spIVsMacroRecorder->GetLastEmitterId(&guid));
		return ::IsEqualGUID(guid, *pguidEmitter_T);
    }

	ATL::CComPtr<IVsMacroRecorder> m_spIVsMacroRecorder;
	Macro_T m_iLastMacroRecorded;
	unsigned int m_iTimesPreviouslyRecorded;
};

} // namespace VSL

#endif // VSLAUTOMATION_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\Include\VSLCommandTarget.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef VSLCOMMANDTARGET_H_25EF07F8_138A_4CA3_9721_3DD66041241D
#define VSLCOMMANDTARGET_H_25EF07F8_138A_4CA3_9721_3DD66041241D

#if _MSC_VER > 1000
#pragma once
#endif

#include <VSL.h>
#include <VSLErrorHandlers.h>
#include <VSLExceptionHandlers.h>
#include <VsShellInterfaces.h>
#include <limits>
#include <AtlColl.h>
#include <atlstr.h>

namespace VSL
{

// A command is identified by VS using a GUID/DWORD pair where the GUID is the command set
// and the DWORD is a unique identifier for the command inside the command set.
class CommandId
{
private:

	// No default construction or assignment
	CommandId();
	const CommandId& operator=(const CommandId& rToCopy);

public:
	CommandId(const GUID& rGuid, DWORD id) :
		m_CommandGuid(rGuid),
		m_Id(id)
	{
	}

	CommandId(const CommandId& rToCopy) :
		m_CommandGuid(rToCopy.m_CommandGuid),
		m_Id(rToCopy.m_Id)
	{
	}

	const GUID& GetGuid() const
	{
		return m_CommandGuid;
	}

	const DWORD GetId() const
	{
		return m_Id;
	}

	bool operator==(const CommandId& rCommandID) const
	{
		return (m_CommandGuid == rCommandID.m_CommandGuid) && (m_Id == rCommandID.m_Id);
	}

	bool operator!=(const CommandId& rCommandID) const
	{
		return !operator==(rCommandID);
	}

	// This operator is used by the ATL map to get a hash code for the object.
	operator ULONG_PTR() const
	{
		return m_CommandGuid.Data1 ^ (((int)m_CommandGuid.Data2 << 16) | (int)m_CommandGuid.Data3) ^ 
	         (((int)m_CommandGuid.Data4[3] << 24) | m_CommandGuid.Data4[7]) ^ m_Id;
	}

private:

	GUID m_CommandGuid;
	DWORD m_Id;
};

// This class handles a single command. It provides a default implementation for
// the QueryStatus and the Exec methods.
template<class Target_T>
class CommandHandlerBase
{

VSL_DECLARE_NOT_COPYABLE(CommandHandlerBase)

public:
	// Define the types for the functions that handle the QueryStatus and Exec methods.
	typedef void (Target_T::*QueryStatusHandler)(const typename Target_T::CommandHandler& handler, OLECMD*, OLECMDTEXT*);
	typedef void (Target_T::*ExecHandler)(typename Target_T::CommandHandler* handler, DWORD, VARIANT*, VARIANT*);

	CommandHandlerBase(const CommandId& commandId, QueryStatusHandler statusHandler = NULL, ExecHandler execHandler = NULL, DWORD dwStatus = OLECMDF_SUPPORTED | OLECMDF_ENABLED, const wchar_t* szText = NULL) :
		m_CommandId(commandId),
		m_OleCommandFlags(dwStatus),
		m_StatusHandler(DefaultStatusHandlerOnNull(statusHandler)),
		m_ExecHandler(execHandler),
		m_strText(szText)
	{
	}

	CommandHandlerBase(const GUID& rGuid, DWORD id, QueryStatusHandler statusHandler = NULL, ExecHandler execHandler = NULL, DWORD dwStatus = OLECMDF_SUPPORTED | OLECMDF_ENABLED, const wchar_t* szText = NULL) :
		m_CommandId(rGuid, id),
		m_OleCommandFlags(dwStatus),
		m_StatusHandler(DefaultStatusHandlerOnNull(statusHandler)),
		m_ExecHandler(execHandler),
		m_strText(szText)
	{
	}

	virtual ~CommandHandlerBase() {}

	// QueryStatus: this method is called when the shell needs to get the status of the commands,
	// e.g. when a menu is show.
	virtual void QueryStatus(Target_T* pTarget, OLECMD* pOleCmd, OLECMDTEXT* pOleText)
	{
		VSL_CHECKBOOLEAN(m_StatusHandler != NULL, E_POINTER);
		VSL_CHECKPOINTER_DEFAULT(pTarget);
		VSL_CHECKPOINTER_DEFAULT(pOleCmd);
		(pTarget->*m_StatusHandler)(*this, pOleCmd, pOleText);
	}

	static void QueryStatusDefault(const CommandHandlerBase<Target_T>& rSender, OLECMD* pOleCmd, OLECMDTEXT* pOleText)
	{
		pOleCmd->cmdf = rSender.GetFlags();
		// Check if the shell is asking for the text of this command.
		if((NULL != pOleText) && (0 != (pOleText->cmdtextf & OLECMDTEXTF_NAME)) && (rSender.GetText()))
		{
			ULONG charsToWrite = rSender.GetText().GetLength();
			if (charsToWrite > pOleText->cwBuf-1)
				charsToWrite = pOleText->cwBuf-1;
			::wcsncpy_s(pOleText->rgwz, pOleText->cwBuf, rSender.GetText(), charsToWrite);
			pOleText->cwActual = charsToWrite;
		}
	}

	// Exec: This method is called when the user selects a command clicking on a menu item or on a
	// toolbar button.
	virtual void Exec(Target_T* pTarget, DWORD dwFlags, VARIANT* pIn, VARIANT* pOut)
	{
		if((NULL != m_ExecHandler))
		{
			VSL_CHECKPOINTER_DEFAULT(pTarget);
			(pTarget->*m_ExecHandler)(this, dwFlags, pIn, pOut);
		}
	}

	// Get the ID of the command handled by this object.
	const CommandId& GetId() const
	{
		return m_CommandId;
	}

	// Command Text
	const CStringW& GetText() const
	{
		return m_strText;
	}

	CStringW& GetText()
	{
		return m_strText;
	}
	
	DWORD GetFlags() const
	{
		return m_OleCommandFlags;
	}

	// Command Checked
	bool GetChecked() const
	{ 
		return (0 != (m_OleCommandFlags & OLECMDF_LATCHED));
	}

	void SetChecked(bool bChecked)
	{
		SetFlag(OLECMDF_LATCHED, bChecked);
	}

	// Command Enabled
	bool GetEnabled() const
	{
		return (0 != (m_OleCommandFlags & OLECMDF_ENABLED));
	}

	void SetEnabled(bool bEnabled)
	{
		SetFlag(OLECMDF_ENABLED, bEnabled);
	}

	// Command Supported
	bool GetSupported() const
	{
		return (0 != (m_OleCommandFlags & OLECMDF_SUPPORTED));
	}

	void SetSupported(bool bSupported)
	{
		SetFlag(OLECMDF_SUPPORTED, bSupported);
	}

	// Command Visible
	bool GetVisible() const
	{
		return (0 == (m_OleCommandFlags & OLECMDF_INVISIBLE));
	}

	void SetVisible(bool bVisible)
	{
		SetFlag(OLECMDF_INVISIBLE, !bVisible);
	}

private:

	void SetFlag(DWORD flag, bool bSet)
	{
		if(bSet)
		{
			m_OleCommandFlags |= flag;
		}
		else
		{
			m_OleCommandFlags &= ~flag;
		}
	}

	QueryStatusHandler DefaultStatusHandlerOnNull(QueryStatusHandler statusHandler)
	{
		return statusHandler != NULL ? statusHandler : &Target_T::QueryStatusDefault;
	}

	CommandId m_CommandId; // The Id of this command.
	DWORD m_OleCommandFlags; // The dwFlags for the command.
	QueryStatusHandler m_StatusHandler; // The function to call for the QueryStatus.
	ExecHandler	m_ExecHandler; // The function to call for the Exec.
	CStringW m_strText;

};

template <class Derived_T>
class IOleCommandTargetImpl :
	public IOleCommandTarget
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IOleCommandTargetImpl)

public:
	typedef CommandHandlerBase<Derived_T> CommandHandler;

protected:
	CommandHandler& GetCommand(const CommandId& rId)
	{
		CommandHandler* handler = Base_T::GetCommand(rId);
		VSL_CHECKBOOLEAN(NULL != handler, OLECMDERR_E_NOTSUPPORTED);
#pragma warning(push) // compiler doesn't get that the above line will throw if pair is NULL
#pragma warning(disable : 6011) // Dereferencing NULL pointer 'pair'
		return *handler;
#pragma warning(pop)
	}

	CommandHandler* TryToGetCommand(const CommandId& rId)
	{
		return Derived_T::GetCommand(rId);
	}

public:

	STDMETHOD(QueryStatus)(
		_In_ const GUID* pCmdGroupGuid,
		_In_ ULONG cCmds, 
		_Inout_cap_(cCmds) OLECMD pCmds[], 
		_Inout_opt_ OLECMDTEXT* pCmdText)
	{
		VSL_STDMETHODTRY{

		VSL_CHECKPOINTER_DEFAULT(pCmdGroupGuid);
		VSL_CHECKPOINTER_DEFAULT(pCmds);
		VSL_CHECKBOOLEAN(1 == cCmds, E_INVALIDARG);

		// It is expected and common that the command is not found, so in this case we want to use
		// the non throwing version of GetCommand.
		CommandHandler* pCommandHandler = TryToGetCommand(CommandId(*pCmdGroupGuid, pCmds[0].cmdID));
		if (NULL == pCommandHandler)
		{
			return OLECMDERR_E_NOTSUPPORTED;
		}

		pCommandHandler->QueryStatus(static_cast<Derived_T*>(this), pCmds, pCmdText);

		}VSL_STDMETHODCATCH()

		return VSL_GET_STDMETHOD_HRESULT();
	}

	STDMETHOD(Exec)(
		_In_ const GUID* pCmdGroupGuid,
		_In_ DWORD nCmdID,
		_In_ DWORD nCmdexecopt, 
		_In_opt_ VARIANT* pIn,
		_Inout_opt_ VARIANT* pOut)
	{
		VSL_STDMETHODTRY{

		VSL_CHECKPOINTER_DEFAULT(pCmdGroupGuid);

		// It is expected and common that the command is not found, so in this case we want to use
		// the non throwing version of GetCommand.
		CommandHandler* pCommandHandler = TryToGetCommand(CommandId(*pCmdGroupGuid, nCmdID));
		if (NULL == pCommandHandler)
		{
			return OLECMDERR_E_NOTSUPPORTED;
		}

		pCommandHandler->Exec(static_cast<Derived_T*>(this), nCmdexecopt, pIn, pOut);

		}VSL_STDMETHODCATCH()

		return VSL_GET_STDMETHOD_HRESULT();
	}

	void QueryStatusDefault(const CommandHandler& rSender, OLECMD* pOleCmd, OLECMDTEXT* pOleText)
	{
		CommandHandler::QueryStatusDefault(rSender, pOleCmd, pOleText);
	}
};

#define VSL_BEGIN_COMMAND_MAP() \
	static CommandHandler* GetCommand(const VSL::CommandId& rId) \
	{ \
		/* Default, unfortunatley ATL doesn't supply a const for it. */ \
		UINT iNumberOfBins = 17; \
		__if_exists(CAtlMapNumberOfBins) \
		{ \
			iNumberOfBins = CAtlMapNumberOfBins; \
		} \
		\
		typedef CAtlMap<const VSL::CommandId, CommandHandler*> CommandMap; \
		\
		static CommandMap commands; \
		static bool bInitialized = false; \
		if(!bInitialized) \
		{ \
			commands.InitHashTable(iNumberOfBins, false);

#define VSL_COMMAND_MAP_ENTRY(guid, id, qsHandler, execHandler) \
			static CommandHandler guid##id##CommandHandler(guid, id, static_cast<CommandHandler::QueryStatusHandler>(qsHandler), static_cast<CommandHandler::ExecHandler>(execHandler)); \
			commands[guid##id##CommandHandler.GetId()] = &guid##id##CommandHandler;

#define VSL_COMMAND_MAP_ENTRY_WITH_FLAGS(guid, id, qsHandler, execHandler, dwFlags) \
			static CommandHandler guid##id##CommandHandler(guid, id, static_cast<CommandHandler::QueryStatusHandler>(qsHandler), static_cast<CommandHandler::ExecHandler>(execHandler), dwFlags); \
			commands[guid##id##CommandHandler.GetId()] = &guid##id##CommandHandler;

#define VSL_COMMAND_MAP_CLASS_ENTRY(type, parameters) \
			{ \
				static type handler parameters; \
				commands[handler.GetId()] = &handler; \
			}

#define VSL_END_VSCOMMAND_MAP() \
			bInitialized = true; \
		}; \
		\
		CommandMap::CPair* pair = commands.Lookup(rId); \
		if(NULL == pair) \
		{ \
			return NULL; \
		} \
		return pair->m_value; \
	}

} // namespace VSL

#endif // VSLCOMMANDTARGET_H_25EF07F8_138A_4CA3_9721_3DD66041241D
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\Include\VSLCom.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef VSLCOM_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define VSLCOM_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

// VSL includes
#include <VSLCommon.h>

namespace VSL
{

//Base is the user's class that derives from NonCocreateableComObjectRoot and whatever
//interfaces the user wants to support on the object
template <class Base_T>
class NonCocreateableComObject : public Base_T
{
public:
	typedef Base_T Base;
	typedef typename Base_T::ConstructorArgument ConstructorArgument;
	NonCocreateableComObject(ConstructorArgument& rConstructorArgument):
		Base(rConstructorArgument)
	{
		_pAtlModule->Lock();
	}
	// Set refcount to -(LONG_MAX/2) to protect destruction and 
	// also catch mismatched Release in debug builds
	virtual ~NonCocreateableComObject()
	{
		m_dwRef = -(LONG_MAX/2);
		FinalRelease();
#ifdef _ATL_DEBUG_INTERFACES
		_AtlDebugInterfacesModule.DeleteNonAddRefThunk(_GetRawUnknown());
#endif
		_pAtlModule->Unlock();
	}
	//If InternalAddRef or InternalRelease is undefined then your class
	//doesn't derive from NonCocreateableComObjectRoot
	STDMETHOD_(ULONG, AddRef)() {return InternalAddRef();}
	STDMETHOD_(ULONG, Release)()
	{
		ULONG l = InternalRelease();
		if (l == 0)
			delete this;
		return l;
	}
	//if _InternalQueryInterface is undefined then you forgot BEGIN_COM_MAP
	STDMETHOD(QueryInterface)(REFIID iid, void ** ppvObject)
	{return _InternalQueryInterface(iid, ppvObject);}
	template <class Q>
	HRESULT STDMETHODCALLTYPE QueryInterface(Q** pp)
	{
		return QueryInterface(__uuidof(Q), (void**)pp);
	}

	static HRESULT WINAPI CreateInstance(NonCocreateableComObject<Base>** pp, ConstructorArgument& rConstructorArgument);
};

template <class Base>
HRESULT WINAPI NonCocreateableComObject<Base>::CreateInstance(NonCocreateableComObject<Base>** pp, ConstructorArgument& rConstructorArgument)
{
	ATLASSERT(pp != NULL);
	if (pp == NULL)
		return E_POINTER;
	*pp = NULL;

	HRESULT hRes = E_OUTOFMEMORY;
	NonCocreateableComObject<Base>* p = NULL;
	ATLTRY(p = new NonCocreateableComObject<Base>(rConstructorArgument))
	if (p != NULL)
	{
		p->SetVoid(NULL);
		p->InternalFinalConstructAddRef();
		hRes = p->_AtlInitialConstruct();
		if (SUCCEEDED(hRes))
			hRes = p->FinalConstruct();
		if (SUCCEEDED(hRes))
			hRes = p->_AtlFinalConstruct();
		p->InternalFinalConstructRelease();
		if (hRes != S_OK)
		{
			delete p;
			p = NULL;
		}
	}
	*pp = p;
	return hRes;
}

} // namespace VSL

#endif // VSLCOM_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Inc\office10\msourl.h ===
/****************************************************************************
	msourl.h

	Owner: SeanMc
	Copyright (c) 1999 Microsoft Corporation

	MSO's url handling interfaces.
****************************************************************************/

#pragma once

#ifndef MSOURL_H
#define MSOURL_H

#ifndef CONST_METHOD
// to declare const methods in C++
#if defined(__cplusplus) && !defined(CINTERFACE)
	#define CONST_METHOD const
#else
	#define CONST_METHOD
#endif
#endif

#include "wininet.h"
#include "msobp.h"

// list of schemes recognized via MsoUrl
typedef enum
	{
	urlsNil = -1,
	urlsHttp,             // "http"
	urlsHttps,            // "https"
	urlsFtp,              // "ftp"
	urlsFile,             // "file"
	urlsCid,              // "cid"
	urlsMailto,           // "mailto"
	urlsJavascript,       // "javascript"
	urlsOutlook,          // "outlook"
	urlsODMA,             // "::ODMA\"
	urlsMhtmlCompound,    // "mhtml:X!Y"
	urlsThismessage,      // "thismessage"
	urlsRes,              // "res"
	urlsMk,               // "mk"
	urlsUnknown
	} MSOURLSCHEME;


// list of relativities understood via MsoUrl
typedef enum
	{
	urlrNil = -1,
	urlrOpaque,           // EXAMPLE: "mailto:someone@somewhere.com"
	urlrAbsolute,         // EXAMPLE: "http://mumble.com/woo.hoo"
	urlrServer,           // EXAMPLE: "/foo/bar/woo.hoo"
	urlrPage              // EXAMPLE: "../foo/bar/woo.hoo"
	} MSOURLRELATIVITY;


/* URLC (Url Component) flags, passed to IMsoUrl::HrGetCustomForm & IMsoUrl::FComponentsAreEqual. */
#define msofurlcScheme   0x0001
#define msofurlcUserName 0x0002
#define msofurlcPassword 0x0004
#define msofurlcServer   0x0008
#define msofurlcPort     0x0010
#define msofurlcDir      0x0020
#define msofurlcFileName 0x0040
#define msofurlcFileExt  0x0080
#define msofurlcQuery    0x0100
#define msofurlcFragment 0x0200
#define msofurlcMhtml	 0x0400

#define msofurlcAuthority (msofurlcUserName | msofurlcPassword | msofurlcServer | msofurlcPort)
#define msofurlcFileLeaf  (msofurlcFileName | msofurlcFileExt)
#define msofurlcPath      (msofurlcDir | msofurlcFileLeaf)
#define msofurlcComplete  (msofurlcScheme | msofurlcAuthority | msofurlcPath | msofurlcQuery | msofurlcFragment | msofurlcMhtml)

/* URL flags, passed to IMsoUrl::HrSetFromUser[Rgwch]. */
#define msofurlNoFragment               0x00000001  // don't treat the '#' character as a fragment delimiter
#define msofurlStripEncapsulatingDelims 0x00000002  // strip off quotes or angle brackets encapsulating the url (if present)
#define msofurlConvertDriveMappedUNC    0x00000004  // convert drive mapped UNCs to pure UNC form
#define msofurlConvertToShortFileName   0x00000008  // convert any local paths to 8.3 form
#define msofurlConvertToLongFileName    0x00000010  // convert any local paths to long filename form
#define msofurlEscapeSingleQuotes       0x00000020  // escape any single quotes found in the url
#define msofurlEscapeAllPercents        0x00000040  // escape all percents (normally percents in %HH sequences are not escaped)
#define msofurlStripLeadingWhitespace   0x00000080  // strip off leading whitespace (if present)
#define msofurlStripTrailingWhitespace  0x00000100  // strip off trailing whitespace (if present)
                                                    // if present with msofurlStripEncapsulatingDelims, strips both inside and outside delims
#define msofurlApplyGuessScheme         0x00000200  // apply best guess scheme if none exists on the url
#define msofurlApplyDefaultScheme       0x00000400  // apply the default scheme if none exists on the url
#define msofurlCaseInsensitivePath      0x00000800  // use case-insensitive comparisons on the path component
#define msofurlEnsureTrailingPathSep    0x00001000  // ensure the path component includes a trailing slash (indicating it is a directory)
#define msofurlRemoveTrailingPathSep    0x00002000  // ensure the path component does not have a trailing slash (indicating a file leaf or empty path)
#define msofurlAllowInvertedLocalSep    0x00004000  // let "x:/" map to { scheme:"file", path:"x:\" }, rather than { scheme:"x", path:"/" }
                                                    // also applies the same logic to "//server/share"
#define msofurlDontChangeSlashTypes     0x00008000  // don't change /'s to \'s or vice-versa
#define msofurlNoEscape                 0x00010000  // don't escape this url internally
#define msofurlEnsureValidAuthority     0x00020000  // ensure the authority component is valid if present (non-empty)
#define msofurlNoQuery                  0x00040000  // don't treat the '?' character as a query delimiter
#define msofurlEnsureBalancedQuotes     0x00080000  // ensure no unbalanced quotes at the beginning/end of the URL
                                                    // use with caution: these may be valid in some cases
#define msofurlEscapeAllReservedChars   0x00100000  // escape all reserved characters (any in ";/:@&=+$,") use with care -- creates very odd urls!
#define msofurlDetectASPLinks           0x00200000  // client wants ASP links detected

/* URLDF flags, passed to IMsoUrl::HrGetDisplayForm. */
#define msofurldfUnescapeHighAnsi       0x0001  // unescape high-ANSI entities (use with extreme caution!)
#define msofurldfUseLocalPathForm       0x0002  // use the local path form for local urls (return what HrGetLocalPath would return if the url is local)
#define msofurldfDoNotUnescapeHash      0x0004  // do not unescape the hash character (leave it "%23" instead)
#define msofurldfDoNotUnescapeLowAnsi   0x0008  // do not unescape low-ANSI entities (use with extreme caution!)

/* URLCF flags, passed to IMsoUrl::HrGetCustomForm. */
#define msofurlcfDisplay                0x0001  // get the display form
#define msofurlcf3SlashFileSyntax       0x0002  // use the 3 slash file: syntax
#define msofurlcfUseHideExtShellSetting 0x0004  // use the OS shell setting to hide extensions to include ext in leaf
#define msofurlcfUseLocalPathForm       0x0008  // use the local path form for local urls (return what HrGetLocalPath would return if the url is local)

/* URLE flags, passed to IMsoUrl::FExists. */
#define msofurleCheckServers      0x0001  // validate against the server (if not set then server based paths return FALSE)
#define msofurleFolder            0x0002  // verify that path points to a folder
#define msofurleBrowsable         0x0004  // verify that path points to a browsable folder (requires msofurleFolder)
#define msofurleAllowUI           0x0008  // allow UI to be raised (such as the password authentication dialog)

/* URLU flags, passed to IMsoUrl::HrUpload. */
#define msofurluAlertIfExist       0x0001
#define msofurluFailIfExist        0x0002

/* URLD flags, passed to IMsoUrl::HrDownload. */
#define msofurldUseCachedVersion  0x0001  // if it already exists in the cache, use it (otherwise download it)


/////////////////////////////////////////////////////////////////////////////////
//
// Basic url definitions:
//
// hierarchichal url := <scheme>://<authority>[/<path>][?<query>][#<fragment>]
// authority := [<username>[:<password>]@]<server>[:<port>]
// path := <dir>[/[fileleaf]]
// fileleaf := <filename>[.<fileext>]
//
// opaque url := <scheme>:<path>[?<query>][#<fragment>]
//
// NOTE: every url always has a path (& dir) component (but it may be the empty string)
//
/////////////////////////////////////////////////////////////////////////////////
//
// Mhtml url definitions:
// 
// Only-File form: mhtml:X - where X is an absolute hierarchichal url.
// Compound form: mhtml:X!Y - where X is like above, Y is a CID or CLOC (Content-Location)
//
// NOTE: We do not return Only-File forms for these types of url's, since this can
//       expose a bug in IE which causes these files to be loaded with the wrong codepage.
// NOTE: We only use the mhtml: prefix when we have a compound mhtml url (restating above).
//       Therefore Only-File url's become normal url's when accessed via url methods.
// 
// We fixup REL url's with mhtml url's by doing the following:
// mhtml:X + REL ==> mhtml:X!REL <- Only-File becomes a compound mhtml url
// mhtml:X!Y + REL ==> mhtml:X!(Y+REL)  <- here, Y+REL is the proper combination of these url's as single entities
//
/////////////////////////////////////////////////////////////////////////////////

/* IMsoUrl (iurl) */
#undef  INTERFACE
#define INTERFACE IMsoUrl
DECLARE_INTERFACE_(IMsoUrl, IUnknown)
{
	// ----- IUnknown methods

	MSOMETHOD (QueryInterface) (THIS_ REFIID riid, VOID **ppvObj) PURE;
	MSOMETHOD_(ULONG, AddRef) (THIS) PURE;
	MSOMETHOD_(ULONG, Release) (THIS) PURE;

	// ----- IMsoUrl methods

	/* FDebugMessage method */
	MSODEBUGMETHOD

	// is the URL valid? (was it set properly?)
	MSOMETHOD_(BOOL, FValid) (THIS) CONST_METHOD PURE;

	// set methods
	//
	// HrSetFromUser - use when you have a url from an external source other than another
	//    MsoUrl (for instance from user typing or pasting in from some external source
	//    or a url read in from an html file).  Param grfurl allows the user to specify
	//    special behavior (such as msofurlNoFragment specifying to interpreting the url
	//    as having no fragment).  Default grfurl is 0.
	// HrSetFromUserRgwch - same as HrSetFromUser but takes a rgwch & cch instead of wz.
	// HrSetFromCanonicalUrl - use only when you have a canonical url retrieved from
	//    another MsoUrl.  Primarily only used internally, or maybe when writing out a
	//    url to a cache in the registry for example.  When in doubt, use HrSetFromUser
	//    (which does more robustifying and canonicalizing on the input url).
	//
	// NOTE: each set method also has a param cp which is the codepage context of the
	//    url (i.e. the codepage of the html source file or CP_ACP for something pasted
	//    or the document codepage for something typed in by the user).
	// NOTE: each set method also has a param piurlBase which is a url which represent the
	//    base for resolving this url.  Urls which are absolute or opaque may safely pass
	//    in NULL for the base.  Relative url's should however always have a valid base.  If
	//    a relative url is created without a base, the HrResolve method will assert.
	MSOMETHOD (HrSetFromUser) (THIS_ const WCHAR *wzUrl, DWORD cp, const IMsoUrl *piurlBase, DWORD grfurl) PURE;
	MSOMETHOD (HrSetFromUserRgwch) (THIS_ const WCHAR *rgwchUrl, int cchUrl, DWORD cp, const IMsoUrl *piurlBase, DWORD grfurl) PURE;
	MSOMETHOD (HrSetFromCanonicalUrl) (THIS_ const WCHAR *wzUrl, DWORD cp, const IMsoUrl *piurlBase) PURE;

	// lock/unlock methods
	//
	// Use these when you use methods returning LPCWSTR's to ensure the data is not changed
	//    while you are accessing it.  These methods ensure that no updates are done to the
	//    url while you are using it's data.  If you don't want to use this, use the methods
	//    which copy the url data to a buffer instead (which don't require buffer locking).
	MSOMETHOD_(void, Lock) (THIS) CONST_METHOD PURE;
	MSOMETHOD_(void, Unlock) (THIS) CONST_METHOD PURE;

	// get url methods
	//
	// HrGetDisplayForm - use to get the unescaped "friendly" form of a url for displaying to
	//    the user (i.e. spaces in the url are actually spaces instead of %20s).
	// HrGetCanonicalForm - use to get the canonical form of the url.  This is the standard
	//    form of the url.
	// HrGetCustomForm - use to get a url with or without certain components.  For instance,
	//    use this when you want to get a url without a fragment (if it has one) -- you would
	//    pass in grfurlc as (msofurlcComplete & ~msofurlcFragment).  Note, this returns the
	//    components with their associated delimiters (unlike the component access methods below).
	//
	// NOTE: the HrGet methods all take in a WCHAR buffer wzBuf, whose size is passed in as
	//    the input value of pcchBuf.  The length of the url put in wzBuf is returned as the
	//    output value of pcchBuf.  If NULL is passed in for wzBuf, then the requisite size
	//    of wzBuf is returned in pcchBuf.  In all cases (input/output) pcchBuf is the actual
	//    count of characters in wzBuf not including the NULL termination character.  So if
	//    you query with NULL, you should alloc (*pcchBuf + 1) characters for wzBuf.  If wzBuf
	//    is NULL and the function succeeds, S_FALSE is returned.  If wzBuf is non-NULL and
	//    the function succeeds, S_OK is returned.
	//
	// CpGetCodePage - use to retrieve the codepage context of this url.
	// WzCanonicalForm - returns the same value as HrGetCanonicalForm but returns an LPCWSTR
	//    pointer to the internal buffer rather than putting it in a user specified buffer.
	//    Useful in certain scenarios.  Url must be locked while this function is called and
	//    while the return value is in use.  Returns NULL on error.
	// CchCanonicalForm - returns the count of characters of the url returned by
	//    WzCanonicalForm.
	MSOMETHOD (HrGetDisplayForm) (THIS_ WCHAR *wzBuf, int *pcchBuf, DWORD grfurldf) CONST_METHOD PURE;
	MSOMETHOD (HrGetCanonicalForm) (THIS_ WCHAR *wzBuf, int *pcchBuf) CONST_METHOD PURE;
	MSOMETHOD (HrGetCustomForm) (THIS_ DWORD grfurlc, WCHAR *wzBuf, int *pcchBuf, DWORD grfurlcf) CONST_METHOD PURE;
	MSOMETHOD_(DWORD, CpGetCodePage) (THIS) CONST_METHOD PURE;
	MSOMETHOD_(LPCWSTR, WzCanonicalForm) (THIS) CONST_METHOD PURE;
	MSOMETHOD_(int, CchCanonicalForm) (THIS) CONST_METHOD PURE;

	// component accessor methods
	//
	// Note: see "Basic url definition" comment above for component definitions.
	//
	// UrlsGetScheme - returns the scheme specified in this url as an MSOURLSCHEME.
	// HrGetScheme - returns the scheme string (without ':' delimiter).
	// HrGetAuthority - returns the authority string
	//    (with all subcomponent delimiters but without initial '/' delimiters).
	// HrGetUserName - returns the username string (without '@' delimiter).
	// HrGetPassword - returns the password string (without ':' delimiter).
	// HrGetServer - returns the server string.
	// HrGetPort - returns the port string (without ':' delimiter).
	// HrGetPath - returns the path string (with the initial '/' delimiter if this
	//    is a hierarchical url).  This may validly return the empty string.
	//    (Path contains Dir & FileLeaf).
	// HrGetDir - returns the dir string (with the initial '/' delimiter if this
	//    is a hierarchical url).  This may validly return the empty string.
	// HrGetFileLeaf - returns the file leaf string (without '/' delimeter).
	//    (FileLeaf contains FileName & FileExt).
	// HrGetFileName - returns the file name string (without '/' delimeter).
	// HrGetFileExt - returns the file ext string (without '.' delimiter).
	// HrGetQuery - returns the query string (without '?' delimiter).
	// HrGetFragment - returns the fragment string (without '#' delimiter).
	//    (Fragment is also known as Bookmark).
	//
	// NOTE: see HrGet url note above for usage of the HrGet component methods.
	//
	// RgwchScheme - same as HrGetScheme but returns a pointer to the scheme component.
	// RgwchAuthority - same
	// RgwchUserName - same
	// RgwchPassword - same
	// RgwchServer - same
	// RgwchPort - same
	// RgwchPath - same
	// RgwchDir - same
	// RgwchFileLeaf - same
	// RgwchFileName - same
	// RgwchFileExt - same
	// RgwchQuery - same
	// RgwchFragment - same
	//
	// NOTE: the Rgwch returning functions all return NULL if the component does not
	//    exist.  Param pcch is an output parameter which will contain the length of
	//    the returned rgwch pointer.  These are not NULL terminated!
	MSOMETHOD_(MSOURLSCHEME, UrlsGetScheme) (THIS) CONST_METHOD PURE;
	MSOMETHOD (HrGetScheme) (THIS_ WCHAR *wzBuf, int *pcchBuf) CONST_METHOD PURE;
	MSOMETHOD (HrGetAuthority) (THIS_ WCHAR *wzBuf, int *pcchBuf) CONST_METHOD PURE;
	MSOMETHOD (HrGetUserName) (THIS_ WCHAR *wzBuf, int *pcchBuf) CONST_METHOD PURE;
	MSOMETHOD (HrGetPassword) (THIS_ WCHAR *wzBuf, int *pcchBuf) CONST_METHOD PURE;
	MSOMETHOD (HrGetServer) (THIS_ WCHAR *wzBuf, int *pcchBuf) CONST_METHOD PURE;
	MSOMETHOD (HrGetPort) (THIS_ WCHAR *wzBuf, int *pcchBuf) CONST_METHOD PURE;
	MSOMETHOD (HrGetPath) (THIS_ WCHAR *wzBuf, int *pcchBuf) CONST_METHOD PURE;
	MSOMETHOD (HrGetDir) (THIS_ WCHAR *wzBuf, int *pcchBuf) CONST_METHOD PURE;
	MSOMETHOD (HrGetFileLeaf) (THIS_ WCHAR *wzBuf, int *pcchBuf) CONST_METHOD PURE;
	MSOMETHOD (HrGetFileName) (THIS_ WCHAR *wzBuf, int *pcchBuf) CONST_METHOD PURE;
	MSOMETHOD (HrGetFileExt) (THIS_ WCHAR *wzBuf, int *pcchBuf) CONST_METHOD PURE;
	MSOMETHOD (HrGetQuery) (THIS_ WCHAR *wzBuf, int *pcchBuf) CONST_METHOD PURE;
	MSOMETHOD (HrGetFragment) (THIS_ WCHAR *wzBuf, int *pcchBuf) CONST_METHOD PURE;
	MSOMETHOD_(LPCWSTR, RgwchScheme) (THIS_ int *pcch) CONST_METHOD PURE;
	MSOMETHOD_(LPCWSTR, RgwchAuthority) (THIS_ int *pcch) CONST_METHOD PURE;
	MSOMETHOD_(LPCWSTR, RgwchUserName) (THIS_ int *pcch) CONST_METHOD PURE;
	MSOMETHOD_(LPCWSTR, RgwchPassword) (THIS_ int *pcch) CONST_METHOD PURE;
	MSOMETHOD_(LPCWSTR, RgwchServer) (THIS_ int *pcch) CONST_METHOD PURE;
	MSOMETHOD_(LPCWSTR, RgwchPort) (THIS_ int *pcch) CONST_METHOD PURE;
	MSOMETHOD_(LPCWSTR, RgwchPath) (THIS_ int *pcch) CONST_METHOD PURE;
	MSOMETHOD_(LPCWSTR, RgwchDir) (THIS_ int *pcch) CONST_METHOD PURE;
	MSOMETHOD_(LPCWSTR, RgwchFileLeaf) (THIS_ int *pcch) CONST_METHOD PURE;
	MSOMETHOD_(LPCWSTR, RgwchFileName) (THIS_ int *pcch) CONST_METHOD PURE;
	MSOMETHOD_(LPCWSTR, RgwchFileExt) (THIS_ int *pcch) CONST_METHOD PURE;
	MSOMETHOD_(LPCWSTR, RgwchQuery) (THIS_ int *pcch) CONST_METHOD PURE;
	MSOMETHOD_(LPCWSTR, RgwchFragment) (THIS_ int *pcch) CONST_METHOD PURE;

	// helper functions for file management
	//
	// FIsHttp - does the url point to a http or https address?
	// FIsFtp - does the url point to a ftp address?
	// FIsLocal - does the url point to a dos addressable file address
	//            (local drive, mapped drive or UNC drive)?
	// FIsUNC - does the url point to a UNC file address?
	// FIsODMA - does the url point to an ODMA path identifier?
	MSOMETHOD_(BOOL, FIsHttp) (THIS) CONST_METHOD PURE;
	MSOMETHOD_(BOOL, FIsFtp) (THIS) CONST_METHOD PURE;
	MSOMETHOD_(BOOL, FIsLocal) (THIS) CONST_METHOD PURE;
	MSOMETHOD_(BOOL, FIsUNC) (THIS) CONST_METHOD PURE;
	MSOMETHOD_(BOOL, FIsODMA) (THIS) CONST_METHOD PURE;

	// local path accessor methods (only work for file: url's)
	//
	// HrGetLocalPath - returns the dos path form of the file: url.  Returns error
	//    if the url is not a file: url.  Behaves the same as HrGet url methods.
	// WzLocalPath - returns a pointer to the dos path form of the file: url.  Returns NULL
	//    if the url is not a file: url.  Behaves the same as WzCanonicalForm.
	// CchLocalPath - returns the count of characters of the dos path returned by
	//    WzLocalPath.
	//
	// EXAMPLE 1: "file://c:/mumble/woo.hoo" yields "c:\mumble\woo.hoo".
	// EXAMPLE 2: "file://server/share/mumble/woo.hoo" yields "\\server\share\mumble\woo.hoo".
	MSOMETHOD (HrGetLocalPath) (THIS_ WCHAR *wzBuf, int *pcchBuf) CONST_METHOD PURE;
	MSOMETHOD_(LPCWSTR, WzLocalPath) (THIS) CONST_METHOD PURE;
	MSOMETHOD_(int, CchLocalPath) (THIS) CONST_METHOD PURE;

	// FIsEqual - returns TRUE iff the given url is equivalent to this url.
	//    (Equivalent to calling FComponentsAreEqual with grfurlc as msofurlcComplete).
	MSOMETHOD_(BOOL, FIsEqual) (THIS_ const IMsoUrl *piurl) CONST_METHOD PURE;

	// FComponentsAreEqual - returns TRUE iff the components specifed in grfurlc are equivalent
	//    in this url and the given url.
	MSOMETHOD_(BOOL, FComponentsAreEqual) (THIS_ DWORD grfurlc, const IMsoUrl *piurl) CONST_METHOD PURE;

	// FSubsumes - returns TRUE iff this url's folder location is a direct
	//    hierarchical ancestor of piurl.  If two url's subsume each other, they point to
	//    the same folder location!
	//
	// EXAMPLE 1: "http://mumble/woo/blah.htm" subsumes "http://mumble/woo/hoo/wunder.bar".
	// EXAMPLE 2: "http://mumble/woo/hoo/wunder.bar" does not subsume "http://mumble/woo/blah.htm".
	// EXAMPLE 3: "http://mumble/woo/blah.htm" does not subsume "ftp://foobarbaz/woo/hoo/wunder.bar".
	// EXAMPLE 4: "http://mumble/woo/hoo/blah.htm" does not subsume "http://mumble/woo/zoo/foo.gif".
	MSOMETHOD_(BOOL, FSubsumes) (THIS_ const IMsoUrl *piurl) CONST_METHOD PURE;

	// UrlrGetRelativity - returns the relativity of this url as an MSOURLRELATIVITY.
	MSOMETHOD_(MSOURLRELATIVITY, UrlrGetRelativity) (THIS) CONST_METHOD PURE;

	// HrSetRelativity - updates the relativity of this url.  Returns S_OK when the
	//    url is successfully updated or S_FALSE if the requested url cannot be set
	//    because the base url's server or scheme is different.  Returns error codes
	//    for other failures.
	MSOMETHOD (HrSetRelativity) (THIS_ MSOURLRELATIVITY urlr) PURE;

	// HrResolve - resolves this relative url to a full path (by combining it with its base),
	//    creates a new url and returns it in ppiurlAbsolute.  On success,
	//    *ppiurlAbsolute must be Released by the client when done.  Calling this on an
	//    absolute or opaque url is valid.
	//
	// EXAMPLE 1: this url "foo.bar" combined with base "http://woohoo/sub/hub/spiffy.htm"
	//    yields resolved path "http://woohoo/sub/hub/foo.bar".
	// EXAMPLE 2: this url "/foo.bar" combined with base "http://woohoo/sub/hub/spiffy.htm"
	//    yields resolved path "http://woohoo/foo.bar".
	// EXAMPLE 3: this url "../foo.bar" combined with base "http://woohoo/sub/hub/spiffy.htm"
	//    yields resolved path "http://woohoo/sub/foo.bar".
	MSOMETHOD (HrResolve) (THIS_ IMsoUrl **ppiurlAbsolute) CONST_METHOD PURE;

	// HrRebase - rebase this url with a different base url (i.e. link fixup).
	//    If the new base url is on a different server this just makes the url absolute.
	//    Otherwise it maintains the current relativity state and constructs a new
	//    relative url pointing at the same target location.  If the relativity state
	//    was not maintainable, it returns S_FALSE on success.
	//
	// EXAMPLE 1: this url "foo.bar" with old base "http://woohoo/sub/hub/spiffy.htm"
	//    rebased with new base "http://woohoo/sub/spiffy.htm"
	//    yields this url "hub/foo.bar".
	// EXAMPLE 2: this url "../foo.bar" with old base "http://woohoo/sub/hub/spiffy.htm"
	//    rebased with new base "http://woohoo/sub/spiffy.htm"
	//    yields this url "foo.bar".
	// EXAMPLE 3: this url "/foo.bar" with old base "http://woohoo/sub/hub/spiffy.htm"
	//    rebased with new base "http://woohoo/sub/spiffy.htm"
	//    yields this url "/foo.bar".
	// EXAMPLE 4: this url "foo.bar" with old base "http://woohoo/sub/hub/spiffy.htm"
	//    rebased with new base "http://mumble/spiffy.htm"
	//    yields this url "http://woohoo/sub/hub/foo.bar".
	MSOMETHOD (HrRebase) (THIS_ const IMsoUrl *piurlBase) PURE;

	// HrDownload - downloads this url for local data access.  On success, returns the
	//    local path to the downloaded file in wzBuf.  The size of wzBuf is the
	//    input value of pcchBuf, the length of the path put into wzBuf is the
	//    output value of pcchBuf.  The grfurld param is a set of flags used to
	//    control the download (default is 0).
	MSOMETHOD (HrDownload) (THIS_ WCHAR *wzBuf, int *pcchBuf, DWORD grfurld) CONST_METHOD PURE;

	// HrUpload - uploads the file specified in wzFile to the location specified
	//    by this url.  The grfurlu param is a set of flags used to control the
	//    upload (default is 0).
	//    Returns:
	//      S_OK    if the file was uploaded successfuly
	//      S_FALSE if the user cancel the operation (for example, he/she doesn't 
	//                      want to overwrite an existing file)
	//      E_FAIL  generic failure
	MSOMETHOD (HrUpload) (THIS_ const WCHAR *wzFile, DWORD grfurlu) CONST_METHOD PURE;

	// HrDelete - deletes the file specified by this url.
	MSOMETHOD (HrDelete) (THIS) CONST_METHOD PURE;

	// FExists - returns TRUE iff the file exists.  Param grfurle determines
	//    which kind of validation to perform (default is 0 which means do not
	//    check web servers (i.e. http/ftp) & returns FALSE if this url points
	//    to a web server location - to validate against web servers pass the
	//    msofurleCheckServers flag).
	MSOMETHOD_(BOOL, FExists) (THIS_ DWORD grfurle) CONST_METHOD PURE;

	// HrGetBase - returns the base url of this url in ppiurlBase.
	//    Caller must release the returned url when done.
	MSOMETHOD (HrGetBase) (THIS_ const IMsoUrl **ppiurlBase) CONST_METHOD PURE;

 	// FIsMhtml - does the url point to an mhtml file, and in the form "mhtml:X[!Y]" ?
	MSOMETHOD_(BOOL, FIsMhtml) (THIS) CONST_METHOD PURE;

	// Returns the reference to the bodypart this mhtml url is referring to
	MSOMETHOD_(LPCWSTR, WzMhtmlBodypart) (THIS) CONST_METHOD PURE;

	// Returns the cch of the reference to the bodypart this mhtml url is referring to
	MSOMETHOD_(int, CchMhtmlBodypart) (THIS) CONST_METHOD PURE;

	MSOMETHOD_(BPSC, BpscBulletProof) (THIS_ MSOBPCB *pmsobpcb) PURE;

	MSOMETHOD_(ULONG, Free) (THIS) PURE;
};


#ifndef __cplusplus
// IMsoUrl wrapper/convenience functions for C clients
#define IMsoUrl_QueryInterface(this, riid, ppvObj) \
	( (this)->lpVtbl->QueryInterface(this, riid, ppvObj) )
#define IMsoUrl_AddRef(this) \
	( (this)->lpVtbl->AddRef(this) )
#define IMsoUrl_Release(this) \
	( (this)->lpVtbl->Free(this) )
#define IMsoUrl_FValid(this) \
	( (this)->lpVtbl->FValid(this) )
#define IMsoUrl_HrSetFromUser(this, wzUrl, cp, piurlBase, grfurl) \
	( (this)->lpVtbl->HrSetFromUser(this, wzUrl, cp, piurlBase, grfurl) )
#define IMsoUrl_HrSetFromUserRgwch(this, rgwchUrl, cchUrl, cp, piurlBase, grfurl) \
	( (this)->lpVtbl->HrSetFromUserRgwch(this, rgwchUrl, cchUrl, cp, piurlBase, grfurl) )
#define IMsoUrl_HrSetFromCanonicalUrl(this, wzUrl, cp, piurlBase) \
	( (this)->lpVtbl->HrSetFromCanonicalUrl(this, wzUrl, cp, piurlBase) )
#define IMsoUrl_Lock(this) \
	( (this)->lpVtbl->Lock(this) )
#define IMsoUrl_Unlock(this) \
	( (this)->lpVtbl->Unlock(this) )
#define IMsoUrl_HrGetDisplayForm(this, wzBuf, pcchBuf, grfurldf) \
	( (this)->lpVtbl->HrGetDisplayForm(this, wzBuf, pcchBuf, grfurldf) )
#define IMsoUrl_HrGetCanonicalForm(this, wzBuf, pcchBuf) \
	( (this)->lpVtbl->HrGetCanonicalForm(this, wzBuf, pcchBuf) )
#define IMsoUrl_HrGetCustomForm(this, grfurlc, wzBuf, pcchBuf, grfurlcf) \
	( (this)->lpVtbl->HrGetCustomForm(this, grfurlc, wzBuf, pcchBuf, grfurlcf) )
#define IMsoUrl_CpGetCodePage(this) \
	( (this)->lpVtbl->CpGetCodePage(this) )
#define IMsoUrl_WzCanonicalForm(this) \
	( (this)->lpVtbl->WzCanonicalForm(this) )
#define IMsoUrl_CchCanonicalForm(this) \
	( (this)->lpVtbl->CchCanonicalForm(this) )
#define IMsoUrl_UrlsGetScheme(this) \
	( (this)->lpVtbl->UrlsGetScheme(this) )
#define IMsoUrl_HrGetScheme(this, wzBuf, pcchBuf) \
	( (this)->lpVtbl->HrGetScheme(this, wzBuf, pcchBuf) )
#define IMsoUrl_HrGetAuthority(this, wzBuf, pcchBuf) \
	( (this)->lpVtbl->HrGetAuthority(this, wzBuf, pcchBuf) )
#define IMsoUrl_HrGetUserName(this, wzBuf, pcchBuf) \
	( (this)->lpVtbl->HrGetUserName(this, wzBuf, pcchBuf) )
#define IMsoUrl_HrGetPassword(this, wzBuf, pcchBuf) \
	( (this)->lpVtbl->HrGetPassword(this, wzBuf, pcchBuf) )
#define IMsoUrl_HrGetServer(this, wzBuf, pcchBuf) \
	( (this)->lpVtbl->HrGetServer(this, wzBuf, pcchBuf) )
#define IMsoUrl_HrGetPort(this, wzBuf, pcchBuf) \
	( (this)->lpVtbl->HrGetPort(this, wzBuf, pcchBuf) )
#define IMsoUrl_HrGetPath(this, wzBuf, pcchBuf) \
	( (this)->lpVtbl->HrGetPath(this, wzBuf, pcchBuf) )
#define IMsoUrl_HrGetDir(this, wzBuf, pcchBuf) \
	( (this)->lpVtbl->HrGetDir(this, wzBuf, pcchBuf) )
#define IMsoUrl_HrGetFileLeaf(this, wzBuf, pcchBuf) \
	( (this)->lpVtbl->HrGetFileLeaf(this, wzBuf, pcchBuf) )
#define IMsoUrl_HrGetFileName(this, wzBuf, pcchBuf) \
	( (this)->lpVtbl->HrGetFileName(this, wzBuf, pcchBuf) )
#define IMsoUrl_HrGetFileExt(this, wzBuf, pcchBuf) \
	( (this)->lpVtbl->HrGetFileExt(this, wzBuf, pcchBuf) )
#define IMsoUrl_HrGetQuery(this, wzBuf, pcchBuf) \
	( (this)->lpVtbl->HrGetQuery(this, wzBuf, pcchBuf) )
#define IMsoUrl_HrGetFragment(this, wzBuf, pcchBuf) \
	( (this)->lpVtbl->HrGetFragment(this, wzBuf, pcchBuf) )
#define IMsoUrl_RgwchScheme(this, pcch) \
	( (this)->lpVtbl->RgwchScheme(this, pcch) )
#define IMsoUrl_RgwchAuthority(this, pcch) \
	( (this)->lpVtbl->RgwchAuthority(this, pcch) )
#define IMsoUrl_RgwchUserName(this, pcch) \
	( (this)->lpVtbl->RgwchUserName(this, pcch) )
#define IMsoUrl_RgwchPassword(this, pcch) \
	( (this)->lpVtbl->RgwchPassword(this, pcch) )
#define IMsoUrl_RgwchServer(this, pcch) \
	( (this)->lpVtbl->RgwchServer(this, pcch) )
#define IMsoUrl_RgwchPort(this, pcch) \
	( (this)->lpVtbl->RgwchPort(this, pcch) )
#define IMsoUrl_RgwchPath(this, pcch) \
	( (this)->lpVtbl->RgwchPath(this, pcch) )
#define IMsoUrl_RgwchFileLeaf(this, pcch) \
	( (this)->lpVtbl->RgwchFileLeaf(this, pcch) )
#define IMsoUrl_RgwchFileExt(this, pcch) \
	( (this)->lpVtbl->RgwchFileExt(this, pcch) )
#define IMsoUrl_RgwchQuery(this, pcch) \
	( (this)->lpVtbl->RgwchQuery(this, pcch) )
#define IMsoUrl_RgwchFragment(this, pcch) \
	( (this)->lpVtbl->RgwchFragment(this, pcch) )
#define IMsoUrl_FIsHttp(this) \
	( (this)->lpVtbl->FIsHttp(this) )
#define IMsoUrl_FIsFtp(this) \
	( (this)->lpVtbl->FIsFtp(this) )
#define IMsoUrl_FIsLocal(this) \
	( (this)->lpVtbl->FIsLocal(this) )
#define IMsoUrl_FIsUNC(this) \
	( (this)->lpVtbl->FIsUNC(this) )
#define IMsoUrl_FIsODMA(this) \
	( (this)->lpVtbl->FIsODMA(this) )
#define IMsoUrl_HrGetLocalPath(this, wzBuf, pcchBuf) \
	( (this)->lpVtbl->HrGetLocalPath(this, wzBuf, pcchBuf) )
#define IMsoUrl_WzLocalPath(this) \
	( (this)->lpVtbl->WzLocalPath(this) )
#define IMsoUrl_CchLocalPath(this) \
	( (this)->lpVtbl->CchLocalPath(this) )
#define IMsoUrl_FIsEqual(this, piurl) \
	( (this)->lpVtbl->FIsEqual(this, piurl) )
#define IMsoUrl_FComponentsAreEqual(this, grfurlc, piurl) \
	( (this)->lpVtbl->FComponentsAreEqual(this, grfurlc, piurl) )
#define IMsoUrl_FSubsumes(this, piurl) \
	( (this)->lpVtbl->FSubsumes(this, piurl) )
#define IMsoUrl_UrlrGetRelativity(this) \
	( (this)->lpVtbl->UrlrGetRelativity(this) )
#define IMsoUrl_HrSetRelativity(this, urlr) \
	( (this)->lpVtbl->HrSetRelativity(this, urlr) )
#define IMsoUrl_HrResolve(this, ppiurlAbsolute) \
	( (this)->lpVtbl->HrResolve(this, ppiurlAbsolute) )
#define IMsoUrl_HrRebase(this, piurlBase) \
	( (this)->lpVtbl->HrRebase(this, piurlBase) )
#define IMsoUrl_HrDownload(this, wzBuf, pcchBuf, grfurld) \
	( (this)->lpVtbl->HrDownload(this, wzBuf, pcchBuf, grfurld) )
#define IMsoUrl_HrUpload(this, wzFile, grfurlu) \
	( (this)->lpVtbl->HrUpload(this, wzFile, grfurlu) )
#define IMsoUrl_HrDelete(this) \
	( (this)->lpVtbl->HrDelete(this) )
#define IMsoUrl_FExists(this, grfurle) \
	( (this)->lpVtbl->FExists(this, grfurle) )
#define IMsoUrl_HrGetBase(this, ppiurlBase) \
	( (this)->lpVtbl->HrGetBase(this, ppiurlBase) )
#define IMsoUrl_FIsMhtml(this) \
 	( (this)->lpVtbl->FIsMhtml(this) )
#define IMsoUrl_WzMhtmlBodypart(this) \
 	( (this)->lpVtbl->WzMhtmlBodypart(this) )
#define IMsoUrl_CchMhtmlBodypart(this) \
 	( (this)->lpVtbl->CchMhtmlBodypart(this) )
#endif // __cplusplus


// Url Creation APIs
//
// MsoHrCreateUrl - creates an unset url in ppiurl.
// MsoHrCreateUrlFromUser - same as calling MsoHrCreateUrl
//    followed by IMsoUrl::HrSetFromUser.
// MsoHrCreateUrlFromUserRgwch - same as calling MsoHrCreateUrl
//    followed by IMsoUrl::HrSetFromUserRgwch.
// MsoHrCreateUrlFromCanonicalUrl - same as calling MsoHrCreateUrl
//    followed by IMsoUrl::HrSetFromCanonicalUrl.
// MsoHrCloneUrl - creates a new copy of the given url
MSOAPI_(HRESULT) MsoHrCreateUrl(interface IMsoUrl **ppiurl);
MSOAPI_(HRESULT) MsoHrCreateUrlFromUser(interface IMsoUrl **ppiurl,
	const WCHAR *wzUrl, DWORD cp, const IMsoUrl *piurlBase, DWORD grfurl);
MSOAPI_(HRESULT) MsoHrCreateUrlFromUserRgwch(interface IMsoUrl **ppiurl,
	const WCHAR *wzUrl, int cchUrl, DWORD cp, const IMsoUrl *piurlBase, DWORD grfurl);
MSOAPIX_(HRESULT) MsoHrCreateUrlFromCanonicalUrl(interface IMsoUrl **ppiurl,
	const WCHAR *wzUrl, DWORD cp, const IMsoUrl *piurlBase);
MSOAPI_(HRESULT) MsoHrCloneUrl(interface IMsoUrl **ppiurl, const IMsoUrl *piurl);


// Some useful path manipulation APIs
//
// MsoFIsPathSep - returns TRUE iff the character is a recognized path separator
// MsoRgwchPathSepIndex - returns a ptr to the first path sep character
// MsoRgwchPathSepIndexRight - returns a ptr to the last path sep character
__inline MsoFIsPathSep(WCHAR wch) { return wch == L'/' || wch == L'\\'; };
MSOAPIX_(WCHAR*) MsoRgwchPathSepIndex(const WCHAR *rgwch, int cch);
MSOAPI_(WCHAR*) MsoRgwchPathSepIndexRight(const WCHAR *rgwch, int cch);

MSOAPIX_(BOOL) MsoFWzIsResUrl(const WCHAR *wzURL);

// Path buffer constants
#define MSO_MAX_PATH            INTERNET_MAX_URL_LENGTH
#define MSO_CB_MAX_PATH         (MSO_MAX_PATH*sizeof(WCHAR))
#define MSO_MAX_URL_PATH        INTERNET_MAX_URL_LENGTH
#define MSO_CB_MAX_URL_PATH     (MSO_MAX_URL_PATH*sizeof(WCHAR))
#define MSO_MAX_LOCAL_PATH      MAX_PATH
#define MSO_CB_MAX_LOCAL_PATH   (MSO_MAX_LOCAL_PATH*sizeof(WCHAR))


//////////////////////////////////////////////////////////////////////////
//
// OPEN ISSUES:
// 
// 1.  We don't handle default ports in the equivalence comparison.
// 2.  We don't handle "http://server.com" & "http://www.server.com"
//     equivalence correctly.
//
//////////////////////////////////////////////////////////////////////////

#endif // MSOURL_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\Include\VSLComparison.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef VSLCOMPARISON_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define VSLCOMPARISON_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include <VSL.h>

namespace VSL
{

#define _VSL_BINARY_COMPARE(type) \
inline bool operator==(const type& rLeft, const type& rRight) \
{ \
	return (0 == ::memcmp(&rLeft, &rRight, sizeof(type))); \
} \

// Common System Types

#ifndef VSL_VARIANT_EQUIVALENCE_DISP_E_BADVARTYPE_RETURN 
#define VSL_VARIANT_EQUIVALENCE_DISP_E_BADVARTYPE_RETURN false
#endif

inline bool operator==(const VARIANT& rLeft, const VARIANT& rRight)
{
	HRESULT hr = ::VarCmp(const_cast<VARIANT*>(&rLeft), const_cast<VARIANT*>(&rRight), LOCALE_USER_DEFAULT, 0);
	if(DISP_E_BADVARTYPE == hr)
	{
		if(rLeft.vt == rRight.vt)
		{
			if(rLeft.vt == VT_UNKNOWN)
			{
				CComPtr<IUnknown> pIUnknown = rLeft.punkVal;
				return pIUnknown.IsEqualObject(rRight.punkVal);
			}
			// REVIEW - what other cases are needed?
		}
		return VSL_VARIANT_EQUIVALENCE_DISP_E_BADVARTYPE_RETURN;
	}
	return (VARCMP_EQ == static_cast<int>(hr));
}

_VSL_BINARY_COMPARE(ULARGE_INTEGER)
_VSL_BINARY_COMPARE(LARGE_INTEGER)
_VSL_BINARY_COMPARE(CY)
_VSL_BINARY_COMPARE(POINTS)
_VSL_BINARY_COMPARE(POINT)
_VSL_BINARY_COMPARE(POINTL)
_VSL_BINARY_COMPARE(SIZE)
_VSL_BINARY_COMPARE(SYSTEMTIME)
_VSL_BINARY_COMPARE(OLECMDTEXT)
_VSL_BINARY_COMPARE(RECT)
_VSL_BINARY_COMPARE(DISPPARAMS)
_VSL_BINARY_COMPARE(LOGFONTW)
_VSL_BINARY_COMPARE(CUSTDATA)
_VSL_BINARY_COMPARE(EXCEPINFO)
_VSL_BINARY_COMPARE(BINDPTR)
_VSL_BINARY_COMPARE(STATSTG)
_VSL_BINARY_COMPARE(CAUUID)
_VSL_BINARY_COMPARE(FILETIME)
_VSL_BINARY_COMPARE(RPCOLEMESSAGE)
_VSL_BINARY_COMPARE(QACONTROL)
_VSL_BINARY_COMPARE(PROPPAGEINFO)
_VSL_BINARY_COMPARE(PROPBAG2)
_VSL_BINARY_COMPARE(STGMEDIUM)
_VSL_BINARY_COMPARE(CALPOLESTR)
_VSL_BINARY_COMPARE(CADWORD)
_VSL_BINARY_COMPARE(POINTF)
_VSL_BINARY_COMPARE(CONTROLINFO)
_VSL_BINARY_COMPARE(MULTI_QI)
_VSL_BINARY_COMPARE(TEXTMETRICW)
_VSL_BINARY_COMPARE(FORMATETC)
_VSL_BINARY_COMPARE(LICINFO)
_VSL_BINARY_COMPARE(BIND_OPTS)
_VSL_BINARY_COMPARE(STATDATA)
_VSL_BINARY_COMPARE(TLIBATTR)
_VSL_BINARY_COMPARE(MSG)
_VSL_BINARY_COMPARE(OLECMD)
_VSL_BINARY_COMPARE(OLEVERB)
_VSL_BINARY_COMPARE(CONNECTDATA)
_VSL_BINARY_COMPARE(StorageLayout)
_VSL_BINARY_COMPARE(TYPEATTR)
_VSL_BINARY_COMPARE(FUNCDESC)
_VSL_BINARY_COMPARE(VARDESC)
_VSL_BINARY_COMPARE(QACONTAINER)
_VSL_BINARY_COMPARE(LOGPALETTE)
_VSL_BINARY_COMPARE(TYPEDESC)

#ifdef _IMM_
_VSL_BINARY_COMPARE(CANDIDATEFORM)
#endif // _IMM_

#ifdef __olecm_h__
_VSL_BINARY_COMPARE(OLECRINFO)
_VSL_BINARY_COMPARE(OLECHOSTINFO)
#endif // __olecm_h__

// Common Visaul Studio Types
_VSL_BINARY_COMPARE(VSSAVETREEITEM)
_VSL_BINARY_COMPARE(VSOPENFILENAMEW)
_VSL_BINARY_COMPARE(VSSAVEFILENAMEW)
_VSL_BINARY_COMPARE(VSBROWSEINFOW)
_VSL_BINARY_COMPARE(VSSWATCHMETRICS)
_VSL_BINARY_COMPARE(VsPropertyBrowserState)
_VSL_BINARY_COMPARE(VSPROPSHEETPAGE)
_VSL_BINARY_COMPARE(VSTREEDISPLAYDATA)
_VSL_BINARY_COMPARE(VSOBNAVIGATIONINFO2)
_VSL_BINARY_COMPARE(FontInfo)
_VSL_BINARY_COMPARE(ColorableItemInfo)
_VSL_BINARY_COMPARE(AllColorableItemInfo)
_VSL_BINARY_COMPARE(VSITEMSELECTION)
_VSL_BINARY_COMPARE(TBXITEMINFO)
_VSL_BINARY_COMPARE(VSTASKCOLUMN)
_VSL_BINARY_COMPARE(VSCOMPONENTSELECTORDATA)
_VSL_BINARY_COMPARE(VSOBNAVIGATIONINFO3)
_VSL_BINARY_COMPARE(TextSpan)
_VSL_BINARY_COMPARE(VSOBSEARCHCRITERIA2)
_VSL_BINARY_COMPARE(OLEMENUID)
_VSL_BINARY_COMPARE(VSOBJCLIPFORMAT)
_VSL_BINARY_COMPARE(VSTREELISTITEMCHANGE)
_VSL_BINARY_COMPARE(VSDEFAULTPREVIEWER)
_VSL_BINARY_COMPARE(TSHELL_CMD)
_VSL_BINARY_COMPARE(NewSyntheticRegion)
_VSL_BINARY_COMPARE(VSBROWSECONTAINER)
_VSL_BINARY_COMPARE(SYMBOL_DESCRIPTION_NODE)
_VSL_BINARY_COMPARE(VsDebugTargetInfo2)
_VSL_BINARY_COMPARE(NewOutlineRegion)
_VSL_BINARY_COMPARE(NewHiddenRegion)
_VSL_BINARY_COMPARE(VsDebugTargetInfo)
_VSL_BINARY_COMPARE(VSCOMPONENTSELECTORTABINIT)
_VSL_BINARY_COMPARE(COMREFERENCE)
_VSL_BINARY_COMPARE(VSNSEBROWSEINFOW)
_VSL_BINARY_COMPARE(VSDRAWITEMSTRUCT)
_VSL_BINARY_COMPARE(VSSWATCHRENDER)
_VSL_BINARY_COMPARE(VSOBNAVNAMEINFONODE2)
_VSL_BINARY_COMPARE(VSOBSEARCHCRITERIA)
_VSL_BINARY_COMPARE(VSOBNAVNAMEINFONODE)
_VSL_BINARY_COMPARE(VSOBJECTINFO)
_VSL_BINARY_COMPARE(MEINIT)
_VSL_BINARY_COMPARE(VsTextPos)

#ifdef __customfind_h__
_VSL_BINARY_COMPARE(VSBROWSESCOPEW)
#endif

#ifdef __dte_h__
_VSL_BINARY_COMPARE(VxDTE::Project)
#endif // __dte_h__

#ifdef __encbuild_h__
_VSL_BINARY_COMPARE(ENC_EXCEPTION_SPAN)
_VSL_BINARY_COMPARE(ENC_ACTIVE_STATEMENT)
#endif // __encbuild_h__

#ifdef __IVsQueryEditQuerySave2_h__
_VSL_BINARY_COMPARE(VSQEQS_FILE_ATTRIBUTE_DATA)
#endif // __IVsQueryEditQuerySave2_h__

#ifdef __msdbg_h__
_VSL_BINARY_COMPARE(BSTR_ARRAY)
_VSL_BINARY_COMPARE(AD_PROCESS_ID)
_VSL_BINARY_COMPARE(TEXT_POSITION)
_VSL_BINARY_COMPARE(BP_CONDITION)
_VSL_BINARY_COMPARE(BP_PASSCOUNT)
_VSL_BINARY_COMPARE(WATCH_COOKIE)
_VSL_BINARY_COMPARE(PROCESS_LAUNCH_INFO)
_VSL_BINARY_COMPARE(RESUME_COOKIE)
_VSL_BINARY_COMPARE(CONST_GUID_ARRAY)
_VSL_BINARY_COMPARE(COMPUTER_INFO)
_VSL_BINARY_COMPARE(THREADPROPERTIES)
_VSL_BINARY_COMPARE(FRAMEINFO)
_VSL_BINARY_COMPARE(DEBUG_PROPERTY_INFO)
_VSL_BINARY_COMPARE(ENUMERATED_PROCESS_ARRAY)
_VSL_BINARY_COMPARE(REMOTE_PROCESS_INFO)
_VSL_BINARY_COMPARE(DEBUG_REFERENCE_INFO)
_VSL_BINARY_COMPARE(PROVIDER_PROCESS_DATA)
_VSL_BINARY_COMPARE(GUID_ARRAY)
_VSL_BINARY_COMPARE(PROCESS_INFO)
_VSL_BINARY_COMPARE(BP_ERROR_RESOLUTION_INFO)
_VSL_BINARY_COMPARE(PENDING_BP_STATE_INFO)
_VSL_BINARY_COMPARE(NATIVE_EXCEPTION_INFO)
_VSL_BINARY_COMPARE(MODULE_SYMBOL_SEARCH_INFO)
_VSL_BINARY_COMPARE(MACHINE_INFO)
_VSL_BINARY_COMPARE(MODULE_INFO)
_VSL_BINARY_COMPARE(CONTEXT_INFO)
_VSL_BINARY_COMPARE(EXCEPTION_INFO)
_VSL_BINARY_COMPARE(BP_RESOLUTION_INFO)
_VSL_BINARY_COMPARE(BP_REQUEST_INFO2)
_VSL_BINARY_COMPARE(BP_REQUEST_INFO)
_VSL_BINARY_COMPARE(CHECKSUM_DATA)
_VSL_BINARY_COMPARE(DEBUG_CUSTOM_VIEWER)
_VSL_BINARY_COMPARE(JMC_CODE_SPEC)
_VSL_BINARY_COMPARE(CODE_PATH)
_VSL_BINARY_COMPARE(DisassemblyData)
#endif // __msdbg_h__

#ifdef __textmgr_h__
_VSL_BINARY_COMPARE(TextAddress)
_VSL_BINARY_COMPARE(TIPSIZEDATA)
_VSL_BINARY_COMPARE(LINEDATAEX)
_VSL_BINARY_COMPARE(SELECTIONSTATE)
_VSL_BINARY_COMPARE(VIEWPREFERENCES)
_VSL_BINARY_COMPARE(FRAMEPREFERENCES)
_VSL_BINARY_COMPARE(LANGPREFERENCES)
_VSL_BINARY_COMPARE(FONTCOLORPREFERENCES)
_VSL_BINARY_COMPARE(MARKERDATA)
_VSL_BINARY_COMPARE(LINEDATA)
_VSL_BINARY_COMPARE(TabStop)
_VSL_BINARY_COMPARE(ChangeInput)
_VSL_BINARY_COMPARE(BUFFERINITEX)
#endif // __textmgr_h__

#ifdef __singlefileeditor_h__
_VSL_BINARY_COMPARE(ExternalError)
_VSL_BINARY_COMPARE(NewSpanMapping)
_VSL_BINARY_COMPARE(TextSpanAndCookie)
#endif // __singlefileeditor_h__

#ifdef __textmgr2_h__
_VSL_BINARY_COMPARE(FRAMEPREFERENCES2)
_VSL_BINARY_COMPARE(LANGPREFERENCES2)
_VSL_BINARY_COMPARE(FONTCOLORPREFERENCES2)
_VSL_BINARY_COMPARE(SMARTTAGSIZEDATA)
_VSL_BINARY_COMPARE(VIEWPREFERENCES2)
_VSL_BINARY_COMPARE(NewHiddenRegionEx)
#endif // __textmgr2_h__

// NOTE - this can not be an operator <, as one parameter must be of class type for that operatore
inline bool IsStringLessThen(_In_ wchar_t* szIsLessThen, _In_ wchar_t* szThis)
{
	return (0 > ::wcscmp(szIsLessThen, szThis));
}

} // namespace VSL

#endif VSLCOMPARISON_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\Include\VSLCommon.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef VSLCOMMON_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define VSLCOMMON_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

// VSL includes
#include <VSL.h>
#include <VSLErrorHandlers.h>
#include <VSLExceptionHandlers.h>

// STL includes
#include <limits>
#ifndef VSL_DELEGATE_CONTAINER
#include <list>
#define VSL_DELEGATE_CONTAINER(FunctorPtr) std::list< FunctorPtr >
#endif

namespace VSL
{

class TypeNull
{
};

#if 0 // FUTURE - include if needed
template <typename Type_T, const Type_T Default_T>
class TypeWithDefault
{
public:
	typedef Type_T Type;
	inline static Type GetDefault()
	{
		return Default_T;
	}
};
#endif

template <typename PointerType_T>
class PointerWithNullDefault
{

VSL_DECLARE_NONINSTANTIABLE_CLASS(PointerWithNullDefault)

public:

	typedef PointerType_T* Type;

	inline static Type GetDefault()
	{
		return NULL;
	}
};

template <class TypeToCacheWithDefault_T>
class LocalCache
{

VSL_DECLARE_NOT_COPYABLE(LocalCache)

public:
	typedef TypeToCacheWithDefault_T TypeToCacheWithDefault;
	typedef typename TypeToCacheWithDefault::Type CachedType;

	enum { bIsGlobal = 0 };

	LocalCache():
		m_Cached(TypeToCacheWithDefault_T::GetDefault())
	{
	}

	CachedType& Get()
	{
		return m_Cached;
	}

	const CachedType& Get() const
	{
		return m_Cached;
	}

	void Set(const CachedType& rToCache)
	{
		m_Cached = rToCache;
	}

private:

	CachedType m_Cached;

};

template <class TypeToCacheWithDefault_T>
class GlobalCache
{

VSL_DECLARE_NOT_COPYABLE(GlobalCache)

public:
	typedef TypeToCacheWithDefault_T TypeToCacheWithDefault;
	typedef typename TypeToCacheWithDefault::Type CachedType;

	enum
	{
		bIsGlobal = 1, // For run-time
		IsGlobal, // For compile-time
	};

	GlobalCache() {}

	CachedType& Get()
	{
		static CachedType cached = TypeToCacheWithDefault::GetDefault();
		return cached;
	}

	const CachedType& Get() const
	{
		return const_cast<GlobalCache*>(this)->Get();
	}

	void Set(const CachedType& rToCache)
	{
		Get() = rToCache;
	}
};

/*
FUTURE - A thread safe caches could be added.
*/

template <class Unique_T, class Count_T = unsigned int>
class GlobalRefCount
{

VSL_DECLARE_NONINSTANTIABLE_CLASS(GlobalRefCount)

public:

	typedef Count_T Count;

	static Count_T& Get()
	{
		static Count_T iRefCount = 0;
		return iRefCount;
	}

	static bool CanIncrement()
	{
#pragma push_macro("max")
#undef max
		return Get() != std::numeric_limits<Count>::max();
#pragma pop_macro("max")
	}

	static void ErrorIfCanNotIncrement()
	{
		VSL_CHECKBOOLEAN(CanIncrement(), E_UNEXPECTED);
	}

	static bool CanDecrement()
	{
		return Get() != 0;
	}
};

// TODO - Unit test this
template <class T>
class __declspec(uuid("9959BC5B-A014-4f2b-8A04-715FA173A8E2")) __declspec(novtable) IProvideCppClass :
	public IUnknown
{
public:
	virtual T& GetCppClass()
	{
		return *(static_cast<T*>(this));
	}
};

class InterfaceSupportsErrorInfoListTerminator
{

VSL_DECLARE_NONINSTANTIABLE_CLASS(InterfaceSupportsErrorInfoListTerminator)

public:
	static HRESULT InterfaceSupportsErrorInfo(REFIID /*riid*/)
	{
		return S_FALSE;
	}
};

template <class Interface_T, class Next_T = InterfaceSupportsErrorInfoListTerminator>
class InterfaceSupportsErrorInfoList
{

VSL_DECLARE_NONINSTANTIABLE_CLASS(InterfaceSupportsErrorInfoList)

public:

	static HRESULT InterfaceSupportsErrorInfo(REFIID riid)
	{
		if(__uuidof(Interface_T) == riid)
		{
			return S_OK;
		}
		return Next_T::InterfaceSupportsErrorInfo(riid);
	}
};

template <class InterfaceList_T>
class ISupportErrorInfoImpl :
	public ISupportErrorInfo
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(ISupportErrorInfoImpl);

public:

	STDMETHOD(InterfaceSupportsErrorInfo)(REFIID riid)
	{
		return InterfaceList_T::InterfaceSupportsErrorInfo(riid);
	}
};

class CallingConventionStandard
{
public:
	enum 
	{
		StandardCall
	};
};

class CallingConventionDefault
{
public:
	enum 
	{
		Default
	};
};

#define VSL_DECLARE_FUNCTOR_TEMPLATE_ARGS_DEFAULTED typename Return_T = TypeNull, typename Parameter1_T = TypeNull, typename Parameter2_T = TypeNull, typename Parameter3_T = TypeNull
#define VSL_DECLARE_FUNCTOR_TEMPLATE_ARGS typename Return_T, typename Parameter1_T, typename Parameter2_T, typename Parameter3_T
#define VSL_SPECIALIZE_FUNCTOR_TEMPLATE_ARG_PARM1_TO_LAST , Parameter1_T VSL_SPECIALIZE_FUNCTOR_TEMPLATE_ARG_PARM2_TO_LAST
#define VSL_SPECIALIZE_FUNCTOR_TEMPLATE_ARG_PARM2_TO_LAST , Parameter2_T VSL_SPECIALIZE_FUNCTOR_TEMPLATE_ARG_PARM3_TO_LAST
#define VSL_SPECIALIZE_FUNCTOR_TEMPLATE_ARG_PARM3_TO_LAST , Parameter3_T
// Last is always empty as it serves as a place holder should additional parameters need to be added
#define VSL_SPECIALIZE_FUNCTOR_TEMPLATE_ARG_PARM4_TO_LAST

template <VSL_DECLARE_FUNCTOR_TEMPLATE_ARGS_DEFAULTED>
class Functor
{
VSL_DEFINE_NON_DEFAULT_CONSTRUCTABLE_BASE_CLASS_WITH_PROTECTED_COPY(Functor)
};

template <class CallingConvention_T, VSL_DECLARE_FUNCTOR_TEMPLATE_ARGS_DEFAULTED>
class FunctionPointerFunctor
{
VSL_DECLARE_NONINSTANTIABLE_CLASS(FunctionPointerFunctor)
};

template <class Class_T, class CallingConvention_T, VSL_DECLARE_FUNCTOR_TEMPLATE_ARGS_DEFAULTED>
class MemberFunctionPointerFunctor
{
VSL_DECLARE_NONINSTANTIABLE_CLASS(MemberFunctionPointerFunctor)
};

template <VSL_DECLARE_FUNCTOR_TEMPLATE_ARGS_DEFAULTED>
class Delegate
{
VSL_DECLARE_NONINSTANTIABLE_CLASS(Delegate)
};


template <VSL_DECLARE_FUNCTOR_TEMPLATE_ARGS>
class Functor<Return_T () VSL_SPECIALIZE_FUNCTOR_TEMPLATE_ARG_PARM1_TO_LAST>
{

VSL_DEFINE_NON_DEFAULT_CONSTRUCTABLE_BASE_CLASS_WITH_PROTECTED_COPY(Functor)

public:
	virtual Return_T operator()() = 0;
};

template <class CallingConvention_T, VSL_DECLARE_FUNCTOR_TEMPLATE_ARGS>
class FunctionPointerFunctor<CallingConvention_T, Return_T () VSL_SPECIALIZE_FUNCTOR_TEMPLATE_ARG_PARM1_TO_LAST> : 
	public Functor<Return_T ()>
{
private:

	FunctionPointerFunctor();

public:

	// Compiler generated destructor, assignment operator, and copy constructor are fine

	typedef Return_T (*FunctionPointer)();

	virtual Return_T operator()()
	{
		return m_pFunction();
	}

	FunctionPointerFunctor(_In_ FunctionPointer pFunction):
		m_pFunction(VSL_CHECKPOINTER(pFunction, E_POINTER))
	{
	}

private:
	FunctionPointer m_pFunction;
};

template <class Class_T, class CallingConvention_T, VSL_DECLARE_FUNCTOR_TEMPLATE_ARGS>
class MemberFunctionPointerFunctor<Class_T, CallingConvention_T, Return_T () VSL_SPECIALIZE_FUNCTOR_TEMPLATE_ARG_PARM1_TO_LAST> : 
	public Functor<Return_T ()>
{
private:

	MemberFunctionPointerFunctor();

public:

	// Compiler generated destructor, assignment operator, and copy constructor are fine

	__if_exists(CallingConvention_T::StandardCall)
	{
	typedef Return_T (__stdcall	Class_T::*MemberFunctionPointer)();
	}
	__if_not_exists(CallingConvention_T::StandardCall)
	{
	typedef Return_T (Class_T::*MemberFunctionPointer)();
	}

	virtual Return_T operator()()
	{
		return (m_pInstance->*m_pMemberFunction)();
	}

	MemberFunctionPointerFunctor(_In_ Class_T* pInstance, _In_ MemberFunctionPointer pMemberFunction):
		m_pInstance(VSL_CHECKPOINTER(pInstance, E_POINTER)),
		m_pMemberFunction(pMemberFunction) // TODO - test member function pointer isn't NULL
	{
	}

private:
	Class_T* m_pInstance;
	MemberFunctionPointer m_pMemberFunction;
};

template <VSL_DECLARE_FUNCTOR_TEMPLATE_ARGS>
class Delegate<Return_T () VSL_SPECIALIZE_FUNCTOR_TEMPLATE_ARG_PARM1_TO_LAST>
{
public:

	// Compiler generated default constructor, destructor, assignment operator, and copy constructor are fine

	typedef Functor<Return_T ()>* FunctorPtr;
	typedef VSL_DELEGATE_CONTAINER(FunctorPtr) Container;

	bool IsBound()
	{
		return !(m_Container.empty());
	}

	Return_T operator()()
	{
		if(!IsBound())
		{
			VSL_CREATE_ERROR_HRESULT(E_UNEXPECTED);
		}

		Container::const_iterator i = m_Container.begin();
		Container::const_iterator iLast = --(m_Container.end());
		while(i != iLast)
		{
			Container::const_iterator tmp = i;
			++i;
			// tmp may be invalidated after this call as the callee could remove
			// its self
			(**tmp)();
		}

		return (**iLast)();
	}

	void operator+=(_In_ FunctorPtr pFunctor)
	{
		m_Container.push_back(pFunctor);
	}

	void operator-=(_In_ FunctorPtr pFunctor)
	{
		m_Container.remove(pFunctor);
	}

private:
	Container m_Container;
};

template <VSL_DECLARE_FUNCTOR_TEMPLATE_ARGS>
class Functor<Return_T (Parameter1_T) VSL_SPECIALIZE_FUNCTOR_TEMPLATE_ARG_PARM2_TO_LAST>
{

VSL_DEFINE_NON_DEFAULT_CONSTRUCTABLE_BASE_CLASS_WITH_PROTECTED_COPY(Functor)

public:
	virtual Return_T operator()(Parameter1_T parameter1) = 0;
};

template <class CallingConvention_T, VSL_DECLARE_FUNCTOR_TEMPLATE_ARGS>
class FunctionPointerFunctor<CallingConvention_T, Return_T (Parameter1_T) VSL_SPECIALIZE_FUNCTOR_TEMPLATE_ARG_PARM2_TO_LAST> : 
	public Functor<Return_T (Parameter1_T)>
{
private:

	FunctionPointerFunctor();

public:

	// Compiler generated destructor, assignment operator, and copy constructor are fine

	typedef Return_T (*FunctionPointer)(Parameter1_T);
	typedef Functor<Return_T (Parameter1_T)> ThisFunctor;

	virtual Return_T operator()(Parameter1_T parameter1)
	{
		return m_pFunction(parameter1);
	}

	FunctionPointerFunctor(_In_ FunctionPointer pFunction):
		m_pFunction(VSL_CHECKPOINTER(pFunction, E_POINTER))
	{
	}

private:
	FunctionPointer m_pFunction;
};

template <class Class_T, class CallingConvention_T, VSL_DECLARE_FUNCTOR_TEMPLATE_ARGS>
class MemberFunctionPointerFunctor<Class_T, CallingConvention_T, Return_T (Parameter1_T) VSL_SPECIALIZE_FUNCTOR_TEMPLATE_ARG_PARM2_TO_LAST> : 
	public Functor<Return_T (Parameter1_T)>
{
private:

	MemberFunctionPointerFunctor();

public:

	// Compiler generated destructor, assignment operator, and copy constructor are fine

	__if_exists(CallingConvention_T::StandardCall)
	{
	typedef Return_T (__stdcall	Class_T::*MemberFunctionPointer)(Parameter1_T);
	}
	__if_not_exists(CallingConvention_T::StandardCall)
	{
	typedef Return_T (Class_T::*MemberFunctionPointer)(Parameter1_T);
	}

	virtual Return_T operator()(Parameter1_T parameter1)
	{
		return (m_pInstance->*m_pMemberFunction)(parameter1);
	}

	MemberFunctionPointerFunctor(_In_ Class_T* pInstance, _In_ MemberFunctionPointer pMemberFunction):
		m_pInstance(VSL_CHECKPOINTER(pInstance, E_POINTER)),
		m_pMemberFunction(pMemberFunction)  // TODO - test member function pointer isn't NULL
	{
	}

private:
	Class_T* m_pInstance;
	MemberFunctionPointer m_pMemberFunction;
};

template <VSL_DECLARE_FUNCTOR_TEMPLATE_ARGS>
class Delegate<Return_T (Parameter1_T) VSL_SPECIALIZE_FUNCTOR_TEMPLATE_ARG_PARM2_TO_LAST>
{
public:

	// Compiler generated default constructor, destructor, assignment operator, and copy constructor are fine

	typedef Functor<Return_T (Parameter1_T)>* FunctorPtr;
	typedef VSL_DELEGATE_CONTAINER(FunctorPtr) Container;

	bool IsBound()
	{
		return !(m_Container.empty());
	}

	Return_T operator()(Parameter1_T parameter1)
	{
		if(!IsBound())
		{
			VSL_CREATE_ERROR_HRESULT(E_UNEXPECTED);
		}

		Container::const_iterator i = m_Container.begin();
		Container::const_iterator iLast = --(m_Container.end());
		while(i != iLast)
		{
			Container::const_iterator tmp = i;
			++i;
			// tmp may be invalidated after this call as the callee could remove
			// its self
			(**tmp)(parameter1);
		}

		return (**iLast)(parameter1);
	}

	void operator+=(_In_ FunctorPtr pFunctor)
	{
		m_Container.push_back(pFunctor);
	}

	void operator-=(_In_ FunctorPtr pFunctor)
	{
		m_Container.remove(pFunctor);
	}

private:
	Container m_Container;
};

template <VSL_DECLARE_FUNCTOR_TEMPLATE_ARGS>
class Functor<Return_T (Parameter1_T, Parameter2_T) VSL_SPECIALIZE_FUNCTOR_TEMPLATE_ARG_PARM3_TO_LAST>
{

VSL_DEFINE_NON_DEFAULT_CONSTRUCTABLE_BASE_CLASS_WITH_PROTECTED_COPY(Functor)

public:
	virtual Return_T operator()(Parameter1_T parameter1, Parameter2_T parameter2) = 0;
};

template <class CallingConvention_T, VSL_DECLARE_FUNCTOR_TEMPLATE_ARGS>
class FunctionPointerFunctor<CallingConvention_T, Return_T (Parameter1_T, Parameter2_T) VSL_SPECIALIZE_FUNCTOR_TEMPLATE_ARG_PARM3_TO_LAST> : 
	public Functor<Return_T (Parameter1_T, Parameter2_T)>
{
private:

	FunctionPointerFunctor();

public:

	// Compiler generated destructor, assignment operator, and copy constructor are fine

	typedef Return_T (*FunctionPointer)(Parameter1_T, Parameter2_T);
	typedef Functor<Return_T (Parameter1_T, Parameter2_T)> ThisFunctor;

	virtual Return_T operator()(Parameter1_T parameter1, Parameter2_T parameter2)
	{
		return m_pFunction(parameter1, parameter2);
	}

	FunctionPointerFunctor(_In_ FunctionPointer pFunction):
		m_pFunction(VSL_CHECKPOINTER(pFunction, E_POINTER))
	{
	}

private:
	FunctionPointer m_pFunction;
};

template <class Class_T, class CallingConvention_T, VSL_DECLARE_FUNCTOR_TEMPLATE_ARGS>
class MemberFunctionPointerFunctor<Class_T, CallingConvention_T, Return_T (Parameter1_T, Parameter2_T) VSL_SPECIALIZE_FUNCTOR_TEMPLATE_ARG_PARM3_TO_LAST> : 
	public Functor<Return_T (Parameter1_T, Parameter2_T)>
{
private:

	MemberFunctionPointerFunctor();

public:

	// Compiler generated destructor, assignment operator, and copy constructor are fine

	__if_exists(CallingConvention_T::StandardCall)
	{
	typedef Return_T (__stdcall	Class_T::*MemberFunctionPointer)(Parameter1_T, Parameter2_T);
	}
	__if_not_exists(CallingConvention_T::StandardCall)
	{
	typedef Return_T (Class_T::*MemberFunctionPointer)(Parameter1_T, Parameter2_T);
	}

	virtual Return_T operator()(Parameter1_T parameter1, Parameter1_T parameter2)
	{
		return (m_pInstance->*m_pMemberFunction)(parameter1, parameter2);
	}

	MemberFunctionPointerFunctor(_In_ Class_T* pInstance, _In_ MemberFunctionPointer pMemberFunction):
		m_pInstance(VSL_CHECKPOINTER(pInstance, E_POINTER)),
		m_pMemberFunction(pMemberFunction)  // TODO - test member function pointer isn't NULL
	{
	}

private:
	Class_T* m_pInstance;
	MemberFunctionPointer m_pMemberFunction;
};

template <VSL_DECLARE_FUNCTOR_TEMPLATE_ARGS>
class Delegate<Return_T (Parameter1_T, Parameter2_T) VSL_SPECIALIZE_FUNCTOR_TEMPLATE_ARG_PARM3_TO_LAST>
{
public:

	// Compiler generated default constructor, destructor, assignment operator, and copy constructor are fine

	typedef Functor<Return_T (Parameter1_T, Parameter2_T)>* FunctorPtr;
	typedef VSL_DELEGATE_CONTAINER(FunctorPtr) Container;

	bool IsBound()
	{
		return !(m_Container.empty());
	}

	Return_T operator()(Parameter1_T parameter1, Parameter2_T parameter2)
	{
		if(!IsBound())
		{
			VSL_CREATE_ERROR_HRESULT(E_UNEXPECTED);
		}

		Container::const_iterator i = m_Container.begin();
		Container::const_iterator iLast = --(m_Container.end());
		while(i != iLast)
		{
			Container::const_iterator tmp = i;
			++i;
			// tmp may be invalidated after this call as the callee could remove
			// its self
			(**tmp)(parameter1, parameter2);
		}

		return (**iLast)(parameter1, parameter2);
	}

	void operator+=(_In_ FunctorPtr pFunctor)
	{
		m_Container.push_back(pFunctor);
	}

	void operator-=(_In_ FunctorPtr pFunctor)
	{
		m_Container.remove(pFunctor);
	}

private:
	Container m_Container;
};


template <VSL_DECLARE_FUNCTOR_TEMPLATE_ARGS>
class Functor<Return_T (Parameter1_T, Parameter2_T, Parameter3_T) VSL_SPECIALIZE_FUNCTOR_TEMPLATE_ARG_PARM4_TO_LAST>
{

VSL_DEFINE_NON_DEFAULT_CONSTRUCTABLE_BASE_CLASS_WITH_PROTECTED_COPY(Functor)

public:
	virtual Return_T operator()(Parameter1_T parameter1, Parameter2_T parameter2, Parameter3_T parameter3) = 0;
};

template <class CallingConvention_T, VSL_DECLARE_FUNCTOR_TEMPLATE_ARGS>
class FunctionPointerFunctor<CallingConvention_T, Return_T (Parameter1_T, Parameter2_T, Parameter3_T) VSL_SPECIALIZE_FUNCTOR_TEMPLATE_ARG_PARM4_TO_LAST> : 
	public Functor<Return_T (Parameter1_T, Parameter2_T, Parameter3_T)>
{
private:

	FunctionPointerFunctor();

public:

	// Compiler generated destructor, assignment operator, and copy constructor are fine

	typedef Return_T (*FunctionPointer)(Parameter1_T, Parameter2_T, Parameter3_T);
	typedef Functor<Return_T (Parameter1_T, Parameter2_T, Parameter3_T)> ThisFunctor;

	virtual Return_T operator()(Parameter1_T parameter1, Parameter2_T parameter2, Parameter3_T parameter3)
	{
		return m_pFunction(parameter1, parameter2, parameter3);
	}

	FunctionPointerFunctor(_In_ FunctionPointer pFunction):
		m_pFunction(VSL_CHECKPOINTER(pFunction, E_POINTER))
	{
	}

private:
	FunctionPointer m_pFunction;
};

template <class Class_T, class CallingConvention_T, VSL_DECLARE_FUNCTOR_TEMPLATE_ARGS>
class MemberFunctionPointerFunctor<Class_T, CallingConvention_T, Return_T (Parameter1_T, Parameter2_T, Parameter3_T) VSL_SPECIALIZE_FUNCTOR_TEMPLATE_ARG_PARM4_TO_LAST> : 
	public Functor<Return_T (Parameter1_T, Parameter2_T, Parameter3_T)>
{
private:

	MemberFunctionPointerFunctor();

public:

	// Compiler generated destructor, assignment operator, and copy constructor are fine

	__if_exists(CallingConvention_T::StandardCall)
	{
	typedef Return_T (__stdcall	Class_T::*MemberFunctionPointer)(Parameter1_T, Parameter2_T, Parameter3_T);
	}
	__if_not_exists(CallingConvention_T::StandardCall)
	{
	typedef Return_T (Class_T::*MemberFunctionPointer)(Parameter1_T, Parameter2_T, Parameter3_T);
	}

	virtual Return_T operator()(Parameter1_T parameter1, Parameter2_T parameter2, Parameter3_T parameter3)
	{
		return (m_pInstance->*m_pMemberFunction)(parameter1, parameter2, parameter3);
	}

	MemberFunctionPointerFunctor(_In_ Class_T* pInstance, _In_ MemberFunctionPointer pMemberFunction):
		m_pInstance(VSL_CHECKPOINTER(pInstance, E_POINTER)),
		m_pMemberFunction(pMemberFunction)  // TODO - test member function pointer isn't NULL
	{
	}

private:
	Class_T* m_pInstance;
	MemberFunctionPointer m_pMemberFunction;
};

template <VSL_DECLARE_FUNCTOR_TEMPLATE_ARGS>
class Delegate<Return_T (Parameter1_T, Parameter2_T, Parameter3_T) VSL_SPECIALIZE_FUNCTOR_TEMPLATE_ARG_PARM4_TO_LAST>
{
public:

	// Compiler generated default constructor, destructor, assignment operator, and copy constructor are fine

	typedef Functor<Return_T (Parameter1_T, Parameter2_T, Parameter3_T)>* FunctorPtr;
	typedef VSL_DELEGATE_CONTAINER(FunctorPtr) Container;

	bool IsBound()
	{
		return !(m_Container.empty());
	}

	Return_T operator()(Parameter1_T parameter1, Parameter2_T parameter2, Parameter3_T parameter3)
	{
		if(!IsBound())
		{
			VSL_CREATE_ERROR_HRESULT(E_UNEXPECTED);
		}

		Container::const_iterator i = m_Container.begin();
		Container::const_iterator iLast = --(m_Container.end());
		while(i != iLast)
		{
			Container::const_iterator tmp = i;
			++i;
			// tmp may be invalidated after this call as the callee could remove
			// its self
			(**tmp)(parameter1, parameter2, parameter3);
		}

		return (**iLast)(parameter1, parameter2, parameter3);
	}

	void operator+=(_In_ FunctorPtr pFunctor)
	{
		m_Container.push_back(pFunctor);
	}

	void operator-=(_In_ FunctorPtr pFunctor)
	{
		m_Container.remove(pFunctor);
	}

private:
	Container m_Container;
};

class CoTaskMemPointerTraits
{
public:
	typedef LPVOID PointerType;
	typedef CoTaskMemPointerTraits Allocator;
	typedef CoTaskMemPointerTraits Values;
	typedef CoTaskMemPointerTraits Cloner;
	static LPVOID GetNullValue()
	{
		return NULL;
	}
	static LPVOID InitializeFromPointerType(_In_ LPVOID pVoid)
	{
		return pVoid;
	}
	static void Free(_In_ LPVOID pVoid)
	{
		::CoTaskMemFree(pVoid);
	}
};

template <class Type_T>
class StdArrayPointerTraits
{
public:
	typedef Type_T* PointerType;
	typedef StdArrayPointerTraits Allocator;
	typedef StdArrayPointerTraits Values;
	typedef StdArrayPointerTraits Cloner;
	static Type_T* GetNullValue()
	{
		return NULL;
	}
	static Type_T* InitializeFromPointerType(_In_ Type_T* pArray)
	{
		return pArray;
	}
	static void Free(_In_ Type_T* pArray)
	{
		delete [] pArray;
	}
	static void AssignFromPointerType(Type_T*& rpAssignTo, _In_ Type_T* pAssignFrom)
	{
		VSL_CHECKBOOLEAN(rpAssignTo != pAssignFrom, E_UNEXPECTED);
		if(rpAssignTo != GetNullValue())
		{
			Free(rpAssignTo);
		}
		rpAssignTo = pAssignFrom;
	}
};

// TODO - 2/2/2006 - specific unit test this (it is currently covered by DocumentPersistanceBaseTest)
template<class PointerTraits_T>
class Pointer
{
public:
	typedef typename PointerTraits_T::PointerType PointerType;
	typedef typename PointerTraits_T::Values Values;
	typedef typename PointerTraits_T::Allocator Allocator;
	typedef typename PointerTraits_T::Cloner Cloner;

	Pointer():
		m_p(Values::GetNullValue())
	{
	}

	Pointer(PointerType p):
		m_p(Cloner::InitializeFromPointerType(p))
	{
	}

// This is done, as we can't have two copies of a method under different
// __if_exists (get a multiply defined error if that is tried)
private:
__if_exists(Cloner::Clone)
{
public:
}

	Pointer(Pointer& rToCopy)
	{
		__if_exists(Cloner::Clone)
		{
		Cloner::Clone(m_p, rToCopy.m_p);
		}
	}

public:

	~Pointer()
	{
		Free();
	}

private:
__if_exists(Cloner::AssignFromPointerType)
{
public:
}
	const Pointer& operator=(PointerType p)
	{
		__if_exists(Cloner::AssignFromPointerType)
		{
		Cloner::AssignFromPointerType(m_p, p);
		}
		return *this;
	}

private:
__if_exists(Cloner::Clone)
{
public:
}
	const Pointer& operator=(Pointer& rToCopy)
	{
		__if_exists(Cloner::Clone)
		{
		Cloner::Clone(m_p, rToCopy.m_p);
		}
		return *this;
	}

public:

	void Free()
	{
		if(Values::GetNullValue() != m_p)
		{
			Allocator::Free(m_p);
			m_p = Values::GetNullValue();
		}
	}

	PointerType Detach()
	{
		PointerType p = m_p;
		m_p = Values::GetNullValue();
		return p;
	}

	operator PointerType() const
	{
		return m_p;
	}

__if_exists(PointerType::bProvideAddressOfOperator)
{
	PointerType* operator &()
	{
		return &m_p;
	}
}

	PointerType operator->() const
	{
		return m_p;
	}

	// FUTURE - 2/2/2006 - add Attach, operator*(), operator&(), operator->(), operator!(), operator<, operator!=, operator==

private:
	PointerType m_p;
};

typedef Pointer<CoTaskMemPointerTraits> CoTaskMemPointer;

template<class ResourceTraits_T>
class Resource
{

// FUTURE - 2/2/2006 - make this copyable
VSL_DECLARE_NOT_COPYABLE(Resource)

public:
	typedef typename ResourceTraits_T::ResourceType ResourceType;
	typedef typename ResourceTraits_T::CastType CastType;
	typedef typename ResourceTraits_T::Values Values;
	typedef typename ResourceTraits_T::Allocator Allocator;
	typedef typename ResourceTraits_T::Cloner Cloner;

	Resource():
		m_Resource(Values::GetNullValue())
	{
	}

	Resource(_In_ ResourceType resource):
		m_Resource(resource)
	{
	}

	~Resource()
	{
		Free();
	}

	void Free()
	{
		if(Values::GetNullValue() != m_Resource)
		{
			Allocator::Free(m_Resource);
			m_Resource = Values::GetNullValue();
		}
	}

	ResourceType Detach()
	{
		ResourceType resource = m_Resource;
		m_Resource = Values::GetNullValue();
		return resource;
	}

	operator CastType() const
	{
		return Values::CastToResource(m_Resource);
	}

	// FUTURE - 3/8/2006 - add Attach, operator!(), operator!=, operator==

private:
	ResourceType m_Resource;
};

class LibraryResourceTraits
{
public:
	typedef HMODULE ResourceType;
	typedef HMODULE CastType;
	typedef LibraryResourceTraits Allocator;
	typedef LibraryResourceTraits Values;
	typedef LibraryResourceTraits Cloner;
	static HMODULE GetNullValue()
	{
		return NULL;
	}
	static void Free(_In_ HMODULE hLibrary)
	{
		::FreeLibrary(hLibrary);
	}
	static HMODULE CastToResource(_In_ HMODULE hLibrary)
	{
		return hLibrary;
	}
};

class Library
{
private:

VSL_DECLARE_NOT_COPYABLE(Library);

	// FUTURE - default construction could be supported
	Library();

public:
	Library(_In_z_ wchar_t* szLibrary):
		m_hLibrary(reinterpret_cast<HMODULE>(VSL_CHECKHANDLE_GLE(::LoadLibrary(szLibrary))))
	{
	}

	// The compiler generated destructor is fine

	// FUTURE - 3/8/2006 - can add additional wrapper methods

private:
	Resource<LibraryResourceTraits> m_hLibrary;
};

#define VSL_DEFINE_IUNKNOWN_NOTIMPL \
	STDMETHOD(QueryInterface)(REFIID, void**) { return E_NOTIMPL; } \
	virtual ULONG STDMETHODCALLTYPE AddRef() { return 0; } \
	virtual ULONG STDMETHODCALLTYPE Release() { return 0; }

} // namespace VSL

#endif // VSLCOMMON_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\Include\VSLControls.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef VSLCONTROLS_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define VSLCONTROLS_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include <VSL.h>
#include <VSLWindows.h>
#include <mscomctl.h>

namespace VSL
{

// FUTURE - support LVS_OWNERDATA

template<
	bool AllowLabelEditing_T = true,
	bool AllowMultiselection_T = true,
	bool AlwaysShowSelection_T = true,
	bool Sort_T = true,
	bool SortAsceneding_T = true,
	bool HasColumnHeader_T = true,
	bool ColumnHeaderDoesNotActAsButton_T = true>
class ReportViewTraits
{

VSL_DECLARE_NONINSTANTIABLE_CLASS(ReportViewTraits)

public:
	enum {
		ReportView
	};

	static const bool AllowMultiselection = AllowMultiselection_T;

	static unsigned short GetStyle()
	{
		unsigned short style = LVS_REPORT;
		style |= AllowLabelEditing_T ? LVS_EDITLABELS : 0;
		style |= AllowMultiselection_T ? 0 : LVS_SINGLESEL;
		style |= AlwaysShowSelection_T ? LVS_SHOWSELALWAYS : 0;
		style |= Sort_T ? (SortAsceneding_T ? LVS_SORTASCENDING : LVS_SORTDESCENDING) : 0;
		style |= HasColumnHeader_T ? 0 : LVS_NOCOLUMNHEADER;
		style |= ColumnHeaderDoesNotActAsButton_T ? LVS_NOSORTHEADER : 0;
		return style;
	}
};

template <class Traits_T = ReportViewTraits<>, class WindowBase_T = Window<> >
class ListViewWin32Control :
	public WindowBase_T
{

VSL_DECLARE_NOT_COPYABLE(ListViewWin32Control)

public:

	class SubWindow
	{
	protected:
		SubWindow(const WindowBase_T& listView, unsigned int iIndex = 0):
			m_iIndex(iIndex),
			m_rListView(listView)
		{
		}

		template<class LPARAM_T>
		LRESULT SendMessage(UINT uMsg, LPARAM_T lParam)
		{
			// C-style cast used here as it can function as both static_cast and reinterpret_cast
			return m_rListView.SendMessage(uMsg, m_iIndex, (LPARAM)lParam);
		}

		unsigned int m_iIndex;
		const WindowBase_T& m_rListView;
	};

__if_exists(Traits_T::ReportView)
{
	class Column :
		protected SubWindow
	{
	private:
		Column();
	public:
		Column(const WindowBase_T& listView, unsigned int iIndex = 0):
			SubWindow(listView, iIndex)
		{
		}

		WORD GetWidth()
		{
			LRESULT lRes = SendMessage(LVM_GETCOLUMNWIDTH, 0);
#if 0 // TODO - enable after unit testing can be accomplished with this check in place
			VSL_CHECKBOOLEAN(lRes >= 0, E_FAIL);
#endif
			return static_cast<WORD>(lRes);
		}

		void SetWidth(WORD width)
		{
			LRESULT lRes = SendMessage(LVM_SETCOLUMNWIDTH, MAKELPARAM(width, 0));
#if 0 // TODO - enable after unit testing can be accomplished with this check in place
			VSL_CHECKBOOLEAN(lRes == TRUE, E_FAIL);
#else
			(lRes);
#endif
		}
	};
}

	class Item :
		protected SubWindow
	{
	private:
		Item();
	public:

		Item(const WindowBase_T& listView, unsigned int iIndex = 0):
			SubWindow(listView, iIndex)
		{
		}

		Item(const WindowBase_T& listView, const LVFINDINFO& rFindInfo, int iStartIndex = -1):
			SubWindow(listView)
		{
			LRESULT lRes = m_rListView.SendMessage(LVM_FINDITEM, iStartIndex, &rFindInfo);
			VSL_CHECKBOOLEAN(lRes != -1, E_FAIL);
			m_iIndex  = static_cast<unsigned int>(lRes);
		}

		unsigned int GetIndex()
		{
			return m_iIndex;
		}

		bool IsSelected()
		{
			LRESULT lRes = SendMessage(LVM_GETITEMSTATE, LVIS_SELECTED);
			return lRes & LVIS_SELECTED;
		}

		void Select()
		{
			LVITEM item	=
			{
				LVIF_STATE,
				m_iIndex,
				0,
				LVIS_SELECTED,
				0,
				0,
				0,
				0,
				0
			};

			if(!Traits_T::AllowMultiselection)
			{
				// Since this is a single selection list, we want to set the item to be both
				// selected and focused.
				item.state |= LVIS_FOCUSED;
			}

			item.stateMask = item.state;

			LRESULT lRes = SendMessage(LVM_SETITEMSTATE, &item);
#if 0 // TODO - enable after unit testing can be accomplished with this check in place
			VSL_CHECKBOOLEAN(lRes == TRUE, E_FAIL);
#else
			(lRes);
#endif
		}

		void GetText(CStringW& rstrText)
		{
			LVITEM item	=
			{
				LVIF_TEXT,
				m_iIndex,
				0,
				0,
				0,
				rstrText.GetBuffer(),
				// add one for null terminator, as list view will null terminate
				rstrText.GetAllocLength() + 1,
				0,
				0
			};

			LRESULT lRes = SendMessage(LVM_GETITEMTEXT, &item);
			VSL_CHECKBOOLEAN(lRes >= 0, E_FAIL);

			// Now update the CString so that it know how many characters it has currently
			// The ugliness below is because CStringW doesn't expose a proper way to do this
			(reinterpret_cast<CStringData*>(const_cast<wchar_t*>(rstrText.GetString()))-1)->nDataLength = static_cast<int>(lRes);
		}

		unsigned int operator++()
		{
			return ++m_iIndex;
		}
	};

	ListViewWin32Control():
		WindowBase_T()
	{
	}

	// The compiler generated destructor is fine

	void Create(HWND hwndParent, unsigned short iControlID, _U_RECT rect = NULL)
	{
		WindowBase_T::Create(
			WC_LISTVIEW,
			hwndParent,
			rect,
			NULL, 
			WS_CHILD | Traits_T::GetStyle(),
			0,
			reinterpret_cast<HMENU>(iControlID));
	}

__if_exists(Traits_T::ReportView)
{
	template <class StdContainer_T>
	void SetColumns(const StdContainer_T& columns)
	{
		StdContainer_T::const_iterator column = columns.begin();
		for(int i = 0; column < columns.end(); ++column, ++i)
		{
			LRESULT lRes = SendMessage(LVM_INSERTCOLUMN, i, static_cast<LVCOLUMN*>(*column));
			VSL_CHECKBOOLEAN(lRes == i, E_FAIL);
		}
	}
}

	template <class StdContainer_T>
	void SetItems(const StdContainer_T& items)
	{
		//Clear the items first
		ClearItems();

		for(StdContainer_T::const_iterator item = items.begin(); item < items.end(); ++item)
		{
			LRESULT lRes = SendMessage(LVM_INSERTITEM, 0, static_cast<LVITEM*>(*item));
#if 0 // TODO - enable after unit testing can be accomplished with this check in place
			VSL_CHECKBOOLEAN(lRes == (*item)->iItem, E_FAIL);
#endif
			(lRes);
		}
	}

	unsigned int GetItemCount()
	{
		LRESULT lRes = SendMessage(LVM_GETITEMCOUNT, 0, 0);
		VSL_CHECKBOOLEAN(lRes >= 0, E_FAIL);
		return static_cast<unsigned int>(lRes);
	}

private:

	// FUTURE - this could be made public
	void ClearItems()
	{
		LRESULT lRes = SendMessage(LVM_DELETEALLITEMS, 0, 0);
#if 0 // TODO - enable after unit testing can be accomplished with this check in place
		VSL_CHECKBOOLEAN(lRes == TRUE, E_FAIL);
#else
		(lRes);
#endif
	}
};

#ifdef _RICHEDIT_

class RichEditAsWindowTraits
{

VSL_DECLARE_NONINSTANTIABLE_CLASS(RichEditAsWindowTraits)

public:
	static long GetStyle()
	{
		return WS_CLIPSIBLINGS | WS_VISIBLE | WS_VSCROLL | WS_HSCROLL | ES_MULTILINE | ES_AUTOVSCROLL | ES_AUTOHSCROLL | ES_WANTRETURN | ES_NOHIDESEL;
	}

	static LPARAM GetEvents()
	{
		return ENM_SELCHANGE | ENM_CHANGE | ENM_MOUSEEVENTS | EN_DROPFILES | ENM_KEYEVENTS;
	}
};

template <class Traits_T = RichEditAsWindowTraits, class WindowBase_T = Window<> >
class RichEditWin32Control :
	public WindowBase_T
{

VSL_DECLARE_NOT_COPYABLE(RichEditWin32Control)

public:

	typedef WindowBase_T Window;
	typedef RichEditWin32Control This;

	RichEditWin32Control():
		WindowBase_T()
	{
	}

	// The compiler generated destructor is fine

	void Create(_In_ HWND hwndParent, unsigned short iControlID, _U_RECT rect = NULL)
	{
		// Need to load riched20.dll before trying to create RICHEDIT_CLASS
		static Library richEdit20(L"RichEd20.dll");

		WindowBase_T::Create(
			RICHEDIT_CLASS,
			hwndParent,
			rect,
			NULL, 
			WS_CHILD | Traits_T::GetStyle(),
			0,
			reinterpret_cast<HMENU>(iControlID));

		SendMessage(EM_SETEVENTMASK, 0, Traits_T::GetEvents());

		CComPtr<IUnknown> spIUnknown;
	    SendMessage(EM_GETOLEINTERFACE, 0, &spIUnknown);
		VSL_CHECKPOINTER(spIUnknown.p, E_FAIL);
		VSL_CHECKHRESULT(spIUnknown->QueryInterface(IID_ITextDocument, reinterpret_cast<void**>(&m_spITextDocument)));
		VSL_CHECKPOINTER(m_spITextDocument.p, E_FAIL);
	}

	void Destroy()
	{
		m_spITextDocument.Release();
	}

	// Caller is responsible for AddRef and Release as appropriate
	ITextDocument* GetITextDocument()
	{
		return m_spITextDocument;
	}

	unsigned int GetLineFromIndex(unsigned int iIndex)
	{
		int result = static_cast<int>(SendMessage(EM_EXLINEFROMCHAR, 0, iIndex));
		VSL_CHECKBOOLEAN(result >= 0, E_FAIL);
		return static_cast<unsigned int>(result);
	}

	unsigned int GetCharacterPositionFromIndex(unsigned int iIndex)
	{
		// First get the index of the current line
		const WPARAM CurrentLine = static_cast<WPARAM>(-1);
		int result = static_cast<int>(SendMessage(EM_LINEINDEX, CurrentLine, 0));
		VSL_CHECKBOOLEAN(result >= 0, E_FAIL);
		// Then subtract the index of the current line from the current index to get the character position
		return iIndex - static_cast<unsigned int>(result);
	}

	int GetIndexFromLineAndCharacter(unsigned int iLine, unsigned int iCharacter)
	{
		// To determine the index given it's line and column, we need to sum
		// up all the characters on the lines preceding iLine, then add on iCharacter
		int iIndex = 0;
		int iSumOfPreviousLineLength = 0;
		for(unsigned int i = 0; i < iLine; ++i)
		{
			// EM_LINELENGTH requires the index of a character in a line whose
			// length is to be retrieved, so pass the index of the first character in the line
			iIndex += static_cast<int>(SendMessage(EM_LINELENGTH, iSumOfPreviousLineLength, 0));
			iIndex += 1; // Add one for the line ending
			iSumOfPreviousLineLength = iIndex;
		}

		// Ensure that the given character position is valid on the given line
		// iLineLength doesn't include the line ending
		unsigned int iLineLength = static_cast<int>(SendMessage(EM_LINELENGTH, iSumOfPreviousLineLength , 0));

        if( iCharacter < 0
			|| iCharacter > iLineLength)
		{
			return -1;
		}

		iIndex += iCharacter;

		return iIndex;
	}

	unsigned int GetLineLength(unsigned int iLine)
	{
		// Convert the line number into an index equivalent
		int iIndex = GetIndexFromLineAndCharacter(iLine, 0);
		// Now use that index to get the actual line length
		return static_cast<unsigned int>(SendMessage(EM_LINELENGTH, iIndex, 0));
	}

	unsigned int GetLineCount()
	{
		return static_cast<unsigned int>(SendMessage(EM_GETLINECOUNT, 0, 0));
	}

	// Returns the string for a line, including the line ending.
	unsigned int GetLineText(unsigned int iLine, Pointer<StdArrayPointerTraits<WCHAR> >& rpText)
	{
		// Get the line length inorder to create a string array that is big enough to hold the entire line
		long iLength = GetLineLength(iLine);
		iLength += 2; // Save one space for EOL and one space for NULL

		rpText = new WCHAR[iLength];
		WCHAR* szText = rpText;
		// EM_GETLINE expects the first word to be set to the buffer size
		reinterpret_cast<WORD *>(szText)[0] = static_cast<WORD>(iLength);
		int iCharactersCopied = static_cast<int>(SendMessage(EM_GETLINE, iLine, szText));

		if( iCharactersCopied > 0 &&
			iCharactersCopied == (iLength - 1))  // -1 for the line ending
		{
			szText[iLength-1] = L'\0';
		}

		return iCharactersCopied;
	}

	void SetSelection(int iStartIndex, int iEndIndex)
	{
		SendMessage(EM_SETSEL, iStartIndex, iEndIndex);
	}

	void SetReadOnly(bool bReadOnly)
	{
		SendMessage(EM_SETREADONLY, bReadOnly, 0);
	}

	void Undo()
	{
		SendMessage(EM_UNDO, 0, 0);
	}

	void SetModified(bool bModified)
	{
		SendMessage(EM_SETMODIFY, bModified, 0);
	}

	void SetCharacterFormat(const CHARFORMATW& rCharacterFormat)
	{
	    SendMessage(EM_SETCHARFORMAT, SCF_SELECTION, &rCharacterFormat);
	}

	class SuspendDrawAndNotifications
	{

	VSL_DECLARE_NOT_COPYABLE(SuspendDrawAndNotifications)

	public:

		SuspendDrawAndNotifications(This& rThis):
			m_rThis(rThis)
		{
			// Turn off drawing
			m_rThis.SendMessage(WM_SETREDRAW, FALSE, 0);

			// Turn notifications notifications off
			m_dwMaskToRestore = static_cast<DWORD>(m_rThis.SendMessage(EM_SETEVENTMASK, 0, ENM_NONE));
		}

		~SuspendDrawAndNotifications()
		{
			// Turn notifications back on
			m_rThis.SendMessage(EM_SETEVENTMASK, 0, m_dwMaskToRestore);

			// Turn on drawing
			m_rThis.SendMessage(WM_SETREDRAW, TRUE, 0);
		}
	private:
		This& m_rThis;
		DWORD m_dwMaskToRestore;
	};

private:

	CComPtr<ITextDocument> m_spITextDocument;
};

#endif // _RICHEDIT_

// TODO - 6/14/2006 - move this elsewhere
class IconResourceTraits
{
public:
	typedef std::pair<HICON, bool> ResourceType;
	typedef HICON CastType;
	typedef IconResourceTraits Allocator;
	typedef IconResourceTraits Values;
	typedef IconResourceTraits Cloner;
	static std::pair<HICON, bool> GetNullValue()
	{
		return std::pair<HICON, bool>(static_cast<HICON>(NULL), true);
	}
	static void Free(_In_ std::pair<HICON, bool>& pair)
	{
		// See DestroyIcon documentation to determine an HICON should be destroyed
		if(pair.first != NULL && pair.second)
		{
			::DestroyIcon(pair.first);
		}
	}
	static HICON CastToResource(_In_ const std::pair<HICON, bool>& pair)
	{
		return pair.first;
	}
};

// TODO - 6/14/2006 - move this elsewhere
class Icon
{
public:

	Icon(_In_ WORD iResourceID):
		m_hIcon(Resource<IconResourceTraits>::ResourceType(reinterpret_cast<HICON>(VSL_CHECKHANDLE_GLE(::LoadIcon(_AtlBaseModule.GetResourceInstance(), MAKEINTRESOURCE(iResourceID)))), false))
	{
	}

	operator HICON()
	{
		return m_hIcon;
	}

private:
	Resource<IconResourceTraits> m_hIcon;
};

class ImageListResourceTraits
{
public:
	typedef HIMAGELIST ResourceType;
	typedef HIMAGELIST CastType;
	typedef ImageListResourceTraits Allocator;
	typedef ImageListResourceTraits Values;
	typedef ImageListResourceTraits Cloner;
	static HIMAGELIST GetNullValue()
	{
		return NULL;
	}
	static void Free(_In_ HIMAGELIST hImageList)
	{
		BOOL b = ::ImageList_Destroy(hImageList);
		(b);
		VSL_ASSERTEX(b, L"Failed to destory HIMAGELIST");
	}
	static HIMAGELIST CastToResource(_In_ HIMAGELIST hImageList)
	{
		return hImageList;
	}
};

class ImageListWin32Control
{
private:

VSL_DECLARE_NOT_COPYABLE(ImageListWin32Control)

public:

	explicit ImageListWin32Control(_In_ int iSize = 1, _In_ int iWidth = 32, _In_ int iHeight = 32, _In_ UINT iFlags = ILC_COLOR4|ILC_MASK):
		m_hImageList(VSL_CHECKPOINTER(::ImageList_Create(iWidth, iHeight, iFlags, 0, iSize), E_FAIL))
	{
	}

	~ImageListWin32Control()
	{
	}

	int AddIcon(_In_ HICON hIcon)
	{
		int iIconIndex = ::ImageList_AddIcon(m_hImageList, hIcon);
		VSL_CHECKBOOLEAN(iIconIndex != -1, E_FAIL);
		return iIconIndex;
	}

	operator HIMAGELIST()
	{
		return m_hImageList;
	}

private:
	Resource<ImageListResourceTraits> m_hImageList;
};

class SingleIconImageListWin32Control :
	public ImageListWin32Control
{
public:
	SingleIconImageListWin32Control(WORD iResourceID)
	{
		VSL_CHECKBOOLEAN(0 == AddIcon(Icon(iResourceID)), E_FAIL);
	}
};

template <class Derived_T>
class StaticallySizedIconImageListWin32Control :
	public ImageListWin32Control
{
public:
	StaticallySizedIconImageListWin32Control(_In_ int iWidth = 32, _In_ int iHeight = 32, _In_ UINT iFlags = ILC_COLOR4|ILC_MASK):
		ImageListWin32Control(Derived_T::CountOfImages, iWidth, iHeight, iFlags)
	{
		C_ASSERT(Derived_T::CountOfImages > 0);
		for(int i = 0; i < Derived_T::CountOfImages; ++i)
		{
			VSL_CHECKBOOLEAN(i == AddIcon(Icon(Derived_T::m_sResourceIDs[i])), E_FAIL);
		}
	}
};

template <class Control_T, class WindowBase_T = ATL::CWindowImplBaseT<> >
class Win32ControlContainer :
	public WindowBase_T
{

VSL_DECLARE_NOT_COPYABLE(Win32ControlContainer)

public:

	typedef Control_T Control;

	static const unsigned short iContainedControlID = 1;

	Win32ControlContainer():
		WindowBase_T(),
		m_Control()
	{
	}

	void Create(_In_ HWND hWndParent, _U_RECT rect)
	{
		static CWndClassInfo classInfo =
		{
			{ sizeof(WNDCLASSEX), 0, StartWindowProc,
			  0, 0, 0, 0, 0, (HBRUSH)(COLOR_WINDOW + 1), 0, _T("Win32ControlContainer"), 0 },
			NULL, NULL, NULL, TRUE, 0, _T("")
		};

		ATOM atom = classInfo.Register(&m_pfnSuperWindowProc);

		HWND hWnd = WindowBase_T::Create(hWndParent, rect, NULL,
			GetWndStyle(0), GetWndExStyle(0), 0U, atom, NULL);
		VSL_CHECKBOOLEAN(hWnd == m_hWnd, E_UNEXPECTED);

		m_Control.Create(m_hWnd, iContainedControlID, rect);
	}

VSL_BEGIN_MSG_MAP(Win32ControlContainer)
	MESSAGE_HANDLER(WM_SIZE, OnSize)
	MESSAGE_HANDLER(WM_SETFOCUS, OnSetFocus)
	REFLECT_NOTIFICATIONS()
VSL_END_MSG_MAP()

	LRESULT OnSize(UINT /*uMsg*/, _In_ WPARAM /*wParam*/, _In_ LPARAM lParam, BOOL& /*bHandled*/)
	{
		if(m_Control.GetHWND() == NULL)
		{
			return 1; // return other then 0 to indicate not processed
		}

		BOOL bRet = m_Control.MoveWindow(0, 0, LOWORD(lParam), HIWORD(lParam), TRUE);
		if(bRet != TRUE)
		{
			VSL_TRACE("Win32ControlContainer::OnSize - m_Control.MoveWindow failed");
		}
		return 0;
	}

	LRESULT OnSetFocus(UINT /*uMsg*/, _In_ WPARAM /*wParam*/, _In_ LPARAM /*lParam*/, BOOL& /*bHandled*/)
	{
		if(m_Control.GetHWND() == NULL)
		{
			return 1; // return other then 0 to indicate not processed
		}

		HWND hWnd = m_Control.SetFocus();
		if(hWnd == NULL)
		{
			VSL_TRACE("Win32ControlContainer::OnSize - m_Control.SetFocus failed");
		}
		return 0;
	}

protected:

	Control_T& GetControl()
	{
		return m_Control;
	}

	HWND GetHWND()
	{
		return m_hWnd;
	}

	void Destroy()
	{
		__if_exists(Control::Destroy)
		{
			m_Control.Destroy();
		}
		// This will cause the control to be destory as well,
		// so the control shouldn't call DestroyWindow itself
		DestroyWindow();
	}

private:

	Control_T m_Control;
};

} // namespace VSL

#endif // VSLCONTROLS_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\Include\VSLErrorHandlers.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef VSLERRORHANDLERS_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define VSLERRORHANDLERS_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

// VSL Includes
#include <VSLErrorHandlersBase.h>

/**************************************************************************************************
VSL_CHECKBOOLEAN and related
**************************************************************************************************/

#ifndef VSL_CHECKBOOLEAN_TRAITS
#define VSL_CHECKBOOLEAN_TRAITS(hrErr) \
	VSL::Traits< \
		VSL::BooleanEvaluator, \
		VSL_OVERRIDE_HRESULT_CONSTANT(VSL::BooleanEvaluator::ExpressionType, hrErr), \
		VSL::ExceptionHRESULT<>, \
		VSL::HRESULTProcessor > 
#endif // VSL_CHECKBOOLEAN_TRAITS

#ifndef VSL_CHECKBOOLEAN_EX
#define VSL_CHECKBOOLEAN_EX(exp, hrErr, extraData) \
	VSL_CHECKEXPRESSION_EX(VSL_CHECKBOOLEAN_TRAITS(hrErr), exp, extraData)
#endif // VSL_CHECKBOOLEAN_EX

#ifndef VSL_CHECKBOOLEAN
#define VSL_CHECKBOOLEAN(exp, hrErr) \
	VSL_CHECKEXPRESSION(VSL_CHECKBOOLEAN_TRAITS(hrErr), exp)
#endif // VSL_CHECKBOOL

/**************************************************************************************************
VSL_CHECKBOOLEAN_GLE and related

TODO - 1/21/2006 - unit test this

**************************************************************************************************/

#ifndef VSL_CHECKBOOLEAN_GLE_TRAITS
#define VSL_CHECKBOOLEAN_GLE_TRAITS VSL::BooleanGetLastErrorTraits
#endif // VSL_CHKBOOLEAN_TRAITS

#ifndef VSL_CHECKBOOLEAN_GLE_EX
#define VSL_CHECKBOOLEAN_GLE_EX(exp, extraData) \
	VSL_CHECKEXPRESSION_EX(VSL_CHECKBOOLEAN_GLE_TRAITS, exp, extraData)
#endif // VSL_CHKBOOLEAN_EX

#ifndef VSL_CHECKBOOLEAN_GLE
#define VSL_CHECKBOOLEAN_GLE(exp) \
	VSL_CHECKEXPRESSION(VSL_CHECKBOOLEAN_GLE_TRAITS, exp)
#endif // VSL_CHKBOOLEAN

/**************************************************************************************************
VSL_CHECKBOOL and related
**************************************************************************************************/

#ifndef VSL_CHECKBOOL_TRAITS
#define VSL_CHECKBOOL_TRAITS(hrErr) \
	VSL::Traits< \
		VSL::BOOLEvaluator, \
		VSL_OVERRIDE_HRESULT_CONSTANT(VSL::BOOLEvaluator::ExpressionType, hrErr), \
		VSL::ExceptionHRESULT<>, \
		VSL::HRESULTProcessor > 
#endif // VSL_CHECKBOOL_TRAITS

#ifndef VSL_CHECKBOOL_EX
#define VSL_CHECKBOOL_EX(exp, hrErr, extraData) \
	VSL_CHECKEXPRESSION_EX(VSL_CHECKBOOL_TRAITS(hrErr), exp, extraData)
#endif // VSL_CHECKBOOL_EX

#ifndef VSL_CHECKBOOL
#define VSL_CHECKBOOL(exp, hrErr) \
	VSL_CHECKEXPRESSION(VSL_CHECKBOOL_TRAITS(hrErr), exp)
#endif // VSL_CHECKBOOL

/**************************************************************************************************
VSL_CHECKBOOL_GLE and related
**************************************************************************************************/

#ifndef VSL_CHECKBOOL_GLE_TRAITS
#define VSL_CHECKBOOL_GLE_TRAITS VSL::BOOLGetLastErrorTraits
#endif // VSL_CHKBOOL_TRAITS

#ifndef VSL_CHECKBOOL_GLE_EX
#define VSL_CHECKBOOL_GLE_EX(exp, extraData) \
	VSL_CHECKEXPRESSION_EX(VSL_CHECKBOOL_GLE_TRAITS, exp, extraData)
#endif // VSL_CHKBOOL_EX

#ifndef VSL_CHECKBOOL_GLE
#define VSL_CHECKBOOL_GLE(exp) \
	VSL_CHECKEXPRESSION(VSL_CHECKBOOL_GLE_TRAITS, exp)
#endif // VSL_CHKBOOL

/**************************************************************************************************
VSL_CHECKHANDLE_GLE and related
**************************************************************************************************/

#ifndef VSL_CHECKHANDLE_GLE_TRAITS
#define VSL_CHECKHANDLE_GLE_TRAITS VSL::HANDLEGetLastErrorTraits
#endif // VSL_CHECKHANDLE_GLE_TRAITS

#ifndef VSL_CHECKHANDLE_GLE_EX
#define VSL_CHECKHANDLE_GLE_EX(exp, extraData) \
	VSL_CHECKEXPRESSION_EX(VSL_CHECKHANDLE_GLE_TRAITS, exp, extraData)
#endif // VSL_CHECKHANDLE_GLE_EX

#ifndef VSL_CHECKHANDLE_GLE
#define VSL_CHECKHANDLE_GLE(exp) \
	VSL_CHECKEXPRESSION(VSL_CHECKHANDLE_GLE_TRAITS, exp)
#endif // VSL_CHECKHANDLE_GLE

#ifndef VSL_CHECKHRESULT_TRAITS
#define VSL_CHECKHRESULT_TRAITS VSL::HRESULTTraits
#endif // VSL_CHECKHRESULT_TRAITS

/**************************************************************************************************
VSL_CHECKHRESULT and related
**************************************************************************************************/

#ifndef VSL_CHECKHRESULT_EX
#define VSL_CHECKHRESULT_EX(exp, extraData) \
	VSL_CHECKEXPRESSION_EX(VSL_CHECKHRESULT_TRAITS, exp, extraData)
#endif // VSL_CHECKHRESULT_EX

#ifndef VSL_CHECKHRESULT
#define VSL_CHECKHRESULT(exp) \
	VSL_CHECKEXPRESSION(VSL_CHECKHRESULT_TRAITS, exp)
#endif // VSL_CHECKHRESULT

/**************************************************************************************************
VSL_CREATE_ERROR_HRESULT and related
**************************************************************************************************/

#ifndef VSL_CREATE_ERROR_HRESULT_TRAITS
#define VSL_CREATE_ERROR_HRESULT_TRAITS  VSL::HRESULTTraits
#endif // VSL_CREATE_ERROR_HRESULT_TRAITS

#ifndef VSL_CREATE_ERROR_HRESULT_EX
#define VSL_CREATE_ERROR_HRESULT_EX(exp, extraData) \
	VSL_CREATE_ERROR_EX(VSL_CREATE_ERROR_HRESULT_TRAITS, exp, extraData)
#endif // VSL_CREATE_ERROR_HRESULT_EX

#ifndef VSL_CREATE_ERROR_HRESULT
#define VSL_CREATE_ERROR_HRESULT(exp) \
	VSL_CREATE_ERROR(VSL_CREATE_ERROR_HRESULT_TRAITS, exp)
#endif // VSL_CREATE_ERROR_HRESULT

/**************************************************************************************************
VSL_CHECKHRESULT and related
**************************************************************************************************/

#ifndef VSL_CHECKWIN32_TRAITS
#define VSL_CHECKWIN32_TRAITS VSL::Win32Traits
#endif // VSL_CHECKWIN32_TRAITS

#ifndef VSL_CHECKWIN32_EX
#define VSL_CHECKWIN32_EX(exp, extraData) \
	VSL_CHECKEXPRESSION_EX(VSL_CHECKWIN32_TRAITS, exp, extraData)
#endif // VSL_CHECKWIN32_EX

#ifndef VSL_CHECKWIN32
#define VSL_CHECKWIN32(exp) \
	VSL_CHECKEXPRESSION(VSL_CHECKWIN32_TRAITS, exp)
#endif // VSL_CHECKWIN32

/**************************************************************************************************
VSL_CREATE_ERROR_WIN32 and related
**************************************************************************************************/

#ifndef VSL_CREATE_ERROR_WIN32_TRAITS
#define VSL_CREATE_ERROR_WIN32_TRAITS VSL::Win32Traits
#endif // VSL_CREATE_ERROR_WIN32_TRAITS

#ifndef VSL_CREATE_ERROR_WIN32_EX
#define VSL_CREATE_ERROR_WIN32_EX(exp, extraData) \
	VSL_CREATE_ERROR_EX(VSL_CREATE_ERROR_WIN32_TRAITS, exp, extraData)
#endif // VSL_CREATE_ERROR_WIN32_EX

#ifndef VSL_CREATE_ERROR_WIN32
#define VSL_CREATE_ERROR_WIN32(exp) \
	VSL_CREATE_ERROR(VSL_CREATE_ERROR_WIN32_TRAITS, exp)
#endif // VSL_CREATE_ERROR_WIN32

/**************************************************************************************************
VSL_CHECKPOINTER and related
**************************************************************************************************/

#ifndef VSL_CHECKPOINTER_TRAITS
#define VSL_CHECKPOINTER_TRAITS(hrErr) \
	VSL::Traits< \
		VSL::PointerEvaluator, \
		VSL_OVERRIDE_HRESULT_CONSTANT(VSL::PointerEvaluator::ExpressionType, hrErr), \
		VSL::ExceptionHRESULT<>, \
		VSL::HRESULTProcessor > 
#endif // VSL_CHECKPOINTER_TRAITS

#ifndef VSL_CHECKPOINTER_EX
#define VSL_CHECKPOINTER_EX(exp, hrErr, extraData) \
	VSL_CHECKEXPRESSION_EX(VSL_CHECKPOINTER_TRAITS(hrErr), exp, extraData)
#endif // VSL_CHECKPOINTER_EX

#ifndef VSL_CHECKPOINTER
#define VSL_CHECKPOINTER(exp, hrErr) \
	VSL_CHECKEXPRESSION_CAST(VSL_CHECKPOINTER_TRAITS(hrErr), exp)
#endif // VSL_CHECKPOINTER

#define VSL_CHECKPOINTER_DEFAULT(exp) VSL_CHECKPOINTER(exp, E_POINTER)

// FUTURE - 1/23/2006 - this will be removed, use VSL_CHECKPOINTER_DEFAULT instead
#ifndef ErrorOnNullPointer
#define ErrorOnNullPointer(p) VSL_CHECKPOINTER_DEFAULT(p)
#endif

#ifndef VSL_RETURN_E_INVALIDARG_IF_NULL
#define VSL_RETURN_E_INVALIDARG_IF_NULL(p) \
    if(NULL == p) \
	{ \
        return E_INVALIDARG; \
	}
#endif

#endif // VSLERRORHANDLERS_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\Include\VSLContainers.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef VSLCONTAINERS_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define VSLCONTAINERS_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include <VSL.h>

namespace VSL
{

/*
The purpose of StaticArray is to faciltate returning an array by reference from a method
without losing size information, as occurs when a built-in array is passed by reference where it
is simply reduced to a raw pointer.

The m_Array member must be public and the class constructors can not be defined to facilitate,
array style initialization, so that element are not default constructed.

An instance of StaticArray can only be created by using struct style initialization to initialize
the public member m_Array via array style initialization, so it doesn't quite emulate a built-in
array perfectly, but operator[] works as expected.

For example:

	StaticArray<int, 3> initializedArray =
	{
		{
			1,
			2,
			3
		}
	};

Because we are emulating the internal built-in array, we bounds check only by assert as the design
intent is for client's to use NumberOfElements to ensure they don't overrun the array, as they 
would need to ARRAYSIZE to ensurean built-in array is not overrun.
*/

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
template <class Type_T, size_t NumberOfElements_T>
class StaticArray
{
private:
	C_ASSERT(NumberOfElements_T > 0);
	VSL_DECLARE_ASSIGNMENT_OPERATOR(StaticArray);

	bool IndexInBounds(size_t i) const
	{
		return (i >= 0 && i < NumberOfElements);
	}
	
public:

#pragma warning(push)
#pragma warning(disable : 4480) // nonstandard extension used: specifying underlying type for enum ''
	enum : size_t {NumberOfElements = NumberOfElements_T};
#pragma warning(pop)

	typedef Type_T Type;

	typedef Type_T ArrayType[NumberOfElements_T];

	typedef const Type_T* const_iterator;

	ArrayType m_Array;

	Type_T& operator[](size_t i)
	{
		VSL_ASSERT(IndexInBounds(i));
		return m_Array[i]; 
	}

	const Type_T& operator[](size_t i) const
	{
		VSL_ASSERT(IndexInBounds(i));
		return m_Array[i]; 
	}

	size_t size() const
	{
		return NumberOfElements;
	}

	const Type_T* begin() const
	{
		return &(m_Array[0]);
	}

	const Type_T* end() const
	{
		return m_Array + NumberOfElements;
	}
};
#pragma warning(pop)

} // namespace VSL

#endif VSLMOCKSYSTEMINTERFACE_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\Include\VSLExceptionHandlers.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef VSLEXCEPTIONHANDLERS_H_DA737291_2E81_11D3_A504_00C04F5E0BA5
#define VSLEXCEPTIONHANDLERS_H_DA737291_2E81_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "VSLExceptions.h"

namespace VSL
{

#ifndef VSL_STDMETHOD_HRESULT
#define VSL_STDMETHOD_HRESULT ___hr___
#endif // VSL_STDMETHOD_HRESULT

#ifndef VSL_STDMETHOD_HRESULT_INIT
#define VSL_STDMETHOD_HRESULT_INIT S_OK
#endif

#ifndef VSL_GET_STDMETHOD_HRESULT
#define VSL_GET_STDMETHOD_HRESULT() VSL_STDMETHOD_HRESULT
#endif // VSL_GET_STDMETHOD_HRESULT

#ifndef VSL_SET_STDMETHOD_HRESULT
#define VSL_SET_STDMETHOD_HRESULT(hr) (VSL_STDMETHOD_HRESULT = hr)
#endif // VSL_SET_STDMETHOD_HRESULT

#ifndef VSL_STDMETHODTRY_EX
#define VSL_STDMETHODTRY_EX(hrInit) \
	HRESULT VSL_STDMETHOD_HRESULT = hrInit; \
	try
#endif // VSL_STDMETHODTRY_EX

/*
By default, VSL_STDMETHODTRY will expand to:
	HRESULT ___hr___ = S_OK;
	try
*/
#ifndef VSL_STDMETHODTRY
#define VSL_STDMETHODTRY VSL_STDMETHODTRY_EX(VSL_STDMETHOD_HRESULT_INIT)
#endif // VSL_STDMETHODTRY 


#ifndef VSL_STDMETHOD_ON_CATCH_CEXCEPTION

inline HRESULT OnCatchExceptionBase(const ExceptionBase& rException)
{
	VSL_TRACE(_T("Exception caught in OnCatchExceptionBase, which is a generic exception handler, please include callstack in error report."));

	rException.ReportError();

	return static_cast<HRESULT>(rException);
}

#define VSL_STDMETHOD_ON_CATCH_CEXCEPTION VSL::OnCatchExceptionBase

#endif // VSL_STDMETHOD_ON_CATCH_CEXCEPTION


#ifndef VSL_STDMETHOD_ON_CATCH_STDEXCEPTION

inline HRESULT OnCatchStdException(const std::exception& rStdException)
{
	VSL_TRACE(_T("Exception caught in OnCatchStdException, which is a generic exception handler, please include callstack in error report."));

	ExceptionStd exception(rStdException);

	exception.ReportError();

	return static_cast<HRESULT>(exception);
}

#define VSL_STDMETHOD_ON_CATCH_STDEXCEPTION VSL::OnCatchStdException

#endif // VSL_STDMETHOD_ON_CATCH_STDEXCEPTION

#ifndef VSL_STDMETHOD_ON_CATCH_ATLEXCEPTION

inline HRESULT OnCatchAtlException(const ATL::CAtlException &rAtlException)
{
	VSL_TRACE(_T("Exception caught in OnCatchAtlException, which is a generic exception handler, please include callstack in error report."));

	VSL_REPORT_ERROR_HRESULT(static_cast<HRESULT>(rAtlException), false);

	return static_cast<HRESULT>(rAtlException);
}

#define VSL_STDMETHOD_ON_CATCH_ATLEXCEPTION VSL::OnCatchAtlException

#endif // VSL_STDMETHOD_ON_CATCH_ATLEXCEPTION

#ifndef VSL_STDMETHOD_ON_CATCH_ALL

inline HRESULT OnCatchAll()
{
	VSL_TRACE(_T("Exception caught in OnCatchAll, which is a generic exception handler, please include callstack in error report."));

	return E_UNEXPECTED;
}

#define VSL_STDMETHOD_ON_CATCH_ALL VSL::OnCatchAll

#endif // VSL_STDMETHOD_ON_CATCH_ALL


#ifndef VSL_STDMETHODCATCH_EX

/*
onExceptionBase:  defined to accept a ExceptionBase and evalutuate to an HRESULT
onStdException:  defined to accept a std::exception and evalutuate to an HRESULT
onCatchAll:  defined to accept no parameters and evalutuate to an HRESULT
*/

#define VSL_STDMETHODCATCH_EX(onExceptionBase, onStdException, onCatchAll) \
	catch(const VSL::ExceptionBase &rException) \
	{ \
		VSL_SET_STDMETHOD_HRESULT(VSL_STDMETHOD_ON_CATCH_CEXCEPTION(rException)); \
	} \
	catch(const std::exception &rStdException) \
	{ \
		VSL_SET_STDMETHOD_HRESULT(VSL_STDMETHOD_ON_CATCH_STDEXCEPTION(rStdException)); \
	} \
	catch(const ATL::CAtlException &rAtlException) \
	{ \
		VSL_SET_STDMETHOD_HRESULT(VSL_STDMETHOD_ON_CATCH_ATLEXCEPTION(rAtlException)); \
	} \
	catch(...) \
	{ \
		VSL_SET_STDMETHOD_HRESULT(onCatchAll()); \
	}

#endif // VSL_STDMETHODCATCH_EX


#ifndef VSL_STDMETHODCATCH
#define VSL_STDMETHODCATCH() VSL_STDMETHODCATCH_EX(VSL_STDMETHOD_ON_CATCH_CEXCEPTION, VSL_STDMETHOD_ON_CATCH_STDEXCEPTION, VSL_STDMETHOD_ON_CATCH_ALL)
#endif // VSL_STDMETHODCATCH

} // namespace VSL

#endif // VSLEXCEPTIONHANDLERS_H_DA737291_2E81_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\Include\VSLErrorHandlersBase.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef VSLERRORHANDLERSBASE_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define VSLERRORHANDLERSBASE_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

// VSL Includes
#include <VSLExceptions.h>

// Win32 includes
#include <winerror.h>
#include <objbase.h>

// CRT includes
#include <TCHAR.h>

namespace VSL
{

/**************************************************************************************************
Evalutators
**************************************************************************************************/

#define VSL_DECLARE_EVALUATOR(CLASS, TYPE, EVALUATOR) \
class CLASS \
{ \
private: \
\
	CLASS(); \
\
public:\
\
	typedef TYPE ExpressionType; \
\
	static bool Evaluate(const ExpressionType expressionValue) \
	{ \
		return EVALUATOR; \
	} \
};

VSL_DECLARE_EVALUATOR(BooleanEvaluator, bool, (false == expressionValue));
VSL_DECLARE_EVALUATOR(BOOLEvaluator, BOOL, (FALSE == expressionValue));
VSL_DECLARE_EVALUATOR(DWORDIsZeroEvaluator, DWORD, (0 == expressionValue));
VSL_DECLARE_EVALUATOR(HANDLEIsNullEvaluator, HANDLE, (NULL == expressionValue));
VSL_DECLARE_EVALUATOR(HANDLEIsInvalidEvaluator, HANDLE, (INVALID_HANDLE_VALUE == expressionValue));
VSL_DECLARE_EVALUATOR(HRESULTEvaluator, HRESULT, FAILED(expressionValue));
VSL_DECLARE_EVALUATOR(Win32Evaluator, DWORD, (ERROR_SUCCESS != expressionValue));
VSL_DECLARE_EVALUATOR(PointerEvaluator, void*, (NULL == expressionValue));

/**************************************************************************************************
Overrides
**************************************************************************************************/

template<class Expression_T, class OverrideType_T = Expression_T>
class DefaultOverride
{
private:

	DefaultOverride();

public:

	typedef typename OverrideType_T OverrideType;

	static inline const OverrideType Override(const Expression_T expressionValue)
	{
		return static_cast<OverrideType>(expressionValue);
	}
};

template<class Expression_T, class OverrideType_T, OverrideType_T OverriderValue_T>
class ConstantOverride
{
private:

	ConstantOverride();

public:

	typedef typename OverrideType_T OverrideType;

	static inline const OverrideType Override(const Expression_T /*expressionValue*/)
	{
		return OverriderValue_T;
	}
};

template<class Expression_T>
class GetLastErrorOverride
{
private:

	GetLastErrorOverride();

public:

	typedef DWORD OverrideType;

	static inline const OverrideType Override(const Expression_T /*expressionValue*/)
	{
		return ::GetLastError();
	}
};

typedef DefaultOverride<HRESULT> DefaultHRESULTOverride;

typedef DefaultOverride<DWORD> DefaultWin32Override;

#define VSL_OVERRIDE_HRESULT_CONSTANT(expType, hrErr) VSL::ConstantOverride<expType, HRESULT, hrErr>

/**************************************************************************************************
Processors
**************************************************************************************************/

class HRESULTProcessor
{
public:
	static void ProcessError(const ExceptionHRESULT<>& rErrObj)
	{
		if(static_cast<HRESULT>(rErrObj) != E_NOTIMPL)
		{
			VSL_TRACE(_T("General error, please include callstack in defect report."));
			VSL_ERROR_PROCESSOR_ASSERTEX(SUCCEEDED(static_cast<HRESULT>(rErrObj)), _T("General error, please include callstack in defect report."));
		}
		throw rErrObj;
	}
};

class Win32Processor
{
public:
	static void ProcessError(const ExceptionWin32<>& rErrObj)
	{
		VSL_TRACE(_T("General error, please include callstack in defect report."));
		VSL_ERROR_PROCESSOR_ASSERTEX(SUCCEEDED(static_cast<HRESULT>(rErrObj)), _T("General error, please include callstack in defect report."));
		throw rErrObj;
	}
};

/**************************************************************************************************
Traits
**************************************************************************************************/

template<
	class ExpressionEvaluator_T,
	class ExpressionValueOverride_T,
	class Exception_T,
	class ErrorProcessor_T>
class Traits
{
public:
	typedef ExpressionEvaluator_T ExpressionEvaluator;
	typedef typename ExpressionEvaluator_T::ExpressionType ExpressionType;
	typedef ExpressionValueOverride_T ExpressionValueOverride;
	typedef Exception_T Exception;
	typedef typename Exception_T::ExtraDataType ExtraDataType;
	typedef typename Exception_T::ExtraDataTypeContainer ExtraDataTypeContainer;
	typedef typename Exception_T::StringType StringType;
	typedef ErrorProcessor_T ErrorProcessor;
};

typedef Traits<
	HRESULTEvaluator,
	DefaultHRESULTOverride,
	ExceptionHRESULT<>,
	HRESULTProcessor >
		HRESULTTraits;

typedef Traits<
	Win32Evaluator, 
	DefaultWin32Override, 
	ExceptionWin32<>, 
	Win32Processor >
		Win32Traits;

typedef Traits<
	BooleanEvaluator,
	GetLastErrorOverride<bool>,
	ExceptionWin32<>,
	Win32Processor >
		BooleanGetLastErrorTraits;

typedef Traits<
	BOOLEvaluator,
	GetLastErrorOverride<BOOL>,
	ExceptionWin32<>,
	Win32Processor >
		BOOLGetLastErrorTraits;

typedef Traits<
	HANDLEIsNullEvaluator,
	GetLastErrorOverride<HANDLE>,
	ExceptionWin32<>,
	Win32Processor >
		HANDLEGetLastErrorTraits;

/**************************************************************************************************
CreateAndProcessError
**************************************************************************************************/

template<class Traits_T>
class CreateAndProcessError
{
public:

	static void Invoke(
		typename const Traits_T::ExpressionType expressionValue,
#ifndef _VSL_NO_SOURCE_INFO
		typename Traits_T::StringType szExpression,
		typename Traits_T::StringType szFilename,
		int iLineNumber,
#endif // _VSL_NO_SOURCE_INFO
		const typename Traits_T::ExtraDataType& extraData = Traits_T::ExtraDataTypeContainer::DefaultValue())
	{
		Traits_T::Exception exception(
			Traits_T::ExpressionValueOverride::Override(expressionValue),
#ifndef _VSL_NO_SOURCE_INFO
			szExpression,
			szFilename,
			iLineNumber,
#endif // _VSL_NO_SOURCE_INFO
			extraData);

		Traits_T::ErrorProcessor::ProcessError(exception);
	}
};

/**************************************************************************************************
VSL_CREATE_ERROR macros
**************************************************************************************************/

#ifndef _VSL_NO_SOURCE_INFO
#define __INVOKE_PARAMETERS(expressionValue, expText) expressionValue, expText, __VSL_FILE__, __LINE__
#define __INVOKE_PARAMETERS_EX(expressionValue, expText, extraData) expressionValue, expText, __VSL_FILE__, __LINE__, extraData
#else // _VSL_NO_SOURCE_INFO
#define __INVOKE_PARAMETERS(expressionValue, expText) expressionValue
#define __INVOKE_PARAMETERS_EX(expressionValue, expText, extraData) expressionValue, extraData
#endif // _VSL_NO_SOURCE_INFO

#ifndef VSL_CREATE_ERROR_EX
#define VSL_CREATE_ERROR_EX(traits, expressionValue, extraData) \
	VSL::CreateAndProcessError<traits >::Invoke(__INVOKE_PARAMETERS_EX(expressionValue, NULL, extraData))
#endif // VSL_CREATE_ERROR_EX

#ifndef VSL_CREATE_ERROR
#define VSL_CREATE_ERROR(traits, expressionValue) \
	VSL::CreateAndProcessError<traits >::Invoke(__INVOKE_PARAMETERS(expressionValue, NULL))
#endif // VSL_CREATE_ERROR

/**************************************************************************************************
FailOnError
**************************************************************************************************/

template<class Traits_T>
class FailOnError
{
public:

	static typename Traits_T::ExpressionType Invoke(
		typename Traits_T::ExpressionType expressionValue
#ifndef _VSL_NO_SOURCE_INFO
		, typename Traits_T::StringType szExpression,
		typename Traits_T::StringType szFilename,
		int iLineNumber
#endif // _VSL_NO_SOURCE_INFO
		)
	{
		if(Traits_T::ExpressionEvaluator::Evaluate(expressionValue))
		{
			CreateAndProcessError<Traits_T>::Invoke(
				expressionValue
#ifndef _VSL_NO_SOURCE_INFO
				, szExpression,
				szFilename,
				iLineNumber
#endif // _VSL_NO_SOURCE_INFO
				);
		}

		return expressionValue;
	}
	
	static typename Traits_T::ExpressionType Invoke(
		typename Traits_T::ExpressionType expressionValue,
#ifndef _VSL_NO_SOURCE_INFO
		typename Traits_T::StringType szExpression,
		typename Traits_T::StringType szFilename,
		int iLineNumber,
#endif // _VSL_NO_SOURCE_INFO
		const typename Traits_T::ExtraDataType& extraData)
	{
		if(Traits_T::ExpressionEvaluator::Evaluate(expressionValue))
		{
			CreateAndProcessError<Traits_T>::Invoke(
				expressionValue,
#ifndef _VSL_NO_SOURCE_INFO
				szExpression,
				szFilename,
				iLineNumber,
#endif // _VSL_NO_SOURCE_INFO
				extraData);
		}

		return expressionValue;
	}

	template <class ExpressionType>
	static ExpressionType InvokeCast(
		ExpressionType expressionValue
#ifndef _VSL_NO_SOURCE_INFO
		, typename Traits_T::StringType szExpression,
		typename Traits_T::StringType szFilename,
		int iLineNumber
#endif // _VSL_NO_SOURCE_INFO
		)
	{
		return (ExpressionType)Invoke(
			(Traits_T::ExpressionType)expressionValue
#ifndef _VSL_NO_SOURCE_INFO
			, szExpression,
			szFilename,
			iLineNumber
#endif // _VSL_NO_SOURCE_INFO
			);
	}

	template <class ExpressionType>
	static ExpressionType InvokeCast(
		ExpressionType expressionValue,
#ifndef _VSL_NO_SOURCE_INFO
		typename Traits_T::StringType szExpression,
		typename Traits_T::StringType szFilename,
		int iLineNumber,
#endif // _VSL_NO_SOURCE_INFO
		const typename Traits_T::ExtraDataType& extraData)
	{
		return (ExpressionType)Invoke(
			(Traits_T::ExpressionType)expressionValue
#ifndef _VSL_NO_SOURCE_INFO
			szExpression,
			szFilename,
			iLineNumber,
#endif // _VSL_NO_SOURCE_INFO
			extraData);
	}
};

/**************************************************************************************************
VSL_CHECKEXPRESSION macros - Checks the expression, and, if an error is indicated, fails
**************************************************************************************************/

#ifndef VSL_CHECKEXPRESSION_EX
#if defined(_UNICODE) || defined(UNICODE)
#define VSL_CHECKEXPRESSION_EX(traits, exp, extraData) \
	VSL::FailOnError<traits >::Invoke(__INVOKE_PARAMETERS_EX(exp, L#exp, extraData))
#else
#define VSL_CHECKEXPRESSION_EX(traits, exp, extraData) \
	VSL::FailOnError<traits >::Invoke(__INVOKE_PARAMETERS_EX(exp, #exp, extraData))
#endif
#endif // VSL_CHECKEXPRESSION_EX

#ifndef VSL_CHECKEXPRESSION
#if defined(_UNICODE) || defined(UNICODE)
#define VSL_CHECKEXPRESSION(traits, exp) \
	VSL::FailOnError<traits >::Invoke(__INVOKE_PARAMETERS(exp, L#exp))
#else
#define VSL_CHECKEXPRESSION(traits, exp) \
	VSL::FailOnError<traits >::Invoke(__INVOKE_PARAMETERS(exp, #exp))
#endif
#endif // VSL_CHECKEXPRESSION

#ifndef VSL_CHECKEXPRESSION_CAST_EX
#if defined(_UNICODE) || defined(UNICODE)
#define VSL_CHECKEXPRESSION_CAST_EX(traits, exp, extraData) \
	VSL::FailOnError<traits >::Invoke(__INVOKE_PARAMETERS_EX(exp, L#exp, extraData))
#else
#define VSL_CHECKEXPRESSION_CAST_EX(traits, exp, extraData) \
	VSL::FailOnError<traits >::Invoke(__INVOKE_PARAMETERS_EX(exp, #exp, extraData))
#endif
#endif // VSL_CHECKEXPRESSION_CAST_EX

#ifndef VSL_CHECKEXPRESSION_CAST
#if defined(_UNICODE) || defined(UNICODE)
#define VSL_CHECKEXPRESSION_CAST(traits, exp) \
	VSL::FailOnError<traits >::InvokeCast(__INVOKE_PARAMETERS(exp, L#exp))
#else
#define VSL_CHECKEXPRESSION_CAST(traits, exp) \
	VSL::FailOnError<traits >::InvokeCast(__INVOKE_PARAMETERS(exp, #exp))
#endif
#endif // VSL_CHECKEXPRESSION_CAST

} // namespace VSL

#endif // VSLERRORHANDLERSBASE_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\Include\VSLExceptions.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef VSLEXCEPTIONS_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define VSLEXCEPTIONS_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

// VSL includes
#include <VSL.h>

// SCL includes
#include <memory>
#include <typeinfo>
#include <stdexcept>
#include <xiosbase>

// VS Platform includes
#include <VsShellInterfaces.h>

namespace VSL
{

// FUTURE - add support for help keyword and possibly source string.
class ExtendedErrorInfo
{
private:

	// No default construction, a description resource ID or string must be provided.
	ExtendedErrorInfo();

public:

	ExtendedErrorInfo(UINT iResourceID):
		m_iResourceID(iResourceID),
		m_strMessage()
	{
	}

	ExtendedErrorInfo(const TCHAR* szErrorMessage):
		m_iResourceID(0),
		m_strMessage(szErrorMessage)
	{
	}

	// The compiler generated destructor is fine

	UINT GetDescriptionID() const
	{
		return m_iResourceID;
	}

	operator const TCHAR*() const
	{
		if(!m_strMessage && m_iResourceID != 0)
		{
			// Could have loaded the string in the res ID contstructor, but it isn't always needed,
			// so we are lazy caching the actual string
			if(!const_cast<ExtendedErrorInfo*>(this)->m_strMessage.LoadString(_AtlBaseModule.GetResourceInstance(), m_iResourceID))
			{
				// Ignore failure, so the application error will still get thrown,
				// even if it doesn't have extended information
				VSL_TRACE("ResourceString default constructor - failed to load resource string!");
			}
		}
		return m_strMessage;
	}

	const ExtendedErrorInfo& operator=(const ExtendedErrorInfo& rToCopy)
	{
		if(&rToCopy != this)
		{
			m_iResourceID = rToCopy.m_iResourceID;
			m_strMessage = rToCopy.m_strMessage;
		}
		return *this;
	}

	bool operator==(UINT iResourceID) const
	{
		return iResourceID == m_iResourceID;
	}

	friend bool operator==(UINT iResourceID, const ExtendedErrorInfo& rThis)
	{
		return rThis.operator==(iResourceID);
	}
private:

	UINT m_iResourceID;
	ATL::CString m_strMessage;

};

// TODO - move this to another file
#ifndef	VSL_GET_VSUISHELL_SERVICE
class GlobalVSServiceProvider; // forward decleration
#define VSL_GET_VSUISHELL_SERVICE() GlobalVSServiceProvider::GetVsUIShellService()
#endif

// NOTE - the string resource provided for source does not get shown to the user by VS
// There may not be much purpose in setting this value.
// FUTURE - the type of iSourceID_T parameter may change to a TCHAR*, something else, or be removed
template <UINT iSourceID_T = 0>
class VsReportErrorUtilities
{

	VSL_DECLARE_NOT_COPYABLE(VsReportErrorUtilities)

public:

	VsReportErrorUtilities():
		m_spIVsUIShell(VSL_GET_VSUISHELL_SERVICE())
	{
		
	}

	VsReportErrorUtilities(IVsUIShell* pIVsUIShell):
		m_spIVsUIShell(pIVsUIShell)
	{
	}

	// The compiler generated destructor is fine

	// FUTURE - The parameter iSourceID may change to be a TCHAR*, something else, or be removed.
	// The other parameters may be reordered.  It is recommended that method not be called 
	// directly for the time being.

	// Does not throw, so can be called outside of try/catch block
	void __declspec(nothrow) ReportExtendedError(
		HRESULT hrError,
		unsigned int iErrorDescriptionID = 0,
		bool bDisplayErrorToUser = false,
		const wchar_t* const szHelpKeyword = NULL,
		unsigned int iSourceID = iSourceID_T) 
	{
		if(!m_spIVsUIShell)
		{
			// Don't have a pointer to the VsUIShell service, bail
			VSL_TRACE(L"VsReportErrorUtilities::ReportExtendedError - VsUIShell not available!");
			return;
		}

		// Load the description from the string table, but ignore failure to ensure that at least 
		// the HRESULT is reported
		CStringW strDescription;
		if(iErrorDescriptionID != 0)
		{
			strDescription.LoadString(iErrorDescriptionID);
			if(!strDescription || strDescription[0] == L'\0')
			{
				VSL_TRACE(L"VsReportErrorUtilities::ReportExtendedError - error description string not loaded!");
			}
		}

		// Load the source, if any, from the string table.  A CStringW is an empty string by default,
		// but NULL is needed if it is not set, so two variables are used here.
		CStringW strSource;
		if(iSourceID != 0)
		{
			// Load the source from the string table, but ignore failure to ensure at least the 
			// HRESULT is reported
			strSource.LoadString(iSourceID);
			if(!strSource || strSource[0] == L'\0')
			{
				VSL_TRACE(L"VsReportErrorUtilities::ReportExtendedError - error source string not loaded!");
			}
		}

		if(strDescription[0] != L'\0' || szHelpKeyword != NULL || strSource[0] != L'\0')
		{
			// Have VS create an object implementing IErrorInfo with the extended error info provided
			// Need to pass in NULL rather then empty string, as VS display's a better error message that
			// way (i.e. it treats a empty string a valid string).
			HRESULT hr = m_spIVsUIShell->SetErrorInfo(
				hrError,
				strDescription[0] != L'\0' ? strDescription.GetString() : NULL,
				0,
				szHelpKeyword,
				strSource[0] != L'\0' ? strSource.GetString() : NULL);

				// Just trace, so hopefully something will get reported to the user
				if(FAILED(hr))
				{
					VSL_TRACE(L"VsReportErrorUtilities::ReportExtendedError - call to IVsUIShell::SetErrorInfo failed");
				}

				if(bDisplayErrorToUser)
				{
					// Have VS report the application error to the user
					hr = m_spIVsUIShell->ReportErrorInfo(hrError);

					// Just trace, as there is nothing to be done about this call failing.
					if(FAILED(hr))
					{
						VSL_TRACE(L"VsReportErrorUtilities::ReportExtendedError - call to IVsUIShell::ReportErrorInfo failed");
					}
				}
		}
		else
		{
			// No extra error information to report, just report it as a standard error
			// which ensures that any previously set error info is cleared.
			ReportStandardError(hrError, bDisplayErrorToUser);
		}
	}

	// Does not throw, so can be called outside of try/catch block
	void __declspec(nothrow) ReportExtendedError(
		HRESULT hrError,
		const ExtendedErrorInfo& rExtendedError,
		bool bDisplayErrorToUser = false)
	{
		ReportExtendedError(hrError, rExtendedError.GetDescriptionID(), bDisplayErrorToUser);
	}

	// Does not throw, so can be called outside of try/catch block
	void __declspec(nothrow) ReportStandardError(HRESULT hrError, bool bDisplayErrorToUser = false)
	{
		if(!m_spIVsUIShell)
		{
			// Don't have a pointer to the VsUIShell service, bail
			VSL_TRACE(L"VsReportErrorUtilities::ReportStandardError - VsUIShell not available!");
			return;
		}

		// Clear any current error info
		HRESULT hr = ::SetErrorInfo(0, NULL);
		// Just trace, so hopefully something will get reported to the user
		if(FAILED(hr))
		{
			VSL_TRACE(L"VsReportErrorUtilities::ReportStandardError - call to ::SetErrorInfo failed");
		}

		if(bDisplayErrorToUser)
		{
			// Have VS report the system error to the user
			hr = m_spIVsUIShell->ReportErrorInfo(hrError);

			// Just trace, so hopefully something will get reported to the user
			if(FAILED(hr))
			{
				VSL_TRACE(L"VsReportErrorUtilities::ReportStandardError - call to ::SetErrorInfo failed");
			}
		}
	}

private:
	CComPtr<IVsUIShell> m_spIVsUIShell;
};

#ifndef VSL_REPORT_ERROR_HRESULT
#define VSL_REPORT_ERROR_HRESULT(hr, bDisplayErrorToUser) \
	VsReportErrorUtilities<> util; \
	util.ReportStandardError(hr, bDisplayErrorToUser);
#endif

#define _VSL_REPORT_ERROR_HRESULT_EX(hr, extended, bDisplayErrorToUser) \
	VsReportErrorUtilities<> util; \
	util.ReportExtendedError(hr, extended, bDisplayErrorToUser);

#ifndef VSL_REPORT_ERROR_HRESULT_EX
#define VSL_REPORT_ERROR_HRESULT_EX _VSL_REPORT_ERROR_HRESULT_EX
#endif

class ExceptionBase
{
public:

	// The compiler generated default constructor, copy constructor, assignment operator are 
	// are fine as this is an abstract base class as signified by the pure virtual destructor.

	virtual ~ExceptionBase() = 0 {}

	operator HRESULT() const
	{
		return GetHRESULT();
	}

	operator DWORD() const
	{
		return GetWin32Error();
	}

	virtual HRESULT GetHRESULT() const = 0;

	virtual DWORD GetWin32Error() const
	{
		HRESULT hr = GetHRESULT();
	    return (FAILED(hr) ? (hr & 0x0000FFFF) : ERROR_SUCCESS);
	}

	virtual void ReportError(bool bDisplayErrorToUser = false) const
	{
		VSL_REPORT_ERROR_HRESULT(GetHRESULT(), bDisplayErrorToUser);
	}
};

class ExceptionStd : 
	public ExceptionBase
{
public:

	enum TypeID
	{
		UNKNOWN = 0,
		EXCEPTION,
			BAD_ALLOC,
			BAD_CAST,
			BAD_EXCEPTION,
			BAD_TYPEID,
				__NON_RTTI_OBJECT,
			LOGIC_ERROR,
				DOMAIN_ERROR,
				INVALID_ARGUMENT,
				LENGTH_ERROR,
				OUT_OF_RANGE,
			RUNTIME_ERROR,
				RANGE_ERROR,
				OVERFLOW_ERROR,
				UNDERFLOW_ERROR,
				IOS_BASE_FAILURE,
		NUM_EXCEPTION_TYPES
	};

private:

	ExceptionStd();
	ExceptionStd& operator=(ExceptionStd& rhs);

public:

	// Let the compiler generate the copy constructor since a bit copy is fine

	explicit ExceptionStd(const std::exception& e):
		m_eTypeID(UNKNOWN)
	{
		try
		{
			const type_info& rType = typeid(e);

			if(rType == typeid(std::exception))
			{
				m_eTypeID = EXCEPTION;
			}
			else if(rType == typeid(std::bad_alloc))
			{
				m_eTypeID = BAD_ALLOC;
			}
			else if(rType == typeid(std::bad_cast))
			{
				m_eTypeID = BAD_CAST;
			}
			else if(rType == typeid(std::bad_exception))
			{
				m_eTypeID = BAD_EXCEPTION;
			}
			else if(rType == typeid(std::bad_typeid))
			{
				m_eTypeID = BAD_TYPEID;
			}
			else if(rType == typeid(std::__non_rtti_object))
			{
				m_eTypeID = __NON_RTTI_OBJECT;
			}
			else if(rType == typeid(std::logic_error))
			{
				m_eTypeID = LOGIC_ERROR;
			}
			else if(rType == typeid(std::domain_error))
			{
				m_eTypeID = DOMAIN_ERROR;
			}
			else if(rType == typeid(std::invalid_argument))
			{
				m_eTypeID = INVALID_ARGUMENT;
			}
			else if(rType == typeid(std::length_error))
			{
				m_eTypeID = LENGTH_ERROR;
			}
			else if(rType == typeid(std::out_of_range))
			{
				m_eTypeID = OUT_OF_RANGE;
			}
			else if(rType == typeid(std::runtime_error))
			{
				m_eTypeID = RUNTIME_ERROR;
			}
			else if(rType == typeid(std::range_error))
			{
				m_eTypeID = RANGE_ERROR;
			}
			else if(rType == typeid(std::overflow_error))
			{
				m_eTypeID = OVERFLOW_ERROR;
			}
			else if(rType == typeid(std::underflow_error))
			{
				m_eTypeID = UNDERFLOW_ERROR;
			}
			else if(rType == typeid(std::ios_base::failure))
			{
				m_eTypeID = IOS_BASE_FAILURE;
			}
		}
		catch(...)
		{
			// typeid should only throw if passed a null pointer, so this should never happen
			VSL_ASSERT(false);
		}
	}

	virtual ~ExceptionStd() {}

    virtual HRESULT GetHRESULT() const
	{
		if(BAD_ALLOC == m_eTypeID)
		{
			return E_OUTOFMEMORY;
		}

		return DISP_E_EXCEPTION;
	}

    TypeID GetStdExceptionTypeID() const
	{
		return m_eTypeID;
	}

protected:

    TypeID m_eTypeID;

};

class ExceptionExBase : 
	public ExceptionBase
{
public:
	// The compiler generated default constructor, copy constructor, assignment operator are 
	// are fine as this is an abstract base class as signified by the pure virtual destructor.

	virtual ~ExceptionExBase() = 0 {}

#ifndef _VSL_NO_SOURCE_INFO
	virtual const TCHAR* GetExpressionString() const = 0;

	virtual const TCHAR* GetSourceFilenamePath() const = 0;

	virtual int GetSourceLinenumber() const = 0;
#endif

	virtual const TCHAR* GetErrorString() const = 0;
};

#if 0 // FUTURE - can be added back if needed.
class ExtraDataTypeContainerString
{
private:

	ExtraDataTypeContainerString();

public:

	typedef const TCHAR* Type;

	static Type DefaultValue()
	{
		return NULL;
	}

	static Type DefaultString()
	{
		return NULL;
	}

	static Type GetErrorStringFromData(Type data)
	{
		return data;
	}
};
#endif

class ExtendedErrorInfoExtraDataTypeContainer
{
private:

	ExtendedErrorInfoExtraDataTypeContainer();

public:

	typedef ExtendedErrorInfo Type;

	static UINT DefaultValue()
	{
		return 0;
	}

	static const TCHAR* DefaultString()
	{
		return _T("");
	}

	static const TCHAR* GetErrorStringFromData(const Type& data)
	{
		return data;
	}
};

typedef ExtendedErrorInfoExtraDataTypeContainer ExceptionExtraDataTypeContainerDefault;

template<
	class Expression_T,
	class ExtraDataTypeContainer_T = ExceptionExtraDataTypeContainerDefault,
	class String_T = const TCHAR* >
class ExceptionExImpl : 
	public ExceptionExBase
{
public:

	typedef Expression_T ExpressionType;
	typedef ExtraDataTypeContainer_T ExtraDataTypeContainer;
	typedef typename ExtraDataTypeContainer_T::Type ExtraDataType;
	typedef String_T StringType;

private:

	ExceptionExImpl();
	const ExceptionExImpl& operator=(const ExceptionExImpl& rToCopy);

public:

	explicit ExceptionExImpl(
		const Expression_T& expressionValue,
#ifndef _VSL_NO_SOURCE_INFO
		String_T strExpression,
		String_T strFilename,
		int iLineNumber,
#endif
		const ExtraDataType& extraData = ExtraDataTypeContainer_T::DefaultValue()):
			m_expValue(expressionValue),
#ifndef _VSL_NO_SOURCE_INFO
			m_strExpression(strExpression),
			m_strFilename(strFilename),
			m_iLineNumber(iLineNumber),
#endif
			m_ExtraData(extraData)
	{

	}

	ExceptionExImpl(const ExceptionExImpl& rToCopy):
		ExceptionExBase(rToCopy),
		m_expValue(rToCopy.m_expValue),
#ifndef _VSL_NO_SOURCE_INFO
		m_strExpression(rToCopy.m_strExpression),
		m_strFilename(rToCopy.m_strFilename),
		m_iLineNumber(rToCopy.m_iLineNumber),
#endif
		m_ExtraData(rToCopy.m_ExtraData)
	{
		
	}

	virtual ~ExceptionExImpl() = 0 {}

#ifndef _VSL_NO_SOURCE_INFO

	virtual const TCHAR* GetExpressionString() const
	{
		return m_strExpression;
	}

	const String_T& GetExpressionStringTyped() const
	{
		return m_strExpression;
	}

	virtual const TCHAR* GetSourceFilenamePath() const
	{
		return m_strFilename;
	}

	const String_T& GetSourceFilenamePathTyped() const
	{
		return m_strFilename;
	}

	virtual int GetSourceLinenumber() const
	{
		return m_iLineNumber;
	}

#endif

	virtual const TCHAR* GetErrorString() const
	{
		return ExtraDataTypeContainer_T::GetErrorStringFromData(m_ExtraData);
	}

	const ExtraDataType& GetExtraData() const
	{
		return m_ExtraData;
	}

	virtual void ReportError(bool bDisplayErrorToUser = false) const
	{
		VSL_REPORT_ERROR_HRESULT_EX(GetHRESULT(), m_ExtraData, bDisplayErrorToUser);
	}

protected:
	
	Expression_T m_expValue;
#ifndef _VSL_NO_SOURCE_INFO
	String_T m_strExpression;
	String_T m_strFilename;
	int m_iLineNumber;
#endif
	ExtraDataType m_ExtraData;

};

template<
	typename class ExtraDataTypeContainer_T = ExceptionExtraDataTypeContainerDefault,
	typename String_T = const TCHAR* >
class ExceptionHRESULT :
	public ExceptionExImpl<
		HRESULT, 
		ExtraDataTypeContainer_T, 
		String_T>
{
public:

	typedef ExceptionExImpl<
		HRESULT, 
		ExtraDataTypeContainer_T, 
		String_T> BaseClass;

private:

	ExceptionHRESULT();
	const ExceptionHRESULT& operator=(const ExceptionHRESULT& rToCopy);

public:

	virtual HRESULT GetHRESULT() const
	{
		return m_expValue;
	}

	explicit ExceptionHRESULT(
		HRESULT hr,
#ifndef _VSL_NO_SOURCE_INFO
		String_T strExpression,
		String_T strFilename,
		int iLineNumber,
#endif
		const ExtraDataType& extraData = ExtraDataTypeContainer_T::DefaultValue()):
			BaseClass(
				hr,
 #ifndef _VSL_NO_SOURCE_INFO
				strExpression,
				strFilename,
				iLineNumber,
#endif
				extraData)
	{
	}

	ExceptionHRESULT(const ExceptionHRESULT& rToCopy):
		BaseClass(rToCopy)
	{
	}
};

template<
	typename class ExtraDataTypeContainer_T = ExceptionExtraDataTypeContainerDefault,
	class String_T = const TCHAR* >
class ExceptionWin32 : 
	public ExceptionExImpl<
		DWORD, 
		ExtraDataTypeContainer_T, 
		String_T>
{
public:

	typedef ExceptionExImpl<
		DWORD, 
		ExtraDataTypeContainer_T, 
		String_T> BaseClass;

private:

	ExceptionWin32();
	const ExceptionWin32& operator=(const ExceptionWin32& rToCopy);
	
public:

	ExceptionWin32(
		DWORD dwCode,
#ifndef _VSL_NO_SOURCE_INFO
		String_T strExpression,
		String_T strFilename,
		int iLineNumber,
#endif
		const ExtraDataType& extraData = ExtraDataTypeContainer_T::DefaultValue()):
			BaseClass(
				dwCode,
 #ifndef _VSL_NO_SOURCE_INFO
				strExpression,
				strFilename,
				iLineNumber,
#endif
				extraData)
	{
	}

	ExceptionWin32(const ExceptionWin32& rToCopy):
		BaseClass(rToCopy)
	{
	}

	virtual HRESULT GetHRESULT() const
	{
		return HRESULT_FROM_WIN32(m_expValue);
	}

	virtual DWORD GetWin32Error() const
	{
		return m_expValue;
	}
};

} // namespace VSL

#endif // VSLEXCEPTIONS_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\Include\VSLFindAndReplace.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef VSLFINDANDREPLACE_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define VSLFINDANDREPLACE_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

namespace VSL
{

// TODO - 3/16/2006 - clean-up this file to be consistent with the rest of VSL

/***************************************************************************
IVsFindTarget implementation
***************************************************************************/

#define VSL_IVSFINDTARGETIMPL_AUTO_DETERMINE_IVSTEXTIMAGE TRUE + 1

template <class Derived_T, const BOOL bImage_T = VSL_IVSFINDTARGETIMPL_AUTO_DETERMINE_IVSTEXTIMAGE>
class IVsFindTargetImpl :
	public IVsFindTarget
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsFindTargetImpl)

public:

	/*
	This function indicates to the caller which Find/Replace options are supported via the pgrfOptions
	out parameter. The pfImage parameter indicates whether the IVsTextImage interface is supported.
	*/
	STDMETHOD(GetCapabilities)(_Out_opt_ BOOL* pfImage, _Out_opt_ DWORD* pgrfOptions)
	{
		VSL_STDMETHODTRY{

		Derived_T& rDerived = *(static_cast<Derived_T*>(this));

		if(NULL != pfImage)
		{
			static BOOL s_bImage = bImage_T;
			if(s_bImage == VSL_IVSFINDTARGETIMPL_AUTO_DETERMINE_IVSTEXTIMAGE)
			{
				CComPtr<IVsTextImage> spIVsTextImage;
				if(S_OK == rDerived._GetRawUnknown()->QueryInterface(IID_IVsTextImage, reinterpret_cast<void**>(&spIVsTextImage)))
				{
					s_bImage = TRUE;
				}
			}
			*pfImage = s_bImage;
		}

		if(NULL != pgrfOptions)
		{
			*pgrfOptions = FR_None;

			*pgrfOptions = rDerived.GetCapabilityOptions();
		}

		}VSL_STDMETHODCATCH()

		return VSL_GET_STDMETHOD_HRESULT();
	}

	STDMETHOD(GetSearchImage)(
		DWORD grfOptions,
		_Out_opt_ IVsTextSpanSet** ppSpans, // May be NULL
		_Out_ IVsTextImage** ppTextImage)
	{
		VSL_STDMETHODTRY{

		Derived_T& rDerived = *(static_cast<Derived_T*>(this));

		DWORD grfSupportedOptions = rDerived.GetCapabilityOptions();
		// Use grfSupportedOptions to mask grfOptions and compare the results to grfOptions
		// If the result of the mask isn't the same, then unsupported options were specified
		VSL_CHECKBOOLEAN(grfOptions == (grfSupportedOptions & grfOptions), E_INVALIDARG);

		VSL_CHECKPOINTER(ppTextImage, E_INVALIDARG);
		*ppTextImage = NULL;

		if(NULL != ppSpans)
		{
			*ppSpans = NULL;
			VSL_CHECKHRESULT(rDerived._GetRawUnknown()->QueryInterface(IID_IVsTextSpanSet, reinterpret_cast<void**>(ppSpans)));
			VSL_CHECKPOINTER(*ppSpans, E_NOINTERFACE); // paranoid
		}

		VSL_CHECKHRESULT(rDerived._GetRawUnknown()->QueryInterface(IID_IVsTextImage, reinterpret_cast<void**>(ppTextImage)));
		VSL_CHECKPOINTER(*ppTextImage, E_NOINTERFACE); // paranoid

		if(NULL != ppSpans)
		{
			// Attach this text image to this span
			(*ppSpans)->AttachTextImage(*ppTextImage);
		}

		}VSL_STDMETHODCATCH()

		return VSL_GET_STDMETHOD_HRESULT();
	}

	// It isn't necessary to implement Find as GetSearchImage which results in hooking into 
	// into VS find/replace engine.
	STDMETHOD(Find)(
		LPCOLESTR /*pszSearch*/,
		VSFINDOPTIONS /*grfOptions*/,
		BOOL /*fResetStartPoint*/,
		_In_ IVsFindHelper* /*pHelper*/, 
		_Out_ VSFINDRESULT* /*pResult*/)
	{
		return E_NOTIMPL;
	}

	// It isn't necessary to implement Replace as GetSearchImage which results in hooking into 
	// into VS find/replace engine.
	STDMETHOD(Replace)(
		LPCOLESTR /*pszSearch*/,
		LPCOLESTR /*pszReplace*/,
		VSFINDOPTIONS /*grfOptions*/,
		BOOL /*fResetStartPoint*/,
		_In_ IVsFindHelper * /*pHelper*/,
		_Out_ BOOL * /*pbReplaced*/)
	{    
		return E_NOTIMPL;
	}

#pragma warning(push)
#pragma warning(disable : 4702) // unreachable code
	STDMETHOD(SetFindState)(IUnknown* pIUnknown)
	{
		VSL_STDMETHODTRY{

		m_spFindState = pIUnknown;

		// NOTE - the catch block are currently, but leave this here so it's not forgoten
		// in the future if it is needed.
		}VSL_STDMETHODCATCH()

		return VSL_GET_STDMETHOD_HRESULT();
	}
#pragma warning(pop)

	STDMETHOD(GetFindState)(IUnknown** ppIUnknown)
	{
		VSL_STDMETHODTRY{

		VSL_CHECKPOINTER(ppIUnknown, E_INVALIDARG);

		*ppIUnknown = m_spFindState;
		if(*ppIUnknown)
		{
			(*ppIUnknown)->AddRef();
		}

		}VSL_STDMETHODCATCH()

		return VSL_GET_STDMETHOD_HRESULT();
	}

	STDMETHOD(GetMatchRect)(_Out_ PRECT /*prc*/)
	{
		return E_NOTIMPL;
	}

	STDMETHOD(NotifyFindTarget)(VSFTNOTIFY /*notification*/)
	{
		return S_OK;
	}

	STDMETHOD(MarkSpan)(const TextSpan* /*pts*/)
	{
		return E_NOTIMPL;
	}

private:

	CComPtr<IUnknown> m_spFindState;

};

/***************************************************************************
IVsTextImage implementation
***************************************************************************/

class ImageLockSimple
{

public:

	ImageLockSimple():
		 m_bLock(false)
	{
	}

	HRESULT Lock(/* [in] */ DWORD /*dwLock*/)
	{
		// Only one reader/writer is allowed at a time, so there is only one lock
		if(!m_bLock)
		{
			m_bLock = true;
			return S_OK;
		}

		return E_FAIL;
	}

	HRESULT Unlock(/* [in] */ DWORD /*dwLock*/)
	{
		m_bLock = false;
		return S_OK;
	}

private:

	bool m_bLock;

};

template <class ImageLock_T = ImageLockSimple>
class IVsTextImageImpl :
	public IVsTextImage
{

public:

	STDMETHOD(GetCharSize)( 
		/* [retval][out] */ _Out_ LONG* pcch)
	{
		(pcch);

		return E_NOTIMPL;
	}

	STDMETHOD(GetOffsetOfTextAddress)( 
		/* [in] */ TextAddress ta,
		/* [retval][out] */ _Out_ LONG* piOffset)
	{
		(ta, piOffset);

		return E_NOTIMPL;
	}

	STDMETHOD(GetTextAddressOfOffset)( 
		/* [in] */ LONG iOffset,
		/* [retval][out] */ _Out_ TextAddress* pta)
	{
		(iOffset, pta);

		return E_NOTIMPL;
	}

	STDMETHOD(GetTextBSTR)( 
		/* [in] */ const TextSpan* pts,
		/* [retval][out] */ _Deref_out_z_ BSTR* pbstrText)
	{
		(pts, pbstrText);

		return E_NOTIMPL;
	}

	STDMETHOD(GetText)( 
		/* [in] */ const TextSpan* pts,
		/* [in] */ LONG cch,
		/* [size_is][out] */ _Out_z_cap_(cch) LPOLESTR psz)
	{
		(pts, cch, psz);

		return E_NOTIMPL;
	}

	// NOTE - If the derived class does not utilize operator new [] to allocate
	// the line text, then the derived class must implement ReleaseLine itself
	STDMETHOD(ReleaseLine)( 
		/* [in] */ _In_ LINEDATAEX* pLineData)
	{
		VSL_STDMETHODTRY{

		VSL_CHECKPOINTER(pLineData, E_INVALIDARG);

		// The memory pointed to by pLineData was created by GetLine in the derived class.
		// Assign it to the correct smart pointer type and it will be correctly released in the destructor
		// when the variable goes out of scope.
		Pointer<StdArrayPointerTraits<WCHAR> > szText = const_cast<WCHAR*>(pLineData->pszText);
		pLineData->pszText = L'\0';

		}VSL_STDMETHODCATCH()

		return VSL_GET_STDMETHOD_HRESULT();
	}

	// No text image events to send out to callers, so this just returns S_OK
	STDMETHOD(AdviseTextImageEvents)( 
		/* [in] */ _In_ IVsTextImageEvents* pSink,
		/* [retval][out] */ _Out_ DWORD* pCookie)
	{
		VSL_STDMETHODTRY{

		VSL_CHECKPOINTER(pSink, E_INVALIDARG);
		VSL_CHECKPOINTER(pCookie, E_INVALIDARG);

		return S_OK;

		}VSL_STDMETHODCATCH()

		return VSL_GET_STDMETHOD_HRESULT();
	}

	// No text image events to send out to callers, so this just returns S_OK
	STDMETHOD(UnadviseTextImageEvents)( 
		/* [in] */ DWORD Cookie)
	{
		(Cookie);

		return S_OK;
	}

	STDMETHOD(LockImage)( 
		/* [in] */ DWORD grfLock)
	{
		return m_lock.Lock(grfLock);
	}

	STDMETHOD(UnlockImage)( 
		/* [in] */ DWORD grfLock)
	{
		return m_lock.Unlock(grfLock);
	}
private:

	ImageLock_T m_lock;
};

/***************************************************************************
IVsTextSpanSet implementation
***************************************************************************/

class IVsTextSpanSetImpl :
	public IVsTextSpanSet
{

public:


STDMETHODIMP AttachTextImage( 
	/* [in] */ IUnknown* pText)
{
	VSL_STDMETHODTRY{

	VSL_CHECKPOINTER(pText, E_INVALIDARG);

	// If m_spTextImage isn't NULL, see if it's the same as pText
	if(!!m_spTextImage)
	{
		if(m_spTextImage.IsEqualObject(pText))
		{
			return S_OK;  // Don't need to do any more, this text image has already been attached to 
		}
		else
		{
			m_spTextImage = NULL;
		}
	}

	VSL_CHECKHRESULT(pText->QueryInterface(IID_IVsTextImage, reinterpret_cast<void**>(&m_spTextImage)));
	VSL_CHECKPOINTER(m_spTextImage.p, E_NOINTERFACE); // paranoid

	// Now add the size span of this text to the array
	long iLineCount = 0;
	VSL_CHECKHRESULT(m_spTextImage->GetLineSize(&iLineCount));

	// Get the length of the last line
	long iLastLineLength = 0;
	long iLastLine = 0;
	if(iLineCount >= 1)
	{
		iLastLine = iLineCount-1;
		VSL_CHECKHRESULT(m_spTextImage->GetLineLength(iLineCount-1, &iLastLineLength));
	}

	TextSpan textSpan;
	textSpan.iStartLine = 0;
	textSpan.iStartIndex = 0;
	textSpan.iEndLine = iLastLine;
	textSpan.iEndIndex = iLastLineLength;

	m_pTextSpanArray.Add(textSpan);

	}VSL_STDMETHODCATCH()

	return VSL_GET_STDMETHOD_HRESULT();
	
}
		

STDMETHODIMP Detach()
{
	m_spTextImage = NULL;
	m_pTextSpanArray.RemoveAll();

	return S_OK;
}
		

STDMETHODIMP SuspendTracking()
{
	return E_NOTIMPL;
}
		

STDMETHODIMP ResumeTracking()
{
	return E_NOTIMPL;
}
		

STDMETHODIMP Add( 
	/* [in] */ LONG cel,
	/* [size_is][in] */ const TextSpan* pSpan)
{
	VSL_STDMETHODTRY{

	VSL_CHECKPOINTER(pSpan, E_INVALIDARG);

	m_pTextSpanArray.SetAtGrow(cel, *pSpan);

	}VSL_STDMETHODCATCH()

	return VSL_GET_STDMETHOD_HRESULT();
}
		

STDMETHODIMP GetCount( 
	/* [retval][out] */ LONG* pcel)
{
	VSL_STDMETHODTRY{

	VSL_CHECKPOINTER(pcel, E_INVALIDARG);

	*pcel = static_cast<LONG>(m_pTextSpanArray.GetCount());

	}VSL_STDMETHODCATCH()

	return VSL_GET_STDMETHOD_HRESULT();
	
}
		

STDMETHODIMP GetAt( 
	/* [in] */ LONG iEl,
	/* [retval][out] */ TextSpan* pSpan)
{
	VSL_STDMETHODTRY{

	VSL_CHECKPOINTER(pSpan, E_INVALIDARG);

	if(iEl >= static_cast<LONG>(m_pTextSpanArray.GetCount()))
	{
		return E_INVALIDARG;
	}

	*pSpan = m_pTextSpanArray.GetAt(iEl);

	}VSL_STDMETHODCATCH()

	return VSL_GET_STDMETHOD_HRESULT();
}
		

STDMETHODIMP RemoveAll()
{
	m_pTextSpanArray.RemoveAll();

	return S_OK;
}
		

STDMETHODIMP Sort( 
	/* [in] */ DWORD SortOptions)
{
	(SortOptions);

	return E_NOTIMPL;
}
		

STDMETHODIMP AddFromEnum( 
	/* [in] */ IVsEnumTextSpans* pEnum)
{
	(pEnum);

	return E_NOTIMPL;
}

private:

	CAtlArray<TextSpan> m_pTextSpanArray;

	CComPtr<IVsTextImage> m_spTextImage;

};

/***************************************************************************
IVsTextView implementation

This is just provided so that the find in files scenario will work 
properly.  It isn't necesary to implement most of the methods for this
scenario to work correctly.
***************************************************************************/

class IVsTextViewSimpleImpl :
	public IVsTextView
{

public:

STDMETHODIMP Initialize(
	IVsTextLines* pBuffer, 
	HWND hwndParent, 
	DWORD dwInitFlags, 
	const INITVIEW* pPrefs)
{
	(pBuffer, hwndParent, dwInitFlags, pPrefs);

	return E_NOTIMPL;
}


STDMETHODIMP CloseView()
{
	return E_NOTIMPL;
}


STDMETHODIMP GetCaretPos(long* piLine, ViewCol* piColumn)
{
	(piLine, piColumn);

	return E_NOTIMPL;
}


STDMETHODIMP SetCaretPos(long iLine, ViewCol iColumn)
{
	(iLine, iColumn);

	return E_NOTIMPL;
}


STDMETHODIMP GetSelectionSpan(TextSpan* pSpan)
{
	(pSpan);

	return E_NOTIMPL;
}


STDMETHODIMP GetSelection(
	long* piAnchorLine, 
	ViewCol* piAnchorCol, 
	long* piEndLine, 
	ViewCol* piEndCol)
{
	(piAnchorLine, piAnchorCol, piEndLine, piEndCol);

	return E_NOTIMPL;
}

// SetSelection is implementation specific


virtual TextSelMode STDMETHODCALLTYPE GetSelectionMode()
{
	return SM_STREAM;
}


STDMETHODIMP SetSelectionMode(TextSelMode iSelMode)
{
	(iSelMode);

	return E_NOTIMPL;
}


STDMETHODIMP ClearSelection(BOOL fMoveToAnchor)
{
	(fMoveToAnchor);

	return E_NOTIMPL;
}


STDMETHODIMP CenterLines(long iLine, long iCount)
{
	(iLine, iCount);

	return E_NOTIMPL;
}


STDMETHODIMP GetSelectedText(BSTR* bstrText)
{
	(bstrText);

	return E_NOTIMPL;
}


STDMETHODIMP GetSelectionDataObject(IDataObject** ppIDataObject)
{
	(ppIDataObject);

	return E_NOTIMPL;
}


STDMETHODIMP GetTextStream(
	long iTopLine, 
	ViewCol iTopCol, 
	long iBottomLine, 
	ViewCol iBottomCol, 
	BSTR* pbstrText)
{
	(iTopLine, iTopCol, iBottomLine, iBottomCol, pbstrText);

	return E_NOTIMPL;
}


STDMETHODIMP GetBuffer(IVsTextLines** ppBuffer)
{
	VSL_STDMETHODTRY{

	VSL_CHECKPOINTER(ppBuffer, E_INVALIDARG);
	*ppBuffer = NULL;
	
	VSL_CHECKHRESULT(QueryInterface(IID_IVsTextLines, reinterpret_cast<void**>(ppBuffer)));
	VSL_CHECKPOINTER(*ppBuffer, E_NOINTERFACE); // paranoid

	}VSL_STDMETHODCATCH()

	return VSL_GET_STDMETHOD_HRESULT();
}


STDMETHODIMP SetBuffer(IVsTextLines* pBuffer)
{
	(pBuffer);

	return E_NOTIMPL;
}


virtual HWND STDMETHODCALLTYPE GetWindowHandle()
{
	return NULL;
}


STDMETHODIMP GetScrollInfo(
	long iBar, 
	long* piFirst, 
	long* piLast, 
	long* piVisible, 
	long* piTop)
{
	(iBar, piFirst, piLast, piVisible, piTop);

	return E_NOTIMPL;
}


STDMETHODIMP SetScrollPosition(long iBar, long iPos)
{
	(iBar, iPos);

	return E_NOTIMPL;
}


STDMETHODIMP AddCommandFilter(
	IOleCommandTarget* pNewCmdTarg, 
	IOleCommandTarget** ppNextCmdTarg)
{
	(pNewCmdTarg, ppNextCmdTarg);

	return E_NOTIMPL;
}


STDMETHODIMP RemoveCommandFilter(IOleCommandTarget* pCmdTarg)
{
	(pCmdTarg);

	return E_NOTIMPL;
}


STDMETHODIMP UpdateCompletionStatus(IVsCompletionSet* pCompSet, DWORD dwFlags)
{
	(pCompSet, dwFlags);

	return E_NOTIMPL;
}


STDMETHODIMP UpdateTipWindow(IVsTipWindow* pTipWnd, DWORD dwFlags)
{
	(pTipWnd, dwFlags);

	return E_NOTIMPL;
}


STDMETHODIMP GetWordExtent(
	long iLine, 
	CharIndex iCharIndex, 
	DWORD dwFlags, 
	TextSpan* pSpan)
{
	(iLine, iCharIndex, dwFlags, pSpan);

	return E_NOTIMPL;
}


STDMETHODIMP RestrictViewRange(
	long iMinLine, 
	long iMaxLine, 
	IVsViewRangeClient* pClient)
{
	(iMinLine, iMaxLine, pClient);

	return E_NOTIMPL;
}


STDMETHODIMP BeginCompoundEdit(const WCHAR *pszDescription)
{
	(pszDescription);

	return E_NOTIMPL;
}


STDMETHODIMP EndCompoundEdit()
{
	return E_NOTIMPL;
}


STDMETHODIMP AbortCompoundEdit()
{
	return E_NOTIMPL;
}


STDMETHODIMP ReplaceTextOnLine(
	long iLine, 
	CharIndex iStartCol, 
	long iCharsToReplace, 
	const WCHAR* pszNewText,
	long iNewLen)
{
	(iLine, iStartCol, iCharsToReplace, pszNewText, iNewLen);

	return E_NOTIMPL;
}


STDMETHODIMP GetLineAndColumn(
	long iPos, 
	long* piLine, 
	CharIndex* piCol)
{
	(iPos, piLine, piCol);

	return E_NOTIMPL;
}


STDMETHODIMP GetNearestPosition(
	long iLine, 
	long iCol,
	long* piPos,
	long* piVirtualSpaces)
{
	(iLine, iCol, piPos, piVirtualSpaces);

	return E_NOTIMPL;
}


STDMETHODIMP UpdateViewFrameCaption()
{
	return E_NOTIMPL;
}


STDMETHODIMP CenterColumns(
	long iLine, 
	long iLeftCol,
	long iColCount)
{
	(iLine, iLeftCol, iColCount);

	return E_NOTIMPL;
}


STDMETHODIMP EnsureSpanVisible(TextSpan span)
{
	(span);

	return E_NOTIMPL;
}


STDMETHODIMP PositionCaretForEditing(long iLine, long cIndentLevels)
{
	(iLine, cIndentLevels);

	return E_NOTIMPL;
}


STDMETHODIMP GetPointOfLineColumn(long iLine, ViewCol iCol, POINT* ppt)
{
	(iLine, iCol, ppt);

	return E_NOTIMPL;
}


STDMETHODIMP GetLineHeight(long* piLineHeight)
{
	(piLineHeight);

	return E_NOTIMPL;
}


STDMETHODIMP HighlightMatchingBrace(
	DWORD dwFlags, 
	ULONG cSpans, 
	TextSpan* rgBaseTextSpans)
{
	(dwFlags, cSpans, rgBaseTextSpans);

	return E_NOTIMPL;
}


STDMETHODIMP SendExplicitFocus()
{
	return E_NOTIMPL;
}


STDMETHODIMP SetTopLine(long iBaseLine)
{
	(iBaseLine);

	return E_NOTIMPL;
}

};

/***************************************************************************
IVsTextViewEvents implementation

This is just provided so that the find in files scenario will work 
properly.  It isn't necesary to implement any of the methods; however,
the it must be possible to create a connection point to this event
inteface for the scenario to work correctly.
***************************************************************************/

class IVsTextViewEventsNotImpl :
	public IVsTextViewEvents
{

public:

void STDMETHODCALLTYPE OnSetFocus(IVsTextView* pView)
{
	(pView);
}


void STDMETHODCALLTYPE OnKillFocus(IVsTextView* pView)
{
	(pView);
}


void STDMETHODCALLTYPE OnSetBuffer(IVsTextView* pView, IVsTextLines* pBuffer)
{
	(pView, pBuffer);
}


void STDMETHODCALLTYPE OnChangeScrollInfo(
	IVsTextView* pView, 
	long iBar, 
	long iMinUnit, 
	long iMaxUnits, 
	long iVisibleUnits, 
	long iFirstVisibleUnit)
{
	(pView, iBar, iMinUnit, iMaxUnits, iVisibleUnits, iFirstVisibleUnit);
}


void STDMETHODCALLTYPE OnChangeCaretLine(
	IVsTextView* pView, 
	long iNewLine, 
	long iOldLine)
{
	(pView, iNewLine, iOldLine);
}

};

/***************************************************************************
IVsCodeWindow implementation

This is just provided so that the find in files scenario will work 
properly.  It isn't necesary to implement most of the methods for this
scenario to work correctly.

TODO - 3/13/2006 - push this up into VSL
***************************************************************************/

class IVsCodeWindowSingleViewSimpleImpl:
	public IVsCodeWindow
{

public:

STDMETHODIMP GetBuffer(IVsTextLines** ppBuffer)
{
	VSL_STDMETHODTRY{

	VSL_CHECKPOINTER(ppBuffer, E_INVALIDARG);
	*ppBuffer = NULL;
	
	VSL_CHECKHRESULT(QueryInterface(IID_IVsTextLines, reinterpret_cast<void**>(ppBuffer)));
	VSL_CHECKPOINTER(*ppBuffer, E_NOINTERFACE); // paranoid

	}VSL_STDMETHODCATCH()

	return VSL_GET_STDMETHOD_HRESULT();
}


STDMETHODIMP SetBuffer(IVsTextLines* pBuffer)
{
	(pBuffer);

	return E_NOTIMPL;
}

STDMETHODIMP GetPrimaryView(IVsTextView** ppView)
{
	VSL_STDMETHODTRY{

	VSL_CHECKPOINTER(ppView, E_INVALIDARG);
	*ppView = NULL;

	VSL_CHECKHRESULT(QueryInterface(IID_IVsTextView, reinterpret_cast<void**>(ppView)));
	VSL_CHECKPOINTER(*ppView, E_NOINTERFACE); // paranoid

	}VSL_STDMETHODCATCH()

	return VSL_GET_STDMETHOD_HRESULT();
}


STDMETHODIMP GetSecondaryView(IVsTextView** ppView)
{
	(ppView);

	return E_NOTIMPL;
}


STDMETHODIMP SetViewClassID(REFCLSID clsidView)
{
	(clsidView);

	return E_NOTIMPL;
}


STDMETHODIMP GetViewClassID(CLSID* pclsidView)
{
	(pclsidView);

	return E_NOTIMPL;
}


STDMETHODIMP SetBaseEditorCaption(LPCOLESTR* pszBaseEditorCaption)
{
	(pszBaseEditorCaption);

	return E_NOTIMPL;
}


STDMETHODIMP GetEditorCaption(READONLYSTATUS dwReadOnly, BSTR* pbstrEditorCaption)
{
	(dwReadOnly, pbstrEditorCaption);

	return E_NOTIMPL;
}


STDMETHODIMP Close(void)
{
	return E_NOTIMPL;
}


STDMETHODIMP GetLastActiveView(IVsTextView** ppView)
{
	VSL_STDMETHODTRY{

	VSL_CHECKPOINTER(ppView, E_INVALIDARG);
	*ppView = NULL;
	
	VSL_CHECKHRESULT(QueryInterface(IID_IVsTextView, reinterpret_cast<void**>(ppView)));
	VSL_CHECKPOINTER(*ppView, E_NOINTERFACE); // paranoid

	}VSL_STDMETHODCATCH()

	return VSL_GET_STDMETHOD_HRESULT();
}

};

/***************************************************************************
IVsTextLines implementation

All methods return E_NOTIMPL as this is is just needed inorder to return
from IVsTextView::GetBuffer, IVsCodeWindow::GetPrimaryView,
IVsCodeWindow::GetLastActiveView during a find in files, as the caller 
in that scenario only does a QI from this interface and doesn't actually 
make use of any methods.
***************************************************************************/

class IVsTextLinesNotImpl :
	public IVsTextLines
{

public:

STDMETHODIMP LockBuffer()
{
	return E_NOTIMPL;
}


STDMETHODIMP UnlockBuffer()
{
	return E_NOTIMPL;
}


STDMETHODIMP InitializeContent(const WCHAR* pszText, long iLength)
{
	(pszText, iLength);

	return E_NOTIMPL;
}


STDMETHODIMP GetStateFlags(DWORD* pdwReadOnlyFlags)
{
	(pdwReadOnlyFlags);

	return E_NOTIMPL;
}


STDMETHODIMP SetStateFlags(DWORD dwReadOnlyFlags)
{
	(dwReadOnlyFlags);

	return E_NOTIMPL;
}


STDMETHODIMP GetPositionOfLine(long iLine, long* piPosition)
{
	(iLine, piPosition);

	return E_NOTIMPL;
}


STDMETHODIMP GetPositionOfLineIndex(
	long iLine, 
	CharIndex iIndex, 
	long* piPosition)
{
	(iLine, iIndex, piPosition);

	return E_NOTIMPL;
}


STDMETHODIMP GetLineIndexOfPosition(
	long iPosition, 
	long* piLine, 
	CharIndex* piColumn)
{
	(iPosition, piLine, piColumn);

	return E_NOTIMPL;
}

// GetLengthOfLine is implemenation specific


STDMETHODIMP GetLineCount(long* piLineCount)
{
	(piLineCount);

	return E_NOTIMPL;
}


STDMETHODIMP GetSize(long* piLength)
{
	(piLength);

	return E_NOTIMPL;
}


STDMETHODIMP GetLanguageServiceID(GUID* pguidLangService)
{
	(pguidLangService);

	return E_NOTIMPL;
}


STDMETHODIMP SetLanguageServiceID(REFGUID guidLangService)
{
	(guidLangService);

	return E_NOTIMPL;
}


STDMETHODIMP GetUndoManager(IOleUndoManager** ppUndoManager)
{
	(ppUndoManager);

	return E_NOTIMPL;
}


STDMETHODIMP Reserved1()
{
	return E_NOTIMPL;
}


STDMETHODIMP Reserved2()
{
	return E_NOTIMPL;
}


STDMETHODIMP Reserved3()
{
	return E_NOTIMPL;
}


STDMETHODIMP Reserved4()
{
	return E_NOTIMPL;
}


STDMETHODIMP Reload(BOOL fUndoable)
{
	(fUndoable);

	return E_NOTIMPL;
}


STDMETHODIMP LockBufferEx(DWORD dwFlags)
{
	(dwFlags);

	return E_NOTIMPL;
}


STDMETHODIMP UnlockBufferEx(DWORD dwFlags)
{
	(dwFlags);

	return E_NOTIMPL;
}

// GetLastLineIndex is implementation specific


STDMETHODIMP Reserved5()
{
	return E_NOTIMPL;
}


STDMETHODIMP Reserved6()
{
	return E_NOTIMPL;
}


STDMETHODIMP Reserved7()
{
	return E_NOTIMPL;
}


STDMETHODIMP Reserved8()
{
	return E_NOTIMPL;
}


STDMETHODIMP Reserved9()
{
	return E_NOTIMPL;
}


STDMETHODIMP Reserved10()
{
	return E_NOTIMPL;
}

STDMETHODIMP GetMarkerData( 
	/* [in] */ long iTopLine,
	/* [in] */ long iBottomLine,
	/* [out] */ MARKERDATA* pMarkerData)
{
	(iTopLine, iBottomLine, pMarkerData);

	return E_NOTIMPL;
}
		

STDMETHODIMP ReleaseMarkerData( 
	/* [in] */ MARKERDATA* pMarkerData)
{
	(pMarkerData);

	return E_NOTIMPL;
}
		

STDMETHODIMP GetLineData( 
	/* [in] */ long iLine,
	/* [out] */ LINEDATA* pLineData,
	/* [in] */ MARKERDATA* pMarkerData)
{
	(iLine, pLineData, pMarkerData);

	return E_NOTIMPL;
}
		

STDMETHODIMP ReleaseLineData( 
	/* [in] */ LINEDATA* pLineData)
{
	(pLineData);

	return E_NOTIMPL;
}
		

STDMETHODIMP GetLineText( 
	/* [in] */ long iStartLine,
	/* [in] */ CharIndex iStartIndex,
	/* [in] */ long iEndLine,
	/* [in] */ CharIndex iEndIndex,
	/* [out] */ BSTR* pbstrBuf)
{
	(iStartLine, iStartIndex, iEndLine, iEndIndex, pbstrBuf);

	return E_NOTIMPL;
}
		

STDMETHODIMP CopyLineText( 
	/* [in] */ long iStartLine,
	/* [in] */ CharIndex iStartIndex,
	/* [in] */ long iEndLine,
	/* [in] */ CharIndex iEndIndex,
	/* [in] */ _In_ LPWSTR pszBuf,
	/* [out][in] */ long* pcchBuf)
{
	(iStartLine, iStartIndex, iEndLine, iEndIndex, pszBuf, pcchBuf);

	return E_NOTIMPL;
}
		

STDMETHODIMP ReplaceLines( 
	/* [in] */ long iStartLine,
	/* [in] */ CharIndex iStartIndex,
	/* [in] */ long iEndLine,
	/* [in] */ CharIndex iEndIndex,
	/* [in] */ LPCWSTR pszText,
	/* [in] */ long iNewLen,
	/* [out] */ TextSpan* pChangedSpan)
{
	(iStartLine, iStartIndex, iEndLine, iEndIndex, pszText, iNewLen, pChangedSpan);

	return E_NOTIMPL;
}
		

STDMETHODIMP CanReplaceLines( 
	/* [in] */ long iStartLine,
	/* [in] */ CharIndex iStartIndex,
	/* [in] */ long iEndLine,
	/* [in] */ CharIndex iEndIndex,
	/* [in] */ long iNewLen)
{
	(iStartLine, iStartIndex, iEndLine, iEndIndex, iNewLen);

	return E_NOTIMPL;
}
		

STDMETHODIMP CreateLineMarker( 
	/* [in] */ long iMarkerType,
	/* [in] */ long iStartLine,
	/* [in] */ CharIndex iStartIndex,
	/* [in] */ long iEndLine,
	/* [in] */ CharIndex iEndIndex,
	/* [in] */ IVsTextMarkerClient *pClient,
	/* [out] */ IVsTextLineMarker **ppMarker)
{
	(iMarkerType, iStartLine, iStartIndex, iEndLine, iEndIndex, pClient, ppMarker);

	return E_NOTIMPL;
}
		

STDMETHODIMP EnumMarkers( 
	/* [in] */ long iStartLine,
	/* [in] */ CharIndex iStartIndex,
	/* [in] */ long iEndLine,
	/* [in] */ CharIndex iEndIndex,
	/* [in] */ long iMarkerType,
	/* [in] */ DWORD dwFlags,
	/* [out] */ IVsEnumLineMarkers** ppEnum)
{
	(iStartLine, iStartIndex, iEndLine, iEndIndex, iMarkerType, dwFlags, ppEnum);

	return E_NOTIMPL;
}
		

STDMETHODIMP FindMarkerByLineIndex( 
	/* [in] */ long iMarkerType,
	/* [in] */ long iStartingLine,
	/* [in] */ CharIndex iStartingIndex,
	/* [in] */ DWORD dwFlags,
	/* [out] */ IVsTextLineMarker** ppMarker)
{
	(iMarkerType, iStartingLine, iStartingIndex, dwFlags, ppMarker);

	return E_NOTIMPL;
}
		

STDMETHODIMP AdviseTextLinesEvents( 
	/* [in] */ IVsTextLinesEvents* pSink,
	/* [out] */ DWORD* pdwCookie)
{
	(pSink, pdwCookie);

	return E_NOTIMPL;
}
		

STDMETHODIMP UnadviseTextLinesEvents( 
	/* [in] */ DWORD dwCookie)
{
	(dwCookie);

	return E_NOTIMPL;
}
		

STDMETHODIMP GetPairExtents( 
	/* [in] */ const TextSpan* pSpanIn,
	/* [out] */ TextSpan* pSpanOut)
{
	(pSpanIn, pSpanOut);

	return E_NOTIMPL;
}
		

STDMETHODIMP ReloadLines( 
	/* [in] */ long iStartLine,
	/* [in] */ CharIndex iStartIndex,
	/* [in] */ long iEndLine,
	/* [in] */ CharIndex iEndIndex,
	/* [in] */ LPCWSTR pszText,
	/* [in] */ long iNewLen,
	/* [out] */ TextSpan* pChangedSpan)
{
	(iStartLine, iStartIndex, iEndLine, iEndIndex, pszText, iNewLen, pChangedSpan);

	return E_NOTIMPL;
}
		

STDMETHODIMP IVsTextLinesReserved1(
	/* [in] */ long iLine,
	/* [out] */ LINEDATA* pLineData,
	/* [in] */ BOOL fAttributes)
{
	(iLine, pLineData, fAttributes);

	return E_NOTIMPL;
}
		

STDMETHODIMP GetLineDataEx(
	/* [in] */ DWORD dwFlags,
	/* [in] */ long iLine,
	/* [in] */ long iStartIndex,
	/* [in] */ long iEndIndex,
	/* [out] */ LINEDATAEX* pLineData,
	/* [in] */ MARKERDATA* pMarkerData)
{
	(dwFlags, iLine, iStartIndex, iEndIndex, pLineData, pMarkerData);

	return E_NOTIMPL;
}
		

STDMETHODIMP ReleaseLineDataEx(
	/* [in] */ LINEDATAEX* pLineData)
{
	(pLineData);

	return E_NOTIMPL;
}
		

STDMETHODIMP CreateEditPoint(
	/* [in] */ long iLine,
	/* [in] */ CharIndex iIndex,
	/* [out] */ IDispatch** ppEditPoint)
{
	(iLine, iIndex, ppEditPoint);

	return E_NOTIMPL;
}
		

STDMETHODIMP ReplaceLinesEx( 
	/* [in] */ DWORD dwFlags,
	/* [in] */ long iStartLine,
	/* [in] */ CharIndex iStartIndex,
	/* [in] */ long iEndLine,
	/* [in] */ CharIndex iEndIndex,
	/* [in] */ LPCWSTR pszText,
	/* [in] */ long iNewLen,
	/* [out] */ TextSpan* pChangedSpan)
{
	(dwFlags, iStartLine, iStartIndex, iEndLine, iEndIndex, pszText, iNewLen, pChangedSpan);

	return E_NOTIMPL;
}
		

STDMETHODIMP CreateTextPoint( 
	/* [in] */ long iLine,
	/* [in] */ CharIndex iIndex,
	/* [out] */ IDispatch** ppTextPoint)
{
	(iLine, iIndex, ppTextPoint);

	return E_NOTIMPL;
}

};

/*
All four of these interfaces, as well as a connection point for IVsTextViewEvents, are required so 
that double-clicking on results of a find in files in the output window will correctly naviagate 
to the location in the document.  That is the only only scenario these interfaces are required for.
*/
template <class Derived_T>
class SingleViewFindInFilesOutputWindowIntegrationImpl :
	public IVsTextViewSimpleImpl,
	public IVsTextViewEventsNotImpl,
	public IVsCodeWindowSingleViewSimpleImpl,
	public IVsTextLinesNotImpl
{
protected:

	// Call in CreatePaneWindow
	void RegisterToTextManager()
	{
		Derived_T& rDerived = *(static_cast<Derived_T*>(this));

		CComPtr<IVsTextManager> spTextManager;
		// REVIEW - 3/17/2006 - is this ever not present?
		if(SUCCEEDED(rDerived.GetVsSiteCache().QueryService(SID_SVsTextManager, &spTextManager)))
		{
			CComPtr<IVsTextView> spTextView;
			VSL_CHECKHRESULT(rDerived._GetRawUnknown()->QueryInterface(IID_IVsTextView, reinterpret_cast<void**>(&spTextView)));

			CComPtr<IVsTextBuffer> spTextBuffer;
			VSL_CHECKHRESULT(rDerived._GetRawUnknown()->QueryInterface(IID_IVsTextBuffer, reinterpret_cast<void**>(&spTextBuffer)));

			VSL_CHECKHRESULT(spTextManager->RegisterView(spTextView, spTextBuffer));
		}
	}

	void UnregisterFromTextManager()
	{
		Derived_T& rDerived = *(static_cast<Derived_T*>(this));

		CComPtr<IVsTextManager> spTextManager;
		// REVIEW - 3/17/2006 - is this ever not present?
		if(SUCCEEDED(rDerived.GetVsSiteCache().QueryService(SID_SVsTextManager, &spTextManager)))
		{
			CComPtr<IVsTextView> spTextView;
			VSL_CHECKHRESULT(rDerived._GetRawUnknown()->QueryInterface(IID_IVsTextView, reinterpret_cast<void**>(&spTextView)));

			VSL_CHECKHRESULT(spTextManager->UnregisterView(spTextView));
		}
	}

};

} // namespace VSL

#endif VSLFINDANDREPLACE_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\Include\VSLFile.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef VSLFILE_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define VSLFILE_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

// VSL includes
#include <VSLVsSite.h>

// ATL includes
#include <ATLFile.h>

namespace VSL
{

class File
{
public:
	File() :
		m_szFullPathName(),
		m_hFile()
	{
	}

	// Transfers ownership of the handle
	// Having the parameter be const allows it to work correctly with STL containers
	File(_In_ const File& file) :
		m_szFullPathName(const_cast<File&>(file).m_szFullPathName),
		m_hFile(const_cast<File&>(file).m_hFile)
	{
	}

	// Does not open the file handle
	explicit File(_In_z_ const wchar_t* szFullPathName) :
		m_szFullPathName(szFullPathName),
		m_hFile()
	{
	}

	const ATL::CStringW& GetFullPathName() const
	{
		return m_szFullPathName;
	}

	ATL::CStringW& GetFullPathName()
	{
		return m_szFullPathName;
	}

	operator const wchar_t*() const
	{
		return m_szFullPathName;
	}

	bool IsFileReadOnly()
	{
		VSL_CHECKBOOLEAN(!m_szFullPathName.IsEmpty(), E_FAIL);
		DWORD dwAttr = ::GetFileAttributesW(m_szFullPathName);
		VSL_CHECKBOOLEAN_GLE(dwAttr != 0);
		return (dwAttr & FILE_ATTRIBUTE_READONLY);
	}

	void Create(
		_In_ DWORD dwDesiredAccess,
		_In_ DWORD dwShareMode,
		_In_ DWORD dwCreationDisposition,
		_In_ DWORD dwFlagsAndAttributes = FILE_ATTRIBUTE_NORMAL,
		_In_opt_ LPSECURITY_ATTRIBUTES lpsa = NULL,
		_In_opt_ HANDLE hTemplateFile = NULL)
	{
		VSL_CHECKBOOLEAN(!m_szFullPathName.IsEmpty(), E_FAIL);

		HRESULT hr = m_hFile.Create(
			m_szFullPathName,
			dwDesiredAccess,
			dwShareMode,
			dwCreationDisposition,
			dwFlagsAndAttributes,
			lpsa,
			hTemplateFile);

		VSL_CHECKHRESULT(hr);
	}

	bool IsZeroLength()
	{
		ULONGLONG iSize;
		VSL_CHECKHRESULT(
			m_hFile.GetSize(iSize));

		return iSize == 0;
	}

	void Close()
	{
		m_hFile.Close();
	}

	operator HANDLE()
	{
		return m_hFile.m_h;
	}

	DWORD GetFileType()
	{
		DWORD dwFileType = ::GetFileType(GetHandle());
		if(FILE_TYPE_UNKNOWN == dwFileType)
		{
			DWORD dwError = ::GetLastError();
			if(dwError != NO_ERROR)
			{
				VSL_CREATE_ERROR_WIN32(dwError);
			}
		}
		return dwFileType;
	}

	bool IsOnDisk()
	{
		return FILE_TYPE_DISK == GetFileType();
	}

	HANDLE GetHandle()
	{
		VSL_CHECKBOOLEAN(m_hFile.m_h, E_FAIL);
		return m_hFile.m_h;
	}

	void Read(
		_Out_bytecap_(nBufSize) LPVOID pBuffer,
		_In_ DWORD nBufSize,
		_Out_ DWORD& nBytesRead)
	{
		VSL_CHECKHRESULT(m_hFile.Read(pBuffer, nBufSize, nBytesRead));
	}

	void Write(
		_In_bytecount_(nBufSize) LPCVOID pBuffer,
		_In_ DWORD nBufSize,
		_Out_opt_ DWORD* pnBytesWritten = NULL)
	{
		VSL_CHECKHRESULT(m_hFile.Write(pBuffer, nBufSize, pnBytesWritten));
	}

	void Seek(_In_ LONGLONG nOffset, _In_ DWORD dwFrom = FILE_CURRENT)
	{
		VSL_CHECKHRESULT(m_hFile.Seek(nOffset, dwFrom));
	}

private:
	ATL::CStringW m_szFullPathName;
	ATL::CAtlFile m_hFile;
};

template <
	class Derived_T,
	class File_T = File,
	class VsSiteCache_T = VsSiteCacheLocal>
class DocumentPersistanceBase :
	public IVsPersistDocData,
	public IVsFileChangeEvents,
	public IVsDocDataFileChangeControl,
	public IPersistFileFormat,
	public IVsFileBackup
{

VSL_DECLARE_NOT_COPYABLE(DocumentPersistanceBase)

public:

	typedef Derived_T Derived;
	typedef File_T File;
	typedef VsSiteCache_T VsSiteCache;

/***************************************************************************
 IVsFileChangeEvents methods
***************************************************************************/

	// Called to notify of file state changes
	STDMETHOD(FilesChanged)(
		DWORD cChanges, 
		LPCOLESTR rglpstrFile[], 
		_In_count_(cChanges) VSFILECHANGEFLAGS rggrfChange[])
	{
		VSL_STDMETHODTRY{

		VSL_CHECKBOOLEAN(cChanges > 0, E_INVALIDARG);
		VSL_CHECKPOINTER(rglpstrFile, E_INVALIDARG);
		VSL_CHECKPOINTER(rggrfChange, E_INVALIDARG);

		if(m_iIgnoreFileChangeLevel > 0)
		{
			// IgnoreFileChanges has been called to indicate that
			// file state changes should be ignored currently
			return S_OK;
		}

		for(DWORD i = 0; i < cChanges; ++i)
		{
			if(rglpstrFile[i] && 0 == GetFileName().CompareNoCase(rglpstrFile[i]))
			{
				Derived& rDerived = *(static_cast<Derived*>(this));

				// If the readonly file attributes has changed, then the state
				// can be updated to match the new state without prompting the 
				// user
				if(rggrfChange[i] & VSFILECHG_Attr)
				{
					BOOL fIsSysReadOnly = m_File.IsFileReadOnly();
					SetReadOnly(fIsSysReadOnly);
				}

				/*
				If the file size or time have have changed then prompt the user to see if the should be
				reloaded.
				
				The file should not be reloaded here as it is possible that there will be more than one 
				FilesChanged notification as separate notifications can be recieved in short order.  
				Additionally, it is the preferred UI style not to prompt the user, until Visual Stuidio
				is brought to the foreground.  Thus, the derived class is called to set a timer
				to cause the user to be prompted if the file should be reloaded after short delay.
				*/
				if((rggrfChange[i] & (VSFILECHG_Time | VSFILECHG_Size)) && !m_bFileChangedTimerSet)
				{
					m_bFileChangedTimerSet = true;

					// Send the message to the parent window.
					rDerived.OnFileChangedSetTimer();
				} 
			}
		}

		}VSL_STDMETHODCATCH()

		return VSL_GET_STDMETHOD_HRESULT();
	}

	// Called to notify of directoy state changes
	STDMETHOD(DirectoryChanged)(LPCOLESTR /*pszDirectory*/)
	{
		// No action required
		return S_OK;
	}

/***************************************************************************
IVsDocDataFileChangeControl methods
***************************************************************************/

	// Called to indicate that file changes should be ignored
	// Balanced calls with fIgnore set to TRUE and FALSE are expected
	STDMETHOD(IgnoreFileChanges)(BOOL fIgnore)
	{
		VSL_STDMETHODTRY{

		if(fIgnore)
		{
			++m_iIgnoreFileChangeLevel;
		}
		else 
		{
			VSL_CHECKBOOLEAN(m_iIgnoreFileChangeLevel > 0, E_UNEXPECTED);

			--m_iIgnoreFileChangeLevel;

			// If we are no longer ignoring files changes and the read only state of 
			// the file doesn't match the cached state then update accordingly to ensure 
			// the caption is update to date
			if(m_iIgnoreFileChangeLevel == 0)
			{
				bool bReadOnly = m_File.IsFileReadOnly();
				if(IsFileReadOnly() != bReadOnly)
				{
					SetReadOnly(bReadOnly);
				}
			}
		}

		}VSL_STDMETHODCATCH()

		return VSL_GET_STDMETHOD_HRESULT();
	}

/***************************************************************************
IPersistFileFormat methods
***************************************************************************/

	STDMETHOD(IsDirty)(_Out_ BOOL *pfIsDirty)
	{
		VSL_STDMETHODTRY{

		VSL_CHECKPOINTER(pfIsDirty, E_INVALIDARG);

		*pfIsDirty = IsFileDirty();

		}VSL_STDMETHODCATCH()

		return VSL_GET_STDMETHOD_HRESULT();
	}

	STDMETHOD(InitNew)(DWORD nFormatIndex)
	{
		VSL_STDMETHODTRY{

		Derived& rDerived = *(static_cast<Derived*>(this));

		VSL_CHECKBOOLEAN(rDerived.IsValidFormat(nFormatIndex), E_INVALIDARG);

		m_dwFormatIndex = nFormatIndex;

		}VSL_STDMETHODCATCH()

		return VSL_GET_STDMETHOD_HRESULT();
	}

	STDMETHOD(Load)(LPCOLESTR pszFilename, DWORD /*grfMode*/, BOOL fReadOnly)
	{
		VSL_STDMETHODTRY{

		// Check that the file name is valid
		VSL_CHECKBOOLEAN(CheckFileName(pszFilename), E_INVALIDARG);

		// Set the wait cursor while we are loading the file
		CComPtr<IVsUIShell> spIVsUIShell = GetDerivedVsSiteChache().GetCachedService<IVsUIShell, SID_SVsUIShell>();
		VSL_CHECKPOINTER(spIVsUIShell.p, E_FAIL);
		VSL_CHECKHRESULT(spIVsUIShell->SetWaitCursor());

		File file(static_cast<const wchar_t*>(pszFilename));
		BOOL fIsSysReadOnly = file.IsFileReadOnly();

		// Open the file for reading
		file.Create(
			GENERIC_READ, 
			FILE_SHARE_READ | FILE_SHARE_WRITE,
			OPEN_EXISTING,
			FILE_FLAG_SEQUENTIAL_SCAN);

		VSL_CHECKBOOLEAN(file.GetFileType() == FILE_TYPE_DISK, __HRESULT_FROM_WIN32(ERROR_INVALID_NAME));

		DWORD dwFormatIndex = DEF_FORMAT_INDEX;
		HRESULT hr = S_OK;
		if(!file.IsZeroLength())
		{
			// Read in the contents, should not throw C++ exceptions
			Derived& rDerived = *(static_cast<Derived*>(this));
			// TODO - put a wrapper function around this so that ReadData can throw
			hr = rDerived.ReadData(file, FALSE, dwFormatIndex);
		}

		if(STG_E_INVALIDCODEPAGE == hr || STG_E_NOTTEXT == hr)
		{
			// These return code indicate that the file wasn't valid
			// and internal state was not modified, so return the 
			// error immediately
			return hr;
		}

		if(FAILED(hr)) // STG_S_DATALOSS like any other error
		{
			// Assume existing data has been lost, so re-initialize
			Initialize();
			return hr;
		}

		// Clear out the current file state
		ResetFileState();

		// Set appropriate flags
		m_dwFormatIndex = dwFormatIndex;
		SetDirty(false);
		SetReadOnly(fReadOnly || fIsSysReadOnly);

		// If we are not doing a reload of the same file then...
		if(GetFileName().IsEmpty() || 0 != GetFileName().Compare(pszFilename))
		{
			SetFileName(pszFilename);
			// Fire the LoadFile event
			FileLoadAdvise();
		}

		}VSL_STDMETHODCATCH()

		return VSL_GET_STDMETHOD_HRESULT();
	}

	STDMETHOD(Save)(LPCOLESTR pszFilename, BOOL fRemember, DWORD nFormatIndex)
	{
		VSL_STDMETHODTRY{

		Derived& rDerived = *(static_cast<Derived*>(this));

		VSL_CHECKBOOLEAN(rDerived.IsValidFormat(nFormatIndex), E_INVALIDARG);

		LPCWSTR szSaveFileName = pszFilename;
		bool bDoingSave = false;

		if(NULL == szSaveFileName)
		{
			// If pszFilename is NULL, then a Save is being asked for, so the filename 
			// must be set already and the incoming value of fRemember is ignored in this case
			VSL_CHECKBOOLEAN(!GetFileName().IsEmpty(), E_INVALIDARG);

			VSL_CHECKBOOLEAN(IsFileEditable(), E_UNEXPECTED);

			szSaveFileName = m_File;
			fRemember = TRUE;
			bDoingSave = true;
		}
		else
		{
			// If pszFilename is not NULL,
			// and if fRemember is TRUE, and the file name is different then a Save As is being asked for
			// but if fRemebber is TRUE, and the file name is the same then a Save is being asked for
			// or if fRemember is FALSE, then a Save Copy As is being asked for
			// so pszFilename must be valid
			if(0 != GetFileName().CompareNoCase(szSaveFileName))
			{
				VSL_CHECKBOOLEAN(CheckFileName(pszFilename), E_INVALIDARG);
			}
			else
			{
				bDoingSave = true;
			}
		}

		if(bDoingSave)
		{
			// Suspend file change notifications on a Save, so the writing of the file during the save
			// doesn't trigger a notification.
			// For a SaveAs the previous file will be unadvised when the name changes, 
			// and SaveCopyAs doesn't affect internal state.
			SuspendFileChangeAdvise(true);
		}

		// do the actual save
		HRESULT hr = WriteToFile(szSaveFileName, nFormatIndex);

		// Resume file change notifications, before checking for an error
		if(bDoingSave)
		{
			SuspendFileChangeAdvise(false);
		}

		VSL_CHECKHRESULT(hr);

		if(fRemember)
		{
			// Save or SaveAs  
			if(!bDoingSave)
			{
				// SaveAs
				SetFileName(szSaveFileName);
			}

			SetDirty(false);
			SetReadOnly(false);
			m_dwFormatIndex = nFormatIndex;

			// Since all changes are now saved properly to disk, there's no need for a backup.
			m_bBackupObsolete = false;
		}

		}VSL_STDMETHODCATCH()

		return VSL_GET_STDMETHOD_HRESULT();
	}

	// REVIEW - is it correct to be doing nothing here?
	STDMETHOD(SaveCompleted)(LPCOLESTR /*pszFilename*/)
	{
		return S_OK;
	}

	STDMETHOD(GetCurFile)(_Deref_out_z_ LPOLESTR* ppszFilename, _Out_ DWORD* pnFormatIndex)
	{
		VSL_STDMETHODTRY{

		VSL_CHECKPOINTER(ppszFilename, E_INVALIDARG);
		VSL_CHECKPOINTER(pnFormatIndex, E_INVALIDARG);

		*ppszFilename = NULL;
		*pnFormatIndex = m_dwFormatIndex;

		if(!GetFileName().IsEmpty())
		{
			// +1 for null terminator, which isn't included in GetLength()
			const SIZE_T iBufferByteSize = (GetFileName().GetLength() + 1) * sizeof(**ppszFilename);
			CoTaskMemPointer pBuffer = ::CoTaskMemAlloc(iBufferByteSize);
			VSL_CHECKPOINTER(static_cast<LPVOID>(pBuffer), E_OUTOFMEMORY);

			VSL_CHECKBOOLEAN(0 == ::memcpy_s(pBuffer, iBufferByteSize, GetFileName(), iBufferByteSize), E_FAIL);
			*ppszFilename = static_cast<LPOLESTR>(pBuffer.Detach());
		}

		}VSL_STDMETHODCATCH()

		return VSL_GET_STDMETHOD_HRESULT();
	}

	STDMETHOD(GetFormatList)(_Deref_out_z_ LPOLESTR* ppszFormatList)
	{
		VSL_STDMETHODTRY{

		VSL_CHECKPOINTER(ppszFormatList, E_INVALIDARG);

		*ppszFormatList = NULL;

		Derived& rDerived = *(static_cast<Derived*>(this));

		ATL::CStringW strFormatList;
		rDerived.GetFormatListString(strFormatList);

		// +1 for null terminator, which isn't included in GetLength()
		const SIZE_T iBufferByteSize = (strFormatList.GetLength() + 1) * sizeof(OLECHAR);
		CoTaskMemPointer pBuffer = ::CoTaskMemAlloc(iBufferByteSize);
		VSL_CHECKPOINTER(static_cast<LPVOID>(pBuffer), E_OUTOFMEMORY);

		VSL_CHECKBOOLEAN(0 == ::memcpy_s(pBuffer, iBufferByteSize, strFormatList, iBufferByteSize), E_FAIL);
		*ppszFormatList = static_cast<LPOLESTR>(pBuffer.Detach());

		}VSL_STDMETHODCATCH()

		return VSL_GET_STDMETHOD_HRESULT();
	}

/***************************************************************************
IPersist methods
***************************************************************************/

	STDMETHOD(GetClassID)(_Out_ CLSID* pClassID)
	{
		VSL_STDMETHODTRY{

		VSL_CHECKPOINTER(pClassID, E_INVALIDARG);

		Derived& rDerived = *(static_cast<Derived*>(this));

		*pClassID = rDerived.GetEditorTypeGuid();

		}VSL_STDMETHODCATCH()

		return VSL_GET_STDMETHOD_HRESULT();
	}                    

/***************************************************************************
IVsPersistDocData methods
***************************************************************************/

	STDMETHOD(GetGuidEditorType)(_Out_ CLSID* pClassID)
	{
		// Delegate to IPersist::GetClassID
		return GetClassID(pClassID);
	}                    

	STDMETHOD(IsDocDataDirty)(_Out_ BOOL* pfDirty)
	{
		// Delegate to IPersistFileFormat::IsDirty
		return IsDirty(pfDirty);
	}

	// SetUntitledDocPath is called by projects after a new document instance is created.
	// Parameter is a legacy artificat.
	STDMETHOD(SetUntitledDocPath)(LPCOLESTR /*pszDocDataPath*/)
	{
		// Delegate to IPersistFileFormat::InitNew
		return InitNew(DEF_FORMAT_INDEX);
	}

	STDMETHOD(LoadDocData)(LPCOLESTR pszMkDocument)
	{
		// Delegate to IPersistFileFormat::Load
		return Load(pszMkDocument, 0, FALSE);
	}

	STDMETHOD(SaveDocData)(VSSAVEFLAGS dwSave, _Deref_out_z_ BSTR* pbstrMkDocumentNew, _Out_ BOOL* pfSaveCanceled)
	{
		VSL_STDMETHODTRY{

		VSL_CHECKPOINTER(pfSaveCanceled, E_INVALIDARG);
		VSL_CHECKPOINTER(pbstrMkDocumentNew, E_INVALIDARG);

		VSL_CHECKBOOLEAN(!GetFileName().IsEmpty(), E_UNEXPECTED);

		// Initialise output parameter flag.
		*pbstrMkDocumentNew = NULL;
		*pfSaveCanceled = FALSE;

		switch(dwSave)
		{
		case VSSAVE_Save:
			{
				CComPtr<IVsQueryEditQuerySave2> spIVsQueryEditQuerySave2;
				VSL_CHECKHRESULT((
					GetDerivedVsSiteChache().QueryCachedService<
						IVsQueryEditQuerySave2, 
						SID_SVsQueryEditQuerySave>(
							&spIVsQueryEditQuerySave2)));

				VSQuerySaveResult result;
				VSL_CHECKHRESULT(spIVsQueryEditQuerySave2->QuerySaveFile(
					GetFileName(),
					0,
					NULL,
					&result));

				switch(result)
				{
				case QSR_NoSave_UserCanceled:
					*pfSaveCanceled = TRUE;
					return S_OK;
				case QSR_NoSave_Continue:
					// Do nothing
					return S_OK;
				case QSR_ForceSaveAs:
					// override
					dwSave = VSSAVE_SaveAs;
					break;
				case QSR_SaveOK:
					// Normal file save with no user dialog
					break;
				default:
					return E_FAIL;
				}
			}
			break;
		case VSSAVE_SaveAs:
			break;
		case VSSAVE_SaveCopyAs:
			break;
		default:
			return E_INVALIDARG;
		}

		CComPtr<IVsUIShell> spIVsUIShell = GetDerivedVsSiteChache().GetCachedService<
			IVsUIShell, 
			SID_SVsUIShell>();
		VSL_CHECKPOINTER(spIVsUIShell.p, E_FAIL);

		VSL_CHECKHRESULT(spIVsUIShell->SaveDocDataToFile(
			dwSave, 
			static_cast<IPersistFileFormat*>(this),
			GetFileName(),
			pbstrMkDocumentNew,
			pfSaveCanceled));

		}VSL_STDMETHODCATCH()

		return VSL_GET_STDMETHOD_HRESULT();
	}

	STDMETHOD(Close)()
	{
		// When closing, the document's IVsWindowPane::ClosePane() method is called after 
		// IVsPersistDocData::Close.  We don't clean-up here, but rather let 
		// the IVsWindowPane::ClosePane() method call OnDocumentClose
		return S_OK;
	}

	STDMETHOD(OnRegisterDocData)(VSCOOKIE /*docCookie*/, _In_ IVsHierarchy* /*pHierNew*/, VSITEMID /*itemidNew*/)
	{
		// REVIEW - return E_NOTIMPL instead
		return S_OK;
	}

	STDMETHOD(RenameDocData)( 
		VSRDTATTRIB /*grfAttribs*/,
		_In_ IVsHierarchy* /*pHierNew*/,
		VSITEMID /*itemidNew*/,
		LPCOLESTR /*pszMkDocumentNew*/)
	{
		// REVIEW - return E_NOTIMPL instead or implement it?
		return S_OK;
	}

	STDMETHOD(IsDocDataReloadable)(_Out_ BOOL* pfReloadable)
	{
		VSL_RETURN_E_INVALIDARG_IF_NULL(pfReloadable);
		
		*pfReloadable = TRUE;

		return S_OK;
	}

	STDMETHOD(ReloadDocData)(VSRELOADDOCDATA grfFlags)
	{
		VSL_STDMETHODTRY{

		// because we implement IVsDocDataFileChangeControl, then RDD_IgnoreNextFileChange
		// flag should never be specified. the caller must use 
		// IVsDocDataFileChangeControl::IgnoreFileChanges instead.
		VSL_CHECKBOOLEAN(!(grfFlags & RDD_IgnoreNextFileChange), E_INVALIDARG);

		// set our file reload flag
		m_bFileReloaded = true;

		// Call IPersistFileFormat::Load 
		VSL_CHECKHRESULT(Load(GetFileName(), 0, FALSE));

		// REVIEW - call derived if RDD_RemoveUndoStack set?

		}VSL_STDMETHODCATCH()

		return VSL_GET_STDMETHOD_HRESULT();
	}

/***************************************************************************
IVsFileBackup methods
***************************************************************************/

	STDMETHOD(BackupFile)(LPCOLESTR pszBackupFileName)
	{
		VSL_STDMETHODTRY{

		VSL_CHECKBOOLEAN(CheckFileName(pszBackupFileName), E_INVALIDARG);

		VSL_CHECKHRESULT(WriteToFile(pszBackupFileName));

		// Note that the backup is not obsolete (i.e. current)
		m_bBackupObsolete = false;

		}VSL_STDMETHODCATCH()

		return VSL_GET_STDMETHOD_HRESULT();
	}

	STDMETHOD(IsBackupFileObsolete)(_Out_ BOOL* pbObsolete)
	{
		VSL_STDMETHODTRY{

		VSL_CHECKPOINTER(pbObsolete, E_INVALIDARG);

		if(IsFileDirty())
		{
			// If dirty, then return current need for a backup
			*pbObsolete = m_bBackupObsolete;
		}
		else
		{
			// If not dirty, then no need for a backup
			*pbObsolete = FALSE;
		}

		}VSL_STDMETHODCATCH()

		return VSL_GET_STDMETHOD_HRESULT();
	}

protected:

/***************************************************************************
Methods the derived class is required to call
***************************************************************************/

	DocumentPersistanceBase():
		m_File(),
		m_spIVsFileChangeEx(0),
		m_FileChangeConnectionCookie(0),
		m_iIgnoreFileChangeLevel(0),
		m_dwFormatIndex(DEF_FORMAT_INDEX),
		m_bFileChangedTimerSet(false),
		m_bFileReloaded(false),
		m_bBackupObsolete(false),
		m_bFileDirty(false),
		m_bFileReadOnly(false),
		m_bFileEditableWhenReadOnly(false)
	{
	}

	virtual ~DocumentPersistanceBase() = 0
	{
	}

	// The derived class should call this method as part of it's closing activity
	void OnDocumentClose()
	{
		if(m_spIVsFileChangeEx)
		{
			if(VSCOOKIE_NIL != m_FileChangeConnectionCookie)
			{
				Unadvise();
			}
			m_spIVsFileChangeEx.Release();
		}
	}

	// The derived class should call this method upon recieving the WM_TIMER 
	// messeage sent from OnFileChangedSetTimer
	void NotifyFileChangedTimerHandled()
	{
		m_bFileChangedTimerSet = false;
	}

/***************************************************************************
Helper methods available to the derived class
***************************************************************************/

	bool IsFileDirty()
	{
		return m_bFileDirty;
	}

	void SetFileDirty(bool bSet)
	{ 
		// Every time the document has changed in any way the previous backup is obsolete.
		m_bBackupObsolete = true;
		m_bFileDirty = bSet;
	}

	bool IsFileEditableWhenReadOnly()
	{
		return m_bFileEditableWhenReadOnly;
	}

	void SetFileEditableWhenReadOnly(bool bSet)
	{ 
		// Every time the document has changed in any way the previous backup is obsolete.
		m_bBackupObsolete = true;
		m_bFileEditableWhenReadOnly = bSet;
	}

	bool IsFileReloaded()
	{
		return m_bFileReloaded;
	}

	void SetFileReloaded(bool bFileReloaded)
	{
		m_bFileReloaded = bFileReloaded;
	}

	bool IsFileReadOnly()
	{
		return m_bFileReadOnly;
	}

	bool IsFileEditable()
	{
		return !IsFileReadOnly() || IsFileEditableWhenReadOnly();
	}

	void ResetFileState()
	{
		m_bFileDirty = false;
		m_bFileReadOnly = false;
		m_bFileEditableWhenReadOnly = false;
	}

	const CStringW& GetFileName()
	{
		return m_File.GetFullPathName();
	}

	void SetFileName(LPCWSTR szFileName)
	{
		if(VSCOOKIE_NIL != m_FileChangeConnectionCookie)
		{
			EnsureVsFileChangeEx();
			Unadvise();
		}

		if(szFileName != NULL)
		{
			EnsureVsFileChangeEx();
			VSL_CHECKHRESULT(m_spIVsFileChangeEx->AdviseFileChange(
				szFileName,
				VSFILECHG_Attr | VSFILECHG_Time | VSFILECHG_Size, 
				static_cast<IVsFileChangeEvents*>(this),
				&m_FileChangeConnectionCookie));

			VSL_CHECKBOOLEAN(m_FileChangeConnectionCookie != VSCOOKIE_NIL, E_FAIL);
		}

		m_File.GetFullPathName() = szFileName;
	}

	File& GetFile()
	{
		return m_File;
	}

/***************************************************************************
Internal helper methods
***************************************************************************/

private:

	void Initialize()
	{
		// REVIEW - 1/30/2006 - what else needs to be done to return us to a clean initial state?
		ResetFileState();
		SetFileName(NULL);
	}

	void SuspendFileChangeAdvise(bool bSuspend)
	{
		EnsureVsFileChangeEx();

		if(!bSuspend)
		{
			// Transitioning from suspended to non-suspended state - so force a
			// sync first to avoid asynchronous notifications of our own change
			VSL_CHECKHRESULT(m_spIVsFileChangeEx->SyncFile(GetFileName()));
		}

		// Suspend (true) or unsupsend (false) as indicated by caller
		VSL_CHECKHRESULT(m_spIVsFileChangeEx->IgnoreFile(NULL, GetFileName(), bSuspend));
	}

	void FileLoadAdvise()
	{
		ATL::CComPtr<IVsRunningDocumentTable> spIVsRunningDocumentTable;
		VSL_CHECKHRESULT(GetDerivedVsSiteChache().QueryService(SID_SVsRunningDocumentTable, &spIVsRunningDocumentTable));

		VSDOCCOOKIE docCookie;
		VSL_CHECKHRESULT(spIVsRunningDocumentTable->FindAndLockDocument(
			RDT_ReadLock,
			GetFileName(),
			NULL,
			NULL,
			0,
			&docCookie));

		HRESULT hr = spIVsRunningDocumentTable->NotifyDocumentChanged(docCookie, RDTA_DocDataReloaded);

		// Here we don't check for success because, even if the previous operation
		// fails, we have to unlock the document.

		VSL_CHECKHRESULT(spIVsRunningDocumentTable->UnlockDocument(RDT_ReadLock, docCookie));

		// Now check the result
		VSL_CHECKHRESULT(hr);
	}

	HRESULT WriteToFile(LPCWSTR pszFilename, DWORD dwFormatIndex = DEF_FORMAT_INDEX) throw()
	{
		VSL_STDMETHODTRY{

		File file(pszFilename);

		// Open the file for writing
		file.Create(
			GENERIC_WRITE,
			FILE_SHARE_READ,
			CREATE_ALWAYS,
			FILE_FLAG_SEQUENTIAL_SCAN);

		Derived& rDerived = *(static_cast<Derived*>(this));

		// WriteData should not modify any internal state, since WriteToFile is called to 
		// backup a file as well as to save it.
		rDerived.WriteData(file, dwFormatIndex);

		}VSL_STDMETHODCATCH()

		return VSL_GET_STDMETHOD_HRESULT();
	}

	void SetDirty(bool bDirty)
	{
		SetFileDirty(bDirty);

		Derived& rDerived = *(static_cast<Derived*>(this));
		rDerived.PostSetDirty();
	}

	void SetReadOnly(bool bReadOnly)
	{
		m_bFileReadOnly = bReadOnly;

		// When the read only status is changed, reset allowing it to be editable when read only
		SetFileEditableWhenReadOnly(false);

		Derived& rDerived = *(static_cast<Derived*>(this));
		rDerived.PostSetReadOnly();
	}

	bool CheckFileName(const wchar_t* const szFileName)
	{
		if(szFileName == NULL || *szFileName == L'\0' || ::wcslen(szFileName) >= _MAX_PATH)
		{
			return false;
		}

		return true;
	}

	// Caller needs to ensure that m_FileChangeConnectionCookie is valid
	void Unadvise()
	{
		HRESULT hr = m_spIVsFileChangeEx->UnadviseFileChange(m_FileChangeConnectionCookie);
		// This shouldn't fail, but no retail failure if it does, as there is nothing to be done about it
		VSL_ASSERT(SUCCEDDED(hr));
		(hr);
		m_FileChangeConnectionCookie = VSCOOKIE_NIL;
	}

	void EnsureVsFileChangeEx()
	{
		if(m_spIVsFileChangeEx != NULL)
		{
			return;
		}

		VSL_CHECKHRESULT(GetDerivedVsSiteChache().QueryService(SID_SVsFileChangeEx, &m_spIVsFileChangeEx));
		VSL_CHECKPOINTER(m_spIVsFileChangeEx.p, E_FAIL);
	}

	const VsSiteCache& GetDerivedVsSiteChache()
	{
		Derived& rDerived = *(static_cast<Derived*>(this));
		return rDerived.GetVsSiteCache();
	}

	File m_File;
	CComPtr<IVsFileChangeEx> m_spIVsFileChangeEx;
	VSCOOKIE m_FileChangeConnectionCookie;
	unsigned int m_iIgnoreFileChangeLevel;
	DWORD m_dwFormatIndex;
	bool m_bFileChangedTimerSet;
	bool m_bFileReloaded;
	bool m_bBackupObsolete;
	bool m_bFileDirty;
	bool m_bFileReadOnly;
	bool m_bFileEditableWhenReadOnly;

};

} // namespace VSL

#endif // VSLFILE_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\Include\VSLHierarchyNode.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef VSLHIERARCHYNODE_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define VSLHIERARCHYNODE_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

// VSL includes
#include <VSL.h>
#include <VSLErrorHandlers.h>
#include <VSLExceptionHandlers.h>

// STL includes
#ifndef VSL_HIERARCHYNODE_DECENDANT_CONTAINER
#include <list>
#define VSL_HIERARCHYNODE_DECENDANT_CONTAINER std::list
#endif

namespace VSL
{

class HierarchyNodeTraitHeapNodes
{
	enum {
		NodesOnHeap
	};
};

class HierarchyNodeTraitStackNodes
{
	enum {
		NodesOnStack
	};
};

// If ItemContainer_T is specified then it must be of type that has contructor acceptiong an Item_T&
// Additionally ItemContainer_T address of operator must return an ItemContainer_T* not an Item_T*
template <
	class Item_T,
	class ItemContainer_T = Item_T,
	class HeapNodes_T = HierarchyNodeTraitHeapNodes>
class HierarchyNodeTraits
{
public:
	typedef Item_T Item;
	typedef ItemContainer_T ItemContainer;
	typedef HeapNodes_T HeapNodes;
};

template <class Traits_T>
class HierarchyNode
{

VSL_DECLARE_NOT_COPYABLE_OR_DEFAULT_CONSTRUCTABLE(HierarchyNode)

public:

	typedef typename Traits_T::Item Item;
	typedef typename Traits_T::ItemContainer ItemContainer;
	typedef VSL_HIERARCHYNODE_DECENDANT_CONTAINER<HierarchyNode*> DescendantContainer;
	typedef typename DescendantContainer::iterator iterator;

	HierarchyNode(const Item& rItem):
		m_pParent(NULL),
		m_Item(rItem)
	{
	}

__if_exists(Traits_T::HeapNodes::NodesOnHeap)
{
private:
}

	HierarchyNode(_In_opt_ HierarchyNode* pParent, _In_ const Item& rItem):
		m_pParent(pParent),
		m_Item(rItem)
	{
		DescendFromParent();
	}

public:

	~HierarchyNode()
	{
	__if_exists(Traits_T::HeapNodes::NodesOnHeap)
	{
		for(iterator i = m_DescendantContainer.begin(); i != m_DescendantContainer.end(); ++i)
		{
			delete *i;
		}
	}
	}

	HierarchyNode* GetParent()
	{
		return m_pParent;
	}

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512)  // assignment operator could not be generated
	struct FindInfo
	{
		const Item& rItemKey;
		DescendantContainer* pContainer;
		iterator rFound;
	};
#pragma warning(pop)

	/*
	If the item matching rFindInfo.rItemKey is the current node, then the method returns true and
	rFindInfo.pContainer will be NULL and rFound will have been assigned to.  The item can be retrieved
	via by dereferencing the node FindIterator was called on.
	
	If the item is found on a descendant, then the method returns true and rFindInfo.pContainer 
	will be set to point to the container the item's node is contained in, rFound will be set to a 
	valid iterator pointing to the item in the container.

	If no item is found the method returns false.
	*/
	bool FindIterator(_Inout_ FindInfo& rFindInfo)
	{
		if(rFindInfo.rItemKey == m_Item)
		{
			rFindInfo.pContainer = NULL;
			return true;
		}

		for(iterator i = m_DescendantContainer.begin(); i != m_DescendantContainer.end(); ++i)
		{
			if(rFindInfo.rItemKey == ***i)
			{
				rFindInfo.pContainer = &m_DescendantContainer;
				rFindInfo.rFound = i;
				return true;
			}

			if((*i)->FindIterator(rFindInfo))
			{
				return true;
			}
		}

		return false;
	}

	/*
	Returns a pointer to the item corresponding to rItemKey if found.

	Returns NULL if the item corresponding to rItemKey is not found.
	*/
	ItemContainer* FindItemContainer(const Item& rItemKey)
	{
		if(m_Item == rItemKey)
		{
			return &m_Item;
		}
		FindInfo findInfo = { rItemKey };
		if(FindIterator(findInfo) && NULL != findInfo.pContainer)
		{
			return &((*findInfo.rFound)->m_Item);
		}
		return NULL;
	}

	DescendantContainer& GetDescendantContainer()
	{
		return m_DescendantContainer;
	}

	bool HasDescendants()
	{
		return !m_DescendantContainer.empty();
	}

	Item operator*()
	{
		return m_Item;
	}

__if_exists(Traits_T::HeapNodes::NodesOnHeap)
{
	HierarchyNode* AddDescendant(const Item& rItem)
	{
		return new HierarchyNode(this, rItem);
	}

}

	void RemoveDescendant(HierarchyNode* pNode)
	{
		m_DescendantContainer.remove(pNode);
	}

private:

	void DescendFromParent()
	{
		if(NULL != m_pParent)
		{
			m_pParent->m_DescendantContainer.push_back(this);
		}
	}

	HierarchyNode* m_pParent;

	ItemContainer m_Item;

	DescendantContainer m_DescendantContainer;
};

} // namespace VSL

#endif // VSLHIERARCHYNODE_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\Include\VSLFont.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef VSLFONT_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define VSLFONT_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

// VSL includes
#include <VSLCommon.h>

namespace VSL
{

// TODO - 3/8/2006 - this should go elsewhere, but don't want to take a dependency on VSLWindows.h
// here.
class DeviceContextResourceTraits
{
public:
	typedef std::pair<HDC, HWND> ResourceType;
	typedef HDC CastType;
	typedef DeviceContextResourceTraits Allocator;
	typedef DeviceContextResourceTraits Values;
	typedef DeviceContextResourceTraits Cloner;
	static std::pair<HDC, HWND> GetNullValue()
	{
		return std::pair<HDC, HWND>(static_cast<HDC>(NULL), static_cast<HWND>(NULL));
	}
	static void Free(std::pair<HDC, HWND>& pair)
	{
		::ReleaseDC(pair.second, pair.first);
	}
	static HDC CastToResource(const std::pair<HDC, HWND>& pair)
	{
		return pair.first;
	}
};

class DeviceContext
{
private:

VSL_DECLARE_NOT_COPYABLE(DeviceContext);

	// FUTURE - default construction could be supported
	DeviceContext();

	typedef Resource<DeviceContextResourceTraits> HandlePair;

public:
	DeviceContext(_In_ HWND hWindow):
		m_HandlePair(HandlePair::ResourceType(reinterpret_cast<HDC>(VSL_CHECKHANDLE_GLE(::GetDC(hWindow))), hWindow))
	{
	}

	// The compiler generated destructor is fine

	template<class LPARAM_T>
	void EnumFontFamiliesExW(_In_ LPLOGFONTW lpLogfont, _In_ FONTENUMPROCW lpProc, _In_ LPARAM_T& lParam, _In_ DWORD dwFlags = 0)
	{
		// Return value will be that provided by the last call to lpProc and 0 indicates an 
		// unspecified error
		VSL_CHECKBOOLEAN((0 != ::EnumFontFamiliesEx(
			m_HandlePair, 
			lpLogfont, 
			lpProc, 
			reinterpret_cast<LPARAM>(&lParam), 
			dwFlags)), E_FAIL);
	}

	// FUTURE - 3/8/2006 - can add additional wrapper methods

private:
	HandlePair m_HandlePair;
};

class VsFontCommandHandling
{

VSL_DECLARE_NONINSTANTIABLE_CLASS(VsFontCommandHandling)

public:
	template <class FontContainer_T>
	static void FontContainerToVariant(const FontContainer_T& rFontContainer, _Out_ VARIANT *pvarOut)
	{
		VSL_CHECKPOINTER(pvarOut, E_INVALIDARG);

		// Clear the out the value here in case of failure
		::VariantClear(pvarOut);

		VSL_CHECKBOOLEAN(rFontContainer.size() > 0, E_FAIL);

		ATL::CComSafeArray<BSTR> fontArray(static_cast<ULONG>(rFontContainer.size()));

		int iIndex = 0;
		for(FontContainer_T::const_iterator i = rFontContainer.begin(); 
			i != rFontContainer.end(); 
			++i, ++iIndex)
		{
			// Deep copies the value by default
			fontArray.SetAt(iIndex, *i);
		}

		V_ARRAY(pvarOut) = fontArray.Detach();
		V_VT(pvarOut) = VT_ARRAY | VT_BSTR;
	}

	// FontNameContainer_T needs to be a container of BSTR's
	template <class FontNameContainer_T>
	class FontNameContainerElementDeallocator
	{

	VSL_DECLARE_NOT_COPYABLE(FontNameContainerElementDeallocator)

	public:
		typedef FontNameContainer_T FontNameContainer;

		FontNameContainerElementDeallocator()
		{
		}

		~FontNameContainerElementDeallocator()
		{
			// Free all of the BSTR's
			for(FontNameContainer_T::const_iterator i = m_Container.begin(); 
				i != m_Container.end(); 
				++i)
			{
				::SysFreeString(*i);
			}
			// The element values now all point to bogus memory, but that's
			// okay as the container will be destructed right after this.
		}

		FontNameContainer_T& GetContainer()
		{
			return m_Container;
		}

	private:
		FontNameContainer_T m_Container;
	};

	// This takes a FontNameContainerElementDeallocator rather then a FontNameContainer
	// to ensure the the font names, which are BSTR's, will get freed.
	template <class FontNameContainerElementDeallocator_T>
	static void PopulateFontNameContainerElementDeallocator(FontNameContainerElementDeallocator_T& rFontNameDeallocator, bool bIgnoreNonTrueTypeFonts = true)
	{
		// The desktop window will supply all of the system fonts
		DeviceContext dc(::GetDesktopWindow());

		EnumFontNamesCallBackLPARAM<FontNameContainerElementDeallocator_T::FontNameContainer> lParam =
		{
			rFontNameDeallocator.GetContainer(),
			bIgnoreNonTrueTypeFonts
		};

		dc.EnumFontFamiliesExW(
			NULL, 
			reinterpret_cast<FONTENUMPROCW>(&EnumFontNamesCallBack<FontNameContainerElementDeallocator_T::FontNameContainer>),
			lParam);

		// FUTURE - could call std::sort algorithm if container doesn't have a sort method
		rFontNameDeallocator.GetContainer().sort(IsStringLessThen);
	}

private:

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
	template <class FontNameContainer_T>
	struct EnumFontNamesCallBackLPARAM
	{
		FontNameContainer_T& rFontNameContainer;
		bool bIgnoreNonTrueTypeFonts;
	};
#pragma warning(pop)

	// This static function is called by Windows in the course of processing
	// the ::EnumFontFamiliesEx call in PopulateFontNameContainerElementDeallocator.
	// Windows calls the method once for each font/character set pair, but the 
	// character set is ignored as the user isn't not given an option to select the 
	// chracter set, only the font name.
	template <class FontNameContainer_T>
	static int CALLBACK EnumFontNamesCallBack(
		_In_ ENUMLOGFONTEX* pEnumLogFont,
		_In_ NEWTEXTMETRICEX* /*pTextMetric*/, 
		DWORD dwFontType, 
		_In_ LPARAM lParam)
	{
		VSL_STDMETHODTRY{
			
		CHKPTR(pEnumLogFont, E_FAIL);
		CHKPTR(lParam, E_FAIL);
		CHKPTR(pEnumLogFont, E_FAIL);
		// lfFaceName is an array, don't need to check it against NULL
		CHK(pEnumLogFont->elfLogFont.lfFaceName[0] != L'\0', E_FAIL);

		// Get the data that was passed into EnumFontFamiliesEx.
		EnumFontNamesCallBackLPARAM<FontNameContainer_T>* p = reinterpret_cast<EnumFontNamesCallBackLPARAM<FontNameContainer_T>*>(lParam);

		// Non TrueType fonts have scaling issues, so ignore those
		if(p->bIgnoreNonTrueTypeFonts && !(TRUETYPE_FONTTYPE & dwFontType))
		{
			return TRUE;
		}

		FontNameContainer_T& rFontNameContainer = p->rFontNameContainer;

		if(rFontNameContainer.size() == 0 || 0 != ::wcscmp(rFontNameContainer.back(), pEnumLogFont->elfLogFont.lfFaceName))
		{
			// Add the font name to the end of the list if it isn't there already
			rFontNameContainer.push_back(CHKPTR(::SysAllocString(pEnumLogFont->elfLogFont.lfFaceName), E_OUTOFMEMORY));
		}

		}VSL_STDMETHODCATCH()

		// 0 stops enumeration, anything else continues it
		return SUCCEEDED(VSL_GET_STDMETHOD_HRESULT()) ? 1 : 0;
	}

};

} // namespace VSL

#endif // VSLFONT_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\Include\VSLMockVisualStudioInterfaces.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef VSLMOCKVISUALSTUDIOINTERFACE_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define VSLMOCKVISUALSTUDIOINTERFACE_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include <VSL.h>
#include <VsShellInterfaces.h>
#include <VSLMockIVsShell.h>
#include <VSLMockIVsUIShell.h>
#include <VSLMockIEnumWindowFrames.h>
#include <VSLMockIVsOutputWindowPane.h>
#include <VSLMockIVsWindowFrame.h>
#include <VSLMockIVsWindowFrame2.h>
#include <VSLMockIVsToolWindowToolbarHost.h>
#include <VSLMockIProfferService.h>
#include <proffserv.h>

namespace VSL
{

inline void PushIVsShellLoadUILibrary(REFCLSID clsid, DWORD_PTR* ppdwModule, HRESULT hrRetrun = S_OK)
{
	VSL_START_VALIDVALUES(IVsShell, LoadUILibrary)
		clsid,
		0,
		ppdwModule,
		hrRetrun
	VSL_END_VALIDVALUES_PUSH();
}

inline void PushIVsWindowFrameGetProperty(VSFPROPID propid, VARIANT* pvar, HRESULT retValue = S_OK)
{
	VSL_PUSH_VALIDVALUES3(IVsWindowFrame, GetProperty, propid, pvar, retValue);
}

} // namespace VSL

#endif VSLMOCKVISUALSTUDIOINTERFACE_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\Include\VSLHierarchy.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef VSLHIERARCHY_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define VSLHIERARCHY_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

// VSL includes
#include <VSLVsSite.h>
#include <VSLHierarchyNode.h>
#include <VSLControls.h>

namespace VSL
{

class IVsHierarchyItem
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsHierarchyItem)

public:
	typedef IVsHierarchyItem ItemInterface;

	virtual const GUID& GetGuidProperty(_In_ VSHPROPID propid) const = 0;

	virtual void SetGuidProperty(_In_ VSHPROPID propid,	_In_ REFGUID rguid) = 0;

	virtual void GetProperty(_In_ VSHPROPID propid, _Out_ VARIANT* pVar) = 0;

	virtual void SetProperty(_In_ VSHPROPID propid, _In_ VARIANT& rVar) = 0;

#ifdef VSL_TEST_HIERARCHY_METHODS_CALLED
	virtual const ATL::CComBSTR& GetCanonicalName() const = 0;

	virtual VSITEMID ParseCanonicalName(_In_ LPCOLESTR pszName) const = 0;
#endif // VSL_TEST_HIERARCHY_METHODS_CALLED

	virtual VSITEMID GetVSITEMID() const = 0;

#ifdef VSL_TEST_HIERARCHY_METHODS_CALLED
	virtual const GUID& GetTypeGuid() const = 0;
#endif // VSL_TEST_HIERARCHY_METHODS_CALLED

	virtual IVsHierarchyEvents* GetIVsHierarchyEvents() = 0;
};

class IVsUIHierarchyItem :
	public IVsHierarchyItem
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsUIHierarchyItem)

public:
	typedef IVsUIHierarchyItem ItemInterface;

	enum
	{
		SupportsUI
	};

	virtual IOleCommandTarget* GetIOleCommandTarget() = 0;

	virtual IDispatch* GetIDispatch() = 0;

#ifdef VSL_TEST_HIERARCHY_METHODS_CALLED
	virtual IVsUserContext* GetIVsUserContext() = 0;
#endif // VSL_TEST_HIERARCHY_METHODS_CALLED

	virtual bool IsVisible() const = 0;

	virtual const GUID& GetCmdUIGuid() const = 0;

	virtual const ATL::CComBSTR& GetCaption() const = 0;

#ifdef VSL_TEST_HIERARCHY_METHODS_CALLED
	virtual const ATL::CComBSTR& GetName() const = 0;

	virtual const ATL::CComBSTR& GetEditLabel() const = 0;
	virtual void SetEditLabel(BSTR rbstrEditLabel) = 0;
#endif // VSL_TEST_HIERARCHY_METHODS_CALLED

	virtual UINT GetIconIndex() const = 0;

	virtual HICON GetIconHandle() const = 0;

	virtual HICON GetOpenFolderIconHandle() const = 0;

	virtual UINT GetOpenFolderIconIndex() const = 0;

	virtual bool IsExpandable() const = 0;

	virtual bool IsExpandedByDefault() const = 0;

	virtual bool IsExpanded() const = 0;

	virtual void SetExpanded(bool bExpanded) = 0;
};

template <class ItemInterface_T = IVsHierarchyItem>
class IVsHierarchyRootItem
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsHierarchyRootItem)

public:
	typedef ItemInterface_T ItemInterface;

	virtual ItemInterface& GetItem(_In_ VSITEMID itemid) = 0;

	virtual const GUID& GetGuidProperty(_In_ VSITEMID itemid, _In_ VSHPROPID propid) const = 0;

	virtual void SetGuidProperty(_In_ VSITEMID itemid, _In_ VSHPROPID propid, _In_ REFGUID rguid) = 0;

	virtual void GetProperty(_In_ VSITEMID itemid, _In_ VSHPROPID propid, _Out_ VARIANT* pVar) const = 0;

	virtual void SetProperty(_In_ VSITEMID itemid, _In_ VSHPROPID propid, _In_ VARIANT& rVar) = 0;
};

template <class Base_T = IVsHierarchyRootItem<IVSUIHierarchyItem> >
class IVsUIHierarchyRootItem :
	public Base_T
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsUIHierarchyRootItem)

public:

	virtual ImageListWin32Control& GetIconImageList() = 0;
};

#pragma warning(push)
#pragma warning(disable : 4355) // 'this' : used in base member initializer list
// Warning disabled as this is safe, as the node just holds the item, but doesn't call into it
// This must be disable at the class scope rather then the at the scope of each constructor

template <
	class Base_T = IVsHierarchyItem,
	class HierarchyNode_T = HierarchyNode<HierarchyNodeTraits<Base_T::ItemInterface*> > >
class VsHierarchyItemBase :
	public Base_T
{
private:

	const VsHierarchyItemBase& operator=(const VsHierarchyItemBase& rToCopy);

public:

	typedef typename HierarchyNode_T HierarchyNode;

protected:

	VsHierarchyItemBase():
		 m_pNode()
	{
		// No default construction allowed, this method should never actually
		// be called, but it needs to be present to compile correctly in some circumstances
		VSL_CREATE_ERROR_HRESULT(E_UNEXPECTED);
	}

	VsHierarchyItemBase(typename HierarchyNode::Item& item):
		 m_pNode(new HierarchyNode(item))
	{
	}

	~VsHierarchyItemBase()
	{
		// Don't delete m_pNode, it's parent node owns it
	}

public:
	explicit VsHierarchyItemBase(VsHierarchyItemBase& rParent):
		m_pNode(rParent.m_pNode->AddDescendant(this))
	{
	}

	// compile generated destructor is fine
	// Except for the root node, all of the nodes are deleted by their parent node
	// The root item is responsible for deleting the root node

	virtual const GUID& GetGuidProperty(_In_ VSHPROPID propid) const
	{
		switch(propid)
		{
		// intentional fall through below
		case VSHPROPID_Parent:
		case VSHPROPID_FirstChild:
		case VSHPROPID_NextSibling:
		case VSHPROPID_Root:
			VSL_CREATE_ERROR_HRESULT(E_UNEXPECTED); // Should be calling GetProperty
			break;
		case VSHPROPID_TypeGuid:
			__if_exists(ItemInterface::GetTypeGuid)
			{
				return GetTypeGuid();
			}
			break;
		case VSHPROPID_SaveName:
		case VSHPROPID_Caption:
		case VSHPROPID_IconImgList:
		case VSHPROPID_IconIndex:
		case VSHPROPID_Expandable:
		case VSHPROPID_ExpandByDefault:
		case VSHPROPID_Name: // == VSHPROPID_ProjectName
		case VSHPROPID_IconHandle:
		case VSHPROPID_OpenFolderIconHandle:
		case VSHPROPID_OpenFolderIconIndex:
			VSL_CREATE_ERROR_HRESULT(E_UNEXPECTED); // Should be calling GetProperty
			break;
		case VSHPROPID_CmdUIGuid:
			__if_exists(ItemInterface::SupportsUI)
			{
				return GetCmdUIGuid();
			}
			break;
		// intentional fall through below
		case VSHPROPID_SelContainer:
		case VSHPROPID_BrowseObject:
		case VSHPROPID_AltHierarchy:
		case VSHPROPID_AltItemid:
		case VSHPROPID_ProjectDir:
		case VSHPROPID_SortPriority:
		case VSHPROPID_UserContext:
		case VSHPROPID_EditLabel:
		case VSHPROPID_ExtObject:
		case VSHPROPID_ExtSelectedItem:
		case VSHPROPID_StateIconIndex:
		case VSHPROPID_TypeName: // == VSHPROPID_ProjectType
		case VSHPROPID_HandlesOwnReload: // == VSHPROPID_ReloadableProjectFile
		case VSHPROPID_ParentHierarchy:
		case VSHPROPID_ParentHierarchyItemid:
		case VSHPROPID_ItemDocCookie:
		case VSHPROPID_Expanded:
		case VSHPROPID_ConfigurationProvider:
		case VSHPROPID_ImplantHierarchy:
		case VSHPROPID_OwnerKey:
		case VSHPROPID_StartupServices:
		case VSHPROPID_FirstVisibleChild:
		case VSHPROPID_NextVisibleSibling:
		case VSHPROPID_IsHiddenItem:
		case VSHPROPID_IsNonMemberItem:
		case VSHPROPID_IsNonLocalStorage:
		case VSHPROPID_StorageType:
		case VSHPROPID_ItemSubType:
		case VSHPROPID_OverlayIconIndex:
		case VSHPROPID_DefaultNamespace:
		case VSHPROPID_IsNonSearchable:
		case VSHPROPID_IsFindInFilesForegroundOnly:
		case VSHPROPID_CanBuildFromMemory:
			VSL_CREATE_ERROR_HRESULT(E_UNEXPECTED); // Should be calling GetProperty
			break;
		case VSHPROPID_PreferredLanguageSID:
			__if_exists(ItemInterface::GetPreferredLanguageSID)
			{
				return GetPreferredLanguageSID();
			}
			break;
		// intentional fall through below
		case VSHPROPID_ShowProjInSolutionPage:
		case VSHPROPID_AllowEditInRunMode:
		case VSHPROPID_IsNewUnsavedItem:
		case VSHPROPID_ShowOnlyItemCaption:
			VSL_CREATE_ERROR_HRESULT(E_UNEXPECTED); // Should be calling GetProperty
			break;
		case VSHPROPID_ProjectIDGuid:
			__if_exists(ItemInterface::GetProjectIDGuid)
			{
				return GetProjectIDGuid();
			}
			break;
		// intentional fall through below
		case VSHPROPID_DesignerVariableNaming:
		case VSHPROPID_DesignerFunctionVisibility:
		case VSHPROPID_HasEnumerationSideEffects:
		case VSHPROPID_DefaultEnableBuildProjectCfg:
		case VSHPROPID_DefaultEnableDeployProjectCfg:
			VSL_CREATE_ERROR_HRESULT(E_UNEXPECTED); // Should be calling GetProperty
			break;
		default:
			VSL_CREATE_ERROR_HRESULT(E_INVALIDARG);
		}

		VSL_CREATE_ERROR_HRESULT(E_NOTIMPL);
		return GUID_NULL;
	}

	virtual void SetGuidProperty(_In_ VSHPROPID propid,	_In_ REFGUID rguid)
	{
		(rguid);
		switch(propid)
		{
		// intentional fall through below
		case VSHPROPID_Parent:
		case VSHPROPID_FirstChild:
		case VSHPROPID_NextSibling:
		case VSHPROPID_Root:
			VSL_CREATE_ERROR_HRESULT(E_UNEXPECTED); // Should be calling GetProperty
			break;
		case VSHPROPID_TypeGuid:
			break; // Property can't be set
		// intentional fall through below
		case VSHPROPID_SaveName:
		case VSHPROPID_Caption:
		case VSHPROPID_IconImgList:
		case VSHPROPID_IconIndex:
		case VSHPROPID_Expandable:
		case VSHPROPID_ExpandByDefault:
		case VSHPROPID_Name: // == VSHPROPID_ProjectName
		case VSHPROPID_IconHandle:
		case VSHPROPID_OpenFolderIconHandle:
		case VSHPROPID_OpenFolderIconIndex:
			VSL_CREATE_ERROR_HRESULT(E_UNEXPECTED); // Should be calling GetProperty
			break;
		case VSHPROPID_CmdUIGuid:
			break; // Property can't be set
		// intentional fall through below
		case VSHPROPID_SelContainer:
		case VSHPROPID_BrowseObject:
		case VSHPROPID_AltHierarchy:
		case VSHPROPID_AltItemid:
		case VSHPROPID_ProjectDir:
		case VSHPROPID_SortPriority:
		case VSHPROPID_UserContext:
		case VSHPROPID_EditLabel:
		case VSHPROPID_ExtObject:
		case VSHPROPID_ExtSelectedItem:
		case VSHPROPID_StateIconIndex:
		case VSHPROPID_TypeName: // == VSHPROPID_ProjectType
		case VSHPROPID_HandlesOwnReload: // == VSHPROPID_ReloadableProjectFile
		case VSHPROPID_ParentHierarchy:
		case VSHPROPID_ParentHierarchyItemid:
		case VSHPROPID_ItemDocCookie:
		case VSHPROPID_Expanded:
		case VSHPROPID_ConfigurationProvider:
		case VSHPROPID_ImplantHierarchy:
		case VSHPROPID_OwnerKey:
		case VSHPROPID_StartupServices:
		case VSHPROPID_FirstVisibleChild:
		case VSHPROPID_NextVisibleSibling:
		case VSHPROPID_IsHiddenItem:
		case VSHPROPID_IsNonMemberItem:
		case VSHPROPID_IsNonLocalStorage:
		case VSHPROPID_StorageType:
		case VSHPROPID_ItemSubType:
		case VSHPROPID_OverlayIconIndex:
		case VSHPROPID_DefaultNamespace:
		case VSHPROPID_IsNonSearchable:
		case VSHPROPID_IsFindInFilesForegroundOnly:
		case VSHPROPID_CanBuildFromMemory:
			VSL_CREATE_ERROR_HRESULT(E_UNEXPECTED); // Should be calling GetProperty
			break;
		case VSHPROPID_PreferredLanguageSID:
			break; // Property can't be set
		// intentional fall through below
		case VSHPROPID_ShowProjInSolutionPage:
		case VSHPROPID_AllowEditInRunMode:
		case VSHPROPID_IsNewUnsavedItem:
		case VSHPROPID_ShowOnlyItemCaption:
			VSL_CREATE_ERROR_HRESULT(E_UNEXPECTED); // Should be calling GetProperty
			break;
		case VSHPROPID_ProjectIDGuid:
			break; // Property can't be set
		// intentional fall through below
		case VSHPROPID_DesignerVariableNaming:
		case VSHPROPID_DesignerFunctionVisibility:
		case VSHPROPID_HasEnumerationSideEffects:
		case VSHPROPID_DefaultEnableBuildProjectCfg:
		case VSHPROPID_DefaultEnableDeployProjectCfg:
			VSL_CREATE_ERROR_HRESULT(E_UNEXPECTED); // Should be calling GetProperty
			break;
		default:
			VSL_CREATE_ERROR_HRESULT(E_INVALIDARG);
		}

		VSL_CREATE_ERROR_HRESULT(E_NOTIMPL);
	}

	virtual void GetProperty(_In_ VSHPROPID propid, _Out_ VARIANT* pVar)
	{
		switch(propid)
		{
		case VSHPROPID_Parent: // intentional fall through
		case VSHPROPID_FirstChild:
			GetRelativesVSITEMID(propid, pVar);
			return;
		case VSHPROPID_NextSibling: // intentional fall through
		case VSHPROPID_Root:
			VSL_ASSERT(false); // Should never get here, root should take care of this
			break;
		case VSHPROPID_TypeGuid:
			break; // Should be calling GetPropertyGuid
		case VSHPROPID_SaveName:
			VSL_CREATE_ERROR_HRESULT(E_NOTIMPL);
			break;
		case VSHPROPID_Caption:
			__if_exists(ItemInterface::SupportsUI)
			{{
				ATL::CComVariant var(GetCaption());
				var.Detach(pVar);
				return;
			}}
			__if_not_exists(ItemInterface::SupportsUI)
			{
				VSL_CREATE_ERROR_HRESULT(E_NOTIMPL);
			}
		case VSHPROPID_IconImgList:
			VSL_ASSERT(false); // Should never get here, root should take care of this
			break;
		case VSHPROPID_IconIndex:
			__if_exists(ItemInterface::SupportsUI)
			{{
				ATL::CComVariant var(static_cast<long>(GetIconIndex()));
				var.Detach(pVar);
				return;
			}}
			// intentional fall through
		case VSHPROPID_Expandable:
			__if_exists(ItemInterface::SupportsUI)
			{{
				ATL::CComVariant var(IsExpandable());
				var.Detach(pVar);
				return;
			}}
			// intentional fall through
		case VSHPROPID_ExpandByDefault:
			__if_exists(ItemInterface::SupportsUI)
			{{
				ATL::CComVariant var(IsExpandedByDefault());
				var.Detach(pVar);
				return;
			}}
			__if_not_exists(ItemInterface::SupportsUI)
			{{
			VSL_CREATE_ERROR_HRESULT(E_NOTIMPL);
			}}
			break;
		case VSHPROPID_Name: // == VSHPROPID_ProjectName
			__if_exists(ItemInterface::GetName)
			{{
				ATL::CComVariant var(GetName());
				var.Detach(pVar);
				return;
			}}
			__if_not_exists(ItemInterface::GetName)
			{
				VSL_CREATE_ERROR_HRESULT(E_NOTIMPL);
			}
			break;
		case VSHPROPID_IconHandle:
			__if_exists(ItemInterface::SupportsUI)
			{{
#pragma warning(push)
#pragma warning(disable : 4311) // 'reinterpret_cast' : pointer truncation from 'HICON' to 'long'
				ATL::CComVariant var(reinterpret_cast<long>(GetIconHandle()));
#pragma warning(pop)
				var.Detach(pVar);
				return;
			}}
			__if_not_exists(ItemInterface::SupportsUI)
			{
				VSL_CREATE_ERROR_HRESULT(E_NOTIMPL);
			}
			break;
		case VSHPROPID_OpenFolderIconHandle:
			__if_exists(ItemInterface::SupportsUI)
			{{
#pragma warning(push)
#pragma warning(disable : 4311) // 'reinterpret_cast' : pointer truncation from 'HICON' to 'long'
				ATL::CComVariant var(reinterpret_cast<long>(GetOpenFolderIconHandle()));
#pragma warning(pop)
				var.Detach(pVar);
				return;
			}}
			__if_not_exists(ItemInterface::SupportsUI)
			{
				VSL_CREATE_ERROR_HRESULT(E_NOTIMPL);
			}
			break;
		case VSHPROPID_OpenFolderIconIndex:
			__if_exists(ItemInterface::SupportsUI)
			{{
				ATL::CComVariant var(static_cast<long>(GetOpenFolderIconIndex()));
				var.Detach(pVar);
				return;
			}}
			__if_not_exists(ItemInterface::SupportsUI)
			{
				VSL_CREATE_ERROR_HRESULT(E_NOTIMPL);
			}
			break;
		case VSHPROPID_CmdUIGuid:
			break; // Should be calling GetPropertyGuid
		case VSHPROPID_SelContainer:
			__if_exists(ItemInterface::GetISelectionContainer)
			{{
				ISelectionContainer* pISelectionContainer = GetISelectionContainer();
				// Visual Studio will try VSHPROPID_BrowseObject instead
				VSL_CHECKPOINTER(pISelectionContainer, E_NOTIMPL);
				ATL::CComVariant var(pISelectionContainer);
				var.Detach(pVar);
				return;
			}}
			__if_not_exists(ItemInterface::GetISelectionContainer)
			{
				VSL_CREATE_ERROR_HRESULT(E_NOTIMPL);
			}
			break;
		case VSHPROPID_BrowseObject:
			__if_exists(ItemInterface::SupportsUI)
			{{
				IDispatch* pIDispatch = GetIDispatch();
#ifdef DEBUG
			__if_not_exists(ItemInterface::GetISelectionContainer)
			{{
				if(pIDispatch == NULL)
				{
					VSL_ASSERTEX(false, L"GetIDispatch is required to return not NULL if GetISelectionContainer is not supported!");
				}
			}}
#endif // DEBUG
				VSL_CHECKPOINTER(pIDispatch, E_NOTIMPL);
				ATL::CComVariant var(pIDispatch);
				var.Detach(pVar);
				return;
			}}
		// intentional fall through here and below
		case VSHPROPID_AltHierarchy:
		case VSHPROPID_AltItemid:
		case VSHPROPID_ProjectDir:
		case VSHPROPID_SortPriority:
			VSL_CREATE_ERROR_HRESULT(E_NOTIMPL);
			break;
		case VSHPROPID_UserContext:
			__if_exists(ItemInterface::GetIVsUserContext)
			{{
				IVsUserContext* pIVsUserContext = GetIVsUserContext();
				VSL_CHECKPOINTER(pIVsUserContext, E_NOTIMPL);
				ATL::CComVariant var(pIVsUserContext);
				var.Detach(pVar);
				return;
			}}
			__if_not_exists(ItemInterface::GetIVsUserContext)
			{
				VSL_CREATE_ERROR_HRESULT(E_NOTIMPL);
			}
			break;
		case VSHPROPID_EditLabel:
			__if_exists(ItemInterface::GetEditLabel)
			{{
				ATL::CComVariant var(GetEditLabel());
				var.Detach(pVar);
				return;
			}}
		// intentional fall through here and below
		case VSHPROPID_ExtObject:
		case VSHPROPID_ExtSelectedItem:
			VSL_CREATE_ERROR_HRESULT(E_NOTIMPL);
			break;
		case VSHPROPID_StateIconIndex:
			__if_exists(ItemInterface::SupportsSourceControl)
			{{
				ATL::CComVariant var(static_cast<long>(GetStateIconIndex()));
				var.Detach(pVar);
				return;
			}}
			__if_not_exists(ItemInterface::SupportsSourceControl)
			{
				VSL_CREATE_ERROR_HRESULT(E_NOTIMPL);
			}
			break;
		// intentional fall through below
		case VSHPROPID_TypeName: // == VSHPROPID_ProjectType
		case VSHPROPID_HandlesOwnReload: // == VSHPROPID_ReloadableProjectFile
		case VSHPROPID_ParentHierarchy: // FUTURE - handle this here or on the root?
		case VSHPROPID_ParentHierarchyItemid: // FUTURE - handle this here or on the root?
		case VSHPROPID_ItemDocCookie:
			VSL_CREATE_ERROR_HRESULT(E_NOTIMPL);
			break;
		case VSHPROPID_Expanded:
			__if_exists(ItemInterface::SupportsUI)
			{{
				ATL::CComVariant var(IsExpanded());
				var.Detach(pVar);
				return;
			}}
			__if_not_exists(ItemInterface::SupportsUI)
			{{
			VSL_CREATE_ERROR_HRESULT(E_NOTIMPL);
			}}
			break;
		case VSHPROPID_ConfigurationProvider:
		case VSHPROPID_ImplantHierarchy:  // FUTURE - handle this here or on the root?
		case VSHPROPID_OwnerKey: // FUTURE - handle this here or on the root?
		case VSHPROPID_StartupServices:
			VSL_CREATE_ERROR_HRESULT(E_NOTIMPL);
			break;
		case VSHPROPID_FirstVisibleChild:
			GetRelativesVSITEMID(propid, pVar);
			return;
		case VSHPROPID_NextVisibleSibling:
			VSL_ASSERT(false); // Should never get here, root should take care of this
			break;
		case VSHPROPID_IsHiddenItem:
			__if_exists(ItemInterface::SupportsUI)
			{{
				ATL::CComVariant var(!IsVisible());
				var.Detach(pVar);
				return;
			}}
		// intentional fall through here and below
		case VSHPROPID_IsNonMemberItem:
		case VSHPROPID_IsNonLocalStorage:
		case VSHPROPID_StorageType:
		case VSHPROPID_ItemSubType:
		case VSHPROPID_OverlayIconIndex:
		case VSHPROPID_DefaultNamespace:
		case VSHPROPID_IsNonSearchable:
		case VSHPROPID_IsFindInFilesForegroundOnly:
		case VSHPROPID_CanBuildFromMemory:
			VSL_CREATE_ERROR_HRESULT(E_NOTIMPL);
			break;
		case VSHPROPID_PreferredLanguageSID:
			break; // Should be calling GetPropertyGuid
		// intentional fall through below
		case VSHPROPID_ShowProjInSolutionPage:
		case VSHPROPID_AllowEditInRunMode:
		case VSHPROPID_IsNewUnsavedItem:
		case VSHPROPID_ShowOnlyItemCaption:
			VSL_CREATE_ERROR_HRESULT(E_NOTIMPL);
			break;
		case VSHPROPID_ProjectIDGuid:
			break; // Should be calling GetPropertyGuid
		// intentional fall through below
		case VSHPROPID_DesignerVariableNaming:
		case VSHPROPID_DesignerFunctionVisibility:
		case VSHPROPID_HasEnumerationSideEffects:
		case VSHPROPID_DefaultEnableBuildProjectCfg:
		case VSHPROPID_DefaultEnableDeployProjectCfg:
	// __VSHPROPID2 - new for Visual Studio 8.0
		case VSHPROPID_PropertyPagesCLSIDList:
		case VSHPROPID_CfgPropertyPagesCLSIDList:
		case VSHPROPID_ExtObjectCATID:
		case VSHPROPID_BrowseObjectCATID:
		case VSHPROPID_CfgBrowseObjectCATID:
		case VSHPROPID_AddItemTemplatesGuid:
		case VSHPROPID_ChildrenEnumerated:
		case VSHPROPID_StatusBarClientText:
		case VSHPROPID_DebuggeeProcessId:
		case VSHPROPID_IsLinkFile:
		case VSHPROPID_KeepAliveDocument:
		case VSHPROPID_SupportsProjectDesigner:
		case VSHPROPID_IntellisenseUnknown:
		case VSHPROPID_IsUpgradeRequired:
		case VSHPROPID_DesignerHiddenCodeGeneration:
		case VSHPROPID_SuppressOutOfDateMessageOnBuild:
		case VSHPROPID_Container:
		case VSHPROPID_UseInnerHierarchyIconList:
		case VSHPROPID_EnableDataSourceWindow:
		case VSHPROPID_AppTitleBarTopHierarchyName:
		case VSHPROPID_DebuggerSourcePaths:
		case VSHPROPID_CategoryGuid:
		case VSHPROPID_DisableApplicationSettings:
		case VSHPROPID_ProjectDesignerEditor:
		case VSHPROPID_PriorityPropertyPagesCLSIDList:
		case VSHPROPID_NoDefaultNestedHierSorting:
		case VSHPROPID_ExcludeFromExportItemTemplate:
		case VSHPROPID_SupportedMyApplicationTypes:
			VSL_CREATE_ERROR_HRESULT(E_NOTIMPL);
			break;
		default:
			VSL_CREATE_ERROR_HRESULT(E_INVALIDARG);
		}

		VSL_CREATE_ERROR_HRESULT(E_UNEXPECTED);
	}

	virtual void SetProperty(_In_ VSHPROPID propid, _In_ VARIANT& rVar)
	{
		(rVar);
		switch(propid)
		{
		// Intentional fall through below
		case VSHPROPID_Parent:
		case VSHPROPID_FirstChild:
		case VSHPROPID_NextSibling:
		case VSHPROPID_Root:
			break; // Property can't be set
		case VSHPROPID_TypeGuid:
			VSL_CREATE_ERROR_HRESULT(E_UNEXPECTED);  // Should be calling SetPropertyGuid
			break;
		// intentional fall through below
		case VSHPROPID_SaveName:
		case VSHPROPID_Caption:
		case VSHPROPID_IconImgList:
		case VSHPROPID_IconIndex:
		case VSHPROPID_Expandable:
		case VSHPROPID_ExpandByDefault:
		case VSHPROPID_Name: // == VSHPROPID_ProjectName
		case VSHPROPID_IconHandle:
		case VSHPROPID_OpenFolderIconHandle:
		case VSHPROPID_OpenFolderIconIndex:
			break; // Property can't be set
		case VSHPROPID_CmdUIGuid:
			VSL_CREATE_ERROR_HRESULT(E_UNEXPECTED);  // Should be calling SetPropertyGuid
			break;
		// intentional fall through below
		case VSHPROPID_SelContainer:
		case VSHPROPID_BrowseObject:
		case VSHPROPID_AltHierarchy:
		case VSHPROPID_AltItemid:
		case VSHPROPID_ProjectDir:
		case VSHPROPID_SortPriority:
		case VSHPROPID_UserContext:
			break; // Property can't be set
		case VSHPROPID_EditLabel:
			__if_exists(ItemInterface::SetEditLabel)
			{
				VSL_CHECKBOOLEAN(rVar.vt == VT_BSTR, DISP_E_BADVARTYPE);
				SetEditLabel(rVar.bstrVal);
				return;
			}
			break;
		// intentional fall through below
		case VSHPROPID_ExtObject:
		case VSHPROPID_ExtSelectedItem:
		case VSHPROPID_StateIconIndex:
		case VSHPROPID_TypeName: // == VSHPROPID_ProjectType
		case VSHPROPID_HandlesOwnReload: // == VSHPROPID_ReloadableProjectFile
		case VSHPROPID_ParentHierarchy: // FUTURE - handle this here or on the root?
		case VSHPROPID_ParentHierarchyItemid: // FUTURE - handle this here or on the root?
		case VSHPROPID_ItemDocCookie:
			break; // Property can't be set
		case VSHPROPID_Expanded:
			__if_exists(ItemInterface::SupportsUI)
			{{
				VSL_CHECKBOOLEAN(rVar.vt == VT_BOOL, DISP_E_BADVARTYPE);
				SetExpanded(rVar.boolVal != VARIANT_FALSE);
				return;
			}}
			// else property can't be set
			break;
		case VSHPROPID_ConfigurationProvider:
		case VSHPROPID_ImplantHierarchy:
		case VSHPROPID_OwnerKey: // FUTURE - handle this here or on the root?
		case VSHPROPID_StartupServices:
		case VSHPROPID_FirstVisibleChild:
		case VSHPROPID_NextVisibleSibling:
		case VSHPROPID_IsHiddenItem:
		case VSHPROPID_IsNonMemberItem:
		case VSHPROPID_IsNonLocalStorage:
		case VSHPROPID_StorageType:
		case VSHPROPID_ItemSubType:
		case VSHPROPID_OverlayIconIndex:
		case VSHPROPID_DefaultNamespace:
		case VSHPROPID_IsNonSearchable:
		case VSHPROPID_IsFindInFilesForegroundOnly:
		case VSHPROPID_CanBuildFromMemory:
			break; // Property can't be set
		case VSHPROPID_PreferredLanguageSID:
			VSL_CREATE_ERROR_HRESULT(E_UNEXPECTED);  // Should be calling SetPropertyGuid
			break;
		// intentional fall through below
		case VSHPROPID_ShowProjInSolutionPage:
		case VSHPROPID_AllowEditInRunMode:
		case VSHPROPID_IsNewUnsavedItem:
		case VSHPROPID_ShowOnlyItemCaption:
			break; // Property can't be set
		case VSHPROPID_ProjectIDGuid:
			VSL_CREATE_ERROR_HRESULT(E_UNEXPECTED);  // Should be calling SetPropertyGuid
			break;
		// intentional fall through below
		case VSHPROPID_DesignerVariableNaming:
		case VSHPROPID_DesignerFunctionVisibility:
		case VSHPROPID_HasEnumerationSideEffects:
		case VSHPROPID_DefaultEnableBuildProjectCfg:
		case VSHPROPID_DefaultEnableDeployProjectCfg:
			break; // Property can't be set
		default:
			VSL_CREATE_ERROR_HRESULT(E_INVALIDARG);
		}

		VSL_CREATE_ERROR_HRESULT(E_NOTIMPL);
	}

	virtual VSITEMID GetVSITEMID() const
	{
		return reinterpret_cast<VSITEMID>(static_cast<HierarchyNode::Item>(const_cast<VsHierarchyItemBase*>(this)));
	}

	virtual IVsHierarchyEvents* GetIVsHierarchyEvents()
	{
		return GetRoot()->GetIVsHierarchyEvents();
	}

protected:

	void FirePropertyChanged(VSHPROPID propid)
	{
		VSL_CHECKHRESULT(GetIVsHierarchyEvents()->OnPropertyChanged(GetVSITEMID(), propid, 0));
	}

	void Delete()
	{
		m_pNode->GetParent()->RemoveDescendant(m_pNode);
		// instance is invalid now
	}

	HierarchyNode* const m_pNode;

private:

	IVsHierarchyItem* GetRoot()
	{
		HierarchyNode* pNodeParent = m_pNode;
		HierarchyNode* pNode = m_pNode;
		while(NULL != (pNode = pNode->GetParent()))
		{
			pNodeParent = pNode;
		}
		return **pNodeParent;
	}

	void GetRelativesVSITEMID(_In_ VSHPROPID propid, _Out_ VARIANT* pVar) const
	{
		VSITEMID requestedId = VSITEMID_NIL;

		switch(propid)
		{
		case VSHPROPID_Parent:
			requestedId = (**(m_pNode->GetParent()))->GetVSITEMID();
			break;
		case VSHPROPID_FirstChild:
			requestedId = (***(GetDescendantContainer().begin()))->GetVSITEMID();
			break;
		case VSHPROPID_FirstVisibleChild:
			{
			__if_exists(ItemInterface::SupportsUI)
			{
				HierarchyNode::DescendantContainer& rContainer = GetDescendantContainer();
				for(HierarchyNode::iterator i = rContainer.begin(); i != rContainer.end(); ++i)
				{
					if((***(i))->IsVisible())
					{
						requestedId = (***(i))->GetVSITEMID();
						break;
					}
				}
			}
			__if_not_exists(ItemInterface::SupportsUI)
			{
				VSL_CREATE_ERROR_HRESULT(E_NOTIMPL);
			}
			}
			break;
		default:
			VSL_ASSERT(false); // PARANOID - should never get here
		}

		ATL::CComVariant var(static_cast<__int32>(requestedId), VT_I4);
		var.Detach(pVar);
	}

	typename HierarchyNode::DescendantContainer& GetDescendantContainer() const
	{
		HierarchyNode::DescendantContainer& rContainer = m_pNode->GetDescendantContainer();
		VSL_CHECKBOOLEAN(!rContainer.empty(), E_INVALIDARG);
		return rContainer;
	}
};
#pragma warning(pop)

template <class Base_T = VsHierarchyItemBase<IVsUIHierarchyItem> >
class VsUIHierarchyItemBase :
	public Base_T
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(VsUIHierarchyItemBase)

protected:

	typedef Base_T BaseClass; // Note using the name Base causes problems with the Base template parameter for CComObject

	VsUIHierarchyItemBase(typename HierarchyNode::Item& item):
		Base_T(item),
		m_bExpanded(false)
	{
	}

public:
	VsUIHierarchyItemBase(Base_T& rParent):
		Base_T(rParent),
		m_bExpanded(false)
	{
	}

#ifdef VSL_TEST_HIERARCHY_METHODS_CALLED
	virtual ISelectionContainer* GetISelectionContainer()
	{
		return NULL;
	}

	virtual IVsUserContext* GetIVsUserContext()
	{
		return NULL;
	}
#endif // VSL_TEST_HIERARCHY_METHODS_CALLED

	virtual bool IsVisible() const
	{
		return true;
	}

	virtual UINT GetIconIndex() const
	{
		// indicates that Visual Studio should ask for the icon handle instead
		VSL_CREATE_ERROR_HRESULT(DISP_E_MEMBERNOTFOUND);
		return 0;
	}

	virtual HICON GetIconHandle() const
	{
// If the hierarchy object doesn't support IVsProject then VS can not get the document path
// in order to try to get the file's system icon, so this is the last resort, as it is called after GetIconIndex
__if_not_exists(ItemInterface::SupportsProject)
{
		VSL_ASSERTEX(false, L"No project UI hierarchy item has no valid icon index and no icon handle, so the item can not be displayed");
}
		// indicates that Visual Studio should ask IVsProject to get a file path and use that file's associated icon instead
		VSL_CREATE_ERROR_HRESULT(DISP_E_MEMBERNOTFOUND);
		return NULL;
	}

	virtual HICON GetOpenFolderIconHandle() const
	{
		return GetIconHandle();
	}

	virtual UINT GetOpenFolderIconIndex() const
	{
		return GetIconIndex();
	}

	virtual bool IsExpandable() const
	{
		return m_pNode->HasDescendants();
	}

	virtual bool IsExpandedByDefault() const
	{
		return false;
	}

	virtual bool IsExpanded() const
	{
		return m_bExpanded;
	}

	virtual void SetExpanded(bool bExpanded)
	{
		m_bExpanded = bExpanded;
	}

private:

	bool m_bExpanded;
};

template <
	class BaseImpl_T = VsHierarchyItemBase<>,
	class RootInterface_T = IVsHierarchyRootItem<BaseImpl_T::ItemInterface> >
class VsHierarchyRootItemBase :
	public BaseImpl_T,
	public RootInterface_T
{
public:
	typedef typename BaseImpl_T BaseImpl;
	typedef typename BaseImpl::ItemInterface ItemInterface;

	VsHierarchyRootItemBase(ItemInterface* pInterface):
		BaseImpl_T(pInterface),
		m_pSelection(NULL)
	{
	}

protected:
	~VsHierarchyRootItemBase()
	{
	}

public:
	void Dispose()
	{
		// The root node will delete each of it's children, and they will delete their children, and so on...
		// Destruction of the node will destory the item it contains, including this instance, so this 
		// instance is invalid after this delete.
		delete m_pNode;
	}

	virtual VSITEMID GetVSITEMID() const
	{
		return VSITEMID_ROOT;
	}

	virtual IVsHierarchyEvents* GetIVsHierarchyEvents()
	{
		// Derived class needs to implement this properly
		VSL_CREATE_ERROR_HRESULT(E_UNEXPECTED);
		return NULL;
	}

	virtual ItemInterface& GetItem(_In_ VSITEMID itemid)
	{
		VSL_CHECKBOOLEAN(itemid != VSITEMID_NIL, E_INVALIDARG);

		if(VSITEMID_ROOT == itemid)
		{
			return *this;
		}

		if(VSITEMID_SELECTION == itemid)
		{
			VSL_CHECKPOINTER(m_pSelection, E_UNEXPECTED);
			return *m_pSelection;
		}

		BaseImpl_T::HierarchyNode::ItemContainer* pItem = m_pNode->FindItemContainer(ItemIdToItem(itemid));
		VSL_CHECKPOINTER(pItem, E_INVALIDARG);
		return **pItem;
	}

	virtual const GUID& GetGuidProperty(_In_ VSITEMID itemid, _In_ VSHPROPID propid) const
	{
		return GetItem(itemid).GetGuidProperty(propid);
	}

	virtual void SetGuidProperty(_In_ VSITEMID itemid, _In_ VSHPROPID propid, _In_ REFGUID rguid)
	{
		GetItem(itemid).SetGuidProperty(propid, rguid);
	}

	virtual void GetProperty(_In_ VSITEMID itemid, _In_ VSHPROPID propid, _Out_ VARIANT* pVar) const
	{
		VSITEMID requestedId = VSITEMID_ROOT;

		switch(propid)
		{
		case VSHPROPID_Root:
			break;
		case VSHPROPID_NextSibling:
			requestedId = ItemToItemId(GetNextSibling(itemid));
			break;
		case VSHPROPID_NextVisibleSibling:
			requestedId = ItemToItemId(GetNextVisibleSibling(itemid));
			break;
		case VSHPROPID_IconImgList:
			__if_exists(ItemInterface::SupportsUI)
			{{
				// VS only get's the image list from the root item, which means that it is global
				// for the entire hierarchy.
#pragma warning(push)
#pragma warning(disable : 4311) // 'reinterpret_cast' : pointer truncation from 'HIMAGELIST' to 'long'
				ATL::CComVariant var(reinterpret_cast<long>(static_cast<HIMAGELIST>(const_cast<VsHierarchyRootItemBase*>(this)->GetIconImageList())));
#pragma warning(pop)
				var.Detach(pVar);
				return;
			}}
		default:
			GetItem(itemid).GetProperty(propid, pVar);
			return;
		}

		ATL::CComVariant var(static_cast<__int32>(requestedId), VT_I4);
		var.Detach(pVar);
	}

	virtual void SetProperty(_In_ VSITEMID itemid, _In_ VSHPROPID propid, _In_ VARIANT& rVar)
	{
		GetItem(itemid).SetProperty(propid, rVar);
	}

	virtual ImageListWin32Control& GetIconImageList()
	{
		// indicates that Visual Studio will need to use icon handle for each item
		// of if no icon is provided, then attepmt to use IVsProject to get a file path 
		// and use that file's associated icon
		VSL_CREATE_ERROR_HRESULT(DISP_E_MEMBERNOTFOUND);
#pragma warning(push)
#pragma warning(disable : 4239 4172)
		return ImageListWin32Control();
#pragma warning(pop)
	}

protected:

	void SetSelection(ItemInterface* pSelection)
	{
		m_pSelection = pSelection;
	}

private:
	ItemInterface& GetItem(_In_ VSITEMID itemid) const
	{
		return const_cast<VsHierarchyRootItemBase*>(this)->GetItem(itemid);
	}

	typename BaseImpl_T::HierarchyNode::Item ItemIdToItem(_In_ VSITEMID itemid) const
	{
		return reinterpret_cast<BaseImpl_T::HierarchyNode::Item>(itemid);
	}

	VSITEMID ItemToItemId(_In_ const typename HierarchyNode::Item& item) const
	{
		return item != NULL ? item->GetVSITEMID() : VSITEMID_NIL;
	}

	VSITEMID TransformVSITEMIDForSibilingSearch(_In_ VSITEMID itemid) const
	{
		if(VSITEMID_ROOT == itemid)
		{
			VSL_CREATE_ERROR_HRESULT(E_INVALIDARG);
		}

		if(VSITEMID_SELECTION == itemid)
		{
			if(m_pSelection == static_cast<const ItemInterface* const>(this))
			{
				VSL_CREATE_ERROR_HRESULT(E_INVALIDARG);
			}
			return ItemToItemId(m_pSelection);
		}

		return itemid;
	}

	ItemInterface* GetNextSibling(_In_ VSITEMID itemid) const
	{
		BaseImpl_T::HierarchyNode::FindInfo findInfo = {ItemIdToItem(TransformVSITEMIDForSibilingSearch(itemid))};
		VSL_CHECKBOOLEAN(m_pNode->FindIterator(findInfo), E_INVALIDARG);
		if((++findInfo.rFound) != findInfo.pContainer->end())
		{
			return ***(findInfo.rFound);
		}
		return NULL;
	}

	ItemInterface* GetNextVisibleSibling(_In_ VSITEMID itemid) const
	{
		__if_exists(ItemInterface::SupportsUI)
		{
			BaseImpl_T::HierarchyNode::FindInfo findInfo = {ItemIdToItem(TransformVSITEMIDForSibilingSearch(itemid))};
			VSL_CHECKBOOLEAN(m_pNode->FindIterator(findInfo), E_INVALIDARG);
			for(++findInfo.rFound; findInfo.rFound != findInfo.pContainer->end(); ++findInfo.rFound)
			{
				if((***findInfo.rFound)->IsVisible())
				{
					return ***(findInfo.rFound);
				}
			}
		}
		__if_not_exists(ItemInterface::SupportsUI)
		{
			VSL_CREATE_ERROR_HRESULT(E_NOTIMPL);
		}
		return NULL;
	}

	ItemInterface* m_pSelection;
};

class IVsHierarchyEventsDelegate :
	public IVsHierarchyEvents
{
public:

// This isn't a real COM object
VSL_DEFINE_IUNKNOWN_NOTIMPL

	virtual HRESULT STDMETHODCALLTYPE OnItemAdded( 
        /* [in] */ VSITEMID itemidParent,
        /* [in] */ VSITEMID itemidSiblingPrev,
        /* [in] */ VSITEMID itemidAdded)
	{
		return m_dOnItemAdded(itemidParent, itemidSiblingPrev, itemidAdded);
	}
    
    virtual HRESULT STDMETHODCALLTYPE OnItemsAppended( 
        /* [in] */ VSITEMID itemidParent)
	{
		return m_dOnItemsAppended(itemidParent);
	}
    
    virtual HRESULT STDMETHODCALLTYPE OnItemDeleted( 
        /* [in] */ VSITEMID itemid)
	{
		return m_dOnItemDeleted(itemid);
	}
    
    virtual HRESULT STDMETHODCALLTYPE OnPropertyChanged( 
        /* [in] */ VSITEMID itemid,
        /* [in] */ VSHPROPID propid,
        /* [in] */ DWORD flags)
	{
		return m_dOnPropertyChanged(itemid, propid, flags);
	}
    
    virtual HRESULT STDMETHODCALLTYPE OnInvalidateItems( 
        /* [in] */ VSITEMID itemidParent)
	{
		return m_dOnInvalidateItems(itemidParent);
	}
    
    virtual /* [local] */ HRESULT STDMETHODCALLTYPE OnInvalidateIcon( 
        /* [in] */ HICON hicon)
	{
		return m_dOnInvalidateIcon(hicon);
	}

	typedef MemberFunctionPointerFunctor<IVsHierarchyEvents, CallingConventionStandard, HRESULT (VSITEMID, VSITEMID, VSITEMID)> OnItemAddedFunctor;
	typedef MemberFunctionPointerFunctor<IVsHierarchyEvents, CallingConventionStandard, HRESULT (VSITEMID)> OnItemsAppendedFunctor;
	typedef MemberFunctionPointerFunctor<IVsHierarchyEvents, CallingConventionStandard, HRESULT (VSITEMID)> OnItemDeletedFunctor;
	typedef MemberFunctionPointerFunctor<IVsHierarchyEvents, CallingConventionStandard, HRESULT (VSITEMID, VSHPROPID, DWORD)> OnPropertyChangedFunctor;
	typedef MemberFunctionPointerFunctor<IVsHierarchyEvents, CallingConventionStandard, HRESULT (VSITEMID)> OnInvalidateItemsFunctor;
	typedef MemberFunctionPointerFunctor<IVsHierarchyEvents, CallingConventionStandard, HRESULT (HICON)> OnInvalidateIconFunctor;

	struct IVsHierarchyEventsFunctors
	{
		OnItemAddedFunctor m_OnItemAddedFunctor;
		OnItemsAppendedFunctor m_OnItemsAppendedFunctor;
		OnItemDeletedFunctor m_OnItemDeletedFunctor;
		OnPropertyChangedFunctor m_OnPropertyChangedFunctor;
		OnInvalidateItemsFunctor m_OnInvalidateItemsFunctor;
		OnInvalidateIconFunctor m_OnInvalidateIconFunctor;

		IVsHierarchyEventsFunctors(
			IVsHierarchyEvents* pIVsHierarchyEvents):
				m_OnItemAddedFunctor(pIVsHierarchyEvents, &IVsHierarchyEvents::OnItemAdded),
				m_OnItemsAppendedFunctor(pIVsHierarchyEvents, &IVsHierarchyEvents::OnItemsAppended),
				m_OnItemDeletedFunctor(pIVsHierarchyEvents, &IVsHierarchyEvents::OnItemDeleted),
				m_OnPropertyChangedFunctor(pIVsHierarchyEvents, &IVsHierarchyEvents::OnPropertyChanged),
				m_OnInvalidateItemsFunctor(pIVsHierarchyEvents, &IVsHierarchyEvents::OnInvalidateItems),
				m_OnInvalidateIconFunctor(pIVsHierarchyEvents, &IVsHierarchyEvents::OnInvalidateIcon)
		{
		}
	};

	void operator+=(IVsHierarchyEventsFunctors& rFunctors)
	{
		m_dOnItemAdded += &(rFunctors.m_OnItemAddedFunctor);
		m_dOnItemsAppended += &(rFunctors.m_OnItemsAppendedFunctor);
		m_dOnItemDeleted += &(rFunctors.m_OnItemDeletedFunctor);
		m_dOnPropertyChanged += &(rFunctors.m_OnPropertyChangedFunctor);
		m_dOnInvalidateItems += &(rFunctors.m_OnInvalidateItemsFunctor);
		m_dOnInvalidateIcon += &(rFunctors.m_OnInvalidateIconFunctor);
	}

	void operator-=(IVsHierarchyEventsFunctors& rFunctors)
	{
		m_dOnItemAdded -= &(rFunctors.m_OnItemAddedFunctor);
		m_dOnItemsAppended -= &(rFunctors.m_OnItemsAppendedFunctor);
		m_dOnItemDeleted -= &(rFunctors.m_OnItemDeletedFunctor);
		m_dOnPropertyChanged -= &(rFunctors.m_OnPropertyChangedFunctor);
		m_dOnInvalidateItems -= &(rFunctors.m_OnInvalidateItemsFunctor);
		m_dOnInvalidateIcon -= &(rFunctors.m_OnInvalidateIconFunctor);
	}

private:
	Delegate<HRESULT (VSITEMID, VSITEMID, VSITEMID)> m_dOnItemAdded;
	Delegate<HRESULT (VSITEMID)> m_dOnItemsAppended;
	Delegate<HRESULT (VSITEMID)> m_dOnItemDeleted;
	Delegate<HRESULT (VSITEMID, VSHPROPID, DWORD)> m_dOnPropertyChanged;
	Delegate<HRESULT (VSITEMID)> m_dOnInvalidateItems;
	Delegate<HRESULT (HICON)> m_dOnInvalidateIcon;
};

template <
	class DerivedClass_T,
	class HierarchyRootItem_T,
	class Base_T = IVsHierarchy,
	class VsSiteCache_T = VsSiteCacheLocal >
class IVsHierarchyImpl :
	public VsSiteBaseImpl<DerivedClass_T, IVsHierarchyImpl<DerivedClass_T, HierarchyRootItem_T, Base_T, VsSiteCache_T>, Base_T, VsSiteCache_T>
{

private:

	HierarchyRootItem_T* CreateRootItemInstance()
	{
		HierarchyRootItem_T* pRootItem = NULL;
		VSL_CHECKHRESULT(HierarchyRootItem_T::CreateInstance(&pRootItem));
		VSL_CHECKPOINTER(pRootItem, E_FAIL);
#pragma warning(push) // compiler doesn't get that the above line will throw if pValidValues is NULL
#pragma warning(disable : 6011) // Dereferencing NULL pointer 'pRootItem'
		__if_exists(HierarchyRootItem_T::AddRef)
		{
			pRootItem->AddRef();
		}
		return pRootItem;
#pragma warning(pop)
	}

protected:

	
	IVsHierarchyImpl():
		m_pRoot(CreateRootItemInstance()),
	 	m_LastCookie(0)
	{
	}

	~IVsHierarchyImpl()
	{
		m_pRoot->Dispose();
	}

public:

	typedef HierarchyRootItem_T HierarchyRootItem;
	typedef typename HierarchyRootItem::ItemInterface ItemInterface;

	STDMETHOD(GetGuidProperty)( 
		_In_ VSITEMID itemid,
		_In_ VSHPROPID propid,
		_Out_ GUID *pguid)
	{
		VSL_STDMETHODTRY{

		EnsureValidVSHPROPID(propid);
		VSL_CHECKPOINTER(pguid, E_INVALIDARG);

		*pguid = GetRootItem().GetGuidProperty(itemid, propid);

		}VSL_STDMETHODCATCH()

		return VSL_GET_STDMETHOD_HRESULT();
	}
	
	STDMETHOD(SetGuidProperty)( 
		_In_ VSITEMID itemid,
		_In_ VSHPROPID propid,
		_In_ REFGUID rguid)
	{
		VSL_STDMETHODTRY{

		EnsureValidVSHPROPID(propid);

		GetRootItem().SetGuidProperty(itemid, propid, rguid);

		}VSL_STDMETHODCATCH()

		return VSL_GET_STDMETHOD_HRESULT();
	}
	
	STDMETHOD(GetProperty)( 
		_In_ VSITEMID itemid,
		_In_ VSHPROPID propid,
		_Out_ VARIANT *pvar)
	{
		VSL_STDMETHODTRY{

		EnsureValidVSHPROPID(propid);
		VSL_CHECKPOINTER(pvar, E_INVALIDARG);
		pvar->vt = VT_EMPTY;

		GetRootItem().GetProperty(itemid, propid, pvar);

		}VSL_STDMETHODCATCH()

		return VSL_GET_STDMETHOD_HRESULT();
	}
	
	STDMETHOD(SetProperty)( 
		_In_ VSITEMID itemid,
		_In_ VSHPROPID propid,
		_In_ VARIANT var)
	{
		VSL_STDMETHODTRY{

		EnsureValidVSHPROPID(propid);

		GetRootItem().SetProperty(itemid, propid, var);

		}VSL_STDMETHODCATCH()

		return VSL_GET_STDMETHOD_HRESULT();
	}
	
	STDMETHOD(GetNestedHierarchy)( 
		_In_ VSITEMID itemid,
		_In_ REFIID iidHierarchyNested,
		_Out_ void **ppHierarchyNested,
		_Out_ VSITEMID *pitemidNested)
	{
#if 1
		VSL_TRACE(_T("IVsHierarchyImpl::GetNestedHierarchy is not implemented\n"));

		(itemid, iidHierarchyNested, ppHierarchyNested, pitemidNested);

		return E_NOTIMPL;
#else // FUTURE - support IVsHierarchyImpl::GetNestedHierarchy
		VSL_STDMETHODTRY{

		VSL_CHECKPOINTER(ppHierarchyNested, E_INVALIDARG);
		VSL_CHECKPOINTER(pitemidNested, E_INVALIDARG);

		(iidHierarchyNested);

		}VSL_STDMETHODCATCH()

		return VSL_GET_STDMETHOD_HRESULT();
#endif
	}
	
	STDMETHOD(GetCanonicalName)( 
		_In_ VSITEMID itemid,
		_Out_ BSTR *pbstrName)
	{
		VSL_STDMETHODTRY_EX(E_NOTIMPL){

		VSL_CHECKPOINTER(pbstrName, E_INVALIDARG);

		__if_exists(ItemInterface::GetCanonicalName)
		{
		VSL_CHECKHRESULT(const_cast<ATL::CComBSTR&>(GetRootItem().GetItem(itemid).GetCanonicalName()).CopyTo(pbstrName));
		}
		__if_not_exists(ItemInterface::GetCanonicalName)
		{
		(itemid);
		}

		}VSL_STDMETHODCATCH()

		return VSL_GET_STDMETHOD_HRESULT();
	}
	
	STDMETHOD(ParseCanonicalName)( 
		_In_ LPCOLESTR pszName,
		_Out_ VSITEMID *pitemid)
	{
		VSL_STDMETHODTRY_EX(E_NOTIMPL){

		VSL_CHECKPOINTER(pszName, E_INVALIDARG);
		VSL_CHECKBOOLEAN(pszName[0] != L'\0', E_INVALIDARG);
		VSL_CHECKPOINTER(pitemid, E_INVALIDARG);

		__if_exists(ItemInterface::ParseCanonicalName)
		{
		*pitemid = GetRootItem().ParseCanonicalName(pszName);
		}

		}VSL_STDMETHODCATCH()

		return VSL_GET_STDMETHOD_HRESULT();
	}
	
	STDMETHOD(Unused0)()
	{
		VSL_TRACE(_T("IVsHierarchyImpl::Unused0 is not implemented\n"));

		return E_NOTIMPL;
	}
	
	STDMETHOD(AdviseHierarchyEvents)( 
		_In_ IVsHierarchyEvents *pEventSink,
		_Out_ VSCOOKIE *pdwCookie)
	{
		VSL_STDMETHODTRY{

		VSL_CHECKPOINTER(pEventSink, E_INVALIDARG);
		VSL_CHECKPOINTER(pdwCookie, E_INVALIDARG);

		VSL_CHECKBOOLEAN(m_LastCookie < 0xFFFFFFFF, E_FAIL);

		m_CookieEventList.push_front(CookieEventPair(++m_LastCookie, pEventSink));
		m_IVsHierarchyEventsDelegate += (*(m_CookieEventList.begin())).second;
		*pdwCookie = m_LastCookie;

		}VSL_STDMETHODCATCH()

		return VSL_GET_STDMETHOD_HRESULT();
	}
	
	STDMETHOD(UnadviseHierarchyEvents)( 
		_In_ VSCOOKIE dwCookie)
	{
		VSL_STDMETHODTRY{

		class RemoveCookieEvent
		{
		public:
			RemoveCookieEvent(VSCOOKIE cookie, IVsHierarchyEventsDelegate& rIVsHierarchyEventsDelegate):
				m_cookie(cookie),
				m_rIVsHierarchyEventsDelegate(rIVsHierarchyEventsDelegate)
			{
			}
			bool operator()(CookieEventPair& rToCheck)
			{
				if(rToCheck.first == m_cookie)
				{
					m_rIVsHierarchyEventsDelegate -= rToCheck.second;
					return true;
				}
				return false;
			}
			void operator=(const RemoveCookieEvent& rToCopy)
			{
				m_cookie = rToCopy.m_cookie;
				m_rIVsHierarchyEventsDelegate = rToCopy.m_rIVsHierarchyEventsDelegate;
			}
		private:
			VSCOOKIE m_cookie;
			IVsHierarchyEventsDelegate& m_rIVsHierarchyEventsDelegate;
		};

		// No verification that cookie is valid, just removal or not.
		m_CookieEventList.remove_if(RemoveCookieEvent(dwCookie, m_IVsHierarchyEventsDelegate));

		if(m_CookieEventList.empty())
		{
			// PARANOID - theoretically, over the long haul, m_LastCookie could wrap, 
			// so zero it when the list is empty
			m_LastCookie = 0;
		}

		}VSL_STDMETHODCATCH()

		return VSL_GET_STDMETHOD_HRESULT();
	}
	
	STDMETHOD(Unused1)()
	{
		VSL_TRACE(_T("IVsHierarchyImpl::Unused1 is not implemented\n"));

		return E_NOTIMPL;
	}
	
	STDMETHOD(Unused2)()
	{
		VSL_TRACE(_T("IVsHierarchyImpl::Unused2 is not implemented\n"));

		return E_NOTIMPL;
	}
	
	STDMETHOD(Unused3)()
	{
		VSL_TRACE(_T("IVsHierarchyImpl::Unused3 is not implemented\n"));

		return E_NOTIMPL;
	}
	
	STDMETHOD(Unused4)()
	{
		VSL_TRACE(_T("IVsHierarchyImpl::Unused4 is not implemented\n"));

		return E_NOTIMPL;
	}

	HierarchyRootItem& GetRootItem()
	{
		return *m_pRoot;
	}

	IVsHierarchyEvents* GetIVsHierarchyEvents()
	{
		return &m_IVsHierarchyEventsDelegate;
	}

protected:

	HierarchyRootItem* m_pRoot;

private:

	void EnsureValidVSHPROPID(_In_ VSHPROPID propid)
	{
		VSL_CHECKBOOLEAN(propid >= VSHPROPID_FIRST2 && propid <= VSHPROPID_LAST, E_INVALIDARG);
	}

	typedef std::pair<VSCOOKIE, IVsHierarchyEventsDelegate::IVsHierarchyEventsFunctors> CookieEventPair;

	std::list<CookieEventPair> m_CookieEventList;
	VSCOOKIE m_LastCookie;
	IVsHierarchyEventsDelegate m_IVsHierarchyEventsDelegate;
};

template <
	class DerivedClass_T,
	class HierarchyRootItem_T,
	class Base_T = IVsHierarchyImpl<DerivedClass_T, HierarchyRootItem_T, IVsUIHierarchy> >
class IVsUIHierarchyImpl :
	public Base_T
{
public:
	STDMETHOD(QueryStatusCommand)( 
		_In_ VSITEMID itemid,
		_In_ const GUID *pguidCmdGroup,
		_In_ ULONG cCmds,
		_Inout_cap_(cCmds) OLECMD prgCmds[  ],
		_Inout_opt_ OLECMDTEXT *pCmdText)
	{
		VSL_STDMETHODTRY{

		CComPtr<IOleCommandTarget> pTarget = GetRootItem().GetItem(itemid).GetIOleCommandTarget();

		if(!pTarget)
		{
			return OLECMDERR_E_NOTSUPPORTED;
		}

		return pTarget->QueryStatus(pguidCmdGroup, cCmds, prgCmds, pCmdText);

		}VSL_STDMETHODCATCH()

		return VSL_GET_STDMETHOD_HRESULT();
	};
	
	STDMETHOD(ExecCommand)( 
		_In_ VSITEMID itemid,
		_In_ const GUID *pguidCmdGroup,
		_In_ DWORD nCmdID,
		_In_ DWORD nCmdexecopt,
		_In_opt_ VARIANT *pvaIn,
		_Inout_opt_ VARIANT *pvaOut)
	{
		VSL_STDMETHODTRY{

		CComPtr<IOleCommandTarget> pTarget = GetRootItem().GetItem(itemid).GetIOleCommandTarget();

		if(!pTarget)
		{
			return OLECMDERR_E_NOTSUPPORTED;
		}

		return pTarget->Exec(pguidCmdGroup, nCmdID, nCmdexecopt, pvaIn, pvaOut);

		}VSL_STDMETHODCATCH()

		return VSL_GET_STDMETHOD_HRESULT();
	}
};

} // namespace VSL

#endif // VSLHIERARCHY_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\Include\VSLMockSystemInterfaces.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef VSLMOCKSYSTEMINTERFACE_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define VSLMOCKSYSTEMINTERFACE_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include <VSL.h>
#include <VSLErrorHandlers.h>

namespace VSL
{

template <class BaseClass_T>
class AddRefAndReleaseMockBase :
	public BaseClass_T
{

VSL_DECLARE_NOT_COPYABLE(AddRefAndReleaseMockBase)

private:

	LONG m_iRefCount;
	bool m_bRefCountBackToZero;

public:

	AddRefAndReleaseMockBase():
		m_iRefCount(0),
		m_bRefCountBackToZero(false)
	{
	}

	virtual ~AddRefAndReleaseMockBase()
	{
		const TCHAR* szNotReleased = _T("Mock object not fully released");
		if(m_iRefCount != 0)
		{
			if(IsDebuggerPresent() != 0)
			{
				DebugBreak();
			}
			VSL_TRACE(_T("ERROR: %s"), szNotReleased);
#ifndef VSL_UNIT_TEST_AddRefAndReleaseMockBase_Destructor_Supress_Assert
			VSL_UTASSERTEX(m_iRefCount == 0, _T("Mock object not fully released.  Ignoring this assert will frequently cause abnormal program termination."));
#endif
		}
		// This may cause terminate to get called, but we want to make sure the error doesn't get
		// ignored, so we live with that.
		VSL_CHECKBOOLEAN_EX(m_iRefCount == 0, E_FAIL, szNotReleased);
	}

	virtual ULONG STDMETHODCALLTYPE AddRef()
	{
		VSL_CHECKBOOLEAN_EX(!m_bRefCountBackToZero, E_FAIL, _T("Mock object AddRefed again after ref count arleady back to 0"));
		VSL_CHECKBOOLEAN_EX(m_iRefCount != LONG_MAX, E_FAIL, _T("Mock object AddRef ref counted beyond LONG_MAX"));
		::InterlockedIncrement(&m_iRefCount);
		return m_iRefCount;
	}
	virtual ULONG STDMETHODCALLTYPE Release()
	{
		VSL_CHECKBOOLEAN_EX(!m_bRefCountBackToZero, E_FAIL, _T("Mock object Releaseed again after ref count arleady back to 0"));
		if(m_bRefCountBackToZero && IsDebuggerPresent() != 0)
		{
			DebugBreak();
		}
		::InterlockedDecrement(&m_iRefCount);
		if(m_iRefCount == 0)
		{
			m_bRefCountBackToZero = true;
		}
		return m_iRefCount;
	}

	LONG GetRefCount() const
	{
		return m_iRefCount;
	}

	void SetRefCount(LONG iRefCount)
	{
		m_iRefCount = iRefCount;
	}
};

template <class PrimaryDerived_T = IUnknown>
class IUnknownInterfaceListTerminator
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IUnknownInterfaceListTerminator)

protected:

	template<typename This_T>
	static IUnknown* InternalGetIUnknownNoAddRef(This_T* pThis)
	{
		// NOTE - getting an error like:
		//
		//   ambiguous conversions from 'IVsWindowFrameMock *' to 'IUnknown *'
		//
		// here indicates that PrimaryDerived_T need to be set to a parent
		// of your equivalent of IVsWindowFrameMock in this example error.
		//
		// The parent should have only one direct derivation path to IUnknown.
		return static_cast<IUnknown*>(static_cast<PrimaryDerived_T*>(pThis));
	}

public:

	enum { NumberOfInterfaces = 1 };

	template<typename This_T>
	static HRESULT InternalQueryInterface(This_T* pThis, REFIID iid, void** ppObject)
	{
		if(__uuidof(IUnknown) == iid)
		{
			*ppObject = InternalGetIUnknownNoAddRef(pThis);
			pThis->AddRef();
			return S_OK;
		}
		*ppObject = NULL;
		return E_NOINTERFACE;
	}
};

typedef IUnknownInterfaceListTerminator<> IUnknownInterfaceListTerminatorDefault;

template <class Interface_T, class Next_T, class PrimaryDerived_T = Interface_T>
class InterfaceList :
	public Interface_T,
	public Next_T
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(InterfaceList)

public:

	enum { NumberOfInterfaces = Next_T::NumberOfInterfaces + 1 };

	template<class This_T>
	static HRESULT InternalQueryInterface(This_T* pThis, REFIID iid, void** ppObject)
	{
		if(__uuidof(Interface_T) == iid)
		{
			*ppObject = static_cast<Interface_T*>(static_cast<PrimaryDerived_T*>(pThis));
			pThis->AddRef();
			return S_OK;
		}
		return Next_T::InternalQueryInterface(pThis, iid, ppObject);
	}
};

template <class InterfaceList_T, class ImplementationClass_T>
class QueryInterfaceMockBase :
	public InterfaceList_T
{

VSL_DECLARE_NOT_COPYABLE(QueryInterfaceMockBase)

public:

	QueryInterfaceMockBase() {}

	virtual ~QueryInterfaceMockBase() = 0 {}

	STDMETHOD(QueryInterface)(REFIID iid, void** ppObject)
	{
		if(ppObject == NULL)
		{
			return E_POINTER;
		}
		return InterfaceList_T::InternalQueryInterface(static_cast<ImplementationClass_T*>(this), iid, ppObject);
	}
};

template <class InterfaceList_T, class ImplementationClass_T>
class COMMockBase : 
	public AddRefAndReleaseMockBase<QueryInterfaceMockBase<InterfaceList_T, ImplementationClass_T> >
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(COMMockBase)

public:

	IUnknown* GetIUnknownNoAddRef()
	{
		return InternalGetIUnknownNoAddRef(static_cast<ImplementationClass_T*>(this));
	}
};

#define VSL_DECLARE_COM_MOCK(className, interfaceList) \
class className : \
	public COMMockBase<interfaceList , className>

template <class InterfaceImpl_T, class Next_T>
class InterfaceImplList :
	public InterfaceImpl_T,
	public Next_T
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(InterfaceImplList)

public:

	enum { NumberOfInterfaces = Next_T::NumberOfInterfaces + 1 };

	template<class This_T>
	static HRESULT InternalQueryInterface(This_T* pThis, REFIID iid, void** ppObject)
	{
		if(__uuidof(InterfaceImpl_T::Interface) == iid)
		{
			*ppObject = static_cast<InterfaceImpl_T::Interface*>(static_cast<InterfaceImpl_T*>(pThis));
			pThis->AddRef();
			return S_OK;
		}
		return Next_T::InternalQueryInterface(pThis, iid, ppObject);
	}
};

// If the mock object provides all of the interfaces itself
// AtlIServiceProviderImplAdaptor can be used to make use of
// ATL::IServiceProviderImpl should be utilized instead.
template <class Base_T>
class AtlIServiceProviderImplAdaptor :
	public ATL::IServiceProviderImpl<Base_T>
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(AtlIServiceProviderImplAdaptor)

public:

	typedef IServiceProvider Interface;
};

#define VSL_DEFINE_SERVICE_MOCK_EX(Name, InterfaceImplList, ServiceGuid) \
\
VSL_DECLARE_COM_MOCK(Name, InterfaceImplList) \
{ \
public: \
	static REFGUID GetServiceID() \
	{ \
		return ServiceGuid; \
	} \
}

// TODO - add ServiceGuid parameter to this, service GUID should always be specified
#define VSL_DEFINE_SERVICE_MOCK(Name, InterfaceImpl) \
typedef InterfaceImplList<InterfaceImpl, IUnknownInterfaceListTerminatorDefault> Name##InterfaceList; \
\
VSL_DEFINE_SERVICE_MOCK_EX(Name, Name##InterfaceList, __uuidof(InterfaceImpl::Interface))

class ServiceListTerminator
{
private:

	const ServiceListTerminator& operator=(const ServiceListTerminator& rToCopy);

public:

	// Allow use of compiler generated constructors and destructor

	enum { NumServices = 0 };

	HRESULT InternalQueryService(REFGUID /*serviceID*/, REFIID /*interfaceID*/, void** ppObject)
	{
		*ppObject = NULL;
		return E_NOINTERFACE;
	}
};

template <class Service_T, class Next_T>
class ServiceList
{
private:

	const ServiceList& operator=(const ServiceList& rToCopy);

public:

	enum { NumServices = Next_T::NumServices + 1 };

	// Allow use of compiler generated constructors and destructor
	ServiceList():
		m_Next(),
		m_Service()
	{
		m_Service.AddRef();
	}

	~ServiceList()
	{
		m_Service.Release();
	}

	HRESULT InternalQueryService(REFGUID serviceID, REFIID interfaceID, void** ppObject)
	{
		if(Service_T::GetServiceID() == serviceID)
		{
			return m_Service.QueryInterface(interfaceID, ppObject);
		}
		return m_Next.InternalQueryService(serviceID, interfaceID, ppObject);
	}

private:

	Next_T m_Next;
	Service_T m_Service;

};

// If the mock object aggregates the services as seperate objects
// IServiceProviderImpl needs to be used.
template <class ServiceList_T>
class IServiceProviderImpl :
	public IServiceProvider
{
private:

	ServiceList_T m_ServiceList;

public:
	typedef IServiceProvider Interface;

	STDMETHOD(QueryService)(REFGUID serviceID, REFIID interfaceID, void** ppObject)
	{
		if(ppObject == NULL)
		{
			return E_POINTER;
		}
		return m_ServiceList.InternalQueryService(serviceID, interfaceID, ppObject);
	}
};

// REVIEW - should this be in this file or a new one (VSLMock.h?)
// TODO - unit test this
template <const GUID* ServiceGuid_T>
class ServiceMockAdapter
{
public:
	static REFGUID GetServiceID()
	{
		return *ServiceGuid_T;
	}

	STDMETHOD(QueryInterface)(REFIID iid, void** ppObject)
	{
		return GetAdapted()->QueryInterface(iid, ppObject);
	}

	static CComPtr<IUnknown>& GetAdapted()
	{
		static CComPtr<IUnknown> pAdapted;
		return pAdapted;
	}

	ULONG AddRef()
	{
		// Do nothing, the owner of what pAdapted is set to need to ref count, it rather then the 
		// service list
		return 0;
	}

	ULONG Release()
	{
		// Do nothing, the owner of what pAdapted is set to need to ref count, it rather then the 
		// service list
		return 0;
	}
};

} // namespace VSL

#endif VSLMOCKSYSTEMINTERFACE_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\Include\VSLPackageDllEntryPoints.cpp ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef VSL_REGISTER_TYPE_LIB
#define VSL_REGISTER_TYPE_LIB FALSE
#endif VSL_REGISTER_TYPE_LIB

#pragma warning(push) // Sometimes true, sometimes not.
#pragma warning(disable : 4702) // warning C4702: unreachable code

// Initializes ATL
extern "C"
BOOL WINAPI DllMain(HINSTANCE /*hInstance*/, DWORD dwReason, LPVOID lpReserved)
{
	VSL_STDMETHODTRY{

	return _AtlModule.DllMain(dwReason, lpReserved);

	}VSL_STDMETHODCATCH()

	return FALSE;
}

// Used by COM to determine whether the DLL can be unloaded
STDAPI DllCanUnloadNow()
{
	VSL_STDMETHODTRY{

	return _AtlModule.DllCanUnloadNow();

	}VSL_STDMETHODCATCH()

	return VSL_GET_STDMETHOD_HRESULT();
}

// Returns a class factory to create an object of the requested type
STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
	VSL_STDMETHODTRY{

	return _AtlModule.GetClassObject(rclsid, riid, ppv);

	}VSL_STDMETHODCATCH()

	return VSL_GET_STDMETHOD_HRESULT();
}


STDMETHODIMP VSDllRegisterServerInternal(_In_opt_ wchar_t* strRegRoot, bool shouldRegister, bool isRanu)
{
	VSL_STDMETHODTRY{

	VsRegistryUtilities::SetRegRoot(NULL==strRegRoot ? DEFAULT_REGISTRY_ROOT : strRegRoot, isRanu);

	//Set ATL to register the typelib as RANU if requested by the caller.
	AtlSetPerUserRegistration(isRanu);

	if(shouldRegister)
	{
		return _AtlModule.RegisterServer(VSL_REGISTER_TYPE_LIB);
	}
	else
	{
		HRESULT hr = _AtlModule.UnregisterServer(VSL_REGISTER_TYPE_LIB);

		// If the type library was already unregistered, ignore the failure
		return (TYPE_E_REGISTRYACCESS == hr) ? S_OK : hr;
	}
	}VSL_STDMETHODCATCH()

	return VSL_GET_STDMETHOD_HRESULT();
}

// Registers COM objects normally and registers VS Packages to the specified VS registry hive under HKCU
STDAPI VSDllRegisterServerUser(_In_opt_ wchar_t* strRegRoot)
{
	return VSDllRegisterServerInternal(strRegRoot, true, true);
}

// Unregisters COM objects normally and unregisters VS Packages from the specified VS registry hive under HKCU
STDAPI VSDllUnregisterServerUser(__in_opt wchar_t* strRegRoot)
{
	return VSDllRegisterServerInternal(strRegRoot, false, true);
}

// Registers COM objects normally and registers VS Packages to the specified VS registry hive
STDAPI VSDllRegisterServer(__in_opt wchar_t* strRegRoot)
{
	return VSDllRegisterServerInternal(strRegRoot, true, false);
}

// Unregisters COM objects normally and unregisters VS Packages from the specified VS registry hive
STDAPI VSDllUnregisterServer(__in_opt wchar_t* strRegRoot)
{
	return VSDllRegisterServerInternal(strRegRoot, false, false);
}

// Registers COM objects normally and registers VS Packages to the default VS registry hive
STDAPI DllRegisterServer()
{
	return VSDllRegisterServer(NULL);
}

// Unregisters COM objects normally and unregisters VS Packages from the default VS registry hive
STDAPI DllUnregisterServer()
{
	return VSDllUnregisterServer(NULL);
}

#pragma warning(pop)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\Include\VSLPackage.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef VSLPACKAGE_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define VSLPACKAGE_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

// VSL includes
#include <VSLVsSite.h>

// ATL includes
#include <ATLColl.h>

// VS Platform includes
#include <vssplash.h>
#include <dte.h> // required for IExtensibleObjectImpl

namespace VSL
{

/*
A non-NULL non-empty string must be passed to VsRegistryUtilities::SetRegRoot in 
VSDllRegisterServer, VSDllUnregisterServer, DllRegisterServer, and DllUnregisterServer 
in any module intending to expose a VS package implemented using VSL.
	
If the VSL package registration macros are utilized it is not necessary to call 
GetRegRootStrings or GetRegDefaultResourceStrings directly.
*/
class VsRegistryUtilities
{
private:
	static bool& GetUseHKCU()
	{
		static bool useHKCU = false;
		return useHKCU;
	}

	static wchar_t*& GetRegRoot()
	{
		static wchar_t* szRegRoot = NULL;
		return szRegRoot;
	}
	static void ErrorIfUninitialized()
	{
		if(GetRegRoot() == NULL)
		{
			VSL_CREATE_ERROR_HRESULT(E_UNEXPECTED);
		}
	}	
public:
	
	/*
	The string passed SetRegRoot needs have lifetime lasting until the end of the registration
	process.  This is true for the strings passed into VSDllRegisterServer and
	VSDllUnregisterServer, and as well as string literals, static and global strings,
	and local strings declared in DllRegisterServer and DllUnregisterServer.
	The one thing this would not be true for, is passing in a string on the heap, which
	is deleted immediately after the call to SetRegRoot, so this should be avoided.
	*/
	static void SetRegRoot(_In_z_ wchar_t* szRegRoot, bool isRanu = FALSE)
	{
		VSL_CHECKBOOLEAN(szRegRoot != NULL, E_POINTER);
#pragma warning(push) // compiler doesn't get that the above line will throw if szRegRoot is NULL
#pragma warning(disable : 6011) // Dereferencing NULL pointer 'szRegRoot'
		VSL_CHECKBOOLEAN(szRegRoot[0] != L'\0', E_INVALIDARG);
#pragma warning(pop)
		GetRegRoot() = szRegRoot;
		GetUseHKCU() = isRanu;
	}
	
	// SetRegRoot must be called before GetRegHiveString.
	static void GetRegHiveString(CComBSTR& bstrRegHive)
	{
		ErrorIfUninitialized();
		(bstrRegHive);
		if(GetUseHKCU())
		{
			VSL_CHECKHRESULT(bstrRegHive.Append(L"HKCU"));
		}
		else
		{
			VSL_CHECKHRESULT(bstrRegHive.Append(L"HKLM"));
		}
	}

	// SetRegRoot must be called before GetRegRootStrings.
	static void GetRegRootStrings(CComBSTR& bstrRootBegin, CComBSTR& bstrRootEnd)
	{
		ErrorIfUninitialized();
		(bstrRootBegin, bstrRootEnd);

		wchar_t segmentCopy[225];
		wchar_t * pszStartSegment = segmentCopy;
		wchar_t * pszEndSegment = segmentCopy;

		wcscpy_s(segmentCopy, _countof(segmentCopy), GetRegRoot());
		if(GetUseHKCU())
		{
			wcscat_s(segmentCopy, _countof(segmentCopy), L"\\Configuration");
		}

#pragma warning(push)
#pragma warning(disable : 4127) // conditional expression is constant
		while(true)
#pragma warning(pop)
		{
			// Find the end of this segment
			for(; *pszEndSegment != L'\\' && *pszEndSegment != L'\0'; ++pszEndSegment)
			{
				// 64 characters seems like a resaonable limit on each segment,
				// so error out if it's longer.
				if(pszEndSegment - pszStartSegment + 1 > 64) // +1 to turn diff into count
				{
					VSL_CREATE_ERROR_HRESULT(E_INVALIDARG);
				}
			}

			const int iSegmentLenth = static_cast<int>(pszEndSegment - pszStartSegment);
			VSL_CHECKBOOLEAN(iSegmentLenth > 0, E_INVALIDARG);
			
			VSL_CHECKHRESULT(bstrRootBegin.Append(L" NoRemove "));
			VSL_CHECKHRESULT(bstrRootBegin.Append(pszStartSegment, iSegmentLenth));
			VSL_CHECKHRESULT(bstrRootBegin.Append(L"\n{\n"));
			VSL_CHECKHRESULT(bstrRootEnd.Append(L"\n}\n"));

			// The second check deals with the string ending with a L'\\'
			if(*pszEndSegment == L'\0' || *(pszEndSegment+1) == L'\0')
			{
				break;
			}

			++pszEndSegment;

			pszStartSegment = pszEndSegment;
		}
	}

	static void GetRegDefaultResourceStrings(CComBSTR& bstrResDllPath, CComBSTR& bstrResDllName)
	{
		wchar_t szModuleFullName[_MAX_PATH];
		DWORD dwLen = ::GetModuleFileNameW(_AtlBaseModule.GetModuleInstance(), szModuleFullName, ARRAYSIZE(szModuleFullName));
		VSL_CHECKBOOL_GLE(static_cast<BOOL>(dwLen > 0));
		VSL_CHECKBOOLEAN(static_cast<BOOL>(dwLen != ARRAYSIZE(szModuleFullName)), __HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER));
	    
		LPTSTR pszModuleFileName = ::PathFindFileName(szModuleFullName);
		VSL_CHECKBOOLEAN(pszModuleFileName != szModuleFullName, E_FAIL);

		VSL_CHECKHRESULT(bstrResDllPath.Append(szModuleFullName, static_cast<int>(pszModuleFileName - szModuleFullName)));

		LPTSTR pszModuleFileExtension = ::PathFindExtension(szModuleFullName);

		VSL_CHECKHRESULT(bstrResDllName.Append(pszModuleFileName, static_cast<int>(pszModuleFileExtension - pszModuleFileName)));
		VSL_CHECKHRESULT(bstrResDllName.Append(L"UI"));
		VSL_CHECKHRESULT(bstrResDllName.Append(pszModuleFileExtension));
	}
};

#define VSL_BEGIN_REGISTRY_MAP_EX(resourceID) \
	static HRESULT WINAPI UpdateRegistry(BOOL bRegister) \
	{ \
		const UINT iResourceID = resourceID; \
		\
		VSL_STDMETHODTRY{ \
		\
		ATL::CAtlArray<ATL::_ATL_REGMAP_ENTRY> regMapEntries; \
		\
		/* Set array to grow by to 10 as that is more then required by basic packages */ \
		/* We don't set the count though as each item will be default constructed. */ \
		regMapEntries.SetCount(0, 10);

#define _VSL_SZ_REGROOTBEGIN L"REGROOTBEGIN"
#define _VSL_SZ_REGROOTEND L"REGROOTEND"
#define _VSL_SZ_REGHIVE L"REGHIVE"

#define VSL_REGISTRY_MAP_REGROOT_ENTRY() \
	    ATL::CComBSTR bstrRegRootBegin; \
		ATL::CComBSTR bstrRegRootEnd; \
		ATL::CComBSTR bstrRegHive; \
		VSL::VsRegistryUtilities::GetRegRootStrings( \
			bstrRegRootBegin, \
			bstrRegRootEnd); \
		VSL::VsRegistryUtilities::GetRegHiveString( \
			bstrRegHive); \
		ATL::_ATL_REGMAP_ENTRY regRootBeginEntry = {_VSL_SZ_REGROOTBEGIN, bstrRegRootBegin}; \
		regMapEntries.Add(regRootBeginEntry); \
		ATL::_ATL_REGMAP_ENTRY regRootEndEntry = {_VSL_SZ_REGROOTEND, bstrRegRootEnd}; \
		regMapEntries.Add(regRootEndEntry); \
		ATL::_ATL_REGMAP_ENTRY regHiveEntry = {_VSL_SZ_REGHIVE, bstrRegHive}; \
		regMapEntries.Add(regHiveEntry);

#define _VSL_SZ_RESOURCE_PATH L"RESOURCE_PATH"
#define _VSL_SZ_RESOURCE_DLL L"RESOURCE_DLL"

#define VSL_REGISTRY_MAP_RESOURCEDLL_ENTRY() \
	    ATL::CComBSTR bstrResDllPath; \
		ATL::CComBSTR bstrResDllName; \
		VSL::VsRegistryUtilities::GetRegDefaultResourceStrings( \
			bstrResDllPath, \
			bstrResDllName); \
		ATL::_ATL_REGMAP_ENTRY resDllPathEntry = {_VSL_SZ_RESOURCE_PATH, bstrResDllPath}; \
		regMapEntries.Add(resDllPathEntry); \
		ATL::_ATL_REGMAP_ENTRY resDllNameEntry = {_VSL_SZ_RESOURCE_DLL, bstrResDllName}; \
		regMapEntries.Add(resDllNameEntry);

#define VSL_BEGIN_REGISTRY_MAP(resourceID) \
VSL_BEGIN_REGISTRY_MAP_EX(resourceID) \
	VSL_REGISTRY_MAP_REGROOT_ENTRY() \
	VSL_REGISTRY_MAP_RESOURCEDLL_ENTRY()

#define _VSL_SZ_TEMPLATE_PATH L"TEMPLATE_PATH"

// VSL_REGISTRY_MAP_RESOURCEDLL_ENTRY must come after VSL_REGISTRY_MAP_RESOURCEDLL_ENTRY in the map
// This is automatic so long as the map begins with VSL_BEGIN_REGISTRY_MAP rather then
// VSL_BEGIN_REGISTRY_MAP_EX
#define VSL_REGISTRY_MAP_TEMPLATE_PATH_ENTRY() \
		ATL::_ATL_REGMAP_ENTRY resTemplatePathEntry = {_VSL_SZ_TEMPLATE_PATH, bstrResDllPath}; \
		regMapEntries.Add(resTemplatePathEntry); \

#define VSL_REGISTRY_MAP_GUID_ENTRY(guid) \
		ATL::CComBSTR bstr##guid(guid); \
		if(!bstr##guid) \
		{ \
			return E_OUTOFMEMORY; \
		} \
		wchar_t szNameOf_##guid[] = L#guid; \
		C_ASSERT(_countof(szNameOf_##guid) <= 31); \
		ATL::_ATL_REGMAP_ENTRY guid##Entry = {szNameOf_##guid, bstr##guid}; \
		regMapEntries.Add(guid##Entry); \

#define VSL_REGISTRY_MAP_GUID_ENTRY_EX(guid, name) \
		ATL::CComBSTR bstr##name(guid); \
		if(!bstr##name) \
		{ \
			return E_OUTOFMEMORY; \
		} \
		wchar_t szNameOf_##name[] = L#name; \
		C_ASSERT(_countof(szNameOf_##name) <= 31); \
		ATL::_ATL_REGMAP_ENTRY name##Entry = {szNameOf_##name, bstr##name}; \
		regMapEntries.Add(name##Entry); \

#define VSL_REGISTRY_MAP_NUMBER_ENTRY(number) \
		/* A signed int can have 10 digits, a '-', and is should be NULL terminated totally 12 characters max. */ \
		wchar_t sz##number[12]; \
		if(0 != ::_ultow_s(number, sz##number, ARRAYSIZE(sz##number), 10)) \
		{ \
			return E_FAIL; \
		} \
		wchar_t szNameOf_##number[] = L#number; \
		C_ASSERT(_countof(szNameOf_##number) <= 31); \
		ATL::_ATL_REGMAP_ENTRY number##Entry = {szNameOf_##number, sz##number}; \
		regMapEntries.Add(number##Entry);

#define VSL_REGISTRY_MAP_STRING_ENTRY(str) \
		if(!str) \
		{ \
			return E_POINTER; \
		} \
		wchar_t szNameOf_##str[] = L#str; \
		C_ASSERT(_countof(szNameOf_##str) <= 31); \
		ATL::_ATL_REGMAP_ENTRY str##Entry = {szNameOf_##str, str}; \
		regMapEntries.Add(str##Entry);

#define VSL_REGISTRY_RESOURCEID_ENTRY(resourceID) \
		/* A signed int can have 10 digits, a '-', and is should be NULL terminated totally 12 characters max. */ \
		/* We also have to add '#' in front of it to tell the shell that this is a resource id, so the total */ \
		/* number or characters needed is 13 */ \
		wchar_t sz##resourceID[13]; \
		sz##resourceID[0] = _T('#'); \
		if(0 != ::_ultow_s(resourceID, &sz##resourceID[1], ARRAYSIZE(sz##resourceID)-1, 10)) \
		{ \
			return E_FAIL; \
		} \
		wchar_t szNameOf_##resourceID[] = L#resourceID; \
		C_ASSERT(_countof(szNameOf_##resourceID) <= 31); \
		ATL::_ATL_REGMAP_ENTRY resourceID##Entry = {szNameOf_##resourceID, sz##resourceID}; \
		regMapEntries.Add(resourceID##Entry);

#define VSL_REGISTRY_RESOURCE_STRING_ENTRY(resourceID) \
		ATL::CComBSTR bstr##resourceID; \
		VSL_CHECKBOOL_GLE(bstr##resourceID.LoadString(_AtlBaseModule.GetResourceInstance(), resourceID)); \
		wchar_t szNameOf_##resourceID[] = L#resourceID; \
		C_ASSERT(_countof(szNameOf_##resourceID) <= 31); \
		ATL::_ATL_REGMAP_ENTRY resourceID##StringEntry = {szNameOf_##resourceID, bstr##resourceID}; \
		regMapEntries.Add(resourceID##StringEntry);

#define VSL_END_REGISTRY_MAP() \
	    ATL::_ATL_REGMAP_ENTRY regMapTerminator = {NULL, NULL}; \
		regMapEntries.Add(regMapTerminator); \
		\
		__if_exists(::_Module) \
		{ \
			return ::_Module.UpdateRegistryFromResourceS(iResourceID, bRegister, regMapEntries.GetData()); \
		} \
		__if_not_exists(::_Module) \
		{ \
			return ATL::_pAtlModule->UpdateRegistryFromResourceS(iResourceID, bRegister, regMapEntries.GetData()); \
		} \
		\
		}VSL_STDMETHODCATCH() \
		\
		return VSL_GET_STDMETHOD_HRESULT(); \
	}

// TODO - 6/21/2006 - unit test this
class VsShellUtilities
{

	VSL_DECLARE_NOT_COPYABLE(VsShellUtilities)

private:
	class Private {}; // Used to make a private instatiation of GlobalRefCount
	typedef GlobalRefCount<Private> RefCount;

public:

	VsShellUtilities(IVsShell* pIVsShell):
		m_spIVsShell(VSL_CHECKPOINTER_DEFAULT(pIVsShell))
	{
	}

	HRESULT LoadUILibrary(REFCLSID rclsidPackage)
	{
		RefCount::ErrorIfCanNotIncrement();

		if(RefCount::Get() > 0)
		{
			++RefCount::Get();
			return S_OK;
		}

		HINSTANCE hInstance = NULL;
		HRESULT hr = m_spIVsShell->LoadUILibrary(rclsidPackage, 0, reinterpret_cast<DWORD_PTR *>(&hInstance));
		if(FAILED(hr))
		{
			return hr;
		}

		if(hInstance == NULL)
		{
			return E_UNEXPECTED;
		}

		// Set the resource instance
		_AtlBaseModule.SetResourceInstance(hInstance);

		++RefCount::Get();
		return S_OK;
	}

	static void UnloadUILibrary()
	{
		if(!RefCount::CanDecrement())
		{
			// Just ignore excessive UnloadUILibrary() calls, since wrapping is prevented
			return;
		}

		if(RefCount::Get() > 1)
		{
			--RefCount::Get();
			return;
		}

		HINSTANCE hResource = _AtlBaseModule.GetResourceInstance();
		HINSTANCE hModule = _AtlBaseModule.GetModuleInstance();

		VSL_CHECKBOOLEAN(hResource != hModule, E_UNEXPECTED);
		if(hResource != NULL)
		{   
			::FreeLibrary(hResource);
		}
		_AtlBaseModule.SetResourceInstance(hModule);

		--RefCount::Get();
	}
private:
	CComPtr<IVsShell> m_spIVsShell;
};

template <
	const CLSID * const clsidPackage_T,
	class VsSiteCache_T,
	class VsShellUtilities_T = VsShellUtilities,
	class ExtendedErrorInfo_T = ExtendedErrorInfo >
class LoadUILibraryRequired
{
public:
	typedef ExtendedErrorInfo ExtendedErrorInfo;

	static void LoadUILibrary(
		const VsSiteCache_T& rVsSiteCache, 
		const ExtendedErrorInfo& rExtendedErrorInfo)
	{
		VsShellUtilities_T utilVsShell(rVsSiteCache.GetCachedService<IVsShell, SID_SVsShell>());
		HRESULT hr = utilVsShell.LoadUILibrary(*clsidPackage_T);
		VSL_CHECKHRESULT_EX(hr, rExtendedErrorInfo);
	}
	static void UnloadUILibrary()
	{
		VsShellUtilities_T::UnloadUILibrary();
	}
};

// FUTURE - could provide LoadUILibraryOptional, which would attempt to load the resource DLL, 
// but not report an or throw and exception if it fails to load.

template <class VsSiteCache_T>
class LoadUILibraryNoop
{
public:
	static void LoadUILibrary(const VsSiteCache_T& /*rVsSiteCache*/)
	{
	}
	static void UnloadUILibrary()
	{
	}
};

template <const GUID * const clsidPackage_T = &GUID_NULL>
class IVsPackageImplDefaults
{
public:
	typedef VsSiteCacheGlobal VsSiteCache;
	typedef LoadUILibraryRequired<clsidPackage_T, VsSiteCache> LoadUILibrary;
};


template <
	class DerivedClass_T,
	const GUID * const clsidPackage_T,
	class VsSiteCache_T = IVsPackageImplDefaults<clsidPackage_T>::VsSiteCache,
	class LoadUILibrary_T = IVsPackageImplDefaults<clsidPackage_T>::LoadUILibrary >
class IVsPackageImpl :
	public VsSiteBaseImpl<DerivedClass_T, IVsPackageImpl<DerivedClass_T, clsidPackage_T, VsSiteCache_T, LoadUILibrary_T>, IVsPackage, VsSiteCache_T>
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsPackageImpl)

public:

	typedef LoadUILibrary_T LoadUILibrary;

    STDMETHOD(GetAutomationObject)(LPCOLESTR /*pszPropName*/, IDispatch** ppIDispatch)
	{
		VSL_TRACE(_T("IVSPackageImpl::GetAutomationObject is not implemented\n"));

		VSL_STDMETHODTRY_EX(E_NOTIMPL){

		VSL_CHECKPOINTER_DEFAULT(ppIDispatch);

		*ppIDispatch = NULL;

		}VSL_STDMETHODCATCH()

		return VSL_GET_STDMETHOD_HRESULT();
	}

    STDMETHOD(CreateTool)(REFGUID /*rguidPersistanceSlot*/)
	{
		VSL_TRACE(_T("IVSPackageImpl::CreateTool is not implemented\n"));

		return E_NOTIMPL;
	}

    STDMETHOD(ResetDefaults)(PKGRESETFLAGS /*dwFlags*/)
	{
		VSL_TRACE(_T("IVSPackageImpl::ResetDefaults is not implemented\n"));

		return E_NOTIMPL;
	}

    STDMETHOD(GetPropertyPage)(REFGUID /*rguidPage*/, VSPROPSHEETPAGE* /*ppage*/)
	{
		VSL_TRACE(_T("IVSPackageImpl::GetPropertyPage is not implemented\n"));

		return E_NOTIMPL;
	}
};

// TODO - unit test these
#define VSL_BEGIN_TOOL_MAP() \
	STDMETHOD(CreateTool)(REFGUID rguidPersistanceSlot) \
	{ \
		VSL_STDMETHODTRY_EX(E_FAIL){ \

#define VSL_TOOL_ENTRY(guidPersistanceSlot, creator) \
		if(rguidPersistanceSlot == guidPersistanceSlot) \
		{ \
			creator; \
			return S_OK; \
		}

#define VSL_END_TOOL_MAP() \
		}VSL_STDMETHODCATCH() \
		return VSL_GET_STDMETHOD_HRESULT(); \
	}

template <
	unsigned int OfficialNameID_T,
	unsigned int ProductID_T,
	unsigned int ProductDetailsID_T,
	unsigned int LogoIconID_T>
class IVsInstalledProductImpl :
	public IVsInstalledProduct
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsInstalledProductImpl)

protected:
	void SetBSTRFromResourceID(BSTR *pbstrToSet, unsigned int iResourceID)
	{
		VSL_CHECKPOINTER_DEFAULT(pbstrToSet);
		CComBSTR bstr;
		VSL_CHECKBOOL_GLE(bstr.LoadString(_AtlBaseModule.GetResourceInstance(), iResourceID));
		*pbstrToSet = bstr.Detach();
	}
public:
	STDMETHOD(get_OfficialName)(BSTR *pbstrName)
	{
		VSL_STDMETHODTRY{

		SetBSTRFromResourceID(pbstrName, OfficialNameID_T);

		}VSL_STDMETHODCATCH()

		return VSL_GET_STDMETHOD_HRESULT();
	}

	STDMETHOD(get_ProductID)(BSTR *pbstrPID)
	{
		VSL_STDMETHODTRY{

		SetBSTRFromResourceID(pbstrPID, ProductID_T);

		}VSL_STDMETHODCATCH()

		return VSL_GET_STDMETHOD_HRESULT();
	}

	STDMETHOD(get_ProductDetails)(BSTR *pbstrProductDetails)
	{
		VSL_STDMETHODTRY{

		SetBSTRFromResourceID(pbstrProductDetails, ProductDetailsID_T);

		}VSL_STDMETHODCATCH()

		return VSL_GET_STDMETHOD_HRESULT();
	}

	STDMETHOD(get_IdIcoLogoForAboutbox)(UINT *pIdIco)
	{
		VSL_STDMETHODTRY{

		VSL_CHECKPOINTER_DEFAULT(pIdIco);
		*pIdIco = LogoIconID_T;

		}VSL_STDMETHODCATCH()

		return VSL_GET_STDMETHOD_HRESULT();
	}

	STDMETHOD(get_IdBmpSplash)(UINT* pIdBmp)
	{
		VSL_TRACE(_T("IVsInstalledProduct::get_IdBmpSplash is not implemented, as it is no longer called by Visaul Studio\n"));

		VSL_STDMETHODTRY_EX(E_NOTIMPL){

		VSL_CHECKPOINTER_DEFAULT(pIdBmp);

		}VSL_STDMETHODCATCH()

		return VSL_GET_STDMETHOD_HRESULT();
	}
};

class VsUtilityLocalSiteControl
{
	enum {
		Local = 1
	};
};

class VsUtilityGlobalSiteControl
{
	enum {
		Global = 1
	};
};

// TODO - unit test this
// REVIEW - should this be global by default instead?
template <class SiteControl_T = VsUtilityLocalSiteControl>
class VsOutputWindowUtilities
{

	VSL_DECLARE_NOT_COPYABLE(VsOutputWindowUtilities)

public:

	VsOutputWindowUtilities()
	{
	}

	// The compiler generated destructor is fine
 
__if_exists(SiteControl_T::Local) // TODO - Using __if_not_exists(SiteControl_T::Global) here causes and ICE, report to compiler team
{

	VsOutputWindowUtilities(IVsOutputWindowPane* pIVsOutputWindowPane):
		m_spIVsOutputWindowPane(VSL_CHECKPOINTER_DEFAULT(pIVsOutputWindowPane))
	{
	}

	template <class VsSiteCache_T>
	void SetSite(const VsSiteCache_T& rVsSiteCache)
	{
		rVsSiteCache.QueryCachedService<IVsOutputWindowPane, SID_SVsGeneralOutputWindowPane>(&m_spIVsOutputWindowPane);
	}

}

	void OutputMessage(const wchar_t* const szMessage)
	{
		VSL_CHECKPOINTER_DEFAULT(szMessage);

		// Write a message on the debug output.
		VSL_TRACE(szMessage);

		EnsureInitialized();

		HRESULT hr = m_spIVsOutputWindowPane->OutputString(szMessage);
		VSL_CHECKHRESULT(hr);
	}

	void OutputMessageWithPreAndPostBarsOfEquals(const wchar_t* const szMessage)
	{
		VSL_CHECKPOINTER_DEFAULT(szMessage);

		// Write a message on the debug output.
		VSL_TRACE(szMessage);

		EnsureInitialized();

		HRESULT hr = m_spIVsOutputWindowPane->OutputString(L" ================================================\n  ");
		if(SUCCEEDED(hr)) 
		{
			hr = m_spIVsOutputWindowPane->OutputString(szMessage);
		}
		if(SUCCEEDED(hr))
		{
			hr = m_spIVsOutputWindowPane->OutputString(L"\n ================================================\n");
		}
		if(FAILED(hr))
		{
			VSL_TRACE(L"Can not write the message on the output window pane.");
			VSL_CREATE_ERROR_HRESULT(hr);
		}
	}

private:

	void EnsureInitialized()
	{
		HRESULT hr = E_NOINTERFACE;
		__if_exists(SiteControl_T::Global)
		{
			if(m_spIVsOutputWindowPane == NULL)
			{
				hr = VsIServiceProviderUtilities<>::QueryCachedService<IVsOutputWindowPane, SID_SVsGeneralOutputWindowPane>(&m_spIVsOutputWindowPane);
			}
		}
		if(m_spIVsOutputWindowPane == NULL)
		{
			// If the output window is not available all we can do is write a message on the debug output
			// and exit.
			VSL_TRACE(L"Can not get the GeneralOutputWindowPane service.");
			VSL_CREATE_ERROR_HRESULT(hr);
		}
	}

	CComPtr<IVsOutputWindowPane> m_spIVsOutputWindowPane;

};

#ifdef __proffserv_h__

// TODO - unit test this
class ProfferServiceUtilities
{
public:

	ProfferServiceUtilities(IProfferService* pIProfferService):
		m_spIProfferService(VSL_CHECKPOINTER_DEFAULT(pIProfferService))
	{
	}

	template <class VsSiteCache_T>
	ProfferServiceUtilities(const VsSiteCache_T& rVsSiteCache)
	{
		HRESULT hr = rVsSiteCache.QueryCachedService<IProfferService, SID_SProfferService>(&m_spIProfferService);
		VSL_CHECKHRESULT(hr);
		VSL_CHECKBOOLEAN(m_spIProfferService != NULL, E_FAIL);
	}

	// Used for services that are not revoked
	// Not revoking services is the typical case
	void ProfferService(REFGUID rguidService, IServiceProvider *pServiceProvider)
	{
		DWORD dwCookie = 0;
		ProfferService(rguidService, pServiceProvider, &dwCookie);
	}

	// Used for services that are revoked
	void ProfferService(REFGUID rguidService, IServiceProvider *pServiceProvider, DWORD* pdwCookie)
	{
		VSL_CHECKPOINTER_DEFAULT(pdwCookie);
		HRESULT hr = m_spIProfferService->ProfferService(rguidService, pServiceProvider, pdwCookie);
		VSL_CHECKHRESULT(hr);
	}

private:

	CComPtr<IProfferService> m_spIProfferService;

};

#endif

template <class SiteControl_T = VsUtilityGlobalSiteControl>
class OleComponentUIManagerUtilities
{

VSL_DECLARE_NOT_COPYABLE(OleComponentUIManagerUtilities)

// This is done, as we can't have two copies of a method under different
// __if_exists (get a multiply defined error if that is tried)
__if_exists(SiteControl_T::Global)
{
// Global version is not instantiable.
private:
}
__if_exists(SiteControl_T::Local)
{
public:
}

	OleComponentUIManagerUtilities()
	{
	}

	~OleComponentUIManagerUtilities()
	{
	}

public:

__if_exists(SiteControl_T::Local) // TODO - Using __if_not_exists(SiteControl_T::Global) here causes and ICE, report to compiler team
{

	OleComponentUIManagerUtilities(IOleComponentUIManager* pIOleComponentUIManager):
		m_spIOleComponentUIManager(VSL_CHECKPOINTER_DEFAULT(pIOleComponentUIManager))
	{
	}

	template <class VsSiteCache_T>
	void SetSite(const VsSiteCache_T& rVsSiteCache)
	{
		rVsSiteCache.QueryCachedService<IOleComponentUIManager, SID_SOleComponentUIManager>(&m_spIOleComponentUIManager);
	}

}

__if_exists(SiteControl_T::Global)
{
	static
}
	LONG ShowMessage(
		_In_ LPOLESTR szTitle, 
		_In_ UINT iMessageID, 
		_In_ OLEMSGBUTTON iButtons = OLEMSGBUTTON_OK, 
		_In_ OLEMSGDEFBUTTON iDefButton = OLEMSGDEFBUTTON_FIRST,
		_In_ OLEMSGICON iIcon = OLEMSGICON_CRITICAL, 
		_In_ BOOL bAlert = FALSE)
	{
		ATL::CStringW strMessage;
		strMessage.LoadString(iMessageID);
		return ShowMessage(
			szTitle,
			static_cast<LPOLESTR>(strMessage.GetBuffer()), 
			iButtons, 
			iDefButton,
			iIcon, 
			bAlert);
	}

__if_exists(SiteControl_T::Global)
{
	static
}
    LONG ShowMessage(
		_In_ LPOLESTR szTitle, 
		_In_ LPOLESTR szMessage, 
		_In_ OLEMSGBUTTON iButtons = OLEMSGBUTTON_OK, 
		_In_ OLEMSGDEFBUTTON iDefButton = OLEMSGDEFBUTTON_FIRST,
		_In_ OLEMSGICON iIcon = OLEMSGICON_CRITICAL, 
		_In_ BOOL bAlert = FALSE)
	{
		EnsureInitialized();
		LONG nResult;
		HRESULT hr = m_spIOleComponentUIManager->ShowMessage(
			OLEROLE_TOPLEVELCOMPONENT,
			GUID_NULL,
			szTitle,
			szMessage,
			NULL,
			NULL,
			iButtons,
			iDefButton,
			iIcon,
			bAlert,
			&nResult);
		VSL_CHECKHRESULT(hr);
		return nResult;
	}

__if_exists(SiteControl_T::Global)
{
	static
}
    void ShowContextMenu( 
        _In_ DWORD dwCompRole,
        _In_ REFCLSID rclsidActive,
        _In_ LONG nMenuId,
        _In_ REFPOINTS pos,
        _In_ IOleCommandTarget *pCmdTrgtActive)
	{
		EnsureInitialized();
		VSL_CHECKHRESULT(m_spIOleComponentUIManager->ShowContextMenu(dwCompRole,
		   rclsidActive,
		   nMenuId,
		   pos,
		   pCmdTrgtActive));
	}

private:


__if_exists(SiteControl_T::Global)
{
	static Functor<void ()>* GetUnsitedFunctor()
	{
		static FunctionPointerFunctor<CallingConventionDefault, void ()> functor(&OnUnsited);
		return &functor;
	}

	static void OnUnsited()
	{
		m_spIOleComponentUIManager.Release();
		VSL_SERVICE_PROVIDER::GetUnsited() -= GetUnsitedFunctor();
	}
}

__if_exists(SiteControl_T::Global)
{
	static
}
	void EnsureInitialized()
	{
		HRESULT hr = E_NOINTERFACE;
		__if_exists(SiteControl_T::Global)
		{
			if(m_spIOleComponentUIManager == NULL)
			{
				hr = VSL_SERVICE_PROVIDER::QueryCachedService<IOleComponentUIManager, SID_SOleComponentUIManager>(&m_spIOleComponentUIManager);
				VSL_CHECKHRESULT(hr);
				// Subscribe to the global service providers Unsited event, so that
				// that static members reference will get released properly.
				VSL_SERVICE_PROVIDER::GetUnsited() += GetUnsitedFunctor();
			}
		}
		if(m_spIOleComponentUIManager == NULL)
		{
			// If the output window is not available all we can do is write a message on the debug output
			// and exit.
			VSL_TRACE(L"Can not get the OleComponentUIManager service.");
			VSL_CREATE_ERROR_HRESULT(hr);
		}
	}

	__if_exists(SiteControl_T::Global)
	{
	static
	}
	CComPtr<IOleComponentUIManager> m_spIOleComponentUIManager;
};

__declspec(selectany) CComPtr<IOleComponentUIManager> OleComponentUIManagerUtilities<>::m_spIOleComponentUIManager;

template <class SiteControl_T = VsUtilityGlobalSiteControl>
class VsUIShellUtilities
{

VSL_DECLARE_NOT_COPYABLE(VsUIShellUtilities)

// This is done, as we can't have two copies of a method under different
// __if_exists (get a multiply defined error if that is tried)
__if_exists(SiteControl_T::Global)
{
// Global version is not instantiable.
private:
}
__if_exists(SiteControl_T::Local)
{
public:
}

	VsUIShellUtilities()
	{
	}

	~VsUIShellUtilities()
	{
	}

public:

__if_exists(SiteControl_T::Local)
{

	VsUIShellUtilities(IVsUIShell* pIVsUIShell):
		m_spIVsUIShell(VSL_CHECKPOINTER_DEFAULT(pIVsUIShell))
	{
	}

	template <class VsSiteCache_T>
	void SetSite(const VsSiteCache_T& rVsSiteCache)
	{
		rVsSiteCache.QueryCachedService<IVsUIShell, SID_SVsUIShell>(&m_spIVsUIShell);
	}

}

__if_exists(SiteControl_T::Global)
{
	static
}
    void FindToolWindow( 
		_In_ VSFINDTOOLWIN grfFTW,
		_In_ REFGUID rguidPersistenceSlot,
		_Out_ IVsWindowFrame **ppWindowFrame)
	{
		EnsureInitialized();
		VSL_CHECKHRESULT(m_spIVsUIShell->FindToolWindow(
			grfFTW,
			rguidPersistenceSlot,
			ppWindowFrame));
	}

__if_exists(SiteControl_T::Global)
{
	static
}
    bool AttemptToFindToolWindow( 
		_In_ VSFINDTOOLWIN grfFTW,
		_In_ REFGUID rguidPersistenceSlot,
		_Out_ IVsWindowFrame **ppWindowFrame)
	{
		EnsureInitialized();
		HRESULT hr = m_spIVsUIShell->FindToolWindow(
			grfFTW,
			rguidPersistenceSlot,
			ppWindowFrame);
		if(SUCCEEDED(hr) && *ppWindowFrame != NULL)
		{
			return true;
		}
		else if(E_FAIL != hr)
		{
			// Anything other then E_FAIL is unexpected
			VSL_CREATE_ERROR_HRESULT(hr);
		}
		return false;
	}

private:


__if_exists(SiteControl_T::Global)
{
	static Functor<void ()>* GetUnsitedFunctor()
	{
		static FunctionPointerFunctor<CallingConventionDefault, void ()> functor(&OnUnsited);
		return &functor;
	}

	static void OnUnsited()
	{
		m_spIVsUIShell.Release();
		VSL_SERVICE_PROVIDER::GetUnsited() -= GetUnsitedFunctor();
	}
}

__if_exists(SiteControl_T::Global)
{
	static
}
	void EnsureInitialized()
	{
		__if_exists(SiteControl_T::Global)
		{
			if(m_spIVsUIShell == NULL)
			{
				m_spIVsUIShell = VSL_SERVICE_PROVIDER::GetCachedService<IVsUIShell, SID_SVsUIShell>();
				// Subscribe to the global service providers Unsited event, so that
				// that static members reference will get released properly.
				VSL_SERVICE_PROVIDER::GetUnsited() += GetUnsitedFunctor();
			}
		}
		if(m_spIVsUIShell == NULL)
		{
			// If the output window is not available all we can do is write a message on the debug output
			// and exit.
			VSL_TRACE(L"Can not get the VsUIShell service.");
			VSL_CREATE_ERROR_HRESULT(E_UNEXPECTED);
		}
	}

	__if_exists(SiteControl_T::Global)
	{
	static
	}
	CComPtr<IVsUIShell> m_spIVsUIShell;
};

__declspec(selectany) CComPtr<IVsUIShell> VsUIShellUtilities<>::m_spIVsUIShell;

} // namespace VSL

#endif // VSLPACKAGE_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockBuildManager.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef BUILDMANAGER_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define BUILDMANAGER_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "vslangproj.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class BuildManagerNotImpl :
	public BuildManager
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(BuildManagerNotImpl)

public:

	typedef BuildManager Interface;

	STDMETHOD(get_DTE)(
		/*[out,retval]*/ DTE** /*ppDTE*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_Parent)(
		/*[out,retval]*/ IDispatch** /*ppdispParent*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_ContainingProject)(
		/*[out,retval]*/ Project** /*ppProject*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_DesignTimeOutputMonikers)(
		/*[out,retval]*/ VARIANT* /*pvarMonikers*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(BuildDesignTimeOutput)(
		/*[in]*/ BSTR /*bstrOutputMoniker*/,
		/*[out,retval]*/ BSTR* /*pbstrXMLFormat*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetTypeInfoCount)(
		/*[out]*/ UINT* /*pctinfo*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetTypeInfo)(
		/*[in]*/ UINT /*iTInfo*/,
		/*[in]*/ LCID /*lcid*/,
		/*[out]*/ ITypeInfo** /*ppTInfo*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetIDsOfNames)(
		/*[in]*/ REFIID /*riid*/,
		/*[in,size_is(cNames)]*/ LPOLESTR* /*rgszNames*/,
		/*[in]*/ UINT /*cNames*/,
		/*[in]*/ LCID /*lcid*/,
		/*[out,size_is(cNames)]*/ DISPID* /*rgDispId*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(Invoke)(
		/*[in]*/ DISPID /*dispIdMember*/,
		/*[in]*/ REFIID /*riid*/,
		/*[in]*/ LCID /*lcid*/,
		/*[in]*/ WORD /*wFlags*/,
		/*[in,out]*/ DISPPARAMS* /*pDispParams*/,
		/*[out]*/ VARIANT* /*pVarResult*/,
		/*[out]*/ EXCEPINFO* /*pExcepInfo*/,
		/*[out]*/ UINT* /*puArgErr*/)VSL_STDMETHOD_NOTIMPL
};

class BuildManagerMockImpl :
	public BuildManager,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(BuildManagerMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(BuildManagerMockImpl)

	typedef BuildManager Interface;
	struct get_DTEValidValues
	{
		/*[out,retval]*/ DTE** ppDTE;
		HRESULT retValue;
	};

	STDMETHOD(get_DTE)(
		/*[out,retval]*/ DTE** ppDTE)
	{
		VSL_DEFINE_MOCK_METHOD(get_DTE)

		VSL_SET_VALIDVALUE(ppDTE);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_ParentValidValues
	{
		/*[out,retval]*/ IDispatch** ppdispParent;
		HRESULT retValue;
	};

	STDMETHOD(get_Parent)(
		/*[out,retval]*/ IDispatch** ppdispParent)
	{
		VSL_DEFINE_MOCK_METHOD(get_Parent)

		VSL_SET_VALIDVALUE_INTERFACE(ppdispParent);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_ContainingProjectValidValues
	{
		/*[out,retval]*/ Project** ppProject;
		HRESULT retValue;
	};

	STDMETHOD(get_ContainingProject)(
		/*[out,retval]*/ Project** ppProject)
	{
		VSL_DEFINE_MOCK_METHOD(get_ContainingProject)

		VSL_SET_VALIDVALUE(ppProject);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_DesignTimeOutputMonikersValidValues
	{
		/*[out,retval]*/ VARIANT* pvarMonikers;
		HRESULT retValue;
	};

	STDMETHOD(get_DesignTimeOutputMonikers)(
		/*[out,retval]*/ VARIANT* pvarMonikers)
	{
		VSL_DEFINE_MOCK_METHOD(get_DesignTimeOutputMonikers)

		VSL_SET_VALIDVALUE_VARIANT(pvarMonikers);

		VSL_RETURN_VALIDVALUES();
	}
	struct BuildDesignTimeOutputValidValues
	{
		/*[in]*/ BSTR bstrOutputMoniker;
		/*[out,retval]*/ BSTR* pbstrXMLFormat;
		HRESULT retValue;
	};

	STDMETHOD(BuildDesignTimeOutput)(
		/*[in]*/ BSTR bstrOutputMoniker,
		/*[out,retval]*/ BSTR* pbstrXMLFormat)
	{
		VSL_DEFINE_MOCK_METHOD(BuildDesignTimeOutput)

		VSL_CHECK_VALIDVALUE_BSTR(bstrOutputMoniker);

		VSL_SET_VALIDVALUE_BSTR(pbstrXMLFormat);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetTypeInfoCountValidValues
	{
		/*[out]*/ UINT* pctinfo;
		HRESULT retValue;
	};

	STDMETHOD(GetTypeInfoCount)(
		/*[out]*/ UINT* pctinfo)
	{
		VSL_DEFINE_MOCK_METHOD(GetTypeInfoCount)

		VSL_SET_VALIDVALUE(pctinfo);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetTypeInfoValidValues
	{
		/*[in]*/ UINT iTInfo;
		/*[in]*/ LCID lcid;
		/*[out]*/ ITypeInfo** ppTInfo;
		HRESULT retValue;
	};

	STDMETHOD(GetTypeInfo)(
		/*[in]*/ UINT iTInfo,
		/*[in]*/ LCID lcid,
		/*[out]*/ ITypeInfo** ppTInfo)
	{
		VSL_DEFINE_MOCK_METHOD(GetTypeInfo)

		VSL_CHECK_VALIDVALUE(iTInfo);

		VSL_CHECK_VALIDVALUE(lcid);

		VSL_SET_VALIDVALUE_INTERFACE(ppTInfo);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetIDsOfNamesValidValues
	{
		/*[in]*/ REFIID riid;
		/*[in,size_is(cNames)]*/ LPOLESTR* rgszNames;
		/*[in]*/ UINT cNames;
		/*[in]*/ LCID lcid;
		/*[out,size_is(cNames)]*/ DISPID* rgDispId;
		HRESULT retValue;
	};

	STDMETHOD(GetIDsOfNames)(
		/*[in]*/ REFIID riid,
		/*[in,size_is(cNames)]*/ LPOLESTR* rgszNames,
		/*[in]*/ UINT cNames,
		/*[in]*/ LCID lcid,
		/*[out,size_is(cNames)]*/ DISPID* rgDispId)
	{
		VSL_DEFINE_MOCK_METHOD(GetIDsOfNames)

		VSL_CHECK_VALIDVALUE(riid);

		VSL_CHECK_VALIDVALUE_MEMCMP(rgszNames, cNames*sizeof(rgszNames[0]), validValues.cNames*sizeof(validValues.rgszNames[0]));

		VSL_CHECK_VALIDVALUE(cNames);

		VSL_CHECK_VALIDVALUE(lcid);

		VSL_SET_VALIDVALUE_MEMCPY(rgDispId, cNames*sizeof(rgDispId[0]), validValues.cNames*sizeof(validValues.rgDispId[0]));

		VSL_RETURN_VALIDVALUES();
	}
	struct InvokeValidValues
	{
		/*[in]*/ DISPID dispIdMember;
		/*[in]*/ REFIID riid;
		/*[in]*/ LCID lcid;
		/*[in]*/ WORD wFlags;
		/*[in,out]*/ DISPPARAMS* pDispParams;
		/*[out]*/ VARIANT* pVarResult;
		/*[out]*/ EXCEPINFO* pExcepInfo;
		/*[out]*/ UINT* puArgErr;
		HRESULT retValue;
	};

	STDMETHOD(Invoke)(
		/*[in]*/ DISPID dispIdMember,
		/*[in]*/ REFIID riid,
		/*[in]*/ LCID lcid,
		/*[in]*/ WORD wFlags,
		/*[in,out]*/ DISPPARAMS* pDispParams,
		/*[out]*/ VARIANT* pVarResult,
		/*[out]*/ EXCEPINFO* pExcepInfo,
		/*[out]*/ UINT* puArgErr)
	{
		VSL_DEFINE_MOCK_METHOD(Invoke)

		VSL_CHECK_VALIDVALUE(dispIdMember);

		VSL_CHECK_VALIDVALUE(riid);

		VSL_CHECK_VALIDVALUE(lcid);

		VSL_CHECK_VALIDVALUE(wFlags);

		VSL_SET_VALIDVALUE(pDispParams);

		VSL_SET_VALIDVALUE_VARIANT(pVarResult);

		VSL_SET_VALIDVALUE(pExcepInfo);

		VSL_SET_VALIDVALUE(puArgErr);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // BUILDMANAGER_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockAsyncIUnknown.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef ASYNCIUNKNOWN_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define ASYNCIUNKNOWN_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "Unknwn.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class AsyncIUnknownNotImpl :
	public AsyncIUnknown
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(AsyncIUnknownNotImpl)

public:

	typedef AsyncIUnknown Interface;

	STDMETHOD(Begin_QueryInterface)(
		/*[in]*/ REFIID /*riid*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(Finish_QueryInterface)(
		/*[out]*/ void** /*ppvObject*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(Begin_AddRef)()VSL_STDMETHOD_NOTIMPL

	virtual ULONG STDMETHODCALLTYPE Finish_AddRef(){ return ULONG(); }

	STDMETHOD(Begin_Release)()VSL_STDMETHOD_NOTIMPL

	virtual ULONG STDMETHODCALLTYPE Finish_Release(){ return ULONG(); }
};

class AsyncIUnknownMockImpl :
	public AsyncIUnknown,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(AsyncIUnknownMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(AsyncIUnknownMockImpl)

	typedef AsyncIUnknown Interface;
	struct Begin_QueryInterfaceValidValues
	{
		/*[in]*/ REFIID riid;
		HRESULT retValue;
	};

	STDMETHOD(Begin_QueryInterface)(
		/*[in]*/ REFIID riid)
	{
		VSL_DEFINE_MOCK_METHOD(Begin_QueryInterface)

		VSL_CHECK_VALIDVALUE(riid);

		VSL_RETURN_VALIDVALUES();
	}
	struct Finish_QueryInterfaceValidValues
	{
		/*[out]*/ void** ppvObject;
		HRESULT retValue;
	};

	STDMETHOD(Finish_QueryInterface)(
		/*[out]*/ void** ppvObject)
	{
		VSL_DEFINE_MOCK_METHOD(Finish_QueryInterface)

		VSL_SET_VALIDVALUE(ppvObject);

		VSL_RETURN_VALIDVALUES();
	}
	struct Begin_AddRefValidValues
	{
		HRESULT retValue;
	};

	STDMETHOD(Begin_AddRef)()
	{
		VSL_DEFINE_MOCK_METHOD_NOARGS(Begin_AddRef)

		VSL_RETURN_VALIDVALUES();
	}
	struct Finish_AddRefValidValues
	{
		ULONG retValue;
	};

	virtual ULONG _stdcall Finish_AddRef()
	{
		VSL_DEFINE_MOCK_METHOD_NOARGS(Finish_AddRef)

		VSL_RETURN_VALIDVALUES();
	}
	struct Begin_ReleaseValidValues
	{
		HRESULT retValue;
	};

	STDMETHOD(Begin_Release)()
	{
		VSL_DEFINE_MOCK_METHOD_NOARGS(Begin_Release)

		VSL_RETURN_VALIDVALUES();
	}
	struct Finish_ReleaseValidValues
	{
		ULONG retValue;
	};

	virtual ULONG _stdcall Finish_Release()
	{
		VSL_DEFINE_MOCK_METHOD_NOARGS(Finish_Release)

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // ASYNCIUNKNOWN_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\Include\VSLWindows.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef VSLWINDOWS_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define VSLWINDOWS_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include <VSL.h>
#include <VSLVsSite.h>
#include <VSLContainers.h>

namespace VSL
{

// REVIEW - determine if there is a good way to unit test this
template <class Parent_T = ATL::CWindow>
class Window :
	public Parent_T
{

VSL_DECLARE_NOT_COPYABLE(Window)

public:

	Window():
		Parent()
	{
	}

	Window(const ATL::CWindow& rWindow):
		Parent(rWindow)
	{
	}

	virtual ~Window() {}

	typedef Parent_T Parent;

	HWND& GetHWND()
	{
		return m_hWnd;
	}

	void CreateDialogParam(
		HINSTANCE hInstance,
		LPCTSTR lpTemplateName,
		HWND hWndParent,
		DLGPROC lpDialogFunc,
		LPARAM dwInitParam)
	{
		GetHWND() = ::CreateDialogParam(
				hInstance, 
				lpTemplateName, 
				hWndParent, 
				lpDialogFunc, 
				dwInitParam);
		VSL_CHECKHANDLE_GLE(GetHWND());
	}

	template<class WPARAM_T, class LPARAM_T>
	LRESULT SendMessage(UINT uMsg, WPARAM_T wParam, LPARAM_T lParam) const throw()
	{
		// cast away constness, since ATL::CWindow doesn't have a const SendMessage method
		return const_cast<Parent_T*>(static_cast<const Parent_T*>(this))->
			// C-style casts used here as they can function as both static_cast and reinterpret_cast
			SendMessage(uMsg, (WPARAM)wParam, (LPARAM)lParam);
	}

	LRESULT CallWindowProc(
		_In_ WNDPROC pWndProc,
		_In_ UINT msg,
		_In_ WPARAM wParam,
		_In_ LPARAM lParam)
	{
		return ::CallWindowProc(pWndProc, m_hWnd, msg, wParam, lParam);
	}

	static HWND GetActiveWindow()
	{
		return ::GetActiveWindow();
	}
};

class Cursor
{
VSL_DECLARE_NOT_COPYABLE(Cursor)

private:

	// FUTURE - could add default construction, not needed currently
	Cursor();

public:

	Cursor(_In_ LPWSTR szCursorName, HINSTANCE hInstance = NULL):
		m_hCursor(static_cast<HCURSOR>(VSL_CHECKHANDLE_GLE(::LoadCursor(hInstance, szCursorName))))
	{
	}

	~Cursor()
	{
		BOOL bDestroyed = ::DestroyCursor(m_hCursor);
		VSL_ASSERT(bDestroyed != FALSE); // paranoid, this should never fire
		(bDestroyed);
	}

	HCURSOR Activate()
	{
		return ::SetCursor(m_hCursor);
	}

private:
	HCURSOR m_hCursor;
};

// TODO - 2/21/2006 - move this someplace else
class Keyboard
{

VSL_DECLARE_NONINSTANTIABLE_CLASS(Keyboard)

public:

	static bool IsKeyDown(_In_ int nVirtKey)
	{
		return (::GetKeyState(nVirtKey) & 0x8000 ? true : false);
	}
};

template <
	class Derived_T,
	class PackageVsSiteCache_T = IVsPackageImplDefaults<>::VsSiteCache,
	// This must not be a global cache, as the site is window specific
	class VsSiteCache_T = VsSiteCacheLocal> 
class ToolWindowBase
{

VSL_DECLARE_NOT_COPYABLE(ToolWindowBase)

private:

	// No default construction, rPackageVsSiteCache must be provided.
	ToolWindowBase();

protected:

	// Since this is not virtual, classes with access should not cast to a pointer of this
	// type and call delete on it
	~ToolWindowBase() {}

public:

	typedef VsSiteCache_T VsSiteCache;
	typedef PackageVsSiteCache_T PackageVsSiteCache;

	// FUTURE - rPackageVsSiteCache may be removed
	ToolWindowBase(const PackageVsSiteCache& rPackageVsSiteCache) :
		m_spIVsWindowFrame(),
		m_VsSiteCache(),
		m_rPackageVsSiteCache(rPackageVsSiteCache)
	{
		C_ASSERT(!VsSiteCache_T::IServiceProviderCache::bIsGlobal);
	}

	bool HasBeenCreated() const
	{
		return m_spIVsWindowFrame != NULL;
	}

	void Show(bool bActivate = GetShowActivateDefault())
	{
		VSL_CHECKBOOLEAN(HasBeenCreated(), E_UNEXPECTED);

		InternalShow(bActivate);
	}

	// FUTURE - rPackageVsSiteCache may be added as a parameter
	bool Create()
	{
		VSL_CHECKBOOLEAN(!HasBeenCreated(), E_UNEXPECTED);

		CComPtr<IVsUIShell> spIVsUIShell = m_rPackageVsSiteCache.GetCachedService<IVsUIShell, SID_SVsUIShell>();
		Derived_T& rDerived = *(static_cast<Derived_T*>(this));

		__if_exists(Derived_T::PreCreate)
		{
			rDerived.PreCreate();
		}

		DWORD dwInstanceId = 0;
		__if_exists(Derived_T::GetInstanceID)
		{
			dwInstanceId = rDerived.GetInstanceID();
		}

		// TODO - 1/18/2006 - add Derived_T::CreateViewObject, with precedence over
		// GetViewObject.  GetViewObject returns a pointer to a member pointer.
		// CreateViewObject set the incoming value to an AddRef'ed pointer.
		// GetViewObject should be callable more then once.  Have UIEventsToolWindow
		// provide CreateViewObject rather then GetViewObject, as the later does
		// not need a reference to the view object for itself.

		IUnknown* pViewObject = NULL;
		__if_exists(Derived_T::GetViewObject)
		{
			__if_exists(Derived_T::GetLocalRegistryCLSIDViewObject)
			{
				// Can't speceify both an object and a clsid
				C_ASSERT(0);
			}
			pViewObject = rDerived.GetViewObject();
		}

		const IID* pLocalRegistryCLSIDViewObject = &GUID_NULL;
		__if_exists(Derived_T::GetLocalRegistryCLSIDViewObject)
		{
			__if_exists(Derived_T::GetViewObject)
			{
				// Can't speceify both an object and a clsid
				C_ASSERT(0);
			}
			pLocalRegistryCLSIDViewObject = &(rDerived.GetLocalRegistryCLSIDViewObject());
			VSL_CHECKBOOLEAN(pLocalRegistryCLSIDViewObject != NULL, E_UNEXPECTED);
		}

		IServiceProvider* pToolWindowServiceProvider = NULL;
		__if_exists(Derived_T::GetToolWindowServiceProvider)
		{
			pToolWindowServiceProvider = rDerived.GetToolWindowServiceProvider();
		}

		BOOL bDefaultPosition = TRUE;

		HRESULT hr = spIVsUIShell->CreateToolWindow(
			rDerived.GetCreationFlags(), 
			dwInstanceId, 
			pViewObject, 
			*pLocalRegistryCLSIDViewObject, 
			rDerived.GetToolWindowGuid(),
			GUID_NULL,
			pToolWindowServiceProvider,
			rDerived.GetCaption(),
			&bDefaultPosition,
			&m_spIVsWindowFrame);

		VSL_CHECKHRESULT(hr);

		CComVariant varServiceProvider;
		VSL_CHECKHRESULT(m_spIVsWindowFrame->GetProperty(VSFPROPID_SPFrame, &varServiceProvider));
		VSL_CHECKBOOLEAN(varServiceProvider.vt == ::VT_UNKNOWN, E_FAIL);
		CComQIPtr<IServiceProvider> spIServiceProvider = varServiceProvider.punkVal;
		VSL_CHECKBOOLEAN(spIServiceProvider != NULL, E_FAIL);
		m_VsSiteCache.SetSite(spIServiceProvider);

		__if_exists(Derived_T::PostCreate)
		{
			rDerived.PostCreate();
		}

		return static_cast<bool>(bDefaultPosition);
	}

	void CreateAndShow(bool bActivate = GetShowActivateDefault())
	{
		if(!HasBeenCreated())
		{
			Create();
		}

		InternalShow(bActivate);
	}

	const VsSiteCache& GetVsSiteCache() const
	{
		return m_VsSiteCache;
	}

	const PackageVsSiteCache& GetPackageVsSiteCache() const
	{
		return m_rPackageVsSiteCache;
	}

protected:

	IVsWindowFrame* GetIVsWindowFrame() const
	{
		return m_spIVsWindowFrame;
	}

private:
	static bool GetShowActivateDefault()
	{
		return true;
	}

	void InternalShow(bool bActivate)
	{
		Derived_T& rDerived = *(static_cast<Derived_T*>(this));
		(rDerived); // quite compiler warning

		__if_exists(Derived_T::PreShow)
		{
			rDerived.PreShow(bActivate);
		}

		if(bActivate)
		{
			VSL_CHECKHRESULT(m_spIVsWindowFrame->Show());
		}
		else
		{
			VSL_CHECKHRESULT(m_spIVsWindowFrame->ShowNoActivate());
		}

		__if_exists(Derived_T::PostShow)
		{
			rDerived.PostShow(bActivate);
		}
	}

	CComPtr<IVsWindowFrame> m_spIVsWindowFrame;
	VsSiteCache m_VsSiteCache;
	// REVIEW - if nothing besides Create ends up using this, remove this and just pass IVsUIShell 
	// to Create and CreateAndShow
	const PackageVsSiteCache& m_rPackageVsSiteCache;
};

template <class Derived_T>
class VsWindowFrameEventSink :
	public IVsWindowFrameNotify,
	public IVsWindowFrameNotify3
{

VSL_DECLARE_NOT_COPYABLE(VsWindowFrameEventSink)

protected:
	VsWindowFrameEventSink() :
		m_spFrame(NULL),
		m_cookie(0)
	{
	}

	virtual ~VsWindowFrameEventSink()
	{
		Unadvise();
	}

public:

	template <class VsSiteCache_T>
	void SetSite(const VsSiteCache_T& rVsSiteCache)
	{
		Unadvise();
		VSL_CHECKHRESULT(rVsSiteCache.QueryService(SID_SVsWindowFrame, &m_spFrame));
		VSL_CHECKHRESULT(m_spFrame->Advise(static_cast<IVsWindowFrameNotify*>(this), &m_cookie));
	}

	// The OnShow method is the same for the two notify interfaces.
	STDMETHOD(OnShow)(FRAMESHOW2 fShow)
	{
		VSL_STDMETHODTRY{

		(fShow); // quite compiler warning
		__if_exists(Derived_T::OnFrameShow)
		{
			static_cast<Derived_T*>(this)->OnFrameShow(fShow);
		}

		}VSL_STDMETHODCATCH()

		return VSL_GET_STDMETHOD_HRESULT();
	}

	// Old version of the interface; the shell should detect that this object
	// implements IVsFrameNotify3 and never call this method.
	STDMETHOD(OnMove)()
	{
		VSL_TRACE(_T("IVsWindowFrameNotify::OnMove is not implemented\n"));

		return E_NOTIMPL;
	}

	// This is the new version (IVsFrameNotify3) of the OnMove event.
	STDMETHOD(OnMove)(int x, int y, int w, int h)
	{
		VSL_STDMETHODTRY{

		(x, y, w, h); // quite compiler warning
		__if_exists(Derived_T::OnFrameMove)
		{
			static_cast<Derived_T*>(this)->OnFrameMove(x, y, w, h);
		}

		}VSL_STDMETHODCATCH()

		return VSL_GET_STDMETHOD_HRESULT();
	}

	// Old version of the interface; the shell should detect that this object
	// implements IVsFrameNotify3 and never call this method.
	STDMETHOD(OnSize)()
	{
		VSL_TRACE(_T("IVsWindowFrameNotify::OnSize is not implemented\n"));

		return E_NOTIMPL;
	}

	// This is the new version (IVsFrameNotify3) of the OnSize event.
	STDMETHOD(OnSize)(int x, int y, int w, int h)
	{
		VSL_STDMETHODTRY{

		(x, y, w, h); // quite compiler warning
		__if_exists(Derived_T::OnFrameSize)
		{
			static_cast<Derived_T*>(this)->OnFrameSize(x, y, w, h);
		}

		}VSL_STDMETHODCATCH()

		return VSL_GET_STDMETHOD_HRESULT();
	}

	// Old version of the interface; the shell should detect that this object
	// implements IVsFrameNotify3 and never call this method.
	STDMETHOD(OnDockableChange)(BOOL /*fDockable*/)
	{
		VSL_TRACE(_T("IVsWindowFrameNotify::OnDockableChange is not implemented\n"));

		return E_NOTIMPL;
	}

	// This is the new version (IVsFrameNotify3) of the OnDockableChange event.
	STDMETHOD(OnDockableChange)(BOOL fDockable, int x, int y, int w, int h)
	{
		VSL_STDMETHODTRY{

		(fDockable, x, y, w, h); // quite compiler warning
		__if_exists(Derived_T::OnFrameDockableChange)
		{
			static_cast<Derived_T*>(this)->OnFrameDockableChange(fDockable, x, y, w, h);
		}

		}VSL_STDMETHODCATCH()

		return VSL_GET_STDMETHOD_HRESULT();
	}

	STDMETHOD(OnClose)(FRAMECLOSE *pgrfSaveOptions)
	{
		VSL_STDMETHODTRY{

		(pgrfSaveOptions);  // quite compiler warning
		__if_exists(Derived_T::OnFrameClose)
		{
			static_cast<Derived_T*>(this)->OnFrameClose(pgrfSaveOptions);
		}

		// If the frame is closing this sink have to remove itself from the list of
		// notification interfaces.
		Unadvise();

		}VSL_STDMETHODCATCH()

		return VSL_GET_STDMETHOD_HRESULT();
	}

private:
	void Unadvise()
	{
		if(m_spFrame && (0 != m_cookie))
		{
			m_spFrame->Unadvise(m_cookie);
		}
		m_spFrame.Release();
		m_cookie = 0;
	}

	CComPtr<IVsWindowFrame2> m_spFrame;
	VSCOOKIE m_cookie;
};

// TODO - unit test this
template<class Derived_T, class VsSiteCache_T = VsSiteCacheLocal>
class IVsWindowPaneImpl :
	public IVsWindowPane
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsWindowPaneImpl)

protected:

	typedef VsSiteCache_T VsSiteCache;

public:

	STDMETHOD(SetSite)(IServiceProvider* pSP)
	{
		VSL_STDMETHODTRY{

		IVsPackageEnums::SetSiteResult result = m_VsSiteCache.SetSite(pSP);
		(result); // Quite compiler warning

		__if_exists(Derived_T::PostSited)
		{
			if(result == IVsPackageEnums::Cached || result == IVsPackageEnums::AlreadyCached)
			{
				static_cast<Derived_T*>(this)->PostSited(result);
			}
		}

		}VSL_STDMETHODCATCH()

		return VSL_GET_STDMETHOD_HRESULT();
	}

	STDMETHOD(GetDefaultSize)(SIZE* /*psize*/)
	{
		return E_NOTIMPL;
	}

	STDMETHOD(ClosePane)()
	{
		return S_OK;
	}

	STDMETHOD(LoadViewState)(IStream* /*pstream*/)
	{
		return E_NOTIMPL;
	}

	STDMETHOD(SaveViewState)(IStream* /*pstream*/)
	{
		return E_NOTIMPL;
	}

	STDMETHOD(TranslateAccelerator)(LPMSG /*lpmsg*/)
	{
		// This tells Visual Studio to process the message itself
		// Failing to return S_FALSE for unhandled message will
		// result in Visual Stuio becoming unresponsive
		return S_FALSE;
	}

	const VsSiteCache& GetVsSiteCache() const
	{
		return m_VsSiteCache;
	}

protected:

	VsSiteCache m_VsSiteCache;
};


template <WORD DialogResource_T>
class Dialog : public ATL::CDialogImpl<Dialog<DialogResource_T> >
{
public:
	enum { IDD = DialogResource_T };

	BEGIN_MSG_MAP(Dialog)
	END_MSG_MAP()
};


// Base implementation for tool window pane
template<class Derived_T, WORD DialogResource_T, class Window_T = Window<VSL::Dialog<DialogResource_T> >, class IVsWindowPaneImpl_T = IVsWindowPaneImpl<Derived_T> >
class VsWindowPaneFromResource :
	public IVsWindowPaneImpl_T,
	public Window_T
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(VsWindowPaneFromResource)

public:

	STDMETHOD(CreatePaneWindow)(HWND hwndParent, int x, int y, int cx, int cy, HWND *phwnd)
	{
		VSL_STDMETHODTRY{

		VSL_CHECKPOINTER_DEFAULT(phwnd);

		*phwnd = NULL;

		Derived_T& rDerived = *(static_cast<Derived_T*>(this));
		(rDerived);

		LPARAM initParam = NULL;
		__if_exists(Derived_T::GetDialogInitParam)
		{
			initParam = rDerived.GetDialogInitParam();
		}

		Window_T::Create(hwndParent, initParam);
		VSL_CHECKBOOL_GLE(NULL != GetHWND());

		// REVIEW - test if the message was actually processed?
		MoveWindow(x, y, cx, cy, TRUE);
		ShowWindow(SW_SHOW);

		*phwnd = GetHWND();

		}VSL_STDMETHODCATCH()

		return VSL_GET_STDMETHOD_HRESULT();
	}

	STDMETHOD(TranslateAccelerator)(LPMSG lpmsg)
	{
		VSL_STDMETHODTRY{

		VSL_CHECKBOOLEAN(NULL != GetHWND(), E_UNEXPECTED);

		// Check if the shell can process this message.
		CComPtr<IVsUIShell> spUiShell = m_VsSiteCache.GetCachedService<IVsUIShell, SID_SVsUIShell>();
		VSL_CHECKBOOLEAN(spUiShell != NULL, E_UNEXPECTED);
		HRESULT hr = spUiShell->TranslateAcceleratorAsACmd(lpmsg);
		VSL_CHECKHRESULT(hr);

		// The shell will return S_OK if it has proccessed the message, S_FALSE otherwise.
		if(S_OK != hr)
		{
			// If this is a dialog message, then we can handle it.
			VSL_SET_STDMETHOD_HRESULT(IsDialogMessage(lpmsg) ? S_OK : S_FALSE);
		}

		}VSL_STDMETHODCATCH()

		return VSL_GET_STDMETHOD_HRESULT();
	}

};

// TODO - unit test this
template <class Derived_T, bool bSingleSelection_T = true, class DerivedForVsSiteCache_T = Derived_T>
class ISelectionContainerImpl :
	public ISelectionContainer
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(ISelectionContainerImpl)

public:

	STDMETHOD(CountObjects)(DWORD dwFlags, ULONG *pCount)
	{
		VSL_STDMETHODTRY{

		VSL_CHECKPOINTER_DEFAULT(pCount);

		if(dwFlags & GETOBJS_ALL)
		{
			*pCount = static_cast<ULONG>(GetDerived()->GetItemsContainer().size());
		}
		else if(dwFlags & GETOBJS_SELECTED)
		{
			const Derived_T::ItemsContainer& rContainer = GetDerived()->GetItemsContainer();

			ULONG i = 0;

			for(Derived_T::ItemsContainer::const_iterator item = rContainer.begin(); 
				item < rContainer.end();
				++item)
			{
				if((*item)->GetCppClass().IsSelected())
				{
					++i;
				}
			}

			*pCount = i;
		}
		else
		{
			VSL_SET_STDMETHOD_HRESULT(E_INVALIDARG);
		}

		}VSL_STDMETHODCATCH()

		return VSL_GET_STDMETHOD_HRESULT();
	}
    
	STDMETHOD(GetObjects)(DWORD dwFlags, ULONG cObjects, IUnknown **pUnknown)
	{
		VSL_STDMETHODTRY_EX(E_FAIL){

		VSL_CHECKPOINTER_DEFAULT(pUnknown);

		if(dwFlags & GETOBJS_ALL)
		{
			EnsureRequestInRange(cObjects);

			const Derived_T::ItemsContainer& rContainer = GetDerived()->GetItemsContainer();

			Derived_T::ItemsContainer::const_iterator item = rContainer.begin();

			for(unsigned int i = 0; 
				item < rContainer.end() && i < cObjects;
				++item, ++i)
			{
				CComPtr<IUnknown> spIUnknown;
				VSL_CHECKHRESULT((*item).QueryInterface(&spIUnknown));
				pUnknown[i] = spIUnknown.Detach();
			}

			return S_OK;
		}
		else if(dwFlags & GETOBJS_SELECTED)
		{
			const Derived_T::ItemsContainer& rContainer = GetDerived()->GetItemsContainer();

			for(Derived_T::ItemsContainer::const_iterator item = rContainer.begin(); 
				item < rContainer.end();
				++item)
			{
				if((*item)->GetCppClass().IsSelected())
				{
					CComPtr<IUnknown> spIUnknown;
					VSL_CHECKHRESULT((*item).QueryInterface(&spIUnknown));
					if(bSingleSelection_T)
					{
						EnsureRequestIsOne(cObjects);
						*pUnknown = spIUnknown.Detach();
						return S_OK;
					}
					else
					{
						C_ASSERT(bSingleSelection_T); // FUTURE - support multi-selection
					}
				}
			}
		}
		else
		{
			VSL_SET_STDMETHOD_HRESULT(E_INVALIDARG);
		}

		}VSL_STDMETHODCATCH()

		return VSL_GET_STDMETHOD_HRESULT();
	}
    

	STDMETHOD(SelectObjects)(ULONG cSelect, IUnknown** apUnkSelect, DWORD dwFlags)
	{
        // This container can handle only one selected object out of a list of one selectable
        // objects, so all this method have to do is to check that the user is selecting
        // the only element in this container.
		VSL_STDMETHODTRY{

		VSL_CHECKPOINTER_DEFAULT(apUnkSelect);

		if(bSingleSelection_T)
		{
			EnsureRequestIsOne(cSelect);
			GetDerived()->SelectItem(*apUnkSelect);
		}
		else
		{
			EnsureRequestInRange(cSelect);
			C_ASSERT(bSingleSelection_T); // FUTURE - support multi-selection
		}

		if(dwFlags & SELOBJS_ACTIVATE_WINDOW)
		{
			CComPtr<IVsWindowFrame> spFrame;
			VSL_CHECKHRESULT(GetDerivedForVsSiteCache()->GetVsSiteCache().QueryService(SID_SVsWindowFrame, &spFrame));
			VSL_CHECKHRESULT(spFrame->Show());
		}

        }VSL_STDMETHODCATCH()

		return VSL_GET_STDMETHOD_HRESULT();
	}

public:
	void FireSelectionChange()
	{
		// In order to get to the STrackSelection service provider, we have to get the 
		// service provider the window was sited with, as selection traction is per window
		// and is not global, so it can't be done through the site provide to the package.
		CComPtr<ITrackSelection> spITrackSelection;
		HRESULT hr = GetDerivedForVsSiteCache()->GetVsSiteCache().QueryCachedService<ITrackSelection, SID_STrackSelection>(&spITrackSelection);
		VSL_CHECKHRESULT(hr);
		VSL_CHECKBOOLEAN(spITrackSelection != NULL, E_FAIL); // paranoid

		hr = spITrackSelection->OnSelectChange(this);
		VSL_CHECKHRESULT(hr);
	}

private:

	void EnsureRequestInRange(ULONG iRequested)
	{
		VSL_CHECKBOOLEAN(iRequested != 0 && iRequested <= GetDerived()->GetItemsContainer().size(), E_INVALIDARG);
	}

	void EnsureRequestIsOne(ULONG iRequested)
	{
		VSL_CHECKBOOLEAN(iRequested == 1, E_INVALIDARG);
	}

	Derived_T* GetDerived()
	{
		return static_cast<Derived_T*>(this);
	}

	DerivedForVsSiteCache_T* GetDerivedForVsSiteCache()
	{
		return static_cast<DerivedForVsSiteCache_T*>(this);
	}
};

template <class IDispatchInterface_T>
class IDispatchInterfaceToVsSelectionConainterItemAdapter
{

VSL_DECLARE_NOT_COPYABLE(IDispatchInterfaceToVsSelectionConainterItemAdapter)

public:

	IDispatchInterfaceToVsSelectionConainterItemAdapter()
	{
	}

	// Compiler generated destructor is sufficient

	IDispatchInterfaceToVsSelectionConainterItemAdapter& operator=(const CComPtr<IDispatchInterface_T>& rspToCopy)
	{
		m_spInterface = rspToCopy;
		return *this;
	}

	const IDispatchInterfaceToVsSelectionConainterItemAdapter* operator->() const
	{
		return this;
	}
	
	const IDispatchInterfaceToVsSelectionConainterItemAdapter& GetCppClass() const
	{
		return *this;
	}

	bool IsSelected() const
	{
		return true;
	}

	template <class Q>
	HRESULT QueryInterface(_Out_ Q** pp) const throw()
	{
		return m_spInterface.QueryInterface(pp);
	}

private:

	CComPtr<IDispatchInterface_T> m_spInterface;
};

template <class Derived_T, class IDispatchInterface_T>
class ISelectionContainerSingleItemImpl :
	public ISelectionContainerImpl<ISelectionContainerSingleItemImpl<Derived_T, IDispatchInterface_T>, true, Derived_T>
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(ISelectionContainerSingleItemImpl)

public:
	typedef VSL::StaticArray<IDispatchInterfaceToVsSelectionConainterItemAdapter<IDispatchInterface_T>, 1> ItemsContainer;

	// Called by ISelectionContainer::CountObjects and ISelectionContainer::GetObjects 
	// implemented by VSL::ISelectionContainerImpl
	ItemsContainer& GetItemsContainer()
	{
		return m_SelectionItemContainer;
	}

	// Called by ISelectionContainer::SelectObjects implemented on VSL::ISelectionContainerImpl 
	void SelectItem(IUnknown* /*apUnkSelect*/)
	{
		// Nothing to do, there is just one item, and it's always selected.
	}

private:

	ItemsContainer m_SelectionItemContainer;
};

template <
	class Derived_T,
	class VsSiteCache_T = IVsPackageImplDefaults<>::VsSiteCache>
class IVsEditorFactoryImpl :
	public VsSiteBaseImpl<Derived_T, IVsEditorFactoryImpl<Derived_T, VsSiteCache_T>, IVsEditorFactory, VsSiteCache_T>
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsEditorFactoryImpl)

public:

	STDMETHOD(CreateEditorInstance)( 
		VSCREATEEDITORFLAGS grfCreateDoc,
		LPCOLESTR /*pszMkDocument*/,
		LPCOLESTR pszPhysicalView,
		_In_ IVsHierarchy* /*pvHier*/,
		VSITEMID /*itemid*/,
		_In_ IUnknown* punkDocDataExisting,
		_Out_ IUnknown** ppunkDocView,
		_Out_ IUnknown** ppunkDocData,
		_Deref_out_z_ BSTR* pbstrEditorCaption,
		_Out_ GUID* pguidCmdUI,
		_Out_ VSEDITORCREATEDOCWIN* pgrfCDW)
	{
		VSL_STDMETHODTRY{

		// Only open or silent is valid according to the interface specification
		VSL_CHECKBOOL(grfCreateDoc & (CEF_OPENFILE | CEF_SILENT), E_INVALIDARG);

		// Make sure all of the out parameters are valid and null them out.
		VSL_CHECKPOINTER(ppunkDocView, E_INVALIDARG);
		*ppunkDocView = NULL;

		VSL_CHECKPOINTER(ppunkDocData, E_INVALIDARG);
		*ppunkDocData = NULL;

		VSL_CHECKPOINTER(pbstrEditorCaption, E_INVALIDARG);
		*pbstrEditorCaption = NULL;

		VSL_CHECKPOINTER(pguidCmdUI, E_INVALIDARG);
		*pguidCmdUI = GUID_NULL;

		VSL_CHECKPOINTER(pgrfCDW, E_INVALIDARG);
		*pgrfCDW = 0;

		ErrorIfClosed();

		Derived_T& rDerived = *(static_cast<Derived_T*>(this));

		Derived_T::PhysicalViewId physicalViewID = 
			rDerived.GetPhysicalViewId(pszPhysicalView);

		if(physicalViewID == Derived_T::Unsupported)
		{
			return E_INVALIDARG;
		}

		if(!rDerived.CanShareBuffer(physicalViewID) && punkDocDataExisting != NULL)
		{
			// punkDocDataExisting not being NULL indicates that the buffer already
			// exists; however, if the derived class indicates it can not share the
			// buffer we return VS_E_INCOMPATIBLEDOCDATA so that VS will ask the 
			// user to close the existing document inorder to terminate the existing
			// buffer
			return VS_E_INCOMPATIBLEDOCDATA;
		}

		CComPtr<IUnknown> spDataObject;
		CComPtr<IUnknown> spViewObject;
		CComBSTR bstrEditorCaption;
		const GUID* pguidCommandUI = NULL;
		VSEDITORCREATEDOCWIN createDocumentWindowUI = 0;

		__if_exists(Derived_T::CreateDataAndViewObjects)
		{
			__if_exists(Derived_T::CreateSingleViewObject)
			{
				C_ASSERT(false); // Can't provide both multi-instance view and single view
			}
			rDerived.CreateDataAndViewObjects(
				physicalViewID, 
				spDataObject,
				spViewObject, 
				bstrEditorCaption, 
				pguidCommandUI, 
				createDocumentWindowUI);
		}
		__if_exists(Derived_T::CreateSingleViewObject)
		{
			rDerived.CreateSingleViewObject(
				physicalViewID, 
				spViewObject, 
				bstrEditorCaption, 
				pguidCommandUI, 
				createDocumentWindowUI);

			spDataObject = spViewObject;
		}

		VSL_CHECKPOINTER(spViewObject.p, E_FAIL);
		VSL_CHECKPOINTER(spDataObject.p, E_FAIL);
		VSL_CHECKPOINTER(pguidCommandUI, E_FAIL);

		// After this point, we need to continue execution to completion,
		// so that all parameters are properly set and nothing is leaked.
		// Anything that can realistically fail should be done before this point.

		*ppunkDocData = spDataObject.Detach();
		*ppunkDocView = spViewObject.Detach();

		*pbstrEditorCaption = bstrEditorCaption.Detach(); 

		*pguidCmdUI = *pguidCommandUI;

		if(createDocumentWindowUI != 0)
		{
			*pgrfCDW = createDocumentWindowUI;
		}

		}VSL_STDMETHODCATCH()

		return VSL_GET_STDMETHOD_HRESULT();
	}

	STDMETHOD(MapLogicalView)( 
		REFGUID rguidLogicalView,
		_Deref_out_z_ BSTR* pbstrPhysicalView)
	{
		VSL_STDMETHODTRY_EX(E_NOTIMPL){ // must return E_NOTIMPL for any unrecognized rguidLogicalView values

		VSL_CHECKPOINTER(pbstrPhysicalView, E_INVALIDARG);
		*pbstrPhysicalView = NULL;

		ErrorIfClosed();

		__if_exists(Derived_T::GetPhysicalViewBSTR)
		{
			Derived_T& rDerived = *(static_cast<Derived_T*>(this));

			Derived_T::PhysicalViewId physicalViewID = 
				rDerived.GetPhysicalViewId(rguidLogicalView);

			if(physicalViewID != Derived_T::Unsupported)
			{
				*pbstrPhysicalView = rDerived.GetPhysicalViewBSTR(physicalViewID);
				return S_OK;
			}
		}
		__if_not_exists(Derived_T::GetPhysicalViewBSTR)
		{
			if(rguidLogicalView == LOGVIEWID_Primary)
			{
				*pbstrPhysicalView = ::SysAllocString(L"");
				return S_OK;
			}
		}

		}VSL_STDMETHODCATCH()

		return VSL_GET_STDMETHOD_HRESULT();
	}
};

} // namespace VSL

// NOTE - this should be an exact clone of ATL's BEGIN_MSG_MAP, except with a try
#define VSL_BEGIN_MSG_MAP(theClass) \
public: \
	BOOL ProcessWindowMessage(_In_ HWND hWnd, UINT uMsg, _In_ WPARAM wParam, _In_ LPARAM lParam, LRESULT& lResult, DWORD dwMsgMapID = 0) \
	{ \
		BOOL bHandled = TRUE; \
		(hWnd); \
		(uMsg); \
		(wParam); \
		(lParam); \
		(lResult); \
		(bHandled); \
		VSL_STDMETHODTRY { \
		switch(dwMsgMapID) \
		{ \
		case 0:

// NOTE - this should be an exact clone of ATL's END_MSG_MAP, except with a the VSL catch blocks
#define VSL_END_MSG_MAP() \
			break; \
		default: \
			ATLTRACE(ATL::atlTraceWindowing, 0, _T("Invalid message map ID (%i)\n"), dwMsgMapID); \
			ATLASSERT(FALSE); \
			break; \
		} \
		}VSL_STDMETHODCATCH() \
		return FALSE; \
	}

#endif // VSLWINDOWS_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\Include\VSLVsSite.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef VSLVSSITE_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define VSLVSSITE_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

// VSL includes
#include <VSLCommon.h>

namespace VSL
{

// TODO - rename this to something more generic as it is used by all VS Site Caches (not just packages)
namespace IVsPackageEnums
{
	enum SetSiteResult {
		NothingCached,
		Cached,
		AlreadyCached,
		Cleared,
	};
};

class IServiceProviderRefCountGlobal
{

VSL_DECLARE_NONINSTANTIABLE_CLASS(IServiceProviderRefCountGlobal)

private:
	class Private {}; // Used to make a private instatiation of GlobalRefCount
	typedef GlobalRefCount<Private> RefCount;
public:
	static bool CanDetach()
	{
		VSL_CHECKBOOLEAN(RefCount::CanDecrement(), E_UNEXPECTED);
		return (--RefCount::Get()) == 0;
	}
	static void RecordAttach()
	{
		VSL_CHECKBOOLEAN(RefCount::CanIncrement(), E_UNEXPECTED);
		++RefCount::Get();
	}
};

template <
	class BaseCache_T = LocalCache<PointerWithNullDefault<IServiceProvider> >,
	class IServiceProviderRefCount_T = TypeNull>
struct IServiceProviderCacheTraits
{
	typedef BaseCache_T BaseCache;
	typedef IServiceProviderRefCount_T IServiceProviderRefCount;
};

typedef IServiceProviderCacheTraits<> IServiceProviderCacheTraitsLocal;

template <class Traits_T = IServiceProviderCacheTraitsLocal >
class IServiceProviderCache :
	public Traits_T::BaseCache
{

VSL_DECLARE_NOT_COPYABLE(IServiceProviderCache)

public:

	typedef typename Traits_T::IServiceProviderRefCount IServiceProviderRefCount;
	typedef typename Traits_T::BaseCache Cache;

	enum { bIsGlobal = Cache::bIsGlobal };

	IServiceProviderCache()	{}

	~IServiceProviderCache()
	{
		__if_not_exists(Cache::IsGlobal)
		{

		if(Get() != NULL)
		{
			Get()->Release();
		}

		}
	}

	IVsPackageEnums::SetSiteResult SetSite(_In_ IServiceProvider* pServiceProvider)
	{
		CachedType& pCached = Get();
		if(pServiceProvider == NULL)
		{
			if(pCached != NULL)
			{
				__if_exists(IServiceProviderRefCount::CanDetach)
				{
				if(IServiceProviderRefCount::CanDetach())
				}
				{
					pCached->Release();
					pCached = NULL;
					return IVsPackageEnums::Cleared;
				}
			}
			return IVsPackageEnums::NothingCached;
		}

		__if_exists(IServiceProviderRefCount::RecordAttach)
		{
			IServiceProviderRefCount::RecordAttach();
		}

		if(pCached == NULL)
		{
			pCached = pServiceProvider;
			pCached->AddRef();
			return IVsPackageEnums::Cached;
		}

		VSL_ASSERT(pServiceProvider == pCached); // These should always be the same

		return IVsPackageEnums::AlreadyCached;
	}
};

typedef IServiceProviderCache<> IServiceProviderLocalCache;

typedef IServiceProviderCacheTraits<
	GlobalCache<PointerWithNullDefault<IServiceProvider> >, 
	IServiceProviderRefCountGlobal>
		IServiceProviderCacheTraitsGlobal;

typedef IServiceProviderCache<IServiceProviderCacheTraitsGlobal> IServiceProviderGlobalCache;

/*
FUTURE - Caches for Apartment threading model objects, Both threading model objects,
and Multithreaded threading model objects could also be supplied if needed.
*/

class CommonServiceCacheGlobal
{

VSL_DECLARE_NOT_COPYABLE(CommonServiceCacheGlobal)

public:
	enum
	{
		bIsGlobal = 1, // For run-time
		IsGlobal, // For compile-time
	};

	CommonServiceCacheGlobal() {}

	template<class Interface_T, REFGUID Service_T>
	CComPtr<Interface_T>& Get()
	{
		static CComPtr<Interface_T> pInterface;
		return pInterface;
	}

	template<class Interface_T, REFGUID Service_T>
	const CComPtr<Interface_T>& Get() const
	{
		return (*const_cast<CommonServiceCacheGlobal*>(this)).Get<Interface_T, Service_T>();
	}
};

class CommonServiceCacheLocal
{

VSL_DECLARE_NOT_COPYABLE(CommonServiceCacheLocal)

public:
	CommonServiceCacheLocal() {}

	template<class Interface_T, REFGUID Service_T>
	CComPtr<Interface_T>& Get()
	{
		// Intentionally left empty, as a compile error for this location indicates a missing
		// specialization below or an incorect usage.
#if 0
		static CComPtr<Interface_T> p;
		return p;
#endif
	}

	template<class Interface_T, REFGUID Service_T>
	const CComPtr<Interface_T>& Get() const
	{
		// Intentionally left empty, as a compile error for this location indicates a missing
		// specialization below or an incorect usage.
#if 0
		static CComPtr<Interface_T> p;
		return p;
#endif
	}

	template<>
	CComPtr<IVsShell>& Get<IVsShell, SID_SVsShell>()
	{
		return m_spIVsShell;
	}

	template<>
	CComPtr<IVsUIShell>& Get<IVsUIShell, SID_SVsUIShell>()
	{
		return m_spIVsUIShell;
	}

	template<>
	const CComPtr<IVsShell>& Get<IVsShell, SID_SVsShell>() const
	{
		return m_spIVsShell;
	}
	template<>
	const CComPtr<IVsUIShell>& Get<IVsUIShell, SID_SVsUIShell>() const
	{
		return m_spIVsUIShell;
	}
	
private:
	CComPtr<IVsShell> m_spIVsShell;
	CComPtr<IVsUIShell> m_spIVsUIShell;
};

class GeneralServiceCacheNotImplemented
{

VSL_DECLARE_NOT_COPYABLE(GeneralServiceCacheNotImplemented)

public:

	// Not being implemented qualifies as global
	enum
	{
		bIsGlobal = 1, // For run-time
		IsGlobal, // For compile-time
	};

	GeneralServiceCacheNotImplemented() {}

	~GeneralServiceCacheNotImplemented() {}

	void Clear() {}

	template<class Interface_T, REFGUID Service_T>
	Interface_T* Get() const
	{
		return NULL;
	}

};

/*
FUTURE - An implementation for a local general service cache could be supplied if needed.
*/

template <
	class IServiceProviderCache_T = IServiceProviderGlobalCache,
	class CommonServiceCache_T = CommonServiceCacheGlobal,
	class GeneralServiceCache_T = GeneralServiceCacheNotImplemented>
class VsSiteCache
{

VSL_DECLARE_NOT_COPYABLE(VsSiteCache)

public:

	typedef typename VsSiteCache<IServiceProviderCache_T, CommonServiceCache_T, GeneralServiceCache_T> This;
	typedef typename IServiceProviderCache_T IServiceProviderCache;
	typedef typename CommonServiceCache_T CommonServiceCache;
	typedef typename GeneralServiceCache_T GeneralServiceCache;

	VsSiteCache():
		m_IServiceProviderCache(),
		m_CommonServiceCache(),
		m_GeneralServiceCache()
	{
	}

	// Returns the site interface IServiceProvider or NULL if it is not set.
	// Caller should AddRef and Release the interface.
	IServiceProvider* GetSite() const
	{
		return m_IServiceProviderCache.Get();
	}

	IVsPackageEnums::SetSiteResult SetSite(_In_ IServiceProvider* pSeriveProvider)
	{
		IVsPackageEnums::SetSiteResult result = m_IServiceProviderCache.SetSite(pSeriveProvider);
		switch(result)
		{
		// TODO - see about using a static list to ensure the AddRefs and Releases are balanced
		case IVsPackageEnums::Cached:
			{
				// Pre-cache common interfaces
				VSL_CHECKHRESULT(QueryService(SID_SVsShell, &m_CommonServiceCache.Get<IVsShell, SID_SVsShell>()));
				VSL_CHECKHRESULT(QueryService(SID_SVsUIShell, &m_CommonServiceCache.Get<IVsUIShell, SID_SVsUIShell>()));
			}
			break;
		case IVsPackageEnums::Cleared:
			{
				// Tell any dependents we've been unsited.
				if(m_UnsitedDelegate.IsBound())
				{
					m_UnsitedDelegate();
				}

				// Clear out the common interfaces
				m_CommonServiceCache.Get<IVsShell, SID_SVsShell>().Release();
				m_CommonServiceCache.Get<IVsUIShell, SID_SVsUIShell>().Release();

				// Clear out the general cache
				m_GeneralServiceCache.Clear();
			}
			break;
		case IVsPackageEnums::NothingCached:
		case IVsPackageEnums::AlreadyCached:
			break;
		default:
			VSL_ASSERT(0); // This should never happen.
		}

		return result;
	}

	// Directly query for a service, by-passing the interface cache.
	// Caller must Release the interface.
	template <class Interface_T>
	HRESULT QueryService(REFGUID serviceID, _Out_ Interface_T** ppInterface) const
	{
		if(GetSite() == NULL)
		{
			return E_UNEXPECTED;
		}
		
		HRESULT hr = GetSite()->QueryService(serviceID, __uuidof(Interface_T), reinterpret_cast<void**>(ppInterface));

		if(SUCCEEDED(hr)) // TODO - 2/9/2006 - unit test this case
		{
			VSL_CHECKBOOLEAN(NULL != *ppInterface, E_NOINTERFACE);
		}

		return hr;
	}

	// Returns the service interface only if it already cached
	// Returns NULL otherwise.
	// Caller should AddRef and Release the interface.
	template <class Interface_T, REFGUID Service_T>
	Interface_T* GetCachedService() const
	{
		return m_GeneralServiceCache.Get<Interface_T, Service_T>();
	}

	template <>
	IVsShell* GetCachedService<IVsShell, SID_SVsShell>() const
	{
		return m_CommonServiceCache.Get<IVsShell, SID_SVsShell>();
	}

	template <>
	IVsUIShell* GetCachedService<IVsUIShell, SID_SVsUIShell>() const
	{
		return m_CommonServiceCache.Get<IVsUIShell, SID_SVsUIShell>();
	}

	// Returns an HRESULT. After the call, ppService will be pointing to a
	// pointer to the service interface or NULL if it can't be found.
	// Will try to get the interface from the cache first
	// and QueryService if necessary.  If QueryService is successful,
	// the interface will be cached in the general cache, if it is implemented.
	// Caller must Release the interface.
	template <class Interface_T, REFGUID Service_T>
	HRESULT QueryCachedService(_Out_ Interface_T** ppService) const
	{
		VSL_CHECKPOINTER_DEFAULT(ppService);

		HRESULT hr = S_OK;

		Interface_T* pService = GetCachedService<Interface_T, Service_T>();

		if(pService == NULL)
		{
			hr = QueryService(Service_T, &pService);

			__if_exists(GeneralServiceCache::Put)
			{

			if(SUCCEEDED(hr) && pService != NULL)
			{
				// Lazy cache general (non-common) interfaces
				const_cast<This*>(this)->m_GeneralServiceCache.Put<Interface_T, Service_T>(pService);
			}

			}
		}
		else
		{
			pService->AddRef();
		}

		*ppService = pService;

		return hr;
	}

	typedef Delegate<void ()> UnsitedDelegate;

	UnsitedDelegate& GetUnsited()
	{
		return m_UnsitedDelegate;
	}

private:

	IServiceProviderCache_T m_IServiceProviderCache;
	CommonServiceCache_T m_CommonServiceCache;
	GeneralServiceCache_T m_GeneralServiceCache;
__if_exists(IServiceProviderCache::IsGlobal)
{
	static
}
	UnsitedDelegate m_UnsitedDelegate;
};

typedef VsSiteCache<> VsSiteCacheGlobal;

__declspec(selectany) VsSiteCacheGlobal::UnsitedDelegate VsSiteCacheGlobal::m_UnsitedDelegate;

typedef VsSiteCache<
	IServiceProviderLocalCache, 
	CommonServiceCacheLocal >
		VsSiteCacheLocal;

// See equivalent method on VsSiteCache for usage.
// It is recommended that that VsSiteCache_T only be set to the default as provided
// VsSiteCache_T should not be set to VsSiteCacheLocal.
// VsSiteCache_T needs to be a global cache callable from the desired thread context.
// If VsSiteCache_T is set to something other then default GlobalVSServiceProvider
// will not function correctly, and VSL_GET_VSUISHELL_SERVICE will need to be defined
// such that it will function correctly.
template <class VsSiteCache_T = VsSiteCacheGlobal>
class VsIServiceProviderUtilities
{

VSL_DECLARE_NONINSTANTIABLE_CLASS(VsIServiceProviderUtilities)

public:

	typedef VsSiteCache_T VsSiteCache;

	template <class Interface_T>
	static HRESULT QueryService(REFGUID serviceID, _Out_ Interface_T** ppInteface)
	{
		C_ASSERT(VsSiteCache_T::IServiceProviderCache::bIsGlobal);
		VsSiteCache_T cache;
		return cache.QueryService<Interface_T>(serviceID, ppInteface);
	}

	template <class Interface_T, REFGUID Service_T>
	static Interface_T* GetCachedService()
	{
		C_ASSERT(VsSiteCache_T::CommonServiceCache::bIsGlobal);
		VsSiteCache_T cache;
		return cache.GetCachedService<Interface_T, Service_T>();
	}

	template <class Interface_T, REFGUID Service_T>
	static HRESULT QueryCachedService(_Out_ Interface_T** ppService)
	{
		C_ASSERT(VsSiteCache_T::GeneralServiceCache::bIsGlobal);
		VsSiteCache_T cache;
		return cache.QueryCachedService<Interface_T, Service_T>(ppService);
	}

	static typename VsSiteCache_T::UnsitedDelegate& GetUnsited()
	{
		VsSiteCache_T cache;
		return cache.GetUnsited();
	}
};

#ifndef VSL_SERVICE_PROVIDER
#define VSL_SERVICE_PROVIDER VsIServiceProviderUtilities<>
#endif

// The purpose of this is to provide a class without defaulted template arguments
// for forward decleration at the top of VSLExceptions.h
class GlobalVSServiceProvider
{
public:
	static IVsUIShell* GetVsUIShellService()
	{
		return VSL_SERVICE_PROVIDER::GetCachedService<IVsUIShell, SID_SVsUIShell>();
	};
};

template <
	class DerivedClass_T,
	class DirectlyDerivedClass_T,
	class Base_T,
	class VsSiteCache_T = VsSiteCacheGlobal>
class VsSiteBaseImpl :
	public Base_T
{

VSL_DECLARE_NOT_COPYABLE(VsSiteBaseImpl)

protected:

	VsSiteBaseImpl():
		m_VsSiteCache(),
		m_bClosed(false)
	{
	}

	virtual ~VsSiteBaseImpl() = 0 {}

public:


	typedef VsSiteCache_T VsSiteCache;

    STDMETHOD(SetSite)(_In_ IServiceProvider* pIServiceProvider)
	{
		VSL_STDMETHODTRY{

		ErrorIfClosed();

		IVsPackageEnums::SetSiteResult result = m_VsSiteCache.SetSite(pIServiceProvider);
		switch(result)
		{
		case IVsPackageEnums::Cached:
			__if_exists(DirectlyDerivedClass_T::LoadUILibrary)
			{
				__if_exists(DirectlyDerivedClass_T::LoadUILibrary::ExtendedErrorInfo)
				{
					DirectlyDerivedClass_T::LoadUILibrary::LoadUILibrary(m_VsSiteCache, DerivedClass_T::GetLoadUILibraryErrorInfo());
				}
				__if_not_exists(DirectlyDerivedClass_T::LoadUILibrary::ExtendedErrorInfo)
				{
					DirectlyDerivedClass_T::LoadUILibrary::LoadUILibrary(m_VsSiteCache);
				}
			}
			__if_exists(DerivedClass_T::PostSited)
			{
				static_cast<DerivedClass_T*>(this)->PostSited(result);
			}
			break;
		case IVsPackageEnums::Cleared:
			__if_exists(DirectlyDerivedClass_T::LoadUILibrary)
			{
				DirectlyDerivedClass_T::LoadUILibrary::UnloadUILibrary();
			}
			break;
		case IVsPackageEnums::NothingCached:
			break;
		case IVsPackageEnums::AlreadyCached:
			__if_exists(DerivedClass_T::PostSited)
			{
				static_cast<DerivedClass_T*>(this)->PostSited(result);
			}
			break;
		default:
			VSL_ASSERT(0); // This should never happen.
		}

		}VSL_STDMETHODCATCH()

		return VSL_GET_STDMETHOD_HRESULT();
	}

	STDMETHOD(GetSite)(_Out_ IServiceProvider **ppSP)
	{
		VSL_STDMETHODTRY{

		VSL_CHECKPOINTER(ppSP, E_INVALIDARG);

		*ppSP = m_VsSiteCache.GetSite();

		VSL_CHECKPOINTER(*ppSP, E_UNEXPECTED); // called before site is set

		(*ppSP)->AddRef();

		}VSL_STDMETHODCATCH()

		return VSL_GET_STDMETHOD_HRESULT();
	}
	
    STDMETHOD(QueryClose)(_Out_ BOOL* pbCanClose)
	{
		if(pbCanClose == NULL)
		{
			return E_POINTER;
		}

		*pbCanClose = TRUE;

		return S_OK;
	}

	// This is expected to be called only once per instance
    STDMETHOD(Close)()
	{
		VSL_STDMETHODTRY{

		ErrorIfClosed();

		__if_exists(DerivedClass_T::PreClosing)
		{
			static_cast<DerivedClass_T*>(this)->PreClosing();
		}

		SetSite(NULL);

		m_bClosed = true;

		}VSL_STDMETHODCATCH()

		return VSL_GET_STDMETHOD_HRESULT();
	}

	VsSiteCache& GetVsSiteCache()
	{
		return m_VsSiteCache;
	}

protected:

	void ErrorIfClosed()
	{
		if(m_bClosed)
		{
			VSL_CREATE_ERROR_HRESULT(E_UNEXPECTED);
		}
	}

private:

	VsSiteCache m_VsSiteCache;
	bool m_bClosed;
};

} // namespace VSL

#endif // VSLVSSITE_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\Include\VSLShortNameDefines.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef VSLSHORTNAMEDEFINES_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define VSLSHORTNAMEDEFINES_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

// Short versions for brevity in client code, so long as the shortname isn't already defined.
// If this causes conflicts, just include the necessary definition before this header file.

// VSLErrorHandlers.h

#ifndef CHKEX
#define CHKEX VSL_CHECKBOOLEAN_EX
#endif

#ifndef CHK
#define CHK VSL_CHECKBOOLEAN
#endif

#ifndef CHKBOOLEX
#define CHKBOOLEX VSL_CHECKBOOL_EX
#endif

#ifndef CHKBOOL
#define CHKBOOL VSL_CHECKBOOL
#endif

#ifndef CHKBOOLGLEEX
#define CHKBOOLGLEEX VSL_CHECKBOOL_GLE_EX
#endif

#ifndef CHKBOOLGLE
#define CHKBOOLGLE VSL_CHECKBOOL_GLE
#endif

#ifndef CHKHANDLEGLEEX
#define CHKHANDLEGLEEX VSL_CHECKHANDLE_GLE_EX
#endif

#ifndef CHKHANDLEGLE
#define CHKHANDLEGLE VSL_CHECKHANDLE_GLE
#endif

#ifndef CHKHREX
#define CHKHREX VSL_CHECKHRESULT_EX
#endif

#ifndef CHKHR
#define CHKHR VSL_CHECKHRESULT
#endif

#ifndef ERRHREX
#define ERRHREX VSL_CREATE_ERROR_HRESULT_EX
#endif

#ifndef ERRHR
#define ERRHR VSL_CREATE_ERROR_HRESULT
#endif

#ifndef CHKW32EX
#define CHKW32EX VSL_CHECKWIN32_EX
#endif

#ifndef CHKW32
#define CHKW32 VSL_CHECKWIN32
#endif

#ifndef ERRW32EX
#define ERRW32EX VSL_CREATE_ERROR_WIN32_EX
#endif

#ifndef ERRW32
#define ERRW32 VSL_CREATE_ERROR_WIN32
#endif

#ifndef CHKPTREX
#define CHKPTREX VSL_CHECKPOINTER_EX
#endif

#ifndef CHKPTR
#define CHKPTR VSL_CHECKPOINTER
#endif

#ifndef CHKPTRDEF
#define CHKPTRDEF VSL_CHECKPOINTER_DEFAULT 
#endif

// VSLUnitTest.h

#ifndef UTHCHKEX
#define UTHCHKEX VSL_UTHELPERCHECK_EX
#endif

#ifndef UTHCHK
#define UTHCHK VSL_UTHELPERCHECK
#endif

#ifndef UTCHKEX
#define UTCHKEX VSL_UTCHECK_EX
#endif

#ifndef UTCHK
#define UTCHK VSL_UTCHECK
#endif

#ifndef UTRUN
#define UTRUN VSL_UTRUN
#endif

#ifndef CREATEVV
#define CREATEVV VSL_CREATE_VALIDVALUES
#endif

#ifndef PUSHVV
#define PUSHVV VSL_PUSH_VALIDVALUES
#endif

#ifndef SETVV
#define SETVV VSL_SET_VALIDVALUES
#endif

#ifndef STARTVV
#define	STARTVV VSL_START_VALIDVALUES_STATIC
#endif

#ifndef ENDVVPUSH
#define	ENDVVPUSH VSL_END_VALIDVALUES_PUSH
#endif

#ifndef ENDVVSET
#define	ENDVVSET VSL_END_VALIDVALUES_SET
#endif

#ifndef PUSHVV1
#define PUSHVV1 VSL_PUSH_VALIDVALUES1
#endif

#ifndef PUSHVV2
#define PUSHVV2 VSL_PUSH_VALIDVALUES2
#endif

#ifndef PUSHVV3
#define PUSHVV3 VSL_PUSH_VALIDVALUES3
#endif

#ifndef PUSHVV4
#define PUSHVV4 VSL_PUSH_VALIDVALUES4
#endif

#ifndef SETVV1
#define SETVV1 VSL_SET_VALIDVALUES1
#endif

#ifndef SETVV2
#define SETVV2 VSL_SET_VALIDVALUES2
#endif

#ifndef SETVV3
#define SETVV3 VSL_SET_VALIDVALUES3
#endif

#ifndef SETVV4
#define SETVV4 VSL_SET_VALIDVALUES4
#endif

#ifndef VVNOT0
#define VVNOT0 VSL_VALIDVALUE_SIMPLE_VERIFY
#endif

#ifndef WASCALLED
#define WASCALLED VSL_WAS_METHOD_CALLED
#endif

#ifndef WASCALLED0
#define WASCALLED0 VSL_WAS_METHODNOARGS_CALLED
#endif

// VSLPackage.h

#ifndef VSQS
#define VSQS VsIServiceProviderUtilities<>::QueryService
#endif

#ifndef VSQCS
#define VSQCS(guidService, Interface_T, ppService) VsIServiceProviderUtilities<>::QueryCachedService<Interface_T, guidService>(ppService)
#endif

#endif // VSLSHORTNAMEDEFINES_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockCSharpProjectConfigurationProperties3.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef CSHARPPROJECTCONFIGURATIONPROPERTIES3_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define CSHARPPROJECTCONFIGURATIONPROPERTIES3_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "vslangproj80.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class CSharpProjectConfigurationProperties3NotImpl :
	public CSharpProjectConfigurationProperties3
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(CSharpProjectConfigurationProperties3NotImpl)

public:

	typedef CSharpProjectConfigurationProperties3 Interface;

	STDMETHOD(get_LanguageVersion)(
		/*[out,retval]*/ BSTR* /*pbstrLanguageVersion*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(put_LanguageVersion)(
		/*[in]*/ BSTR /*LanguageVersion*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_ErrorReport)(
		/*[out,retval]*/ BSTR* /*pbstrErrorReport*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(put_ErrorReport)(
		/*[in]*/ BSTR /*ErrorReport*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_DebugInfo)(
		/*[out,retval]*/ BSTR* /*pbstrDebugInfo*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(put_DebugInfo)(
		/*[in]*/ BSTR /*DebugInfo*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_PlatformTarget)(
		/*[out,retval]*/ BSTR* /*pbstrPlatformTarget*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(put_PlatformTarget)(
		/*[in]*/ BSTR /*PlatformTarget*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_TreatSpecificWarningsAsErrors)(
		/*[out,retval]*/ BSTR* /*pbstrWarningsAsErrors*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(put_TreatSpecificWarningsAsErrors)(
		/*[in]*/ BSTR /*WarningsAsErrors*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_RunCodeAnalysis)(
		/*[out,retval]*/ VARIANT_BOOL* /*pbRunCodeAnalysis*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(put_RunCodeAnalysis)(
		/*[in]*/ VARIANT_BOOL /*RunCodeAnalysis*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_CodeAnalysisLogFile)(
		/*[out,retval]*/ BSTR* /*pbstrCodeAnalysisLogFile*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(put_CodeAnalysisLogFile)(
		/*[in]*/ BSTR /*CodeAnalysisLogFile*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_CodeAnalysisRuleAssemblies)(
		/*[out,retval]*/ BSTR* /*pbstrCodeAnalysisRuleAssemblies*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(put_CodeAnalysisRuleAssemblies)(
		/*[in]*/ BSTR /*CodeAnalysisRuleAssemblies*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_CodeAnalysisInputAssembly)(
		/*[out,retval]*/ BSTR* /*pbstrCodeAnalysisInputAssembly*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(put_CodeAnalysisInputAssembly)(
		/*[in]*/ BSTR /*CodeAnalysisInputAssembly*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_CodeAnalysisRules)(
		/*[out,retval]*/ BSTR* /*pbstrCodeAnalysisRules*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(put_CodeAnalysisRules)(
		/*[in]*/ BSTR /*CodeAnalysisRules*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_CodeAnalysisSpellCheckLanguages)(
		/*[out,retval]*/ BSTR* /*pbstrCodeAnalysisSpellCheckLanguages*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(put_CodeAnalysisSpellCheckLanguages)(
		/*[in]*/ BSTR /*CodeAnalysisSpellCheckLanguages*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_CodeAnalysisUseTypeNameInSuppression)(
		/*[out,retval]*/ VARIANT_BOOL* /*bUseTypeNameInSuppression*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(put_CodeAnalysisUseTypeNameInSuppression)(
		/*[in]*/ VARIANT_BOOL /*UseTypeNameInSuppression*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_CodeAnalysisModuleSuppressionsFile)(
		/*[out,retval]*/ BSTR* /*pbstrCodeAnalysisModuleSuppressionsFile*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(put_CodeAnalysisModuleSuppressionsFile)(
		/*[in]*/ BSTR /*CodeAnalysisModuleSuppressionsFile*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_UseVSHostingProcess)(
		/*[out,retval]*/ VARIANT_BOOL* /*pbUseVSHostingProcess*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(put_UseVSHostingProcess)(
		/*[in]*/ VARIANT_BOOL /*UseVSHostingProcess*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_GenerateSerializationAssemblies)(
		/*[out,retval]*/ sgenGenerationOption* /*pSgenGenerationOption*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(put_GenerateSerializationAssemblies)(
		/*[in]*/ sgenGenerationOption /*SgenGenerationOption*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_NoWarn)(
		/*[out,retval]*/ BSTR* /*pbstrWarnings*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(put_NoWarn)(
		/*[in]*/ BSTR /*bstrWarnings*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_NoStdLib)(
		/*[out,retval]*/ VARIANT_BOOL* /*pbNoStdLib*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(put_NoStdLib)(
		/*[in]*/ VARIANT_BOOL /*bNoStdLib*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get___id)(
		/*[out,retval]*/ BSTR* /*pbstrName*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_DebugSymbols)(
		/*[out,retval]*/ VARIANT_BOOL* /*pbGenerate*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(put_DebugSymbols)(
		/*[in]*/ VARIANT_BOOL /*bGenerate*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_DefineDebug)(
		/*[out,retval]*/ VARIANT_BOOL* /*pbDefineDebug*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(put_DefineDebug)(
		/*[in]*/ VARIANT_BOOL /*bDefineDebug*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_DefineTrace)(
		/*[out,retval]*/ VARIANT_BOOL* /*pbDefineTrace*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(put_DefineTrace)(
		/*[in]*/ VARIANT_BOOL /*bDefineTrace*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_OutputPath)(
		/*[out,retval]*/ BSTR* /*pbstrOutputPath*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(put_OutputPath)(
		/*[in]*/ BSTR /*bstrOutputPath*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_IntermediatePath)(
		/*[out,retval]*/ BSTR* /*pbstrIntermediatePath*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(put_IntermediatePath)(
		/*[in]*/ BSTR /*bstrIntermediatePath*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_DefineConstants)(
		/*[out,retval]*/ BSTR* /*pbstrDefineConstants*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(put_DefineConstants)(
		/*[in]*/ BSTR /*bstrDefineConstants*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_RemoveIntegerChecks)(
		/*[out,retval]*/ VARIANT_BOOL* /*pbRemoveIntegerChecks*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(put_RemoveIntegerChecks)(
		/*[in]*/ VARIANT_BOOL /*bRemoveIntegerChecks*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_BaseAddress)(
		/*[out,retval]*/ DWORD* /*pdwBaseAddress*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(put_BaseAddress)(
		/*[in]*/ DWORD /*dwBaseAddress*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_AllowUnsafeBlocks)(
		/*[out,retval]*/ VARIANT_BOOL* /*pbUnsafe*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(put_AllowUnsafeBlocks)(
		/*[in]*/ VARIANT_BOOL /*bUnsafe*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_CheckForOverflowUnderflow)(
		/*[out,retval]*/ VARIANT_BOOL* /*pbCheckForOverflowUnderflow*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(put_CheckForOverflowUnderflow)(
		/*[in]*/ VARIANT_BOOL /*bCheckForOverflowUnderflow*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_DocumentationFile)(
		/*[out,retval]*/ BSTR* /*pbstrDocumentationFile*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(put_DocumentationFile)(
		/*[in]*/ BSTR /*bstrDocumentationFile*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_Optimize)(
		/*[out,retval]*/ VARIANT_BOOL* /*pbOptimize*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(put_Optimize)(
		/*[in]*/ VARIANT_BOOL /*bCheckForOverflowUnderflow*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_IncrementalBuild)(
		/*[out,retval]*/ VARIANT_BOOL* /*pbIncrementalBuild*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(put_IncrementalBuild)(
		/*[in]*/ VARIANT_BOOL /*bIncrementalBuild*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_StartProgram)(
		/*[out,retval]*/ BSTR* /*pbstrStartProgram*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(put_StartProgram)(
		/*[in]*/ BSTR /*bstrStartProgram*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_StartWorkingDirectory)(
		/*[out,retval]*/ BSTR* /*pbstrStartWorkingDirectory*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(put_StartWorkingDirectory)(
		/*[in]*/ BSTR /*bstrStartWorkingDirectory*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_StartURL)(
		/*[out,retval]*/ BSTR* /*pbstrStartURL*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(put_StartURL)(
		/*[in]*/ BSTR /*bstrStartURL*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_StartPage)(
		/*[out,retval]*/ BSTR* /*pbstrStartPage*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(put_StartPage)(
		/*[in]*/ BSTR /*bstrStartPage*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_StartArguments)(
		/*[out,retval]*/ BSTR* /*pbstrStartArguments*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(put_StartArguments)(
		/*[in]*/ BSTR /*bstrStartArguments*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_StartWithIE)(
		/*[out,retval]*/ VARIANT_BOOL* /*pbStartWithIE*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(put_StartWithIE)(
		/*[in]*/ VARIANT_BOOL /*bStartWithIE*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_EnableASPDebugging)(
		/*[out,retval]*/ VARIANT_BOOL* /*pbEnableASPDebugging*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(put_EnableASPDebugging)(
		/*[in]*/ VARIANT_BOOL /*bEnableASPDebugging*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_EnableASPXDebugging)(
		/*[out,retval]*/ VARIANT_BOOL* /*pbEnableASPXDebugging*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(put_EnableASPXDebugging)(
		/*[in]*/ VARIANT_BOOL /*bEnableASPXDebugging*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_EnableUnmanagedDebugging)(
		/*[out,retval]*/ VARIANT_BOOL* /*pbEnableUnmanagedDebugging*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(put_EnableUnmanagedDebugging)(
		/*[in]*/ VARIANT_BOOL /*bEnableUnmanagedDebugging*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_StartAction)(
		/*[out,retval]*/ prjStartAction* /*pdebugStartMode*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(put_StartAction)(
		/*[in]*/ prjStartAction /*debugStartMode*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_Extender)(
		/*[in]*/ BSTR /*ExtenderName*/,
		/*[out,retval]*/ IDispatch** /*Extender*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_ExtenderNames)(
		/*[out,retval]*/ VARIANT* /*ExtenderNames*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_ExtenderCATID)(
		/*[out,retval]*/ BSTR* /*pRetval*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_WarningLevel)(
		/*[out,retval]*/ prjWarningLevel* /*pWarningLeve*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(put_WarningLevel)(
		/*[in]*/ prjWarningLevel /*warningLevel*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_TreatWarningsAsErrors)(
		/*[out,retval]*/ VARIANT_BOOL* /*pWarningAsError*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(put_TreatWarningsAsErrors)(
		/*[in]*/ VARIANT_BOOL /*warningAsError*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_EnableSQLServerDebugging)(
		/*[out,retval]*/ VARIANT_BOOL* /*pbEnableSQLServerDebugging*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(put_EnableSQLServerDebugging)(
		/*[in]*/ VARIANT_BOOL /*bEnableSQLServerDebugging*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_FileAlignment)(
		/*[out,retval]*/ DWORD* /*pdwFileAlignment*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(put_FileAlignment)(
		/*[in]*/ DWORD /*dwFileAlignment*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_RegisterForComInterop)(
		/*[out,retval]*/ VARIANT_BOOL* /*pVal*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(put_RegisterForComInterop)(
		/*[in]*/ VARIANT_BOOL /*val*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_ConfigurationOverrideFile)(
		/*[out,retval]*/ BSTR* /*pbstrConfigFile*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(put_ConfigurationOverrideFile)(
		/*[in]*/ BSTR /*bstrConfigFile*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_RemoteDebugEnabled)(
		/*[out,retval]*/ VARIANT_BOOL* /*pbEnableRemoteLaunch*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(put_RemoteDebugEnabled)(
		/*[in]*/ VARIANT_BOOL /*bEnableRemoteLaunch*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_RemoteDebugMachine)(
		/*[out,retval]*/ BSTR* /*pbstrRemoteLaunchMach*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(put_RemoteDebugMachine)(
		/*[in]*/ BSTR /*bstrRemoteLaunchMach*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetTypeInfoCount)(
		/*[out]*/ UINT* /*pctinfo*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetTypeInfo)(
		/*[in]*/ UINT /*iTInfo*/,
		/*[in]*/ LCID /*lcid*/,
		/*[out]*/ ITypeInfo** /*ppTInfo*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetIDsOfNames)(
		/*[in]*/ REFIID /*riid*/,
		/*[in,size_is(cNames)]*/ LPOLESTR* /*rgszNames*/,
		/*[in]*/ UINT /*cNames*/,
		/*[in]*/ LCID /*lcid*/,
		/*[out,size_is(cNames)]*/ DISPID* /*rgDispId*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(Invoke)(
		/*[in]*/ DISPID /*dispIdMember*/,
		/*[in]*/ REFIID /*riid*/,
		/*[in]*/ LCID /*lcid*/,
		/*[in]*/ WORD /*wFlags*/,
		/*[in,out]*/ DISPPARAMS* /*pDispParams*/,
		/*[out]*/ VARIANT* /*pVarResult*/,
		/*[out]*/ EXCEPINFO* /*pExcepInfo*/,
		/*[out]*/ UINT* /*puArgErr*/)VSL_STDMETHOD_NOTIMPL
};

class CSharpProjectConfigurationProperties3MockImpl :
	public CSharpProjectConfigurationProperties3,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(CSharpProjectConfigurationProperties3MockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(CSharpProjectConfigurationProperties3MockImpl)

	typedef CSharpProjectConfigurationProperties3 Interface;
	struct get_LanguageVersionValidValues
	{
		/*[out,retval]*/ BSTR* pbstrLanguageVersion;
		HRESULT retValue;
	};

	STDMETHOD(get_LanguageVersion)(
		/*[out,retval]*/ BSTR* pbstrLanguageVersion)
	{
		VSL_DEFINE_MOCK_METHOD(get_LanguageVersion)

		VSL_SET_VALIDVALUE_BSTR(pbstrLanguageVersion);

		VSL_RETURN_VALIDVALUES();
	}
	struct put_LanguageVersionValidValues
	{
		/*[in]*/ BSTR LanguageVersion;
		HRESULT retValue;
	};

	STDMETHOD(put_LanguageVersion)(
		/*[in]*/ BSTR LanguageVersion)
	{
		VSL_DEFINE_MOCK_METHOD(put_LanguageVersion)

		VSL_CHECK_VALIDVALUE_BSTR(LanguageVersion);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_ErrorReportValidValues
	{
		/*[out,retval]*/ BSTR* pbstrErrorReport;
		HRESULT retValue;
	};

	STDMETHOD(get_ErrorReport)(
		/*[out,retval]*/ BSTR* pbstrErrorReport)
	{
		VSL_DEFINE_MOCK_METHOD(get_ErrorReport)

		VSL_SET_VALIDVALUE_BSTR(pbstrErrorReport);

		VSL_RETURN_VALIDVALUES();
	}
	struct put_ErrorReportValidValues
	{
		/*[in]*/ BSTR ErrorReport;
		HRESULT retValue;
	};

	STDMETHOD(put_ErrorReport)(
		/*[in]*/ BSTR ErrorReport)
	{
		VSL_DEFINE_MOCK_METHOD(put_ErrorReport)

		VSL_CHECK_VALIDVALUE_BSTR(ErrorReport);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_DebugInfoValidValues
	{
		/*[out,retval]*/ BSTR* pbstrDebugInfo;
		HRESULT retValue;
	};

	STDMETHOD(get_DebugInfo)(
		/*[out,retval]*/ BSTR* pbstrDebugInfo)
	{
		VSL_DEFINE_MOCK_METHOD(get_DebugInfo)

		VSL_SET_VALIDVALUE_BSTR(pbstrDebugInfo);

		VSL_RETURN_VALIDVALUES();
	}
	struct put_DebugInfoValidValues
	{
		/*[in]*/ BSTR DebugInfo;
		HRESULT retValue;
	};

	STDMETHOD(put_DebugInfo)(
		/*[in]*/ BSTR DebugInfo)
	{
		VSL_DEFINE_MOCK_METHOD(put_DebugInfo)

		VSL_CHECK_VALIDVALUE_BSTR(DebugInfo);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_PlatformTargetValidValues
	{
		/*[out,retval]*/ BSTR* pbstrPlatformTarget;
		HRESULT retValue;
	};

	STDMETHOD(get_PlatformTarget)(
		/*[out,retval]*/ BSTR* pbstrPlatformTarget)
	{
		VSL_DEFINE_MOCK_METHOD(get_PlatformTarget)

		VSL_SET_VALIDVALUE_BSTR(pbstrPlatformTarget);

		VSL_RETURN_VALIDVALUES();
	}
	struct put_PlatformTargetValidValues
	{
		/*[in]*/ BSTR PlatformTarget;
		HRESULT retValue;
	};

	STDMETHOD(put_PlatformTarget)(
		/*[in]*/ BSTR PlatformTarget)
	{
		VSL_DEFINE_MOCK_METHOD(put_PlatformTarget)

		VSL_CHECK_VALIDVALUE_BSTR(PlatformTarget);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_TreatSpecificWarningsAsErrorsValidValues
	{
		/*[out,retval]*/ BSTR* pbstrWarningsAsErrors;
		HRESULT retValue;
	};

	STDMETHOD(get_TreatSpecificWarningsAsErrors)(
		/*[out,retval]*/ BSTR* pbstrWarningsAsErrors)
	{
		VSL_DEFINE_MOCK_METHOD(get_TreatSpecificWarningsAsErrors)

		VSL_SET_VALIDVALUE_BSTR(pbstrWarningsAsErrors);

		VSL_RETURN_VALIDVALUES();
	}
	struct put_TreatSpecificWarningsAsErrorsValidValues
	{
		/*[in]*/ BSTR WarningsAsErrors;
		HRESULT retValue;
	};

	STDMETHOD(put_TreatSpecificWarningsAsErrors)(
		/*[in]*/ BSTR WarningsAsErrors)
	{
		VSL_DEFINE_MOCK_METHOD(put_TreatSpecificWarningsAsErrors)

		VSL_CHECK_VALIDVALUE_BSTR(WarningsAsErrors);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_RunCodeAnalysisValidValues
	{
		/*[out,retval]*/ VARIANT_BOOL* pbRunCodeAnalysis;
		HRESULT retValue;
	};

	STDMETHOD(get_RunCodeAnalysis)(
		/*[out,retval]*/ VARIANT_BOOL* pbRunCodeAnalysis)
	{
		VSL_DEFINE_MOCK_METHOD(get_RunCodeAnalysis)

		VSL_SET_VALIDVALUE(pbRunCodeAnalysis);

		VSL_RETURN_VALIDVALUES();
	}
	struct put_RunCodeAnalysisValidValues
	{
		/*[in]*/ VARIANT_BOOL RunCodeAnalysis;
		HRESULT retValue;
	};

	STDMETHOD(put_RunCodeAnalysis)(
		/*[in]*/ VARIANT_BOOL RunCodeAnalysis)
	{
		VSL_DEFINE_MOCK_METHOD(put_RunCodeAnalysis)

		VSL_CHECK_VALIDVALUE(RunCodeAnalysis);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_CodeAnalysisLogFileValidValues
	{
		/*[out,retval]*/ BSTR* pbstrCodeAnalysisLogFile;
		HRESULT retValue;
	};

	STDMETHOD(get_CodeAnalysisLogFile)(
		/*[out,retval]*/ BSTR* pbstrCodeAnalysisLogFile)
	{
		VSL_DEFINE_MOCK_METHOD(get_CodeAnalysisLogFile)

		VSL_SET_VALIDVALUE_BSTR(pbstrCodeAnalysisLogFile);

		VSL_RETURN_VALIDVALUES();
	}
	struct put_CodeAnalysisLogFileValidValues
	{
		/*[in]*/ BSTR CodeAnalysisLogFile;
		HRESULT retValue;
	};

	STDMETHOD(put_CodeAnalysisLogFile)(
		/*[in]*/ BSTR CodeAnalysisLogFile)
	{
		VSL_DEFINE_MOCK_METHOD(put_CodeAnalysisLogFile)

		VSL_CHECK_VALIDVALUE_BSTR(CodeAnalysisLogFile);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_CodeAnalysisRuleAssembliesValidValues
	{
		/*[out,retval]*/ BSTR* pbstrCodeAnalysisRuleAssemblies;
		HRESULT retValue;
	};

	STDMETHOD(get_CodeAnalysisRuleAssemblies)(
		/*[out,retval]*/ BSTR* pbstrCodeAnalysisRuleAssemblies)
	{
		VSL_DEFINE_MOCK_METHOD(get_CodeAnalysisRuleAssemblies)

		VSL_SET_VALIDVALUE_BSTR(pbstrCodeAnalysisRuleAssemblies);

		VSL_RETURN_VALIDVALUES();
	}
	struct put_CodeAnalysisRuleAssembliesValidValues
	{
		/*[in]*/ BSTR CodeAnalysisRuleAssemblies;
		HRESULT retValue;
	};

	STDMETHOD(put_CodeAnalysisRuleAssemblies)(
		/*[in]*/ BSTR CodeAnalysisRuleAssemblies)
	{
		VSL_DEFINE_MOCK_METHOD(put_CodeAnalysisRuleAssemblies)

		VSL_CHECK_VALIDVALUE_BSTR(CodeAnalysisRuleAssemblies);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_CodeAnalysisInputAssemblyValidValues
	{
		/*[out,retval]*/ BSTR* pbstrCodeAnalysisInputAssembly;
		HRESULT retValue;
	};

	STDMETHOD(get_CodeAnalysisInputAssembly)(
		/*[out,retval]*/ BSTR* pbstrCodeAnalysisInputAssembly)
	{
		VSL_DEFINE_MOCK_METHOD(get_CodeAnalysisInputAssembly)

		VSL_SET_VALIDVALUE_BSTR(pbstrCodeAnalysisInputAssembly);

		VSL_RETURN_VALIDVALUES();
	}
	struct put_CodeAnalysisInputAssemblyValidValues
	{
		/*[in]*/ BSTR CodeAnalysisInputAssembly;
		HRESULT retValue;
	};

	STDMETHOD(put_CodeAnalysisInputAssembly)(
		/*[in]*/ BSTR CodeAnalysisInputAssembly)
	{
		VSL_DEFINE_MOCK_METHOD(put_CodeAnalysisInputAssembly)

		VSL_CHECK_VALIDVALUE_BSTR(CodeAnalysisInputAssembly);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_CodeAnalysisRulesValidValues
	{
		/*[out,retval]*/ BSTR* pbstrCodeAnalysisRules;
		HRESULT retValue;
	};

	STDMETHOD(get_CodeAnalysisRules)(
		/*[out,retval]*/ BSTR* pbstrCodeAnalysisRules)
	{
		VSL_DEFINE_MOCK_METHOD(get_CodeAnalysisRules)

		VSL_SET_VALIDVALUE_BSTR(pbstrCodeAnalysisRules);

		VSL_RETURN_VALIDVALUES();
	}
	struct put_CodeAnalysisRulesValidValues
	{
		/*[in]*/ BSTR CodeAnalysisRules;
		HRESULT retValue;
	};

	STDMETHOD(put_CodeAnalysisRules)(
		/*[in]*/ BSTR CodeAnalysisRules)
	{
		VSL_DEFINE_MOCK_METHOD(put_CodeAnalysisRules)

		VSL_CHECK_VALIDVALUE_BSTR(CodeAnalysisRules);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_CodeAnalysisSpellCheckLanguagesValidValues
	{
		/*[out,retval]*/ BSTR* pbstrCodeAnalysisSpellCheckLanguages;
		HRESULT retValue;
	};

	STDMETHOD(get_CodeAnalysisSpellCheckLanguages)(
		/*[out,retval]*/ BSTR* pbstrCodeAnalysisSpellCheckLanguages)
	{
		VSL_DEFINE_MOCK_METHOD(get_CodeAnalysisSpellCheckLanguages)

		VSL_SET_VALIDVALUE_BSTR(pbstrCodeAnalysisSpellCheckLanguages);

		VSL_RETURN_VALIDVALUES();
	}
	struct put_CodeAnalysisSpellCheckLanguagesValidValues
	{
		/*[in]*/ BSTR CodeAnalysisSpellCheckLanguages;
		HRESULT retValue;
	};

	STDMETHOD(put_CodeAnalysisSpellCheckLanguages)(
		/*[in]*/ BSTR CodeAnalysisSpellCheckLanguages)
	{
		VSL_DEFINE_MOCK_METHOD(put_CodeAnalysisSpellCheckLanguages)

		VSL_CHECK_VALIDVALUE_BSTR(CodeAnalysisSpellCheckLanguages);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_CodeAnalysisUseTypeNameInSuppressionValidValues
	{
		/*[out,retval]*/ VARIANT_BOOL* bUseTypeNameInSuppression;
		HRESULT retValue;
	};

	STDMETHOD(get_CodeAnalysisUseTypeNameInSuppression)(
		/*[out,retval]*/ VARIANT_BOOL* bUseTypeNameInSuppression)
	{
		VSL_DEFINE_MOCK_METHOD(get_CodeAnalysisUseTypeNameInSuppression)

		VSL_SET_VALIDVALUE(bUseTypeNameInSuppression);

		VSL_RETURN_VALIDVALUES();
	}
	struct put_CodeAnalysisUseTypeNameInSuppressionValidValues
	{
		/*[in]*/ VARIANT_BOOL UseTypeNameInSuppression;
		HRESULT retValue;
	};

	STDMETHOD(put_CodeAnalysisUseTypeNameInSuppression)(
		/*[in]*/ VARIANT_BOOL UseTypeNameInSuppression)
	{
		VSL_DEFINE_MOCK_METHOD(put_CodeAnalysisUseTypeNameInSuppression)

		VSL_CHECK_VALIDVALUE(UseTypeNameInSuppression);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_CodeAnalysisModuleSuppressionsFileValidValues
	{
		/*[out,retval]*/ BSTR* pbstrCodeAnalysisModuleSuppressionsFile;
		HRESULT retValue;
	};

	STDMETHOD(get_CodeAnalysisModuleSuppressionsFile)(
		/*[out,retval]*/ BSTR* pbstrCodeAnalysisModuleSuppressionsFile)
	{
		VSL_DEFINE_MOCK_METHOD(get_CodeAnalysisModuleSuppressionsFile)

		VSL_SET_VALIDVALUE_BSTR(pbstrCodeAnalysisModuleSuppressionsFile);

		VSL_RETURN_VALIDVALUES();
	}
	struct put_CodeAnalysisModuleSuppressionsFileValidValues
	{
		/*[in]*/ BSTR CodeAnalysisModuleSuppressionsFile;
		HRESULT retValue;
	};

	STDMETHOD(put_CodeAnalysisModuleSuppressionsFile)(
		/*[in]*/ BSTR CodeAnalysisModuleSuppressionsFile)
	{
		VSL_DEFINE_MOCK_METHOD(put_CodeAnalysisModuleSuppressionsFile)

		VSL_CHECK_VALIDVALUE_BSTR(CodeAnalysisModuleSuppressionsFile);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_UseVSHostingProcessValidValues
	{
		/*[out,retval]*/ VARIANT_BOOL* pbUseVSHostingProcess;
		HRESULT retValue;
	};

	STDMETHOD(get_UseVSHostingProcess)(
		/*[out,retval]*/ VARIANT_BOOL* pbUseVSHostingProcess)
	{
		VSL_DEFINE_MOCK_METHOD(get_UseVSHostingProcess)

		VSL_SET_VALIDVALUE(pbUseVSHostingProcess);

		VSL_RETURN_VALIDVALUES();
	}
	struct put_UseVSHostingProcessValidValues
	{
		/*[in]*/ VARIANT_BOOL UseVSHostingProcess;
		HRESULT retValue;
	};

	STDMETHOD(put_UseVSHostingProcess)(
		/*[in]*/ VARIANT_BOOL UseVSHostingProcess)
	{
		VSL_DEFINE_MOCK_METHOD(put_UseVSHostingProcess)

		VSL_CHECK_VALIDVALUE(UseVSHostingProcess);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_GenerateSerializationAssembliesValidValues
	{
		/*[out,retval]*/ sgenGenerationOption* pSgenGenerationOption;
		HRESULT retValue;
	};

	STDMETHOD(get_GenerateSerializationAssemblies)(
		/*[out,retval]*/ sgenGenerationOption* pSgenGenerationOption)
	{
		VSL_DEFINE_MOCK_METHOD(get_GenerateSerializationAssemblies)

		VSL_SET_VALIDVALUE(pSgenGenerationOption);

		VSL_RETURN_VALIDVALUES();
	}
	struct put_GenerateSerializationAssembliesValidValues
	{
		/*[in]*/ sgenGenerationOption SgenGenerationOption;
		HRESULT retValue;
	};

	STDMETHOD(put_GenerateSerializationAssemblies)(
		/*[in]*/ sgenGenerationOption SgenGenerationOption)
	{
		VSL_DEFINE_MOCK_METHOD(put_GenerateSerializationAssemblies)

		VSL_CHECK_VALIDVALUE(SgenGenerationOption);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_NoWarnValidValues
	{
		/*[out,retval]*/ BSTR* pbstrWarnings;
		HRESULT retValue;
	};

	STDMETHOD(get_NoWarn)(
		/*[out,retval]*/ BSTR* pbstrWarnings)
	{
		VSL_DEFINE_MOCK_METHOD(get_NoWarn)

		VSL_SET_VALIDVALUE_BSTR(pbstrWarnings);

		VSL_RETURN_VALIDVALUES();
	}
	struct put_NoWarnValidValues
	{
		/*[in]*/ BSTR bstrWarnings;
		HRESULT retValue;
	};

	STDMETHOD(put_NoWarn)(
		/*[in]*/ BSTR bstrWarnings)
	{
		VSL_DEFINE_MOCK_METHOD(put_NoWarn)

		VSL_CHECK_VALIDVALUE_BSTR(bstrWarnings);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_NoStdLibValidValues
	{
		/*[out,retval]*/ VARIANT_BOOL* pbNoStdLib;
		HRESULT retValue;
	};

	STDMETHOD(get_NoStdLib)(
		/*[out,retval]*/ VARIANT_BOOL* pbNoStdLib)
	{
		VSL_DEFINE_MOCK_METHOD(get_NoStdLib)

		VSL_SET_VALIDVALUE(pbNoStdLib);

		VSL_RETURN_VALIDVALUES();
	}
	struct put_NoStdLibValidValues
	{
		/*[in]*/ VARIANT_BOOL bNoStdLib;
		HRESULT retValue;
	};

	STDMETHOD(put_NoStdLib)(
		/*[in]*/ VARIANT_BOOL bNoStdLib)
	{
		VSL_DEFINE_MOCK_METHOD(put_NoStdLib)

		VSL_CHECK_VALIDVALUE(bNoStdLib);

		VSL_RETURN_VALIDVALUES();
	}
	struct get___idValidValues
	{
		/*[out,retval]*/ BSTR* pbstrName;
		HRESULT retValue;
	};

	STDMETHOD(get___id)(
		/*[out,retval]*/ BSTR* pbstrName)
	{
		VSL_DEFINE_MOCK_METHOD(get___id)

		VSL_SET_VALIDVALUE_BSTR(pbstrName);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_DebugSymbolsValidValues
	{
		/*[out,retval]*/ VARIANT_BOOL* pbGenerate;
		HRESULT retValue;
	};

	STDMETHOD(get_DebugSymbols)(
		/*[out,retval]*/ VARIANT_BOOL* pbGenerate)
	{
		VSL_DEFINE_MOCK_METHOD(get_DebugSymbols)

		VSL_SET_VALIDVALUE(pbGenerate);

		VSL_RETURN_VALIDVALUES();
	}
	struct put_DebugSymbolsValidValues
	{
		/*[in]*/ VARIANT_BOOL bGenerate;
		HRESULT retValue;
	};

	STDMETHOD(put_DebugSymbols)(
		/*[in]*/ VARIANT_BOOL bGenerate)
	{
		VSL_DEFINE_MOCK_METHOD(put_DebugSymbols)

		VSL_CHECK_VALIDVALUE(bGenerate);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_DefineDebugValidValues
	{
		/*[out,retval]*/ VARIANT_BOOL* pbDefineDebug;
		HRESULT retValue;
	};

	STDMETHOD(get_DefineDebug)(
		/*[out,retval]*/ VARIANT_BOOL* pbDefineDebug)
	{
		VSL_DEFINE_MOCK_METHOD(get_DefineDebug)

		VSL_SET_VALIDVALUE(pbDefineDebug);

		VSL_RETURN_VALIDVALUES();
	}
	struct put_DefineDebugValidValues
	{
		/*[in]*/ VARIANT_BOOL bDefineDebug;
		HRESULT retValue;
	};

	STDMETHOD(put_DefineDebug)(
		/*[in]*/ VARIANT_BOOL bDefineDebug)
	{
		VSL_DEFINE_MOCK_METHOD(put_DefineDebug)

		VSL_CHECK_VALIDVALUE(bDefineDebug);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_DefineTraceValidValues
	{
		/*[out,retval]*/ VARIANT_BOOL* pbDefineTrace;
		HRESULT retValue;
	};

	STDMETHOD(get_DefineTrace)(
		/*[out,retval]*/ VARIANT_BOOL* pbDefineTrace)
	{
		VSL_DEFINE_MOCK_METHOD(get_DefineTrace)

		VSL_SET_VALIDVALUE(pbDefineTrace);

		VSL_RETURN_VALIDVALUES();
	}
	struct put_DefineTraceValidValues
	{
		/*[in]*/ VARIANT_BOOL bDefineTrace;
		HRESULT retValue;
	};

	STDMETHOD(put_DefineTrace)(
		/*[in]*/ VARIANT_BOOL bDefineTrace)
	{
		VSL_DEFINE_MOCK_METHOD(put_DefineTrace)

		VSL_CHECK_VALIDVALUE(bDefineTrace);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_OutputPathValidValues
	{
		/*[out,retval]*/ BSTR* pbstrOutputPath;
		HRESULT retValue;
	};

	STDMETHOD(get_OutputPath)(
		/*[out,retval]*/ BSTR* pbstrOutputPath)
	{
		VSL_DEFINE_MOCK_METHOD(get_OutputPath)

		VSL_SET_VALIDVALUE_BSTR(pbstrOutputPath);

		VSL_RETURN_VALIDVALUES();
	}
	struct put_OutputPathValidValues
	{
		/*[in]*/ BSTR bstrOutputPath;
		HRESULT retValue;
	};

	STDMETHOD(put_OutputPath)(
		/*[in]*/ BSTR bstrOutputPath)
	{
		VSL_DEFINE_MOCK_METHOD(put_OutputPath)

		VSL_CHECK_VALIDVALUE_BSTR(bstrOutputPath);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_IntermediatePathValidValues
	{
		/*[out,retval]*/ BSTR* pbstrIntermediatePath;
		HRESULT retValue;
	};

	STDMETHOD(get_IntermediatePath)(
		/*[out,retval]*/ BSTR* pbstrIntermediatePath)
	{
		VSL_DEFINE_MOCK_METHOD(get_IntermediatePath)

		VSL_SET_VALIDVALUE_BSTR(pbstrIntermediatePath);

		VSL_RETURN_VALIDVALUES();
	}
	struct put_IntermediatePathValidValues
	{
		/*[in]*/ BSTR bstrIntermediatePath;
		HRESULT retValue;
	};

	STDMETHOD(put_IntermediatePath)(
		/*[in]*/ BSTR bstrIntermediatePath)
	{
		VSL_DEFINE_MOCK_METHOD(put_IntermediatePath)

		VSL_CHECK_VALIDVALUE_BSTR(bstrIntermediatePath);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_DefineConstantsValidValues
	{
		/*[out,retval]*/ BSTR* pbstrDefineConstants;
		HRESULT retValue;
	};

	STDMETHOD(get_DefineConstants)(
		/*[out,retval]*/ BSTR* pbstrDefineConstants)
	{
		VSL_DEFINE_MOCK_METHOD(get_DefineConstants)

		VSL_SET_VALIDVALUE_BSTR(pbstrDefineConstants);

		VSL_RETURN_VALIDVALUES();
	}
	struct put_DefineConstantsValidValues
	{
		/*[in]*/ BSTR bstrDefineConstants;
		HRESULT retValue;
	};

	STDMETHOD(put_DefineConstants)(
		/*[in]*/ BSTR bstrDefineConstants)
	{
		VSL_DEFINE_MOCK_METHOD(put_DefineConstants)

		VSL_CHECK_VALIDVALUE_BSTR(bstrDefineConstants);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_RemoveIntegerChecksValidValues
	{
		/*[out,retval]*/ VARIANT_BOOL* pbRemoveIntegerChecks;
		HRESULT retValue;
	};

	STDMETHOD(get_RemoveIntegerChecks)(
		/*[out,retval]*/ VARIANT_BOOL* pbRemoveIntegerChecks)
	{
		VSL_DEFINE_MOCK_METHOD(get_RemoveIntegerChecks)

		VSL_SET_VALIDVALUE(pbRemoveIntegerChecks);

		VSL_RETURN_VALIDVALUES();
	}
	struct put_RemoveIntegerChecksValidValues
	{
		/*[in]*/ VARIANT_BOOL bRemoveIntegerChecks;
		HRESULT retValue;
	};

	STDMETHOD(put_RemoveIntegerChecks)(
		/*[in]*/ VARIANT_BOOL bRemoveIntegerChecks)
	{
		VSL_DEFINE_MOCK_METHOD(put_RemoveIntegerChecks)

		VSL_CHECK_VALIDVALUE(bRemoveIntegerChecks);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_BaseAddressValidValues
	{
		/*[out,retval]*/ DWORD* pdwBaseAddress;
		HRESULT retValue;
	};

	STDMETHOD(get_BaseAddress)(
		/*[out,retval]*/ DWORD* pdwBaseAddress)
	{
		VSL_DEFINE_MOCK_METHOD(get_BaseAddress)

		VSL_SET_VALIDVALUE(pdwBaseAddress);

		VSL_RETURN_VALIDVALUES();
	}
	struct put_BaseAddressValidValues
	{
		/*[in]*/ DWORD dwBaseAddress;
		HRESULT retValue;
	};

	STDMETHOD(put_BaseAddress)(
		/*[in]*/ DWORD dwBaseAddress)
	{
		VSL_DEFINE_MOCK_METHOD(put_BaseAddress)

		VSL_CHECK_VALIDVALUE(dwBaseAddress);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_AllowUnsafeBlocksValidValues
	{
		/*[out,retval]*/ VARIANT_BOOL* pbUnsafe;
		HRESULT retValue;
	};

	STDMETHOD(get_AllowUnsafeBlocks)(
		/*[out,retval]*/ VARIANT_BOOL* pbUnsafe)
	{
		VSL_DEFINE_MOCK_METHOD(get_AllowUnsafeBlocks)

		VSL_SET_VALIDVALUE(pbUnsafe);

		VSL_RETURN_VALIDVALUES();
	}
	struct put_AllowUnsafeBlocksValidValues
	{
		/*[in]*/ VARIANT_BOOL bUnsafe;
		HRESULT retValue;
	};

	STDMETHOD(put_AllowUnsafeBlocks)(
		/*[in]*/ VARIANT_BOOL bUnsafe)
	{
		VSL_DEFINE_MOCK_METHOD(put_AllowUnsafeBlocks)

		VSL_CHECK_VALIDVALUE(bUnsafe);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_CheckForOverflowUnderflowValidValues
	{
		/*[out,retval]*/ VARIANT_BOOL* pbCheckForOverflowUnderflow;
		HRESULT retValue;
	};

	STDMETHOD(get_CheckForOverflowUnderflow)(
		/*[out,retval]*/ VARIANT_BOOL* pbCheckForOverflowUnderflow)
	{
		VSL_DEFINE_MOCK_METHOD(get_CheckForOverflowUnderflow)

		VSL_SET_VALIDVALUE(pbCheckForOverflowUnderflow);

		VSL_RETURN_VALIDVALUES();
	}
	struct put_CheckForOverflowUnderflowValidValues
	{
		/*[in]*/ VARIANT_BOOL bCheckForOverflowUnderflow;
		HRESULT retValue;
	};

	STDMETHOD(put_CheckForOverflowUnderflow)(
		/*[in]*/ VARIANT_BOOL bCheckForOverflowUnderflow)
	{
		VSL_DEFINE_MOCK_METHOD(put_CheckForOverflowUnderflow)

		VSL_CHECK_VALIDVALUE(bCheckForOverflowUnderflow);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_DocumentationFileValidValues
	{
		/*[out,retval]*/ BSTR* pbstrDocumentationFile;
		HRESULT retValue;
	};

	STDMETHOD(get_DocumentationFile)(
		/*[out,retval]*/ BSTR* pbstrDocumentationFile)
	{
		VSL_DEFINE_MOCK_METHOD(get_DocumentationFile)

		VSL_SET_VALIDVALUE_BSTR(pbstrDocumentationFile);

		VSL_RETURN_VALIDVALUES();
	}
	struct put_DocumentationFileValidValues
	{
		/*[in]*/ BSTR bstrDocumentationFile;
		HRESULT retValue;
	};

	STDMETHOD(put_DocumentationFile)(
		/*[in]*/ BSTR bstrDocumentationFile)
	{
		VSL_DEFINE_MOCK_METHOD(put_DocumentationFile)

		VSL_CHECK_VALIDVALUE_BSTR(bstrDocumentationFile);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_OptimizeValidValues
	{
		/*[out,retval]*/ VARIANT_BOOL* pbOptimize;
		HRESULT retValue;
	};

	STDMETHOD(get_Optimize)(
		/*[out,retval]*/ VARIANT_BOOL* pbOptimize)
	{
		VSL_DEFINE_MOCK_METHOD(get_Optimize)

		VSL_SET_VALIDVALUE(pbOptimize);

		VSL_RETURN_VALIDVALUES();
	}
	struct put_OptimizeValidValues
	{
		/*[in]*/ VARIANT_BOOL bCheckForOverflowUnderflow;
		HRESULT retValue;
	};

	STDMETHOD(put_Optimize)(
		/*[in]*/ VARIANT_BOOL bCheckForOverflowUnderflow)
	{
		VSL_DEFINE_MOCK_METHOD(put_Optimize)

		VSL_CHECK_VALIDVALUE(bCheckForOverflowUnderflow);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_IncrementalBuildValidValues
	{
		/*[out,retval]*/ VARIANT_BOOL* pbIncrementalBuild;
		HRESULT retValue;
	};

	STDMETHOD(get_IncrementalBuild)(
		/*[out,retval]*/ VARIANT_BOOL* pbIncrementalBuild)
	{
		VSL_DEFINE_MOCK_METHOD(get_IncrementalBuild)

		VSL_SET_VALIDVALUE(pbIncrementalBuild);

		VSL_RETURN_VALIDVALUES();
	}
	struct put_IncrementalBuildValidValues
	{
		/*[in]*/ VARIANT_BOOL bIncrementalBuild;
		HRESULT retValue;
	};

	STDMETHOD(put_IncrementalBuild)(
		/*[in]*/ VARIANT_BOOL bIncrementalBuild)
	{
		VSL_DEFINE_MOCK_METHOD(put_IncrementalBuild)

		VSL_CHECK_VALIDVALUE(bIncrementalBuild);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_StartProgramValidValues
	{
		/*[out,retval]*/ BSTR* pbstrStartProgram;
		HRESULT retValue;
	};

	STDMETHOD(get_StartProgram)(
		/*[out,retval]*/ BSTR* pbstrStartProgram)
	{
		VSL_DEFINE_MOCK_METHOD(get_StartProgram)

		VSL_SET_VALIDVALUE_BSTR(pbstrStartProgram);

		VSL_RETURN_VALIDVALUES();
	}
	struct put_StartProgramValidValues
	{
		/*[in]*/ BSTR bstrStartProgram;
		HRESULT retValue;
	};

	STDMETHOD(put_StartProgram)(
		/*[in]*/ BSTR bstrStartProgram)
	{
		VSL_DEFINE_MOCK_METHOD(put_StartProgram)

		VSL_CHECK_VALIDVALUE_BSTR(bstrStartProgram);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_StartWorkingDirectoryValidValues
	{
		/*[out,retval]*/ BSTR* pbstrStartWorkingDirectory;
		HRESULT retValue;
	};

	STDMETHOD(get_StartWorkingDirectory)(
		/*[out,retval]*/ BSTR* pbstrStartWorkingDirectory)
	{
		VSL_DEFINE_MOCK_METHOD(get_StartWorkingDirectory)

		VSL_SET_VALIDVALUE_BSTR(pbstrStartWorkingDirectory);

		VSL_RETURN_VALIDVALUES();
	}
	struct put_StartWorkingDirectoryValidValues
	{
		/*[in]*/ BSTR bstrStartWorkingDirectory;
		HRESULT retValue;
	};

	STDMETHOD(put_StartWorkingDirectory)(
		/*[in]*/ BSTR bstrStartWorkingDirectory)
	{
		VSL_DEFINE_MOCK_METHOD(put_StartWorkingDirectory)

		VSL_CHECK_VALIDVALUE_BSTR(bstrStartWorkingDirectory);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_StartURLValidValues
	{
		/*[out,retval]*/ BSTR* pbstrStartURL;
		HRESULT retValue;
	};

	STDMETHOD(get_StartURL)(
		/*[out,retval]*/ BSTR* pbstrStartURL)
	{
		VSL_DEFINE_MOCK_METHOD(get_StartURL)

		VSL_SET_VALIDVALUE_BSTR(pbstrStartURL);

		VSL_RETURN_VALIDVALUES();
	}
	struct put_StartURLValidValues
	{
		/*[in]*/ BSTR bstrStartURL;
		HRESULT retValue;
	};

	STDMETHOD(put_StartURL)(
		/*[in]*/ BSTR bstrStartURL)
	{
		VSL_DEFINE_MOCK_METHOD(put_StartURL)

		VSL_CHECK_VALIDVALUE_BSTR(bstrStartURL);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_StartPageValidValues
	{
		/*[out,retval]*/ BSTR* pbstrStartPage;
		HRESULT retValue;
	};

	STDMETHOD(get_StartPage)(
		/*[out,retval]*/ BSTR* pbstrStartPage)
	{
		VSL_DEFINE_MOCK_METHOD(get_StartPage)

		VSL_SET_VALIDVALUE_BSTR(pbstrStartPage);

		VSL_RETURN_VALIDVALUES();
	}
	struct put_StartPageValidValues
	{
		/*[in]*/ BSTR bstrStartPage;
		HRESULT retValue;
	};

	STDMETHOD(put_StartPage)(
		/*[in]*/ BSTR bstrStartPage)
	{
		VSL_DEFINE_MOCK_METHOD(put_StartPage)

		VSL_CHECK_VALIDVALUE_BSTR(bstrStartPage);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_StartArgumentsValidValues
	{
		/*[out,retval]*/ BSTR* pbstrStartArguments;
		HRESULT retValue;
	};

	STDMETHOD(get_StartArguments)(
		/*[out,retval]*/ BSTR* pbstrStartArguments)
	{
		VSL_DEFINE_MOCK_METHOD(get_StartArguments)

		VSL_SET_VALIDVALUE_BSTR(pbstrStartArguments);

		VSL_RETURN_VALIDVALUES();
	}
	struct put_StartArgumentsValidValues
	{
		/*[in]*/ BSTR bstrStartArguments;
		HRESULT retValue;
	};

	STDMETHOD(put_StartArguments)(
		/*[in]*/ BSTR bstrStartArguments)
	{
		VSL_DEFINE_MOCK_METHOD(put_StartArguments)

		VSL_CHECK_VALIDVALUE_BSTR(bstrStartArguments);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_StartWithIEValidValues
	{
		/*[out,retval]*/ VARIANT_BOOL* pbStartWithIE;
		HRESULT retValue;
	};

	STDMETHOD(get_StartWithIE)(
		/*[out,retval]*/ VARIANT_BOOL* pbStartWithIE)
	{
		VSL_DEFINE_MOCK_METHOD(get_StartWithIE)

		VSL_SET_VALIDVALUE(pbStartWithIE);

		VSL_RETURN_VALIDVALUES();
	}
	struct put_StartWithIEValidValues
	{
		/*[in]*/ VARIANT_BOOL bStartWithIE;
		HRESULT retValue;
	};

	STDMETHOD(put_StartWithIE)(
		/*[in]*/ VARIANT_BOOL bStartWithIE)
	{
		VSL_DEFINE_MOCK_METHOD(put_StartWithIE)

		VSL_CHECK_VALIDVALUE(bStartWithIE);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_EnableASPDebuggingValidValues
	{
		/*[out,retval]*/ VARIANT_BOOL* pbEnableASPDebugging;
		HRESULT retValue;
	};

	STDMETHOD(get_EnableASPDebugging)(
		/*[out,retval]*/ VARIANT_BOOL* pbEnableASPDebugging)
	{
		VSL_DEFINE_MOCK_METHOD(get_EnableASPDebugging)

		VSL_SET_VALIDVALUE(pbEnableASPDebugging);

		VSL_RETURN_VALIDVALUES();
	}
	struct put_EnableASPDebuggingValidValues
	{
		/*[in]*/ VARIANT_BOOL bEnableASPDebugging;
		HRESULT retValue;
	};

	STDMETHOD(put_EnableASPDebugging)(
		/*[in]*/ VARIANT_BOOL bEnableASPDebugging)
	{
		VSL_DEFINE_MOCK_METHOD(put_EnableASPDebugging)

		VSL_CHECK_VALIDVALUE(bEnableASPDebugging);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_EnableASPXDebuggingValidValues
	{
		/*[out,retval]*/ VARIANT_BOOL* pbEnableASPXDebugging;
		HRESULT retValue;
	};

	STDMETHOD(get_EnableASPXDebugging)(
		/*[out,retval]*/ VARIANT_BOOL* pbEnableASPXDebugging)
	{
		VSL_DEFINE_MOCK_METHOD(get_EnableASPXDebugging)

		VSL_SET_VALIDVALUE(pbEnableASPXDebugging);

		VSL_RETURN_VALIDVALUES();
	}
	struct put_EnableASPXDebuggingValidValues
	{
		/*[in]*/ VARIANT_BOOL bEnableASPXDebugging;
		HRESULT retValue;
	};

	STDMETHOD(put_EnableASPXDebugging)(
		/*[in]*/ VARIANT_BOOL bEnableASPXDebugging)
	{
		VSL_DEFINE_MOCK_METHOD(put_EnableASPXDebugging)

		VSL_CHECK_VALIDVALUE(bEnableASPXDebugging);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_EnableUnmanagedDebuggingValidValues
	{
		/*[out,retval]*/ VARIANT_BOOL* pbEnableUnmanagedDebugging;
		HRESULT retValue;
	};

	STDMETHOD(get_EnableUnmanagedDebugging)(
		/*[out,retval]*/ VARIANT_BOOL* pbEnableUnmanagedDebugging)
	{
		VSL_DEFINE_MOCK_METHOD(get_EnableUnmanagedDebugging)

		VSL_SET_VALIDVALUE(pbEnableUnmanagedDebugging);

		VSL_RETURN_VALIDVALUES();
	}
	struct put_EnableUnmanagedDebuggingValidValues
	{
		/*[in]*/ VARIANT_BOOL bEnableUnmanagedDebugging;
		HRESULT retValue;
	};

	STDMETHOD(put_EnableUnmanagedDebugging)(
		/*[in]*/ VARIANT_BOOL bEnableUnmanagedDebugging)
	{
		VSL_DEFINE_MOCK_METHOD(put_EnableUnmanagedDebugging)

		VSL_CHECK_VALIDVALUE(bEnableUnmanagedDebugging);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_StartActionValidValues
	{
		/*[out,retval]*/ prjStartAction* pdebugStartMode;
		HRESULT retValue;
	};

	STDMETHOD(get_StartAction)(
		/*[out,retval]*/ prjStartAction* pdebugStartMode)
	{
		VSL_DEFINE_MOCK_METHOD(get_StartAction)

		VSL_SET_VALIDVALUE(pdebugStartMode);

		VSL_RETURN_VALIDVALUES();
	}
	struct put_StartActionValidValues
	{
		/*[in]*/ prjStartAction debugStartMode;
		HRESULT retValue;
	};

	STDMETHOD(put_StartAction)(
		/*[in]*/ prjStartAction debugStartMode)
	{
		VSL_DEFINE_MOCK_METHOD(put_StartAction)

		VSL_CHECK_VALIDVALUE(debugStartMode);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_ExtenderValidValues
	{
		/*[in]*/ BSTR ExtenderName;
		/*[out,retval]*/ IDispatch** Extender;
		HRESULT retValue;
	};

	STDMETHOD(get_Extender)(
		/*[in]*/ BSTR ExtenderName,
		/*[out,retval]*/ IDispatch** Extender)
	{
		VSL_DEFINE_MOCK_METHOD(get_Extender)

		VSL_CHECK_VALIDVALUE_BSTR(ExtenderName);

		VSL_SET_VALIDVALUE_INTERFACE(Extender);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_ExtenderNamesValidValues
	{
		/*[out,retval]*/ VARIANT* ExtenderNames;
		HRESULT retValue;
	};

	STDMETHOD(get_ExtenderNames)(
		/*[out,retval]*/ VARIANT* ExtenderNames)
	{
		VSL_DEFINE_MOCK_METHOD(get_ExtenderNames)

		VSL_SET_VALIDVALUE_VARIANT(ExtenderNames);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_ExtenderCATIDValidValues
	{
		/*[out,retval]*/ BSTR* pRetval;
		HRESULT retValue;
	};

	STDMETHOD(get_ExtenderCATID)(
		/*[out,retval]*/ BSTR* pRetval)
	{
		VSL_DEFINE_MOCK_METHOD(get_ExtenderCATID)

		VSL_SET_VALIDVALUE_BSTR(pRetval);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_WarningLevelValidValues
	{
		/*[out,retval]*/ prjWarningLevel* pWarningLeve;
		HRESULT retValue;
	};

	STDMETHOD(get_WarningLevel)(
		/*[out,retval]*/ prjWarningLevel* pWarningLeve)
	{
		VSL_DEFINE_MOCK_METHOD(get_WarningLevel)

		VSL_SET_VALIDVALUE(pWarningLeve);

		VSL_RETURN_VALIDVALUES();
	}
	struct put_WarningLevelValidValues
	{
		/*[in]*/ prjWarningLevel warningLevel;
		HRESULT retValue;
	};

	STDMETHOD(put_WarningLevel)(
		/*[in]*/ prjWarningLevel warningLevel)
	{
		VSL_DEFINE_MOCK_METHOD(put_WarningLevel)

		VSL_CHECK_VALIDVALUE(warningLevel);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_TreatWarningsAsErrorsValidValues
	{
		/*[out,retval]*/ VARIANT_BOOL* pWarningAsError;
		HRESULT retValue;
	};

	STDMETHOD(get_TreatWarningsAsErrors)(
		/*[out,retval]*/ VARIANT_BOOL* pWarningAsError)
	{
		VSL_DEFINE_MOCK_METHOD(get_TreatWarningsAsErrors)

		VSL_SET_VALIDVALUE(pWarningAsError);

		VSL_RETURN_VALIDVALUES();
	}
	struct put_TreatWarningsAsErrorsValidValues
	{
		/*[in]*/ VARIANT_BOOL warningAsError;
		HRESULT retValue;
	};

	STDMETHOD(put_TreatWarningsAsErrors)(
		/*[in]*/ VARIANT_BOOL warningAsError)
	{
		VSL_DEFINE_MOCK_METHOD(put_TreatWarningsAsErrors)

		VSL_CHECK_VALIDVALUE(warningAsError);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_EnableSQLServerDebuggingValidValues
	{
		/*[out,retval]*/ VARIANT_BOOL* pbEnableSQLServerDebugging;
		HRESULT retValue;
	};

	STDMETHOD(get_EnableSQLServerDebugging)(
		/*[out,retval]*/ VARIANT_BOOL* pbEnableSQLServerDebugging)
	{
		VSL_DEFINE_MOCK_METHOD(get_EnableSQLServerDebugging)

		VSL_SET_VALIDVALUE(pbEnableSQLServerDebugging);

		VSL_RETURN_VALIDVALUES();
	}
	struct put_EnableSQLServerDebuggingValidValues
	{
		/*[in]*/ VARIANT_BOOL bEnableSQLServerDebugging;
		HRESULT retValue;
	};

	STDMETHOD(put_EnableSQLServerDebugging)(
		/*[in]*/ VARIANT_BOOL bEnableSQLServerDebugging)
	{
		VSL_DEFINE_MOCK_METHOD(put_EnableSQLServerDebugging)

		VSL_CHECK_VALIDVALUE(bEnableSQLServerDebugging);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_FileAlignmentValidValues
	{
		/*[out,retval]*/ DWORD* pdwFileAlignment;
		HRESULT retValue;
	};

	STDMETHOD(get_FileAlignment)(
		/*[out,retval]*/ DWORD* pdwFileAlignment)
	{
		VSL_DEFINE_MOCK_METHOD(get_FileAlignment)

		VSL_SET_VALIDVALUE(pdwFileAlignment);

		VSL_RETURN_VALIDVALUES();
	}
	struct put_FileAlignmentValidValues
	{
		/*[in]*/ DWORD dwFileAlignment;
		HRESULT retValue;
	};

	STDMETHOD(put_FileAlignment)(
		/*[in]*/ DWORD dwFileAlignment)
	{
		VSL_DEFINE_MOCK_METHOD(put_FileAlignment)

		VSL_CHECK_VALIDVALUE(dwFileAlignment);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_RegisterForComInteropValidValues
	{
		/*[out,retval]*/ VARIANT_BOOL* pVal;
		HRESULT retValue;
	};

	STDMETHOD(get_RegisterForComInterop)(
		/*[out,retval]*/ VARIANT_BOOL* pVal)
	{
		VSL_DEFINE_MOCK_METHOD(get_RegisterForComInterop)

		VSL_SET_VALIDVALUE(pVal);

		VSL_RETURN_VALIDVALUES();
	}
	struct put_RegisterForComInteropValidValues
	{
		/*[in]*/ VARIANT_BOOL val;
		HRESULT retValue;
	};

	STDMETHOD(put_RegisterForComInterop)(
		/*[in]*/ VARIANT_BOOL val)
	{
		VSL_DEFINE_MOCK_METHOD(put_RegisterForComInterop)

		VSL_CHECK_VALIDVALUE(val);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_ConfigurationOverrideFileValidValues
	{
		/*[out,retval]*/ BSTR* pbstrConfigFile;
		HRESULT retValue;
	};

	STDMETHOD(get_ConfigurationOverrideFile)(
		/*[out,retval]*/ BSTR* pbstrConfigFile)
	{
		VSL_DEFINE_MOCK_METHOD(get_ConfigurationOverrideFile)

		VSL_SET_VALIDVALUE_BSTR(pbstrConfigFile);

		VSL_RETURN_VALIDVALUES();
	}
	struct put_ConfigurationOverrideFileValidValues
	{
		/*[in]*/ BSTR bstrConfigFile;
		HRESULT retValue;
	};

	STDMETHOD(put_ConfigurationOverrideFile)(
		/*[in]*/ BSTR bstrConfigFile)
	{
		VSL_DEFINE_MOCK_METHOD(put_ConfigurationOverrideFile)

		VSL_CHECK_VALIDVALUE_BSTR(bstrConfigFile);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_RemoteDebugEnabledValidValues
	{
		/*[out,retval]*/ VARIANT_BOOL* pbEnableRemoteLaunch;
		HRESULT retValue;
	};

	STDMETHOD(get_RemoteDebugEnabled)(
		/*[out,retval]*/ VARIANT_BOOL* pbEnableRemoteLaunch)
	{
		VSL_DEFINE_MOCK_METHOD(get_RemoteDebugEnabled)

		VSL_SET_VALIDVALUE(pbEnableRemoteLaunch);

		VSL_RETURN_VALIDVALUES();
	}
	struct put_RemoteDebugEnabledValidValues
	{
		/*[in]*/ VARIANT_BOOL bEnableRemoteLaunch;
		HRESULT retValue;
	};

	STDMETHOD(put_RemoteDebugEnabled)(
		/*[in]*/ VARIANT_BOOL bEnableRemoteLaunch)
	{
		VSL_DEFINE_MOCK_METHOD(put_RemoteDebugEnabled)

		VSL_CHECK_VALIDVALUE(bEnableRemoteLaunch);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_RemoteDebugMachineValidValues
	{
		/*[out,retval]*/ BSTR* pbstrRemoteLaunchMach;
		HRESULT retValue;
	};

	STDMETHOD(get_RemoteDebugMachine)(
		/*[out,retval]*/ BSTR* pbstrRemoteLaunchMach)
	{
		VSL_DEFINE_MOCK_METHOD(get_RemoteDebugMachine)

		VSL_SET_VALIDVALUE_BSTR(pbstrRemoteLaunchMach);

		VSL_RETURN_VALIDVALUES();
	}
	struct put_RemoteDebugMachineValidValues
	{
		/*[in]*/ BSTR bstrRemoteLaunchMach;
		HRESULT retValue;
	};

	STDMETHOD(put_RemoteDebugMachine)(
		/*[in]*/ BSTR bstrRemoteLaunchMach)
	{
		VSL_DEFINE_MOCK_METHOD(put_RemoteDebugMachine)

		VSL_CHECK_VALIDVALUE_BSTR(bstrRemoteLaunchMach);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetTypeInfoCountValidValues
	{
		/*[out]*/ UINT* pctinfo;
		HRESULT retValue;
	};

	STDMETHOD(GetTypeInfoCount)(
		/*[out]*/ UINT* pctinfo)
	{
		VSL_DEFINE_MOCK_METHOD(GetTypeInfoCount)

		VSL_SET_VALIDVALUE(pctinfo);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetTypeInfoValidValues
	{
		/*[in]*/ UINT iTInfo;
		/*[in]*/ LCID lcid;
		/*[out]*/ ITypeInfo** ppTInfo;
		HRESULT retValue;
	};

	STDMETHOD(GetTypeInfo)(
		/*[in]*/ UINT iTInfo,
		/*[in]*/ LCID lcid,
		/*[out]*/ ITypeInfo** ppTInfo)
	{
		VSL_DEFINE_MOCK_METHOD(GetTypeInfo)

		VSL_CHECK_VALIDVALUE(iTInfo);

		VSL_CHECK_VALIDVALUE(lcid);

		VSL_SET_VALIDVALUE_INTERFACE(ppTInfo);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetIDsOfNamesValidValues
	{
		/*[in]*/ REFIID riid;
		/*[in,size_is(cNames)]*/ LPOLESTR* rgszNames;
		/*[in]*/ UINT cNames;
		/*[in]*/ LCID lcid;
		/*[out,size_is(cNames)]*/ DISPID* rgDispId;
		HRESULT retValue;
	};

	STDMETHOD(GetIDsOfNames)(
		/*[in]*/ REFIID riid,
		/*[in,size_is(cNames)]*/ LPOLESTR* rgszNames,
		/*[in]*/ UINT cNames,
		/*[in]*/ LCID lcid,
		/*[out,size_is(cNames)]*/ DISPID* rgDispId)
	{
		VSL_DEFINE_MOCK_METHOD(GetIDsOfNames)

		VSL_CHECK_VALIDVALUE(riid);

		VSL_CHECK_VALIDVALUE_MEMCMP(rgszNames, cNames*sizeof(rgszNames[0]), validValues.cNames*sizeof(validValues.rgszNames[0]));

		VSL_CHECK_VALIDVALUE(cNames);

		VSL_CHECK_VALIDVALUE(lcid);

		VSL_SET_VALIDVALUE_MEMCPY(rgDispId, cNames*sizeof(rgDispId[0]), validValues.cNames*sizeof(validValues.rgDispId[0]));

		VSL_RETURN_VALIDVALUES();
	}
	struct InvokeValidValues
	{
		/*[in]*/ DISPID dispIdMember;
		/*[in]*/ REFIID riid;
		/*[in]*/ LCID lcid;
		/*[in]*/ WORD wFlags;
		/*[in,out]*/ DISPPARAMS* pDispParams;
		/*[out]*/ VARIANT* pVarResult;
		/*[out]*/ EXCEPINFO* pExcepInfo;
		/*[out]*/ UINT* puArgErr;
		HRESULT retValue;
	};

	STDMETHOD(Invoke)(
		/*[in]*/ DISPID dispIdMember,
		/*[in]*/ REFIID riid,
		/*[in]*/ LCID lcid,
		/*[in]*/ WORD wFlags,
		/*[in,out]*/ DISPPARAMS* pDispParams,
		/*[out]*/ VARIANT* pVarResult,
		/*[out]*/ EXCEPINFO* pExcepInfo,
		/*[out]*/ UINT* puArgErr)
	{
		VSL_DEFINE_MOCK_METHOD(Invoke)

		VSL_CHECK_VALIDVALUE(dispIdMember);

		VSL_CHECK_VALIDVALUE(riid);

		VSL_CHECK_VALIDVALUE(lcid);

		VSL_CHECK_VALIDVALUE(wFlags);

		VSL_SET_VALIDVALUE(pDispParams);

		VSL_SET_VALIDVALUE_VARIANT(pVarResult);

		VSL_SET_VALIDVALUE(pExcepInfo);

		VSL_SET_VALIDVALUE(puArgErr);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // CSHARPPROJECTCONFIGURATIONPROPERTIES3_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\Include\VSLUnitTest.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef VSLUNITTEST_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define VSLUNITTEST_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#if !defined(_WIN32_WINNT) || (_WIN32_WINNT < 0x0400)
#error VSLUnitTest.h requires _WIN32_WINNT to be set to 0x0400 or higher.
#endif

#ifndef _VSL_RETAIL_SOURCE_INFO
#ifdef VSL_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#error VSLUnitTest.h requires _VSL_RETAIL_SOURCE_INFO to be defined prior to the first inclusion of VSL.h
#else // VSL_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define _VSL_RETAIL_SOURCE_INFO
#endif // VSL_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#endif // _VSL_RETAIL_SOURCE_INFO

// VSL includes and pre-defines

// For unit tests, disable error reporting, by default
#ifndef VSL_REPORT_ERROR_HRESULT
#define VSL_REPORT_ERROR_HRESULT(hr, bDisplayErrorToUser) (hr, bDisplayErrorToUser)
#endif

#ifndef VSL_REPORT_ERROR_HRESULT_EX
#define VSL_REPORT_ERROR_HRESULT_EX(hr, extended, bDisplayErrorToUser) (hr, extended, bDisplayErrorToUser)
#endif

// For unit tests, assume variants of types the system doesn't know how to compare, are equivalent
#ifndef VSL_VARIANT_EQUIVALENCE_DISP_E_BADVARTYPE_RETURN 
#define VSL_VARIANT_EQUIVALENCE_DISP_E_BADVARTYPE_RETURN true
#endif

// Since unit tests will generate errors on purpose, disable this so no asserts will be raised
// by the default error processors.
#ifndef VSL_ERROR_PROCESSOR_ASSERTEX
#define VSL_ERROR_PROCESSOR_ASSERTEX(exp, szMsg) ((void)0)
#endif

#ifndef VSL_UTASSERTEX
#define VSL_UTASSERTEX(exp, szMsg) _ASSERT_BASE(exp, szMsg)
#endif

#include <VSL.h>
#include <VSLCommon.h>
#include <VSLComparison.h>

#pragma warning(push)

// REVIEW - next version these warnings may be fixed.
#pragma warning(disable : 6011)

#include <iostream>
#include <crtdbg.h>
#include <queue>

#pragma warning(pop)

namespace VSL
{

#ifndef VSL_UTPASSEX
#define VSL_UTPASSEX(szTestName, szTestStep, szFailure, szFileName, iLineNumber) ((void)0)
#endif

#define VSL_UTPASS(szTestName, szTestStep, szFailure) VSL_UTPASSEX(szTestName, szTestStep, szFailure, __VSL_FILE__, __LINE__)

class FailedTest {};    // This class is used to identify the counter of failed tests.
typedef GlobalRefCount<FailedTest> FailureCounter;

static void HandleUnitTestFailure(
	const char* szTestName,
	const TCHAR* szTestStep, 
	const TCHAR* szExpText, 
	const TCHAR* szFileName, 
	int iLineNumber)
{
	if (FailureCounter::CanIncrement())
	{
		FailureCounter::Get()++;
	}
	_ASSERTE(szFileName != NULL);
	_ASSERTE(iLineNumber > 0);

#ifdef _UNICODE
	std::wostream& streamOut = std::wcerr;
#else
	std::ostream& streamOut = std::cpit;
#endif

	streamOut << szFileName << _T('(') << iLineNumber << _T(')') << _T(" : FAILED");

	if(szTestName != NULL)
	{
		streamOut << _T(" : ") << szTestName;
	}

	if(szTestStep != NULL)
	{
		streamOut << _T(" : ") << szTestStep;
	}

	if(szExpText != NULL)
	{
		streamOut << _T(" : ") << szExpText;
	}

	streamOut << _T('\n');

	if(IsDebuggerPresent() != 0)
	{
		DebugBreak();
	}
}

#ifndef VSL_UTFAILEX
#define VSL_UTFAILEX(szTestName, szTestStep, szFailure, szFileName, iLineNumber) VSL::HandleUnitTestFailure(szTestName, szTestStep, szFailure, szFileName, iLineNumber)
#endif // VSL_UTFAILEX

#define VSL_UTFAIL(szTestName, szTestStep, szFailure) VSL_UTFAILEX(szTestName, szTestStep, szFailure, __VSL_FILE__, __LINE__)

class UnitTestBase
{
private:

VSL_DECLARE_NOT_COPYABLE(UnitTestBase)

protected:

	explicit UnitTestBase(_In_opt_ const char* const szTestName):
		m_szTestName(szTestName)
	{
		SetUnitTestBase(*this);
	}

	~UnitTestBase() {}

public:

	bool Check(
		bool bExpValue,
		const TCHAR* szTestStep, 
		const TCHAR* szExpText, 
		const TCHAR* szFileName, 
		int iLineNumber) const
	{
		if(bExpValue)
		{
			// Success
			VSL_UTPASSEX(m_szTestName, szTestStep, szExpText, szFileName, iLineNumber);
		}
		else
		{
			// Failure
			VSL_UTFAILEX(m_szTestName, szTestStep, szExpText, szFileName, iLineNumber);
		}

		return bExpValue;
	}

public:

	static void SetUnitTestBase(const UnitTestBase& rUnitTestBase)
	{
		GetCurrentUnitTestBase() = &rUnitTestBase;
	}

	typedef const UnitTestBase* UnitTestBasePtr;
	static UnitTestBasePtr& GetCurrentUnitTestBase()
	{
		static UnitTestBasePtr pUnitTestBase = NULL;
		return pUnitTestBase;
	}

protected:

	const char* const m_szTestName;

};

#ifdef _UNICODE
#define VSL_UTHELPERCHECK_EX(exp, szTestStep, pUnitTest) pUnitTest->VSL::UnitTestBase::Check(exp, szTestStep, L#exp, __WFILE__, __LINE__)
#else
#define VSL_UTHELPERCHECK_EX(exp, szTestStep, pUnitTest) pUnitTest->VSL::UnitTestBase::Check(exp, szTestStep, #exp, __FILE__, __LINE__)
#endif

#define VSL_UTHELPERCHECK(exp, pUnitTest) VSL_UTHELPERCHECK_EX(exp, NULL, pUnitTest)
#define VSL_UTCHECK_EX(exp, szTestStep) VSL_UTHELPERCHECK_EX(exp, szTestStep, this)
#define VSL_UTCHECK(exp) VSL_UTHELPERCHECK_EX(exp, NULL, this)

template <class Test_T>
class UnitTestWrapper
{
private:

	UnitTestWrapper();

public:

	static void DoTest()
	{
		const char* szTestName = NULL;

		try
		{
			szTestName = typeid(Test_T).name();
		}
		catch(...)
		{
			VSL_UTFAIL(NULL, NULL, _T("Get name for test failed"));
			return;
		}

		try
		{
			Test_T test(szTestName);
		}
		catch(const ExceptionExBase& rException)
		{
			VSL_UTFAILEX(szTestName, rException.GetErrorString(), rException.GetExpressionString(), rException.GetSourceFilenamePath(), rException.GetSourceLinenumber());
		}
		catch(const ExceptionBase& /*rException*/)
		{
			VSL_UTFAIL(szTestName, NULL, _T("Threw an non-ExceptionExImpl ExceptionBase"));
		}
		catch(...)
		{
			VSL_UTFAIL(szTestName, NULL, _T("Threw an unknown exception"));
		}
	}
};

class UnitTestListTerminator
{
private:

	const UnitTestListTerminator& operator=(const UnitTestListTerminator& rToCopy);

public:

	// Allow use of compiler generated constructors and destructor

	enum { NumTests = 0 };
};

template <class Test_T, class Next_T>
class UnitTestList
{
private:

	const UnitTestList& operator=(const UnitTestList& rToCopy);

public:

	enum { NumTests = Next_T::NumTests + 1 };

	UnitTestList():
		m_Next()
	{
		Test_T::DoTest();
	}

	// Allow use of compiler generated copy constructor and destructor

private:

	Next_T m_Next;

};

// FUTURE - this may get removed
class VirtualDestructorUnitTestHelperBase
{
private:

	const VirtualDestructorUnitTestHelperBase& operator=(const VirtualDestructorUnitTestHelperBase& rToCopy);

public:

	// Allow use of compiler generated constructors and destructor

	static int& GetRefcount()
	{
		static int iRefCount = 0;
		return iRefCount;
	}
};

// FUTURE - this may get removed, it doesn't work flawlessly
template <class BaseClass_T>
class VirtualDestructorUnitTestHelper :
	public VirtualDestructorUnitTestHelperBase,
	public BaseClass_T
{
private:

	const VirtualDestructorUnitTestHelper& operator=(const VirtualDestructorUnitTestHelper& rToCopy);

public:
	typedef BaseClass_T BaseClass;

	VirtualDestructorUnitTestHelper()
	{
		++(GetRefcount());
	}

	VirtualDestructorUnitTestHelper(const VirtualDestructorUnitTestHelper& rToCopy)
	{
		++(GetRefcount());
	}

	virtual ~VirtualDestructorUnitTestHelper()
	{
		--(GetRefcount());
	}
};

template <class DerivedClass_T>
class BaseClassHasVirtualDestructorUnitTest :
	UnitTestBase
{
private:

	BaseClassHasVirtualDestructorUnitTest(const BaseClassHasVirtualDestructorUnitTest& rToCopy);
	const BaseClassHasVirtualDestructorUnitTest& operator=(const BaseClassHasVirtualDestructorUnitTest& rToCopy);

public:

	explicit BaseClassHasVirtualDestructorUnitTest(const char* const szTestName):
		UnitTestBase(szTestName)
	{
		VSL_UTCHECK_EX(DerivedClass_T::GetRefcount() == 0, _T("0 static ref count before construction"));
		{
			DerivedClass_T obj;
			VSL_UTCHECK_EX(DerivedClass_T::GetRefcount() == 1, _T("1 static ref count after construction"));
		}
		// obj destructor will be called when it goes out of scope.
		VSL_UTCHECK_EX(DerivedClass_T::GetRefcount() == 0, _T("0 static ref count after out of scope destruction and before construction via new"));
		DerivedClass_T::BaseClass* p = new DerivedClass_T;
		VSL_UTCHECK_EX(DerivedClass_T::GetRefcount() == 1, _T("1 static ref count after construction via new"));
		delete p;
		VSL_UTCHECK_EX(DerivedClass_T::GetRefcount() == 0, _T("0 static ref count after destruction via delete through base class pointer"));
	}
};

#define VSL_DEFINE_VIRTUAL_DESTRUCTOR_TEST_HELPER(toTest) \
class toTest##HasVirtualDestructorTestHelper : \
	public VirtualDestructorUnitTestHelper<toTest> \
{ \
public: \
	virtual ~toTest##HasVirtualDestructorTestHelper() {} \
}

#define VSL_UTRUN(test) VSL::UnitTestWrapper<test >::DoTest()

#define VSL_UTRUN_BASE_CLASS_HAS_VIRTUAL_DESTRUCTOR(toTest) \
	VSL_UTRUN(BaseClassHasVirtualDestructorUnitTest<toTest##HasVirtualDestructorTestHelper>)

#define VSL_VALIDVALUE_SIMPLE_VERIFY(type) reinterpret_cast<type>(-1)

// TODO - unit test this (everything is covered in usage at the moment, so low pri)
class MockBase
{
private:

VSL_DECLARE_NOT_COPYABLE(MockBase)

protected:

	MockBase()
	{
	}

	~MockBase()
	{
	}

public:

	template <class ValidValues_T>
	static void SetValidValues(const ValidValues_T& rValidValues)
	{
		ValidValues<const ValidValues_T*>() = &rValidValues;
	}

	template <class ValidValues_T>
	static void PushValidValues(const ValidValues_T& rValidValues, unsigned int iNumTimes = 1)
	{
		VSL_ASSERT(iNumTimes > 0);
		for(unsigned int i = 1; i <= iNumTimes; ++i)
		{
			GetValidValuesQueue<ValidValues_T>().push(rValidValues);
		}
	}

	template <class Signature_T, Signature_T Unique_T>
	static bool WasMethodCalled(int iTimesCalled)
	{
		return (Called<Signature_T, Unique_T>(false) == iTimesCalled);
	}

protected:

	template <class ValidValues_T>
	static const ValidValues_T& GetValidValues()
	{
		const ValidValues_T* pValidValues = ValidValues<const ValidValues_T*>();

		VSL_UTASSERTEX(pValidValues != NULL, _T("ValidValues was not set!"));
		VSL_CHECKBOOLEAN(pValidValues != NULL, E_UNEXPECTED);
#pragma warning(push) // compiler doesn't get that the above line will throw if pValidValues is NULL
#pragma warning(disable : 6011) // Dereferencing NULL pointer 'pValidValues'
		return *pValidValues;
#pragma warning(pop)
	}

	template <class ValidValues_T>
	static std::queue<ValidValues_T>& GetValidValuesQueue()
	{
		static std::queue<ValidValues_T> queue;
		return queue;
	}

	template <class Signature_T, Signature_T Unique_T>
	static int Called(bool bIncrement = true)
	{
		static int iCalled = 0;
		// This will be called with false to get the number of times it was called
		int iRet = iCalled;
		if (bIncrement)
		{
			++iCalled;
		}
		else
		{
			iCalled = 0;
		}
		return iRet;
	}

public:

#pragma warning(push)
#pragma warning(disable : 4480) // warning C4480: nonstandard extension used: specifying underlying type for enum 'VSL::MockBase::CheckPointerResult'
	enum CheckPointerResult : unsigned int
	{
		DoCheck = 0,
		Fail,
		SkipCheck
	};
#pragma warning(pop)

	template <class PointerType1_T, class PointerType2_T>
	static CheckPointerResult ShouldCheckPointerValue(PointerType1_T* pValidValue, const PointerType2_T* pPassedIn)
	{
		if(pValidValue == VSL_VALIDVALUE_SIMPLE_VERIFY(PointerType1_T*))
		{
			// Just make sure the value isn't null
			if(pPassedIn != NULL)
			{
				return SkipCheck;
			}
			else
			{
				VSL_UTHELPERCHECK(pPassedIn != NULL, VSL::UnitTestBase::GetCurrentUnitTestBase());
				return Fail;
			}
		}
		if(pValidValue == NULL)
		{
			if(pPassedIn == NULL)
			{
				return SkipCheck;
			}
			else
			{
				VSL_UTHELPERCHECK(pPassedIn == NULL, VSL::UnitTestBase::GetCurrentUnitTestBase());
				return Fail;
			}
		}
		if(pPassedIn == NULL)
		{
			VSL_UTHELPERCHECK(pPassedIn != NULL, VSL::UnitTestBase::GetCurrentUnitTestBase());
			return Fail;
		}
		return DoCheck;
	}

	static bool CheckPointerResultToBoolean(CheckPointerResult result)
	{
		return (result != Fail);
	}

	static bool CheckValidStringW(_In_opt_ const wchar_t * const pszValid, _In_opt_ const wchar_t * const pszParam)
	{
		bool bRet;
		if(pszValid == VSL_VALIDVALUE_SIMPLE_VERIFY(const wchar_t * const))
		{
			// Just make sure the value isn't null or empty string
			if(pszParam != NULL)
			{
				bRet = (pszParam[0] != L'\0');
			}
			else
			{
				bRet = false;
			}
		}
		else if(pszValid == NULL)
		{
			bRet = (pszParam == NULL);
		}
		else if(pszParam != NULL)
		{
			bRet = (0 == ::wcscmp(pszValid, pszParam));
		}
		else
		{
			bRet = false;
		}
		return bRet;
	}

	static bool CheckValidStringA(_In_opt_ const char * const pszValid, _In_opt_ const char * const pszParam)
	{
		bool bRet = true;
		if(pszValid == VSL_VALIDVALUE_SIMPLE_VERIFY(const char * const))
		{
			// Just make sure the value isn't null or empty string
			if(pszParam != NULL)
			{
				bRet = (pszParam[0] != '\0');
			}
			else
			{
				bRet = false;
			}
		}
		else if(pszValid == NULL)
		{
			bRet = (pszParam == NULL);
		}
		else if(pszParam != NULL)
		{
			bRet = (0 == ::strcmp(pszValid, pszParam));
		}
		else
		{
			bRet = false;
		}
		return bRet;
	}

	static bool CheckValidBSTR(const BSTR bstrValid, const BSTR bstrParam)
	{
		bool bRet = true;
		if(bstrValid == VSL_VALIDVALUE_SIMPLE_VERIFY(const BSTR))
		{
			// Just make sure the value isn't null or empty string
			if(bstrParam != NULL)
			{
				bRet = (bstrParam[0] != L'\0');
			}
			else
			{
				bRet = false;
			}
		}
		else if(bstrValid == NULL)
		{
			bRet = (bstrParam == NULL);
		}
		else
		{
			bRet = (VARCMP_EQ == ::VarBstrCmp(bstrValid, bstrParam, LOCALE_USER_DEFAULT, 0));
		}
		return bRet;
	}

	template <class PointerType1_T, class PointerType2_T>
	static bool CheckValidPointer(PointerType1_T pValidValue, PointerType2_T pPassedIn)
	{
		CheckPointerResult result = ShouldCheckPointerValue(pValidValue, pPassedIn);
		if(result == DoCheck)
		{
			return (*pValidValue == *pPassedIn);
		}
		return CheckPointerResultToBoolean(result);
	}

	template <class Interface1_T, class Interface2_T>
	static bool CheckValidInterfacePointer(Interface1_T* pValidValue, Interface2_T* pPassedIn)
	{
		CheckPointerResult result = ShouldCheckPointerValue(pValidValue, pPassedIn);
		if(result == DoCheck)
		{
			return (pValidValue == pPassedIn);
		}
		return CheckPointerResultToBoolean(result);
	}

	static bool CheckValidVoidPointer(void* pValidValue, void* pPassedIn, size_t iSizeInBytes)
	{
		CheckPointerResult result = ShouldCheckPointerValue(pValidValue, pPassedIn);
		if(result == DoCheck)
		{
			return (0 == ::memcmp(pPassedIn, pValidValue, iSizeInBytes));
		}
		return CheckPointerResultToBoolean(result);
	}

	static bool CheckValidSAFEARRAY(SAFEARRAY* pValidValue, SAFEARRAY* pPassedIn)
	{
		CheckPointerResult result = ShouldCheckPointerValue(pValidValue, pPassedIn);
		if(result == DoCheck)
		{
			// TODO implement this properly
			return true;
		}
		return CheckPointerResultToBoolean(result);
	}

	template <class Type>
	static void SetValidValue(Type* pValidValue, Type* pPassedIn)
	{
		if(pPassedIn != NULL && pValidValue != NULL)
		{
			*pPassedIn = *pValidValue;
		}
	}

	template <class Type>
	static void SetValidInterface(Type* pValidValue, Type* pPassedIn)
	{
		if(pPassedIn != NULL && pValidValue != NULL)
		{
			*pPassedIn = *pValidValue;
			if((*pPassedIn) != NULL)
			{
				(*pPassedIn)->AddRef();
			}
		}
	}

	static void SetValidBSTR(BSTR* pValidValue, BSTR* pPassedIn)
	{
		if(pPassedIn != NULL && pValidValue != NULL)
		{
			VSL_UTHELPERCHECK(NULL != (*pPassedIn = ::SysAllocString(*(pValidValue))), VSL::UnitTestBase::GetCurrentUnitTestBase());
		}
	}

	static void SetValidVariant(VARIANT* pValidValue, VARIANT* pPassedIn)
	{
		if(pPassedIn != NULL && pValidValue != NULL)
		{
			VSL_UTHELPERCHECK(S_OK == ::VariantCopy(pPassedIn, pValidValue), VSL::UnitTestBase::GetCurrentUnitTestBase());
		}
	}

	static void SetValidStringW(_Out_z_cap_(iLength) wchar_t* pValidValue, _In_z_ wchar_t* pPassedIn, size_t iLength)
	{
		if(pPassedIn != NULL && pValidValue != NULL)
		{
			VSL_UTHELPERCHECK(0 == ::wcscpy_s(pPassedIn, iLength, pValidValue), VSL::UnitTestBase::GetCurrentUnitTestBase());
		}
	}

	static void SetValidStringA(_Out_z_cap_(iLength) char* pValidValue, _In_z_ char* pPassedIn, size_t iLength)
	{
		if(pPassedIn != NULL && pValidValue != NULL)
		{
			VSL_UTHELPERCHECK(0 == ::strcpy_s(pPassedIn, iLength, pValidValue), VSL::UnitTestBase::GetCurrentUnitTestBase());
		}
	}

	static void SetValidVoidPointer(void* pValidValue, void* pPassedIn, size_t iByteLength)
	{
		if(pPassedIn != NULL && pValidValue != NULL)
		{
			::memcpy(pPassedIn, pValidValue, iByteLength);
		}
	}

	static void SetValidSAFEARRAY(SAFEARRAY** pValidValue, SAFEARRAY** pPassedIn)
	{
		if(pPassedIn != NULL && pValidValue != NULL)
		{
			VSL_UTHELPERCHECK(S_OK == ::SafeArrayCopy(*pValidValue, pPassedIn), VSL::UnitTestBase::GetCurrentUnitTestBase());
		}
	}

private:

	template <class ValidValuesPtr_T>
	static ValidValuesPtr_T& ValidValues()
	{
		static ValidValuesPtr_T pValidValues = NULL;
		return pValidValues;
	}

};

// TODO - unit test these
#define VSL_DEFINE_MOCK_CLASS_TYPDEFS(className) \
	typedef className This; \
	typedef void (className::*ClassMethodNoArgs)(); \
	typedef void (className::*ClassMethod)(...);

#define VSL_DEFINE_MOCK_METHOD_NOARGS_NORETURN(methodName) \
	Called<This::ClassMethodNoArgs, reinterpret_cast<This::ClassMethodNoArgs>(&This::methodName)>()

#define VSL_DEFINE_VALIDVALUES(type) \
	const type validValues = !GetValidValuesQueue<type>().empty() ? GetValidValuesQueue<type>().front() : GetValidValues<type>(); \
	if(!GetValidValuesQueue<type>().empty()) \
	{ \
		GetValidValuesQueue<type>().pop(); \
	}

#define VSL_NOTE_METHOD_WAS_CALLED(methodName) \
	Called<This::ClassMethod, reinterpret_cast<This::ClassMethod>(&This::methodName)>() \

#define VSL_DEFINE_MOCK_METHOD(methodName) \
	VSL_NOTE_METHOD_WAS_CALLED(methodName); \
	VSL_DEFINE_VALIDVALUES(methodName##ValidValues)

#define VSL_DEFINE_MOCK_METHOD_NOARGS(methodName) \
	VSL_DEFINE_MOCK_METHOD_NOARGS_NORETURN(methodName); \
	VSL_DEFINE_VALIDVALUES(methodName##ValidValues)

#define VSL_NOTE_STATIC_METHOD_WAS_CALLED(methodName) \
	Called<void (*)(...), reinterpret_cast<void (*)(...)>(&This::methodName)>() \

#define VSL_DEFINE_MOCK_STATIC_METHOD(methodName) \
	VSL_NOTE_STATIC_METHOD_WAS_CALLED(methodName); \
	VSL_DEFINE_VALIDVALUES(methodName##ValidValues)

#define VSL_VALIDVALUD_STRINGW_LENGTH(sz) (sz == NULL ? 0 : ::wcslen(sz)+1)
#define VSL_VALIDVALUD_STRINGA_LENGTH(sz) (sz == NULL ? 0 : ::strlen(sz)+1)

#define VSL_CHECK_VALIDVALUE(value)	VSL_UTHELPERCHECK(validValues.value == value, VSL::UnitTestBase::GetCurrentUnitTestBase())
#if defined(UNICODE) || defined(_UNICODE)
#define VSL_CHECK_VALIDVALUE_STRING(value) VSL_UTHELPERCHECK(VSL::MockBase::CheckValidStringW(validValues.value, value), VSL::UnitTestBase::GetCurrentUnitTestBase())
#else
#define VSL_CHECK_VALIDVALUE_STRING(value) VSL_UTHELPERCHECK(VSL::MockBase::CheckValidStringA(validValues.value, value), VSL::UnitTestBase::GetCurrentUnitTestBase())
#endif
#define VSL_CHECK_VALIDVALUE_STRINGW(value) VSL_UTHELPERCHECK(VSL::MockBase::CheckValidStringW(validValues.value, value), VSL::UnitTestBase::GetCurrentUnitTestBase())
#define VSL_CHECK_VALIDVALUE_STRINGA(value) VSL_UTHELPERCHECK(VSL::MockBase::CheckValidStringA(validValues.value, value), VSL::UnitTestBase::GetCurrentUnitTestBase())
#define VSL_CHECK_VALIDVALUE_BSTR(value) VSL_UTHELPERCHECK(VSL::MockBase::CheckValidBSTR(validValues.value, value), VSL::UnitTestBase::GetCurrentUnitTestBase())
#define VSL_CHECK_VALIDVALUE_POINTER(value) VSL_UTHELPERCHECK(VSL::MockBase::CheckValidPointer(validValues.value, value), VSL::UnitTestBase::GetCurrentUnitTestBase())
#define VSL_CHECK_VALIDVALUE_PVOID(value) VSL_UTHELPERCHECK(VSL::MockBase::CheckValidVoidPointer(validValues.value, value, validValues.value##_size_in_bytes), VSL::UnitTestBase::GetCurrentUnitTestBase())
#define VSL_CHECK_VALIDVALUE_SAFEARRAY(value) VSL_UTHELPERCHECK(VSL::MockBase::CheckValidSAFEARRAY(validValues.value, value), VSL::UnitTestBase::GetCurrentUnitTestBase())
#define VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(value) VSL_UTHELPERCHECK(VSL::MockBase::CheckValidInterfacePointer(validValues.value, value), VSL::UnitTestBase::GetCurrentUnitTestBase())
#define VSL_CHECK_VALIDVALUE_RANGE(value) VSL_UTHELPERCHECK(validValues.value##Min <= value && validValues.value##Max >= value, VSL::UnitTestBase::GetCurrentUnitTestBase())
#define VSL_CHECK_VALIDVALUE_HWND(value) VSL_UTHELPERCHECK(::IsWindow(value), VSL::UnitTestBase::GetCurrentUnitTestBase())

#define _VSL_CHECK_VALIDVALUE_IF(value) \
		{ \
		VSL::MockBase::CheckPointerResult result = VSL::MockBase::ShouldCheckPointerValue(validValues.value, value); \
		if(result == Fail) \
		{ \
			VSL_UTHELPERCHECK(false, VSL::UnitTestBase::GetCurrentUnitTestBase()); \
		} \
		else if(result == DoCheck) \
		{

#define _VSL_CHECK_VALIDVALUE_CLOSE_IF \
		} \
		}

#define VSL_CHECK_VALIDVALUE_ARRAY(value, sizeParam, sizeMember) \
		_VSL_CHECK_VALIDVALUE_IF(value) \
			VSL_UTHELPERCHECK(sizeParam == sizeMember, VSL::UnitTestBase::GetCurrentUnitTestBase()); \
			unsigned int iCount = static_cast<unsigned int>(sizeParam < sizeMember ? sizeParam : sizeMember); \
			for(unsigned int i = 0; i < iCount; ++i) \
			{ \
				VSL_UTHELPERCHECK(value[i] == validValues.value[i], VSL::UnitTestBase::GetCurrentUnitTestBase()); \
			} \
		_VSL_CHECK_VALIDVALUE_CLOSE_IF

#define VSL_CHECK_VALIDVALUE_MEMCMP(value, bytesParam, bytesMember) \
		_VSL_CHECK_VALIDVALUE_IF(value) \
			VSL_UTHELPERCHECK(bytesParam == bytesMember, VSL::UnitTestBase::GetCurrentUnitTestBase()); \
			VSL_UTHELPERCHECK(0 == ::memcmp(value, validValues.value, static_cast<size_t>(bytesParam < bytesMember ? bytesParam : bytesMember)), VSL::UnitTestBase::GetCurrentUnitTestBase()); \
		_VSL_CHECK_VALIDVALUE_CLOSE_IF

#define _VSL_SET_VALIDVALUE_IF(value) if(value != NULL && validValues.value != NULL)

#define VSL_SET_VALIDVALUE(value) VSL::MockBase::SetValidValue(validValues.value, value)

#define VSL_SET_VALIDVALUE_CONST(value, type) \
		_VSL_SET_VALIDVALUE_IF(value) \
		{ \
			*const_cast<type>(value) = *validValues.value; \
		}

#define VSL_SET_VALIDVALUE_PVOID(value)	VSL::MockBase::SetValidVoidPointer(validValues.value, value, validValues.value##_size_in_bytes)

#define VSL_SET_VALIDVALUE_INTERFACE(value)	VSL::MockBase::SetValidInterface(validValues.value, value)

#define VSL_SET_VALIDVALUE_INTERFACEARRAY(value, sizeParam, sizeMember) \
		_VSL_SET_VALIDVALUE_IF(value) \
		{ \
			unsigned int iCount = static_cast<unsigned int>(sizeParam < sizeMember ? sizeParam : sizeMember); \
			for(unsigned int i = 0; i < iCount; ++i) \
			{ \
				value[i] = validValues.value[i]; \
				if(value[i] != NULL) \
				{ \
					(value[i])->AddRef(); \
				} \
			} \
		}

#define VSL_SET_VALIDVALUE_MEMCPY(value, bytesParam, bytesMember) \
		_VSL_SET_VALIDVALUE_IF(value) \
		{ \
			::memcpy(value, validValues.value, static_cast<size_t>(bytesParam < bytesMember ? bytesParam : bytesMember)); \
		}

#define VSL_SET_VALIDVALUE_STRINGW(value, iLength) VSL::MockBase::SetValidStringW(validValues.value, value, iLength)

#define VSL_SET_VALIDVALUE_STRINGA(value, iLength) VSL::MockBase::SetValidStringA(validValues.value, value, iLength)

#define VSL_SET_VALIDVALUE_BSTR(value) VSL::MockBase::SetValidBSTR(validValues.value, value)

#define VSL_SET_VALIDVALUE_VARIANT(value) VSL::MockBase::SetValidVariant(validValues.value, value)

#define VSL_SET_VALIDVALUE_SAFEARRAY(value)	VSL::MockBase::SetValidSAFEARRAY(validValues.value, value)

#define VSL_SET_VALIDVALUE_REFERENCE(value) (value = validValues.value)

#define VSL_RETURN_VALIDVALUES() return validValues.retValue

#define VSL_CREATE_VALIDVALUES(CLASS, METHOD, variableName)	CLASS##MockImpl::METHOD##ValidValues variableName =

#define VSL_SET_VALIDVALUES(rValidValues) VSL::MockBase::SetValidValues(rValidValues)

#define VSL_PUSH_VALIDVALUES(rValidValues) VSL::MockBase::PushValidValues(rValidValues)

#define VSL_PUSH_VALIDVALUES_EX(rValidValues, iNumTimes) VSL::MockBase::PushValidValues(rValidValues, iNumTimes)

#define VSL_START_VALIDVALUES(CLASS, METHOD) \
		{ \
		__if_exists(CLASS##MockImpl) \
		{ \
		CLASS##MockImpl::METHOD##ValidValues __validValues__ = \
		} \
		__if_not_exists(CLASS##MockImpl) \
		{ \
		CLASS::METHOD##ValidValues __validValues__ = \
		} \
		{

#define VSL_START_VALIDVALUES_STATIC(CLASS, METHOD) \
		{ \
		__if_exists(CLASS##MockImpl) \
		{ \
		static CLASS##MockImpl::METHOD##ValidValues __validValues__ = \
		} \
		__if_not_exists(CLASS##MockImpl) \
		{ \
		static CLASS::METHOD##ValidValues __validValues__ = \
		} \
		{ \

#define VSL_END_VALIDVALUES_SET() \
		}; \
		VSL_SET_VALIDVALUES(__validValues__); \
		} 

#define VSL_END_VALIDVALUES_PUSH() \
		}; \
		VSL_PUSH_VALIDVALUES(__validValues__); \
		} 

#define VSL_END_VALIDVALUES_EX(iNumTimes) \
		}; \
		VSL_PUSH_VALIDVALUES_EX(__validValues__, iNumTimes); \
		} 

#define VSL_PUSH_VALIDVALUES1(CLASS, METHOD, param1) \
		VSL_START_VALIDVALUES(CLASS, METHOD) \
			param1 \
		VSL_END_VALIDVALUES_PUSH()

#define VSL_PUSH_VALIDVALUES2(CLASS, METHOD, param1, param2) \
		VSL_START_VALIDVALUES(CLASS, METHOD) \
			param1, \
			param2 \
		VSL_END_VALIDVALUES_PUSH()

#define VSL_PUSH_VALIDVALUES3(CLASS, METHOD, param1, param2, param3) \
		VSL_START_VALIDVALUES(CLASS, METHOD) \
			param1, \
			param2, \
			param3 \
		VSL_END_VALIDVALUES_PUSH()

#define VSL_PUSH_VALIDVALUES4(CLASS, METHOD, param1, param2, param3, param4) \
		VSL_START_VALIDVALUES(CLASS, METHOD) \
			param1, \
			param2, \
			param3, \
			param4 \
		VSL_END_VALIDVALUES_PUSH()

#define VSL_SET_VALIDVALUES1(CLASS, METHOD, param1) \
		VSL_START_VALIDVALUES_STATIC(CLASS, METHOD) \
			param1 \
		VSL_END_VALIDVALUES_SET()

#define VSL_SET_VALIDVALUES2(CLASS, METHOD, param1, param2) \
		VSL_START_VALIDVALUES_STATIC(CLASS, METHOD) \
			param1, \
			param2 \
		VSL_END_VALIDVALUES_SET()

#define VSL_SET_VALIDVALUES3(CLASS, METHOD, param1, param2, param3) \
		VSL_START_VALIDVALUES_STATIC(CLASS, METHOD) \
			param1, \
			param2, \
			param3 \
		VSL_END_VALIDVALUES_SET()

#define VSL_SET_VALIDVALUES4(CLASS, METHOD, param1, param2, param3, param4) \
		VSL_START_VALIDVALUES_STATIC(CLASS, METHOD) \
			param1, \
			param2, \
			param3, \
			param4 \
		VSL_END_VALIDVALUES_SET()

#define VSL_WAS_METHOD_CALLED(CLASS, METHOD, iNumTimes) (VSL::MockBase::WasMethodCalled<CLASS##MockImpl::ClassMethod, reinterpret_cast<CLASS##MockImpl::ClassMethod>(&CLASS##MockImpl::METHOD)>(iNumTimes))
#define VSL_WAS_METHODNOARGS_CALLED(CLASS, METHOD, iNumTimes) (VSL::MockBase::WasMethodCalled<CLASS##MockImpl::ClassMethodNoArgs, reinterpret_cast<CLASS##MockImpl::ClassMethodNoArgs>(&CLASS##MockImpl::METHOD)>(iNumTimes))

// TODO - move these elsewhere

#ifdef __ATLWIN_H__

class WindowMock :
	public MockBase
{
public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(WindowMock)

	WindowMock():
		m_bCreated(false)
	{
	}

	WindowMock(HWND hwnd):
		m_bCreated(hwnd == NULL ? false : true)
	{
	}

	HWND Create(LPCTSTR /*lpstrWndClass*/, HWND /*hWndParent*/, _U_RECT /*rect*/ = NULL, LPCTSTR /*szWindowName*/ = NULL,
			DWORD /*dwStyle*/ = 0, DWORD /*dwExStyle*/ = 0,
			_U_MENUorID /*MenuOrID*/ = 0U, LPVOID /*lpCreateParam*/ = NULL)
	{
		m_bCreated = true;
		return NULL;
	}

	HWND Create(HWND /*hWndParent*/, LPARAM /*dwInitParam*/ = NULL)
	{
		return InternalCreate();
	}

	struct InternalCreateValidValues
	{
		// In
		// TODO
		// Out
		HWND retValue;
		DWORD dwLastError;
	};

	// Mock method infrastructure doesn't work with overloaded methods
	HWND InternalCreate()
	{
		VSL_DEFINE_MOCK_METHOD(InternalCreate);

		m_bCreated = (validValues.retValue == NULL ? false : true);

		::SetLastError(validValues.dwLastError);

		VSL_RETURN_VALIDVALUES();
	}

	struct CreateDialogParamValidValues
	{
		// In
		HINSTANCE hInstance;
		LPCTSTR lpTemplateName;
		HWND hWndParent;
		DLGPROC lpDialogFunc;
		LPARAM dwInitParam;
		// Out
		DWORD dwErrorCode;
	};

	void CreateDialogParam(
		HINSTANCE hInstance,
		LPCTSTR lpTemplateName,
		HWND hWndParent,
		DLGPROC lpDialogFunc,
		LPARAM dwInitParam)
	{
		VSL_DEFINE_MOCK_METHOD(CreateDialogParam);

		VSL_CHECK_VALIDVALUE(hInstance);
		VSL_CHECK_VALIDVALUE(lpTemplateName);
		VSL_CHECK_VALIDVALUE(hWndParent);
		VSL_CHECK_VALIDVALUE(lpDialogFunc);
		VSL_CHECK_VALIDVALUE(dwInitParam);

		::SetLastError(validValues.dwErrorCode);

		m_bCreated = validValues.dwErrorCode == 0 ? true : false;
	}

	struct MoveWindowValidValues
	{
		// In
		int x;
		int y;
		int nWidth;
		int nHeight;
		BOOL bRepaint;
		// Out
		BOOL bRet;
	};

	BOOL MoveWindow(
		int x,
		int y,
		int nWidth,
		int nHeight,
		BOOL bRepaint = TRUE)
	{
		VSL_DEFINE_MOCK_METHOD(MoveWindow);

		VSL_CHECK_VALIDVALUE(x);
		VSL_CHECK_VALIDVALUE(y);
		VSL_CHECK_VALIDVALUE(nWidth);
		VSL_CHECK_VALIDVALUE(nHeight);
		VSL_CHECK_VALIDVALUE(bRepaint);

		return validValues.bRet;
	}

	struct ShowWindowValidValues
	{
		// In
		int nCmdShow;
		// Out
		BOOL bRet;
	};

	BOOL ShowWindow(int nCmdShow)
	{
		VSL_DEFINE_MOCK_METHOD(ShowWindow);

		VSL_CHECK_VALIDVALUE(nCmdShow);

		return validValues.bRet;
	}

	struct IsDialogMessageValidValues
	{
		// In
		LPMSG lpMsg;
		// Out
		BOOL bRet;
	};
	
	BOOL IsDialogMessage(LPMSG lpMsg)
	{
		VSL_DEFINE_MOCK_METHOD(IsDialogMessage);

		VSL_CHECK_VALIDVALUE(lpMsg);

		return validValues.bRet;
	}

	struct SendDlgItemMessageValidValues
	{
		// In
		int nID;
		UINT message;
		WPARAM wParam;
		LPARAM lParam;
		// Out
		LRESULT retValue;
	};

	LRESULT SendDlgItemMessage(
		int nID,
		UINT message,
		WPARAM wParam = 0,
		LPARAM lParam = 0)
	{
		VSL_DEFINE_MOCK_METHOD(SendDlgItemMessage);

		VSL_CHECK_VALIDVALUE(nID);
		VSL_CHECK_VALIDVALUE(message);
		VSL_CHECK_VALIDVALUE(wParam);
		VSL_CHECK_VALIDVALUE(lParam);

		return validValues.retValue;
	}

	struct GetDlgItemValidValues
	{
		// In
		int nID;
		// Out
		HWND retValue;
	};

	HWND GetDlgItem(int nID) const
	{
		VSL_DEFINE_MOCK_METHOD(GetDlgItem);

		VSL_CHECK_VALIDVALUE(nID);

		return validValues.retValue;
	}

	struct SetWindowTextValidValues
	{
		// In
		LPCTSTR lpszString;
		// Out
		BOOL retValue;
	};

	BOOL SetWindowText(LPCTSTR lpszString)
	{
		VSL_DEFINE_MOCK_METHOD(SetWindowText);

		VSL_CHECK_VALIDVALUE_STRING(lpszString);

		VSL_RETURN_VALIDVALUES();
	}

	HWND GetHWND()
	{
		return reinterpret_cast<HWND>(m_bCreated);
	}


	template<class WPARAM_T, class LPARAM_T>
	struct SendMessageValidValues
	{
		UINT uMsg;
		WPARAM_T wParam;
		LPARAM_T lParam;
		LRESULT retValue;
	};

	template<class WPARAM_T, class LPARAM_T>
	class SendMessageTraits
	{
	public:
		static void wParam(const SendMessageValidValues<WPARAM_T, LPARAM_T>& /*validValues*/, WPARAM_T /*wParam*/)
		{
		}
		static void lParam(const SendMessageValidValues<WPARAM_T, LPARAM_T>& /*validValues*/, LPARAM_T /*lParam*/)
		{
		}
	};

	template<>
	class SendMessageTraits<int, int>
	{
	public:
		static void wParam(const SendMessageValidValues<int, int>& validValues, int wParam)
		{
			VSL_CHECK_VALIDVALUE(wParam);
		}
		static void lParam(const SendMessageValidValues<int , int>& validValues, int lParam)
		{
			VSL_CHECK_VALIDVALUE(lParam);
		}
	};

	template<>
	class SendMessageTraits<int, IUnknown**>
	{
	public:
		static void wParam(const SendMessageValidValues<int, IUnknown**>& /*validValues*/, int /*wParam*/)
		{
		}
		static void lParam(const SendMessageValidValues<int, IUnknown**>& validValues, IUnknown** lParam)
		{
			VSL_SET_VALIDVALUE_INTERFACE(lParam);
		}
	};

	template<>
	class SendMessageTraits<unsigned int, WCHAR*>
	{
	public:
		static void wParam(const SendMessageValidValues<unsigned int, WCHAR*>& /*validValues*/, int /*wParam*/)
		{
		}
		static void lParam(const SendMessageValidValues<unsigned int, WCHAR*>& validValues, WCHAR* lParam)
		{
			// The first word of the lParam tells us the size of the array
			WORD cchText = reinterpret_cast<WORD *>(lParam)[0];
			::wcscpy_s(lParam, cchText, validValues.lParam);
		}
	};

#ifdef _RICHEDIT_
	template<>
	class SendMessageTraits<int, EDITSTREAM*>
	{
	public:
		static void wParam(const SendMessageValidValues<int, EDITSTREAM*>& validValues, int wParam)
		{
			VSL_CHECK_VALIDVALUE(wParam);
		}
		static void lParam(const SendMessageValidValues<int, EDITSTREAM*>& validValues, EDITSTREAM* lParam)
		{
			VSL_SET_VALIDVALUE(lParam);
		}
	};
#endif // _RICHEDIT_

	template<class WPARAM_T, class LPARAM_T>
	LRESULT SendMessage(UINT uMsg, WPARAM_T wParam, LPARAM_T lParam) const
	{
		Called<This::ClassMethod, reinterpret_cast<This::ClassMethod>(&This::SendMessage<WPARAM_T, LPARAM_T>)>();

		if(GetValidValuesQueue<SendMessageValidValues<WPARAM_T, LPARAM_T> >().empty())
		{
			return 0;
		}

		const SendMessageValidValues<WPARAM_T, LPARAM_T> validValues = GetValidValuesQueue<SendMessageValidValues<WPARAM_T, LPARAM_T> >().front();
		GetValidValuesQueue<SendMessageValidValues<WPARAM_T, LPARAM_T> >().pop();

		VSL_CHECK_VALIDVALUE(uMsg);

		SendMessageTraits<WPARAM_T, LPARAM_T>::wParam(validValues, wParam);

		SendMessageTraits<WPARAM_T, LPARAM_T>::lParam(validValues, lParam);

		VSL_RETURN_VALIDVALUES();
	}

	UINT_PTR SetTimer(UINT_PTR /*nIDEvent*/, UINT /*nElapse*/, void (CALLBACK* /*lpfnTimer*/)(HWND, UINT, UINT_PTR, DWORD) = NULL)
	{
		return 1;
	}

	LONG_PTR SetWindowLongPtr(int /*nIndex*/, LONG_PTR /*dwNewLong*/)
	{
		return NULL;
	}

	struct GetWindowLongPtrWValidValues
	{
		int nIndex;
		LONG_PTR retValue;
	};

	LONG_PTR GetWindowLongPtr(int nIndex) const
	{
		VSL_DEFINE_MOCK_METHOD(GetWindowLongPtrW);

		VSL_CHECK_VALIDVALUE(nIndex);

		VSL_RETURN_VALIDVALUES();
	}

	BOOL DestroyWindow()
	{
		return TRUE;
	}

	HWND SetFocus()
	{
		return NULL;
	}

	BOOL InvalidateRect(LPCRECT /*lpRect*/, BOOL /*bErase*/ = TRUE)
	{
		return TRUE;
	}

	BOOL UpdateWindow()
	{
		return TRUE;
	}

	LRESULT CallWindowProc(
		_In_ WNDPROC /*pWndProc*/,
		_In_ UINT /*msg*/,
		_In_ WPARAM /*wParam*/,
		_In_ LPARAM /*lParam*/)
	{
		return 0;
	}

	BOOL ClientToScreen(LPPOINT /*lpPoint*/) const
	{
		return TRUE;
	}

	bool IsWindow()
	{
		return m_bCreated;
	}

	static HWND GetActiveWindow()
	{
		return reinterpret_cast<HWND>(1);
	}

	DWORD GetWindowProcessID()
	{
		return ::GetCurrentProcessId();
	}

	BOOL KillTimer(_In_ UINT_PTR/*uIDEvent*/)
	{
		return TRUE;
	}

protected:
	bool m_bCreated;
};

class CursorMock
{

VSL_DECLARE_NOT_COPYABLE(CursorMock)

private:

	// FUTURE - could add default construction, not needed currently
	CursorMock();

public:

	CursorMock(_In_ LPWSTR /*szCursorName*/, HINSTANCE /*hInstance*/ = NULL)
	{
	}

	~CursorMock()
	{
	}

	HCURSOR Activate()
	{
		return NULL;
	}

};

class KeyboardMock :
	public MockBase
{
public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(KeyboardMock)

	struct IsKeyDownValidValues
	{
		int nVirtKey;
		bool retValue;
	};

	static bool IsKeyDown(_In_ int nVirtKey)
	{
		VSL_DEFINE_MOCK_STATIC_METHOD(IsKeyDown);

		VSL_CHECK_VALIDVALUE(nVirtKey);

		VSL_RETURN_VALIDVALUES();
	}
};

// REVIEW - is this necessary, or can the normal class be used with a little tweaking?
template <class Control_T, class WindowBase_T = WindowMock>
class Win32ControlContainerMock :
	public WindowBase_T
{
public:
	typedef Control_T Control;

	static const unsigned short iContainedControlID = 1;

	__if_exists(_U_RECT)
	{
	void Create(HWND hWndParent, _U_RECT rect)
	{
		m_bCreated = true;
		m_Control.Create(hWndParent, iContainedControlID, rect);
	}
	}

// Can't have a dependency on VSLWindows.h here, need to move these mocks elsewhere
//VSL_BEGIN_MSG_MAP(Win32ControlContainer)
BEGIN_MSG_MAP(Win32ControlContainer)
	MESSAGE_HANDLER(WM_SIZE, OnSize)
//	MESSAGE_HANDLER(WM_SETFOCUS, OnSetFocus)
//	REFLECT_NOTIFICATIONS()
//VSL_END_MSG_MAP()
END_MSG_MAP()

	LRESULT OnSize(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
	{
		(uMsg, wParam, lParam, bHandled);
		return 0;
	}
protected:
	Control_T& GetControl()
	{
		return m_Control;
	}

	void Destroy()
	{
		__if_exists(Control::Destroy)
		{
			m_Control.Destroy();
		}
	}

private:
	Control_T m_Control;
};

#endif // __ATLWIN_H__

class FileMock :
	public MockBase
{
public:

	VSL_DEFINE_MOCK_CLASS_TYPDEFS(FileMock);

	FileMock() :
		m_szFullPathName(),
		bHandleSet(false)
	{
	}

	// Does not open the file handle
	explicit FileMock(_In_z_ const wchar_t* szFullPathName) :
		m_szFullPathName(szFullPathName),
		bHandleSet(false)
	{
	}

	const ATL::CStringW& GetFullPathName() const
	{
		return m_szFullPathName;
	}

	ATL::CStringW& GetFullPathName()
	{
		return m_szFullPathName;
	}

	operator const wchar_t*() const
	{
		return m_szFullPathName;
	}

	struct IsFileReadOnlyValidValues
	{
		bool retValue;
	};

	bool IsFileReadOnly()
	{
		VSL_DEFINE_MOCK_METHOD_NOARGS(IsFileReadOnly);

		VSL_RETURN_VALIDVALUES();
	}

	void Create(
		_In_ DWORD dwDesiredAccess,
		_In_ DWORD dwShareMode,
		_In_ DWORD dwCreationDisposition,
		_In_ DWORD dwFlagsAndAttributes = FILE_ATTRIBUTE_NORMAL,
		_In_opt_ LPSECURITY_ATTRIBUTES lpsa = NULL,
		_In_opt_ HANDLE hTemplateFile = NULL)
	{
		VSL_DEFINE_MOCK_METHOD_NOARGS_NORETURN(Close);

		VSL_CHECKBOOLEAN(!m_szFullPathName.IsEmpty(), E_FAIL);

		bHandleSet = true;

		(dwDesiredAccess, dwShareMode, dwCreationDisposition, dwFlagsAndAttributes, lpsa, hTemplateFile);
	}

	struct IsZeroLengthValidValues
	{
		bool retValue;
	};

	bool IsZeroLength()
	{
		VSL_DEFINE_MOCK_METHOD_NOARGS(IsZeroLength);

		VSL_RETURN_VALIDVALUES();
	}

	void Close()
	{
		VSL_DEFINE_MOCK_METHOD_NOARGS_NORETURN(Close);

		bHandleSet = false;
	}

	operator HANDLE()
	{
		return bHandleSet ? reinterpret_cast<HANDLE>(1) : NULL;
	}

	struct GetFileTypeValidValues
	{
		DWORD retValue;
	};

	DWORD GetFileType()
	{
		VSL_DEFINE_MOCK_METHOD_NOARGS(GetFileType);

		VSL_RETURN_VALIDVALUES();
	}

	bool IsOnDisk()
	{
		return FILE_TYPE_DISK == GetFileType();
	}

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512)  // assignment operator could not be generated
	struct ReadValidValues
	{
		LPVOID pBuffer;
		DWORD nBufSize;
		DWORD& nBytesRead;
		HRESULT hrException;
	};
#pragma warning(pop)

	void Read(
		_Out_bytecap_(nBufSize) LPVOID pBuffer,
		_In_ DWORD nBufSize,
		_Out_ DWORD& nBytesRead)
	{
		VSL_DEFINE_MOCK_METHOD(Read);

		VSL_CHECK_VALIDVALUE(nBufSize);

		VSL_SET_VALIDVALUE_REFERENCE(nBytesRead);

		VSL_CHECKHRESULT(validValues.hrException);

		VSL_SET_VALIDVALUE_MEMCPY(pBuffer, nBufSize, validValues.nBufSize);
	}

	struct WriteValidValues
	{
		LPCVOID pBuffer;
		DWORD nBufSize;
		DWORD* pnBytesWritten;
		HRESULT hrException;
	};

	void Write(
		_In_bytecount_(nBufSize) LPCVOID pBuffer,
		_In_ DWORD nBufSize,
		_Out_opt_ DWORD* pnBytesWritten = NULL)
	{
		VSL_DEFINE_MOCK_METHOD(Write);

		VSL_CHECK_VALIDVALUE(pBuffer);

		VSL_CHECK_VALIDVALUE(nBufSize);

		VSL_CHECKHRESULT(validValues.hrException);

		VSL_SET_VALIDVALUE(pnBytesWritten);
	}

	void Seek(_In_ LONGLONG nOffset, _In_ DWORD dwFrom = FILE_CURRENT)
	{
		(nOffset, dwFrom);
	}

	ATL::CStringW m_szFullPathName;
	bool bHandleSet;
};

} // namespace VSL

#endif VSLUNITTEST_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockFolderProperties.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef FOLDERPROPERTIES_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define FOLDERPROPERTIES_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "vslangproj.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class FolderPropertiesNotImpl :
	public FolderProperties
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(FolderPropertiesNotImpl)

public:

	typedef FolderProperties Interface;

	STDMETHOD(get___id)(
		/*[out,retval]*/ BSTR* /*pbstrName*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_FileName)(
		/*[out,retval]*/ BSTR* /*pbstrName*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(put_FileName)(
		/*[in]*/ BSTR /*bstrName*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_LocalPath)(
		/*[out,retval]*/ BSTR* /*pbstrLocalPath*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_FullPath)(
		/*[out,retval]*/ BSTR* /*pbstrFullPath*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_URL)(
		/*[out,retval]*/ BSTR* /*pbstrURL*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_Extender)(
		/*[in]*/ BSTR /*ExtenderName*/,
		/*[out,retval]*/ IDispatch** /*Extender*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_ExtenderNames)(
		/*[out,retval]*/ VARIANT* /*ExtenderNames*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_ExtenderCATID)(
		/*[out,retval]*/ BSTR* /*pRetval*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_WebReference)(
		/*[out,retval]*/ BSTR* /*pbstrWebReferenceUrl*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(put_WebReference)(
		/*[in]*/ BSTR /*bstrWebReferenceUrl*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_DefaultNamespace)(
		/*[out,retval]*/ BSTR* /*pbstrNamespace*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_UrlBehavior)(
		/*[out,retval]*/ webrefUrlBehavior* /*pUrlBehavior*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(put_UrlBehavior)(
		/*[in]*/ webrefUrlBehavior /*urlBehavior*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetTypeInfoCount)(
		/*[out]*/ UINT* /*pctinfo*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetTypeInfo)(
		/*[in]*/ UINT /*iTInfo*/,
		/*[in]*/ LCID /*lcid*/,
		/*[out]*/ ITypeInfo** /*ppTInfo*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetIDsOfNames)(
		/*[in]*/ REFIID /*riid*/,
		/*[in,size_is(cNames)]*/ LPOLESTR* /*rgszNames*/,
		/*[in]*/ UINT /*cNames*/,
		/*[in]*/ LCID /*lcid*/,
		/*[out,size_is(cNames)]*/ DISPID* /*rgDispId*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(Invoke)(
		/*[in]*/ DISPID /*dispIdMember*/,
		/*[in]*/ REFIID /*riid*/,
		/*[in]*/ LCID /*lcid*/,
		/*[in]*/ WORD /*wFlags*/,
		/*[in,out]*/ DISPPARAMS* /*pDispParams*/,
		/*[out]*/ VARIANT* /*pVarResult*/,
		/*[out]*/ EXCEPINFO* /*pExcepInfo*/,
		/*[out]*/ UINT* /*puArgErr*/)VSL_STDMETHOD_NOTIMPL
};

class FolderPropertiesMockImpl :
	public FolderProperties,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(FolderPropertiesMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(FolderPropertiesMockImpl)

	typedef FolderProperties Interface;
	struct get___idValidValues
	{
		/*[out,retval]*/ BSTR* pbstrName;
		HRESULT retValue;
	};

	STDMETHOD(get___id)(
		/*[out,retval]*/ BSTR* pbstrName)
	{
		VSL_DEFINE_MOCK_METHOD(get___id)

		VSL_SET_VALIDVALUE_BSTR(pbstrName);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_FileNameValidValues
	{
		/*[out,retval]*/ BSTR* pbstrName;
		HRESULT retValue;
	};

	STDMETHOD(get_FileName)(
		/*[out,retval]*/ BSTR* pbstrName)
	{
		VSL_DEFINE_MOCK_METHOD(get_FileName)

		VSL_SET_VALIDVALUE_BSTR(pbstrName);

		VSL_RETURN_VALIDVALUES();
	}
	struct put_FileNameValidValues
	{
		/*[in]*/ BSTR bstrName;
		HRESULT retValue;
	};

	STDMETHOD(put_FileName)(
		/*[in]*/ BSTR bstrName)
	{
		VSL_DEFINE_MOCK_METHOD(put_FileName)

		VSL_CHECK_VALIDVALUE_BSTR(bstrName);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_LocalPathValidValues
	{
		/*[out,retval]*/ BSTR* pbstrLocalPath;
		HRESULT retValue;
	};

	STDMETHOD(get_LocalPath)(
		/*[out,retval]*/ BSTR* pbstrLocalPath)
	{
		VSL_DEFINE_MOCK_METHOD(get_LocalPath)

		VSL_SET_VALIDVALUE_BSTR(pbstrLocalPath);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_FullPathValidValues
	{
		/*[out,retval]*/ BSTR* pbstrFullPath;
		HRESULT retValue;
	};

	STDMETHOD(get_FullPath)(
		/*[out,retval]*/ BSTR* pbstrFullPath)
	{
		VSL_DEFINE_MOCK_METHOD(get_FullPath)

		VSL_SET_VALIDVALUE_BSTR(pbstrFullPath);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_URLValidValues
	{
		/*[out,retval]*/ BSTR* pbstrURL;
		HRESULT retValue;
	};

	STDMETHOD(get_URL)(
		/*[out,retval]*/ BSTR* pbstrURL)
	{
		VSL_DEFINE_MOCK_METHOD(get_URL)

		VSL_SET_VALIDVALUE_BSTR(pbstrURL);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_ExtenderValidValues
	{
		/*[in]*/ BSTR ExtenderName;
		/*[out,retval]*/ IDispatch** Extender;
		HRESULT retValue;
	};

	STDMETHOD(get_Extender)(
		/*[in]*/ BSTR ExtenderName,
		/*[out,retval]*/ IDispatch** Extender)
	{
		VSL_DEFINE_MOCK_METHOD(get_Extender)

		VSL_CHECK_VALIDVALUE_BSTR(ExtenderName);

		VSL_SET_VALIDVALUE_INTERFACE(Extender);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_ExtenderNamesValidValues
	{
		/*[out,retval]*/ VARIANT* ExtenderNames;
		HRESULT retValue;
	};

	STDMETHOD(get_ExtenderNames)(
		/*[out,retval]*/ VARIANT* ExtenderNames)
	{
		VSL_DEFINE_MOCK_METHOD(get_ExtenderNames)

		VSL_SET_VALIDVALUE_VARIANT(ExtenderNames);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_ExtenderCATIDValidValues
	{
		/*[out,retval]*/ BSTR* pRetval;
		HRESULT retValue;
	};

	STDMETHOD(get_ExtenderCATID)(
		/*[out,retval]*/ BSTR* pRetval)
	{
		VSL_DEFINE_MOCK_METHOD(get_ExtenderCATID)

		VSL_SET_VALIDVALUE_BSTR(pRetval);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_WebReferenceValidValues
	{
		/*[out,retval]*/ BSTR* pbstrWebReferenceUrl;
		HRESULT retValue;
	};

	STDMETHOD(get_WebReference)(
		/*[out,retval]*/ BSTR* pbstrWebReferenceUrl)
	{
		VSL_DEFINE_MOCK_METHOD(get_WebReference)

		VSL_SET_VALIDVALUE_BSTR(pbstrWebReferenceUrl);

		VSL_RETURN_VALIDVALUES();
	}
	struct put_WebReferenceValidValues
	{
		/*[in]*/ BSTR bstrWebReferenceUrl;
		HRESULT retValue;
	};

	STDMETHOD(put_WebReference)(
		/*[in]*/ BSTR bstrWebReferenceUrl)
	{
		VSL_DEFINE_MOCK_METHOD(put_WebReference)

		VSL_CHECK_VALIDVALUE_BSTR(bstrWebReferenceUrl);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_DefaultNamespaceValidValues
	{
		/*[out,retval]*/ BSTR* pbstrNamespace;
		HRESULT retValue;
	};

	STDMETHOD(get_DefaultNamespace)(
		/*[out,retval]*/ BSTR* pbstrNamespace)
	{
		VSL_DEFINE_MOCK_METHOD(get_DefaultNamespace)

		VSL_SET_VALIDVALUE_BSTR(pbstrNamespace);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_UrlBehaviorValidValues
	{
		/*[out,retval]*/ webrefUrlBehavior* pUrlBehavior;
		HRESULT retValue;
	};

	STDMETHOD(get_UrlBehavior)(
		/*[out,retval]*/ webrefUrlBehavior* pUrlBehavior)
	{
		VSL_DEFINE_MOCK_METHOD(get_UrlBehavior)

		VSL_SET_VALIDVALUE(pUrlBehavior);

		VSL_RETURN_VALIDVALUES();
	}
	struct put_UrlBehaviorValidValues
	{
		/*[in]*/ webrefUrlBehavior urlBehavior;
		HRESULT retValue;
	};

	STDMETHOD(put_UrlBehavior)(
		/*[in]*/ webrefUrlBehavior urlBehavior)
	{
		VSL_DEFINE_MOCK_METHOD(put_UrlBehavior)

		VSL_CHECK_VALIDVALUE(urlBehavior);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetTypeInfoCountValidValues
	{
		/*[out]*/ UINT* pctinfo;
		HRESULT retValue;
	};

	STDMETHOD(GetTypeInfoCount)(
		/*[out]*/ UINT* pctinfo)
	{
		VSL_DEFINE_MOCK_METHOD(GetTypeInfoCount)

		VSL_SET_VALIDVALUE(pctinfo);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetTypeInfoValidValues
	{
		/*[in]*/ UINT iTInfo;
		/*[in]*/ LCID lcid;
		/*[out]*/ ITypeInfo** ppTInfo;
		HRESULT retValue;
	};

	STDMETHOD(GetTypeInfo)(
		/*[in]*/ UINT iTInfo,
		/*[in]*/ LCID lcid,
		/*[out]*/ ITypeInfo** ppTInfo)
	{
		VSL_DEFINE_MOCK_METHOD(GetTypeInfo)

		VSL_CHECK_VALIDVALUE(iTInfo);

		VSL_CHECK_VALIDVALUE(lcid);

		VSL_SET_VALIDVALUE_INTERFACE(ppTInfo);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetIDsOfNamesValidValues
	{
		/*[in]*/ REFIID riid;
		/*[in,size_is(cNames)]*/ LPOLESTR* rgszNames;
		/*[in]*/ UINT cNames;
		/*[in]*/ LCID lcid;
		/*[out,size_is(cNames)]*/ DISPID* rgDispId;
		HRESULT retValue;
	};

	STDMETHOD(GetIDsOfNames)(
		/*[in]*/ REFIID riid,
		/*[in,size_is(cNames)]*/ LPOLESTR* rgszNames,
		/*[in]*/ UINT cNames,
		/*[in]*/ LCID lcid,
		/*[out,size_is(cNames)]*/ DISPID* rgDispId)
	{
		VSL_DEFINE_MOCK_METHOD(GetIDsOfNames)

		VSL_CHECK_VALIDVALUE(riid);

		VSL_CHECK_VALIDVALUE_MEMCMP(rgszNames, cNames*sizeof(rgszNames[0]), validValues.cNames*sizeof(validValues.rgszNames[0]));

		VSL_CHECK_VALIDVALUE(cNames);

		VSL_CHECK_VALIDVALUE(lcid);

		VSL_SET_VALIDVALUE_MEMCPY(rgDispId, cNames*sizeof(rgDispId[0]), validValues.cNames*sizeof(validValues.rgDispId[0]));

		VSL_RETURN_VALIDVALUES();
	}
	struct InvokeValidValues
	{
		/*[in]*/ DISPID dispIdMember;
		/*[in]*/ REFIID riid;
		/*[in]*/ LCID lcid;
		/*[in]*/ WORD wFlags;
		/*[in,out]*/ DISPPARAMS* pDispParams;
		/*[out]*/ VARIANT* pVarResult;
		/*[out]*/ EXCEPINFO* pExcepInfo;
		/*[out]*/ UINT* puArgErr;
		HRESULT retValue;
	};

	STDMETHOD(Invoke)(
		/*[in]*/ DISPID dispIdMember,
		/*[in]*/ REFIID riid,
		/*[in]*/ LCID lcid,
		/*[in]*/ WORD wFlags,
		/*[in,out]*/ DISPPARAMS* pDispParams,
		/*[out]*/ VARIANT* pVarResult,
		/*[out]*/ EXCEPINFO* pExcepInfo,
		/*[out]*/ UINT* puArgErr)
	{
		VSL_DEFINE_MOCK_METHOD(Invoke)

		VSL_CHECK_VALIDVALUE(dispIdMember);

		VSL_CHECK_VALIDVALUE(riid);

		VSL_CHECK_VALIDVALUE(lcid);

		VSL_CHECK_VALIDVALUE(wFlags);

		VSL_SET_VALIDVALUE(pDispParams);

		VSL_SET_VALIDVALUE_VARIANT(pVarResult);

		VSL_SET_VALIDVALUE(pExcepInfo);

		VSL_SET_VALIDVALUE(puArgErr);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // FOLDERPROPERTIES_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockFileProperties.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef FILEPROPERTIES_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define FILEPROPERTIES_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "vslangproj.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class FilePropertiesNotImpl :
	public FileProperties
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(FilePropertiesNotImpl)

public:

	typedef FileProperties Interface;

	STDMETHOD(get___id)(
		/*[out,retval]*/ BSTR* /*pbstrName*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_FileName)(
		/*[out,retval]*/ BSTR* /*pbstrName*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(put_FileName)(
		/*[in]*/ BSTR /*bstrName*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_Extension)(
		/*[out,retval]*/ BSTR* /*pbstrExtension*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_Filesize)(
		/*[out,retval]*/ unsigned long* /*pdwSize*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_LocalPath)(
		/*[out,retval]*/ BSTR* /*pbstrLocalPath*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_FullPath)(
		/*[out,retval]*/ BSTR* /*pbstrFullPath*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_URL)(
		/*[out,retval]*/ BSTR* /*pbstrURL*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_HTMLTitle)(
		/*[out,retval]*/ BSTR* /*pbstrTitle*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_Author)(
		/*[out,retval]*/ BSTR* /*pbstrTitle*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_DateCreated)(
		/*[out,retval]*/ BSTR* /*pbstrDateCreated*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_DateModified)(
		/*[out,retval]*/ BSTR* /*pbstrDateCreated*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_ModifiedBy)(
		/*[out,retval]*/ BSTR* /*pbstrDateCreated*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_SubType)(
		/*[out,retval]*/ BSTR* /*pbstrSubType*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(put_SubType)(
		/*[in]*/ BSTR /*bstrSubType*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_Extender)(
		/*[in]*/ BSTR /*ExtenderName*/,
		/*[out,retval]*/ IDispatch** /*Extender*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_ExtenderNames)(
		/*[out,retval]*/ VARIANT* /*ExtenderNames*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_ExtenderCATID)(
		/*[out,retval]*/ BSTR* /*pRetval*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_BuildAction)(
		/*[out,retval]*/ prjBuildAction* /*pbuildAction*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(put_BuildAction)(
		/*[in]*/ prjBuildAction /*buildAction*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_CustomTool)(
		/*[out,retval]*/ BSTR* /*pbstrCustomTool*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(put_CustomTool)(
		/*[in]*/ BSTR /*bstrCustomTool*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_CustomToolNamespace)(
		/*[out,retval]*/ BSTR* /*pbstrCustomToolNamespace*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(put_CustomToolNamespace)(
		/*[in]*/ BSTR /*bstrCustomToolNamespace*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_CustomToolOutput)(
		/*[out,retval]*/ BSTR* /*pbstrCustomToolOutput*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_IsCustomToolOutput)(
		/*[out,retval]*/ VARIANT_BOOL* /*pbIsCustomToolOutput*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_IsDependentFile)(
		/*[out,retval]*/ VARIANT_BOOL* /*pbIsDepedentFile*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_IsLink)(
		/*[out,retval]*/ VARIANT_BOOL* /*pbIsLinkFile*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_IsDesignTimeBuildInput)(
		/*[out,retval]*/ VARIANT_BOOL* /*pbIsDesignTimeBuildInput*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetTypeInfoCount)(
		/*[out]*/ UINT* /*pctinfo*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetTypeInfo)(
		/*[in]*/ UINT /*iTInfo*/,
		/*[in]*/ LCID /*lcid*/,
		/*[out]*/ ITypeInfo** /*ppTInfo*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetIDsOfNames)(
		/*[in]*/ REFIID /*riid*/,
		/*[in,size_is(cNames)]*/ LPOLESTR* /*rgszNames*/,
		/*[in]*/ UINT /*cNames*/,
		/*[in]*/ LCID /*lcid*/,
		/*[out,size_is(cNames)]*/ DISPID* /*rgDispId*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(Invoke)(
		/*[in]*/ DISPID /*dispIdMember*/,
		/*[in]*/ REFIID /*riid*/,
		/*[in]*/ LCID /*lcid*/,
		/*[in]*/ WORD /*wFlags*/,
		/*[in,out]*/ DISPPARAMS* /*pDispParams*/,
		/*[out]*/ VARIANT* /*pVarResult*/,
		/*[out]*/ EXCEPINFO* /*pExcepInfo*/,
		/*[out]*/ UINT* /*puArgErr*/)VSL_STDMETHOD_NOTIMPL
};

class FilePropertiesMockImpl :
	public FileProperties,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(FilePropertiesMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(FilePropertiesMockImpl)

	typedef FileProperties Interface;
	struct get___idValidValues
	{
		/*[out,retval]*/ BSTR* pbstrName;
		HRESULT retValue;
	};

	STDMETHOD(get___id)(
		/*[out,retval]*/ BSTR* pbstrName)
	{
		VSL_DEFINE_MOCK_METHOD(get___id)

		VSL_SET_VALIDVALUE_BSTR(pbstrName);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_FileNameValidValues
	{
		/*[out,retval]*/ BSTR* pbstrName;
		HRESULT retValue;
	};

	STDMETHOD(get_FileName)(
		/*[out,retval]*/ BSTR* pbstrName)
	{
		VSL_DEFINE_MOCK_METHOD(get_FileName)

		VSL_SET_VALIDVALUE_BSTR(pbstrName);

		VSL_RETURN_VALIDVALUES();
	}
	struct put_FileNameValidValues
	{
		/*[in]*/ BSTR bstrName;
		HRESULT retValue;
	};

	STDMETHOD(put_FileName)(
		/*[in]*/ BSTR bstrName)
	{
		VSL_DEFINE_MOCK_METHOD(put_FileName)

		VSL_CHECK_VALIDVALUE_BSTR(bstrName);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_ExtensionValidValues
	{
		/*[out,retval]*/ BSTR* pbstrExtension;
		HRESULT retValue;
	};

	STDMETHOD(get_Extension)(
		/*[out,retval]*/ BSTR* pbstrExtension)
	{
		VSL_DEFINE_MOCK_METHOD(get_Extension)

		VSL_SET_VALIDVALUE_BSTR(pbstrExtension);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_FilesizeValidValues
	{
		/*[out,retval]*/ unsigned long* pdwSize;
		HRESULT retValue;
	};

	STDMETHOD(get_Filesize)(
		/*[out,retval]*/ unsigned long* pdwSize)
	{
		VSL_DEFINE_MOCK_METHOD(get_Filesize)

		VSL_SET_VALIDVALUE(pdwSize);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_LocalPathValidValues
	{
		/*[out,retval]*/ BSTR* pbstrLocalPath;
		HRESULT retValue;
	};

	STDMETHOD(get_LocalPath)(
		/*[out,retval]*/ BSTR* pbstrLocalPath)
	{
		VSL_DEFINE_MOCK_METHOD(get_LocalPath)

		VSL_SET_VALIDVALUE_BSTR(pbstrLocalPath);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_FullPathValidValues
	{
		/*[out,retval]*/ BSTR* pbstrFullPath;
		HRESULT retValue;
	};

	STDMETHOD(get_FullPath)(
		/*[out,retval]*/ BSTR* pbstrFullPath)
	{
		VSL_DEFINE_MOCK_METHOD(get_FullPath)

		VSL_SET_VALIDVALUE_BSTR(pbstrFullPath);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_URLValidValues
	{
		/*[out,retval]*/ BSTR* pbstrURL;
		HRESULT retValue;
	};

	STDMETHOD(get_URL)(
		/*[out,retval]*/ BSTR* pbstrURL)
	{
		VSL_DEFINE_MOCK_METHOD(get_URL)

		VSL_SET_VALIDVALUE_BSTR(pbstrURL);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_HTMLTitleValidValues
	{
		/*[out,retval]*/ BSTR* pbstrTitle;
		HRESULT retValue;
	};

	STDMETHOD(get_HTMLTitle)(
		/*[out,retval]*/ BSTR* pbstrTitle)
	{
		VSL_DEFINE_MOCK_METHOD(get_HTMLTitle)

		VSL_SET_VALIDVALUE_BSTR(pbstrTitle);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_AuthorValidValues
	{
		/*[out,retval]*/ BSTR* pbstrTitle;
		HRESULT retValue;
	};

	STDMETHOD(get_Author)(
		/*[out,retval]*/ BSTR* pbstrTitle)
	{
		VSL_DEFINE_MOCK_METHOD(get_Author)

		VSL_SET_VALIDVALUE_BSTR(pbstrTitle);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_DateCreatedValidValues
	{
		/*[out,retval]*/ BSTR* pbstrDateCreated;
		HRESULT retValue;
	};

	STDMETHOD(get_DateCreated)(
		/*[out,retval]*/ BSTR* pbstrDateCreated)
	{
		VSL_DEFINE_MOCK_METHOD(get_DateCreated)

		VSL_SET_VALIDVALUE_BSTR(pbstrDateCreated);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_DateModifiedValidValues
	{
		/*[out,retval]*/ BSTR* pbstrDateCreated;
		HRESULT retValue;
	};

	STDMETHOD(get_DateModified)(
		/*[out,retval]*/ BSTR* pbstrDateCreated)
	{
		VSL_DEFINE_MOCK_METHOD(get_DateModified)

		VSL_SET_VALIDVALUE_BSTR(pbstrDateCreated);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_ModifiedByValidValues
	{
		/*[out,retval]*/ BSTR* pbstrDateCreated;
		HRESULT retValue;
	};

	STDMETHOD(get_ModifiedBy)(
		/*[out,retval]*/ BSTR* pbstrDateCreated)
	{
		VSL_DEFINE_MOCK_METHOD(get_ModifiedBy)

		VSL_SET_VALIDVALUE_BSTR(pbstrDateCreated);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_SubTypeValidValues
	{
		/*[out,retval]*/ BSTR* pbstrSubType;
		HRESULT retValue;
	};

	STDMETHOD(get_SubType)(
		/*[out,retval]*/ BSTR* pbstrSubType)
	{
		VSL_DEFINE_MOCK_METHOD(get_SubType)

		VSL_SET_VALIDVALUE_BSTR(pbstrSubType);

		VSL_RETURN_VALIDVALUES();
	}
	struct put_SubTypeValidValues
	{
		/*[in]*/ BSTR bstrSubType;
		HRESULT retValue;
	};

	STDMETHOD(put_SubType)(
		/*[in]*/ BSTR bstrSubType)
	{
		VSL_DEFINE_MOCK_METHOD(put_SubType)

		VSL_CHECK_VALIDVALUE_BSTR(bstrSubType);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_ExtenderValidValues
	{
		/*[in]*/ BSTR ExtenderName;
		/*[out,retval]*/ IDispatch** Extender;
		HRESULT retValue;
	};

	STDMETHOD(get_Extender)(
		/*[in]*/ BSTR ExtenderName,
		/*[out,retval]*/ IDispatch** Extender)
	{
		VSL_DEFINE_MOCK_METHOD(get_Extender)

		VSL_CHECK_VALIDVALUE_BSTR(ExtenderName);

		VSL_SET_VALIDVALUE_INTERFACE(Extender);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_ExtenderNamesValidValues
	{
		/*[out,retval]*/ VARIANT* ExtenderNames;
		HRESULT retValue;
	};

	STDMETHOD(get_ExtenderNames)(
		/*[out,retval]*/ VARIANT* ExtenderNames)
	{
		VSL_DEFINE_MOCK_METHOD(get_ExtenderNames)

		VSL_SET_VALIDVALUE_VARIANT(ExtenderNames);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_ExtenderCATIDValidValues
	{
		/*[out,retval]*/ BSTR* pRetval;
		HRESULT retValue;
	};

	STDMETHOD(get_ExtenderCATID)(
		/*[out,retval]*/ BSTR* pRetval)
	{
		VSL_DEFINE_MOCK_METHOD(get_ExtenderCATID)

		VSL_SET_VALIDVALUE_BSTR(pRetval);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_BuildActionValidValues
	{
		/*[out,retval]*/ prjBuildAction* pbuildAction;
		HRESULT retValue;
	};

	STDMETHOD(get_BuildAction)(
		/*[out,retval]*/ prjBuildAction* pbuildAction)
	{
		VSL_DEFINE_MOCK_METHOD(get_BuildAction)

		VSL_SET_VALIDVALUE(pbuildAction);

		VSL_RETURN_VALIDVALUES();
	}
	struct put_BuildActionValidValues
	{
		/*[in]*/ prjBuildAction buildAction;
		HRESULT retValue;
	};

	STDMETHOD(put_BuildAction)(
		/*[in]*/ prjBuildAction buildAction)
	{
		VSL_DEFINE_MOCK_METHOD(put_BuildAction)

		VSL_CHECK_VALIDVALUE(buildAction);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_CustomToolValidValues
	{
		/*[out,retval]*/ BSTR* pbstrCustomTool;
		HRESULT retValue;
	};

	STDMETHOD(get_CustomTool)(
		/*[out,retval]*/ BSTR* pbstrCustomTool)
	{
		VSL_DEFINE_MOCK_METHOD(get_CustomTool)

		VSL_SET_VALIDVALUE_BSTR(pbstrCustomTool);

		VSL_RETURN_VALIDVALUES();
	}
	struct put_CustomToolValidValues
	{
		/*[in]*/ BSTR bstrCustomTool;
		HRESULT retValue;
	};

	STDMETHOD(put_CustomTool)(
		/*[in]*/ BSTR bstrCustomTool)
	{
		VSL_DEFINE_MOCK_METHOD(put_CustomTool)

		VSL_CHECK_VALIDVALUE_BSTR(bstrCustomTool);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_CustomToolNamespaceValidValues
	{
		/*[out,retval]*/ BSTR* pbstrCustomToolNamespace;
		HRESULT retValue;
	};

	STDMETHOD(get_CustomToolNamespace)(
		/*[out,retval]*/ BSTR* pbstrCustomToolNamespace)
	{
		VSL_DEFINE_MOCK_METHOD(get_CustomToolNamespace)

		VSL_SET_VALIDVALUE_BSTR(pbstrCustomToolNamespace);

		VSL_RETURN_VALIDVALUES();
	}
	struct put_CustomToolNamespaceValidValues
	{
		/*[in]*/ BSTR bstrCustomToolNamespace;
		HRESULT retValue;
	};

	STDMETHOD(put_CustomToolNamespace)(
		/*[in]*/ BSTR bstrCustomToolNamespace)
	{
		VSL_DEFINE_MOCK_METHOD(put_CustomToolNamespace)

		VSL_CHECK_VALIDVALUE_BSTR(bstrCustomToolNamespace);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_CustomToolOutputValidValues
	{
		/*[out,retval]*/ BSTR* pbstrCustomToolOutput;
		HRESULT retValue;
	};

	STDMETHOD(get_CustomToolOutput)(
		/*[out,retval]*/ BSTR* pbstrCustomToolOutput)
	{
		VSL_DEFINE_MOCK_METHOD(get_CustomToolOutput)

		VSL_SET_VALIDVALUE_BSTR(pbstrCustomToolOutput);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_IsCustomToolOutputValidValues
	{
		/*[out,retval]*/ VARIANT_BOOL* pbIsCustomToolOutput;
		HRESULT retValue;
	};

	STDMETHOD(get_IsCustomToolOutput)(
		/*[out,retval]*/ VARIANT_BOOL* pbIsCustomToolOutput)
	{
		VSL_DEFINE_MOCK_METHOD(get_IsCustomToolOutput)

		VSL_SET_VALIDVALUE(pbIsCustomToolOutput);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_IsDependentFileValidValues
	{
		/*[out,retval]*/ VARIANT_BOOL* pbIsDepedentFile;
		HRESULT retValue;
	};

	STDMETHOD(get_IsDependentFile)(
		/*[out,retval]*/ VARIANT_BOOL* pbIsDepedentFile)
	{
		VSL_DEFINE_MOCK_METHOD(get_IsDependentFile)

		VSL_SET_VALIDVALUE(pbIsDepedentFile);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_IsLinkValidValues
	{
		/*[out,retval]*/ VARIANT_BOOL* pbIsLinkFile;
		HRESULT retValue;
	};

	STDMETHOD(get_IsLink)(
		/*[out,retval]*/ VARIANT_BOOL* pbIsLinkFile)
	{
		VSL_DEFINE_MOCK_METHOD(get_IsLink)

		VSL_SET_VALIDVALUE(pbIsLinkFile);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_IsDesignTimeBuildInputValidValues
	{
		/*[out,retval]*/ VARIANT_BOOL* pbIsDesignTimeBuildInput;
		HRESULT retValue;
	};

	STDMETHOD(get_IsDesignTimeBuildInput)(
		/*[out,retval]*/ VARIANT_BOOL* pbIsDesignTimeBuildInput)
	{
		VSL_DEFINE_MOCK_METHOD(get_IsDesignTimeBuildInput)

		VSL_SET_VALIDVALUE(pbIsDesignTimeBuildInput);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetTypeInfoCountValidValues
	{
		/*[out]*/ UINT* pctinfo;
		HRESULT retValue;
	};

	STDMETHOD(GetTypeInfoCount)(
		/*[out]*/ UINT* pctinfo)
	{
		VSL_DEFINE_MOCK_METHOD(GetTypeInfoCount)

		VSL_SET_VALIDVALUE(pctinfo);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetTypeInfoValidValues
	{
		/*[in]*/ UINT iTInfo;
		/*[in]*/ LCID lcid;
		/*[out]*/ ITypeInfo** ppTInfo;
		HRESULT retValue;
	};

	STDMETHOD(GetTypeInfo)(
		/*[in]*/ UINT iTInfo,
		/*[in]*/ LCID lcid,
		/*[out]*/ ITypeInfo** ppTInfo)
	{
		VSL_DEFINE_MOCK_METHOD(GetTypeInfo)

		VSL_CHECK_VALIDVALUE(iTInfo);

		VSL_CHECK_VALIDVALUE(lcid);

		VSL_SET_VALIDVALUE_INTERFACE(ppTInfo);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetIDsOfNamesValidValues
	{
		/*[in]*/ REFIID riid;
		/*[in,size_is(cNames)]*/ LPOLESTR* rgszNames;
		/*[in]*/ UINT cNames;
		/*[in]*/ LCID lcid;
		/*[out,size_is(cNames)]*/ DISPID* rgDispId;
		HRESULT retValue;
	};

	STDMETHOD(GetIDsOfNames)(
		/*[in]*/ REFIID riid,
		/*[in,size_is(cNames)]*/ LPOLESTR* rgszNames,
		/*[in]*/ UINT cNames,
		/*[in]*/ LCID lcid,
		/*[out,size_is(cNames)]*/ DISPID* rgDispId)
	{
		VSL_DEFINE_MOCK_METHOD(GetIDsOfNames)

		VSL_CHECK_VALIDVALUE(riid);

		VSL_CHECK_VALIDVALUE_MEMCMP(rgszNames, cNames*sizeof(rgszNames[0]), validValues.cNames*sizeof(validValues.rgszNames[0]));

		VSL_CHECK_VALIDVALUE(cNames);

		VSL_CHECK_VALIDVALUE(lcid);

		VSL_SET_VALIDVALUE_MEMCPY(rgDispId, cNames*sizeof(rgDispId[0]), validValues.cNames*sizeof(validValues.rgDispId[0]));

		VSL_RETURN_VALIDVALUES();
	}
	struct InvokeValidValues
	{
		/*[in]*/ DISPID dispIdMember;
		/*[in]*/ REFIID riid;
		/*[in]*/ LCID lcid;
		/*[in]*/ WORD wFlags;
		/*[in,out]*/ DISPPARAMS* pDispParams;
		/*[out]*/ VARIANT* pVarResult;
		/*[out]*/ EXCEPINFO* pExcepInfo;
		/*[out]*/ UINT* puArgErr;
		HRESULT retValue;
	};

	STDMETHOD(Invoke)(
		/*[in]*/ DISPID dispIdMember,
		/*[in]*/ REFIID riid,
		/*[in]*/ LCID lcid,
		/*[in]*/ WORD wFlags,
		/*[in,out]*/ DISPPARAMS* pDispParams,
		/*[out]*/ VARIANT* pVarResult,
		/*[out]*/ EXCEPINFO* pExcepInfo,
		/*[out]*/ UINT* puArgErr)
	{
		VSL_DEFINE_MOCK_METHOD(Invoke)

		VSL_CHECK_VALIDVALUE(dispIdMember);

		VSL_CHECK_VALIDVALUE(riid);

		VSL_CHECK_VALIDVALUE(lcid);

		VSL_CHECK_VALIDVALUE(wFlags);

		VSL_SET_VALIDVALUE(pDispParams);

		VSL_SET_VALIDVALUE_VARIANT(pVarResult);

		VSL_SET_VALIDVALUE(pExcepInfo);

		VSL_SET_VALIDVALUE(puArgErr);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // F