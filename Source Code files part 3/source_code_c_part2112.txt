O;
				continue;
			}
			if (HasFlag(rBindCur.wType, (DBTYPE_BYREF | DBTYPE_VECTOR)))
			{
				hr = DB_E_ERRORSOCCURRED;
				rgStatus[iBinding] = DBBINDSTATUS_BADBINDINFO;
				continue;
			}
			if (HasFlag(rBindCur.wType, (DBTYPE_VECTOR | DBTYPE_ARRAY)))
			{
				hr = DB_E_ERRORSOCCURRED;
				rgStatus[iBinding] = DBBINDSTATUS_BADBINDINFO;
				continue;
			}
			if (rBindCur.wType == DBTYPE_NULL || rBindCur.wType == DBTYPE_EMPTY)
			{
				hr = DB_E_ERRORSOCCURRED;
				rgStatus[iBinding] = DBBINDSTATUS_BADBINDINFO;
				continue;
			}
			if (HasFlag(rBindCur.wType, DBTYPE_RESERVED))
			{
				hr = DB_E_ERRORSOCCURRED;
				rgStatus[iBinding] = DBBINDSTATUS_BADBINDINFO;
				continue;
			}
			// DBTYPE_BYREF must be accompanied by other valid type
			if (rBindCur.wType == (DBTYPE_BYREF | DBTYPE_EMPTY)
				|| rBindCur.wType == (DBTYPE_BYREF | DBTYPE_NULL)
				|| rBindCur.wType == DBTYPE_BYREF)
			{
				hr = DB_E_ERRORSOCCURRED;
				rgStatus[iBinding] = DBBINDSTATUS_BADBINDINFO;
				continue;
			}

			// If someone attempts to set DBBINDFLAG_HTML on a non-string
			// column, generate a BADBINDINFO error.
			if (rBindCur.wType != DBTYPE_STR && rBindCur.wType != DBTYPE_WSTR &&
				rBindCur.dwFlags & DBBINDFLAG_HTML)
			{
				hr = DB_E_ERRORSOCCURRED;
				rgStatus[iBinding] = DBBINDSTATUS_BADBINDINFO;
				continue;
			}

			// the dwFlags parameter must be 0 or DBBINDFLAG_HTML,
			// all other values will return an error.
			if (rBindCur.dwFlags != 0 && rBindCur.dwFlags != DBBINDFLAG_HTML)
			{
				hr = DB_E_ERRORSOCCURRED;
				rgStatus[iBinding] = DBBINDSTATUS_BADBINDINFO;
				continue;
			}

			if (rBindCur.dwMemOwner == DBMEMOWNER_PROVIDEROWNED)
			{
				BOOL bIsPointerType = HasFlag(rBindCur.wType, DBTYPE_BYREF) ||
									  HasFlag(rBindCur.wType, DBTYPE_VECTOR) ||
									  HasFlag(rBindCur.wType, DBTYPE_ARRAY) ||
									  HasFlag( (DBTYPE) (~(DBTYPE_BYREF) & rBindCur.wType), DBTYPE_BSTR);
				if (!bIsPointerType)
				{
					hr = DB_E_ERRORSOCCURRED;
					rgStatus[iBinding] = DBBINDSTATUS_BADBINDINFO;
					continue;
				}
			}
			else if (rBindCur.dwMemOwner != DBMEMOWNER_CLIENTOWNED)
			{
				// the dwMemOwner flag is supposed to be ignored for reference accessors
				// (see the description of DBBINDING structure in MSDN), otherwise dwMemOwner
				// should have a value of DBMEMOWNER_CLIENTOWNED or DBMEMOWNER_PROVIDEROWNED
				if (!HasFlag(rBindCur.wType, DBTYPE_BYREF))
				{
					hr = DB_E_ERRORSOCCURRED;
					rgStatus[iBinding] = DBBINDSTATUS_BADBINDINFO;
					continue;
				}
			}
		}
		return hr;
	}

	unsigned  m_bIsCommand:1;
	unsigned  m_bHasParamaters:1;
	unsigned  m_bIsChangeable:1;
};

// IAccessorImpl
template <class T, class BindType = ATLBINDINGS,
			class BindingVector = CAtlMap < HACCESSOR, BindType* > >
class ATL_NO_VTABLE IAccessorImpl :
	public IAccessorImplBase<BindType>
{
public:
	typedef BindType _BindType;
	typedef BindingVector _BindingVector;
	IAccessorImpl()
	{
		m_bIsCommand = FALSE;
		m_bHasParamaters = FALSE;
		m_bIsChangeable = FALSE;
	}
	OUT_OF_LINE HRESULT InternalFinalConstruct(_In_opt_ IUnknown* /*pUnkThis*/)
	{
		CComPtr<ICommand> spCommand;
		CComPtr<ICommandWithParameters> spCommandWithParameters;
		T* pT = (T*)this;

		pT->_InternalQueryInterface(IID_ICommand,(void **) &spCommand);

		if (spCommand !=NULL)  // It's a command
		{
			m_bIsCommand = TRUE;
			pT->_InternalQueryInterface(IID_ICommandWithParameters, (void **) &spCommandWithParameters);
			m_bHasParamaters =  spCommandWithParameters != NULL;

		}
		return S_OK;
	}
	HRESULT FinalConstruct()
	{
		T* pT = (T*)this;
		return InternalFinalConstruct(pT->GetUnknown());
	}
	void FinalRelease()
	{
#ifdef _DEBUG
		if (m_rgBindings.GetCount())
			ATLTRACE(atlTraceDBProvider, 0, _T("IAccessorImpl::~IAccessorImpl Bindings still in vector, removing\n"));
#endif //_DEBUG
		while (m_rgBindings.GetCount())
			ReleaseAccessor((HACCESSOR)m_rgBindings.GetKeyAt(m_rgBindings.GetStartPosition()), NULL);
	}
	STDMETHOD(AddRefAccessor)(
		_In_ HACCESSOR hAccessor,
		_Out_opt_ DBREFCOUNT *pcRefCount)
	{
		ATLTRACE(atlTraceDBProvider, 2, _T("IAccessorImpl::AddRefAccessor\n"));
		if (hAccessor == NULL)
		{
			ATLTRACE(atlTraceDBProvider, 0, _T("AddRefAccessor : Bad hAccessor\n"));
			return DB_E_BADACCESSORHANDLE;
		}
		BindType* pBind;
		if( ! m_rgBindings.Lookup(hAccessor, pBind ) )
			return DB_E_BADACCESSORHANDLE;

		ATLENSURE_RETURN( pBind );
		ULONG cRefCount = T::_ThreadModel::Increment((LONG*)&pBind->dwRef);

		if (pcRefCount != NULL)
			*pcRefCount = cRefCount;

		return S_OK;
	}
	OUT_OF_LINE ATLCOLUMNINFO* ValidateHelper(
		_Out_ DBORDINAL* pcCols,
		_Inout_ CComPtr<IDataConvert>& rspConvert)
	{
		T* pT = (T*)this;
		rspConvert = pT->m_spConvert;
		return T::GetColumnInfo(pT, pcCols);
	}
	OUT_OF_LINE HRESULT ValidateBindingsFromMetaData(
		_In_ DBCOUNTITEM cBindings,
		_In_count_(cBindings) const DBBINDING rgBindings[],
		_Out_cap_(cBindings) DBBINDSTATUS rgStatus[],
		_In_ bool bHasBookmarks)
	{
		HRESULT hr = S_OK;
		DBORDINAL cCols;
		CComPtr<IDataConvert> spConvert;
		ATLCOLUMNINFO* pColInfo = ValidateHelper(&cCols, spConvert);
		ATLENSURE_RETURN(pColInfo != NULL);
		for (DBCOUNTITEM iBinding = 0; iBinding < cBindings; iBinding++)
		{
			const DBBINDING& rBindCur = rgBindings[iBinding];
			DBORDINAL iOrdAdjusted;
			if (bHasBookmarks)
				iOrdAdjusted = rBindCur.iOrdinal;	// Bookmarks start with ordinal 0
			else
				iOrdAdjusted = rBindCur.iOrdinal - 1; // Non-bookmarks start w/ ordinal 1
			if (rBindCur.iOrdinal > cCols)
			{
				hr = DB_E_ERRORSOCCURRED;
				rgStatus[iBinding] = DBBINDSTATUS_BADORDINAL;
				continue;
			}

			// If a binding specifies provider owned memory, and specifies type
			// X | BYREF, and the provider's copy is not X or X | BYREF, return
			// DBBINDSTATUS_BADBINDINFO

			if (rBindCur.dwMemOwner == DBMEMOWNER_PROVIDEROWNED)
			{
				if ((rBindCur.wType & DBTYPE_BYREF) != 0 &&
					((rBindCur.wType & (~DBTYPE_BYREF)) !=
						(pColInfo[iOrdAdjusted].wType & (~DBTYPE_BYREF))))
				{
					hr = DB_E_ERRORSOCCURRED;
					rgStatus[iBinding] = DBBINDSTATUS_BADBINDINFO;
					continue;
				}
			}

			ATLASSERT(spConvert != NULL);
			HRESULT hrConvert = spConvert->CanConvert(pColInfo[iOrdAdjusted].wType, rBindCur.wType);
			if (FAILED(hrConvert) || hrConvert == S_FALSE)
			{
				hr = DB_E_ERRORSOCCURRED;
				rgStatus[iBinding] = DBBINDSTATUS_UNSUPPORTEDCONVERSION;
				continue;
			}
		}
		return hr;
	}
	STDMETHOD(CreateAccessor)(
		_In_ DBACCESSORFLAGS dwAccessorFlags,
		_In_ DBCOUNTITEM cBindings,
		_In_count_(cBindings) const DBBINDING rgBindings[],
		_In_ DBLENGTH cbRowSize,
		_Out_ HACCESSOR *phAccessor,
		_Out_cap_(cBindings) DBBINDSTATUS rgStatus[])
	{
		ATLTRACE(atlTraceDBProvider, 2, _T("IAccessorImpl::CreateAccessor\n"));
		T* pT = (T*)this;
		T::ObjectLock cab(pT);

		if (!phAccessor)
		{
			ATLTRACE(atlTraceDBProvider, 0, _T("IAccessorImpl::CreateAccessor : Inavlid NULL Parameter for HACCESSOR*\n"));
			return E_INVALIDARG;
		}
		*phAccessor = NULL;
		if (cBindings != 0 && rgBindings == NULL)
		{
			ATLTRACE(atlTraceDBProvider, 0, _T("IAccessorImpl::CreateAccessor  : Bad Binding array\n"));
			return E_INVALIDARG;
		}
		if (dwAccessorFlags & DBACCESSOR_PASSBYREF)
		{
			CComVariant varByRef;
			HRESULT hr = pT->GetPropValue(&DBPROPSET_ROWSET,
				DBPROP_BYREFACCESSORS, &varByRef);
			if (FAILED(hr) || varByRef.boolVal == ATL_VARIANT_FALSE)
				return DB_E_BYREFACCESSORNOTSUPPORTED;
		}
		if (!m_bHasParamaters)
		{
			if (dwAccessorFlags & DBACCESSOR_PARAMETERDATA)
				return DB_E_BADACCESSORFLAGS;
		}

		// since our accessor does not provide any further restrictions or optimizations based
		// on the DBACCESSOR_OPTIMIZED flag, the flag will be ignored.  In particular we will
		// not be returning this flag in the call to IAccessor::GetBindings.  This way we will
		// be complient with the OLEDB specifications and we will not have to prevent the
		// client from creating additional accessors after the first row is fetched.
		DBACCESSORFLAGS dwMask = DBACCESSOR_OPTIMIZED;
		dwAccessorFlags &= ~dwMask;

		CComVariant varUpdate;
		HRESULT hr = pT->GetPropValue(&DBPROPSET_ROWSET, DBPROP_UPDATABILITY, &varUpdate);
		m_bIsChangeable = (SUCCEEDED(hr) && (varUpdate.iVal & DBPROPVAL_UP_INSERT));

		if (m_bIsCommand || !m_bIsChangeable)
		{
			if (cBindings == 0) // No NULL Accessors on the command
				return DB_E_NULLACCESSORNOTSUPPORTED;
		}

		CTempBuffer<DBBINDSTATUS> tmpBuffer;
		if (rgStatus == NULL && cBindings) // Create a fake status array
			rgStatus = tmpBuffer.Allocate(cBindings);

		// Validate the Binding passed
		bool bHasBookmarks = false;
		CComVariant varBookmarks;
		HRESULT hrLocal = pT->GetPropValue(&DBPROPSET_ROWSET, DBPROP_BOOKMARKS, &varBookmarks);
		bHasBookmarks = (hrLocal == S_OK &&  varBookmarks.boolVal != ATL_VARIANT_FALSE);

		hr = ValidateBindings(cBindings, rgBindings, rgStatus, bHasBookmarks);
		if (FAILED(hr))
			return hr;
		if (!m_bIsCommand)
		{
			hr = ValidateBindingsFromMetaData(cBindings, rgBindings, rgStatus,
					bHasBookmarks);
			if (FAILED(hr))
				return hr;
		}
		hr = IAccessorImplBase<BindType>::CreateAccessor(dwAccessorFlags, cBindings,
			rgBindings, cbRowSize, phAccessor,rgStatus);
		if (SUCCEEDED(hr))
		{
			ATLASSERT(*phAccessor != NULL);
			BindType* pBind = (BindType*)*phAccessor;
			ATLENSURE_RETURN(pBind);
			_ATLTRY
			{
				m_rgBindings.SetAt((HACCESSOR)pBind, pBind);
				hr = S_OK;
			}
			_ATLCATCH( e )
			{
				_ATLDELETEEXCEPTION( e );
				hr = E_OUTOFMEMORY;
			}
		}
		return hr;

	}

	STDMETHOD(GetBindings)(
		_In_ HACCESSOR hAccessor,
		_Out_ DBACCESSORFLAGS *pdwAccessorFlags,
		_Out_ DBCOUNTITEM *pcBindings,
		_Out_opt_ _Deref_post_opt_cap_(*pcBindings) DBBINDING **prgBindings)
	{
		ATLTRACE(atlTraceDBProvider, 2, _T("IAccessorImpl::GetBindings\n"));

		// Zero output parameters in case of failure
		if (pdwAccessorFlags != NULL)
			*pdwAccessorFlags = NULL;

		if (pcBindings != NULL)
			*pcBindings = NULL;

		if (prgBindings != NULL)
			*prgBindings = NULL;

		// Check if any of the out params are NULL pointers
		if ((pdwAccessorFlags && pcBindings && prgBindings) == NULL)
			return E_INVALIDARG;

		BindType* pBind;
		bool bFound = m_rgBindings.Lookup((INT_PTR)hAccessor, pBind);
		HRESULT hr = DB_E_BADACCESSORHANDLE;
		if (bFound && pBind != NULL)
		{
			*pdwAccessorFlags = pBind->dwAccessorFlags;
			*pcBindings = pBind->cBindings;
			// Get NULL for NULL Accessor
			*prgBindings = (pBind->cBindings) ? (DBBINDING*)::ATL::AtlCoTaskMemCAlloc(*pcBindings, static_cast<ULONG>(sizeof(DBBINDING))) : NULL;
			if (*prgBindings == NULL && pBind->cBindings) // No Error if NULL Accessor
				return E_OUTOFMEMORY;
			Checked::memcpy_s(*prgBindings, *pcBindings * sizeof(DBBINDING), pBind->pBindings, *pcBindings * sizeof(DBBINDING));
			hr = S_OK;
		}
		return hr;
	}

	STDMETHOD(ReleaseAccessor)(
		_In_ HACCESSOR hAccessor,
		_Out_opt_ DBREFCOUNT *pcRefCount)
	{
		ATLTRACE(atlTraceDBProvider, 2, _T("IAccessorImpl::ReleaseAccessor\n"));
		T::ObjectLock cab((T*)this);
		BindType* pBind;
		bool bFound = m_rgBindings.Lookup((INT_PTR)hAccessor, pBind);
		if (!bFound || pBind == NULL)
			return DB_E_BADACCESSORHANDLE;
		DBREFCOUNT cRefCount = T::_ThreadModel::Decrement((LONG*)&pBind->dwRef);
		if (pcRefCount != NULL)
			*pcRefCount = cRefCount;
		if (cRefCount == 0)
		{
			delete [] pBind->pBindings;
			delete pBind;
			return m_rgBindings.RemoveKey(hAccessor) ? S_OK : DB_E_BADACCESSORHANDLE;
		}
		return S_OK;
	}

	BindingVector m_rgBindings;
};

#define BEGIN_PROVIDER_COLUMN_MAP(theClass) \
	typedef theClass _Class; \
	template <class T> \
	_Ret_count_x_(*pcCols) static ATL::ATLCOLUMNINFO* GetColumnInfo( \
		_In_opt_ _Post_bytecount_x_(sizeof(T)) T* pv, \
		_Out_ DBORDINAL* pcCols) \
	{ \
	UNREFERENCED_PARAMETER(pv); \
	static ATL::ATLCOLUMNINFO _rgColumns [] = \
	{

#define SIZEOF_MEMBER(memberOf, member) \
	sizeof(((memberOf*)0)->member)
#define EXPANDGUID(guid) \
	{ guid.Data1, guid.Data2, guid.Data3, \
	{ guid.Data4[0], guid.Data4[1], guid.Data4[2], guid.Data4[3], guid.Data4[4], guid.Data4[5], guid.Data4[6], guid.Data4[7] } }

#define PROVIDER_COLUMN_ENTRY_GN(name, ordinal, flags, colSize, dbtype, precision, scale, guid) \
{ (LPOLESTR)name, (ITypeInfo*)NULL, (DBORDINAL)ordinal, (DBCOLUMNFLAGS)flags, (DBLENGTH)colSize, (DBTYPE)dbtype, (BYTE)precision, (BYTE)scale, { EXPANDGUID(guid), (DWORD)0, (LPOLESTR) name}, 0},

#define PROVIDER_COLUMN_ENTRY_EX(name, typeinfo, ordinal, flags, colSize, dbtype, precision, scale, guid, member) \
	{ \
		(LPOLESTR)OLESTR(name), \
		typeinfo, \
		(DBORDINAL)ordinal, \
		flags, \
		colSize, \
		dbtype, \
		(BYTE)precision, \
		(BYTE)scale, \
		{ \
			EXPANDGUID(guid), \
			(DWORD)DBKIND_NAME, \
			(LPOLESTR)OLESTR(name) \
		}, \
		offsetof(_Class, member) \
	},

#define PROVIDER_COLUMN_ENTRY(name, ordinal, member) \
	PROVIDER_COLUMN_ENTRY_EX(name, NULL, ordinal, DBCOLUMNFLAGS_ISFIXEDLENGTH, (DBLENGTH)SIZEOF_MEMBER(_Class, member), ATL::_GetOleDBType(((_Class*)0)->member), 0, 0, GUID_NULL, member)

#define PROVIDER_COLUMN_ENTRY_PS(name, ordinal, precision, scale, member) \
	PROVIDER_COLUMN_ENTRY_EX(name, NULL, ordinal, DBCOLUMNFLAGS_ISFIXEDLENGTH, (DBLENGTH)SIZEOF_MEMBER(_Class, member), ATL::_GetOleDBType(((_Class*)0)->member), precision, scale, GUID_NULL, member)

#define PROVIDER_COLUMN_ENTRY_LENGTH(name, ordinal, size, member) \
	PROVIDER_COLUMN_ENTRY_EX(name, NULL, ordinal, DBCOLUMNFLAGS_ISFIXEDLENGTH, size, ATL::_GetOleDBType(((_Class*)0)->member), 0, 0, GUID_NULL, member)

#define PROVIDER_COLUMN_ENTRY_TYPE_LENGTH(name, ordinal, type, size, member) \
	PROVIDER_COLUMN_ENTRY_EX(name, NULL, ordinal, DBCOLUMNFLAGS_ISFIXEDLENGTH, size, type, 0, 0, GUID_NULL, member)

#define PROVIDER_COLUMN_ENTRY_TYPE(name, ordinal, type, member) \
	PROVIDER_COLUMN_ENTRY_EX(name, NULL, ordinal, DBCOLUMNFLAGS_ISFIXEDLENGTH, (DBLENGTH)SIZEOF_MEMBER(_Class, member), type, 0, 0, GUID_NULL, member)

#define PROVIDER_COLUMN_ENTRY_TYPE_PS(name, ordinal, type, precision, scale, member) \
	PROVIDER_COLUMN_ENTRY_EX(name, NULL, ordinal, DBCOLUMNFLAGS_ISFIXEDLENGTH, (DBLENGTH)SIZEOF_MEMBER(_Class, member), type, precision, scale, GUID_NULL, member)

#define PROVIDER_COLUMN_ENTRY_FIXED(name, ordinal, type, member) \
	PROVIDER_COLUMN_ENTRY_EX(name, NULL, ordinal, DBCOLUMNFLAGS_ISFIXEDLENGTH, (DBLENGTH)SIZEOF_MEMBER(_Class, member), type, 0, 0, GUID_NULL, member)

#define PROVIDER_COLUMN_ENTRY_STR(name, ordinal, member) \
	PROVIDER_COLUMN_ENTRY_EX(name, NULL, ordinal, 0, (DBLENGTH)SIZEOF_MEMBER(_Class, member), DBTYPE_STR, 255, 255, GUID_NULL, member)

#define PROVIDER_COLUMN_ENTRY_WSTR(name, ordinal, member) \
	PROVIDER_COLUMN_ENTRY_EX(name, NULL, ordinal, 0, (DBLENGTH)SIZEOF_MEMBER(_Class, member), DBTYPE_WSTR, 255, 255, GUID_NULL, member)

#define END_PROVIDER_COLUMN_MAP() \
}; *pcCols = sizeof(_rgColumns)/sizeof(ATL::ATLCOLUMNINFO); return _rgColumns;}

class CDynColumnInfo:
	public CAtlArray<ATLCOLUMNINFO>
{
public:
	HRESULT Add(
		_In_z_ LPOLESTR szName,
		_In_ DBORDINAL ordinal,
		_In_ DBLENGTH colSize,
		_In_ DBTYPE type,
		_In_ BYTE precision,
		_In_ BYTE scale,
		_In_ DBBYTEOFFSET offset,
		_In_ DWORD flags = DBCOLUMNFLAGS_ISFIXEDLENGTH)
	{
		ATLCOLUMNINFO col;
		col.pwszName = szName;
		col.pTypeInfo = NULL;
		col.iOrdinal = ordinal;
		col.dwFlags = flags;
		col.ulColumnSize = colSize;
		col.wType = type;
		col.bPrecision = precision;
		col.bScale = scale;
		col.cbOffset = offset;
		memset(&(col.columnid), 0, sizeof(DBID));
		col.columnid.uName.pwszName = (LPOLESTR)szName;
		_ATLTRY
		{
			CAtlArray<ATLCOLUMNINFO>::Add(col);
		}
		_ATLCATCH( e )
		{
			_ATLDELETEEXCEPTION( e );
			return E_OUTOFMEMORY;
		}
		return S_OK;
	}

	HRESULT AddString(
		_In_z_ LPOLESTR szName,
		_In_ DBORDINAL ordinal,
		_In_ DBLENGTH colSize,
		_In_ DBBYTEOFFSET offset)
	{
		return Add(szName,ordinal, colSize, DBTYPE_STR, 0xFF, 0xFF, offset);
	}
};

// Implementation Class
class CSimpleRow
{
public:
	typedef DBCOUNTITEM KeyType;

	CSimpleRow(_In_ DBCOUNTITEM iRowsetCur)
	{
		m_dwRef = 0;
		m_pData = NULL;
		m_iRowset = iRowsetCur;
		m_iOriginalRowset = iRowsetCur; // used for stronger identity tests
		m_status = 0;
	}
	~CSimpleRow()
	{
		m_pData = NULL;	// Data will be freed seperately
	}
	DWORD AddRefRow()
	{
		return CComObjectThreadModel::Increment((LPLONG)&m_dwRef);
	}
	DWORD ReleaseRow()
	{
		return CComObjectThreadModel::Decrement((LPLONG)&m_dwRef);
	}

	HRESULT Compare(_In_ CSimpleRow* pRow)
	{
		ATLENSURE_RETURN(pRow != NULL);
		return (m_iRowset == pRow->m_iRowset) ? S_OK : S_FALSE;
	}

	DWORD	m_dwRef;
	void*	m_pData;			// NEW:  For IRowsetChange & IRowsetUpdate
	DBPENDINGSTATUS m_status;	// NEW:  For IRowsetUpdate
	KeyType m_iOriginalRowset;	// NEW:  For IRowsetChange & IRowsetUpdate
	KeyType m_iRowset;
};

template <class T>
inline void SendColumnSetFailureNotification(
	_Inout_ _Prepost_bytecount_x_(sizeof(T)) T* pT,
	_In_ HROW hNotifyRow,
	_In_ typename T::_BindType* pBinding,
	_In_ CAtlArray<DBORDINAL>& rgColumns)
{
	pT->Fire_OnFieldChange(pT, hNotifyRow, pBinding->cBindings,
		rgColumns.GetData(), DBREASON_COLUMN_SET,
		DBEVENTPHASE_FAILEDTODO, TRUE);
}

template <class T, class RowClass>
inline void SendRowsFirstChangeFailureNotification(
	_Inout_ _Prepost_bytecount_x_(sizeof(T)) T* pT,
	_In_ RowClass* pRow,
	_In_ HROW *phNotifyRow,
	_In_ bool bDeferred)
{
	ATLENSURE(pRow);
	if (bDeferred)
	{
		// Determine if we are really in a first row change
		if (pRow->m_status != DBPENDINGSTATUS_CHANGED &&
			pRow->m_status != (DBPENDINGSTATUS_NEW | DBPENDINGSTATUS_UNCHANGED))
		{
			pT->Fire_OnRowChange(pT, 1, phNotifyRow,
				DBREASON_ROW_FIRSTCHANGE, DBEVENTPHASE_FAILEDTODO, TRUE);
		}
	}
}

template <class T, class RowClass, class MapClass>
HRESULT TransferData(
	_In_ _Prepost_bytecount_x_(sizeof(T)) T* pT,
	_In_ bool bReading,
	_In_opt_ void* pData,
	_In_ RowClass* pRow,
	_In_opt_ MapClass* /*pMap*/,
	_In_ HACCESSOR hAccessor)
{
	ATLTRACE(atlTraceDBProvider, 2, _T("TransferData\n"));
	bool bFailed = false;
	bool bSucceeded = false;
	HRESULT hr = S_OK;

	__if_exists(T::Fire_OnFieldChange)
	{
		CAtlArray<DBORDINAL> rgColumns;
		HROW hNotifyRow = NULL;
		//HROW hNotifyRow = pT->m_rgRowHandles.ReverseLookup(pRow);
		{
			POSITION pos = pT->m_rgRowHandles.GetStartPosition();
			while( pos != NULL )
			{
				MapClass::CPair* pPair = pT->m_rgRowHandles.GetNext( pos );
				ATLASSUME( pPair != NULL );
				if( pPair->m_value == pRow )
				{
					hNotifyRow = pPair->m_key;
					break;
				}
			}
		}
	}

	__if_exists(T::Fire_OnRowChange)
	{
		// We need to send the DBREASON_ROW_FIRSTCHANGE notification's
		// SYNCHAFTER phase in this function.  IFF. we're deferred and
		// we have a newly changed row.

		CComVariant varDeferred;
		bool bDeferred;
		hr = pT->GetPropValue(&DBPROPSET_ROWSET, DBPROP_IRowsetUpdate,
							&varDeferred);
		(FAILED(hr) || varDeferred.boolVal == ATL_VARIANT_FALSE) ? bDeferred = false : bDeferred = true;
	}

	// Check for a deleted row
	if( pRow->m_iRowset >= pT->m_rgRowData.GetCount() )
	{
		__if_exists(T::Fire_OnFieldChange)
		{
			if( !bReading )
			{
				SendRowsFirstChangeFailureNotification( pT, pRow, &hNotifyRow, bDeferred );
			}
		}
		return DB_E_DELETEDROW;
	}

	// NOTE: This was checking against DBPENDINGSTATUS_DELETED.  Instead, it
	// should check for DBPENDINGSTATUS_INVALIDROW (means a forced deleted
	// row).

	if (pRow->m_status == DBPENDINGSTATUS_INVALIDROW)
	{
		__if_exists(T::Fire_OnFieldChange)
		{
			if( !bReading )
			{
				SendRowsFirstChangeFailureNotification( pT, pRow, &hNotifyRow, bDeferred );
			}
		}
		return DB_E_DELETEDROW;
	}

	T::_BindType* pBinding;
	bool bFound = pT->m_rgBindings.Lookup((INT_PTR)hAccessor, pBinding);
	if (!bFound || pBinding == NULL)
	{
		__if_exists(T::Fire_OnFieldChange)
		{
			if( !bReading )
			{
				SendRowsFirstChangeFailureNotification( pT, pRow, &hNotifyRow, bDeferred );
			}
		}
		return DB_E_BADACCESSORHANDLE;
	}

	if (pData == NULL && pBinding->cBindings != 0)
	{
		__if_exists(T::Fire_OnFieldChange)
		{
			if( !bReading )
			{
				SendRowsFirstChangeFailureNotification( pT, pRow, &hNotifyRow, bDeferred );
			}
		}
		return E_INVALIDARG;
	}

	void* pDstData;
	void* pSrcData;
	if (bReading)
	{
		pDstData = pData;
		pSrcData = (void*)&(pT->m_rgRowData[(LONG)pRow->m_iRowset]);
	}
	else
	{
		pSrcData = pData;
		pDstData = (void*)&(pT->m_rgRowData[(LONG)pRow->m_iRowset]);
	}

	if (!bReading)
	{
		// Send the OKTODO notification
		__if_exists(T::Fire_OnFieldChange)
		{
			if (/* pRow->m_status != DBPENDINGSTATUS_NEW && */
				pRow->m_status != (DBPENDINGSTATUS_NEW | DBPENDINGSTATUS_UNCHANGED))
			{
				HRESULT hrNotify;
				for (DBORDINAL l=0; l<pBinding->cBindings; l++)
				{
					_ATLTRY
					{
						rgColumns.Add(pBinding->pBindings[l].iOrdinal);
					}
					_ATLCATCH( e )
					{
						_ATLDELETEEXCEPTION( e );
						return E_FAIL;
					}
				}

				hrNotify = pT->Fire_OnFieldChange(pT, hNotifyRow, pBinding->cBindings,
					rgColumns.GetData(), DBREASON_COLUMN_SET,
					DBEVENTPHASE_OKTODO, FALSE);
				if ((hrNotify != S_OK) && (hrNotify != E_FAIL))
				{
					__if_exists(T::Fire_OnRowChange)
					{
						if (bDeferred)
							pT->Fire_OnRowChange(pT, 1, &hNotifyRow,
								DBREASON_ROW_FIRSTCHANGE, DBEVENTPHASE_FAILEDTODO, TRUE);
						return DB_E_CANCELED;
					}
				}

				hrNotify = pT->Fire_OnFieldChange(pT, hNotifyRow, pBinding->cBindings,
					rgColumns.GetData(), DBREASON_COLUMN_SET, DBEVENTPHASE_ABOUTTODO,
					FALSE);
				if ((hrNotify != S_OK) && (hrNotify != E_FAIL))
				{
					__if_exists(T::Fire_OnRowChange)
					{
						if (bDeferred)
							pT->Fire_OnRowChange(pT, 1, &hNotifyRow,
								DBREASON_ROW_FIRSTCHANGE, DBEVENTPHASE_FAILEDTODO, TRUE);
						return DB_E_CANCELED;
					}
				}

				hrNotify = pT->Fire_OnFieldChange(pT, hNotifyRow, pBinding->cBindings,
					rgColumns.GetData(), DBREASON_COLUMN_SET,
					DBEVENTPHASE_SYNCHAFTER, FALSE);
				if ((hrNotify != S_OK) && (hrNotify != E_FAIL))
				{
					__if_exists(T::Fire_OnRowChange)
					{
						if (bDeferred)
							pT->Fire_OnRowChange(pT, 1, &hNotifyRow,
								DBREASON_ROW_FIRSTCHANGE, DBEVENTPHASE_FAILEDTODO, TRUE);
						return DB_E_CANCELED;
					}
				}
			}
		}

		__if_exists(T::Fire_OnRowChange)
		{
			if(bDeferred && pRow->m_status != DBPENDINGSTATUS_CHANGED &&
				pRow->m_status != (DBPENDINGSTATUS_NEW | DBPENDINGSTATUS_UNCHANGED))
			{
				HRESULT hrNotify = pT->Fire_OnRowChange(pT, 1, &hNotifyRow,
					DBREASON_ROW_FIRSTCHANGE, DBEVENTPHASE_SYNCHAFTER, FALSE);

				if ((hrNotify != S_OK) && (hrNotify != E_FAIL))
				{
					__if_exists(T::Fire_OnFieldChange)
					{
						pT->Fire_OnFieldChange(pT, hNotifyRow, pBinding->cBindings,
							rgColumns.GetData(), DBREASON_COLUMN_SET,
							DBEVENTPHASE_FAILEDTODO, TRUE);
					}
					return DB_E_CANCELED;
				}
			}
		}
	}


	DBORDINAL cCols;
	ATLCOLUMNINFO* pColInfo = T::GetColumnInfo(pT, &cCols);
	ATLENSURE_RETURN(pColInfo);
	for (DBORDINAL iBind =0; iBind < pBinding->cBindings; iBind++)
	{
		DBBINDING* pBindCur = &(pBinding->pBindings[iBind]);
		DBORDINAL iColInfo;
		for (iColInfo = 0;
			 iColInfo < cCols && pBindCur->iOrdinal != pColInfo[iColInfo].iOrdinal;
			 iColInfo++);
		if (iColInfo == cCols)
		{
			__if_exists(T::Fire_OnFieldChange)
			{
				if( !bReading )
				{
					SendColumnSetFailureNotification( pT, hNotifyRow, pBinding, rgColumns );
					SendRowsFirstChangeFailureNotification( pT, pRow, &hNotifyRow, bDeferred );
				}
			}
			return DB_E_BADORDINAL;
		}
		ATLCOLUMNINFO* pColCur = &(pColInfo[iColInfo]);
		// Ordinal found at iColInfo

		BYTE* pSrcTemp = (bReading) ? (BYTE*)pSrcData + pColCur->cbOffset :
									  (BYTE*)pSrcData + pBindCur->obValue;

		BYTE* pDstTemp = NULL;
		if (pBindCur->dwPart & DBPART_VALUE)
			pDstTemp = (bReading) ? (BYTE*)pDstData + pBindCur->obValue :
						 (BYTE*)pDstData + pColCur->cbOffset;


		if (!bReading)
		{
			// Check to see that the appropriate data parts are available
			if ((pBindCur->dwPart & DBPART_LENGTH) &&
				!(pBindCur->dwPart & DBPART_VALUE) &&
				!(pBindCur->dwPart & DBPART_STATUS))
			{
				__if_exists(T::Fire_OnFieldChange)
				{
					if (/* pRow->m_status != DBPENDINGSTATUS_NEW && */
						pRow->m_status != (DBPENDINGSTATUS_NEW | DBPENDINGSTATUS_UNCHANGED))
					{
						pT->Fire_OnFieldChange(pT, hNotifyRow, pBinding->cBindings,
							rgColumns.GetData(), DBREASON_COLUMN_SET, DBEVENTPHASE_FAILEDTODO,
							TRUE);
					}
				}

				// Not sure why you would want to run SetData here!
				bFailed = true;
				continue;
			}
		}

		// Handle the the status for any consumer issues
		DBSTATUS dbStat = DBSTATUS_S_OK;
		if (bReading)
		{
			dbStat = pT->GetDBStatus(pRow, pColCur);

			if (dbStat == DBSTATUS_S_ISNULL)
			{
				if (pBindCur->dwPart & DBPART_STATUS)
					*((DBSTATUS*)((BYTE*)(pDstData) + pBindCur->obStatus)) = dbStat;

				// Set the length to 0 as reqiured by the spec.
				if (pBindCur->dwPart & DBPART_LENGTH)
					*((DBLENGTH*)((BYTE*)(pDstData) + pBindCur->obLength)) = 0;

				// Set the destination value to NULL
				if (pBindCur->dwPart & DBPART_VALUE)
				{

					ATLENSURE_RETURN(pDstTemp);
					*pDstTemp = NULL;
				}

				continue;
			}
		}
		else
		{
			// Allow the provider to do checking for DBSTATUS_S_ISNULL
			if (pBindCur->dwPart & DBPART_STATUS)
			{
				dbStat = *((DBSTATUS*)((BYTE*)(pSrcData) + pBindCur->obStatus));

				// Return DBSTATUS_E_UNAVAILABLE if the status is DBSTATUS_S_OK
				//	and either the value part is not bound or the length part is
				//	bound and the type is DBTYPE_BYTES.

				// There was another entry of code here with LENGTH, NO VALUE,
				//	and status was not DBSTATUS_S_ISNULL.  May need to regenerate that
				if (dbStat == DBSTATUS_S_OK)
				{
					if (!(pBindCur->dwPart & DBPART_VALUE) ||
						((pBindCur->dwPart & DBPART_LENGTH) && (pBindCur->wType == DBTYPE_BYTES)))
					{
						// Can't set non-null columns w/o a value part
						__if_exists(T::Fire_OnFieldChange)
						{
							if (/* pRow->m_status != DBPENDINGSTATUS_NEW && */
								pRow->m_status != (DBPENDINGSTATUS_NEW | DBPENDINGSTATUS_UNCHANGED))
							{
								pT->Fire_OnFieldChange(pT, hNotifyRow, pBinding->cBindings,
									rgColumns.GetData(), DBREASON_COLUMN_SET, DBEVENTPHASE_FAILEDTODO,
									TRUE);
							}
						}

						bFailed = true;
						*((DBSTATUS*)((BYTE*)(pSrcData) + pBindCur->obStatus)) = DBSTATUS_E_UNAVAILABLE;
						continue;
					}
				}

				switch (dbStat)
				{
				case DBSTATUS_S_ISNULL:
					if (!(pColCur->dwFlags & DBCOLUMNFLAGS_ISNULLABLE) ||
						FAILED(pT->SetDBStatus(&dbStat, pRow, pColCur)))
					{
						__if_exists(T::Fire_OnFieldChange)
						{
							if (/* pRow->m_status != DBPENDINGSTATUS_NEW && */
								pRow->m_status != (DBPENDINGSTATUS_NEW | DBPENDINGSTATUS_UNCHANGED))
							{
								pT->Fire_OnFieldChange(pT, hNotifyRow,
									pBinding->cBindings, rgColumns.GetData(),
									DBREASON_COLUMN_SET, DBEVENTPHASE_FAILEDTODO,
									TRUE);
							}
						}

						// Special processing for attempting to write, read-only columns
						if (!(pColCur->dwFlags & DBCOLUMNFLAGS_ISNULLABLE))
							*((DBSTATUS*)((BYTE*)(pSrcData) + pBindCur->obStatus)) = DBSTATUS_E_INTEGRITYVIOLATION;

						bFailed = true;
					}
					else
					{
						__if_exists(T::Fire_OnFieldChange)
						{
							if (/* pRow->m_status != DBPENDINGSTATUS_NEW && */
								pRow->m_status != (DBPENDINGSTATUS_NEW | DBPENDINGSTATUS_UNCHANGED))
							{
								pT->Fire_OnFieldChange(pT, hNotifyRow, 1, &iBind,
									DBREASON_COLUMN_SET, DBEVENTPHASE_DIDEVENT, TRUE);
							}
						}
						bSucceeded = true;
						dbStat = DBSTATUS_S_OK;
						if (pBindCur->dwPart & DBPART_VALUE)
						{
							ATLENSURE_RETURN(pDstTemp);
							*pDstTemp = NULL;
						}
					}
					continue;
					break;
				case DBSTATUS_S_DEFAULT:
				case DBSTATUS_S_IGNORE:
				{
					HRESULT hrStatus = pT->SetDBStatus(&dbStat, pRow, pColCur);
					*((DBSTATUS*)((BYTE*)(pSrcData) + pBindCur->obStatus)) = dbStat;

					if (FAILED(hrStatus))
					{
						__if_exists(T::Fire_OnFieldChange)
						{
							if (/* pRow->m_status != DBPENDINGSTATUS_NEW && */
								pRow->m_status != (DBPENDINGSTATUS_NEW | DBPENDINGSTATUS_UNCHANGED))
							{
								pT->Fire_OnFieldChange(pT, hNotifyRow, pBinding->cBindings,
									rgColumns.GetData(), DBREASON_COLUMN_SET,
									DBEVENTPHASE_FAILEDTODO, TRUE);
							}
						}

						// Note, status should be set by SetDBStatus
						bFailed = true;
					}
					else
					{
						__if_exists(T::Fire_OnFieldChange)
						{
							if (/* pRow->m_status != DBPENDINGSTATUS_NEW && */
								pRow->m_status != (DBPENDINGSTATUS_NEW | DBPENDINGSTATUS_UNCHANGED))
							{
								pT->Fire_OnFieldChange(pT, hNotifyRow, pBinding->cBindings,
									rgColumns.GetData(), DBREASON_COLUMN_SET,
									DBEVENTPHASE_DIDEVENT, TRUE);
							}
						}
						bSucceeded = true;
					}
					continue;
					break;
				}
				case DBSTATUS_S_OK:
					// Still call SetDBStatus here as they may have locks on
					// integrity contstraints to observe
					if (FAILED(pT->SetDBStatus(&dbStat, pRow, pColCur)))
					{
						__if_exists(T::Fire_OnFieldChange)
						{
							if (/* pRow->m_status != DBPENDINGSTATUS_NEW && */
								pRow->m_status != (DBPENDINGSTATUS_NEW | DBPENDINGSTATUS_UNCHANGED))
							{
								pT->Fire_OnFieldChange(pT, hNotifyRow, pBinding->cBindings,
									rgColumns.GetData(), DBREASON_COLUMN_SET,
									DBEVENTPHASE_FAILEDTODO, TRUE);
							}
						}

						bFailed = true;
						*((DBSTATUS*)((BYTE*)(pSrcData) + pBindCur->obStatus)) = dbStat;
						continue;
					}
					break;
				default:
					*((DBSTATUS*)((BYTE*)(pSrcData) + pBindCur->obStatus)) = DBSTATUS_E_BADSTATUS;

					__if_exists(T::Fire_OnFieldChange)
					{
						if (/* pRow->m_status != DBPENDINGSTATUS_NEW && */
							pRow->m_status != (DBPENDINGSTATUS_NEW | DBPENDINGSTATUS_UNCHANGED))
						{
							pT->Fire_OnFieldChange(pT, hNotifyRow, pBinding->cBindings,
								rgColumns.GetData(), DBREASON_COLUMN_SET,
								DBEVENTPHASE_FAILEDTODO, TRUE);
						}
					}

					bFailed = true;
					continue;
					break;
				}
			}
		}

		// Determine sizes of input and output columns
		DBLENGTH cbCol = 0;
		DBLENGTH cbDst;
		if (bReading)
			cbDst = pBindCur->cbMaxLen;
		else
			cbDst = pColCur->ulColumnSize;

		switch (pColCur->wType)
		{
		case DBTYPE_STR:
			if (bReading)
				cbCol = lstrlenA((LPSTR)(((BYTE*)pSrcData) + pColCur->cbOffset));
			else
			{
				// Use the length field when setting data
				if (pBindCur->dwPart & DBPART_LENGTH)
					cbCol = *((DBLENGTH*)((BYTE*)(pSrcData) + pBindCur->obLength));
				else
					cbCol = lstrlenA((LPSTR)(pSrcTemp));	// was cbDst

				if (cbCol >= cbDst)
				{
					if (cbCol > (cbDst + 1)) // over maximum case
					{
						__if_exists(T::Fire_OnFieldChange)
						{
							if (/* pRow->m_status != DBPENDINGSTATUS_NEW && */
								pRow->m_status != (DBPENDINGSTATUS_NEW | DBPENDINGSTATUS_UNCHANGED))
							{
								pT->Fire_OnFieldChange(pT, hNotifyRow, pBinding->cBindings,
									rgColumns.GetData(), DBREASON_COLUMN_SET,
									DBEVENTPHASE_FAILEDTODO, TRUE);
							}
						}

						bFailed = true;
						if (pBindCur->dwPart & DBPART_STATUS)
							*((DBSTATUS*)((BYTE*)(pSrcData) + pBindCur->obStatus)) = DBSTATUS_E_CANTCONVERTVALUE;
						continue;
					}
				}
				cbCol = cbDst;	// Leave room for NULL term. need to copy for WSTR
			}
			break;
		case DBTYPE_WSTR:
		case DBTYPE_BSTR:
			if (bReading)
				cbCol = lstrlenW((LPWSTR)(((BYTE*)pSrcData) + pColCur->cbOffset)) * sizeof(WCHAR);
			else
			{
				if (pBindCur->dwPart & DBPART_LENGTH)
					cbCol = *((DBLENGTH*)((BYTE*)(pSrcData) + pBindCur->obLength));
				else
					cbCol = lstrlenW((LPWSTR)(pSrcData)) * sizeof(WCHAR);

				if (cbCol >= cbDst)
				{
					if (cbCol > (cbDst + 1)) // over maximum case
					{
						__if_exists(T::Fire_OnFieldChange)
						{
							if (/* pRow->m_status != DBPENDINGSTATUS_NEW && */
								pRow->m_status != (DBPENDINGSTATUS_NEW | DBPENDINGSTATUS_UNCHANGED))
							{
								pT->Fire_OnFieldChange(pT, hNotifyRow, pBinding->cBindings,
									rgColumns.GetData(), DBREASON_COLUMN_SET,
									DBEVENTPHASE_FAILEDTODO, TRUE);
							}
						}

						bFailed = true;
						if (pBindCur->dwPart & DBPART_STATUS)
							*((DBSTATUS*)((BYTE*)(pSrcData) + pBindCur->obStatus)) = DBSTATUS_E_CANTCONVERTVALUE;
						continue;
					}
				}
				cbCol = cbDst;	// Leave room for NULL term. need to copy for WSTR
			}
			break;
		case DBTYPE_BYTES:
			if (bReading)
				cbCol = pColCur->ulColumnSize;
			else
			{
				if (pBindCur->dwPart & DBPART_LENGTH)
					cbCol = *((DBLENGTH *)((BYTE*)(pSrcData) + pBindCur->obLength));
				else
				{
					__if_exists(T::Fire_OnFieldChange)
					{
						if (/* pRow->m_status != DBPENDINGSTATUS_NEW && */
							pRow->m_status != (DBPENDINGSTATUS_NEW | DBPENDINGSTATUS_UNCHANGED))
						{
							pT->Fire_OnFieldChange(pT, hNotifyRow, pBinding->cBindings,
								rgColumns.GetData(), DBREASON_COLUMN_SET,
								DBEVENTPHASE_FAILEDTODO, TRUE);
						}
					}

					// If no length part is bound for DBTYPE_BYTES, it is an error
					bFailed = true;
					continue;
				}

				if (cbCol >= cbDst)
					cbCol = cbDst;	// Leave room for NULL term. need to copy for WSTR
			}
			break;
		default:
			if (bReading)
				cbCol = pColCur->ulColumnSize;
			else
				cbDst = pColCur->ulColumnSize;

			break;
		}
		cbDst=cbCol;

		// Handle cases where we have provider owned memory.  Note, these should be
		// with DBTYPE_BYREF (otherwise, it doesn't make sense).
		if (pBindCur->dwPart & DBPART_VALUE)
		{
			if (pBindCur->dwMemOwner == DBMEMOWNER_PROVIDEROWNED
				&& pBindCur->wType & DBTYPE_BYREF)
			{
				ATLENSURE_RETURN(pDstTemp);
				*(BYTE**)pDstTemp = pSrcTemp;
			}
			else
			{
				ATLASSERT(pT->m_spConvert != NULL);
				ATLASSUME(pDstTemp != NULL);

				hr = pT->m_spConvert->DataConvert(pColCur->wType, pBindCur->wType,
						cbCol, &cbDst, pSrcTemp, pDstTemp, pBindCur->cbMaxLen,
						dbStat, &dbStat, pBindCur->bPrecision, pBindCur->bScale,0);
			}
		}
		if (pBindCur->dwPart & DBPART_LENGTH)
		{
			if (bReading)
				*((DBLENGTH*)((BYTE*)(pDstData) + pBindCur->obLength)) = (dbStat == DBSTATUS_S_ISNULL) ? 0 : cbDst;
			else
				*((DBLENGTH*)((BYTE*)(pSrcData) + pBindCur->obLength)) = cbDst;
		}
		if (pBindCur->dwPart & DBPART_STATUS)
		{
			if (bReading)
				*((DBSTATUS*)((BYTE*)(pDstData) + pBindCur->obStatus)) = dbStat;
			else
				*((DBSTATUS*)((BYTE*)(pSrcData) + pBindCur->obStatus)) = dbStat;
		}

		if (FAILED(hr))
		{
			if (!bReading)
			{
				__if_exists(T::Fire_OnFieldChange)
				{
					if (/* pRow->m_status != DBPENDINGSTATUS_NEW && */
						pRow->m_status != (DBPENDINGSTATUS_NEW | DBPENDINGSTATUS_UNCHANGED))
					{
						pT->Fire_OnFieldChange(pT, hNotifyRow, pBinding->cBindings,
							rgColumns.GetData(), DBREASON_COLUMN_SET,
							DBEVENTPHASE_FAILEDTODO, TRUE);
					}
				}
			}

			bFailed = true;
		}
		else
		{
			bSucceeded = true;
		}
	}

	// Return error codes to the consumer
	if (bFailed)
	{
		__if_exists(T::Fire_OnFieldChange)
		{
			if( !bReading )
			{
//				SendColumnSetFailureNotification( pT, hNotifyRow, pBinding, rgColumns );
				SendRowsFirstChangeFailureNotification( pT, pRow, &hNotifyRow, bDeferred );
			}
		}
		return (bSucceeded != false) ? DB_S_ERRORSOCCURRED : DB_E_ERRORSOCCURRED;
	}
	else
	{
		if (!bReading)
		{
			__if_exists(T::Fire_OnFieldChange)
			{
				if (/* pRow->m_status != DBPENDINGSTATUS_NEW && */
					pRow->m_status != (DBPENDINGSTATUS_NEW | DBPENDINGSTATUS_UNCHANGED))
				{
					pT->Fire_OnFieldChange(pT, hNotifyRow, pBinding->cBindings,
						rgColumns.GetData(), DBREASON_COLUMN_SET,
						DBEVENTPHASE_DIDEVENT, TRUE);
				}
			}
		}

		return hr;
	}
}

template <class T, class Storage,
		  class BaseInterface = IRowsetChange,
		  class RowClass = CSimpleRow,
		  class MapClass = CAtlMap < RowClass::KeyType, RowClass* > >
class ATL_NO_VTABLE IRowsetChangeImpl :
	public BaseInterface
{
public:
	// IRowsetChange Methods
	STDMETHOD (DeleteRows)(
		_In_ HCHAPTER /*hReserved*/,
		_In_ DBCOUNTITEM cRows,
		_In_count_(cRows) const HROW rghRows[],
		_Out_opt_cap_(cRows) DBROWSTATUS rgRowStatus[])
	{
		ATLTRACE(atlTraceDBProvider, 2, _T("IRowsetChangeImpl::DeleteRows"));

		T* pT = (T*)this;
		T::ObjectLock lock(pT);

		__if_exists(T::Fire_OnRowChange)
		{
			// Check to see if someone is in an event handler.  If we do, then
			// we should return DB_E_NOTREENTRANT.
			if (!pT->IncrementMutex())
				return DB_E_NOTREENTRANT;
			else
				pT->DecrementMutex();
		}

		BOOL bSuccess = false;
		BOOL bFailed = false;
		// Check to see if the DBPROP_UPDATABILITY value DBPROPVAL_UP_CHANGE
		// is set.  If not, then this method should return DB_E_NOTSUPPORTED.
		CComVariant varChange;
		HRESULT hr = pT->GetPropValue(&DBPROPSET_ROWSET, DBPROP_UPDATABILITY,
							&varChange);
		if (!(varChange.iVal & DBPROPVAL_UP_DELETE))
			return DB_E_NOTSUPPORTED;

		// NO-OP if cRows is zero
		if (cRows == 0)
			return S_OK;

		if (rghRows == NULL && cRows >= 1)
			return E_INVALIDARG;

		// Determine if we're in immediate or deferred mode
		CComVariant varDeferred;
		bool bDeferred;
		hr = pT->GetPropValue(&DBPROPSET_ROWSET, DBPROP_IRowsetUpdate,
							&varDeferred);
		(FAILED(hr) || varDeferred.boolVal == ATL_VARIANT_FALSE) ? bDeferred = false : bDeferred = true;


		// Loop through and delete rows
		for (DBCOUNTITEM l=0; l<cRows; l++)
		{
			HROW hRow = rghRows[l];
			RowClass* pRow;
			DBROWSTATUS rowStat = DBROWSTATUS_S_OK;

			// Handle events
			__if_exists(T::Fire_OnRowChange)
			{
				HRESULT hrNotify = pT->Fire_OnRowChange(pT, 1, &rghRows[l],
					DBREASON_ROW_DELETE, DBEVENTPHASE_OKTODO, FALSE);
				if (hrNotify == S_FALSE)
				{
					bFailed |= true;
					if (rgRowStatus != NULL)
						rgRowStatus[l] = DBROWSTATUS_E_CANCELED;
					continue;
				}
				else
				{
					hrNotify = pT->Fire_OnRowChange(pT, 1, &rghRows[l],
						DBREASON_ROW_DELETE, DBEVENTPHASE_ABOUTTODO, FALSE);
					if (hrNotify == S_FALSE)
					{
						bFailed |= true;
						if (rgRowStatus != NULL)
							rgRowStatus[l] = DBROWSTATUS_E_CANCELED;

						continue;
					}
				}

				// Send sync after now as it gets tricky to replace stuff once
				// we're in the method.
				hrNotify = pT->Fire_OnRowChange(pT, 1, &rghRows[l],
					DBREASON_ROW_DELETE, DBEVENTPHASE_SYNCHAFTER, FALSE);
				if (hrNotify == S_FALSE)
				{
					bFailed |= true;
					if (rgRowStatus != NULL)
						rgRowStatus[l] = DBROWSTATUS_E_CANCELED;

					continue;
				}
			}

			// Attempt to locate the row in our map
			bool bFound = pT->m_rgRowHandles.Lookup(hRow, pRow);
			if (!bFound || pRow == NULL)
			{
				bFailed |= true;
				if (rgRowStatus != NULL)
					rgRowStatus[l] = DBROWSTATUS_E_INVALID;
				continue;
			}

			// Check if the row has already been deleted.  Note, we
			// use DBPENDINGSTATUS_DELETED in the immediate case as
			// well.
			if (pRow->m_status == DBPENDINGSTATUS_DELETED)
			{
				__if_exists(T::Fire_OnRowChange)
				{
					pT->Fire_OnRowChange(pT, 1, &rghRows[l],
						DBREASON_ROW_DELETE, DBEVENTPHASE_FAILEDTODO,
						TRUE);
				}

				if (rgRowStatus != NULL)
					rgRowStatus[l] = DBROWSTATUS_E_DELETED;
				bFailed |= true;
				continue;
			}


			// Delete the row
			if (bDeferred)
			{
				// Mark the row as deleted but do not remove it until
				// IRowsetUpdate::Update is called.
				if (pRow->m_status != DBPENDINGSTATUS_INVALIDROW)
				{
					__if_exists(T::Fire_OnRowChange)
					{
						pT->Fire_OnRowChange(pT, 1, &rghRows[l], DBREASON_ROW_DELETE,
							DBEVENTPHASE_DIDEVENT, FALSE);
					}
					bSuccess |= true;
					rowStat = DBROWSTATUS_S_OK;
				}
				else
				{
					__if_exists(T::OnRowChange)
					{
						pT->Fire_OnRowChange(pT, 1, &rghRows[l],
							DBREASON_ROW_DELETE, DBEVENTPHASE_FAILEDTODO,
							FALSE);
					}

					bFailed |= true;
					// unsigned high bit signified neg. number
					if (pRow->m_dwRef & 0x80000000)
						rowStat = DBROWSTATUS_E_INVALID;
					else
						rowStat = DBROWSTATUS_E_DELETED;
				}
			}
			else
			{
				// Remove the m_rgRowData and m_rgRowLink entries.  The
				// HROW will be released in IRowset::ReleaseRows.
				// Remove the link by NULLing out the pointer
				if( pRow->m_iRowset < 0 || pRow->m_iRowset >= pT->m_rgRowData.GetCount() )
				{
					__if_exists(T::Fire_OnRowChange)
					{
						pT->Fire_OnRowChange(pT, 1, &rghRows[l],
							DBREASON_ROW_DELETE, DBEVENTPHASE_FAILEDTODO,
							FALSE);
					}

					rowStat = DBROWSTATUS_E_INVALID;
					bFailed |= true;
				}
				else
				{
					pT->m_rgRowData.RemoveAt(pRow->m_iRowset);

					// Perform the actual delete of the row.  Send notificaitons
					// to inform the consumer of the change.

					// Need to update any outstanding pRow->m_iRowset
					// variables
					POSITION pos = pT->m_rgRowHandles.GetStartPosition();
					while (pos != NULL)
					{
						MapClass::CPair* pPair = pT->m_rgRowHandles.GetNext( pos );
						ATLENSURE_RETURN( pPair != NULL );
						RowClass* pCheckRow = pPair->m_value;
						if (pCheckRow != NULL &&
							pCheckRow->m_iRowset > pRow->m_iRowset)
							pCheckRow->m_iRowset--;
					}

					__if_exists(T::GetRowsAt)
					{
						// If we support bookmarks, then ensure our bookmark array
						// is solid
						for (size_t k=0; k<pT->m_rgBookmarks.GetCount(); k++)
						{
							if (pT->m_rgBookmarks[k] == (DBROWCOUNT)(pRow->m_iRowset + 1))
								pT->m_rgBookmarks[k] = -1;		// Value for invalid bookmark

							if (pT->m_rgBookmarks[k] > (DBROWCOUNT)(pRow->m_iRowset + 1))
								pT->m_rgBookmarks[k] = (pT->m_rgBookmarks[k] - 1);
						}
					}

					if (FAILED(pT->FlushData(rghRows[l], NULL)))
					{
						__if_exists(T::Fire_OnRowChange)
						{
							pT->Fire_OnRowChange(pT, 1, &rghRows[l],
								DBREASON_ROW_DELETE, DBEVENTPHASE_FAILEDTODO,
								FALSE);
						}
						bFailed |= true;
						rowStat = DBROWSTATUS_E_FAIL;
					}
					else
					{
						// Send DIDEVENT
						__if_exists(T::Fire_OnRowChange)
						{
							pT->Fire_OnRowChange(pT, 1, &rghRows[l],
								DBREASON_ROW_DELETE, DBEVENTPHASE_DIDEVENT, FALSE);
						}
						rowStat = DBROWSTATUS_S_OK;
						bSuccess |= true;
					}
				}
			}

			// We use the status even in immediate mode to determine if a
			// row has been deleted from the cache but not release
			if (pRow->m_status == DBPENDINGSTATUS_NEW)
				pRow->m_status = DBPENDINGSTATUS_INVALIDROW;
			else
			{
				if (pRow->m_status != DBPENDINGSTATUS_INVALIDROW)
					pRow->m_status = DBPENDINGSTATUS_DELETED;
			}


			if (rgRowStatus != NULL)
				rgRowStatus[l] = rowStat;
		}



		hr = S_OK;
		if (bFailed)
			(bSuccess) ? hr = DB_S_ERRORSOCCURRED : hr = DB_E_ERRORSOCCURRED;

		return hr;
	}

	STDMETHOD (SetData)(
		_In_ HROW hRow,
		_In_ HACCESSOR hAccessor,
		_In_opt_ void* pSrcData)
	{
		ATLTRACE(atlTraceDBProvider, 2, _T("IRowsetChangeImpl::SetData\n"));

		T* pT = (T*)this;
		T::ObjectLock lock(pT);

		__if_exists(T::Fire_OnFieldChange)
		{
			// Check to see if someone is in an event handler.  If we do, then
			// we should return DB_E_NOTREENTRANT.
			if (!pT->IncrementMutex())
				return DB_E_NOTREENTRANT;
			else
				pT->DecrementMutex();
		}

		RowClass* pRow;

		// Check to see if the DBPROP_UPDATABILITY value DBPROPVAL_UP_CHANGE
		// is set.  If not, then this method should return DB_E_NOTSUPPORTED.
		CComVariant varChange;
		HRESULT hr = pT->GetPropValue(&DBPROPSET_ROWSET, DBPROP_UPDATABILITY,
							&varChange);
		if (!(varChange.iVal & DBPROPVAL_UP_CHANGE))
			return DB_E_NOTSUPPORTED;


		if (hRow == NULL)
			return DB_E_BADROWHANDLE;
		if( ! pT->m_rgRowHandles.Lookup(hRow, pRow) )
			return DB_E_BADROWHANDLE;
		if (hRow == NULL || pRow == NULL)
			return DB_E_BADROWHANDLE;
		hr = TransferData<T, RowClass, MapClass>
								 (pT, false, pSrcData, pRow, &(pT->m_rgRowHandles), hAccessor);
		if (FAILED(hr))
			return hr;

		// Flush Users Data
		HRESULT hrFlush = pT->FlushData(hRow, hAccessor);

		if (SUCCEEDED(hrFlush))
			return hr;	// note: we could have DB_S_ERRORSOCCURRED from TransferData
		else
			return hrFlush;
	}

	STDMETHOD (InsertRow)(
		_In_ HCHAPTER /*hReserved*/,
		_In_ HACCESSOR hAccessor,
		_In_opt_ void* pData,
		_Out_opt_ HROW* phRow)
	{
		ATLTRACE(atlTraceDBProvider, 2, _T("IRowsetChangeImpl::InsertRow\n"));

		T* pT = (T*) this;
		T::ObjectLock lock(pT);

		__if_exists(T::Fire_OnRowChange)
		{
			HRESULT hrNotify = S_OK;	// Used for responses to notifications

			// Check to see if someone is in an event handler.  If we do, then
			// we should return DB_E_NOTREENTRANT.
			if (!pT->IncrementMutex())
			{
				// Note, we can't set this above because we may inadvertantly
				// step on someone elses *phRow
				if (phRow != NULL)
					*phRow = NULL;
				return DB_E_NOTREENTRANT;
			}
			else
				pT->DecrementMutex();
		}

		// Check to see if the DBPROP_UPDATABILITY value DBPROPVAL_UP_CHANGE
		// is set.  If not, then this method should return DB_E_NOTSUPPORTED.
		CComVariant varChange;
		HRESULT hr = pT->GetPropValue(&DBPROPSET_ROWSET, DBPROP_UPDATABILITY,
							&varChange);
		if (!(varChange.iVal & DBPROPVAL_UP_INSERT))
			return DB_E_NOTSUPPORTED;


		if (phRow != NULL)
			*phRow = NULL;

		// validate that the hAccessor is valid
		T::_BindType* pBinding;
		bool bFound = pT->m_rgBindings.Lookup((INT_PTR)hAccessor, pBinding);
		if (!bFound || pBinding == NULL)
			return DB_E_BADACCESSORHANDLE;

		// validate parameters
		if (pData == NULL && pBinding->cBindings != 0)
			return E_INVALIDARG;

		// Check to see if DBPROP_CANHOLDROWS is set to false.  In this case,
		// return a DB_E_ROWSNOTRELEASED if there are any pending changes.
		CComVariant varHoldRows;
		hr = pT->GetPropValue(&DBPROPSET_ROWSET, DBPROP_CANHOLDROWS,
			&varHoldRows);

		if (FAILED(hr) || varHoldRows.boolVal == ATL_VARIANT_FALSE)
		{
			if (pT->m_rgRowHandles.GetCount() > 0)
			{
				RowClass* pCheckRow = NULL;
				POSITION pos = pT->m_rgRowHandles.GetStartPosition();

				while (pos != NULL)
				{
					MapClass::CPair* pPair = pT->m_rgRowHandles.GetNext(pos);
					ATLENSURE_RETURN( pPair != NULL );
					HROW hCheckRow = pPair->m_key;
					bool bFoundHandle = pT->m_rgRowHandles.Lookup(hCheckRow, pCheckRow);

					if (bFoundHandle && pCheckRow != NULL &&
						pCheckRow->m_status != DBPENDINGSTATUS_UNCHANGED)
						return DB_E_ROWSNOTRELEASED;
				}
			}
		}

		// We should check DBPROP_IMMOBILEROWS and then call an
		//		ordering routine in the user's code.
		// Create a row and place into m_rgRowData
		Storage newRow;		// Create an instance of the users data
		CComVariant var;
		HRESULT hrProps = pT->GetPropValue(&DBPROPSET_ROWSET,
			DBPROP_BOOKMARKS, &var);
		if (SUCCEEDED(hrProps) && var.boolVal != ATL_VARIANT_FALSE)
		{
			DBORDINAL cCols;
			ATLCOLUMNINFO* pInfo = T::GetColumnInfo(pT, &cCols);
			ATLASSERT(pInfo != NULL);
			for (DBORDINAL i = 0;i < cCols; i++)
			{
				if (pInfo[i].iOrdinal == 0)
				{
					switch(pInfo[i].wType)
					{
					case DBTYPE_BYTES:
						*((DBBKMARK*)(&newRow + pInfo[i].cbOffset)) = (ULONG_PTR)(pT->m_rgRowData.GetCount() + 1);
						break;
					default:
						ATLASSERT(FALSE);
					};
				}
			}
		}

		// Call CreateRow to make a new hRow
		HROW hInsertedRow = NULL;
		DBCOUNTITEM ulRowsObtained = 0;

		size_t lSize = pT->m_rgRowData.GetCount();

		hr = pT->CreateRow((LONG_PTR)lSize, ulRowsObtained, &hInsertedRow);

		if (FAILED(hr))
		{
			return hr;
		}
		else
		{
			__if_exists(T::Fire_OnRowChange)
			{
				hrNotify = pT->Fire_OnRowChange(pT, 1, &hInsertedRow, DBREASON_ROW_INSERT,
					DBEVENTPHASE_OKTODO, FALSE);
				if ((hrNotify != S_OK) && (hrNotify != E_FAIL))
				{
					pT->m_rgRowHandles.RemoveKey((RowClass::KeyType)hInsertedRow);
					return DB_E_CANCELED;
				}

				hrNotify = pT->Fire_OnRowChange(pT, 1, &hInsertedRow, DBREASON_ROW_INSERT,
					DBEVENTPHASE_ABOUTTODO, FALSE);
				if ((hrNotify != S_OK) && (hrNotify != E_FAIL))
				{
					pT->m_rgRowHandles.RemoveKey((RowClass::KeyType)hInsertedRow);
					return DB_E_CANCELED;
				}
			}
		}

		// Add in the storage and linkeage for the row
		CComVariant varOrderedInsert;

		// Need to determine if we want ordered insertions
		bool bOrderedInsert;
		hr = pT->GetPropValue(&DBPROPSET_ROWSET, DBPROP_IMMOBILEROWS,
							&varOrderedInsert);
		(FAILED(hr) || varOrderedInsert.boolVal != ATL_VARIANT_FALSE) ?
			bOrderedInsert = false : bOrderedInsert = true;

		//if (!pT->m_rgRowData.Add(newRow))
		//{
		//	ATLTRACE(atlTraceDBProvider, 0, _T("Failed to add record Out of Memory"));
		//	return E_OUTOFMEMORY;
		//}
		_ATLTRY
		{
			pT->m_rgRowData.Add(newRow);
		}
		_ATLCATCH( e )
		{
			_ATLDELETEEXCEPTION( e );
			ATLTRACE(atlTraceDBProvider, 0, _T("Failed to add record Out of Memory"));
			return E_OUTOFMEMORY;
		}

		// Set the inserted row's status to DBPENDINGSTATUS_NEW if it is deferred.
		// This will prevent a spurious Notification for ROW_FIRSTCHANGE from
		// firing in IRowsetUpdateImpl::SetData.
		CComVariant varDeferred;
		bool bDeferred;
		HRESULT hrDeferred = pT->GetPropValue(&DBPROPSET_ROWSET, DBPROP_IRowsetUpdate,
							&varDeferred);
		(FAILED(hrDeferred) || varDeferred.boolVal == ATL_VARIANT_FALSE) ? bDeferred = false : bDeferred = true;

		RowClass* pRow;
		ATLVERIFY( pT->m_rgRowHandles.Lookup(hInsertedRow, pRow) );
		ATLENSURE_RETURN(pRow != NULL);

		// Set the status to NEW + UNCHANGED so we don't generate COLUMN_SET or
		// FIRSTCHANGE events in SetData. We'll switch it back to zero after the
		// operation.
		pRow->m_status = DBPENDINGSTATUS_NEW | DBPENDINGSTATUS_UNCHANGED;

		// Call SetData, if necessary
		if (pData != NULL)
		{
			hr = SetData(hInsertedRow, hAccessor, pData);
			if (FAILED(hr))
			{
				__if_exists(T::Fire_OnRowChange)
				{
					pT->Fire_OnRowChange(pT, 1, &hInsertedRow, DBREASON_ROW_INSERT,
						DBEVENTPHASE_FAILEDTODO, TRUE);
				}
			}
		}

		if (!bDeferred)
			pRow->m_status = 0;
		else
			pRow->m_status = DBPENDINGSTATUS_NEW;

		__if_exists(T::Fire_OnRowChange)
		{
			hrNotify = pT->Fire_OnRowChange(pT, 1, &hInsertedRow, DBREASON_ROW_INSERT,
				DBEVENTPHASE_SYNCHAFTER, FALSE);
			if ((hrNotify != S_OK) && (hrNotify != E_FAIL))
			{
				// Remove storage
				RowClass* pRowInserted;
				ATLVERIFY( pT->m_rgRowHandles.Lookup(hInsertedRow, pRowInserted) );
				ATLENSURE_RETURN( pRowInserted != NULL );
				pT->m_rgRowData.RemoveAt(pRowInserted->m_iRowset);

				// Remove Handle
				pT->m_rgRowHandles.RemoveKey((RowClass::KeyType)hInsertedRow);

				return DB_E_CANCELED;
			}

			pT->Fire_OnRowChange(pT, 1, &hInsertedRow, DBREASON_ROW_INSERT,
				DBEVENTPHASE_DIDEVENT, TRUE);
		}

		if (phRow != NULL && SUCCEEDED(hr))
			*phRow = hInsertedRow;

		return hr;
 	}

	// Callbacks to Provider
	HRESULT FlushData(
		_In_ HROW,
		_In_ HACCESSOR)
	{
		// The provider overrides this function to commit data to its store
		return S_OK;
	}
};


// IRowsetImpl
template <class T, class RowsetInterface,
		  class RowClass = CSimpleRow,
		  class MapClass = CAtlMap < RowClass::KeyType, RowClass* > >
class ATL_NO_VTABLE IRowsetImpl :
	public RowsetInterface
{
public:
	typedef RowClass _HRowClass;
	IRowsetImpl()
	{
		m_iRowset = 0;
		m_bCanScrollBack = false;
		m_bCanFetchBack = false;
		m_bRemoveDeleted = true;
		m_bIRowsetUpdate = false;
		m_bReset = true;
		m_bExternalFetch = false;
	}
	virtual ~IRowsetImpl()
	{
		//for (int i = 0; i < m_rgRowHandles.GetCount(); i++)
		//	delete (m_rgRowHandles.GetValueAt(i));
		POSITION pos = m_rgRowHandles.GetStartPosition();
		while( pos != NULL )
		{
			MapClass::CPair *pPair = m_rgRowHandles.GetNext(pos);
			if(pPair!=NULL)
			{
				delete pPair->m_value;
			}
			else
			{
				ATLASSERT(FALSE);
			}
		}
	}
	HRESULT RefRows(
		_In_ DBCOUNTITEM cRows,
		_In_count_(cRows) const HROW rghRows[],
		_Out_opt_cap_(cRows) DBREFCOUNT rgRefCounts[],
		_Out_opt_cap_(cRows) DBROWSTATUS rgRowStatus[],
		_In_ BOOL bAdd)
	{
		ATLTRACE(atlTraceDBProvider, 2, _T("IRowsetImpl::AddRefRows\n"));
		if (cRows == 0)
			return S_OK;
		if (rghRows == NULL)
			return E_INVALIDARG;
		T::ObjectLock cab((T*)this);
		BOOL bSuccess1 = FALSE;
		BOOL bFailed1 = FALSE;
		DBROWSTATUS rs;
		DWORD dwRef;

		__if_exists(T::Fire_OnRowChange)
		{
			// Maintain an array of handles w/ zero ref counts for notification
			CAtlArray<HROW>  arrZeroHandles;
		}

		for (ULONG iRow = 0; iRow < cRows; iRow++)
		{
			HROW hRowCur = rghRows[iRow];
			RowClass* pRow;
			bool bFoundCur = m_rgRowHandles.Lookup((RowClass::KeyType)hRowCur, pRow);
			if (!bFoundCur || pRow == NULL)
			{
				ATLTRACE(atlTraceDBProvider, 0, _T("Could not find HANDLE %x in list\n"), hRowCur);
				rs = DBROWSTATUS_E_INVALID;
				dwRef = 0;
				bFailed1 = TRUE;
			}
			else
			{

				if (pRow->m_status != DBPENDINGSTATUS_UNCHANGED &&
					pRow->m_status != DBPENDINGSTATUS_INVALIDROW &&
					pRow->m_dwRef == 0 && !bAdd)
				{
					if (rgRefCounts)
						rgRefCounts[iRow] = 0;
					if (rgRowStatus != NULL)
						rgRowStatus[iRow] = DBROWSTATUS_E_INVALID;
					bFailed1 = TRUE;
					continue;
				}

				// Check if we're in immediate or deferred mode
				CComVariant varDeferred;
				bool bDeferred;
				T* pT = (T*)this;
				HRESULT hr = pT->GetPropValue(&DBPROPSET_ROWSET,
					DBPROP_IRowsetUpdate, &varDeferred);
				(FAILED(hr) || varDeferred.boolVal == ATL_VARIANT_FALSE) ?
					bDeferred = false : bDeferred = true;

				if (!bDeferred && bAdd &&
					pRow->m_status == DBPENDINGSTATUS_DELETED)
				{
					bFailed1 = TRUE;
					if (rgRowStatus != NULL)
						rgRowStatus[iRow] = DBROWSTATUS_E_DELETED;
					continue;
				}

				if (bAdd)
					dwRef = pRow->AddRefRow();
				else
				{
					dwRef = pRow->ReleaseRow();
					if ((pRow->m_status != DBPENDINGSTATUS_UNCHANGED &&
						pRow->m_status != 0 &&
						pRow->m_status != DBPENDINGSTATUS_INVALIDROW) &&
						bDeferred)
					{
						if (rgRefCounts)
							rgRefCounts[iRow] = dwRef;
						if (rgRowStatus != NULL)
							rgRowStatus[iRow] = DBROWSTATUS_S_PENDINGCHANGES;
						bSuccess1 = TRUE;
						continue;
					}

					if (dwRef == 0)
					{
						__if_exists(T::Fire_OnRowsetChange)
						{
							_ATLTRY
							{
								arrZeroHandles.Add(hRowCur);
							}
							_ATLCATCH( e )
							{
								_ATLDELETEEXCEPTION( e );
								return E_FAIL;
							}
						}

						// Now determine if the DBPROP_REMOVEDELETED property
						// is ATL_VARIANT_FALSE.  If so, then do NOT remove the
						// row.
						hr = pT->GetPropValue(&DBPROPSET_ROWSET,
							DBPROP_REMOVEDELETED, &varDeferred);
						if (FAILED(hr) || varDeferred.boolVal != ATL_VARIANT_FALSE)
						{
							delete pRow;
							m_rgRowHandles.RemoveKey((RowClass::KeyType)hRowCur);
						}
					}
				}
				bSuccess1 = TRUE;
				rs = DBROWSTATUS_S_OK;
			}
			if (rgRefCounts)
				rgRefCounts[iRow] = dwRef;
			if (rgRowStatus != NULL)
				rgRowStatus[iRow] = rs;
		}

		__if_exists(T::Fire_OnRowsetChange)
		{
			if (!bAdd && arrZeroHandles.GetCount() > 0)
			{
				T* pT = (T*)this;
				pT->Fire_OnRowChange(pT, (ULONG_PTR)arrZeroHandles.GetCount(), arrZeroHandles.GetData(),
					DBREASON_ROW_RELEASE, DBEVENTPHASE_DIDEVENT, FALSE);
			}
		}

		if (!bSuccess1 && !bFailed1)
		{
			ATLTRACE(atlTraceDBProvider, 0, _T("IRowsetImpl::RefRows Unexpected state\n"));
			return E_FAIL;
		}
		HRESULT hr = S_OK;
		if (bSuccess1 && bFailed1)
			hr = DB_S_ERRORSOCCURRED;
		if (!bSuccess1 && bFailed1)
			hr = DB_E_ERRORSOCCURRED;
		return hr;
	}

	STDMETHOD(AddRefRows)(
		_In_ DBCOUNTITEM cRows,
		_In_count_(cRows) const HROW rghRows[],
		_Out_opt_cap_(cRows) DBREFCOUNT rgRefCounts[],
		_Out_opt_cap_(cRows) DBROWSTATUS rgRowStatus[])
	{
		ATLTRACE(atlTraceDBProvider, 2, _T("IRowsetImpl::AddRefRows\n"));
		if (cRows == 0)
			return S_OK;
		return RefRows(cRows, rghRows, rgRefCounts, rgRowStatus, TRUE);
	}
	virtual DBSTATUS GetDBStatus(
		_In_opt_ RowClass*,
		_In_opt_ ATLCOLUMNINFO*)
	{
		return DBSTATUS_S_OK;
	}
	virtual HRESULT SetDBStatus(
		_In_opt_ DBSTATUS*,
		_In_opt_ RowClass*,
		_In_opt_ ATLCOLUMNINFO*)
	{
		// The provider overrides this function to handle special processing
		// for DBSTATUS_S_ISNULL and DBSTATUS_S_DEFAULT.
		return S_OK;
	}

	OUT_OF_LINE HRESULT GetDataHelper(
		_In_ HACCESSOR hAccessor,
		_Out_ ATLCOLUMNINFO*& rpInfo,
		_Deref_out_ void** ppBinding,
		_Out_ void*& rpSrcData,
		_Out_ DBORDINAL& rcCols,
		_Inout_ CComPtr<IDataConvert>& rspConvert,
		_In_ RowClass* pRow)
	{
		ATLENSURE_RETURN(ppBinding != NULL);
		T* pT = (T*) this;
		T::_BindingVector::CPair* pPair = pT->m_rgBindings.Lookup( hAccessor );
		if (pPair == NULL || pPair->m_value == NULL)
			return DB_E_BADACCESSORHANDLE;
		*ppBinding = pPair->m_value;
		rpSrcData = (void*)&(pT->m_rgRowData[pRow->m_iRowset]);
		rpInfo = T::GetColumnInfo((T*)this, &rcCols);
		rspConvert = pT->m_spConvert;
		return S_OK;

	}
	STDMETHOD(GetData)(
		_In_ HROW hRow,
		_In_ HACCESSOR hAccessor,
		_In_opt_ void *pDstData)
	{
		T* pT = (T*)this;
		RowClass* pRow;
		if (hRow == NULL )
			return DB_E_BADROWHANDLE;

		if( !pT->m_rgRowHandles.Lookup((INT_PTR)hRow, pRow))
			return DB_E_BADROWHANDLE;

		if (pRow == NULL)
			return DB_E_BADROWHANDLE;

		return TransferData<T, RowClass, MapClass>
						   (pT, true, pDstData, pRow, &(pT->m_rgRowHandles), hAccessor);
	}

	HRESULT CreateRow(
		_In_ DBROWOFFSET lRowsOffset,
		_Inout_ DBCOUNTITEM& cRowsObtained,
		_Inout_ HROW* rgRows)
	{
		RowClass* pRow = NULL;
		ATLASSERT(lRowsOffset >= 0);
		RowClass::KeyType key = lRowsOffset+1;
		ATLASSERT(key > 0);
		bool bFound = m_rgRowHandles.Lookup(key,pRow);
		if (!bFound || pRow == NULL)
		{
			pRow=NULL;
			ATLTRY(pRow = new RowClass(lRowsOffset))
			if (pRow == NULL)
				return E_OUTOFMEMORY;
			_ATLTRY
			{
				m_rgRowHandles.SetAt(key, pRow);
			}
			_ATLCATCH( e )
			{
				_ATLDELETEEXCEPTION( e );
				delete pRow;
				pRow = NULL;
				return E_OUTOFMEMORY;
			}
		}
		pRow->AddRefRow();
		m_bReset = false;
		rgRows[cRowsObtained++] = (HROW)key;
		return S_OK;
	}

	HRESULT GetNextRowsSkipDeleted(
		_In_ HCHAPTER /*hReserved*/,
		_In_ DBROWOFFSET lRowsOffset,
		_In_ DBROWCOUNT cRows,
		_Out_ DBCOUNTITEM *pcRowsObtained,
		_Deref_post_cap_(*pcRowsObtained) HROW **prghRows)
	{
		ATLTRACE(atlTraceDBProvider, 2, _T("IRowsetImpl::GetNextRows\n"));
		T* pT = (T*) this;

		__if_exists(T::Fire_OnRowChange)
		{
			// Check to see if someone is in an event handler.  If we do, then
			// we should return DB_E_NOTREENTRANT.
			if (!pT->IncrementMutex())
			{
				// Note, we can't set this above this block because we may
				// inadvertantly reset somebody else's pcRowsObtained
				if (pcRowsObtained != NULL)
					*pcRowsObtained = 0;
				return DB_E_NOTREENTRANT;
			}
			else
				pT->DecrementMutex();
		}

		if (pcRowsObtained != NULL)
			*pcRowsObtained = 0;
		if (prghRows == NULL || pcRowsObtained == NULL)
			return E_INVALIDARG;
		if (cRows == 0)
			return S_OK;
		HRESULT hr = S_OK;
		T::ObjectLock cab(pT);
		if (lRowsOffset < 0 && !m_bCanScrollBack)
			return DB_E_CANTSCROLLBACKWARDS;
		if (cRows < 0  && !m_bCanFetchBack)
			return DB_E_CANTFETCHBACKWARDS;

		DBROWOFFSET cRowsInSet = (DBROWOFFSET)pT->m_rgRowData.GetCount();

		DBROWOFFSET iStepSize = cRows >= 0 ? 1 : -1;
		// If cRows == MINLONG_PTR, we can't use ABS on it.  Therefore, we reset it
		// to a value just greater than cRowsInSet
		if (cRows == MINLONG_PTR && cRowsInSet != MINLONG_PTR)
			cRows = cRowsInSet + 2;	// set the value to something we can deal with
		else
			cRows = AbsVal(cRows);

		// First, simulate the operation, skipping over any deleted rows, calculate the number of rows retrieved,
		// and return an error code if appropriate

		DBROWOFFSET nCurrentRow = m_iRowset;

		// Note, if m_bReset, m_iRowset must be 0
		if ( m_bReset && (lRowsOffset < 0 || ( lRowsOffset == 0 && iStepSize < 0 ) ) )
			nCurrentRow = cRowsInSet;

		// skip the rows according to the lRowsOffset value
		if( lRowsOffset > 0 )
		{
			DBROWOFFSET nRowsToSkip = lRowsOffset;

			while( nRowsToSkip > 0 && nCurrentRow <= cRowsInSet )
			{
				RowClass* pRow = NULL;
				RowClass::KeyType key = nCurrentRow + 1;
				bool bFound = m_rgRowHandles.Lookup(key,pRow);
				if( bFound && pRow != NULL )
				{
					if( pRow->m_status == DBPENDINGSTATUS_DELETED )
					{
						nCurrentRow++;
						continue;
					}
				}
				nCurrentRow++;
				nRowsToSkip--;
			}

			if( nCurrentRow > cRowsInSet )
				return DB_S_ENDOFROWSET;
		}
		else if( lRowsOffset < 0 )
		{
			DBROWOFFSET nRowsToSkip = lRowsOffset;
			if (nRowsToSkip == MINLONG_PTR && cRowsInSet != MINLONG_PTR)
				nRowsToSkip = cRowsInSet + 2;	// set the value to something we can deal with
			else
				nRowsToSkip = -nRowsToSkip;

			while( nRowsToSkip > 0 && nCurrentRow > 0 )
			{
				nCurrentRow--;

				RowClass* pRow = NULL;
				RowClass::KeyType key = nCurrentRow + 1;
				bool bFound = m_rgRowHandles.Lookup(key,pRow);
				if( bFound && pRow != NULL )
				{
					if( pRow->m_status == DBPENDINGSTATUS_DELETED )
					{
						continue;
					}
				}
				nRowsToSkip--;
			}

			if( nCurrentRow < 0 )
				return DB_S_ENDOFROWSET;
		}

		DBROWOFFSET nFetchStartPosition = nCurrentRow;

		// now fetch the rows
		DBROWOFFSET cRowsToFetch = cRows;
		DBROWOFFSET cRowsFetched = 0;
		if( iStepSize == 1 )
		{
			while( cRowsToFetch > 0 && nCurrentRow < cRowsInSet )
			{
				RowClass* pRow = NULL;
				RowClass::KeyType key = nCurrentRow + 1;
				bool bFound = m_rgRowHandles.Lookup(key,pRow);
				if( bFound && pRow != NULL )
				{
					if( pRow->m_status == DBPENDINGSTATUS_DELETED )
					{
						nCurrentRow++;
						continue;
					}
				}
				// now we would fetch the row
				cRowsFetched++;
				cRowsToFetch--;
				nCurrentRow++;
			}
		}
		else
		{
			while( cRowsToFetch > 0 && nCurrentRow > 0 )
			{
				nCurrentRow--;
				RowClass* pRow = NULL;
				RowClass::KeyType key = nCurrentRow + 1;
				bool bFound = m_rgRowHandles.Lookup(key,pRow);
				if( bFound && pRow != NULL )
				{
					if( pRow->m_status == DBPENDINGSTATUS_DELETED )
					{
						continue;
					}
				}
				// now we would fetch the row
				cRowsFetched++;
				cRowsToFetch--;
			}
		}

		//  we could not fetch any rows
		if( cRowsFetched == 0 )
			return DB_S_ENDOFROWSET;

		// Simulation completed... no problems detected... we can now perform the real fetching

		// Fire events for OKTODO and ABOUTTODO after all validation has taken
		// place but before any permanent changes to the rowset state take place
		__if_exists(T::Fire_OnRowsetChange)
		{
			// Only fire these events if we're not being called by a bookmark
			// operation (which is why m_bExternalFetch would be set to true)
			if(!m_bExternalFetch)
			{
				HRESULT hrNotify = pT->Fire_OnRowsetChange(pT,
					DBREASON_ROWSET_FETCHPOSITIONCHANGE, DBEVENTPHASE_OKTODO, FALSE);
				if (hrNotify == S_FALSE)
					return DB_E_CANCELED;
				else
				{
					hrNotify = pT->Fire_OnRowsetChange(pT, DBREASON_ROWSET_FETCHPOSITIONCHANGE,
						DBEVENTPHASE_ABOUTTODO, FALSE);
					if (hrNotify == S_FALSE)
						return DB_E_CANCELED;
					else
					{
						hrNotify = pT->Fire_OnRowsetChange(pT, DBREASON_ROWSET_FETCHPOSITIONCHANGE,
							DBEVENTPHASE_SYNCHAFTER, FALSE);
						if (hrNotify == S_FALSE)
							return DB_E_CANCELED;
					}
				}
			}
		}

		nCurrentRow = nFetchStartPosition; // we already calculated the 'start fetch position' in the simulation stage
		ATLASSERT( nCurrentRow >= 0 && nCurrentRow <= cRowsInSet );

		*pcRowsObtained = 0;
		CComHeapPtr<HROW> rghRowsAllocated;
		if (*prghRows == NULL)
		{
			DBROWOFFSET cHandlesToAlloc = cRowsFetched;

			rghRowsAllocated.Allocate(cHandlesToAlloc);
			if(rghRowsAllocated == NULL)
				return E_OUTOFMEMORY;

			*prghRows = rghRowsAllocated;
		}

		// now fetch the rows
		cRowsToFetch = cRows;

		while( cRowsToFetch > 0 && nCurrentRow >= 0 && nCurrentRow <= cRowsInSet )
		{
			if( ( iStepSize == 1 && nCurrentRow == cRowsInSet ) ||
				( iStepSize == -1 && nCurrentRow == 0 ) )
				break;

			DBROWOFFSET lRow = nCurrentRow;

			if( iStepSize > 0 )
			{
				while(true)
				{
					RowClass* pRow = NULL;
					RowClass::KeyType key = lRow + 1;
					bool bFound = m_rgRowHandles.Lookup(key,pRow);
					if( bFound && pRow != NULL )
					{
						if( pRow->m_status == DBPENDINGSTATUS_DELETED )
						{
							lRow++;
							ATLASSERT( lRow < cRowsInSet );
							continue;
						}
					}
					break;
				}
			}
			else
			{
				while(true)
				{
					lRow--;
					RowClass* pRow = NULL;
					RowClass::KeyType key = lRow + 1;
					bool bFound = m_rgRowHandles.Lookup(key,pRow);
					if( bFound && pRow != NULL )
					{
						if( pRow->m_status == DBPENDINGSTATUS_DELETED )
						{
							ATLASSERT( lRow >= 0 );
							continue;
						}
					}
					break;
				}
			}

			ATLASSERT( lRow >= 0 && lRow < cRowsInSet );

			hr = pT->CreateRow(lRow, *pcRowsObtained, *prghRows);

			if (FAILED(hr))
			{
				RefRows(*pcRowsObtained, *prghRows, NULL, NULL, FALSE);
				for (ULONG iRowDel = 0; iRowDel < *pcRowsObtained; iRowDel++)
					*prghRows[iRowDel] = NULL;
				*pcRowsObtained = 0;
				return hr;
			}

			__if_exists(T::Fire_OnRowsetChange)
			{
				if (!m_bExternalFetch)
					pT->Fire_OnRowsetChange(pT, DBREASON_ROWSET_FETCHPOSITIONCHANGE,
						DBEVENTPHASE_DIDEVENT, TRUE);
			}

			cRowsToFetch--;
			if( iStepSize > 0 )
				nCurrentRow = lRow + iStepSize;
			else
				nCurrentRow = lRow;
		} // while

		// If we have multiple rows fetched, return one event, per the specification
		// containing all rows activated.
		if (*pcRowsObtained >= 1)
		{
			__if_exists(T::Fire_OnRowsetChange)
			{
				CAtlArray<HROW> rgActivated;
				for (size_t ulActivated = 0; ulActivated < *pcRowsObtained; ulActivated++)
				{
					// This is a bit of an assumption that all newly activated
					// rows would have the ref count as 1.  Another way to solve this
					// problem would be to modify the signature of CreateRow to take
					// a CAtlArray<HROW> as a parameter and store the activated rows.
					RowClass* pActiveRow;
					if( m_rgRowHandles.Lookup((*prghRows)[ulActivated], pActiveRow ) &&
						(pActiveRow != NULL && pActiveRow->m_dwRef == 1) )
					{
						_ATLTRY
						{
							rgActivated.Add((*prghRows)[ulActivated]);
						}
						_ATLCATCH( e )
						{
							_ATLDELETEEXCEPTION( e );
							return E_OUTOFMEMORY;
						}
					}
				}
				if (rgActivated.GetCount() > 0)
				{
					pT->Fire_OnRowChange(pT, (DBCOUNTITEM)rgActivated.GetCount(), rgActivated.GetData(),
						DBREASON_ROW_ACTIVATE, DBEVENTPHASE_DIDEVENT, FALSE);
				}
			}
		}

		m_iRowset = nCurrentRow;
		if( *pcRowsObtained < (DBCOUNTITEM)cRows ) // we could not fetch the requested # of rows
			hr = DB_S_ENDOFROWSET;

		if (SUCCEEDED(hr))
			rghRowsAllocated.Detach();

		return hr;
	}

	STDMETHOD(GetNextRows)(
		_In_ HCHAPTER hReserved,
		_In_ DBROWOFFSET lRowsOffset,
		_In_ DBROWCOUNT cRows,
		_Out_ DBCOUNTITEM *pcRowsObtained,
		_Deref_post_cap_(*pcRowsObtained) HROW **prghRows)
	{

		if( m_bRemoveDeleted && m_bIRowsetUpdate )
			return GetNextRowsSkipDeleted( hReserved, lRowsOffset, cRows, pcRowsObtained, prghRows );

		DBROWOFFSET lTmpRows = lRowsOffset;
		ATLTRACE(atlTraceDBProvider, 2, _T("IRowsetImpl::GetNextRows\n"));
		T* pT = (T*) this;

		__if_exists(T::Fire_OnRowChange)
		{
			// Check to see if someone is in an event handler.  If we do, then
			// we should return DB_E_NOTREENTRANT.
			if (!pT->IncrementMutex())
			{
				// Note, we can't set this above this block because we may
				// inadvertantly reset somebody else's pcRowsObtained
				if (pcRowsObtained != NULL)
					*pcRowsObtained = 0;
				return DB_E_NOTREENTRANT;
			}
			else
				pT->DecrementMutex();
		}

		if (pcRowsObtained != NULL)
			*pcRowsObtained = 0;
		if (prghRows == NULL || pcRowsObtained == NULL)
			return E_INVALIDARG;
		if (cRows == 0)
			return S_OK;
		HRESULT hr = S_OK;
		T::ObjectLock cab(pT);
		if (lRowsOffset < 0 && !m_bCanScrollBack)
			return DB_E_CANTSCROLLBACKWARDS;
		if (cRows < 0  && !m_bCanFetchBack)
			return DB_E_CANTFETCHBACKWARDS;

		// Calculate # of rows in set and the base fetch position.  If the rowset
		// is at its head position, then lRowOffset < 0 means moving from the BACK
		// of the rowset and not the front.

		DBROWOFFSET cRowsInSet = (DBROWOFFSET)pT->m_rgRowData.GetCount();

		if (((lRowsOffset == MINLONG_PTR) && (cRowsInSet != MINLONG_PTR))
			|| AbsVal(lRowsOffset) > cRowsInSet ||
			( AbsVal(lRowsOffset) == cRowsInSet && lRowsOffset < 0 && cRows < 0 ) ||
			( AbsVal(lRowsOffset) == cRowsInSet && lRowsOffset > 0 && cRows > 0 ))
			return DB_S_ENDOFROWSET;

		// In the case where the user is moving backwards after moving forwards,
		// we do not wrap around to the end of the rowset.
		if ((m_iRowset == 0 && !m_bReset && cRows < 0) ||
			((m_iRowset + lRowsOffset) > cRowsInSet) ||
			(m_iRowset == cRowsInSet && lRowsOffset >= 0 && cRows > 0))
			return DB_S_ENDOFROWSET;

		// Fire events for OKTODO and ABOUTTODO after all validation has taken
		// place but before any permanent changes to the rowset state take place
		__if_exists(T::Fire_OnRowsetChange)
		{
			// Only fire these events if we're not being called by a bookmark
			// operation (which is why m_bExternalFetch would be set to true)
			if(!m_bExternalFetch)
			{
				HRESULT hrNotify = pT->Fire_OnRowsetChange(pT,
					DBREASON_ROWSET_FETCHPOSITIONCHANGE, DBEVENTPHASE_OKTODO, FALSE);
				if (hrNotify == S_FALSE)
					return DB_E_CANCELED;
				else
				{
					hrNotify = pT->Fire_OnRowsetChange(pT, DBREASON_ROWSET_FETCHPOSITIONCHANGE,
						DBEVENTPHASE_ABOUTTODO, FALSE);
					if (hrNotify == S_FALSE)
						return DB_E_CANCELED;
					else
					{
						hrNotify = pT->Fire_OnRowsetChange(pT, DBREASON_ROWSET_FETCHPOSITIONCHANGE,
							DBEVENTPHASE_SYNCHAFTER, FALSE);
						if (hrNotify == S_FALSE)
							return DB_E_CANCELED;
					}
				}
			}
		}

		// Note, if m_bReset, m_iRowset must be 0
		if (lRowsOffset < 0 && m_bReset)
			m_iRowset = cRowsInSet;

		int iStepSize = cRows >= 0 ? 1 : -1;

		// If cRows == MINLONG_PTR, we can't use ABS on it.  Therefore, we reset it
		// to a value just greater than cRowsInSet
		if (cRows == MINLONG_PTR && cRowsInSet != MINLONG_PTR)
			cRows = cRowsInSet + 2;	// set the value to something we can deal with
		else
			cRows = AbsVal(cRows);

		if (iStepSize < 0 && m_iRowset == 0 && m_bReset && lRowsOffset <= 0)
			m_iRowset = cRowsInSet;

		lRowsOffset += m_iRowset;

		*pcRowsObtained = 0;
		CComHeapPtr<HROW> rghRowsAllocated;
		if (*prghRows == NULL)
		{
			DBROWOFFSET cHandlesToAlloc = __min(cRowsInSet, cRows);
			if (iStepSize == 1 && (cRowsInSet - lRowsOffset) < cHandlesToAlloc)
				cHandlesToAlloc = cRowsInSet - lRowsOffset;
			if (iStepSize == -1 && lRowsOffset < cHandlesToAlloc)
				cHandlesToAlloc = lRowsOffset;

			rghRowsAllocated.Allocate(cHandlesToAlloc);
			if(rghRowsAllocated == NULL)
				return E_OUTOFMEMORY;
			*prghRows = rghRowsAllocated;
		}

		while ((lRowsOffset >= 0 && cRows != 0) &&
			((lRowsOffset < cRowsInSet) || (lRowsOffset <= cRowsInSet && iStepSize < 0)))
		{
			// cRows > cRowsInSet && iStepSize < 0
			if (lRowsOffset == 0 && cRows > 0 && iStepSize < 0)
				break;

			// in the case where we have iStepSize < 0, move the row back
			// further because we want the previous row
			DBROWOFFSET lRow = lRowsOffset;
			if ((lRowsOffset == 0) && (lTmpRows == 0) && (iStepSize < 0))
				lRow = cRowsInSet;

			if (iStepSize < 0)
				lRow += iStepSize;

			hr = pT->CreateRow(lRow, *pcRowsObtained, *prghRows);

			if (FAILED(hr))
			{
				RefRows(*pcRowsObtained, *prghRows, NULL, NULL, FALSE);
				for (ULONG iRowDel = 0; iRowDel < *pcRowsObtained; iRowDel++)
					*prghRows[iRowDel] = NULL;
				*pcRowsObtained = 0;
				return hr;
			}

			__if_exists(T::Fire_OnRowsetChange)
			{
				if (!m_bExternalFetch)
					pT->Fire_OnRowsetChange(pT, DBREASON_ROWSET_FETCHPOSITIONCHANGE,
						DBEVENTPHASE_DIDEVENT, TRUE);
			}

			cRows--;
			lRowsOffset += iStepSize;
		}

		// If we have multiple rows fetched, return one event, per the specification
		// containing all rows activated.
		if (*pcRowsObtained >= 1)
		{
			__if_exists(T::Fire_OnRowsetChange)
			{
				CAtlArray<HROW> rgActivated;
				for (size_t ulActivated = 0; ulActivated < *pcRowsObtained; ulActivated++)
				{
					// This is a bit of an assumption that all newly activated
					// rows would have the ref count as 1.  Another way to solve this
					// problem would be to modify the signature of CreateRow to take
					// a CAtlArray<HROW> as a parameter and store the activated rows.
					RowClass* pActiveRow;
					if( m_rgRowHandles.Lookup((*prghRows)[ulActivated], pActiveRow ) &&
						(pActiveRow != NULL && pActiveRow->m_dwRef == 1) )
					{
						_ATLTRY
						{
							rgActivated.Add((*prghRows)[ulActivated]);
						}
						_ATLCATCH( e )
						{
							_ATLDELETEEXCEPTION( e );
							return E_OUTOFMEMORY;
						}
					}
				}
				if (rgActivated.GetCount() > 0)
				{
					pT->Fire_OnRowChange(pT, (DBCOUNTITEM)rgActivated.GetCount(), rgActivated.GetData(),
						DBREASON_ROW_ACTIVATE, DBEVENTPHASE_DIDEVENT, FALSE);
				}
			}
		}

		m_iRowset = lRowsOffset;
		if ((lRowsOffset >= cRowsInSet && cRows) || (lRowsOffset < 0 && cRows)  ||
			(lRowsOffset == 0 && cRows > 0 && iStepSize < 0))
			hr = DB_S_ENDOFROWSET;

		if (SUCCEEDED(hr))
			rghRowsAllocated.Detach();
		return hr;
	}

	STDMETHOD(ReleaseRows)(
		_In_ DBCOUNTITEM cRows,
		_In_count_(cRows) const HROW rghRows[],
		_In_opt_ DBROWOPTIONS rgRowOptions[],
		_Out_opt_cap_(cRows) DBREFCOUNT rgRefCounts[],
		_Out_opt_cap_(cRows) DBROWSTATUS rgRowStatus[])
	{
		ATLTRACE(atlTraceDBProvider, 2, _T("IRowsetImpl::ReleaseRows\n"));

		__if_exists(T::Fire_OnRowChange)
		{
			T* pT = (T*) this;

			// Check to see if someone is in an event handler.  If we do, then
			// we should return DB_E_NOTREENTRANT.
			if (!pT->IncrementMutex())
				return DB_E_NOTREENTRANT;
			else
				pT->DecrementMutex();
		}

		if (cRows == 0)
			return S_OK;
		UNREFERENCED_PARAMETER(rgRowOptions);
		return RefRows(cRows, rghRows, rgRefCounts, rgRowStatus, FALSE);
	}

	STDMETHOD(RestartPosition)(_In_ HCHAPTER /*hReserved*/)
	{
		ATLTRACE(atlTraceDBProvider, 2, _T("IRowsetImpl::RestartPosition\n"));

		T* pT = (T*) this;

		__if_exists(T::Fire_OnRowsetChange)
		{
			// Check to see if someone is in an event handler.  If we do, then
			// we should return DB_E_NOTREENTRANT.
			if (!pT->IncrementMutex())
				return DB_E_NOTREENTRANT;
			else
				pT->DecrementMutex();


			bool bNeedEvents = ((m_iRowset != 0 || !m_bReset)) ? true : false;

			// Only fire the events iff. we are actually causing a reset
			if (bNeedEvents)
			{
				HRESULT hrNotify = pT->Fire_OnRowsetChange(pT,
					DBREASON_ROWSET_FETCHPOSITIONCHANGE, DBEVENTPHASE_OKTODO, FALSE);
				if (hrNotify == S_FALSE)
					return DB_E_CANCELED;
				else
				{
					hrNotify = pT->Fire_OnRowsetChange(pT, DBREASON_ROWSET_FETCHPOSITIONCHANGE,
						DBEVENTPHASE_ABOUTTODO, FALSE);
					if (hrNotify == S_FALSE)
						return DB_E_CANCELED;
					else
					{
						hrNotify = pT->Fire_OnRowsetChange(pT, DBREASON_ROWSET_FETCHPOSITIONCHANGE,
							DBEVENTPHASE_SYNCHAFTER, FALSE);
						if (hrNotify == S_FALSE)
							return DB_E_CANCELED;
					}
				}

			}
		}

		// Check to see if DBPROP_CANHOLDROWS is set to false.  In this case,
		// return a DB_E_ROWSNOTRELEASED.
		CComVariant varHoldRows;
		HRESULT hr = pT->GetPropValue(&DBPROPSET_ROWSET, DBPROP_CANHOLDROWS,
			&varHoldRows);

		if (FAILED(hr) || varHoldRows.boolVal == ATL_VARIANT_FALSE)
		{
			if (m_rgRowHandles.GetCount() > 0)
			{
				RowClass* pRow = NULL;
				POSITION pos = pT->m_rgRowHandles.GetStartPosition();

				while (pos != NULL)
				{
					MapClass::CPair* pPair = pT->m_rgRowHandles.GetNext(pos);
					ATLENSURE_RETURN( pPair != NULL );
					HROW hRow = pPair->m_key;
					bool bFound = pT->m_rgRowHandles.Lookup(hRow, pRow);

					if (bFound && pRow != NULL &&
						pRow->m_status != DBPENDINGSTATUS_UNCHANGED)
					{
						__if_exists(T::Fire_OnRowsetChange)
						{
							if (bNeedEvents)
							{
								pT->Fire_OnRowsetChange(pT, DBREASON_ROWSET_FETCHPOSITIONCHANGE,
										DBEVENTPHASE_FAILEDTODO, TRUE);
							}
						}

						return DB_E_ROWSNOTRELEASED;
					}
				}
			}
		}

		m_iRowset = 0;
		m_bReset = true;
		__if_exists(T::Fire_OnRowsetChange)
		{
			// listener must comply so blow off ret val.
			if (bNeedEvents)
				pT->Fire_OnRowsetChange(pT, DBREASON_ROWSET_FETCHPOSITIONCHANGE,
						DBEVENTPHASE_DIDEVENT, TRUE);
		}
		return S_OK;
	}

	MapClass  m_rgRowHandles;
	DBROWOFFSET m_iRowset; // cursor
	unsigned  m_bCanScrollBack:1;
	unsigned  m_bCanFetchBack:1;
	unsigned  m_bRemoveDeleted:1; // DBPROP_REMOVEDELETED
	unsigned  m_bIRowsetUpdate:1; // DBPROP_IRowsetUpdate
	unsigned  m_bReset:1;
	unsigned  m_bExternalFetch:1;
};


template <class T, class RowsetInterface,
		  class RowClass = CSimpleRow,
		  class MapClass = CAtlMap < RowClass::KeyType, RowClass* >,
		  class BookmarkKeyType = LONG, class BookmarkType = LONG,
		  class BookmarkMapClass = CAtlMap < RowClass::KeyType, RowClass* > >
class ATL_NO_VTABLE IRowsetLocateImpl :
	public IRowsetImpl<T, RowsetInterface, RowClass, MapClass>
{
public:
	STDMETHOD (Compare)(
		_In_ HCHAPTER /*hReserved*/,
		_In_ DBBKMARK cbBookmark1,
		_In_ const BYTE * pBookmark1,
		_In_ DBBKMARK cbBookmark2,
		_In_ const BYTE * pBookmark2,
		_Out_ DBCOMPARE * pComparison)
	{
		ATLTRACE(atlTraceDBProvider, 2, _T("IRowsetLocateImpl::Compare\n"));

		T* pT = (T*)this;

		__if_exists(T::Fire_OnRowChange)
		{
			// Check to see if someone is in an event handler.  If we do, then
			// we should return DB_E_NOTREENTRANT.
			if (!pT->IncrementMutex())
				return DB_E_NOTREENTRANT;
			else
				pT->DecrementMutex();
		}


		// Validate input parameters
		if (pComparison == NULL)
			return E_INVALIDARG;

		// ValidateBookmark catches the cbBookmark == 0 and the
		//		pBookmark == NULL -- E_INVALIDARG cases
		HRESULT hr = ValidateBookmark(cbBookmark1, pBookmark1);
		if (hr != S_OK)
			return hr;

		hr = ValidateBookmark(cbBookmark2, pBookmark2);
		if (hr != S_OK)
			return hr;

		// Return the value based on the bookmark values.  Be sure that
		// they are not specials in which case go below
		if ((*pBookmark1 == *pBookmark2) && (cbBookmark1 != 1) && (cbBookmark2 != 1))
		{
			*pComparison = DBCOMPARE_EQ;
			return S_OK;
		}

		// Determine if we are using ordered or unorder bookmarks
		CComVariant varOrdered;
		HRESULT hrProps = pT->GetPropValue(&DBPROPSET_ROWSET, DBPROP_ORDEREDBOOKMARKS,
			&varOrdered);

		if ((*pBookmark1 == DBBMK_FIRST && cbBookmark1 == 1) ||
			(*pBookmark1 == DBBMK_LAST  && cbBookmark1 == 1) ||
			(*pBookmark2 == DBBMK_FIRST && cbBookmark2 == 1) ||
			(*pBookmark2 == DBBMK_LAST  && cbBookmark2 == 1) ||
			(FAILED(hrProps)) ||
			(varOrdered.boolVal == ATL_VARIANT_FALSE))
		{
			// If the bookmarks are 'specials' DBBMK_FIRST or DBBMK_LAST or the
			// bookmarks are unordered, then we return NE instead of GT or LT.
			if (*pBookmark1 == *pBookmark2)
				*pComparison = DBCOMPARE_EQ;
			else
				*pComparison = DBCOMPARE_NE;
		}
		else
		{
			// We have valid bookmarks which are not special values.
			// Since we assume that bookmarks are ordered, we'll return
			// the
			if (*(DBBKMARK*)pBookmark1 < *(DBBKMARK*)pBookmark2)
				*pComparison = DBCOMPARE_LT;
			else if (*(DBBKMARK*)pBookmark1 > *(DBBKMARK*)pBookmark2)
				*pComparison = DBCOMPARE_GT;
			else
				*pComparison = DBCOMPARE_EQ;
		}

		return S_OK;
	}

	STDMETHOD (GetRowsAt)(
		_In_ HWATCHREGION /*hReserved1*/,
		_In_ HCHAPTER hReserved2,
		_In_ DBBKMARK cbBookmark,
		_In_ const BYTE* pBookmark,
		_In_ DBROWOFFSET lRowsOffset,
		_In_ DBROWCOUNT cRows,
		_Out_ DBCOUNTITEM* pcRowsObtained,
		_Deref_out_ HROW** prghRows)
	{
		ATLTRACE(atlTraceDBProvider, 2, _T("IRowsetLocateImpl::GetRowsAt\n"));

		T* pT = (T*)this;

		__if_exists(T::Fire_OnRowChange)
		{
			// Check to see if someone is in an event handler.  If we do, then
			// we should return DB_E_NOTREENTRANT.
			if (!pT->IncrementMutex())
				return DB_E_NOTREENTRANT;
			else
				pT->DecrementMutex();
		}

		T::ObjectLock cab(pT);

		// Check input parameters
		if (pcRowsObtained == NULL)
			return E_INVALIDARG;

		*pcRowsObtained = 0;

		if (cbBookmark == 0 || pBookmark == NULL || prghRows == NULL)
			return E_INVALIDARG;

		// Check bookmark
		HRESULT hr = ValidateBookmark(cbBookmark, pBookmark);
		if (hr != S_OK)
			return hr;

		// Set the current row position to the bookmark.  Handle any
		// normal values

		// We need to handle the offset as the start position is defined
		// as the bookmark + offset.  If the offset is negative, and we
		// do not have m_bCanScrollBack then return an error.  The
		// GetNextRows function handles the case where cRows is negative
		// and we don't have m_bCanFetchBack set.
		if (lRowsOffset < 0 && !m_bCanScrollBack)
			return DB_E_CANTSCROLLBACKWARDS;

		DBROWOFFSET iRowsetTemp = m_iRowset;  // Cache the current rowset

		// Determine if this row is deleted or not.
		size_t lBookmarkIndex = (size_t)(*pBookmark);

		// -1 is uniform value for a deleted bookmark
		if( cbBookmark != 1 )
		{
			if (m_rgBookmarks[lBookmarkIndex] == -1)
			{
				m_iRowset = iRowsetTemp;
				return DB_E_BADBOOKMARK;
			}
			else
			{
				m_iRowset = m_rgBookmarks[lBookmarkIndex];
			}
		}

		if ((cbBookmark == 1) && (*pBookmark == DBBMK_FIRST))
			m_iRowset = 1;

		if ((cbBookmark == 1) && (*pBookmark == DBBMK_LAST))
			m_iRowset = (DBROWOFFSET)pT->m_rgRowData.GetCount();

		// Set the start position to m_iRowset + lRowsOffset
		m_iRowset += lRowsOffset;

		if (lRowsOffset >= 0)
			(cRows >= 0) ? m_iRowset -= 1 : m_iRowset +=0;
		else
			(cRows >= 0) ? m_iRowset -= 1 : m_iRowset +=0;
//		(lRowsOffset >= 0) ? m_iRowset -= 1 : m_iRowset += 1;

		// BUG: If we get DBBMK_FIRST and lRowsOffset == -1, then we set
		// m_iRowset to 0xFFFFFFFF.

		if (m_iRowset < 0 || m_iRowset > (DBROWOFFSET)pT->m_rgRowData.GetCount())
		{
			m_iRowset = iRowsetTemp;
			return DB_S_ENDOFROWSET;
		}

		// Call IRowsetImpl::GetNextRows to actually get the rows.
		m_bExternalFetch = true;
		hr = GetNextRows(hReserved2, 0, cRows, pcRowsObtained, prghRows);
		m_bExternalFetch = false;

		// If we have multiple rows fetched, return one event, per the specification
		// containing all rows activated.
		if (*pcRowsObtained >= 1)
		{
			__if_exists(T::Fire_OnRowsetChange)
			{
				CAtlArray<HROW> rgActivated;
				for (ULONG ulActivated = 0; ulActivated < *pcRowsObtained; ulActivated++)
				{
					// This is a bit of an assumption that all newly activated
					// rows would have the ref count as 1.  Another way to solve this
					// problem would be to modify the signature of CreateRow to take
					// a CAtlArray<HROW> as a parameter and store the activated rows.
					RowClass* pActiveRow;
					bool bFound = m_rgRowHandles.Lookup((*prghRows)[ulActivated], pActiveRow);
					if ( bFound && pActiveRow != NULL && pActiveRow->m_dwRef == 1)
					{
						_ATLTRY
						{
							rgActivated.Add((*prghRows)[ulActivated]);
						}
						_ATLCATCH( e )
						{
							_ATLDELETEEXCEPTION( e );
							return E_OUTOFMEMORY;
						}
					}
				}
				if (rgActivated.GetCount() > 0)
				{
					pT->Fire_OnRowChange(pT, (DBCOUNTITEM)rgActivated.GetCount(), rgActivated.GetData(),
						DBREASON_ROW_ACTIVATE, DBEVENTPHASE_DIDEVENT, FALSE);
				}
			}
		}

		m_iRowset = iRowsetTemp;
		return hr;
	}

	STDMETHOD (GetRowsByBookmark)(
		_In_ HCHAPTER /*hReserved*/,
		_In_ DBCOUNTITEM cRows,
		_In_count_(cRows) const DBBKMARK rgcbBookmarks[],
		_In_count_(cRows) const BYTE* rgpBookmarks[],
		_Out_cap_(cRows) HROW rghRows[],
		_Out_opt_cap_(cRows) DBROWSTATUS rgRowStatus[])
	{
		HRESULT hr = S_OK;
		ATLTRACE(atlTraceDBProvider, 2, _T("IRowsetLocateImpl::GetRowsByBookmark\n"));
		bool bErrors = false;
		bool bSuccess = false;

		T* pT = (T*)this;

		__if_exists(T::Fire_OnRowChange)
		{
			// Check to see if someone is in an event handler.  If we do, then
			// we should return DB_E_NOTREENTRANT.
			if (!pT->IncrementMutex())
				return DB_E_NOTREENTRANT;
			else
				pT->DecrementMutex();
		}

		T::ObjectLock cab(pT);
		if (rgcbBookmarks == NULL || rgpBookmarks == NULL || rghRows == NULL)
			return E_INVALIDARG;

		if (cRows == 0)
			return S_OK;	// No rows fetched in this case.

		memset(rghRows, 0, sizeof(HROW)*cRows);
		for (size_t l=0; l<cRows; l++)
		{
			// Validate each bookmark before fetching the row.  Note, it is
			// an error for the bookmark to be one of the standard values
			const BYTE* pBookmark = rgpBookmarks[l];
			hr = ValidateBookmark(rgcbBookmarks[l], pBookmark);
			if ((hr != S_OK) ||
				(*pBookmark == DBBMK_FIRST && rgcbBookmarks[l] == 1) ||
				(*pBookmark == DBBMK_LAST && rgcbBookmarks[l] == 1))
			{
				bErrors |= true;
				if (rgRowStatus != NULL)
				{
					rgRowStatus[l] = DBROWSTATUS_E_INVALID;
					continue;
				}
			}

			// Determine if this row is deleted or not by first looking in our cache
			DBROWCOUNT lBookmarkIndex = *(DBROWCOUNT*)pBookmark;
			if (m_rgBookmarks[lBookmarkIndex] == -1) // Uniform value for invalid row
			{
				if (rgRowStatus != NULL)
					rgRowStatus[l] = DBROWSTATUS_E_INVALID;

				bErrors |= true;
				continue;
			}

			// Fetch the row, we now that it is a valid row after validation.
			DBCOUNTITEM ulRowsObtained = 0;
			DBROWCOUNT lRow = m_rgBookmarks[lBookmarkIndex] - 1;
//			if (((long)*rgpBookmarks[l]) != 0)
//				lRow = ((long)*rgpBookmarks[l]) - 1;

			// Attempt to create the row
			if (CreateRow(lRow, ulRowsObtained, &rghRows[l]) != S_OK)
			{
				bErrors |= true;
			}
			else
			{
				if (rgRowStatus != NULL)
					rgRowStatus[l] = DBROWSTATUS_S_OK;

				bSuccess |= true;
			}
		}

		__if_exists(T::Fire_OnRowsetChange)
		{
			CAtlArray<HROW> rgActivated;
			for (size_t ulActivated = 0; ulActivated < cRows; ulActivated++)
			{
				// This is a bit of an assumption that all newly activated
				// rows would have the ref count as 1.  Another way to solve this
				// problem would be to modify the signature of CreateRow to take
				// a CAtlArray<HROW> as a parameter and store the activated rows.
				RowClass* pActiveRow;
				bool bFound = m_rgRowHandles.Lookup(rghRows[ulActivated], pActiveRow);
				if (bFound && pActiveRow != NULL && pActiveRow->m_dwRef == 1)
				{
					_ATLTRY
					{
						rgActivated.Add(rghRows[ulActivated]);
					}
					_ATLCATCH( e )
					{
						_ATLDELETEEXCEPTION( e );
						return E_OUTOFMEMORY;
					}
				}
			}
			if (rgActivated.GetCount() > 0)
			{
				pT->Fire_OnRowChange(pT, (DBCOUNTITEM)rgActivated.GetCount(), rgActivated.GetData(),
					DBREASON_ROW_ACTIVATE, DBEVENTPHASE_DIDEVENT, FALSE);
			}
		}

		if (bErrors)
			return (bSuccess != false) ? DB_S_ERRORSOCCURRED : DB_E_ERRORSOCCURRED;
		else
			return hr;
	}

	STDMETHOD (Hash)(
		_In_ HCHAPTER /*hReserved*/,
		_In_ DBBKMARK cBookmarks,
		_In_count_(cBookmarks) const DBBKMARK rgcbBookmarks[],
		_In_count_(cBookmarks) const BYTE* rgpBookmarks[],
		_Out_cap_(cBookmarks) DBHASHVALUE rgHashedValues[],
		_Out_opt_cap_(cBookmarks) DBROWSTATUS rgBookmarkStatus[])
	{
		ATLTRACE(atlTraceDBProvider, 2, _T("IRowsetLocateImpl::Hash\n"));

		bool bSuccess = false;
		bool bErrors = false;

		__if_exists(T::Fire_OnRowChange)
		{
			T* pT = (T*)this;
			// Check to see if someone is in an event handler.  If we do, then
			// we should return DB_E_NOTREENTRANT.
			if (!pT->IncrementMutex())
				return DB_E_NOTREENTRANT;
			else
				pT->DecrementMutex();
		}

		HRESULT hr = E_FAIL;
		// validate parameters
		if (cBookmarks != 0 && (rgcbBookmarks == NULL || rgpBookmarks == NULL ||
			rgHashedValues == NULL))
			return E_INVALIDARG;

		// hash values
		for (size_t i=0; i<cBookmarks; i++)
		{
			// Check the bookmarks
			const BYTE* pBookmark = rgpBookmarks[i];
			hr = ValidateBookmark(rgcbBookmarks[i], pBookmark);
			if (FAILED(hr) ||
				(*pBookmark == DBBMK_LAST && rgcbBookmarks[i] == 1) ||
				(*pBookmark == DBBMK_FIRST && rgcbBookmarks[i] == 1))
			{
				if (rgBookmarkStatus != NULL)
					rgBookmarkStatus[i] = DBROWSTATUS_E_INVALID;
				bErrors |= true;
				continue;
			}

			rgHashedValues[i] = (DBHASHVALUE)(*(rgpBookmarks[i]));

			if (rgBookmarkStatus != NULL)
				rgBookmarkStatus[i] = DBROWSTATUS_S_OK;
			bSuccess |= true;

		}

		if (bErrors)
			return (bSuccess != false) ? DB_S_ERRORSOCCURRED : DB_E_ERRORSOCCURRED;
		else
			return S_OK;
	}

	// Data members
	CAtlArray<DBROWCOUNT> m_rgBookmarks;

	// Implementation
	protected:
	HRESULT ValidateBookmark(
		_In_ DBBKMARK cbBookmark,
		_In_ const BYTE* pBookmark)
	{
		T* pT = (T*)this;
		if (cbBookmark == 0 || pBookmark == NULL)
			return E_INVALIDARG;

		// All of our bookmarks are DBBKMARKs, if they are anything other than
		// sizeof(DBBKMARK) then we have an invalid bookmark
		if ((cbBookmark != sizeof(DBBKMARK)) && (cbBookmark != 1))
		{
			ATLTRACE(atlTraceDBProvider, 2, _T("Bookmarks are invalid length, should be DBBKMARKs"));
			return DB_E_BADBOOKMARK;
		}

		// If our bookmark is a special (i.e. cbBookmark == 1), then it should
		// be one of the accepted values.
		if ((cbBookmark == 1) && (*pBookmark != DBBMK_FIRST && *pBookmark != DBBMK_LAST))
		{
			ATLTRACE(atlTraceDBProvider, 2, _T("Bookmark is invalid"));
			return DB_E_BADBOOKMARK;
		}

		// If the contents of our bookmarks are less than 0 or greater than
		// rowcount, then they are invalid
		DBCOUNTITEM nRows = (ULONG_PTR)pT->m_rgBookmarks.GetCount();
		DBROWOFFSET lBookmarkIndex = (DBROWOFFSET)(*pBookmark);
		if (lBookmarkIndex <= -1 || lBookmarkIndex > (DBROWOFFSET)nRows )
		{
			ATLTRACE(atlTraceDBProvider, 2, _T("IRowsetLocateImpl::Bookmark has invalid range"));
			return DB_E_BADBOOKMARK;
		}

		return S_OK;
	}
};

///////////////////////////////////////////////////////////////////////////
// IRowsetIdentityImpl
template <class T, class RowClass = CSimpleRow>
class ATL_NO_VTABLE IRowsetIdentityImpl :
	public IRowsetIdentity
{
public:
	STDMETHOD(IsSameRow)(
		_In_ HROW hThisRow,
		_In_ HROW hThatRow)
	{
		ATLTRACE(atlTraceDBProvider, 2, _T("IRowsetIdentityImpl::IsSameRow\n"));
		T* pT = (T*)this;

		// Validate row handles
		RowClass* pRow1;
		if( ! pT->m_rgRowHandles.Lookup((RowClass::KeyType)hThisRow, pRow1) )
			return DB_E_BADROWHANDLE;

		RowClass* pRow2;
		if( ! pT->m_rgRowHandles.Lookup((RowClass::KeyType)hThatRow, pRow2) )
			return DB_E_BADROWHANDLE;

		if (pRow1->m_status == DBPENDINGSTATUS_DELETED ||
			pRow2->m_status == DBPENDINGSTATUS_DELETED)
			return DB_E_DELETEDROW;

		HRESULT hr = pRow1->Compare(pRow2);
__if_not_exists(T::InsertRow)
{
		return hr;
}

__if_exists(T::InsertRow)
{
		if (hr != S_OK)
			return hr;

		// Add one more test for providers who support IRowsetChange or Update.
		// It is possible for a series of inserts & deletes to occur to make
		// CSimpleRow appear as if it were equivalent (when it is not).  To
		// fix this, we've added an m_iOriginalRowset variable that never gets
		// changed.
		return (pRow1->m_iOriginalRowset == pRow2->m_iOriginalRowset) ? S_OK : S_FALSE;
}
	};
};

template <class T>
class ATL_NO_VTABLE IInternalConnectionImpl :
	public IInternalConnection
{
public:
	STDMETHOD(AddConnection)()
	{
		T* pT = (T*)this;
		T::_ThreadModel::Increment(&pT->m_cSessionsOpen);
		return S_OK;
	}
	STDMETHOD(ReleaseConnection)()
	{
		T* pT = (T*)this;
		T::_ThreadModel::Decrement(&pT->m_cSessionsOpen);
		return S_OK;
	}
};

template <class T>
class ATL_NO_VTABLE IInternalCommandConnectionImpl :
	public IInternalConnection
{
public:
	STDMETHOD(AddConnection)()
	{
		T* pT = (T*)this;
		T::_ThreadModel::Increment(&pT->m_cRowsetsOpen);
		return S_OK;
	}
	STDMETHOD(ReleaseConnection)()
	{
		T* pT = (T*)this;
		T::_ThreadModel::Decrement(&pT->m_cRowsetsOpen);
		return S_OK;
	}
};

template <class T>
class ATL_NO_VTABLE IObjectWithSiteSessionImpl :
	public IObjectWithSiteImpl< T >
{
public:

	virtual ~IObjectWithSiteSessionImpl()
	{
		CComPtr<IInternalConnection> pConn;
		if (m_spUnkSite != NULL)
		{
			if (SUCCEEDED(m_spUnkSite->QueryInterface(__uuidof(IInternalConnection), (void**)&pConn)))
				pConn->ReleaseConnection();
		}
	}
	STDMETHOD(SetSite)(_Inout_opt_ IUnknown* pCreator)
	{
		HRESULT hr = S_OK;
		T* pT = (T*)this;
		pT->Lock();
		m_spUnkSite = pCreator;
		pT->Unlock();
		CComPtr<IInternalConnection> pConn;
		if (pCreator != NULL)
		{
			hr = pCreator->QueryInterface(__uuidof(IInternalConnection), (void**)&pConn);
			if (SUCCEEDED(hr))
				hr = pConn->AddConnection();
		}
		return hr;
	}

	LONG m_cSessionsOpen;
};

template <class T>
class ATL_NO_VTABLE IRowsetCreatorImpl :
	public IObjectWithSiteImpl< T >
{
public:

	virtual ~IRowsetCreatorImpl()
	{
		CComPtr<IInternalConnection> pConn;
		if (m_spUnkSite != NULL)
		{
			if (SUCCEEDED(m_spUnkSite->QueryInterface(__uuidof(IInternalConnection), (void**)&pConn)))
				pConn->ReleaseConnection();
		}
	}

	STDMETHOD(SetSite)(_Inout_opt_ IUnknown* pCreator)
	{
		T* pT = (T*)this;
		HRESULT hr = S_OK;
		pT->Lock();
		m_spUnkSite = pCreator;
		pT->Unlock();
		CComVariant varPropScroll, varPropFetch, varPropRemove, varPropUpdate;
		HRESULT hrProps = pT->GetPropValue(&DBPROPSET_ROWSET, DBPROP_CANSCROLLBACKWARDS, &varPropScroll);
		if (SUCCEEDED(hrProps))
			pT->m_bCanScrollBack = (varPropScroll.boolVal != ATL_VARIANT_FALSE);
		hrProps = pT->GetPropValue(&DBPROPSET_ROWSET, DBPROP_CANFETCHBACKWARDS, &varPropFetch);
		if (SUCCEEDED(hrProps))
			pT->m_bCanFetchBack = (varPropFetch.boolVal != ATL_VARIANT_FALSE);
		hrProps = pT->GetPropValue(&DBPROPSET_ROWSET, DBPROP_REMOVEDELETED, &varPropRemove);
		if (SUCCEEDED(hrProps))
			pT->m_bRemoveDeleted = (varPropRemove.boolVal != ATL_VARIANT_FALSE);
		hrProps = pT->GetPropValue(&DBPROPSET_ROWSET, DBPROP_IRowsetUpdate, &varPropUpdate);
		if (SUCCEEDED(hrProps))
			pT->m_bIRowsetUpdate = (varPropUpdate.boolVal != ATL_VARIANT_FALSE);
		CComPtr<IInternalConnection> pConn;
		if (pCreator != NULL)
		{
			if (SUCCEEDED(pCreator->QueryInterface(__uuidof(IInternalConnection), (void**)&pConn)))
				hr = pConn->AddConnection();
		}
		return hr;
	}

	LONG m_cRowsetsOpen;
};

// IRowsetInfoImpl
template <class T, class PropClass = T>
class ATL_NO_VTABLE IRowsetInfoImpl :
	public IRowsetInfo,
	public CUtlProps<PropClass>
{
public:
	static UPROPSET* _GetPropSet(
		_Out_opt_ ULONG* pNumPropSets,
		_Out_ ULONG* pcElemPerSupported,
		_Inout_opt_ UPROPSET* pSet = NULL,
		_Out_opt_ GUID* pguidSet = NULL)
	{
		//protects from recurrence call this method (compiler warning C4717)
		ATLASSERT(&IRowsetInfoImpl<T>::_GetPropSet != &PropClass::_GetPropSet);

		if (&IRowsetInfoImpl<T>::_GetPropSet != &PropClass::_GetPropSet)
		{
			return PropClass::_GetPropSet(pNumPropSets, pcElemPerSupported, pSet, pguidSet);
		}
		return NULL;
	}
	STDMETHOD(GetProperties)(
		_In_ const ULONG cPropertyIDSets,
		_In_count_(cPropertyIDSets) const DBPROPIDSET rgPropertyIDSets[],
		_Out_ ULONG *pcPropertySets,
		_Out_ _Deref_post_opt_cap_(*pcPropertySets) DBPROPSET **prgPropertySets)
	{
		ATLTRACE(atlTraceDBProvider, 2, _T("IRowsetInfoImpl::GetProperties\n"));

		// IRowsetInfo can't return PROPERTIESINERROR.  Therefore, disable
		// checking for it.  Instead, treat it as any normal property set.
		m_dwFlags |= ~ARGCHK_PROPERTIESINERROR;
		HRESULT hr = GetPropertiesArgChk(cPropertyIDSets, rgPropertyIDSets,
			pcPropertySets, prgPropertySets);
		if(SUCCEEDED(hr))
		{
			// Scan property sets to allow user defined properies
			ULONG ulPropSets = 0;
			ULONG ulPropElems = 0;
			ULONG ulPropInits = 0;
			UPROPSET* pSetA = NULL;
			UPROPSET* pSetTemp = NULL;
			ULONG l=0;
			ULONG cSets = (ULONG)(ULONG_PTR)T::_GetPropSet(NULL, &ulPropElems);

			CTempBuffer<UPROPSET> tmpBuffer;
			pSetA = tmpBuffer.Allocate(cSets);
			if (pSetA == NULL)
				return E_OUTOFMEMORY;  // We shouldn't get this but...
			pSetTemp = T::_GetPropSet(&ulPropSets, &ulPropElems, pSetA);

			typedef const GUID* PCGUID;

			for(l=0; l<cSets; l++)
			{
				if (pSetTemp[l].bIsChained != true)
					ulPropInits++;
			}

			CTempBuffer<PCGUID> tmpBuffer2;
			PCGUID* ppGuid = tmpBuffer2.Allocate(ulPropInits);
			if (ppGuid == NULL)
				return E_OUTOFMEMORY;
			ulPropInits = 0;
			for (l=0; l<cSets; l++)
			{
				if (pSetTemp[l].bIsChained != true)
					ppGuid[ulPropInits++] = pSetTemp[l].pPropSet;
			}

			return CUtlProps<PropClass>::GetProperties(cPropertyIDSets,
					rgPropertyIDSets, pcPropertySets, prgPropertySets,
					ulPropInits, ppGuid);
		}
		else
			return hr;
	}

	OUT_OF_LINE ATLCOLUMNINFO* InternalGetColumnInfo(_Out_ DBORDINAL* pcCols)
	{
		return T::GetColumnInfo((T*)this, pcCols);
	}
ATLPREFAST_SUPPRESS(6387)
	STDMETHOD(GetReferencedRowset)(
		_In_ DBORDINAL iOrdinal,
		_In_ REFIID riid,
		_Deref_out_ IUnknown **ppReferencedRowset)
	{
		ATLTRACE(atlTraceDBProvider, 2, _T("IRowsetInfoImpl::GetReferencedRowset\n"));
		DBORDINAL cCols=0;

		// Check Arguments
		if( ppReferencedRowset == NULL )
		{
			ATLTRACE(atlTraceDBProvider, 0, _T("IRowsetInfoImpl::GetReferencedRowset : Error NULL IUnk output Param\n"));
			return E_INVALIDARG;
		}
		*ppReferencedRowset = NULL;

		// Check to see if column in question is a bookmark
		ATLCOLUMNINFO* pColInfo = InternalGetColumnInfo(&cCols);
		DBORDINAL iColInfo;
		for (iColInfo = 0;
			 iColInfo < cCols && iOrdinal != pColInfo[iColInfo].iOrdinal;
			 iColInfo++);
		if (iColInfo == cCols)
			return DB_E_BADORDINAL;
		ATLCOLUMNINFO* pColCur = &(pColInfo[iColInfo]);

		if ((pColCur->dwFlags & DBCOLUMNFLAGS_ISBOOKMARK) == 0)
			return DB_E_NOTAREFERENCECOLUMN;

		// Query for requested interface
		return QueryInterface(riid, (void**)ppReferencedRowset);
	}
ATLPREFAST_UNSUPPRESS()
	
	STDMETHOD(GetSpecification)(
		_In_ REFIID riid,
		_Deref_out_ IUnknown **ppSpecification)
	{
		ATLTRACE(atlTraceDBProvider, 2, _T("IRowsetInfoImpl::GetSpecification\n"));

		if (ppSpecification == NULL)
			return E_INVALIDARG;
		T* pT = (T*) this;
		T::ObjectLock cab(pT);
		ATLASSERT(pT->m_spUnkSite != NULL);
		return pT->m_spUnkSite->QueryInterface(riid, (void**)ppSpecification);
	}
};

	
/*
template <class Storage, class ContainedArray = CAtlArray<Storage> >
class CUpdateArray :
	public ContainedArray
{
public:

	void RemoveAll()
	{
		ContainedArray::RemoveAll();
		m_rgRowLink.RemoveAll();
	}

	BOOL Add(Storage& rStorage)
	{
		if (ContainedArray::Add(rStorage))
		{
			if (!m_rgRowLink.Add(GetCount() - 1))
			{
				RemoveAt(GetCount() - 1);
				return FALSE;
			}
			return TRUE;
		}
		return FALSE;
	}

	BOOL RemoveAt(int nIndex)
	{
		if (ContainedArray::RemoveAt(m_rgRowLink[nIndex]))
		{
			// Decrement any links following the current row
			for (long l=nIndex+1; l<m_rgRowLink.GetCount(); l++)
			{
				long* pElem = &(m_rgRowLink.m_aT[l]);
				ATLASSERT(pElem != NULL);
				(*pElem)--;
			}
			return m_rgRowLink.RemoveAt(nIndex);
		}
		return FALSE;
	}

	ContainedArray::_ArrayElementType& operator[] (int nIndex)
	{
		ATLASSERT(nIndex >= 0 && nIndex < GetCount());
		return ContainedArray::operator[](m_rgRowLink[nIndex]);
	}

	const ContainedArray::_ArrayElementType& operator[] (int nIndex) const
	{
		ATLASSERT(nIndex >= 0 && nIndex < GetCount());
		return ContainedArray::operator[](m_rgRowLink[nIndex]);
	}

	CSimpleValArray<long> m_rgRowLink;
};
*/

class CComSharedMutex
{
public:
	CComSharedMutex()
	{
		m_lInterlockedVariable = -1;
	};

	inline bool IncrementMutex()
	{
		long lAvailable = ::InterlockedIncrement(&m_lInterlockedVariable);
		if (lAvailable > 0)
		{
			// Mutex is held, decrement and return false
			DecrementMutex();
			return false;
		}
		else
			return true;
	};
	inline void DecrementMutex()
	{
		::InterlockedDecrement(&m_lInterlockedVariable);
	};

	long m_lInterlockedVariable;
};


template <class T, class ReentrantEventSync = CComSharedMutex>
class IRowsetNotifyCP :
	public IConnectionPointImpl<T, &__uuidof(IRowsetNotify), CComDynamicUnkArray>,
	public ReentrantEventSync
{
public:
	HRESULT Fire_OnFieldChange(
		_Inout_ IRowset* pRowset,
		_In_ HROW hRow,
		_In_ DBORDINAL cColumns,
		_In_count_(cColumns) DBORDINAL* rgColumns,
		_In_ DBREASON eReason,
		_In_ DBEVENTPHASE ePhase,
		_In_ BOOL fCantDeny)
	{
		ATLTRACE(atlTraceDBProvider, 2, _T("IRowsetNotifyCP::Fire_OnFieldChange\n"));

		IncrementMutex();	// Lock the event handler so other's can't call methods
		HRESULT ret = S_OK;
		T* pT = static_cast<T*>(this);
		int nConnectionIndex;
		int nConnections = m_vec.GetSize();

		for (nConnectionIndex = 0; nConnectionIndex < nConnections; nConnectionIndex++)
		{
			pT->Lock();
			CComPtr<IUnknown> sp = m_vec.GetAt(nConnectionIndex);
			pT->Unlock();
			IRowsetNotify* pIRowsetNotify = reinterpret_cast<IRowsetNotify*>(sp.p);
			if (pIRowsetNotify != NULL)
				ret = pIRowsetNotify->OnFieldChange(pRowset, hRow, cColumns,
					rgColumns, eReason, ePhase, fCantDeny);
			switch(ePhase)
			{
			case DBEVENTPHASE_OKTODO:
				if (ret == S_FALSE  && fCantDeny == FALSE)
				{
					// if we get an S_FALSE back, a consumer has vetoed the
					// request.  In this case, we should send a FAILEDTODO
					// to ONLY those consumers already notified.
					for (int nFailedIndex = 0; nFailedIndex <= nConnectionIndex; nFailedIndex++)
					{
						pT->Lock();
						CComPtr<IUnknown> spFailed = m_vec.GetAt(nFailedIndex);
						pT->Unlock();
						IRowsetNotify* pIFailedNotify = reinterpret_cast<IRowsetNotify*>(spFailed.p);
						if (pIFailedNotify != NULL)
							pIFailedNotify->OnFieldChange(pRowset, hRow, cColumns, rgColumns,
								eReason, DBEVENTPHASE_FAILEDTODO, FALSE);
					}
					// Terminate the loop as no further consumers should be
					// notified.
					DecrementMutex();
					return ret;
				}
				else
				{
					if (ret != S_OK)
						ret = S_OK;
				}
				break;
			case DBEVENTPHASE_ABOUTTODO:
			case DBEVENTPHASE_SYNCHAFTER:
				if (ret == S_FALSE && fCantDeny == FALSE)
				{
					Fire_OnFieldChange(pRowset, hRow, cColumns, rgColumns,
						eReason, DBEVENTPHASE_FAILEDTODO, FALSE);
					DecrementMutex();
					return ret;
				}
				else
				{
					if (ret != S_OK)
						ret = S_OK;
				}
				break;
			case DBEVENTPHASE_FAILEDTODO:
			case DBEVENTPHASE_DIDEVENT:
				break; // Nothing todo
			default:
				ATLTRACE(atlTraceDBProvider, 0, _T("IRowsetNotifyCP::Fire_OnFieldChange: Unknown Phase requested\n"));
				ATLASSERT(FALSE);
				DecrementMutex();
				return E_FAIL;
			};
		}
		DecrementMutex();
		if( ret != S_OK && ret != S_FALSE )
			ret = S_OK;
		return ret;

	}
	HRESULT Fire_OnRowChange(
		_Inout_ IRowset* pRowset,
		_In_ DBCOUNTITEM cRows,
		_In_count_(cRows) const HROW rghRows[],
		_In_ DBREASON eReason,
		_In_ DBEVENTPHASE ePhase,
		_In_ BOOL fCantDeny)
	{
		ATLTRACE(atlTraceDBProvider, 2, _T("IRowsetNotifyCP::Fire_OnRowChange\n"));
		IncrementMutex();  // Lock the handler so other's can't call methods
		HRESULT ret = S_OK;
		T* pT = static_cast<T*>(this);
		int nConnectionIndex;
		int nConnections = m_vec.GetSize();

		for (nConnectionIndex = 0; nConnectionIndex < nConnections; nConnectionIndex++)
		{
			pT->Lock();
			CComPtr<IUnknown> sp = m_vec.GetAt(nConnectionIndex);
			pT->Unlock();
			IRowsetNotify* pIRowsetNotify = reinterpret_cast<IRowsetNotify*>(sp.p);
			if (pIRowsetNotify != NULL)
			{
				ret = pIRowsetNotify->OnRowChange(pRowset, cRows, rghRows, eReason, ePhase, fCantDeny);
			}
			switch(ePhase)
			{
			case DBEVENTPHASE_OKTODO:
				if (ret == S_FALSE && fCantDeny == FALSE)
				{
					// if we get an S_FALSE back, a consumer has vetoed the
					// request.  In this case, we should send a FAILEDTODO
					// to ONLY those consumers already notified.
					for (int nFailedIndex = 0; nFailedIndex <= nConnectionIndex; nFailedIndex++)
					{
						pT->Lock();
						CComPtr<IUnknown> spFailed = m_vec.GetAt(nFailedIndex);
						pT->Unlock();
						IRowsetNotify* pIFailedNotify = reinterpret_cast<IRowsetNotify*>(spFailed.p);
						if (pIFailedNotify != NULL)
							pIFailedNotify->OnRowChange(pRowset, cRows, rghRows, eReason,
								DBEVENTPHASE_FAILEDTODO, FALSE);
					}
					// Terminate the loop as no further consumers should be
					// notified.
					DecrementMutex();
					return ret;
				}
				break;
			case DBEVENTPHASE_SYNCHAFTER:
			case DBEVENTPHASE_ABOUTTODO:
				if (ret	== S_FALSE && fCantDeny == FALSE)
				{
					Fire_OnRowChange(pRowset, cRows, rghRows, eReason,
						DBEVENTPHASE_FAILEDTODO, FALSE);
					DecrementMutex();
					return ret;
				}
				break;
			case DBEVENTPHASE_FAILEDTODO:
			case DBEVENTPHASE_DIDEVENT:
				break; // Nothing todo
			default:
				ATLTRACE(atlTraceDBProvider, 0, _T("IRowsetNotifyCP::Fire_OnRowChange: Unknown Phase requested\n"));
				ATLASSERT(FALSE);
				DecrementMutex();
				return E_FAIL;
			};
		}
		DecrementMutex();
		if( ret != S_OK && ret != S_FALSE )
			ret = S_OK;
		return ret;

	}
	HRESULT Fire_OnRowsetChange(
		_Inout_ IRowset* pRowset,
		_In_ DBREASON eReason,
		_In_ DBEVENTPHASE ePhase,
		_In_ BOOL fCantDeny)
	{
		ATLTRACE(atlTraceDBProvider, 2, _T("IRowsetNotifyCP::Fire_OnRowsetChange\n"));
		IncrementMutex(); // Lock the handler so others can't call methods
		HRESULT ret = S_OK;
		T* pT = static_cast<T*>(this);
		int nConnectionIndex;
		int nConnections = m_vec.GetSize();

		for (nConnectionIndex = 0; nConnectionIndex < nConnections; nConnectionIndex++)
		{
			pT->Lock();
			CComPtr<IUnknown> sp = m_vec.GetAt(nConnectionIndex);
			pT->Unlock();
			IRowsetNotify* pIRowsetNotify = reinterpret_cast<IRowsetNotify*>(sp.p);
			if (pIRowsetNotify != NULL)
				ret = pIRowsetNotify->OnRowsetChange(pRowset, eReason, ePhase, fCantDeny);
			switch(ePhase)
			{
			case DBEVENTPHASE_OKTODO:
				if (ret == S_FALSE && fCantDeny == FALSE)
				{
					// if we get an S_FALSE back, a consumer has vetoed the
					// request.  In this case, we should send a FAILEDTODO
					// to ONLY those consumers already notified.
					for (int nFailedIndex = 0; nFailedIndex <= nConnectionIndex; nFailedIndex++)
					{
						pT->Lock();
						CComPtr<IUnknown> spFailed = m_vec.GetAt(nFailedIndex);
						pT->Unlock();
						IRowsetNotify* pIFailedNotify = reinterpret_cast<IRowsetNotify*>(spFailed.p);
						if (pIFailedNotify != NULL)
							pIFailedNotify->OnRowsetChange(pRowset, eReason,
								DBEVENTPHASE_FAILEDTODO, FALSE);
					}
					// Terminate the loop as no further consumers should be
					// notified.
					DecrementMutex();
					return ret;
				}
				break;
			case DBEVENTPHASE_ABOUTTODO:
			case DBEVENTPHASE_SYNCHAFTER:
				if (ret == S_FALSE && fCantDeny == FALSE)
				{
					Fire_OnRowsetChange(pRowset, eReason, DBEVENTPHASE_FAILEDTODO,
						FALSE);
					DecrementMutex();
					return ret;
				}
				break;
			case DBEVENTPHASE_FAILEDTODO:
			case DBEVENTPHASE_DIDEVENT:
				break; // Nothing todo
			default:
				ATLTRACE(atlTraceDBProvider, 0, _T("IRowsetNotifyCP::Fire_OnRowChange: Unknown Phase requested\n"));
				ATLASSERT(FALSE);
				DecrementMutex();
				return E_FAIL;
			};
		}
		DecrementMutex();
		if( ret != S_OK && ret != S_FALSE )
			ret = S_OK;
		return ret;

	}
};


template <class T, class Storage,
		  class ArrayType = CAtlArray<Storage>,
		  class RowsetInterface = IRowsetImpl < T, IRowset >,
		  class RowClass = CSimpleRow >
class CRowsetBaseImpl :
	public IAccessorImpl<T>,
	public IRowsetIdentityImpl<T, RowClass>,
	public IRowsetCreatorImpl<T>,
	public IColumnsInfoImpl<T>,
	public IConvertTypeImpl<T>,
	public RowsetInterface
{
public:
	HRESULT NameFromDBID(
		_In_ DBID* pDBID,
		_Inout_ CComBSTR& bstr,
		_In_ bool bIndex)
	{

		if (pDBID->uName.pwszName != NULL)
		{
			ATLTRY( bstr = pDBID->uName.pwszName );
			if (!bstr)
				return E_OUTOFMEMORY;
			return S_OK;
		}

		return (bIndex) ? DB_E_NOINDEX : DB_E_NOTABLE;
	}

	HRESULT GetCommandFromID(
		_In_opt_ DBID* pTableID,
		_In_opt_ DBID* pIndexID)
	{
		if (pTableID == NULL && pIndexID == NULL)
			return E_INVALIDARG;

		if (pTableID != NULL && pTableID->eKind == DBKIND_NAME)
		{
			HRESULT hr = NameFromDBID(pTableID, m_strCommandText, true);
			if (FAILED(hr))
				return hr;
			if (pIndexID != NULL)
			{
				if (pIndexID->eKind == DBKIND_NAME)
				{
					hr = NameFromDBID(pIndexID, m_strIndexText, false);
					if (FAILED(hr))
					{
						m_strCommandText.Empty();
						return hr;
					}
				}
				else
				{
					m_strCommandText.Empty();
					return DB_E_NOINDEX;
				}
			}
			return S_OK;
		}
		if (pIndexID != NULL && pIndexID->eKind == DBKIND_NAME)
			return NameFromDBID(pIndexID, m_strIndexText, false);

		return S_OK;
	}

	HRESULT ValidateCommandID(
		_In_opt_ DBID* pTableID,
		_In_opt_ DBID* pIndexID)
	{
		HRESULT hr = S_OK;

		if (pTableID != NULL)
		{
			hr = CUtlProps<T>::IsValidDBID(pTableID);

			if (hr != S_OK)
				return hr;

			// Check for a NULL TABLE ID (where its a valid pointer but NULL)
			if ((pTableID->eKind == DBKIND_GUID_NAME ||
				pTableID->eKind == DBKIND_NAME ||
				pTableID->eKind == DBKIND_PGUID_NAME)
				&& pTableID->uName.pwszName == NULL)
				return DB_E_NOTABLE;
		}

		if (pIndexID != NULL)
			hr = CUtlProps<T>::IsValidDBID(pIndexID);

		return hr;
	}

	HRESULT SetCommandText(
		_In_opt_ DBID* pTableID,
		_In_opt_ DBID* pIndexID)
	{
		T* pT = (T*)this;
		HRESULT hr = pT->ValidateCommandID(pTableID, pIndexID);
		if (FAILED(hr))
			return hr;
		hr = pT->GetCommandFromID(pTableID, pIndexID);
		return hr;
	}

	_Ret_count_x_(*pcCols) static ATLCOLUMNINFO* GetColumnInfo(
		_In_opt_ _Pre_opt_bytecount_x_(sizeof(T)) T* pv,
		_Out_ DBORDINAL* pcCols)
	{
		return Storage::GetColumnInfo(pv,pcCols);
	}

	CComBSTR m_strCommandText;
	CComBSTR m_strIndexText;
	ArrayType m_rgRowData;
};


template <class T, class Storage, class CreatorClass,
		  class ArrayType = CAtlArray<Storage>,
  		  class RowClass = CSimpleRow,
		  class RowsetInterface = IRowsetImpl < T, IRowset > >
class CRowsetImpl :
	public CComObjectRootEx<typename CreatorClass::_ThreadModel>,
	public CRowsetBaseImpl<T, Storage, ArrayType, RowsetInterface, RowClass>,
	public IRowsetInfoImpl<T, typename CreatorClass::_PropClass>
{
public:
	typedef CRowsetImpl< T, Storage, CreatorClass, ArrayType, RowClass, RowsetInterface> _RowsetBaseClass;
	typedef ArrayType _RowsetArrayType;
	typedef Storage _StorageClass;
	typedef CreatorClass _RowsetCreatorClass;

BEGIN_COM_MAP(CRowsetImpl)
	COM_INTERFACE_ENTRY(IRowsetInfo)
	COM_INTERFACE_ENTRY(IAccessor)
	COM_INTERFACE_ENTRY(IObjectWithSite)
	COM_INTERFACE_ENTRY(IColumnsInfo)
	COM_INTERFACE_ENTRY(IConvertType)
	COM_INTERFACE_ENTRY(IRowsetIdentity)
	COM_INTERFACE_ENTRY(IRowset)
END_COM_MAP()

	HRESULT FinalConstruct()
	{
		HRESULT hr = IAccessorImpl<T>::FinalConstruct();
		if (FAILED(hr))
			return hr;
		return CConvertHelper::FinalConstruct();
	}

	void FinalRelease()
	{
		m_rgRowData.RemoveAll();
		IAccessorImpl<T>::FinalRelease();
		__if_exists(T::Fire_OnRowsetChange)
		{
			T* pT = (T*)this;
			pT->Fire_OnRowsetChange(pT, DBREASON_ROWSET_RELEASE, DBEVENTPHASE_DIDEVENT, TRUE);
		}
	}
};


template <class T, class Storage, class CreatorClass,
		  class ArrayType = CAtlArray<Storage>,
  		  class RowClass = CSimpleRow,
		  class RowsetInterface = IRowsetImpl < T, IRowset > >
class CSchemaRowsetImpl :
	public CComObjectRootEx<typename CreatorClass::_ThreadModel>,
	public CRowsetBaseImpl<T, Storage, ArrayType, RowsetInterface, RowClass>,
	public IRowsetInfoImpl<T>
{
public:
	typedef CSchemaRowsetImpl< T, Storage, CreatorClass, ArrayType, RowClass, RowsetInterface> _RowsetBaseClass;
	typedef ArrayType _RowsetArrayType;
	typedef Storage _StorageClass;
	typedef CreatorClass _RowsetCreatorClass;

BEGIN_COM_MAP(CSchemaRowsetImpl)
	COM_INTERFACE_ENTRY(IRowsetInfo)
	COM_INTERFACE_ENTRY(IAccessor)
	COM_INTERFACE_ENTRY(IObjectWithSite)
	COM_INTERFACE_ENTRY(IColumnsInfo)
	COM_INTERFACE_ENTRY(IConvertType)
	COM_INTERFACE_ENTRY(IRowsetIdentity)
	COM_INTERFACE_ENTRY(IRowset)
END_COM_MAP()

	HRESULT FinalConstruct()
	{
		HRESULT hr = IAccessorImpl<T>::FinalConstruct();
		if (FAILED(hr))
			return hr;
		return CConvertHelper::FinalConstruct();
	}

	void FinalRelease()
	{
		m_rgRowData.RemoveAll();
		__if_exists(T::Fire_OnRowsetChange)
		{
			T* pT = (T*)this;
			pT->Fire_OnRowsetChange(pT, DBREASON_ROWSET_RELEASE, DBEVENTPHASE_DIDEVENT, TRUE);
		}
	}
};


template <const GUID* pguidProvider>
class CErrorReporterHelper
{
public:

	HRESULT PostError(
		_In_ HRESULT hrErr,
		_In_ IID* piid)
	{
		HRESULT	hr = S_OK;
		if (piid == NULL)
			return E_INVALIDARG;

		CComPtr<ICreateErrorInfo>	spCrtErrInfo;
		CComPtr<IErrorInfo>			spIErrorInfo;
		CComPtr<IErrorRecords>		spIErrorRecords;

		hr = CreateErrorInfo(&spCrtErrInfo);
		if (SUCCEEDED(hr))
		{
			ERRORINFO		errorinfo;
			memset(&errorinfo, 0, sizeof(ERRORINFO));
			errorinfo.clsid		= *pguidProvider;
			errorinfo.dispid	= NULL;
			errorinfo.dwMinor	= 0;
			errorinfo.hrError	= hrErr;
			errorinfo.iid		= *piid;

			spCrtErrInfo->SetGUID(errorinfo.iid);
			spCrtErrInfo->SetSource(L"Provider PROGID");
			spCrtErrInfo->SetDescription(L"Error Description");
			spCrtErrInfo->SetHelpFile(L"provider.hlp");
			spCrtErrInfo->SetHelpContext(1);

			//Obtain the error object or create a new one if none exists
			if ( FAILED(GetErrorInfo(0, &spIErrorInfo)) || ( spIErrorInfo == NULL ) )
			{
				hr = spIErrorInfo.CoCreateInstance(CLSID_EXTENDEDERRORINFO);
				if( FAILED(hr))
					return hr;
			}

			// Obtain the IErrorRecord Interface
			hr = spIErrorInfo->QueryInterface(&spIErrorRecords);
			if( SUCCEEDED(hr))
			{
				hr = spIErrorRecords->AddErrorRecord(&errorinfo, 0, NULL, spCrtErrInfo, 0);
				if( FAILED(hr))
					return hr;
			}
		}

		if( spIErrorInfo != NULL)
			SetErrorInfo(0, spIErrorInfo);

		return hr;
	}
};

struct ATLERRORINFO
{
	ERRORINFO*		  pInfo;
	DISPPARAMS		  dispparams;
	CComPtr<IUnknown> spCustError;
	DWORD			  dwLookupID;

};

template <class T, class RecordClass = ATLERRORINFO>
class IErrorRecordsImpl :
	public IErrorRecords
{
public:
	STDMETHOD(AddErrorRecord)(
		_In_ ERRORINFO *pErrorInfo,
		_In_ DWORD dwLookupID,
		_In_ DISPPARAMS *pdispparams,
		_In_ IUnknown *punkCustomError,
		_In_ DWORD)
	{
		ATLTRACE(atlTraceDBProvider, 2, _T("IErrorRecordsImpl::AddErrorRecord\n"));
		if (pErrorInfo == NULL)
			return E_INVALIDARG;
		ATLERRORINFO err;

		err.pInfo = pErrorInfo;
		err.dispparams = *pdispparams;
		err.spCustError = punkCustomError;
		err.dwLookupID = dwLookupID;

		//if (!m_rgErrors.Add(err))
		//	return E_OUTOFMEMORY;
		_ATLTRY
		{
			m_rgErrors.Add(err);
		}
		_ATLCATCH( e )
		{
			_ATLDELETEEXCEPTION( e );
			return E_OUTOFMEMORY;
		}

		return S_OK;
	}

	STDMETHOD(GetBasicErrorInfo)(
		_In_ ULONG ulRecordNum,
		_In_ ERRORINFO *pErrorInfo)
	{
		ATLTRACE(atlTraceDBProvider, 2, _T("IErrorRecordsImpl::GetBasicErrorInfo\n"));
		if (pErrorInfo == NULL)
			return E_INVALIDARG;
		if (ulRecordNum >= m_rgErrors.GetCount())
			return DB_E_BADRECORDNUM;

		*pErrorInfo = *(m_rgErrors[ulRecordNum].pInfo);
		return S_OK;
	}

	STDMETHOD(GetCustomErrorObject)(
		_In_ ULONG ulRecordNum,
		_In_ REFIID riid,
		_Deref_out_ IUnknown **ppObject)
	{
		ATLTRACE(atlTraceDBProvider, 2, _T("IErrorRecordsImpl::GetCustomErrorObject\n"));
		if (ppObject == NULL)
			return E_INVALIDARG;
		if (ulRecordNum >= m_rgErrors.GetCount())
			return DB_E_BADRECORDNUM;

		CComPtr<IUnknown> spUnkCust;
		spUnkCust = m_rgErrors[ulRecordNum].spCustError;
		return spUnkCust->QueryInterface(riid, (void**)ppObject);

	}

	STDMETHOD(GetErrorInfo)(
		_In_ ULONG ulRecordNum,
		_In_ LCID,
		_Deref_out_ IErrorInfo **ppErrorInfo)
	{
		ATLTRACE(atlTraceDBProvider, 2, _T("IErrorRecordsImpl::GetErrorInfo\n"));

		if (ppErrorInfo == NULL)
			return E_INVALIDARG;
		if (ulRecordNum >= m_rgErrors.GetCount())
			return DB_E_BADRECORDNUM;

		CComPtr<ICreateErrorInfo> spErrorInfo;

		if (FAILED(CreateErrorInfo(&spErrorInfo)))
			return E_OUTOFMEMORY;

		ERRORINFO& rInfo = *(m_rgErrors[ulRecordNum].pInfo);
		T* pT = (T*)this;
		spErrorInfo->SetDescription(pT->GetErrorDescriptionString(rInfo));
		spErrorInfo->SetGUID(pT->GetErrorGUID(rInfo));
		spErrorInfo->SetHelpContext(pT->GetErrorHelpContext(rInfo));
		spErrorInfo->SetHelpFile(pT->GetErrorHelpFile(rInfo));
		spErrorInfo->SetSource(pT->GetErrorSource(rInfo));
		return spErrorInfo->QueryInterface(__uuidof(IErrorInfo), (void**)ppErrorInfo);
	}

	STDMETHOD(GetErrorParameters)(
		_In_ ULONG ulRecordNum,
		_Out_ DISPPARAMS *pdispparams)
	{
		ATLTRACE(atlTraceDBProvider, 2, _T("IErrorRecordsImpl::GetErrorParameters\n"));
		if (pdispparams == NULL)
			return E_INVALIDARG;
		if (ulRecordNum >= m_rgErrors.GetCount())
			return DB_E_BADRECORDNUM;

		*pdispparams = m_rgErrors[ulRecordNum].dispparams;
		return S_OK;
	}

	STDMETHOD(GetRecordCount)(_Out_ ULONG *pcRecords)
	{
		ATLTRACE(atlTraceDBProvider, 2, _T("IErrorRecordsImpl::GetRecordCount\n"));
		if (pcRecords == NULL)
		{
			return E_INVALIDARG;
		}
#ifdef _WIN64
		size_t cRecords = m_rgErrors.GetCount();
		if (cRecords > ULONG_MAX)
		{
			*pcRecords = 0;
			return E_FAIL;
		}
		*pcRecords = (ULONG)cRecords;
#else
		*pcRecords = m_rgErrors.GetCount();
#endif
		return S_OK;
	}

	LPOLESTR GetErrorDescriptionString(_In_ ERRORINFO&)
	{
		return OLESTR("The Error Description String");
	}

	REFGUID GetErrorGUID(_In_ ERRORINFO&)
	{
		return GUID_NULL;
	}

	DWORD GetErrorHelpContext(_In_ ERRORINFO&)
	{
		return 0;
	}

	LPOLESTR GetErrorHelpFile(_In_ ERRORINFO&)
	{
		return OLESTR("The Error Help File");
	}

	LPOLESTR GetErrorSource(_In_ ERRORINFO&)
	{
		return OLESTR("The ErrorInfo");
	}

	CAtlArray<RecordClass> m_rgErrors;
};


class CTABLESRow
{
public:

	WCHAR m_szCatalog[129];
	WCHAR m_szSchema[129];
	WCHAR m_szTable[129];
	WCHAR m_szType[129];
	WCHAR m_szDesc[129];
	GUID  m_guid;
	ULONG m_ulPropID;
	DATE m_DateCreated;
	DATE m_DateModified;

	CTABLESRow()
	{
		Checked::wcscpy_s(m_szCatalog, _countof(m_szCatalog), L"");
		Checked::wcscpy_s(m_szSchema, _countof(m_szSchema), L"");
		Checked::wcscpy_s(m_szTable, _countof(m_szTable), L"");
		Checked::wcscpy_s(m_szType, _countof(m_szType), L"");
		Checked::wcscpy_s(m_szDesc, _countof(m_szDesc), L"");
		m_guid = GUID_NULL;
		m_ulPropID = 0;
		m_DateCreated = 0.0;
		m_DateModified = 0.0;
	}

BEGIN_PROVIDER_COLUMN_MAP(CTABLESRow)
	PROVIDER_COLUMN_ENTRY_WSTR("TABLE_CATALOG", 1, m_szCatalog)
	PROVIDER_COLUMN_ENTRY_WSTR("TABLE_SCHEMA", 2, m_szSchema)
	PROVIDER_COLUMN_ENTRY_WSTR("TABLE_NAME", 3, m_szTable)
	PROVIDER_COLUMN_ENTRY_WSTR("TABLE_TYPE", 4, m_szType)
	PROVIDER_COLUMN_ENTRY_PS("TABLE_GUID", 5, 0xFF, 0xFF, m_guid)
	PROVIDER_COLUMN_ENTRY_WSTR("DESCRIPTION", 6, m_szDesc)
	PROVIDER_COLUMN_ENTRY_PS("TABLE_PROPID", 7, 10, 0xFF, m_ulPropID)
	PROVIDER_COLUMN_ENTRY_TYPE_PS("DATE_CREATED", 8, DBTYPE_DATE, 0xFF, 0xFF, m_DateCreated)
	PROVIDER_COLUMN_ENTRY_TYPE_PS("DATE_MODIFIED", 9, DBTYPE_DATE, 0xFF, 0xFF, m_DateModified)
END_PROVIDER_COLUMN_MAP()

};


class CCOLUMNSRow
{
public:

	WCHAR			m_szTableCatalog[129];
	WCHAR			m_szTableSchema[129];
	WCHAR			m_szTableName[129];
	WCHAR			m_szColumnName[129];
	GUID			m_guidColumn;
	ULONG			m_ulColumnPropID;
	ULONG			m_ulOrdinalPosition;
	VARIANT_BOOL	m_bColumnHasDefault;
	WCHAR			m_szColumnDefault[129];
	ULONG			m_ulColumnFlags;
	VARIANT_BOOL	m_bIsNullable;
	USHORT			m_nDataType;
	GUID			m_guidType;
	ULONG			m_ulCharMaxLength;
	ULONG			m_ulCharOctetLength;
	USHORT			m_nNumericPrecision;
	short			m_nNumericScale;
	ULONG			m_ulDateTimePrecision;
	WCHAR			m_szCharSetCatalog[129];
	WCHAR			m_szCharSetSchema[129];
	WCHAR			m_szCharSetName[129];
	WCHAR			m_szCollationCatalog[129];
	WCHAR			m_szCollationSchema[129];
	WCHAR			m_szCollationName[129];
	WCHAR			m_szDomainCatalog[129];
	WCHAR			m_szDomainSchema[129];
	WCHAR			m_szDomainName[129];
	WCHAR			m_szDescription[129];

	CCOLUMNSRow()
	{
		ClearMembers();
	}

	void ClearMembers()
	{
		m_szTableCatalog[0] = NULL;
		m_szTableSchema[0] = NULL;
		m_szTableName[0] = NULL;
		m_szColumnName[0] = NULL;
		m_guidColumn = GUID_NULL;
		m_ulColumnPropID = 0;
		m_ulOrdinalPosition = 0;
		m_bColumnHasDefault = ATL_VARIANT_FALSE;
		m_szColumnDefault[0] = NULL;
		m_ulColumnFlags = 0;
		m_bIsNullable = ATL_VARIANT_FALSE;
		m_nDataType = 0;
		m_guidType = GUID_NULL;
		m_ulCharMaxLength = 0;
		m_ulCharOctetLength = 0;
		m_nNumericPrecision = 0;
		m_nNumericScale = 0;
		m_ulDateTimePrecision = 0;
		m_szCharSetCatalog[0] = NULL;
		m_szCharSetSchema[0] = NULL;
		m_szCharSetName[0] = NULL;
		m_szCollationCatalog[0] = NULL;
		m_szCollationSchema[0] = NULL;
		m_szCollationName[0] = NULL;
		m_szDomainCatalog[0] = NULL;
		m_szDomainSchema[0] = NULL;
		m_szDomainName[0] = NULL;
		m_szDescription[0] = NULL;
	}


BEGIN_PROVIDER_COLUMN_MAP(CCOLUMNSRow)
	PROVIDER_COLUMN_ENTRY_WSTR("TABLE_CATALOG", 1, m_szTableCatalog)
	PROVIDER_COLUMN_ENTRY_WSTR("TABLE_SCHEMA", 2, m_szTableSchema)
	PROVIDER_COLUMN_ENTRY_WSTR("TABLE_NAME", 3, m_szTableName)
	PROVIDER_COLUMN_ENTRY_WSTR("COLUMN_NAME", 4, m_szColumnName)
	PROVIDER_COLUMN_ENTRY_PS("COLUMN_GUID", 5, 0xFF, 0xFF, m_guidColumn)
	PROVIDER_COLUMN_ENTRY_PS("COLUMN_PROPID",6, 10, 0xFF, m_ulColumnPropID)
	PROVIDER_COLUMN_ENTRY_PS("ORDINAL_POSITION",7, 10, 0xFF, m_ulOrdinalPosition)
	PROVIDER_COLUMN_ENTRY_TYPE_PS("COLUMN_HASDEFAULT",8, DBTYPE_BOOL, 0xFF, 0xFF, m_bColumnHasDefault)
	PROVIDER_COLUMN_ENTRY_PS("COLUMN_DEFAULT",9, 0xFF, 0xFF, m_szColumnDefault)
	PROVIDER_COLUMN_ENTRY_PS("COLUMN_FLAGS",10, 10, 0xFF, m_ulColumnFlags)
	PROVIDER_COLUMN_ENTRY_TYPE_PS("IS_NULLABLE",11, DBTYPE_BOOL, 0xFF, 0xFF, m_bIsNullable)
	PROVIDER_COLUMN_ENTRY_TYPE_PS("DATA_TYPE",12, DBTYPE_UI2, 5, 0xFF, m_nDataType)
	PROVIDER_COLUMN_ENTRY_PS("TYPE_GUID",13, 0xFF, 0xFF, m_guidType)
	PROVIDER_COLUMN_ENTRY_PS("CHARACTER_MAXIMUM_LENGTH",14, 10, 0xFF, m_ulCharMaxLength)
	PROVIDER_COLUMN_ENTRY_PS("CHARACTER_OCTET_LENGTH",15, 10, 0xFF, m_ulCharOctetLength)
	PROVIDER_COLUMN_ENTRY_PS("NUMERIC_PRECISION",16, 5, 0xFF, m_nNumericPrecision)
	PROVIDER_COLUMN_ENTRY_PS("NUMERIC_SCALE",17, 5, 0xFF, m_nNumericScale)
	PROVIDER_COLUMN_ENTRY_PS("DATETIME_PRECISION",18, 10, 0xFF, m_ulDateTimePrecision)
	PROVIDER_COLUMN_ENTRY_WSTR("CHARACTER_SET_CATALOG", 19, m_szCharSetCatalog)
	PROVIDER_COLUMN_ENTRY_WSTR("CHARACTER_SET_SCHEMA", 20, m_szCharSetSchema)
	PROVIDER_COLUMN_ENTRY_WSTR("CHARACTER_SET_NAME", 21, m_szCharSetName)
	PROVIDER_COLUMN_ENTRY_WSTR("COLLATION_CATALOG", 22, m_szCollationCatalog)
	PROVIDER_COLUMN_ENTRY_WSTR("COLLATION_SCHEMA", 23, m_szCollationSchema)
	PROVIDER_COLUMN_ENTRY_WSTR("COLLATION_NAME", 24, m_szCollationName)
	PROVIDER_COLUMN_ENTRY_WSTR("DOMAIN_CATALOG", 25, m_szDomainCatalog)
	PROVIDER_COLUMN_ENTRY_WSTR("DOMAIN_SCHEMA", 26, m_szDomainSchema)
	PROVIDER_COLUMN_ENTRY_WSTR("DOMAIN_NAME", 27, m_szDomainName)
	PROVIDER_COLUMN_ENTRY_WSTR("DESCRIPTION", 28, m_szDescription)
END_PROVIDER_COLUMN_MAP()
};

template <class ArrayClass>
HRESULT InitFromRowset(
	_Inout_ ArrayClass& rgData,
	_In_ DBID* pTableID,
	_In_ DBID* pIndexID,
	_Inout_ IUnknown* pSession,
	_Out_ LONG* pcRowsAffected)
{
	CComQIPtr<IOpenRowset> spOpenRowset = pSession;
	if (spOpenRowset == NULL)
		return E_FAIL;
	CComPtr<IColumnsInfo> spColInfo;
	HRESULT hr = spOpenRowset->OpenRowset(NULL, pTableID, pIndexID, __uuidof(IColumnsInfo), 0, NULL, (IUnknown**)&spColInfo);
	if (FAILED(hr))
		return hr;
	LPOLESTR szColumns = NULL;
	DBORDINAL cColumns = 0;
	DBCOLUMNINFO* pColInfo = NULL;
	hr = spColInfo->GetColumnInfo(&cColumns, &pColInfo, &szColumns);
	if (FAILED(hr))
		return hr;
	*pcRowsAffected = 0;
	for (ULONG iCol = 0; iCol < cColumns;  iCol++)
	{
		CCOLUMNSRow crData;
		DBCOLUMNINFO& rColCur = pColInfo[iCol];
		Checked::wcsncpy_s(crData.m_szTableName, _countof(crData.m_szTableName), pTableID->uName.pwszName, _TRUNCATE);
		Checked::wcsncpy_s(crData.m_szColumnName, _countof(crData.m_szColumnName), rColCur.pwszName, _TRUNCATE);
		Checked::wcsncpy_s(crData.m_szDescription, _countof(crData.m_szDescription), rColCur.pwszName, _TRUNCATE);
		GUID* pGuidCol = CDBIDOps::GetDBIDpGuid(rColCur.columnid);
		if (pGuidCol)
			crData.m_guidColumn = *pGuidCol;
		else
			crData.m_guidColumn = GUID_NULL;
		crData.m_ulColumnPropID = CDBIDOps::GetPropIDFromDBID(rColCur.columnid);
		crData.m_ulOrdinalPosition = rColCur.iOrdinal;
		crData.m_ulColumnFlags = rColCur.dwFlags;
		crData.m_bIsNullable = (rColCur.dwFlags & DBCOLUMNFLAGS_ISNULLABLE) ? ATL_VARIANT_TRUE : ATL_VARIANT_FALSE;
		crData.m_nDataType = rColCur.wType;
		crData.m_ulCharMaxLength = rColCur.ulColumnSize;
		crData.m_nNumericPrecision = rColCur.bPrecision;
		crData.m_nNumericScale = rColCur.bScale;
		//if (!rgData.Add(crData))
		//{
		//	CoTaskMemFree(pColInfo);
		//	CoTaskMemFree(szColumns);
		//	return E_OUTOFMEMORY;
		//}
		_ATLTRY
		{
			rgData.Add(crData);
		}
		_ATLCATCH( e )
		{
			_ATLDELETEEXCEPTION( e );
			CoTaskMemFree(pColInfo);
			CoTaskMemFree(szColumns);
			return E_OUTOFMEMORY;
		}

		(*pcRowsAffected)++;
	}

	CoTaskMemFree(pColInfo);
	CoTaskMemFree(szColumns);
	return S_OK;
}

class CPROVIDER_TYPERow
{
public:
// Attributes
	WCHAR			m_szName[129];
	USHORT			m_nType;
	ULONG			m_ulSize;
	WCHAR			m_szPrefix[129];
	WCHAR			m_szSuffix[129];
	WCHAR			m_szCreateParams[129];
	VARIANT_BOOL	m_bIsNullable;
	VARIANT_BOOL	m_bCaseSensitive;
	ULONG			m_ulSearchable;
	VARIANT_BOOL	m_bUnsignedAttribute;
	VARIANT_BOOL	m_bFixedPrecScale;
	VARIANT_BOOL	m_bAutoUniqueValue;
	WCHAR			m_szLocalTypeName[129];
	short			m_nMinScale;
	short			m_nMaxScale;
	GUID			m_guidType;
	WCHAR			m_szTypeLib[129];
	WCHAR			m_szVersion[129];
	VARIANT_BOOL	m_bIsLong;
	VARIANT_BOOL	m_bBestMatch;
	VARIANT_BOOL	m_bIsFixedLength;


	CPROVIDER_TYPERow()
	{
		m_szName[0] = NULL;
		m_nType = 0;
		m_ulSize = 0;
		m_szPrefix[0] = NULL;
		m_szSuffix[0] = NULL;
		m_szCreateParams[0] = NULL;
		m_bIsNullable = ATL_VARIANT_FALSE;
		m_bCaseSensitive = ATL_VARIANT_FALSE;
		m_ulSearchable = DB_UNSEARCHABLE;
		m_bUnsignedAttribute = ATL_VARIANT_FALSE;
		m_bFixedPrecScale = ATL_VARIANT_FALSE;
		m_bAutoUniqueValue = ATL_VARIANT_FALSE;
		m_szLocalTypeName[0] = NULL;
		m_nMinScale = 0;
		m_nMaxScale = 0;
		m_guidType = GUID_NULL;
		m_szTypeLib[0] = NULL;
		m_szVersion[0] = NULL;
		m_bIsLong = ATL_VARIANT_FALSE;
		m_bBestMatch = ATL_VARIANT_FALSE;
		m_bIsFixedLength = ATL_VARIANT_FALSE;
	}
// Binding Maps
BEGIN_PROVIDER_COLUMN_MAP(CPROVIDER_TYPERow)
	PROVIDER_COLUMN_ENTRY_WSTR("TYPE_NAME", 1, m_szName)
	PROVIDER_COLUMN_ENTRY_TYPE_PS("DATA_TYPE", 2, DBTYPE_UI2, 5, 0xFF, m_nType)
	PROVIDER_COLUMN_ENTRY_PS("COLUMN_SIZE", 3, 10, 0xFF, m_ulSize)
	PROVIDER_COLUMN_ENTRY_WSTR("LITERAL_PREFIX", 4, m_szPrefix)
	PROVIDER_COLUMN_ENTRY_WSTR("LITERAL_SUFFIX", 5, m_szSuffix)
	PROVIDER_COLUMN_ENTRY_WSTR("CREATE_PARAMS", 6, m_szCreateParams)
	PROVIDER_COLUMN_ENTRY_TYPE_PS("IS_NULLABLE", 7, DBTYPE_BOOL, 0xFF, 0xFF, m_bIsNullable)
	PROVIDER_COLUMN_ENTRY_TYPE_PS("CASE_SENSITIVE", 8, DBTYPE_BOOL, 0xFF, 0xFF, m_bCaseSensitive)
	PROVIDER_COLUMN_ENTRY_PS("SEARCHABLE", 9, 10, 0xFF, m_ulSearchable)
	PROVIDER_COLUMN_ENTRY_TYPE_PS("UNSIGNED_ATTRIBUTE", 10, DBTYPE_BOOL, 0xFF, 0xFF, m_bUnsignedAttribute)
	PROVIDER_COLUMN_ENTRY_TYPE_PS("FIXED_PREC_SCALE", 11, DBTYPE_BOOL, 0xFF, 0xFF, m_bFixedPrecScale)
	PROVIDER_COLUMN_ENTRY_TYPE_PS("AUTO_UNIQUE_VALUE", 12, DBTYPE_BOOL, 0xFF, 0xFF, m_bAutoUniqueValue)
	PROVIDER_COLUMN_ENTRY_WSTR("LOCAL_TYPE_NAME", 13, m_szLocalTypeName)
	PROVIDER_COLUMN_ENTRY_PS("MINIMUM_SCALE", 14, 5, 0xFF, m_nMinScale)
	PROVIDER_COLUMN_ENTRY_PS("MAXIMUM_SCALE", 15, 5, 0xFF, m_nMaxScale)
	PROVIDER_COLUMN_ENTRY_PS("GUID", 16, 0xFF, 0xFF, m_guidType)
	PROVIDER_COLUMN_ENTRY_WSTR("TYPELIB", 17, m_szTypeLib)
	PROVIDER_COLUMN_ENTRY_WSTR("VERSION", 18, m_szVersion)
	PROVIDER_COLUMN_ENTRY_TYPE_PS("IS_LONG", 19, DBTYPE_BOOL, 0xFF, 0xFF, m_bIsLong)
	PROVIDER_COLUMN_ENTRY_TYPE_PS("BEST_MATCH", 20, DBTYPE_BOOL, 0xFF, 0xFF, m_bBestMatch)
	PROVIDER_COLUMN_ENTRY_TYPE_PS("IS_FIXEDLENGTH", 21, DBTYPE_BOOL, 0xFF, 0xFF, m_bIsFixedLength)
END_PROVIDER_COLUMN_MAP()
};


class CEnumRowsetImpl
{
public:

	WCHAR m_szSourcesName[256];
	WCHAR m_szSourcesParseName[256];
	WCHAR m_szSourcesDescription[256];
	unsigned short m_iType;
	VARIANT_BOOL m_bIsParent;

BEGIN_PROVIDER_COLUMN_MAP(CEnumRowsetImpl)
	PROVIDER_COLUMN_ENTRY("SOURCES_NAME", 1, m_szSourcesName)
	PROVIDER_COLUMN_ENTRY("SOURCES_PARSENAME", 2, m_szSourcesParseName)
	PROVIDER_COLUMN_ENTRY("SOURCES_DESCRIPTION", 3, m_szSourcesDescription)
	PROVIDER_COLUMN_ENTRY("SOURCES_TYPE", 4, m_iType)
	PROVIDER_COLUMN_ENTRY("SOURCES_ISPARENT", 5, m_bIsParent)
END_PROVIDER_COLUMN_MAP()

};


///////////////////////////////////////////////////////////////////////////
// class IRowsetUpdateImpl

template <class T, class Storage,
			class UpdateArray = CAtlArray<Storage>,
			class RowClass = CSimpleRow,
			class MapClass = CAtlMap < RowClass::KeyType, RowClass* > >
class IRowsetUpdateImpl :
	public IRowsetChangeImpl<T, Storage, IRowsetUpdate, RowClass, MapClass>
{
public:
	// Destructor
	virtual ~IRowsetUpdateImpl()
	{
		m_mapCachedData.RemoveAll();
	}

	// IRowsetChange Methods
	STDMETHOD (SetData)(
		_In_ HROW hRow,
		_In_ HACCESSOR hAccessor,
		_In_opt_ void* pSrcData)
	{
		T* pT = (T*)this;

		__if_exists(T::Fire_OnFieldChange)
		{
			// Check to see if someone is in an event handler.  If we do, then
			// we should return DB_E_NOTREENTRANT.
			if (!pT->IncrementMutex())
				return DB_E_NOTREENTRANT;
			else
				pT->DecrementMutex();
		}

		// We provide this implementation for use as it adds more
		// complexity to the SetData function to handle both
		// immediate and deferred processing.  It also allows us to
		// cache the original data w/o increasing the size of
		// IRowsetChangeImpl
		RowClass* pRow;
		HRESULT hr;

		// Determine if we are in immediate or deferred mode, if we are in
		// immediate mode call FlushData.  Otherwise, add the orginal data
		// to the cache
		CComVariant varDeferred;
		bool bDeferred;
		hr = pT->GetPropValue(&DBPROPSET_ROWSET, DBPROP_IRowsetUpdate,
							&varDeferred);
		(FAILED(hr) || varDeferred.boolVal == ATL_VARIANT_FALSE) ? bDeferred = false : bDeferred = true;

		if( ! pT->m_rgRowHandles.Lookup(hRow, pRow) )
			return DB_E_BADROWHANDLE;

		if (hRow == NULL || pRow == NULL)
			return DB_E_BADROWHANDLE;

		// If we've deleted the row (or are pending) then SetData should fail
		if (pRow->m_status == DBPENDINGSTATUS_DELETED)
			return DB_E_DELETEDROW;

		if (bDeferred)
		{
			__if_exists(T::Fire_OnRowChange)
			{
				if (pRow->m_status != DBPENDINGSTATUS_CHANGED &&
					pRow->m_status != (DBPENDINGSTATUS_NEW | DBPENDINGSTATUS_UNCHANGED))
				{
					HRESULT hrNotify = pT->Fire_OnRowChange(pT, 1, &hRow,
						DBREASON_ROW_FIRSTCHANGE, DBEVENTPHASE_OKTODO, FALSE);
					if ((hrNotify != S_OK) && (hrNotify != E_FAIL))
						return DB_E_CANCELED;

					hrNotify = pT->Fire_OnRowChange(pT, 1, &hRow,
						DBREASON_ROW_FIRSTCHANGE, DBEVENTPHASE_ABOUTTODO, FALSE);
					if ((hrNotify != S_OK) && (hrNotify != E_FAIL))
						return DB_E_CANCELED;
				}
			}

			// If a row is soft inserted (i.e. haven't called update yet)
			// then ignore this section.  An undo will cause the row to
			// delete.
			if (pRow->m_status != DBPENDINGSTATUS_NEW)
			{
				// See if row is already cached, don't make any changes
				//void* pData = (void*)m_mapCachedData.Lookup(hRow, pTemp);
				Storage* pData;
				if (! m_mapCachedData.Lookup(hRow, pData) )
				{
					Storage* pam = NULL;
					ATLTRY(pam = new Storage);
					if (pam == NULL)
						return E_OUTOFMEMORY;
					Checked::memcpy_s(pam, sizeof(Storage), &pT->m_rgRowData[pRow->m_iRowset], sizeof(Storage));

					_ATLTRY
					{
						m_mapCachedData.SetAt(hRow, pam);
					}
					_ATLCATCH( e )
					{
						_ATLDELETEEXCEPTION( e );
						return E_FAIL;
					}
				}
			}
		}

		// NOTE: TransferData will send the SYNCHAFTER phase of the FIRSTCHANGE
		// notification message.  It will handle a veto internally.
		hr = TransferData<T, RowClass, MapClass>
						(pT, false, pSrcData, pRow, &(pT->m_rgRowHandles), hAccessor);
		if (FAILED(hr))
			return hr;

		// Flush Users Data, if in immediate mode
		if (!bDeferred)
		{
			HRESULT hrFlush = pT->FlushData(hRow, hAccessor);
			if (hrFlush == S_OK)
				return hr;  // TransferData may have returned DB_S_ERRORSOCCURRED
			else
				return hrFlush;
		}
		else
		{
			__if_exists(T::Fire_OnRowChange)
			{
				if (pRow->m_status != DBPENDINGSTATUS_CHANGED &&
					pRow->m_status != (DBPENDINGSTATUS_NEW | DBPENDINGSTATUS_UNCHANGED))
				{
					pT->Fire_OnRowChange(pT, 1, &hRow,
						DBREASON_ROW_FIRSTCHANGE, DBEVENTPHASE_DIDEVENT, TRUE);
				}
			}

			if (pRow->m_status != DBPENDINGSTATUS_NEW)
				pRow->m_status = DBPENDINGSTATUS_CHANGED;
			return hr;	// TransferData may have returned DB_S_ERRORSOCCURRED
		}
	}

	// IRowsetUpdate Methods
	STDMETHOD (GetOriginalData)(
		_In_ HROW hRow,
		_In_ HACCESSOR hAccessor,
		_Inout_opt_ void* pData)
	{
		ATLTRACE(atlTraceDBProvider, 2, _T("IRowsetUpdateImpl::GetOriginalData\n"));

		T* pT = (T*)this;

		__if_exists(T::Fire_OnRowChange)
		{
			// Check to see if someone is in an event handler.  If we do, then
			// we should return DB_E_NOTREENTRANT.
			if (!pT->IncrementMutex())
				return DB_E_NOTREENTRANT;
			else
				pT->DecrementMutex();
		}

		// Validate input parameters
		T::_BindType* pBinding;
		bool bFound = pT->m_rgBindings.Lookup((INT_PTR)hAccessor, pBinding);
		if (!bFound || pBinding == NULL)
			return DB_E_BADACCESSORHANDLE;

		if (pData == NULL && pBinding->cBindings != 0)
			return E_INVALIDARG;

		RowClass* pRow;
		if (! pT->m_rgRowHandles.Lookup(hRow, pRow))
			return DB_E_BADROWHANDLE;
		if (hRow == NULL || pRow == NULL)
			return DB_E_BADROWHANDLE;

		// If the status is DBPENDINGSTATUS_INVALIDROW, the row has been
		// deleted and the change transmitted to the data source.  In
		// this case, we can't get the original data so return
		// DB_E_DELETEDROW.
		if (pRow->m_status == DBPENDINGSTATUS_INVALIDROW)
			return DB_E_DELETEDROW;

		// Note, need to determine if accessor is not a row accessor


		// Determine if we have a pending insert. In this case, the
		// spec says revert to default values, and if defaults,
		// are not available, then NULLs.

		if (pRow->m_status == DBPENDINGSTATUS_NEW)
		{
			ATLCOLUMNINFO* pInfo;
			bool bSucceeded = true;
			bool bFailed = false;
			DBORDINAL ulColumns;
			Storage temp;
			Checked::memcpy_s(&temp, sizeof(Storage), &pT->m_rgRowData[pRow->m_iRowset], sizeof(Storage));

			pInfo = T::GetColumnInfo(pT, &ulColumns);

			for (ULONG lBind=0; lBind<pBinding->cBindings; lBind++)
			{
				DBBINDING* pBindCur = &(pBinding->pBindings[lBind]);
				ULONG lColInfo;
				for (lColInfo=0; lColInfo<ulColumns &&
					pBindCur->iOrdinal != pInfo[lColInfo].iOrdinal; lColInfo++);
				if (lColInfo == ulColumns)
					return DB_E_BADORDINAL;

				ATLCOLUMNINFO* pColCur = &(pInfo[lColInfo]);
				DBSTATUS dbStat = DBSTATUS_S_DEFAULT;

				// Try to get the default value.  if that doesn't work, then
				// attempt to do a NULL value
				if (FAILED(pT->SetDBStatus(&dbStat, pRow, pColCur)))
				{
					if ((pColCur->dwFlags & DBCOLUMNFLAGS_ISNULLABLE) ||
						(pColCur->dwFlags & DBCOLUMNFLAGS_MAYBENULL))
					{
						BYTE* pDstTemp = (BYTE*)(&(pT->m_rgRowData[pRow->m_iRowset]) + pColCur->cbOffset);
						*pDstTemp = NULL;
						if (pBindCur->dwPart & DBPART_STATUS)
							*((DBSTATUS*)((BYTE*)(pData) + pBindCur->obStatus)) = DBSTATUS_S_ISNULL;
						bSucceeded |= true;
						continue;
					}
					else
					{
						if (pBindCur->dwPart & DBPART_STATUS)
							*((DBSTATUS*)((BYTE*)(pData) + pBindCur->obStatus)) = DBSTATUS_E_UNAVAILABLE;
						bFailed = true;
						continue;
					}
				}
				else
				{
					if (pBindCur->dwPart & DBPART_STATUS)
						*((DBSTATUS*)((BYTE*)(pData) + pBindCur->obStatus)) = DBSTATUS_S_OK;
					bSucceeded |= true;
					continue;
				}
			}

			TransferData<T, RowClass, MapClass>
					(pT, true, pData, pRow, &(pT->m_rgRowHandles), hAccessor);

			Checked::memcpy_s(&pT->m_rgRowData[pRow->m_iRowset], sizeof(Storage), &temp, sizeof(Storage));
			if (!bFailed)
				return S_OK;
			else
				return (bSucceeded ? DB_S_ERRORSOCCURRED : DB_E_ERRORSOCCURRED);
		}

		// Determine if the row is cached, if so, we'll temporarily replace
		// it in m_rgRowData and call TransferData to handle the accessor.
		// It is kind of strange but it saves us from having to reimplement
		// TransferData

		Storage* pam;
		bFound = m_mapCachedData.Lookup(hRow, pam);
		Storage temp;

		if (bFound && pam != NULL)
		{
			Checked::memcpy_s(&temp, sizeof(Storage), &pT->m_rgRowData[pRow->m_iRowset], sizeof(Storage));
			Checked::memcpy_s(&pT->m_rgRowData[pRow->m_iRowset], sizeof(Storage), pam, sizeof(Storage));
		}

		// We need to trick TransferData to thinking a non-transmitted
		// deleted row is still alive.  This will be its final state after
		// we return anyway.
		if (pRow->m_status == DBPENDINGSTATUS_DELETED)
			pRow->m_status = DBPENDINGSTATUS_UNCHANGED;

		HRESULT hr = TransferData<T, RowClass, MapClass>
						(pT, true, pData, pRow, &(pT->m_rgRowHandles), hAccessor);

		if (bFound && pam != NULL)
		{
			Checked::memcpy_s(&pT->m_rgRowData[pRow->m_iRowset], sizeof(Storage), &temp, sizeof(Storage));
		}

		pRow->m_status = DBPENDINGSTATUS_UNCHANGED;
		return hr;
	}

	STDMETHOD (GetPendingRows)(
		_In_ HCHAPTER /*hReserved*/,
		_In_ DBPENDINGSTATUS dwRowStatus,
		_Out_opt_ DBCOUNTITEM* pcPendingRows,
		_Deref_opt_out_opt_ HROW** prgPendingRows,
		_Deref_opt_out_opt_ DBPENDINGSTATUS** prgPendingStatus)
	{
		ATLTRACE(atlTraceDBProvider, 2, _T("IRowsetUpdateImpl::GetPendingRows\n"));
		T* pT = (T*)this;
		bool bPending = false;
		RowClass* pRow = NULL;
		//DBROWCOUNT ulRowHandles = (DBROWCOUNT)pT->m_rgRowHandles.GetCount();

		if (pcPendingRows != NULL)
		{
			*pcPendingRows = 0;

			if (prgPendingRows != NULL)
				*prgPendingRows = NULL;

			if (prgPendingStatus != NULL)
				*prgPendingStatus = NULL;
		}

		// Validate input parameters
		if ((dwRowStatus &
			~(DBPENDINGSTATUS_NEW | DBPENDINGSTATUS_CHANGED | DBPENDINGSTATUS_DELETED)) != 0)
			return E_INVALIDARG;

		// Validate input parameters
		if ((dwRowStatus &
			~(DBPENDINGSTATUS_NEW | DBPENDINGSTATUS_CHANGED | DBPENDINGSTATUS_DELETED)) != 0)
			return E_INVALIDARG;

		// Determine how many rows we'll need to return

		POSITION pos = pT->m_rgRowHandles.GetStartPosition();
		while( pos != NULL )
		{
			MapClass::CPair* pPair = pT->m_rgRowHandles.GetNext( pos );
			ATLASSERT( pPair != NULL );
			if(!pPair)
			{
				return E_FAIL;
			}

			// Check to see if a row has a pending status
			pRow = pPair->m_value;

			if (pRow->m_status & dwRowStatus)
			{
				if (pcPendingRows != NULL)
					(*pcPendingRows)++;
				bPending = true;
			}
		}

		// In this case, there are no pending rows that match, just exit out
		if (!bPending)
		{
			// There are no pending rows so exit immediately
			return S_FALSE;
		}
		else
		{
			// Here' the consumer just wants to see if there are pending rows
			// we know that so we can exit
			if (pcPendingRows == NULL)
				return S_OK;
		}

		// Allocate arrays for pending rows
		if (prgPendingRows != NULL)
		{
			*prgPendingRows = (HROW*)::ATL::AtlCoTaskMemCAlloc(*pcPendingRows, static_cast<ULONG>(sizeof(HROW)));
			if (*prgPendingRows == NULL)
			{
				*pcPendingRows = 0;
				return E_OUTOFMEMORY;
			}
		}

		if (prgPendingStatus != NULL)
		{
			*prgPendingStatus = (DBPENDINGSTATUS*)::ATL::AtlCoTaskMemCAlloc(*pcPendingRows, static_cast<ULONG>(sizeof(DBPENDINGSTATUS)));
			if (*prgPendingStatus == NULL)
			{
				*pcPendingRows = 0;
				CoTaskMemFree(*prgPendingRows);
				*prgPendingRows = NULL;
				return E_OUTOFMEMORY;
			}
			memset(*prgPendingStatus, 0, *pcPendingRows * sizeof(DBPENDINGSTATUS));
		}

		if (prgPendingRows || prgPendingStatus)
		{
			ULONG ulRows = 0;
			pos = pT->m_rgRowHandles.GetStartPosition();
			while( pos != NULL )
			{
				MapClass::CPair* pPair = pT->m_rgRowHandles.GetNext( pos );
				ATLASSERT( pPair != NULL );

				pRow = pPair->m_value;
				if (pRow->m_status & dwRowStatus)
				{
					// Add the output row
					pRow->AddRefRow();
					if (prgPendingRows)
						((*prgPendingRows)[ulRows]) = /*(HROW)*/pPair->m_key;
					if (prgPendingStatus)
						((*prgPendingStatus)[ulRows]) = (DBPENDINGSTATUS)pRow->m_status;
					ulRows++;
				}
			}
			/*
			for (iRowset = 0; iRowset < ulRowHandles; iRowset++)
			{
				pRow = pT->m_rgRowHandles.GetValueAt(iRowset);
				if (pRow->m_status & dwRowStatus)
				{
					// Add the output row
					pRow->AddRefRow();
					if (prgPendingRows)
						((*prgPendingRows)[ulRows]) = (HROW)pT->m_rgRowHandles.GetKeyAt(iRowset);
					if (prgPendingStatus)
						((*prgPendingStatus)[ulRows]) = (DBPENDINGSTATUS)pRow->m_status;
					ulRows++;
				}
			}
			*/
			if (pcPendingRows != NULL)
				*pcPendingRows = ulRows;
		}

		// Return code depending on
		return S_OK;
	}

	STDMETHOD (GetRowStatus)(
		_In_ HCHAPTER /*hReserved*/,
		_In_ DBCOUNTITEM cRows,
		_In_count_(cRows) const HROW rghRows[],
		_Out_cap_(cRows) DBPENDINGSTATUS rgPendingStatus[])
	{
		ATLTRACE(atlTraceDBProvider, 2, _T("IRowsetUpdateImpl::GetRowStatus\n"));
		T* pT = (T*)this;

		bool bSucceeded = true;
		ULONG ulFetched = 0;

		if (cRows != 0)
		{
			// check for correct pointers
			if (rghRows == NULL || rgPendingStatus == NULL)
				return E_INVALIDARG;

			for (ULONG ulRows=0; ulRows < cRows; ulRows++)
			{
				RowClass* pRow;
				bool bFound = pT->m_rgRowHandles.Lookup(rghRows[ulRows], pRow);
				if ((! bFound || pRow == NULL) || (pRow->m_status == DBPENDINGSTATUS_INVALIDROW))
				{
					rgPendingStatus[ulRows] = DBPENDINGSTATUS_INVALIDROW;
					bSucceeded = false;
					continue;
				}
				if (pRow->m_status != 0)
					rgPendingStatus[ulRows] = pRow->m_status;
				else
					rgPendingStatus[ulRows] = DBPENDINGSTATUS_UNCHANGED;

				ulFetched++;
			}
		}

		if (bSucceeded)
		{
			return S_OK;
		}
		else
		{
			if (ulFetched > 0)
				return DB_S_ERRORSOCCURRED;
			else
				return DB_E_ERRORSOCCURRED;
		}
	}

	STDMETHOD (Undo)(
		_In_ HCHAPTER /*hReserved*/,
		_In_ DBCOUNTITEM cRows,
		_In_count_(cRows) const HROW rghRows[],
		_Out_ DBCOUNTITEM *pcRowsUndone,
		_Out_opt_ _Deref_post_opt_cap_(*pcRowsUndone) HROW **prgRowsUndone,
		_Out_opt_ _Deref_post_opt_cap_(*pcRowsUndone) DBROWSTATUS **prgRowStatus)
	{
		ATLTRACE(atlTraceDBProvider, 2, _T("IRowsetUpdateImpl::Undo\n"));

		T* pT = (T*)this;
		T::ObjectLock lock(pT);

		__if_exists(T::Fire_OnRowChange)
		{
			// Check to see if someone is in an event handler.  If we do, then
			// we should return DB_E_NOTREENTRANT.
			if (!pT->IncrementMutex())
			{
				// Note, we can't set this up above as we may inadvertantly
				// step on the pcRowsUndone variable.
				if (pcRowsUndone != NULL)
					*pcRowsUndone = NULL;
				return DB_E_NOTREENTRANT;
			}
			else
				pT->DecrementMutex();
		}

		DBCOUNTITEM ulRows = 0;
		bool bSucceeded = false;
		bool bFailed = false;
		bool bIgnore = false;
		ULONG ulUndone = 0;

		// the following lines are used to fix the two _alloca calls below.  Those calls are risky
		// because we may be allocating huge amounts of data.  So instead I'll allocate that data on heap.
		// But if you use _alloca you don't have to worry about cleaning this memory.  So we will use these
		// temporary variables to allocate memory on heap.  As soon as we exit the function, the memory will
		// be cleaned up, just as if we were using alloca. So now, instead of calling alloca, I'll alloc
		// memory on heap using the two smnart pointers below, and then assing it to the actual pointers.
		CHeapPtr<HROW> spTempRowsUndone;
		CHeapPtr<DBROWSTATUS> spTempRowStatus;

		__if_exists(T::Fire_OnRowChange)
		{
			HRESULT hrNotify = S_OK;
			int nReason = 0;
		}

		// Ignore prgRowsUndone/prgRowStatus if pcRowsUndone is NULL and
		// cRows == 0.
		if (pcRowsUndone != NULL || cRows != 0)
		{
			if (prgRowsUndone != NULL)
				*prgRowsUndone = NULL;

			if (prgRowStatus != NULL)
				*prgRowStatus = NULL;
		}
		else
		{
			bIgnore = true;		// Don't do status or row arrays
		}

		// Check to see how many changes we'll undo
		if (pcRowsUndone != NULL)
		{
			*pcRowsUndone = NULL;
			 if (prgRowsUndone == NULL)
				 return E_INVALIDARG;
		}


		if (cRows != 0)
		{
			if (rghRows == NULL)
				return E_INVALIDARG;

			ulRows = cRows;
		}
		else
			ulRows = (DBCOUNTITEM)pT->m_rgRowHandles.GetCount();

		// NULL out pointers
		if (prgRowsUndone != NULL && ulRows != 0 && bIgnore == false)
		{
			// Make a temporary buffer as we may not fill up everything
			// in the case where cRows == 0
			if (cRows != 0)
				*prgRowsUndone = (HROW*)::ATL::AtlCoTaskMemCAlloc(ulRows, static_cast<ULONG>(sizeof(HROW)));
			else
			{
				spTempRowsUndone.Allocate(ulRows);
				*prgRowsUndone = spTempRowsUndone;
			}

			if (*prgRowsUndone == NULL)
				return E_OUTOFMEMORY;
		}
		else
		{
			if (prgRowsUndone != NULL && bIgnore == false)
				*prgRowsUndone = NULL;
		}

		if (prgRowStatus != NULL && ulRows != 0 && bIgnore == false)
		{
			if (cRows != 0)
				*prgRowStatus = (DBROWSTATUS*)::ATL::AtlCoTaskMemCAlloc(ulRows, static_cast<ULONG>(sizeof(DBROWSTATUS)));
			else
			{
				spTempRowStatus.Allocate(ulRows);
				*prgRowStatus = spTempRowStatus;
			}

			if (*prgRowStatus == NULL)
			{
				if (cRows != 0)
					CoTaskMemFree(*prgRowsUndone);
				*prgRowsUndone = NULL;
				return E_OUTOFMEMORY;
			}
		}
		else
		{
			if (prgRowStatus != NULL && bIgnore == false)
				*prgRowStatus = NULL;
		}

		POSITION pos = pT->m_rgRowHandles.GetStartPosition();
		RowClass* pRow = NULL;
		for (ULONG ulUndoRow = 0; ulUndoRow < ulRows; ulUndoRow++)
		{
			HROW hRowUndo = NULL;
			ULONG ulCurrentRow = ulUndone;

			if (rghRows != NULL && cRows != 0)
			{
				hRowUndo = rghRows[ulUndoRow];
			}
			else
			{
				ATLASSERT(ulUndoRow < (ULONG)pT->m_rgRowHandles.GetCount());
				ATLASSERT( pos != NULL );
				MapClass::CPair* pPair = pT->m_rgRowHandles.GetNext(pos);
				ATLASSERT( pPair != NULL );
				if(!pPair)
				{
					return E_FAIL;
				}
				hRowUndo = pPair->m_key;
			}

			if (prgRowsUndone != NULL && bIgnore == false)
				(*prgRowsUndone)[ulCurrentRow] = hRowUndo;

			// Fetch the RowClass and determine if it is valid
			bool bFound = pT->m_rgRowHandles.Lookup(hRowUndo, pRow);
			if (!bFound || pRow == NULL)
			{
				if (prgRowStatus != NULL && bIgnore == false)
					(*prgRowStatus)[ulCurrentRow] = DBROWSTATUS_E_INVALID;
				bFailed = true;
				ulUndone++;
				continue;
			}

			// If cRows is zero we'll go through all rows fetched.  We shouldn't
			// increment the count for rows that haven't been modified.

			if (cRows != 0 || (pRow != NULL &&
				pRow->m_status != 0 && pRow->m_status != DBPENDINGSTATUS_UNCHANGED
				&& pRow->m_status != DBPENDINGSTATUS_INVALIDROW))
				ulUndone++;
			else
				continue;


			// AddRef the row if cRows is zero (we will be returning it to the
			// consumer)
			if (cRows == 0)
				pRow->AddRefRow();

			// Fetch the data, note, this may be NULL in several cases
			Storage* pData;
			if(! m_mapCachedData.Lookup(hRowUndo, pData) )
				pData = NULL;

			switch (pRow->m_status)
			{
			case DBPENDINGSTATUS_INVALIDROW:	// Row has already been hard deleted
				if (prgRowStatus != NULL && bIgnore == false)
					(*prgRowStatus)[ulCurrentRow] = DBROWSTATUS_E_DELETED;
				bFailed = true;
				continue;
				break;

			case DBPENDINGSTATUS_NEW:			// Row has been soft inserted
				// If the row is newly inserted, go ahead and mark its
				// row as INVALID (according to the specification).

				__if_exists(T::Fire_OnRowChange)
				{
					hrNotify = pT->Fire_OnRowChange(pT, 1, &hRowUndo,
						DBREASON_ROW_UNDOINSERT, DBEVENTPHASE_OKTODO, FALSE);

					if ((hrNotify != S_OK) && (hrNotify != E_FAIL))
					{
						if (prgRowStatus != NULL && bIgnore == false)
							(*prgRowStatus)[ulCurrentRow] = DBROWSTATUS_E_CANCELED;
						bFailed = true;
						continue;
					}

					hrNotify = pT->Fire_OnRowChange(pT, 1, &hRowUndo,
						DBREASON_ROW_UNDOINSERT, DBEVENTPHASE_ABOUTTODO, FALSE);

					if ((hrNotify != S_OK) && (hrNotify != E_FAIL))
					{
						if (prgRowStatus != NULL && bIgnore == false)
							(*prgRowStatus)[ulCurrentRow] = DBROWSTATUS_E_CANCELED;
						bFailed = true;
						continue;
					}

					hrNotify = pT->Fire_OnRowChange(pT, 1, &hRowUndo,
						DBREASON_ROW_UNDOINSERT, DBEVENTPHASE_SYNCHAFTER, FALSE);

					if ((hrNotify != S_OK) && (hrNotify != E_FAIL))
					{
						if (prgRowStatus != NULL && bIgnore == false)
							(*prgRowStatus)[ulCurrentRow] = DBROWSTATUS_E_CANCELED;
						bFailed = true;
						continue;
					}
				}

				if (prgRowStatus != NULL && bIgnore == false)
					(*prgRowStatus)[ulCurrentRow] = DBROWSTATUS_S_OK;
				pT->m_rgRowData.RemoveAt(pRow->m_iRowset);

				// Move any other subsequent rows up in the chain
				{
					POSITION posRow = pT->m_rgRowHandles.GetStartPosition();
					while(posRow != NULL)
					{
						MapClass::CPair* pPair = pT->m_rgRowHandles.GetNext(posRow);
						ATLASSERT( pPair != NULL );
						if(!pPair)
						{
							return E_FAIL;
						}
						RowClass* pCheckRow = pPair->m_value;
						if (pCheckRow != NULL &&
							pCheckRow->m_iRowset > pRow->m_iRowset)
							pCheckRow->m_iRowset--;
					}
				}

				pRow->m_status = DBPENDINGSTATUS_INVALIDROW;
				bSucceeded = true;

				__if_exists(T::Fire_OnRowChange)
				{
					pT->Fire_OnRowChange(pT, 1, &hRowUndo, DBREASON_ROW_UNDOINSERT,
						DBEVENTPHASE_DIDEVENT, TRUE);
				}

				continue;
				break;

			case 0:								// Row has just been fetched
			case DBPENDINGSTATUS_DELETED:		// Row has been soft deleted
			case DBPENDINGSTATUS_UNCHANGED:		// Row is not changed
				__if_exists(T::Fire_OnRowChange)
				{
					if (pRow->m_status == DBPENDINGSTATUS_DELETED)
					{
						nReason = 1;
						hrNotify = pT->Fire_OnRowChange(pT, 1, &hRowUndo,
							DBREASON_ROW_UNDODELETE, DBEVENTPHASE_OKTODO, FALSE);

						if ((hrNotify != S_OK) && (hrNotify != E_FAIL))
						{
							if (prgRowStatus != NULL && bIgnore == false)
								(*prgRowStatus)[ulCurrentRow] = DBROWSTATUS_E_CANCELED;
							bFailed = true;
							continue;
						}

						hrNotify = pT->Fire_OnRowChange(pT, 1, &hRowUndo,
							DBREASON_ROW_UNDODELETE, DBEVENTPHASE_ABOUTTODO, FALSE);

						if ((hrNotify != S_OK) && (hrNotify != E_FAIL))
						{
							if (prgRowStatus != NULL && bIgnore == false)
								(*prgRowStatus)[ulCurrentRow] = DBROWSTATUS_E_CANCELED;
							bFailed = true;
							continue;
						}

						hrNotify = pT->Fire_OnRowChange(pT, 1, &hRowUndo,
							DBREASON_ROW_UNDODELETE, DBEVENTPHASE_SYNCHAFTER, FALSE);

						if ((hrNotify != S_OK) && (hrNotify != E_FAIL))
						{
							if (prgRowStatus != NULL && bIgnore == false)
								(*prgRowStatus)[ulCurrentRow] = DBROWSTATUS_E_CANCELED;
							bFailed = true;
							continue;
						}
					}
				}

				pRow->m_status = DBPENDINGSTATUS_UNCHANGED;

				if (prgRowStatus != NULL && bIgnore == false)
					(*prgRowStatus)[ulCurrentRow] = DBROWSTATUS_S_OK;
				bSucceeded = true;

				// Somebody set, then deleted a row most likely
				if (pData != NULL)
				{
					Checked::memcpy_s(&pT->m_rgRowData[pRow->m_iRowset], sizeof(Storage), pData, sizeof(Storage));
				}

				__if_exists(T::Fire_OnRowChange)
				{
					if (nReason == 1)
					{
						pT->Fire_OnRowChange(pT, 1, &hRowUndo, DBREASON_ROW_UNDODELETE,
							DBEVENTPHASE_DIDEVENT, TRUE);
						nReason = 0;
					}
				}
				continue;
				break;

			default:							// Row has been changed
				__if_exists(T::Fire_OnRowChange)
				{
					hrNotify = pT->Fire_OnRowChange(pT, 1, &hRowUndo,
						DBREASON_ROW_UNDOCHANGE, DBEVENTPHASE_OKTODO, FALSE);

					if ((hrNotify != S_OK) && (hrNotify != E_FAIL))
					{
						if (prgRowStatus != NULL && bIgnore == false)
							(*prgRowStatus)[ulCurrentRow] = DBROWSTATUS_E_CANCELED;
						bFailed = true;
						continue;
					}

					hrNotify = pT->Fire_OnRowChange(pT, 1, &hRowUndo,
						DBREASON_ROW_UNDOCHANGE, DBEVENTPHASE_ABOUTTODO, FALSE);

					if ((hrNotify != S_OK) && (hrNotify != E_FAIL))
					{
						if (prgRowStatus != NULL && bIgnore == false)
							(*prgRowStatus)[ulCurrentRow] = DBROWSTATUS_E_CANCELED;
						bFailed = true;
						continue;
					}

					hrNotify = pT->Fire_OnRowChange(pT, 1, &hRowUndo,
						DBREASON_ROW_UNDOCHANGE, DBEVENTPHASE_SYNCHAFTER, FALSE);

					if ((hrNotify != S_OK) && (hrNotify != E_FAIL))
					{
						if (prgRowStatus != NULL && bIgnore == false)
							(*prgRowStatus)[ulCurrentRow] = DBROWSTATUS_E_CANCELED;
						bFailed = true;
						continue;
					}
				}

				if (pData == NULL)
				{
					__if_exists(T::Fire_OnRowChange)
					{
						pT->Fire_OnRowChange(pT, 1, &hRowUndo, DBREASON_ROW_UNDOCHANGE,
							DBEVENTPHASE_FAILEDTODO, FALSE);
					}

					if (prgRowStatus != NULL && bIgnore == false)
						(*prgRowStatus)[ulCurrentRow] = DBROWSTATUS_E_INVALID;
					bFailed = true;
					continue;
				}

				// Copy data back
				Checked::memcpy_s(&pT->m_rgRowData[pRow->m_iRowset], sizeof(Storage), pData, sizeof(Storage));
				if (prgRowStatus != NULL && bIgnore == false)
					(*prgRowStatus)[ulCurrentRow] = DBROWSTATUS_S_OK;
				pRow->m_status = DBPENDINGSTATUS_UNCHANGED;
				bSucceeded = true;

				// Remove undo buffer
				m_mapCachedData.RemoveKey(hRowUndo);

				// Check if we need to release the row because it's ref was 0
				// See the IRowset::ReleaseRows section in the spec for more
				// information
				if (pRow->m_dwRef == 0)
				{
					pRow->AddRefRow();	// Artifically bump this to remove it
					if( FAILED( pT->RefRows(1, &hRowUndo, NULL, NULL, false) ) )
						return E_FAIL;
				}

				__if_exists(T::Fire_OnRowChange)
				{
					pT->Fire_OnRowChange(pT, 1, &hRowUndo, DBREASON_ROW_UNDOCHANGE,
						DBEVENTPHASE_DIDEVENT, TRUE);
				}

				break;
			}
		}

		// Set the output for rows undone.
		if (pcRowsUndone)
			*pcRowsUndone = ulUndone;

		// In the case where cRows == 0, we need to allocate the final
		// array of data.
		if (cRows == 0)
		{
			HROW* prowTemp = NULL;
			DBROWSTATUS* prowStatus = NULL;

			if (prgRowsUndone != NULL && ulUndone != 0 && bIgnore == false)
			{
				prowTemp = (HROW*)::ATL::AtlCoTaskMemCAlloc(ulUndone, static_cast<ULONG>(sizeof(HROW)));
				if (prowTemp == NULL)
				{
					// Free prgRowsUndone
					if (cRows != 0 && prgRowsUndone != NULL)
						CoTaskMemFree(*prgRowsUndone);

					if (cRows != 0 && prgRowStatus != NULL)
						CoTaskMemFree(*prgRowStatus);

					return E_OUTOFMEMORY;
				}

				Checked::memcpy_s(prowTemp, (sizeof(HROW)*ulUndone), *prgRowsUndone, (sizeof(HROW)*ulUndone));
				if (cRows != 0)
					CoTaskMemFree(*prgRowsUndone);  // we're finished w/ the temp array
				*prgRowsUndone = prowTemp;
			}
			else
			{
				if (prgRowsUndone != NULL && bIgnore == false)
					*prgRowsUndone = NULL;
			}

			if (prgRowStatus != NULL && ulUndone != 0 && bIgnore == false)
			{
				prowStatus = (DBROWSTATUS*)::ATL::AtlCoTaskMemCAlloc(ulUndone, static_cast<ULONG>(sizeof(DBROWSTATUS)));
				if (prowStatus == NULL)
				{
					if (cRows != 0 && prgRowsUndone != NULL)
						CoTaskMemFree(*prgRowsUndone);

					if (prgRowStatus != NULL && cRows != 0)
						CoTaskMemFree(*prgRowStatus);

					return E_OUTOFMEMORY;
				}

				Checked::memcpy_s(prowStatus, (sizeof(DBROWSTATUS)*ulUndone), *prgRowStatus, (sizeof(DBROWSTATUS)*ulUndone));
				if (cRows != 0)
					CoTaskMemFree(*prgRowStatus);
				*prgRowStatus = prowStatus;
			}
			else
			{
				if (prgRowStatus != NULL && bIgnore == false)
					*prgRowStatus = NULL;
			}
		}

		// Send the return value
		if (!bFailed)
			return S_OK;
		else
		{
			if (!bSucceeded)
				return DB_E_ERRORSOCCURRED;
			else
				return DB_S_ERRORSOCCURRED;
		}
	}

	STDMETHOD (Update)(
		_In_ HCHAPTER /*hReserved*/,
		_In_ DBCOUNTITEM cRows,
		_In_count_(cRows) const HROW rghRows[],
		_Out_ DBCOUNTITEM *pcRows,
		_Out_opt_ _Deref_post_opt_cap_(*pcRows) HROW **prgRows,
		_Out_opt_ _Deref_post_opt_cap_(*pcRows) DBROWSTATUS **prgRowStatus)
	{
		ATLTRACE(atlTraceDBProvider, 2, _T("IRowsetUpdateImpl::Update\n"));

		T* pT = (T*)this;
		T::ObjectLock lock(pT);

		__if_exists(T::Fire_OnRowChange)
		{
			// Check to see if someone is in an event handler.  If we do, then
			// we should return DB_E_NOTREENTRANT.
			if (!pT->IncrementMutex())
			{
				if (pcRows != NULL)
					*pcRows = NULL;
				return DB_E_NOTREENTRANT;
			}
			else
				pT->DecrementMutex();
		}

		bool bSucceeded = false;
		bool bFailed = false;
		bool bIgnore = false;
		ULONG ulCount = 0;
		DBCOUNTITEM ulRowUpdate = 0;

		// the following lines are used to fix the two _alloca calls below.  Those calls are risky
		// because we may be allocating huge amounts of data.  So instead I'll allocate that data on heap.
		// But if you use _alloca you don't have to worry about cleaning this memory.  So we will use these
		// temporary variables to allocate memory on heap.  As soon as we exit the function, the memory will
		// be cleaned up, just as if we were using alloca. So now, instead of calling alloca, I'll alloc
		// memory on heap using the two smnart pointers below, and then assing it to the actual pointers.
		CHeapPtr<HROW> spTempRows;
		CHeapPtr<DBROWSTATUS> spTempRowStatus;

		if (pcRows != NULL || cRows != 0)
		{
			if (prgRows != NULL)
				*prgRows = NULL;

			if (prgRowStatus != NULL)
				*prgRowStatus = NULL;
		}
		else
		{
			bIgnore = true;
		}

		if (pcRows != NULL)
		{
			*pcRows = NULL;
			if (prgRows == NULL)
				return E_INVALIDARG;
		}

		if (cRows != 0)
		{
			if (rghRows == NULL)
				return E_INVALIDARG;

			ulRowUpdate = cRows;
		}
		else
			ulRowUpdate = (DBCOUNTITEM)pT->m_rgRowHandles.GetCount();

		// NULL out pointers
		if (prgRows != NULL && ulRowUpdate != 0  && bIgnore == false)
		{
			if (cRows != 0)
				*prgRows = (HROW*)::ATL::AtlCoTaskMemCAlloc(ulRowUpdate, static_cast<ULONG>(sizeof(HROW)));
			else
			{
				spTempRows.Allocate(ulRowUpdate);
				*prgRows = spTempRows;
			}

			if (*prgRows == NULL)
				return E_OUTOFMEMORY;
		}
		else
		{
			if (prgRows != NULL && bIgnore == false)
				*prgRows = NULL;
		}

		if (prgRowStatus != NULL && ulRowUpdate != 0  && bIgnore == false)
		{
			if (cRows != 0)
				*prgRowStatus = (DBROWSTATUS*)::ATL::AtlCoTaskMemCAlloc(ulRowUpdate, static_cast<ULONG>(sizeof(DBROWSTATUS)));
			else
			{
				spTempRowStatus.Allocate(ulRowUpdate);
				*prgRowStatus = spTempRowStatus;
			}

			if (*prgRowStatus == NULL)
			{
				if(prgRows && *prgRows)
				{
					CoTaskMemFree(*prgRows);
					*prgRows = NULL;
				}
				return E_OUTOFMEMORY;
			}
		}
		else
		{
			if (prgRowStatus != NULL && bIgnore == false)
				*prgRowStatus = NULL;
		}

		// NOTE:  If cRows is zero, then we should ignore rghRows and
		// update all of the rows in the cached map.
		RowClass* pRow = NULL;
		POSITION pos = pT->m_rgRowHandles.GetStartPosition();
		for (ULONG ulRow = 0; ulRow < ulRowUpdate; ulRow++)
		{
			void* pData = NULL;
			HROW hRowUpdate = NULL;
			ULONG ulAlreadyProcessed = 0;
			bool bDupRow = false;
			LONG ulCurrentRow = ulCount;

			// Fetch the HROW, RowClass, and Data for the row.  Perform
			// Validation as necessiary
			if (cRows != 0)
			{
				hRowUpdate = rghRows[ulRow];

				for (ULONG ulCheckDup = 0; ulCheckDup < ulRow; ulCheckDup++)
				{
					if (pT->IsSameRow(hRowUpdate, rghRows[ulCheckDup]) == S_OK)
					{
						ulAlreadyProcessed = ulCheckDup;
						bDupRow = true;
						break;
					}
				}
			}
			else
			{
				ATLASSERT(ulRow < (ULONG)pT->m_rgRowHandles.GetCount());
				ATLASSERT( pos != NULL );
				MapClass::CPair* pPair = pT->m_rgRowHandles.GetNext(pos);
				ATLASSERT( pPair != NULL );
				if(!pPair)
				{
					return E_FAIL;
				}
				hRowUpdate = pPair->m_key;
			}

			if (prgRows != NULL && bIgnore == false)
				(*prgRows)[ulCurrentRow] = hRowUpdate;


			if (bDupRow != false)
			{
				// We've already set the row before, just copy status and
				// continue processing
				if (prgRowStatus != NULL && bIgnore == false)
					(*prgRowStatus)[ulCurrentRow] = (*prgRowStatus)[ulAlreadyProcessed];

				ulCount++;
				continue;
			}

			bool bFound = pT->m_rgRowHandles.Lookup(hRowUpdate, pRow);
			if (!bFound || pRow == NULL)
			{
				if (prgRowStatus != NULL  && bIgnore == false)
					(*prgRowStatus)[ulCurrentRow] = DBROWSTATUS_E_INVALID;
				bFailed = true;
				ulCount++;
				continue;
			}

			// If the row is not UNCHANGED, send preliminary notifications before beginning processing
			if( pRow->m_status != 0 &&
				pRow->m_status != DBPENDINGSTATUS_UNCHANGED )
			{
				__if_exists(T::Fire_OnRowChange)
				{

					HRESULT hrNotify = pT->Fire_OnRowChange(pT, 1, &hRowUpdate, DBREASON_ROW_UPDATE,
															DBEVENTPHASE_OKTODO, FALSE);
					if ((hrNotify != S_OK) && (hrNotify != E_FAIL))
					{
						if (prgRowStatus != NULL && bIgnore == false)
							(*prgRowStatus)[ulCurrentRow] = DBROWSTATUS_E_CANCELED;
						bFailed = true;
						continue;
					}

					hrNotify = pT->Fire_OnRowChange(pT, 1, &hRowUpdate, DBREASON_ROW_UPDATE,
															DBEVENTPHASE_ABOUTTODO, FALSE);
					if ((hrNotify != S_OK) && (hrNotify != E_FAIL))
					{
						if (prgRowStatus != NULL && bIgnore == false)
							(*prgRowStatus)[ulCurrentRow] = DBROWSTATUS_E_CANCELED;
						bFailed = true;
						continue;
					}

					hrNotify = pT->Fire_OnRowChange(pT, 1, (HROW*)&hRowUpdate, DBREASON_ROW_UPDATE,
															DBEVENTPHASE_SYNCHAFTER, FALSE);

					if ((hrNotify != S_OK) && (hrNotify != E_FAIL))
					{
						if (prgRowStatus != NULL && bIgnore == false)
							(*prgRowStatus)[ulCurrentRow] = DBROWSTATUS_E_CANCELED;
						bFailed = true;
						continue;
					}
				}
			}

			// If cRows is zero we'll go through all rows fetched.  We
			// shouldn't increment the attempted count for rows that are
			// not changed
			if (cRows != 0 || (pRow != NULL &&
				pRow->m_status !=0 && pRow->m_status != DBPENDINGSTATUS_UNCHANGED
				&& pRow->m_status != DBPENDINGSTATUS_INVALIDROW))
				ulCount++;
			else
				continue;


			switch(pRow->m_status)
			{
			case DBPENDINGSTATUS_INVALIDROW:		// Row is bad or deleted
				__if_exists(T::Fire_OnRowChange)
				{
					pT->Fire_OnRowChange(pT, 1, (HROW*)&hRowUpdate, DBREASON_ROW_UPDATE,
						DBEVENTPHASE_FAILEDTODO, TRUE);
				}
				if (prgRowStatus != NULL && bIgnore == false)
					(*prgRowStatus)[ulCurrentRow] = DBROWSTATUS_E_DELETED;
				bFailed = true;
				continue;
				break;

			case DBPENDINGSTATUS_UNCHANGED:
			case 0:
				// If the row's status is not changed, then just put S_OK
				// and continue.  The spec says we should not transmit the
				// request to the data source (as nothing would change).
				//__if_exists(T::Fire_OnRowChange)
				//{
				//	pT->Fire_OnRowChange(pT, 1, (HROW*)&hRowUpdate, DBREASON_ROW_UPDATE,
				//		DBEVENTPHASE_DIDEVENT, TRUE);
				//}
				if (prgRowStatus != NULL && bIgnore == false)
					(*prgRowStatus)[ulCurrentRow] = DBROWSTATUS_S_OK;
				bSucceeded = true;
				continue;
				break;

			default:
				pData = &pT->m_rgRowData[pRow->m_iRowset];

				if (pData == NULL)
				{
					__if_exists(T::Fire_OnRowChange)
					{
						pT->Fire_OnRowChange(pT, 1, (HROW*)&hRowUpdate, DBREASON_ROW_UPDATE,
							DBEVENTPHASE_FAILEDTODO, TRUE);
					}
					if (prgRowStatus != NULL && bIgnore == false)
						(*prgRowStatus)[ulCurrentRow] = DBROWSTATUS_E_INVALID;
					bFailed = true;
					continue;
				}

				// If the rghRows variable is NULL, we now add the row to
				// prgRows.  We do this because we have determined that the
				// row has changed. AddRef the row as it may not be held by
				// the consumer.
				if (cRows == 0)
					pRow->AddRefRow();

				// Ask the provider if it is OK to change this row.
				DBROWSTATUS status = DBROWSTATUS_S_OK;
				if (FAILED(IsUpdateAllowed(pRow->m_status, hRowUpdate, &status)))
				{
					__if_exists(T::Fire_OnRowChange)
					{
						pT->Fire_OnRowChange(pT, 1, (HROW*)&hRowUpdate, DBREASON_ROW_UPDATE,
							DBEVENTPHASE_FAILEDTODO, TRUE);
					}
					if (prgRowStatus != NULL && bIgnore == false)
						(*prgRowStatus)[ulCurrentRow] = status;
					bFailed = true;
					continue;
				}

				if (pRow->m_status == DBPENDINGSTATUS_DELETED)
				{
					pT->m_rgRowData.RemoveAt(pRow->m_iRowset);
					// Need to update any outstanding pRow->m_iRowset
					// variables
					POSITION posRow = pT->m_rgRowHandles.GetStartPosition();
					while( posRow != NULL )
					{
						MapClass::CPair* pPair = pT->m_rgRowHandles.GetNext(posRow);
						ATLASSERT( pPair != NULL );
						RowClass* pCheckRow = pPair->m_value;
						if (pCheckRow != NULL &&
							pCheckRow->m_iRowset > pRow->m_iRowset)
							pCheckRow->m_iRowset--;
					}

					// Per the specification, deleted rows transmitted
					// to the data source are set to
					// DBPENDINGSTATUS_INVALIDROW
					pRow->m_status = DBPENDINGSTATUS_INVALIDROW;
				}

				// Copy data back
				if (FAILED(pT->FlushData(hRowUpdate, NULL)))
				{
					if (prgRowStatus != NULL && bIgnore == false)
						(*prgRowStatus)[ulCurrentRow] = DBROWSTATUS_E_FAIL;
					__if_exists(T::Fire_OnRowChange)
					{
						pT->Fire_OnRowChange(pT, 1, (HROW*)&hRowUpdate, DBREASON_ROW_UPDATE,
							DBEVENTPHASE_FAILEDTODO, TRUE);
					}
					bFailed = true;
					continue;
				}

				if (prgRowStatus != NULL && bIgnore == false)
					(*prgRowStatus)[ulCurrentRow] = DBROWSTATUS_S_OK;
				bSucceeded = true;

				if (pRow->m_status != DBPENDINGSTATUS_DELETED)
				{
					if (pRow->m_status != DBPENDINGSTATUS_INVALIDROW)
						pRow->m_status = DBPENDINGSTATUS_UNCHANGED;
				}

				// Remove undo buffer.
				if (m_mapCachedData.Lookup(hRowUpdate) != NULL)
					m_mapCachedData.RemoveKey(hRowUpdate);

				// Check if we need to release the row because it's ref was 0
				// See the IRowset::ReleaseRows section in the spec for more
				// information
				if (pRow->m_dwRef == 0)
				{
					pRow->AddRefRow();	// Artifically bump this to remove it
					if( FAILED( pT->RefRows(1, &hRowUpdate, NULL, NULL, false) ) )
						return E_FAIL;
				}

				__if_exists(T::Fire_OnRowChange)
				{
					pT->Fire_OnRowChange(pT, 1, (HROW*)&hRowUpdate, DBREASON_ROW_UPDATE,
						DBEVENTPHASE_DIDEVENT, TRUE);
				}

				break;

			}
		}

		// Set the output for rows undone.
		if (pcRows)
		{
			if( cRows==0 )
				*pcRows = ulCount;
			else
				*pcRows = cRows;
		}

		// In the case where cRows == 0, we need to allocate the final
		// array of HROWs and status values.
		if (cRows == 0)
		{
			HROW* prowTemp;
			DBROWSTATUS* prowStatus;

			if (prgRows != NULL && ulCount != 0 && bIgnore == false)
			{
				prowTemp = (HROW*)::ATL::AtlCoTaskMemCAlloc(ulCount, static_cast<ULONG>(sizeof(HROW)));
				if (prowTemp == NULL)
				{
					if (cRows != 0 && prgRows != NULL)
						CoTaskMemFree(*prgRows);

					if (cRows != 0 && prgRowStatus != NULL)
						CoTaskMemFree(*prgRowStatus);

					return E_OUTOFMEMORY;
				}

				Checked::memcpy_s(prowTemp, sizeof(HROW) * ulCount, *prgRows, sizeof(HROW) * ulCount);
				if (cRows != 0)
					CoTaskMemFree(*prgRows);
				*prgRows = prowTemp;
			}
			else
			{
				if (prgRows != NULL && bIgnore == false)
					*prgRows = NULL;
			}

			if (prgRowStatus != NULL && ulCount != 0 && bIgnore == false)
			{
				prowStatus = (DBROWSTATUS*)::ATL::AtlCoTaskMemCAlloc(ulCount, static_cast<ULONG>(sizeof(DBROWSTATUS)));
				if (prowStatus == NULL)
				{
					if (cRows != 0 && prgRows != NULL)
						CoTaskMemFree(*prgRows);

					if (cRows != 0 && prgRowStatus != NULL)
						CoTaskMemFree(*prgRowStatus);

					return E_OUTOFMEMORY;
				}

				Checked::memcpy_s(prowStatus, sizeof(DBROWSTATUS)*ulCount, *prgRowStatus, sizeof(DBROWSTATUS)*ulCount);
				if (cRows != 0)
					CoTaskMemFree(*prgRowStatus);
				*prgRowStatus = prowStatus;
			}
			else
			{
				if (prgRowStatus != NULL && bIgnore == false)
					*prgRowStatus = NULL;
			}
		}

		// Send the return value
		if (!bFailed)
			return S_OK;
		else
		{
			if (!bSucceeded)
				return DB_E_ERRORSOCCURRED;
			else
				return DB_S_ERRORSOCCURRED;
		}
	}

	// Callback functions
	HRESULT IsUpdateAllowed(
		_In_ DBPENDINGSTATUS /*status*/,
		_In_ HROW /*hRowUpdate*/,
		_In_opt_ DBROWSTATUS* /*pRowStatus*/)
	{
		// If you need to perform any checks for security, integrity
		// violations, etc. as a result of an update, override this
		// method.

		// Make sure you put the appropriate status in the pRowStatus
		// as it will be returned to the user.
		return S_OK;
	}

	// Map containing original data for deferred operation
	CAtlMap<HROW, Storage*> m_mapCachedData;
};

}; //namespace ATL
#pragma pack(pop)
#pragma warning(pop)

#endif //__ATLDB_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\include\atldbsch.h ===
// This is a part of the Active Template Library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Active Template Library Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Active Template Library product.

///////////////////////////////////////////////////////////////////////////
// ATLDBSCH.H : Declarations for OLE DB Schema Rowset Consumer Support
//

#ifndef __ATLDBSCH_H__
#define __ATLDBSCH_H__

#pragma once


#pragma pack(push,_ATL_PACKING)
namespace ATL
{

template <short nRestrictions>
class _CStoreRestrictions
{
public:
	_CStoreRestrictions()
	{
		m_pvarRestrictions = NULL;
		ATLENSURE(m_pvarRestrictions = new CComVariant[nRestrictions]);
	}
	~_CStoreRestrictions()
	{
		delete [] m_pvarRestrictions;
	}
	
ATLPREFAST_SUPPRESS(6387)
	HRESULT GetRowset(
		_Inout_ const CSession& session,
		_In_ const GUID& guidSchema,
		_Deref_out_opt_ IRowset** ppRowset)
	{
		ATLENSURE_RETURN(session.m_spOpenRowset != NULL);
		CComPtr<IDBSchemaRowset> spSchemaRowset;

		HRESULT hr = session.m_spOpenRowset->QueryInterface(__uuidof(IDBSchemaRowset), (void**)&spSchemaRowset);
		if (FAILED(hr))
			return hr;

		return spSchemaRowset->GetRowset(NULL, guidSchema, nRestrictions,
			m_pvarRestrictions, __uuidof(IRowset), 0, NULL, (IUnknown**)ppRowset);
	}
ATLPREFAST_UNSUPPRESS()
	
	CComVariant* m_pvarRestrictions;
};

template <>
class _CStoreRestrictions<0>
{
public:
ATLPREFAST_SUPPRESS(6387)
	HRESULT GetRowset(
		_Inout_ const CSession& session,
		_In_ const GUID& guidSchema,
		_Deref_out_ IRowset** ppRowset)
	{
		ATLENSURE_RETURN(session.m_spOpenRowset != NULL);
		CComPtr<IDBSchemaRowset> spSchemaRowset;

		HRESULT hr = session.m_spOpenRowset->QueryInterface(__uuidof(IDBSchemaRowset), (void**)&spSchemaRowset);
		if (FAILED(hr))
			return hr;
		
		return spSchemaRowset->GetRowset(NULL, guidSchema, 0,
			NULL, __uuidof(IRowset), 0, NULL, (IUnknown**)ppRowset);
	}
ATLPREFAST_UNSUPPRESS()
};
	
///////////////////////////////////////////////////////////////////////////
// class CSchemaRowset
template <class T, short nRestrictions, template <typename T> class TRowset = CRowset>
class CSchemaRowset :
	public CAccessorRowset<T, TRowset>,
	public _CStoreRestrictions<nRestrictions>
{
public:
// Operations
	HRESULT Open(
		_Inout_ const CSession& session,
		_In_ const GUID& guidSchema,
		_In_ bool bBind = true)
	{
		HRESULT hr = GetRowset(session, guidSchema, &m_spRowset);
		if ( SUCCEEDED(hr) && bBind )
			hr = Bind();

		return hr;
	}
};

 ///////////////////////////////////////////////////////////////////////////
// class CRestrictions

template <class T, short nRestrictions, const GUID* pguid>
class CRestrictions : 
	public CSchemaRowset<T, nRestrictions>
{
public:
	HRESULT Open(
		_Inout_ const CSession& session,
		_In_opt_z_ LPCTSTR lpszParam1 = NULL,
		_In_opt_z_ LPCTSTR lpszParam2 = NULL,
		_In_opt_z_ LPCTSTR lpszParam3 = NULL,
		_In_opt_z_ LPCTSTR lpszParam4 = NULL,
		_In_opt_z_ LPCTSTR lpszParam5 = NULL,
		_In_opt_z_ LPCTSTR lpszParam6 = NULL,
		_In_opt_z_ LPCTSTR lpszParam7 = NULL,
		_In_ bool bBind = true)
	{
		USES_CONVERSION_EX;
		CComVariant* pVariant;

		if (m_pvarRestrictions == NULL)
			return E_OUTOFMEMORY;

		if (lpszParam1 != NULL)
		{
			m_pvarRestrictions->vt = VT_BSTR;
			m_pvarRestrictions->bstrVal = ::SysAllocString(T2COLE_EX_DEF(lpszParam1));
			if (m_pvarRestrictions->bstrVal == NULL)
				return E_OUTOFMEMORY;
		}

		if (lpszParam2 != NULL)
		{
			pVariant = m_pvarRestrictions + 1;
			pVariant->vt = VT_BSTR;
			pVariant->bstrVal = ::SysAllocString(T2COLE_EX_DEF(lpszParam2));
			if (pVariant->bstrVal == NULL)
				return E_OUTOFMEMORY;
		}

		if (lpszParam3 != NULL)
		{
			pVariant = m_pvarRestrictions + 2;
			pVariant->vt = VT_BSTR;
			pVariant->bstrVal = ::SysAllocString(T2COLE_EX_DEF(lpszParam3));
			if (pVariant->bstrVal == NULL)
				return E_OUTOFMEMORY;
		}

		if (lpszParam4 != NULL)
		{
			pVariant = m_pvarRestrictions + 3;
			pVariant->vt = VT_BSTR;
			pVariant->bstrVal = ::SysAllocString(T2COLE_EX_DEF(lpszParam4));
			if (pVariant->bstrVal == NULL)
				return E_OUTOFMEMORY;
		}

		if (lpszParam5 != NULL)
		{
			pVariant = m_pvarRestrictions + 4;
			pVariant->vt = VT_BSTR;
			pVariant->bstrVal = ::SysAllocString(T2COLE_EX_DEF(lpszParam5));
			if (pVariant->bstrVal == NULL)
				return E_OUTOFMEMORY;
		}

		if (lpszParam6 != NULL)
		{
			pVariant = m_pvarRestrictions + 5;
			pVariant->vt = VT_BSTR;
			pVariant->bstrVal = ::SysAllocString(T2COLE_EX_DEF(lpszParam6));
			if (pVariant->bstrVal == NULL)
				return E_OUTOFMEMORY;
		}

		if (lpszParam7 != NULL)
		{
			pVariant = m_pvarRestrictions + 6;
			pVariant->vt = VT_BSTR;
			pVariant->bstrVal = ::SysAllocString(T2COLE_EX_DEF(lpszParam7));
			if (pVariant->bstrVal == NULL)
				return E_OUTOFMEMORY;
		}

		return CSchemaRowset<T, nRestrictions>::Open(session, *pguid, bBind);
	}
};


///////////////////////////////////////////////////////////////////////////
// CSchemas

class CSchemas
{
public:
	CSchemas()
	{
		m_nSchemas          = 0;
		m_pSchemaGuids      = NULL;
		m_pulRestrictions   = NULL;
	};

	~CSchemas()
	{
		// Clean up allocated memory
		CoTaskMemFree(m_pSchemaGuids);
		CoTaskMemFree(m_pulRestrictions);
	};

// Operations
	HRESULT GetSchemas(_Inout_ const CSession& session)
	{
		CComPtr<IDBSchemaRowset> spSchemaRowset;
		HRESULT hr;

		ATLENSURE_RETURN(session.m_spOpenRowset != NULL);

		hr = session.m_spOpenRowset->QueryInterface(__uuidof(IDBSchemaRowset),
			(void**)&spSchemaRowset);
		if (FAILED(hr))
			return hr;

		return spSchemaRowset->GetSchemas(&m_nSchemas, &m_pSchemaGuids,
				&m_pulRestrictions);
	};

// Attributes
	ULONG   m_nSchemas;
	LPGUID  m_pSchemaGuids;
	ULONG*  m_pulRestrictions;
};


///////////////////////////////////////////////////////////////////////////
// CAssertionInfo

class CAssertionInfo
{
public:
	CAssertionInfo()
	{
		memset(this, 0, sizeof(*this));
	}

// Attributes
	TCHAR           m_szCatalog[129];
	TCHAR           m_szSchema[129];
	TCHAR           m_szName[129];
	VARIANT_BOOL    m_bIsDeferrable;
	VARIANT_BOOL    m_bInitiallyDeferred;
	TCHAR           m_szDescription[129];

// Binding Map
BEGIN_COLUMN_MAP(CAssertionInfo)
	COLUMN_ENTRY(1, m_szCatalog)
	COLUMN_ENTRY(2, m_szSchema)
	COLUMN_ENTRY(3, m_szName)
	COLUMN_ENTRY(4, m_bIsDeferrable)
	COLUMN_ENTRY(5, m_bInitiallyDeferred)
	COLUMN_ENTRY(6, m_szDescription)
END_COLUMN_MAP()
};


///////////////////////////////////////////////////////////////////////////
// class CCatalogInfo

class CCatalogInfo
{
public:
	CCatalogInfo()
	{
		memset(this, 0, sizeof(*this));
	}

// Attributes
	TCHAR   m_szName[129];
	TCHAR   m_szDescription[129];

// Binding Info
BEGIN_COLUMN_MAP(CCatalogInfo)
	COLUMN_ENTRY(1, m_szName)
	COLUMN_ENTRY(2, m_szDescription)
END_COLUMN_MAP()
};


///////////////////////////////////////////////////////////////////////////
// class CCharacterSetInfo

class CCharacterSetInfo
{
public:
	CCharacterSetInfo()
	{
		memset(this, 0, sizeof(*this));
	}

// Attributes
	TCHAR           m_szCatalog[129];
	TCHAR           m_szSchema[129];
	TCHAR           m_szName[129];
	TCHAR           m_szFormOfUse[129];
	LARGE_INTEGER   m_nNumCharacters;
	TCHAR           m_szCollateCatalog[129];
	TCHAR           m_szCollateSchema[129];
	TCHAR           m_szCollateName[129];

// Binding Info
BEGIN_COLUMN_MAP(CCharacterSetInfo)
	COLUMN_ENTRY(1, m_szCatalog)
	COLUMN_ENTRY(2, m_szSchema)
	COLUMN_ENTRY(3, m_szName)
	COLUMN_ENTRY(4, m_szFormOfUse)
	COLUMN_ENTRY(5, m_nNumCharacters)
	COLUMN_ENTRY(6, m_szCollateCatalog)
	COLUMN_ENTRY(7, m_szCollateSchema)
	COLUMN_ENTRY(8, m_szCollateName)
END_COLUMN_MAP()
};


///////////////////////////////////////////////////////////////////////////
// class CCheckConstraintInfo

class CCheckConstraintInfo
{
public:
	CCheckConstraintInfo()
	{
		memset(this, 0, sizeof(*this));
	}

// Attributes
	TCHAR   m_szCatalog[129];
	TCHAR   m_szSchema[129];
	TCHAR   m_szName[129];
	TCHAR   m_szCheckClause[129];
	TCHAR   m_szDescription[129];

// Binding Maps
BEGIN_COLUMN_MAP(CCheckConstraintInfo)
	COLUMN_ENTRY(1, m_szCatalog)
	COLUMN_ENTRY(2, m_szSchema)
	COLUMN_ENTRY(3, m_szName)
	COLUMN_ENTRY(4, m_szCheckClause)
	COLUMN_ENTRY(5, m_szDescription)
END_COLUMN_MAP()
};


///////////////////////////////////////////////////////////////////////////
// class CCollationInfo

class CCollationInfo
{
public:
// Constructors
	CCollationInfo()
	{
		memset(this, 0, sizeof(*this));
	}

// Attributes
	TCHAR   m_szCatalog[129];
	TCHAR   m_szSchema[129];
	TCHAR   m_szName[129];
	TCHAR   m_szCharSetCatalog[129];
	TCHAR   m_szCharSetSchema[129];
	TCHAR   m_szCharSetName[129];
	TCHAR   m_szPadAttribute[10];

// Binding Maps
BEGIN_COLUMN_MAP(CCollationInfo)
	COLUMN_ENTRY(1, m_szCatalog)
	COLUMN_ENTRY(2, m_szSchema)
	COLUMN_ENTRY(3, m_szName)
	COLUMN_ENTRY(4, m_szCharSetCatalog)
	COLUMN_ENTRY(5, m_szCharSetSchema)
	COLUMN_ENTRY(6, m_szCharSetName)
	COLUMN_ENTRY(7, m_szPadAttribute)
END_COLUMN_MAP()
};


///////////////////////////////////////////////////////////////////////////
// class CColumnDomainUsageInfo

class CColumnDomainUsageInfo
{
public:
// Constructor
	CColumnDomainUsageInfo()
	{
		memset(this, 0, sizeof(*this));
	}

// Attributes
	TCHAR   m_szCatalog[129];
	TCHAR   m_szSchema[129];
	TCHAR   m_szName[129];
	TCHAR   m_szTableCatalog[129];
	TCHAR   m_szTableSchema[129];
	TCHAR   m_szTableName[129];
	TCHAR   m_szColumnName[129];
	GUID    m_guidColumn;
	ULONG   m_nColumnPropID;

// Binding Maps
BEGIN_COLUMN_MAP(CColumnDomainUsageInfo)
	COLUMN_ENTRY(1, m_szCatalog)
	COLUMN_ENTRY(2, m_szSchema)
	COLUMN_ENTRY(3, m_szName)
	COLUMN_ENTRY(4, m_szTableCatalog)
	COLUMN_ENTRY(5, m_szTableSchema)
	COLUMN_ENTRY(6, m_szTableName)
	COLUMN_ENTRY(7, m_szColumnName)
	COLUMN_ENTRY(8, m_guidColumn)
	COLUMN_ENTRY(9, m_nColumnPropID)
END_COLUMN_MAP()
};


///////////////////////////////////////////////////////////////////////////
// class CColumnPrivilegeInfo

class CColumnPrivilegeInfo
{
public:
// Constructor
	CColumnPrivilegeInfo()
	{
		memset(this, 0, sizeof(*this));
	}

// Attributes
	TCHAR           m_szGrantor[129];
	TCHAR           m_szGrantee[129];
	TCHAR           m_szTableCatalog[129];
	TCHAR           m_szTableSchema[129];
	TCHAR           m_szTableName[129];
	TCHAR           m_szColumnName[129];
	GUID            m_guidColumn;
	ULONG           m_nColumnPropID;
	TCHAR           m_szPrivilegeType[20];
	VARIANT_BOOL    m_bIsGrantable;

// Binding Maps
BEGIN_COLUMN_MAP(CColumnPrivilegeInfo)
	COLUMN_ENTRY(1,  m_szGrantor)
	COLUMN_ENTRY(2,  m_szGrantee)
	COLUMN_ENTRY(3,  m_szTableCatalog)
	COLUMN_ENTRY(4,  m_szTableSchema)
	COLUMN_ENTRY(5,  m_szTableName)
	COLUMN_ENTRY(6,  m_szColumnName)
	COLUMN_ENTRY(7,  m_guidColumn)
	COLUMN_ENTRY(8,  m_nColumnPropID)
	COLUMN_ENTRY(9,  m_szPrivilegeType)
	COLUMN_ENTRY(10, m_bIsGrantable)
END_COLUMN_MAP()
};


///////////////////////////////////////////////////////////////////////////
// class CColumnsInfo

class CColumnsInfo
{
public:
// Constructors and Destructors
	CColumnsInfo()
	{
		memset(this, 0, sizeof(*this));
	}

// Operations
	TCHAR           m_szTableCatalog[129];
	TCHAR           m_szTableSchema[129];
	TCHAR           m_szTableName[129];
	TCHAR           m_szColumnName[129];
	GUID            m_guidColumn;
	ULONG           m_nColumnPropID;
	ULONG           m_nOrdinalPosition;
	VARIANT_BOOL    m_bColumnHasDefault;
	TCHAR           m_szColumnDefault[129];
	ULONG           m_nColumnFlags;
	VARIANT_BOOL    m_bIsNullable;
	USHORT          m_nDataType;
	GUID            m_guidType;
	ULONG           m_nMaxLength;
	ULONG           m_nOctetLength;
	USHORT          m_nNumericPrecision;
	SHORT           m_nNumericScale;
	ULONG           m_nDateTimePrecision;
	TCHAR           m_szCharSetCatalog[129];
	TCHAR           m_szCharSetSchema[129];
	TCHAR           m_szCharSetName[129];
	TCHAR           m_szCollationCatalog[129];
	TCHAR           m_szCollationSchema[129];
	TCHAR           m_szCollationName[129];
	TCHAR           m_szDomainCatalog[129];
	TCHAR           m_szDomainSchema[129];
	TCHAR           m_szDomainName[129];
	TCHAR           m_szDescription[129];

BEGIN_COLUMN_MAP(CColumnsInfo)
	COLUMN_ENTRY(1, m_szTableCatalog)
	COLUMN_ENTRY(2, m_szTableSchema)
	COLUMN_ENTRY(3, m_szTableName)
	COLUMN_ENTRY(4, m_szColumnName)
	COLUMN_ENTRY(5, m_guidColumn)
	COLUMN_ENTRY(6, m_nColumnPropID)
	COLUMN_ENTRY(7, m_nOrdinalPosition)
	COLUMN_ENTRY(8, m_bColumnHasDefault)
	COLUMN_ENTRY(9, m_szColumnDefault)
	COLUMN_ENTRY(10, m_nColumnFlags)
	COLUMN_ENTRY(11, m_bIsNullable)
	COLUMN_ENTRY(12, m_nDataType)
	COLUMN_ENTRY(13, m_guidType)
	COLUMN_ENTRY(14, m_nMaxLength)
	COLUMN_ENTRY(15, m_nOctetLength)
	COLUMN_ENTRY(16, m_nNumericPrecision)
	COLUMN_ENTRY(17, m_nNumericScale)
	COLUMN_ENTRY(18, m_nDateTimePrecision)
	COLUMN_ENTRY(19, m_szCharSetCatalog)
	COLUMN_ENTRY(20, m_szCharSetSchema)
	COLUMN_ENTRY(21, m_szCharSetName)
	COLUMN_ENTRY(22, m_szCollationCatalog)
	COLUMN_ENTRY(23, m_szCollationSchema)
	COLUMN_ENTRY(24, m_szCollationName)
	COLUMN_ENTRY(25, m_szDomainCatalog)
	COLUMN_ENTRY(26, m_szDomainSchema)
	COLUMN_ENTRY(27, m_szDomainName)
	COLUMN_ENTRY(28, m_szDescription)
END_COLUMN_MAP()
};


///////////////////////////////////////////////////////////////////////////
// class CConstraintColumnUsageInfo

class CConstraintColumnUsageInfo
{
public:
// Constructor
	CConstraintColumnUsageInfo()
	{
		memset(this, 0, sizeof(*this));
	}

// Attributes
	TCHAR   m_szTableCatalog[129];
	TCHAR   m_szTableSchema[129];
	TCHAR   m_szTableName[129];
	TCHAR   m_szColumnName[129];
	GUID    m_guidColumn;
	ULONG   m_nColumnPropID;
	TCHAR   m_szConstraintCatalog[129];
	TCHAR   m_szConstraintSchema[129];
	TCHAR   m_szConstraintName[129];

// Binding Maps
BEGIN_COLUMN_MAP(CConstraintColumnUsageInfo)
	COLUMN_ENTRY(1, m_szTableCatalog)
	COLUMN_ENTRY(2, m_szTableSchema)
	COLUMN_ENTRY(3, m_szTableName)
	COLUMN_ENTRY(4, m_szColumnName)
	COLUMN_ENTRY(5, m_guidColumn)
	COLUMN_ENTRY(6, m_nColumnPropID)
	COLUMN_ENTRY(7, m_szConstraintCatalog)
	COLUMN_ENTRY(8, m_szConstraintSchema)
	COLUMN_ENTRY(9, m_szConstraintName)
END_COLUMN_MAP()
};

///////////////////////////////////////////////////////////////////////////
// class CConstraintColumnUsageInfo

class CConstraintTableUsageInfo
{
public:
// Constructor
	CConstraintTableUsageInfo()
	{
		memset(this, 0, sizeof(*this));
	}

// Attributes
	TCHAR   m_szTableCatalog[129];
	TCHAR   m_szTableSchema[129];
	TCHAR   m_szTableName[129];
	TCHAR   m_szConstraintCatalog[129];
	TCHAR   m_szConstraintSchema[129];
	TCHAR   m_szConstraintName[129];

// Binding Maps
BEGIN_COLUMN_MAP(CConstraintTableUsageInfo)
	COLUMN_ENTRY(1, m_szTableCatalog)
	COLUMN_ENTRY(2, m_szTableSchema)
	COLUMN_ENTRY(3, m_szTableName)
	COLUMN_ENTRY(4, m_szConstraintCatalog)
	COLUMN_ENTRY(5, m_szConstraintSchema)
	COLUMN_ENTRY(6, m_szConstraintName)
END_COLUMN_MAP()
};

///////////////////////////////////////////////////////////////////////////
// class CForeignKeysInfo

class CForeignKeysInfo
{
public:
// Constructor
	CForeignKeysInfo()
	{
		memset(this, 0, sizeof(*this));
	}

// Attributes
	TCHAR   m_szPKTableCatalog[129];
	TCHAR   m_szPKTableSchema[129];
	TCHAR   m_szPKTableName[129];
	TCHAR   m_szPKColumnName[129];
	GUID    m_guidPKColumn;
	ULONG   m_nPKColumnPropID;
	TCHAR   m_szFKTableCatalog[129];
	TCHAR   m_szFKTableSchema[129];
	TCHAR   m_szFKTableName[129];
	TCHAR   m_szFKColumnName[129];
	GUID    m_guidFKColumn;
	ULONG   m_nFKColumnPropID;
	ULONG   m_nOrdinal;
	TCHAR   m_szUpdateRule[12];
	TCHAR   m_szDeleteRule[12];

// Binding Info
BEGIN_COLUMN_MAP(CForeignKeysInfo)
	COLUMN_ENTRY(1, m_szPKTableCatalog)
	COLUMN_ENTRY(2, m_szPKTableSchema)
	COLUMN_ENTRY(3, m_szPKTableName)
	COLUMN_ENTRY(4, m_szPKColumnName)
	COLUMN_ENTRY(5, m_guidPKColumn)
	COLUMN_ENTRY(6, m_nPKColumnPropID)
	COLUMN_ENTRY(7, m_szFKTableCatalog)
	COLUMN_ENTRY(8, m_szFKTableSchema)
	COLUMN_ENTRY(9, m_szFKTableName)
	COLUMN_ENTRY(10, m_szFKColumnName)
	COLUMN_ENTRY(11, m_guidFKColumn)
	COLUMN_ENTRY(12, m_nFKColumnPropID)
	COLUMN_ENTRY(13, m_nOrdinal)
	COLUMN_ENTRY(14, m_szUpdateRule)
	COLUMN_ENTRY(15, m_szDeleteRule)
END_COLUMN_MAP()
};


///////////////////////////////////////////////////////////////////////////
// class CIndexesInfo

class CIndexesInfo
{
public:
// Constructors
	CIndexesInfo()
	{
		memset(this, 0, sizeof(*this));
	}

// Attributes
	TCHAR           m_szTableCatalog[129];
	TCHAR           m_szTableSchema[129];
	TCHAR           m_szTableName[129];
	TCHAR           m_szIndexCatalog[129];
	TCHAR           m_szIndexSchema[129];
	TCHAR           m_szIndexName[129];
	VARIANT_BOOL    m_bPrimaryKey;
	VARIANT_BOOL    m_bUnique;
	VARIANT_BOOL    m_bClustered;
	USHORT          m_nType;
	LONG            m_nFillFactor;
	LONG            m_nInitialSize;
	LONG            m_nNulls;
	VARIANT_BOOL    m_bSortBookmarks;
	VARIANT_BOOL    m_bAutoUpdate;
	LONG            m_nNullCollation;
	ULONG           m_nOrdinalPosition;
	TCHAR           m_szColumnName[129];
	GUID            m_guidColumn;
	ULONG           m_nColumnPropID;
	SHORT           m_nCollation;
	LONG            m_nCardinality;
	LONG            m_nPages;
	TCHAR           m_szFilterCondition[129];

// Binding Maps
BEGIN_COLUMN_MAP(CIndexesInfo)
	COLUMN_ENTRY(1, m_szTableCatalog)
	COLUMN_ENTRY(2, m_szTableSchema)
	COLUMN_ENTRY(3, m_szTableName)
	COLUMN_ENTRY(4, m_szIndexCatalog)
	COLUMN_ENTRY(5, m_szIndexSchema)
	COLUMN_ENTRY(6, m_szIndexName)
	COLUMN_ENTRY(7, m_bPrimaryKey)
	COLUMN_ENTRY(8, m_bUnique)
	COLUMN_ENTRY(9, m_bClustered)
	COLUMN_ENTRY(10, m_nType)
	COLUMN_ENTRY(11, m_nFillFactor)
	COLUMN_ENTRY(12, m_nInitialSize)
	COLUMN_ENTRY(13, m_nNulls)
	COLUMN_ENTRY(14, m_bSortBookmarks)
	COLUMN_ENTRY(15, m_bAutoUpdate)
	COLUMN_ENTRY(16, m_nNullCollation)
	COLUMN_ENTRY(17, m_nOrdinalPosition)
	COLUMN_ENTRY(18, m_szColumnName)
	COLUMN_ENTRY(19, m_guidColumn)
	COLUMN_ENTRY(20, m_nColumnPropID)
	COLUMN_ENTRY(21, m_nCollation)
	COLUMN_ENTRY(22, m_nCardinality)
	COLUMN_ENTRY(23, m_nPages)
	COLUMN_ENTRY(25, m_szFilterCondition)
END_COLUMN_MAP()
};


///////////////////////////////////////////////////////////////////////////
// class CKeyColumnUsageInfo

class CKeyColumnUsageInfo
{
public:
// Constructors
	CKeyColumnUsageInfo()
	{
		memset(this, 0, sizeof(*this));
	}

// Attributes
	TCHAR   m_szConstraintCatalog[129];
	TCHAR   m_szConstraintSchema[129];
	TCHAR   m_szConstraintName[129];
	TCHAR   m_szTableCatalog[129];
	TCHAR   m_szTableSchema[129];
	TCHAR   m_szTableName[129];
	TCHAR   m_szColumnName[129];
	GUID    m_guidColumn;
	ULONG   m_nColumnPropID;
	ULONG   m_nOrdinalPosition;

// Binding Maps
BEGIN_COLUMN_MAP(CKeyColumnUsageInfo)
	COLUMN_ENTRY(1,  m_szConstraintCatalog)
	COLUMN_ENTRY(2,  m_szConstraintSchema)
	COLUMN_ENTRY(3,  m_szConstraintName)
	COLUMN_ENTRY(4,  m_szTableCatalog)
	COLUMN_ENTRY(5,  m_szTableSchema)
	COLUMN_ENTRY(6,  m_szTableName)
	COLUMN_ENTRY(7,  m_szColumnName)
	COLUMN_ENTRY(8,  m_guidColumn)
	COLUMN_ENTRY(9,  m_nColumnPropID)
	COLUMN_ENTRY(10, m_nOrdinalPosition)
END_COLUMN_MAP()
};


///////////////////////////////////////////////////////////////////////////
// class CPrimaryKeyInfo

class CPrimaryKeyInfo
{
public:
// Constructors
	CPrimaryKeyInfo()
	{
		memset(this, 0, sizeof(*this));
	}

// Attributes
	TCHAR   m_szTableCatalog[129];
	TCHAR   m_szTableSchema[129];
	TCHAR   m_szTableName[129];
	TCHAR   m_szColumnName[129];
	GUID    m_guidColumn;
	ULONG   m_nColumnPropID;
	ULONG   m_nOrdinal;

// Binding Maps
BEGIN_COLUMN_MAP(CPrimaryKeyInfo)
	COLUMN_ENTRY(1, m_szTableCatalog)
	COLUMN_ENTRY(2, m_szTableSchema)
	COLUMN_ENTRY(3, m_szTableName)
	COLUMN_ENTRY(4, m_szColumnName)
	COLUMN_ENTRY(5, m_guidColumn)
	COLUMN_ENTRY(6, m_nColumnPropID)
	COLUMN_ENTRY(7, m_nOrdinal)
END_COLUMN_MAP()
};


///////////////////////////////////////////////////////////////////////////
// class CProcedureColumnInfo

class CProcedureColumnInfo
{
public:
// Constructors
	CProcedureColumnInfo()
	{
		memset(this, 0, sizeof(*this));
	}

// Attributes
	TCHAR           m_szCatalog[129];
	TCHAR           m_szSchema[129];
	TCHAR           m_szName[129];
	TCHAR           m_szColumnName[129];
	GUID            m_guidColumn;
	ULONG           m_nColumnPropID;
	ULONG           m_nRowsetNumber;
	ULONG           m_nOrdinalPosition;
	VARIANT_BOOL    m_bIsNullable;
	USHORT          m_nDataType;
	GUID            m_guidType;
	ULONG           m_nMaxLength;
	ULONG           m_nOctetLength;
	USHORT          m_nPrecision;
	SHORT           m_nScale;
	TCHAR           m_szDescription[129];

// Binding Maps
BEGIN_COLUMN_MAP(CProcedureColumnInfo)
	COLUMN_ENTRY(1,  m_szCatalog)
	COLUMN_ENTRY(2,  m_szSchema)
	COLUMN_ENTRY(3,  m_szName)
	COLUMN_ENTRY(4,  m_szColumnName)
	COLUMN_ENTRY(5,  m_guidColumn)
	COLUMN_ENTRY(6,  m_nColumnPropID)
	COLUMN_ENTRY(7,  m_nRowsetNumber)
	COLUMN_ENTRY(8,  m_nOrdinalPosition)
	COLUMN_ENTRY(9,  m_bIsNullable)
	COLUMN_ENTRY(10, m_nDataType)
	COLUMN_ENTRY(11, m_guidType)
	COLUMN_ENTRY(12, m_nMaxLength)
	COLUMN_ENTRY(13, m_nOctetLength)
	COLUMN_ENTRY(14, m_nPrecision)
	COLUMN_ENTRY(15, m_nScale)
	COLUMN_ENTRY(16, m_szDescription)
END_COLUMN_MAP()
};


///////////////////////////////////////////////////////////////////////////
// class CProcedureParameterInfo

class CProcedureParameterInfo
{
public:
// Constructors
	CProcedureParameterInfo()
	{
		memset(this, 0, sizeof(*this));
	}

// Attributes
	TCHAR           m_szCatalog[129];
	TCHAR           m_szSchema[129];
	TCHAR           m_szName[129];
	TCHAR           m_szParameterName[129];
	USHORT          m_nOrdinalPosition;
	USHORT          m_nType;
	VARIANT_BOOL    m_bHasDefault;
	TCHAR           m_szDefault[129];
	VARIANT_BOOL    m_bIsNullable;
	USHORT          m_nDataType;
	ULONG           m_nMaxLength;
	ULONG           m_nOctetLength;
	USHORT          m_nPrecision;
	SHORT           m_nScale;
	TCHAR           m_szDescription[129];

// Binding Maps
BEGIN_COLUMN_MAP(CProcedureParameterInfo)
	COLUMN_ENTRY(1, m_szCatalog)
	COLUMN_ENTRY(2, m_szSchema)
	COLUMN_ENTRY(3, m_szName)
	COLUMN_ENTRY(4, m_szParameterName)
	COLUMN_ENTRY(5, m_nOrdinalPosition)
	COLUMN_ENTRY(6, m_nType)
	COLUMN_ENTRY(7, m_bHasDefault)
	COLUMN_ENTRY(8, m_szDefault)
	COLUMN_ENTRY(9, m_bIsNullable)
	COLUMN_ENTRY(10, m_nDataType)
	COLUMN_ENTRY(11, m_nMaxLength)
	COLUMN_ENTRY(12, m_nOctetLength)
	COLUMN_ENTRY(13, m_nPrecision)
	COLUMN_ENTRY(14, m_nScale)
	COLUMN_ENTRY(15, m_szDescription)
END_COLUMN_MAP()
};


///////////////////////////////////////////////////////////////////////////
// class CProcedureInfo

class CProcedureInfo
{
public:
// Constructors
	CProcedureInfo()
	{
		memset(this, 0, sizeof(*this));
	}

// Attributes
	TCHAR   m_szCatalog[129];
	TCHAR   m_szSchema[129];
	TCHAR   m_szName[129];
	SHORT   m_nType;
	TCHAR   m_szDefinition[129];
	TCHAR   m_szDescription[129];

// Binding Maps
BEGIN_COLUMN_MAP(CProcedureInfo)
	COLUMN_ENTRY(1, m_szCatalog)
	COLUMN_ENTRY(2, m_szSchema)
	COLUMN_ENTRY(3, m_szName)
	COLUMN_ENTRY(4, m_nType)
	COLUMN_ENTRY(5, m_szDefinition)
	COLUMN_ENTRY(6, m_szDescription)
END_COLUMN_MAP()
};


///////////////////////////////////////////////////////////////////////////
// class CProviderTypeInfo

class CProviderTypeInfo
{
public:
// Constructors
	CProviderTypeInfo()
	{
		memset(this, 0, sizeof(*this));
	}

// Attributes
	TCHAR           m_szTypeName[129];
	USHORT          m_nDataType;
	ULONG           m_nColumnSize;
	TCHAR           m_szLiteralPrefix[129];
	TCHAR           m_szLiteralSuffix[129];
	TCHAR           m_szCreateParams[129];
	VARIANT_BOOL    m_bIsNullable;
	VARIANT_BOOL    m_bCaseSensitive;
	ULONG           m_nSearchable;
	VARIANT_BOOL    m_bUnsignedAttribute;
	VARIANT_BOOL    m_bFixedPrecScale;
	VARIANT_BOOL    m_bAutoUniqueValue;
	TCHAR           m_szLocalTypeName[129];
	SHORT           m_nMinScale;
	SHORT           m_nMaxScale;
	GUID            m_guidType;
	TCHAR           m_szTypeLib[129];
	TCHAR           m_szVersion[129];
	VARIANT_BOOL    m_bIsLong;
	VARIANT_BOOL    m_bBestMatch;
	VARIANT_BOOL    m_bIsFixedLength;

// Binding Maps
BEGIN_COLUMN_MAP(CProviderTypeInfo)
	COLUMN_ENTRY(1, m_szTypeName)
	COLUMN_ENTRY(2, m_nDataType)
	COLUMN_ENTRY(3, m_nColumnSize)
	COLUMN_ENTRY(4, m_szLiteralPrefix)
	COLUMN_ENTRY(5, m_szLiteralSuffix)
	COLUMN_ENTRY(6, m_szCreateParams)
	COLUMN_ENTRY(7, m_bIsNullable)
	COLUMN_ENTRY(8, m_bCaseSensitive)
	COLUMN_ENTRY(9, m_nSearchable)
	COLUMN_ENTRY(10, m_bUnsignedAttribute)
	COLUMN_ENTRY(11, m_bFixedPrecScale)
	COLUMN_ENTRY(12, m_bAutoUniqueValue)
	COLUMN_ENTRY(13, m_szLocalTypeName)
	COLUMN_ENTRY(14, m_nMinScale)
	COLUMN_ENTRY(15, m_nMaxScale)
	COLUMN_ENTRY(16, m_guidType)
	COLUMN_ENTRY(17, m_szTypeLib)
	COLUMN_ENTRY(18, m_szVersion)
	COLUMN_ENTRY(19, m_bIsLong)
	COLUMN_ENTRY(20, m_bBestMatch)
	COLUMN_ENTRY(21, m_bIsFixedLength)
END_COLUMN_MAP()
};


///////////////////////////////////////////////////////////////////////////
// class CReferentialConstraintInfo

class CReferentialConstraintInfo
{
public:
// Constructors
	CReferentialConstraintInfo()
	{
		memset(this, 0, sizeof(*this));
	}

// Attributes
	TCHAR   m_szCatalog[129];
	TCHAR   m_szSchema[129];
	TCHAR   m_szName[129];
	TCHAR   m_szUniqueCatalog[129];
	TCHAR   m_szUniqueSchema[129];
	TCHAR   m_szUniqueName[129];
	TCHAR   m_szMatchOption[8];
	TCHAR   m_szUpdateRule[12];
	TCHAR   m_szDeleteRule[12];
	TCHAR   m_szDescription[129];

// Binding Maps
BEGIN_COLUMN_MAP(CReferentialConstraintInfo)
	COLUMN_ENTRY(1,  m_szCatalog)
	COLUMN_ENTRY(2,  m_szSchema)
	COLUMN_ENTRY(3,  m_szName)
	COLUMN_ENTRY(4,  m_szUniqueCatalog)
	COLUMN_ENTRY(5,  m_szUniqueSchema)
	COLUMN_ENTRY(6,  m_szUniqueName)
	COLUMN_ENTRY(7,  m_szMatchOption)
	COLUMN_ENTRY(8,  m_szUpdateRule)
	COLUMN_ENTRY(9,  m_szDeleteRule)
	COLUMN_ENTRY(10, m_szDescription)
END_COLUMN_MAP()
};


///////////////////////////////////////////////////////////////////////////
// class CSchemataInfo

class CSchemataInfo
{
public:
// Constructors
	CSchemataInfo()
	{
		memset(this, 0, sizeof(*this));
	}

// Attributes
	TCHAR   m_szCatalog[129];
	TCHAR   m_szName[129];
	TCHAR   m_szOwner[129];
	TCHAR   m_szCharCatalog[129];
	TCHAR   m_szCharSchema[129];
	TCHAR   m_szCharName[129];

// Binding Maps
BEGIN_COLUMN_MAP(CSchemataInfo)
	COLUMN_ENTRY(1, m_szCatalog)
	COLUMN_ENTRY(2, m_szName)
	COLUMN_ENTRY(3, m_szOwner)
	COLUMN_ENTRY(4, m_szCharCatalog)
	COLUMN_ENTRY(5, m_szCharSchema)
	COLUMN_ENTRY(6, m_szCharName)
END_COLUMN_MAP()
};


///////////////////////////////////////////////////////////////////////////
// class CSQLLangugageInfo

class CSQLLanguageInfo
{
public:
// Constructors
	CSQLLanguageInfo()
	{
		memset(this, 0, sizeof(*this));
	}

// Attributes
	TCHAR   m_szSource[10];
	TCHAR   m_szYear[5];
	TCHAR   m_szConformance[13];
	TCHAR   m_szIntegrity[4];
	TCHAR   m_szImplementation[24];
	TCHAR   m_szBindingStyle[10];
	TCHAR   m_szProgrammingLanguage[10];

// Binding Maps
BEGIN_COLUMN_MAP(CSQLLanguageInfo)
	COLUMN_ENTRY(1, m_szSource)
	COLUMN_ENTRY(2, m_szYear)
	COLUMN_ENTRY(3, m_szConformance)
	COLUMN_ENTRY(4, m_szIntegrity)
	COLUMN_ENTRY(5, m_szImplementation)
	COLUMN_ENTRY(6, m_szBindingStyle)
	COLUMN_ENTRY(7, m_szProgrammingLanguage)
END_COLUMN_MAP()
};


///////////////////////////////////////////////////////////////////////////
// class CStatisticInfo

class CStatisticInfo
{
public:
// Constructors
	CStatisticInfo()
	{
		memset(this, 0, sizeof(*this));
	}

// Attributes
	TCHAR   m_szTableCatalog[129];
	TCHAR   m_szTableSchema[129];
	TCHAR   m_szTableName[129];
	LONG    m_nCardinality;

// Binding Maps
BEGIN_COLUMN_MAP(CStatisticInfo)
	COLUMN_ENTRY(1, m_szTableCatalog)
	COLUMN_ENTRY(2, m_szTableSchema)
	COLUMN_ENTRY(3, m_szTableName)
	COLUMN_ENTRY(4, m_nCardinality)
END_COLUMN_MAP()
};


///////////////////////////////////////////////////////////////////////////
// class CTableConstraintInfo

class CTableConstraintInfo
{
public:
// Constructors
	CTableConstraintInfo()
	{
		memset(this, 0, sizeof(*this));
	}

// Attributes
	TCHAR           m_szCatalog[129];
	TCHAR           m_szSchema[129];
	TCHAR           m_szName[129];
	TCHAR           m_szTableCatalog[129];
	TCHAR           m_szTableSchema[129];
	TCHAR           m_szTableName[129];
	TCHAR           m_szType[12];
	VARIANT_BOOL    m_bIsDeferrable;
	VARIANT_BOOL    m_bInitiallyDeferred;
	TCHAR           m_szDescription[129];

// Binding Maps
BEGIN_COLUMN_MAP(CTableConstraintInfo)
	COLUMN_ENTRY(1,  m_szCatalog)
	COLUMN_ENTRY(2,  m_szSchema)
	COLUMN_ENTRY(3,  m_szName)
	COLUMN_ENTRY(4,  m_szTableCatalog)
	COLUMN_ENTRY(5,  m_szTableSchema)
	COLUMN_ENTRY(6,  m_szTableName)
	COLUMN_ENTRY(7,  m_szType)
	COLUMN_ENTRY(8,  m_bIsDeferrable)
	COLUMN_ENTRY(9,  m_bInitiallyDeferred)
	COLUMN_ENTRY(10, m_szDescription)
END_COLUMN_MAP()
};


///////////////////////////////////////////////////////////////////////////
// class CTablePrivilegeInfo

class CTablePrivilegeInfo
{
public:
// Constructors
	CTablePrivilegeInfo()
	{
		memset(this, 0, sizeof(*this));
	}

// Attributes
	TCHAR           m_szGrantor[129];
	TCHAR           m_szGrantee[129];
	TCHAR           m_szCatalog[129];
	TCHAR           m_szSchema[129];
	TCHAR           m_szName[129];
	TCHAR           m_szType[12];
	VARIANT_BOOL    m_bIsGrantable;

// Binding Maps
BEGIN_COLUMN_MAP(CTablePrivilegeInfo)
	COLUMN_ENTRY(1, m_szGrantor)
	COLUMN_ENTRY(2, m_szGrantee)
	COLUMN_ENTRY(3, m_szCatalog)
	COLUMN_ENTRY(4, m_szSchema)
	COLUMN_ENTRY(5, m_szName)
	COLUMN_ENTRY(6, m_szType)
	COLUMN_ENTRY(7, m_bIsGrantable)
END_COLUMN_MAP()
};



///////////////////////////////////////////////////////////////////////////
// class CTableInfo

class CTableInfo
{
public:
// Constructors
	CTableInfo()
	{
		memset(this, 0, sizeof(*this));
	}

// Attributes
	TCHAR   m_szCatalog[129];
	TCHAR   m_szSchema[129];
	TCHAR   m_szName[129];
	TCHAR   m_szType[129];
	GUID    m_guidTable;
	TCHAR   m_szDescription[129];


// Binding Map
BEGIN_COLUMN_MAP(CTableInfo)
	COLUMN_ENTRY(1, m_szCatalog)
	COLUMN_ENTRY(2, m_szSchema)
	COLUMN_ENTRY(3, m_szName)
	COLUMN_ENTRY(4, m_szType)
	COLUMN_ENTRY(5, m_guidTable)
	COLUMN_ENTRY(6, m_szDescription)
END_COLUMN_MAP()
};


///////////////////////////////////////////////////////////////////////////
// class CTranslationInfo

class CTranslationInfo
{
public:
// Constructors
	CTranslationInfo()
	{
		memset(this, 0, sizeof(*this));
	}

// Attributes
	TCHAR   m_szCatalog[129];
	TCHAR   m_szSchema[129];
	TCHAR   m_szName[129];
	TCHAR   m_szSourceCatalog[129];
	TCHAR   m_szSourceSchema[129];
	TCHAR   m_szSourceName[129];
	TCHAR   m_szTargetCatalog[129];
	TCHAR   m_szTargetSchema[129];
	TCHAR   m_szTargetName[129];

// Binding Maps
BEGIN_COLUMN_MAP(CTranslationInfo)
	COLUMN_ENTRY(1, m_szCatalog)
	COLUMN_ENTRY(2, m_szSchema)
	COLUMN_ENTRY(3, m_szName)
	COLUMN_ENTRY(4, m_szSourceCatalog)
	COLUMN_ENTRY(5, m_szSourceSchema)
	COLUMN_ENTRY(6, m_szSourceName)
	COLUMN_ENTRY(7, m_szTargetCatalog)
	COLUMN_ENTRY(8, m_szTargetSchema)
	COLUMN_ENTRY(9, m_szTargetName)
END_COLUMN_MAP()
};


///////////////////////////////////////////////////////////////////////////
// class CUsagePrivilegeInfo

class CUsagePrivilegeInfo
{
public:
// Constructors
	CUsagePrivilegeInfo()
	{
		memset(this, 0, sizeof(*this));
	}

// Attributes
	TCHAR   m_szGrantor[129];
	TCHAR   m_szGrantee[129];
	TCHAR   m_szObjectCatalog[129];
	TCHAR   m_szObjectSchema[129];
	TCHAR   m_szObjectName[129];
	TCHAR   m_szObjectType[12];
	TCHAR   m_szPrivilegeType[6];
	VARIANT_BOOL    m_bIsGrantable;

// Binding Maps
BEGIN_COLUMN_MAP(CUsagePrivilegeInfo)
	COLUMN_ENTRY(1, m_szGrantor)
	COLUMN_ENTRY(2, m_szGrantee)
	COLUMN_ENTRY(3, m_szObjectCatalog)
	COLUMN_ENTRY(4, m_szObjectSchema)
	COLUMN_ENTRY(5, m_szObjectName)
	COLUMN_ENTRY(6, m_szObjectType)
	COLUMN_ENTRY(7, m_szPrivilegeType)
	COLUMN_ENTRY(8, m_bIsGrantable)
END_COLUMN_MAP()
};


///////////////////////////////////////////////////////////////////////////
// class CViewColumnUsageInfo

class CViewColumnUsageInfo
{
public:
// Constructors
	CViewColumnUsageInfo()
	{
		memset(this, 0, sizeof(*this));
	}

// Attributes
	TCHAR   m_szCatalog[129];
	TCHAR   m_szSchema[129];
	TCHAR   m_szName[129];
	TCHAR   m_szTableCatalog[129];
	TCHAR   m_szTableSchema[129];
	TCHAR   m_szTableName[129];
	TCHAR   m_szColumnName[129];
	GUID    m_guidColumn;
	ULONG   m_nColumnPropID;

// Binding Maps
BEGIN_COLUMN_MAP(CViewColumnUsageInfo)
	COLUMN_ENTRY(1, m_szCatalog)
	COLUMN_ENTRY(2, m_szSchema)
	COLUMN_ENTRY(3, m_szName)
	COLUMN_ENTRY(4, m_szTableCatalog)
	COLUMN_ENTRY(5, m_szTableSchema)
	COLUMN_ENTRY(6, m_szTableName)
	COLUMN_ENTRY(7, m_szColumnName)
	COLUMN_ENTRY(8, m_guidColumn)
	COLUMN_ENTRY(9, m_nColumnPropID)
END_COLUMN_MAP()
};


///////////////////////////////////////////////////////////////////////////
// class CViewTableUsageInfo

class CViewTableUsageInfo
{
public:
// Constructors
	CViewTableUsageInfo()
	{
		memset(this, 0, sizeof(*this));
	}

// Attributes
	TCHAR   m_szCatalog[129];
	TCHAR   m_szSchema[129];
	TCHAR   m_szName[129];
	TCHAR   m_szTableCatalog[129];
	TCHAR   m_szTableSchema[129];
	TCHAR   m_szTableName[129];

// Binding Maps
BEGIN_COLUMN_MAP(CViewTableUsageInfo)
	COLUMN_ENTRY(1, m_szCatalog)
	COLUMN_ENTRY(2, m_szSchema)
	COLUMN_ENTRY(3, m_szName)
	COLUMN_ENTRY(4, m_szTableCatalog)
	COLUMN_ENTRY(5, m_szTableSchema)
	COLUMN_ENTRY(6, m_szTableName)
END_COLUMN_MAP()
};


///////////////////////////////////////////////////////////////////////////
// class CViewInfo

class CViewInfo
{
public:
// Constructors
	CViewInfo()
	{
		memset(this, 0, sizeof(*this));
	}

// Attributes
	TCHAR           m_szTableCatalog[129];
	TCHAR           m_szTableSchema[129];
	TCHAR           m_szTableName[129];
	TCHAR           m_szDefinition[129];
	VARIANT_BOOL    m_bCheckOption;
	VARIANT_BOOL    m_bIsUpdatable;
	TCHAR           m_szDescription[129];

// Binding Maps
BEGIN_COLUMN_MAP(CViewInfo)
	COLUMN_ENTRY(1, m_szTableCatalog)
	COLUMN_ENTRY(2, m_szTableSchema)
	COLUMN_ENTRY(3, m_szTableName)
	COLUMN_ENTRY(4, m_szDefinition)
	COLUMN_ENTRY(5, m_bCheckOption)
	COLUMN_ENTRY(6, m_bIsUpdatable)
	COLUMN_ENTRY(7, m_szDescription)
END_COLUMN_MAP()
};


///////////////////////////////////////////////////////////////////////////
// typedefs

typedef CRestrictions<CAccessor<CAssertionInfo>,            3, &DBSCHEMA_ASSERTIONS>                CAssertions;
typedef CRestrictions<CAccessor<CCatalogInfo>,              1, &DBSCHEMA_CATALOGS >                 CCatalogs;
typedef CRestrictions<CAccessor<CCharacterSetInfo>,         3, &DBSCHEMA_CHARACTER_SETS>            CCharacterSets;
typedef CRestrictions<CAccessor<CCheckConstraintInfo>,      3, &DBSCHEMA_CHECK_CONSTRAINTS>         CCheckConstraints;
typedef CRestrictions<CAccessor<CCollationInfo>,            3, &DBSCHEMA_COLLATIONS>                CCollations;
typedef CRestrictions<CAccessor<CColumnDomainUsageInfo>,    4, &DBSCHEMA_COLUMN_DOMAIN_USAGE>       CColumnDomainUsage;
typedef CRestrictions<CAccessor<CColumnPrivilegeInfo>,      6, &DBSCHEMA_COLUMN_PRIVILEGES>         CColumnPrivileges;
typedef CRestrictions<CAccessor<CColumnsInfo>,              4, &DBSCHEMA_COLUMNS>                   CColumns;
typedef CRestrictions<CAccessor<CConstraintColumnUsageInfo>,4, &DBSCHEMA_CONSTRAINT_COLUMN_USAGE>   CConstraintColumnUsage;
typedef CRestrictions<CAccessor<CConstraintTableUsageInfo>, 3, &DBSCHEMA_CONSTRAINT_TABLE_USAGE>    CConstraintTableUsage;
typedef CRestrictions<CAccessor<CForeignKeysInfo>,          6, &DBSCHEMA_FOREIGN_KEYS>              CForeignKeys;
typedef CRestrictions<CAccessor<CIndexesInfo>,              5, &DBSCHEMA_INDEXES>                   CIndexes;
typedef CRestrictions<CAccessor<CKeyColumnUsageInfo>,       7, &DBSCHEMA_KEY_COLUMN_USAGE>          CKeyColumnUsage;
typedef CRestrictions<CAccessor<CPrimaryKeyInfo>,           3, &DBSCHEMA_PRIMARY_KEYS>              CPrimaryKeys;
typedef CRestrictions<CAccessor<CProcedureColumnInfo>,      4, &DBSCHEMA_PROCEDURE_COLUMNS>         CProcedureColumns;
typedef CRestrictions<CAccessor<CProcedureParameterInfo>,   4, &DBSCHEMA_PROCEDURE_PARAMETERS>      CProcedureParameters;
typedef CRestrictions<CAccessor<CProcedureInfo>,            4, &DBSCHEMA_PROCEDURES>                CProcedures;
typedef CRestrictions<CAccessor<CProviderTypeInfo>,         2, &DBSCHEMA_PROVIDER_TYPES>            CProviderTypes;
typedef CRestrictions<CAccessor<CReferentialConstraintInfo>,3, &DBSCHEMA_REFERENTIAL_CONSTRAINTS>   CReferentialConstraints;
typedef CRestrictions<CAccessor<CSchemataInfo>,             3, &DBSCHEMA_SCHEMATA>                  CSchemata;
typedef CRestrictions<CAccessor<CSQLLanguageInfo>,          0, &DBSCHEMA_SQL_LANGUAGES>             CSQLLanguages;
typedef CRestrictions<CAccessor<CStatisticInfo>,            3, &DBSCHEMA_STATISTICS>                CStatistics ;
typedef CRestrictions<CAccessor<CTableConstraintInfo>,      7, &DBSCHEMA_TABLE_CONSTRAINTS>         CTableConstraints;
typedef CRestrictions<CAccessor<CTablePrivilegeInfo>,       5, &DBSCHEMA_TABLE_PRIVILEGES>          CTablePrivileges;
typedef CRestrictions<CAccessor<CTableInfo>,                4, &DBSCHEMA_TABLES>                    CTables;
typedef CRestrictions<CAccessor<CTranslationInfo>,          3, &DBSCHEMA_TRANSLATIONS>              CTranslations;
typedef CRestrictions<CAccessor<CUsagePrivilegeInfo>,       6, &DBSCHEMA_USAGE_PRIVILEGES>          CUsagePrivileges;
typedef CRestrictions<CAccessor<CViewColumnUsageInfo>,      3, &DBSCHEMA_VIEW_COLUMN_USAGE>         CViewColumnUsage;
typedef CRestrictions<CAccessor<CViewTableUsageInfo>,       3, &DBSCHEMA_VIEW_TABLE_USAGE>          CViewTableUsage;
typedef CRestrictions<CAccessor<CViewInfo>,                 3, &DBSCHEMA_VIEWS>                     CViews;

///////////////////////////////////////////////////////////////////////////

}; //namespace ATL

#pragma pack(pop)
#endif // __ATLDBSCH_H__

///////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\include\atldbcli.h ===
// This is a part of the Active Template Library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Active Template Library Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Active Template Library product.

// ATLDBCLI.H : ATL consumer code for OLEDB

#ifndef __ATLDBCLI_H__
#define __ATLDBCLI_H__

#pragma once

#ifndef __cplusplus
	#error ATL requires C++ compilation (use a .cpp suffix)
#endif

#ifndef __ATLBASE_H__
#include <atlbase.h>
#endif

#include <atlsimpstr.h>

#ifndef __oledb_h__
#include <oledb.h>
#endif // __oledb_h__

#include <oledberr.h>
#include <msdaguid.h>
#include <msdasc.h>

#pragma warning(push)

#pragma warning(disable: 4244)
#pragma warning(disable: 4127)  // conditional expression constant

#ifndef _CPPUNWIND
#pragma warning(disable: 4702) // unreachable code
#endif


#pragma pack(push,_ATL_PACKING)
namespace ATL
{

#define DEFINE_OLEDB_TYPE_FUNCTION(ctype, oledbtype) \
	inline DBTYPE _GetOleDBType(_In_ ctype&) throw ()\
	{ \
		return oledbtype; \
	}
	inline DBTYPE _GetOleDBType(_In_ BYTE[]) throw ()
	{
		return DBTYPE_BYTES;
	}
	inline DBTYPE _GetOleDBType(_In_ CHAR[]) throw ()
	{
		return DBTYPE_STR;
	}
	inline DBTYPE _GetOleDBType(_In_ WCHAR[]) throw()
	{
		return DBTYPE_WSTR;
	}

	DEFINE_OLEDB_TYPE_FUNCTION(const WCHAR*, DBTYPE_WSTR | DBTYPE_BYREF)
	DEFINE_OLEDB_TYPE_FUNCTION(const CHAR*, DBTYPE_STR | DBTYPE_BYREF)

	DEFINE_OLEDB_TYPE_FUNCTION(CComBSTR, DBTYPE_BSTR)

	//DEFINE_OLEDB_TYPE_FUNCTION(__int8, DBTYPE_I1)
	//DEFINE_OLEDB_TYPE_FUNCTION(__int16, DBTYPE_I2)
	//DEFINE_OLEDB_TYPE_FUNCTION(__int32, DBTYPE_I4)
	DEFINE_OLEDB_TYPE_FUNCTION(__int64, DBTYPE_I8)
	//DEFINE_OLEDB_TYPE_FUNCTION(unsigned __int8, DBTYPE_UI1)
	//DEFINE_OLEDB_TYPE_FUNCTION(unsigned __int16, DBTYPE_UI2)
	//DEFINE_OLEDB_TYPE_FUNCTION(unsigned __int32, DBTYPE_UI4)
	DEFINE_OLEDB_TYPE_FUNCTION(unsigned __int64, DBTYPE_UI8)

	DEFINE_OLEDB_TYPE_FUNCTION(signed char      ,DBTYPE_I1)
	DEFINE_OLEDB_TYPE_FUNCTION(SHORT            ,DBTYPE_I2)     // DBTYPE_BOOL
	DEFINE_OLEDB_TYPE_FUNCTION(int              ,DBTYPE_I4)
	DEFINE_OLEDB_TYPE_FUNCTION(LONG             ,DBTYPE_I4)     // DBTYPE_ERROR (SCODE)
	DEFINE_OLEDB_TYPE_FUNCTION(LARGE_INTEGER    ,DBTYPE_I8)     // DBTYPE_CY
	DEFINE_OLEDB_TYPE_FUNCTION(CURRENCY		    ,DBTYPE_CY)     // DBTYPE_CY
	DEFINE_OLEDB_TYPE_FUNCTION(BYTE             ,DBTYPE_UI1)
	DEFINE_OLEDB_TYPE_FUNCTION(unsigned short   ,DBTYPE_UI2)
	DEFINE_OLEDB_TYPE_FUNCTION(unsigned int     ,DBTYPE_UI4)
	DEFINE_OLEDB_TYPE_FUNCTION(unsigned long    ,DBTYPE_UI4)
	DEFINE_OLEDB_TYPE_FUNCTION(ULARGE_INTEGER   ,DBTYPE_UI8)
	DEFINE_OLEDB_TYPE_FUNCTION(float            ,DBTYPE_R4)
	DEFINE_OLEDB_TYPE_FUNCTION(double           ,DBTYPE_R8)     // DBTYPE_DATE
	DEFINE_OLEDB_TYPE_FUNCTION(DECIMAL          ,DBTYPE_DECIMAL)
	DEFINE_OLEDB_TYPE_FUNCTION(DB_NUMERIC       ,DBTYPE_NUMERIC)
	DEFINE_OLEDB_TYPE_FUNCTION(VARIANT          ,DBTYPE_VARIANT)
	DEFINE_OLEDB_TYPE_FUNCTION(IDispatch*       ,DBTYPE_IDISPATCH)
	DEFINE_OLEDB_TYPE_FUNCTION(IUnknown*        ,DBTYPE_IUNKNOWN)
	DEFINE_OLEDB_TYPE_FUNCTION(GUID             ,DBTYPE_GUID)
	DEFINE_OLEDB_TYPE_FUNCTION(SAFEARRAY*       ,DBTYPE_ARRAY)
	DEFINE_OLEDB_TYPE_FUNCTION(DBVECTOR         ,DBTYPE_VECTOR)
	DEFINE_OLEDB_TYPE_FUNCTION(DBDATE           ,DBTYPE_DBDATE)
	DEFINE_OLEDB_TYPE_FUNCTION(DBTIME           ,DBTYPE_DBTIME)
	DEFINE_OLEDB_TYPE_FUNCTION(DBTIMESTAMP      ,DBTYPE_DBTIMESTAMP)
 	DEFINE_OLEDB_TYPE_FUNCTION(FILETIME			,DBTYPE_FILETIME)
	DEFINE_OLEDB_TYPE_FUNCTION(PROPVARIANT		,DBTYPE_PROPVARIANT)
	DEFINE_OLEDB_TYPE_FUNCTION(DB_VARNUMERIC	,DBTYPE_VARNUMERIC)

// Internal structure containing the accessor handle and a flag
// indicating whether the data for the accessor is automatically
// retrieved
struct _ATL_ACCESSOR_INFO
{
	HACCESSOR   hAccessor;
	bool        bAutoAccessor;
};

class _CNoOutputColumns
{
public:
	static bool HasOutputColumns() throw ()
	{
		return false;
	}
	static ULONG _GetNumAccessors() throw ()
	{
		return 0;
	}
	static HRESULT _GetBindEntries(
		_In_opt_z_ LPOLESTR*,
		_In_opt_ DBORDINAL*,
		_In_opt_ DBBINDING*,
		_In_ ULONG,
		_In_opt_ bool*,
		_In_opt_ BYTE* pBuffer = NULL,
		_In_ bool bClearOnly = false) throw ()
	{
		(bClearOnly);
		(pBuffer);
		return E_FAIL;
	}
};

class _CNoParameters
{
public:
	static bool HasParameters() throw ()
	{
		return false;
	}
	static HRESULT _GetParamEntries(
		_In_opt_z_ LPOLESTR*,
		_In_opt_ DBORDINAL*,
		_In_opt_ DBBINDING*,
		_In_opt_ BYTE* pBuffer = NULL,
		_In_ bool bClearOnly = false) throw ()
	{
		(bClearOnly);
		(pBuffer);
		return E_FAIL;
	}
};

class _CNoCommand
{
public:
	static HRESULT GetDefaultCommand(
		_In_opt_z_ LPCWSTR* /*ppszCommand*/) throw ()
	{
		return S_OK;
	}
};

typedef _CNoOutputColumns   _OutputColumnsClass;
typedef _CNoParameters      _ParamClass;
typedef _CNoCommand         _CommandClass;

#define BEGIN_ACCESSOR_MAP(x, num) \
	public: \
	typedef x _classtype; \
	typedef x _OutputColumnsClass; \
	static ULONG _GetNumAccessors() throw()\
	{ \
		return num;  \
	} \
	static bool HasOutputColumns() throw () { return true; } \
	/* If pBindings == NULL means we only return the column number */ \
	/* If pBuffer != NULL then it points to the accessor buffer and */ \
	/* we release any appropriate memory e.g. BSTR's or interface pointers */ \
	inline static HRESULT _GetBindEntries( \
		_Out_opt_ _Deref_post_z_cap_(*pColumns) LPOLESTR* pColumnNames, \
		_Out_ DBORDINAL* pColumns, \
		_In_opt_ DBBINDING *pBinding, \
		_In_ ULONG nAccessor, \
		_Inout_opt_ bool* pAuto, \
		_In_opt_ BYTE* pBuffer = NULL, \
		_In_ bool bClearOnly = false) \
	{ \
		ATLENSURE(pColumns != NULL); \
		DBPARAMIO eParamIO = DBPARAMIO_NOTPARAM; \
		DBORDINAL nColumns = 0; \
		(pBuffer);\

#define BEGIN_ACCESSOR(num, bAuto) \
	if (nAccessor == num) \
	{ \
		if (pBinding != NULL) \
		{ \
			ATLASSUME(pAuto != NULL); \
			*pAuto = bAuto; \
		}

#define END_ACCESSOR() \
	} \
	else

#define END_ACCESSOR_MAP() \
		; \
		*pColumns = nColumns; \
		return S_OK; \
	}

#define BEGIN_COLUMN_MAP(x) \
	BEGIN_ACCESSOR_MAP(x, 1) \
		BEGIN_ACCESSOR(0, true)

#define END_COLUMN_MAP() \
		END_ACCESSOR() \
	END_ACCESSOR_MAP()

#define offsetbuf(m) offsetof(_classtype, m)
#define _OLEDB_TYPE(data) ATL::_GetOleDBType(((_classtype*)0)->data)
#define _SIZE_TYPE(data) sizeof(((_classtype*)0)->data)

#define _COLUMN_ENTRY_CODE(nOrdinal, wType, nLength, nPrecision, nScale, dataOffset, lengthOffset, statusOffset) \
	if (pBuffer != NULL) \
	{ \
		if (!bClearOnly) \
			ATL::CAccessorBase::FreeType(wType, pBuffer + dataOffset); \
		memset(pBuffer + dataOffset, 0, nLength); \
	} \
	else if (pBinding != NULL) \
	{ \
		ATLENSURE( pColumnNames != NULL ); \
		*pColumnNames = NULL; \
		ATL::CAccessorBase::Bind(pBinding, nOrdinal, wType, nLength, nPrecision, nScale, eParamIO, \
			dataOffset, lengthOffset, statusOffset); \
		pColumnNames++; \
		pBinding++; \
	} \
	nColumns++;

#define _COLUMN_NAME_CODE(pszName, wType, nLength, nPrecision, nScale, dataOffset, lengthOffset, statusOffset) \
	if (pBuffer != NULL) \
	{ \
		if (!bClearOnly) \
			ATL::CAccessorBase::FreeType(wType, pBuffer + dataOffset); \
		memset(pBuffer + dataOffset, 0, nLength); \
	} \
	else if (pBinding != NULL) \
	{ \
		ATLENSURE( pColumnNames != NULL ); \
		*pColumnNames = pszName; \
		ATL::CAccessorBase::Bind(pBinding, 0, wType, nLength, nPrecision, nScale, eParamIO, \
			dataOffset, lengthOffset, statusOffset); \
		pColumnNames++; \
		pBinding++; \
	} \
	nColumns++;

///////////////////////////////////////////////////////////////////////////
// the following tweleve macros are used for binding column by the column ordinal number

#define COLUMN_ENTRY_EX(nOrdinal, wType, nLength, nPrecision, nScale, data, length, status) \
	_COLUMN_ENTRY_CODE(nOrdinal, wType, nLength, nPrecision, nScale, offsetbuf(data), offsetbuf(length), offsetbuf(status))

#define COLUMN_ENTRY_TYPE(nOrdinal, wType, data) \
	COLUMN_ENTRY_TYPE_SIZE(nOrdinal, wType, _SIZE_TYPE(data), data)

#define COLUMN_ENTRY_TYPE_SIZE(nOrdinal, wType, nLength, data) \
	_COLUMN_ENTRY_CODE(nOrdinal, wType, nLength, 0, 0, offsetbuf(data), 0, 0)

#define COLUMN_ENTRY_TYPE_STATUS(nOrdinal, wType, status, data) \
	_COLUMN_ENTRY_CODE(nOrdinal, wType, _SIZE_TYPE(data), 0, 0, offsetbuf(data), 0, offsetbuf(status))

#define COLUMN_ENTRY_TYPE_PS(nOrdinal, wType, nPrecision, nScale, data) \
	_COLUMN_ENTRY_CODE(nOrdinal, wType, _SIZE_TYPE(data), nPrecision, nScale, offsetbuf(data), 0, 0)

// Standard macros where type and size is worked out
#define COLUMN_ENTRY(nOrdinal, data) \
	COLUMN_ENTRY_TYPE(nOrdinal, _OLEDB_TYPE(data), data)

#define COLUMN_ENTRY_LENGTH(nOrdinal, data, length) \
	_COLUMN_ENTRY_CODE(nOrdinal, _OLEDB_TYPE(data), _SIZE_TYPE(data), 0, 0, offsetbuf(data), offsetbuf(length), 0)

#define COLUMN_ENTRY_STATUS(nOrdinal, data, status) \
	_COLUMN_ENTRY_CODE(nOrdinal, _OLEDB_TYPE(data), _SIZE_TYPE(data), 0, 0, offsetbuf(data), 0, offsetbuf(status))

#define COLUMN_ENTRY_LENGTH_STATUS(nOrdinal, data, length, status) \
	_COLUMN_ENTRY_CODE(nOrdinal, _OLEDB_TYPE(data), _SIZE_TYPE(data), 0, 0, offsetbuf(data), offsetbuf(length), offsetbuf(status))

// Follow macros are used if precision and scale need to be specified
#define COLUMN_ENTRY_PS(nOrdinal, nPrecision, nScale, data) \
	_COLUMN_ENTRY_CODE(nOrdinal, _OLEDB_TYPE(data), _SIZE_TYPE(data), nPrecision, nScale, offsetbuf(data), 0, 0)

#define COLUMN_ENTRY_PS_LENGTH(nOrdinal, nPrecision, nScale, data, length) \
	_COLUMN_ENTRY_CODE(nOrdinal, _OLEDB_TYPE(data), _SIZE_TYPE(data), nPrecision, nScale, offsetbuf(data), offsetbuf(length), 0)

#define COLUMN_ENTRY_PS_STATUS(nOrdinal, nPrecision, nScale, data, status) \
	_COLUMN_ENTRY_CODE(nOrdinal, _OLEDB_TYPE(data), _SIZE_TYPE(data), nPrecision, nScale, offsetbuf(data), 0, offsetbuf(status))

#define COLUMN_ENTRY_PS_LENGTH_STATUS(nOrdinal, nPrecision, nScale, data, length, status) \
	_COLUMN_ENTRY_CODE(nOrdinal, _OLEDB_TYPE(data), _SIZE_TYPE(data), nPrecision, nScale, offsetbuf(data), offsetbuf(length), offsetbuf(status))

///////////////////////////////////////////////////////////////////////////
// the following tweleve macros are used for binding column by the column name

#define COLUMN_NAME_EX(pszName, wType, nLength, nPrecision, nScale, data, length, status) \
	_COLUMN_NAME_CODE(pszName, wType, nLength, nPrecision, nScale, offsetbuf(data), offsetbuf(length), offsetbuf(status))

#define COLUMN_NAME_TYPE(pszName, wType, data) \
	COLUMN_NAME_TYPE_SIZE(pszName, wType, _SIZE_TYPE(data), data)

#define COLUMN_NAME_TYPE_SIZE(pszName, wType, nLength, data) \
	_COLUMN_NAME_CODE(pszName, wType, nLength, 0, 0, offsetbuf(data), 0, 0)

#define COLUMN_NAME_TYPE_STATUS(pszName, wType, status, data) \
	_COLUMN_NAME_CODE(pszName, wType, _SIZE_TYPE(data), 0, 0, offsetbuf(data), 0, offsetbuf(status))

#define COLUMN_NAME_TYPE_PS(pszName, wType, nPrecision, nScale, data) \
	_COLUMN_NAME_CODE(pszName, wType, _SIZE_TYPE(data), nPrecision, nScale, offsetbuf(data), 0, 0)

// Standard macros where type and size is worked out
#define COLUMN_NAME(pszName, data) \
	COLUMN_NAME_TYPE(pszName, _OLEDB_TYPE(data), data)

#define COLUMN_NAME_LENGTH(pszName, data, length) \
	_COLUMN_NAME_CODE(pszName, _OLEDB_TYPE(data), _SIZE_TYPE(data), 0, 0, offsetbuf(data), offsetbuf(length), 0)

#define COLUMN_NAME_STATUS(pszName, data, status) \
	_COLUMN_NAME_CODE(pszName, _OLEDB_TYPE(data), _SIZE_TYPE(data), 0, 0, offsetbuf(data), 0, offsetbuf(status))

#define COLUMN_NAME_LENGTH_STATUS(pszName, data, length, status) \
	_COLUMN_NAME_CODE(pszName, _OLEDB_TYPE(data), _SIZE_TYPE(data), 0, 0, offsetbuf(data), offsetbuf(length), offsetbuf(status))

// Follow macros are used if precision and scale need to be specified
#define COLUMN_NAME_PS(pszName, nPrecision, nScale, data) \
	_COLUMN_NAME_CODE(pszName, _OLEDB_TYPE(data), _SIZE_TYPE(data), nPrecision, nScale, offsetbuf(data), 0, 0)

#define COLUMN_NAME_PS_LENGTH(pszName, nPrecision, nScale, data, length) \
	_COLUMN_NAME_CODE(pszName, _OLEDB_TYPE(data), _SIZE_TYPE(data), nPrecision, nScale, offsetbuf(data), offsetbuf(length), 0)

#define COLUMN_NAME_PS_STATUS(pszName, nPrecision, nScale, data, status) \
	_COLUMN_NAME_CODE(pszName, _OLEDB_TYPE(data), _SIZE_TYPE(data), nPrecision, nScale, offsetbuf(data), 0, offsetbuf(status))

#define COLUMN_NAME_PS_LENGTH_STATUS(pszName, nPrecision, nScale, data, length, status) \
	_COLUMN_NAME_CODE(pszName, _OLEDB_TYPE(data), _SIZE_TYPE(data), nPrecision, nScale, offsetbuf(data), offsetbuf(length), offsetbuf(status))



#define BOOKMARK_ENTRY(variable) \
	COLUMN_ENTRY_TYPE_SIZE(0, DBTYPE_BYTES, _SIZE_TYPE(variable##.m_rgBuffer), variable##.m_rgBuffer)

#define _BLOB_ENTRY_CODE(nOrdinal, IID, flags, dataOffset, lengthOffset, statusOffset) \
	if (pBuffer != NULL) \
	{ \
		if (!bClearOnly) \
			ATL::CAccessorBase::FreeType(DBTYPE_IUNKNOWN, pBuffer + dataOffset); \
		memset(pBuffer + dataOffset, 0, sizeof(IUnknown*)); \
	} \
	else if (pBinding != NULL) \
	{ \
		ATLASSERT( pColumnNames != NULL ); \
		DBOBJECT* pObject = NULL; \
		ATLTRY(pObject = new DBOBJECT); \
		if (pObject == NULL) \
			return E_OUTOFMEMORY; \
		pObject->dwFlags = flags; \
		pObject->iid     = IID; \
		*pColumnNames = NULL; \
		ATL::CAccessorBase::Bind(pBinding, nOrdinal, DBTYPE_IUNKNOWN, sizeof(IUnknown*), 0, 0, eParamIO, \
			dataOffset, lengthOffset, statusOffset, pObject); \
		pColumnNames++; \
		pBinding++; \
	} \
	nColumns++;

#define _BLOB_NAME_CODE(pszName, IID, flags, dataOffset, lengthOffset, statusOffset) \
	if (pBuffer != NULL) \
	{ \
		if (!bClearOnly) \
			ATL::CAccessorBase::FreeType(DBTYPE_IUNKNOWN, pBuffer + dataOffset); \
		memset(pBuffer + dataOffset, 0, sizeof(IUnknown*)); \
	} \
	else if (pBinding != NULL) \
	{ \
		ATLASSERT( pColumnNames != NULL ); \
		DBOBJECT* pObject = NULL; \
		ATLTRY(pObject = new DBOBJECT); \
		if (pObject == NULL) \
			return E_OUTOFMEMORY; \
		pObject->dwFlags = flags; \
		pObject->iid     = IID; \
		*pColumnNames = pszName; \
		ATL::CAccessorBase::Bind(pBinding, 0, DBTYPE_IUNKNOWN, sizeof(IUnknown*), 0, 0, eParamIO, \
			dataOffset, lengthOffset, statusOffset, pObject); \
		pColumnNames++; \
		pBinding++; \
	} \
	nColumns++;

#define BLOB_ENTRY(nOrdinal, IID, flags, data) \
	_BLOB_ENTRY_CODE(nOrdinal, IID, flags, offsetbuf(data), 0, 0);

#define BLOB_ENTRY_STATUS(nOrdinal, IID, flags, data, status) \
	_BLOB_ENTRY_CODE(nOrdinal, IID, flags, offsetbuf(data), 0, offsetbuf(status));

#define BLOB_ENTRY_LENGTH(nOrdinal, IID, flags, data, length) \
	_BLOB_ENTRY_CODE(nOrdinal, IID, flags, offsetbuf(data), offsetbuf(length), 0);

#define BLOB_ENTRY_LENGTH_STATUS(nOrdinal, IID, flags, data, length, status) \
	_BLOB_ENTRY_CODE(nOrdinal, IID, flags, offsetbuf(data), offsetbuf(length), offsetbuf(status));

#define BLOB_NAME(pszName, IID, flags, data) \
	_BLOB_NAME_CODE(pszName, IID, flags, offsetbuf(data), 0, 0);

#define BLOB_NAME_STATUS(pszName, IID, flags, data, status) \
	_BLOB_NAME_CODE(pszName, IID, flags, offsetbuf(data), 0, offsetbuf(status));

#define BLOB_NAME_LENGTH(pszName, IID, flags, data, length) \
	_BLOB_NAME_CODE(pszName, IID, flags, offsetbuf(data), offsetbuf(length), 0);

#define BLOB_NAME_LENGTH_STATUS(pszName, IID, flags, data, length, status) \
	_BLOB_NAME_CODE(pszName, IID, flags, offsetbuf(data), offsetbuf(length), offsetbuf(status));

#define BEGIN_PARAM_MAP(x) \
	public: \
	typedef x _classtype; \
	typedef x _ParamClass; \
	static bool HasParameters() throw () { return true; } \
	static HRESULT _GetParamEntries( \
		_Out_opt_ _Deref_post_z_cap_(*pColumns) LPOLESTR* pColumnNames, \
		_Out_ DBORDINAL* pColumns, \
		_In_opt_ DBBINDING *pBinding, \
		_In_opt_ BYTE* pBuffer = NULL, \
		_In_ bool bClearOnly = false) \
	{ \
		ATLENSURE(pColumns != NULL); \
		DBPARAMIO eParamIO = DBPARAMIO_INPUT; \
		int nColumns = 0; \
		(pBuffer);

#define END_PARAM_MAP() \
		*pColumns = nColumns; \
		return S_OK; \
	}

#define SET_PARAM_TYPE(type) \
	eParamIO = type;

#ifdef _UNICODE
#define DEFINE_COMMAND(x, szCommand) \
	typedef x _CommandClass; \
	static HRESULT GetDefaultCommand(LPCWSTR* ppwszCommand) throw () \
	{ \
		*ppwszCommand = szCommand; \
		return S_OK; \
	}
#else // !_UNICODE
#define DEFINE_COMMAND(x, szCommand) \
	typedef x _CommandClass; \
	static HRESULT GetDefaultCommand(LPCWSTR* ppwszCommand) throw () \
	{ \
		static CA2WEX<sizeof(szCommand)> szCmd(szCommand); \
		*ppwszCommand = szCmd; \
		return S_OK; \
	}
#endif // !_UNICODE

#pragma deprecated("DEFINE_COMMAND") // Use DEFINE_COMMAND_EX instead!

#define DEFINE_COMMAND_EX(x, wszCommand) \
	typedef x _CommandClass; \
	static HRESULT GetDefaultCommand(LPCWSTR* ppwszCommand) throw () \
	{ \
		*ppwszCommand = wszCommand; \
		return S_OK; \
	}


///////////////////////////////////////////////////////////////////////////
// class CDBErrorInfo

class CDBErrorInfo
{
public:
	// Use to get the number of error record when you want to explicitly check that
	// the passed interface set the error information
	HRESULT GetErrorRecords(
		_Inout_ IUnknown* pUnk,
		_In_ const IID& iid,
		_Out_ ULONG* pcRecords) throw()
	{
		ATLENSURE_RETURN(pUnk);
		ATLENSURE_RETURN(pcRecords);
		CComPtr<ISupportErrorInfo> spSupportErrorInfo;
		HRESULT hr = pUnk->QueryInterface(&spSupportErrorInfo);
		if (FAILED(hr))
			return hr;

		hr = spSupportErrorInfo->InterfaceSupportsErrorInfo(iid);
		if (FAILED(hr))
			return hr;

		return GetErrorRecords(pcRecords);
	}
	// Use to get the number of error records
	HRESULT GetErrorRecords(_Out_ ULONG* pcRecords) throw ()
	{
		ATLENSURE_RETURN(pcRecords != NULL);
		HRESULT hr;
		m_spErrorInfo.Release();
		m_spErrorRecords.Release();
		hr = ::GetErrorInfo(0, &m_spErrorInfo);
		if (hr == S_FALSE)
			return E_FAIL;

		hr = m_spErrorInfo->QueryInterface(__uuidof(IErrorRecords), (void**)&m_spErrorRecords);
		if (FAILED(hr))
		{
			// Well we got the IErrorInfo so we'll just treat that as
			// the one record
			*pcRecords = 1;
			return S_OK;
		}

		return m_spErrorRecords->GetRecordCount(pcRecords);
	}
	// Get the error information for the passed record number. GetErrorRecords must
	// be called before this function is called.
	HRESULT GetAllErrorInfo(
		_In_ ULONG ulRecordNum,
		_In_ LCID lcid,
		_Deref_opt_out_z_ BSTR* pbstrDescription,
		_Deref_opt_out_z_ BSTR* pbstrSource = NULL,
		_Out_opt_ GUID* pguid = NULL,
		_Out_opt_ DWORD* pdwHelpContext = NULL,
		_Deref_opt_out_z_ BSTR* pbstrHelpFile = NULL) const throw()
	{
		CComPtr<IErrorInfo> spErrorInfo;

		// If we have the IErrorRecords interface pointer then use it, otherwise
		// we'll just default to the IErrorInfo we have already retrieved in the call
		// to GetErrorRecords
		if (m_spErrorRecords != NULL)
		{
			HRESULT hr = m_spErrorRecords->GetErrorInfo(ulRecordNum, lcid, &spErrorInfo);
			if (FAILED(hr))
				return hr;
		}
		else
		{
			ATLASSUME(m_spErrorInfo != NULL);
			spErrorInfo = m_spErrorInfo;
		}

		if (pbstrDescription != NULL)
			spErrorInfo->GetDescription(pbstrDescription);

		if (pguid != NULL)
			spErrorInfo->GetGUID(pguid);

		if (pdwHelpContext != NULL)
			spErrorInfo->GetHelpContext(pdwHelpContext);

		if (pbstrHelpFile != NULL)
			spErrorInfo->GetHelpFile(pbstrHelpFile);

		if (pbstrSource != NULL)
			spErrorInfo->GetSource(pbstrSource);

		return S_OK;
	}
	// Get the error information for the passed record number
	HRESULT GetBasicErrorInfo(
		_In_ ULONG ulRecordNum,
		_Out_ ERRORINFO* pErrorInfo) const throw ()
	{
		return m_spErrorRecords->GetBasicErrorInfo(ulRecordNum, pErrorInfo);
	}

ATLPREFAST_SUPPRESS(6387)	
	// Get the custom error object for the passed record number
	HRESULT GetCustomErrorObject(
		_In_ ULONG ulRecordNum,
		_In_ REFIID riid,
		_Deref_out_ IUnknown** ppObject) const throw ()
	{
		return m_spErrorRecords->GetCustomErrorObject(ulRecordNum, riid, ppObject);
	}
ATLPREFAST_UNSUPPRESS();

	// Get the IErrorInfo interface for the passed record number
	HRESULT GetErrorInfo(
		_In_ ULONG ulRecordNum,
		_In_ LCID lcid,
		_Deref_out_ IErrorInfo** ppErrorInfo) const throw ()
	{
		return m_spErrorRecords->GetErrorInfo(ulRecordNum, lcid, ppErrorInfo);
	}
	// Get the error parameters for the passed record number
	HRESULT GetErrorParameters(
		_In_ ULONG ulRecordNum,
		_Out_ DISPPARAMS* pdispparams) const throw ()
	{
		return m_spErrorRecords->GetErrorParameters(ulRecordNum, pdispparams);
	}

// Implementation
	CComPtr<IErrorInfo>     m_spErrorInfo;
	CComPtr<IErrorRecords>  m_spErrorRecords;
};

#ifdef _DEBUG
inline void AtlTraceErrorRecords(_In_ HRESULT hrErr = S_OK)
{
	CDBErrorInfo ErrorInfo;
	ULONG        cRecords;
	HRESULT      hr;
	ULONG        i;
	CComBSTR     bstrDesc, bstrHelpFile, bstrSource;
	GUID         guid;
	DWORD        dwHelpContext;
	WCHAR        wszGuid[40];

	// If the user passed in an HRESULT then trace it
	if (hrErr != S_OK)
	{
		ATLTRACE(atlTraceDBClient, 0, _T("OLE DB Error Record dump for hr = 0x%x\n"), hrErr);
	}

	LCID lcLocale = GetSystemDefaultLCID();

	hr = ErrorInfo.GetErrorRecords(&cRecords);
	if (FAILED(hr) && ErrorInfo.m_spErrorInfo == NULL)
	{
		ATLTRACE(atlTraceDBClient, 0, _T("No OLE DB Error Information found: hr = 0x%x\n"), hr);
	}
	else
	{
		for (i = 0; i < cRecords; i++)
		{
			hr = ErrorInfo.GetAllErrorInfo(i, lcLocale, &bstrDesc, &bstrSource, &guid,
										&dwHelpContext, &bstrHelpFile);
			if (FAILED(hr))
			{
				ATLTRACE(atlTraceDBClient, 0,
					_T("OLE DB Error Record dump retrieval failed: hr = 0x%x\n"), hr);
				return;
			}
			StringFromGUID2(guid, wszGuid, sizeof(wszGuid) / sizeof(WCHAR));
			ATLTRACE(atlTraceDBClient, 0,
				_T("Row #: %4d Source: \"%s\" Description: \"%s\" Help File: \"%s\" Help Context: %4d GUID: %s\n"),
				i, static_cast<TCHAR*>(COLE2T(bstrSource)), static_cast<TCHAR*>(COLE2T(bstrDesc)), static_cast<TCHAR*>(COLE2T(bstrHelpFile)), dwHelpContext, static_cast<TCHAR*>(COLE2T(wszGuid)));
			bstrSource.Empty();
			bstrDesc.Empty();
			bstrHelpFile.Empty();
		}
		ATLTRACE(atlTraceDBClient, 0, _T("OLE DB Error Record dump end\n"));
	}
}
#else
inline void AtlTraceErrorRecords(_In_ HRESULT hrErr = S_OK) throw()
{
	(hrErr);
}
#endif


///////////////////////////////////////////////////////////////////////////
// class CDBPropSet

class CDBPropSet :
	public tagDBPROPSET
{
public:
	CDBPropSet()
	{
		rgProperties    = NULL;
		cProperties     = 0;
	}
	CDBPropSet(_In_ const GUID& guid)
	{
		rgProperties    = NULL;
		cProperties     = 0;
		guidPropertySet = guid;
	}
	CDBPropSet(_In_ const CDBPropSet& propset)
	{
		InternalCopy(propset);
	}
	~CDBPropSet()
	{
		for (ULONG i = 0; i < cProperties; i++)
			VariantClear(&rgProperties[i].vValue);

		CoTaskMemFree(rgProperties);
	}
	CDBPropSet& operator=(_In_ CDBPropSet& propset) throw()
	{
		if(this!=&propset)
		{
			this->~CDBPropSet();
			InternalCopy(propset);
        }
		return *this;
	}
	// Set the GUID of the property set this class represents.
	// Use if you didn't pass the GUID to the constructor.
	void SetGUID(_In_ const GUID& guid) throw()
	{
		guidPropertySet = guid;
	}
	// Add the passed property to the property set
	_Check_return_ bool AddProperty(
		_In_ DWORD dwPropertyID,
		_In_ const VARIANT& var,
		_In_ DBPROPOPTIONS propoptions = DBPROPOPTIONS_REQUIRED) throw()
	{
		HRESULT hr;
		if (!Add(propoptions))
			return false;
		rgProperties[cProperties].dwPropertyID   = dwPropertyID;
		hr = ::VariantCopy(&(rgProperties[cProperties].vValue), const_cast<VARIANT*>(&var));
		if (FAILED(hr))
			return false;
		cProperties++;
		return true;
	}
	// Add the passed property to the property set
	_Check_return_ bool AddProperty(
		_In_ DWORD dwPropertyID,
		_In_z_ LPCSTR szValue,
		_In_ DBPROPOPTIONS propoptions = DBPROPOPTIONS_REQUIRED) throw()
	{
		if (!Add(propoptions))
		{
			return false;
		}
		rgProperties[cProperties].dwPropertyID   = dwPropertyID;
		rgProperties[cProperties].vValue.vt      = VT_BSTR;
		rgProperties[cProperties].vValue.bstrVal = CComBSTR(szValue).Detach();
#pragma warning(push)
#pragma warning(disable:4068)
#pragma prefast(push)
#pragma prefast(disable:325, "We are deliberately checking if this has already been allocated")
		if (rgProperties[cProperties].vValue.bstrVal == NULL)
		{
			return false;
		}
#pragma prefast(pop)
#pragma warning(pop)
		cProperties++;
		return true;
	}
	// Add the passed property to the property set
	_Check_return_ bool AddProperty(
		_In_ DWORD dwPropertyID,
		_In_z_ LPCWSTR szValue,
		_In_ DBPROPOPTIONS propoptions = DBPROPOPTIONS_REQUIRED) throw()
	{
		if (!Add(propoptions))
		{
			return false;
		}
		rgProperties[cProperties].dwPropertyID   = dwPropertyID;
		rgProperties[cProperties].vValue.vt      = VT_BSTR;
		rgProperties[cProperties].vValue.bstrVal = CComBSTR(szValue).Detach();
#pragma warning(push)
#pragma warning(disable:4068)
#pragma prefast(push)
#pragma prefast(disable:325, "We are deliberately checking if this has already been allocated")
		if (rgProperties[cProperties].vValue.bstrVal == NULL)
		{
			return false;
		}
#pragma prefast(pop)
#pragma warning(pop)
		cProperties++;
		return true;
	}
	// Add the passed property to the property set
	_Check_return_ bool AddProperty(
		_In_ DWORD dwPropertyID,
		_In_ bool bValue,
		_In_ DBPROPOPTIONS propoptions = DBPROPOPTIONS_REQUIRED) throw()
	{
		if (!Add(propoptions))
			return false;
		rgProperties[cProperties].dwPropertyID   = dwPropertyID;
		rgProperties[cProperties].vValue.vt      = VT_BOOL;
		rgProperties[cProperties].vValue.boolVal = (bValue) ? ATL_VARIANT_TRUE : ATL_VARIANT_FALSE;
		cProperties++;
		return true;
	}
	// Add the passed property to the property set
	_Check_return_ bool AddProperty(
		_In_ DWORD dwPropertyID,
		_In_ BYTE bValue,
		_In_ DBPROPOPTIONS propoptions = DBPROPOPTIONS_REQUIRED)
	{
		if (!Add(propoptions))
			return false;
		rgProperties[cProperties].dwPropertyID  = dwPropertyID;
		rgProperties[cProperties].vValue.vt     = VT_UI1;
		rgProperties[cProperties].vValue.bVal   = bValue;
		cProperties++;
		return true;
	}
	// Add the passed property to the property set
	_Check_return_ bool AddProperty(
		_In_ DWORD dwPropertyID,
		_In_ short nValue,
		_In_ DBPROPOPTIONS propoptions = DBPROPOPTIONS_REQUIRED)
	{
		if (!Add(propoptions))
			return false;
		rgProperties[cProperties].dwPropertyID  = dwPropertyID;
		rgProperties[cProperties].vValue.vt     = VT_I2;
		rgProperties[cProperties].vValue.iVal   = nValue;
		cProperties++;
		return true;
	}
	// Add the passed property to the property set
	_Check_return_ bool AddProperty(
		_In_ DWORD dwPropertyID,
		_In_ long nValue,
		_In_ DBPROPOPTIONS propoptions = DBPROPOPTIONS_REQUIRED)
	{
		if (!Add(propoptions))
			return false;
		rgProperties[cProperties].dwPropertyID  = dwPropertyID;
		rgProperties[cProperties].vValue.vt     = VT_I4;
		rgProperties[cProperties].vValue.lVal   = nValue;
		cProperties++;
		return true;
	}
	// Add the passed property to the property set
	_Check_return_ bool AddProperty(
		_In_ DWORD dwPropertyID,
		_In_ float fltValue,
		_In_ DBPROPOPTIONS propoptions = DBPROPOPTIONS_REQUIRED)
	{
		if (!Add(propoptions))
			return false;
		rgProperties[cProperties].dwPropertyID  = dwPropertyID;
		rgProperties[cProperties].vValue.vt     = VT_R4;
		rgProperties[cProperties].vValue.fltVal = fltValue;
		cProperties++;
		return true;
	}
	// Add the passed property to the property set
	_Check_return_ bool AddProperty(
		_In_ DWORD dwPropertyID,
		_In_ double dblValue,
		_In_ DBPROPOPTIONS propoptions = DBPROPOPTIONS_REQUIRED) throw()
	{
		if (!Add(propoptions))
			return false;
		rgProperties[cProperties].dwPropertyID  = dwPropertyID;
		rgProperties[cProperties].vValue.vt     = VT_R8;
		rgProperties[cProperties].vValue.dblVal = dblValue;
		cProperties++;
		return true;
	}
	// Add the passed property to the property set
	_Check_return_ bool AddProperty(
		_In_ DWORD dwPropertyID,
		_In_ CY cyValue,
		_In_ DBPROPOPTIONS propoptions = DBPROPOPTIONS_REQUIRED) throw()
	{
		if (!Add(propoptions))
			return false;
		rgProperties[cProperties].dwPropertyID  = dwPropertyID;
		rgProperties[cProperties].vValue.vt     = VT_CY;
		rgProperties[cProperties].vValue.cyVal  = cyValue;
		cProperties++;
		return true;
	}
// Implementation
	// Create memory to add a new property
	_Check_return_ bool Add(
		_In_ DBPROPOPTIONS propoptions = DBPROPOPTIONS_REQUIRED) throw()
	{
		if (((cProperties + 1) < cProperties))
		{
			return false;
		}
		DBPROP* rgTemp = (DBPROP*)::ATL::AtlCoTaskMemRecalloc(rgProperties, (cProperties + 1), sizeof(DBPROP));
		if (rgTemp == NULL)
			return false;
		rgProperties = rgTemp;
		rgProperties[cProperties].dwOptions = propoptions;
		rgProperties[cProperties].colid     = DB_NULLID;
		rgProperties[cProperties].vValue.vt = VT_EMPTY;
		return true;
	}
	// Copies in the passed value now it this value been cleared
	void InternalCopy(_In_ const CDBPropSet& propset) throw()
	{
		cProperties     = propset.cProperties;
		rgProperties    = (DBPROP*)::ATL::AtlCoTaskMemCAlloc(cProperties, static_cast<ULONG>(sizeof(DBPROP)));
		if (rgProperties != NULL)
		{
			guidPropertySet = propset.guidPropertySet;
			for (ULONG i = 0; i < cProperties; i++)
			{
				rgProperties[i].dwPropertyID = propset.rgProperties[i].dwPropertyID;
				if( propset.rgProperties[i].dwOptions == DBPROPOPTIONS_OPTIONAL )
					rgProperties[i].dwOptions = DBPROPOPTIONS_OPTIONAL;
				else
					rgProperties[i].dwOptions = DBPROPOPTIONS_REQUIRED;
				rgProperties[i].colid        = DB_NULLID;
				rgProperties[i].vValue.vt    = VT_EMPTY;
				HRESULT hr = VariantCopy(&rgProperties[i].vValue, &propset.rgProperties[i].vValue);
				ATLASSERT( SUCCEEDED(hr) );
				if( FAILED(hr) )
					VariantInit( &rgProperties[i].vValue );
			}
		}
		else
		{
			// The memory allocation failed so set the count
			// of properties to zero
			cProperties = 0;
		}
	}
};


///////////////////////////////////////////////////////////////////////////
// class CDBPropIDSet

class CDBPropIDSet :
	public tagDBPROPIDSET
{
// Constructors and Destructors
public:
	CDBPropIDSet()
	{
		rgPropertyIDs   = NULL;
		cPropertyIDs    = 0;
	}
	CDBPropIDSet(_In_ const GUID& guid)
	{
		rgPropertyIDs   = NULL;
		cPropertyIDs    = 0;
		guidPropertySet = guid;
	}
	CDBPropIDSet(_In_ const CDBPropIDSet& propidset)
	{
		InternalCopy(propidset);
	}
	~CDBPropIDSet()
	{
		free(rgPropertyIDs);
	}
	CDBPropIDSet& operator=(_In_ CDBPropIDSet& propset) throw()
	{
		this->~CDBPropIDSet();
		InternalCopy(propset);
		return *this;
	}
	// Set the GUID of the property ID set
	void SetGUID(_In_ const GUID& guid) throw()
	{
		guidPropertySet = guid;
	}
	// Add a property ID to the set
	bool AddPropertyID(_In_ DBPROPID propid) throw()
	{
		if (!Add())
			return false;
		rgPropertyIDs[cPropertyIDs] = propid;
		cPropertyIDs++;
		return true;
	}
// Implementation
	bool Add() throw()
	{
		DBPROPID* pTempID  = (DBPROPID*)_recalloc(rgPropertyIDs, (cPropertyIDs + 1), sizeof(DBPROPID));
		if (pTempID == NULL)
			return false;

		rgPropertyIDs = pTempID;
		return true;
	}
	void InternalCopy(_In_ const CDBPropIDSet& propidset) throw()
	{
		cPropertyIDs    = propidset.cPropertyIDs;
		rgPropertyIDs   = NULL;
		ATLTRY(rgPropertyIDs   = (DBPROPID*)calloc(cPropertyIDs, sizeof(DBPROPID)));
		if (rgPropertyIDs != NULL)
		{
			guidPropertySet = propidset.guidPropertySet;
			for (ULONG i = 0; i < cPropertyIDs; i++)
				rgPropertyIDs[i] = propidset.rgPropertyIDs[i];
		}
		else
		{
			// The memory allocation failed so set the count
			// of properties to zero
			cPropertyIDs = 0;
		}
	}
};


///////////////////////////////////////////////////////////////////////////
// class CBookmarkBase

class ATL_NO_VTABLE CBookmarkBase
{
public:
	virtual DBLENGTH GetSize() const = 0;
	virtual BYTE* GetBuffer() const = 0;
};


///////////////////////////////////////////////////////////////////////////
// class CBookmark

template <DBLENGTH nSize = 0>
class CBookmark :
	public CBookmarkBase
{
public:
	virtual DBLENGTH GetSize() const throw()
	{
		return nSize;
	}
	_Ret_count_x_(nSize) virtual BYTE* GetBuffer() const throw()
	{
		return (BYTE*)m_rgBuffer;
	}

// Implementation
	BYTE m_rgBuffer[nSize];
};


// Size of 0 means that the memory for the bookmark will be allocated
// at run time.
template <>
class CBookmark<0> :
	public CBookmarkBase
{
public:
	CBookmark()
	{
		m_nSize = 0;
		m_pBuffer = NULL;
	}
	CBookmark(_In_ DBLENGTH nSize)
	{
		m_pBuffer = NULL;
		ATLTRY(m_pBuffer = new BYTE[nSize]);
		m_nSize = (m_pBuffer == NULL) ? 0 : nSize;
	}
	virtual ~CBookmark()
	{
		delete [] m_pBuffer;
	}
	CBookmark& operator=(_In_ const CBookmark& bookmark) throw()
	{
		if(this!=&bookmark)
		{
			SetBookmark(bookmark.GetSize(), bookmark.GetBuffer());
		}
		return *this;
	}
	virtual DBLENGTH GetSize() const throw()
	{
		return m_nSize;
	}
	_Ret_count_x_(m_nSize) virtual BYTE* GetBuffer() const throw()
	{
		return m_pBuffer;
	}
	// Sets the bookmark to the passed value
	HRESULT SetBookmark(
		_In_ DBLENGTH nSize,
		_In_count_(nSize) BYTE* pBuffer) throw()
	{
		ATLENSURE_RETURN(pBuffer != NULL);
		delete [] m_pBuffer;
		m_pBuffer = NULL;
		ATLTRY(m_pBuffer = new BYTE[nSize]);
		if (m_pBuffer != NULL)
		{
			Checked::memcpy_s(m_pBuffer, nSize, pBuffer, nSize);
			m_nSize = nSize;
			return S_OK;
		}
		else
		{
			m_nSize = 0;
			return E_OUTOFMEMORY;
		}
	}
	DBLENGTH  m_nSize;
	BYTE*   m_pBuffer;
};


///////////////////////////////////////////////////////////////////////////
// class CAccessorBase

class CAccessorBase
{
public:
	CAccessorBase()
	{
		m_pAccessorInfo  = NULL;
		m_nAccessors     = 0;
		m_pBuffer        = NULL;
	}
	void Close() throw()
	{
		// If Close is called then ReleaseAccessors must have been
		// called first
		ATLASSUME(m_nAccessors == 0);
		ATLASSUME(m_pAccessorInfo == NULL);
	}
	// Get the number of accessors that have been created
	ULONG GetNumAccessors() const throw()
	{
		return m_nAccessors;
	}
	// Get the handle of the passed accessor (offset from 0)
	HACCESSOR GetHAccessor(_In_ ULONG nAccessor) const throw()
	{
		ATLENSURE_RETURN_VAL(nAccessor<m_nAccessors, 0);
		return m_pAccessorInfo[nAccessor].hAccessor;
	};
	// Called during Close to release the accessor information
	HRESULT ReleaseAccessors(_Inout_ IUnknown* pUnk) throw()
	{
		ATLENSURE_RETURN(pUnk != NULL);
		HRESULT hr = S_OK;
		if (m_nAccessors > 0)
		{
			CComPtr<IAccessor> spAccessor;
			hr = pUnk->QueryInterface(__uuidof(IAccessor), (void**)&spAccessor);
			if (SUCCEEDED(hr))
			{
				ATLENSURE_RETURN(m_pAccessorInfo != NULL);
				for (ULONG i = 0; i < m_nAccessors; i++)
					spAccessor->ReleaseAccessor(m_pAccessorInfo[i].hAccessor, NULL);
			}
			m_nAccessors = 0;
			delete [] m_pAccessorInfo;
			m_pAccessorInfo = NULL;
		}
		return hr;
	}
	// Returns true or false depending upon whether data should be
	// automatically retrieved for the passed accessor.
	bool IsAutoAccessor(_In_ ULONG nAccessor) const throw()
	{
		ATLENSURE_RETURN_VAL(nAccessor < m_nAccessors, false);
		ATLENSURE_RETURN_VAL(m_pAccessorInfo != NULL, false);
		return m_pAccessorInfo[nAccessor].bAutoAccessor;
	}

// Implementation
	// Used by the rowset class to find out where to place the data
	BYTE* GetBuffer() const throw()
	{
		return m_pBuffer;
	}
	// Set the buffer that is used to retrieve the data
	void SetBuffer(_In_opt_ BYTE* pBuffer) throw()
	{
		m_pBuffer = pBuffer;
	}

	bool NoBindOnNullRowset() const throw()
	{
		return false;
	}

	// Allocate internal memory for the passed number of accessors
	HRESULT AllocateAccessorMemory(_In_ int nAccessors) throw()
	{
		// Can't be called twice without calling ReleaseAccessors first
		ATLASSUME(m_pAccessorInfo == NULL);
		m_pAccessorInfo = NULL;
		ATLTRY(m_pAccessorInfo = new _ATL_ACCESSOR_INFO[nAccessors]);
		if (m_pAccessorInfo == NULL)
			return E_OUTOFMEMORY;
		m_nAccessors    = nAccessors;
		return S_OK;
	}
	// BindParameters will be overriden if parameters are used
	HRESULT BindParameters(
		_In_opt_ HACCESSOR*,
		_In_opt_ ICommand*,
		_In_opt_ void**) throw()
	{
		return S_OK;
	}

	// Create an accessor for the passed binding information. The created accessor is
	// returned through the pHAccessor parameter.
	static HRESULT BindEntries(
		_In_bytecount_x_(nColumns * sizeof(DBBINDING)) DBBINDING* pBindings,
		_In_ DBORDINAL nColumns,
		_Out_ HACCESSOR* pHAccessor,
		_In_ DBLENGTH nSize,
		_Inout_ IAccessor* pAccessor) throw()
	{
		ATLENSURE_RETURN(pBindings  != NULL);
		ATLENSURE_RETURN(pHAccessor != NULL);
		ATLENSURE_RETURN(pAccessor  != NULL);
		HRESULT hr;
		DBORDINAL i;
		DWORD dwAccessorFlags = (pBindings->eParamIO == DBPARAMIO_NOTPARAM) ?
			DBACCESSOR_ROWDATA : DBACCESSOR_PARAMETERDATA;

#ifdef _DEBUG
		// In debug builds we will retrieve the status flags and trace out
		// any errors that may occur.
		CAutoVectorPtr<DBBINDSTATUS> spStatus;
		spStatus.Allocate( nColumns );
		hr = pAccessor->CreateAccessor(dwAccessorFlags, nColumns,
			pBindings, nSize, pHAccessor, spStatus);
		if (FAILED(hr) && (DBBINDSTATUS*)spStatus)
		{
			for (i=0; i<nColumns; i++)
			{
				if (spStatus[i] != DBBINDSTATUS_OK)
					ATLTRACE(atlTraceDBClient, 0, _T("Binding entry %d failed. Status: %d\n"), i, spStatus[i]);
			}
		}
#else
		hr = pAccessor->CreateAccessor(dwAccessorFlags, nColumns,
			pBindings, nSize, pHAccessor, NULL);
#endif
		for (i=0; i<nColumns; i++)
			delete pBindings[i].pObject;

		return hr;
	}

	// Set up the binding structure pointed to by pBindings based upon
	// the other passed parameters.
	static void Bind(
		_Out_opt_ DBBINDING* pBinding,
		_In_ DBORDINAL nOrdinal,
		_In_ DBTYPE wType,
		_In_ DBLENGTH nLength,
		_In_ BYTE nPrecision,
		_In_ BYTE nScale,
		_In_ DBPARAMIO eParamIO,
		_In_ DBBYTEOFFSET nDataOffset,
		_In_ DBBYTEOFFSET nLengthOffset = 0,
		_In_ DBBYTEOFFSET nStatusOffset = 0,
		_In_opt_ DBOBJECT* pdbobject = NULL)
	{
		ATLENSURE(pBinding != NULL);

		// If we are getting a pointer to the data then let the provider
		// own the memory
		if (wType & DBTYPE_BYREF)
			pBinding->dwMemOwner = DBMEMOWNER_PROVIDEROWNED;
		else
			pBinding->dwMemOwner = DBMEMOWNER_CLIENTOWNED;

		pBinding->pObject   = pdbobject;

		pBinding->eParamIO      = eParamIO;
		pBinding->iOrdinal      = nOrdinal;
		pBinding->wType         = wType;
		pBinding->bPrecision    = nPrecision;
		pBinding->bScale        = nScale;
		pBinding->dwFlags       = 0;

		pBinding->obValue       = nDataOffset;
		pBinding->obLength      = 0;
		pBinding->obStatus      = 0;
		pBinding->pTypeInfo     = NULL;
		pBinding->pBindExt      = NULL;
		pBinding->cbMaxLen      = nLength;

		pBinding->dwPart = DBPART_VALUE;
		if (nLengthOffset != 0)
		{
			pBinding->dwPart |= DBPART_LENGTH;
			pBinding->obLength = nLengthOffset;
		}
		if (nStatusOffset != 0)
		{
			pBinding->dwPart |= DBPART_STATUS;
			pBinding->obStatus = nStatusOffset;
		}
	}

	// Free memory if appropriate
	static inline void FreeType(
		_In_ DBTYPE wType,
		_In_opt_ BYTE* pValue,
		_Inout_opt_ IRowset* pRowset = NULL) throw()
	{
		if (pValue == NULL)
			return;

		if( wType & DBTYPE_ARRAY )
		{
			SAFEARRAY** ppSafeArray = (SAFEARRAY**)pValue;
			if( (*ppSafeArray) != NULL )
			{
				SafeArrayDestroy(*ppSafeArray);
				*ppSafeArray = NULL;
			}
		}
		else
		{
			switch (wType)
			{
				case DBTYPE_BSTR:
					SysFreeString(*((BSTR*)pValue));
					*((BSTR*)pValue) = NULL;
				break;
				case DBTYPE_VARIANT:
					VariantClear((VARIANT*)pValue);
				break;
				case DBTYPE_IUNKNOWN:
				case DBTYPE_IDISPATCH:
					if( (*(IUnknown**)pValue) != NULL )
					{
						(*(IUnknown**)pValue)->Release();
						*(IUnknown**)pValue = NULL;
					}
				break;

				case DBTYPE_HCHAPTER:
					CComQIPtr<IChapteredRowset> spChapteredRowset = pRowset;
					if (spChapteredRowset != NULL)
						spChapteredRowset->ReleaseChapter(*(HCHAPTER*)pValue, NULL);
				break;
			}
		}
		if ((wType & DBTYPE_VECTOR) && ~(wType & DBTYPE_BYREF))
			CoTaskMemFree(((DBVECTOR*)pValue)->ptr);
	}

	void FreeRecordMemory(_Inout_opt_ IRowset* /*pRowset*/) throw()
	{
	}

	_ATL_ACCESSOR_INFO* m_pAccessorInfo;
	ULONG               m_nAccessors;
	BYTE*               m_pBuffer;
};

class CXMLAccessor;

///////////////////////////////////////////////////////////////////////////
// class CRowset

template <class TAccessor = CAccessorBase>
class CRowset
{
// Constructors and Destructors
public:
	CRowset()
	{
		m_pXMLAccessor = NULL;
		m_pAccessor = NULL;
		m_hRow      = 0;
	}
	CRowset(_In_opt_ IRowset* pRowset)
	{
		m_pXMLAccessor = NULL;
		m_pAccessor = NULL;
		m_hRow      = 0;
		m_spRowset  = pRowset;
	}
	~CRowset()
	{
		Close();
	}

	HRESULT GetXMLColumnInfo(_Inout_ CSimpleStringW& strOutput) throw()
	{
		ATLASSUME(m_spRowset != NULL);
		HRESULT hr;
		if( m_pXMLAccessor == NULL )
		{
			ATLTRY(m_pXMLAccessor = new CXMLAccessor);
			if( m_pXMLAccessor == NULL )
				return E_OUTOFMEMORY;
			hr = m_pXMLAccessor->BindColumns( m_spRowset );
			if( FAILED(hr) )
			{
				delete m_pXMLAccessor;
				m_pXMLAccessor = NULL;
				return hr;
			}
		}

		ATLASSUME( m_pXMLAccessor != NULL );

		return m_pXMLAccessor->GetXMLColumnData( strOutput );
	}

	HRESULT GetXMLRow(
		_Inout_ CSimpleStringW& strOutput,
		_In_ bool bAppend = false) throw()
	{
		ATLASSUME(m_spRowset != NULL);
		ATLASSUME(m_hRow != 0);

		HRESULT hr;
		if( m_pXMLAccessor == NULL )
		{
			ATLTRY(m_pXMLAccessor = new CXMLAccessor);
			if( m_pXMLAccessor == NULL )
				return E_OUTOFMEMORY;
			hr = m_pXMLAccessor->BindColumns( m_spRowset );
			if( FAILED(hr) )
			{
				delete m_pXMLAccessor;
				m_pXMLAccessor = NULL;
				return hr;
			}
		}

		ATLASSUME( m_pXMLAccessor != NULL );

		hr = m_spRowset->GetData(m_hRow, m_pXMLAccessor->GetHAccessor(0), m_pXMLAccessor->GetBuffer());
		if( FAILED(hr) )
			return hr;

		hr = m_pXMLAccessor->GetXMLRowData( strOutput, bAppend );

		m_pXMLAccessor->FreeRecordMemory( GetInterface() );
		return hr;
	}

	// Release any retrieved row handles and then release the rowset
	void Close() throw()
	{
		if( m_pXMLAccessor != NULL )
		{
			if (m_spRowset != NULL)
				m_pXMLAccessor->ReleaseAccessors( m_spRowset );
			delete m_pXMLAccessor;
			m_pXMLAccessor = NULL;
		}
		if (m_spRowset != NULL)
		{
			m_pAccessor->FreeRecordMemory(m_spRowset);
			ReleaseRows();
			m_spRowset.Release();
			m_spRowsetChange.Release();
		}
	}
	// Addref the current row
	HRESULT AddRefRows() throw()
	{
		ATLASSUME(m_spRowset != NULL);
		return m_spRowset->AddRefRows(1, &m_hRow, NULL, NULL);
	}
	// Release the current row
	HRESULT ReleaseRows() throw()
	{
		ATLASSUME(m_spRowset != NULL);
		HRESULT hr = S_OK;

		if (m_hRow != 0)
		{
			hr = m_spRowset->ReleaseRows(1, &m_hRow, NULL, NULL, NULL);
			m_hRow = 0;
		}
		return hr;
	}

	CRowset<>* GetRowsetBase() throw()
	{
		return (CRowset<>*)this;
	}

	// Compare two bookmarks with each other
	HRESULT Compare(
		_In_ const CBookmarkBase& bookmark1,
		_In_ const CBookmarkBase& bookmark2,
		_Out_ DBCOMPARE* pComparison) const throw()
	{
		ATLASSUME(m_spRowset != NULL);
		CComPtr<IRowsetLocate> spLocate;
		HRESULT hr = m_spRowset.QueryInterface(&spLocate);
		if (FAILED(hr))
			return hr;

		return spLocate->Compare(NULL, bookmark1.GetSize(), bookmark1.GetBuffer(),
			bookmark2.GetSize(), bookmark2.GetBuffer(), pComparison);
	}

	// Compare the passed hRow with the current row
	HRESULT IsSameRow(_In_ HROW hRow) const throw()
	{
		ATLASSUME(m_spRowset != NULL);
		if (m_hRow == hRow)
			return S_OK;

		CComPtr<IRowsetIdentity> spRowsetIdentity;
		HRESULT hr = m_spRowset.QueryInterface(&spRowsetIdentity);
		if (FAILED(hr))
			return hr;

		return spRowsetIdentity->IsSameRow(m_hRow, hRow);
	}

	// Move to the previous record
	HRESULT MovePrev() throw()
	{
		// the following line of code may fail if the DBPROP_CANFETCHBACKWARDS and/or
		// DBPROP_CANSCROLLBACKWARDS properties have not been set.
		return MoveNext(-2);
	}

	// Move to the next record
	HRESULT MoveNext() throw()
	{
		return MoveNext(0);
	}

	// Move lSkip records forward or backward
	HRESULT MoveNext(
		_In_ LONG lSkip,
		_In_ bool bForward = true) throw()
	{
		HRESULT hr;
		DBCOUNTITEM ulRowsFetched = 0;

		// Check the data was opened successfully and the accessor
		// has been set.
		ATLASSUME(m_spRowset != NULL);
		ATLASSUME(m_pAccessor != NULL);

		m_pAccessor->FreeRecordMemory(m_spRowset);
		// Release a row if one is already around
		ReleaseRows();

		// Get the row handle
		HROW* phRow = &m_hRow;
		hr = m_spRowset->GetNextRows(0, lSkip, (bForward) ? 1 : -1, &ulRowsFetched, &phRow);
		if (hr != S_OK)
			return hr;

		// Get the data
		hr = GetData();
		if (FAILED(hr))
		{
			ATLTRACE(atlTraceDBClient, 0, _T("GetData failed - HRESULT = 0x%X\n"),hr);
			ReleaseRows();
		}
		return hr;
	}

	// Move to the first record
	HRESULT MoveFirst() throw()
	{
		HRESULT hr;

		// Check the data was opened successfully and the accessor
		// has been set.
		ATLASSUME(m_spRowset != NULL);
		ATLASSUME(m_pAccessor != NULL);

		m_pAccessor->FreeRecordMemory(m_spRowset);
		// Release a row if one is already around
		ReleaseRows();

		// the call to RestartPosition may fail if the DBPROP_CANFETCHBACKWARDS and/or
		// DBPROP_CANSCROLLBACKWARDS properties have not been set.
		hr = m_spRowset->RestartPosition(NULL);
		if (FAILED(hr))
			return hr;

		// Get the data
		return MoveNext();
	}

	// Move to the last record
	HRESULT MoveLast() throw()
	{
		// Check the data was opened successfully and the accessor
		// has been set.
		ATLASSUME(m_spRowset != NULL);
		ATLASSUME(m_pAccessor != NULL);

		// Release a row if one is already around
		m_pAccessor->FreeRecordMemory(m_spRowset);
		ReleaseRows();

		HRESULT hr;
		DBCOUNTITEM ulRowsFetched = 0;
		HROW* phRow = &m_hRow;

		// Restart the rowset position and then move backwards

		// the call to RestartPosition may fail if the DBPROP_CANFETCHBACKWARDS and/or
		// DBPROP_CANSCROLLBACKWARDS properties have not been set.
		m_spRowset->RestartPosition(NULL);
		hr = m_spRowset->GetNextRows(NULL, -1, 1, &ulRowsFetched, &phRow);
		if (hr != S_OK)
			return hr;

		// Get the data
		hr = GetData();
		if (FAILED(hr))
		{
			ATLTRACE(atlTraceDBClient, 0, _T("GetData from MoveLast failed - HRESULT = 0x%X\n"),hr);
			ReleaseRows();
		}

		return S_OK;
	}
	// Move to the passed bookmark
	HRESULT MoveToBookmark(
		_In_ const CBookmarkBase& bookmark,
		_In_ LONG lSkip = 0) throw()
	{
		// Check the data was opened successfully and the accessor
		// has been set.
		ATLASSUME(m_spRowset != NULL);
		ATLASSUME(m_pAccessor != NULL);

		CComPtr<IRowsetLocate> spLocate;
		HRESULT hr = m_spRowset.QueryInterface(&spLocate);
		if (FAILED(hr))
			return hr;

		m_pAccessor->FreeRecordMemory(m_spRowset);
		// Release a row if one is already around
		ReleaseRows();

		DBCOUNTITEM ulRowsFetched = 0;
		HROW* phRow = &m_hRow;
		hr = spLocate->GetRowsAt(NULL, NULL, bookmark.GetSize(), bookmark.GetBuffer(),
			lSkip, 1, &ulRowsFetched, &phRow);
		// Note we're not using SUCCEEDED here, because we could get DB_S_ENDOFROWSET
		if (hr != S_OK)
			return hr;

		// Get the data
		hr = GetData();
		if (FAILED(hr))
		{
			ATLTRACE(atlTraceDBClient, 0, _T("GetData from Bookmark failed - HRESULT = 0x%X\n"),hr);
			ReleaseRows();
		}

		return S_OK;
	}

	// Get the data for the current record
	HRESULT GetData() throw()
	{
		HRESULT hr = S_OK;
		ATLASSUME(m_pAccessor != NULL);

		ULONG nAccessors = m_pAccessor->GetNumAccessors();
		for (ULONG i=0; i<nAccessors; i++)
		{
			if (m_pAccessor->IsAutoAccessor(i))
			{
				hr = GetData(i);
				if (FAILED(hr))
					return hr;
			}
		}
		return hr;
	}

	// Get the data for the passed accessor. Use for a non-auto accessor
	HRESULT GetData(_In_ int nAccessor) throw()
	{
		ATLASSUME(m_spRowset != NULL);
		ATLASSUME(m_pAccessor != NULL);
		ATLASSUME(m_hRow != 0);

		// Note that we are using the specified buffer if it has been set,
		// otherwise we use the accessor for the data.
		return m_spRowset->GetData(m_hRow, m_pAccessor->GetHAccessor(nAccessor), m_pAccessor->GetBuffer());
	}

	// Get the data for the passed accessor. Use for a non-auto accessor
	HRESULT GetDataHere(
		_In_ int nAccessor,
		_Out_ void* pBuffer) throw()
	{
		ATLASSUME(m_spRowset != NULL);
		ATLASSUME(m_pAccessor != NULL);
		ATLASSUME(m_hRow != 0);

		// Note that we are using the specified buffer if it has been set,
		// otherwise we use the accessor for the data.
		return m_spRowset->GetData(m_hRow, m_pAccessor->GetHAccessor(nAccessor), pBuffer);
	}

	HRESULT GetDataHere(_Out_ void* pBuffer) throw()
	{
		HRESULT hr = S_OK;

		ULONG nAccessors = m_pAccessor->GetNumAccessors();
		for (ULONG i=0; i<nAccessors; i++)
		{
			hr = GetDataHere(i, pBuffer);
			if (FAILED(hr))
				return hr;
		}
		return hr;
	}

	// Insert the current record
	HRESULT Insert(
		_In_ int nAccessor = 0,
		_In_ bool bGetHRow = false) throw()
	{
		ATLASSUME(m_pAccessor != NULL);
		HRESULT hr;
		if (m_spRowsetChange != NULL)
		{
			HROW* pHRow;
			if (bGetHRow)
			{
				ReleaseRows();
				pHRow = &m_hRow;
			}
			else
				pHRow = NULL;

			hr = m_spRowsetChange->InsertRow(NULL, m_pAccessor->GetHAccessor(nAccessor),
					m_pAccessor->GetBuffer(), pHRow);

		}
		else
			hr = E_NOINTERFACE;

		return hr;
	}

	// Delete the current record
	HRESULT Delete() const throw()
	{
		ATLASSUME(m_pAccessor != NULL);
		HRESULT hr;
		if (m_spRowsetChange != NULL)
			hr = m_spRowsetChange->DeleteRows(NULL, 1, &m_hRow, NULL);
		else
			hr = E_NOINTERFACE;

		return hr;
	}

	// Update the current record
	HRESULT SetData() const throw()
	{
		ATLASSUME(m_pAccessor != NULL);
		HRESULT hr = S_OK;

		ULONG nAccessors = m_pAccessor->GetNumAccessors();
		for (ULONG i=0; i<nAccessors; i++)
		{
			hr = SetData(i);
			if (FAILED(hr))
				return hr;
		}
		return hr;
	}

	// Update the current record with the data in the passed accessor
	HRESULT SetData(_In_ int nAccessor) const throw()
	{
		ATLASSUME(m_pAccessor != NULL);
		HRESULT hr;
		if (m_spRowsetChange != NULL)
		{
			hr = m_spRowsetChange->SetData(m_hRow, m_pAccessor->GetHAccessor(nAccessor),
				m_pAccessor->GetBuffer());
		}
		else
			hr = E_NOINTERFACE;

		return hr;
	}

	// Get the data most recently fetched from or transmitted to the data source.
	// Does not get values based on pending changes.
	HRESULT GetOriginalData() throw()
	{
		ATLASSUME(m_spRowset != NULL);
		ATLASSUME(m_pAccessor != NULL);

		HRESULT hr = S_OK;
		CComPtr<IRowsetUpdate> spRowsetUpdate;
		hr = m_spRowset->QueryInterface(&spRowsetUpdate);
		if (FAILED(hr))
			return hr;

		ULONG nAccessors = m_pAccessor->GetNumAccessors();
		for (ULONG i = 0; i < nAccessors; i++)
		{
			hr = spRowsetUpdate->GetOriginalData(m_hRow, m_pAccessor->GetHAccessor(i), m_pAccessor->GetBuffer());
			if (FAILED(hr))
				return hr;
		}
		return hr;
	}

	// Get the status of the current row
	HRESULT GetRowStatus(_Out_ DBPENDINGSTATUS* pStatus) const throw()
	{
		ATLASSUME(m_spRowset != NULL);
		ATLASSERT(pStatus != NULL);

		CComPtr<IRowsetUpdate> spRowsetUpdate;
		HRESULT hr = m_spRowset->QueryInterface(&spRowsetUpdate);
		if (FAILED(hr))
			return hr;

		return spRowsetUpdate->GetRowStatus(NULL, 1, &m_hRow, pStatus);
	}

	// Undo any changes made to the current row since it was last fetched or Update
	// was called for it
	HRESULT Undo(
		_In_opt_ DBCOUNTITEM* pcRows = NULL,
		_Out_opt_ HROW* phRow = NULL,
		_Out_opt_ DBROWSTATUS* pStatus = NULL) throw()
	{
		ATLASSUME(m_spRowset != NULL);

		CComPtr<IRowsetUpdate> spRowsetUpdate;
		HRESULT hr = m_spRowset->QueryInterface(&spRowsetUpdate);
		if (FAILED(hr))
			return hr;

		CComHeapPtr<HROW> sprgRows;
		CComHeapPtr<DBROWSTATUS> spRowStatus;

		if (phRow != NULL)
			hr = spRowsetUpdate->Undo(NULL, 1, &m_hRow, pcRows, &sprgRows, &spRowStatus);
		else
			hr = spRowsetUpdate->Undo(NULL, 1, &m_hRow, pcRows, NULL, &spRowStatus);

		if (phRow != NULL && sprgRows != NULL)
			*phRow = *sprgRows;

		if (pStatus != NULL && spRowStatus != NULL)
			*pStatus = *spRowStatus;

		return hr;
	}

	// Transmits any pending changes made to a row since it was last fetched or Update was
	// called for it. Also see SetData.
	HRESULT Update(
		_In_opt_ DBCOUNTITEM* pcRows = NULL,
		_Out_opt_ HROW* phRow = NULL,
		_Out_opt_ DBROWSTATUS* pStatus = NULL) throw()
	{
		ATLASSUME(m_spRowset != NULL);

		CComPtr<IRowsetUpdate> spRowsetUpdate;
		HRESULT hr = m_spRowset->QueryInterface(&spRowsetUpdate);
		if (FAILED(hr))
			return hr;

		CComHeapPtr<HROW>           sprgRows;
		CComHeapPtr<DBROWSTATUS>    spRowStatus;

		if (phRow != NULL)
			hr = spRowsetUpdate->Update(NULL, 1, &m_hRow, pcRows, &sprgRows, &spRowStatus);
		else
			hr = spRowsetUpdate->Update(NULL, 1, &m_hRow, pcRows, NULL, &spRowStatus);

		if (phRow != NULL && sprgRows != NULL)
			*phRow = *sprgRows;

		if (pStatus != NULL && spRowStatus != NULL)
			*pStatus = *spRowStatus;

		return hr;
	}
	// Transmits any pending changes to all rows made since it was last fetched or Update was
	// alled for it.  Differs from Update in that it will do every row (even if we don't hold
	// the handle for it).
	HRESULT UpdateAll(
		_In_opt_ DBCOUNTITEM* pcRows = NULL,
		_Deref_opt_out_ HROW** pphRow = NULL,
		_Deref_opt_out_ DBROWSTATUS** ppStatus = NULL) throw()
	{
		ATLASSUME(m_spRowset != NULL);

		CComPtr<IRowsetUpdate> spRowsetUpdate;
		HRESULT hr = m_spRowset->QueryInterface(&spRowsetUpdate);
		if (FAILED(hr))
			return hr;

		// Create some temporary variables to help with debugging.
		DBCOUNTITEM		cRowsReturned = 0;
		CComHeapPtr<HROW>			sprgRows;
		CComHeapPtr<DBROWSTATUS>	spRowStatus;

		// Passing zero for the 2nd parameter tells the provider to update ALL pending rows.
		// The 3rd parameter, prghRows is ignored.
		hr =  spRowsetUpdate->Update(NULL, 0, NULL, &cRowsReturned, &sprgRows, &spRowStatus);

		// NOTE, the user must CoTaskMemFree *pphRow and *ppStatus after return, if they
		// are non-NULL.  Otherwise, we'll CoTaskMemFree if they are NULL.
		if (pcRows != NULL)
			*pcRows = cRowsReturned;

		if (pphRow != NULL)
			*pphRow = sprgRows.Detach();

		if (ppStatus != NULL)
			*ppStatus = spRowStatus.Detach();

		return hr;
	}

	// Get the approximate position of the row corresponding to the passed bookmark
	HRESULT GetApproximatePosition(
		_In_ const CBookmarkBase* pBookmark,
		_Out_opt_ DBCOUNTITEM* pPosition,
		_Out_opt_ DBCOUNTITEM* pcRows) throw()
	{
		ATLASSUME(m_spRowset != NULL);

		CComPtr<IRowsetScroll> spRowsetScroll;
		HRESULT hr = m_spRowset->QueryInterface(&spRowsetScroll);
		if (SUCCEEDED(hr))
		{
			if (pBookmark != NULL)
				hr = spRowsetScroll->GetApproximatePosition(NULL, pBookmark->GetSize(), pBookmark->GetBuffer(),
						pPosition, pcRows);
			else
				hr = spRowsetScroll->GetApproximatePosition(NULL, 0, NULL, pPosition, pcRows);

		}
		return hr;

	}
	// Move to a fractional position in the rowset
	HRESULT MoveToRatio(
		_In_ DBCOUNTITEM nNumerator,
		_In_ DBCOUNTITEM nDenominator,
		_In_ bool bForward = true) throw()
	{
		ATLASSUME(m_spRowset != NULL);
		DBCOUNTITEM nRowsFetched;

		CComPtr<IRowsetScroll> spRowsetScroll;
		HRESULT hr = m_spRowset->QueryInterface(&spRowsetScroll);
		if (FAILED(hr))
			return hr;

		m_pAccessor->FreeRecordMemory(m_spRowset);
		ReleaseRows();
		HROW* phRow = &m_hRow;
		hr = spRowsetScroll->GetRowsAtRatio(NULL, NULL, nNumerator, nDenominator, (bForward) ? 1 : -1,
			&nRowsFetched, &phRow);
		// Note we're not using SUCCEEDED here, because we could get DB_S_ENDOFROWSET
		if (hr == S_OK)
			hr = GetData();

		return hr;
	}

	HRESULT FindNextRow(
		_In_ DBCOMPAREOP op,
		_In_ BYTE* pData,
		_In_ DBTYPE wType,
		_In_ DBLENGTH nLength,
		_In_ BYTE bPrecision,
		_In_ BYTE bScale,
		_In_ BOOL bSkipCurrent = TRUE,
		_In_opt_ CBookmarkBase* pBookmark = NULL) throw()
	{
		ATLASSUME(m_spRowset != NULL);
		DBBINDING   binding;
		HRESULT     hr;
		HACCESSOR   hAccessor;
		DBCOUNTITEM ulRowsFetched = 0;
		HROW*       phRow = &m_hRow;
		DBLENGTH    cbBookmark;
		BYTE*       pBookmarkBuffer;
		CComQIPtr<IAccessor, &__uuidof(IAccessor)>        spAccessor(m_spRowset);
		CComQIPtr<IRowsetFind, &__uuidof(IRowsetFind)>    spRowsetFind(m_spRowset);

		if (spAccessor == NULL || spRowsetFind == NULL)
			return E_NOINTERFACE;

		TAccessor::Bind(&binding, 1, wType, nLength, bPrecision, bScale, DBPARAMIO_NOTPARAM, 0);
		hr = CAccessorBase::BindEntries(&binding, 1, &hAccessor, nLength, spAccessor);
		if (FAILED(hr))
			return hr;

		if (pBookmark == NULL)
		{
			cbBookmark = 0;
			pBookmarkBuffer = NULL;
		}
		else
		{
			cbBookmark = pBookmark->GetSize();
			pBookmarkBuffer = pBookmark->GetBuffer();
		}

		hr = spRowsetFind->FindNextRow(DB_NULL_HCHAPTER, hAccessor, pData, op, cbBookmark, pBookmarkBuffer,
					bSkipCurrent, 1,  &ulRowsFetched, &phRow);
		// Note we're not using SUCCEEDED here, because we could get DB_S_ENDOFROWSET
		if (hr != S_OK)
			return hr;

		// Get the data
		hr = GetData();
		spAccessor->ReleaseAccessor(hAccessor, NULL);
		if (FAILED(hr))
		{
			ATLTRACE(_T("ATL: GetData from FindNextRows failed - HRESULT = 0x%X\n"),hr);
			ReleaseRows();
		}
		return S_OK;
	}

// Implementation
	static const IID& GetIID() throw()
	{
		return __uuidof(IRowset);
	}

	IRowset* GetInterface() const throw()
	{
		return m_spRowset;
	}

	IRowset** GetInterfacePtr() throw()
	{
		return &m_spRowset;
	}

	void SetupOptionalRowsetInterfaces() throw()
	{
		// Cache IRowsetChange if available
		if (m_spRowset != NULL)
			m_spRowset->QueryInterface(&m_spRowsetChange);
	}

	HRESULT BindFinished() const throw()
	{
		return S_OK;
	}

	void SetAccessor(_In_opt_ TAccessor* pAccessor) throw()
	{
		m_pAccessor = pAccessor;
	}

	CComPtr<IRowset>        m_spRowset;
	CComPtr<IRowsetChange>  m_spRowsetChange;
	TAccessor*				m_pAccessor;
	HROW                    m_hRow;
	CXMLAccessor* m_pXMLAccessor;
};

///////////////////////////////////////////////////////////////////////////
// class CBulkRowset

template <class TAccessor>
class CBulkRowset : 
	public CRowset<TAccessor>
{
public:
	CBulkRowset()
	{
		// Default the number of rows to bulk fetch to 10
		m_nRows = 10;
		m_hr    = S_OK;
		m_phRow = NULL;
	}

	~CBulkRowset()
	{
		Close();
	}

	void Close() throw()
	{
		if (m_spRowset != NULL)
		{
			m_pAccessor->FreeRecordMemory(m_spRowset);
			ReleaseRows();
		}
		CRowset<TAccessor>::Close();

		delete [] m_phRow;
		m_phRow = NULL;

		m_hr = S_OK;
	}
	// Set the number of row handles that will be retrieved in each
	// bulk row fetch. The default is 10 and this function must be called
	// before Open if you wish to change it.
	void SetRows(_In_ DBROWCOUNT nRows) throw()
	{
		if (nRows == 0)
			nRows = 10;
		if (nRows != m_nRows)
		{
			// This function must be called before the memory is allocated
			// during binding or between a Close() and a Open()
			delete m_phRow;
			m_phRow = NULL;
			m_nRows = nRows;
		}
	}
	// AddRef all the currently retrieved row handles
	HRESULT AddRefRows() throw()
	{
		ATLASSUME(m_spRowset != NULL);
		return m_spRowset->AddRefRows(m_nCurrentRows, m_phRow, NULL, NULL);
	}
	// Release all the currently retrieved row handles
	HRESULT ReleaseRows() throw()
	{
		ATLASSUME(m_spRowset != NULL);
		// We're going to Release the rows so reset the current row position
		m_nCurrentRow = 0;
		m_hRow        = 0;
		DBCOUNTITEM nCurrentRows = m_nCurrentRows;
		m_nCurrentRows = 0;
		return m_spRowset->ReleaseRows(nCurrentRows, m_phRow, NULL, NULL, NULL);
	}
	// Move to the first record
	HRESULT MoveFirst() throw()
	{
		ATLASSUME(m_spRowset != NULL);

		m_hr = S_OK;
		m_pAccessor->FreeRecordMemory(m_spRowset);
		ReleaseRows();
		// the following line of code may fail if the DBPROP_CANFETCHBACKWARDS and/or
		// DBPROP_CANSCROLLBACKWARDS properties have not been set.
		HRESULT hr = m_spRowset->RestartPosition(NULL);
		if (FAILED(hr))
			return hr;

		// Get the data
		return MoveNext(0);
	}
	// Move to the last record
	HRESULT MoveLast() throw()
	{
		m_hr = S_OK;
		m_pAccessor->FreeRecordMemory(m_spRowset);
		ReleaseRows();
		m_hr = S_OK;
		// the following line of code may fail if the DBPROP_CANFETCHBACKWARDS and/or
		// DBPROP_CANSCROLLBACKWARDS properties have not been set.
		return CRowset<TAccessor>::MoveLast();
	}
	// Move to the next record
	HRESULT MoveNext() throw()
	{
		return MoveNext(0);
	}
	// Move to the previous record
	HRESULT MovePrev() throw()
	{
		// the following line of code may fail if the DBPROP_CANFETCHBACKWARDS and/or
		// DBPROP_CANSCROLLBACKWARDS properties have not been set.
		return MoveNext(-2);
	}
	// Move lSkip records forward or backward
	HRESULT MoveNext(
		_In_ DBROWOFFSET lSkip,
		_In_ bool bForward = true) throw()
	{
		ATLASSUME(m_spRowset != NULL);
		ATLASSUME(m_phRow    != NULL);

		m_pAccessor->FreeRecordMemory(m_spRowset);

		// Calculate the record index in the buffer
		DBROWOFFSET nNewRow = m_nCurrentRow + lSkip + (bForward ? 1 : -1);

		bool bFetchNewRows = false;
		// Is the row in the buffer?
		// else adjust the skip value
		if (m_nCurrentRows == 0)
		{
			//lSkip = 0;
			bFetchNewRows = true;
		}
		else if (nNewRow >= (DBROWOFFSET)m_nCurrentRows)
		{
			bFetchNewRows = true;
			lSkip = nNewRow - m_nCurrentRows + (bForward ? 0 : (2 - m_nRows));
		}
		else if (nNewRow < 0)
		{
			lSkip = nNewRow - (m_nCurrentRows - m_nCurrentRow) + (bForward ? 0 : (2 - m_nRows));
			bFetchNewRows = true;
		}

		if (bFetchNewRows)
		{
			nNewRow = 0;
			// If we've reached the end of the buffer and we had a non S_OK HRESULT from
			// the last call to GetNextRows then return that HRESULT now.
			if (m_hr != S_OK && m_hr != DB_S_ROWLIMITEXCEEDED)
				return m_hr;

			// We've finished with these rows so we need some more
			// First release any HROWs that we have
			ReleaseRows();

			// the following line of code may fail if the DBPROP_CANFETCHBACKWARDS and/or
			// DBPROP_CANSCROLLBACKWARDS properties have not been set and the lSkip offset is negative.
			m_hr = m_spRowset->GetNextRows(NULL, lSkip, m_nRows, &m_nCurrentRows, &m_phRow);

			// If we have an error HRESULT or we haven't retrieved any rows then return
			// the HRESULT now.
			if (FAILED(m_hr) || m_nCurrentRows == 0)
				return m_hr;
			if (!bForward)
				nNewRow = m_nCurrentRows - 1;
		}

		// Get the data for the current row
		m_hRow = m_phRow[m_nCurrentRow = nNewRow];
		return GetData();
	}
	// Move to the passed bookmark
	HRESULT MoveToBookmark(
		_In_ const CBookmarkBase& bookmark,
		_In_ DBCOUNTITEM lSkip = 0) throw()
	{
		ATLASSUME(m_spRowset != NULL);
		CComPtr<IRowsetLocate> spLocate;
		HRESULT hr = m_spRowset->QueryInterface(&spLocate);
		if (FAILED(hr))
			return hr;

		m_pAccessor->FreeRecordMemory(m_spRowset);
		ReleaseRows();
		m_hr = spLocate->GetRowsAt(NULL, NULL, bookmark.GetSize(), bookmark.GetBuffer(),
			lSkip, m_nRows, &m_nCurrentRows, &m_phRow);
		if( (m_hr != S_OK || m_nCurrentRows == 0 ) && m_hr != DB_S_ENDOFROWSET)
			return m_hr;

		// Get the data
		m_hRow = m_phRow[m_nCurrentRow];
		return GetData();
	}
	// Move to a fractional position in the rowset
	HRESULT MoveToRatio(
		_In_ DBCOUNTITEM nNumerator,
		_In_ DBCOUNTITEM nDenominator) throw()
	{
		ATLASSUME(m_spRowset != NULL);

		CComPtr<IRowsetScroll> spRowsetScroll;
		HRESULT hr = m_spRowset->QueryInterface(&spRowsetScroll);
		if (FAILED(hr))
			return hr;

		m_pAccessor->FreeRecordMemory(m_spRowset);
		ReleaseRows();
		m_hr = spRowsetScroll->GetRowsAtRatio(NULL, NULL, nNumerator, nDenominator, m_nRows, &m_nCurrentRows, &m_phRow);
		if (m_hr != S_OK || m_nCurrentRows == 0)
			return m_hr;

		// Get the data
		m_hRow = m_phRow[m_nCurrentRow];
		return GetData();
	}
	// Insert the current record
	HRESULT Insert(
		_In_ int nAccessor = 0,
		_In_ bool bGetHRow = false) throw()
	{
		ReleaseRows();
		return CRowset< TAccessor >::Insert(nAccessor, bGetHRow);
	}

// Implementation
	HRESULT BindFinished() throw()
	{
		// No rows in the buffer yet
		m_nCurrentRows = 0;
		// Cause MoveNext to automatically perform a new bulk fetch the first time
		m_nCurrentRow  = 0;
		m_hr = S_OK;

		// Do not allocate if the buffer has been allocated by a previous call to BindFinished.
		if (m_phRow == NULL)
		{
			ATLTRY(m_phRow = new HROW[m_nRows]);
			if (m_phRow == NULL)
				return E_OUTOFMEMORY;
		}

		return S_OK;
	}

	HRESULT m_hr;           // HRESULT to return from MoveNext at end of buffer
	HROW*   m_phRow;        // Pointer to array of HROWs for each row in buffer
	DBROWCOUNT   m_nRows;        // Number of rows that will fit in the buffer
	DBCOUNTITEM  m_nCurrentRows; // Number of rows currently in the buffer
	DBCOUNTITEM  m_nCurrentRow;
};

/////////////////////////////////////////////////////////////////////////////
// Large Block Allocation Helper - CVBufHelper & CVirtualBuffer
template <class T>
class CVBufHelper
{
public:
	virtual T* operator()(_In_opt_ T* pCurrent)
	{
		return pCurrent;
	}
};

template <class T>
class CVirtualBuffer
{
protected:
	CVirtualBuffer()
	{
	}
	T* m_pTop;
	int m_nMaxElements;
public:
	T* m_pBase;
	T* m_pCurrent;
	explicit CVirtualBuffer(_In_ int nMaxElements)
	{
		//in case of overflow throw exception
		ATLENSURE(nMaxElements>=0);

		ATLENSURE(nMaxElements <=size_t(-1)/sizeof(T)); //overflow check
		m_nMaxElements = nMaxElements;
 		m_pBase = (T*) VirtualAlloc(NULL,sizeof(T)*nMaxElements,	MEM_RESERVE, PAGE_READWRITE);
		if(m_pBase == NULL)
		{
			_AtlRaiseException((DWORD)STATUS_NO_MEMORY);
		}
		m_pTop = m_pCurrent = m_pBase;
		// Commit first page - chances are this is all that will be used
		VirtualAlloc(m_pBase, sizeof(T), MEM_COMMIT, PAGE_READWRITE);
	}
	~CVirtualBuffer()
	{
		VirtualFree(m_pBase, 0, MEM_RELEASE);
	}
	int Except(_In_ LPEXCEPTION_POINTERS lpEP)
	{
		EXCEPTION_RECORD* pExcept = lpEP->ExceptionRecord;
		if (pExcept->ExceptionCode != EXCEPTION_ACCESS_VIOLATION)
			return EXCEPTION_CONTINUE_SEARCH;
		BYTE* pAddress = (LPBYTE) pExcept->ExceptionInformation[1];

		// The address is out of this buffer arrange means AV is not conflicted with this buffer.
		BYTE* pTmp = reinterpret_cast<BYTE*>(m_pBase);
		if ((pAddress < pTmp) || (pAddress >= pTmp + (sizeof(T) * m_nMaxElements)))
			return EXCEPTION_CONTINUE_SEARCH;

		VirtualAlloc(pAddress, sizeof(T), MEM_COMMIT, PAGE_READWRITE);
		return EXCEPTION_CONTINUE_EXECUTION;
	}
	bool Seek(_In_ int nElement)
	{
		ATLASSERT(nElement >= 0 && nElement < m_nMaxElements);
		if(nElement < 0 || nElement >= m_nMaxElements)
			return false;
		m_pCurrent = &m_pBase[nElement];
		return true;
	}

#define ATL_DBCLI_BEGIN_VBUF_GUARDED_REGION()							\
	__pragma(warning(push))												\
	/* we never return EXCEPTION_EXECUTE_HANDLER in Except */			\
	/* hence, we can safely ignore this warning about the handler */	\
	/* being empty */													\
	__pragma(warning(disable:6322))										\
	__try																\
	{																	\
		/**/
# define ATL_DBCLI_END_VBUF_GUARDED_REGION()							\
	} /* try { */														\
	__except(Except(GetExceptionInformation()))							\
	{																	\
		/*EMPTY*/														\
	}																	\
	__pragma(warning(pop))												\
		/**/

	void SetAt(
		_In_ int nElement,
		_In_ const T& Element)
	{
		ATLASSERT(nElement >= 0 && nElement < m_nMaxElements);

		ATL_DBCLI_BEGIN_VBUF_GUARDED_REGION()
			T* p = &m_pBase[nElement];
			*p = Element;
			m_pTop = p++ > m_pTop ? p : m_pTop;
		ATL_DBCLI_END_VBUF_GUARDED_REGION()
	}
	template <class Q>
	void WriteBulk(_In_ Q& helper)
	{
		ATL_DBCLI_BEGIN_VBUF_GUARDED_REGION()
			m_pCurrent = helper(m_pBase);
			m_pTop = m_pCurrent > m_pTop ? m_pCurrent : m_pTop;
		ATL_DBCLI_END_VBUF_GUARDED_REGION()
	}
	void Write(_In_ const T& Element)
	{
		ATL_DBCLI_BEGIN_VBUF_GUARDED_REGION()
			*m_pCurrent = Element;
			m_pCurrent++;
			m_pTop = m_pCurrent > m_pTop ? m_pCurrent : m_pTop;
		ATL_DBCLI_END_VBUF_GUARDED_REGION()
	}
	T& Read()
	{
		return *m_pCurrent;
	}
	_Ret_opt_z_ operator BSTR()
	{
		BSTR bstrTemp = NULL ;
		ATL_DBCLI_BEGIN_VBUF_GUARDED_REGION()
			bstrTemp = SysAllocStringByteLen((char*) m_pBase,
				(UINT) ((BYTE*)m_pTop - (BYTE*)m_pBase));
		ATL_DBCLI_END_VBUF_GUARDED_REGION()
		return bstrTemp;
	}
	const T& operator[](_In_ int nElement) const
	{
		if(nElement < 0 || nElement >= m_nMaxElements)
			_AtlRaiseException((DWORD)EXCEPTION_ARRAY_BOUNDS_EXCEEDED);

		return m_pBase[nElement];
	}
	operator T*()
	{
		return m_pBase;
	}

};


typedef CVirtualBuffer<BYTE> CVirtualBytes;

///////////////////////////////////////////////////////////////////////////
// class CArrayRowset
//
// Allows you to access a rowset with an array syntax. TAccessor must be a
// CAccessor<> type class

template <class TAccessor>
class CArrayRowset :
	public CVirtualBuffer<typename TAccessor::DataClass>,
	protected CBulkRowset<TAccessor>
{
public:
	CArrayRowset(_In_ int nMax = 100000) :
		CVirtualBuffer<TAccessor::DataClass>(nMax)
	{
		m_nRowsRead = 0;
	}
	typename TAccessor::DataClass& operator[](_In_ int nRow)
	{
		ATLASSERT(nRow >= 0);
		if( nRow < 0 )
			AtlThrow(E_INVALIDARG);

		HRESULT hr = S_OK;
		TAccessor::DataClass* pCurrent = m_pBase + m_nRowsRead;

		// Retrieve the row if we haven't retrieved it already
		while ((ULONG)nRow >= m_nRowsRead)
		{
			m_pAccessor->SetBuffer(reinterpret_cast<BYTE*>(pCurrent));
			ATL_DBCLI_BEGIN_VBUF_GUARDED_REGION()
				// Get the row
				hr = MoveNext();
				if (hr != S_OK)
					break;
			ATL_DBCLI_END_VBUF_GUARDED_REGION()
			m_nRowsRead++;
			pCurrent++;
		}

		if(hr != S_OK)
		{
			ATLASSERT(hr != DB_S_ENDOFROWSET);	// if you're getting this assertion, then
												// most likely you are trying to access an
												// out of bounds element of CArrayRowset
												// (ex. table[100].data where table has only
												// 50 records)
			AtlThrow(hr);
		}

		return *(m_pBase + nRow);
	}

	HRESULT Snapshot() throw()
	{
		HRESULT hr = S_FALSE;
		ATLASSUME(m_nRowsRead == 0);
		ATLASSUME(m_spRowset != NULL);
		TAccessor::DataClass* pCurrent = m_pBase;
		m_pAccessor->SetBuffer(reinterpret_cast<BYTE*>(pCurrent));
		ATL_DBCLI_BEGIN_VBUF_GUARDED_REGION()
			hr = MoveFirst();
		ATL_DBCLI_END_VBUF_GUARDED_REGION()
		if (FAILED(hr))
			return hr;
		do
		{
			m_nRowsRead++;
			pCurrent++;
			m_pAccessor->SetBuffer(reinterpret_cast<BYTE*>(pCurrent));
			ATL_DBCLI_BEGIN_VBUF_GUARDED_REGION()
				hr = MoveNext();
			ATL_DBCLI_END_VBUF_GUARDED_REGION()
		} while (SUCCEEDED(hr) &&  hr != DB_S_ENDOFROWSET);

		return (hr == DB_S_ENDOFROWSET) ? S_OK : hr;
	}
	ULONG   m_nRowsRead;
};

#undef ATL_DBCLI_BEGIN_VBUF_GUARDED_REGION
#undef ATL_DBCLI_END_VBUF_GUARDED_REGION

// Used when you don't need any parameters or output columns
class CNoAccessor
{
public:
	// We don't need any typedef's here as the default
	// global typedef is not to have any parameters and
	// output columns.
	HRESULT BindColumns(_In_opt_ IUnknown*) throw()
	{
		return S_OK;
	}
	HRESULT BindParameters(
		_In_opt_ HACCESSOR*,
		_In_opt_ ICommand*,
		_Deref_opt_out_ void**) throw()
	{
		return S_OK;
	}
	void Close() throw()
	{
	}
	HRESULT ReleaseAccessors(_In_opt_ IUnknown*) throw()
	{
		return S_OK;
	}
	void FreeRecordMemory(_Inout_opt_ IRowset* /*pRowset*/) throw()
	{
	}
	void FreeRecordMemory(_In_ int /*nAccessor*/, _Inout_opt_ IRowset* /*pRowset*/) throw()
	{
	}
	HRESULT GetColumnInfo(
		_In_opt_ IRowset*,
		_In_opt_ DBORDINAL*,
		_In_opt_ DBCOLUMNINFO**) throw()
	{
		return E_FAIL;
	}
	ULONG GetNumAccessors() const throw()
	{
		return 0;
	}
	bool IsAutoAccessor(_In_ ULONG /*nAccessor*/) const throw()
	{
		return false;
	}
	HACCESSOR GetHAccessor(_In_ ULONG /*nAccessor*/) const throw()
	{
		return 0;
	}
	BYTE* GetBuffer() const throw()
	{
		ATLASSERT(FALSE);
		return NULL;
	}
	static void Bind(
		_In_opt_ DBBINDING*,
		_In_ DBORDINAL,
		_In_ DBTYPE,
		_In_ DBLENGTH,
		_In_ BYTE,
		_In_ BYTE,
		_In_ DBPARAMIO,
		_In_ DBBYTEOFFSET,
		_In_ DBBYTEOFFSET = 0,
		_In_ DBBYTEOFFSET = 0,
		_In_opt_ DBOBJECT* = NULL) throw()
	{
		ATLASSERT(FALSE);
	}
	bool NoBindOnNullRowset() const throw()
	{
		return false;
	}
};

// Used when a rowset will not be returned from the command
template <class TAccessor = CAccessorBase>
class CNoRowset
{
public:
	HRESULT BindFinished() throw()
	{
		return S_OK;
	}
	void Close() throw()
	{
	}
	static const IID& GetIID() throw()
	{
		return IID_NULL;
	}
	IRowset* GetInterface() const throw()
	{
		return NULL;
	}
	IRowset** GetInterfacePtr() throw()
	{
		return NULL;
	}
	void SetAccessor(_In_opt_ void*) throw()
	{
	}
	void SetupOptionalRowsetInterfaces() throw()
	{
	}
};

// Used with SQL Server 2000, a rowset will not be returned from the command, but instead
// we get an ISequentialStream object and use it to read the data.
template <class TAccessor = CAccessorBase>
class CStreamRowset
{
public:
	// Constructors & destructors
	CStreamRowset()
	{
		m_spStream = NULL;
	}

	~CStreamRowset()
	{
		Close();
	}

	// Methods
	void Close()
	{
		if (m_spStream != NULL)
			m_spStream.Release();
	}

	// Implementation
	static const IID& GetIID()
	{
		return IID_ISequentialStream;
	}
	ISequentialStream* GetInterface() const
	{
		return m_spStream;
	}
	ISequentialStream** GetInterfacePtr()
	{
		return &m_spStream;
	}

	HRESULT BindFinished() throw()
	{
		return S_OK;
	}
	void SetAccessor(_In_opt_ void*) throw()
	{
	}
	void SetupOptionalRowsetInterfaces() throw()
	{
	}

	CComPtr<ISequentialStream> m_spStream;
};


///////////////////////////////////////////////////////////////////////////
// class CAccessor
// T is the class that contains the data that will be accessed.
ATLPREFAST_SUPPRESS(6387)
template <class T>
class CAccessor :
	public CAccessorBase,
	public T
{
public:
	typedef T DataClass;

// Implementation
	HRESULT ReleaseAccessors(_Inout_ IUnknown* pUnk) throw()
	{
		FreeRecordMemory( (IRowset*) pUnk );
		return CAccessorBase::ReleaseAccessors(pUnk);
	}

	// Free's any columns in the current record that need to be freed.
	// E.g. Calls SysFreeString on any BSTR's and Release on any interfaces.
	void FreeRecordMemory(
		_In_ int nAccessor,
		_In_opt_ IRowset* /* pRowset */) throw()
	{
		(nAccessor);
		__if_exists(_GetBindEntries)
		{
			DBORDINAL nColumns;

			// Passing in m_pBuffer tells the column entry maps to free the
			// memory for the types if appropriate
			_GetBindEntries(NULL, &nColumns, NULL, nAccessor, NULL, m_pBuffer);
		}
	}
	void FreeRecordMemory(_Inout_opt_ IRowset* pRowset) throw()
	{
		for (ULONG i = 0; i < GetNumAccessors(); i++)
			FreeRecordMemory(i, pRowset);
	}

	HRESULT GetColumnInfo(
		_In_opt_ IRowset*,
		_In_opt_ DBORDINAL*,
		_Deref_out_opt_ DBCOLUMNINFO** ppColumnInfo) throw()
	{
		ATLASSERT(ppColumnInfo != NULL);
		*ppColumnInfo = NULL;

		return E_FAIL;
	}

	void ClearRecordMemory() throw()
	{
		__if_exists(_GetBindEntries)
		{
			for (ULONG i = 0; i < _OutputColumnsClass::_GetNumAccessors(); i++)
			{
				DBORDINAL nColumns;
				_GetBindEntries(NULL, &nColumns, NULL, i, NULL, m_pBuffer, true);
			}
		}
	}

	HRESULT BindColumns(_Inout_ IUnknown* pUnk) throw()
	{
		HRESULT hr;
		ULONG   nAccessors;
		DBLENGTH  nSize;
		nAccessors = _OutputColumnsClass::_GetNumAccessors();

		SetBuffer((BYTE*)(T*)this);
		ClearRecordMemory();

		nSize = sizeof(T);
		hr = BindAccessors(nAccessors, nSize, pUnk);
		return hr;
	}
	HRESULT BindAccessors(
		_In_ ULONG nAccessors,
		_In_ DBLENGTH nSize,
		_Inout_ IUnknown* pUnk) throw()
	{
		ATLENSURE_RETURN(pUnk != NULL);
		HRESULT hr;

		CComPtr<IAccessor> spAccessor;
		hr = pUnk->QueryInterface(&spAccessor);
		if (SUCCEEDED(hr))
		{
			// Allocate the accessor memory if we haven't done so yet
			if (m_pAccessorInfo == NULL)
			{
				hr = AllocateAccessorMemory(nAccessors);
				if (FAILED(hr))
					return hr;
			}

			for (ULONG i=0; i<nAccessors && SUCCEEDED(hr); i++)
				hr = BindAccessor(spAccessor, i, nSize);
		}

		return hr;
	}

	HRESULT BindAccessor(
		_Inout_ IAccessor* pAccessor,
		_In_ ULONG nAccessor,
		_In_ DBLENGTH nSize) throw()
	{
		CAutoVectorPtr<DBBINDING>	spBindings;
		CAutoVectorPtr<LPOLESTR>	spColumnNames;
		DBORDINAL					nColumns = 0;
		bool						bAuto = false;
		HRESULT						hr;
		CComHeapPtr<DBCOLUMNINFO>	spColumnInfo;
		DBORDINAL					nColumnInfoCount = 0;
		CComHeapPtr<OLECHAR>		spStringsBuffer;

		// First time just get the number of entries by passing in &nColumns
		_OutputColumnsClass::_GetBindEntries(NULL, &nColumns, NULL, nAccessor, NULL);

		ATLASSERT(nColumns > 0);

		// Allocate the binding structures
		if( !spBindings.Allocate(nColumns) )
			return E_OUTOFMEMORY;

		for( ULONG i = 0; i < nColumns; i++ )
			spBindings[i].pObject = NULL;

		// Allocate the column names strings array
		if( !spColumnNames.Allocate(nColumns) )
			return E_OUTOFMEMORY;

		// Now get the bind entries
		hr = _OutputColumnsClass::_GetBindEntries(spColumnNames, &nColumns, spBindings, nAccessor, &bAuto);
		if (SUCCEEDED(hr))
		{
			// translate the columns names to oridinals if necessary
			for( ULONG i = 0; i < nColumns; i++ )
				if( spColumnNames[i] != NULL ) // if a column name was given, translate it to oridinal
				{
					// if necessary, get the column information
					if( spColumnInfo == NULL )
					{
						if( FAILED( GetColumnNames( pAccessor, &spColumnInfo, &spStringsBuffer, &nColumnInfoCount ) ) )
						{
							ATLASSERT( FALSE ); // unable to get columns information
							return E_FAIL;
						}
					}
					if( ! GetOridinalColumnNo(spColumnNames[i], spBindings[i].iOrdinal, spColumnInfo, nColumnInfoCount ) )
					{
						ATLASSERT(FALSE); // unable to match column name to an oridinal !!!
						return E_FAIL;
					}
				}

			m_pAccessorInfo[nAccessor].bAutoAccessor = bAuto;
			hr = BindEntries(spBindings, nColumns, &m_pAccessorInfo[nAccessor].hAccessor, nSize, pAccessor);
		}
		else
		{
			// free any DBBINDING::pObject's
			for( ULONG i = 0; i < nColumns; i++ )
				delete spBindings[i].pObject;

		}
		return hr;
	}

	HRESULT BindParameters(
		_In_ HACCESSOR* pHAccessor,
		_Inout_ ICommand* pCommand,
		_Deref_out_ void** ppParameterBuffer) throw()
	{
		HRESULT				hr = S_OK;
		ATLENSURE_RETURN(ppParameterBuffer);

		// In the static accessor case, the parameter buffer will be T plus the size of CAccessorBase
		*ppParameterBuffer = static_cast<T*>(this);

		// Only bind the parameters if we haven't already done it
		if (*pHAccessor == NULL)
		{
			DBORDINAL					nColumns = 0;
			CAutoVectorPtr<DBBINDING>	spBinding;
			CAutoVectorPtr<LPOLESTR>	spColumnNames;

			CComHeapPtr<DBPARAMINFO>	spParameterInfo;
			DB_UPARAMS					nParameterInfoCount = 0;
			CComHeapPtr<OLECHAR>		spStringsBuffer;

			_ParamClass::_GetParamEntries(NULL, &nColumns, NULL);

			// Allocate the DBPARAMINFO array
			if( !spBinding.Allocate(nColumns) )
				return E_OUTOFMEMORY;

			// Allocate the column names strings array
			if( !spColumnNames.Allocate(nColumns) )
				return E_OUTOFMEMORY;

			hr = _ParamClass::_GetParamEntries(spColumnNames, &nColumns, spBinding);
			if (SUCCEEDED(hr))
			{
				for( ULONG i = 0; i < nColumns; i++ )
				{
					// For bindings in parameter accessors, consumer-owned memory must always be used.
					spBinding[i].dwMemOwner = DBMEMOWNER_CLIENTOWNED;

					// translate the columns names to oridinals if necessary
					if( spColumnNames[i] != NULL ) // if a column name was given, translate it to oridinal
					{
						// if necessary, get the column information
						if( spParameterInfo == NULL )
						{
							if( FAILED( GetParameterNames( pCommand, &spParameterInfo, &spStringsBuffer, &nParameterInfoCount ) ) )
							{
								ATLASSERT( FALSE ); // unable to get columns information
								return E_FAIL;
							}
						}
						if( ! GetOridinalParameterNo(spColumnNames[i], spBinding[i].iOrdinal, spParameterInfo, nParameterInfoCount ) )
						{
							ATLASSERT(FALSE); // unable to match parameter name to an oridinal !!!
							return E_FAIL;
						}
					}
				}

				// Get the IAccessor from the passed ICommand
				ATLENSURE_RETURN(pCommand != NULL);
				CComPtr<IAccessor> spAccessor;
				hr = pCommand->QueryInterface(&spAccessor);
				if (SUCCEEDED(hr))
				{
					hr = BindEntries(spBinding, nColumns, pHAccessor, sizeof(T), spAccessor);
				}
			}
		}
		return hr;
	}

protected:
	bool GetOridinalColumnNo(
		_In_z_ LPCOLESTR pOleColumnName,
		_Out_ DBORDINAL& nColumn,
		_In_count_(nColumns) DBCOLUMNINFO* pColumnInfo,
		_In_ DBORDINAL nColumns) throw()
	{
		ATLASSERT(pOleColumnName != NULL);
		ATLASSERT(pColumnInfo != NULL);

		if( pOleColumnName == NULL || pColumnInfo == NULL )
			return false;

		// Search through the columns trying to find a match
		for (ULONG i = 0; i < nColumns; i++)
		{
			if (pColumnInfo[i].pwszName != NULL && wcscmp(pColumnInfo[i].pwszName, pOleColumnName) == 0)
			{
				nColumn = pColumnInfo[i].iOrdinal;
				return true;
			}
		}
		return false;   // Not Found
	}
	
	HRESULT GetColumnNames(
		_Inout_ IAccessor* pAccessor,
		_Deref_out_ DBCOLUMNINFO** ppColumnInfo,
		_Deref_out_z_ OLECHAR** ppStringsBuffer,
		_Out_ DBORDINAL* pnColumns) throw()
	{
		ATLASSERT( ppColumnInfo != NULL );
		ATLASSERT( ppStringsBuffer != NULL );
		ATLASSERT( pnColumns != NULL );
		ATLASSERT( pAccessor != NULL );

		if( ppColumnInfo == NULL || ppStringsBuffer == NULL || pnColumns == NULL || pAccessor == NULL )
			return E_FAIL;

		CComPtr<IColumnsInfo> spColumnsInfo;
		HRESULT hr = pAccessor->QueryInterface(&spColumnsInfo);
		if (FAILED(hr))
			return hr;

		hr = spColumnsInfo->GetColumnInfo(pnColumns, ppColumnInfo, ppStringsBuffer);
		if (FAILED(hr))
			return hr;

		return S_OK;
	}
	
	bool GetOridinalParameterNo(
		_In_z_ LPCOLESTR pOleParameterName,
		_Out_ DB_UPARAMS& nParameter,
		_In_count_(nParameters) DBPARAMINFO* pParameterInfo,
		_In_ DB_UPARAMS nParameters) throw()
	{
		ATLASSERT(pOleParameterName != NULL);
		ATLASSERT(pParameterInfo != NULL);

		if( pOleParameterName == NULL || pParameterInfo == NULL )
			return false;

		// Search through the columns trying to find a match
		for (ULONG i = 0; i < nParameters; i++)
		{
			if (pParameterInfo[i].pwszName != NULL && wcscmp(pParameterInfo[i].pwszName, pOleParameterName) == 0)
			{
				nParameter = pParameterInfo[i].iOrdinal;
				return true;
			}
		}
		return false;   // Not Found
	}

	HRESULT GetParameterNames(
		_Inout_ ICommand* pCmd,
		_Deref_out_ DBPARAMINFO** ppParameterInfo,
		_Deref_out_z_ OLECHAR** ppStringsBuffer,
		_Out_ DB_UPARAMS* pnParameters) throw()
	{
		ATLASSERT( ppParameterInfo != NULL );
		ATLASSERT( ppStringsBuffer != NULL );
		ATLASSERT( pnParameters != NULL );
		ATLASSERT( pCmd != NULL );

		if( ppParameterInfo == NULL || ppStringsBuffer == NULL || pnParameters == NULL || pCmd == NULL )
			return E_FAIL;

		CComPtr<ICommandWithParameters> spCommandWithParameters;
		HRESULT hr = pCmd->QueryInterface(&spCommandWithParameters);
		if (FAILED(hr))
			return hr;

		hr = spCommandWithParameters->GetParameterInfo(pnParameters, ppParameterInfo, ppStringsBuffer);
		if (FAILED(hr))
			return hr;

		return S_OK;
	}
};
ATLPREFAST_UNSUPPRESS()

enum DBBLOBHANDLINGENUM
{
	DBBLOBHANDLING_DEFAULT,
	DBBLOBHANDLING_NOSTREAMS,
	DBBLOBHANDLING_SKIP
};

///////////////////////////////////////////////////////////////////////////
// CDynamicAccessor
class CDynamicAccessor :
	public CAccessorBase
{
public:
	CDynamicAccessor(
		_In_ DBBLOBHANDLINGENUM eBlobHandling = DBBLOBHANDLING_DEFAULT,
		_In_ DBLENGTH nBlobSize = 8000)
	{
		ATLASSERT( eBlobHandling == DBBLOBHANDLING_DEFAULT ||
				   eBlobHandling == DBBLOBHANDLING_NOSTREAMS ||
				   eBlobHandling == DBBLOBHANDLING_SKIP );

		m_nColumns        = 0;
		m_pColumnInfo     = NULL;
		m_pStringsBuffer  = NULL;
		m_eBlobHandling   = eBlobHandling;
		m_nBlobSize       = nBlobSize;
		m_pfClientOwnedMemRef = NULL;
	};

	~CDynamicAccessor()
	{
		Close();
	}

	HRESULT ReleaseAccessors(_Inout_ IUnknown* pUnk) throw()
	{
		FreeRecordMemory( (IRowset*) pUnk );
		return CAccessorBase::ReleaseAccessors(pUnk);
	}

	bool SetBlobHandling(_In_ DBBLOBHANDLINGENUM eBlobHandling)
	{
		switch( eBlobHandling )
		{
		case DBBLOBHANDLING_DEFAULT:
		case DBBLOBHANDLING_NOSTREAMS:
		case DBBLOBHANDLING_SKIP:
			m_eBlobHandling = eBlobHandling;
			return true;
		default:
			ATLASSERT( FALSE ); // invalid blob handling mode!!!
			return false;
		}
	}

	const DBBLOBHANDLINGENUM GetBlobHandling() const
	{
		return m_eBlobHandling;
	}

	void SetBlobSizeLimit(_In_ DBLENGTH nBlobSize)
	{
		m_nBlobSize = nBlobSize;
	}

	const DBLENGTH GetBlobSizeLimit() const
	{
		return m_nBlobSize;
	}

//	void FreeRecordMemory(int , IRowset* ) throw() {}

	void Close() throw()
	{
		CoTaskMemFree(m_pColumnInfo);
		m_pColumnInfo = NULL;

		// Free the memory for the string buffer returned by IColumnsInfo::GetColumnInfo,
		// if necessary
		CoTaskMemFree(m_pStringsBuffer);
		m_pStringsBuffer = NULL;

		delete [] m_pBuffer;
		m_pBuffer = NULL;

		delete [] m_pfClientOwnedMemRef;
		m_pfClientOwnedMemRef = NULL;

		m_nColumns = 0;

		CAccessorBase::Close();
	}

	bool GetColumnType(
		_In_ DBORDINAL nColumn,
		_Out_ DBTYPE* pType) const throw()
	{
		if (TranslateColumnNo(nColumn))
		{
			ATLENSURE_RETURN_VAL(pType, false);
			*pType = m_pColumnInfo[nColumn].wType;
			return true;
		}
		else
			return false;
	}

	bool GetColumnFlags(
		_In_ DBORDINAL nColumn,
		_Out_ DBCOLUMNFLAGS* pFlags) const throw()
	{
		if (TranslateColumnNo(nColumn))
		{
			ATLENSURE_RETURN_VAL(pFlags, false);
			*pFlags = m_pColumnInfo[nColumn].dwFlags;
			return true;
		}
		else
			return false;
	}
	bool GetOrdinal(
		_In_z_ const CHAR* pColumnName,
		_Out_ DBORDINAL* pOrdinal) const throw()
	{
		ATLENSURE_RETURN_VAL(pColumnName != NULL, false);
		DBORDINAL nColumn;
		if (GetInternalColumnNo(pColumnName, &nColumn))
		{
			ATLENSURE_RETURN_VAL(pOrdinal, false);
			*pOrdinal = m_pColumnInfo[nColumn].iOrdinal;
			return true;
		}
		else
			return false;
	}
	bool GetOrdinal(
		_In_z_ const WCHAR* pColumnName,
		_Out_ DBORDINAL* pOrdinal) const throw()
	{
		ATLENSURE_RETURN_VAL(pColumnName != NULL, false);
		DBORDINAL nColumn;
		if (GetInternalColumnNo(pColumnName, &nColumn))
		{
			ATLENSURE_RETURN_VAL(pOrdinal, false);
			*pOrdinal = m_pColumnInfo[nColumn].iOrdinal;
			return true;
		}
		else
			return false;
	}

	void* GetValue(_In_ DBORDINAL nColumn) const throw()
	{
		if (TranslateColumnNo(nColumn))
			return _GetDataPtr(nColumn);
		else
			return NULL;
	}

	void* GetValue(_In_z_ const CHAR* pColumnName) const throw()
	{
		ATLENSURE_RETURN_VAL(pColumnName != NULL, NULL);
		DBORDINAL nColumn;
		if (GetInternalColumnNo(pColumnName, &nColumn))
			return _GetDataPtr(nColumn);
		else
			return NULL;    // Not Found
	}

	void* GetValue(_In_z_ const WCHAR* pColumnName) const throw()
	{
		ATLENSURE_RETURN_VAL(pColumnName != NULL, NULL);
		DBORDINAL nColumn;
		if (GetInternalColumnNo(pColumnName, &nColumn))
			return _GetDataPtr(nColumn);
		else
			return NULL;    // Not Found
	}

	template <class ctype>
	void _GetValue(
		_In_ DBORDINAL nColumn,
		_Out_ ctype* pData) const throw()
	{
		ATLASSUME(pData != NULL);
		ATLASSUME(m_pColumnInfo[nColumn].ulColumnSize == sizeof(ctype));
		ctype* pBuffer = (ctype*)_GetDataPtr(nColumn);
		*pData = *pBuffer;
	}
	template <class ctype>
	void _SetValue(
		_In_ DBORDINAL nColumn,
		_In_ const ctype& data) throw()
	{
		ATLASSUME(m_pColumnInfo[nColumn].ulColumnSize == sizeof(ctype));
		ctype* pBuffer = (ctype*)_GetDataPtr(nColumn);
		*pBuffer = (ctype)data;
	}
	template <class ctype>
	bool GetValue(
		_In_ DBORDINAL nColumn,
		_Out_ ctype* pData) const throw()
	{
		ATLENSURE_RETURN_VAL(pData, false);
		if (TranslateColumnNo(nColumn))
		{
			_GetValue(nColumn, pData);
			return true;
		}
		return false;
	}
	template <class ctype>
	bool SetValue(
		_In_ DBORDINAL nColumn,
		_In_ const ctype& data) throw()
	{
		if (TranslateColumnNo(nColumn))
		{
			_SetValue(nColumn, data);
			return true;
		}
		return false;
	}
	template <class ctype>
	bool GetValue(
		_In_z_ const CHAR *pColumnName,
		_Out_ ctype* pData) const throw()
	{
		ATLENSURE_RETURN_VAL(pColumnName != NULL, false);
		ATLENSURE_RETURN_VAL(pData, false);
		DBORDINAL nColumn;
		if (GetInternalColumnNo(pColumnName, &nColumn))
		{
			_GetValue(nColumn, pData);
			return true;
		}
		return false;
	}
	template <class ctype>
	bool GetValue(
		_In_z_ const WCHAR *pColumnName,
		_Out_ ctype* pData) const throw()
	{
		ATLENSURE_RETURN_VAL(pColumnName != NULL, false);
		ATLENSURE_RETURN_VAL(pData, false);
		DBORDINAL nColumn;
		if (GetInternalColumnNo(pColumnName, &nColumn))
		{
			_GetValue(nColumn, pData);
			return true;
		}
		return false;
	}
	template <class ctype>
	bool SetValue(
		_In_z_ const CHAR *pColumnName,
		_In_ const ctype& data) throw()
	{
		ATLASSERT(pColumnName != NULL);
		DBORDINAL nColumn;
		if (GetInternalColumnNo(pColumnName, &nColumn))
		{
			_SetValue(nColumn, data);
			return true;
		}
		return false;
	}
	template <class ctype>
	bool SetValue(
		_In_z_ const WCHAR *pColumnName,
		_In_ const ctype& data) throw()
	{
		ATLASSERT(pColumnName != NULL);
		DBORDINAL nColumn;
		if (GetInternalColumnNo(pColumnName, &nColumn))
		{
			_SetValue(nColumn, data);
			return true;
		}
		return false;
	}
	bool GetLength(
		_In_ DBORDINAL nColumn,
		_Out_ DBLENGTH* pLength) const
	{
		ATLENSURE(pLength != NULL);
		if (TranslateColumnNo(nColumn))
		{
			DBBYTEOFFSET nOffset = (DBBYTEOFFSET)(ULONG_PTR)m_pColumnInfo[nColumn].pTypeInfo;
			IncrementAndAlignOffset( nOffset, m_pColumnInfo[nColumn].ulColumnSize, __alignof(DBLENGTH) );
			*pLength = *(DBLENGTH*)( m_pBuffer + nOffset );
			return true;
		}
		else
			return false;
	}
	bool SetLength(
		_In_ DBORDINAL nColumn,
		_In_ DBLENGTH nLength) throw()
	{
		if (TranslateColumnNo(nColumn))
		{
			DBBYTEOFFSET nOffset = (DBBYTEOFFSET)(ULONG_PTR)m_pColumnInfo[nColumn].pTypeInfo;
			IncrementAndAlignOffset( nOffset, m_pColumnInfo[nColumn].ulColumnSize, __alignof(DBLENGTH) );
			*(DBLENGTH*)( m_pBuffer + nOffset ) = nLength;
			return true;
		}
		else
			return false;
	}
	bool GetLength(
		_In_z_ const CHAR* pColumnName,
		_Out_ DBLENGTH* pLength) const
	{
		ATLENSURE(pColumnName != NULL);
		ATLENSURE(pLength != NULL);
		DBORDINAL nColumn;
		if (GetInternalColumnNo(pColumnName, &nColumn))
		{
			DBBYTEOFFSET nOffset = (DBBYTEOFFSET)(ULONG_PTR)m_pColumnInfo[nColumn].pTypeInfo;
			IncrementAndAlignOffset( nOffset, m_pColumnInfo[nColumn].ulColumnSize, __alignof(DBLENGTH) );
			*pLength = *(DBLENGTH*)( m_pBuffer + nOffset );
			return true;
		}
		else
			return false;
	}
	bool GetLength(
		_In_z_ const WCHAR* pColumnName,
		_Out_ DBLENGTH* pLength) const
	{
		ATLENSURE(pColumnName != NULL);
		ATLENSURE(pLength != NULL);
		DBORDINAL nColumn;
		if (GetInternalColumnNo(pColumnName, &nColumn))
		{
			DBBYTEOFFSET nOffset = (DBBYTEOFFSET)(ULONG_PTR)m_pColumnInfo[nColumn].pTypeInfo;
			IncrementAndAlignOffset( nOffset, m_pColumnInfo[nColumn].ulColumnSize, __alignof(DBLENGTH) );
			*pLength = *(DBLENGTH*)( m_pBuffer + nOffset );
			return true;
		}
		else
			return false;
	}
	bool SetLength(
		_In_z_ const CHAR* pColumnName,
		_In_ DBLENGTH nLength) throw()
	{
		ATLASSERT(pColumnName != NULL);
		DBORDINAL nColumn;
		if (GetInternalColumnNo(pColumnName, &nColumn))
		{
			DBBYTEOFFSET nOffset = (DBBYTEOFFSET)(ULONG_PTR)m_pColumnInfo[nColumn].pTypeInfo;
			IncrementAndAlignOffset( nOffset, m_pColumnInfo[nColumn].ulColumnSize, __alignof(DBLENGTH) );
			*(DBLENGTH*)( m_pBuffer + nOffset ) = nLength;
			return true;
		}
		else
			return false;
	}
	bool SetLength(
		_In_z_ const WCHAR* pColumnName,
		_In_ DBLENGTH nLength) throw()
	{
		ATLASSERT(pColumnName != NULL);
		DBORDINAL nColumn;
		if (GetInternalColumnNo(pColumnName, &nColumn))
		{
			DBBYTEOFFSET nOffset = (DBBYTEOFFSET)(ULONG_PTR)m_pColumnInfo[nColumn].pTypeInfo;
			IncrementAndAlignOffset( nOffset, m_pColumnInfo[nColumn].ulColumnSize, __alignof(DBLENGTH) );
			*(DBLENGTH*)( m_pBuffer + nOffset ) = nLength;
			return true;
		}
		else
			return false;
	}
	bool GetStatus(
		_In_ DBORDINAL nColumn,
		_Out_ DBSTATUS* pStatus) const
	{
		ATLENSURE(pStatus != NULL);
		if (TranslateColumnNo(nColumn))
		{
			DBBYTEOFFSET nOffset = (DBBYTEOFFSET)(ULONG_PTR)m_pColumnInfo[nColumn].pTypeInfo;
			IncrementAndAlignOffset( nOffset, m_pColumnInfo[nColumn].ulColumnSize, __alignof(DBLENGTH) );
			IncrementAndAlignOffset( nOffset, sizeof(DBLENGTH), __alignof(DBSTATUS) );
			*pStatus = *(DBSTATUS*)( m_pBuffer + nOffset );
			return true;
		}
		else
			return false;
	}
	bool SetStatus(
		_In_ DBORDINAL nColumn,
		_In_ DBSTATUS status) throw()
	{
		if (TranslateColumnNo(nColumn))
		{
			DBBYTEOFFSET nOffset = (DBBYTEOFFSET)(ULONG_PTR)m_pColumnInfo[nColumn].pTypeInfo;
			IncrementAndAlignOffset( nOffset, m_pColumnInfo[nColumn].ulColumnSize, __alignof(DBLENGTH) );
			IncrementAndAlignOffset( nOffset, sizeof(DBLENGTH), __alignof(DBSTATUS) );
			*(DBSTATUS*)( m_pBuffer + nOffset ) = status;
			return true;
		}
		else
			return false;
	}
	bool GetStatus(
		_In_z_ const CHAR* pColumnName,
		_Out_ DBSTATUS* pStatus) const
	{
		ATLENSURE(pColumnName != NULL);
		ATLENSURE(pStatus != NULL);
		DBORDINAL nColumn;
		if (GetInternalColumnNo(pColumnName, &nColumn))
		{
			DBBYTEOFFSET nOffset = (DBBYTEOFFSET)(ULONG_PTR)m_pColumnInfo[nColumn].pTypeInfo;
			IncrementAndAlignOffset( nOffset, m_pColumnInfo[nColumn].ulColumnSize, __alignof(DBLENGTH) );
			IncrementAndAlignOffset( nOffset, sizeof(DBLENGTH), __alignof(DBSTATUS) );
			*pStatus = *(DBSTATUS*)( m_pBuffer + nOffset );
			return true;
		}
		else
			return false;
	}
	bool GetStatus(
		_In_z_ const WCHAR* pColumnName,
		_Out_ DBSTATUS* pStatus) const
	{
		ATLENSURE(pColumnName != NULL);
		ATLENSURE(pStatus != NULL);
		DBORDINAL nColumn;
		if (GetInternalColumnNo(pColumnName, &nColumn))
		{
			DBBYTEOFFSET nOffset = (DBBYTEOFFSET)(ULONG_PTR)m_pColumnInfo[nColumn].pTypeInfo;
			IncrementAndAlignOffset( nOffset, m_pColumnInfo[nColumn].ulColumnSize, __alignof(DBLENGTH) );
			IncrementAndAlignOffset( nOffset, sizeof(DBLENGTH), __alignof(DBSTATUS) );
			*pStatus = *(DBSTATUS*)( m_pBuffer + nOffset );
			return true;
		}
		else
			return false;
	}
	bool SetStatus(
		_In_z_ const CHAR* pColumnName,
		_In_ DBSTATUS status) throw()
	{
		ATLASSERT(pColumnName != NULL);
		DBORDINAL nColumn;
		if (GetInternalColumnNo(pColumnName, &nColumn))
		{
			DBBYTEOFFSET nOffset = (DBBYTEOFFSET)(ULONG_PTR)m_pColumnInfo[nColumn].pTypeInfo;
			IncrementAndAlignOffset( nOffset, m_pColumnInfo[nColumn].ulColumnSize, __alignof(DBLENGTH) );
			IncrementAndAlignOffset( nOffset, sizeof(DBLENGTH), __alignof(DBSTATUS) );
			*(DBSTATUS*)( m_pBuffer + nOffset ) = status;
			return true;
		}
		else
			return false;
	}
	bool SetStatus(
		_In_z_ const WCHAR* pColumnName,
		_In_ DBSTATUS status) throw()
	{
		ATLASSERT(pColumnName != NULL);
		DBORDINAL nColumn;
		if (GetInternalColumnNo(pColumnName, &nColumn))
		{
			DBBYTEOFFSET nOffset = (DBBYTEOFFSET)(ULONG_PTR)m_pColumnInfo[nColumn].pTypeInfo;
			IncrementAndAlignOffset( nOffset, m_pColumnInfo[nColumn].ulColumnSize, __alignof(DBLENGTH) );
			IncrementAndAlignOffset( nOffset, sizeof(DBLENGTH), __alignof(DBSTATUS) );
			*(DBSTATUS*)( m_pBuffer + nOffset ) = status;
			return true;
		}
		else
			return false;
	}

	// Returns true if a bookmark is available
	HRESULT GetBookmark(_Inout_ CBookmark<>* pBookmark) const throw()
	{
		ATLENSURE_RETURN(pBookmark);
		HRESULT hr;
		if (m_pColumnInfo->iOrdinal == 0)
			hr = pBookmark->SetBookmark(m_pColumnInfo->ulColumnSize, (BYTE*)_GetDataPtr(0));
		else
			hr = E_FAIL;
		return hr;
	}

	DBORDINAL GetColumnCount() const throw()
	{
		return m_nColumns;
	}

	LPOLESTR GetColumnName(_In_ DBORDINAL nColumn) const throw()
	{
		if (TranslateColumnNo(nColumn))
			return m_pColumnInfo[nColumn].pwszName;
		else
			return NULL;
	}

	ATL_DEPRECATED("CDynamicAccessor::GetColumnInfo must be passed an array of string buffers too.")
	HRESULT GetColumnInfo(
		_Inout_ IRowset* pRowset,
		_In_opt_ DBORDINAL* pColumns,
		_Deref_opt_out_ DBCOLUMNINFO** ppColumnInfo);

ATLPREFAST_SUPPRESS(6387)
	HRESULT GetColumnInfo(
		_Inout_ IRowset* pRowset,
		_Out_ DBORDINAL* pColumns,
		_Deref_out_  DBCOLUMNINFO** ppColumnInfo,
		_Deref_out_z_ OLECHAR** ppStringsBuffer) throw()
	{
		CComPtr<IColumnsInfo> spColumnsInfo;
		HRESULT hr = pRowset->QueryInterface(&spColumnsInfo);
		if (SUCCEEDED(hr))
			hr = spColumnsInfo->GetColumnInfo(pColumns, ppColumnInfo, ppStringsBuffer);

		return hr;
	}
ATLPREFAST_UNSUPPRESS()
	
	HRESULT AddBindEntry(_In_ const DBCOLUMNINFO& info) throw()
	{
		if ((m_nColumns + 1 < m_nColumns))
		{
			return E_OUTOFMEMORY;
		}
		DBCOLUMNINFO* pTempInfo = (DBCOLUMNINFO*)::ATL::AtlCoTaskMemRecalloc(m_pColumnInfo, (m_nColumns + 1), sizeof(DBCOLUMNINFO));
		if (pTempInfo == NULL)
			return E_OUTOFMEMORY;
		m_pColumnInfo = pTempInfo;
		m_pColumnInfo[m_nColumns] = info;
		m_nColumns++;

		return S_OK;
	}

	bool NoBindOnNullRowset() const throw()
	{
		return true;
	}

// Implementation
	// Free's any columns in the current record that need to be freed.
	// E.g. Calls SysFreeString on any BSTR's and Release on any interfaces.
	void FreeRecordMemory(_Inout_ IRowset* pRowset) throw()
	{
		ULONG i;

		for (i = 0; i < m_nColumns; i++)
		{
			if( m_pfClientOwnedMemRef != NULL && m_pfClientOwnedMemRef[i] == true )
			{
				DBBYTEOFFSET nOffset = (DBBYTEOFFSET)(ULONG_PTR)m_pColumnInfo[i].pTypeInfo;
				IncrementAndAlignOffset( nOffset, m_pColumnInfo[i].ulColumnSize, __alignof(DBLENGTH) );
				IncrementAndAlignOffset( nOffset, sizeof(DBLENGTH), __alignof(DBSTATUS) );
				if( *(DBSTATUS*)( m_pBuffer + nOffset ) != DBSTATUS_S_ISNULL )
				{
					void* pRef = _GetDataPtr(i);

					if( pRef != NULL && *(void**)pRef != NULL )
					{
						CoTaskMemFree( *(void**)_GetDataPtr(i) );
						*(void**)pRef = NULL;
					}
				}
			}
			else if( m_pColumnInfo[i].wType == DBTYPE_IUNKNOWN || m_pColumnInfo[i].wType == DBTYPE_IDISPATCH )
			{
				DBBYTEOFFSET nOffset = (DBBYTEOFFSET)(ULONG_PTR)m_pColumnInfo[i].pTypeInfo;
				IncrementAndAlignOffset( nOffset, m_pColumnInfo[i].ulColumnSize, __alignof(DBLENGTH) );
				IncrementAndAlignOffset( nOffset, sizeof(DBLENGTH), __alignof(DBSTATUS) );
				if( *(DBSTATUS*)( m_pBuffer + nOffset ) == DBSTATUS_S_OK )
					CAccessorBase::FreeType(m_pColumnInfo[i].wType, (BYTE*)_GetDataPtr(i), pRowset);
			}
			else
			{
				CAccessorBase::FreeType(m_pColumnInfo[i].wType, (BYTE*)_GetDataPtr(i), pRowset);
			}
		}
	}
	void ClearRecordMemory() throw()
	{
		for (ULONG i = 0; i < m_nColumns; i++)
		{
			memset((BYTE*)_GetDataPtr(i), 0, m_pColumnInfo[i].ulColumnSize);
		}
	}

	void* _GetDataPtr(_In_ DBORDINAL nColumn) const throw()
	{
		return m_pBuffer + (DBBYTEOFFSET)(ULONG_PTR)m_pColumnInfo[nColumn].pTypeInfo;
	}
	bool GetInternalColumnNo(
		_In_z_ const CHAR* pColumnName,
		_Out_ DBORDINAL* pColumn) const
	{
		ATLENSURE(pColumnName != NULL);
		ATLENSURE(pColumn != NULL);
		ULONG       i;
		size_t      nSize = (lstrlenA(pColumnName) + 1) * sizeof(OLECHAR);
		CComBSTR	bstrColumnName(pColumnName);

		// Search through the columns trying to find a match
		for (i = 0; i < m_nColumns; i++)
		{
			ATLASSUME(m_pColumnInfo != NULL);
			if (m_pColumnInfo[i].pwszName != NULL &&
				memcmp(m_pColumnInfo[i].pwszName, bstrColumnName.m_str, nSize) == 0)
			{
				break;
			}
		}
		if (i < m_nColumns && pColumn)
		{
			*pColumn = i;
			return true;
		}
		else
		{
			return false;   // Not Found
		}
	}
	bool GetInternalColumnNo(
		_In_z_ const WCHAR* pColumnName,
		_Out_ DBORDINAL* pColumn) const
	{
		ATLENSURE(pColumnName != NULL);
		ATLASSERT(pColumn != NULL);
		ULONG       i;
		size_t      nSize = (wcslen(pColumnName) + 1) * sizeof(OLECHAR);
		CComBSTR	bstrColumnName(pColumnName);

		// Search through the columns trying to find a match
		for (i = 0; i < m_nColumns; i++)
		{
			ATLASSUME(m_pColumnInfo != NULL);
			if (m_pColumnInfo[i].pwszName != NULL &&
				memcmp(m_pColumnInfo[i].pwszName, bstrColumnName.m_str, nSize) == 0)
				break;
		}

		if (i < m_nColumns && pColumn)
		{
			*pColumn = i;
			return true;
		}

		return false;   // Not Found
	}

	// Set up the binding structure pointed to by pBindings based upon
	// the other passed parameters.
	static void BindEx(
		_Inout_ DBBINDING* pBinding,
		_In_ DBORDINAL nOrdinal,
		_In_ DBTYPE wType,
		_In_ DBLENGTH nLength,
		_In_ BYTE nPrecision,
		_In_ BYTE nScale,
		_In_ DBPARAMIO eParamIO,
		_In_ DBBYTEOFFSET nDataOffset,
		_In_ DBBYTEOFFSET nLengthOffset,
		_In_ DBBYTEOFFSET nStatusOffset,
		_In_opt_ DBOBJECT* pdbobject,
		_In_ DBMEMOWNER dwMemOwner,
		_In_ bool fSkipData = false )
	{
		ATLENSURE(pBinding != NULL);

		pBinding->dwMemOwner    = dwMemOwner;

		pBinding->pObject       = pdbobject;

		pBinding->eParamIO      = eParamIO;
		pBinding->iOrdinal      = nOrdinal;
		pBinding->wType         = wType;
		pBinding->bPrecision    = nPrecision;
		pBinding->bScale        = nScale;
		pBinding->dwFlags       = 0;

		pBinding->obValue       = 0;
		pBinding->obLength      = 0;
		pBinding->obStatus      = 0;
		pBinding->pTypeInfo     = NULL;
		pBinding->pBindExt      = NULL;
		pBinding->cbMaxLen      = nLength;

		pBinding->dwPart = 0;

		if ( ! fSkipData ) // skip column data
		{
			pBinding->dwPart |= DBPART_VALUE;
			pBinding->obValue = nDataOffset;
		}
		if (nLengthOffset != 0) // skip length
		{
			pBinding->dwPart |= DBPART_LENGTH;
			pBinding->obLength = nLengthOffset;
		}
		if (nStatusOffset != 0) // skip status
		{
			pBinding->dwPart |= DBPART_STATUS;
			pBinding->obStatus = nStatusOffset;
		}
	}

	HRESULT GetRowsetProperties(
		_Inout_ IUnknown* pUnk,
		_In_ DBPROPID* prgPropertyIDs,
		_Out_cap_(nPropCount) BOOL* pbValues,
		_In_ ULONG nPropCount) throw()
	{
		ULONG t;

		ATLENSURE_RETURN(pUnk != NULL);
		ATLENSURE_RETURN(pbValues != NULL);
		ATLASSERT(prgPropertyIDs != NULL);
		ATLASSERT(nPropCount > 0);

		CComPtr<IRowsetInfo> spRowsetInfo;
		HRESULT hr = pUnk->QueryInterface(&spRowsetInfo);

		for( t = 0; t < nPropCount; t++ )
			pbValues[t] = FALSE;

		if (FAILED(hr))
			ATLASSERT(0); // unable to retrieve IRowsetInfo interface
		else
		{
			DBPROPIDSET            rgPropertyIDSets[1];
			ULONG                  cPropSets        = 0;
			CComHeapPtr<DBPROPSET> rgPropSets;

			// Set up the Property ID Set.
			rgPropertyIDSets[0].rgPropertyIDs       = prgPropertyIDs;
			rgPropertyIDSets[0].cPropertyIDs        = nPropCount;
			rgPropertyIDSets[0].guidPropertySet     = DBPROPSET_ROWSET;

			hr = spRowsetInfo->GetProperties(	1,					// cPropertyIDSets
												rgPropertyIDSets,	// rgPropertyIDSets
												&cPropSets,         // pcPropSets
												&rgPropSets );      // prgPropSets

			if( SUCCEEDED(hr) )
			{
				for( t = 0; t < __min(rgPropSets[0].cProperties, nPropCount); t++ )
					pbValues[t] = V_BOOL(&rgPropSets[0].rgProperties[t].vValue);

				if( rgPropSets[0].rgProperties )
					CoTaskMemFree(rgPropSets[0].rgProperties);
			}
		}

		return hr;
	}

	HRESULT BindColumns(_Inout_ IUnknown* pUnk) throw()
	{
		IID iidStreamToUse = __uuidof(ISequentialStream);
		bool fIStreamSupportTested = false;

		ATLENSURE_RETURN(pUnk != NULL);
		CComPtr<IAccessor> spAccessor;
		HRESULT hr = pUnk->QueryInterface(&spAccessor);
		if (FAILED(hr))
			return hr;

		ULONG   i;
		DBBYTEOFFSET   nOffset = 0, nDataOffset, nLengthOffset, nStatusOffset;

		// If the user hasn't specifed the column information to bind by calling AddBindEntry then
		// we get it ourselves
		if (m_pColumnInfo == NULL)
		{
			CComPtr<IColumnsInfo> spColumnsInfo;
			hr = pUnk->QueryInterface(&spColumnsInfo);
			if (FAILED(hr))
				return hr;

			hr = spColumnsInfo->GetColumnInfo(&m_nColumns, &m_pColumnInfo, &m_pStringsBuffer);
			if (FAILED(hr))
				return hr;

			m_bOverride = false;
		}
		else
			m_bOverride = true;

		DBBINDING* pBinding = NULL;
		ATLTRY( pBinding = new DBBINDING[m_nColumns] );
		if( pBinding == NULL )
			return E_OUTOFMEMORY;

		CAutoVectorPtr<DBBINDING> spBinding(pBinding);

		ATLASSUME(m_pfClientOwnedMemRef == NULL);
		ATLTRY(m_pfClientOwnedMemRef = new bool[m_nColumns]);
		if( m_pfClientOwnedMemRef == NULL )
		{
			return E_OUTOFMEMORY;
		}

#ifdef _DEBUG
		ATLTRACE( "CDynamicAccessor::BindColumns\n" );
		ATLTRACE( "Number of columns: %d\n", m_nColumns );
		ATLTRACE( "Blob Handling Mode: " );
		switch( m_eBlobHandling )
		{
		case DBBLOBHANDLING_DEFAULT:
			ATLTRACE( "DBBLOBHANDLING_DEFAULT\n" );
			break;
		case DBBLOBHANDLING_NOSTREAMS:
			ATLTRACE( "DBBLOBHANDLING_NOSTREAMS\n" );
			break;
		case DBBLOBHANDLING_SKIP:
			ATLTRACE( "DBBLOBHANDLING_SKIP\n" );
			break;
		default:
			ATLTRACE( "IVALID HANDLING MODE!!!\n" );
		}
#endif
		DBBINDING* pCurrent = pBinding;
		DBOBJECT*  pObject;

		ATLASSUME(m_pColumnInfo != NULL || m_nColumns == 0);

		for (i = 0; i < m_nColumns; i++)
		{
			// If it's a BLOB or the column size is large enough for us to treat it as
			// a BLOB then we also need to set up the DBOBJECT structure.
			m_pfClientOwnedMemRef[i] = false;
			if (m_pColumnInfo[i].ulColumnSize > m_nBlobSize && m_pColumnInfo[i].wType != DBTYPE_IUNKNOWN )
			{
				if( m_eBlobHandling == DBBLOBHANDLING_SKIP )
				{
					// Calculate the column data offset
					nDataOffset = 0;
					// Calculate the column length offset
					nLengthOffset = AlignAndIncrementOffset( nOffset, sizeof(DBLENGTH), __alignof(DBLENGTH) );
					// Calculate the column status offset
					nStatusOffset = AlignAndIncrementOffset( nOffset, sizeof(DBSTATUS), __alignof(DBSTATUS) );
					//If ulColumnSize is not zeroed, GetLength and GetStatus will not access the correct offset in buffer.
					//As they add ulColumnSize to skip the data.
					m_pColumnInfo[i].ulColumnSize = 0;
					ATLTRACE( "%d. Column ordinal %d: Binding length and status ONLY\n", i, m_pColumnInfo[i].iOrdinal );

					BindEx(pCurrent, m_pColumnInfo[i].iOrdinal, m_pColumnInfo[i].wType,
						m_pColumnInfo[i].ulColumnSize, m_pColumnInfo[i].bPrecision, m_pColumnInfo[i].bScale,
						DBPARAMIO_NOTPARAM, nDataOffset, nLengthOffset, nStatusOffset, NULL, DBMEMOWNER_CLIENTOWNED, true );
					pCurrent++;
				}
				else if( m_eBlobHandling == DBBLOBHANDLING_NOSTREAMS )
				{
					// get the value by reference
					m_pColumnInfo[i].wType |= DBTYPE_BYREF;
					m_pColumnInfo[i].ulColumnSize   = sizeof(WCHAR*);
					m_pfClientOwnedMemRef[i] = true;

					// Calculate the column data offset
					nDataOffset = AlignAndIncrementOffset( nOffset, m_pColumnInfo[i].ulColumnSize, GetAlignment( m_pColumnInfo[i].wType ) );
					// Calculate the column length offset
					nLengthOffset = AlignAndIncrementOffset( nOffset, sizeof(DBLENGTH), __alignof(DBLENGTH) );
					// Calculate the column status offset
					nStatusOffset = AlignAndIncrementOffset( nOffset, sizeof(DBSTATUS), __alignof(DBSTATUS) );

					ATLTRACE( "%d. Column ordinal %d: Binding by reference in provider allocated, consumer owned memory\n", i, m_pColumnInfo[i].iOrdinal );

					BindEx(pCurrent, m_pColumnInfo[i].iOrdinal, m_pColumnInfo[i].wType,
						m_pColumnInfo[i].ulColumnSize, m_pColumnInfo[i].bPrecision, m_pColumnInfo[i].bScale,
						DBPARAMIO_NOTPARAM, nDataOffset, nLengthOffset, nStatusOffset, NULL, DBMEMOWNER_CLIENTOWNED);
					pCurrent++;

				}
				else // if( m_eBlobHandling == DBBLOBHANDLING_DEFAULT )
				{
					// we will try to bind blobs as streams
					// if we have not tested if the rowset supports streams, do it now
					if( ! fIStreamSupportTested )
					{
						ATLTRACE( "Testing streams support... " );

						DBPROPID rgPropertyIDs[2] = { DBPROP_ISequentialStream, DBPROP_IStream };
						BOOL     rgStreamsSupported[2] = {FALSE, FALSE};

						// check if the rowset supports IStream* interfaces
						hr = GetRowsetProperties( pUnk, rgPropertyIDs, rgStreamsSupported, 2 );
						ATLASSERT( SUCCEEDED( hr ) );

						if( rgStreamsSupported[0] )
						{
							iidStreamToUse = __uuidof(ISequentialStream);

							ATLTRACE( "ISequentialStream is supported\n" );
						}
						else if( rgStreamsSupported[1] )
						{
							iidStreamToUse = __uuidof(IStream);

							ATLTRACE( "IStream is supported\n" );
						}
						else
						{

							ATLTRACE( "neither ISequentialStream nor IStream are supported!\n" );

							ATLASSERT(FALSE); // the stream interfaces are not supported!!!
						}

						fIStreamSupportTested = true;
					}

					pObject = NULL;
					ATLTRY(pObject = new DBOBJECT);
					if (pObject == NULL)
					{
						for( ULONG t = 0; t < i; t++ )
							delete pBinding[t].pObject;

						delete [] m_pfClientOwnedMemRef;
						m_pfClientOwnedMemRef = NULL;

						return E_OUTOFMEMORY;
					}
					pObject->dwFlags = STGM_READ;
					pObject->iid     = iidStreamToUse;
					m_pColumnInfo[i].wType      = DBTYPE_IUNKNOWN;
					m_pColumnInfo[i].ulColumnSize   = sizeof(IUnknown*);

					// Calculate the column data offset
					nDataOffset = AlignAndIncrementOffset( nOffset, m_pColumnInfo[i].ulColumnSize, GetAlignment( m_pColumnInfo[i].wType ) );
					// Calculate the column length offset
					nLengthOffset = AlignAndIncrementOffset( nOffset, sizeof(DBLENGTH), __alignof(DBLENGTH) );
					// Calculate the column status offset
					nStatusOffset = AlignAndIncrementOffset( nOffset, sizeof(DBSTATUS), __alignof(DBSTATUS) );

#ifdef _DEBUG
					if( iidStreamToUse == __uuidof(ISequentialStream) )
						ATLTRACE( "%d. Column ordinal %d: Binding as an ISequentialStream object\n", i, m_pColumnInfo[i].iOrdinal );
					else
						ATLTRACE( "%d. Column ordinal %d: Binding as an IStream object\n", i, m_pColumnInfo[i].iOrdinal );
#endif
					Bind(pCurrent, m_pColumnInfo[i].iOrdinal, m_pColumnInfo[i].wType,
						m_pColumnInfo[i].ulColumnSize, m_pColumnInfo[i].bPrecision, m_pColumnInfo[i].bScale,
						DBPARAMIO_NOTPARAM, nDataOffset, nLengthOffset, nStatusOffset, pObject);
					pCurrent++;

				}
			}
			// else if it's a COM object
			else if( m_pColumnInfo[i].wType == DBTYPE_IUNKNOWN)
			{
				pObject = NULL;
				ATLTRY(pObject = new DBOBJECT);
				if (pObject == NULL)
				{
					for( ULONG t = 0; t < i; t++ )
						delete pBinding[t].pObject;

					delete [] m_pfClientOwnedMemRef;
					m_pfClientOwnedMemRef = NULL;

					return E_OUTOFMEMORY;
				}
				pObject->dwFlags = STGM_READ;
				pObject->iid     = __uuidof(IUnknown); // iidPersistToUse;
				m_pColumnInfo[i].wType      = DBTYPE_IUNKNOWN;
				m_pColumnInfo[i].ulColumnSize   = sizeof(IUnknown*);

				// Calculate the column data offset
				nDataOffset = AlignAndIncrementOffset( nOffset, m_pColumnInfo[i].ulColumnSize, GetAlignment( m_pColumnInfo[i].wType ) );

				// Calculate the column length offset
				nLengthOffset = AlignAndIncrementOffset( nOffset, sizeof(DBLENGTH), __alignof(DBLENGTH) );

				// Calculate the column status offset
				nStatusOffset = AlignAndIncrementOffset( nOffset, sizeof(DBSTATUS), __alignof(DBSTATUS) );

				ATLTRACE( "%d. Column ordinal %d: Binding a COM object\n", i, m_pColumnInfo[i].iOrdinal );

				Bind(pCurrent, m_pColumnInfo[i].iOrdinal, m_pColumnInfo[i].wType,
					m_pColumnInfo[i].ulColumnSize, m_pColumnInfo[i].bPrecision, m_pColumnInfo[i].bScale,
					DBPARAMIO_NOTPARAM, nDataOffset, nLengthOffset, nStatusOffset, pObject);
				pCurrent++;

			}
			// else if it's not a BLOB or COM object
			else
			{
				pObject = NULL;

				// Calculate the size needed if it's a string
				// including the NULL terminator.
				if (m_pColumnInfo[i].wType == DBTYPE_STR)
					m_pColumnInfo[i].ulColumnSize += 1;

				if (m_pColumnInfo[i].wType == DBTYPE_WSTR)
					m_pColumnInfo[i].ulColumnSize = m_pColumnInfo[i].ulColumnSize*2 + 2;

				// Calculate the column data offset
				nDataOffset = AlignAndIncrementOffset( nOffset, m_pColumnInfo[i].ulColumnSize, GetAlignment( m_pColumnInfo[i].wType ) );

				// Calculate the column length offset
				nLengthOffset = AlignAndIncrementOffset( nOffset, sizeof(DBLENGTH), __alignof(DBLENGTH) );

				// Calculate the column status offset
				nStatusOffset = AlignAndIncrementOffset( nOffset, sizeof(DBSTATUS), __alignof(DBSTATUS) );

				ATLTRACE( "%d. Column ordinal %d: Binding as native data type\n", i, m_pColumnInfo[i].iOrdinal );

				Bind(pCurrent, m_pColumnInfo[i].iOrdinal, m_pColumnInfo[i].wType,
					m_pColumnInfo[i].ulColumnSize, m_pColumnInfo[i].bPrecision, m_pColumnInfo[i].bScale,
					DBPARAMIO_NOTPARAM, nDataOffset, nLengthOffset, nStatusOffset, pObject);
				pCurrent++;
			}

			// Note that, as we're not using this for anything else, we're using the
			// pTypeInfo element to store the offset to our data.
			m_pColumnInfo[i].pTypeInfo = (ITypeInfo*)(ULONG_PTR)nDataOffset;
		}
		// Allocate the accessor memory if we haven't done so yet
		if (m_pAccessorInfo == NULL)
		{
			hr = AllocateAccessorMemory(1); // We only have one accessor
			if (FAILED(hr))
			{
				for( ULONG t = 0; t < m_nColumns; t++ )
					delete pBinding[t].pObject;

				delete [] m_pfClientOwnedMemRef;
				m_pfClientOwnedMemRef = NULL;

				return hr;
			}
			m_pAccessorInfo->bAutoAccessor = true;
		}

		// Allocate enough memory for the data buffer and tell the rowset
		// Note that the rowset will free the memory in its destructor.
		m_pBuffer = NULL;
		ATLTRY(m_pBuffer = new BYTE[nOffset]);
		if (m_pBuffer == NULL)
		{
			for( ULONG t = 0; t < m_nColumns; t++ )
				delete pBinding[t].pObject;

			delete [] m_pfClientOwnedMemRef;
			m_pfClientOwnedMemRef = NULL;

			return E_OUTOFMEMORY;
		}
		memset(m_pBuffer, 0, nOffset);
		hr = BindEntries(pBinding, m_nColumns, &m_pAccessorInfo->hAccessor,
				nOffset, spAccessor);

		if( FAILED(hr))
		{
			delete [] m_pfClientOwnedMemRef;
			m_pfClientOwnedMemRef = NULL;
		}

		return hr;
	}

	// Translate the column number to the index into the column info array
	bool TranslateColumnNo(_Inout_ DBORDINAL& nColumn) const throw()
	{
		ATLASSUME(m_pColumnInfo != NULL);
		// If the user has overriden the binding then we need to search
		// through the column info for the ordinal number
		if (m_bOverride)
		{
			for (ULONG i = 0; i < m_nColumns; i++)
			{
				if (m_pColumnInfo[i].iOrdinal == nColumn)
				{
					nColumn = i;
					return true;
				}
			}
			return false;
		}
		else
		{
			// Note that m_pColumnInfo->iOrdinal will be zero if have bound
			// a bookmark as the first entry, otherwise it will be 1.
			// If the column is out of range then return false
			if (nColumn > (m_nColumns - 1 + m_pColumnInfo->iOrdinal))
				return false;

			// otherwise translate the column to an index into our internal
			// binding entries array
			nColumn -= m_pColumnInfo->iOrdinal;
			return true;
		}
	}

	static size_t GetAlignment(_In_ DBTYPE bType) throw()
	{
		if( bType & DBTYPE_BYREF )
			return __alignof(void*);

		if( bType & DBTYPE_ARRAY )
			return __alignof(SAFEARRAY*);

		if( bType & DBTYPE_VECTOR )
			return __alignof(DBVECTOR);

		switch( bType )
		{
		case DBTYPE_I2:
			return __alignof(signed short);
			break;

		case DBTYPE_I4:
			return __alignof(signed int);
			break;

		case DBTYPE_R4:
			return __alignof(float);
			break;

		case DBTYPE_R8:
			return __alignof(double);
			break;

		case DBTYPE_CY:
			return __alignof(__int64);
			break;

		case DBTYPE_DATE:
			return __alignof(DATE);
			break;

		case DBTYPE_BSTR:
			return __alignof(BSTR*);
			break;

		case DBTYPE_IDISPATCH:
			return __alignof(IDispatch*);
			break;

		case DBTYPE_ERROR:
			return __alignof(SCODE);
			break;

		case DBTYPE_BOOL:
			return __alignof(VARIANT_BOOL);
			break;

		case DBTYPE_VARIANT:
			return __alignof(VARIANT);
			break;

		case DBTYPE_IUNKNOWN:
			return __alignof(IUnknown*);
			break;

		case DBTYPE_DECIMAL:
			return __alignof(DECIMAL);
			break;

		case DBTYPE_UI1:
			return __alignof(unsigned char);
			break;

		case DBTYPE_I1:
			return __alignof(signed char);
			break;

		case DBTYPE_UI2:
			return __alignof(unsigned short);
			break;

		case DBTYPE_UI4:
			return __alignof(unsigned int);
			break;

		case DBTYPE_I8:
			return __alignof(signed char);
			break;

		case DBTYPE_UI8:
			return __alignof(unsigned char);
			break;

		case DBTYPE_GUID:
			return __alignof(GUID);
			break;

		case DBTYPE_BYTES:
			return __alignof(BYTE);
			break;

		case DBTYPE_STR:
			return __alignof(char);
			break;

		case DBTYPE_WSTR:
			return __alignof(short);
			break;

		case DBTYPE_NUMERIC:
			return __alignof(DB_NUMERIC);
			break;

		case DBTYPE_DBDATE:
			return __alignof(DBDATE);
			break;

		case DBTYPE_DBTIME:
			return __alignof(DBTIME);
			break;

		case DBTYPE_DBTIMESTAMP:
			return __alignof(DBTIMESTAMP);
			break;

		default:
			return __alignof(__int64);
		}
	}

	inline static DBBYTEOFFSET AlignAndIncrementOffset(
		_Inout_ DBBYTEOFFSET& nOffset,
		_In_ DBLENGTH nSize,
		_In_ size_t nAlign) throw()
	{
		DBBYTEOFFSET nResult;

		nOffset = AtlAlignUp( nOffset, (ULONG)nAlign );
		nResult = nOffset;
		nOffset += nSize;

		return nResult;
	}

	inline static void IncrementAndAlignOffset(
		_Inout_ DBBYTEOFFSET& nOffset,
		_In_ DBLENGTH nSize,
		_In_ size_t nAlign) throw()
	{
		nOffset += nSize;
		nOffset = AtlAlignUp( nOffset, (ULONG)nAlign );
	}

	typedef CDynamicAccessor _OutputColumnsClass;
	static bool HasOutputColumns() throw()
	{
		return true;
	}

	DBORDINAL           m_nColumns;
	bool*				m_pfClientOwnedMemRef;
	DBCOLUMNINFO*       m_pColumnInfo;
	OLECHAR*            m_pStringsBuffer;
	bool                m_bOverride;

	protected:
	DBBLOBHANDLINGENUM  m_eBlobHandling;
	DBLENGTH            m_nBlobSize;
};
	
template< typename BaseType >
inline void strcpyT(
	_Out_z_cap_(maxCount) BaseType *strDest,
	_In_ size_t maxCount,
	_In_z_ const BaseType *strSource)
{
	return NULL;
}

template< typename BaseType >
inline size_t strlenT(_In_z_ const BaseType *string)
{
	return NULL;
}

template<>
inline void strcpyT<CHAR>(
	_Out_z_cap_(maxCount) CHAR *strDest,
	_In_ size_t maxCount,
	_In_z_ const CHAR *strSource)
{
	Checked::strcpy_s( strDest, maxCount, strSource);
}

template<>
inline size_t strlenT<CHAR>(_In_z_ const CHAR *string)
{
	return strlen( string );
}

template<>
inline void strcpyT<WCHAR>(
	_Out_z_cap_(maxCount) WCHAR *strDest,
	_In_ size_t maxCount,
	_In_z_ const WCHAR *strSource)
{
	Checked::wcscpy_s( strDest, maxCount, strSource);
}

template<>
inline size_t strlenT<WCHAR>(_In_z_ const WCHAR *string)
{
	return wcslen( string );
}

template< typename BaseType, DBTYPEENUM OleDbType >
class CDynamicStringAccessorT :
	public CDynamicAccessor
{
public:
	explicit CDynamicStringAccessorT(_In_ DBLENGTH nBlobSize = 8000)
		: CDynamicAccessor( DBBLOBHANDLING_DEFAULT, nBlobSize )
	{
	}

	HRESULT BindColumns(_Inout_ IUnknown* pUnk) throw()
	{
		ATLENSURE_RETURN(pUnk != NULL);
		CComPtr<IAccessor> spAccessor;
		HRESULT hr = pUnk->QueryInterface(&spAccessor);
		if (FAILED(hr))
			return hr;

		ULONG   i;
		DBBYTEOFFSET nOffset = 0, nDataOffset, nLengthOffset, nStatusOffset;
		DBLENGTH nLength;

		// If the user hasn't specifed the column information to bind by calling AddBindEntry then
		// we get it ourselves
		if (m_pColumnInfo == NULL)
		{
			CComPtr<IColumnsInfo> spColumnsInfo;
			hr = pUnk->QueryInterface(&spColumnsInfo);
			if (FAILED(hr))
				return hr;

			hr = spColumnsInfo->GetColumnInfo(&m_nColumns, &m_pColumnInfo, &m_pStringsBuffer);
			if (FAILED(hr))
				return hr;

			m_bOverride = false;
		}
		else
			m_bOverride = true;

		DBBINDING* pBinding = NULL;
		ATLTRY(pBinding= new DBBINDING[m_nColumns]);
		if (pBinding == NULL)
			return E_OUTOFMEMORY;

		::ATL::CAutoVectorPtr<DBBINDING> spBinding(pBinding);

		ATLASSUME(m_pfClientOwnedMemRef == NULL);
		ATLTRY(m_pfClientOwnedMemRef = new bool[m_nColumns]);
		if( m_pfClientOwnedMemRef == NULL )
		{
			return E_OUTOFMEMORY;
		}

		DBBINDING* pCurrent = pBinding;

		ATLASSUME(m_pColumnInfo != NULL || m_nColumns == 0);

		for (i = 0; i < m_nColumns; i++)
		{
			m_pfClientOwnedMemRef[i] = false;

			// If it's a IPersist* object or the column size is large enough for us to treat it as
			// a BLOB then we will request references (in client owned memory) to a string
			if (m_pColumnInfo[i].ulColumnSize > m_nBlobSize || m_pColumnInfo[i].wType == DBTYPE_IUNKNOWN)
			{
				m_pColumnInfo[i].wType      = OleDbType | DBTYPE_BYREF;
				m_pColumnInfo[i].ulColumnSize   = sizeof(BaseType*);
				m_pfClientOwnedMemRef[i] = true;
			}
			else // We're treating everything as a string so add 1 for the NULL byte.
			{
				switch (m_pColumnInfo[i].wType)
				{
				case DBTYPE_BOOL:
					nLength = 2;
					break;
				case DBTYPE_BYTES:
					nLength = m_pColumnInfo[i].ulColumnSize * 2;
					break;
				case DBTYPE_BSTR:
					nLength = m_pColumnInfo[i].ulColumnSize;
					break;
				case DBTYPE_STR:
					nLength = m_pColumnInfo[i].ulColumnSize;
					break;
				case DBTYPE_WSTR:
					nLength = m_pColumnInfo[i].ulColumnSize;
					break;
				case DBTYPE_I1:
					nLength = 5;
					break;
				case DBTYPE_I2:
					nLength = 7;
					break;
				case DBTYPE_I4:
					nLength = 12;
					break;
				case DBTYPE_I8:
					nLength = 22;
					break;
				case DBTYPE_UI1:
					nLength = 4;
					break;
				case DBTYPE_UI2:
					nLength = 6;
					break;
				case DBTYPE_UI4:
					nLength = 11;
					break;
				case DBTYPE_UI8:
					nLength = 21;
					break;
				case DBTYPE_R4:
					nLength = 13;
					break;
				case DBTYPE_R8:
					nLength = 23;		// maybe 9
					break;
				case DBTYPE_DECIMAL:
					nLength = 23;
					break;
				case DBTYPE_NUMERIC:
					nLength = 23;
					break;
				case DBTYPE_VARIANT:
					nLength = 20;
					break;
				case DBTYPE_IDISPATCH:
					nLength = 32;
					break;
				case DBTYPE_IUNKNOWN:
					nLength = 32;
					break;
				case DBTYPE_GUID:
					nLength = 38;
					break;
				case DBTYPE_ARRAY:
					nLength = 32;
					break;
				case DBTYPE_VECTOR:
					nLength = 32;
					break;
				case DBTYPE_DATE:
					nLength = 32;
					break;
				case DBTYPE_DBDATE:
					nLength = 32;
					break;
				case DBTYPE_DBTIME:
					nLength = 32;
					break;
				case DBTYPE_DBTIMESTAMP:
					nLength = 32;
					break;
				case DBTYPE_FILETIME:
					nLength = 32;
					break;
				case DBTYPE_PROPVARIANT:
					nLength = 32;
					break;
				case DBTYPE_VARNUMERIC:
					nLength = 32;
					break;
				case DBTYPE_CY:
					nLength = 32;
					break;
				default:
					ATLASSERT(FALSE); // unhandled column type
					nLength = 32;
				}
				m_pColumnInfo[i].ulColumnSize = (nLength + 1) * sizeof(BaseType);
				m_pColumnInfo[i].wType = OleDbType;
			}

			// Calculate the column data offset
			nDataOffset = AlignAndIncrementOffset( nOffset, m_pColumnInfo[i].ulColumnSize, GetAlignment( OleDbType ) );

			// Calculate the column length offset
			nLengthOffset = AlignAndIncrementOffset( nOffset, sizeof(DBLENGTH), __alignof(DBLENGTH) );

			// Calculate the column status offset
			nStatusOffset = AlignAndIncrementOffset( nOffset, sizeof(DBSTATUS), __alignof(DBSTATUS) );

			BindEx(pCurrent, m_pColumnInfo[i].iOrdinal, m_pColumnInfo[i].wType,
				m_pColumnInfo[i].ulColumnSize, m_pColumnInfo[i].bPrecision, m_pColumnInfo[i].bScale,
				DBPARAMIO_NOTPARAM, nDataOffset, nLengthOffset, nStatusOffset, NULL, DBMEMOWNER_CLIENTOWNED);

			pCurrent++;

			// Note that, as we're not using this for anything else, we're using the
			// pTypeInfo element to store the offset to our data.
			m_pColumnInfo[i].pTypeInfo = (ITypeInfo*)(ULONG_PTR)nDataOffset;
		}

		// Allocate the accessor memory if we haven't done so yet
		if (m_pAccessorInfo == NULL)
		{
			hr = AllocateAccessorMemory(1); // We only have one accessor
			if (FAILED(hr))
			{
				delete [] m_pfClientOwnedMemRef;
				m_pfClientOwnedMemRef = NULL;
				return hr;
			}
			m_pAccessorInfo->bAutoAccessor = true;
		}

		// Allocate enough memory for the data buffer and tell the rowset
		// Note that the rowset will free the memory in its destructor.
		m_pBuffer = NULL;
		ATLTRY(m_pBuffer = new BYTE[nOffset]);
		if (m_pBuffer == NULL)
		{
			delete [] m_pfClientOwnedMemRef;
			m_pfClientOwnedMemRef = NULL;
			return E_OUTOFMEMORY;
		}

		memset(m_pBuffer, 0, nOffset);
		hr = BindEntries(pBinding, m_nColumns, &m_pAccessorInfo->hAccessor,
				nOffset, spAccessor);

		if( FAILED(hr) )
		{
			delete [] m_pfClientOwnedMemRef;
			m_pfClientOwnedMemRef = NULL;
		}

		return hr;
	}

	BaseType* GetString(_In_ DBORDINAL nColumn) const throw()
	{
		if (TranslateColumnNo(nColumn))
		{
			if( m_pColumnInfo[nColumn].wType & DBTYPE_BYREF )
				return *(BaseType**)_GetDataPtr(nColumn);
			else
				return (BaseType*)_GetDataPtr(nColumn);
		}
		else
			return NULL;
	}

	BaseType* GetString(_In_z_ const CHAR* pColumnName) const throw()
	{
		ATLASSERT(pColumnName != NULL);
		DBORDINAL nColumn;
		if (GetInternalColumnNo(pColumnName, &nColumn))
		{
			if( m_pColumnInfo[nColumn].wType & DBTYPE_BYREF )
				return *(BaseType**)_GetDataPtr(nColumn);
			else
				return (BaseType*)_GetDataPtr(nColumn);
		}
		else
			return NULL;    // Not Found
	}

	BaseType* GetString(_In_z_ const WCHAR* pColumnName) const throw()
	{
		ATLASSERT(pColumnName != NULL);
		DBORDINAL nColumn;
		if (GetInternalColumnNo(pColumnName, &nColumn))
		{
			if( m_pColumnInfo[nColumn].wType & DBTYPE_BYREF )
				return *(BaseType**)_GetDataPtr(nColumn);
			else
				return (BaseType*)_GetDataPtr(nColumn);
		}
		else
			return NULL;    // Not Found
	}

	void _SetLength(
		_In_ DBORDINAL nColumn,
		_In_ DBLENGTH nLength) throw()
	{
		DBBYTEOFFSET nOffset = (DBBYTEOFFSET)(ULONG_PTR)m_pColumnInfo[nColumn].pTypeInfo;
		IncrementAndAlignOffset( nOffset, m_pColumnInfo[nColumn].ulColumnSize, __alignof(DBLENGTH) );
		*(DBLENGTH*)( m_pBuffer + nOffset ) = nLength;
	}

	HRESULT _SetString(
		_In_ DBORDINAL nColumn,
		_In_z_ BaseType* data) throw()
	{
		DBLENGTH stringLen = (DBLENGTH)strlenT<BaseType>( data );

		if( m_pColumnInfo[nColumn].wType & DBTYPE_BYREF )
		{
			BaseType** pBuffer = (BaseType**)_GetDataPtr(nColumn);



			//in case of overflow throw exception
			if (stringLen + 1>(size_t(-1)/sizeof(BaseType)))
			{
				return(E_FAIL);//arithmetic overflow
			}

			BaseType* pNewBuffer = (BaseType*)::ATL::AtlCoTaskMemRecalloc( *pBuffer, (stringLen + 1), sizeof(BaseType));
			if( pNewBuffer == NULL )
				return E_OUTOFMEMORY;

			*pBuffer = pNewBuffer;
			strcpyT<BaseType>( pNewBuffer, stringLen+1, data);
			_SetLength( nColumn, stringLen * sizeof(BaseType) );
		}
		else
		{
			BaseType* pBuffer = (BaseType*)_GetDataPtr(nColumn);
			if( stringLen >= m_pColumnInfo[nColumn].ulColumnSize / sizeof(BaseType) )
			{
				strcpyT<BaseType>( pBuffer, m_pColumnInfo[nColumn].ulColumnSize / sizeof(BaseType) - 1, data);
				pBuffer[m_pColumnInfo[nColumn].ulColumnSize / sizeof(BaseType) - 1] = 0;
				_SetLength( nColumn, m_pColumnInfo[nColumn].ulColumnSize - sizeof(BaseType));
				return DBSTATUS_S_TRUNCATED;
			}
			else
			{
				strcpyT<BaseType>( pBuffer, m_pColumnInfo[nColumn].ulColumnSize / sizeof(BaseType), data);
				_SetLength( nColumn, stringLen * sizeof(BaseType) );
			}
		}
		return S_OK;
	}

	HRESULT SetString(
		_In_ DBORDINAL nColumn,
		_In_z_ BaseType* data) throw()
	{
		if (TranslateColumnNo(nColumn))
			return _SetString(nColumn, data);
		else
			return DB_S_ERRORSOCCURRED;
	}
	HRESULT SetString(
		_In_z_ const CHAR* pColumnName,
		_In_z_ BaseType* data) throw()
	{
		ATLASSERT(pColumnName != NULL);
		DBORDINAL nColumn;
		if (GetInternalColumnNo(pColumnName, &nColumn))
			return _SetString(nColumn, data);
		else
			return DB_S_ERRORSOCCURRED;
	}
	HRESULT SetString(
		_In_z_ const WCHAR* pColumnName,
		_In_z_ BaseType* data) throw()
	{
		ATLASSERT(pColumnName != NULL);
		DBORDINAL nColumn;
		if (GetInternalColumnNo(pColumnName, &nColumn))
			return _SetString(nColumn, data);
		else
			return DB_S_ERRORSOCCURRED;
	}
};


typedef CDynamicStringAccessorT<CHAR, DBTYPE_STR> CDynamicStringAccessorA;
typedef CDynamicStringAccessorT<WCHAR, DBTYPE_WSTR> CDynamicStringAccessorW;

#ifdef _UNICODE
typedef CDynamicStringAccessorW CDynamicStringAccessor;
#else
typedef CDynamicStringAccessorA CDynamicStringAccessor;
#endif

class CXMLAccessor :
	public CDynamicStringAccessorW
{
public:

	HRESULT GetXMLColumnData(_Inout_ CSimpleStringW& strOutput) throw()
	{
		_ATLTRY
		{
			strOutput = L"<columninfo>\n";
			DBTYPE wType;
			DBORDINAL nColumns = m_nColumns;
			//If Bookmark column -> index is 0 based starting at bookmark - index 0.
			if (m_pColumnInfo->iOrdinal == 0 && m_nColumns > 0)
			{
				--nColumns;
			}
			for (ULONG i=1; i <= nColumns; i++)
			{
				strOutput += L"<column type=\"";
				if( !GetColumnType(i, &wType) )
					return E_FAIL;

				wType &= ~DBTYPE_BYREF;
				wType &= ~DBTYPE_ARRAY;
				wType &= ~DBTYPE_VECTOR;

				switch (wType)
				{
				case DBTYPE_BOOL:
					strOutput += L"BOOL";
					break;
				case DBTYPE_STR:
				case DBTYPE_WSTR:
					strOutput += L"STRING";
					break;
				case DBTYPE_I1:
					strOutput += L"I1";
					break;
				case DBTYPE_I2:
					strOutput += L"I2";
					break;
				case DBTYPE_I4:
					strOutput += L"I4";
					break;
				case DBTYPE_I8:
					strOutput += L"I8";
					break;
				case DBTYPE_UI1:
					strOutput += L"UI1";
					break;
				case DBTYPE_UI2:
					strOutput += L"UI2";
					break;
				case DBTYPE_UI4:
					strOutput += L"UI4";
					break;
				case DBTYPE_UI8:
					strOutput += L"UI8";
					break;
				case DBTYPE_R4:
					strOutput += L"R4";
					break;
				case DBTYPE_R8:
					strOutput += L"R8";
					break;
				case DBTYPE_DECIMAL:
					strOutput += L"DECIMAL";
					break;
				case DBTYPE_NUMERIC:
					strOutput += L"NUMERIC";
					break;
				case DBTYPE_VARIANT:
					strOutput += L"VARIANT";
					break;
				case DBTYPE_IDISPATCH:
					strOutput += L"DISPATCH";
					break;
				case DBTYPE_IUNKNOWN:
					strOutput += L"IUNKNOWN";
					break;
				case DBTYPE_GUID:
					strOutput += L"GUID";
					break;
				case DBTYPE_DBDATE:
					strOutput += L"DBDATE";
					break;
				case DBTYPE_DBTIME:
					strOutput += L"DBTIME";
					break;
				case DBTYPE_DBTIMESTAMP:
					strOutput += L"DBTIMESTAMP";
					break;
				case DBTYPE_FILETIME:
					strOutput += L"FILETIME";
					break;
				case DBTYPE_PROPVARIANT:
					strOutput += L"PROPVARIANT";
					break;
				case DBTYPE_VARNUMERIC:
					strOutput += L"VARNUMERIC";
					break;
				}
				strOutput += L"\">";
				strOutput += GetColumnName(i);
				strOutput += L"</column>\n";
			}
			strOutput += L"</columninfo>\n";
			return S_OK;
		}
		_ATLCATCH(e)
		{
			_ATLDELETEEXCEPTION(e)
			return E_FAIL;
		}
	}

	HRESULT GetXMLRowData(
		_Inout_ CSimpleStringW& strOutput,
		_In_ bool bAppend = false) throw()
	{
		_ATLTRY
		{
			LPOLESTR pszName;
			if (!bAppend)
				strOutput.Empty();
			strOutput += L"<row>";
			DBORDINAL nColumns = m_nColumns;
			//If Bookmark column -> index is 0 based starting at bookmark - index 0.
			if (m_pColumnInfo->iOrdinal == 0 && m_nColumns > 0)
			{
				--nColumns;
			}
			for (ULONG i=1; i<=nColumns; i++)
			{
				pszName = GetColumnName(i);
				strOutput += L"<";
				strOutput += pszName;
				strOutput += L">";
				DBSTATUS dbStatus=DBSTATUS_S_ISNULL;
				if( !GetStatus(i, &dbStatus) )
					return E_FAIL;

				if (dbStatus!=DBSTATUS_S_ISNULL)
					strOutput += GetString(i);

				strOutput += L"</";
				strOutput += pszName;
				strOutput += L">";
			}
			strOutput += L"</row>";
			return S_OK;
		}
		_ATLCATCH(e)
		{
			_ATLDELETEEXCEPTION(e)
			return E_FAIL;
		}
	}
};

// Like CDynamicAccessor but everything is bound as a DBTYPE_VARIANT
class CDynamicVariantAccessor :
	public CDynamicAccessor
{
public:
	HRESULT BindColumns(_Inout_ IUnknown* pUnk) throw()
	{
		ATLENSURE_RETURN(pUnk != NULL);
		CComPtr<IAccessor> spAccessor;
		HRESULT hr = pUnk->QueryInterface(&spAccessor);
		if (FAILED(hr))
			return hr;

		ULONG   i;
		DBBYTEOFFSET   nOffset = 0, nDataOffset, nLengthOffset, nStatusOffset;

		// If the user hasn't specifed the column information to bind by calling AddBindEntry then
		// we get it ourselves
		if (m_pColumnInfo == NULL)
		{
			CComPtr<IColumnsInfo> spColumnsInfo;
			hr = pUnk->QueryInterface(&spColumnsInfo);
			if (FAILED(hr))
				return hr;

			hr = spColumnsInfo->GetColumnInfo(&m_nColumns, &m_pColumnInfo, &m_pStringsBuffer);
			if (FAILED(hr))
				return hr;

			m_bOverride = false;
		}
		else
			m_bOverride = true;

		DBBINDING* pBinding = NULL;

		ATLTRY(pBinding= new DBBINDING[m_nColumns]);

		if (pBinding == NULL)
			return E_OUTOFMEMORY;

		CAutoVectorPtr<DBBINDING> spBinding(pBinding);

		DBBINDING* pCurrent = pBinding;
		DBOBJECT*  pObject;

		ATLASSUME(m_pColumnInfo != NULL || m_nColumns == 0);

		for (i = 0; i < m_nColumns; i++)
		{
			// If it's a BLOB or the column size is large enough for us to treat it as
			// a BLOB then we also need to set up the DBOBJECT structure.
			if (m_pColumnInfo[i].ulColumnSize > m_nBlobSize || m_pColumnInfo[i].wType == DBTYPE_IUNKNOWN)
			{
				pObject = NULL;
				ATLTRY(pObject = new DBOBJECT);
				if (pObject == NULL)
				{
					for( UINT t = 0; t < i; t++ )
						delete pBinding[t].pObject;
					return E_OUTOFMEMORY;
				}
				pObject->dwFlags = STGM_READ;
				pObject->iid     = __uuidof(ISequentialStream);
				m_pColumnInfo[i].wType      = DBTYPE_IUNKNOWN;
				m_pColumnInfo[i].ulColumnSize   = sizeof(IUnknown*);
			}
			else
				pObject = NULL;

			m_pColumnInfo[i].ulColumnSize = sizeof(VARIANT);

			// Calculate the column data offset
			nDataOffset = AlignAndIncrementOffset(nOffset, sizeof(VARIANT), __alignof(VARIANT));

			// Calculate the column length offset
			nLengthOffset = AlignAndIncrementOffset(nOffset, sizeof(DBLENGTH), __alignof(DBLENGTH));

			// Calculate the column status offset
			nStatusOffset = AlignAndIncrementOffset(nOffset, sizeof(DBSTATUS), __alignof(DBSTATUS));

			Bind(pCurrent, m_pColumnInfo[i].iOrdinal, DBTYPE_VARIANT,
				sizeof(VARIANT), m_pColumnInfo[i].bPrecision, m_pColumnInfo[i].bScale,
				DBPARAMIO_NOTPARAM, nDataOffset, nLengthOffset, nStatusOffset, pObject);
			pCurrent++;

			// Note that, as we're not using this for anything else, we're using the
			// pTypeInfo element to store the offset to our data.
			m_pColumnInfo[i].pTypeInfo = (ITypeInfo*)(ULONG_PTR)nDataOffset;
		}
		// Allocate the accessor memory if we haven't done so yet
		if (m_pAccessorInfo == NULL)
		{
			hr = AllocateAccessorMemory(1); // We only have one accessor
			if (FAILED(hr))
			{
				for( UINT t = 0; t < m_nColumns; t++ )
					delete pBinding[t].pObject;
				return hr;
			}
			m_pAccessorInfo->bAutoAccessor = true;
		}

		// Allocate enough memory for the data buffer and tell the rowset
		// Note that the rowset will free the memory in its destructor.
		m_pBuffer = NULL;
		ATLTRY(m_pBuffer = new BYTE[nOffset]);
		if (m_pBuffer == NULL)
		{
			for( UINT t = 0; t < m_nColumns; t++ )
				delete pBinding[t].pObject;
			return E_OUTOFMEMORY;
		}
		memset(m_pBuffer, 0, nOffset);
		hr = BindEntries(pBinding, m_nColumns, &m_pAccessorInfo->hAccessor,
				nOffset, spAccessor);

		return hr;
	}
};

///////////////////////////////////////////////////////////////////////////
// class CDynamicParameterAccessor

class CDynamicParameterAccessor :
	public CDynamicAccessor
{
// Constructors and Destructors
public:
	typedef CDynamicParameterAccessor _ParamClass;
	CDynamicParameterAccessor(
			_In_ DBBLOBHANDLINGENUM eBlobHandling = DBBLOBHANDLING_DEFAULT,
			_In_ DBLENGTH nBlobSize = 8000 )
		: CDynamicAccessor( eBlobHandling, nBlobSize )
	{
		m_pParameterEntry       = NULL;
		m_pParameterBuffer      = NULL;
		m_ppParamName           = NULL;
		m_nParameterBufferSize  = 0;
		m_nParams               = 0;
	};

	~CDynamicParameterAccessor()
	{
		delete [] m_pParameterEntry;
		if (m_ppParamName != NULL)
		{
			CoTaskMemFree(*m_ppParamName);
			delete [] m_ppParamName;
		}
		delete m_pParameterBuffer;
	};

	bool GetParamSize(
		_In_ DBORDINAL nParam,
		_Out_ DBLENGTH *pLength) const
	{
		ATLENSURE( pLength != NULL );

		if( !TranslateParameterNo( nParam ) )
			return false;

		*pLength = m_pParameterEntry[nParam].cbMaxLen;
		return true;
	}

	bool GetParamIO(
		_In_ DBORDINAL nParam,
		_Out_ DBPARAMIO *pParamIO) const
	{
		ATLENSURE( pParamIO != NULL );

		if( !TranslateParameterNo( nParam ) )
			return false;

		*pParamIO = m_pParameterEntry[nParam].eParamIO;
		return true;
	}

	bool GetParamType(
		_In_ DBORDINAL nParam,
		_Out_ DBTYPE *pType) const
	{
		ATLENSURE( pType != NULL );

		if( !TranslateParameterNo( nParam ) )
			return false;

		*pType = m_pParameterEntry[nParam].wType;
		return true;
	}
	bool GetParamLength(
		_In_ DBORDINAL nParam,
		_Out_ DBLENGTH *pLength)
	{
		ATLENSURE( pLength != NULL );

		DBLENGTH* pBuffer = GetParamLength(nParam);
		if (pBuffer == NULL)
			return false;
		*pLength = *pBuffer;
		return true;
	}
	bool SetParamLength(
		_In_ DBORDINAL nParam,
		_In_ DBLENGTH length)
	{
		DBLENGTH* pBuffer = GetParamLength(nParam);
		if (pBuffer == NULL)
			return false;
		*pBuffer = length;
		return true;
	}
	bool GetParamStatus(
		_In_ DBORDINAL nParam,
		_Out_ DBSTATUS *pStatus)
	{
		ATLENSURE( pStatus != NULL );

		DBSTATUS* pBuffer = GetParamStatus(nParam);
		if (pBuffer == NULL)
			return false;
		*pStatus = *pBuffer;
		return true;
	}
	bool SetParamStatus(
		_In_ DBORDINAL nParam,
		_In_ DBSTATUS status)
	{
		DBSTATUS* pBuffer = GetParamStatus(nParam);
		if (pBuffer == NULL)
			return false;
		*pBuffer = status;
		return true;
	}
	template <class ctype>
	bool GetParam(
		_In_ DBORDINAL nParam,
		_Out_ ctype* pData) const throw()
	{
		ATLENSURE_RETURN_VAL( pData != NULL, false);
		ctype* pBuffer = (ctype*)GetParam(nParam);
		if (pBuffer == NULL)
			return false;
		*pData = *pBuffer;
		return true;
	}

	bool GetParamString(
		_In_ DBORDINAL nParam,
		_Inout_ CSimpleStringA& strOutput) throw()
	{
		CHAR* pData = (CHAR*)GetParam(nParam);
		if (pData == NULL)
			return false;

		strOutput = pData;
		return true;
	}

	bool GetParamString(
		_In_ DBORDINAL nParam,
		_Inout_ CSimpleStringW& strOutput) throw()
	{
		WCHAR* pData = (WCHAR*)GetParam(nParam);
		if (pData == NULL)
			return false;

		strOutput = pData;
		return true;
	}

	bool GetParamString(
		_In_ DBORDINAL nParam,
		_Out_opt_z_cap_post_count_(*pMaxLen, *pMaxLen) CHAR* pBuffer,
		_Inout_ size_t* pMaxLen) throw()
	{
		ATLASSERT( pMaxLen != NULL );

		CHAR* pData = (CHAR*)GetParam(nParam);
		if (pData == NULL)
			return false;

		size_t nStrLen = strlen( pData );

		if( pBuffer == NULL )
		{
			*pMaxLen = nStrLen + 1;
			return true;
		}

		if( ( *pMaxLen ) < ( nStrLen + 1 ) )
		{
			return false;
		}

		Checked::strcpy_s( pBuffer, *pMaxLen, pData);
		return true;
	}

	bool GetParamString(
		_In_ DBORDINAL nParam,
		_Out_opt_z_cap_post_count_(*pMaxLen, *pMaxLen) WCHAR* pBuffer,
		_Inout_ size_t* pMaxLen) throw()
	{
		ATLASSERT( pMaxLen != NULL );

		WCHAR* pData = (WCHAR*)GetParam(nParam);
		if (pData == NULL)
			return false;

		size_t nStrLen = wcslen( pData );

		if( pBuffer == NULL )
		{
			*pMaxLen = nStrLen + 1;
			return true;
		}

		if( ( * pMaxLen ) < ( nStrLen + 1 ) )
		{
			return false;
		}

		Checked::wcscpy_s( pBuffer, *pMaxLen, pData);
		return true;
	}

	template <class ctype>
	bool SetParam(
		_In_ DBORDINAL nParam,
		_In_ const ctype* pData,
		_In_ DBSTATUS status = DBSTATUS_S_OK)
	{
		ATLENSURE( pData != NULL );

		if( !TranslateParameterNo( nParam ) )
			return false;

		ctype* pBuffer = (ctype*)_GetParam(nParam);
		if (pBuffer == NULL)
			return false;

		*pBuffer = *pData;

		DBSTATUS *pStatus = _GetParamStatus( nParam );
		if( pStatus != NULL )
			*pStatus = status;

		return true;
	}

	bool SetParamString(
		_In_ DBORDINAL nParam,
		_In_z_ const CHAR* pString,
		_In_ DBSTATUS status = DBSTATUS_S_OK )
	{
		ATLENSURE( pString != NULL );

		if( !TranslateParameterNo( nParam ) )
			return false;

		CHAR* pBuffer = (CHAR*)_GetParam(nParam);
		if (pBuffer == NULL)
			return false;

		size_t nMaxLen = m_pParameterEntry[nParam].cbMaxLen;
		if( strlen( pString ) >= nMaxLen )
			return false;

		Checked::strcpy_s(pBuffer, nMaxLen, pString);

		DBSTATUS *pStatus = _GetParamStatus( nParam );
		if( pStatus != NULL )
			*pStatus = status;
		DBLENGTH *pLength = _GetParamLength( nParam );
		if( pLength != NULL )
			*pLength = (DBLENGTH)(strlen(pBuffer));

		return true;
	}

	bool SetParamString(
		_In_ DBORDINAL nParam,
		_In_z_ const WCHAR* pString,
		_In_ DBSTATUS status = DBSTATUS_S_OK ) throw()
	{
		ATLASSUME( pString != NULL );

		if( !TranslateParameterNo( nParam ) )
			return false;

		WCHAR* pBuffer = (WCHAR*)_GetParam(nParam);
		if (pBuffer == NULL)
			return false;

		size_t nMaxLen = m_pParameterEntry[nParam].cbMaxLen / 2;
		if( Checked::wcsnlen( pString, nMaxLen ) >= nMaxLen )
			return false;

		Checked::wcscpy_s( pBuffer, nMaxLen, pString);

		DBSTATUS *pStatus = _GetParamStatus( nParam );
		if( pStatus != NULL )
			*pStatus = status;
		DBLENGTH *pLength = _GetParamLength( nParam );
		if( pLength != NULL )
			*pLength = (DBLENGTH)( sizeof(WCHAR) * wcslen(pBuffer));

		return true;
	}

	template <class ctype>
	bool GetParam(
		_In_z_ TCHAR* pParamName,
		_Out_ ctype* pData) const throw()
	{
		ATLENSURE_RETURN_VAL( pData != NULL, false);

		DBORDINAL nParam = 0;
		if( !_GetParameterNo( pParamName, nParam ) )
			return NULL;

		ctype* pBuffer = (ctype*)_GetParam(nParam);
		if (pBuffer == NULL)
			return false;

		*pData = *pBuffer;
		return true;
	}

	template <class ctype>
	bool SetParam(
		_In_z_ TCHAR* pParamName,
		_In_ const ctype* pData,
		_In_ DBSTATUS status = DBSTATUS_S_OK) throw()
	{
		ATLASSERT( pData != NULL );

		DBORDINAL nParam = 0;
		if( !_GetParameterNo( pParamName, nParam ) )
			return NULL;

		ctype* pBuffer = (ctype*)_GetParam(nParam);
		if (pBuffer == NULL)
			return false;

		*pBuffer = *pData;

		DBSTATUS *pStatus = _GetParamStatus( nParam );
		if( pStatus != NULL )
			*pStatus = status;
		//DBLENGTH *pLength = _GetParamLength( nParam );
		//if( pLength != NULL )
		//	*pLength = sizeof(ctype);

		return true;
	}

	void* GetParam(_In_ DBORDINAL nParam) const throw()
	{
		if( !TranslateParameterNo( nParam ) )
			return NULL;

		return _GetParam( nParam );
	}

	DBLENGTH* GetParamLength(_In_ DBORDINAL nParam) const throw()
	{
		if( !TranslateParameterNo( nParam ) )
			return NULL;

		return _GetParamLength( nParam );
	}

	DBSTATUS* GetParamStatus(_In_ DBORDINAL nParam) const throw()
	{
		if( !TranslateParameterNo( nParam ) )
			return NULL;

		return _GetParamStatus( nParam );
	}

	void* GetParam(_In_z_ TCHAR* pParamName) const throw()
	{
		ATLENSURE_RETURN_VAL( pParamName, NULL);
		DBORDINAL nParam = 0;
		if( !_GetParameterNo( pParamName, nParam ) )
			return NULL;

		return _GetParam( nParam );
	}

	// Get the number of parameters
	DB_UPARAMS GetParamCount() const throw()
	{
		return m_nParams;
	}

	// Get the parameter name for the passed parameter number
	LPOLESTR GetParamName(_In_ DBORDINAL nParam) const throw()
	{
		if( !TranslateParameterNo( nParam ) )
			return NULL;

		return m_ppParamName[nParam];
	}

	bool TranslateParameterNo(_Inout_ DBORDINAL& nParam) const throw()
	{
		for( DBORDINAL i = 0; i < m_nParams; i++ )
		{
			if( m_pParameterEntry[i].iOrdinal == nParam )
			{
				nParam = i;
				return true;
			}
		}

		return false;
	}

	bool _GetParameterNo(
		_In_z_ TCHAR* pParamName,
		_Out_ DBORDINAL& nParam) const throw()
	{
		if( pParamName == NULL )
			return false;

		DBORDINAL i;
		size_t    nSize = (lstrlen(pParamName) + 1) * sizeof(OLECHAR);
		CComBSTR  bstrParamName(pParamName);

		for (i=0; i<m_nParams; i++)
		{
			if (memcmp(m_ppParamName[i], bstrParamName.m_str, nSize) == 0)
			{
				nParam = i;
				return true;
			}
		}

		return false;    // Not Found
	}

	void* _GetParam(_In_ DBORDINAL nParam) const throw()
	{
		return m_pParameterBuffer + m_pParameterEntry[nParam].obValue;
	}

	DBLENGTH* _GetParamLength(_In_ DBORDINAL nParam) const throw()
	{
		if( m_pParameterEntry[nParam].obLength == 0 )
			return NULL;
		else
			return (DBLENGTH*)(m_pParameterBuffer + m_pParameterEntry[nParam].obLength);
	}

	DBSTATUS* _GetParamStatus(_In_ DBORDINAL nParam) const throw()
	{
		if( m_pParameterEntry[nParam].obStatus == 0 )
			return NULL;
		else
			return (DBSTATUS*)(m_pParameterBuffer + m_pParameterEntry[nParam].obStatus);
	}

// Implementation
	HRESULT BindParameters(
		_In_ HACCESSOR* pHAccessor,
		_Inout_ ICommand* pCommand,
		_Deref_out_ void** ppParameterBuffer,
		_In_ bool fBindLength = false,
		_In_ bool fBindStatus = false) throw()
	{
		// If we have already bound the parameters then just return
		// the pointer to the parameter buffer
		if (*pHAccessor != 0)
		{
			*ppParameterBuffer = m_pParameterBuffer;
			return S_OK;
		}

		CComPtr<IAccessor> spAccessor;
		ATLENSURE_RETURN(pCommand != NULL);
		HRESULT hr = pCommand->QueryInterface(&spAccessor);
		if (FAILED(hr))
			return hr;

		// Try to bind parameters if available
		CComPtr<ICommandWithParameters> spCommandParameters;
		hr = pCommand->QueryInterface(&spCommandParameters);
		if (FAILED(hr))
			return hr;

		DB_UPARAMS ulParams     = 0;
		CComHeapPtr<DBPARAMINFO>    spParamInfo;
		LPOLESTR pNamesBuffer;

		// Get Parameter Information
		hr = spCommandParameters->GetParameterInfo(&ulParams, &spParamInfo,
				&pNamesBuffer);
		if (FAILED(hr))
			return hr;

		// Create the parameter information for binding
		hr = AllocateParameterInfo(ulParams);
		if (FAILED(hr))
		{
			CoTaskMemFree(pNamesBuffer);
			return hr;
		}

		DBBYTEOFFSET nOffset = 0;
		DBBYTEOFFSET nDataOffset = 0;
		DBBYTEOFFSET nLengthOffset = 0;
		DBBYTEOFFSET nStatusOffset = 0;

		DBBINDING* pCurrent = m_pParameterEntry;
		for (ULONG l=0; l<ulParams; l++)
		{
			m_pParameterEntry[l].eParamIO = 0;

			if (spParamInfo[l].dwFlags & DBPARAMFLAGS_ISINPUT)
				m_pParameterEntry[l].eParamIO |= DBPARAMIO_INPUT;

			if (spParamInfo[l].dwFlags & DBPARAMFLAGS_ISOUTPUT)
				m_pParameterEntry[l].eParamIO |= DBPARAMIO_OUTPUT;

			// if this is a BLOB, truncate column length to m_nBlobSize (like 8000 bytes)
			if( spParamInfo[l].ulParamSize > m_nBlobSize )
				spParamInfo[l].ulParamSize = m_nBlobSize;

			// if this is a string, recalculate column size in bytes
			DBLENGTH colLength = spParamInfo[l].ulParamSize;
			if (spParamInfo[l].wType == DBTYPE_STR)
				colLength += 1;
			if (spParamInfo[l].wType == DBTYPE_WSTR)
				colLength = colLength*2 + 2;

			// Calculate the column data offset
			nDataOffset = AlignAndIncrementOffset( nOffset, colLength, GetAlignment( spParamInfo[l].wType ) );

			if( fBindLength )
			{
				// Calculate the column length offset
				nLengthOffset = AlignAndIncrementOffset( nOffset, sizeof(DBLENGTH), __alignof(DBLENGTH) );
			}

			if( fBindStatus )
			{
				// Calculate the column status offset
				nStatusOffset = AlignAndIncrementOffset( nOffset, sizeof(DBSTATUS), __alignof(DBSTATUS) );
			}

			Bind(pCurrent, spParamInfo[l].iOrdinal, spParamInfo[l].wType,
				colLength, spParamInfo[l].bPrecision, spParamInfo[l].bScale,
				m_pParameterEntry[l].eParamIO, nDataOffset, nLengthOffset, nStatusOffset );

			pCurrent++;

			m_ppParamName[l] = pNamesBuffer;
			if (pNamesBuffer && *pNamesBuffer)
			{
				// Search for the NULL termination character
				while (*pNamesBuffer++)
					;
			}
		}

		// Allocate memory for the new buffer
		m_pParameterBuffer = NULL;
		ATLTRY(m_pParameterBuffer = new BYTE[nOffset]);
		if (m_pParameterBuffer == NULL)
		{
			// Note that pNamesBuffer will be freed in the destructor
			// by freeing *m_ppParamName
			return E_OUTOFMEMORY;
		}
		*ppParameterBuffer = m_pParameterBuffer;
		m_nParameterBufferSize = nOffset;
		m_nParams = ulParams;
		BindEntries(m_pParameterEntry, ulParams, pHAccessor, nOffset, spAccessor);

		return S_OK;
	}
	bool HasParameters() const throw()
	{
		return true;
	}
	HRESULT AllocateParameterInfo(_In_ DB_UPARAMS nParamEntries) throw()
	{
		// Allocate memory for the bind structures
		m_pParameterEntry = NULL;
		ATLTRY(m_pParameterEntry = new DBBINDING[nParamEntries]);
		if (m_pParameterEntry == NULL)
			return E_OUTOFMEMORY;

		// Allocate memory to store the field names
		m_ppParamName = NULL;
		ATLTRY(m_ppParamName = new OLECHAR*[nParamEntries]);
		if (m_ppParamName == NULL)
		{
			delete [] m_pParameterEntry;
			m_pParameterEntry = NULL;
			return E_OUTOFMEMORY;
		}
		return S_OK;
	}

// Data Members
	// Number of parameters
	DB_UPARAMS          m_nParams;
	// A pointer to the entry structures for each parameter
	DBBINDING*          m_pParameterEntry;
	// String names for the parameters
	OLECHAR**           m_ppParamName;
	// The size of the buffer where the parameters are stored
	DBLENGTH            m_nParameterBufferSize;
	// A pointer to the buffer where the parameters are stored
	BYTE*               m_pParameterBuffer;
};


///////////////////////////////////////////////////////////////////////////
// class CManualAccessor

class CManualAccessor :
	public CAccessorBase
{
public:
	CManualAccessor()
	{
		// By default we don't have any parameters unless CreateParameterAccessor
		// is called
		m_pEntry          = NULL;
		m_nParameters     = 0;
		m_pParameterEntry = NULL;
		m_nColumns        = 0;
		m_pParameterBuffer = NULL;
	}
	~CManualAccessor()
	{
		delete [] m_pEntry;
		delete [] m_pParameterEntry;
	}

	HRESULT ReleaseAccessors(_Inout_ IUnknown* pUnk) throw()
	{
		FreeRecordMemory( (IRowset*) pUnk );
		return CAccessorBase::ReleaseAccessors(pUnk);
	}

	HRESULT CreateAccessor(
		_In_ int nBindEntries,
		_In_bytecount_(nBufferSize) void* pBuffer,
		_In_ DBLENGTH nBufferSize) throw()
	{
		m_pBuffer     = (BYTE*)pBuffer;
		m_nBufferSize = nBufferSize;
		m_nColumns    = 0;
		m_nEntry      = 0;
		memset(pBuffer, 0, nBufferSize);

		// If they've previously created some entries then free them
		delete [] m_pEntry;
		m_pEntry = NULL;

		// Allocate memory for the bind structures
		ATLTRY(m_pEntry = new DBBINDING[nBindEntries]);
		if (m_pEntry == NULL)
			return E_OUTOFMEMORY;

		m_nColumns    = nBindEntries;

		return S_OK;
	}
	HRESULT CreateParameterAccessor(
		_In_ int nBindEntries,
		_In_bytecount_(nBufferSize) void* pBuffer,
		_In_ DBLENGTH nBufferSize) throw()
	{
		// Should be called only once.  But, if you really insist on doing this...
		if (m_pParameterEntry != NULL)
		{
			delete [] m_pParameterEntry;
			m_pParameterEntry = NULL;
		}

		m_pParameterBuffer     = (BYTE*)pBuffer;
		m_nParameterBufferSize = nBufferSize;
		m_nParameters          = 0;
		m_nCurrentParameter    = 0;

		// Allocate memory for the bind structures
		ATLTRY(m_pParameterEntry = new DBBINDING[nBindEntries]);
		if (m_pParameterEntry == NULL)
			return E_OUTOFMEMORY;

		m_nParameters          = nBindEntries;

		return S_OK;
	}
	void AddBindEntry(
		_In_ DBORDINAL nOrdinal,
		_In_ DBTYPE wType,
		_In_ DBLENGTH nColumnSize,
		_In_ void* pData,
		_In_opt_ void* pLength = NULL,
		_In_opt_ void* pStatus = NULL) throw()
	{
		ATLASSUME(m_nEntry < m_nColumns);
		DBBYTEOFFSET   nLengthOffset, nStatusOffset;

		if (pStatus != NULL)
			nStatusOffset = (BYTE*)pStatus - m_pBuffer;
		else
			nStatusOffset = 0;

		if (pLength != NULL)
			nLengthOffset = (BYTE*)pLength - m_pBuffer;
		else
			nLengthOffset = 0;

		Bind(m_pEntry+m_nEntry, nOrdinal, wType, nColumnSize, 0, 0, DBPARAMIO_NOTPARAM,
			(BYTE*)pData - m_pBuffer, nLengthOffset, nStatusOffset);

		m_nEntry++;
	}
	void AddParameterEntry(
		_In_ DBORDINAL nOrdinal,
		_In_ DBTYPE wType,
		_In_ DBLENGTH nColumnSize,
		_In_ void* pData,
		_In_opt_ void* pLength = NULL,
		_In_opt_ void* pStatus = NULL,
		_In_ DBPARAMIO eParamIO = DBPARAMIO_INPUT) throw()
	{
		ATLASSUME(m_nCurrentParameter < m_nParameters);
		DBBYTEOFFSET nLengthOffset, nStatusOffset;

		if (pStatus != NULL)
			nStatusOffset = (BYTE*)pStatus - m_pParameterBuffer;
		else
			nStatusOffset = 0;

		if (pLength != NULL)
			nLengthOffset = (BYTE*)pLength - m_pParameterBuffer;
		else
			nLengthOffset = 0;

		Bind(m_pParameterEntry + m_nCurrentParameter, nOrdinal, wType, nColumnSize, 0, 0,
			eParamIO, (BYTE*)pData - m_pParameterBuffer, nLengthOffset, nStatusOffset);

		m_nCurrentParameter++;
	}

// Implementation
	// Free's any columns in the current record that need to be freed.
	// E.g. Calls SysFreeString on any BSTR's and Release on any interfaces.
	void FreeRecordMemory(_Inout_ IRowset* pRowset) throw ()
	{
		ULONG i;

		for (i = 0; i < m_nColumns; i++)
			CAccessorBase::FreeType(m_pEntry[i].wType, m_pBuffer + m_pEntry[i].obValue, pRowset);
	}

	void ClearRecordMemory() throw()
	{
		memset(m_pBuffer, 0, m_nBufferSize);
	}

	HRESULT BindColumns(_Inout_ IUnknown* pUnk) throw()
	{
		ATLENSURE_RETURN(pUnk != NULL);
		CComPtr<IAccessor> spAccessor;
		HRESULT hr = pUnk->QueryInterface(&spAccessor);
		if (FAILED(hr))
			return hr;

		// Allocate the accessor memory if we haven't done so yet
		if (m_pAccessorInfo == NULL)
		{
			hr = AllocateAccessorMemory(1); // We only have one accessor
			if (FAILED(hr))
				return hr;
			m_pAccessorInfo->bAutoAccessor = true;
		}

		return BindEntries(m_pEntry, m_nColumns, &m_pAccessorInfo->hAccessor, m_nBufferSize, spAccessor);
	}

	HRESULT BindParameters(
		_In_ HACCESSOR* pHAccessor,
		_Inout_ ICommand* pCommand,
		_Deref_out_ void** ppParameterBuffer) throw()
	{
		HRESULT hr;
		ATLENSURE_RETURN(ppParameterBuffer);
		*ppParameterBuffer = m_pParameterBuffer;

		// Only bind the parameter if we haven't done so yet
		if (*pHAccessor == 0)
		{
			// Get the IAccessor from the passed IUnknown
			CComPtr<IAccessor> spAccessor;
			ATLENSURE_RETURN(pCommand != NULL);
			hr = pCommand->QueryInterface(&spAccessor);
			if (SUCCEEDED(hr))
			{
				hr = BindEntries(m_pParameterEntry, m_nParameters, pHAccessor,
						m_nParameterBufferSize, spAccessor);
			}
		}
		else
			hr = S_OK;

		return hr;
	}

	typedef CManualAccessor _ParamClass;
	typedef CManualAccessor _OutputColumnsClass;

	bool HasParameters() throw()
	{
		return (m_nParameters > 0);
	}
	bool HasOutputColumns() throw()
	{
		return (m_nColumns > 0);
	}
	DBORDINAL GetColumnCount() const throw()
	{
		return m_nColumns;
	}

	// The binding structure for the output columns
	DBBINDING*          m_pEntry;
	// The number of output columns
	DBORDINAL           m_nColumns;
	// The number of the current entry for the output columns
	DBORDINAL           m_nEntry;
	// The size of the data buffer for the output columns
	DBLENGTH            m_nBufferSize;
	// The number of parameters columns
	DBORDINAL           m_nParameters;
	// The number of the parameter column to bind next
	DBORDINAL           m_nCurrentParameter;
	// A pointer to the entry structures for each parameter
	DBBINDING*          m_pParameterEntry;
	// The size of the buffer where the parameters are stored
	DBLENGTH            m_nParameterBufferSize;
	// A pointer to the buffer where the parameters are stored
	BYTE*               m_pParameterBuffer;
};

class _ATL_COLUMN_PARAM_INFO
{
public:
	_ATL_COLUMN_PARAM_INFO()
	{
		m_pParams = NULL;
		m_pBuffer = NULL;
	}
	~_ATL_COLUMN_PARAM_INFO()
	{
		delete m_pParams;
	}
	BOOL AddBinding(_In_ DBBINDING& binding)
	{
		return m_rgBinding.Add(binding);
	}

	CSimpleArray<DBBINDING, CSimpleArrayEqualHelperFalse<DBBINDING> >	m_rgBinding;	// The binding for each parameter
	DBPARAMS*				m_pParams;
	BYTE*					m_pBuffer;
};

///////////////////////////////////////////////////////////////////////////
// CColumnAccessor
class CColumnAccessor :
	public CAccessorBase
{
public:
	CColumnAccessor()
	{
		m_pParamInfo = NULL;
	}
	~CColumnAccessor()
	{
		delete m_pParamInfo;
	}

	HRESULT ReleaseAccessors(_Inout_ IUnknown* pUnk) throw()
	{
		FreeRecordMemory( (IRowset*) pUnk );
		return CAccessorBase::ReleaseAccessors(pUnk);
	}

	// pUnk is the interface the accessor will be created upon
	HRESULT CreateAccessor(
		_Inout_ IUnknown* pUnk,
		_In_ DBORDINAL nOrdinal,
		_In_ DBTYPE wType,
		_In_ DBLENGTH nColumnSize,
		_In_ BYTE nPrecision,
		_In_ BYTE nScale,
		_In_ void* pData) throw()
	{
		(nPrecision);
		(nScale);
		ATLENSURE_RETURN(pUnk != NULL);
		DBBINDING binding;

		Bind(&binding, nOrdinal, wType, nColumnSize, 0, 0, DBPARAMIO_NOTPARAM,
			(BYTE*)pData - m_pBuffer);

		CComPtr<IAccessor> spAccessor;
		HRESULT hr = pUnk->QueryInterface(&spAccessor);
		if (FAILED(hr))
			return hr;

		// Add another accessor info structure
		AddAccessorInfo();
		_ATL_ACCESSOR_INFO* pAccessorInfo = m_pAccessorInfo + m_nAccessors - 1;

		pAccessorInfo->bAutoAccessor = true;	// Always auto

		// Bind it
		return BindEntries(&binding, 1, &pAccessorInfo->hAccessor, nColumnSize, spAccessor);
	}
	// Bind columns doesn't have to do anything here as we bind each accessor when
	// CreateAccessor is called
	HRESULT BindColumns(_In_opt_ IUnknown*) throw()
	{
		return S_OK;
	}
	HRESULT SetParameterBuffer(_In_opt_ BYTE* pBuffer) throw()
	{
		// This should only be called once.
		ATLASSUME(m_pParamInfo == NULL);

		ATLTRY(m_pParamInfo = new _ATL_COLUMN_PARAM_INFO);
		if (m_pParamInfo == NULL)
			return E_OUTOFMEMORY;

		m_pParamInfo->m_pBuffer = pBuffer;
		return S_OK;
	}
	HRESULT AddParameter(
		_In_ DBPARAMIO paramio,
		_In_ DBORDINAL nOrdinal,
		_In_ DBTYPE wType,
		_In_ DBLENGTH nColumnSize,
		_In_ BYTE /* nPrecision*/,
		_In_ BYTE /* nScale */,
		_In_ void* pData) throw()
	{
		ATLASSUME(m_pParamInfo != NULL);

		DBBINDING binding;

		Bind(&binding, nOrdinal, wType, nColumnSize, 0, 0, paramio,
			(BYTE*)pData - m_pParamInfo->m_pBuffer);

		if (m_pParamInfo->AddBinding(binding) == FALSE)
			return E_OUTOFMEMORY;

		return S_OK;
	}
	bool HasOutputColumns() throw()
	{
		if( m_nAccessors )
			return true;
		else
			return false;
	}
	bool HasParameters() const throw()
	{
		return (m_pParamInfo != NULL) ? true : false;
	}
	// Called to bind the parameters created
	HRESULT BindParameters(
		_In_ HACCESSOR* pHAccessor,
		_Inout_ ICommand* pCommand,
		_Deref_out_ void** ppParameterBuffer)
	{
		ATLASSUME(m_pParamInfo != NULL);
		HRESULT hr = S_OK;

		// Only bind the parameters if we haven't already done it
		if (*pHAccessor == 0)
		{
			// Get the IAccessor from the passed ICommand
			CComPtr<IAccessor> spAccessor;
			ATLENSURE_RETURN(pCommand != NULL);
			hr = pCommand->QueryInterface(&spAccessor);
			if (SUCCEEDED(hr))
			{
				*ppParameterBuffer = m_pParamInfo->m_pBuffer;
				// size isn't being passed here
				hr = BindEntries(&m_pParamInfo->m_rgBinding[0], m_pParamInfo->m_rgBinding.GetSize(),
					pHAccessor, 4, spAccessor);
			}

		}
		return hr;
	}
// Implementation
	typedef CColumnAccessor _ParamClass;
	typedef CColumnAccessor _OutputColumnsClass;

	HRESULT AddAccessorInfo() throw()
	{
		_ATL_ACCESSOR_INFO* pAccessorInfo = NULL;
		ATLTRY( pAccessorInfo = new _ATL_ACCESSOR_INFO[m_nAccessors + 1]; )
		if (pAccessorInfo == NULL)
			return E_OUTOFMEMORY;

		// Now copy the current accessor information to the new buffer
		Checked::memcpy_s(pAccessorInfo, sizeof(_ATL_ACCESSOR_INFO) * m_nAccessors, m_pAccessorInfo, sizeof(_ATL_ACCESSOR_INFO) * m_nAccessors);
		m_nAccessors++;

		// Now delete the old memory and use the new one
		delete [] m_pAccessorInfo;
		m_pAccessorInfo = pAccessorInfo;
		return S_OK;
	}
	_ATL_COLUMN_PARAM_INFO* m_pParamInfo;
};

///////////////////////////////////////////////////////////////////////////
// CAccessorRowset
template <class TAccessor = CNoAccessor, template <typename T> class TRowset = CRowset>
class CAccessorRowset :
	public TAccessor,
	public TRowset<TAccessor>
{
public:
	CAccessorRowset()
	{
		// Give the rowset a pointer to the accessor
		__if_exists(m_nAccessors)
		{
			SetAccessor(this);
		}
	}
	~CAccessorRowset()
	{
		Close();
	}
ATLPREFAST_SUPPRESS(6387)
	// Used to get the column information from the opened rowset. The user is responsible
	// for freeing the returned column information and string buffer.
	HRESULT GetColumnInfo(
		_In_ DBORDINAL* pulColumns,
		_Deref_out_ DBCOLUMNINFO** ppColumnInfo,
		_Deref_out_z_ LPOLESTR* ppStrings) const throw()
	{
		if (ppColumnInfo == NULL || pulColumns == NULL || ppStrings == NULL)
			return E_POINTER;

		ATLASSERT(GetInterface() != NULL);
		if (GetInterface() == NULL)
			return E_FAIL;
		CComPtr<IColumnsInfo> spColumns;
		HRESULT hr = GetInterface()->QueryInterface(&spColumns);
		if (SUCCEEDED(hr))
			hr = spColumns->GetColumnInfo(pulColumns, ppColumnInfo, ppStrings);

		return hr;
	}
ATLPREFAST_UNSUPPRESS()
	
	// Used to get the column information when overriding the bindings using CDynamicAccessor
	// The user should CoTaskMemFree the column information pointer that is returned.
	HRESULT GetColumnInfo(
		_In_ DBORDINAL* pColumns,
		_Deref_out_ DBCOLUMNINFO** ppColumnInfo) throw()
	{
		// If you get a compilation here, then you are most likely calling this function
		// from a class that is not using CDynamicAccessor.
		ATLASSERT(GetInterface() != NULL);
		if (GetInterface() == NULL)
			return E_FAIL;

		ATLASSUME(ppColumnInfo != NULL);

		return TAccessor::GetColumnInfo(GetInterface(), pColumns, ppColumnInfo);
	}
	
	// Call to bind the output columns
	HRESULT Bind() throw()
	{
		// Bind should only be called when we've successfully opened the rowset
		ATLASSERT(GetInterface() != NULL);
		if (GetInterface() == NULL)
			return E_FAIL;
		HRESULT hr = TAccessor::BindColumns(GetInterface());
		if (SUCCEEDED(hr))
			hr = BindFinished();
		return hr;
	}
	// Close the opened rowset and release the created accessors for the output columns
	void Close() throw()
	{
		if (GetInterface() != NULL)
		{
			ReleaseAccessors(GetInterface());
			TAccessor::Close();
			TRowset<TAccessor>::Close();
		}
	}
	// Free's any columns in the current record that need to be freed.
	// E.g. Calls SysFreeString on any BSTR's and Release on any interfaces.
	void FreeRecordMemory() throw()
	{
		TAccessor::FreeRecordMemory(m_spRowset);
	}
	void FreeRecordMemory(int nAccessor) throw()
	{
		TAccessor::FreeRecordMemory(nAccessor, m_spRowset);
	}
};

///////////////////////////////////////////////////////////////////////////
// class CEnumeratorAccessor

class CEnumeratorAccessor
{
public:
	WCHAR           m_szName[129];
	WCHAR           m_szParseName[129];
	WCHAR           m_szDescription[129];
	USHORT          m_nType;
	VARIANT_BOOL    m_bIsParent;

// Binding Maps
BEGIN_COLUMN_MAP(CEnumeratorAccessor)
	COLUMN_ENTRY(1, m_szName)
	COLUMN_ENTRY(2, m_szParseName)
	COLUMN_ENTRY(3, m_szDescription)
	COLUMN_ENTRY(4, m_nType)
	COLUMN_ENTRY(5, m_bIsParent)
END_COLUMN_MAP()
};


///////////////////////////////////////////////////////////////////////////
// class CEnumerator

class CEnumerator :
	public CAccessorRowset<CAccessor<CEnumeratorAccessor> >
{
public:
	HRESULT Open(_In_ LPMONIKER pMoniker) throw()
	{
		if (pMoniker == NULL)
			return E_FAIL;

		// Bind the moniker for the sources rowset
		if (FAILED(BindMoniker(pMoniker, 0, __uuidof(ISourcesRowset),
					(void**)&m_spSourcesRowset)))
			return E_FAIL;

		// Enumerate the data sources
		if (FAILED(m_spSourcesRowset->GetSourcesRowset(NULL, __uuidof(IRowset), 0,
			NULL, (IUnknown**)&m_spRowset)))
			return E_FAIL;

		return Bind();
	}
	HRESULT Open(_In_ const CEnumerator& enumerator) throw()
	{
		HRESULT hr;
		CComPtr<IMoniker> spMoniker;

		hr = enumerator.GetMoniker(&spMoniker);
		if (FAILED(hr))
			return hr;

		return Open(spMoniker);
	}
	HRESULT Open(_In_ const CLSID* pClsid = &CLSID_OLEDB_ENUMERATOR) throw()
	{
		if (pClsid == NULL)
			return E_FAIL;

		HRESULT hr;
		// Create the enumerator
		hr = CoCreateInstance(*pClsid, NULL, CLSCTX_INPROC_SERVER,
				__uuidof(ISourcesRowset), (LPVOID*)&m_spSourcesRowset);
		if (FAILED(hr))
			return hr;

		// Get the rowset so we can enumerate the data sources
		hr = m_spSourcesRowset->GetSourcesRowset(NULL, __uuidof(IRowset), 0,
			NULL, (IUnknown**)&m_spRowset);
		if (FAILED(hr))
			return hr;

		return Bind();
	}

	void Close() throw()
	{
		// Close the rowset pointer
		if (m_spSourcesRowset != NULL)
			m_spSourcesRowset.Release();

		// Close the base class pointers
		CAccessorRowset<CAccessor<CEnumeratorAccessor> >::Close();
	}

	HRESULT GetMoniker(_Deref_out_ LPMONIKER* ppMoniker) const throw()
	{
		CComPtr<IParseDisplayName> spParse;
		HRESULT hr;
		ULONG   chEaten;

		if (ppMoniker == NULL)
			return E_POINTER;

		if (m_spSourcesRowset == NULL)
			return E_FAIL;

		hr = m_spSourcesRowset->QueryInterface(__uuidof(IParseDisplayName), (void**)&spParse);
		if (FAILED(hr))
			return hr;

		hr = spParse->ParseDisplayName(NULL, (LPOLESTR)m_szParseName,
				&chEaten, ppMoniker);
		return hr;
	}

	HRESULT GetMoniker(
		_Deref_out_ LPMONIKER* ppMoniker,
		_In_z_ LPCTSTR lpszDisplayName) const throw()
	{
		CComPtr<IParseDisplayName> spParse;
		HRESULT hr;
		ULONG   chEaten;

		if (ppMoniker == NULL || lpszDisplayName == NULL)
			return E_POINTER;

		if (m_spSourcesRowset == NULL)
			return E_FAIL;

		hr = m_spSourcesRowset->QueryInterface(__uuidof(IParseDisplayName), (void**)&spParse);
		if (FAILED(hr))
			return hr;

		hr = spParse->ParseDisplayName(NULL, (LPOLESTR)CComBSTR(lpszDisplayName),
				&chEaten, ppMoniker);
		return hr;
	}

	bool Find(_In_z_ TCHAR* szSearchName) throw()
	{
		CT2W ctSearchName(szSearchName);
		WCHAR *wszSearchName = ctSearchName;

		// Loop through the providers looking for the passed name
		while (MoveNext()==S_OK && lstrcmpW(m_szName, wszSearchName))
		{
			ATLTRACE(atlTraceDBClient, 2, _T("%s, %s, %d\n"), m_szName, m_szParseName, m_nType);
		}
		if (lstrcmpW(m_szName, wszSearchName))
			return false;
		else
			return true;
	}

	CComPtr<ISourcesRowset> m_spSourcesRowset;
};


///////////////////////////////////////////////////////////////////////////
// CDataSource

class CDataSource
{
public:
	HRESULT Open(
		_In_ const CLSID& clsid,
		_Inout_opt_cap_(nPropertySets) DBPROPSET* pPropSet = NULL,
		_In_ ULONG nPropertySets=1) throw()
	{
		HRESULT hr;

		m_spInit.Release();
		hr = CoCreateInstance(clsid, NULL, CLSCTX_INPROC_SERVER, __uuidof(IDBInitialize),
				(void**)&m_spInit);
		if (FAILED(hr))
			return hr;

		// Initialize the provider
		return OpenWithProperties(pPropSet, nPropertySets);
	}
	HRESULT Open(
		_In_ const CLSID& clsid,
		_In_z_ LPCTSTR pName,
		_In_opt_z_ LPCTSTR pUserName = NULL,
		_In_opt_z_ LPCTSTR pPassword = NULL,
		_In_ long nInitMode = 0) throw()
	{
		m_spInit.Release();
		HRESULT hr = CoCreateInstance(clsid, NULL, CLSCTX_INPROC_SERVER, __uuidof(IDBInitialize),
				(void**)&m_spInit);
		if (FAILED(hr))
			return hr;

		return OpenWithNameUserPassword(pName, pUserName, pPassword, nInitMode);
	}
	HRESULT Open(
		_In_z_ LPCSTR szProgID,
		_Inout_opt_cap_(nPropertySets) DBPROPSET* pPropSet = NULL,
		_In_ ULONG nPropertySets=1) throw()
	{
		HRESULT hr;
		CLSID   clsid;

		hr = CLSIDFromProgID(CComBSTR(szProgID), &clsid);
		if (FAILED(hr))
		{
			return hr;
		}

		return Open(clsid, pPropSet, nPropertySets);
	}
	HRESULT Open(
		_In_z_ LPCWSTR szProgID,
		_In_z_ LPCTSTR pName,
		_In_opt_z_ LPCTSTR pUserName = NULL,
		_In_opt_z_ LPCTSTR pPassword = NULL,
		_In_ long nInitMode = 0) throw()
	{
		CLSID clsid;

		HRESULT hr = CLSIDFromProgID(szProgID, &clsid);
		if (FAILED(hr))
			return hr;

		return Open(clsid, pName, pUserName, pPassword, nInitMode);
	}
	HRESULT Open(
		_In_z_ LPCWSTR szProgID,
		_Inout_opt_cap_(nPropertySets) DBPROPSET* pPropSet = NULL,
		_In_ ULONG nPropertySets=1) throw()
	{
		HRESULT hr;
		CLSID   clsid;

		hr = CLSIDFromProgID(szProgID, &clsid);
		if (FAILED(hr))
			return hr;

		return Open(clsid, pPropSet, nPropertySets);
	}
	HRESULT Open(
		_In_z_ LPCSTR szProgID,
		_In_z_ LPCTSTR pName,
		_In_opt_z_ LPCTSTR pUserName = NULL,
		_In_opt_z_ LPCTSTR pPassword = NULL,
		_In_ long nInitMode = 0) throw()
	{
		CLSID   clsid;

		HRESULT hr = CLSIDFromProgID(CComBSTR(szProgID), &clsid);
		if (FAILED(hr))
		{
			return hr;
		}

		return Open(clsid, pName, pUserName, pPassword, nInitMode);
	}
	HRESULT Open(
		_In_ const CEnumerator& enumerator,
		_Inout_opt_cap_(nPropertySets) DBPROPSET* pPropSet = NULL,
		_In_ ULONG nPropertySets=1) throw()
	{
		CComPtr<IMoniker> spMoniker;

		HRESULT hr = enumerator.GetMoniker(&spMoniker);
		if (FAILED(hr))
			return hr;

		m_spInit.Release();
		//  Now bind the moniker
		hr = BindMoniker(spMoniker, 0, __uuidof(IDBInitialize), (void**)&m_spInit);
		if (FAILED(hr))
			return hr;

		return OpenWithProperties(pPropSet, nPropertySets);
	}
	HRESULT Open(
		_In_ const CEnumerator& enumerator,
		_In_z_ LPCTSTR pName,
		_In_opt_z_ LPCTSTR pUserName = NULL,
		_In_opt_z_ LPCTSTR pPassword = NULL,
		_In_ long nInitMode = 0) throw()
	{
		CComPtr<IMoniker> spMoniker;

		HRESULT hr = enumerator.GetMoniker(&spMoniker);
		if (FAILED(hr))
			return hr;

		m_spInit.Release();
		//  Now bind the moniker
		hr = BindMoniker(spMoniker, 0, __uuidof(IDBInitialize), (void**)&m_spInit);
		if (FAILED(hr))
			return hr;

		return OpenWithNameUserPassword(pName, pUserName, pPassword, nInitMode);
	}
	// Invoke the data links dialog and open the selected database
	HRESULT Open(
		_In_ HWND hWnd = GetActiveWindow(),
		_In_ DBPROMPTOPTIONS dwPromptOptions = DBPROMPTOPTIONS_WIZARDSHEET) throw()
	{
		CComPtr<IDBPromptInitialize> spDBInit;

		HRESULT hr = CoCreateInstance(__uuidof(DataLinks), NULL, CLSCTX_INPROC_SERVER,
			__uuidof(IDBPromptInitialize), (void**) &spDBInit);
		if (FAILED(hr))
			return hr;

		CComPtr<IDBProperties> spIDBProperties;
		hr = spDBInit->PromptDataSource(NULL, hWnd, dwPromptOptions, 0, NULL, NULL,
			__uuidof(IDBProperties), (IUnknown**)&spIDBProperties);

		if (hr == S_OK)
		{
			hr = spIDBProperties->QueryInterface(&m_spInit);
			if (SUCCEEDED(hr))
				hr = m_spInit->Initialize();
		}
		return hr;
	}
	// Opens a data source using the service components
	HRESULT OpenWithServiceComponents(
		_In_ const CLSID& clsid,
		_In_opt_count_(nPropertySets) DBPROPSET* pPropSet = NULL,
		_In_ ULONG nPropertySets=1) throw()
	{
		CComPtr<IDataInitialize> spDataInit;

		HRESULT hr = CoCreateInstance(__uuidof(MSDAINITIALIZE), NULL, CLSCTX_INPROC_SERVER,
			__uuidof(IDataInitialize), (void**)&spDataInit);
		if (FAILED(hr))
			return hr;

		m_spInit.Release();
		hr = spDataInit->CreateDBInstance(clsid, NULL, CLSCTX_INPROC_SERVER, NULL,
			__uuidof(IDBInitialize), (IUnknown**)&m_spInit);
		if (FAILED(hr))
			return hr;

		// Initialize the provider
		return OpenWithProperties(pPropSet, nPropertySets);
	}
	// Opens a data source using the service components
	HRESULT OpenWithServiceComponents(
		_In_z_ LPCTSTR szProgID,
		_In_opt_count_(nPropertySets) DBPROPSET* pPropSet = NULL,
		_In_ ULONG nPropertySets=1) throw()
	{
		CLSID clsid;

		HRESULT hr = CLSIDFromProgID(CComBSTR(szProgID), &clsid);
		if (FAILED(hr))
			return hr;

		return OpenWithServiceComponents(clsid, pPropSet, nPropertySets);
	}
	// Bring up the "Organize Dialog" which allows the user to select a previously created data link
	// file (.UDL file). The selected file will be used to open the datbase.
	HRESULT OpenWithPromptFileName(
		_In_ HWND hWnd = GetActiveWindow(),
		_In_ DBPROMPTOPTIONS dwPromptOptions = DBPROMPTOPTIONS_NONE,
		_In_opt_z_ LPCOLESTR szInitialDirectory = NULL) throw()
	{
		CComPtr<IDBPromptInitialize> spDBInit;

		HRESULT hr = CoCreateInstance(__uuidof(DataLinks), NULL, CLSCTX_INPROC_SERVER,
			__uuidof(IDBPromptInitialize), (void**) &spDBInit);
		if (FAILED(hr))
		{
			return hr;
		}

		CComPtr<IDBProperties> spIDBProperties;
		LPOLESTR szSelected;

		hr = spDBInit->PromptFileName(hWnd, dwPromptOptions, szInitialDirectory, L"*.udl", &szSelected);

		if (hr == S_OK)
		{
			hr = OpenFromFileName(szSelected);
		}
		else if (hr == S_FALSE)
		{
			hr = MAKE_HRESULT(SEVERITY_ERROR, FACILITY_WIN32, ERROR_CANCELLED);  // The user clicked cancel
		}

		return hr;
	}
	// Open the datasource specified by the passed filename, typically a .UDL file
	HRESULT OpenFromFileName(_In_z_ LPCOLESTR szFileName) throw()
	{
		CComPtr<IDataInitialize> spDataInit;
		CComHeapPtr<OLECHAR>     spszInitString;

		HRESULT hr = CoCreateInstance(__uuidof(MSDAINITIALIZE), NULL, CLSCTX_INPROC_SERVER,
			__uuidof(IDataInitialize), (void**)&spDataInit);
		if (FAILED(hr))
			return hr;

		hr = spDataInit->LoadStringFromStorage(szFileName, &spszInitString);
		if (FAILED(hr))
			return hr;

		return OpenFromInitializationString(spszInitString);
	}
	// Open the datasource specified by the passed initialization string
	HRESULT OpenFromInitializationString(
		_In_z_ LPCOLESTR szInitializationString,
		_In_ bool fPromptForInfo = false) throw()
	{
		CComPtr<IDataInitialize> spDataInit;

		HRESULT hr = CoCreateInstance(__uuidof(MSDAINITIALIZE), NULL, CLSCTX_INPROC_SERVER,
			__uuidof(IDataInitialize), (void**)&spDataInit);
		if (FAILED(hr))
			return hr;

		hr = spDataInit->GetDataSource(NULL, CLSCTX_INPROC_SERVER, szInitializationString,
			__uuidof(IDBInitialize), (IUnknown**)&m_spInit);
		if (FAILED(hr))
			return hr;

		if( fPromptForInfo )
		{
			CComPtr<IDBProperties> spIDBProperties;
			hr = m_spInit->QueryInterface( &spIDBProperties );

			DBPROP rgProperties[1];
			DBPROPSET rgPropertySets[1];

			VariantInit(&rgProperties[0].vValue);
			rgProperties[0].dwOptions = DBPROPOPTIONS_REQUIRED;
			rgProperties[0].colid = DB_NULLID;
			rgProperties[0].dwPropertyID = DBPROP_INIT_PROMPT;
			rgProperties[0].vValue.vt = VT_I2;
			rgProperties[0].vValue.lVal = DBPROMPT_COMPLETEREQUIRED;

			rgPropertySets[0].rgProperties = rgProperties;
			rgPropertySets[0].cProperties = 1;
			rgPropertySets[0].guidPropertySet = DBPROPSET_DBINIT;

			hr = spIDBProperties->SetProperties( 1, rgPropertySets );
			if (FAILED(hr))
				return hr;
		}

		return m_spInit->Initialize();
	}
ATLPREFAST_SUPPRESS(6387)
	// Get the initialization string from the currently open data source. The returned string
	// must be CoTaskMemFree'd when finished with.
	HRESULT GetInitializationString(
		_Deref_out_z_ BSTR* pInitializationString,
		_In_ bool bIncludePassword=false) throw()
	{
		// If the datasource isn't open then we're not going to get an init string
		ATLASSUME(m_spInit != NULL);
		CComPtr<IDataInitialize> spDataInit;
		LPOLESTR    szInitString;

		HRESULT hr = CoCreateInstance(__uuidof(MSDAINITIALIZE), NULL, CLSCTX_INPROC_SERVER,
			__uuidof(IDataInitialize), (void**)&spDataInit);
		if (FAILED(hr))
			return hr;

		hr = spDataInit->GetInitializationString(m_spInit, bIncludePassword, &szInitString);

		if (SUCCEEDED(hr))
		{
			*pInitializationString = ::SysAllocString(szInitString);
			if (*pInitializationString == NULL && szInitString != NULL)
				hr = E_OUTOFMEMORY;
			CoTaskMemFree(szInitString);
		}

		return hr;
	}
ATLPREFAST_UNSUPPRESS()
	
	HRESULT GetProperties(
		_In_ ULONG ulPropIDSets,
		_In_count_(ulPropIDSets) const DBPROPIDSET* pPropIDSet,
		_Out_ ULONG* pulPropertySets,
		_Out_cap_x_(*pulPropertySets) DBPROPSET** ppPropsets) const throw()
	{
		CComPtr<IDBProperties> spProperties;

		// Check that we are connected
		ATLASSUME(m_spInit != NULL);

		HRESULT hr = m_spInit->QueryInterface(__uuidof(IDBProperties), (void**)&spProperties);
		if (FAILED(hr))
			return hr;

		hr = spProperties->GetProperties(ulPropIDSets, pPropIDSet, pulPropertySets,
				ppPropsets);
		return hr;
	}

	HRESULT GetProperty(
		_In_ const GUID& guid,
		_In_ DBPROPID propid,
		_Out_ VARIANT* pVariant) const throw()
	{
		ATLENSURE_RETURN(pVariant != NULL);
		CComPtr<IDBProperties> spProperties;

		// Check that we are connected
		ATLASSUME(m_spInit != NULL);

		HRESULT hr = m_spInit->QueryInterface(__uuidof(IDBProperties), (void**)&spProperties);
		if (FAILED(hr))
			return hr;

		CDBPropIDSet set(guid);
		if(!set.AddPropertyID(propid))
		{
			return E_FAIL;
		}
		CComHeapPtr<DBPROPSET> spPropSet;
		ULONG ulPropSet = 0;
		hr = spProperties->GetProperties(1, &set, &ulPropSet, &spPropSet);
		if (FAILED(hr))
			return hr;

		ATLASSERT(ulPropSet == 1);
		hr = VariantCopy(pVariant, &(spPropSet->rgProperties[0].vValue));
		VariantClear(&(spPropSet->rgProperties[0].vValue));
		CoTaskMemFree(spPropSet->rgProperties);

		return hr;
	}
	void Close() throw()
	{
		m_spInit.Release();
	}

// Implementation
	HRESULT OpenFromIDBProperties(_Inout_ IDBProperties* pIDBProperties) throw()
	{
		ATLENSURE_RETURN(pIDBProperties);

		CComPtr<IPersist> spPersist;
		CLSID   clsid;

		HRESULT hr = pIDBProperties->QueryInterface(__uuidof(IPersist), (void**)&spPersist);
		if (FAILED(hr))
			return hr;

		spPersist->GetClassID(&clsid);

		ULONG       ulPropSets=0;
		CDBPropSet* pPropSets=NULL;
		pIDBProperties->GetProperties(0, NULL, &ulPropSets, (DBPROPSET**)&pPropSets);

		hr = Open(clsid, &pPropSets[0], ulPropSets);

		ATLASSUME(pPropSets != NULL || ulPropSets == 0);

		for (ULONG i=0; i < ulPropSets; i++)
			(pPropSets+i)->~CDBPropSet();
		CoTaskMemFree(pPropSets);

		return hr;
	}

	HRESULT OpenWithNameUserPassword(
		_In_opt_z_ LPCTSTR pName,
		_In_opt_z_ LPCTSTR pUserName,
		_In_opt_z_ LPCTSTR pPassword,
		_In_ long nInitMode = 0) throw()
	{
		ATLASSUME(m_spInit != NULL);
		CComPtr<IDBProperties>  spProperties;

		HRESULT hr = m_spInit->QueryInterface(__uuidof(IDBProperties), (void**)&spProperties);
		if (FAILED(hr))
			return hr;

		// Set connection properties
		CDBPropSet propSet(DBPROPSET_DBINIT);

		// Add Datbase name, User name and Password
		if (pName != NULL)
		{
			if(!propSet.AddProperty(DBPROP_INIT_DATASOURCE, pName))
			{
				return E_FAIL;
			}
		}

		if (pUserName != NULL)
		{
			if(!propSet.AddProperty(DBPROP_AUTH_USERID, pUserName))
			{
				return E_FAIL;
			}
		}

		if (pPassword != NULL)
		{
			if(!propSet.AddProperty(DBPROP_AUTH_PASSWORD, pPassword))
			{
				return E_FAIL;
			}
		}

		if (nInitMode)
		{
			if(!propSet.AddProperty(DBPROP_INIT_MODE, nInitMode))
			{
				return E_FAIL;
			}
		}

		hr = spProperties->SetProperties(1, &propSet);
		if (FAILED(hr))
			return hr;

		// Initialize the provider
		return m_spInit->Initialize();
	}
	HRESULT OpenWithProperties(
		_Inout_opt_cap_(nPropertySets) DBPROPSET* pPropSet,
		_In_ ULONG nPropertySets=1) throw()
	{
		ATLASSUME(m_spInit != NULL);

		// Set the properties if there are some to set
		if (pPropSet != NULL)
		{
			CComPtr<IDBProperties>  spProperties;
			HRESULT                 hr;

			hr = m_spInit->QueryInterface(__uuidof(IDBProperties), (void**)&spProperties);
			if (FAILED(hr))
				return hr;

			hr = spProperties->SetProperties(nPropertySets, pPropSet);
			if (FAILED(hr))
				return hr;
		}

		// Initialize the provider
		return m_spInit->Initialize();
	}

	CComPtr<IDBInitialize>  m_spInit;
};


///////////////////////////////////////////////////////////////////////////
// class CSession

class CSession
{
public:
	~CSession()
	{
		Close();
	}

	// Create a session on the passed datasource
	HRESULT Open(
		_In_ const CDataSource& ds,
		_Inout_opt_cap_(ulPropSets) DBPROPSET *pPropSet = NULL,
		_In_ ULONG ulPropSets = 0) throw()
	{
		CComPtr<IDBCreateSession> spSession;

		// Check we have connected to the database
		ATLASSERT(ds.m_spInit != NULL);

		HRESULT hr = ds.m_spInit->QueryInterface(__uuidof(IDBCreateSession), (void**)&spSession);
		if (FAILED(hr))
			return hr;

		hr = spSession->CreateSession(NULL, __uuidof(IOpenRowset), (IUnknown**)&m_spOpenRowset);

		if( pPropSet != NULL && SUCCEEDED(hr) && m_spOpenRowset != NULL )
		{
			// If the user didn't specify the default parameter, use one
			if (pPropSet != NULL && ulPropSets == 0)
				ulPropSets = 1;

			CComPtr<ISessionProperties> spSessionProperties;
			hr = m_spOpenRowset->QueryInterface(__uuidof(ISessionProperties), (void**)&spSessionProperties);
			if(FAILED(hr))
				return hr;

			hr = spSessionProperties->SetProperties( ulPropSets, pPropSet );
		}
		return hr;
	}

	// Close the session
	void Close() throw()
	{
		m_spOpenRowset.Release();
	}
	// Start a transaction
	HRESULT StartTransaction(
		_In_ ISOLEVEL isoLevel = ISOLATIONLEVEL_READCOMMITTED,
		_In_ ULONG isoFlags = 0,
		_In_opt_ ITransactionOptions* pOtherOptions = NULL,
		_Out_opt_ ULONG* pulTransactionLevel = NULL) const throw()
	{
		ATLASSUME(m_spOpenRowset != NULL);
		CComPtr<ITransactionLocal> spTransactionLocal;
		HRESULT hr = m_spOpenRowset->QueryInterface(&spTransactionLocal);

		if (SUCCEEDED(hr))
			hr = spTransactionLocal->StartTransaction(isoLevel, isoFlags, pOtherOptions, pulTransactionLevel);

		return hr;
	}
	// Abort the current transaction
	HRESULT Abort(
		_In_opt_ BOID* pboidReason = NULL,
		_In_ BOOL bRetaining = FALSE,
		_In_ BOOL bAsync = FALSE) const throw()
	{
		ATLASSUME(m_spOpenRowset != NULL);
		CComPtr<ITransaction> spTransaction;
		HRESULT hr = m_spOpenRowset->QueryInterface(&spTransaction);

		if (SUCCEEDED(hr))
			hr = spTransaction->Abort(pboidReason, bRetaining, bAsync);

		return hr;
	}
	// Commit the current transaction
	HRESULT Commit(
		_In_ BOOL bRetaining = FALSE,
		_In_ DWORD grfTC = XACTTC_SYNC,
		_In_ DWORD grfRM = 0) const throw()
	{
		ATLASSUME(m_spOpenRowset != NULL);
		CComPtr<ITransaction> spTransaction;
		HRESULT hr = m_spOpenRowset->QueryInterface(&spTransaction);

		if (SUCCEEDED(hr))
			hr = spTransaction->Commit(bRetaining, grfTC, grfRM);

		return hr;
	}
	// Get information for the current transaction
	HRESULT GetTransactionInfo(_Out_ XACTTRANSINFO* pInfo) const throw()
	{
		ATLASSUME(m_spOpenRowset != NULL);
		CComPtr<ITransaction> spTransaction;
		HRESULT hr = m_spOpenRowset->QueryInterface(&spTransaction);

		if (SUCCEEDED(hr))
			hr = spTransaction->GetTransactionInfo(pInfo);

		return hr;
	}
// Implementation
	CComPtr<IOpenRowset> m_spOpenRowset;
};

///////////////////////////////////////////////////////////////////////////
// class CDataConnection

class CDataConnection
{
public:
	CDataConnection()
	{
	}

	CDataConnection(_In_ const CDataConnection &ds)
	{
		Copy(ds);
	}

	CDataConnection& Copy(_In_ const CDataConnection &ds) throw()
	{
		m_source.m_spInit = ds.m_source.m_spInit;
		m_session.m_spOpenRowset = ds.m_session.m_spOpenRowset;
		return *this;
	}

	HRESULT Open(_In_z_ LPCOLESTR szInitString) throw()
	{
		HRESULT hr = E_FAIL;
		hr = m_source.OpenFromInitializationString(szInitString);
		if (hr == S_OK)
		{
			hr = m_session.Open(m_source);
		}
		return hr;
	}

	HRESULT OpenNewSession(_In_ CSession &session) throw()
	{
		return session.Open(m_source);
	}

	operator const CSession&() throw()
	{
		return m_session;
	}

	operator const CSession*() throw()
	{
		return &m_session;
	}

	operator const CDataSource&() throw()
	{
		return m_source;
	}

	operator const CDataSource*() throw()
	{
		return &m_source;
	}

	CDataConnection& operator=(_In_ const CDataConnection &ds) throw()
	{
		return Copy(ds);
	}

	operator BOOL() throw()
	{
		return m_session.m_spOpenRowset != NULL ? TRUE : FALSE;
	}

	operator bool() throw()
	{
		return m_session.m_spOpenRowset != NULL ? true : false;
	}

	void CloseDataSource() throw()
	{
		m_session.Close();
		m_source.Close();
	}

	CSession m_session;
	CDataSource m_source;
};

///////////////////////////////////////////////////////////////////////////
// CTable

template <class TAccessor = CNoAccessor, template <typename T> class TRowset = CRowset>
class CTable :
	public CAccessorRowset<TAccessor, TRowset>
{
public:
	// Open a rowset on the passed name
	HRESULT Open(
		_In_ const CSession& session,
		_In_z_ LPCWSTR wszTableName,
		_Inout_opt_cap_(ulPropSets) DBPROPSET* pPropSet = NULL,
		_In_ ULONG ulPropSets = 0) throw()
	{
		DBID    idTable;

		idTable.eKind           = DBKIND_NAME;
		idTable.uName.pwszName  = (LPOLESTR)wszTableName;

		return Open(session, idTable, pPropSet, ulPropSets);
	}

	HRESULT Open(
		_In_ const CSession& session,
		_In_z_ LPCSTR szTableName,
		_Inout_opt_cap_(ulPropSets) DBPROPSET* pPropSet = NULL,
		_In_ ULONG ulPropSets = 0) throw()
	{
		return Open( session, CComBSTR(szTableName), pPropSet, ulPropSets );
	}

	// Open the a rowset on the passed DBID
	HRESULT Open(
		_In_ const CSession& session,
		_In_ DBID& dbid,
		_Inout_opt_cap_(ulPropSets) DBPROPSET* pPropSet = NULL,
		_In_ ULONG ulPropSets = 0) throw()
	{
		// Check the session is valid
		ATLENSURE_RETURN(session.m_spOpenRowset != NULL);

		// If the user didn't specify the default parameter, use one for
		// backward compatibility
		if (pPropSet != NULL && ulPropSets == 0)
			ulPropSets = 1;

		HRESULT hr = session.m_spOpenRowset->OpenRowset(NULL, &dbid, NULL, GetIID(),
			ulPropSets, pPropSet, (IUnknown**)GetInterfacePtr());
		if (SUCCEEDED(hr))
		{
			SetupOptionalRowsetInterfaces();

			// If we have output columns then bind
			if (_OutputColumnsClass::HasOutputColumns())
				hr = Bind();
		}

		return hr;
	}
};

#if (OLEDBVER < 0x0150)
#define DBGUID_DEFAULT DBGUID_DBSQL
#endif


///////////////////////////////////////////////////////////////////////////
// CCommandBase

class CCommandBase
{
public:
	CCommandBase()
	{
		m_hParameterAccessor = 0;
	}

	~CCommandBase()
	{
		ReleaseCommand();
	}
	// Create the command
	HRESULT CreateCommand(_In_ const CSession& session) throw()
	{
		// Before creating the command, release the old one if necessary.
		ReleaseCommand();

		// Check the session is valid
		ATLASSERT(session.m_spOpenRowset != NULL);

		CComPtr<IDBCreateCommand> spCreateCommand;

		HRESULT hr = session.m_spOpenRowset->QueryInterface(__uuidof(IDBCreateCommand), (void**)&spCreateCommand);
		if (FAILED(hr))
			return hr;

		return spCreateCommand->CreateCommand(NULL, __uuidof(ICommand), (IUnknown**)&m_spCommand);
	}
	// Prepare the command
	HRESULT Prepare(_In_ ULONG cExpectedRuns = 0) throw()
	{
		CComPtr<ICommandPrepare> spCommandPrepare;
		HRESULT hr = m_spCommand->QueryInterface(&spCommandPrepare);
		if (SUCCEEDED(hr))
			hr = spCommandPrepare->Prepare(cExpectedRuns);

		return hr;
	}
	// Unprepare the command
	HRESULT Unprepare() throw()
	{
		CComPtr<ICommandPrepare> spCommandPrepare;
		HRESULT hr = m_spCommand->QueryInterface(&spCommandPrepare);
		if (SUCCEEDED(hr))
			hr = spCommandPrepare->Unprepare();

		return hr;
	}
	// Create the command and set the command text
	HRESULT Create(
		_In_ const CSession& session,
		_In_z_ LPCWSTR wszCommand,
		_In_ REFGUID guidCommand = DBGUID_DEFAULT) throw()
	{
		HRESULT hr;

		hr = CreateCommand(session);
		if (SUCCEEDED(hr))
		{
			CComPtr<ICommandText> spCommandText;
			hr = m_spCommand->QueryInterface(&spCommandText);
			if (SUCCEEDED(hr))
				hr = spCommandText->SetCommandText(guidCommand, wszCommand);
		}
		return hr;
	}
	HRESULT Create(
		_In_ const CSession& session,
		_In_z_ LPCSTR szCommand,
		_In_ REFGUID guidCommand = DBGUID_DEFAULT) throw()
	{
		return Create( session, CComBSTR(szCommand), guidCommand );
	}

	// Release the command
	void ReleaseCommand() throw()
	{
		// Release the parameter accessor if necessary, before releasing the command
		if (m_hParameterAccessor != 0 && m_spCommand != NULL )
		{
			CComPtr<IAccessor> spAccessor;
			HRESULT hr = m_spCommand->QueryInterface(&spAccessor);
			if (SUCCEEDED(hr))
			{
				spAccessor->ReleaseAccessor(m_hParameterAccessor, NULL);
				m_hParameterAccessor = 0;
			}
		}
		m_spCommand.Release();
	}
	// Get the parameter information from the command
	HRESULT GetParameterInfo(
		_Out_ DB_UPARAMS* pParams,
		_Out_capcount_x_(*pParams) DBPARAMINFO** ppParamInfo,
		_Out_cap_x_(*pParams) _Deref_post_z_ OLECHAR** ppNamesBuffer) throw()
	{
		CComPtr<ICommandWithParameters> spCommandParameters;
		HRESULT hr = m_spCommand->QueryInterface(&spCommandParameters);
		if (SUCCEEDED(hr))
		{
			// Get the parameter information
			hr = spCommandParameters->GetParameterInfo(pParams, ppParamInfo,
					ppNamesBuffer);
		}
		return hr;
	}
	// Set the parameter information for the command
	HRESULT SetParameterInfo(
		_In_ DB_UPARAMS ulParams,
		_In_count_(ulParams) const DBORDINAL* pOrdinals,
		_In_opt_count_(ulParams) const DBPARAMBINDINFO* pParamInfo) throw()
	{
		CComPtr<ICommandWithParameters> spCommandParameters;
		HRESULT hr = m_spCommand->QueryInterface(&spCommandParameters);
		if (SUCCEEDED(hr))
		{
			// Set the parameter information
			hr = spCommandParameters->SetParameterInfo(ulParams, pOrdinals,
				pParamInfo);
		}
		return hr;
	}

	CComPtr<ICommand>   m_spCommand;
	HACCESSOR           m_hParameterAccessor;
};

// Used to turn on multiple result set support in CCommand
class CMultipleResults
{
public:
	bool UseMultipleResults() throw()
	{
		return true;
	}
	IMultipleResults** GetMultiplePtrAddress() throw()
	{
		return &m_spMultipleResults.p;
	}
	IMultipleResults* GetMultiplePtr() throw()
	{
		return m_spMultipleResults;
	}

	CComPtr<IMultipleResults> m_spMultipleResults;
};

// Used to turn off multiple result set support in CCommand
class CNoMultipleResults
{
public:
	bool UseMultipleResults() throw()
	{
		return false;
	}
	IMultipleResults** GetMultiplePtrAddress() throw()
	{
		return NULL;
	}
	IMultipleResults* GetMultiplePtr() throw()
	{
		return NULL;
	}
};


///////////////////////////////////////////////////////////////////////////
// CCommand

template <class TAccessor = CNoAccessor, template <typename T> class TRowset = CRowset,
			class TMultiple = CNoMultipleResults>
class CCommand :
	public CAccessorRowset<TAccessor, TRowset>,
	public CCommandBase,
	public TMultiple
{
public:
	// Create a command on the session and execute it
	HRESULT Open(
		_In_ const CSession& session,
		_In_opt_z_ LPCWSTR wszCommand,
		_Inout_opt_cap_(ulPropSets) DBPROPSET *pPropSet = NULL,
		_Out_opt_ DBROWCOUNT* pRowsAffected = NULL,
		_In_ REFGUID guidCommand = DBGUID_DEFAULT,
		_In_ bool bBind = true,
		_In_ ULONG ulPropSets = 0) throw()
	{
		HRESULT hr;

		if (wszCommand == NULL)
		{
			hr = _CommandClass::GetDefaultCommand(&wszCommand);
			if (FAILED(hr))
				return hr;
		}
		hr = Create(session, wszCommand, guidCommand);
		if (FAILED(hr))
			return hr;

		return Open(pPropSet, pRowsAffected, bBind, ulPropSets);
	}

	HRESULT Open(
		_In_ const CSession& session,
		_In_opt_z_ LPCSTR szCommand,
		_Inout_opt_cap_(ulPropSets) DBPROPSET *pPropSet = NULL,
		_Out_opt_ DBROWCOUNT* pRowsAffected = NULL,
		_In_ REFGUID guidCommand = DBGUID_DEFAULT,
		_In_ bool bBind = true,
		_In_ ULONG ulPropSets = 0) throw()
	{
		if( szCommand == NULL )
		{
			return Open( session, (LPCWSTR)NULL, pPropSet, pRowsAffected, guidCommand, bBind, ulPropSets );
		}
		else
		{
			return Open( session, CComBSTR(szCommand), pPropSet, pRowsAffected, guidCommand, bBind, ulPropSets );
		}
	}

	// this version of Open, takes an INT instead of a string pointer.
	// this is to resolve an ambiguity when calling
	// Open( session, NULL, ... ) or Open( session )
	HRESULT Open(
		_In_ const CSession& session,
		_In_ INT szCommand = NULL,
		_Inout_opt_cap_(ulPropSets) DBPROPSET *pPropSet = NULL,
		_Out_opt_ DBROWCOUNT* pRowsAffected = NULL,
		_In_ REFGUID guidCommand = DBGUID_DEFAULT,
		_In_ bool bBind = true,
		_In_ ULONG ulPropSets = 0) throw()
	{
		UNREFERENCED_PARAMETER(szCommand);
		ATLASSERT( szCommand == NULL );

		return Open( session, (LPCWSTR)NULL, pPropSet, pRowsAffected, guidCommand, bBind, ulPropSets );
	}

	// Used if you have previously created the command
	HRESULT Open(
		_Inout_opt_cap_(ulPropSets) DBPROPSET *pPropSet = NULL,
		_Out_opt_ DBROWCOUNT* pRowsAffected = NULL,
		_In_ bool bBind = true,
		_In_ ULONG ulPropSets = 0) throw()
	{
		HRESULT     hr;
		DBPARAMS    params;
		DBPARAMS    *pParams;

		// Bind the parameters if we have some
		if (_ParamClass::HasParameters())
		{
			// Bind the parameters in the accessor if they haven't already been bound
			hr = BindParameters(&m_hParameterAccessor, m_spCommand, &params.pData);
			if (FAILED(hr))
				return hr;

			// Setup the DBPARAMS structure
			params.cParamSets = 1;
			params.hAccessor = m_hParameterAccessor;
			pParams = &params;
		}
		else
			pParams = NULL;

		return ExecuteAndBind(pParams, pPropSet, pRowsAffected, bBind, ulPropSets);
	}
	// Get the next rowset when using multiple result sets
	HRESULT GetNextResult(
		_Out_ DBROWCOUNT* pulRowsAffected,
		_In_ bool bBind = true) throw()
	{
		// This function should only be called if CMultipleResults is being
		// used as the third template parameter
		ATLASSERT(GetMultiplePtrAddress() != NULL);

		// If user calls GetNextResult but the interface is not available
		// return E_FAIL.
		if (GetMultiplePtr() == NULL)
			return E_FAIL;

		// Close the existing rowset in preparation for opening the next one
		Close();

		HRESULT hr = GetMultiplePtr()->GetResult(NULL, 0, GetIID(),
			pulRowsAffected, (IUnknown**)GetInterfacePtr());
		if (FAILED(hr))
			return hr;

		if (bBind && GetInterface() != NULL)
			return Bind();
		else
			return hr;
	}

// Implementation
	HRESULT ExecuteAndBind(
		_In_opt_ DBPARAMS* pParams,
		_Inout_opt_cap_(ulPropSets) DBPROPSET* pPropSet = NULL,
		_Out_opt_ DBROWCOUNT* pRowsAffected = NULL,
		_In_ bool bBind = true,
		_In_ ULONG ulPropSets = 0) throw()
	{
		HRESULT hr = Execute((IUnknown**)GetInterfacePtr(), pParams, pPropSet,
							pRowsAffected, ulPropSets);
		if (FAILED(hr))
			return hr;

		// Only bind if we have been asked to and we have output columns
		if (bBind && _OutputColumnsClass::HasOutputColumns())
		{
			// for dynamic accessors we don't want to automatically call Bind if we got no rowset in return
			if( NoBindOnNullRowset() && GetInterface() == NULL )
				return hr;
			else
				return Bind();
		}
		else
			return hr;
	}

	HRESULT Execute(
		_Deref_out_ IRowset** ppRowset,
		_Inout_opt_cap_(ulPropSets) DBPARAMS* pParams,
		_In_ DBPROPSET *pPropSet,
		_Out_opt_ DBROWCOUNT* pRowsAffected,
		_In_ ULONG ulPropSets = 0) throw()
	{
		return Execute( (IUnknown**)ppRowset, pParams, pPropSet, pRowsAffected, ulPropSets );
	}

	HRESULT Execute(
		_Deref_out_ IUnknown** ppInterface,
		_In_opt_ DBPARAMS* pParams,
		_Inout_opt_cap_(ulPropSets) DBPROPSET *pPropSet,
		_Out_opt_ DBROWCOUNT* pRowsAffected,
		_In_ ULONG ulPropSets = 0) throw()
	{
		HRESULT hr;

		// Specify the properties if we have some
		if (pPropSet)
		{
			// For backward compatibility, if the default parameter is not
			// specified, then set it to one if a property set exists
			if (ulPropSets == 0)
				ulPropSets = 1;

			CComPtr<ICommandProperties> spCommandProperties;
			hr = m_spCommand->QueryInterface(&spCommandProperties);
			if (FAILED(hr))
				return hr;

			hr = spCommandProperties->SetProperties(ulPropSets, pPropSet);
			if (FAILED(hr))
				return hr;
		}

		// If the user want the rows affected then return it back, otherwise
		// just point to our local variable here.
		DBROWCOUNT nAffected, *pAffected;
		if (pRowsAffected)
			pAffected = pRowsAffected;
		else
			pAffected = &nAffected;

		if (UseMultipleResults())
		{
			hr = m_spCommand->Execute(NULL, __uuidof(IMultipleResults), pParams,
				pAffected, (IUnknown**)GetMultiplePtrAddress());

			if (SUCCEEDED(hr))
				hr = GetNextResult(pAffected, false);
			else
				// If we can't get IMultipleResults then just try to get IRowset
				hr = m_spCommand->Execute(NULL, GetIID(), pParams, pAffected,
					ppInterface);
		}
		else
		{
			hr = m_spCommand->Execute(NULL, GetIID(), pParams, pAffected,
				ppInterface);
		}
		if (SUCCEEDED(hr))
			SetupOptionalRowsetInterfaces();

		return hr;
	}
};


// This class can be used to implement the IRowsetNotify interface.
// It is supplied so that if you only want to implement one of the
// notifications you don't have to supply empty functions for the
// other methods.
class ATL_NO_VTABLE IRowsetNotifyImpl :
	public IRowsetNotify
{
public:
	STDMETHOD(OnFieldChange)(
			_In_opt_ IRowset* /* pRowset */,
			_In_ HROW /* hRow */,
			_In_ DBORDINAL /* cColumns */,
			_In_ DBORDINAL /* rgColumns*/ [] ,
			_In_ DBREASON /* eReason */,
			_In_ DBEVENTPHASE /* ePhase */,
			_In_ BOOL /* fCantDeny */)
	{
		ATLTRACENOTIMPL(_T("IRowsetNotifyImpl::OnFieldChange"));
	}
	STDMETHOD(OnRowChange)(
			_In_opt_ IRowset* /* pRowset */,
			_In_ DBCOUNTITEM /* cRows */,
			_In_ const HROW /* rghRows*/ [] ,
			_In_ DBREASON /* eReason */,
			_In_ DBEVENTPHASE /* ePhase */,
			_In_ BOOL /* fCantDeny */)
	{
		ATLTRACENOTIMPL(_T("IRowsetNotifyImpl::OnRowChange"));
	}
	STDMETHOD(OnRowsetChange)(
		_In_opt_ IRowset* /* pRowset */,
		_In_ DBREASON /* eReason */,
		_In_ DBEVENTPHASE /* ePhase */,
		_In_ BOOL /* fCantDeny*/)
	{
		ATLTRACENOTIMPL(_T("IRowsetNotifyImpl::OnRowsetChange"));
	}
};


}; //namespace ATL

#pragma pack(pop)
#pragma warning(pop)

#endif // __ATLDBCLI_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\include\atlcur.h ===
// This is a part of the Active Template Library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Active Template Library Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Active Template Library product.

#ifndef __ATLCUR_H__
#define __ATLCUR_H__

#pragma once

#include <atlbase.h>


#pragma pack(push,_ATL_PACKING)
namespace ATL
{

const LONGLONG CY_MIN_INTEGER	= -922337203685477;
const LONGLONG CY_MAX_INTEGER	= 922337203685477;
const SHORT CY_MIN_FRACTION		= -9999;
const SHORT CY_MAX_FRACTION		= 9999;
const SHORT CY_SCALE			= 10000;

class CComCurrency
{
public:

// constructors
	CComCurrency() throw()
	{
		 m_currency.int64 = 0;
	}
	CComCurrency(_In_ CURRENCY cySrc) throw()
	{
		m_currency.int64 = cySrc.int64;
	}
	CComCurrency(_In_ const CComCurrency& curSrc) throw()
	{
		*this = curSrc;
	}
	CComCurrency(
		_In_ LONGLONG nInteger,
		_In_ SHORT nFraction)
	{
		m_currency.int64 = 0;
		HRESULT hRes = SetInteger(nInteger);
		if (FAILED(hRes))
			AtlThrow(hRes);
		hRes = SetFraction(nFraction);
		if (FAILED(hRes))
			AtlThrow(hRes);
	}
	CComCurrency(_In_ BYTE bSrc)
	{
		*this = bSrc;
	}
	CComCurrency(_In_ SHORT sSrc)
	{
		*this = sSrc;
	}
	CComCurrency(_In_ LONG lSrc)
	{
		*this = lSrc;
	}
	CComCurrency(_In_ FLOAT fSrc)
	{
		*this = fSrc;
	}
	CComCurrency(_In_ DOUBLE dSrc)
	{
		*this = dSrc;
	}
	CComCurrency(_In_ CHAR cSrc)
	{
		*this = cSrc;
	}
	CComCurrency(_In_ USHORT usSrc)
	{
		*this = usSrc;
	}
	CComCurrency(_In_ ULONG ulSrc)
	{
		*this = ulSrc;
	}
	CComCurrency(_In_ DECIMAL dSrc)
	{
		*this = dSrc;
	}
	explicit CComCurrency(_In_z_ LPCSTR szSrc)
	{
		ATLASSERT(szSrc);
		if( szSrc == NULL )
			AtlThrow(E_INVALIDARG);

		USES_CONVERSION_EX;
		LPOLESTR p = A2OLE_EX(szSrc, _ATL_SAFE_ALLOCA_DEF_THRESHOLD);
		if( p == NULL )
			AtlThrow(E_OUTOFMEMORY);

		HRESULT hRes = VarCyFromStr(p, GetThreadLocale(), LOCALE_NOUSEROVERRIDE, &m_currency);
		if (FAILED(hRes))
			AtlThrow(hRes);
	}
	explicit CComCurrency(_In_z_ LPCWSTR szSrc)
	{
		ATLENSURE(szSrc);
		HRESULT hRes = VarCyFromStr(const_cast<LPWSTR>(szSrc), GetThreadLocale(), LOCALE_NOUSEROVERRIDE, &m_currency);
		if (FAILED(hRes))
			AtlThrow(hRes);
	}
	explicit CComCurrency(_In_ const VARIANT& varSrc)
	{
		VARIANT var;
		VariantInit(&var);
		HRESULT hRes = VariantChangeType(&var, const_cast<VARIANT*>(&varSrc), 0, VT_CY);
		if (FAILED(hRes))
			AtlThrow(hRes);
		m_currency.int64 = V_CY(&var).int64;
	}
	explicit CComCurrency(_In_ LPDISPATCH pDispSrc)
	{
		ATLENSURE(pDispSrc);
		HRESULT hRes = VarCyFromDisp(pDispSrc, GetThreadLocale(), &m_currency);
		if (FAILED(hRes))
			AtlThrow(hRes);
	}

// assignment operators
	const CComCurrency& operator=(_In_ CURRENCY cySrc) throw()
	{
		m_currency.int64 = cySrc.int64;
		return *this;
	}
	const CComCurrency& operator=(_In_ const CComCurrency& curSrc) throw()
	{
		m_currency.int64 = curSrc.m_currency.int64;
		return *this;
	}
	const CComCurrency& operator=(_In_ BYTE bSrc)
	{
		HRESULT hRes = VarCyFromUI1(bSrc, &m_currency);
		if (FAILED(hRes))
			AtlThrow(hRes);
		return *this;
	}
	const CComCurrency& operator=(_In_ SHORT sSrc)
	{
		HRESULT hRes = VarCyFromI2(sSrc, &m_currency);
		if (FAILED(hRes))
			AtlThrow(hRes);
		return *this;
	}
	const CComCurrency& operator=(_In_ LONG lSrc)
	{
		HRESULT hRes = VarCyFromI4(lSrc, &m_currency);
		if (FAILED(hRes))
			AtlThrow(hRes);
		return *this;
	}
	const CComCurrency& operator=(_In_ FLOAT fSrc)
	{
		HRESULT hRes = VarCyFromR4(fSrc, &m_currency);
		if (FAILED(hRes))
			AtlThrow(hRes);
		return *this;
	}
	const CComCurrency& operator=(_In_ DOUBLE dSrc)
	{
		HRESULT hRes = VarCyFromR8(dSrc, &m_currency);
		if (FAILED(hRes))
			AtlThrow(hRes);
		return *this;
	}
	const CComCurrency& operator=(_In_ CHAR cSrc)
	{
		HRESULT hRes = VarCyFromI1(cSrc, &m_currency);
		if (FAILED(hRes))
			AtlThrow(hRes);
		return *this;
	}
	const CComCurrency& operator=(_In_ USHORT usSrc)
	{
		HRESULT hRes = VarCyFromUI2(usSrc, &m_currency);
		if (FAILED(hRes))
			AtlThrow(hRes);
		return *this;
	}
	const CComCurrency& operator=(_In_ ULONG ulSrc)
	{
		HRESULT hRes = VarCyFromUI4(ulSrc, &m_currency);
		if (FAILED(hRes))
			AtlThrow(hRes);
		return *this;
	}
	const CComCurrency& operator=(_In_ DECIMAL dSrc)
	{
		HRESULT hRes = VarCyFromDec(&dSrc, &m_currency);
		if (FAILED(hRes))
			AtlThrow(hRes);
		return *this;
	}

// comparison operators
	bool operator==(_In_ const CComCurrency& cur) const
	{
		return (static_cast<HRESULT>(VARCMP_EQ) == VarCyCmp(m_currency, cur.m_currency));
	}
	bool operator!=(_In_ const CComCurrency& cur) const
	{
		return (static_cast<HRESULT>(VARCMP_EQ) != VarCyCmp(m_currency, cur.m_currency));
	}
	bool operator<(_In_ const CComCurrency& cur) const
	{
		return (static_cast<HRESULT>(VARCMP_LT) == VarCyCmp(m_currency, cur.m_currency));
	}
	bool operator>(_In_ const CComCurrency& cur) const
	{
		return (static_cast<HRESULT>(VARCMP_GT) == VarCyCmp(m_currency, cur.m_currency));
	}
	bool operator<=(_In_ const CComCurrency& cur) const
	{
		HRESULT hRes = VarCyCmp(m_currency, cur.m_currency);
		return (static_cast<HRESULT>(VARCMP_LT) == hRes || (HRESULT)VARCMP_EQ == hRes);
	}
	bool operator>=(_In_ const CComCurrency& cur) const
	{
		HRESULT hRes = VarCyCmp(m_currency, cur.m_currency);
		return (static_cast<HRESULT>(VARCMP_GT) == hRes || static_cast<HRESULT>(VARCMP_EQ) == hRes);
	}

// math operators
	CComCurrency operator+(_In_ const CComCurrency& cur) const
	{
		CURRENCY cy;
		HRESULT hRes = VarCyAdd(m_currency, cur.m_currency, &cy);
		if (FAILED(hRes))
			AtlThrow(hRes);
		return cy;
	}
	CComCurrency operator-(_In_ const CComCurrency& cur) const
	{
		CURRENCY cy;
		HRESULT hRes = VarCySub(m_currency, cur.m_currency, &cy);
		if (FAILED(hRes))
			AtlThrow(hRes);
		return cy;
	}
	const CComCurrency& operator+=(_In_ const CComCurrency& cur)
	{
		HRESULT hRes = VarCyAdd(m_currency, cur.m_currency, &m_currency);
		if (FAILED(hRes))
			AtlThrow(hRes);
		return *this;
	}
	const CComCurrency& operator-=(_In_ const CComCurrency& cur)
	{
		HRESULT hRes = VarCySub(m_currency, cur.m_currency, &m_currency);
		if (FAILED(hRes))
			AtlThrow(hRes);
		return *this;
	}
	CComCurrency operator*(_In_ const CComCurrency& cur) const
	{
		CURRENCY cy;
		HRESULT hRes = VarCyMul(m_currency, cur.m_currency, &cy);
		if (FAILED(hRes))
			AtlThrow(hRes);
		return cy;
	}
	const CComCurrency& operator*=(_In_ const CComCurrency& cur)
	{
		HRESULT hRes = VarCyMul(m_currency, cur.m_currency, &m_currency);
		if (FAILED(hRes))
			AtlThrow(hRes);
		return *this;
	}
	CComCurrency operator*(_In_ long nOperand) const
	{
		CURRENCY cy;
		HRESULT hRes = VarCyMulI4(m_currency, nOperand, &cy);
		if (FAILED(hRes))
			AtlThrow(hRes);
		return cy;
	}
	const CComCurrency& operator*=(_In_ long nOperand)
	{
		HRESULT hRes = VarCyMulI4(m_currency, nOperand, &m_currency);
		if (FAILED(hRes))
			AtlThrow(hRes);
		return *this;
	}
	CComCurrency operator-() const
	{
		CURRENCY cy;
		HRESULT hRes = VarCyNeg(m_currency, &cy);
		if (FAILED(hRes))
			AtlThrow(hRes);
		return cy;
	}
	CComCurrency operator/(_In_ long nOperand) const
	{
		ATLASSERT(nOperand);
		if( nOperand == 0 )
			AtlThrow(E_INVALIDARG);

		CURRENCY cy;
		cy.int64 = m_currency.int64 / nOperand;
		return cy;
	}
	const CComCurrency& operator/=(_In_ long nOperand)
	{
		ATLASSERT(nOperand);
		if( nOperand == 0 )
			AtlThrow(E_INVALIDARG);

		m_currency.int64 /= nOperand;
		return *this;
	}

// cast operators
	operator CURRENCY&() throw()
	{
		return m_currency;
	}
	operator const CURRENCY&() const throw()
	{
		return m_currency;
	}
	CURRENCY* GetCurrencyPtr() throw()
	{
		return &m_currency;
	}

// misc functions
	HRESULT Round(_In_ int nDecimals)
	{
		ATLASSERT(nDecimals >= 0 && nDecimals <= 4);
		if( nDecimals < 0 || nDecimals > 4 )
			return E_INVALIDARG;

		return VarCyRound(m_currency, nDecimals, &m_currency);
	}

	HRESULT SetInteger(_In_ LONGLONG nInteger)
	{
		// check if within range
		ATLASSERT(nInteger >= CY_MIN_INTEGER && nInteger <= CY_MAX_INTEGER);
		if( nInteger < CY_MIN_INTEGER || nInteger > CY_MAX_INTEGER )
			return E_INVALIDARG;

		if (m_currency.int64)
		{
			// signs must match
			if ((m_currency.int64 < 0 && nInteger > 0) ||
				(m_currency.int64 > 0 && nInteger < 0))
				return TYPE_E_TYPEMISMATCH;

			CURRENCY cyTemp;
			// get fractional part
			cyTemp.int64 = m_currency.int64 % CY_SCALE;
			// check if within range again
			if ((nInteger == CY_MAX_INTEGER && cyTemp.int64 > 5807) ||
				(nInteger == CY_MIN_INTEGER && cyTemp.int64 < -5808))
				return TYPE_E_OUTOFBOUNDS;
			// set to fractional part, wiping out integer part
			m_currency.int64 = cyTemp.int64;
		}
		// add new integer part scaled by CY_SCALE
		m_currency.int64 += nInteger * CY_SCALE;
		return S_OK;
	}

	// Based on 4 digits.  To set .2, pass 2000, to set .0002, pass a 2
	HRESULT SetFraction(_In_ SHORT nFraction)
	{
		// check if within range
		ATLASSERT(nFraction >= CY_MIN_FRACTION && nFraction <= CY_MAX_FRACTION);
		if( nFraction < CY_MIN_FRACTION || nFraction > CY_MAX_FRACTION )
			return E_INVALIDARG;

		if (m_currency.int64)
		{
			// signs must match
			if ((m_currency.int64 < 0 && nFraction > 0) ||
				(m_currency.int64 > 0 && nFraction < 0))
				return TYPE_E_TYPEMISMATCH;

			CURRENCY cyTemp;
			// get integer part, wiping out fractional part
			cyTemp.int64 = m_currency.int64 / CY_SCALE;
			// check if within range again
			if ((cyTemp.int64 == CY_MAX_INTEGER && nFraction > 5807) ||
				(cyTemp.int64 == CY_MIN_INTEGER && nFraction < -5808))
				return TYPE_E_OUTOFBOUNDS;
			// scale to CY_SCALE
			m_currency.int64 = cyTemp.int64 * CY_SCALE;
		}
		m_currency.int64 += nFraction;
		return S_OK;
	}

	LONGLONG GetInteger() const
	{
		if (m_currency.int64)
			return (m_currency.int64 / CY_SCALE);
		else
			return 0;
	}

	SHORT GetFraction() const
	{
		if (m_currency.int64)
			// get fractional part
			return static_cast<SHORT>(m_currency.int64 % CY_SCALE);
		else
			return 0;
	}

	CURRENCY m_currency;
};

}; //namespace ATL
#pragma pack(pop)
#endif //__ATLSAFE_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\include\atldef.h ===
// This is a part of the Active Template Library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Active Template Library Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Active Template Library product.

#ifndef __ATLDEF_H__
#define __ATLDEF_H__

#pragma once

#pragma warning(disable : 4619)	// there is no warning number

#include <atlrc.h>
#include <errno.h>
#include <sal.h>

// preprocessor string helpers
#ifndef _ATL_STRINGIZE
#define __ATL_STRINGIZE(_Value) #_Value
#define _ATL_STRINGIZE(_Value) __ATL_STRINGIZE(_Value)
#endif

#ifndef _ATL_APPEND
#define __ATL_APPEND(_Value1, _Value2) _Value1 ## _Value2
#define _ATL_APPEND(_Value1, _Value2) __ATL_APPEND(_Value1, _Value2)
#endif

#ifndef RC_INVOKED

#ifndef __cplusplus
	#error ATL requires C++ compilation (use a .cpp suffix)
#endif

#ifdef UNDER_CE
	#error This version of ATL is not currently supported for CE. Look for the CE specific version.
#endif

// If you are mixing compilation units that are built as
// native code with those that are built /clr, you must define
// the symbol '_ATL_MIXED'. _ATL_MIXED must be defined for all 
// compilation units in an executable or it must be defined for none of them.
#if !defined(_ATL_MIXED)
namespace Inconsistent_definition_of_symbol__ATL_MIXED
{
	struct _Please_define_it_the_same_throughout_your_project { };
}
#else
namespace Inconsistent_definition_of_symbol__ATL_MIXED
{
#ifdef _M_IX86
#pragma comment(linker, "/include:??3@YAXPAX@Z")
#else
#pragma comment(linker, "/include:??3@YAXPEAX@Z")
#endif
	struct _Please_define_it_the_same_throughout_your_project { virtual void one(){} };
}
#endif
namespace Inconsistent_definition_of_symbol__ATL_MIXED
{
	__declspec(selectany) _Please_define_it_the_same_throughout_your_project clash = _Please_define_it_the_same_throughout_your_project ();
}

#if !defined(_ATL_MIXED)
namespace Define_the_symbol__ATL_MIXED
{
#if defined(_M_CEE)
	struct Thank_you { };
#else
#ifdef _M_IX86
#pragma comment(linker, "/include:??3@YAXPAX@Z")
#else
#pragma comment(linker, "/include:??3@YAXPEAX@Z")
#endif
	struct Thank_you { virtual void one(){} };
#endif
	__declspec(selectany) Thank_you clash = Thank_you();
}
#endif

#if defined(_ATL_MIXED)
#define _ATL_NATIVE_INITIALIZATION
#endif

#if !defined(_M_CEE)
#define _ATL_NATIVE_INITIALIZATION
#endif

#ifdef _UNICODE
#ifndef UNICODE
#define UNICODE         // UNICODE is used by Windows headers
#endif
#endif

#ifdef UNICODE
#ifndef _UNICODE
#define _UNICODE        // _UNICODE is used by C-runtime/MFC headers
#endif
#endif

#ifdef _DEBUG
#ifndef DEBUG
#define DEBUG
#endif
#endif


//PREFAST support static_assert from version 16.00
#if defined(_PREFAST_) && (_MSC_VER < 1600)
#define ATLSTATIC_ASSERT(expr, comment)
#else 
#define ATLSTATIC_ASSERT(expr, comment)		static_assert(expr, comment)
#endif

#ifdef _WIN64
#define _ATL_SUPPORT_VT_I8  // Always support VT_I8 on Win64.
#endif

#if !defined(UNALIGNED)
#if defined(_M_IA64) || defined(_M_AMD64)
#define UNALIGNED __unaligned
#else
#define UNALIGNED
#endif
#endif

#if !defined(_countof)
#if !defined(__cplusplus)
#define _countof(_Array) (sizeof(_Array) / sizeof(_Array[0]))
#else
extern "C++"
{
template <typename _CountofType, size_t _SizeOfArray>
char (*__countof_helper(UNALIGNED _CountofType (&_Array)[_SizeOfArray]))[_SizeOfArray];
#define _countof(_Array) sizeof(*__countof_helper(_Array))
}
#endif
#endif

#ifndef AtlThrow
#ifndef _ATL_CUSTOM_THROW
#define AtlThrow ATL::AtlThrowImpl
#endif
#endif // AtlThrow

#ifndef ATLASSERT
#define ATLASSERT(expr) _ASSERTE(expr)
#endif // ATLASSERT

/* 
Why does ATLASSUME exist?

ATL 8 has two existing validation models

ATLASSERT/ATLVERIFY - These are used to make sure a debug build reports a problem with the expression/invariant
ATLENSURE - Debug is the same as ATLVERIFY, retail throws a C++ exception

We added ATLENSURE because there were too many unreported error paths in ATL and we wanted to bail out of more
error conditions rather than just trying to continue in retail.

There might be a case for changing 'lots' of ATLASSERT to ATLENSURE, but we chose an incremental approach and only
changed over where we saw a problem with code reported from a customer or test case. This reduces code churn in our
code for this version.

In general, our approach is to try to make sure that when something goes wrong
- the client does not continue to run, because we report an error condition
- debug builds see an assertion about the problem

Sometimes we have code like

HRESULT ComMethod(void)
{
	ATLASSUME(m_pFoo);
	return m_pFoo->Method();
}

We could add
	if(!m_pFoo) return E_POINTER;

But this is very unlikely to help, since it removes the ability of the developer to debug this problem if it's seen in a retail
build of the application. 

We could try something more severe

	if(!m_pFoo) terminate(); // or your favourite shutdown function

This would ensure good reporting (because VC8 terminate generates a Windows Error Report and crash dump), but hardly seems a big win 
over the previous crash.

ATLENSURE might seem slightly better. It is debuggable and consistent with ATL in general. In fact, many parts of ATL do just this. 
But in this specific context, it doesn't look like a great choice. COM methods should not in general be emitting native C++ exceptions 
as an error reporting strategy. 

So we find ourselves in a quandry. For these kinds of methods, the traditional code (ATLASSERT followed by a crash), seems be the most 
debuggable thing to do in this situation. At least for VS8, we have decided to stick with this shape.

---

Now consider the impact of cl /analyze. We want cl /analyze to not warn about our potential dereferences when they refer to member variables
whose state was previously validated by another method. But we do want to see the impact of function contracts on the parameters of the
function. 

So we've done a broad replace of all the member-related ATLASSERT to ATLASSUME. 

*/

#ifndef ATLASSUME
#define ATLASSUME(expr) do { ATLASSERT(expr); __analysis_assume(!!(expr)); } while(0)
#endif // ATLASSUME

#ifndef ATLVERIFY
#ifdef _DEBUG
#define ATLVERIFY(expr) ATLASSERT(expr)
#else
#define ATLVERIFY(expr) (expr)
#endif // DEBUG
#endif // ATLVERIFY

#ifndef ATLENSURE_THROW
#define ATLENSURE_THROW(expr, hr)          \
do {                                       \
	int __atl_condVal=!!(expr);            \
	ATLASSUME(__atl_condVal);              \
	if(!(__atl_condVal)) AtlThrow(hr);     \
} while (0)
#endif // ATLENSURE_THROW

#ifndef ATLENSURE
#define ATLENSURE(expr) ATLENSURE_THROW(expr, E_FAIL)
#endif // ATLENSURE

#ifndef ATLENSURE_SUCCEEDED
#define ATLENSURE_SUCCEEDED(hr) ATLENSURE_THROW(SUCCEEDED(hr), hr)
#endif // ATLENSURE_SUCCEEDED

/* Used inside COM methods that do not want to throw */
#ifndef ATLENSURE_RETURN_VAL
#define ATLENSURE_RETURN_VAL(expr, val)        \
do {                                           \
	int __atl_condVal=!!(expr);                \
	ATLASSERT(__atl_condVal);                  \
	if(!(__atl_condVal)) return val;           \
} while (0) 
#endif // ATLENSURE_RETURN_VAL

/* Used inside COM methods that do not want to throw */
#ifndef ATLENSURE_RETURN
#define ATLENSURE_RETURN(expr) ATLENSURE_RETURN_HR(expr, E_FAIL)
#endif // ATLENSURE_RETURN

/* Naming is slightly off in these macros
ATLENSURE_RETURN is an HRESULT return of E_FAIL
ATLENSURE_RETURN_VAL is any return value (function can pick)
ATLENSURE_RETURN_HR is HRESULT-specific, though currently the same as _VAL
*/
#ifndef ATLENSURE_RETURN_HR
#define ATLENSURE_RETURN_HR(expr, hr) ATLENSURE_RETURN_VAL(expr, hr)
#endif // ATLENSURE_RETURN_HR

#ifndef ATL_CRT_ERRORCHECK
#define ATL_CRT_ERRORCHECK(expr) AtlCrtErrorCheck(expr)
#endif // ATL_CRT_ERRORCHECK

#ifndef ATL_CRT_ERRORCHECK_SPRINTF
#define ATL_CRT_ERRORCHECK_SPRINTF(expr) \
do { \
	errno_t _saveErrno = errno; \
	errno = 0; \
	(expr); \
	if(0 != errno) \
	{ \
		AtlCrtErrorCheck(errno); \
	} \
	else \
	{ \
		errno = _saveErrno; \
	} \
} while (0)
#endif // ATL_CRT_ERRORCHECK_SPRINTF

///////////////////////////////////////////////////////////////////////////////
// __declspec(novtable) is used on a class declaration to prevent the vtable
// pointer from being initialized in the constructor and destructor for the
// class.  This has many benefits because the linker can now eliminate the
// vtable and all the functions pointed to by the vtable.  Also, the actual
// constructor and destructor code are now smaller.
///////////////////////////////////////////////////////////////////////////////
// This should only be used on a class that is not directly createable but is
// rather only used as a base class.  Additionally, the constructor and
// destructor (if provided by the user) should not call anything that may cause
// a virtual function call to occur back on the object.
///////////////////////////////////////////////////////////////////////////////
// By default, the wizards will generate new ATL object classes with this
// attribute (through the ATL_NO_VTABLE macro).  This is normally safe as long
// the restriction mentioned above is followed.  It is always safe to remove
// this macro from your class, so if in doubt, remove it.
///////////////////////////////////////////////////////////////////////////////

#ifdef _ATL_DISABLE_NO_VTABLE
#define ATL_NO_VTABLE
#else
#define ATL_NO_VTABLE __declspec(novtable)
#endif

#ifdef _ATL_DISABLE_NOTHROW
#define ATL_NOTHROW
#else
#define ATL_NOTHROW __declspec(nothrow)
#endif

#ifdef _ATL_DISABLE_FORCEINLINE
#define ATL_FORCEINLINE
#else
#define ATL_FORCEINLINE __forceinline
#endif

#ifdef _ATL_DISABLE_NOINLINE
#define ATL_NOINLINE
#else
#define ATL_NOINLINE __declspec( noinline )
#endif

#ifdef _ATL_DISABLE_DEPRECATED
#define ATL_DEPRECATED(_Message)
#else
#define ATL_DEPRECATED(_Message) __declspec( deprecated(_Message) )
#endif

// If ATLXX.DLL is being used then _ATL_STATIC_REGISTRY doesn't really make sense
#ifdef _ATL_DLL
#undef _ATL_STATIC_REGISTRY
#else
// If not linking to ATLXX.DLL, use the static registrar and not building atl.dll
#ifndef _ATL_DLL_IMPL
#ifndef _ATL_STATIC_REGISTRY
#define _ATL_STATIC_REGISTRY
#endif
#endif
#endif

#ifdef _ATL_DEBUG_REFCOUNT
#ifndef _ATL_DEBUG_INTERFACES
#define _ATL_DEBUG_INTERFACES
#endif
#endif

#ifdef _DEBUG
#ifndef _ATL_DEBUG
#define _ATL_DEBUG
#endif // _ATL_DEBUG
#endif // _DEBUG

#ifdef _ATL_DEBUG_INTERFACES
#ifndef _ATL_DEBUG
#define _ATL_DEBUG
#endif // _ATL_DEBUG
#endif // _ATL_DEBUG_INTERFACES

#ifndef _ATL_HEAPFLAGS
#ifdef _MALLOC_ZEROINIT
#define _ATL_HEAPFLAGS HEAP_ZERO_MEMORY
#else
#define _ATL_HEAPFLAGS 0
#endif
#endif

#ifndef _ATL_PACKING
#define _ATL_PACKING 8
#endif

#if defined(_ATL_DLL)
	#define ATLAPI extern "C" HRESULT __declspec(dllimport) __stdcall
	#define ATLAPI_(x) extern "C" __declspec(dllimport) x __stdcall
	#define ATLINLINE
	#define ATLAPIINL extern "C" inline HRESULT __stdcall
	#define ATLAPIINL_(x) extern "C" inline x __stdcall
#elif defined(_ATL_DLL_IMPL)
	#define ATLAPI extern "C" inline HRESULT __stdcall
	#define ATLAPI_(x) extern "C" inline x __stdcall
	#define ATLAPIINL ATLAPI
	#define ATLAPIINL_(x) ATLAPI_(x)
	#define ATLINLINE
#else
	#define ATLAPI __declspec(nothrow) HRESULT __stdcall
	#define ATLAPI_(x) __declspec(nothrow) x __stdcall
	#define ATLAPIINL ATLAPI
	#define ATLAPIINL_(x) ATLAPI_(x)
	#define ATLINLINE inline
#endif

#ifdef _ATL_NO_EXCEPTIONS
	#ifdef _AFX
	#error MFC projects cannot define _ATL_NO_EXCEPTIONS
	#endif
#else
	#ifndef _CPPUNWIND
	#define _ATL_NO_EXCEPTIONS
	#endif
#endif

#ifdef _CPPUNWIND

#ifndef ATLTRYALLOC

#ifdef _AFX
#define ATLTRYALLOC(x) try{x;} catch(CException* e){e->Delete();}
#else
/* prefast noise VSW 489981 */
#define ATLTRYALLOC(x) __pragma(warning(push)) __pragma(warning(disable: 4571)) try{x;} catch(...) {} __pragma(warning(pop))
#endif	//__AFX

#endif	//ATLTRYALLOC

// If you define _ATLTRY before including this file, then
// you should define _ATLCATCH and _ATLRETHROW as well.
#ifndef _ATLTRY
#define _ATLTRY try
#ifdef _AFX
#define _ATLCATCH( e ) catch( CException* e )
#else
#define _ATLCATCH( e ) catch( CAtlException e )
#endif

#define _ATLCATCHALL() __pragma(warning(push)) __pragma(warning(disable: 4571)) catch( ... ) __pragma(warning(pop))

#ifdef _AFX
#define _ATLDELETEEXCEPTION(e) e->Delete();
#else
#define _ATLDELETEEXCEPTION(e) e;
#endif

#define _ATLRETHROW throw
#endif	// _ATLTRY

/* 
COM functions should not throw. Which means we should protect their callers from C++ exceptions leaking out. These macros
can help with that, though they have not yet been applied to the whole of ATL, which uses a variety of patterns to achieve
this end
*/
 
#ifndef _ATL_COM_BEGIN 
#define _ATL_COM_BEGIN \
	HRESULT __hrAtlComMethod=S_OK; \
	try \
	{
#endif

#ifdef _AFX
/* Nice to do something more complex here in future to translate an MFC exception to a better HR */
#define _AFX_COM_END_PART \
	catch(CException *e) \
	{ \
		if(e) \
		{ \
			e->Delete(); \
		} \
		__hrAtlComMethod=E_FAIL; \
	}
#else
#define _AFX_COM_END_PART \
	catch(CAtlException e) \
	{ \
		__hrAtlComMethod=e.m_hr; \
	}
#endif

#ifndef _ATL_COM_END 
#define _ATL_COM_END \
	_AFX_COM_END_PART \
	catch(...) \
	{ \
		__hrAtlComMethod=E_FAIL; \
	} \
	return hr; 
#endif



#else //_CPPUNWIND

#ifndef ATLTRYALLOC
#define ATLTRYALLOC(x) x;
#endif	//ATLTRYALLOC

// if _ATLTRY is defined before including this file then 
// _ATLCATCH and _ATLRETHROW should be defined as well.
#ifndef _ATLTRY
#define _ATLTRY
#define _ATLCATCH( e ) __pragma(warning(push)) __pragma(warning(disable: 4127)) if( false ) __pragma(warning(pop))
#define _ATLCATCHALL() __pragma(warning(push)) __pragma(warning(disable: 4127)) if( false ) __pragma(warning(pop))
#define _ATLDELETEEXCEPTION(e)
#define _ATLRETHROW
#endif	// _ATLTRY

#endif	//_CPPUNWIND

#ifndef ATLTRY
#define ATLTRY(x) ATLTRYALLOC(x)
#endif	//ATLTRY

#define offsetofclass(base, derived) ((DWORD_PTR)(static_cast<base*>((derived*)_ATL_PACKING))-_ATL_PACKING)

/////////////////////////////////////////////////////////////////////////////
// Master version numbers

#define _ATL     1      // Active Template Library
#define _ATL_VER 0x0A00 // Active Template Library version 10.00

#ifndef _ATL_FILENAME_VER
#define _ATL_FILENAME_VER "100"
#endif

#ifndef _ATL_FILENAME_VER_NUM
#define _ATL_FILENAME_VER_NUM 100
#endif

#ifndef _ATL_VER_RBLD
#define _ATL_VER_RBLD "10.00"
#endif

/////////////////////////////////////////////////////////////////////////////
// Threading

#ifndef _ATL_SINGLE_THREADED
#ifndef _ATL_APARTMENT_THREADED
#ifndef _ATL_FREE_THREADED
#define _ATL_FREE_THREADED
#endif
#endif
#endif

// UUIDOF
#ifndef _ATL_NO_UUIDOF
#define _ATL_IIDOF(x) __uuidof(x)
#else
#define _ATL_IIDOF(x) IID_##x
#endif

// Lean and mean
#ifndef ATL_NO_LEAN_AND_MEAN
#ifndef WIN32_LEAN_AND_MEAN
#define WIN32_LEAN_AND_MEAN
#endif
#ifndef NOMCX
#define NOMCX
#endif
#endif	// ATL_NO_LEAN_AND_MEAN

#ifdef NOSERVICE
#ifndef _ATL_NO_SERVICE
#define _ATL_NO_SERVICE
#endif	// _ATL_NO_SERVICE
#else
#ifdef _ATL_NO_SERVICE
#ifndef NOSERVICE
#define NOSERVICE
#endif	// NOSERVICE
#endif	// _ATL_NO_SERVICE
#endif	// NOSERVICE

#include <malloc.h>
#ifdef _DEBUG
#include <stdlib.h>
#endif
#ifndef _ATL_NO_DEBUG_CRT
// Warning: if you define the above symbol, you will have
// to provide your own definition of the ATLASSERT(x) macro
// in order to compile ATL
	#include <crtdbg.h>
#endif

#endif // RC_INVOKED

// Note : we can not use macros to generate the window class names because it
//        will require nested macros. rc.exe does not handle nested macros.
// #define ATLAXWIN_CLASS	_ATL_STRINGIZE(_ATL_APPEND(AtlAxWin, _ATL_FILENAME_VER_NUM))
// #define ATLAXWINLIC_CLASS	_ATL_STRINGIZE(_ATL_APPEND(AtlAxWinLic, _ATL_FILENAME_VER_NUM))

#define ATLAXWIN_CLASS "AtlAxWin100"
#define ATLAXWINLIC_CLASS "AtlAxWinLic100"

#if defined(_ATL_SECURE_NO_DEPRECATE) && !defined(_ATL_SECURE_NO_WARNINGS)
#define _ATL_SECURE_NO_WARNINGS
#endif

// _ATL_INSECURE_DEPRECATE define
#ifndef _ATL_INSECURE_DEPRECATE
#ifdef _ATL_SECURE_NO_WARNINGS
#define _ATL_INSECURE_DEPRECATE(_Message)
#else
#define _ATL_INSECURE_DEPRECATE(_Message) __declspec(deprecated(_Message))
#endif // _ATL_SECURE_NO_WARNINGS
#endif // _ATL_INSECURE_DEPRECATE

/*
This is called when something really bad happens -- so bad
that we consider it dangerous to even throw an exception
*/
#ifndef _ATL_FATAL_SHUTDOWN
#define _ATL_FATAL_SHUTDOWN do { ::TerminateProcess(::GetCurrentProcess(), 0); } while(0)
#endif

//ATL/MFC code should use standard pointer to member standard syntax &MyClass::MyMethod, instead
//of the legacy non-standard syntax - MyMethod.
#ifdef _ATL_ENABLE_PTM_WARNING
#define PTM_WARNING_DISABLE
#define PTM_WARNING_RESTORE
#else
#define PTM_WARNING_DISABLE \
	__pragma(warning( push )) \
	__pragma(warning( disable : 4867 ))
#define PTM_WARNING_RESTORE \
	__pragma(warning( pop ))
#endif //_ATL_ENABLE_PTM_WARNING

/* we have to define our own versions of MAKEINTRESOURCE and IS_INTRESOURCE to 
 * fix warning 6268. At least until those macros are not cleanend in PSDK.
   Same comes true for those definitions of constants which use the above macros
*/
#define ATL_MAKEINTRESOURCEA(i) ((LPSTR)((ULONG_PTR)((WORD)(i))))
#define ATL_MAKEINTRESOURCEW(i) ((LPWSTR)((ULONG_PTR)((WORD)(i))))
#ifdef UNICODE
#define ATL_MAKEINTRESOURCE  ATL_MAKEINTRESOURCEW
#else
#define ATL_MAKEINTRESOURCE  ATL_MAKEINTRESOURCEA
#endif // !UNICODE
#define ATL_IS_INTRESOURCE(_r) ((((ULONG_PTR)(_r)) >> 16) == 0)

/*
 * Predefined Resource Types
 */
#define ATL_RT_CURSOR           ATL_MAKEINTRESOURCE(1)
#define ATL_RT_BITMAP           ATL_MAKEINTRESOURCE(2)
#define ATL_RT_ICON             ATL_MAKEINTRESOURCE(3)
#define ATL_RT_MENU             ATL_MAKEINTRESOURCE(4)
#define ATL_RT_DIALOG           ATL_MAKEINTRESOURCE(5)
#define ATL_RT_STRING           ATL_MAKEINTRESOURCE(6)
#define ATL_RT_FONTDIR          ATL_MAKEINTRESOURCE(7)
#define ATL_RT_FONT             ATL_MAKEINTRESOURCE(8)
#define ATL_RT_ACCELERATOR      ATL_MAKEINTRESOURCE(9)
#define ATL_RT_RCDATA           ATL_MAKEINTRESOURCE(10)
#define ATL_RT_MESSAGETABLE     ATL_MAKEINTRESOURCE(11)

#define ATL_DIFFERENCE     11
#define ATL_RT_GROUP_CURSOR ATL_MAKEINTRESOURCE((ULONG_PTR)ATL_RT_CURSOR + ATL_DIFFERENCE)
#define ATL_RT_GROUP_ICON   ATL_MAKEINTRESOURCE((ULONG_PTR)ATL_RT_ICON + ATL_DIFFERENCE)
#define ATL_RT_VERSION      ATL_MAKEINTRESOURCE(16)
#define ATL_RT_DLGINCLUDE   ATL_MAKEINTRESOURCE(17)
#define ATL_RT_PLUGPLAY     ATL_MAKEINTRESOURCE(19)
#define ATL_RT_VXD          ATL_MAKEINTRESOURCE(20)
#define ATL_RT_ANICURSOR    ATL_MAKEINTRESOURCE(21)
#define ATL_RT_ANIICON      ATL_MAKEINTRESOURCE(22)
#define ATL_RT_HTML         ATL_MAKEINTRESOURCE(23)

/* sal.h stuff that is not in the current LKG */
#ifndef __out_ecount_part_z
#define __out_ecount_part_z(size,length)                        __out_ecount_part(size,length) __post __nullterminated
#endif

#ifndef __out_ecount_part_z_opt
#define __out_ecount_part_z_opt(size,length)                    __out_ecount_part_opt(size,length) __post __nullterminated
#endif

#ifndef __deref_opt_out_z
#define __deref_opt_out_z                                       __deref_opt_out __post __deref __nullterminated
#endif

#ifndef __out_bcount_part_z
#define __out_bcount_part_z(size,length)                        __out_bcount_part(size,length) __post __nullterminated
#endif

#define ATLPREFAST_SUPPRESS(x) __pragma(warning(push)) __pragma(warning(disable: x))
#define ATLPREFAST_UNSUPPRESS() __pragma(warning(pop))
	
#ifndef _FormatMessage_format_string_
#define _FormatMessage_format_string_
#endif
	
/* 
	Helper functions for SAL annotation
*/
namespace ATL {

template < typename T >
_Ret_opt_bytecap_(dwLen) inline __declspec(noalias) T* SAL_Assume_bytecap_for_opt_(
	_Out_opt_cap_c_(0) T* buf, 
	_In_ size_t dwLen)
{
	(void)(dwLen);
	return buf;
}

template < typename T >
_Ret_z_ inline __declspec(noalias) T* SAL_Assume_notnull_for_opt_z_(_In_opt_z_ T* buf)
{
	ATLASSUME(buf!=0);
	return buf;
}		

} // namespace ATL

#endif // __ATLDEF_H__

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\include\atldebugapi.h ===
// This is a part of the Active Template Library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Active Template Library Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Active Template Library product.


#ifndef __ATLDEBUGAPI_H__
#define __ATLDEBUGAPI_H__

#pragma once

#ifdef __cplusplus

#pragma pack(push,_ATL_PACKING)
namespace ATL
{
extern "C" {
#endif
#define ATL_TRACE_MAX_NAME_SIZE 64

typedef enum ATLTRACESTATUS
{
	ATLTRACESTATUS_INHERIT,
	ATLTRACESTATUS_ENABLED,
	ATLTRACESTATUS_DISABLED
} ATLTRACESTATUS;

DWORD_PTR __stdcall AtlTraceOpenProcess(_In_ DWORD idProcess);
void __stdcall AtlTraceCloseProcess(_In_ DWORD_PTR dwProcess);
void __stdcall AtlTraceSnapshotProcess(_In_ DWORD_PTR dwProcess);

DWORD_PTR __stdcall AtlTraceRegister(
	_In_ HINSTANCE hInst,
	_In_opt_ int (__cdecl *fnCrtDbgReport)(
				_In_ int,
				_In_z_ const char *,
				_In_ int,
				_In_z_ const char *,
				_In_z_ const char *,...)
	);

BOOL __stdcall AtlTraceUnregister(_In_ DWORD_PTR dwModule);

DWORD_PTR __stdcall AtlTraceRegisterCategoryA(
	_In_ DWORD_PTR dwModule,
	_In_z_count_c_(ATL_TRACE_MAX_NAME_SIZE) const CHAR szCategoryName[ATL_TRACE_MAX_NAME_SIZE]);

DWORD_PTR __stdcall AtlTraceRegisterCategoryU(
	_In_ DWORD_PTR dwModule,
	_In_z_count_c_(ATL_TRACE_MAX_NAME_SIZE) const WCHAR szCategoryName[ATL_TRACE_MAX_NAME_SIZE]);

BOOL __stdcall AtlTraceModifyProcess(
	_In_ DWORD_PTR dwProcess,
	_In_ UINT nLevel,
	_In_ BOOL bEnabled,
	_In_ BOOL bFuncAndCategoryNames,
	_In_ BOOL bFileNameAndLineNo);

BOOL __stdcall AtlTraceModifyModule(
	_In_ DWORD_PTR dwProcess,
	_In_ DWORD_PTR dwModule,
	_In_ UINT nLevel,
	_In_ ATLTRACESTATUS eStatus);

BOOL __stdcall AtlTraceModifyCategory(
	_In_ DWORD_PTR dwProcess,
	_In_ DWORD_PTR dwCategory,
	_In_ UINT nLevel,
	_In_ ATLTRACESTATUS eStatus);

BOOL __stdcall AtlTraceGetProcess(
	_In_ DWORD_PTR dwProcess,
	_Out_opt_ UINT *pnLevel,
	_Out_opt_ BOOL *pbEnabled,
	_Out_opt_ BOOL *pbFuncAndCategoryNames,
	_Out_opt_ BOOL *pbFileNameAndLineNo);

BOOL __stdcall AtlTraceGetModule(
	_In_ DWORD_PTR dwProcess,
	_In_ DWORD_PTR dwModule,
	_Out_opt_ UINT *pnLevel,
	_Out_opt_ ATLTRACESTATUS *pStatus);

BOOL __stdcall AtlTraceGetCategory(
	_In_ DWORD_PTR dwProcess,
	_In_ DWORD_PTR dwCategory,
	_Out_opt_ UINT *pnLevel,
	_Out_opt_ ATLTRACESTATUS *pStatus);

_ATL_INSECURE_DEPRECATE("AtlTraceGetUpdateEventNameA is unsafe. Instead use AtlTraceGetUpdateEventNameA_s")
void __stdcall AtlTraceGetUpdateEventNameA(_Inout_z_ CHAR *pszEventName);

_ATL_INSECURE_DEPRECATE("AtlTraceGetUpdateEventNameU is unsafe. Instead use AtlTraceGetUpdateEventNameU_s")
void __stdcall AtlTraceGetUpdateEventNameU(_Inout_z_ WCHAR *pszEventName);

void __stdcall AtlTraceGetUpdateEventNameA_s(
	_Out_z_cap_(cchEventName) CHAR *pszEventName,
	_In_ size_t cchEventName);

void __stdcall AtlTraceGetUpdateEventNameU_s(
	_Out_z_cap_(cchEventName) WCHAR *pszEventName,
	_In_ size_t cchEventName);

void __cdecl AtlTraceVA(
	_In_ DWORD_PTR dwModule,
	_In_opt_z_ const char *pszFileName,
	_In_ int nLineNo,
	_In_ DWORD_PTR dwCategory,
	_In_ UINT nLevel,
	_In_z_ _Printf_format_string_ const CHAR *pszFormat, 
	_In_ va_list ptr);

void __cdecl AtlTraceVU(
	_In_ DWORD_PTR dwModule,
	_In_opt_z_ const char *pszFileName,
	_In_ int nLineNo,
	_In_ DWORD_PTR dwCategory,
	_In_ UINT nLevel,
	_In_z_ _Printf_format_string_ const WCHAR *pszFormat, 
	_In_ va_list ptr);

BOOL __stdcall AtlTraceLoadSettingsA(
	_In_opt_z_ const CHAR *pszFileName,
	_In_ DWORD_PTR dwProcess = 0);

BOOL __stdcall AtlTraceLoadSettingsU(
	_In_opt_z_ const WCHAR *pszFileName,
	_In_ DWORD_PTR dwProcess = 0);

BOOL __stdcall AtlTraceSaveSettingsA(
	_In_opt_z_ const CHAR *pszFileName,
	_In_ DWORD_PTR dwProcess = 0);

BOOL __stdcall AtlTraceSaveSettingsU(
	_In_opt_z_ const WCHAR *pszFileName,
	_In_ DWORD_PTR dwProcess = 0);

typedef struct ATLTRACESETTINGS
{
	UINT nLevel;
	ATLTRACESTATUS eStatus;
} ATLTRACESETTINGS;

typedef struct ATLTRACEPROCESSSETTINGS
{
	UINT nLevel;
	BOOL bEnabled;
	BOOL bFuncAndCategoryNames;
	BOOL bFileNameAndLineNo;
} ATLTRACEPROCESSSETTINGS;

typedef struct ATLTRACEPROCESSINFO
{
	WCHAR szName[ATL_TRACE_MAX_NAME_SIZE];
	WCHAR szPath[MAX_PATH];
	DWORD dwId;
	ATLTRACEPROCESSSETTINGS settings;
	int nModules;
} ATLTRACEPROCESSINFO;

typedef struct ATLTRACEMODULEINFO
{
	WCHAR szName[ATL_TRACE_MAX_NAME_SIZE];
	WCHAR szPath[MAX_PATH];
	ATLTRACESETTINGS settings;
	DWORD_PTR dwModule;
	int nCategories;
} ATLTRACEMODULEINFO;

typedef struct ATLTRACECATEGORYINFO
{
	WCHAR szName[ATL_TRACE_MAX_NAME_SIZE];
	ATLTRACESETTINGS settings;
	DWORD_PTR dwCategory;
} ATLTRACECATEGORYINFO;

BOOL __stdcall AtlTraceGetProcessInfo(
	_In_ DWORD_PTR dwProcess,
	_Out_ ATLTRACEPROCESSINFO* pProcessInfo);

void __stdcall AtlTraceGetModuleInfo(
	_In_ DWORD_PTR dwProcess,
	_In_ int iModule,
	_Out_ ATLTRACEMODULEINFO* pModuleInfo);

void __stdcall AtlTraceGetCategoryInfo(
	_In_ DWORD_PTR dwProcess,
	_In_ DWORD_PTR dwModule,
	_In_ int iCategory,
	_Out_ ATLTRACECATEGORYINFO* pAtlTraceCategoryInfo);

#ifdef UNICODE
#define AtlTraceRegisterCategory AtlTraceRegisterCategoryU
#define AtlTraceGetUpdateEventName AtlTraceGetUpdateEventNameU
#define AtlTraceGetUpdateEventName_s AtlTraceGetUpdateEventNameU_s
#define AtlTrace AtlTraceU
#define AtlTraceV AtlTraceVU
#define AtlTraceLoadSettings AtlTraceLoadSettingsU
#define AtlTraceSaveSettings AtlTraceSaveSettingsU

#else
#define AtlTraceRegisterCategory AtlTraceRegisterCategoryA
#define AtlTraceGetUpdateEventName AtlTraceGetUpdateEventNameA
#define AtlTraceGetUpdateEventName_s AtlTraceGetUpdateEventNameA_s
#define AtlTrace AtlTraceA
#define AtlTraceV AtlTraceVA
#define AtlTraceLoadSettings AtlTraceLoadSettingsA
#define AtlTraceSaveSettings AtlTraceSaveSettingsA

#endif

#ifdef __cplusplus
};

};  // namespace ATL
#pragma pack(pop)
#endif

#endif  // __ATLDEBUGAPI_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\include\atlenc.h ===
// This is a part of the Active Template Library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Active Template Library Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Active Template Library product.

#ifndef __ATLENC_H__
#define __ATLENC_H__

#pragma once

#include <atlbase.h>
#include <stdio.h>

#pragma pack(push,_ATL_PACKING)
namespace ATL {

#ifndef ATL_UUENCODE_END
#define ATL_UUENCODE_END "end\r\n"
#endif//ATL_UUENCODE_END

//Not including CRLFs
//NOTE: For BASE64 and UUENCODE, this actually
//represents the amount of unencoded characters
//per line
#define ATLSMTP_MAX_QP_LINE_LENGTH       76
#define ATLSMTP_MAX_BASE64_LINE_LENGTH   57
#define ATLSMTP_MAX_UUENCODE_LINE_LENGTH 45


//=======================================================================
// Base64Encode/Base64Decode
// compliant with RFC 2045
//=======================================================================
//
#define ATL_BASE64_FLAG_NONE	0
#define ATL_BASE64_FLAG_NOPAD	1
#define ATL_BASE64_FLAG_NOCRLF  2

inline int Base64EncodeGetRequiredLength(
	_In_ int nSrcLen,
	_In_ DWORD dwFlags = ATL_BASE64_FLAG_NONE)
{
	__int64 nSrcLen4=static_cast<__int64>(nSrcLen)*4;
	ATLENSURE(nSrcLen4 <= INT_MAX);

	int nRet = static_cast<int>(nSrcLen4/3);

	if ((dwFlags & ATL_BASE64_FLAG_NOPAD) == 0)
		nRet += nSrcLen % 3;

	int nCRLFs = nRet / 76 + 1;
	int nOnLastLine = nRet % 76;

	if (nOnLastLine)
	{
		if (nOnLastLine % 4)
			nRet += 4-(nOnLastLine % 4);
	}

	nCRLFs *= 2;

	if ((dwFlags & ATL_BASE64_FLAG_NOCRLF) == 0)
		nRet += nCRLFs;

	return nRet;
}

inline int Base64DecodeGetRequiredLength(_In_ int nSrcLen) throw()
{
	return nSrcLen;
}

inline BOOL Base64Encode(
	_In_count_(nSrcLen) const BYTE *pbSrcData,
	_In_ int nSrcLen,
	_Out_z_cap_post_count_(*pnDestLen, *pnDestLen) LPSTR szDest,
	_Inout_ int *pnDestLen,
	_In_ DWORD dwFlags = ATL_BASE64_FLAG_NONE) throw()
{
	static const char s_chBase64EncodingTable[64] = {
		'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q',
		'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z', 'a', 'b', 'c', 'd', 'e', 'f', 'g',	'h',
		'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y',
		'z', '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '+', '/' };

	if (!pbSrcData || !szDest || !pnDestLen)
	{
		return FALSE;
	}

	if(*pnDestLen < Base64EncodeGetRequiredLength(nSrcLen, dwFlags))
	{
		ATLASSERT(FALSE);
		return FALSE;
	}

	int nWritten( 0 );
	int nLen1( (nSrcLen/3)*4 );
	int nLen2( nLen1/76 );
	int nLen3( 19 );

	for (int i=0; i<=nLen2; i++)
	{
		if (i==nLen2)
			nLen3 = (nLen1%76)/4;

		for (int j=0; j<nLen3; j++)
		{
			DWORD dwCurr(0);
			for (int n=0; n<3; n++)
			{
				dwCurr |= *pbSrcData++;
				dwCurr <<= 8;
			}
			for (int k=0; k<4; k++)
			{
				BYTE b = (BYTE)(dwCurr>>26);
				*szDest++ = s_chBase64EncodingTable[b];
				dwCurr <<= 6;
			}
		}
		nWritten+= nLen3*4;

		if ((dwFlags & ATL_BASE64_FLAG_NOCRLF)==0)
		{
			*szDest++ = '\r';
			*szDest++ = '\n';
			nWritten+= 2;
		}
	}

	if (nWritten && (dwFlags & ATL_BASE64_FLAG_NOCRLF)==0)
	{
		szDest-= 2;
		nWritten -= 2;
	}

	nLen2 = (nSrcLen%3) ? (nSrcLen%3 + 1) : 0;
	if (nLen2)
	{
		DWORD dwCurr(0);
		for (int n=0; n<3; n++)
		{
			if (n<(nSrcLen%3))
				dwCurr |= *pbSrcData++;
			dwCurr <<= 8;
		}
		for (int k=0; k<nLen2; k++)
		{
			BYTE b = (BYTE)(dwCurr>>26);
			*szDest++ = s_chBase64EncodingTable[b];
			dwCurr <<= 6;
		}
		nWritten+= nLen2;
		if ((dwFlags & ATL_BASE64_FLAG_NOPAD)==0)
		{
			nLen3 = nLen2 ? 4-nLen2 : 0;
			for (int j=0; j<nLen3; j++)
			{
				*szDest++ = '=';
			}
			nWritten+= nLen3;
		}
	}

	*pnDestLen = nWritten;
	return TRUE;
}

inline int DecodeBase64Char(_In_ unsigned int ch) throw()
{
	// returns -1 if the character is invalid
	// or should be skipped
	// otherwise, returns the 6-bit code for the character
	// from the encoding table
	if (ch >= 'A' && ch <= 'Z')
		return ch - 'A' + 0;	// 0 range starts at 'A'
	if (ch >= 'a' && ch <= 'z')
		return ch - 'a' + 26;	// 26 range starts at 'a'
	if (ch >= '0' && ch <= '9')
		return ch - '0' + 52;	// 52 range starts at '0'
	if (ch == '+')
		return 62;
	if (ch == '/')
		return 63;
	return -1;
}

inline BOOL Base64Decode(
	_In_z_count_(nSrcLen) LPCSTR szSrc,
	_In_ int nSrcLen,
	_Out_cap_post_count_(*pnDestLen, *pnDestLen) BYTE *pbDest,
	_Inout_ int *pnDestLen) throw()
{
	// walk the source buffer
	// each four character sequence is converted to 3 bytes
	// CRLFs and =, and any characters not in the encoding table
	// are skiped

	if (szSrc == NULL || pnDestLen == NULL)
	{
		ATLASSERT(FALSE);
		return FALSE;
	}

	LPCSTR szSrcEnd = szSrc + nSrcLen;
	int nWritten = 0;

	BOOL bOverflow = (pbDest == NULL) ? TRUE : FALSE;

	while (szSrc < szSrcEnd &&(*szSrc) != 0)
	{
		DWORD dwCurr = 0;
		int i;
		int nBits = 0;
		for (i=0; i<4; i++)
		{
			if (szSrc >= szSrcEnd)
				break;
			int nCh = DecodeBase64Char(*szSrc);
			szSrc++;
			if (nCh == -1)
			{
				// skip this char
				i--;
				continue;
			}
			dwCurr <<= 6;
			dwCurr |= nCh;
			nBits += 6;
		}

		if(!bOverflow && nWritten + (nBits/8) > (*pnDestLen))
			bOverflow = TRUE;

		// dwCurr has the 3 bytes to write to the output buffer
		// left to right
		dwCurr <<= 24-nBits;
		for (i=0; i<nBits/8; i++)
		{
			if(!bOverflow)
			{
				*pbDest = (BYTE) ((dwCurr & 0x00ff0000) >> 16);
				pbDest++;
			}
			dwCurr <<= 8;
			nWritten++;
		}

	}

	*pnDestLen = nWritten;

	if(bOverflow)
	{
		if(pbDest != NULL)
		{
			ATLASSERT(FALSE);
		}

		return FALSE;
	}

	return TRUE;
}


//=======================================================================
// UUEncode/UUDecode
// compliant with POSIX P1003.2b/D11
//=======================================================================
//
//Flag to determine whether or not we should encode the header
#define ATLSMTP_UUENCODE_HEADER 1

//Flag to determine whether or not we should encode the end
#define ATLSMTP_UUENCODE_END    2

//Flag to determine whether or not we should do data stuffing
#define ATLSMTP_UUENCODE_DOT    4

//The the (rough) required length of the uuencoded stream based
//on input of length nSrcLen
inline int UUEncodeGetRequiredLength(_In_ int nSrcLen)
{
	__int64 nRet64=static_cast<__int64>(nSrcLen)*4/3;
	nRet64 += 3*(nSrcLen/ATLSMTP_MAX_UUENCODE_LINE_LENGTH);
	nRet64 += 12+MAX_PATH; // "begin" statement
	nRet64 += 8; // "end" statement
	nRet64 += 1; // dot-stuffing
	ATLENSURE(nRet64 <= INT_MAX && nRet64 >= INT_MIN);
	int nRet = static_cast<int>(nRet64);
	return nRet;
}

//Get the decode required length
inline int UUDecodeGetRequiredLength(_In_ int nSrcLen) throw()
{
	return nSrcLen;
}

#define UUENCODE(ch) ((ch) ? ((ch) & 0x3F ) + ' ' : '`')

#ifdef _DEBUG
inline void UUEncodeCheckFilename(_In_z_ const char* pcszFilename)
{
	// It's the callers responsibility to supply a filename that can readily be
	// used for the UUEncode header. We do a basic check here because there does
	// not appear to be a real specification.
	for (const char* pc = pcszFilename; *pc != 0; ++pc)
	{
		if (*pc >= 32 && *pc < 127)
			;
		else
		{
			ATLASSERT( "Is *pc a character suitable for filenames in UUEncode header" && 0 );
			break;
		}
	}
}
#endif // def _DEBUG

namespace Checked {
template <typename T>
inline
T* EnsureNotBeyond(T* p, T* end)
{
	ATLENSURE(p < end);
	return p;
}
} // namespace Checked

//encode a chunk of data
// this warning is bogus
// Invalid data: accessing 'szDest', the readable size is 'sizeof(("end??"))-1' bytes, but '15' bytes might be read
ATLPREFAST_SUPPRESS(6385)
inline BOOL UUEncode(
	_In_bytecount_(nSrcLen) const BYTE* pbSrcData,
	_In_ int nSrcLen,
	_Out_z_cap_post_count_(*pnDestLen, *pnDestLen) LPSTR szDestBegin,
	_Inout_ int* pnDestLen,
	_In_opt_z_ LPCTSTR lpszFile = _T("file"),
	_In_ DWORD dwFlags = 0) throw()
{
	//The UUencode character set
	static const char s_chUUEncodeChars[64] = {
		'`','!','"','#','$','%','&','\'','(',')','*','+',',',
		'-','.','/','0','1','2','3','4','5','6','7','8','9',
		':',';','<','=','>','?','@','A','B','C','D','E','F',
		'G','H','I','J','K','L','M','N','O','P','Q','R','S',
		'T','U','V','W','X','Y','Z','[','\\',']','^','_'
	};

	if (!pbSrcData || !szDestBegin || !pnDestLen)
	{
		return FALSE;
	}

	ATLASSERT(*pnDestLen >= UUEncodeGetRequiredLength(nSrcLen));

	char* szDest = szDestBegin;
	char* const szDestEnd = szDestBegin + *pnDestLen;

	using Checked::EnsureNotBeyond;

	ATLENSURE(szDestEnd >= szDestBegin );

	BYTE ch1 = 0, ch2 = 0, ch3 = 0;
	int nTotal = 0, nCurr = 0, nWritten = 0, nCnt = 0;

	//if ATL_UUENCODE_HEADER
	//header
	if (dwFlags & ATLSMTP_UUENCODE_HEADER)
	{
		if (!lpszFile)
		{
			return FALSE;
		}

		{
			CT2CAEX<MAX_PATH+1> narrowFilename( lpszFile );
#ifdef _DEBUG
			UUEncodeCheckFilename(narrowFilename);
#endif
			//default permission is 666
			nWritten = sprintf_s(szDest, *pnDestLen, "begin 666 %s\r\n", static_cast<LPCSTR>(narrowFilename));
		}
		if (nWritten < 0)
		{
			if(*pnDestLen>0)
			{
				szDest[0]='\0';
			}
			return FALSE;
		}

		szDest += nWritten;
	}

	//while we haven't reached the end of the data
	while (nTotal < nSrcLen)
	{
		//If the amount of data is greater than MAX_UUENCODE_LINE_LENGTH
		//cut off at MAX_UUENCODE_LINE_LENGTH
		nCurr = __min(nSrcLen-nTotal, ATLSMTP_MAX_UUENCODE_LINE_LENGTH);
		*EnsureNotBeyond(szDest,szDestEnd) = UUENCODE((unsigned char)(nCurr));
		nCurr++;
		nCnt = 1;

		nWritten++;
		//if we need to stuff an extra dot (e.g. when we are sending via SMTP), do it
		if ((dwFlags & ATLSMTP_UUENCODE_DOT) && *szDest == '.')
		{
			*EnsureNotBeyond(++szDest,szDestEnd) = '.';
			nWritten++;
		}
		szDest++;
		while (nCnt < nCurr)
		{
			//Set to 0 in the uuencoding alphabet
			ch1 = ch2 = ch3 = ' ';
			ch1 = *pbSrcData++;
			nCnt++;
			nTotal++;
			if (nTotal < nSrcLen)
			{
				ch2 = *pbSrcData++;
				nCnt++;
				nTotal++;
			}
			if (nTotal < nSrcLen)
			{
				ch3 = *pbSrcData++;
				nCnt++;
				nTotal++;
			}

			//encode the first 6 bits of ch1
			*EnsureNotBeyond(szDest++,szDestEnd) = s_chUUEncodeChars[(ch1 >> 2) & 0x3F];
			//encode the last 2 bits of ch1 and the first 4 bits of ch2
			*EnsureNotBeyond(szDest++,szDestEnd)  = s_chUUEncodeChars[((ch1 << 4) & 0x30) | ((ch2 >> 4) & 0x0F)];
			//encode the last 4 bits of ch2 and the first 2 bits of ch3
			*EnsureNotBeyond(szDest++,szDestEnd)  = s_chUUEncodeChars[((ch2 << 2) & 0x3C) | ((ch3 >> 6) & 0x03)];
			//encode the last 6 bits of ch3
			*EnsureNotBeyond(szDest++,szDestEnd) = s_chUUEncodeChars[ch3 & 0x3F];
			nWritten += 4;
		}
		//output a CRLF
		*EnsureNotBeyond(szDest++,szDestEnd)  = '\r'; 
		*EnsureNotBeyond(szDest++,szDestEnd)  = '\n'; 
		nWritten += 2;
	}

	//if we need to encode the end, do it
	if (dwFlags & ATLSMTP_UUENCODE_END)
	{
		*EnsureNotBeyond(szDest++,szDestEnd) = '`'; 
		*EnsureNotBeyond(szDest++,szDestEnd) = '\r';
		*EnsureNotBeyond(szDest++,szDestEnd) = '\n';
		nWritten += 3;

		Checked::memcpy_s(szDest, *pnDestLen-nWritten, ATL_UUENCODE_END, sizeof(ATL_UUENCODE_END)-1);
		nWritten += sizeof("end\r\n")-1;
	}
	*pnDestLen = nWritten;
	return TRUE;
}
ATLPREFAST_UNSUPPRESS()

#define UUDECODE(ch) (((ch) == '`') ? '\0' : ((ch) - ' ') & 0x3F)

inline BOOL UUDecode(
	_In_bytecount_(nSrcLen) BYTE* pbSrcData,
	_In_ int nSrcLen,
	_Out_cap_post_count_(*pnDestLen, *pnDestLen) BYTE* pbDest,
	_Inout_ int* pnDestLen)
{
	if (!pbSrcData || !pbDest || !pnDestLen)
	{
		return FALSE;
	}

	BYTE* pbDestEnd=pbDest+*pnDestLen;
	int nConvert = 0;
	int nScan = 0;

	int nWritten = 0;
	int fSkipLine = 0;
	int nLineLen = 0;

	char chars[4];
	char ch;

	while (nSrcLen > 0)
	{
		if (*pbSrcData == '\r' || *pbSrcData == '\n')
		{
			fSkipLine = 0;
			pbSrcData++;
			nSrcLen--;
			nLineLen = 0;
			continue;
		}
		if (fSkipLine)
		{
			pbSrcData++;
			nSrcLen--;
			continue;
		}

		// skip begin/end lines
		if ((nSrcLen >= sizeof("begin")-1 && !_strnicmp((char *)pbSrcData, "begin", sizeof("begin")-1)) ||
			(nSrcLen >= sizeof("end")-1 && !_strnicmp((char *)pbSrcData, "end", sizeof("end")-1)))
		{
			fSkipLine = 1;
			continue;
		}

		// skip first character on line
		nLineLen = UUDECODE(*pbSrcData);
		pbSrcData++;
		nSrcLen--;

		nConvert = 0;
		nScan = 0;

		while (nScan < nLineLen)
		{
			if (nSrcLen > 0)
			{
				if (*pbSrcData == '\r' || *pbSrcData == '\n')
				{
					// invalid uuencoding
					return FALSE;
				}
				ch = *pbSrcData++;
				nSrcLen--;
			}
			else
			{
				ch = ' ';
			}

			chars[nConvert++] = UUDECODE(ch);

			if (nConvert == 4)
			{
				// write to destination buffer if it fits
				if (nScan < nLineLen && pbDest < pbDestEnd)
				{
					nScan++;
					*pbDest++ = (BYTE)(((chars[0] & 0x3F) << 2) | ((chars[1] & 0x3F) >> 4));
				}
				if (nScan < nLineLen && pbDest < pbDestEnd)
				{
					nScan++;
					*pbDest++ = (BYTE)(((chars[1] & 0x3F) << 4) | ((chars[2] & 0x3F) >> 2));
				}
				if (nScan < nLineLen && pbDest < pbDestEnd)
				{
					nScan++;
					*pbDest++ = (BYTE)(((chars[2] & 0x3F) << 6) | (chars[3] & 0x3F));
				}

				// if we are at the end of the buffer and there's still more to write, return error
				if (pbDest >= pbDestEnd && nScan < nLineLen)
				{
					// Estimating how much space we need
					// (this should always give you more than that is required, but give still
					// give better estimate than UUDecodeGetRequiredLength()
					// Math:
					//     nWritten - length we have decoded so far (not including the current line)
					//     nScan - length of the current line that we have decoded so far
					//     nSrcLen - length of the encoded stream that we haven't read
					//               (encoded length is always greater than decoded length)
					//
					*pnDestLen = nWritten + nScan + nSrcLen;
					return FALSE;
				}

				nConvert = 0;
			}
		}
		nWritten+= nLineLen;
	}

	*pnDestLen = nWritten;
	return TRUE;
}

//=======================================================================
// Quoted Printable encode/decode
// compliant with RFC 2045
//=======================================================================
//
inline int QPEncodeGetRequiredLength(_In_ int nSrcLen)
{
	__int64 nRet64 = 3*((3*static_cast<__int64>(nSrcLen))/(ATLSMTP_MAX_QP_LINE_LENGTH-8));
	nRet64 += 3*static_cast<__int64>(nSrcLen);
	nRet64 += 3;
	ATLENSURE(nRet64 <= INT_MAX && nRet64 >= INT_MIN);
	int nRet = static_cast<int>(nRet64);
	return nRet;
}

inline int QPDecodeGetRequiredLength(_In_ int nSrcLen) throw()
{
	return nSrcLen;
}


#define ATLSMTP_QPENCODE_DOT 1
#define ATLSMTP_QPENCODE_TRAILING_SOFT 2

inline BOOL QPEncode(
	_In_bytecount_(nSrcLen) BYTE* pbSrcData,
	_In_ int nSrcLen,
	_Out_cap_post_count_(*pnDestLen, *pnDestLen) CHAR* szDest,
	_Inout_ int* pnDestLen,
	_In_ DWORD dwFlags = 0) throw()
{
	//The hexadecimal character set
	static const char s_chHexChars[16] = {'0', '1', '2', '3', '4', '5', '6', '7', '8', '9',
								'A', 'B', 'C', 'D', 'E', 'F'};

	if (!pbSrcData || !szDest || !pnDestLen)
	{
		return FALSE;
	}

	ATLASSERT(*pnDestLen >= QPEncodeGetRequiredLength(nSrcLen));

	int nRead = 0, nWritten = 0, nLineLen = 0;
	char ch;
	while (nRead < nSrcLen)
	{
		ch = *pbSrcData++;
		nRead++;
		if (nLineLen == 0 && ch == '.' && (dwFlags & ATLSMTP_QPENCODE_DOT))
		{
			*szDest++ = '.';
			nWritten++;
			nLineLen++;
		}
		if ((ch > 32 && ch < 61) || (ch > 61 && ch < 127))
		{
			*szDest++ = ch;
			nWritten++;
			nLineLen++;
		}
		else if ((ch == ' ' || ch == '\t') && (nLineLen < (ATLSMTP_MAX_QP_LINE_LENGTH-12)))
		{
			*szDest++ = ch;
			nWritten++;
			nLineLen++;
		}
		else
		{
			*szDest++ = '=';
			*szDest++ = s_chHexChars[(ch >> 4) & 0x0F];
			*szDest++ = s_chHexChars[ch & 0x0F];
			nWritten += 3;
			nLineLen += 3;
		}
		if (nLineLen >= (ATLSMTP_MAX_QP_LINE_LENGTH-11))
		{
			*szDest++ = '=';
			*szDest++ = '\r';
			*szDest++ = '\n';
			nLineLen = 0;
			nWritten += 3;
		}
	}
	if (dwFlags & ATLSMTP_QPENCODE_TRAILING_SOFT)
	{
		*szDest++ = '=';
		*szDest++ = '\r';
		*szDest++ = '\n';
		nWritten += 3;
	}

	*pnDestLen = nWritten;

	return TRUE;
}

inline BOOL QPDecode(
	_In_bytecount_(nSrcLen) BYTE* pbSrcData,
	_In_ int nSrcLen,
	_Out_cap_post_count_(*pnDestLen, *pnDestLen) CHAR* szDest,
	_Inout_ int* pnDestLen,
	_In_ DWORD dwFlags = 0)
{
	if (!pbSrcData || !szDest || !pnDestLen)
	{
		return FALSE;
	}

	LPSTR szDestEnd=szDest + *pnDestLen;
	int nRead = 0, nWritten = 0, nLineLen = -1;
	char ch;
	while (nRead <= nSrcLen)
	{
		ch = *pbSrcData++;
		nRead++;
		nLineLen++;
		if (ch == '=')
		{
			//if the next character is a digit or a character, convert
			if ( ( nRead < ( nSrcLen - 1 ) ) && (isdigit(static_cast<unsigned char>(*pbSrcData)) || isalpha(static_cast<unsigned char>(*pbSrcData))))
			{
				char szBuf[5];
				szBuf[0] = *pbSrcData++;
				szBuf[1] = *pbSrcData++;
				szBuf[2] = '\0';
				char* tmp = '\0';
				ATLENSURE(szDest < szDestEnd);
				*szDest++ = (BYTE)strtoul(szBuf, &tmp, 16);
				nWritten++;
				nRead += 2;
				continue;
			}
			//if the next character is a carriage return or line break, eat it
			if (nRead < nSrcLen && *pbSrcData == '\r' && (nRead+1 < nSrcLen) && *(pbSrcData+1)=='\n')
			{
				pbSrcData++;
				nRead++;
				nLineLen = -1;
				continue;
			}
			return FALSE;
		}
		if (ch == '\r' || ch == '\n')
		{
			nLineLen = -1;
			continue;
		}
		if ((dwFlags & ATLSMTP_QPENCODE_DOT) && ch == '.' && nLineLen == 0)
		{
			continue;
		}
		ATLENSURE(szDest < szDestEnd);
		*szDest++ = ch;
		nWritten++;
	}

	*pnDestLen = nWritten-1;
	return TRUE;
}

//=======================================================================
// Q and B encoding (for encoding MIME header information)
// compliant with RFC 2047
//=======================================================================

inline int IsExtendedChar(_In_ char ch) throw()
{
	return ((ch > 126 || ch < 32) && ch != '\t' && ch != '\n' && ch != '\r');
}

inline int GetExtendedChars(
	_In_z_count_(nSrcLen) LPCSTR szSrc,
	_In_ int nSrcLen)
{
	ATLENSURE( szSrc );

	int nChars(0);

	for (int i=0; i<nSrcLen; i++)
	{
		if (IsExtendedChar(*szSrc++))
			nChars++;
	}

	return nChars;
}

#ifndef ATL_MAX_ENC_CHARSET_LENGTH
#define ATL_MAX_ENC_CHARSET_LENGTH 50
#endif

//Get the required length to hold this encoding based on nSrcLen
inline int QEncodeGetRequiredLength(
	_In_ int nSrcLen,
	_In_ int nCharsetLen) throw()
{
	return QPEncodeGetRequiredLength(nSrcLen)+7+nCharsetLen;
}

inline BOOL IsBufferWriteSafe(
	_In_ int nNumOfCharsAboutToWrite,
	_In_ int nBuffSize)
{
	if(nNumOfCharsAboutToWrite >= nBuffSize)
	{
		ATLASSERT(FALSE);
		return FALSE;
	}
	return TRUE;
}

//QEncode pbSrcData with the charset specified by pszCharSet
inline BOOL QEncode(
	_In_bytecount_(nSrcLen) BYTE* pbSrcData,
	_In_ int nSrcLen,
	_Out_z_cap_post_count_(*pnDestLen, *pnDestLen) LPSTR szDest,
	_Inout_ int* pnDestLen,
	_In_z_ LPCSTR pszCharSet,
	_Out_opt_ int* pnNumEncoded = NULL) throw()
{
	//The hexadecimal character set
	static const char s_chHexChars[16] = {'0', '1', '2', '3', '4', '5', '6', '7', '8', '9',
								'A', 'B', 'C', 'D', 'E', 'F'};

	if (!pbSrcData || !szDest || !pszCharSet || !pnDestLen)
	{
		return FALSE;
	}

	if(*pnDestLen < QEncodeGetRequiredLength(nSrcLen, ATL_MAX_ENC_CHARSET_LENGTH))
	{
		ATLASSERT(FALSE);
		return FALSE;
	}

	int nRead = 0, nWritten = 0, nEncCnt = 0;
	char ch;

	if (!IsBufferWriteSafe(nWritten+2, *pnDestLen))
	{
		return FALSE;
	}
	*szDest++ = '=';
	*szDest++ = '?';
	nWritten = 2;

	//output the charset
	while(nWritten < *pnDestLen && *pszCharSet != '\0')
	{
		*szDest++ = *pszCharSet++;
		nWritten++;
	}

	if (!IsBufferWriteSafe(nWritten+3, *pnDestLen))
	{
		return FALSE;
	}
	*szDest++ = '?';
	*szDest++ = 'Q';
	*szDest++ = '?';
	nWritten += 3;

	while (nRead < nSrcLen)
	{
		ch = *pbSrcData++;
		nRead++;
		if (((ch > 32 && ch < 61) || (ch > 61 && ch < 127)) && ch != '?' && ch != '_')
		{
			if (!IsBufferWriteSafe(nWritten+1, *pnDestLen))
			{
					return FALSE;
			}
			*szDest++ = ch;
			nWritten++;
			continue;
					}
		//otherwise it is an unprintable/unsafe character
		if (!IsBufferWriteSafe(nWritten+3, *pnDestLen))
		{
			return FALSE;
		}
		*szDest++ = '=';
		*szDest++ = s_chHexChars[(ch >> 4) & 0x0F];
		*szDest++ = s_chHexChars[ch & 0x0F];
		if (ch < 32 || ch > 126)
			nEncCnt++;
		nWritten += 3;
	}
	if (!IsBufferWriteSafe(nWritten+2, *pnDestLen))
	{
		return FALSE;
	}
	*szDest++ = '?';
	*szDest++ = '=';
	*szDest = 0;
	nWritten += 2;

	*pnDestLen = nWritten;

	if (pnNumEncoded)
		*pnNumEncoded = nEncCnt;

	return TRUE;
}

#define BENCODE_ADDITION_SIZE 7 // size of prefix+suffix added by the encoding.

//Get the required length to hold this encoding based on nSrcLen
inline int BEncodeGetRequiredLength(
	_In_ int nSrcLen,
	_In_ int nCharsetLen) throw()
{
	return Base64EncodeGetRequiredLength(nSrcLen)+BENCODE_ADDITION_SIZE+nCharsetLen;
}

//BEncode pbSrcData with the charset specified by pszCharSet
inline BOOL BEncode(
	_In_bytecount_(nSrcLen) BYTE* pbSrcData,
	_In_ int nSrcLen,
	_Out_z_cap_post_count_(*pnDestLen, *pnDestLen) LPSTR szDest,
	_Inout_ int* pnDestLen,
	_In_z_ LPCSTR pszCharSet) throw()
{
	if (!pbSrcData || !szDest || !pszCharSet || !pnDestLen)
	{
		return FALSE;
	}

	if(*pnDestLen < BEncodeGetRequiredLength(nSrcLen, ATL_MAX_ENC_CHARSET_LENGTH))
	{
		ATLASSERT(FALSE);
		return FALSE;
	}

	int nWritten = 0;

	if (!IsBufferWriteSafe(nWritten+2, *pnDestLen))
	{
		return FALSE;
	}
	*szDest++ = '=';
	*szDest++ = '?';
	nWritten = 2;

	//output the charset
	while(nWritten < *pnDestLen && *pszCharSet != '\0')
	{
		*szDest++ = *pszCharSet++;
		nWritten++;
	}

	if (!IsBufferWriteSafe(nWritten+3, *pnDestLen))
	{
		return FALSE;
	}
	*szDest++ = '?';
	*szDest++ = 'B';
	*szDest++ = '?';
	nWritten += 3;

	// the buffer size is *pnDestLen - size of the header and the tail.
	int DataDestLen = *pnDestLen - BENCODE_ADDITION_SIZE;
	BOOL bRet = Base64Encode(pbSrcData, nSrcLen, szDest, &DataDestLen, ATL_BASE64_FLAG_NOCRLF);
	if (!bRet)
		return FALSE;

	nWritten += DataDestLen;
	szDest += DataDestLen;
	if (!IsBufferWriteSafe(nWritten+2, *pnDestLen))
	{
		return FALSE;
	}
	*szDest++ = '?';
	*szDest++ = '=';
	*szDest = 0;
	nWritten += 2;

	*pnDestLen = nWritten;
	return TRUE;
}

//=======================================================================
// AtlUnicodeToUTF8
//
// Support for converting UNICODE strings to UTF8
//
//=======================================================================
//

#define ATL_HIGH_SURROGATE_START  0xd800
#define ATL_HIGH_SURROGATE_END    0xdbff
#define ATL_LOW_SURROGATE_START   0xdc00
#define ATL_LOW_SURROGATE_END     0xdfff

ATL_NOINLINE inline
int AtlUnicodeToUTF8(
	_In_count_(nSrc) LPCWSTR wszSrc,
	_In_ int nSrc,
	_Out_opt_z_cap_post_count_(nDest, return + 1) LPSTR szDest,
	_In_ int nDest)
{
	return(WideCharToMultiByte(CP_UTF8, 0, wszSrc, nSrc, szDest, nDest, NULL, NULL));
}


//=======================================================================
// EscapeXML
//
// Support for escaping strings for use in XML documents
//=======================================================================
//

#define ATL_ESC_FLAG_NONE 0
#define ATL_ESC_FLAG_ATTR 1 // escape for attribute values

inline int _AtlCopyNCR(
	_In_ wchar_t wch,
	_Out_z_cap_c_(9) wchar_t *wszEsc) throw()
{
	wchar_t szHex[9];
	int nRet = swprintf_s(szHex, _countof(szHex), L"&#x%04X;", wch);
	Checked::memcpy_s(wszEsc, 9*sizeof(wchar_t), szHex, 8*sizeof(wchar_t));
	return nRet;
}

inline int _AtlCopyNCRPair(
	_In_ DWORD dw,
	_Out_z_cap_c_(11) wchar_t *wszEsc) throw()
{
	wchar_t szHex[11];
	int nRet = swprintf_s(szHex, _countof(szHex), L"&#x%06X;", dw);
	Checked::memcpy_s(wszEsc, 11*sizeof(wchar_t), szHex, 10*sizeof(wchar_t));
	return nRet;
}

// wide-char version
inline int EscapeXML(
	_In_count_(nSrcLen) const wchar_t *szIn,
	_In_ int nSrcLen,
	_Out_opt_cap_post_count_(nDestLen, return + 1) wchar_t *szEsc,
	_In_ int nDestLen,
	_In_ DWORD dwFlags = ATL_ESC_FLAG_NONE)
{
	ATLENSURE( szIn != NULL );

	int nCnt(0);
	int nCurrLen(nDestLen);
	int nInc(0);
	wchar_t wchHighSurrogate = 0;
	BOOL bHandled;

	while (nSrcLen--)
	{
		bHandled = FALSE;
		nInc = 0;
		switch (*szIn)
		{
		case L'<': case L'>':
			if ((szEsc != NULL) && (3 < nCurrLen))
			{
				*szEsc++ = L'&';
				*szEsc++ = (*szIn==L'<' ? L'l' : L'g');
				*szEsc++ = L't';
				*szEsc++ = L';';
			}
			nInc = 4;
			break;

		case L'&':
			if ((szEsc != NULL) && (4 < nCurrLen))
			{
				Checked::memcpy_s(szEsc, nCurrLen*sizeof(wchar_t), L"&amp;", 5*sizeof(wchar_t));
				szEsc+= 5;
			}
			nInc = 5;
			break;

		case L'\'': case L'\"': // escaping for attribute values
			if (dwFlags & ATL_ESC_FLAG_ATTR)
			{
				if ((szEsc != NULL) && (5 < nCurrLen))
				{
					Checked::memcpy_s(szEsc, nCurrLen*sizeof(wchar_t), (*szIn == L'\'' ? L"&apos;" : L"&quot;"), 6*sizeof(wchar_t));
					szEsc+= 6;
				}
				nInc = 6;
				break;
			}
			// fall through

		default:
			// check if high surrogate is available
			if ((*szIn >= ATL_HIGH_SURROGATE_START) && (*szIn <= ATL_HIGH_SURROGATE_END))
			{
				// another high surrogate, then treat the 1st as normal unicode character
				if (wchHighSurrogate)
				{
					if ((szEsc != NULL) && (7 < nCurrLen))
					{
						_AtlCopyNCR(wchHighSurrogate, szEsc);
						szEsc+= 8;
					}
					nInc = 8;
				}
				wchHighSurrogate = *szIn;
				bHandled = TRUE;
			}
			if ((!bHandled) && (wchHighSurrogate))
			{
				if ((*szIn >= ATL_LOW_SURROGATE_START) && (*szIn <= ATL_LOW_SURROGATE_END))
				{
					// valid surrogate pairs
					DWORD dwSurrogateChar = (((wchHighSurrogate-0xD800) << 10) + (*szIn - 0xDC00) + 0x10000);
					if ((szEsc != NULL) && (9 < nCurrLen))
					{
						_AtlCopyNCRPair(dwSurrogateChar, szEsc);
						szEsc+= 10;
					}
					nInc = 10;
					bHandled = TRUE;
				}
				else
				{
					// bad surrogate pair: ERROR
					// just process wchHighSurrogate, and the code below will
					// process the current code point
					if ((szEsc != NULL) && (7 < nCurrLen))
					{
						_AtlCopyNCR(wchHighSurrogate, szEsc);
						szEsc+= 8;
					}
					nCurrLen-= 8;
					nCnt+= 8;
				}
				wchHighSurrogate = 0;
			}
			if (!bHandled)
			{
				if ((*szIn < 0x0020) || (*szIn > 0x007E))
				{
					if ((szEsc != NULL) && (7 < nCurrLen))
					{
						_AtlCopyNCR(*szIn, szEsc);
						szEsc+= 8;
					}
					nInc = 8;
				}
				else
				{
					if ((szEsc != NULL) && (0 < nCurrLen))
					{
						*szEsc++ = *szIn;
					}
					nInc = 1;
				}
			}
		}

		nCurrLen -= nInc;
		nCnt+= nInc;

		szIn++;
	}

	// If the last character was a high surrogate, then handle it as a normal unicode character.
	if (wchHighSurrogate != 0)
	{
		if ((wchHighSurrogate < 0x0020) || (wchHighSurrogate > 0x007E))
		{
			if ((szEsc != NULL) && (7 < nCurrLen))
			{
				_AtlCopyNCR(wchHighSurrogate, szEsc);
			}
			nCurrLen -= 8;
			nCnt+= 8;
		}
		else
		{
			if ((szEsc != NULL) && (0 < nCurrLen))
			{
				*szEsc = wchHighSurrogate;
			}
			nCurrLen--;
			nCnt++;
		}
	}


	if ((szEsc != NULL) && (nCurrLen < 0))
	{
		return 0;
	}

	return nCnt;
}

//=======================================================================
// HexEncode, HexDecode
//
// Support for encoding/decoding binary XML datatypes with hex encoding
//=======================================================================
//

inline int AtlHexEncodeGetRequiredLength(_In_ int nSrcLen)
{
	__int64 nRet64=2*static_cast<__int64>(nSrcLen)+1;
	ATLENSURE(nRet64 <= INT_MAX && nRet64 >= INT_MIN);
	int nRet = static_cast<int>(nRet64);
	return nRet;
}

inline int AtlHexDecodeGetRequiredLength(_In_ int nSrcLen) throw()
{
	return nSrcLen/2;
}

inline BOOL AtlHexEncode(
	_In_bytecount_(nSrcLen) const BYTE *pbSrcData,
	_In_ int nSrcLen,
	_Out_z_cap_post_count_(*pnDestLen, *pnDestLen) LPSTR szDest,
	_Inout_ int *pnDestLen) throw()
{
	static const char s_chHexChars[16] = {'0', '1', '2', '3', '4', '5', '6', '7', '8', '9',
										  'A', 'B', 'C', 'D', 'E', 'F'};

	if (!pbSrcData || !szDest || !pnDestLen)
	{
		return FALSE;
	}

	if(*pnDestLen < AtlHexEncodeGetRequiredLength(nSrcLen))
	{
		ATLASSERT(FALSE);
		return FALSE;
	}

	int nRead = 0;
	int nWritten = 0;
	BYTE ch;
	while (nRead < nSrcLen)
	{
		ch = *pbSrcData++;
		nRead++;
		*szDest++ = s_chHexChars[(ch >> 4) & 0x0F];
		*szDest++ = s_chHexChars[ch & 0x0F];
		nWritten += 2;
	}

	*pnDestLen = nWritten;

	return TRUE;
}

#ifdef _CHAR_UNSIGNED
#define ATL_HEX_INVALID CHAR_MAX
#else
/* In pre-V8 this was always the value, which meant we didn't compile clean with /J */
#define ATL_HEX_INVALID ((char)(-1))
#endif

//Get the decimal value of a hexadecimal character
inline char AtlGetHexValue(_In_ char ch) throw()
{
	if (ch >= '0' && ch <= '9')
		return (ch - '0');
	if (ch >= 'A' && ch <= 'F')
		return (ch - 'A' + 10);
	if (ch >= 'a' && ch <= 'f')
		return (ch - 'a' + 10);
	return ATL_HEX_INVALID;
}

inline BOOL AtlHexDecode(
	_In_z_count_(nSrcLen) LPCSTR pSrcData,
	_In_ int nSrcLen,
	_Out_z_cap_post_count_(*pnDestLen, *pnDestLen) LPBYTE pbDest,
	_Inout_ int* pnDestLen) throw()
{
	if (!pSrcData || !pbDest || !pnDestLen)
	{
		return FALSE;
	}

	if(*pnDestLen < AtlHexDecodeGetRequiredLength(nSrcLen))
	{
		ATLASSERT(FALSE);
		return FALSE;
	}

	int nRead = 0;
	int nWritten = 0;
	while (nRead < nSrcLen)
	{
		char ch1 = AtlGetHexValue((char)*pSrcData++);
		char ch2 = AtlGetHexValue((char)*pSrcData++);
		if ((ch1==ATL_HEX_INVALID) || (ch2==ATL_HEX_INVALID))
		{
			return FALSE;
		}
		*pbDest++ = (BYTE)(16*ch1+ch2);
		nWritten++;
		nRead += 2;
	}

	*pnDestLen = nWritten;
	return TRUE;
}

} // namespace ATL
#pragma pack(pop)

#endif // __ATLENC_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\include\atlexcept.h ===
// This is a part of the Active Template Library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Active Template Library Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Active Template Library product.

#ifndef __ATLEXCEPT_H__
#define __ATLEXCEPT_H__

#pragma once

#include <atldef.h>
#include <atltrace.h>


#pragma pack(push,_ATL_PACKING)
namespace ATL
{

/////////////////////////////////////////////////////////////////////////////
// Exception raise (for functions that cannot return an error code)

inline void __declspec(noreturn) _AtlRaiseException(
	_In_ DWORD dwExceptionCode,
	_In_ DWORD dwExceptionFlags = EXCEPTION_NONCONTINUABLE)
{
	RaiseException( dwExceptionCode, dwExceptionFlags, 0, NULL );
}

class CAtlException
{
public:
	CAtlException() throw() :
		m_hr( E_FAIL )
	{
	}

	CAtlException(_In_ HRESULT hr) throw() :
		m_hr( hr )
	{
	}

	operator HRESULT() const throw()
	{
		return( m_hr );
	}

public:
	HRESULT m_hr;
};

#ifndef _ATL_NO_EXCEPTIONS

// Throw a CAtlException with the given HRESULT
#if defined( _ATL_CUSTOM_THROW )  // You can define your own AtlThrow to throw a custom exception.
#ifdef _AFX
#error MFC projects must use default implementation of AtlThrow()
#endif
#else
ATL_NOINLINE __declspec(noreturn) inline void WINAPI AtlThrowImpl(_In_ HRESULT hr)
{
	ATLTRACE(atlTraceException, 0, _T("AtlThrow: hr = 0x%x\n"), hr );
#ifdef _AFX
	if( hr == E_OUTOFMEMORY )
	{
		AfxThrowMemoryException();
	}
	else
	{
		AfxThrowOleException( hr );
	}
#else
	throw CAtlException( hr );
#endif
};
#endif

// Throw a CAtlException corresponding to the result of ::GetLastError
ATL_NOINLINE __declspec(noreturn) inline void WINAPI AtlThrowLastWin32()
{
	DWORD dwError = ::GetLastError();
	AtlThrow( HRESULT_FROM_WIN32( dwError ) );
}

#else  // no exception handling

// Throw a CAtlException with th given HRESULT
#if !defined( _ATL_CUSTOM_THROW )  // You can define your own AtlThrow

ATL_NOINLINE inline void WINAPI AtlThrowImpl(_In_ HRESULT hr)
{
	ATLTRACE(atlTraceException, 0, _T("AtlThrow: hr = 0x%x\n"), hr );
	ATLASSERT( false );
	DWORD dwExceptionCode;
	switch(hr)
	{
	case E_OUTOFMEMORY:
		dwExceptionCode = STATUS_NO_MEMORY;
		break;
	default:
		dwExceptionCode = EXCEPTION_ILLEGAL_INSTRUCTION;
	}
	_AtlRaiseException((DWORD)dwExceptionCode);
}
#endif

// Throw a CAtlException corresponding to the result of ::GetLastError
ATL_NOINLINE inline void WINAPI AtlThrowLastWin32()
{
	DWORD dwError = ::GetLastError();
	AtlThrow( HRESULT_FROM_WIN32( dwError ) );
}

#endif  // no exception handling

};  // namespace ATL
#pragma pack(pop)

#endif  // __ATLEXCEPT_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\include\atlhandler.h ===
// This is a part of the Active Template Library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Active Template Library Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Active Template Library product.

#ifndef __ATL_HANDLER__
#define __ATL_HANDLER__

#pragma once

#include <filter.h>

#ifndef REFPROPERTYKEY
#include <propkeydef.h>
#endif

#include <atlstr.h>

#ifndef _AFXDLL
// afx.h already defined POSITION type
#ifndef __AFX_H__
#include <atlcoll.h>
#endif //__AFX_H__
#ifndef ATLASSERT
#include <atldef.h>
#endif
#endif

#include <thumbcache.h>

namespace ATL
{

interface IFilterChunkValue
{
protected:
	IFilterChunkValue ()
	{
	}

public:
	virtual ~IFilterChunkValue ()
	{
	}

	virtual void Clear () = 0;
	virtual BOOL IsValid() const = 0;
	virtual HRESULT GetValue(_Deref_out_ PROPVARIANT **ppPropVariant) = 0;
	virtual PROPVARIANT GetValueNoAlloc () = 0;
	virtual CString& GetString() = 0;
	virtual HRESULT CopyChunk(_Inout_ STAT_CHUNK *pStatChunk) = 0;
	virtual CHUNKSTATE GetChunkType() const = 0;
	virtual REFGUID GetChunkGUID() const = 0;
	virtual DWORD GetChunkPID() const = 0;

	// set the property by key to a unicode string
	virtual HRESULT SetTextValue(
		_In_ REFPROPERTYKEY pkey,
		_In_z_ LPCTSTR pszValue,
		_In_ CHUNKSTATE chunkType = CHUNK_VALUE,
		_In_ LCID locale = 0,
		_In_ DWORD cwcLenSource = 0,
		_In_ DWORD cwcStartSource = 0,
		_In_ CHUNK_BREAKTYPE chunkBreakType = CHUNK_NO_BREAK) = 0;

	// set the property by key to a bool
	virtual HRESULT SetBoolValue(
		_In_ REFPROPERTYKEY pkey,
		_In_ BOOL bVal,
		_In_ CHUNKSTATE chunkType = CHUNK_VALUE,
		_In_ LCID locale = 0,
		_In_ DWORD cwcLenSource = 0,
		_In_ DWORD cwcStartSource = 0,
		_In_ CHUNK_BREAKTYPE chunkBreakType = CHUNK_NO_BREAK) = 0;

	// set the property by key to a variant bool
	virtual HRESULT SetBoolValue(
		_In_ REFPROPERTYKEY pkey,
		_In_ VARIANT_BOOL bVal,
		_In_ CHUNKSTATE chunkType = CHUNK_VALUE,
		_In_ LCID locale = 0,
		_In_ DWORD cwcLenSource = 0,
		_In_ DWORD cwcStartSource = 0,
		_In_ CHUNK_BREAKTYPE chunkBreakType = CHUNK_NO_BREAK) = 0;

	// set the property by key to an int
	virtual HRESULT SetIntValue(
		_In_ REFPROPERTYKEY pkey,
		_In_ int nVal,
		_In_ CHUNKSTATE chunkType = CHUNK_VALUE,
		_In_ LCID locale = 0,
		_In_ DWORD cwcLenSource = 0,
		_In_ DWORD cwcStartSource = 0,
		_In_ CHUNK_BREAKTYPE chunkBreakType = CHUNK_NO_BREAK) = 0;

	// set the property by key to a long
	virtual HRESULT SetLongValue(
		_In_ REFPROPERTYKEY pkey,
		_In_ long lVal,
		_In_ CHUNKSTATE chunkType = CHUNK_VALUE,
		_In_ LCID locale = 0,
		_In_ DWORD cwcLenSource = 0,
		_In_ DWORD cwcStartSource = 0,
		_In_ CHUNK_BREAKTYPE chunkBreakType = CHUNK_NO_BREAK) = 0;

	// set the property by key to a dword
	virtual HRESULT SetDwordValue(
		_In_ REFPROPERTYKEY pkey,
		_In_ DWORD dwVal,
		_In_ CHUNKSTATE chunkType = CHUNK_VALUE,
		_In_ LCID locale = 0,
		_In_ DWORD cwcLenSource = 0,
		_In_ DWORD cwcStartSource = 0,
		_In_ CHUNK_BREAKTYPE chunkBreakType = CHUNK_NO_BREAK) = 0;

	// set property by key to an int64
	virtual HRESULT SetInt64Value(
		_In_ REFPROPERTYKEY pkey,
		_In_ __int64 nVal,
		_In_ CHUNKSTATE chunkType = CHUNK_VALUE,
		_In_ LCID locale = 0,
		_In_ DWORD cwcLenSource = 0,
		_In_ DWORD cwcStartSource = 0,
		_In_ CHUNK_BREAKTYPE chunkBreakType = CHUNK_NO_BREAK) = 0;

	// set property by key to a SystemTime
	virtual HRESULT SetSystemTimeValue(
		_In_ REFPROPERTYKEY pkey,
		_In_ const SYSTEMTIME &systemTime,
		_In_ CHUNKSTATE chunkType = CHUNK_VALUE,
		_In_ LCID locale=0,
		_In_ DWORD cwcLenSource=0,
		_In_ DWORD cwcStartSource=0,
		_In_ CHUNK_BREAKTYPE chunkBreakType=CHUNK_NO_BREAK) = 0;

	// set Property by key to a filetime
	virtual HRESULT SetFileTimeValue(
		_In_ REFPROPERTYKEY pkey,
		_In_ FILETIME dtVal,
		_In_ CHUNKSTATE chunkType = CHUNK_VALUE,
		_In_ LCID locale = 0,
		_In_ DWORD cwcLenSource = 0,
		_In_ DWORD cwcStartSource = 0,
		_In_ CHUNK_BREAKTYPE chunkBreakType = CHUNK_NO_BREAK) = 0;

	virtual void CopyFrom (_Inout_ IFilterChunkValue* pValue) = 0;
};

interface IDocument
{
protected:
	IDocument() : m_refCount(0)
	{
	}

public:
	virtual ~IDocument()
	{
	}

	virtual LONG AddRef()
	{
		return InterlockedIncrement(&m_refCount);
	}

	virtual LONG Release()
	{
#ifdef _AFXDLL
		ASSERT(m_refCount > 0);
#else
		ATLASSERT(m_refCount > 0);
#endif
		if (InterlockedDecrement(&m_refCount) == 0)
		{
			delete this;
			return 0;
		}

		return m_refCount;
	}

	virtual HRESULT LoadFromStream(
		_Inout_ IStream* pStream,
		_In_ DWORD grfMode) = 0;
	virtual void InitializeSearchContent() = 0;
	virtual void BeginReadChunks() = 0;

	virtual BOOL GetThumbnail(
		_In_ UINT cx,
		_Out_ HBITMAP* phbmp,
		_Out_ WTS_ALPHATYPE* pdwAlpha) = 0;

	virtual void ClearChunkList() = 0;
	virtual BOOL SetChunkValue(
		_In_ IFilterChunkValue* value) = 0;
	virtual BOOL ReadNextChunkValue(
		_Deref_out_opt_ IFilterChunkValue** value) = 0;
	virtual void RemoveChunk(
		_In_ REFCLSID guid,
		_In_ DWORD pid) = 0;
	virtual POSITION FindChunk(
		_In_ REFCLSID guid,
		_In_ DWORD pid) = 0;

	virtual LPVOID GetContainer() const = 0;

protected:
	volatile LONG m_refCount;
};

#ifdef _MFC_VER
#define IPreviewCtrl CMFCPreviewCtrlImpl
#else
interface IPreviewCtrl
{
protected:
	IPreviewCtrl()
	{
	}

public:
	virtual ~IPreviewCtrl()
	{
	}

	void SetDocument(_In_ IDocument* pDocument)
	{
		m_pDocument = pDocument;
	}

	IDocument* GetDocument()
	{
		return m_pDocument;
	}

	virtual BOOL Create(
		_In_ HWND hWndParent,
		_In_ const RECT* prc) = 0;
	virtual void Destroy() = 0;
	virtual void SetHost(_In_ HWND hWndParent) = 0;
	virtual void Focus() = 0;
	virtual void Redraw() = 0;
	virtual void SetRect(
		_In_ const RECT* prc,
		_In_ BOOL bRedraw) = 0;
	virtual void SetPreviewVisuals(
		_In_ COLORREF clrBack,
		_In_ COLORREF clrText,
		_In_ const LOGFONTW *plf) = 0;

protected:
	IDocument* m_pDocument;
};
#endif

} //namespace ATL
#endif // __ATL_HANDLER__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\include\atlevent.h ===
// This is a part of the Active Template Library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Active Template Library Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Active Template Library product.

#ifndef __ATLEVENT_H__
#define __ATLEVENT_H__

#define __ATLEVENT_VER 3

#pragma once

#ifndef __cplusplus
		#error ATL requires C++ compilation (use a .cpp suffix)
#endif

#if _WIN32_WINNT < 0x0403
#error This file requires _WIN32_WINNT to be #defined at least to 0x0403. Value 0x0501 or higher is recommended.
#endif

struct __EventingCriticalSectionStub 
{
   void Lock()
   {
   }
   void Unlock()
   {
   }
};

struct __EventingCriticalSectionAuto 
{
private:
	void EmitError(_In_ DWORD dwLastError)
	{
		static const int nMax = 256;
		TCHAR pszMessage[nMax];

		if (!FormatMessage(FORMAT_MESSAGE_FROM_SYSTEM, NULL, dwLastError,
				MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),(LPTSTR)&pszMessage, nMax, NULL)) {

			static const TCHAR szDefaultMessage[] = _T("cannot initialize critical section");

			::ATL::Checked::tcscpy_s(pszMessage, _countof(pszMessage), szDefaultMessage);
		}

		MessageBox(0, pszMessage, 0, MB_OK | MB_ICONHAND);
	}
public:
	void Lock()
	{
		EnterCriticalSection(&m_sec);
	}
	void Unlock()
	{
		LeaveCriticalSection(&m_sec);
	}
	__EventingCriticalSectionAuto()
	{
		if (!InitializeCriticalSectionAndSpinCount(&m_sec, 0)) {
			EmitError(GetLastError());
		}
	}
	~__EventingCriticalSectionAuto()
	{
		DeleteCriticalSection(&m_sec);
	}
	CRITICAL_SECTION m_sec;
};

template <class T>
struct __eventingGetAddr 
{
	typedef void (T::*pmfn_type) ();
	typedef void (*pgfn_type) ();
	union U {
		void *addr;
		void (T::*pmfn)();
		void (*pgfn)();
	};
	static pmfn_type __getMAddr(_In_ void *addr)
	{
		U u;
		u.addr = addr;
		return u.pmfn;
	}
	static void* __getVAddr(_In_ pmfn_type pmfn)
	{
		U u;
		u.pmfn = pmfn;
		return u.addr;
	}
	static pgfn_type __getSMAddr(_In_ void *addr)
	{
		U u;
		u.addr = addr;
		return u.pgfn;
	}
	static void* __getSVAddr(_In_ pgfn_type pgfn)
	{
		U u;
		u.pgfn = pgfn;
		return u.addr;
	}
};

struct __eventNode 
{
	virtual int __isEqual(
		_In_ void*,
		_In_ void*) = 0;
	virtual int __isEqual(_In_ void*) = 0;
	__eventNode* next;
};

struct __eventMainNode 
{
	int key;
	__eventNode* root_node;
	__eventMainNode* next_event;
};


//
// pvargSrc should only contain the memory for a VARIANT
//
inline HRESULT WINAPI __VariantChangeType(
	_Inout_ VARIANTARG*& pvargDest,
	_In_ VARIANTARG* pvargSrc,
	_In_ VARTYPE vt)
{
	ATLASSERT(pvargDest != 0 && pvargSrc != 0);
	if( pvargDest == 0 || pvargSrc == 0 )
		return E_INVALIDARG;
	ATLTRACE(_T("ATLEVENT: __VariantChangeType(pvargDest->vt=%d,vt=%d)\n"), pvargDest->vt, vt);

	::VariantInit(pvargSrc);
	HRESULT hr = ::VariantChangeType(pvargSrc, pvargDest, 0, vt);
	if (FAILED(hr)) {
		if (hr == DISP_E_TYPEMISMATCH && (vt & VT_ARRAY) != 0 && (pvargDest->vt & ~VT_BYREF) == (VT_ARRAY | VT_VARIANT)) {
			return S_OK; // you're on your own
		}
	} else {
		::VariantClear(pvargDest);
		*pvargDest = *pvargSrc;
	}
	return hr;
}

HRESULT WINAPI _com_handle_excepinfo(
	_In_ EXCEPINFO& excepInfo,
	_Deref_out_ IErrorInfo** pperrinfo);

#pragma pack(push,_ATL_PACKING)
namespace ATL {

    inline HRESULT AtlExcepInfoFromErrorInfo(
		_In_ HRESULT hrInvoke,
		_Inout_ EXCEPINFO *pExcepInfo)
    {
        if (pExcepInfo == NULL)
        {
            return E_POINTER;
        }
        pExcepInfo->pfnDeferredFillIn = NULL;
        pExcepInfo->scode = hrInvoke;
        CComPtr<IErrorInfo> spErrInfo;
        HRESULT hr = GetErrorInfo(0, &spErrInfo);
        if (hr == S_OK)
        {
            // Set up ErrInfo object
            // Ignore any errors. If additional error information is not
            // available then corresponding pointer will be NULL or 0
            spErrInfo->GetSource(&pExcepInfo->bstrSource);
            spErrInfo->GetDescription(&pExcepInfo->bstrDescription);
            spErrInfo->GetHelpFile(&pExcepInfo->bstrHelpFile);
            spErrInfo->GetHelpContext(&pExcepInfo->dwHelpContext);
        }
        return hr;
    }

	inline HRESULT __ComInvokeEventHandler(
		_Inout_ IDispatch* pDispatch,
		_In_ DISPID id,
		_In_ WORD wFlags,
		_In_ DISPPARAMS *pDispParams,
		_Out_opt_ VARIANT *pVarResult)
	{
		if (pVarResult != 0) {
			::VariantInit(pVarResult);
		}
		EXCEPINFO excepInfo;
		memset(&excepInfo, 0, sizeof excepInfo);
		UINT nArgErr = (UINT)-1;
		HRESULT hr = pDispatch->Invoke(id, IID_NULL, LOCALE_USER_DEFAULT, wFlags, pDispParams, pVarResult, &excepInfo, &nArgErr);
		if (FAILED(hr)) {
			IErrorInfo* perrinfo = 0;
			if (SUCCEEDED(_com_handle_excepinfo(excepInfo, &perrinfo)))
			{
				SetErrorInfo(0, perrinfo);
				perrinfo->Release();
			}
		}
		return hr;
	}

	struct __EventHandlerProxy 
	{
		virtual HRESULT CDECL __eventHandlerProxy(_In_ int idx, ...) = 0;
	};
	struct __EventHandlerNodeProxy 
	{
		virtual int __Index(_In_ int i) = 0;
	};
	template <typename T /*super*/>
	class __ComEventingImpl : 
		public __EventHandlerProxy 
	{
		enum { __InvalidIndex = -1 };
		struct __ComEventingNode : __EventHandlerNodeProxy {
			__ComEventingNode(
				_In_opt_ T* pThis = 0,
				_In_opt_ IUnknown* pSource = 0,
				_In_opt_ IUnknown* pSink = 0,
				_In_opt_ const _GUID* pGuid = 0,
				_In_ int nSize = 0)
			{
				__pThis = pThis;
				__nHooks = 0;
				__dwAdvise = 0;
				__pSource = pSource;
				__pSink = pSink;
				__pNext = 0;
				__pGuid = const_cast<_GUID*> (pGuid);
				__nArraySize = nSize;
				__proxyIndex = NULL;
				__proxyIndex = new int[__nArraySize];
				memset(__proxyIndex, 0xff, __nArraySize*sizeof(int));
			}
			int __Index(_In_ int i) {
				return __proxyIndex[i];
			}
			T* __pThis;
			int *__proxyIndex;
			int __nArraySize;
			int __nHooks;
			unsigned long __dwAdvise;
			CComPtr<IUnknown> __pSource;
			IUnknown* __pSink;
			_GUID* __pGuid;
			__ComEventingNode* __pNext;
		};
		__ComEventingNode* __pFirst;
		__ComEventingNode* __pLast;
		__ComEventingNode* __pCurrent;
	public:
		__ComEventingImpl() {
			__pCurrent = __pFirst = __pLast = 0;
		}
		~__ComEventingImpl() {
			if (__pFirst != 0) {
				__pCurrent = __pFirst;
				while (__pCurrent != 0) {
					__pCurrent->__pSink->Release();
					delete [] __pCurrent->__proxyIndex;
					__pFirst = __pCurrent;
					__pCurrent = __pCurrent->__pNext;
					delete __pFirst;
				}
			}
		}
		template <typename U /*interface*/>
		HRESULT __WhichThis(
			_In_ IUnknown* pS,
			_In_ T* pThis,
			_In_ int nSize,
			_In_ bool bNext,
			_In_ int idx)
		{
			if (bNext) {
				 if (__pCurrent != 0) {
					 __pCurrent = __pCurrent->__pNext;
				 }
			} else {
				__pCurrent = __pFirst;
			}
			if (__pCurrent == 0
				|| !__pCurrent->__pSource.IsEqualObject(pS)
				|| __pCurrent->__pThis != pThis
				|| !IsEqualGUID(*U::Guid(), *__pCurrent->__pGuid)) {
				if (__pCurrent != 0) {
					__ComEventingNode* pTheOne = 0;
					while ((__pCurrent = __pCurrent->__pNext) != 0) {
						if (__pCurrent->__pSource.IsEqualObject(pS)
							&& (__pCurrent->__pThis == pThis)
							&& IsEqualGUID(*U::Guid(), *__pCurrent->__pGuid)) {
							if (nSize > 0 || __pCurrent->__proxyIndex[idx] != __InvalidIndex) {
								pTheOne = __pCurrent;
								if (nSize > 0) {
									break;
								}
							}
						 }
					 }
					 if (pTheOne != 0) {
						 __pCurrent = pTheOne;
						 return S_OK;
					 }
				}
				if (nSize > 0) {
					CComObject<U>* pSink;
					HRESULT hr = CComObject<U>::CreateInstance(&pSink);
					if (FAILED(hr)) {
						return hr;
					}
					pSink->AddRef();
					pSink->__pThis = pThis;
					ATLTRY( pSink->__pThat = __pCurrent = new __ComEventingNode(pThis, pS, pSink, U::Guid(), nSize) );
					if( pSink->__pThat == NULL )
						return E_OUTOFMEMORY;
					if (__pLast != 0) {
						__pLast->__pNext = __pCurrent;
					} else {
						__pFirst = __pCurrent;
					}
					__pLast = __pCurrent;
				}
			}
			return S_OK;
		}
		template <typename U /*interface*/>
		HRESULT __AddHandler(
			_In_ T* pThis,
			_In_ int idxSink,
			_Inout_ IUnknown* pS,
			_In_ int idx,
			_In_ int nSize)
		{
			if (pS == 0 || pThis == 0) {
				return E_FAIL;
			}
			bool bNext = false;
			bool bDone = false;
			while (!bDone) {
				HRESULT hr = __WhichThis<U>(pS, pThis, nSize, bNext, idx);
				if (SUCCEEDED(hr)) {
					if (__pCurrent->__proxyIndex[idx] == __InvalidIndex) {
						__pCurrent->__proxyIndex[idx] = idxSink;
						++__pCurrent->__nHooks;
						__pCurrent->__pThis = pThis;
						bDone = true;
					}
					if (__pCurrent->__dwAdvise == 0) {
						return AtlAdvise(pS, __pCurrent->__pSink, *U::Guid(), &__pCurrent->__dwAdvise);
					}
					bNext = true;
				} else {
					return hr;
				}
			}
			return S_OK;
		}
		template <typename U /*interface*/>
		HRESULT __RemoveHandler(
			_In_ T* pThis,
			_In_ IUnknown* pS,
			_In_ int idx)
		{
			bool bNext = false;
			bool bDone = false;
			while (!bDone) {
				__WhichThis<U>(pS, pThis, 0, bNext, idx);
				if (__pCurrent == 0) {
					return E_FAIL;
				}
				if (__pCurrent->__proxyIndex[idx] != __InvalidIndex) {
					__pCurrent->__proxyIndex[idx] = __InvalidIndex;
					--__pCurrent->__nHooks;
					bDone = true;
				}
				if (__pCurrent->__dwAdvise != 0 && __pCurrent->__nHooks == 0) {
					HRESULT hr = AtlUnadvise(pS, *U::Guid(), __pCurrent->__dwAdvise);
					if (SUCCEEDED(hr)) {
						__pCurrent->__pSource.Release();
						__pCurrent->__dwAdvise = 0;
					}
					return hr;
				}
				bNext = true;
			}
			return S_OK;
		}
		HRESULT __RemoveAllHandlers(
			_In_opt_ IUnknown* pS,
			_In_opt_ const _GUID* pIID)
		{
			HRESULT hr = E_FAIL;
			__pCurrent = __pFirst;
			while (1) {
				if (__pCurrent == 0) {
					return hr;
				} else if ((pS == 0 || __pCurrent->__pSource.IsEqualObject(pS)
					&& (pIID == 0 || IsEqualGUID(*pIID, *__pCurrent->__pGuid)))
					&& __pCurrent->__dwAdvise != 0) {
					hr = AtlUnadvise(__pCurrent->__pSource, *__pCurrent->__pGuid, __pCurrent->__dwAdvise);
					if (SUCCEEDED(hr)) {
						__pCurrent->__pSource.Release();
						__pCurrent->__dwAdvise = 0;
						memset(__pCurrent->__proxyIndex, 0xff, __pCurrent->__nArraySize*sizeof(int));
						__pCurrent->__nHooks = 0;
					}
				}
				__pCurrent = __pCurrent->__pNext;
			}
		}
	};

	class __ComEventingImpl_LD {
		struct __EventCookieNode {
			__EventCookieNode(
				_In_opt_ IUnknown* pS = 0,
				_In_opt_ const _GUID* pG = 0)
			{
				__nextCookie = 0;
				__dwAdvise = 0;
				__pSource = pS;
				__pGuid = const_cast<_GUID*> (pG);
			}
			__EventCookieNode* __nextCookie;
			unsigned long __dwAdvise;
			CComPtr<IUnknown> __pSource;
			_GUID* __pGuid;
		} *__EventCookies;
	public:
		HRESULT __Advise(
			_Inout_ IUnknown* pSrc,
			_Inout_opt_ IUnknown* pSink,
			_In_ const IID& iid)
		{
			__EventCookieNode* pRoot = __EventCookies;
			while (pRoot != 0) {
				if (pRoot->__pSource.IsEqualObject(pSrc)
					&& IsEqualGUID(iid, *pRoot->__pGuid)
					&& pRoot->__dwAdvise == 0) {
					break;
				}
				pRoot = pRoot->__nextCookie;
			}
			if (pRoot == 0) {
				ATLTRY( pRoot = new __EventCookieNode(pSrc, &iid) );
				if( pRoot == NULL )
					return E_OUTOFMEMORY;
				pRoot->__nextCookie = __EventCookies;
				__EventCookies = pRoot;
			}
			return AtlAdvise(pSrc, pSink, iid, &pRoot->__dwAdvise);
		}
		HRESULT __Unadvise(
			_Inout_ IUnknown* pSrc,
			_In_ const IID& iid)
		{
			__EventCookieNode* pRoot = __EventCookies;
			__EventCookieNode* pTheOne = 0;
			while (pRoot != 0) {
				if (pRoot->__pSource.IsEqualObject(pSrc)
					&& IsEqualGUID(iid, *pRoot->__pGuid)
					&& pRoot->__dwAdvise != 0) {
					pTheOne = pRoot;
				}
				pRoot = pRoot->__nextCookie;
			}
			HRESULT hr = E_FAIL;
			if (pTheOne != 0) {
				hr = AtlUnadvise(pSrc, iid, pTheOne->__dwAdvise);
				if (SUCCEEDED(hr)) {
					pTheOne->__pSource.Release();
					pTheOne->__dwAdvise = 0;
				}
			}
			return hr;
		}
		__ComEventingImpl_LD() {
			__EventCookies = 0;
		}
		~__ComEventingImpl_LD() {
			while (__EventCookies != 0) {
				__EventCookieNode* pDead = __EventCookies;
				__EventCookies = __EventCookies->__nextCookie;
				delete pDead;
			}
		}
	};
}

#pragma pack(pop)
#endif // __ATLEVENT_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\include\atliface.h ===
// This is a part of the Active Template Library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Active Template Library Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Active Template Library product.

#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 6.00.0342 */
/* at Mon Feb 12 21:31:09 2001
 */
/* Compiler settings for atliface.idl:
	Oicf, W1, Zp8, env=Win32 (32b run)
	protocol : dce , ms_ext, c_ext
	error checks: allocation ref bounds_check enum stub_data 
	VC __declspec() decoration level: 
		 __declspec(uuid()), __declspec(selectany), __declspec(novtable)
		 DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 440
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __atliface_h__
#define __atliface_h__

#pragma once

/* Forward Declarations */ 

#ifndef __IRegistrarBase_FWD_DEFINED__
#define __IRegistrarBase_FWD_DEFINED__
typedef interface IRegistrarBase IRegistrarBase;
#endif 	/* __IRegistrarBase_FWD_DEFINED__ */


#ifndef __IRegistrar_FWD_DEFINED__
#define __IRegistrar_FWD_DEFINED__
typedef interface IRegistrar IRegistrar;
#endif 	/* __IRegistrar_FWD_DEFINED__ */


#ifndef __IDocHostUIHandlerDispatch_FWD_DEFINED__
#define __IDocHostUIHandlerDispatch_FWD_DEFINED__
typedef interface IDocHostUIHandlerDispatch IDocHostUIHandlerDispatch;
#endif 	/* __IDocHostUIHandlerDispatch_FWD_DEFINED__ */


#ifndef __IAxWinHostWindow_FWD_DEFINED__
#define __IAxWinHostWindow_FWD_DEFINED__
typedef interface IAxWinHostWindow IAxWinHostWindow;
#endif 	/* __IAxWinHostWindow_FWD_DEFINED__ */


#ifndef __IAxWinHostWindowLic_FWD_DEFINED__
#define __IAxWinHostWindowLic_FWD_DEFINED__
typedef interface IAxWinHostWindowLic IAxWinHostWindowLic;
#endif 	/* __IAxWinHostWindowLic_FWD_DEFINED__ */


#ifndef __IAxWinAmbientDispatch_FWD_DEFINED__
#define __IAxWinAmbientDispatch_FWD_DEFINED__
typedef interface IAxWinAmbientDispatch IAxWinAmbientDispatch;
#endif 	/* __IAxWinAmbientDispatch_FWD_DEFINED__ */


#ifndef __IAxWinAmbientDispatchEx_FWD_DEFINED__
#define __IAxWinAmbientDispatchEx_FWD_DEFINED__
typedef interface IAxWinAmbientDispatchEx IAxWinAmbientDispatchEx;
#endif 	/* __IAxWinAmbientDispatchEx_FWD_DEFINED__ */


#ifndef __IInternalConnection_FWD_DEFINED__
#define __IInternalConnection_FWD_DEFINED__
typedef interface IInternalConnection IInternalConnection;
#endif 	/* __IInternalConnection_FWD_DEFINED__ */


#ifndef __IAccessibleProxy_FWD_DEFINED__
#define __IAccessibleProxy_FWD_DEFINED__
typedef interface IAccessibleProxy IAccessibleProxy;
#endif 	/* __IAccessibleProxy_FWD_DEFINED__ */


#ifndef __IAccessibleServer_FWD_DEFINED__
#define __IAccessibleServer_FWD_DEFINED__
typedef interface IAccessibleServer IAccessibleServer;
#endif 	/* __IAccessibleServer_FWD_DEFINED__ */


/* header files for imported files */
#include "oaidl.h"
#include "ocidl.h"
#include "oleacc.h"

#ifdef __cplusplus
extern "C"{
#endif 

void * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void * ); 

/* interface __MIDL_itf_atliface_0000 */
/* [local] */ 

EXTERN_C const CLSID CLSID_Registrar;


extern RPC_IF_HANDLE __MIDL_itf_atliface_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_atliface_0000_v0_0_s_ifspec;

#ifndef __IRegistrarBase_INTERFACE_DEFINED__
#define __IRegistrarBase_INTERFACE_DEFINED__

/* interface IRegistrarBase */
/* [unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IRegistrarBase;

#if defined(__cplusplus) && !defined(CINTERFACE)

	MIDL_INTERFACE("e21f8a85-b05d-4243-8183-c7cb405588f7")
	IRegistrarBase : public IUnknown
	{
	public:
		virtual HRESULT STDMETHODCALLTYPE AddReplacement( 
			/* [in] */ LPCOLESTR key,
			/* [in] */ LPCOLESTR item) = 0;

		virtual HRESULT STDMETHODCALLTYPE ClearReplacements( void) = 0;

	};

#else 	/* C style interface */

	typedef struct IRegistrarBaseVtbl
	{
		BEGIN_INTERFACE

		HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
			IRegistrarBase * This,
			/* [in] */ REFIID riid,
			/* [iid_is][out] */ void **ppvObject);

		ULONG ( STDMETHODCALLTYPE *AddRef )( 
			IRegistrarBase * This);

		ULONG ( STDMETHODCALLTYPE *Release )( 
			IRegistrarBase * This);

		HRESULT ( STDMETHODCALLTYPE *AddReplacement )( 
			IRegistrarBase * This,
			/* [in] */ LPCOLESTR key,
			/* [in] */ LPCOLESTR item);

		HRESULT ( STDMETHODCALLTYPE *ClearReplacements )( 
			IRegistrarBase * This);

		END_INTERFACE
	} IRegistrarBaseVtbl;

	interface IRegistrarBase
	{
		CONST_VTBL struct IRegistrarBaseVtbl *lpVtbl;
	};



#ifdef COBJMACROS


#define IRegistrarBase_QueryInterface(This,riid,ppvObject)	\
	(This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IRegistrarBase_AddRef(This)	\
	(This)->lpVtbl -> AddRef(This)

#define IRegistrarBase_Release(This)	\
	(This)->lpVtbl -> Release(This)


#define IRegistrarBase_AddReplacement(This,key,item)	\
	(This)->lpVtbl -> AddReplacement(This,key,item)

#define IRegistrarBase_ClearReplacements(This)	\
	(This)->lpVtbl -> ClearReplacements(This)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IRegistrarBase_AddReplacement_Proxy( 
	IRegistrarBase * This,
	/* [in] */ LPCOLESTR key,
	/* [in] */ LPCOLESTR item);


void __RPC_STUB IRegistrarBase_AddReplacement_Stub(
	IRpcStubBuffer *This,
	IRpcChannelBuffer *_pRpcChannelBuffer,
	PRPC_MESSAGE _pRpcMessage,
	DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IRegistrarBase_ClearReplacements_Proxy( 
	IRegistrarBase * This);


void __RPC_STUB IRegistrarBase_ClearReplacements_Stub(
	IRpcStubBuffer *This,
	IRpcChannelBuffer *_pRpcChannelBuffer,
	PRPC_MESSAGE _pRpcMessage,
	DWORD *_pdwStubPhase);



#endif 	/* __IRegistrarBase_INTERFACE_DEFINED__ */


#ifndef __IRegistrar_INTERFACE_DEFINED__
#define __IRegistrar_INTERFACE_DEFINED__

/* interface IRegistrar */
/* [unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IRegistrar;

#if defined(__cplusplus) && !defined(CINTERFACE)

	MIDL_INTERFACE("44EC053B-400F-11D0-9DCD-00A0C90391D3")
	IRegistrar : public IRegistrarBase
	{
	public:
		virtual HRESULT STDMETHODCALLTYPE ResourceRegisterSz( 
			/* [in] */ LPCOLESTR resFileName,
			/* [in] */ LPCOLESTR szID,
			/* [in] */ LPCOLESTR szType) = 0;

		virtual HRESULT STDMETHODCALLTYPE ResourceUnregisterSz( 
			/* [in] */ LPCOLESTR resFileName,
			/* [in] */ LPCOLESTR szID,
			/* [in] */ LPCOLESTR szType) = 0;

		virtual HRESULT STDMETHODCALLTYPE FileRegister( 
			/* [in] */ LPCOLESTR fileName) = 0;

		virtual HRESULT STDMETHODCALLTYPE FileUnregister( 
			/* [in] */ LPCOLESTR fileName) = 0;

		virtual HRESULT STDMETHODCALLTYPE StringRegister( 
			/* [in] */ LPCOLESTR data) = 0;

		virtual HRESULT STDMETHODCALLTYPE StringUnregister( 
			/* [in] */ LPCOLESTR data) = 0;

		virtual HRESULT STDMETHODCALLTYPE ResourceRegister( 
			/* [in] */ LPCOLESTR resFileName,
			/* [in] */ UINT nID,
			/* [in] */ LPCOLESTR szType) = 0;

		virtual HRESULT STDMETHODCALLTYPE ResourceUnregister( 
			/* [in] */ LPCOLESTR resFileName,
			/* [in] */ UINT nID,
			/* [in] */ LPCOLESTR szType) = 0;

	};

#else 	/* C style interface */

	typedef struct IRegistrarVtbl
	{
		BEGIN_INTERFACE

		HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
			IRegistrar * This,
			/* [in] */ REFIID riid,
			/* [iid_is][out] */ void **ppvObject);

		ULONG ( STDMETHODCALLTYPE *AddRef )( 
			IRegistrar * This);

		ULONG ( STDMETHODCALLTYPE *Release )( 
			IRegistrar * This);

		HRESULT ( STDMETHODCALLTYPE *AddReplacement )( 
			IRegistrar * This,
			/* [in] */ LPCOLESTR key,
			/* [in] */ LPCOLESTR item);

		HRESULT ( STDMETHODCALLTYPE *ClearReplacements )( 
			IRegistrar * This);

		HRESULT ( STDMETHODCALLTYPE *ResourceRegisterSz )( 
			IRegistrar * This,
			/* [in] */ LPCOLESTR resFileName,
			/* [in] */ LPCOLESTR szID,
			/* [in] */ LPCOLESTR szType);

		HRESULT ( STDMETHODCALLTYPE *ResourceUnregisterSz )( 
			IRegistrar * This,
			/* [in] */ LPCOLESTR resFileName,
			/* [in] */ LPCOLESTR szID,
			/* [in] */ LPCOLESTR szType);

		HRESULT ( STDMETHODCALLTYPE *FileRegister )( 
			IRegistrar * This,
			/* [in] */ LPCOLESTR fileName);

		HRESULT ( STDMETHODCALLTYPE *FileUnregister )( 
			IRegistrar * This,
			/* [in] */ LPCOLESTR fileName);

		HRESULT ( STDMETHODCALLTYPE *StringRegister )( 
			IRegistrar * This,
			/* [in] */ LPCOLESTR data);

		HRESULT ( STDMETHODCALLTYPE *StringUnregister )( 
			IRegistrar * This,
			/* [in] */ LPCOLESTR data);

		HRESULT ( STDMETHODCALLTYPE *ResourceRegister )( 
			IRegistrar * This,
			/* [in] */ LPCOLESTR resFileName,
			/* [in] */ UINT nID,
			/* [in] */ LPCOLESTR szType);

		HRESULT ( STDMETHODCALLTYPE *ResourceUnregister )( 
			IRegistrar * This,
			/* [in] */ LPCOLESTR resFileName,
			/* [in] */ UINT nID,
			/* [in] */ LPCOLESTR szType);

		END_INTERFACE
	} IRegistrarVtbl;

	interface IRegistrar
	{
		CONST_VTBL struct IRegistrarVtbl *lpVtbl;
	};



#ifdef COBJMACROS


#define IRegistrar_QueryInterface(This,riid,ppvObject)	\
	(This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IRegistrar_AddRef(This)	\
	(This)->lpVtbl -> AddRef(This)

#define IRegistrar_Release(This)	\
	(This)->lpVtbl -> Release(This)


#define IRegistrar_AddReplacement(This,key,item)	\
	(This)->lpVtbl -> AddReplacement(This,key,item)

#define IRegistrar_ClearReplacements(This)	\
	(This)->lpVtbl -> ClearReplacements(This)


#define IRegistrar_ResourceRegisterSz(This,resFileName,szID,szType)	\
	(This)->lpVtbl -> ResourceRegisterSz(This,resFileName,szID,szType)

#define IRegistrar_ResourceUnregisterSz(This,resFileName,szID,szType)	\
	(This)->lpVtbl -> ResourceUnregisterSz(This,resFileName,szID,szType)

#define IRegistrar_FileRegister(This,fileName)	\
	(This)->lpVtbl -> FileRegister(This,fileName)

#define IRegistrar_FileUnregister(This,fileName)	\
	(This)->lpVtbl -> FileUnregister(This,fileName)

#define IRegistrar_StringRegister(This,data)	\
	(This)->lpVtbl -> StringRegister(This,data)

#define IRegistrar_StringUnregister(This,data)	\
	(This)->lpVtbl -> StringUnregister(This,data)

#define IRegistrar_ResourceRegister(This,resFileName,nID,szType)	\
	(This)->lpVtbl -> ResourceRegister(This,resFileName,nID,szType)

#define IRegistrar_ResourceUnregister(This,resFileName,nID,szType)	\
	(This)->lpVtbl -> ResourceUnregister(This,resFileName,nID,szType)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IRegistrar_ResourceRegisterSz_Proxy( 
	IRegistrar * This,
	/* [in] */ LPCOLESTR resFileName,
	/* [in] */ LPCOLESTR szID,
	/* [in] */ LPCOLESTR szType);


void __RPC_STUB IRegistrar_ResourceRegisterSz_Stub(
	IRpcStubBuffer *This,
	IRpcChannelBuffer *_pRpcChannelBuffer,
	PRPC_MESSAGE _pRpcMessage,
	DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IRegistrar_ResourceUnregisterSz_Proxy( 
	IRegistrar * This,
	/* [in] */ LPCOLESTR resFileName,
	/* [in] */ LPCOLESTR szID,
	/* [in] */ LPCOLESTR szType);


void __RPC_STUB IRegistrar_ResourceUnregisterSz_Stub(
	IRpcStubBuffer *This,
	IRpcChannelBuffer *_pRpcChannelBuffer,
	PRPC_MESSAGE _pRpcMessage,
	DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IRegistrar_FileRegister_Proxy( 
	IRegistrar * This,
	/* [in] */ LPCOLESTR fileName);


void __RPC_STUB IRegistrar_FileRegister_Stub(
	IRpcStubBuffer *This,
	IRpcChannelBuffer *_pRpcChannelBuffer,
	PRPC_MESSAGE _pRpcMessage,
	DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IRegistrar_FileUnregister_Proxy( 
	IRegistrar * This,
	/* [in] */ LPCOLESTR fileName);


void __RPC_STUB IRegistrar_FileUnregister_Stub(
	IRpcStubBuffer *This,
	IRpcChannelBuffer *_pRpcChannelBuffer,
	PRPC_MESSAGE _pRpcMessage,
	DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IRegistrar_StringRegister_Proxy( 
	IRegistrar * This,
	/* [in] */ LPCOLESTR data);


void __RPC_STUB IRegistrar_StringRegister_Stub(
	IRpcStubBuffer *This,
	IRpcChannelBuffer *_pRpcChannelBuffer,
	PRPC_MESSAGE _pRpcMessage,
	DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IRegistrar_StringUnregister_Proxy( 
	IRegistrar * This,
	/* [in] */ LPCOLESTR data);


void __RPC_STUB IRegistrar_StringUnregister_Stub(
	IRpcStubBuffer *This,
	IRpcChannelBuffer *_pRpcChannelBuffer,
	PRPC_MESSAGE _pRpcMessage,
	DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IRegistrar_ResourceRegister_Proxy( 
	IRegistrar * This,
	/* [in] */ LPCOLESTR resFileName,
	/* [in] */ UINT nID,
	/* [in] */ LPCOLESTR szType);


void __RPC_STUB IRegistrar_ResourceRegister_Stub(
	IRpcStubBuffer *This,
	IRpcChannelBuffer *_pRpcChannelBuffer,
	PRPC_MESSAGE _pRpcMessage,
	DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IRegistrar_ResourceUnregister_Proxy( 
	IRegistrar * This,
	/* [in] */ LPCOLESTR resFileName,
	/* [in] */ UINT nID,
	/* [in] */ LPCOLESTR szType);


void __RPC_STUB IRegistrar_ResourceUnregister_Stub(
	IRpcStubBuffer *This,
	IRpcChannelBuffer *_pRpcChannelBuffer,
	PRPC_MESSAGE _pRpcMessage,
	DWORD *_pdwStubPhase);



#endif 	/* __IRegistrar_INTERFACE_DEFINED__ */


#ifndef __IDocHostUIHandlerDispatch_INTERFACE_DEFINED__
#define __IDocHostUIHandlerDispatch_INTERFACE_DEFINED__

/* interface IDocHostUIHandlerDispatch */
/* [object][unique][helpstring][uuid][local] */ 

typedef 
enum tagDOCHOSTUIDBLCLKDispatch
	{	docHostUIDblClkDEFAULT	= 0,
	docHostUIDblClkSHOWPROPERTIES	= 1,
	docHostUIDblClkSHOWCODE	= 2
	} 	DOCHOSTUIDBLCLKDispatch;

typedef 
enum tagDocHostUIFlagDispatch
	{	docHostUIFlagDIALOG	= 1,
	docHostUIFlagDISABLE_HELP_MENU	= 2,
	docHostUIFlagNO3DBORDER	= 4,
	docHostUIFlagSCROLL_NO	= 8,
	docHostUIFlagDISABLE_SCRIPT_INACTIVE	= 16,
	docHostUIFlagOPENNEWWIN	= 32,
	docHostUIFlagDISABLE_OFFSCREEN	= 64,
	docHostUIFlagFLAT_SCROLLBAR	= 128,
	docHostUIFlagDIV_BLOCKDEFAULT	= 256,
	docHostUIFlagACTIVATE_CLIENTHIT_ONLY	= 512
	} 	DocHostUIFlagDispatch;


EXTERN_C const IID IID_IDocHostUIHandlerDispatch;

#if defined(__cplusplus) && !defined(CINTERFACE)

	MIDL_INTERFACE("425B5AF0-65F1-11d1-9611-0000F81E0D0D")
	IDocHostUIHandlerDispatch : public IDispatch
	{
	public:
		virtual HRESULT STDMETHODCALLTYPE ShowContextMenu( 
			/* [in] */ DWORD dwID,
			/* [in] */ DWORD x,
			/* [in] */ DWORD y,
			/* [in] */ IUnknown *pcmdtReserved,
			/* [in] */ IDispatch *pdispReserved,
			/* [retval][out] */ HRESULT *dwRetVal) = 0;

		virtual HRESULT STDMETHODCALLTYPE GetHostInfo( 
			/* [out][in] */ DWORD *pdwFlags,
			/* [out][in] */ DWORD *pdwDoubleClick) = 0;

		virtual HRESULT STDMETHODCALLTYPE ShowUI( 
			/* [in] */ DWORD dwID,
			/* [in] */ IUnknown *pActiveObject,
			/* [in] */ IUnknown *pCommandTarget,
			/* [in] */ IUnknown *pFrame,
			/* [in] */ IUnknown *pDoc,
			/* [retval][out] */ HRESULT *dwRetVal) = 0;

		virtual HRESULT STDMETHODCALLTYPE HideUI( void) = 0;

		virtual HRESULT STDMETHODCALLTYPE UpdateUI( void) = 0;

		virtual HRESULT STDMETHODCALLTYPE EnableModeless( 
			/* [in] */ VARIANT_BOOL fEnable) = 0;

		virtual HRESULT STDMETHODCALLTYPE OnDocWindowActivate( 
			/* [in] */ VARIANT_BOOL fActivate) = 0;

		virtual HRESULT STDMETHODCALLTYPE OnFrameWindowActivate( 
			/* [in] */ VARIANT_BOOL fActivate) = 0;

		virtual HRESULT STDMETHODCALLTYPE ResizeBorder( 
			/* [in] */ long left,
			/* [in] */ long top,
			/* [in] */ long right,
			/* [in] */ long bottom,
			/* [in] */ IUnknown *pUIWindow,
			/* [in] */ VARIANT_BOOL fFrameWindow) = 0;

		virtual HRESULT STDMETHODCALLTYPE TranslateAccelerator( 
			/* [in] */ DWORD_PTR hWnd,
			/* [in] */ DWORD nMessage,
			/* [in] */ DWORD_PTR wParam,
			/* [in] */ DWORD_PTR lParam,
			/* [in] */ BSTR bstrGuidCmdGroup,
			/* [in] */ DWORD nCmdID,
			/* [retval][out] */ HRESULT *dwRetVal) = 0;

		virtual HRESULT STDMETHODCALLTYPE GetOptionKeyPath( 
			/* [out] */ BSTR *pbstrKey,
			/* [in] */ DWORD dw) = 0;

		virtual HRESULT STDMETHODCALLTYPE GetDropTarget( 
			/* [in] */ IUnknown *pDropTarget,
			/* [out] */ IUnknown **ppDropTarget) = 0;

		virtual HRESULT STDMETHODCALLTYPE GetExternal( 
			/* [out] */ IDispatch **ppDispatch) = 0;

		virtual HRESULT STDMETHODCALLTYPE TranslateUrl( 
			/* [in] */ DWORD dwTranslate,
			/* [in] */ BSTR bstrURLIn,
			/* [out] */ BSTR *pbstrURLOut) = 0;

		virtual HRESULT STDMETHODCALLTYPE FilterDataObject( 
			/* [in] */ IUnknown *pDO,
			/* [out] */ IUnknown **ppDORet) = 0;

	};

#else 	/* C style interface */

	typedef struct IDocHostUIHandlerDispatchVtbl
	{
		BEGIN_INTERFACE

		HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
			IDocHostUIHandlerDispatch * This,
			/* [in] */ REFIID riid,
			/* [iid_is][out] */ void **ppvObject);

		ULONG ( STDMETHODCALLTYPE *AddRef )( 
			IDocHostUIHandlerDispatch * This);

		ULONG ( STDMETHODCALLTYPE *Release )( 
			IDocHostUIHandlerDispatch * This);

		HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
			IDocHostUIHandlerDispatch * This,
			/* [out] */ UINT *pctinfo);

		HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
			IDocHostUIHandlerDispatch * This,
			/* [in] */ UINT iTInfo,
			/* [in] */ LCID lcid,
			/* [out] */ ITypeInfo **ppTInfo);

		HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
			IDocHostUIHandlerDispatch * This,
			/* [in] */ REFIID riid,
			/* [size_is][in] */ _In_count_(cNames) LPOLESTR *rgszNames,
			/* [in] */ UINT cNames,
			/* [in] */ LCID lcid,
			/* [size_is][out] */ DISPID *rgDispId);

		/* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
			IDocHostUIHandlerDispatch * This,
			/* [in] */ DISPID dispIdMember,
			/* [in] */ REFIID riid,
			/* [in] */ LCID lcid,
			/* [in] */ WORD wFlags,
			/* [out][in] */ DISPPARAMS *pDispParams,
			/* [out] */ VARIANT *pVarResult,
			/* [out] */ EXCEPINFO *pExcepInfo,
			/* [out] */ UINT *puArgErr);

		HRESULT ( STDMETHODCALLTYPE *ShowContextMenu )( 
			IDocHostUIHandlerDispatch * This,
			/* [in] */ DWORD dwID,
			/* [in] */ DWORD x,
			/* [in] */ DWORD y,
			/* [in] */ IUnknown *pcmdtReserved,
			/* [in] */ IDispatch *pdispReserved,
			/* [retval][out] */ HRESULT *dwRetVal);

		HRESULT ( STDMETHODCALLTYPE *GetHostInfo )( 
			IDocHostUIHandlerDispatch * This,
			/* [out][in] */ DWORD *pdwFlags,
			/* [out][in] */ DWORD *pdwDoubleClick);

		HRESULT ( STDMETHODCALLTYPE *ShowUI )( 
			IDocHostUIHandlerDispatch * This,
			/* [in] */ DWORD dwID,
			/* [in] */ IUnknown *pActiveObject,
			/* [in] */ IUnknown *pCommandTarget,
			/* [in] */ IUnknown *pFrame,
			/* [in] */ IUnknown *pDoc,
			/* [retval][out] */ HRESULT *dwRetVal);

		HRESULT ( STDMETHODCALLTYPE *HideUI )( 
			IDocHostUIHandlerDispatch * This);

		HRESULT ( STDMETHODCALLTYPE *UpdateUI )( 
			IDocHostUIHandlerDispatch * This);

		HRESULT ( STDMETHODCALLTYPE *EnableModeless )( 
			IDocHostUIHandlerDispatch * This,
			/* [in] */ VARIANT_BOOL fEnable);

		HRESULT ( STDMETHODCALLTYPE *OnDocWindowActivate )( 
			IDocHostUIHandlerDispatch * This,
			/* [in] */ VARIANT_BOOL fActivate);

		HRESULT ( STDMETHODCALLTYPE *OnFrameWindowActivate )( 
			IDocHostUIHandlerDispatch * This,
			/* [in] */ VARIANT_BOOL fActivate);

		HRESULT ( STDMETHODCALLTYPE *ResizeBorder )( 
			IDocHostUIHandlerDispatch * This,
			/* [in] */ long left,
			/* [in] */ long top,
			/* [in] */ long right,
			/* [in] */ long bottom,
			/* [in] */ IUnknown *pUIWindow,
			/* [in] */ VARIANT_BOOL fFrameWindow);

		HRESULT ( STDMETHODCALLTYPE *TranslateAccelerator )( 
			IDocHostUIHandlerDispatch * This,
			/* [in] */ DWORD_PTR hWnd,
			/* [in] */ DWORD nMessage,
			/* [in] */ DWORD_PTR wParam,
			/* [in] */ DWORD_PTR lParam,
			/* [in] */ BSTR bstrGuidCmdGroup,
			/* [in] */ DWORD nCmdID,
			/* [retval][out] */ HRESULT *dwRetVal);

		HRESULT ( STDMETHODCALLTYPE *GetOptionKeyPath )( 
			IDocHostUIHandlerDispatch * This,
			/* [out] */ BSTR *pbstrKey,
			/* [in] */ DWORD dw);

		HRESULT ( STDMETHODCALLTYPE *GetDropTarget )( 
			IDocHostUIHandlerDispatch * This,
			/* [in] */ IUnknown *pDropTarget,
			/* [out] */ IUnknown **ppDropTarget);

		HRESULT ( STDMETHODCALLTYPE *GetExternal )( 
			IDocHostUIHandlerDispatch * This,
			/* [out] */ IDispatch **ppDispatch);

		HRESULT ( STDMETHODCALLTYPE *TranslateUrl )( 
			IDocHostUIHandlerDispatch * This,
			/* [in] */ DWORD dwTranslate,
			/* [in] */ BSTR bstrURLIn,
			/* [out] */ BSTR *pbstrURLOut);

		HRESULT ( STDMETHODCALLTYPE *FilterDataObject )( 
			IDocHostUIHandlerDispatch * This,
			/* [in] */ IUnknown *pDO,
			/* [out] */ IUnknown **ppDORet);

		END_INTERFACE
	} IDocHostUIHandlerDispatchVtbl;

	interface IDocHostUIHandlerDispatch
	{
		CONST_VTBL struct IDocHostUIHandlerDispatchVtbl *lpVtbl;
	};



#ifdef COBJMACROS


#define IDocHostUIHandlerDispatch_QueryInterface(This,riid,ppvObject)	\
	(This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDocHostUIHandlerDispatch_AddRef(This)	\
	(This)->lpVtbl -> AddRef(This)

#define IDocHostUIHandlerDispatch_Release(This)	\
	(This)->lpVtbl -> Release(This)


#define IDocHostUIHandlerDispatch_GetTypeInfoCount(This,pctinfo)	\
	(This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IDocHostUIHandlerDispatch_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
	(This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IDocHostUIHandlerDispatch_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
	(This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IDocHostUIHandlerDispatch_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
	(This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IDocHostUIHandlerDispatch_ShowContextMenu(This,dwID,x,y,pcmdtReserved,pdispReserved,dwRetVal)	\
	(This)->lpVtbl -> ShowContextMenu(This,dwID,x,y,pcmdtReserved,pdispReserved,dwRetVal)

#define IDocHostUIHandlerDispatch_GetHostInfo(This,pdwFlags,pdwDoubleClick)	\
	(This)->lpVtbl -> GetHostInfo(This,pdwFlags,pdwDoubleClick)

#define IDocHostUIHandlerDispatch_ShowUI(This,dwID,pActiveObject,pCommandTarget,pFrame,pDoc,dwRetVal)	\
	(This)->lpVtbl -> ShowUI(This,dwID,pActiveObject,pCommandTarget,pFrame,pDoc,dwRetVal)

#define IDocHostUIHandlerDispatch_HideUI(This)	\
	(This)->lpVtbl -> HideUI(This)

#define IDocHostUIHandlerDispatch_UpdateUI(This)	\
	(This)->lpVtbl -> UpdateUI(This)

#define IDocHostUIHandlerDispatch_EnableModeless(This,fEnable)	\
	(This)->lpVtbl -> EnableModeless(This,fEnable)

#define IDocHostUIHandlerDispatch_OnDocWindowActivate(This,fActivate)	\
	(This)->lpVtbl -> OnDocWindowActivate(This,fActivate)

#define IDocHostUIHandlerDispatch_OnFrameWindowActivate(This,fActivate)	\
	(This)->lpVtbl -> OnFrameWindowActivate(This,fActivate)

#define IDocHostUIHandlerDispatch_ResizeBorder(This,left,top,right,bottom,pUIWindow,fFrameWindow)	\
	(This)->lpVtbl -> ResizeBorder(This,left,top,right,bottom,pUIWindow,fFrameWindow)

#define IDocHostUIHandlerDispatch_TranslateAccelerator(This,hWnd,nMessage,wParam,lParam,bstrGuidCmdGroup,nCmdID,dwRetVal)	\
	(This)->lpVtbl -> TranslateAccelerator(This,hWnd,nMessage,wParam,lParam,bstrGuidCmdGroup,nCmdID,dwRetVal)

#define IDocHostUIHandlerDispatch_GetOptionKeyPath(This,pbstrKey,dw)	\
	(This)->lpVtbl -> GetOptionKeyPath(This,pbstrKey,dw)

#define IDocHostUIHandlerDispatch_GetDropTarget(This,pDropTarget,ppDropTarget)	\
	(This)->lpVtbl -> GetDropTarget(This,pDropTarget,ppDropTarget)

#define IDocHostUIHandlerDispatch_GetExternal(This,ppDispatch)	\
	(This)->lpVtbl -> GetExternal(This,ppDispatch)

#define IDocHostUIHandlerDispatch_TranslateUrl(This,dwTranslate,bstrURLIn,pbstrURLOut)	\
	(This)->lpVtbl -> TranslateUrl(This,dwTranslate,bstrURLIn,pbstrURLOut)

#define IDocHostUIHandlerDispatch_FilterDataObject(This,pDO,ppDORet)	\
	(This)->lpVtbl -> FilterDataObject(This,pDO,ppDORet)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IDocHostUIHandlerDispatch_ShowContextMenu_Proxy( 
	IDocHostUIHandlerDispatch * This,
	/* [in] */ DWORD dwID,
	/* [in] */ DWORD x,
	/* [in] */ DWORD y,
	/* [in] */ IUnknown *pcmdtReserved,
	/* [in] */ IDispatch *pdispReserved,
	/* [retval][out] */ HRESULT *dwRetVal);


void __RPC_STUB IDocHostUIHandlerDispatch_ShowContextMenu_Stub(
	IRpcStubBuffer *This,
	IRpcChannelBuffer *_pRpcChannelBuffer,
	PRPC_MESSAGE _pRpcMessage,
	DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDocHostUIHandlerDispatch_GetHostInfo_Proxy( 
	IDocHostUIHandlerDispatch * This,
	/* [out][in] */ DWORD *pdwFlags,
	/* [out][in] */ DWORD *pdwDoubleClick);


void __RPC_STUB IDocHostUIHandlerDispatch_GetHostInfo_Stub(
	IRpcStubBuffer *This,
	IRpcChannelBuffer *_pRpcChannelBuffer,
	PRPC_MESSAGE _pRpcMessage,
	DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDocHostUIHandlerDispatch_ShowUI_Proxy( 
	IDocHostUIHandlerDispatch * This,
	/* [in] */ DWORD dwID,
	/* [in] */ IUnknown *pActiveObject,
	/* [in] */ IUnknown *pCommandTarget,
	/* [in] */ IUnknown *pFrame,
	/* [in] */ IUnknown *pDoc,
	/* [retval][out] */ HRESULT *dwRetVal);


void __RPC_STUB IDocHostUIHandlerDispatch_ShowUI_Stub(
	IRpcStubBuffer *This,
	IRpcChannelBuffer *_pRpcChannelBuffer,
	PRPC_MESSAGE _pRpcMessage,
	DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDocHostUIHandlerDispatch_HideUI_Proxy( 
	IDocHostUIHandlerDispatch * This);


void __RPC_STUB IDocHostUIHandlerDispatch_HideUI_Stub(
	IRpcStubBuffer *This,
	IRpcChannelBuffer *_pRpcChannelBuffer,
	PRPC_MESSAGE _pRpcMessage,
	DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDocHostUIHandlerDispatch_UpdateUI_Proxy( 
	IDocHostUIHandlerDispatch * This);


void __RPC_STUB IDocHostUIHandlerDispatch_UpdateUI_Stub(
	IRpcStubBuffer *This,
	IRpcChannelBuffer *_pRpcChannelBuffer,
	PRPC_MESSAGE _pRpcMessage,
	DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDocHostUIHandlerDispatch_EnableModeless_Proxy( 
	IDocHostUIHandlerDispatch * This,
	/* [in] */ VARIANT_BOOL fEnable);


void __RPC_STUB IDocHostUIHandlerDispatch_EnableModeless_Stub(
	IRpcStubBuffer *This,
	IRpcChannelBuffer *_pRpcChannelBuffer,
	PRPC_MESSAGE _pRpcMessage,
	DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDocHostUIHandlerDispatch_OnDocWindowActivate_Proxy( 
	IDocHostUIHandlerDispatch * This,
	/* [in] */ VARIANT_BOOL fActivate);


void __RPC_STUB IDocHostUIHandlerDispatch_OnDocWindowActivate_Stub(
	IRpcStubBuffer *This,
	IRpcChannelBuffer *_pRpcChannelBuffer,
	PRPC_MESSAGE _pRpcMessage,
	DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDocHostUIHandlerDispatch_OnFrameWindowActivate_Proxy( 
	IDocHostUIHandlerDispatch * This,
	/* [in] */ VARIANT_BOOL fActivate);


void __RPC_STUB IDocHostUIHandlerDispatch_OnFrameWindowActivate_Stub(
	IRpcStubBuffer *This,
	IRpcChannelBuffer *_pRpcChannelBuffer,
	PRPC_MESSAGE _pRpcMessage,
	DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDocHostUIHandlerDispatch_ResizeBorder_Proxy( 
	IDocHostUIHandlerDispatch * This,
	/* [in] */ long left,
	/* [in] */ long top,
	/* [in] */ long right,
	/* [in] */ long bottom,
	/* [in] */ IUnknown *pUIWindow,
	/* [in] */ VARIANT_BOOL fFrameWindow);


void __RPC_STUB IDocHostUIHandlerDispatch_ResizeBorder_Stub(
	IRpcStubBuffer *This,
	IRpcChannelBuffer *_pRpcChannelBuffer,
	PRPC_MESSAGE _pRpcMessage,
	DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDocHostUIHandlerDispatch_TranslateAccelerator_Proxy( 
	IDocHostUIHandlerDispatch * This,
	/* [in] */ DWORD_PTR hWnd,
	/* [in] */ DWORD nMessage,
	/* [in] */ DWORD_PTR wParam,
	/* [in] */ DWORD_PTR lParam,
	/* [in] */ BSTR bstrGuidCmdGroup,
	/* [in] */ DWORD nCmdID,
	/* [retval][out] */ HRESULT *dwRetVal);


void __RPC_STUB IDocHostUIHandlerDispatch_TranslateAccelerator_Stub(
	IRpcStubBuffer *This,
	IRpcChannelBuffer *_pRpcChannelBuffer,
	PRPC_MESSAGE _pRpcMessage,
	DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDocHostUIHandlerDispatch_GetOptionKeyPath_Proxy( 
	IDocHostUIHandlerDispatch * This,
	/* [out] */ BSTR *pbstrKey,
	/* [in] */ DWORD dw);


void __RPC_STUB IDocHostUIHandlerDispatch_GetOptionKeyPath_Stub(
	IRpcStubBuffer *This,
	IRpcChannelBuffer *_pRpcChannelBuffer,
	PRPC_MESSAGE _pRpcMessage,
	DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDocHostUIHandlerDispatch_GetDropTarget_Proxy( 
	IDocHostUIHandlerDispatch * This,
	/* [in] */ IUnknown *pDropTarget,
	/* [out] */ IUnknown **ppDropTarget);


void __RPC_STUB IDocHostUIHandlerDispatch_GetDropTarget_Stub(
	IRpcStubBuffer *This,
	IRpcChannelBuffer *_pRpcChannelBuffer,
	PRPC_MESSAGE _pRpcMessage,
	DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDocHostUIHandlerDispatch_GetExternal_Proxy( 
	IDocHostUIHandlerDispatch * This,
	/* [out] */ IDispatch **ppDispatch);


void __RPC_STUB IDocHostUIHandlerDispatch_GetExternal_Stub(
	IRpcStubBuffer *This,
	IRpcChannelBuffer *_pRpcChannelBuffer,
	PRPC_MESSAGE _pRpcMessage,
	DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDocHostUIHandlerDispatch_TranslateUrl_Proxy( 
	IDocHostUIHandlerDispatch * This,
	/* [in] */ DWORD dwTranslate,
	/* [in] */ BSTR bstrURLIn,
	/* [out] */ BSTR *pbstrURLOut);


void __RPC_STUB IDocHostUIHandlerDispatch_TranslateUrl_Stub(
	IRpcStubBuffer *This,
	IRpcChannelBuffer *_pRpcChannelBuffer,
	PRPC_MESSAGE _pRpcMessage,
	DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDocHostUIHandlerDispatch_FilterDataObject_Proxy( 
	IDocHostUIHandlerDispatch * This,
	/* [in] */ IUnknown *pDO,
	/* [out] */ IUnknown **ppDORet);


void __RPC_STUB IDocHostUIHandlerDispatch_FilterDataObject_Stub(
	IRpcStubBuffer *This,
	IRpcChannelBuffer *_pRpcChannelBuffer,
	PRPC_MESSAGE _pRpcMessage,
	DWORD *_pdwStubPhase);



#endif 	/* __IDocHostUIHandlerDispatch_INTERFACE_DEFINED__ */


#ifndef __IAxWinHostWindow_INTERFACE_DEFINED__
#define __IAxWinHostWindow_INTERFACE_DEFINED__

/* interface IAxWinHostWindow */
/* [object][unique][helpstring][uuid] */ 


EXTERN_C const IID IID_IAxWinHostWindow;

#if defined(__cplusplus) && !defined(CINTERFACE)

	MIDL_INTERFACE("B6EA2050-048A-11d1-82B9-00C04FB9942E")
	IAxWinHostWindow : public IUnknown
	{
	public:
		virtual HRESULT STDMETHODCALLTYPE CreateControl( 
			/* [in] */ LPCOLESTR lpTricsData,
			/* [in] */ HWND hWnd,
			/* [in] */ IStream *pStream) = 0;

		virtual HRESULT STDMETHODCALLTYPE CreateControlEx( 
			/* [in] */ LPCOLESTR lpTricsData,
			/* [in] */ HWND hWnd,
			/* [in] */ IStream *pStream,
			/* [out] */ IUnknown **ppUnk,
			/* [in] */ REFIID riidAdvise,
			/* [in] */ IUnknown *punkAdvise) = 0;

		virtual HRESULT STDMETHODCALLTYPE AttachControl( 
			/* [in] */ IUnknown *pUnkControl,
			/* [in] */ HWND hWnd) = 0;

		virtual HRESULT STDMETHODCALLTYPE QueryControl( 
			/* [in] */ REFIID riid,
			/* [iid_is][out] */ void **ppvObject) = 0;

		virtual HRESULT STDMETHODCALLTYPE SetExternalDispatch( 
			/* [in] */ IDispatch *pDisp) = 0;

		virtual HRESULT STDMETHODCALLTYPE SetExternalUIHandler( 
			/* [in] */ IDocHostUIHandlerDispatch *pDisp) = 0;

	};

#else 	/* C style interface */

	typedef struct IAxWinHostWindowVtbl
	{
		BEGIN_INTERFACE

		HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
			IAxWinHostWindow * This,
			/* [in] */ REFIID riid,
			/* [iid_is][out] */ void **ppvObject);

		ULONG ( STDMETHODCALLTYPE *AddRef )( 
			IAxWinHostWindow * This);

		ULONG ( STDMETHODCALLTYPE *Release )( 
			IAxWinHostWindow * This);

		HRESULT ( STDMETHODCALLTYPE *CreateControl )( 
			IAxWinHostWindow * This,
			/* [in] */ LPCOLESTR lpTricsData,
			/* [in] */ HWND hWnd,
			/* [in] */ IStream *pStream);

		HRESULT ( STDMETHODCALLTYPE *CreateControlEx )( 
			IAxWinHostWindow * This,
			/* [in] */ LPCOLESTR lpTricsData,
			/* [in] */ HWND hWnd,
			/* [in] */ IStream *pStream,
			/* [out] */ IUnknown **ppUnk,
			/* [in] */ REFIID riidAdvise,
			/* [in] */ IUnknown *punkAdvise);

		HRESULT ( STDMETHODCALLTYPE *AttachControl )( 
			IAxWinHostWindow * This,
			/* [in] */ IUnknown *pUnkControl,
			/* [in] */ HWND hWnd);

		HRESULT ( STDMETHODCALLTYPE *QueryControl )( 
			IAxWinHostWindow * This,
			/* [in] */ REFIID riid,
			/* [iid_is][out] */ void **ppvObject);

		HRESULT ( STDMETHODCALLTYPE *SetExternalDispatch )( 
			IAxWinHostWindow * This,
			/* [in] */ IDispatch *pDisp);

		HRESULT ( STDMETHODCALLTYPE *SetExternalUIHandler )( 
			IAxWinHostWindow * This,
			/* [in] */ IDocHostUIHandlerDispatch *pDisp);

		END_INTERFACE
	} IAxWinHostWindowVtbl;

	interface IAxWinHostWindow
	{
		CONST_VTBL struct IAxWinHostWindowVtbl *lpVtbl;
	};



#ifdef COBJMACROS


#define IAxWinHostWindow_QueryInterface(This,riid,ppvObject)	\
	(This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IAxWinHostWindow_AddRef(This)	\
	(This)->lpVtbl -> AddRef(This)

#define IAxWinHostWindow_Release(This)	\
	(This)->lpVtbl -> Release(This)


#define IAxWinHostWindow_CreateControl(This,lpTricsData,hWnd,pStream)	\
	(This)->lpVtbl -> CreateControl(This,lpTricsData,hWnd,pStream)

#define IAxWinHostWindow_CreateControlEx(This,lpTricsData,hWnd,pStream,ppUnk,riidAdvise,punkAdvise)	\
	(This)->lpVtbl -> CreateControlEx(This,lpTricsData,hWnd,pStream,ppUnk,riidAdvise,punkAdvise)

#define IAxWinHostWindow_AttachControl(This,pUnkControl,hWnd)	\
	(This)->lpVtbl -> AttachControl(This,pUnkControl,hWnd)

#define IAxWinHostWindow_QueryControl(This,riid,ppvObject)	\
	(This)->lpVtbl -> QueryControl(This,riid,ppvObject)

#define IAxWinHostWindow_SetExternalDispatch(This,pDisp)	\
	(This)->lpVtbl -> SetExternalDispatch(This,pDisp)

#define IAxWinHostWindow_SetExternalUIHandler(This,pDisp)	\
	(This)->lpVtbl -> SetExternalUIHandler(This,pDisp)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IAxWinHostWindow_CreateControl_Proxy( 
	IAxWinHostWindow * This,
	/* [in] */ LPCOLESTR lpTricsData,
	/* [in] */ HWND hWnd,
	/* [in] */ IStream *pStream);


void __RPC_STUB IAxWinHostWindow_CreateControl_Stub(
	IRpcStubBuffer *This,
	IRpcChannelBuffer *_pRpcChannelBuffer,
	PRPC_MESSAGE _pRpcMessage,
	DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAxWinHostWindow_CreateControlEx_Proxy( 
	IAxWinHostWindow * This,
	/* [in] */ LPCOLESTR lpTricsData,
	/* [in] */ HWND hWnd,
	/* [in] */ IStream *pStream,
	/* [out] */ IUnknown **ppUnk,
	/* [in] */ REFIID riidAdvise,
	/* [in] */ IUnknown *punkAdvise);


void __RPC_STUB IAxWinHostWindow_CreateControlEx_Stub(
	IRpcStubBuffer *This,
	IRpcChannelBuffer *_pRpcChannelBuffer,
	PRPC_MESSAGE _pRpcMessage,
	DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAxWinHostWindow_AttachControl_Proxy( 
	IAxWinHostWindow * This,
	/* [in] */ IUnknown *pUnkControl,
	/* [in] */ HWND hWnd);


void __RPC_STUB IAxWinHostWindow_AttachControl_Stub(
	IRpcStubBuffer *This,
	IRpcChannelBuffer *_pRpcChannelBuffer,
	PRPC_MESSAGE _pRpcMessage,
	DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAxWinHostWindow_QueryControl_Proxy( 
	IAxWinHostWindow * This,
	/* [in] */ REFIID riid,
	/* [iid_is][out] */ void **ppvObject);


void __RPC_STUB IAxWinHostWindow_QueryControl_Stub(
	IRpcStubBuffer *This,
	IRpcChannelBuffer *_pRpcChannelBuffer,
	PRPC_MESSAGE _pRpcMessage,
	DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAxWinHostWindow_SetExternalDispatch_Proxy( 
	IAxWinHostWindow * This,
	/* [in] */ IDispatch *pDisp);


void __RPC_STUB IAxWinHostWindow_SetExternalDispatch_Stub(
	IRpcStubBuffer *This,
	IRpcChannelBuffer *_pRpcChannelBuffer,
	PRPC_MESSAGE _pRpcMessage,
	DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAxWinHostWindow_SetExternalUIHandler_Proxy( 
	IAxWinHostWindow * This,
	/* [in] */ IDocHostUIHandlerDispatch *pDisp);


void __RPC_STUB IAxWinHostWindow_SetExternalUIHandler_Stub(
	IRpcStubBuffer *This,
	IRpcChannelBuffer *_pRpcChannelBuffer,
	PRPC_MESSAGE _pRpcMessage,
	DWORD *_pdwStubPhase);



#endif 	/* __IAxWinHostWindow_INTERFACE_DEFINED__ */


#ifndef __IAxWinHostWindowLic_INTERFACE_DEFINED__
#define __IAxWinHostWindowLic_INTERFACE_DEFINED__

/* interface IAxWinHostWindowLic */
/* [object][unique][helpstring][uuid] */ 


EXTERN_C const IID IID_IAxWinHostWindowLic;

#if defined(__cplusplus) && !defined(CINTERFACE)

	MIDL_INTERFACE("3935BDA8-4ED9-495c-8650-E01FC1E38A4B")
	IAxWinHostWindowLic : public IAxWinHostWindow
	{
	public:
		virtual HRESULT STDMETHODCALLTYPE CreateControlLic( 
			/* [in] */ LPCOLESTR lpTricsData,
			/* [in] */ HWND hWnd,
			/* [in] */ IStream *pStream,
			/* [in] */ BSTR bstrLic) = 0;

		virtual HRESULT STDMETHODCALLTYPE CreateControlLicEx( 
			/* [in] */ LPCOLESTR lpTricsData,
			/* [in] */ HWND hWnd,
			/* [in] */ IStream *pStream,
			/* [out] */ IUnknown **ppUnk,
			/* [in] */ REFIID riidAdvise,
			/* [in] */ IUnknown *punkAdvise,
			/* [in] */ BSTR bstrLic) = 0;

	};

#else 	/* C style interface */

	typedef struct IAxWinHostWindowLicVtbl
	{
		BEGIN_INTERFACE

		HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
			IAxWinHostWindowLic * This,
			/* [in] */ REFIID riid,
			/* [iid_is][out] */ void **ppvObject);

		ULONG ( STDMETHODCALLTYPE *AddRef )( 
			IAxWinHostWindowLic * This);

		ULONG ( STDMETHODCALLTYPE *Release )( 
			IAxWinHostWindowLic * This);

		HRESULT ( STDMETHODCALLTYPE *CreateControl )( 
			IAxWinHostWindowLic * This,
			/* [in] */ LPCOLESTR lpTricsData,
			/* [in] */ HWND hWnd,
			/* [in] */ IStream *pStream);

		HRESULT ( STDMETHODCALLTYPE *CreateControlEx )( 
			IAxWinHostWindowLic * This,
			/* [in] */ LPCOLESTR lpTricsData,
			/* [in] */ HWND hWnd,
			/* [in] */ IStream *pStream,
			/* [out] */ IUnknown **ppUnk,
			/* [in] */ REFIID riidAdvise,
			/* [in] */ IUnknown *punkAdvise);

		HRESULT ( STDMETHODCALLTYPE *AttachControl )( 
			IAxWinHostWindowLic * This,
			/* [in] */ IUnknown *pUnkControl,
			/* [in] */ HWND hWnd);

		HRESULT ( STDMETHODCALLTYPE *QueryControl )( 
			IAxWinHostWindowLic * This,
			/* [in] */ REFIID riid,
			/* [iid_is][out] */ void **ppvObject);

		HRESULT ( STDMETHODCALLTYPE *SetExternalDispatch )( 
			IAxWinHostWindowLic * This,
			/* [in] */ IDispatch *pDisp);

		HRESULT ( STDMETHODCALLTYPE *SetExternalUIHandler )( 
			IAxWinHostWindowLic * This,
			/* [in] */ IDocHostUIHandlerDispatch *pDisp);

		HRESULT ( STDMETHODCALLTYPE *CreateControlLic )( 
			IAxWinHostWindowLic * This,
			/* [in] */ LPCOLESTR lpTricsData,
			/* [in] */ HWND hWnd,
			/* [in] */ IStream *pStream,
			/* [in] */ BSTR bstrLic);

		HRESULT ( STDMETHODCALLTYPE *CreateControlLicEx )( 
			IAxWinHostWindowLic * This,
			/* [in] */ LPCOLESTR lpTricsData,
			/* [in] */ HWND hWnd,
			/* [in] */ IStream *pStream,
			/* [out] */ IUnknown **ppUnk,
			/* [in] */ REFIID riidAdvise,
			/* [in] */ IUnknown *punkAdvise,
			/* [in] */ BSTR bstrLic);

		END_INTERFACE
	} IAxWinHostWindowLicVtbl;

	interface IAxWinHostWindowLic
	{
		CONST_VTBL struct IAxWinHostWindowLicVtbl *lpVtbl;
	};



#ifdef COBJMACROS


#define IAxWinHostWindowLic_QueryInterface(This,riid,ppvObject)	\
	(This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IAxWinHostWindowLic_AddRef(This)	\
	(This)->lpVtbl -> AddRef(This)

#define IAxWinHostWindowLic_Release(This)	\
	(This)->lpVtbl -> Release(This)


#define IAxWinHostWindowLic_CreateControl(This,lpTricsData,hWnd,pStream)	\
	(This)->lpVtbl -> CreateControl(This,lpTricsData,hWnd,pStream)

#define IAxWinHostWindowLic_CreateControlEx(This,lpTricsData,hWnd,pStream,ppUnk,riidAdvise,punkAdvise)	\
	(This)->lpVtbl -> CreateControlEx(This,lpTricsData,hWnd,pStream,ppUnk,riidAdvise,punkAdvise)

#define IAxWinHostWindowLic_AttachControl(This,pUnkControl,hWnd)	\
	(This)->lpVtbl -> AttachControl(This,pUnkControl,hWnd)

#define IAxWinHostWindowLic_QueryControl(This,riid,ppvObject)	\
	(This)->lpVtbl -> QueryControl(This,riid,ppvObject)

#define IAxWinHostWindowLic_SetExternalDispatch(This,pDisp)	\
	(This)->lpVtbl -> SetExternalDispatch(This,pDisp)

#define IAxWinHostWindowLic_SetExternalUIHandler(This,pDisp)	\
	(This)->lpVtbl -> SetExternalUIHandler(This,pDisp)


#define IAxWinHostWindowLic_CreateControlLic(This,lpTricsData,hWnd,pStream,bstrLic)	\
	(This)->lpVtbl -> CreateControlLic(This,lpTricsData,hWnd,pStream,bstrLic)

#define IAxWinHostWindowLic_CreateControlLicEx(This,lpTricsData,hWnd,pStream,ppUnk,riidAdvise,punkAdvise,bstrLic)	\
	(This)->lpVtbl -> CreateControlLicEx(This,lpTricsData,hWnd,pStream,ppUnk,riidAdvise,punkAdvise,bstrLic)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IAxWinHostWindowLic_CreateControlLic_Proxy( 
	IAxWinHostWindowLic * This,
	/* [in] */ LPCOLESTR lpTricsData,
	/* [in] */ HWND hWnd,
	/* [in] */ IStream *pStream,
	/* [in] */ BSTR bstrLic);


void __RPC_STUB IAxWinHostWindowLic_CreateControlLic_Stub(
	IRpcStubBuffer *This,
	IRpcChannelBuffer *_pRpcChannelBuffer,
	PRPC_MESSAGE _pRpcMessage,
	DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAxWinHostWindowLic_CreateControlLicEx_Proxy( 
	IAxWinHostWindowLic * This,
	/* [in] */ LPCOLESTR lpTricsData,
	/* [in] */ HWND hWnd,
	/* [in] */ IStream *pStream,
	/* [out] */ IUnknown **ppUnk,
	/* [in] */ REFIID riidAdvise,
	/* [in] */ IUnknown *punkAdvise,
	/* [in] */ BSTR bstrLic);


void __RPC_STUB IAxWinHostWindowLic_CreateControlLicEx_Stub(
	IRpcStubBuffer *This,
	IRpcChannelBuffer *_pRpcChannelBuffer,
	PRPC_MESSAGE _pRpcMessage,
	DWORD *_pdwStubPhase);



#endif 	/* __IAxWinHostWindowLic_INTERFACE_DEFINED__ */


#ifndef __IAxWinAmbientDispatch_INTERFACE_DEFINED__
#define __IAxWinAmbientDispatch_INTERFACE_DEFINED__

/* interface IAxWinAmbientDispatch */
/* [unique][helpstring][uuid][dual][object] */ 


EXTERN_C const IID IID_IAxWinAmbientDispatch;

#if defined(__cplusplus) && !defined(CINTERFACE)

	MIDL_INTERFACE("B6EA2051-048A-11d1-82B9-00C04FB9942E")
	IAxWinAmbientDispatch : public IDispatch
	{
	public:
		virtual /* [helpstring][propput] */ HRESULT STDMETHODCALLTYPE put_AllowWindowlessActivation( 
			/* [in] */ VARIANT_BOOL bCanWindowlessActivate) = 0;

		virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_AllowWindowlessActivation( 
			/* [retval][out] */ VARIANT_BOOL *pbCanWindowlessActivate) = 0;

		virtual /* [id][helpstring][propput] */ HRESULT STDMETHODCALLTYPE put_BackColor( 
			/* [in] */ OLE_COLOR clrBackground) = 0;

		virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_BackColor( 
			/* [retval][out] */ OLE_COLOR *pclrBackground) = 0;

		virtual /* [id][helpstring][propput] */ HRESULT STDMETHODCALLTYPE put_ForeColor( 
			/* [in] */ OLE_COLOR clrForeground) = 0;

		virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_ForeColor( 
			/* [retval][out] */ OLE_COLOR *pclrForeground) = 0;

		virtual /* [id][helpstring][propput] */ HRESULT STDMETHODCALLTYPE put_LocaleID( 
			/* [in] */ LCID lcidLocaleID) = 0;

		virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_LocaleID( 
			/* [retval][out] */ LCID *plcidLocaleID) = 0;

		virtual /* [id][helpstring][propput] */ HRESULT STDMETHODCALLTYPE put_UserMode( 
			/* [in] */ VARIANT_BOOL bUserMode) = 0;

		virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_UserMode( 
			/* [retval][out] */ VARIANT_BOOL *pbUserMode) = 0;

		virtual /* [id][helpstring][propput] */ HRESULT STDMETHODCALLTYPE put_DisplayAsDefault( 
			/* [in] */ VARIANT_BOOL bDisplayAsDefault) = 0;

		virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_DisplayAsDefault( 
			/* [retval][out] */ VARIANT_BOOL *pbDisplayAsDefault) = 0;

		virtual /* [id][helpstring][propput] */ HRESULT STDMETHODCALLTYPE put_Font( 
			/* [in] */ IFontDisp *pFont) = 0;

		virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_Font( 
			/* [retval][out] */ IFontDisp **pFont) = 0;

		virtual /* [id][helpstring][propput] */ HRESULT STDMETHODCALLTYPE put_MessageReflect( 
			/* [in] */ VARIANT_BOOL bMsgReflect) = 0;

		virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_MessageReflect( 
			/* [retval][out] */ VARIANT_BOOL *pbMsgReflect) = 0;

		virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_ShowGrabHandles( 
			/* [retval][out] */ VARIANT_BOOL *pbShowGrabHandles) = 0;

		virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_ShowHatching( 
			/* [retval][out] */ VARIANT_BOOL *pbShowHatching) = 0;

		virtual /* [helpstring][propput] */ HRESULT STDMETHODCALLTYPE put_DocHostFlags( 
			/* [in] */ DWORD dwDocHostFlags) = 0;

		virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_DocHostFlags( 
			/* [retval][out] */ DWORD *pdwDocHostFlags) = 0;

		virtual /* [helpstring][propput] */ HRESULT STDMETHODCALLTYPE put_DocHostDoubleClickFlags( 
			/* [in] */ DWORD dwDocHostDoubleClickFlags) = 0;

		virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_DocHostDoubleClickFlags( 
			/* [retval][out] */ DWORD *pdwDocHostDoubleClickFlags) = 0;

		virtual /* [helpstring][propput] */ HRESULT STDMETHODCALLTYPE put_AllowContextMenu( 
			/* [in] */ VARIANT_BOOL bAllowContextMenu) = 0;

		virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_AllowContextMenu( 
			/* [retval][out] */ VARIANT_BOOL *pbAllowContextMenu) = 0;

		virtual /* [helpstring][propput] */ HRESULT STDMETHODCALLTYPE put_AllowShowUI( 
			/* [in] */ VARIANT_BOOL bAllowShowUI) = 0;

		virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_AllowShowUI( 
			/* [retval][out] */ VARIANT_BOOL *pbAllowShowUI) = 0;

		virtual /* [helpstring][propput] */ HRESULT STDMETHODCALLTYPE put_OptionKeyPath( 
			/* [in] */ BSTR bstrOptionKeyPath) = 0;

		virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_OptionKeyPath( 
			/* [retval][out] */ BSTR *pbstrOptionKeyPath) = 0;

	};

#else 	/* C style interface */

	typedef struct IAxWinAmbientDispatchVtbl
	{
		BEGIN_INTERFACE

		HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
			IAxWinAmbientDispatch * This,
			/* [in] */ REFIID riid,
			/* [iid_is][out] */ void **ppvObject);

		ULONG ( STDMETHODCALLTYPE *AddRef )( 
			IAxWinAmbientDispatch * This);

		ULONG ( STDMETHODCALLTYPE *Release )( 
			IAxWinAmbientDispatch * This);

		HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
			IAxWinAmbientDispatch * This,
			/* [out] */ UINT *pctinfo);

		HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
			IAxWinAmbientDispatch * This,
			/* [in] */ UINT iTInfo,
			/* [in] */ LCID lcid,
			/* [out] */ ITypeInfo **ppTInfo);

		HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
			IAxWinAmbientDispatch * This,
			/* [in] */ REFIID riid,
			/* [size_is][in] */ _In_count_(cNames) LPOLESTR *rgszNames,
			/* [in] */ UINT cNames,
			/* [in] */ LCID lcid,
			/* [size_is][out] */ DISPID *rgDispId);

		/* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
			IAxWinAmbientDispatch * This,
			/* [in] */ DISPID dispIdMember,
			/* [in] */ REFIID riid,
			/* [in] */ LCID lcid,
			/* [in] */ WORD wFlags,
			/* [out][in] */ DISPPARAMS *pDispParams,
			/* [out] */ VARIANT *pVarResult,
			/* [out] */ EXCEPINFO *pExcepInfo,
			/* [out] */ UINT *puArgErr);

		/* [helpstring][propput] */ HRESULT ( STDMETHODCALLTYPE *put_AllowWindowlessActivation )( 
			IAxWinAmbientDispatch * This,
			/* [in] */ VARIANT_BOOL bCanWindowlessActivate);

		/* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_AllowWindowlessActivation )( 
			IAxWinAmbientDispatch * This,
			/* [retval][out] */ VARIANT_BOOL *pbCanWindowlessActivate);

		/* [id][helpstring][propput] */ HRESULT ( STDMETHODCALLTYPE *put_BackColor )( 
			IAxWinAmbientDispatch * This,
			/* [in] */ OLE_COLOR clrBackground);

		/* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_BackColor )( 
			IAxWinAmbientDispatch * This,
			/* [retval][out] */ OLE_COLOR *pclrBackground);

		/* [id][helpstring][propput] */ HRESULT ( STDMETHODCALLTYPE *put_ForeColor )( 
			IAxWinAmbientDispatch * This,
			/* [in] */ OLE_COLOR clrForeground);

		/* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_ForeColor )( 
			IAxWinAmbientDispatch * This,
			/* [retval][out] */ OLE_COLOR *pclrForeground);

		/* [id][helpstring][propput] */ HRESULT ( STDMETHODCALLTYPE *put_LocaleID )( 
			IAxWinAmbientDispatch * This,
			/* [in] */ LCID lcidLocaleID);

		/* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_LocaleID )( 
			IAxWinAmbientDispatch * This,
			/* [retval][out] */ LCID *plcidLocaleID);

		/* [id][helpstring][propput] */ HRESULT ( STDMETHODCALLTYPE *put_UserMode )( 
			IAxWinAmbientDispatch * This,
			/* [in] */ VARIANT_BOOL bUserMode);

		/* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_UserMode )( 
			IAxWinAmbientDispatch * This,
			/* [retval][out] */ VARIANT_BOOL *pbUserMode);

		/* [id][helpstring][propput] */ HRESULT ( STDMETHODCALLTYPE *put_DisplayAsDefault )( 
			IAxWinAmbientDispatch * This,
			/* [in] */ VARIANT_BOOL bDisplayAsDefault);

		/* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_DisplayAsDefault )( 
			IAxWinAmbientDispatch * This,
			/* [retval][out] */ VARIANT_BOOL *pbDisplayAsDefault);

		/* [id][helpstring][propput] */ HRESULT ( STDMETHODCALLTYPE *put_Font )( 
			IAxWinAmbientDispatch * This,
			/* [in] */ IFontDisp *pFont);

		/* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Font )( 
			IAxWinAmbientDispatch * This,
			/* [retval][out] */ IFontDisp **pFont);

		/* [id][helpstring][propput] */ HRESULT ( STDMETHODCALLTYPE *put_MessageReflect )( 
			IAxWinAmbientDispatch * This,
			/* [in] */ VARIANT_BOOL bMsgReflect);

		/* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_MessageReflect )( 
			IAxWinAmbientDispatch * This,
			/* [retval][out] */ VARIANT_BOOL *pbMsgReflect);

		/* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_ShowGrabHandles )( 
			IAxWinAmbientDispatch * This,
			/* [retval][out] */ VARIANT_BOOL *pbShowGrabHandles);

		/* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_ShowHatching )( 
			IAxWinAmbientDispatch * This,
			/* [retval][out] */ VARIANT_BOOL *pbShowHatching);

		/* [helpstring][propput] */ HRESULT ( STDMETHODCALLTYPE *put_DocHostFlags )( 
			IAxWinAmbientDispatch * This,
			/* [in] */ DWORD dwDocHostFlags);

		/* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_DocHostFlags )( 
			IAxWinAmbientDispatch * This,
			/* [retval][out] */ DWORD *pdwDocHostFlags);

		/* [helpstring][propput] */ HRESULT ( STDMETHODCALLTYPE *put_DocHostDoubleClickFlags )( 
			IAxWinAmbientDispatch * This,
			/* [in] */ DWORD dwDocHostDoubleClickFlags);

		/* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_DocHostDoubleClickFlags )( 
			IAxWinAmbientDispatch * This,
			/* [retval][out] */ DWORD *pdwDocHostDoubleClickFlags);

		/* [helpstring][propput] */ HRESULT ( STDMETHODCALLTYPE *put_AllowContextMenu )( 
			IAxWinAmbientDispatch * This,
			/* [in] */ VARIANT_BOOL bAllowContextMenu);

		/* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_AllowContextMenu )( 
			IAxWinAmbientDispatch * This,
			/* [retval][out] */ VARIANT_BOOL *pbAllowContextMenu);

		/* [helpstring][propput] */ HRESULT ( STDMETHODCALLTYPE *put_AllowShowUI )( 
			IAxWinAmbientDispatch * This,
			/* [in] */ VARIANT_BOOL bAllowShowUI);

		/* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_AllowShowUI )( 
			IAxWinAmbientDispatch * This,
			/* [retval][out] */ VARIANT_BOOL *pbAllowShowUI);

		/* [helpstring][propput] */ HRESULT ( STDMETHODCALLTYPE *put_OptionKeyPath )( 
			IAxWinAmbientDispatch * This,
			/* [in] */ BSTR bstrOptionKeyPath);

		/* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_OptionKeyPath )( 
			IAxWinAmbientDispatch * This,
			/* [retval][out] */ BSTR *pbstrOptionKeyPath);

		END_INTERFACE
	} IAxWinAmbientDispatchVtbl;

	interface IAxWinAmbientDispatch
	{
		CONST_VTBL struct IAxWinAmbientDispatchVtbl *lpVtbl;
	};



#ifdef COBJMACROS


#define IAxWinAmbientDispatch_QueryInterface(This,riid,ppvObject)	\
	(This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IAxWinAmbientDispatch_AddRef(This)	\
	(This)->lpVtbl -> AddRef(This)

#define IAxWinAmbientDispatch_Release(This)	\
	(This)->lpVtbl -> Release(This)


#define IAxWinAmbientDispatch_GetTypeInfoCount(This,pctinfo)	\
	(This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IAxWinAmbientDispatch_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
	(This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IAxWinAmbientDispatch_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
	(This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IAxWinAmbientDispatch_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
	(This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IAxWinAmbientDispatch_put_AllowWindowlessActivation(This,bCanWindowlessActivate)	\
	(This)->lpVtbl -> put_AllowWindowlessActivation(This,bCanWindowlessActivate)

#define IAxWinAmbientDispatch_get_AllowWindowlessActivation(This,pbCanWindowlessActivate)	\
	(This)->lpVtbl -> get_AllowWindowlessActivation(This,pbCanWindowlessActivate)

#define IAxWinAmbientDispatch_put_BackColor(This,clrBackground)	\
	(This)->lpVtbl -> put_BackColor(This,clrBackground)

#define IAxWinAmbientDispatch_get_BackColor(This,pclrBackground)	\
	(This)->lpVtbl -> get_BackColor(This,pclrBackground)

#define IAxWinAmbientDispatch_put_ForeColor(This,clrForeground)	\
	(This)->lpVtbl -> put_ForeColor(This,clrForeground)

#define IAxWinAmbientDispatch_get_ForeColor(This,pclrForeground)	\
	(This)->lpVtbl -> get_ForeColor(This,pclrForeground)

#define IAxWinAmbientDispatch_put_LocaleID(This,lcidLocaleID)	\
	(This)->lpVtbl -> put_LocaleID(This,lcidLocaleID)

#define IAxWinAmbientDispatch_get_LocaleID(This,plcidLocaleID)	\
	(This)->lpVtbl -> get_LocaleID(This,plcidLocaleID)

#define IAxWinAmbientDispatch_put_UserMode(This,bUserMode)	\
	(This)->lpVtbl -> put_UserMode(This,bUserMode)

#define IAxWinAmbientDispatch_get_UserMode(This,pbUserMode)	\
	(This)->lpVtbl -> get_UserMode(This,pbUserMode)

#define IAxWinAmbientDispatch_put_DisplayAsDefault(This,bDisplayAsDefault)	\
	(This)->lpVtbl -> put_DisplayAsDefault(This,bDisplayAsDefault)

#define IAxWinAmbientDispatch_get_DisplayAsDefault(This,pbDisplayAsDefault)	\
	(This)->lpVtbl -> get_DisplayAsDefault(This,pbDisplayAsDefault)

#define IAxWinAmbientDispatch_put_Font(This,pFont)	\
	(This)->lpVtbl -> put_Font(This,pFont)

#define IAxWinAmbientDispatch_get_Font(This,pFont)	\
	(This)->lpVtbl -> get_Font(This,pFont)

#define IAxWinAmbientDispatch_put_MessageReflect(This,bMsgReflect)	\
	(This)->lpVtbl -> put_MessageReflect(This,bMsgReflect)

#define IAxWinAmbientDispatch_get_MessageReflect(This,pbMsgReflect)	\
	(This)->lpVtbl -> get_MessageReflect(This,pbMsgReflect)

#define IAxWinAmbientDispatch_get_ShowGrabHandles(This,pbShowGrabHandles)	\
	(This)->lpVtbl -> get_ShowGrabHandles(This,pbShowGrabHandles)

#define IAxWinAmbientDispatch_get_ShowHatching(This,pbShowHatching)	\
	(This)->lpVtbl -> get_ShowHatching(This,pbShowHatching)

#define IAxWinAmbientDispatch_put_DocHostFlags(This,dwDocHostFlags)	\
	(This)->lpVtbl -> put_DocHostFlags(This,dwDocHostFlags)

#define IAxWinAmbientDispatch_get_DocHostFlags(This,pdwDocHostFlags)	\
	(This)->lpVtbl -> get_DocHostFlags(This,pdwDocHostFlags)

#define IAxWinAmbientDispatch_put_DocHostDoubleClickFlags(This,dwDocHostDoubleClickFlags)	\
	(This)->lpVtbl -> put_DocHostDoubleClickFlags(This,dwDocHostDoubleClickFlags)

#define IAxWinAmbientDispatch_get_DocHostDoubleClickFlags(This,pdwDocHostDoubleClickFlags)	\
	(This)->lpVtbl -> get_DocHostDoubleClickFlags(This,pdwDocHostDoubleClickFlags)

#define IAxWinAmbientDispatch_put_AllowContextMenu(This,bAllowContextMenu)	\
	(This)->lpVtbl -> put_AllowContextMenu(This,bAllowContextMenu)

#define IAxWinAmbientDispatch_get_AllowContextMenu(This,pbAllowContextMenu)	\
	(This)->lpVtbl -> get_AllowContextMenu(This,pbAllowContextMenu)

#define IAxWinAmbientDispatch_put_AllowShowUI(This,bAllowShowUI)	\
	(This)->lpVtbl -> put_AllowShowUI(This,bAllowShowUI)

#define IAxWinAmbientDispatch_get_AllowShowUI(This,pbAllowShowUI)	\
	(This)->lpVtbl -> get_AllowShowUI(This,pbAllowShowUI)

#define IAxWinAmbientDispatch_put_OptionKeyPath(This,bstrOptionKeyPath)	\
	(This)->lpVtbl -> put_OptionKeyPath(This,bstrOptionKeyPath)

#define IAxWinAmbientDispatch_get_OptionKeyPath(This,pbstrOptionKeyPath)	\
	(This)->lpVtbl -> get_OptionKeyPath(This,pbstrOptionKeyPath)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][propput] */ HRESULT STDMETHODCALLTYPE IAxWinAmbientDispatch_put_AllowWindowlessActivation_Proxy( 
	IAxWinAmbientDispatch * This,
	/* [in] */ VARIANT_BOOL bCanWindowlessActivate);


void __RPC_STUB IAxWinAmbientDispatch_put_AllowWindowlessActivation_Stub(
	IRpcStubBuffer *This,
	IRpcChannelBuffer *_pRpcChannelBuffer,
	PRPC_MESSAGE _pRpcMessage,
	DWORD *_pdwStubPhase);


/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE IAxWinAmbientDispatch_get_AllowWindowlessActivation_Proxy( 
	IAxWinAmbientDispatch * This,
	/* [retval][out] */ VARIANT_BOOL *pbCanWindowlessActivate);


void __RPC_STUB IAxWinAmbientDispatch_get_AllowWindowlessActivation_Stub(
	IRpcStubBuffer *This,
	IRpcChannelBuffer *_pRpcChannelBuffer,
	PRPC_MESSAGE _pRpcMessage,
	DWORD *_pdwStubPhase);


/* [id][helpstring][propput] */ HRESULT STDMETHODCALLTYPE IAxWinAmbientDispatch_put_BackColor_Proxy( 
	IAxWinAmbientDispatch * This,
	/* [in] */ OLE_COLOR clrBackground);


void __RPC_STUB IAxWinAmbientDispatch_put_BackColor_Stub(
	IRpcStubBuffer *This,
	IRpcChannelBuffer *_pRpcChannelBuffer,
	PRPC_MESSAGE _pRpcMessage,
	DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IAxWinAmbientDispatch_get_BackColor_Proxy( 
	IAxWinAmbientDispatch * This,
	/* [retval][out] */ OLE_COLOR *pclrBackground);


void __RPC_STUB IAxWinAmbientDispatch_get_BackColor_Stub(
	IRpcStubBuffer *This,
	IRpcChannelBuffer *_pRpcChannelBuffer,
	PRPC_MESSAGE _pRpcMessage,
	DWORD *_pdwStubPhase);


/* [id][helpstring][propput] */ HRESULT STDMETHODCALLTYPE IAxWinAmbientDispatch_put_ForeColor_Proxy( 
	IAxWinAmbientDispatch * This,
	/* [in] */ OLE_COLOR clrForeground);


void __RPC_STUB IAxWinAmbientDispatch_put_ForeColor_Stub(
	IRpcStubBuffer *This,
	IRpcChannelBuffer *_pRpcChannelBuffer,
	PRPC_MESSAGE _pRpcMessage,
	DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IAxWinAmbientDispatch_get_ForeColor_Proxy( 
	IAxWinAmbientDispatch * This,
	/* [retval][out] */ OLE_COLOR *pclrForeground);


void __RPC_STUB IAxWinAmbientDispatch_get_ForeColor_Stub(
	IRpcStubBuffer *This,
	IRpcChannelBuffer *_pRpcChannelBuffer,
	PRPC_MESSAGE _pRpcMessage,
	DWORD *_pdwStubPhase);


/* [id][helpstring][propput] */ HRESULT STDMETHODCALLTYPE IAxWinAmbientDispatch_put_LocaleID_Proxy( 
	IAxWinAmbientDispatch * This,
	/* [in] */ LCID lcidLocaleID);


void __RPC_STUB IAxWinAmbientDispatch_put_LocaleID_Stub(
	IRpcStubBuffer *This,
	IRpcChannelBuffer *_pRpcChannelBuffer,
	PRPC_MESSAGE _pRpcMessage,
	DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IAxWinAmbientDispatch_get_LocaleID_Proxy( 
	IAxWinAmbientDispatch * This,
	/* [retval][out] */ LCID *plcidLocaleID);


void __RPC_STUB IAxWinAmbientDispatch_get_LocaleID_Stub(
	IRpcStubBuffer *This,
	IRpcChannelBuffer *_pRpcChannelBuffer,
	PRPC_MESSAGE _pRpcMessage,
	DWORD *_pdwStubPhase);


/* [id][helpstring][propput] */ HRESULT STDMETHODCALLTYPE IAxWinAmbientDispatch_put_UserMode_Proxy( 
	IAxWinAmbientDispatch * This,
	/* [in] */ VARIANT_BOOL bUserMode);


void __RPC_STUB IAxWinAmbientDispatch_put_UserMode_Stub(
	IRpcStubBuffer *This,
	IRpcChannelBuffer *_pRpcChannelBuffer,
	PRPC_MESSAGE _pRpcMessage,
	DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IAxWinAmbientDispatch_get_UserMode_Proxy( 
	IAxWinAmbientDispatch * This,
	/* [retval][out] */ VARIANT_BOOL *pbUserMode);


void __RPC_STUB IAxWinAmbientDispatch_get_UserMode_Stub(
	IRpcStubBuffer *This,
	IRpcChannelBuffer *_pRpcChannelBuffer,
	PRPC_MESSAGE _pRpcMessage,
	DWORD *_pdwStubPhase);


/* [id][helpstring][propput] */ HRESULT STDMETHODCALLTYPE IAxWinAmbientDispatch_put_DisplayAsDefault_Proxy( 
	IAxWinAmbientDispatch * This,
	/* [in] */ VARIANT_BOOL bDisplayAsDefault);


void __RPC_STUB IAxWinAmbientDispatch_put_DisplayAsDefault_Stub(
	IRpcStubBuffer *This,
	IRpcChannelBuffer *_pRpcChannelBuffer,
	PRPC_MESSAGE _pRpcMessage,
	DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IAxWinAmbientDispatch_get_DisplayAsDefault_Proxy( 
	IAxWinAmbientDispatch * This,
	/* [retval][out] */ VARIANT_BOOL *pbDisplayAsDefault);


void __RPC_STUB IAxWinAmbientDispatch_get_DisplayAsDefault_Stub(
	IRpcStubBuffer *This,
	IRpcChannelBuffer *_pRpcChannelBuffer,
	PRPC_MESSAGE _pRpcMessage,
	DWORD *_pdwStubPhase);


/* [id][helpstring][propput] */ HRESULT STDMETHODCALLTYPE IAxWinAmbientDispatch_put_Font_Proxy( 
	IAxWinAmbientDispatch * This,
	/* [in] */ IFontDisp *pFont);


void __RPC_STUB IAxWinAmbientDispatch_put_Font_Stub(
	IRpcStubBuffer *This,
	IRpcChannelBuffer *_pRpcChannelBuffer,
	PRPC_MESSAGE _pRpcMessage,
	DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IAxWinAmbientDispatch_get_Font_Proxy( 
	IAxWinAmbientDispatch * This,
	/* [retval][out] */ IFontDisp **pFont);


void __RPC_STUB IAxWinAmbientDispatch_get_Font_Stub(
	IRpcStubBuffer *This,
	IRpcChannelBuffer *_pRpcChannelBuffer,
	PRPC_MESSAGE _pRpcMessage,
	DWORD *_pdwStubPhase);


/* [id][helpstring][propput] */ HRESULT STDMETHODCALLTYPE IAxWinAmbientDispatch_put_MessageReflect_Proxy( 
	IAxWinAmbientDispatch * This,
	/* [in] */ VARIANT_BOOL bMsgReflect);


void __RPC_STUB IAxWinAmbientDispatch_put_MessageReflect_Stub(
	IRpcStubBuffer *This,
	IRpcChannelBuffer *_pRpcChannelBuffer,
	PRPC_MESSAGE _pRpcMessage,
	DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IAxWinAmbientDispatch_get_MessageReflect_Proxy( 
	IAxWinAmbientDispatch * This,
	/* [retval][out] */ VARIANT_BOOL *pbMsgReflect);


void __RPC_STUB IAxWinAmbientDispatch_get_MessageReflect_Stub(
	IRpcStubBuffer *This,
	IRpcChannelBuffer *_pRpcChannelBuffer,
	PRPC_MESSAGE _pRpcMessage,
	DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IAxWinAmbientDispatch_get_ShowGrabHandles_Proxy( 
	IAxWinAmbientDispatch * This,
	/* [retval][out] */ VARIANT_BOOL *pbShowGrabHandles);


void __RPC_STUB IAxWinAmbientDispatch_get_ShowGrabHandles_Stub(
	IRpcStubBuffer *This,
	IRpcChannelBuffer *_pRpcChannelBuffer,
	PRPC_MESSAGE _pRpcMessage,
	DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IAxWinAmbientDispatch_get_ShowHatching_Proxy( 
	IAxWinAmbientDispatch * This,
	/* [retval][out] */ VARIANT_BOOL *pbShowHatching);


void __RPC_STUB IAxWinAmbientDispatch_get_ShowHatching_Stub(
	IRpcStubBuffer *This,
	IRpcChannelBuffer *_pRpcChannelBuffer,
	PRPC_MESSAGE _pRpcMessage,
	DWORD *_pdwStubPhase);


/* [helpstring][propput] */ HRESULT STDMETHODCALLTYPE IAxWinAmbientDispatch_put_DocHostFlags_Proxy( 
	IAxWinAmbientDispatch * This,
	/* [in] */ DWORD dwDocHostFlags);


void __RPC_STUB IAxWinAmbientDispatch_put_DocHostFlags_Stub(
	IRpcStubBuffer *This,
	IRpcChannelBuffer *_pRpcChannelBuffer,
	PRPC_MESSAGE _pRpcMessage,
	DWORD *_pdwStubPhase);


/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE IAxWinAmbientDispatch_get_DocHostFlags_Proxy( 
	IAxWinAmbientDispatch * This,
	/* [retval][out] */ DWORD *pdwDocHostFlags);


void __RPC_STUB IAxWinAmbientDispatch_get_DocHostFlags_Stub(
	IRpcStubBuffer *This,
	IRpcChannelBuffer *_pRpcChannelBuffer,
	PRPC_MESSAGE _pRpcMessage,
	DWORD *_pdwStubPhase);


/* [helpstring][propput] */ HRESULT STDMETHODCALLTYPE IAxWinAmbientDispatch_put_DocHostDoubleClickFlags_Proxy( 
	IAxWinAmbientDispatch * This,
	/* [in] */ DWORD dwDocHostDoubleClickFlags);


void __RPC_STUB IAxWinAmbientDispatch_put_DocHostDoubleClickFlags_Stub(
	IRpcStubBuffer *This,
	IRpcChannelBuffer *_pRpcChannelBuffer,
	PRPC_MESSAGE _pRpcMessage,
	DWORD *_pdwStubPhase);


/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE IAxWinAmbientDispatch_get_DocHostDoubleClickFlags_Proxy( 
	IAxWinAmbientDispatch * This,
	/* [retval][out] */ DWORD *pdwDocHostDoubleClickFlags);


void __RPC_STUB IAxWinAmbientDispatch_get_DocHostDoubleClickFlags_Stub(
	IRpcStubBuffer *This,
	IRpcChannelBuffer *_pRpcChannelBuffer,
	PRPC_MESSAGE _pRpcMessage,
	DWORD *_pdwStubPhase);


/* [helpstring][propput] */ HRESULT STDMETHODCALLTYPE IAxWinAmbientDispatch_put_AllowContextMenu_Proxy( 
	IAxWinAmbientDispatch * This,
	/* [in] */ VARIANT_BOOL bAllowContextMenu);


void __RPC_STUB IAxWinAmbientDispatch_put_AllowContextMenu_Stub(
	IRpcStubBuffer *This,
	IRpcChannelBuffer *_pRpcChannelBuffer,
	PRPC_MESSAGE _pRpcMessage,
	DWORD *_pdwStubPhase);


/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE IAxWinAmbientDispatch_get_AllowContextMenu_Proxy( 
	IAxWinAmbientDispatch * This,
	/* [retval][out] */ VARIANT_BOOL *pbAllowContextMenu);


void __RPC_STUB IAxWinAmbientDispatch_get_AllowContextMenu_Stub(
	IRpcStubBuffer *This,
	IRpcChannelBuffer *_pRpcChannelBuffer,
	PRPC_MESSAGE _pRpcMessage,
	DWORD *_pdwStubPhase);


/* [helpstring][propput] */ HRESULT STDMETHODCALLTYPE IAxWinAmbientDispatch_put_AllowShowUI_Proxy( 
	IAxWinAmbientDispatch * This,
	/* [in] */ VARIANT_BOOL bAllowShowUI);


void __RPC_STUB IAxWinAmbientDispatch_put_AllowShowUI_Stub(
	IRpcStubBuffer *This,
	IRpcChannelBuffer *_pRpcChannelBuffer,
	PRPC_MESSAGE _pRpcMessage,
	DWORD *_pdwStubPhase);


/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE IAxWinAmbientDispatch_get_AllowShowUI_Proxy( 
	IAxWinAmbientDispatch * This,
	/* [retval][out] */ VARIANT_BOOL *pbAllowShowUI);


void __RPC_STUB IAxWinAmbientDispatch_get_AllowShowUI_Stub(
	IRpcStubBuffer *This,
	IRpcChannelBuffer *_pRpcChannelBuffer,
	PRPC_MESSAGE _pRpcMessage,
	DWORD *_pdwStubPhase);


/* [helpstring][propput] */ HRESULT STDMETHODCALLTYPE IAxWinAmbientDispatch_put_OptionKeyPath_Proxy( 
	IAxWinAmbientDispatch * This,
	/* [in] */ BSTR bstrOptionKeyPath);


void __RPC_STUB IAxWinAmbientDispatch_put_OptionKeyPath_Stub(
	IRpcStubBuffer *This,
	IRpcChannelBuffer *_pRpcChannelBuffer,
	PRPC_MESSAGE _pRpcMessage,
	DWORD *_pdwStubPhase);


/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE IAxWinAmbientDispatch_get_OptionKeyPath_Proxy( 
	IAxWinAmbientDispatch * This,
	/* [retval][out] */ BSTR *pbstrOptionKeyPath);


void __RPC_STUB IAxWinAmbientDispatch_get_OptionKeyPath_Stub(
	IRpcStubBuffer *This,
	IRpcChannelBuffer *_pRpcChannelBuffer,
	PRPC_MESSAGE _pRpcMessage,
	DWORD *_pdwStubPhase);



#endif 	/* __IAxWinAmbientDispatch_INTERFACE_DEFINED__ */


#ifndef __IAxWinAmbientDispatchEx_INTERFACE_DEFINED__
#define __IAxWinAmbientDispatchEx_INTERFACE_DEFINED__

/* interface IAxWinAmbientDispatchEx */
/* [unique][helpstring][uuid][dual][object] */ 


EXTERN_C const IID IID_IAxWinAmbientDispatchEx;

#if defined(__cplusplus) && !defined(CINTERFACE)

	MIDL_INTERFACE("B2D0778B-AC99-4c58-A5C8-E7724E5316B5")
	IAxWinAmbientDispatchEx : public IAxWinAmbientDispatch
	{
	public:
		virtual /* [id] */ HRESULT STDMETHODCALLTYPE SetAmbientDispatch( 
			/* [in] */ IDispatch *pDispatch) = 0;

	};

#else 	/* C style interface */

	typedef struct IAxWinAmbientDispatchExVtbl
	{
		BEGIN_INTERFACE

		HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
			IAxWinAmbientDispatchEx * This,
			/* [in] */ REFIID riid,
			/* [iid_is][out] */ void **ppvObject);

		ULONG ( STDMETHODCALLTYPE *AddRef )( 
			IAxWinAmbientDispatchEx * This);

		ULONG ( STDMETHODCALLTYPE *Release )( 
			IAxWinAmbientDispatchEx * This);

		HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
			IAxWinAmbientDispatchEx * This,
			/* [out] */ UINT *pctinfo);

		HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
			IAxWinAmbientDispatchEx * This,
			/* [in] */ UINT iTInfo,
			/* [in] */ LCID lcid,
			/* [out] */ ITypeInfo **ppTInfo);

		HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
			IAxWinAmbientDispatchEx * This,
			/* [in] */ REFIID riid,
			/* [size_is][in] */ _In_count_(cNames) LPOLESTR *rgszNames,
			/* [in] */ UINT cNames,
			/* [in] */ LCID lcid,
			/* [size_is][out] */ DISPID *rgDispId);

		/* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
			IAxWinAmbientDispatchEx * This,
			/* [in] */ DISPID dispIdMember,
			/* [in] */ REFIID riid,
			/* [in] */ LCID lcid,
			/* [in] */ WORD wFlags,
			/* [out][in] */ DISPPARAMS *pDispParams,
			/* [out] */ VARIANT *pVarResult,
			/* [out] */ EXCEPINFO *pExcepInfo,
			/* [out] */ UINT *puArgErr);

		/* [helpstring][propput] */ HRESULT ( STDMETHODCALLTYPE *put_AllowWindowlessActivation )( 
			IAxWinAmbientDispatchEx * This,
			/* [in] */ VARIANT_BOOL bCanWindowlessActivate);

		/* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_AllowWindowlessActivation )( 
			IAxWinAmbientDispatchEx * This,
			/* [retval][out] */ VARIANT_BOOL *pbCanWindowlessActivate);

		/* [id][helpstring][propput] */ HRESULT ( STDMETHODCALLTYPE *put_BackColor )( 
			IAxWinAmbientDispatchEx * This,
			/* [in] */ OLE_COLOR clrBackground);

		/* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_BackColor )( 
			IAxWinAmbientDispatchEx * This,
			/* [retval][out] */ OLE_COLOR *pclrBackground);

		/* [id][helpstring][propput] */ HRESULT ( STDMETHODCALLTYPE *put_ForeColor )( 
			IAxWinAmbientDispatchEx * This,
			/* [in] */ OLE_COLOR clrForeground);

		/* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_ForeColor )( 
			IAxWinAmbientDispatchEx * This,
			/* [retval][out] */ OLE_COLOR *pclrForeground);

		/* [id][helpstring][propput] */ HRESULT ( STDMETHODCALLTYPE *put_LocaleID )( 
			IAxWinAmbientDispatchEx * This,
			/* [in] */ LCID lcidLocaleID);

		/* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_LocaleID )( 
			IAxWinAmbientDispatchEx * This,
			/* [retval][out] */ LCID *plcidLocaleID);

		/* [id][helpstring][propput] */ HRESULT ( STDMETHODCALLTYPE *put_UserMode )( 
			IAxWinAmbientDispatchEx * This,
			/* [in] */ VARIANT_BOOL bUserMode);

		/* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_UserMode )( 
			IAxWinAmbientDispatchEx * This,
			/* [retval][out] */ VARIANT_BOOL *pbUserMode);

		/* [id][helpstring][propput] */ HRESULT ( STDMETHODCALLTYPE *put_DisplayAsDefault )( 
			IAxWinAmbientDispatchEx * This,
			/* [in] */ VARIANT_BOOL bDisplayAsDefault);

		/* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_DisplayAsDefault )( 
			IAxWinAmbientDispatchEx * This,
			/* [retval][out] */ VARIANT_BOOL *pbDisplayAsDefault);

		/* [id][helpstring][propput] */ HRESULT ( STDMETHODCALLTYPE *put_Font )( 
			IAxWinAmbientDispatchEx * This,
			/* [in] */ IFontDisp *pFont);

		/* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Font )( 
			IAxWinAmbientDispatchEx * This,
			/* [retval][out] */ IFontDisp **pFont);

		/* [id][helpstring][propput] */ HRESULT ( STDMETHODCALLTYPE *put_MessageReflect )( 
			IAxWinAmbientDispatchEx * This,
			/* [in] */ VARIANT_BOOL bMsgReflect);

		/* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_MessageReflect )( 
			IAxWinAmbientDispatchEx * This,
			/* [retval][out] */ VARIANT_BOOL *pbMsgReflect);

		/* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_ShowGrabHandles )( 
			IAxWinAmbientDispatchEx * This,
			/* [retval][out] */ VARIANT_BOOL *pbShowGrabHandles);

		/* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_ShowHatching )( 
			IAxWinAmbientDispatchEx * This,
			/* [retval][out] */ VARIANT_BOOL *pbShowHatching);

		/* [helpstring][propput] */ HRESULT ( STDMETHODCALLTYPE *put_DocHostFlags )( 
			IAxWinAmbientDispatchEx * This,
			/* [in] */ DWORD dwDocHostFlags);

		/* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_DocHostFlags )( 
			IAxWinAmbientDispatchEx * This,
			/* [retval][out] */ DWORD *pdwDocHostFlags);

		/* [helpstring][propput] */ HRESULT ( STDMETHODCALLTYPE *put_DocHostDoubleClickFlags )( 
			IAxWinAmbientDispatchEx * This,
			/* [in] */ DWORD dwDocHostDoubleClickFlags);

		/* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_DocHostDoubleClickFlags )( 
			IAxWinAmbientDispatchEx * This,
			/* [retval][out] */ DWORD *pdwDocHostDoubleClickFlags);

		/* [helpstring][propput] */ HRESULT ( STDMETHODCALLTYPE *put_AllowContextMenu )( 
			IAxWinAmbientDispatchEx * This,
			/* [in] */ VARIANT_BOOL bAllowContextMenu);

		/* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_AllowContextMenu )( 
			IAxWinAmbientDispatchEx * This,
			/* [retval][out] */ VARIANT_BOOL *pbAllowContextMenu);

		/* [helpstring][propput] */ HRESULT ( STDMETHODCALLTYPE *put_AllowShowUI )( 
			IAxWinAmbientDispatchEx * This,
			/* [in] */ VARIANT_BOOL bAllowShowUI);

		/* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_AllowShowUI )( 
			IAxWinAmbientDispatchEx * This,
			/* [retval][out] */ VARIANT_BOOL *pbAllowShowUI);

		/* [helpstring][propput] */ HRESULT ( STDMETHODCALLTYPE *put_OptionKeyPath )( 
			IAxWinAmbientDispatchEx * This,
			/* [in] */ BSTR bstrOptionKeyPath);

		/* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_OptionKeyPath )( 
			IAxWinAmbientDispatchEx * This,
			/* [retval][out] */ BSTR *pbstrOptionKeyPath);

		/* [id] */ HRESULT ( STDMETHODCALLTYPE *SetAmbientDispatch )( 
			IAxWinAmbientDispatchEx * This,
			/* [in] */ IDispatch *pDispatch);

		END_INTERFACE
	} IAxWinAmbientDispatchExVtbl;

	interface IAxWinAmbientDispatchEx
	{
		CONST_VTBL struct IAxWinAmbientDispatchExVtbl *lpVtbl;
	};



#ifdef COBJMACROS


#define IAxWinAmbientDispatchEx_QueryInterface(This,riid,ppvObject)	\
	(This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IAxWinAmbientDispatchEx_AddRef(This)	\
	(This)->lpVtbl -> AddRef(This)

#define IAxWinAmbientDispatchEx_Release(This)	\
	(This)->lpVtbl -> Release(This)


#define IAxWinAmbientDispatchEx_GetTypeInfoCount(This,pctinfo)	\
	(This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IAxWinAmbientDispatchEx_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
	(This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IAxWinAmbientDispatchEx_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
	(This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IAxWinAmbientDispatchEx_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
	(This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IAxWinAmbientDispatchEx_put_AllowWindowlessActivation(This,bCanWindowlessActivate)	\
	(This)->lpVtbl -> put_AllowWindowlessActivation(This,bCanWindowlessActivate)

#define IAxWinAmbientDispatchEx_get_AllowWindowlessActivation(This,pbCanWindowlessActivate)	\
	(This)->lpVtbl -> get_AllowWindowlessActivation(This,pbCanWindowlessActivate)

#define IAxWinAmbientDispatchEx_put_BackColor(This,clrBackground)	\
	(This)->lpVtbl -> put_BackColor(This,clrBackground)

#define IAxWinAmbientDispatchEx_get_BackColor(This,pclrBackground)	\
	(This)->lpVtbl -> get_BackColor(This,pclrBackground)

#define IAxWinAmbientDispatchEx_put_ForeColor(This,clrForeground)	\
	(This)->lpVtbl -> put_ForeColor(This,clrForeground)

#define IAxWinAmbientDispatchEx_get_ForeColor(This,pclrForeground)	\
	(This)->lpVtbl -> get_ForeColor(This,pclrForeground)

#define IAxWinAmbientDispatchEx_put_LocaleID(This,lcidLocaleID)	\
	(This)->lpVtbl -> put_LocaleID(This,lcidLocaleID)

#define IAxWinAmbientDispatchEx_get_LocaleID(This,plcidLocaleID)	\
	(This)->lpVtbl -> get_LocaleID(This,plcidLocaleID)

#define IAxWinAmbientDispatchEx_put_UserMode(This,bUserMode)	\
	(This)->lpVtbl -> put_UserMode(This,bUserMode)

#define IAxWinAmbientDispatchEx_get_UserMode(This,pbUserMode)	\
	(This)->lpVtbl -> get_UserMode(This,pbUserMode)

#define IAxWinAmbientDispatchEx_put_DisplayAsDefault(This,bDisplayAsDefault)	\
	(This)->lpVtbl -> put_DisplayAsDefault(This,bDisplayAsDefault)

#define IAxWinAmbientDispatchEx_get_DisplayAsDefault(This,pbDisplayAsDefault)	\
	(This)->lpVtbl -> get_DisplayAsDefault(This,pbDisplayAsDefault)

#define IAxWinAmbientDispatchEx_put_Font(This,pFont)	\
	(This)->lpVtbl -> put_Font(This,pFont)

#define IAxWinAmbientDispatchEx_get_Font(This,pFont)	\
	(This)->lpVtbl -> get_Font(This,pFont)

#define IAxWinAmbientDispatchEx_put_MessageReflect(This,bMsgReflect)	\
	(This)->lpVtbl -> put_MessageReflect(This,bMsgReflect)

#define IAxWinAmbientDispatchEx_get_MessageReflect(This,pbMsgReflect)	\
	(This)->lpVtbl -> get_MessageReflect(This,pbMsgReflect)

#define IAxWinAmbientDispatchEx_get_ShowGrabHandles(This,pbShowGrabHandles)	\
	(This)->lpVtbl -> get_ShowGrabHandles(This,pbShowGrabHandles)

#define IAxWinAmbientDispatchEx_get_ShowHatching(This,pbShowHatching)	\
	(This)->lpVtbl -> get_ShowHatching(This,pbShowHatching)

#define IAxWinAmbientDispatchEx_put_DocHostFlags(This,dwDocHostFlags)	\
	(This)->lpVtbl -> put_DocHostFlags(This,dwDocHostFlags)

#define IAxWinAmbientDispatchEx_get_DocHostFlags(This,pdwDocHostFlags)	\
	(This)->lpVtbl -> get_DocHostFlags(This,pdwDocHostFlags)

#define IAxWinAmbientDispatchEx_put_DocHostDoubleClickFlags(This,dwDocHostDoubleClickFlags)	\
	(This)->lpVtbl -> put_DocHostDoubleClickFlags(This,dwDocHostDoubleClickFlags)

#define IAxWinAmbientDispatchEx_get_DocHostDoubleClickFlags(This,pdwDocHostDoubleClickFlags)	\
	(This)->lpVtbl -> get_DocHostDoubleClickFlags(This,pdwDocHostDoubleClickFlags)

#define IAxWinAmbientDispatchEx_put_AllowContextMenu(This,bAllowContextMenu)	\
	(This)->lpVtbl -> put_AllowContextMenu(This,bAllowContextMenu)

#define IAxWinAmbientDispatchEx_get_AllowContextMenu(This,pbAllowContextMenu)	\
	(This)->lpVtbl -> get_AllowContextMenu(This,pbAllowContextMenu)

#define IAxWinAmbientDispatchEx_put_AllowShowUI(This,bAllowShowUI)	\
	(This)->lpVtbl -> put_AllowShowUI(This,bAllowShowUI)

#define IAxWinAmbientDispatchEx_get_AllowShowUI(This,pbAllowShowUI)	\
	(This)->lpVtbl -> get_AllowShowUI(This,pbAllowShowUI)

#define IAxWinAmbientDispatchEx_put_OptionKeyPath(This,bstrOptionKeyPath)	\
	(This)->lpVtbl -> put_OptionKeyPath(This,bstrOptionKeyPath)

#define IAxWinAmbientDispatchEx_get_OptionKeyPath(This,pbstrOptionKeyPath)	\
	(This)->lpVtbl -> get_OptionKeyPath(This,pbstrOptionKeyPath)


#define IAxWinAmbientDispatchEx_SetAmbientDispatch(This,pDispatch)	\
	(This)->lpVtbl -> SetAmbientDispatch(This,pDispatch)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [id] */ HRESULT STDMETHODCALLTYPE IAxWinAmbientDispatchEx_SetAmbientDispatch_Proxy( 
	IAxWinAmbientDispatchEx * This,
	/* [in] */ IDispatch *pDispatch);


void __RPC_STUB IAxWinAmbientDispatchEx_SetAmbientDispatch_Stub(
	IRpcStubBuffer *This,
	IRpcChannelBuffer *_pRpcChannelBuffer,
	PRPC_MESSAGE _pRpcMessage,
	DWORD *_pdwStubPhase);



#endif 	/* __IAxWinAmbientDispatchEx_INTERFACE_DEFINED__ */


#ifndef __IInternalConnection_INTERFACE_DEFINED__
#define __IInternalConnection_INTERFACE_DEFINED__

/* interface IInternalConnection */
/* [object][unique][helpstring][uuid] */ 


EXTERN_C const IID IID_IInternalConnection;

#if defined(__cplusplus) && !defined(CINTERFACE)

	MIDL_INTERFACE("72AD0770-6A9F-11d1-BCEC-0060088F444E")
	IInternalConnection : public IUnknown
	{
	public:
		virtual HRESULT STDMETHODCALLTYPE AddConnection( void) = 0;

		virtual HRESULT STDMETHODCALLTYPE ReleaseConnection( void) = 0;

	};

#else 	/* C style interface */

	typedef struct IInternalConnectionVtbl
	{
		BEGIN_INTERFACE

		HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
			IInternalConnection * This,
			/* [in] */ REFIID riid,
			/* [iid_is][out] */ void **ppvObject);

		ULONG ( STDMETHODCALLTYPE *AddRef )( 
			IInternalConnection * This);

		ULONG ( STDMETHODCALLTYPE *Release )( 
			IInternalConnection * This);

		HRESULT ( STDMETHODCALLTYPE *AddConnection )( 
			IInternalConnection * This);

		HRESULT ( STDMETHODCALLTYPE *ReleaseConnection )( 
			IInternalConnection * This);

		END_INTERFACE
	} IInternalConnectionVtbl;

	interface IInternalConnection
	{
		CONST_VTBL struct IInternalConnectionVtbl *lpVtbl;
	};



#ifdef COBJMACROS


#define IInternalConnection_QueryInterface(This,riid,ppvObject)	\
	(This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IInternalConnection_AddRef(This)	\
	(This)->lpVtbl -> AddRef(This)

#define IInternalConnection_Release(This)	\
	(This)->lpVtbl -> Release(This)


#define IInternalConnection_AddConnection(This)	\
	(This)->lpVtbl -> AddConnection(This)

#define IInternalConnection_ReleaseConnection(This)	\
	(This)->lpVtbl -> ReleaseConnection(This)

#endif /* COBJMACROS */


#endif 	/* C style interface */

HRESULT STDMETHODCALLTYPE IInternalConnection_AddConnection_Proxy( 
	IInternalConnection * This);

void __RPC_STUB IInternalConnection_AddConnection_Stub(
	IRpcStubBuffer *This,
	IRpcChannelBuffer *_pRpcChannelBuffer,
	PRPC_MESSAGE _pRpcMessage,
	DWORD *_pdwStubPhase);

HRESULT STDMETHODCALLTYPE IInternalConnection_ReleaseConnection_Proxy( 
	IInternalConnection * This);


void __RPC_STUB IInternalConnection_ReleaseConnection_Stub(
	IRpcStubBuffer *This,
	IRpcChannelBuffer *_pRpcChannelBuffer,
	PRPC_MESSAGE _pRpcMessage,
	DWORD *_pdwStubPhase);

#endif 	/* __IInternalConnection_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_atliface_0257 */
/* [local] */ 


#pragma pack(push,_ATL_PACKING)
namespace ATL
{
#ifdef __cplusplus
#include <atldef.h>
#else
#define ATLAPI EXTERN_C HRESULT __declspec(dllimport) __stdcall
#define ATLAPI_(x) EXTERN_C __declspec(dllimport) x __stdcall
#define ATLINLINE
#endif	// __cplusplus

ATLAPI_(INT_PTR) AtlAxDialogBoxW(
	_In_ HINSTANCE hInstance, 
	_In_z_ LPCWSTR lpTemplateName,
	_In_ HWND hWndParent, 
	_In_ DLGPROC lpDialogProc, 
	_In_ LPARAM dwInitParam);

ATLAPI_(INT_PTR) AtlAxDialogBoxA(
	_In_ HINSTANCE hInstance, 
	_In_z_ LPCSTR lpTemplateName, 
	_In_ HWND hWndParent, 
	_In_ DLGPROC lpDialogProc, 
	_In_ LPARAM dwInitParam);

#ifdef UNICODE
#define AtlAxDialogBox AtlAxDialogBoxW
#else
#define AtlAxDialogBox AtlAxDialogBoxA
#endif

ATLAPI_(HWND) AtlAxCreateDialogW(
	_In_ HINSTANCE hInstance,
	_In_z_ LPCWSTR lpTemplateName, 
	_In_ HWND hWndParent, 
	_In_ DLGPROC lpDialogProc, 
	_In_ LPARAM dwInitParam);

ATLAPI_(HWND) AtlAxCreateDialogA(
	_In_ HINSTANCE hInstance, 
	_In_z_ LPCSTR lpTemplateName,
	_In_ HWND hWndParent, 
	_In_ DLGPROC lpDialogProc, 
	_In_ LPARAM dwInitParam);

#ifdef UNICODE
#define AtlAxCreateDialog AtlAxCreateDialogW
#else
#define AtlAxCreateDialog AtlAxCreateDialogA
#endif

ATLAPI AtlAxCreateControl(
	_In_z_ LPCOLESTR lpszName, 
	_In_ HWND hWnd, 
	_Inout_opt_ IStream* pStream, 
	_Deref_out_ IUnknown** ppUnkContainer);

#ifdef __cplusplus

ATLAPI AtlAxCreateControlEx(
	_In_z_ LPCOLESTR lpszName, 
	_In_ HWND hWnd, 
	_Inout_opt_ IStream* pStream,
	_Deref_opt_out_ IUnknown** ppUnkContainer,
	_Deref_opt_out_ IUnknown** ppUnkControl,
	_In_ REFIID iidSink=IID_NULL, 
	_Inout_opt_ IUnknown* punkSink=NULL);

ATLAPI AtlAxCreateControlLic(
	_In_z_ LPCOLESTR lpszName,
	_In_ HWND hWnd,
	_Inout_opt_ IStream* pStream, 
	_Deref_opt_out_ IUnknown** ppUnkContainer, 
	_In_opt_z_ BSTR bstrLic = NULL);

ATLAPI AtlAxCreateControlLicEx(
	_In_z_ LPCOLESTR lpszName,
	_In_ HWND hWnd, 
	_Inout_opt_ IStream* pStream, 
	_Deref_opt_out_ IUnknown** ppUnkContainer, 
	_Deref_opt_out_ IUnknown** ppUnkControl, 
	_In_ REFIID iidSink=IID_NULL, 
	_Inout_opt_ IUnknown* punkSink=NULL, 
	_In_opt_z_ BSTR bstrLic = NULL);

#else

ATLAPI AtlAxCreateControlEx(
	_In_z_ LPCOLESTR lpszName, 
	_In_ HWND hWnd, 
	_Inout_opt_ IStream* pStream, 
	_Deref_opt_out_ IUnknown** ppUnkContainer,
	_Deref_opt_out_ IUnknown** ppUnkControl,
	_In_ REFIID iidSink, 
	_Inout_opt_ IUnknown* punkSink);

ATLAPI AtlAxCreateControlLic(
	_In_z_ LPCOLESTR lpszName,
	_In_ HWND hWnd, 
	_Inout_opt_ IStream* pStream, 
	_Deref_opt_out_ IUnknown** ppUnkContainer,
	_In_opt_z_ BSTR bstrLic);

ATLAPI AtlAxCreateControlLicEx(
	_In_z_ LPCOLESTR lpszName, 
	_Inout_ HWND hWnd, 
	_In_opt_ IStream* pStream, 
	_Deref_opt_out_ IUnknown** ppUnkContainer, 
	_Deref_opt_out_ IUnknown** ppUnkControl, 
	_In_ REFIID iidSink,
	_Inout_opt_ IUnknown* punkSink,
	_In_opt_z_ BSTR bstrLic);
	
#endif	// __cplusplus
	
ATLAPI AtlAxAttachControl(
	_Inout_ IUnknown* pControl,
	_In_ HWND hWnd, 
	_Deref_opt_out_ IUnknown** ppUnkContainer);

ATLAPI_(BOOL) AtlAxWinInit();

ATLAPI AtlAxGetHost(
	_In_ HWND h, 
	_Deref_out_ IUnknown** pp);

ATLAPI AtlAxGetControl(
	_In_ HWND h, 
	_Deref_out_ IUnknown** pp);

}; //namespace ATL
#pragma pack(pop)

extern RPC_IF_HANDLE __MIDL_itf_atliface_0257_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_atliface_0257_v0_0_s_ifspec;

#ifndef __IAccessibleProxy_INTERFACE_DEFINED__
#define __IAccessibleProxy_INTERFACE_DEFINED__

/* interface IAccessibleProxy */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_IAccessibleProxy;

#if defined(__cplusplus) && !defined(CINTERFACE)

	MIDL_INTERFACE("7A7D9DCF-B7A1-4019-9031-258268846980")
	IAccessibleProxy : public IUnknown
	{
	public:
		virtual HRESULT STDMETHODCALLTYPE SetServer( 
			/* [in] */ IAccessible *pAccessible,
			/* [in] */ IAccessibleServer *pServer) = 0;

	};

#else 	/* C style interface */

	typedef struct IAccessibleProxyVtbl
	{
		BEGIN_INTERFACE

		HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
			IAccessibleProxy * This,
			/* [in] */ REFIID riid,
			/* [iid_is][out] */ void **ppvObject);

		ULONG ( STDMETHODCALLTYPE *AddRef )( 
			IAccessibleProxy * This);

		ULONG ( STDMETHODCALLTYPE *Release )( 
			IAccessibleProxy * This);

		HRESULT ( STDMETHODCALLTYPE *SetServer )( 
			IAccessibleProxy * This,
			/* [in] */ IAccessible *pAccessible,
			/* [in] */ IAccessibleServer *pServer);

		END_INTERFACE
	} IAccessibleProxyVtbl;

	interface IAccessibleProxy
	{
		CONST_VTBL struct IAccessibleProxyVtbl *lpVtbl;
	};



#ifdef COBJMACROS


#define IAccessibleProxy_QueryInterface(This,riid,ppvObject)	\
	(This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IAccessibleProxy_AddRef(This)	\
	(This)->lpVtbl -> AddRef(This)

#define IAccessibleProxy_Release(This)	\
	(This)->lpVtbl -> Release(This)


#define IAccessibleProxy_SetServer(This,pAccessible,pServer)	\
	(This)->lpVtbl -> SetServer(This,pAccessible,pServer)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IAccessibleProxy_SetServer_Proxy( 
	IAccessibleProxy * This,
	/* [in] */ IAccessible *pAccessible,
	/* [in] */ IAccessibleServer *pServer);


void __RPC_STUB IAccessibleProxy_SetServer_Stub(
	IRpcStubBuffer *This,
	IRpcChannelBuffer *_pRpcChannelBuffer,
	PRPC_MESSAGE _pRpcMessage,
	DWORD *_pdwStubPhase);



#endif 	/* __IAccessibleProxy_INTERFACE_DEFINED__ */


#ifndef __IAccessibleServer_INTERFACE_DEFINED__
#define __IAccessibleServer_INTERFACE_DEFINED__

/* interface IAccessibleServer */
/* [unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IAccessibleServer;

#if defined(__cplusplus) && !defined(CINTERFACE)

	MIDL_INTERFACE("52C8FB5E-D779-4e77-AE9F-F611FA7E9D7A")
	IAccessibleServer : public IUnknown
	{
	public:
		virtual HRESULT STDMETHODCALLTYPE SetProxy( 
			/* [in] */ IAccessibleProxy *pUnknown) = 0;

		virtual HRESULT STDMETHODCALLTYPE GetHWND( 
			/* [out] */ HWND *phWnd) = 0;

		virtual HRESULT STDMETHODCALLTYPE GetEnumVariant( 
			/* [out] */ IEnumVARIANT **ppEnumVariant) = 0;

	};

#else 	/* C style interface */

	typedef struct IAccessibleServerVtbl
	{
		BEGIN_INTERFACE

		HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
			IAccessibleServer * This,
			/* [in] */ REFIID riid,
			/* [iid_is][out] */ void **ppvObject);

		ULONG ( STDMETHODCALLTYPE *AddRef )( 
			IAccessibleServer * This);

		ULONG ( STDMETHODCALLTYPE *Release )( 
			IAccessibleServer * This);

		HRESULT ( STDMETHODCALLTYPE *SetProxy )( 
			IAccessibleServer * This,
			/* [in] */ IAccessibleProxy *pUnknown);

		HRESULT ( STDMETHODCALLTYPE *GetHWND )( 
			IAccessibleServer * This,
			/* [out] */ HWND *phWnd);

		HRESULT ( STDMETHODCALLTYPE *GetEnumVariant )( 
			IAccessibleServer * This,
			/* [out] */ IEnumVARIANT **ppEnumVariant);

		END_INTERFACE
	} IAccessibleServerVtbl;

	interface IAccessibleServer
	{
		CONST_VTBL struct IAccessibleServerVtbl *lpVtbl;
	};



#ifdef COBJMACROS


#define IAccessibleServer_QueryInterface(This,riid,ppvObject)	\
	(This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IAccessibleServer_AddRef(This)	\
	(This)->lpVtbl -> AddRef(This)

#define IAccessibleServer_Release(This)	\
	(This)->lpVtbl -> Release(This)


#define IAccessibleServer_SetProxy(This,pUnknown)	\
	(This)->lpVtbl -> SetProxy(This,pUnknown)

#define IAccessibleServer_GetHWND(This,phWnd)	\
	(This)->lpVtbl -> GetHWND(This,phWnd)

#define IAccessibleServer_GetEnumVariant(This,ppEnumVariant)	\
	(This)->lpVtbl -> GetEnumVariant(This,ppEnumVariant)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IAccessibleServer_SetProxy_Proxy( 
	IAccessibleServer * This,
	/* [in] */ IAccessibleProxy *pUnknown);


void __RPC_STUB IAccessibleServer_SetProxy_Stub(
	IRpcStubBuffer *This,
	IRpcChannelBuffer *_pRpcChannelBuffer,
	PRPC_MESSAGE _pRpcMessage,
	DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAccessibleServer_GetHWND_Proxy( 
	IAccessibleServer * This,
	/* [out] */ HWND *phWnd);


void __RPC_STUB IAccessibleServer_GetHWND_Stub(
	IRpcStubBuffer *This,
	IRpcChannelBuffer *_pRpcChannelBuffer,
	PRPC_MESSAGE _pRpcMessage,
	DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAccessibleServer_GetEnumVariant_Proxy( 
	IAccessibleServer * This,
	/* [out] */ IEnumVARIANT **ppEnumVariant);


void __RPC_STUB IAccessibleServer_GetEnumVariant_Stub(
	IRpcStubBuffer *This,
	IRpcChannelBuffer *_pRpcChannelBuffer,
	PRPC_MESSAGE _pRpcMessage,
	DWORD *_pdwStubPhase);



#endif 	/* __IAccessibleServer_INTERFACE_DEFINED__ */


/* Additional Prototypes for ALL interfaces */

unsigned long             __RPC_USER  BSTR_UserSize(     unsigned long *, unsigned long            , BSTR * ); 
unsigned char * __RPC_USER  BSTR_UserMarshal(  unsigned long *, unsigned char *, BSTR * ); 
unsigned char * __RPC_USER  BSTR_UserUnmarshal(unsigned long *, unsigned char *, BSTR * ); 
void                      __RPC_USER  BSTR_UserFree(     unsigned long *, BSTR * ); 

unsigned long             __RPC_USER  HWND_UserSize(     unsigned long *, unsigned long            , HWND * ); 
unsigned char * __RPC_USER  HWND_UserMarshal(  unsigned long *, unsigned char *, HWND * ); 
unsigned char * __RPC_USER  HWND_UserUnmarshal(unsigned long *, unsigned char *, HWND * ); 
void                      __RPC_USER  HWND_UserFree(     unsigned long *, HWND * ); 

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\include\atlhost.h ===
// This is a part of the Active Template Library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Active Template Library Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Active Template Library product.

#ifndef __ATLHOST_H__
#define __ATLHOST_H__

#pragma once

#ifndef _ATL_NO_PRAGMA_WARNINGS
#pragma warning (push)
#pragma warning(disable: 4702) // unreachable code
#pragma warning(disable: 4127) // conditional expression constant
#pragma warning(disable: 4571) //catch(...) blocks compiled with /EHs do NOT catch or re-throw Structured Exceptions
#endif //!_ATL_NO_PRAGMA_WARNINGS

#include <urlmon.h>
#include <mshtml.h>
#include <mshtmhst.h>
#include <exdisp.h>

#ifndef _ATL_AXHOST
#define _ATL_AXHOST
#endif //_ATL_AXHOST

#include <atlwin.h>
#include <atlcom.h>

#ifndef __cplusplus
	#error ATL requires C++ compilation (use a .cpp suffix)
#endif

#ifdef _ATL_NO_HOSTING
	#error atlhost.h requires Hosting support (_ATL_NO_HOSTING is defined)
#endif //_ATL_NO_HOSTING


#pragma pack(push,_ATL_PACKING)
namespace ATL
{
//AtlAxWinTerm is not exported
inline BOOL AtlAxWinTerm()
{
#ifndef _ATL_DLL //don't unregister DLL's version
	UnregisterClass(CAxWindow::GetWndClassName(), _AtlBaseModule.GetModuleInstance());
	UnregisterClass(CAxWindow2::GetWndClassName(), _AtlBaseModule.GetModuleInstance());
#endif
	return TRUE;
}


// Define this to host SHDOCVW rather than MSHTML
#define SHDOCVW

UINT __declspec(selectany) WM_ATLGETHOST = 0;
UINT __declspec(selectany) WM_ATLGETCONTROL = 0;

typedef HRESULT (__stdcall *typeMkParseDisplayName)(
	_In_ IBindCtx*,
	_In_z_ LPCWSTR ,
	_Out_ ULONG*,
	_Out_ LPMONIKER*);
ATLPREFAST_SUPPRESS(6387)
static HRESULT CreateNormalizedObject(
	_In_opt_z_ LPCOLESTR lpszTricsData,
	_In_ REFIID riid,
	_Deref_out_ void** ppvObj,
	_Out_ bool& bWasHTML,
	_In_opt_z_ BSTR bstrLicKey)
{
	ATLASSERT(ppvObj);
	if (ppvObj == NULL)
	{
		return E_POINTER;
	}
	*ppvObj = NULL;

	CLSID clsid;
	HRESULT hr = E_FAIL;

	bWasHTML = false;

	if (lpszTricsData == NULL || lpszTricsData[0] == 0)
	{
		return S_OK;
	}

	// Is it HTML ?
	if ((lpszTricsData[0] == OLECHAR('M') || lpszTricsData[0] == OLECHAR('m')) &&
		(lpszTricsData[1] == OLECHAR('S') || lpszTricsData[1] == OLECHAR('s')) &&
		(lpszTricsData[2] == OLECHAR('H') || lpszTricsData[2] == OLECHAR('h')) &&
		(lpszTricsData[3] == OLECHAR('T') || lpszTricsData[3] == OLECHAR('t')) &&
		(lpszTricsData[4] == OLECHAR('M') || lpszTricsData[4] == OLECHAR('m')) &&
		(lpszTricsData[5] == OLECHAR('L') || lpszTricsData[5] == OLECHAR('l')) &&
		(lpszTricsData[6] == OLECHAR(':')))
	{
		// It's HTML, so let's create mshtml
		hr = CoCreateInstance(__uuidof(HTMLDocument), NULL, CLSCTX_INPROC_SERVER, riid, ppvObj);
		bWasHTML = true;
	}
	// Is it a URL?
	else if (CAtlModule::FindOneOf(COLE2CT(lpszTricsData), _T(":")))
	{
		// URL so let's create shdocvw
		hr = CoCreateInstance(__uuidof(WebBrowser), NULL, CLSCTX_INPROC_SERVER, riid, ppvObj);
		bWasHTML = true;
	}
	// assume ProgID or CLSID
	else
	{
		// Can't be clsid, or progid if length is greater than 255
		if (ocslen(lpszTricsData) < 255)
		{
			if (lpszTricsData[0] == '{') // Is it a CLSID?
			{
				hr = CLSIDFromString((LPOLESTR)lpszTricsData, &clsid);
			}
			else
			{
				hr = CLSIDFromProgID((LPOLESTR)lpszTricsData, &clsid); // How about a ProgID?
			}
		}
		if (SUCCEEDED(hr))
		{
			// If the license key is present
			// Create using IClassFactory2.
            if (::SysStringLen(bstrLicKey) != 0)
			{
				CComPtr<IClassFactory2> spClassFactory;
				hr = CoGetClassObject(clsid, CLSCTX_INPROC_SERVER, NULL, __uuidof(IClassFactory2), (void**)&spClassFactory);
				if (SUCCEEDED(hr))
				{
					hr = spClassFactory->CreateInstanceLic(NULL, NULL, riid, bstrLicKey, ppvObj);
				}
			}
			else
			{
				hr = CoCreateInstance(clsid, NULL, CLSCTX_INPROC_SERVER, riid, ppvObj);
			}
		}
	}
	return hr;
}
ATLPREFAST_UNSUPPRESS()

class ATL_NO_VTABLE CAxFrameWindow :
	public CComObjectRootEx<CComObjectThreadModel>,
	public CWindowImpl<CAxFrameWindow>,
	public IOleInPlaceFrame
{
public:
	CAxFrameWindow()
	{
	}
	void FinalRelease()
	{
		m_spActiveObject.Release();
		if (m_hWnd)
			DestroyWindow();
	}

	DECLARE_POLY_AGGREGATABLE(CAxFrameWindow)

	BEGIN_COM_MAP(CAxFrameWindow)
		COM_INTERFACE_ENTRY(IOleInPlaceFrame)
		COM_INTERFACE_ENTRY(IOleInPlaceUIWindow)
		COM_INTERFACE_ENTRY(IOleWindow)
	END_COM_MAP()

	DECLARE_EMPTY_MSG_MAP()

// IOleWindow
	STDMETHOD(GetWindow)(_Out_ HWND* phwnd)
	{
		ATLASSERT(phwnd != NULL);
		if (phwnd == NULL)
			return E_POINTER;

		if (m_hWnd == NULL)
			Create(NULL, NULL, _T("AXWIN Frame Window"), WS_OVERLAPPEDWINDOW, 0, (UINT)NULL);
		*phwnd = m_hWnd;
		return S_OK;
	}
	STDMETHOD(ContextSensitiveHelp)(_In_ BOOL /*fEnterMode*/)
	{
		return S_OK;
	}

// IOleInPlaceUIWindow
	STDMETHOD(GetBorder)(_In_ LPRECT /*lprectBorder*/)
	{
		return S_OK;
	}

	STDMETHOD(RequestBorderSpace)(_In_ LPCBORDERWIDTHS /*pborderwidths*/)
	{
		return INPLACE_E_NOTOOLSPACE;
	}

	STDMETHOD(SetBorderSpace)(_In_ LPCBORDERWIDTHS /*pborderwidths*/)
	{
		return S_OK;
	}

	STDMETHOD(SetActiveObject)(
		_In_ IOleInPlaceActiveObject* pActiveObject,
		_In_opt_z_ LPCOLESTR /*pszObjName*/)
	{
		m_spActiveObject = pActiveObject;
		return S_OK;
	}

// IOleInPlaceFrameWindow
	STDMETHOD(InsertMenus)(
		_In_ HMENU /*hmenuShared*/,
		_Inout_ LPOLEMENUGROUPWIDTHS /*lpMenuWidths*/)
	{
		return S_OK;
	}

	STDMETHOD(SetMenu)(
		_In_ HMENU /*hmenuShared*/,
		_In_ HOLEMENU /*holemenu*/,
		_In_ HWND /*hwndActiveObject*/)
	{
		return S_OK;
	}

	STDMETHOD(RemoveMenus)(_In_ HMENU /*hmenuShared*/)
	{
		return S_OK;
	}

	STDMETHOD(SetStatusText)(_In_opt_z_ LPCOLESTR /*pszStatusText*/)
	{
		return S_OK;
	}

	STDMETHOD(EnableModeless)(_In_ BOOL /*fEnable*/)
	{
		return S_OK;
	}

	STDMETHOD(TranslateAccelerator)(
		_In_ LPMSG /*lpMsg*/,
		_In_ WORD /*wID*/)
	{
		return S_FALSE;
	}

	CComPtr<IOleInPlaceActiveObject> m_spActiveObject;
};


class ATL_NO_VTABLE CAxUIWindow :
	public CComObjectRootEx<CComObjectThreadModel>,
	public CWindowImpl<CAxUIWindow>,
	public IOleInPlaceUIWindow
{
public:
	CAxUIWindow()
	{
	}

	void FinalRelease()
	{
		m_spActiveObject.Release();
		if (m_hWnd)
			DestroyWindow();
	}

	DECLARE_POLY_AGGREGATABLE(CAxUIWindow)

	BEGIN_COM_MAP(CAxUIWindow)
		COM_INTERFACE_ENTRY(IOleInPlaceUIWindow)
		COM_INTERFACE_ENTRY(IOleWindow)
	END_COM_MAP()

	DECLARE_EMPTY_MSG_MAP()

// IOleWindow
	STDMETHOD(GetWindow)(_Out_ HWND* phwnd)
	{
		ATLENSURE_RETURN(phwnd);
		if (m_hWnd == NULL)
			Create(NULL, NULL, _T("AXWIN UI Window"), WS_OVERLAPPEDWINDOW, 0, (UINT)NULL);
		*phwnd = m_hWnd;
		return S_OK;
	}

	STDMETHOD(ContextSensitiveHelp)(_In_ BOOL /*fEnterMode*/)
	{
		return S_OK;
	}

// IOleInPlaceUIWindow
	STDMETHOD(GetBorder)(_In_ LPRECT /*lprectBorder*/)
	{
		return S_OK;
	}

	STDMETHOD(RequestBorderSpace)(_In_ LPCBORDERWIDTHS /*pborderwidths*/)
	{
		return INPLACE_E_NOTOOLSPACE;
	}

	STDMETHOD(SetBorderSpace)(_In_ LPCBORDERWIDTHS /*pborderwidths*/)
	{
		return S_OK;
	}

	STDMETHOD(SetActiveObject)(
		_In_ IOleInPlaceActiveObject* pActiveObject,
		_In_opt_z_ LPCOLESTR /*pszObjName*/)
	{
		m_spActiveObject = pActiveObject;
		return S_OK;
	}

	CComPtr<IOleInPlaceActiveObject> m_spActiveObject;
};


/////////////////////////////////////////////////////////////////////////////
// CAxHostWindow
// This class is not cocreateable

class ATL_NO_VTABLE CAxHostWindow :
		public CComCoClass<CAxHostWindow , &CLSID_NULL>,
		public CComObjectRootEx<CComSingleThreadModel>,
		public CWindowImpl<CAxHostWindow>,
		public IAxWinHostWindowLic,
		public IOleClientSite,
		public IOleInPlaceSiteWindowless,
		public IOleControlSite,
		public IOleContainer,
		public IObjectWithSiteImpl<CAxHostWindow>,
		public IServiceProvider,
		public IAdviseSink,
#ifndef _ATL_NO_DOCHOSTUIHANDLER
		public IDocHostUIHandler,
#endif
		public IDispatchImpl<IAxWinAmbientDispatchEx, &__uuidof(IAxWinAmbientDispatchEx), &CAtlModule::m_libid, 0xFFFF, 0xFFFF>
{
public:
// ctor/dtor
	CAxHostWindow()
	{
		m_bInPlaceActive = FALSE;
		m_bUIActive = FALSE;
		m_bMDIApp = FALSE;
		m_bWindowless = FALSE;
		m_bCapture = FALSE;
		m_bHaveFocus = FALSE;

		// Initialize ambient properties
		m_bCanWindowlessActivate = TRUE;
		m_bUserMode = TRUE;
		m_bDisplayAsDefault = FALSE;
		m_clrBackground = 0;
		m_clrForeground = GetSysColor(COLOR_WINDOWTEXT);
		m_lcidLocaleID = LOCALE_USER_DEFAULT;
		m_bMessageReflect = true;

		m_bReleaseAll = FALSE;

		m_bSubclassed = FALSE;

		m_dwAdviseSink = 0xCDCDCDCD;
		m_dwDocHostFlags = DOCHOSTUIFLAG_NO3DBORDER;
		m_dwDocHostDoubleClickFlags = DOCHOSTUIDBLCLK_DEFAULT;
		m_bAllowContextMenu = true;
		m_bAllowShowUI = false;
		m_hDCScreen = NULL;
		m_bDCReleased = true;

		m_hAccel = NULL;
	}

	virtual ~CAxHostWindow()
	{
	}
	void FinalRelease()
	{
		ReleaseAll();
	}

	virtual void OnFinalMessage(_In_ HWND /*hWnd*/)
	{
		GetControllingUnknown()->Release();
	}

	DECLARE_NO_REGISTRY()
	DECLARE_POLY_AGGREGATABLE(CAxHostWindow)
	DECLARE_GET_CONTROLLING_UNKNOWN()

	BEGIN_COM_MAP(CAxHostWindow)
		COM_INTERFACE_ENTRY2(IDispatch, IAxWinAmbientDispatchEx)
		COM_INTERFACE_ENTRY(IAxWinHostWindow)
		COM_INTERFACE_ENTRY(IAxWinHostWindowLic)
		COM_INTERFACE_ENTRY(IOleClientSite)
		COM_INTERFACE_ENTRY(IOleInPlaceSiteWindowless)
		COM_INTERFACE_ENTRY(IOleInPlaceSiteEx)
		COM_INTERFACE_ENTRY(IOleInPlaceSite)
		COM_INTERFACE_ENTRY(IOleWindow)
		COM_INTERFACE_ENTRY(IOleControlSite)
		COM_INTERFACE_ENTRY(IOleContainer)
		COM_INTERFACE_ENTRY(IObjectWithSite)
		COM_INTERFACE_ENTRY(IServiceProvider)
		COM_INTERFACE_ENTRY(IAxWinAmbientDispatchEx)
		COM_INTERFACE_ENTRY(IAxWinAmbientDispatch)
#ifndef _ATL_NO_DOCHOSTUIHANDLER
		COM_INTERFACE_ENTRY(IDocHostUIHandler)
#endif
		COM_INTERFACE_ENTRY(IAdviseSink)
	END_COM_MAP()

	static CWndClassInfo& GetWndClassInfo()
	{
		static CWndClassInfo wc =
		{
			{ sizeof(WNDCLASSEX), 0, StartWindowProc,
			  0, 0, 0, 0, 0, (HBRUSH)(COLOR_WINDOW + 1), 0, _T(ATLAXWIN_CLASS), 0 },
			NULL, NULL, IDC_ARROW, TRUE, 0, _T("")
		};
		return wc;
	}

	BEGIN_MSG_MAP(CAxHostWindow)
		MESSAGE_HANDLER(WM_ERASEBKGND, OnEraseBackground)
		MESSAGE_HANDLER(WM_PAINT, OnPaint)
		MESSAGE_HANDLER(WM_SIZE, OnSize)
		MESSAGE_HANDLER(WM_MOUSEACTIVATE, OnMouseActivate)
		MESSAGE_HANDLER(WM_SETFOCUS, OnSetFocus)
		MESSAGE_HANDLER(WM_KILLFOCUS, OnKillFocus)
		if (m_bWindowless && uMsg >= WM_MOUSEFIRST && uMsg <= WM_MOUSELAST)
		{
			// Mouse messages handled when a windowless control has captured the cursor
			// or if the cursor is over the control
			DWORD dwHitResult = m_bCapture ? HITRESULT_HIT : HITRESULT_OUTSIDE;
			if (dwHitResult == HITRESULT_OUTSIDE && m_spViewObject != NULL)
			{
				POINT ptMouse = { GET_X_LPARAM(lParam), GET_Y_LPARAM(lParam) };
				m_spViewObject->QueryHitPoint(DVASPECT_CONTENT, &m_rcPos, ptMouse, 0, &dwHitResult);
			}
			if (dwHitResult == HITRESULT_HIT)
			{
				MESSAGE_HANDLER(WM_MOUSEMOVE, OnWindowlessMouseMessage)
				MESSAGE_HANDLER(WM_LBUTTONUP, OnWindowlessMouseMessage)
				MESSAGE_HANDLER(WM_RBUTTONUP, OnWindowlessMouseMessage)
				MESSAGE_HANDLER(WM_MBUTTONUP, OnWindowlessMouseMessage)
				MESSAGE_HANDLER(WM_LBUTTONDOWN, OnWindowlessMouseMessage)
				MESSAGE_HANDLER(WM_RBUTTONDOWN, OnWindowlessMouseMessage)
				MESSAGE_HANDLER(WM_MBUTTONDOWN, OnWindowlessMouseMessage)
				MESSAGE_HANDLER(WM_LBUTTONDBLCLK, OnWindowlessMouseMessage)
				MESSAGE_HANDLER(WM_RBUTTONDBLCLK, OnWindowlessMouseMessage)
				MESSAGE_HANDLER(WM_MBUTTONDBLCLK, OnWindowlessMouseMessage)
			}
		}
		if (m_bWindowless & m_bHaveFocus)
		{
			// Keyboard messages handled only when a windowless control has the focus
			MESSAGE_HANDLER(WM_KEYDOWN, OnWindowMessage)
			MESSAGE_HANDLER(WM_KEYUP, OnWindowMessage)
			MESSAGE_HANDLER(WM_CHAR, OnWindowMessage)
			MESSAGE_HANDLER(WM_DEADCHAR, OnWindowMessage)
			MESSAGE_HANDLER(WM_SYSKEYDOWN, OnWindowMessage)
			MESSAGE_HANDLER(WM_SYSKEYUP, OnWindowMessage)
			MESSAGE_HANDLER(WM_SYSDEADCHAR, OnWindowMessage)
			MESSAGE_HANDLER(WM_HELP, OnWindowMessage)
			MESSAGE_HANDLER(WM_CANCELMODE, OnWindowMessage)
			MESSAGE_HANDLER(WM_IME_CHAR, OnWindowMessage)
			MESSAGE_HANDLER(WM_MBUTTONDBLCLK, OnWindowMessage)
			MESSAGE_RANGE_HANDLER(WM_IME_SETCONTEXT, WM_IME_KEYUP, OnWindowMessage)
		}
		MESSAGE_HANDLER(WM_DESTROY, OnDestroy)
		if (m_bMessageReflect)
		{
			bHandled = TRUE;
			lResult = ReflectNotifications(uMsg, wParam, lParam, bHandled);
			if(bHandled)
				return TRUE;
		}
		MESSAGE_HANDLER(WM_ATLGETHOST, OnGetUnknown)
		MESSAGE_HANDLER(WM_ATLGETCONTROL, OnGetControl)
		MESSAGE_HANDLER(WM_FORWARDMSG, OnForwardMsg)
	END_MSG_MAP()

	LRESULT OnForwardMsg(
		_In_ UINT /*uMsg*/,
		_In_ WPARAM /*wParam*/,
		_In_ LPARAM lParam,
		_Inout_ BOOL& /*bHandled*/)
	{
		ATLASSUME(lParam != 0);
		LPMSG lpMsg = (LPMSG)lParam;
		CComQIPtr<IOleInPlaceActiveObject, &__uuidof(IOleInPlaceActiveObject)> spInPlaceActiveObject(m_spUnknown);
		if(spInPlaceActiveObject)
		{
			if(spInPlaceActiveObject->TranslateAccelerator(lpMsg) == S_OK)
				return 1;
		}
		return 0;
	}

	LRESULT OnGetUnknown(
		_In_ UINT /*uMsg*/,
		_In_ WPARAM /*wParam*/,
		_In_ LPARAM /*lParam*/,
		_Inout_ BOOL& /*bHandled*/)
	{
		IUnknown* pUnk = GetControllingUnknown();
		pUnk->AddRef();
		return (LRESULT)pUnk;
	}
	LRESULT OnGetControl(
		_In_ UINT /*uMsg*/,
		_In_ WPARAM /*wParam*/,
		_In_ LPARAM /*lParam*/,
		_Inout_ BOOL& /*bHandled*/)
	{
		IUnknown* pUnk = m_spUnknown;
		if (pUnk)
			pUnk->AddRef();
		return (LRESULT)pUnk;
	}

	void ReleaseAll()
	{
		if (m_bReleaseAll)
			return;
		m_bReleaseAll = TRUE;

		if (m_spViewObject != NULL)
			m_spViewObject->SetAdvise(DVASPECT_CONTENT, 0, NULL);

		if(m_dwAdviseSink != 0xCDCDCDCD)
		{
			AtlUnadvise(m_spUnknown, m_iidSink, m_dwAdviseSink);
			m_dwAdviseSink = 0xCDCDCDCD;
		}

		if (m_spOleObject)
		{
			m_spOleObject->Unadvise(m_dwOleObject);
			m_spOleObject->Close(OLECLOSE_NOSAVE);
			m_spOleObject->SetClientSite(NULL);
		}

		if (m_spUnknown != NULL)
		{
			CComPtr<IObjectWithSite> spSite;
			m_spUnknown->QueryInterface(__uuidof(IObjectWithSite), (void**)&spSite);
			if (spSite != NULL)
				spSite->SetSite(NULL);
		}

		m_spViewObject.Release();
		m_dwViewObjectType = 0;

		m_spInPlaceObjectWindowless.Release();
		m_spOleObject.Release();
		m_spUnknown.Release();

		m_spInPlaceUIWindow.Release();
		m_spInPlaceFrame.Release();

		m_bInPlaceActive = FALSE;
		m_bWindowless = FALSE;
		m_bInPlaceActive = FALSE;
		m_bUIActive = FALSE;
		m_bCapture = FALSE;
		m_bReleaseAll = FALSE;

		if (m_hAccel != NULL)
		{
			DestroyAcceleratorTable(m_hAccel);
			m_hAccel = NULL;
		}
	}

// window message handlers
	LRESULT OnEraseBackground(
		_In_ UINT /*uMsg*/,
		_In_ WPARAM /*wParam*/,
		_In_ LPARAM /*lParam*/,
		_Inout_ BOOL& bHandled)
	{
		if (m_spViewObject == NULL)
			bHandled = false;

		return 1;
	}

	LRESULT OnMouseActivate(
		_In_ UINT /*uMsg*/,
		_In_ WPARAM /*wParam*/,
		_In_ LPARAM /*lParam*/,
		_Inout_ BOOL& bHandled)
	{
		bHandled = FALSE;
		if (m_dwMiscStatus & OLEMISC_NOUIACTIVATE)
		{
			if (m_spOleObject != NULL && !m_bInPlaceActive)
			{
				CComPtr<IOleClientSite> spClientSite;
				GetControllingUnknown()->QueryInterface(__uuidof(IOleClientSite), (void**)&spClientSite);
				if (spClientSite != NULL)
					m_spOleObject->DoVerb(OLEIVERB_INPLACEACTIVATE, NULL, spClientSite, 0, m_hWnd, &m_rcPos);
			}
		}
		else
		{
			BOOL b = false;
			OnSetFocus(0, 0, 0, b);
		}
		return 0;
	}
	LRESULT OnSetFocus(
		_In_ UINT /*uMsg*/,
		_In_ WPARAM /*wParam*/,
		_In_ LPARAM /*lParam*/,
		_Inout_ BOOL& bHandled)
	{
		m_bHaveFocus = TRUE;
		if (!m_bReleaseAll)
		{
			if (m_spOleObject != NULL && !m_bUIActive)
			{
				CComPtr<IOleClientSite> spClientSite;
				GetControllingUnknown()->QueryInterface(__uuidof(IOleClientSite), (void**)&spClientSite);
				if (spClientSite != NULL)
					m_spOleObject->DoVerb(OLEIVERB_UIACTIVATE, NULL, spClientSite, 0, m_hWnd, &m_rcPos);
			}
			if (m_bWindowless)
				::SetFocus(m_hWnd);
			else if(!IsChild(::GetFocus()))
				::SetFocus(::GetWindow(m_hWnd, GW_CHILD));
		}
		bHandled = FALSE;
		return 0;
	}
	LRESULT OnKillFocus(
		_In_ UINT /*uMsg*/,
		_In_ WPARAM /*wParam*/,
		_In_ LPARAM /*lParam*/,
		_Inout_ BOOL& bHandled)
	{
		m_bHaveFocus = FALSE;
		bHandled = FALSE;
		return 0;
	}
	LRESULT OnSize(
		_In_ UINT /*uMsg*/,
		_In_ WPARAM /*wParam*/,
		_In_ LPARAM lParam,
		_Inout_ BOOL& bHandled)
	{
		int nWidth = GET_X_LPARAM(lParam);  // width of client area
		int nHeight = GET_Y_LPARAM(lParam); // height of client area

		m_rcPos.right = m_rcPos.left + nWidth;
		m_rcPos.bottom = m_rcPos.top + nHeight;
		m_pxSize.cx = m_rcPos.right - m_rcPos.left;
		m_pxSize.cy = m_rcPos.bottom - m_rcPos.top;
		AtlPixelToHiMetric(&m_pxSize, &m_hmSize);

		if (m_spOleObject)
			m_spOleObject->SetExtent(DVASPECT_CONTENT, &m_hmSize);
		if (m_spInPlaceObjectWindowless)
			m_spInPlaceObjectWindowless->SetObjectRects(&m_rcPos, &m_rcPos);
		if (m_bWindowless)
			InvalidateRect(NULL, TRUE);
		bHandled = FALSE;
		return 0;
	}
	LRESULT OnDestroy(
		_In_ UINT uMsg,
		_In_ WPARAM wParam,
		_In_ LPARAM lParam,
		_Inout_ BOOL& bHandled)
	{
		GetControllingUnknown()->AddRef();
		DefWindowProc(uMsg, wParam, lParam);
		ReleaseAll();
		bHandled = FALSE;
		return 0;
	}
	LRESULT OnWindowMessage(
		_In_ UINT uMsg,
		_In_ WPARAM wParam,
		_In_ LPARAM lParam,
		_Inout_ BOOL& bHandled)
	{
		LRESULT lRes = 0;
		HRESULT hr = S_FALSE;
		if (m_bInPlaceActive && m_bWindowless && m_spInPlaceObjectWindowless)
			hr = m_spInPlaceObjectWindowless->OnWindowMessage(uMsg, wParam, lParam, &lRes);
		if (hr == S_FALSE)
			bHandled = FALSE;
		return lRes;
	}
	LRESULT OnWindowlessMouseMessage(
		_In_ UINT uMsg,
		_In_ WPARAM wParam,
		_In_ LPARAM lParam,
		_Inout_ BOOL& bHandled)
	{
		LRESULT lRes = 0;
		if (m_bInPlaceActive && m_bWindowless && m_spInPlaceObjectWindowless)
			m_spInPlaceObjectWindowless->OnWindowMessage(uMsg, wParam, lParam, &lRes);
		bHandled = FALSE;
		return lRes;
	}
	LRESULT OnPaint(
		_In_ UINT /*uMsg*/,
		_In_ WPARAM /*wParam*/,
		_In_ LPARAM /*lParam*/,
		_Inout_ BOOL& bHandled)
	{
		if (m_spViewObject == NULL)
		{
			PAINTSTRUCT ps;
			HDC hdc = ::BeginPaint(m_hWnd, &ps);
			if (hdc == NULL)
				return 0;
			RECT rcClient;
			GetClientRect(&rcClient);
			HBRUSH hbrBack = CreateSolidBrush(m_clrBackground);
			if (hbrBack != NULL)
			{
				FillRect(hdc, &rcClient, hbrBack);
				DeleteObject(hbrBack);
			}
			::EndPaint(m_hWnd, &ps);
			return 1;
		}
		if (m_spViewObject && m_bWindowless)
		{
			PAINTSTRUCT ps;
			HDC hdc = ::BeginPaint(m_hWnd, &ps);

			if (hdc == NULL)
				return 0;

			RECT rcClient;
			GetClientRect(&rcClient);

			HBITMAP hBitmap = CreateCompatibleBitmap(hdc, rcClient.right - rcClient.left, rcClient.bottom - rcClient.top);
			if (hBitmap != NULL)
			{
				HDC hdcCompatible = ::CreateCompatibleDC(hdc);
				if (hdcCompatible != NULL)
				{
					HBITMAP hBitmapOld = (HBITMAP)SelectObject(hdcCompatible, hBitmap);
					if (hBitmapOld != NULL)
					{
						HBRUSH hbrBack = CreateSolidBrush(m_clrBackground);
						if (hbrBack != NULL)
						{
							FillRect(hdcCompatible, &rcClient, hbrBack);
							DeleteObject(hbrBack);

							m_spViewObject->Draw(DVASPECT_CONTENT, -1, NULL, NULL, NULL, hdcCompatible, (RECTL*)&m_rcPos, (RECTL*)&m_rcPos, NULL, 0);

							::BitBlt(hdc, 0, 0, rcClient.right, rcClient.bottom,  hdcCompatible, 0, 0, SRCCOPY);
						}
						::SelectObject(hdcCompatible, hBitmapOld);
					}
					::DeleteDC(hdcCompatible);
				}
				::DeleteObject(hBitmap);
			}
			::EndPaint(m_hWnd, &ps);
		}
		else
		{
			bHandled = FALSE;
			return 0;
		}
		return 1;
	}

// IAxWinHostWindow
	STDMETHOD(CreateControl)(
		_In_z_ LPCOLESTR lpTricsData,
		_In_ HWND hWnd,
		_Inout_opt_ IStream* pStream)
	{
		CComPtr<IUnknown> p;
		return CreateControlLicEx(lpTricsData, hWnd, pStream, &p, IID_NULL, NULL, NULL);
	}
	STDMETHOD(CreateControlEx)(
		_In_z_ LPCOLESTR lpszTricsData,
		_In_ HWND hWnd,
		_Inout_opt_ IStream* pStream,
		_Deref_out_ IUnknown** ppUnk,
		_In_ REFIID iidAdvise,
		_Inout_ IUnknown* punkSink)
	{
		return CreateControlLicEx(lpszTricsData, hWnd, pStream, ppUnk, iidAdvise, punkSink, NULL);
	}
	STDMETHOD(AttachControl)(
		_Inout_ IUnknown* pUnkControl,
		_In_ HWND hWnd)
	{
		HRESULT hr = S_FALSE;

		ReleaseAll();

		bool bReleaseWindowOnFailure = false; // Used to keep track of whether we subclass the window

		if ((m_hWnd != NULL) && (m_hWnd != hWnd)) // Don't release the window if it's the same as the one we already subclass/own
		{
			RedrawWindow(NULL, NULL, RDW_INVALIDATE | RDW_UPDATENOW | RDW_ERASE | RDW_INTERNALPAINT | RDW_FRAME);
			ReleaseWindow();
		}

		if (::IsWindow(hWnd))
		{
			if (m_hWnd != hWnd) // Don't need to subclass the window if we already own it
			{
				SubclassWindow(hWnd);
				bReleaseWindowOnFailure = true;
			}

			hr = ActivateAx(pUnkControl, true, NULL);

			if (FAILED(hr))
			{
				ReleaseAll();

				if (m_hWnd != NULL)
				{
					RedrawWindow(NULL, NULL, RDW_INVALIDATE | RDW_UPDATENOW | RDW_ERASE | RDW_INTERNALPAINT | RDW_FRAME);
					if (bReleaseWindowOnFailure) // We subclassed the window in an attempt to create this control, so we unsubclass on failure
						ReleaseWindow();
				}
			}
		}
		return hr;
	}
	
ATLPREFAST_SUPPRESS(6387)
	STDMETHOD(QueryControl)(
		_In_ REFIID riid,
		_Deref_out_ void** ppvObject)
	{
		HRESULT hr = E_POINTER;
		if (ppvObject)
		{
			if (m_spUnknown)
			{
				hr = m_spUnknown->QueryInterface(riid, ppvObject);
			}
			else
			{
				*ppvObject = NULL;
				hr = OLE_E_NOCONNECTION;
			}
		}
		return hr;
	}
ATLPREFAST_UNSUPPRESS()
	
	STDMETHOD(SetExternalDispatch)(_In_opt_ IDispatch* pDisp)
	{
		m_spExternalDispatch = pDisp;
		return S_OK;
	}
	STDMETHOD(SetExternalUIHandler)(_In_opt_ IDocHostUIHandlerDispatch* pUIHandler)
	{
#ifndef _ATL_NO_DOCHOSTUIHANDLER
		m_spIDocHostUIHandlerDispatch = pUIHandler;
#endif
		return S_OK;
	}

ATLPREFAST_SUPPRESS(6387)
	
	STDMETHOD(CreateControlLic)(
		_In_z_ LPCOLESTR lpTricsData,
		_In_ HWND hWnd,
		_Inout_opt_ IStream* pStream,
		_In_opt_z_ BSTR bstrLic)
	{
		CComPtr<IUnknown> p;
		return CreateControlLicEx(lpTricsData, hWnd, pStream, &p, IID_NULL, NULL, bstrLic);
	}

	_Success_(return == S_OK) STDMETHOD(CreateControlLicEx)(
		_In_z_ LPCOLESTR lpszTricsData,
		_In_ HWND hWnd,
		_Inout_opt_ IStream* pStream,
		_Deref_out_ IUnknown** ppUnk,
		_In_ REFIID iidAdvise,
		_Inout_opt_ IUnknown* punkSink,
		_In_opt_z_ BSTR bstrLic)
	{
		ATLASSERT(ppUnk != NULL);
		if (ppUnk == NULL)
			return E_POINTER;
		*ppUnk = NULL;
		HRESULT hr = S_FALSE;
		bool bReleaseWindowOnFailure = false; // Used to keep track of whether we subclass the window

		ReleaseAll();

		if ((m_hWnd != NULL) && (m_hWnd != hWnd)) // Don't release the window if it's the same as the one we already subclass/own
		{
			RedrawWindow(NULL, NULL, RDW_INVALIDATE | RDW_UPDATENOW | RDW_ERASE | RDW_INTERNALPAINT | RDW_FRAME);
			ReleaseWindow();
		}

		if (::IsWindow(hWnd))
		{
			if (m_hWnd != hWnd) // Don't need to subclass the window if we already own it
			{
				SubclassWindow(hWnd);
				bReleaseWindowOnFailure = true;
			}
			if (m_clrBackground == 0)
			{
				if (IsParentDialog())
				{
					m_clrBackground = GetSysColor(COLOR_BTNFACE);
				}
				else
				{
					m_clrBackground = GetSysColor(COLOR_WINDOW);
				}
			}

			bool bWasHTML = false;

			hr = CreateNormalizedObject(lpszTricsData, __uuidof(IUnknown), (void**)ppUnk, bWasHTML, bstrLic);

			if (SUCCEEDED(hr))
			{			
				hr = ActivateAx(*ppUnk, false, pStream);
			}

			// Try to hook up any sink the user might have given us.
			m_iidSink = iidAdvise;
			if(SUCCEEDED(hr) && *ppUnk && punkSink)
			{
				AtlAdvise(*ppUnk, punkSink, m_iidSink, &m_dwAdviseSink);
			}

			if (SUCCEEDED(hr) && bWasHTML && *ppUnk != NULL)
			{
				if ((GetStyle() & (WS_VSCROLL | WS_HSCROLL)) == 0)
				{
					m_dwDocHostFlags |= DOCHOSTUIFLAG_SCROLL_NO;
				}
				else
				{
					DWORD dwStyle = GetStyle();
					SetWindowLong(GWL_STYLE, dwStyle & ~(WS_VSCROLL | WS_HSCROLL));
					SetWindowPos(NULL, 0, 0, 0, 0, SWP_NOACTIVATE | SWP_NOMOVE | SWP_NOZORDER | SWP_NOSIZE | SWP_FRAMECHANGED | SWP_DRAWFRAME);
				}

				CComPtr<IUnknown> spUnk(*ppUnk);
				// Is it just plain HTML?
				if ((lpszTricsData[0] == OLECHAR('M') || lpszTricsData[0] == OLECHAR('m')) &&
					(lpszTricsData[1] == OLECHAR('S') || lpszTricsData[1] == OLECHAR('s')) &&
					(lpszTricsData[2] == OLECHAR('H') || lpszTricsData[2] == OLECHAR('h')) &&
					(lpszTricsData[3] == OLECHAR('T') || lpszTricsData[3] == OLECHAR('t')) &&
					(lpszTricsData[4] == OLECHAR('M') || lpszTricsData[4] == OLECHAR('m')) &&
					(lpszTricsData[5] == OLECHAR('L') || lpszTricsData[5] == OLECHAR('l')) &&
					(lpszTricsData[6] == OLECHAR(':')))
				{
					// Just HTML: load the HTML data into the document
					UINT nCreateSize = (static_cast<UINT>(ocslen(lpszTricsData)) - 7) * sizeof(OLECHAR);
					HGLOBAL hGlobal = GlobalAlloc(GHND, nCreateSize);
					if (hGlobal)
					{
						CComPtr<IStream> spStream;
						BYTE* pBytes = (BYTE*) GlobalLock(hGlobal);
						Checked::memcpy_s(pBytes, nCreateSize, lpszTricsData + 7, nCreateSize);
						GlobalUnlock(hGlobal);
						hr = CreateStreamOnHGlobal(hGlobal, TRUE, &spStream);
						if (SUCCEEDED(hr))
						{
							CComPtr<IPersistStreamInit> spPSI;
							hr = spUnk->QueryInterface(__uuidof(IPersistStreamInit), (void**)&spPSI);
							if (SUCCEEDED(hr))
							{
								hr = spPSI->Load(spStream);
							}
						}
					}
					else
					{
						hr = E_OUTOFMEMORY;
					}
				}
				else
				{
					CComPtr<IWebBrowser2> spBrowser;
					spUnk->QueryInterface(__uuidof(IWebBrowser2), (void**)&spBrowser);
					if (spBrowser)
					{
						CComVariant ve;
						CComVariant vurl(lpszTricsData);
						spBrowser->put_Visible(ATL_VARIANT_TRUE);
						spBrowser->Navigate2(&vurl, &ve, &ve, &ve, &ve);
					}
				}

			}
			if (FAILED(hr) || m_spUnknown == NULL)
			{
				// We don't have a control or something failed so release
				ReleaseAll();

				if (m_hWnd != NULL)
				{
					RedrawWindow(NULL, NULL, RDW_INVALIDATE | RDW_UPDATENOW | RDW_ERASE | RDW_INTERNALPAINT | RDW_FRAME);
					if (FAILED(hr) && bReleaseWindowOnFailure) // We subclassed the window in an attempt to create this control, so we unsubclass on failure
					{
						ReleaseWindow();
					}
				}
			}
		}
		return hr;
	}
ATLPREFAST_UNSUPPRESS()
	
#ifndef _ATL_NO_DOCHOSTUIHANDLER
	// IDocHostUIHandler
	// MSHTML requests to display its context menu
	STDMETHOD(ShowContextMenu)(
		_In_ DWORD dwID,
		_In_ POINT* pptPosition,
		_In_ IUnknown* pCommandTarget,
		_Inout_ IDispatch* pDispatchObjectHit)
	{
		HRESULT hr = m_bAllowContextMenu ? S_FALSE : S_OK;
		if (m_spIDocHostUIHandlerDispatch != NULL)
			m_spIDocHostUIHandlerDispatch->ShowContextMenu(
				dwID,
				pptPosition->x,
				pptPosition->y,
				pCommandTarget,
				pDispatchObjectHit,
				&hr);
		return hr;
	}
	// Called at initialisation to find UI styles from container
	STDMETHOD(GetHostInfo)(_Inout_ DOCHOSTUIINFO* pInfo)
	{
		if (pInfo == NULL)
			return E_POINTER;

		if (m_spIDocHostUIHandlerDispatch != NULL)
			return m_spIDocHostUIHandlerDispatch->GetHostInfo(&pInfo->dwFlags, &pInfo->dwDoubleClick);

		pInfo->dwFlags = m_dwDocHostFlags;
		pInfo->dwDoubleClick = m_dwDocHostDoubleClickFlags;

		return S_OK;
	}
	// Allows the host to replace the IE4/MSHTML menus and toolbars.
	STDMETHOD(ShowUI)(
		_In_ DWORD dwID,
		_Inout_ IOleInPlaceActiveObject* pActiveObject,
		_Inout_ IOleCommandTarget* pCommandTarget,
		_Inout_ IOleInPlaceFrame* pFrame,
		_Inout_ IOleInPlaceUIWindow* pDoc)
	{
		HRESULT hr = m_bAllowShowUI ? S_FALSE : S_OK;
		if (m_spIDocHostUIHandlerDispatch != NULL)
			m_spIDocHostUIHandlerDispatch->ShowUI(
				dwID,
				pActiveObject,
				pCommandTarget,
				pFrame,
				pDoc,
				&hr);
		return hr;
	}
	// Called when IE4/MSHTML removes its menus and toolbars.
	STDMETHOD(HideUI)()
	{
		HRESULT hr = S_OK;
		if (m_spIDocHostUIHandlerDispatch != NULL)
			hr = m_spIDocHostUIHandlerDispatch->HideUI();
		return hr;
	}
	// Notifies the host that the command state has changed.
	STDMETHOD(UpdateUI)()
	{
		HRESULT hr = S_OK;
		if (m_spIDocHostUIHandlerDispatch != NULL)
			hr = m_spIDocHostUIHandlerDispatch->UpdateUI();
		return hr;
	}
	// Called from the IE4/MSHTML implementation of IOleInPlaceActiveObject::EnableModeless
	STDMETHOD(EnableModeless)(_In_ BOOL fEnable)
	{
		HRESULT hr = S_OK;
		if (m_spIDocHostUIHandlerDispatch != NULL)
			hr = m_spIDocHostUIHandlerDispatch->EnableModeless(fEnable ? ATL_VARIANT_TRUE : ATL_VARIANT_FALSE);
		return hr;
	}
	// Called from the IE4/MSHTML implementation of IOleInPlaceActiveObject::OnDocWindowActivate
	STDMETHOD(OnDocWindowActivate)(_In_ BOOL fActivate)
	{
		HRESULT hr = S_OK;
		if (m_spIDocHostUIHandlerDispatch != NULL)
			hr = m_spIDocHostUIHandlerDispatch->OnDocWindowActivate(fActivate ? ATL_VARIANT_TRUE : ATL_VARIANT_FALSE);
		return hr;
	}
	// Called from the IE4/MSHTML implementation of IOleInPlaceActiveObject::OnFrameWindowActivate.
	STDMETHOD(OnFrameWindowActivate)(_In_ BOOL fActivate)
	{
		HRESULT hr = S_OK;
		if (m_spIDocHostUIHandlerDispatch != NULL)
			hr = m_spIDocHostUIHandlerDispatch->OnFrameWindowActivate(fActivate ? ATL_VARIANT_TRUE : ATL_VARIANT_FALSE);
		return hr;
	}
	// Called from the IE4/MSHTML implementation of IOleInPlaceActiveObject::ResizeBorder.
	STDMETHOD(ResizeBorder)(
		_In_ LPCRECT prcBorder,
		_Inout_ IOleInPlaceUIWindow* pUIWindow,
		_In_ BOOL fFrameWindow)
	{
		HRESULT hr = S_OK;
		if (m_spIDocHostUIHandlerDispatch != NULL)
			hr = m_spIDocHostUIHandlerDispatch->ResizeBorder(
				prcBorder->left,
				prcBorder->top,
				prcBorder->right,
				prcBorder->bottom,
				pUIWindow,
				fFrameWindow ? ATL_VARIANT_TRUE : ATL_VARIANT_FALSE);
		return hr;
	}
	// Called by IE4/MSHTML when IOleInPlaceActiveObject::TranslateAccelerator or IOleControlSite::TranslateAccelerator is called.
	STDMETHOD(TranslateAccelerator)(
		_In_ LPMSG lpMsg,
		_In_ const GUID* pguidCmdGroup,
		_In_ DWORD nCmdID)
	{
		HRESULT hr = S_FALSE;
		if (m_spIDocHostUIHandlerDispatch != NULL)
			m_spIDocHostUIHandlerDispatch->TranslateAccelerator(
				(DWORD_PTR) lpMsg->hwnd,
				lpMsg->message,
				lpMsg->wParam,
				lpMsg->lParam,
				CComBSTR(*pguidCmdGroup),
				nCmdID,
				&hr);
		return hr;
	}
	// Returns the registry key under which IE4/MSHTML stores user preferences.
	// Returns S_OK if successful, or S_FALSE otherwise. If S_FALSE, IE4/MSHTML will default to its own user options.
	STDMETHOD(GetOptionKeyPath)(
		_Deref_out_opt_z_ LPOLESTR* pchKey,
		_In_ DWORD dwReserved)
	{
		HRESULT hr = S_FALSE;
		ATLENSURE_RETURN_VAL(pchKey, E_POINTER);
		*pchKey = NULL;
		if (m_spIDocHostUIHandlerDispatch != NULL)
		{
			hr = m_spIDocHostUIHandlerDispatch->GetOptionKeyPath(pchKey, dwReserved);
			if (FAILED(hr) || *pchKey == NULL)
				hr = S_FALSE;
		}
		else
		{
			if (m_bstrOptionKeyPath.Length() != 0)
			{
				int cchLength = ocslen(m_bstrOptionKeyPath) + 1;
				LPOLESTR pStr = (LPOLESTR)CoTaskMemAlloc(cchLength * sizeof(OLECHAR));
				if (pStr == NULL)
				{
					return E_OUTOFMEMORY;
				}
				if(!ocscpy_s(pStr, cchLength, m_bstrOptionKeyPath.m_str))
				{
					return E_FAIL;
				}
				*pchKey = pStr;
				hr = S_OK;
			}
		}
		return hr;
	}
ATLPREFAST_SUPPRESS(6387)
	// Called by IE4/MSHTML when it is being used as a drop target to allow the host to supply an alternative IDropTarget
	STDMETHOD(GetDropTarget)(
		_Inout_ IDropTarget* pDropTarget,
		_Deref_out_ IDropTarget** ppDropTarget)
	{
		ATLASSERT(ppDropTarget != NULL);
		if (ppDropTarget == NULL)
			return E_POINTER;
		*ppDropTarget = NULL;

		HRESULT hr = E_NOTIMPL;
		if (m_spIDocHostUIHandlerDispatch != NULL)
		{
			CComPtr<IUnknown> spUnk;
			hr = m_spIDocHostUIHandlerDispatch->GetDropTarget(pDropTarget, &spUnk);
			if (SUCCEEDED(hr) && spUnk)
			{
				hr = spUnk->QueryInterface(__uuidof(IDropTarget), (void**)ppDropTarget);
				if (FAILED(hr) || *ppDropTarget == NULL)
					hr = E_NOTIMPL;
			}
			else
			{
				hr = E_NOTIMPL;
			}
		}
		return hr;
	}
ATLPREFAST_UNSUPPRESS()
	
ATLPREFAST_SUPPRESS(6387)
	// Called by IE4/MSHTML to obtain the host's IDispatch interface
	STDMETHOD(GetExternal)(_Deref_out_ IDispatch** ppDispatch)
	{
		ATLASSERT(ppDispatch != NULL);
		if (ppDispatch == NULL)
			return E_POINTER;
		*ppDispatch = NULL;

		HRESULT hr = E_NOINTERFACE;
		if (m_spIDocHostUIHandlerDispatch != NULL)
		{
			hr = m_spIDocHostUIHandlerDispatch->GetExternal(ppDispatch);
			if (FAILED(hr) || *ppDispatch == NULL)
				hr = E_NOINTERFACE;
		}
		else
		{
			// return the IDispatch we have for extending the object Model
			if (ppDispatch != NULL)
			{
				hr=m_spExternalDispatch.CopyTo(ppDispatch);
			}
			else
				hr = E_POINTER;
		}
		return hr;
	}
ATLPREFAST_UNSUPPRESS()
	
	// Called by IE4/MSHTML to allow the host an opportunity to modify the URL to be loaded
	STDMETHOD(TranslateUrl)(
		_In_ DWORD dwTranslate,
		_In_z_ OLECHAR* pchURLIn,
		_Deref_out_opt_z_ OLECHAR** ppchURLOut)
	{
		ATLENSURE_RETURN_VAL(ppchURLOut, E_POINTER);
		*ppchURLOut = NULL;

		HRESULT hr = S_FALSE;
		if (m_spIDocHostUIHandlerDispatch != NULL)
		{
			CComBSTR bstrURLOut;
			hr = m_spIDocHostUIHandlerDispatch->TranslateUrl(dwTranslate, CComBSTR(pchURLIn), &bstrURLOut);
			if (SUCCEEDED(hr) && bstrURLOut.Length() != 0)
			{
				UINT nLen = (bstrURLOut.Length() + 1) * 2;
				*ppchURLOut = (OLECHAR*) CoTaskMemAlloc(nLen);
				if (*ppchURLOut == NULL)
                {
					return E_OUTOFMEMORY;
                }
				Checked::memcpy_s(*ppchURLOut, nLen, bstrURLOut.m_str, nLen);
			}
			else
            {
				hr = S_FALSE;
            }
		}
		return hr;
	}
	// Called on the host by IE4/MSHTML to allow the host to replace IE4/MSHTML's data object.
	// This allows the host to block certain clipboard formats or support additional clipboard formats.
	STDMETHOD(FilterDataObject)(
		_Inout_ IDataObject* pDO,
		_Deref_out_opt_ IDataObject** ppDORet)
	{
		ATLASSERT(ppDORet != NULL);
		if (ppDORet == NULL)
			return E_POINTER;
		*ppDORet = NULL;

		HRESULT hr = S_FALSE;
		if (m_spIDocHostUIHandlerDispatch != NULL)
		{
			CComPtr<IUnknown> spUnk;
			hr = m_spIDocHostUIHandlerDispatch->FilterDataObject(pDO, &spUnk);
			if (spUnk)
				hr = QueryInterface(__uuidof(IDataObject), (void**)ppDORet);
			if (FAILED(hr) || *ppDORet == NULL)
				hr = S_FALSE;
		}
		return hr;
	}
#endif

	HRESULT FireAmbientPropertyChange(_In_ DISPID dispChanged)
	{
		HRESULT hr = S_OK;
		CComQIPtr<IOleControl, &__uuidof(IOleControl)> spOleControl(m_spUnknown);
		if (spOleControl != NULL)
			hr = spOleControl->OnAmbientPropertyChange(dispChanged);
		return hr;
	}

	// IAxWinAmbientDispatch
	CComPtr<IDispatch> m_spAmbientDispatch;

	STDMETHOD(Invoke)(
		_In_ DISPID dispIdMember,
		_In_ REFIID riid,
		_In_ LCID lcid,
		_In_ WORD wFlags,
		_In_ DISPPARAMS *pDispParams,
		_Out_opt_ VARIANT *pVarResult,
		_Out_opt_ EXCEPINFO *pExcepInfo,
		_Out_opt_ UINT *puArgErr)
	{
		HRESULT hr = IDispatchImpl<IAxWinAmbientDispatchEx, &__uuidof(IAxWinAmbientDispatchEx), &CAtlModule::m_libid, 0xFFFF, 0xFFFF>::Invoke
			(dispIdMember, riid, lcid, wFlags, pDispParams, pVarResult, pExcepInfo, puArgErr);
		if ((hr == DISP_E_MEMBERNOTFOUND || hr == TYPE_E_ELEMENTNOTFOUND) && m_spAmbientDispatch != NULL)
		{
			hr = m_spAmbientDispatch->Invoke(dispIdMember, riid, lcid, wFlags, pDispParams, pVarResult, pExcepInfo, puArgErr);
			if (SUCCEEDED(hr) && (wFlags & DISPATCH_PROPERTYPUT) != 0)
			{
				hr = FireAmbientPropertyChange(dispIdMember);
			}
		}
		return hr;
	}

	STDMETHOD(put_AllowWindowlessActivation)(_In_ VARIANT_BOOL bAllowWindowless)
	{
		m_bCanWindowlessActivate = bAllowWindowless;
		return S_OK;
	}
	STDMETHOD(get_AllowWindowlessActivation)(_Out_ VARIANT_BOOL* pbAllowWindowless)
	{
		ATLASSERT(pbAllowWindowless != NULL);
		if (pbAllowWindowless == NULL)
			return E_POINTER;

		*pbAllowWindowless = m_bCanWindowlessActivate ? ATL_VARIANT_TRUE : ATL_VARIANT_FALSE;
		return S_OK;
	}
	STDMETHOD(put_BackColor)(_In_ OLE_COLOR clrBackground)
	{
		m_clrBackground = clrBackground;
		FireAmbientPropertyChange(DISPID_AMBIENT_BACKCOLOR);
		InvalidateRect(0, FALSE);
		return S_OK;
	}
	STDMETHOD(get_BackColor)(_Out_ OLE_COLOR* pclrBackground)
	{
		ATLASSERT(pclrBackground != NULL);
		if (pclrBackground == NULL)
			return E_POINTER;

		*pclrBackground = m_clrBackground;
		return S_OK;
	}
	STDMETHOD(put_ForeColor)(_In_ OLE_COLOR clrForeground)
	{
		m_clrForeground = clrForeground;
		FireAmbientPropertyChange(DISPID_AMBIENT_FORECOLOR);
		return S_OK;
	}
	STDMETHOD(get_ForeColor)(_Out_ OLE_COLOR* pclrForeground)
	{
		ATLASSERT(pclrForeground != NULL);
		if (pclrForeground == NULL)
			return E_POINTER;

		*pclrForeground = m_clrForeground;
		return S_OK;
	}
	STDMETHOD(put_LocaleID)(_In_ LCID lcidLocaleID)
	{
		m_lcidLocaleID = lcidLocaleID;
		FireAmbientPropertyChange(DISPID_AMBIENT_LOCALEID);
		return S_OK;
	}
	STDMETHOD(get_LocaleID)(_Out_ LCID* plcidLocaleID)
	{
		ATLASSERT(plcidLocaleID != NULL);
		if (plcidLocaleID == NULL)
			return E_POINTER;

		*plcidLocaleID = m_lcidLocaleID;
		return S_OK;
	}
	STDMETHOD(put_UserMode)(_In_ VARIANT_BOOL bUserMode)
	{
		m_bUserMode = bUserMode;
		FireAmbientPropertyChange(DISPID_AMBIENT_USERMODE);
		return S_OK;
	}
	STDMETHOD(get_UserMode)(_Out_ VARIANT_BOOL* pbUserMode)
	{
		ATLASSERT(pbUserMode != NULL);
		if (pbUserMode == NULL)
			return E_POINTER;

		*pbUserMode = m_bUserMode ? ATL_VARIANT_TRUE : ATL_VARIANT_FALSE;
		return S_OK;
	}
	STDMETHOD(put_DisplayAsDefault)(_In_ VARIANT_BOOL bDisplayAsDefault)
	{
		m_bDisplayAsDefault = bDisplayAsDefault;
		FireAmbientPropertyChange(DISPID_AMBIENT_DISPLAYASDEFAULT);
		return S_OK;
	}
	STDMETHOD(get_DisplayAsDefault)(_Out_ VARIANT_BOOL* pbDisplayAsDefault)
	{
		ATLASSERT(pbDisplayAsDefault != NULL);
		if (pbDisplayAsDefault == NULL)
			return E_POINTER;

		*pbDisplayAsDefault = m_bDisplayAsDefault ? ATL_VARIANT_TRUE : ATL_VARIANT_FALSE;
		return S_OK;
	}
	STDMETHOD(put_Font)(_In_ IFontDisp* pFont)
	{
		m_spFont = pFont;
		FireAmbientPropertyChange(DISPID_AMBIENT_FONT);
		return S_OK;
	}
	STDMETHOD(get_Font)(_Deref_out_opt_ IFontDisp** pFont)
	{
		ATLASSERT(pFont != NULL);
		if (pFont == NULL)
			return E_POINTER;
		*pFont = NULL;

		if (m_spFont == NULL)
		{
			USES_CONVERSION_EX;
			HFONT hSystemFont = (HFONT) GetStockObject(DEFAULT_GUI_FONT);
			if (hSystemFont == NULL)
				hSystemFont = (HFONT) GetStockObject(SYSTEM_FONT);
			if (hSystemFont == NULL)
				return AtlHresultFromLastError();
			LOGFONT logfont;
			GetObject(hSystemFont, sizeof(logfont), &logfont);
			FONTDESC fd;
			fd.cbSizeofstruct = sizeof(FONTDESC);
			fd.lpstrName = T2OLE_EX_DEF(logfont.lfFaceName);
			fd.sWeight = (short)logfont.lfWeight;
			fd.sCharset = logfont.lfCharSet;
			fd.fItalic = logfont.lfItalic;
			fd.fUnderline = logfont.lfUnderline;
			fd.fStrikethrough = logfont.lfStrikeOut;

			long lfHeight = logfont.lfHeight;
			if (lfHeight < 0)
				lfHeight = -lfHeight;

			int ppi;
			HDC hdc;
			if (m_hWnd)
			{
				hdc = ::GetDC(m_hWnd);
				if (hdc == NULL)
					return AtlHresultFromLastError();
				ppi = GetDeviceCaps(hdc, LOGPIXELSY);
				::ReleaseDC(m_hWnd, hdc);
			}
			else
			{
				hdc = ::GetDC(GetDesktopWindow());
				if (hdc == NULL)
					return AtlHresultFromLastError();
				ppi = GetDeviceCaps(hdc, LOGPIXELSY);
				::ReleaseDC(GetDesktopWindow(), hdc);
			}
			fd.cySize.Lo = lfHeight * 720000 / ppi;
			fd.cySize.Hi = 0;

			OleCreateFontIndirect(&fd, __uuidof(IFontDisp), (void**) &m_spFont);
		}

		return m_spFont.CopyTo(pFont);
	}
	STDMETHOD(put_MessageReflect)(_In_ VARIANT_BOOL bMessageReflect)
	{
		m_bMessageReflect = bMessageReflect;
		FireAmbientPropertyChange(DISPID_AMBIENT_MESSAGEREFLECT);
		return S_OK;
	}
	STDMETHOD(get_MessageReflect)(_Out_ VARIANT_BOOL* pbMessageReflect)
	{
		ATLASSERT(pbMessageReflect != NULL);
		if (pbMessageReflect == NULL)
			return E_POINTER;

		*pbMessageReflect = m_bMessageReflect ? ATL_VARIANT_TRUE : ATL_VARIANT_FALSE;
		return S_OK;
	}
	STDMETHOD(get_ShowGrabHandles)(_Out_ VARIANT_BOOL* pbShowGrabHandles)
	{
		*pbShowGrabHandles = ATL_VARIANT_FALSE;
		return S_OK;
	}
	STDMETHOD(get_ShowHatching)(_Out_ VARIANT_BOOL* pbShowHatching)
	{
		ATLASSERT(pbShowHatching != NULL);
		if (pbShowHatching == NULL)
			return E_POINTER;

		*pbShowHatching = ATL_VARIANT_FALSE;
		return S_OK;
	}
	STDMETHOD(put_DocHostFlags)(_In_ DWORD dwDocHostFlags)
	{
		m_dwDocHostFlags = dwDocHostFlags;
		FireAmbientPropertyChange(DISPID_UNKNOWN);
		return S_OK;
	}
	STDMETHOD(get_DocHostFlags)(_Out_ DWORD* pdwDocHostFlags)
	{
		ATLASSERT(pdwDocHostFlags != NULL);
		if (pdwDocHostFlags == NULL)
			return E_POINTER;

		*pdwDocHostFlags = m_dwDocHostFlags;
		return S_OK;
	}
	STDMETHOD(put_DocHostDoubleClickFlags)(_In_ DWORD dwDocHostDoubleClickFlags)
	{
		m_dwDocHostDoubleClickFlags = dwDocHostDoubleClickFlags;
		return S_OK;
	}
	STDMETHOD(get_DocHostDoubleClickFlags)(_Out_ DWORD* pdwDocHostDoubleClickFlags)
	{
		ATLASSERT(pdwDocHostDoubleClickFlags != NULL);
		if (pdwDocHostDoubleClickFlags == NULL)
			return E_POINTER;

		*pdwDocHostDoubleClickFlags = m_dwDocHostDoubleClickFlags;
		return S_OK;
	}
	STDMETHOD(put_AllowContextMenu)(_In_ VARIANT_BOOL bAllowContextMenu)
	{
		m_bAllowContextMenu = bAllowContextMenu;
		return S_OK;
	}
	STDMETHOD(get_AllowContextMenu)(_Out_ VARIANT_BOOL* pbAllowContextMenu)
	{
		ATLASSERT(pbAllowContextMenu != NULL);
		if (pbAllowContextMenu == NULL)
			return E_POINTER;

		*pbAllowContextMenu = m_bAllowContextMenu ? ATL_VARIANT_TRUE : ATL_VARIANT_FALSE;
		return S_OK;
	}
	STDMETHOD(put_AllowShowUI)(_In_ VARIANT_BOOL bAllowShowUI)
	{
		m_bAllowShowUI = bAllowShowUI;
		return S_OK;
	}
	STDMETHOD(get_AllowShowUI)(_Out_ VARIANT_BOOL* pbAllowShowUI)
	{
		ATLASSERT(pbAllowShowUI != NULL);
		if (pbAllowShowUI == NULL)
			return E_POINTER;

		*pbAllowShowUI = m_bAllowShowUI ? ATL_VARIANT_TRUE : ATL_VARIANT_FALSE;
		return S_OK;
	}
	STDMETHOD(put_OptionKeyPath)(_In_z_ BSTR bstrOptionKeyPath) throw()
	{
		m_bstrOptionKeyPath = bstrOptionKeyPath;
		return S_OK;
	}
	STDMETHOD(get_OptionKeyPath)(_Deref_out_opt_z_ BSTR* pbstrOptionKeyPath)
	{
		ATLASSERT(pbstrOptionKeyPath != NULL);
		if (pbstrOptionKeyPath == NULL)
			return E_POINTER;

		*pbstrOptionKeyPath = SysAllocString(m_bstrOptionKeyPath);
		return S_OK;
	}

	STDMETHOD(SetAmbientDispatch)(_In_ IDispatch* pDispatch)
	{
		m_spAmbientDispatch = pDispatch;
		return S_OK;
	}

	// IObjectWithSite
	STDMETHOD(SetSite)(_Inout_opt_ IUnknown* pUnkSite)
	{
		HRESULT hr = IObjectWithSiteImpl<CAxHostWindow>::SetSite(pUnkSite);

		if (SUCCEEDED(hr) && m_spUnkSite)
		{
			// Look for "outer" IServiceProvider
			hr = m_spUnkSite->QueryInterface(__uuidof(IServiceProvider), (void**)&m_spServices);
			ATLASSERT( SUCCEEDED(hr) && "No ServiceProvider!" );
		}

		if (pUnkSite == NULL)
			m_spServices.Release();

		return hr;
	}

	// IOleClientSite
	STDMETHOD(SaveObject)()
	{
		ATLTRACENOTIMPL(_T("IOleClientSite::SaveObject"));
	}
	STDMETHOD(GetMoniker)(
		_In_ DWORD /*dwAssign*/,
		_In_ DWORD /*dwWhichMoniker*/,
		_In_opt_ IMoniker** /*ppmk*/)
	{
		ATLTRACENOTIMPL(_T("IOleClientSite::GetMoniker"));
	}
	STDMETHOD(GetContainer)(_Deref_out_ IOleContainer** ppContainer)
	{
		ATLTRACE(atlTraceHosting, 2, _T("IOleClientSite::GetContainer\n"));
		ATLASSERT(ppContainer != NULL);

		HRESULT hr = E_POINTER;
		if (ppContainer)
		{
			hr = E_NOTIMPL;
			(*ppContainer) = NULL;
			if (m_spUnkSite)
				hr = m_spUnkSite->QueryInterface(__uuidof(IOleContainer), (void**)ppContainer);
			if (FAILED(hr))
				hr = QueryInterface(__uuidof(IOleContainer), (void**)ppContainer);
		}
		return hr;
	}
	STDMETHOD(ShowObject)()
	{
		ATLTRACE(atlTraceHosting, 2, _T("IOleClientSite::ShowObject\r\n"));

		HDC hdc = CWindowImpl<CAxHostWindow>::GetDC();
		if (hdc == NULL)
			return E_FAIL;
		if (m_spViewObject)
			m_spViewObject->Draw(DVASPECT_CONTENT, -1, NULL, NULL, NULL, hdc, (RECTL*)&m_rcPos, (RECTL*)&m_rcPos, NULL, 0);
		CWindowImpl<CAxHostWindow>::ReleaseDC(hdc);
		return S_OK;
	}
	STDMETHOD(OnShowWindow)(_In_ BOOL /*fShow*/)
	{
		ATLTRACENOTIMPL(_T("IOleClientSite::OnShowWindow"));
	}
	STDMETHOD(RequestNewObjectLayout)()
	{
		ATLTRACENOTIMPL(_T("IOleClientSite::RequestNewObjectLayout"));
	}

	// IOleInPlaceSite
	STDMETHOD(GetWindow)(_Out_ HWND* phwnd)
	{
		ATLENSURE_RETURN(phwnd);
		*phwnd = m_hWnd;
		return S_OK;
	}
	STDMETHOD(ContextSensitiveHelp)(_In_ BOOL /*fEnterMode*/)
	{
		ATLTRACENOTIMPL(_T("IOleInPlaceSite::ContextSensitiveHelp"));
	}
	STDMETHOD(CanInPlaceActivate)()
	{
		return S_OK;
	}
	STDMETHOD(OnInPlaceActivate)()
	{
		// should only be called once the first time control is inplace-activated
		ATLASSUME(m_bInPlaceActive == FALSE);
		ATLASSUME(m_spInPlaceObjectWindowless == NULL);

		m_bInPlaceActive = TRUE;
		OleLockRunning(m_spOleObject, TRUE, FALSE);
		m_bWindowless = FALSE;
		m_spOleObject->QueryInterface(__uuidof(IOleInPlaceObject), (void**) &m_spInPlaceObjectWindowless);
		return S_OK;
	}
	STDMETHOD(OnUIActivate)()
	{
		ATLTRACE(atlTraceHosting, 2, _T("IOleInPlaceSite::OnUIActivate\n"));
		m_bUIActive = TRUE;
		return S_OK;
	}
ATLPREFAST_SUPPRESS(6387)
	STDMETHOD(GetWindowContext)(
		_Deref_out_ IOleInPlaceFrame** ppFrame,
		_Deref_out_ IOleInPlaceUIWindow** ppDoc,
		_Out_ LPRECT lprcPosRect,
		_Out_ LPRECT lprcClipRect,
		_Inout_ LPOLEINPLACEFRAMEINFO pFrameInfo)
	{
		if (ppFrame != NULL)
			*ppFrame = NULL;
		if (ppDoc != NULL)
			*ppDoc = NULL;
		if (ppFrame == NULL || ppDoc == NULL || lprcPosRect == NULL || lprcClipRect == NULL)
		{
			ATLASSERT(false);
			return E_POINTER;
		}

		if (!m_spInPlaceFrame)
		{
			CComObject<CAxFrameWindow>* pFrameWindow;
			HRESULT hRet = CComObject<CAxFrameWindow>::CreateInstance(&pFrameWindow);

			if(FAILED(hRet))
			{
				return hRet;
			}

			pFrameWindow->QueryInterface(__uuidof(IOleInPlaceFrame), (void**) &m_spInPlaceFrame);
			ATLASSUME(m_spInPlaceFrame);
		}
		if (!m_spInPlaceUIWindow)
		{
			CComObject<CAxUIWindow>* pUIWindow;
			HRESULT hRet = CComObject<CAxUIWindow>::CreateInstance(&pUIWindow);

			if(FAILED(hRet))
			{
				return hRet;
			}		

			pUIWindow->QueryInterface(__uuidof(IOleInPlaceUIWindow), (void**) &m_spInPlaceUIWindow);
			ATLASSUME(m_spInPlaceUIWindow);
		}
		HRESULT hr=S_OK;
		hr=m_spInPlaceFrame.CopyTo(ppFrame);
		if(FAILED(hr))
		{
			return hr;
		}
		hr=m_spInPlaceUIWindow.CopyTo(ppDoc);
		if(FAILED(hr))
		{
			return hr;
		}
		GetClientRect(lprcPosRect);
		GetClientRect(lprcClipRect);

		if (m_hAccel == NULL)
		{
			ACCEL ac = { 0,0,0 };
			m_hAccel = CreateAcceleratorTable(&ac, 1);
		}
		pFrameInfo->cb = sizeof(OLEINPLACEFRAMEINFO);
		pFrameInfo->fMDIApp = m_bMDIApp;
		pFrameInfo->hwndFrame = GetParent();
		pFrameInfo->haccel = m_hAccel;
		pFrameInfo->cAccelEntries = (m_hAccel != NULL) ? 1 : 0;

		return hr;
	}
ATLPREFAST_UNSUPPRESS()
	
	STDMETHOD(Scroll)(_In_ SIZE /*scrollExtant*/)
	{
		ATLTRACENOTIMPL(_T("IOleInPlaceSite::Scroll"));
	}
	STDMETHOD(OnUIDeactivate)(_In_ BOOL /*fUndoable*/)
	{
		ATLTRACE(atlTraceHosting, 2, _T("IOleInPlaceSite::OnUIDeactivate\n"));
		m_bUIActive = FALSE;
		return S_OK;
	}
	STDMETHOD(OnInPlaceDeactivate)()
	{
		m_bInPlaceActive = FALSE;
		m_spInPlaceObjectWindowless.Release();
		return S_OK;
	}
	STDMETHOD(DiscardUndoState)()
	{
		ATLTRACENOTIMPL(_T("IOleInPlaceSite::DiscardUndoState"));
	}
	STDMETHOD(DeactivateAndUndo)()
	{
		ATLTRACENOTIMPL(_T("IOleInPlaceSite::DeactivateAndUndo"));
	}
	STDMETHOD(OnPosRectChange)(_In_ LPCRECT lprcPosRect)
	{
		ATLTRACE2(atlTraceHosting, 0, 	_T("IOleInPlaceSite::OnPosRectChange"));
		if (lprcPosRect==NULL) { return E_POINTER; }

		// Use MoveWindow() to resize the CAxHostWindow.
		// The CAxHostWindow handler for OnSize() will
		// take care of calling IOleInPlaceObject::SetObjectRects().

		// Convert to parent window coordinates for MoveWindow().
		RECT rect = *lprcPosRect;
		ClientToScreen( &rect );
		HWND hWnd = GetParent();

		// Check to make sure it's a non-top-level window.
		if(hWnd != NULL)
		{
			CWindow wndParent(hWnd);
			wndParent.ScreenToClient(&rect);
			wndParent.Detach ();
		}
		// Do the actual move.
		MoveWindow( &rect);

		return S_OK;
	}

// IOleInPlaceSiteEx
	STDMETHOD(OnInPlaceActivateEx)(
		_In_opt_ BOOL* /*pfNoRedraw*/,
		_In_ DWORD dwFlags)
	{
		// should only be called once the first time control is inplace-activated
		ATLASSUME(m_bInPlaceActive == FALSE);
		ATLASSUME(m_spInPlaceObjectWindowless == NULL);

		m_bInPlaceActive = TRUE;
		OleLockRunning(m_spOleObject, TRUE, FALSE);
		HRESULT hr = E_FAIL;
		if (dwFlags & ACTIVATE_WINDOWLESS)
		{
			m_bWindowless = TRUE;
			hr = m_spOleObject->QueryInterface(__uuidof(IOleInPlaceObjectWindowless), (void**) &m_spInPlaceObjectWindowless);
		}
		if (FAILED(hr))
		{
			m_bWindowless = FALSE;
			hr = m_spOleObject->QueryInterface(__uuidof(IOleInPlaceObject), (void**) &m_spInPlaceObjectWindowless);
		}
		if (m_spInPlaceObjectWindowless)
			m_spInPlaceObjectWindowless->SetObjectRects(&m_rcPos, &m_rcPos);
		return S_OK;
	}
	STDMETHOD(OnInPlaceDeactivateEx)(_In_ BOOL /*fNoRedraw*/)
	{
		m_bInPlaceActive = FALSE;
		m_spInPlaceObjectWindowless.Release();
		return S_OK;
	}
	STDMETHOD(RequestUIActivate)()
	{
		return S_OK;
	}

// IOleInPlaceSiteWindowless
	HDC m_hDCScreen;
	bool m_bDCReleased;

	STDMETHOD(CanWindowlessActivate)()
	{
		return m_bCanWindowlessActivate ? S_OK : S_FALSE;
	}
	STDMETHOD(GetCapture)()
	{
		return m_bCapture ? S_OK : S_FALSE;
	}
	STDMETHOD(SetCapture)(_In_ BOOL fCapture)
	{
		if (fCapture)
		{
			CWindow::SetCapture();
			m_bCapture = TRUE;
		}
		else
		{
			ReleaseCapture();
			m_bCapture = FALSE;
		}
		return S_OK;
	}
	STDMETHOD(GetFocus)()
	{
		return m_bHaveFocus ? S_OK : S_FALSE;
	}
	STDMETHOD(SetFocus)(_In_ BOOL fGotFocus)
	{
		m_bHaveFocus = fGotFocus;
		return S_OK;
	}
	STDMETHOD(GetDC)(
		_In_opt_ LPCRECT /*pRect*/,
		_In_ DWORD grfFlags,
		_Out_ HDC* phDC)
	{
		if (phDC == NULL)
			return E_POINTER;
		if (!m_bDCReleased)
			return E_FAIL;

		*phDC = CWindowImpl<CAxHostWindow>::GetDC();
		if (*phDC == NULL)
			return E_FAIL;

		m_bDCReleased = false;

		if (grfFlags & OLEDC_NODRAW)
			return S_OK;

		RECT rect;
		GetClientRect(&rect);
		if (grfFlags & OLEDC_OFFSCREEN)
		{
			HDC hDCOffscreen = CreateCompatibleDC(*phDC);
			if (hDCOffscreen != NULL)
			{
				HBITMAP hBitmap = CreateCompatibleBitmap(*phDC, rect.right - rect.left, rect.bottom - rect.top);
				if (hBitmap == NULL)
					DeleteDC(hDCOffscreen);
				else
				{
					HGDIOBJ hOldBitmap = SelectObject(hDCOffscreen, hBitmap);
					if (hOldBitmap == NULL)
					{
						DeleteObject(hBitmap);
						DeleteDC(hDCOffscreen);
					}
					else
					{
						DeleteObject(hOldBitmap);
						m_hDCScreen = *phDC;
						*phDC = hDCOffscreen;
					}
				}
			}
		}

		if (grfFlags & OLEDC_PAINTBKGND)
			::FillRect(*phDC, &rect, (HBRUSH) (COLOR_WINDOW+1));
		return S_OK;
	}
	STDMETHOD(ReleaseDC)(_Inout_ HDC hDC)
	{
		m_bDCReleased = true;
		if (m_hDCScreen != NULL)
		{
			RECT rect;
			GetClientRect(&rect);
			// Offscreen DC has to be copied to screen DC before releasing the screen dc;
			BitBlt(m_hDCScreen, rect.left, rect.top, rect.right - rect.left, rect.bottom - rect.top, hDC, 0, 0, SRCCOPY);
			DeleteDC(hDC);
			hDC = m_hDCScreen;
		}

		CWindowImpl<CAxHostWindow>::ReleaseDC(hDC);
		return S_OK;
	}
	STDMETHOD(InvalidateRect)(
		_In_opt_ LPCRECT pRect,
		_In_ BOOL fErase)
	{
		CWindowImpl<CAxHostWindow>::InvalidateRect(pRect, fErase);
		return S_OK;
	}
	STDMETHOD(InvalidateRgn)(
		_In_ HRGN hRGN,
		_In_ BOOL fErase)
	{
		CWindowImpl<CAxHostWindow>::InvalidateRgn(hRGN, fErase);
		return S_OK;
	}
	STDMETHOD(ScrollRect)(
		_In_ INT /*dx*/,
		_In_ INT /*dy*/,
		_In_ LPCRECT /*pRectScroll*/,
		_In_ LPCRECT /*pRectClip*/)
	{
		return S_OK;
	}
	STDMETHOD(AdjustRect)(_In_ LPRECT /*prc*/)
	{
		return S_OK;
	}
	STDMETHOD(OnDefWindowMessage)(
		_In_ UINT msg,
		_In_ WPARAM wParam,
		_In_ LPARAM lParam,
		_Out_ LRESULT* plResult)
	{
		*plResult = DefWindowProc(msg, wParam, lParam);
		return S_OK;
	}

	// IOleControlSite
	STDMETHOD(OnControlInfoChanged)()
	{
		return S_OK;
	}
	STDMETHOD(LockInPlaceActive)(_In_ BOOL /*fLock*/)
	{
		return S_OK;
	}
	STDMETHOD(GetExtendedControl)(_Deref_out_ IDispatch** ppDisp)
	{
		if (ppDisp == NULL)
			return E_POINTER;
		return m_spOleObject.QueryInterface(ppDisp);
	}
	STDMETHOD(TransformCoords)(
		_Inout_ POINTL* /*pPtlHimetric*/,
		_Inout_ POINTF* /*pPtfContainer*/,
		_In_ DWORD /*dwFlags*/)
	{
		ATLTRACENOTIMPL(_T("CAxHostWindow::TransformCoords"));
	}
	STDMETHOD(TranslateAccelerator)(
		_In_ LPMSG /*lpMsg*/,
		_In_ DWORD /*grfModifiers*/)
	{
		return S_FALSE;
	}
	STDMETHOD(OnFocus)(_In_ BOOL fGotFocus)
	{
		m_bHaveFocus = fGotFocus;
		return S_OK;
	}
	STDMETHOD(ShowPropertyFrame)()
	{
		ATLTRACENOTIMPL(_T("CAxHostWindow::ShowPropertyFrame"));
	}

	// IAdviseSink
	STDMETHOD_(void, OnDataChange)(
		_In_ FORMATETC* /* pFormatetc */,
		_In_ STGMEDIUM* /* pStgmed */)
	{
	}
	STDMETHOD_(void, OnViewChange)(
		_In_ DWORD /*dwAspect*/,
		_In_ LONG /*lindex*/)
	{
	}
	STDMETHOD_(void, OnRename)(_In_opt_ IMoniker* /* pmk */)
	{
	}
	STDMETHOD_(void, OnSave)()
	{
	}
	STDMETHOD_(void, OnClose)()
	{
	}

	// IOleContainer
	STDMETHOD(ParseDisplayName)(
		_In_opt_ IBindCtx* /*pbc*/,
		_In_opt_z_ LPOLESTR /*pszDisplayName*/,
		_In_opt_ ULONG* /*pchEaten*/,
		_In_opt_ IMoniker** /*ppmkOut*/)
	{
		ATLTRACENOTIMPL(_T("CAxHostWindow::ParseDisplayName"));
	}
	
ATLPREFAST_SUPPRESS(6387)
	STDMETHOD(EnumObjects)(
		_In_ DWORD /*grfFlags*/,
		_Deref_out_ IEnumUnknown** ppenum)
	{
		if (ppenum == NULL)
			return E_POINTER;
		*ppenum = NULL;
		typedef CComObject<CComEnum<IEnumUnknown, &__uuidof(IEnumUnknown), IUnknown*, _CopyInterface<IUnknown> > > enumunk;
		enumunk* p = NULL;

ATLPREFAST_SUPPRESS(6014)
		/* prefast noise VSW 489981 */
		ATLTRY(p = new enumunk);
ATLPREFAST_UNSUPPRESS()
	
		if(p == NULL)
			return E_OUTOFMEMORY;
		IUnknown* pTemp = m_spUnknown;
		// There is always only one object.
		HRESULT hRes = p->Init(reinterpret_cast<IUnknown**>(&pTemp), reinterpret_cast<IUnknown**>(&pTemp + 1), GetControllingUnknown(), AtlFlagCopy);
		if (SUCCEEDED(hRes))
			hRes = p->QueryInterface(__uuidof(IEnumUnknown), (void**)ppenum);
		if (FAILED(hRes))
			delete p;
		return hRes;
	}
ATLPREFAST_UNSUPPRESS()
	
	STDMETHOD(LockContainer)(_In_ BOOL fLock)
	{
		m_bLocked = fLock;
		return S_OK;
	}

	HRESULT ActivateAx(
		_Inout_opt_ IUnknown* pUnkControl,
		_In_ bool bInited,
		_Inout_opt_ IStream* pStream)
	{
		if (pUnkControl == NULL)
			return S_OK;

		m_spUnknown = pUnkControl;

		HRESULT hr = S_OK;
		pUnkControl->QueryInterface(__uuidof(IOleObject), (void**)&m_spOleObject);
		if (m_spOleObject)
		{
			m_spOleObject->GetMiscStatus(DVASPECT_CONTENT, &m_dwMiscStatus);
			if (m_dwMiscStatus & OLEMISC_SETCLIENTSITEFIRST)
			{
				CComQIPtr<IOleClientSite> spClientSite(GetControllingUnknown());
				m_spOleObject->SetClientSite(spClientSite);
			}

			if (!bInited) // If user hasn't initialized the control, initialize/load using IPersistStreamInit or IPersistStream
			{
				CComQIPtr<IPersistStreamInit> spPSI(m_spOleObject);
				if (spPSI)
				{
					if (pStream)
						hr = spPSI->Load(pStream);
					else
						hr = spPSI->InitNew();
				}
				else if (pStream)
				{
					CComQIPtr<IPersistStream> spPS(m_spOleObject);
					if (spPS)
						hr = spPS->Load(pStream);
				}

				if (FAILED(hr)) // If the initialization of the control failed...
				{
					// Clean up and return
					if (m_dwMiscStatus & OLEMISC_SETCLIENTSITEFIRST)
						m_spOleObject->SetClientSite(NULL);

					m_dwMiscStatus = 0;
					m_spOleObject.Release();
					m_spUnknown.Release();

					return hr;
				}
			}

			if (0 == (m_dwMiscStatus & OLEMISC_SETCLIENTSITEFIRST))
			{
				CComQIPtr<IOleClientSite> spClientSite(GetControllingUnknown());
				m_spOleObject->SetClientSite(spClientSite);
			}

			m_dwViewObjectType = 0;
			hr = m_spOleObject->QueryInterface(__uuidof(IViewObjectEx), (void**) &m_spViewObject);
			if (FAILED(hr))
			{
				hr = m_spOleObject->QueryInterface(__uuidof(IViewObject2), (void**) &m_spViewObject);
				if (SUCCEEDED(hr))
					m_dwViewObjectType = 3;
			} else
				m_dwViewObjectType = 7;

			if (FAILED(hr))
			{
				hr = m_spOleObject->QueryInterface(__uuidof(IViewObject), (void**) &m_spViewObject);
				if (SUCCEEDED(hr))
					m_dwViewObjectType = 1;
			}
			CComQIPtr<IAdviseSink> spAdviseSink(GetControllingUnknown());
			m_spOleObject->Advise(spAdviseSink, &m_dwOleObject);
			if (m_spViewObject)
				m_spViewObject->SetAdvise(DVASPECT_CONTENT, 0, spAdviseSink);
			m_spOleObject->SetHostNames(OLESTR("AXWIN"), NULL);

			if ((m_dwMiscStatus & OLEMISC_INVISIBLEATRUNTIME) == 0)
			{
				GetClientRect(&m_rcPos);
				m_pxSize.cx = m_rcPos.right - m_rcPos.left;
				m_pxSize.cy = m_rcPos.bottom - m_rcPos.top;
				AtlPixelToHiMetric(&m_pxSize, &m_hmSize);
				m_spOleObject->SetExtent(DVASPECT_CONTENT, &m_hmSize);
				m_spOleObject->GetExtent(DVASPECT_CONTENT, &m_hmSize);
				AtlHiMetricToPixel(&m_hmSize, &m_pxSize);
				m_rcPos.right = m_rcPos.left + m_pxSize.cx;
				m_rcPos.bottom = m_rcPos.top + m_pxSize.cy;

				CComQIPtr<IOleClientSite> spClientSite(GetControllingUnknown());
				hr = m_spOleObject->DoVerb(OLEIVERB_INPLACEACTIVATE, NULL, spClientSite, 0, m_hWnd, &m_rcPos);
				RedrawWindow(NULL, NULL, RDW_INVALIDATE | RDW_UPDATENOW | RDW_ERASE | RDW_INTERNALPAINT | RDW_FRAME);
			}
		}
		CComPtr<IObjectWithSite> spSite;
		pUnkControl->QueryInterface(__uuidof(IObjectWithSite), (void**)&spSite);
		if (spSite != NULL)
			spSite->SetSite(GetControllingUnknown());

		return hr;
	}


// pointers
	CComPtr<IUnknown> m_spUnknown;
	CComPtr<IOleObject> m_spOleObject;
	CComPtr<IOleInPlaceFrame> m_spInPlaceFrame;
	CComPtr<IOleInPlaceUIWindow> m_spInPlaceUIWindow;
	CComPtr<IViewObjectEx> m_spViewObject;
	CComPtr<IOleInPlaceObjectWindowless> m_spInPlaceObjectWindowless;
	CComPtr<IDispatch> m_spExternalDispatch;
#ifndef _ATL_NO_DOCHOSTUIHANDLER
	CComPtr<IDocHostUIHandlerDispatch> m_spIDocHostUIHandlerDispatch;
#endif
	IID m_iidSink;
	DWORD m_dwViewObjectType;
	DWORD m_dwAdviseSink;

	// state
	unsigned long m_bInPlaceActive:1;
	unsigned long m_bUIActive:1;
	unsigned long m_bMDIApp:1;
	unsigned long m_bWindowless:1;
	unsigned long m_bCapture:1;
	unsigned long m_bHaveFocus:1;
	unsigned long m_bReleaseAll:1;
	unsigned long m_bLocked:1;

	DWORD m_dwOleObject;
	DWORD m_dwMiscStatus;
	SIZEL m_hmSize;
	SIZEL m_pxSize;
	RECT m_rcPos;

	// Accelerator table
	HACCEL m_hAccel;

	// Ambient property storage
	unsigned long m_bCanWindowlessActivate:1;
	unsigned long m_bUserMode:1;
	unsigned long m_bDisplayAsDefault:1;
	unsigned long m_bMessageReflect:1;
	unsigned long m_bSubclassed:1;
	unsigned long m_bAllowContextMenu:1;
	unsigned long m_bAllowShowUI:1;
	OLE_COLOR m_clrBackground;
	OLE_COLOR m_clrForeground;
	LCID m_lcidLocaleID;
	CComPtr<IFontDisp> m_spFont;
	CComPtr<IServiceProvider>  m_spServices;
	DWORD m_dwDocHostFlags;
	DWORD m_dwDocHostDoubleClickFlags;
	CComBSTR m_bstrOptionKeyPath;

	void SubclassWindow(_In_ HWND hWnd)
	{
		m_bSubclassed = CWindowImpl<CAxHostWindow>::SubclassWindow(hWnd);
	}

	void ReleaseWindow()
	{
		if (m_bSubclassed)
		{
			if(UnsubclassWindow(TRUE) != NULL)
				m_bSubclassed = FALSE;
		}
		else
			DestroyWindow();
	}

	// Reflection
	LRESULT ReflectNotifications(
		_In_ UINT uMsg,
		_In_ WPARAM wParam,
		_In_ LPARAM lParam,
		_Inout_ BOOL& bHandled)
	{
		HWND hWndChild = NULL;

		switch(uMsg)
		{
		case WM_COMMAND:
			if(lParam != 0)	// not from a menu
				hWndChild = (HWND)lParam;
			break;
		case WM_NOTIFY:
			hWndChild = ((LPNMHDR)lParam)->hwndFrom;
			break;
		case WM_PARENTNOTIFY:
			DefWindowProc();
			switch(LOWORD(wParam))
			{
			case WM_CREATE:
			case WM_DESTROY:
				hWndChild = (HWND)lParam;
				break;
			default:
				hWndChild = GetDlgItem(HIWORD(wParam));
				break;
			}
			break;
		case WM_DRAWITEM:
			{
				DRAWITEMSTRUCT* pdis = ((LPDRAWITEMSTRUCT)lParam);
				if (pdis->CtlType != ODT_MENU)	// not from a menu
					hWndChild = pdis->hwndItem;
				else							// Status bar control sends this message with type set to ODT_MENU
					if (::IsWindow(pdis->hwndItem))
						hWndChild = pdis->hwndItem;
			}
			break;
		case WM_MEASUREITEM:
			{
				MEASUREITEMSTRUCT* pmis = ((LPMEASUREITEMSTRUCT)lParam);
				if(pmis->CtlType != ODT_MENU)	// not from a menu
					hWndChild = GetDlgItem(pmis->CtlID);
			}
			break;
		case WM_COMPAREITEM:
				// Sent only by combo or list box
					hWndChild =((LPCOMPAREITEMSTRUCT)lParam)->hwndItem;
			break;
		case WM_DELETEITEM:
				// Sent only by combo or list box
				hWndChild = ((LPDELETEITEMSTRUCT)lParam)->hwndItem;
			break;
		case WM_VKEYTOITEM:
		case WM_CHARTOITEM:
		case WM_HSCROLL:
		case WM_VSCROLL:
			hWndChild = (HWND)lParam;
			break;
		case WM_CTLCOLORBTN:
		case WM_CTLCOLORDLG:
		case WM_CTLCOLOREDIT:
		case WM_CTLCOLORLISTBOX:
		case WM_CTLCOLORMSGBOX:
		case WM_CTLCOLORSCROLLBAR:
		case WM_CTLCOLORSTATIC:
			hWndChild = (HWND)lParam;
			break;
		default:
			break;
		}

		if(hWndChild == NULL)
		{
			bHandled = FALSE;
			return 1;
		}

		if (m_bWindowless)
		{
			LRESULT lRes = 0;
			if (m_bInPlaceActive && m_spInPlaceObjectWindowless)
				m_spInPlaceObjectWindowless->OnWindowMessage(OCM__BASE + uMsg, wParam, lParam, &lRes);
			return lRes;
		}

		ATLASSERT(::IsWindow(hWndChild));
		return ::SendMessage(hWndChild, OCM__BASE + uMsg, wParam, lParam);
	}

ATLPREFAST_SUPPRESS(6387)
	STDMETHOD(QueryService)(
		_In_ REFGUID rsid,
		_In_ REFIID riid,
		_Deref_out_ void** ppvObj)
	{
		ATLASSERT(ppvObj != NULL);
		if (ppvObj == NULL)
			return E_POINTER;
		*ppvObj = NULL;

		HRESULT hr = E_NOINTERFACE;
		// Try for service on this object

		// No services currently

		// If that failed try to find the service on the outer object
		if (m_spServices)
		{
			hr = m_spServices->QueryService(rsid, riid, ppvObj);
		}

		return hr;
	}
ATLPREFAST_UNSUPPRESS()
	
};

static LRESULT CALLBACK AtlAxWindowProc(
	_In_ HWND hWnd,
	_In_ UINT uMsg,
	_In_ WPARAM wParam,
	_In_ LPARAM lParam)
{
	switch(uMsg)
	{
	case WM_CREATE:
		{
			// create control from a PROGID in the title
			// This is to make sure drag drop works
			::OleInitialize(NULL);

			CREATESTRUCT* lpCreate = (CREATESTRUCT*)lParam;
			int nLen = ::GetWindowTextLength(hWnd);
			CAutoStackPtr<TCHAR> spName((TCHAR *)_malloca((nLen + 1) * sizeof(TCHAR)));
			if(!spName)
			{
				return -1;
			}
			::GetWindowText(hWnd, spName, nLen + 1);
			::SetWindowText(hWnd, _T(""));
			IAxWinHostWindow* pAxWindow = NULL;
			int nCreateSize = 0;
			if (lpCreate && lpCreate->lpCreateParams)
				nCreateSize = *((WORD*)lpCreate->lpCreateParams);

			CComPtr<IStream> spStream;
			if (nCreateSize)
			{
				HGLOBAL h = GlobalAlloc(GHND, nCreateSize);
				if (h)
				{
					BYTE* pBytes = (BYTE*) GlobalLock(h);
					BYTE* pSource = ((BYTE*)(lpCreate->lpCreateParams)) + sizeof(WORD);
					//Align to DWORD
					//pSource += (((~((DWORD)pSource)) + 1) & 3);
					Checked::memcpy_s(pBytes, nCreateSize, pSource, nCreateSize);
					GlobalUnlock(h);
					CreateStreamOnHGlobal(h, TRUE, &spStream);
				}
			}

			USES_CONVERSION_EX;
			CComPtr<IUnknown> spUnk;
			LPCOLESTR lpszName = T2COLE_EX_DEF(spName);
			ATLASSUME(lpszName);			
			HRESULT hRet = AtlAxCreateControlLic(lpszName, hWnd, spStream, &spUnk, NULL);
			if(FAILED(hRet))
			{
#ifdef _DEBUG
				LPTSTR pszMsg = NULL;
				::FormatMessage(FORMAT_MESSAGE_ALLOCATE_BUFFER|FORMAT_MESSAGE_FROM_SYSTEM, NULL, hRet, 0, (LPTSTR)&pszMsg, 0, NULL);
				ATLTRACE(atlTraceControls, 0, _T("Control creation failed for '%s'\n"), static_cast<TCHAR *>(spName));
				ATLTRACE(atlTraceControls, 0, _T("Error code: 0x%x - %s"), hRet, pszMsg);
				::LocalFree(pszMsg);
#endif
				return -1;	// abort window creation
			}
			hRet = spUnk->QueryInterface(__uuidof(IAxWinHostWindow), (void**)&pAxWindow);
			if(FAILED(hRet))
				return -1;	// abort window creation

			::SetWindowLongPtr(hWnd, GWLP_USERDATA, (DWORD_PTR)pAxWindow);
		// continue with DefWindowProc
		}
		break;
	case WM_NCDESTROY:
		{
			IAxWinHostWindow* pAxWindow = (IAxWinHostWindow*)::GetWindowLongPtr(hWnd, GWLP_USERDATA);
			if(pAxWindow != NULL)
				pAxWindow->Release();
			OleUninitialize();
		}
		break;

	case WM_PARENTNOTIFY:
		{
			if(LOWORD( wParam ) == WM_CREATE)
			{
				ATLASSERT(lParam);
				// Set the control parent style for the AxWindow
				if(lParam != 0) {
					DWORD dwExStyle = ::GetWindowLong((HWND)lParam, GWL_EXSTYLE);
					if(dwExStyle & WS_EX_CONTROLPARENT)
					{
						dwExStyle = ::GetWindowLong(hWnd, GWL_EXSTYLE);
						dwExStyle |= WS_EX_CONTROLPARENT;
						::SetWindowLong(hWnd, GWL_EXSTYLE, dwExStyle);
					}
				}
			}
		}
		break;

	default:
		break;
	}

	return ::DefWindowProc(hWnd, uMsg, wParam, lParam);
}

static LRESULT CALLBACK AtlAxWindowProc2(
	_In_ HWND hWnd,
	_In_ UINT uMsg,
	_In_ WPARAM wParam,
	_In_ LPARAM lParam)
{
	switch(uMsg)
	{
	case WM_CREATE:
		{
		// create control from a PROGID in the title
			// This is to make sure drag drop works
			::OleInitialize(NULL);

			CREATESTRUCT* lpCreate = (CREATESTRUCT*)lParam;
			int nLen = ::GetWindowTextLength(hWnd);
			CAutoStackPtr<TCHAR> spName((TCHAR *)_malloca((nLen + 1) * sizeof(TCHAR)));
			if(!spName)
			{
				return -1;
			}
			::GetWindowText(hWnd, spName, nLen + 1);
			::SetWindowText(hWnd, _T(""));
			IAxWinHostWindowLic* pAxWindow = NULL;
			int nCreateSize = 0;
			if (lpCreate && lpCreate->lpCreateParams)
				nCreateSize = *((WORD*)lpCreate->lpCreateParams);

			// Format of data in lpCreateParams
			//	int nCreateSize;	// size of Create data in bytes
			//	WORD nMsg;			//constant used to indicate type of DLGINIT data. See _DialogSplitHelper for values.
			//	DWORD dwLen;		// Length of data strored for control in DLGINIT format in bytes.
			//	DWORD cchLicKey;	// Length of licence key in OLECHAR's
			//  OLECHAR *szLicKey;	// This will be present only if cchLicKey is greater than 0. This is of variable length and will contain cchLicKey OLECHAR's that represent the licence key.
			//	The following two fields will be present only if nMsg is WM_OCC_LOADFROMSTREAM_EX or WM_OCC_LOADFROMSTORAGE_EX. If present this information will be ignored since databinding is not supported.
			//		ULONG cbDataBinding;	// Lenght of databinding information in bytes.
			//		BYTE *pbDataBindingInfo	// cbDataBinding bytes that contain databinding information
			//	BYTE *pbControlData;	// Actual control data persisted by the control.


			CComPtr<IStream> spStream;
			if (nCreateSize)
			{
				HGLOBAL h = GlobalAlloc(GHND, nCreateSize);
				if (h)
				{
					BYTE* pBytes = (BYTE*) GlobalLock(h);
					BYTE* pSource = ((BYTE*)(lpCreate->lpCreateParams)) + sizeof(WORD);
					//Align to DWORD
					//pSource += (((~((DWORD)pSource)) + 1) & 3);
					Checked::memcpy_s(pBytes, nCreateSize, pSource, nCreateSize);
					GlobalUnlock(h);
					CreateStreamOnHGlobal(h, TRUE, &spStream);
				}
			}

			CComBSTR bstrLicKey;
			HRESULT hRet = _DialogSplitHelper::ParseInitData(spStream, &bstrLicKey.m_str);
			if (FAILED(hRet))
				return -1;

			USES_CONVERSION_EX;
			CComPtr<IUnknown> spUnk;
			LPCOLESTR lpszName = T2COLE_EX_DEF(spName);
			ATLASSUME(lpszName);			
			hRet = AtlAxCreateControlLic(lpszName, hWnd, spStream, &spUnk, bstrLicKey);
			if(FAILED(hRet))
			{
#ifdef _DEBUG
				LPTSTR pszMsg = NULL;
				::FormatMessage(FORMAT_MESSAGE_ALLOCATE_BUFFER|FORMAT_MESSAGE_FROM_SYSTEM, NULL, hRet, 0, (LPTSTR)&pszMsg, 0, NULL);
				ATLTRACE(atlTraceControls, 0, _T("Control creation failed for '%s'\n"), static_cast<TCHAR *>(spName));
				ATLTRACE(atlTraceControls, 0, _T("Error code: 0x%x - %s"), hRet, pszMsg);
				::LocalFree(pszMsg);
#endif
				return -1;	// abort window creation
			}
			hRet = spUnk->QueryInterface(__uuidof(IAxWinHostWindowLic), (void**)&pAxWindow);
			if(FAILED(hRet))
				return -1;	// abort window creation
			::SetWindowLongPtr(hWnd, GWLP_USERDATA, (DWORD_PTR)pAxWindow);
		// continue with DefWindowProc
		}
		break;
	case WM_NCDESTROY:
		{
			IAxWinHostWindowLic* pAxWindow = (IAxWinHostWindowLic*)::GetWindowLongPtr(hWnd, GWLP_USERDATA);
			if(pAxWindow != NULL)
				pAxWindow->Release();
			OleUninitialize();
		}
		break;

	case WM_PARENTNOTIFY:
		{
			if(LOWORD( wParam ) == WM_CREATE)
			{
				ATLASSERT(lParam);
				// Set the control parent style for the AxWindow
				if(lParam != 0) {
					DWORD dwExStyle = ::GetWindowLong((HWND)lParam, GWL_EXSTYLE);
					if(dwExStyle & WS_EX_CONTROLPARENT)
					{
						dwExStyle = ::GetWindowLong(hWnd, GWL_EXSTYLE);
						dwExStyle |= WS_EX_CONTROLPARENT;
						::SetWindowLong(hWnd, GWL_EXSTYLE, dwExStyle);
					}
				}
			}
		}
		break;

	default:
		break;
	}

	return ::DefWindowProc(hWnd, uMsg, wParam, lParam);
}

//All exports go here
#ifndef _ATL_DLL

inline HRSRC AtlFindResource(
	_In_opt_ HMODULE hModule,
	_In_z_ LPCSTR lpName,
	_In_z_ LPCSTR lpType)
{
	return ::FindResourceA(hModule, lpName, lpType);
}

inline HRSRC AtlFindResource(
	_In_opt_ HMODULE hModule,
	_In_z_ LPCWSTR lpName,
	_In_z_ LPCWSTR lpType)
{
	return ::FindResourceW(hModule, lpName, lpType);
}

class _AtlDialogBoxIndirectParamHelper
{
public :
	typedef INT_PTR ReturnType;
	static ReturnType GetInvalidValue()
	{
		return -1;
	}
	static bool IsValidReturnVal(_In_ ReturnType nRet)
	{
		return (nRet != 0 && nRet != -1);
	}
};

class _AtlCreateDialogIndirectParamHelper
{
public :
	typedef HWND ReturnType;
	static ReturnType GetInvalidValue()
	{
		return NULL;
	}
	static bool IsValidReturnVal(_In_ ReturnType nRet)
	{
		return (nRet != 0);
	}
};

template <class StringType, class Helper, typename Helper::ReturnType (WINAPI *pFunc)(HINSTANCE, LPCDLGTEMPLATE, HWND,DLGPROC, LPARAM)>
typename Helper::ReturnType AtlAxDialogCreateT(
	_In_ HINSTANCE hInstance,
	_In_z_ StringType lpTemplateName,
	_In_ HWND hWndParent,
	_In_ DLGPROC lpDialogProc,
	_In_ LPARAM dwInitParam)
{
	AtlAxWinInit();
	Helper::ReturnType nRet = Helper::GetInvalidValue();

	HRSRC hDlg = AtlFindResource(hInstance, lpTemplateName, (StringType)RT_DIALOG);
	if (hDlg != NULL)
	{
		HRSRC hDlgInit = AtlFindResource(hInstance, lpTemplateName, (StringType)_ATL_RT_DLGINIT);
		HGLOBAL hData = NULL;
		BYTE* pInitData = NULL;

		if (hDlgInit)
		{
			hData = ::LoadResource(hInstance, hDlgInit);
			ATLASSUME(hData != NULL);
			pInitData = (BYTE*) ::LockResource(hData);
		}

		DWORD dwLastError = 0;
		HGLOBAL hResource = LoadResource(hInstance, hDlg);
		if (hResource != NULL)
		{
			DLGTEMPLATE* pDlg = (DLGTEMPLATE*) LockResource(hResource);
			if (pDlg != NULL)
			{
				LPCDLGTEMPLATE lpDialogTemplate;

				lpDialogTemplate = _DialogSplitHelper::SplitDialogTemplate(pDlg, pInitData);

				nRet = (*pFunc)(hInstance, lpDialogTemplate, hWndParent, lpDialogProc, dwInitParam);
				if (!Helper::IsValidReturnVal(nRet))
				{
					dwLastError = ::GetLastError();
				}
				if (lpDialogTemplate != pDlg)
					GlobalFree(GlobalHandle(lpDialogTemplate));
			}
			else
				dwLastError = ::GetLastError();
		}
		else
			dwLastError = ::GetLastError();

		if (dwLastError != 0)
			SetLastError(dwLastError);
	}
	return nRet;
}

ATLINLINE ATLAPI_(INT_PTR) AtlAxDialogBoxW(
	_In_ HINSTANCE hInstance,
	_In_z_ LPCWSTR lpTemplateName,
	_In_ HWND hWndParent,
	_In_ DLGPROC lpDialogProc,
	_In_ LPARAM dwInitParam)
{
	return AtlAxDialogCreateT<LPCWSTR, _AtlDialogBoxIndirectParamHelper, ::DialogBoxIndirectParamW>(
		hInstance, lpTemplateName, hWndParent, lpDialogProc, dwInitParam);
}

ATLINLINE ATLAPI_(INT_PTR) AtlAxDialogBoxA(
	_In_ HINSTANCE hInstance,
	_In_z_ LPCSTR lpTemplateName,
	_In_ HWND hWndParent,
	_In_ DLGPROC lpDialogProc,
	_In_ LPARAM dwInitParam)
{
	return AtlAxDialogCreateT<LPCSTR, _AtlDialogBoxIndirectParamHelper, ::DialogBoxIndirectParamA>(
		hInstance, lpTemplateName, hWndParent, lpDialogProc, dwInitParam);
}

ATLINLINE ATLAPI_(HWND) AtlAxCreateDialogW(
	_In_ HINSTANCE hInstance,
	_In_z_ LPCWSTR lpTemplateName,
	_In_ HWND hWndParent,
	_In_ DLGPROC lpDialogProc,
	_In_ LPARAM dwInitParam)
{
	return AtlAxDialogCreateT<LPCWSTR, _AtlCreateDialogIndirectParamHelper, CreateDialogIndirectParamW>(
		hInstance, lpTemplateName, hWndParent, lpDialogProc, dwInitParam);
}

ATLINLINE ATLAPI_(HWND) AtlAxCreateDialogA(
	_In_ HINSTANCE hInstance,
	_In_z_ LPCSTR lpTemplateName,
	_In_ HWND hWndParent,
	_In_ DLGPROC lpDialogProc,
	_In_ LPARAM dwInitParam)
{
	return AtlAxDialogCreateT<LPCSTR, _AtlCreateDialogIndirectParamHelper, CreateDialogIndirectParamA>(hInstance, lpTemplateName, hWndParent, lpDialogProc, dwInitParam);
}

ATLINLINE ATLAPI AtlAxCreateControl(
	_In_z_ LPCOLESTR lpszName,
	_In_ HWND hWnd,
	_Inout_opt_ IStream* pStream,
	_Deref_out_ IUnknown** ppUnkContainer)
{
	return AtlAxCreateControlEx(lpszName, hWnd, pStream, ppUnkContainer, NULL, IID_NULL, NULL);
}

ATLINLINE ATLAPI AtlAxCreateControlEx(
	_In_z_ LPCOLESTR lpszName,
	_In_ HWND hWnd,
	_Inout_opt_ IStream* pStream,
	_Deref_opt_out_ IUnknown** ppUnkContainer,
	_Deref_opt_out_ IUnknown** ppUnkControl,
	_In_ REFIID iidSink,
	_Inout_opt_ IUnknown* punkSink)
{
	return AtlAxCreateControlLicEx(lpszName, hWnd, pStream, ppUnkContainer, ppUnkControl, iidSink, punkSink, NULL);
}

ATLINLINE ATLAPI AtlAxCreateControlLic(
	_In_z_ LPCOLESTR lpszName,
	_In_ HWND hWnd,
	_Inout_opt_ IStream* pStream,
	_Deref_opt_out_ IUnknown** ppUnkContainer,
	_In_opt_z_ BSTR bstrLic)
{
	return AtlAxCreateControlLicEx(lpszName, hWnd, pStream, ppUnkContainer, NULL, IID_NULL, NULL, bstrLic);
}

ATLPREFAST_SUPPRESS(6387)
ATLINLINE ATLAPI AtlAxCreateControlLicEx(
	_In_z_ LPCOLESTR lpszName,
	_In_ HWND hWnd,
	_Inout_opt_ IStream* pStream,
	_Deref_opt_out_ IUnknown** ppUnkContainer,
	_Deref_opt_out_ IUnknown** ppUnkControl,
	_In_ REFIID iidSink,
	_Inout_opt_ IUnknown* punkSink,
	_In_opt_z_ BSTR bstrLic)
{
	AtlAxWinInit();
	HRESULT hr;
	CComPtr<IUnknown> spUnkContainer;
	CComPtr<IUnknown> spUnkControl;

	hr = CAxHostWindow::_CreatorClass::CreateInstance(NULL, __uuidof(IUnknown), (void**)&spUnkContainer);
	if (SUCCEEDED(hr))
	{
		CComPtr<IAxWinHostWindowLic> pAxWindow;
		spUnkContainer->QueryInterface(__uuidof(IAxWinHostWindow), (void**)&pAxWindow);
		CComBSTR bstrName(lpszName);
		hr = pAxWindow->CreateControlLicEx(bstrName, hWnd, pStream, &spUnkControl, iidSink, punkSink, bstrLic);
	}
	if (ppUnkContainer != NULL)
	{
		if (SUCCEEDED(hr))
		{
			*ppUnkContainer = spUnkContainer.p;
			spUnkContainer.p = NULL;
		}
		else
			*ppUnkContainer = NULL;
	}
	if (ppUnkControl != NULL)
	{
		if (SUCCEEDED(hr))
		{
			*ppUnkControl = SUCCEEDED(hr) ? spUnkControl.p : NULL;
			spUnkControl.p = NULL;
		}
		else
			*ppUnkControl = NULL;
	}
	return hr;
}
ATLPREFAST_UNSUPPRESS()
	
ATLPREFAST_SUPPRESS(6387)
ATLINLINE ATLAPI AtlAxAttachControl(
	_Inout_ IUnknown* pControl,
	_In_ HWND hWnd,
	_Deref_opt_out_ IUnknown** ppUnkContainer)
{
	AtlAxWinInit();
	if (pControl == NULL)
		return E_INVALIDARG;
	CComPtr<IUnknown> spUnkContainer;

	HRESULT hr = CAxHostWindow::_CreatorClass::CreateInstance(NULL, __uuidof(IUnknown), (void**)&spUnkContainer);
	if (SUCCEEDED(hr))
	{
		CComPtr<IAxWinHostWindow> spAxWindow;
		hr = spUnkContainer->QueryInterface(&spAxWindow);
		if (SUCCEEDED(hr))
			hr = spAxWindow->AttachControl(pControl, hWnd);
	}
	if (ppUnkContainer != NULL)
	{
		*ppUnkContainer = SUCCEEDED(hr) ? spUnkContainer.Detach() : NULL;
	}
	return hr;
}
ATLPREFAST_UNSUPPRESS()
	
#ifdef _ATL_DLL_IMPL
// global variable in ATL.DLL to keep track if AtlAxWin window class has been registered in ATL.DLL
bool __declspec(selectany) bAtlAxWinInitialized;
#endif

//This either registers a global class (if AtlAxWinInit is in ATL.DLL)
// or it registers a local class
ATLINLINE ATLAPI_(BOOL) AtlAxWinInit()
{
	CComCritSecLock<CComCriticalSection> lock(_AtlWinModule.m_csWindowCreate, false);
	if (FAILED(lock.Lock()))
	{
		ATLTRACE(atlTraceHosting, 0, _T("ERROR : Unable to lock critical section in AtlAxWinInit\n"));
		ATLASSERT(0);
		return FALSE;
	}
	WM_ATLGETHOST = RegisterWindowMessage(_T("WM_ATLGETHOST"));
	WM_ATLGETCONTROL = RegisterWindowMessage(_T("WM_ATLGETCONTROL"));
	WNDCLASSEX wc;
// first check if the class is already registered
	wc.cbSize = sizeof(WNDCLASSEX);
	BOOL bRet = ::GetClassInfoEx(_AtlBaseModule.GetModuleInstance(), CAxWindow::GetWndClassName(), &wc);

// register class if not

	if(!bRet)
	{
		wc.cbSize = sizeof(WNDCLASSEX);
#ifdef _ATL_DLL_IMPL
		wc.style = CS_GLOBALCLASS | CS_DBLCLKS;
		bAtlAxWinInitialized = true;
#else
		wc.style = CS_DBLCLKS;
#endif
		wc.lpfnWndProc = AtlAxWindowProc;
		wc.cbClsExtra = 0;
		wc.cbWndExtra = 0;
		wc.hInstance = _AtlBaseModule.GetModuleInstance();
		wc.hIcon = NULL;
		wc.hCursor = ::LoadCursor(NULL, IDC_ARROW);
		wc.hbrBackground = (HBRUSH)(COLOR_WINDOW + 1);
		wc.lpszMenuName = NULL;
		wc.lpszClassName = CAxWindow::GetWndClassName();
		wc.hIconSm = NULL;

		ATOM atom= ::RegisterClassEx(&wc);
		if (atom)
		{
		   _AtlWinModule.m_rgWindowClassAtoms.Add(atom);
		   bRet=TRUE;
		}else
		{
		  bRet=FALSE;
		}
	}

	if (bRet)
	{
		// first check if the class is already registered
		memset(&wc, 0, sizeof(WNDCLASSEX));
		wc.cbSize = sizeof(WNDCLASSEX);
		bRet = ::GetClassInfoEx(_AtlBaseModule.GetModuleInstance(), CAxWindow2::GetWndClassName(), &wc);

		// register class if not

		if(!bRet)
		{
			wc.cbSize = sizeof(WNDCLASSEX);
#ifdef _ATL_DLL_IMPL
			wc.style = CS_GLOBALCLASS | CS_DBLCLKS;
#else
			wc.style = CS_DBLCLKS;
#endif
			wc.lpfnWndProc = AtlAxWindowProc2;
			wc.cbClsExtra = 0;
			wc.cbWndExtra = 0;
			wc.hInstance = _AtlBaseModule.GetModuleInstance();
			wc.hIcon = NULL;
			wc.hCursor = ::LoadCursor(NULL, IDC_ARROW);
			wc.hbrBackground = (HBRUSH)(COLOR_WINDOW + 1);
			wc.lpszMenuName = NULL;
			wc.lpszClassName = CAxWindow2::GetWndClassName();
			wc.hIconSm = NULL;
			ATOM atom= RegisterClassEx(&wc);

			if (atom)
			{
				_AtlWinModule.m_rgWindowClassAtoms.Add(atom);
				bRet=TRUE;
			}else
			{
				bRet=FALSE;
			}

		}
	}
	return bRet;
}

ATLPREFAST_SUPPRESS(6387)
ATLINLINE ATLAPI AtlAxGetControl(
	_In_ HWND h,
	_Deref_out_ IUnknown** pp)
{
	ATLASSERT(WM_ATLGETCONTROL != 0);
	if (pp == NULL)
		return E_POINTER;
	*pp = (IUnknown*)SendMessage(h, WM_ATLGETCONTROL, 0, 0);
	return (*pp) ? S_OK : E_FAIL;
}
ATLPREFAST_UNSUPPRESS()
	
ATLPREFAST_SUPPRESS(6387)
ATLINLINE ATLAPI AtlAxGetHost(
	_In_ HWND h,
	_Deref_out_ IUnknown** pp)
{
	ATLASSERT(WM_ATLGETHOST != 0);
	if (pp == NULL)
		return E_POINTER;
	*pp = (IUnknown*)SendMessage(h, WM_ATLGETHOST, 0, 0);
	return (*pp) ? S_OK : E_FAIL;
}
ATLPREFAST_UNSUPPRESS()

#endif // _ATL_DLL

}; //namespace ATL
#pragma pack(pop)

#ifndef _ATL_NO_PRAGMA_WARNINGS
#pragma warning (pop)
#endif //!_ATL_NO_PRAGMA_WARNINGS

#endif  // __ATLHOST_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\include\atlhandlerimpl.h ===
// This is a part of the Active Template Library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Active Template Library Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Active Template Library product.

#ifndef __ATL_HANDLER_IMPL__
#define __ATL_HANDLER_IMPL__

#pragma once

#if (NTDDI_VERSION < NTDDI_VISTA) // min Windows Vista required
#error Preview/Thumbnail/Search handlers are not supported on Windows versions prior to Vista.
#endif

#ifndef _ATL_NO_PRAGMA_WARNINGS
#pragma warning (push)
#endif //!_ATL_NO_PRAGMA_WARNINGS

#include <Filterr.h>
#include <atlhandler.h>
#include <atlcoll.h>
#include <shobjidl.h>
#include <propsys.h>
#include <thumbcache.h>

#pragma pack(push,_ATL_PACKING)
namespace ATL
{

class ATL_NO_VTABLE CThumbnailProviderImpl :
	public IInitializeWithStream,
	public IThumbnailProvider
{
public:
	CThumbnailProviderImpl() : m_pStream(NULL), m_pDocument(NULL)
	{
	}

	virtual ~CThumbnailProviderImpl()
	{
	}

	void FinalRelease()
	{
		ReleaseAll();
	}

	//IThumbnailProvider implementation
	STDMETHOD (GetThumbnail)(
		_In_ UINT cx,
		_Inout_ HBITMAP *phbmp,
		_Inout_ WTS_ALPHATYPE *pdwAlpha)
	{
#ifdef _AFXDLL
		AFX_MANAGE_STATE(AfxGetStaticModuleState());
#endif
		*phbmp = NULL;
		*pdwAlpha = WTSAT_UNKNOWN;

		m_pDocument = CreateDocument();
		if (m_pDocument == NULL)
		{
			return E_POINTER;
		}

		m_pDocument->AddRef();

		HRESULT hr = LoadDocumentFromStream(m_pStream, m_grfMode);
		if (FAILED(hr))
		{
			return hr;
		}

		hr = GetBitmap(cx, phbmp, pdwAlpha);

		ReleaseAll();
		return hr;
	}

	//IInitializeWithStream implementation
	STDMETHOD (Initialize)(
		_Inout_ IStream *pStream,
		_In_ DWORD grfMode)
	{
#ifdef _AFXDLL
		AFX_MANAGE_STATE(AfxGetStaticModuleState());
#endif
		// Initialize can be called more than once, so release existing valid m_pStream
		if (m_pStream != NULL)
		{
			m_pStream->Release();
		}

		m_pStream = pStream;
		m_pStream->AddRef();

		m_grfMode = grfMode | STGM_SHARE_EXCLUSIVE;
		return S_OK;
	}

protected:
	virtual IDocument* CreateDocument()
	{
		return NULL;
	}

	virtual HRESULT LoadDocumentFromStream(
		_Inout_ IStream* pStream,
		_In_ DWORD grfMode)
	{
		if (m_pDocument == NULL)
		{
			return E_POINTER;
		}
		return m_pDocument->LoadFromStream(pStream, grfMode);
	}

	virtual HRESULT GetBitmap(
		_In_ UINT /* cx */,
		_In_opt_ HBITMAP * /* phbmp */,
		_In_opt_ WTS_ALPHATYPE * /* pdwAlpha */)
	{
		return E_NOTIMPL;
	}

	void ReleaseAll()
	{
		if (m_pStream != NULL)
		{
			m_pStream->Release();
			m_pStream = NULL;
		}

		if (m_pDocument != NULL)
		{
			m_pDocument->Release();
			m_pDocument = NULL;
		}
	}
protected:
	IStream*   m_pStream;
	IDocument* m_pDocument;
	DWORD      m_grfMode;

};

template <class T>
class ATL_NO_VTABLE CPreviewHandlerImpl :
	public IObjectWithSiteImpl<T>,
	public IPreviewHandler,
	public IOleWindow,
	public IInitializeWithStream,
	public IPreviewHandlerVisuals
{
public:
	CPreviewHandlerImpl(void) :
		m_pPreviewCtrl(NULL), m_pStream(NULL),
		m_pFrame(NULL), m_hWndHost(NULL),
		m_pDocument(NULL), m_clrBackColor(RGB(255, 255, 255)),
		m_clrTextColor(0), m_pLogFont(NULL)
	{
		::SetRectEmpty(&m_rectHost);
	}
	virtual ~CPreviewHandlerImpl()
	{
	}

	void FinalRelease()
	{
		ReleaseStream();

		if (m_pPreviewCtrl != NULL)
		{
			m_pPreviewCtrl->Destroy();
			m_pPreviewCtrl = NULL;
		}

		if (m_pFrame != NULL)
		{
			m_pFrame->Release();
			m_pFrame = NULL;
		}

		if (m_pDocument != NULL)
		{
			m_pDocument->Release();
			m_pDocument = NULL;
		}

		m_hWndHost = NULL;
		SetRectEmpty(&m_rectHost);
	}

	//IPreviewHandler implementation
	STDMETHOD (SetWindow)(
		_In_ HWND hwnd,
		_In_ const RECT *prc)
	{
#ifdef _AFXDLL
		AFX_MANAGE_STATE(AfxGetStaticModuleState());
#endif
		m_hWndHost = hwnd;
		CopyRect(&m_rectHost, prc);

		if (m_pPreviewCtrl != NULL)
		{
			m_pPreviewCtrl->SetHost(hwnd);
			m_pPreviewCtrl->SetRect(prc, FALSE);
		}

		return S_OK;
	}

	STDMETHOD (SetRect)(_In_ const RECT *prc)
	{
#ifdef _AFXDLL
		AFX_MANAGE_STATE(AfxGetStaticModuleState());
#endif
		CopyRect(&m_rectHost, prc);

		if (m_pPreviewCtrl != NULL)
		{
			m_pPreviewCtrl->SetRect(prc, TRUE);
		}

		return S_OK;
	}

	IFACEMETHODIMP DoPreview()
	{
		if (m_pPreviewCtrl == NULL)
		{
#ifdef _AFXDLL
			AFX_MANAGE_STATE(AfxGetStaticModuleState());
#endif

#ifdef AFX_PREVIEW_STANDALONE
			m_pDocument = CreateDocument();

			if (m_pDocument == NULL)
			{
				return E_FAIL;
			}

			m_pDocument->AddRef();
			m_pPreviewCtrl = CreatePreviewControl();

			if (m_pPreviewCtrl == NULL || !m_pPreviewCtrl->Create(m_hWndHost, &m_rectHost))
			{
				return E_FAIL;
			}

			m_pPreviewCtrl->SetDocument(m_pDocument);
#else
			if (FAILED(InitializeDocumentPreview(m_hWndHost, &m_rectHost)))
			{
				return E_FAIL;
			}
#endif

			if (m_pPreviewCtrl != NULL)
			{
				m_pPreviewCtrl->SetPreviewVisuals(m_clrBackColor, m_clrTextColor, m_pLogFont);
			}

			// support for loading from archive
			LoadDocumentFromStream(m_pStream);

			// we can release stream now, otherwise the file remains locked for a long time
			ReleaseStream();
		}

		if (m_pPreviewCtrl != NULL)
		{
			m_pPreviewCtrl->Redraw();
		}

		return S_OK;
	}

	IFACEMETHODIMP Unload()
	{
#ifdef _AFXDLL
		AFX_MANAGE_STATE(AfxGetStaticModuleState());
#endif
		ReleaseStream();

		if (m_pPreviewCtrl != NULL)
		{
			m_pPreviewCtrl->Destroy();
			m_pPreviewCtrl = NULL;
		}

		if (m_pDocument != NULL)
		{
			m_pDocument->Release();
			m_pDocument = NULL;
		}

		if (m_pFrame != NULL)
		{
			m_pFrame->Release();
			m_pFrame = NULL;
		}

		return S_OK;
	}

	IFACEMETHODIMP SetFocus()
	{
#ifdef _AFXDLL
		AFX_MANAGE_STATE(AfxGetStaticModuleState());
#endif
		HRESULT hr = S_FALSE;

		if (m_pPreviewCtrl != NULL)
		{
			m_pPreviewCtrl->Focus();
			hr = S_OK;
		}

		return hr;
	}

	STDMETHOD (QueryFocus)(_Out_ HWND *phwnd)
	{
#ifdef _AFXDLL
		AFX_MANAGE_STATE(AfxGetStaticModuleState());
#endif
		HRESULT hr = S_OK;

		*phwnd = ::GetFocus();
		if (*phwnd == NULL)
		{
			hr = HRESULT_FROM_WIN32(GetLastError());
		}

		return hr;
	}

	STDMETHOD (TranslateAccelerator)(_In_ MSG *pmsg)
	{
#ifdef _AFXDLL
		AFX_MANAGE_STATE(AfxGetStaticModuleState());
#endif
		HRESULT hr = S_FALSE;

		if (m_pFrame != NULL)
		{
			// If your previewer has multiple tab stops, you will need to do appropriate first/last child checking.
			// This sample previewer has no tabstops, so we want to just forward this message out
			hr = m_pFrame->TranslateAccelerator(pmsg);
		}

		return hr;
	}

	// IPreviewHandlerVisuals implementation
	STDMETHOD (SetBackgroundColor)(_In_ COLORREF color)
	{
#ifdef _AFXDLL
		AFX_MANAGE_STATE(AfxGetStaticModuleState());
#endif
		m_clrBackColor = color;
		return S_OK;
	}

	STDMETHOD (SetFont)(_In_ const LOGFONTW *plf)
	{
#ifdef _AFXDLL
		AFX_MANAGE_STATE(AfxGetStaticModuleState());
#endif
		m_pLogFont = (LOGFONTW*) plf;
		return S_OK;
	}

	STDMETHOD (SetTextColor)(_In_ COLORREF color)
	{
#ifdef _AFXDLL
		AFX_MANAGE_STATE(AfxGetStaticModuleState());
#endif
		m_clrTextColor = color;
		return S_OK;
	}

	// IObjectWithSite override
	STDMETHOD (SetSite)(_Inout_opt_ IUnknown *punkSite)
	{
#ifdef _AFXDLL
		AFX_MANAGE_STATE(AfxGetStaticModuleState());
#endif
		__super::SetSite(punkSite);

		// Clean up old frame
		if (m_pFrame != NULL)
		{
			m_pFrame->Release();
			m_pFrame = NULL;
		}

		// Get the new frame
		if (m_spUnkSite)
		{
			m_spUnkSite->QueryInterface(&m_pFrame);
		}

		return S_OK;
	}

	// IOleWindow
	STDMETHOD (GetWindow)(_Out_ HWND *phwnd)
	{
#ifdef _AFXDLL
		AFX_MANAGE_STATE(AfxGetStaticModuleState());
#endif
		*phwnd = m_hWndHost;
		return S_OK;
	}

	STDMETHOD (ContextSensitiveHelp)(_In_ BOOL)
	{
#ifdef _AFXDLL
		AFX_MANAGE_STATE(AfxGetStaticModuleState());
#endif
		return E_NOTIMPL;
	}

	//IInitializeWithStream implementation
	STDMETHOD (Initialize)(
		_Inout_ IStream *pStream,
		_In_ DWORD grfMode)
	{
#ifdef _AFXDLL
		AFX_MANAGE_STATE(AfxGetStaticModuleState());
#endif
		// Initialize can be called more than once, so release existing valid m_pStream
		ReleaseStream();

		m_pStream = pStream;
		m_pStream->AddRef();

		m_grfMode = grfMode;
		return S_OK;
	}

protected:
	virtual HRESULT InitializeDocumentPreview(
		_In_ HWND /* hWnd */,
		_In_opt_ RECT* /* prc */)
	{
		return E_NOTIMPL;
	}

	virtual IPreviewCtrl* CreatePreviewControl()
	{
		return NULL;
	}

	virtual IDocument* CreateDocument()
	{
		return NULL;
	}

	virtual HRESULT LoadDocumentFromStream(_Inout_ IStream* pStream)
	{
		if (m_pDocument == NULL)
		{
			return E_POINTER;
		}

		return m_pDocument->LoadFromStream(pStream, m_grfMode);
	}

	void ReleaseStream()
	{
		if (m_pStream != NULL)
		{
			m_pStream->Release();
			m_pStream = NULL;
		}
	}

protected:
	IPreviewCtrl*          m_pPreviewCtrl;
	IStream*               m_pStream;
	DWORD                  m_grfMode;
	IPreviewHandlerFrame*  m_pFrame;
	HWND                   m_hWndHost;
	RECT                   m_rectHost;

	COLORREF               m_clrBackColor;
	COLORREF               m_clrTextColor;
	LOGFONTW*              m_pLogFont;

	IDocument*             m_pDocument;
};

class ATL_NO_VTABLE CSearchFilterImpl :
	public IPersistStream,
	public IPersistFile,
	public IFilter
{
public:

	CSearchFilterImpl(void) :
		m_pStream(NULL), m_pDocument(NULL),
		m_dwChunkId(0), m_iText(0), m_pCurrentChunk(NULL)
	{
		m_hEventLog = NULL;
		m_bEnableEventLog = FALSE;
	}

	virtual ~CSearchFilterImpl()
	{
	}

	void FinalRelease()
	{
		ReleaseAll();

		if (m_hEventLog != NULL)
		{
			CloseEventLog(m_hEventLog);
			m_hEventLog = NULL;
		}
	}

public:
	// IFilter implementation
	STDMETHODIMP Init(
		_In_ ULONG /* grfFlags */,
		_In_ ULONG /* cAttributes */,
		_In_opt_ const FULLPROPSPEC * /* aAttributes */,
		_In_opt_ ULONG * /* pFlags */)
	{

#ifdef _AFXDLL
		AFX_MANAGE_STATE(AfxGetStaticModuleState());
#endif
		HRESULT hr = S_OK;

		if (m_hEventLog == NULL && m_bEnableEventLog)
		{
			m_hEventLog = OpenEventLog(NULL, L"Search Handler");
		}

		if (m_bEnableEventLog)
		{
			PCWSTR pszMsg = L"IFilter::Init entered.";
			ReportEvent(m_hEventLog, EVENTLOG_SUCCESS, 0, 1, NULL, 1, 0, &pszMsg, NULL);
		}

		m_pDocument = CreateDocument();
		if (m_pDocument == NULL)
		{
			return E_FAIL;
		}

		m_pDocument->AddRef();
		hr = LoadDocumentFromStream(m_pStream, STGM_READ | STGM_SHARE_EXCLUSIVE);

		if (FAILED(hr))
		{
			if (m_bEnableEventLog)
			{
				PCWSTR pszMsg = L"IFilter::Init (LoadDocumentFromStream) failed.";
				ReportEvent(m_hEventLog, EVENTLOG_ERROR_TYPE, 0, 0, NULL, 1, sizeof (DWORD), &pszMsg, &hr);
			}
			return hr;
		}

		m_pDocument->InitializeSearchContent();
		m_pDocument->BeginReadChunks();

		return S_OK;
	}

	STDMETHODIMP GetChunk(_Inout_ STAT_CHUNK *pStat)
	{
#ifdef _AFXDLL
		AFX_MANAGE_STATE(AfxGetStaticModuleState());
#endif
		HRESULT hr = S_OK;

		try
		{
			// Get the chunk from the derived class.  A return of S_FALSE indicates the
			// chunk should be skipped and we should try to get the next chunk.

			int cIterations = 0;
			hr = S_FALSE;

			while (S_FALSE == hr)
			{
				pStat->idChunk = m_dwChunkId;

				hr = S_OK;
				if (!m_pDocument->ReadNextChunkValue(&m_pCurrentChunk))
				{
					hr = FILTER_E_END_OF_CHUNKS;
				}
				++cIterations;
			}

			if (hr == S_OK)
			{
				if (m_pCurrentChunk != NULL && m_pCurrentChunk->IsValid())
				{
					// copy out the STAT_CHUNK
					m_pCurrentChunk->CopyChunk(pStat);

					// and set the id to be the sequential chunk
					pStat->idChunk = ++m_dwChunkId;
				}
				else
				{
					hr = E_INVALIDARG;
				}
			}
		}
		catch (CAtlException e)
		{
			ATLTRACE2(atlTraceGeneral, 4, L"CMFCWSFilterImpl::GetChunk ATL exception! hr = 0x%x", e.m_hr);
			hr = e.m_hr;
		}

		if (m_bEnableEventLog)
		{
			PCWSTR pszMsg = L"IFilter::GetChunk.";
			ReportEvent(m_hEventLog, EVENTLOG_SUCCESS, 0, 2, NULL, 1, sizeof (DWORD), &pszMsg, &hr);
		}

		return hr;
	}

	STDMETHODIMP GetText(
		_Inout_ ULONG *pcwcBuffer,
		_Out_z_cap_(*pcwcBuffer) WCHAR *awcBuffer)
	{
#ifdef _AFXDLL
		AFX_MANAGE_STATE(AfxGetStaticModuleState());
#endif
		HRESULT hr = S_OK;

		if ((pcwcBuffer == NULL) || (*pcwcBuffer == 0))
		{
			return E_INVALIDARG;
		}

		if (m_pCurrentChunk == NULL || !m_pCurrentChunk->IsValid())
		{
			return FILTER_E_NO_MORE_TEXT;
		}

		if (m_pCurrentChunk->GetChunkType() != CHUNK_TEXT)
		{
			return FILTER_E_NO_TEXT;
		}

		try
		{
			int cchTotal = m_pCurrentChunk->GetString().GetLength();
			int cchLeft = cchTotal - m_iText;
			int cchToCopy = min((int)*pcwcBuffer - 1, cchLeft);

			if (cchToCopy > 0)
			{

				PCWSTR psz = ((PCWSTR)m_pCurrentChunk->GetString()) + m_iText;
				// copy the chars
				wcsncpy_s(awcBuffer, *pcwcBuffer, psz, cchToCopy);
				// null terminate it
				awcBuffer[cchToCopy] = '\0';

				// set how much data is copied
				*pcwcBuffer = cchToCopy;

				// remember we copied it
				m_iText += cchToCopy;
				cchLeft -= cchToCopy;

				if (cchLeft == 0)
				{
					hr = FILTER_S_LAST_TEXT;
				}
			}
			else
			{
				hr = FILTER_E_NO_MORE_TEXT;
			}
		}
		catch (CAtlException e)
		{
			ATLTRACE2(atlTraceGeneral, 4, L"CMFCWSFilterImpl::GetText ATL exception! hr = 0x%x", e.m_hr);
			hr = e.m_hr;
		}

		if (m_bEnableEventLog)
		{
			PCWSTR pszMsg = L"IFilter::GetText.";
			ReportEvent(m_hEventLog, EVENTLOG_SUCCESS, 0, 3, NULL, 1, sizeof(DWORD), &pszMsg, &hr);
		}

		return hr;
	}

	STDMETHODIMP GetValue(_Deref_out_ PROPVARIANT **ppPropValue)
	{
#ifdef _AFXDLL
		AFX_MANAGE_STATE(AfxGetStaticModuleState());
#endif
		HRESULT hr = S_OK;

		// if this is not a value chunk they shouldn't be calling this
		if (m_pCurrentChunk == NULL || m_pCurrentChunk->GetChunkType() != CHUNK_VALUE)
		{
			return FILTER_E_NO_MORE_VALUES;
		}

		try
		{
			if (m_pCurrentChunk->IsValid())
			{
				// return the value of this chunk as a PROPVARIANT ( they own freeing it properly )
				hr = m_pCurrentChunk->GetValue(ppPropValue);
				m_pCurrentChunk->Clear();
			}
			else
			{
				// we have already return the value for this chunk, go away
				hr = FILTER_E_NO_MORE_VALUES;
			}
		}
		catch (CAtlException e)
		{
			ATLTRACE2(atlTraceGeneral, 4, L"CMFCWSFilterImpl::GetValue ATL exception! hr = 0x%x", e.m_hr);
			hr = e.m_hr;
		}

		if (m_bEnableEventLog)
		{
			PCWSTR pszMsg = L"IFilter::GetValue.";
			ReportEvent(m_hEventLog, EVENTLOG_SUCCESS, 0, 4, NULL, 1, sizeof(DWORD), &pszMsg, &hr);
		}

		return hr;
	}

	STDMETHODIMP BindRegion(
		_In_ FILTERREGION /* origPos */,
		_In_ REFIID /* riid */,
		_In_opt_ void ** /* ppunk */)
	{
#ifdef _AFXDLL
		AFX_MANAGE_STATE(AfxGetStaticModuleState());
#endif
		ATLTRACE2(atlTraceGeneral, 4, L"BindRegion: not implemented");
		return E_NOTIMPL;
	}

	// IPersistStream implementation
	// IPersistStream::Load() is used by WS 3.x and above for the index
	// search case when this filter is loaded into the filter host process
	STDMETHODIMP Load(_Inout_ IStream *pStream)
	{
#ifdef _AFXDLL
		AFX_MANAGE_STATE(AfxGetStaticModuleState());
#endif

		if (m_hEventLog == NULL)
		{
			m_hEventLog = OpenEventLog(NULL, L"Search Handler");
		}

		// Initialize can be called more than once, so release existing valid m_pStream
		if (m_pStream != NULL)
		{
			m_pStream->Release();
		}

		m_pStream = pStream;
		m_pStream->AddRef();

		if (m_bEnableEventLog)
		{
			PCWSTR pszMsg = L"IPersistStream::Load entered.";
			ReportEvent(m_hEventLog, EVENTLOG_SUCCESS, 0, 0, NULL, 1, 0, &pszMsg, NULL);
		}

		return S_OK;
	};

	STDMETHODIMP Save(
		_Inout_ IStream * /* pStm */,
		_In_ BOOL /* fClearDirty */)
	{
#ifdef _AFXDLL
		AFX_MANAGE_STATE(AfxGetStaticModuleState());
#endif
		return E_NOTIMPL; 
	};

	STDMETHODIMP GetSizeMax(_Out_ ULARGE_INTEGER * /* pcbSize */)
	{
#ifdef _AFXDLL
		AFX_MANAGE_STATE(AfxGetStaticModuleState());
#endif
		return E_NOTIMPL;
	};

	STDMETHODIMP IsDirty()
	{
#ifdef _AFXDLL
		AFX_MANAGE_STATE(AfxGetStaticModuleState());
#endif
		return S_FALSE;
	}

	STDMETHODIMP GetClassID(_In_opt_ CLSID * /* pClassID */)
	{
#ifdef _AFXDLL
		AFX_MANAGE_STATE(AfxGetStaticModuleState());
#endif
		ATLTRACE2(atlTraceGeneral, 4, L"GetClassID: must be implemented in a derived class.");
		return E_NOTIMPL;
	}

	// IPersistFile implementation
	STDMETHODIMP Load(
		_In_z_ LPCWSTR pszFileName,
		_In_ DWORD dwMode)
	{
#ifdef _AFXDLL
		AFX_MANAGE_STATE(AfxGetStaticModuleState());
#endif
		HRESULT hr = SHCreateStreamOnFileEx(pszFileName, dwMode, 0, FALSE, NULL, &m_pStream);
		return hr;
	};

	// these methods are never called by WS
	STDMETHODIMP Save(
		_In_opt_z_ LPCWSTR /* pszFileName */,
		_In_ BOOL /* fRemember */)
	{
#ifdef _AFXDLL
		AFX_MANAGE_STATE(AfxGetStaticModuleState());
#endif
		return E_NOTIMPL;
	};

	STDMETHODIMP SaveCompleted(
		_In_opt_z_ LPCWSTR /* pszFileName */)
	{
#ifdef _AFXDLL
		AFX_MANAGE_STATE(AfxGetStaticModuleState());
#endif
		return E_NOTIMPL;
	};

	STDMETHODIMP GetCurFile(
		_In_opt_ LPWSTR* /* pszFileName */)
	{
#ifdef _AFXDLL
		AFX_MANAGE_STATE(AfxGetStaticModuleState());
#endif
		return E_NOTIMPL;
	};

protected:
	virtual IDocument* CreateDocument()
	{
		return NULL;
	}

	virtual HRESULT LoadDocumentFromStream(
		_Inout_ IStream* pStream,
		_In_ DWORD grfMode)
	{
		if (m_pDocument == NULL)
		{
			return E_POINTER;
		}

		return m_pDocument->LoadFromStream(pStream, grfMode);
	}

	void ReleaseAll()
	{
#ifdef _AFXDLL
		AFX_MANAGE_STATE(AfxGetStaticModuleState());
#endif
		if (m_pStream != NULL)
		{
			m_pStream->Release();
			m_pStream = NULL;
		}

		if (m_pDocument != NULL)
		{
			m_pDocument->Release();
			m_pDocument = NULL;
		}
	}

protected:
	IStream*                    m_pStream;
	IDocument*                  m_pDocument;

	IFilterChunkValue*          m_pCurrentChunk;    // the current chunk value
	DWORD                       m_dwChunkId;        // Current chunk id
	DWORD                       m_iText;            // index into ChunkValue

	HANDLE                      m_hEventLog;
	BOOL                        m_bEnableEventLog;
};

class CFilterChunkValueImpl : 
	public IFilterChunkValue
{
public:
	CFilterChunkValueImpl()
	{
		Clear();
	}

	~CFilterChunkValueImpl()
	{
		Clear();
	}

	virtual void Clear()
	{
		m_fIsValid = false;
		ZeroMemory(&m_chunk, sizeof(m_chunk));
		PropVariantInit(&m_propVariant);
		m_strValue.Empty();
	}

	virtual BOOL IsValid() const
	{
		return m_fIsValid;
	}

ATLPREFAST_SUPPRESS(6387)
	virtual HRESULT GetValue(_Deref_out_ PROPVARIANT **ppPropVariant)
	{
		HRESULT hr = S_OK;

		*ppPropVariant = NULL;
		CComHeapPtr<PROPVARIANT> spPropVariant;

		// allocate a propvariant on the COM heap
		if (spPropVariant.Allocate())
		{
			// fill it with COMHeap copied data from our local non-com heap propvariant
			hr = PropVariantCopy(spPropVariant, &m_propVariant);
		}
		else
		{
			hr = E_OUTOFMEMORY;
		}

		if (SUCCEEDED(hr))
		{
			// detach and return this as the value
			*ppPropVariant = spPropVariant.Detach();
		}
				
		return hr;
	}
ATLPREFAST_UNSUPPRESS()
	
	virtual PROPVARIANT GetValueNoAlloc()
	{
		return m_propVariant;
	}

	virtual CString& GetString()
	{
		return m_strValue;
	}

	virtual HRESULT CopyChunk(_Out_ STAT_CHUNK *pStatChunk)
	{
		*pStatChunk = m_chunk;
		return S_OK;
	}

	virtual CHUNKSTATE GetChunkType() const
	{
		return m_chunk.flags;
	}

	virtual REFGUID GetChunkGUID() const
	{
		return m_chunk.attribute.guidPropSet;
	}

	virtual DWORD GetChunkPID() const
	{
		return m_chunk.attribute.psProperty.propid;
	}

	// set the property by key to a unicode string
	virtual HRESULT SetTextValue(
		_In_ REFPROPERTYKEY pkey,
		_In_z_ LPCTSTR pszValue,
		_In_ CHUNKSTATE chunkType = CHUNK_VALUE,
		_In_ LCID locale = 0,
		_In_ DWORD cwcLenSource = 0,
		_In_ DWORD cwcStartSource = 0,
		_In_ CHUNK_BREAKTYPE chunkBreakType = CHUNK_NO_BREAK)
	{
		HRESULT hr = SetChunk(pkey, chunkType, locale, cwcLenSource, cwcStartSource, chunkBreakType);
		if (SUCCEEDED(hr))
		{
			m_strValue = pszValue;
			m_propVariant.vt = VT_LPWSTR;
			m_propVariant.pwszVal = (LPWSTR)(LPCWSTR)m_strValue;
			m_fIsValid = true;
		}

		return hr;
	}

	// set the property by key to a bool
	virtual HRESULT SetBoolValue(
		_In_ REFPROPERTYKEY pkey,
		_In_ BOOL bVal,
		_In_ CHUNKSTATE chunkType = CHUNK_VALUE,
		_In_ LCID locale = 0,
		_In_ DWORD cwcLenSource = 0,
		_In_ DWORD cwcStartSource = 0,
		_In_ CHUNK_BREAKTYPE chunkBreakType = CHUNK_NO_BREAK)
	{
		return SetBoolValue(pkey, bVal ? VARIANT_TRUE : VARIANT_FALSE, chunkType, locale, cwcLenSource, cwcStartSource, chunkBreakType);
	}

	// set the property by key to a variant bool
	virtual HRESULT SetBoolValue(
		_In_ REFPROPERTYKEY pkey,
		_In_ VARIANT_BOOL bVal,
		_In_ CHUNKSTATE chunkType = CHUNK_VALUE,
		_In_ LCID locale = 0,
		_In_ DWORD cwcLenSource = 0,
		_In_ DWORD cwcStartSource = 0,
		_In_ CHUNK_BREAKTYPE chunkBreakType = CHUNK_NO_BREAK)
	{
		HRESULT hr = SetChunk(pkey, chunkType, locale, cwcLenSource, cwcStartSource, chunkBreakType);
		if (SUCCEEDED(hr))
		{
			m_propVariant.vt = VT_BOOL;
			m_propVariant.boolVal = bVal;
			m_fIsValid = true;
		}

		return hr;
	}

	// set the property by key to an int
	virtual HRESULT SetIntValue(
		_In_ REFPROPERTYKEY pkey,
		_In_ int nVal,
		_In_ CHUNKSTATE chunkType = CHUNK_VALUE,
		_In_ LCID locale = 0,
		_In_ DWORD cwcLenSource = 0,
		_In_ DWORD cwcStartSource = 0,
		_In_ CHUNK_BREAKTYPE chunkBreakType = CHUNK_NO_BREAK)
	{
		HRESULT hr = SetChunk(pkey, chunkType, locale, cwcLenSource, cwcStartSource, chunkBreakType);
		if (SUCCEEDED(hr))
		{
			m_propVariant.vt = VT_I4;
			m_propVariant.lVal = nVal;
			m_fIsValid = true;
		}

		return hr;
	}

	// set the property by key to a long
	virtual HRESULT SetLongValue(
		_In_ REFPROPERTYKEY pkey,
		_In_ long lVal,
		_In_ CHUNKSTATE chunkType = CHUNK_VALUE,
		_In_ LCID locale = 0,
		_In_ DWORD cwcLenSource = 0,
		_In_ DWORD cwcStartSource = 0,
		_In_ CHUNK_BREAKTYPE chunkBreakType = CHUNK_NO_BREAK)
	{
		HRESULT hr = SetChunk(pkey, chunkType, locale, cwcLenSource, cwcStartSource, chunkBreakType);
		if (SUCCEEDED(hr))
		{
			m_propVariant.vt = VT_I4;
			m_propVariant.lVal = lVal;
			m_fIsValid = true;
		}

		return hr;
	}

	// set the property by key to a dword
	virtual HRESULT SetDwordValue(
		_In_ REFPROPERTYKEY pkey,
		_In_ DWORD dwVal,
		_In_ CHUNKSTATE chunkType = CHUNK_VALUE,
		_In_ LCID locale = 0,
		_In_ DWORD cwcLenSource = 0,
		_In_ DWORD cwcStartSource = 0,
		_In_ CHUNK_BREAKTYPE chunkBreakType = CHUNK_NO_BREAK)
	{
		HRESULT hr = SetChunk(pkey, chunkType, locale, cwcLenSource, cwcStartSource, chunkBreakType);
		if (SUCCEEDED(hr))
		{
			m_propVariant.vt = VT_UI4;
			m_propVariant.ulVal = dwVal;
			m_fIsValid = true;
		}

		return hr;
	}

	// set property by key to an int64
	virtual HRESULT SetInt64Value(
		_In_ REFPROPERTYKEY pkey,
		_In_ __int64 nVal,
		_In_ CHUNKSTATE chunkType = CHUNK_VALUE,
		_In_ LCID locale = 0,
		_In_ DWORD cwcLenSource = 0,
		_In_ DWORD cwcStartSource = 0,
		_In_ CHUNK_BREAKTYPE chunkBreakType = CHUNK_NO_BREAK)
	{
		HRESULT hr = SetChunk(pkey, chunkType, locale, cwcLenSource, cwcStartSource, chunkBreakType);
		if (SUCCEEDED(hr))
		{
			m_propVariant.vt = VT_I8;
			m_propVariant.hVal.QuadPart = nVal;
			m_fIsValid = true;
		}

		return hr;
	}

	// set property by key to a SystemTime
	virtual HRESULT SetSystemTimeValue(
		_In_ REFPROPERTYKEY pkey,
		_In_ const SYSTEMTIME &systemTime,
		_In_ CHUNKSTATE chunkType = CHUNK_VALUE,
		_In_ LCID locale = 0,
		_In_ DWORD cwcLenSource = 0,
		_In_ DWORD cwcStartSource = 0,
		_In_ CHUNK_BREAKTYPE chunkBreakType = CHUNK_NO_BREAK)
	{
		HRESULT hr = SetChunk(pkey, chunkType, locale, cwcLenSource, cwcStartSource, chunkBreakType);
		if (SUCCEEDED(hr))
		{
			m_propVariant.vt = VT_FILETIME;
			SystemTimeToFileTime(&systemTime, &m_propVariant.filetime);
			m_fIsValid = true;
		}

		return hr;
	}

	// set Property by key to a filetime
	virtual HRESULT SetFileTimeValue(
		_In_ REFPROPERTYKEY pkey,
		_In_ FILETIME dtVal,
		_In_ CHUNKSTATE chunkType = CHUNK_VALUE,
		_In_ LCID locale = 0,
		_In_ DWORD cwcLenSource = 0,
		_In_ DWORD cwcStartSource = 0,
		_In_ CHUNK_BREAKTYPE chunkBreakType = CHUNK_NO_BREAK)
	{
		HRESULT hr = SetChunk(pkey, chunkType, locale, cwcLenSource, cwcStartSource, chunkBreakType);
		if (SUCCEEDED(hr))
		{
			m_propVariant.vt = VT_FILETIME;
			m_propVariant.filetime = dtVal;
			m_fIsValid = true;
		}

		return hr;
	}

	virtual void CopyFrom(_Inout_ IFilterChunkValue* pValue)
	{
		Clear();

		pValue->CopyChunk (&m_chunk);

		// NOTE this object does not contain a real property variant that was allocated with CoTaskMemAlloc
		m_propVariant = pValue->GetValueNoAlloc ();
		m_strValue = pValue->GetString ();

		// fix up the string ownership to member
		if (m_propVariant.vt == VT_LPWSTR)
		{
			m_propVariant.pwszVal = (LPWSTR)(LPCWSTR)m_strValue;
		}
		else if (m_propVariant.vt & VT_VECTOR)
		{
		}

		m_fIsValid = pValue->IsValid();
		return;
	}

protected:
	// set the locale for this chunk
	HRESULT SetChunk(
		_In_ REFPROPERTYKEY pkey,
		_In_ CHUNKSTATE chunkType = CHUNK_VALUE,
		_In_ LCID locale = 0,
		_In_ DWORD cwcLenSource = 0,
		_In_ DWORD cwcStartSource = 0,
		_In_ CHUNK_BREAKTYPE chunkBreakType = CHUNK_NO_BREAK)
	{
		Clear();

		// initialize the chunk
		m_chunk.attribute.psProperty.ulKind = PRSPEC_PROPID;
		m_chunk.attribute.psProperty.propid = pkey.pid;
		m_chunk.attribute.guidPropSet = pkey.fmtid;
		m_chunk.flags = chunkType;
		m_chunk.locale = locale == 0 ? GetUserDefaultLCID() : locale;
		m_chunk.cwcLenSource = cwcLenSource;
		m_chunk.cwcStartSource = cwcStartSource;
		m_chunk.breakType = chunkBreakType;

		return S_OK;
	}

	// member variables
private:
	BOOL        m_fIsValid;
	STAT_CHUNK  m_chunk;
	PROPVARIANT m_propVariant;
	CString     m_strValue;
};

class CAtlDocumentImpl : 
	public IDocument
{
public:
	virtual void BeginReadChunks()
	{
		m_posReadChunk = m_lstChunks.GetHeadPosition();
	}

	virtual void ClearChunkList()
	{
		m_posReadChunk = NULL;

		POSITION pos = m_lstChunks.GetHeadPosition();
		while (pos != NULL)
		{
			IFilterChunkValue* v = (IFilterChunkValue*) m_lstChunks.GetNext(pos);
			if (v != NULL)
			{
				delete v;
			}
		}

		m_lstChunks.RemoveAll();
	}

	virtual BOOL SetChunkValue(_Inout_ IFilterChunkValue* pValue)
	{
		if (pValue == NULL || !pValue->IsValid())
		{
			return false;
		}

		POSITION pos = FindChunk(pValue->GetChunkGUID(), pValue->GetChunkPID());

		if (pos == NULL)
		{
			m_lstChunks.AddTail(pValue);
		}

		return TRUE;
	}

	virtual BOOL ReadNextChunkValue(_Deref_out_ IFilterChunkValue** ppValue)
	{
		if (m_posReadChunk == NULL || ppValue == NULL)
		{
			return FALSE;
		}

		*ppValue = (IFilterChunkValue*) m_lstChunks.GetNext(m_posReadChunk);
		return TRUE;
	}

	virtual void RemoveChunk(
		_In_ REFCLSID guid,
		_In_ DWORD pid)
	{
		POSITION pos = FindChunk(guid, pid);
		if (pos != NULL)
		{
			delete m_lstChunks.GetAt(pos);
			m_lstChunks.RemoveAt(pos);
		}
	}

	virtual POSITION FindChunk(
		_In_ REFCLSID guid,
		_In_ DWORD pid)
	{
		POSITION value = NULL;
		POSITION pos = m_lstChunks.GetHeadPosition();
		POSITION posPrev = NULL;
		while (pos != NULL)
		{
			posPrev = pos;
			IFilterChunkValue* v = (IFilterChunkValue*) m_lstChunks.GetNext(pos);
			if (IsEqualIID(v->GetChunkGUID(), guid) && v->GetChunkPID() == pid)
			{
				value = posPrev;
				break;
			}
		}

		return value;
	}

	BOOL GetThumbnail(
		_In_ UINT cx,
		_Out_ HBITMAP* phbmp,
		_In_opt_ WTS_ALPHATYPE* /* pdwAlpha */)
	{
		HDC hdc = ::GetDC(NULL);
		RECT rcBounds;

		SetRect(&rcBounds, 0, 0, cx, cx);

		HDC hDrawDC = CreateCompatibleDC(hdc);
		if (hDrawDC == NULL)
		{
			ReleaseDC(NULL, hdc);
			return FALSE;
		}

		HBITMAP hBmp = CreateCompatibleBitmap(hDrawDC, cx, cx);
		if (hBmp == NULL)
		{
			ReleaseDC(NULL, hdc);
			DeleteDC(hDrawDC);
			return FALSE;
		}

		HBITMAP hOldBitmap = (HBITMAP) SelectObject(hDrawDC, hBmp);

		// Here you need to draw the document's data
		OnDrawThumbnail(hDrawDC, &rcBounds);

		SelectObject(hDrawDC, hOldBitmap);

		DeleteDC(hDrawDC);
		ReleaseDC(NULL, hdc);

		*phbmp = hBmp;
		return TRUE;
	}

	virtual void OnDrawThumbnail(
		_In_ HDC /* hDrawDC */,
		_In_ LPRECT /* lprcBounds */)
	{
	}

	virtual LPVOID GetContainer() const
	{
		return (LPVOID) this;
	}

protected:
	CAtlList<IFilterChunkValue*> m_lstChunks;
	POSITION                     m_posReadChunk;
};

} //namespace ATL

#pragma pack(pop)

#ifndef _ATL_NO_PRAGMA_WARNINGS
#pragma warning (pop)
#endif //!_ATL_NO_PRAGMA_WARNINGS

#endif // __ATL_HANDLER_IMPL__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\include\atlfile.h ===
// This is a part of the Active Template Library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Active Template Library Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Active Template Library product.

#ifndef __ATLFILE_H__
#define __ATLFILE_H__

#pragma once

#include <atlbase.h>

#pragma pack(push,_ATL_PACKING)
namespace ATL
{

class CAtlFile :
	public CHandle
{
public:
	/// <summary>
	/// CAtlFile constructor</summary>
	CAtlFile() throw():
		m_pTM( NULL )
	{
	}

	/// <param name="pTM">Pointer to CAtlTransactionManager object</param>
	explicit CAtlFile(_In_opt_ CAtlTransactionManager* pTM) throw() :
		m_pTM( pTM )
	{
	}

	CAtlFile(_In_ CAtlFile& file) throw() :
		CHandle( file ),  // Transfers ownership
		m_pTM( file.m_pTM )
	{
	}

	explicit CAtlFile(_In_ HANDLE hFile) throw() :
		CHandle( hFile ),  // Takes ownership
		m_pTM( NULL )
	{
	}

	HRESULT Create(
		_In_z_ LPCTSTR szFilename,
		_In_ DWORD dwDesiredAccess,
		_In_ DWORD dwShareMode,
		_In_ DWORD dwCreationDisposition,
		_In_ DWORD dwFlagsAndAttributes = FILE_ATTRIBUTE_NORMAL,
		_In_opt_ LPSECURITY_ATTRIBUTES lpsa = NULL,
		_In_opt_ HANDLE hTemplateFile = NULL) throw()
	{
		ATLASSUME(m_h == NULL);

		HANDLE hFile = m_pTM != NULL ?
			m_pTM->CreateFile(
				szFilename,
				dwDesiredAccess,
				dwShareMode,
				lpsa,
				dwCreationDisposition,
				dwFlagsAndAttributes,
				hTemplateFile) :
			::CreateFile(
				szFilename,
				dwDesiredAccess,
				dwShareMode,
				lpsa,
				dwCreationDisposition,
				dwFlagsAndAttributes,
				hTemplateFile);

		if (hFile == INVALID_HANDLE_VALUE)
			return AtlHresultFromLastError();

		Attach(hFile);
		return S_OK;
	}

	HRESULT Read(
		_Out_bytecap_(nBufSize) LPVOID pBuffer,
		_In_ DWORD nBufSize) throw()
	{
		ATLASSUME(m_h != NULL);

		DWORD nBytesRead = 0;
		BOOL bSuccess = ::ReadFile(m_h, pBuffer, nBufSize, &nBytesRead, NULL);
		if (!bSuccess )
			return AtlHresultFromLastError();
		if (nBytesRead != nBufSize)
			return HRESULT_FROM_WIN32( ERROR_HANDLE_EOF );

		return S_OK;
	}

	HRESULT Read(
		_Out_bytecap_(nBufSize) LPVOID pBuffer,
		_In_ DWORD nBufSize,
		_Out_ DWORD& nBytesRead) throw()
	{
		ATLASSUME(m_h != NULL);

		BOOL b = ::ReadFile(m_h, pBuffer, nBufSize, &nBytesRead, NULL);
		if (!b)
			return AtlHresultFromLastError();

		return S_OK;
	}

	// this function will usually return HRESULT_FROM_WIN32(ERROR_IO_PENDING)
	// indicating succesful queueing of the operation
	HRESULT Read(
		_Out_bytecap_(nBufSize) LPVOID pBuffer,
		_In_ DWORD nBufSize,
		_Inout_opt_ LPOVERLAPPED pOverlapped) throw()
	{
		ATLASSUME(m_h != NULL);

		BOOL b = ::ReadFile(m_h, pBuffer, nBufSize, NULL, pOverlapped);
		if (!b)
			return AtlHresultFromLastError();

		return S_OK;
	}

	HRESULT Read(
		_In_bytecount_(nBufSize) LPVOID pBuffer,
		_In_ DWORD nBufSize,
		_Inout_ LPOVERLAPPED pOverlapped,
		_In_ LPOVERLAPPED_COMPLETION_ROUTINE pfnCompletionRoutine) throw()
	{
		ATLASSUME(m_h != NULL);

		BOOL b = ::ReadFileEx(m_h, pBuffer, nBufSize, pOverlapped, pfnCompletionRoutine);
		if (!b)
			return AtlHresultFromLastError();

		return S_OK;
	}

	HRESULT Write(
		_In_bytecount_(nBufSize) LPCVOID pBuffer,
		_In_ DWORD nBufSize,
		_Out_opt_ DWORD* pnBytesWritten = NULL) throw()
	{
		ATLASSUME(m_h != NULL);

		DWORD nBytesWritten;
		if (pnBytesWritten == NULL)
			pnBytesWritten = &nBytesWritten;
		BOOL b = ::WriteFile(m_h, pBuffer, nBufSize, pnBytesWritten, NULL);
		if (!b)
			return AtlHresultFromLastError();

		return S_OK;
	}

	// this function will usually return HRESULT_FROM_WIN32(ERROR_IO_PENDING)
	// indicating succesful queueing of the operation
	HRESULT Write(
		_In_bytecount_(nBufSize) LPCVOID pBuffer,
		_In_ DWORD nBufSize,
		_Inout_opt_ LPOVERLAPPED pOverlapped) throw()
	{
		ATLASSUME(m_h != NULL);

		BOOL b = ::WriteFile(m_h, pBuffer, nBufSize, NULL, pOverlapped);
		if (!b)
			return AtlHresultFromLastError();

		return S_OK;
	}

	HRESULT Write(
		_In_bytecount_(nBufSize) LPCVOID pBuffer,
		_In_ DWORD nBufSize,
		_Inout_ LPOVERLAPPED pOverlapped,
		_In_opt_ LPOVERLAPPED_COMPLETION_ROUTINE pfnCompletionRoutine) throw()
	{
		ATLASSUME(m_h != NULL);

		BOOL b = ::WriteFileEx(m_h, pBuffer, nBufSize, pOverlapped, pfnCompletionRoutine);
		if (!b)
			return AtlHresultFromLastError();

		return S_OK;
	}

	// this function returns HRESULT_FROM_WIN32(ERROR_IO_INCOMPLETE)
	// if bWait is false and the operation is still pending
	HRESULT GetOverlappedResult(
		_In_ LPOVERLAPPED pOverlapped,
		_Out_ DWORD& dwBytesTransferred,
		_In_ BOOL bWait) throw()
	{
		BOOL b = ::GetOverlappedResult(m_h, pOverlapped, &dwBytesTransferred, bWait);
		if (!b)
			return AtlHresultFromLastError();

		return S_OK;
	}

	HRESULT Seek(
		_In_ LONGLONG nOffset,
		_In_ DWORD dwFrom = FILE_CURRENT) throw()
	{
		ATLASSUME(m_h != NULL);
		ATLASSERT(dwFrom == FILE_BEGIN || dwFrom == FILE_END || dwFrom == FILE_CURRENT);

		LARGE_INTEGER liOffset;
		liOffset.QuadPart = nOffset;
		DWORD nNewPos = ::SetFilePointer(m_h, liOffset.LowPart, &liOffset.HighPart, dwFrom);
		if (nNewPos == INVALID_SET_FILE_POINTER)
		{
			HRESULT hr;

			hr = AtlHresultFromLastError();
			if (FAILED(hr))
				return hr;
		}

		return S_OK;
	}

	HRESULT GetPosition(_Out_ ULONGLONG& nPos) const throw()
	{
		ATLASSUME(m_h != NULL);

		LARGE_INTEGER liOffset;
		liOffset.QuadPart = 0;
		liOffset.LowPart = ::SetFilePointer(m_h, 0, &liOffset.HighPart, FILE_CURRENT);
		if (liOffset.LowPart == INVALID_SET_FILE_POINTER)
		{
			HRESULT hr;

			hr = AtlHresultFromLastError();
			if (FAILED(hr))
				return hr;
		}
		nPos = liOffset.QuadPart;

		return S_OK;
	}

	HRESULT Flush() throw()
	{
		ATLASSUME(m_h != NULL);

		if (!::FlushFileBuffers(m_h))
			return AtlHresultFromLastError();

		return S_OK;
	}

	HRESULT LockRange(
		_In_ ULONGLONG nPos,
		_In_ ULONGLONG nCount) throw()
	{
		ATLASSUME(m_h != NULL);

		LARGE_INTEGER liPos;
		liPos.QuadPart = nPos;

		LARGE_INTEGER liCount;
		liCount.QuadPart = nCount;

		if (!::LockFile(m_h, liPos.LowPart, liPos.HighPart, liCount.LowPart, liCount.HighPart))
			return AtlHresultFromLastError();

		return S_OK;
	}

	HRESULT UnlockRange(
		_In_ ULONGLONG nPos,
		_In_ ULONGLONG nCount) throw()
	{
		ATLASSUME(m_h != NULL);

		LARGE_INTEGER liPos;
		liPos.QuadPart = nPos;

		LARGE_INTEGER liCount;
		liCount.QuadPart = nCount;

		if (!::UnlockFile(m_h, liPos.LowPart, liPos.HighPart, liCount.LowPart, liCount.HighPart))
			return AtlHresultFromLastError();

		return S_OK;
	}

	HRESULT SetSize(_In_ ULONGLONG nNewLen) throw()
	{
		ATLASSUME(m_h != NULL);

		HRESULT hr = Seek(nNewLen, FILE_BEGIN);
		if (FAILED(hr))
			return hr;

		if (!::SetEndOfFile(m_h))
			return AtlHresultFromLastError();

		return S_OK;
	}

	HRESULT GetSize(_Out_ ULONGLONG& nLen) const throw()
	{
		ATLASSUME(m_h != NULL);

		ULARGE_INTEGER liFileSize;
		liFileSize.LowPart = ::GetFileSize(m_h, &liFileSize.HighPart);
		if (liFileSize.LowPart == INVALID_FILE_SIZE)
		{
			HRESULT hr;

			hr = AtlHresultFromLastError();
			if (FAILED(hr))
				return hr;
		}

		nLen = liFileSize.QuadPart;

		return S_OK;
	}

protected:
	/// <summary>
	/// Pointer to CAtlTransactionManager object</summary>
	CAtlTransactionManager* m_pTM;
};

// This class allows the creation of a temporary file that is written to.
// When the entire file has been successfully written it will be closed and given
// it's proper file name if required.
class CAtlTemporaryFile
{
public:
	CAtlTemporaryFile() throw()
	{
	}

	~CAtlTemporaryFile() throw()
	{
		// Ensure that the temporary file is closed and deleted,
		// if necessary.
		if (m_file.m_h != NULL)
		{
			Close();
		}
	}

	HRESULT Create(
		_In_opt_z_ LPCTSTR pszDir = NULL,
		_In_ DWORD dwDesiredAccess = GENERIC_WRITE) throw()
	{
		TCHAR szPath[_MAX_PATH];
		TCHAR tmpFileName[_MAX_PATH];

		ATLASSUME(m_file.m_h == NULL);

		if (pszDir == NULL)
		{
			DWORD dwRet = GetTempPath(_MAX_DIR, szPath);
			if (dwRet == 0)
			{
				// Couldn't find temporary path;
				return AtlHresultFromLastError();
			}
			else if (dwRet > _MAX_DIR)
			{
				return DISP_E_BUFFERTOOSMALL;
			}
		}
		else
		{
			if(Checked::tcsncpy_s(szPath, _countof(szPath), pszDir, _TRUNCATE)==STRUNCATE)
			{
				return DISP_E_BUFFERTOOSMALL;
			}
		}

		if (!GetTempFileName(szPath, _T("TFR"), 0, tmpFileName))
		{
			// Couldn't create temporary filename;
			return AtlHresultFromLastError();
		}
		tmpFileName[_countof(tmpFileName)-1]='\0';

		Checked::tcsncpy_s(m_szTempFileName, _countof(m_szTempFileName), tmpFileName, _TRUNCATE);
		SECURITY_ATTRIBUTES secatt;
		secatt.nLength = sizeof(secatt);
		secatt.lpSecurityDescriptor = NULL;
		secatt.bInheritHandle = TRUE;

		m_dwAccess = dwDesiredAccess;

		return m_file.Create(
			m_szTempFileName,
			m_dwAccess,
			0,
			CREATE_ALWAYS,
			FILE_ATTRIBUTE_NOT_CONTENT_INDEXED | FILE_ATTRIBUTE_TEMPORARY,
			&secatt);
	}

	HRESULT Close(_In_opt_z_ LPCTSTR szNewName = NULL) throw()
	{
		ATLASSUME(m_file.m_h != NULL);

		// This routine is called when we are finished writing to the
		// temporary file, so we now just want to close it and copy
		// it to the actual filename we want it to be called.

		// So let's close it first.
		m_file.Close();

		// no new name so delete it
		if (szNewName == NULL)
		{
			::DeleteFile(m_szTempFileName);
			return S_OK;
		}

		// delete any existing file and move our temp file into it's place
		if (!::DeleteFile(szNewName))
		{
			DWORD dwError = GetLastError();
			if (dwError != ERROR_FILE_NOT_FOUND)
				return AtlHresultFromWin32(dwError);
		}

		if (!::MoveFile(m_szTempFileName, szNewName))
			return AtlHresultFromLastError();

		return S_OK;
	}

	HRESULT HandsOff() throw()
	{
		m_file.Flush();
		m_file.Close();

		return S_OK;
	}

	HRESULT HandsOn() throw()
	{
		HRESULT hr = m_file.Create(
			m_szTempFileName,
			m_dwAccess,
			0,
			OPEN_EXISTING);
		if (FAILED(hr))
			return hr;

		return m_file.Seek(0, FILE_END);
	}

	HRESULT Read(
		_Out_bytecap_(nBufSize) LPVOID pBuffer,
		_In_ DWORD nBufSize,
		_Out_ DWORD& nBytesRead) throw()
	{
		return m_file.Read(pBuffer, nBufSize, nBytesRead);
	}

	HRESULT Write(
		_In_bytecount_(nBufSize) LPCVOID pBuffer,
		_In_ DWORD nBufSize,
		_Out_opt_ DWORD* pnBytesWritten = NULL) throw()
	{
		return m_file.Write(pBuffer, nBufSize, pnBytesWritten);
	}

	HRESULT Seek(
		_In_ LONGLONG nOffset,
		_In_ DWORD dwFrom = FILE_CURRENT) throw()
	{
		return m_file.Seek(nOffset, dwFrom);
	}

	HRESULT GetPosition(_Out_ ULONGLONG& nPos) const throw()
	{
		return m_file.GetPosition(nPos);
	}

	HRESULT Flush() throw()
	{
		return m_file.Flush();
	}

	HRESULT LockRange(
		_In_ ULONGLONG nPos,
		_In_ ULONGLONG nCount) throw()
	{
		return m_file.LockRange(nPos, nCount);
	}

	HRESULT UnlockRange(
		_In_ ULONGLONG nPos,
		_In_ ULONGLONG nCount) throw()
	{
		return m_file.UnlockRange(nPos, nCount);
	}

	HRESULT SetSize(_In_ ULONGLONG nNewLen) throw()
	{
		return m_file.SetSize(nNewLen);
	}

	HRESULT GetSize(_Out_ ULONGLONG& nLen) const throw()
	{
		return m_file.GetSize(nLen);
	}

	operator HANDLE() throw()
	{
		return m_file;
	}

	LPCTSTR TempFileName() throw()
	{
		return m_szTempFileName;
	}

private:
	CAtlFile m_file;
	TCHAR m_szTempFileName[_MAX_FNAME+1];
	DWORD m_dwAccess;
};

class CAtlFileMappingBase
{
public:
	CAtlFileMappingBase() throw()
	{
		m_pData = NULL;
		m_hMapping = NULL;
	}

	~CAtlFileMappingBase() throw()
	{
		Unmap();
	}

	HRESULT MapFile(
		_In_ HANDLE hFile,
		_In_ SIZE_T nMappingSize = 0,
		_In_ ULONGLONG nOffset = 0,
		_In_ DWORD dwMappingProtection = PAGE_READONLY,
		_In_ DWORD dwViewDesiredAccess = FILE_MAP_READ) throw()
	{
		ATLASSUME(m_pData == NULL);
		ATLASSUME(m_hMapping == NULL);
		ATLASSERT(hFile != INVALID_HANDLE_VALUE && hFile != NULL);

		ULARGE_INTEGER liFileSize;
		liFileSize.LowPart = ::GetFileSize(hFile, &liFileSize.HighPart);
		if (liFileSize.QuadPart < nMappingSize)
			liFileSize.QuadPart = nMappingSize;

		m_hMapping = ::CreateFileMapping(hFile, NULL, dwMappingProtection, liFileSize.HighPart, liFileSize.LowPart, 0);
		if (m_hMapping == NULL)
			return AtlHresultFromLastError();

		if (nMappingSize == 0)
			m_nMappingSize = (SIZE_T) (liFileSize.QuadPart - nOffset);
		else
			m_nMappingSize = nMappingSize;

		m_dwViewDesiredAccess = dwViewDesiredAccess;
		m_nOffset.QuadPart = nOffset;

		m_pData = ::MapViewOfFileEx(m_hMapping, m_dwViewDesiredAccess, m_nOffset.HighPart, m_nOffset.LowPart, m_nMappingSize, NULL);
		if (m_pData == NULL)
		{
			HRESULT hr;

			hr = AtlHresultFromLastError();
			::CloseHandle(m_hMapping);
			m_hMapping = NULL;
			return hr;
		}

		return S_OK;
	}

	HRESULT MapSharedMem(
		_In_ SIZE_T nMappingSize,
		_In_z_ LPCTSTR szName,
		_Out_opt_ BOOL* pbAlreadyExisted = NULL,
		_In_opt_ LPSECURITY_ATTRIBUTES lpsa = NULL,
		_In_ DWORD dwMappingProtection = PAGE_READWRITE,
		_In_ DWORD dwViewDesiredAccess = FILE_MAP_ALL_ACCESS) throw()
	{
		ATLASSUME(m_pData == NULL);
		ATLASSUME(m_hMapping == NULL);
		ATLASSERT(nMappingSize > 0);
		ATLASSERT(szName != NULL); // if you just want a regular chunk of memory, use a heap allocator

		m_nMappingSize = nMappingSize;

		ULARGE_INTEGER nSize;
		nSize.QuadPart = nMappingSize;
		m_hMapping = ::CreateFileMapping(INVALID_HANDLE_VALUE, lpsa, dwMappingProtection, nSize.HighPart, nSize.LowPart, szName);
		if (m_hMapping == NULL)
			return AtlHresultFromLastError();

		if (pbAlreadyExisted != NULL)
			*pbAlreadyExisted = (GetLastError() == ERROR_ALREADY_EXISTS);

		m_dwViewDesiredAccess = dwViewDesiredAccess;
		m_nOffset.QuadPart = 0;

		m_pData = ::MapViewOfFileEx(m_hMapping, m_dwViewDesiredAccess, m_nOffset.HighPart, m_nOffset.LowPart, m_nMappingSize, NULL);
		if (m_pData == NULL)
		{
			HRESULT hr;

			hr = AtlHresultFromLastError();
			::CloseHandle(m_hMapping);
			m_hMapping = NULL;
			return hr;
		}


		return S_OK;
	}

	HRESULT OpenMapping(
		_In_z_ LPCTSTR szName,
		_In_ SIZE_T nMappingSize,
		_In_ ULONGLONG nOffset = 0,
		_In_ DWORD dwViewDesiredAccess = FILE_MAP_ALL_ACCESS) throw()
	{
		ATLASSUME(m_pData == NULL);
		ATLASSUME(m_hMapping == NULL);
		ATLASSERT(szName != NULL); // if you just want a regular chunk of memory, use a heap allocator

		m_nMappingSize = nMappingSize;
		m_dwViewDesiredAccess = dwViewDesiredAccess;

		m_hMapping = ::OpenFileMapping(m_dwViewDesiredAccess, FALSE, szName);
		if (m_hMapping == NULL)
			return AtlHresultFromLastError();

		m_dwViewDesiredAccess = dwViewDesiredAccess;
		m_nOffset.QuadPart = nOffset;

		m_pData = ::MapViewOfFileEx(m_hMapping, m_dwViewDesiredAccess, m_nOffset.HighPart, m_nOffset.LowPart, m_nMappingSize, NULL);
		if (m_pData == NULL)
		{
			HRESULT hr;

			hr = AtlHresultFromLastError();
			::CloseHandle(m_hMapping);
			m_hMapping = NULL;
			return hr;
		}

		return S_OK;
	}

	HRESULT Unmap() throw()
	{
		HRESULT hr = S_OK;

		if (m_pData != NULL)
		{
			if (!::UnmapViewOfFile(m_pData))
				hr = AtlHresultFromLastError();
			m_pData = NULL;
		}
		if (m_hMapping != NULL)
		{
			if (!::CloseHandle(m_hMapping) && SUCCEEDED(hr))
				hr = AtlHresultFromLastError();
			m_hMapping = NULL;
		}
		return hr;
	}

	void* GetData() const throw()
	{
		return m_pData;
	}

	HANDLE GetHandle() const throw()
	{
		return m_hMapping;
	}

	SIZE_T GetMappingSize() throw()
	{
		return m_nMappingSize;
	}

	HRESULT CopyFrom(_In_ CAtlFileMappingBase& orig) throw()
	{
		if (this == &orig)
			return S_OK;
		ATLASSUME(m_pData == NULL);
		ATLASSUME(m_hMapping == NULL);
		ATLASSERT(orig.m_pData != NULL);
		ATLENSURE_RETURN_VAL(orig.m_hMapping != NULL, E_FAIL);

		m_dwViewDesiredAccess = orig.m_dwViewDesiredAccess;
		m_nOffset.QuadPart = orig.m_nOffset.QuadPart;
		m_nMappingSize = orig.m_nMappingSize;

		if (!::DuplicateHandle(GetCurrentProcess(), orig.m_hMapping, GetCurrentProcess(),
				&m_hMapping, NULL, TRUE, DUPLICATE_SAME_ACCESS))
			return AtlHresultFromLastError();

		m_pData = ::MapViewOfFileEx(m_hMapping, m_dwViewDesiredAccess, m_nOffset.HighPart, m_nOffset.LowPart, m_nMappingSize, NULL);
		if (m_pData == NULL)
		{
			HRESULT hr;

			hr = AtlHresultFromLastError();
			::CloseHandle(m_hMapping);
			m_hMapping = NULL;
			return hr;
		}

		return S_OK;
	}

	CAtlFileMappingBase(_In_ CAtlFileMappingBase& orig)
	{
		m_pData = NULL;
		m_hMapping = NULL;

		HRESULT hr = CopyFrom(orig);
		if (FAILED(hr))
			AtlThrow(hr);
	}

	CAtlFileMappingBase& operator=(_In_ CAtlFileMappingBase& orig)
	{
		HRESULT hr = CopyFrom(orig);
		if (FAILED(hr))
			AtlThrow(hr);

		return *this;
	}

private:
	void* m_pData;
	SIZE_T m_nMappingSize;
	HANDLE m_hMapping;
	ULARGE_INTEGER m_nOffset;
	DWORD m_dwViewDesiredAccess;
};

template <typename T = char>
class CAtlFileMapping : 
	public CAtlFileMappingBase
{
public:
	operator T*() const throw()
	{
		return reinterpret_cast<T*>(GetData());
	}
};

}; //namespace ATL

#pragma pack(pop)
#endif //__ATLFILE_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\include\atlimpl.cpp ===
// This is a part of the Active Template Library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Active Template Library Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Active Template Library product.

#pragma message("atlimpl.cpp is obsolete. Please remove it from your project.")

/////////////////////////////////////////////////////////////////////////////
// No longer used
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\include\atlimage.h ===
// This is a part of the Active Template Library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Active Template Library Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Active Template Library product.

#ifndef __ATLIMAGE_H__
#define __ATLIMAGE_H__

#pragma once

#include <atldef.h>
#include <atlbase.h>
#include <atlstr.h>
#include <atlsimpcoll.h>
#include <atltypes.h>

#ifndef _ATL_NO_PRAGMA_WARNINGS
#pragma warning (push)
#pragma warning(disable : 4820)	// padding added after member
#endif //!_ATL_NO_PRAGMA_WARNINGS

#pragma warning( push, 3 )
#pragma push_macro("new")
#undef new
#include <gdiplus.h>
#pragma pop_macro("new")
#pragma warning( pop )

#include <shlwapi.h>

#ifndef _ATL_NO_DEFAULT_LIBS
#pragma comment(lib, "gdi32.lib")
#pragma comment(lib, "shlwapi.lib")
#pragma comment(lib, "gdiplus.lib")
#if WINVER >= 0x0500
#pragma comment(lib, "msimg32.lib")
#endif  // WINVER >= 0x0500
#endif  // !_ATL_NO_DEFAULT_LIBS

#pragma pack(push, _ATL_PACKING)

namespace ATL
{

const int CIMAGE_DC_CACHE_SIZE = 4;

class CImage;

class CImageDC
{
public:
	CImageDC(_In_ const CImage& image) throw( ... );
	~CImageDC() throw();

	operator HDC() const throw();

private:
	const CImage& m_image;
	HDC m_hDC;
};

class CImage
{
private:
	class CDCCache
	{
	public:
		CDCCache() throw();
		~CDCCache() throw();

		HDC GetDC() throw();
		void ReleaseDC(_In_ HDC) throw();

	private:
		HDC m_ahDCs[CIMAGE_DC_CACHE_SIZE];
	};

	class CInitGDIPlus
	{
	public:
		CInitGDIPlus() throw();
		~CInitGDIPlus() throw();

		bool Init() throw();
		void ReleaseGDIPlus() throw();
		void IncreaseCImageCount() throw();
		void DecreaseCImageCount() throw();

	private:
		ULONG_PTR m_dwToken;
		CRITICAL_SECTION m_sect;
		LONG m_nCImageObjects;
		DWORD m_dwLastError;
	};

public:
	static const DWORD createAlphaChannel = 0x01;

	static const DWORD excludeGIF = 0x01;
	static const DWORD excludeBMP = 0x02;
	static const DWORD excludeEMF = 0x04;
	static const DWORD excludeWMF = 0x08;
	static const DWORD excludeJPEG = 0x10;
	static const DWORD excludePNG = 0x20;
	static const DWORD excludeTIFF = 0x40;
	static const DWORD excludeIcon = 0x80;
	static const DWORD excludeOther = 0x80000000;
	static const DWORD excludeDefaultLoad = 0;
	static const DWORD excludeDefaultSave = excludeIcon|excludeEMF|excludeWMF;
	static const DWORD excludeValid = 0x800000ff;

	enum DIBOrientation
	{
		DIBOR_DEFAULT,
		DIBOR_TOPDOWN,
		DIBOR_BOTTOMUP
	};

public:
	CImage() throw();
	virtual ~CImage() throw();

	operator HBITMAP() const throw();
#if WINVER >= 0x0500
	BOOL AlphaBlend(
		_In_ HDC hDestDC,
		_In_ int xDest,
		_In_ int yDest,
		_In_ BYTE bSrcAlpha = 0xff,
		_In_ BYTE bBlendOp = AC_SRC_OVER) const throw();
	BOOL AlphaBlend(
		_In_ HDC hDestDC,
		_In_ const POINT& pointDest,
		_In_ BYTE bSrcAlpha = 0xff,
		_In_ BYTE bBlendOp = AC_SRC_OVER) const throw();
	BOOL AlphaBlend(
		_In_ HDC hDestDC,
		_In_ int xDest,
		_In_ int yDest,
		_In_ int nDestWidth,
		_In_ int nDestHeight,
		_In_ int xSrc,
		_In_ int ySrc,
		_In_ int nSrcWidth,
		_In_ int nSrcHeight,
		_In_ BYTE bSrcAlpha = 0xff,
		_In_ BYTE bBlendOp = AC_SRC_OVER) const throw();
	BOOL AlphaBlend(
		_In_ HDC hDestDC,
		_In_ const RECT& rectDest,
		_In_ const RECT& rectSrc,
		_In_ BYTE bSrcAlpha = 0xff,
		_In_ BYTE bBlendOp = AC_SRC_OVER) const throw();
#endif  // WINVER >= 0x0500
	void Attach(
		_In_ HBITMAP hBitmap,
		_In_ DIBOrientation eOrientation = DIBOR_DEFAULT) throw();
	BOOL BitBlt(
		_In_ HDC hDestDC,
		_In_ int xDest,
		_In_ int yDest,
		_In_ DWORD dwROP = SRCCOPY) const throw();
	BOOL BitBlt(
		_In_ HDC hDestDC,
		_In_ const POINT& pointDest,
		_In_ DWORD dwROP = SRCCOPY) const throw();
	BOOL BitBlt(
		_In_ HDC hDestDC,
		_In_ int xDest,
		_In_ int yDest,
		_In_ int nDestWidth,
		_In_ int nDestHeight,
		_In_ int xSrc,
		_In_ int ySrc,
		_In_ DWORD dwROP = SRCCOPY) const throw();
	BOOL BitBlt(
		_In_ HDC hDestDC,
		_In_ const RECT& rectDest,
		_In_ const POINT& pointSrc,
		_In_ DWORD dwROP = SRCCOPY) const throw();
	BOOL Create(
		_In_ int nWidth,
		_In_ int nHeight,
		_In_ int nBPP,
		_In_ DWORD dwFlags = 0) throw();
	BOOL CreateEx(
		_In_ int nWidth,
		_In_ int nHeight,
		_In_ int nBPP,
		_In_ DWORD eCompression,
		_In_opt_count_c_(3) const DWORD* pdwBitmasks = NULL,
		_In_ DWORD dwFlags = 0) throw();
	void Destroy() throw();
	HBITMAP Detach() throw();
	BOOL Draw(
		_In_ HDC hDestDC,
		_In_ int xDest,
		_In_ int yDest,
		_In_ int nDestWidth,
		_In_ int nDestHeight,
		_In_ int xSrc,
		_In_ int ySrc,
		_In_ int nSrcWidth,
		_In_ int nSrcHeight) const throw();
	BOOL Draw(
		_In_ HDC hDestDC,
		_In_ const RECT& rectDest,
		_In_ const RECT& rectSrc) const throw();
	BOOL Draw(
		_In_ HDC hDestDC,
		_In_ int xDest,
		_In_ int yDest) const throw();
	BOOL Draw(
		_In_ HDC hDestDC,
		_In_ const POINT& pointDest) const throw();
	BOOL Draw(
		_In_ HDC hDestDC,
		_In_ int xDest,
		_In_ int yDest,
		_In_ int nDestWidth,
		_In_ int nDestHeight ) const throw();
	BOOL Draw(
		_In_ HDC hDestDC,
		_In_ const RECT& rectDest) const throw();
	BOOL Draw(
		_In_ HDC hDestDC,
		_In_ const RECT& rectDest,
		_In_ Gdiplus::InterpolationMode interpolationMode) const throw();
	const void* GetBits() const throw();
	void* GetBits() throw();
	int GetBPP() const throw();
	void GetColorTable(
		_In_ UINT iFirstColor,
		_In_ UINT nColors,
		_In_ RGBQUAD* prgbColors) const throw();
	HDC GetDC() const throw();
	static HRESULT GetExporterFilterString(
		_Inout_ CSimpleString& strExporters,
		_Inout_ CSimpleArray< GUID >& aguidFileTypes,
		_In_opt_z_ LPCTSTR pszAllFilesDescription = NULL,
		_In_ DWORD dwExclude = excludeDefaultSave,
		_In_ TCHAR chSeparator = _T( '|' ) );
	static HRESULT GetImporterFilterString(
		_Inout_ CSimpleString& strImporters,
		_Inout_ CSimpleArray< GUID >& aguidFileTypes,
		_In_opt_z_ LPCTSTR pszAllFilesDescription = NULL,
		_In_ DWORD dwExclude = excludeDefaultLoad,
		_In_ TCHAR chSeparator = _T( '|' ) );
	int GetHeight() const throw();
	int GetMaxColorTableEntries() const throw();
	int GetPitch() const throw();
	const void* GetPixelAddress(
		_In_ int x,
		_In_ int y) const throw();
	void* GetPixelAddress(
		_In_ int x,
		_In_ int y) throw();
	COLORREF GetPixel(
		_In_ int x,
		_In_ int y) const throw();
	LONG GetTransparentColor() const throw();
	int GetWidth() const throw();
	bool IsDIBSection() const throw();
	bool IsIndexed() const throw();
	bool IsNull() const throw();
	HRESULT Load(_In_z_ LPCTSTR pszFileName) throw();
	HRESULT Load(_Inout_ IStream* pStream) throw();
	void LoadFromResource(
		_In_opt_ HINSTANCE hInstance,
		_In_z_ LPCTSTR pszResourceName) throw();
	void LoadFromResource(
		_In_opt_ HINSTANCE hInstance,
		_In_ UINT nIDResource) throw();
	BOOL MaskBlt(
		_In_ HDC hDestDC,
		_In_ int xDest,
		_In_ int yDest,
		_In_ int nDestWidth,
		_In_ int nDestHeight,
		_In_ int xSrc,
		_In_ int ySrc,
		_In_ HBITMAP hbmMask,
		_In_ int xMask,
		_In_ int yMask,
		_In_ DWORD dwROP = SRCCOPY) const throw();
	BOOL MaskBlt(
		_In_ HDC hDestDC,
		_In_ const RECT& rectDest,
		_In_ const POINT& pointSrc,
		_In_ HBITMAP hbmMask,
		_In_ const POINT& pointMask,
		_In_ DWORD dwROP = SRCCOPY) const throw();
	BOOL MaskBlt(
		_In_ HDC hDestDC,
		_In_ int xDest,
		_In_ int yDest,
		_In_ HBITMAP hbmMask,
		_In_ DWORD dwROP = SRCCOPY) const throw();
	BOOL MaskBlt(
		_In_ HDC hDestDC,
		_In_ const POINT& pointDest,
		_In_ HBITMAP hbmMask,
		_In_ DWORD dwROP = SRCCOPY) const throw();
	BOOL PlgBlt(
		_In_ HDC hDestDC,
		_In_count_c_(3) const POINT* pPoints,
		_In_opt_ HBITMAP hbmMask = NULL) const throw();
	BOOL PlgBlt(
		_In_ HDC hDestDC,
		_In_count_c_(3) const POINT* pPoints,
		_In_ int xSrc,
		_In_ int ySrc,
		_In_ int nSrcWidth,
		_In_ int nSrcHeight,
		_In_opt_ HBITMAP hbmMask = NULL,
		_In_ int xMask = 0,
		_In_ int yMask = 0) const throw();
	BOOL PlgBlt(
		_In_ HDC hDestDC,
		_In_count_c_(3) const POINT* pPoints,
		_In_ const RECT& rectSrc,
		_In_opt_ HBITMAP hbmMask = NULL,
		_In_ const POINT& pointMask = CPoint( 0, 0 )) const throw();
	void ReleaseDC() const throw();
	HRESULT Save(
		_Inout_ IStream* pStream,
		_In_ REFGUID guidFileType) const throw();
	HRESULT Save(
		_In_z_ LPCTSTR pszFileName,
		_In_ REFGUID guidFileType = GUID_NULL) const throw();
	void SetColorTable(
		_In_ UINT iFirstColor,
		_In_ UINT nColors,
		_In_ const RGBQUAD* prgbColors) throw();
	void SetPixel(
		_In_ int x,
		_In_ int y,
		_In_ COLORREF color) throw();
	void SetPixelIndexed(
		_In_ int x,
		_In_ int y,
		_In_ int iIndex) throw();
	void SetPixelRGB(
		_In_ int x,
		_In_ int y,
		_In_ BYTE r,
		_In_ BYTE g,
		_In_ BYTE b) throw();
	void SetHasAlphaChannel(_In_ bool bHasAlphaChannel) throw();
	LONG SetTransparentColor(_In_ LONG iTransparentColor) throw();
	COLORREF SetTransparentColor(_In_ COLORREF clrTransparentColor) throw();
	BOOL StretchBlt(
		_In_ HDC hDestDC,
		_In_ int xDest,
		_In_ int yDest,
		_In_ int nDestWidth,
		_In_ int nDestHeight,
		_In_ DWORD dwROP = SRCCOPY) const throw();
	BOOL StretchBlt(
		_In_ HDC hDestDC,
		_In_ const RECT& rectDest,
		_In_ DWORD dwROP = SRCCOPY) const throw();
	BOOL StretchBlt(
		_In_ HDC hDestDC,
		_In_ int xDest,
		_In_ int yDest,
		_In_ int nDestWidth,
		_In_ int nDestHeight,
		_In_ int xSrc,
		_In_ int ySrc,
		_In_ int nSrcWidth,
		_In_ int nSrcHeight,
		_In_ DWORD dwROP = SRCCOPY) const throw();
	BOOL StretchBlt(
		_In_ HDC hDestDC,
		_In_ const RECT& rectDest,
		_In_ const RECT& rectSrc,
		_In_ DWORD dwROP = SRCCOPY) const throw();
#if WINVER >= 0x0500
	BOOL TransparentBlt(
		_In_ HDC hDestDC,
		_In_ int xDest,
		_In_ int yDest,
		_In_ int nDestWidth,
		_In_ int nDestHeight,
		_In_ UINT crTransparent = CLR_INVALID) const throw();
	BOOL TransparentBlt(
		_In_ HDC hDestDC,
		_In_ const RECT& rectDest,
		_In_ UINT crTransparent = CLR_INVALID) const throw();
	BOOL TransparentBlt(
		_In_ HDC hDestDC,
		_In_ int xDest,
		_In_ int yDest,
		_In_ int nDestWidth,
		_In_ int nDestHeight,
		_In_ int xSrc,
		_In_ int ySrc,
		_In_ int nSrcWidth,
		_In_ int nSrcHeight,
		_In_ UINT crTransparent = CLR_INVALID) const throw();
	BOOL TransparentBlt(
		_In_ HDC hDestDC,
		_In_ const RECT& rectDest,
		_In_ const RECT& rectSrc,
		_In_ UINT crTransparent = CLR_INVALID) const throw();
#endif  // WINVER >= 0x0500

	static BOOL IsTransparencySupported() throw();

private:
	HBITMAP m_hBitmap;
	void* m_pBits;
	int m_nWidth;
	int m_nHeight;
	int m_nPitch;
	int m_nBPP;
	bool m_bIsDIBSection;
	bool m_bHasAlphaChannel;
	LONG m_iTransparentColor;
	COLORREF m_clrTransparentColor;

	static CInitGDIPlus s_initGDIPlus;

public:
	inline static void ReleaseGDIPlus()
	{
		s_initGDIPlus.ReleaseGDIPlus();
	}


// Implementation
private:
	static CLSID FindCodecForExtension(
		_In_z_ LPCTSTR pszExtension,
		_In_count_(nCodecs) const Gdiplus::ImageCodecInfo* pCodecs,
		_In_ UINT nCodecs);
	static CLSID FindCodecForFileType(
		_In_ REFGUID guidFileType,
		_In_count_(nCodecs) const Gdiplus::ImageCodecInfo* pCodecs,
		_In_ UINT nCodecs);
	static void BuildCodecFilterString(
		_In_count_(nCodecs) const Gdiplus::ImageCodecInfo* pCodecs,
		_In_ UINT nCodecs,
		_Inout_ CSimpleString& strFilter,
		_Inout_ CSimpleArray< GUID >& aguidFileTypes,
		_In_opt_z_ LPCTSTR pszAllFilesDescription,
		_In_ DWORD dwExclude,
		_In_ TCHAR chSeparator);

	static bool ShouldExcludeFormat(
		_In_ REFGUID guidFileType,
		_In_ DWORD dwExclude) throw();
	void UpdateBitmapInfo(_In_ DIBOrientation eOrientation);
	HRESULT CreateFromGdiplusBitmap(_Inout_ Gdiplus::Bitmap& bmSrc) throw();

	static bool InitGDIPlus() throw();

	static int ComputePitch(
		_In_ int nWidth,
		_In_ int nBPP)
	{
		return( (((nWidth*nBPP)+31)/32)*4 );
	}
	COLORREF GetTransparentRGB() const;

private:
	mutable HDC m_hDC;
	mutable int m_nDCRefCount;
	mutable HBITMAP m_hOldBitmap;

	static CDCCache s_cache;
};

inline CImageDC::CImageDC(_In_ const CImage& image) throw( ... ) :
	m_image( image ),
	m_hDC( image.GetDC() )
{
	if( m_hDC == NULL )
	{
		AtlThrow( E_OUTOFMEMORY );
	}
}

inline CImageDC::~CImageDC() throw()
{
	m_image.ReleaseDC();
}

inline CImageDC::operator HDC() const throw()
{
	return( m_hDC );
}

inline CImage::CInitGDIPlus::CInitGDIPlus() throw() :
	m_dwToken( 0 ), m_nCImageObjects( 0 ), m_dwLastError(S_OK)
{
	if (!InitializeCriticalSectionAndSpinCount(&m_sect, 0))
	{
		m_dwLastError = HRESULT_FROM_WIN32(GetLastError());
	}
}

inline CImage::CInitGDIPlus::~CInitGDIPlus() throw()
{
	ReleaseGDIPlus();
	DeleteCriticalSection(&m_sect);
}

inline bool CImage::CInitGDIPlus::Init() throw()
{
	if (m_dwLastError != S_OK)
	{
		return false;
	}

	EnterCriticalSection(&m_sect);
	bool fRet = true;

	if( m_dwToken == 0 )
	{
		Gdiplus::GdiplusStartupInput input;
		Gdiplus::GdiplusStartupOutput output;
		Gdiplus::Status status = Gdiplus::GdiplusStartup( &m_dwToken, &input, &output );
		if( status != Gdiplus::Ok )
			fRet = false;
	}
	LeaveCriticalSection(&m_sect);
	return fRet;
}

inline void CImage::CInitGDIPlus::ReleaseGDIPlus() throw()
{
	EnterCriticalSection(&m_sect);
	if( m_dwToken != 0 )
	{
		Gdiplus::GdiplusShutdown( m_dwToken );
	}
	m_dwToken = 0;
	LeaveCriticalSection(&m_sect);
}

inline void CImage::CInitGDIPlus::IncreaseCImageCount() throw()
{
	EnterCriticalSection(&m_sect);
	m_nCImageObjects++;
	LeaveCriticalSection(&m_sect);
}

inline void CImage::CInitGDIPlus::DecreaseCImageCount() throw()
{
	EnterCriticalSection(&m_sect);
	if( --m_nCImageObjects == 0 )
		ReleaseGDIPlus();
	LeaveCriticalSection(&m_sect);
}

inline CImage::CDCCache::CDCCache() throw()
{
	int iDC;

	for( iDC = 0; iDC < CIMAGE_DC_CACHE_SIZE; iDC++ )
	{
		m_ahDCs[iDC] = NULL;
	}
}

inline CImage::CDCCache::~CDCCache() throw()
{
	int iDC;

	for( iDC = 0; iDC < CIMAGE_DC_CACHE_SIZE; iDC++ )
	{
		if( m_ahDCs[iDC] != NULL )
		{
			::DeleteDC( m_ahDCs[iDC] );
		}
	}
}

inline HDC CImage::CDCCache::GetDC() throw()
{
	HDC hDC;

	for( int iDC = 0; iDC < CIMAGE_DC_CACHE_SIZE; iDC++ )
	{
		hDC = static_cast< HDC >( InterlockedExchangePointer( reinterpret_cast< void** >(&m_ahDCs[iDC]), NULL ) );
		if( hDC != NULL )
		{
			return( hDC );
		}
	}

	hDC = ::CreateCompatibleDC( NULL );

	return( hDC );
}

inline void CImage::CDCCache::ReleaseDC(_In_ HDC hDC) throw()
{
	for( int iDC = 0; iDC < CIMAGE_DC_CACHE_SIZE; iDC++ )
	{
		HDC hOldDC;

		hOldDC = static_cast< HDC >( InterlockedExchangePointer( reinterpret_cast< void** >(&m_ahDCs[iDC]), hDC ) );
		if( hOldDC == NULL )
		{
			return;
		}
		else
		{
			hDC = hOldDC;
		}
	}
	if( hDC != NULL )
	{
		::DeleteDC( hDC );
	}
}

inline CImage::CImage() throw() :
	m_hBitmap( NULL ),
	m_pBits( NULL ),
	m_hDC( NULL ),
	m_nDCRefCount( 0 ),
	m_hOldBitmap( NULL ),
	m_nWidth( 0 ),
	m_nHeight( 0 ),
	m_nPitch( 0 ),
	m_nBPP( 0 ),
	m_iTransparentColor( -1 ),
	m_clrTransparentColor( (COLORREF)-1 ),
	m_bHasAlphaChannel( false ),
	m_bIsDIBSection( false )
{
	s_initGDIPlus.IncreaseCImageCount();
}

inline CImage::~CImage() throw()
{
	Destroy();
	s_initGDIPlus.DecreaseCImageCount();
}

inline CImage::operator HBITMAP() const throw()
{
	return( m_hBitmap );
}

#if WINVER >= 0x0500
inline BOOL CImage::AlphaBlend(
	_In_ HDC hDestDC,
	_In_ int xDest,
	_In_ int yDest,
	_In_ BYTE bSrcAlpha,
	_In_ BYTE bBlendOp) const throw()
{
	return AlphaBlend( hDestDC, xDest, yDest, m_nWidth, m_nHeight, 0, 0,
		m_nWidth, m_nHeight, bSrcAlpha, bBlendOp );
}

inline BOOL CImage::AlphaBlend(
	_In_ HDC hDestDC,
	_In_ const POINT& pointDest,
    _In_ BYTE bSrcAlpha,
	_In_ BYTE bBlendOp) const throw()
{
	return AlphaBlend( hDestDC, pointDest.x, pointDest.y, m_nWidth, m_nHeight,
		0, 0, m_nWidth, m_nHeight, bSrcAlpha, bBlendOp );
}

inline BOOL CImage::AlphaBlend(
	_In_ HDC hDestDC,
	_In_ int xDest,
	_In_ int yDest,
	_In_ int nDestWidth,
	_In_ int nDestHeight,
	_In_ int xSrc,
	_In_ int ySrc,
	_In_ int nSrcWidth,
	_In_ int nSrcHeight,
	_In_ BYTE bSrcAlpha,
	_In_ BYTE bBlendOp) const throw()
{
	BLENDFUNCTION blend;
	BOOL bResult;

	blend.SourceConstantAlpha = bSrcAlpha;
	blend.BlendOp = bBlendOp;
	blend.BlendFlags = 0;
	if( m_bHasAlphaChannel )
	{
		blend.AlphaFormat = AC_SRC_ALPHA;
	}
	else
	{
		blend.AlphaFormat = 0;
	}

	GetDC();

	bResult = ::AlphaBlend( hDestDC, xDest, yDest, nDestWidth, nDestHeight, m_hDC,
		xSrc, ySrc, nSrcWidth, nSrcHeight, blend );

	ReleaseDC();

	return( bResult );
}

inline BOOL CImage::AlphaBlend(
	_In_ HDC hDestDC,
	_In_ const RECT& rectDest,
	_In_ const RECT& rectSrc,
	_In_ BYTE bSrcAlpha,
	_In_ BYTE bBlendOp) const throw()
{
	return AlphaBlend(hDestDC, rectDest.left, rectDest.top, rectDest.right-
		rectDest.left, rectDest.bottom-rectDest.top, rectSrc.left, rectSrc.top,
		rectSrc.right-rectSrc.left, rectSrc.bottom-rectSrc.top, bSrcAlpha,
		bBlendOp);
}
#endif  // WINVER >= 0x0500

inline void CImage::Attach(
	_In_ HBITMAP hBitmap,
	_In_ DIBOrientation eOrientation) throw()
{
	ATLASSUME( m_hBitmap == NULL );
	ATLASSERT( hBitmap != NULL );

	m_hBitmap = hBitmap;

	UpdateBitmapInfo(eOrientation);
}

inline BOOL CImage::BitBlt(
	_In_ HDC hDestDC,
	_In_ int xDest,
	_In_ int yDest,
	_In_ DWORD dwROP) const throw()
{
	return BitBlt(hDestDC, xDest, yDest, m_nWidth, m_nHeight, 0, 0, dwROP);
}

inline BOOL CImage::BitBlt(
	_In_ HDC hDestDC,
	_In_ const POINT& pointDest,
	_In_ DWORD dwROP) const throw()
{
	return BitBlt(hDestDC, pointDest.x, pointDest.y, m_nWidth, m_nHeight, 0, 0, dwROP);
}

inline BOOL CImage::BitBlt(
	_In_ HDC hDestDC,
	_In_ int xDest,
	_In_ int yDest,
	_In_ int nDestWidth,
	_In_ int nDestHeight,
	_In_ int xSrc,
	_In_ int ySrc,
	_In_ DWORD dwROP) const throw()
{
	ATLASSUME( m_hBitmap != NULL );
	ATLENSURE_RETURN_VAL( hDestDC != NULL, FALSE );

	GetDC();

	BOOL bResult = ::BitBlt( hDestDC, xDest, yDest, nDestWidth, nDestHeight, m_hDC,
		xSrc, ySrc, dwROP );

	ReleaseDC();

	return bResult;
}

inline BOOL CImage::BitBlt(
	_In_ HDC hDestDC,
	_In_ const RECT& rectDest,
	_In_ const POINT& pointSrc,
	_In_ DWORD dwROP) const throw()
{
	return BitBlt( hDestDC, rectDest.left, rectDest.top, rectDest.right-
		rectDest.left, rectDest.bottom-rectDest.top, pointSrc.x, pointSrc.y,
		dwROP );
}

inline BOOL CImage::Create(
	_In_ int nWidth,
	_In_ int nHeight,
	_In_ int nBPP,
	_In_ DWORD dwFlags) throw()
{
	return( CreateEx( nWidth, nHeight, nBPP, BI_RGB, NULL, dwFlags ) );
}

inline BOOL CImage::CreateEx(
	_In_ int nWidth,
	_In_ int nHeight,
	_In_ int nBPP,
	_In_ DWORD eCompression,
	_In_opt_count_c_(3) const DWORD* pdwBitfields,
	_In_ DWORD dwFlags) throw()
{
	USES_ATL_SAFE_ALLOCA;
	LPBITMAPINFO pbmi;
	HBITMAP hBitmap;

	ATLASSERT( (eCompression == BI_RGB) || (eCompression == BI_BITFIELDS) );
	if( dwFlags&createAlphaChannel )
	{
		ATLASSERT( (nBPP == 32) && (eCompression == BI_RGB) );
	}

	pbmi = (LPBITMAPINFO)_ATL_SAFE_ALLOCA(sizeof(BITMAPINFOHEADER) + sizeof(RGBQUAD)*256, _ATL_SAFE_ALLOCA_DEF_THRESHOLD);
	if( pbmi == NULL )
		return FALSE;

	memset( &pbmi->bmiHeader, 0, sizeof( pbmi->bmiHeader ) );
	pbmi->bmiHeader.biSize = sizeof( pbmi->bmiHeader );
	pbmi->bmiHeader.biWidth = nWidth;
	pbmi->bmiHeader.biHeight = nHeight;
	pbmi->bmiHeader.biPlanes = 1;
	pbmi->bmiHeader.biBitCount = USHORT( nBPP );
	pbmi->bmiHeader.biCompression = eCompression;
	if( nBPP <= 8 )
	{
		ATLASSERT( eCompression == BI_RGB );
#pragma warning(push)
#pragma warning(disable:4068) //Disable unknown pragma warning that prefast pragma causes.
#pragma prefast(push)
#pragma prefast(disable:203, "no buffer overrun here, buffer was alocated properly")
		memset( pbmi->bmiColors, 0, 256*sizeof( RGBQUAD ) );
#pragma prefast(pop)
#pragma warning(pop)
	}

	else
	{
		if( eCompression == BI_BITFIELDS )
		{
			ATLASSUME( pdwBitfields != NULL );
			Checked::memcpy_s(pbmi->bmiColors, 3*sizeof( DWORD ), pdwBitfields, 3*sizeof( DWORD ));
		}
	}

	hBitmap = ::CreateDIBSection( NULL, pbmi, DIB_RGB_COLORS, &m_pBits, NULL,
		0 );
	if( hBitmap == NULL )
	{
		return( FALSE );
	}

	Attach( hBitmap, (nHeight < 0) ? DIBOR_TOPDOWN : DIBOR_BOTTOMUP );

	if( dwFlags&createAlphaChannel )
	{
		m_bHasAlphaChannel = true;
	}

	return( TRUE );
}

inline void CImage::Destroy() throw()
{
	HBITMAP hBitmap;

	if( m_hBitmap != NULL )
	{
		hBitmap = Detach();
		::DeleteObject( hBitmap );
	}
}

inline HBITMAP CImage::Detach() throw()
{
	HBITMAP hBitmap;

	ATLASSUME( m_hBitmap != NULL );
	ATLASSUME( m_hDC == NULL );

	hBitmap = m_hBitmap;
	m_hBitmap = NULL;
	m_pBits = NULL;
	m_nWidth = 0;
	m_nHeight = 0;
	m_nBPP = 0;
	m_nPitch = 0;
	m_iTransparentColor = -1;
	m_clrTransparentColor = (COLORREF)-1;
	m_bHasAlphaChannel = false;
	m_bIsDIBSection = false;

	return( hBitmap );
}

inline BOOL CImage::Draw(
	_In_ HDC hDestDC,
	_In_ const RECT& rectDest) const throw()
{
	return Draw( hDestDC, rectDest.left, rectDest.top, rectDest.right-
		rectDest.left, rectDest.bottom-rectDest.top, 0, 0, m_nWidth,
		m_nHeight );
}

inline BOOL CImage::Draw(
	_In_ HDC hDestDC,
	_In_ int xDest,
	_In_ int yDest,
	_In_ int nDestWidth,
	_In_ int nDestHeight) const throw()
{
	return Draw(hDestDC, xDest, yDest, nDestWidth, nDestHeight, 0, 0, m_nWidth, m_nHeight);
}

inline BOOL CImage::Draw(
	_In_ HDC hDestDC,
	_In_ const POINT& pointDest) const throw()
{
	return Draw( hDestDC, pointDest.x, pointDest.y, m_nWidth, m_nHeight, 0, 0, m_nWidth, m_nHeight );
}

inline BOOL CImage::Draw(
	_In_ HDC hDestDC,
	_In_ int xDest,
	_In_ int yDest) const throw()
{
	return Draw( hDestDC, xDest, yDest, m_nWidth, m_nHeight, 0, 0, m_nWidth, m_nHeight );
}

inline BOOL CImage::Draw(
	_In_ HDC hDestDC,
	_In_ const RECT& rectDest,
	_In_ const RECT& rectSrc) const throw()
{
	return Draw( hDestDC, rectDest.left, rectDest.top, rectDest.right-
		rectDest.left, rectDest.bottom-rectDest.top, rectSrc.left, rectSrc.top,
		rectSrc.right-rectSrc.left, rectSrc.bottom-rectSrc.top );
}

inline BOOL CImage::Draw(
	_In_ HDC hDestDC,
	_In_ int xDest,
	_In_ int yDest,
	_In_ int nDestWidth,
	_In_ int nDestHeight,
	_In_ int xSrc,
	_In_ int ySrc,
	_In_ int nSrcWidth,
	_In_ int nSrcHeight) const throw()
{
	BOOL bResult;

	ATLASSUME( m_hBitmap != NULL );
	ATLENSURE_RETURN_VAL( hDestDC != NULL, FALSE );
	ATLASSERT( nDestWidth > 0 );
	ATLASSERT( nDestHeight > 0 );
	ATLASSERT( nSrcWidth > 0 );
	ATLASSERT( nSrcHeight > 0 );

	GetDC();

#if WINVER >= 0x0500
	if( ((m_iTransparentColor != -1) || (m_clrTransparentColor != (COLORREF)-1)) && IsTransparencySupported() )
	{
		bResult = ::TransparentBlt( hDestDC, xDest, yDest, nDestWidth, nDestHeight,
			m_hDC, xSrc, ySrc, nSrcWidth, nSrcHeight, GetTransparentRGB() );
	}
	else if( m_bHasAlphaChannel && IsTransparencySupported() )
	{
		BLENDFUNCTION bf;

		bf.BlendOp = AC_SRC_OVER;
		bf.BlendFlags = 0;
		bf.SourceConstantAlpha = 0xff;
		bf.AlphaFormat = AC_SRC_ALPHA;
		bResult = ::AlphaBlend( hDestDC, xDest, yDest, nDestWidth, nDestHeight,
			m_hDC, xSrc, ySrc, nSrcWidth, nSrcHeight, bf );
	}
	else
#endif  // WINVER >= 0x0500
	{
		bResult = ::StretchBlt( hDestDC, xDest, yDest, nDestWidth, nDestHeight,
			m_hDC, xSrc, ySrc, nSrcWidth, nSrcHeight, SRCCOPY );
	}

	ReleaseDC();

	return( bResult );
}

inline BOOL CImage::Draw(
	_In_ HDC hDestDC,
	_In_ const RECT& rectDest,
	_In_ Gdiplus::InterpolationMode interpolationMode) const throw()
{
	if (!InitGDIPlus())
	{
		return FALSE;
	}

	Gdiplus::Bitmap bm(m_hBitmap, NULL);
	if (bm.GetLastStatus() != Gdiplus::Ok)
	{
		return FALSE;
	}

	Gdiplus::Graphics dcDst(hDestDC);
	dcDst.SetInterpolationMode(interpolationMode);

	Gdiplus::Status status = dcDst.DrawImage(&bm, rectDest.left, rectDest.top, rectDest.right - rectDest.left, rectDest.bottom - rectDest.top);

	return status == Gdiplus::Ok;
}

inline const void* CImage::GetBits() const throw()
{
	ATLASSUME( m_hBitmap != NULL );
	ATLASSERT( IsDIBSection() );

	return( m_pBits );
}

inline void* CImage::GetBits() throw()
{
	ATLASSUME( m_hBitmap != NULL );
	ATLASSERT( IsDIBSection() );

	return( m_pBits );
}

inline int CImage::GetBPP() const throw()
{
	ATLASSUME( m_hBitmap != NULL );

	return( m_nBPP );
}

inline void CImage::GetColorTable(
	_In_ UINT iFirstColor,
	_In_ UINT nColors,
	_In_ RGBQUAD* prgbColors) const throw()
{
	ATLASSUME( m_hBitmap != NULL );
	ATLASSUME( m_pBits != NULL );
	ATLASSERT( IsIndexed() );

	GetDC();

	::GetDIBColorTable( m_hDC, iFirstColor, nColors, prgbColors );

	ReleaseDC();
}

inline HDC CImage::GetDC() const throw()
{
	ATLASSUME( m_hBitmap != NULL );

	m_nDCRefCount++;
	if( m_hDC == NULL )
	{
		m_hDC = s_cache.GetDC();
		m_hOldBitmap = HBITMAP( ::SelectObject( m_hDC, m_hBitmap ) );
	}

	return( m_hDC );
}

inline bool CImage::ShouldExcludeFormat(
	_In_ REFGUID guidFileType,
	_In_ DWORD dwExclude) throw()
{
	static const GUID* apguidFormats[] =
	{
		&Gdiplus::ImageFormatGIF,
		&Gdiplus::ImageFormatBMP,
		&Gdiplus::ImageFormatEMF,
		&Gdiplus::ImageFormatWMF,
		&Gdiplus::ImageFormatJPEG,
		&Gdiplus::ImageFormatPNG,
		&Gdiplus::ImageFormatTIFF,
		&Gdiplus::ImageFormatIcon,
		NULL
	};

	ATLASSERT( (dwExclude|excludeValid) == excludeValid );
	for( int iFormat = 0; apguidFormats[iFormat] != NULL; iFormat++ )
	{
		if( guidFileType == *apguidFormats[iFormat] )
		{
			return( (dwExclude&(1<<iFormat)) != 0 );
		}
	}

	return( (dwExclude&excludeOther) != 0 );
}

inline void CImage::BuildCodecFilterString(
	_In_count_(nCodecs) const Gdiplus::ImageCodecInfo* pCodecs,
	_In_ UINT nCodecs,
	_Inout_ CSimpleString& strFilter,
	_Inout_ CSimpleArray< GUID >& aguidFileTypes,
	_In_opt_z_ LPCTSTR pszAllFilesDescription,
	_In_ DWORD dwExclude,
	_In_ TCHAR chSeparator)
{
	if( pszAllFilesDescription != NULL )
	{
		aguidFileTypes.Add( GUID_NULL );
	}

	CString strAllExtensions;
	CString strTempFilter;
	for( UINT iCodec = 0; iCodec < nCodecs; iCodec++ )
	{
		const Gdiplus::ImageCodecInfo* pCodec = &pCodecs[iCodec];

		if( !ShouldExcludeFormat( pCodec->FormatID, dwExclude ) )
		{
			CW2CT pwszFilenameExtension( pCodec->FilenameExtension );
			strTempFilter += CW2CT( pCodec->FormatDescription );
			strTempFilter += _T( " (" );
			strTempFilter += pwszFilenameExtension;
			strTempFilter += _T( ")" );
			strTempFilter += chSeparator;
			strTempFilter += pwszFilenameExtension;
			strTempFilter += chSeparator;

			aguidFileTypes.Add( pCodec->FormatID );

			if( !strAllExtensions.IsEmpty() )
			{
				strAllExtensions += _T( ";" );
			}
			strAllExtensions += pwszFilenameExtension;
		}
	}

	if( pszAllFilesDescription != NULL )
	{
		strFilter += pszAllFilesDescription;
		strFilter += chSeparator;
		strFilter += strAllExtensions;
		strFilter += chSeparator;
	}
	strFilter += strTempFilter;

	strFilter += chSeparator;
	if( aguidFileTypes.GetSize() == 0 )
	{
		strFilter += chSeparator;
	}
}

inline HRESULT CImage::GetImporterFilterString(
	_Inout_ CSimpleString& strImporters,
	_Inout_ CSimpleArray< GUID >& aguidFileTypes,
	_In_opt_z_ LPCTSTR pszAllFilesDescription /* = NULL */,
	_In_ DWORD dwExclude /* = excludeDefaultLoad */,
	_In_ TCHAR chSeparator /* = '|' */)
{
	if( !InitGDIPlus() )
	{
		return( E_FAIL );
	}

	UINT nCodecs;
	UINT nSize;
	Gdiplus::Status status;
	Gdiplus::ImageCodecInfo* pCodecs;

	status = Gdiplus::GetImageDecodersSize( &nCodecs, &nSize );
	USES_ATL_SAFE_ALLOCA;
	pCodecs = static_cast< Gdiplus::ImageCodecInfo* >( _ATL_SAFE_ALLOCA(nSize, _ATL_SAFE_ALLOCA_DEF_THRESHOLD) );

	if( pCodecs == NULL )
		return E_OUTOFMEMORY;

	status = Gdiplus::GetImageDecoders( nCodecs, nSize, pCodecs );
	BuildCodecFilterString( pCodecs, nCodecs, strImporters, aguidFileTypes, pszAllFilesDescription, dwExclude, chSeparator );

	return( S_OK );
}

inline HRESULT CImage::GetExporterFilterString(
	_Inout_ CSimpleString& strExporters,
	_Inout_ CSimpleArray< GUID >& aguidFileTypes,
	_In_opt_z_ LPCTSTR pszAllFilesDescription /* = NULL */,
	_In_ DWORD dwExclude /* = excludeDefaultSave */,
	_In_ TCHAR chSeparator /* = '|' */)
{
	if( !InitGDIPlus() )
	{
		return( E_FAIL );
	}

	UINT nCodecs;
	UINT nSize;
	Gdiplus::Status status;
	Gdiplus::ImageCodecInfo* pCodecs;

	status = Gdiplus::GetImageDecodersSize( &nCodecs, &nSize );
	USES_ATL_SAFE_ALLOCA;
	pCodecs = static_cast< Gdiplus::ImageCodecInfo* >( _ATL_SAFE_ALLOCA(nSize, _ATL_SAFE_ALLOCA_DEF_THRESHOLD) );

	if( pCodecs == NULL )
		return E_OUTOFMEMORY;

	status = Gdiplus::GetImageDecoders( nCodecs, nSize, pCodecs );
	BuildCodecFilterString( pCodecs, nCodecs, strExporters, aguidFileTypes, pszAllFilesDescription, dwExclude, chSeparator );

	return( S_OK );
}

inline int CImage::GetHeight() const throw()
{
	ATLASSUME( m_hBitmap != NULL );

	return( m_nHeight );
}

inline int CImage::GetMaxColorTableEntries() const throw()
{
	ATLASSUME( m_hBitmap != NULL );
	ATLASSERT( IsDIBSection() );

	if( IsIndexed() )
	{
		return( 1<<m_nBPP );
	}
	else
	{
		return( 0 );
	}
}

inline int CImage::GetPitch() const throw()
{
	ATLASSUME( m_hBitmap != NULL );
	ATLASSERT( IsDIBSection() );

	return( m_nPitch );
}

inline COLORREF CImage::GetPixel(
	_In_ int x,
	_In_ int y) const throw()
{
	ATLASSUME( m_hBitmap != NULL );
	ATLASSERT( (x >= 0) && (x < m_nWidth) );
	ATLASSERT( (y >= 0) && (y < m_nHeight) );

	GetDC();

	COLORREF clr = ::GetPixel( m_hDC, x, y );

	ReleaseDC();

	return( clr );
}

inline const void* CImage::GetPixelAddress(
	_In_ int x,
	_In_ int y) const throw()
{
	ATLASSUME( m_hBitmap != NULL );
	ATLASSERT( IsDIBSection() );
	ATLASSERT( (x >= 0) && (x < m_nWidth) );
	ATLASSERT( (y >= 0) && (y < m_nHeight) );

	return( LPBYTE( m_pBits )+(y*m_nPitch)+((x*m_nBPP)/8) );
}

inline void* CImage::GetPixelAddress(
	_In_ int x,
	_In_ int y) throw()
{
	ATLASSUME( m_hBitmap != NULL );
	ATLASSERT( IsDIBSection() );
	ATLASSERT( (x >= 0) && (x < m_nWidth) );
	ATLASSERT( (y >= 0) && (y < m_nHeight) );

	return( LPBYTE( m_pBits )+(y*m_nPitch)+((x*m_nBPP)/8) );
}

inline LONG CImage::GetTransparentColor() const throw()
{
	ATLASSUME( m_hBitmap != NULL );
	ATLASSERT( (m_nBPP == 4) || (m_nBPP == 8) );

	return( m_iTransparentColor );
}

inline int CImage::GetWidth() const throw()
{
	ATLASSUME( m_hBitmap != NULL );

	return( m_nWidth );
}

inline bool CImage::IsDIBSection() const throw()
{
	return( m_bIsDIBSection );
}

inline bool CImage::IsIndexed() const throw()
{
	ATLASSUME( m_hBitmap != NULL );
	ATLASSERT( IsDIBSection() );

	return( m_nBPP <= 8 );
}

inline bool CImage::IsNull() const throw()
{
	return( m_hBitmap == NULL );
}

inline HRESULT CImage::Load(_Inout_ IStream* pStream) throw()
{
	if( !InitGDIPlus() )
	{
		return( E_FAIL );
	}

	Gdiplus::Bitmap bmSrc( pStream );
	if( bmSrc.GetLastStatus() != Gdiplus::Ok )
	{
		return( E_FAIL );
	}

	return( CreateFromGdiplusBitmap( bmSrc ) );
}

inline HRESULT CImage::Load(_In_z_ LPCTSTR pszFileName) throw()
{
	if( !InitGDIPlus() )
	{
		return( E_FAIL );
	}

	Gdiplus::Bitmap bmSrc( (CT2W)pszFileName );
	if( bmSrc.GetLastStatus() != Gdiplus::Ok )
	{
		return( E_FAIL );
	}

	return( CreateFromGdiplusBitmap( bmSrc ) );
}

inline HRESULT CImage::CreateFromGdiplusBitmap(_Inout_ Gdiplus::Bitmap& bmSrc) throw()
{
	Gdiplus::PixelFormat eSrcPixelFormat = bmSrc.GetPixelFormat();
	UINT nBPP = 32;
	DWORD dwFlags = 0;
	Gdiplus::PixelFormat eDestPixelFormat = PixelFormat32bppRGB;
	if( eSrcPixelFormat&PixelFormatGDI )
	{
		nBPP = Gdiplus::GetPixelFormatSize( eSrcPixelFormat );
		eDestPixelFormat = eSrcPixelFormat;
	}
	if( Gdiplus::IsAlphaPixelFormat( eSrcPixelFormat ) )
	{
		nBPP = 32;
		dwFlags |= createAlphaChannel;
		eDestPixelFormat = PixelFormat32bppARGB;
	}

	BOOL bSuccess = Create( bmSrc.GetWidth(), bmSrc.GetHeight(), nBPP, dwFlags );
	if( !bSuccess )
	{
		return( E_FAIL );
	}
	USES_ATL_SAFE_ALLOCA;
	Gdiplus::ColorPalette* pPalette = NULL;
	if( Gdiplus::IsIndexedPixelFormat( eSrcPixelFormat ) )
	{
		UINT nPaletteSize = bmSrc.GetPaletteSize();
		pPalette = static_cast< Gdiplus::ColorPalette* >( _ATL_SAFE_ALLOCA(nPaletteSize, _ATL_SAFE_ALLOCA_DEF_THRESHOLD) );

		if( pPalette == NULL )
			return E_OUTOFMEMORY;

		bmSrc.GetPalette( pPalette, nPaletteSize );

		RGBQUAD argbPalette[256];
		ATLENSURE_RETURN( (pPalette->Count > 0) && (pPalette->Count <= 256) );
		for( UINT iColor = 0; iColor < pPalette->Count; iColor++ )
		{
			Gdiplus::ARGB color = pPalette->Entries[iColor];
			argbPalette[iColor].rgbRed = (BYTE)( (color>>RED_SHIFT) & 0xff );
			argbPalette[iColor].rgbGreen = (BYTE)( (color>>GREEN_SHIFT) & 0xff );
			argbPalette[iColor].rgbBlue = (BYTE)( (color>>BLUE_SHIFT) & 0xff );
			argbPalette[iColor].rgbReserved = 0;
		}

		SetColorTable( 0, pPalette->Count, argbPalette );
	}

	if( eDestPixelFormat == eSrcPixelFormat )
	{
		// The pixel formats are identical, so just memcpy the rows.
		Gdiplus::BitmapData data;
		Gdiplus::Rect rect( 0, 0, GetWidth(), GetHeight() );
		if(bmSrc.LockBits( &rect, Gdiplus::ImageLockModeRead, eSrcPixelFormat, &data )!=Gdiplus::Ok)
		{
			return E_OUTOFMEMORY;
		}

		size_t nBytesPerRow = AtlAlignUp( nBPP*GetWidth(), 8 )/8;
		BYTE* pbDestRow = static_cast< BYTE* >( GetBits() );
		BYTE* pbSrcRow = static_cast< BYTE* >( data.Scan0 );
		for( int y = 0; y < GetHeight(); y++ )
		{
			Checked::memcpy_s(pbDestRow, nBytesPerRow, pbSrcRow, nBytesPerRow);
			pbDestRow += GetPitch();
			pbSrcRow += data.Stride;
		}

		bmSrc.UnlockBits( &data );
	}
	else
	{
		// Let GDI+ work its magic
		Gdiplus::Bitmap bmDest( GetWidth(), GetHeight(), GetPitch(), eDestPixelFormat, static_cast< BYTE* >( GetBits() ) );
		Gdiplus::Graphics gDest( &bmDest );

		gDest.DrawImage( &bmSrc, 0, 0 );
	}

	return( S_OK );
}

inline void CImage::LoadFromResource(
	_In_opt_ HINSTANCE hInstance,
	_In_z_ LPCTSTR pszResourceName) throw()
{
	HBITMAP hBitmap;

	hBitmap = HBITMAP( ::LoadImage( hInstance, pszResourceName, IMAGE_BITMAP, 0,
		0, LR_CREATEDIBSECTION ) );

	Attach( hBitmap );
}

inline void CImage::LoadFromResource(
	_In_opt_ HINSTANCE hInstance,
	_In_ UINT nIDResource) throw()
{
	LoadFromResource( hInstance, MAKEINTRESOURCE( nIDResource ) );
}

inline BOOL CImage::MaskBlt(
	_In_ HDC hDestDC,
	_In_ int xDest,
	_In_ int yDest,
	_In_ int nWidth,
	_In_ int nHeight,
	_In_ int xSrc,
	_In_ int ySrc,
	_In_ HBITMAP hbmMask,
	_In_ int xMask,
	_In_ int yMask,
	_In_ DWORD dwROP) const throw()
{
	BOOL bResult;

	ATLASSUME( m_hBitmap != NULL );
	ATLENSURE_RETURN_VAL( hDestDC != NULL, FALSE );

	GetDC();

	bResult = ::MaskBlt( hDestDC, xDest, yDest, nWidth, nHeight, m_hDC, xSrc,
		ySrc, hbmMask, xMask, yMask, dwROP );

	ReleaseDC();

	return( bResult );
}

inline BOOL CImage::MaskBlt(
	_In_ HDC hDestDC,
	_In_ const RECT& rectDest,
	_In_ const POINT& pointSrc,
	_In_ HBITMAP hbmMask,
	_In_ const POINT& pointMask,
	_In_ DWORD dwROP) const throw()
{
	return MaskBlt( hDestDC, rectDest.left, rectDest.top, rectDest.right-
		rectDest.left, rectDest.bottom-rectDest.top, pointSrc.x, pointSrc.y,
		hbmMask, pointMask.x, pointMask.y, dwROP );
}

inline BOOL CImage::MaskBlt(
	_In_ HDC hDestDC,
	_In_ int xDest,
	_In_ int yDest,
	_In_ HBITMAP hbmMask,
	_In_ DWORD dwROP) const throw()
{
	return MaskBlt( hDestDC, xDest, yDest, m_nWidth, m_nHeight, 0, 0, hbmMask,
		0, 0, dwROP );
}

inline BOOL CImage::MaskBlt(
	_In_ HDC hDestDC,
	_In_ const POINT& pointDest,
	_In_ HBITMAP hbmMask,
	_In_ DWORD dwROP) const throw()
{
	return MaskBlt( hDestDC, pointDest.x, pointDest.y, m_nWidth, m_nHeight, 0,
		0, hbmMask, 0, 0, dwROP );
}

inline BOOL CImage::PlgBlt(
	_In_ HDC hDestDC,
	_In_count_c_(3) const POINT* pPoints,
	_In_ int xSrc,
	_In_ int ySrc,
	_In_ int nSrcWidth,
	_In_ int nSrcHeight,
	_In_opt_ HBITMAP hbmMask,
	_In_ int xMask,
	_In_ int yMask) const throw()
{
	ATLASSUME( m_hBitmap != NULL );
	ATLENSURE_RETURN_VAL( hDestDC != NULL, FALSE );

	GetDC();

	BOOL bResult = ::PlgBlt( hDestDC, pPoints, m_hDC, xSrc, ySrc, nSrcWidth,
		nSrcHeight, hbmMask, xMask, yMask );

	ReleaseDC();

	return( bResult );
}

inline BOOL CImage::PlgBlt(
	_In_ HDC hDestDC,
	_In_count_c_(3) const POINT* pPoints,
	_In_ const RECT& rectSrc,
	_In_opt_ HBITMAP hbmMask,
	_In_ const POINT& pointMask) const throw()
{
	return PlgBlt( hDestDC, pPoints, rectSrc.left, rectSrc.top, rectSrc.right-
		rectSrc.left, rectSrc.bottom-rectSrc.top, hbmMask, pointMask.x,
		pointMask.y );
}

inline BOOL CImage::PlgBlt(
	_In_ HDC hDestDC,
	_In_count_c_(3) const POINT* pPoints,
	_In_opt_ HBITMAP hbmMask) const throw()
{
	return PlgBlt( hDestDC, pPoints, 0, 0, m_nWidth, m_nHeight, hbmMask, 0, 0 );
}

inline void CImage::ReleaseDC() const throw()
{
	HBITMAP hBitmap;

	ATLASSUME( m_hDC != NULL );

	m_nDCRefCount--;
	if( m_nDCRefCount == 0 )
	{
		hBitmap = HBITMAP( ::SelectObject( m_hDC, m_hOldBitmap ) );
		ATLASSERT( hBitmap == m_hBitmap );
		s_cache.ReleaseDC( m_hDC );
		m_hDC = NULL;
	}
}

inline CLSID CImage::FindCodecForExtension(
	_In_z_ LPCTSTR pszExtension,
	_In_count_(nCodecs) const Gdiplus::ImageCodecInfo* pCodecs,
	_In_ UINT nCodecs)
{
	CT2CW pszExtensionW( pszExtension );

	for( UINT iCodec = 0; iCodec < nCodecs; iCodec++ )
	{
		CStringW strExtensions( pCodecs[iCodec].FilenameExtension );

		int iStart = 0;
		do
		{
			CStringW strExtension = ::PathFindExtensionW( strExtensions.Tokenize( L";", iStart ) );
			if( iStart != -1 )
			{
				if( strExtension.CompareNoCase( pszExtensionW ) == 0 )
				{
					return( pCodecs[iCodec].Clsid );
				}
			}
		} while( iStart != -1 );
	}

	return( CLSID_NULL );
}

inline CLSID CImage::FindCodecForFileType(
	_In_ REFGUID guidFileType,
	_In_count_(nCodecs) const Gdiplus::ImageCodecInfo* pCodecs,
	_In_ UINT nCodecs)
{
	for( UINT iCodec = 0; iCodec < nCodecs; iCodec++ )
	{
		if( pCodecs[iCodec].FormatID == guidFileType )
		{
			return( pCodecs[iCodec].Clsid );
		}
	}

	return( CLSID_NULL );
}

inline HRESULT CImage::Save(
	_Inout_ IStream* pStream,
	_In_ REFGUID guidFileType) const throw()
{
	if( !InitGDIPlus() )
	{
		return( E_FAIL );
	}

	UINT nEncoders;
	UINT nBytes;
	Gdiplus::Status status;

	status = Gdiplus::GetImageEncodersSize( &nEncoders, &nBytes );
	if( status != Gdiplus::Ok )
	{
		return( E_FAIL );
	}

	USES_ATL_SAFE_ALLOCA;
	Gdiplus::ImageCodecInfo* pEncoders = static_cast< Gdiplus::ImageCodecInfo* >( _ATL_SAFE_ALLOCA(nBytes, _ATL_SAFE_ALLOCA_DEF_THRESHOLD) );

	if( pEncoders == NULL )
		return E_OUTOFMEMORY;

	status = Gdiplus::GetImageEncoders( nEncoders, nBytes, pEncoders );
	if( status != Gdiplus::Ok )
	{
		return( E_FAIL );
	}

	CLSID clsidEncoder = FindCodecForFileType( guidFileType, pEncoders, nEncoders );
	if( clsidEncoder == CLSID_NULL )
	{
		return( E_FAIL );
	}

	if( m_bHasAlphaChannel )
	{
		ATLASSUME( m_nBPP == 32 );
		Gdiplus::Bitmap bm( m_nWidth, m_nHeight, m_nPitch, PixelFormat32bppARGB, static_cast< BYTE* >( m_pBits ) );
		status = bm.Save( pStream, &clsidEncoder, NULL );
		if( status != Gdiplus::Ok )
		{
			return( E_FAIL );
		}
	}
	else
	{
		Gdiplus::Bitmap bm( m_hBitmap, NULL );
		status = bm.Save( pStream, &clsidEncoder, NULL );
		if( status != Gdiplus::Ok )
		{
			return( E_FAIL );
		}
	}

	return( S_OK );
}

inline HRESULT CImage::Save(
	_In_z_ LPCTSTR pszFileName,
	_In_ REFGUID guidFileType) const throw()
{
	if( !InitGDIPlus() )
	{
		return( E_FAIL );
	}

	UINT nEncoders;
	UINT nBytes;
	Gdiplus::Status status;

	status = Gdiplus::GetImageEncodersSize( &nEncoders, &nBytes );
	if( status != Gdiplus::Ok )
	{
		return( E_FAIL );
	}

	USES_CONVERSION_EX;
	Gdiplus::ImageCodecInfo* pEncoders = static_cast< Gdiplus::ImageCodecInfo* >( _ATL_SAFE_ALLOCA(nBytes, _ATL_SAFE_ALLOCA_DEF_THRESHOLD) );

	if( pEncoders == NULL )
		return E_OUTOFMEMORY;

	status = Gdiplus::GetImageEncoders( nEncoders, nBytes, pEncoders );
	if( status != Gdiplus::Ok )
	{
		return( E_FAIL );
	}

	CLSID clsidEncoder = CLSID_NULL;
	if( guidFileType == GUID_NULL )
	{
		// Determine clsid from extension
		clsidEncoder = FindCodecForExtension( ::PathFindExtension( pszFileName ), pEncoders, nEncoders );
	}
	else
	{
		// Determine clsid from file type
		clsidEncoder = FindCodecForFileType( guidFileType, pEncoders, nEncoders );
	}
	if( clsidEncoder == CLSID_NULL )
	{
		return( E_FAIL );
	}

	LPCWSTR pwszFileName = T2CW_EX( pszFileName, _ATL_SAFE_ALLOCA_DEF_THRESHOLD );
#ifndef _UNICODE
	if( pwszFileName == NULL )
		return E_OUTOFMEMORY;
#endif // _UNICODE
	if( m_bHasAlphaChannel )
	{
		ATLASSUME( m_nBPP == 32 );
		Gdiplus::Bitmap bm( m_nWidth, m_nHeight, m_nPitch, PixelFormat32bppARGB, static_cast< BYTE* >( m_pBits ) );
		status = bm.Save( pwszFileName, &clsidEncoder, NULL );
		if( status != Gdiplus::Ok )
		{
			return( E_FAIL );
		}
	}
	else
	{
		Gdiplus::Bitmap bm( m_hBitmap, NULL );
		status = bm.Save( pwszFileName, &clsidEncoder, NULL );
		if( status != Gdiplus::Ok )
		{
			return( E_FAIL );
		}
	}

	return( S_OK );
}

inline void CImage::SetColorTable(
	_In_ UINT iFirstColor,
	_In_ UINT nColors,
	_In_ const RGBQUAD* prgbColors) throw()
{
	ATLASSUME( m_hBitmap != NULL );
	ATLASSERT( IsDIBSection() );
	ATLASSERT( IsIndexed() );

	GetDC();

	::SetDIBColorTable( m_hDC, iFirstColor, nColors, prgbColors );

	ReleaseDC();
}

inline void CImage::SetPixel(
	_In_ int x,
	_In_ int y,
	_In_ COLORREF color) throw()
{
	ATLASSUME( m_hBitmap != NULL );
	ATLASSERT( (x >= 0) && (x < m_nWidth) );
	ATLASSERT( (y >= 0) && (y < m_nHeight) );

	GetDC();

	::SetPixel( m_hDC, x, y, color );

	ReleaseDC();
}

inline void CImage::SetPixelIndexed(
	_In_ int x,
	_In_ int y,
	_In_ int iIndex) throw()
{
	SetPixel( x, y, PALETTEINDEX( iIndex ) );
}

inline void CImage::SetPixelRGB(
	_In_ int x,
	_In_ int y,
	_In_ BYTE r,
	_In_ BYTE g,
	_In_ BYTE b) throw()
{
	SetPixel( x, y, RGB( r, g, b ) );
}

inline void CImage::SetHasAlphaChannel(_In_ bool bHasAlphaChannel) throw()
{
	m_bHasAlphaChannel = bHasAlphaChannel;
}

inline LONG CImage::SetTransparentColor(_In_ LONG iTransparentColor) throw()
{
	LONG iOldTransparentColor;

	ATLASSUME( m_hBitmap != NULL );
	ATLASSERT( (m_nBPP == 4) || (m_nBPP == 8) );
	ATLASSERT( iTransparentColor < GetMaxColorTableEntries() );
	ATLASSERT( iTransparentColor >= -1 );

	iOldTransparentColor = m_iTransparentColor;
	m_iTransparentColor = iTransparentColor;

	return( iOldTransparentColor );
}

inline COLORREF CImage::SetTransparentColor(_In_ COLORREF clrTransparentColor) throw()
{
	COLORREF clrOldTransparentColor;

	clrOldTransparentColor = m_clrTransparentColor;
	m_clrTransparentColor = clrTransparentColor;

	return( clrOldTransparentColor );
}

inline BOOL CImage::StretchBlt(
	_In_ HDC hDestDC,
	_In_ int xDest,
	_In_ int yDest,
	_In_ int nDestWidth,
	_In_ int nDestHeight,
	_In_ DWORD dwROP) const throw()
{
	return StretchBlt( hDestDC, xDest, yDest, nDestWidth, nDestHeight, 0, 0,
		m_nWidth, m_nHeight, dwROP );
}

inline BOOL CImage::StretchBlt(
	_In_ HDC hDestDC,
	_In_ const RECT& rectDest,
	_In_ DWORD dwROP) const throw()
{
	return StretchBlt( hDestDC, rectDest.left, rectDest.top, rectDest.right-
		rectDest.left, rectDest.bottom-rectDest.top, 0, 0, m_nWidth, m_nHeight,
		dwROP );
}

inline BOOL CImage::StretchBlt(
	_In_ HDC hDestDC,
	_In_ int xDest,
	_In_ int yDest,
	_In_ int nDestWidth,
	_In_ int nDestHeight,
	_In_ int xSrc,
	_In_ int ySrc,
	_In_ int nSrcWidth,
	_In_ int nSrcHeight,
	_In_ DWORD dwROP) const throw()
{
	ATLASSUME( m_hBitmap != NULL );
	ATLENSURE_RETURN_VAL( hDestDC != NULL, FALSE );

	GetDC();

	BOOL bResult = ::StretchBlt( hDestDC, xDest, yDest, nDestWidth, nDestHeight, m_hDC,
		xSrc, ySrc, nSrcWidth, nSrcHeight, dwROP );

	ReleaseDC();

	return( bResult );
}

inline BOOL CImage::StretchBlt(
	_In_ HDC hDestDC,
	_In_ const RECT& rectDest,
	_In_ const RECT& rectSrc,
	_In_ DWORD dwROP) const throw()
{
	return StretchBlt( hDestDC, rectDest.left, rectDest.top, rectDest.right-
		rectDest.left, rectDest.bottom-rectDest.top, rectSrc.left, rectSrc.top,
		rectSrc.right-rectSrc.left, rectSrc.bottom-rectSrc.top, dwROP );
}

#if WINVER >= 0x0500
inline BOOL CImage::TransparentBlt(
	_In_ HDC hDestDC,
	_In_ int xDest,
	_In_ int yDest,
	_In_ int nDestWidth,
	_In_ int nDestHeight,
	_In_ UINT crTransparent) const throw()
{
	return TransparentBlt( hDestDC, xDest, yDest, nDestWidth, nDestHeight, 0,
		0, m_nWidth, m_nHeight, crTransparent );
}

inline BOOL CImage::TransparentBlt(
	_In_ HDC hDestDC,
	_In_ const RECT& rectDest,
	_In_ UINT crTransparent) const throw()
{
	return TransparentBlt( hDestDC, rectDest.left, rectDest.top,
		rectDest.right-rectDest.left, rectDest.bottom-rectDest.top,
		crTransparent );
}

inline BOOL CImage::TransparentBlt(
	_In_ HDC hDestDC,
	_In_ int xDest,
	_In_ int yDest,
	_In_ int nDestWidth,
	_In_ int nDestHeight,
	_In_ int xSrc,
	_In_ int ySrc,
	_In_ int nSrcWidth,
	_In_ int nSrcHeight,
	_In_ UINT crTransparent) const throw()
{
	ATLASSUME( m_hBitmap != NULL );
	ATLENSURE_RETURN_VAL( hDestDC != NULL, FALSE );

	GetDC();

	if( crTransparent == CLR_INVALID )
	{
		crTransparent = GetTransparentRGB();
	}

	BOOL bResult = ::TransparentBlt( hDestDC, xDest, yDest, nDestWidth, nDestHeight,
		m_hDC, xSrc, ySrc, nSrcWidth, nSrcHeight, crTransparent );

	ReleaseDC();

	return( bResult );
}

inline BOOL CImage::TransparentBlt(
	_In_ HDC hDestDC,
	_In_ const RECT& rectDest,
	_In_ const RECT& rectSrc,
	_In_ UINT crTransparent) const throw()
{
	return TransparentBlt( hDestDC, rectDest.left, rectDest.top,
		rectDest.right-rectDest.left, rectDest.bottom-rectDest.top, rectSrc.left,
		rectSrc.top, rectSrc.right-rectSrc.left, rectSrc.bottom-rectSrc.top,
		crTransparent );
}
#endif  // WINVER >= 0x0500

inline BOOL CImage::IsTransparencySupported() throw()
{
	return( TRUE );
}

inline void CImage::UpdateBitmapInfo(_In_ DIBOrientation eOrientation)
{
	DIBSECTION dibsection;
	int nBytes;

	nBytes = ::GetObject( m_hBitmap, sizeof( DIBSECTION ), &dibsection );
	if( nBytes == sizeof( DIBSECTION ) )
	{
		m_bIsDIBSection = true;
		m_nWidth = dibsection.dsBmih.biWidth;
		m_nHeight = abs( dibsection.dsBmih.biHeight );
		m_nBPP = dibsection.dsBmih.biBitCount;
		m_nPitch = ComputePitch( m_nWidth, m_nBPP );
		m_pBits = dibsection.dsBm.bmBits;
		if( eOrientation == DIBOR_DEFAULT )
		{
			eOrientation = (dibsection.dsBmih.biHeight > 0) ? DIBOR_BOTTOMUP : DIBOR_TOPDOWN;
		}
		if( eOrientation == DIBOR_BOTTOMUP )
		{
			m_pBits = LPBYTE( m_pBits )+((m_nHeight-1)*m_nPitch);
			m_nPitch = -m_nPitch;
		}
	}
	else
	{
		// Non-DIBSection
		ATLASSERT( nBytes == sizeof( BITMAP ) );
		m_bIsDIBSection = false;
		m_nWidth = dibsection.dsBm.bmWidth;
		m_nHeight = dibsection.dsBm.bmHeight;
		m_nBPP = dibsection.dsBm.bmBitsPixel;
		m_nPitch = 0;
		m_pBits = 0;
	}
	m_iTransparentColor = -1;
	m_bHasAlphaChannel = false;
}

inline COLORREF CImage::GetTransparentRGB() const
{
	RGBQUAD rgb;

	ATLASSUME( m_hDC != NULL );  // Must have a DC
	ATLASSUME( m_iTransparentColor != -1 || m_clrTransparentColor != (COLORREF)-1 );

	if (m_iTransparentColor != -1)
	{
		::GetDIBColorTable( m_hDC, m_iTransparentColor, 1, &rgb );
		return( RGB( rgb.rgbRed, rgb.rgbGreen, rgb.rgbBlue ) );
	}
	else
	{
		return m_clrTransparentColor;
	}
}

inline bool CImage::InitGDIPlus() throw()
{
	bool bSuccess = s_initGDIPlus.Init();
	return( bSuccess );
}

};  // namespace ATL

#pragma pack(pop)

#ifndef _ATL_NO_PRAGMA_WARNINGS
#pragma warning (pop)
#endif

#endif  // __ATLIMAGE_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\include\atlpath.h ===
// This is a part of the Active Template Library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Active Template Library Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Active Template Library product.

#ifndef __ATLPATH_H__
#define __ATLPATH_H__

#pragma once

#ifdef _AFX
#include <afxstr.h>
#else
#include <atlstr.h>
#endif

#ifndef _ATL_NO_DEFAULT_LIBS
#pragma comment(lib, "shlwapi.lib")
#endif  // !_ATL_NO_DEFAULT_LIBS


#pragma pack(push,_ATL_PACKING)
namespace ATL
{

namespace ATLPath
{

_Ret_opt_z_ inline char* AddBackslash(
	_Inout_z_cap_c_(MAX_PATH) char* pszPath)
{
	return ::PathAddBackslashA( pszPath );
}

_Ret_opt_z_ inline wchar_t* AddBackslash(
	_Inout_z_cap_c_(MAX_PATH) wchar_t* pszPath)
{
	return ::PathAddBackslashW( pszPath );
}

inline BOOL AddExtension(
	_Inout_z_cap_c_(MAX_PATH) char* pszPath,
	_In_z_ const char* pszExtension)
{
	return ::PathAddExtensionA( pszPath, pszExtension );
}

inline BOOL AddExtension(
	_Inout_z_cap_c_(MAX_PATH) wchar_t* pszPath,
	_In_z_ const wchar_t* pszExtension)
{
	return ::PathAddExtensionW( pszPath, pszExtension );
}

inline BOOL Append(
	_Inout_z_cap_c_(MAX_PATH) char* pszPath,
	_In_z_ const char* pszMore)
{
	return ::PathAppendA( pszPath, pszMore );
}

inline BOOL Append(
	_Inout_z_cap_c_(MAX_PATH) wchar_t* pszPath,
	_In_z_ const wchar_t* pszMore)
{
	return ::PathAppendW( pszPath, pszMore );
}

_Ret_z_ inline char* BuildRoot(
	_Out_z_cap_c_(4) char* pszPath,
	_In_ int iDrive)
{
	return ::PathBuildRootA( pszPath, iDrive );
}

_Ret_z_ inline wchar_t* BuildRoot(
	_Out_z_cap_c_(4) wchar_t* pszPath,
	_In_ int iDrive)
{
	return ::PathBuildRootW( pszPath, iDrive );
}

inline BOOL Canonicalize(
	_Out_z_cap_c_(MAX_PATH) char* pszDest,
	_In_z_ const char* pszSrc)
{
	return ::PathCanonicalizeA( pszDest, pszSrc );
}

inline BOOL Canonicalize(
	_Out_z_cap_c_(MAX_PATH) wchar_t* pszDest,
	_In_z_ const wchar_t* pszSrc)
{
	return ::PathCanonicalizeW( pszDest, pszSrc );
}

_Ret_opt_z_ inline char* Combine(
	_Out_z_cap_c_(MAX_PATH) char* pszDest,
	_In_z_ const char* pszDir,
	_In_z_ const char* pszFile)
{
	return ::PathCombineA( pszDest, pszDir, pszFile );
}

_Ret_opt_z_ inline wchar_t* Combine(
	_Out_z_cap_c_(MAX_PATH) wchar_t* pszDest,
	_In_ const wchar_t* pszDir,
	_In_ const wchar_t* pszFile)
{
	return ::PathCombineW( pszDest, pszDir, pszFile );
}

inline int CommonPrefix(
	_In_z_ const char* pszFile1,
	_In_z_ const char* pszFile2,
	_Out_z_cap_c_(MAX_PATH) char* pszDest)
{
	return ::PathCommonPrefixA( pszFile1, pszFile2, pszDest );
}

inline int CommonPrefix(
	_In_z_ const wchar_t* pszFile1,
	_In_z_ const wchar_t* pszFile2,
	_Out_z_cap_c_(MAX_PATH) wchar_t* pszDest)
{
	return ::PathCommonPrefixW( pszFile1, pszFile2, pszDest );
}

inline BOOL FileExists(_In_z_ const char* pszPath)
{
	return ::PathFileExistsA( pszPath );
}

inline BOOL FileExists(_In_z_ const wchar_t* pszPath)
{
	return ::PathFileExistsW( pszPath );
}

_Ret_z_ inline char* FindExtension(_In_z_ const char* pszPath)
{
	return ::PathFindExtensionA( pszPath );
}

_Ret_z_ inline wchar_t* FindExtension(_In_z_ const wchar_t* pszPath)
{
	return ::PathFindExtensionW( pszPath );
}

inline char* FindFileName(_In_z_ const char* pszPath)
{
	return ::PathFindFileNameA( pszPath );
}

inline wchar_t* FindFileName(_In_z_ const wchar_t* pszPath)
{
	return ::PathFindFileNameW( pszPath );
}

inline int GetDriveNumber(_In_z_ const char* pszPath)
{
	return ::PathGetDriveNumberA( pszPath );
}

inline int GetDriveNumber(_In_z_ const wchar_t* pszPath)
{
	return ::PathGetDriveNumberW( pszPath );
}

inline BOOL IsDirectory(_In_z_ const char* pszPath)
{
	return ::PathIsDirectoryA( pszPath );
}

inline BOOL IsDirectory(_In_z_ const wchar_t* pszPath)
{
	return ::PathIsDirectoryW( pszPath );
}

inline BOOL IsFileSpec(_In_z_ const char* pszPath)
{
	return ::PathIsFileSpecA( pszPath );
}

inline BOOL IsFileSpec(_In_z_ const wchar_t* pszPath)
{
	return ::PathIsFileSpecW( pszPath );
}

inline BOOL IsPrefix(
	_In_z_ const char* pszPrefix,
	_In_z_ const char* pszPath)
{
	return ::PathIsPrefixA( pszPrefix, pszPath );
}

inline BOOL IsPrefix(
	_In_z_ const wchar_t* pszPrefix,
	_In_z_ const wchar_t* pszPath)
{
	return ::PathIsPrefixW( pszPrefix, pszPath );
}

inline BOOL IsRelative(_In_z_ const char* pszPath)
{
	return ::PathIsRelativeA( pszPath );
}

inline BOOL IsRelative(_In_z_ const wchar_t* pszPath)
{
	return ::PathIsRelativeW( pszPath );
}

inline BOOL IsRoot(_In_z_ const char* pszPath)
{
	return ::PathIsRootA( pszPath );
}

inline BOOL IsRoot(_In_z_ const wchar_t* pszPath)
{
	return ::PathIsRootW( pszPath );
}

inline BOOL IsSameRoot(
	_In_z_ const char* pszPath1,
	_In_z_ const char* pszPath2)
{
	return ::PathIsSameRootA( pszPath1, pszPath2 );
}

inline BOOL IsSameRoot(
	_In_z_ const wchar_t* pszPath1,
	_In_z_ const wchar_t* pszPath2)
{
	return ::PathIsSameRootW( pszPath1, pszPath2 );
}

inline BOOL IsUNC(_In_z_ const char* pszPath)
{
	return ::PathIsUNCA( pszPath );
}

inline BOOL IsUNC(_In_z_ const wchar_t* pszPath)
{
	return ::PathIsUNCW( pszPath );
}

inline BOOL IsUNCServer(_In_z_ const char* pszPath)
{
	return ::PathIsUNCServerA( pszPath );
}

inline BOOL IsUNCServer(_In_z_ const wchar_t* pszPath)
{
	return ::PathIsUNCServerW( pszPath );
}

inline BOOL IsUNCServerShare(_In_z_ const char* pszPath)
{
	return ::PathIsUNCServerShareA( pszPath );
}

inline BOOL IsUNCServerShare(_In_z_ const wchar_t* pszPath)
{
	return ::PathIsUNCServerShareW( pszPath );
}

inline BOOL MakePretty(_Inout_z_cap_c_(MAX_PATH) char* pszPath)
{
	return ::PathMakePrettyA( pszPath );
}

inline BOOL MakePretty(_Inout_z_cap_c_(MAX_PATH) wchar_t* pszPath)
{
	return ::PathMakePrettyW( pszPath );
}

inline BOOL MatchSpec(
	_In_z_ const char* pszPath,
	_In_z_ const char* pszSpec)
{
	return ::PathMatchSpecA( pszPath, pszSpec );
}

inline BOOL MatchSpec(
	_In_z_ const wchar_t* pszPath,
	_In_z_ const wchar_t* pszSpec)
{
	return ::PathMatchSpecW( pszPath, pszSpec );
}

inline void QuoteSpaces(_Inout_z_cap_c_(MAX_PATH) char* pszPath)
{
	::PathQuoteSpacesA( pszPath );
}

inline void QuoteSpaces(_Inout_z_cap_c_(MAX_PATH) wchar_t* pszPath)
{
	::PathQuoteSpacesW( pszPath );
}

inline BOOL RelativePathTo(
	_Out_z_cap_c_(MAX_PATH) char* pszPath,
	_In_z_ const char* pszFrom,
	_In_ DWORD dwAttrFrom,
	_In_z_ const char* pszTo,
	_In_ DWORD dwAttrTo)
{
	return ::PathRelativePathToA( pszPath, pszFrom, dwAttrFrom, pszTo, dwAttrTo );
}

inline BOOL RelativePathTo(
	_Out_z_cap_c_(MAX_PATH) wchar_t* pszPath,
	_In_z_ const wchar_t* pszFrom,
	_In_ DWORD dwAttrFrom,
	_In_z_ const wchar_t* pszTo,
	_In_ DWORD dwAttrTo)
{
	return ::PathRelativePathToW( pszPath, pszFrom, dwAttrFrom, pszTo, dwAttrTo );
}

inline void RemoveArgs(_Inout_z_cap_c_(MAX_PATH) char* pszPath)
{
	::PathRemoveArgsA( pszPath );
}

inline void RemoveArgs(_Inout_z_cap_c_(MAX_PATH) wchar_t* pszPath)
{
	::PathRemoveArgsW( pszPath );
}

inline char* RemoveBackslash(_Inout_z_cap_c_(MAX_PATH) char* pszPath)
{
	return ::PathRemoveBackslashA( pszPath );
}

inline wchar_t* RemoveBackslash(_Inout_z_cap_c_(MAX_PATH) wchar_t* pszPath)
{
	return ::PathRemoveBackslashW( pszPath );
}

inline void RemoveBlanks(_Inout_z_cap_c_(MAX_PATH) char* pszPath)
{
	::PathRemoveBlanksA( pszPath );
}

inline void RemoveBlanks(_Inout_z_cap_c_(MAX_PATH) wchar_t* pszPath)
{
	::PathRemoveBlanksW( pszPath );
}

inline void RemoveExtension(_Inout_z_cap_c_(MAX_PATH) char* pszPath)
{
	::PathRemoveExtensionA( pszPath );
}

inline void RemoveExtension(_Inout_z_cap_c_(MAX_PATH) wchar_t* pszPath)
{
	::PathRemoveExtensionW( pszPath );
}

inline BOOL RemoveFileSpec(_Inout_z_cap_c_(MAX_PATH) char* pszPath)
{
	return ::PathRemoveFileSpecA( pszPath );
}

inline BOOL RemoveFileSpec(_Inout_z_cap_c_(MAX_PATH) wchar_t* pszPath)
{
	return ::PathRemoveFileSpecW( pszPath );
}

inline BOOL RenameExtension(
	_Inout_z_cap_c_(MAX_PATH) char* pszPath,
	_In_z_ const char* pszExt)
{
	return ::PathRenameExtensionA( pszPath, pszExt );
}

inline BOOL RenameExtension(
	_Inout_z_cap_c_(MAX_PATH) wchar_t* pszPath,
	_In_z_ const wchar_t* pszExt)
{
	return ::PathRenameExtensionW( pszPath, pszExt );
}

inline char* SkipRoot(_In_z_ const char* pszPath)
{
	return ::PathSkipRootA( pszPath );
}

inline wchar_t* SkipRoot(_In_z_ const wchar_t* pszPath)
{
	return ::PathSkipRootW( pszPath );
}

inline void StripPath(_Inout_z_cap_c_(MAX_PATH) char* pszPath)
{
	::PathStripPathA( pszPath );
}

inline void StripPath(_Inout_z_cap_c_(MAX_PATH) wchar_t* pszPath)
{
	::PathStripPathW( pszPath );
}

inline BOOL StripToRoot(_Inout_z_cap_c_(MAX_PATH) char* pszPath)
{
	return ::PathStripToRootA( pszPath );
}

inline BOOL StripToRoot(_Inout_z_cap_c_(MAX_PATH) wchar_t* pszPath)
{
	return ::PathStripToRootW( pszPath );
}

inline void UnquoteSpaces(_Inout_z_ char* pszPath)
{
	::PathUnquoteSpacesA( pszPath );
}

inline void UnquoteSpaces(_Inout_z_ wchar_t* pszPath)
{
	::PathUnquoteSpacesW( pszPath );
}

inline BOOL CompactPath(
	_In_ HDC hDC,
	_Inout_z_cap_c_(MAX_PATH) char* pszPath,
	_In_ UINT dx)
{
	return ::PathCompactPathA( hDC, pszPath, dx );
}

inline BOOL CompactPath(
	_In_ HDC hDC,
	_Inout_z_cap_c_(MAX_PATH) wchar_t* pszPath,
	_In_ UINT dx)
{
	return ::PathCompactPathW( hDC, pszPath, dx );
}

inline BOOL CompactPathEx(
	_Out_z_cap_(nMaxChars) char* pszDest,
	_In_z_ const char* pszSrc,
	_In_ UINT nMaxChars,
	_In_ DWORD dwFlags)
{
	return ::PathCompactPathExA( pszDest, pszSrc, nMaxChars, dwFlags );
}

inline BOOL CompactPathEx(
	_Out_z_cap_(nMaxChars) wchar_t* pszDest,
	_In_z_ const wchar_t* pszSrc,
	_In_ UINT nMaxChars,
	_In_ DWORD dwFlags)
{
	return ::PathCompactPathExW( pszDest, pszSrc, nMaxChars, dwFlags );
}

};  // namespace ATLPath

template< typename StringType >
class CPathT
{
public:
	typedef typename StringType::XCHAR XCHAR;
	typedef typename StringType::PCXSTR PCXSTR;
	typedef typename StringType::PXSTR PXSTR;

public:
	CPathT() throw()
	{
	}
	CPathT(_In_ const CPathT< StringType >& path) :
		m_strPath( path.m_strPath )
	{
	}
	CPathT(_In_z_ PCXSTR pszPath) :
		m_strPath( pszPath )
	{
	}

	operator const StringType& () const throw()
	{
		return m_strPath;
	}
	operator StringType& () throw()
	{
		return m_strPath;
	}
	operator PCXSTR() const throw()
	{
		return m_strPath;
	}
	CPathT< StringType >& operator+=(_In_z_ PCXSTR pszMore)
	{
		Append( pszMore );

		return *this;
	}

	void AddBackslash()
	{
		PXSTR pszBuffer = m_strPath.GetBuffer( m_strPath.GetLength()+1 );
		ATLPath::AddBackslash( pszBuffer );
		m_strPath.ReleaseBuffer();
	}
	BOOL AddExtension(_In_z_ PCXSTR pszExtension)
	{
		// If NULL is passed, shlwapi's PathAddExtension API adds ".EXE"
		int nLenExtension = (pszExtension == NULL) ? 4 : StringType::StringLength(pszExtension);
		PXSTR pszBuffer = m_strPath.GetBuffer( m_strPath.GetLength()+nLenExtension);
		BOOL bResult = ATLPath::AddExtension( pszBuffer, pszExtension );
		m_strPath.ReleaseBuffer();

		return bResult;
	}
	BOOL Append(_In_z_ PCXSTR pszMore)
	{
		PXSTR pszBuffer = m_strPath.GetBuffer( m_strPath.GetLength()+StringType::StringLength( pszMore )+1 );
		BOOL bResult = ATLPath::Append( pszBuffer, pszMore );
		m_strPath.ReleaseBuffer();

		return bResult;
	}
	void BuildRoot(_In_ int iDrive)
	{
		ATLASSERT( iDrive >= 0 );
		ATLASSERT( iDrive <= 25 );

		PXSTR pszBuffer = m_strPath.GetBuffer( 3 );
		ATLPath::BuildRoot( pszBuffer, iDrive );
		m_strPath.ReleaseBuffer();
	}
	void Canonicalize()
	{
		StringType strResult;

		PXSTR pszBuffer = strResult.GetBuffer( MAX_PATH );
		ATLPath::Canonicalize( pszBuffer, m_strPath );
		strResult.ReleaseBuffer();

		m_strPath = strResult;
	}
	void Combine(
		_In_z_ PCXSTR pszDir,
		_In_z_ PCXSTR pszFile)
	{
		PXSTR pszBuffer = m_strPath.GetBuffer( MAX_PATH );
		ATLPath::Combine( pszBuffer, pszDir, pszFile );
		m_strPath.ReleaseBuffer();
	}
	CPathT< StringType > CommonPrefix(_In_z_ PCXSTR pszOther)
	{
		CPathT< StringType > pathResult;

		PXSTR pszBuffer = pathResult.m_strPath.GetBuffer( __max( m_strPath.GetLength(), StringType::StringLength( pszOther ) ) );
		int nLength = ATLPath::CommonPrefix( m_strPath, pszOther, pszBuffer );
		pathResult.m_strPath.ReleaseBuffer( nLength );

		return pathResult;
	}
	BOOL CompactPath(
		_In_ HDC hDC,
		_In_ UINT nWidth)
	{
		// PathCompactPath can actually _increase_ the length of the path
		PXSTR pszBuffer = m_strPath.GetBuffer( MAX_PATH );
		BOOL bResult = ATLPath::CompactPath( hDC, pszBuffer, nWidth );
		m_strPath.ReleaseBuffer();

		return bResult;
	}
	BOOL CompactPathEx(
		_In_ UINT nMaxChars,
		_In_ DWORD dwFlags = 0)
	{
		StringType strResult;

		PXSTR pszBuffer = strResult.GetBuffer( nMaxChars );
		BOOL bResult = ATLPath::CompactPathEx( pszBuffer, m_strPath, nMaxChars,
			dwFlags );
		strResult.ReleaseBuffer();

		m_strPath = strResult;

		return bResult;
	}
	BOOL FileExists() const
	{
		return ATLPath::FileExists( m_strPath );
	}
	int FindExtension() const
	{
		PCXSTR pszBuffer = m_strPath;
		PCXSTR pszExtension = ATLPath::FindExtension( pszBuffer );
		if( *pszExtension == 0 )
			return -1;
		else
			return int( pszExtension-pszBuffer );
	}
	int FindFileName() const
	{
		PCXSTR pszBuffer = m_strPath;
		PCXSTR pszFileName = ATLPath::FindFileName( pszBuffer );
		if( *pszFileName == 0 )
			return -1;
		else
			return int( pszFileName-pszBuffer );
	}
	int GetDriveNumber() const
	{
		return ATLPath::GetDriveNumber( m_strPath );
	}
	StringType GetExtension() const
	{
		int iExtension;
		StringType strExtension;

		iExtension = FindExtension();
		if( iExtension != -1 )
			strExtension = m_strPath.Mid( iExtension );

		return strExtension;
	}
	BOOL IsDirectory() const
	{
		return ATLPath::IsDirectory( m_strPath );
	}

	BOOL IsFileSpec() const
	{
		return ATLPath::IsFileSpec( m_strPath );
	}
	BOOL IsPrefix(_In_z_ PCXSTR pszPrefix) const
	{
		return ATLPath::IsPrefix( pszPrefix, m_strPath );
	}
	BOOL IsRelative() const
	{
		return ATLPath::IsRelative( m_strPath );
	}
	BOOL IsRoot() const
	{
		return ATLPath::IsRoot( m_strPath );
	}
	BOOL IsSameRoot(_In_z_ PCXSTR pszOther) const
	{
		return ATLPath::IsSameRoot( m_strPath, pszOther );
	}
	BOOL IsUNC() const
	{
		return ATLPath::IsUNC( m_strPath );
	}
	BOOL IsUNCServer() const
	{
		return ATLPath::IsUNCServer( m_strPath );
	}
	BOOL IsUNCServerShare() const
	{
		return ATLPath::IsUNCServerShare( m_strPath );
	}
	BOOL MakePretty()
	{
		PXSTR pszBuffer = m_strPath.GetBuffer( m_strPath.GetLength() );
		BOOL bResult = ATLPath::MakePretty( pszBuffer );
		m_strPath.ReleaseBuffer();

		return bResult;
	}
	BOOL MatchSpec(_In_z_ PCXSTR pszSpec) const
	{
		return ATLPath::MatchSpec( m_strPath, pszSpec );
	}
	void QuoteSpaces()
	{
		PXSTR pszBuffer = m_strPath.GetBuffer( m_strPath.GetLength()+2 );
		ATLPath::QuoteSpaces( pszBuffer );
		m_strPath.ReleaseBuffer();
	}
	BOOL RelativePathTo(
		_In_z_ PCXSTR pszFrom,
		_In_ DWORD dwAttrFrom,
		_In_z_ PCXSTR pszTo,
		_In_ DWORD dwAttrTo)
	{
		PXSTR pszBuffer = m_strPath.GetBuffer( MAX_PATH );
		BOOL bResult = ATLPath::RelativePathTo( pszBuffer, pszFrom, dwAttrFrom,
			pszTo, dwAttrTo );
		m_strPath.ReleaseBuffer();

		return bResult;
	}
	void RemoveArgs()
	{
		PXSTR pszBuffer = m_strPath.GetBuffer( m_strPath.GetLength() );
		ATLPath::RemoveArgs( pszBuffer );
		m_strPath.ReleaseBuffer();
	}
	void RemoveBackslash()
	{
		PXSTR pszBuffer = m_strPath.GetBuffer( m_strPath.GetLength() );
		ATLPath::RemoveBackslash( pszBuffer );
		m_strPath.ReleaseBuffer();
	}
	void RemoveBlanks()
	{
		PXSTR pszBuffer = m_strPath.GetBuffer( m_strPath.GetLength() );
		ATLPath::RemoveBlanks( pszBuffer );
		m_strPath.ReleaseBuffer();
	}
	void RemoveExtension()
	{
		PXSTR pszBuffer = m_strPath.GetBuffer( m_strPath.GetLength() );
		ATLPath::RemoveExtension( pszBuffer );
		m_strPath.ReleaseBuffer();
	}
	BOOL RemoveFileSpec()
	{
		PXSTR pszBuffer = m_strPath.GetBuffer( m_strPath.GetLength() );
		BOOL bResult = ATLPath::RemoveFileSpec( pszBuffer );
		m_strPath.ReleaseBuffer();

		return bResult;
	}
	BOOL RenameExtension(_In_z_ PCXSTR pszExtension)
	{
		PXSTR pszBuffer = m_strPath.GetBuffer( MAX_PATH );
		BOOL bResult = ATLPath::RenameExtension( pszBuffer, pszExtension );
		m_strPath.ReleaseBuffer();

		return bResult;
	}
	int SkipRoot() const
	{
		PCXSTR pszBuffer = m_strPath;
		PXSTR pszResult = ATLPath::SkipRoot( pszBuffer );

		return int( pszResult-pszBuffer );
	}
	void StripPath()
	{
		PXSTR pszBuffer = m_strPath.GetBuffer( m_strPath.GetLength() );
		ATLPath::StripPath( pszBuffer );
		m_strPath.ReleaseBuffer();
	}
	BOOL StripToRoot()
	{
		PXSTR pszBuffer = m_strPath.GetBuffer( m_strPath.GetLength() );
		BOOL bResult = ATLPath::StripToRoot( pszBuffer );
		m_strPath.ReleaseBuffer();

		return bResult;
	}
	void UnquoteSpaces()
	{
		PXSTR pszBuffer = m_strPath.GetBuffer( m_strPath.GetLength() );
		ATLPath::UnquoteSpaces( pszBuffer );
		m_strPath.ReleaseBuffer();
	}

public:
	StringType m_strPath;
};

typedef CPathT< CString > CPath;
typedef CPathT< CStringA > CPathA;
typedef CPathT< CStringW > CPathW;

};  // namespace ATL
#pragma pack(pop)

#endif  //__ATLPATH_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\include\atlmem.h ===
// This is a part of the Active Template Library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Active Template Library Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Active Template Library product.

#ifndef __ATLMEM_H__
#define __ATLMEM_H__

#pragma once

#include <atlcore.h>
#include <limits.h>


#pragma pack(push,_ATL_PACKING)
namespace ATL
{

template< typename N >
inline N WINAPI AtlAlignUp(
	_In_ N n,
	_In_ ULONG nAlign) throw()
{
	return( N( (n+(nAlign-1))&~(N( nAlign )-1) ) );
}

template< typename N >
inline N WINAPI AtlAlignDown(
	_In_ N n,
	_In_ ULONG nAlign) throw()
{
	return( N( n&~(N( nAlign )-1) ) );
}

__interface __declspec(uuid("654F7EF5-CFDF-4df9-A450-6C6A13C622C0")) IAtlMemMgr
{
public:
	void* Allocate(_In_ size_t nBytes) throw();
	void Free(_Inout_opt_ void* p) throw();
	void* Reallocate(
		_Inout_opt_bytecap_(nBytes) void* p,
		_In_ size_t nBytes) throw();
	size_t GetSize(_In_ void* p) throw();
};

class CCRTHeap :
	public IAtlMemMgr
{
public:
	_Ret_opt_bytecap_(nBytes) virtual void* Allocate(_In_ size_t nBytes) throw()
	{
		return( malloc( nBytes ) );
	}
	virtual void Free(_In_opt_ void* p) throw()
	{
		free( p );
	}
	_Ret_opt_bytecap_(nBytes) virtual void* Reallocate(
		_In_opt_ void* p,
		_In_ size_t nBytes) throw()
	{
		return( realloc( p, nBytes ) );
	}
	virtual size_t GetSize(_In_ void* p) throw()
	{
		return( _msize( p ) );
	}

public:
};

class CWin32Heap :
	public IAtlMemMgr
{
public:
	CWin32Heap() throw() :
		m_hHeap( NULL ),
		m_bOwnHeap( false )
	{
	}
	CWin32Heap(_In_ HANDLE hHeap) throw() :
		m_hHeap( hHeap ),
		m_bOwnHeap( false )
	{
		ATLASSERT( hHeap != NULL );
	}
	CWin32Heap(
			_In_ DWORD dwFlags,
			_In_ size_t nInitialSize,
			_In_ size_t nMaxSize = 0 ) :
		m_hHeap( NULL ),
		m_bOwnHeap( true )
	{
		ATLASSERT( !(dwFlags&HEAP_GENERATE_EXCEPTIONS) );
		m_hHeap = ::HeapCreate( dwFlags, nInitialSize, nMaxSize );
		if( m_hHeap == NULL )
		{
			AtlThrowLastWin32();
		}
	}
	virtual ~CWin32Heap() throw()
	{
		if( m_bOwnHeap && (m_hHeap != NULL) )
		{
			BOOL bSuccess;

			bSuccess = ::HeapDestroy( m_hHeap );
			ATLASSERT( bSuccess );
		}
	}

	void Attach(
		_In_ HANDLE hHeap,
		_In_ bool bTakeOwnership) throw()
	{
		ATLASSERT( hHeap != NULL );
		ATLASSUME( m_hHeap == NULL );

		m_hHeap = hHeap;
		m_bOwnHeap = bTakeOwnership;
	}
	HANDLE Detach() throw()
	{
		HANDLE hHeap;

		hHeap = m_hHeap;
		m_hHeap = NULL;
		m_bOwnHeap = false;

		return( hHeap );
	}

// IAtlMemMgr
	_Ret_opt_bytecap_(nBytes) virtual void* Allocate(_In_ size_t nBytes) throw()
	{
		return( ::HeapAlloc( m_hHeap, 0, nBytes ) );
	}
	virtual void Free(_In_opt_ void* p) throw()
	{
		if( p != NULL )
		{
			BOOL bSuccess;

			bSuccess = ::HeapFree( m_hHeap, 0, p );
			ATLASSERT( bSuccess );
		}
	}
	_Ret_opt_bytecap_(nBytes) virtual void* Reallocate(
		_In_opt_ void* p,
		_In_ size_t nBytes) throw()
	{
		if( p == NULL )
		{
			return( Allocate( nBytes ) );
		}

		if (nBytes==0)
		{
			  Free(p);
			  return NULL;
		}

		return( ::HeapReAlloc( m_hHeap, 0, p, nBytes ) );
	}
	virtual size_t GetSize(_Inout_ void* p) throw()
	{
		return( ::HeapSize( m_hHeap, 0, p ) );
	}

public:
	HANDLE m_hHeap;
	bool m_bOwnHeap;
};

class CLocalHeap :
	public IAtlMemMgr
{
// IAtlMemMgr
public:
	_Ret_opt_bytecap_(nBytes) virtual void* Allocate(_In_ size_t nBytes) throw()
	{
		return( ::LocalAlloc( LMEM_FIXED, nBytes ) );
	}
	virtual void Free(_In_opt_ void* p) throw()
	{
		::LocalFree( p );
	}
	_Ret_opt_bytecap_(nBytes) virtual void* Reallocate(
		_In_opt_ void* p,
		_In_ size_t nBytes) throw()
	{
		if (p==NULL)
		{
			return ( Allocate(nBytes) );
		}
		if (nBytes==0)
		{
			Free(p);
			return NULL;
		}

		return SAL_Assume_bytecap_for_opt_(::LocalReAlloc(p, nBytes, 0), nBytes);
	}
	virtual size_t GetSize(_In_ void* p) throw()
	{
		return( ::LocalSize( p ) );
	}
};

class CGlobalHeap :
	public IAtlMemMgr
{
// IAtlMemMgr
public:
	_Ret_opt_bytecap_(nBytes) virtual void* Allocate(_In_ size_t nBytes) throw()
	{
		return( ::GlobalAlloc( LMEM_FIXED, nBytes ) );
	}
	virtual void Free(_In_opt_ void* p) throw()
	{
		::GlobalFree( p );
	}
	_Ret_opt_bytecap_(nBytes) virtual void* Reallocate(
		_In_opt_ void* p,
		_In_ size_t nBytes) throw()
	{
		if (p==NULL)
		{
			return ( Allocate(nBytes) );
		}
		if (nBytes==0){
			Free(p);
			return NULL;
		}
		return SAL_Assume_bytecap_for_opt_(::GlobalReAlloc( p, nBytes, 0 ), nBytes);
	}
	virtual size_t GetSize(_In_ void* p) throw()
	{
		return( ::GlobalSize( p ) );
	}
};

};  // namespace ATL
#pragma pack(pop)

#ifdef _OBJBASE_H_
#include <atlcommem.h>
#endif	// _OBJBASE_H_

#endif  //__ATLMEM_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\include\atlrc.h ===
// This is a part of the Active Template Library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Active Template Library Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Active Template Library product.

#pragma once

#ifndef __ATLRC_H__

#define ATL_RESID_BASE						0xD800
#define ATL_STRING_BASE						ATL_RESID_BASE

#define ATL_IDS_DATETIME_INVALID			(ATL_STRING_BASE + 0)
#define ATL_IDS_DATETIMESPAN_INVALID		(ATL_STRING_BASE + 1)

#define ATL_SERVICE_MANAGER_OPEN_ERROR		(ATL_STRING_BASE + 10)
#define ATL_SERVICE_START_ERROR				(ATL_STRING_BASE + 11)
#define ATL_SERVICE_OPEN_ERROR				(ATL_STRING_BASE + 12)
#define ATL_SERVICE_DELETE_ERROR			(ATL_STRING_BASE + 13)
#define ATL_SERVICE_STOP_ERROR				(ATL_STRING_BASE + 14)

#endif	// __ATLRC_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\include\atlpreviewctrlimpl.h ===
// This is a part of the Active Template Library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Active Template Library Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Active Template Library product.

#include <atlwin.h>
#include <atlhandler.h>

#pragma once

#ifndef __cplusplus
#error ATL requires C++ compilation (use a .cpp suffix)
#endif

#pragma pack(push,_ATL_PACKING)
namespace ATL
{
/// <summary>
/// This class is an ATL implementation of a window that is placed on a host window provided by the Shell
/// for Rich Preview. </summary>
class CAtlPreviewCtrlImpl :
	public CWindowImpl<CAtlPreviewCtrlImpl>,
	public IPreviewCtrl
{
public:
	BEGIN_MSG_MAP(CAtlPreviewCtrlImpl)
		MESSAGE_HANDLER(WM_PAINT, OnPaint)
	END_MSG_MAP()

	/// <summary>
	/// Constructs a preview control object.</summary>
	CAtlPreviewCtrlImpl(void) : m_clrText(0), m_clrBack(RGB(255, 255, 255)), m_plf(NULL)
	{
	}

	/// <summary>
	/// Destructs a preview control object.</summary>
	virtual ~CAtlPreviewCtrlImpl(void)
	{
	}
	/// <summary>Handles WM_PAINT message.</summary>
	/// <param name="nMsg">Set to WM_PAINT.</param>
	/// <param name="wParam">This parameter is not used. </param>
	/// <param name="lParam">This parameter is not used. </param>
	/// <param name="bHandled">When this function returns it contains TRUE.</param>
	/// <returns> Always returns 0.</returns>
	LRESULT OnPaint(
		_In_ UINT nMsg,
		_In_ WPARAM wParam,
		_In_ LPARAM lParam,
		_Out_ BOOL& bHandled)
	{
		UNREFERENCED_PARAMETER(nMsg);
		UNREFERENCED_PARAMETER(wParam);
		UNREFERENCED_PARAMETER(lParam);

		PAINTSTRUCT ps;
		BeginPaint(&ps);
		DoPaint(ps.hdc);
		EndPaint(&ps);

		bHandled = TRUE;

		return 0;
	}

	/// <summary>
	/// Called by a Rich Preview handler to create the Windows window. </summary>
	/// <param name="hWndParent"> A handle to the host window supplied by the Shell for Rich Preview. </param>
	/// <param name="prc"> Specifies initial size and position of the window. </param>
	/// <returns>TRUE if creation succeeded; otherwise FALSE.</returns>
	virtual BOOL Create(
		_In_ HWND hWndParent,
		_In_ const RECT* prc)
	{
		_U_RECT rect((LPRECT)prc);
		CWindowImpl<CAtlPreviewCtrlImpl>::Create(hWndParent, rect);
		return TRUE;
	}
	/// <summary>
	/// Called by a Rich Preview handler when it needs to destroy this control.</summary>
	virtual void Destroy()
	{
		CWindowImpl<CAtlPreviewCtrlImpl>::DestroyWindow();
	}
	/// <summary>
	/// Sets a new parent for this control. </summary>
	/// <param name="hWndParent">A handle to the new parent window.</param>
	virtual void SetHost(_In_ HWND hWndParent)
	{
		CWindowImpl<CAtlPreviewCtrlImpl>::SetParent(hWndParent);
	}
	/// <summary>
	/// Sets input focus to this control. </summary>
	virtual void Focus()
	{
		CWindowImpl<CAtlPreviewCtrlImpl>::SetFocus();
	}
	/// <summary>
	/// Tells this control to redraw. </summary>
	virtual void Redraw()
	{
		CWindowImpl<CAtlPreviewCtrlImpl>::RedrawWindow();
	}
	/// <summary>
	/// Sets a new bounding rectangle for this control. </summary>
	/// <remarks> Usually new bounding rectangle is set when the host control is resized.</remarks>
	/// <param name="prc">Specifies the new size and position of preview control.</param>
	/// <param name="bRedraw">Specifies whether the control should be redrawn.</param>
	virtual void SetRect(
		_In_ const RECT* prc,
		_In_ BOOL bRedraw)
	{
		DWORD dwFlags = SWP_NOZORDER;
		if (!bRedraw)
		{
			dwFlags |= SWP_NOREDRAW;
		}
		SetWindowPos(NULL, prc, dwFlags);
	}
	/// <summary>
	/// Called by a Rich Preview handler when it needs to set visuals of rich preview content.</summary>
	/// <param name="clrBack"> Background color of preview window. </param>
	/// <param name="clrText"> Text color of preview window. </param>
	/// <param name="plf"> Font used to display texts in preview window. </param>
	virtual void SetPreviewVisuals(
		_In_ COLORREF clrBack,
		_In_ COLORREF clrText,
		_In_ const LOGFONTW *plf)
	{
		m_clrText = clrText;
		m_clrBack = clrBack;
		m_plf = plf;
	}

protected:
	/// <summary> Called by the framework to render the preview.</summary>
	/// <param name="hdc">A handle to a device context for painting.</par
	virtual void DoPaint(_In_ HDC hdc)
	{
		CString str = _T("Override CAtlPreviewCtrlImpl::DoPaint in a derived class for painting.");
		TextOut(hdc, 0, 0, str, str.GetLength());
	}

protected:
	/// <summary> Text color of preview window. </summary>
	COLORREF m_clrText;
	/// <summary> Background color of preview window. </summary>
	COLORREF m_clrBack;
	/// <summary> Font used to display texts in preview window. </summary>
	const LOGFONTW* m_plf;
};
} //namespace ATL
#pragma pack(pop)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\include\atlplus.h ===
// This is a part of the Visual C++ COM Library
// Copyright (C) Microsoft Corporation
// All rights reserved.

#ifndef __ATLPLUS_H__
#define __ATLPLUS_H__

#pragma once

#ifndef __cplusplus
	#error The Visual C++ COM Library requires C++ compilation (use a .cpp suffix)
#endif

#include <shellapi.h>
#include "atlevent.h"
#include <atlstr.h>
//Avoid using <atlstr.h> except in the registry templates (for circular dependencies).

[
	provider(name="ATL4", uuid="BC6B4B8A-0E4A-4bc9-B319-9DC2ACFB61EE")
];


#pragma pack(push,_ATL_PACKING)
namespace ATL
{

// Registry

#define rgsopEndOfStream 0
#define rgsopAddKeyNoRemove  1
#define rgsopAddKeyForceRemove 2
#define rgsopAddKey 3
#define rgsopDeleteKey 4
#define rgsopOpenAsParent 5
#define rgsopCloseAsParent 6
#define rgsopOpenRootKey 7
#define rgsopAddStringValue 8
#define rgsopAddMultiStringValue 9
#define rgsopAddDWORDValue 10
#define rgsopAddBinaryValue 11

struct RGSStrings
{
	LPTSTR sz;
	BYTE bHasReplacement;
};
struct RGSDWORD
{
	DWORD dwValueOrIndex;
	BYTE bHasReplacement;
};
struct RGSBinary
{
	BYTE* pBytes;
	DWORD dwLenOrIndex;
	BYTE bHasReplacement;
};

typedef DWORD RGSOps;

enum RDXOperations
{
	eReadFromReg,
	eWriteToReg,
	eDeleteFromReg
};

class CVMExpansionVector :
	public CSimpleMap<LPTSTR, LPTSTR>
{
public:
	int FindKey(_In_ _Deref_prepost_z_ LPTSTR& key) const
	{
		for(int i = 0; i < m_nSize; i++)
		{
			if (lstrcmpi(m_aKey[i],key) == 0)
				return i;
		}
		return -1;  // not found
	}
	int FindVal(_In_ _Deref_prepost_z_ LPTSTR& val) const
	{
		for(int i = 0; i < m_nSize; i++)
		{
			if (lstrcmpi(m_aVal[i],val) == 0)
				return i;
		}
		return -1;  // not found
	}

	LPTSTR Lookup(_In_z_ LPTSTR key) const
	{
		int nIndex = FindKey(key);
		if(nIndex == -1)
			return NULL;    // must be able to convert
		return GetValueAt(nIndex);
	}
};


class CRegistryVirtualMachine :
	public IRegistrarBase
{
public:
ATLPREFAST_SUPPRESS(6387)
	HRESULT STDMETHODCALLTYPE QueryInterface(
		_In_ const IID &riid,
		_Deref_out_ void** ppv)
	{
		if (ppv == NULL)
			return E_POINTER;
		*ppv = NULL;
		if (IsEqualGUID(riid, __uuidof(IUnknown)) || IsEqualGUID(riid, __uuidof(IRegistrarBase)) )
		{
			*ppv = this;
			return S_OK;
		}
		return E_NOINTERFACE;
	}
ATLPREFAST_UNSUPPRESS()
	
	ULONG STDMETHODCALLTYPE AddRef(void)
	{
		return 1L;
	}

	ULONG STDMETHODCALLTYPE Release(void)
	{
		return 1L;
	}

#ifndef _UNICODE
	virtual HRESULT STDMETHODCALLTYPE AddReplacement(
		_In_z_ LPCOLESTR key,
		_In_z_ LPCOLESTR item)
	{
		HRESULT hr = E_OUTOFMEMORY;
		_ATLTRY
		{
			hr = AddReplacement(COLE2T(key), COLE2T(item));
		}
		_ATLCATCHALL()
		{
		}
		return hr;
	}
#endif

public:
	virtual ~CRegistryVirtualMachine() throw()
	{
		ClearReplacements();
	}

	// Operations
	HRESULT AddStandardReplacements() throw()
	{
		USES_CONVERSION_EX;

		TCHAR szModule[MAX_PATH];
		HINSTANCE hInst = _AtlBaseModule.GetModuleInstance();
		DWORD dwFLen = GetModuleFileName(hInst , szModule, MAX_PATH);
		if( dwFLen == 0 )
			return AtlHresultFromLastError();
		else if( dwFLen == MAX_PATH )
			return HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER);

		HRESULT hr;
		if ((hInst == NULL) || (hInst == GetModuleHandle(NULL))) // register as EXE
		{
			// If Registering as an EXE, then we quote the resultant path.
			// We don't do it for a DLL, because LoadLibrary fails if the path is
			// quoted
			TCHAR szModuleQuote[_MAX_PATH + _ATL_QUOTES_SPACE];
			szModuleQuote[0] = _T('\"');
			Checked::tcscpy_s(szModuleQuote + 1, _countof(szModuleQuote) - 1, szModule);
			int nLen = lstrlen(szModuleQuote);
			szModuleQuote[nLen] = _T('\"');
			szModuleQuote[nLen + 1] = 0;
			hr = AddReplacement(_T("Module"), szModuleQuote);
		}
		else
		{
			hr= AddReplacement(_T("Module"), szModule);
		}

		if(FAILED(hr))
			return hr;

		hr = AddReplacement(_T("Module_Raw"), szModule);
		if(FAILED(hr))
			return hr;

		OLECHAR* sz;
		hr = StringFromCLSID(CAtlModule::m_libid, &sz);
		if (FAILED(hr))
			return hr;
		
		LPCTSTR pszModuleGUID = OLE2T_EX_DEF(sz);
		ATLASSUME(pszModuleGUID != NULL);
		hr = AddReplacement(_T("MODULEGUID"), pszModuleGUID);
		CoTaskMemFree(sz);
		if (FAILED(hr))
			return hr;
		SHFILEINFO shf;
		if (SHGetFileInfo(szModule, 0, &shf, sizeof(shf), SHGFI_EXETYPE) == 0)
			hr = AddReplacement(_T("MODULETYPE"), _T("InprocServer32"));
		else
			hr = AddReplacement(_T("MODULETYPE"), _T("LocalServer32"));

		if (SUCCEEDED(hr))
			hr = _pAtlModule->AddCommonRGSReplacements(this);
		return hr;
	}

	virtual HRESULT STDMETHODCALLTYPE AddReplacement(
		_In_z_ LPCTSTR lpszKey,
		_In_z_ LPCTSTR lpszItem) throw()
	{
		ATLASSERT(lpszKey != NULL && lpszItem != NULL);
		if (lpszKey == NULL || lpszItem == NULL)
			return E_INVALIDARG;

		HRESULT hr = E_OUTOFMEMORY; // If any of the new's fail.

		m_csMap.Lock();
		DWORD cch = lstrlen(lpszKey) + 1;
		CAutoVectorPtr<TCHAR> szNewKey;
		if (szNewKey.Allocate(cch))
		{
			Checked::tcscpy_s(szNewKey, cch, lpszKey);
			cch = lstrlen(lpszItem) + 1;
			CAutoVectorPtr<TCHAR> szNewItem;
			if (szNewItem.Allocate(cch))
			{
				Checked::tcscpy_s(szNewItem, cch, lpszItem);
				if (m_RepMap.Add(szNewKey, szNewItem))
				{
					hr = S_OK;
					szNewKey.Detach();
					szNewItem.Detach();
				}
			}
		}
		m_csMap.Unlock();
		return hr;
	}

	HRESULT STDMETHODCALLTYPE ClearReplacements() throw()
	{
		m_csMap.Lock();
		HRESULT hr = S_OK;
		for (int i = 0; i < m_RepMap.GetSize(); i++)
		{
			delete [] m_RepMap.m_aKey[i];
			delete [] m_RepMap.m_aVal[i];
		}
		m_RepMap.RemoveAll();
		m_csMap.Unlock();
		return hr;
	}

	HRESULT VMUpdateRegistry(
		_In_ RGSOps* pOps,
		_In_opt_ RGSStrings* rgStrings,
		_In_opt_ RGSDWORD* rgDWORDS,
		_In_opt_ RGSBinary *rgBinary,
		_In_ BOOL bRegister) throw()
	{
        ATLASSERT(pOps != NULL && rgStrings != NULL);
        if (pOps == NULL || rgStrings == NULL)
            return E_INVALIDARG;
        HRESULT hr = S_OK;

        // Handle multiple ROOT keys in the RGS file.
        while ( SUCCEEDED(hr) && *pOps != 0 )
        {
            DWORD code, p1, p2;
            GetOpsFromDWORD(*pOps, code, p1, p2);

            if (code != rgsopOpenRootKey)
            {
                ATLASSERT(FALSE); // Bad parse tree
                return E_FAIL;
            }
            HKEY hKeyBase = (( HKEY ) (ULONG_PTR)((LONG)(p1 | 0x80000000)));
            pOps++;
            hr = VMUpdateRegistryRecurse(hKeyBase, pOps, rgStrings, rgDWORDS, rgBinary, bRegister);
        }
        return hr;
	}

	// Implementation
	inline BYTE ChToByte(_In_ const TCHAR ch)
	{
		switch (ch)
		{
			case '0':
			case '1':
			case '2':
			case '3':
			case '4':
			case '5':
			case '6':
			case '7':
			case '8':
			case '9':
					return (BYTE) (ch - '0');
			case 'A':
			case 'B':
			case 'C':
			case 'D':
			case 'E':
			case 'F':
					return (BYTE) (10 + (ch - 'A'));
			case 'a':
			case 'b':
			case 'c':
			case 'd':
			case 'e':
			case 'f':
					return (BYTE) (10 + (ch - 'a'));
			default:
					ATLASSERT(FALSE);
					ATLTRACE(atlTraceRegistrar, 0, _T("Bogus value %c passed as binary Hex value\n"), ch);
					return 0;
		}
	}

	HRESULT GetStringAtLoc(
		_In_ RGSStrings* rgStrings,
		_In_ DWORD iLoc,
		_Inout_ CSimpleArray<TCHAR>& rgBytes,
		_In_ _Deref_prepost_opt_z_ LPTSTR* pszCur) throw()
	{
		if (pszCur == NULL)
			return E_INVALIDARG;

		LPTSTR& szCur = *pszCur;
		szCur = rgStrings[iLoc].sz;
		if (szCur == NULL)
			return S_FALSE;

		if (rgStrings[iLoc].bHasReplacement)
		{
			rgBytes.RemoveAll();
			LPCTSTR szTemp = szCur;
			szCur = NULL;
			while (*szTemp != NULL) // look for end
			{
				if (*szTemp == _T('%'))
				{
					szTemp = CharNext(szTemp);
					if (*szTemp == _T('%'))
						rgBytes.Add(*szTemp);
					else
					{
						LPCTSTR lpszNext = AtlstrchrT(szTemp, _T('%'));
						if (lpszNext == NULL)
						{
							ATLTRACE(atlTraceRegistrar, 0, _T("Error : closing '%%' found\n"));
							return E_FAIL;
						}
						int nLength = (int)(INT_PTR)(lpszNext - szTemp);
						if (nLength > 31)
							return E_FAIL;
						TCHAR buf[32];
						Checked::tcsncpy_s(buf, _countof(buf), szTemp, nLength);
						LPTSTR lpszVar = m_RepMap.Lookup(buf);
						if (lpszVar == NULL)
							return E_FAIL;
						for (int iMapped = 0; lpszVar[iMapped] != NULL; iMapped++)
							rgBytes.Add(lpszVar[iMapped]);
						szTemp = lpszNext;
					}
				}
				else
					rgBytes.Add(*szTemp);
				szTemp = CharNext(szTemp);
			}
			rgBytes.Add(*szTemp);
		}
		return S_OK;
	}
	HRESULT GetDWORDAtLoc(
		_In_ RGSDWORD* rgDWORDS,
		_In_ DWORD iLoc,
		_Out_ DWORD& dwValueOrIndex) throw()
	{
		dwValueOrIndex = rgDWORDS[iLoc].dwValueOrIndex;
		return rgDWORDS[iLoc].bHasReplacement == TRUE ? S_FALSE : S_OK;
	}

	HRESULT GetBinaryAtLoc(
		_In_ RGSBinary* rgBinary,
		_In_ DWORD iLoc,
		_Deref_out_ BYTE** ppValue,
		_Out_ DWORD* pdwLen) throw()
	{
		*ppValue = rgBinary[iLoc].pBytes;
		*pdwLen = rgBinary[iLoc].dwLenOrIndex;
		return rgBinary[iLoc].bHasReplacement == TRUE ? S_FALSE : S_OK;
	}

	HRESULT DeleteKeyWithReplacement(
		_In_ HKEY hKeyParent,
		_In_ DWORD iString,
		_In_ RGSStrings* rgStrings) throw()
	{
		CRegKey rkForceRemove;
		CSimpleArray<TCHAR> rgBytes;
		LPTSTR szReplacement = NULL;
		HRESULT hr = GetStringAtLoc(rgStrings, (DWORD)iString, rgBytes, &szReplacement);
		if (FAILED(hr))
			return hr;
		rkForceRemove.Attach(hKeyParent);
		LONG lRet = ERROR_FILE_NOT_FOUND;
		if (hKeyParent)
			lRet = rkForceRemove.RecurseDeleteKey((szReplacement) ? szReplacement : rgBytes.m_aT);
		if (lRet != ERROR_SUCCESS && lRet != ERROR_FILE_NOT_FOUND && lRet != ERROR_PATH_NOT_FOUND)
		{
			ATLTRACE(atlTraceRegistrar, 0, _T("Failed to delete key %s or one of its subkeys\n"),
				(szReplacement) ? szReplacement : rgBytes.m_aT);
			hr = AtlHresultFromWin32(lRet);
		}
		rkForceRemove.Detach();
		return hr;
	}

	HRESULT AddKeyWithReplacement(
		_In_ HKEY hKeyParent,
		_Inout_ CRegKey& rkCur,
		_In_ DWORD iString,
		_In_ RGSStrings* rgStrings) throw()
	{
		LPTSTR szReplacement = NULL;
		CSimpleArray<TCHAR> rgBytes;
		HRESULT hr = GetStringAtLoc(rgStrings, (DWORD)iString, rgBytes, &szReplacement);
		if (FAILED(hr))
			return hr;

		if (rkCur.Open(hKeyParent, (szReplacement) ? szReplacement : rgBytes.m_aT,
					   KEY_READ | KEY_WRITE) != ERROR_SUCCESS)
		{
			LONG lRes = rkCur.Create(hKeyParent, (szReplacement) ? szReplacement : rgBytes.m_aT, REG_NONE, REG_OPTION_NON_VOLATILE , KEY_READ | KEY_WRITE);
			if (lRes != ERROR_SUCCESS)
				return AtlHresultFromWin32(lRes);
		}
		return S_OK;
	}

	HRESULT VMUpdateRegistryRecurse(
		_In_ HKEY hKeyParent,
		_In_ RGSOps*& pOps,
		_In_opt_ RGSStrings* rgStrings,
		_In_opt_ RGSDWORD* rgDWORDS,
		_In_opt_ RGSBinary *rgBinary,
		_In_ BOOL bRegister) throw()
	{
		CRegKey  rkCur;
		LONG     lRes = ERROR_SUCCESS;
		HRESULT  hr = S_OK;
		bool bNoRemove = false;
		RGSOps opParent = 0;
		DWORD code, p1, p2;
		USES_CONVERSION_EX;

		GetOpsFromDWORD(*pOps, code, p1, p2);
		while (code != rgsopCloseAsParent)
		{
			switch(code)
			{
			case rgsopEndOfStream:
				return S_OK;
			case rgsopAddKeyNoRemove:
				bNoRemove = true;
				if (bRegister)
				{
					hr = AddKeyWithReplacement(hKeyParent, rkCur, p1, rgStrings);
					if (FAILED(hr))
						return hr;
				}
				pOps++; // NoRemove means do nothing during Unreg
				GetOpsFromDWORD(*pOps, code, p1, p2);
				break;
			case rgsopAddKeyForceRemove:
				if (bRegister)
				{
					hr = DeleteKeyWithReplacement(hKeyParent, p1, rgStrings);
					if (FAILED(hr))
						return hr;
				}
				// fall through to normal add functionality
			case rgsopAddKey:
			{
				if (!bRegister)
				{
					LPTSTR szReplacement = NULL;
					CSimpleArray<TCHAR> rgBytes;
					hr = GetStringAtLoc(rgStrings, p1, rgBytes, &szReplacement);
					if (FAILED(hr))
						return hr;

					lRes = ERROR_FILE_NOT_FOUND;
					if (hKeyParent)
						lRes = rkCur.Open(hKeyParent, (szReplacement) ? szReplacement : rgBytes.m_aT, KEY_READ | KEY_WRITE);
					if (lRes != ERROR_SUCCESS && lRes != ERROR_FILE_NOT_FOUND)
						return AtlHresultFromWin32(lRes); // Ignore if it is not in the registry and continue.
					opParent = *pOps; // remember this for the delete
				}
				else
				{
					hr = AddKeyWithReplacement(hKeyParent, rkCur, p1, rgStrings);
					if (FAILED(hr))
						return hr;
				}
				pOps++;
				GetOpsFromDWORD(*pOps, code, p1, p2);
				break;
			}
			case rgsopDeleteKey:
				ATLASSERT(FALSE); // Not yet implemented
				break;
			case rgsopOpenAsParent:
				pOps++;
				hr = VMUpdateRegistryRecurse(rkCur.m_hKey, pOps, rgStrings, rgDWORDS, rgBinary, bRegister);
				if (FAILED(hr))
					return hr;
				GetOpsFromDWORD(*pOps, code, p1, p2);
				if (!bRegister)
				{
					if (!bNoRemove)
					{
						DWORD codeTemp, p1Temp, p2Temp;
						GetOpsFromDWORD(opParent, codeTemp, p1Temp, p2Temp);
						hr = DeleteKeyWithReplacement(hKeyParent, p1Temp, rgStrings);
						if (FAILED(hr))
							return hr;
					}
					else
						bNoRemove = false; // turn it back off
				}
				break;
			case rgsopCloseAsParent:
				ATLASSERT(FALSE); // Should never get here it is the governing loop constraint
				return E_FAIL;
			case rgsopOpenRootKey:
			{
				HKEY hKeyBase = (( HKEY ) (ULONG_PTR)((LONG)(p1 | 0x80000000)));
				pOps++;
				return VMUpdateRegistryRecurse(hKeyBase, pOps, rgStrings, rgDWORDS, rgBinary, bRegister);
				break;
			}
			case rgsopAddStringValue:
			{
				if (bRegister)
				{
					bool bRestoreRK = false;
					if (rkCur.m_hKey == NULL)
					{
						rkCur.m_hKey = hKeyParent;
						bRestoreRK = true;
					}
					CSimpleArray<TCHAR> rgBytes, rgBytes2;
					LPTSTR szReplacement = NULL;
					LPTSTR szReplacement2 = NULL;
					hr = GetStringAtLoc(rgStrings, p2, rgBytes, &szReplacement);
					if (SUCCEEDED(hr) && p1 != 0)
						hr = GetStringAtLoc(rgStrings, p1, rgBytes2, &szReplacement2);

					CRegKey key;
					if (p1 == 0)
						key.m_hKey = rkCur.m_hKey;
					else
						key.m_hKey = hKeyParent;
					lRes = key.SetStringValue((p1 != 0) ? ((szReplacement2) ? szReplacement2 : rgBytes2.m_aT) : NULL,
						(szReplacement) ? szReplacement : rgBytes.m_aT);
					key.m_hKey = NULL;
					if (ERROR_SUCCESS != lRes)
						return AtlHresultFromWin32(lRes);
					if (bRestoreRK)
						rkCur.m_hKey = NULL;
					ATLTRACE(atlTraceRegistrar, 2, _T("Setting Value %s at %s\n"), (szReplacement) ? szReplacement : rgBytes.m_aT, (p1 != 0) ? (szReplacement2) ? szReplacement2 : rgBytes2.m_aT : _T("default"));
				}
				pOps++;
				GetOpsFromDWORD(*pOps, code, p1, p2);
				break;
			}
			case rgsopAddMultiStringValue:
			{
				if (bRegister)
				{
					bool bRestoreRK = false;
					if (rkCur.m_hKey == NULL)
					{
						rkCur.m_hKey = hKeyParent;
						bRestoreRK = true;
					}
					CSimpleArray<TCHAR> rgBytes, rgBytes2;
					LPTSTR szReplacement = NULL;
					LPTSTR szReplacement2 = NULL;
					hr = GetStringAtLoc(rgStrings, p2, rgBytes, &szReplacement);
					if (SUCCEEDED(hr) && p1 != 0)
						hr = GetStringAtLoc(rgStrings, p1, rgBytes2, &szReplacement2);

					ATLTRACE(atlTraceRegistrar, 2, _T("Setting Value %s at %s\n"), (szReplacement) ? szReplacement : rgBytes.m_aT, (p1 != 0) ? (szReplacement2) ? szReplacement2 : rgBytes2.m_aT : _T("default"));

					TCHAR* pszValue = (szReplacement) ? szReplacement : rgBytes.m_aT;
					int nLen = lstrlen(pszValue) + 2; //Allocate space for double null termination.
					CTempBuffer <TCHAR, 1024> pszDestValue;
					//nLen should be >= the max size of the target buffer.
					ATLTRY(pszDestValue.Allocate(nLen));
					if (pszDestValue != NULL)
					{
						TCHAR* p = pszDestValue;
						TCHAR* q = pszValue;
						nLen = 0;
						while (*q != _T('\0'))
						{
							TCHAR* r = CharNext(q);
							if (*q == '\\' && *r == '0')
							{
								*p++ = NULL;
								q = CharNext(r);
							}
							else
							{
								*p = *q;
		#ifndef _UNICODE
								if (IsDBCSLeadByte(*q))
								{
									p++;
									q++;
									 //Protect from Lead byte followed by the zero terminator.May skip beyond the end of the string.
									if (*q == _T('\0')) { break; }
									*p = *q;
								}
		#endif
								p++;
								q++;
							}
							nLen ++;
						}
					    //Always terminate with 2 NULLs.
					    *p = NULL;
						p++;
						*p = NULL;


						CRegKey key;
						if (p1 == 0)
							key.m_hKey = rkCur.m_hKey;
						else
						key.m_hKey = hKeyParent;
						lRes = key.SetMultiStringValue((p1 != 0) ? ((szReplacement2) ? szReplacement2 : rgBytes2.m_aT) : NULL,
							pszDestValue);
						key.m_hKey = NULL;
						if (ERROR_SUCCESS != lRes)
							return AtlHresultFromWin32(lRes);
						if (bRestoreRK)
							rkCur.m_hKey = NULL;
					}
					else
					{
						return E_OUTOFMEMORY;
					}
				}
				pOps++;
				GetOpsFromDWORD(*pOps, code, p1, p2);
				break;
			}

			case rgsopAddDWORDValue:
			{
				if (bRegister)
				{
					bool bRestoreRK = false;
					if (rkCur.m_hKey == NULL)
					{
						rkCur.m_hKey = hKeyParent;
						bRestoreRK = true;
					}
					CSimpleArray<TCHAR> rgBytes, rgBytes2;
					LPTSTR szReplacement = NULL;
					LPTSTR szReplacement2 = NULL;
					DWORD dwValue;
					hr = GetDWORDAtLoc(rgDWORDS, p2, dwValue);
					if (hr == S_FALSE)
					{
						GetStringAtLoc(rgStrings, dwValue, rgBytes, &szReplacement);
						CStringW strW(szReplacement ? szReplacement : rgBytes.m_aT);
						hr = VarUI4FromStr(const_cast<wchar_t *>(static_cast<const wchar_t *>(strW)), 0, 0, &dwValue);
						if (FAILED(hr))
						{
							// Replacement value exceeds max DWORD value
							return E_FAIL;
						}
					}

					if (SUCCEEDED(hr) && p1 != 0)
						hr = GetStringAtLoc(rgStrings, p1, rgBytes2, &szReplacement2);

					CRegKey key;
					if (p1 == 0)
						key.m_hKey = rkCur.m_hKey;
					else
						key.m_hKey = hKeyParent;
					lRes = key.SetDWORDValue((szReplacement2) ? szReplacement2 : rgBytes2.m_aT,
						dwValue);
					key.m_hKey = NULL;
					if (ERROR_SUCCESS != lRes)
						return AtlHresultFromWin32(lRes);
					if (bRestoreRK)
						rkCur.m_hKey = NULL;
					ATLTRACE(atlTraceRegistrar, 2, _T("Setting Value %s at %s\n"), (szReplacement) ? szReplacement : rgBytes.m_aT, (p1 != 0) ? (szReplacement2) ? szReplacement2 : rgBytes2.m_aT : _T("default"));
				}
				pOps++;
				GetOpsFromDWORD(*pOps, code, p1, p2);
				break;
			}
			case rgsopAddBinaryValue:
			{
				if (bRegister)
				{
					bool bRestoreRK = false;
					if (rkCur.m_hKey == NULL)
					{
						rkCur.m_hKey = hKeyParent;
						bRestoreRK = true;
					}
					CSimpleArray<TCHAR> rgBytes, rgBytes2;
					LPTSTR szReplacement = NULL;
					LPTSTR szReplacement2 = NULL;
					BYTE* pByte;
					CTempBuffer <BYTE, 1024> pByteTemp;
					DWORD dwLen;
					hr = GetBinaryAtLoc(rgBinary, p2, &pByte, &dwLen);
					if (hr == S_FALSE)
					{
						GetStringAtLoc(rgStrings, dwLen, rgBytes, &szReplacement);
						if (szReplacement == NULL)
						{
							szReplacement = rgBytes.m_aT;
						}
						int cbValue = lstrlen(szReplacement);
						if (cbValue & 0x00000001)
						{
							ATLTRACE(atlTraceRegistrar, 0, _T("Binary Data does not fall on BYTE boundries\n"));
							return E_FAIL;
						}
						dwLen = cbValue/2;
						ATLTRY(pByteTemp.Allocate(dwLen));
						if (pByteTemp == NULL)
						{
							return E_OUTOFMEMORY;
						}
						pByte = pByteTemp;
						memset(pByte, 0, dwLen);
						for (int irg = 0; irg < cbValue; irg++)
							pByte[(irg/2)] |= (ChToByte(szReplacement[irg])) << (4*(1 - (irg & 0x00000001)));
					}

					if (SUCCEEDED(hr) && p1 != 0)
						hr = GetStringAtLoc(rgStrings, p1, rgBytes2, &szReplacement2);

					CRegKey key;
					if (p1 == 0)
						key.m_hKey = rkCur.m_hKey;
					else
						key.m_hKey = hKeyParent;
					lRes = key.SetBinaryValue((szReplacement2) ? szReplacement2 : rgBytes2.m_aT,
						pByte, dwLen);
					key.m_hKey = NULL;
					if (ERROR_SUCCESS != lRes)
						return AtlHresultFromWin32(lRes);
					if (bRestoreRK)
						rkCur.m_hKey = NULL;
					ATLTRACE(atlTraceRegistrar, 2, _T("Setting Value %s at %s\n"), (szReplacement) ? szReplacement : rgBytes.m_aT, (p1 != 0) ? (szReplacement2) ? szReplacement2 : rgBytes2.m_aT : _T("default"));
				}
				pOps++;
				GetOpsFromDWORD(*pOps, code, p1, p2);
				break;
			}


			default:
				ATLASSERT(FALSE); // Should never get here
				break;
			};
		}
		pOps++;
		GetOpsFromDWORD(*pOps, code, p1, p2);
		return hr;
	}

	void GetOpsFromDWORD(
		_In_ RGSOps op,
		_Out_ DWORD& rcode,
		_Out_ DWORD& rp1,
		_Out_ DWORD& rp2) throw()
	{
		rcode = (op & 0xF0000000) >> 28;
		rp1 = (op & 0x0FFFC000) >> 14;
		rp2 = (op & 0x00003FFF);
	}

	CVMExpansionVector								m_RepMap;
	CComObjectThreadModel::AutoCriticalSection      m_csMap;
};


struct _RDXEntries
{
	enum KeyType
	{
		keyTypeString,
		keyTypeCString,
		keyTypeDWORD,
		keyTypeBinary,
		keyTypeNoEntry
	};

	HKEY iRootKey;
	LPTSTR szSubKey;
	LPTSTR szValue;
	enum KeyType nKey;
	int nMemberOffset;
	DWORD cb;
};

#define RDX_MEMBER_OFFSET(member) ((int)((char*) &(member) - (char*) this))

#define BEGIN_RDX_MAP() \
	ATL::_RDXEntries* _GetRDXEntries() \
	{ \
		static ATL::_RDXEntries rgEntries [] = {

#define RDX_TEXT(rootkey, subkey, valuename, member, member_size) \
{ rootkey, subkey, valuename, ATL::_RDXEntries::keyTypeString, RDX_MEMBER_OFFSET(member), member_size },

#define RDX_CSTRING_TEXT(rootkey, subkey, valuename, member, member_size) \
{ rootkey, subkey, valuename, ATL::_RDXEntries::keyTypeCString, RDX_MEMBER_OFFSET(member), member_size },

#define RDX_DWORD(rootkey, subkey, valuename, member, member_size) \
{ rootkey, subkey, valuename, ATL::_RDXEntries::keyTypeDWORD, RDX_MEMBER_OFFSET(member), member_size },

#define RDX_BINARY(rootkey, subkey, valuename, member, member_size) \
{ rootkey, subkey, valuename, ATL::_RDXEntries::keyTypeBinary, RDX_MEMBER_OFFSET(member), member_size },

#define END_RDX_MAP() \
		{NULL, NULL, NULL, ATL::_RDXEntries::keyTypeNoEntry, 0, 0} };\
		return rgEntries; \
	} \
	HRESULT RegistryDataExchange(enum ATL::RDXOperations rdxOp, void* pItem = NULL) \
	{ \
		return ::RegistryDataExchange(this, rdxOp, pItem); \
	}

class CByteFilter
{
public:

	static BYTE ChToByte(_In_ const TCHAR ch)
	{
		switch (ch)
		{
			case '0':
			case '1':
			case '2':
			case '3':
			case '4':
			case '5':
			case '6':
			case '7':
			case '8':
			case '9':
					return (BYTE) (ch - '0');
			case 'A':
			case 'B':
			case 'C':
			case 'D':
			case 'E':
			case 'F':
					return (BYTE) (10 + (ch - 'A'));
			case 'a':
			case 'b':
			case 'c':
			case 'd':
			case 'e':
			case 'f':
					return (BYTE) (10 + (ch - 'a'));
			default:
					ATLASSERT(FALSE);
					ATLTRACE(atlTraceRegistrar, 0, _T("Bogus value %c passed as binary Hex value\n"), ch);
					return 0;
		}
	}
};

template <class T>
HRESULT RegistryDataExchange(
	_Inout_ T* pT,
	_In_ enum RDXOperations rdxOp,
	_In_opt_ void* pItem = NULL)
{
	_RDXEntries* pEntries = pT->_GetRDXEntries();
	ATLASSERT(pEntries != NULL);
	LONG lRes = ERROR_SUCCESS;

	while (pEntries->nKey != _RDXEntries::keyTypeNoEntry)
	{
		void *pMember = (char*)pT + pEntries->nMemberOffset;
		ATLASSERT(pMember != NULL);
		if (pItem == NULL || pItem == pMember)
		{
			if (rdxOp == eDeleteFromReg)
			{
				if (pEntries->szSubKey != NULL)
				{
					if (pEntries->szValue != NULL)
					{
						CRegKey rkDel;
						lRes = rkDel.Open(pEntries->iRootKey, pEntries->szSubKey, KEY_READ | KEY_WRITE);
						if (lRes != ERROR_SUCCESS)
						{
							ATLTRACE(atlTraceRegistrar, 0, _T("Failed to Open key in order to delete Value\n"));
							return AtlHresultFromWin32(lRes);
						}
						lRes = rkDel.DeleteValue(pEntries->szValue);
						if (lRes != ERROR_SUCCESS)
						{
							ATLTRACE(atlTraceRegistrar, 0, _T("Failed to delete Value\n"));
							return AtlHresultFromWin32(lRes);
						}
					}
					else
					{
						lRes = RegDeleteKey(pEntries->iRootKey, pEntries->szSubKey);
						if (lRes != ERROR_SUCCESS)
						{
							ATLTRACE(atlTraceRegistrar, 0, _T("RegDeleteKey failed\n"));
							return AtlHresultFromWin32(lRes);
						}
					}
				}
				else
				{
					if (pEntries->szValue)
					{
						lRes = RegDeleteValue(pEntries->iRootKey, pEntries->szValue);
						if (lRes != ERROR_SUCCESS)
						{
							ATLTRACE(atlTraceRegistrar, 0, _T("RegDeleteValue failed\n"));
							return AtlHresultFromWin32(lRes);
						}
					}
				}
				pEntries++;
				continue;
			}

			CRegKey rk;
			REGSAM samDesired = KEY_READ;
			if (rdxOp == eWriteToReg)
				samDesired |= KEY_WRITE;
			lRes = rk.Open(pEntries->iRootKey, pEntries->szSubKey, samDesired);
			if (lRes != ERROR_SUCCESS && rdxOp == eReadFromReg)
				return AtlHresultFromWin32(lRes);
			else
			{
				if (lRes != ERROR_SUCCESS)
				{
					lRes = rk.Create(pEntries->iRootKey, pEntries->szSubKey, REG_NONE, REG_OPTION_NON_VOLATILE, KEY_WRITE | KEY_READ);
					if (lRes != ERROR_SUCCESS)
						return AtlHresultFromWin32(lRes);
				}
			}
			DWORD dwRet = pEntries->cb;
			switch(pEntries->nKey)
			{
			case _RDXEntries::keyTypeString:
				if (rdxOp == eWriteToReg)
					lRes = rk.SetStringValue(pEntries->szValue, (LPCTSTR)pMember);
				else
					lRes= rk.QueryStringValue(pEntries->szValue, (LPTSTR)pMember, &dwRet);
				break;
			case _RDXEntries::keyTypeCString:
				{
					CString& rStr = *((CString*)pMember);
					if (rdxOp == eWriteToReg)
						lRes = rk.SetStringValue(pEntries->szValue, rStr);
					else
					{
						lRes = rk.QueryStringValue(pEntries->szValue, NULL, &dwRet);
						if (lRes != ERROR_SUCCESS)
						{
							ATLTRACE(atlTraceRegistrar, 0, _T("Unable to determine keys length\n"));
							return AtlHresultFromWin32(lRes);
						}

						lRes= rk.QueryStringValue(pEntries->szValue, rStr.GetBuffer(dwRet), &dwRet);
						rStr.ReleaseBuffer();
						if (lRes != ERROR_SUCCESS)
						{
							ATLTRACE(atlTraceRegistrar, 0, _T("Unable to copy keys data to CString\n"));
							return AtlHresultFromWin32(lRes);
						}
					}
				}
				break;
			case _RDXEntries::keyTypeDWORD:
				{
					DWORD& rdw = *((DWORD*)pMember);
					if (rdxOp == eWriteToReg)
						lRes = rk.SetDWORDValue(pEntries->szValue, rdw);
					else
						lRes= rk.QueryDWORDValue(pEntries->szValue, rdw);
					break;
				}
			case _RDXEntries::keyTypeBinary:
				if (rdxOp == eReadFromReg)
				{
					DWORD dwType = REG_BINARY;
					DWORD dwCount = pEntries->cb;
					LONG lRes = RegQueryValueEx(rk, pEntries->szValue, NULL, &dwType, (LPBYTE)pMember, &dwCount);
					if (lRes != ERROR_SUCCESS)
					{
						ATLTRACE(atlTraceRegistrar, 0, _T("Failed to query binary value\n"));
						return AtlHresultFromWin32(lRes);
					}
					ATLASSERT(dwType == REG_BINARY);
					break;
				}
				else
				{
					lRes = RegSetValueEx(rk, pEntries->szValue, 0, REG_BINARY, (const BYTE *)pMember, pEntries->cb);
					break;
				}
			case _RDXEntries::keyTypeNoEntry:
				ATLASSERT(FALSE);  // Not yet implemented
				break;
			};
			if (pItem != NULL)
				return AtlHresultFromWin32(lRes);
		}
		pEntries++;
	}
	return AtlHresultFromWin32(lRes);
}
}; // namespace ATL
#pragma pack(pop)

#endif // __ATLPLUS_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\include\atlsafe.h ===
// This is a part of the Active Template Library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Active Template Library Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Active Template Library product.

#ifndef __ATLSAFE_H__
#define __ATLSAFE_H__

#pragma once

#include <atlbase.h>

#pragma pack(push,_ATL_PACKING)
namespace ATL
{

// This struct is used with CComSafeArray to set the matching VARTYPE based on
// template argument type passed in to CComSafeArray.
template <typename T>
struct _ATL_AutomationType
{
};

#define DEFINE_AUTOMATION_TYPE_FUNCTION(ctype, typewrapper, oleautomationtype) \
	template <> \
	struct _ATL_AutomationType<ctype> \
	{ \
		typedef typewrapper _typewrapper;\
		enum { type = oleautomationtype }; \
		static void* GetT(const ctype& t) throw() \
		{ \
			return (void*)&t; \
		} \
	};
	// specialization for BSTR so GetT doesn't return &BSTR
	template <>
	struct _ATL_AutomationType<BSTR>
	{
		typedef CComBSTR _typewrapper ;
		enum { type = VT_BSTR };
		static void* GetT(_In_ const BSTR& t) throw()
		{
			return t;
		}
	};
	// specialization for LPUNKNOWN so GetT doesn't return &LPUNKNOWN
	template <>
	struct _ATL_AutomationType<LPUNKNOWN>
	{
		typedef CComPtr<IUnknown> _typewrapper;
		enum { type = VT_UNKNOWN};
		static void* GetT(_In_ const LPUNKNOWN& t) throw()
		{
			return t;
		}
	};
	// specialization for LPDISPATCH so GetT doesn't return &LPDISPATCH
	template <>
	struct _ATL_AutomationType<LPDISPATCH>
	{
		typedef CComPtr<IDispatch> _typewrapper;
		enum { type = VT_DISPATCH};
		static void* GetT(_In_ const LPDISPATCH& t) throw()
		{
			return t;
		}
	};

	DEFINE_AUTOMATION_TYPE_FUNCTION(CHAR		, CHAR			,VT_I1)
	DEFINE_AUTOMATION_TYPE_FUNCTION(SHORT		, SHORT			,VT_I2)
	DEFINE_AUTOMATION_TYPE_FUNCTION(INT			, INT			,VT_I4)
	DEFINE_AUTOMATION_TYPE_FUNCTION(LONG		, LONG			,VT_I4)
	DEFINE_AUTOMATION_TYPE_FUNCTION(LONGLONG	, LONGLONG		,VT_I8)
	DEFINE_AUTOMATION_TYPE_FUNCTION(BYTE		, BYTE			,VT_UI1)
	DEFINE_AUTOMATION_TYPE_FUNCTION(USHORT		, USHORT		,VT_UI2)
	DEFINE_AUTOMATION_TYPE_FUNCTION(UINT		, UINT			,VT_UI4)
	DEFINE_AUTOMATION_TYPE_FUNCTION(ULONG		, ULONG			,VT_UI4)
	DEFINE_AUTOMATION_TYPE_FUNCTION(ULONGLONG	, ULONGLONG		,VT_UI8)
	DEFINE_AUTOMATION_TYPE_FUNCTION(FLOAT		, FLOAT			,VT_R4)
	DEFINE_AUTOMATION_TYPE_FUNCTION(DOUBLE		, DOUBLE		,VT_R8)
	DEFINE_AUTOMATION_TYPE_FUNCTION(DECIMAL		, DECIMAL		,VT_DECIMAL)
	DEFINE_AUTOMATION_TYPE_FUNCTION(VARIANT		, CComVariant	,VT_VARIANT)
	DEFINE_AUTOMATION_TYPE_FUNCTION(CY			, CY			,VT_CY)

// wrapper for SAFEARRAYBOUND used with CComSafeArray
class CComSafeArrayBound : 
	public SAFEARRAYBOUND
{
public:
	CComSafeArrayBound(
		_In_ ULONG ulCount = 0,
		_In_ LONG lLowerBound = 0) throw()
	{
		cElements = ulCount;
		lLbound = lLowerBound;
	}
	CComSafeArrayBound& operator=(_In_ const CComSafeArrayBound& bound) throw()
	{
		cElements = bound.cElements;
		lLbound = bound.lLbound;
		return *this;
	}
	CComSafeArrayBound& operator=(_In_ ULONG ulCount) throw()
	{
		cElements = ulCount;
		lLbound = 0;
		return *this;
	}
	ULONG GetCount() const throw()
	{
		return cElements;
	}
	ULONG SetCount(_In_ ULONG ulCount) throw()
	{
		cElements = ulCount;
		return cElements;
	}
	LONG GetLowerBound() const throw()
	{
		return lLbound;
	}
	LONG SetLowerBound(_In_ LONG lLowerBound) throw()
	{
		lLbound = lLowerBound;
		return lLbound;
	}
	LONG GetUpperBound() const throw()
	{
		return lLbound + cElements - 1;
	}
};

// wrapper for SAFEARRAY.  T is type stored (e.g. BSTR, VARIANT, etc.)
template <typename T, VARTYPE _vartype = _ATL_AutomationType<T>::type>
class CComSafeArray
{
public:
// Constructors
	CComSafeArray() throw() : m_psa(NULL)
	{
	}
	// create SAFEARRAY where number of elements = ulCount
	explicit CComSafeArray(
		_In_ ULONG ulCount,
		_In_ LONG lLBound = 0) : m_psa(NULL)
	{
		CComSafeArrayBound bound(ulCount, lLBound);
		HRESULT hRes = Create(&bound);
		if (FAILED(hRes))
			AtlThrow(hRes);
	}
	explicit CComSafeArray(_In_ const SAFEARRAYBOUND& bound) : m_psa(NULL)
	{
		HRESULT hRes = Create(&bound);
		if (FAILED(hRes))
			AtlThrow(hRes);
	}
	// pass an array of SAFEARRAYBOUNDs for multi-dimensional
	explicit CComSafeArray(
		_In_ const SAFEARRAYBOUND *pBound,
		_In_ UINT uDims = 1) : m_psa(NULL)
	{
		ATLASSERT(pBound != NULL);
		ATLASSERT(uDims > 0);
		HRESULT hRes = Create(pBound, uDims);
		if (FAILED(hRes))
			AtlThrow(hRes);
	}
	CComSafeArray(_In_ const SAFEARRAY *psaSrc) : m_psa(NULL)
	{
		ATLASSERT(psaSrc != NULL);
		HRESULT hRes = CopyFrom(psaSrc);
		if (FAILED(hRes))
			AtlThrow(hRes);
	}
	CComSafeArray(_In_ const SAFEARRAY& saSrc) : m_psa(NULL)
	{
		HRESULT hRes = CopyFrom(&saSrc);
		if (FAILED(hRes))
			AtlThrow(hRes);
	}
	CComSafeArray(_In_ const CComSafeArray& saSrc) : m_psa(NULL)
	{
		ATLASSUME(saSrc.m_psa != NULL);
		HRESULT hRes = CopyFrom(saSrc.m_psa);
		if (FAILED(hRes))
			AtlThrow(hRes);
	}

	~CComSafeArray() throw()
	{
		HRESULT hRes = Destroy();
		DBG_UNREFERENCED_LOCAL_VARIABLE(hRes);
		ATLASSERT(SUCCEEDED(hRes));
	}

	HRESULT Attach(_In_ const SAFEARRAY *psaSrc)
	{
		ATLENSURE_THROW(psaSrc != NULL, E_INVALIDARG);

		VARTYPE vt;
		HRESULT hRes = ::ATL::AtlSafeArrayGetActualVartype(const_cast<LPSAFEARRAY>(psaSrc), &vt);
		ATLENSURE_SUCCEEDED(hRes);
		ATLENSURE_THROW(vt == GetType(), E_INVALIDARG);

		hRes = Destroy();
		ATLENSURE_SUCCEEDED(hRes);

		m_psa = const_cast<LPSAFEARRAY>(psaSrc);
		hRes = Lock();

		return hRes;
	}
	LPSAFEARRAY Detach()
	{
		Unlock();
		LPSAFEARRAY pTemp = m_psa;
		m_psa = NULL;
		return pTemp;
	}

// overloaded operators
	CComSafeArray<T>& operator=(_In_ const CComSafeArray& saSrc)
	{
		*this = saSrc.m_psa;
		return *this;
	}
	CComSafeArray<T>& operator=(_In_ const SAFEARRAY *psaSrc)
	{
		ATLASSERT(psaSrc != NULL);
		HRESULT hRes = CopyFrom(psaSrc);
		if (FAILED(hRes))
			AtlThrow(hRes);
		return *this;
	}
	operator const SAFEARRAY *() const throw()
	{
		return m_psa;
	}
	operator LPSAFEARRAY() throw()
	{
		return m_psa;
	}
	LPSAFEARRAY* GetSafeArrayPtr() throw()
	{
		return &m_psa;
	}
	const typename _ATL_AutomationType<T>::_typewrapper& operator[](_In_ int nIndex) const
	{
		return GetAt(nIndex);
	}
	typename _ATL_AutomationType<T>::_typewrapper& operator[](_In_ int nIndex)
	{
		return GetAt(nIndex);
	}
	const typename _ATL_AutomationType<T>::_typewrapper& operator[](_In_ LONG nIndex) const
	{
		return GetAt(nIndex);
	}
	typename _ATL_AutomationType<T>::_typewrapper& operator[](_In_ LONG nIndex)
	{
		return GetAt(nIndex);
	}

// info functions
	LONG GetLowerBound(_In_ UINT uDim = 0) const
	{
		ATLASSUME(m_psa != NULL);
		LONG lLBound = 0;
		HRESULT hRes = SafeArrayGetLBound(m_psa, uDim+1, &lLBound);
		if (FAILED(hRes))
			AtlThrow(hRes);
		return lLBound;
	}
	LONG GetUpperBound(_In_ UINT uDim = 0) const
	{
		ATLASSUME(m_psa != NULL);
		LONG lUBound = 0;
		HRESULT hRes = SafeArrayGetUBound(m_psa, uDim+1, &lUBound);
		if (FAILED(hRes))
			AtlThrow(hRes);
		return lUBound;
	}
	ULONG GetCount(_In_ UINT uDim = 0) const
	{
		ATLASSUME(m_psa != NULL);
		ATLASSERT(uDim < GetDimensions());
		LONG lLBound, lUBound;
		HRESULT hRes = SafeArrayGetLBound(m_psa, uDim+1, &lLBound);
		ATLASSERT(SUCCEEDED(hRes));
		if(FAILED(hRes))
			AtlThrow(hRes);
		hRes = SafeArrayGetUBound(m_psa, uDim+1, &lUBound);
		ATLASSERT(SUCCEEDED(hRes));
		if(FAILED(hRes))
			AtlThrow(hRes);
		return (lUBound - lLBound + 1);
	}
	UINT GetDimensions() const
	{
		ATLASSUME(m_psa != NULL);
		return SafeArrayGetDim(m_psa);
	}
	VARTYPE GetType() const throw()
	{
		return _vartype;
	}
	bool IsSizable() const
	{
		ATLASSUME(m_psa != NULL);
		if(m_psa == NULL)
			AtlThrow(E_FAIL);

		return (m_psa->fFeatures & FADF_FIXEDSIZE) ? false : true;
	}

// miscellaneous functions
	const typename _ATL_AutomationType<T>::_typewrapper& GetAt(_In_ LONG lIndex) const
	{
		ATLASSUME(m_psa != NULL);
		if(m_psa == NULL)
			AtlThrow(E_FAIL);

		LONG lLBound = GetLowerBound();
		ATLASSERT(lIndex >= lLBound);
		ATLASSERT(lIndex <= GetUpperBound());
		if ((lIndex < lLBound) || (lIndex > GetUpperBound()))
			AtlThrow(E_INVALIDARG);

		return ((_ATL_AutomationType<T>::_typewrapper*)m_psa->pvData)[lIndex-lLBound];
	}

	typename _ATL_AutomationType<T>::_typewrapper& GetAt(_In_ LONG lIndex)
	{
		ATLASSUME(m_psa != NULL);
		if(m_psa == NULL)
			AtlThrow(E_FAIL);

		LONG lLBound = GetLowerBound();
		ATLASSERT(lIndex >= lLBound);
		ATLASSERT(lIndex <= GetUpperBound());
		if ((lIndex < lLBound) || (lIndex > GetUpperBound()))
			AtlThrow(E_INVALIDARG);

		return ((_ATL_AutomationType<T>::_typewrapper*)m_psa->pvData)[lIndex-lLBound];
	}
	HRESULT SetAt(
		_In_ LONG lIndex,
		_In_ const T& t,
		_In_ BOOL bCopy = TRUE)
	{
		UNREFERENCED_PARAMETER(bCopy);
		ATLASSUME(m_psa != NULL);
		if(m_psa == NULL)
			return E_FAIL;

		LONG lLBound = GetLowerBound();
		ATLASSERT(lIndex >= lLBound);
		ATLASSERT(lIndex <= GetUpperBound());
		if ((lIndex < lLBound) || (lIndex > GetUpperBound()))
			return E_INVALIDARG;

		((T*)m_psa->pvData)[lIndex-lLBound] = t;
		return S_OK;
	}
	// multi-dimensional version
	HRESULT MultiDimGetAt(_In_ const LONG *alIndex, _Out_ T& t)
	{
		ATLASSUME(m_psa != NULL);
		return SafeArrayGetElement(m_psa, const_cast<LONG*>(alIndex), &t);
	}
	// multi-dimensional version
	HRESULT MultiDimSetAt(_In_ const LONG *alIndex, _In_ const T& t)
	{
		ATLASSUME(m_psa != NULL);
		return SafeArrayPutElement(m_psa, const_cast<LONG*>(alIndex), _ATL_AutomationType<T>::GetT(t));
	}
	// append an item
	HRESULT Add(
		_In_ const T& t,
		_In_ BOOL bCopy = TRUE)
	{
		HRESULT hRes = S_OK;
		if (NULL == m_psa)
		{
			hRes = Create();
			if (FAILED(hRes))
				return hRes;
		}
		ATLASSERT(GetDimensions() == 1); // not for multi-dimensional
		LONG lLBound = GetLowerBound();
		hRes = Resize(GetCount() + 1, lLBound);
		if (SUCCEEDED(hRes))
			return SetAt(GetCount() - 1 + lLBound, t, bCopy);
		else
			return hRes;
	}
	// appends an array of type T items
	HRESULT Add(
		_In_ ULONG ulCount,
		_In_count_(ulCount) const T *pT,
		_In_ BOOL bCopy = TRUE)
	{
		ATLASSERT(pT != NULL);
		ATLASSERT(ulCount > 0);
		if(pT == NULL)
			return E_INVALIDARG;

		HRESULT hRes = S_OK;
		if (NULL == m_psa)
		{
			hRes = Create();
			if (FAILED(hRes))
				return hRes;
		}
		ATLASSERT(GetDimensions() == 1); // not for multi-dimensional
		ULONG ulLastIndex = GetCount();
		ULONG ulTotalCount = ulLastIndex + ulCount;
		LONG lLBound = GetLowerBound();
		hRes = Resize(ulTotalCount, lLBound);
		if (SUCCEEDED(hRes))
		{
			for (ULONG ulCntr=0; ulCntr<ulCount; ulCntr++, ulLastIndex++)
			{
				hRes = SetAt(ulLastIndex + lLBound, pT[ulCntr], bCopy);
				if (FAILED(hRes))
					break;
			}
		}
		return hRes;
	}
	// appends items in the safearray
	HRESULT Add(_In_ const SAFEARRAY *psaSrc)
	{
		ATLASSUME(psaSrc != NULL);
		// safearrays must only have one dimension
		ATLASSERT(SafeArrayGetDim(const_cast<LPSAFEARRAY>(psaSrc)) == 1);

		HRESULT hRes = S_OK;
		if (NULL == m_psa)
		{
			hRes = Create();
			if (FAILED(hRes))
				return hRes;
		}
		ATLASSERT(GetDimensions() == 1);

		// types must match
		VARTYPE vt;
		hRes = ::ATL::AtlSafeArrayGetActualVartype(const_cast<LPSAFEARRAY>(psaSrc), &vt);
		if(FAILED(hRes))
			return hRes;

		if(GetType() != vt)
		{
			ATLASSERT(FALSE);
			return E_INVALIDARG;
		}

		// resize safearray
		ULONG ulCount = psaSrc->rgsabound[0].cElements;
		ULONG ulLastIndex = GetCount();
		ULONG ulTotalCount = ulLastIndex + ulCount;
		LONG lLBound = GetLowerBound();
		hRes = Resize(ulTotalCount, lLBound);
		if (SUCCEEDED(hRes))
		{
			CComSafeArray saTemp;
			hRes = saTemp.Attach(psaSrc);
			if (FAILED(hRes))
				return hRes;

			LONG lsrcLBound = saTemp.GetLowerBound();
			for(ULONG lCntr = 0; lCntr < ulCount; lCntr++, ulLastIndex++)
			{
				// copy data to end of our safearray
				hRes = SetAt(ulLastIndex + lLBound, saTemp.GetAt(lCntr + lsrcLBound));
				if (FAILED(hRes))
					break;
			}
			saTemp.Detach();
		}
		return hRes;
	}

	// Resize only resizes the right-most dimension
	HRESULT Resize(
		_In_ ULONG ulCount,
		_In_ LONG lLBound = 0)
	{
		ATLASSUME(m_psa != NULL);
		CComSafeArrayBound bound(ulCount, lLBound);
		return Resize(&bound);
	}
	// Resize only resizes the right-most dimension
	HRESULT Resize(_In_ const SAFEARRAYBOUND *pBound)
	{
		ATLASSUME(m_psa != NULL);
		ATLASSUME(pBound != NULL);
		if (!IsSizable())
        {
			return E_FAIL;
        }
		HRESULT hRes = Unlock();
		if (SUCCEEDED(hRes))
		{
			hRes = SafeArrayRedim(m_psa, const_cast<LPSAFEARRAYBOUND>(pBound));
			HRESULT hrLock = Lock();
			if (SUCCEEDED(hRes))
			{
				hRes = hrLock;
			}
		}
		return hRes;
	}
	HRESULT CopyFrom(_In_ const SAFEARRAY *psaSrc)
	{
		ATLENSURE_THROW(psaSrc != NULL, E_INVALIDARG);

		VARTYPE vt;
		HRESULT hRes = ::ATL::AtlSafeArrayGetActualVartype(const_cast<LPSAFEARRAY>(psaSrc), &vt);
		ATLENSURE_SUCCEEDED(hRes);
		ATLENSURE_THROW(vt == GetType(), E_INVALIDARG);

		hRes = Destroy();
		ATLENSURE_SUCCEEDED(hRes);

		hRes = SafeArrayCopy( const_cast<LPSAFEARRAY>(psaSrc), &m_psa );
		ATLENSURE_SUCCEEDED(hRes);

		if( m_psa )
		{
			hRes = Lock();
		}
		return hRes;
	}
	HRESULT CopyTo(_Out_ LPSAFEARRAY *ppArray)
	{
		ATLENSURE_THROW(ppArray != NULL, E_POINTER);
		ATLENSURE(m_psa != NULL);

		return SafeArrayCopy( m_psa, ppArray );
	}
	HRESULT Create(
		_In_ ULONG ulCount = 0,
		_In_ LONG lLBound = 0)
	{
		CComSafeArrayBound bound(ulCount, lLBound);
		return Create(&bound);
	}
	HRESULT Create(
		_In_ const SAFEARRAYBOUND *pBound,
		_In_ UINT uDims = 1)
	{
		ATLASSUME(m_psa == NULL);
		ATLASSERT(uDims > 0);
		if(m_psa != NULL)
			return E_FAIL;

		if(pBound == NULL || uDims == 0)
			return E_INVALIDARG;

		HRESULT hRes = S_OK;
		m_psa = SafeArrayCreate(_vartype, uDims, const_cast<LPSAFEARRAYBOUND>(pBound));
		if (NULL == m_psa)
			hRes = E_OUTOFMEMORY;
		else
			hRes = Lock();
		return hRes;
	}
	HRESULT Destroy()
	{
		HRESULT hRes = S_OK;
		if (m_psa != NULL)
		{
			hRes = Unlock();
			if (SUCCEEDED(hRes))
			{
				hRes = SafeArrayDestroy(m_psa);
				if (SUCCEEDED(hRes))
					m_psa = NULL;
			}
		}
		return hRes;
	}
protected:
	HRESULT Lock()
	{
		ATLASSUME(m_psa != NULL);
		return SafeArrayLock(m_psa);
	}
	HRESULT Unlock()
	{
		ATLASSUME(m_psa != NULL);
		return SafeArrayUnlock(m_psa);
	}
public:
	LPSAFEARRAY m_psa;
};

template<>
HRESULT CComSafeArray<BSTR>::SetAt(
	_In_ LONG lIndex,
	_In_ const BSTR& strData,
	_In_ BOOL bCopy)
{
	ATLASSERT(strData != NULL);
	if(strData == NULL)
		return E_INVALIDARG;

	ATLASSUME(m_psa != NULL);
	LONG lLBound = GetLowerBound();
	ATLASSERT(lIndex >= lLBound);
	ATLASSERT(lIndex <= GetUpperBound());

	if((lIndex < lLBound) || (lIndex > GetUpperBound()))
		return E_INVALIDARG;

	BSTR strOrg = ((BSTR*)m_psa->pvData)[lIndex-lLBound];
	if (strOrg)
		::SysFreeString(strOrg);

	if (bCopy)
	{
		BSTR strTemp = ::SysAllocString(strData);
		if (NULL == strTemp)
			return E_OUTOFMEMORY;
		((BSTR*)m_psa->pvData)[lIndex-lLBound] = strTemp;
	}
	else
		((BSTR*)m_psa->pvData)[lIndex-lLBound] = strData;

	return S_OK;
}
template<>
HRESULT CComSafeArray<VARIANT>::SetAt(
	_In_ LONG lIndex,
	_In_ const VARIANT& varData,
	_In_ BOOL bCopy)
{
	ATLASSUME(m_psa != NULL);
	LONG lLBound = GetLowerBound();
	ATLASSERT(lIndex >= lLBound);
	ATLASSERT(lIndex <= GetUpperBound());

	if((lIndex < lLBound) || (lIndex > GetUpperBound()))
		return E_INVALIDARG;

	if (bCopy)
		return VariantCopyInd(&((VARIANT*)m_psa->pvData)[lIndex-lLBound], const_cast<LPVARIANT>(&varData));
	else
	{
		VARIANT varOrg = ((VARIANT*)m_psa->pvData)[lIndex-lLBound];
		if (V_VT(&varOrg) != VT_EMPTY)
			::VariantClear(&varOrg);
		((VARIANT*)m_psa->pvData)[lIndex-lLBound] = varData;
		return S_OK;
	}
}
template<>
HRESULT CComSafeArray<LPUNKNOWN>::SetAt(
	_In_ LONG lIndex,
	_In_ const LPUNKNOWN& pUnk,
	_In_ BOOL bAddRef)
{
	ATLENSURE_RETURN(pUnk != NULL);
	ATLASSUME(m_psa != NULL);
	LONG lLBound = GetLowerBound();
	ATLASSERT(lIndex >= lLBound);
	ATLASSERT(lIndex <= GetUpperBound());

	if((lIndex < lLBound) || (lIndex > GetUpperBound()))
		return E_INVALIDARG;

	LPUNKNOWN pOrgUnk = ((LPUNKNOWN*)m_psa->pvData)[lIndex-lLBound];
	if (pOrgUnk)
		pOrgUnk->Release();
	if (bAddRef)
		pUnk->AddRef();
	((LPUNKNOWN*)m_psa->pvData)[lIndex-lLBound] = pUnk;
	return S_OK;
}
template<>
HRESULT CComSafeArray<LPDISPATCH>::SetAt(
	_In_ LONG lIndex,
	_In_ const LPDISPATCH& pDisp,
	_In_ BOOL bAddRef)
{
	ATLENSURE_RETURN(pDisp != NULL);
	ATLASSUME(m_psa != NULL);
	LONG lLBound = GetLowerBound();
	ATLASSERT(lIndex >= lLBound);
	ATLASSERT(lIndex <= GetUpperBound());

	if((lIndex < lLBound) || (lIndex > GetUpperBound()))
		return E_INVALIDARG;

	LPDISPATCH pOrgDisp = ((LPDISPATCH*)m_psa->pvData)[lIndex-lLBound];
	if (pOrgDisp)
		pOrgDisp->Release();
	if (bAddRef)
		pDisp->AddRef();
	((LPDISPATCH*)m_psa->pvData)[lIndex-lLBound] = pDisp;
	return S_OK;
}

}; //namespace ATL

#pragma pack(pop)

#endif //__ATLSAFE_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\include\atlsecurity.inl ===
// This is a part of the Active Template Library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Active Template Library Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Active Template Library product.
#ifndef __ATLSECURITY_INL__
#define __ATLSECURITY_INL__

#pragma once

#ifndef __ATLSECURITY_H__
	#error atlsecurity.inl requires atlsecurity.h to be included first
#endif

#pragma warning(push)
#pragma warning(3: 4294)
#pragma warning(disable: 4571) //catch(...) blocks compiled with /EHs do NOT catch or re-throw Structured Exceptions
namespace ATL
{
#pragma comment(lib, "userenv.lib")

// **************************************************************
// CSid implementation

inline CSid::CSid() throw() :
	m_bValid(false),
	m_sidnameuse(SidTypeInvalid)
{
}

inline CSid::CSid(
		_In_z_ LPCTSTR pszAccountName,
		_In_opt_z_ LPCTSTR pszSystem /* = NULL */) throw(...) :
	m_bValid(false),
	m_sidnameuse(SidTypeInvalid)
{
	if(!LoadAccount(pszAccountName, pszSystem))
		AtlThrowLastWin32();
}

inline CSid::CSid(
		_In_ const SID *pSid,
		_In_opt_z_ LPCTSTR pszSystem /* = NULL */) throw(...) :
	m_bValid(false),
	m_sidnameuse(SidTypeInvalid)
{
	if(!LoadAccount(pSid, pszSystem))
		AtlThrowLastWin32();
}

#pragma warning(push)
#pragma warning(disable : 4793)
inline CSid::CSid(
		_In_ const SID_IDENTIFIER_AUTHORITY &IdentifierAuthority,
		_In_ BYTE nSubAuthorityCount,
		...) throw(...) :
	m_bValid(false),
	m_sidnameuse(SidTypeInvalid)
{
	BYTE buffer[SECURITY_MAX_SID_SIZE];
	SID *pSid = reinterpret_cast<SID*>(buffer);

	ATLASSERT(nSubAuthorityCount);
	if(!nSubAuthorityCount || ::GetSidLengthRequired(nSubAuthorityCount) > SECURITY_MAX_SID_SIZE)
		AtlThrow(E_INVALIDARG);

	if(!::InitializeSid(pSid,
		const_cast<SID_IDENTIFIER_AUTHORITY *>(&IdentifierAuthority),
		nSubAuthorityCount))
	{
		AtlThrowLastWin32();
	}

	va_list args;
	va_start(args, nSubAuthorityCount);
	for(UINT i = 0; i < nSubAuthorityCount; i++)
		*::GetSidSubAuthority(pSid, i) = va_arg(args, DWORD);
	va_end(args);

	Copy(*pSid);

	m_sidnameuse = SidTypeUnknown;
}
#pragma warning(pop)

inline CSid::~CSid() throw()
{
}

inline CSid::CSid(_In_ const CSid &rhs) throw(...) :
	m_sidnameuse(rhs.m_sidnameuse),
	m_bValid(rhs.m_bValid),
	m_strAccountName(rhs.m_strAccountName),
	m_strDomain(rhs.m_strDomain),
	m_strSid(rhs.m_strSid)
{
	if (!rhs.m_bValid)
		return;

	if(!rhs.IsValid())
		AtlThrow(E_INVALIDARG);

	if(!::CopySid(rhs.GetLength(), _GetPSID(), rhs._GetPSID()))
	{
		HRESULT hr = AtlHresultFromLastError();
		AtlThrow(hr);
	}
}

inline CSid &CSid::operator=(_In_ const CSid &rhs) throw(...)
{
	if(this != &rhs)
	{
		m_sidnameuse = rhs.m_sidnameuse;
		m_strAccountName = rhs.m_strAccountName;
		m_strDomain = rhs.m_strDomain;
		m_strSid = rhs.m_strSid;
		m_bValid = rhs.m_bValid;

		if (m_bValid)
		{
			if(!::CopySid(rhs.GetLength(), _GetPSID(), rhs._GetPSID()))
			{
				HRESULT hr = AtlHresultFromLastError();
				m_bValid = false;
				AtlThrow(hr);
			}
		}
	}
	return *this;
}

inline CSid::CSid(_In_ const SID &rhs) throw(...) :
	m_bValid(false),
	m_sidnameuse(SidTypeInvalid)
{
	Copy(rhs);
}

inline CSid &CSid::operator=(_In_ const SID &rhs) throw(...)
{
	if (!m_bValid || _GetPSID() != &rhs)
	{
		Clear();
		Copy(rhs);

		m_sidnameuse = SidTypeUnknown;
	}
	return *this;
}

inline bool CSid::LoadAccount(
	_In_z_ LPCTSTR pszAccountName,
	_In_opt_z_ LPCTSTR pszSystem /* = NULL */) throw(...)
{
    Clear();

	ATLASSERT(pszAccountName);
	if (!pszAccountName)
    {
		return false;
    }

	static const DWORD dwDomainSize = 128; // reasonable to start with
	BYTE buffSid[SECURITY_MAX_SID_SIZE];
	CTempBuffer<TCHAR, dwDomainSize> buffDomain;
	buffDomain.Allocate(dwDomainSize); // just assign the static buffer

	SID *pSid = reinterpret_cast<SID *>(buffSid);
	TCHAR *szDomain = static_cast<TCHAR *>(buffDomain);
	DWORD cbSid = SECURITY_MAX_SID_SIZE;
	DWORD cbDomain = dwDomainSize;

	BOOL bSuccess = ::LookupAccountName(pszSystem, pszAccountName, pSid, &cbSid, szDomain, &cbDomain, &m_sidnameuse);
	if (!bSuccess && ::GetLastError() == ERROR_INSUFFICIENT_BUFFER)
	{
		// We could have gotten the insufficient buffer error because
		// one or both of pSid and szDomain was too small. Check for that
		// here.
		if (cbSid > SECURITY_MAX_SID_SIZE)
		{
			// Should never happen. Fail
			AtlThrow(E_FAIL);
		}

		if (cbDomain > dwDomainSize)
		{
			// Failed because domain was not big enough, reallocate it.
			buffDomain.Reallocate(cbDomain);
			szDomain = static_cast<TCHAR *>(buffDomain);
		}
		bSuccess = ::LookupAccountName(pszSystem, pszAccountName, pSid, &cbSid, szDomain, &cbDomain, &m_sidnameuse);
	}

	if (bSuccess)
	{
		// should be taken care of by ::LookupAccountName
		ATLASSERT(::GetLengthSid(pSid) < SECURITY_MAX_SID_SIZE);

		// LookupAccountName doesn't change cbSid on success (although it changes cbDomain)
		m_bValid = true;
		if (::CopySid(cbSid, _GetPSID(), pSid))
		{
			m_strDomain = szDomain;
			m_strAccountName = pszAccountName;
			m_strSystem = pszSystem;
			return true;
		}
	}

	Clear();
	return false;
}

inline bool CSid::LoadAccount(
	_In_ const SID *pSid,
	_In_opt_z_ LPCTSTR pszSystem /* = NULL */) throw(...)
{
    Clear();
	ATLASSERT(pSid);

	if(pSid)
	{
		_ATLTRY
		{
			m_strSystem = pszSystem;
			Copy(*pSid);
			return true;
		}
		_ATLCATCHALL()
		{
			Clear();
			throw;
		}
	}
	return false;
}

inline LPCTSTR CSid::AccountName() const throw(...)
{
	if(m_strAccountName.IsEmpty())
		GetAccountNameAndDomain();
	return m_strAccountName;
}

inline LPCTSTR CSid::Domain() const throw(...)
{
	if(m_strDomain.IsEmpty())
		GetAccountNameAndDomain();
	return m_strDomain;
}

inline LPCTSTR CSid::Sid() const throw(...)
{
	_ATLTRY
	{
		if(m_strSid.IsEmpty())
		{
#if(_WIN32_WINNT >= 0x0500)
			LPTSTR pszSid;
			if(::ConvertSidToStringSid(_GetPSID(), &pszSid))
			{
				m_strSid = pszSid;
				::LocalFree(pszSid);
			}
#else
			SID_IDENTIFIER_AUTHORITY *psia = ::GetSidIdentifierAuthority(_GetPSID());
			UINT i;

			if(psia->Value[0] || psia->Value[1])
			{
				m_strSid.Format(_T("S-%d-0x%02hx%02hx%02hx%02hx%02hx%02hx"), SID_REVISION,
					(USHORT)psia->Value[0],
					(USHORT)psia->Value[1],
					(USHORT)psia->Value[2],
					(USHORT)psia->Value[3],
					(USHORT)psia->Value[4],
					(USHORT)psia->Value[5]);
			}
			else
			{
				ULONG nAuthority = 0;
				for(i = 2; i < 6; i++)
				{
					nAuthority <<= 8;
					nAuthority |= psia->Value[i];
				}
				m_strSid.Format(_T("S-%d-%lu"), SID_REVISION, nAuthority);
			}

			UINT nSubAuthorityCount = *::GetSidSubAuthorityCount(_GetPSID());
			CString strTemp;
			for(i = 0; i < nSubAuthorityCount; i++)
			{
				strTemp.Format(_T("-%lu"), *::GetSidSubAuthority(_GetPSID(), i));
				m_strSid += strTemp;
			}
#endif
		}
		return m_strSid;
	}
	_ATLCATCHALL()
	{
		m_strSid.Empty();
		throw;
	}
}

inline const SID *CSid::GetPSID() const throw(...)
{
	return _GetPSID();
}

inline CSid::operator const SID *() const throw(...)
{
	return GetPSID();
}

inline SID_NAME_USE CSid::SidNameUse() const throw()
{
	return m_sidnameuse;
}

inline UINT CSid::GetLength() const throw()
{
	ATLASSERT(IsValid());
	return ::GetLengthSid(_GetPSID());
}

inline bool CSid::EqualPrefix(_In_ const CSid &rhs) const throw()
{
	if (_GetPSID() == NULL || rhs._GetPSID() == NULL || !IsValid() || !rhs.IsValid())
	{
		return FALSE;
	}
	return 0 != ::EqualPrefixSid(_GetPSID(), rhs._GetPSID());
}

inline bool CSid::EqualPrefix(_In_ const SID &rhs) const throw()
{
	if (_GetPSID() == NULL || !IsValid() || !::IsValidSid(const_cast<SID *>(&rhs)))
	{
		return FALSE;
	}
	return 0 != ::EqualPrefixSid(_GetPSID(), const_cast<SID *>(&rhs));
}

inline const SID_IDENTIFIER_AUTHORITY *CSid::GetPSID_IDENTIFIER_AUTHORITY() const throw()
{
	ATLASSERT(IsValid());
	return ::GetSidIdentifierAuthority(_GetPSID());
}

inline DWORD CSid::GetSubAuthority(_In_ DWORD nSubAuthority) const throw()
{
	ATLASSERT(IsValid());
	return *::GetSidSubAuthority(_GetPSID(), nSubAuthority);
}

inline UCHAR CSid::GetSubAuthorityCount() const throw()
{
	ATLASSERT(IsValid());
	return *::GetSidSubAuthorityCount(_GetPSID());
}

inline bool CSid::IsValid() const throw()
{
	if (!m_bValid)
		return false;
	return 0 != ::IsValidSid(_GetPSID());
}

inline void CSid::Clear() throw()
{
	m_sidnameuse = SidTypeInvalid;
	m_strAccountName.Empty();
	m_strDomain.Empty();
	m_strSid.Empty();
	m_strSystem.Empty();
	m_bValid = false;
}

inline void CSid::Copy(_In_ const SID &rhs) throw(...)
{
	// This function assumes everything is cleaned up/initialized
	// (with the exception of m_strSystem).
	// It does some sanity checking to prevent memory leaks, but
	// you should clean up all members of CSid before calling this
	// function.  (i.e., results are unpredictable on error)

	ATLASSUME(m_sidnameuse == SidTypeInvalid);
	ATLASSUME(m_strAccountName.IsEmpty());
	ATLASSUME(m_strDomain.IsEmpty());
	ATLASSUME(m_strSid.IsEmpty());

	SID *p = const_cast<SID *>(&rhs);
	if(!::IsValidSid(p))
		AtlThrow(E_INVALIDARG);

	DWORD dwLengthSid = ::GetLengthSid(p);
	if (dwLengthSid > SECURITY_MAX_SID_SIZE)
		AtlThrow(E_INVALIDARG);

	m_bValid = true;
	if(!::CopySid(dwLengthSid, _GetPSID(), p))
	{
		HRESULT hr = AtlHresultFromLastError();
		m_bValid = false;
		AtlThrow(hr);
	}
}

inline void CSid::GetAccountNameAndDomain() const throw(...)
{
	static const DWORD dwMax = 32;
	DWORD cbName = dwMax, cbDomain = dwMax;
	TCHAR szName[dwMax], szDomain[dwMax];

#pragma warning(push)
#pragma warning(disable: 6202)
	/* Prefast false warning: we do not use cbName or cbDomain as char buffers when call LookupAccountSid.*/
	if(::LookupAccountSid(m_strSystem, _GetPSID(), szName, &cbName, szDomain, &cbDomain, &m_sidnameuse))
#pragma warning(pop)
	{
		m_strAccountName = szName;
		m_strDomain = szDomain;
	}
	else
	{
		switch(::GetLastError())
		{
		case ERROR_INSUFFICIENT_BUFFER:
		{
			LPTSTR pszName = m_strAccountName.GetBuffer(cbName);
			LPTSTR pszDomain = m_strDomain.GetBuffer(cbDomain);

			if (!::LookupAccountSid(m_strSystem, _GetPSID(), pszName, &cbName, pszDomain, &cbDomain, &m_sidnameuse))
				AtlThrowLastWin32();

			m_strAccountName.ReleaseBuffer();
			m_strDomain.ReleaseBuffer();
			break;
		}

		case ERROR_NONE_MAPPED:
			m_strAccountName.Empty();
			m_strDomain.Empty();
			m_sidnameuse = SidTypeUnknown;
			break;

		default:
			ATLASSERT(FALSE);
		}
	}
}

inline SID* CSid::_GetPSID() const throw()
{
	ATLASSUME(m_bValid);
	return reinterpret_cast<SID*>(const_cast<BYTE*>(m_buffer));
}

inline bool operator==(_In_ const CSid &lhs, _In_ const CSid &rhs) throw()
{
	if( lhs.GetPSID() == NULL || rhs.GetPSID() == NULL || !lhs.IsValid() || !rhs.IsValid() )
		return false;
	return 0 != ::EqualSid(const_cast<SID*>(lhs.GetPSID()), const_cast<SID*>(rhs.GetPSID()));
}

inline bool operator!=(_In_ const CSid &lhs, _In_ const CSid &rhs) throw()
{
	return !(lhs == rhs);
}

inline bool operator<(_In_ const CSid &lhs, _In_ const CSid &rhs) throw()
{
	// all other ordered comparisons are done in terms of this one
	const SID_IDENTIFIER_AUTHORITY* la = lhs.GetPSID_IDENTIFIER_AUTHORITY();
	const SID_IDENTIFIER_AUTHORITY* ra = rhs.GetPSID_IDENTIFIER_AUTHORITY();

	for (int i=0; i<6; i++)
	{
		if (la->Value[i] < ra->Value[i])
		{
			return true;
		}
		else if (la->Value[i] > ra->Value[i])
		{
			return false;
		}
	}

	for (UCHAR i=0; i<rhs.GetSubAuthorityCount(); i++)
	{
		if (lhs.GetSubAuthorityCount() == i)
		{
			// lhs is a prefix of rhs
			return true;
		}

		if (lhs.GetSubAuthority(i) < rhs.GetSubAuthority(i))
		{
			return true;
		}
		else if (lhs.GetSubAuthority(i) > rhs.GetSubAuthority(i))
		{
			return false;
		}
	}

	return false;
}

inline bool operator>(
	_In_ const CSid &lhs,
	_In_ const CSid &rhs) throw()
{
	return (rhs < lhs);
}

inline bool operator<=(
	_In_ const CSid &lhs,
	_In_ const CSid &rhs) throw()
{
	return !(rhs < lhs);
}

inline bool operator>=(
	_In_ const CSid &lhs,
	_In_ const CSid &rhs) throw()
{
	return !(lhs < rhs);
}

// **************************************************************
// Well-known sids

namespace Sids
{
__declspec(selectany) extern const SID_IDENTIFIER_AUTHORITY
	SecurityNullSidAuthority		= SECURITY_NULL_SID_AUTHORITY,
	SecurityWorldSidAuthority		= SECURITY_WORLD_SID_AUTHORITY,
	SecurityLocalSidAuthority		= SECURITY_LOCAL_SID_AUTHORITY,
	SecurityCreatorSidAuthority		= SECURITY_CREATOR_SID_AUTHORITY,
	SecurityNonUniqueAuthority		= SECURITY_NON_UNIQUE_AUTHORITY,
	SecurityNTAuthority				= SECURITY_NT_AUTHORITY;

// Universal
inline CSid Null() throw(...)
{
	return CSid(SecurityNullSidAuthority, 1, SECURITY_NULL_RID);
}
inline CSid World() throw(...)
{
	return CSid(SecurityWorldSidAuthority, 1, SECURITY_WORLD_RID);
}
inline CSid Local() throw(...)
{
	return CSid(SecurityLocalSidAuthority, 1, SECURITY_LOCAL_RID);
}
inline CSid CreatorOwner() throw(...)
{
	return CSid(SecurityCreatorSidAuthority, 1, SECURITY_CREATOR_OWNER_RID);
}
inline CSid CreatorGroup() throw(...)
{
	return CSid(SecurityCreatorSidAuthority, 1, SECURITY_CREATOR_GROUP_RID);
}
inline CSid CreatorOwnerServer() throw(...)
{
	return CSid(SecurityCreatorSidAuthority, 1, SECURITY_CREATOR_OWNER_SERVER_RID);
}
inline CSid CreatorGroupServer() throw(...)
{
	return CSid(SecurityCreatorSidAuthority, 1, SECURITY_CREATOR_GROUP_SERVER_RID);
}

// NT Authority
inline CSid Dialup() throw(...)
{
	return CSid(SecurityNTAuthority, 1, SECURITY_DIALUP_RID);
}
inline CSid Network() throw(...)
{
	return CSid(SecurityNTAuthority, 1, SECURITY_NETWORK_RID);
}
inline CSid Batch() throw(...)
{
	return CSid(SecurityNTAuthority, 1, SECURITY_BATCH_RID);
}
inline CSid Interactive() throw(...)
{
	return CSid(SecurityNTAuthority, 1, SECURITY_INTERACTIVE_RID);
}
inline CSid Service() throw(...)
{
	return CSid(SecurityNTAuthority, 1, SECURITY_SERVICE_RID);
}
inline CSid AnonymousLogon() throw(...)
{
	return CSid(SecurityNTAuthority, 1, SECURITY_ANONYMOUS_LOGON_RID);
}
inline CSid Proxy() throw(...)
{
	return CSid(SecurityNTAuthority, 1, SECURITY_PROXY_RID);
}
inline CSid ServerLogon() throw(...)
{
	return CSid(SecurityNTAuthority, 1, SECURITY_SERVER_LOGON_RID);
}
inline CSid Self() throw(...)
{
	return CSid(SecurityNTAuthority, 1, SECURITY_PRINCIPAL_SELF_RID);
}
inline CSid AuthenticatedUser() throw(...)
{
	return CSid(SecurityNTAuthority, 1, SECURITY_AUTHENTICATED_USER_RID);
}
inline CSid RestrictedCode() throw(...)
{
	return CSid(SecurityNTAuthority, 1, SECURITY_RESTRICTED_CODE_RID);
}
inline CSid TerminalServer() throw(...)
{
	return CSid(SecurityNTAuthority, 1, SECURITY_TERMINAL_SERVER_RID);
}
inline CSid System() throw(...)
{
	return CSid(SecurityNTAuthority, 1, SECURITY_LOCAL_SYSTEM_RID);
}


inline CSid NetworkService() throw(...)
{
	return CSid(SecurityNTAuthority, 1, SECURITY_NETWORK_SERVICE_RID);

}

// NT Authority\BUILTIN
inline CSid Admins() throw(...)
{
	return CSid(SecurityNTAuthority, 2, SECURITY_BUILTIN_DOMAIN_RID, DOMAIN_ALIAS_RID_ADMINS);
}
inline CSid Users() throw(...)
{
	return CSid(SecurityNTAuthority, 2, SECURITY_BUILTIN_DOMAIN_RID, DOMAIN_ALIAS_RID_USERS);
}
inline CSid Guests() throw(...)
{
	return CSid(SecurityNTAuthority, 2, SECURITY_BUILTIN_DOMAIN_RID, DOMAIN_ALIAS_RID_GUESTS);
}
inline CSid PowerUsers() throw(...)
{
	return CSid(SecurityNTAuthority, 2, SECURITY_BUILTIN_DOMAIN_RID, DOMAIN_ALIAS_RID_POWER_USERS);
}
inline CSid AccountOps() throw(...)
{
	return CSid(SecurityNTAuthority, 2, SECURITY_BUILTIN_DOMAIN_RID, DOMAIN_ALIAS_RID_ACCOUNT_OPS);
}
inline CSid SystemOps() throw(...)
{
	return CSid(SecurityNTAuthority, 2, SECURITY_BUILTIN_DOMAIN_RID, DOMAIN_ALIAS_RID_SYSTEM_OPS);
}
inline CSid PrintOps() throw(...)
{
	return CSid(SecurityNTAuthority, 2, SECURITY_BUILTIN_DOMAIN_RID, DOMAIN_ALIAS_RID_PRINT_OPS);
}
inline CSid BackupOps() throw(...)
{
	return CSid(SecurityNTAuthority, 2, SECURITY_BUILTIN_DOMAIN_RID, DOMAIN_ALIAS_RID_BACKUP_OPS);
}
inline CSid Replicator() throw(...)
{
	return CSid(SecurityNTAuthority, 2, SECURITY_BUILTIN_DOMAIN_RID, DOMAIN_ALIAS_RID_REPLICATOR);
}
inline CSid RasServers() throw(...)
{
	return CSid(SecurityNTAuthority, 2, SECURITY_BUILTIN_DOMAIN_RID, DOMAIN_ALIAS_RID_RAS_SERVERS);
}
inline CSid PreW2KAccess() throw(...)
{
	return CSid(SecurityNTAuthority, 2, SECURITY_BUILTIN_DOMAIN_RID, DOMAIN_ALIAS_RID_PREW2KCOMPACCESS);
}
} // namespace Sids

// **************************************************************
// CAcl implementation

inline CAcl::CAcl() throw() :
	m_pAcl(NULL),
	m_bNull(false),
	m_dwAclRevision(ACL_REVISION)
{
}

inline CAcl::~CAcl() throw()
{
	free(m_pAcl);
}

inline CAcl::CAcl(_In_ const CAcl &rhs) throw(...) :
	m_pAcl(NULL),
	m_bNull(rhs.m_bNull),
	m_dwAclRevision(rhs.m_dwAclRevision)
{
}

inline CAcl &CAcl::operator=(_In_ const CAcl &rhs) throw(...)
{
	if(this != &rhs)
	{
		free(m_pAcl);
		m_pAcl = NULL;
		m_bNull = rhs.m_bNull;
		m_dwAclRevision = rhs.m_dwAclRevision;
	}
	return *this;
}

inline void CAcl::GetAclEntries(
	_Out_ CSid::CSidArray *pSids,
	_Out_opt_ CAccessMaskArray *pAccessMasks /* = NULL */,
	_Out_opt_ CAceTypeArray *pAceTypes /* = NULL */,
	_Out_opt_ CAceFlagArray *pAceFlags /* = NULL */) const throw(...)
{
	ATLASSERT(pSids);
	if(pSids)
	{
		pSids->RemoveAll();
		if(pAccessMasks)
			pAccessMasks->RemoveAll();
		if(pAceTypes)
			pAceTypes->RemoveAll();
		if(pAceFlags)
			pAceFlags->RemoveAll();

		const CAce *pAce;
		const UINT nCount = GetAceCount();
		for(UINT i = 0; i < nCount; i++)
		{
			pAce = GetAce(i);

			pSids->Add(pAce->Sid());
			if(pAccessMasks)
				pAccessMasks->Add(pAce->AccessMask());
			if(pAceTypes)
				pAceTypes->Add(pAce->AceType());
			if(pAceFlags)
				pAceFlags->Add(pAce->AceFlags());
		}
	}
}

inline void CAcl::GetAclEntry(
	_In_ UINT nIndex,
	_Inout_opt_ CSid* pSid,
	_Out_opt_ ACCESS_MASK* pMask /* = NULL */,
	_Out_opt_ BYTE* pType /* = NULL */,
	_Out_opt_ BYTE* pFlags /* = NULL */,
	_Out_opt_ GUID* pObjectType /* = NULL */,
	_Out_opt_ GUID* pInheritedObjectType /* = NULL */) const throw(...)
{
	const CAce* pAce = GetAce(nIndex);

	if (pSid)
		*pSid = pAce->Sid();
	if (pMask)
		*pMask = pAce->AccessMask();
	if (pType)
		*pType = pAce->AceType();
	if (pFlags)
		*pFlags = pAce->AceFlags();
	if (pObjectType)
		*pObjectType = pAce->ObjectType();
	if (pInheritedObjectType)
		*pInheritedObjectType = pAce->InheritedObjectType();
}

inline bool CAcl::RemoveAces(_In_ const CSid &rSid) throw(...)
{
	ATLASSERT(rSid.IsValid());
	if (!rSid.IsValid())
		AtlThrow(E_INVALIDARG);

	if(IsNull())
		return false;

	bool bRet = false;
	const CAce *pAce;
	UINT nIndex = 0;

	while(nIndex < GetAceCount())
	{
		pAce = GetAce(nIndex);
		if(rSid == pAce->Sid())
		{
			RemoveAce(nIndex);
			bRet = true;
		}
		else
			nIndex++;
	}

	if(bRet)
		Dirty();

	return bRet;
}

inline const ACL *CAcl::GetPACL() const throw(...)
{
	if(!m_pAcl && !m_bNull)
	{
		UINT nAclLength = sizeof(ACL);
		const CAce *pAce;
		UINT i;
		const UINT nCount = GetAceCount();

		for(i = 0; i < nCount; i++)
		{
			pAce = GetAce(i);
			ATLASSERT(pAce);
			if(pAce)
				nAclLength += pAce->GetLength();
		}

		m_pAcl = static_cast<ACL *>(malloc(nAclLength));
		if(!m_pAcl)
			AtlThrow(E_OUTOFMEMORY);

		if(!::InitializeAcl(m_pAcl, (DWORD) nAclLength, m_dwAclRevision))
		{
			HRESULT hr = AtlHresultFromLastError();
			free(m_pAcl);
			m_pAcl = NULL;
			AtlThrow(hr);
		}
		else
		{
			PrepareAcesForACL();

			for(i = 0; i < nCount; i++)
			{
				pAce = GetAce(i);
				ATLASSERT(pAce);
				if(!pAce ||
					!::AddAce(m_pAcl, m_dwAclRevision, MAXDWORD, pAce->GetACE(), (DWORD) pAce->GetLength()))
				{
					HRESULT hr = AtlHresultFromLastError();
					free(m_pAcl);
					m_pAcl = NULL;
					AtlThrow(hr);
				}
			}
		}
	}
	return m_pAcl;
}

inline CAcl::operator const ACL *() const throw(...)
{
	return GetPACL();
}

inline UINT CAcl::GetLength() const throw(...)
{
	ACL *pAcl = const_cast<ACL *>(GetPACL());
	ACL_SIZE_INFORMATION AclSize;

	ATLENSURE(pAcl);

	if(!::GetAclInformation(pAcl, &AclSize, sizeof(AclSize), AclSizeInformation))
		AtlThrowLastWin32();

	return AclSize.AclBytesInUse;
}

inline void CAcl::SetNull() throw()
{
	RemoveAllAces();
	m_bNull = true;
}

inline void CAcl::SetEmpty() throw()
{
	RemoveAllAces();
	m_bNull = false;
}

inline bool CAcl::IsNull() const throw()
{
	return m_bNull;
}

inline bool CAcl::IsEmpty() const throw()
{
	return !m_bNull && 0 == GetAceCount();
}

inline void CAcl::Dirty() throw()
{
	free(m_pAcl);
	m_pAcl = NULL;
}

inline void CAcl::PrepareAcesForACL() const throw()
{
}

// **************************************************************
// CAcl::CAce implementation

inline CAcl::CAce::CAce(
		_In_ const CSid &rSid,
		_In_ ACCESS_MASK accessmask,
		_In_ BYTE aceflags) throw(...) :
	m_dwAccessMask(accessmask),
	m_sid(rSid),
	m_aceflags(aceflags),
	m_pAce(NULL)
{
}

inline CAcl::CAce::~CAce() throw()
{
	if(m_pAce)
	{
		free(m_pAce);
		m_pAce = NULL;
	}
}

inline CAcl::CAce::CAce(_In_ const CAce &rhs) throw(...) :
	m_sid(rhs.m_sid),
	m_dwAccessMask(rhs.m_dwAccessMask),
	m_aceflags(rhs.m_aceflags),
	m_pAce(NULL)
{
}

inline CAcl::CAce &CAcl::CAce::operator=(_In_ const CAce &rhs) throw(...)
{
	if(this != &rhs)
	{
		m_sid = rhs.m_sid;
		m_dwAccessMask = rhs.m_dwAccessMask;
		m_aceflags = rhs.m_aceflags;
		if(m_pAce)
		{
			free(m_pAce);
		}
		m_pAce = NULL;
	}
	return *this;
}

inline bool CAcl::CAce::IsObjectAce() const throw()
{
	return false;
}

inline GUID CAcl::CAce::ObjectType() const throw()
{
	return GUID_NULL;
}

inline GUID CAcl::CAce::InheritedObjectType() const throw()
{
	return GUID_NULL;
}

inline ACCESS_MASK CAcl::CAce::AccessMask() const throw()
{
	return m_dwAccessMask;
}

inline BYTE CAcl::CAce::AceFlags() const throw()
{
	return m_aceflags;
}

inline const CSid &CAcl::CAce::Sid() const throw()
{
	return m_sid;
}

inline void CAcl::CAce::AddAccess(_In_ ACCESS_MASK accessmask) throw()
{
	m_dwAccessMask |= accessmask;
	if(m_pAce)
	{
		free(m_pAce);
		m_pAce = NULL;
	}
}

// ************************************************
// CDacl implementation

inline CDacl::CDacl() throw()
{
}

inline CDacl::~CDacl() throw()
{
	CDacl::RemoveAllAces();
}

inline CDacl::CDacl(_In_ const CDacl &rhs) throw(...)
{
	Copy(rhs);
}

inline CDacl &CDacl::operator=(_In_ const CDacl &rhs) throw(...)
{
	if (this != &rhs)
	{
		RemoveAllAces();
		Copy(rhs);
	}

	return *this;
}

inline CDacl::CDacl(_In_ const ACL &rhs) throw(...)
{
	Copy(rhs);
}

inline CDacl &CDacl::operator=(_In_ const ACL &rhs) throw(...)
{
	RemoveAllAces();

	Copy(rhs);
	return *this;
}

inline bool CDacl::AddAllowedAce(
	_In_ const CSid &rSid,
	_In_ ACCESS_MASK accessmask,
	_In_ BYTE aceflags /* = 0 */) throw(...)
{
	ATLASSERT(rSid.IsValid());
	if(!rSid.IsValid())
		return false;

	if (IsNull())
		SetEmpty();

	CAutoPtr<CAccessAce> pAce;
	ATLTRY(pAce.Attach(new CAccessAce(rSid, accessmask, aceflags, true)));
	if(!pAce)
		AtlThrow(E_OUTOFMEMORY);

	m_acl.Add(pAce);

	Dirty();
	return true;
}

inline bool CDacl::AddDeniedAce(
	_In_ const CSid &rSid,
	_In_ ACCESS_MASK accessmask,
	_In_ BYTE aceflags /* = 0 */) throw(...)
{
	ATLASSERT(rSid.IsValid());
	if(!rSid.IsValid())
		return false;

	if (IsNull())
		SetEmpty();

	CAutoPtr<CAccessAce> pAce;
	ATLTRY(pAce.Attach(new CAccessAce(rSid, accessmask, aceflags, false)));
	if(!pAce)
		AtlThrow(E_OUTOFMEMORY);

	m_acl.Add(pAce);

	Dirty();
	return true;
}

#if(_WIN32_WINNT >= 0x0500)
inline bool CDacl::AddAllowedAce(
	_In_ const CSid &rSid,
	_In_ ACCESS_MASK accessmask,
	_In_ BYTE aceflags,
	_In_ const GUID *pObjectType,
	_In_ const GUID *pInheritedObjectType) throw(...)
{
	if(!pObjectType && !pInheritedObjectType)
		return AddAllowedAce(rSid, accessmask, aceflags);

	ATLASSERT(rSid.IsValid());
	if(!rSid.IsValid())
		return false;

	if (IsNull())
		SetEmpty();

	CAutoPtr<CAccessAce> pAce;
	ATLTRY(pAce.Attach(new CAccessObjectAce(rSid, accessmask, aceflags, true,
		pObjectType, pInheritedObjectType)));
	if(!pAce)
		AtlThrow(E_OUTOFMEMORY);

	m_acl.Add(pAce);

	m_dwAclRevision = ACL_REVISION_DS;
	Dirty();
	return true;
}
#endif

#if(_WIN32_WINNT >= 0x0500)
inline bool CDacl::AddDeniedAce(
	_In_ const CSid &rSid,
	_In_ ACCESS_MASK accessmask,
	_In_ BYTE aceflags,
	_In_ const GUID *pObjectType,
	_In_ const GUID *pInheritedObjectType) throw(...)
{
	if(!pObjectType && !pInheritedObjectType)
		return AddDeniedAce(rSid, accessmask, aceflags);

	ATLASSERT(rSid.IsValid());
	if(!rSid.IsValid())
		return false;

	if (IsNull())
		SetEmpty();

	CAutoPtr<CAccessAce> pAce;
	ATLTRY(pAce.Attach(new CAccessObjectAce(rSid, accessmask, aceflags, false,
		pObjectType, pInheritedObjectType)));
	if(!pAce)
		AtlThrow(E_OUTOFMEMORY);

	m_acl.Add(pAce);

	m_dwAclRevision = ACL_REVISION_DS;
	Dirty();
	return true;
}
#endif

inline void CDacl::RemoveAllAces() throw()
{
	m_acl.RemoveAll();
	Dirty();
}

inline void CDacl::RemoveAce(UINT nIndex)
{
	m_acl.RemoveAt(nIndex);
}

inline UINT CDacl::GetAceCount() const throw()
{
	return (UINT) m_acl.GetCount();
}

inline void CDacl::Copy(_In_ const CDacl &rhs) throw(...)
{
	CSid sid;
	ACCESS_MASK accessmask;
	BYTE type;
	BYTE flags;
	GUID guidType;
	GUID guidInheritedType;
	CAutoPtr<CAccessAce> pAce;

	Dirty();

	if (rhs.IsNull())
		SetNull();
	else
		SetEmpty();

	m_dwAclRevision = rhs.m_dwAclRevision;

	for(UINT i=0; i<rhs.GetAceCount(); i++)
	{
		rhs.GetAclEntry(i, &sid, &accessmask, &type, &flags, &guidType, &guidInheritedType);
		switch (type)
		{
		case ACCESS_ALLOWED_ACE_TYPE:
		case ACCESS_DENIED_ACE_TYPE:
			ATLTRY(pAce.Attach(new CAccessAce(sid, accessmask, flags, ACCESS_ALLOWED_ACE_TYPE == type)));
			if (!pAce)
				AtlThrow(E_OUTOFMEMORY);
			m_acl.Add(pAce);
			break;

#if(_WIN32_WINNT >= 0x0500)
		case ACCESS_ALLOWED_OBJECT_ACE_TYPE:
		case ACCESS_DENIED_OBJECT_ACE_TYPE:
		{
			GUID *pguidType = NULL;
			GUID *pguidInheritedType = NULL;
			if(guidType != GUID_NULL)
			{
				pguidType = &guidType;
			}

			if(guidInheritedType != GUID_NULL)
			{
				pguidInheritedType = &guidInheritedType;
			}

			ATLTRY(pAce.Attach(new CAccessObjectAce(
					sid,
					accessmask,
					flags,
					ACCESS_ALLOWED_OBJECT_ACE_TYPE == type,
					pguidType,
					pguidInheritedType)));
			if (!pAce)
				AtlThrow(E_OUTOFMEMORY);
			m_acl.Add(pAce);
			break;
		}
#endif

		default:
			// Wrong ACE type
			ATLASSERT(false);
		}
	}
}

inline void CDacl::Copy(_In_ const ACL &rhs) throw(...)
{
	ACL *pAcl = const_cast<ACL *>(&rhs);
	if (pAcl == NULL)
	{
		SetNull();
		return;
	}
	ACL_SIZE_INFORMATION aclsizeinfo;
	ACL_REVISION_INFORMATION aclrevisioninfo;
	ACE_HEADER *pHeader;
	CSid sid;
	ACCESS_MASK accessmask;
	CAutoPtr<CAccessAce> pAce;

	Dirty();

	if(!::GetAclInformation(pAcl, &aclsizeinfo, sizeof(aclsizeinfo), AclSizeInformation))
		AtlThrowLastWin32();

	if(!::GetAclInformation(pAcl, &aclrevisioninfo, sizeof(aclrevisioninfo), AclRevisionInformation))
		AtlThrowLastWin32();
	m_dwAclRevision = aclrevisioninfo.AclRevision;

	for(DWORD i = 0; i < aclsizeinfo.AceCount; i++)
	{
		if(!::GetAce(pAcl, i, reinterpret_cast<void **>(&pHeader)))
			AtlThrowLastWin32();

		accessmask = *reinterpret_cast<ACCESS_MASK *>
			(reinterpret_cast<BYTE *>(pHeader) + sizeof(ACE_HEADER));

		switch(pHeader->AceType)
		{
		case ACCESS_ALLOWED_ACE_TYPE:
		case ACCESS_DENIED_ACE_TYPE:
			sid = *reinterpret_cast<SID *>
				(reinterpret_cast<BYTE *>(pHeader) + sizeof(ACE_HEADER) + sizeof(ACCESS_MASK));

			ATLTRY(pAce.Attach(new CAccessAce(sid, accessmask, pHeader->AceFlags,
				ACCESS_ALLOWED_ACE_TYPE == pHeader->AceType)));
			if (!pAce)
				AtlThrow(E_OUTOFMEMORY);
			m_acl.Add(pAce);
			break;

#if(_WIN32_WINNT >= 0x0500)
		case ACCESS_ALLOWED_OBJECT_ACE_TYPE:
		case ACCESS_DENIED_OBJECT_ACE_TYPE:
		{
			GUID *pObjectType = NULL, *pInheritedObjectType = NULL;
			BYTE *pb = reinterpret_cast<BYTE *>
				(pHeader) + offsetof(ACCESS_ALLOWED_OBJECT_ACE, SidStart);
			DWORD dwFlags = reinterpret_cast<ACCESS_ALLOWED_OBJECT_ACE *>(pHeader)->Flags;

			if(dwFlags & ACE_OBJECT_TYPE_PRESENT)
			{
				pObjectType = reinterpret_cast<GUID *>
					(reinterpret_cast<BYTE *>(pHeader) +
					offsetof(ACCESS_ALLOWED_OBJECT_ACE, ObjectType));
			}
			else
				pb -= sizeof(GUID);

			if(dwFlags & ACE_INHERITED_OBJECT_TYPE_PRESENT)
			{
				pInheritedObjectType = reinterpret_cast<GUID *>
					(reinterpret_cast<BYTE *>(pHeader) +
					(pObjectType ?
					offsetof(ACCESS_ALLOWED_OBJECT_ACE, InheritedObjectType) :
					offsetof(ACCESS_ALLOWED_OBJECT_ACE, ObjectType)));
			}
			else
				pb -= sizeof(GUID);

			sid = *reinterpret_cast<SID *>(pb);

			ATLTRY(pAce.Attach(new CAccessObjectAce(sid, accessmask, pHeader->AceFlags,
				ACCESS_ALLOWED_OBJECT_ACE_TYPE == pHeader->AceType,
				pObjectType, pInheritedObjectType)));
			if (!pAce)
				AtlThrow(E_OUTOFMEMORY);
			m_acl.Add(pAce);
			break;
		}
#endif

		default:
			// Wrong ACE type
			ATLASSERT(false);
		}
	}
}

inline const CDacl::CAce *CDacl::GetAce(_In_ UINT nIndex) const
{
	return m_acl[nIndex];
}

inline void CDacl::PrepareAcesForACL() const throw()
{
	// For a dacl, sort the aces
	size_t i, j, h = 1;
	const size_t nCount = m_acl.GetCount();
	CAutoPtr<CAccessAce> spAce;

	while(h * 3 + 1 < nCount)
		h = 3 * h + 1;

	while(h > 0)
	{
		for(i = h - 1; i < nCount; i++)
		{
			spAce = m_acl[i];

			for(j = i; j >= h && CAccessAce::Order(*m_acl[j - h], *spAce) == -1; j -= h)
				m_acl[j] = m_acl[j - h];

			m_acl[j] = spAce;
		}

		h /= 3;
	}
}

// ************************************************
// CDacl::CAccessAce implementation

inline CDacl::CAccessAce::CAccessAce(
		_In_ const CSid &rSid,
		_In_ ACCESS_MASK accessmask,
		_In_ BYTE aceflags,
		_In_ bool bAllowAccess) throw(...) :
	CAce(rSid, accessmask, aceflags),
	m_bAllow(bAllowAccess)
{
}

inline CDacl::CAccessAce::~CAccessAce() throw()
{
}

inline void *CDacl::CAccessAce::GetACE() const throw(...)
{
	C_ASSERT(sizeof(ACCESS_ALLOWED_ACE) == sizeof(ACCESS_DENIED_ACE));
	C_ASSERT(offsetof(ACCESS_ALLOWED_ACE, Header)==offsetof(ACCESS_DENIED_ACE, Header));
	C_ASSERT(offsetof(ACCESS_ALLOWED_ACE, Mask)==offsetof(ACCESS_DENIED_ACE, Mask));
	C_ASSERT(offsetof(ACCESS_ALLOWED_ACE, SidStart)==offsetof(ACCESS_DENIED_ACE, SidStart));

	if(!m_pAce)
	{
		UINT nLength = GetLength();
		ACCESS_ALLOWED_ACE *pAce = static_cast<ACCESS_ALLOWED_ACE *>(malloc(nLength));
		if(!pAce)
			AtlThrow(E_OUTOFMEMORY);

		memset(pAce, 0x00, nLength);

		pAce->Header.AceSize = static_cast<WORD>(nLength);
		pAce->Header.AceFlags = m_aceflags;
		pAce->Header.AceType = AceType();

		pAce->Mask = m_dwAccessMask;
		ATLASSERT(nLength-offsetof(ACCESS_ALLOWED_ACE, SidStart) >= m_sid.GetLength());
		Checked::memcpy_s(&pAce->SidStart, nLength-offsetof(ACCESS_ALLOWED_ACE, SidStart), m_sid.GetPSID(), m_sid.GetLength());

		m_pAce = pAce;
	}
	return m_pAce;
}

inline UINT CDacl::CAccessAce::GetLength() const throw()
{
	return offsetof(ACCESS_ALLOWED_ACE, SidStart) + m_sid.GetLength();
}

inline BYTE CDacl::CAccessAce::AceType() const throw()
{
	return (BYTE)(m_bAllow ? ACCESS_ALLOWED_ACE_TYPE : ACCESS_DENIED_ACE_TYPE);
}

inline bool CDacl::CAccessAce::Allow() const throw()
{
	return m_bAllow;
}

inline bool CDacl::CAccessAce::Inherited() const throw()
{
	return 0 != (m_aceflags & INHERITED_ACE);
}

inline int CDacl::CAccessAce::Order(
	_In_ const CDacl::CAccessAce &lhs,
	_In_ const CDacl::CAccessAce &rhs) throw()
{
	// The order is:
	// denied direct aces
	// denied direct object aces
	// allowed direct aces
	// allowed direct object aces
	// denied inherit aces
	// denied inherit object aces
	// allowed inherit aces
	// allowed inherit object aces

	// inherited aces are always "greater" than non-inherited aces
	if(lhs.Inherited() && !rhs.Inherited())
		return -1;
	if(!lhs.Inherited() && rhs.Inherited())
		return 1;

	// if the aces are *both* either inherited or non-inherited, continue...

	// allowed aces are always "greater" than denied aces (subject to above)
	if(lhs.Allow() && !rhs.Allow())
		return -1;
	if(!lhs.Allow() && rhs.Allow())
		return 1;

	// if the aces are *both* either allowed or denied, continue...

	// object aces are always "greater" than non-object aces (subject to above)
	if(lhs.IsObjectAce() && !rhs.IsObjectAce())
		return -1;
	if(!lhs.IsObjectAce() && rhs.IsObjectAce())
		return 1;

	// aces are "equal" (e.g., both are access denied inherited object aces)
	return 0;
}

#if(_WIN32_WINNT >= 0x0500)
// ************************************************
// CDacl::CAccessObjectAce implementation

inline CDacl::CAccessObjectAce::CAccessObjectAce(
		_In_ const CSid &rSid,
		_In_ ACCESS_MASK accessmask,
		_In_ BYTE aceflags,
		_In_ bool bAllowAccess,
		_In_opt_ const GUID *pObjectType,
		_In_opt_ const GUID *pInheritedObjectType) throw(...) :
	CAccessAce(rSid, accessmask, aceflags, bAllowAccess),
	m_pObjectType(NULL),
	m_pInheritedObjectType(NULL)
{
	if(pObjectType)
	{
		ATLTRY(m_pObjectType = new GUID(*pObjectType));
		if(!m_pObjectType)
			AtlThrow(E_OUTOFMEMORY);
	}

	if(pInheritedObjectType)
	{
		ATLTRY(m_pInheritedObjectType = new GUID(*pInheritedObjectType));
		if(!m_pInheritedObjectType)
		{
			delete m_pObjectType;
			m_pObjectType = NULL;
			AtlThrow(E_OUTOFMEMORY);
		}
	}
}

inline CDacl::CAccessObjectAce::~CAccessObjectAce() throw()
{
	delete m_pObjectType;
	delete m_pInheritedObjectType;
}

inline CDacl::CAccessObjectAce::CAccessObjectAce(_In_ const CAccessObjectAce &rhs) throw(...) :
	CAccessAce(rhs),
	m_pObjectType(NULL),
	m_pInheritedObjectType(NULL)
{
	*this = rhs;
}

inline CDacl::CAccessObjectAce &CDacl::CAccessObjectAce::operator=(
	_In_ const CAccessObjectAce &rhs) throw(...)
{
	if(this != &rhs)
	{
		CAccessAce::operator=(rhs);

		if(rhs.m_pObjectType)
		{
			if(!m_pObjectType)
			{
				ATLTRY(m_pObjectType = new GUID);
				if(!m_pObjectType)
					AtlThrow(E_OUTOFMEMORY);
			}
			*m_pObjectType = *rhs.m_pObjectType;
		}
		else
		{
			delete m_pObjectType;
			m_pObjectType = NULL;
		}

		if(rhs.m_pInheritedObjectType)
		{
			if(!m_pInheritedObjectType)
			{
				ATLTRY(m_pInheritedObjectType = new GUID);
				if(!m_pInheritedObjectType)
				{
					delete m_pObjectType;
					m_pObjectType = NULL;
					AtlThrow(E_OUTOFMEMORY);
				}
			}
			*m_pInheritedObjectType = *rhs.m_pInheritedObjectType;
		}
		else
		{
			delete m_pInheritedObjectType;
			m_pInheritedObjectType = NULL;
		}
	}
	return *this;
}

inline void *CDacl::CAccessObjectAce::GetACE() const throw(...)
{
	C_ASSERT(sizeof(ACCESS_ALLOWED_OBJECT_ACE) == sizeof(ACCESS_DENIED_OBJECT_ACE));
	C_ASSERT(offsetof(ACCESS_ALLOWED_OBJECT_ACE, Header)==offsetof(ACCESS_DENIED_OBJECT_ACE, Header));
	C_ASSERT(offsetof(ACCESS_ALLOWED_OBJECT_ACE, Mask)==offsetof(ACCESS_DENIED_OBJECT_ACE, Mask));
	C_ASSERT(offsetof(ACCESS_ALLOWED_OBJECT_ACE, Flags)==offsetof(ACCESS_DENIED_OBJECT_ACE, Flags));
	C_ASSERT(offsetof(ACCESS_ALLOWED_OBJECT_ACE, ObjectType)==offsetof(ACCESS_DENIED_OBJECT_ACE, ObjectType));
	C_ASSERT(offsetof(ACCESS_ALLOWED_OBJECT_ACE, InheritedObjectType)==offsetof(ACCESS_DENIED_OBJECT_ACE, InheritedObjectType));
	C_ASSERT(offsetof(ACCESS_ALLOWED_OBJECT_ACE, SidStart)==offsetof(ACCESS_DENIED_OBJECT_ACE, SidStart));

	if(!m_pAce)
	{
		UINT nLength = GetLength();

		ACCESS_ALLOWED_OBJECT_ACE *pAce = static_cast<ACCESS_ALLOWED_OBJECT_ACE *>(malloc(nLength));
		if(!pAce)
			AtlThrow(E_OUTOFMEMORY);

		memset(pAce, 0x00, nLength);

		pAce->Header.AceSize = static_cast<WORD>(nLength);
		pAce->Header.AceFlags = m_aceflags;
		pAce->Header.AceType = AceType();

		pAce->Mask = m_dwAccessMask;
		pAce->Flags = 0;

		BYTE *pb = (reinterpret_cast<BYTE *>(pAce)) + offsetof(ACCESS_ALLOWED_OBJECT_ACE, SidStart);
		if(!m_pObjectType)
			pb -= sizeof(GUID);
		else
		{
			pAce->ObjectType = *m_pObjectType;
			pAce->Flags |= ACE_OBJECT_TYPE_PRESENT;
		}

		if(!m_pInheritedObjectType)
			pb -= sizeof(GUID);
		else
		{
			if(m_pObjectType)
				pAce->InheritedObjectType = *m_pInheritedObjectType;
			else
				pAce->ObjectType = *m_pInheritedObjectType;
			pAce->Flags |= ACE_INHERITED_OBJECT_TYPE_PRESENT;
		}
		
		size_t sidSpaceAvailable = nLength - (pb - reinterpret_cast<BYTE*>(pAce));
		if (sidSpaceAvailable > nLength)
		{
			sidSpaceAvailable = 0;
		}
		
		ATLASSERT(sidSpaceAvailable >= m_sid.GetLength());
		Checked::memcpy_s(pb, sidSpaceAvailable, m_sid.GetPSID(), m_sid.GetLength());
		m_pAce = pAce;
	}
	return m_pAce;
}

inline UINT CDacl::CAccessObjectAce::GetLength() const throw()
{
	UINT nLength = offsetof(ACCESS_ALLOWED_OBJECT_ACE, SidStart);

	if(!m_pObjectType)
		nLength -= sizeof(GUID);
	if(!m_pInheritedObjectType)
		nLength -= sizeof(GUID);

	nLength += m_sid.GetLength();

	return nLength;
}

inline BYTE CDacl::CAccessObjectAce::AceType() const throw()
{
	return (BYTE)(m_bAllow ? ACCESS_ALLOWED_OBJECT_ACE_TYPE : ACCESS_DENIED_OBJECT_ACE_TYPE);
}

inline bool CDacl::CAccessObjectAce::IsObjectAce() const throw()
{
	return true;
}

inline GUID CDacl::CAccessObjectAce::ObjectType() const throw()
{
	return m_pObjectType ? *m_pObjectType : GUID_NULL;
}

inline GUID CDacl::CAccessObjectAce::InheritedObjectType() const throw()
{
	return m_pInheritedObjectType ? *m_pInheritedObjectType : GUID_NULL;
}
#endif // _WIN32_WINNT

//******************************************
// CSacl implementation

inline CSacl::CSacl() throw()
{
}

inline CSacl::~CSacl() throw()
{
	CSacl::RemoveAllAces();
}

inline CSacl::CSacl(_In_ const CSacl &rhs) throw(...)
{
	Copy(rhs);
}

inline CSacl &CSacl::operator=(_In_ const CSacl &rhs) throw(...)
{
	if (this != &rhs)
	{
		RemoveAllAces();
		Copy(rhs);
	}

	return *this;
}

inline CSacl::CSacl(_In_ const ACL &rhs) throw(...)
{
	Copy(rhs);
}

inline CSacl &CSacl::operator=(_In_ const ACL &rhs) throw(...)
{
	RemoveAllAces();

	Copy(rhs);
	return *this;
}

inline bool CSacl::AddAuditAce(
	_In_ const CSid &rSid,
	_In_ ACCESS_MASK accessmask,
	_In_ bool bSuccess,
	_In_ bool bFailure,
	_In_ BYTE aceflags /* = 0 */) throw(...)
{
	ATLASSERT(rSid.IsValid());
	if(!rSid.IsValid())
		return false;

	if (IsNull())
		SetEmpty();

	CAutoPtr<CAuditAce> pAce;
	ATLTRY(pAce.Attach(new CAuditAce(rSid, accessmask, aceflags, bSuccess, bFailure)))
	if(!pAce)
		AtlThrow(E_OUTOFMEMORY);

	m_acl.Add(pAce);

	Dirty();
	return true;
}

#if(_WIN32_WINNT >= 0x0500)
inline bool CSacl::AddAuditAce(
	_In_ const CSid &rSid,
	_In_ ACCESS_MASK accessmask,
	_In_ bool bSuccess,
	_In_ bool bFailure,
	_In_ BYTE aceflags,
	_In_ const GUID *pObjectType,
	_In_ const GUID *pInheritedObjectType) throw(...)
{
	if(!pObjectType && !pInheritedObjectType)
		return AddAuditAce(rSid, accessmask, bSuccess, bFailure, aceflags);

	ATLASSERT(rSid.IsValid());
	if(!rSid.IsValid())
		return false;

	if (IsNull())
		SetEmpty();

	CAutoPtr<CAuditAce> pAce;
	ATLTRY(pAce.Attach(new CAuditObjectAce(rSid, accessmask, aceflags, bSuccess,
		bFailure, pObjectType, pInheritedObjectType)));
	if(!pAce)
		AtlThrow(E_OUTOFMEMORY);

	m_acl.Add(pAce);
	m_dwAclRevision = ACL_REVISION_DS;
	Dirty();
	return true;
}
#endif

inline void CSacl::RemoveAllAces() throw()
{
	m_acl.RemoveAll();
	Dirty();
}

inline void CSacl::RemoveAce(UINT nIndex)
{
	m_acl.RemoveAt(nIndex);
}

inline UINT CSacl::GetAceCount() const throw()
{
	return (UINT) m_acl.GetCount();
}

inline void CSacl::Copy(_In_ const CSacl &rhs) throw(...)
{
	CSid sid;
	ACCESS_MASK accessmask;
	BYTE type;
	BYTE flags;
	GUID guidType;
	GUID guidInheritedType;
	bool bSuccess;
	bool bFailure;
	CAutoPtr<CAuditAce> pAce;

	Dirty();

	if (rhs.IsNull())
		SetNull();
	else
		SetEmpty();

	m_dwAclRevision = rhs.m_dwAclRevision;

	for (UINT i=0; i<rhs.GetAceCount(); i++)
	{
		rhs.GetAclEntry(i, &sid, &accessmask, &type, &flags, &guidType, &guidInheritedType);

		bSuccess = 0 != (flags & SUCCESSFUL_ACCESS_ACE_FLAG);
		bFailure = 0 != (flags & FAILED_ACCESS_ACE_FLAG);

		switch (type)
		{
		case SYSTEM_AUDIT_ACE_TYPE:
			ATLTRY(pAce.Attach(new CAuditAce(sid, accessmask, flags, bSuccess, bFailure)));
			if (!pAce)
				AtlThrow(E_OUTOFMEMORY);
			m_acl.Add(pAce);
			break;

#if(_WIN32_WINNT >= 0x0500)
		case SYSTEM_AUDIT_OBJECT_ACE_TYPE:
		{
			GUID *pguidType = NULL;
			GUID *pguidInheritedType = NULL;
			if(guidType != GUID_NULL)
			{
				pguidType = &guidType;
			}

			if(guidInheritedType != GUID_NULL)
			{
				pguidInheritedType = &guidInheritedType;
			}

			ATLTRY(pAce.Attach(new CAuditObjectAce(
					sid,
					accessmask,
					flags,
					bSuccess,
					bFailure,
					pguidType,
					pguidInheritedType)));
			if(!pAce)
				AtlThrow(E_OUTOFMEMORY);
			m_acl.Add(pAce);
			break;
		}
#endif
		default:
			// Wrong ACE type
			ATLASSERT(false);
		}
	}
}

inline void CSacl::Copy(_In_ const ACL &rhs) throw(...)
{
	ACL *pAcl = const_cast<ACL *>(&rhs);
	ACL_SIZE_INFORMATION aclsizeinfo;
	ACL_REVISION_INFORMATION aclrevisioninfo;
	ACE_HEADER *pHeader;
	CSid sid;
	ACCESS_MASK accessmask;
	bool bSuccess, bFailure;
	CAutoPtr<CAuditAce> pAce;

	Dirty();

	if(!::GetAclInformation(pAcl, &aclsizeinfo, sizeof(aclsizeinfo), AclSizeInformation))
		AtlThrowLastWin32();

	if(!::GetAclInformation(pAcl, &aclrevisioninfo, sizeof(aclrevisioninfo), AclRevisionInformation))
		AtlThrowLastWin32();
	m_dwAclRevision = aclrevisioninfo.AclRevision;

	for(DWORD i = 0; i < aclsizeinfo.AceCount; i++)
	{
		if(!::GetAce(pAcl, i, reinterpret_cast<void **>(&pHeader)))
			AtlThrowLastWin32();

		accessmask = *reinterpret_cast<ACCESS_MASK *>
			(reinterpret_cast<BYTE *>(pHeader) + sizeof(ACE_HEADER));

		bSuccess = 0 != (pHeader->AceFlags & SUCCESSFUL_ACCESS_ACE_FLAG);
		bFailure = 0 != (pHeader->AceFlags & FAILED_ACCESS_ACE_FLAG);

		switch(pHeader->AceType)
		{
		case SYSTEM_AUDIT_ACE_TYPE:
			sid = *reinterpret_cast<SID *>
				(reinterpret_cast<BYTE *>(pHeader) +	sizeof(ACE_HEADER) + sizeof(ACCESS_MASK));
			ATLTRY(pAce.Attach(new CAuditAce(sid, accessmask, pHeader->AceFlags, bSuccess, bFailure)));
			if (!pAce)
				AtlThrow(E_OUTOFMEMORY);
			m_acl.Add(pAce);
			break;

#if(_WIN32_WINNT >= 0x0500)
		case SYSTEM_AUDIT_OBJECT_ACE_TYPE:
		{
			GUID *pObjectType = NULL, *pInheritedObjectType = NULL;
			BYTE *pb = reinterpret_cast<BYTE *>
				(pHeader) + offsetof(SYSTEM_AUDIT_OBJECT_ACE, SidStart);
			DWORD dwFlags = reinterpret_cast<SYSTEM_AUDIT_OBJECT_ACE *>(pHeader)->Flags;

			if(dwFlags & ACE_OBJECT_TYPE_PRESENT)
			{
				pObjectType = reinterpret_cast<GUID *>
					(reinterpret_cast<BYTE *>(pHeader) +
					offsetof(SYSTEM_AUDIT_OBJECT_ACE, ObjectType));
			}
			else
				pb -= sizeof(GUID);

			if(dwFlags & ACE_INHERITED_OBJECT_TYPE_PRESENT)
			{
				pInheritedObjectType = reinterpret_cast<GUID *>
					(reinterpret_cast<BYTE *>(pHeader) +
					(pObjectType ?
					offsetof(SYSTEM_AUDIT_OBJECT_ACE, InheritedObjectType) :
					offsetof(SYSTEM_AUDIT_OBJECT_ACE, ObjectType)));
			}
			else
				pb -= sizeof(GUID);

			sid = *reinterpret_cast<SID *>(pb);

			ATLTRY(pAce.Attach(new CAuditObjectAce(sid, accessmask, pHeader->AceFlags,
				bSuccess, bFailure, pObjectType, pInheritedObjectType)));
			if(!pAce)
				AtlThrow(E_OUTOFMEMORY);
			m_acl.Add(pAce);
			break;
		}
#endif
		default:
			// Wrong ACE type
			ATLASSERT(false);
		}
	}
}

inline const CSacl::CAce *CSacl::GetAce(_In_ UINT nIndex) const
{
	return m_acl[nIndex];
}

//******************************************
// CSacl::CAuditAce implementation

inline CSacl::CAuditAce::CAuditAce(
		_In_ const CSid &rSid,
		_In_ ACCESS_MASK accessmask,
		_In_ BYTE aceflags,
		_In_ bool bAuditSuccess,
		_In_ bool bAuditFailure) throw(...) :
	CAce(rSid, accessmask, aceflags),
	m_bSuccess(bAuditSuccess),
	m_bFailure(bAuditFailure)
{
	if (m_bSuccess)
		m_aceflags |= SUCCESSFUL_ACCESS_ACE_FLAG;
	if (m_bFailure)
		m_aceflags |= FAILED_ACCESS_ACE_FLAG;
}

inline CSacl::CAuditAce::~CAuditAce() throw()
{
}

inline void *CSacl::CAuditAce::GetACE() const throw(...)
{
	if(!m_pAce)
	{
		UINT nLength = GetLength();
		SYSTEM_AUDIT_ACE *pAce = static_cast<SYSTEM_AUDIT_ACE *>(malloc(nLength));
		if(!pAce)
			AtlThrow(E_OUTOFMEMORY);

		memset(pAce, 0x00, nLength);

		pAce->Header.AceSize = static_cast<WORD>(nLength);
		pAce->Header.AceFlags = m_aceflags;
		pAce->Header.AceType = AceType();

		pAce->Mask = m_dwAccessMask;
		ATLASSERT(nLength-offsetof(SYSTEM_AUDIT_ACE, SidStart) >= m_sid.GetLength());
		Checked::memcpy_s(&pAce->SidStart, nLength-offsetof(SYSTEM_AUDIT_ACE, SidStart), m_sid.GetPSID(), m_sid.GetLength());

		m_pAce = pAce;
	}
	return m_pAce;
}

inline UINT CSacl::CAuditAce::GetLength() const throw()
{
	return offsetof(SYSTEM_AUDIT_ACE, SidStart) + m_sid.GetLength();
}

inline BYTE CSacl::CAuditAce::AceType() const throw()
{
	return SYSTEM_AUDIT_ACE_TYPE;
}

#if(_WIN32_WINNT >= 0x0500)
//******************************************
// CSacl::CAuditObjectAce implementation

inline CSacl::CAuditObjectAce::CAuditObjectAce(
		_In_ const CSid &rSid,
		_In_ ACCESS_MASK accessmask,
		_In_ BYTE aceflags,
		_In_ bool bAuditSuccess,
		_In_ bool bAuditFailure,
		_In_opt_ const GUID *pObjectType,
		_In_opt_ const GUID *pInheritedObjectType) throw(...) :
	CAuditAce(rSid, accessmask, aceflags, bAuditSuccess, bAuditFailure),
	m_pObjectType(NULL),
	m_pInheritedObjectType(NULL)
{
	if(pObjectType)
	{
		ATLTRY(m_pObjectType = new GUID(*pObjectType));
		if(!m_pObjectType)
			AtlThrow(E_OUTOFMEMORY);
	}

	if(pInheritedObjectType)
	{
		ATLTRY(m_pInheritedObjectType = new GUID(*pInheritedObjectType));
		if(!m_pInheritedObjectType)
		{
			delete m_pObjectType;
			m_pObjectType = NULL;
			AtlThrow(E_OUTOFMEMORY);
		}
	}
}

inline CSacl::CAuditObjectAce::~CAuditObjectAce() throw()
{
	delete m_pObjectType;
	delete m_pInheritedObjectType;
}

inline CSacl::CAuditObjectAce::CAuditObjectAce(_In_ const CAuditObjectAce &rhs) throw(...) :
	CAuditAce(rhs),
	m_pObjectType(NULL),
	m_pInheritedObjectType(NULL)
{
	*this = rhs;
}

inline CSacl::CAuditObjectAce &CSacl::CAuditObjectAce::operator=(
	_In_ const CAuditObjectAce &rhs) throw(...)
{
	if(this != &rhs)
	{
		CAuditAce::operator=(rhs);

		if(rhs.m_pObjectType)
		{
			if(!m_pObjectType)
			{
				ATLTRY(m_pObjectType = new GUID);
				if(!m_pObjectType)
					AtlThrow(E_OUTOFMEMORY);
			}
			*m_pObjectType = *rhs.m_pObjectType;
		}
		else
		{
			delete m_pObjectType;
			m_pObjectType = NULL;
		}

		if(rhs.m_pInheritedObjectType)
		{
			if(!m_pInheritedObjectType)
			{
				ATLTRY(m_pInheritedObjectType = new GUID);
				if(!m_pInheritedObjectType)
				{
					delete m_pObjectType;
					m_pObjectType = NULL;
					AtlThrow(E_OUTOFMEMORY);
				}
			}
			*m_pInheritedObjectType = *rhs.m_pInheritedObjectType;
		}
		else
		{
			delete m_pInheritedObjectType;
			m_pInheritedObjectType = NULL;
		}
	}
	return *this;
}

inline void *CSacl::CAuditObjectAce::GetACE() const throw(...)
{
	if(!m_pAce)
	{
		UINT nLength = GetLength();
		SYSTEM_AUDIT_OBJECT_ACE *pAce = static_cast<SYSTEM_AUDIT_OBJECT_ACE *>(malloc(nLength));
		if(!pAce)
			AtlThrow(E_OUTOFMEMORY);

		memset(pAce, 0x00, nLength);

		pAce->Header.AceType = SYSTEM_AUDIT_OBJECT_ACE_TYPE;
		pAce->Header.AceSize = static_cast<WORD>(nLength);
		pAce->Header.AceFlags = m_aceflags;

		pAce->Mask = m_dwAccessMask;
		pAce->Flags = 0;

		if(m_bSuccess)
			pAce->Header.AceFlags |= SUCCESSFUL_ACCESS_ACE_FLAG;
		else
			pAce->Header.AceFlags &= ~SUCCESSFUL_ACCESS_ACE_FLAG;

		if(m_bFailure)
			pAce->Header.AceFlags |= FAILED_ACCESS_ACE_FLAG;
		else
			pAce->Header.AceFlags &= ~FAILED_ACCESS_ACE_FLAG;

		BYTE *pb = ((BYTE *) pAce) + offsetof(SYSTEM_AUDIT_OBJECT_ACE, SidStart);
		if(!m_pObjectType)
			pb -= sizeof(GUID);
		else
		{
			pAce->ObjectType = *m_pObjectType;
			pAce->Flags |= ACE_OBJECT_TYPE_PRESENT;
		}

		if(!m_pInheritedObjectType)
			pb -= sizeof(GUID);
		else
		{
			if(m_pObjectType)
				pAce->InheritedObjectType = *m_pInheritedObjectType;
			else
				pAce->ObjectType = *m_pInheritedObjectType;
			pAce->Flags |= ACE_INHERITED_OBJECT_TYPE_PRESENT;
		}

		size_t sidSpaceAvailable = nLength - (pb - reinterpret_cast<BYTE*>(pAce));
		if (sidSpaceAvailable > nLength)
		{
			sidSpaceAvailable = 0;
		}

		ATLASSERT(sidSpaceAvailable >= m_sid.GetLength());
		Checked::memcpy_s(pb, sidSpaceAvailable, m_sid.GetPSID(), m_sid.GetLength());
		m_pAce = pAce;
	}
	return m_pAce;
}

inline UINT CSacl::CAuditObjectAce::GetLength() const throw()
{
	UINT nLength = offsetof(SYSTEM_AUDIT_OBJECT_ACE, SidStart);

	if(!m_pObjectType)
		nLength -= sizeof(GUID);
	if(!m_pInheritedObjectType)
		nLength -= sizeof(GUID);

	nLength += m_sid.GetLength();

	return nLength;
}

inline BYTE CSacl::CAuditObjectAce::AceType() const throw()
{
	return SYSTEM_AUDIT_OBJECT_ACE_TYPE;
}

inline bool CSacl::CAuditObjectAce::IsObjectAce() const throw()
{
	return true;
}

inline GUID CSacl::CAuditObjectAce::ObjectType() const throw()
{
	return m_pObjectType ? *m_pObjectType : GUID_NULL;
}

inline GUID CSacl::CAuditObjectAce::InheritedObjectType() const throw()
{
	return m_pInheritedObjectType ? *m_pInheritedObjectType : GUID_NULL;
}
#endif

//******************************************
// CSecurityDesc implementation

inline CSecurityDesc::CSecurityDesc() throw() :
	m_pSecurityDescriptor(NULL)
{
}

inline CSecurityDesc::~CSecurityDesc() throw()
{
	Clear();
}

inline CSecurityDesc::CSecurityDesc(
		_In_ const CSecurityDesc &rhs) throw(...)
	: m_pSecurityDescriptor(NULL)
{
	if(rhs.m_pSecurityDescriptor)
		Init(*rhs.m_pSecurityDescriptor);
}

inline CSecurityDesc &CSecurityDesc::operator=(
	_In_ const CSecurityDesc &rhs) throw(...)
{
	if(this != &rhs)
	{
		Clear();
		if(rhs.m_pSecurityDescriptor)
			Init(*rhs.m_pSecurityDescriptor);
	}
	return *this;
}

inline CSecurityDesc::CSecurityDesc(
		_In_ const SECURITY_DESCRIPTOR &rhs) throw(...) :
	m_pSecurityDescriptor(NULL)
{
	Init(rhs);
}

inline CSecurityDesc &CSecurityDesc::operator=(
	_In_ const SECURITY_DESCRIPTOR &rhs) throw(...)
{
	if(m_pSecurityDescriptor != &rhs)
	{
		Clear();
		Init(rhs);
	}
	return *this;
}

#if(_WIN32_WINNT >= 0x0500)
inline bool CSecurityDesc::FromString(_In_z_ LPCTSTR pstr) throw(...)
{
	SECURITY_DESCRIPTOR *pSD;
	if(!::ConvertStringSecurityDescriptorToSecurityDescriptor(pstr, SDDL_REVISION_1,
			(PSECURITY_DESCRIPTOR *) &pSD, NULL))
		AtlThrowLastWin32();

	*this = *pSD;
	::LocalFree(pSD);

	return true;
}

inline bool CSecurityDesc::ToString(
	_In_ CString *pstr,
	_In_ SECURITY_INFORMATION si /* =
		OWNER_SECURITY_INFORMATION |
		GROUP_SECURITY_INFORMATION |
		DACL_SECURITY_INFORMATION |
		SACL_SECURITY_INFORMATION */) const throw(...)
{
	ATLASSERT(pstr);
	if(!pstr || !m_pSecurityDescriptor)
		return false;

	LPTSTR pszStringSecurityDescriptor;
	if(!::ConvertSecurityDescriptorToStringSecurityDescriptor(m_pSecurityDescriptor,
			SDDL_REVISION_1,
			si,
			&pszStringSecurityDescriptor,
			NULL))
		AtlThrowLastWin32();

	_ATLTRY
	{
		*pstr = pszStringSecurityDescriptor;
	}
	_ATLCATCHALL()
	{
		::LocalFree(pszStringSecurityDescriptor);
		throw;
	}

	::LocalFree(pszStringSecurityDescriptor);
	return true;
}
#endif

inline void CSecurityDesc::SetOwner(
	_In_ const CSid &sid,
	_In_ bool bDefaulted /* = false */) throw(...)
{
	if(m_pSecurityDescriptor)
		MakeAbsolute();

	PSID pNewOwner, pOldOwner;
	if(m_pSecurityDescriptor)
	{
		BOOL _bDefaulted;
		if(!::GetSecurityDescriptorOwner(m_pSecurityDescriptor, &pOldOwner, &_bDefaulted))
			AtlThrowLastWin32();
	}
	else
	{
		AllocateAndInitializeSecurityDescriptor();
		pOldOwner = NULL;
	}

	if(!sid.IsValid())
		AtlThrow(E_FAIL);

	UINT nSidLength = sid.GetLength();
	pNewOwner = malloc(nSidLength);
	if(!pNewOwner)
		AtlThrow(E_OUTOFMEMORY);

	if(!::CopySid((DWORD) nSidLength, pNewOwner, const_cast<SID *>(sid.GetPSID())) ||
		!::SetSecurityDescriptorOwner(m_pSecurityDescriptor, pNewOwner, bDefaulted))
	{
		HRESULT hr = AtlHresultFromLastError();
		free(pNewOwner);
		AtlThrow(hr);
	}

	free(pOldOwner);
}

inline void CSecurityDesc::SetGroup(
	_In_ const CSid &sid,
	_In_ bool bDefaulted /* = false */) throw(...)
{
	if(m_pSecurityDescriptor)
		MakeAbsolute();

	PSID pNewGroup, pOldGroup;
	if(m_pSecurityDescriptor)
	{
		BOOL _bDefaulted;
		if(!::GetSecurityDescriptorGroup(m_pSecurityDescriptor, &pOldGroup, &_bDefaulted))
			AtlThrowLastWin32();
	}
	else
	{
		AllocateAndInitializeSecurityDescriptor();
		pOldGroup = NULL;
	}

	if(!sid.IsValid())
		AtlThrow(E_FAIL);

	UINT nSidLength = sid.GetLength();
	pNewGroup = malloc(nSidLength);
	if(!pNewGroup)
		AtlThrow(E_OUTOFMEMORY);

	if(!::CopySid((DWORD) nSidLength, pNewGroup, const_cast<SID *>(sid.GetPSID())) ||
		!::SetSecurityDescriptorGroup(m_pSecurityDescriptor, pNewGroup, bDefaulted))
	{
		HRESULT hr = AtlHresultFromLastError();
		free(pNewGroup);
		AtlThrow(hr);
	}

	free(pOldGroup);
}

inline void CSecurityDesc::SetDacl(
	_In_ const CDacl &Dacl,
	_In_ bool bDefaulted /* = false */) throw(...)
{
	if(m_pSecurityDescriptor)
		MakeAbsolute();

	PACL pNewDacl, pOldDacl = NULL;
	if(m_pSecurityDescriptor)
	{
		BOOL _bDefaulted, _bPresent;
		if(!::GetSecurityDescriptorDacl(m_pSecurityDescriptor, &_bPresent, &pOldDacl, &_bDefaulted))
			AtlThrowLastWin32();
	}
	else
		AllocateAndInitializeSecurityDescriptor();

	if(Dacl.IsNull() || Dacl.IsEmpty())
		pNewDacl = NULL;
	else
	{
		UINT nAclLength = Dacl.GetLength();
		ATLASSUME(nAclLength > 0);

		pNewDacl = static_cast<ACL *>(malloc(nAclLength));
		if(!pNewDacl)
			AtlThrow(E_OUTOFMEMORY);

		Checked::memcpy_s(pNewDacl, nAclLength, Dacl.GetPACL(), nAclLength);
	}

#ifdef _DEBUG
	if(Dacl.IsNull())
	{
		// setting a NULL DACL is almost always the wrong thing to do
		ATLTRACE(atlTraceSecurity, 2, _T("Error: Setting Dacl to Null offers no security\n"));
		ATLASSERT(FALSE);
	}
#endif

	if(!::SetSecurityDescriptorDacl(m_pSecurityDescriptor, Dacl.IsNull() || pNewDacl, pNewDacl, bDefaulted))
	{
		HRESULT hr = AtlHresultFromLastError();
		free(pNewDacl);
		AtlThrow(hr);
	}

	free(pOldDacl);
}

inline void CSecurityDesc::SetDacl(
	_In_ bool bPresent,
	_In_ bool bDefaulted /* = false */) throw(...)
{
	if(m_pSecurityDescriptor)
		MakeAbsolute();

	PACL pOldDacl = NULL;
	if(m_pSecurityDescriptor)
	{
		BOOL _bDefaulted, _bPresent;
		if(!::GetSecurityDescriptorDacl(m_pSecurityDescriptor, &_bPresent, &pOldDacl, &_bDefaulted))
			AtlThrowLastWin32();
	}
	else
		AllocateAndInitializeSecurityDescriptor();

#ifdef _DEBUG
	if(bPresent)
	{
		// setting a NULL DACL is almost always the wrong thing to do
		ATLTRACE(atlTraceSecurity, 2, _T("Error: Setting Dacl to Null offers no security\n"));
		ATLASSERT(FALSE);
	}
#endif

	if(!::SetSecurityDescriptorDacl(m_pSecurityDescriptor, bPresent, NULL, bDefaulted))
		AtlThrowLastWin32();

	free(pOldDacl);
}

inline void CSecurityDesc::SetSacl(
	_In_ const CSacl &Sacl,
	_In_ bool bDefaulted /* = false */) throw(...)
{
	if(m_pSecurityDescriptor)
		MakeAbsolute();

	PACL pNewSacl, pOldSacl = NULL;
	if(m_pSecurityDescriptor)
	{
		BOOL _bDefaulted, _bPresent;
		if(!::GetSecurityDescriptorSacl(m_pSecurityDescriptor, &_bPresent, &pOldSacl, &_bDefaulted))
			AtlThrowLastWin32();
	}
	else
		AllocateAndInitializeSecurityDescriptor();

	if(Sacl.IsNull() || Sacl.IsEmpty())
		pNewSacl = NULL;
	else
	{
		UINT nAclLength = Sacl.GetLength();
		ATLASSERT(nAclLength > 0);

		pNewSacl = static_cast<ACL *>(malloc(nAclLength));
		if(!pNewSacl)
			AtlThrow(E_OUTOFMEMORY);

		Checked::memcpy_s(pNewSacl, nAclLength, Sacl.GetPACL(), nAclLength);
	}

	if(!::SetSecurityDescriptorSacl(m_pSecurityDescriptor, Sacl.IsNull() || pNewSacl, pNewSacl, bDefaulted))
	{
		HRESULT hr = AtlHresultFromLastError();
		free(pNewSacl);
		AtlThrow(hr);
	}

	free(pOldSacl);
}

inline bool CSecurityDesc::GetOwner(
	_Out_ CSid *pSid,
	_Out_opt_ bool *pbDefaulted /* = NULL */) const throw(...)
{
	ATLASSERT(pSid);
	SID *pOwner;
	BOOL bDefaulted;

	if(!pSid || !m_pSecurityDescriptor ||
		!::GetSecurityDescriptorOwner(m_pSecurityDescriptor, (PSID *) &pOwner, &bDefaulted))
	{
		return false;
	}

	*pSid = *pOwner;

	if(pbDefaulted)
		*pbDefaulted = 0 != bDefaulted;

	return true;
}

inline bool CSecurityDesc::GetGroup(
	_Out_ CSid *pSid,
	_Out_opt_ bool *pbDefaulted /* = NULL */) const throw(...)
{
	ATLASSERT(pSid);
	SID *pGroup;
	BOOL bDefaulted;

	if(!pSid || !m_pSecurityDescriptor ||
		!::GetSecurityDescriptorGroup(m_pSecurityDescriptor, (PSID *) &pGroup, &bDefaulted))
	{
		return false;
	}

	*pSid = *pGroup;

	if(pbDefaulted)
		*pbDefaulted = 0 != bDefaulted;

	return true;
}

inline bool CSecurityDesc::GetDacl(
	_Out_ CDacl *pDacl,
	_Out_opt_ bool *pbPresent /* = NULL */,
	_Out_opt_ bool *pbDefaulted /* = NULL */) const throw(...)
{
	ACL *pAcl;
	BOOL bPresent, bDefaulted;

	if(!m_pSecurityDescriptor ||
		!::GetSecurityDescriptorDacl(m_pSecurityDescriptor, &bPresent, &pAcl, &bDefaulted))
	{
		return false;
	}

	if(pDacl)
	{
		if(bPresent)
		{
			if(pAcl)
				*pDacl = *pAcl;
			else
				pDacl->SetNull();
		}
		else
			pDacl->SetEmpty();
	}

	if(pbPresent)
		*pbPresent = 0 != bPresent;

	if(pbDefaulted)
		*pbDefaulted = 0 != bDefaulted;

	return true;
}

inline bool CSecurityDesc::GetSacl(
	_Out_ CSacl *pSacl,
	_Out_opt_ bool *pbPresent /* = NULL */,
	_Out_opt_ bool *pbDefaulted /* = NULL */) const throw(...)
{
	ACL *pAcl;
	BOOL bPresent, bDefaulted;

	if(!m_pSecurityDescriptor ||
		!::GetSecurityDescriptorSacl(m_pSecurityDescriptor, &bPresent, &pAcl, &bDefaulted))
	{
		return false;
	}

	if(pSacl)
	{
		if(bPresent)
		{
			if(pAcl)
				*pSacl = *pAcl;
			else
				pSacl->SetNull();
		}
		else
			pSacl->SetEmpty();
	}

	if(pbPresent)
		*pbPresent = 0 != bPresent;

	if(pbDefaulted)
		*pbDefaulted = 0 != bDefaulted;

	return true;
}

inline bool CSecurityDesc::IsDaclDefaulted() const throw()
{
	SECURITY_DESCRIPTOR_CONTROL sdc;
	if(!GetControl(&sdc))
		return false;

	return (sdc & SE_DACL_PRESENT) &&
		(sdc & SE_DACL_DEFAULTED);
}

inline bool CSecurityDesc::IsDaclPresent() const throw()
{
	SECURITY_DESCRIPTOR_CONTROL sdc;
	if(!GetControl(&sdc))
		return false;

	return 0 != (sdc & SE_DACL_PRESENT);
}

inline bool CSecurityDesc::IsGroupDefaulted() const throw()
{
	SECURITY_DESCRIPTOR_CONTROL sdc;
	if(!GetControl(&sdc))
		return false;

	return 0 != (sdc & SE_GROUP_DEFAULTED);
}

inline bool CSecurityDesc::IsOwnerDefaulted() const throw()
{
	SECURITY_DESCRIPTOR_CONTROL sdc;
	if(!GetControl(&sdc))
		return false;

	return (sdc & SE_OWNER_DEFAULTED);
}

inline bool CSecurityDesc::IsSaclDefaulted() const throw()
{
	SECURITY_DESCRIPTOR_CONTROL sdc;
	if(!GetControl(&sdc))
		return false;

	return (sdc & SE_SACL_PRESENT) &&
		(sdc & SE_SACL_DEFAULTED);
}

inline bool CSecurityDesc::IsSaclPresent() const throw()
{
	SECURITY_DESCRIPTOR_CONTROL sdc;
	if(!GetControl(&sdc))
		return false;

	return 0 != (sdc & SE_SACL_PRESENT);
}

inline bool CSecurityDesc::IsSelfRelative() const throw()
{
	SECURITY_DESCRIPTOR_CONTROL sdc;
	if(!GetControl(&sdc))
		return false;

	return 0 != (sdc & SE_SELF_RELATIVE);
}

inline bool CSecurityDesc::IsDaclAutoInherited() const throw()
{
	SECURITY_DESCRIPTOR_CONTROL sdc;
	if(!GetControl(&sdc))
		return false;

	return 0 != (sdc & SE_DACL_AUTO_INHERITED);
}

inline bool CSecurityDesc::IsDaclProtected() const throw()
{
	SECURITY_DESCRIPTOR_CONTROL sdc;
	if(!GetControl(&sdc))
		return false;

	return 0 != (sdc & SE_DACL_PROTECTED);
}

inline bool CSecurityDesc::IsSaclAutoInherited() const throw()
{
	SECURITY_DESCRIPTOR_CONTROL sdc;
	if(!GetControl(&sdc))
		return false;

	return 0 != (sdc & SE_SACL_AUTO_INHERITED);
}

inline bool CSecurityDesc::IsSaclProtected() const throw()
{
	SECURITY_DESCRIPTOR_CONTROL sdc;
	if(!GetControl(&sdc))
		return false;

	return 0 != (sdc & SE_SACL_PROTECTED);
}

inline const SECURITY_DESCRIPTOR *CSecurityDesc::GetPSECURITY_DESCRIPTOR() const throw()
{
	return m_pSecurityDescriptor;
}

inline CSecurityDesc::operator const SECURITY_DESCRIPTOR *() const throw()
{
	return GetPSECURITY_DESCRIPTOR();
}

inline void CSecurityDesc::GetSECURITY_DESCRIPTOR(
	_Out_ SECURITY_DESCRIPTOR *pSD,
	_Inout_ LPDWORD lpdwBufferLength) throw(...)
{
	ATLASSERT(lpdwBufferLength && m_pSecurityDescriptor);
	if(!lpdwBufferLength)
		AtlThrow(E_INVALIDARG);
	if (!m_pSecurityDescriptor)
		AtlThrow(E_UNEXPECTED);

	MakeAbsolute();

	if (!::MakeSelfRelativeSD(m_pSecurityDescriptor, pSD, lpdwBufferLength) &&
			(pSD || GetLastError() != ERROR_INSUFFICIENT_BUFFER))
		AtlThrowLastWin32();
}

inline UINT CSecurityDesc::GetLength() throw()
{
	return ::GetSecurityDescriptorLength(m_pSecurityDescriptor);
}

inline bool CSecurityDesc::GetControl(
	_Out_ SECURITY_DESCRIPTOR_CONTROL *psdc) const throw()
{
	ATLASSERT(psdc);
	if(!psdc)
		return false;

	DWORD dwRev;
	*psdc = 0;
	if(!m_pSecurityDescriptor ||
		!::GetSecurityDescriptorControl(m_pSecurityDescriptor, psdc, &dwRev))
	{
		return false;
	}
	return true;
}

#if(_WIN32_WINNT >= 0x0500)
inline bool CSecurityDesc::SetControl(
	_In_ SECURITY_DESCRIPTOR_CONTROL ControlBitsOfInterest,
	_In_ SECURITY_DESCRIPTOR_CONTROL ControlBitsToSet) throw()
{
	ATLASSUME(m_pSecurityDescriptor);
	if (!m_pSecurityDescriptor)
		return false;

	return 0 != ::SetSecurityDescriptorControl(m_pSecurityDescriptor,
		ControlBitsOfInterest, ControlBitsToSet);
}
#endif

inline void CSecurityDesc::MakeSelfRelative() throw(...)
{
	SECURITY_DESCRIPTOR_CONTROL sdc;
	if(!m_pSecurityDescriptor)
		return;

	if (!GetControl(&sdc))
		AtlThrow(E_FAIL);

	if(sdc & SE_SELF_RELATIVE)
		return;

	SECURITY_DESCRIPTOR *pSD;
	DWORD dwLen = 0;

	::MakeSelfRelativeSD(m_pSecurityDescriptor, NULL, &dwLen);
	if(::GetLastError() != ERROR_INSUFFICIENT_BUFFER)
		AtlThrowLastWin32();

	pSD = static_cast<SECURITY_DESCRIPTOR *>(malloc(dwLen));
	if(!pSD)
		AtlThrow(E_OUTOFMEMORY);

	if(!::MakeSelfRelativeSD(m_pSecurityDescriptor, pSD, &dwLen))
	{
		HRESULT hr = AtlHresultFromLastError();
		free(pSD);
		AtlThrow(hr);
	}

	Clear();
	m_pSecurityDescriptor = pSD;
}

inline void CSecurityDesc::MakeAbsolute() throw(...)
{
	SECURITY_DESCRIPTOR_CONTROL sdc;
	if(!m_pSecurityDescriptor)
		return;

	if (!GetControl(&sdc))
		AtlThrow(E_FAIL);;

	if(!(sdc & SE_SELF_RELATIVE))
		return;

	SECURITY_DESCRIPTOR *pSD;
	SID *pOwner, *pGroup;
	ACL *pDacl, *pSacl;
	DWORD dwSD, dwOwner, dwGroup, dwDacl, dwSacl;

	dwSD = dwOwner = dwGroup = dwDacl = dwSacl = 0;

	::MakeAbsoluteSD(m_pSecurityDescriptor, NULL, &dwSD, NULL, &dwDacl,
		NULL, &dwSacl, NULL, &dwOwner, NULL, &dwGroup);
	if(::GetLastError() != ERROR_INSUFFICIENT_BUFFER)
		AtlThrowLastWin32();

	pSD    = static_cast<SECURITY_DESCRIPTOR *>(malloc(dwSD));
	pOwner = static_cast<SID *>(dwOwner ? malloc(dwOwner) : NULL);
	pGroup = static_cast<SID *>(dwGroup ? malloc(dwGroup) : NULL);
	pDacl  = static_cast<ACL *>(dwDacl ? malloc(dwDacl) : NULL);
	pSacl  = static_cast<ACL *>(dwSacl ? malloc(dwSacl) : NULL);

	bool bFailed=false;
	HRESULT hr=S_OK;
	if(	!pSD ||
		(dwOwner && !pOwner) ||
		(dwGroup && !pGroup) ||
		(dwDacl && !pDacl) ||
		(dwSacl && !pSacl))
	{
		bFailed=true;
		hr=E_OUTOFMEMORY;
	}
	else
	{
		if(!::MakeAbsoluteSD(m_pSecurityDescriptor,
			pSD, &dwSD,
			pDacl, &dwDacl,
			pSacl, &dwSacl,
			pOwner, &dwOwner,
			pGroup, &dwGroup))
		{
			hr = AtlHresultFromLastError();
			bFailed=true;
		}
	}

	if(bFailed)
	{
		free(pSD);
		free(pOwner);
		free(pGroup);
		free(pDacl);
		free(pSacl);
		AtlThrow(hr);
	}

	Clear();
	m_pSecurityDescriptor = pSD;
}

inline void CSecurityDesc::Clear() throw()
{
	if(m_pSecurityDescriptor)
	{
		SECURITY_DESCRIPTOR_CONTROL sdc;
		if(GetControl(&sdc) && !(sdc & SE_SELF_RELATIVE))
		{
			PSID pOwner, pGroup;
			ACL *pDacl, *pSacl;
			BOOL bDefaulted, bPresent;

			::GetSecurityDescriptorOwner(m_pSecurityDescriptor, &pOwner, &bDefaulted);
			free(pOwner);
			::GetSecurityDescriptorGroup(m_pSecurityDescriptor, &pGroup, &bDefaulted);
			free(pGroup);
			::GetSecurityDescriptorDacl(m_pSecurityDescriptor, &bPresent, &pDacl, &bDefaulted);
			if(bPresent)
				free(pDacl);
			::GetSecurityDescriptorSacl(m_pSecurityDescriptor, &bPresent, &pSacl, &bDefaulted);
			if(bPresent)
				free(pSacl);
		}
		free(m_pSecurityDescriptor);
		m_pSecurityDescriptor = NULL;
	}
}

inline void CSecurityDesc::AllocateAndInitializeSecurityDescriptor() throw(...)
{
	// m_pSecurityDescriptor should be NULL.
	ATLASSERT(!m_pSecurityDescriptor);

	m_pSecurityDescriptor = static_cast<SECURITY_DESCRIPTOR *>(malloc(sizeof(SECURITY_DESCRIPTOR)));
	if(!m_pSecurityDescriptor)
		AtlThrow(E_OUTOFMEMORY);

	if(!::InitializeSecurityDescriptor(m_pSecurityDescriptor, SECURITY_DESCRIPTOR_REVISION))
	{
		HRESULT hr = AtlHresultFromLastError();
		free(m_pSecurityDescriptor);
		m_pSecurityDescriptor = NULL;
		AtlThrow(hr);
	}
}

inline void CSecurityDesc::Init(_In_ const SECURITY_DESCRIPTOR &rhs) throw(...)
{
	SECURITY_DESCRIPTOR *pSD = const_cast<SECURITY_DESCRIPTOR *>(&rhs);
	DWORD dwRev, dwLen = ::GetSecurityDescriptorLength(pSD);

	m_pSecurityDescriptor = static_cast<SECURITY_DESCRIPTOR *>(malloc(dwLen));
	if(!m_pSecurityDescriptor)
		AtlThrow(E_OUTOFMEMORY);

	SECURITY_DESCRIPTOR_CONTROL sdc;
	if(!::GetSecurityDescriptorControl(pSD, &sdc, &dwRev))
	{
		HRESULT hr = AtlHresultFromLastError();
		free(m_pSecurityDescriptor);
		m_pSecurityDescriptor = NULL;
		AtlThrow(hr);
	}

	if(sdc & SE_SELF_RELATIVE)
	{
		Checked::memcpy_s(m_pSecurityDescriptor, dwLen, pSD, dwLen);
	}
	else
	{
		if(!::MakeSelfRelativeSD(pSD, m_pSecurityDescriptor, &dwLen))
		{
			HRESULT hr = AtlHresultFromLastError();
			free(m_pSecurityDescriptor);
			m_pSecurityDescriptor = NULL;
			AtlThrow(hr);
		}
	}
}

//******************************************
// CSecurityAttributes implementation

inline CSecurityAttributes::CSecurityAttributes() throw()
{
	nLength = 0;
	lpSecurityDescriptor = NULL;
	bInheritHandle = FALSE;
}

inline CSecurityAttributes::CSecurityAttributes(
		_In_ const CSecurityDesc &rSecurityDescriptor,
		_In_ bool bInheritHandle /* = false */) throw(...) :
	m_SecurityDescriptor(rSecurityDescriptor)
{
	Set(m_SecurityDescriptor, bInheritHandle);
}

inline void CSecurityAttributes::Set(
	_In_ const CSecurityDesc &rSecurityDescriptor,
	_In_ bool bInheritHandle /* = false */) throw(...)
{
	m_SecurityDescriptor = rSecurityDescriptor;
	nLength = sizeof(SECURITY_ATTRIBUTES);
	lpSecurityDescriptor = const_cast<SECURITY_DESCRIPTOR *>
		(m_SecurityDescriptor.GetPSECURITY_DESCRIPTOR());
	this->bInheritHandle = bInheritHandle;
}

//******************************************************
// CTokenPrivileges implementation

inline CTokenPrivileges::CTokenPrivileges() throw() :
	m_bDirty(true),
	m_pTokenPrivileges(NULL)
{
}

inline CTokenPrivileges::~CTokenPrivileges() throw()
{
	free(m_pTokenPrivileges);
}

inline CTokenPrivileges::CTokenPrivileges(
		_In_ const CTokenPrivileges &rhs) throw(...) :
	m_pTokenPrivileges(NULL),
	m_bDirty(true)
{
	const Map::CPair *pPair;
	POSITION pos = rhs.m_mapTokenPrivileges.GetStartPosition();
	while(pos)
	{
		pPair = rhs.m_mapTokenPrivileges.GetNext(pos);
		m_mapTokenPrivileges.SetAt(pPair->m_key, pPair->m_value);
	}
}

inline CTokenPrivileges &CTokenPrivileges::operator=(
	_In_ const CTokenPrivileges &rhs) throw(...)
{
	if(this != &rhs)
	{
		m_mapTokenPrivileges.RemoveAll();

		const Map::CPair *pPair;
		POSITION pos = rhs.m_mapTokenPrivileges.GetStartPosition();
		while(pos)
		{
			pPair = rhs.m_mapTokenPrivileges.GetNext(pos);
			m_mapTokenPrivileges.SetAt(pPair->m_key, pPair->m_value);
		}
		m_bDirty = true;
	}
	return *this;
}

inline CTokenPrivileges::CTokenPrivileges(
		_In_ const TOKEN_PRIVILEGES &rPrivileges) throw(...) :
	m_pTokenPrivileges(NULL)
{
	AddPrivileges(rPrivileges);
}

inline CTokenPrivileges &CTokenPrivileges::operator=(
	_In_ const TOKEN_PRIVILEGES &rPrivileges) throw(...)
{
	m_mapTokenPrivileges.RemoveAll();
	AddPrivileges(rPrivileges);
	return *this;
}

inline void CTokenPrivileges::Add(
	_In_ const TOKEN_PRIVILEGES &rPrivileges) throw(...)
{
	AddPrivileges(rPrivileges);
}

inline bool CTokenPrivileges::Add(
	_In_z_ LPCTSTR pszPrivilege,
	_In_ bool bEnable) throw(...)
{
	LUID_AND_ATTRIBUTES la;
	if(!::LookupPrivilegeValue(NULL, pszPrivilege, &la.Luid))
		return false;

	la.Attributes = bEnable ? SE_PRIVILEGE_ENABLED : 0;

	m_mapTokenPrivileges.SetAt(la.Luid, la.Attributes);

	m_bDirty = true;
	return true;
}

inline bool CTokenPrivileges::LookupPrivilege(
	_In_z_ LPCTSTR pszPrivilege,
	_Out_opt_ DWORD *pdwAttributes /* = NULL */) const throw(...)
{
	DWORD dwAttributes;
	LUID luid;

	if(!::LookupPrivilegeValue(NULL, pszPrivilege, &luid))
		return false;

	if(m_mapTokenPrivileges.Lookup(luid, dwAttributes))
	{
		if(pdwAttributes)
			*pdwAttributes = dwAttributes;
		return true;
	}
	return false;
}

inline void CTokenPrivileges::GetNamesAndAttributes(
	_Inout_ CNames *pNames,
	_Inout_opt_ CAttributes *pAttributes /* = NULL */) const throw(...)
{
	ATLASSERT(pNames);
	if(pNames)
	{
		CAutoVectorPtr<TCHAR> psz;
		DWORD cbName = 0, cbTmp;
		const Map::CPair *pPair;

		pNames->RemoveAll();
		if(pAttributes)
			pAttributes->RemoveAll();

		POSITION pos = m_mapTokenPrivileges.GetStartPosition();
		while(pos)
		{
			pPair = m_mapTokenPrivileges.GetNext(pos);

			cbTmp = cbName;
#pragma warning(push)
#pragma warning(disable: 6535)
			/* prefast noise VSW 492728 */
			if(!::LookupPrivilegeName(NULL, const_cast<LUID *>(&pPair->m_key), psz, &cbTmp))
#pragma warning(pop)
				if(::GetLastError() == ERROR_INSUFFICIENT_BUFFER)
				{
					psz.Free();
					if(!psz.Allocate(cbTmp + 1))
					{
						pNames->RemoveAll();
						if(pAttributes)
							pAttributes->RemoveAll();
						AtlThrow(E_OUTOFMEMORY);
					}

					cbName = cbTmp;
					if(!::LookupPrivilegeName(NULL, const_cast<LUID *>(&pPair->m_key), psz, &cbTmp))
						break;
				}
				else
					break;

			pNames->Add((LPTSTR) psz);
			if(pAttributes)
				pAttributes->Add(pPair->m_value);
		}

		if(pos)
		{
			pNames->RemoveAll();
			if(pAttributes)
				pAttributes->RemoveAll();
		}
	}
}

inline void CTokenPrivileges::GetDisplayNames(
	_Inout_ CNames *pDisplayNames) const throw(...)
{
	ATLASSERT(pDisplayNames);
	if(pDisplayNames)
	{
		DWORD dwLang, cbTmp, cbDisplayName = 0;
		CAutoVectorPtr<TCHAR> psz;
		CNames Names;
		UINT i;

		GetNamesAndAttributes(&Names);

		pDisplayNames->RemoveAll();

		for(i = 0; i < Names.GetCount(); i++)
		{
			cbTmp = cbDisplayName;
#pragma warning(push)
#pragma warning(disable: 6535)
			/* prefast noise VSW 492728 */
			if(!::LookupPrivilegeDisplayName(NULL, Names[i], psz, &cbTmp, &dwLang))
#pragma warning(pop)
			{
				if(::GetLastError() == ERROR_INSUFFICIENT_BUFFER)
				{
					psz.Free();
					if(!psz.Allocate(cbTmp + 1))
					{
						pDisplayNames->RemoveAll();
						AtlThrow(E_OUTOFMEMORY);
					}

					cbDisplayName = cbTmp;
					if(!::LookupPrivilegeDisplayName(NULL, Names[i], psz, &cbTmp, &dwLang))
						break;
				}
				else
					break;
			}
			pDisplayNames->Add((LPTSTR) psz);
		}

		if(i != Names.GetCount())
			pDisplayNames->RemoveAll();
	}
}

inline void CTokenPrivileges::GetLuidsAndAttributes(
	_Inout_ CLUIDArray *pLuids,
	_Inout_opt_ CAttributes *pAttributes /* = NULL */) const throw(...)
{
	ATLASSERT(pLuids);
	if(pLuids)
	{
		const Map::CPair *pPair;

		pLuids->RemoveAll();
		if(pAttributes)
			pAttributes->RemoveAll();

		POSITION pos = m_mapTokenPrivileges.GetStartPosition();
		while(pos)
		{
			pPair = m_mapTokenPrivileges.GetNext(pos);
			pLuids->Add(pPair->m_key);
			if(pAttributes)
				pAttributes->Add(pPair->m_value);
		}
	}
}

inline bool CTokenPrivileges::Delete(_In_z_ LPCTSTR pszPrivilege) throw()
{
	LUID Luid;
	if(!::LookupPrivilegeValue(NULL, pszPrivilege, &Luid))
		return false;

	if(!m_mapTokenPrivileges.RemoveKey(Luid))
		return false;

	m_bDirty = true;
	return true;
}

inline void CTokenPrivileges::DeleteAll() throw()
{
	m_mapTokenPrivileges.RemoveAll();
	m_bDirty = true;
}

inline UINT CTokenPrivileges::GetCount() const throw()
{
	return (UINT) m_mapTokenPrivileges.GetCount();
}

inline UINT CTokenPrivileges::GetLength() const throw()
{
	return offsetof(TOKEN_PRIVILEGES, Privileges) + sizeof(LUID_AND_ATTRIBUTES) * GetCount();
}

inline const TOKEN_PRIVILEGES *CTokenPrivileges::GetPTOKEN_PRIVILEGES() const throw(...)
{
	if(m_bDirty)
	{
		free(m_pTokenPrivileges);
		m_pTokenPrivileges = NULL;

		if(m_mapTokenPrivileges.GetCount())
		{
			m_pTokenPrivileges = static_cast<TOKEN_PRIVILEGES *>(malloc(GetLength()));
			if(!m_pTokenPrivileges)
				AtlThrow(E_OUTOFMEMORY);

			m_pTokenPrivileges->PrivilegeCount = (DWORD) GetCount();

			UINT i = 0;
			POSITION pos = m_mapTokenPrivileges.GetStartPosition();
			const Map::CPair *pPair;
			while(pos)
			{
				pPair = m_mapTokenPrivileges.GetNext(pos);
				m_pTokenPrivileges->Privileges[i].Luid = pPair->m_key;
				m_pTokenPrivileges->Privileges[i].Attributes = pPair->m_value;

				i++;
			}
		}
	}
	return m_pTokenPrivileges;
}

inline CTokenPrivileges::operator const TOKEN_PRIVILEGES *() const throw(...)
{
	return GetPTOKEN_PRIVILEGES();
}

inline void CTokenPrivileges::AddPrivileges(
	_In_ const TOKEN_PRIVILEGES &rPrivileges) throw(...)
{
	m_bDirty = true;
	for(UINT i = 0; i < rPrivileges.PrivilegeCount; i++)
#pragma warning(push)
#pragma warning(disable: 6385)
		/* prefast noise VSW 492737 */
		m_mapTokenPrivileges.SetAt(
			rPrivileges.Privileges[i].Luid, rPrivileges.Privileges[i].Attributes);
#pragma warning(pop)
}

//******************************************************
// CTokenGroups implementation

inline CTokenGroups::CTokenGroups() throw() :
	m_pTokenGroups(NULL),
	m_bDirty(true)
{
}

inline CTokenGroups::~CTokenGroups() throw()
{
	free(m_pTokenGroups);
}

inline CTokenGroups::CTokenGroups(
		_In_ const CTokenGroups &rhs) throw(...) :
	m_pTokenGroups(NULL),
	m_bDirty(true)
{
	const Map::CPair *pPair;
	POSITION pos = rhs.m_mapTokenGroups.GetStartPosition();
	while(pos)
	{
		pPair = rhs.m_mapTokenGroups.GetNext(pos);
		m_mapTokenGroups.SetAt(pPair->m_key, pPair->m_value);
	}
}

inline CTokenGroups &CTokenGroups::operator=(
	_In_ const CTokenGroups &rhs) throw(...)
{
	if(this != &rhs)
	{
		m_mapTokenGroups.RemoveAll();

		const Map::CPair *pPair;
		POSITION pos = rhs.m_mapTokenGroups.GetStartPosition();
		while(pos)
		{
			pPair = rhs.m_mapTokenGroups.GetNext(pos);
			m_mapTokenGroups.SetAt(pPair->m_key, pPair->m_value);
		}
		m_bDirty = true;
	}
	return *this;
}

inline CTokenGroups::CTokenGroups(
		_In_ const TOKEN_GROUPS &rhs) throw(...) :
	m_pTokenGroups(NULL)
{
	AddTokenGroups(rhs);
}

inline CTokenGroups &CTokenGroups::operator=(
	_In_ const TOKEN_GROUPS &rhs) throw(...)
{
	m_mapTokenGroups.RemoveAll();
	AddTokenGroups(rhs);
	return *this;
}

inline void CTokenGroups::Add(
	_In_ const TOKEN_GROUPS &rTokenGroups) throw(...)
{
	AddTokenGroups(rTokenGroups);
}

inline void CTokenGroups::Add(
	_In_ const CSid &rSid,
	_In_ DWORD dwAttributes) throw(...)
{
	m_mapTokenGroups.SetAt(rSid, dwAttributes);
	m_bDirty = true;
}

inline bool CTokenGroups::LookupSid(
	_In_ const CSid &rSid,
	_Out_opt_ DWORD *pdwAttributes /* = NULL */) const throw()
{
	DWORD dwAttributes;
	if(m_mapTokenGroups.Lookup(rSid, dwAttributes))
	{
		if(pdwAttributes)
			*pdwAttributes = dwAttributes;
		return true;
	}
	return false;
}

inline void CTokenGroups::GetSidsAndAttributes(
	_Inout_ CSid::CSidArray *pSids,
	_Inout_opt_ CAtlArray<DWORD> *pAttributes /* = NULL */) const throw(...)
{
	ATLASSERT(pSids);
	if(pSids)
	{
		const Map::CPair *pPair;

		pSids->RemoveAll();
		if(pAttributes)
			pAttributes->RemoveAll();

		POSITION pos = m_mapTokenGroups.GetStartPosition();
		while(pos)
		{
			pPair = m_mapTokenGroups.GetNext(pos);
			pSids->Add(pPair->m_key);
			if(pAttributes)
				pAttributes->Add(pPair->m_value);
		}
	}
}

inline bool CTokenGroups::Delete(
	_In_ const CSid &rSid) throw()
{
	return m_mapTokenGroups.RemoveKey(rSid);
}

inline void CTokenGroups::DeleteAll() throw()
{
	m_mapTokenGroups.RemoveAll();
	m_bDirty = true;
}

inline UINT CTokenGroups::GetCount() const throw()
{
	return (UINT) m_mapTokenGroups.GetCount();
}

inline UINT CTokenGroups::GetLength() const throw()
{
	return UINT(offsetof(TOKEN_GROUPS, Groups) + sizeof(SID_AND_ATTRIBUTES) * m_mapTokenGroups.GetCount());
}

inline const TOKEN_GROUPS *CTokenGroups::GetPTOKEN_GROUPS() const throw(...)
{
	if(m_bDirty)
	{
		free(m_pTokenGroups);
		m_pTokenGroups = NULL;

		if(m_mapTokenGroups.GetCount())
		{
			m_pTokenGroups = static_cast<TOKEN_GROUPS *>(malloc(GetLength()));
			if(!m_pTokenGroups)
				AtlThrow(E_OUTOFMEMORY);

			m_pTokenGroups->GroupCount = (DWORD) m_mapTokenGroups.GetCount();

			UINT i = 0;
			POSITION pos = m_mapTokenGroups.GetStartPosition();
			const Map::CPair *pPair;
			while(pos)
			{
				pPair = m_mapTokenGroups.GetNext(pos);
				m_pTokenGroups->Groups[i].Sid = const_cast<SID *>(pPair->m_key.GetPSID());
				m_pTokenGroups->Groups[i].Attributes = pPair->m_value;

				i++;
			}
		}
	}
	return m_pTokenGroups;
}

inline CTokenGroups::operator const TOKEN_GROUPS *() const throw(...)
{
	return GetPTOKEN_GROUPS();
}

inline void CTokenGroups::AddTokenGroups(
	_In_ const TOKEN_GROUPS &rTokenGroups) throw(...)
{
	m_bDirty = true;
	for(UINT i = 0; i < rTokenGroups.GroupCount; i++)
#pragma warning(push)
#pragma warning(disable: 6385)
		/* prefast noise VSW 492737 */
		m_mapTokenGroups.SetAt(
			CSid(static_cast<SID *>(rTokenGroups.Groups[i].Sid)),
			rTokenGroups.Groups[i].Attributes);
#pragma warning(pop)
}

// *************************************
// CAccessToken implementation

inline CAccessToken::CAccessToken() throw() :
	m_hToken(NULL),
	m_hProfile(NULL),
	m_pRevert(NULL)
{
}

inline CAccessToken::~CAccessToken() throw()
{
	Clear();
}

inline void CAccessToken::Attach(_In_ HANDLE hToken) throw()
{
	ATLASSUME(m_hToken == NULL);
	m_hToken = hToken;
}

inline HANDLE CAccessToken::Detach() throw()
{
	HANDLE hToken = m_hToken;
	m_hToken = NULL;
	Clear();
	return hToken;
}

inline HANDLE CAccessToken::GetHandle() const throw()
{
	return m_hToken;
}

inline HKEY CAccessToken::HKeyCurrentUser() const throw()
{
	return reinterpret_cast<HKEY>(m_hProfile);
}

inline bool CAccessToken::EnablePrivilege(
	_In_z_ LPCTSTR pszPrivilege,
	_In_opt_ CTokenPrivileges *pPreviousState /* = NULL */,
	_Out_opt_ bool* pbErrNotAllAssigned /*=NULL*/) throw(...)
{
	CTokenPrivileges NewState;
	NewState.Add(pszPrivilege, true);
	return EnableDisablePrivileges(NewState, pPreviousState,pbErrNotAllAssigned);
}

inline bool CAccessToken::EnablePrivileges(
	_In_ const CAtlArray<LPCTSTR> &rPrivileges,
	_Inout_opt_ CTokenPrivileges *pPreviousState /* = NULL */,
	_Out_opt_ bool* pbErrNotAllAssigned /*=NULL*/) throw(...)
{
	return EnableDisablePrivileges(rPrivileges, true, pPreviousState,pbErrNotAllAssigned);
}

inline bool CAccessToken::DisablePrivilege(
	_In_z_ LPCTSTR pszPrivilege,
	_In_opt_ CTokenPrivileges *pPreviousState /* = NULL */,
	_Out_opt_ bool* pbErrNotAllAssigned /*=NULL*/) throw(...)
{
	CTokenPrivileges NewState;
	NewState.Add(pszPrivilege, false);
	return EnableDisablePrivileges(NewState, pPreviousState,pbErrNotAllAssigned);
}

inline bool CAccessToken::DisablePrivileges(
	_In_ const CAtlArray<LPCTSTR> &rPrivileges,
	_Inout_opt_ CTokenPrivileges *pPreviousState /* = NULL */,
	_Out_opt_ bool* pbErrNotAllAssigned /*=NULL*/) throw(...)
{
	return EnableDisablePrivileges(rPrivileges, false, pPreviousState,pbErrNotAllAssigned);
}

inline bool CAccessToken::EnableDisablePrivileges(
	_In_ const CTokenPrivileges &rNewState,
	_Inout_opt_ CTokenPrivileges *pPreviousState /* = NULL */,
	_Out_opt_ bool* pbErrNotAllAssigned /*=NULL*/) throw(...)
{
	if(!rNewState.GetCount())
	{
		return true;
	}

	TOKEN_PRIVILEGES *pNewState = const_cast<TOKEN_PRIVILEGES *>(rNewState.GetPTOKEN_PRIVILEGES());

	DWORD dwLength = DWORD(offsetof(TOKEN_PRIVILEGES, Privileges) +
		rNewState.GetCount() * sizeof(LUID_AND_ATTRIBUTES));

	USES_ATL_SAFE_ALLOCA;
	TOKEN_PRIVILEGES *pPrevState = static_cast<TOKEN_PRIVILEGES *>(_ATL_SAFE_ALLOCA(dwLength, _ATL_SAFE_ALLOCA_DEF_THRESHOLD));
	if(::AdjustTokenPrivileges(m_hToken, FALSE, pNewState, dwLength, pPrevState, &dwLength))
	{
		if (pbErrNotAllAssigned)
		{
			if(::GetLastError() == ERROR_NOT_ALL_ASSIGNED)
			{
				*pbErrNotAllAssigned=true;
			} else
			{
				*pbErrNotAllAssigned=false;
			}
		}
	} else
	{
		return false;
	}

	if(pPreviousState != NULL && pPrevState != NULL)
	{
		pPreviousState->Add(*pPrevState);
	}

	return true;
}

inline bool CAccessToken::PrivilegeCheck(
	_In_ PPRIVILEGE_SET RequiredPrivileges,
	_Out_ bool *pbResult) const throw()
{
	BOOL bResult;
	if(!::PrivilegeCheck(m_hToken, RequiredPrivileges, &bResult))
		return false;

	*pbResult = 0 != bResult;
	return true;
}

inline bool CAccessToken::GetLogonSid(_Inout_ CSid *pSid) const throw(...)
{
	ATLASSERT(pSid);
	if(!pSid)
		return false;

	DWORD dwLen;
	::GetTokenInformation(m_hToken, TokenGroups, NULL, 0, &dwLen);
	if(::GetLastError() != ERROR_INSUFFICIENT_BUFFER)
		return false;

	USES_ATL_SAFE_ALLOCA;
	TOKEN_GROUPS *pGroups = static_cast<TOKEN_GROUPS *>(_ATL_SAFE_ALLOCA(dwLen, _ATL_SAFE_ALLOCA_DEF_THRESHOLD));
	if(::GetTokenInformation(m_hToken, TokenGroups, pGroups, dwLen, &dwLen))
	{
		ATLASSUME(pGroups != NULL);
		for(UINT i = 0; i < pGroups->GroupCount; i++)
		{
			if(pGroups->Groups[i].Attributes & SE_GROUP_LOGON_ID)
			{
				*pSid = *static_cast<SID *>(pGroups->Groups[i].Sid);
				return true;
			}
		}
	}
	return false;
}

inline bool CAccessToken::GetTokenId(_Out_ LUID *pluid) const throw(...)
{
	ATLASSERT(pluid);
	if(!pluid)
		return false;

	TOKEN_STATISTICS Statistics = { 0 };
	if(!GetStatistics(&Statistics))
		return false;

	*pluid = Statistics.TokenId;
	return true;
}

inline bool CAccessToken::GetLogonSessionId(_Out_ LUID *pluid) const throw(...)
{
	ATLASSERT(pluid);
	if(!pluid)
		return false;

	TOKEN_STATISTICS Statistics = { 0 };
	if(!GetStatistics(&Statistics))
		return false;

	*pluid = Statistics.AuthenticationId;
	return true;
}

inline bool CAccessToken::CheckTokenMembership(
	_In_ const CSid &rSid,
	_Inout_ bool *pbIsMember) const throw(...)
{
	// "this" must be an impersonation token and NOT a primary token
	BOOL bIsMember;

	ATLASSERT(pbIsMember);
	if (!pbIsMember)
		return false;

#if(_WIN32_WINNT >= 0x0500)
	if(::CheckTokenMembership(m_hToken, const_cast<SID *>(rSid.GetPSID()), &bIsMember))
#else
	GENERIC_MAPPING gm = {0, 0, 0, 1};
	PRIVILEGE_SET ps;
	DWORD cb = sizeof(PRIVILEGE_SET);
	DWORD ga;
	CSecurityDesc sd;
	CDacl dacl;

	if (!dacl.AddAllowedAce(rSid, 1))
		return false;
	sd.SetOwner(rSid);
	sd.SetGroup(rSid);
	sd.SetDacl(dacl);

	if(::AccessCheck(const_cast<SECURITY_DESCRIPTOR *>(sd.GetPSECURITY_DESCRIPTOR()),
		m_hToken, 1, &gm, &ps, &cb, &ga, &bIsMember))
#endif
	{
		*pbIsMember = 0 != bIsMember;
		return true;
	}
	return false;
}

#if(_WIN32_WINNT >= 0x0500)
inline bool CAccessToken::IsTokenRestricted() const throw()
{
	return 0 != ::IsTokenRestricted(m_hToken);
}
#endif

inline bool CAccessToken::GetDefaultDacl(_Inout_ CDacl *pDacl) const throw(...)
{
	return GetInfoConvert<CDacl, TOKEN_DEFAULT_DACL>(pDacl, TokenDefaultDacl);
}

inline bool CAccessToken::GetGroups(_Inout_ CTokenGroups *pGroups) const throw(...)
{
	return GetInfoConvert<CTokenGroups, TOKEN_GROUPS>(pGroups, TokenGroups);
}

inline bool CAccessToken::GetImpersonationLevel(
	_Inout_ SECURITY_IMPERSONATION_LEVEL *pImpersonationLevel) const throw(...)
{
	return GetInfo<SECURITY_IMPERSONATION_LEVEL>(pImpersonationLevel, TokenImpersonationLevel);
}

inline bool CAccessToken::GetOwner(_Inout_ CSid *pSid) const throw(...)
{
	return GetInfoConvert<CSid, TOKEN_OWNER>(pSid, TokenOwner);
}

inline bool CAccessToken::GetPrimaryGroup(_Inout_ CSid *pSid) const throw(...)
{
	return GetInfoConvert<CSid, TOKEN_PRIMARY_GROUP>(pSid, TokenPrimaryGroup);
}

inline bool CAccessToken::GetPrivileges(_Inout_ CTokenPrivileges *pPrivileges) const throw(...)
{
	return GetInfoConvert<CTokenPrivileges, TOKEN_PRIVILEGES>(pPrivileges, TokenPrivileges);
}

inline bool CAccessToken::GetTerminalServicesSessionId(_Inout_ DWORD *pdwSessionId) const throw(...)
{
	return GetInfo<DWORD>(pdwSessionId, TokenSessionId);
}

inline bool CAccessToken::GetSource(_Inout_ TOKEN_SOURCE *pSource) const throw(...)
{
	return GetInfo<TOKEN_SOURCE>(pSource, TokenSource);
}

inline bool CAccessToken::GetStatistics(_Inout_ TOKEN_STATISTICS *pStatistics) const throw(...)
{
	return GetInfo<TOKEN_STATISTICS>(pStatistics, TokenStatistics);
}

inline bool CAccessToken::GetType(_Inout_ TOKEN_TYPE *pType) const throw(...)
{
	return GetInfo<TOKEN_TYPE>(pType, TokenType);
}

inline bool CAccessToken::GetUser(_Inout_ CSid *pSid) const throw(...)
{
	return GetInfoConvert<CSid, TOKEN_USER>(pSid, TokenUser);
}

inline bool CAccessToken::SetOwner(_In_ const CSid &rSid) throw(...)

{
	TOKEN_OWNER to;
	to.Owner = const_cast<SID *>(rSid.GetPSID());
	return 0 != ::SetTokenInformation(m_hToken, TokenOwner, &to, sizeof(to));
}

inline bool CAccessToken::SetPrimaryGroup(_In_ const CSid &rSid) throw(...)
{
	TOKEN_PRIMARY_GROUP tpg;
	tpg.PrimaryGroup = const_cast<SID *>(rSid.GetPSID());
	return 0 != ::SetTokenInformation(m_hToken, TokenPrimaryGroup, &tpg, sizeof(tpg));
}

inline bool CAccessToken::SetDefaultDacl(_In_ const CDacl &rDacl) throw(...)
{
	TOKEN_DEFAULT_DACL tdd;
	tdd.DefaultDacl = const_cast<ACL *>(rDacl.GetPACL());
	return 0 != ::SetTokenInformation(m_hToken, TokenDefaultDacl, &tdd, sizeof(tdd));
}

inline bool CAccessToken::CreateImpersonationToken(
	_Inout_ CAccessToken *pImp,
	_In_ SECURITY_IMPERSONATION_LEVEL sil /* = SecurityImpersonation */) const throw(...)
{
	ATLASSERT(pImp);
	if(!pImp)
		return false;

	HANDLE hToken;
	if(!::DuplicateToken(m_hToken, sil, &hToken))
		return false;

	pImp->Clear();
	pImp->m_hToken = hToken;
	return true;
}

inline bool CAccessToken::CreatePrimaryToken(
	_Inout_ CAccessToken *pPri,
	_In_ DWORD dwDesiredAccess /* = MAXIMUM_ALLOWED */,
	_In_opt_ const CSecurityAttributes *pTokenAttributes /* = NULL */) const throw(...)
{
	ATLASSERT(pPri);
	if(!pPri)
		return false;

	HANDLE hToken;
	if(!::DuplicateTokenEx(m_hToken, dwDesiredAccess,
		const_cast<CSecurityAttributes *>(pTokenAttributes),
		SecurityAnonymous, TokenPrimary, &hToken))
	{
		return false;
	}

	pPri->Clear();
	pPri->m_hToken = hToken;
	return true;
}

#if(_WIN32_WINNT >= 0x0500)

inline bool CAccessToken::CreateRestrictedToken(
	_Inout_ CAccessToken *pRestrictedToken,
	_In_ const CTokenGroups &SidsToDisable,
	_In_ const CTokenGroups &SidsToRestrict,
	_In_ const CTokenPrivileges &PrivilegesToDelete /* = CTokenPrivileges() */) const throw(...)
{
	ATLASSERT(pRestrictedToken);
	if(!pRestrictedToken)
		return false;

	HANDLE hToken;
	SID_AND_ATTRIBUTES *pSidsToDisable;
	SID_AND_ATTRIBUTES *pSidsToRestrict;
	LUID_AND_ATTRIBUTES *pPrivilegesToDelete;

	UINT nDisableSidCount = SidsToDisable.GetCount();
	if(nDisableSidCount)
	{
		const TOKEN_GROUPS * pTOKEN_GROUPS = SidsToDisable.GetPTOKEN_GROUPS();

		ATLASSERT(pTOKEN_GROUPS != NULL);

		if(pTOKEN_GROUPS != NULL)
		{
			pSidsToDisable = const_cast<SID_AND_ATTRIBUTES *>
				(pTOKEN_GROUPS->Groups);
		}
		else
		{
			return false;
		}
	}
	else
	{
		pSidsToDisable = NULL;
	}

	UINT nRestrictedSidCount = SidsToRestrict.GetCount();
	if(nRestrictedSidCount)
	{
		const TOKEN_GROUPS * pTOKEN_GROUPS = SidsToRestrict.GetPTOKEN_GROUPS();

		ATLASSERT(pTOKEN_GROUPS != NULL);

		if(pTOKEN_GROUPS != NULL)
		{
			pSidsToRestrict = const_cast<SID_AND_ATTRIBUTES *>
				(pTOKEN_GROUPS->Groups);
		}
		else
		{
			return false;
		}

	}
	else
	{
		pSidsToRestrict = NULL;
	}

	UINT nDeletePrivilegesCount = PrivilegesToDelete.GetCount();
	if(nDeletePrivilegesCount)
	{
		const TOKEN_PRIVILEGES * pTOKEN_PRIVILEGES = PrivilegesToDelete.GetPTOKEN_PRIVILEGES();

		ATLASSERT(pTOKEN_PRIVILEGES != NULL);

		if(pTOKEN_PRIVILEGES != NULL)
		{
			pPrivilegesToDelete = const_cast<LUID_AND_ATTRIBUTES *>
				(pTOKEN_PRIVILEGES->Privileges);
		}
		else
		{
			return false;
		}

	}
	else
	{
		pPrivilegesToDelete = NULL;
	}

	if(!::CreateRestrictedToken(m_hToken, 0,
		(DWORD) nDisableSidCount, pSidsToDisable,
		(DWORD) nDeletePrivilegesCount, pPrivilegesToDelete,
		(DWORD) nRestrictedSidCount, pSidsToRestrict, &hToken))
	{
		return false;
	}

	pRestrictedToken->Clear();
	pRestrictedToken->m_hToken = hToken;
	return true;
}

#endif // _WIN32_WINNT >= 0x0500

inline bool CAccessToken::GetProcessToken(
	_In_ DWORD dwDesiredAccess,
	_In_opt_ HANDLE hProcess /* = NULL */) throw()
{
	if(!hProcess)
		hProcess = ::GetCurrentProcess();

	HANDLE hToken;
	if(!::OpenProcessToken(hProcess, dwDesiredAccess, &hToken))
		return false;

	Clear();
	m_hToken = hToken;
	return true;
}

inline bool CAccessToken::GetThreadToken(
	_In_ DWORD dwDesiredAccess,
	_In_opt_ HANDLE hThread /* = NULL */,
	_In_ bool bOpenAsSelf /* = true */) throw()
{
	if(!hThread)
		hThread = ::GetCurrentThread();

	HANDLE hToken;
	if(!::OpenThreadToken(hThread, dwDesiredAccess, bOpenAsSelf, &hToken))
		return false;

	Clear();
	m_hToken = hToken;

	return true;
}

inline bool CAccessToken::GetEffectiveToken(_In_ DWORD dwDesiredAccess) throw()
{
	if(!GetThreadToken(dwDesiredAccess))
		return GetProcessToken(dwDesiredAccess);
	return true;
}

inline bool CAccessToken::OpenThreadToken(
	_In_ DWORD dwDesiredAccess,
	_In_ bool bImpersonate /* = false */,
	_In_ bool bOpenAsSelf /* = true */,
	_In_ SECURITY_IMPERSONATION_LEVEL sil /* = SecurityImpersonation */) throw(...)
{
	// If bImpersonate == false the original impersonate level should be restored after getting token.
	SECURITY_IMPERSONATION_LEVEL silCurrent = SecurityAnonymous; 
	bool bNeedRestoreLevel = CheckImpersonation() && !bImpersonate;
	if(bNeedRestoreLevel)
	{
		// Calling thread is impersonating. The impersonation level should be recorded down.
		bNeedRestoreLevel = GetImpersonationLevel(&silCurrent);
	}

	if(!::ImpersonateSelf(sil))
		return false;

	HANDLE hToken;
	if(!::OpenThreadToken(::GetCurrentThread(), dwDesiredAccess, bOpenAsSelf, &hToken))
	{
		// The function call failed returning to original impersonation level.
		RevertToLevel(bNeedRestoreLevel ? &silCurrent : NULL);
		return false;
	}

	Clear();
	m_hToken = hToken;

	if(!bImpersonate)
	{
		// Restore the original impersonation level.
		RevertToLevel(bNeedRestoreLevel ? &silCurrent : NULL);
	}
	else
	{
		ATLTRY(m_pRevert = new CRevertToSelf);
		if(!m_pRevert)
		{
			::RevertToSelf();
			Clear();
			return false;
		}
	}
	return true;
}

#if (_WIN32_WINNT >= 0x0400 ) || defined(_WIN32_DCOM)
inline bool CAccessToken::OpenCOMClientToken(
	_In_ DWORD dwDesiredAccess,
	_In_ bool bImpersonate /* = false */,
	_In_ bool bOpenAsSelf /* = true */) throw(...)
{
	CheckImpersonation();

	if(FAILED(::CoImpersonateClient()))
		return false;

	HANDLE hToken;
	if(!::OpenThreadToken(::GetCurrentThread(), dwDesiredAccess, bOpenAsSelf, &hToken))
		return false;

	Clear();
	m_hToken = hToken;

	if(!bImpersonate)
		::CoRevertToSelf();
	else
	{
		ATLTRY(m_pRevert = new CCoRevertToSelf);
		if(!m_pRevert)
		{
			::CoRevertToSelf();
			Clear();
			return false;
		}
	}
	return true;
}
#endif //(_WIN32_WINNT >= 0x0400 ) || defined(_WIN32_DCOM)

inline bool CAccessToken::OpenNamedPipeClientToken(
	_In_ HANDLE hPipe,
	_In_ DWORD dwDesiredAccess,
	_In_ bool bImpersonate /* = false */,
	_In_ bool bOpenAsSelf /* = true */) throw(...)
{
	CheckImpersonation();

	if(!::ImpersonateNamedPipeClient(hPipe))
		return false;

	HANDLE hToken;
	if(!::OpenThreadToken(::GetCurrentThread(), dwDesiredAccess, bOpenAsSelf, &hToken))
		return false;

	Clear();
	m_hToken = hToken;

	if(!bImpersonate)
		::RevertToSelf();
	else
	{
		ATLTRY(m_pRevert = new CRevertToSelf);
		if(!m_pRevert)
		{
			::RevertToSelf();
			Clear();
			return false;
		}
	}
	return true;
}

inline bool CAccessToken::OpenRPCClientToken(
	_In_ RPC_BINDING_HANDLE BindingHandle,
	_In_ DWORD dwDesiredAccess,
	_In_ bool bImpersonate /* = false */,
	_In_ bool bOpenAsSelf /* = true */) throw(...)
{
	CheckImpersonation();

	if(RPC_S_OK != ::RpcImpersonateClient(BindingHandle))
		return false;

	HANDLE hToken;
	if(!::OpenThreadToken(::GetCurrentThread(), dwDesiredAccess, bOpenAsSelf, &hToken))
		return false;

	Clear();
	m_hToken = hToken;

	if(!bImpersonate)
	{
		RPC_STATUS rpcStatus = ::RpcRevertToSelfEx(BindingHandle);
		if( rpcStatus != RPC_S_OK )
		{
			Clear();
			return false;
		}
	}
	else
	{
		ATLTRY(m_pRevert = new CRpcRevertToSelfEx(BindingHandle));
		if(!m_pRevert)
		{
			RPC_STATUS rpcStatus = ::RpcRevertToSelfEx(BindingHandle);
		    if( rpcStatus != RPC_S_OK )
		    {
                // If we continue, arbitrary user code will run in the wrong context. Too dangerous to risk
                _ATL_FATAL_SHUTDOWN;
		    }
		}
	}
	return true;
}

inline bool CAccessToken::ImpersonateLoggedOnUser() const throw(...)
{
	CheckImpersonation();

	ATLASSUME(m_hToken);
	if(m_hToken && ::ImpersonateLoggedOnUser(m_hToken))
	{
		ATLASSERT(!m_pRevert);
		delete m_pRevert;
		ATLTRY(m_pRevert = new CRevertToSelf);
		if (!m_pRevert)
		{
			::RevertToSelf();
			return false;
		}
		return true;
	}
	return false;
}

inline bool CAccessToken::Impersonate(
	_In_opt_ HANDLE hThread /* = NULL */) const throw(...)
{
	CheckImpersonation();

	ATLASSUME(m_hToken);
	if(m_hToken)
		return 0 != ::SetThreadToken(hThread ? &hThread : NULL, m_hToken);
	return false;
}

inline bool CAccessToken::Revert(
	_In_opt_ HANDLE hThread /* = NULL */) const throw()
{
	if (hThread || !m_pRevert)
		return 0 != ::SetThreadToken(hThread ? &hThread : NULL, NULL);

	bool bRet = m_pRevert->Revert();
	delete m_pRevert;
	m_pRevert = NULL;
	return bRet;
}

inline bool CAccessToken::LoadUserProfile() throw(...)
{
	ATLASSUME(m_hToken && !m_hProfile);
	if(!m_hToken || m_hProfile)
		return false;

	CSid UserSid;
	PROFILEINFO Profile;

	if(!GetUser(&UserSid))
		return false;

	memset(&Profile, 0x00, sizeof(PROFILEINFO));
	Profile.dwSize = sizeof(PROFILEINFO);
	Profile.lpUserName = const_cast<LPTSTR>(UserSid.AccountName());
	if(!::LoadUserProfile(m_hToken, &Profile))
		return false;

	m_hProfile = Profile.hProfile;

	return true;
}

inline HANDLE CAccessToken::GetProfile() const throw()
{
	return m_hProfile;
}

inline bool CAccessToken::LogonUser(
	_In_z_ LPCTSTR pszUserName,
	_In_z_ LPCTSTR pszDomain,
	_In_z_ LPCTSTR pszPassword,
	_In_ DWORD dwLogonType /* = LOGON32_LOGON_INTERACTIVE */,
	_In_ DWORD dwLogonProvider /* = LOGON32_PROVIDER_DEFAULT */) throw()
{
	Clear();

	return 0 != ::LogonUser(
		const_cast<LPTSTR>(pszUserName),
		const_cast<LPTSTR>(pszDomain),
		const_cast<LPTSTR>(pszPassword),
		dwLogonType, dwLogonProvider, &m_hToken);
}

inline bool CAccessToken::CreateProcessAsUser(
	_In_opt_z_ LPCTSTR pApplicationName,
	_In_opt_z_ LPTSTR pCommandLine,
	_In_ LPPROCESS_INFORMATION pProcessInformation,
	_In_ LPSTARTUPINFO pStartupInfo,
	_In_ DWORD dwCreationFlags /* = NORMAL_PRIORITY_CLASS */,
	_In_ bool bLoadProfile /* = false */,
	_In_opt_ const CSecurityAttributes *pProcessAttributes /* = NULL */,
	_In_opt_ const CSecurityAttributes *pThreadAttributes /* = NULL */,
	_In_ bool bInherit /* = false */,
	_In_opt_z_ LPCTSTR pCurrentDirectory /* = NULL */) throw()
{
	ATLASSERT(pProcessInformation != NULL);
	ATLASSERT(pStartupInfo != NULL);

	if(!pProcessInformation || !pStartupInfo)
	{
		return false;
	}

	LPVOID pEnvironmentBlock;
	PROFILEINFO Profile;
	CSid UserSid;
	DWORD dwLastError;

	HANDLE hToken = m_hToken;

	// Straighten out impersonation problems...
	TOKEN_TYPE TokenType = TokenPrimary;
	if(!GetType(&TokenType))
	{
		return false;
	}

	if (TokenType != TokenPrimary)
	{
		hToken = NULL;
		if (!::DuplicateTokenEx(m_hToken, TOKEN_QUERY|TOKEN_DUPLICATE|TOKEN_ASSIGN_PRIMARY, NULL,
			SecurityImpersonation, TokenPrimary, &hToken))
		{
			return false;
		}
	}

	// Profile
	if(bLoadProfile && !m_hProfile)
	{
		if(!GetUser(&UserSid))
		{
			if(TokenType != TokenPrimary)
				::CloseHandle(hToken);
			return false;
		}
		memset(&Profile, 0x00, sizeof(PROFILEINFO));
		Profile.dwSize = sizeof(PROFILEINFO);
		Profile.lpUserName = const_cast<LPTSTR>(UserSid.AccountName());
		if(::LoadUserProfile(hToken, &Profile))
			m_hProfile = Profile.hProfile;
	}

	// Environment block
	if(!::CreateEnvironmentBlock(&pEnvironmentBlock, hToken, bInherit))
		return false;

	BOOL bRetVal = ::CreateProcessAsUser(
		hToken,
		pApplicationName,
		pCommandLine,
		const_cast<CSecurityAttributes *>(pProcessAttributes),
		const_cast<CSecurityAttributes *>(pThreadAttributes),
		bInherit,
		dwCreationFlags,
		pEnvironmentBlock,
		pCurrentDirectory,
		pStartupInfo,
		pProcessInformation);

	 dwLastError = ::GetLastError();

	if(TokenType != TokenPrimary)
		::CloseHandle(hToken);

	::DestroyEnvironmentBlock(pEnvironmentBlock);

	::SetLastError(dwLastError);
	return bRetVal != 0;
}

inline bool CAccessToken::EnableDisablePrivileges(
	_In_ const CAtlArray<LPCTSTR> &rPrivileges,
	_In_ bool bEnable,
	_Inout_opt_ CTokenPrivileges *pPreviousState,
	_Out_opt_ bool* pbErrNotAllAssigned/*=NULL*/) throw(...)
{
	CTokenPrivileges NewState;
	for(UINT i = 0; i < rPrivileges.GetCount(); i++)
		NewState.Add(rPrivileges[i], bEnable);
	return EnableDisablePrivileges(NewState, pPreviousState,pbErrNotAllAssigned);
}

inline bool CAccessToken::CheckImpersonation() const throw()
{
	// You should not be impersonating at this point.  Use GetThreadToken
	// instead of the OpenXXXToken functions or call Revert before
	// calling Impersonate.
	HANDLE hToken=INVALID_HANDLE_VALUE;
	if(!::OpenThreadToken(::GetCurrentThread(), 0, false, &hToken) &&
		::GetLastError() != ERROR_NO_TOKEN)
	{
		ATLTRACE(atlTraceSecurity, 2, _T("Caution: replacing thread impersonation token.\n"));
		return true;
	}
	if(hToken!=INVALID_HANDLE_VALUE)
	{
	    ::CloseHandle(hToken);
	}
	return false;
}

inline bool CAccessToken::RevertToLevel(
	_In_opt_ SECURITY_IMPERSONATION_LEVEL *pSil) const throw()
{
	BOOL bRet = ::RevertToSelf();
	if(bRet && pSil != NULL)
	{
		bRet = ::ImpersonateSelf(*pSil);
	}
	return !!bRet;
}

inline void CAccessToken::Clear() throw()
{
	if(m_hProfile)
	{
		ATLASSUME(m_hToken);
		if(m_hToken)
			::UnloadUserProfile(m_hToken, m_hProfile);
		m_hProfile = NULL;
	}

	if(m_hToken)
	{
		::CloseHandle(m_hToken);
		m_hToken = NULL;
	}
	delete m_pRevert;
	m_pRevert = NULL;
}

//*******************************************
// CAutoRevertImpersonation implementation

inline CAutoRevertImpersonation::CAutoRevertImpersonation(
	_In_ const CAccessToken* pAT) throw()
{
	m_pAT = pAT;
}

inline CAutoRevertImpersonation::~CAutoRevertImpersonation() throw()
{
	if (m_pAT != NULL)
	{
		m_pAT->Revert();
	}
}

inline void CAutoRevertImpersonation::Attach(
	_In_ const CAccessToken* pAT) throw()
{
	ATLASSUME(m_pAT == NULL);
	m_pAT = pAT;
}

inline const CAccessToken* CAutoRevertImpersonation::Detach() throw()
{
	const CAccessToken* pAT = m_pAT;
	m_pAT = NULL;
	return pAT;
}

inline const CAccessToken* CAutoRevertImpersonation::GetAccessToken() throw()
{
	return m_pAT;
}

//*******************************************
// CPrivateObjectSecurityDesc implementation

inline CPrivateObjectSecurityDesc::CPrivateObjectSecurityDesc() throw() :
	m_bPrivate(false),
	CSecurityDesc()
{
}

inline CPrivateObjectSecurityDesc::~CPrivateObjectSecurityDesc() throw()
{
	Clear();
}

inline bool CPrivateObjectSecurityDesc::Create(
	_In_opt_ const CSecurityDesc *pParent,
	_In_opt_ const CSecurityDesc *pCreator,
	_In_ bool bIsDirectoryObject,
	_In_ const CAccessToken &Token,
	_In_ PGENERIC_MAPPING GenericMapping) throw()
{
	Clear();

	const SECURITY_DESCRIPTOR *pSDParent = pParent ? pParent->GetPSECURITY_DESCRIPTOR() : NULL;
	const SECURITY_DESCRIPTOR *pSDCreator = pCreator ? pCreator->GetPSECURITY_DESCRIPTOR() : NULL;

	if(!::CreatePrivateObjectSecurity(
		const_cast<SECURITY_DESCRIPTOR *>(pSDParent),
		const_cast<SECURITY_DESCRIPTOR *>(pSDCreator),
		reinterpret_cast<PSECURITY_DESCRIPTOR *>(&m_pSecurityDescriptor),
		bIsDirectoryObject, Token.GetHandle(), GenericMapping))
	{
		return false;
	}

	m_bPrivate = true;
	return true;
}

#if(_WIN32_WINNT >= 0x0500)
inline bool CPrivateObjectSecurityDesc::Create(
	_In_opt_ const CSecurityDesc *pParent,
	_In_opt_ const CSecurityDesc *pCreator,
	_In_opt_ GUID *ObjectType,
	_In_ bool bIsContainerObject,
	_In_ ULONG AutoInheritFlags,
	_In_ const CAccessToken &Token,
	_In_ PGENERIC_MAPPING GenericMapping) throw()
{
	Clear();

	const SECURITY_DESCRIPTOR *pSDParent = pParent ? pParent->GetPSECURITY_DESCRIPTOR() : NULL;
	const SECURITY_DESCRIPTOR *pSDCreator = pCreator ? pCreator->GetPSECURITY_DESCRIPTOR() : NULL;

	if(!::CreatePrivateObjectSecurityEx(
		const_cast<SECURITY_DESCRIPTOR *>(pSDParent),
		const_cast<SECURITY_DESCRIPTOR *>(pSDCreator),
		reinterpret_cast<PSECURITY_DESCRIPTOR *>(&m_pSecurityDescriptor),
		ObjectType, bIsContainerObject, AutoInheritFlags, Token.GetHandle(), GenericMapping))
	{
		return false;
	}

	m_bPrivate = true;
	return true;
}
#endif

inline bool CPrivateObjectSecurityDesc::Get(
	_In_ SECURITY_INFORMATION si,
	_Inout_ CSecurityDesc *pResult) const throw()
{
	ATLASSERT(pResult);
	if(!pResult)
		return false;

	if(!m_bPrivate)
		return false;

	DWORD dwLength = 0;
	SECURITY_DESCRIPTOR *pSDResult = NULL;

	if(!::GetPrivateObjectSecurity(m_pSecurityDescriptor, si, pSDResult, dwLength, &dwLength) &&
		::GetLastError() != ERROR_INSUFFICIENT_BUFFER)
	{
		return false;
	}

	USES_ATL_SAFE_ALLOCA;
	pSDResult = static_cast<SECURITY_DESCRIPTOR *>(_ATL_SAFE_ALLOCA(dwLength, _ATL_SAFE_ALLOCA_DEF_THRESHOLD));
	if (pSDResult == NULL)
	{
		return false;
	}

	if(!::GetPrivateObjectSecurity(m_pSecurityDescriptor, si, pSDResult, dwLength, &dwLength))
		return false;

	*pResult = *pSDResult;

	return true;
}

inline bool CPrivateObjectSecurityDesc::Set(
	_In_ SECURITY_INFORMATION si,
	_In_ const CSecurityDesc &Modification,
	_In_ PGENERIC_MAPPING GenericMapping,
	_In_ const CAccessToken &Token) throw()
{
	if(!m_bPrivate)
		return false;

	const SECURITY_DESCRIPTOR *pSDModification = Modification.GetPSECURITY_DESCRIPTOR();

	return 0 != ::SetPrivateObjectSecurity(si,
		const_cast<SECURITY_DESCRIPTOR *>(pSDModification),
		reinterpret_cast<PSECURITY_DESCRIPTOR *>(&m_pSecurityDescriptor),
		GenericMapping, Token.GetHandle());
}

#if(_WIN32_WINNT >= 0x0500)
inline bool CPrivateObjectSecurityDesc::Set(
	_In_ SECURITY_INFORMATION si,
	_In_ const CSecurityDesc &Modification,
	_In_ ULONG AutoInheritFlags,
	_In_ PGENERIC_MAPPING GenericMapping,
	_In_ const CAccessToken &Token) throw()
{
	if(!m_bPrivate)
		return false;

	const SECURITY_DESCRIPTOR *pSDModification = Modification.GetPSECURITY_DESCRIPTOR();

	return 0 != ::SetPrivateObjectSecurityEx(si,
		const_cast<SECURITY_DESCRIPTOR *>(pSDModification),
		reinterpret_cast<PSECURITY_DESCRIPTOR *>(&m_pSecurityDescriptor),
		AutoInheritFlags, GenericMapping, Token.GetHandle());
}

inline bool CPrivateObjectSecurityDesc::ConvertToAutoInherit(
	_In_opt_ const CSecurityDesc *pParent,
	_In_opt_ GUID *ObjectType,
	_In_ bool bIsDirectoryObject,
	_In_ PGENERIC_MAPPING GenericMapping) throw()
{
	if(!m_bPrivate)
		return false;

	const SECURITY_DESCRIPTOR *pSDParent = pParent ? pParent->GetPSECURITY_DESCRIPTOR() : NULL;
	SECURITY_DESCRIPTOR *pSD;

	if(!::ConvertToAutoInheritPrivateObjectSecurity(
		const_cast<SECURITY_DESCRIPTOR *>(pSDParent),
		m_pSecurityDescriptor,
		reinterpret_cast<PSECURITY_DESCRIPTOR *>(&pSD),
		ObjectType, bIsDirectoryObject, GenericMapping))
	{
		return false;
	}

	Clear();
	m_bPrivate = true;
	m_pSecurityDescriptor = pSD;

	return true;
}

inline void CPrivateObjectSecurityDesc::Clear() throw()
{
	if(m_bPrivate)
	{
		ATLVERIFY(::DestroyPrivateObjectSecurity(reinterpret_cast<PSECURITY_DESCRIPTOR *>(&m_pSecurityDescriptor)));
		m_bPrivate = false;
		m_pSecurityDescriptor = NULL;
	}
	else
		CSecurityDesc::Clear();
}

#endif // _WIN32_WINNT >= 0x500

//*******************************************
// Global functions

inline bool AtlGetSecurityDescriptor(
	_In_z_ LPCTSTR pszObjectName,
	_In_ SE_OBJECT_TYPE ObjectType,
	_Inout_ CSecurityDesc *pSecurityDescriptor,
	_In_ SECURITY_INFORMATION requestedInfo /* =
		OWNER_SECURITY_INFORMATION |
		GROUP_SECURITY_INFORMATION |
		DACL_SECURITY_INFORMATION |
		SACL_SECURITY_INFORMATION */,
	_In_ bool bRequestNeededPrivileges /* = true */) throw(...)
{
	ATLASSERT(pSecurityDescriptor);
	if(!pSecurityDescriptor)
		return false;

	SECURITY_DESCRIPTOR *pSD;
	DWORD dwErr;

	CAccessToken at;
	CTokenPrivileges TokenPrivileges;

	if (!(requestedInfo & SACL_SECURITY_INFORMATION))
		bRequestNeededPrivileges = false;

	if (bRequestNeededPrivileges)
	{
		if(!at.OpenThreadToken(TOKEN_IMPERSONATE | TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY,
					false, false, SecurityImpersonation) ||
				!at.EnablePrivilege(SE_SECURITY_NAME, &TokenPrivileges) ||
				!at.Impersonate())
			return false;
	}

#pragma warning(push)
#pragma warning(disable: 6309 6387)
	/* psdk prefast noise 498088 */
	dwErr = ::GetNamedSecurityInfo(const_cast<LPTSTR>(pszObjectName), ObjectType, requestedInfo, NULL, NULL, NULL, NULL, (PSECURITY_DESCRIPTOR *) &pSD);
#pragma warning(pop)

	if (bRequestNeededPrivileges)
	{
		if( !at.EnableDisablePrivileges(TokenPrivileges) )
			return false;
		if( !at.Revert() )
			return false;
	}

	if(dwErr != ERROR_SUCCESS)
	{
		::SetLastError(dwErr);
		return false;
	}

	*pSecurityDescriptor = *pSD;
	::LocalFree(pSD);
	return true;
}

inline bool AtlGetSecurityDescriptor(
	_In_ HANDLE hObject,
	_In_ SE_OBJECT_TYPE ObjectType,
	_Inout_ CSecurityDesc *pSecurityDescriptor,
	_In_ SECURITY_INFORMATION requestedInfo /* =
		OWNER_SECURITY_INFORMATION |
		GROUP_SECURITY_INFORMATION |
		DACL_SECURITY_INFORMATION |
		SACL_SECURITY_INFORMATION */,
	_In_ bool bRequestNeededPrivileges /* = true */) throw(...)
{
	ATLASSERT(pSecurityDescriptor);
	if(!pSecurityDescriptor)
		return false;

	SECURITY_DESCRIPTOR *pSD;
	DWORD dwErr;

	CAccessToken at;
	CTokenPrivileges TokenPrivileges;

	if (!(requestedInfo & SACL_SECURITY_INFORMATION))
		bRequestNeededPrivileges = false;

	if (bRequestNeededPrivileges)
	{
		if(!at.OpenThreadToken(TOKEN_IMPERSONATE | TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY,
					false, false, SecurityImpersonation) ||
				!at.EnablePrivilege(SE_SECURITY_NAME, &TokenPrivileges) ||
				!at.Impersonate())
			return false;
	}

#pragma warning(push)
#pragma warning(disable: 6309 6387)
	/* psdk prefast noise 498088 */
	dwErr = ::GetSecurityInfo(hObject, ObjectType, requestedInfo, NULL, NULL, NULL, NULL, reinterpret_cast<PSECURITY_DESCRIPTOR *>(&pSD));
#pragma warning(pop)

	if (bRequestNeededPrivileges)
	{
		if( !at.EnableDisablePrivileges(TokenPrivileges) )
			return false;
		if( !at.Revert() )
			return false;
	}

	if(dwErr != ERROR_SUCCESS)
	{
		::SetLastError(dwErr);
		return false;
	}

	*pSecurityDescriptor = *pSD;
	::LocalFree(pSD);
	return true;
}

inline bool AtlGetOwnerSid(
	_In_ HANDLE hObject,
	_In_ SE_OBJECT_TYPE ObjectType,
	_Inout_ CSid *pSid) throw(...)
{
	ATLASSERT(hObject && pSid);
	if(!hObject || !pSid)
		return false;

	SID *pOwner;
	PSECURITY_DESCRIPTOR pSD;

#pragma warning(push)
#pragma warning(disable: 6309 6387)
	/* psdk prefast noise 498088 */
	DWORD dwErr = ::GetSecurityInfo(hObject, ObjectType, OWNER_SECURITY_INFORMATION, (PSID *) &pOwner, NULL, NULL, NULL, &pSD);
#pragma warning(pop)

	if(dwErr != ERROR_SUCCESS)
	{
		::SetLastError(dwErr);
		return false;
	}

	*pSid = *pOwner;
	::LocalFree(pSD);
	return true;
}

inline bool AtlSetOwnerSid(
	_In_ HANDLE hObject,
	_In_ SE_OBJECT_TYPE ObjectType,
	_In_ const CSid &rSid) throw(...)
{
	ATLASSERT(hObject && rSid.IsValid());
	if(!hObject || !rSid.IsValid())
		return false;

	DWORD dwErr = ::SetSecurityInfo(hObject, ObjectType, OWNER_SECURITY_INFORMATION,
		const_cast<SID *>(rSid.GetPSID()), NULL, NULL, NULL);

	::SetLastError(dwErr);
	return ERROR_SUCCESS == dwErr;
}

inline bool AtlGetOwnerSid(
	_In_z_ LPCTSTR pszObjectName,
	_In_ SE_OBJECT_TYPE ObjectType,
	_Inout_ CSid *pSid) throw(...)
{
	ATLASSERT(pszObjectName && pSid);
	if(!pszObjectName || !pSid)
		return false;

	SID *pOwner;
	PSECURITY_DESCRIPTOR pSD;
#pragma warning(push)
#pragma warning(disable: 6309 6387)
	/* psdk prefast noise 498088 */
	DWORD dwErr = ::GetNamedSecurityInfo(const_cast<LPTSTR>(pszObjectName), ObjectType,	OWNER_SECURITY_INFORMATION, reinterpret_cast<PSID *>(&pOwner), NULL, NULL, NULL, &pSD);
#pragma warning(pop)

	if(dwErr != ERROR_SUCCESS)
	{
		::SetLastError(dwErr);
		return false;
	}

	*pSid = *pOwner;
	::LocalFree(pSD);
	return true;
}

inline bool AtlSetOwnerSid(
	_In_z_ LPCTSTR pszObjectName,
	_In_ SE_OBJECT_TYPE ObjectType,
	_In_ const CSid &rSid) throw(...)
{
	ATLASSERT(pszObjectName && rSid.IsValid());
	if(!pszObjectName || !rSid.IsValid())
		return false;

	DWORD dwErr = ::SetNamedSecurityInfo(const_cast<LPTSTR>(pszObjectName), ObjectType,
		OWNER_SECURITY_INFORMATION, const_cast<SID *>(rSid.GetPSID()), NULL, NULL, NULL);

	::SetLastError(dwErr);
	return ERROR_SUCCESS == dwErr;
}

inline bool AtlGetGroupSid(
	_In_ HANDLE hObject,
	_In_ SE_OBJECT_TYPE ObjectType,
	_Inout_ CSid *pSid) throw(...)
{
	ATLASSERT(hObject && pSid);
	if(!hObject || !pSid)
		return false;

	SID *pGroup;
	PSECURITY_DESCRIPTOR pSD;
#pragma warning(push)
#pragma warning(disable: 6309 6387)
	/* psdk prefast noise 498088 */
	DWORD dwErr = ::GetSecurityInfo(hObject, ObjectType, GROUP_SECURITY_INFORMATION, NULL, reinterpret_cast<PSID *>(&pGroup), NULL, NULL, &pSD);
#pragma warning(pop)

	if(dwErr != ERROR_SUCCESS)
	{
		::SetLastError(dwErr);
		return false;
	}

	*pSid = *pGroup;
	::LocalFree(pSD);
	return true;
}

inline bool AtlSetGroupSid(
	_In_ HANDLE hObject,
	_In_ SE_OBJECT_TYPE ObjectType,
	_In_ const CSid &rSid) throw(...)
{
	ATLASSERT(hObject && rSid.IsValid());
	if(!hObject || !rSid.IsValid())
		return false;

	DWORD dwErr = ::SetSecurityInfo(hObject, ObjectType, GROUP_SECURITY_INFORMATION,
		NULL, const_cast<SID *>(rSid.GetPSID()), NULL, NULL);

	::SetLastError(dwErr);
	return ERROR_SUCCESS == dwErr;
}

inline bool AtlGetGroupSid(
	_In_z_ LPCTSTR pszObjectName,
	_In_ SE_OBJECT_TYPE ObjectType,
	_Inout_ CSid *pSid) throw(...)
{
	ATLASSERT(pszObjectName && pSid);
	if(!pszObjectName || !pSid)
		return false;

	SID *pGroup;
	PSECURITY_DESCRIPTOR pSD;
#pragma warning(push)
#pragma warning(disable: 6309 6387)
	/* psdk prefast noise 498088 */
	DWORD dwErr = ::GetNamedSecurityInfo(const_cast<LPTSTR>(pszObjectName),	ObjectType, GROUP_SECURITY_INFORMATION, NULL, reinterpret_cast<PSID *>(&pGroup), NULL, NULL, &pSD);
#pragma warning(pop)

	if(dwErr != ERROR_SUCCESS)
	{
		::SetLastError(dwErr);
		return false;
	}

	*pSid = *pGroup;
	::LocalFree(pSD);
	return true;
}

inline bool AtlSetGroupSid(
	_In_z_ LPCTSTR pszObjectName,
	_In_ SE_OBJECT_TYPE ObjectType,
	_In_ const CSid &rSid) throw(...)
{
	ATLASSERT(pszObjectName && rSid.IsValid());
	if(!pszObjectName || !rSid.IsValid())
		return false;

	DWORD dwErr = ::SetNamedSecurityInfo(const_cast<LPTSTR>(pszObjectName), ObjectType,
		GROUP_SECURITY_INFORMATION, NULL, const_cast<SID *>(rSid.GetPSID()), NULL, NULL);

	::SetLastError(dwErr);
	return ERROR_SUCCESS == dwErr;
}

inline bool AtlGetDacl(
	_In_ HANDLE hObject,
	_In_ SE_OBJECT_TYPE ObjectType,
	_Inout_ CDacl *pDacl) throw(...)
{
	ATLASSERT(hObject && pDacl);
	if(!hObject || !pDacl)
		return false;

	ACL *pAcl;
	PSECURITY_DESCRIPTOR pSD;

#pragma warning(push)
#pragma warning(disable: 6309 6387)
	/* psdk prefast noise 498088 */
	DWORD dwErr = ::GetSecurityInfo(hObject, ObjectType, DACL_SECURITY_INFORMATION, NULL, NULL, &pAcl, NULL, &pSD);
#pragma warning(pop)

	if(dwErr != ERROR_SUCCESS)
	{
		::SetLastError(dwErr);
		return false;
	}

	if(pAcl)
		*pDacl = *pAcl;
	::LocalFree(pSD);

	return NULL != pAcl;
}

inline bool AtlSetDacl(
	_In_ HANDLE hObject,
	_In_ SE_OBJECT_TYPE ObjectType,
	_In_ const CDacl &rDacl,
	_In_ DWORD dwInheritanceFlowControl /* = 0 */) throw(...)
{
	ATLASSERT(hObject);
	if(!hObject)
		return false;

	ATLASSERT(
		dwInheritanceFlowControl == 0 ||
		dwInheritanceFlowControl == PROTECTED_DACL_SECURITY_INFORMATION ||
		dwInheritanceFlowControl == UNPROTECTED_DACL_SECURITY_INFORMATION);

	DWORD dwErr = ::SetSecurityInfo(hObject, ObjectType,
		DACL_SECURITY_INFORMATION | dwInheritanceFlowControl,
		NULL, NULL, const_cast<ACL *>(rDacl.GetPACL()), NULL);

	::SetLastError(dwErr);
	return ERROR_SUCCESS == dwErr;
}

inline bool AtlGetDacl(
	_In_z_ LPCTSTR pszObjectName,
	_In_ SE_OBJECT_TYPE ObjectType,
	_Inout_ CDacl *pDacl) throw(...)
{
	ATLASSERT(pszObjectName && pDacl);
	if(!pszObjectName || !pDacl)
		return false;

	ACL *pAcl;
	PSECURITY_DESCRIPTOR pSD;

#pragma warning(push)
#pragma warning(disable: 6309 6387)
	/* psdk prefast noise 498088 */
	DWORD dwErr = ::GetNamedSecurityInfo(const_cast<LPTSTR>(pszObjectName), ObjectType,	DACL_SECURITY_INFORMATION, NULL, NULL, &pAcl, NULL, &pSD);
#pragma warning(pop)

	if(dwErr != ERROR_SUCCESS)
	{
		::SetLastError(dwErr);
		return false;
	}

	if(pAcl)
		*pDacl = *pAcl;
	::LocalFree(pSD);

	return NULL != pAcl;
}

inline bool AtlSetDacl(
	_In_z_ LPCTSTR pszObjectName,
	_In_ SE_OBJECT_TYPE ObjectType,
	_In_ const CDacl &rDacl,
	_In_ DWORD dwInheritanceFlowControl /* = 0 */) throw(...)
{
	ATLASSERT(pszObjectName);
	if(!pszObjectName)
		return false;

	ATLASSERT(
		dwInheritanceFlowControl == 0 ||
		dwInheritanceFlowControl == PROTECTED_DACL_SECURITY_INFORMATION ||
		dwInheritanceFlowControl == UNPROTECTED_DACL_SECURITY_INFORMATION);

	DWORD dwErr = ::SetNamedSecurityInfo(const_cast<LPTSTR>(pszObjectName), ObjectType,
		DACL_SECURITY_INFORMATION | dwInheritanceFlowControl,
		NULL, NULL, const_cast<ACL *>(rDacl.GetPACL()), NULL);

	::SetLastError(dwErr);
	return ERROR_SUCCESS == dwErr;
}

inline bool AtlGetSacl(
	_In_ HANDLE hObject,
	_In_ SE_OBJECT_TYPE ObjectType,
	_Inout_ CSacl *pSacl,
	_In_ bool bRequestNeededPrivileges /* = true */) throw(...)
{
	ATLASSERT(hObject && pSacl);
	if(!hObject || !pSacl)
		return false;

	ACL *pAcl;
	PSECURITY_DESCRIPTOR pSD;
	CAccessToken at;
	CTokenPrivileges TokenPrivileges;

	if (bRequestNeededPrivileges)
	{
		if(!at.OpenThreadToken(TOKEN_IMPERSONATE | TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY,
					false, false, SecurityImpersonation) ||
				!at.EnablePrivilege(SE_SECURITY_NAME, &TokenPrivileges) ||
				!at.Impersonate())
			return false;
	}

#pragma warning(push)
#pragma warning(disable: 6309 6387)
	/* psdk prefast noise 498088 */
	DWORD dwErr = ::GetSecurityInfo(hObject, ObjectType, SACL_SECURITY_INFORMATION, NULL, NULL, NULL, &pAcl, &pSD);
#pragma warning(pop)

	if (bRequestNeededPrivileges)
	{
        if( !at.EnableDisablePrivileges(TokenPrivileges) )
			return false;
		if( !at.Revert() )
			return false;
	}

	if(dwErr != ERROR_SUCCESS)
	{
		::SetLastError(dwErr);
		return false;
	}

	if(pAcl)
		*pSacl = *pAcl;
	::LocalFree(pSD);

	return NULL != pAcl;
}

inline bool AtlSetSacl(
	_In_ HANDLE hObject,
	_In_ SE_OBJECT_TYPE ObjectType,
	_In_ const CSacl &rSacl,
	_In_ DWORD dwInheritanceFlowControl /* = 0 */,
	_In_ bool bRequestNeededPrivileges /* = true */) throw(...)
{
	ATLASSERT(hObject);
	if (!hObject)
		return false;

	CAccessToken at;
	CTokenPrivileges TokenPrivileges;

	ATLASSERT(
		dwInheritanceFlowControl == 0 ||
		dwInheritanceFlowControl == PROTECTED_SACL_SECURITY_INFORMATION ||
		dwInheritanceFlowControl == UNPROTECTED_SACL_SECURITY_INFORMATION);

	if (bRequestNeededPrivileges)
	{
		if(!at.OpenThreadToken(TOKEN_IMPERSONATE | TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY,
					false, false, SecurityImpersonation) ||
				!at.EnablePrivilege(SE_SECURITY_NAME, &TokenPrivileges) ||
				!at.Impersonate())
			return false;
	}

	DWORD dwErr = ::SetSecurityInfo(hObject, ObjectType,
		SACL_SECURITY_INFORMATION | dwInheritanceFlowControl,
		NULL, NULL, NULL, const_cast<ACL *>(rSacl.GetPACL()));

	if (bRequestNeededPrivileges)
	{
		if( !at.EnableDisablePrivileges(TokenPrivileges) )
			return false;
		if( !at.Revert() )
			return false;
	}

	::SetLastError(dwErr);
	return ERROR_SUCCESS == dwErr;
}

inline bool AtlGetSacl(
	_In_z_ LPCTSTR pszObjectName,
	_In_ SE_OBJECT_TYPE ObjectType,
	_Inout_ CSacl *pSacl,
	_In_ bool bRequestNeededPrivileges /* = true */) throw(...)
{
	ATLASSERT(pszObjectName && pSacl);
	if(!pszObjectName || !pSacl)
		return false;

	ACL *pAcl;
	PSECURITY_DESCRIPTOR pSD;
	CAccessToken at;
	CTokenPrivileges TokenPrivileges;

	if (bRequestNeededPrivileges)
	{
		if(!at.OpenThreadToken(TOKEN_IMPERSONATE | TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY,
					false, false, SecurityImpersonation) ||
				!at.EnablePrivilege(SE_SECURITY_NAME, &TokenPrivileges) ||
				!at.Impersonate())
			return false;
	}

#pragma warning(push)
#pragma warning(disable: 6309 6387)
	/* psdk prefast noise 498088 */
	DWORD dwErr = ::GetNamedSecurityInfo(const_cast<LPTSTR>(pszObjectName), ObjectType,	SACL_SECURITY_INFORMATION, NULL, NULL, NULL, &pAcl, &pSD);
#pragma warning(pop)

	if (bRequestNeededPrivileges)
	{
		at.EnableDisablePrivileges(TokenPrivileges);
		at.Revert();
	}

	::SetLastError(dwErr);
	if(dwErr != ERROR_SUCCESS)
		return false;

	if(pAcl)
		*pSacl = *pAcl;
	::LocalFree(pSD);

	return NULL != pAcl;
}

inline bool AtlSetSacl(
	_In_z_ LPCTSTR pszObjectName,
	_In_ SE_OBJECT_TYPE ObjectType,
	_In_ const CSacl &rSacl,
	_In_ DWORD dwInheritanceFlowControl /* = 0 */,
	_In_ bool bRequestNeededPrivileges /* = true */) throw(...)
{
	ATLASSERT(pszObjectName);
	if (!pszObjectName)
		return false;

	CAccessToken at;
	CTokenPrivileges TokenPrivileges;

	ATLASSERT(
		dwInheritanceFlowControl == 0 ||
		dwInheritanceFlowControl == PROTECTED_SACL_SECURITY_INFORMATION ||
		dwInheritanceFlowControl == UNPROTECTED_SACL_SECURITY_INFORMATION);

	if(bRequestNeededPrivileges)
	{
		if (!at.OpenThreadToken(TOKEN_IMPERSONATE | TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY,
					false, false, SecurityImpersonation) ||
				!at.EnablePrivilege(SE_SECURITY_NAME, &TokenPrivileges) ||
				!at.Impersonate())
			return false;
	}

	DWORD dwErr = ::SetNamedSecurityInfo(const_cast<LPTSTR>(pszObjectName), ObjectType,
		SACL_SECURITY_INFORMATION | dwInheritanceFlowControl,
		NULL, NULL, NULL, const_cast<ACL *>(rSacl.GetPACL()));

	if (bRequestNeededPrivileges)
	{
		at.EnableDisablePrivileges(TokenPrivileges);
		at.Revert();
	}

	::SetLastError(dwErr);
	return ERROR_SUCCESS == dwErr;
}

} // namespace ATL

#pragma warning(pop)

#endif // __ATLSECURITY_INL__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\include\atlsimpstr.h ===
// This is a part of the Active Template Library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Active Template Library Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Active Template Library product.

#ifndef __ATLSIMPSTR_H__
#define __ATLSIMPSTR_H__

#pragma once

#include <atldef.h>
#include <atlcore.h>
#include <atlexcept.h>
#include <atlmem.h>

extern "C"
{
	LONG __cdecl _InterlockedIncrement(/* _Inout_ */ LONG volatile * pn);
	LONG __cdecl _InterlockedDecrement(/* _Inout_ */ LONG volatile * pn);
};

#pragma intrinsic( _InterlockedIncrement )
#pragma intrinsic( _InterlockedDecrement )

#pragma pack(push,_ATL_PACKING)
namespace ATL
{

struct CStringData;

__interface IAtlStringMgr
{
public:
	// Allocate a new CStringData
	CStringData* Allocate(
		_In_ int nAllocLength,
		_In_ int nCharSize) throw();
	// Free an existing CStringData
	void Free(_Inout_ CStringData* pData) throw();
	// Change the size of an existing CStringData
	CStringData* Reallocate(
		_Inout_ CStringData* pData,
		_In_ int nAllocLength,
		_In_ int nCharSize) throw();
	// Get the CStringData for a Nil string
	CStringData* GetNilString() throw();
	IAtlStringMgr* Clone() throw();
};

#ifdef _M_IX86
#ifndef _M_CEE
#define _AtlInterlockedIncrement _InterlockedIncrement
#define _AtlInterlockedDecrement _InterlockedDecrement
#else
#define _AtlInterlockedIncrement InterlockedIncrement
#define _AtlInterlockedDecrement InterlockedDecrement
/* managed code must use the non-intrinsics */
#ifdef InterlockedIncrement
#undef InterlockedIncrement
#endif
#ifdef InterlockedDecrement
#undef InterlockedDecrement
#endif
#endif  // !_M_CEE
#else
#define _AtlInterlockedIncrement InterlockedIncrement
#define _AtlInterlockedDecrement InterlockedDecrement
#endif  // _M_IX86_

struct CStringData
{
	IAtlStringMgr* pStringMgr;  // String manager for this CStringData
	int nDataLength;  // Length of currently used data in XCHARs (not including terminating null)
	int nAllocLength;  // Length of allocated data in XCHARs (not including terminating null)
	long nRefs;     // Reference count: negative == locked
	// XCHAR data[nAllocLength+1]  // A CStringData is always followed in memory by the actual array of character data

	void* data() throw()
	{
		return (this+1);
	}

	void AddRef() throw()
	{
		ATLASSERT(nRefs > 0);
		_AtlInterlockedIncrement(&nRefs);
	}
	bool IsLocked() const throw()
	{
		return nRefs < 0;
	}
	bool IsShared() const throw()
	{
		return( nRefs > 1 );
	}
	void Lock() throw()
	{
		ATLASSERT( nRefs <= 1 );
		nRefs--;  // Locked buffers can't be shared, so no interlocked operation necessary
		if( nRefs == 0 )
		{
			nRefs = -1;
		}
	}
	void Release() throw()
	{
		ATLASSERT( nRefs != 0 );

		if( _AtlInterlockedDecrement( &nRefs ) <= 0 )
		{
			pStringMgr->Free( this );
		}
	}
	void Unlock() throw()
	{
		ATLASSERT( IsLocked() );

		if(IsLocked())
		{
			nRefs++;  // Locked buffers can't be shared, so no interlocked operation necessary
			if( nRefs == 0 )
			{
				nRefs = 1;
			}
		}
	}
};

class CNilStringData :
	public CStringData
{
public:
	CNilStringData() throw()
	{
		pStringMgr = NULL;
		nRefs = 2;  // Never gets freed by IAtlStringMgr
		nDataLength = 0;
		nAllocLength = 0;
		achNil[0] = 0;
		achNil[1] = 0;
	}

	void SetManager(_In_ IAtlStringMgr* pMgr) throw()
	{
		ATLASSERT( pStringMgr == NULL );
		pStringMgr = pMgr;
	}

public:
	wchar_t achNil[2];
};

template< typename BaseType, const int t_nSize >
class CStaticString
{
public:
	CStaticString(_In_z_ const BaseType* psz) :
		m_psz( psz )
	{
	}

	operator const BaseType*() const
	{
		return m_psz;
	}

	static int __cdecl GetLength()
	{
		return (t_nSize/sizeof( BaseType ))-1;
	}

private:
	const BaseType* m_psz;

private:
	CStaticString(_In_ const CStaticString& str) throw();
	CStaticString& operator=(_In_ const CStaticString& str) throw();
};

#define _ST( psz ) ATL::CStaticString< TCHAR, sizeof( _T( psz ) ) >( _T( psz ) )
#define _SA( psz ) ATL::CStaticString< char, sizeof( psz ) >( psz )
#define _SW( psz ) ATL::CStaticString< wchar_t, sizeof( L##psz ) >( L##psz )
#define _SO( psz ) _SW( psz )

template< typename BaseType = char >
class ChTraitsBase
{
public:
	typedef char XCHAR;
	typedef LPSTR PXSTR;
	typedef LPCSTR PCXSTR;
	typedef wchar_t YCHAR;
	typedef LPWSTR PYSTR;
	typedef LPCWSTR PCYSTR;
};

template<>
class ChTraitsBase< wchar_t >
{
public:
	typedef wchar_t XCHAR;
	typedef LPWSTR PXSTR;
	typedef LPCWSTR PCXSTR;
	typedef char YCHAR;
	typedef LPSTR PYSTR;
	typedef LPCSTR PCYSTR;
};

template< typename TCharType, bool t_bMFCDLL = false >
class CStrBufT;

template< typename BaseType , bool t_bMFCDLL = false>
class CSimpleStringT
{
public:
	typedef typename ChTraitsBase< BaseType >::XCHAR XCHAR;
	typedef typename ChTraitsBase< BaseType >::PXSTR PXSTR;
	typedef typename ChTraitsBase< BaseType >::PCXSTR PCXSTR;
	typedef typename ChTraitsBase< BaseType >::YCHAR YCHAR;
	typedef typename ChTraitsBase< BaseType >::PYSTR PYSTR;
	typedef typename ChTraitsBase< BaseType >::PCYSTR PCYSTR;

public:
	explicit CSimpleStringT(_Inout_ IAtlStringMgr* pStringMgr)
	{
		ATLENSURE( pStringMgr != NULL );
		CStringData* pData = pStringMgr->GetNilString();
		Attach( pData );
	}

	CSimpleStringT(_In_ const CSimpleStringT& strSrc)
	{
		CStringData* pSrcData = strSrc.GetData();
		CStringData* pNewData = CloneData( pSrcData );
		Attach( pNewData );
	}

	CSimpleStringT(_In_ const CSimpleStringT<BaseType, !t_bMFCDLL>& strSrc)
	{
		CStringData* pSrcData = strSrc.GetData();
		CStringData* pNewData = CloneData( pSrcData );
		Attach( pNewData );
	}

	CSimpleStringT(
		_In_z_ PCXSTR pszSrc,
		_Inout_ IAtlStringMgr* pStringMgr)
	{
		ATLENSURE( pStringMgr != NULL );

		int nLength = StringLength( pszSrc );
		CStringData* pData = pStringMgr->Allocate( nLength, sizeof( XCHAR ) );
		if( pData == NULL )
		{
			ThrowMemoryException();
		}
		Attach( pData );
		SetLength( nLength );
		CopyChars( m_pszData, nLength, pszSrc, nLength );
	}
	CSimpleStringT(
		_In_count_(nLength) const XCHAR* pchSrc,
		_In_ int nLength,
		_Inout_ IAtlStringMgr* pStringMgr)
	{
		ATLENSURE( pStringMgr != NULL );

		if(pchSrc == NULL && nLength != 0)
			AtlThrow(E_INVALIDARG);

		CStringData* pData = pStringMgr->Allocate( nLength, sizeof( XCHAR ) );
		if( pData == NULL )
		{
			ThrowMemoryException();
		}
		Attach( pData );
		SetLength( nLength );
		CopyChars( m_pszData, nLength, pchSrc, nLength );
	}
	~CSimpleStringT() throw()
	{
		CStringData* pData = GetData();
		pData->Release();
	}

	operator CSimpleStringT<BaseType, !t_bMFCDLL>&()
	{
		return *(CSimpleStringT<BaseType, !t_bMFCDLL>*)this;
	}

	CSimpleStringT& operator=(_In_ const CSimpleStringT& strSrc)
	{
		CStringData* pSrcData = strSrc.GetData();
		CStringData* pOldData = GetData();
		if( pSrcData != pOldData)
		{
			if( pOldData->IsLocked() || pSrcData->pStringMgr != pOldData->pStringMgr )
			{
				SetString( strSrc.GetString(), strSrc.GetLength() );
			}
			else
			{
				CStringData* pNewData = CloneData( pSrcData );
				pOldData->Release();
				Attach( pNewData );
			}
		}

		return( *this );
	}

	CSimpleStringT& operator=(_In_ const CSimpleStringT<BaseType, !t_bMFCDLL>& strSrc)
	{
		CStringData* pSrcData = strSrc.GetData();
		CStringData* pOldData = GetData();
		if( pSrcData != pOldData)
		{
			if( pOldData->IsLocked() || pSrcData->pStringMgr != pOldData->pStringMgr )
			{
				SetString( strSrc.GetString(), strSrc.GetLength() );
			}
			else
			{
				CStringData* pNewData = CloneData( pSrcData );
				pOldData->Release();
				Attach( pNewData );
			}
		}

		return( *this );
	}

	CSimpleStringT& operator=(_In_opt_z_ PCXSTR pszSrc)
	{
		SetString( pszSrc );

		return( *this );
	}

	CSimpleStringT& operator+=(_In_ const CSimpleStringT& strSrc)
	{
		Append( strSrc );

		return( *this );
	}
	template <bool bMFCDLL>
	CSimpleStringT& operator+=(_In_ const CSimpleStringT<BaseType, bMFCDLL>& strSrc)
	{
		Append( strSrc );

		return( *this );
	}

	CSimpleStringT& operator+=(_In_z_ PCXSTR pszSrc)
	{
		Append( pszSrc );

		return( *this );
	}
	template< int t_nSize >
	CSimpleStringT& operator+=(_In_ const CStaticString< XCHAR, t_nSize >& strSrc)
	{
		Append( static_cast<const XCHAR *>(strSrc), strSrc.GetLength() );

		return( *this );
	}
	CSimpleStringT& operator+=(_In_ char ch)
	{
		AppendChar( XCHAR( ch ) );

		return( *this );
	}
	CSimpleStringT& operator+=(_In_ unsigned char ch)
	{
		AppendChar( XCHAR( ch ) );

		return( *this );
	}
	CSimpleStringT& operator+=(_In_ wchar_t ch)
	{
		AppendChar( XCHAR( ch ) );

		return( *this );
	}

	XCHAR operator[](_In_ int iChar) const
	{
		ATLASSERT( (iChar >= 0) && (iChar <= GetLength()) );  // Indexing the '\0' is OK

		if( (iChar < 0) || (iChar > GetLength()) )
			AtlThrow(E_INVALIDARG);

		return( m_pszData[iChar] );
	}

	operator PCXSTR() const throw()
	{
		return( m_pszData );
	}

	void Append(_In_z_ PCXSTR pszSrc)
	{
		Append( pszSrc, StringLength( pszSrc ) );
	}
	void Append(
		_In_count_(nLength) PCXSTR pszSrc,
		_In_ int nLength)
	{
		// See comment in SetString() about why we do this
		UINT_PTR nOffset = pszSrc-GetString();

		UINT nOldLength = GetLength();
		if (nOldLength < 0)
		{
			// protects from underflow
			nOldLength = 0;
		}

		//Make sure the nLength is greater than zero
		ATLENSURE_THROW(nLength >=0, E_INVALIDARG);

		//Make sure we don't read pass end of the terminating NULL
		nLength = StringLengthN(pszSrc, nLength);

		//Make sure after the string doesn't exceed INT_MAX after appending
		ATLENSURE_THROW(INT_MAX - nLength >= static_cast<int>(nOldLength), E_INVALIDARG);

		int nNewLength = nOldLength+nLength;
		PXSTR pszBuffer = GetBuffer( nNewLength );
		if( nOffset <= nOldLength )
		{
			pszSrc = pszBuffer+nOffset;
			// No need to call CopyCharsOverlapped, since the destination is
			// beyond the end of the original buffer
		}
		CopyChars( pszBuffer+nOldLength, nLength, pszSrc, nLength );
		ReleaseBufferSetLength( nNewLength );
	}
	void AppendChar(_In_ XCHAR ch)
	{
		UINT nOldLength = GetLength();
		int nNewLength = nOldLength+1;
		PXSTR pszBuffer = GetBuffer( nNewLength );
		pszBuffer[nOldLength] = ch;
		ReleaseBufferSetLength( nNewLength );
	}
	void Append(_In_ const CSimpleStringT& strSrc)
	{
		Append( strSrc.GetString(), strSrc.GetLength() );
	}
	template <bool bMFCDLL>
	void Append(_In_ const CSimpleStringT<BaseType, bMFCDLL>& strSrc)
	{
		Append( strSrc.GetString(), strSrc.GetLength() );
	}
	void Empty() throw()
	{
		CStringData* pOldData = GetData();
		IAtlStringMgr* pStringMgr = pOldData->pStringMgr;
		if( pOldData->nDataLength == 0 )
		{
			return;
		}

		if( pOldData->IsLocked() )
		{
			// Don't reallocate a locked buffer that's shrinking
			SetLength( 0 );
		}
		else
		{
			pOldData->Release();
			CStringData* pNewData = pStringMgr->GetNilString();
			Attach( pNewData );
		}
	}
	void FreeExtra()
	{
		CStringData* pOldData = GetData();
		int nLength = pOldData->nDataLength;
		IAtlStringMgr* pStringMgr = pOldData->pStringMgr;
		if( pOldData->nAllocLength == nLength )
		{
			return;
		}

		if( !pOldData->IsLocked() )  // Don't reallocate a locked buffer that's shrinking
		{
			CStringData* pNewData = pStringMgr->Allocate( nLength, sizeof( XCHAR ) );
			if( pNewData == NULL )
			{
				SetLength( nLength );
				return;
			}

			CopyChars( PXSTR( pNewData->data() ), nLength,
				PCXSTR( pOldData->data() ), nLength );

			pOldData->Release();
			Attach( pNewData );
			SetLength( nLength );
		}
	}

	int GetAllocLength() const throw()
	{
		return( GetData()->nAllocLength );
	}
	XCHAR GetAt(_In_ int iChar) const
	{
		ATLASSERT( (iChar >= 0) && (iChar <= GetLength()) );  // Indexing the '\0' is OK
		if( (iChar < 0) || (iChar > GetLength()) )
			AtlThrow(E_INVALIDARG);

		return( m_pszData[iChar] );
	}
	PXSTR GetBuffer()
	{
		CStringData* pData = GetData();
		if( pData->IsShared() )
		{
			Fork( pData->nDataLength );
		}

		return( m_pszData );
	}
	_Ret_cap_(nMinBufferLength + 1) PXSTR GetBuffer(_In_ int nMinBufferLength)
	{
		return( PrepareWrite( nMinBufferLength ) );
	}
	_Ret_cap_(nLength + 1) PXSTR GetBufferSetLength(_In_ int nLength)
	{
		PXSTR pszBuffer = GetBuffer( nLength );
		SetLength( nLength );

		return( pszBuffer );
	}
	int GetLength() const throw()
	{
		return( GetData()->nDataLength );
	}
	IAtlStringMgr* GetManager() const throw()
	{
		IAtlStringMgr* pStringMgr = GetData()->pStringMgr;
		return pStringMgr ? pStringMgr->Clone() : NULL;
	}

	_Ret_count_x_(m_nLength) PCXSTR GetString() const throw()
	{
		return( m_pszData );
	}
	bool IsEmpty() const throw()
	{
		return( GetLength() == 0 );
	}
	PXSTR LockBuffer()
	{
		CStringData* pData = GetData();
		if( pData->IsShared() )
		{
			Fork( pData->nDataLength );
			pData = GetData();  // Do it again, because the fork might have changed it
		}
		pData->Lock();

		return( m_pszData );
	}
	void UnlockBuffer() throw()
	{
		CStringData* pData = GetData();
		pData->Unlock();
	}
	void Preallocate(_In_ int nLength)
	{
		PrepareWrite( nLength );
	}
	void ReleaseBuffer(_In_ int nNewLength = -1)
	{
		if( nNewLength == -1 )
		{
			int nAlloc = GetData()->nAllocLength;
			nNewLength = StringLengthN( m_pszData, nAlloc);
		}
		SetLength( nNewLength );
	}
	void ReleaseBufferSetLength(_In_ int nNewLength)
	{
		ATLASSERT( nNewLength >= 0 );
		SetLength( nNewLength );
	}
	void Truncate(_In_ int nNewLength)
	{
		ATLASSERT( nNewLength <= GetLength() );
		GetBuffer( nNewLength );
		ReleaseBufferSetLength( nNewLength );
	}
	void SetAt(
		_In_ int iChar,
		_In_ XCHAR ch)
	{
		ATLASSERT( (iChar >= 0) && (iChar < GetLength()) );

		if( (iChar < 0) || (iChar >= GetLength()) )
			AtlThrow(E_INVALIDARG);

		int nLength = GetLength();
		PXSTR pszBuffer = GetBuffer();
		pszBuffer[iChar] = ch;
		ReleaseBufferSetLength( nLength );

	}
	void SetManager(_Inout_ IAtlStringMgr* pStringMgr)
	{
		ATLASSERT( IsEmpty() );

		CStringData* pData = GetData();
		pData->Release();
		pData = pStringMgr->GetNilString();
		Attach( pData );
	}
	void SetString(_In_opt_z_ PCXSTR pszSrc)
	{
		SetString( pszSrc, StringLength( pszSrc ) );
	}
	void SetString(
		_In_opt_count_(nLength) PCXSTR pszSrc,
		_In_ int nLength)
	{
		if( nLength == 0 )
		{
			Empty();
		}
		else
		{
			// It is possible that pszSrc points to a location inside of our
			// buffer.  GetBuffer() might change m_pszData if (1) the buffer
			// is shared or (2) the buffer is too small to hold the new
			// string.  We detect this aliasing, and modify pszSrc to point
			// into the newly allocated buffer instead.

			if(pszSrc == NULL)
				AtlThrow(E_INVALIDARG);

			UINT nOldLength = GetLength();
			UINT_PTR nOffset = pszSrc-GetString();
			// If 0 <= nOffset <= nOldLength, then pszSrc points into our
			// buffer

			PXSTR pszBuffer = GetBuffer( nLength );
			if( nOffset <= nOldLength )
			{
				CopyCharsOverlapped( pszBuffer, GetAllocLength(),
					pszBuffer+nOffset, nLength );
			}
			else
			{
				CopyChars( pszBuffer, GetAllocLength(), pszSrc, nLength );
			}
			ReleaseBufferSetLength( nLength );
		}
	}

public:
	friend CSimpleStringT operator+(
		_In_ const CSimpleStringT& str1,
		_In_ const CSimpleStringT& str2)
	{
		CSimpleStringT s( str1.GetManager() );

		Concatenate( s, str1, str1.GetLength(), str2, str2.GetLength() );

		return( s );
	}

	friend CSimpleStringT operator+(
		_In_ const CSimpleStringT& str1,
		_In_z_ PCXSTR psz2)
	{
		CSimpleStringT s( str1.GetManager() );

		Concatenate( s, str1, str1.GetLength(), psz2, StringLength( psz2 ) );

		return( s );
	}

	friend CSimpleStringT operator+(
		_In_z_ PCXSTR psz1,
		_In_ const CSimpleStringT& str2)
	{
		CSimpleStringT s( str2.GetManager() );

		Concatenate( s, psz1, StringLength( psz1 ), str2, str2.GetLength() );

		return( s );
	}

	_ATL_INSECURE_DEPRECATE("CSimpleStringT::CopyChars must be passed a buffer size")
	static void __cdecl CopyChars(
		_Out_cap_(nChars) XCHAR* pchDest,
		_In_opt_count_(nChars) const XCHAR* pchSrc,
		_In_ int nChars) throw()
	{
		#pragma warning (push)
		#pragma warning(disable : 4996)
		memcpy( pchDest, pchSrc, nChars*sizeof( XCHAR ) );
		#pragma warning (pop)
	}
	static void __cdecl CopyChars(
		_Out_cap_post_count_(nDestLen,nChars) XCHAR* pchDest,
		_In_ size_t nDestLen,
		_In_opt_count_(nChars) const XCHAR* pchSrc,
		_In_ int nChars) throw()
	{
		memcpy_s( pchDest, nDestLen*sizeof( XCHAR ),
			pchSrc, nChars*sizeof( XCHAR ) );
	}

	_ATL_INSECURE_DEPRECATE("CSimpleStringT::CopyCharsOverlapped must be passed a buffer size")
	static void __cdecl CopyCharsOverlapped(
		_Out_cap_(nChars) XCHAR* pchDest,
		_In_count_(nChars) const XCHAR* pchSrc,
		_In_ int nChars) throw()
	{
		#pragma warning (push)
		#pragma warning(disable : 4996)
		memmove( pchDest, pchSrc, nChars*sizeof( XCHAR ) );
		#pragma warning (pop)
	}
	static void __cdecl CopyCharsOverlapped(
		_Out_cap_post_count_(nDestLen, nDestLen) XCHAR* pchDest,
		_In_ size_t nDestLen,
		_In_count_(nChars) const XCHAR* pchSrc,
		_In_ int nChars) throw()
	{
		memmove_s( pchDest, nDestLen*sizeof( XCHAR ),
			pchSrc, nChars*sizeof( XCHAR ) );
	}
	static int __cdecl StringLength(_In_opt_z_ const char* psz) throw()
	{
		if( psz == NULL )
		{
			return( 0 );
		}
		return( int( strlen( psz ) ) );
	}
	static int __cdecl StringLength(_In_opt_z_ const wchar_t* psz) throw()
	{
		if( psz == NULL )
		{
			return( 0 );
		}
		return( int( wcslen( psz ) ) );
	}
	static int __cdecl StringLengthN(
		_In_opt_z_count_(sizeInXChar) const char* psz,
		_In_ size_t sizeInXChar) throw()
	{
		if( psz == NULL )
		{
			return( 0 );
		}
		return( int( strnlen( psz, sizeInXChar ) ) );
	}
	static int __cdecl StringLengthN(
		_In_opt_z_count_(sizeInXChar) const wchar_t* psz,
		_In_ size_t sizeInXChar) throw()
	{
		if( psz == NULL )
		{
			return( 0 );
		}
		return( int( wcsnlen( psz, sizeInXChar ) ) );
	}

protected:
	static void __cdecl Concatenate(
		_Inout_ CSimpleStringT& strResult,
		_In_count_(nLength1) PCXSTR psz1,
		_In_ int nLength1,
		_In_count_(nLength2) PCXSTR psz2,
		_In_ int nLength2)
	{
		int nNewLength = nLength1+nLength2;
		PXSTR pszBuffer = strResult.GetBuffer( nNewLength );
		CopyChars( pszBuffer, nLength1, psz1, nLength1 );
		CopyChars( pszBuffer+nLength1, nLength2, psz2, nLength2 );
		strResult.ReleaseBufferSetLength( nNewLength );
	}
	ATL_NOINLINE __declspec( noreturn ) static void __cdecl ThrowMemoryException()
	{
		AtlThrow( E_OUTOFMEMORY );
	}

// Implementation
private:
	void Attach(_Inout_ CStringData* pData) throw()
	{
		m_pszData = static_cast< PXSTR >( pData->data() );
	}
	ATL_NOINLINE void Fork(_In_ int nLength)
	{
		CStringData* pOldData = GetData();
		int nOldLength = pOldData->nDataLength;
		CStringData* pNewData = pOldData->pStringMgr->Clone()->Allocate( nLength, sizeof( XCHAR ) );
		if( pNewData == NULL )
		{
			ThrowMemoryException();
		}
		int nCharsToCopy = ((nOldLength < nLength) ? nOldLength : nLength)+1;  // Copy '\0'
		CopyChars( PXSTR( pNewData->data() ), nCharsToCopy,
			PCXSTR( pOldData->data() ), nCharsToCopy );
		pNewData->nDataLength = nOldLength;
		pOldData->Release();
		Attach( pNewData );
	}
	CStringData* GetData() const throw()
	{
		return( reinterpret_cast< CStringData* >( m_pszData )-1 );
	}
	PXSTR PrepareWrite(_In_ int nLength)
	{
		if (nLength < 0)
			AtlThrow(E_INVALIDARG);

		CStringData* pOldData = GetData();
		int nShared = 1-pOldData->nRefs;  // nShared < 0 means true, >= 0 means false
		int nTooShort = pOldData->nAllocLength-nLength;  // nTooShort < 0 means true, >= 0 means false
		if( (nShared|nTooShort) < 0 )  // If either sign bit is set (i.e. either is less than zero), we need to copy data
		{
			PrepareWrite2( nLength );
		}

		return( m_pszData );
	}
	ATL_NOINLINE void PrepareWrite2(_In_ int nLength)
	{
		CStringData* pOldData = GetData();
		if( pOldData->nDataLength > nLength )
		{
			nLength = pOldData->nDataLength;
		}
		if( pOldData->IsShared() )
		{
			Fork( nLength );
		}
		else if( pOldData->nAllocLength < nLength )
		{
			// Grow exponentially, until we hit 1G, then by 1M thereafter.
			int nNewLength = pOldData->nAllocLength;
			if( nNewLength > 1024 * 1024 * 1024 )
			{
				nNewLength += 1024 * 1024;
			}
			else
			{
				// Exponential growth factor is 1.5.
				nNewLength = nNewLength + nNewLength / 2;
			}
			if( nNewLength < nLength )
			{
				nNewLength = nLength;
			}
			Reallocate( nNewLength );
		}
	}
	ATL_NOINLINE void Reallocate(_In_ int nLength)
	{
		CStringData* pOldData = GetData();
		ATLASSERT( pOldData->nAllocLength < nLength );
		IAtlStringMgr* pStringMgr = pOldData->pStringMgr;
		if ( pOldData->nAllocLength >= nLength || nLength <= 0)
		{
			ThrowMemoryException();
			return;
		}
		CStringData* pNewData = pStringMgr->Reallocate( pOldData, nLength, sizeof( XCHAR ) );
		if( pNewData == NULL )
		{
			ThrowMemoryException();
		}
		Attach( pNewData );
	}

	void SetLength(_In_ int nLength)
	{
		ATLASSERT( nLength >= 0 );
		ATLASSERT( nLength <= GetData()->nAllocLength );

		if( nLength < 0 || nLength > GetData()->nAllocLength)
			AtlThrow(E_INVALIDARG);

		GetData()->nDataLength = nLength;
		m_pszData[nLength] = 0;
	}

	static CStringData* __cdecl CloneData(_Inout_ CStringData* pData)
	{
		CStringData* pNewData = NULL;

		IAtlStringMgr* pNewStringMgr = pData->pStringMgr->Clone();
		if( !pData->IsLocked() && (pNewStringMgr == pData->pStringMgr) )
		{
			pNewData = pData;
			pNewData->AddRef();
		}
		else
		{
			pNewData = pNewStringMgr->Allocate( pData->nDataLength, sizeof( XCHAR ) );
			if( pNewData == NULL )
			{
				ThrowMemoryException();
			}
			pNewData->nDataLength = pData->nDataLength;
			CopyChars( PXSTR( pNewData->data() ), pData->nDataLength+1,
				PCXSTR( pData->data() ), pData->nDataLength+1 );  // Copy '\0'
		}

		return( pNewData );
	}

public :
	typedef CStrBufT<BaseType, t_bMFCDLL> CStrBuf;
private:
	PXSTR m_pszData;

	friend class CSimpleStringT<BaseType, !t_bMFCDLL>;
};

template< typename TCharType, bool t_bMFCDLL >
class CStrBufT
{
public:
	typedef CSimpleStringT< TCharType, t_bMFCDLL> StringType;
	typedef typename StringType::XCHAR XCHAR;
	typedef typename StringType::PXSTR PXSTR;
	typedef typename StringType::PCXSTR PCXSTR;

	static const DWORD AUTO_LENGTH = 0x01;  // Automatically determine the new length of the string at release.  The string must be null-terminated.
	static const DWORD SET_LENGTH = 0x02;  // Set the length of the string object at GetBuffer time

public:
	explicit CStrBufT(_In_ StringType& str) throw( ... ) :
		m_str( str ),
		m_pszBuffer( NULL ),
#ifdef _DEBUG
		m_nBufferLength( str.GetLength() ),
#endif
		m_nLength( str.GetLength() )
	{
		m_pszBuffer = m_str.GetBuffer();
	}

	CStrBufT(
			_In_ StringType& str,
			_In_ int nMinLength,
			_In_ DWORD dwFlags = AUTO_LENGTH) throw( ... ) :
		m_str( str ),
		m_pszBuffer( NULL ),
#ifdef _DEBUG
		m_nBufferLength( nMinLength ),
#endif
		m_nLength( (dwFlags&AUTO_LENGTH) ? -1 : nMinLength )
	{
		if( dwFlags&SET_LENGTH )
		{
			m_pszBuffer = m_str.GetBufferSetLength( nMinLength );
		}
		else
		{
			m_pszBuffer = m_str.GetBuffer( nMinLength );
		}
	}

	~CStrBufT()
	{
		m_str.ReleaseBuffer( m_nLength );
	}

	operator PXSTR() throw()
	{
		return( m_pszBuffer );
	}
	operator PCXSTR() const throw()
	{
		return( m_pszBuffer );
	}

	void SetLength(_In_ int nLength)
	{
		ATLASSERT( nLength >= 0 );
		ATLASSERT( nLength <= m_nBufferLength );

		if( nLength < 0 )
			AtlThrow(E_INVALIDARG);

		m_nLength = nLength;
	}

// Implementation
private:
	StringType& m_str;
	PXSTR m_pszBuffer;
	int m_nLength;
#ifdef _DEBUG
	int m_nBufferLength;
#endif

// Private copy constructor and copy assignment operator to prevent accidental use
private:
	CStrBufT(_In_ const CStrBufT&) throw();
	CStrBufT& operator=(_In_ const CStrBufT& ) throw();
};

typedef CSimpleStringT< TCHAR > CSimpleString;
typedef CSimpleStringT< char > CSimpleStringA;
typedef CSimpleStringT< wchar_t > CSimpleStringW;
typedef CStrBufT< TCHAR > CStrBuf;
typedef CStrBufT< char > CStrBufA;
typedef CStrBufT< wchar_t > CStrBufW;

};  // namespace ATL
#pragma pack(pop)

#endif  // __ATLSIMPSTR_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\include\atlsecurity.h ===
// This is a part of the Active Template Library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Active Template Library Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Active Template Library product.
#ifndef __ATLSECURITY_H__
#define __ATLSECURITY_H__

#pragma once

#include <sddl.h>
#include <userenv.h>
#include <aclapi.h>
#include <atlcoll.h>
#include <atlstr.h>

#pragma warning(push)
#pragma warning(disable: 4625) // copy constructor could not be generated because a base class copy constructor is inaccessible
#pragma warning(disable: 4626) // assignment operator could not be generated because a base class assignment operator is inaccessible
#pragma warning(disable: 4571) //catch(...) blocks compiled with /EHs do NOT catch or re-throw Structured Exceptions
#ifndef _CPPUNWIND
#pragma warning (disable : 4702)	// unreachable code
#endif


#pragma pack(push,_ATL_PACKING)
namespace ATL
{
#pragma comment(lib, "userenv.lib")

// **************************************************************
// CSid

class CSid
{

public:
	CSid() throw();

	explicit CSid(
		_In_z_ LPCTSTR pszAccountName,
		_In_opt_z_ LPCTSTR pszSystem = NULL) throw(...);
	explicit CSid(
		_In_ const SID *pSid,
		_In_opt_z_ LPCTSTR pszSystem = NULL) throw(...);
	CSid(
		_In_ const SID_IDENTIFIER_AUTHORITY &IdentifierAuthority,
		_In_ BYTE nSubAuthorityCount, ...) throw(...);
	virtual ~CSid() throw();

	CSid(_In_ const CSid &rhs) throw(...);
	CSid &operator=(_In_ const CSid &rhs) throw(...);

	CSid(_In_ const SID &rhs) throw(...);
	CSid &operator=(_In_ const SID &rhs) throw(...);

	typedef CAtlArray<CSid> CSidArray;

	bool LoadAccount(
		_In_z_ LPCTSTR pszAccountName,
		_In_opt_z_ LPCTSTR pszSystem = NULL) throw(...);
	bool LoadAccount(
		_In_ const SID *pSid,
		_In_opt_z_ LPCTSTR pszSystem = NULL) throw(...);

	LPCTSTR AccountName() const throw(...);
	LPCTSTR Domain() const throw(...);
	LPCTSTR Sid() const throw(...);

	const SID *GetPSID() const throw(...);
	operator const SID *() const throw(...);
	SID_NAME_USE SidNameUse() const throw();

	UINT GetLength() const throw();

	// SID functions
	bool EqualPrefix(_In_ const CSid &rhs) const throw();
	bool EqualPrefix(_In_ const SID &rhs) const throw();

	const SID_IDENTIFIER_AUTHORITY *GetPSID_IDENTIFIER_AUTHORITY() const throw();
	DWORD GetSubAuthority(_In_ DWORD nSubAuthority) const throw();
	UCHAR GetSubAuthorityCount() const throw();
	bool IsValid() const throw();

private:
	void Copy(_In_ const SID &rhs) throw(...);
	void Clear() throw();
	void GetAccountNameAndDomain() const throw(...);
	SID* _GetPSID() const throw();

	BYTE m_buffer[SECURITY_MAX_SID_SIZE];
	bool m_bValid; // true if the CSid has been given a value

	mutable SID_NAME_USE m_sidnameuse;
	mutable CString m_strAccountName;
	mutable CString m_strDomain;
	mutable CString m_strSid;

	CString m_strSystem;
};

bool operator==(
	_In_ const CSid &lhs,
	_In_ const CSid &rhs) throw();
bool operator!=(
	_In_ const CSid &lhs,
	_In_ const CSid &rhs) throw();

// sort operations are provided to allow CSids to be put into
// sorted stl collections (stl::[multi]map, stl::[multi]set)
bool operator<(
	_In_ const CSid &lhs,
	_In_ const CSid &rhs) throw();
bool operator>(
	_In_ const CSid &lhs,
	_In_ const CSid &rhs) throw();
bool operator<=(
	_In_ const CSid &lhs,
	_In_ const CSid &rhs) throw();
bool operator>=(
	_In_ const CSid &lhs,
	_In_ const CSid &rhs) throw();

// **************************************************************
// Well-known sids

namespace Sids
{
// Universal
CSid Null() throw(...);
CSid World() throw(...);
CSid Local() throw(...);
CSid CreatorOwner() throw(...);
CSid CreatorGroup() throw(...);
CSid CreatorOwnerServer() throw(...);
CSid CreatorGroupServer() throw(...);

// NT Authority
CSid Dialup() throw(...);
CSid Network() throw(...);
CSid Batch() throw(...);
CSid Interactive() throw(...);
CSid Service() throw(...);
CSid AnonymousLogon() throw(...);
CSid Proxy() throw(...);
CSid ServerLogon() throw(...);
CSid Self() throw(...);
CSid AuthenticatedUser() throw(...);
CSid RestrictedCode() throw(...);
CSid TerminalServer() throw(...);
CSid System() throw(...);
CSid NetworkService() throw (...);

// NT Authority\BUILTIN
CSid Admins() throw(...);
CSid Users() throw(...);
CSid Guests() throw(...);
CSid PowerUsers() throw(...);
CSid AccountOps() throw(...);
CSid SystemOps() throw(...);
CSid PrintOps() throw(...);
CSid BackupOps() throw(...);
CSid Replicator() throw(...);
CSid RasServers() throw(...);
CSid PreW2KAccess() throw(...);
} // namespace Sids

//***************************************
// CAcl
//		CAce
//
//		CDacl
//			CAccessAce
//
//		CSacl
//			CAuditAce
//***************************************

// **************************************************************
// CAcl

class CAcl
{
public:
	CAcl() throw();
	virtual ~CAcl() throw();

	CAcl(_In_ const CAcl &rhs) throw(...);
	CAcl &operator=(_In_ const CAcl &rhs) throw(...);

	typedef CAtlArray<ACCESS_MASK> CAccessMaskArray;
	typedef CAtlArray<BYTE> CAceTypeArray;
	typedef CAtlArray<BYTE> CAceFlagArray;

	void GetAclEntries(
		_Out_ CSid::CSidArray *pSids,
		_Out_opt_ CAccessMaskArray *pAccessMasks = NULL,
		_Out_opt_ CAceTypeArray *pAceTypes = NULL,
		_Out_opt_ CAceFlagArray *pAceFlags = NULL) const throw(...);
	void GetAclEntry(
		_In_ UINT nIndex,
		_Inout_opt_ CSid* pSid,
		_Out_opt_ ACCESS_MASK* pMask = NULL,
		_Out_opt_ BYTE* pType = NULL,
		_Out_opt_ BYTE* pFlags = NULL,
		_Out_opt_ GUID* pObjectType = NULL,
		_Out_opt_ GUID* pInheritedObjectType = NULL) const throw(...);

	bool RemoveAces(_In_ const CSid &rSid) throw(...);

	virtual UINT GetAceCount() const throw() = 0;
	virtual void RemoveAllAces() throw() = 0;
	virtual void RemoveAce(_In_ UINT nIndex) = 0;

	const ACL *GetPACL() const throw(...);
	operator const ACL *() const throw(...);
	UINT GetLength() const throw(...);

	void SetNull() throw();
	void SetEmpty() throw();
	bool IsNull() const throw();
	bool IsEmpty() const throw();

private:
	mutable ACL *m_pAcl;
	bool m_bNull;

protected:
	void Dirty() throw();

	class CAce
	{
	public:
		CAce(
			_In_ const CSid &rSid,
			_In_ ACCESS_MASK accessmask,
			_In_ BYTE aceflags) throw(...);
		virtual ~CAce() throw();

		CAce(_In_ const CAce &rhs) throw(...);
		CAce &operator=(_In_ const CAce &rhs) throw(...);

		virtual void *GetACE() const throw(...) = 0;
		virtual UINT GetLength() const throw() = 0;
		virtual BYTE AceType() const throw() = 0;
		virtual bool IsObjectAce() const throw();
		virtual GUID ObjectType() const throw();
		virtual GUID InheritedObjectType() const throw();

		ACCESS_MASK AccessMask() const throw();
		BYTE AceFlags() const throw();
		const CSid &Sid() const throw();

		void AddAccess(_In_ ACCESS_MASK accessmask) throw();

	protected:
		CSid m_sid;
		ACCESS_MASK m_dwAccessMask;
		BYTE m_aceflags;
		mutable void *m_pAce;
	};

	virtual const CAce *GetAce(_In_ UINT nIndex) const = 0;
	virtual void PrepareAcesForACL() const throw();

	DWORD m_dwAclRevision;
};

// ************************************************
// CDacl

class CDacl :
	public CAcl
{
public:
	CDacl() throw();
	virtual ~CDacl() throw();

	CDacl(_In_ const CDacl &rhs) throw(...);
	CDacl &operator=(_In_ const CDacl &rhs) throw(...);

	CDacl(_In_ const ACL &rhs) throw(...);
	CDacl &operator=(_In_ const ACL &rhs) throw(...);

	bool AddAllowedAce(
		_In_ const CSid &rSid,
		_In_ ACCESS_MASK accessmask,
		_In_ BYTE aceflags = 0) throw(...);
	bool AddDeniedAce(
		_In_ const CSid &rSid,
		_In_ ACCESS_MASK accessmask,
		_In_ BYTE aceflags = 0) throw(...);
#if(_WIN32_WINNT >= 0x0500)
	bool AddAllowedAce(
		_In_ const CSid &rSid,
		_In_ ACCESS_MASK accessmask,
		_In_ BYTE aceflags,
		_In_ const GUID *pObjectType,
		_In_ const GUID *pInheritedObjectType) throw(...);
	bool AddDeniedAce(
		_In_ const CSid &rSid,
		_In_ ACCESS_MASK accessmask,
		_In_ BYTE aceflags,
		_In_ const GUID *pObjectType,
		_In_ const GUID *pInheritedObjectType) throw(...);
#endif
	void RemoveAllAces() throw();
	void RemoveAce(_In_ UINT nIndex);

	UINT GetAceCount() const throw();

private:
	void Copy(_In_ const CDacl &rhs) throw(...);
	void Copy(_In_ const ACL &rhs) throw(...);

	class CAccessAce : 
		public CAcl::CAce
	{
	public:
		CAccessAce(
			_In_ const CSid &rSid,
			_In_ ACCESS_MASK accessmask,
			_In_ BYTE aceflags,
			_In_ bool bAllowAccess) throw(...);
		virtual ~CAccessAce() throw();

		void *GetACE() const throw(...);
		UINT GetLength() const throw();
		BYTE AceType() const throw();

		bool Allow() const throw();
		bool Inherited() const throw();

		static int Order(
			_In_ const CAccessAce &lhs,
			_In_ const CAccessAce &rhs) throw();

	protected:
		bool m_bAllow;
	};

#if(_WIN32_WINNT >= 0x0500)
	class CAccessObjectAce : 
		public CAccessAce
	{
	public:
		CAccessObjectAce(
			_In_ const CSid &rSid,
			_In_ ACCESS_MASK accessmask,
			_In_ BYTE aceflags,
			_In_ bool bAllowAccess,
			_In_opt_ const GUID *pObjectType,
			_In_opt_ const GUID *pInheritedObjectType) throw(...);
		virtual ~CAccessObjectAce() throw();

		CAccessObjectAce(_In_ const CAccessObjectAce &rhs) throw(...);
		CAccessObjectAce &operator=(_In_ const CAccessObjectAce &rhs) throw(...);

		void *GetACE() const throw(...);
		UINT GetLength() const throw();
		BYTE AceType() const throw();
		bool IsObjectAce() const throw();
		virtual GUID ObjectType() const throw();
		virtual GUID InheritedObjectType() const throw();

	protected:
		GUID *m_pObjectType;
		GUID *m_pInheritedObjectType;
	};

#endif
	const CAcl::CAce *GetAce(_In_ UINT nIndex) const;

	void PrepareAcesForACL() const throw();

	mutable CAutoPtrArray<CAccessAce> m_acl;
};

//******************************************
// CSacl

class CSacl : 
	public CAcl
{
public:
	CSacl() throw();
	virtual ~CSacl() throw();

	CSacl(_In_ const CSacl &rhs) throw(...);
	CSacl &operator=(_In_ const CSacl &rhs) throw(...);

	CSacl(_In_ const ACL &rhs) throw(...);
	CSacl &operator=(_In_ const ACL &rhs) throw(...);

	bool AddAuditAce(
		_In_ const CSid &rSid,
		_In_ ACCESS_MASK accessmask,
		_In_ bool bSuccess,
		_In_ bool bFailure,
		_In_ BYTE aceflags = 0) throw(...);
#if(_WIN32_WINNT >= 0x0500)
	bool AddAuditAce(
		_In_ const CSid &rSid,
		_In_ ACCESS_MASK accessmask,
		_In_ bool bSuccess,
		_In_ bool bFailure,
		_In_ BYTE aceflags,
		_In_ const GUID *pObjectType,
		_In_ const GUID *pInheritedObjectType) throw(...);
#endif
	void RemoveAllAces() throw();
	void RemoveAce(_In_ UINT nIndex);

	UINT GetAceCount() const throw();

private:
	void Copy(_In_ const CSacl &rhs) throw(...);
	void Copy(_In_ const ACL &rhs) throw(...);

	class CAuditAce : 
		public CAcl::CAce
	{
	public:
		CAuditAce(
			_In_ const CSid &rSid,
			_In_ ACCESS_MASK accessmask,
			_In_ BYTE aceflags,
			_In_ bool bAuditSuccess,
			_In_ bool bAuditFailure) throw(...);
		virtual ~CAuditAce() throw();

		void *GetACE() const throw(...);
		UINT GetLength() const throw();
		BYTE AceType() const throw();
	protected:
		bool m_bSuccess;
		bool m_bFailure;
	};

#if(_WIN32_WINNT >= 0x0500)
	class CAuditObjectAce :
		public CAuditAce
	{
	public:
		CAuditObjectAce(
			_In_ const CSid &rSid,
			_In_ ACCESS_MASK accessmask,
			_In_ BYTE aceflags,
			_In_ bool bAuditSuccess,
			_In_ bool bAuditFailure,
			_In_opt_ const GUID *pObjectType,
			_In_opt_ const GUID *pInheritedObjectType) throw(...);
		virtual ~CAuditObjectAce() throw();

		CAuditObjectAce(_In_ const CAuditObjectAce &rhs) throw(...);
		CAuditObjectAce &operator=(_In_ const CAuditObjectAce &rhs) throw(...);

		void *GetACE() const throw(...);
		UINT GetLength() const throw();
		BYTE AceType() const throw();
		bool IsObjectAce() const throw();
		virtual GUID ObjectType() const throw();
		virtual GUID InheritedObjectType() const throw();

	protected:
		GUID *m_pObjectType;
		GUID *m_pInheritedObjectType;
	};
#endif
	const CAce *GetAce(_In_ UINT nIndex) const;

	CAutoPtrArray<CAuditAce> m_acl;
};

//******************************************
// CSecurityDesc

class CSecurityDesc
{
public:
	CSecurityDesc() throw();
	virtual ~CSecurityDesc() throw();

	CSecurityDesc(_In_ const CSecurityDesc &rhs) throw(...);
	CSecurityDesc &operator=(_In_ const CSecurityDesc &rhs) throw(...);

	CSecurityDesc(_In_ const SECURITY_DESCRIPTOR &rhs) throw(...);
	CSecurityDesc &operator=(_In_ const SECURITY_DESCRIPTOR &rhs) throw(...);

#if(_WIN32_WINNT >= 0x0500)
	bool FromString(_In_z_ LPCTSTR pstr) throw(...);
	bool ToString(
		_In_ CString *pstr,
		_In_ SECURITY_INFORMATION si =
			OWNER_SECURITY_INFORMATION |
			GROUP_SECURITY_INFORMATION |
			DACL_SECURITY_INFORMATION |
			SACL_SECURITY_INFORMATION) const throw(...);
#endif

	void SetOwner(
		_In_ const CSid &sid,
		_In_ bool bDefaulted = false) throw(...);
	void SetGroup(
		_In_ const CSid &sid,
		_In_ bool bDefaulted = false) throw(...);
	void SetDacl(
		_In_ const CDacl &Dacl,
		_In_ bool bDefaulted = false) throw(...);
	void SetDacl(
		_In_ bool bPresent,
		_In_ bool bDefaulted = false) throw(...);
	void SetSacl(
		_In_ const CSacl &Sacl,
		_In_ bool bDefaulted = false) throw(...);
	bool GetOwner(
		_Out_ CSid *pSid,
		_Out_opt_ bool *pbDefaulted = NULL) const throw(...);
	bool GetGroup(
		_Out_ CSid *pSid,
		_Out_opt_ bool *pbDefaulted = NULL) const throw(...);
	bool GetDacl(
		_Out_ CDacl *pDacl,
		_Out_opt_ bool *pbPresent = NULL,
		_Out_opt_ bool *pbDefaulted = NULL) const throw(...);
	bool GetSacl(
		_Out_ CSacl *pSacl,
		_Out_opt_ bool *pbPresent = NULL,
		_Out_opt_ bool *pbDefaulted = NULL) const throw(...);

	bool IsDaclDefaulted() const throw();
	bool IsDaclPresent() const throw();
	bool IsGroupDefaulted() const throw();
	bool IsOwnerDefaulted() const throw();
	bool IsSaclDefaulted() const throw();
	bool IsSaclPresent() const throw();
	bool IsSelfRelative() const throw();

	// Only meaningful on Win2k or better
	bool IsDaclAutoInherited() const throw();
	bool IsDaclProtected() const throw();
	bool IsSaclAutoInherited() const throw();
	bool IsSaclProtected() const throw();

	const SECURITY_DESCRIPTOR *GetPSECURITY_DESCRIPTOR() const throw();
	operator const SECURITY_DESCRIPTOR *() const throw();

	void GetSECURITY_DESCRIPTOR(
		_Out_ SECURITY_DESCRIPTOR *pSD,
		_Inout_ LPDWORD lpdwBufferLength) throw(...);

	UINT GetLength() throw();

	bool GetControl(_Out_ SECURITY_DESCRIPTOR_CONTROL *psdc) const throw();
#if(_WIN32_WINNT >= 0x0500)
	bool SetControl(
		_In_ SECURITY_DESCRIPTOR_CONTROL ControlBitsOfInterest,
		_In_ SECURITY_DESCRIPTOR_CONTROL ControlBitsToSet) throw();
#endif

	void MakeSelfRelative() throw(...);
	void MakeAbsolute() throw(...);

protected:
	virtual void Clear() throw();
	void AllocateAndInitializeSecurityDescriptor() throw(...);
	void Init(_In_ const SECURITY_DESCRIPTOR &rhs) throw(...);

	SECURITY_DESCRIPTOR *m_pSecurityDescriptor;
};

// **************************************************************
// CSecurityAttributes

class CSecurityAttributes :
	public SECURITY_ATTRIBUTES
{
public:
	CSecurityAttributes() throw();
	explicit CSecurityAttributes(
		_In_ const CSecurityDesc &rSecurityDescriptor,
		_In_ bool bInheritHandle = false) throw(...);

	void Set(
		_In_ const CSecurityDesc &rSecurityDescriptor,
		_In_ bool bInheritHandle = false) throw(...);

protected:
	CSecurityDesc m_SecurityDescriptor;
};

template<>
class CElementTraits< LUID > :
	public CElementTraitsBase< LUID >
{
public:
	typedef const LUID& INARGTYPE;
	typedef LUID& OUTARGTYPE;

	static ULONG Hash(_In_ INARGTYPE luid) throw()
	{
		return luid.HighPart ^ luid.LowPart;
	}

	static BOOL CompareElements(
		_In_ INARGTYPE element1,
		_In_ INARGTYPE element2) throw()
	{
		return element1.HighPart == element2.HighPart && element1.LowPart == element2.LowPart;
	}

	static int CompareElementsOrdered(
		_In_ INARGTYPE element1,
		_In_ INARGTYPE element2 ) throw()
	{
		_LARGE_INTEGER li1, li2;
		li1.LowPart = element1.LowPart;
		li1.HighPart = element1.HighPart;
		li2.LowPart = element2.LowPart;
		li2.HighPart = element2.HighPart;

		if( li1.QuadPart > li2.QuadPart )
			return( 1 );
		else if( li1.QuadPart < li2.QuadPart )
			return( -1 );

		return( 0 );
	}
};

typedef CAtlArray<LUID> CLUIDArray;

//******************************************************
// CTokenPrivileges

class CTokenPrivileges
{
public:
	CTokenPrivileges() throw();
	virtual ~CTokenPrivileges() throw();

	CTokenPrivileges(_In_ const CTokenPrivileges &rhs) throw(...);
	CTokenPrivileges &operator=(_In_ const CTokenPrivileges &rhs) throw(...);

	CTokenPrivileges(_In_ const TOKEN_PRIVILEGES &rPrivileges) throw(...);
	CTokenPrivileges &operator=(_In_ const TOKEN_PRIVILEGES &rPrivileges) throw(...);

	void Add(_In_ const TOKEN_PRIVILEGES &rPrivileges) throw(...);
	bool Add(
		_In_z_ LPCTSTR pszPrivilege,
		_In_ bool bEnable) throw(...);

	typedef CAtlArray<CString> CNames;
	typedef CAtlArray<DWORD> CAttributes;

	bool LookupPrivilege(
		_In_z_ LPCTSTR pszPrivilege,
		_Out_opt_ DWORD *pdwAttributes = NULL) const throw(...);
	void GetNamesAndAttributes(
		_Inout_ CNames *pNames,
		_Inout_opt_ CAttributes *pAttributes = NULL) const throw(...);
	void GetDisplayNames(_Inout_ CNames *pDisplayNames) const throw(...);
	void GetLuidsAndAttributes(
		_Inout_ CLUIDArray *pPrivileges,
		_Inout_opt_ CAttributes *pAttributes = NULL) const throw(...);

	bool Delete(_In_z_ LPCTSTR pszPrivilege) throw();
	void DeleteAll() throw();

	UINT GetCount() const throw();
	UINT GetLength() const throw();

	const TOKEN_PRIVILEGES *GetPTOKEN_PRIVILEGES() const throw(...);
	operator const TOKEN_PRIVILEGES *() const throw(...);

private:
	typedef CAtlMap<LUID, DWORD> Map;
	Map m_mapTokenPrivileges;
	mutable TOKEN_PRIVILEGES *m_pTokenPrivileges;
	bool m_bDirty;

	void AddPrivileges(_In_ const TOKEN_PRIVILEGES &rPrivileges) throw(...);
};

//******************************************************
// CTokenGroups

class CTokenGroups
{
public:
	CTokenGroups() throw();
	virtual ~CTokenGroups() throw();

	CTokenGroups(_In_ const CTokenGroups &rhs) throw(...);
	CTokenGroups &operator=(_In_ const CTokenGroups &rhs) throw(...);

	CTokenGroups(_In_ const TOKEN_GROUPS &rhs) throw(...);
	CTokenGroups &operator=(_In_ const TOKEN_GROUPS &rhs) throw(...);

	void Add(_In_ const TOKEN_GROUPS &rTokenGroups) throw(...);
	void Add(_In_ const CSid &rSid, _In_ DWORD dwAttributes) throw(...);

	bool LookupSid(
		_In_ const CSid &rSid,
		_Out_opt_ DWORD *pdwAttributes = NULL) const throw();
	void GetSidsAndAttributes(
		_Inout_ CSid::CSidArray *pSids,
		_Inout_opt_ CAtlArray<DWORD> *pAttributes = NULL) const throw(...);

	bool Delete(_In_ const CSid &rSid) throw();
	void DeleteAll() throw();

	UINT GetCount() const throw();
	UINT GetLength() const throw();

	const TOKEN_GROUPS *GetPTOKEN_GROUPS() const throw(...);
	operator const TOKEN_GROUPS *() const throw(...);

private:
	class CTGElementTraits :
		public CElementTraitsBase< CSid >
	{
	public:
		static UINT Hash(_In_ const CSid &sid) throw()
		{
			return sid.GetSubAuthority(sid.GetSubAuthorityCount() - 1);
		}

		static bool CompareElements(
			_In_ INARGTYPE element1,
			_In_ INARGTYPE element2 ) throw()
		{
			return( element1 == element2 );
		}
	};

	typedef CAtlMap<CSid, DWORD, CTGElementTraits> Map;
	Map m_mapTokenGroups;
	mutable TOKEN_GROUPS *m_pTokenGroups;
	mutable bool m_bDirty;

	void AddTokenGroups(_In_ const TOKEN_GROUPS &rTokenGroups) throw(...);
};

// *************************************
// CAccessToken

class CAccessToken
{
public:
	CAccessToken() throw();
	virtual ~CAccessToken() throw();

	void Attach(_In_ HANDLE hToken) throw();
	HANDLE Detach() throw();
	HANDLE GetHandle() const throw();
	HKEY HKeyCurrentUser() const throw();

	// Privileges
	bool EnablePrivilege(
		_In_z_ LPCTSTR pszPrivilege,
		_In_opt_ CTokenPrivileges *pPreviousState = NULL,
		_Out_opt_ bool* pbErrNotAllAssigned=NULL) throw(...);
	bool EnablePrivileges(
		_In_ const CAtlArray<LPCTSTR> &rPrivileges,
		_Inout_opt_ CTokenPrivileges *pPreviousState = NULL,
		_Out_opt_ bool* pbErrNotAllAssigned=NULL) throw(...);
	bool DisablePrivilege(
		_In_z_ LPCTSTR pszPrivilege,
		_In_opt_ CTokenPrivileges *pPreviousState = NULL,
		_Out_opt_ bool* pbErrNotAllAssigned=NULL) throw(...);
	bool DisablePrivileges(
		_In_ const CAtlArray<LPCTSTR> &rPrivileges,
		_Inout_opt_ CTokenPrivileges *pPreviousState = NULL,
		_Out_opt_ bool* pbErrNotAllAssigned=NULL) throw(...);
	bool EnableDisablePrivileges(
		_In_ const CTokenPrivileges &rPrivilenges,
		_Inout_opt_ CTokenPrivileges *pPreviousState = NULL,
		_Out_opt_ bool* pbErrNotAllAssigned=NULL) throw(...);
	bool PrivilegeCheck(
		_In_ PPRIVILEGE_SET RequiredPrivileges,
		_Out_ bool *pbResult) const throw();

	bool GetLogonSid(_Inout_ CSid *pSid) const throw(...);
	bool GetTokenId(_Out_ LUID *pluid) const throw(...);
	bool GetLogonSessionId(_Out_ LUID *pluid) const throw(...);

	bool CheckTokenMembership(
		_In_ const CSid &rSid,
		_Inout_ bool *pbIsMember) const throw(...);
#if(_WIN32_WINNT >= 0x0500)
	bool IsTokenRestricted() const throw();
#endif

	// Token Information
protected:
	void InfoTypeToRetType(
		_Inout_ CSid *pRet,
		_In_ const TOKEN_USER &rWork) const throw(...)
	{
		ATLENSURE(pRet);
		*pRet = *static_cast<SID *>(rWork.User.Sid);
	}

	void InfoTypeToRetType(
		_Inout_ CTokenGroups *pRet,
		_In_ const TOKEN_GROUPS &rWork) const throw(...)
	{
		ATLENSURE(pRet);
		*pRet = rWork;
	}

	void InfoTypeToRetType(
		_Inout_ CTokenPrivileges *pRet,
		_In_ const TOKEN_PRIVILEGES &rWork) const throw(...)
	{
		ATLENSURE(pRet);
		*pRet = rWork;
	}

	void InfoTypeToRetType(
		_Inout_ CSid *pRet,
		_In_ const TOKEN_OWNER &rWork) const throw(...)
	{
		ATLENSURE(pRet);
		*pRet = *static_cast<SID *>(rWork.Owner);
	}

	void InfoTypeToRetType(
		_Inout_ CSid *pRet,
		_In_ const TOKEN_PRIMARY_GROUP &rWork) const throw(...)
	{
		ATLENSURE(pRet);
		*pRet = *static_cast<SID *>(rWork.PrimaryGroup);
	}

	void InfoTypeToRetType(
		_Inout_ CDacl *pRet,
		_In_ const TOKEN_DEFAULT_DACL &rWork) const throw(...)
	{
		ATLENSURE(pRet);
		*pRet = *rWork.DefaultDacl;
	}

	template<typename RET_T, typename INFO_T>
	bool GetInfoConvert(
		_Inout_ RET_T *pRet,
		_In_ TOKEN_INFORMATION_CLASS TokenClass,
		_Out_opt_ INFO_T *pWork = NULL) const throw(...)
	{
		ATLASSERT(pRet);
		if(!pRet)
			return false;

		DWORD dwLen;
		::GetTokenInformation(m_hToken, TokenClass, NULL, 0, &dwLen);
		if(::GetLastError() != ERROR_INSUFFICIENT_BUFFER)
			return false;

		USES_ATL_SAFE_ALLOCA;
		pWork = static_cast<INFO_T *>(_ATL_SAFE_ALLOCA(dwLen, _ATL_SAFE_ALLOCA_DEF_THRESHOLD));
		if (pWork == NULL)
			return false;
		if(!::GetTokenInformation(m_hToken, TokenClass, pWork, dwLen, &dwLen))
			return false;

		InfoTypeToRetType(pRet, *pWork);
		return true;
	}

	template<typename RET_T>
	bool GetInfo(
		_Inout_ RET_T *pRet,
		_In_ TOKEN_INFORMATION_CLASS TokenClass) const throw(...)
	{
		ATLASSERT(pRet);
		if(!pRet)
			return false;

		DWORD dwLen;
		if(!::GetTokenInformation(m_hToken, TokenClass, pRet, sizeof(RET_T), &dwLen))
			return false;
		return true;
	}

public:
	bool GetDefaultDacl(_Inout_ CDacl *pDacl) const throw(...);
	bool GetGroups(_Inout_ CTokenGroups *pGroups) const throw(...);
	bool GetImpersonationLevel(_Inout_ SECURITY_IMPERSONATION_LEVEL *pImpersonationLevel) const throw(...);
	bool GetOwner(_Inout_ CSid *pSid) const throw(...);
	bool GetPrimaryGroup(_Inout_ CSid *pSid) const throw(...);
	bool GetPrivileges(_Inout_ CTokenPrivileges *pPrivileges) const throw(...);
	bool GetTerminalServicesSessionId(_Inout_ DWORD *pdwSessionId) const throw(...);
	bool GetSource(_Inout_ TOKEN_SOURCE *pSource) const throw(...);
	bool GetStatistics(_Inout_ TOKEN_STATISTICS *pStatistics) const throw(...);
	bool GetType(_Inout_ TOKEN_TYPE *pType) const throw(...);
	bool GetUser(_Inout_ CSid *pSid) const throw(...);

	bool SetOwner(_In_ const CSid &rSid) throw(...);
	bool SetPrimaryGroup(_In_ const CSid &rSid) throw(...);
	bool SetDefaultDacl(_In_ const CDacl &rDacl) throw(...);

	bool CreateImpersonationToken(
		_Inout_ CAccessToken *pImp,
		_In_ SECURITY_IMPERSONATION_LEVEL sil = SecurityImpersonation) const throw(...);
	bool CreatePrimaryToken(
		_Inout_ CAccessToken *pPri,
		_In_ DWORD dwDesiredAccess = MAXIMUM_ALLOWED,
		_In_opt_ const CSecurityAttributes *pTokenAttributes = NULL) const throw(...);

#if(_WIN32_WINNT >= 0x0500)
	bool CreateRestrictedToken(
		_Inout_ CAccessToken *pRestrictedToken,
		_In_ const CTokenGroups &SidsToDisable,
		_In_ const CTokenGroups &SidsToRestrict,
		_In_ const CTokenPrivileges &PrivilegesToDelete = CTokenPrivileges()) const throw(...);
#endif

	// Token API type functions
	bool GetProcessToken(
		_In_ DWORD dwDesiredAccess,
		_In_opt_ HANDLE hProcess = NULL) throw();
	bool GetThreadToken(
		_In_ DWORD dwDesiredAccess,
		_In_opt_ HANDLE hThread = NULL,
		_In_ bool bOpenAsSelf = true) throw();
	bool GetEffectiveToken(_In_ DWORD dwDesiredAccess) throw();

	bool OpenThreadToken(
		_In_ DWORD dwDesiredAccess,
		_In_ bool bImpersonate = false,
		_In_ bool bOpenAsSelf = true,
		_In_ SECURITY_IMPERSONATION_LEVEL sil = SecurityImpersonation) throw(...);

#if (_WIN32_WINNT >= 0x0400 ) || defined(_WIN32_DCOM)
	bool OpenCOMClientToken(
		_In_ DWORD dwDesiredAccess,
		_In_ bool bImpersonate = false,
		_In_ bool bOpenAsSelf = true) throw(...);
#endif //(_WIN32_WINNT >= 0x0400 ) || defined(_WIN32_DCOM)

	bool OpenNamedPipeClientToken(
		_In_ HANDLE hPipe,
		_In_ DWORD dwDesiredAccess,
		_In_ bool bImpersonate = false,
		_In_ bool bOpenAsSelf = true) throw(...);
	bool OpenRPCClientToken(
		_In_ RPC_BINDING_HANDLE BindingHandle,
		_In_ DWORD dwDesiredAccess,
		_In_ bool bImpersonate = false,
		_In_ bool bOpenAsSelf = true) throw(...);

	bool ImpersonateLoggedOnUser() const throw(...);
	bool Impersonate(_In_opt_ HANDLE hThread = NULL) const throw(...);
	bool Revert(_In_opt_ HANDLE hThread = NULL) const throw();

	bool LoadUserProfile() throw(...);
	HANDLE GetProfile() const throw();

	// Must hold Tcb privilege
	bool LogonUser(
		_In_z_ LPCTSTR pszUserName,
		_In_z_ LPCTSTR pszDomain,
		_In_z_ LPCTSTR pszPassword,
		_In_ DWORD dwLogonType = LOGON32_LOGON_INTERACTIVE,
		_In_ DWORD dwLogonProvider = LOGON32_PROVIDER_DEFAULT) throw();

	// Must hold AssignPrimaryToken (unless restricted token) and
	// IncreaseQuota privileges
	bool CreateProcessAsUser(
		_In_opt_z_ LPCTSTR pApplicationName,
		_In_opt_z_ LPTSTR pCommandLine,
		_In_ LPPROCESS_INFORMATION pProcessInformation,
		_In_ LPSTARTUPINFO pStartupInfo,
		_In_ DWORD dwCreationFlags = NORMAL_PRIORITY_CLASS,
		_In_ bool bLoadProfile = false,
		_In_opt_ const CSecurityAttributes *pProcessAttributes = NULL,
		_In_opt_ const CSecurityAttributes *pThreadAttributes = NULL,
		_In_ bool bInherit = false,
		_In_opt_z_ LPCTSTR pCurrentDirectory = NULL) throw();

protected:
	bool EnableDisablePrivileges(
		_In_ const CAtlArray<LPCTSTR> &rPrivileges,
		_In_ bool bEnable,
		_Inout_opt_ CTokenPrivileges *pPreviousState,
		_Out_opt_ bool* pbErrNotAllAssigned=NULL) throw(...);
	bool CheckImpersonation() const throw();

	bool RevertToLevel(_In_opt_ SECURITY_IMPERSONATION_LEVEL *pSil) const throw();

	virtual void Clear() throw();

	HANDLE m_hToken, m_hProfile;

private:
	CAccessToken(_In_ const CAccessToken &rhs) throw(...);
	CAccessToken &operator=(_In_ const CAccessToken &rhs) throw(...);

	class CRevert
	{
	public:
		virtual bool Revert() throw() = 0;
	};

	class CRevertToSelf : 
		public CRevert
	{
	public:
		bool Revert() throw()
		{
			return 0 != ::RevertToSelf();
		}
	};

#if (_WIN32_WINNT >= 0x0400 ) || defined(_WIN32_DCOM)
	class CCoRevertToSelf :
		public CRevert
	{
	public:
		bool Revert() throw()
		{
			return SUCCEEDED(::CoRevertToSelf());
		}
	};
#endif //(_WIN32_WINNT >= 0x0400 ) || defined(_WIN32_DCOM)

	class CRpcRevertToSelfEx : 
		public CRevert
	{
	public:
		CRpcRevertToSelfEx(_In_ RPC_BINDING_HANDLE BindingHandle) throw() :
			m_hBinding(BindingHandle)
		{
		}
		bool Revert() throw()
		{
			return RPC_S_OK == ::RpcRevertToSelfEx(m_hBinding);
		}

	private:
		RPC_BINDING_HANDLE m_hBinding;
	};
	mutable CRevert *m_pRevert;
};

//*******************************************
// CAutoRevertImpersonation

class CAutoRevertImpersonation
{
public:
	CAutoRevertImpersonation(_In_ const CAccessToken* pAT) throw();
	~CAutoRevertImpersonation() throw();

	void Attach(_In_ const CAccessToken* pAT) throw();
	const CAccessToken* Detach() throw();

	const CAccessToken* GetAccessToken() throw();

private:
	const CAccessToken* m_pAT;

	CAutoRevertImpersonation(_In_ const CAutoRevertImpersonation &rhs) throw(...);
	CAutoRevertImpersonation &operator=(_In_ const CAutoRevertImpersonation &rhs) throw(...);
};

//*******************************************
// CPrivateObjectSecurityDesc

class CPrivateObjectSecurityDesc : 
	public CSecurityDesc
{
public:
	CPrivateObjectSecurityDesc() throw();
	~CPrivateObjectSecurityDesc() throw();

	bool Create(
		_In_opt_ const CSecurityDesc *pParent,
		_In_opt_ const CSecurityDesc *pCreator,
		_In_ bool bIsDirectoryObject,
		_In_ const CAccessToken &Token,
		_In_ PGENERIC_MAPPING GenericMapping) throw();

#if(_WIN32_WINNT >= 0x0500)
	bool Create(
		_In_opt_ const CSecurityDesc *pParent,
		_In_opt_ const CSecurityDesc *pCreator,
		_In_opt_ GUID *ObjectType,
		_In_ bool bIsContainerObject,
		_In_ ULONG AutoInheritFlags,
		_In_ const CAccessToken &Token,
		_In_ PGENERIC_MAPPING GenericMapping) throw();
#endif

	bool Get(
		_In_ SECURITY_INFORMATION si,
		_Inout_ CSecurityDesc *pResult) const throw();
	bool Set(
		_In_ SECURITY_INFORMATION si,
		_In_ const CSecurityDesc &Modification,
		_In_ PGENERIC_MAPPING GenericMapping,
		_In_ const CAccessToken &Token) throw();

#if(_WIN32_WINNT >= 0x0500)
	bool Set(
		_In_ SECURITY_INFORMATION si,
		_In_ const CSecurityDesc &Modification,
		_In_ ULONG AutoInheritFlags,
		_In_ PGENERIC_MAPPING GenericMapping,
		_In_ const CAccessToken &Token) throw();

	bool ConvertToAutoInherit(
		_In_opt_ const CSecurityDesc *pParent,
		_In_opt_ GUID *ObjectType,
		_In_ bool bIsDirectoryObject,
		_In_ PGENERIC_MAPPING GenericMapping) throw();
#endif

protected:
	void Clear() throw();

private:
	bool m_bPrivate;

	CPrivateObjectSecurityDesc(_In_ const CPrivateObjectSecurityDesc &rhs) throw(...);
	CPrivateObjectSecurityDesc &operator=(_In_ const CPrivateObjectSecurityDesc &rhs) throw(...);
};

//*******************************************
// Global Functions

inline bool AtlGetSecurityDescriptor(
	_In_z_ LPCTSTR pszObjectName,
	_In_ SE_OBJECT_TYPE ObjectType,
	_Inout_ CSecurityDesc *pSecurityDescriptor,
	_In_ SECURITY_INFORMATION requestedInfo =
		OWNER_SECURITY_INFORMATION |
		GROUP_SECURITY_INFORMATION |
		DACL_SECURITY_INFORMATION |
		SACL_SECURITY_INFORMATION,
	_In_ bool bRequestNeededPrivileges = true) throw(...);

inline bool AtlGetSecurityDescriptor(
	_In_ HANDLE hObject,
	_In_ SE_OBJECT_TYPE ObjectType,
	_Inout_ CSecurityDesc *pSecurityDescriptor,
	_In_ SECURITY_INFORMATION requestedInfo =
		OWNER_SECURITY_INFORMATION |
		GROUP_SECURITY_INFORMATION |
		DACL_SECURITY_INFORMATION |
		SACL_SECURITY_INFORMATION,
	_In_ bool bRequestNeededPrivileges = true) throw(...);

inline bool AtlGetOwnerSid(
	_In_ HANDLE hObject,
	_In_ SE_OBJECT_TYPE ObjectType,
	_Inout_ CSid *pSid) throw(...);

inline bool AtlSetOwnerSid(
	_In_ HANDLE hObject,
	_In_ SE_OBJECT_TYPE ObjectType,
	_In_ const CSid &rSid) throw(...);

inline bool AtlGetOwnerSid(
	_In_z_ LPCTSTR pszObjectName,
	_In_ SE_OBJECT_TYPE ObjectType,
	_Inout_ CSid *pSid) throw(...);

inline bool AtlSetOwnerSid(
	_In_z_ LPCTSTR pszObjectName,
	_In_ SE_OBJECT_TYPE ObjectType,
	_In_ const CSid &rSid) throw(...);

inline bool AtlGetGroupSid(
	_In_ HANDLE hObject,
	_In_ SE_OBJECT_TYPE ObjectType,
	_Inout_ CSid *pSid) throw(...);

inline bool AtlSetGroupSid(
	_In_ HANDLE hObject,
	_In_ SE_OBJECT_TYPE ObjectType,
	_In_ const CSid &rSid) throw(...);

inline bool AtlGetGroupSid(
	_In_z_ LPCTSTR pszObjectName,
	_In_ SE_OBJECT_TYPE ObjectType,
	_Inout_ CSid *pSid) throw(...);

inline bool AtlSetGroupSid(
	_In_z_ LPCTSTR pszObjectName,
	_In_ SE_OBJECT_TYPE ObjectType,
	_In_ const CSid &rSid) throw(...);

inline bool AtlGetDacl(
	_In_ HANDLE hObject,
	_In_ SE_OBJECT_TYPE ObjectType,
	_Inout_ CDacl *pDacl) throw(...);

inline bool AtlSetDacl(
	_In_ HANDLE hObject,
	_In_ SE_OBJECT_TYPE ObjectType,
	_In_ const CDacl &rDacl,
	_In_ DWORD dwInheritanceFlowControl = 0) throw(...);

inline bool AtlGetDacl(
	_In_z_ LPCTSTR pszObjectName,
	_In_ SE_OBJECT_TYPE ObjectType,
	_Inout_ CDacl *pDacl) throw(...);

inline bool AtlSetDacl(
	_In_z_ LPCTSTR pszObjectName,
	_In_ SE_OBJECT_TYPE ObjectType,
	_In_ const CDacl &rDacl,
	_In_ DWORD dwInheritanceFlowControl = 0) throw(...);

inline bool AtlGetSacl(
	_In_ HANDLE hObject,
	_In_ SE_OBJECT_TYPE ObjectType,
	_Inout_ CSacl *pSacl,
	_In_ bool bRequestNeededPrivileges = true) throw(...);

inline bool AtlSetSacl(
	_In_ HANDLE hObject,
	_In_ SE_OBJECT_TYPE ObjectType,
	_In_ const CSacl &rSacl,
	_In_ DWORD dwInheritanceFlowControl = 0,
	_In_ bool bRequestNeededPrivileges = true) throw(...);

inline bool AtlGetSacl(
	_In_z_ LPCTSTR pszObjectName,
	_In_ SE_OBJECT_TYPE ObjectType,
	_Inout_ CSacl *pSacl,
	_In_ bool bRequestNeededPrivileges = true) throw(...);

inline bool AtlSetSacl(
	_In_z_ LPCTSTR pszObjectName,
	_In_ SE_OBJECT_TYPE ObjectType,
	_In_ const CSacl &rSacl,
	_In_ DWORD dwInheritanceFlowControl = 0,
	_In_ bool bRequestNeededPrivileges = true) throw(...);

} // namespace ATL


#pragma warning(pop)

#include <atlsecurity.inl>
#pragma pack(pop)
#endif // __ATLSECURITY_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\include\atlsnap.h ===
// This is a part of the Active Template Library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Active Template Library Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Active Template Library product.

#ifndef __ATLSNAP_H__
#define __ATLSNAP_H__

#pragma once

#ifndef _ATL_NO_PRAGMA_WARNINGS
#pragma warning (push)
#pragma warning(disable: 4702) // unreachable code
#pragma warning(disable: 4127) // conditional expression constant
#endif //!_ATL_NO_PRAGMA_WARNINGS

#include <mmc.h>
#include <commctrl.h>
#include <atlwin.h>

#ifndef _ATL_NO_DEFAULT_LIBS
#pragma comment(lib, "mmc.lib")
#pragma comment(lib, "comctl32.lib")
#endif  // !_ATL_NO_DEFAULT_LIBS


#pragma pack(push,_ATL_PACKING)
namespace ATL
{

template <class T, bool bAutoDelete = true>
class ATL_NO_VTABLE CSnapInPropertyPageImpl :
	public CDialogImplBase
{
public:
	PROPSHEETPAGE m_psp;

	operator PROPSHEETPAGE*()
	{
		return &m_psp;
	}

// Construction
	CSnapInPropertyPageImpl(_In_opt_z_ LPCTSTR lpszTitle = NULL)
	{
		// initialize PROPSHEETPAGE struct
		memset(&m_psp, 0, sizeof(PROPSHEETPAGE));
		m_psp.dwSize = sizeof(PROPSHEETPAGE);
		m_psp.dwFlags = PSP_USECALLBACK;
		m_psp.hInstance = _AtlBaseModule.GetResourceInstance();
		m_psp.pszTemplate = MAKEINTRESOURCE(T::IDD);
		m_psp.pfnDlgProc = (DLGPROC)T::StartDialogProc;
		m_psp.pfnCallback = T::PropPageCallback;
		m_psp.lParam = (LPARAM)this;

		if(lpszTitle != NULL)
		{
			m_psp.pszTitle = lpszTitle;
			m_psp.dwFlags |= PSP_USETITLE;
		}
	}

	static UINT CALLBACK PropPageCallback(
		_In_ HWND hWnd,
		_In_ UINT uMsg,
		_In_ LPPROPSHEETPAGE ppsp)
	{
		UNREFERENCED_PARAMETER(hWnd);
		ATLASSERT(hWnd == NULL);
		if(uMsg == PSPCB_CREATE)
		{
			CDialogImplBase* pPage = (CDialogImplBase*)ppsp->lParam;
			_AtlWinModule.AddCreateWndData(&pPage->m_thunk.cd, pPage);
		}
		if (bAutoDelete && uMsg == PSPCB_RELEASE)
		{
			T* pPage = (T*)ppsp->lParam;
			delete pPage;
		}

		return 1;
	}

	HPROPSHEETPAGE Create()
	{
		ATLASSUME(m_psp.lParam == (LPARAM)this);
		return ::CreatePropertySheetPage(&m_psp);
	}

	BOOL EndDialog(int)
	{
		// do nothing here, calling ::EndDialog will close the whole sheet
		ATLASSERT(FALSE);
		return FALSE;
	}

// Operations
	void CancelToClose()
	{
		ATLASSERT(::IsWindow(m_hWnd));
		ATLASSERT(GetParent() != NULL);

		::SendMessage(GetParent(), PSM_CANCELTOCLOSE, 0, 0L);
	}
	void SetModified(_In_ BOOL bChanged = TRUE)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		ATLASSERT(GetParent() != NULL);

		if(bChanged)
			::SendMessage(GetParent(), PSM_CHANGED, (WPARAM)m_hWnd, 0L);
		else
			::SendMessage(GetParent(), PSM_UNCHANGED, (WPARAM)m_hWnd, 0L);
	}
	LRESULT QuerySiblings(
		_In_ WPARAM wParam,
		_In_ LPARAM lParam)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		ATLASSERT(GetParent() != NULL);

		return ::SendMessage(GetParent(), PSM_QUERYSIBLINGS, wParam, lParam);
	}

	typedef CSnapInPropertyPageImpl< T, bAutoDelete > thisClass;
	BEGIN_MSG_MAP(thisClass)
		MESSAGE_HANDLER(WM_NOTIFY, OnNotify)
	END_MSG_MAP()

// Message handler
	LRESULT OnNotify(
		_In_ UINT /*uMsg*/,
		_In_ WPARAM /*wParam*/,
		_In_ LPARAM lParam,
		_Inout_ BOOL& bHandled)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		NMHDR* pNMHDR = (NMHDR*)lParam;

		// don't handle messages not from the page/sheet itself
		if(pNMHDR->hwndFrom != m_hWnd && pNMHDR->hwndFrom != ::GetParent(m_hWnd))
		{
			bHandled = FALSE;
			return 1;
		}

		T* pT = (T*)this;
		LRESULT lResult = 0;
		// handle default
		switch(pNMHDR->code)
		{
		case PSN_SETACTIVE:
			lResult = pT->OnSetActive() ? 0 : -1;
			break;
		case PSN_KILLACTIVE:
			lResult = !pT->OnKillActive();
			break;
		case PSN_APPLY:
			lResult = pT->OnApply() ? PSNRET_NOERROR : PSNRET_INVALID_NOCHANGEPAGE;
			break;
		case PSN_RESET:
			pT->OnReset();
			break;
		case PSN_QUERYCANCEL:
			lResult = !pT->OnQueryCancel();
			break;
		case PSN_WIZNEXT:
			lResult = !pT->OnWizardNext();
			break;
		case PSN_WIZBACK:
			lResult = !pT->OnWizardBack();
			break;
		case PSN_WIZFINISH:
			lResult = !pT->OnWizardFinish();
			break;
		case PSN_HELP:
			lResult = pT->OnHelp();
			break;
		default:
			bHandled = FALSE;	// not handled
		}

		return lResult;
	}

// Overridables
	BOOL OnSetActive()
	{
		return TRUE;
	}
	BOOL OnKillActive()
	{
		return TRUE;
	}
	BOOL OnApply()
	{
		return TRUE;
	}
	void OnReset()
	{
	}
	BOOL OnQueryCancel()
	{
		return TRUE;    // ok to cancel
	}
	BOOL OnWizardBack()
	{
		return TRUE;
	}
	BOOL OnWizardNext()
	{
		return TRUE;
	}
	BOOL OnWizardFinish()
	{
		return TRUE;
	}
	BOOL OnHelp()
	{
		return TRUE;
	}
};

class CSnapInItem;
class CSnapInObjectRootBase;

class CObjectData
{
public:
	CSnapInItem* m_pItem;
	DATA_OBJECT_TYPES m_type;
};

class ATL_NO_VTABLE CSnapInItem
{
public:
	virtual ~CSnapInItem()
	{
	}
	STDMETHOD(Notify)(
		_In_ MMC_NOTIFY_TYPE event,
		_In_ LONG_PTR arg,
		_In_ LONG_PTR param,
		_Inout_opt_ IComponentData* pComponentData,
		_Inout_opt_ IComponent* pComponent,
		_In_ DATA_OBJECT_TYPES type) = 0;

	STDMETHOD(GetScopePaneInfo)(_Out_ SCOPEDATAITEM *pScopeDataItem) = 0;

	STDMETHOD(GetResultViewType)(
		_Deref_out_z_ LPOLESTR *ppViewType,
		_Out_ long *pViewOptions) = 0;

	STDMETHOD(GetResultPaneInfo)(_Out_ RESULTDATAITEM *pResultDataItem) = 0;

	STDMETHOD(AddMenuItems)(
		_In_ LPCONTEXTMENUCALLBACK piCallback,
		_Inout_ long  *pInsertionAllowed,
		_In_ DATA_OBJECT_TYPES type) = 0;

	STDMETHOD(Command)(
		_In_ long lCommandID,
		_Inout_ CSnapInObjectRootBase* pObj,
		_In_ DATA_OBJECT_TYPES type) = 0;

	STDMETHOD(CreatePropertyPages)(
		_In_ LPPROPERTYSHEETCALLBACK lpProvider,
		_In_ LONG_PTR handle,
		_Inout_ IUnknown* pUnk,
		_In_ DATA_OBJECT_TYPES type) = 0;

	STDMETHOD(QueryPagesFor)(_In_ DATA_OBJECT_TYPES type) = 0;

	STDMETHOD(SetControlbar)(
		_Inout_ IControlbar  *pControlbar,
		_Inout_opt_ IExtendControlbar  *pExtendControlbar,
		_Inout_ CSimpleMap<UINT, IUnknown*>* pToolbarMap) = 0;

	STDMETHOD(ControlbarNotify)(
		_Inout_ IControlbar *pControlbar,
		_Inout_opt_ IExtendControlbar *pExtendControlbar,
		_Inout_ CSimpleMap<UINT, IUnknown*>* pToolbarMap,
		_In_ MMC_NOTIFY_TYPE event,
		_In_ LONG_PTR arg,
		_In_ LONG_PTR param,
		_Inout_ CSnapInObjectRootBase* pObj,
		_In_ DATA_OBJECT_TYPES type) = 0;

	STDMETHOD(GetScopeData)(_Deref_out_ SCOPEDATAITEM  **pScopeDataItem) = 0;

	STDMETHOD(GetResultData)(_Deref_out_ RESULTDATAITEM  **pResultDataItem) = 0;

	STDMETHOD(FillData)(
		_In_ CLIPFORMAT cf,
		_Inout_ LPSTREAM pStream) = 0;

	virtual void InitDataClass(
		_Inout_opt_ IDataObject* /*pDataObject*/,
		_Inout_opt_ CSnapInItem* /*pDefault*/)
	{
		ATLASSERT(0 && "Override this function in derived class");
	}

	static HRESULT GetDataClass(
		_Inout_ IDataObject* pDataObj,
		_Deref_out_opt_ _Deref_post_opt_bytecount_x_(sizeof(CSnapInItem)) CSnapInItem** ppItem,
		_Out_ DATA_OBJECT_TYPES* pType)
	{
		if (ppItem == NULL)
			return E_POINTER;
		if (pType == NULL)
			return E_POINTER;

		if (IS_SPECIAL_DATAOBJECT(pDataObj))
		{
			ATLTRACENOTIMPL(_T("CSnapInItem::GetDataClass"));
		}

		*ppItem = NULL;
		*pType = CCT_UNINITIALIZED;

		STGMEDIUM stgmedium = { TYMED_HGLOBAL, NULL };
		FORMATETC formatetc = { m_CCF_SNAPIN_GETOBJECTDATA,
			NULL,
			DVASPECT_CONTENT,
			-1,
			TYMED_HGLOBAL
		};

		stgmedium.hGlobal = GlobalAlloc(0, sizeof(CObjectData));
		if (stgmedium.hGlobal == NULL)
			return E_OUTOFMEMORY;

		HRESULT hr = pDataObj->GetDataHere(&formatetc, &stgmedium);
		if (SUCCEEDED(hr))
		{
			CObjectData* pData = (CObjectData*)stgmedium.hGlobal;
			 *ppItem = pData->m_pItem;
			 *pType = pData->m_type;
		}

		GlobalFree(stgmedium.hGlobal);
				
		return hr;
	}

	virtual HRESULT STDMETHODCALLTYPE GetDataObject(
		_Deref_out_ IDataObject** pDataObj,
		_In_ DATA_OBJECT_TYPES type) = 0;

	static void Init()
	{
		m_CCF_NODETYPE			= (CLIPFORMAT) RegisterClipboardFormat(_T("CCF_NODETYPE"));
		m_CCF_SZNODETYPE		= (CLIPFORMAT) RegisterClipboardFormat(_T("CCF_SZNODETYPE"));
		m_CCF_DISPLAY_NAME		= (CLIPFORMAT) RegisterClipboardFormat(_T("CCF_DISPLAY_NAME"));
		m_CCF_SNAPIN_CLASSID	= (CLIPFORMAT) RegisterClipboardFormat(_T("CCF_SNAPIN_CLASSID"));
		m_CCF_SNAPIN_GETOBJECTDATA	= (CLIPFORMAT) RegisterClipboardFormat(_T("CCF_GETOBJECTDATA"));
		m_CCF_MMC_MULTISELECT_DATAOBJECT	= (CLIPFORMAT) RegisterClipboardFormat(_T("CCF_MMC_MULTISELECT_DATAOBJECT"));
	}
public:
	static CLIPFORMAT m_CCF_NODETYPE;
	static CLIPFORMAT m_CCF_SZNODETYPE;
	static CLIPFORMAT m_CCF_DISPLAY_NAME;
	static CLIPFORMAT m_CCF_SNAPIN_CLASSID;
	static CLIPFORMAT m_CCF_SNAPIN_GETOBJECTDATA;
	static CLIPFORMAT m_CCF_MMC_MULTISELECT_DATAOBJECT;
};

class CSnapInObjectRootBase
{
public:
	CComPtr <IControlbar> m_spControlbar;
	CSimpleMap <UINT, IUnknown*> m_toolbarMap;
	const int m_nType;

	CSnapInObjectRootBase(_In_ int n = 0) : m_nType(n)
	{
	}
ATLPREFAST_SUPPRESS(6387)
	HRESULT GetDataClass(
		_In_ IDataObject* pDataObject,
		_Deref_out_ CSnapInItem** ppItem,
		_Out_ DATA_OBJECT_TYPES* pType)
	{
		return CSnapInItem::GetDataClass(pDataObject, ppItem, pType);
	}
ATLPREFAST_UNSUPPRESS()
};


template <int n, class ComponentData>
class CSnapInObjectRoot :
	public CSnapInObjectRootBase
{
public :
	CSnapInObjectRoot() : CSnapInObjectRootBase(n)
	{
		m_pComponentData = NULL;
	}
	ComponentData* m_pComponentData;
};

#define EXTENSION_SNAPIN_DATACLASS(dataClass) dataClass m_##dataClass;

#define BEGIN_EXTENSION_SNAPIN_NODEINFO_MAP(classname) \
	HRESULT GetDataClass( \
		_In_ IDataObject* pDataObject, \
		_Deref_out_ ATL::CSnapInItem** ppItem, \
		_Out_ DATA_OBJECT_TYPES* pType) \
	{ \
		if (ppItem == NULL) \
			return E_POINTER; \
		if (pType == NULL) \
			return E_POINTER; \
\
		*ppItem = NULL; \
\
		*pType = CCT_UNINITIALIZED; \
\
		STGMEDIUM stgmedium = { TYMED_HGLOBAL, NULL }; \
		FORMATETC formatetc = { ATL::CSnapInItem::m_CCF_NODETYPE, \
			NULL, \
			DVASPECT_CONTENT, \
			-1, \
			TYMED_HGLOBAL \
		}; \
\
		stgmedium.hGlobal = GlobalAlloc(0, sizeof(GUID)); \
		if (stgmedium.hGlobal == NULL) \
			return E_OUTOFMEMORY; \
\
		HRESULT hr = pDataObject->GetDataHere(&formatetc, &stgmedium); \
		if (FAILED(hr)) \
		{ \
			GlobalFree(stgmedium.hGlobal); \
			return hr; \
		} \
\
		GUID guid; \
		Checked::memcpy_s(&guid, sizeof(GUID), stgmedium.hGlobal, sizeof(GUID)); \
\
		GlobalFree(stgmedium.hGlobal); \
		hr = S_OK;

#define EXTENSION_SNAPIN_NODEINFO_ENTRY(dataClass) \
		if (IsEqualGUID(guid, *(GUID*)m_##dataClass.GetNodeType())) \
		{ \
			*ppItem = m_##dataClass.GetExtNodeObject(pDataObject, &m_##dataClass); \
			ATLASSERT(*ppItem != NULL); \
			(*ppItem)->InitDataClass(pDataObject, &m_##dataClass); \
			return hr; \
		}

#define END_EXTENSION_SNAPIN_NODEINFO_MAP() \
			return ATL::CSnapInItem::GetDataClass(pDataObject, ppItem, pType); \
	};

class ATL_NO_VTABLE CSnapInDataObjectImpl :
	public IDataObject,
	public CComObjectRoot
{
public:
	virtual ~CSnapInDataObjectImpl()
	{
	}
	BEGIN_COM_MAP(CSnapInDataObjectImpl)
		COM_INTERFACE_ENTRY(IDataObject)
	END_COM_MAP()
	STDMETHOD(GetData)(
		_In_opt_ FORMATETC * /*pformatetcIn*/,
		_In_opt_ STGMEDIUM * /*pmedium*/)
	{
		ATLTRACENOTIMPL(_T("SnapInDataObjectImpl::GetData\n"));
	}

	STDMETHOD(GetDataHere)(
		_In_ FORMATETC* pformatetc,
		_In_ STGMEDIUM* pmedium)
	{
		ATLTRACE(atlTraceSnapin, 2, _T("SnapInDataObjectImpl::GetDataHere\n"));
		if (pmedium == NULL)
			return E_POINTER;

		HRESULT hr = DV_E_TYMED;
		// Make sure the type medium is HGLOBAL
		if (pmedium->tymed == TYMED_HGLOBAL)
		{
			// Create the stream on the hGlobal passed in
			CComPtr<IStream> spStream;
			hr = CreateStreamOnHGlobal(pmedium->hGlobal, FALSE, &spStream);
			if (SUCCEEDED(hr))
				if (pformatetc->cfFormat == CSnapInItem::m_CCF_SNAPIN_GETOBJECTDATA)
				{
					hr = DV_E_CLIPFORMAT;
					ULONG uWritten;
					hr = spStream->Write(&m_objectData, sizeof(CObjectData), &uWritten);
				}
				else
					hr = m_objectData.m_pItem->FillData(pformatetc->cfFormat, spStream);
		}
		return hr;
	}

	STDMETHOD(QueryGetData)(_In_opt_ FORMATETC* /* pformatetc */)
	{
		ATLTRACENOTIMPL(_T("SnapInDataObjectImpl::QueryGetData\n"));
	}
	STDMETHOD(GetCanonicalFormatEtc)(
		_In_opt_ FORMATETC* /* pformatectIn */,
		_In_opt_ FORMATETC* /* pformatetcOut */)
	{
		ATLTRACENOTIMPL(_T("SnapInDataObjectImpl::GetCanonicalFormatEtc\n"));
	}
	STDMETHOD(SetData)(
		_In_opt_ FORMATETC* /* pformatetc */,
		_In_opt_ STGMEDIUM* /* pmedium */,
		_In_ BOOL /* fRelease */)
	{
		ATLTRACENOTIMPL(_T("SnapInDataObjectImpl::SetData\n"));
	}
	STDMETHOD(EnumFormatEtc)(
		_In_ DWORD /* dwDirection */,
		_In_ IEnumFORMATETC** /* ppenumFormatEtc */)
	{
		ATLTRACENOTIMPL(_T("SnapInDataObjectImpl::EnumFormatEtc\n"));
	}
	STDMETHOD(DAdvise)(
		_In_opt_ FORMATETC * /*pformatetc*/,
		_In_ DWORD /*advf*/,
		_Inout_opt_ IAdviseSink * /*pAdvSink*/,
		_Out_opt_ DWORD* /*pdwConnection*/)
	{
		ATLTRACENOTIMPL(_T("SnapInDataObjectImpl::SetData\n"));
	}
	STDMETHOD(DUnadvise)(_In_ DWORD /*dwConnection*/)
	{
		ATLTRACENOTIMPL(_T("SnapInDataObjectImpl::SetDatan\n"));
	}
	STDMETHOD(EnumDAdvise)(_In_ IEnumSTATDATA ** /*ppenumAdvise*/)
	{
		ATLTRACENOTIMPL(_T("SnapInDataObjectImpl::SetData\n"));
	}

	CObjectData m_objectData;
};


template <class T, class Component>
class ATL_NO_VTABLE IComponentDataImpl :
	public IComponentData
{
public :
	IComponentDataImpl()
	{
		m_pNode = NULL;
	}

	STDMETHOD(Initialize)(_Inout_ LPUNKNOWN pUnknown)
	{
		ATLTRACE(atlTraceSnapin, 2, _T("IComponentDataImpl::Initialize\n"));

		HRESULT hr = E_POINTER;

		ATLASSERT(pUnknown != NULL);
		if (pUnknown == NULL)
			ATLTRACE(atlTraceSnapin, 0, _T("IComponentData::Initialize called with pUnknown == NULL\n"));
		else
		{
			hr = pUnknown->QueryInterface(&m_spConsole);
			if (FAILED(hr))
				ATLTRACE(atlTraceSnapin, 0, _T("QI for IConsole failed\n"));
		}

		return hr;
	}

	STDMETHOD(CreateComponent)(_Deref_out_ LPCOMPONENT *ppComponent)
	{
		ATLTRACE(atlTraceSnapin, 2, _T("IComponentDataImpl::CreateComponent\n"));

		HRESULT hr = E_POINTER;

		ATLASSERT(ppComponent != NULL);
		if (ppComponent == NULL)
			ATLTRACE(atlTraceSnapin, 0, _T("IComponentData::CreateComponent called with ppComponent == NULL\n"));
		else
		{
			*ppComponent = NULL;

			CComObject< Component >* pComponent;
			hr = CComObject< Component >::CreateInstance(&pComponent);
			ATLASSUME(SUCCEEDED(hr));
			if (FAILED(hr))
				ATLTRACE(atlTraceSnapin, 0, _T("IComponentData::CreateComponent : Could not create IComponent object\n"));
			else
			{
				pComponent->m_pComponentData = static_cast<T*>(this);
				hr = pComponent->QueryInterface(__uuidof(IComponent), (void**)ppComponent);
			}
		}
		return hr;
	}

	STDMETHOD(Notify)(
		_Inout_ LPDATAOBJECT lpDataObject,
		_In_ MMC_NOTIFY_TYPE event,
		_In_ LONG_PTR arg,
		_In_ LONG_PTR param)
	{
		ATLTRACE(atlTraceSnapin, 2, _T("IComponentDataImpl::Notify\n"));
		ATLASSERT(lpDataObject != NULL && _T("Override Notify in derived class handle notifications for which lpDataObject == NULL"));
		HRESULT hr = E_POINTER;

		ATLASSERT(lpDataObject != NULL);
		if (lpDataObject == NULL)
			ATLTRACE(atlTraceSnapin, 0, _T("IComponentData::Notify called with lpDataObject == NULL\n"));
		else
		{
			T* pT = static_cast<T*>(this);
			CSnapInItem* pItem;
			DATA_OBJECT_TYPES type;
			hr = pT->m_pComponentData->GetDataClass(lpDataObject, &pItem, &type);
			ATLASSERT(SUCCEEDED(hr));
			if (SUCCEEDED(hr))
			{
				hr = pItem->Notify(event, arg, param, pT, NULL, type);
			}
		}
		return hr;
	}

	STDMETHOD(Destroy)(void)
	{
		ATLTRACE(atlTraceSnapin, 2, _T("IComponentDataImpl::Destroy\n"));

		T* pT = static_cast<T*>(this);
		if (pT->m_spControlbar != NULL)
		{
			int n = pT->m_toolbarMap.GetSize();
			for (int i = 0; i < n; i++)
			{
				IToolbar* pToolbar = (IToolbar*)pT->m_toolbarMap.GetValueAt(i);
				 if (pToolbar != NULL)
				 {
					pT->m_spControlbar->Detach(pToolbar);
					pToolbar->Release();
				 }
			}
		}
		pT->m_toolbarMap.RemoveAll();

		m_spConsole.Release();
		return S_OK;
	}

	STDMETHOD(QueryDataObject)(
		_In_ LONG_PTR cookie,
		_In_ DATA_OBJECT_TYPES type,
		_Deref_out_ LPDATAOBJECT *ppDataObject)
	{
		ATLTRACE(atlTraceSnapin, 2, _T("IComponentDataImpl::QueryDataObject\n"));
		HRESULT hr = E_POINTER;

		ATLASSERT(ppDataObject != NULL);
		if (ppDataObject == NULL)
			ATLTRACE(atlTraceSnapin, 0, _T("IComponentData::QueryDataObject called with ppDataObject == NULL\n"));
		else
		{
			*ppDataObject = NULL;

			CSnapInItem* pItem = (CSnapInItem*) cookie;
			if (cookie == NULL)
				pItem = m_pNode;

			hr = pItem->GetDataObject(ppDataObject, type);
		}
		return hr;
	}

	STDMETHOD(GetDisplayInfo)(_Inout_ SCOPEDATAITEM *pScopeDataItem)
	{
		ATLTRACE(atlTraceSnapin, 2, _T("IComponentDataImpl::GetDisplayInfo\n"));

		HRESULT hr = E_POINTER;

		ATLASSERT(pScopeDataItem != NULL);
		if (pScopeDataItem == NULL)
			ATLTRACE(atlTraceSnapin, 0, _T("IComponentData::GetDisplayInfo called with pScopeDataItem == NULL\n"));
		else
		{
			CSnapInItem* pItem= (CSnapInItem*) pScopeDataItem->lParam;
			if (pItem == NULL)
				pItem = m_pNode;

			hr = E_UNEXPECTED;
			if (pItem != NULL)
				hr = pItem->GetScopePaneInfo(pScopeDataItem);
		}
		return hr;
	}

	STDMETHOD(CompareObjects)(
		_In_opt_ LPDATAOBJECT /*lpDataObjectA*/,
		_In_opt_ LPDATAOBJECT /*lpDataObjectB*/)
	{
		ATLTRACENOTIMPL(_T("IComponentDataImpl::CompareObjects\n"));
	}

	CComPtr<IConsole> m_spConsole;
	CSnapInItem* m_pNode;
};


template <class T>
class ATL_NO_VTABLE IComponentImpl :
	public IComponent
{
public:
	STDMETHOD(Initialize)(_Inout_ LPCONSOLE lpConsole)
	{
		ATLTRACE(atlTraceSnapin, 2, _T("IComponentImpl::Initialize\n"));

		HRESULT hr = E_POINTER;

		ATLASSERT(lpConsole != NULL);
		if (lpConsole == NULL)
			ATLTRACE(atlTraceSnapin, 0, _T("lpConsole is NULL\n"));
		else
		{
			m_spConsole = lpConsole;

			CComPtr<IHeaderCtrl> spHeaderCtrl;
			hr = m_spConsole.QueryInterface(&spHeaderCtrl);
			if (FAILED(hr))
				ATLTRACE(atlTraceSnapin, 0, _T("QI for IHeaderCtrl failed\n"));
			else
			{
				hr = m_spConsole->SetHeader(spHeaderCtrl);
				if (FAILED(hr))
					ATLTRACE(atlTraceSnapin, 0, _T("IConsole::SetHeader failed (HRESULT = %x)\n"), hr);
			}
		}
		return hr;
	}

	STDMETHOD(Notify)(
		_Inout_ LPDATAOBJECT lpDataObject,
		_In_ MMC_NOTIFY_TYPE event,
		_In_ LONG_PTR arg,
		_In_ LONG_PTR param)
	{
		ATLTRACE(atlTraceSnapin, 2, _T("IComponentImpl::Notify\n"));
		ATLASSERT(lpDataObject != NULL && _T("Override Notify in derived class handle notifications for which lpDataObject == NULL"));
		HRESULT hr = E_POINTER;

		if (lpDataObject == NULL)
			ATLTRACE(atlTraceSnapin, 0, _T("IComponent::Notify called with lpDataObject==NULL \n"));
		else
		{
			T* pT = static_cast<T*>(this);
			CSnapInItem* pItem;
			DATA_OBJECT_TYPES type;
			// Make sure that the object is derived from CSnapInObjectRoot
			hr = pT->m_pComponentData->GetDataClass(lpDataObject, &pItem, &type);
			if (SUCCEEDED(hr))
			{
				hr = pItem->Notify(event, arg, param, NULL, pT, type);
			}
		}
		return hr;
	}

	STDMETHOD(Destroy)(_In_ LONG_PTR /*cookie*/)
	{
		ATLTRACE(atlTraceSnapin, 2, _T("IComponentImpl::Destroy\n"));

		T* pT = static_cast<T*>(this);

		if (pT->m_spControlbar != NULL)
		{
			int n = pT->m_toolbarMap.GetSize();
			for (int i = 0; i < n; i++)
			{
				IToolbar* pToolbar = (IToolbar*)pT->m_toolbarMap.GetValueAt(i);
				 if (pToolbar != NULL)
				 {
					pT->m_spControlbar->Detach(pToolbar);
					pToolbar->Release();
				 }
			}
		}
		pT->m_toolbarMap.RemoveAll();

		m_spConsole->SetHeader(NULL);
		m_spConsole.Release();
		return S_OK;
	}

	STDMETHOD(QueryDataObject)(
		_In_ LONG_PTR cookie,
		_In_ DATA_OBJECT_TYPES type,
		_Deref_out_ LPDATAOBJECT *ppDataObject)
	{
		ATLTRACE(atlTraceSnapin, 2, _T("IComponentImpl::QueryDataObject\n"));

		ATLASSERT(ppDataObject != NULL);
		if (ppDataObject == NULL)
		{
			ATLTRACE(atlTraceSnapin, 0, _T("IComponent::QueryDataObject called with ppDataObject==NULL \n"));
			return E_POINTER;
		}

		if (cookie == NULL)
		{
			ATLTRACE(atlTraceSnapin, 0, _T("IComponent::QueryDataObject called with cookie==NULL \n"));
			return E_UNEXPECTED;
		}

		*ppDataObject = NULL;
		if (cookie == MMC_MULTI_SELECT_COOKIE)
		{
			ATLTRACE(atlTraceSnapin, 0, _T("Override QueryDataObject to handle multiselect\n"));
			return E_UNEXPECTED;
		}

		CSnapInItem* pItem = (CSnapInItem*) cookie;
		return pItem->GetDataObject(ppDataObject, type);
	}

	STDMETHOD(GetResultViewType)(
		_In_ LONG_PTR cookie,
		_Deref_out_z_ LPOLESTR *ppViewType,
		_Out_ long *pViewOptions)
	{
		ATLTRACE(atlTraceSnapin, 2, _T("IComponentImpl::GetResultViewType\n"));

		HRESULT hr = E_FAIL;
		if (cookie == NULL)
		{
			T* pT = static_cast<T*> (this);
			ATLENSURE_RETURN( pT->m_pComponentData != NULL );
			ATLENSURE_RETURN( pT->m_pComponentData->m_pNode != NULL );
			hr = pT->m_pComponentData->m_pNode->GetResultViewType(ppViewType, pViewOptions);
		}
		else
		{
			CSnapInItem* pItem = (CSnapInItem*)cookie;
			hr = pItem->GetResultViewType(ppViewType, pViewOptions);
		}
		return hr;
	}

	STDMETHOD(GetDisplayInfo)(_Inout_ RESULTDATAITEM *pResultDataItem)
	{
		ATLTRACE(atlTraceSnapin, 2, _T("IComponentImpl::GetDisplayInfo\n"));

		ATLASSERT(pResultDataItem != NULL);
		if (pResultDataItem == NULL)
		{
			ATLTRACE(atlTraceSnapin, 0, _T("IComponent::GetDisplayInfo called with pResultDataItem==NULL\n"));
			return E_POINTER;
		}

		CSnapInItem* pItem = (CSnapInItem*) pResultDataItem->lParam;

		if (pItem == NULL)
		{
			ATLTRACE(atlTraceSnapin, 0, _T("Invalid Item\n"));
			return E_UNEXPECTED;
		}
		return pItem->GetResultPaneInfo(pResultDataItem);
	}

	STDMETHOD(CompareObjects)(
		_In_opt_ LPDATAOBJECT /*lpDataObjectA*/,
		_In_opt_ LPDATAOBJECT /*lpDataObjectB*/)
	{
		ATLTRACENOTIMPL(_T("IComponentImpl::CompareObjects\n"));
	}

	CComPtr<IConsole> m_spConsole;
};

template <class T, class D>
class ATL_NO_VTABLE IResultDataCompareImpl :
	public IResultDataCompare
{
public:
	STDMETHOD(Compare)(long /*lUserParam*/,
		_In_ long /*cookieA*/,
		_In_ long /*cookieB*/,
		_In_opt_ int* /*pnResult*/)
	{
		ATLTRACENOTIMPL(_T("IResultDataCompareImpl::Compare"));
	}
};


template <class T>
class ATL_NO_VTABLE IExtendContextMenuImpl :
	public IExtendContextMenu
{
public:
	STDMETHOD(AddMenuItems)(
		_Inout_ LPDATAOBJECT pDataObject,
		_In_ LPCONTEXTMENUCALLBACK piCallback,
		_Inout_ long *pInsertionAllowed)
	{
		ATLTRACE(atlTraceSnapin, 2, _T("IExtendContextMenuImpl::AddMenuItems\n"));

		HRESULT hr = E_POINTER;

		ATLASSERT(pDataObject != NULL);
		if (pDataObject == NULL)
			ATLTRACE(atlTraceSnapin, 0, _T("IExtendContextMenu::AddMenuItems called with pDataObject==NULL\n"));
		else
		{
			T* pT = static_cast<T*>(this);
			CSnapInItem* pItem;
			DATA_OBJECT_TYPES type;
			hr = pT->m_pComponentData->GetDataClass(pDataObject, &pItem, &type);

			if (SUCCEEDED(hr))
			{
				hr = pItem->AddMenuItems(piCallback, pInsertionAllowed, type);
			}
		}
		return hr;
	}

	STDMETHOD(Command)(
		_In_ long lCommandID,
		_Inout_ LPDATAOBJECT pDataObject)
	{
		ATLTRACE(atlTraceSnapin, 2, _T("IExtendContextMenuImpl::Command\n"));

		HRESULT hr = E_POINTER;

		ATLASSERT(pDataObject != NULL);
		if (pDataObject == NULL)
			ATLTRACE(atlTraceSnapin, 0, _T("IExtendContextMenu::Command called with pDataObject==NULL\n"));
		else
		{
			T* pT = static_cast<T*>(this);
			CSnapInItem* pItem;
			DATA_OBJECT_TYPES type;
			hr = pT->m_pComponentData->GetDataClass(pDataObject, &pItem, &type);

			if (SUCCEEDED(hr))
			{
				hr = pItem->Command(lCommandID, (CSnapInObjectRootBase*)pT, type);
			}
		}
		return hr;
	}
};

template<class T>
class ATL_NO_VTABLE IExtendPropertySheetImpl :
	public IExtendPropertySheet
{
public:
	STDMETHOD(CreatePropertyPages)(
		_In_ LPPROPERTYSHEETCALLBACK lpProvider,
		_In_ LONG_PTR handle,
		_Inout_ LPDATAOBJECT pDataObject)
	{
		ATLTRACE(atlTraceSnapin, 2, _T("IExtendPropertySheetImpl::CreatePropertyPages\n"));

		HRESULT hr = E_POINTER;

		ATLASSERT(pDataObject != NULL);
		if (pDataObject == NULL)
			ATLTRACE(atlTraceSnapin, 0, _T("IExtendPropertySheetImpl::CreatePropertyPages called with pDataObject==NULL\n"));
		else
		{
			T* pT = static_cast<T*>(this);
			CSnapInItem* pItem;
			DATA_OBJECT_TYPES type;
			hr = pT->m_pComponentData->GetDataClass(pDataObject, &pItem, &type);

			if (SUCCEEDED(hr))
			{
				hr = pItem->CreatePropertyPages(lpProvider, handle, this, type);
			}
		}

		return hr;
	}

	STDMETHOD(QueryPagesFor)(_Inout_ LPDATAOBJECT pDataObject)
	{
		ATLTRACE(atlTraceSnapin, 2, _T("IExtendPropertySheetImpl::QueryPagesFor\n"));

		HRESULT hr = E_POINTER;

		ATLASSERT(pDataObject != NULL);
		if (pDataObject == NULL)
			ATLTRACE(atlTraceSnapin, 0, _T("IExtendPropertySheetImpl::QueryPagesFor called with pDataObject==NULL\n"));
		else
		{
			T* pT = static_cast<T*>(this);
			CSnapInItem* pItem;
			DATA_OBJECT_TYPES type;
			hr = pT->m_pComponentData->GetDataClass(pDataObject, &pItem, &type);

			if (SUCCEEDED(hr))
			{
				hr = pItem->QueryPagesFor(type);
			}
		}
		return hr;
	}
};

template <class T>
class ATL_NO_VTABLE IExtendControlbarImpl :
	public IExtendControlbar
{
public:
	STDMETHOD(SetControlbar)(_In_opt_ LPCONTROLBAR pControlbar)
	{
		ATLTRACE(atlTraceSnapin, 2, _T("IExtendControlbarImpl::SetControlbar\n"));
		T* pT = static_cast<T*>(this);

		if (pT->m_spControlbar != NULL)
		{
			int n = pT->m_toolbarMap.GetSize();
			for (int i = 0; i < n; i++)
			{
				IToolbar* pToolbar = (IToolbar*)pT->m_toolbarMap.GetValueAt(i);
				 if (pToolbar != NULL)
				 {
					pT->m_spControlbar->Detach(pToolbar);
					pToolbar->Release();
				 }
			}
		}
		pT->m_toolbarMap.RemoveAll();

		pT->m_spControlbar = pControlbar;
		return S_OK;
	}

	STDMETHOD(ControlbarNotify)(
		_In_ MMC_NOTIFY_TYPE event,
		_In_ LONG_PTR arg,
		_In_ LONG_PTR param)
	{
		ATLTRACE(atlTraceSnapin, 2, _T("IExtendControlbarImpl::ControlbarNotify\n"));

		CSnapInItem* pItem = NULL;
		DATA_OBJECT_TYPES type = CCT_UNINITIALIZED;
		HRESULT hr = S_FALSE;
		T* pT = static_cast<T*>(this);

		if (event == MMCN_BTN_CLICK)
			hr = pT->m_pComponentData->GetDataClass((IDataObject*) arg, &pItem, &type);
		else if (event == MMCN_SELECT)
		{
			hr = pT->m_pComponentData->GetDataClass((IDataObject*) param, &pItem, &type);
			const BOOL bSelect = (BOOL) HIWORD (arg);
			if (bSelect)
			{
				int n = pT->m_toolbarMap.GetSize();
				for (int i = 0; i < n; i++)
				{
					IToolbar* pToolbar = (IToolbar*)pT->m_toolbarMap.GetValueAt(i);
					 if (pToolbar != NULL)
						pT->m_spControlbar->Detach(pToolbar);
				}
			}
		}

		if (SUCCEEDED(hr) && pItem != NULL)
			hr = pItem->ControlbarNotify(pT->m_spControlbar, this, &(pT->m_toolbarMap), event, arg, param, (CSnapInObjectRootBase*) pT, type);

		return hr;
	}
};

#define SNAPINMENUID(id) \
public: \
	static const UINT GetMenuID() \
	{ \
		static const UINT IDMENU = id; \
		return id; \
	}

#define EXT_SNAPINMENUID(id) \
public: \
	static const UINT GetMenuID() \
	{ \
		static const UINT IDMENU = id; \
		return id; \
	}

#define BEGIN_SNAPINCOMMAND_MAP(theClass, bIsExtension) \
	HRESULT ProcessCommand(UINT nID, \
		_Out_ bool& bHandled, \
		_In_opt_ ATL::CSnapInObjectRootBase* pObj, \
		_In_ DATA_OBJECT_TYPES type) \
	{ \
			bHandled = true; \
			HRESULT hr = S_OK;

#define SNAPINCOMMAND_ENTRY(id, func) \
		if (id == nID) \
		{ \
			hr = func(bHandled, pObj); \
			if (bHandled) \
				return hr; \
		}

#define SNAPINCOMMAND_RANGE_ENTRY(id1, id2, func) \
		if (nID >= id1 && nID <= id2) \
		{ \
			hr = func(nID, bHandled, pObj); \
			if (bHandled) \
				return hr; \
		}

#define CHAIN_SNAPINCOMMAND_MAP(theChainClass) \
	{ \
		hr = theChainClass::ProcessCommand(nID, bHandled, pObj, type); \
		if (bHandled) \
			return hr; \
	}

#define END_SNAPINCOMMAND_MAP() \
			return hr; \
	}

struct CSnapInToolBarData
{
	WORD wVersion;
	WORD wWidth;
	WORD wHeight;
	WORD wItemCount;
	//WORD aItems[wItemCount]

	WORD* items()
	{
		return (WORD*)(this+1);
	}
};

#define RT_TOOLBAR  MAKEINTRESOURCE(241)

class CSnapInToolbarInfo
{
public:
	void __stdcall CleanUp(_In_ DWORD_PTR /*dw*/)
	{
		if (m_pStrToolTip)
		{
			for (UINT i = 0; i < m_nButtonCount; i++)
			{
				delete m_pStrToolTip[i];
				m_pStrToolTip[i] = NULL;
			}
			delete [] m_pStrToolTip;
			m_pStrToolTip = NULL;
		}

		if (m_pStrButtonText)
		{
			for (UINT i = 0; i < m_nButtonCount; i++)
			{
				delete m_pStrButtonText[i];
				m_pStrButtonText[i] = NULL;
			}

			delete [] m_pStrButtonText;
			m_pStrButtonText = NULL;
		}
		if (m_pnButtonID)
		{
			delete m_pnButtonID;
			m_pnButtonID = NULL;
		}

		m_nButtonCount = 0;
	}

	OLECHAR** m_pStrToolTip;
	OLECHAR** m_pStrButtonText;
	UINT* m_pnButtonID;
	UINT m_idToolbar;
	UINT m_nButtonCount;
};

#define BEGIN_SNAPINTOOLBARID_MAP(theClass) \
public: \
	static ATL::CSnapInToolbarInfo* GetToolbarInfo() \
	{ \
		static ATL::CSnapInToolbarInfo m_toolbarInfo[] = \
		{

#define SNAPINTOOLBARID_ENTRY(id) \
			{ NULL, NULL, NULL, id, 0},

#define END_SNAPINTOOLBARID_MAP() \
			{ NULL, NULL, NULL, 0, 0} \
		}; \
		return m_toolbarInfo; \
	}

template <class T, BOOL bIsExtension = FALSE>
class ATL_NO_VTABLE CSnapInItemImpl :
	public CSnapInItem
{
public:
	CSnapInItemImpl()
	{
	}

	virtual ~CSnapInItemImpl()
	{
	}

public:

	STDMETHOD(Notify)(
		_In_ MMC_NOTIFY_TYPE /*event*/,
		_In_ LONG_PTR /*arg*/,
		_In_ LONG_PTR /*param*/,
		_Inout_opt_ IComponentData* /*pComponentData*/,
		_Inout_opt_ IComponent* /*pComponent*/,
		_In_ DATA_OBJECT_TYPES /*type*/)
	{
		ATLASSERT("Override Function in Derived Class");
		ATLTRACENOTIMPL(_T("CSnapInItemImpl::Notify"));
	}

	STDMETHOD(GetScopePaneInfo)(_In_ SCOPEDATAITEM * /*pScopeDataItem*/)
	{
		ATLTRACENOTIMPL(_T("CSnapInItemImpl::GetScopePaneInfo"));
	}

	STDMETHOD(GetResultViewType)(
		_Deref_out_opt_z_ LPOLESTR *ppViewType,
		_Out_ long *pViewOptions)
	{
		ATLTRACE(atlTraceSnapin, 2, _T("CSnapInItemImpl::GetResultViewType\n"));
		*ppViewType = NULL;
		*pViewOptions = MMC_VIEW_OPTIONS_NONE;
		return S_FALSE;
	}

	STDMETHOD(GetResultPaneInfo)(_In_opt_ RESULTDATAITEM * /*pResultDataItem*/)
	{
		ATLTRACENOTIMPL(_T("CSnapInItemImpl::GetResultPaneInfo"));
	}

	STDMETHOD(AddMenuItems)(
		_In_ LPCONTEXTMENUCALLBACK piCallback,
		_Inout_ long *pInsertionAllowed,
		_In_ DATA_OBJECT_TYPES /*type*/)
	{
		ATLTRACE(atlTraceSnapin, 2, _T("CSnapInItemImpl::AddMenuItems\n"));
		T* pT = static_cast<T*>(this);

		if (!bIsExtension)
			pT->SetMenuInsertionFlags(true, pInsertionAllowed);

		UINT menuID = pT->GetMenuID();
		if (menuID == 0)
			return S_OK;

		HMENU hMenu = LoadMenu(_AtlBaseModule.GetResourceInstance(), MAKEINTRESOURCE(menuID));
		long insertionID;
		if (hMenu)
		{
			USES_CONVERSION_EX;

			for (int i = 0; 1; i++)
			{
				HMENU hSubMenu = GetSubMenu(hMenu, i);
				if (hSubMenu == NULL)
					break;

				MENUITEMINFO menuItemInfo;
				memset(&menuItemInfo, 0, sizeof(menuItemInfo));
				menuItemInfo.cbSize = sizeof(menuItemInfo);

				switch (i)
				{
				case 0:
					if (! (*pInsertionAllowed & CCM_INSERTIONALLOWED_TOP) )
						continue;
					insertionID = CCM_INSERTIONPOINTID_PRIMARY_TOP;
					break;

				case 1:
					if (! (*pInsertionAllowed & CCM_INSERTIONALLOWED_NEW) )
						continue;
					if (bIsExtension)
						insertionID = CCM_INSERTIONPOINTID_3RDPARTY_NEW;
					else
						insertionID = CCM_INSERTIONPOINTID_PRIMARY_NEW;
					break;

				case 2:;
					if (! (*pInsertionAllowed & CCM_INSERTIONALLOWED_TASK) )
						continue;
					if (bIsExtension)
						insertionID = CCM_INSERTIONPOINTID_3RDPARTY_TASK;
					else
						insertionID = CCM_INSERTIONPOINTID_PRIMARY_TASK;
					break;
				case 3:;
					if (! (*pInsertionAllowed & CCM_INSERTIONALLOWED_VIEW) )
						continue;
					insertionID = CCM_INSERTIONPOINTID_PRIMARY_VIEW;
					break;
				default:
					{
						insertionID = 0;
						continue;
					}
					break;
				}

				menuItemInfo.fMask = MIIM_TYPE | MIIM_STATE | MIIM_ID;
				menuItemInfo.fType = MFT_STRING;
				TCHAR szMenuText[128];

				for (int j = 0; 1; j++)
				{
					menuItemInfo.fMask = MIIM_TYPE | MIIM_STATE | MIIM_ID;
					menuItemInfo.fType = MFT_STRING;
					menuItemInfo.cch = 128;
					menuItemInfo.dwTypeData = szMenuText;
					TCHAR szStatusBar[256];

					if (!GetMenuItemInfo(hSubMenu, j, TRUE, &menuItemInfo))
						break;
					if (menuItemInfo.fType != MFT_STRING)
						continue;

					/* force termination -- should be unnecessary because we check return from GetMenuItemInfo */
					szMenuText[_countof(szMenuText)-1]=_T('\0');

					pT->UpdateMenuState(menuItemInfo.wID, szMenuText, &menuItemInfo.fState);
					LoadString(_AtlBaseModule.GetResourceInstance(), menuItemInfo.wID, szStatusBar, 256);

					OLECHAR wszStatusBar[256];
					OLECHAR wszMenuText[128];
					if(!ocscpy_s(wszMenuText, _countof(wszMenuText), CT2COLE(szMenuText)) ||
						!ocscpy_s(wszStatusBar, _countof(wszStatusBar), CT2COLE (szStatusBar)))
					{
						return E_FAIL;
					}

					CONTEXTMENUITEM contextMenuItem;
					contextMenuItem.strName = wszMenuText;
					contextMenuItem.strStatusBarText = wszStatusBar;
					contextMenuItem.lCommandID = menuItemInfo.wID;
					contextMenuItem.lInsertionPointID = insertionID;
					contextMenuItem.fFlags = menuItemInfo.fState;
					contextMenuItem.fSpecialFlags = 0;

					HRESULT hr = piCallback->AddItem(&contextMenuItem);
					DBG_UNREFERENCED_LOCAL_VARIABLE(hr);
					ATLASSERT(SUCCEEDED(hr));
				}
			}
			DestroyMenu(hMenu);
		}

		if (!bIsExtension)
			pT->SetMenuInsertionFlags(true, pInsertionAllowed);

		return S_OK;
	}

	STDMETHOD(Command)(
		_In_ long lCommandID,
		_Inout_opt_ CSnapInObjectRootBase* pObj,
		_In_ DATA_OBJECT_TYPES type)
	{
		ATLTRACE(atlTraceSnapin, 2, _T("CSnapInItemImpl::Command\n"));
		bool bHandled = false;
		T* pT = static_cast<T*>(this);
		return pT->ProcessCommand(lCommandID, bHandled, pObj, type);
	}

	STDMETHOD(CreatePropertyPages)(
		_In_ LPPROPERTYSHEETCALLBACK /*lpProvider*/,
		_In_ LONG_PTR /*handle*/,
		_Inout_opt_ IUnknown* /*pUnk*/,
		_In_ DATA_OBJECT_TYPES /*type*/)
	{
		ATLASSERT("Override Function in Derived Class");
		ATLTRACENOTIMPL(_T("CSnapInItemImpl::CreatePropertyPages"));
	}

	STDMETHOD(QueryPagesFor)(_In_ DATA_OBJECT_TYPES /*type*/)
	{
		ATLASSERT("Override Function in Derived Class");
		ATLTRACENOTIMPL(_T("CSnapInItemImpl::QueryPagesFor"));
	}

	STDMETHOD(SetControlbar)(
		_Inout_ IControlbar *pControlbar,
		_Inout_opt_ IExtendControlbar* pExtendControlBar,
		_Inout_ CSimpleMap<UINT, IUnknown*>* pToolbarMap)
	{
		ATLTRACE(atlTraceSnapin, 2, _T("CSnapInItemImpl::SetControlbar\n"));
		static bool m_bAddTermFunc = false;
		if (!m_bAddTermFunc)
		{
			m_bAddTermFunc = true;
			_pAtlModule->AddTermFunc(CleanUpToolbarInfo, 0);
		}

		T* pT = static_cast<T*>(this);

		CSnapInToolbarInfo* pInfo = pT->GetToolbarInfo();
		if (pInfo == NULL)
			return S_OK;

		USES_CONVERSION_EX;
		for( ; pInfo->m_idToolbar; pInfo++)
		{
			IToolbar* p = (IToolbar*) pToolbarMap->Lookup(pInfo->m_idToolbar);
			if (p != NULL)
				continue;

			HBITMAP hBitmap = LoadBitmap(_AtlBaseModule.GetResourceInstance(), MAKEINTRESOURCE(pInfo->m_idToolbar));
			if (hBitmap == NULL)
				return E_FAIL;

			HRSRC hRsrc = ::FindResource(_AtlBaseModule.GetResourceInstance(), MAKEINTRESOURCE(pInfo->m_idToolbar), RT_TOOLBAR);
			if (hRsrc == NULL)
				return E_FAIL;

			HGLOBAL hGlobal = LoadResource(_AtlBaseModule.GetResourceInstance(), hRsrc);
			if (hGlobal == NULL)
				return E_FAIL;

			CSnapInToolBarData* pData = (CSnapInToolBarData*)LockResource(hGlobal);
			if (pData == NULL)
				return E_FAIL;
			ATLASSERT(pData->wVersion == 1);
			ATLASSERT(pData->wWidth == 16);
			ATLASSERT(pData->wHeight == 16);

			int nButtonCount = pData->wItemCount;
			if (pInfo->m_pnButtonID == NULL)
				ATLTRY(pInfo->m_pnButtonID = new UINT[nButtonCount]);
			pInfo->m_nButtonCount=nButtonCount;

			if (pInfo->m_pnButtonID == NULL)
				continue;

			CAutoVectorPtr<MMCBUTTON> pButtons;
			if (!pButtons.Allocate(pData->wItemCount))
			{
				delete []pInfo->m_pnButtonID;
				pInfo->m_pnButtonID=NULL;
				continue;
			}

			if (pInfo->m_pStrToolTip == NULL)
			{
				ATLTRY(pInfo->m_pStrToolTip = new OLECHAR* [pData->wItemCount]);
				if (pInfo->m_pStrToolTip)
					memset(pInfo->m_pStrToolTip, 0, sizeof(OLECHAR*) * pData->wItemCount);
			}

			if (pInfo->m_pStrToolTip == NULL)
			{
				delete []pInfo->m_pnButtonID;
				pInfo->m_pnButtonID=NULL;
				continue;
			}

			for (int i = 0, j = 0; i < pData->wItemCount; i++)
			{
				pInfo->m_pnButtonID[i] = pButtons[i].idCommand = pData->items()[i];
				if (pButtons[i].idCommand)
				{
					pButtons[i].nBitmap = j++;
					// get the statusbar string and allow modification of the button state
					TCHAR szStatusBar[512];
					LoadString(_AtlBaseModule.GetResourceInstance(), pButtons[i].idCommand, szStatusBar, 512);

					if (pInfo->m_pStrToolTip[i] == NULL)
					{
						ATLTRY(pInfo->m_pStrToolTip[i] = new OLECHAR[lstrlen(szStatusBar) + 1]);
					}
					if (pInfo->m_pStrToolTip[i] == NULL)
						continue;
					if(!ocscpy_s(pInfo->m_pStrToolTip[i], (lstrlen(szStatusBar) + 1), CT2COLE(szStatusBar)))
					{
						return E_FAIL;
					}
					pButtons[i].lpTooltipText = pInfo->m_pStrToolTip[i];
					pButtons[i].lpButtonText = OLESTR("");
					pButtons[i].fsState = TBSTATE_ENABLED;
					pButtons[i].fsType = TBSTYLE_BUTTON;
					pT->SetToolbarButtonInfo(pButtons[i].idCommand, &pButtons[i].fsState, &pButtons[i].fsType);
				}
				else
				{
					pButtons[i].lpTooltipText = OLESTR("");
					pButtons[i].lpButtonText = OLESTR("");
					pButtons[i].fsType = TBSTYLE_SEP;
					pButtons[i].fsState = 0;
				}
			}

			CComPtr<IToolbar> pToolbar;
			HRESULT hr = pControlbar->Create(TOOLBAR, pExtendControlBar, reinterpret_cast<LPUNKNOWN*>(&pToolbar));
			if (SUCCEEDED(hr))
			{
				hr = pToolbar->AddBitmap(pData->wItemCount, hBitmap, pData->wWidth, pData->wHeight, RGB(192, 192, 192));
				if (SUCCEEDED(hr))
				{
					hr = pToolbar->AddButtons(pData->wItemCount, pButtons);
					if (SUCCEEDED(hr))
					{
						pToolbarMap->Add(pInfo->m_idToolbar, pToolbar);
					}
				}
			}
		}
		return S_OK;
	}

	STDMETHOD(ControlbarNotify)(
		_Inout_ IControlbar *pControlbar,
		_Inout_opt_ IExtendControlbar *pExtendControlbar,
		_Inout_ CSimpleMap<UINT, IUnknown*>* pToolbarMap,
		_In_ MMC_NOTIFY_TYPE event,
		_In_ LONG_PTR arg,
		_In_ LONG_PTR param,
		_Inout_opt_ CSnapInObjectRootBase* pObj,
		_In_ DATA_OBJECT_TYPES type)
	{
		ATLTRACE(atlTraceSnapin, 2, _T("CSnapInItemImpl::ControlbarNotify\n"));
		T* pT = static_cast<T*>(this);

		SetControlbar(pControlbar, pExtendControlbar, pToolbarMap);

		if(event == MMCN_SELECT)
		{
			if (pControlbar == NULL)
				return S_OK;

			BOOL bSelect = (BOOL) HIWORD (arg);

			CSnapInToolbarInfo* pInfo = pT->GetToolbarInfo();
			if (pInfo == NULL)
				return S_OK;

			for(; pInfo->m_idToolbar; pInfo++)
			{
				IToolbar* pToolbar = (IToolbar*)pToolbarMap->Lookup(pInfo->m_idToolbar);
				if (pToolbar == NULL)
					continue;
				if (bSelect)
					pControlbar->Attach(TOOLBAR, pToolbar);
				for (UINT i = 0; i < pInfo->m_nButtonCount; i++)
				{
					if (pInfo->m_pnButtonID[i])
					{
						BOOL bEnable;
						if (bSelect)
							bEnable = pT->UpdateToolbarButton(pInfo->m_pnButtonID[i],
								ENABLED);
						else
							bEnable = FALSE;

						pToolbar->SetButtonState(pInfo->m_pnButtonID[i],
							ENABLED, bEnable
							);
						pToolbar->SetButtonState(pInfo->m_pnButtonID[i],
							CHECKED,
							pT->UpdateToolbarButton(pInfo->m_pnButtonID[i],
								CHECKED));
						pToolbar->SetButtonState(pInfo->m_pnButtonID[i],
							HIDDEN,
							pT->UpdateToolbarButton(pInfo->m_pnButtonID[i],
								HIDDEN));
						pToolbar->SetButtonState(pInfo->m_pnButtonID[i],
							INDETERMINATE,
							pT->UpdateToolbarButton(pInfo->m_pnButtonID[i],
								INDETERMINATE));
						pToolbar->SetButtonState(pInfo->m_pnButtonID[i],
							BUTTONPRESSED,
							pT->UpdateToolbarButton(pInfo->m_pnButtonID[i],
								BUTTONPRESSED));
					}
				}
			}
			return S_OK;
		}
		else if (event == MMCN_BTN_CLICK)
		{
			bool bHandled;
			return pT->ProcessCommand((UINT) param, bHandled, pObj, type);
		}

		return E_UNEXPECTED;
	}

	STDMETHOD(GetScopeData)(_Deref_out_ SCOPEDATAITEM **pScopeDataItem)
	{
		if (pScopeDataItem == NULL)
			return E_FAIL;

		*pScopeDataItem = &m_scopeDataItem;
		return S_OK;
	}

	STDMETHOD(GetResultData)(_Deref_out_ RESULTDATAITEM **pResultDataItem)
	{
		if (pResultDataItem == NULL)
			return E_FAIL;

		*pResultDataItem = &m_resultDataItem;
		return S_OK;
	}
	
ATLPREFAST_SUPPRESS(6387)
	STDMETHOD(GetDataObject)(
		_Deref_out_ IDataObject** pDataObj,
		_In_ DATA_OBJECT_TYPES type)
	{
		ATLASSERT(pDataObj != NULL);
		if (pDataObj == NULL)
			return E_POINTER;
		*pDataObj = NULL;

		CComObject<CSnapInDataObjectImpl>* pData;
		HRESULT hr = CComObject<CSnapInDataObjectImpl>::CreateInstance(&pData);
		if (FAILED(hr))
			return hr;

		T* pT = static_cast<T*> (this);
		pData->m_objectData.m_pItem = pT;
		pData->m_objectData.m_type = type;

		hr = pData->QueryInterface(__uuidof(IDataObject), (void**)(pDataObj));
		return hr;
	}
ATLPREFAST_UNSUPPRESS()
	
	void UpdateMenuState(
		_In_ UINT /*id*/,
		_In_opt_z_ LPTSTR /*pBuf*/,
		_In_opt_ UINT * /*flags*/)
	{
		return;
	}

	void SetToolbarButtonInfo(
		_In_ UINT /*id*/,
		_Out_ BYTE *pfsState,
		_Out_ BYTE *pfsType)
	{
		*pfsState = TBSTATE_ENABLED;
		*pfsType = TBSTYLE_BUTTON;
	}

	BOOL UpdateToolbarButton(
		_In_ UINT /*id*/,
		_In_ BYTE fsState)
	{
		if (fsState == ENABLED)
			return TRUE;
		return FALSE;
	}

	HRESULT ProcessCommand(
		_In_ UINT nID,
		_In_ bool& /*bHandled*/,
		_In_opt_ CSnapInObjectRootBase* /*pObj*/,
		_In_ DATA_OBJECT_TYPES /*type*/)
	{
		UNREFERENCED_PARAMETER(nID);
		ATLTRACE(atlTraceSnapin, 2, _T("No handler for item with ID %d\n"), nID);
		return S_OK;
	}

	STDMETHOD (FillData)(
		_In_ CLIPFORMAT cf,
		_Inout_ LPSTREAM pStream)
	{
		HRESULT hr = DV_E_CLIPFORMAT;
		ULONG uWritten;

		T* pT = static_cast<T*> (this);

		if (cf == m_CCF_NODETYPE)
		{
			hr = pStream->Write(pT->GetNodeType(), sizeof(GUID), &uWritten);
			return hr;
		}

		if (cf == m_CCF_SZNODETYPE)
		{
			hr = pStream->Write(pT->GetSZNodeType(), (ocslen((OLECHAR*)pT->GetSZNodeType()) + 1 )* sizeof(OLECHAR), &uWritten);
			return hr;
		}

		if (cf == m_CCF_DISPLAY_NAME)
		{
			hr = pStream->Write(pT->GetDisplayName(), (ocslen((OLECHAR*)pT->GetDisplayName()) + 1) * sizeof(OLECHAR), &uWritten);
			return hr;
		}

		if (cf == m_CCF_SNAPIN_CLASSID)
		{
			hr = pStream->Write(pT->GetSnapInCLSID(), sizeof(GUID), &uWritten);
			return hr;
		}

		return hr;
	}

	static CSnapInToolbarInfo* GetToolbarInfo()
	{
		return NULL;
	}

	static void _stdcall CleanUpToolbarInfo(_In_ DWORD_PTR dw)
	{
		for (CSnapInToolbarInfo* pInfo = T::GetToolbarInfo(); pInfo->m_idToolbar != 0; pInfo++)
		{
			pInfo->CleanUp(dw);
		}
	}

	static const UINT GetMenuID()
	{
		return 0;
	}

	void SetMenuInsertionFlags(
		_In_ bool /*bBeforeInsertion*/,
		_In_opt_ long* /*pInsertionAllowed*/)
	{
	}

	void* GetNodeType()
	{
		return (void*)T::m_NODETYPE;
	}
	void* GetSZNodeType()
	{
		return (void*)T::m_SZNODETYPE;
	}

	void* GetDisplayName()
	{
		return (void*)T::m_SZDISPLAY_NAME;
	}

	void* GetSnapInCLSID()
	{
		return (void*)T::m_SNAPIN_CLASSID;
	}

	CComBSTR m_bstrDisplayName;
	SCOPEDATAITEM m_scopeDataItem;
	RESULTDATAITEM m_resultDataItem;
};

_declspec( selectany ) CLIPFORMAT CSnapInItem::m_CCF_NODETYPE = 0;
_declspec( selectany ) CLIPFORMAT CSnapInItem::m_CCF_SZNODETYPE = 0;
_declspec( selectany ) CLIPFORMAT CSnapInItem::m_CCF_DISPLAY_NAME = 0;
_declspec( selectany ) CLIPFORMAT CSnapInItem::m_CCF_SNAPIN_CLASSID = 0;
_declspec( selectany ) CLIPFORMAT CSnapInItem::m_CCF_SNAPIN_GETOBJECTDATA = 0;
_declspec( selectany ) CLIPFORMAT CSnapInItem::m_CCF_MMC_MULTISELECT_DATAOBJECT = 0;

}; //namespace ATL


#pragma pack(pop)
#ifndef _ATL_NO_PRAGMA_WARNINGS
#pragma warning (pop)
#endif //!_ATL_NO_PRAGMA_WARNINGS

#endif //__ATLSNAP_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\include\atlsimpcoll.h ===
// This is a part of the Active Template Library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Active Template Library Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Active Template Library product.

#ifndef __ATLSIMPCOLL_H__
#define __ATLSIMPCOLL_H__

#pragma once

#include <atldef.h>
#include <atlchecked.h>
#include <wchar.h>

#pragma push_macro("malloc")
#undef malloc
#pragma push_macro("calloc")
#undef calloc
#pragma push_macro("realloc")
#undef realloc
#pragma push_macro("_recalloc")
#undef _recalloc
#pragma push_macro("free")
#undef free

#pragma warning(push)
#pragma warning(disable: 4800) // forcing 'int' value to bool


#pragma pack(push,_ATL_PACKING)
namespace ATL
{

#pragma push_macro("new")
#undef new

/////////////////////////////////////////////////////////////////////////////
// Collection helpers - CSimpleArray & CSimpleMap

// template class helpers with functions for comparing elements
// override if using complex types without operator==
template <class T>
class CSimpleArrayEqualHelper
{
public:
	static bool IsEqual(
		_In_ const T& t1,
		_In_ const T& t2)
	{
		return (t1 == t2);
	}
};

template <class T>
class CSimpleArrayEqualHelperFalse
{
public:
	static bool IsEqual(
		_In_ const T&,
		_In_ const T&)
	{
		ATLASSERT(false);
		return false;
	}
};

template <class TKey, class TVal>
class CSimpleMapEqualHelper
{
public:
	static bool IsEqualKey(
		_In_ const TKey& k1,
		_In_ const TKey& k2)
	{
		return CSimpleArrayEqualHelper<TKey>::IsEqual(k1, k2);
	}

	static bool IsEqualValue(
		_In_ const TVal& v1,
		_In_ const TVal& v2)
	{
		return CSimpleArrayEqualHelper<TVal>::IsEqual(v1, v2);
	}
};

template <class TKey, class TVal>
class CSimpleMapEqualHelperFalse
{
public:
	static bool IsEqualKey(
		_In_ const TKey& k1,
		_In_ const TKey& k2)
	{
		return CSimpleArrayEqualHelper<TKey>::IsEqual(k1, k2);
	}

	static bool IsEqualValue(
		_In_ const TVal&,
		_In_ const TVal&)
	{
		ATLASSERT(FALSE);
		return false;
	}
};

template <class T, class TEqual = CSimpleArrayEqualHelper< T > >
class CSimpleArray
{
public:
// Construction/destruction
	CSimpleArray() :
		m_aT(NULL), m_nSize(0), m_nAllocSize(0)
	{
	}

	~CSimpleArray();

	CSimpleArray(_In_ const CSimpleArray< T, TEqual >& src) :
		m_aT(NULL), m_nSize(0), m_nAllocSize(0)
	{
        if (src.GetSize())
        {
			m_aT = (T*)calloc(src.GetSize(), sizeof(T));
			if (m_aT != NULL)
			{
				m_nAllocSize = src.GetSize();
				for (int i=0; i<src.GetSize(); i++)
					Add(src[i]);
			}
		}
	}
	CSimpleArray< T, TEqual >& operator=(_In_ const CSimpleArray< T, TEqual >& src)
	{
		if (GetSize() != src.GetSize())
		{
			RemoveAll();
			m_aT = (T*)calloc(src.GetSize(), sizeof(T));
			if (m_aT != NULL)
				m_nAllocSize = src.GetSize();
		}
		else
		{
			for (int i = GetSize(); i > 0; i--)
				RemoveAt(i - 1);
		}
		for (int i=0; i<src.GetSize(); i++)
			Add(src[i]);
		return *this;
	}

// Operations
	int GetSize() const
	{
		return m_nSize;
	}
	BOOL Add(_In_ const T& t)
	{
		if(m_nSize == m_nAllocSize)
		{
			// Make sure newElement is not a reference to an element in the array.
			// Or else, it will be invalidated by the reallocation.
			ATLENSURE(	(&t < m_aT) ||
						(&t >= (m_aT + m_nAllocSize) ) );

			T* aT;
			int nNewAllocSize = (m_nAllocSize == 0) ? 1 : (m_nSize * 2);

			if (nNewAllocSize<0||nNewAllocSize>INT_MAX/sizeof(T))
			{
				return FALSE;
			}

			aT = (T*)_recalloc(m_aT, nNewAllocSize, sizeof(T));
			if(aT == NULL)
				return FALSE;
			m_nAllocSize = nNewAllocSize;
			m_aT = aT;
		}
		InternalSetAtIndex(m_nSize, t);
		m_nSize++;
		return TRUE;
	}
	BOOL Remove(_In_ const T& t)
	{
		int nIndex = Find(t);
		if(nIndex == -1)
			return FALSE;
		return RemoveAt(nIndex);
	}
	BOOL RemoveAt(_In_ int nIndex)
	{
		ATLASSERT(nIndex >= 0 && nIndex < m_nSize);
		if (nIndex < 0 || nIndex >= m_nSize)
			return FALSE;
		m_aT[nIndex].~T();
		if(nIndex != (m_nSize - 1))
			Checked::memmove_s((void*)(m_aT + nIndex), (m_nSize - nIndex) * sizeof(T), (void*)(m_aT + nIndex + 1), (m_nSize - (nIndex + 1)) * sizeof(T));
		m_nSize--;
		return TRUE;
	}
	void RemoveAll()
	{
		if(m_aT != NULL)
		{
			for(int i = 0; i < m_nSize; i++)
				m_aT[i].~T();
			free(m_aT);
			m_aT = NULL;
		}
		m_nSize = 0;
		m_nAllocSize = 0;
    }
	const T& operator[] (_In_ int nIndex) const
	{
		ATLASSERT(nIndex >= 0 && nIndex < m_nSize);
		if(nIndex < 0 || nIndex >= m_nSize)
		{
			_AtlRaiseException((DWORD)EXCEPTION_ARRAY_BOUNDS_EXCEEDED);
		}
		return m_aT[nIndex];
	}
	T& operator[] (_In_ int nIndex)
	{
		ATLASSERT(nIndex >= 0 && nIndex < m_nSize);
		if(nIndex < 0 || nIndex >= m_nSize)
		{
			_AtlRaiseException((DWORD)EXCEPTION_ARRAY_BOUNDS_EXCEEDED);
		}
		return m_aT[nIndex];
	}
	T* GetData() const
	{
		return m_aT;
	}

	int Find(_In_ const T& t) const
	{
		for(int i = 0; i < m_nSize; i++)
		{
			if(TEqual::IsEqual(m_aT[i], t))
				return i;
		}
		return -1;  // not found
	}

	BOOL SetAtIndex(
		_In_ int nIndex,
		_In_ const T& t)
	{
		if (nIndex < 0 || nIndex >= m_nSize)
			return FALSE;
		InternalSetAtIndex(nIndex, t);
		return TRUE;
	}

// Implementation
	class Wrapper
	{
	public:
		Wrapper(_In_ const T& _t) : t(_t)
		{
		}
		template <class _Ty>
		void * __cdecl operator new(
			_In_ size_t,
			_In_ _Ty* p)
		{
			return p;
		}
		template <class _Ty>
		void __cdecl operator delete(
			_In_ void* /* pv */,
			_In_ _Ty* /* p */)
		{
		}
		T t;
	};

// Implementation
	void InternalSetAtIndex(
		_In_ int nIndex,
		_In_ const T& t)
	{
		new(m_aT + nIndex) Wrapper(t);
	}

	typedef T _ArrayElementType;
	T* m_aT;
	int m_nSize;
	int m_nAllocSize;
};

#define CSimpleValArray CSimpleArray

template <class T, class TEqual> inline CSimpleArray<T, TEqual>::~CSimpleArray()
{
	RemoveAll();
}

// intended for small number of simple types or pointers
template <class TKey, class TVal, class TEqual = CSimpleMapEqualHelper< TKey, TVal > >
class CSimpleMap
{
public:
	TKey* m_aKey;
	TVal* m_aVal;
	int m_nSize;

	typedef TKey _ArrayKeyType;
	typedef TVal _ArrayElementType;

// Construction/destruction
	CSimpleMap() :
		m_aKey(NULL), m_aVal(NULL), m_nSize(0)
	{
	}

	~CSimpleMap()
	{
		RemoveAll();
	}

// Operations
	int GetSize() const
	{
		return m_nSize;
	}
	BOOL Add(
		_In_ const TKey& key,
		_In_ const TVal& val)
	{
		TKey* pKey;
		pKey = (TKey*)_recalloc(m_aKey, (m_nSize + 1), sizeof(TKey));
		if(pKey == NULL)
			return FALSE;
		m_aKey = pKey;
		TVal* pVal;
		pVal = (TVal*)_recalloc(m_aVal, (m_nSize + 1), sizeof(TVal));
		if(pVal == NULL)
			return FALSE;
		m_aVal = pVal;
		InternalSetAtIndex(m_nSize, key, val);
		m_nSize++;
		return TRUE;
	}
	BOOL Remove(_In_ const TKey& key)
	{
		int nIndex = FindKey(key);
		if(nIndex == -1)
			return FALSE;
		return RemoveAt(nIndex);
	}
	BOOL RemoveAt(_In_ int nIndex)
	{
		ATLASSERT(nIndex >= 0 && nIndex < m_nSize);
		if (nIndex < 0 || nIndex >= m_nSize)
			return FALSE;
		m_aKey[nIndex].~TKey();
		m_aVal[nIndex].~TVal();
		if(nIndex != (m_nSize - 1))
		{
			Checked::memmove_s((void*)(m_aKey + nIndex), (m_nSize - nIndex) * sizeof(TKey), (void*)(m_aKey + nIndex + 1), (m_nSize - (nIndex + 1)) * sizeof(TKey));
			Checked::memmove_s((void*)(m_aVal + nIndex), (m_nSize - nIndex) * sizeof(TVal), (void*)(m_aVal + nIndex + 1), (m_nSize - (nIndex + 1)) * sizeof(TVal));
		}
		TKey* pKey;
		pKey = (TKey*)_recalloc(m_aKey, (m_nSize - 1), sizeof(TKey));
		if(pKey != NULL || m_nSize == 1)
			m_aKey = pKey;
		TVal* pVal;
		pVal = (TVal*)_recalloc(m_aVal, (m_nSize - 1), sizeof(TVal));
		if(pVal != NULL || m_nSize == 1)
			m_aVal = pVal;
		m_nSize--;
		return TRUE;
	}
	void RemoveAll()
	{
		if(m_aKey != NULL)
		{
			for(int i = 0; i < m_nSize; i++)
			{
				m_aKey[i].~TKey();
				m_aVal[i].~TVal();
			}
			free(m_aKey);
			m_aKey = NULL;
		}
		if(m_aVal != NULL)
		{
			free(m_aVal);
			m_aVal = NULL;
		}

		m_nSize = 0;
	}
	BOOL SetAt(
		_In_ const TKey& key,
		_In_ const TVal& val)
	{
		int nIndex = FindKey(key);
		if(nIndex == -1)
			return FALSE;
		ATLASSERT(nIndex >= 0 && nIndex < m_nSize);
		m_aKey[nIndex].~TKey();
		m_aVal[nIndex].~TVal();
		InternalSetAtIndex(nIndex, key, val);
		return TRUE;
	}
	TVal Lookup(_In_ const TKey& key) const
	{
		int nIndex = FindKey(key);
		if(nIndex == -1)
			return NULL;    // must be able to convert
		return GetValueAt(nIndex);
	}
	TKey ReverseLookup(_In_ const TVal& val) const
	{
		int nIndex = FindVal(val);
		if(nIndex == -1)
			return NULL;    // must be able to convert
		return GetKeyAt(nIndex);
	}
	TKey& GetKeyAt(_In_ int nIndex) const
	{
		ATLASSERT(nIndex >= 0 && nIndex < m_nSize);
		if(nIndex < 0 || nIndex >= m_nSize)
			_AtlRaiseException((DWORD)EXCEPTION_ARRAY_BOUNDS_EXCEEDED);

		return m_aKey[nIndex];
	}
	TVal& GetValueAt(_In_ int nIndex) const
	{
		ATLASSERT(nIndex >= 0 && nIndex < m_nSize);
		if(nIndex < 0 || nIndex >= m_nSize)
			_AtlRaiseException((DWORD)EXCEPTION_ARRAY_BOUNDS_EXCEEDED);

		return m_aVal[nIndex];
	}

	int FindKey(_In_ const TKey& key) const
	{
		for(int i = 0; i < m_nSize; i++)
		{
			if(TEqual::IsEqualKey(m_aKey[i], key))
				return i;
		}
		return -1;  // not found
	}
	int FindVal(_In_ const TVal& val) const
	{
		for(int i = 0; i < m_nSize; i++)
		{
			if(TEqual::IsEqualValue(m_aVal[i], val))
				return i;
		}
		return -1;  // not found
	}

	BOOL SetAtIndex(
		_In_ int nIndex,
		_In_ const TKey& key,
		_In_ const TVal& val)
	{
		if (nIndex < 0 || nIndex >= m_nSize)
			return FALSE;
		InternalSetAtIndex(nIndex, key, val);
		return TRUE;
	}


// Implementation

	template <typename T>
	class Wrapper
	{
	public:
		Wrapper(_In_ const T& _t) : t(_t)
		{
		}
		template <class _Ty>
		void *operator new(
			_In_ size_t,
			_In_ _Ty* p)
		{
			return p;
		}
		template <class _Ty>
		void operator delete(
			_In_ void* /* pv */,
			_In_ _Ty* /* p */)
		{
		}
		T t;
	};
	void InternalSetAtIndex(
		_In_ int nIndex,
		_In_ const TKey& key,
		_In_ const TVal& val)
	{
		new(m_aKey + nIndex) Wrapper<TKey>(key);
		new(m_aVal + nIndex) Wrapper<TVal>(val);
	}
};

#pragma pop_macro("new")

};  // namespace ATL
#pragma pack(pop)

#pragma warning(pop)

#pragma pop_macro("free")
#pragma pop_macro("realloc")
#pragma pop_macro("_recalloc")
#pragma pop_macro("malloc")
#pragma pop_macro("calloc")


#endif  // __ATLSIMPCOLL_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\include\atlsocket.inl ===
// This is a part of the Active Template Library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Active Template Library Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Active Template Library product.

#include <wtypes.h>
#include <atlconv.h>
#include <tchar.h>

namespace ATL
{
////////////////////////////////////////////////////////////////////////////
// CSocketAddr implmenetation.
////////////////////////////////////////////////////////////////////////////

inline CSocketAddr::CSocketAddr() throw()
{
	m_pAddrs = NULL;
}

inline CSocketAddr::~CSocketAddr() throw()
{
	if (m_pAddrs != NULL)
	{
		FreeAddrInfo(m_pAddrs);
		m_pAddrs = NULL;
	}
}

inline int CSocketAddr::FindAddr(
	_In_z_ LPCTSTR szHost,
	_In_z_ LPCTSTR szPortOrServiceName,
	_In_ int flags,
	_In_ int addr_family,
	_In_ int sock_type,
	_In_ int ai_proto) throw()
{
	if (m_pAddrs)
	{
		FreeAddrInfo(m_pAddrs);
		m_pAddrs = NULL;
	}

	ADDRINFOT hints;
	ZeroMemory(&hints, sizeof(hints));
	hints.ai_flags = flags;
	hints.ai_family = addr_family;
	hints.ai_socktype = sock_type;
	hints.ai_protocol = ai_proto;
#if _WIN32_WINNT < 0x0502
#ifdef _UNICODE
	USES_CONVERSION_EX;
	const char * pszHost = W2CA_EX(szHost, _ATL_SAFE_ALLOCA_DEF_THRESHOLD);
	const char * pszPortOrServiceName = W2CA_EX(szPortOrServiceName, _ATL_SAFE_ALLOCA_DEF_THRESHOLD);
	if(pszHost == NULL || pszPortOrServiceName == NULL )
	{
		WSASetLastError(WSA_NOT_ENOUGH_MEMORY);
		return SOCKET_ERROR;
	}
#else
	const char * pszHost = szHost;
	const char * pszPortOrServiceName = szPortOrServiceName;
#endif
	return ::GetAddrInfo(pszHost, pszPortOrServiceName, &hints, &m_pAddrs);
#else
	return ::GetAddrInfo(szHost, szPortOrServiceName, &hints, &m_pAddrs);
#endif
}

inline int CSocketAddr::FindAddr(
	_In_z_ LPCTSTR szHost,
	_In_ int nPortNo,
	_In_ int flags,
	_In_ int addr_family,
	_In_ int sock_type,
	_In_ int ai_proto) throw()
{
	// convert port number to string
	TCHAR szPort[12];
	if(::_itot_s(nPortNo, szPort, _countof(szPort), 10))
	{
		WSASetLastError(WSA_NOT_ENOUGH_MEMORY);
		return SOCKET_ERROR;
	}

	return FindAddr(szHost, szPort, flags, addr_family, sock_type, ai_proto);
}

inline int CSocketAddr::FindINET4Addr(
	_In_z_ LPCTSTR szHost,
	_In_ int nPortNo,
	_In_ int flags /* = 0 */,
	_In_ int sock_type /* = SOCK_STREAM */) throw()
{
	// convert port number to string
	TCHAR szPort[12];
	if(::_itot_s(nPortNo, szPort, _countof(szPort), 10))
	{
		WSASetLastError(WSA_NOT_ENOUGH_MEMORY);
		return SOCKET_ERROR;
	}
	return FindAddr(szHost, szPort, flags, PF_INET, sock_type, IPPROTO_IP);
}

inline int CSocketAddr::FindINET6Addr(
	_In_z_ LPCTSTR szHost,
	_In_ int nPortNo,
	_In_ int flags /* = 0 */,
	_In_ int sock_type /* = SOCK_STREAM */) throw()
{
	// convert port number to string
	TCHAR szPort[12];
	if(::_itot_s(nPortNo, szPort, _countof(szPort), 10))
	{
		WSASetLastError(WSA_NOT_ENOUGH_MEMORY);
		return SOCKET_ERROR;
	}

	// TEMP (alecont): With the new PSDK, IPPROTO_IPV6 is available only if _WIN32_WINNT >= 0x0501
	return FindAddr(szHost, szPort, flags, PF_INET6, sock_type, /*IPPROTO_IPV6*/ 41);
}

inline ADDRINFOT* const CSocketAddr::GetAddrInfoList() const
{
	return m_pAddrs;
}

inline ADDRINFOT* const CSocketAddr::GetAddrInfo(_In_ int nIndex /* = 0 */) const
{
	if (!m_pAddrs)
		return NULL;
	ADDRINFOT *pAI = m_pAddrs;
	while (nIndex > 0 && pAI != NULL)
	{
		pAI = pAI->ai_next;
		nIndex --;
	}
	return pAI;
}


}; // namespace ATL
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\include\atlstdthunk.h ===
// This is a part of the Active Template Library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Active Template Library Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Active Template Library product.

#ifndef __ATLSTDTHUNK_H__
#define __ATLSTDTHUNK_H__

#pragma once

#pragma push_macro("new")
#undef new

namespace ATL
{

/////////////////////////////////////////////////////////////////////////////
// Thunks for __stdcall member functions

#if defined(_M_IX86)
PVOID __stdcall __AllocStdCallThunk(VOID);
VOID  __stdcall __FreeStdCallThunk(_In_opt_ PVOID);

#pragma pack(push,1)
struct _stdcallthunk
{
	DWORD   m_mov;          // mov dword ptr [esp+0x4], pThis (esp+0x4 is hWnd)
	DWORD   m_this;         //
	BYTE    m_jmp;          // jmp WndProc
	DWORD   m_relproc;      // relative jmp
	BOOL Init(
		_In_ DWORD_PTR proc,
		_In_opt_ void* pThis)
	{
		m_mov = 0x042444C7;  //C7 44 24 0C
		m_this = PtrToUlong(pThis);
		m_jmp = 0xe9;
		m_relproc = DWORD((INT_PTR)proc - ((INT_PTR)this+sizeof(_stdcallthunk)));
		// write block from data cache and
		//  flush from instruction cache
		FlushInstructionCache(GetCurrentProcess(), this, sizeof(_stdcallthunk));
		return TRUE;
	}
	//some thunks will dynamically allocate the memory for the code
	void* GetCodeAddress()
	{
		return this;
	}
	_Ret_opt_bytecount_x_(sizeof(_stdcallthunk)) void* operator new(_In_ size_t)
	{
        return __AllocStdCallThunk();
    }
    void operator delete(_In_opt_ void* pThunk)
    {
        __FreeStdCallThunk(pThunk);
    }
};
#pragma pack(pop)

#elif defined(_M_AMD64)
PVOID __AllocStdCallThunk(VOID);
VOID  __FreeStdCallThunk(PVOID);
#pragma pack(push,2)
struct _stdcallthunk
{
    USHORT  RcxMov;         // mov rcx, pThis
    ULONG64 RcxImm;         //
    USHORT  RaxMov;         // mov rax, target
    ULONG64 RaxImm;         //
    USHORT  RaxJmp;         // jmp target
    BOOL Init(
		_In_ DWORD_PTR proc,
		_In_opt_ void *pThis)
    {
        RcxMov = 0xb948;          // mov rcx, pThis
        RcxImm = (ULONG64)pThis;  //
        RaxMov = 0xb848;          // mov rax, target
        RaxImm = (ULONG64)proc;   //
        RaxJmp = 0xe0ff;          // jmp rax
        FlushInstructionCache(GetCurrentProcess(), this, sizeof(_stdcallthunk));
		return TRUE;
    }
	//some thunks will dynamically allocate the memory for the code
	void* GetCodeAddress()
	{
		return this;
	}
	_Ret_opt_bytecount_x_(sizeof(_stdcallthunk)) void* operator new(_In_ size_t)
	{
        return __AllocStdCallThunk();
    }
    void operator delete(_In_opt_ void* pThunk)
    {
        __FreeStdCallThunk(pThunk);
    }
};
#pragma pack(pop)
#elif defined(_SH3_)
#pragma pack(push,4)
struct _stdcallthunk // this should come out to 16 bytes
{
	WORD	m_mov_r0;		// mov.l	pFunc,r0
	WORD	m_mov_r1;		// mov.l	pThis,r1
	WORD	m_jmp;			// jmp		@r0
	WORD	m_nop;			// nop
	DWORD	m_pFunc;
	DWORD	m_pThis;
	BOOL Init(
		_In_ DWORD_PTR proc,
		_In_opt_ void* pThis)
	{
		m_mov_r0 = 0xd001;
		m_mov_r1 = 0xd402;
		m_jmp = 0x402b;
		m_nop = 0x0009;
		m_pFunc = (DWORD)proc;
		m_pThis = (DWORD)pThis;
		// write block from data cache and
		//  flush from instruction cache
		FlushInstructionCache(GetCurrentProcess(), this, sizeof(_stdcallthunk));
		return TRUE;
	}
	void* GetCodeAddress()
	{
		return this;
	}
};
#pragma pack(pop)
#elif defined(_MIPS_)
#pragma pack(push,4)
struct _stdcallthunk
{
	WORD	m_pFuncHi;
	WORD	m_lui_t0;		// lui		t0,PFUNC_HIGH
	WORD	m_pFuncLo;
	WORD	m_ori_t0;		// ori		t0,t0,PFUNC_LOW
	WORD	m_pThisHi;
	WORD	m_lui_a0;		// lui		a0,PTHIS_HIGH
	DWORD	m_jr_t0;		// jr		t0
	WORD	m_pThisLo;
	WORD	m_ori_a0;		// ori		a0,PTHIS_LOW
	BOOL Init(
		_In_ DWORD_PTR proc,
		_In_opt_ void* pThis)
	{
		m_pFuncHi = HIWORD(proc);
		m_lui_t0  = 0x3c08;
		m_pFuncLo = LOWORD(proc);
		m_ori_t0  = 0x3508;
		m_pThisHi = HIWORD(pThis);
		m_lui_a0  = 0x3c04;
		m_jr_t0   = 0x01000008;
		m_pThisLo = LOWORD(pThis);
		m_ori_a0  = 0x3484;
		// write block from data cache and
		//  flush from instruction cache
		FlushInstructionCache(GetCurrentProcess(), this, sizeof(_stdcallthunk));
		return TRUE;
	}
	void* GetCodeAddress()
	{
		return this;
	}
};
#pragma pack(pop)
#elif defined(_ARM_)
#pragma pack(push,4)
struct _stdcallthunk // this should come out to 16 bytes
{
	DWORD	m_mov_r0;		// mov	r0, pThis
	DWORD	m_mov_pc;		// mov	pc, pFunc
	DWORD	m_pThis;
	DWORD	m_pFunc;
	BOOL Init(
		_In_ DWORD_PTR proc,
		_In_opt_ void* pThis)
	{
		m_mov_r0 = 0xE59F0000;
		m_mov_pc = 0xE59FF000;
		m_pThis = (DWORD)pThis;
		m_pFunc = (DWORD)proc;
		// write block from data cache and
		//  flush from instruction cache
		FlushInstructionCache(GetCurrentProcess(), this, sizeof(_stdcallthunk));
		return TRUE;
	}
	void* GetCodeAddress()
	{
		return this;
	}
};
#pragma pack(pop)
#elif defined(_M_IA64)
#pragma pack(push,8)
extern "C" void _StdCallThunkProcProc(void);
struct _FuncDesc
{
    void* pfn;
    void* gp;
};
struct _stdcallthunk
{
    _FuncDesc m_funcdesc;
    void* m_pFunc;
    void* m_pThis;

    BOOL Init(
		_In_ DWORD_PTR proc,
		_In_opt_ void* pThis)
    {
        m_funcdesc.pfn = ((_FuncDesc*)(&_StdCallThunkProcProc))->pfn;  // Pointer to actual beginning of StdCallThunkProc
        m_funcdesc.gp = &m_pFunc;
        m_pFunc = reinterpret_cast< void* >( proc );
        m_pThis = pThis;
        ::FlushInstructionCache( GetCurrentProcess(), this, sizeof( _stdcallthunk ) );
		return TRUE;
    }
    void* GetCodeAddress()
    {
        return( &m_funcdesc );
    }
};
#pragma pack(pop)
//IA64 thunks do not currently use the atlhunk.cpp allocator.
#else
#error Only ARM, ALPHA, SH3, MIPS, IA64, AMD64 and X86 supported
#endif


#if defined(_M_IX86) || defined (_M_AMD64)

#pragma pack(push,8)
class CDynamicStdCallThunk
{
public:
	_stdcallthunk *pThunk;

	CDynamicStdCallThunk()
	{
		pThunk = NULL;
	}

	~CDynamicStdCallThunk()
	{
		if (pThunk)
		{
			delete pThunk;
		}
	}

	BOOL Init(
		_In_ DWORD_PTR proc,
		_In_opt_ void *pThis)
	{
		if (pThunk == NULL)
		{
			pThunk = new _stdcallthunk;
			if (pThunk == NULL)
			{
				return FALSE;
			}
		}
		return pThunk->Init(proc, pThis);
	}


	void* GetCodeAddress()
	{
		return pThunk->GetCodeAddress();
	}
};

#pragma pack(pop)
typedef CDynamicStdCallThunk CStdCallThunk;
#else
typedef _stdcallthunk CStdCallThunk;
#endif  // _M_IX86 || _M_AMD64

}   // namespace ATL


#pragma pop_macro("new")

#endif // __ATLSTDTHUNK_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\include\atlsync.inl ===
// This is a part of the Active Template Library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Active Template Library Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Active Template Library product.

#ifndef __ATLSYNC_INL__
#define __ATLSYNC_INL__

#pragma once

#ifndef __ATLSYNC_H__
	#error atlsync.inl requires atlsync.h to be included first
#endif

namespace ATL
{

inline CCriticalSection::CCriticalSection()
{
	if (!::InitializeCriticalSectionAndSpinCount( this, 0 ))
	{
		AtlThrow(HRESULT_FROM_WIN32(GetLastError()));
	}
}

inline CCriticalSection::CCriticalSection(_In_ ULONG nSpinCount)
{
	if (!::InitializeCriticalSectionAndSpinCount( this, nSpinCount ))
	{
		AtlThrow(HRESULT_FROM_WIN32(GetLastError()));
	}
}

inline CCriticalSection::~CCriticalSection() throw()
{
	::DeleteCriticalSection( this );
}

inline void CCriticalSection::Enter()
{
	::EnterCriticalSection( this );
}

inline void CCriticalSection::Leave() throw()
{
	::LeaveCriticalSection( this );
}

inline ULONG CCriticalSection::SetSpinCount(_In_ ULONG nSpinCount) throw()
{
	return( ::SetCriticalSectionSpinCount( this, nSpinCount ) );
}

inline BOOL CCriticalSection::TryEnter() throw()
{
	return( ::TryEnterCriticalSection( this ) );
}

inline CEvent::CEvent() throw()
{
}

inline CEvent::CEvent(_Inout_ CEvent& hEvent) throw() :
	CHandle( hEvent )
{
}

inline CEvent::CEvent(
	_In_ BOOL bManualReset,
	_In_ BOOL bInitialState)
{
	BOOL bSuccess;

	bSuccess = Create( NULL, bManualReset, bInitialState, NULL );
	if( !bSuccess )
	{
		AtlThrowLastWin32();
	}
}

inline CEvent::CEvent(
	_In_opt_ LPSECURITY_ATTRIBUTES pAttributes,
	_In_ BOOL bManualReset,
	_In_ BOOL bInitialState,
	_In_opt_z_ LPCTSTR pszName)
{
	BOOL bSuccess;

	bSuccess = Create( pAttributes, bManualReset, bInitialState, pszName );
	if( !bSuccess )
	{
		AtlThrowLastWin32();
	}
}


inline CEvent::CEvent(_In_ HANDLE h) throw() :
	CHandle( h )
{
}

inline BOOL CEvent::Create(
	_In_opt_ LPSECURITY_ATTRIBUTES pSecurity,
	_In_ BOOL bManualReset,
	_In_ BOOL bInitialState,
	_In_opt_z_ LPCTSTR pszName) throw()
{
	ATLASSUME( m_h == NULL );

	m_h = ::CreateEvent( pSecurity, bManualReset, bInitialState, pszName );

	return( m_h != NULL );
}

inline BOOL CEvent::Open(
	_In_ DWORD dwAccess,
	_In_ BOOL bInheritHandle,
	_In_z_ LPCTSTR pszName) throw()
{
	ATLASSUME( m_h == NULL );

	m_h = ::OpenEvent( dwAccess, bInheritHandle, pszName );
	return( m_h != NULL );
}

inline BOOL CEvent::Pulse() throw()
{
	ATLASSUME( m_h != NULL );

	return( ::PulseEvent( m_h ) );
}

inline BOOL CEvent::Reset() throw()
{
	ATLASSUME( m_h != NULL );

	return( ::ResetEvent( m_h ) );
}

inline BOOL CEvent::Set() throw()
{
	ATLASSUME( m_h != NULL );

	return( ::SetEvent( m_h ) );
}


inline CMutex::CMutex() throw()
{
}

inline CMutex::CMutex(_Inout_ CMutex& hMutex) throw() :
	CHandle( hMutex )
{
}

inline CMutex::CMutex(_In_ BOOL bInitialOwner)
{
	BOOL bSuccess;

	bSuccess = Create( NULL, bInitialOwner, NULL );
	if( !bSuccess )
	{
		AtlThrowLastWin32();
	}
}

inline CMutex::CMutex(
	_In_opt_ LPSECURITY_ATTRIBUTES pSecurity,
	_In_ BOOL bInitialOwner,
	_In_opt_z_ LPCTSTR pszName)
{
	BOOL bSuccess;

	bSuccess = Create( pSecurity, bInitialOwner, pszName );
	if( !bSuccess )
	{
		AtlThrowLastWin32();
	}
}

inline CMutex::CMutex(_In_ HANDLE h) throw() :
	CHandle( h )
{
}

inline BOOL CMutex::Create(
	_In_opt_ LPSECURITY_ATTRIBUTES pSecurity,
	_In_ BOOL bInitialOwner,
	_In_opt_z_ LPCTSTR pszName) throw()
{
	ATLASSUME( m_h == NULL );

	m_h = ::CreateMutex( pSecurity, bInitialOwner, pszName );
	return( m_h != NULL );
}

inline BOOL CMutex::Open(
	_In_ DWORD dwAccess,
	_In_ BOOL bInheritHandle,
	_In_z_ LPCTSTR pszName) throw()
{
	ATLASSUME( m_h == NULL );

	m_h = ::OpenMutex( dwAccess, bInheritHandle, pszName );
	return( m_h != NULL );
}

inline BOOL CMutex::Release() throw()
{
	ATLASSUME( m_h != NULL );

	return( ::ReleaseMutex( m_h ) );
}

inline CSemaphore::CSemaphore() throw()
{
}

inline CSemaphore::CSemaphore(_Inout_ CSemaphore& hSemaphore) throw() :
	CHandle( hSemaphore )
{
}

inline CSemaphore::CSemaphore(
	_In_ LONG nInitialCount,
	_In_ LONG nMaxCount)
{
	BOOL bSuccess = Create( NULL, nInitialCount, nMaxCount, NULL );
	if( !bSuccess )
	{
		AtlThrowLastWin32();
	}
}

inline CSemaphore::CSemaphore(
	_In_opt_ LPSECURITY_ATTRIBUTES pSecurity,
	_In_ LONG nInitialCount,
	_In_ LONG nMaxCount,
	_In_opt_z_ LPCTSTR pszName)
{
	BOOL bSuccess;

	bSuccess = Create( pSecurity, nInitialCount, nMaxCount, pszName );
	if( !bSuccess )
	{
		AtlThrowLastWin32();
	}
}

inline CSemaphore::CSemaphore(_In_ HANDLE h) throw() :
	CHandle( h )
{
}

inline BOOL CSemaphore::Create(
	_In_opt_ LPSECURITY_ATTRIBUTES pSecurity,
	_In_ LONG nInitialCount,
	_In_ LONG nMaxCount,
	_In_opt_z_ LPCTSTR pszName) throw()
{
	ATLASSUME( m_h == NULL );

	m_h = ::CreateSemaphore( pSecurity, nInitialCount, nMaxCount, pszName );
	return( m_h != NULL );
}

inline BOOL CSemaphore::Open(
	_In_ DWORD dwAccess,
	_In_ BOOL bInheritHandle,
	_In_z_ LPCTSTR pszName) throw()
{
	ATLASSUME( m_h == NULL );

	m_h = ::OpenSemaphore( dwAccess, bInheritHandle, pszName );
	return( m_h != NULL );
}

inline BOOL CSemaphore::Release(
	_In_ LONG nReleaseCount,
	_Out_opt_ LONG* pnOldCount) throw()
{
	ATLASSUME( m_h != NULL );

	return( ::ReleaseSemaphore( m_h, nReleaseCount, pnOldCount ) );
}


inline CMutexLock::CMutexLock(
		_Inout_ CMutex& mtx,
		_In_ bool bInitialLock) :
	m_mtx( mtx ),
	m_bLocked( false )
{
	if( bInitialLock )
	{
		Lock();
	}
}

inline CMutexLock::~CMutexLock() throw()
{
	if( m_bLocked )
	{
		Unlock();
	}
}

inline void CMutexLock::Lock()
{
	DWORD dwResult;

	ATLASSERT( !m_bLocked );
	dwResult = ::WaitForSingleObject( m_mtx, INFINITE );
	if( dwResult == WAIT_ABANDONED )
	{
		ATLTRACE(atlTraceSync, 0, _T("Warning: abandoned mutex 0x%x\n"), 
			reinterpret_cast<int>(static_cast<HANDLE>(m_mtx)));
	}
	m_bLocked = true;
}

inline void CMutexLock::Unlock() throw()
{
	ATLASSUME( m_bLocked );

	m_mtx.Release();
	//ATLASSERT in CMutexLock::Lock prevents calling Lock more than 1 time.
	m_bLocked = false;
}

};  // namespace ATL

#endif  // __ATLSYNC_INL__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\include\atlsync.h ===
// This is a part of the Active Template Library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Active Template Library Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Active Template Library product.


#ifndef __ATLSYNC_H__
#define __ATLSYNC_H__

#pragma once

#ifndef _ATL_NO_PRAGMA_WARNINGS
#pragma warning(push)
#pragma warning(disable: 4512)  // assignment operator could not be generated
#endif  // !_ATL_NO_PRAGMA_WARNINGS

#include <atlbase.h>

#pragma pack(push,_ATL_PACKING)

namespace ATL
{

class CCriticalSection :
	public CRITICAL_SECTION
{
public:
	CCriticalSection();
	explicit CCriticalSection(_In_ ULONG nSpinCount);

	~CCriticalSection() throw();

	// Acquire the critical section
	void Enter();
	// Release the critical section
	void Leave() throw();
	// Set the spin count for the critical section
	ULONG SetSpinCount(_In_ ULONG nSpinCount) throw();
	// Attempt to acquire the critical section
	BOOL TryEnter() throw();
};

class CEvent :
	public CHandle
{
public:
	CEvent() throw();
	CEvent(_Inout_ CEvent& h) throw();
	CEvent(
		_In_ BOOL bManualReset,
		_In_ BOOL bInitialState);
	CEvent(
		_In_opt_ LPSECURITY_ATTRIBUTES pSecurity,
		_In_ BOOL bManualReset,
		_In_ BOOL bInitialState,
		_In_opt_z_ LPCTSTR pszName);
	explicit CEvent(_In_ HANDLE h) throw();

	// Create a new event
	BOOL Create(
		_In_opt_ LPSECURITY_ATTRIBUTES pSecurity,
		_In_ BOOL bManualReset,
		_In_ BOOL bInitialState,
		_In_opt_z_ LPCTSTR pszName) throw();
	// Open an existing named event
	BOOL Open(
		_In_ DWORD dwAccess,
		_In_ BOOL bInheritHandle,
		_In_z_ LPCTSTR pszName) throw();
	// Pulse the event (signals waiting objects, then resets)
	BOOL Pulse() throw();
	// Set the event to the non-signaled state
	BOOL Reset() throw();
	// Set the event to the signaled state
	BOOL Set() throw();
};

class CMutex :
	public CHandle
{
public:
	CMutex() throw();
	CMutex(_Inout_ CMutex& h) throw();
	explicit CMutex(_In_ BOOL bInitialOwner);
	CMutex(
		_In_opt_ LPSECURITY_ATTRIBUTES pSecurity,
		_In_ BOOL bInitialOwner,
		_In_opt_z_ LPCTSTR pszName);
	explicit CMutex(_In_ HANDLE h) throw();

	// Create a new mutex
	BOOL Create(
		_In_opt_ LPSECURITY_ATTRIBUTES pSecurity,
		_In_ BOOL bInitialOwner,
		_In_opt_z_ LPCTSTR pszName) throw();
	// Open an existing named mutex
	BOOL Open(
		_In_ DWORD dwAccess,
		_In_ BOOL bInheritHandle,
		_In_z_ LPCTSTR pszName) throw();
	// Release ownership of the mutex
	BOOL Release() throw();
};

class CSemaphore :
	public CHandle
{
public:
	CSemaphore() throw();
	CSemaphore(_Inout_ CSemaphore& h) throw();
	CSemaphore(
		_In_ LONG nInitialCount,
		_In_ LONG nMaxCount);
	CSemaphore(
		_In_opt_ LPSECURITY_ATTRIBUTES pSecurity,
		_In_ LONG nInitialCount,
		_In_ LONG nMaxCount,
		_In_opt_z_ LPCTSTR pszName );
	explicit CSemaphore(_In_ HANDLE h) throw();

	// Create a new semaphore
	BOOL Create(
		_In_opt_ LPSECURITY_ATTRIBUTES pSecurity,
		_In_ LONG nInitialCount,
		_In_ LONG nMaxCount,
		_In_opt_z_ LPCTSTR pszName) throw();
	// Open an existing named semaphore
	BOOL Open(
		_In_ DWORD dwAccess,
		_In_ BOOL bInheritHandle,
		_In_z_ LPCTSTR pszName) throw();
	// Increase the count of the semaphore
	BOOL Release(
		_In_ LONG nReleaseCount = 1,
		_Out_opt_ LONG* pnOldCount = NULL) throw();
};

class CMutexLock
{
public:
	CMutexLock(
		_Inout_ CMutex& mtx,
		_In_ bool bInitialLock = true);
	~CMutexLock() throw();

	void Lock();
	void Unlock() throw();

// Implementation
private:
	CMutex& m_mtx;
	bool m_bLocked;

// Private to prevent accidental use
	CMutexLock(_In_ const CMutexLock&) throw();
	CMutexLock& operator=(_In_ const CMutexLock&) throw();
};

};  // namespace ATL


#include <atlsync.inl>

#pragma pack(pop)
#ifndef _ATL_NO_PRAGMA_WARNINGS
#pragma warning(pop)
#endif  // !_ATL_NO_PRAGMA_WARNINGS

#endif  // __ATLSYNC_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\include\atlstr.h ===
// This is a part of the Active Template Library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Active Template Library Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Active Template Library product.
#ifndef __ATLSTR_H__
#define __ATLSTR_H__

#pragma once

#ifndef __cplusplus
	#error ATL requires C++ compilation (use a .cpp suffix)
#endif

#include <atlbase.h>
#include <winnls.h>
#include <limits.h>
#include <cstringt.h>

#pragma pack(push,_ATL_PACKING)

namespace ATL
{

class CAtlStringMgr :
	public IAtlStringMgr
{
public:
	CAtlStringMgr(_In_opt_ IAtlMemMgr* pMemMgr = NULL) throw() :
		m_pMemMgr( pMemMgr )
	{
		m_nil.SetManager( this );
	}
	virtual ~CAtlStringMgr() throw()
	{
	}

	void SetMemoryManager(_In_ IAtlMemMgr* pMemMgr) throw()
	{
		ATLASSUME( m_pMemMgr == NULL );
		m_pMemMgr = pMemMgr;
	}

// IAtlStringMgr
public:
	_Ret_opt_bytecap_x_(sizeof(CStringData) + nChars*nCharSize) virtual CStringData* Allocate(
		_In_ int nChars,
		_In_ int nCharSize) throw()
	{
		size_t nTotalSize;
		CStringData* pData;
		size_t nDataBytes;

		nChars = AtlAlignUp( nChars + 1, 8 );  // Prevent excessive reallocation.  The heap will usually round up anyway.

		if(	FAILED(::ATL::AtlMultiply(&nDataBytes, static_cast<size_t>(nChars), static_cast<size_t>(nCharSize))) ||
			FAILED(::ATL::AtlAdd(&nTotalSize, static_cast<size_t>(sizeof( CStringData )), nDataBytes)))
		{
			return NULL;
		}
		pData = static_cast< CStringData* >( m_pMemMgr->Allocate( nTotalSize ) );
		if( pData == NULL )
		{
			return( NULL );
		}
		pData->pStringMgr = this;
		pData->nRefs = 1;
		pData->nAllocLength = nChars - 1;
		pData->nDataLength = 0;

		return( pData );
	}
	virtual void Free(_In_ CStringData* pData) throw()
	{		
		ATLASSUME(pData != NULL);
		ATLASSERT(pData->pStringMgr == this);
			
		m_pMemMgr->Free( pData );
	}
	_Ret_opt_bytecap_x_(sizeof(CStringData) + nChars*nCharSize) virtual CStringData* Reallocate(
		_Inout_ _Post_bytecount_x_(sizeof(CStringData)) CStringData* pData,
		_In_ int nChars,
		_In_ int nCharSize) throw()
	{
		CStringData* pNewData;
		ULONG nTotalSize;
		ULONG nDataBytes;

		ATLASSERT( pData->pStringMgr == this );
		nChars = AtlAlignUp( nChars+1, 8 );  // Prevent excessive reallocation.  The heap will usually round up anyway.

		if(	FAILED(::ATL::AtlMultiply(&nDataBytes, static_cast<ULONG>(nChars), static_cast<ULONG>(nCharSize))) ||
			FAILED(::ATL::AtlAdd(&nTotalSize, static_cast<ULONG>(sizeof( CStringData )), nDataBytes)))
		{
			return NULL;
		}
		pNewData = static_cast< CStringData* >( m_pMemMgr->Reallocate( pData, nTotalSize ) );
		if( pNewData == NULL )
		{
			return NULL;
		}
		pNewData->nAllocLength = nChars - 1;

		return pNewData;
	}
	virtual CStringData* GetNilString() throw()
	{
		m_nil.AddRef();
		return &m_nil;
	}
	virtual IAtlStringMgr* Clone() throw()
	{
		return this;
	}

protected:
	IAtlMemMgr* m_pMemMgr;
	CNilStringData m_nil;
};

extern CAtlStringMgr g_strmgr;

template <class ChTraits>
inline typename ChTraits::PCXSTR strstrT(typename ChTraits::PCXSTR pStr,typename ChTraits::PCXSTR pCharSet);

template< typename _CharType = char >
class ChTraitsOS :
	public ChTraitsBase< _CharType >
{
public:
	static int tclen(_In_z_ LPCSTR p) throw()
	{
		ATLASSERT(p != NULL);
		LPCSTR pnext = CharNext(p);
		return ((pnext-p)>1) ? 2 : 1;
	}
	_Ret_opt_z_ static LPCSTR strchr(
		_In_z_ LPCSTR p,
		_In_ char ch) throw()
	{
		return AtlstrchrT(p,ch);
	}
	_Ret_opt_z_ static LPCSTR strchr_db(
		_In_z_ LPCSTR p,
		_In_ char ch1,
		_In_ char ch2) throw()
	{
		ATLASSERT(p != NULL);
		while (*p != 0)
		{
			if (*p == ch1 && *(p+1) == ch2)
			{
				return p;
			}
			p = CharNext(p);
		}
		return NULL;
	}
	_Ret_opt_z_ static LPCSTR strrchr(
		_In_z_ LPCSTR p,
		_In_ char ch) throw()
	{
		ATLASSERT(p != NULL);
		const _CharType* pch = NULL;
		while (*p != 0)
		{
			if (*p == ch)
			{
				pch = p;
			}
			p = CharNext(p);
		}
		//for strrchr(buff,'\0')
		if (*p == ch)
		{
			pch = p;
		}
		return const_cast< _CharType* >( pch );
	}
	static _CharType* _strrev(_Inout_opt_z_ _CharType* psz) throw()
	{
		// Optimize NULL, zero-length, and single-char case.
		if ((psz == NULL) || (psz[0] == '\0') || (psz[1] == '\0'))
			return psz;

		_CharType* p = psz;
		// first go through and reverse the bytes in MBCS chars
		while (*p != _T('\0'))
		{
			if (IsDBCSLeadByte(*p++))
			{
				if (*p)
				{
					_CharType c = *p;
					*p=*(p-1);
					*(p-1)=c;
					p++;

				} else
				{
				        //  second byte is EOS
                        //There is nothing really satisfying to do here. We have a string
                        //that ends in leadbyte,'\0'. Reversing this would lead to the leadbyte
                        //becoming falsely attached to the character before it:
                        //(XL0 -> LX0, X has suddenly become a trailbyte)

                        //So what we choose to do is assert and purge the dud byte from within the
                        //string.

                    ATLASSERT(FALSE && _T("Bad MBCS string passed into __strev"));

                    // String has at least moved once already, so this is safe
                    ATLASSERT(p>psz);

                    // move back one to point at the dud leadbyte
                    --p;

                    // now truncate the string one byte earlier
                    *p='\0';

				}
			}


		} //end while

		_CharType* q = psz;
		--p;
		while (q < p)
		{
			_CharType t = *q;
			*q = *p;
			*p = t;
			q++;
			p--;
		}
		return psz;
	}
	_Ret_opt_z_ static LPCSTR strstr(
		_In_z_ LPCSTR pStr,
		_In_z_ LPCSTR pCharSet) throw()
	{
		return strstrT< ChTraitsOS<XCHAR> >(pStr,pCharSet);
	}
	static int strspn(
		_In_z_ const _CharType* pStr,
		_In_z_ const _CharType* pCharSet) throw()
	{
		ATLASSERT(pStr != NULL);
		int nRet = 0;
		_CharType* p = const_cast<_CharType*>(pStr);
		while (*p != 0)
		{
			_CharType* pNext = CharNext(p);
			if(pNext > p + 1)
			{
				if(strchr_db(pCharSet, *p, *(p+1)) == NULL)
					break;
				nRet += 2;
			}
			else
			{
				if(strchr(pCharSet, *p) == NULL)
					break;
				nRet++;
			}
			p = pNext;
		}
		return nRet;
	}
	static int strcspn(
		_In_z_ const _CharType* pStr,
		_In_z_ const _CharType* pCharSet) throw()
	{
		ATLASSERT(pStr != NULL);
		int nRet = 0;
		_CharType* p = const_cast<_CharType*>(pStr);
		while (*p != 0)
		{
			_CharType* pNext = CharNext(p);
			if(pNext > p + 1)
			{
				if(strchr_db(pCharSet, *p, *(p+1)) != NULL)
					break;
				nRet += 2;
			}
			else
			{
				if(strchr(pCharSet, *p) != NULL)
					break;
				nRet++;
			}
			p = pNext;
		}
		return nRet;
	}
	_Ret_opt_z_ static LPCSTR strpbrk(
		_In_z_ LPCSTR p,
		_In_z_ LPCSTR lpszCharSet) throw()
	{
		int nRet=0;
		nRet=strcspn(p,lpszCharSet);
		if (p[nRet]){
			p+=nRet;
			return p;
		}
		return NULL;
	}

	static _CharType* CharNext(_In_ const _CharType* p) throw()
	{
		return AtlCharNext(p);
	}

	static int IsDigit(_In_ _CharType ch) throw()
	{
		WORD type;
		GetStringTypeExA(GetThreadLocale(), CT_CTYPE1, &ch, 1, &type);
		return (type & C1_DIGIT) == C1_DIGIT;
	}

	static int IsSpace(_In_ _CharType ch) throw()
	{
		WORD type;
		GetStringTypeExA(GetThreadLocale(), CT_CTYPE1, &ch, 1, &type);
		return (type & C1_SPACE) == C1_SPACE;
	}

	static int StringCompare(
		_In_z_ const _CharType* pstrOne,
		_In_z_ const _CharType* pstrOther) throw()
	{
		return lstrcmpA((LPCSTR) pstrOne, (LPCSTR) pstrOther);
	}

	static int StringCompareIgnore(
		_In_z_ const _CharType* pstrOne,
		_In_z_ const _CharType* pstrOther) throw()
	{
		return lstrcmpiA((LPCSTR) pstrOne, (LPCSTR) pstrOther);
	}

	static int StringCollate(
		_In_z_ const _CharType* pstrOne,
		_In_z_ const _CharType* pstrOther) throw()
	{
		int nRet = CompareStringA(GetThreadLocale(), 0, (LPCSTR)pstrOne, -1,
			(LPCSTR)pstrOther, -1);
		ATLASSERT(nRet != 0);
		return nRet-2;  // Convert to strcmp convention.  This really is documented.
	}

	static int StringCollateIgnore(
		_In_z_ const _CharType* pstrOne,
		_In_z_ const _CharType* pstrOther) throw()
	{
		int nRet = CompareStringA(GetThreadLocale(), NORM_IGNORECASE, (LPCSTR)pstrOne, -1,
			(LPCSTR)pstrOther, -1);
		ATLASSERT(nRet != 0);
		return nRet-2;  // Convert to strcmp convention.  This really is documented.
	}

	_Ret_opt_z_ static LPCSTR StringFindString(
		_In_z_ LPCSTR pstrBlock,
		_In_z_ LPCSTR pstrMatch) throw()
	{
		return strstr(pstrBlock, pstrMatch);
	}

	_Ret_opt_z_ static LPSTR StringFindString(
		_In_z_ LPSTR pszBlock,
		_In_z_ LPCSTR pszMatch) throw()
	{
		return( const_cast< LPSTR >( StringFindString( const_cast< LPCSTR >( pszBlock ), pszMatch ) ) );
	}

	_Ret_opt_z_ static LPCSTR StringFindChar(
		_In_z_ LPCSTR pszBlock,
		_In_ char chMatch) throw()
	{
		return strchr(pszBlock, chMatch);
	}

	_Ret_opt_z_ static LPCSTR StringFindCharRev(
		_In_z_ LPCSTR psz,
		_In_ char ch) throw()
	{
		return strrchr(psz, ch);
	}

	_Ret_opt_z_ static LPCSTR StringScanSet(
		_In_z_ LPCSTR pszBlock,
		_In_z_ LPCSTR pszMatch) throw()
	{
		return strpbrk(pszBlock, pszMatch);
	}

	static int StringSpanIncluding(
		_In_z_ const _CharType* pstrBlock,
		_In_z_ const _CharType* pstrSet) throw()
	{
		return strspn(pstrBlock, pstrSet);
	}

	static int StringSpanExcluding(
		_In_z_ const _CharType* pstrBlock,
		_In_z_ const _CharType* pstrSet) throw()
	{
		return strcspn(pstrBlock, pstrSet);
	}

	_ATL_INSECURE_DEPRECATE("ChTraitsOS::StringUppercase must be passed a buffer size")
	static _CharType* StringUppercase(_Inout_z_ _CharType* psz) throw()
	{
		return CharUpperA( psz );
	}

	_ATL_INSECURE_DEPRECATE("ChTraitsOS::StringLowercase must be passed a buffer size")
	static _CharType* StringLowercase(_Inout_z_ _CharType* psz) throw()
	{
		return CharLowerA( psz );
	}

	static _CharType* StringUppercase(
		_Inout_z_cap_(size) _CharType* psz,
		_In_ size_t size) throw()
	{
		if(size>UINT_MAX)
		{
			// API only allows DWORD size
			AtlThrow(E_INVALIDARG);
		}
		DWORD dwSize=static_cast<DWORD>(size);
		CharUpperBuffA( psz, dwSize );
		return psz;
	}

	static _CharType* StringLowercase(
		_Inout_z_cap_(size) _CharType* psz,
		_In_ size_t size) throw()
	{
		if(size>UINT_MAX)
		{
			// API only allows DWORD size
			AtlThrow(E_INVALIDARG);
		}
		DWORD dwSize=static_cast<DWORD>(size);
		CharLowerBuffA( psz, dwSize );
		return psz;
	}

	static _CharType* StringReverse(_Inout_z_ _CharType* psz) throw()
	{
		return _strrev( psz );
	}

	static int GetFormattedLength(
		_In_z_ _Printf_format_string_ const _CharType* pszFormat, 
		_In_ va_list args)
	{
		_CharType szBuffer[1028];
		int nLength = 0;

		SetLastError(ERROR_SUCCESS);
#pragma warning(push)
#pragma warning(disable:4995)
#pragma warning(disable:4996)
		// wvsprintf always truncates the output to 1024 character plus the '\0'.
		// Note that we are using wvsprintf only in the MIN_CRT case; wvsprintf is
		// an insecure function and should be avoided. Here the use of wvsprintf
		// is safe and the only way to get a string formatted without using the CRT.
		nLength = wvsprintfA(szBuffer, pszFormat, args);
#pragma warning(pop)
		ATLENSURE(GetLastError() == ERROR_SUCCESS);
		ATLASSERT(nLength >= 0);
		ATLASSERT(nLength <= 1024);

		return nLength;
	}

	_ATL_INSECURE_DEPRECATE("CSimpleStringT::Format must be passed a buffer size")
	static int Format(
		_Out_ _Post_z_count_(return) _CharType* pszBuffer,
		_In_z_ _Printf_format_string_ const _CharType* pszFormat,
		_In_ va_list args) throw()
	{
#pragma warning(push)
#pragma warning(disable:4995)
#pragma warning(disable:4996)
		return wvsprintfA(pszBuffer, pszFormat, args);
#pragma warning(pop)
	}
	static int Format(
		_Out_z_cap_post_count_(nlength, return) _CharType*  pszBuffer,
		_In_ size_t nlength,
		_In_z_ _Printf_format_string_ const _CharType* pszFormat, 
		_In_ va_list args )
	{
		_CharType buffSafe[1030]; //wvsprintf output is max 1024.
		int nCharsWritten = 0;

		SetLastError(ERROR_SUCCESS);
#pragma warning(push)
#pragma warning(disable:4995)
#pragma warning(disable:4996)
		// wvsprintf always truncates the output to 1024 character plus the '\0'.
		// Note that we are using wvsprintf only in the MIN_CRT case; wvsprintf is
		// an insecure function and should be avoided. Here the use of wvsprintf
		// is safe and the only way to get a string formatted without using the CRT.
		nCharsWritten = wvsprintfA(buffSafe, pszFormat, args);
#pragma warning(pop)
		ATLENSURE(GetLastError() == ERROR_SUCCESS);
		ATLENSURE(nCharsWritten <= 1024);
		//nlength should have room for nCharsWritten + NULL
		ATLENSURE_THROW((size_t)nCharsWritten < nlength ,E_INVALIDARG);
		Checked::strcpy_s(pszBuffer,nlength,buffSafe);
		return nCharsWritten;
	}

	static int GetBaseTypeLength(_In_z_ const char* pszSrc) throw()
	{
		// Returns required buffer length in XCHARs
		return lstrlenA(pszSrc);
	}

	static int GetBaseTypeLength(
		_In_z_ const char* pszSrc,
		_In_ int nLength) throw()
	{
		(void)pszSrc;
		// Returns required buffer length in XCHARs
		return nLength;
	}

	static int GetBaseTypeLength(_In_z_ const wchar_t* pszSrc) throw()
	{
		// Returns required buffer length in XCHARs
		return ::WideCharToMultiByte(_AtlGetConversionACP(), 0, pszSrc, -1, NULL, 0, NULL, NULL)-1;
	}

	static int GetBaseTypeLength(
		_In_count_(nLength) const wchar_t* pszSrc,
		_In_ int nLength) throw()
	{
		// Returns required buffer length in XCHARs
		return ::WideCharToMultiByte(_AtlGetConversionACP(), 0, pszSrc, nLength, NULL, 0, NULL, NULL);
	}

	static void ConvertToBaseType(
		_Out_cap_(nDestLength) _CharType* pszDest,
		_In_ int nDestLength,
		_In_count_(nSrcLength) const char* pszSrc,
		_In_ int nSrcLength = -1) throw()
	{
		if (nSrcLength == -1) { nSrcLength=1 + GetBaseTypeLength(pszSrc); }
		// nLen is in chars
		Checked::memcpy_s(pszDest, nDestLength*sizeof(_CharType),
			pszSrc, nSrcLength*sizeof(_CharType));
	}

	static void ConvertToBaseType(
		_Out_cap_(nDestLength) _CharType* pszDest,
		_In_ int nDestLength,
		_In_count_(nSrcLength) const wchar_t* pszSrc,
		_In_ int nSrcLength = -1) throw()
	{
		// nLen is in XCHARs
		::WideCharToMultiByte(_AtlGetConversionACP(), 0, pszSrc, nSrcLength, pszDest, nDestLength, NULL, NULL);
	}

	_ATL_INSECURE_DEPRECATE("ChTraitsOS::ConvertToOem must be passed a buffer size")
	static void ConvertToOem(_Inout_z_ _CharType* pstrString) throw()
	{
		BOOL fSuccess=::CharToOemA(pstrString, pstrString);
		// old version can't report error
		ATLASSERT(fSuccess);
	}

	_ATL_INSECURE_DEPRECATE("ChTraitsOS::ConvertToAnsi must be passed a buffer size")
	static void ConvertToAnsi(_Inout_z_ _CharType* pstrString) throw()
	{
		BOOL fSuccess=::OemToCharA(pstrString, pstrString);
		// old version can't report error
		ATLASSERT(fSuccess);
	}

	static void ConvertToOem(
		_Out_z_cap_(size) _CharType* pstrString,
		_In_ size_t size)
	{
		if(size>UINT_MAX)
		{
			// API only allows DWORD size
			AtlThrow(E_INVALIDARG);
		}
		DWORD dwSize=static_cast<DWORD>(size);
		BOOL fSuccess=::CharToOemBuffA(pstrString, pstrString, dwSize);
		if(!fSuccess)
		{
			AtlThrowLastWin32();
		}
	}

	static void ConvertToAnsi(
		_Out_z_cap_(size) _CharType* pstrString,
		_In_ size_t size)
	{
		if(size>UINT_MAX)
		{
			// API only allows DWORD size
			AtlThrow(E_INVALIDARG);
		}
		DWORD dwSize=static_cast<DWORD>(size);
		BOOL fSuccess=::OemToCharBuffA(pstrString, pstrString, dwSize);
		if(!fSuccess)
		{
			AtlThrowLastWin32();
		}
	}

	static void FloodCharacters(
		_In_ _CharType ch,
		_In_ int nLength,
		_Out_bytecapcount_(nLength) _CharType* pstr) throw()
	{
		// nLength is in XCHARs
		memset(pstr, ch, nLength);
	}

	_Ret_z_ static BSTR AllocSysString(
		_In_count_(nDataLength) const _CharType* pchData,
		_In_ int nDataLength) throw()
	{
		int nLen = MultiByteToWideChar(_AtlGetConversionACP(), 0, pchData, nDataLength,
			NULL, NULL);
		BSTR bstr = ::SysAllocStringLen(NULL, nLen);
		if (bstr != NULL)
		{
			MultiByteToWideChar(_AtlGetConversionACP(), 0, pchData, nDataLength, bstr, nLen);
		}

		return bstr;
	}

	static BOOL ReAllocSysString(
		_In_bytecount_(nDataLength) const _CharType* pchData,
		_Inout_ _Deref_post_opt_valid_ BSTR* pbstr,
		_In_ int nDataLength) throw()
	{
		int nLen = MultiByteToWideChar(_AtlGetConversionACP(), 0, pchData,
			nDataLength, NULL, NULL);
		BOOL bSuccess =::SysReAllocStringLen(pbstr, NULL, nLen);
		if (bSuccess)
		{
			MultiByteToWideChar(_AtlGetConversionACP(), 0, pchData, nDataLength,
				*pbstr, nLen);
		}

		return bSuccess;
	}

	static DWORD FormatMessage(
		_In_ DWORD dwFlags,
		_In_ LPCVOID lpSource,
		_In_ DWORD dwMessageID,
		_In_ DWORD dwLanguageID,
		_Out_z_cap_(nSize) char* pstrBuffer,
		_In_ DWORD nSize,
		_In_opt_ va_list* pArguments) throw()
	{
		return ::FormatMessageA(dwFlags, lpSource, dwMessageID, dwLanguageID,
				pstrBuffer, nSize, pArguments);
	}

	static int SafeStringLen(_In_opt_z_ const char* psz) throw()
	{
		// returns length in bytes
		return (psz != NULL) ? lstrlenA(psz) : 0;
	}

	static int SafeStringLen(_In_opt_z_ const wchar_t* psz) throw()
	{
		// returns length in wchar_ts
		return (psz != NULL) ? lstrlenW(psz) : 0;
	}

	static int GetCharLen(_In_opt_z_ const wchar_t*) throw()
	{
		// returns char length
		return 1;
	}
	static int GetCharLen(_In_z_ const char* psz) throw()
	{
		const char* p = ::CharNextA(psz);
		return (p - psz);
	}

	static DWORD GetEnvironmentVariable(
		_In_z_ const _CharType* pstrVar,
		_Out_opt_z_cap_(dwSize) _CharType* pstrBuffer,
		_In_ DWORD dwSize) throw()
	{
		return ::GetEnvironmentVariableA(pstrVar, pstrBuffer, dwSize);
	}
};

// specialization for wchar_t
template<>
class ChTraitsOS< wchar_t > :
	public ChTraitsBase< wchar_t >
{
protected:
	static int CompareStringW(
		_In_ LCID lcid,
		_In_ DWORD dwFlags,
		_In_count_(nLength1) LPCWSTR pszString1,
		_In_ int nLength1,
		_In_count_(nLength2) LPCWSTR pszString2,
		_In_ int nLength2)
	{
		return ::CompareStringW(lcid, dwFlags, pszString1, nLength1,
			pszString2, nLength2);
	}
	static BOOL GetStringTypeExW(
		_In_ LCID lcid,
		_In_ DWORD dwInfoType,
		_In_count_(nLength) LPCWSTR pszSrc,
		_In_ int nLength,
		_Out_ LPWORD pwCharType)
	{
		return ::GetStringTypeExW(lcid, dwInfoType, pszSrc, nLength, pwCharType);
	}
	static int lstrcmpiW(_In_z_ LPCWSTR psz1, _In_z_ LPCWSTR psz2)
	{
		return ::lstrcmpiW(psz1, psz2);
	}
	static LPWSTR CharLowerW(_Inout_z_ LPWSTR psz)
	{
		return ::CharLowerW(psz);
	}
	static LPWSTR CharUpperW(_Inout_z_ LPWSTR psz)
	{
		return ::CharUpperW(psz);
	}
	static DWORD _GetEnvironmentVariableW(
		_In_z_ LPCWSTR pszName,
		_Out_opt_z_cap_(nSize) LPWSTR pszBuffer,
		_In_ DWORD nSize)
	{
		return ::GetEnvironmentVariableW(pszName, pszBuffer, nSize);
	}

public:
	static int tclen(_In_opt_z_ const wchar_t*) throw()
	{
		return 1;
	}
	_Ret_opt_z_ static LPCWSTR strchr(
		_In_z_ LPCWSTR p,
		_In_ wchar_t ch) throw()
	{
		return AtlstrchrT(p,ch);
	}
	_Ret_opt_z_ static LPCWSTR strrchr(
		_In_z_ LPCWSTR p,
		_In_ wchar_t ch) throw()
	{
		const wchar_t* pch = p+lstrlenW(p);
		while ((pch != p) && (*pch != ch))
		{
			pch--;
		}
		if (*pch == ch)
		{
			return pch;
		}
		else
		{
			return NULL;
		}
	}
	_Ret_opt_z_ static wchar_t* _strrev(_Inout_opt_z_ wchar_t* psz) throw()
	{
		// Optimize NULL, zero-length, and single-char case.		
		ATLPREFAST_SUPPRESS(6385)
		if ((psz == NULL) || (psz[0] == L'\0') || (psz[1] == L'\0'))
			return psz;
		ATLPREFAST_UNSUPPRESS()

		wchar_t* p = psz+(lstrlenW( psz )-1);
		wchar_t* q = psz;
		while(q < p)
		{
			wchar_t t = *q;
			*q = *p;
			*p = t;
			q++;
			p--;
		}
		return psz;
	}
	_Ret_opt_z_ static LPCWSTR strstr(
		_In_z_ LPCWSTR pStr,
		_In_z_ LPCWSTR pCharSet) throw()
	{
		return strstrT< ChTraitsOS<XCHAR> >(pStr,pCharSet);
	}
	static int strspn(
		_In_z_ const wchar_t* psz,
		_In_z_ const wchar_t* pszCharSet) throw()
	{
		int nRet = 0;
		const wchar_t* p = psz;
		while (*p != 0)
		{
			if(strchr(pszCharSet, *p) == NULL)
				break;
			nRet++;
			p++;
		}
		return nRet;
	}
	static int strcspn(
		_In_z_ const wchar_t* psz,
		_In_z_ const wchar_t* pszCharSet) throw()
	{
		int nRet = 0;
		const wchar_t* p = psz;
		while (*p != 0)
		{
			if(strchr(pszCharSet, *p) != NULL)
				break;
			nRet++;
			p++;
		}
		return nRet;
	}
	_Ret_opt_z_ static LPCWSTR strpbrk(
		_In_z_ LPCWSTR psz,
		_In_z_ LPCWSTR pszCharSet) throw()
	{
		const wchar_t* p = psz;
		while (*p != 0)
		{
			if (strchr(pszCharSet, *p) != NULL)
				return p;
			p++;
		}
		return NULL;
	}

	static wchar_t* CharNext(_In_ const wchar_t* p) throw()
	{
		return AtlCharNext(p);
	}

	static int IsDigit(_In_ wchar_t ch) throw()
	{
		WORD type;
		GetStringTypeExW(0, CT_CTYPE1, &ch, 1, &type);
		return (type & C1_DIGIT) == C1_DIGIT;
	}

	static int IsSpace(_In_ wchar_t ch) throw()
	{
		WORD type;
		GetStringTypeExW(0, CT_CTYPE1, &ch, 1, &type);
		return (type & C1_SPACE) == C1_SPACE;
	}


	static int StringCompare(
		_In_z_ const wchar_t* pstrOne,
		_In_z_ const wchar_t* pstrOther) throw()
	{
		return wcscmp(pstrOne, pstrOther);
	}

	static int StringCompareIgnore(
		_In_z_ const wchar_t* pstrOne,
		_In_z_ const wchar_t* pstrOther) throw()
	{
		return lstrcmpiW(pstrOne, pstrOther);
	}

	static int StringCollate(
		_In_z_ const wchar_t* pstrOne,
		_In_z_ const wchar_t* pstrOther) throw()
	{
		int nRet;

		nRet = CompareStringW(GetThreadLocale(), 0, pstrOne, -1, pstrOther, -1);
		ATLASSERT(nRet != 0);
		return nRet-2;  // Convert to strcmp convention.  This really is documented.
	}

	static int StringCollateIgnore(
		_In_z_ const wchar_t* pstrOne,
		_In_z_ const wchar_t* pstrOther) throw()
	{
		int nRet = CompareStringW(GetThreadLocale(), NORM_IGNORECASE, pstrOne, -1, pstrOther, -1);
		ATLASSERT(nRet != 0);
		return nRet-2;  // Convert to strcmp convention.  This really is documented.
	}

	_Ret_opt_z_ static LPCWSTR StringFindString(
		_In_z_ LPCWSTR pstrBlock,
		_In_z_ LPCWSTR pstrMatch) throw()
	{
		return strstr(pstrBlock, pstrMatch);
	}

	_Ret_opt_z_ static LPWSTR StringFindString(
		_In_z_ LPWSTR pszBlock,
		_In_z_ LPCWSTR pszMatch) throw()
	{
		return( const_cast< LPWSTR >( StringFindString( const_cast< LPCWSTR >( pszBlock ), pszMatch ) ) );
	}

	_Ret_opt_z_ static LPCWSTR StringFindChar(
		_In_z_ LPCWSTR pstrBlock,
		_In_ wchar_t pstrMatch) throw()
	{
		return strchr(pstrBlock, pstrMatch);
	}

	_Ret_opt_z_ static LPCWSTR StringFindCharRev(
		_In_z_ LPCWSTR pstr,
		_In_ wchar_t ch) throw()
	{
		return strrchr(pstr, ch);
	}

	_Ret_opt_z_ static LPCWSTR StringScanSet(
		_In_z_ LPCWSTR pszBlock,
		_In_z_ LPCWSTR pszMatch) throw()
	{
		return strpbrk(pszBlock, pszMatch);
	}

	static int StringSpanIncluding(
		_In_z_ const wchar_t* pszBlock,
		_In_z_ const wchar_t* pszSet) throw()
	{
		return strspn(pszBlock, pszSet);
	}

	static int StringSpanExcluding(
		_In_z_ const wchar_t* pszBlock,
		_In_z_ const wchar_t* pszSet) throw()
	{
		return strcspn(pszBlock, pszSet);
	}

	_ATL_INSECURE_DEPRECATE("ChTraitsOS::StringUppercase must be passed a buffer size")
	static wchar_t* StringUppercase(_Inout_z_ wchar_t* psz) throw()
	{
		CharUpperW(psz);
		return psz;
	}

	_ATL_INSECURE_DEPRECATE("ChTraitsOS::StringUppercase must be passed a buffer size")
	static wchar_t* StringLowercase(_Inout_z_ wchar_t* psz) throw()
	{
		CharLowerW(psz);
		return psz;
	}

	_Ret_z_ static wchar_t* StringUppercase(
		_Inout_z_cap_(size) wchar_t* psz,
		_In_ size_t size) throw()
	{
		if(size>(UINT_MAX/sizeof(wchar_t)))
		{
			// API only allows DWORD size
			AtlThrow(E_INVALIDARG);
		}
		DWORD dwSize=static_cast<DWORD>(size);
		CharUpperBuffW(psz, dwSize);
		return psz;
	}

	_Ret_z_ static wchar_t* StringLowercase(
		_Inout_z_cap_(size) wchar_t* psz,
		_In_ size_t size) throw()
	{
		if(size>(UINT_MAX/sizeof(wchar_t)))
		{
			// API only allows DWORD size
			AtlThrow(E_INVALIDARG);
		}
		DWORD dwSize=static_cast<DWORD>(size);
		CharLowerBuffW(psz, dwSize);
		return psz;
	}

	_Ret_opt_z_ static wchar_t* StringReverse(_Inout_z_ wchar_t* psz) throw()
	{
		return _strrev(psz);
	}

	static int GetFormattedLength(
		_In_z_ _Printf_format_string_ const wchar_t* pszFormat, 
		_In_ va_list args)
	{
		wchar_t szBuffer[1028];
		int nLength = 0;

		SetLastError(ERROR_SUCCESS);
#pragma warning(push)
#pragma warning(disable:4995)
#pragma warning(disable:4996)
		// wvsprintf always truncates the output to 1024 character plus the '\0'.
		// Note that we are using wvsprintf only in the MIN_CRT case; wvsprintf is
		// an insecure function and should be avoided. Here the use of wvsprintf
		// is safe and the only way to get a string formatted without using the CRT.
		nLength = wvsprintfW(szBuffer, pszFormat, args);
#pragma warning(pop)
		ATLENSURE(GetLastError() == ERROR_SUCCESS);
		ATLASSERT(nLength >= 0);
		ATLASSERT(nLength <= 1024);

		return nLength;
	}

	_ATL_INSECURE_DEPRECATE("ChTraitsOS::Format must be passed a buffer size")
	static int Format(
		_Out_ _Post_z_ wchar_t* pszBuffer,
		_In_z_ _Printf_format_string_ const wchar_t* pszFormat,
		_In_ va_list args) throw()
	{
#pragma warning(push)
#pragma warning(disable:4995)
#pragma warning(disable:4996)
		return wvsprintfW(pszBuffer, pszFormat, args);
#pragma warning(pop)
	}

	static int Format(
		_Out_z_cap_(nLength) wchar_t* pszBuffer,
		_In_ size_t nLength,
		_In_z_ _Printf_format_string_ const wchar_t* pszFormat,
		_In_ va_list args)
	{
		wchar_t buffSafe[1028];
		int nCharsWritten = 0;

		SetLastError(ERROR_SUCCESS);
#pragma warning(push)
#pragma warning(disable:4995)
#pragma warning(disable:4996)
		// wvsprintf always truncates the output to 1024 character plus the '\0'.
		// Note that we are using wvsprintf only in the MIN_CRT case; wvsprintf is
		// an insecure function and should be avoided. Here the use of wvsprintf
		// is safe and the only way to get a string formatted without using the CRT.
		nCharsWritten = wvsprintfW(buffSafe, pszFormat, args);
#pragma warning(pop)
		ATLENSURE(GetLastError() == ERROR_SUCCESS);
		ATLENSURE(nCharsWritten <= 1024);
		//nlength should have room for nCharsWritten + NULL
		ATLENSURE_THROW((size_t)nCharsWritten < nLength ,E_INVALIDARG);
		ATLENSURE_THROW(wcslen(buffSafe) < nLength ,E_INVALIDARG);

ATLPREFAST_SUPPRESS(6386)
		/* prefast noise 497597 */
		Checked::wcscpy_s(pszBuffer,nLength,buffSafe);
ATLPREFAST_UNSUPPRESS()
	
		return nCharsWritten;
	}

	static int GetBaseTypeLength(_In_z_ const char* pszSrc) throw()
	{
		// Returns required buffer size in wchar_ts
		return ::MultiByteToWideChar(_AtlGetConversionACP(), 0, pszSrc, -1, NULL, 0)-1;
	}

	static int GetBaseTypeLength(
		_In_count_(nLength) const char* pszSrc,
		_In_ int nLength) throw()
	{
		// Returns required buffer size in wchar_ts
		return ::MultiByteToWideChar(_AtlGetConversionACP(), 0, pszSrc, nLength, NULL, 0);
	}

	static int GetBaseTypeLength(_In_z_ const wchar_t* pszSrc) throw()
	{
		// Returns required buffer size in wchar_ts
		return lstrlenW(pszSrc);
	}

	static int GetBaseTypeLength(
		_In_count_(nLength) const wchar_t* pszSrc,
		_In_ int nLength) throw()
	{
		(void)pszSrc;
		// Returns required buffer size in wchar_ts
		return nLength;
	}

	static void ConvertToBaseType(
		_Out_cap_(nDestLength) wchar_t* pszDest,
		_In_ int nDestLength,
		_In_count_(nSrcLength) const char* pszSrc,
		_In_ int nSrcLength = -1) throw()
	{
		// nLen is in wchar_ts
		::MultiByteToWideChar(_AtlGetConversionACP(), 0, pszSrc, nSrcLength, pszDest, nDestLength);
	}

	static void ConvertToBaseType(
		_Out_cap_(nDestLength) wchar_t* pszDest,
		_In_ int nDestLength,
		_In_count_(nSrcLength) const wchar_t* pszSrc,
		_In_ int nSrcLength = -1) throw()
	{
		if (nSrcLength == -1) { nSrcLength=1 + GetBaseTypeLength(pszSrc); }
		// nLen is in wchar_ts
		Checked::wmemcpy_s(pszDest, nDestLength, pszSrc, nSrcLength);
	}

	// this conversion on Unicode strings makes no sense
	/*
	static void ConvertToOem(_In_opt_z_ wchar_t*)
	{
		ATLASSERT(FALSE);
	}
	*/

	// this conversion on Unicode strings makes no sense
	/*
	static void ConvertToAnsi(_In_opt_z_ wchar_t*)
	{
		ATLASSERT(FALSE);
	}
	*/

	static void FloodCharacters(
		_In_ wchar_t ch,
		_In_ int nLength,
		_Out_z_capcount_(nLength) wchar_t* pstr) throw()
	{
		// nLength is in XCHARs
		for (int i = 0; i < nLength; i++)
			pstr[i] = ch;
	}

	static BSTR AllocSysString(
		_In_count_(nDataLength) const wchar_t* pchData,
		_In_ int nDataLength) throw()
	{
		BSTR bstr = ::SysAllocStringLen(pchData, nDataLength);
		return bstr;
	}

	static BOOL ReAllocSysString(
		_In_count_(nDataLength) const wchar_t* pchData,
		_Inout_ _Deref_post_opt_valid_ _Post_z_ BSTR* pbstr,
		_In_ int nDataLength) throw()
	{
		return ::SysReAllocStringLen(pbstr, pchData, nDataLength);
	}

	static DWORD FormatMessage(
		_In_ DWORD dwFlags,
		_In_ LPCVOID lpSource,
		_In_ DWORD dwMessageID,
		_In_ DWORD dwLanguageID,
		_Out_z_cap_(nSize) wchar_t* pstrBuffer,
		_In_ DWORD nSize,
		_In_opt_ va_list* pArguments) throw()
	{
		return ::FormatMessageW(dwFlags, lpSource, dwMessageID, dwLanguageID,
				pstrBuffer, nSize, pArguments);
	}

	static int SafeStringLen(_In_opt_z_ const char* psz) throw()
	{
		// returns length in bytes
		return (psz != NULL) ? lstrlenA(psz) : 0;
	}

	static int SafeStringLen(_In_opt_z_ const wchar_t* psz) throw()
	{
		// returns length in wchar_ts
		return (psz != NULL) ? lstrlenW(psz) : 0;
	}

	static int GetCharLen(_In_opt_z_ const wchar_t*) throw()
	{
		// returns char length
		return 1;
	}
	static int GetCharLen(_In_z_ const char* psz) throw()
	{
		LPCSTR p = ::CharNextA( psz );
		return int( p-psz );
	}

	static DWORD GetEnvironmentVariable(
		_In_z_ const wchar_t* pstrVar,
		_Out_opt_z_cap_(dwSize) wchar_t* pstrBuffer,
		_In_ DWORD dwSize) throw()
	{
		return ::GetEnvironmentVariableW(pstrVar, pstrBuffer, dwSize);
	}
};

template <class ChTraits>
inline typename ChTraits::PCXSTR strstrT(
	_In_ typename ChTraits::PCXSTR pStr,
	_In_ typename ChTraits::PCXSTR pCharSet)
{
	ATLASSERT(pStr != NULL);
	size_t nCharSetLen = ChTraits::GetBaseTypeLength(pCharSet);
	if (nCharSetLen == 0)
		return pStr;
	//lstrlenA returns length in bytes, not chars.
	size_t nStrLen = ChTraits::GetBaseTypeLength(pStr);
	ChTraits::PCXSTR pStrEnd=pStr + nStrLen;
	const ChTraits::XCHAR* pMatch;
	const ChTraits::XCHAR* pStart = pStr;
	while ((pMatch = ChTraits::strchr(pStart, *pCharSet)) != NULL)
	{
		size_t nCharsLeftInStr=pStrEnd - pMatch;
		if (nCharsLeftInStr < nCharSetLen)
		{
			break;
		}
		if (memcmp(pMatch, pCharSet, nCharSetLen*sizeof(ChTraits::XCHAR)) == 0)
		{
			return pMatch;
		}
		pStart = ChTraits::CharNext(pMatch);
	}

	return NULL;
}

template< typename _BaseType = char, class StringIterator = ChTraitsOS< _BaseType > >
class StrTraitATL : 
	public StringIterator
{
public:
	static HINSTANCE FindStringResourceInstance(_In_ UINT nID) throw()
	{
		return( AtlFindStringResourceInstance( nID ) );
	}

	static IAtlStringMgr* GetDefaultManager() throw()
	{
		return( &g_strmgr );
	}
};

#ifndef _ATL_CSTRING_NO_CRT
typedef CStringT< wchar_t, StrTraitATL< wchar_t, ChTraitsCRT< wchar_t > > > CAtlStringW;
typedef CStringT< char, StrTraitATL< char, ChTraitsCRT< char > > > CAtlStringA;
typedef CStringT< TCHAR, StrTraitATL< TCHAR, ChTraitsCRT< TCHAR > > > CAtlString;
#else  // _ATL_CSTRING_NO_CRT
typedef CStringT< wchar_t, StrTraitATL< wchar_t > > CAtlStringW;
typedef CStringT< char, StrTraitATL< char > > CAtlStringA;
typedef CStringT< TCHAR, StrTraitATL< TCHAR > > CAtlString;
#endif  // _ATL_CSTRING_NO_CRT

#ifndef _AFX
typedef CAtlStringW CStringW;
typedef CAtlStringA CStringA;
typedef CAtlString CString;
#endif

template< typename T >
class CElementTraits;

template<>
class CElementTraits< ATL::CAtlStringA > :
	public CStringElementTraits< ATL::CAtlStringA >
{
};

template<>
class CElementTraits< ATL::CAtlStringW > :
	public CStringElementTraits< ATL::CAtlStringW >
{
};

}; //namespace ATL

#pragma pack(pop)
#endif // __ATLSTR_H__

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\include\atlsocket.h ===
// This is a part of the Active Template Library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Active Template Library Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Active Template Library product.

#ifndef __ATL_SOCKET__
#define __ATL_SOCKET__

#pragma warning(push)
#pragma warning(disable: 4191) // unsafe conversion from 'functionptr1' to 'functionptr2'

#include <winsock2.h>
#include <mswsock.h>

#pragma warning(push)
#pragma warning(disable : 4127)
#pragma warning(disable : 4706)
#if !defined(_WIN32_WINNT) || (_WIN32_WINNT <= 0x0500)
/* psdk prefast noise */
#pragma warning(disable : 6011)
#endif
#include <ws2tcpip.h>
#pragma warning(pop)

#pragma comment(lib, "ws2_32.lib")
#pragma comment(lib, "mswsock.lib")

#if _WIN32_WINNT < 0x0502
#define ADDRINFOT addrinfo
#define GetAddrInfo getaddrinfo
#define FreeAddrInfo freeaddrinfo
#endif

#pragma pack(push,_ATL_PACKING)
namespace ATL
{
	class CSocketAddr;

	////////////////////////////////////////////////////////////////////////
	// class CSocketAddr
	//
	// Description:
	// This class provides an abstraction over an internet address. It provides
	// an IP version agnostic way to look up network addresses for use with
	// Windows sockets API functions and Socket wrappers in libraries
	// The members of this class that are used to look up network addresses
	// use the getaddrinfo Win32 API, which is an IP version agnostic function
	// for retrieving network addresses. This class can find both IPv4 and
	// IPv6 network addresses.
	////////////////////////////////////////////////////////////////////////
	class CSocketAddr
	{
	public:
		// Construction/Destruction
		CSocketAddr() throw();
		virtual ~CSocketAddr() throw();

		// Operations
		int FindAddr(
			_In_z_ LPCTSTR szHost, 				// Host name or dotted IP address
			_In_z_ LPCTSTR szPortOrServiceName,	// Port number or name of service on host
			_In_ int flags,						// 0 or combination of AI_PASSIVE, AI_CANONNAME or AI_NUMERICHOST
			_In_ int addr_family,				// Address family (such as PF_INET)
			_In_ int sock_type,					// Socket type (such as SOCK_STREAM)
			_In_ int ai_proto);					// Protocol (such as IPPROTO_IP or IPPROTO_IPV6)

		int FindAddr(
			_In_z_ LPCTSTR szHost, 			// Host name or dotted IP address
			_In_ int nPortNo,				// Port number
			_In_ int flags,					// 0 or combination of AI_PASSIVE, AI_CANONNAME or AI_NUMERICHOST
			_In_ int addr_family,			// Address family (such as PF_INET)
			_In_ int sock_type,				// Socket type (such as SOCK_STREAM)
			_In_ int ai_proto) throw();		// Protocol (such as IPPROTO_IP or IPPROTO_IPV6)

		int FindINET4Addr(
			_In_z_ LPCTSTR szHost, 						// Host name
			_In_ int nPortNo, 							// Port number
			_In_ int flags = 0, 						// 0 or combination of AI_PASSIVE, AI_CANONNAME or AI_NUMERICHOST
			_In_ int sock_type = SOCK_STREAM) throw(); 	// Socket type (such as SOCK_STREAM or SOCK_DGRAM)

		int FindINET6Addr(
			_In_z_ LPCTSTR szHost, 						// Host name
			_In_ int nPortNo, 							// Port number
			_In_ int flags = 0, 						// 0 or combination of AI_PASSIVE, AI_CANONNAME or AI_NUMERICHOST
			_In_ int sock_type = SOCK_STREAM) throw(); 	// Socket type (such as SOCK_STREAM or SOCK_DGRAM)

		ADDRINFOT* const GetAddrInfoList() const;
		ADDRINFOT* const GetAddrInfo(_In_ int nIndex = 0) const;

		// Implementation
	private:
		ADDRINFOT *m_pAddrs;
	};
}; // namespace ATL


#include <atlsocket.inl>

#pragma pack(pop)
#pragma warning(pop)

#endif __ATL_SOCKET__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\include\atltime.h ===
// This is a part of the Active Template Library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Active Template Library Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Active Template Library product.

#ifndef __ATLTIME_H__
#define __ATLTIME_H__

#pragma once

#pragma warning(push)
#pragma warning(disable : 4159 4127)

#include <atldef.h>

#include <time.h>

#ifdef _AFX
#include <afxstr.h>
#else
#include <atlstr.h>
#endif

#if defined(_M_IX86)
#pragma pack(push, 4)
#else
#pragma pack(push, ATL_PACKING)
#endif

#ifndef __oledb_h__
#include <oledb.h>
#endif // __oledb_h__

namespace ATL
{
class CTimeSpan
{
public:
	CTimeSpan() throw();
	CTimeSpan(_In_ __time64_t time) throw();
	CTimeSpan(
		_In_ LONG lDays,
		_In_ int nHours,
		_In_ int nMins,
		_In_ int nSecs) throw();

	LONGLONG GetDays() const throw();
	LONGLONG GetTotalHours() const throw();
	LONG GetHours() const throw();
	LONGLONG GetTotalMinutes() const throw();
	LONG GetMinutes() const throw();
	LONGLONG GetTotalSeconds() const throw();
	LONG GetSeconds() const throw();

	__time64_t GetTimeSpan() const throw();

	CTimeSpan operator+(_In_ CTimeSpan span) const throw();
	CTimeSpan operator-(_In_ CTimeSpan span) const throw();
	CTimeSpan& operator+=(_In_ CTimeSpan span) throw();
	CTimeSpan& operator-=(_In_ CTimeSpan span) throw();
	bool operator==(_In_ CTimeSpan span) const throw();
	bool operator!=(_In_ CTimeSpan span) const throw();
	bool operator<(_In_ CTimeSpan span) const throw();
	bool operator>(_In_ CTimeSpan span) const throw();
	bool operator<=(_In_ CTimeSpan span) const throw();
	bool operator>=(_In_ CTimeSpan span) const throw();

public:
	CString Format(_In_z_ LPCTSTR pszFormat) const;
	CString Format(_In_ UINT nID) const;
#if defined(_AFX) && defined(_UNICODE)
	// for compatibility with MFC 3.x
	CString Format(_In_z_ LPCSTR pFormat) const;
#endif

#ifdef _AFX
	CArchive& Serialize64(_In_ CArchive& ar);
#endif

private:
	__time64_t m_timeSpan;
};

class CTime
{
public:
	static CTime WINAPI GetCurrentTime() throw();
	static BOOL WINAPI IsValidFILETIME(_In_ const FILETIME& ft) throw();

	CTime() throw();
	CTime(_In_ __time64_t time) throw();
	CTime(
		_In_ int nYear,
		_In_ int nMonth,
		_In_ int nDay,
		_In_ int nHour,
		_In_ int nMin,
		_In_ int nSec,
		_In_ int nDST = -1);
	CTime(
		_In_ WORD wDosDate,
		_In_ WORD wDosTime,
		_In_ int nDST = -1);
	CTime(
		_In_ const SYSTEMTIME& st,
		_In_ int nDST = -1);
	CTime(
		_In_ const FILETIME& ft,
		_In_ int nDST = -1);
	CTime(
		_In_ const DBTIMESTAMP& dbts,
		_In_ int nDST = -1) throw();

	CTime& operator=(_In_ __time64_t time) throw();

	CTime& operator+=(_In_ CTimeSpan span) throw();
	CTime& operator-=(_In_ CTimeSpan span) throw();

	CTimeSpan operator-(_In_ CTime time) const throw();
	CTime operator-(_In_ CTimeSpan span) const throw();
	CTime operator+(_In_ CTimeSpan span) const throw();

	bool operator==(_In_ CTime time) const throw();
	bool operator!=(_In_ CTime time) const throw();
	bool operator<(_In_ CTime time) const throw();
	bool operator>(_In_ CTime time) const throw();
	bool operator<=(_In_ CTime time) const throw();
	bool operator>=(_In_ CTime time) const throw();

	struct tm* GetGmtTm(_Out_ struct tm* ptm) const;
	struct tm* GetLocalTm(_Out_ struct tm* ptm) const;

	bool GetAsSystemTime(_Out_ SYSTEMTIME& st) const throw();
	bool GetAsDBTIMESTAMP(_Out_ DBTIMESTAMP& dbts) const throw();

	__time64_t GetTime() const throw();

	int GetYear() const throw();
	int GetMonth() const throw();
	int GetDay() const throw();
	int GetHour() const throw();
	int GetMinute() const throw();
	int GetSecond() const throw();
	int GetDayOfWeek() const throw();

	// formatting using "C" strftime
	CString Format(_In_z_ LPCTSTR pszFormat) const;
	CString FormatGmt(_In_z_ LPCTSTR pszFormat) const;
	CString Format(_In_ UINT nFormatID) const;
	CString FormatGmt(_In_ UINT nFormatID) const;

#if defined(_AFX) && defined(_UNICODE)
	// for compatibility with MFC 3.x
	CString Format(_In_z_ LPCSTR pFormat) const;
	CString FormatGmt(_In_z_ LPCSTR pFormat) const;
#endif

#ifdef _AFX
	CArchive& Serialize64(_In_ CArchive& ar);
#endif

private:
	__time64_t m_time;
};

class CFileTimeSpan
{
public:
	CFileTimeSpan() throw();
	CFileTimeSpan(_In_ const CFileTimeSpan& span) throw();
	CFileTimeSpan(_In_ LONGLONG nSpan) throw();

	CFileTimeSpan& operator=(_In_ const CFileTimeSpan& span) throw();

	CFileTimeSpan& operator+=(_In_ CFileTimeSpan span) throw();
	CFileTimeSpan& operator-=(_In_ CFileTimeSpan span) throw();

	CFileTimeSpan operator+(_In_ CFileTimeSpan span) const throw();
	CFileTimeSpan operator-(_In_ CFileTimeSpan span) const throw();

	bool operator==(_In_ CFileTimeSpan span) const throw();
	bool operator!=(_In_ CFileTimeSpan span) const throw();
	bool operator<(_In_ CFileTimeSpan span) const throw();
	bool operator>(_In_ CFileTimeSpan span) const throw();
	bool operator<=(_In_ CFileTimeSpan span) const throw();
	bool operator>=(_In_ CFileTimeSpan span) const throw();

	LONGLONG GetTimeSpan() const throw();
	void SetTimeSpan(_In_ LONGLONG nSpan) throw();

protected:
	LONGLONG m_nSpan;
};

class CFileTime :
	public FILETIME
{
public:
	CFileTime() throw();
	CFileTime(_In_ const FILETIME& ft) throw();
	CFileTime(_In_ ULONGLONG nTime) throw();

	static CFileTime WINAPI GetCurrentTime() throw();

	CFileTime& operator=(_In_ const FILETIME& ft) throw();

	CFileTime& operator+=(_In_ CFileTimeSpan span) throw();
	CFileTime& operator-=(_In_ CFileTimeSpan span) throw();

	CFileTime operator+(_In_ CFileTimeSpan span) const throw();
	CFileTime operator-(_In_ CFileTimeSpan span) const throw();
	CFileTimeSpan operator-(_In_ CFileTime ft) const throw();

	bool operator==(_In_ CFileTime ft) const throw();
	bool operator!=(_In_ CFileTime ft) const throw();
	bool operator<(_In_ CFileTime ft) const throw();
	bool operator>(_In_ CFileTime ft) const throw();
	bool operator<=(_In_ CFileTime ft) const throw();
	bool operator>=(_In_ CFileTime ft) const throw();

	ULONGLONG GetTime() const throw();
	void SetTime(_In_ ULONGLONG nTime) throw();

	CFileTime UTCToLocal() const throw();
	CFileTime LocalToUTC() const throw();

	static const ULONGLONG Millisecond = 10000;
	static const ULONGLONG Second = Millisecond * static_cast<ULONGLONG>(1000);
	static const ULONGLONG Minute = Second * static_cast<ULONGLONG>(60);
	static const ULONGLONG Hour = Minute * static_cast<ULONGLONG>(60);
	static const ULONGLONG Day = Hour * static_cast<ULONGLONG>(24);
	static const ULONGLONG Week = Day * static_cast<ULONGLONG>(7);
};

// Used only if these strings could not be found in resources.
extern __declspec(selectany) const TCHAR * const szInvalidDateTime = _T("Invalid DateTime");
extern __declspec(selectany) const TCHAR * const szInvalidDateTimeSpan = _T("Invalid DateTimeSpan");

const int maxTimeBufferSize = 128;
const long maxDaysInSpan  =	3615897L;

} // namespace ATL

#ifndef _DEBUG
#define ATLTIME_INLINE inline
#include <atltime.inl>
#endif

namespace ATL
{

enum _CTIMESPANFORMATSTEP
{
	_CTFS_NONE   = 0,
	_CTFS_FORMAT = 1,
	_CTFS_NZ     = 2
};
#define _CTIMESPANFORMATS 3

inline CString CTimeSpan::Format(_In_z_ LPCTSTR pFormat) const
// formatting timespans is a little trickier than formatting CTimes
//  * we are only interested in relative time formats, ie. it is illegal
//      to format anything dealing with absolute time (i.e. years, months,
//         day of week, day of year, timezones, ...)
//  * the only valid formats:
//      %D - # of days
//      %H - hour in 24 hour format
//      %M - minute (0-59)
//      %S - seconds (0-59)
//      %% - percent sign
//	%#<any_of_mods> - skip leading zeros
{
	ATLASSERT( pFormat != NULL );
	if( pFormat == NULL )
		AtlThrow( E_INVALIDARG );

	CString strBuffer;
	CString hmsFormats [_CTIMESPANFORMATS] = {_T("%c"),_T("%02ld"),_T("%d")};
	CString dayFormats [_CTIMESPANFORMATS] = {_T("%c"),_T("%I64d"),_T("%I64d")};
	strBuffer.Preallocate(maxTimeBufferSize);
	TCHAR ch;

	while ((ch = *pFormat++) != _T('\0'))
	{
		enum _CTIMESPANFORMATSTEP formatstep = _CTFS_NONE;
		if(ch == _T('%'))
		{
			formatstep = _CTFS_FORMAT;
			ch = *pFormat++;
			if(ch == _T('#'))
			{
					formatstep = _CTFS_NZ;
					ch = *pFormat++;
			}
		}
		switch (ch)
		{
			case '%':
				strBuffer += ch;
				break;
			case 'D':
				strBuffer.AppendFormat(dayFormats[formatstep], formatstep ? GetDays()    : ch);
				break;
			case 'H':
				strBuffer.AppendFormat(hmsFormats[formatstep], formatstep ? GetHours()   : ch);
				break;
			case 'M':
				strBuffer.AppendFormat(hmsFormats[formatstep], formatstep ? GetMinutes() : ch);
				break;
			case 'S':
				strBuffer.AppendFormat(hmsFormats[formatstep], formatstep ? GetSeconds() : ch);
				break;
			default:
				if(formatstep)
				{
#pragma warning (push)
#pragma warning (disable: 4127)  // conditional expression constant
					ATLENSURE(FALSE);      // probably a bad format character
#pragma warning (pop)
				}
				else
				{
					strBuffer += ch;
#ifdef _MBCS
					if (_istlead(ch))
					{
						strBuffer += *pFormat++;
					}
#endif
				}
				break;
			}
	}

	return strBuffer;
}

inline CString CTimeSpan::Format(_In_ UINT nFormatID) const
{
	CString strFormat;
	ATLENSURE(strFormat.LoadString(nFormatID));
	return Format(strFormat);
}

#if defined(_AFX) && defined(_UNICODE)
inline CString CTimeSpan::Format(_In_z_ LPCSTR pFormat) const
{
	return Format(CString(pFormat));
}
#endif

#ifdef __oledb_h__
inline CTime::CTime(
	_In_ const DBTIMESTAMP& dbts,
	_In_ int nDST) throw()
{
	struct tm atm;
	atm.tm_sec = dbts.second;
	atm.tm_min = dbts.minute;
	atm.tm_hour = dbts.hour;
	atm.tm_mday = dbts.day;
	atm.tm_mon = dbts.month - 1;        // tm_mon is 0 based
	ATLASSERT(dbts.year >= 1900);
	atm.tm_year = dbts.year - 1900;     // tm_year is 1900 based
	atm.tm_isdst = nDST;
	m_time = _mktime64(&atm);
	ATLASSUME(m_time != -1);       // indicates an illegal input time
}
#endif

inline CString CTime::Format(_In_z_ LPCTSTR pFormat) const
{
	if(pFormat == NULL)
	{
		return pFormat;
	}

	TCHAR szBuffer[maxTimeBufferSize];
	struct tm ptmTemp;

	if (_localtime64_s(&ptmTemp, &m_time) != 0)
	{
		AtlThrow(E_INVALIDARG);
	}

	if (!_tcsftime(szBuffer, maxTimeBufferSize, pFormat, &ptmTemp))
	{
		szBuffer[0] = '\0';
	}

	return szBuffer;
}

inline CString CTime::FormatGmt(_In_z_ LPCTSTR pFormat) const
{
	if(pFormat == NULL)
	{
		return pFormat;
	}

	TCHAR szBuffer[maxTimeBufferSize];
	struct tm ptmTemp;

	if (_gmtime64_s(&ptmTemp, &m_time) != 0)
	{
		AtlThrow(E_INVALIDARG);
	}

	if (!_tcsftime(szBuffer, maxTimeBufferSize, pFormat, &ptmTemp))
	{
		szBuffer[0] = '\0';
	}

	return szBuffer;
}

inline CString CTime::Format(_In_ UINT nFormatID) const
{
	CString strFormat;
	ATLENSURE(strFormat.LoadString(nFormatID));
	return Format(strFormat);
}

inline CString CTime::FormatGmt(_In_ UINT nFormatID) const
{
	CString strFormat;
	ATLENSURE(strFormat.LoadString(nFormatID));
	return FormatGmt(strFormat);
}

#if defined (_AFX) && defined(_UNICODE)
inline CString CTime::Format(_In_z_ LPCSTR pFormat) const
{
	return Format(CString(pFormat));
}

inline CString CTime::FormatGmt(_In_z_ LPCSTR pFormat) const
{
	return FormatGmt(CString(pFormat));
}
#endif // _AFX && _UNICODE

}	// namespace ATL
#pragma pack(pop)

#pragma warning(pop)

#endif  // __ATLTIME_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\include\atltime.inl ===
// This is a part of the Active Template Library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Active Template Library Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Active Template Library product.

#ifndef __ATLTIME_INL__
#define __ATLTIME_INL__

#pragma once

#ifndef __ATLTIME_H__
	#error atltime.inl requires atltime.h to be included first
#endif

namespace ATL
{
/////////////////////////////////////////////////////////////////////////////
// CTimeSpan
/////////////////////////////////////////////////////////////////////////////

ATLTIME_INLINE CTimeSpan::CTimeSpan() throw() :
	m_timeSpan(0)
{
}

ATLTIME_INLINE CTimeSpan::CTimeSpan(_In_ __time64_t time) throw() :
	m_timeSpan( time )
{
}

ATLTIME_INLINE CTimeSpan::CTimeSpan(
	_In_ LONG lDays,
	_In_ int nHours,
	_In_ int nMins,
	_In_ int nSecs) throw()
{
 	m_timeSpan = nSecs + 60* (nMins + 60* (nHours + __int64(24) * lDays));
}

ATLTIME_INLINE LONGLONG CTimeSpan::GetDays() const throw()
{
	return( m_timeSpan/(24*3600) );
}

ATLTIME_INLINE LONGLONG CTimeSpan::GetTotalHours() const throw()
{
	return( m_timeSpan/3600 );
}

ATLTIME_INLINE LONG CTimeSpan::GetHours() const throw()
{
	return( LONG( GetTotalHours()-(GetDays()*24) ) );
}

ATLTIME_INLINE LONGLONG CTimeSpan::GetTotalMinutes() const throw()
{
	return( m_timeSpan/60 );
}

ATLTIME_INLINE LONG CTimeSpan::GetMinutes() const throw()
{
	return( LONG( GetTotalMinutes()-(GetTotalHours()*60) ) );
}

ATLTIME_INLINE LONGLONG CTimeSpan::GetTotalSeconds() const throw()
{
	return( m_timeSpan );
}

ATLTIME_INLINE LONG CTimeSpan::GetSeconds() const throw()
{
	return( LONG( GetTotalSeconds()-(GetTotalMinutes()*60) ) );
}

ATLTIME_INLINE __time64_t CTimeSpan::GetTimeSpan() const throw()
{
	return( m_timeSpan );
}

ATLTIME_INLINE CTimeSpan CTimeSpan::operator+(_In_ CTimeSpan span) const throw()
{
	return( CTimeSpan( m_timeSpan+span.m_timeSpan ) );
}

ATLTIME_INLINE CTimeSpan CTimeSpan::operator-(_In_ CTimeSpan span) const throw()
{
	return( CTimeSpan( m_timeSpan-span.m_timeSpan ) );
}

ATLTIME_INLINE CTimeSpan& CTimeSpan::operator+=(_In_ CTimeSpan span) throw()
{
	m_timeSpan += span.m_timeSpan;
	return( *this );
}

ATLTIME_INLINE CTimeSpan& CTimeSpan::operator-=(_In_ CTimeSpan span) throw()
{
	m_timeSpan -= span.m_timeSpan;
	return( *this );
}

ATLTIME_INLINE bool CTimeSpan::operator==(_In_ CTimeSpan span) const throw()
{
	return( m_timeSpan == span.m_timeSpan );
}

ATLTIME_INLINE bool CTimeSpan::operator!=(_In_ CTimeSpan span) const throw()
{
	return( m_timeSpan != span.m_timeSpan );
}

ATLTIME_INLINE bool CTimeSpan::operator<(_In_ CTimeSpan span) const throw()
{
	return( m_timeSpan < span.m_timeSpan );
}

ATLTIME_INLINE bool CTimeSpan::operator>(_In_ CTimeSpan span) const throw()
{
	return( m_timeSpan > span.m_timeSpan );
}

ATLTIME_INLINE bool CTimeSpan::operator<=(_In_ CTimeSpan span) const throw()
{
	return( m_timeSpan <= span.m_timeSpan );
}

ATLTIME_INLINE bool CTimeSpan::operator>=(_In_ CTimeSpan span) const throw()
{
	return( m_timeSpan >= span.m_timeSpan );
}

/////////////////////////////////////////////////////////////////////////////
// CTime
/////////////////////////////////////////////////////////////////////////////

ATLTIME_INLINE CTime WINAPI CTime::GetCurrentTime() throw()
{
	return( CTime( ::_time64( NULL ) ) );
}

ATLTIME_INLINE BOOL WINAPI CTime::IsValidFILETIME(_In_ const FILETIME& fileTime) throw()
{
	FILETIME localTime;
	if (!FileTimeToLocalFileTime(&fileTime, &localTime))
	{
		return FALSE;
	}

	// then convert that time to system time
	SYSTEMTIME sysTime;
	if (!FileTimeToSystemTime(&localTime, &sysTime))
	{
		return FALSE;
	}

	return TRUE;
}

ATLTIME_INLINE CTime::CTime() throw() :
	m_time(0)
{
}

ATLTIME_INLINE CTime::CTime(_In_ __time64_t time)  throw():
	m_time( time )
{
}

ATLTIME_INLINE CTime::CTime(
	_In_ int nYear,
	_In_ int nMonth,
	_In_ int nDay,
	_In_ int nHour,
	_In_ int nMin,
	_In_ int nSec,
	_In_ int nDST)
{
#pragma warning (push)
#pragma warning (disable: 4127)  // conditional expression constant

	ATLENSURE( nYear >= 1900 );
	ATLENSURE( nMonth >= 1 && nMonth <= 12 );
	ATLENSURE( nDay >= 1 && nDay <= 31 );
	ATLENSURE( nHour >= 0 && nHour <= 23 );
	ATLENSURE( nMin >= 0 && nMin <= 59 );
	ATLENSURE( nSec >= 0 && nSec <= 59 );

#pragma warning (pop)

	struct tm atm;

	atm.tm_sec = nSec;
	atm.tm_min = nMin;
	atm.tm_hour = nHour;
	atm.tm_mday = nDay;
	atm.tm_mon = nMonth - 1;        // tm_mon is 0 based
	atm.tm_year = nYear - 1900;     // tm_year is 1900 based
	atm.tm_isdst = nDST;

	m_time = _mktime64(&atm);
	ATLASSUME(m_time != -1);       // indicates an illegal input time
	if(m_time == -1)
	{
		AtlThrow(E_INVALIDARG);
	}
}

ATLTIME_INLINE CTime::CTime(
	_In_ WORD wDosDate,
	_In_ WORD wDosTime,
	_In_ int nDST)
{
	struct tm atm;
	atm.tm_sec = (wDosTime & ~0xFFE0) << 1;
	atm.tm_min = (wDosTime & ~0xF800) >> 5;
	atm.tm_hour = wDosTime >> 11;

	atm.tm_mday = wDosDate & ~0xFFE0;
	atm.tm_mon = ((wDosDate & ~0xFE00) >> 5) - 1;
	atm.tm_year = (wDosDate >> 9) + 80;
	atm.tm_isdst = nDST;
	m_time = _mktime64(&atm);
	ATLASSUME(m_time != -1);       // indicates an illegal input time

	if(m_time == -1)
		AtlThrow(E_INVALIDARG);

}

ATLTIME_INLINE CTime::CTime(
	_In_ const SYSTEMTIME& sysTime,
	_In_ int nDST)
{
	if (sysTime.wYear < 1900)
	{
		__time64_t time0 = 0L;
		CTime timeT(time0);
		*this = timeT;
	}
	else
	{
		CTime timeT(
			(int)sysTime.wYear, (int)sysTime.wMonth, (int)sysTime.wDay,
			(int)sysTime.wHour, (int)sysTime.wMinute, (int)sysTime.wSecond,
			nDST);
		*this = timeT;
	}
}

ATLTIME_INLINE CTime::CTime(
	_In_ const FILETIME& fileTime,
	_In_ int nDST)
{
	// first convert file time (UTC time) to local time
	FILETIME localTime;
	if (!FileTimeToLocalFileTime(&fileTime, &localTime))
	{
		m_time = 0;
		AtlThrow(E_INVALIDARG);
		return;
	}

	// then convert that time to system time
	SYSTEMTIME sysTime;
	if (!FileTimeToSystemTime(&localTime, &sysTime))
	{
		m_time = 0;
		AtlThrow(E_INVALIDARG);
		return;
	}

	// then convert the system time to a time_t (C-runtime local time)
	CTime timeT(sysTime, nDST);
	*this = timeT;
}

ATLTIME_INLINE CTime& CTime::operator=(_In_ __time64_t time) throw()
{
	m_time = time;

	return( *this );
}

ATLTIME_INLINE CTime& CTime::operator+=(_In_ CTimeSpan span) throw()
{
	m_time += span.GetTimeSpan();

	return( *this );
}

ATLTIME_INLINE CTime& CTime::operator-=(_In_ CTimeSpan span) throw()
{
	m_time -= span.GetTimeSpan();

	return( *this );
}

ATLTIME_INLINE CTimeSpan CTime::operator-(_In_ CTime time) const throw()
{
	return( CTimeSpan( m_time-time.m_time ) );
}

ATLTIME_INLINE CTime CTime::operator-(_In_ CTimeSpan span) const throw()
{
	return( CTime( m_time-span.GetTimeSpan() ) );
}

ATLTIME_INLINE CTime CTime::operator+(_In_ CTimeSpan span) const throw()
{
	return( CTime( m_time+span.GetTimeSpan() ) );
}

ATLTIME_INLINE bool CTime::operator==(_In_ CTime time) const throw()
{
	return( m_time == time.m_time );
}

ATLTIME_INLINE bool CTime::operator!=(_In_ CTime time) const throw()
{
	return( m_time != time.m_time );
}

ATLTIME_INLINE bool CTime::operator<(_In_ CTime time) const throw()
{
	return( m_time < time.m_time );
}

ATLTIME_INLINE bool CTime::operator>(_In_ CTime time) const throw()
{
	return( m_time > time.m_time );
}

ATLTIME_INLINE bool CTime::operator<=(_In_ CTime time) const throw()
{
	return( m_time <= time.m_time );
}

ATLTIME_INLINE bool CTime::operator>=(_In_ CTime time) const throw()
{
	return( m_time >= time.m_time );
}

ATLTIME_INLINE struct tm* CTime::GetGmtTm(_Out_ struct tm* ptm) const
{
	// Ensure ptm is valid
	ATLENSURE( ptm != NULL );

	if (ptm != NULL)
	{
		struct tm ptmTemp;
		errno_t err = _gmtime64_s(&ptmTemp, &m_time);

		// Be sure the call succeeded
		if(err != 0) { return NULL; }

		*ptm = ptmTemp;
		return ptm;
	}

	return NULL;
}

ATLTIME_INLINE struct tm* CTime::GetLocalTm(_Out_ struct tm* ptm) const
{
	// Ensure ptm is valid
	ATLENSURE( ptm != NULL );

	if (ptm != NULL)
	{
		struct tm ptmTemp;
		errno_t err = _localtime64_s(&ptmTemp, &m_time);

		if (err != 0)
		{
			return NULL;    // indicates that m_time was not initialized!
		}

		*ptm = ptmTemp;
		return ptm;
	}

	return NULL;
}

ATLTIME_INLINE bool CTime::GetAsSystemTime(_Out_ SYSTEMTIME& timeDest) const throw()
{
	struct tm ttm;
	struct tm* ptm;

	ptm = GetLocalTm(&ttm);
	if(!ptm) 
	{ 
		return false; 
	}

	timeDest.wYear = (WORD) (1900 + ptm->tm_year);
	timeDest.wMonth = (WORD) (1 + ptm->tm_mon);
	timeDest.wDayOfWeek = (WORD) ptm->tm_wday;
	timeDest.wDay = (WORD) ptm->tm_mday;
	timeDest.wHour = (WORD) ptm->tm_hour;
	timeDest.wMinute = (WORD) ptm->tm_min;
	timeDest.wSecond = (WORD) ptm->tm_sec;
	timeDest.wMilliseconds = 0;

	return true;
}

ATLTIME_INLINE __time64_t CTime::GetTime() const throw()
{
	return( m_time );
}

ATLTIME_INLINE int CTime::GetYear() const
{
	struct tm ttm;
	struct tm * ptm;

	ptm = GetLocalTm(&ttm);
	return ptm ? (ptm->tm_year) + 1900 : 0 ;
}

ATLTIME_INLINE int CTime::GetMonth() const
{
	struct tm ttm;
	struct tm * ptm;

	ptm = GetLocalTm(&ttm);
	return ptm ? ptm->tm_mon + 1 : 0;
}

ATLTIME_INLINE int CTime::GetDay() const
{
	struct tm ttm;
	struct tm * ptm;

	ptm = GetLocalTm(&ttm);
	return ptm ? ptm->tm_mday : 0 ;
}

ATLTIME_INLINE int CTime::GetHour() const
{
	struct tm ttm;
	struct tm * ptm;

	ptm = GetLocalTm(&ttm);
	return ptm ? ptm->tm_hour : -1 ;
}

ATLTIME_INLINE int CTime::GetMinute() const
{
	struct tm ttm;
	struct tm * ptm;

	ptm = GetLocalTm(&ttm);
	return ptm ? ptm->tm_min : -1 ;
}

ATLTIME_INLINE int CTime::GetSecond() const
{
	struct tm ttm;
	struct tm * ptm;

	ptm = GetLocalTm(&ttm);
	return ptm ? ptm->tm_sec : -1 ;
}

ATLTIME_INLINE int CTime::GetDayOfWeek() const
{
	struct tm ttm;
	struct tm * ptm;

	ptm = GetLocalTm(&ttm);
	return ptm ? ptm->tm_wday + 1 : 0 ;
}

/////////////////////////////////////////////////////////////////////////////
// CFileTimeSpan
/////////////////////////////////////////////////////////////////////////////

ATLTIME_INLINE CFileTimeSpan::CFileTimeSpan() throw() :
	m_nSpan( 0 )
{
}

ATLTIME_INLINE CFileTimeSpan::CFileTimeSpan(_In_ const CFileTimeSpan& span) throw() :
	m_nSpan( span.m_nSpan )
{
}

ATLTIME_INLINE CFileTimeSpan::CFileTimeSpan(_In_ LONGLONG nSpan) throw() :
	m_nSpan( nSpan )
{
}

ATLTIME_INLINE CFileTimeSpan& CFileTimeSpan::operator=(_In_ const CFileTimeSpan& span) throw()
{
	m_nSpan = span.m_nSpan;

	return( *this );
}

ATLTIME_INLINE CFileTimeSpan& CFileTimeSpan::operator+=(_In_ CFileTimeSpan span) throw()
{
	m_nSpan += span.m_nSpan;

	return( *this );
}

ATLTIME_INLINE CFileTimeSpan& CFileTimeSpan::operator-=(_In_ CFileTimeSpan span) throw()
{
	m_nSpan -= span.m_nSpan;

	return( *this );
}

ATLTIME_INLINE CFileTimeSpan CFileTimeSpan::operator+(_In_ CFileTimeSpan span) const throw()
{
	return( CFileTimeSpan( m_nSpan+span.m_nSpan ) );
}

ATLTIME_INLINE CFileTimeSpan CFileTimeSpan::operator-(_In_ CFileTimeSpan span) const throw()
{
	return( CFileTimeSpan( m_nSpan-span.m_nSpan ) );
}

ATLTIME_INLINE bool CFileTimeSpan::operator==(_In_ CFileTimeSpan span) const throw()
{
	return( m_nSpan == span.m_nSpan );
}

ATLTIME_INLINE bool CFileTimeSpan::operator!=(_In_ CFileTimeSpan span) const throw()
{
	return( m_nSpan != span.m_nSpan );
}

ATLTIME_INLINE bool CFileTimeSpan::operator<(_In_ CFileTimeSpan span) const throw()
{
	return( m_nSpan < span.m_nSpan );
}

ATLTIME_INLINE bool CFileTimeSpan::operator>(_In_ CFileTimeSpan span) const throw()
{
	return( m_nSpan > span.m_nSpan );
}

ATLTIME_INLINE bool CFileTimeSpan::operator<=(_In_ CFileTimeSpan span) const throw()
{
	return( m_nSpan <= span.m_nSpan );
}

ATLTIME_INLINE bool CFileTimeSpan::operator>=(_In_ CFileTimeSpan span) const throw()
{
	return( m_nSpan >= span.m_nSpan );
}

ATLTIME_INLINE LONGLONG CFileTimeSpan::GetTimeSpan() const throw()
{
	return( m_nSpan );
}

ATLTIME_INLINE void CFileTimeSpan::SetTimeSpan(_In_ LONGLONG nSpan) throw()
{
	m_nSpan = nSpan;
}


/////////////////////////////////////////////////////////////////////////////
// CFileTime
/////////////////////////////////////////////////////////////////////////////

ATLTIME_INLINE CFileTime::CFileTime() throw()
{
	dwLowDateTime = 0;
	dwHighDateTime = 0;
}

ATLTIME_INLINE CFileTime::CFileTime(_In_ const FILETIME& ft) throw()
{
	dwLowDateTime = ft.dwLowDateTime;
	dwHighDateTime = ft.dwHighDateTime;
}

ATLTIME_INLINE CFileTime::CFileTime(_In_ ULONGLONG nTime) throw()
{
	dwLowDateTime = DWORD( nTime );
	dwHighDateTime = DWORD( nTime>>32 );
}

ATLTIME_INLINE CFileTime& CFileTime::operator=(_In_ const FILETIME& ft) throw()
{
	dwLowDateTime = ft.dwLowDateTime;
	dwHighDateTime = ft.dwHighDateTime;

	return( *this );
}

ATLTIME_INLINE CFileTime WINAPI CFileTime::GetCurrentTime() throw()
{
	CFileTime ft;
	GetSystemTimeAsFileTime(&ft);
	return ft;
}

ATLTIME_INLINE CFileTime& CFileTime::operator+=(_In_ CFileTimeSpan span) throw()
{
	SetTime( GetTime()+span.GetTimeSpan() );

	return( *this );
}

ATLTIME_INLINE CFileTime& CFileTime::operator-=(_In_ CFileTimeSpan span) throw()
{
	SetTime( GetTime()-span.GetTimeSpan() );

	return( *this );
}

ATLTIME_INLINE CFileTime CFileTime::operator+(_In_ CFileTimeSpan span) const throw()
{
	return( CFileTime( GetTime()+span.GetTimeSpan() ) );
}

ATLTIME_INLINE CFileTime CFileTime::operator-(_In_ CFileTimeSpan span) const throw()
{
	return( CFileTime( GetTime()-span.GetTimeSpan() ) );
}

ATLTIME_INLINE CFileTimeSpan CFileTime::operator-(_In_ CFileTime ft) const throw()
{
	return( CFileTimeSpan( GetTime()-ft.GetTime() ) );
}

ATLTIME_INLINE bool CFileTime::operator==(_In_ CFileTime ft) const throw()
{
	return( GetTime() == ft.GetTime() );
}

ATLTIME_INLINE bool CFileTime::operator!=(_In_ CFileTime ft) const throw()
{
	return( GetTime() != ft.GetTime() );
}

ATLTIME_INLINE bool CFileTime::operator<(_In_ CFileTime ft) const throw()
{
	return( GetTime() < ft.GetTime() );
}

ATLTIME_INLINE bool CFileTime::operator>(_In_ CFileTime ft) const throw()
{
	return( GetTime() > ft.GetTime() );
}

ATLTIME_INLINE bool CFileTime::operator<=(_In_ CFileTime ft) const throw()
{
	return( GetTime() <= ft.GetTime() );
}

ATLTIME_INLINE bool CFileTime::operator>=(_In_ CFileTime ft) const throw()
{
	return( GetTime() >= ft.GetTime() );
}

ATLTIME_INLINE ULONGLONG CFileTime::GetTime() const throw()
{
	return( (ULONGLONG( dwHighDateTime )<<32)|dwLowDateTime );
}

ATLTIME_INLINE void CFileTime::SetTime(_In_ ULONGLONG nTime) throw()
{
	dwLowDateTime = DWORD( nTime );
	dwHighDateTime = DWORD( nTime>>32 );
}

ATLTIME_INLINE CFileTime CFileTime::UTCToLocal() const throw()
{
	CFileTime ftLocal;

	::FileTimeToLocalFileTime( this, &ftLocal );

	return( ftLocal );
}

ATLTIME_INLINE CFileTime CFileTime::LocalToUTC() const throw()
{
	CFileTime ftUTC;

	::LocalFileTimeToFileTime( this, &ftUTC );

	return( ftUTC );
}

}  // namespace ATL
#endif //__ATLTIME_INL__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\include\atltrace.h ===
// This is a part of the Active Template Library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Active Template Library Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Active Template Library product.

#ifndef __ATLTRACE_H__
#define __ATLTRACE_H__

#pragma once

#include <atldef.h>
#include <atlconv.h>

#ifdef _DEBUG
#include <stdio.h>
#include <stdarg.h>
#endif

#ifdef _DEBUG
#include <atldebugapi.h>

extern "C" IMAGE_DOS_HEADER __ImageBase;
#endif  // _DEBUG


#pragma pack(push,_ATL_PACKING)
namespace ATL
{

// Declare a global instance of this class to automatically register a custom trace category at startup
class CTraceCategory
{
public:
	explicit CTraceCategory(
		_In_z_ LPCTSTR pszCategoryName,
		_In_ UINT nStartingLevel = 0) throw();

#ifdef _DEBUG
	UINT GetLevel() const throw();
	void SetLevel(_In_ UINT nLevel) throw();
	ATLTRACESTATUS GetStatus() const throw();
	void SetStatus(_In_ ATLTRACESTATUS eStatus) throw();
#endif

	operator DWORD_PTR() const throw();

public:
#ifdef _DEBUG
	DWORD_PTR m_dwCategory;
#endif
};

#ifdef _DEBUG
extern bool _IsTracingEnabled(
	_In_ DWORD_PTR dwModule,
	_In_ DWORD_PTR dwCategory,
	_In_ UINT nLevel);

class CTrace
{
public:
	typedef int (__cdecl *fnCrtDbgReport_t)(
		_In_ int,
		_In_z_ const char *,
		_In_ int,
		_In_z_ const char *,
		_In_z_ const char *,...);

private:
	CTrace(
#ifdef _ATL_NO_DEBUG_CRT
		_In_opt_ fnCrtDbgReport_t pfnCrtDbgReport = NULL)
#else
		_In_opt_ fnCrtDbgReport_t pfnCrtDbgReport = _CrtDbgReport)
#endif
		: m_hInst(reinterpret_cast<HINSTANCE>(&__ImageBase)),
			m_dwModule( 0 )
	{
		m_dwModule = AtlTraceRegister(m_hInst, pfnCrtDbgReport);
	}

	~CTrace()
	{
		AtlTraceUnregister(m_dwModule);
	}

public:
	bool ChangeCategory(
		_In_ DWORD_PTR dwCategory,
		_In_ UINT nLevel,
		_In_ ATLTRACESTATUS eStatus)
	{
		return 0 !=
			AtlTraceModifyCategory(0, dwCategory, nLevel, eStatus);
	}

	bool GetCategory(
		_In_ DWORD_PTR dwCategory,
		_Out_ UINT *pnLevel,
		_Out_ ATLTRACESTATUS *peStatus)
	{
		ATLASSERT(pnLevel && peStatus);
		return 0 != AtlTraceGetCategory(0, dwCategory, pnLevel, peStatus);
	}
	UINT GetLevel()
	{
		ATLTRACESTATUS eStatus;
		UINT nLevel;
		AtlTraceGetModule(0, m_dwModule, &nLevel, &eStatus);

		return nLevel;
	}
	void SetLevel(_In_ UINT nLevel)
	{
		AtlTraceModifyModule(0, m_dwModule, nLevel, ATLTRACESTATUS_ENABLED);
	}
	ATLTRACESTATUS GetStatus()
	{
		ATLTRACESTATUS eStatus;
		UINT nLevel;
		AtlTraceGetModule(0, m_dwModule, &nLevel, &eStatus);

		return eStatus;
	}
	void SetStatus(_In_ ATLTRACESTATUS eStatus)
	{
		ATLTRACESTATUS eOldStatus;
		UINT nLevel;
		AtlTraceGetModule(0, m_dwModule, &nLevel, &eOldStatus);
		AtlTraceModifyModule(0, m_dwModule, nLevel, eStatus);
	}
	void __cdecl TraceV(
		_In_opt_z_ const char *pszFileName,
		_In_ int nLine,
		_In_ DWORD_PTR dwCategory,
		_In_ UINT nLevel,
		_In_z_ LPCSTR pszFmt,
		_In_ va_list args) const;
	void __cdecl TraceV(
		_In_opt_z_ const char *pszFileName,
		_In_ int nLine,
		_In_ DWORD_PTR dwCategory,
		_In_ UINT nLevel,
		_In_z_ LPCWSTR pszFmt,
		_In_ va_list args) const;

	DWORD_PTR RegisterCategory(_In_z_ LPCSTR pszCategory)
	{
		return(AtlTraceRegisterCategoryA(m_dwModule, pszCategory));
	}
#ifdef _UNICODE
	DWORD_PTR RegisterCategory(_In_z_ LPCWSTR pszCategory)
	{
		return(AtlTraceRegisterCategoryU(m_dwModule, pszCategory));
	}
#endif

	bool LoadSettings(_In_opt_z_ LPCTSTR pszFileName = NULL) const
	{
		return 0 != AtlTraceLoadSettings(pszFileName);
	}
	void SaveSettings(_In_opt_z_ LPCTSTR pszFileName = NULL) const
	{
		AtlTraceSaveSettings(pszFileName);
	}

	static bool IsTracingEnabled(
		_In_ DWORD_PTR dwCategory,
		_In_ UINT nLevel)
	{
		return _IsTracingEnabled(s_trace.m_dwModule, dwCategory, nLevel);
	}
public:
	static CTrace s_trace;

protected:
	HINSTANCE m_hInst;
	DWORD_PTR m_dwModule;
};

inline bool IsTracingEnabled(
	_In_ DWORD_PTR dwCategory,
	_In_ UINT nLevel)
{
	return CTrace::IsTracingEnabled(dwCategory, nLevel);
}

inline void __cdecl CTrace::TraceV(
	_In_opt_z_ const char *pszFileName,
	_In_ int nLine,
	_In_ DWORD_PTR dwCategory,
	_In_ UINT nLevel,
	_In_z_ LPCSTR pszFmt, 
	_In_ va_list args) const
{
	AtlTraceVA(m_dwModule, pszFileName, nLine, dwCategory, nLevel, pszFmt, args);
}

inline void __cdecl CTrace::TraceV(
	_In_opt_z_ const char *pszFileName,
	_In_ int nLine,
	_In_ DWORD_PTR dwCategory,
	_In_ UINT nLevel,
	_In_z_ LPCWSTR pszFmt,
	_In_ va_list args) const
{
	AtlTraceVU(m_dwModule, pszFileName, nLine, dwCategory, nLevel, pszFmt, args);
}

extern CTraceCategory atlTraceGeneral;

class CTraceFileAndLineInfo
{
public:
	CTraceFileAndLineInfo(
			_In_z_ const char *pszFileName,
			_In_ int nLineNo)
		: m_pszFileName(pszFileName), m_nLineNo(nLineNo)
	{
	}

#pragma warning(push)
#pragma warning(disable : 4793)
	void __cdecl operator()(
		_In_ DWORD_PTR dwCategory,
		_In_ UINT nLevel,
		_In_z_ const char *pszFmt, 
		...) const
	{
		va_list ptr; va_start(ptr, pszFmt);
		ATL::CTrace::s_trace.TraceV(m_pszFileName, m_nLineNo, dwCategory, nLevel, pszFmt, ptr);
		va_end(ptr);
	}
#pragma warning(pop)

#pragma warning(push)
#pragma warning(disable : 4793)
	void __cdecl operator()(
		_In_ DWORD_PTR dwCategory,
		_In_ UINT nLevel,
		_In_z_ const wchar_t *pszFmt, 
		...) const
	{
		va_list ptr; va_start(ptr, pszFmt);
		ATL::CTrace::s_trace.TraceV(m_pszFileName, m_nLineNo, dwCategory, nLevel, pszFmt, ptr);
		va_end(ptr);
	}
#pragma warning(pop)

#pragma warning(push)
#pragma warning(disable : 4793)
	void __cdecl operator()(
		_In_z_ const char *pszFmt, 
		...) const
	{
		va_list ptr; va_start(ptr, pszFmt);
		ATL::CTrace::s_trace.TraceV(m_pszFileName, m_nLineNo, atlTraceGeneral, 0, pszFmt, ptr);
		va_end(ptr);
	}
#pragma warning(pop)

#pragma warning(push)
#pragma warning(disable : 4793)
	void __cdecl operator()(
		_In_z_ const wchar_t *pszFmt, 
		...) const
	{
		va_list ptr; va_start(ptr, pszFmt);
		ATL::CTrace::s_trace.TraceV(m_pszFileName, m_nLineNo, atlTraceGeneral, 0, pszFmt, ptr);
		va_end(ptr);
	}
#pragma warning(pop)

private:
	/* unimplemented */
	CTraceFileAndLineInfo &__cdecl operator=(_In_ const CTraceFileAndLineInfo &right);

	const char *const m_pszFileName;
	const int m_nLineNo;
};

#endif  // _DEBUG

#ifdef _DEBUG

inline CTraceCategory::CTraceCategory(
		_In_z_ LPCTSTR pszCategoryName,
		_In_ UINT nStartingLevel) throw() :
	m_dwCategory( 0 )
{
	m_dwCategory = ATL::CTrace::s_trace.RegisterCategory( pszCategoryName );
	ATL::CTrace::s_trace.ChangeCategory( m_dwCategory, nStartingLevel, ATLTRACESTATUS_INHERIT);
}

inline CTraceCategory::operator DWORD_PTR() const throw()
{
	return( m_dwCategory );
}

inline UINT CTraceCategory::GetLevel() const throw()
{
	UINT nLevel;
	ATLTRACESTATUS eStatus;
	ATL::CTrace::s_trace.GetCategory( m_dwCategory, &nLevel, &eStatus );

	return( nLevel );
}

inline void CTraceCategory::SetLevel(_In_ UINT nLevel) throw()
{
	ATL::CTrace::s_trace.ChangeCategory( m_dwCategory, nLevel, ATLTRACESTATUS_ENABLED );
}

inline ATLTRACESTATUS CTraceCategory::GetStatus() const throw()
{
	UINT nLevel;
	ATLTRACESTATUS eStatus;
	ATL::CTrace::s_trace.GetCategory( m_dwCategory, &nLevel, &eStatus );

	return( eStatus );
}

inline void CTraceCategory::SetStatus(_In_ ATLTRACESTATUS eStatus) throw()
{
	UINT nLevel;
	ATLTRACESTATUS eOldStatus;
	ATL::CTrace::s_trace.GetCategory( m_dwCategory, &nLevel, &eOldStatus );
	ATL::CTrace::s_trace.ChangeCategory( m_dwCategory, nLevel, eStatus );
}

#else  // !_DEBUG

inline CTraceCategory::CTraceCategory(
	_In_z_ LPCTSTR pszCategoryName,
	_In_ UINT nStartingLevel) throw()
{
	(void)pszCategoryName;
	(void)nStartingLevel;
}

inline CTraceCategory::operator DWORD_PTR() const throw()
{
	return( 0 );
}

#endif  // _DEBUG

}  // namespace ATL

namespace ATL
{

#ifdef _DEBUG
#define DECLARE_TRACE_CATEGORY( name ) extern ATL::CTraceCategory name;
#else
#define DECLARE_TRACE_CATEGORY( name ) const DWORD_PTR name = 0;
#endif

DECLARE_TRACE_CATEGORY( atlTraceGeneral )
DECLARE_TRACE_CATEGORY( atlTraceCOM )
DECLARE_TRACE_CATEGORY( atlTraceQI )
DECLARE_TRACE_CATEGORY( atlTraceRegistrar )
DECLARE_TRACE_CATEGORY( atlTraceRefcount )
DECLARE_TRACE_CATEGORY( atlTraceWindowing )
DECLARE_TRACE_CATEGORY( atlTraceControls )
DECLARE_TRACE_CATEGORY( atlTraceHosting )
DECLARE_TRACE_CATEGORY( atlTraceDBClient )
DECLARE_TRACE_CATEGORY( atlTraceDBProvider )
DECLARE_TRACE_CATEGORY( atlTraceSnapin )
DECLARE_TRACE_CATEGORY( atlTraceNotImpl )
DECLARE_TRACE_CATEGORY( atlTraceAllocation )
DECLARE_TRACE_CATEGORY( atlTraceException )
DECLARE_TRACE_CATEGORY( atlTraceTime )
DECLARE_TRACE_CATEGORY( atlTraceCache )
DECLARE_TRACE_CATEGORY( atlTraceStencil )
DECLARE_TRACE_CATEGORY( atlTraceString )
DECLARE_TRACE_CATEGORY( atlTraceMap )
DECLARE_TRACE_CATEGORY( atlTraceUtil )
DECLARE_TRACE_CATEGORY( atlTraceSecurity )
DECLARE_TRACE_CATEGORY( atlTraceSync )
DECLARE_TRACE_CATEGORY( atlTraceISAPI )

// atlTraceUser categories are no longer needed.  Just declare your own trace category using CTraceCategory.
DECLARE_TRACE_CATEGORY( atlTraceUser )
DECLARE_TRACE_CATEGORY( atlTraceUser2 )
DECLARE_TRACE_CATEGORY( atlTraceUser3 )
DECLARE_TRACE_CATEGORY( atlTraceUser4 )

#pragma deprecated( atlTraceUser )
#pragma deprecated( atlTraceUser2 )
#pragma deprecated( atlTraceUser3 )
#pragma deprecated( atlTraceUser4 )

#ifdef _DEBUG

#ifndef _ATL_NO_DEBUG_CRT
class CNoUIAssertHook
{
public:
	CNoUIAssertHook()
	{
		ATLASSERT( s_pfnPrevHook == NULL );
		s_pfnPrevHook = _CrtSetReportHook(CrtHookProc);
	}
	~CNoUIAssertHook()
	{
		_CrtSetReportHook(s_pfnPrevHook);
		s_pfnPrevHook = NULL;
	}

private:
	static int __cdecl CrtHookProc(
		_In_ int eReportType,
		_In_z_ char* pszMessage,
		_Inout_ int* pnRetVal)
	{

		if (eReportType == _CRT_ASSERT)
		{
			::OutputDebugStringA( "ASSERTION FAILED\n" );
			::OutputDebugStringA( pszMessage );
			//If caller doesn't want retVal, so be it.
			if (pnRetVal != NULL)
			{
				*pnRetVal = 1;
			}
			return TRUE;
		}

		if (s_pfnPrevHook != NULL)
		{
			return s_pfnPrevHook(eReportType, pszMessage, pnRetVal);
		}
		else
		{
			return FALSE;
		}
	}

private:
	static _CRT_REPORT_HOOK s_pfnPrevHook;
};

__declspec( selectany ) _CRT_REPORT_HOOK CNoUIAssertHook::s_pfnPrevHook = NULL;

#define DECLARE_NOUIASSERT() ATL::CNoUIAssertHook _g_NoUIAssertHook;

#endif  // _ATL_NO_DEBUG_CRT

#ifndef ATLTRACE
#define ATLTRACE ATL::CTraceFileAndLineInfo(__FILE__, __LINE__)
#define ATLTRACE2 ATLTRACE
#endif

#pragma warning(push)
#pragma warning(disable : 4793)
inline void __cdecl AtlTrace(_In_z_ _Printf_format_string_ LPCSTR pszFormat, ...)
{
	va_list ptr;
	va_start(ptr, pszFormat);
	ATL::CTrace::s_trace.TraceV(NULL, -1, atlTraceGeneral, 0, pszFormat, ptr);
	va_end(ptr);
}
#pragma warning(pop)

#pragma warning(push)
#pragma warning(disable : 4793)
inline void __cdecl AtlTrace(_In_z_ _Printf_format_string_ LPCWSTR pszFormat, ...)
{
	va_list ptr;
	va_start(ptr, pszFormat);
	ATL::CTrace::s_trace.TraceV(NULL, -1, atlTraceGeneral, 0, pszFormat, ptr);
	va_end(ptr);
}
#pragma warning(pop)

#pragma warning(push)
#pragma warning(disable : 4793)
inline void __cdecl AtlTrace2(
	_In_ DWORD_PTR dwCategory,
	_In_ UINT nLevel,
	_In_z_ _Printf_format_string_ LPCSTR pszFormat, ...)
{
	va_list ptr;
	va_start(ptr, pszFormat);
	ATL::CTrace::s_trace.TraceV(NULL, -1, dwCategory, nLevel, pszFormat, ptr);
	va_end(ptr);
}
#pragma warning(pop)

#pragma warning(push)
#pragma warning(disable : 4793)
inline void __cdecl AtlTrace2(
	_In_ DWORD_PTR dwCategory,
	_In_ UINT nLevel,
	_In_z_ _Printf_format_string_ LPCWSTR pszFormat, ...)
{
	va_list ptr;
	va_start(ptr, pszFormat);
	ATL::CTrace::s_trace.TraceV(NULL, -1, dwCategory, nLevel, pszFormat, ptr);
	va_end(ptr);
}
#pragma warning(pop)

#define ATLTRACENOTIMPL(funcname)  do { ATLTRACE(ATL::atlTraceNotImpl, 0, _T("ATL: %s not implemented.\n"), funcname); return E_NOTIMPL; } while(0)

#else // !DEBUG

#pragma warning(push)
#pragma warning(disable : 4793)
inline void __cdecl AtlTraceNull(...)
{
}
inline void __cdecl AtlTrace(
	_In_z_ _Printf_format_string_ LPCSTR, ...)
{
}
inline void __cdecl AtlTrace2(
	_In_ DWORD_PTR,
	_In_ UINT,
	_In_z_ _Printf_format_string_ LPCSTR, ...)
{
}
inline void __cdecl AtlTrace(
	_In_z_ _Printf_format_string_ LPCWSTR, ...)
{
}
inline void __cdecl AtlTrace2(
	_In_ DWORD_PTR,
	_In_ UINT,
	_In_z_ _Printf_format_string_ LPCWSTR, ...)
{
}
#pragma warning(pop)

#ifndef ATLTRACE

#define ATLTRACE            __noop
#define ATLTRACE2           __noop
#endif //ATLTRACE
#define ATLTRACENOTIMPL(funcname)   return E_NOTIMPL
#define DECLARE_NOUIASSERT()

#endif //!_DEBUG

};  // namespace ATL
#pragma pack(pop)

#endif  // __ATLTRACE_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\include\atlwin.cpp ===
// This is a part of the Active Template Library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Active Template Library Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Active Template Library product.

#pragma message("atlwin.cpp is obsolete. Please remove it from your project.")

///////////////////////////////////////
// No longer used
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\include\atltypes.inl ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#ifndef __ATLTYPES_INL__
#define __ATLTYPES_INL__

#pragma once

#ifndef GET_X_LPARAM
#define GET_X_LPARAM(lp)                        ((int)(short)LOWORD(lp))
#endif
#ifndef GET_Y_LPARAM
#define GET_Y_LPARAM(lp)                        ((int)(short)HIWORD(lp))
#endif

#ifndef __ATLTYPES_H__
	#error atltypes.inl requires atltypes.h to be included first
#endif	// __ATLTYPES_H__

// CSize
ATLTYPES_INLINE CSize::CSize() throw()
{
	cx = 0;
	cy = 0;
}

ATLTYPES_INLINE CSize::CSize(
	_In_ int initCX,
	_In_ int initCY) throw()
{
	cx = initCX;
	cy = initCY;
}

ATLTYPES_INLINE CSize::CSize(_In_ SIZE initSize) throw()
{
	*(SIZE*)this = initSize;
}

ATLTYPES_INLINE CSize::CSize(_In_ POINT initPt) throw()
{
	*(POINT*)this = initPt;
}

ATLTYPES_INLINE CSize::CSize(_In_ DWORD dwSize) throw()
{
		cx = (short)LOWORD(dwSize);
		cy = (short)HIWORD(dwSize);
}

ATLTYPES_INLINE BOOL CSize::operator==(_In_ SIZE size) const throw()
{
	return (cx == size.cx && cy == size.cy);
}

ATLTYPES_INLINE BOOL CSize::operator!=(_In_ SIZE size) const throw()
{
	return (cx != size.cx || cy != size.cy);
}

ATLTYPES_INLINE void CSize::operator+=(_In_ SIZE size) throw()
{
	cx += size.cx;
	cy += size.cy;
}

ATLTYPES_INLINE void CSize::operator-=(_In_ SIZE size) throw()
{
	cx -= size.cx;
	cy -= size.cy;
}

ATLTYPES_INLINE void CSize::SetSize(
	_In_ int CX,
	_In_ int CY) throw()
{
	cx = CX;
	cy = CY;
}

ATLTYPES_INLINE CSize CSize::operator+(_In_ SIZE size) const throw()
{
	return CSize(cx + size.cx, cy + size.cy);
}

ATLTYPES_INLINE CSize CSize::operator-(_In_ SIZE size) const throw()
{
	return CSize(cx - size.cx, cy - size.cy);
}

ATLTYPES_INLINE CSize CSize::operator-() const throw()
{
	return CSize(-cx, -cy);
}

ATLTYPES_INLINE CPoint CSize::operator+(_In_ POINT point) const throw()
{
	return CPoint(cx + point.x, cy + point.y);
}

ATLTYPES_INLINE CPoint CSize::operator-(_In_ POINT point) const throw()
{
	return CPoint(cx - point.x, cy - point.y);
}

ATLTYPES_INLINE CRect CSize::operator+(_In_ const RECT* lpRect) const throw()
{
	return CRect(lpRect) + *this;
}

ATLTYPES_INLINE CRect CSize::operator-(_In_ const RECT* lpRect) const throw()
{
	return CRect(lpRect) - *this;
}

// CPoint
ATLTYPES_INLINE CPoint::CPoint() throw()
{
	x = 0;
	y = 0;
}

ATLTYPES_INLINE CPoint::CPoint(
	_In_ int initX,
	_In_ int initY) throw()
{
	x = initX;
	y = initY;
}

ATLTYPES_INLINE CPoint::CPoint(_In_ POINT initPt) throw()
{
	*(POINT*)this = initPt;
}

ATLTYPES_INLINE CPoint::CPoint(_In_ SIZE initSize) throw()
{
	*(SIZE*)this = initSize;
}

ATLTYPES_INLINE CPoint::CPoint(_In_ LPARAM dwPoint) throw()
{
	x = (short)GET_X_LPARAM(dwPoint);
	y = (short)GET_Y_LPARAM(dwPoint);
}

ATLTYPES_INLINE void CPoint::Offset(
	_In_ int xOffset,
	_In_ int yOffset) throw()
{
	x += xOffset;
	y += yOffset;
}

ATLTYPES_INLINE void CPoint::Offset(_In_ POINT point) throw()
{
	x += point.x;
	y += point.y;
}

ATLTYPES_INLINE void CPoint::Offset(_In_ SIZE size) throw()
{
	x += size.cx;
	y += size.cy;
}

ATLTYPES_INLINE void CPoint::SetPoint(
	_In_ int X,
	_In_ int Y) throw()
{
	x = X;
	y = Y;
}

ATLTYPES_INLINE BOOL CPoint::operator==(_In_ POINT point) const throw()
{
	return (x == point.x && y == point.y);
}

ATLTYPES_INLINE BOOL CPoint::operator!=(_In_ POINT point) const throw()
{
	return (x != point.x || y != point.y);
}

ATLTYPES_INLINE void CPoint::operator+=(_In_ SIZE size) throw()
{
	x += size.cx;
	y += size.cy;
}

ATLTYPES_INLINE void CPoint::operator-=(_In_ SIZE size) throw()
{
	x -= size.cx;
	y -= size.cy;
}

ATLTYPES_INLINE void CPoint::operator+=(_In_ POINT point) throw()
{
	x += point.x;
	y += point.y;
}

ATLTYPES_INLINE void CPoint::operator-=(_In_ POINT point) throw()
{
	x -= point.x;
	y -= point.y;
}

ATLTYPES_INLINE CPoint CPoint::operator+(_In_ SIZE size) const throw()
{
	return CPoint(x + size.cx, y + size.cy);
}

ATLTYPES_INLINE CPoint CPoint::operator-(_In_ SIZE size) const throw()
{
	return CPoint(x - size.cx, y - size.cy);
}

ATLTYPES_INLINE CPoint CPoint::operator-() const throw()
{
	return CPoint(-x, -y);
}

ATLTYPES_INLINE CPoint CPoint::operator+(_In_ POINT point) const throw()
{
	return CPoint(x + point.x, y + point.y);
}

ATLTYPES_INLINE CSize CPoint::operator-(_In_ POINT point) const throw()
{
	return CSize(x - point.x, y - point.y);
}

ATLTYPES_INLINE CRect CPoint::operator+(_In_ const RECT* lpRect) const throw()
{
	return CRect(lpRect) + *this;
}

ATLTYPES_INLINE CRect CPoint::operator-(_In_ const RECT* lpRect) const throw()
{
	return CRect(lpRect) - *this;
}

// CRect
ATLTYPES_INLINE CRect::CRect() throw()
{
	left = 0;
	top = 0;
	right = 0;
	bottom = 0;
}

ATLTYPES_INLINE CRect::CRect(
	_In_ int l,
	_In_ int t,
	_In_ int r,
	_In_ int b) throw()
{
	left = l;
	top = t;
	right = r;
	bottom = b;
}

ATLTYPES_INLINE CRect::CRect(_In_ const RECT& srcRect) throw()
{
	::CopyRect(this, &srcRect);
}

ATLTYPES_INLINE CRect::CRect(_In_ LPCRECT lpSrcRect) throw()
{
	::CopyRect(this, lpSrcRect);
}

ATLTYPES_INLINE CRect::CRect(
	_In_ POINT point,
	_In_ SIZE size) throw()
{
	right = (left = point.x) + size.cx;
	bottom = (top = point.y) + size.cy;
}

ATLTYPES_INLINE CRect::CRect(
	_In_ POINT topLeft,
	_In_ POINT bottomRight) throw()
{
	left = topLeft.x;
	top = topLeft.y;
	right = bottomRight.x;
	bottom = bottomRight.y;
}

ATLTYPES_INLINE int CRect::Width() const throw()
{
	return right - left;
}

ATLTYPES_INLINE int CRect::Height() const throw()
{
	return bottom - top;
}

ATLTYPES_INLINE CSize CRect::Size() const throw()
{
	return CSize(right - left, bottom - top);
}

ATLTYPES_INLINE CPoint& CRect::TopLeft() throw()
{
	return *((CPoint*)this);
}

ATLTYPES_INLINE CPoint& CRect::BottomRight() throw()
{
	return *((CPoint*)this+1);
}

ATLTYPES_INLINE const CPoint& CRect::TopLeft() const throw()
{
	return *((CPoint*)this);
}

ATLTYPES_INLINE const CPoint& CRect::BottomRight() const throw()
{
	return *((CPoint*)this+1);
}

ATLTYPES_INLINE CPoint CRect::CenterPoint() const throw()
{
	return CPoint((left+right)/2, (top+bottom)/2);
}

ATLTYPES_INLINE void CRect::SwapLeftRight() throw()
{
	SwapLeftRight(LPRECT(this));
}

ATLTYPES_INLINE void WINAPI CRect::SwapLeftRight(_Inout_ LPRECT lpRect) throw()
{
	LONG temp = lpRect->left;
	lpRect->left = lpRect->right;
	lpRect->right = temp;
}

ATLTYPES_INLINE CRect::operator LPRECT() throw()
{
	return this;
}

ATLTYPES_INLINE CRect::operator LPCRECT() const throw()
{
	return this;
}

ATLTYPES_INLINE BOOL CRect::IsRectEmpty() const throw()
{
	return ::IsRectEmpty(this);
}

ATLTYPES_INLINE BOOL CRect::IsRectNull() const throw()
{
	return (left == 0 && right == 0 && top == 0 && bottom == 0);
}

ATLTYPES_INLINE BOOL CRect::PtInRect(_In_ POINT point) const throw()
{
	return ::PtInRect(this, point);
}

ATLTYPES_INLINE void CRect::SetRect(
	_In_ int x1,
	_In_ int y1,
	_In_ int x2,
	_In_ int y2) throw()
{
	::SetRect(this, x1, y1, x2, y2);
}

ATLTYPES_INLINE void CRect::SetRect(
	_In_ POINT topLeft,
	_In_ POINT bottomRight) throw()
{
	::SetRect(this, topLeft.x, topLeft.y, bottomRight.x, bottomRight.y);
}

ATLTYPES_INLINE void CRect::SetRectEmpty() throw()
{
	::SetRectEmpty(this);
}

ATLTYPES_INLINE void CRect::CopyRect(_In_ LPCRECT lpSrcRect) throw()
{
	::CopyRect(this, lpSrcRect);
}

ATLTYPES_INLINE BOOL CRect::EqualRect(_In_ LPCRECT lpRect) const throw()
{
	return ::EqualRect(this, lpRect);
}

ATLTYPES_INLINE void CRect::InflateRect(
	_In_ int x,
	_In_ int y) throw()
{
	::InflateRect(this, x, y);
}

ATLTYPES_INLINE void CRect::InflateRect(SIZE size) throw()
{
	::InflateRect(this, size.cx, size.cy);
}

ATLTYPES_INLINE void CRect::DeflateRect(
	_In_ int x,
	_In_ int y) throw()
{
	::InflateRect(this, -x, -y);
}

ATLTYPES_INLINE void CRect::DeflateRect(_In_ SIZE size) throw()
{
	::InflateRect(this, -size.cx, -size.cy);
}

ATLTYPES_INLINE void CRect::OffsetRect(
	_In_ int x,
	_In_ int y) throw()
{
	::OffsetRect(this, x, y);
}

ATLTYPES_INLINE void CRect::OffsetRect(_In_ POINT point) throw()
{
	::OffsetRect(this, point.x, point.y);
}

ATLTYPES_INLINE void CRect::OffsetRect(_In_ SIZE size) throw()
{
	::OffsetRect(this, size.cx, size.cy);
}

ATLTYPES_INLINE void CRect::MoveToY(_In_ int y) throw()
{
	bottom = Height() + y;
	top = y;
}

ATLTYPES_INLINE void CRect::MoveToX(_In_ int x) throw()
{
	right = Width() + x;
	left = x;
}

ATLTYPES_INLINE void CRect::MoveToXY(
	_In_ int x,
	_In_ int y) throw()
{
	MoveToX(x);
	MoveToY(y);
}

ATLTYPES_INLINE void CRect::MoveToXY(_In_ POINT pt) throw()
{
	MoveToX(pt.x);
	MoveToY(pt.y);
}

ATLTYPES_INLINE BOOL CRect::IntersectRect(
	_In_ LPCRECT lpRect1,
	_In_ LPCRECT lpRect2) throw()
{
	return ::IntersectRect(this, lpRect1, lpRect2);
}

ATLTYPES_INLINE BOOL CRect::UnionRect(
	_In_ LPCRECT lpRect1,
	_In_ LPCRECT lpRect2) throw()
{
	return ::UnionRect(this, lpRect1, lpRect2);
}

ATLTYPES_INLINE void CRect::operator=(_In_ const RECT& srcRect) throw()
{
	::CopyRect(this, &srcRect);
}

ATLTYPES_INLINE BOOL CRect::operator==(_In_ const RECT& rect) const throw()
{
	return ::EqualRect(this, &rect);
}

ATLTYPES_INLINE BOOL CRect::operator!=(_In_ const RECT& rect) const throw()
{
	return !::EqualRect(this, &rect);
}

ATLTYPES_INLINE void CRect::operator+=(_In_ POINT point) throw()
{
	::OffsetRect(this, point.x, point.y);
}

ATLTYPES_INLINE void CRect::operator+=(_In_ SIZE size) throw()
{
	::OffsetRect(this, size.cx, size.cy);
}

ATLTYPES_INLINE void CRect::operator+=(_In_ LPCRECT lpRect) throw()
{
	InflateRect(lpRect);
}

ATLTYPES_INLINE void CRect::operator-=(_In_ POINT point) throw()
{
	::OffsetRect(this, -point.x, -point.y);
}

ATLTYPES_INLINE void CRect::operator-=(_In_ SIZE size) throw()
{
	::OffsetRect(this, -size.cx, -size.cy);
}

ATLTYPES_INLINE void CRect::operator-=(_In_ LPCRECT lpRect) throw()
{
	DeflateRect(lpRect);
}

ATLTYPES_INLINE void CRect::operator&=(_In_ const RECT& rect) throw()
{
	::IntersectRect(this, this, &rect);
}

ATLTYPES_INLINE void CRect::operator|=(_In_ const RECT& rect) throw()
{
	::UnionRect(this, this, &rect);
}

ATLTYPES_INLINE CRect CRect::operator+(_In_ POINT pt) const throw()
{
	CRect rect(*this);
	::OffsetRect(&rect, pt.x, pt.y);
	return rect;
}

ATLTYPES_INLINE CRect CRect::operator-(_In_ POINT pt) const throw()
{
	CRect rect(*this);
	::OffsetRect(&rect, -pt.x, -pt.y);
	return rect;
}

ATLTYPES_INLINE CRect CRect::operator+(_In_ SIZE size) const throw()
{
	CRect rect(*this);
	::OffsetRect(&rect, size.cx, size.cy);
	return rect;
}

ATLTYPES_INLINE CRect CRect::operator-(_In_ SIZE size) const throw()
{
	CRect rect(*this);
	::OffsetRect(&rect, -size.cx, -size.cy);
	return rect;
}

ATLTYPES_INLINE CRect CRect::operator+(_In_ LPCRECT lpRect) const throw()
{
	CRect rect(this);
	rect.InflateRect(lpRect);
	return rect;
}

ATLTYPES_INLINE CRect CRect::operator-(_In_ LPCRECT lpRect) const throw()
{
	CRect rect(this);
	rect.DeflateRect(lpRect);
	return rect;
}

ATLTYPES_INLINE CRect CRect::operator&(_In_ const RECT& rect2) const throw()
{
	CRect rect;
	::IntersectRect(&rect, this, &rect2);
	return rect;
}

ATLTYPES_INLINE CRect CRect::operator|(_In_ const RECT& rect2) const throw()
{
	CRect rect;
	::UnionRect(&rect, this, &rect2);
	return rect;
}

ATLTYPES_INLINE BOOL CRect::SubtractRect(
	_In_ LPCRECT lpRectSrc1,
	_In_ LPCRECT lpRectSrc2) throw()
{
	return ::SubtractRect(this, lpRectSrc1, lpRectSrc2);
}

ATLTYPES_INLINE void CRect::NormalizeRect() throw()
{
	int nTemp;
	if (left > right)
	{
		nTemp = left;
		left = right;
		right = nTemp;
	}
	if (top > bottom)
	{
		nTemp = top;
		top = bottom;
		bottom = nTemp;
	}
}

ATLTYPES_INLINE void CRect::InflateRect(_In_ LPCRECT lpRect) throw()
{
	left -= lpRect->left;
	top -= lpRect->top;
	right += lpRect->right;
	bottom += lpRect->bottom;
}

ATLTYPES_INLINE void CRect::InflateRect(
	_In_ int l,
	_In_ int t,
	_In_ int r,
	_In_ int b) throw()
{
	left -= l;
	top -= t;
	right += r;
	bottom += b;
}

ATLTYPES_INLINE void CRect::DeflateRect(_In_ LPCRECT lpRect) throw()
{
	left += lpRect->left;
	top += lpRect->top;
	right -= lpRect->right;
	bottom -= lpRect->bottom;
}

ATLTYPES_INLINE void CRect::DeflateRect(
	_In_ int l,
	_In_ int t,
	_In_ int r,
	_In_ int b) throw()
{
	left += l;
	top += t;
	right -= r;
	bottom -= b;
}

ATLTYPES_INLINE CRect CRect::MulDiv(
	_In_ int nMultiplier,
	_In_ int nDivisor) const throw()
{
	return CRect(
		::MulDiv(left, nMultiplier, nDivisor),
		::MulDiv(top, nMultiplier, nDivisor),
		::MulDiv(right, nMultiplier, nDivisor),
		::MulDiv(bottom, nMultiplier, nDivisor));
}


#endif	// __ATLTYPES_INL__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\include\atlutil.h ===
// This is a part of the Active Template Library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Active Template Library Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Active Template Library product.

#ifndef __ATLUTIL_H__
#define __ATLUTIL_H__

#pragma once
#include <stdio.h>
#include <string.h>
#include <crtdbg.h>
#include <stdlib.h>
#include <mbstring.h>
#include <atldef.h>
#include <imagehlp.h>
#include <atlbase.h>
#include <atlstr.h>
#include <atlcoll.h>
#include <atlenc.h>
#include <atlcom.h>
#include <atlpath.h>

#ifndef _ATL_NO_DEFAULT_LIBS

#pragma comment(lib, "dbghelp.lib")

#endif  // !_ATL_NO_DEFAULT_LIBS

#pragma warning( push )
#pragma warning( disable: 4127 )
#pragma warning(disable: 4625) // copy constructor could not be generated because a base class copy constructor is inaccessible
#pragma warning(disable: 4626) // assignment operator could not be generated because a base class assignment operator is inaccessible
#pragma warning(disable: 4061) // enumerate 'enum value' in switch of enum 'enum type' is not explicitly handled by a case label
#pragma warning(disable: 4571) //catch(...) blocks compiled with /EHs do NOT catch or re-throw Structured Exceptions

extern "C" WINBASEAPI
BOOL
WINAPI
IsDebuggerPresent
(
	VOID
);

#pragma pack(push,_ATL_PACKING)
namespace ATL {

template <typename CharType>
inline BOOL AtlIsFullPathT(_In_count_c_(3) const CharType* szPath)
{
	ATLENSURE( szPath != NULL );
	//Full path len >= 2
	if (szPath[0] == '\0' || szPath[1] == '\0')
	{
		return FALSE;
	}
	if (*szPath == '"') //"<path>" - skip the quote.
	{
		szPath++;
	}
	if (szPath[1]==':')		// drive: case
	{
		return TRUE;
	}
	if (szPath[0]=='\\' && szPath[1]=='\\' &&
		szPath[2] != '\0' ) // unc path name
	{
		return TRUE;
	}
	return FALSE;

}

inline BOOL IsFullPath(_In_count_c_(3) LPCTSTR szPath) throw()
{
	return AtlIsFullPathT(szPath);
}

inline BOOL IsFullPathA(_In_count_c_(3) LPCSTR szPath) throw()
{
	return AtlIsFullPathT(szPath);
}


#pragma warning(push)
#pragma warning(disable : 4706)

// this function is different from the the CRT
// strncpy in that it does not pad out the whole string with zeroes
inline char * __cdecl _strncpy(
	_Out_z_cap_(count) char * dest,
	_In_z_count_(count) const char * source,
	_In_ size_t count) throw()
{
	ATLASSERT( dest != NULL );
	ATLASSERT( source != NULL );
	if(!dest || count==0)
	{
		return NULL;
	}
	if(dest!=source)
	{
		dest[0]='\0';
	}
	if(!source && count>0)
	{
		return NULL;
	}

	char *start = dest;

	while (count && (*dest++ = *source++))
	{
		count--;
	}

	return(start);
}
#pragma warning(pop)

inline bool _SafeStringCopy(
	_Out_z_cap_(nLen) char *szDest,
	_In_z_count_(nLen) const char *szSrc,
	_In_ size_t nLen) throw()
{
	ATLASSERT( szDest != NULL );
	ATLASSERT( szSrc != NULL );

	// initialize for check below
	szDest[nLen-1] = '\0';

	_strncpy(szDest, szSrc, nLen);
	if ('\0' != szDest[nLen-1])
	{
		// string was too large
		szDest[nLen-1] = '\0';
		return false;
	}
	return true;
}

template <class T>
inline bool SafeStringCopy(
	_Inout_ T& Destination,
	_In_z_ const char* Source) throw()
{
	// Copy up to the size of the buffer
	return _SafeStringCopy(Destination, Source, sizeof(Destination));
}

#if(_WIN32_WINNT >= 0x0400)
// Helper class for reverting the thread impersonation token
// and then restoring it back to what it was
class CRevertThreadToken
{
public:
	HANDLE m_hThreadToken;

	CRevertThreadToken() throw()
	{
		m_hThreadToken = INVALID_HANDLE_VALUE;
	}

	~CRevertThreadToken() throw()
	{
		// should have been Restore()'d by now.
#ifdef _DEBUG
		if(m_hThreadToken != INVALID_HANDLE_VALUE)
			DebugBreak();
#endif
	}

	// When called, this function
	// makes a copy of the thread's impersonation token
	// and then calls RevertToSelf() to revert the impersonation
	// level to the process
	// call Restore() to restore the impersonation
	// token
	BOOL Initialize() throw()
	{
		if (OpenThreadToken(GetCurrentThread(), TOKEN_IMPERSONATE |	TOKEN_DUPLICATE, FALSE, &m_hThreadToken))
		{
			if (!RevertToSelf())
			{
				CloseHandle(m_hThreadToken);
				m_hThreadToken = INVALID_HANDLE_VALUE;
				return FALSE;
			}
			return TRUE;
		}
		return FALSE;
	}

	DWORD Restore() throw()
	{
		DWORD dwError = NO_ERROR;
		if (m_hThreadToken != INVALID_HANDLE_VALUE)
		{
			if (!SetThreadToken(NULL, m_hThreadToken))
			{
				dwError = ::GetLastError();
			}
			CloseHandle(m_hThreadToken);
			m_hThreadToken = INVALID_HANDLE_VALUE;
		}
		return dwError;
	}
};
#else
// Dummy version for downlevel support
class CRevertThreadToken
{
public:
	BOOL Initialize() throw()
	{
		return FALSE;
	}
	DWORD Restore() throw()
	{
		return 0;
	}
};
#endif // _WIN32_WINNT >= 0x0400)

#ifndef ATL_ISAPI_BUFFER_SIZE
#define ATL_ISAPI_BUFFER_SIZE 4096
#endif

//typedefs and defines for CUrl (essentially the same as the ones from wininet, but with an ATL_ prepended)
typedef WORD ATL_URL_PORT;

enum ATL_URL_SCHEME
{
	ATL_URL_SCHEME_UNKNOWN = -1,
	ATL_URL_SCHEME_FTP     = 0,
	ATL_URL_SCHEME_GOPHER  = 1,
	ATL_URL_SCHEME_HTTP    = 2,
	ATL_URL_SCHEME_HTTPS   = 3,
	ATL_URL_SCHEME_FILE    = 4,
	ATL_URL_SCHEME_NEWS    = 5,
	ATL_URL_SCHEME_MAILTO  = 6,
	ATL_URL_SCHEME_SOCKS   = 7,
};


#define ATL_URL_MAX_HOST_NAME_LENGTH   256
#define ATL_URL_MAX_USER_NAME_LENGTH   128
#define ATL_URL_MAX_PASSWORD_LENGTH    128
#define ATL_URL_MAX_PORT_NUMBER_LENGTH 5           // ATL_URL_PORT is unsigned short
#define ATL_URL_MAX_PORT_NUMBER_VALUE  65535       // maximum unsigned short value
#define ATL_URL_MAX_PATH_LENGTH        2048
#define ATL_URL_MAX_SCHEME_LENGTH      32          // longest protocol name length
#define ATL_URL_MAX_URL_LENGTH         (ATL_URL_MAX_SCHEME_LENGTH \
									   + sizeof("://") \
									   + ATL_URL_MAX_PATH_LENGTH)

#define ATL_URL_INVALID_PORT_NUMBER    0           // use the protocol-specific default

#define ATL_URL_DEFAULT_FTP_PORT       21          // default for FTP servers
#define ATL_URL_DEFAULT_GOPHER_PORT    70          //    "     "  gopher "
#define ATL_URL_DEFAULT_HTTP_PORT      80          //    "     "  HTTP   "
#define ATL_URL_DEFAULT_HTTPS_PORT     443         //    "     "  HTTPS  "
#define ATL_URL_DEFAULT_SOCKS_PORT     1080        // default for SOCKS firewall servers.

__interface IStackDumpHandler
{
public:
	void __stdcall OnBegin();
	void __stdcall OnEntry(
		_In_ void *pvAddress,
		_In_opt_z_ LPCSTR szModule,
		_In_opt_z_ LPCSTR szSymbol);
	void __stdcall OnError(_In_z_ LPCSTR szError);
	void __stdcall OnEnd();
};

#define ATL_MODULE_NAME_LEN _MAX_PATH
#define ATL_SYMBOL_NAME_LEN 1024

// Helper class for generating a stack dump
// This is used internally by AtlDumpStack
class CStackDumper
{
public:
	struct _ATL_SYMBOL_INFO
	{
		ULONG_PTR dwAddress;
		ULONG_PTR dwOffset;
		CHAR	szModule[ATL_MODULE_NAME_LEN];
		CHAR	szSymbol[ATL_SYMBOL_NAME_LEN];
	};

	static LPVOID __stdcall FunctionTableAccess(
		_In_ HANDLE hProcess,
		_In_ ULONG_PTR dwPCAddress)
	{
		return SymFunctionTableAccess(hProcess, dwPCAddress);
	}

	static ULONG_PTR __stdcall GetModuleBase(
		_In_ HANDLE hProcess,
		_In_ ULONG_PTR dwReturnAddress)
	{
		IMAGEHLP_MODULE moduleInfo;
		moduleInfo.SizeOfStruct = sizeof(IMAGEHLP_MODULE);

		if (SymGetModuleInfo(hProcess, dwReturnAddress, &moduleInfo))
		{
			return moduleInfo.BaseOfImage;
		}
		else
		{
			MEMORY_BASIC_INFORMATION memoryBasicInfo;

			if (::VirtualQueryEx(hProcess, (LPVOID) dwReturnAddress, &memoryBasicInfo, sizeof(memoryBasicInfo)))
			{
				DWORD cch = 0;

				typedef DWORD64 (__stdcall * PFNSYMLOADMODULEEXW)(HANDLE, HANDLE, PCWSTR, PCWSTR, DWORD64, DWORD, PMODLOAD_DATA, DWORD);
				PFNSYMLOADMODULEEXW pfnSymLoadModuleExW = NULL;
				HMODULE hDbgHelp = GetModuleHandleW(L"dbghelp.dll");
				if (hDbgHelp != NULL)
				{
					pfnSymLoadModuleExW = (PFNSYMLOADMODULEEXW)GetProcAddress(hDbgHelp, "SymLoadModuleExW");
					if (pfnSymLoadModuleExW != NULL)
					{
						WCHAR szFile[MAX_PATH] = { 0 };
						cch = GetModuleFileNameW((HINSTANCE)memoryBasicInfo.AllocationBase, szFile, MAX_PATH);

						// Ignore the return code since we can't do anything with it.
						pfnSymLoadModuleExW(hProcess, NULL, ((cch) ? szFile : NULL), NULL, (DWORD_PTR) memoryBasicInfo.AllocationBase, 0, NULL, 0);
						return (DWORD_PTR) memoryBasicInfo.AllocationBase;
					}
				}

				char szFile[MAX_PATH] = { 0 };

				cch = GetModuleFileNameA((HINSTANCE)memoryBasicInfo.AllocationBase, szFile, MAX_PATH);

				// Ignore the return code since we can't do anything with it.
				SymLoadModule(hProcess, NULL, ((cch) ? szFile : NULL), NULL, (DWORD_PTR) memoryBasicInfo.AllocationBase, 0);
				return (DWORD_PTR) memoryBasicInfo.AllocationBase;
			}
		}
		return 0;
	}

	static BOOL ResolveSymbol(
		_In_ HANDLE hProcess,
		_In_ UINT_PTR dwAddress,
		_Out_ _ATL_SYMBOL_INFO &siSymbol)
	{
		BOOL fRetval = TRUE;

		siSymbol.dwAddress = dwAddress;

		CHAR szUndec[ATL_SYMBOL_NAME_LEN];
		CHAR szWithOffset[ATL_SYMBOL_NAME_LEN];
		LPSTR pszSymbol = NULL;
		IMAGEHLP_MODULE mi;

		memset(&siSymbol, 0, sizeof(_ATL_SYMBOL_INFO));
		mi.SizeOfStruct = sizeof(IMAGEHLP_MODULE);

		if (!SymGetModuleInfo(hProcess, dwAddress, &mi))
		{
			Checked::strcpy_s(siSymbol.szModule, _countof(siSymbol.szModule), "<no module>");
		}
		else
		{
			LPSTR pszModule = strchr(mi.ImageName, '\\');
			if (pszModule == NULL)
				pszModule = mi.ImageName;
			else
				pszModule++;

			Checked::strncpy_s(siSymbol.szModule, _countof(siSymbol.szModule), pszModule, _TRUNCATE);
		}

		__try
		{
			union
			{
				CHAR rgchSymbol[sizeof(IMAGEHLP_SYMBOL) + ATL_SYMBOL_NAME_LEN];
				IMAGEHLP_SYMBOL  sym;
			} sym;
			memset(&sym.sym, 0x00, sizeof(sym.sym));
			sym.sym.SizeOfStruct = sizeof(IMAGEHLP_SYMBOL);
			sym.sym.Address = dwAddress;
			sym.sym.MaxNameLength = ATL_SYMBOL_NAME_LEN;

			if (SymGetSymFromAddr(hProcess, dwAddress, &(siSymbol.dwOffset), &sym.sym))
			{
				pszSymbol = sym.sym.Name;

				if (UnDecorateSymbolName(sym.sym.Name, szUndec, _countof(szUndec),
					UNDNAME_NO_MS_KEYWORDS | UNDNAME_NO_ACCESS_SPECIFIERS))
				{
					pszSymbol = szUndec;
				}
				else if (SymUnDName(&sym.sym, szUndec, _countof(szUndec)))
				{
					pszSymbol = szUndec;
				}
				if (siSymbol.dwOffset != 0)
				{
#ifdef _WIN64
					sprintf_s(szWithOffset, ATL_SYMBOL_NAME_LEN, "%s + %I64d bytes", pszSymbol, siSymbol.dwOffset);
#else
					sprintf_s(szWithOffset, ATL_SYMBOL_NAME_LEN, "%s + %d bytes", pszSymbol, siSymbol.dwOffset);						
#endif

					// ensure null-terminated
					szWithOffset[ATL_SYMBOL_NAME_LEN-1] = '\0';

					pszSymbol = szWithOffset;
				}
		  }
		  else
			  pszSymbol = "<no symbol>";
		}
		__except (EXCEPTION_ACCESS_VIOLATION == GetExceptionCode())
		{
			pszSymbol = "<EX: no symbol>";
			siSymbol.dwOffset = dwAddress - mi.BaseOfImage;
		}

		Checked::strncpy_s(siSymbol.szSymbol, _countof(siSymbol.szSymbol), pszSymbol, _TRUNCATE);
		return fRetval;
	}
};

#ifndef _ATL_MAX_STACK_FRAMES
#define _ATL_MAX_STACK_FRAMES 256
#endif

class _AtlThreadContextInfo
{
public:
	HANDLE             hThread; //Thread to get context for
	CONTEXT            context; //Where to put context
	IStackDumpHandler* pHandler;
	_AtlThreadContextInfo(_In_ IStackDumpHandler* p) throw()
	{
		hThread = NULL;
		memset(&context, 0, sizeof(context));
		context.ContextFlags = CONTEXT_FULL;
		pHandler = p;
	}
	~_AtlThreadContextInfo() throw()
	{
		if (hThread != NULL)
			CloseHandle(hThread);
	}
#pragma warning(push)
#pragma warning(disable:4793)
	HRESULT DumpStack() throw()
	{
		//We can't just call GetThreadContext for the current thread.
		//The docs state this is incorrect and we see problems on x64/Itanium

		//We need to spin up another thread which suspends this thread and gets
		//this thread's context, then unsuspends this thread and signals it.

		HANDLE hThreadPseudo = ::GetCurrentThread();
		HANDLE hProcess = ::GetCurrentProcess();
		if (DuplicateHandle(hProcess, hThreadPseudo, hProcess, &hThread, 0, FALSE, DUPLICATE_SAME_ACCESS) == 0)
			return HRESULT_FROM_WIN32(GetLastError());

		DWORD dwID;
		HANDLE hWorkerThread = CreateThread(NULL, 0, ContextThreadProc, this, 0, &dwID);
		if (hWorkerThread == NULL)
			return HRESULT_FROM_WIN32(GetLastError());
		//Wait for thread to terminate which will indicate it is done.
		//On CE we can't suspend this thread while in the kernel, so loop
		//rather than just waiting.
		while (WaitForSingleObject(hWorkerThread, 0) != WAIT_OBJECT_0)
		{
		}
		CloseHandle(hWorkerThread);
		return S_OK;
	}
	static DWORD WINAPI ContextThreadProc(_In_ LPVOID pv) throw()
	{
		_AtlThreadContextInfo* pThis =
			reinterpret_cast< _AtlThreadContextInfo* >(pv);
		return pThis->DoDumpStack();
	}
	DWORD DoDumpStack() throw()
	{
		SuspendThread(hThread);
		GetThreadContext(hThread, &context);

		pHandler->OnBegin();

		CAtlArray<void *> adwAddress;
		HANDLE hProcess = ::GetCurrentProcess();
		if (SymInitialize(hProcess, NULL, TRUE))
		{
			// force undecorated names to get params
			DWORD dw = SymGetOptions();
			dw &= ~SYMOPT_UNDNAME;
			SymSetOptions(dw);

			STACKFRAME stackFrame;
			memset(&stackFrame, 0, sizeof(stackFrame));
			stackFrame.AddrPC.Mode = AddrModeFlat;
			stackFrame.AddrFrame.Mode = AddrModeFlat;
			stackFrame.AddrStack.Mode = AddrModeFlat;
			stackFrame.AddrReturn.Mode = AddrModeFlat;
			stackFrame.AddrBStore.Mode = AddrModeFlat;

			DWORD dwMachType;

#if defined(_M_IX86)
			dwMachType                   = IMAGE_FILE_MACHINE_I386;

			// program counter, stack pointer, and frame pointer
			stackFrame.AddrPC.Offset     = context.Eip;
			stackFrame.AddrStack.Offset  = context.Esp;
			stackFrame.AddrFrame.Offset  = context.Ebp;
#elif defined(_M_AMD64)
			// only program counter
			dwMachType                   = IMAGE_FILE_MACHINE_AMD64;
			stackFrame.AddrPC.Offset     = context.Rip;
#elif defined(_M_MRX000)
			// only program counter
			dwMachType                   = IMAGE_FILE_MACHINE_R4000;
			stackFrame.AddrPC.Offset     = context.Fir;
#elif defined(_M_IA64)
			// only program counter
			dwMachType                   = IMAGE_FILE_MACHINE_IA64;
			stackFrame.AddrPC.Offset     = context.StIIP;
#else
#error("Unknown Target Machine");
#endif

			adwAddress.SetCount(0, 16);

			int nFrame;
			for (nFrame = 0; nFrame < _ATL_MAX_STACK_FRAMES; nFrame++)
			{
				if (!StackWalk(dwMachType, hProcess, hThread,
					&stackFrame, &context, NULL,
					CStackDumper::FunctionTableAccess, CStackDumper::GetModuleBase, NULL))
				{
					break;
				}
				if (stackFrame.AddrPC.Offset != 0)
					adwAddress.Add((void*)(DWORD_PTR)stackFrame.AddrPC.Offset);
			}

			// dump it out now
			INT_PTR nAddress;
			INT_PTR cAddresses = adwAddress.GetCount();
			for (nAddress = 0; nAddress < cAddresses; nAddress++)
			{
				CStackDumper::_ATL_SYMBOL_INFO info;
				UINT_PTR dwAddress = (UINT_PTR)adwAddress[nAddress];

				LPCSTR szModule = NULL;
				LPCSTR szSymbol = NULL;

				if (CStackDumper::ResolveSymbol(hProcess, dwAddress, info))
				{
					szModule = info.szModule;
					szSymbol = info.szSymbol;
				}
				pHandler->OnEntry((void *) dwAddress, szModule, szSymbol);
			}

			SymCleanup(hProcess);
		}

		pHandler->OnEnd();
		ResumeThread(hThread);

		return 0;
	}
};

// Helper function to produce a stack dump
ATL_NOINLINE inline void AtlDumpStack(_In_ IStackDumpHandler *pHandler)
{
	ATLASSERT(pHandler);
	_AtlThreadContextInfo info(pHandler);
	info.DumpStack();
}
#pragma warning(pop)

#define STACK_TRACE_PART_DELIMITER ';'
#define STACK_TRACE_LINE_DELIMITER '~'

// CReportHookDumpHandler is a stack dump handler
// that gathers the stack dump into the format
// used by CDebugReportHook
class CReportHookDumpHandler : 
	public IStackDumpHandler
{
public:
	CReportHookDumpHandler()
	{
		m_pstr = NULL;
	}

	void GetStackDump(_In_ CStringA *pstr)
	{
		ATLASSERT(pstr);
		SetString(pstr);
		AtlDumpStack(this);
		SetString(NULL);
	}

	void SetString(_In_opt_ CStringA *pstr)
	{
		m_pstr = pstr;
	}

	// implementation
	// IStackDumpHandler methods
	void __stdcall OnBegin()
	{
	}

	void __stdcall OnEntry(
		_In_ void *pvAddress,
		_In_opt_z_ LPCSTR szModule,
		_In_opt_z_ LPCSTR szSymbol)
	{
		// make sure SetString was called before
		// trying to get a stack dump
		ATLASSUME(m_pstr);
		if (!m_pstr)
			return;

		char szBuf[100];
		sprintf_s(szBuf, _countof(szBuf), "0x%p;", pvAddress);
		// ensure null-terminated
		szBuf[sizeof(szBuf)-1] = '\0';
		*m_pstr += szBuf;
		if (!szModule)
			szModule = "Unknown";
		if (!szSymbol)
			szSymbol = "<No Info>";

		*m_pstr += szModule;
		*m_pstr += STACK_TRACE_PART_DELIMITER;
		ATLASSERT(szSymbol);
		*m_pstr += szSymbol;
		*m_pstr += STACK_TRACE_PART_DELIMITER;
		*m_pstr += STACK_TRACE_LINE_DELIMITER;
	}

	void __stdcall OnError(_In_opt_z_ LPCSTR /*szError*/)
	{
	}
	void __stdcall OnEnd()
	{
	}

protected:
	CStringA *m_pstr;

};

#define PIPE_INPUT_BUFFER_SIZE  4096
#define PIPE_OUTPUT_BUFFER_SIZE 2048

enum
{
	DEBUG_SERVER_MESSAGE_TRACE,
	DEBUG_SERVER_MESSAGE_ASSERT,
	DEBUG_SERVER_MESSAGE_QUIT
};

struct DEBUG_SERVER_MESSAGE
{
	DWORD dwType;		// one of DEBUG_SERVER_MESSAGE_*
	DWORD dwProcessId;	// process id of client
	DWORD dwClientNameLen;	// length of client name
	size_t dwTextLen;	// length of text message including null terminator
	BOOL bIsDebuggerAttached;	// TRUE if the debugger is already attached
};

#ifdef _DEBUG

class CDebugReportHook
{
protected:

	static char m_szPipeName[MAX_PATH+1];
	static DWORD m_dwTimeout;
	static DWORD m_dwClientNameLen;
	static char m_szClientName[MAX_COMPUTERNAME_LENGTH+1];

public:
	CDebugReportHook(
		_In_z_ LPCSTR szMachineName = ".",
		_In_z_ LPCSTR szPipeName = "AtlsDbgPipe",
		_In_ DWORD dwTimeout = 20000) throw()
	{
		if (SetPipeName(szMachineName, szPipeName))
		{
			SetTimeout(dwTimeout);
			SetHook();
		}
		m_dwClientNameLen = sizeof(m_szClientName);
		GetComputerNameA(m_szClientName, &m_dwClientNameLen);
	}

	~CDebugReportHook() throw()
	{
		RemoveHook();
	}

	BOOL SetPipeName(
		_In_z_ LPCSTR szMachineName = ".",
		_In_z_ LPCSTR szPipeName = "AtlsDbgPipe") throw()
	{
		if (sprintf_s(m_szPipeName, MAX_PATH, "\\\\%s\\pipe\\%s", szMachineName, szPipeName) != -1)
		{
			return TRUE;
		}
		return FALSE;
	}

	void SetTimeout(_In_ DWORD dwTimeout)
	{
		m_dwTimeout = dwTimeout;
	}

	void SetHook() throw()
	{
#ifdef _DEBUG
		ATLASSERT( _CrtSetReportHook2(_CRT_RPTHOOK_INSTALL, CDebugReportHookProc) != -1 );
#else
		_CrtSetReportHook2(_CRT_RPTHOOK_INSTALL, CDebugReportHookProc);
#endif
	}

	void RemoveHook() throw()
	{
#ifdef _DEBUG
		ATLASSERT( _CrtSetReportHook2(_CRT_RPTHOOK_REMOVE, CDebugReportHookProc) != -1 );
#else
		_CrtSetReportHook2(_CRT_RPTHOOK_REMOVE, CDebugReportHookProc);
#endif
	}

	static int __cdecl CDebugReportHookProc(
		_In_ int reportType,
		_In_z_ char *message,
		_Inout_ int *returnValue) throw()
	{
		//Cannot ensure since it may recurse - throw directly.
		if (message == NULL)
		{
			AtlThrow(E_INVALIDARG);
		}
		DWORD dwWritten;
		if (returnValue!=NULL)
		{
			*returnValue = 0;
		}

		CRevertThreadToken revert;
		if (!revert.Initialize())
			return FALSE;

		CHandle hdlPipe;
		while (1)
		{
			// we're opening an untrusted server. prevent the server from getting our privileges through impersonation
			HANDLE hPipe = CreateFileA(m_szPipeName, GENERIC_WRITE | GENERIC_READ,
				FILE_SHARE_READ | FILE_SHARE_WRITE, NULL, OPEN_EXISTING, SECURITY_SQOS_PRESENT | SECURITY_IDENTIFICATION | SECURITY_EFFECTIVE_ONLY, NULL);

			if (hPipe != INVALID_HANDLE_VALUE )
			{
				hdlPipe.Attach(hPipe);
				break;
			}

			if (GetLastError() != ERROR_PIPE_BUSY)
			{
				if (revert.Restore())
				{
#ifdef _DEBUG
					DebugBreak();
#endif
				}
				if (reportType == _CRT_ASSERT)
					return TRUE;
				return FALSE;
			}

			//If the pipe is busy, we wait for up to m_dwTimeout
			if (!WaitNamedPipeA(m_szPipeName, m_dwTimeout))
			{
				if (revert.Restore())
				{
#ifdef _DEBUG
					DebugBreak();
#endif
				}
				if (reportType == _CRT_ASSERT)
					return TRUE;
				return FALSE;
			}
		}

		DEBUG_SERVER_MESSAGE Message;

		Message.bIsDebuggerAttached = IsDebuggerPresent();

		if (reportType == _CRT_ASSERT)
		{
			Message.dwType = DEBUG_SERVER_MESSAGE_ASSERT;
		}
		else
		{
			Message.dwType = DEBUG_SERVER_MESSAGE_TRACE;
		}

		Message.dwProcessId = GetCurrentProcessId();
		Message.dwClientNameLen = m_dwClientNameLen+1;	// add 1 for the null terminator
		Message.dwTextLen = strlen(message)+1;

		int nRet = 1;

		WriteFile(hdlPipe, &Message, sizeof(DEBUG_SERVER_MESSAGE), &dwWritten, NULL);

		WriteFile(hdlPipe, m_szClientName, Message.dwClientNameLen, &dwWritten, NULL);

		WriteFile(hdlPipe, message, (DWORD)Message.dwTextLen, &dwWritten, NULL);

		//Check to see whether or not to send stack trace
		BOOL bRet = ReadFile(hdlPipe, &nRet, sizeof(nRet), &dwWritten, NULL);

		//if nRet == 1, the user wants stack trace info
		if (bRet && nRet)
		{
			_ATLTRY
			{
				CStringA str;
				CReportHookDumpHandler stackDumper;
				stackDumper.GetStackDump(&str);
				if (!WriteFile(hdlPipe, (LPCSTR)str, str.GetLength(), &dwWritten, NULL))
				{
					if (revert.Restore())
					{
	#ifdef _DEBUG
						DebugBreak();
	#endif
					}
					return (reportType == _CRT_ASSERT ? TRUE : FALSE);
				}
			}
			_ATLCATCHALL()
			{
				if (revert.Restore())
				{
#ifdef _DEBUG
					DebugBreak();
#endif
				}
				return (reportType == _CRT_ASSERT ? TRUE : FALSE);
			}
		}

		if (bRet)
			bRet = ReadFile(hdlPipe, &nRet, sizeof(nRet), &dwWritten, NULL);
		if (!bRet)
			nRet = 0;

		if (revert.Restore())
		{
#ifdef _DEBUG
			DebugBreak();
#endif
		}

		// possible return values
		// 0 -> Ignore or cancel
		// 1 -> Retry
		// 2 -> Abort
		if (nRet == 0)
		{
			return (reportType == _CRT_ASSERT ? TRUE : FALSE);
		}
		if (nRet == 1)
		{
			if (IsDebuggerPresent())
			{
				DebugBreak();
			}
		}

		if (nRet == 2)
			abort();

		return (reportType == _CRT_ASSERT ? TRUE : FALSE);
	}
}; // class CDebugReportHook


__declspec(selectany) char CDebugReportHook::m_szPipeName[MAX_PATH+1];
__declspec(selectany) DWORD CDebugReportHook::m_dwTimeout;
__declspec(selectany) DWORD CDebugReportHook::m_dwClientNameLen;
__declspec(selectany) char CDebugReportHook::m_szClientName[MAX_COMPUTERNAME_LENGTH+1];
#endif

#ifndef ATL_POOL_NUM_THREADS
	#define ATL_POOL_NUM_THREADS 0
#endif

#ifndef ATL_POOL_STACK_SIZE
	#define ATL_POOL_STACK_SIZE 0
#endif

#ifndef ATLS_DEFAULT_THREADSPERPROC
	#define ATLS_DEFAULT_THREADSPERPROC 2
#endif

#ifndef ATLS_DEFAULT_THREADPOOLSHUTDOWNTIMEOUT
	#define ATLS_DEFAULT_THREADPOOLSHUTDOWNTIMEOUT 36000
#endif

// IThreadPoolConfig
// Used to configure the worker thread pool. This can be used by any
// client of the CThreadPool class.
__interface __declspec(uuid("B1F64757-6E88-4fa2-8886-7848B0D7E660"))
	IThreadPoolConfig : public IUnknown
{
	STDMETHOD(SetSize)(_In_ int nNumThreads);
	STDMETHOD(GetSize)(_Out_ int *pnNumThreads);
	STDMETHOD(SetTimeout)(_In_ DWORD dwMaxWait);
	STDMETHOD(GetTimeout)(_Out_ DWORD *pdwMaxWait);
};

//
// CThreadPool
// This class is a simple IO completion port based thread pool
//	Worker:
//		is a class that is responsible for handling requests
//		queued on the thread pool.
//		It must have a typedef for RequestType, where request type
//		is the datatype to be queued on the pool
//		RequestType must be castable to (DWORD)
//		The value -1 is reserved for shutdown
//		of the pool
//		Worker must also have a void Execute(RequestType request, void *pvParam, OVERLAPPED *pOverlapped) function
//	ThreadTraits:
//		is a class that implements a static CreateThread function
//		This allows for overriding how the threads are created
#define ATLS_POOL_SHUTDOWN ((OVERLAPPED*) ((__int64) -1))
ATLPREFAST_SUPPRESS(6387)
template <class Worker, class ThreadTraits=DefaultThreadTraits, class WaitTraits=DefaultWaitTraits>
class CThreadPool : 
	public IThreadPoolConfig
{
protected:

	CSimpleMap<DWORD, HANDLE> m_threadMap;

	DWORD m_dwThreadEventId;

	CComCriticalSection m_critSec;
	DWORD m_dwStackSize;
	DWORD m_dwMaxWait;

	void *m_pvWorkerParam;
	LONG m_bShutdown;

	HANDLE m_hThreadEvent;
	HANDLE m_hRequestQueue;

public:

	CThreadPool() throw() :
		m_hRequestQueue(NULL),
		m_pvWorkerParam(NULL),
		m_dwMaxWait(ATLS_DEFAULT_THREADPOOLSHUTDOWNTIMEOUT),
		m_bShutdown(FALSE),
		m_dwThreadEventId(0),
		m_dwStackSize(0)
	{
	}

	virtual ~CThreadPool() throw()
	{
		Shutdown();
	}

	// Initialize the thread pool
	// if nNumThreads > 0, then it specifies the number of threads
	// if nNumThreads < 0, then it specifies the number of threads per proc (-)
	// if nNumThreads == 0, then it defaults to two threads per proc
	// hCompletion is a handle of a file to associate with the completion port
	// pvWorkerParam is a parameter that will be passed to Worker::Execute
	//	dwStackSize:
	//		The stack size to use when creating the threads
	_Check_return_ HRESULT Initialize(
		_In_opt_ void *pvWorkerParam=NULL,
		_In_ int nNumThreads=0,
		_In_ DWORD dwStackSize=0,
		_In_ HANDLE hCompletion=INVALID_HANDLE_VALUE) throw()
	{
		ATLASSUME( m_hRequestQueue == NULL );

		if (m_hRequestQueue)   // Already initialized
			return AtlHresultFromWin32(ERROR_ALREADY_INITIALIZED);

		if (S_OK != m_critSec.Init())
			return E_FAIL;

		m_hThreadEvent = CreateEvent(NULL, FALSE, FALSE, NULL);
		if (!m_hThreadEvent)
		{
			m_critSec.Term();
			return AtlHresultFromLastError();
		}

		// Create IO completion port to queue the requests
		m_hRequestQueue = CreateIoCompletionPort(hCompletion, NULL, 0, nNumThreads);
		if (m_hRequestQueue == NULL)
		{
			// failed creating the Io completion port
			m_critSec.Term();
			CloseHandle(m_hThreadEvent);
			return AtlHresultFromLastError();
		}
		m_pvWorkerParam = pvWorkerParam;
		m_dwStackSize = dwStackSize;

		HRESULT hr = SetSize(nNumThreads);
		if (hr != S_OK)
		{
			// Close the request queue handle
			CloseHandle(m_hRequestQueue);

			// Clear the queue handle
			m_hRequestQueue = NULL;

			// Uninitialize the critical sections
			m_critSec.Term();
			CloseHandle(m_hThreadEvent);


			return hr;
		}

		return S_OK;
	}

	// Shutdown the thread pool
	// This function posts the shutdown request to all the threads in the pool
	// It will wait for the threads to shutdown a maximum of dwMaxWait MS.
	// If the timeout expires it just returns without terminating the threads.
	void Shutdown(_In_ DWORD dwMaxWait=0) throw()
	{
		if (!m_hRequestQueue)   // Not initialized
			return;

		CComCritSecLock<CComCriticalSection> lock(m_critSec, false);
		if (FAILED(lock.Lock()))
		{
			// out of memory
			ATLASSERT( FALSE );
			return;
		}


		if (dwMaxWait == 0)
			dwMaxWait = m_dwMaxWait;

		HRESULT hr = InternalResizePool(0, dwMaxWait);

		if (hr != S_OK)
			ATLTRACE(atlTraceUtil, 0, _T("Thread pool not shutting down cleanly : %08x"), hr);
			// If the threads have not returned, then something is wrong

		for (int i = m_threadMap.GetSize() - 1; i >= 0; i--)
		{
			HANDLE hThread = m_threadMap.GetValueAt(i);
			DWORD dwExitCode;
			GetExitCodeThread(hThread, &dwExitCode);
			if (dwExitCode == STILL_ACTIVE)
			{
ATLPREFAST_SUPPRESS(6258)
				/* deliberate design choice to use TerminateThread here in extremis */
				ATLTRACE(atlTraceUtil, 0, _T("Terminating thread"));
				TerminateThread(hThread, 0);
ATLPREFAST_UNSUPPRESS()
			}
			CloseHandle(hThread);
		}

		// Close the request queue handle
		CloseHandle(m_hRequestQueue);

		// Clear the queue handle
		m_hRequestQueue = NULL;

		ATLASSUME(m_threadMap.GetSize() == 0);

		// Uninitialize the critical sections
		lock.Unlock();
		m_critSec.Term();
		CloseHandle(m_hThreadEvent);

	}

	// IThreadPoolConfig methods
	_Check_return_ HRESULT STDMETHODCALLTYPE SetSize(_In_ int nNumThreads) throw()
	{
		if (nNumThreads == 0)
			nNumThreads = -ATLS_DEFAULT_THREADSPERPROC;

		if (nNumThreads < 0)
		{
			SYSTEM_INFO si;
			GetSystemInfo(&si);
			nNumThreads = (int) (-nNumThreads) * si.dwNumberOfProcessors;
		}

		return InternalResizePool(nNumThreads, m_dwMaxWait);
	}

	_Check_return_ HRESULT STDMETHODCALLTYPE GetSize(_Out_ int *pnNumThreads) throw()
	{
		if (!pnNumThreads)
			return E_POINTER;

		*pnNumThreads = GetNumThreads();
		return S_OK;
	}

	_Check_return_ HRESULT STDMETHODCALLTYPE SetTimeout(_In_ DWORD dwMaxWait) throw()
	{
		m_dwMaxWait = dwMaxWait;

		return S_OK;
	}

	_Check_return_ HRESULT STDMETHODCALLTYPE GetTimeout(_Out_ DWORD *pdwMaxWait) throw()
	{
		if (!pdwMaxWait)
			return E_POINTER;

		*pdwMaxWait = m_dwMaxWait;

		return S_OK;
	}

	// IUnknown methods
	_Check_return_ HRESULT STDMETHODCALLTYPE QueryInterface(
		_In_ REFIID riid,
		_Deref_out_ void** ppv) throw()
	{
		if (!ppv)
			return E_POINTER;

		*ppv = NULL;

		if (InlineIsEqualGUID(riid, __uuidof(IUnknown)) ||
			InlineIsEqualGUID(riid, __uuidof(IThreadPoolConfig)))
		{
			*ppv = static_cast<IThreadPoolConfig*>(this);
			AddRef();
			return S_OK;
		}
		return E_NOINTERFACE;
	}

	ULONG STDMETHODCALLTYPE AddRef() throw()
	{
		return 1;
	}

	ULONG STDMETHODCALLTYPE Release() throw()
	{
		return 1;
	}

	HANDLE GetQueueHandle() throw()
	{
		return m_hRequestQueue;
	}

	int GetNumThreads() throw()
	{
		return m_threadMap.GetSize();
	}

	// QueueRequest adds a request to the thread pool
	// it will be picked up by one of the threads and dispatched to the worker
	// in WorkerThreadProc
	BOOL QueueRequest(_In_ typename Worker::RequestType request) throw()
	{
		ATLASSUME( m_hRequestQueue != NULL );

		if (!PostQueuedCompletionStatus(m_hRequestQueue, 0, (ULONG_PTR) request, NULL))
			return FALSE;
		return TRUE;
	}

protected:

	DWORD ThreadProc() throw()
	{
		DWORD dwBytesTransfered;
		ULONG_PTR dwCompletionKey;

		OVERLAPPED* pOverlapped;

		// this block is to ensure theWorker gets destructed before the
		// thread handle is closed
		{
			// We instantiate an instance of the worker class on the stack
			// for the life time of the thread.
			Worker theWorker;

			if (theWorker.Initialize(m_pvWorkerParam) == FALSE)
			{
				return 1;
			}

			SetEvent(m_hThreadEvent);
			// Get the request from the IO completion port
			while (GetQueuedCompletionStatus(m_hRequestQueue, &dwBytesTransfered, &dwCompletionKey, &pOverlapped, INFINITE))
			{
				if (pOverlapped == ATLS_POOL_SHUTDOWN) // Shut down
				{
					LONG bResult = InterlockedExchange(&m_bShutdown, FALSE);
					if (bResult) // Shutdown has not been cancelled
						break;

					// else, shutdown has been cancelled -- continue as before
				}
				else										// Do work
				{
					Worker::RequestType request = (Worker::RequestType) dwCompletionKey;

					// Process the request.  Notice the following:
					// (1) It is the worker's responsibility to free any memory associated
					// with the request if the request is complete
					// (2) If the request still requires some more processing
					// the worker should queue the request again for dispatching
					theWorker.Execute(request, m_pvWorkerParam, pOverlapped);
				}
			}

			theWorker.Terminate(m_pvWorkerParam);
		}

		m_dwThreadEventId = GetCurrentThreadId();
		SetEvent(m_hThreadEvent);

		return 0;
	}

	static DWORD WINAPI WorkerThreadProc(_In_ LPVOID pv) throw()
	{
		CThreadPool* pThis =
			reinterpret_cast< CThreadPool* >(pv);

		return pThis->ThreadProc();
	}

	_Check_return_ HRESULT InternalResizePool(
		_In_ int nNumThreads,
		_In_ int dwMaxWait) throw()
	{
		if (!m_hRequestQueue)   // Not initialized
			return E_FAIL;

		CComCritSecLock<CComCriticalSection> lock(m_critSec, false);
		if (FAILED(lock.Lock()))
		{
			// out of memory
			ATLASSERT( FALSE );
			return E_FAIL;
		}

		int nCurThreads = m_threadMap.GetSize();
		if (nNumThreads == nCurThreads)
		{
			return S_OK;
		}
		else if (nNumThreads < nCurThreads)
		{
			int nNumShutdownThreads = nCurThreads - nNumThreads;
			for (int nThreadIndex = 0; nThreadIndex < nNumShutdownThreads; nThreadIndex++)
			{
				ResetEvent(m_hThreadEvent);

				InterlockedExchange(&m_bShutdown, TRUE);
				PostQueuedCompletionStatus(m_hRequestQueue, 0, 0, ATLS_POOL_SHUTDOWN);
				DWORD dwRet = WaitTraits::WaitForSingleObject(m_hThreadEvent, dwMaxWait);

				if (dwRet == WAIT_TIMEOUT)
				{
					LONG bResult = InterlockedExchange(&m_bShutdown, FALSE);
					if (bResult) // Nobody picked up the shutdown message
					{
						return AtlHresultFromWin32(WAIT_TIMEOUT);
					}
				}
				else if (dwRet != WAIT_OBJECT_0)
				{
					return AtlHresultFromLastError();
				}

				int nIndex = m_threadMap.FindKey(m_dwThreadEventId);
				if (nIndex != -1)
				{
					HANDLE hThread = m_threadMap.GetValueAt(nIndex);
					// Wait for the thread to shutdown
					if (WaitTraits::WaitForSingleObject(hThread, 60000) == WAIT_OBJECT_0)
					{
						CloseHandle(hThread);
						m_threadMap.RemoveAt(nIndex);
					}
					else
					{
						// Thread failed to terminate
						return E_FAIL;
					}
				}
			}
		}
		else
		{
			int nNumNewThreads = nNumThreads - nCurThreads;
			// Create and initialize worker threads

			for (int nThreadIndex = 0; nThreadIndex < nNumNewThreads; nThreadIndex++)
			{
				DWORD dwThreadID;
				ResetEvent(m_hThreadEvent);
				CHandle hdlThread( ThreadTraits::CreateThread(NULL, m_dwStackSize, WorkerThreadProc, (LPVOID)this, 0, &dwThreadID) );

				if (!hdlThread)
				{
					HRESULT hr = AtlHresultFromLastError();
					ATLASSERT(hr != S_OK);
					return hr;
				}

				DWORD dwRet = WaitTraits::WaitForSingleObject(m_hThreadEvent, dwMaxWait);
				if (dwRet != WAIT_OBJECT_0)
				{
					if (dwRet == WAIT_TIMEOUT)
					{
						return HRESULT_FROM_WIN32(WAIT_TIMEOUT);
					}
					else
					{
						return AtlHresultFromLastError();
					}
				}

				if (m_threadMap.Add(dwThreadID, hdlThread) != FALSE)
				{
					hdlThread.Detach();
				}
			}
		}
		return S_OK;
	}
}; // class CThreadPool
ATLPREFAST_UNSUPPRESS()

//
// CNonStatelessWorker
// This class is a simple wrapper for use with CThreadPool.
//	It instantiates one instance of Worker per request
//	this allows Worker to hold state for each request
//	and depend on the destructor being called
//	Worker:
//		is a class that is responsible for handling requests
//		queued on the thread pool (See CThreadPool)
template <class Worker>
class CNonStatelessWorker
{
public:
	typedef typename Worker::RequestType RequestType;

	BOOL Initialize(_In_opt_ void * /*pvParam*/) throw()
	{
		return TRUE;
	}

	void Execute(
		_In_ typename Worker::RequestType request,
		_In_ void *pvWorkerParam,
		_In_ OVERLAPPED *pOverlapped)
	{
		Worker worker;
		if (worker.Initialize(pvWorkerParam))
		{
			worker.Execute(request, pvWorkerParam, pOverlapped);
			worker.Terminate(pvWorkerParam);
		}
	}
	void Terminate(_In_opt_ void* /*pvParam*/) throw()
	{
	}
}; // class CNonStatelessWorker


//Flags
#define ATL_URL_ESCAPE             1   // (un)escape URL characters
#define ATL_URL_NO_ENCODE          2   // Don't convert unsafe characters to escape sequence
#define ATL_URL_DECODE             4   // Convert %XX escape sequences to characters
#define ATL_URL_NO_META            8   // Don't convert .. etc. meta path sequences
#define ATL_URL_ENCODE_SPACES_ONLY 16  // Encode spaces only
#define ATL_URL_BROWSER_MODE       32  // Special encode/decode rules for browser
#define ATL_URL_ENCODE_PERCENT     64  // Encode percent (by default, not encoded)
#define ATL_URL_CANONICALIZE       128 // Internal: used by Canonicalize for AtlEscapeUrl: Cannot be set via SetFlags
#define ATL_URL_COMBINE            256 // Internal: Cannot be set via SetFlags


//Get the decimal value of a hexadecimal character
inline short AtlHexValue(_In_ char chIn) throw()
{
	unsigned char ch = (unsigned char)chIn;
	if (ch >= '0' && ch <= '9')
		return (short)(ch - '0');
	if (ch >= 'A' && ch <= 'F')
		return (short)(ch - 'A' + 10);
	if (ch >= 'a' && ch <= 'f')
		return (short)(ch - 'a' + 10);
	return -1;
}


//Determine if the character is unsafe under the URI RFC document
inline BOOL AtlIsUnsafeUrlChar(_In_ char chIn) throw()
{
	unsigned char ch = (unsigned char)chIn;
	switch(ch)
	{
		case ';': case '\\': case '?': case '@': case '&':
		case '=': case '+': case '$': case ',': case ' ':
		case '<': case '>': case '#': case '%': case '\"':
		case '{': case '}': case '|':
		case '^': case '[': case ']': case '`':
			return TRUE;
		default:
		{
			if (ch < 32 || ch > 126)
				return TRUE;
			return FALSE;
		}
	}
}

//Get the default internet port for a particular scheme
inline ATL_URL_PORT AtlGetDefaultUrlPort(_In_ ATL_URL_SCHEME m_nScheme) throw()
{
	switch (m_nScheme)
	{
		case ATL_URL_SCHEME_FTP:
			return ATL_URL_DEFAULT_FTP_PORT;
		case ATL_URL_SCHEME_GOPHER:
			return ATL_URL_DEFAULT_GOPHER_PORT;
		case ATL_URL_SCHEME_HTTP:
			return ATL_URL_DEFAULT_HTTP_PORT;
		case ATL_URL_SCHEME_HTTPS:
			return ATL_URL_DEFAULT_HTTPS_PORT;
		case ATL_URL_SCHEME_SOCKS:
			return ATL_URL_DEFAULT_SOCKS_PORT;
		default:
			return ATL_URL_INVALID_PORT_NUMBER;
	}
}

//Escape a meta sequence with lpszOutUrl as the base url and lpszInUrl as the relative url
//i.e. lpszInUrl = ./* or ../*
ATL_NOINLINE inline BOOL AtlEscapeUrlMetaHelper(
	_Deref_inout_z_ LPSTR* ppszOutUrl,
	_In_z_ LPCSTR szPrev,
	_In_ DWORD dwOutLen,
	_Deref_inout_z_ LPSTR* ppszInUrl,
	_Out_ DWORD* pdwLen,
	_In_ DWORD dwFlags = 0,
	_In_ DWORD dwColonPos = ATL_URL_MAX_URL_LENGTH)
{
	ATLENSURE( ppszOutUrl != NULL );
	ATLENSURE( szPrev != NULL );
	ATLENSURE( ppszInUrl != NULL );
	ATLENSURE( pdwLen != NULL);

	LPSTR szOut = *ppszOutUrl;
	LPSTR szIn = *ppszInUrl;
	DWORD dwUrlLen = dwOutLen;
	char chPrev = *szPrev;
	BOOL bRet = FALSE;

	//if the previous character is a directory delimiter
	if (chPrev == '/' || chPrev == '\\')
	{
		char chNext = *szIn;

		//if the next character is a directory delimiter
		if (chNext == '/' || chNext == '\\')
		{
			//the meta sequence is of the form /./*
			szIn++;
			bRet = TRUE;
		}
		else if (chNext == '.' && ((chNext = *(szIn+1)) == '/' ||
			chNext == '\\' || chNext == '\0'))
		{
			//otherwise if the meta sequence is of the form "/../"
			//skip the preceding "/"
			szOut--;

			//skip the ".." of the meta sequence
			szIn+= 2;
			DWORD dwOutPos = dwUrlLen-1;
			LPSTR szTmp = szOut;

			//while we are not at the beginning of the base url
			while (dwOutPos)
			{
				szTmp--;
				dwOutPos--;

				//if it is a directory delimiter
				if (*szTmp == '/' || *szTmp == '\\')
				{
					//if we are canonicalizing the url and NOT combining it
					//and if we have encountered the ':' or we are at a position before the ':'
					if ((dwFlags & ATL_URL_CANONICALIZE) && ((dwFlags & ATL_URL_COMBINE) == 0) &&
						(dwColonPos && (dwOutPos <= dwColonPos+1)))
					{
						//NOTE: this is to match the way that InternetCanonicalizeUrl and
						//      InternetCombineUrl handle this case
						break;
					}

					//otherwise, set the current output string position to right after the '/'
					szOut = szTmp+1;

					//update the length to match
					dwUrlLen = dwOutPos+1;
					bRet = TRUE;
					break;
				}
			}

			//if we could not properly escape the meta sequence
			if (dwUrlLen != dwOutPos+1)
			{
				//restore everything to its original value
				szIn-= 2;
				szOut++;
			}
			else
			{
				bRet = TRUE;
			}
		}
	}
	//update the strings
	*ppszOutUrl = szOut;
	*ppszInUrl = szIn;
	*pdwLen = dwUrlLen;
	return bRet;
}

//Convert all unsafe characters in szStringIn to escape sequences
//lpszStringIn and lpszStringOut should be different strings
inline BOOL AtlEscapeUrl(
	_In_z_ LPCSTR szStringIn,
	_Out_z_cap_post_count_(dwMaxLength, *pdwStrLen) LPSTR szStringOut,
	_Out_opt_ DWORD* pdwStrLen,
	_In_ DWORD dwMaxLength,
	_In_ DWORD dwFlags = 0)
{
	ATLENSURE( szStringIn != NULL );
	ATLENSURE( szStringOut != NULL );
	ATLENSURE( szStringIn != szStringOut );

	char ch;
	DWORD dwLen = 0;
	BOOL bRet = TRUE;
	BOOL bSchemeFile = FALSE;
	DWORD dwColonPos = 0;
	DWORD dwFlagsInternal = dwFlags;
	//The next 2 are for buffer security checks
	LPSTR szOrigStringOut=szStringOut;
	LPSTR szStringOutEnd = (szStringOut + dwMaxLength);

	while((ch = *szStringIn++) != '\0')
	{
		//if we are at the maximum length, set bRet to FALSE
		//this ensures no more data is written to szStringOut, but
		//the length of the string is still updated, so the user
		//knows how much space to allocate
		if (dwLen == dwMaxLength)
		{
			bRet = FALSE;
		}

		//Keep track of the first ':' position to match the weird way
		//InternetCanonicalizeUrl handles it
		if (ch == ':' && (dwFlagsInternal & ATL_URL_CANONICALIZE) && !dwColonPos)
		{
			if (bRet)
			{
				*szStringOut = '\0';
				LPSTR pszStrToLower=szStringOut-dwLen;
				ATLENSURE(pszStrToLower >= szOrigStringOut &&  pszStrToLower <= szStringOutEnd);
				Checked::strlwr_s(pszStrToLower,szStringOutEnd-pszStrToLower+1);

				if (dwLen == 4 && !strncmp("file", (szStringOut-4), 4))
				{
					bSchemeFile = TRUE;
				}
			}

			dwColonPos = dwLen+1;
		}
		else if (ch == '%' && (dwFlagsInternal & ATL_URL_DECODE))
		{
			//decode the escaped sequence
			if (*szStringIn != '\0')
			{
				short nFirstDigit = AtlHexValue(*szStringIn++);

				if( nFirstDigit < 0 )
				{
					bRet = FALSE;
					break;
				}
				ch = static_cast<char>(16*nFirstDigit);
				if (*szStringIn != '\0')
				{
					short nSecondDigit = AtlHexValue(*szStringIn++);

					if( nSecondDigit < 0 )
					{
						bRet = FALSE;
						break;
					}
					ch = static_cast<char>(ch+nSecondDigit);
				}
				else
				{
					break;
				}
			}
			else
			{
				break;
			}
		}
		else if ((ch == '?' || ch == '#') && (dwFlagsInternal & ATL_URL_BROWSER_MODE))
		{
			//ATL_URL_BROWSER mode does not encode after a '?' or a '#'
			dwFlagsInternal |= ATL_URL_NO_ENCODE;
		}

		if ((dwFlagsInternal & ATL_URL_CANONICALIZE) && (dwFlagsInternal & ATL_URL_NO_ENCODE)==0)
		{
			//canonicalize the '\' to '/'
			if (ch == '\\' && (dwColonPos || (dwFlagsInternal & ATL_URL_COMBINE)) && bRet)
			{
				//if the scheme is not file or it is file and the '\' is in "file:\\"
				//NOTE: This is to match the way InternetCanonicalizeUrl handles this case
				if (!bSchemeFile || (dwLen < 7))
				{
					ch = '/';
				}
			}
			else if (ch == '.' && dwLen > 0 && (dwFlagsInternal & ATL_URL_NO_META)==0)
			{
				//if we are escaping meta sequences, attempt to do so
				if (AtlEscapeUrlMetaHelper(&szStringOut, szStringOut-1, dwLen, (char**)(&szStringIn), &dwLen, dwFlagsInternal, dwColonPos))
					continue;
			}
		}

		//if we are encoding and it is an unsafe character
		if (AtlIsUnsafeUrlChar(ch) && (dwFlagsInternal & ATL_URL_NO_ENCODE)==0)
		{
			//if we are only encoding spaces, and ch is not a space or
			//if we are not encoding meta sequences and it is a dot or
			//if we not encoding percents and it is a percent
			if (((dwFlagsInternal & ATL_URL_ENCODE_SPACES_ONLY) && ch != ' ') ||
				((dwFlagsInternal & ATL_URL_NO_META) && ch == '.') ||
				(((dwFlagsInternal & ATL_URL_ENCODE_PERCENT) == 0) && ch == '%'))
			{
				//just output it without encoding
				if (bRet)
					*szStringOut++ = ch;
			}
			else
			{
				//if there is not enough space for the escape sequence
				if (dwLen >= (dwMaxLength-3))
				{
					bRet = FALSE;
				}
				if (bRet)
				{
					//output the percent, followed by the hex value of the character
					LPSTR pszTmp = szStringOut;
					*pszTmp++ = '%';
					if ((unsigned char)ch < 16)
					{
						*pszTmp++ = '0';
					}
					Checked::ultoa_s((unsigned char)ch, pszTmp, szStringOutEnd-pszTmp, 16);
					szStringOut+= sizeof("%FF")-1;
				}
				dwLen += sizeof("%FF")-2;
			}
		}
		else //safe character
		{
			if (bRet)
				*szStringOut++ = ch;
		}
		dwLen++;
	}

	if (bRet && dwLen < dwMaxLength)
		*szStringOut = '\0';

	if (pdwStrLen)
		*pdwStrLen = dwLen + 1;

	if (dwLen+1 > dwMaxLength)
		bRet = FALSE;

	return bRet;
}

inline BOOL AtlEscapeUrl(
	_In_z_ LPCWSTR szStringIn,
	_Out_z_cap_post_count_(dwMaxLength, *pdwStrLen) LPWSTR szStringOut,
	_Out_opt_ DWORD* pdwStrLen,
	_In_ DWORD dwMaxLength,
	_In_ DWORD dwFlags = 0)
{
	ATLENSURE( szStringIn != NULL );
	ATLENSURE( szStringOut != NULL );
	// convert to UTF8
	BOOL bRet = FALSE;

	int nSrcLen = (int) wcslen(szStringIn);
	if (nSrcLen == 0) // handle the case of an empty string
	{
		if (pdwStrLen != NULL)
		{
			*pdwStrLen = 1; //one for null
	    }
        *szStringOut = '\0';
		return TRUE;
	}
	int nCnt = AtlUnicodeToUTF8(szStringIn, nSrcLen, NULL, 0);
	if (nCnt != 0)
	{
		nCnt++;
		CHeapPtr<char> szIn;

		char szInBuf[ATL_URL_MAX_URL_LENGTH];
		char *pszIn = szInBuf;

		// try to avoid allocation
		if (nCnt <= 0)
		{
			return FALSE;
		}

		if (nCnt > ATL_URL_MAX_URL_LENGTH)
		{
			if (!szIn.AllocateBytes(nCnt))
			{
				// out of memory
				return FALSE;
			}
			pszIn = szIn;
		}

		nCnt = AtlUnicodeToUTF8(szStringIn, nSrcLen, pszIn, nCnt);
		ATLASSERT( nCnt != 0 );

		pszIn[nCnt] = '\0';

		char szOutBuf[ATL_URL_MAX_URL_LENGTH];
		char *pszOut = szOutBuf;
		CHeapPtr<char> szTmp;

		// try to avoid allocation
		if (dwMaxLength > ATL_URL_MAX_URL_LENGTH)
		{
			if (!szTmp.AllocateBytes(dwMaxLength))
			{
				// out of memory
				return FALSE;
			}
			pszOut = szTmp;
		}

		DWORD dwStrLen = 0;
		bRet = AtlEscapeUrl(pszIn, pszOut, &dwStrLen, dwMaxLength, dwFlags);
		if (bRet != FALSE)
		{
			// it is now safe to convert using any codepage, since there
			// are no non-ASCII characters
			_ATLTRY
			{
				Checked::wmemcpy_s(szStringOut, dwMaxLength, CA2W( pszOut ), dwStrLen);
			}
			_ATLCATCHALL()
			{
				bRet = FALSE;
			}
		}
		if (pdwStrLen)
		{
			*pdwStrLen = dwStrLen;
		}
	}

	return bRet;
}

//Convert all escaped characters in szString to their real values
//lpszStringIn and lpszStringOut can be the same string
inline BOOL AtlUnescapeUrl(
	_In_z_ LPCSTR szStringIn,
	_Out_z_cap_post_count_(dwMaxLength, *pdwStrLen) LPSTR szStringOut,
	_Out_opt_ LPDWORD pdwStrLen,
	_In_ DWORD dwMaxLength)
{
	ATLENSURE(szStringIn != NULL);
	ATLENSURE(szStringOut != NULL);

	int nValue = 0;
	char ch;
	DWORD dwLen = 0;
	BOOL bRet = TRUE;
	while ((ch = *szStringIn) != 0)
	{
		if (dwLen == dwMaxLength)
			bRet = FALSE;

		if (bRet)
		{
			if (ch == '%')
			{
				if ((*(szStringIn+1) == '\0') || (*(szStringIn+2) == '\0'))
				{
					bRet = FALSE;
					break;
				}
				ch = *(++szStringIn);
				//currently assuming 2 hex values after '%'
				//as per the RFC 2396 document
				short nFirstDigit = AtlHexValue(ch);
				short nSecondDigit = AtlHexValue(*(++szStringIn));

				if(nFirstDigit < 0 || nSecondDigit < 0)
				{
					bRet = FALSE;
					break;
				}
				nValue = 16*nFirstDigit;
				nValue+= nSecondDigit;
				*szStringOut++ = static_cast<char>(nValue);
			}
			else //non-escape character
			{
				if (bRet)
					*szStringOut++ = ch;
			}
		}
		dwLen++;
		szStringIn++;
	}

	if (bRet && dwLen < dwMaxLength)
		*szStringOut = '\0';

	if (pdwStrLen)
		*pdwStrLen = dwLen + 1;

	if (dwLen+1 > dwMaxLength)
		bRet = FALSE;

	return bRet;
}

inline BOOL AtlUnescapeUrl(
	_In_z_ LPCWSTR szStringIn,
	_Out_z_cap_post_count_(dwMaxLength, *pdwStrLen) LPWSTR szStringOut,
	_Out_opt_ LPDWORD pdwStrLen,
	_In_ DWORD dwMaxLength)
{
	ATLENSURE(szStringIn != NULL);
	ATLENSURE(szStringOut != NULL);
	/// convert to UTF8
	BOOL bRet = FALSE;

	int nSrcLen = (int) wcslen(szStringIn);
	int nCnt = AtlUnicodeToUTF8(szStringIn, nSrcLen, NULL, 0);
	if (nCnt != 0)
	{
		nCnt++;
		CHeapPtr<char> szIn;

		char szInBuf[ATL_URL_MAX_URL_LENGTH];
		char *pszIn = szInBuf;

		if (nCnt <= 0)
		{
			return FALSE;
		}

		// try to avoid allocation
		if (nCnt > ATL_URL_MAX_URL_LENGTH)
		{
			if (!szIn.AllocateBytes(nCnt))
			{
				// out of memory
				return FALSE;
			}
			pszIn = szIn;
		}

		nCnt = AtlUnicodeToUTF8(szStringIn, nSrcLen, pszIn, nCnt);
		ATLASSERT( nCnt != 0 );

		pszIn[nCnt] = '\0';

		char szOutBuf[ATL_URL_MAX_URL_LENGTH];
		char *pszOut = szOutBuf;
		CHeapPtr<char> szTmp;

		// try to avoid allocation
		if (dwMaxLength > ATL_URL_MAX_URL_LENGTH)
		{
			if (!szTmp.AllocateBytes(dwMaxLength))
			{
				// out of memory
				return FALSE;
			}
			pszOut = szTmp;
		}

		DWORD dwStrLen = 0;
		bRet = AtlUnescapeUrl(pszIn, pszOut, &dwStrLen, dwMaxLength);
		if (bRet != FALSE)
		{
			// it is now safe to convert using any codepage, since there
			// are no non-ASCII characters
			_ATLTRY
			{
				Checked::wmemcpy_s(szStringOut, dwMaxLength, CA2W( pszOut ), dwStrLen);
			}
			_ATLCATCHALL()
			{
				bRet = FALSE;
			}
		}
		if (pdwStrLen)
		{
			*pdwStrLen = dwStrLen;
		}
	}

	return bRet;
}

//Canonicalize a URL (same as InternetCanonicalizeUrl)
inline BOOL AtlCanonicalizeUrl(
	_In_z_ LPCTSTR szUrl,
	_Out_z_capcount_(*pdwMaxLength) LPTSTR szCanonicalized,
	_Inout_ DWORD* pdwMaxLength,
	_In_ DWORD dwFlags = 0)
{
	ATLENSURE( szUrl != NULL );
	ATLENSURE( szCanonicalized != NULL );
	ATLENSURE( pdwMaxLength != NULL);

	return AtlEscapeUrl(szUrl, szCanonicalized, pdwMaxLength, *pdwMaxLength, dwFlags | ATL_URL_CANONICALIZE);
}

//Combine a base and relative URL (same as InternetCombineUrl)
inline BOOL AtlCombineUrl(
	_In_z_ LPCTSTR szBaseUrl,
	_In_z_ LPCTSTR szRelativeUrl,
	_Out_z_capcount_(*pdwMaxLength) LPTSTR szBuffer,
	_Inout_ DWORD* pdwMaxLength,
	_In_ DWORD dwFlags = 0)
{
	ATLENSURE(szBaseUrl != NULL);
	ATLENSURE(szRelativeUrl != NULL);
	ATLENSURE(szBuffer != NULL);
	ATLENSURE(pdwMaxLength != NULL);

	size_t nLen1 = _tcslen(szBaseUrl);
	TCHAR szCombined[2*ATL_URL_MAX_URL_LENGTH];
	if (nLen1 >= _countof(szCombined))
	{
		return FALSE;
	}

	Checked::tcscpy_s(szCombined, _countof(szCombined), szBaseUrl);

	// if last char of szBaseUrl is not a slash, add it.
	if (nLen1 > 0 && szCombined[nLen1-1] != _T('/'))
	{
		if (nLen1 >= _countof(szCombined) - 1)
		{
			return FALSE;
		}
		szCombined[nLen1] = _T('/');
		nLen1++;
		szCombined[nLen1] = _T('\0');
	}

	size_t nLen2 = _tcslen(szRelativeUrl);

	if (nLen2 >= _countof(szCombined))
	{
		return FALSE;
	}
	if (nLen2+nLen1+1 >= _countof(szCombined) || nLen2+nLen1+1 <= nLen1)
	{
		return FALSE;
	}

	Checked::tcsncpy_s(szCombined+nLen1,_countof(szCombined)-nLen1, szRelativeUrl, nLen2);
	DWORD dwLen = (DWORD) (nLen1+nLen2);
	if (dwLen >= *pdwMaxLength)
	{
		*pdwMaxLength = dwLen;
		return FALSE;
	}
	return AtlEscapeUrl(szCombined, szBuffer, pdwMaxLength, *pdwMaxLength, dwFlags | ATL_URL_COMBINE | ATL_URL_CANONICALIZE);
}

class CUrl
{
private:
	//scheme names cannot contain escape/unsafe characters
	TCHAR m_szScheme[ATL_URL_MAX_SCHEME_LENGTH+1];

	//host names cannot contain escape/unsafe characters
	TCHAR m_szHostName[ATL_URL_MAX_HOST_NAME_LENGTH+1];

	TCHAR m_szUserName[ATL_URL_MAX_USER_NAME_LENGTH+1];
	TCHAR m_szPassword[ATL_URL_MAX_PASSWORD_LENGTH+1];
	TCHAR m_szUrlPath[ATL_URL_MAX_PATH_LENGTH+1];
	TCHAR m_szExtraInfo[ATL_URL_MAX_PATH_LENGTH+1];

	ATL_URL_PORT m_nPortNumber;
	ATL_URL_SCHEME m_nScheme;

	DWORD m_dwSchemeNameLength;
	DWORD m_dwHostNameLength;
	DWORD m_dwUserNameLength;
	DWORD m_dwPasswordLength;
	DWORD m_dwUrlPathLength;
	DWORD m_dwExtraInfoLength;

public:
	//Empty constructor
	CUrl() throw()
	{
		InitFields();
		SetScheme(ATL_URL_SCHEME_HTTP);
	}

	//Copy constructor--maybe make private
	CUrl(_In_ const CUrl& urlThat) throw()
	{
		CopyFields(urlThat);
	}

	//Destructor (empty)
	~CUrl() throw()
	{
	}

	CUrl& operator=(_In_ const CUrl& urlThat)  throw()
	{
		CopyFields(urlThat);
		return (*this);
	}

	//Set the url
	BOOL CrackUrl(
		_In_z_ LPCTSTR lpszUrl,
		_In_ DWORD dwFlags = 0) throw()
	{
		ATLASSERT(lpszUrl != NULL);
		ATLASSERT((dwFlags == 0) || (dwFlags == ATL_URL_ESCAPE) ||
			(dwFlags == ATL_URL_DECODE) || (dwFlags == (ATL_URL_DECODE | ATL_URL_ESCAPE)));

		InitFields();

		BOOL bRet = Parse(lpszUrl);

		if ((dwFlags & ATL_URL_ESCAPE) || (dwFlags & ATL_URL_DECODE))
		{
			if (bRet && (m_dwUserNameLength > 0))
			{
				bRet = AtlUnescapeUrl(m_szUserName, m_szUserName,
					&m_dwUserNameLength, ATL_URL_MAX_USER_NAME_LENGTH+1);
				if (bRet)
				{
					--m_dwUserNameLength;
				}
			}

			if (bRet && (m_dwPasswordLength > 0))
			{
				bRet = AtlUnescapeUrl(m_szPassword, m_szPassword,
					&m_dwPasswordLength, ATL_URL_MAX_PASSWORD_LENGTH+1);
				if (bRet)
				{
					--m_dwPasswordLength;
				}
			}

			if (bRet && (m_dwHostNameLength > 0))
			{
				bRet = AtlUnescapeUrl(m_szHostName, m_szHostName,
					&m_dwHostNameLength, ATL_URL_MAX_HOST_NAME_LENGTH+1);
				if (bRet)
				{
					--m_dwHostNameLength;
				}
			}

			if (bRet && (m_dwUrlPathLength > 0))
			{
				bRet = AtlUnescapeUrl(m_szUrlPath, m_szUrlPath,
					&m_dwUrlPathLength, ATL_URL_MAX_PATH_LENGTH+1);
				if (bRet)
				{
					--m_dwUrlPathLength;
				}
			}

			if (bRet && (m_dwExtraInfoLength > 0))
			{
				bRet = AtlUnescapeUrl(m_szExtraInfo, m_szExtraInfo,
					&m_dwExtraInfoLength, ATL_URL_MAX_PATH_LENGTH+1);
				if (bRet)
				{
					--m_dwExtraInfoLength;
				}
			}
		}
		return bRet;
	}

	inline BOOL CreateUrl(
		_Out_z_cap_post_count_(*pdwMaxLength,*pdwMaxLength) LPTSTR lpszUrl,
		_Inout_ DWORD* pdwMaxLength,
		_In_ DWORD dwFlags = 0) const throw()
	{
		ATLASSERT(lpszUrl != NULL);
		ATLASSERT(pdwMaxLength != NULL);

		if( pdwMaxLength == NULL )
			return FALSE;

		//build URL: <scheme>://<user>:<pass>@<domain>:<port><path><extra>
		TCHAR szPortNumber[ATL_URL_MAX_PORT_NUMBER_LENGTH+2];
		DWORD dwLength = *pdwMaxLength;
		*pdwMaxLength = GetUrlLength()+1;

		if( lpszUrl == NULL )
			return FALSE;

		if (*pdwMaxLength > dwLength)
			return FALSE;


		int nWritten=_stprintf_s(szPortNumber, _countof(szPortNumber), _T(":%d"), m_nPortNumber);
		if(nWritten<0)
		{
			return FALSE;
		}
		else
		{
			szPortNumber[_countof(szPortNumber)-1]=_T('\0');
		}

		LPTSTR lpszOutUrl = lpszUrl;
		LPTSTR lpszEndUrl = lpszUrl + dwLength;
		if (*m_szScheme)
		{
			Checked::tcsncpy_s(lpszUrl,lpszEndUrl - lpszUrl,m_szScheme, m_dwSchemeNameLength);
			lpszUrl += m_dwSchemeNameLength;
			if( lpszUrl >= lpszEndUrl )
				return FALSE;
			*lpszUrl++ = ':';
			if (m_nScheme != ATL_URL_SCHEME_MAILTO)
			{
				if( (lpszUrl + 1) >= lpszEndUrl )
					return FALSE;
				*lpszUrl++ = '/';
				*lpszUrl++ = '/';
			}
		}

		if (*m_szUserName)
		{
			Checked::tcsncpy_s(lpszUrl, lpszEndUrl - lpszUrl,m_szUserName, m_dwUserNameLength);
			lpszUrl += m_dwUserNameLength;
			if (*m_szPassword)
			{
				if( lpszUrl >= lpszEndUrl )
					return FALSE;
				*lpszUrl++ = ':';
				Checked::tcsncpy_s(lpszUrl, lpszEndUrl - lpszUrl,m_szPassword, m_dwPasswordLength);
				lpszUrl += m_dwPasswordLength;
			}
			if( lpszUrl >= lpszEndUrl )
				return FALSE;
			*lpszUrl++ = '@';
		}

		if (*m_szHostName)
		{
			Checked::tcsncpy_s(lpszUrl, lpszEndUrl - lpszUrl,m_szHostName, m_dwHostNameLength);
			lpszUrl += m_dwHostNameLength;
			if (m_nPortNumber != AtlGetDefaultUrlPort(m_nScheme))
			{
				if( lpszUrl >= lpszEndUrl )
					return FALSE;
				DWORD dwPortLen = (DWORD) _tcslen(szPortNumber);
				Checked::tcsncpy_s(lpszUrl, lpszEndUrl - lpszUrl,szPortNumber, dwPortLen);
				lpszUrl += dwPortLen;
			}
			if (*m_szUrlPath && *m_szUrlPath != '/' && *m_szUrlPath != '\\')
			{
				if( lpszUrl >= lpszEndUrl )
					return FALSE;
				*lpszUrl++ = '/';
			}
		}

		if (*m_szUrlPath)
		{
			if( lpszUrl >= lpszEndUrl )
				return FALSE;
			Checked::tcsncpy_s(lpszUrl, lpszEndUrl - lpszUrl, m_szUrlPath, m_dwUrlPathLength);
			lpszUrl+= m_dwUrlPathLength;
		}

		if (*m_szExtraInfo)
		{
			if( lpszUrl >= lpszEndUrl )
				return FALSE;
			Checked::tcsncpy_s(lpszUrl, lpszEndUrl - lpszUrl, m_szExtraInfo, m_dwExtraInfoLength);
			lpszUrl += m_dwExtraInfoLength;
		}

		if( lpszUrl >= lpszEndUrl )
			return FALSE;
		*lpszUrl = '\0';

		(*pdwMaxLength)--;

		if (dwFlags & ATL_URL_ESCAPE)
		{
			TCHAR szUrl[ATL_URL_MAX_URL_LENGTH];
			Checked::tcsncpy_s(szUrl, _countof(szUrl),lpszOutUrl, *pdwMaxLength);
			if (AtlUnescapeUrl(szUrl, lpszOutUrl, pdwMaxLength, dwLength))
			{
				(*pdwMaxLength)--;
				return TRUE;
			}
			else
			{
				return FALSE;
			}
		}

		return TRUE;
	}

	inline void Clear() throw()
	{
		InitFields();
	}

	inline DWORD GetUrlLength() const throw()
	{
		//The conditionals in this method are related to the conditionals in the CreateUrl method
		//scheme + ':'
		DWORD dwUrlLength = m_dwSchemeNameLength+1;

		//i.e. "//"
		if (m_nScheme != ATL_URL_SCHEME_MAILTO)
			dwUrlLength += 2;

		//i.e. "username@"
		if (m_dwUserNameLength > 0)
			dwUrlLength += m_dwUserNameLength+1;

		//i.e. ":password"
		if (m_dwPasswordLength > 0)
			dwUrlLength += m_dwPasswordLength+1;

		dwUrlLength += m_dwHostNameLength;

		// will need to add an extra '/' in this case
		if (m_dwHostNameLength && m_dwUrlPathLength && *m_szUrlPath != '/' && *m_szUrlPath != '\\')
			dwUrlLength++;

		//i.e. ":xx" where "xx" is the port number
		if (m_nPortNumber != AtlGetDefaultUrlPort(m_nScheme))
		{
			dwUrlLength += _sctprintf(_T(":%d"), m_nPortNumber);
		}

		dwUrlLength += m_dwUrlPathLength + m_dwExtraInfoLength;

		return dwUrlLength;
	}

	//Get the Scheme Name (i.e. http, ftp, etc.)
	inline LPCTSTR GetSchemeName() const throw()
	{
		return m_szScheme;
	}

	//Get the Scheme Name length
	inline DWORD GetSchemeNameLength() const throw()
	{
		return m_dwSchemeNameLength;
	}

	//This method will incur the cost of
	//validating the scheme and updating the scheme name
	inline BOOL SetSchemeName(_In_z_ LPCTSTR lpszSchm)
	{
		ATLENSURE(lpszSchm != NULL);

		const _schemeinfo *pSchemes = GetSchemes();

		ATLENSURE( pSchemes != NULL );

		int nScheme = -1;

		for (int i=0; i<s_nSchemes; i++)
		{
			if (pSchemes[i].szSchemeName && _tcsicmp(lpszSchm, pSchemes[i].szSchemeName) == 0)
			{
				nScheme = i;
				break;
			}
		}

		if (nScheme != -1)
		{
			m_nScheme = (ATL_URL_SCHEME) nScheme;
			m_dwSchemeNameLength = pSchemes[nScheme].dwSchemeLength;
			m_nPortNumber = (ATL_URL_PORT) pSchemes[nScheme].nUrlPort;
		}
		else
		{
			// unknown scheme
			m_nScheme = ATL_URL_SCHEME_UNKNOWN;
			m_dwSchemeNameLength = (DWORD) _tcslen(lpszSchm);
			if (m_dwSchemeNameLength > ATL_URL_MAX_SCHEME_LENGTH)
			{
				// scheme name too long
				return FALSE;
			}

			m_nPortNumber = ATL_URL_INVALID_PORT_NUMBER;
		}

		Checked::tcsncpy_s(m_szScheme, _countof(m_szScheme),lpszSchm, m_dwSchemeNameLength);
		m_szScheme[m_dwSchemeNameLength] = '\0';

		return TRUE;
	}

	inline BOOL SetScheme(_In_ ATL_URL_SCHEME nScheme)
	{
		if ((nScheme < 0) || (nScheme >= s_nSchemes))
		{
			// invalid scheme
			return FALSE;
		}

		const _schemeinfo *pSchemes = GetSchemes();

		ATLENSURE( pSchemes != NULL );

		m_nScheme = (ATL_URL_SCHEME) nScheme;
		m_dwSchemeNameLength = pSchemes[nScheme].dwSchemeLength;
		m_nPortNumber = (ATL_URL_PORT) pSchemes[nScheme].nUrlPort;
		Checked::tcsncpy_s(m_szScheme,_countof(m_szScheme), pSchemes[nScheme].szSchemeName, m_dwSchemeNameLength);

		return TRUE;
	}

	inline ATL_URL_SCHEME GetScheme() const throw()
	{
		return m_nScheme;
	}

	//Get the host name
	inline LPCTSTR GetHostName() const throw()
	{
		return m_szHostName;
	}

	//Get the host name's length
	inline DWORD GetHostNameLength() const throw()
	{
		return m_dwHostNameLength;
	}

	//Set the Host name
	inline BOOL SetHostName(_In_z_count_c_(ATL_URL_MAX_HOST_NAME_LENGTH+1) LPCTSTR lpszHost) throw()
	{
		ATLASSERT(lpszHost != NULL);

		DWORD dwLen = (DWORD) Checked::tcsnlen(lpszHost, ATL_URL_MAX_HOST_NAME_LENGTH+1);
		if (dwLen > ATL_URL_MAX_HOST_NAME_LENGTH)
			return FALSE;

		Checked::tcsncpy_s(m_szHostName,_countof(m_szHostName), lpszHost, dwLen);
		m_dwHostNameLength = dwLen;

		return TRUE;
	}

	//Get the port number in terms of ATL_URL_PORT
	inline ATL_URL_PORT GetPortNumber() const throw()
	{
		return m_nPortNumber;
	}

	//Set the port number in terms of ATL_URL_PORT
	inline BOOL SetPortNumber(_In_ ATL_URL_PORT nPrt) throw()
	{
		m_nPortNumber = nPrt;
		return TRUE;
	}

	//Get the user name
	inline LPCTSTR GetUserName() const throw()
	{
		return m_szUserName;
	}

	//Get the user name's length
	inline DWORD GetUserNameLength() const throw()
	{
		return m_dwUserNameLength;
	}

	//Set the user name
	inline BOOL SetUserName(_In_z_count_c_(ATL_URL_MAX_USER_NAME_LENGTH+1) LPCTSTR lpszUser) throw()
	{
		ATLASSERT(lpszUser != NULL);

		DWORD dwLen = (DWORD) Checked::tcsnlen(lpszUser, ATL_URL_MAX_USER_NAME_LENGTH+1);
		if (dwLen > ATL_URL_MAX_USER_NAME_LENGTH)
			return FALSE;

		Checked::tcsncpy_s(m_szUserName,_countof(m_szUserName), lpszUser, dwLen);
		m_dwUserNameLength = dwLen;

		return TRUE;
	}

	//Get the password
	inline LPCTSTR GetPassword() const throw()
	{
		return m_szPassword;
	}

	//Get the password's length
	inline DWORD GetPasswordLength() const throw()
	{
		return m_dwPasswordLength;
	}

	//Set the password
	inline BOOL SetPassword(_In_z_count_c_(ATL_URL_MAX_PASSWORD_LENGTH+1) LPCTSTR lpszPass)
	{
		ATLENSURE(lpszPass != NULL);

		if (*lpszPass && !*m_szUserName)
			return FALSE;

		DWORD dwLen = (DWORD) Checked::tcsnlen(lpszPass, ATL_URL_MAX_PASSWORD_LENGTH+1);
		if (dwLen > ATL_URL_MAX_PASSWORD_LENGTH)
			return FALSE;

		Checked::tcsncpy_s(m_szPassword,_countof(m_szPassword), lpszPass, dwLen);
		m_dwPasswordLength = dwLen;

		return TRUE;
	}

	//Get the url path (everything after scheme and
	//before extra info)
	inline LPCTSTR GetUrlPath() const throw()
	{
		return m_szUrlPath;
	}

	//Get the url path's length
	inline DWORD GetUrlPathLength() const throw()
	{
		return m_dwUrlPathLength;
	}

	//Set the url path
	inline BOOL SetUrlPath(_In_z_count_c_(ATL_URL_MAX_PATH_LENGTH+1) LPCTSTR lpszPath) throw()
	{
		ATLASSERT(lpszPath != NULL);

		DWORD dwLen = (DWORD) Checked::tcsnlen(lpszPath, ATL_URL_MAX_PATH_LENGTH+1);
		if (dwLen > ATL_URL_MAX_PATH_LENGTH)
			return FALSE;

		Checked::tcsncpy_s(m_szUrlPath,_countof(m_szUrlPath), lpszPath, dwLen);
		m_dwUrlPathLength = dwLen;

		return TRUE;
	}

	//Get extra info (i.e. ?something or #something)
	inline LPCTSTR GetExtraInfo() const throw()
	{
		return m_szExtraInfo;
	}

	//Get extra info's length
	inline DWORD GetExtraInfoLength() const throw()
	{
		return m_dwExtraInfoLength;
	}

	//Set extra info
	inline BOOL SetExtraInfo(_In_z_count_c_(ATL_URL_MAX_PATH_LENGTH+1) LPCTSTR lpszInfo) throw()
	{
		ATLASSERT(lpszInfo != NULL);

		DWORD dwLen = (DWORD) Checked::tcsnlen(lpszInfo, ATL_URL_MAX_PATH_LENGTH+1);
		if (dwLen > ATL_URL_MAX_PATH_LENGTH)
			return FALSE;

		Checked::tcsncpy_s(m_szExtraInfo,_countof(m_szExtraInfo), lpszInfo, dwLen);
		m_dwExtraInfoLength = dwLen;

		return TRUE;
	}

	//Insert Escape characters into URL
	inline BOOL Canonicalize(_In_ DWORD dwFlags = 0) throw()
	{
		Checked::tcslwr_s(m_szScheme, _countof(m_szScheme));
		TCHAR szTmp[ATL_URL_MAX_URL_LENGTH];
		Checked::tcscpy_s(szTmp,_countof(szTmp), m_szUserName);
		// AtlEscapeUrl returns the size of the buffer required to hold the data
		// including the NULL terminator. However, CUrl stores the lengths of the
		// URL components as length - NULL terminator, similar to what you'd get
		// if you did a strlen on the URL component so we have to adjust the lengths
		// that come back from AtlEscapeUrl
		BOOL bRet = AtlEscapeUrl(szTmp, m_szUserName, &m_dwUserNameLength, ATL_URL_MAX_USER_NAME_LENGTH, dwFlags);
		if (bRet)
		{
			m_dwUserNameLength--;
			Checked::tcscpy_s(szTmp,_countof(szTmp), m_szPassword);
			bRet = AtlEscapeUrl(szTmp, m_szPassword, &m_dwPasswordLength, ATL_URL_MAX_PASSWORD_LENGTH, dwFlags);
		}
		if (bRet)
		{
			m_dwPasswordLength--;
			Checked::tcscpy_s(szTmp,_countof(szTmp), m_szHostName);
			bRet = AtlEscapeUrl(szTmp, m_szHostName, &m_dwHostNameLength, ATL_URL_MAX_HOST_NAME_LENGTH, dwFlags);
		}
		if (bRet)
		{
			m_dwHostNameLength--;
			Checked::tcscpy_s(szTmp,_countof(szTmp), m_szUrlPath);
			bRet = AtlEscapeUrl(szTmp, m_szUrlPath, &m_dwUrlPathLength, ATL_URL_MAX_PATH_LENGTH, dwFlags);
			if (bRet)
				m_dwUrlPathLength--;
		}


		//in ATL_URL_BROWSER mode, the portion of the URL following the '?' or '#' is not encoded
		if (bRet && (dwFlags & ATL_URL_BROWSER_MODE) == 0 && m_szExtraInfo != NULL && m_szExtraInfo[0] != 0)
		{
			Checked::tcscpy_s(szTmp,_countof(szTmp), m_szExtraInfo);
			bRet = AtlEscapeUrl(szTmp+1, m_szExtraInfo+1, &m_dwExtraInfoLength, ATL_URL_MAX_PATH_LENGTH-1, dwFlags);
		}

		return bRet;
	}

private:

	const static DWORD s_nSchemes = 8;

	struct _schemeinfo
	{
		LPCTSTR szSchemeName;
		DWORD dwSchemeLength;
		ATL_URL_PORT nUrlPort;
	};

	const _schemeinfo * GetSchemes() throw()
	{
		const static _schemeinfo s_schemes[] =
		{
			{ _T("ftp"), sizeof("ftp")-1, ATL_URL_DEFAULT_FTP_PORT },
			{ _T("gopher"), sizeof("gopher")-1, ATL_URL_DEFAULT_GOPHER_PORT },
			{ _T("http"), sizeof("http")-1, ATL_URL_DEFAULT_HTTP_PORT },
			{ _T("https"), sizeof("https")-1, ATL_URL_DEFAULT_HTTPS_PORT },
			{ _T("file"), sizeof("file")-1, ATL_URL_INVALID_PORT_NUMBER },
			{ _T("news"), sizeof("news")-1, ATL_URL_INVALID_PORT_NUMBER },
			{ _T("mailto"), sizeof("mailto")-1, ATL_URL_INVALID_PORT_NUMBER },
			{ _T("socks"), sizeof("socks")-1, ATL_URL_DEFAULT_SOCKS_PORT }
		};

		return s_schemes;
	}

	inline BOOL Parse(_In_z_ LPCTSTR lpszUrl)
	{
		ATLENSURE(lpszUrl != NULL);

		TCHAR ch;
		BOOL bGotScheme = FALSE;
		BOOL bGotUserName = FALSE;
		BOOL bGotHostName = FALSE;
		BOOL bGotPortNumber = FALSE;
		CAtlString strCurrentUrl;
		TCHAR* szCurrentUrl = strCurrentUrl.GetBuffer(ATL_URL_MAX_URL_LENGTH+6);
		TCHAR* pszCurrentUrl = szCurrentUrl;
		size_t nUrlSize = 0;

		BOOL bInsideSquareBrackets = FALSE;

		//parse lpszUrl using szCurrentUrl to store temporary data

		//this loop will get the following if it exists:
		//<protocol>://user:pass@server:port
		while ((ch = *lpszUrl) != '\0')
		{
			if (nUrlSize >= ATL_URL_MAX_URL_LENGTH+5)
				goto error;

			if (ch == ':' && !bInsideSquareBrackets)
			{
				//3 cases:
				//(1) Just encountered a scheme
				//(2) Port number follows
				//(3) Form of username:password@

				// Check to see if we've just encountered a scheme
				*pszCurrentUrl = '\0';
				if (!bGotScheme)
				{
					if (!SetSchemeName(szCurrentUrl))
						goto error;

					//Set a flag to avoid checking for
					//schemes everytime we encounter a :
					bGotScheme = TRUE;

					if (*(lpszUrl+1) == '/')
					{
						if (*(lpszUrl+2) == '/')
						{
							//the mailto scheme cannot have a '/' following the "mailto:" portion
							if (bGotScheme && m_nScheme == ATL_URL_SCHEME_MAILTO)
								goto error;

							//Skip these characters and continue
							lpszUrl+= 2;
						}
						else
						{
							//it is an absolute path
							//no domain name, port, username, or password is allowed in this case
							//break to loop that gets path
							lpszUrl++;
							pszCurrentUrl = szCurrentUrl;
							nUrlSize = 0;
							break;
						}
					}

					//reset pszCurrentUrl
					pszCurrentUrl = szCurrentUrl;
					nUrlSize = 0;
					lpszUrl++;

					//if the scheme is file, skip to getting the path information
					if (m_nScheme == ATL_URL_SCHEME_FILE)
						break;
					continue;
				}
				else if (!bGotUserName || !bGotPortNumber)
				{
					//It must be a username:password or a port number
					*pszCurrentUrl = '\0';

					pszCurrentUrl = szCurrentUrl;
					nUrlSize = 0;
					TCHAR tmpBuf[ATL_URL_MAX_PASSWORD_LENGTH+1];
					TCHAR* pTmpBuf = tmpBuf;
					int nCnt = 0;

					//get the user or portnumber (break on either '/', '@', or '\0'
					while (((ch = *(++lpszUrl)) != '/') && (ch != '@') && (ch != '\0'))
					{
						if (nCnt >= ATL_URL_MAX_PASSWORD_LENGTH)
							goto error;

						*pTmpBuf++ = ch;
						nCnt++;
					}
					*pTmpBuf = '\0';

					//if we broke on a '/' or a '\0', it must be a port number
					if (!bGotPortNumber && (ch == '/' || ch == '\0'))
					{
						//the host name must immediately preced the port number
						if (!SetHostName(szCurrentUrl))
							goto error;

						//get the port number
						m_nPortNumber = (ATL_URL_PORT) _ttoi(tmpBuf);
						if (m_nPortNumber < 0)
							goto error;

						bGotPortNumber = bGotHostName = TRUE;
					}
					else if (!bGotUserName && ch=='@')
					{
						//otherwise it must be a username:password
						if (!SetUserName(szCurrentUrl) || !SetPassword(tmpBuf))
							goto error;

						bGotUserName = TRUE;
						lpszUrl++;
					}
					else
					{
						goto error;
					}
				}
			}
			else if (ch == '@')
			{
				if (bGotUserName)
					goto error;

				//type is userinfo@
				*pszCurrentUrl = '\0';
				if (!SetUserName(szCurrentUrl))
					goto error;

				bInsideSquareBrackets = FALSE;

				bGotUserName = TRUE;
				lpszUrl++;
				pszCurrentUrl = szCurrentUrl;
				nUrlSize = 0;
			}
			else if (ch == '/' || ch == '?' || (!*(lpszUrl+1)))
			{
				//we're at the end of this loop
				//set the domain name and break
				if (!*(lpszUrl+1) && ch != '/' && ch != '?')
				{
					if (nUrlSize >= ATL_URL_MAX_URL_LENGTH+4)
						goto error;

					*pszCurrentUrl++ = ch;
					nUrlSize++;
					lpszUrl++;
				}
				*pszCurrentUrl = '\0';
				if (!bGotHostName)
				{
					if (!SetHostName(szCurrentUrl))
						goto error;
				}
				pszCurrentUrl = szCurrentUrl;
				nUrlSize = 0;
				break;
			}
			else
			{
				if (ch == '[' && bGotScheme && !bGotHostName)
					bInsideSquareBrackets = TRUE;
				else if (ch == ']')
					bInsideSquareBrackets = FALSE;

				*pszCurrentUrl++ = ch;
				lpszUrl++;
				nUrlSize++;
			}
		}

		if (!bGotScheme)
			goto error;

		//Now build the path
		while ((ch = *lpszUrl) != '\0')
		{
			if (nUrlSize >= ATL_URL_MAX_URL_LENGTH+5)
				goto error;

			//break on a '#' or a '?', which delimit "extra information"
			if (m_nScheme != ATL_URL_SCHEME_FILE && (ch == '#' || ch == '?'))
			{
				break;
			}
			*pszCurrentUrl++ = ch;
			nUrlSize++;
			lpszUrl++;
		}
		*pszCurrentUrl = '\0';

		if (*szCurrentUrl != '\0' && !SetUrlPath(szCurrentUrl))
			goto error;

		pszCurrentUrl = szCurrentUrl;
		nUrlSize = 0;

		while ((ch = *lpszUrl++) != '\0')
		{
			if (nUrlSize >= ATL_URL_MAX_URL_LENGTH+5)
				goto error;

			*pszCurrentUrl++ = ch;
			nUrlSize++;
		}

		*pszCurrentUrl = '\0';
		if (*szCurrentUrl != '\0' && !SetExtraInfo(szCurrentUrl))
			goto error;

		switch(m_nScheme)
		{
			case ATL_URL_SCHEME_FILE:
				m_nPortNumber = ATL_URL_INVALID_PORT_NUMBER;
				break;
			case ATL_URL_SCHEME_NEWS:
				m_nPortNumber = ATL_URL_INVALID_PORT_NUMBER;
				break;
			case ATL_URL_SCHEME_MAILTO:
				m_nPortNumber = ATL_URL_INVALID_PORT_NUMBER;
				break;
			default:
				if (!bGotPortNumber)
					m_nPortNumber = (unsigned short)AtlGetDefaultUrlPort(m_nScheme);
		}

		return TRUE;

error:
		InitFields();
		return FALSE;

	}

	ATL_NOINLINE void InitFields() throw()
	{
		m_nPortNumber = ATL_URL_INVALID_PORT_NUMBER;
		m_nScheme = ATL_URL_SCHEME_UNKNOWN;

		m_dwSchemeNameLength = 0;
		m_dwHostNameLength   = 0;
		m_dwUserNameLength   = 0;
		m_dwUrlPathLength    = 0;
		m_dwPasswordLength   = 0;
		m_dwExtraInfoLength  = 0;

		m_szScheme[0]        = '\0';
		m_szHostName[0]      = '\0';
		m_szUserName[0]      = '\0';
		m_szPassword[0]      = '\0';
		m_szUrlPath[0]       = '\0';
		m_szExtraInfo[0]     = '\0';
	}

	//copy all fields from urlThat
	inline void CopyFields(_In_ const CUrl& urlThat) throw()
	{
		Checked::tcsncpy_s(m_szScheme,_countof(m_szScheme), urlThat.m_szScheme, urlThat.m_dwSchemeNameLength);
		Checked::tcsncpy_s(m_szHostName,_countof(m_szHostName), urlThat.m_szHostName, urlThat.m_dwHostNameLength);
		Checked::tcsncpy_s(m_szUserName,_countof(m_szUserName), urlThat.m_szUserName, urlThat.m_dwUserNameLength);
		Checked::tcsncpy_s(m_szPassword,_countof(m_szPassword), urlThat.m_szPassword, urlThat.m_dwPasswordLength);
		Checked::tcsncpy_s(m_szUrlPath, _countof(m_szUrlPath),urlThat.m_szUrlPath, urlThat.m_dwUrlPathLength);
		Checked::tcsncpy_s(m_szExtraInfo, _countof(m_szExtraInfo),urlThat.m_szExtraInfo, urlThat.m_dwExtraInfoLength);

		m_nPortNumber        = urlThat.m_nPortNumber;
		m_nScheme            = urlThat.m_nScheme;
		m_dwSchemeNameLength = urlThat.m_dwSchemeNameLength;
		m_dwHostNameLength   = urlThat.m_dwHostNameLength;
		m_dwUserNameLength   = urlThat.m_dwUserNameLength;
		m_dwPasswordLength   = urlThat.m_dwPasswordLength;
		m_dwUrlPathLength    = urlThat.m_dwUrlPathLength;
		m_dwExtraInfoLength  = urlThat.m_dwExtraInfoLength;
	}

}; // class CUrl

typedef CUrl* LPURL;
typedef const CUrl * LPCURL;


#ifndef ATL_WORKER_THREAD_WAIT
#define ATL_WORKER_THREAD_WAIT 10000	// time to wait when shutting down
#endif

//
// IWorkerThreadClient
// Interface to be used with CWorkerThread
__interface IWorkerThreadClient
{
	HRESULT Execute(
		_In_ DWORD_PTR dwParam,
		_In_ HANDLE hObject);
	HRESULT CloseHandle(_In_ HANDLE hHandle);
};

//
// CWorkerThread
// This class creates a worker thread that waits on kernel
// object handles and executes a specified client
// function when the handle is signaled
// To use it, construct an instance, call Initialize
// then call add AddHandle with the handle of a kernel
// object and pass a pointer to your implementation
// of IWorkerThreadClient.  Execute on your IWorkerThreadClient
// implementation will be called when the handle is signaled
// You can also use AddTimer() to add a waitable timer
// to the worker thread.
// If the thread is still active when your object is destroyed
// you must call RemoveHandle() on each handle that your object
// owns.
// To terminate the thread, call Shutdown
//
template <class ThreadTraits=DefaultThreadTraits>
class CWorkerThread
{
protected:
	HANDLE m_hThread;
	DWORD m_dwThreadId;
	CWorkerThread<ThreadTraits> *m_pThread;
	struct WorkerClientEntry
	{
		IWorkerThreadClient *pClient;
		DWORD_PTR dwParam;
	};

	CSimpleArray<HANDLE> m_hWaitHandles;
	CSimpleArray<WorkerClientEntry, CSimpleArrayEqualHelperFalse<WorkerClientEntry> > m_ClientEntries;
	CComSafeDeleteCriticalSection m_critSec;
	HANDLE m_hRefreshComplete;

	_Check_return_ HRESULT Refresh() throw()
	{
		ATLASSUME(m_hRefreshComplete);

		DWORD dwRet = ERROR_SUCCESS;
		BOOL bRet = SetEvent(m_hWaitHandles[1]);
		if (bRet)
		{
			dwRet = WaitForSingleObject(m_hRefreshComplete, INFINITE);
			if (dwRet != WAIT_OBJECT_0)
			{
				bRet = FALSE;
			}
		}

		if (bRet)
		{
			return S_OK;
		}

		return (dwRet != ERROR_SUCCESS) ? AtlHresultFromWin32(dwRet) : AtlHresultFromLastError();
	}

public:
	CWorkerThread() throw() :
	  m_hThread(NULL),
	  m_dwThreadId(0),
	  m_hRefreshComplete(NULL),
	  m_pThread(NULL)
	{
	}

	~CWorkerThread() throw()
	{
		HRESULT hrShutdown=Shutdown();

		if(FAILED(hrShutdown))
		{
			// ignore due to loader lock contention
			ATLTRACE( "Shutdown failed: 0x%08X", hrShutdown );
		}
	}

	DWORD GetThreadId() throw()
	{
		if (m_pThread)
			return m_pThread->GetThreadId();

		return m_dwThreadId;
	}

	HANDLE GetThreadHandle() throw()
	{
		if (m_pThread)
			return m_pThread->GetThreadHandle();

		return m_hThread;
	}

	_Check_return_ HRESULT Initialize() throw()
	{
		if (m_pThread)
			return E_UNEXPECTED; // already initialized!

		// the object should be initialized first
		ATLASSUME(m_hWaitHandles.GetSize() == 0);

		HRESULT hr = m_critSec.Init();
		if (FAILED(hr))
		{
			return hr;
		}

		// create the refresh complete event
		m_hRefreshComplete = CreateEvent(NULL, FALSE, FALSE, NULL);
		if (!m_hRefreshComplete)
		{
			m_critSec.Term();
			return AtlHresultFromLastError();
		}

		// add the shutdown event

		HANDLE hEventShutdown = CreateEvent(NULL, FALSE, FALSE, NULL);
		if (!hEventShutdown)
		{
			hr = AtlHresultFromLastError();
			HRESULT hrShutdown=Shutdown();
			if(FAILED(hrShutdown) && SUCCEEDED(hr))
			{
				/* if the OS didn't tell us anything about the real error, at least report the shutdown one */
				hr=hrShutdown;
			}
			return hr;
		}

		hr = AddHandle(hEventShutdown, NULL, 0);
		if (FAILED(hr))
		{
			CloseHandle(hEventShutdown);
			HRESULT hrShutdown=Shutdown();
			if(FAILED(hrShutdown) && SUCCEEDED(hr))
			{
				/* if the OS didn't tell us anything about the real error, at least report the shutdown one */
				hr=hrShutdown;
			}
			return hr;
		}

		// create the refresh event
		HANDLE hEventRefresh = CreateEvent(NULL, FALSE, FALSE, NULL);
		if (!hEventRefresh)
		{
			hr = AtlHresultFromLastError();
			HRESULT hrShutdown=Shutdown();
			if(FAILED(hrShutdown) && SUCCEEDED(hr))
			{
				/* if the OS didn't tell us anything about the real error, at least report the shutdown one */
				hr=hrShutdown;
			}
			return hr;
		}

		hr = AddHandle(hEventRefresh, NULL, 0);
		if (FAILED(hr))
		{
			CloseHandle(hEventRefresh);
			HRESULT hrShutdown=Shutdown();
			if(FAILED(hrShutdown) && SUCCEEDED(hr))
			{
				/* if the OS didn't tell us anything about the real error, at least report the shutdown one */
				hr=hrShutdown;
			}
			return hr;
		}

		m_hThread = ThreadTraits::CreateThread(NULL, 0, (LPTHREAD_START_ROUTINE) _WorkerThreadProc,
			this, 0, &m_dwThreadId);
		if (!m_hThread)
		{
			hr = AtlHresultFromLastError();
			HRESULT hrShutdown=Shutdown();
			if(FAILED(hrShutdown) && SUCCEEDED(hr))
			{
				/* if the OS didn't tell us anything about the real error, at least report the shutdown one */
				hr=hrShutdown;
			}
			return hr;
		}

		if (WaitForSingleObject(m_hRefreshComplete, INFINITE) != WAIT_OBJECT_0)
		{
			hr = AtlHresultFromLastError();
		}

		return hr;
	}

	_Check_return_ HRESULT Initialize(_In_ CWorkerThread<ThreadTraits> *pThread) throw()
	{
		if (!pThread)
			return E_INVALIDARG;

		if (m_hThread)
			return E_UNEXPECTED; // already initialized

		if (m_pThread && (pThread != m_pThread))
			return E_UNEXPECTED; // already initialized

		m_pThread = pThread;
		return S_OK;
	}

	_Check_return_ HRESULT AddHandle(
		_In_ HANDLE hObject,
		_In_opt_ IWorkerThreadClient *pClient,
		_In_ DWORD_PTR dwParam) throw()
	{
		if (m_pThread)
			return m_pThread->AddHandle(hObject, pClient, dwParam);
		// Make sure the object has been initialized
		ATLASSUME(m_hRefreshComplete != NULL);

		CComCritSecLock<CComSafeDeleteCriticalSection> lock(m_critSec, false);
		HRESULT hr = lock.Lock();
		if (FAILED(hr))
		{
			return hr;
		}

		if (m_hWaitHandles.GetSize() == MAXIMUM_WAIT_OBJECTS)
		{
			return AtlHresultFromWin32(ERROR_INVALID_PARAMETER);
		}
		BOOL bRet = m_hWaitHandles.Add(hObject);
		if (!bRet)
		{
			return E_OUTOFMEMORY;
		}

		WorkerClientEntry entry;
		entry.pClient = pClient;
		entry.dwParam = dwParam;
		bRet = m_ClientEntries.Add(entry);
		if (!bRet)
		{
			m_hWaitHandles.RemoveAt(m_hWaitHandles.GetSize()-1);
			return E_OUTOFMEMORY;
		}
		if (m_hWaitHandles.GetSize() > 2)
		{
			// tell the worker thread to refresh
			hr = Refresh();

			ATLTRACE( atlTraceUtil, 0, _T("Refresh result: 0x%08X\n"), hr );
		}

		return hr;
	}

#if (_WIN32_WINNT >= 0x0400) || (_WIN32_WINDOWS > 0x0400)
	_Check_return_ HRESULT AddTimer(
		_In_ DWORD dwInterval,
		_In_ IWorkerThreadClient *pClient,
		_In_ DWORD_PTR dwParam,
		_Out_ HANDLE *phTimer) throw()
	{
		if (m_pThread)
			return m_pThread->AddTimer(dwInterval, pClient, dwParam, phTimer);
		// Make sure the object has been initialized
		ATLASSUME(m_hRefreshComplete != NULL);

		ATLENSURE_RETURN(phTimer);
		*phTimer = NULL;

		HANDLE hTimer = CreateWaitableTimer(NULL, FALSE, NULL);
		if (!hTimer)
		{
			return AtlHresultFromLastError();
		}

		HRESULT hr;
		LARGE_INTEGER liDueTime;

		liDueTime.QuadPart = -10000 * (__int64) dwInterval;

		BOOL bRet = SetWaitableTimer(hTimer, &liDueTime, dwInterval,  NULL, NULL, FALSE);
		if (!bRet)
		{
			hr = AtlHresultFromLastError();
			CloseHandle(hTimer);
			return hr;
		}

		hr = AddHandle(hTimer, pClient, dwParam);
		if (FAILED(hr))
		{
			CloseHandle(hTimer);
			return hr;
		}
		if (phTimer)
			*phTimer = hTimer;
		return S_OK;
	}
#endif

	_Check_return_ HRESULT RemoveHandle(_In_ HANDLE hObject) throw()
	{
		if (m_pThread)
			return m_pThread->RemoveHandle(hObject);

		// Make sure the object has been initialized
		ATLASSUME(m_hRefreshComplete != NULL);

		CComCritSecLock<CComSafeDeleteCriticalSection> lock(m_critSec, false);
		HRESULT hr = lock.Lock();
		if (FAILED(hr))
		{
			return hr;
		}

		int nIndex = m_hWaitHandles.Find(hObject);
		if (nIndex >= 0)
		{
			ATLASSERT(nIndex < m_ClientEntries.GetSize());

			IWorkerThreadClient *pClient = m_ClientEntries[nIndex].pClient;

			m_hWaitHandles.RemoveAt(nIndex);
			m_ClientEntries.RemoveAt(nIndex);

			// refresh
			hr = Refresh();

			ATLTRACE( "Refresh result: 0x%08X", hr );

			// now it is safe to close the handle
			if (!pClient || FAILED(pClient->CloseHandle(hObject)))
			{
				CloseHandle(hObject);
			}
		}
		else
		{
			hr = E_FAIL;
		}

		return hr;
	}


	_Check_return_ HRESULT Shutdown(_In_ DWORD dwWait=ATL_WORKER_THREAD_WAIT) throw()
	{
		if (m_pThread)
			return S_OK;

		if (!m_hThread)
		{
			RemoveAllClients();
			m_critSec.Term();
			if (m_hRefreshComplete)
			{
				CloseHandle(m_hRefreshComplete);
				m_hRefreshComplete = NULL;
			}
			return S_OK;
		}

		ATLASSUME(m_hWaitHandles.GetSize() > 0);

		SetEvent(m_hWaitHandles[0]);

		DWORD dwRet = WaitForSingleObject(m_hThread, dwWait);

		RemoveAllClients();

		CloseHandle(m_hThread);
		m_hThread = NULL;
		if (m_hRefreshComplete)
		{
			CloseHandle(m_hRefreshComplete);
			m_hRefreshComplete = NULL;
		}
		m_critSec.Term();
		return (dwRet == WAIT_OBJECT_0) ? S_OK : AtlHresultFromWin32(dwRet);
	}

private:

	int CopyHandles(_Out_cap_c_(MAXIMUM_WAIT_OBJECTS) HANDLE handles[MAXIMUM_WAIT_OBJECTS]) throw()
	{
		ATLENSURE_RETURN_VAL( MAXIMUM_WAIT_OBJECTS >= m_hWaitHandles.GetSize(), 0 );

		int i;
		for (i=0; i<m_hWaitHandles.GetSize(); i++)
		{
			handles[i] = m_hWaitHandles[i];
		}
		for (;i<MAXIMUM_WAIT_OBJECTS; i++)
		{
			handles[i] = INVALID_HANDLE_VALUE;
		}

		return m_hWaitHandles.GetSize();
	}

	int CopyClientEntries(
		_Out_bytecap_x_(MAXIMUM_WAIT_OBJECTS * sizeof(WorkerClientEntry)) WorkerClientEntry clientEntries[MAXIMUM_WAIT_OBJECTS]) throw()
	{
		ATLENSURE_RETURN_VAL( MAXIMUM_WAIT_OBJECTS >= m_ClientEntries.GetSize(), 0 );

		int i;
		for (i=0; i<m_ClientEntries.GetSize(); i++)
		{
			clientEntries[i] = m_ClientEntries[i];
		}
		for (;i<MAXIMUM_WAIT_OBJECTS; i++)
		{
			clientEntries[i].pClient = NULL;
		}

		return m_ClientEntries.GetSize();
	}

protected:

	void RemoveAllClients() throw()
	{
		ATLASSUME(m_hWaitHandles.GetSize() == m_ClientEntries.GetSize());

		int nLen = m_hWaitHandles.GetSize();
		for (int i = 0; i < nLen; i++)
		{
			WorkerClientEntry& entry = m_ClientEntries[i];
			if (!entry.pClient || FAILED(entry.pClient->CloseHandle(m_hWaitHandles[i])))
				CloseHandle(m_hWaitHandles[i]);
		}
		m_hWaitHandles.RemoveAll();
		m_ClientEntries.RemoveAll();
	}

	DWORD WorkerThreadProc()
	{
		// Make sure the object has been initialized
		ATLASSUME(m_hRefreshComplete != NULL);

		HANDLE handles[MAXIMUM_WAIT_OBJECTS];
		WorkerClientEntry clientEntries[MAXIMUM_WAIT_OBJECTS];
		int nSize = 0;

		nSize = CopyHandles(handles);
		CopyClientEntries(clientEntries);

		// tell the main thread we're done copying
		SetEvent(m_hRefreshComplete);

		while (TRUE)
		{
			DWORD dwRet = WaitForMultipleObjects(nSize, handles, FALSE, INFINITE);
			// check for shutdown
			if (dwRet == WAIT_OBJECT_0)
				return 0;
			else if (dwRet == WAIT_OBJECT_0+1)	// check for refresh
			{
				nSize = CopyHandles(handles);
				CopyClientEntries(clientEntries);

				// tell the main thread we're done copying
				SetEvent(m_hRefreshComplete);
				continue;
			}
			else if (dwRet > WAIT_OBJECT_0 && dwRet < WAIT_OBJECT_0 + nSize)
			{
				// execute the approriate client
				WorkerClientEntry& entry = clientEntries[dwRet - WAIT_OBJECT_0];

				// We ignore the error code because nothing useful can be done with it in this
				// implementation
				entry.pClient->Execute(entry.dwParam, handles[dwRet - WAIT_OBJECT_0]);
			}
			else
			{
				// this probably means an invalid handle was added
				ATLASSERT(FALSE);
				return 1;
			}
		}

		return 0;
	}

#pragma warning(push)
#pragma warning(disable: 4702) // Unreachable code.

	static DWORD WINAPI _WorkerThreadProc(_Inout_ CWorkerThread *pThis) throw()
	{
		_ATLTRY
		{
			return pThis->WorkerThreadProc();
		}
		_ATLCATCHALL()
		{
			//
			// uncaught exception thrown from a worker thread client
			//

			ATLASSERT( FALSE );
			return 1;
		}
	}

#pragma warning(pop)

}; // class CWorkerThread

// Use CNoWorkerThread as a template argument for classes
// that need a worker thread type as a template argument but
// don't require the services of a worker thread. An example
// would be CDllCache (atlutil.h) when you want to create a
// CDllCache with no sweeper thread.
class CNoWorkerThread
{
public:
	DWORD GetThreadId() throw()
	{
		return 0;
	}

	HANDLE GetThreadHandle() throw()
	{
		return NULL;
	}

	HRESULT Initialize() throw()
	{
		return S_OK;
	}

	HRESULT AddHandle(
		_In_ HANDLE /*hObject*/,
		_In_opt_ IWorkerThreadClient * /*pClient*/,
		_In_ DWORD_PTR /*dwParam*/) throw()
	{
		return S_OK;
	}


	HRESULT AddTimer(
		_In_ DWORD /*dwInterval*/,
		_In_opt_ IWorkerThreadClient * /*pClient*/,
		_In_ DWORD_PTR /*dwParam*/,
		_In_opt_ HANDLE * /*phTimer*/) throw()
	{
		return S_OK;
	}

	HRESULT RemoveHandle(_In_ HANDLE /*hObject*/) throw()
	{
		return S_OK;
	}

	HRESULT Shutdown(_In_ DWORD dwWait=ATL_WORKER_THREAD_WAIT) throw()
	{
		(dwWait);
		return S_OK;
	}
}; // CNoWorkerThread

// Copies a CString into a null-terminated string.
// pdwDestLen on input is the size of the buffer in characters (including the null)
// On success, pdwDestLen contains the length of the string in characters (not including the null)
// On failure, pdwDestLen contains the length of the string including the null.
template <class StringType>
inline BOOL CopyCString(
	_In_ const StringType& str,
	_Out_z_capcount_(*pdwDestLen) typename StringType::PXSTR szDest,
	_Inout_ DWORD *pdwDestLen) throw()
{
	if (!pdwDestLen)
		return FALSE;

	DWORD dwLen = str.GetLength();
	if (!szDest || *pdwDestLen < (dwLen + 1))
	{
		*pdwDestLen = dwLen + 1;
		return FALSE;
	}

	StringType::PCXSTR szBuffer = str;
	if (szBuffer)
	{
		Checked::memcpy_s(szDest, *pdwDestLen * sizeof(StringType::XCHAR),
			szBuffer, (dwLen+1) * sizeof(StringType::XCHAR));
		*pdwDestLen = dwLen;
		return TRUE;
	}

	return FALSE;
}

// Call this function to convert from a SYSTEMTIME
// structure to an Http-date as defined in rfc2616
inline void SystemTimeToHttpDate(
	_In_ const SYSTEMTIME& st,
	_Inout_ CStringA &strTime)
{
	double varDtTime;
	BOOL bValidSystemTime=AtlConvertSystemTimeToVariantTime(st,&varDtTime);
	ATLENSURE(bValidSystemTime);
	ATLENSURE(st.wDayOfWeek>=0 && st.wDayOfWeek<7);
	ATLENSURE(st.wMonth>=1 && st.wMonth<=12);
	static LPCSTR szDays[] = { "Sun", "Mon", "Tue",
		"Wed", "Thu", "Fri", "Sat" };
	static LPCSTR szMonth[] = { "Jan", "Feb", "Mar", "Apr",
		"May", "Jun", "Jul", "Aug", "Sep",
		"Oct", "Nov", "Dec" };

	strTime.Format("%s, %02d %s %d %02d:%02d:%02d GMT",
		szDays[st.wDayOfWeek], st.wDay, szMonth[st.wMonth-1], st.wYear,
		st.wHour, st.wMinute, st.wSecond);
}

// RGBToHtml - Converts a COLORREF to a color that can be used in HTML.
//             Eg. RGB(11,22,33) would be converted to #112233
// color:    The color to convert.
// pbOut:    The output buffer that will hold the resulting color.
//           The buffer must have space for at least 8 characters including space for the null terminator.
// nBuffer:	 Specifies the number of bytes in pbOut.
bool inline RGBToHtml(
	_In_ COLORREF color,
	_Out_bytecap_(nBuffer) _Post_bytecount_c_(9 * sizeof(TCHAR)) LPTSTR pbOut,
	_In_ long nBuffer)
{
	ATLENSURE (nBuffer >= 9 * sizeof(TCHAR));
	if (_stprintf_s(pbOut, nBuffer/sizeof(TCHAR), _T("#%0.2x%0.2x%0.2x"), GetRValue(color),
		GetGValue(color), GetBValue(color)) == -1)
	{
		return false;
	}
	return true;
}

inline int AsciiStricmp (
		_In_z_ const char* dst,
		_In_z_ const char* src)
{
	ATLENSURE( dst != NULL );
	ATLENSURE( src != NULL );

	int f, l;

	do {
		if ( ((f = (unsigned char)(*(dst++))) >= 'A') &&
			 (f <= 'Z') )
			f -= 'A' - 'a';
		if ( ((l = (unsigned char)(*(src++))) >= 'A') &&
			 (l <= 'Z') )
			l -= 'A' - 'a';
	} while ( f && (f == l) );

	return(f - l);
}

inline int AsciiStrnicmp (
		_In_z_ const char* first,
		_In_z_ const char* last,
		_In_ size_t count)
{
	ATLENSURE( first != NULL );
	ATLENSURE( last != NULL );

	int f, l;

	do {

		if ( ((f = (unsigned char)(*(first++))) >= 'A') &&
			 (f <= 'Z') )
			f -= 'A' - 'a';

		if ( ((l = (unsigned char)(*(last++))) >= 'A') &&
			 (l <= 'Z') )
			l -= 'A' - 'a';

	} while ( --count && f && (f == l) );

	return ( f - l );
}

inline CString AtlGetErrorDescription(
	_In_ HRESULT hr,
	_In_ DWORD dwLangId = 0) throw(...)
{
	LPTSTR szMessage = NULL;
	CString str;

	if (FormatMessage(
			FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM | FORMAT_MESSAGE_IGNORE_INSERTS,
			NULL,
			hr,
			dwLangId,
			(LPTSTR) &szMessage,
			0,
			NULL) == 0)
	{
		// unknown HRESULT
		str.Format(_T("HRESULT 0x%8.8x"), hr);
	}
	else
	{
		str = szMessage;
		LocalFree(szMessage);

		int nLen = str.GetLength();
		while (nLen > 0 && (str[nLen-1] == '\r' || str[nLen-1] == '\n'))
		{
			nLen--;
		}
		str.Truncate(nLen);
	}

	return str;
}

template <class NumType, class CharType>
NumType AtlStrToNumHelper(
	_In_z_ const CharType *szVal,
	_Deref_opt_out_z_ CharType **pEnd,
	_In_ int nRadix);

template <>
inline __int64 AtlStrToNumHelper<__int64, char>(
	_In_z_ const char *szVal,
	_Deref_opt_out_z_ char **pEnd,
	_In_ int nRadix)
{
	return _strtoi64(szVal, pEnd, nRadix);
}

template <>
inline unsigned __int64 AtlStrToNumHelper<unsigned __int64, char>(
	_In_z_ const char *szVal,
	_Deref_opt_out_z_ char **pEnd,
	_In_ int nRadix)
{
	return _strtoui64(szVal, pEnd, nRadix);
}

template <>
inline long AtlStrToNumHelper<long, char>(
	_In_z_ const char *szVal,
	_Deref_opt_out_z_ char **pEnd,
	_In_ int nRadix)
{
	return strtol(szVal, pEnd, nRadix);
}

template <>
inline unsigned long AtlStrToNumHelper<unsigned long, char>(
	_In_z_ const char *szVal,
	_Deref_opt_out_z_ char **pEnd,
	_In_ int nRadix)
{
	return strtoul(szVal, pEnd, nRadix);
}

template <>
inline int AtlStrToNumHelper<int, char>(
	_In_z_ const char *szVal,
	_Deref_opt_out_z_ char **pEnd,
	_In_ int nRadix)
{
	return strtol(szVal, pEnd, nRadix);
}

template <>
inline unsigned int AtlStrToNumHelper<unsigned int, char>(
	_In_z_ const char *szVal,
	_Deref_opt_out_z_ char **pEnd,
	_In_ int nRadix)
{
	return strtoul(szVal, pEnd, nRadix);
}

template <>
inline __int64 AtlStrToNumHelper<__int64, wchar_t>(
	_In_z_ const wchar_t *szVal,
	_Deref_opt_out_z_ wchar_t **pEnd,
	_In_ int nRadix)
{
	return _wcstoi64(szVal, pEnd, nRadix);
}

template <>
inline unsigned __int64 AtlStrToNumHelper<unsigned __int64, wchar_t>(
	_In_z_ const wchar_t *szVal,
	_Deref_opt_out_z_ wchar_t **pEnd,
	_In_ int nRadix)
{
	return _wcstoui64(szVal, pEnd, nRadix);
}

template <>
inline long AtlStrToNumHelper<long, wchar_t>(
	_In_z_ const wchar_t *szVal,
	_Deref_opt_out_z_ wchar_t **pEnd,
	_In_ int nRadix)
{
	return wcstol(szVal, pEnd, nRadix);
}

template <>
inline unsigned long AtlStrToNumHelper<unsigned long, wchar_t>(
	_In_z_ const wchar_t *szVal,
	_Deref_opt_out_z_ wchar_t **pEnd,
	_In_ int nRadix)
{
	return wcstoul(szVal, pEnd, nRadix);
}

template <>
inline int AtlStrToNumHelper<int, wchar_t>(
	_In_z_ const wchar_t *szVal,
	_Deref_opt_out_z_ wchar_t **pEnd,
	_In_ int nRadix)
{
	return wcstol(szVal, pEnd, nRadix);
}

template <>
inline unsigned int AtlStrToNumHelper<unsigned int, wchar_t>(
	_In_z_ const wchar_t *szVal,
	_Deref_opt_out_z_ wchar_t **pEnd,
	_In_ int nRadix)
{
	return wcstoul(szVal, pEnd, nRadix);
}

template <class NumType, class CharType>
NumType AtlStrToNumHelper(
	_In_z_ const CharType *szVal,
	_Deref_opt_out_z_ CharType **pEnd);

template <>
inline double AtlStrToNumHelper<double, char>(
	_In_z_ const char *szVal,
	_Deref_opt_out_z_ char **pEnd)
{
	return strtod(szVal, pEnd);
}

template <>
inline double AtlStrToNumHelper<double, wchar_t>(
	_In_z_ const wchar_t *szVal,
	_Deref_opt_out_z_ wchar_t **pEnd)
{
	return wcstod(szVal, pEnd);
}

template <class NumType, class CharType>
inline errno_t AtlStrToNum(
	_Out_ NumType *retValue,
	_In_z_ const CharType *szVal,
	_Deref_opt_out_z_ CharType **pEnd,
	_In_ int nRadix)
{
	ATLENSURE(retValue != NULL);
	errno_t saveErrno = Checked::get_errno();

	Checked::set_errno(0);
	*retValue = AtlStrToNumHelper<NumType, CharType>(szVal, pEnd, nRadix);
	errno_t retErrno = Checked::get_errno();
	Checked::set_errno(saveErrno);

	return retErrno;
}

template <class NumType, class CharType>
inline errno_t AtlStrToNum(
	_Out_ NumType *retValue,
	_In_z_ const CharType *szVal,
	_Deref_opt_out_z_ CharType **pEnd)
{
	ATLENSURE(retValue != NULL);
	errno_t saveErrno = Checked::get_errno();

	Checked::set_errno(0);
	*retValue = AtlStrToNumHelper<NumType, CharType>(szVal, pEnd);
	errno_t retErrno = Checked::get_errno();
	Checked::set_errno(saveErrno);

	return retErrno;
}

} // namespace ATL
#pragma pack(pop)

#pragma warning( pop )

#endif // __ATLUTIL_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\include\atlwin.h ===
// This is a part of the Active Template Library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Active Template Library Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Active Template Library product.

#ifndef _ATL_NO_PRAGMA_WARNINGS
#pragma warning (push)
#pragma warning(disable : 4668)	// is not defined as a preprocessor macro, replacing with '0' for '#if/#elif
#pragma warning(disable : 4820)	// padding added after member
#pragma warning(disable : 4571) //catch(...) blocks compiled with /EHs do NOT catch or re-throw Structured Exceptions
#endif //!_ATL_NO_PRAGMA_WARNINGS

#ifndef __ATLWIN_H__
#define __ATLWIN_H__

#pragma once

#ifndef __cplusplus
	#error ATL requires C++ compilation (use a .cpp suffix)
#endif

#ifndef __ATLBASE_H__
	#error atlwin.h requires atlbase.h to be included first
#endif

#include <atlstdthunk.h>
#include <commctrl.h>
#include <atlsimpstr.h>

// protect template members from windowsx.h macros
#ifdef _INC_WINDOWSX
#undef SubclassWindow
#endif //_INC_WINDOWSX

#ifdef SetWindowLongPtrA
#undef SetWindowLongPtrA
inline LONG_PTR SetWindowLongPtrA(
	_In_ HWND hWnd,
	_In_ int nIndex,
	_In_ LONG_PTR dwNewLong)
{
	return( ::SetWindowLongA( hWnd, nIndex, LONG( dwNewLong ) ) );
}
#endif

#ifdef SetWindowLongPtrW
#undef SetWindowLongPtrW
inline LONG_PTR SetWindowLongPtrW(
	_In_ HWND hWnd,
	_In_ int nIndex,
	_In_ LONG_PTR dwNewLong)
{
	return( ::SetWindowLongW( hWnd, nIndex, LONG( dwNewLong ) ) );
}
#endif

#ifdef GetWindowLongPtrA
#undef GetWindowLongPtrA
inline LONG_PTR GetWindowLongPtrA(
	_In_ HWND hWnd,
	_In_ int nIndex)
{
	return( ::GetWindowLongA( hWnd, nIndex ) );
}
#endif

#ifdef GetWindowLongPtrW
#undef GetWindowLongPtrW
inline LONG_PTR GetWindowLongPtrW(
	_In_ HWND hWnd,
	_In_ int nIndex)
{
	return( ::GetWindowLongW( hWnd, nIndex ) );
}
#endif

#ifndef _ATL_NO_DEFAULT_LIBS
#pragma comment(lib, "gdi32.lib")
#endif  // !_ATL_NO_DEFAULT_LIBS

#pragma pack(push,_ATL_PACKING)
namespace ATL
{
//#endif

/////////////////////////////////////////////////////////////////////////////
// Dual argument helper classes

class _U_RECT
{
public:
	_U_RECT(_In_opt_ LPRECT lpRect) : m_lpRect(lpRect)
	{
	}
	_U_RECT(_In_ RECT& rc) : m_lpRect(&rc)
	{
	}
	LPRECT m_lpRect;
};

class _U_MENUorID
{
public:
	_U_MENUorID(_In_ HMENU hMenu) : m_hMenu(hMenu)
	{
	}
	_U_MENUorID(_In_ UINT nID) : m_hMenu((HMENU)(UINT_PTR)nID)
	{
	}
	HMENU m_hMenu;
};

class _U_STRINGorID
{
public:
	_U_STRINGorID(_In_z_ LPCTSTR lpString) : m_lpstr(lpString)
	{
	}
	_U_STRINGorID(_In_ UINT nID) : m_lpstr(MAKEINTRESOURCE(nID))
	{
	}
	LPCTSTR m_lpstr;
};

struct _ATL_WNDCLASSINFOA;
struct _ATL_WNDCLASSINFOW;

ATLAPIINL_(ATOM) AtlWinModuleRegisterWndClassInfoA(
	_In_ _ATL_WIN_MODULE* pWinModule,
	_In_ _ATL_BASE_MODULE* pBaseModule,
	_Inout_ _ATL_WNDCLASSINFOA* p,
	_In_ WNDPROC* pProc);

inline ATOM AtlModuleRegisterWndClassInfoA(
	_In_opt_ _ATL_MODULE* /*pM*/,
	_Inout_ _ATL_WNDCLASSINFOA* p,
	_In_ WNDPROC* pProc)
{
	return AtlWinModuleRegisterWndClassInfoA(&_AtlWinModule, &_AtlBaseModule, p, pProc);
}

ATLAPIINL_(ATOM) AtlWinModuleRegisterWndClassInfoW(
	_In_ _ATL_WIN_MODULE* pWinModule,
	_In_ _ATL_BASE_MODULE* pBaseModule,
	_Inout_ _ATL_WNDCLASSINFOW* p,
	_In_ WNDPROC* pProc);

inline ATOM AtlModuleRegisterWndClassInfoW(
	_In_opt_ _ATL_MODULE* /*pM*/,
	_Inout_ _ATL_WNDCLASSINFOW* p,
	_In_ WNDPROC* pProc)
{
	return AtlWinModuleRegisterWndClassInfoW(&_AtlWinModule, &_AtlBaseModule, p, pProc);
}

ATLAPIINL_(ATOM) AtlWinModuleRegisterClassExA(
	_In_ _ATL_WIN_MODULE* pWinModule,
	_In_ const WNDCLASSEXA *lpwc);

inline ATOM AtlModuleRegisterClassExA(
	_In_opt_ _ATL_MODULE* /*pM*/,
	_In_ const WNDCLASSEXA *lpwc)
{
	return AtlWinModuleRegisterClassExA(&_AtlWinModule, lpwc);
}

ATLAPIINL_(ATOM) AtlWinModuleRegisterClassExW(
	_In_ _ATL_WIN_MODULE* pWinModule,
	_In_ const WNDCLASSEXW *lpwc);

inline ATOM AtlModuleRegisterClassExW(
	_In_opt_ _ATL_MODULE* /*pM*/,
	_In_ const WNDCLASSEXW *lpwc)
{
	return AtlWinModuleRegisterClassExW(&_AtlWinModule, lpwc);
}


#ifdef UNICODE
#define AtlWinModuleRegisterWndClassInfo AtlWinModuleRegisterWndClassInfoW
#define AtlWinModuleRegisterClassEx AtlWinModuleRegisterClassExW
#define AtlModuleRegisterWndClassInfo AtlModuleRegisterWndClassInfoW
#define AtlModuleRegisterClassEx AtlModuleRegisterClassExW
#else
#define AtlWinModuleRegisterWndClassInfo AtlWinModuleRegisterWndClassInfoA
#define AtlWinModuleRegisterClassEx AtlWinModuleRegisterClassExA
#define AtlModuleRegisterWndClassInfo AtlModuleRegisterWndClassInfoA
#define AtlModuleRegisterClassEx AtlModuleRegisterClassExA
#endif


#define HIMETRIC_PER_INCH   2540
#define MAP_PIX_TO_LOGHIM(x,ppli)   MulDiv(HIMETRIC_PER_INCH, (x), (ppli))
#define MAP_LOGHIM_TO_PIX(x,ppli)   MulDiv((ppli), (x), HIMETRIC_PER_INCH)

ATLAPI_(HDC) AtlCreateTargetDC(
	_In_ HDC hdc,
	_In_ DVTARGETDEVICE* ptd);

ATLAPI_(void) AtlHiMetricToPixel(
	_In_ const SIZEL *lpSizeInHiMetric,
	_Out_ LPSIZEL lpSizeInPix);

ATLAPI_(void) AtlPixelToHiMetric(
	_In_ const SIZEL *lpSizeInPix,
	_Out_ LPSIZEL lpSizeInHiMetric);

#ifndef GET_X_LPARAM
#define GET_X_LPARAM(lParam)	((int)(short)LOWORD(lParam))
#endif
#ifndef GET_Y_LPARAM
#define GET_Y_LPARAM(lParam)	((int)(short)HIWORD(lParam))
#endif


}; //namespace ATL
//#endif


namespace ATL
{

/////////////////////////////////////////////////////////////////////////////
// _ATL_MSG - extended MSG structure

struct _ATL_MSG :
	public MSG
{
public:
// Additional data members
	int cbSize;
	BOOL bHandled;

// Constructors
	_ATL_MSG() : cbSize(sizeof(_ATL_MSG)), bHandled(TRUE)
	{
		hwnd = NULL;
		message = 0;
		wParam = 0;
		lParam = 0;
		time = 0;
		pt.x = pt.y = 0;
	}
	_ATL_MSG(
			_In_opt_ HWND hWnd,
			_In_ UINT uMsg,
			_In_ WPARAM wParamIn,
			_In_ LPARAM lParamIn,
			_In_ DWORD dwTime,
			_In_ POINT ptIn,
			_In_ BOOL bHandledIn) :
		cbSize(sizeof(_ATL_MSG)), bHandled(bHandledIn)
	{
		hwnd = hWnd;
		message = uMsg;
		wParam = wParamIn;
		lParam = lParamIn;
		time = dwTime;
		pt = ptIn;
	}
	_ATL_MSG(
			_In_opt_ HWND hWnd,
			_In_ UINT uMsg,
			_In_ WPARAM wParamIn,
			_In_ LPARAM lParamIn,
			_In_ BOOL bHandledIn = TRUE) :
		cbSize(sizeof(_ATL_MSG)), bHandled(bHandledIn)
	{
		hwnd = hWnd;
		message = uMsg;
		wParam = wParamIn;
		lParam = lParamIn;
		time = 0;
		pt.x = pt.y = 0;
	}
	_ATL_MSG(
			_In_ MSG& msg,
			_In_ BOOL bHandledIn = TRUE) :
		cbSize(sizeof(_ATL_MSG)), bHandled(bHandledIn)
	{
		hwnd = msg.hwnd;
		message = msg.message;
		wParam = msg.wParam;
		lParam = msg.lParam;
		time = msg.time;
		pt = msg.pt;
	}
};

struct _ATL_WNDCLASSINFOA
{
	WNDCLASSEXA m_wc;
	LPCSTR m_lpszOrigName;
	WNDPROC pWndProc;
	LPCSTR m_lpszCursorID;
	BOOL m_bSystemCursor;
	ATOM m_atom;
	CHAR m_szAutoName[5+sizeof(void*)*CHAR_BIT];

	ATOM Register(_In_ WNDPROC* p)
	{
		return AtlWinModuleRegisterWndClassInfoA(&_AtlWinModule, &_AtlBaseModule, this, p);
	}
};

struct _ATL_WNDCLASSINFOW
{
	WNDCLASSEXW m_wc;
	LPCWSTR m_lpszOrigName;
	WNDPROC pWndProc;
	LPCWSTR m_lpszCursorID;
	BOOL m_bSystemCursor;
	ATOM m_atom;
	WCHAR m_szAutoName[5+sizeof(void*)*CHAR_BIT];

	ATOM Register(_In_ WNDPROC* p)
	{
		return AtlWinModuleRegisterWndClassInfoW(&_AtlWinModule, &_AtlBaseModule, this, p);
	}
};

};  // namespace ATL


namespace ATL
{

/////////////////////////////////////////////////////////////////////////////
// Forward declarations

class CWindow;
#ifndef _ATL_NO_HOSTING
template <class TBase = CWindow> class CAxWindowT;
template <class TBase = CWindow> class CAxWindow2T;
#endif //!_ATL_NO_HOSTING
class CMessageMap;
class CDynamicChain;
typedef _ATL_WNDCLASSINFOA CWndClassInfoA;
typedef _ATL_WNDCLASSINFOW CWndClassInfoW;
#ifdef UNICODE
#define CWndClassInfo CWndClassInfoW
#else
#define CWndClassInfo CWndClassInfoA
#endif
template <class T, class TBase = CWindow, class TWinTraits = CControlWinTraits> class CWindowImpl;
template <class T, class TBase = CWindow, class TWinTraits = CControlWinTraits> class CWindowWithReflectorImpl;
template <class T, class TBase = CWindow> class CDialogImpl;
#ifndef _ATL_NO_HOSTING
template <class T, class TBase = CWindow> class CAxDialogImpl;
#endif //!_ATL_NO_HOSTING
template <WORD t_wDlgTemplateID, BOOL t_bCenter = TRUE> class CSimpleDialog;
template <class TBase = CWindow, class TWinTraits = CControlWinTraits> class CContainedWindowT;

/////////////////////////////////////////////////////////////////////////////
// Helper functions for cracking dialog templates

class _DialogSplitHelper
{
public:
	// Constants used in DLGINIT resources for OLE control containers
	// NOTE: These are NOT real Windows messages they are simply tags
	// used in the control resource and are never used as 'messages'
	enum
	{
		ATL_WM_OCC_LOADFROMSTREAM = 0x0376,
		ATL_WM_OCC_LOADFROMSTORAGE = 0x0377,
		ATL_WM_OCC_INITNEW = 0x0378,
		ATL_WM_OCC_LOADFROMSTREAM_EX = 0x037A,
		ATL_WM_OCC_LOADFROMSTORAGE_EX = 0x037B,
		ATL_DISPID_DATASOURCE = 0x80010001,
		ATL_DISPID_DATAFIELD = 0x80010002,
	};

//local struct used for implementation
#pragma pack(push, 1)
	struct DLGINITSTRUCT
	{
		WORD nIDC;
		WORD message;
		DWORD dwSize;
	};
	struct DLGTEMPLATEEX
	{
		WORD dlgVer;
		WORD signature;
		DWORD helpID;
		DWORD exStyle;
		DWORD style;
		WORD cDlgItems;
		short x;
		short y;
		short cx;
		short cy;

		// Everything else in this structure is variable length,
		// and therefore must be determined dynamically

		// sz_Or_Ord menu;			// name or ordinal of a menu resource
		// sz_Or_Ord windowClass;	// name or ordinal of a window class
		// WCHAR title[titleLen];	// title string of the dialog box
		// short pointsize;			// only if DS_SETFONT is set
		// short weight;			// only if DS_SETFONT is set
		// short bItalic;			// only if DS_SETFONT is set
		// WCHAR font[fontLen];		// typeface name, if DS_SETFONT is set
	};
	struct DLGITEMTEMPLATEEX
	{
		DWORD helpID;
		DWORD exStyle;
		DWORD style;
		short x;
		short y;
		short cx;
		short cy;
		DWORD id;

		// Everything else in this structure is variable length,
		// and therefore must be determined dynamically

		// sz_Or_Ord windowClass;	// name or ordinal of a window class
		// sz_Or_Ord title;			// title string or ordinal of a resource
		// WORD extraCount;			// bytes following creation data
	};
#pragma pack(pop)

	static BOOL IsDialogEx(_In_ const DLGTEMPLATE* pTemplate)
	{
		return ((DLGTEMPLATEEX*)pTemplate)->signature == 0xFFFF;
	}

	inline static WORD& DlgTemplateItemCount(_In_ DLGTEMPLATE* pTemplate)
	{
		if (IsDialogEx(pTemplate))
			return reinterpret_cast<DLGTEMPLATEEX*>(pTemplate)->cDlgItems;
		else
			return pTemplate->cdit;
	}

	inline static const WORD& DlgTemplateItemCount(_In_ const DLGTEMPLATE* pTemplate)
	{
		if (IsDialogEx(pTemplate))
			return reinterpret_cast<const DLGTEMPLATEEX*>(pTemplate)->cDlgItems;
		else
			return pTemplate->cdit;
	}

	static DLGITEMTEMPLATE* FindFirstDlgItem(_In_ const DLGTEMPLATE* pTemplate)
	{
		BOOL bDialogEx = IsDialogEx(pTemplate);

		WORD* pw;
		DWORD dwStyle;
		if (bDialogEx)
		{
			pw = (WORD*)((DLGTEMPLATEEX*)pTemplate + 1);
			dwStyle = ((DLGTEMPLATEEX*)pTemplate)->style;
		}
		else
		{
			pw = (WORD*)(pTemplate + 1);
			dwStyle = pTemplate->style;
		}

		// Check for presence of menu and skip it if there is one
		// 0x0000 means there is no menu
		// 0xFFFF means there is a menu ID following
		// Everything else means that this is a NULL terminated Unicode string
		// which identifies the menu resource
		if (*pw == 0xFFFF)
			pw += 2;				// Has menu ID, so skip 2 words
		else
			while (*pw++);			// Either No menu, or string, skip past terminating NULL

		// Check for presence of class name string
		// 0x0000 means "Use system dialog class name"
		// 0xFFFF means there is a window class (atom) specified
		// Everything else means that this is a NULL terminated Unicode string
		// which identifies the menu resource
		if (*pw == 0xFFFF)
			pw += 2;				// Has class atom, so skip 2 words
		else
			while (*pw++);			// Either No class, or string, skip past terminating NULL

		// Skip caption string
		while (*pw++);

		// If we have DS_SETFONT, there is extra font information which we must now skip
		if (dwStyle & DS_SETFONT)
		{
			// If it is a regular DLGTEMPLATE there is only a short for the point size
			// and a string specifying the font (typefacename).  If this is a DLGTEMPLATEEX
			// then there is also the font weight, and bItalic which must be skipped
			if (bDialogEx)
				pw += 3;			// Skip font size, weight, (italic, charset)
			else
				pw += 1;			// Skip font size
			while (*pw++);			// Skip typeface name
		}

		// Dword-align and return
		return (DLGITEMTEMPLATE*)(((DWORD_PTR)pw + 3) & ~3);
	}

	// Given the current dialog item and whether this is an extended dialog
	// return a pointer to the next DLGITEMTEMPLATE*
	static DLGITEMTEMPLATE* FindNextDlgItem(
		_In_ DLGITEMTEMPLATE* pItem,
		_In_ BOOL bDialogEx)
	{
		WORD* pw;

		// First skip fixed size header information, size of which depends
		// if this is a DLGITEMTEMPLATE or DLGITEMTEMPLATEEX
		if (bDialogEx)
			pw = (WORD*)((DLGITEMTEMPLATEEX*)pItem + 1);
		else
			pw = (WORD*)(pItem + 1);

		if (*pw == 0xFFFF)			// Skip class name ordinal or string
			pw += 2; // (WORDs)
		else
			while (*pw++);

		if (*pw == 0xFFFF)			// Skip title ordinal or string
			pw += 2; // (WORDs)
		else
			while (*pw++);

		WORD cbExtra = *pw++;		// Skip extra data

		// cbExtra includes the size WORD in DIALOG resource.
		if (cbExtra != 0 && !bDialogEx)
			cbExtra -= 2;

		// Dword-align and return
		return (DLGITEMTEMPLATE*)(((DWORD_PTR)pw + cbExtra + 3) & ~3);
	}

	// Find the initialization data (Stream) for the control specified by the ID
	// If found, return the pointer into the data and the length of the data
	static DWORD FindCreateData(
		_In_ DWORD dwID,
		_In_ BYTE* pInitData,
		_Inout_ _Deref_post_opt_valid_ BYTE** pData)
	{
		ATLASSUME(pData != NULL);
		
		while (pInitData)
		{
			// Read the DLGINIT header
			WORD nIDC = *((UNALIGNED WORD*)pInitData);
			pInitData += sizeof(WORD);
			BYTE* pTemp = pInitData;
			WORD nMsg = *((UNALIGNED WORD*)pInitData);
			pInitData += sizeof(WORD);
			DWORD dwLen = *((UNALIGNED DWORD*)pInitData);
			pInitData += sizeof(DWORD);

			// If the header is for the control specified get the other info
			if (nIDC == dwID)
			{
				if (nMsg == (WORD)ATL_WM_OCC_INITNEW)
				{
					ATLASSERT(dwLen == 0);
					return 0;
				}
				*pData = pTemp;
				return dwLen + sizeof(WORD) + sizeof(DWORD);
			}

			// It's not the right control, skip past data
			pInitData += dwLen;
		}
		return 0;
	}

	static bool IsActiveXControl(
		_In_ DLGITEMTEMPLATE* pItem,
		_In_ BOOL bDialogEx)
	{
		LPWSTR pszClassName;
		pszClassName = bDialogEx ?
			(LPWSTR)(((DLGITEMTEMPLATEEX*)pItem) + 1) :
			(LPWSTR)(pItem + 1);
		if (pszClassName[0] == L'{')
			return true;
		return false;
	}

	// Convert MSDEV (MFC) style DLGTEMPLATE with controls to regular DLGTEMPLATE
	static DLGTEMPLATE* SplitDialogTemplate(
		_In_ DLGTEMPLATE* pTemplate,
		_In_opt_ BYTE* /*pInitData*/)
	{
		// Calculate the size of the DLGTEMPLATE for allocating the new one
		DLGITEMTEMPLATE* pFirstItem = FindFirstDlgItem(pTemplate);
		ULONG_PTR cbHeader = (BYTE*)pFirstItem - (BYTE*)pTemplate;
		ULONG_PTR cbNewTemplate = cbHeader;

		BOOL bDialogEx = IsDialogEx(pTemplate);

		int iItem;
		int nItems = (int)DlgTemplateItemCount(pTemplate);
		LPWSTR pszClassName;
		BOOL bHasOleControls = FALSE;

		// Make first pass through the dialog template.  On this pass, we're
		// interested in determining:
		//    1. Does this template contain any ActiveX Controls?
		//    2. If so, how large a buffer is needed for a template containing
		//       only the non-OLE controls?

		DLGITEMTEMPLATE* pItem = pFirstItem;
		DLGITEMTEMPLATE* pNextItem = pItem;
		for (iItem = 0; iItem < nItems; iItem++)
		{
			pNextItem = FindNextDlgItem(pItem, bDialogEx);

			pszClassName = bDialogEx ?
				(LPWSTR)(((DLGITEMTEMPLATEEX*)pItem) + 1) :
				(LPWSTR)(pItem + 1);

			// Check if the class name begins with a '{'
			// If it does, that means it is an ActiveX Control in MSDEV (MFC) format
			if (pszClassName[0] == L'{')
			{
				// Item is an ActiveX control.
				bHasOleControls = TRUE;
			}
			else
			{
				// Item is not an ActiveX Control: make room for it in new template.
				cbNewTemplate += (BYTE*)pNextItem - (BYTE*)pItem;
			}

			pItem = pNextItem;
		}

		// No OLE controls were found, so there's no reason to go any further.
		if (!bHasOleControls)
			return pTemplate;

		// Copy entire header into new template.
		BYTE* pNew = (BYTE*)GlobalAlloc(GMEM_FIXED, cbNewTemplate);
		ATLASSUME(pNew != NULL);
		DLGTEMPLATE* pNewTemplate = (DLGTEMPLATE*)pNew;
		Checked::memcpy_s(pNew, cbNewTemplate, pTemplate, cbHeader);
		pNew += cbHeader;

		ULONG_PTR cbNewTemplateLast = cbNewTemplate;
		cbNewTemplate -= cbHeader;
		ATLENSURE(cbNewTemplate <= cbNewTemplateLast);

		// Initialize item count in new header to zero.
		DlgTemplateItemCount(pNewTemplate) = 0;

		pItem = pFirstItem;
		pNextItem = pItem;

		// Second pass through the dialog template.  On this pass, we want to:
		//    1. Copy all the non-OLE controls into the new template.
		for (iItem = 0; iItem < nItems; iItem++)
		{
			pNextItem = FindNextDlgItem(pItem, bDialogEx);

			pszClassName = bDialogEx ?
				(LPWSTR)(((DLGITEMTEMPLATEEX*)pItem) + 1) :
				(LPWSTR)(pItem + 1);

			if (pszClassName[0] != L'{')
			{
				// Item is not an OLE control: copy it to the new template.
				ULONG_PTR cbItem = (BYTE*)pNextItem - (BYTE*)pItem;
				ATLASSERT(cbItem >= (bDialogEx ?
					sizeof(DLGITEMTEMPLATEEX) :
					sizeof(DLGITEMTEMPLATE)));
				Checked::memcpy_s(pNew, cbNewTemplate, pItem, cbItem);
				pNew += cbItem;
				cbNewTemplateLast = cbNewTemplate;
				cbNewTemplate -= cbItem;
				ATLENSURE(cbNewTemplate <= cbNewTemplateLast);

				// Incrememt item count in new header.
				++DlgTemplateItemCount(pNewTemplate);
			}

			pItem = pNextItem;
		}
		return pNewTemplate;
	}

	static HRESULT ParseInitData(
		_Inout_opt_ IStream* pStream,
		_Deref_out_opt_z_ BSTR* pLicKey)
	{
		*pLicKey = NULL;
		if(pStream == NULL)
			return S_OK;	// nothing to do

		ULONG uRead;
		HRESULT hr;

		WORD nMsg;
		hr = pStream->Read(&nMsg, sizeof(WORD), &uRead);
		if (FAILED(hr))
			return hr;

		DWORD dwLen;
		hr = pStream->Read(&dwLen, sizeof(DWORD), &uRead);
		if (FAILED(hr))
			return hr;

		DWORD cchLicKey;
		hr = pStream->Read(&cchLicKey, sizeof(DWORD), &uRead);
		if (FAILED(hr))
			return hr;

		if (cchLicKey > 0)
		{
			CComBSTR bstr(cchLicKey);
			if (bstr.Length() == 0)
				return E_OUTOFMEMORY;
			memset(bstr.m_str, 0, (cchLicKey + 1) * sizeof(OLECHAR));
			hr = pStream->Read(bstr.m_str, cchLicKey * sizeof(OLECHAR), &uRead);
			if (FAILED(hr))
				return hr;
			*pLicKey = bstr.Detach();
		}

		// Extended (DATABINDING) stream format is not supported,
		// we reject databinding info but preserve other information
		if (nMsg == (WORD)ATL_WM_OCC_LOADFROMSTREAM_EX ||
			nMsg == (WORD)ATL_WM_OCC_LOADFROMSTORAGE_EX)
		{
			// Read the size of the section
			ULONG cbOffset;
			hr = pStream->Read(&cbOffset, sizeof(ULONG), &uRead);
			if (FAILED(hr))
				return hr;
			BYTE pTemp[1000];
			cbOffset -= sizeof(ULONG);

			while (cbOffset > 0)
			{
				pStream->Read(pTemp, (cbOffset < 1000 ? cbOffset : 1000), &uRead);
				cbOffset -= uRead;
			}
			return S_OK;
		}
		if (nMsg == (WORD)ATL_WM_OCC_LOADFROMSTREAM)
		{
			return S_OK;
		}
		return E_FAIL;
	}
};

/////////////////////////////////////////////////////////////////////////////
// CWindow - client side for a Windows window

class CWindow
{
public:
	static RECT rcDefault;
	HWND m_hWnd;

	CWindow(_In_opt_ HWND hWnd = NULL) throw() :
		m_hWnd(hWnd)
	{
	}

	CWindow& operator=(_In_opt_ HWND hWnd) throw()
	{
		m_hWnd = hWnd;
		return *this;
	}

	static LPCTSTR GetWndClassName() throw()
	{
		return NULL;
	}

	void Attach(_In_opt_ HWND hWndNew) throw()
	{
		ATLASSUME(m_hWnd == NULL);
		ATLASSERT((hWndNew == NULL) || ::IsWindow(hWndNew));
		m_hWnd = hWndNew;
	}

	HWND Detach() throw()
	{
		HWND hWnd = m_hWnd;
		m_hWnd = NULL;
		return hWnd;
	}

	HWND Create(
		_In_opt_z_ LPCTSTR lpstrWndClass,
		_In_opt_ HWND hWndParent,
		_In_ _U_RECT rect = NULL,
		_In_opt_z_ LPCTSTR szWindowName = NULL,
		_In_ DWORD dwStyle = 0,
		_In_ DWORD dwExStyle = 0,
		_In_ _U_MENUorID MenuOrID = 0U,
		_In_opt_ LPVOID lpCreateParam = NULL) throw()
	{
		ATLASSUME(m_hWnd == NULL);
		if(rect.m_lpRect == NULL)
			rect.m_lpRect = &rcDefault;
		m_hWnd = ::CreateWindowEx(dwExStyle, lpstrWndClass, szWindowName,
			dwStyle, rect.m_lpRect->left, rect.m_lpRect->top, rect.m_lpRect->right - rect.m_lpRect->left,
			rect.m_lpRect->bottom - rect.m_lpRect->top, hWndParent, MenuOrID.m_hMenu,
			_AtlBaseModule.GetModuleInstance(), lpCreateParam);
		return m_hWnd;
	}

	BOOL DestroyWindow() throw()
	{
		ATLASSERT(::IsWindow(m_hWnd));

		if(!::DestroyWindow(m_hWnd))
			return FALSE;

		m_hWnd = NULL;
		return TRUE;
	}

// Attributes

	operator HWND() const throw()
	{
		return m_hWnd;
	}

	DWORD GetStyle() const throw()
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (DWORD)::GetWindowLong(m_hWnd, GWL_STYLE);
	}

	DWORD GetExStyle() const throw()
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (DWORD)::GetWindowLong(m_hWnd, GWL_EXSTYLE);
	}

	LONG GetWindowLong(_In_ int nIndex) const throw()
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return ::GetWindowLong(m_hWnd, nIndex);
	}

	LONG_PTR GetWindowLongPtr(_In_ int nIndex) const throw()
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return ::GetWindowLongPtr(m_hWnd, nIndex);
	}

	LONG SetWindowLong(
		_In_ int nIndex,
		_In_ LONG dwNewLong) throw()
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return ::SetWindowLong(m_hWnd, nIndex, dwNewLong);
	}

	LONG_PTR SetWindowLongPtr(
		_In_ int nIndex,
		_In_ LONG_PTR dwNewLong) throw()
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return ::SetWindowLongPtr(m_hWnd, nIndex, dwNewLong);
	}

	WORD GetWindowWord(_In_ int nIndex) const throw()
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return ::GetWindowWord(m_hWnd, nIndex);
	}

	WORD SetWindowWord(
		_In_ int nIndex,
		_In_ WORD wNewWord) throw()
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return ::SetWindowWord(m_hWnd, nIndex, wNewWord);
	}

// Message Functions

	LRESULT SendMessage(
		_In_ UINT message,
		_In_ WPARAM wParam = 0,
		_In_ LPARAM lParam = 0) throw()
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return ::SendMessage(m_hWnd,message,wParam,lParam);
	}

	BOOL PostMessage(
		_In_ UINT message,
		_In_ WPARAM wParam = 0,
		_In_ LPARAM lParam = 0) throw()
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return ::PostMessage(m_hWnd,message,wParam,lParam);
	}

	BOOL SendNotifyMessage(
		_In_ UINT message,
		_In_ WPARAM wParam = 0,
		_In_ LPARAM lParam = 0) throw()
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return ::SendNotifyMessage(m_hWnd, message, wParam, lParam);
	}

	// support for C style macros
	static LRESULT SendMessage(
		_In_ HWND hWnd,
		_In_ UINT message,
		_In_ WPARAM wParam,
		_In_ LPARAM lParam) throw()
	{
		ATLASSERT(::IsWindow(hWnd));
		return ::SendMessage(hWnd, message, wParam, lParam);
	}

// Window Text Functions

	BOOL SetWindowText(_In_z_ LPCTSTR lpszString) throw()
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return ::SetWindowText(m_hWnd, lpszString);
	}

	int GetWindowText(
		_Out_z_cap_post_count_(nMaxCount, return + 1) LPTSTR lpszStringBuf,
		_In_ int nMaxCount) const throw()
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return ::GetWindowText(m_hWnd, lpszStringBuf, nMaxCount);
	}
	int GetWindowText(_Inout_ CSimpleString& strText) const
	{
		int nLength;
		LPTSTR pszText;

		nLength = GetWindowTextLength();
		pszText = strText.GetBuffer(nLength+1);
		nLength = GetWindowText(pszText, nLength+1);
		strText.ReleaseBuffer(nLength);

		return nLength;
	}
	int GetWindowTextLength() const throw()
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return ::GetWindowTextLength(m_hWnd);
	}

// Font Functions

	void SetFont(
		_In_ HFONT hFont,
		_In_ BOOL bRedraw = TRUE) throw()
	{
		ATLASSERT(::IsWindow(m_hWnd));
		::SendMessage(m_hWnd, WM_SETFONT, (WPARAM)hFont, MAKELPARAM(bRedraw, 0));
	}

	HFONT GetFont() const throw()
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (HFONT)::SendMessage(m_hWnd, WM_GETFONT, 0, 0);
	}

// Menu Functions (non-child windows only)

	HMENU GetMenu() const throw()
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (HMENU)::GetMenu(m_hWnd);
	}

	BOOL SetMenu(_In_ HMENU hMenu) throw()
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return ::SetMenu(m_hWnd, hMenu);
	}

	BOOL DrawMenuBar() throw()
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return ::DrawMenuBar(m_hWnd);
	}

	HMENU GetSystemMenu(_In_ BOOL bRevert) const throw()
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (HMENU)::GetSystemMenu(m_hWnd, bRevert);
	}

	BOOL HiliteMenuItem(
		_In_ HMENU hMenu,
		_In_ UINT uItemHilite,
		_In_ UINT uHilite) throw()
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return ::HiliteMenuItem(m_hWnd, hMenu, uItemHilite, uHilite);
	}

// Window Size and Position Functions

	BOOL IsIconic() const throw()
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return ::IsIconic(m_hWnd);
	}

	BOOL IsZoomed() const throw()
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return ::IsZoomed(m_hWnd);
	}

	BOOL MoveWindow(
		_In_ int x,
		_In_ int y,
		_In_ int nWidth,
		_In_ int nHeight,
		_In_ BOOL bRepaint = TRUE) throw()
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return ::MoveWindow(m_hWnd, x, y, nWidth, nHeight, bRepaint);
	}

	BOOL MoveWindow(
		_In_ LPCRECT lpRect,
		_In_ BOOL bRepaint = TRUE) throw()
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return ::MoveWindow(m_hWnd, lpRect->left, lpRect->top, lpRect->right - lpRect->left, lpRect->bottom - lpRect->top, bRepaint);
	}

	BOOL SetWindowPos(
		_In_opt_ HWND hWndInsertAfter,
		_In_ int x,
		_In_ int y,
		_In_ int cx,
		_In_ int cy,
		_In_ UINT nFlags) throw()
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return ::SetWindowPos(m_hWnd, hWndInsertAfter, x, y, cx, cy, nFlags);
	}

	BOOL SetWindowPos(
		_In_opt_ HWND hWndInsertAfter,
		_In_ LPCRECT lpRect,
		_In_ UINT nFlags) throw()
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return ::SetWindowPos(m_hWnd, hWndInsertAfter, lpRect->left, lpRect->top, lpRect->right - lpRect->left, lpRect->bottom - lpRect->top, nFlags);
	}

	UINT ArrangeIconicWindows() throw()
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return ::ArrangeIconicWindows(m_hWnd);
	}

	BOOL BringWindowToTop() throw()
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return ::BringWindowToTop(m_hWnd);
	}

	BOOL GetWindowRect(_Out_ LPRECT lpRect) const throw()
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return ::GetWindowRect(m_hWnd, lpRect);
	}

	BOOL GetClientRect(_Out_ LPRECT lpRect) const throw()
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return ::GetClientRect(m_hWnd, lpRect);
	}

	BOOL GetWindowPlacement(_Out_ WINDOWPLACEMENT FAR* lpwndpl) const throw()
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return ::GetWindowPlacement(m_hWnd, lpwndpl);
	}

	BOOL SetWindowPlacement(_In_ const WINDOWPLACEMENT FAR* lpwndpl) throw()
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return ::SetWindowPlacement(m_hWnd, lpwndpl);
	}

// Coordinate Mapping Functions

	BOOL ClientToScreen(_Inout_ LPPOINT lpPoint) const throw()
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return ::ClientToScreen(m_hWnd, lpPoint);
	}

	BOOL ClientToScreen(_Inout_ LPRECT lpRect) const throw()
	{
		ATLASSERT(::IsWindow(m_hWnd));
		if(!::ClientToScreen(m_hWnd, (LPPOINT)lpRect))
			return FALSE;
		return ::ClientToScreen(m_hWnd, ((LPPOINT)lpRect)+1);
	}

	BOOL ScreenToClient(_Inout_ LPPOINT lpPoint) const throw()
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return ::ScreenToClient(m_hWnd, lpPoint);
	}

	BOOL ScreenToClient(_Inout_ LPRECT lpRect) const throw()
	{
		ATLASSERT(::IsWindow(m_hWnd));
		if(!::ScreenToClient(m_hWnd, (LPPOINT)lpRect))
			return FALSE;
		return ::ScreenToClient(m_hWnd, ((LPPOINT)lpRect)+1);
	}

	int MapWindowPoints(
		_In_ HWND hWndTo,
		_Inout_cap_(nCount) LPPOINT lpPoint,
		_In_ UINT nCount) const throw()
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return ::MapWindowPoints(m_hWnd, hWndTo, lpPoint, nCount);
	}

	int MapWindowPoints(
		_In_ HWND hWndTo,
		_Inout_ LPRECT lpRect) const throw()
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return ::MapWindowPoints(m_hWnd, hWndTo, (LPPOINT)lpRect, 2);
	}

// Update and Painting Functions

	HDC BeginPaint(_Out_ LPPAINTSTRUCT lpPaint) throw()
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return ::BeginPaint(m_hWnd, lpPaint);
	}

	void EndPaint(_In_ LPPAINTSTRUCT lpPaint) throw()
	{
		ATLASSERT(::IsWindow(m_hWnd));
		::EndPaint(m_hWnd, lpPaint);
	}

	HDC GetDC() throw()
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return ::GetDC(m_hWnd);
	}

	HDC GetWindowDC() throw()
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return ::GetWindowDC(m_hWnd);
	}

	int ReleaseDC(_In_ HDC hDC) throw()
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return ::ReleaseDC(m_hWnd, hDC);
	}

	void Print(
		_In_ HDC hDC,
		_In_ DWORD dwFlags) const throw()
	{
		ATLASSERT(::IsWindow(m_hWnd));
		::SendMessage(m_hWnd, WM_PRINT, (WPARAM)hDC, dwFlags);
	}

	void PrintClient(
		_In_ HDC hDC,
		_In_ DWORD dwFlags) const throw()
	{
		ATLASSERT(::IsWindow(m_hWnd));
		::SendMessage(m_hWnd, WM_PRINTCLIENT, (WPARAM)hDC, dwFlags);
	}

	BOOL UpdateWindow() throw()
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return ::UpdateWindow(m_hWnd);
	}

	void SetRedraw(_In_ BOOL bRedraw = TRUE) throw()
	{
		ATLASSERT(::IsWindow(m_hWnd));
		::SendMessage(m_hWnd, WM_SETREDRAW, (WPARAM)bRedraw, 0);
	}

	BOOL GetUpdateRect(
		_In_opt_ LPRECT lpRect,
		_In_ BOOL bErase = FALSE) throw()
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return ::GetUpdateRect(m_hWnd, lpRect, bErase);
	}

	int GetUpdateRgn(
		_In_ HRGN hRgn,
		_In_ BOOL bErase = FALSE) throw()
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return ::GetUpdateRgn(m_hWnd, hRgn, bErase);
	}

	BOOL Invalidate(_In_ BOOL bErase = TRUE) throw()
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return ::InvalidateRect(m_hWnd, NULL, bErase);
	}

	BOOL InvalidateRect(
		_In_opt_ LPCRECT lpRect,
		_In_ BOOL bErase = TRUE) throw()
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return ::InvalidateRect(m_hWnd, lpRect, bErase);
	}

	BOOL ValidateRect(_In_opt_ LPCRECT lpRect) throw()
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return ::ValidateRect(m_hWnd, lpRect);
	}

	void InvalidateRgn(
		_In_ HRGN hRgn,
		_In_ BOOL bErase = TRUE) throw()
	{
		ATLASSERT(::IsWindow(m_hWnd));
		::InvalidateRgn(m_hWnd, hRgn, bErase);
	}

	BOOL ValidateRgn(_In_opt_ HRGN hRgn) throw()
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return ::ValidateRgn(m_hWnd, hRgn);
	}

	BOOL ShowWindow(_In_ int nCmdShow) throw()
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return ::ShowWindow(m_hWnd, nCmdShow);
	}

	BOOL IsWindowVisible() const throw()
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return ::IsWindowVisible(m_hWnd);
	}

	BOOL ShowOwnedPopups(_In_ BOOL bShow = TRUE) throw()
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return ::ShowOwnedPopups(m_hWnd, bShow);
	}

	HDC GetDCEx(
		_In_ HRGN hRgnClip,
		_In_ DWORD flags) throw()
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return ::GetDCEx(m_hWnd, hRgnClip, flags);
	}

	BOOL LockWindowUpdate(_In_ BOOL bLock = TRUE) throw()
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return ::LockWindowUpdate(bLock ? m_hWnd : NULL);
	}

	BOOL RedrawWindow(
		_In_opt_ LPCRECT lpRectUpdate = NULL,
		_In_opt_ HRGN hRgnUpdate = NULL,
		_In_ UINT flags = RDW_INVALIDATE | RDW_UPDATENOW | RDW_ERASE) throw()
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return ::RedrawWindow(m_hWnd, lpRectUpdate, hRgnUpdate, flags);
	}

// Timer Functions

	UINT_PTR SetTimer(
		_In_ UINT_PTR nIDEvent,
		_In_ UINT nElapse,
		_In_opt_ void (CALLBACK* lpfnTimer)(HWND, UINT, UINT_PTR, DWORD) = NULL) throw()
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return ::SetTimer(m_hWnd, nIDEvent, nElapse, (TIMERPROC)lpfnTimer);
	}

	BOOL KillTimer(_In_ UINT_PTR nIDEvent) throw()
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return ::KillTimer(m_hWnd, nIDEvent);
	}

// Window State Functions

	BOOL IsWindowEnabled() const throw()
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return ::IsWindowEnabled(m_hWnd);
	}

	BOOL EnableWindow(_In_ BOOL bEnable = TRUE) throw()
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return ::EnableWindow(m_hWnd, bEnable);
	}

	HWND SetActiveWindow() throw()
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return ::SetActiveWindow(m_hWnd);
	}

	HWND SetCapture() throw()
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return ::SetCapture(m_hWnd);
	}

	HWND SetFocus() throw()
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return ::SetFocus(m_hWnd);
	}

// Dialog-Box Item Functions

	BOOL CheckDlgButton(
		_In_ int nIDButton,
		_In_ UINT nCheck) throw()
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return ::CheckDlgButton(m_hWnd, nIDButton, nCheck);
	}

	BOOL CheckRadioButton(
		_In_ int nIDFirstButton,
		_In_ int nIDLastButton,
		_In_ int nIDCheckButton) throw()
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return ::CheckRadioButton(m_hWnd, nIDFirstButton, nIDLastButton, nIDCheckButton);
	}

	int DlgDirList(
		_Inout_z_ LPTSTR lpPathSpec,
		_In_ int nIDListBox,
		_In_ int nIDStaticPath,
		_In_ UINT nFileType) throw()
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return ::DlgDirList(m_hWnd, lpPathSpec, nIDListBox, nIDStaticPath, nFileType);
	}

	int DlgDirListComboBox(
		_Inout_z_ LPTSTR lpPathSpec,
		_In_ int nIDComboBox,
		_In_ int nIDStaticPath,
		_In_ UINT nFileType) throw()
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return ::DlgDirListComboBox(m_hWnd, lpPathSpec, nIDComboBox, nIDStaticPath, nFileType);
	}

	BOOL DlgDirSelect(
		_Out_z_cap_(nCount) LPTSTR lpString,
		_In_ int nCount,
		_In_ int nIDListBox) throw()
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return ::DlgDirSelectEx(m_hWnd, lpString, nCount, nIDListBox);
	}

	BOOL DlgDirSelectComboBox(
		_Out_z_cap_(nCount) LPTSTR lpString,
		_In_ int nCount,
		_In_ int nIDComboBox) throw()
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return ::DlgDirSelectComboBoxEx(m_hWnd, lpString, nCount, nIDComboBox);
	}

	UINT GetDlgItemInt(
		_In_ int nID,
		_Out_opt_ BOOL* lpTrans = NULL,
		_In_ BOOL bSigned = TRUE) const throw()
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return ::GetDlgItemInt(m_hWnd, nID, lpTrans, bSigned);
	}

	UINT GetDlgItemText(
		_In_ int nID,
		_Out_z_cap_post_count_(nMaxCount, return + 1) LPTSTR lpStr,
		_In_ int nMaxCount) const throw()
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return ::GetDlgItemText(m_hWnd, nID, lpStr, nMaxCount);
	}

	UINT GetDlgItemText(
		_In_ int nID,
		_Inout_ CSimpleString& strText) const
	{
		ATLASSERT(::IsWindow(m_hWnd));

		HWND hItem = GetDlgItem(nID);
		if (hItem != NULL)
		{
			int nLength;
			LPTSTR pszText;

			nLength = ::GetWindowTextLength(hItem);
			pszText = strText.GetBuffer(nLength+1);
			nLength = ::GetWindowText(hItem, pszText, nLength+1);
			strText.ReleaseBuffer(nLength);

			return nLength;
		}
		else
		{
			strText.Empty();

			return 0;
		}
	}
#ifdef _OLEAUTO_H_
	BOOL GetDlgItemText(
		_In_ int nID,
		_Inout_ _Deref_post_opt_z_ BSTR& bstrText) const throw()
	{
		ATLASSERT(::IsWindow(m_hWnd));

		HWND hWndCtl = GetDlgItem(nID);
		if(hWndCtl == NULL)
			return FALSE;

		return CWindow(hWndCtl).GetWindowText(bstrText);
	}
#endif // _OLEAUTO_H_
	CWindow GetNextDlgGroupItem(
		_In_ HWND hWndCtl,
		_In_ BOOL bPrevious = FALSE) const throw()
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return CWindow(::GetNextDlgGroupItem(m_hWnd, hWndCtl, bPrevious));
	}

	CWindow GetNextDlgTabItem(
		_In_ HWND hWndCtl,
		_In_ BOOL bPrevious = FALSE) const throw()
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return CWindow(::GetNextDlgTabItem(m_hWnd, hWndCtl, bPrevious));
	}

	UINT IsDlgButtonChecked(_In_ int nIDButton) const throw()
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return ::IsDlgButtonChecked(m_hWnd, nIDButton);
	}

	LRESULT SendDlgItemMessage(
		_In_ int nID,
		_In_ UINT message,
		_In_ WPARAM wParam = 0,
		_In_ LPARAM lParam = 0) throw()
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return ::SendDlgItemMessage(m_hWnd, nID, message, wParam, lParam);
	}

	BOOL SetDlgItemInt(
		_In_ int nID,
		_In_ UINT nValue,
		_In_ BOOL bSigned = TRUE) throw()
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return ::SetDlgItemInt(m_hWnd, nID, nValue, bSigned);
	}

	BOOL SetDlgItemText(
		_In_ int nID,
		_In_z_ LPCTSTR lpszString) throw()
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return ::SetDlgItemText(m_hWnd, nID, lpszString);
	}

#ifndef _ATL_NO_HOSTING
ATLPREFAST_SUPPRESS(6387)
	HRESULT GetDlgControl(
		_In_ int nID,
		_In_ REFIID iid,
		_Deref_out_ void** ppCtrl) throw()
	{
		ATLASSERT(::IsWindow(m_hWnd));
		ATLASSERT(ppCtrl != NULL);
		if (ppCtrl == NULL)
			return E_POINTER;
		*ppCtrl = NULL;
		HRESULT hr = HRESULT_FROM_WIN32(ERROR_CONTROL_ID_NOT_FOUND);
		HWND hWndCtrl = GetDlgItem(nID);
		if (hWndCtrl != NULL)
		{
			*ppCtrl = NULL;
			CComPtr<IUnknown> spUnk;
			hr = AtlAxGetControl(hWndCtrl, &spUnk);
			if (SUCCEEDED(hr))
				hr = spUnk->QueryInterface(iid, ppCtrl);
		}
		return hr;
	}
ATLPREFAST_UNSUPPRESS()

ATLPREFAST_SUPPRESS(6387)
	HRESULT GetDlgHost(
		_In_ int nID,
		_In_ REFIID iid,
		_Deref_out_ void** ppHost) throw()
	{
		ATLASSERT(::IsWindow(m_hWnd));
		ATLASSERT(ppHost != NULL);
		if (ppHost == NULL)
			return E_POINTER;
		*ppHost = NULL;
		HRESULT hr = HRESULT_FROM_WIN32(ERROR_CONTROL_ID_NOT_FOUND);
		HWND hWndCtrl = GetDlgItem(nID);
		if (hWndCtrl != NULL)
		{
			CComPtr<IUnknown> spUnk;
			hr = AtlAxGetHost(hWndCtrl, &spUnk);
			if (SUCCEEDED(hr))
				hr = spUnk->QueryInterface(iid, ppHost);
		}
		return hr;
	}
ATLPREFAST_UNSUPPRESS()
	
#endif //!_ATL_NO_HOSTING

// Scrolling Functions

	int GetScrollPos(_In_ int nBar) const throw()
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return ::GetScrollPos(m_hWnd, nBar);
	}

	BOOL GetScrollRange(
		_In_ int nBar,
		_Out_ LPINT lpMinPos,
		_Out_ LPINT lpMaxPos) const throw()
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return ::GetScrollRange(m_hWnd, nBar, lpMinPos, lpMaxPos);
	}

	BOOL ScrollWindow(
		_In_ int xAmount,
		_In_ int yAmount,
		_In_opt_ LPCRECT lpRect = NULL,
		_In_opt_ LPCRECT lpClipRect = NULL) throw()
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return ::ScrollWindow(m_hWnd, xAmount, yAmount, lpRect, lpClipRect);
	}

	int ScrollWindowEx(
		_In_ int dx,
		_In_ int dy,
		_In_opt_ LPCRECT lpRectScroll,
		_In_opt_ LPCRECT lpRectClip,
		_In_opt_ HRGN hRgnUpdate,
		_In_opt_ LPRECT lpRectUpdate,
		_In_ UINT uFlags) throw()
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return ::ScrollWindowEx(m_hWnd, dx, dy, lpRectScroll, lpRectClip, hRgnUpdate, lpRectUpdate, uFlags);
	}

	int ScrollWindowEx(
		_In_ int dx,
		_In_ int dy,
		_In_ UINT uFlags,
		_In_opt_ LPCRECT lpRectScroll = NULL,
		_In_opt_ LPCRECT lpRectClip = NULL,
		_In_opt_ HRGN hRgnUpdate = NULL,
		_In_opt_ LPRECT lpRectUpdate = NULL) throw()
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return ::ScrollWindowEx(m_hWnd, dx, dy, lpRectScroll, lpRectClip, hRgnUpdate, lpRectUpdate, uFlags);
	}

	int SetScrollPos(
		_In_ int nBar,
		_In_ int nPos,
		_In_ BOOL bRedraw = TRUE) throw()
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return ::SetScrollPos(m_hWnd, nBar, nPos, bRedraw);
	}

	BOOL SetScrollRange(
		_In_ int nBar,
		_In_ int nMinPos,
		_In_ int nMaxPos,
		_In_ BOOL bRedraw = TRUE) throw()
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return ::SetScrollRange(m_hWnd, nBar, nMinPos, nMaxPos, bRedraw);
	}

	BOOL ShowScrollBar(
		_In_ UINT nBar,
		_In_ BOOL bShow = TRUE) throw()
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return ::ShowScrollBar(m_hWnd, nBar, bShow);
	}

	BOOL EnableScrollBar(
		_In_ UINT uSBFlags,
		_In_ UINT uArrowFlags = ESB_ENABLE_BOTH) throw()
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return ::EnableScrollBar(m_hWnd, uSBFlags, uArrowFlags);
	}

// Window Access Functions

	CWindow ChildWindowFromPoint(_In_ POINT point) const throw()
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return CWindow(::ChildWindowFromPoint(m_hWnd, point));
	}

	CWindow ChildWindowFromPointEx(
		_In_ POINT point,
		_In_ UINT uFlags) const throw()
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return CWindow(::ChildWindowFromPointEx(m_hWnd, point, uFlags));
	}

	CWindow GetTopWindow() const throw()
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return CWindow(::GetTopWindow(m_hWnd));
	}

	CWindow GetWindow(_In_ UINT nCmd) const throw()
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return CWindow(::GetWindow(m_hWnd, nCmd));
	}

	CWindow GetLastActivePopup() const throw()
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return CWindow(::GetLastActivePopup(m_hWnd));
	}

	BOOL IsChild(_In_ HWND hWnd) const throw()
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return ::IsChild(m_hWnd, hWnd);
	}

	CWindow GetParent() const throw()
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return CWindow(::GetParent(m_hWnd));
	}

	CWindow SetParent(_In_ HWND hWndNewParent) throw()
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return CWindow(::SetParent(m_hWnd, hWndNewParent));
	}

// Window Tree Access

	int GetDlgCtrlID() const throw()
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return ::GetDlgCtrlID(m_hWnd);
	}

	int SetDlgCtrlID(_In_ int nID) throw()
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (int)::SetWindowLong(m_hWnd, GWL_ID, nID);
	}

	CWindow GetDlgItem(_In_ int nID) const throw()
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return CWindow(::GetDlgItem(m_hWnd, nID));
	}

// Alert Functions

	BOOL FlashWindow(_In_ BOOL bInvert) throw()
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return ::FlashWindow(m_hWnd, bInvert);
	}

	int MessageBox(
		_In_z_ LPCTSTR lpszText,
		_In_opt_z_ LPCTSTR lpszCaption = _T(""),
		_In_ UINT nType = MB_OK) throw()
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return ::MessageBox(m_hWnd, lpszText, lpszCaption, nType);
	}

// Clipboard Functions

	BOOL ChangeClipboardChain(_In_ HWND hWndNewNext) throw()
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return ::ChangeClipboardChain(m_hWnd, hWndNewNext);
	}

	HWND SetClipboardViewer() throw()
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return ::SetClipboardViewer(m_hWnd);
	}

	BOOL OpenClipboard() throw()
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return ::OpenClipboard(m_hWnd);
	}

// Caret Functions

	BOOL CreateCaret(_In_ HBITMAP hBitmap) throw()
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return ::CreateCaret(m_hWnd, hBitmap, 0, 0);
	}

	BOOL CreateSolidCaret(_In_ int nWidth, _In_ int nHeight) throw()
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return ::CreateCaret(m_hWnd, (HBITMAP)0, nWidth, nHeight);
	}

	BOOL CreateGrayCaret(_In_ int nWidth, _In_ int nHeight) throw()
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return ::CreateCaret(m_hWnd, (HBITMAP)1, nWidth, nHeight);
	}

	BOOL HideCaret() throw()
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return ::HideCaret(m_hWnd);
	}

	BOOL ShowCaret() throw()
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return ::ShowCaret(m_hWnd);
	}

#ifdef _INC_SHELLAPI
// Drag-Drop Functions
	void DragAcceptFiles(_In_ BOOL bAccept = TRUE) throw()
	{
		ATLASSERT(::IsWindow(m_hWnd)); ::DragAcceptFiles(m_hWnd, bAccept);
	}
#endif

// Icon Functions

	HICON SetIcon(
		_In_ HICON hIcon,
		_In_ BOOL bBigIcon = TRUE) throw()
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (HICON)::SendMessage(m_hWnd, WM_SETICON, bBigIcon, (LPARAM)hIcon);
	}

	HICON GetIcon(_In_ BOOL bBigIcon = TRUE) const throw()
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (HICON)::SendMessage(m_hWnd, WM_GETICON, bBigIcon, 0);
	}

// Help Functions

	BOOL WinHelp(
		_In_z_ LPCTSTR lpszHelp,
		_In_ UINT nCmd = HELP_CONTEXT,
		_In_ DWORD dwData = 0) throw()
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return ::WinHelp(m_hWnd, lpszHelp, nCmd, dwData);
	}

	BOOL SetWindowContextHelpId(_In_ DWORD dwContextHelpId) throw()
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return ::SetWindowContextHelpId(m_hWnd, dwContextHelpId);
	}

	DWORD GetWindowContextHelpId() const throw()
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return ::GetWindowContextHelpId(m_hWnd);
	}

// Hot Key Functions

	int SetHotKey(
		_In_ WORD wVirtualKeyCode,
		_In_ WORD wModifiers) throw()
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (int)::SendMessage(m_hWnd, WM_SETHOTKEY, MAKEWORD(wVirtualKeyCode, wModifiers), 0);
	}

	DWORD GetHotKey() const throw()
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (DWORD)::SendMessage(m_hWnd, WM_GETHOTKEY, 0, 0);
	}

// Misc. Operations

//N new
	BOOL GetScrollInfo(
		_In_ int nBar,
		_Out_ LPSCROLLINFO lpScrollInfo) throw()
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return ::GetScrollInfo(m_hWnd, nBar, lpScrollInfo);
	}
	int SetScrollInfo(
		_In_ int nBar,
		_In_ LPSCROLLINFO lpScrollInfo,
		_In_ BOOL bRedraw = TRUE) throw()
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return ::SetScrollInfo(m_hWnd, nBar, lpScrollInfo, bRedraw);
	}
	BOOL IsDialogMessage(_In_ LPMSG lpMsg) throw()
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return ::IsDialogMessage(m_hWnd, lpMsg);
	}

	void NextDlgCtrl() const throw()
	{
		ATLASSERT(::IsWindow(m_hWnd));
		::SendMessage(m_hWnd, WM_NEXTDLGCTL, 0, 0L);
	}
	void PrevDlgCtrl() const throw()
	{
		ATLASSERT(::IsWindow(m_hWnd));
		::SendMessage(m_hWnd, WM_NEXTDLGCTL, 1, 0L);
	}
	void GotoDlgCtrl(_In_ HWND hWndCtrl) const throw()
	{
		ATLASSERT(::IsWindow(m_hWnd));
		::SendMessage(m_hWnd, WM_NEXTDLGCTL, (WPARAM)hWndCtrl, 1L);
	}

	BOOL ResizeClient(
		_In_ int nWidth,
		_In_ int nHeight,
		_In_ BOOL bRedraw = TRUE) throw()
	{
		ATLASSERT(::IsWindow(m_hWnd));

		RECT rcWnd;
		if(!GetClientRect(&rcWnd))
			return FALSE;

		if(nWidth != -1)
			rcWnd.right = nWidth;
		if(nHeight != -1)
			rcWnd.bottom = nHeight;

		if(!::AdjustWindowRectEx(&rcWnd, GetStyle(), (!(GetStyle() & WS_CHILD) && (GetMenu() != NULL)), GetExStyle()))
			return FALSE;

		UINT uFlags = SWP_NOZORDER | SWP_NOMOVE | SWP_NOACTIVATE;
		if(!bRedraw)
			uFlags |= SWP_NOREDRAW;

		return SetWindowPos(NULL, 0, 0, rcWnd.right - rcWnd.left, rcWnd.bottom - rcWnd.top, uFlags);
	}

	int GetWindowRgn(_Out_ HRGN hRgn) throw()
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return ::GetWindowRgn(m_hWnd, hRgn);
	}
	int SetWindowRgn(
		_In_opt_ HRGN hRgn,
		_In_ BOOL bRedraw = FALSE) throw()
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return ::SetWindowRgn(m_hWnd, hRgn, bRedraw);
	}
	HDWP DeferWindowPos(
		_In_ HDWP hWinPosInfo,
		_In_ HWND hWndInsertAfter,
		_In_ int x,
		_In_ int y,
		_In_ int cx,
		_In_ int cy,
		_In_ UINT uFlags) throw()
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return ::DeferWindowPos(hWinPosInfo, m_hWnd, hWndInsertAfter, x, y, cx, cy, uFlags);
	}
	DWORD GetWindowThreadID() throw()
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return ::GetWindowThreadProcessId(m_hWnd, NULL);
	}
	DWORD GetWindowProcessID() throw()
	{
		ATLASSERT(::IsWindow(m_hWnd));
		DWORD dwProcessID;
		::GetWindowThreadProcessId(m_hWnd, &dwProcessID);
		return dwProcessID;
	}
	BOOL IsWindow() const throw()
	{
		return ::IsWindow(m_hWnd);
	}
	BOOL IsWindowUnicode() const throw()
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return ::IsWindowUnicode(m_hWnd);
	}
	BOOL IsParentDialog() throw()
	{
		ATLASSERT(::IsWindow(m_hWnd));
		TCHAR szBuf[8]; // "#32770" + NUL character
		if (GetClassName(GetParent(), szBuf, sizeof(szBuf)/sizeof(szBuf[0])) == 0)
			return FALSE;
		return lstrcmp(szBuf, _T("#32770")) == 0;
	}
	BOOL ShowWindowAsync(_In_ int nCmdShow) throw()
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return ::ShowWindowAsync(m_hWnd, nCmdShow);
	}

	CWindow GetDescendantWindow(_In_ int nID) const throw()
	{
		ATLASSERT(::IsWindow(m_hWnd));

		// GetDlgItem recursive (return first found)
		// breadth-first for 1 level, then depth-first for next level

		// use GetDlgItem since it is a fast USER function
		HWND hWndChild, hWndTmp;
		if((hWndChild = ::GetDlgItem(m_hWnd, nID)) != NULL)
		{
			if(::GetTopWindow(hWndChild) != NULL)
			{
				// children with the same ID as their parent have priority
				CWindow wnd(hWndChild);
				hWndTmp = wnd.GetDescendantWindow(nID);
				if(hWndTmp != NULL)
					return CWindow(hWndTmp);
			}
			return CWindow(hWndChild);
		}

		// walk each child
		for(hWndChild = ::GetTopWindow(m_hWnd); hWndChild != NULL;
			hWndChild = ::GetNextWindow(hWndChild, GW_HWNDNEXT))
		{
			CWindow wnd(hWndChild);
			hWndTmp = wnd.GetDescendantWindow(nID);
			if(hWndTmp != NULL)
				return CWindow(hWndTmp);
		}

		return CWindow(NULL);    // not found
	}

	void SendMessageToDescendants(
		_In_ UINT message,
		_In_ WPARAM wParam = 0,
		_In_ LPARAM lParam = 0,
		_In_ BOOL bDeep = TRUE) throw()
	{
		for(HWND hWndChild = ::GetTopWindow(m_hWnd); hWndChild != NULL;
			hWndChild = ::GetNextWindow(hWndChild, GW_HWNDNEXT))
		{
			::SendMessage(hWndChild, message, wParam, lParam);

			if(bDeep && ::GetTopWindow(hWndChild) != NULL)
			{
				// send to child windows after parent
				CWindow wnd(hWndChild);
				wnd.SendMessageToDescendants(message, wParam, lParam, bDeep);
			}
		}
	}

	BOOL CenterWindow(_In_ HWND hWndCenter = NULL) throw()
	{
		ATLASSERT(::IsWindow(m_hWnd));

		// determine owner window to center against
		DWORD dwStyle = GetStyle();
		if(hWndCenter == NULL)
		{
			if(dwStyle & WS_CHILD)
				hWndCenter = ::GetParent(m_hWnd);
			else
				hWndCenter = ::GetWindow(m_hWnd, GW_OWNER);
		}

		// get coordinates of the window relative to its parent
		RECT rcDlg;
		::GetWindowRect(m_hWnd, &rcDlg);
		RECT rcArea;
		RECT rcCenter;
		HWND hWndParent;
		if(!(dwStyle & WS_CHILD))
		{
			// don't center against invisible or minimized windows
			if(hWndCenter != NULL)
			{
				DWORD dwStyleCenter = ::GetWindowLong(hWndCenter, GWL_STYLE);
				if(!(dwStyleCenter & WS_VISIBLE) || (dwStyleCenter & WS_MINIMIZE))
					hWndCenter = NULL;
			}

			// center within screen coordinates
#if WINVER < 0x0500
			::SystemParametersInfo(SPI_GETWORKAREA, NULL, &rcArea, NULL);
#else
			HMONITOR hMonitor = NULL;
			if(hWndCenter != NULL)
			{
				hMonitor = ::MonitorFromWindow(hWndCenter, MONITOR_DEFAULTTONEAREST);
			}
			else
			{
				hMonitor = ::MonitorFromWindow(m_hWnd, MONITOR_DEFAULTTONEAREST);
			}
			ATLENSURE_RETURN_VAL(hMonitor != NULL, FALSE);

			MONITORINFO minfo;
			minfo.cbSize = sizeof(MONITORINFO);
			BOOL bResult = ::GetMonitorInfo(hMonitor, &minfo);
			ATLENSURE_RETURN_VAL(bResult, FALSE);

			rcArea = minfo.rcWork;
#endif
			if(hWndCenter == NULL)
				rcCenter = rcArea;
			else
				::GetWindowRect(hWndCenter, &rcCenter);
		}
		else
		{
			// center within parent client coordinates
			hWndParent = ::GetParent(m_hWnd);
			ATLASSERT(::IsWindow(hWndParent));

			::GetClientRect(hWndParent, &rcArea);
			ATLASSERT(::IsWindow(hWndCenter));
			::GetClientRect(hWndCenter, &rcCenter);
			::MapWindowPoints(hWndCenter, hWndParent, (POINT*)&rcCenter, 2);
		}

		int DlgWidth = rcDlg.right - rcDlg.left;
		int DlgHeight = rcDlg.bottom - rcDlg.top;

		// find dialog's upper left based on rcCenter
		int xLeft = (rcCenter.left + rcCenter.right) / 2 - DlgWidth / 2;
		int yTop = (rcCenter.top + rcCenter.bottom) / 2 - DlgHeight / 2;

		// if the dialog is outside the screen, move it inside
		if(xLeft + DlgWidth > rcArea.right)
			xLeft = rcArea.right - DlgWidth;
		if(xLeft < rcArea.left)
			xLeft = rcArea.left;

		if(yTop + DlgHeight > rcArea.bottom)
			yTop = rcArea.bottom - DlgHeight;
		if(yTop < rcArea.top)
			yTop = rcArea.top;

		// map screen coordinates to child coordinates
		return ::SetWindowPos(m_hWnd, NULL, xLeft, yTop, -1, -1,
			SWP_NOSIZE | SWP_NOZORDER | SWP_NOACTIVATE);
	}

	BOOL ModifyStyle(
		_In_ DWORD dwRemove,
		_In_ DWORD dwAdd,
		_In_ UINT nFlags = 0) throw()
	{
		ATLASSERT(::IsWindow(m_hWnd));

		DWORD dwStyle = ::GetWindowLong(m_hWnd, GWL_STYLE);
		DWORD dwNewStyle = (dwStyle & ~dwRemove) | dwAdd;
		if(dwStyle == dwNewStyle)
			return FALSE;

		::SetWindowLong(m_hWnd, GWL_STYLE, dwNewStyle);
		if(nFlags != 0)
		{
			::SetWindowPos(m_hWnd, NULL, 0, 0, 0, 0,
				SWP_NOSIZE | SWP_NOMOVE | SWP_NOZORDER | SWP_NOACTIVATE | nFlags);
		}

		return TRUE;
	}

	BOOL ModifyStyleEx(
		_In_ DWORD dwRemove,
		_In_ DWORD dwAdd,
		_In_ UINT nFlags = 0) throw()
	{
		ATLASSERT(::IsWindow(m_hWnd));

		DWORD dwStyle = ::GetWindowLong(m_hWnd, GWL_EXSTYLE);
		DWORD dwNewStyle = (dwStyle & ~dwRemove) | dwAdd;
		if(dwStyle == dwNewStyle)
			return FALSE;

		::SetWindowLong(m_hWnd, GWL_EXSTYLE, dwNewStyle);
		if(nFlags != 0)
		{
			::SetWindowPos(m_hWnd, NULL, 0, 0, 0, 0,
				SWP_NOSIZE | SWP_NOMOVE | SWP_NOZORDER | SWP_NOACTIVATE | nFlags);
		}

		return TRUE;
	}

#ifdef _OLEAUTO_H_
	BOOL GetWindowText(_Inout_ _Deref_post_opt_z_ BSTR* pbstrText) throw()
	{
		return GetWindowText(*pbstrText);
	}
	BOOL GetWindowText(_Deref_out_opt_z_ BSTR& bstrText) throw()
	{
		USES_CONVERSION_EX;
		ATLASSERT(::IsWindow(m_hWnd));
		::SysFreeString(bstrText);
		bstrText = NULL;

		int nLen = ::GetWindowTextLength(m_hWnd);

		CTempBuffer<TCHAR> lpszText;
		if(nLen>0)
		{
			ATLTRY(lpszText.Allocate(nLen+1));
			if (lpszText == NULL)
			{
				return FALSE;
			}

			if(!::GetWindowText(m_hWnd, lpszText, nLen+1))
			{
				return FALSE;
			}
		}

		bstrText = ::SysAllocString(T2OLE_EX_DEF(lpszText));

		return nLen==0 ? FALSE : ((bstrText != NULL) ? TRUE : FALSE);
	}
#endif // _OLEAUTO_H_
	CWindow GetTopLevelParent() const throw()
	{
		ATLASSERT(::IsWindow(m_hWnd));

		HWND hWndParent = m_hWnd;
		HWND hWndTmp;
		while((hWndTmp = ::GetParent(hWndParent)) != NULL)
			hWndParent = hWndTmp;

		return CWindow(hWndParent);
	}

	CWindow GetTopLevelWindow() const throw()
	{
		ATLASSERT(::IsWindow(m_hWnd));

		HWND hWndParent;
		HWND hWndTmp = m_hWnd;

		do
		{
			hWndParent = hWndTmp;
			hWndTmp = (::GetWindowLong(hWndParent, GWL_STYLE) & WS_CHILD) ? ::GetParent(hWndParent) : ::GetWindow(hWndParent, GW_OWNER);
		}
		while(hWndTmp != NULL);

		return CWindow(hWndParent);
	}
};

_declspec(selectany) RECT CWindow::rcDefault = { CW_USEDEFAULT, CW_USEDEFAULT, 0, 0 };

/////////////////////////////////////////////////////////////////////////////
// CAxWindow - client side for an ActiveX host window

#ifndef _ATL_NO_HOSTING

ATLPREFAST_SUPPRESS(6387)
template <class TBase /* = CWindow */>
class CAxWindowT : 
	public TBase
{
public:
// Constructors
	CAxWindowT(_In_opt_ HWND hWnd = NULL) : TBase(hWnd)
	{
		AtlAxWinInit();
	}

	CAxWindowT< TBase >& operator=(_In_ HWND hWnd)
	{
		m_hWnd = hWnd;
		return *this;
	}

// Attributes
	static LPCTSTR GetWndClassName()
	{
		return _T(ATLAXWIN_CLASS);
	}

// Operations
	HWND Create(
		_In_opt_ HWND hWndParent,
		_In_ _U_RECT rect = NULL,
		_In_opt_z_ LPCTSTR szWindowName = NULL,
		_In_ DWORD dwStyle = 0,
		_In_ DWORD dwExStyle = 0,
		_In_ _U_MENUorID MenuOrID = 0U,
		_In_opt_ LPVOID lpCreateParam = NULL)
	{
		return CWindow::Create(GetWndClassName(), hWndParent, rect, szWindowName, dwStyle, dwExStyle, MenuOrID, lpCreateParam);
	}

	HRESULT CreateControl(
		_In_z_ LPCOLESTR lpszName,
		_Inout_opt_ IStream* pStream = NULL,
		_Deref_opt_out_ IUnknown** ppUnkContainer = NULL)
	{
		return CreateControlEx(lpszName, pStream, ppUnkContainer);
	}

	HRESULT CreateControl(
		_In_ DWORD dwResID,
		_Inout_opt_ IStream* pStream = NULL,
		_Deref_opt_out_ IUnknown** ppUnkContainer = NULL)
	{
		return CreateControlEx(dwResID, pStream, ppUnkContainer);
	}

	HRESULT CreateControlEx(
		_In_z_ LPCOLESTR lpszName,
		_Inout_opt_ IStream* pStream = NULL,
		_Deref_opt_out_ IUnknown** ppUnkContainer = NULL,
		_Deref_opt_out_ IUnknown** ppUnkControl = NULL,
		_In_ REFIID iidSink = IID_NULL,
		_Inout_opt_ IUnknown* punkSink = NULL)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		// We must have a valid window!

		// Get a pointer to the container object connected to this window
		CComPtr<IAxWinHostWindow> spWinHost;
		HRESULT hr = QueryHost(&spWinHost);

		// If QueryHost failed, there is no host attached to this window
		// We assume that the user wants to create a new host and subclass the current window
		if (FAILED(hr))
			return AtlAxCreateControlEx(lpszName, m_hWnd, pStream, ppUnkContainer, ppUnkControl, iidSink, punkSink);

		// Create the control requested by the caller
		CComPtr<IUnknown> pControl;
		if (SUCCEEDED(hr))
			hr = spWinHost->CreateControlEx(lpszName, m_hWnd, pStream, &pControl, iidSink, punkSink);

		// Send back the necessary interface pointers
		if (SUCCEEDED(hr))
		{
			if (ppUnkControl)
				*ppUnkControl = pControl.Detach();

			if (ppUnkContainer)
			{
				hr = spWinHost.QueryInterface(ppUnkContainer);
				ATLASSERT(SUCCEEDED(hr)); // This should not fail!
			}
		}

		return hr;
	}

	HRESULT CreateControlEx(
		_In_ DWORD dwResID,
		_Inout_opt_ IStream* pStream = NULL,
		_Deref_opt_out_ IUnknown** ppUnkContainer = NULL,
		_Deref_opt_out_ IUnknown** ppUnkControl = NULL,
		_In_ REFIID iidSink = IID_NULL,
		_Inout_opt_ IUnknown* punkSink = NULL)
	{
		TCHAR szModule[MAX_PATH];
		DWORD dwFLen = GetModuleFileName(_AtlBaseModule.GetModuleInstance(), szModule, MAX_PATH);
		if( dwFLen == 0 )
			return AtlHresultFromLastError();
		else if( dwFLen == MAX_PATH )
			return HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER);

		CComBSTR bstrURL(OLESTR("res://"));
		HRESULT hr=bstrURL.Append(szModule);
		if(FAILED(hr))
		{
			return hr;
		}
		hr=bstrURL.Append(OLESTR("/"));
		if(FAILED(hr))
		{
			return hr;
		}
		TCHAR szResID[11];
		if (_stprintf_s(szResID, _countof(szResID), _T("%0d"), dwResID) == -1)
		{
			return HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER);
		}
		hr=bstrURL.Append(szResID);
		if(FAILED(hr))
		{
			return hr;
		}

		ATLASSERT(::IsWindow(m_hWnd));
		return CreateControlEx(bstrURL, pStream, ppUnkContainer, ppUnkControl, iidSink, punkSink);
	}

	HRESULT AttachControl(
		_Inout_ IUnknown* pControl,
		_Deref_out_ IUnknown** ppUnkContainer)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		// We must have a valid window!

		// Get a pointer to the container object connected to this window
		CComPtr<IAxWinHostWindow> spWinHost;
		HRESULT hr = QueryHost(&spWinHost);

		// If QueryHost failed, there is no host attached to this window
		// We assume that the user wants to create a new host and subclass the current window
		if (FAILED(hr))
			return AtlAxAttachControl(pControl, m_hWnd, ppUnkContainer);

		// Attach the control specified by the caller
		if (SUCCEEDED(hr))
			hr = spWinHost->AttachControl(pControl, m_hWnd);

		// Get the IUnknown interface of the container
		if (SUCCEEDED(hr) && ppUnkContainer)
		{
			hr = spWinHost.QueryInterface(ppUnkContainer);
			ATLASSERT(SUCCEEDED(hr)); // This should not fail!
		}

		return hr;
	}

	HRESULT QueryHost(
		_In_ REFIID iid,
		_Deref_out_ void** ppUnk)
	{
		ATLASSERT(ppUnk != NULL);
		if (ppUnk == NULL)
			return E_POINTER;
		HRESULT hr;
		*ppUnk = NULL;
		CComPtr<IUnknown> spUnk;
		hr = AtlAxGetHost(m_hWnd, &spUnk);
		if (SUCCEEDED(hr))
			hr = spUnk->QueryInterface(iid, ppUnk);
		return hr;
	}
	
	template <class Q>
	HRESULT QueryHost(_Deref_out_ Q** ppUnk)
	{
		return QueryHost(__uuidof(Q), (void**)ppUnk);
	}

	HRESULT QueryControl(
		_In_ REFIID iid,
		_Deref_out_ void** ppUnk)
	{
		ATLASSERT(ppUnk != NULL);
		if (ppUnk == NULL)
			return E_POINTER;
		HRESULT hr;
		*ppUnk = NULL;
		CComPtr<IUnknown> spUnk;
		hr = AtlAxGetControl(m_hWnd, &spUnk);
		if (SUCCEEDED(hr))
			hr = spUnk->QueryInterface(iid, ppUnk);
		return hr;
	}
	
	template <class Q>
	HRESULT QueryControl(_Deref_out_ Q** ppUnk)
	{
		return QueryControl(__uuidof(Q), (void**)ppUnk);
	}
	HRESULT SetExternalDispatch(_Inout_ IDispatch* pDisp)
	{
		HRESULT hr;
		CComPtr<IAxWinHostWindow> spHost;
		hr = QueryHost(__uuidof(IAxWinHostWindow), (void**)&spHost);
		if (SUCCEEDED(hr))
			hr = spHost->SetExternalDispatch(pDisp);
		return hr;
	}
	HRESULT SetExternalUIHandler(_Inout_ IDocHostUIHandlerDispatch* pUIHandler)
	{
		HRESULT hr;
		CComPtr<IAxWinHostWindow> spHost;
		hr = QueryHost(__uuidof(IAxWinHostWindow), (void**)&spHost);
		if (SUCCEEDED(hr))
			hr = spHost->SetExternalUIHandler(pUIHandler);
		return hr;
	}
};
ATLPREFAST_UNSUPPRESS()
	
typedef CAxWindowT<CWindow> CAxWindow;

template <class TBase /* = CWindow */>
class CAxWindow2T : 
	public CAxWindowT<TBase>
{
public:
// Constructors
	CAxWindow2T(_In_opt_ HWND hWnd = NULL) : 
		CAxWindowT<TBase>(hWnd)
	{
	}

	CAxWindow2T< TBase >& operator=(_In_ HWND hWnd)
	{
		m_hWnd = hWnd;
		return *this;
	}

// Attributes
	static LPCTSTR GetWndClassName()
	{
		return _T(ATLAXWINLIC_CLASS);
	}

// Operations
	HWND Create(
		_In_opt_ HWND hWndParent,
		_In_ _U_RECT rect = NULL,
		_In_opt_z_ LPCTSTR szWindowName = NULL,
		_In_ DWORD dwStyle = 0,
		_In_ DWORD dwExStyle = 0,
		_In_ _U_MENUorID MenuOrID = 0U,
		_In_opt_ LPVOID lpCreateParam = NULL)
	{
		return CWindow::Create(GetWndClassName(), hWndParent, rect, szWindowName, dwStyle, dwExStyle, MenuOrID, lpCreateParam);
	}

	HRESULT CreateControlLic(
		_In_z_ LPCOLESTR lpszName,
		_Inout_opt_ IStream* pStream = NULL,
		_Deref_opt_out_ IUnknown** ppUnkContainer = NULL,
		_In_opt_z_ BSTR bstrLicKey = NULL)
	{
		return CreateControlLicEx(lpszName, pStream, ppUnkContainer, NULL, IID_NULL, NULL, bstrLicKey);
	}

	HRESULT CreateControlLic(
		_In_ DWORD dwResID,
		_Inout_opt_ IStream* pStream = NULL,
		_Deref_opt_out_ IUnknown** ppUnkContainer = NULL,
		_In_opt_z_ BSTR bstrLicKey = NULL)
	{
		return CreateControlLicEx(dwResID, pStream, ppUnkContainer, NULL, IID_NULL, NULL, bstrLicKey);
	}

	HRESULT CreateControlLicEx(
		_In_z_ LPCOLESTR lpszName,
		_Inout_opt_ IStream* pStream = NULL,
		_Deref_opt_out_ IUnknown** ppUnkContainer = NULL,
		_Deref_opt_out_ IUnknown** ppUnkControl = NULL,
		_In_ REFIID iidSink = IID_NULL,
		_Inout_opt_ IUnknown* punkSink = NULL,
		_In_opt_z_ BSTR bstrLicKey = NULL)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		// We must have a valid window!

		// Get a pointer to the container object connected to this window
		CComPtr<IAxWinHostWindowLic> spWinHost;
		HRESULT hr = QueryHost(&spWinHost);

		// If QueryHost failed, there is no host attached to this window
		// We assume that the user wants to create a new host and subclass the current window
		if (FAILED(hr))
			return AtlAxCreateControlLicEx(lpszName, m_hWnd, pStream, ppUnkContainer, ppUnkControl, iidSink, punkSink, bstrLicKey);

		// Create the control requested by the caller
		CComPtr<IUnknown> pControl;
		if (SUCCEEDED(hr))
			hr = spWinHost->CreateControlLicEx(lpszName, m_hWnd, pStream, &pControl, iidSink, punkSink, bstrLicKey);

		// Send back the necessary interface pointers
		if (SUCCEEDED(hr))
		{
			if (ppUnkControl)
				*ppUnkControl = pControl.Detach();

			if (ppUnkContainer)
			{
				hr = spWinHost.QueryInterface(ppUnkContainer);
				ATLASSERT(SUCCEEDED(hr)); // This should not fail!
			}
		}

		return hr;
	}

	HRESULT CreateControlLicEx(
		_In_ DWORD dwResID,
		_Inout_opt_ IStream* pStream = NULL,
		_Deref_opt_out_ IUnknown** ppUnkContainer = NULL,
		_Deref_opt_out_ IUnknown** ppUnkControl = NULL,
		_In_ REFIID iidSink = IID_NULL,
		_Inout_opt_ IUnknown* punkSink = NULL,
		_In_opt_z_ BSTR bstrLickey = NULL)
	{
		TCHAR szModule[MAX_PATH];
		DWORD dwFLen = GetModuleFileName(_AtlBaseModule.GetModuleInstance(), szModule, MAX_PATH);
		if( dwFLen == 0 )
			return AtlHresultFromLastError();
		else if( dwFLen == MAX_PATH )
			return HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER);

		CComBSTR bstrURL(OLESTR("res://"));
		HRESULT hr = bstrURL.Append(szModule);
		if (FAILED(hr))
			return hr;
		hr = bstrURL.Append(OLESTR("/"));
		if (FAILED(hr))
			return hr;

		TCHAR szResID[11];
		if (_stprintf_s(szResID, _countof(szResID), _T("%0d"), dwResID) == -1)
		{
			return HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER);
		}
		hr = bstrURL.Append(szResID);
		if (FAILED(hr))
			return hr;

		ATLASSERT(::IsWindow(m_hWnd));
		return CreateControlLicEx(bstrURL, pStream, ppUnkContainer, ppUnkControl, iidSink, punkSink, bstrLickey);
	}
};

typedef CAxWindow2T<CWindow> CAxWindow2;


#endif //_ATL_NO_HOSTING

/////////////////////////////////////////////////////////////////////////////
// WindowProc thunks

class CWndProcThunk
{
public:
	_AtlCreateWndData cd;
	CStdCallThunk thunk;

	BOOL Init(
		_In_opt_ WNDPROC proc,
		_In_opt_ void* pThis)
	{
		return thunk.Init((DWORD_PTR)proc, pThis);
	}
	WNDPROC GetWNDPROC()
	{
		return (WNDPROC)thunk.GetCodeAddress();
	}
};

/////////////////////////////////////////////////////////////////////////////
// CMessageMap - abstract class that provides an interface for message maps

class ATL_NO_VTABLE CMessageMap
{
public:
	virtual BOOL ProcessWindowMessage(
		_In_ HWND hWnd,
		_In_ UINT uMsg,
		_In_ WPARAM wParam,
		_In_ LPARAM lParam,
		_Inout_ LRESULT& lResult,
		_In_ DWORD dwMsgMapID) = 0;
};

/////////////////////////////////////////////////////////////////////////////
// Message map

#define BEGIN_MSG_MAP(theClass) \
public: \
	BOOL ProcessWindowMessage(_In_ HWND hWnd, _In_ UINT uMsg, _In_ WPARAM wParam,\
		_In_ LPARAM lParam, _Inout_ LRESULT& lResult, _In_ DWORD dwMsgMapID = 0) \
	{ \
		BOOL bHandled = TRUE; \
		(hWnd); \
		(uMsg); \
		(wParam); \
		(lParam); \
		(lResult); \
		(bHandled); \
		switch(dwMsgMapID) \
		{ \
		case 0:

#define ALT_MSG_MAP(msgMapID) \
		break; \
		case msgMapID:

#define MESSAGE_HANDLER(msg, func) \
	if(uMsg == msg) \
	{ \
		bHandled = TRUE; \
		lResult = func(uMsg, wParam, lParam, bHandled); \
		if(bHandled) \
			return TRUE; \
	}

#define MESSAGE_RANGE_HANDLER(msgFirst, msgLast, func) \
	if(uMsg >= msgFirst && uMsg <= msgLast) \
	{ \
		bHandled = TRUE; \
		lResult = func(uMsg, wParam, lParam, bHandled); \
		if(bHandled) \
			return TRUE; \
	}

#define COMMAND_HANDLER(id, code, func) \
	if(uMsg == WM_COMMAND && id == LOWORD(wParam) && code == HIWORD(wParam)) \
	{ \
		bHandled = TRUE; \
		lResult = func(HIWORD(wParam), LOWORD(wParam), (HWND)lParam, bHandled); \
		if(bHandled) \
			return TRUE; \
	}

#define COMMAND_ID_HANDLER(id, func) \
	if(uMsg == WM_COMMAND && id == LOWORD(wParam)) \
	{ \
		bHandled = TRUE; \
		lResult = func(HIWORD(wParam), LOWORD(wParam), (HWND)lParam, bHandled); \
		if(bHandled) \
			return TRUE; \
	}

#define COMMAND_CODE_HANDLER(code, func) \
	if(uMsg == WM_COMMAND && code == HIWORD(wParam)) \
	{ \
		bHandled = TRUE; \
		lResult = func(HIWORD(wParam), LOWORD(wParam), (HWND)lParam, bHandled); \
		if(bHandled) \
			return TRUE; \
	}

#define COMMAND_RANGE_HANDLER(idFirst, idLast, func) \
	if(uMsg == WM_COMMAND && LOWORD(wParam) >= idFirst  && LOWORD(wParam) <= idLast) \
	{ \
		bHandled = TRUE; \
		lResult = func(HIWORD(wParam), LOWORD(wParam), (HWND)lParam, bHandled); \
		if(bHandled) \
			return TRUE; \
	}

#define COMMAND_RANGE_CODE_HANDLER(idFirst, idLast, code, func) \
	if(uMsg == WM_COMMAND && code == HIWORD(wParam) && LOWORD(wParam) >= idFirst  && LOWORD(wParam) <= idLast) \
	{ \
		bHandled = TRUE; \
		lResult = func(HIWORD(wParam), LOWORD(wParam), (HWND)lParam, bHandled); \
		if(bHandled) \
			return TRUE; \
	}

#define NOTIFY_HANDLER(id, cd, func) \
	if(uMsg == WM_NOTIFY && id == ((LPNMHDR)lParam)->idFrom && cd == ((LPNMHDR)lParam)->code) \
	{ \
		bHandled = TRUE; \
		lResult = func((int)wParam, (LPNMHDR)lParam, bHandled); \
		if(bHandled) \
			return TRUE; \
	}

#define NOTIFY_ID_HANDLER(id, func) \
	if(uMsg == WM_NOTIFY && id == ((LPNMHDR)lParam)->idFrom) \
	{ \
		bHandled = TRUE; \
		lResult = func((int)wParam, (LPNMHDR)lParam, bHandled); \
		if(bHandled) \
			return TRUE; \
	}

#define NOTIFY_CODE_HANDLER(cd, func) \
	if(uMsg == WM_NOTIFY && cd == ((LPNMHDR)lParam)->code) \
	{ \
		bHandled = TRUE; \
		lResult = func((int)wParam, (LPNMHDR)lParam, bHandled); \
		if(bHandled) \
			return TRUE; \
	}

#define NOTIFY_RANGE_HANDLER(idFirst, idLast, func) \
	if(uMsg == WM_NOTIFY && ((LPNMHDR)lParam)->idFrom >= idFirst && ((LPNMHDR)lParam)->idFrom <= idLast) \
	{ \
		bHandled = TRUE; \
		lResult = func((int)wParam, (LPNMHDR)lParam, bHandled); \
		if(bHandled) \
			return TRUE; \
	}

#define NOTIFY_RANGE_CODE_HANDLER(idFirst, idLast, cd, func) \
	if(uMsg == WM_NOTIFY && cd == ((LPNMHDR)lParam)->code && ((LPNMHDR)lParam)->idFrom >= idFirst && ((LPNMHDR)lParam)->idFrom <= idLast) \
	{ \
		bHandled = TRUE; \
		lResult = func((int)wParam, (LPNMHDR)lParam, bHandled); \
		if(bHandled) \
			return TRUE; \
	}

#define CHAIN_MSG_MAP(theChainClass) \
	{ \
		if(theChainClass::ProcessWindowMessage(hWnd, uMsg, wParam, lParam, lResult)) \
			return TRUE; \
	}

#define CHAIN_MSG_MAP_MEMBER(theChainMember) \
	{ \
		if(theChainMember.ProcessWindowMessage(hWnd, uMsg, wParam, lParam, lResult)) \
			return TRUE; \
	}

#define CHAIN_MSG_MAP_ALT(theChainClass, msgMapID) \
	{ \
		if(theChainClass::ProcessWindowMessage(hWnd, uMsg, wParam, lParam, lResult, msgMapID)) \
			return TRUE; \
	}

#define CHAIN_MSG_MAP_ALT_MEMBER(theChainMember, msgMapID) \
	{ \
		if(theChainMember.ProcessWindowMessage(hWnd, uMsg, wParam, lParam, lResult, msgMapID)) \
			return TRUE; \
	}

#define CHAIN_MSG_MAP_DYNAMIC(dynaChainID) \
	{ \
		if(CDynamicChain::CallChain(dynaChainID, hWnd, uMsg, wParam, lParam, lResult)) \
			return TRUE; \
	}

#define END_MSG_MAP() \
			break; \
		default: \
			ATLTRACE(ATL::atlTraceWindowing, 0, _T("Invalid message map ID (%i)\n"), dwMsgMapID); \
			ATLASSERT(FALSE); \
			break; \
		} \
		return FALSE; \
	}


// Handler prototypes:
//  LRESULT MessageHandler(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
//  LRESULT CommandHandler(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
//  LRESULT NotifyHandler(int idCtrl, LPNMHDR pnmh, BOOL& bHandled);


// Empty message map macro

#define DECLARE_EMPTY_MSG_MAP() \
public: \
	BOOL ProcessWindowMessage(_In_ HWND, _In_ UINT, _In_ WPARAM, _In_ LPARAM, _Inout_ LRESULT&, _In_ DWORD = 0) \
	{ \
		return FALSE; \
	}

// Message forwarding and reflection macros

#define FORWARD_NOTIFICATIONS() \
	{ \
		bHandled = TRUE; \
		lResult = ForwardNotifications(uMsg, wParam, lParam, bHandled); \
		if(bHandled) \
			return TRUE; \
	}

#define REFLECT_NOTIFICATIONS() \
	{ \
		bHandled = TRUE; \
		lResult = ReflectNotifications(uMsg, wParam, lParam, bHandled); \
		if(bHandled) \
			return TRUE; \
	}

#define DEFAULT_REFLECTION_HANDLER() \
	if(DefaultReflectionHandler(hWnd, uMsg, wParam, lParam, lResult)) \
		return TRUE;

#define REFLECTED_COMMAND_HANDLER(id, code, func) \
	if(uMsg == OCM_COMMAND && id == LOWORD(wParam) && code == HIWORD(wParam)) \
	{ \
		bHandled = TRUE; \
		lResult = func(HIWORD(wParam), LOWORD(wParam), (HWND)lParam, bHandled); \
		if(bHandled) \
			return TRUE; \
	}

#define REFLECTED_COMMAND_ID_HANDLER(id, func) \
	if(uMsg == OCM_COMMAND && id == LOWORD(wParam)) \
	{ \
		bHandled = TRUE; \
		lResult = func(HIWORD(wParam), LOWORD(wParam), (HWND)lParam, bHandled); \
		if(bHandled) \
			return TRUE; \
	}

#define REFLECTED_COMMAND_CODE_HANDLER(code, func) \
	if(uMsg == OCM_COMMAND && code == HIWORD(wParam)) \
	{ \
		bHandled = TRUE; \
		lResult = func(HIWORD(wParam), LOWORD(wParam), (HWND)lParam, bHandled); \
		if(bHandled) \
			return TRUE; \
	}

#define REFLECTED_COMMAND_RANGE_HANDLER(idFirst, idLast, func) \
	if(uMsg == OCM_COMMAND && LOWORD(wParam) >= idFirst  && LOWORD(wParam) <= idLast) \
	{ \
		bHandled = TRUE; \
		lResult = func(HIWORD(wParam), LOWORD(wParam), (HWND)lParam, bHandled); \
		if(bHandled) \
			return TRUE; \
	}

#define REFLECTED_COMMAND_RANGE_CODE_HANDLER(idFirst, idLast, code, func) \
	if(uMsg == OCM_COMMAND && code == HIWORD(wParam) && LOWORD(wParam) >= idFirst  && LOWORD(wParam) <= idLast) \
	{ \
		bHandled = TRUE; \
		lResult = func(HIWORD(wParam), LOWORD(wParam), (HWND)lParam, bHandled); \
		if(bHandled) \
			return TRUE; \
	}

#define REFLECTED_NOTIFY_HANDLER(id, cd, func) \
	if(uMsg == OCM_NOTIFY && id == ((LPNMHDR)lParam)->idFrom && cd == ((LPNMHDR)lParam)->code) \
	{ \
		bHandled = TRUE; \
		lResult = func((int)wParam, (LPNMHDR)lParam, bHandled); \
		if(bHandled) \
			return TRUE; \
	}

#define REFLECTED_NOTIFY_ID_HANDLER(id, func) \
	if(uMsg == OCM_NOTIFY && id == ((LPNMHDR)lParam)->idFrom) \
	{ \
		bHandled = TRUE; \
		lResult = func((int)wParam, (LPNMHDR)lParam, bHandled); \
		if(bHandled) \
			return TRUE; \
	}

#define REFLECTED_NOTIFY_CODE_HANDLER(cd, func) \
	if(uMsg == OCM_NOTIFY && cd == ((LPNMHDR)lParam)->code) \
	{ \
		bHandled = TRUE; \
		lResult = func((int)wParam, (LPNMHDR)lParam, bHandled); \
		if(bHandled) \
			return TRUE; \
	}

#define REFLECTED_NOTIFY_RANGE_HANDLER(idFirst, idLast, func) \
	if(uMsg == OCM_NOTIFY && ((LPNMHDR)lParam)->idFrom >= idFirst && ((LPNMHDR)lParam)->idFrom <= idLast) \
	{ \
		bHandled = TRUE; \
		lResult = func((int)wParam, (LPNMHDR)lParam, bHandled); \
		if(bHandled) \
			return TRUE; \
	}

#define REFLECTED_NOTIFY_RANGE_CODE_HANDLER(idFirst, idLast, cd, func) \
	if(uMsg == OCM_NOTIFY && cd == ((LPNMHDR)lParam)->code && ((LPNMHDR)lParam)->idFrom >= idFirst && ((LPNMHDR)lParam)->idFrom <= idLast) \
	{ \
		bHandled = TRUE; \
		lResult = func((int)wParam, (LPNMHDR)lParam, bHandled); \
		if(bHandled) \
			return TRUE; \
	}

/////////////////////////////////////////////////////////////////////////////
// CDynamicChain - provides support for dynamic chaining

class CDynamicChain
{
public:
	struct ATL_CHAIN_ENTRY
	{
		DWORD m_dwChainID;
		CMessageMap* m_pObject;
		DWORD m_dwMsgMapID;
	};

	CSimpleArray<ATL_CHAIN_ENTRY*> m_aChainEntry;

	CDynamicChain()
	{
	}

	~CDynamicChain()
	{
		for(int i = 0; i < m_aChainEntry.GetSize(); i++)
		{
			if(m_aChainEntry[i] != NULL)
				delete m_aChainEntry[i];
		}
	}

	BOOL SetChainEntry(
		_In_ DWORD dwChainID,
		_In_ CMessageMap* pObject,
		_In_ DWORD dwMsgMapID = 0)
	{
	// first search for an existing entry

		int i;
		for(i = 0; i < m_aChainEntry.GetSize(); i++)
		{
			if(m_aChainEntry[i] != NULL && m_aChainEntry[i]->m_dwChainID == dwChainID)
			{
				m_aChainEntry[i]->m_pObject = pObject;
				m_aChainEntry[i]->m_dwMsgMapID = dwMsgMapID;
				return TRUE;
			}
		}

	// create a new one

		ATL_CHAIN_ENTRY* pEntry = NULL;
		ATLTRY(pEntry = new ATL_CHAIN_ENTRY);

		if(pEntry == NULL)
			return FALSE;

		pEntry->m_dwChainID = dwChainID;
		pEntry->m_pObject = pObject;
		pEntry->m_dwMsgMapID = dwMsgMapID;

	// search for an empty one

		for(i = 0; i < m_aChainEntry.GetSize(); i++)
		{
			if(m_aChainEntry[i] == NULL)
			{
				m_aChainEntry[i] = pEntry;
				return TRUE;
			}
		}

	// add a new one

		BOOL bRet = m_aChainEntry.Add(pEntry);

		if(!bRet)
		{
			delete pEntry;
			return FALSE;
		}

		return TRUE;
	}

	BOOL RemoveChainEntry(_In_ DWORD dwChainID)
	{
		for(int i = 0; i < m_aChainEntry.GetSize(); i++)
		{
			if(m_aChainEntry[i] != NULL && m_aChainEntry[i]->m_dwChainID == dwChainID)
			{
				delete m_aChainEntry[i];
				m_aChainEntry[i] = NULL;
				return TRUE;
			}
		}

		return FALSE;
	}

	BOOL CallChain(
		_In_ DWORD dwChainID,
		_In_ HWND hWnd,
		_In_ UINT uMsg,
		_In_ WPARAM wParam,
		_In_ LPARAM lParam,
		_Inout_ LRESULT& lResult)
	{
		for(int i = 0; i < m_aChainEntry.GetSize(); i++)
		{
			if(m_aChainEntry[i] != NULL && m_aChainEntry[i]->m_dwChainID == dwChainID)
				return (m_aChainEntry[i]->m_pObject)->ProcessWindowMessage(hWnd, uMsg, wParam, lParam, lResult, m_aChainEntry[i]->m_dwMsgMapID);
		}

		return FALSE;
	}
};

/////////////////////////////////////////////////////////////////////////////
// CWndClassInfo - Manages Windows class information

#define DECLARE_WND_CLASS(WndClassName) \
static ATL::CWndClassInfo& GetWndClassInfo() \
{ \
	static ATL::CWndClassInfo wc = \
	{ \
		{ sizeof(WNDCLASSEX), CS_HREDRAW | CS_VREDRAW | CS_DBLCLKS, StartWindowProc, \
		  0, 0, NULL, NULL, NULL, (HBRUSH)(COLOR_WINDOW + 1), NULL, WndClassName, NULL }, \
		NULL, NULL, IDC_ARROW, TRUE, 0, _T("") \
	}; \
	return wc; \
}

#define DECLARE_WND_CLASS_EX(WndClassName, style, bkgnd) \
static ATL::CWndClassInfo& GetWndClassInfo() \
{ \
	static ATL::CWndClassInfo wc = \
	{ \
		{ sizeof(WNDCLASSEX), style, StartWindowProc, \
		  0, 0, NULL, NULL, NULL, (HBRUSH)(bkgnd + 1), NULL, WndClassName, NULL }, \
		NULL, NULL, IDC_ARROW, TRUE, 0, _T("") \
	}; \
	return wc; \
}

#define DECLARE_WND_SUPERCLASS(WndClassName, OrigWndClassName) \
static ATL::CWndClassInfo& GetWndClassInfo() \
{ \
	static ATL::CWndClassInfo wc = \
	{ \
		{ sizeof(WNDCLASSEX), 0, StartWindowProc, \
		  0, 0, NULL, NULL, NULL, NULL, NULL, WndClassName, NULL }, \
		OrigWndClassName, NULL, NULL, TRUE, 0, _T("") \
	}; \
	return wc; \
}

/////////////////////////////////////////////////////////////////////////////
// CWinTraits - Defines various default values for a window

template <DWORD t_dwStyle = 0, DWORD t_dwExStyle = 0>
class CWinTraits
{
public:
	static DWORD GetWndStyle(_In_ DWORD dwStyle)
	{
		return dwStyle == 0 ? t_dwStyle : dwStyle;
	}
	static DWORD GetWndExStyle(_In_ DWORD dwExStyle)
	{
		return dwExStyle == 0 ? t_dwExStyle : dwExStyle;
	}
};

typedef CWinTraits<WS_CHILD | WS_VISIBLE | WS_CLIPCHILDREN | WS_CLIPSIBLINGS, 0>					CControlWinTraits;
typedef CWinTraits<WS_OVERLAPPEDWINDOW | WS_CLIPCHILDREN | WS_CLIPSIBLINGS, WS_EX_APPWINDOW | WS_EX_WINDOWEDGE>		CFrameWinTraits;
typedef CWinTraits<WS_OVERLAPPEDWINDOW | WS_CHILD | WS_VISIBLE | WS_CLIPCHILDREN | WS_CLIPSIBLINGS, WS_EX_MDICHILD>	CMDIChildWinTraits;

typedef CWinTraits<0, 0> CNullTraits;

template <DWORD t_dwStyle = 0, DWORD t_dwExStyle = 0, class TWinTraits = CControlWinTraits>
class CWinTraitsOR
{
public:
	static DWORD GetWndStyle(_In_ DWORD dwStyle)
	{
		return dwStyle | t_dwStyle | TWinTraits::GetWndStyle(dwStyle);
	}
	static DWORD GetWndExStyle(_In_ DWORD dwExStyle)
	{
		return dwExStyle | t_dwExStyle | TWinTraits::GetWndExStyle(dwExStyle);
	}
};

/////////////////////////////////////////////////////////////////////////////
// CWindowImpl - Implements a window

template <class TBase /* = CWindow */>
class ATL_NO_VTABLE CWindowImplRoot : 
	public TBase, 
	public CMessageMap
{
public:
	CWndProcThunk m_thunk;
	const _ATL_MSG* m_pCurrentMsg;
	DWORD m_dwState;

	enum { WINSTATE_DESTROYED = 0x00000001 };

// Constructor/destructor
	CWindowImplRoot() : m_pCurrentMsg(NULL), m_dwState(0)
	{
	}

	virtual ~CWindowImplRoot()
	{
#ifdef _DEBUG
		if(m_hWnd != NULL)	// should be cleared in WindowProc
		{
			ATLTRACE(atlTraceWindowing, 0, _T("ERROR - Object deleted before window was destroyed\n"));
			ATLASSERT(FALSE);
		}
#endif //_DEBUG
	}

// Current message
	const _ATL_MSG* GetCurrentMessage() const
	{
		return m_pCurrentMsg;
	}

	// "handled" management for cracked handlers
	BOOL IsMsgHandled() const
	{
		const _ATL_MSG* pMsg = GetCurrentMessage();
		ATLASSUME(pMsg != NULL);
		ATLASSERT(pMsg->cbSize >= sizeof(_ATL_MSG));
		return pMsg->bHandled;
	}
	void SetMsgHandled(_In_ BOOL bHandled)
	{
		_ATL_MSG* pMsg = (_ATL_MSG*)GetCurrentMessage();	// override const
		ATLASSUME(pMsg != NULL);
		ATLASSERT(pMsg->cbSize >= sizeof(_ATL_MSG));
		pMsg->bHandled = bHandled;
	}

// Message forwarding and reflection support
	LRESULT ForwardNotifications(
		_In_ UINT uMsg,
		_In_ WPARAM wParam,
		_In_ LPARAM lParam,
		_Out_ BOOL& bHandled);
	LRESULT ReflectNotifications(
		_In_ UINT uMsg,
		_In_ WPARAM wParam,
		_In_ LPARAM lParam,
		_Out_ BOOL& bHandled);
	static BOOL DefaultReflectionHandler(
		_In_ HWND hWnd,
		_In_ UINT uMsg,
		_In_ WPARAM wParam,
		_In_ LPARAM lParam,
		_Out_ LRESULT& lResult);
};

template <class TBase>
LRESULT CWindowImplRoot< TBase >::ForwardNotifications(
	_In_ UINT uMsg,
	_In_ WPARAM wParam,
	_In_ LPARAM lParam,
	_Out_ BOOL& bHandled)
{
	LRESULT lResult = 0;
	switch(uMsg)
	{
	case WM_COMMAND:
	case WM_NOTIFY:
	case WM_PARENTNOTIFY:
	case WM_DRAWITEM:
	case WM_MEASUREITEM:
	case WM_COMPAREITEM:
	case WM_DELETEITEM:
	case WM_VKEYTOITEM:
	case WM_CHARTOITEM:
	case WM_HSCROLL:
	case WM_VSCROLL:
	case WM_CTLCOLORBTN:
	case WM_CTLCOLORDLG:
	case WM_CTLCOLOREDIT:
	case WM_CTLCOLORLISTBOX:
	case WM_CTLCOLORMSGBOX:
	case WM_CTLCOLORSCROLLBAR:
	case WM_CTLCOLORSTATIC:
		lResult = GetParent().SendMessage(uMsg, wParam, lParam);
		break;
	default:
		bHandled = FALSE;
		break;
	}
	return lResult;
}

template <class TBase>
LRESULT CWindowImplRoot< TBase >::ReflectNotifications(
	_In_ UINT uMsg,
	_In_ WPARAM wParam,
	_In_ LPARAM lParam,
	_Out_ BOOL& bHandled)
{
	HWND hWndChild = NULL;

	switch(uMsg)
	{
	case WM_COMMAND:
		if(lParam != NULL)	// not from a menu
			hWndChild = (HWND)lParam;
		break;
	case WM_NOTIFY:
		hWndChild = ((LPNMHDR)lParam)->hwndFrom;
		break;
	case WM_PARENTNOTIFY:
		switch(LOWORD(wParam))
		{
		case WM_CREATE:
		case WM_DESTROY:
			hWndChild = (HWND)lParam;
			break;
		default:
			hWndChild = GetDlgItem(HIWORD(wParam));
			break;
		}
		break;
	case WM_DRAWITEM:
		if(wParam)	// not from a menu
			hWndChild = ((LPDRAWITEMSTRUCT)lParam)->hwndItem;
		break;
	case WM_MEASUREITEM:
		if(wParam)	// not from a menu
			hWndChild = GetDlgItem(((LPMEASUREITEMSTRUCT)lParam)->CtlID);
		break;
	case WM_COMPAREITEM:
		if(wParam)	// not from a menu
			hWndChild =  ((LPCOMPAREITEMSTRUCT)lParam)->hwndItem;
		break;
	case WM_DELETEITEM:
		if(wParam)	// not from a menu
			hWndChild =  ((LPDELETEITEMSTRUCT)lParam)->hwndItem;

		break;
	case WM_VKEYTOITEM:
	case WM_CHARTOITEM:
	case WM_HSCROLL:
	case WM_VSCROLL:
		hWndChild = (HWND)lParam;
		break;
	case WM_CTLCOLORBTN:
	case WM_CTLCOLORDLG:
	case WM_CTLCOLOREDIT:
	case WM_CTLCOLORLISTBOX:
	case WM_CTLCOLORMSGBOX:
	case WM_CTLCOLORSCROLLBAR:
	case WM_CTLCOLORSTATIC:
		hWndChild = (HWND)lParam;
		break;
	default:
		break;
	}

	if(hWndChild == NULL)
	{
		bHandled = FALSE;
		return 1;
	}

	ATLASSERT(::IsWindow(hWndChild));
	return ::SendMessage(hWndChild, OCM__BASE + uMsg, wParam, lParam);
}

template <class TBase>
BOOL CWindowImplRoot< TBase >::DefaultReflectionHandler(
	_In_ HWND hWnd,
	_In_ UINT uMsg,
	_In_ WPARAM wParam,
	_In_ LPARAM lParam,
	_Out_ LRESULT& lResult)
{
	switch(uMsg)
	{
	case OCM_COMMAND:
	case OCM_NOTIFY:
	case OCM_PARENTNOTIFY:
	case OCM_DRAWITEM:
	case OCM_MEASUREITEM:
	case OCM_COMPAREITEM:
	case OCM_DELETEITEM:
	case OCM_VKEYTOITEM:
	case OCM_CHARTOITEM:
	case OCM_HSCROLL:
	case OCM_VSCROLL:
	case OCM_CTLCOLORBTN:
	case OCM_CTLCOLORDLG:
	case OCM_CTLCOLOREDIT:
	case OCM_CTLCOLORLISTBOX:
	case OCM_CTLCOLORMSGBOX:
	case OCM_CTLCOLORSCROLLBAR:
	case OCM_CTLCOLORSTATIC:
		lResult = ::DefWindowProc(hWnd, uMsg - OCM__BASE, wParam, lParam);
		return TRUE;
	default:
		break;
	}
	return FALSE;
}

template <class TBase = CWindow, class TWinTraits = CControlWinTraits>
class ATL_NO_VTABLE CWindowImplBaseT : 
	public CWindowImplRoot< TBase >
{
public:
	WNDPROC m_pfnSuperWindowProc;

	CWindowImplBaseT() : m_pfnSuperWindowProc(::DefWindowProc)
	{
	}

	static DWORD GetWndStyle(_In_ DWORD dwStyle)
	{
		return TWinTraits::GetWndStyle(dwStyle);
	}
	static DWORD GetWndExStyle(_In_ DWORD dwExStyle)
	{
		return TWinTraits::GetWndExStyle(dwExStyle);
	}

	virtual WNDPROC GetWindowProc()
	{
		return WindowProc;
	}
	static LRESULT CALLBACK StartWindowProc(
		_In_ HWND hWnd,
		_In_ UINT uMsg,
		_In_ WPARAM wParam,
		_In_ LPARAM lParam);

	static LRESULT CALLBACK WindowProc(
		_In_ HWND hWnd,
		_In_ UINT uMsg,
		_In_ WPARAM wParam,
		_In_ LPARAM lParam);

	HWND Create(
		_In_opt_ HWND hWndParent,
		_In_ _U_RECT rect,
		_In_z_ LPCTSTR szWindowName,
		_In_ DWORD dwStyle,
		_In_ DWORD dwExStyle,
		_In_ _U_MENUorID MenuOrID,
		_In_ ATOM atom,
		_In_opt_ LPVOID lpCreateParam = NULL);

	BOOL DestroyWindow()
	{
#ifndef ATL_NO_ASSERT_ON_DESTROY_NONEXISTENT_WINDOW
		ATLASSERT(::IsWindow(m_hWnd));
#endif

		if (!::DestroyWindow(m_hWnd))
		{
			return FALSE;
		}

		return TRUE;
	}
	BOOL SubclassWindow(_In_ HWND hWnd);
	HWND UnsubclassWindow(_In_ BOOL bForce = FALSE);

	LRESULT DefWindowProc()
	{
		const _ATL_MSG* pMsg = m_pCurrentMsg;
		LRESULT lRes = 0;
		if (pMsg != NULL)
			lRes = DefWindowProc(pMsg->message, pMsg->wParam, pMsg->lParam);
		return lRes;
	}

	LRESULT DefWindowProc(
		_In_ UINT uMsg,
		_In_ WPARAM wParam,
		_In_ LPARAM lParam)
	{
#ifdef STRICT
		return ::CallWindowProc(m_pfnSuperWindowProc, m_hWnd, uMsg, wParam, lParam);
#else
		return ::CallWindowProc((FARPROC)m_pfnSuperWindowProc, m_hWnd, uMsg, wParam, lParam);
#endif
	}

	virtual void OnFinalMessage(_In_ HWND /*hWnd*/)
	{
		// override to do something, if needed
	}
};

typedef CWindowImplBaseT<CWindow>	CWindowImplBase;

template <class TBase, class TWinTraits>
LRESULT CALLBACK CWindowImplBaseT< TBase, TWinTraits >::StartWindowProc(
	_In_ HWND hWnd,
	_In_ UINT uMsg,
	_In_ WPARAM wParam,
	_In_ LPARAM lParam)
{
	CWindowImplBaseT< TBase, TWinTraits >* pThis = (CWindowImplBaseT< TBase, TWinTraits >*)_AtlWinModule.ExtractCreateWndData();
	ATLASSERT(pThis != NULL);
	if(!pThis)
	{
		return 0;
	}
	pThis->m_hWnd = hWnd;

	// Initialize the thunk.  This is allocated in CWindowImplBaseT::Create,
	// so failure is unexpected here.

	pThis->m_thunk.Init(pThis->GetWindowProc(), pThis);
	WNDPROC pProc = pThis->m_thunk.GetWNDPROC();
	WNDPROC pOldProc = (WNDPROC)::SetWindowLongPtr(hWnd, GWLP_WNDPROC, (LONG_PTR)pProc);
#ifdef _DEBUG
	// check if somebody has subclassed us already since we discard it
	if(pOldProc != StartWindowProc)
		ATLTRACE(atlTraceWindowing, 0, _T("Subclassing through a hook discarded.\n"));
#else
	(pOldProc);	// avoid unused warning
#endif
	return pProc(hWnd, uMsg, wParam, lParam);
}

template <class TBase, class TWinTraits>
LRESULT CALLBACK CWindowImplBaseT< TBase, TWinTraits >::WindowProc(
	_In_ HWND hWnd,
	_In_ UINT uMsg,
	_In_ WPARAM wParam,
	_In_ LPARAM lParam)
{
	CWindowImplBaseT< TBase, TWinTraits >* pThis = (CWindowImplBaseT< TBase, TWinTraits >*)hWnd;
	// set a ptr to this message and save the old value
	_ATL_MSG msg(pThis->m_hWnd, uMsg, wParam, lParam);
	const _ATL_MSG* pOldMsg = pThis->m_pCurrentMsg;
	pThis->m_pCurrentMsg = &msg;
	// pass to the message map to process
	LRESULT lRes = 0;
	BOOL bRet = pThis->ProcessWindowMessage(pThis->m_hWnd, uMsg, wParam, lParam, lRes, 0);
	// restore saved value for the current message
	ATLASSERT(pThis->m_pCurrentMsg == &msg);

	// do the default processing if message was not handled
	if(!bRet)
	{
		if(uMsg != WM_NCDESTROY)
			lRes = pThis->DefWindowProc(uMsg, wParam, lParam);
		else
		{
			// unsubclass, if needed
			LONG_PTR pfnWndProc = ::GetWindowLongPtr(pThis->m_hWnd, GWLP_WNDPROC);
			lRes = pThis->DefWindowProc(uMsg, wParam, lParam);
			if(pThis->m_pfnSuperWindowProc != ::DefWindowProc && ::GetWindowLongPtr(pThis->m_hWnd, GWLP_WNDPROC) == pfnWndProc)
				::SetWindowLongPtr(pThis->m_hWnd, GWLP_WNDPROC, (LONG_PTR)pThis->m_pfnSuperWindowProc);
			// mark window as destryed
			pThis->m_dwState |= WINSTATE_DESTROYED;
		}
	}
	if((pThis->m_dwState & WINSTATE_DESTROYED) && pOldMsg== NULL)
	{
		// clear out window handle
		HWND hWndThis = pThis->m_hWnd;
		pThis->m_hWnd = NULL;
		pThis->m_dwState &= ~WINSTATE_DESTROYED;
		// clean up after window is destroyed
		pThis->m_pCurrentMsg = pOldMsg;
		pThis->OnFinalMessage(hWndThis);
	}else {
		pThis->m_pCurrentMsg = pOldMsg;
	}
	return lRes;
}

template <class TBase, class TWinTraits>
HWND CWindowImplBaseT< TBase, TWinTraits >::Create(
	_In_opt_ HWND hWndParent,
	_In_ _U_RECT rect,
	_In_z_ LPCTSTR szWindowName,
	_In_ DWORD dwStyle,
	_In_ DWORD dwExStyle,
	_In_ _U_MENUorID MenuOrID,
	_In_ ATOM atom,
	_In_opt_ LPVOID lpCreateParam)
{
	ATLASSUME(m_hWnd == NULL);

	// Allocate the thunk structure here, where we can fail gracefully.
	BOOL result = m_thunk.Init(NULL,NULL);
	if (result == FALSE) {
		SetLastError(ERROR_OUTOFMEMORY);
		return NULL;
	}

	if(atom == 0)
		return NULL;

	_AtlWinModule.AddCreateWndData(&m_thunk.cd, this);

	if(MenuOrID.m_hMenu == NULL && (dwStyle & WS_CHILD))
		MenuOrID.m_hMenu = (HMENU)(UINT_PTR)this;
	if(rect.m_lpRect == NULL)
		rect.m_lpRect = &TBase::rcDefault;

	HWND hWnd = ::CreateWindowEx(dwExStyle, MAKEINTATOM(atom), szWindowName,
		dwStyle, rect.m_lpRect->left, rect.m_lpRect->top, rect.m_lpRect->right - rect.m_lpRect->left,
		rect.m_lpRect->bottom - rect.m_lpRect->top, hWndParent, MenuOrID.m_hMenu,
		_AtlBaseModule.GetModuleInstance(), lpCreateParam);

	ATLASSUME(m_hWnd == hWnd);

	return hWnd;
}

template <class TBase, class TWinTraits>
BOOL CWindowImplBaseT< TBase, TWinTraits >::SubclassWindow(_In_ HWND hWnd)
{
	ATLASSUME(m_hWnd == NULL);
	ATLASSERT(::IsWindow(hWnd));

	// Allocate the thunk structure here, where we can fail gracefully.

	BOOL result = m_thunk.Init(GetWindowProc(), this);
	if (result == FALSE)
	{
		return FALSE;
	}
	WNDPROC pProc = m_thunk.GetWNDPROC();
	WNDPROC pfnWndProc = (WNDPROC)::SetWindowLongPtr(hWnd, GWLP_WNDPROC, (LONG_PTR)pProc);
	if(pfnWndProc == NULL)
		return FALSE;
	m_pfnSuperWindowProc = pfnWndProc;
	m_hWnd = hWnd;
	return TRUE;
}

// Use only if you want to subclass before window is destroyed,
// WindowProc will automatically subclass when  window goes away
template <class TBase, class TWinTraits>
HWND CWindowImplBaseT< TBase, TWinTraits >::UnsubclassWindow(_In_ BOOL bForce /*= FALSE*/)
{
	ATLASSUME(m_hWnd != NULL);

	WNDPROC pOurProc = m_thunk.GetWNDPROC();
	WNDPROC pActiveProc = (WNDPROC)::GetWindowLongPtr(m_hWnd, GWLP_WNDPROC);

	HWND hWnd = NULL;
	if (bForce || pOurProc == pActiveProc)
	{
		if(!::SetWindowLongPtr(m_hWnd, GWLP_WNDPROC, (LONG_PTR)m_pfnSuperWindowProc))
			return NULL;

		m_pfnSuperWindowProc = ::DefWindowProc;
		hWnd = m_hWnd;
		m_hWnd = NULL;
	}
	return hWnd;
}

template <class T, class TBase /* = CWindow */, class TWinTraits /* = CControlWinTraits */>
class ATL_NO_VTABLE CWindowImpl :
	public CWindowImplBaseT< TBase, TWinTraits >
{
public:
	DECLARE_WND_CLASS(NULL)

	static LPCTSTR GetWndCaption()
	{
		return NULL;
	}

	HWND Create(
		_In_opt_ HWND hWndParent,
		_In_ _U_RECT rect = NULL,
		_In_opt_z_ LPCTSTR szWindowName = NULL,
		_In_ DWORD dwStyle = 0,
		_In_ DWORD dwExStyle = 0,
		_In_ _U_MENUorID MenuOrID = 0U,
		_In_opt_ LPVOID lpCreateParam = NULL)
	{
		if (T::GetWndClassInfo().m_lpszOrigName == NULL)
			T::GetWndClassInfo().m_lpszOrigName = GetWndClassName();
		ATOM atom = T::GetWndClassInfo().Register(&m_pfnSuperWindowProc);

		dwStyle = T::GetWndStyle(dwStyle);
		dwExStyle = T::GetWndExStyle(dwExStyle);

		// set caption
		if (szWindowName == NULL)
			szWindowName = T::GetWndCaption();

		return CWindowImplBaseT< TBase, TWinTraits >::Create(hWndParent, rect, szWindowName,
			dwStyle, dwExStyle, MenuOrID, atom, lpCreateParam);
	}
};

template <class T, class TBase /* = CWindow */, class TWinTraits /* = CControlWinTraits */>
class ATL_NO_VTABLE CWindowWithReflectorImpl :
	public CWindowImpl< T, TBase, TWinTraits >
{
public:
	HWND Create(
		_In_opt_ HWND hWndParent,
		_In_ _U_RECT rect = NULL,
		_In_opt_z_ LPCTSTR szWindowName = NULL,
		_In_ DWORD dwStyle = 0,
		_In_ DWORD dwExStyle = 0,
		_In_ _U_MENUorID MenuOrID = 0U,
		_In_opt_ LPVOID lpCreateParam = NULL)
	{
		m_wndReflector.Create(hWndParent, rect, NULL, WS_VISIBLE | WS_CHILD | WS_CLIPSIBLINGS | WS_CLIPCHILDREN, 0, Reflector::REFLECTOR_MAP_ID);
		RECT rcPos = { 0, 0, rect.m_lpRect->right, rect.m_lpRect->bottom };
		return CWindowImpl< T, TBase, TWinTraits >::Create(m_wndReflector, rcPos, szWindowName, dwStyle, dwExStyle, MenuOrID, lpCreateParam);
	}

// message map and handlers
	typedef CWindowWithReflectorImpl< T, TBase, TWinTraits >	thisClass;
	BEGIN_MSG_MAP(thisClass)
		MESSAGE_HANDLER(WM_NCDESTROY, OnNcDestroy)
		MESSAGE_HANDLER(WM_WINDOWPOSCHANGING, OnWindowPosChanging)
	END_MSG_MAP()

	LRESULT OnNcDestroy(
		_In_ UINT /*uMsg*/,
		_In_ WPARAM /*wParam*/,
		_In_ LPARAM /*lParam*/,
		_Out_ BOOL& bHandled)
	{
		m_wndReflector.DestroyWindow();
		bHandled = FALSE;
		return 1;
	}
	LRESULT OnWindowPosChanging(
		_In_ UINT uMsg,
		_In_ WPARAM wParam,
		_In_ LPARAM lParam,
		_Inout_ BOOL& /*bHandled*/)
	{
		WINDOWPOS* pWP = (WINDOWPOS*)lParam;
		m_wndReflector.SetWindowPos(m_wndReflector.GetParent(), pWP->x, pWP->y, pWP->cx, pWP->cy, pWP->flags);
		pWP->flags |= SWP_NOMOVE;
		pWP->x = 0;
		pWP->y = 0;
		return DefWindowProc(uMsg, wParam, lParam);
	}

	// reflector window stuff
	class Reflector :
		public CWindowImpl<Reflector>
	{
	public:
		enum { REFLECTOR_MAP_ID = 69 };
		DECLARE_WND_CLASS_EX(_T("ATLReflectorWindow"), 0, -1)
		BEGIN_MSG_MAP(Reflector)
			REFLECT_NOTIFICATIONS()
		END_MSG_MAP()
	} m_wndReflector;
};

/////////////////////////////////////////////////////////////////////////////
// CDialogImpl - Implements a dialog box

#define _ATL_RT_DLGINIT  MAKEINTRESOURCE(240)

template <class TBase /* = CWindow */>
class ATL_NO_VTABLE CDialogImplBaseT :
	public CWindowImplRoot< TBase >
{
public:
	virtual ~CDialogImplBaseT()
	{
	}
	virtual DLGPROC GetDialogProc()
	{
		return DialogProc;
	}
	static INT_PTR CALLBACK StartDialogProc(
		_In_ HWND hWnd,
		_In_ UINT uMsg,
		_In_ WPARAM wParam,
		_In_ LPARAM lParam);
	static INT_PTR CALLBACK DialogProc(
		_In_ HWND hWnd,
		_In_ UINT uMsg,
		_In_ WPARAM wParam,
		_In_ LPARAM lParam);

	BOOL MapDialogRect(_Inout_ LPRECT lpRect)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return ::MapDialogRect(m_hWnd, lpRect);
	}
	virtual void OnFinalMessage(_In_ HWND /*hWnd*/)
	{
		// override to do something, if needed
	}
	// has no meaning for a dialog, but needed for handlers that use it
	LRESULT DefWindowProc()
	{
		return 0;
	}
	// initialize combobox and comboboxex from RT_DLGINIT resource if any
	BOOL ExecuteDlgInit(_In_ int iDlgID)
	{
		BOOL bSuccess = TRUE;
		HINSTANCE hInst = _AtlBaseModule.GetResourceInstance();
		HRSRC hrsrc = ::FindResourceW(hInst, MAKEINTRESOURCEW(iDlgID), (LPWSTR)_ATL_RT_DLGINIT);
		if (hrsrc)
		{
			HGLOBAL hResData = ::LoadResource(hInst, hrsrc);
			if (hResData)
			{
				UNALIGNED WORD* pDlgInit = (UNALIGNED WORD*)::LockResource(hResData);
				if (pDlgInit)
				{
					while (bSuccess && NULL != *pDlgInit)
					{
						WORD wID = *pDlgInit++;
						WORD wMsg = *pDlgInit++;
						DWORD dwSize = *((UNALIGNED DWORD*&)pDlgInit)++;

						// CB_ADDSTRING is stored as 0x403
						if (0x403 == wMsg)
						{
							CA2T szText(reinterpret_cast<LPCSTR>(pDlgInit));
							if (-1 == SendDlgItemMessage(wID, CB_ADDSTRING, 0, reinterpret_cast<LPARAM>(static_cast<LPCTSTR>(szText))))
							{
								bSuccess = FALSE;
							}
						}
						// CBEM_INSERTITEM is stored as 0x1234
						else if (0x1234 == wMsg)
						{
							COMBOBOXEXITEM item;
							item.mask = CBEIF_TEXT;
							item.iItem = -1;
							item.pszText = CA2T(reinterpret_cast<LPSTR>(pDlgInit));
							if (-1 == SendDlgItemMessage(wID, CBEM_INSERTITEM, 0, (LPARAM)&item))
							{
								bSuccess = FALSE;
							}
						}
						pDlgInit = (LPWORD)((LPBYTE)pDlgInit + dwSize);
					}
				}
			}
		}
		return bSuccess;
	}
};

template <class TBase>
INT_PTR CALLBACK CDialogImplBaseT< TBase >::StartDialogProc(
	_In_ HWND hWnd,
	_In_ UINT uMsg,
	_In_ WPARAM wParam,
	_In_ LPARAM lParam)
{
	CDialogImplBaseT< TBase >* pThis = (CDialogImplBaseT< TBase >*)_AtlWinModule.ExtractCreateWndData();
	ATLASSERT(pThis != NULL);
	if(!pThis)
	{
		return 0;
	}
	pThis->m_hWnd = hWnd;
	// Initialize the thunk.  This was allocated in CDialogImpl::DoModal or
	// CDialogImpl::Create, so failure is unexpected here.

	pThis->m_thunk.Init((WNDPROC)pThis->GetDialogProc(), pThis);
	DLGPROC pProc = (DLGPROC)pThis->m_thunk.GetWNDPROC();
	DLGPROC pOldProc = (DLGPROC)::SetWindowLongPtr(hWnd, DWLP_DLGPROC, (LONG_PTR)pProc);
#ifdef _DEBUG
	// check if somebody has subclassed us already since we discard it
	if(pOldProc != StartDialogProc)
		ATLTRACE(atlTraceWindowing, 0, _T("Subclassing through a hook discarded.\n"));
#else
	DBG_UNREFERENCED_LOCAL_VARIABLE(pOldProc);	// avoid unused warning
#endif
	return pProc(hWnd, uMsg, wParam, lParam);
}

template <class TBase>
INT_PTR CALLBACK CDialogImplBaseT< TBase >::DialogProc(
	_In_ HWND hWnd,
	_In_ UINT uMsg,
	_In_ WPARAM wParam,
	_In_ LPARAM lParam)
{
	CDialogImplBaseT< TBase >* pThis = (CDialogImplBaseT< TBase >*)hWnd;
	// set a ptr to this message and save the old value
	_ATL_MSG msg(pThis->m_hWnd, uMsg, wParam, lParam);
	const _ATL_MSG* pOldMsg = pThis->m_pCurrentMsg;
	pThis->m_pCurrentMsg = &msg;
	// pass to the message map to process
	LRESULT lRes = 0;
	BOOL bRet = pThis->ProcessWindowMessage(pThis->m_hWnd, uMsg, wParam, lParam, lRes, 0);
	// restore saved value for the current message
	ATLASSERT(pThis->m_pCurrentMsg == &msg);
	pThis->m_pCurrentMsg = pOldMsg;
	// set result if message was handled
	if(bRet)
	{
		switch (uMsg)
		{
		case WM_COMPAREITEM:
		case WM_VKEYTOITEM:
		case WM_CHARTOITEM:
		case WM_INITDIALOG:
		case WM_QUERYDRAGICON:
		case WM_CTLCOLORMSGBOX:
		case WM_CTLCOLOREDIT:
		case WM_CTLCOLORLISTBOX:
		case WM_CTLCOLORBTN:
		case WM_CTLCOLORDLG:
		case WM_CTLCOLORSCROLLBAR:
		case WM_CTLCOLORSTATIC:
			// return directly
			bRet = (BOOL)lRes;
			break;
		default:
			// return in DWL_MSGRESULT
			//Make sure the window was not destroyed before setting attributes.
			if((pThis->m_dwState & WINSTATE_DESTROYED) == 0)
			{
				::SetWindowLongPtr(pThis->m_hWnd, DWLP_MSGRESULT, lRes);
			}
			break;
		}
	}
	else if(uMsg == WM_NCDESTROY)
	{
		// mark dialog as destryed
		pThis->m_dwState |= WINSTATE_DESTROYED;
	}

	if((pThis->m_dwState & WINSTATE_DESTROYED) && pThis->m_pCurrentMsg == NULL)
	{
		// clear out window handle
		HWND hWndThis = pThis->m_hWnd;
		pThis->m_hWnd = NULL;
		pThis->m_dwState &= ~WINSTATE_DESTROYED;
		// clean up after dialog is destroyed
		pThis->OnFinalMessage(hWndThis);
	}
	return bRet;
}

typedef CDialogImplBaseT<CWindow>	CDialogImplBase;

template <class T, class TBase /* = CWindow */>
class ATL_NO_VTABLE CDialogImpl :
	public CDialogImplBaseT< TBase >
{
public:
#ifdef _DEBUG
	bool m_bModal;
	CDialogImpl() : m_bModal(false)
	{
	}
#endif //_DEBUG
	// modal dialogs
	INT_PTR DoModal(
		_In_ HWND hWndParent = ::GetActiveWindow(),
		_In_ LPARAM dwInitParam = NULL)
	{
		BOOL result;

		ATLASSUME(m_hWnd == NULL);

		// Allocate the thunk structure here, where we can fail
		// gracefully.

		result = m_thunk.Init(NULL,NULL);
		if (result == FALSE)
		{
			SetLastError(ERROR_OUTOFMEMORY);
			return -1;
		}

		_AtlWinModule.AddCreateWndData(&m_thunk.cd, (CDialogImplBaseT< TBase >*)this);
#ifdef _DEBUG
		m_bModal = true;
#endif //_DEBUG
		return ::DialogBoxParam(_AtlBaseModule.GetResourceInstance(), MAKEINTRESOURCE(static_cast<T*>(this)->IDD),
					hWndParent, T::StartDialogProc, dwInitParam);
	}
	BOOL EndDialog(_In_ int nRetCode)
	{
		ATLASSERT(::IsWindow(m_hWnd));
#ifdef _DEBUG
		ATLASSUME(m_bModal);	// must be a modal dialog
#endif //_DEBUG
		return ::EndDialog(m_hWnd, nRetCode);
	}
	// modeless dialogs
	HWND Create(
		_In_ HWND hWndParent,
		_In_ LPARAM dwInitParam = NULL)
	{
		BOOL result;

		ATLASSUME(m_hWnd == NULL);

		// Allocate the thunk structure here, where we can fail
		// gracefully.

		result = m_thunk.Init(NULL,NULL);
		if (result == FALSE)
		{
			SetLastError(ERROR_OUTOFMEMORY);
			return NULL;
		}

		_AtlWinModule.AddCreateWndData(&m_thunk.cd, (CDialogImplBaseT< TBase >*)this);
#ifdef _DEBUG
		m_bModal = false;
#endif //_DEBUG
		HWND hWnd = ::CreateDialogParam(_AtlBaseModule.GetResourceInstance(), MAKEINTRESOURCE(static_cast<T*>(this)->IDD),
					hWndParent, T::StartDialogProc, dwInitParam);
		ATLASSUME(m_hWnd == hWnd);
		return hWnd;
	}
	// for CComControl
	HWND Create(
		_In_ HWND hWndParent,
		_In_ RECT&,
		_In_ LPARAM dwInitParam = NULL)
	{
		return Create(hWndParent, dwInitParam);
	}
	BOOL DestroyWindow()
	{
		ATLASSERT(::IsWindow(m_hWnd));
#ifdef _DEBUG
		ATLASSERT(!m_bModal);	// must not be a modal dialog
#endif //_DEBUG

		if (!::DestroyWindow(m_hWnd))
		{
			return FALSE;
		}

		return TRUE;
	}
};

/////////////////////////////////////////////////////////////////////////////
// CAxDialogImpl - Implements a dialog box that hosts ActiveX controls

#ifndef _ATL_NO_HOSTING


template <class T, class TBase /* = CWindow */>
class ATL_NO_VTABLE CAxDialogImpl :
	public CDialogImplBaseT< TBase >
{
protected:
	bool m_bModal;
	HRESULT m_hrError;
public:
	CAxDialogImpl() : m_bModal(false), m_hrError(S_OK)
	{
	}

	int GetIDD()
	{
		return( static_cast<T*>(this)->IDD );
	}
	virtual DLGPROC GetDialogProc()
	{
		return DialogProc;
	}
	static INT_PTR CALLBACK DialogProc(
		_In_ HWND hWnd,
		_In_ UINT uMsg,
		_In_ WPARAM wParam,
		_In_ LPARAM lParam);
	// modal dialogs
	INT_PTR DoModal(
		_In_ HWND hWndParent = ::GetActiveWindow(),
		_In_ LPARAM dwInitParam = NULL)
	{
		ATLASSUME(m_hWnd == NULL);
		_AtlWinModule.AddCreateWndData(&m_thunk.cd, static_cast< CDialogImplBaseT< TBase >* >(this));

		m_bModal = true;
		m_hrError = S_OK;

		INT_PTR iRes = AtlAxDialogBox(_AtlBaseModule.GetResourceInstance(), MAKEINTRESOURCE(static_cast<T*>(this)->IDD),
							hWndParent, T::StartDialogProc, dwInitParam);

		if (FAILED(m_hrError) && -1 == iRes)
		{
			::SetLastError(m_hrError);
		}

		return iRes;
	}
	BOOL EndDialog(_In_ int nRetCode)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		ATLASSUME(m_bModal);	// must be a modal dialog

		return ::EndDialog(m_hWnd, nRetCode);
	}
	// modeless dialogs
	HWND Create(
		_In_ HWND hWndParent,
		_In_ LPARAM dwInitParam = NULL)
	{
		ATLASSUME(m_hWnd == NULL);
		_AtlWinModule.AddCreateWndData(&m_thunk.cd, static_cast< CDialogImplBaseT< TBase >* >(this));

		m_bModal = false;
		m_hrError = S_OK;

		HWND hWnd = AtlAxCreateDialog(_AtlBaseModule.GetResourceInstance(), MAKEINTRESOURCE(static_cast<T*>(this)->IDD),
					hWndParent, T::StartDialogProc, dwInitParam);

		if (FAILED(m_hrError) && hWnd != NULL)
		{
			DestroyWindow();
			::SetLastError(m_hrError);
			hWnd = NULL;
		}

		ATLASSUME(m_hWnd == hWnd);
		return hWnd;
	}
	// for CComControl
	HWND Create(
		_In_ HWND hWndParent,
		_In_ RECT&,
		_In_ LPARAM dwInitParam = NULL)
	{
		return Create(hWndParent, dwInitParam);
	}
	BOOL DestroyWindow()
	{
		ATLASSERT(::IsWindow(m_hWnd));
		ATLASSERT(!m_bModal);	// must not be a modal dialog

		if (!::DestroyWindow(m_hWnd))
		{
			return FALSE;
		}
		return TRUE;
	}

// Event handling support and Message map
	HRESULT AdviseSinkMap(_In_ bool bAdvise)
	{
		if(!bAdvise && m_hWnd == NULL)
		{
			// window is gone, controls are already unadvised
			ATLTRACE(atlTraceControls, 1, _T("CAxDialogImpl::AdviseSinkMap called after the window was destroyed\n"));
			return S_OK;
		}
		HRESULT hRet = E_NOTIMPL;
		__if_exists(T::_GetSinkMapFinder)
		{
			T* pT = static_cast<T*>(this);
			hRet = AtlAdviseSinkMap(pT, bAdvise);
		}
		return hRet;
	}

	typedef CAxDialogImpl< T, TBase >	thisClass;
	BEGIN_MSG_MAP(thisClass)
		MESSAGE_HANDLER(WM_INITDIALOG, OnInitDialog)
		MESSAGE_HANDLER(WM_DESTROY, OnDestroy)
	END_MSG_MAP()

	virtual HRESULT CreateActiveXControls(_In_ UINT nID)
	{
		// Load dialog template and InitData
		HRSRC hDlgInit = ::FindResourceW(_AtlBaseModule.GetResourceInstance(), MAKEINTRESOURCEW(nID), (LPWSTR)_ATL_RT_DLGINIT);
		BYTE* pInitData = NULL;
		HGLOBAL hData = NULL;
		HRESULT hr = S_OK;
		if (hDlgInit != NULL)
		{
			hData = ::LoadResource(_AtlBaseModule.GetResourceInstance(), hDlgInit);
			if (hData != NULL)
				pInitData = (BYTE*) ::LockResource(hData);
		}

		HRSRC hDlg = ::FindResourceW(_AtlBaseModule.GetResourceInstance(), MAKEINTRESOURCEW(nID), (LPWSTR)RT_DIALOG);
		if (hDlg != NULL)
		{
			HGLOBAL hResource = ::LoadResource(_AtlBaseModule.GetResourceInstance(), hDlg);
			DLGTEMPLATE* pDlg = NULL;
			if (hResource != NULL)
			{
				pDlg = (DLGTEMPLATE*) ::LockResource(hResource);
				if (pDlg != NULL)
				{
					// Get first control on the template
					BOOL bDialogEx = _DialogSplitHelper::IsDialogEx(pDlg);
					WORD nItems = _DialogSplitHelper::DlgTemplateItemCount(pDlg);

					// Get first control on the dialog
					DLGITEMTEMPLATE* pItem = _DialogSplitHelper::FindFirstDlgItem(pDlg);
					HWND hWndPrev = GetWindow(GW_CHILD);

					// Create all ActiveX cotnrols in the dialog template and place them in the correct tab order (z-order)
					for (WORD nItem = 0; nItem < nItems; nItem++)
					{
						DWORD wID = bDialogEx ? ((_DialogSplitHelper::DLGITEMTEMPLATEEX*)pItem)->id : pItem->id;
						if (_DialogSplitHelper::IsActiveXControl(pItem, bDialogEx))
						{
							BYTE* pData = NULL;
							DWORD dwLen = _DialogSplitHelper::FindCreateData(wID, pInitData, &pData);
							CComPtr<IStream> spStream;
							if (dwLen != 0)
							{
								HGLOBAL h = GlobalAlloc(GHND, dwLen);
								if (h != NULL)
								{
									BYTE* pBytes = SAL_Assume_bytecap_for_opt_((BYTE*) GlobalLock(h), dwLen);
									if (pBytes == NULL)
									{
										hr = AtlHresultFromLastError();
										break;
									}									
									BYTE* pSource = SAL_Assume_bytecap_for_opt_(pData, dwLen);									
									ATLASSUME(pSource != NULL);
									Checked::memcpy_s(pBytes, dwLen, pSource, dwLen);
									GlobalUnlock(h);
									CreateStreamOnHGlobal(h, TRUE, &spStream);
								}
								else
								{
									hr = E_OUTOFMEMORY;
									break;
								}
							}

							CComBSTR bstrLicKey;
							hr = _DialogSplitHelper::ParseInitData(spStream, &bstrLicKey.m_str);
							if (SUCCEEDED(hr))
							{
								CAxWindow2 wnd;
								// Get control caption.
								LPWSTR pszClassName =
									bDialogEx ?
										(LPWSTR)(((_DialogSplitHelper::DLGITEMTEMPLATEEX*)pItem) + 1) :
										(LPWSTR)(pItem + 1);
								// Get control rect.
								RECT rect;
								rect.left =
									bDialogEx ?
										((_DialogSplitHelper::DLGITEMTEMPLATEEX*)pItem)->x :
										pItem->x;
								rect.top =
									bDialogEx ?
										((_DialogSplitHelper::DLGITEMTEMPLATEEX*)pItem)->y :
										pItem->y;
								rect.right = rect.left +
									(bDialogEx ?
										((_DialogSplitHelper::DLGITEMTEMPLATEEX*)pItem)->cx :
										pItem->cx);
								rect.bottom = rect.top +
									(bDialogEx ?
										((_DialogSplitHelper::DLGITEMTEMPLATEEX*)pItem)->cy :
										pItem->cy);

								// Convert from dialog units to screen units
								MapDialogRect(&rect);

								// Create AxWindow with a NULL caption.
								wnd.Create(m_hWnd,
									&rect,
									NULL,
									(bDialogEx ?
										((_DialogSplitHelper::DLGITEMTEMPLATEEX*)pItem)->style :
										pItem->style) | WS_TABSTOP,
									bDialogEx ?
										((_DialogSplitHelper::DLGITEMTEMPLATEEX*)pItem)->exStyle :
										0,
									bDialogEx ?
										((_DialogSplitHelper::DLGITEMTEMPLATEEX*)pItem)->id :
										pItem->id,
									NULL);

								if (wnd != NULL)
								{
									// Set the Help ID
									if (bDialogEx && ((_DialogSplitHelper::DLGITEMTEMPLATEEX*)pItem)->helpID != 0)
										wnd.SetWindowContextHelpId(((_DialogSplitHelper::DLGITEMTEMPLATEEX*)pItem)->helpID);
									// Try to create the ActiveX control.
									hr = wnd.CreateControlLic(pszClassName, spStream, NULL, bstrLicKey);
									if (FAILED(hr))
										break;
									// Set the correct tab position.
									if (nItem == 0)
										hWndPrev = HWND_TOP;
									wnd.SetWindowPos(hWndPrev, 0,0,0,0,SWP_NOACTIVATE | SWP_NOMOVE | SWP_NOSIZE);
									hWndPrev = wnd;
								}
								else
								{
									hr = AtlHresultFromLastError();
								}
							}
						}
						else
						{
							if (nItem != 0)
								hWndPrev = ::GetWindow(hWndPrev, GW_HWNDNEXT);
						}
						pItem = _DialogSplitHelper::FindNextDlgItem(pItem, bDialogEx);
					}
				}
				else
					hr = AtlHresultFromLastError();
			}
			else
				hr = AtlHresultFromLastError();
		}
		return hr;
	}

	LRESULT OnInitDialog(
		_In_ UINT /*uMsg*/,
		_In_ WPARAM /*wParam*/,
		_In_ LPARAM /*lParam*/,
		_Out_ BOOL& bHandled)
	{
		// initialize controls in dialog with DLGINIT resource section
		ExecuteDlgInit(static_cast<T*>(this)->IDD);
		AdviseSinkMap(true);
		bHandled = FALSE;
		return 1;
	}

	LRESULT OnDestroy(
		_In_ UINT /*uMsg*/,
		_In_ WPARAM /*wParam*/,
		_In_ LPARAM /*lParam*/,
		_Out_ BOOL& bHandled)
	{
		AdviseSinkMap(false);
		bHandled = FALSE;
		return 1;
	}

// Accelerators handling - needs to be called from a message loop
	BOOL IsDialogMessage(_In_ LPMSG pMsg)
	{
		if((pMsg->message < WM_KEYFIRST || pMsg->message > WM_KEYLAST) &&
		   (pMsg->message < WM_MOUSEFIRST || pMsg->message > WM_MOUSELAST))
			return FALSE;

		// find a direct child of the dialog from the window that has focus
		HWND hWndCtl = ::GetFocus();
		if(IsChild(hWndCtl) && ::GetParent(hWndCtl) != m_hWnd)
		{
			do
			{
				hWndCtl = ::GetParent(hWndCtl);
			}
			while (::GetParent(hWndCtl) != m_hWnd);
		}
		// give controls a chance to translate this message
		if (::SendMessage(hWndCtl, WM_FORWARDMSG, 0, (LPARAM)pMsg) == 1)
			return TRUE;

		// do the Windows default thing
		return CDialogImplBaseT< TBase >::IsDialogMessage(pMsg);
	}
};

template <class T, class TBase>
INT_PTR CALLBACK CAxDialogImpl< T, TBase >::DialogProc(
	_In_ HWND hWnd,
	_In_ UINT uMsg,
	_In_ WPARAM wParam,
	_In_ LPARAM lParam)
{
	CAxDialogImpl< T, TBase >* pThis = reinterpret_cast< CAxDialogImpl< T, TBase >* >(hWnd);
	if (uMsg == WM_INITDIALOG)
	{
		HRESULT hr;
		if (FAILED(hr = pThis->CreateActiveXControls(pThis->GetIDD())))
		{
			pThis->m_hrError = hr;

			if (pThis->m_bModal)
			{
				pThis->EndDialog(-1);
			}

			return FALSE;
		}
	}
	return CDialogImplBaseT< TBase >::DialogProc(hWnd, uMsg, wParam, lParam);
}
#endif //_ATL_NO_HOSTING

/////////////////////////////////////////////////////////////////////////////
// CSimpleDialog - Prebuilt modal dialog that uses standard buttons

template <WORD t_wDlgTemplateID, BOOL t_bCenter /* = TRUE */>
class CSimpleDialog :
	public CDialogImplBase
{
public:
	INT_PTR DoModal(_In_ HWND hWndParent = ::GetActiveWindow())
	{
		ATLASSUME(m_hWnd == NULL);
		_AtlWinModule.AddCreateWndData(&m_thunk.cd, (CDialogImplBase*)this);
		INT_PTR nRet = ::DialogBox(_AtlBaseModule.GetResourceInstance(),
			MAKEINTRESOURCE(t_wDlgTemplateID), hWndParent, StartDialogProc);
		m_hWnd = NULL;
		return nRet;
	}

	typedef CSimpleDialog<t_wDlgTemplateID, t_bCenter>	thisClass;
	BEGIN_MSG_MAP(thisClass)
		MESSAGE_HANDLER(WM_INITDIALOG, OnInitDialog)
		COMMAND_RANGE_HANDLER(IDOK, IDNO, OnCloseCmd)
	END_MSG_MAP()

	LRESULT OnInitDialog(
		_In_ UINT /*uMsg*/,
		_In_ WPARAM /*wParam*/,
		_In_ LPARAM /*lParam*/,
		_In_ BOOL& /*bHandled*/)
	{
		// initialize controls in dialog with DLGINIT resource section
		ExecuteDlgInit(t_wDlgTemplateID);
		if(t_bCenter)
			CenterWindow(GetParent());
		return TRUE;
	}

	LRESULT OnCloseCmd(
		_In_ WORD /*wNotifyCode*/,
		_In_ WORD wID,
		_In_ HWND /*hWndCtl*/,
		_In_ BOOL& /*bHandled*/)
	{
		::EndDialog(m_hWnd, wID);
		return 0;
	}
};

/////////////////////////////////////////////////////////////////////////////
// CContainedWindow - Implements a contained window

template <class TBase /* = CWindow */, class TWinTraits /* = CControlWinTraits */>
class CContainedWindowT :
	public TBase
{
public:
	CWndProcThunk m_thunk;
	LPCTSTR m_lpszClassName;
	WNDPROC m_pfnSuperWindowProc;
	CMessageMap* m_pObject;
	DWORD m_dwMsgMapID;
	const _ATL_MSG* m_pCurrentMsg;

	// If you use this constructor you must supply
	// the Window Class Name, Object* and Message Map ID
	// Later to the Create call
	CContainedWindowT() : m_pCurrentMsg(NULL)
	{
	}

	CContainedWindowT(
			_In_z_ LPTSTR lpszClassName,
			_In_ CMessageMap* pObject,
			_In_ DWORD dwMsgMapID = 0)
		: m_lpszClassName(lpszClassName),
		m_pfnSuperWindowProc(::DefWindowProc),
		m_pObject(pObject), m_dwMsgMapID(dwMsgMapID),
		m_pCurrentMsg(NULL)
	{
	}

	CContainedWindowT(
			_In_ CMessageMap* pObject,
			_In_ DWORD dwMsgMapID = 0)
		: m_lpszClassName(TBase::GetWndClassName()),
		m_pfnSuperWindowProc(::DefWindowProc),
		m_pObject(pObject), m_dwMsgMapID(dwMsgMapID),
		m_pCurrentMsg(NULL)
	{
	}

	void SwitchMessageMap(_In_ DWORD dwMsgMapID)
	{
		m_dwMsgMapID = dwMsgMapID;
	}

	const _ATL_MSG* GetCurrentMessage() const
	{
		return m_pCurrentMsg;
	}

	LRESULT DefWindowProc()
	{
		const _ATL_MSG* pMsg = m_pCurrentMsg;
		LRESULT lRes = 0;
		if (pMsg != NULL)
			lRes = DefWindowProc(pMsg->message, pMsg->wParam, pMsg->lParam);
		return lRes;
	}

	LRESULT DefWindowProc(
		_In_ UINT uMsg,
		_In_ WPARAM wParam,
		_In_ LPARAM lParam)
	{
#ifdef STRICT
		return ::CallWindowProc(m_pfnSuperWindowProc, m_hWnd, uMsg, wParam, lParam);
#else
		return ::CallWindowProc((FARPROC)m_pfnSuperWindowProc, m_hWnd, uMsg, wParam, lParam);
#endif
	}
	static LRESULT CALLBACK StartWindowProc(
		_In_ HWND hWnd,
		_In_ UINT uMsg,
		_In_ WPARAM wParam,
		_In_ LPARAM lParam)
	{
		CContainedWindowT< TBase >* pThis = (CContainedWindowT< TBase >*)_AtlWinModule.ExtractCreateWndData();
		ATLASSERT(pThis != NULL);
		if(!pThis)
		{
			return 0;
		}
		pThis->m_hWnd = hWnd;

		// Initialize the thunk.  This was allocated in CContainedWindowT::Create,
		// so failure is unexpected here.

		pThis->m_thunk.Init(WindowProc, pThis);
		WNDPROC pProc = pThis->m_thunk.GetWNDPROC();
		WNDPROC pOldProc = (WNDPROC)::SetWindowLongPtr(hWnd, GWLP_WNDPROC, (LONG_PTR)pProc);
#ifdef _DEBUG
		// check if somebody has subclassed us already since we discard it
		if(pOldProc != StartWindowProc)
			ATLTRACE(atlTraceWindowing, 0, _T("Subclassing through a hook discarded.\n"));
#else
		DBG_UNREFERENCED_LOCAL_VARIABLE(pOldProc);	// avoid unused warning
#endif
		return pProc(hWnd, uMsg, wParam, lParam);
	}

	static LRESULT CALLBACK WindowProc(
		_In_ HWND hWnd,
		_In_ UINT uMsg,
		_In_ WPARAM wParam,
		_In_ LPARAM lParam)
	{
		CContainedWindowT< TBase >* pThis = (CContainedWindowT< TBase >*)hWnd;
		ATLASSERT(pThis);
		if(!pThis)
		{
			return 0;
		}
		ATLASSERT(pThis->m_hWnd != NULL);
		ATLASSERT(pThis->m_pObject != NULL);
		if(!pThis->m_hWnd || !pThis->m_pObject)
		{
			return 0;
		}
		// set a ptr to this message and save the old value
		_ATL_MSG msg(pThis->m_hWnd, uMsg, wParam, lParam);
		const _ATL_MSG* pOldMsg = pThis->m_pCurrentMsg;
		pThis->m_pCurrentMsg = &msg;
		// pass to the message map to process
		LRESULT lRes = 0;
		BOOL bRet = pThis->m_pObject->ProcessWindowMessage(pThis->m_hWnd, uMsg, wParam, lParam, lRes, pThis->m_dwMsgMapID);
		// restore saved value for the current message
		ATLASSERT(pThis->m_pCurrentMsg == &msg);
		pThis->m_pCurrentMsg = pOldMsg;
		// do the default processing if message was not handled
		if(!bRet)
		{
			if(uMsg != WM_NCDESTROY)
				lRes = pThis->DefWindowProc(uMsg, wParam, lParam);
			else
			{
				// unsubclass, if needed
				LONG_PTR pfnWndProc = ::GetWindowLongPtr(pThis->m_hWnd, GWLP_WNDPROC);
				lRes = pThis->DefWindowProc(uMsg, wParam, lParam);
				if(pThis->m_pfnSuperWindowProc != ::DefWindowProc && ::GetWindowLongPtr(pThis->m_hWnd, GWLP_WNDPROC) == pfnWndProc)
					::SetWindowLongPtr(pThis->m_hWnd, GWLP_WNDPROC, (LONG_PTR)pThis->m_pfnSuperWindowProc);
				// clear out window handle
				pThis->m_hWnd = NULL;
			}
		}
		return lRes;
	}

	ATOM RegisterWndSuperclass()
	{
		USES_ATL_SAFE_ALLOCA;
		ATOM atom = 0;
		size_t cchBuff = _tcslen(m_lpszClassName) + 14;
		LPTSTR szBuff = (LPTSTR)_ATL_SAFE_ALLOCA( (cchBuff * sizeof(TCHAR)), _ATL_SAFE_ALLOCA_DEF_THRESHOLD);
		if (NULL == szBuff)
		{
			return atom;
		}

		WNDCLASSEX wc;
		wc.cbSize = sizeof(WNDCLASSEX);

		// Try global class
		if(!::GetClassInfoEx(NULL, m_lpszClassName, &wc))
		{
			// try local class
			if(!::GetClassInfoEx(_AtlBaseModule.GetModuleInstance(), m_lpszClassName, &wc))
				return atom;
		}

		m_pfnSuperWindowProc = wc.lpfnWndProc;
		Checked::tcscpy_s(szBuff, cchBuff, _T("ATL:"));
		Checked::tcscat_s(szBuff, cchBuff, m_lpszClassName);

		WNDCLASSEX wc1;
		wc1.cbSize = sizeof(WNDCLASSEX);

		SetLastError(0);
		atom = (ATOM)::GetClassInfoEx(_AtlBaseModule.GetModuleInstance(), szBuff, &wc1);

		if(atom == 0 && GetLastError() == ERROR_CLASS_DOES_NOT_EXIST)   // register class
		{
			wc.lpszClassName = szBuff;
			wc.lpfnWndProc = StartWindowProc;
			wc.hInstance = _AtlBaseModule.GetModuleInstance();
			wc.style &= ~CS_GLOBALCLASS;	// we don't register global classes

			atom = AtlWinModuleRegisterClassEx(&_AtlWinModule, &wc);
		}
		return atom;
	}

	HWND Create(
		_In_ HWND hWndParent,
		_In_ _U_RECT rect,
		_In_opt_z_ LPCTSTR szWindowName = NULL,
		_In_ DWORD dwStyle = 0,
		_In_ DWORD dwExStyle = 0,
		_In_ _U_MENUorID MenuOrID = 0U,
		_In_opt_ LPVOID lpCreateParam = NULL)
	{
		BOOL result;
		ATLASSUME(m_hWnd == NULL);

		ATOM atom = RegisterWndSuperclass();
		if(atom == 0)
			return NULL;

		// Allocate the thunk structure here, where we can fail gracefully.

		result = m_thunk.Init(NULL,NULL);
		if (result == FALSE)
		{
			SetLastError(ERROR_OUTOFMEMORY);
			return NULL;
		}

		_AtlWinModule.AddCreateWndData(&m_thunk.cd, this);

		if(MenuOrID.m_hMenu == NULL && (dwStyle & WS_CHILD))
			MenuOrID.m_hMenu = (HMENU)(UINT_PTR)this;
		if(rect.m_lpRect == NULL)
			rect.m_lpRect = &TBase::rcDefault;

		dwStyle = TWinTraits::GetWndStyle(dwStyle);
		dwExStyle = TWinTraits::GetWndExStyle(dwExStyle);

		HWND hWnd = ::CreateWindowEx(dwExStyle, MAKEINTATOM(atom), szWindowName,
								dwStyle,
								rect.m_lpRect->left, rect.m_lpRect->top,
								rect.m_lpRect->right - rect.m_lpRect->left,
								rect.m_lpRect->bottom - rect.m_lpRect->top,
								hWndParent, MenuOrID.m_hMenu,
								_AtlBaseModule.GetModuleInstance(), lpCreateParam);
		ATLASSUME(m_hWnd == hWnd);
		return hWnd;
	}

	HWND Create(
		_In_ CMessageMap* pObject,
		_In_ DWORD dwMsgMapID,
		_In_ HWND hWndParent,
		_In_ _U_RECT rect,
		_In_opt_z_ LPCTSTR szWindowName = NULL,
		_In_ DWORD dwStyle = 0,
		_In_ DWORD dwExStyle = 0,
		_In_ _U_MENUorID MenuOrID = 0U,
		_In_opt_ LPVOID lpCreateParam = NULL)
	{
		m_lpszClassName = TBase::GetWndClassName();
		m_pfnSuperWindowProc = ::DefWindowProc;
		m_pObject = pObject;
		m_dwMsgMapID = dwMsgMapID;
		return Create(hWndParent, rect, szWindowName, dwStyle, dwExStyle, MenuOrID, lpCreateParam);
	}

	HWND Create(
		_In_z_ LPCTSTR lpszClassName,
		_In_ CMessageMap* pObject,
		_In_ DWORD dwMsgMapID,
		_In_ HWND hWndParent,
		_In_ _U_RECT rect,
		_In_opt_z_ LPCTSTR szWindowName = NULL,
		_In_ DWORD dwStyle = 0,
		_In_ DWORD dwExStyle = 0,
		_In_ _U_MENUorID MenuOrID = 0U,
		_In_opt_ LPVOID lpCreateParam = NULL)
	{
		m_lpszClassName = lpszClassName;
		m_pfnSuperWindowProc = ::DefWindowProc;
		m_pObject = pObject;
		m_dwMsgMapID = dwMsgMapID;
		return Create(hWndParent, rect, szWindowName, dwStyle, dwExStyle, MenuOrID, lpCreateParam);
	}

	BOOL SubclassWindow(_In_ HWND hWnd)
	{
		BOOL result;
		ATLASSUME(m_hWnd == NULL);
		ATLASSERT(::IsWindow(hWnd));

		result = m_thunk.Init(WindowProc, this);
		if (result == FALSE)
		{
			return result;
		}

		WNDPROC pProc = m_thunk.GetWNDPROC();
		WNDPROC pfnWndProc = (WNDPROC)::SetWindowLongPtr(hWnd, GWLP_WNDPROC, (LONG_PTR)pProc);
		if(pfnWndProc == NULL)
			return FALSE;
		m_pfnSuperWindowProc = pfnWndProc;
		m_hWnd = hWnd;
		return TRUE;
	}

	// Use only if you want to subclass before window is destroyed,
	// WindowProc will automatically subclass when  window goes away
	HWND UnsubclassWindow(_In_ BOOL bForce = FALSE)
	{
		ATLASSUME(m_hWnd != NULL);

		WNDPROC pOurProc = m_thunk.GetWNDPROC();
		WNDPROC pActiveProc = (WNDPROC)::GetWindowLongPtr(m_hWnd, GWLP_WNDPROC);

		HWND hWnd = NULL;
		if (bForce || pOurProc == pActiveProc)
		{
			if(!::SetWindowLongPtr(m_hWnd, GWLP_WNDPROC, (LONG_PTR)m_pfnSuperWindowProc))
				return NULL;

			m_pfnSuperWindowProc = ::DefWindowProc;
			hWnd = m_hWnd;
			m_hWnd = NULL;
		}
		return hWnd;
	}
	LRESULT ReflectNotifications(
		_In_ UINT uMsg,
		_In_ WPARAM wParam,
		_In_ LPARAM lParam,
		_Inout_ BOOL& bHandled)
	{
		HWND hWndChild = NULL;

		switch(uMsg)
		{
		case WM_COMMAND:
			if(lParam != NULL)	// not from a menu
				hWndChild = (HWND)lParam;
			break;
		case WM_NOTIFY:
			hWndChild = ((LPNMHDR)lParam)->hwndFrom;
			break;
		case WM_PARENTNOTIFY:
			switch(LOWORD(wParam))
			{
			case WM_CREATE:
			case WM_DESTROY:
				hWndChild = (HWND)lParam;
				break;
			default:
				hWndChild = GetDlgItem(HIWORD(wParam));
				break;
			}
			break;
		case WM_DRAWITEM:
			if(wParam)	// not from a menu
				hWndChild = ((LPDRAWITEMSTRUCT)lParam)->hwndItem;
			break;
		case WM_MEASUREITEM:
			if(wParam)	// not from a menu
				hWndChild = GetDlgItem(((LPMEASUREITEMSTRUCT)lParam)->CtlID);
			break;
		case WM_COMPAREITEM:
			if(wParam)	// not from a menu
				hWndChild = ((LPCOMPAREITEMSTRUCT)lParam)->hwndItem;
			break;
		case WM_DELETEITEM:
			if(wParam)	// not from a menu
				hWndChild = ((LPDELETEITEMSTRUCT)lParam)->hwndItem;

			break;
		case WM_VKEYTOITEM:
		case WM_CHARTOITEM:
		case WM_HSCROLL:
		case WM_VSCROLL:
			hWndChild = (HWND)lParam;
			break;
		case WM_CTLCOLORBTN:
		case WM_CTLCOLORDLG:
		case WM_CTLCOLOREDIT:
		case WM_CTLCOLORLISTBOX:
		case WM_CTLCOLORMSGBOX:
		case WM_CTLCOLORSCROLLBAR:
		case WM_CTLCOLORSTATIC:
			hWndChild = (HWND)lParam;
			break;
		default:
			break;
		}

		if(hWndChild == NULL)
		{
			bHandled = FALSE;
			return 1;
		}

		ATLASSERT(::IsWindow(hWndChild));
		return ::SendMessage(hWndChild, OCM__BASE + uMsg, wParam, lParam);
	}
};

typedef CContainedWindowT<CWindow>	CContainedWindow;

/////////////////////////////////////////////////////////////////////////////
// _DialogSizeHelper - helpers for calculating the size of a dialog template

class _DialogSizeHelper
{
public:
//local struct used for implementation
#pragma pack(push, 1)
	struct _ATL_DLGTEMPLATEEX
	{
		WORD dlgVer;
		WORD signature;
		DWORD helpID;
		DWORD exStyle;
		DWORD style;
		WORD cDlgItems;
		short x;
		short y;
		short cx;
		short cy;
	};
#pragma pack(pop)

	static void GetDialogSize(
		_In_ const DLGTEMPLATE* pTemplate,
		_Out_ SIZE* pSize,
		_In_ bool bPropertyPage = false)
	{
		// If the dialog has a font we use it otherwise we default
		// to the system font.
		TCHAR szFace[LF_FACESIZE];
		WORD  wFontSize = 0;
		GetSizeInDialogUnits(pTemplate, pSize);
		BOOL bFont = GetFont(pTemplate, szFace, &wFontSize);
		if (bFont)
		{
			ConvertDialogUnitsToPixels(szFace, wFontSize, pSize, bPropertyPage);
		}
		else
		{
			ConvertDialogUnitsToPixels(NULL, 0, pSize, bPropertyPage);
		}
	}

	static void GetFontDimensions(
		_In_opt_z_ LPCTSTR pszFontFace,
		_In_ WORD wFontSize,
		_Out_ SIZE* pSizeChar,
		_Out_ LONG *ptmHeight)
	{
		if (pszFontFace != NULL)
		{
			// Attempt to create the font to be used in the dialog box
			HDC hDC = ::GetDC(NULL);
			if (hDC != NULL)
			{
				LOGFONT lf;
				memset(&lf, 0, sizeof(LOGFONT));
				lf.lfHeight = -MulDiv(wFontSize, GetDeviceCaps(hDC, LOGPIXELSY), 72);
				lf.lfWeight = FW_NORMAL;
				lf.lfCharSet = DEFAULT_CHARSET;
				Checked::tcsncpy_s(lf.lfFaceName, _countof(lf.lfFaceName), pszFontFace, _TRUNCATE);

				HFONT hNewFont = CreateFontIndirect(&lf);
				if (hNewFont != NULL)
				{
					TEXTMETRIC  tm;
					SIZE        size;
					HFONT       hFontOld = (HFONT)SelectObject(hDC, hNewFont);
					GetTextMetrics(hDC, &tm);
					::GetTextExtentPoint(hDC,
						_T("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz"), 52,
						&size);
					SelectObject(hDC, hFontOld);
					DeleteObject(hNewFont);
					*ptmHeight = tm.tmHeight;
					pSizeChar->cy = tm.tmHeight + tm.tmExternalLeading;
					pSizeChar->cx = (size.cx + 26) / 52;
					::ReleaseDC(NULL, hDC);
					return;
				}
				::ReleaseDC(NULL, hDC);
			}
		}
		// Could not create font or no font name was not specified
		LONG nDlgBaseUnits = GetDialogBaseUnits();
		pSizeChar->cx = LOWORD(nDlgBaseUnits);
		*ptmHeight = pSizeChar->cy = HIWORD(nDlgBaseUnits);
	}

// ID of the dialog template used for property sheet in comctl32.dll
#define IDD_PROPSHEET_ID   1006

	static void ConvertDialogUnitsToPixels(
		_In_opt_z_ LPCTSTR pszFontFace,
		_In_ WORD wFontSize,
		_Inout_ SIZE* pSizePixel,
		_In_ bool bPropertyPage = false)
	{
		LONG tmHeight;
		SIZE sizeFontChar;
		GetFontDimensions(pszFontFace, wFontSize, &sizeFontChar, &tmHeight);
		if (bPropertyPage)
		{
			// Get the font used by the property sheet
			HINSTANCE hInst = LoadLibrary(_T("COMCTL32.DLL"));
			if (hInst != NULL)
			{
				HRSRC hResource = ::FindResourceW(hInst,
					MAKEINTRESOURCEW(IDD_PROPSHEET_ID),
					(LPWSTR) RT_DIALOG);
				if (hResource != NULL)
				{
					HGLOBAL hTemplate = LoadResource(hInst, hResource);
					if (hTemplate != NULL)
					{
						TCHAR szFace[LF_FACESIZE];
						WORD wSize;
						BOOL bFont;
						bFont = _DialogSizeHelper::GetFont((DLGTEMPLATE*)hTemplate, szFace,	&wSize);
						FreeLibrary(hInst);
						if (bFont)
						{
							SIZE sizeSheetFontChar;
							LONG tmHeightSheetFont;
							GetFontDimensions(szFace, wSize, &sizeSheetFontChar, &tmHeightSheetFont);
							// Now translate to pixels compensating for the calculations made by OLEAUT32 and Dialog manager

							// Calculate the size of pixels using property sheet font.
							pSizePixel->cx = MulDiv(pSizePixel->cx, sizeFontChar.cx, 4);
							pSizePixel->cy = MulDiv(pSizePixel->cy, sizeSheetFontChar.cy, 8);

							// Inflate/Deflate the height to compensate for the correct font.
							pSizePixel->cy = MulDiv(pSizePixel->cy, tmHeight, tmHeightSheetFont);
							return ;
						}
					}
				}
			}
		}
		// Not property page or could not load Property sheet resource.
		// Translate dialog units to pixels
		pSizePixel->cx = MulDiv(pSizePixel->cx, sizeFontChar.cx, 4);
		pSizePixel->cy = MulDiv(pSizePixel->cy, sizeFontChar.cy, 8);
	}

	static BOOL IsDialogEx(_In_ const DLGTEMPLATE* pTemplate)
	{
		return ((_ATL_DLGTEMPLATEEX*)pTemplate)->signature == 0xFFFF;
	}

	static BOOL HasFont(_In_ const DLGTEMPLATE* pTemplate)
	{
		return (DS_SETFONT &
			(IsDialogEx(pTemplate) ?
				((_ATL_DLGTEMPLATEEX*)pTemplate)->style : pTemplate->style));
	}

	static BYTE* GetFontSizeField(_In_ const DLGTEMPLATE* pTemplate)
	{
		BOOL bDialogEx = IsDialogEx(pTemplate);
		WORD* pw;

		if (bDialogEx)
			pw = (WORD*)((_ATL_DLGTEMPLATEEX*)pTemplate + 1);
		else
			pw = (WORD*)(pTemplate + 1);

		if (*pw == (WORD)-1)        // Skip menu name string or ordinal
			pw += 2; // WORDs
		else
			while(*pw++);

		if (*pw == (WORD)-1)        // Skip class name string or ordinal
			pw += 2; // WORDs
		else
			while(*pw++);

		while (*pw++);          // Skip caption string

		return (BYTE*)pw;
	}

	static BOOL GetFont(
		_In_ const DLGTEMPLATE* pTemplate,
		_Out_z_cap_c_(LF_FACESIZE) TCHAR* pszFace,
		_Out_ WORD* pFontSize)
	{
		ATLENSURE(pTemplate!=NULL);
		if (!HasFont(pTemplate))
			return FALSE;
		ATLENSURE(pszFace!=NULL);
		ATLENSURE(pFontSize!=NULL);

		BYTE* pb = GetFontSizeField(pTemplate);
		*pFontSize = *(WORD*)pb;
		// Skip over font attributes to get to the font name
		pb += sizeof(WORD) * (IsDialogEx(pTemplate) ? 3 : 1);
		CW2T pszFaceTemp(reinterpret_cast<WCHAR*>(pb));
		Checked::tcsncpy_s(pszFace, LF_FACESIZE, pszFaceTemp, _TRUNCATE);
		if (_tcslen(pszFace) >= LF_FACESIZE)
		{	// NUL not appended
			pszFace[LF_FACESIZE-1] = _T('\0');
		}
		return TRUE;
	}

	static void GetSizeInDialogUnits(
		_In_ const DLGTEMPLATE* pTemplate,
		_Out_ SIZE* pSize)
	{
		if (IsDialogEx(pTemplate))
		{
			pSize->cx = ((_ATL_DLGTEMPLATEEX*)pTemplate)->cx;
			pSize->cy = ((_ATL_DLGTEMPLATEEX*)pTemplate)->cy;
		}
		else
		{
			pSize->cx = pTemplate->cx;
			pSize->cy = pTemplate->cy;
		}
	}
};

inline void AtlGetDialogSize(
	_In_ const DLGTEMPLATE* pTemplate,
	_Out_ SIZE* pSize,
	_In_ bool bPropertyPage = false)
{
	ATLASSERT(pTemplate != NULL);
	ATLASSERT(pSize != NULL);
	_DialogSizeHelper::GetDialogSize(pTemplate, pSize, bPropertyPage);
}

}; //namespace ATL

#ifndef _ATL_NO_HOSTING

#include <atlhost.h>

#endif

#endif // __ATLWIN_H__


namespace ATL
{

class AtlModuleRegisterWndClassInfoParamA
{
public:
	typedef LPSTR				PXSTR;
	typedef LPCSTR				PCXSTR;
	typedef _ATL_WNDCLASSINFOA	_ATL_WNDCLASSINFO;
	typedef WNDCLASSEXA			WNDCLASSEX;

	static BOOL GetClassInfoEx(
		_In_opt_ HINSTANCE hinst,
		_In_z_ PCXSTR lpszClass,
		_Out_ WNDCLASSEX* lpwcx)
	{
		return ::GetClassInfoExA(hinst, lpszClass, lpwcx);
	}

	_ATL_INSECURE_DEPRECATE("You must pass an output buffer size to AtlModuleRegisterWndClassInfoParamA::FormatWindowClassName")
	static void FormatWindowClassName(
		_In_z_ PXSTR szBuffer,
		_In_ void* unique)
	{
#pragma warning(push)
#pragma warning(disable:4996)
#if defined(_WIN64) // || or Windows 2000
		::wsprintfA(szBuffer, "ATL:%p", unique);
#else
		::wsprintfA(szBuffer, "ATL:%8.8X", reinterpret_cast<DWORD_PTR>(unique));
#endif
#pragma warning(pop)
	}

	static void FormatWindowClassName(
		_Out_z_cap_(dwBuffSize) PXSTR szBuffer,
		_In_ DWORD dwBuffSize,
		_In_ void* unique)
	{
		sprintf_s(szBuffer, dwBuffSize, "ATL:%p", unique);
	}

	static HCURSOR LoadCursor(
		_In_opt_ HINSTANCE hInstance,
		_In_z_ PCXSTR lpCursorName)
	{
		return ::LoadCursorA(hInstance, lpCursorName);
	}

	static ATOM RegisterClassEx(
		_In_ _ATL_WIN_MODULE* pWinModule,
		_In_ const WNDCLASSEX* lpwcx)
	{
		return AtlWinModuleRegisterClassExA(pWinModule, lpwcx);
	}
};

class AtlModuleRegisterWndClassInfoParamW
{
public:
	typedef LPWSTR				PXSTR;
	typedef LPCWSTR				PCXSTR;
	typedef _ATL_WNDCLASSINFOW	_ATL_WNDCLASSINFO;
	typedef WNDCLASSEXW			WNDCLASSEX;

	static BOOL GetClassInfoEx(
		_In_opt_ HINSTANCE hinst,
		_In_z_ PCXSTR lpszClass,
		_Out_ WNDCLASSEX* lpwcx)
	{
		return ::GetClassInfoExW(hinst, lpszClass, lpwcx);
	}

	_ATL_INSECURE_DEPRECATE("You must pass an output buffer size to AtlModuleRegisterWndClassInfoParamW::FormatWindowClassName")
	static void FormatWindowClassName(
		_In_z_ PXSTR szBuffer,
		_In_ void* unique)
	{
#pragma warning(push)
#pragma warning(disable:4996)
#if defined(_WIN64) // || or Windows 2000
		::wsprintfW(szBuffer, L"ATL:%p", unique);
#else
		::wsprintfW(szBuffer, L"ATL:%8.8X", reinterpret_cast<DWORD_PTR>(unique));
#endif
#pragma warning(pop)
	}

	static void FormatWindowClassName(
		_Out_z_cap_(dwBuffSize) PXSTR szBuffer,
		_In_ DWORD dwBuffSize,
		_In_ void* unique)
	{
		swprintf_s(szBuffer, dwBuffSize, L"ATL:%p", unique);
	}

	static HCURSOR LoadCursor(
		_In_opt_ HINSTANCE hInstance,
		_In_z_ PCXSTR lpCursorName)
	{
		return ::LoadCursorW(hInstance, lpCursorName);
	}

	static ATOM RegisterClassEx(
		_In_ _ATL_WIN_MODULE* pWinModule,
		_In_ const WNDCLASSEX* lpwcx)
	{
		return AtlWinModuleRegisterClassExW(pWinModule, lpwcx);
	}
};

ATLINLINE ATLAPIINL_(ATOM) AtlWinModuleRegisterClassExA(
	_In_ _ATL_WIN_MODULE* pWinModule,
	_In_ const WNDCLASSEXA *lpwc)
{
	if (pWinModule == NULL || lpwc == NULL)
		return 0;

	ATOM atom = ::RegisterClassExA(lpwc);
	if (atom != 0)
	{
		BOOL bRet = pWinModule->m_rgWindowClassAtoms.Add(atom);
		ATLASSERT(bRet);
		(bRet);
	}
	return atom;
}

ATLINLINE ATLAPIINL_(ATOM) AtlWinModuleRegisterClassExW(
	_In_ _ATL_WIN_MODULE* pWinModule,
	_In_ const WNDCLASSEXW *lpwc)
{
	if (pWinModule == NULL || lpwc == NULL)
		return 0;

	ATOM atom = ::RegisterClassExW(lpwc);
	if (atom != 0)
	{
		BOOL bRet = pWinModule->m_rgWindowClassAtoms.Add(atom);
		ATLASSERT(bRet);
		(bRet);
	}
	return atom;
}


template <class T>
ATLINLINE ATOM AtlModuleRegisterWndClassInfoT(
	_In_ _ATL_BASE_MODULE* pBaseModule,
	_In_ _ATL_WIN_MODULE* pWinModule,
	_Inout_ _Prepost_bytecount_x_(sizeof(T::_ATL_WNDCLASSINFO)) typename T::_ATL_WNDCLASSINFO* p,
	_In_ WNDPROC* pProc, 
	_In_ T)
{
	if (pBaseModule == NULL || pWinModule == NULL || p == NULL || pProc == NULL)
	{
		ATLTRACE(atlTraceWindowing, 0, _T("ERROR : Invalid Arguments to AtlModuleRegisterWndClassInfoT\n"));
		ATLASSERT(0);
		return 0;
	}

	if (p->m_atom == 0)
	{
		ATL::CComCritSecLock<ATL::CComCriticalSection> lock(pWinModule->m_csWindowCreate, false);
		if (FAILED(lock.Lock()))
		{
			ATLTRACE(atlTraceWindowing, 0, _T("ERROR : Unable to lock critical section in AtlModuleRegisterWndClassInfoT\n"));
			ATLASSERT(0);
			return 0;
		}
		if(p->m_atom == 0)
		{
			if (p->m_lpszOrigName != NULL)
			{
				ATLASSERT(pProc != NULL);
				T::PCXSTR lpsz = p->m_wc.lpszClassName;
				WNDPROC proc = p->m_wc.lpfnWndProc;

				T::WNDCLASSEX wc;
				wc.cbSize = sizeof(T::WNDCLASSEX);
				// Try global class
				if(!T::GetClassInfoEx(NULL, p->m_lpszOrigName, &wc))
				{
					// try process local
					if(!T::GetClassInfoEx(pBaseModule->m_hInst, p->m_lpszOrigName, &wc))
					{
						ATLTRACE(atlTraceWindowing, 0, "ERROR : Could not obtain Window Class information for %s\n", p->m_lpszOrigName);
						return 0;
					}
				}
				p->m_wc = wc;
				p->pWndProc = p->m_wc.lpfnWndProc;
				p->m_wc.lpszClassName = lpsz;
				p->m_wc.lpfnWndProc = proc;
			}
			else
			{
				p->m_wc.hCursor = T::LoadCursor(p->m_bSystemCursor ? NULL : pBaseModule->m_hInstResource,
					p->m_lpszCursorID);
			}

			p->m_wc.hInstance = pBaseModule->m_hInst;
			p->m_wc.style &= ~CS_GLOBALCLASS;	// we don't register global classes
			if (p->m_wc.lpszClassName == NULL)
			{
				T::FormatWindowClassName(p->m_szAutoName, _countof(p->m_szAutoName), &p->m_wc);
				p->m_wc.lpszClassName = p->m_szAutoName;
			}
			T::WNDCLASSEX wcTemp;
			wcTemp = p->m_wc;
			p->m_atom = static_cast<ATOM>(T::GetClassInfoEx(p->m_wc.hInstance, p->m_wc.lpszClassName, &wcTemp));
			if (p->m_atom == 0)
			{
				p->m_atom = T::RegisterClassEx(pWinModule, &p->m_wc);
			}
		}
	}

	if (p->m_lpszOrigName != NULL)
	{
		ATLASSERT(pProc != NULL);
		ATLASSERT(p->pWndProc != NULL);
		*pProc = p->pWndProc;
	}
	return p->m_atom;
}

ATLINLINE ATLAPIINL_(ATOM) AtlWinModuleRegisterWndClassInfoA(
	_In_ _ATL_WIN_MODULE* pWinModule,
	_In_ _ATL_BASE_MODULE* pBaseModule,
	_Inout_ _ATL_WNDCLASSINFOA* p,
	_In_ WNDPROC* pProc)
{
	AtlModuleRegisterWndClassInfoParamA templateParameter;
	return AtlModuleRegisterWndClassInfoT<AtlModuleRegisterWndClassInfoParamA>(
		pBaseModule, pWinModule, p, pProc, templateParameter);
}

ATLINLINE ATLAPIINL_(ATOM) AtlWinModuleRegisterWndClassInfoW(
	_In_ _ATL_WIN_MODULE* pWinModule,
	_In_ _ATL_BASE_MODULE* pBaseModule,
	_Inout_ _ATL_WNDCLASSINFOW* p,
	_In_ WNDPROC* pProc)
{
	AtlModuleRegisterWndClassInfoParamW templateParameter;
	return AtlModuleRegisterWndClassInfoT<AtlModuleRegisterWndClassInfoParamW>(
		pBaseModule, pWinModule, p, pProc, templateParameter);
}

//All exports go here
#ifndef _ATL_DLL

ATLINLINE ATLAPI_(HDC) AtlCreateTargetDC(
	_In_ HDC hdc,
	_In_ DVTARGETDEVICE* ptd)
{
	USES_CONVERSION_EX;

	// cases  hdc, ptd, hdc is metafile, hic
//  NULL,    NULL,  n/a,    Display
//  NULL,   !NULL,  n/a,    ptd
//  !NULL,   NULL,  FALSE,  hdc
//  !NULL,   NULL,  TRUE,   display
//  !NULL,  !NULL,  FALSE,  ptd
//  !NULL,  !NULL,  TRUE,   ptd

	if (ptd != NULL)
	{
		LPDEVMODEOLE lpDevMode;
		LPOLESTR lpszDriverName;
		LPOLESTR lpszDeviceName;
		LPOLESTR lpszPortName;

		if (ptd->tdExtDevmodeOffset == 0)
			lpDevMode = NULL;
		else
			lpDevMode  = (LPDEVMODEOLE) ((LPSTR)ptd + ptd->tdExtDevmodeOffset);

		lpszDriverName = (LPOLESTR)((BYTE*)ptd + ptd->tdDriverNameOffset);
		lpszDeviceName = (LPOLESTR)((BYTE*)ptd + ptd->tdDeviceNameOffset);
		lpszPortName   = (LPOLESTR)((BYTE*)ptd + ptd->tdPortNameOffset);

		return ::CreateDC(OLE2CT_EX_DEF(lpszDriverName), OLE2CT_EX_DEF(lpszDeviceName), OLE2CT_EX_DEF(lpszPortName), DEVMODEOLE2T_EX(lpDevMode));
	}
	else if (hdc == NULL || GetDeviceCaps(hdc, TECHNOLOGY) == DT_METAFILE)
		return ::CreateDC(_T("DISPLAY"), NULL, NULL, NULL);
	else
		return hdc;
}


/////////////////////////////////////////////////////////////////////////////
// Windowing : Conversion helpers

ATLINLINE ATLAPI_(void) AtlHiMetricToPixel(
	_In_ const SIZEL *lpSizeInHiMetric,
	_Out_ LPSIZEL lpSizeInPix)
{
	ATLENSURE_THROW(lpSizeInHiMetric!=NULL, E_POINTER);
	ATLENSURE_THROW(lpSizeInPix!=NULL, E_POINTER);
	int nPixelsPerInchX;    // Pixels per logical inch along width
	int nPixelsPerInchY;    // Pixels per logical inch along height

	HDC hDCScreen = GetDC(NULL);
	ATLASSUME(hDCScreen != NULL);
	nPixelsPerInchX = GetDeviceCaps(hDCScreen, LOGPIXELSX);
	nPixelsPerInchY = GetDeviceCaps(hDCScreen, LOGPIXELSY);
	ReleaseDC(NULL, hDCScreen);

	lpSizeInPix->cx = MAP_LOGHIM_TO_PIX(lpSizeInHiMetric->cx, nPixelsPerInchX);
	lpSizeInPix->cy = MAP_LOGHIM_TO_PIX(lpSizeInHiMetric->cy, nPixelsPerInchY);
}

ATLINLINE ATLAPI_(void) AtlPixelToHiMetric(
	_In_ const SIZEL * lpSizeInPix,
	_Out_ LPSIZEL lpSizeInHiMetric)
{
	ATLENSURE_THROW(lpSizeInPix!=NULL, E_POINTER);
	ATLENSURE_THROW(lpSizeInHiMetric!=NULL, E_POINTER);
	int nPixelsPerInchX;    // Pixels per logical inch along width
	int nPixelsPerInchY;    // Pixels per logical inch along height

	HDC hDCScreen = GetDC(NULL);
	ATLASSUME(hDCScreen != NULL);
	nPixelsPerInchX = GetDeviceCaps(hDCScreen, LOGPIXELSX);
	nPixelsPerInchY = GetDeviceCaps(hDCScreen, LOGPIXELSY);
	ReleaseDC(NULL, hDCScreen);

	lpSizeInHiMetric->cx = MAP_PIX_TO_LOGHIM(lpSizeInPix->cx, nPixelsPerInchX);
	lpSizeInHiMetric->cy = MAP_PIX_TO_LOGHIM(lpSizeInPix->cy, nPixelsPerInchY);
}
#endif // !_ATL_DLL

} //namespace ATL


#pragma pack(pop)

#ifndef _ATL_NO_PRAGMA_WARNINGS
#pragma warning (pop)
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\include\atltypes.h ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#ifndef __ATLTYPES_H__
#define __ATLTYPES_H__

#pragma once

/////////////////////////////////////////////////////////////////////////////
// Classes declared in this file

class CSize;
class CPoint;
class CRect;

/////////////////////////////////////////////////////////////////////////////
// CSize - An extent, similar to Windows SIZE structure.

class CSize :
	public tagSIZE
{
public:

// Constructors
	// construct an uninitialized size
	CSize() throw();
	// create from two integers
	CSize(
		_In_ int initCX,
		_In_ int initCY) throw();
	// create from another size
	CSize(_In_ SIZE initSize) throw();
	// create from a point
	CSize(_In_ POINT initPt) throw();
	// create from a DWORD: cx = LOWORD(dw) cy = HIWORD(dw)
	CSize(_In_ DWORD dwSize) throw();

// Operations
	BOOL operator==(_In_ SIZE size) const throw();
	BOOL operator!=(_In_ SIZE size) const throw();
	void operator+=(_In_ SIZE size) throw();
	void operator-=(_In_ SIZE size) throw();
	void SetSize(_In_ int CX, _In_ int CY) throw();

// Operators returning CSize values
	CSize operator+(_In_ SIZE size) const throw();
	CSize operator-(_In_ SIZE size) const throw();
	CSize operator-() const throw();

// Operators returning CPoint values
	CPoint operator+(_In_ POINT point) const throw();
	CPoint operator-(_In_ POINT point) const throw();

// Operators returning CRect values
	CRect operator+(_In_ const RECT* lpRect) const throw();
	CRect operator-(_In_ const RECT* lpRect) const throw();
};

/////////////////////////////////////////////////////////////////////////////
// CPoint - A 2-D point, similar to Windows POINT structure.

class CPoint :
	public tagPOINT
{
public:
// Constructors

	// create an uninitialized point
	CPoint() throw();
	// create from two integers
	CPoint(
		_In_ int initX,
		_In_ int initY) throw();
	// create from another point
	CPoint(_In_ POINT initPt) throw();
	// create from a size
	CPoint(_In_ SIZE initSize) throw();
	// create from an LPARAM: x = LOWORD(dw) y = HIWORD(dw)
	CPoint(_In_ LPARAM dwPoint) throw();


// Operations

// translate the point
	void Offset(
		_In_ int xOffset,
		_In_ int yOffset) throw();
	void Offset(_In_ POINT point) throw();
	void Offset(_In_ SIZE size) throw();
	void SetPoint(
		_In_ int X,
		_In_ int Y) throw();

	BOOL operator==(_In_ POINT point) const throw();
	BOOL operator!=(_In_ POINT point) const throw();
	void operator+=(_In_ SIZE size) throw();
	void operator-=(_In_ SIZE size) throw();
	void operator+=(_In_ POINT point) throw();
	void operator-=(_In_ POINT point) throw();

// Operators returning CPoint values
	CPoint operator+(_In_ SIZE size) const throw();
	CPoint operator-(_In_ SIZE size) const throw();
	CPoint operator-() const throw();
	CPoint operator+(_In_ POINT point) const throw();

// Operators returning CSize values
	CSize operator-(_In_ POINT point) const throw();

// Operators returning CRect values
	CRect operator+(_In_ const RECT* lpRect) const throw();
	CRect operator-(_In_ const RECT* lpRect) const throw();
};

/////////////////////////////////////////////////////////////////////////////
// CRect - A 2-D rectangle, similar to Windows RECT structure.

class CRect :
	public tagRECT
{
// Constructors
public:
	// uninitialized rectangle
	CRect() throw();
	// from left, top, right, and bottom
	CRect(
		_In_ int l,
		_In_ int t,
		_In_ int r,
		_In_ int b) throw();
	// copy constructor
	CRect(_In_ const RECT& srcRect) throw();
	// from a pointer to another rect
	CRect(_In_ LPCRECT lpSrcRect) throw();
	// from a point and size
	CRect(
		_In_ POINT point,
		_In_ SIZE size) throw();
	// from two points
	CRect(
		_In_ POINT topLeft,
		_In_ POINT bottomRight) throw();

// Attributes (in addition to RECT members)

	// retrieves the width
	int Width() const throw();
	// returns the height
	int Height() const throw();
	// returns the size
	CSize Size() const throw();
	// reference to the top-left point
	CPoint& TopLeft() throw();
	// reference to the bottom-right point
	CPoint& BottomRight() throw();
	// const reference to the top-left point
	const CPoint& TopLeft() const throw();
	// const reference to the bottom-right point
	const CPoint& BottomRight() const throw();
	// the geometric center point of the rectangle
	CPoint CenterPoint() const throw();
	// swap the left and right
	void SwapLeftRight() throw();
	static void WINAPI SwapLeftRight(_Inout_ LPRECT lpRect) throw();

	// convert between CRect and LPRECT/LPCRECT (no need for &)
	operator LPRECT() throw();
	operator LPCRECT() const throw();

	// returns TRUE if rectangle has no area
	BOOL IsRectEmpty() const throw();
	// returns TRUE if rectangle is at (0,0) and has no area
	BOOL IsRectNull() const throw();
	// returns TRUE if point is within rectangle
	BOOL PtInRect(_In_ POINT point) const throw();

// Operations

	// set rectangle from left, top, right, and bottom
	void SetRect(
		_In_ int x1,
		_In_ int y1,
		_In_ int x2,
		_In_ int y2) throw();
	void SetRect(
		_In_ POINT topLeft,
		_In_ POINT bottomRight) throw();
	// empty the rectangle
	void SetRectEmpty() throw();
	// copy from another rectangle
	void CopyRect(_In_ LPCRECT lpSrcRect) throw();
	// TRUE if exactly the same as another rectangle
	BOOL EqualRect(_In_ LPCRECT lpRect) const throw();

	// Inflate rectangle's width and height by
	// x units to the left and right ends of the rectangle
	// and y units to the top and bottom.
	void InflateRect(
		_In_ int x,
		_In_ int y) throw();
	// Inflate rectangle's width and height by
	// size.cx units to the left and right ends of the rectangle
	// and size.cy units to the top and bottom.
	void InflateRect(_In_ SIZE size) throw();
	// Inflate rectangle's width and height by moving individual sides.
	// Left side is moved to the left, right side is moved to the right,
	// top is moved up and bottom is moved down.
	void InflateRect(_In_ LPCRECT lpRect) throw();
	void InflateRect(
		_In_ int l,
		_In_ int t,
		_In_ int r,
		_In_ int b) throw();

	// deflate the rectangle's width and height without
	// moving its top or left
	void DeflateRect(
		_In_ int x,
		_In_ int y) throw();
	void DeflateRect(_In_ SIZE size) throw();
	void DeflateRect(_In_ LPCRECT lpRect) throw();
	void DeflateRect(
		_In_ int l,
		_In_ int t,
		_In_ int r,
		_In_ int b) throw();

	// translate the rectangle by moving its top and left
	void OffsetRect(
		_In_ int x,
		_In_ int y) throw();
	void OffsetRect(_In_ SIZE size) throw();
	void OffsetRect(_In_ POINT point) throw();
	void NormalizeRect() throw();

	// absolute position of rectangle
	void MoveToY(_In_ int y) throw();
	void MoveToX(_In_ int x) throw();
	void MoveToXY(
		_In_ int x,
		_In_ int y) throw();
	void MoveToXY(_In_ POINT point) throw();

	// set this rectangle to intersection of two others
	BOOL IntersectRect(
		_In_ LPCRECT lpRect1,
		_In_ LPCRECT lpRect2) throw();

	// set this rectangle to bounding union of two others
	BOOL UnionRect(
		_In_ LPCRECT lpRect1,
		_In_ LPCRECT lpRect2) throw();

	// set this rectangle to minimum of two others
	BOOL SubtractRect(
		_In_ LPCRECT lpRectSrc1,
		_In_ LPCRECT lpRectSrc2) throw();

// Additional Operations
	void operator=(_In_ const RECT& srcRect) throw();
	BOOL operator==(_In_ const RECT& rect) const throw();
	BOOL operator!=(_In_ const RECT& rect) const throw();
	void operator+=(_In_ POINT point) throw();
	void operator+=(_In_ SIZE size) throw();
	void operator+=(_In_ LPCRECT lpRect) throw();
	void operator-=(_In_ POINT point) throw();
	void operator-=(_In_ SIZE size) throw();
	void operator-=(_In_ LPCRECT lpRect) throw();
	void operator&=(_In_ const RECT& rect) throw();
	void operator|=(_In_ const RECT& rect) throw();

// Operators returning CRect values
	CRect operator+(_In_ POINT point) const throw();
	CRect operator-(_In_ POINT point) const throw();
	CRect operator+(_In_ LPCRECT lpRect) const throw();
	CRect operator+(_In_ SIZE size) const throw();
	CRect operator-(_In_ SIZE size) const throw();
	CRect operator-(_In_ LPCRECT lpRect) const throw();
	CRect operator&(_In_ const RECT& rect2) const throw();
	CRect operator|(_In_ const RECT& rect2) const throw();
	CRect MulDiv(
		_In_ int nMultiplier,
		_In_ int nDivisor) const throw();
};

#ifndef _DEBUG
#define ATLTYPES_INLINE inline
#include <atltypes.inl>
#endif


#endif // __ATLTYPES_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\include\atltransactionmanager.h ===
// This is a part of the Active Template Library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Active Template Library Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Active Template Library product.

#ifndef __ATLTRANSACTIONMANAGER_H__
#define __ATLTRANSACTIONMANAGER_H__

#pragma once

#include <ktmw32.h>
#include <tchar.h>

_CRTIMP bool __cdecl __uncaught_exception();

#pragma pack(push,_ATL_PACKING)
namespace ATL
{

/// <summary>
/// CAtlTransactionManager class provides a wrapper to Kernel Transaction Manager (KTM) functions.</summary>
class CAtlTransactionManager
{
public:
	/// <summary>
	/// CAtlTransactionManager constructor</summary>
	/// <param name="bFallback">TRUE - support fallback. If transacted function fails, the class automatically calls the "non-transacted" function. FALSE - no "fallback" calls.</param>
	/// <param name="bAutoCreateTransaction">TRUE - auto-create transaction handler in constructor. FALSE - don't create</param>
	explicit CAtlTransactionManager(_In_ BOOL bFallback = TRUE, _In_ BOOL bAutoCreateTransaction = TRUE) :
		m_hTransaction(NULL), m_bFallback(bFallback)
	{
		if (bAutoCreateTransaction)
		{
			Create();
		}
	}

	/// <summary>
	/// CAtlTransactionManager destructor. In normal processing, the transaction is automatically committed and closed. If the destructor is called during an exception unwind, the transaction is rolled back and closed.</summary>
	~CAtlTransactionManager()
	{
		if (m_hTransaction != NULL)
		{
			if (__uncaught_exception())
			{
				Rollback();
			}
			else
			{
				Commit();
			}

			Close();
		}
	}

private:
	// Copy construction and copy are not supported, so make sure that the compiler does not generate
	// implicit versions and that a compiler error is issued if someone attempts to use them.
	CAtlTransactionManager(_In_ const CAtlTransactionManager &atm);
	CAtlTransactionManager &operator=(_In_ const CAtlTransactionManager &atm);

// Attributes:
public:
	/// <summary>
	/// Returns transaction handle</summary>
	/// <returns>
	/// Returns the transaction handle for a class. Returns NULL if the CAtlTransactionManager is not attached to a handle.</returns>
	HANDLE GetHandle() const
	{
		return m_hTransaction;
	}

	/// <summary>
	/// Determines whether the fallback calls are enabled </summary>
	/// <returns>
	/// Returns TRUE is the class support fallback calls. FALSE - otherwise.</returns>
	BOOL IsFallback() const
	{
		return m_bFallback;
	}

// Operattions:
public:
	/// <summary>
	/// Creates transaction handle. This wrapper calls Windows CreateTransaction function</summary>
	/// <returns>
	/// TRUE if succeeds; otherwise FALSE.</returns>
	BOOL Create();

	/// <summary>
	/// Closes transaction handle. This wrapper calls Windows CloseHandle function. The method is automatically called in destructor</summary>
	/// <returns>
	/// TRUE if succeeds; otherwise FALSE.</returns>
	BOOL Close();

	/// <summary>
	/// Requests that the transaction be committed. This wrapper calls Windows CommitTransaction function. The method is automatically called in destructor.</summary>
	/// <returns>
	/// TRUE if succeeds; otherwise FALSE.</returns>
	BOOL Commit();

	/// <summary>
	/// Requests that the transaction be rolled back. This wrapper calls Windows RollbackTransaction function</summary>
	/// <returns>
	/// TRUE if succeeds; otherwise FALSE.</returns>
	BOOL Rollback();

	/// <summary>
	/// Creates or opens a file, file stream, or directory as a transacted operation. This wrapper calls Windows CreateFileTransacted function</summary>
	/// <returns> 
	/// Returns a handle that can be used to access the object.</returns>
	/// <param name="lpFileName">The name of an object to be created or opened.</param>
	/// <param name="dwDesiredAccess">The access to the object, which can be summarized as read, write, both or neither (zero). The most commonly used values are GENERIC_READ, GENERIC_WRITE, or both (GENERIC_READ | GENERIC_WRITE).</param>
	/// <param name="dwShareMode">The sharing mode of an object, which can be read, write, both, delete, all of these, or none: 0, FILE_SHARE_DELETE, FILE_SHARE_READ, FILE_SHARE_WRITE</param>
	/// <param name="lpSecurityAttributes">A pointer to a SECURITY_ATTRIBUTES structure that contains an optional security descriptor and also determines whether or not the returned handle can be inherited by child processes. The parameter can be NULL</param>
	/// <param name="dwCreationDisposition">An action to take on files that exist and do not exist. This parameter must be one of the following values, which cannot be combined: CREATE_ALWAYS, CREATE_NEW, OPEN_ALWAYS, OPEN_EXISTING or TRUNCATE_EXISTING</param>
	/// <param name="dwFlagsAndAttributes">The file attributes and flags. This parameter can include any combination of the available file attributes (FILE_ATTRIBUTE_*). All other file attributes override FILE_ATTRIBUTE_NORMAL. This parameter can also contain combinations of flags (FILE_FLAG_*) for control of buffering behavior, access modes, and other special-purpose flags. These combine with any FILE_ATTRIBUTE_* values.</param>
	/// <param name="hTemplateFile">A valid handle to a template file with the GENERIC_READ access right. The template file supplies file attributes and extended attributes for the file that is being created. This parameter can be NULL.</param>
	HANDLE CreateFile(
		_In_z_ LPCTSTR lpFileName,
		_In_ DWORD dwDesiredAccess,
		_In_ DWORD dwShareMode,
		_In_opt_ LPSECURITY_ATTRIBUTES lpSecurityAttributes,
		_In_ DWORD dwCreationDisposition,
		_In_ DWORD dwFlagsAndAttributes,
		_In_opt_ HANDLE hTemplateFile);

	/// <summary>
	/// Deletes an existing file as a transacted operation. This wrapper calls Windows DeleteFileTransacted function</summary>
	/// <returns> 
	/// TRUE if succeeds; otherwise FALSE.</returns>
	/// <param name="lpFileName">The name of the file to be deleted.</param>
	BOOL DeleteFile(_In_z_ LPCTSTR lpFileName);

	/// <summary>
	/// Moves an existing file or a directory, including its children, as a transacted operation. This wrapper calls Windows MoveFileTransacted function</summary>
	/// <returns>
	/// TRUE if succeeds; otherwise FALSE.</returns>
	/// <param name="lpOldFileName">The current name of the existing file or directory on the local computer.</param>
	/// <param name="lpNewFileName">The new name for the file or directory. The new name must not already exist. A new file may be on a different file system or drive. A new directory must be on the same drive.</param>
	BOOL MoveFile(
		_In_z_ LPCTSTR lpOldFileName,
		_In_z_ LPCTSTR lpNewFileName);

	/// <summary>
	/// Retrieves file system attributes for a specified file or directory as a transacted operation. This wrapper calls Windows GetFileAttributesTransacted function</summary>
	/// <returns>
	/// File attributes (see WIN32_FILE_ATTRIBUTE_DATA::dwFileAttributes desciption).</returns>
	/// <param name="lpFileName">The name of the file or directory.</param>
	DWORD GetFileAttributes(_In_z_ LPCTSTR lpFileName);

	/// <summary>
	/// Retrieves file system attributes for a specified file or directory as a transacted operation. This wrapper calls Windows GetFileAttributesTransacted function</summary>
	/// <returns>
	/// TRUE if succeeds; otherwise FALSE.</returns>
	/// <param name="lpFileName">The name of the file or directory.</param>
	/// <param name="fInfoLevelId">The level of attribute information to retrieve.</param>
	/// <param name="lpFileInformation">A pointer to a buffer that receives the attribute information. The type of attribute information that is stored into this buffer is determined by the value of fInfoLevelId. If the fInfoLevelId parameter is GetFileExInfoStandard then this parameter points to a WIN32_FILE_ATTRIBUTE_DATA structure.</param>
	BOOL GetFileAttributesEx(
		_In_z_ LPCTSTR lpFileName,
		_In_ GET_FILEEX_INFO_LEVELS fInfoLevelId,
		_Out_ LPVOID lpFileInformation);

	/// <summary>
	/// Sets the attributes for a file or directory as a transacted operation. This wrapper calls Windows SetFileAttributesTransacted function</summary>
	/// <returns>
	/// TRUE if succeeds; otherwise FALSE.</returns>
	/// <param name="lpFileName">The name of the file or directory.</param>
	/// <param name="dwAttributes">The file attributes to set for the file. See SetFileAttributesTransacted function description</param>
	BOOL SetFileAttributes(
		_In_z_ LPCTSTR lpFileName,
		_In_ DWORD dwAttributes);

	/// <summary>
	/// Searches a directory for a file or subdirectory with a name that matches a specific name as a transacted operation. This wrapper calls Windows FindFirstFileTransacted function</summary>
	/// <returns> 
	/// If the function succeeds, the return value is a search handle used in a subsequent call to FindNextFile or FindClose. If the function fails or fails to locate files from the search string in the lpFileName parameter, the return value is INVALID_HANDLE_VALUE.</returns>
	/// <param name="lpFileName">The directory or path, and the file name, which can include wildcard characters, for example, an asterisk (*) or a question mark (?).</param>
	/// <param name="pNextInfo">A pointer to the WIN32_FIND_DATA structure that receives information about a found file or subdirectory.</param>
	HANDLE FindFirstFile(
		_In_z_ LPCTSTR lpFileName,
		_Out_ WIN32_FIND_DATA* pNextInfo);

	/// <summary>
	/// Creates the specified registry key and associates it with a transaction. If the key already exists, the function opens it. This wrapper calls Windows RegCreateKeyTransacted function</summary>
	/// <returns> 
	/// If the function succeeds, the return value is ERROR_SUCCESS. If the function fails, the return value is a nonzero error code defined in Winerror.h</returns>
	/// <param name="hKey">A handle to an open registry key.</param>
	/// <param name="lpSubKey">The name of a subkey that this function opens or creates.</param>
	/// <param name="dwReserved">This parameter is reserved and must be zero</param>
	/// <param name="ulOptions">This parameter can be one of the following values: REG_OPTION_BACKUP_RESTORE, REG_OPTION_NON_VOLATILE or REG_OPTION_VOLATILE.</param>
	/// <param name="samDesired">A mask that specifies the access rights for the key</param>
	/// <param name="lpSecurityAttributes"> pointer to a SECURITY_ATTRIBUTES structure that determines whether the returned handle can be inherited by child processes. If lpSecurityAttributes is NULL, the handle cannot be inherited</param>
	/// <param name="phkResult">A pointer to a variable that receives a handle to the opened or created key. If the key is not one of the predefined registry keys, call the RegCloseKey function after you have finished using the handle</param>
	/// <param name="lpdwDisposition">A pointer to a variable that receives one of the following disposition values: REG_CREATED_NEW_KEY or REG_OPENED_EXISTING_KEY</param>
	LSTATUS RegCreateKeyEx(
		_In_ HKEY hKey,
		_In_z_ LPCTSTR lpSubKey,
		_In_ DWORD dwReserved,
		_In_opt_z_ LPTSTR lpClass,
		_In_ DWORD dwOptions,
		_In_ REGSAM samDesired,
		_In_opt_ CONST LPSECURITY_ATTRIBUTES lpSecurityAttributes,
		_Out_ PHKEY phkResult,
		_Out_opt_ LPDWORD lpdwDisposition);
	/// <summary>
	/// Opens the specified registry key and associates it with a transaction. This wrapper calls Windows RegOpenKeyTransacted function</summary>
	/// <returns> 
	/// If the function succeeds, the return value is ERROR_SUCCESS. If the function fails, the return value is a nonzero error code defined in Winerror.h</returns>
	/// <param name="hKey">A handle to an open registry key.</param>
	/// <param name="lpSubKey">The name of the registry subkey to be opened.</param>
	/// <param name="ulOptions">This parameter is reserved and must be zero.</param>
	/// <param name="samDesired">A mask that specifies the access rights for the key</param>
	/// <param name="phkResult">A pointer to a variable that receives a handle to the opened or created key. If the key is not one of the predefined registry keys, call the RegCloseKey function after you have finished using the handle</param>
	LSTATUS RegOpenKeyEx(
		_In_ HKEY hKey,
		_In_opt_z_ LPCTSTR lpSubKey,
		_In_ DWORD ulOptions,
		_In_ REGSAM samDesired,
		_Out_ PHKEY phkResult);
	/// <summary>
	/// Deletes a subkey and its values from the specified platform-specific view of the registry as a transacted operation. This wrapper calls Windows RegDeleteKeyTransacted function</summary>
	/// <returns>
	/// If the function succeeds, the return value is ERROR_SUCCESS. If the function fails, the return value is a nonzero error code defined in Winerror.h</returns>
	/// <param name="hKey">A handle to an open registry key.</param>
	/// <param name="lpSubKey">The name of the key to be deleted.</param>
	LSTATUS RegDeleteKey(
		_In_ HKEY hKey,
		_In_z_ LPCTSTR lpSubKey);

protected:
	/// <summary>
	/// Transaction handle</summary>
	HANDLE m_hTransaction;

	/// <summary>
	/// TRUE: if the fallback is supported; FALSE - otherwise.</summary>
	BOOL   m_bFallback;
};

inline BOOL CAtlTransactionManager::Create()
{
	if (m_hTransaction != NULL)
	{
		// Already created
		ATLASSERT(FALSE);
		return FALSE;
	}

	typedef HANDLE (WINAPI* PFNCREATETRANSACTION)(LPSECURITY_ATTRIBUTES, LPGUID, DWORD, DWORD, DWORD, DWORD, LPWSTR);
	static bool bInitialized = false;
	static PFNCREATETRANSACTION pfCreateTransaction = NULL;

	if (!bInitialized)
	{
		HMODULE hKTM32 = LoadLibraryW(L"ktmw32.dll");
		if (hKTM32 != NULL)
		{
			pfCreateTransaction = (PFNCREATETRANSACTION)GetProcAddress(hKTM32, "CreateTransaction");
		}
		bInitialized = true;
	}

	if (pfCreateTransaction == NULL)
	{
		return FALSE;
	}

	SECURITY_ATTRIBUTES sa;
	ZeroMemory(&sa, sizeof(SECURITY_ATTRIBUTES));

	m_hTransaction = (*pfCreateTransaction)(&sa, 0, 0, 0, 0, 0, NULL);
	return m_hTransaction != NULL;
}

inline BOOL CAtlTransactionManager::Close()
{
	if (m_hTransaction == NULL)
	{
		return FALSE;
	}

	if (!::CloseHandle(m_hTransaction))
	{
		return FALSE;
	}

	m_hTransaction = NULL;
	return TRUE;
}

inline BOOL CAtlTransactionManager::Commit()
{
	if (m_hTransaction == NULL)
	{
		ATLASSERT(FALSE);
		return FALSE;
	}

	typedef BOOL (WINAPI* PFNCOMMITTRANSACTION)(HANDLE);
	static bool bInitialized = false;
	static PFNCOMMITTRANSACTION pfCommitTransaction = NULL;

	if (!bInitialized)
	{
		HMODULE hKTM32 = LoadLibraryW(L"ktmw32.dll");
		if (hKTM32 != NULL)
		{
			pfCommitTransaction = (PFNCOMMITTRANSACTION)GetProcAddress(hKTM32, "CommitTransaction");
		}
		bInitialized = true;
	}

	if (pfCommitTransaction != NULL)
	{
		return (*pfCommitTransaction)(m_hTransaction);
	}

	return FALSE;
}

inline BOOL CAtlTransactionManager::Rollback()
{
	if (m_hTransaction == NULL)
	{
		ATLASSERT(FALSE);
		return FALSE;
	}

	typedef BOOL (WINAPI* PFNROLLBACKTRANSACTION)(HANDLE);
	static bool bInitialized = false;
	static PFNROLLBACKTRANSACTION pfRollbackTransaction = NULL;

	if (!bInitialized)
	{
		HMODULE hKTM32 = LoadLibraryW(L"ktmw32.dll");
		if (hKTM32 != NULL)
		{
			pfRollbackTransaction = (PFNROLLBACKTRANSACTION)GetProcAddress(hKTM32, "RollbackTransaction");
		}
		bInitialized = true;
	}

	if (pfRollbackTransaction != NULL)
	{
		return (*pfRollbackTransaction)(m_hTransaction);
	}

	return FALSE;
}

inline HANDLE CAtlTransactionManager::CreateFile(
	_In_z_ LPCTSTR lpFileName,
	_In_ DWORD dwDesiredAccess,
	_In_ DWORD dwShareMode,
	_In_opt_ LPSECURITY_ATTRIBUTES lpSecurityAttributes,
	_In_ DWORD dwCreationDisposition,
	_In_ DWORD dwFlagsAndAttributes,
	_In_opt_ HANDLE hTemplateFile)
{
	if (m_hTransaction != NULL)
	{
		HMODULE hKernel32 = ::GetModuleHandle(_T("kernel32.dll"));
		ATLASSERT(hKernel32 != NULL);
		if (hKernel32 == NULL)
		{
			return INVALID_HANDLE_VALUE;
		}

#ifdef _UNICODE
		typedef HANDLE (WINAPI* PFNCREATEFILETRANSACTED)(LPCWSTR, DWORD, DWORD, LPSECURITY_ATTRIBUTES, DWORD, DWORD, HANDLE, HANDLE, PUSHORT, PVOID);
		PFNCREATEFILETRANSACTED pfCreateTransacted = (PFNCREATEFILETRANSACTED)GetProcAddress(hKernel32, "CreateFileTransactedW");
#else
		typedef HANDLE (WINAPI* PFNCREATEFILETRANSACTED)(LPCSTR, DWORD, DWORD, LPSECURITY_ATTRIBUTES, DWORD, DWORD, HANDLE, HANDLE, PUSHORT, PVOID);
		PFNCREATEFILETRANSACTED pfCreateTransacted = (PFNCREATEFILETRANSACTED)GetProcAddress(hKernel32, "CreateFileTransactedA");
#endif
		if (pfCreateTransacted != NULL)
		{
			return (*pfCreateTransacted)(lpFileName, dwDesiredAccess, dwShareMode, lpSecurityAttributes, dwCreationDisposition, dwFlagsAndAttributes, hTemplateFile, m_hTransaction, NULL, NULL);
		}
	}
	else if (m_bFallback)
	{
		return ::CreateFile((LPCTSTR)lpFileName, dwDesiredAccess, dwShareMode, lpSecurityAttributes, dwCreationDisposition, dwFlagsAndAttributes, NULL);
	}

	return INVALID_HANDLE_VALUE;
}

inline BOOL CAtlTransactionManager::DeleteFile(_In_z_ LPCTSTR lpFileName)
{
	if (m_hTransaction != NULL)
	{
		HMODULE hKernel32 = ::GetModuleHandle(_T("kernel32.dll"));
		ATLASSERT(hKernel32 != NULL);
		if (hKernel32 == NULL)
		{
			return FALSE;
		}

#ifdef _UNICODE
		typedef BOOL (WINAPI* PFNDELETEFILETRANSACTED)(LPCWSTR, HANDLE);
		PFNDELETEFILETRANSACTED pfDeleteTransacted = (PFNDELETEFILETRANSACTED)GetProcAddress(hKernel32, "DeleteFileTransactedW");
#else
		typedef BOOL (WINAPI* PFNDELETEFILETRANSACTED)(LPCSTR, HANDLE);
		PFNDELETEFILETRANSACTED pfDeleteTransacted = (PFNDELETEFILETRANSACTED)GetProcAddress(hKernel32, "DeleteFileTransactedA");
#endif
		if (pfDeleteTransacted != NULL)
		{
			return (*pfDeleteTransacted)(lpFileName, m_hTransaction);
		}
	}
	else if (m_bFallback)
	{
		return ::DeleteFile((LPTSTR)lpFileName);
	}

	return FALSE;
}

inline BOOL CAtlTransactionManager::MoveFile(
	_In_z_ LPCTSTR lpOldFileName,
	_In_z_ LPCTSTR lpNewFileName)
{
	if (m_hTransaction != NULL)
	{
		HMODULE hKernel32 = ::GetModuleHandle(_T("kernel32.dll"));
		ATLASSERT(hKernel32 != NULL);
		if (hKernel32 == NULL)
		{
			return FALSE;
		}

#ifdef _UNICODE
		typedef BOOL (WINAPI* PFNMOVEFILETRANSACTED)(LPCWSTR, LPCWSTR, LPPROGRESS_ROUTINE, LPVOID, DWORD, HANDLE);
		PFNMOVEFILETRANSACTED pfMoveFileTransacted = (PFNMOVEFILETRANSACTED)GetProcAddress(hKernel32, "MoveFileTransactedW");
#else
		typedef BOOL (WINAPI* PFNMOVEFILETRANSACTED)(LPCSTR, LPCSTR, LPPROGRESS_ROUTINE, LPVOID, DWORD, HANDLE);
		PFNMOVEFILETRANSACTED pfMoveFileTransacted = (PFNMOVEFILETRANSACTED)GetProcAddress(hKernel32, "MoveFileTransactedA");
#endif
		if (pfMoveFileTransacted != NULL)
		{
			return (*pfMoveFileTransacted)(lpOldFileName, lpNewFileName, NULL, NULL, MOVEFILE_COPY_ALLOWED, m_hTransaction);
		}
	}
	else if (m_bFallback)
	{
		return ::MoveFile(lpOldFileName, lpNewFileName);
	}

	return FALSE;
}

inline BOOL CAtlTransactionManager::GetFileAttributesEx(
	_In_z_ LPCTSTR lpFileName,
	_In_ GET_FILEEX_INFO_LEVELS fInfoLevelId,
	_Out_ LPVOID lpFileInformation)
{
	if (m_hTransaction != NULL)
	{
		HMODULE hKernel32 = ::GetModuleHandle(_T("kernel32.dll"));
		ATLASSERT(hKernel32 != NULL);
		if (hKernel32 == NULL)
		{
			return FALSE;
		}

#ifdef _UNICODE
		typedef BOOL (WINAPI* PFNGETFILEATTRIBUTESTRANSACTED)(LPCWSTR, GET_FILEEX_INFO_LEVELS, LPVOID, HANDLE);
		PFNGETFILEATTRIBUTESTRANSACTED pfGetFileAttributesTransacted = (PFNGETFILEATTRIBUTESTRANSACTED)GetProcAddress(hKernel32, "GetFileAttributesTransactedW");
#else
		typedef BOOL (WINAPI* PFNGETFILEATTRIBUTESTRANSACTED)(LPCSTR, GET_FILEEX_INFO_LEVELS, LPVOID, HANDLE);
		PFNGETFILEATTRIBUTESTRANSACTED pfGetFileAttributesTransacted = (PFNGETFILEATTRIBUTESTRANSACTED)GetProcAddress(hKernel32, "GetFileAttributesTransactedA");
#endif
		if (pfGetFileAttributesTransacted != NULL)
		{
			return (*pfGetFileAttributesTransacted)(lpFileName, fInfoLevelId, lpFileInformation, m_hTransaction);
		}
	}
	else if (m_bFallback)
	{
		return ::GetFileAttributesEx((LPCTSTR)lpFileName, fInfoLevelId, lpFileInformation);
	}

	return FALSE;
}

inline DWORD CAtlTransactionManager::GetFileAttributes(_In_z_ LPCTSTR lpFileName)
{
	WIN32_FILE_ATTRIBUTE_DATA fileAttributeData;
	if (GetFileAttributesEx(lpFileName, GetFileExInfoStandard, &fileAttributeData))
	{
		return fileAttributeData.dwFileAttributes;
	}

	return 0;
}

inline BOOL CAtlTransactionManager::SetFileAttributes(
	_In_z_ LPCTSTR lpFileName,
	_In_ DWORD dwAttributes)
{
	if (m_hTransaction != NULL)
	{
		HMODULE hKernel32 = ::GetModuleHandle(_T("kernel32.dll"));
		ATLASSERT(hKernel32 != NULL);
		if (hKernel32 == NULL)
		{
			return FALSE;
		}

#ifdef _UNICODE
		typedef BOOL (WINAPI* PFNSETFILEATTRIBUTESTRANSACTED)(LPCWSTR, DWORD, HANDLE);
		PFNSETFILEATTRIBUTESTRANSACTED pfSetFileAttributesTransacted = (PFNSETFILEATTRIBUTESTRANSACTED)GetProcAddress(hKernel32, "SetFileAttributesTransactedW");
#else
		typedef BOOL (WINAPI* PFNSETFILEATTRIBUTESTRANSACTED)(LPCSTR, DWORD, HANDLE);
		PFNSETFILEATTRIBUTESTRANSACTED pfSetFileAttributesTransacted = (PFNSETFILEATTRIBUTESTRANSACTED)GetProcAddress(hKernel32, "SetFileAttributesTransactedA");
#endif
		if (pfSetFileAttributesTransacted != NULL)
		{
			return (*pfSetFileAttributesTransacted)(lpFileName, dwAttributes, m_hTransaction);
		}
	}
	else if (m_bFallback)
	{
		return ::SetFileAttributes((LPCTSTR)lpFileName, dwAttributes);
	}

	return FALSE;
}

inline HANDLE CAtlTransactionManager::FindFirstFile(
	_In_z_ LPCTSTR lpFileName,
	_Out_ WIN32_FIND_DATA* pNextInfo)
{
	if (m_hTransaction != NULL)
	{
		HMODULE hKernel32 = ::GetModuleHandle(_T("kernel32.dll"));
		ATLASSERT(hKernel32 != NULL);
		if (hKernel32 == NULL)
		{
			return INVALID_HANDLE_VALUE;
		}

#ifdef _UNICODE
		typedef HANDLE (WINAPI* PFNFINDFIRSTFILETRANSACTED)(LPCWSTR, FINDEX_INFO_LEVELS, LPVOID, FINDEX_SEARCH_OPS, LPVOID, DWORD, HANDLE);
		PFNFINDFIRSTFILETRANSACTED pfFindFirstFileTransacted = (PFNFINDFIRSTFILETRANSACTED)GetProcAddress(hKernel32, "FindFirstFileTransactedW");
#else
		typedef HANDLE (WINAPI* PFNFINDFIRSTFILETRANSACTED)(LPCSTR, FINDEX_INFO_LEVELS, LPVOID, FINDEX_SEARCH_OPS, LPVOID, DWORD, HANDLE);
		PFNFINDFIRSTFILETRANSACTED pfFindFirstFileTransacted = (PFNFINDFIRSTFILETRANSACTED)GetProcAddress(hKernel32, "FindFirstFileTransactedA");
#endif
		if (pfFindFirstFileTransacted != NULL)
		{
			return (*pfFindFirstFileTransacted)(lpFileName, FindExInfoStandard, pNextInfo, FindExSearchNameMatch, NULL, 0, m_hTransaction);
		}
	}
	else if (m_bFallback)
	{
		return ::FindFirstFile(lpFileName, pNextInfo);
	}

	return INVALID_HANDLE_VALUE;
}

inline LSTATUS CAtlTransactionManager::RegOpenKeyEx(
	_In_ HKEY hKey,
	_In_opt_z_ LPCTSTR lpSubKey,
	_In_ DWORD ulOptions,
	_In_ REGSAM samDesired,
	_Out_ PHKEY phkResult)
{
	if (m_hTransaction != NULL)
	{
		HMODULE hAdvAPI32 = ::GetModuleHandle(_T("Advapi32.dll"));
		ATLASSERT(hAdvAPI32 != NULL);
		if (hAdvAPI32 == NULL)
		{
			return ERROR_INVALID_FUNCTION;
		}

#ifdef _UNICODE
		typedef LSTATUS (WINAPI* PFNREGOPENKEYTRANSACTED)(HKEY, LPCWSTR, DWORD, REGSAM, PHKEY, HANDLE, PVOID);
		PFNREGOPENKEYTRANSACTED pfRegOpenKeyTransacted = (PFNREGOPENKEYTRANSACTED)GetProcAddress(hAdvAPI32, "RegOpenKeyTransactedW");
#else
		typedef LSTATUS (WINAPI* PFNREGOPENKEYTRANSACTED)(HKEY, LPCSTR, DWORD, REGSAM, PHKEY, HANDLE, PVOID);
		PFNREGOPENKEYTRANSACTED pfRegOpenKeyTransacted = (PFNREGOPENKEYTRANSACTED)GetProcAddress(hAdvAPI32, "RegOpenKeyTransactedA");
#endif
		if (pfRegOpenKeyTransacted != NULL)
		{
			return (*pfRegOpenKeyTransacted)(hKey, lpSubKey, ulOptions, samDesired, phkResult, m_hTransaction, NULL);
		}
	}
	else if (m_bFallback)
	{
		return ::RegOpenKeyEx(hKey, lpSubKey, ulOptions, samDesired, phkResult);
	}

	return ERROR_INVALID_FUNCTION;
}

inline LSTATUS CAtlTransactionManager::RegCreateKeyEx(
	_In_ HKEY hKey,
	_In_z_ LPCTSTR lpSubKey,
	_In_ DWORD dwReserved,
	_In_opt_z_ LPTSTR lpClass,
	_In_ DWORD dwOptions,
	_In_ REGSAM samDesired,
	_In_opt_ CONST LPSECURITY_ATTRIBUTES lpSecurityAttributes,
	_Out_ PHKEY phkResult,
	_Out_opt_ LPDWORD lpdwDisposition)
{
	if (m_hTransaction != NULL)
	{
		HMODULE hAdvAPI32 = ::GetModuleHandle(_T("Advapi32.dll"));
		ATLASSERT(hAdvAPI32 != NULL);
		if (hAdvAPI32 == NULL)
		{
			return ERROR_INVALID_FUNCTION;
		}

#ifdef _UNICODE
		typedef LSTATUS (WINAPI* PFNREGCREATEKEYTRANSACTED)(HKEY, LPCWSTR, DWORD, LPWSTR, DWORD, REGSAM, CONST LPSECURITY_ATTRIBUTES, PHKEY, LPDWORD, HANDLE, PVOID);
		PFNREGCREATEKEYTRANSACTED pfRegCreateKeyTransacted = (PFNREGCREATEKEYTRANSACTED)GetProcAddress(hAdvAPI32, "RegCreateKeyTransactedW");
#else
		typedef LSTATUS (WINAPI* PFNREGCREATEKEYTRANSACTED)(HKEY, LPCSTR, DWORD, LPSTR, DWORD, REGSAM, CONST LPSECURITY_ATTRIBUTES, PHKEY, LPDWORD, HANDLE, PVOID);
		PFNREGCREATEKEYTRANSACTED pfRegCreateKeyTransacted = (PFNREGCREATEKEYTRANSACTED)GetProcAddress(hAdvAPI32, "RegCreateKeyTransactedA");
#endif
		if (pfRegCreateKeyTransacted != NULL)
		{
			return (*pfRegCreateKeyTransacted)(hKey, lpSubKey, dwReserved, lpClass, dwOptions, samDesired, lpSecurityAttributes, phkResult, lpdwDisposition, m_hTransaction, NULL);
		}
	}
	else if (m_bFallback)
	{
		return ::RegCreateKeyEx(hKey, lpSubKey, dwReserved, lpClass, dwOptions, samDesired, lpSecurityAttributes, phkResult, lpdwDisposition);
	}

	return ERROR_INVALID_FUNCTION;
}

inline LSTATUS CAtlTransactionManager::RegDeleteKey(_In_ HKEY hKey, _In_z_ LPCTSTR lpSubKey)
{
	if (m_hTransaction != NULL)
	{
		HMODULE hAdvAPI32 = ::GetModuleHandle(_T("Advapi32.dll"));
		ATLASSERT(hAdvAPI32 != NULL);
		if (hAdvAPI32 == NULL)
		{
			return ERROR_INVALID_FUNCTION;
		}

#ifdef _UNICODE
		typedef LSTATUS (WINAPI* PFNREGDELETEKEYTRANSACTED)(HKEY, LPCWSTR, REGSAM, DWORD, HANDLE, PVOID);
		PFNREGDELETEKEYTRANSACTED pfRegDeleteKeyTransacted = (PFNREGDELETEKEYTRANSACTED)GetProcAddress(hAdvAPI32, "RegDeleteKeyTransactedW");
#else
		typedef LSTATUS (WINAPI* PFNREGDELETEKEYTRANSACTED)(HKEY, LPCSTR, REGSAM, DWORD, HANDLE, PVOID);
		PFNREGDELETEKEYTRANSACTED pfRegDeleteKeyTransacted = (PFNREGDELETEKEYTRANSACTED)GetProcAddress(hAdvAPI32, "RegDeleteKeyTransactedA");
#endif
		if (pfRegDeleteKeyTransacted != NULL)
		{
			return (*pfRegDeleteKeyTransacted)(hKey, lpSubKey, 0, 0, m_hTransaction, NULL);
		}
	}
	else if (m_bFallback)
	{
		return ::RegDeleteKey(hKey, lpSubKey);
	}

	return ERROR_INVALID_FUNCTION;
}

} //namespace ATL
#pragma pack(pop)

#endif // __ATLTRANSACTIONMANAGER_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\include\atlxml.h ===
// This is a part of the Active Template Library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Active Template Library Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Active Template Library product.

#ifndef __ATLXML_H__
#define __ATLXML_H__

#pragma once

#include <msxml2.h>

#pragma warning (push)
#pragma pack(push,_ATL_PACKING)

#define IF_NOT_VALID_RETURN_EPTR if (!IsValid()) { return E_POINTER; }
#define HR_SUCCEEDED_OK(hr) (SUCCEEDED(hr) && hr == S_OK)
#define IF_HR_INVALID_RETURN_HR(hr) if (!HR_SUCCEEDED_OK(hr)) { return hr; }
#define IF_HR_INVALID_RETURN_BOOL(hr) if (!SUCCEEDED(hr) || hr == S_FALSE) { return FALSE; }
#define IF_NULL_RETURN_INVALID(ptr) if (ptr == NULL) { return E_INVALIDARG; }

namespace ATL
{

class CXMLDocument;

template<class T>
class CXMLNode
{
public:
	CXMLNode()
	{
	}
	CXMLNode(_In_ T* node) : m_pNode(node)
	{
	}
	CXMLNode(_In_ CXMLNode<T>& node) : m_pNode(node)
	{
	}
	virtual ~CXMLNode()
	{
	}

	inline BOOL IsValid() const
	{
		return m_pNode != NULL;
	}

	HRESULT GetNodeType(_Out_ DOMNodeType& val)
	{
		IF_NOT_VALID_RETURN_EPTR;

		return Get()->get_nodeType(&val);
	}

	HRESULT GetNodeName(_Inout_ CString& strName)
	{
		IF_NOT_VALID_RETURN_EPTR;

		BSTR bstr = NULL;
		HRESULT hr = Get()->get_nodeName(&bstr);
		if (HR_SUCCEEDED_OK(hr))
		{
			strName = CStringW(bstr);
		}

		if (bstr != NULL)
		{
			::SysFreeString(bstr);
		}

		return hr;
	}

	HRESULT GetXML(_Inout_ CString& strXML)
	{
		IF_NOT_VALID_RETURN_EPTR;

		BSTR bstr = NULL;
		HRESULT hr = Get()->get_xml(&bstr);
		if (HR_SUCCEEDED_OK(hr))
		{
			strXML = CStringW(bstr);
		}

		if (bstr != NULL)
		{
			::SysFreeString(bstr);
		}

		return hr;
	}

	HRESULT GetName(_Inout_ CString& strName)
	{
		IF_NOT_VALID_RETURN_EPTR;

		BSTR bstr = NULL;
		HRESULT hr = Get()->get_baseName(&bstr);
		if (HR_SUCCEEDED_OK(hr))
		{
			strName = CStringW(bstr);
		}

		if (bstr != NULL)
		{
			::SysFreeString(bstr);
		}

		return hr;
	}

	HRESULT GetText(_Inout_ CString& strText)
	{
		IF_NOT_VALID_RETURN_EPTR;

		BSTR bstr = NULL;
		HRESULT hr = Get()->get_text(&bstr);
		if (HR_SUCCEEDED_OK(hr))
		{
			strText = CStringW(bstr);
		}

		if (bstr != NULL)
		{
			::SysFreeString(bstr);
		}

		return hr;
	}

	HRESULT GetOwnerDocument(_Inout_ CXMLDocument& document)
	{
		IF_NOT_VALID_RETURN_EPTR;

		return Get()->get_ownerDocument(document);
	}

	HRESULT GetParentNode(_Inout_ CXMLNode<IXMLDOMNode>& node)
	{
		IF_NOT_VALID_RETURN_EPTR;

		return Get()->get_parentNode(node);
	}

	HRESULT AppendChild(_In_ IXMLDOMNode* child)
	{
		IF_NOT_VALID_RETURN_EPTR;
		IF_NULL_RETURN_INVALID(child);

		CXMLNode<IXMLDOMNode> node;
		HRESULT hr = Get()->appendChild(child, node);

		return hr;
	}

	HRESULT SelectNode(
		_In_z_ LPCTSTR pszSelect,
		_Inout_ CXMLNode<IXMLDOMNode>& node)
	{
		IF_NOT_VALID_RETURN_EPTR;
		IF_NULL_RETURN_INVALID(pszSelect);

		CString strSelect = pszSelect;
		BSTR bstrSelect = strSelect.AllocSysString();
		HRESULT hr = Get()->selectSingleNode(bstrSelect, node);
		::SysFreeString(bstrSelect);

		return hr;
	}

	HRESULT SelectNodes(
		_In_z_ LPCTSTR pszSelect,
		_Deref_out_opt_ IXMLDOMNodeList** nodes)
	{
		IF_NOT_VALID_RETURN_EPTR;
		IF_NULL_RETURN_INVALID(pszSelect);
		IF_NULL_RETURN_INVALID(nodes);

		CString strSelect = pszSelect;
		BSTR bstrSelect = strSelect.AllocSysString();
		HRESULT hr = Get()->selectNodes(bstrSelect, nodes);
		::SysFreeString(bstrSelect);

		return hr;
	}

	HRESULT HasChildren(_Out_ BOOL& bHasChildren)
	{
		IF_NOT_VALID_RETURN_EPTR;

		bHasChildren = FALSE;

		VARIANT_BOOL var = VARIANT_FALSE;
		HRESULT hr = Get()->hasChildNodes(&var);
		if (HR_SUCCEEDED_OK(hr))
		{
			bHasChildren = (BOOL)(var == VARIANT_TRUE);
		}

		return hr;
	}

	HRESULT GetFirstChild(_Inout_ CXMLNode<IXMLDOMNode>& child)
	{
		IF_NOT_VALID_RETURN_EPTR;

		return Get()->get_firstChild(child);
	}

	HRESULT GetLastChild(_Inout_ CXMLNode<IXMLDOMNode>& child)
	{
		IF_NOT_VALID_RETURN_EPTR;

		return Get()->get_lastChild(child);
	}

	HRESULT GetPrevSibling(_Inout_ CXMLNode<IXMLDOMNode>& sibling)
	{
		IF_NOT_VALID_RETURN_EPTR;

		return Get()->get_previousSibling(sibling);
	}

	HRESULT GetNextSibling(_Inout_ CXMLNode<IXMLDOMNode>& sibling)
	{
		IF_NOT_VALID_RETURN_EPTR;

		return Get()->get_nextSibling(sibling);
	}

	inline operator T* ()
	{
		return (T*)m_pNode;
	}
	inline operator T** ()
	{
		return &m_pNode;
	}
	inline CComQIPtr<T>& Get()
	{
		return m_pNode;
	}

private:
	CComQIPtr<T> m_pNode;
};

class CXMLDocument : 
	public CXMLNode<IXMLDOMDocument>
{
public:
	CXMLDocument()
	{
		EmptyErrorInfo();
		m_bComInitialized = FALSE;
	}
	virtual ~CXMLDocument()
	{
		if (m_bComInitialized)
		{
			CoUninitialize();
		}
	}

	HRESULT Create(
		_In_z_ LPCTSTR pszVersion,
		_In_z_ LPCTSTR pszEncoding,
		_In_ BOOL bStandalone,
		_In_z_ LPCTSTR pszRoot)
	{
		EmptyErrorInfo();
		IF_NULL_RETURN_INVALID(pszVersion);

		HRESULT hr = Initialize();
		if (!SUCCEEDED(hr))
		{
			return hr;
		}

		CXMLNode<IXMLDOMProcessingInstruction> proc;

		CString strData(_T("version=\""));
		CString strVersion = pszVersion;
		strData += strVersion + _T("\"");

		if (pszEncoding != NULL)
		{
			CString strEncoding = pszEncoding;
			CString strStandalone = bStandalone ? _T("\"yes\"") : _T("\"no\"");
			strData += _T(" encoding=\"") + strEncoding + _T("\" standalone=" + strStandalone);
		}

		BSTR bstr1 = T2BSTR(_T("xml"));
		BSTR bstr2 = strData.AllocSysString();

		hr = Get()->createProcessingInstruction(bstr1, bstr2, proc);

		::SysFreeString(bstr1);
		::SysFreeString(bstr2);

		IF_HR_INVALID_RETURN_HR(hr);

		hr = AppendChild(proc);
		IF_HR_INVALID_RETURN_HR(hr);

		if (pszRoot != NULL)
		{
			CXMLNode<IXMLDOMElement> root;
			hr = CreateElement(pszRoot, root);
			IF_HR_INVALID_RETURN_HR(hr);

			hr = AppendChild(root);
			IF_HR_INVALID_RETURN_HR(hr);
		}

		return hr;
	}

	HRESULT Load(_In_z_ LPCTSTR pszFile)
	{
		EmptyErrorInfo();
		IF_NULL_RETURN_INVALID(pszFile);

		HRESULT hr = Initialize();
		IF_HR_INVALID_RETURN_HR(hr);
		IF_NOT_VALID_RETURN_EPTR;

		CString strFile = pszFile;
		VARIANT_BOOL varBool = VARIANT_FALSE;
		VARIANT var;
		V_VT(&var) = VT_BSTR;
		V_BSTR(&var) = strFile.AllocSysString();

		hr = Get()->load(var, &varBool);

		::VariantClear(&var);

		if (HR_SUCCEEDED_OK(hr) && varBool == VARIANT_FALSE)
		{
			hr = S_FALSE;
		}

		if (!HR_SUCCEEDED_OK(hr))
		{
			UpdateErrorInfo();

			return hr;
		}

		return PostLoad();
	}

	HRESULT Load(_Inout_ IStream* pStream)
	{
		EmptyErrorInfo();
		IF_NULL_RETURN_INVALID(pStream);

		HRESULT hr = Initialize();
		IF_HR_INVALID_RETURN_HR(hr);
		IF_NOT_VALID_RETURN_EPTR;

		VARIANT_BOOL varBool = VARIANT_FALSE;
		VARIANT var;
		V_VT(&var) = VT_UNKNOWN;
		V_UNKNOWN(&var) = pStream;
		V_UNKNOWN(&var)->AddRef();

		hr = Get()->load(var, &varBool);

		::VariantClear(&var);

		if (HR_SUCCEEDED_OK(hr) && varBool == VARIANT_FALSE)
		{
			hr = S_FALSE;
		}

		if (!HR_SUCCEEDED_OK(hr))
		{
			UpdateErrorInfo();

			return hr;
		}

		return PostLoad();
	}

	HRESULT Load(
		_In_bytecount_(size) LPBYTE lpBuffer,
		_In_ UINT size)
	{
		EmptyErrorInfo();
		IF_NULL_RETURN_INVALID(lpBuffer);
		IF_NULL_RETURN_INVALID(size);

		HRESULT hr = Initialize();
		IF_HR_INVALID_RETURN_HR(hr);
		IF_NOT_VALID_RETURN_EPTR;

		hr = E_FAIL;

		HGLOBAL hGlobal = ::GlobalAlloc(GHND, size);
		if (hGlobal != NULL)
		{
			LPVOID lpVoid = ::GlobalLock(hGlobal);

			if (lpVoid != NULL)
			{
ATLPREFAST_SUPPRESS(6386)
				memcpy(lpVoid, lpBuffer, size);
ATLPREFAST_UNSUPPRESS()
					
				::GlobalUnlock(hGlobal);

				IStream* pStream = NULL;
				if (SUCCEEDED(::CreateStreamOnHGlobal(hGlobal, FALSE, &pStream)))
				{
					hr = Load(pStream);
				}

				if (pStream != NULL)
				{
					pStream->Release();
				}
			}

			::GlobalFree(hGlobal);
		}

		return hr;
	}

	HRESULT LoadXML(_In_z_ LPCTSTR pszXML)
	{
		EmptyErrorInfo();
		IF_NULL_RETURN_INVALID(pszXML);

		HRESULT hr = Initialize();
		IF_HR_INVALID_RETURN_HR(hr);
		IF_NOT_VALID_RETURN_EPTR;

		VARIANT_BOOL varBool = VARIANT_FALSE;
		CString strXML = pszXML;
		BSTR bstr = strXML.AllocSysString();
		hr = Get()->loadXML(bstr, &varBool);
		::SysFreeString(bstr);

		if (HR_SUCCEEDED_OK(hr) && varBool == VARIANT_FALSE)
		{
			hr = S_FALSE;
		}

		if (!HR_SUCCEEDED_OK(hr))
		{
			UpdateErrorInfo();

			return hr;
		}

		return PostLoad();
	}

	HRESULT Save(_In_z_ LPCTSTR pszFile)
	{
		IF_NOT_VALID_RETURN_EPTR;
		IF_NULL_RETURN_INVALID(pszFile);

		CString strFile = pszFile;
		VARIANT var;
		V_VT(&var) = VT_BSTR;
		V_BSTR(&var) = strFile.AllocSysString();

		HRESULT hr = Get()->save(var);

		::VariantClear(&var);

		return hr;
	}

	HRESULT Save(_Inout_ IStream* pStream)
	{
		IF_NOT_VALID_RETURN_EPTR;
		IF_NULL_RETURN_INVALID(pStream);

		VARIANT var;
		V_VT(&var) = VT_UNKNOWN;
		V_UNKNOWN(&var) = pStream;
		V_UNKNOWN(&var)->AddRef();

		HRESULT hr = Get()->save(var);

		::VariantClear(&var);

		return hr;
	}

	HRESULT Save(
		_Out_ _Deref_post_opt_cap_(size) LPBYTE* lpBuffer,
		_Out_ UINT& size)
	{
		IF_NOT_VALID_RETURN_EPTR;
		IF_NULL_RETURN_INVALID(lpBuffer);

		size = 0;
		*lpBuffer = NULL;

		HRESULT hr = E_FAIL;

		HGLOBAL hGlobal = ::GlobalAlloc(GHND, 0);
		if (hGlobal != NULL)
		{
			IStream* pStream = NULL;
			if (SUCCEEDED(::CreateStreamOnHGlobal(hGlobal, FALSE, &pStream)))
			{
				if (SUCCEEDED(Save(pStream)))
				{
					STATSTG stat = {0};
					pStream->Stat(&stat, STATFLAG_NONAME);
					size = (UINT)stat.cbSize.QuadPart;
					if (size > 0)
					{
						*lpBuffer = new BYTE[size];
						LARGE_INTEGER dlibMove = {0};
						pStream->Seek(dlibMove, STREAM_SEEK_SET, NULL);
						pStream->Read(*lpBuffer, size, NULL);

						hr = S_OK;
					}
				}
			}

			if (pStream != NULL)
			{
				pStream->Release();
			}

			::GlobalFree(hGlobal);
		}

		return hr;
	}

	HRESULT CreateElement(
		_In_z_ LPCTSTR pszName,
		_Inout_ CXMLNode<IXMLDOMElement>& val)
	{
		IF_NOT_VALID_RETURN_EPTR;

		CString strName = pszName;
		BSTR bstr = strName.AllocSysString();
		HRESULT hr = Get()->createElement(bstr, val);
		::SysFreeString(bstr);

		return hr;
	}

	HRESULT CreateText(
		_In_z_ LPCTSTR pszText,
		_Inout_ CXMLNode<IXMLDOMText>& val)
	{
		IF_NOT_VALID_RETURN_EPTR;

		CString strText = pszText;
		BSTR bstr = strText.AllocSysString();
		HRESULT hr = Get()->createTextNode(bstr, val);
		::SysFreeString(bstr);

		return hr;
	}

	HRESULT CreateElementWithText(
		_In_z_ LPCTSTR pszName,
		_In_z_ LPCTSTR pszText,
		_Inout_ CXMLNode<IXMLDOMElement>& node)
	{
		IF_NOT_VALID_RETURN_EPTR;

		HRESULT hr = CreateElement(pszName, node);
		IF_HR_INVALID_RETURN_HR(hr);

		CXMLNode<IXMLDOMText> element;
		hr = CreateText(pszText, element);
		IF_HR_INVALID_RETURN_HR(hr);

		return node.AppendChild(element);
	}

	HRESULT GetDocumentElement(_Inout_ CXMLNode<IXMLDOMElement>& document)
	{
		IF_NOT_VALID_RETURN_EPTR;

		return Get()->get_documentElement(document);
	}

	const CString& GetErrorReason() const
	{
		return m_strErrorReason;
	}
	long GetErrorLine() const
	{
		return m_nErrorLine;
	}
	long GetErrorLinePos() const
	{
		return m_nErrorLinePos;
	}

protected:
	_Check_return_ HRESULT Initialize()
	{
		if (IsValid())
		{
			return S_OK;
		}

		HRESULT hr = CoInitialize(NULL);

		if (SUCCEEDED(hr))
		{
			m_bComInitialized = TRUE;

			hr = Get().CoCreateInstance(CLSID_DOMDocument30, NULL, CLSCTX_INPROC_SERVER);
			IF_HR_INVALID_RETURN_HR(hr);

			hr = Get()->put_async(VARIANT_FALSE);

			if (SUCCEEDED(hr))
			{
				hr = Get()->put_validateOnParse(VARIANT_FALSE);
			}

			if (SUCCEEDED(hr))
			{
				hr = Get()->put_resolveExternals(VARIANT_FALSE);
			}

			if (SUCCEEDED(hr))
			{
				hr = Get()->put_preserveWhiteSpace(VARIANT_TRUE);
			}

			if (FAILED(hr))
			{
				Get().Release();
			}
		}

		return hr;
	}

	HRESULT PostLoad()
	{
		IF_NOT_VALID_RETURN_EPTR;

		CComQIPtr<IXMLDOMDocument2> doc2;
		HRESULT hr = Get()->QueryInterface(&doc2);

		IF_HR_INVALID_RETURN_HR(hr);

		BSTR bstr = T2BSTR(_T("SelectionLanguage"));
		VARIANT var;
		V_VT(&var) = VT_BSTR;
		V_BSTR(&var) = T2BSTR(_T("XPath"));

		hr = doc2->setProperty(bstr, var);

		::SysFreeString(bstr);
		::VariantClear(&var);

		return hr;
	}

	HRESULT UpdateErrorInfo()
	{
		IF_NOT_VALID_RETURN_EPTR;

		EmptyErrorInfo();

		CComPtr<IXMLDOMParseError> pXMLErr;
		HRESULT hr = Get()->get_parseError(&pXMLErr);

		IF_HR_INVALID_RETURN_HR(hr);

		BSTR bstrErr = NULL;
		if (SUCCEEDED(pXMLErr->get_reason(&bstrErr)))
		{
			m_strErrorReason = CStringW(bstrErr);
		}
		if (bstrErr)
		{
			::SysFreeString(bstrErr);
		}

		if (!SUCCEEDED(pXMLErr->get_line(&m_nErrorLine)))
		{
			m_nErrorLine = 1;
		}

		if (!SUCCEEDED(pXMLErr->get_linepos(&m_nErrorLinePos)))
		{
			m_nErrorLinePos = 1;
		}

		return hr;
	}

	void EmptyErrorInfo()
	{
		m_strErrorReason.Empty();
		m_nErrorLine    = -1;
		m_nErrorLinePos = -1;
	}

protected:
	CString m_strErrorReason;
	long    m_nErrorLine;
	long    m_nErrorLinePos;
	BOOL    m_bComInitialized;
};

}	// namespace ATL

#pragma pack(pop)
#pragma warning (pop)

#ifndef _ATL_NO_AUTOMATIC_NAMESPACE
using namespace ATL;
#endif //!_ATL_NO_AUTOMATIC_NAMESPACE

#endif	// __ATLXML_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\include\ocdb.h ===
/*=--------------------------------------------------------------------------=
 * ocdb.h
 *=--------------------------------------------------------------------------=
 * defines the interfaces and constants for use with the OLE Controls Data
 * binding interfaces.
 *
 * Copyright (c) Microsoft Corporation, All Rights Reserved.
 *
 *
 *
 */
#ifndef __OCDB_H_

#undef Delete
#ifdef __cplusplus
extern "C" {
#endif

/* LPDBSTRs are MultiByte in 16bits, and Unicode in 32bits.
 */
#if !defined(OLE2ANSI)

#define LPDBSTR                     LPWSTR
#define DBCHAR                      WCHAR
#define ldbstrlen(str)              wcslen(str)
#define ldbstrcpy(a, b)             wcscpy((a), (b))
#define ldbstrcpy_s(a, sa, b)       wcscpy_s((a), (sa), (b))
#define ldbstrcpyn(a, b, n)         wcsncpy((a), (b), (n))
#define ldbstrcpyn_s(a, sa, b, n)   wcsncpy_s((a), (sa), (b), (n))
#define ldbstrcmp(a, b)             wcscmp((a), (b))
#define ldbstrcat(a, b)             wcscat((a), (b))
#define ldbstrcat_s(a, b)           wcscat_s((a), (sa), (b))
#define ldbstrcmpi(a, b)            wcsicmp((a),(b))
#define DBTEXT(quote)               L##quote

#else

#define LPDBSTR                     LPSTR
#define DBCHAR                      char
#define ldbstrlen(str)              lstrlen(str)
#define ldbstrcpy(a, b)             lstrcpy((a), (b))
#define ldbstrcpy_s(a, sa, b)       lstrcpy((a), (b))
#define ldbstrcpyn(a, b, n)         lstrcpyn((a), (b), (n))
#define ldbstrcpyn_s(a, sa, b, n)   lstrcpyn((a), (b), (n))
#define ldbstrcmp(a, b)             lstrcmp((a), (b))
#define ldbstrcat(a, b)             lstrcat((a), (b))
#define ldbstrcat_s(a, sa, b)       lstrcat((a), (b))
#define ldbstrcmpi(a,b)             lstrcmpi((a),(b))
#define DBTEXT(quote)               quote

#endif /* !OLE2ANSI */

typedef LPDBSTR FAR *  LPLPDBSTR;


/* Many systems don't have BLOBs defined.
 */
#ifndef _tagBLOB_DEFINED
#define _tagBLOB_DEFINED
#define _BLOB_DEFINED
#define _LPBLOB_DEFINED

typedef struct tagBLOB {

	ULONG cbSize;
	BYTE *pBlobData;

} BLOB, *LPBLOB;

#endif

/*----------------------------------------------------------------------------
 *
 *  dbvar.h
 *
 *----------------------------------------------------------------------------
 */
#ifndef _DBCOLUMNID_DEFINED
#define _DBCOLUMNID_DEFINED
typedef enum tagDBCOLKIND
  {
	DBCOLKIND_GUID_NAME = 0,
	DBCOLKIND_GUID_NUMBER = 1,
		DBCOLKIND_NAME = 2
  }
DBCOLKIND;

#define GUID_NAMEONLY   {0x88c8d398,0x863c,0x101b,{0xac,0x3b,0x00,0xaa,0x00,0x44,0x77,0x3d}}
#define GUID_NUMBERONLY {0x88c8d399,0x863c,0x101b,{0xac,0x3b,0x00,0xaa,0x00,0x44,0x77,0x3d}}

typedef struct tagDBCOLUMNID
  {
  GUID guid;
  DBCOLKIND dwKind;
union
	{
	LONG lNumber;
	LPDBSTR lpdbsz;
	}
  ;
  }
DBCOLUMNID;
#endif   /* ndef _COLUMNID_DEFINED */

#ifdef OLD_DEFS
#ifndef _DBVARENUM_DEFINED
#define _DBVARENUM_DEFINED
enum DBVARENUM
  {
	DBTYPE_EMPTY = 0,
	DBTYPE_NULL = 1,
	DBTYPE_I2 = 2,
	DBTYPE_I4 = 3,
	DBTYPE_R4 = 4,
	DBTYPE_R8 = 5,
	DBTYPE_CY = 6,
	DBTYPE_DATE = 7,
	DBTYPE_BOOL = 11,
	DBTYPE_UI2 = 18,
	DBTYPE_UI4 = 19,
		DBTYPE_I8 = 20,
		DBTYPE_UI8 = 21,
	DBTYPE_HRESULT = 25,
	DBTYPE_LPSTR = 30,
	DBTYPE_LPWSTR = 31,
	DBTYPE_FILETIME = 64,
	DBTYPE_BLOB = 65,
	DBTYPE_UUID = 72,
	DBTYPE_DBEXPR = 503,
	DBTYPE_COLUMNID = 507,
	DBTYPE_BYTES = 508,
	DBTYPE_CHARS = 509,
	DBTYPE_WCHARS = 510,
	DBTYPE_ANYVARIANT = 511
  }
;
#endif   /* ndef _DBVARENUM_DEFINED */
#else
#define DBTYPE_COLUMNID 507
#endif

#define DBTYPE_EXT      0x100

typedef struct tagDBVARIANT DBVARIANT;

struct FARSTRUCT tagDBVARIANT{
	VARTYPE vt;
	unsigned short wReserved1;
	unsigned short wReserved2;
	unsigned short wReserved3;
	union {
	  unsigned char bVal;        /* VT_UI1               */
	  short    iVal;             /* VT_I2                */
	  long     lVal;             /* VT_I4                */
	  float    fltVal;           /* VT_R4                */
	  double       dblVal;           /* VT_R8                */
	  VARIANT_BOOL xbool;             /* VT_BOOL              */
	  SCODE    scode;            /* VT_ERROR             */
	  CY       cyVal;            /* VT_CY                */
	  DATE     date;             /* VT_DATE              */
	  BSTR     bstrVal;          /* VT_BSTR              */
	  IUnknown     FAR* punkVal;     /* VT_UNKNOWN           */
	  IDispatch    FAR* pdispVal;    /* VT_DISPATCH          */
	  SAFEARRAY    FAR* parray;      /* VT_ARRAY|*           */

	  unsigned char FAR *pbVal;      /* VT_BYREF|VT_UI1      */
	  short    FAR* piVal;       /* VT_BYREF|VT_I2       */
	  long     FAR* plVal;       /* VT_BYREF|VT_I4       */
	  float    FAR* pfltVal;     /* VT_BYREF|VT_R4       */
	  double       FAR* pdblVal;     /* VT_BYREF|VT_R8       */
	  VARIANT_BOOL FAR* pbool;       /* VT_BYREF|VT_BOOL     */
	  SCODE    FAR* pscode;      /* VT_BYREF|VT_ERROR    */
	  CY       FAR* pcyVal;      /* VT_BYREF|VT_CY       */
	  DATE     FAR* pdate;       /* VT_BYREF|VT_DATE     */
	  BSTR     FAR* pbstrVal;    /* VT_BYREF|VT_BSTR     */
	  IUnknown  FAR* FAR* ppunkVal;  /* VT_BYREF|VT_UNKNOWN  */
	  IDispatch FAR* FAR* ppdispVal; /* VT_BYREF|VT_DISPATCH */
	  SAFEARRAY FAR* FAR* pparray;   /* VT_BYREF|VT_ARRAY|*  */
	  VARIANT      FAR* pvarVal;     /* VT_BYREF|VT_VARIANT  */

	  void     FAR* byref;       /* Generic ByRef        */

	  // types new to DBVARIANTs
	  //
	  BLOB         blob;             /* VT_BLOB              */
	  DBCOLUMNID  *pColumnid;        /* DBTYPE_COLUMNID      */
	  LPSTR        pszVal;           /* VT_LPSTR             */
	  LPWSTR       pwszVal;          /* VT_LPWSTR            */
	  LPWSTR FAR  *ppwszVal;         /* VT_LPWSTR|VT_BYREF   */
	  BLOB FAR    *pblob;            /* VT_BYREF|VT_BLOB     */
	  DBCOLUMNID **ppColumnid;       /* VT_BYREF|DBTYPE_COLID*/
	  DBVARIANT   *pdbvarVal;        /* VT_BYREF|DBTYPE_VARIANT */
	}
#if defined(NONAMELESSUNION)
	u
#endif
	;
};

/*----------------------------------------------------------------------------
 *
 *  dbs.h
 *
 *----------------------------------------------------------------------------
 */
typedef enum tagDBROWFETCH
  {
	DBROWFETCH_DEFAULT = 0,
	DBROWFETCH_CALLEEALLOCATES = 1,
	DBROWFETCH_FORCEREFRESH = 2
  }
DBROWFETCH;

typedef struct tagDBFETCHROWS
  {
  ULONG_PTR      cRowsRequested;
  DWORD      dwFlags;
  VOID HUGEP *pData;
  VOID HUGEP *pVarData;
  ULONG_PTR      cbVarData;
  ULONG_PTR      cRowsReturned;
  }
DBFETCHROWS;

#define DB_NOMAXLENGTH   (DWORD)0
#define DB_NOVALUE       (DWORD)0xFFFFFFFF
#define DB_NULL          (DWORD)0xFFFFFFFF
#define DB_EMPTY         (DWORD)0xFFFFFFFE
#define DB_USEENTRYID    (DWORD)0xFFFFFFFD
#define DB_CANTCOERCE    (DWORD)0xFFFFFFFC
#define DB_TRUNCATED     (DWORD)0xFFFFFFFB
#define DB_UNKNOWN       (DWORD)0xFFFFFFFA
#define DB_NOINFO        (DWORD)0xFFFFFFF9

#ifdef OLD_DEFS
typedef enum tagDBBINDING
  {
	DBBINDING_DEFAULT = 0,
	DBBINDING_VARIANT = 1,
	DBBINDING_ENTRYID = 2
  }
DBBINDING;
#else
typedef enum _DBBINDING
  {
	DBBINDING_DEFAULT = 0,
	DBBINDING_VARIANT = 1,
	DBBINDING_ENTRYID = 2
  }
_DBBINDING;
#endif

typedef enum tagDBBINDTYPE
  {
		DBBINDTYPE_DATA    = 0,
	DBBINDTYPE_ENTRYID = 1,
	DBBDINTYPE_EITHER  = 2,
	DBBINDTYPE_BOTH    = 3
  }
DBBINDTYPE;

typedef struct tagDBCOLUMNBINDING
  {
  DBCOLUMNID columnID;
  ULONG obData;
  ULONG cbMaxLen;
  ULONG obVarDataLen;
  ULONG obInfo;
  DWORD dwBinding;
  DWORD dwDataType;
  }
DBCOLUMNBINDING;

typedef struct tagDBBINDPARAMS
  {
  ULONG cbMaxLen;
  DWORD dwBinding;
  DWORD dwDataType;
  ULONG cbVarDataLen;
  DWORD dwInfo;
  void *pData;
  }
DBBINDPARAMS;

#define CID_NUMBER_INVALID            -1
#define CID_NUMBER_AUTOINCREMENT       0
#define CID_NUMBER_BASECOLUMNNAME      1
#define CID_NUMBER_BASENAME            2
#define CID_NUMBER_BINARYCOMPARABLE    3
#define CID_NUMBER_BINDTYPE            4
#define CID_NUMBER_CASESENSITIVE       5
#define CID_NUMBER_COLLATINGORDER      6
#define CID_NUMBER_COLUMNID            7
#define CID_NUMBER_CURSORCOLUMN        8
#define CID_NUMBER_DATACOLUMN          9
#define CID_NUMBER_DEFAULTVALUE        10
#define CID_NUMBER_ENTRYIDMAXLENGTH    11
#define CID_NUMBER_FIXED               12
#define CID_NUMBER_HASDEFAULT          13
#define CID_NUMBER_MAXLENGTH           14
#define CID_NUMBER_MULTIVALUED         15
#define CID_NUMBER_NAME                16
#define CID_NUMBER_NULLABLE            17
#define CID_NUMBER_PHYSICALSORT        18
#define CID_NUMBER_NUMBER              19
#define CID_NUMBER_ROWENTRYID          20
#define CID_NUMBER_SCALE               21
#define CID_NUMBER_SEARCHABLE          22
#define CID_NUMBER_TYPE                23
#define CID_NUMBER_UNIQUE              24
#define CID_NUMBER_UPDATABLE           25
#define CID_NUMBER_VERSION             26
#define CID_NUMBER_STATUS              27

/* c and C++ have different meanings for const.
 */
#ifdef __cplusplus
#define EXTERNAL_DEFN    extern const
#else
#define EXTERNAL_DEFN    const
#endif /* __cplusplus */



#define _DBCIDGUID {0xfe284700L,0xd188,0x11cd,{0xad,0x48, 0x0,0xaa, 0x0,0x3c,0x9c,0xb6}}
#ifdef DBINITCONSTANTS

EXTERNAL_DEFN DBCOLUMNID NEAR COLUMNID_INVALID         = {_DBCIDGUID, DBCOLKIND_GUID_NUMBER, -1};
EXTERNAL_DEFN DBCOLUMNID NEAR COLUMN_AUTOINCREMENT     = {_DBCIDGUID, DBCOLKIND_GUID_NUMBER, 0};
EXTERNAL_DEFN DBCOLUMNID NEAR COLUMN_BASECOLUMNNAME    = {_DBCIDGUID, DBCOLKIND_GUID_NUMBER, 1};
EXTERNAL_DEFN DBCOLUMNID NEAR COLUMN_BASENAME          = {_DBCIDGUID, DBCOLKIND_GUID_NUMBER, 2};
EXTERNAL_DEFN DBCOLUMNID NEAR COLUMN_BINARYCOMPARABLE  = {_DBCIDGUID, DBCOLKIND_GUID_NUMBER, 3};
EXTERNAL_DEFN DBCOLUMNID NEAR COLUMN_BINDTYPE          = {_DBCIDGUID, DBCOLKIND_GUID_NUMBER, 4};
EXTERNAL_DEFN DBCOLUMNID NEAR COLUMN_CASESENSITIVE     = {_DBCIDGUID, DBCOLKIND_GUID_NUMBER, 5};
EXTERNAL_DEFN DBCOLUMNID NEAR COLUMN_COLLATINGORDER    = {_DBCIDGUID, DBCOLKIND_GUID_NUMBER, 6};
EXTERNAL_DEFN DBCOLUMNID NEAR COLUMN_COLUMNID          = {_DBCIDGUID, DBCOLKIND_GUID_NUMBER, 7};
EXTERNAL_DEFN DBCOLUMNID NEAR COLUMN_CURSORCOLUMN      = {_DBCIDGUID, DBCOLKIND_GUID_NUMBER, 8};
EXTERNAL_DEFN DBCOLUMNID NEAR COLUMN_DATACOLUMN        = {_DBCIDGUID, DBCOLKIND_GUID_NUMBER, 9};
EXTERNAL_DEFN DBCOLUMNID NEAR COLUMN_DEFAULTVALUE      = {_DBCIDGUID, DBCOLKIND_GUID_NUMBER, 10};
EXTERNAL_DEFN DBCOLUMNID NEAR COLUMN_ENTRYIDMAXLENGTH  = {_DBCIDGUID, DBCOLKIND_GUID_NUMBER, 11};
EXTERNAL_DEFN DBCOLUMNID NEAR COLUMN_FIXED             = {_DBCIDGUID, DBCOLKIND_GUID_NUMBER, 12};
EXTERNAL_DEFN DBCOLUMNID NEAR COLUMN_HASDEFAULT        = {_DBCIDGUID, DBCOLKIND_GUID_NUMBER, 13};
EXTERNAL_DEFN DBCOLUMNID NEAR COLUMN_MAXLENGTH         = {_DBCIDGUID, DBCOLKIND_GUID_NUMBER, 14};
EXTERNAL_DEFN DBCOLUMNID NEAR COLUMN_MULTIVALUED       = {_DBCIDGUID, DBCOLKIND_GUID_NUMBER, 15};
EXTERNAL_DEFN DBCOLUMNID NEAR COLUMN_NAME              = {_DBCIDGUID, DBCOLKIND_GUID_NUMBER, 16};
EXTERNAL_DEFN DBCOLUMNID NEAR COLUMN_NULLABLE          = {_DBCIDGUID, DBCOLKIND_GUID_NUMBER, 17};
EXTERNAL_DEFN DBCOLUMNID NEAR COLUMN_PHYSICALSORT      = {_DBCIDGUID, DBCOLKIND_GUID_NUMBER, 18};
EXTERNAL_DEFN DBCOLUMNID NEAR COLUMN_NUMBER            = {_DBCIDGUID, DBCOLKIND_GUID_NUMBER, 19};
EXTERNAL_DEFN DBCOLUMNID NEAR COLUMN_ROWENTRYID        = {_DBCIDGUID, DBCOLKIND_GUID_NUMBER, 20};
EXTERNAL_DEFN DBCOLUMNID NEAR COLUMN_SCALE             = {_DBCIDGUID, DBCOLKIND_GUID_NUMBER, 21};
EXTERNAL_DEFN DBCOLUMNID NEAR COLUMN_SEARCHABLE        = {_DBCIDGUID, DBCOLKIND_GUID_NUMBER, 22};
EXTERNAL_DEFN DBCOLUMNID NEAR COLUMN_TYPE              = {_DBCIDGUID, DBCOLKIND_GUID_NUMBER, 23};
EXTERNAL_DEFN DBCOLUMNID NEAR COLUMN_UNIQUE            = {_DBCIDGUID, DBCOLKIND_GUID_NUMBER, 24};
EXTERNAL_DEFN DBCOLUMNID NEAR COLUMN_UPDATABLE         = {_DBCIDGUID, DBCOLKIND_GUID_NUMBER, 25};
EXTERNAL_DEFN DBCOLUMNID NEAR COLUMN_VERSION           = {_DBCIDGUID, DBCOLKIND_GUID_NUMBER, 26};
EXTERNAL_DEFN DBCOLUMNID NEAR COLUMN_STATUS            = {_DBCIDGUID, DBCOLKIND_GUID_NUMBER, 27};
#else
extern const DBCOLUMNID NEAR COLUMNID_INVALID;
extern const DBCOLUMNID NEAR COLUMN_AUTOINCREMENT;
extern const DBCOLUMNID NEAR COLUMN_BASECOLUMNNAME;
extern const DBCOLUMNID NEAR COLUMN_BASENAME;
extern const DBCOLUMNID NEAR COLUMN_BINARYCOMPARABLE;
extern const DBCOLUMNID NEAR COLUMN_BINDTYPE;
extern const DBCOLUMNID NEAR COLUMN_CASESENSITIVE;
extern const DBCOLUMNID NEAR COLUMN_COLLATINGORDER;
extern const DBCOLUMNID NEAR COLUMN_COLUMNID;
extern const DBCOLUMNID NEAR COLUMN_CURSORCOLUMN;
extern const DBCOLUMNID NEAR COLUMN_DATACOLUMN;
extern const DBCOLUMNID NEAR COLUMN_DEFAULTVALUE;
extern const DBCOLUMNID NEAR COLUMN_ENTRYIDMAXLENGTH;
extern const DBCOLUMNID NEAR COLUMN_FIXED;
extern const DBCOLUMNID NEAR COLUMN_HASDEFAULT;
extern const DBCOLUMNID NEAR COLUMN_MAXLENGTH;
extern const DBCOLUMNID NEAR COLUMN_MULTIVALUED;
extern const DBCOLUMNID NEAR COLUMN_NAME;
extern const DBCOLUMNID NEAR COLUMN_NULLABLE;
extern const DBCOLUMNID NEAR COLUMN_PHYSICALSORT;
extern const DBCOLUMNID NEAR COLUMN_NUMBER;
extern const DBCOLUMNID NEAR COLUMN_ROWENTRYID;
extern const DBCOLUMNID NEAR COLUMN_SCALE;
extern const DBCOLUMNID NEAR COLUMN_SEARCHABLE;
extern const DBCOLUMNID NEAR COLUMN_TYPE;
extern const DBCOLUMNID NEAR COLUMN_UNIQUE;
extern const DBCOLUMNID NEAR COLUMN_UPDATABLE;
extern const DBCOLUMNID NEAR COLUMN_VERSION;
extern const DBCOLUMNID NEAR COLUMN_STATUS;
#endif

#define BMK_NUMBER_BMKTEMPORARY    0
#define BMK_NUMBER_BMKTEMPORARYREL 1
#define BMK_NUMBER_BMKCURSOR       2
#define BMK_NUMBER_BMKCURSORREL    3
#define BMK_NUMBER_BMKSESSION      4
#define BMK_NUMBER_BMKSESSIONREL   5
#define BMK_NUMBER_BMKPERSIST      6
#define BMK_NUMBER_BMKPERSISTREL   7


#define DBBMKGUID_OCDB {0xf6304bb0L,0xd188,0x11cd,{0xad,0x48, 0x0,0xaa, 0x0,0x3c,0x9c,0xb6}}
#ifdef DBINITCONSTANTS
EXTERNAL_DEFN DBCOLUMNID NEAR COLUMN_BMKTEMPORARY      = {DBBMKGUID_OCDB, DBCOLKIND_GUID_NUMBER, 0};
EXTERNAL_DEFN DBCOLUMNID NEAR COLUMN_BMKTEMPORARYREL   = {DBBMKGUID_OCDB, DBCOLKIND_GUID_NUMBER, 1};
EXTERNAL_DEFN DBCOLUMNID NEAR COLUMN_BMKCURSOR         = {DBBMKGUID_OCDB, DBCOLKIND_GUID_NUMBER, 2};
EXTERNAL_DEFN DBCOLUMNID NEAR COLUMN_BMKCURSORREL      = {DBBMKGUID_OCDB, DBCOLKIND_GUID_NUMBER, 3};
EXTERNAL_DEFN DBCOLUMNID NEAR COLUMN_BMKSESSION        = {DBBMKGUID_OCDB, DBCOLKIND_GUID_NUMBER, 4};
EXTERNAL_DEFN DBCOLUMNID NEAR COLUMN_BMKSESSIONREL     = {DBBMKGUID_OCDB, DBCOLKIND_GUID_NUMBER, 5};
EXTERNAL_DEFN DBCOLUMNID NEAR COLUMN_BMKPERSIST        = {DBBMKGUID_OCDB, DBCOLKIND_GUID_NUMBER, 6};
EXTERNAL_DEFN DBCOLUMNID NEAR COLUMN_BMKPERSISTREL     = {DBBMKGUID_OCDB, DBCOLKIND_GUID_NUMBER, 7};
#else
extern const DBCOLUMNID NEAR COLUMN_BMKINVALID;
extern const DBCOLUMNID NEAR COLUMN_BMKTEMPORARY;
extern const DBCOLUMNID NEAR COLUMN_BMKTEMPORARYREL;
extern const DBCOLUMNID NEAR COLUMN_BMKCURSOR;
extern const DBCOLUMNID NEAR COLUMN_BMKCURSORREL;
extern const DBCOLUMNID NEAR COLUMN_BMKSESSION;
extern const DBCOLUMNID NEAR COLUMN_BMKSESSIONREL;
extern const DBCOLUMNID NEAR COLUMN_BMKPERSIST;
extern const DBCOLUMNID NEAR COLUMN_BMKPERSISTREL;
#endif

#define DB_BMK_SIZE        sizeof(BYTE)
#ifdef DBINITCONSTANTS
#ifdef OLD_DEFS
EXTERNAL_DEFN BYTE NEAR DBBMK_INVALID   = 0x0;
#endif
EXTERNAL_DEFN BYTE NEAR DBBMK_CURRENT   = 0x1;
EXTERNAL_DEFN BYTE NEAR DBBMK_BEGINNING = 0x2;
EXTERNAL_DEFN BYTE NEAR DBBMK_END       = 0x3;
#else
#ifdef OLD_DEFS
extern const BYTE NEAR DBBMK_INVALID;
#endif
extern const BYTE NEAR DBBMK_CURRENT;
extern const BYTE NEAR DBBMK_BEGINNING;
extern const BYTE NEAR DBBMK_END;
#endif

typedef enum tagDBCOLUMNBINDOPTS
  {
	DBCOLUMNBINDOPTS_REPLACE = 0,
	DBCOLUMNBINDOPTS_ADD = 1
  }
DBCOLUMNBINDOPTS;

typedef enum tagDBUPDATELOCK
  {
	DBUPDATELOCK_PESSIMISTIC = 0,
	DBUPDATELOCK_OPTIMISTIC = 1
  }
DBUPDATELOCK;

typedef enum tagDBCOLUMNDATA
  {
	DBCOLUMNDATA_UNCHANGED = 0,
	DBCOLUMNDATA_CHANGED = 1,
		DBCOLUMNDATA_UNKNOWN = 2
  }
DBCOLUMNDATA;

typedef enum tagDBROWACTION
  {
	DBROWACTION_IGNORE = 0,
	DBROWACTION_UPDATE = 1,
	DBROWACTION_DELETE = 2,
	DBROWACTION_ADD = 3,
	DBROWACTION_LOCK = 4,
	DBROWACTION_UNLOCK = 5
  }
DBROWACTION;

typedef enum tagDBUPDATEABLE
  {
	DBUPDATEABLE_UPDATEABLE = 0,
	DBUPDATEABLE_NOTUPDATEABLE = 1,
	DBUPDATEABLE_UNKNOWN = 2
  }
DBUPDATEABLE;

#ifdef OLD_DEFS
typedef struct tagDBROWSTATUS
  {
  HRESULT hrStatus;
  BLOB Bookmark;
  }
DBROWSTATUS;
#endif

typedef enum tagDBEVENTWHATS
  {
	DBEVENT_CURRENT_ROW_CHANGED = 1,
	DBEVENT_CURRENT_ROW_DATA_CHANGED = 2,
	DBEVENT_NONCURRENT_ROW_DATA_CHANGED = 4,
	DBEVENT_SET_OF_COLUMNS_CHANGED = 8,
	DBEVENT_ORDER_OF_COLUMNS_CHANGED = 16,
	DBEVENT_SET_OF_ROWS_CHANGED = 32,
	DBEVENT_ORDER_OF_ROWS_CHANGED = 64,
	DBEVENT_METADATA_CHANGED = 128,
	DBEVENT_ASYNCH_OP_FINISHED = 256,
	DBEVENT_FIND_CRITERIA_CHANGED = 512,
  }
DBEVENTWHATS;

typedef enum tagDBREASON
  {
	DBREASON_DELETED = 1,
	DBREASON_INSERTED = 2,
	DBREASON_MODIFIED = 3,
	DBREASON_REMOVEDFROMCURSOR = 4,
	DBREASON_MOVEDINCURSOR = 5,
	DBREASON_MOVE = 6,
	DBREASON_FIND = 7,
	DBREASON_NEWINDEX = 8,
	DBREASON_ROWFIXUP = 9,
	DBREASON_RECALC = 10,
	DBREASON_REFRESH = 11,
	DBREASON_NEWPARAMETERS = 12,
	DBREASON_SORTCHANGED = 13,
	DBREASON_FILTERCHANGED = 14,
	DBREASON_QUERYSPECCHANGED = 15,
	DBREASON_SEEK = 16,
	DBREASON_PERCENT = 17,
	DBREASON_FINDCRITERIACHANGED = 18,
	DBREASON_SETRANGECHANGED = 19,
	DBREASON_ADDNEW = 20,
	DBREASON_MOVEPERCENT = 21,
	DBREASON_BEGINTRANSACT = 22,
	DBREASON_ROLLBACK = 23,
	DBREASON_COMMIT = 24,
	DBREASON_CLOSE = 25,
	DBREASON_BULK_ERROR = 26,
	DBREASON_BULK_NOTTRANSACTABLE = 27,
	DBREASON_BULK_ABOUTTOEXECUTE = 28,
	DBREASON_CANCELUPDATE = 29,
	DBREASON_SETCOLUMN = 30,
	DBREASON_EDIT = 31,
	DBREASON_UNLOAD = 32
  }
#ifdef OLD_DEFS
DBREASON
#else
_DBREASON;
#endif

// Arg1 values for DBREASON_FIND
typedef enum tagDBFINDTYPES
  {
  DB_FINDFIRST = 1,
  DB_FINDLAST = 2,
  DB_FINDNEXT = 3,
  DB_FINDPRIOR = 4,
  DB_FIND = 5
  }
DBFINDTYPES;

typedef struct tagDBNOTIFYREASON
  {
  DWORD dwReason;
  DBVARIANT arg1;
  DBVARIANT arg2;
  }
DBNOTIFYREASON;

//#define DB_E_BADBINDINFO           MAKE_SCODE(SEVERITY_ERROR,   FACILITY_ITF, 0x0e00)
//#define DB_E_BADBOOKMARK           MAKE_SCODE(SEVERITY_ERROR,   FACILITY_ITF, 0x0e01)
//#define DB_E_BADCOLUMNID           MAKE_SCODE(SEVERITY_ERROR,   FACILITY_ITF, 0x0e02)
#define OCDB_E_BADCRITERIA           MAKE_SCODE(SEVERITY_ERROR,   FACILITY_ITF, 0x0e03)
#define OCDB_E_BADENTRYID            MAKE_SCODE(SEVERITY_ERROR,   FACILITY_ITF, 0x0e04)
#define OCDB_E_BADFRACTION           MAKE_SCODE(SEVERITY_ERROR,   FACILITY_ITF, 0x0e05)
//#define DB_E_BADINDEXID            MAKE_SCODE(SEVERITY_ERROR,   FACILITY_ITF, 0x0e06)
#define OCDB_E_BADQUERYSPEC          MAKE_SCODE(SEVERITY_ERROR,   FACILITY_ITF, 0x0e07)
#define OCDB_E_BADSORTORDER          MAKE_SCODE(SEVERITY_ERROR,   FACILITY_ITF, 0x0e08)
//#define DB_E_BADVALUES             MAKE_SCODE(SEVERITY_ERROR,   FACILITY_ITF, 0x0e09)
#define OCDB_E_CANTCOERCE            MAKE_SCODE(SEVERITY_ERROR,   FACILITY_ITF, 0x0e0a)
#define OCDB_E_CANTLOCK              MAKE_SCODE(SEVERITY_ERROR,   FACILITY_ITF, 0x0e0b)
#define OCDB_E_COLUMNUNAVAILABLE     MAKE_SCODE(SEVERITY_ERROR,   FACILITY_ITF, 0x0e0c)
#define OCDB_E_DATACHANGED           MAKE_SCODE(SEVERITY_ERROR,   FACILITY_ITF, 0x0e0d)
#define OCDB_E_INVALIDCOLUMNORDINAL  MAKE_SCODE(SEVERITY_ERROR,   FACILITY_ITF, 0x0e0e)
#define OCDB_E_INVALIDINTERFACE      MAKE_SCODE(SEVERITY_ERROR,   FACILITY_ITF, 0x0e0f)
#define OCDB_E_LOCKFAILED            MAKE_SCODE(SEVERITY_ERROR,   FACILITY_ITF, 0x0e10)
#define OCDB_E_ROWDELETED            MAKE_SCODE(SEVERITY_ERROR,   FACILITY_ITF, 0x0e11)
#define OCDB_E_ROWTOOSHORT           MAKE_SCODE(SEVERITY_ERROR,   FACILITY_ITF, 0x0e12)
//#define DB_E_SCHEMAVIOLATION       MAKE_SCODE(SEVERITY_ERROR,   FACILITY_ITF, 0x0e13)
#define OCDB_E_SEEKKINDNOTSUPPORTED  MAKE_SCODE(SEVERITY_ERROR,   FACILITY_ITF, 0x0e14)
#define OCDB_E_UPDATEINPROGRESS      MAKE_SCODE(SEVERITY_ERROR,   FACILITY_ITF, 0x0e15)
#define OCDB_E_USEENTRYID            MAKE_SCODE(SEVERITY_ERROR,   FACILITY_ITF, 0x0e16)
#define OCDB_E_STATEERROR            MAKE_SCODE(SEVERITY_ERROR,   FACILITY_ITF, 0x0e17)
#define OCDB_E_BADFETCHINFO          MAKE_SCODE(SEVERITY_ERROR,   FACILITY_ITF, 0x0e18)
#define OCDB_E_NOASYNC               MAKE_SCODE(SEVERITY_ERROR,   FACILITY_ITF, 0x0e19)
#define OCDB_E_ENTRYIDOPEN           MAKE_SCODE(SEVERITY_ERROR,   FACILITY_ITF, 0x0e1a)
#define OCDB_E_BUFFERTOOSMALL        MAKE_SCODE(SEVERITY_ERROR,   FACILITY_ITF, 0x0e1b)
#define OCDB_S_BUFFERTOOSMALL        MAKE_SCODE(SEVERITY_SUCCESS, FACILITY_ITF, 0x0ec0)
#define OCDB_S_CANCEL                MAKE_SCODE(SEVERITY_SUCCESS, FACILITY_ITF, 0x0ec1)
#define OCDB_S_DATACHANGED           MAKE_SCODE(SEVERITY_SUCCESS, FACILITY_ITF, 0x0ec2)
#define OCDB_S_ENDOFCURSOR           MAKE_SCODE(SEVERITY_SUCCESS, FACILITY_ITF, 0x0ec3)
#define OCDB_S_ENDOFRESULTSET        MAKE_SCODE(SEVERITY_SUCCESS, FACILITY_ITF, 0x0ec4)
#define OCDB_S_OPERATIONCANCELLED    MAKE_SCODE(SEVERITY_SUCCESS, FACILITY_ITF, 0x0ec5)
#define OCDB_S_QUERYINTERFACE        MAKE_SCODE(SEVERITY_SUCCESS, FACILITY_ITF, 0x0ec6)
#define OCDB_S_WORKINGASYNC          MAKE_SCODE(SEVERITY_SUCCESS, FACILITY_ITF, 0x0ec7)
//#define DB_S_COULDNTCOERCE         MAKE_SCODE(SEVERITY_SUCCESS, FACILITY_ITF, 0x0ec8)
#define OCDB_S_MOVEDTOFIRST          MAKE_SCODE(SEVERITY_SUCCESS, FACILITY_ITF, 0x0ec9)
#define OCDB_S_CURRENTROWUNCHANGED   MAKE_SCODE(SEVERITY_SUCCESS, FACILITY_ITF, 0x0eca)
#define OCDB_S_ROWADDED              MAKE_SCODE(SEVERITY_SUCCESS, FACILITY_ITF, 0x0ecb)
#define OCDB_S_ROWUPDATED            MAKE_SCODE(SEVERITY_SUCCESS, FACILITY_ITF, 0x0ecc)
#define OCDB_S_ROWDELETED            MAKE_SCODE(SEVERITY_SUCCESS, FACILITY_ITF, 0x0ecd)

/*----------------------------------------------------------------------------
 *
 *  ICursor
 *
 *----------------------------------------------------------------------------
 */
/* Forward declaration */
//typedef interface ICursor ICursor;

#if defined(__cplusplus) && !defined(CINTERFACE)

/* C++ Language Binding */
//extern "C" const IID IID_ICursor;

interface ICursor : public IUnknown
{
public:
	virtual HRESULT STDMETHODCALLTYPE GetColumnsCursor
	(
	REFIID riid,
	IUnknown **ppvColumnsCursor,
	ULONG_PTR *pcRows
	) = 0;

	virtual HRESULT STDMETHODCALLTYPE SetBindings
	(
	ULONG_PTR cCol,
	DBCOLUMNBINDING rgBoundColumns[],
	ULONG_PTR cbRowLength,
	DWORD dwFlags
	) = 0;

	virtual HRESULT STDMETHODCALLTYPE GetBindings
	(
	ULONG_PTR *pcCol,
	DBCOLUMNBINDING *prgBoundColumns[],
	ULONG_PTR *pcbRowLength
	) = 0;

	virtual HRESULT STDMETHODCALLTYPE GetNextRows
	(
	LARGE_INTEGER udlRowsToSkip,
	DBFETCHROWS *pFetchParams
	) = 0;

	virtual HRESULT STDMETHODCALLTYPE Requery
	(
		void
	) = 0;

};

#else

/* C Language Binding */
//extern const IID IID_ICursor;

typedef struct ICursorVtbl
{

	HRESULT (STDMETHODCALLTYPE FAR *QueryInterface)
	(
		ICursor FAR *this,
	REFIID riid,
	void **ppvObject
	);

	ULONG (STDMETHODCALLTYPE FAR *AddRef)
	(
		ICursor FAR *this
	);

	ULONG (STDMETHODCALLTYPE FAR *Release)
	(
		ICursor FAR *this
	);

	HRESULT (STDMETHODCALLTYPE FAR *GetColumnsCursor)
	(
		ICursor FAR *this,
	REFIID riid,
	IUnknown **ppvColumnsCursor,
	ULONG_PTR *pcRows
	);

	HRESULT (STDMETHODCALLTYPE FAR *SetBindings)
	(
		ICursor FAR *this,
	ULONG_PTR cCol,
	DBCOLUMNBINDING rgBoundColumns[],
	ULONG_PTR cbRowLength,
	DWORD dwFlags
	);

	HRESULT (STDMETHODCALLTYPE FAR *GetBindings)
	(
		ICursor FAR *this,
	ULONG_PTR *pcCol,
	DBCOLUMNBINDING *prgBoundColumns[],
	ULONG_PTR *pcbRowLength
	);

	HRESULT (STDMETHODCALLTYPE FAR *GetNextRows)
	(
		ICursor FAR *this,
	LARGE_INTEGER udlRowsToSkip,
	DBFETCHROWS *pFetchParams
	);

	HRESULT (STDMETHODCALLTYPE FAR *Requery)
	(
		ICursor FAR *this
	);

} ICursorVtbl;

interface ICursor
{
	ICursorVtbl FAR *lpVtbl;
} ;

#ifdef COBJMACROS

#define ICursor_QueryInterface(pI, riid, ppvObject) \
	(*(pI)->lpVtbl->QueryInterface)((pI), riid, ppvObject)

#define ICursor_AddRef(pI) \
	(*(pI)->lpVtbl->AddRef)((pI))

#define ICursor_Release(pI) \
	(*(pI)->lpVtbl->Release)((pI))

#define ICursor_GetColumnsCursor(pI, riid, ppvColumnsCursor, pcRows) \
	(*(pI)->lpVtbl->GetColumnsCursor)((pI), riid, ppvColumnsCursor, pcRows)

#define ICursor_SetBindings(pI, cCol, rgBoundColumns, cbRowLength, dwFlags) \
	(*(pI)->lpVtbl->SetBindings)((pI), cCol, rgBoundColumns, cbRowLength, dwFlags)

#define ICursor_GetBindings(pI, pcCol, prgBoundColumns, pcbRowLength) \
	(*(pI)->lpVtbl->GetBindings)((pI), pcCol, prgBoundColumns, pcbRowLength)

#define ICursor_GetNextRows(pI, udlRowsToSkip, pFetchParams) \
	(*(pI)->lpVtbl->GetNextRows)((pI), udlRowsToSkip, pFetchParams)

#define ICursor_Requery(pI) \
	(*(pI)->lpVtbl->Requery)((pI))

#endif /* COBJMACROS */

#endif

/*----------------------------------------------------------------------------
 *
 *  ICursorMove
 *
 *----------------------------------------------------------------------------
 */
/* Forward declaration */
//typedef interface ICursorMove ICursorMove;

typedef enum tagDBCLONEOPTS
  {
	DBCLONEOPTS_DEFAULT = 0,
	DBCLONEOPTS_SAMEROW = 1
  }
DBCLONEOPTS;


#if defined(__cplusplus) && !defined(CINTERFACE)

/* C++ Language Binding */
//extern "C" const IID IID_ICursorMove;

interface ICursorMove : public ICursor
{
public:
	virtual HRESULT STDMETHODCALLTYPE Move
	(
	ULONG cbBookmark,
	void *pBookmark,
	LARGE_INTEGER dlOffset,
	DBFETCHROWS *pFetchParams
	) = 0;

	virtual HRESULT STDMETHODCALLTYPE GetBookmark
	(
	DBCOLUMNID *pBookmarkType,
	ULONG cbMaxSize,
	ULONG *pcbBookmark,
	void *pBookmark
	) = 0;

	virtual HRESULT STDMETHODCALLTYPE Clone
	(
	DWORD dwFlags,
	REFIID riid,
	IUnknown **ppvClonedCursor
	) = 0;

};

#else

/* C Language Binding */
//extern const IID IID_ICursorMove;

typedef struct ICursorMoveVtbl
{

	HRESULT (STDMETHODCALLTYPE FAR *QueryInterface)
	(
		ICursorMove FAR *this,
	REFIID riid,
	void **ppvObject
	);

	ULONG (STDMETHODCALLTYPE FAR *AddRef)
	(
		ICursorMove FAR *this
	);

	ULONG (STDMETHODCALLTYPE FAR *Release)
	(
		ICursorMove FAR *this
	);

	HRESULT (STDMETHODCALLTYPE FAR *GetColumnsCursor)
	(
		ICursorMove FAR *this,
	REFIID riid,
	IUnknown **ppvColumnsCursor,
	ULONG_PTR *pcRows
	);

	HRESULT (STDMETHODCALLTYPE FAR *SetBindings)
	(
		ICursorMove FAR *this,
	ULONG_PTR cCol,
	DBCOLUMNBINDING rgBoundColumns[],
	ULONG_PTR cbRowLength,
	DWORD dwFlags
	);

	HRESULT (STDMETHODCALLTYPE FAR *GetBindings)
	(
		ICursorMove FAR *this,
	ULONG_PTR *pcCol,
	DBCOLUMNBINDING *prgBoundColumns[],
	ULONG_PTR *pcbRowLength
	);

	HRESULT (STDMETHODCALLTYPE FAR *GetNextRows)
	(
		ICursorMove FAR *this,
	LARGE_INTEGER udlRowsToSkip,
	DBFETCHROWS *pFetchParams
	);

	HRESULT (STDMETHODCALLTYPE FAR *Requery)
	(
		ICursorMove FAR *this
	);

	HRESULT (STDMETHODCALLTYPE FAR *Move)
	(
		ICursorMove FAR *this,
	ULONG cbBookmark,
	void *pBookmark,
	LARGE_INTEGER dlOffset,
	DBFETCHROWS *pFetchParams
	);

	HRESULT (STDMETHODCALLTYPE FAR *GetBookmark)
	(
		ICursorMove FAR *this,
	DBCOLUMNID *pBookmarkType,
	ULONG cbMaxSize,
	ULONG *pcbBookmark,
	void *pBookmark
	);

	HRESULT (STDMETHODCALLTYPE FAR *Clone)
	(
		ICursorMove FAR *this,
	DWORD dwFlags,
	REFIID riid,
	IUnknown **ppvClonedCursor
	);

} ICursorMoveVtbl;

interface ICursorMove
{
	ICursorMoveVtbl FAR *lpVtbl;
} ;

#ifdef COBJMACROS

#define ICursorMove_QueryInterface(pI, riid, ppvObject) \
	(*(pI)->lpVtbl->QueryInterface)((pI), riid, ppvObject)

#define ICursorMove_AddRef(pI) \
	(*(pI)->lpVtbl->AddRef)((pI))

#define ICursorMove_Release(pI) \
	(*(pI)->lpVtbl->Release)((pI))

#define ICursorMove_GetColumnsCursor(pI, riid, ppvColumnsCursor, pcRows) \
	(*(pI)->lpVtbl->GetColumnsCursor)((pI), riid, ppvColumnsCursor, pcRows)

#define ICursorMove_SetBindings(pI, cCol, rgBoundColumns, cbRowLength, dwFlags) \
	(*(pI)->lpVtbl->SetBindings)((pI), cCol, rgBoundColumns, cbRowLength, dwFlags)

#define ICursorMove_GetBindings(pI, pcCol, prgBoundColumns, pcbRowLength) \
	(*(pI)->lpVtbl->GetBindings)((pI), pcCol, prgBoundColumns, pcbRowLength)

#define ICursorMove_GetNextRows(pI, udlRowsToSkip, pFetchParams) \
	(*(pI)->lpVtbl->GetNextRows)((pI), udlRowsToSkip, pFetchParams)

#define ICursorMove_Requery(pI) \
	(*(pI)->lpVtbl->Requery)((pI))

#define ICursorMove_Move(pI, cbBookmark, pBookmark, dlOffset, pFetchParams) \
	(*(pI)->lpVtbl->Move)((pI), cbBookmark, pBookmark, dlOffset, pFetchParams)

#define ICursorMove_GetBookmark(pI, pBookmarkType, cbMaxSize, pcbBookmark, pBookmark) \
	(*(pI)->lpVtbl->GetBookmark)((pI), pBookmarkType, cbMaxSize, pcbBookmark, pBookmark)

#define ICursorMove_Clone(pI, dwFlags, riid, ppvClonedCursor) \
	(*(pI)->lpVtbl->Clone)((pI), dwFlags, riid, ppvClonedCursor)
#endif /* COBJMACROS */

#endif

/*----------------------------------------------------------------------------
 *
 *  ICursorScroll
 *
 *----------------------------------------------------------------------------
 */
/* Forward declaration */
//typedef interface ICursorScroll ICursorScroll;

typedef enum tagDBCURSORPOPULATED
  {
	DBCURSORPOPULATED_FULLY = 0,
	DBCURSORPOPULATED_PARTIALLY = 1
  }
DBCURSORPOPULATED;


#if defined(__cplusplus) && !defined(CINTERFACE)

/* C++ Language Binding */
//extern "C" const IID IID_ICursorScroll;

interface ICursorScroll : public ICursorMove
{
public:
	virtual HRESULT STDMETHODCALLTYPE Scroll
	(
	ULONG ulNumerator,
	ULONG ulDenominator,
	DBFETCHROWS *pFetchParams
	) = 0;

	virtual HRESULT STDMETHODCALLTYPE GetApproximatePosition
	(
	ULONG cbBookmark,
	void *pBookmark,
	ULONG *pulNumerator,
	ULONG *pulDenominator
	) = 0;

	virtual HRESULT STDMETHODCALLTYPE GetApproximateCount
	(
	LARGE_INTEGER *pudlApproxCount,
	DWORD *pdwFullyPopulated
	) = 0;

};

#else

/* C Language Binding */
//extern const IID IID_ICursorScroll;

typedef struct ICursorScrollVtbl
{

	HRESULT (STDMETHODCALLTYPE FAR *QueryInterface)
	(
		ICursorScroll FAR *this,
	REFIID riid,
	void **ppvObject
	);

	ULONG (STDMETHODCALLTYPE FAR *AddRef)
	(
		ICursorScroll FAR *this
	);

	ULONG (STDMETHODCALLTYPE FAR *Release)
	(
		ICursorScroll FAR *this
	);

	HRESULT (STDMETHODCALLTYPE FAR *GetColumnsCursor)
	(
		ICursorScroll FAR *this,
	REFIID riid,
	IUnknown **ppvColumnsCursor,
	ULONG *pcRows
	);

	HRESULT (STDMETHODCALLTYPE FAR *SetBindings)
	(
		ICursorScroll FAR *this,
	ULONG cCol,
	DBCOLUMNBINDING rgBoundColumns[],
	ULONG cbRowLength,
	DWORD dwFlags
	);

	HRESULT (STDMETHODCALLTYPE FAR *GetBindings)
	(
		ICursorScroll FAR *this,
	ULONG *pcCol,
	DBCOLUMNBINDING *prgBoundColumns[],
	ULONG *pcbRowLength
	);

	HRESULT (STDMETHODCALLTYPE FAR *GetNextRows)
	(
		ICursorScroll FAR *this,
	LARGE_INTEGER udlRowsToSkip,
	DBFETCHROWS *pFetchParams
	);

	HRESULT (STDMETHODCALLTYPE FAR *Requery)
	(
		ICursorScroll FAR *this
	);

	HRESULT (STDMETHODCALLTYPE FAR *Move)
	(
		ICursorScroll FAR *this,
	ULONG cbBookmark,
	void *pBookmark,
	LARGE_INTEGER dlOffset,
	DBFETCHROWS *pFetchParams
	);

	HRESULT (STDMETHODCALLTYPE FAR *GetBookmark)
	(
		ICursorScroll FAR *this,
	DBCOLUMNID *pBookmarkType,
	ULONG cbMaxSize,
	ULONG *pcbBookmark,
	void *pBookmark
	);

	HRESULT (STDMETHODCALLTYPE FAR *Clone)
	(
		ICursorScroll FAR *this,
	DWORD dwFlags,
	REFIID riid,
	IUnknown **ppvClonedCursor
	);

	HRESULT (STDMETHODCALLTYPE FAR *Scroll)
	(
		ICursorScroll FAR *this,
	ULONG ulNumerator,
	ULONG ulDenominator,
	DBFETCHROWS *pFetchParams
	);

	HRESULT (STDMETHODCALLTYPE FAR *GetApproximatePosition)
	(
		ICursorScroll FAR *this,
	ULONG cbBookmark,
	void *pBookmark,
	ULONG *pulNumerator,
	ULONG *pulDenominator
	);

	HRESULT (STDMETHODCALLTYPE FAR *GetApproximateCount)
	(
		ICursorScroll FAR *this,
	LARGE_INTEGER *pudlApproxCount,
	DWORD *pdwFullyPopulated
	);

} ICursorScrollVtbl;

interface ICursorScroll
{
	ICursorScrollVtbl FAR *lpVtbl;
} ;

#ifdef COBJMACROS

#define ICursorScroll_QueryInterface(pI, riid, ppvObject) \
	(*(pI)->lpVtbl->QueryInterface)((pI), riid, ppvObject)

#define ICursorScroll_AddRef(pI) \
	(*(pI)->lpVtbl->AddRef)((pI))

#define ICursorScroll_Release(pI) \
	(*(pI)->lpVtbl->Release)((pI))

#define ICursorScroll_GetColumnsCursor(pI, riid, ppvColumnsCursor, pcRows) \
	(*(pI)->lpVtbl->GetColumnsCursor)((pI), riid, ppvColumnsCursor, pcRows)

#define ICursorScroll_SetBindings(pI, cCol, rgBoundColumns, cbRowLength, dwFlags) \
	(*(pI)->lpVtbl->SetBindings)((pI), cCol, rgBoundColumns, cbRowLength, dwFlags)

#define ICursorScroll_GetBindings(pI, pcCol, prgBoundColumns, pcbRowLength) \
	(*(pI)->lpVtbl->GetBindings)((pI), pcCol, prgBoundColumns, pcbRowLength)

#define ICursorScroll_GetNextRows(pI, udlRowsToSkip, pFetchParams) \
	(*(pI)->lpVtbl->GetNextRows)((pI), udlRowsToSkip, pFetchParams)

#define ICursorScroll_Requery(pI) \
	(*(pI)->lpVtbl->Requery)((pI))

#define ICursorScroll_Move(pI, cbBookmark, pBookmark, dlOffset, pFetchParams) \
	(*(pI)->lpVtbl->Move)((pI), cbBookmark, pBookmark, dlOffset, pFetchParams)

#define ICursorScroll_GetBookmark(pI, pBookmarkType, cbMaxSize, pcbBookmark, pBookmark) \
	(*(pI)->lpVtbl->GetBookmark)((pI), pBookmarkType, cbMaxSize, pcbBookmark, pBookmark)

#define ICursorScroll_Clone(pI, dwFlags, riid, ppvClonedCursor) \
	(*(pI)->lpVtbl->Clone)((pI), dwFlags, riid, ppvClonedCursor)

#define ICursorScroll_Scroll(pI, ulNumerator, ulDenominator, pFetchParams) \
	(*(pI)->lpVtbl->Scroll)((pI), ulNumerator, ulDenominator, pFetchParams)

#define ICursorScroll_GetApproximatePosition(pI, cbBookmark, pBookmark, pulNumerator, pulDenominator) \
	(*(pI)->lpVtbl->GetApproximatePosition)((pI), cbBookmark, pBookmark, pulNumerator, pulDenominator)

#define ICursorScroll_GetApproximateCount(pI, pudlApproxCount, pdwFullyPopulated) \
	(*(pI)->lpVtbl->GetApproximateCount)((pI), pudlApproxCount, pdwFullyPopulated)
#endif /* COBJMACROS */

#endif

/*----------------------------------------------------------------------------
 *
 *  ICursorUpdateARow
 *
 *----------------------------------------------------------------------------
 */
/* Forward declaration */
//typedef interface ICursorUpdateARow ICursorUpdateARow;

typedef enum tagDBEDITMODE
  {
	DBEDITMODE_NONE = 1,
	DBEDITMODE_UPDATE = 2,
	DBEDITMODE_ADD = 3
  }
DBEDITMODE;


#if defined(__cplusplus) && !defined(CINTERFACE)

/* C++ Language Binding */
//extern "C" const IID IID_ICursorUpdateARow;

interface ICursorUpdateARow : public IUnknown
{
public:
	virtual HRESULT STDMETHODCALLTYPE BeginUpdate
	(
	DWORD dwFlags
	) = 0;

	virtual HRESULT STDMETHODCALLTYPE SetColumn
	(
	DBCOLUMNID *pcid,
	DBBINDPARAMS *pBindParams
	) = 0;

	virtual HRESULT STDMETHODCALLTYPE GetColumn
	(
	DBCOLUMNID *pcid,
	DBBINDPARAMS *pBindParams,
	DWORD *pdwFlags
	) = 0;

	virtual HRESULT STDMETHODCALLTYPE GetEditMode
	(
	DWORD *pdwState
	) = 0;

	virtual HRESULT STDMETHODCALLTYPE Update
	(
	DBCOLUMNID *pBookmarkType,
	ULONG *pcbBookmark,
	void **ppBookmark
	) = 0;

	virtual HRESULT STDMETHODCALLTYPE Cancel
	(
		void
	) = 0;

	virtual HRESULT STDMETHODCALLTYPE Delete
	(
	void
	) = 0;

};

#else

/* C Language Binding */
//extern const IID IID_ICursorUpdateARow;

typedef struct ICursorUpdateARowVtbl
{

	HRESULT (STDMETHODCALLTYPE FAR *QueryInterface)
	(
		ICursorUpdateARow FAR *this,
	REFIID riid,
	void **ppvObject
	);

	ULONG (STDMETHODCALLTYPE FAR *AddRef)
	(
		ICursorUpdateARow FAR *this
	);

	ULONG (STDMETHODCALLTYPE FAR *Release)
	(
		ICursorUpdateARow FAR *this
	);

	HRESULT (STDMETHODCALLTYPE FAR *BeginUpdate)
	(
		ICursorUpdateARow FAR *this,
	DWORD dwFlags
	);

	HRESULT (STDMETHODCALLTYPE FAR *SetColumn)
	(
		ICursorUpdateARow FAR *this,
	DBCOLUMNID *pcid,
	DBBINDPARAMS *pBindParams
	);

	HRESULT (STDMETHODCALLTYPE FAR *GetColumn)
	(
		ICursorUpdateARow FAR *this,
	DBCOLUMNID *pcid,
	DBBINDPARAMS *pBindParams,
	DWORD *pdwFlags
	);

	HRESULT (STDMETHODCALLTYPE FAR *GetEditMode)
	(
		ICursorUpdateARow FAR *this,
	DWORD *pdwState
	);

	HRESULT (STDMETHODCALLTYPE FAR *Update)
	(
		ICursorUpdateARow FAR *this,
	DBCOLUMNID *pBookmarkType,
	ULONG *pcbBookmark,
	void **ppBookmark
	);

	HRESULT (STDMETHODCALLTYPE FAR *Cancel)
	(
		ICursorUpdateARow FAR *this
	);

	HRESULT (STDMETHODCALLTYPE FAR *Delete)
	(
		ICursorUpdateARow FAR *this
	);

} ICursorUpdateARowVtbl;

interface ICursorUpdateARow
{
	ICursorUpdateARowVtbl FAR *lpVtbl;
} ;

#ifdef COBJMACROS

#define ICursorUpdateARow_QueryInterface(pI, riid, ppvObject) \
	(*(pI)->lpVtbl->QueryInterface)((pI), riid, ppvObject)

#define ICursorUpdateARow_AddRef(pI) \
	(*(pI)->lpVtbl->AddRef)((pI))

#define ICursorUpdateARow_Release(pI) \
	(*(pI)->lpVtbl->Release)((pI))

#define ICursorUpdateARow_BeginUpdate(pI, dwFlags) \
	(*(pI)->lpVtbl->BeginUpdate)((pI), dwFlags)

#define ICursorUpdateARow_SetColumn(pI, pcid, pBindParams) \
	(*(pI)->lpVtbl->SetColumn)((pI), pcid, pBindParams)

#define ICursorUpdateARow_GetColumn(pI, pcid, pBindParams, pdwFlags) \
	(*(pI)->lpVtbl->GetColumn)((pI), pcid, pBindParams, pdwFlags)

#define ICursorUpdateARow_GetEditMode(pI, pdwState) \
	(*(pI)->lpVtbl->GetEditMode)((pI), pdwState)

#define ICursorUpdateARow_Update(pI, pBookmarkType, pcbBookmark, ppBookmark) \
	(*(pI)->lpVtbl->Update)((pI), pBookmarkType, pcbBookmark, ppBookmark)

#define ICursorUpdateARow_Cancel(pI) \
	(*(pI)->lpVtbl->Cancel)((pI))

#define ICursorUpdateARow_Delete(pI) \
	(*(pI)->lpVtbl->Delete)((pI))


#endif /* COBJMACROS */

#endif

/*----------------------------------------------------------------------------
 *
 *  ICursorFind
 *
 *----------------------------------------------------------------------------
 */
/* Forward declaration */
//typedef interface ICursorFind ICursorFind;

typedef enum tagDBFINDFLAGS
  {
	DBFINDFLAGS_FINDNEXT = 1,
	DBFINDFLAGS_FINDPRIOR = 2,
	DBFINDFLAGS_INCLUDECURRENT = 4
  }
DBFINDFLAGS;

#ifdef OLD_DEFS
typedef enum tagDBSEEKFLAGS
  {
	DBSEEK_LT    = 1,
	DBSEEK_LE    = 2,
	DBSEEK_EQ    = 3,       // EXACT EQUALITY
	DBSEEK_GT    = 4,
	DBSEEK_GE    = 5,
	DBSEEK_PARTIALEQ = 6             // only for strings
  }
DBSEEKFLAGS;
#endif

#if defined(__cplusplus) && !defined(CINTERFACE)

/* C++ Language Binding */
//extern "C" const IID IID_ICursorFind;

interface ICursorFind : public IUnknown
{
public:
	virtual HRESULT STDMETHODCALLTYPE FindByValues
	(
	ULONG            cbBookmark,
	LPVOID           pBookmark,
	DWORD            dwFindFlags,
	ULONG            cValues,
		DBCOLUMNID       rgColumns[],
	DBVARIANT        rgValues[],
	DWORD            rgdwSeekFlags[],
		DBFETCHROWS FAR *pFetchParams
	) = 0;
};

#else

/* C Language Binding */
//extern const IID IID_ICursorFind;

typedef struct ICursorFindVtbl
{

	HRESULT (STDMETHODCALLTYPE FAR *QueryInterface)
	(
		ICursorFind FAR *this,
	REFIID riid,
	void **ppvObject
	);

	ULONG (STDMETHODCALLTYPE FAR *AddRef)
	(
		ICursorFind FAR *this
	);

	ULONG (STDMETHODCALLTYPE FAR *Release)
	(
		ICursorFind FAR *this
	);

	HRESULT (STDMETHODCALLTYPE FAR *FindByValues)
	(
		ICursorFind FAR *this,
	ULONG            cbBookmark,
	LPVOID           pBookmark,
	DWORD            dwFindFlags,
	ULONG            cValues,
		DBCOLUMNID       rgColumns[],
	DBVARIANT        rgValues[],
	DWORD            rgdwSeekFlags[],
		DBFETCHROWS      pFetchParams
	);


} ICursorFindVtbl;

interface ICursorFind
{
	ICursorFindVtbl FAR *lpVtbl;
} ;

#ifdef COBJMACROS

#define ICursorFind_QueryInterface(pI, riid, ppvObject) \
	(*(pI)->lpVtbl->QueryInterface)((pI), riid, ppvObject)

#define ICursorFind_AddRef(pI) \
	(*(pI)->lpVtbl->AddRef)((pI))

#define ICursorFind_Release(pI) \
	(*(pI)->lpVtbl->Release)((pI))

#define ICursorFind_FindByValues(pI, cbB, pB, dwFF, cV, rgC, rgV, rgSF, pF) \
	(*(pI)->lpVtbl->FindByValues)((pI), cbB, pB, dwFF, cB, rgC, rgV, rgSF, pF)

#endif /* COBJMACROS */

#endif


/*----------------------------------------------------------------------------
 *
 *  IEntryID
 *
 *----------------------------------------------------------------------------
 */
/* Forward declaration */
//typedef interface IEntryID IEntryID;

#if defined(__cplusplus) && !defined(CINTERFACE)

/* C++ Language Binding */
//extern "C" const IID IID_IEntryID;

interface IEntryID : public IUnknown
{
public:
	virtual HRESULT STDMETHODCALLTYPE GetInterface
	(
	ULONG cbEntryID,
	void *pEntryID,
		DWORD dwFlags,
		REFIID riid,
	IUnknown **ppvObj
	) = 0;

};

#else

/* C Language Binding */
//extern const IID IID_IEntryID;

typedef struct IEntryIDVtbl
{

	HRESULT (STDMETHODCALLTYPE FAR *QueryInterface)
	(
		IEntryID FAR *this,
	REFIID riid,
	void **ppvObject
	);

	ULONG (STDMETHODCALLTYPE FAR *AddRef)
	(
		IEntryID FAR *this
	);

	ULONG (STDMETHODCALLTYPE FAR *Release)
	(
		IEntryID FAR *this
	);

	HRESULT (STDMETHODCALLTYPE FAR *GetInterface)
	(
		IEntryID FAR *this,
	ULONG cbEntryID,
	void *pEntryID,
		REFIID riid,
	IUnknown **ppvObj
	);

} IEntryIDVtbl;

interface IEntryID
{
	IEntryIDVtbl FAR *lpVtbl;
} ;

#ifdef COBJMACROS

#define IEntryID_QueryInterface(pI, riid, ppvObject) \
	(*(pI)->lpVtbl->QueryInterface)((pI), riid, ppvObject)

#define IEntryID_AddRef(pI) \
	(*(pI)->lpVtbl->AddRef)((pI))

#define IEntryID_Release(pI) \
	(*(pI)->lpVtbl->Release)((pI))

#define IEntryID_GetInterface(pI, cbEntryID, pEntryID, riid, ppvObj) \
	(*(pI)->lpVtbl->GetInterface)((pI), cbEntryID, pEntryID, riid, ppvObj)
#endif /* COBJMACROS */

#endif


/*----------------------------------------------------------------------------
 *
 *  INotifyDBEvents
 *
 *----------------------------------------------------------------------------
 */
/* Forward declaration */
//typedef interface INotifyDBEvents INotifyDBEvents;

#if defined(__cplusplus) && !defined(CINTERFACE)

/* C++ Language Binding */
//extern "C" const IID IID_INotifyDBEvents;

interface INotifyDBEvents : public IUnknown
{
public:
	virtual HRESULT STDMETHODCALLTYPE OKToDo
	(
	DWORD dwEventWhat,
	ULONG cReasons,
	DBNOTIFYREASON rgReasons[]
	) = 0;

	virtual HRESULT STDMETHODCALLTYPE Cancelled
	(
	DWORD dwEventWhat,
	ULONG cReasons,
	DBNOTIFYREASON rgReasons[]
	) = 0;

	virtual HRESULT STDMETHODCALLTYPE SyncBefore
	(
	DWORD dwEventWhat,
	ULONG cReasons,
	DBNOTIFYREASON rgReasons[]
	) = 0;

	virtual HRESULT STDMETHODCALLTYPE AboutToDo
	(
	DWORD dwEventWhat,
	ULONG cReasons,
	DBNOTIFYREASON rgReasons[]
	) = 0;

	virtual HRESULT STDMETHODCALLTYPE FailedToDo
	(
	DWORD dwEventWhat,
	ULONG cReasons,
	DBNOTIFYREASON rgReasons[]
	) = 0;

	virtual HRESULT STDMETHODCALLTYPE SyncAfter
	(
	DWORD dwEventWhat,
	ULONG cReasons,
	DBNOTIFYREASON rgReasons[]
	) = 0;

	virtual HRESULT STDMETHODCALLTYPE DidEvent
	(
	DWORD dwEventWhat,
	ULONG cReasons,
	DBNOTIFYREASON rgReasons[]
	) = 0;

};

#else

/* C Language Binding */
extern const IID IID_INotifyDBEvents;

typedef struct INotifyDBEventsVtbl
{

	HRESULT (STDMETHODCALLTYPE FAR *QueryInterface)
	(
		INotifyDBEvents FAR *this,
	REFIID riid,
	void **ppvObject
	);

	ULONG (STDMETHODCALLTYPE FAR *AddRef)
	(
		INotifyDBEvents FAR *this
	);

	ULONG (STDMETHODCALLTYPE FAR *Release)
	(
		INotifyDBEvents FAR *this
	);

	HRESULT (STDMETHODCALLTYPE FAR *OKToDo)
	(
		INotifyDBEvents FAR *this,
	DWORD dwEventWhat,
	ULONG cReasons,
	DBNOTIFYREASON rgReasons[]
	);

	HRESULT (STDMETHODCALLTYPE FAR *Cancelled)
	(
		INotifyDBEvents FAR *this,
	DWORD dwEventWhat,
	ULONG cReasons,
	DBNOTIFYREASON rgReasons[]
	);

	HRESULT (STDMETHODCALLTYPE FAR *SyncBefore)
	(
		INotifyDBEvents FAR *this,
	DWORD dwEventWhat,
	ULONG cReasons,
	DBNOTIFYREASON rgReasons[]
	);

	HRESULT (STDMETHODCALLTYPE FAR *AboutToDo)
	(
		INotifyDBEvents FAR *this,
	DWORD dwEventWhat,
	ULONG cReasons,
	DBNOTIFYREASON rgReasons[]
	);

	HRESULT (STDMETHODCALLTYPE FAR *FailedToDo)
	(
		INotifyDBEvents FAR *this,
	DWORD dwEventWhat,
	ULONG cReasons,
	DBNOTIFYREASON rgReasons[]
	);

	HRESULT (STDMETHODCALLTYPE FAR *SyncAfter)
	(
		INotifyDBEvents FAR *this,
	DWORD dwEventWhat,
	ULONG cReasons,
	DBNOTIFYREASON rgReasons[]
	);

	HRESULT (STDMETHODCALLTYPE FAR *DidEvent)
	(
		INotifyDBEvents FAR *this,
	DWORD dwEventWhat,
	ULONG cReasons,
	DBNOTIFYREASON rgReasons[]
	);

} INotifyDBEventsVtbl;

interface INotifyDBEvents
{
	INotifyDBEventsVtbl FAR *lpVtbl;
} ;

#ifdef COBJMACROS

#define INotifyDBEvents_QueryInterface(pI, riid, ppvObject) \
	(*(pI)->lpVtbl->QueryInterface)((pI), riid, ppvObject)

#define INotifyDBEvents_AddRef(pI) \
	(*(pI)->lpVtbl->AddRef)((pI))

#define INotifyDBEvents_Release(pI) \
	(*(pI)->lpVtbl->Release)((pI))

#define INotifyDBEvents_OKToDo(pI, dwEventWhat, cReasons, rgReasons) \
	(*(pI)->lpVtbl->OKToDo)((pI), dwEventWhat, cReasons, rgReasons)

#define INotifyDBEvents_Cancelled(pI, dwEventWhat, cReasons, rgReasons) \
	(*(pI)->lpVtbl->Cancelled)((pI), dwEventWhat, cReasons, rgReasons)

#define INotifyDBEvents_SyncBefore(pI, dwEventWhat, cReasons, rgReasons) \
	(*(pI)->lpVtbl->SyncBefore)((pI), dwEventWhat, cReasons, rgReasons)

#define INotifyDBEvents_AboutToDo(pI, dwEventWhat, cReasons, rgReasons) \
	(*(pI)->lpVtbl->AboutToDo)((pI), dwEventWhat, cReasons, rgReasons)

#define INotifyDBEvents_FailedToDo(pI, dwEventWhat, cReasons, rgReasons) \
	(*(pI)->lpVtbl->FailedToDo)((pI), dwEventWhat, cReasons, rgReasons)

#define INotifyDBEvents_SyncAfter(pI, dwEventWhat, cReasons, rgReasons) \
	(*(pI)->lpVtbl->SyncAfter)((pI), dwEventWhat, cReasons, rgReasons)

#define INotifyDBEvents_DidEvent(pI, dwEventWhat, cReasons, rgReasons) \
	(*(pI)->lpVtbl->DidEvent)((pI), dwEventWhat, cReasons, rgReasons)
#endif /* COBJMACROS */

#endif


#ifdef __cplusplus
}
#endif

#define __OCDB_H_
#endif // __OCDB_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\include\statreg.cpp ===
// This is a part of the Active Template Library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Active Template Library Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Active Template Library product.

#pragma message("statreg.cpp is obsolete. Please remove it from your project.")

///////////////////////////////////////
// No longer used
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\include\olebind.h ===
/*****************************************************************************\
*                                                                             *
* olebind.h     Data binding interfaces for OLE                               *
*                                                                             *
*               OLE Version 2.0                                               *
*                                                                             *
*               Copyright (c) Microsoft Corp. All rights reserved.            *
*                                                                             *
\*****************************************************************************/

#if !defined( _OLEBIND_H_ )
#define _OLEBIND_H_

#if !defined( INITGUID )
#include <olectl.h>
#endif

DEFINE_GUID(IID_IBoundObject,
	0x9BFBBC00,0xEFF1,0x101A,0x84,0xED,0x00,0xAA,0x00,0x34,0x1D,0x07);
DEFINE_GUID(IID_IBoundObjectSite,
	0x9BFBBC01,0xEFF1,0x101A,0x84,0xED,0x00,0xAA,0x00,0x34,0x1D,0x07);

typedef interface IBoundObject FAR* LPBOUNDOBJECT;
typedef interface IBoundObjectSite FAR* LPBOUNDOBJECTSITE;

typedef interface ICursor FAR* LPCURSOR;
typedef interface ICursor FAR* FAR* LPLPCURSOR;
typedef interface ICursorMove FAR* LPCURSORMOVE;
typedef interface ICursorScroll FAR* LPCURSORSCROLL;
typedef interface ICursorFind FAR* LPCURSORFIND;
typedef interface ICursorUpdateARow FAR* LPCURSORUPDATEAROW;

//////////////////////////////////////////////////////////////////////////////
//
//  IBoundObject interface
//
//////////////////////////////////////////////////////////////////////////////

#undef  INTERFACE
#define INTERFACE IBoundObject

DECLARE_INTERFACE_(IBoundObject, IUnknown)
{
	//
	//  IUnknown methods
	//
	STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
	STDMETHOD_(ULONG,AddRef)(THIS) PURE;
	STDMETHOD_(ULONG,Release)(THIS) PURE;

	//
	//  IBoundObject methods
	//
	STDMETHOD(OnSourceChanged)(THIS_ DISPID dispid, BOOL fBound, BOOL FAR* lpfOwnXferOut) PURE;
	STDMETHOD(IsDirty)(THIS_ DISPID dispid) PURE;
};
//////////////////////////////////////////////////////////////////////////////
//
//  IBoundObjectSite interface
//
//////////////////////////////////////////////////////////////////////////////

#undef  INTERFACE
#define INTERFACE IBoundObjectSite

DECLARE_INTERFACE_(IBoundObjectSite, IUnknown)
{
	//
	//  IUnknown methods
	//
	STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
	STDMETHOD_(ULONG,AddRef)(THIS) PURE;
	STDMETHOD_(ULONG,Release)(THIS) PURE;

	//
	//  IBoundObjectSite methods
	//
	STDMETHOD(GetCursor)(THIS_ DISPID dispid, LPLPCURSOR ppCursor, LPVOID FAR* ppcidOut) PURE;
};


#endif // !defined( _OLEBIND_H_ )
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\include\cstringt.inl ===
// This is a part of the Active Template Library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Active Template Library Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Active Template Library product.

#pragma once

#ifndef __ATLCOMCLI_H__
#error AtlComCli.h should be included before including this file.
#endif

namespace ATL
{

template< typename BaseType, class StringTraits >
CStringT< BaseType, StringTraits >::CStringT(_In_ const VARIANT& varSrc) :
	CThisSimpleString( StringTraits::GetDefaultManager() )
{
	CComVariant varResult;
	HRESULT hr = ::VariantChangeType( &varResult, const_cast< VARIANT* >( &varSrc ), 0, VT_BSTR );
	if( FAILED( hr ) )
	{
		AtlThrow( hr );
	}

	*this = V_BSTR( &varResult );
}

template< typename BaseType, class StringTraits >
CStringT< BaseType, StringTraits >::CStringT(
		_In_ const VARIANT& varSrc,
		_In_ IAtlStringMgr* pStringMgr) :
	CThisSimpleString( pStringMgr )
{
	CComVariant varResult;
	HRESULT hr = ::VariantChangeType( &varResult, const_cast< VARIANT* >( &varSrc ), 0, VT_BSTR );
	if( FAILED( hr ) )
	{
		AtlThrow( hr );
	}

	*this = V_BSTR( &varResult );
}

template< typename BaseType, class StringTraits >
CStringT< BaseType, StringTraits >& CStringT< BaseType, StringTraits >::operator=(
	_In_ const VARIANT& var)
{
	CComVariant varResult;
	HRESULT hr = ::VariantChangeType( &varResult, const_cast< VARIANT* >( &var ), 0, VT_BSTR );
	if( FAILED( hr ) )
	{
		AtlThrow( hr );
	}

	*this = V_BSTR( &varResult );

	return( *this );
}

template< typename BaseType, class StringTraits >
CStringT< BaseType, StringTraits >& CStringT< BaseType, StringTraits >::operator+=(
	_In_ const VARIANT& var)
{
	CComVariant varResult;
	HRESULT hr = ::VariantChangeType( &varResult, const_cast< VARIANT* >( &var ), 0, VT_BSTR );
	if( FAILED( hr ) )
	{
		AtlThrow( hr );
	}

	*this += V_BSTR( &varResult );

	return( *this );
}

}	// namespace ATL
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\include\cstringt.h ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

/////////////////////////////////////////////////////////////////////////////
// CSTRINGT.H - Framework-independent, templateable string class

#ifndef __CSTRINGT_H__
#define __CSTRINGT_H__

#pragma once

#ifndef _ATL_NO_PRAGMA_WARNINGS
#pragma warning (push)
#pragma warning(disable : 4668)	// is not defined as a preprocessor macro, replacing with '0' for '#if/#elif
#pragma warning(disable : 4820)	// padding added after member
#pragma warning(disable : 4127)  // conditional expression constant
#endif //!_ATL_NO_PRAGMA_WARNINGS

#pragma warning(disable:4786)	// avoid 255-character limit warnings

#ifdef _MANAGED
#include <vcclr.h>  // For PtrToStringChars
#endif

#include <atlsimpstr.h>
#include <stddef.h>

#ifndef _INC_NEW
#include <new.h>
#endif

#include <stdio.h>
#include <wchar.h>
#include <limits.h>
#include <mbstring.h>

#ifdef _ATL_CSTRING_EXPLICIT_CONSTRUCTORS
#define CSTRING_EXPLICIT explicit
#else
#define CSTRING_EXPLICIT
#endif

#include <atlconv.h>
#include <atlmem.h>

struct tagVARIANT;
typedef tagVARIANT VARIANT;

#ifndef _AFX
#define _AFX_FUNCNAME(_Name) _Name
#endif

#pragma push_macro("new")
#undef new

#if defined(_AFX)
#pragma push_macro("FormatMessage")
#undef FormatMessage
#endif

/////////////////////////////////////////////////////////////////////////////
// Naming conventions:
//    The term "length" can be confusing when dealing with ANSI, Unicode, and
//    MBCS character sets, so this file will use the following naming
//    conventions to differentiate between the different meanings of
//    "length":
//
//    'Byte Length' - Length of a buffer in bytes, regardless of character
//       size
//    'Char Length' - Number of distinct characters in string.  For wide-
//       character strings, this is equivalent to half the 'Byte Length'.
//       For ANSI strings, this is equivalent to the 'Byte Length'.  For MBCS
//       strings, 'Char Length' counts a lead-byte/trail-byte combination
//       as one character.
//    'Length' - When neither of the above terms is used, 'Length' refers to
//       length in XCHARs, which is equal to 'Byte Length'/sizeof(XCHAR).
/////////////////////////////////////////////////////////////////////////////

namespace ATL
{

// This struct have the same memory layout as CString and is used to enable
// const statically initialized CString without making a copy on the heap
template <class StringType,int t_nChars> struct CConstFixedStringT
{
	CStringData m_data;
	typename StringType::XCHAR m_achData[t_nChars];
};

#define IMPLEMENT_CONST_STRING_PTR(StringType, value, name) const CConstFixedStringT<StringType, sizeof(value)/sizeof(StringType::XCHAR)> _init##name ={ 	{NULL,		sizeof(value)/sizeof(StringType::XCHAR)-1, 	sizeof(value)/sizeof(StringType::XCHAR)-1, 	-1},			value	};	const StringType::XCHAR* const _value##name = _init##name.m_achData;	extern const StringType* const name = CONST_STRING_PTR(StringType, name);
#define DECLARE_CONST_STRING_PTR(StringType, name) extern const StringType* const name;
#define CONST_STRING_PTR(StringType, name) reinterpret_cast<const StringType* const>(&_value##name)

/////////////////////////////////////////////////////////////////////////////
// inline helpers

inline int _wcstombsz(
	_Out_cap_(count) char* mbstr,
	_In_z_ const wchar_t* wcstr,
	_In_ ULONG count) throw()
{
	// count is number of bytes
	if (count == 0 && mbstr != NULL)
		return 0;

	int result = ::WideCharToMultiByte(_AtlGetConversionACP(), 0, wcstr, -1,
		mbstr, count, NULL, NULL);
	ATLASSERT(mbstr == NULL || result <= (int)count);
	return result;
}

inline int _mbstowcsz(
	_Out_cap_(count) wchar_t* wcstr,
	_In_z_ const char* mbstr,
	_In_ ULONG count)
{
	// count is number of wchar_t's
	if (count == 0 && wcstr != NULL)
		return 0;

	int result = ::MultiByteToWideChar(_AtlGetConversionACP(), 0, mbstr, -1,
		wcstr, count);
	ATLENSURE(wcstr == NULL || result <= (int)count);
	if ((result > 0) && (wcstr != NULL))
	{
		wcstr[result-1] = 0;
	}

	return result;
}

/////////////////////////////////////////////////////////////////////////////
//

template< typename _CharType = char >
class ChTraitsCRT :
	public ChTraitsBase< _CharType >
{
public:
	static char* __cdecl CharNext(_In_ const char* p) throw()
	{
		return reinterpret_cast< char* >( _mbsinc( reinterpret_cast< const unsigned char* >( p ) ) );
	}

	static int __cdecl IsDigit(_In_ char ch) throw()
	{
		return _ismbcdigit( ch );
	}

	static int __cdecl IsSpace(_In_ char ch) throw()
	{
		return _ismbcspace( ch );
	}

	static int __cdecl StringCompare(
		_In_z_ LPCSTR pszA,
		_In_z_ LPCSTR pszB) throw()
	{
		return _mbscmp( reinterpret_cast< const unsigned char* >( pszA ), reinterpret_cast< const unsigned char* >( pszB ) );
	}

	static int __cdecl StringCompareIgnore(
		_In_z_ LPCSTR pszA,
		_In_z_ LPCSTR pszB) throw()
	{
		return _mbsicmp( reinterpret_cast< const unsigned char* >( pszA ), reinterpret_cast< const unsigned char* >( pszB ) );
	}

	static int __cdecl StringCollate(
		_In_z_ LPCSTR pszA,
		_In_z_ LPCSTR pszB) throw()
	{
		return _mbscoll( reinterpret_cast< const unsigned char* >( pszA ), reinterpret_cast< const unsigned char* >( pszB ) );
	}

	static int __cdecl StringCollateIgnore(
		_In_z_ LPCSTR pszA,
		_In_z_ LPCSTR pszB) throw()
	{
		return _mbsicoll( reinterpret_cast< const unsigned char* >( pszA ), reinterpret_cast< const unsigned char* >( pszB ) );
	}

	static LPCSTR __cdecl StringFindString(
		_In_z_ LPCSTR pszBlock,
		_In_z_ LPCSTR pszMatch) throw()
	{
		return reinterpret_cast< LPCSTR >( _mbsstr( reinterpret_cast< const unsigned char* >( pszBlock ),
			reinterpret_cast< const unsigned char* >( pszMatch ) ) );
	}

	static LPSTR __cdecl StringFindString(
		_In_z_ LPSTR pszBlock,
		_In_z_ LPCSTR pszMatch) throw()
	{
		return( const_cast< LPSTR >( StringFindString( const_cast< LPCSTR >( pszBlock ), pszMatch ) ) );
	}

	static LPCSTR __cdecl StringFindChar(
		_In_z_ LPCSTR pszBlock,
		_In_ char chMatch) throw()
	{
		return reinterpret_cast< LPCSTR >( _mbschr( reinterpret_cast< const unsigned char* >( pszBlock ), (unsigned char)chMatch ) );
	}

	static LPCSTR __cdecl StringFindCharRev(
		_In_z_ LPCSTR psz,
		_In_ char ch) throw()
	{
		return reinterpret_cast< LPCSTR >( _mbsrchr( reinterpret_cast< const unsigned char* >( psz ), (unsigned char)ch ) );
	}

	static LPCSTR __cdecl StringScanSet(
		_In_z_ LPCSTR pszBlock,
		_In_z_ LPCSTR pszMatch) throw()
	{
		return reinterpret_cast< LPCSTR >( _mbspbrk( reinterpret_cast< const unsigned char* >( pszBlock ),
			reinterpret_cast< const unsigned char* >( pszMatch ) ) );
	}

	static int __cdecl StringSpanIncluding(
		_In_z_ LPCSTR pszBlock,
		_In_z_ LPCSTR pszSet) throw()
	{
		return (int)_mbsspn( reinterpret_cast< const unsigned char* >( pszBlock ), reinterpret_cast< const unsigned char* >( pszSet ) );
	}

	static int __cdecl StringSpanExcluding(
		_In_z_ LPCSTR pszBlock,
		_In_z_ LPCSTR pszSet) throw()
	{
		return (int)_mbscspn( reinterpret_cast< const unsigned char* >( pszBlock ), reinterpret_cast< const unsigned char* >( pszSet ) );
	}

	_ATL_INSECURE_DEPRECATE("You must pass an output size to ChTraitsCRT::StringUppercase")
	static LPSTR __cdecl StringUppercase(_Inout_z_ LPSTR psz) throw()
	{
#pragma warning (push)
#pragma warning(disable : 4996)
		return reinterpret_cast< LPSTR >( _mbsupr( reinterpret_cast< unsigned char* >( psz ) ) );
#pragma warning (pop)
	}

	_ATL_INSECURE_DEPRECATE("You must pass an output size to ChTraitsCRT::StringLowercase")
	static LPSTR __cdecl StringLowercase(_Inout_z_ LPSTR psz) throw()
	{
#pragma warning (push)
#pragma warning(disable : 4996)
		return reinterpret_cast< LPSTR >( _mbslwr( reinterpret_cast< unsigned char* >( psz ) ) );
#pragma warning (pop)
	}

	static LPSTR __cdecl StringUppercase(
		_Inout_z_cap_(size) LPSTR psz,
		_In_ size_t size) throw()
	{
		Checked::mbsupr_s(reinterpret_cast< unsigned char* >( psz ), size);
		return psz;
	}

	static LPSTR __cdecl StringLowercase(
		_Inout_z_cap_(size) LPSTR psz,
		_In_ size_t size) throw()
	{
		Checked::mbslwr_s( reinterpret_cast< unsigned char* >( psz ), size );
		return psz;
	}

	static LPSTR __cdecl StringReverse(_Inout_z_ LPSTR psz) throw()
	{
		return reinterpret_cast< LPSTR >( _mbsrev( reinterpret_cast< unsigned char* >( psz ) ) );
	}

	static int __cdecl GetFormattedLength(
		_In_z_ _Printf_format_string_ LPCSTR pszFormat, va_list args) throw()
	{
		return _vscprintf( pszFormat, args );
	}

	_ATL_INSECURE_DEPRECATE("You must pass an output size to ChTraitsCRT::Format")
	static int __cdecl Format(
		_Out_ _Post_z_ LPSTR pszBuffer,
		_In_z_ _Printf_format_string_ LPCSTR pszFormat,
		va_list args ) throw()
	{
#pragma warning (push)
#pragma warning(disable : 4995)
#pragma warning(disable : 4996)
		return vsprintf( pszBuffer, pszFormat, args );
#pragma warning (pop)
	}
	static int __cdecl Format(
		_Out_z_cap_post_count_(nlength, return) LPSTR pszBuffer,
		_In_ size_t nlength,
		_In_z_ _Printf_format_string_ LPCSTR pszFormat, va_list args ) throw()
	{
		return vsprintf_s( pszBuffer, nlength, pszFormat, args );
	}

	static int __cdecl GetBaseTypeLength(_In_z_ LPCSTR pszSrc) throw()
	{
		// Returns required buffer length in XCHARs
		return int( strlen( pszSrc ) );
	}

	static int __cdecl GetBaseTypeLength(
		_In_z_count_(nLength) LPCSTR pszSrc,
		_In_ int nLength) throw()
	{
		(void)pszSrc;
		// Returns required buffer length in XCHARs
		return nLength;
	}

	static int __cdecl GetBaseTypeLength(_In_z_ LPCWSTR pszSource) throw()
	{
		// Returns required buffer length in XCHARs
		return ::WideCharToMultiByte( _AtlGetConversionACP(), 0, pszSource, -1, NULL, 0, NULL, NULL )-1;
	}

	static int __cdecl GetBaseTypeLength(
		_In_count_(nLength) LPCWSTR pszSource,
		_In_ int nLength) throw()
	{
		// Returns required buffer length in XCHARs
		return ::WideCharToMultiByte( _AtlGetConversionACP(), 0, pszSource, nLength, NULL, 0, NULL, NULL );
	}

	static void __cdecl ConvertToBaseType(
		_Out_cap_(nDestLength) LPSTR pszDest,
		_In_ int nDestLength,
		_In_z_ LPCSTR pszSrc,
		_In_ int nSrcLength = -1) throw()
	{
		if (nSrcLength == -1) { nSrcLength=1 + GetBaseTypeLength(pszSrc); }
		// nLen is in XCHARs
		Checked::memcpy_s( pszDest, nDestLength*sizeof( char ),
			pszSrc, nSrcLength*sizeof( char ) );
	}

	static void __cdecl ConvertToBaseType(
		_Out_cap_(nDestLength) LPSTR pszDest,
		_In_ int nDestLength,
		_In_ LPCWSTR pszSrc,
		_In_ int nSrcLength = -1) throw()
	{
		// nLen is in XCHARs
		::WideCharToMultiByte( _AtlGetConversionACP(), 0, pszSrc, nSrcLength, pszDest, nDestLength, NULL, NULL );
	}

	_ATL_INSECURE_DEPRECATE("You must pass an output size to ChTraitsCRT::ConvertToOem")
	static void ConvertToOem(_Inout_ _CharType* pstrString) throw()
	{
		BOOL fSuccess=::CharToOemA(pstrString, pstrString);
		// old version can't report error
		ATLASSERT(fSuccess);
	}

	_ATL_INSECURE_DEPRECATE("You must pass an output size to ChTraitsCRT::ConvertToAnsi")
	static void ConvertToAnsi(_Inout_ _CharType* pstrString) throw()
	{
		BOOL fSuccess=::OemToCharA(pstrString, pstrString);
		// old version can't report error
		ATLASSERT(fSuccess);
	}

	static void ConvertToOem(
		_Inout_cap_(size) _CharType* pstrString,
		_In_ size_t size)
	{
		if(size>UINT_MAX)
		{
			// API only allows DWORD size
			AtlThrow(E_INVALIDARG);
		}
		DWORD dwSize=static_cast<DWORD>(size);
		BOOL fSuccess=::CharToOemBuffA(pstrString, pstrString, dwSize);
		if(!fSuccess)
		{
			AtlThrowLastWin32();
		}
	}

	static void ConvertToAnsi(
		_Inout_cap_(size) _CharType* pstrString,
		_In_ size_t size)
	{
		if(size>UINT_MAX)
		{
			// API only allows DWORD size
			AtlThrow(E_INVALIDARG);
		}
		DWORD dwSize=static_cast<DWORD>(size);
		BOOL fSuccess=::OemToCharBuffA(pstrString, pstrString, dwSize);
		if(!fSuccess)
		{
			AtlThrowLastWin32();
		}
	}

	static void __cdecl FloodCharacters(
		_In_ char ch,
		_In_ int nLength,
		_Out_capcount_(nLength) char* pch) throw()
	{
		// nLength is in XCHARs
		memset( pch, ch, nLength );
	}

	static BSTR __cdecl AllocSysString(
		_In_count_(nDataLength) const char* pchData,
		_In_ int nDataLength) throw()
	{
		int nLen = ::MultiByteToWideChar( _AtlGetConversionACP(), 0, pchData, nDataLength,
			NULL, NULL );
		BSTR bstr = ::SysAllocStringLen( NULL, nLen );
		if( bstr != NULL )
		{
			::MultiByteToWideChar( _AtlGetConversionACP(), 0, pchData, nDataLength,
				bstr, nLen );
		}

		return bstr;
	}

	static BOOL __cdecl ReAllocSysString(
		_In_count_(nDataLength) const char* pchData,
		_Inout_ _Deref_post_opt_valid_ _Post_z_ BSTR* pbstr,
		_In_ int nDataLength) throw()
	{
		int nLen = ::MultiByteToWideChar( _AtlGetConversionACP(), 0, pchData, nDataLength, NULL, NULL );
		BOOL bSuccess = ::SysReAllocStringLen( pbstr, NULL, nLen );
		if( bSuccess )
		{
			::MultiByteToWideChar( _AtlGetConversionACP(), 0, pchData, nDataLength, *pbstr, nLen );
		}

		return bSuccess;
	}

	static DWORD __cdecl _AFX_FUNCNAME(FormatMessage)(
		_In_ DWORD dwFlags,
		_In_opt_ LPCVOID pSource,
		_In_ DWORD dwMessageID,
		_In_ DWORD dwLanguageID,
		_Out_z_cap_(nSize) LPSTR pszBuffer,
		_In_ DWORD nSize,
		_In_opt_ va_list* pArguments) throw()
	{
		return ::FormatMessageA( dwFlags, pSource, dwMessageID, dwLanguageID,
				pszBuffer, nSize, pArguments );
	}

#if defined(_AFX)
	static DWORD __cdecl FormatMessage(
		_In_ DWORD dwFlags,
		_In_opt_ LPCVOID pSource,
		_In_ DWORD dwMessageID,
		_In_ DWORD dwLanguageID,
		_Out_z_cap_(nSize) LPSTR pszBuffer,
		_In_ DWORD nSize,
		_In_opt_ va_list* pArguments) throw()
	{
		return _AFX_FUNCNAME(FormatMessage)(dwFlags, pSource, dwMessageID, dwLanguageID, pszBuffer, nSize, pArguments);
	}
#endif

	static int __cdecl SafeStringLen(_In_opt_z_ LPCSTR psz) throw()
	{
		// returns length in bytes
		return (psz != NULL) ? int( strlen( psz ) ) : 0;
	}

	static int __cdecl SafeStringLen(_In_opt_z_ LPCWSTR psz) throw()
	{
		// returns length in wchar_ts
		return (psz != NULL) ? int( wcslen( psz ) ) : 0;
	}

	static int __cdecl GetCharLen(_In_opt_z_ const wchar_t* pch) throw()
	{
		(void)pch;
		// returns char length
		return 1;
	}

	static int __cdecl GetCharLen(_In_z_ const char* pch) throw()
	{
		// returns char length
		return int( _mbclen( reinterpret_cast< const unsigned char* >( pch ) ) );
	}

	static DWORD __cdecl GetEnvironmentVariable(
		_In_z_ LPCSTR pszVar,
		_Out_opt_z_cap_(dwSize) LPSTR pszBuffer,
		_In_ DWORD dwSize) throw()
	{
		return ::GetEnvironmentVariableA( pszVar, pszBuffer, dwSize );
	}
};

// specialization for wchar_t
template<>
class ChTraitsCRT< wchar_t > :
	public ChTraitsBase< wchar_t >
{
	static DWORD __cdecl _GetEnvironmentVariableW(
		_In_z_ LPCWSTR pszName,
		_Out_opt_z_cap_post_count_(nSize, return) LPWSTR pszBuffer,
		_In_ DWORD nSize) throw()
	{
		return ::GetEnvironmentVariableW( pszName, pszBuffer, nSize );
	}

public:
	static LPWSTR __cdecl CharNext(_In_ LPCWSTR psz) throw()
	{
		return const_cast< LPWSTR >( psz+1 );
	}

	static int __cdecl IsDigit(_In_ wchar_t ch) throw()
	{
		return iswdigit( static_cast<unsigned short>(ch) );
	}

	static int __cdecl IsSpace(_In_ wchar_t ch) throw()
	{
		return iswspace( static_cast<unsigned short>(ch) );
	}

	static int __cdecl StringCompare(
		_In_z_ LPCWSTR pszA,
		_In_z_ LPCWSTR pszB) throw()
	{
		return wcscmp( pszA, pszB );
	}

	static int __cdecl StringCompareIgnore(
		_In_z_ LPCWSTR pszA,
		_In_z_ LPCWSTR pszB) throw()
	{
		return _wcsicmp( pszA, pszB );
	}

	static int __cdecl StringCollate(
		_In_z_ LPCWSTR pszA,
		_In_z_ LPCWSTR pszB) throw()
	{
		return wcscoll( pszA, pszB );
	}

	static int __cdecl StringCollateIgnore(
		_In_z_ LPCWSTR pszA,
		_In_z_ LPCWSTR pszB) throw()
	{
		return _wcsicoll( pszA, pszB );
	}

	static LPCWSTR __cdecl StringFindString(
		_In_z_ LPCWSTR pszBlock,
		_In_z_ LPCWSTR pszMatch) throw()
	{
		return wcsstr( pszBlock, pszMatch );
	}

	static LPWSTR __cdecl StringFindString(
		_In_z_ LPWSTR pszBlock,
		_In_z_ LPCWSTR pszMatch) throw()
	{
		return( const_cast< LPWSTR >( StringFindString( const_cast< LPCWSTR >( pszBlock ), pszMatch ) ) );
	}

	static LPCWSTR __cdecl StringFindChar(
		_In_z_ LPCWSTR pszBlock,
		_In_ wchar_t chMatch) throw()
	{
		return wcschr( pszBlock, chMatch );
	}

	static LPCWSTR __cdecl StringFindCharRev(
		_In_z_ LPCWSTR psz,
		_In_ wchar_t ch) throw()
	{
		return wcsrchr( psz, ch );
	}

	static LPCWSTR __cdecl StringScanSet(
		_In_z_ LPCWSTR pszBlock,
		_In_z_ LPCWSTR pszMatch) throw()
	{
		return wcspbrk( pszBlock, pszMatch );
	}

	static int __cdecl StringSpanIncluding(
		_In_z_ LPCWSTR pszBlock,
		_In_z_ LPCWSTR pszSet) throw()
	{
		return (int)wcsspn( pszBlock, pszSet );
	}

	static int __cdecl StringSpanExcluding(
		_In_z_ LPCWSTR pszBlock,
		_In_z_ LPCWSTR pszSet) throw()
	{
		return (int)wcscspn( pszBlock, pszSet );
	}

	_ATL_INSECURE_DEPRECATE("You must pass an output size to ChTraitsCRT::StringUppercase")
	static LPWSTR __cdecl StringUppercase(_Inout_z_ LPWSTR psz) throw()
	{
#pragma warning (push)
#pragma warning(disable : 4996)
		return _wcsupr( psz );
#pragma warning (pop)
	}

	_ATL_INSECURE_DEPRECATE("You must pass an output size to ChTraitsCRT::StringLowercase")
	static LPWSTR __cdecl StringLowercase(_Inout_z_ LPWSTR psz) throw()
	{
#pragma warning (push)
#pragma warning(disable : 4996)
		return _wcslwr( psz );
#pragma warning (pop)
	}

	static LPWSTR __cdecl StringUppercase(
		_Inout_cap_(size) LPWSTR psz,
		_In_ size_t size) throw()
	{
		errno_t err = _wcsupr_s( psz, size );
		return (err == 0) ? psz : NULL;
	}

	static LPWSTR __cdecl StringLowercase(
		_Inout_cap_(size) LPWSTR psz,
		_In_ size_t size) throw()
	{
		errno_t err = _wcslwr_s( psz, size );
		return (err == 0) ? psz : NULL;
	}

	static LPWSTR __cdecl StringReverse(_Inout_z_ LPWSTR psz) throw()
	{
		return _wcsrev( psz );
	}

	static int __cdecl GetFormattedLength(
		_In_z_ _Printf_format_string_ LPCWSTR pszFormat, va_list args) throw()
	{
		return _vscwprintf( pszFormat, args );
	}

	_ATL_INSECURE_DEPRECATE("You must pass an output size to ChTraitsCRT::Format")
	static int __cdecl Format(
		_Out_ _Post_z_ LPWSTR pszBuffer,
		_In_ _Printf_format_string_ LPCWSTR pszFormat, va_list args) throw()
	{
#pragma warning (push)
#pragma warning(disable : 4995)
#pragma warning(disable : 4996)
		return vswprintf( pszBuffer, pszFormat, args );
#pragma warning (pop)
	}
	static int __cdecl Format(
		_Out_cap_(nLength) LPWSTR pszBuffer,
		_In_ size_t nLength,
		_In_z_ __format_string LPCWSTR pszFormat, va_list args) throw()
	{
		return vswprintf_s( pszBuffer, nLength, pszFormat, args );
	}

	static int __cdecl GetBaseTypeLength(_In_z_ LPCSTR pszSrc) throw()
	{
		// Returns required buffer size in wchar_ts
		return ::MultiByteToWideChar( _AtlGetConversionACP(), 0, pszSrc, -1, NULL, 0 )-1;
	}

	static int __cdecl GetBaseTypeLength(
		_In_count_(nLength) LPCSTR pszSrc,
		_In_ int nLength) throw()
	{
		// Returns required buffer size in wchar_ts
		return ::MultiByteToWideChar( _AtlGetConversionACP(), 0, pszSrc, nLength, NULL, 0 );
	}

	static int __cdecl GetBaseTypeLength(_In_z_ LPCWSTR pszSrc) throw()
	{
		// Returns required buffer size in wchar_ts
		return (int)wcslen( pszSrc );
	}

	static int __cdecl GetBaseTypeLength(
		_In_count_(nLength) LPCWSTR pszSrc,
		_In_ int nLength) throw()
	{
		(void)pszSrc;
		// Returns required buffer size in wchar_ts
		return nLength;
	}

	static void __cdecl ConvertToBaseType(
		_Out_cap_(nDestLength) LPWSTR pszDest,
		_In_ int nDestLength,
		_In_ LPCSTR pszSrc,
		_In_ int nSrcLength = -1) throw()
	{
		// nLen is in wchar_ts
		::MultiByteToWideChar( _AtlGetConversionACP(), 0, pszSrc, nSrcLength, pszDest, nDestLength );
	}

	static void __cdecl ConvertToBaseType(
		_Out_cap_(nDestLength) LPWSTR pszDest,
		_In_ int nDestLength,
		_In_ LPCWSTR pszSrc,
		_In_ int nSrcLength = -1 ) throw()
	{
		if (nSrcLength == -1) { nSrcLength=1 + GetBaseTypeLength(pszSrc); }
		// nLen is in wchar_ts
		Checked::wmemcpy_s(pszDest, nDestLength, pszSrc, nSrcLength);
	}

	static void __cdecl FloodCharacters(
		_In_ wchar_t ch,
		_In_ int nLength,
		_Out_capcount_(nLength) LPWSTR psz) throw()
	{
		// nLength is in XCHARs
		for( int i = 0; i < nLength; i++ )
		{
			psz[i] = ch;
		}
	}

	_Ret_opt_z_ static BSTR __cdecl AllocSysString(
		_In_count_(nDataLength) const wchar_t* pchData,
		_In_ int nDataLength) throw()
	{
		return ::SysAllocStringLen( pchData, nDataLength );
	}

	static BOOL __cdecl ReAllocSysString(
		_In_count_(nDataLength) const wchar_t* pchData,
		_Inout_ _Deref_post_opt_valid_ _Post_z_ BSTR* pbstr,
		_In_ int nDataLength) throw()
	{
		return ::SysReAllocStringLen( pbstr, pchData, nDataLength );
	}

	static int __cdecl SafeStringLen(_In_opt_z_ LPCSTR psz) throw()
	{
		// returns length in bytes
		return (psz != NULL) ? (int)strlen( psz ) : 0;
	}

	static int __cdecl SafeStringLen(_In_opt_z_ LPCWSTR psz) throw()
	{
		// returns length in wchar_ts
		return (psz != NULL) ? (int)wcslen( psz ) : 0;
	}

	static int __cdecl GetCharLen(_In_opt_z_ const wchar_t* pch) throw()
	{
		(void)pch;
		// returns char length
		return 1;
	}

	static int __cdecl GetCharLen(_In_z_ const char* pch) throw()
	{
		// returns char length
		return (int)( _mbclen( reinterpret_cast< const unsigned char* >( pch ) ) );
	}

	static DWORD __cdecl GetEnvironmentVariable(
		_In_z_ LPCWSTR pszVar,
		_Out_opt_z_cap_(dwSize) LPWSTR pszBuffer,
		_In_ DWORD dwSize) throw()
	{
		return _GetEnvironmentVariableW( pszVar, pszBuffer, dwSize );
	}

	static void __cdecl ConvertToOem(_In_opt_z_ LPWSTR /*psz*/)
	{
		ATLENSURE(FALSE); // Unsupported Feature
	}

	static void __cdecl ConvertToAnsi(_In_opt_z_ LPWSTR /*psz*/)
	{
		ATLENSURE(FALSE); // Unsupported Feature
	}

	static void __cdecl ConvertToOem(
		_In_count_(nLen) LPWSTR /*psz*/,
		_In_ size_t nLen)
	{
		UNREFERENCED_PARAMETER(nLen);
		ATLENSURE(FALSE); // Unsupported Feature
	}

	static void __cdecl ConvertToAnsi(
		_In_count_(nLen) LPWSTR /*psz*/,
		_In_ size_t nLen)
	{
		UNREFERENCED_PARAMETER(nLen);
		ATLENSURE(FALSE); // Unsupported Feature
	}

#ifdef _UNICODE
public:
	static DWORD __cdecl _AFX_FUNCNAME(FormatMessage)(
		_In_ DWORD dwFlags,
		_In_opt_ LPCVOID pSource,
		_In_ DWORD dwMessageID,
		_In_ DWORD dwLanguageID,
		_Out_z_cap_(nSize) LPWSTR pszBuffer,
		_In_ DWORD nSize,
		_In_opt_ va_list* pArguments) throw()
	{
		return ::FormatMessageW( dwFlags, pSource, dwMessageID, dwLanguageID,
				pszBuffer, nSize, pArguments );
	}

#if defined(_AFX)
	static DWORD __cdecl FormatMessage(
		_In_ DWORD dwFlags,
		_In_opt_ LPCVOID pSource,
		_In_ DWORD dwMessageID,
		_In_ DWORD dwLanguageID,
		_Out_z_cap_(nSize) LPWSTR pszBuffer,
		_In_ DWORD nSize,
		_In_opt_ va_list* pArguments) throw()
	{
		return _AFX_FUNCNAME(FormatMessage)(dwFlags, pSource, dwMessageID, dwLanguageID, pszBuffer, nSize, pArguments);
	}
#endif

#else
	static DWORD __cdecl _AFX_FUNCNAME(FormatMessage)(
		_In_ DWORD /*dwFlags*/,
		_In_opt_ LPCVOID /*pSource*/,
		_In_ DWORD /*dwMessageID*/,
		_In_ DWORD /*dwLanguageID*/,
		_Out_z_cap_(nSize) LPWSTR /*pszBuffer*/,
		_In_ DWORD nSize,
		_In_opt_ va_list* /*pArguments*/)
	{
		ATLENSURE(FALSE); // Unsupported Feature
		UNREFERENCED_PARAMETER(nSize);
		return 0;
	}

#if defined(_AFX)
	static DWORD __cdecl FormatMessage(
		_In_ DWORD dwFlags,
		_In_opt_ LPCVOID pSource,
		_In_ DWORD dwMessageID,
		_In_ DWORD dwLanguageID,
		_Out_z_cap_(nSize) LPWSTR pszBuffer,
		_In_ DWORD nSize,
		_In_opt_ va_list* pArguments)
	{
		return _AFX_FUNCNAME(FormatMessage)(dwFlags, pSource, dwMessageID, dwLanguageID, pszBuffer, nSize, pArguments);
	}
#endif

#endif

};

}	// namespace ATL

// Forward declare
template< typename _CharType = char, class StringIterator = ATL::ChTraitsCRT< _CharType > >
class StrTraitMFC_DLL;

namespace ATL
{

namespace _CSTRING_IMPL_
{
template <typename _CharType, class StringTraits>
struct _MFCDLLTraitsCheck
{
	const static bool c_bIsMFCDLLTraits = false;
};

template<typename _CharType>
struct _MFCDLLTraitsCheck<_CharType, StrTraitMFC_DLL<_CharType, ATL::ChTraitsCRT< _CharType > > >
{
	const static bool c_bIsMFCDLLTraits = true;
};

}

// The CStringT class has a few varargs member functions that will cause 4793
// warnings if compiled /clr. Because of the way template classes are parsed,
// we need to disable the warning for the entire class.
//#pragma warning( push )
//#pragma warning( disable : 4793 )


template< typename BaseType, class StringTraits >
class CStringT :
	public CSimpleStringT< BaseType, _CSTRING_IMPL_::_MFCDLLTraitsCheck<BaseType, StringTraits>::c_bIsMFCDLLTraits >
{
public:
	typedef CSimpleStringT< BaseType, _CSTRING_IMPL_::_MFCDLLTraitsCheck<BaseType, StringTraits>::c_bIsMFCDLLTraits > CThisSimpleString;
	typedef StringTraits StrTraits;
	typedef typename CThisSimpleString::XCHAR XCHAR;
	typedef typename CThisSimpleString::PXSTR PXSTR;
	typedef typename CThisSimpleString::PCXSTR PCXSTR;
	typedef typename CThisSimpleString::YCHAR YCHAR;
	typedef typename CThisSimpleString::PYSTR PYSTR;
	typedef typename CThisSimpleString::PCYSTR PCYSTR;

public:
	CStringT() throw() :
		CThisSimpleString( StringTraits::GetDefaultManager() )
	{
	}
	explicit CStringT(
			_In_ IAtlStringMgr* pStringMgr) throw() :
		CThisSimpleString( pStringMgr )
	{
	}

	CStringT(_In_ const VARIANT& varSrc);
	CStringT(
		_In_ const VARIANT& varSrc,
		_In_ IAtlStringMgr* pStringMgr);

	static void __cdecl Construct(_In_ CStringT* pString)
	{
		new( pString ) CStringT;
	}

	// Copy constructor
	CStringT(_In_ const CStringT& strSrc) :
		CThisSimpleString( strSrc )
	{
	}

	// Construct from CSimpleStringT
	operator CSimpleStringT<BaseType, !_CSTRING_IMPL_::_MFCDLLTraitsCheck<BaseType, StringTraits>::c_bIsMFCDLLTraits >&()
	{
		return *(CSimpleStringT<BaseType, !_CSTRING_IMPL_::_MFCDLLTraitsCheck<BaseType, StringTraits>::c_bIsMFCDLLTraits >*)this;
	}

	template <bool bMFCDLL>
	CStringT(_In_ const CSimpleStringT<BaseType, bMFCDLL>& strSrc) :
		CThisSimpleString( strSrc )
	{
	}

	CStringT(_In_opt_z_ const XCHAR* pszSrc) :
		CThisSimpleString( StringTraits::GetDefaultManager() )
	{
		if( !CheckImplicitLoad( pszSrc ) )
		{
			*this = pszSrc;
		}
	}

	CStringT(
			_In_opt_z_ const XCHAR* pszSrc,
			_In_ IAtlStringMgr* pStringMgr) :
		CThisSimpleString( pStringMgr )
	{
		if( !CheckImplicitLoad( pszSrc ) )
		{
			*this = pszSrc;
		}
	}

#ifndef _CSTRING_DISABLE_NARROW_WIDE_CONVERSION
	CSTRING_EXPLICIT CStringT(_In_opt_z_ const YCHAR* pszSrc) :
		CThisSimpleString( StringTraits::GetDefaultManager() )
	{
		if( !CheckImplicitLoad( pszSrc ) )
		{
			*this = pszSrc;
		}
	}

	CStringT(
			_In_opt_z_ const YCHAR* pszSrc,
			_In_ IAtlStringMgr* pStringMgr) :
		CThisSimpleString( pStringMgr )
	{
		if( !CheckImplicitLoad( pszSrc ) )
		{
			*this = pszSrc;
		}
	}
#endif // ndef _CSTRING_DISABLE_NARROW_WIDE_CONVERSION

	// This template will compile only for
	// class SystemString == System::String

#if defined(__cplusplus_cli)

	template <class SystemString>
	CStringT(_In_ SystemString^ pString) :
		CThisSimpleString( StringTraits::GetDefaultManager() )
	{
		cli::pin_ptr<const System::Char> pChar = PtrToStringChars( pString );
		const wchar_t *psz = pChar;
		*this = psz;
	}

#elif defined(_MANAGED)

	template<class SystemString>
	CStringT(_In_ SystemString __gc* pString) :
		CThisSimpleString( StringTraits::GetDefaultManager() )
	{
		const wchar_t __pin* psz = PtrToStringChars( pString );
		*this = psz;
	}

#endif

#ifndef _CSTRING_DISABLE_NARROW_WIDE_CONVERSION
	CSTRING_EXPLICIT CStringT(_In_z_ const unsigned char* pszSrc) :
		CThisSimpleString( StringTraits::GetDefaultManager() )
	{
		*this = reinterpret_cast< const char* >( pszSrc );
	}
#endif // ndef _CSTRING_DISABLE_NARROW_WIDE_CONVERSION

//ctors to prevent from oldSyntax template ctor (above) hijack certain types.
//MFC dll instantiate all CStringT methods inside the dll and declares dllimport for
//all methods in user build (see afxstr.h), so need to include the methods in MFC dll builds.
#if defined(_AFXDLL) && defined(_MFC_DLL_BLD) || !defined(__cplusplus_cli) && defined(_MANAGED)

	/*CSTRING_EXPLICIT*/ CStringT(_In_opt_z_ char* pszSrc) :
		CThisSimpleString( StringTraits::GetDefaultManager() )
	{
		const char *psz = reinterpret_cast< const char* >( pszSrc );
		if (!CheckImplicitLoad( psz ))
		{
			*this = psz;
		}
	}

	CSTRING_EXPLICIT CStringT(_In_opt_z_ unsigned char* pszSrc) :
		CThisSimpleString( StringTraits::GetDefaultManager() )
	{
		const char *psz = reinterpret_cast< const char* >( pszSrc );
		if (!CheckImplicitLoad( psz ))
		{
			*this = psz;
		}
	}

	CSTRING_EXPLICIT CStringT(_In_opt_z_ wchar_t* pszSrc) :
		CThisSimpleString( StringTraits::GetDefaultManager() )
	{
		const wchar_t *psz = reinterpret_cast< const wchar_t* >( pszSrc );
		if (!CheckImplicitLoad( psz ))
		{
			*this = psz;
		}
	}
#endif


#ifndef _CSTRING_DISABLE_NARROW_WIDE_CONVERSION
	CStringT(
			_In_opt_z_ const unsigned char* pszSrc,
			_In_ IAtlStringMgr* pStringMgr) :
		CThisSimpleString( pStringMgr )
	{
		*this = reinterpret_cast< const char* >( pszSrc );
	}
#endif // ndef _CSTRING_DISABLE_NARROW_WIDE_CONVERSION

#ifdef _CSTRING_DISABLE_NARROW_WIDE_CONVERSION
#define _CSTRING_CHAR_T XCHAR
#else // def _CSTRING_NARROW_WIDE_CONVERSION
#define _CSTRING_CHAR_T char
#endif // def _CSTRING_NARROW_WIDE_CONVERSION

	CSTRING_EXPLICIT CStringT(
			_In_ _CSTRING_CHAR_T ch,
			_In_ int nLength = 1) :
		CThisSimpleString( StringTraits::GetDefaultManager() )
	{
		ATLASSERT( nLength >= 0 );
		if( nLength > 0 )
		{
			PXSTR pszBuffer = GetBuffer( nLength );
			StringTraits::FloodCharacters( XCHAR( ch ), nLength, pszBuffer );
			ReleaseBufferSetLength( nLength );
		}
	}
#undef _CSTRING_CHAR_T

#ifndef _CSTRING_DISABLE_NARROW_WIDE_CONVERSION
	CSTRING_EXPLICIT CStringT(
			_In_ wchar_t ch,
			_In_ int nLength = 1) :
		CThisSimpleString( StringTraits::GetDefaultManager() )
	{
		ATLASSERT( nLength >= 0 );
		if( nLength > 0 )
		{
			//Convert ch to the BaseType
			wchar_t pszCh[2] = { ch , 0 };
			int nBaseTypeCharLen = 1;

			if(ch != L'\0')
			{
				nBaseTypeCharLen = StringTraits::GetBaseTypeLength(pszCh);
			}

			CTempBuffer<XCHAR,10> buffBaseTypeChar;
			buffBaseTypeChar.Allocate(nBaseTypeCharLen+1);
			StringTraits::ConvertToBaseType( buffBaseTypeChar, nBaseTypeCharLen+1, pszCh, 1 );
			//Allocate enough characters in String and flood (replicate) with the (converted character)*nLength
			PXSTR pszBuffer = GetBuffer( nLength*nBaseTypeCharLen );
			if (nBaseTypeCharLen == 1)
			{   //Optimization for a common case - wide char translates to 1 ansi/wide char.
				StringTraits::FloodCharacters( buffBaseTypeChar[0], nLength, pszBuffer );
			} else
			{
				XCHAR* p=pszBuffer;
				for (int i=0 ; i < nLength ;++i)
				{
					for (int j=0 ; j < nBaseTypeCharLen ;++j)
					{
						*p=buffBaseTypeChar[j];
						++p;
					}
				}
			}
			ReleaseBufferSetLength( nLength*nBaseTypeCharLen );
		}
	}
#else
private:
	CSTRING_EXPLICIT CStringT(
		_In_ YCHAR ch,
		_In_ int nLength = 1);
public:
#endif // ndef _CSTRING_DISABLE_NARROW_WIDE_CONVERSION

	CStringT(
			_In_count_(nLength) const XCHAR* pch,
			_In_ int nLength) :
		CThisSimpleString( pch, nLength, StringTraits::GetDefaultManager() )
	{
	}

	CStringT(
			_In_count_(nLength) const XCHAR* pch,
			_In_ int nLength,
			_In_ IAtlStringMgr* pStringMgr) :
		CThisSimpleString( pch, nLength, pStringMgr )
	{
	}

#ifndef _CSTRING_DISABLE_NARROW_WIDE_CONVERSION
	CStringT(
			_In_count_(nLength) const YCHAR* pch,
			_In_ int nLength) :
		CThisSimpleString( StringTraits::GetDefaultManager() )
	{
		ATLASSERT( nLength >= 0 );
		if( nLength > 0 )
		{
			ATLASSERT( AtlIsValidAddress( pch, nLength*sizeof( YCHAR ), FALSE ) );
			if(pch == NULL)
				AtlThrow(E_INVALIDARG);

			int nDestLength = StringTraits::GetBaseTypeLength( pch, nLength );
			PXSTR pszBuffer = GetBuffer( nDestLength );
			StringTraits::ConvertToBaseType( pszBuffer, nDestLength, pch, nLength );
			ReleaseBufferSetLength( nDestLength );
		}
	}

	CStringT(
			_In_count_(nLength) const YCHAR* pch,
			_In_ int nLength,
			_In_ IAtlStringMgr* pStringMgr) :
		CThisSimpleString( pStringMgr )
	{
		ATLASSERT( nLength >= 0 );
		if( nLength > 0 )
		{
			ATLASSERT( AtlIsValidAddress( pch, nLength*sizeof( YCHAR ), FALSE ) );
			if(pch == NULL)
				AtlThrow(E_INVALIDARG);

			int nDestLength = StringTraits::GetBaseTypeLength( pch, nLength );
			PXSTR pszBuffer = GetBuffer( nDestLength );
			StringTraits::ConvertToBaseType( pszBuffer, nDestLength, pch, nLength );
			ReleaseBufferSetLength( nDestLength );
		}
	}
#endif // ndef _CSTRING_DISABLE_NARROW_WIDE_CONVERSION

	// Destructor
	~CStringT() throw()
	{
	}

	// Assignment operators
	CStringT& operator=(_In_ const CStringT& strSrc)
	{
		CThisSimpleString::operator=( strSrc );

		return( *this );
	}

	template <bool bMFCDLL>
	CStringT& operator=(_In_ const CSimpleStringT<BaseType, bMFCDLL>& strSrc)
	{
		CThisSimpleString::operator=( strSrc );

		return( *this );
	}

	CStringT& operator=(_In_opt_z_ PCXSTR pszSrc)
	{
		CThisSimpleString::operator=( pszSrc );

		return( *this );
	}

#ifndef _CSTRING_DISABLE_NARROW_WIDE_CONVERSION
	CStringT& operator=(_In_opt_z_ PCYSTR pszSrc)
	{
		// nDestLength is in XCHARs
		int nDestLength = (pszSrc != NULL) ? StringTraits::GetBaseTypeLength( pszSrc ) : 0;
		if( nDestLength > 0 )
		{
			PXSTR pszBuffer = GetBuffer( nDestLength );
			StringTraits::ConvertToBaseType( pszBuffer, nDestLength, pszSrc);
			ReleaseBufferSetLength( nDestLength );
		}
		else
		{
			Empty();
		}

		return( *this );
	}

	CStringT& operator=(_In_opt_z_ const unsigned char* pszSrc)
	{
		return( operator=( reinterpret_cast< const char* >( pszSrc ) ) );
	}
#endif // ndef _CSTRING_DISABLE_NARROW_WIDE_CONVERSION

	CStringT& operator=(_In_ XCHAR ch)
	{
		XCHAR ach[2] = { ch, 0 };

		return( operator=( ach ) );
	}

#ifndef _CSTRING_DISABLE_NARROW_WIDE_CONVERSION

	CStringT& operator=(_In_ YCHAR ch)
	{
		YCHAR ach[2] = { ch, 0 };

		return( operator=( ach ) );
	}
#endif // ndef _CSTRING_DISABLE_NARROW_WIDE_CONVERSION

	CStringT& operator=(_In_ const VARIANT& var);

	CStringT& operator+=(_In_ const CThisSimpleString& str)
	{
		CThisSimpleString::operator+=( str );

		return( *this );
	}
	template <bool bMFCDLL>
	CStringT& operator+=(_In_ const CSimpleStringT<BaseType, bMFCDLL>& str)
	{
		CThisSimpleString::operator+=( str );

		return( *this );
	}

	CStringT& operator+=(_In_z_ PCXSTR pszSrc)
	{
		CThisSimpleString::operator+=( pszSrc );

		return( *this );
	}
	template< int t_nSize >
	CStringT& operator+=(_In_ const CStaticString< XCHAR, t_nSize >& strSrc)
	{
		CThisSimpleString::operator+=( strSrc );

		return( *this );
	}

#ifndef _CSTRING_DISABLE_NARROW_WIDE_CONVERSION
	CStringT& operator+=(_In_opt_z_ PCYSTR pszSrc)
	{
		CStringT str( pszSrc, GetManager() );

		return( operator+=( str ) );
	}
#endif // ndef _CSTRING_DISABLE_NARROW_WIDE_CONVERSION

	CStringT& operator+=(_In_ XCHAR ch)
	{
		CThisSimpleString::operator+=( ch );

		return( *this );
	}

#ifdef _CSTRING_DISABLE_NARROW_WIDE_CONVERSION
private:
	CStringT& operator+=(_In_ YCHAR ch);
public:
#else
	CStringT& operator+=(_In_ unsigned char ch)
	{
		CThisSimpleString::operator+=( ch );

		return( *this );
	}

	CStringT& operator+=(_In_ YCHAR ch)
	{
		CThisSimpleString::operator+=( ch );

		return( *this );
	}
#endif // def _CSTRING_DISABLE_NARROW_WIDE_CONVERSION

	CStringT& operator+=(_In_ const VARIANT& var);

	// Override from base class
	IAtlStringMgr* GetManager() const throw()
	{
		IAtlStringMgr* pStringMgr = CThisSimpleString::GetManager();
		if(pStringMgr) { return pStringMgr; }

		pStringMgr = StringTraits::GetDefaultManager();
		return pStringMgr->Clone();
	}

	// Comparison

	int Compare(_In_z_ PCXSTR psz) const
	{
		ATLENSURE( AtlIsValidString( psz ) );
		__analysis_assume(psz); // AtlIsValidString guarantees that psz != NULL
		return( StringTraits::StringCompare( GetString(), psz ) );
	}

	int CompareNoCase(_In_z_ PCXSTR psz) const
	{
		ATLENSURE( AtlIsValidString( psz ) );
		__analysis_assume(psz); // AtlIsValidString guarantees that psz != NULL
		return( StringTraits::StringCompareIgnore( GetString(), psz ) );
	}

	int Collate(_In_z_ PCXSTR psz) const throw()
	{
		ATLASSERT( AtlIsValidString( psz ) );
		return( StringTraits::StringCollate( GetString(), psz ) );
	}

	int CollateNoCase(_In_z_ PCXSTR psz) const throw()
	{
		ATLASSERT( AtlIsValidString( psz ) );
		return( StringTraits::StringCollateIgnore( GetString(), psz ) );
	}

	// Advanced manipulation

	// Delete 'nCount' characters, starting at index 'iIndex'
	int Delete(
		_In_ int iIndex,
		_In_ int nCount = 1)
	{
		if( iIndex < 0 )
			iIndex = 0;

		if( nCount < 0 )
			nCount = 0;

		int nLength = GetLength();
		if( (::ATL::AtlAddThrow(nCount, iIndex)) > nLength )
		{
			nCount = nLength-iIndex;
		}
		if( nCount > 0 )
		{
			int nNewLength = nLength-nCount;
			int nXCHARsToCopy = nLength-(iIndex+nCount)+1;
			PXSTR pszBuffer = GetBuffer();
			Checked::memmove_s( pszBuffer+iIndex, nXCHARsToCopy*sizeof( XCHAR ),
				pszBuffer+iIndex+nCount, nXCHARsToCopy*sizeof( XCHAR ) );
			ReleaseBufferSetLength( nNewLength );
		}

		return( GetLength() );
	}

	// Insert character 'ch' before index 'iIndex'
	int Insert(
		_In_ int iIndex,
		_In_ XCHAR ch)
	{
		if( iIndex < 0 )
			iIndex = 0;

		if( iIndex > GetLength() )
		{
			iIndex = GetLength();
		}
		int nNewLength = GetLength()+1;

		PXSTR pszBuffer = GetBuffer( nNewLength );

		// move existing bytes down
		Checked::memmove_s( pszBuffer+iIndex+1, (nNewLength-iIndex)*sizeof( XCHAR ),
			pszBuffer+iIndex, (nNewLength-iIndex)*sizeof( XCHAR ) );
		pszBuffer[iIndex] = ch;

		ReleaseBufferSetLength( nNewLength );

		return( nNewLength );
	}

	// Insert string 'psz' before index 'iIndex'
	int Insert(
		_In_ int iIndex,
		_In_z_ PCXSTR psz)
	{
		if( iIndex < 0 )
			iIndex = 0;

		if( iIndex > GetLength() )
		{
			iIndex = GetLength();
		}

		// nInsertLength and nNewLength are in XCHARs
		int nInsertLength = StringTraits::SafeStringLen( psz );
		int nNewLength = GetLength();
		if( nInsertLength > 0 )
		{
			nNewLength += nInsertLength;

			PXSTR pszBuffer = GetBuffer( nNewLength );
			// move existing bytes down
			Checked::memmove_s( pszBuffer+iIndex+nInsertLength, (nNewLength-iIndex-nInsertLength+1)*sizeof( XCHAR ),
				pszBuffer+iIndex, (nNewLength-iIndex-nInsertLength+1)*sizeof( XCHAR ) );
			Checked::memcpy_s( pszBuffer+iIndex, nInsertLength*sizeof( XCHAR ),
				psz, nInsertLength*sizeof( XCHAR ) );
			ReleaseBufferSetLength( nNewLength );
		}

		return( nNewLength );
	}

	// Replace all occurrences of character 'chOld' with character 'chNew'
	int Replace(
		_In_ XCHAR chOld,
		_In_ XCHAR chNew)
	{
		int nCount = 0;

		// short-circuit the nop case
		if( chOld != chNew )
		{
			// otherwise modify each character that matches in the string
			bool bCopied = false;
			PXSTR pszBuffer = const_cast< PXSTR >( GetString() );  // We don't actually write to pszBuffer until we've called GetBuffer().

			int nLength = GetLength();
			int iChar = 0;
			while( iChar < nLength )
			{
				// replace instances of the specified character only
				if( pszBuffer[iChar] == chOld )
				{
					if( !bCopied )
					{
						bCopied = true;
						pszBuffer = GetBuffer( nLength );
					}
					pszBuffer[iChar] = chNew;
					nCount++;
				}
				iChar = int( StringTraits::CharNext( pszBuffer+iChar )-pszBuffer );
			}
			if( bCopied )
			{
				ReleaseBufferSetLength( nLength );
			}
		}

		return( nCount );
	}

	// Replace all occurrences of string 'pszOld' with string 'pszNew'
	int Replace(
		_In_z_ PCXSTR pszOld,
		_In_z_ PCXSTR pszNew)
	{
		// can't have empty or NULL lpszOld

		// nSourceLen is in XCHARs
		int nSourceLen = StringTraits::SafeStringLen( pszOld );
		if( nSourceLen == 0 )
			return( 0 );
		// nReplacementLen is in XCHARs
		int nReplacementLen = StringTraits::SafeStringLen( pszNew );

		// loop once to figure out the size of the result string
		int nCount = 0;
		{
			PCXSTR pszStart = GetString();
			PCXSTR pszEnd = pszStart+GetLength();
			while( pszStart < pszEnd )
			{
				PCXSTR pszTarget;
				while( (pszTarget = StringTraits::StringFindString( pszStart, pszOld ) ) != NULL)
				{
					nCount++;
					pszStart = pszTarget+nSourceLen;
				}
				pszStart += StringTraits::SafeStringLen( pszStart )+1;
			}
		}

		// if any changes were made, make them
		if( nCount > 0 )
		{
			// if the buffer is too small, just
			//   allocate a new buffer (slow but sure)
			int nOldLength = GetLength();
			int nNewLength = nOldLength+(nReplacementLen-nSourceLen)*nCount;

			PXSTR pszBuffer = GetBuffer( __max( nNewLength, nOldLength ) );

			PXSTR pszStart = pszBuffer;
			PXSTR pszEnd = pszStart+nOldLength;

			// loop again to actually do the work
			while( pszStart < pszEnd )
			{
				PXSTR pszTarget;
				while( (pszTarget = StringTraits::StringFindString( pszStart, pszOld ) ) != NULL )
				{
					int nBalance = nOldLength-int(pszTarget-pszBuffer+nSourceLen);
					Checked::memmove_s( pszTarget+nReplacementLen, nBalance*sizeof( XCHAR ),
						pszTarget+nSourceLen, nBalance*sizeof( XCHAR ) );
					Checked::memcpy_s( pszTarget, nReplacementLen*sizeof( XCHAR ),
						pszNew, nReplacementLen*sizeof( XCHAR ) );
					pszStart = pszTarget+nReplacementLen;
					pszTarget[nReplacementLen+nBalance] = 0;
					nOldLength += (nReplacementLen-nSourceLen);
				}
				pszStart += StringTraits::SafeStringLen( pszStart )+1;
			}
			ATLASSERT( pszBuffer[nNewLength] == 0 );
			ReleaseBufferSetLength( nNewLength );
		}

		return( nCount );
	}

	// Remove all occurrences of character 'chRemove'
	int Remove(_In_ XCHAR chRemove)
	{
		int nLength = GetLength();
		PXSTR pszBuffer = GetBuffer( nLength );

		PXSTR pszSource = pszBuffer;
		PXSTR pszDest = pszBuffer;
		PXSTR pszEnd = pszBuffer+nLength;

		while( pszSource < pszEnd )
		{
			PXSTR pszNewSource = StringTraits::CharNext( pszSource );
			if( *pszSource != chRemove )
			{
				// Copy the source to the destination.  Remember to copy all bytes of an MBCS character
	   			// Copy the source to the destination.  Remember to copy all bytes of an MBCS character
				size_t NewSourceGap = (pszNewSource-pszSource);
				PXSTR pszNewDest = pszDest + NewSourceGap;
				size_t i = 0;
				for (i = 0;  pszDest != pszNewDest && i < NewSourceGap; i++)
				{
					*pszDest = *pszSource;
					pszSource++;
					pszDest++;
				}
			}
			pszSource = pszNewSource;
		}
		*pszDest = 0;
		int nCount = int( pszSource-pszDest );
		ReleaseBufferSetLength( nLength-nCount );

		return( nCount );
	}

	CStringT Tokenize(
		_In_z_ PCXSTR pszTokens,
		_Inout_ int& iStart) const
	{
		ATLASSERT( iStart >= 0 );

		if(iStart < 0)
			AtlThrow(E_INVALIDARG);

		if( (pszTokens == NULL) || (*pszTokens == (XCHAR)0) )
		{
			if (iStart < GetLength())
			{
				return( CStringT( GetString()+iStart, GetManager() ) );
			}
		}
		else
		{
			PCXSTR pszPlace = GetString()+iStart;
			PCXSTR pszEnd = GetString()+GetLength();
			if( pszPlace < pszEnd )
			{
				int nIncluding = StringTraits::StringSpanIncluding( pszPlace,
					pszTokens );

				if( (pszPlace+nIncluding) < pszEnd )
				{
					pszPlace += nIncluding;
					int nExcluding = StringTraits::StringSpanExcluding( pszPlace, pszTokens );

					int iFrom = iStart+nIncluding;
					int nUntil = nExcluding;
					iStart = iFrom+nUntil+1;

					return( Mid( iFrom, nUntil ) );
				}
			}
		}

		// return empty string, done tokenizing
		iStart = -1;

		return( CStringT( GetManager() ) );
	}

	// find routines

	// Find the first occurrence of character 'ch', starting at index 'iStart'
	int Find(
		_In_ XCHAR ch,
		_In_ int iStart = 0) const throw()
	{
		// iStart is in XCHARs
		ATLASSERT( iStart >= 0 );

		// nLength is in XCHARs
		int nLength = GetLength();
		if( iStart < 0 || iStart >= nLength)
		{
			return( -1 );
		}

		// find first single character
		PCXSTR psz = StringTraits::StringFindChar( GetString()+iStart, ch );

		// return -1 if not found and index otherwise
		return( (psz == NULL) ? -1 : int( psz-GetString() ) );
	}

	// look for a specific sub-string

	// Find the first occurrence of string 'pszSub', starting at index 'iStart'
	int Find(
		_In_z_ PCXSTR pszSub,
		_In_ int iStart = 0) const throw()
	{
		// iStart is in XCHARs
		ATLASSERT( iStart >= 0 );
		ATLASSERT( AtlIsValidString( pszSub ) );

		if(pszSub == NULL)
		{
			return( -1 );
		}
		// nLength is in XCHARs
		int nLength = GetLength();
		if( iStart < 0 || iStart > nLength )
		{
			return( -1 );
		}

		// find first matching substring
		PCXSTR psz = StringTraits::StringFindString( GetString()+iStart, pszSub );

		// return -1 for not found, distance from beginning otherwise
		return( (psz == NULL) ? -1 : int( psz-GetString() ) );
	}

	// Find the first occurrence of any of the characters in string 'pszCharSet'
	int FindOneOf(_In_z_ PCXSTR pszCharSet) const throw()
	{
		ATLASSERT( AtlIsValidString( pszCharSet ) );
		PCXSTR psz = StringTraits::StringScanSet( GetString(), pszCharSet );
		return( (psz == NULL) ? -1 : int( psz-GetString() ) );
	}

	// Find the last occurrence of character 'ch'
	int ReverseFind(_In_ XCHAR ch) const throw()
	{
		// find last single character
		PCXSTR psz = StringTraits::StringFindCharRev( GetString(), ch );

		// return -1 if not found, distance from beginning otherwise
		return( (psz == NULL) ? -1 : int( psz-GetString() ) );
	}

	// manipulation

	// Convert the string to uppercase
	CStringT& MakeUpper()
	{
		int nLength = GetLength();
		PXSTR pszBuffer = GetBuffer( nLength );
		StringTraits::StringUppercase( pszBuffer, nLength+1 );
		ReleaseBufferSetLength( nLength );

		return( *this );
	}

	// Convert the string to lowercase
	CStringT& MakeLower()
	{
		int nLength = GetLength();
		PXSTR pszBuffer = GetBuffer( nLength );
		StringTraits::StringLowercase( pszBuffer, nLength+1 );
		ReleaseBufferSetLength( nLength );

		return( *this );
	}

	// Reverse the string
	CStringT& MakeReverse()
	{
		int nLength = GetLength();
		PXSTR pszBuffer = GetBuffer( nLength );
		StringTraits::StringReverse( pszBuffer );
		ReleaseBufferSetLength( nLength );

		return( *this );
	}

	// trimming

	// Remove all trailing whitespace
	CStringT& TrimRight()
	{
		// find beginning of trailing spaces by starting
		// at beginning (DBCS aware)

		PCXSTR psz = GetString();
		PCXSTR pszLast = NULL;

		while( *psz != 0 )
		{
			if( StringTraits::IsSpace( *psz ) )
			{
				if( pszLast == NULL )
					pszLast = psz;
			}
			else
			{
				pszLast = NULL;
			}
			psz = StringTraits::CharNext( psz );
		}

		if( pszLast != NULL )
		{
			// truncate at trailing space start
			int iLast = int( pszLast-GetString() );

			Truncate( iLast );
		}

		return( *this );
	}

	// Remove all leading whitespace
	CStringT& TrimLeft()
	{
		// find first non-space character

		PCXSTR psz = GetString();

		while( StringTraits::IsSpace( *psz ) )
		{
			psz = StringTraits::CharNext( psz );
		}

		if( psz != GetString() )
		{
			// fix up data and length
			int iFirst = int( psz-GetString() );
			PXSTR pszBuffer = GetBuffer( GetLength() );
			psz = pszBuffer+iFirst;
			int nDataLength = GetLength()-iFirst;
			Checked::memmove_s( pszBuffer, (GetLength()+1)*sizeof( XCHAR ),
				psz, (nDataLength+1)*sizeof( XCHAR ) );
			ReleaseBufferSetLength( nDataLength );
		}

		return( *this );
	}

	// Remove all leading and trailing whitespace
	CStringT& Trim()
	{
		return( TrimRight().TrimLeft() );
	}

	// Remove all leading and trailing occurrences of character 'chTarget'
	CStringT& Trim(_In_ XCHAR chTarget)
	{
		return( TrimRight( chTarget ).TrimLeft( chTarget ) );
	}

	// Remove all leading and trailing occurrences of any of the characters in the string 'pszTargets'
	CStringT& Trim(_In_z_ PCXSTR pszTargets)
	{
		return( TrimRight( pszTargets ).TrimLeft( pszTargets ) );
	}

	// trimming anything (either side)

	// Remove all trailing occurrences of character 'chTarget'
	CStringT& TrimRight(_In_ XCHAR chTarget)
	{
		// find beginning of trailing matches
		// by starting at beginning (DBCS aware)

		PCXSTR psz = GetString();
		PCXSTR pszLast = NULL;

		while( *psz != 0 )
		{
			if( *psz == chTarget )
			{
				if( pszLast == NULL )
				{
					pszLast = psz;
				}
			}
			else
			{
				pszLast = NULL;
			}
			psz = StringTraits::CharNext( psz );
		}

		if( pszLast != NULL )
		{
			// truncate at left-most matching character
			int iLast = int( pszLast-GetString() );
			Truncate( iLast );
		}

		return( *this );
	}

	// Remove all trailing occurrences of any of the characters in string 'pszTargets'
	CStringT& TrimRight(_In_z_ PCXSTR pszTargets)
	{
		// if we're not trimming anything, we're not doing any work
		if( (pszTargets == NULL) || (*pszTargets == 0) )
		{
			return( *this );
		}

		// find beginning of trailing matches
		// by starting at beginning (DBCS aware)

		PCXSTR psz = GetString();
		PCXSTR pszLast = NULL;

		while( *psz != 0 )
		{
			if( StringTraits::StringFindChar( pszTargets, *psz ) != NULL )
			{
				if( pszLast == NULL )
				{
					pszLast = psz;
				}
			}
			else
			{
				pszLast = NULL;
			}
			psz = StringTraits::CharNext( psz );
		}

		if( pszLast != NULL )
		{
			// truncate at left-most matching character
			int iLast = int( pszLast-GetString() );
			Truncate( iLast );
		}

		return( *this );
	}

	// Remove all leading occurrences of character 'chTarget'
	CStringT& TrimLeft(_In_ XCHAR chTarget)
	{
		// find first non-matching character
		PCXSTR psz = GetString();

		while( chTarget == *psz )
		{
			psz = StringTraits::CharNext( psz );
		}

		if( psz != GetString() )
		{
			// fix up data and length
			int iFirst = int( psz-GetString() );
			PXSTR pszBuffer = GetBuffer( GetLength() );
			psz = pszBuffer+iFirst;
			int nDataLength = GetLength()-iFirst;
			Checked::memmove_s( pszBuffer, (GetLength()+1)*sizeof( XCHAR ),
				psz, (nDataLength+1)*sizeof( XCHAR ) );
			ReleaseBufferSetLength( nDataLength );
		}

		return( *this );
	}

	// Remove all leading occurrences of any of the characters in string 'pszTargets'
	CStringT& TrimLeft(_In_z_ PCXSTR pszTargets)
	{
		// if we're not trimming anything, we're not doing any work
		if( (pszTargets == NULL) || (*pszTargets == 0) )
		{
			return( *this );
		}

		PCXSTR psz = GetString();
		while( (*psz != 0) && (StringTraits::StringFindChar( pszTargets, *psz ) != NULL) )
		{
			psz = StringTraits::CharNext( psz );
		}

		if( psz != GetString() )
		{
			// fix up data and length
			int iFirst = int( psz-GetString() );
			PXSTR pszBuffer = GetBuffer( GetLength() );
			psz = pszBuffer+iFirst;
			int nDataLength = GetLength()-iFirst;
			Checked::memmove_s( pszBuffer, (GetLength()+1)*sizeof( XCHAR ),
				psz, (nDataLength+1)*sizeof( XCHAR ) );
			ReleaseBufferSetLength( nDataLength );
		}

		return( *this );
	}

	// Convert the string to the OEM character set
	void AnsiToOem()
	{
		int nLength = GetLength();
		PXSTR pszBuffer = GetBuffer( nLength );
		StringTraits::ConvertToOem( pszBuffer, nLength+1 );
		ReleaseBufferSetLength( nLength );
	}

	// Convert the string to the ANSI character set

	void OemToAnsi()
	{
		int nLength = GetLength();
		PXSTR pszBuffer = GetBuffer( nLength );
		StringTraits::ConvertToAnsi( pszBuffer, nLength+1 );
		ReleaseBufferSetLength( nLength );
	}

	// Very simple sub-string extraction

	// Return the substring starting at index 'iFirst'
	CStringT Mid(_In_ int iFirst) const
	{
		return( Mid( iFirst, GetLength()-iFirst ) );
	}

	// Return the substring starting at index 'iFirst', with length 'nCount'
	CStringT Mid(
		_In_ int iFirst,
		_In_ int nCount) const
	{
		// nCount is in XCHARs

		// out-of-bounds requests return sensible things
		if (iFirst < 0)
			iFirst = 0;
		if (nCount < 0)
			nCount = 0;

		if( (::ATL::AtlAddThrow(iFirst,nCount)) > GetLength() )
		{
			nCount = GetLength()-iFirst;
		}
		if( iFirst > GetLength() )
		{
			nCount = 0;
		}

		ATLASSERT( (nCount == 0) || ((iFirst+nCount) <= GetLength()) );

		// optimize case of returning entire string
		if( (iFirst == 0) && ((iFirst+nCount) == GetLength()) )
		{
			return( *this );
		}

		return( CStringT( GetString()+iFirst, nCount, GetManager() ) );
	}

	// Return the substring consisting of the rightmost 'nCount' characters
	CStringT Right(_In_ int nCount) const
	{
		// nCount is in XCHARs
		if (nCount < 0)
			nCount = 0;

		int nLength = GetLength();
		if( nCount >= nLength )
		{
			return( *this );
		}

		return( CStringT( GetString()+nLength-nCount, nCount, GetManager() ) );
	}

	// Return the substring consisting of the leftmost 'nCount' characters
	CStringT Left(_In_ int nCount) const
	{
		// nCount is in XCHARs
		if (nCount < 0)
			nCount = 0;

		int nLength = GetLength();
		if( nCount >= nLength )
		{
			return( *this );
		}

		return( CStringT( GetString(), nCount, GetManager() ) );
	}

	// Return the substring consisting of the leftmost characters in the set 'pszCharSet'
	CStringT SpanIncluding(_In_z_ PCXSTR pszCharSet) const
	{
		ATLASSERT( AtlIsValidString( pszCharSet ) );
		if(pszCharSet == NULL)
			AtlThrow(E_INVALIDARG);

		return( Left( StringTraits::StringSpanIncluding( GetString(), pszCharSet ) ) );
	}

	// Return the substring consisting of the leftmost characters not in the set 'pszCharSet'
	CStringT SpanExcluding(_In_z_ PCXSTR pszCharSet) const
	{
		ATLASSERT( AtlIsValidString( pszCharSet ) );
		if(pszCharSet == NULL)
			AtlThrow(E_INVALIDARG);

		return( Left( StringTraits::StringSpanExcluding( GetString(), pszCharSet ) ) );
 	}

	// Format data using format string 'pszFormat'
	void __cdecl Format(_In_z_ _FormatMessage_format_string_ PCXSTR pszFormat, ...);

	// Format data using format string loaded from resource 'nFormatID'
	void __cdecl Format(_In_ _FormatMessage_format_string_ UINT nFormatID, ...);

	// Append formatted data using format string loaded from resource 'nFormatID'
	void __cdecl AppendFormat(_In_ _FormatMessage_format_string_ UINT nFormatID, ...);

	// Append formatted data using format string 'pszFormat'
	void __cdecl AppendFormat(_In_z_ _FormatMessage_format_string_ PCXSTR pszFormat, ...);

	void AppendFormatV(
		_In_z_ _FormatMessage_format_string_ PCXSTR pszFormat, 
		_In_ va_list args)
	{
		ATLASSERT( AtlIsValidString( pszFormat ) );
		if(pszFormat == NULL)
			AtlThrow(E_INVALIDARG);

		int nCurrentLength = GetLength();
		int nAppendLength = StringTraits::GetFormattedLength( pszFormat, args );

		if (nAppendLength < 0)
			AtlThrow(E_FAIL);

		PXSTR pszBuffer = GetBuffer( nCurrentLength+nAppendLength );
		StringTraits::Format( pszBuffer+nCurrentLength,
			nAppendLength+1, pszFormat, args );
		ReleaseBufferSetLength( nCurrentLength+nAppendLength );
	}

	void FormatV(
		_In_z_ _FormatMessage_format_string_ PCXSTR pszFormat, 
		_In_ va_list args)
	{
		ATLASSERT( AtlIsValidString( pszFormat ) );
		if(pszFormat == NULL)
			AtlThrow(E_INVALIDARG);

		int nLength = StringTraits::GetFormattedLength( pszFormat, args );

		if (nLength < 0)
			AtlThrow(E_FAIL);

		PXSTR pszBuffer = GetBuffer( nLength );
		StringTraits::Format( pszBuffer, nLength+1, pszFormat, args );
		ReleaseBufferSetLength( nLength );
	}

	// Format a message using format string 'pszFormat'
	void __cdecl _AFX_FUNCNAME(FormatMessage)(_In_z_ _FormatMessage_format_string_ PCXSTR pszFormat, ...);

	// Format a message using format string loaded from resource 'nFormatID'
	void __cdecl _AFX_FUNCNAME(FormatMessage)(_In_ _FormatMessage_format_string_ UINT nFormatID, ...);

#if defined(_AFX)
	void __cdecl FormatMessage(_In_z_ _FormatMessage_format_string_ PCXSTR pszFormat, ...);

	void __cdecl FormatMessage(_In_ _FormatMessage_format_string_ UINT nFormatID, ...);
#endif

	// Format a message using format string 'pszFormat' and va_list
	void FormatMessageV(
		_In_z_ _FormatMessage_format_string_ PCXSTR pszFormat, 
		_In_opt_ va_list* pArgList)
	{
		// format message into temporary buffer pszTemp
		CHeapPtr< XCHAR, CLocalAllocator > pszTemp;
		/*
			FormatMessage returns zero in case of failure or the number of characters
			if it is success, but we may actually get 0 as a number of characters.
			So to avoid this situation use SetLastError and GetLastErorr to determine
			whether the function FormatMessage has failed.
		*/
		DWORD dwLastError = ::GetLastError();
		::SetLastError(0);

		StringTraits::_AFX_FUNCNAME(FormatMessage)( FORMAT_MESSAGE_FROM_STRING|
			FORMAT_MESSAGE_ALLOCATE_BUFFER, pszFormat, 0, 0, reinterpret_cast< PXSTR >( &pszTemp ),
			0, pArgList );

		if( ::GetLastError() != 0 )
		{
			ThrowMemoryException();
		}
		::SetLastError(dwLastError);

		*this = pszTemp;
	}

	// OLE BSTR support

	// Allocate a BSTR containing a copy of the string
	_Ret_opt_z_ BSTR AllocSysString() const
	{
		BSTR bstrResult = StringTraits::AllocSysString( GetString(), GetLength() );

		if( bstrResult == NULL )
		{
			ThrowMemoryException();
		}
		return( bstrResult );
	}

	BSTR SetSysString(_Inout_ _Deref_post_opt_valid_ _Post_z_ BSTR* pbstr) const
	{
		ATLASSERT( AtlIsValidAddress( pbstr, sizeof( BSTR ) ) );

		if( !StringTraits::ReAllocSysString( GetString(), pbstr,
			GetLength() ) )
		{
			ThrowMemoryException();
		}

		ATLASSERT( *pbstr != NULL );

		return( *pbstr );
	}

	// Set the string to the value of environment variable 'pszVar'
	_Check_return_ BOOL GetEnvironmentVariable(_In_z_ PCXSTR pszVar)
	{
		ULONG nLength = StringTraits::GetEnvironmentVariable( pszVar, NULL, 0 );
		BOOL bRetVal = FALSE;

		if( nLength == 0 )
		{
			Empty();
		}
		else
		{
			PXSTR pszBuffer = GetBuffer( nLength );
			StringTraits::GetEnvironmentVariable( pszVar, pszBuffer, nLength );
			ReleaseBuffer();
			bRetVal = TRUE;
		}

		return( bRetVal );
	}

	// Load the string from resource 'nID'
	_Check_return_ BOOL LoadString(_In_ UINT nID)
	{
		HINSTANCE hInst = StringTraits::FindStringResourceInstance( nID );
		if( hInst == NULL )
		{
			return( FALSE );
		}

		return( LoadString( hInst, nID ) );
	}

	// Load the string from resource 'nID' in module 'hInstance'
	_Check_return_ BOOL LoadString(
		_In_ HINSTANCE hInstance,
		_In_ UINT nID)
	{
		const ATLSTRINGRESOURCEIMAGE* pImage = AtlGetStringResourceImage( hInstance, nID );
		if( pImage == NULL )
		{
			return( FALSE );
		}

		int nLength = StringTraits::GetBaseTypeLength( pImage->achString, pImage->nLength );
		PXSTR pszBuffer = GetBuffer( nLength );
		StringTraits::ConvertToBaseType( pszBuffer, nLength, pImage->achString, pImage->nLength );
		ReleaseBufferSetLength( nLength );

		return( TRUE );
	}

	// Load the string from resource 'nID' in module 'hInstance', using language 'wLanguageID'
	_Check_return_ BOOL LoadString(
		_In_ HINSTANCE hInstance,
		_In_ UINT nID,
		_In_ WORD wLanguageID)
	{
		const ATLSTRINGRESOURCEIMAGE* pImage = AtlGetStringResourceImage( hInstance, nID, wLanguageID );
		if( pImage == NULL )
		{
			return( FALSE );
		}

		int nLength = StringTraits::GetBaseTypeLength( pImage->achString, pImage->nLength );
		PXSTR pszBuffer = GetBuffer( nLength );
		StringTraits::ConvertToBaseType( pszBuffer, nLength, pImage->achString, pImage->nLength );
		ReleaseBufferSetLength( nLength );

		return( TRUE );
	}

	friend CStringT operator+(
		_In_ const CStringT& str1,
		_In_ const CStringT& str2)
	{
		CStringT strResult( str1.GetManager() );

		Concatenate( strResult, str1, str1.GetLength(), str2, str2.GetLength() );

		return( strResult );
	}

	friend CStringT operator+(
		_In_ const CStringT& str1,
		_In_z_ PCXSTR psz2)
	{
		CStringT strResult( str1.GetManager() );

		Concatenate( strResult, str1, str1.GetLength(), psz2, StringLength( psz2 ) );

		return( strResult );
	}

	friend CStringT operator+(
		_In_z_ PCXSTR psz1,
		_In_ const CStringT& str2)
	{
		CStringT strResult( str2.GetManager() );

		Concatenate( strResult, psz1, StringLength( psz1 ), str2, str2.GetLength() );

		return( strResult );
	}

#ifdef _CSTRING_DISABLE_NARROW_WIDE_CONVERSION
#define _CSTRING_CHAR_T XCHAR
#else // def _CSTRING_NARROW_WIDE_CONVERSION
#define _CSTRING_CHAR_T char
#endif // def _CSTRING_NARROW_WIDE_CONVERSION

	friend CStringT operator+(
		_In_ const CStringT& str1,
		_In_ _CSTRING_CHAR_T ch2)
	{
		CStringT strResult( str1.GetManager() );
		XCHAR chTemp = XCHAR( ch2 );

		Concatenate( strResult, str1, str1.GetLength(), &chTemp, 1 );

		return( strResult );
	}

	friend CStringT operator+(
		_In_ _CSTRING_CHAR_T ch1,
		_In_ const CStringT& str2)
	{
		CStringT strResult( str2.GetManager() );
		XCHAR chTemp = XCHAR( ch1 );

		Concatenate( strResult, &chTemp, 1, str2, str2.GetLength() );

		return( strResult );
	}

#ifndef _CSTRING_DISABLE_NARROW_WIDE_CONVERSION
	friend CStringT operator+(
		_In_ const CStringT& str1,
		_In_ wchar_t ch2)
	{
		CStringT strResult( str1.GetManager() );
		XCHAR chTemp = XCHAR( ch2 );

		Concatenate( strResult, str1, str1.GetLength(), &chTemp, 1 );

		return( strResult );
	}

	friend CStringT operator+(
		_In_ wchar_t ch1,
		_In_ const CStringT& str2)
	{
		CStringT strResult( str2.GetManager() );
		XCHAR chTemp = XCHAR( ch1 );

		Concatenate( strResult, &chTemp, 1, str2, str2.GetLength() );

		return( strResult );
	}
#endif // ndef _CSTRING_DISABLE_NARROW_WIDE_CONVERSION

	friend bool operator==(
		_In_ const CStringT& str1,
		_In_ const CStringT& str2) throw()
	{
		return( str1.Compare( str2 ) == 0 );
	}

	friend bool operator==(
		_In_ const CStringT& str1,
		_In_z_ PCXSTR psz2) throw()
	{
		return( str1.Compare( psz2 ) == 0 );
	}

	friend bool operator==(
		_In_z_ PCXSTR psz1,
		_In_ const CStringT& str2) throw()
	{
		return( str2.Compare( psz1 ) == 0 );
	}

#ifndef _CSTRING_DISABLE_NARROW_WIDE_CONVERSION
	friend bool operator==(
		_In_ const CStringT& str1,
		_In_z_ PCYSTR psz2) throw( ... )
	{
		CStringT str2( psz2, str1.GetManager() );

		return( str1 == str2 );
	}

	friend bool operator==(
		_In_z_ PCYSTR psz1,
		_In_ const CStringT& str2) throw( ... )
	{
		CStringT str1( psz1, str2.GetManager() );

		return( str1 == str2 );
	}
#endif // ndef _CSTRING_DISABLE_NARROW_WIDE_CONVERSION

	friend bool operator!=(
		_In_ const CStringT& str1,
		_In_ const CStringT& str2 ) throw()
	{
		return( str1.Compare( str2 ) != 0 );
	}

	friend bool operator!=(
		_In_ const CStringT& str1,
		_In_z_ PCXSTR psz2) throw()
	{
		return( str1.Compare( psz2 ) != 0 );
	}

	friend bool operator!=(
		_In_z_ PCXSTR psz1,
		_In_ const CStringT& str2) throw()
	{
		return( str2.Compare( psz1 ) != 0 );
	}

#ifndef _CSTRING_DISABLE_NARROW_WIDE_CONVERSION
	friend bool operator!=(
		_In_ const CStringT& str1,
		_In_z_ PCYSTR psz2) throw( ... )
	{
		CStringT str2( psz2, str1.GetManager() );

		return( str1 != str2 );
	}

	friend bool operator!=(
		_In_z_ PCYSTR psz1,
		_In_ const CStringT& str2) throw( ... )
	{
		CStringT str1( psz1, str2.GetManager() );

		return( str1 != str2 );
	}
#endif // ndef _CSTRING_DISABLE_NARROW_WIDE_CONVERSION

	friend bool operator<(
		_In_ const CStringT& str1,
		_In_ const CStringT& str2) throw()
	{
		return( str1.Compare( str2 ) < 0 );
	}

	friend bool operator<(
		_In_ const CStringT& str1,
		_In_z_ PCXSTR psz2 ) throw()
	{
		return( str1.Compare( psz2 ) < 0 );
	}

	friend bool operator<(
		_In_z_ PCXSTR psz1,
		_In_ const CStringT& str2) throw()
	{
		return( str2.Compare( psz1 ) > 0 );
	}

	friend bool operator>(
		_In_ const CStringT& str1,
		_In_ const CStringT& str2) throw()
	{
		return( str1.Compare( str2 ) > 0 );
	}

	friend bool operator>(
		_In_ const CStringT& str1,
		_In_z_ PCXSTR psz2) throw()
	{
		return( str1.Compare( psz2 ) > 0 );
	}

	friend bool operator>(
		_In_z_ PCXSTR psz1,
		_In_ const CStringT& str2) throw()
	{
		return( str2.Compare( psz1 ) < 0 );
	}

	friend bool operator<=(
		_In_ const CStringT& str1,
		_In_ const CStringT& str2) throw()
	{
		return( str1.Compare( str2 ) <= 0 );
	}

	friend bool operator<=(
		_In_ const CStringT& str1,
		_In_z_ PCXSTR psz2) throw()
	{
		return( str1.Compare( psz2 ) <= 0 );
	}

	friend bool operator<=(
		_In_z_ PCXSTR psz1,
		_In_ const CStringT& str2) throw()
	{
		return( str2.Compare( psz1 ) >= 0 );
	}

	friend bool operator>=(
		_In_ const CStringT& str1,
		_In_ const CStringT& str2) throw()
	{
		return( str1.Compare( str2 ) >= 0 );
	}

	friend bool operator>=(
		_In_ const CStringT& str1,
		_In_z_ PCXSTR psz2) throw()
	{
		return( str1.Compare( psz2 ) >= 0 );
	}

	friend bool operator>=(
		_In_z_ PCXSTR psz1,
		_In_ const CStringT& str2) throw()
	{
		return( str2.Compare( psz1 ) <= 0 );
	}

	friend bool operator==(
		_In_ XCHAR ch1,
		_In_ const CStringT& str2) throw()
	{
		return( (str2.GetLength() == 1) && (str2[0] == ch1) );
	}

	friend bool operator==(
		_In_ const CStringT& str1,
		_In_ XCHAR ch2) throw()
	{
		return( (str1.GetLength() == 1) && (str1[0] == ch2) );
	}

	friend bool operator!=(
		_In_ XCHAR ch1,
		_In_ const CStringT& str2) throw()
	{
		return( (str2.GetLength() != 1) || (str2[0] != ch1) );
	}

	friend bool operator!=(
		_In_ const CStringT& str1,
		_In_ XCHAR ch2) throw()
	{
		return( (str1.GetLength() != 1) || (str1[0] != ch2) );
	}

private:
	bool CheckImplicitLoad(_In_opt_ const void* pv)
	{
		bool bRet = false;

		if( (pv != NULL) && IS_INTRESOURCE( pv ) )
		{
			UINT nID = LOWORD( reinterpret_cast< DWORD_PTR >( pv ) );
			if( !LoadString( nID ) )
			{
				ATLTRACE( atlTraceString, 2, _T( "Warning: implicit LoadString(%u) failed\n" ), nID );
			}
			bRet = true;
		}

		return( bRet );
	}

};

#ifndef _CSTRING_BUFFER_SIZE
#define _CSTRING_BUFFER_SIZE(_CStringObj) ((_CStringObj).GetAllocLength() + 1)
#endif

#pragma warning(push)
#pragma warning(disable : 4793)
// Format data using format string 'pszFormat'
template< typename BaseType, class StringTraits >
inline void __cdecl CStringT<BaseType, StringTraits>::Format(
	_In_z_ _FormatMessage_format_string_ PCXSTR pszFormat,
	...)
{
	ATLASSERT( AtlIsValidString( pszFormat ) );

	va_list argList;
	va_start( argList, pszFormat );
	FormatV( pszFormat, argList );
	va_end( argList );
}

// Format data using format string loaded from resource 'nFormatID'
template< typename BaseType, class StringTraits >
inline void __cdecl CStringT<BaseType, StringTraits>::Format(
	_In_ _FormatMessage_format_string_ UINT nFormatID,
	...)
{
	CStringT strFormat( GetManager() );
	ATLENSURE( strFormat.LoadString( nFormatID ) );

	va_list argList;
	va_start( argList, nFormatID );
	FormatV( strFormat, argList );
	va_end( argList );
}

// Append formatted data using format string loaded from resource 'nFormatID'
template< typename BaseType, class StringTraits >
inline void __cdecl CStringT<BaseType, StringTraits>::AppendFormat(
	_In_ _FormatMessage_format_string_ UINT nFormatID,
	...)
{
	va_list argList;
	va_start( argList, nFormatID );

	CStringT strFormat( GetManager() );
	ATLENSURE( strFormat.LoadString( nFormatID ) );

	AppendFormatV( strFormat, argList );

	va_end( argList );
}


// Append formatted data using format string 'pszFormat'
template< typename BaseType, class StringTraits >
inline void __cdecl CStringT<BaseType, StringTraits>::AppendFormat(
	_In_z_ _FormatMessage_format_string_ PCXSTR pszFormat, 
	...)
{
	ATLASSERT( AtlIsValidString( pszFormat ) );

	va_list argList;
	va_start( argList, pszFormat );

	AppendFormatV( pszFormat, argList );

	va_end( argList );
}

// Format a message using format string 'pszFormat'
template< typename BaseType, class StringTraits >
inline void __cdecl CStringT<BaseType, StringTraits>::_AFX_FUNCNAME(FormatMessage)(
	_In_z_ _FormatMessage_format_string_ PCXSTR pszFormat, 
	...)
{
	if(pszFormat == NULL)
		AtlThrow(E_INVALIDARG);

	va_list argList;
	va_start( argList, pszFormat );

	FormatMessageV( pszFormat, &argList );

	va_end( argList );
}

#if defined(_AFX)
template< typename BaseType, class StringTraits >
inline void __cdecl CStringT<BaseType, StringTraits>::FormatMessage(
	_In_z_ _FormatMessage_format_string_ PCXSTR pszFormat, 
	...)
{
	if(pszFormat == NULL)
		AtlThrow(E_INVALIDARG);

	va_list argList;
	va_start( argList, pszFormat );

	FormatMessageV( pszFormat, &argList );

	va_end( argList );
}
#endif

// Format a message using format string loaded from resource 'nFormatID'
template< typename BaseType, class StringTraits >
inline void __cdecl CStringT<BaseType, StringTraits>::_AFX_FUNCNAME(FormatMessage)(
	_In_ _FormatMessage_format_string_ UINT nFormatID, 
	...)
{
	// get format string from string table
	CStringT strFormat( GetManager() );
	ATLENSURE( strFormat.LoadString( nFormatID ) );

	if(strFormat.GetLength() == 0)
		AtlThrow(E_INVALIDARG);

	va_list argList;
	va_start( argList, nFormatID );

	FormatMessageV( strFormat, &argList );

	va_end( argList );
}

#if defined(_AFX)
template< typename BaseType, class StringTraits >
inline void __cdecl CStringT<BaseType, StringTraits>::FormatMessage(
	_In_ _FormatMessage_format_string_ UINT nFormatID, 
	...)
{
	// get format string from string table
	CStringT strFormat( GetManager() );

	ATLENSURE( strFormat.LoadString( nFormatID ) );

	if(strFormat.GetLength() == 0)
		AtlThrow(E_INVALIDARG);

	va_list argList;
	va_start( argList, nFormatID );

	FormatMessageV( strFormat, &argList );

	va_end( argList );
}
#endif

#pragma warning( pop )

class IFixedStringLog
{
public:
	virtual void OnAllocateSpill(
		_In_ int nActualChars,
		_In_ int nFixedChars,
		_In_ const CStringData* pData) throw() = 0;
	virtual void OnReallocateSpill(
		_In_ int nActualChars,
		_In_ int nFixedChars,
		_In_ const CStringData* pData) throw() = 0;
};

class CFixedStringMgr :
	public IAtlStringMgr
{
public:
	CFixedStringMgr(
			_Inout_ CStringData* pData,
			_In_ int nChars,
			_In_opt_ IAtlStringMgr* pMgr = NULL) throw() :
		m_pData( pData ),
		m_pMgr( pMgr )
	{
		m_pData->nRefs = -1;
		m_pData->nDataLength = 0;
		m_pData->nAllocLength = nChars;
		m_pData->pStringMgr = this;
		*static_cast< wchar_t* >( m_pData->data() ) = 0;
	}
	virtual ~CFixedStringMgr() throw()
	{
	}

// IAtlStringMgr
public:
	virtual CStringData* Allocate(
		_In_ int nChars,
		_In_ int nCharSize) throw()
	{
		ATLASSUME( m_pData->nRefs == -1 );
		ATLASSUME( m_pData->nDataLength == 0 );
		ATLASSERT(nChars>=0);

		/* no way to report problems here; allocate empty */
		if(nChars<0)
		{
			nChars=0;
		}

		if( nChars > m_pData->nAllocLength )
		{
			if( s_pLog != NULL )
			{
				s_pLog->OnAllocateSpill( nChars, m_pData->nAllocLength, m_pData );
			}
			CStringData* pData = m_pMgr->Allocate( nChars, nCharSize );
			if( pData != NULL )
			{
				pData->pStringMgr = this;
				pData->nRefs = -1;  // Locked
			}

			return pData;
		}

		m_pData->nRefs = -1;  // Locked
		m_pData->nDataLength = 0;
		m_pData->pStringMgr = this;

		return m_pData;
	}
	virtual void Free(_Inout_ CStringData* pData) throw()
	{
		ATLASSERT( pData->nRefs <= 0 );
		if( pData != m_pData )
		{
			// Must have been allocated from the backup manager
			pData->pStringMgr = m_pMgr;
			m_pMgr->Free( pData );
		}

		// Always make sure the fixed buffer is ready to be used as the nil string.
		m_pData->nRefs = -1;
		m_pData->nDataLength = 0;
		*static_cast< wchar_t* >( m_pData->data() ) = 0;
	}
	virtual CStringData* Reallocate(
		_Inout_ CStringData* pData,
		_In_ int nChars,
		_In_ int nCharSize) throw()
	{
		CStringData* pNewData;

		ATLASSERT( pData->nRefs < 0 );
		if( pData != m_pData )
		{
			pData->pStringMgr = m_pMgr;
			pNewData = m_pMgr->Reallocate( pData, nChars, nCharSize );
			if( pNewData == NULL )
			{
				pData->pStringMgr = this;
			}
			else
			{
				pNewData->pStringMgr = this;
			}
		}
		else
		{
			if( nChars > pData->nAllocLength )
			{
				if( s_pLog != NULL )
				{
					s_pLog->OnReallocateSpill( nChars, pData->nAllocLength, pData );
				}
				pNewData = m_pMgr->Allocate( nChars, nCharSize );
				if( pNewData == NULL )
				{
					return NULL;
				}

				// Copy the string data
				Checked::memcpy_s( pNewData->data(), nChars*nCharSize,
					pData->data(), (pData->nAllocLength+1)*nCharSize );
				pNewData->nRefs = pData->nRefs;  // Locked
				pNewData->pStringMgr = this;
				pNewData->nDataLength = pData->nDataLength;
			}
			else
			{
				// Don't do anything if the buffer is already big enough.
				pNewData = pData;
			}
		}

		return pNewData;
	}
	virtual CStringData* GetNilString() throw()
	{
		ATLASSUME( m_pData->nRefs == -1 );
		ATLASSUME( m_pData->nDataLength == 0 );

		return m_pData;
	}
	virtual IAtlStringMgr* Clone() throw()
	{
		return m_pMgr;
	}

public:
	static IFixedStringLog* s_pLog;

	IAtlStringMgr* GetBackupManager() const throw()
	{
		return m_pMgr;
	}

protected:
	IAtlStringMgr* m_pMgr;
	CStringData* m_pData;
};

__declspec( selectany ) IFixedStringLog* CFixedStringMgr::s_pLog = NULL;

#pragma warning( push )
#pragma warning( disable: 4355 )  // 'this' used in base member initializer list

template< class StringType, int t_nChars >
class CFixedStringT :
	private CFixedStringMgr,  // This class must be first, since it needs to be initialized before StringType
	public StringType
{
public:
	CFixedStringT() throw() :
		CFixedStringMgr( &m_data, t_nChars, StrTraits::GetDefaultManager() ),
		StringType( static_cast< IAtlStringMgr* >( this ) )
	{
	}

	explicit CFixedStringT(_In_ IAtlStringMgr* pStringMgr) throw() :
		CFixedStringMgr( &m_data, t_nChars, pStringMgr ),
		StringType( static_cast< IAtlStringMgr* >( this ) )
	{
	}

	CFixedStringT(_In_ const CFixedStringT< StringType, t_nChars >& str) :
		CFixedStringMgr( &m_data, t_nChars, StrTraits::GetDefaultManager() ),
		StringType( str.GetString(), str.GetLength(), static_cast< CFixedStringMgr* >( this ) )
	{
	}

	CFixedStringT(_In_ const StringType& str) :
		CFixedStringMgr( &m_data, t_nChars, StrTraits::GetDefaultManager() ),
		StringType( str.GetString(), str.GetLength(), static_cast< CFixedStringMgr* >( this ) )
	{
	}

	CFixedStringT(_In_z_ const typename StringType::XCHAR* psz) :
		CFixedStringMgr( &m_data, t_nChars, StrTraits::GetDefaultManager() ),
		StringType( psz, static_cast< CFixedStringMgr* >( this ) )
	{
	}

	CFixedStringT(_In_count_(nLength) const typename StringType::XCHAR* psz, _In_ int nLength) :
		CFixedStringMgr( &m_data, t_nChars, StrTraits::GetDefaultManager() ),
		StringType( psz, nLength, static_cast< CFixedStringMgr* >( this ) )
	{
	}

	explicit CFixedStringT(_In_z_ const typename StringType::YCHAR* psz) :
		CFixedStringMgr( &m_data, t_nChars, StrTraits::GetDefaultManager() ),
		StringType( psz, static_cast< CFixedStringMgr* >( this ) )
	{
	}

	explicit CFixedStringT(_In_z_ const unsigned char* psz) :
		CFixedStringMgr( &m_data, t_nChars, StrTraits::GetDefaultManager() ),
		StringType( psz, static_cast< CFixedStringMgr* >( this ) )
	{
	}

	~CFixedStringT() throw()
	{
		Empty();
	}

	CFixedStringT< StringType, t_nChars >& operator=(
		_In_ const CFixedStringT< StringType, t_nChars >& str)
	{
		StringType::operator=( str );
		return *this;
	}

	CFixedStringT< StringType, t_nChars >& operator=(_In_z_ const char* psz)
	{
		StringType::operator=( psz );
		return *this;
	}

	CFixedStringT< StringType, t_nChars >& operator=(_In_z_ const wchar_t* psz)
	{
		StringType::operator=( psz );
		return *this;
	}

	CFixedStringT< StringType, t_nChars >& operator=(_In_z_ const unsigned char* psz)
	{
		StringType::operator=( psz );
		return *this;
	}

	CFixedStringT< StringType, t_nChars >& operator=(_In_ const StringType& str)
	{
		StringType::operator=( str );
		return *this;
	}

// Implementation
protected:
	CStringData m_data;
	typename StringType::XCHAR m_achData[t_nChars+1];
};

#pragma warning( pop )
class CFixedStringLog :
	public IFixedStringLog
{
public:
	CFixedStringLog() throw()
	{
		CFixedStringMgr::s_pLog = this;
	}
	virtual ~CFixedStringLog() throw()
	{
		CFixedStringMgr::s_pLog = NULL;
	}

public:
	void OnAllocateSpill(
		_In_ int nActualChars,
		_In_ int nFixedChars,
		_In_ const CStringData* pData) throw()
	{
		(void)nActualChars;
		(void)nFixedChars;
		(void)pData;
		ATLTRACE( atlTraceString, 0, _T( "CFixedStringMgr::Allocate() spilling to heap.  %d chars (fixed size = %d chars)\n" ), nActualChars, nFixedChars );
	}
	void OnReallocateSpill(
		_In_ int nActualChars,
		_In_ int nFixedChars,
		_In_ const CStringData* pData) throw()
	{
		(void)nActualChars;
		(void)nFixedChars;
		(void)pData;
		ATLTRACE( atlTraceString, 0, _T( "CFixedStringMgr::Reallocate() spilling to heap.  %d chars (fixed size = %d chars)\n" ), nActualChars, nFixedChars );
	}
};

template< typename T >
class CStringElementTraits
{
public:
	typedef typename T::PCXSTR INARGTYPE;
	typedef T& OUTARGTYPE;

	static void __cdecl CopyElements(
		_Out_capcount_(nElements) T* pDest,
		_In_count_(nElements) const T* pSrc,
		_In_ size_t nElements)
	{
		for( size_t iElement = 0; iElement < nElements; iElement++ )
		{
			pDest[iElement] = pSrc[iElement];
		}
	}

	static void __cdecl RelocateElements(
		_Out_capcount_(nElements) T* pDest,
		_In_count_(nElements) T* pSrc,
		_In_ size_t nElements)
	{
		Checked::memmove_s( pDest, nElements*sizeof( T ), pSrc, nElements*sizeof( T ) );
	}

	static ULONG __cdecl Hash(_In_ INARGTYPE str)
	{
		ATLENSURE( str != NULL );
		ULONG nHash = 0;
		const T::XCHAR* pch = str;
		while( *pch != 0 )
		{
			nHash = (nHash<<5)+nHash+(*pch);
			pch++;
		}

		return( nHash );
	}

	static bool __cdecl CompareElements(
		_In_ INARGTYPE str1,
		_In_ INARGTYPE str2)
	{
		return( T::StrTraits::StringCompare( str1, str2 ) == 0 );
	}

	static int __cdecl CompareElementsOrdered(
		_In_ INARGTYPE str1,
		_In_ INARGTYPE str2)
	{
		return( T::StrTraits::StringCompare( str1, str2 ) );
	}
};

#pragma pop_macro("new")

#if defined(_AFX)
#pragma pop_macro("FormatMessage")
#endif

};  // namespace ATL



#ifdef __ATLCOMCLI_H__
#include <cstringt.inl>
#endif	// __ATLCOMCLI_H__


#ifndef _ATL_NO_PRAGMA_WARNINGS
#pragma warning (pop)
#endif


#endif	// __CSTRINGT_H__ (whole file)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\include\ocdbid.h ===
/*=--------------------------------------------------------------------------=
 * ocdbid.h
 *=--------------------------------------------------------------------------=
 * defines all the guids for OLE Controls Data Binding Interfaces interfaces.
 *
 * Copyright (c) Microsoft Corporation, All Rights Reserved.
 *
 */

/* {9F6AA700-D188-11cd-AD48-00AA003C9CB6} */
DEFINE_GUID(IID_ICursor,
0x9f6aa700, 0xd188, 0x11cd, 0xad, 0x48, 0x0, 0xaa, 0x0, 0x3c, 0x9c, 0xb6);

/* {ACFF0690-D188-11cd-AD48-00AA003C9CB6} */
DEFINE_GUID(IID_ICursorMove,
0xacff0690, 0xd188, 0x11cd, 0xad, 0x48, 0x0, 0xaa, 0x0, 0x3c, 0x9c, 0xb6);

/* {BB87E420-D188-11cd-AD48-00AA003C9CB6} */
DEFINE_GUID(IID_ICursorScroll,
0xbb87e420, 0xd188, 0x11cd, 0xad, 0x48, 0x0, 0xaa, 0x0, 0x3c, 0x9c, 0xb6);

/* {D14216A0-D188-11cd-AD48-00AA003C9CB6} */
DEFINE_GUID(IID_ICursorUpdateARow,
0xd14216a0, 0xd188, 0x11cd, 0xad, 0x48, 0x0, 0xaa, 0x0, 0x3c, 0x9c, 0xb6);

/* {DB526CC0-D188-11cd-AD48-00AA003C9CB6} */
DEFINE_GUID(IID_INotifyDBEvents,
0xdb526cc0, 0xd188, 0x11cd, 0xad, 0x48, 0x0, 0xaa, 0x0, 0x3c, 0x9c, 0xb6);

/* {E01D7850-D188-11cd-AD48-00AA003C9CB6} */
DEFINE_GUID(IID_ICursorFind,
0xe01d7850, 0xd188, 0x11cd, 0xad, 0x48, 0x0, 0xaa, 0x0, 0x3c, 0x9c, 0xb6);

/* {E4D19810-D188-11cd-AD48-00AA003C9CB6} */
DEFINE_GUID(IID_IEntryID,
0xe4d19810, 0xd188, 0x11cd, 0xad, 0x48, 0x0, 0xaa, 0x0, 0x3c, 0x9c, 0xb6);

/* {E8BF1170-D188-11cd-AD48-00AA003C9CB6} */
DEFINE_GUID(_GUID_NAMEONLY,
0xe8bf1170, 0xd188, 0x11cd, 0xad, 0x48, 0x0, 0xaa, 0x0, 0x3c, 0x9c, 0xb6);

/* {F6304BB0-D188-11cd-AD48-00AA003C9CB6} */
DEFINE_GUID(_DBBMKGUID,
0xf6304bb0, 0xd188, 0x11cd, 0xad, 0x48, 0x0, 0xaa, 0x0, 0x3c, 0x9c, 0xb6);

/* {FE284700-D188-11cd-AD48-00AA003C9CB6} */
//DEFINE_GUID(_DBCIDGUID,
//0xfe284700, 0xd188, 0x11cd, 0xad, 0x48, 0x0, 0xaa, 0x0, 0x3c, 0x9c, 0xb6);

// OLEDB interface guids

/* {0x0c733a30,0x2a1c,0x11ce,{0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d}} */
DEFINE_GUID(IID_ISequentialStream,
0x0c733a30,0x2a1c,0x11ce,0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d);

/* {0x0c733a8c,0x2a1c,0x11ce,{0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d}} */
DEFINE_GUID(IID_IAccessor,
0x0c733a8c,0x2a1c,0x11ce,0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d);

/* {0x0c733a7c,0x2a1c,0x11ce,{0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d}} */
DEFINE_GUID(IID_IRowset,
0x0c733a7c,0x2a1c,0x11ce,0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d);

/* {0x0c733a55,0x2a1c,0x11ce,{0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d}} */
DEFINE_GUID(IID_IRowsetInfo,
0x0c733a55,0x2a1c,0x11ce,0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d);

/* {0x0c733a7d,0x2a1c,0x11ce,{0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d}} */
DEFINE_GUID(IID_IRowsetLocate,
0x0c733a7d,0x2a1c,0x11ce,0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d);

/* {0x0c733a84,0x2a1c,0x11ce,{0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d}} */
DEFINE_GUID(IID_IRowsetResynch,
0x0c733a84,0x2a1c,0x11ce,0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d);

/* {0x0c733a7e,0x2a1c,0x11ce,{0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d}} */
DEFINE_GUID(IID_IRowsetScroll,
0x0c733a7e,0x2a1c,0x11ce,0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d);

/* {0x0c733a05,0x2a1c,0x11ce,{0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d}} */
DEFINE_GUID(IID_IRowsetChange,
0x0c733a05,0x2a1c,0x11ce,0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d);

/* {0x0c733a6d,0x2a1c,0x11ce,{0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d}} */
DEFINE_GUID(IID_IRowsetUpdate,
0x0c733a6d,0x2a1c,0x11ce,0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d);

/* {0x0c733a09,0x2a1c,0x11ce,{0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d}} */
DEFINE_GUID(IID_IRowsetIdentity,
0x0c733a09,0x2a1c,0x11ce,0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d);

/* {0x0c733a83,0x2a1c,0x11ce,{0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d}} */
DEFINE_GUID(IID_IRowsetNotify,
0x0c733a83,0x2a1c,0x11ce,0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d);

/* {0x0c733a82,0x2a1c,0x11ce,{0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d}} */
DEFINE_GUID(IID_IRowsetIndex,
0x0c733a82,0x2a1c,0x11ce,0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d);

/* {0x0c733a63,0x2a1c,0x11ce,{0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d}} */
DEFINE_GUID(IID_ICommand,
0x0c733a63,0x2a1c,0x11ce,0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d);

/* {0x0c733a90,0x2a1c,0x11ce,{0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d}} */
DEFINE_GUID(IID_IMultipleResults,
0x0c733a90,0x2a1c,0x11ce,0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d);

/* {0x0c733a88,0x2a1c,0x11ce,{0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d}} */
DEFINE_GUID(IID_IConvertType,
0x0c733a88,0x2a1c,0x11ce,0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d);

/* {0x0c733a26,0x2a1c,0x11ce,{0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d}} */
DEFINE_GUID(IID_ICommandPrepare,
0x0c733a26,0x2a1c,0x11ce,0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d);

/* {0x0c733a79,0x2a1c,0x11ce,{0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d}} */
DEFINE_GUID(IID_ICommandProperties,
0x0c733a79,0x2a1c,0x11ce,0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d);

/* {0x0c733a27,0x2a1c,0x11ce,{0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d}} */
DEFINE_GUID(IID_ICommandText,
0x0c733a27,0x2a1c,0x11ce,0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d);

/* {0x0c733a64,0x2a1c,0x11ce,{0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d}} */
DEFINE_GUID(IID_ICommandWithParameters,
0x0c733a64,0x2a1c,0x11ce,0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d);

/* {0x0c733a10,0x2a1c,0x11ce,{0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d}} */
DEFINE_GUID(IID_IColumnsRowset,
0x0c733a10,0x2a1c,0x11ce,0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d);

/* {0x0c733a11,0x2a1c,0x11ce,{0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d}} */
DEFINE_GUID(IID_IColumnsInfo,
0x0c733a11,0x2a1c,0x11ce,0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d);

/* {0x0c733a1d,0x2a1c,0x11ce,{0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d}} */
DEFINE_GUID(IID_IDBCreateCommand,
0x0c733a1d,0x2a1c,0x11ce,0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d);

/* {0x0c733a5d,0x2a1c,0x11ce,{0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d}} */
DEFINE_GUID(IID_IDBCreateSession,
0x0c733a5d,0x2a1c,0x11ce,0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d);

/* {0x0c733a1e,0x2a1c,0x11ce,{0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d}} */
DEFINE_GUID(IID_ISourcesRowset,
0x0c733a1e,0x2a1c,0x11ce,0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d);

/* {0x0c733a8a,0x2a1c,0x11ce,{0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d}} */
DEFINE_GUID(IID_IDBProperties,
0x0c733a8a,0x2a1c,0x11ce,0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d);

/* {0x0c733a8b,0x2a1c,0x11ce,{0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d}} */
DEFINE_GUID(IID_IDBInitialize,
0x0c733a8b,0x2a1c,0x11ce,0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d);

/* {0x0c733a89,0x2a1c,0x11ce,{0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d}} */
DEFINE_GUID(IID_IDBInfo,
0x0c733a89,0x2a1c,0x11ce,0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d);

/* {0x0c733a7a,0x2a1c,0x11ce,{0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d}} */
DEFINE_GUID(IID_IDBDataSourceAdmin,
0x0c733a7a,0x2a1c,0x11ce,0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d);

/* {0x0c733a85,0x2a1c,0x11ce,{0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d}} */
DEFINE_GUID(IID_ISessionProperties,
0x0c733a85,0x2a1c,0x11ce,0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d);

/* {0x0c733a68,0x2a1c,0x11ce,{0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d}} */
DEFINE_GUID(IID_IIndexDefinition,
0x0c733a68,0x2a1c,0x11ce,0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d);

/* {0x0c733a86,0x2a1c,0x11ce,{0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d}} */
DEFINE_GUID(IID_ITableDefinition,
0x0c733a86,0x2a1c,0x11ce,0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d);

/* {0x0c733a69,0x2a1c,0x11ce,{0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d}} */
DEFINE_GUID(IID_IOpenRowset,
0x0c733a69,0x2a1c,0x11ce,0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d);

/* {0x0c733a7b,0x2a1c,0x11ce,{0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d}} */
DEFINE_GUID(IID_IDBSchemaRowset,
0x0c733a7b,0x2a1c,0x11ce,0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d);

/* {0x0c733a67,0x2a1c,0x11ce,{0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d}} */
DEFINE_GUID(IID_IErrorRecords,
0x0c733a67,0x2a1c,0x11ce,0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d);

/* {0x0c733a66,0x2a1c,0x11ce,{0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d}} */
DEFINE_GUID(IID_IErrorLookup,
0x0c733a66,0x2a1c,0x11ce,0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d);

/* {0x0c733a74,0x2a1c,0x11ce,{0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d}} */
DEFINE_GUID(IID_ISQLErrorInfo,
0x0c733a74,0x2a1c,0x11ce,0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d);

/* {0x0c733a75,0x2a1c,0x11ce,{0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d}} */
DEFINE_GUID(IID_IGetDataSource,
0x0c733a75,0x2a1c,0x11ce,0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d);

/* {0x0c733a5f,0x2a1c,0x11ce,{0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d}} */
DEFINE_GUID(IID_ITransactionLocal,
0x0c733a5f,0x2a1c,0x11ce,0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d);

/* {0x0c733a5e,0x2a1c,0x11ce,{0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d}} */
DEFINE_GUID(IID_ITransactionJoin,
0x0c733a5e,0x2a1c,0x11ce,0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d);

/* {0x0c733a60,0x2a1c,0x11ce,{0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d}} */
DEFINE_GUID(IID_ITransactionObject,
0x0c733a60,0x2a1c,0x11ce,0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d);

//@@@+ V2.0
#if( OLEDBVER >= 0x0200 )

/* {0x0c733a7f,0x2a1c,0x11ce,{0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d}} */
DEFINE_GUID(IID_IRowsetExactScroll,
0x0c733a7f,0x2a1c,0x11ce,0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d);

/* {0x0c733a72,0x2a1c,0x11ce,{0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d}} */
DEFINE_GUID(IID_IRowsetNextRowset,
0x0c733a72,0x2a1c,0x11ce,0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d);

/* {0x0c733a71,0x2a1c,0x11ce,{0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d}} */
DEFINE_GUID(IID_IRowsetNewRowAfter,
0x0c733a71,0x2a1c,0x11ce,0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d);

/* {0x0c733a6e,0x2a1c,0x11ce,{0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d}} */
DEFINE_GUID(IID_IRowsetWithParameters,
0x0c733a6e,0x2a1c,0x11ce,0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d);

/* {0x0c733a0d,0x2a1c,0x11ce,{0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d}} */
DEFINE_GUID(IID_IRowsetFind,
0x0c733a0d,0x2a1c,0x11ce,0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d);

/* {0x0c733a0f,0x2a1c,0x11ce,{0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d}} */
DEFINE_GUID(IID_IRowsetAsynch,
0x0c733a0f,0x2a1c,0x11ce,0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d);

/* {0x0c733a12,0x2a1c,0x11ce,{0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d}} */
DEFINE_GUID(IID_IRowsetKeys,
0x0c733a12,0x2a1c,0x11ce,0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d);

/* {0x0c733a73,0x2a1c,0x11ce,{0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d}} */
DEFINE_GUID(IID_IRowsetWatchAll,
0x0c733a73,0x2a1c,0x11ce,0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d);

/* {0x0c733a44,0x2a1c,0x11ce,{0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d}} */
DEFINE_GUID(IID_IRowsetWatchNotify,
0x0c733a44,0x2a1c,0x11ce,0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d);

/* {0x0c733a45,0x2a1c,0x11ce,{0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d}} */
DEFINE_GUID(IID_IRowsetWatchRegion,
0x0c733a45,0x2a1c,0x11ce,0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d);

/* {0x0c733a6b,0x2a1c,0x11ce,{0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d}} */
DEFINE_GUID(IID_IRowsetCopyRows,
0x0c733a6b,0x2a1c,0x11ce,0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d);

/* {0x0c733a6a,0x2a1c,0x11ce,{0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d}} */
DEFINE_GUID(IID_IReadData,
0x0c733a6a,0x2a1c,0x11ce,0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d);

/* {0x0c733a4e,0x2a1c,0x11ce,{0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d}} */
DEFINE_GUID(IID_ICommandCost,
0x0c733a4e,0x2a1c,0x11ce,0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d);

/* {0x0c733a87,0x2a1c,0x11ce,{0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d}} */
DEFINE_GUID(IID_ICommandTree,
0x0c733a87,0x2a1c,0x11ce,0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d);

/* {0x0c733a18,0x2a1c,0x11ce,{0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d}} */
DEFINE_GUID(IID_ICommandValidate,
0x0c733a18,0x2a1c,0x11ce,0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d);

/* {0x0c733a51,0x2a1c,0x11ce,{0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d}} */
DEFINE_GUID(IID_IQuery,
0x0c733a51,0x2a1c,0x11ce,0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d);

/* {0x0c733a77,0x2a1c,0x11ce,{0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d}} */
DEFINE_GUID(IID_ITableRename,
0x0c733a77,0x2a1c,0x11ce,0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d);

/* {0x0c733a50,0x2a1c,0x11ce,{0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d}} */
DEFINE_GUID(IID_IDBSchemaCommand,
0x0c733a50,0x2a1c,0x11ce,0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d);

/* {0x0c733a62,0x2a1c,0x11ce,{0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d}} */
DEFINE_GUID(IID_IDBSecurityInfo,
0x0c733a62,0x2a1c,0x11ce,0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d);

/* {0x0c733a4d,0x2a1c,0x11ce,{0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d}} */
DEFINE_GUID(IID_IProvideMoniker,
0x0c733a4d,0x2a1c,0x11ce,0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d);

#endif // OLEDBVER >= 0x0200
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\include\winres.h ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

// winres.h - Windows resource definitions
//  extracted from WINUSER.H and COMMCTRL.H

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, off)
#endif

#define VS_VERSION_INFO     1

#ifdef APSTUDIO_INVOKED
#define APSTUDIO_HIDDEN_SYMBOLS // Ignore following symbols
#endif

#ifndef WINVER
#define WINVER 0x0501   // default to Windows XP
#endif

#include <winresrc.h>

// operation messages sent to DLGINIT
#define LB_ADDSTRING    (WM_USER+1)
#define CB_ADDSTRING    (WM_USER+3)

#ifdef APSTUDIO_INVOKED
#undef APSTUDIO_HIDDEN_SYMBOLS
#endif

#ifdef IDC_STATIC
#undef IDC_STATIC
#endif
#define IDC_STATIC      (-1)

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, on)
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\include\statreg.h ===
// This is a part of the Active Template Library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Active Template Library Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Active Template Library product.

#ifndef __STATREG_H__
#define __STATREG_H__

#pragma once

#ifndef __cplusplus
	#error ATL requires C++ compilation (use a .cpp suffix)
#endif

#ifndef __ATLBASE_H__
	#error statreg.h requires atlbase.h to be included first
#endif

#pragma warning(push)
#pragma warning(disable:4571) //catch(...) blocks compiled with /EHs do NOT catch or re-throw Structured Exceptions

#define E_ATL_REGISTRAR_DESC              0x0201
#define E_ATL_NOT_IN_MAP                  0x0202
#define E_ATL_UNEXPECTED_EOS              0x0203
#define E_ATL_VALUE_SET_FAILED            0x0204
#define E_ATL_RECURSE_DELETE_FAILED       0x0205
#define E_ATL_EXPECTING_EQUAL             0x0206
#define E_ATL_CREATE_KEY_FAILED           0x0207
#define E_ATL_DELETE_KEY_FAILED           0x0208
#define E_ATL_OPEN_KEY_FAILED             0x0209
#define E_ATL_CLOSE_KEY_FAILED            0x020A
#define E_ATL_UNABLE_TO_COERCE            0x020B
#define E_ATL_BAD_HKEY                    0x020C
#define E_ATL_MISSING_OPENKEY_TOKEN       0x020D
#define E_ATL_CONVERT_FAILED              0x020E
#define E_ATL_TYPE_NOT_SUPPORTED          0x020F
#define E_ATL_COULD_NOT_CONCAT            0x0210
#define E_ATL_COMPOUND_KEY                0x0211
#define E_ATL_INVALID_MAPKEY              0x0212
#define E_ATL_UNSUPPORTED_VT              0x0213
#define E_ATL_VALUE_GET_FAILED            0x0214
#define E_ATL_VALUE_TOO_LARGE             0x0215
#define E_ATL_MISSING_VALUE_DELIMETER     0x0216
#define E_ATL_DATA_NOT_BYTE_ALIGNED       0x0217

#pragma pack(push,_ATL_PACKING)
namespace ATL
{
const TCHAR  chDirSep            = _T('\\');
const TCHAR  chRightBracket      = _T('}');
const TCHAR  chLeftBracket       = _T('{');
const TCHAR  chQuote             = _T('\'');
const TCHAR  chEquals            = _T('=');
const LPCTSTR  szStringVal       = _T("S");
const LPCTSTR  multiszStringVal  = _T("M");
const LPCTSTR  szDwordVal        = _T("D");
const LPCTSTR  szBinaryVal       = _T("B");
const LPCTSTR  szValToken        = _T("Val");
const LPCTSTR  szForceRemove     = _T("ForceRemove");
const LPCTSTR  szNoRemove        = _T("NoRemove");
const LPCTSTR  szDelete          = _T("Delete");


// Implementation helper
class CExpansionVectorEqualHelper
{
public:
	static bool IsEqualKey(
		_In_z_ const LPTSTR k1,
		_In_z_ const LPTSTR k2)
	{
		if (lstrcmpi(k1, k2) == 0)
			return true;
		return false;
	}

	// Not used
	static bool IsEqualValue(
		_In_opt_z_ const LPCOLESTR /*v1*/,
		_In_opt_z_ const LPCOLESTR /*v2*/)
	{
		return false;
	}
};

// Implementation helper
class CExpansionVector : 
	public CSimpleMap<LPTSTR, LPOLESTR, CExpansionVectorEqualHelper >
{
public:
	~CExpansionVector()
	{
		 ClearReplacements();
	}

	BOOL Add(
		_In_z_ LPCTSTR lpszKey,
		_In_z_ LPCOLESTR lpszValue)
	{
		ATLASSERT(lpszKey != NULL && lpszValue != NULL);
		if (lpszKey == NULL || lpszValue == NULL)
			return FALSE;

		HRESULT hRes = S_OK;

		size_t cbKey = (lstrlen(lpszKey)+1)*sizeof(TCHAR);
		TCHAR* szKey = NULL;

		ATLTRY(szKey = new TCHAR[cbKey];)
		CAutoVectorPtr<TCHAR> spKey;
		ATLASSUME(szKey != NULL);
		spKey.Attach(szKey);

		size_t cbValue = (ocslen(lpszValue)+1)*sizeof(OLECHAR);
		LPOLESTR szValue = NULL;
		ATLTRY(szValue = new OLECHAR[cbValue];)
		CAutoVectorPtr<OLECHAR> spValue;
		ATLASSUME(szValue != NULL);
		spValue.Attach(szValue);

		if (szKey == NULL || szValue == NULL)
			hRes = E_OUTOFMEMORY;
		else
		{
			Checked::memcpy_s(szKey, cbKey, lpszKey, cbKey);
			Checked::memcpy_s(szValue, cbValue, lpszValue, cbValue);
			if (!CSimpleMap<LPTSTR, LPOLESTR, CExpansionVectorEqualHelper>::Add(szKey, szValue))
				hRes = E_OUTOFMEMORY;
		}
		if (SUCCEEDED(hRes))
		{
			spKey.Detach();
			spValue.Detach();
		}
		return SUCCEEDED(hRes);
	}
	HRESULT ClearReplacements()
	{
		for (int i = 0; i < GetSize(); i++)
		{
			delete []GetKeyAt(i);
			delete []GetValueAt(i);
		}
		RemoveAll();
		return S_OK;
	}
};

class CRegObject;

class CRegParser
{
public:
	CRegParser(_In_ CRegObject* pRegObj);

	HRESULT PreProcessBuffer(
		_In_z_ LPTSTR lpszReg,
		_Deref_out_z_ LPTSTR* ppszReg);

	HRESULT  RegisterBuffer(
		_In_z_ LPTSTR szReg,
		_In_ BOOL bRegister);

protected:

	static const int MAX_VALUE = 4096;
	void    SkipWhiteSpace();
	HRESULT NextToken(_Out_z_cap_c_(MAX_VALUE) LPTSTR szToken);
	HRESULT AddValue(
		_Inout_ CRegKey& rkParent,
		_In_opt_z_ LPCTSTR szValueName,
		_Out_z_cap_c_(MAX_VALUE) LPTSTR szToken);
	BOOL    CanForceRemoveKey(_In_z_ LPCTSTR szKey);
	BOOL    HasSubKeys(_In_ HKEY hkey);
	BOOL    HasValues(_In_ HKEY hkey);
	HRESULT RegisterSubkeys(
		_Out_z_cap_c_(MAX_VALUE) LPTSTR szToken,
		_In_ HKEY hkParent,
		_In_ BOOL bRegister,
		_In_ BOOL bInRecovery = FALSE);
	BOOL    IsSpace(_In_ TCHAR ch);
	LPTSTR  m_pchCur;

	CRegObject*     m_pRegObj;

	HRESULT GenerateError(_In_ UINT)
	{
		return DISP_E_EXCEPTION;
	}
	//HRESULT HandleReplacements(LPTSTR& szToken);
	HRESULT SkipAssignment(_Inout_z_cap_c_(MAX_VALUE) LPTSTR szToken);

	BOOL    EndOfVar()
	{
		return chQuote == *m_pchCur && chQuote != *CharNext(m_pchCur);
	}
	static LPTSTR StrChr(_In_z_ LPTSTR lpsz, _In_ TCHAR ch);
	static HKEY HKeyFromString(_In_z_ LPTSTR szToken);
	static BYTE ChToByte(_In_ const TCHAR ch);
	static BOOL VTFromRegType(_In_z_ LPCTSTR szValueType, _Out_ VARTYPE& vt);

	static const TCHAR* const rgszNeverDelete[];
	static const int cbNeverDelete;
	static const int MAX_TYPE = 4096;

	// Implementation Helper
	class CParseBuffer
	{
	public:
		int nPos;
		int nSize;
		LPTSTR p;
		CParseBuffer(_In_ int nInitial)
		{
			if (nInitial < 100)
				nInitial = 1000;
			nPos = 0;
			nSize = nInitial;
			p = (LPTSTR) ::ATL::AtlCoTaskMemCAlloc(nSize,static_cast<ULONG>(sizeof(TCHAR)));
			if (p != NULL)
				*p = _T('\0');
		}
		~CParseBuffer()
		{
			CoTaskMemFree(p);
		}
		BOOL Append(
			_In_count_(nChars) const TCHAR* pch,
			_In_ int nChars)
		{
			ATLASSERT(p != NULL);
			int newSize = nPos + nChars + 1;
			if ((newSize <= nPos) || (newSize <= nChars))
				return FALSE;

			if (newSize >= nSize)
			{
				while (newSize >= nSize) {
					if (nSize > INT_MAX / 2)
					return FALSE;
					nSize *= 2;
				}
				LPTSTR pTemp = (LPTSTR)::ATL::AtlCoTaskMemRecalloc(p, nSize, sizeof(TCHAR));
				if (pTemp == NULL)
					return FALSE;
				p = pTemp;
			}
			if ((nPos < 0) || (nPos >= nSize) || nSize - nPos > nSize)
				return FALSE;

#pragma warning(push)
#pragma warning(disable: 22008)
			/* Prefast false warning is fired here despite the all above checks */
			Checked::memcpy_s(p + nPos, (nSize-nPos) * sizeof(TCHAR), pch, int(nChars * sizeof(TCHAR)));
			nPos += nChars;
			*(p + nPos) = _T('\0');
#pragma warning(pop)
			return TRUE;
		}

		BOOL AddChar(_In_z_ const TCHAR* pch)
		{
#ifndef _UNICODE
			int nChars = int(CharNext(pch) - pch);
#else
			int nChars = 1;
#endif
			return Append(pch, nChars);

		}
		BOOL AddString(_In_z_ LPCOLESTR lpsz)
		{
			if (lpsz == NULL)
			{
				return FALSE;
			}
			USES_CONVERSION_EX;
			LPCTSTR lpszT = OLE2CT_EX(lpsz, _ATL_SAFE_ALLOCA_DEF_THRESHOLD);
			if (lpszT == NULL)
			{
				return FALSE;
			}
			return Append(lpszT, (int)lstrlen(lpszT));
		}
		LPTSTR Detach()
		{
			LPTSTR lp = p;
			p = NULL;
			nSize = nPos = 0;
			return lp;
		}

	};
};

#if defined(_ATL_DLL) || defined(_ATL_DLL_IMPL)
class ATL_NO_VTABLE CRegObject :
	public IRegistrar
#else
class CRegObject :
	public IRegistrarBase
#endif
{
public:

#if defined(_ATL_DLL) || defined(_ATL_DLL_IMPL)

#else
	STDMETHOD(QueryInterface)(
		_In_ const IID &,
		_In_opt_ void ** )
	{
		ATLASSERT(_T("statically linked in CRegObject is not a com object. Do not callthis function"));
		return E_NOTIMPL;
	}

	STDMETHOD_(ULONG, AddRef)(void)
	{
		ATLASSERT(_T("statically linked in CRegObject is not a com object. Do not callthis function"));
		return 1;
	}
	STDMETHOD_(ULONG, Release)(void)
	{
		ATLASSERT(_T("statically linked in CRegObject is not a com object. Do not callthis function"));
		return 0;
	}
#endif
	virtual ~CRegObject()
	{
		ClearReplacements();
	}
	HRESULT FinalConstruct()
	{
		return m_csMap.Init();
	}
	void FinalRelease() {}


	// Map based methods
	HRESULT STDMETHODCALLTYPE AddReplacement(
		_In_z_ LPCOLESTR lpszKey,
		_In_z_ LPCOLESTR lpszItem);
	HRESULT STDMETHODCALLTYPE ClearReplacements();
	LPCOLESTR StrFromMap(_In_z_ LPTSTR lpszKey);

	// Register via a given mechanism
	HRESULT STDMETHODCALLTYPE ResourceRegister(
		_In_z_ LPCOLESTR pszFileName,
		_In_ UINT nID,
		_In_z_ LPCOLESTR pszType);
	HRESULT STDMETHODCALLTYPE ResourceRegisterSz(
		_In_z_ LPCOLESTR pszFileName,
		_In_z_ LPCOLESTR pszID,
		_In_z_ LPCOLESTR pszType);
	HRESULT STDMETHODCALLTYPE ResourceUnregister(
		_In_z_ LPCOLESTR pszFileName,
		_In_ UINT nID,
		_In_z_ LPCOLESTR pszType);
	HRESULT STDMETHODCALLTYPE ResourceUnregisterSz(
		_In_z_ LPCOLESTR pszFileName,
		_In_z_ LPCOLESTR pszID,
		_In_z_ LPCOLESTR pszType);

	HRESULT STDMETHODCALLTYPE FileRegister(_In_z_ LPCOLESTR bstrFileName)
	{
		return CommonFileRegister(bstrFileName, TRUE);
	}

	HRESULT STDMETHODCALLTYPE FileUnregister(_In_z_ LPCOLESTR bstrFileName)
	{
		return CommonFileRegister(bstrFileName, FALSE);
	}

	HRESULT STDMETHODCALLTYPE StringRegister(_In_z_ LPCOLESTR bstrData)
	{
		return RegisterWithString(bstrData, TRUE);
	}

	HRESULT STDMETHODCALLTYPE StringUnregister(_In_z_ LPCOLESTR bstrData)
	{
		return RegisterWithString(bstrData, FALSE);
	}

protected:

	HRESULT CommonFileRegister(
		_In_z_ LPCOLESTR pszFileName,
		_In_ BOOL bRegister);
	HRESULT RegisterFromResource(
		_In_z_ LPCOLESTR pszFileName,
		_In_z_ LPCTSTR pszID,
		_In_z_ LPCTSTR pszType,
		_In_ BOOL bRegister);
	HRESULT RegisterWithString(
		_In_z_ LPCOLESTR pszData,
		_In_ BOOL bRegister);

	static HRESULT GenerateError(_In_ UINT)
	{
		return DISP_E_EXCEPTION;
	}

	CExpansionVector m_RepMap;
	CComObjectThreadModel::AutoDeleteCriticalSection m_csMap;
};

inline HRESULT STDMETHODCALLTYPE CRegObject::AddReplacement(
	_In_z_ LPCOLESTR lpszKey,
	_In_z_ LPCOLESTR lpszItem)
{
	if (lpszKey == NULL || lpszItem == NULL)
		return E_INVALIDARG;
	m_csMap.Lock();
	USES_CONVERSION_EX;

	LPCTSTR lpszT = OLE2CT_EX(lpszKey, _ATL_SAFE_ALLOCA_DEF_THRESHOLD);

#ifndef _UNICODE
	if(lpszT == NULL)
		return E_OUTOFMEMORY;
#endif

	BOOL bRet = m_RepMap.Add(lpszT, lpszItem);
	m_csMap.Unlock();
	return bRet ? S_OK : E_OUTOFMEMORY;
}

inline HRESULT CRegObject::RegisterFromResource(
	_In_z_ LPCOLESTR bstrFileName,
	_In_z_ LPCTSTR szID,
	_In_z_ LPCTSTR szType,
	_In_ BOOL bRegister)
{
	USES_CONVERSION_EX;

	HRESULT     hr;
	CRegParser  parser(this);
	HINSTANCE   hInstResDll;
	HRSRC       hrscReg;
	HGLOBAL     hReg;
	DWORD       dwSize;
	LPSTR       szRegA;
	CTempBuffer<TCHAR, 1024> szReg;

	LPCTSTR lpszBSTRFileName = OLE2CT_EX(bstrFileName, _ATL_SAFE_ALLOCA_DEF_THRESHOLD);
#ifndef _UNICODE
	if (lpszBSTRFileName == NULL)
	{
		return E_OUTOFMEMORY;
	}
#endif // _UNICODE

	hInstResDll = LoadLibraryEx(lpszBSTRFileName, NULL, LOAD_LIBRARY_AS_DATAFILE);

	if (NULL == hInstResDll)
	{
		ATLTRACE(atlTraceRegistrar, 0, _T("Failed to LoadLibrary on %s\n"), bstrFileName);
		hr = AtlHresultFromLastError();
		goto ReturnHR;
	}

	hrscReg =FindResource((HMODULE)hInstResDll, szID, szType);

	if (NULL == hrscReg)
	{
		ATLTRACE(atlTraceRegistrar, 0, (HIWORD(szID) == 0) ?
			_T("Failed to FindResource on ID:%d TYPE:%s\n") :
			_T("Failed to FindResource on ID:%s TYPE:%s\n"),
			szID, szType);
		hr = AtlHresultFromLastError();
		goto ReturnHR;
	}
	hReg = LoadResource((HMODULE)hInstResDll, hrscReg);

	if (NULL == hReg)
	{
		ATLTRACE(atlTraceRegistrar, 0, _T("Failed to LoadResource\n"));
		hr = AtlHresultFromLastError();
		goto ReturnHR;
	}

	dwSize = SizeofResource((HMODULE)hInstResDll, hrscReg);
	szRegA = (LPSTR)hReg;

	// Allocate extra space for NULL.
	if (dwSize + 1 < dwSize)
	{
		hr = E_OUTOFMEMORY;
		goto ReturnHR;
	}

	ATLTRY(szReg.Allocate(dwSize + 1));
	if (szReg == NULL)
	{
		hr = E_OUTOFMEMORY;
		goto ReturnHR;
	}

#ifdef _UNICODE
	DWORD uniSize = ::MultiByteToWideChar(_AtlGetConversionACP(), 0, szRegA, dwSize, szReg, dwSize);
	if (uniSize == 0)
	{
		hr = AtlHresultFromLastError();
		goto ReturnHR;
	}
	// Append a NULL at the end.
	szReg[uniSize] = _T('\0');
#else
	Checked::memcpy_s(szReg, dwSize, szRegA, dwSize);
	// Append a NULL at the end.
   	szReg[dwSize] = _T('\0');
#endif

	hr = parser.RegisterBuffer(szReg, bRegister);

ReturnHR:

	if (NULL != hInstResDll)
		FreeLibrary((HMODULE)hInstResDll);
	return hr;
}

inline HRESULT STDMETHODCALLTYPE CRegObject::ResourceRegister(
	_In_z_ LPCOLESTR szFileName,
	_In_ UINT nID,
	_In_z_ LPCOLESTR szType)
{
	USES_CONVERSION_EX;

	LPCTSTR lpszT = OLE2CT_EX(szType, _ATL_SAFE_ALLOCA_DEF_THRESHOLD);
#ifndef _UNICODE
	if (lpszT == NULL)
	{
		return E_OUTOFMEMORY;
	}
#endif // _UNICODE

	return RegisterFromResource(szFileName, MAKEINTRESOURCE(nID), lpszT, TRUE);
}

inline HRESULT STDMETHODCALLTYPE CRegObject::ResourceRegisterSz(
	_In_z_ LPCOLESTR szFileName,
	_In_z_ LPCOLESTR szID,
	_In_z_ LPCOLESTR szType)
{
	USES_CONVERSION_EX;
	if (szID == NULL || szType == NULL)
		return E_INVALIDARG;

	LPCTSTR lpszID = OLE2CT_EX(szID, _ATL_SAFE_ALLOCA_DEF_THRESHOLD);
	LPCTSTR lpszType = OLE2CT_EX(szType, _ATL_SAFE_ALLOCA_DEF_THRESHOLD);
#ifndef _UNICODE
	if (lpszID == NULL || lpszType==NULL)
	{
		return E_OUTOFMEMORY;
	}
#endif // _UNICODE
	return RegisterFromResource(szFileName, lpszID, lpszType, TRUE);
}

inline HRESULT STDMETHODCALLTYPE CRegObject::ResourceUnregister(
	_In_z_ LPCOLESTR szFileName,
	_In_ UINT nID,
	_In_z_ LPCOLESTR szType)
{
	USES_CONVERSION_EX;

	LPCTSTR lpszT = OLE2CT_EX(szType, _ATL_SAFE_ALLOCA_DEF_THRESHOLD);
#ifndef _UNICODE
	if (lpszT == NULL)
	{
		return E_OUTOFMEMORY;
	}
#endif // _UNICODE
	return RegisterFromResource(szFileName, MAKEINTRESOURCE(nID), lpszT, FALSE);
}

inline HRESULT STDMETHODCALLTYPE CRegObject::ResourceUnregisterSz(
	_In_z_ LPCOLESTR szFileName,
	_In_z_ LPCOLESTR szID,
	_In_z_ LPCOLESTR szType)
{
	USES_CONVERSION_EX;
	if (szID == NULL || szType == NULL)
		return E_INVALIDARG;

	LPCTSTR lpszID = OLE2CT_EX(szID, _ATL_SAFE_ALLOCA_DEF_THRESHOLD);
	LPCTSTR lpszType = OLE2CT_EX(szType, _ATL_SAFE_ALLOCA_DEF_THRESHOLD);
#ifndef _UNICODE
	if (lpszID == NULL || lpszType == NULL)
	{
		return E_OUTOFMEMORY;
	}
#endif // _UNICODE

	return RegisterFromResource(szFileName, lpszID, lpszType, FALSE);
}

inline HRESULT CRegObject::RegisterWithString(
	_In_z_ LPCOLESTR bstrData,
	_In_ BOOL bRegister)
{
	USES_CONVERSION_EX;
	CRegParser  parser(this);

	LPCTSTR szReg = OLE2CT_EX(bstrData, _ATL_SAFE_ALLOCA_DEF_THRESHOLD);
#ifndef _UNICODE
	if (szReg == NULL)
	{
		return E_OUTOFMEMORY;
	}
#endif // _UNICODE

	HRESULT hr = parser.RegisterBuffer((LPTSTR)szReg, bRegister);

	return hr;
}

inline HRESULT CRegObject::ClearReplacements()
{
	m_csMap.Lock();
	HRESULT hr = m_RepMap.ClearReplacements();
	m_csMap.Unlock();
	return hr;
}


inline LPCOLESTR CRegObject::StrFromMap(_In_z_ LPTSTR lpszKey)
{
	m_csMap.Lock();
	LPCOLESTR lpsz = m_RepMap.Lookup(lpszKey);
	if (lpsz == NULL) // not found!!
		ATLTRACE(atlTraceRegistrar, 0, _T("Map Entry not found\n"));
	m_csMap.Unlock();
	return lpsz;
}

inline HRESULT CRegObject::CommonFileRegister(
	_In_z_ LPCOLESTR bstrFileName,
	_In_ BOOL bRegister)
{
	USES_CONVERSION_EX;

	CRegParser  parser(this);

	LPCTSTR lpszBSTRFileName = OLE2CT_EX(bstrFileName, _ATL_SAFE_ALLOCA_DEF_THRESHOLD);
#ifndef _UNICODE
	if (lpszBSTRFileName == NULL)
	{
		return E_OUTOFMEMORY;
	}
#endif // _UNICODE

	HANDLE hFile = CreateFile(lpszBSTRFileName, GENERIC_READ, 0, NULL,
							  OPEN_EXISTING,
							  FILE_ATTRIBUTE_READONLY,
							  NULL);
	if (INVALID_HANDLE_VALUE == hFile)
	{
		ATLTRACE2(atlTraceRegistrar, 0, _T("Failed to CreateFile on %s\n"), lpszBSTRFileName);
		return AtlHresultFromLastError();
	}

	HRESULT hRes = S_OK;
	DWORD cbRead;
	DWORD cbFile = GetFileSize(hFile, NULL); // No HiOrder DWORD required

	CTempBuffer<char, 1024> szReg;
	// Extra space for NULL.
	ATLTRY(szReg.Allocate(cbFile + 1));
	if (szReg == NULL)
	{
		hRes = E_OUTOFMEMORY;
		goto ReturnHR;
	}

	if (ReadFile(hFile, szReg, cbFile, &cbRead, NULL) == 0)
	{
		ATLTRACE2(atlTraceRegistrar, 0, "Read Failed on file %s\n", lpszBSTRFileName);
		hRes =  AtlHresultFromLastError();
	}
	if (SUCCEEDED(hRes))
	{
		szReg[cbRead] = '\0';

#ifdef _UNICODE
		CTempBuffer<WCHAR, 1024> szConverted;
		ATLTRY(szConverted.Allocate(cbFile + 1));
		if (szConverted == NULL)
		{
			hRes =  E_OUTOFMEMORY;
			goto ReturnHR;

		}
		if (::MultiByteToWideChar(_AtlGetConversionACP(), 0, szReg, cbFile + 1, szConverted, cbFile + 1) == 0)
		{
			hRes = AtlHresultFromLastError();
			goto ReturnHR;
		}
#else
		LPTSTR szConverted = szReg;
#endif
		hRes = parser.RegisterBuffer(szConverted, bRegister);
	}
ReturnHR:
	CloseHandle(hFile);
	return hRes;
}

__declspec(selectany) const TCHAR* const CRegParser::rgszNeverDelete[] =
{
	_T("AppID"),
	_T("CLSID"),
	_T("Component Categories"),
	_T("FileType"),
	_T("Interface"),
	_T("Hardware"),
	_T("Mime"),
	_T("SAM"),
	_T("SECURITY"),
	_T("SYSTEM"),
	_T("Software"),
	_T("TypeLib")
};

__declspec(selectany) const int CRegParser::cbNeverDelete = sizeof(rgszNeverDelete) / sizeof(LPCTSTR*);


inline BOOL CRegParser::VTFromRegType(
	_In_z_ LPCTSTR szValueType,
	_Out_ VARTYPE& vt)
{
	struct typemap
	{
		LPCTSTR lpsz;
		VARTYPE vt;
	};
#pragma warning (push)
#pragma warning (disable : 4640)	// construction of local static object is not thread-safe

	static const typemap map[] = {
		{szStringVal, VT_BSTR},
		{multiszStringVal, VT_BSTR | VT_BYREF},
		{szDwordVal,  VT_UI4},
		{szBinaryVal, VT_UI1}
	};

#pragma warning (pop)

	for (int i=0;i<sizeof(map)/sizeof(typemap);i++)
	{
		if (!lstrcmpi(szValueType, map[i].lpsz))
		{
			vt = map[i].vt;
			return TRUE;
		}
	}

	return FALSE;
}

inline BYTE CRegParser::ChToByte(_In_ const TCHAR ch)
{
	switch (ch)
	{
		case '0':
		case '1':
		case '2':
		case '3':
		case '4':
		case '5':
		case '6':
		case '7':
		case '8':
		case '9':
				return (BYTE) (ch - '0');
		case 'A':
		case 'B':
		case 'C':
		case 'D':
		case 'E':
		case 'F':
				return (BYTE) (10 + (ch - 'A'));
		case 'a':
		case 'b':
		case 'c':
		case 'd':
		case 'e':
		case 'f':
				return (BYTE) (10 + (ch - 'a'));
		default:
				ATLASSERT(FALSE);
				ATLTRACE(atlTraceRegistrar, 0, _T("Bogus value %c passed as binary Hex value\n"), ch);
				return 0;
	}
}

inline HKEY CRegParser::HKeyFromString(_In_z_ LPTSTR szToken)
{
	struct keymap
	{
		LPCTSTR lpsz;
		HKEY hkey;
	};
	static const keymap map[] = {
		{_T("HKCR"), HKEY_CLASSES_ROOT},
		{_T("HKCU"), HKEY_CURRENT_USER},
		{_T("HKLM"), HKEY_LOCAL_MACHINE},
		{_T("HKU"),  HKEY_USERS},
		{_T("HKPD"), HKEY_PERFORMANCE_DATA},
		{_T("HKDD"), HKEY_DYN_DATA},
		{_T("HKCC"), HKEY_CURRENT_CONFIG},
		{_T("HKEY_CLASSES_ROOT"), HKEY_CLASSES_ROOT},
		{_T("HKEY_CURRENT_USER"), HKEY_CURRENT_USER},
		{_T("HKEY_LOCAL_MACHINE"), HKEY_LOCAL_MACHINE},
		{_T("HKEY_USERS"), HKEY_USERS},
		{_T("HKEY_PERFORMANCE_DATA"), HKEY_PERFORMANCE_DATA},
		{_T("HKEY_DYN_DATA"), HKEY_DYN_DATA},
		{_T("HKEY_CURRENT_CONFIG"), HKEY_CURRENT_CONFIG}
	};

	for (int i=0;i<sizeof(map)/sizeof(keymap);i++)
	{
		if (!lstrcmpi(szToken, map[i].lpsz))
			return map[i].hkey;
	}
	return NULL;
}

inline LPTSTR CRegParser::StrChr(
	_In_z_ LPTSTR lpsz,
	_In_ TCHAR ch)
{
	LPTSTR p = NULL;

	if (lpsz == NULL)
		return NULL;

	while (*lpsz)
	{
		if (*lpsz == ch)
		{
			p = lpsz;
			break;
		}
		lpsz = CharNext(lpsz);
	}
	return p;
}

inline CRegParser::CRegParser(_In_ CRegObject* pRegObj)
{
	m_pRegObj = pRegObj;
	m_pchCur = NULL;
}

inline BOOL CRegParser::IsSpace(_In_ TCHAR ch)
{
	switch (ch)
	{
		case _T(' '):
		case _T('\t'):
		case _T('\r'):
		case _T('\n'):
				return TRUE;
	}

	return FALSE;
}

inline void CRegParser::SkipWhiteSpace()
{
	while(IsSpace(*m_pchCur))
		m_pchCur = CharNext(m_pchCur);
}

#pragma warning(push)
#pragma warning(disable:6385) // suppressing code analysis warning on the GenerateError code path
inline HRESULT CRegParser::NextToken(_Out_z_cap_c_(MAX_VALUE) LPTSTR szToken)
{
	SkipWhiteSpace();

	// NextToken cannot be called at EOS
	if (_T('\0') == *m_pchCur)
		return GenerateError(E_ATL_UNEXPECTED_EOS);
#pragma warning(pop)

	LPCTSTR szOrig = szToken;
	// handle quoted value / key
	if (chQuote == *m_pchCur)
	{
		m_pchCur = CharNext(m_pchCur);

		while (_T('\0') != *m_pchCur && !EndOfVar())
		{
			if (chQuote == *m_pchCur) // If it is a quote that means we must skip it
				m_pchCur = CharNext(m_pchCur);

			LPTSTR pchPrev = m_pchCur;
			m_pchCur = CharNext(m_pchCur);

			INT_PTR nChars = m_pchCur - pchPrev;

			// Make sure we have room for nChars plus terminating NULL
			if ((szToken + nChars + 1) >= szOrig + MAX_VALUE)
				return GenerateError(E_ATL_VALUE_TOO_LARGE);

			for (int i = 0; i < (int)nChars; i++, szToken++, pchPrev++)
				*szToken = *pchPrev;
		}

		if (_T('\0') == *m_pchCur)
		{
			ATLTRACE(atlTraceRegistrar, 0, _T("NextToken : Unexpected End of File\n"));
			return GenerateError(E_ATL_UNEXPECTED_EOS);
		}

		*szToken = _T('\0');
		m_pchCur = CharNext(m_pchCur);
	}

	else
	{
		// Handle non-quoted ie parse up till first "White Space"
		while (_T('\0') != *m_pchCur && !IsSpace(*m_pchCur))
		{
			LPTSTR pchPrev = m_pchCur;
			m_pchCur = CharNext(m_pchCur);

			INT_PTR nChars = m_pchCur - pchPrev;

			// Make sure we have room for nChars plus terminating NULL
			if ((szToken + nChars + 1) >= szOrig + MAX_VALUE)
				return GenerateError(E_ATL_VALUE_TOO_LARGE);

			for (int i = 0; i < (int)nChars; i++, szToken++, pchPrev++)
				*szToken = *pchPrev;
		}

		*szToken = _T('\0');
	}
	return S_OK;
}

#pragma warning(push)
#pragma warning(disable:6385) // suppressing code analysis warning on the GenerateError code path
inline HRESULT CRegParser::AddValue(
	_Inout_ CRegKey& rkParent,
	_In_opt_z_ LPCTSTR szValueName,
	_Out_z_cap_c_(MAX_VALUE) LPTSTR szToken)
{
	HRESULT hr;

	TCHAR		szValue[MAX_VALUE];
	VARTYPE     vt = VT_EMPTY;
	LONG        lRes = ERROR_SUCCESS;
	UINT        nIDRes = 0;

	if (FAILED(hr = NextToken(szValue)))
		return hr;
	if (!VTFromRegType(szValue, vt))
	{
		ATLTRACE(atlTraceRegistrar, 0, _T("%s Type not supported\n"), szValue);
		return GenerateError(E_ATL_TYPE_NOT_SUPPORTED);
	}
#pragma warning(pop)

	SkipWhiteSpace();
	if (FAILED(hr = NextToken(szValue)))
		return hr;

	switch (vt)
	{
	case VT_BSTR:
		{
			lRes = rkParent.SetStringValue(szValueName, szValue);
			ATLTRACE(atlTraceRegistrar, 2, _T("Setting Value %s at %s\n"), szValue, !szValueName ? _T("default") : szValueName);
			break;
		}
	case VT_BSTR | VT_BYREF:
		{
			ATLTRACE(atlTraceRegistrar, 2, _T("Setting Value %s at %s\n"), szValue, !szValueName ? _T("default") : szValueName);
			int nLen = lstrlen(szValue) + 2; //Allocate space for double null termination.
			CTempBuffer<TCHAR, 256> pszDestValue;
			//nLen should be >= the max size of the target buffer.
			ATLTRY(pszDestValue.Allocate(nLen));
			if (pszDestValue != NULL)
			{
				TCHAR* p = pszDestValue;
				TCHAR* q = szValue;
				nLen = 0;
				while (*q != _T('\0'))
				{
					TCHAR* r = CharNext(q);
					if (*q == _T('\\') && *r == _T('0'))
					{
						*p++ = _T('\0');
						q = CharNext(r);
					}
					else
					{
						*p = *q;
#ifndef _UNICODE
						if (IsDBCSLeadByte(*q))
						{
							p++;
							q++;
							//Protect from Lead byte followed by the zero terminator.May skip beyond the end of the string.
							if (*q == _T('\0')) { break; }
							*p = *q;
						}
#endif
						p++;
						q++;
					}
					nLen ++;
				}
			   //Always terminate with 2 null characters.
				*p = _T('\0');
				p++;
			    *p = _T('\0');
				lRes = rkParent.SetMultiStringValue(szValueName, pszDestValue);
			}
			else
			{
				lRes = ERROR_OUTOFMEMORY;
			}
		}
		break;
	case VT_UI4:
		{
			ULONG ulVal;
			USES_CONVERSION_EX;

			LPOLESTR lpszV = T2OLE_EX(szValue, _ATL_SAFE_ALLOCA_DEF_THRESHOLD);
	#ifndef _UNICODE
			if(lpszV == NULL)
				return E_OUTOFMEMORY;
	#endif
			VarUI4FromStr(lpszV, 0, 0, &ulVal);

			lRes = rkParent.SetDWORDValue(szValueName, ulVal);
			ATLTRACE(atlTraceRegistrar, 2, _T("Setting Value %d at %s\n"), ulVal, !szValueName ? _T("default") : szValueName);
			break;
		}
	case VT_UI1:
		{
			int cbValue = lstrlen(szValue);
			if (cbValue & 0x00000001)
			{
				ATLTRACE(atlTraceRegistrar, 0, _T("Binary Data does not fall on BYTE boundries\n"));
				return E_FAIL;
			}
			int cbValDiv2 = cbValue/2;
			CTempBuffer<BYTE, 256> rgBinary;
			ATLTRY(rgBinary.Allocate(cbValDiv2));
			if (rgBinary == NULL)
				return E_FAIL;
			memset(rgBinary, 0, cbValDiv2);
			for (int irg = 0; irg < cbValue; irg++)
				rgBinary[(irg/2)] |= (ChToByte(szValue[irg])) << (4*(1 - (irg & 0x00000001)));
			lRes = RegSetValueEx(rkParent, szValueName, 0, REG_BINARY, rgBinary, cbValDiv2);
			break;
		}
	}

	if (ERROR_SUCCESS != lRes)
	{
		nIDRes = E_ATL_VALUE_SET_FAILED;
		return AtlHresultFromWin32(lRes);
	}

	if (FAILED(hr = NextToken(szToken)))
		return hr;

	return S_OK;
}

inline BOOL CRegParser::CanForceRemoveKey(_In_z_ LPCTSTR szKey)
{
	for (int iNoDel = 0; iNoDel < cbNeverDelete; iNoDel++)
		if (!lstrcmpi(szKey, rgszNeverDelete[iNoDel]))
			 return FALSE;                       // We cannot delete it

	return TRUE;
}

inline BOOL CRegParser::HasSubKeys(_In_ HKEY hkey)
{
	DWORD cSubKeys = 0;

	if (RegQueryInfoKeyW(hkey, NULL, NULL, NULL,
							   &cSubKeys, NULL, NULL,
							   NULL, NULL, NULL, NULL, NULL) != ERROR_SUCCESS)
	{
		ATLTRACE(atlTraceRegistrar, 0, _T("Should not be here!!\n"));
		ATLASSERT(FALSE);
		return FALSE;
	}

	return cSubKeys > 0;
}

inline BOOL CRegParser::HasValues(_In_ HKEY hkey)
{
	DWORD cValues = 0;
	DWORD cMaxValueNameLen;

	LONG lResult = RegQueryInfoKeyW(hkey, NULL, NULL, NULL,
								  NULL, NULL, NULL,
								  &cValues, &cMaxValueNameLen, NULL, NULL, NULL);
	if (ERROR_SUCCESS != lResult)
	{
		ATLTRACE(atlTraceRegistrar, 0, _T("RegQueryInfoKey Failed "));
		ATLASSERT(FALSE);
		return FALSE;
	}

	if ((1 == cValues) && (0 == cMaxValueNameLen))
	{
		return FALSE;
	}

	return cValues > 0; // More than 1 means we have a non-default value
}

inline HRESULT CRegParser::SkipAssignment(_Inout_z_cap_c_(MAX_VALUE) LPTSTR szToken)
{
	HRESULT hr;
	TCHAR szValue[MAX_VALUE];

	if (*szToken == chEquals)
	{
		if (FAILED(hr = NextToken(szToken)))
			return hr;
		// Skip assignment
		SkipWhiteSpace();
		if (FAILED(hr = NextToken(szValue)))
			return hr;
		if (FAILED(hr = NextToken(szToken)))
			return hr;
	}

	return S_OK;
}

ATLPREFAST_SUPPRESS(6387)
inline HRESULT CRegParser::PreProcessBuffer(
	_In_z_ LPTSTR lpszReg,
	_Deref_out_z_ LPTSTR* ppszReg)
{
	ATLASSERT(lpszReg != NULL);
	ATLASSERT(ppszReg != NULL);

	if (lpszReg == NULL || ppszReg == NULL)
		return E_POINTER;

	*ppszReg = NULL;
	int nSize = lstrlen(lpszReg)*2;
	CParseBuffer pb(nSize);
	if (pb.p == NULL)
		return E_OUTOFMEMORY;
	m_pchCur = lpszReg;
	HRESULT hr = S_OK;

	bool bRedirectionEnabled = false;
	hr = AtlGetPerUserRegistration(&bRedirectionEnabled);
	if( FAILED(hr) )
	{
		return hr;
	}

	// nNestingLevel is used to avoid checking for unnecessary root key replacements
	// since all of them are expected to be at the top level.
	int nNestingLevel = 0;
	bool bRedirectionPresent = false;
	bool bInsideQuotes = false;

	while (*m_pchCur != _T('\0')) // look for end
	{
		if ( true == bRedirectionEnabled )
		{
			LPCOLESTR szStartHKCU = L"HKCU\r\n{\tSoftware\r\n\t{\r\n\t\tClasses";
			LPCOLESTR szEndHKCU = L"\r\n\t}\r\n}\r\n";

			if ( 0 == nNestingLevel )
			{
				// Then we should be reading a root key. HKCR, HKCU, etc
				TCHAR* szRootKey = NULL;
				if( NULL != ( szRootKey = _tcsstr(m_pchCur, _T("HKCR")) ) &&	// if HKCR is found.
					(szRootKey == m_pchCur) )	// if HKCR is the first token.
				{
					// Skip HKCR
					m_pchCur = CharNext(m_pchCur);
					m_pchCur = CharNext(m_pchCur);
					m_pchCur = CharNext(m_pchCur);
					m_pchCur = CharNext(m_pchCur);

					// Add HKCU
					if (!pb.AddString(szStartHKCU))
					{
						hr = E_OUTOFMEMORY;
						break;
					}

					bRedirectionPresent = true;
				}
			}

			if ( chQuote == *m_pchCur )
			{
				if( false == bInsideQuotes )
				{
					bInsideQuotes = true;
				}
				else
				{
					// Make sure it is not an escaped sequence.
					if( EndOfVar() )
					{
						bInsideQuotes = false;
					}
					else
					{
						// An escaped single quote...
						m_pchCur = CharNext(m_pchCur);
						if (!pb.AddChar(m_pchCur))
						{
							hr = E_OUTOFMEMORY;
							break;
						}
					}
				}
			}

			if ( (false == bInsideQuotes) && (*m_pchCur == _T('{')) )
			{
				++nNestingLevel;
			}

			if ( (false == bInsideQuotes) && (*m_pchCur == _T('}')) )
			{
				--nNestingLevel;
				if ( (0 == nNestingLevel) && (true == bRedirectionPresent) )
				{
					if (!pb.AddString(szEndHKCU))
					{
						hr = E_OUTOFMEMORY;
						break;
					}

					bRedirectionPresent = false;
				}
			}
		}

		if (*m_pchCur == _T('%'))
		{
			m_pchCur = CharNext(m_pchCur);
			if (*m_pchCur == _T('%'))
			{
				if (!pb.AddChar(m_pchCur))
				{
					hr = E_OUTOFMEMORY;
					break;
				}
			}
			else
			{
				LPTSTR lpszNext = StrChr(m_pchCur, _T('%'));
				if (lpszNext == NULL)
				{
					ATLTRACE(atlTraceRegistrar, 0, _T("Error no closing %% found\n"));
					hr = GenerateError(E_ATL_UNEXPECTED_EOS);
					break;
				}
				if ((lpszNext-m_pchCur) > 31)
				{
					hr = E_FAIL;
					break;
				}
				int nLength = int(lpszNext - m_pchCur);
				TCHAR buf[32];
				Checked::tcsncpy_s(buf, _countof(buf), m_pchCur, nLength);
				LPCOLESTR lpszVar = m_pRegObj->StrFromMap(buf);
				if (lpszVar == NULL)
				{
					hr = GenerateError(E_ATL_NOT_IN_MAP);
					break;
				}
				if (!pb.AddString(lpszVar))
				{
					hr = E_OUTOFMEMORY;
					break;
				}

				while (m_pchCur != lpszNext)
					m_pchCur = CharNext(m_pchCur);
			}
		}
		else
		{
			if (!pb.AddChar(m_pchCur))
			{
				hr = E_OUTOFMEMORY;
				break;
			}
		}

		m_pchCur = CharNext(m_pchCur);
	}
	if (SUCCEEDED(hr))
		*ppszReg = pb.Detach();
	return hr;
}
ATLPREFAST_UNSUPPRESS()

inline HRESULT CRegParser::RegisterBuffer(
	_In_z_ LPTSTR szBuffer,
	_In_ BOOL bRegister)
{
	TCHAR   szToken[MAX_VALUE];
	HRESULT hr = S_OK;

	LPTSTR szReg = NULL;
	hr = PreProcessBuffer(szBuffer, &szReg);
	if (FAILED(hr))
		return hr;

	ATLTRACE(atlTraceRegistrar, 0, _T("%s\n"), szReg);

	m_pchCur = szReg;

	// Preprocess szReg

	while (_T('\0') != *m_pchCur)
	{
		if (FAILED(hr = NextToken(szToken)))
			break;
		HKEY hkBase;
		if ((hkBase = HKeyFromString(szToken)) == NULL)
		{
			ATLTRACE(atlTraceRegistrar, 0, _T("HKeyFromString failed on %s\n"), szToken);
			hr = GenerateError(E_ATL_BAD_HKEY);
			break;
		}

		if (FAILED(hr = NextToken(szToken)))
			break;

		if (chLeftBracket != *szToken)
		{
			ATLTRACE(atlTraceRegistrar, 0, _T("Syntax error, expecting a {, found a %s\n"), szToken);
			hr = GenerateError(E_ATL_MISSING_OPENKEY_TOKEN);
			break;
		}
		if (bRegister)
		{
			LPTSTR szRegAtRegister = m_pchCur;
			hr = RegisterSubkeys(szToken, hkBase, bRegister);
			if (FAILED(hr))
			{
				ATLTRACE(atlTraceRegistrar, 0, _T("Failed to register, cleaning up!\n"));
				m_pchCur = szRegAtRegister;
				RegisterSubkeys(szToken, hkBase, FALSE);
				break;
			}
		}
		else
		{
			if (FAILED(hr = RegisterSubkeys(szToken, hkBase, bRegister)))
				break;
		}

		SkipWhiteSpace();
	}
	CoTaskMemFree(szReg);
	return hr;
}

inline HRESULT CRegParser::RegisterSubkeys(
	_Out_z_cap_c_(MAX_VALUE) LPTSTR szToken,
	_In_ HKEY hkParent,
	_In_ BOOL bRegister,
	_In_ BOOL bRecover)
{
	CRegKey keyCur;
	LONG    lRes;
	TCHAR  szKey[_MAX_PATH];
	BOOL    bDelete = TRUE;
	BOOL    bInRecovery = bRecover;
	HRESULT hr = S_OK;

	ATLTRACE(atlTraceRegistrar, 2, _T("Num Els = %d\n"), cbNeverDelete);
	if (FAILED(hr = NextToken(szToken)))
		return hr;

	while (*szToken != chRightBracket) // Continue till we see a }
	{
		bDelete = TRUE;
		BOOL bTokenDelete = !lstrcmpi(szToken, szDelete);

		if (!lstrcmpi(szToken, szForceRemove) || bTokenDelete)
		{
			if (FAILED(hr = NextToken(szToken)))
				break;

			if (bRegister)
			{
				CRegKey rkForceRemove;

				if (StrChr(szToken, chDirSep) != NULL)
					return GenerateError(E_ATL_COMPOUND_KEY);

				if (CanForceRemoveKey(szToken))
				{
					rkForceRemove.Attach(hkParent);
					// Error not returned. We will overwrite the values any way.
					rkForceRemove.RecurseDeleteKey(szToken);
					rkForceRemove.Detach();
				}
				if (bTokenDelete)
				{
					if (FAILED(hr = NextToken(szToken)))
						break;
					if (FAILED(hr = SkipAssignment(szToken)))
						break;
					goto EndCheck;
				}
			}
		}

		if (!lstrcmpi(szToken, szNoRemove))
		{
			bDelete = FALSE;    // set even for register
			if (FAILED(hr = NextToken(szToken)))
				break;
		}

		if (!lstrcmpi(szToken, szValToken)) // need to add a value to hkParent
		{
			TCHAR  szValueName[MAX_VALUE];

			if (FAILED(hr = NextToken(szValueName)))
				break;
			if (FAILED(hr = NextToken(szToken)))
				break;

			if (*szToken != chEquals)
				return GenerateError(E_ATL_EXPECTING_EQUAL);

			if (bRegister)
			{
				CRegKey rk;

				rk.Attach(hkParent);
				hr = AddValue(rk, szValueName, szToken);
				rk.Detach();

				if (FAILED(hr))
					return hr;

				goto EndCheck;
			}
			else
			{
				if (!bRecover && bDelete)
				{
					ATLTRACE(atlTraceRegistrar, 1, _T("Deleting %s\n"), szValueName);
					// We have to open the key for write to be able to delete.
					CRegKey rkParent;
					lRes = rkParent.Open(hkParent, NULL, KEY_WRITE);
					if (lRes == ERROR_SUCCESS)
					{
						lRes = rkParent.DeleteValue(szValueName);
						if (lRes != ERROR_SUCCESS && lRes != ERROR_FILE_NOT_FOUND)
						{
							// Key not present is not an error
							hr = AtlHresultFromWin32(lRes);
							break;
						}
					}
					else
					{
						hr = AtlHresultFromWin32(lRes);
						break;
					}
				}
				if (FAILED(hr = SkipAssignment(szToken)))
					break;
				continue;  // can never have a subkey
			}
		}

		if (StrChr(szToken, chDirSep) != NULL)
			return GenerateError(E_ATL_COMPOUND_KEY);

		if (bRegister)
		{
			lRes = keyCur.Open(hkParent, szToken, KEY_READ | KEY_WRITE);
			if (ERROR_SUCCESS != lRes)
			{
				// Failed all access try read only
				lRes = keyCur.Open(hkParent, szToken, KEY_READ);
				if (ERROR_SUCCESS != lRes)
				{
					// Finally try creating it
					ATLTRACE(atlTraceRegistrar, 2, _T("Creating key %s\n"), szToken);
					lRes = keyCur.Create(hkParent, szToken, REG_NONE, REG_OPTION_NON_VOLATILE, KEY_READ | KEY_WRITE);
					if (lRes != ERROR_SUCCESS)
						return AtlHresultFromWin32(lRes);
				}
			}

			if (FAILED(hr = NextToken(szToken)))
				break;


			if (*szToken == chEquals)
			{
				if (FAILED(hr = AddValue(keyCur, NULL, szToken))) // NULL == default
					break;
			}
		}
		else //Unregister
		{
			if (!bRecover)
			{
 				lRes = keyCur.Open(hkParent, szToken, KEY_READ);

			}
			else
				lRes = ERROR_FILE_NOT_FOUND;


			// Open failed set recovery mode
			if (lRes != ERROR_SUCCESS)
				bRecover = true;

			// TRACE out Key open status and if in recovery mode
#ifdef _DEBUG
			if (!bRecover)
				ATLTRACE(atlTraceRegistrar, 1, _T("Opened Key %s\n"), szToken);
			else
				ATLTRACE(atlTraceRegistrar, 0, _T("Ignoring Open key on %s : In Recovery mode\n"), szToken);
#endif //_DEBUG

			// Remember Subkey
			Checked::tcsncpy_s(szKey, _countof(szKey), szToken, _TRUNCATE);

			if (FAILED(hr = NextToken(szToken)))
				break;
			if (FAILED(hr = SkipAssignment(szToken)))
				break;

			if (*szToken == chLeftBracket && lstrlen(szToken) == 1)
			{
				hr = RegisterSubkeys(szToken, keyCur.m_hKey, bRegister, bRecover);
				// In recover mode ignore error
				if (FAILED(hr) && !bRecover)
					break;
				// Skip the }
				if (FAILED(hr = NextToken(szToken)))
					break;
			}

#ifdef _DEBUG
			if (bRecover != bInRecovery)
				ATLTRACE(atlTraceRegistrar, 0, _T("Ending Recovery Mode\n"));
#endif
			bRecover = bInRecovery;

			if (lRes == ERROR_FILE_NOT_FOUND)
				// Key already not present so not an error.
				continue;

			if (lRes != ERROR_SUCCESS)
			{
				// We are recovery mode continue on errors else break
				if (bRecover)
					continue;
				else
				{
					hr = AtlHresultFromWin32(lRes);
					break;
				}
			}

			// If in recovery mode
			if (bRecover && HasSubKeys(keyCur))
			{
				// See if the KEY is in the NeverDelete list and if so, don't
				if (CanForceRemoveKey(szKey) && bDelete)
				{
					ATLTRACE(atlTraceRegistrar, 0, _T("Deleting non-empty subkey %s by force\n"), szKey);
					// Error not returned since we are in recovery mode. The error that caused recovery mode is returned
					keyCur.RecurseDeleteKey(szKey);
				}
				continue;
			}

			BOOL bHasSubKeys=HasSubKeys(keyCur);
			lRes = keyCur.Close();
			if (lRes != ERROR_SUCCESS)
			return AtlHresultFromWin32(lRes);

			if (bDelete&& !bHasSubKeys)
			{
				ATLTRACE(atlTraceRegistrar, 0, _T("Deleting Key %s\n"), szKey);
				CRegKey rkParent;
				rkParent.Attach(hkParent);
				lRes = rkParent.DeleteSubKey(szKey);
				rkParent.Detach();
				if (lRes != ERROR_SUCCESS)
				{

					hr = AtlHresultFromWin32(lRes);
					break;
				}
			}
		}

EndCheck:

		if (bRegister)
		{
			if (*szToken == chLeftBracket && lstrlen(szToken) == 1)
			{
				if (FAILED(hr = RegisterSubkeys(szToken, keyCur.m_hKey, bRegister, FALSE)))
					break;
				if (FAILED(hr = NextToken(szToken)))
					break;
			}
		}
	}

	return hr;
}

}; //namespace ATL

#pragma pack(pop)
#pragma warning(pop)

#endif //__STATREG_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\src\atl\regobj.cpp ===
// This is a part of the Active Template Library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Active Template Library Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the	
// Active Template Library product.

// RegObj.cpp

#include "stdafx.h"
#include "resource.h"
#include "RegObj.h"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\src\atl\stdafx.h ===
// This is a part of the Active Template Library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Active Template Library Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the	
// Active Template Library product.

#pragma warning(push)
#pragma warning(disable: 4005)		// disable macro redefinition warning for _WIN32_WINNT

#define _WIN32_WINNT 0x0502

#pragma warning(pop)

#define _ATL_FREE_THREADED
#define _ATL_DLL_IMPL

#include <atlbase.h>

extern CComModule _Module;

#ifdef _DEBUG
#include <atlbase.inl>
#endif

#include <atlcom.h>
#include <statreg.h>
#include <atlwin.h>
#include <atlctl.h>
#include <atlconv.h>
#include <atlhost.h>
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\src\atl\stdafx.cpp ===
// This is a part of the Active Template Library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Active Template Library Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the	
// Active Template Library product.

#include "stdafx.h"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\src\atl\resource.h ===
// This is a part of the Active Template Library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Active Template Library Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Active Template Library product.

//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by atl.rc
//
#define IDS_REGISTRAR_DESC              1
#define IDS_NOT_IN_MAP                  2
#define IDS_UNEXPECTED_EOS              3
#define IDS_VALUE_SET_FAILED            4
#define IDS_RECURSE_DELETE_FAILED       5
#define IDS_EXPECTING_EQUAL             6
#define IDS_CREATE_KEY_FAILED           7
#define IDS_DELETE_KEY_FAILED           8
#define IDS_OPEN_KEY_FAILED             9
#define IDS_CLOSE_KEY_FAILED            10
#define IDS_UNABLE_TO_COERCE            11
#define IDS_BAD_HKEY                    12
#define IDS_MISSING_OPENKEY_TOKEN       13
#define IDS_CONVERT_FAILED              14
#define IDS_TYPE_NOT_SUPPORTED          15
#define IDS_COULD_NOT_CONCAT            16
#define IDS_COMPOUND_KEY                17
#define IDS_INVALID_MAPKEY              18
#define IDS_UNSUPPORTED_VT              19
#define IDS_VALUE_GET_FAILED            20
#define IDS_VALUE_TOO_LARGE             21
#define IDS_MISSING_VALUE_DELIMETER     22
#define IDS_DATA_NOT_BYTE_ALIGNED       23
#define IDS_PROJNAME                    100
#define IDR_Registrar                   101
#define IDS_STRING101                   101

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        1029
#define _APS_NEXT_COMMAND_VALUE         32768
#define _APS_NEXT_CONTROL_VALUE         201
#define _APS_NEXT_SYMED_VALUE           102
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\src\atl\regobj.h ===
// This is a part of the Active Template Library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Active Template Library Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Active Template Library product.

// RegObj.h : Declaration of the CRegObject

/////////////////////////////////////////////////////////////////////////////
// register

class ATL_NO_VTABLE CDLLRegObject :
	public CRegObject,
	public CComObjectRoot,
	public CComCoClass<CDLLRegObject, &CLSID_Registrar>
{
public:
	CDLLRegObject()
	{
	}
	~CDLLRegObject()
	{
		CRegObject::ClearReplacements();
	}

BEGIN_COM_MAP(CDLLRegObject)
	COM_INTERFACE_ENTRY(IRegistrar)
END_COM_MAP()

DECLARE_NOT_AGGREGATABLE(CDLLRegObject)
	HRESULT FinalConstruct()
	{
		HRESULT hr = CComObjectRoot::FinalConstruct();
		if (SUCCEEDED(hr))
		{
			hr = CRegObject::FinalConstruct();
		}
		return hr;
	}
	void FinalRelease()
	{
		CComObjectRoot::FinalRelease();
	}
//we can't use the component because that's what we're registering
//we don't want to do the static registry because we'd have extra code
#pragma warning( push )
#pragma warning( disable: 4996 )  // disable "deprecated symbol" warning
	static HRESULT WINAPI UpdateRegistry(_In_ BOOL bRegister)
	{
		CComObject<CDLLRegObject>* p;
		CComObject<CDLLRegObject>::CreateInstance(&p);
		CComPtr<IRegistrar> pR;
		HRESULT hr = p->QueryInterface(IID_IRegistrar, (void**)&pR);
		if (FAILED(hr))
		{
			delete p;
			return hr;
		}
		return AtlModuleUpdateRegistryFromResourceD(&_Module,
			(LPCOLESTR)MAKEINTRESOURCE(IDR_Registrar), bRegister, NULL, pR);
	}
#pragma warning( pop )
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\src\atl\atl.cpp ===
// This is a part of the Active Template Library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Active Template Library Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Active Template Library product.

// atl.cpp : Implementation of DLL Exports.

#include "stdafx.h"
#include "resource.h"
#include "RegObj.h"
#include <io.h>

#define _ATL_DLL_FILENAME_UPPERCASE_T _T("ATL") _T(_ATL_FILENAME_VER) _T(".DLL")

CComModule _Module;

BEGIN_OBJECT_MAP(ObjectMap)
	OBJECT_ENTRY(CLSID_Registrar, CDLLRegObject)
	OBJECT_ENTRY_NON_CREATEABLE(CAxHostWindow)
END_OBJECT_MAP()

/////////////////////////////////////////////////////////////////////////////
// DLL Entry Point

extern "C"
BOOL WINAPI DllMain(
	_In_ HINSTANCE hInstance,
	_In_ DWORD dwReason,
	__reserved LPVOID /*lpReserved*/)
{
	if (dwReason == DLL_PROCESS_ATTACH)
	{
		bAtlAxWinInitialized = false;
#ifndef _UNICODE
		OutputDebugString(_T("Slight Performance loss due to running ANSI version of ") _ATL_DLL_FILENAME_UPPERCASE_T _T(" on Windows NT, Windows 2000, Windows XP or Windows Server 2003 \nPlease install the Unicode version.\n"));
#endif
#ifdef _DEBUG
		_CrtSetDbgFlag(_CRTDBG_ALLOC_MEM_DF);
		int n = 0;
		_CrtSetBreakAlloc(n);
#endif
		_Module.Init(ObjectMap, hInstance, &LIBID_ATLLib);
#ifdef _ATL_DEBUG_INTERFACES
		int ni = 0;
		_Module.m_nIndexBreakAt = ni;
#endif // _ATL_DEBUG_INTERFACES

		DisableThreadLibraryCalls(hInstance);
	}
	else if (dwReason == DLL_PROCESS_DETACH)
	{
#ifdef _DEBUG
		::OutputDebugString(_ATL_DLL_FILENAME_UPPERCASE_T _T(" exiting.\n"));
#endif
		_Module.Term();
		if (bAtlAxWinInitialized)
			AtlAxWinTerm();
#ifdef _DEBUG
		if (_CrtDumpMemoryLeaks())
			::MessageBeep(MB_ICONEXCLAMATION);
#endif
	}
	return TRUE;    // ok
}

namespace ATL
{
STDAPI AtlCreateRegistrar(_Deref_out_ IRegistrar** ppReg)
{
	if (ppReg == NULL)
		return E_POINTER;
	*ppReg = NULL;

	return CDLLRegObject::_CreatorClass::CreateInstance(NULL, IID_IRegistrar, (void**)ppReg);
}

STDAPI AtlUpdateRegistryFromResourceD(
	_In_ HINSTANCE hInst,
	_In_z_ LPCOLESTR lpszRes,
	_In_ BOOL bRegister,
	_In_opt_ struct _ATL_REGMAP_ENTRY* pMapEntries,
	_In_opt_ IRegistrar* pReg)
{
	ATLASSERT(hInst != NULL);
	if (hInst == NULL)
		return E_INVALIDARG;

	HRESULT hRes = S_OK;
	CComPtr<IRegistrar> p;

	if (pReg != NULL)
		p = pReg;
	else
	{
		hRes = AtlCreateRegistrar(&p);
	}
	if (NULL != pMapEntries)
	{
		while (NULL != pMapEntries->szKey)
		{
			ATLASSERT(NULL != pMapEntries->szData);
			p->AddReplacement(pMapEntries->szKey, pMapEntries->szData);
			pMapEntries++;
		}
	}
	if (SUCCEEDED(hRes))
	{
		TCHAR szModule[_MAX_PATH];
		int nRet = GetModuleFileName(hInst, szModule, _MAX_PATH);
		if(nRet == _MAX_PATH)
			return AtlHresultFromWin32(ERROR_BUFFER_OVERFLOW);

		if(nRet == 0)
			return AtlHresultFromLastError();

		USES_CONVERSION_EX;
		LPOLESTR pszModule = T2OLE_EX(szModule, _ATL_SAFE_ALLOCA_DEF_THRESHOLD);
#ifndef _UNICODE
		if(pszModule == NULL)
			return E_OUTOFMEMORY;
#endif

		// Buffer Size is Multiplied by 2 because we are calling ReplaceSingleQuote
		OLECHAR pszModuleUnquoted[_MAX_PATH * 2];
		CAtlModule::EscapeSingleQuote(pszModuleUnquoted, _countof(pszModuleUnquoted), pszModule);
		if (hInst == GetModuleHandle(NULL)) // register as EXE
		{
			// If Registering as an EXE, then we quote the resultant path.
			// We don't do it for a DLL, because LoadLibrary fails if the path is
			// quoted
			OLECHAR pszModuleQuote[(_MAX_PATH + _ATL_QUOTES_SPACE)*2];
			pszModuleQuote[0] = OLESTR('\"');
			if(!ocscpy_s(pszModuleQuote + 1, ((_MAX_PATH + _ATL_QUOTES_SPACE)*2)-1, pszModuleUnquoted))
			{
				return E_FAIL;
			}
			size_t nLen = ocslen(pszModuleQuote);
			pszModuleQuote[nLen] = OLESTR('\"');
			pszModuleQuote[nLen + 1] = 0;

			hRes = p->AddReplacement(OLESTR("Module"), pszModuleQuote);
		}
		else
		{
			hRes = p->AddReplacement(OLESTR("Module"), pszModuleUnquoted);
		}

		if(FAILED(hRes))
			return hRes;

		hRes = p->AddReplacement(OLESTR("Module_Raw"), pszModuleUnquoted);
		if(FAILED(hRes))
			return hRes;

		LPCOLESTR szType = OLESTR("REGISTRY");
		if (IS_INTRESOURCE(lpszRes))
		{
			if (bRegister)
				hRes = p->ResourceRegister(pszModule, ((UINT)LOWORD((DWORD_PTR)lpszRes)), szType);
			else
				hRes = p->ResourceUnregister(pszModule, ((UINT)LOWORD((DWORD_PTR)lpszRes)), szType);
		}
		else
		{
			if (bRegister)
				hRes = p->ResourceRegisterSz(pszModule, lpszRes, szType);
			else
				hRes = p->ResourceUnregisterSz(pszModule, lpszRes, szType);
		}

	}
	return hRes;
}

// Cannot pull these in from the static lib. The functions they reference are decorated
// with C++ calling convention. The functions are exported from the DLL with the
// C calling convention
#ifdef _DEBUG
CAtlComModule _AtlComModule;
#endif

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\src\atl\atls\allocate.h ===
// This is a part of the Active Template Library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Active Template Library Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Active Template Library product.

#ifndef ATLDEBUG_SHAREDMEORY_ALLOCATOR_HEADER
#define ATLDEBUG_SHAREDMEORY_ALLOCATOR_HEADER

class CAtlTraceProcess;
class CAtlTraceModule;
class CAtlTraceCategory;

class CTraceSnapshot
{
public:
	struct CModuleInfo
	{
		DWORD_PTR m_dwModule;
		int m_nCategories;
		int m_iFirstCategory;
	};

public:
	CSimpleArray< CModuleInfo > m_aModules;
	CSimpleArray< DWORD_PTR > m_adwCategories;
};

class CAtlAllocator
{
public:
	CAtlAllocator() :
		m_dwPageSize(0),
		m_hMap(NULL),
		m_bValid(false),
		m_pProcess(NULL),
		m_bSnapshot(false)
	{
	}

	~CAtlAllocator()
	{
		Close();
	}

	bool Init(
		_In_z_ const CHAR *pszFileMappingName,
		_In_ DWORD dwMaxSize);
	bool Open(_In_z_ const CHAR *pszFileMappingName);
	void Close(_In_ bool bForceUnmap = false);
	bool IsValid() const
	{
		return m_bValid;
	}

	CAtlTraceProcess *GetProcess() const
	{
		return m_pProcess;
	}
	CAtlTraceModule *GetModule(_In_ int iModule) const;
//	CAtlTraceCategory *GetCategory(int iModule, unsigned nCategory) const;
	CAtlTraceCategory* GetCategory(_In_ int iCategory) const;

	/*
	bool Lock(DWORD dwTimeOut);
	void Unlock();
	*/

	bool LoadSettings(_In_z_ const CHAR *pszFileName);
	bool LoadSettings(_In_z_ const WCHAR *pszFileName);
	bool SaveSettings(_In_z_ const CHAR *pszFileName);
	bool SaveSettings(_In_z_ const WCHAR *pszFileName);

	int GetModuleCount() const;
	int GetCategoryCount(_In_ int iModule) const;
	int GetCategoryCount(_In_ const CAtlTraceModule& Module) const;

	bool FindModule(
		_In_z_ const WCHAR *pszModuleName,
		_Out_ unsigned *pnModule) const;

	int AddModule(_In_ HINSTANCE hInst);
	int AddCategory(
		_In_ int iModule,
		_In_z_ const WCHAR *szCategoryName);

	bool RemoveModule(_In_ int iModule);

	void CleanUp();

	void TakeSnapshot();
	void ReleaseSnapshot();

	CTraceSnapshot m_snapshot;
	bool m_bSnapshot;

private:
	CAtlTraceProcess *m_pProcess;
	DWORD m_dwPageSize;
	HANDLE m_hMap;
	bool m_bValid;
	BYTE *m_pBufferStart;
};

#endif // ATLDEBUG_SHAREDMEORY_ALLOCATOR_HEADER
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\src\atl\atls\atlbase.cpp ===
// This is a part of the Active Template Library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Active Template Library Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Active Template Library product.

#include "StdAfx.H"

#pragma warning( disable: 4073 )  // initializers put in library initialization area

#ifndef _delayimp_h
extern "C" IMAGE_DOS_HEADER __ImageBase;
#endif

namespace ATL
{

// {B62F5910-6528-11d1-9611-0000F81E0D0D}
extern "C" const GUID GUID_ATLVer30 = { 0xb62f5910, 0x6528, 0x11d1, { 0x96, 0x11, 0x0, 0x0, 0xf8, 0x1e, 0xd, 0xd } };

// {394C3DE0-3C6F-11d2-817B-00C04F797AB7}
extern "C" const GUID GUID_ATLVer70 = { 0x394c3de0, 0x3c6f, 0x11d2, { 0x81, 0x7b, 0x0, 0xc0, 0x4f, 0x79, 0x7a, 0xb7 } };

// ATLVer GUID for ATL10.0
// {5DC0A9CA-92A2-4204-9003-E4CE5F11E1A8}
extern "C" const GUID GUID_ATLVer100 = { 0x5dc0a9ca, 0x92a2, 0x4204, { 0x90, 0x3, 0xe4, 0xce, 0x5f, 0x11, 0xe1, 0xa8 } };


CAtlBaseModule::CAtlBaseModule() throw()
{
	cbSize = sizeof(_ATL_BASE_MODULE);

	m_hInst = m_hInstResource = reinterpret_cast<HINSTANCE>(&__ImageBase);

	dwAtlBuildVer = _ATL_VER;
	pguidVer = &GUID_ATLVer100;

	if (FAILED(m_csResource.Init()))
	{
		ATLTRACE(atlTraceGeneral, 0, _T("ERROR : Unable to initialize critical section in CAtlBaseModule\n"));
		ATLASSERT(0);
		CAtlBaseModule::m_bInitFailed = true;
	}
}

CAtlBaseModule::~CAtlBaseModule() throw ()
{
	m_csResource.Term();
}

bool CAtlBaseModule::AddResourceInstance(_In_ HINSTANCE hInst) throw()
{
	CComCritSecLock<CComCriticalSection> lock(m_csResource, false);
	if (FAILED(lock.Lock()))
	{
		ATLTRACE(atlTraceGeneral, 0, _T("ERROR : Unable to lock critical section in CAtlBaseModule\n"));
		ATLASSERT(0);
		return false;
	}
	return m_rgResourceInstance.Add(hInst) != FALSE;
}

bool CAtlBaseModule::RemoveResourceInstance(_In_ HINSTANCE hInst) throw()
{
	CComCritSecLock<CComCriticalSection> lock(m_csResource, false);
	if (FAILED(lock.Lock()))
	{
			ATLTRACE(atlTraceGeneral, 0, _T("ERROR : Unable to lock critical section in CAtlBaseModule\n"));
		ATLASSERT(0);
		return false;
	}
	for (int i = 0; i < m_rgResourceInstance.GetSize(); i++)
	{
		if (m_rgResourceInstance[i] == hInst)
		{
			m_rgResourceInstance.RemoveAt(i);
			return true;
		}
	}
	return false;
}
HINSTANCE CAtlBaseModule::GetHInstanceAt(_In_ int i) throw()
{
	CComCritSecLock<CComCriticalSection> lock(m_csResource, false);
	if (FAILED(lock.Lock()))
	{
		ATLTRACE(atlTraceGeneral, 0, _T("ERROR : Unable to lock critical section in CAtlBaseModule\n"));
		ATLASSERT(0);
		return NULL;
	}
	if (i > m_rgResourceInstance.GetSize() || i < 0)
	{
		return NULL;
	}

	if (i == m_rgResourceInstance.GetSize())
	{
		return m_hInstResource;
	}

	return m_rgResourceInstance[i];
}

#pragma init_seg( lib )

CAtlBaseModule	_AtlBaseModule;
};  // namespace ATL
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\src\atl\atls\allocate.cpp ===
// This is a part of the Active Template Library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Active Template Library Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Active Template Library product.

#include "stdafx.h"

#include "Common.h"
#include "Allocate.h"

#include "AtlTraceModuleManager.h"

#pragma comment(lib, "advapi32.lib")
#pragma warning(disable : 4711)	// function selected for automatic inline expansion

bool CAtlAllocator::Init(
	_In_z_ const CHAR *pszFileName,
	_In_ DWORD dwMaxSize)
{
	// We're relying on syncronization provided by the startup code (CRT DllMain/WinMain)
	Close();

	ATLASSERT(!m_hMap && !m_pBufferStart);

	HANDLE hThreadToken = NULL;
	__try
	{
		// If we're being loaded while impersonating a different client,
		// we need to revert to self before we open the shared memory section
		BOOL bOpen = OpenThreadToken(GetCurrentThread(), TOKEN_IMPERSONATE|TOKEN_DUPLICATE, TRUE, &hThreadToken);
		if( bOpen && hThreadToken != NULL )
		{
			if( !RevertToSelf() )
			{
				CloseHandle(hThreadToken);
				hThreadToken = NULL;
				__leave;
			}
		}

		// Use a NULL SECURITY_ATTRIBUTES structure to get the default DACL.
		m_hMap = CreateFileMappingA(INVALID_HANDLE_VALUE, NULL,
			PAGE_READWRITE | SEC_RESERVE, 0, dwMaxSize, pszFileName);
		if(!m_hMap)
		{
			__leave;
		}

		DWORD dwErr = ::GetLastError();

		m_pBufferStart = (BYTE *)
			MapViewOfFile(m_hMap, FILE_MAP_ALL_ACCESS, 0, 0, 0);
		if(!m_pBufferStart)
		{
			__leave;
		}

		SYSTEM_INFO si;
		GetSystemInfo(&si);

		if(dwErr == ERROR_ALREADY_EXISTS)
		{
			m_pProcess = reinterpret_cast<CAtlTraceProcess *>(m_pBufferStart);

			// Looks like it's already mapped into this process space.
			// Let's do some checking...
			if(( m_pProcess==NULL ) || ( m_pProcess->Base()==NULL ) ||
				( 0 != memcmp(m_pBufferStart, m_pProcess->Base(), m_pProcess->m_dwFrontAlloc )))
			{
				// something's not right
				__leave;
			}

			// sure looks valid
			m_pProcess->IncRef();
			m_pProcess = static_cast<CAtlTraceProcess *>(m_pProcess->Base());

			UnmapViewOfFile(m_pBufferStart);
			m_pBufferStart = reinterpret_cast<BYTE *>(m_pProcess);
		}
		else
		{
			// This is just in case sizeof(CAtlTraceProcess) is
			// ever > dwPageSize (doubtful that could ever
			// happen, but it's easy enough to avoid here)
			DWORD dwCurrAlloc = si.dwPageSize;
			while(dwCurrAlloc < sizeof(CAtlTraceProcess))
			{
				dwCurrAlloc += si.dwPageSize;
			}

			if(!VirtualAlloc(m_pBufferStart, dwCurrAlloc, MEM_COMMIT, PAGE_READWRITE))
			{
				__leave;
			}

			m_pProcess = new(m_pBufferStart) CAtlTraceProcess(dwMaxSize);
			m_pProcess->m_dwFrontAlloc = dwCurrAlloc;
			m_pProcess->m_dwCurrFront = sizeof(CAtlTraceProcess);
		}
		m_dwPageSize = si.dwPageSize;
		m_bValid = true;
	}
	__finally
	{
		if( hThreadToken != NULL )
		{
			// Go back to impersonating whomever we were impersonating
			BOOL bSuccess;
			bSuccess = SetThreadToken(NULL, hThreadToken);
			ATLASSERT( bSuccess );
			CloseHandle( hThreadToken );
		}

		if(!m_bValid)
		{
			if(m_pBufferStart)
			{
				UnmapViewOfFile(m_pBufferStart);
				m_pBufferStart = NULL;
			}

			if(m_hMap)
			{
				CloseHandle(m_hMap);
				m_hMap = NULL;
			}
		}
	}
	return m_bValid;
}

bool CAtlAllocator::Open(_In_z_ const CHAR *pszFileName)
{
	Close();

	__try
	{
		m_hMap = OpenFileMappingA(FILE_MAP_WRITE, FALSE, pszFileName);
		if(!m_hMap)
			__leave;

		m_pBufferStart = (BYTE *)
			MapViewOfFile(m_hMap, FILE_MAP_ALL_ACCESS, 0, 0, 0);
		if(!m_pBufferStart)
			__leave;

		m_pProcess = reinterpret_cast<CAtlTraceProcess *>(m_pBufferStart);
		m_pProcess->IncRef();

		SYSTEM_INFO si;
		GetSystemInfo(&si);
		m_dwPageSize = si.dwPageSize;

		m_bValid = true;
	}
	__finally
	{
		if(!m_bValid)
		{
			if(m_pBufferStart)
			{
				UnmapViewOfFile(m_pBufferStart);
				m_pBufferStart = NULL;
			}
			if(m_hMap)
			{
				CloseHandle(m_hMap);
				m_hMap = NULL;
			}

			m_pProcess = NULL;
		}
	}
	return m_bValid;
}

void CAtlAllocator::Close(_In_ bool bForceUnmap)
{
	if(m_bValid)
	{
		if(m_pProcess->DecRef() == 0 || bForceUnmap)
			UnmapViewOfFile(m_pBufferStart);
		m_pBufferStart = NULL;

		CloseHandle(m_hMap);
		m_hMap = NULL;

		m_bValid = false;
	}
}

CAtlTraceModule *CAtlAllocator::GetModule(_In_ int iModule) const
{
	if (!m_bValid)
	{
		return NULL;
	}

	if( iModule == -1 )
	{
		return NULL;
	}
        int modcnt = m_pProcess->ModuleCount();
	ATLASSERT(iModule < modcnt);
	if(iModule >=0 && iModule < modcnt)
	{
		BYTE *pb = reinterpret_cast<BYTE *>(m_pProcess) + sizeof(CAtlTraceProcess);
		return reinterpret_cast<CAtlTraceModule *>(pb) + iModule;
	}
	else
	{
		return NULL;
	}
}

/*
CAtlTraceCategory *CAtlAllocator::GetCategory(
	_In_ unsigned nModule,
	_In_ unsigned nCategory) const
{
	ATLASSERT(nModule < m_pProcess->ModuleCount());

	if(nModule < m_pProcess->ModuleCount())
	{
		BYTE *pb = reinterpret_cast<BYTE *>(m_pProcess) + sizeof(CAtlTraceProcess);
		CAtlTraceModule *pModule = reinterpret_cast<CAtlTraceModule *>(pb) + nModule;

		if(IsValidCategoryIndex(pModule->m_nFirstCategory))
		{
			unsigned nOldIndex, nIndex = pModule->m_nFirstCategory;
			CAtlTraceCategory *pCategory;
			do
			{
				pCategory = GetCategoryByIndex(nIndex);
				if(pCategory->m_nCategory == nCategory)
					return pCategory;

				nOldIndex = nIndex;
				nIndex = pCategory->m_nNext;
			}
			while(nOldIndex != nIndex);
		}
	}
	return NULL;
}
*/

/*
bool CAtlAllocator::IsValidCategoryIndex(_In_ unsigned nIndex) const
{
	return nIndex < m_pProcess->CategoryCount();
}
*/

CAtlTraceCategory *CAtlAllocator::GetCategory(_In_ int iCategory) const
{
	if (!m_bValid)
	{
		return NULL;
	}

	if(iCategory == m_pProcess->CategoryCount())
	{
		return NULL;
	}

	ATLASSERT((iCategory < m_pProcess->CategoryCount()) || (iCategory == -1));
	CAtlTraceCategory *pCategory = NULL;
	if(iCategory >= 0)
	{
		BYTE *pb = reinterpret_cast<BYTE *>(m_pProcess) + m_pProcess->MaxSize();
		pCategory = reinterpret_cast<CAtlTraceCategory *>(pb) - iCategory - 1;
	}
	return pCategory;
}

int CAtlAllocator::GetCategoryCount(_In_ int iModule) const
{
	if (!m_bValid)
	{
		return 0;
	}

	UINT nCategories = 0;
	CAtlTraceModule* pModule = GetModule(iModule);
	ATLASSERT(pModule != NULL);
	if(pModule != NULL)
	{
		nCategories = GetCategoryCount( *pModule );
	}

	return nCategories;
}

int CAtlAllocator::GetCategoryCount(_In_ const CAtlTraceModule& rModule) const
{
	if (!m_bValid)
	{
		return 0;
	}

	UINT nCategories = 0;
	int iCategory = rModule.m_iFirstCategory;
	while( iCategory != -1 )
	{
		CAtlTraceCategory* pCategory = GetCategory( iCategory );
		if( pCategory == NULL )
			break;
		nCategories++;
		iCategory = pCategory->m_iNextCategory;
	}
	return nCategories;
}

int CAtlAllocator::GetModuleCount() const
{
	if (!m_bValid)
	{
		return 0;
	}

	ATLASSERT(m_pProcess);
	return m_pProcess->ModuleCount();
}

const ULONG kModuleBatchSize = 10;

bool CAtlAllocator::FindModule(
	_In_z_ const WCHAR *pszModulePath,
	_Out_ unsigned *pnModule) const
{
	if (!m_bValid)
	{
		return false;
	}

	if(pnModule)
	{
		for(int i = 0; i < m_pProcess->ModuleCount(); i++)
		{
			if(0 == _wcsicmp(GetModule(i)->Path(), pszModulePath))
			{
				*pnModule = i;
				return true;
			}
		}
	}

	return false;
}

int CAtlAllocator::AddModule(_In_ HINSTANCE hInst)
{
	if (!m_bValid)
	{
		return -1;
	}

	CAtlTraceProcess *pProcess = GetProcess();
	ATLASSERT(pProcess);
	int iFoundModule = -1;
	while( iFoundModule == -1 )
	{
		for(int iModule = 0; (iModule < pProcess->ModuleCount()) && (iFoundModule == -1); iModule++)
		{
			CAtlTraceModule *pModule = GetModule(iModule);
			ATLASSERT(pModule != NULL);
			bool bFound = pModule->TryAllocate();
			if( bFound )
			{
				pModule->Reset(hInst);
				pModule->m_iFirstCategory = -1;
				pModule->MarkValid( pProcess->GetNextCookie() );
				iFoundModule = iModule;
			}
		}
		if( iFoundModule == -1 )
		{
			ULONG nNewAllocSize = kModuleBatchSize*sizeof( CAtlTraceModule );
			void* pNewModules = reinterpret_cast<BYTE *>(pProcess) + pProcess->m_dwFrontAlloc;
			VirtualAlloc(pNewModules, nNewAllocSize, MEM_COMMIT, PAGE_READWRITE);
			pProcess->m_dwFrontAlloc += nNewAllocSize;
			for( ULONG iNewModule = 0; iNewModule < kModuleBatchSize; iNewModule++ )
			{
				CAtlTraceModule* pNewModule = static_cast< CAtlTraceModule* >( pNewModules )+iNewModule;
				new( pNewModule ) CAtlTraceModule;
			}
			pProcess->IncModuleCount( kModuleBatchSize );
		}
	}

	return iFoundModule;
}

const ULONG kCategoryBatchSize = 10;

int CAtlAllocator::AddCategory(
	_In_ int iModule,
	_In_z_ const WCHAR *szCategoryName)
{
	if (!m_bValid)
	{
		return -1;
	}

	int iFoundCategory = -1;
	CAtlTraceProcess *pProcess = GetProcess();
	ATLASSERT(pProcess);
	CAtlTraceModule *pModule = GetModule(iModule);
	if(pModule)
	{
		pModule->TryAddRef();

		while( iFoundCategory == -1 )
		{
			for(int iCategory = 0; (iCategory < pProcess->CategoryCount()) && (iFoundCategory == -1); iCategory++)
			{
				CAtlTraceCategory *pCategory = GetCategory( iCategory );
				ATLASSERT(pCategory != NULL);
				bool bFound = pCategory->TryAllocate();
				if( bFound )
				{
					pCategory->Reset( szCategoryName, pModule->m_nCookie );
					pCategory->m_iNextCategory = pModule->m_iFirstCategory;
					pCategory->MarkValid( pProcess->GetNextCookie() );
					pModule->m_iFirstCategory = iCategory;
					::InterlockedIncrement( &pModule->m_nCategories );
					iFoundCategory = iCategory;
				}
			}

			if( iFoundCategory == -1 )
			{
				ULONG nNewAllocSize = kCategoryBatchSize*sizeof( CAtlTraceCategory );
				void* pNewCategories = reinterpret_cast<BYTE *>(pProcess) + pProcess->MaxSize()-pProcess->m_dwBackAlloc-nNewAllocSize;
				VirtualAlloc(pNewCategories, nNewAllocSize, MEM_COMMIT, PAGE_READWRITE);
				pProcess->m_dwBackAlloc += nNewAllocSize;
				for( ULONG iNewCategory = 0; iNewCategory < kCategoryBatchSize; iNewCategory++ )
				{
					CAtlTraceCategory* pNewCategory = static_cast< CAtlTraceCategory* >( pNewCategories )+iNewCategory;
					new( pNewCategory ) CAtlTraceCategory;
				}
				pProcess->IncCategoryCount( kCategoryBatchSize );
			}
		}

		pModule->Release();
	}

	pProcess->m_bLoaded = false;

	return( iFoundCategory );
}

bool CAtlAllocator::RemoveModule(_In_ int iModule)
{
	if (!m_bValid)
	{
		return false;
	}

	CAtlTraceModule* pModule = GetModule(iModule);
	if(pModule)
	{
		int iCategory = pModule->m_iFirstCategory;
		while( iCategory != -1 )
		{
			CAtlTraceCategory* pCategory = GetCategory( iCategory );
			if( pCategory == NULL )
			{
				pModule->Release();
				return false;
			}
			iCategory = pCategory->m_iNextCategory;
			::InterlockedDecrement( &pModule->m_nCategories );
			pModule->m_iFirstCategory = iCategory;
			pCategory->Release();
		}

		pModule->Release();
		return true;
	}
	return false;
}

void CAtlAllocator::CleanUp()
{
	Close();
}

void CAtlAllocator::TakeSnapshot()
{
	if (!m_bValid)
	{
		return;
	}

	if( m_bSnapshot )
	{
		ReleaseSnapshot();
	}

	int nModules = GetModuleCount();
	for( int iModule = 0; iModule < nModules; iModule++ )
	{
		CAtlTraceModule* pModule = GetModule( iModule );
		bool bValidModule = pModule->TryAddRef();
		if( bValidModule )
		{
			CTraceSnapshot::CModuleInfo module;
			module.m_dwModule = DWORD_PTR( iModule )+1;
			module.m_iFirstCategory = m_snapshot.m_adwCategories.GetSize();
			module.m_nCategories = pModule->m_nCategories;

			int iCategory = pModule->m_iFirstCategory;
			bool bCategoriesValid = true;
			int nCategories = 0;
			while( (iCategory != -1) && bCategoriesValid )
			{
				CAtlTraceCategory* pCategory = GetCategory( iCategory );
				bool bValidCategory = pCategory->TryAddRef();
				if( bValidCategory )
				{
					if( pCategory->m_nModuleCookie != pModule->m_nCookie )
					{
						bValidCategory = false;
						pCategory->Release();
					}
					else
					{
						m_snapshot.m_adwCategories.Add( DWORD_PTR( iCategory ) );
						nCategories++;
						iCategory = pCategory->m_iNextCategory;
					}
				}
				if( !bValidCategory )
				{
					bCategoriesValid = false;
				}
			}
			if( !bCategoriesValid )
			{
				for( int iCategoryIndex = nCategories-1; iCategoryIndex >= 0; iCategoryIndex-- )
				{
					DWORD_PTR dwCategory = m_snapshot.m_adwCategories[module.m_iFirstCategory+iCategoryIndex];
					m_snapshot.m_adwCategories.RemoveAt( module.m_iFirstCategory+iCategoryIndex );
					GetCategory( int( dwCategory ) )->Release();
				}
				pModule->Release();
			}
			else
			{
				m_snapshot.m_aModules.Add( module );
			}
		}
	}

	m_bSnapshot = true;
}

void CAtlAllocator::ReleaseSnapshot()
{
	if (!m_bValid)
	{
		return;
	}

	if( m_bSnapshot )
	{
		for( int iModule = 0; iModule < m_snapshot.m_aModules.GetSize(); iModule++ )
		{
			CAtlTraceModule *pModule = GetModule( int( m_snapshot.m_aModules[iModule].m_dwModule-1 ) );
			if( pModule != NULL )
				pModule->Release();
		}
		for( int iCategory = 0; iCategory < m_snapshot.m_adwCategories.GetSize(); iCategory++ )
		{
			CAtlTraceCategory *pCategory = GetCategory( int( m_snapshot.m_adwCategories[iCategory] ) );
			if( pCategory != NULL )
				pCategory->Release();
		}
		m_bSnapshot = false;
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\src\atl\atls\atlcommodule.cpp ===
// This is a part of the Active Template Library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Active Template Library Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the	
// Active Template Library product.

#include "StdAfx.H"

#pragma warning( disable: 4073 )  // initializers put in library initialization area

namespace ATL
{

#pragma init_seg( lib )

CAtlComModule	_AtlComModule;
};  // namespace ATL
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\src\atl\atls\ATLComTime.cpp ===
// This is a part of the Active Template Library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Active Template Library Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Active Template Library product.

#include "StdAfx.H"

#ifdef _DEBUG
#define ATLCOMTIME_INLINE
#include <atlcomtime.inl>
#endif	// _DEBUG

#include <oledb.h>

namespace ATL
{

bool CTime::GetAsDBTIMESTAMP(_Out_ DBTIMESTAMP& dbts) const
{
	struct tm tmLocal;
	GetLocalTm(&tmLocal);

	dbts.year = (SHORT) (1900 + tmLocal.tm_year);
	dbts.month = (USHORT) (1 + tmLocal.tm_mon);
	dbts.day = (USHORT) tmLocal.tm_mday;
	dbts.hour = (USHORT) tmLocal.tm_hour;
	dbts.minute = (USHORT) tmLocal.tm_min;
	dbts.second = (USHORT) tmLocal.tm_sec;
	dbts.fraction = 0;

	return true;
}

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\src\atl\atls\atlfuncs.cpp ===
// This is a part of the Active Template Library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Active Template Library Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the	
// Active Template Library product.

#include "stdafx.h"

#undef ATLINLINE
#define ATLINLINE
#ifdef _DEBUG
#include <atlbase.inl>
#endif

// C4740 - flow in or out of inline asm code suppresses global optimization
#pragma warning( disable: 4740 )

namespace  ATL
{

/////////////////////////////////////////////////////////////////////////////
// ComStdThunk

#ifdef _M_IX86
extern "C"
void __declspec(naked) __stdcall CComStdCallThunkHelper()
{
	__asm
	{
		mov eax, [esp+4];	// get pThunk
		mov edx, [eax+4];	// get the pThunk->pThis
		mov [esp+4], edx;	// replace pThunk with pThis
		mov eax, [eax+8];	// get pThunk->pfn
		jmp eax;			// jump pfn
	};
}

#endif

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\src\atl\atls\atldebuginterfacesmodule.cpp ===
// This is a part of the Active Template Library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Active Template Library Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the	
// Active Template Library product.

#include "StdAfx.H"

// C4073 - initializers put in library initialization area
// C4740 - flow in or out of inline asm code suppresses global optimization
#pragma warning( disable: 4073 4740 )

namespace ATL
{

inline static void WINAPI atlBadThunkCall()
{
	ATLASSERT(FALSE && "Call through deleted thunk");
}

#if defined(_M_IX86)

#define ATL_IMPL_THUNK(n)\
__declspec(naked) HRESULT _QIThunk::f##n()\
{\
	__asm mov eax, [esp+4]  /* eax = this */ \
	__asm cmp dword ptr [eax+8], 0  /* if( this->m_dwRef > 0 ) */ \
	__asm jg goodref\
	__asm call atlBadThunkCall\
	__asm goodref:\
	__asm mov eax, [esp+4]  /* eax = this */ \
	__asm mov eax, dword ptr [eax+4]  /* eax = this->m_pUnk */ \
	__asm mov [esp+4], eax  /* this = m_pUnk */ \
	__asm mov eax, dword ptr [eax]  /* eax = m_pUnk->vtbl */ \
	__asm mov eax, dword ptr [eax+4*n]  /* eax = this->vtbl[n] */ \
	__asm jmp eax  /* call the real method on m_pUnk */ \
}

ATL_IMPL_THUNK(3)
ATL_IMPL_THUNK(4)
ATL_IMPL_THUNK(5)
ATL_IMPL_THUNK(6)
ATL_IMPL_THUNK(7)
ATL_IMPL_THUNK(8)
ATL_IMPL_THUNK(9)
ATL_IMPL_THUNK(10)
ATL_IMPL_THUNK(11)
ATL_IMPL_THUNK(12)
ATL_IMPL_THUNK(13)
ATL_IMPL_THUNK(14)
ATL_IMPL_THUNK(15)
ATL_IMPL_THUNK(16)
ATL_IMPL_THUNK(17)
ATL_IMPL_THUNK(18)
ATL_IMPL_THUNK(19)
ATL_IMPL_THUNK(20)
ATL_IMPL_THUNK(21)
ATL_IMPL_THUNK(22)
ATL_IMPL_THUNK(23)
ATL_IMPL_THUNK(24)
ATL_IMPL_THUNK(25)
ATL_IMPL_THUNK(26)
ATL_IMPL_THUNK(27)
ATL_IMPL_THUNK(28)
ATL_IMPL_THUNK(29)
ATL_IMPL_THUNK(30)
ATL_IMPL_THUNK(31)
ATL_IMPL_THUNK(32)
ATL_IMPL_THUNK(33)
ATL_IMPL_THUNK(34)
ATL_IMPL_THUNK(35)
ATL_IMPL_THUNK(36)
ATL_IMPL_THUNK(37)
ATL_IMPL_THUNK(38)
ATL_IMPL_THUNK(39)
ATL_IMPL_THUNK(40)
ATL_IMPL_THUNK(41)
ATL_IMPL_THUNK(42)
ATL_IMPL_THUNK(43)
ATL_IMPL_THUNK(44)
ATL_IMPL_THUNK(45)
ATL_IMPL_THUNK(46)
ATL_IMPL_THUNK(47)
ATL_IMPL_THUNK(48)
ATL_IMPL_THUNK(49)
ATL_IMPL_THUNK(50)
ATL_IMPL_THUNK(51)
ATL_IMPL_THUNK(52)
ATL_IMPL_THUNK(53)
ATL_IMPL_THUNK(54)
ATL_IMPL_THUNK(55)
ATL_IMPL_THUNK(56)
ATL_IMPL_THUNK(57)
ATL_IMPL_THUNK(58)
ATL_IMPL_THUNK(59)
ATL_IMPL_THUNK(60)
ATL_IMPL_THUNK(61)
ATL_IMPL_THUNK(62)
ATL_IMPL_THUNK(63)
ATL_IMPL_THUNK(64)
ATL_IMPL_THUNK(65)
ATL_IMPL_THUNK(66)
ATL_IMPL_THUNK(67)
ATL_IMPL_THUNK(68)
ATL_IMPL_THUNK(69)
ATL_IMPL_THUNK(70)
ATL_IMPL_THUNK(71)
ATL_IMPL_THUNK(72)
ATL_IMPL_THUNK(73)
ATL_IMPL_THUNK(74)
ATL_IMPL_THUNK(75)
ATL_IMPL_THUNK(76)
ATL_IMPL_THUNK(77)
ATL_IMPL_THUNK(78)
ATL_IMPL_THUNK(79)
ATL_IMPL_THUNK(80)
ATL_IMPL_THUNK(81)
ATL_IMPL_THUNK(82)
ATL_IMPL_THUNK(83)
ATL_IMPL_THUNK(84)
ATL_IMPL_THUNK(85)
ATL_IMPL_THUNK(86)
ATL_IMPL_THUNK(87)
ATL_IMPL_THUNK(88)
ATL_IMPL_THUNK(89)
ATL_IMPL_THUNK(90)
ATL_IMPL_THUNK(91)
ATL_IMPL_THUNK(92)
ATL_IMPL_THUNK(93)
ATL_IMPL_THUNK(94)
ATL_IMPL_THUNK(95)
ATL_IMPL_THUNK(96)
ATL_IMPL_THUNK(97)
ATL_IMPL_THUNK(98)
ATL_IMPL_THUNK(99)
ATL_IMPL_THUNK(100)
ATL_IMPL_THUNK(101)
ATL_IMPL_THUNK(102)
ATL_IMPL_THUNK(103)
ATL_IMPL_THUNK(104)
ATL_IMPL_THUNK(105)
ATL_IMPL_THUNK(106)
ATL_IMPL_THUNK(107)
ATL_IMPL_THUNK(108)
ATL_IMPL_THUNK(109)
ATL_IMPL_THUNK(110)
ATL_IMPL_THUNK(111)
ATL_IMPL_THUNK(112)
ATL_IMPL_THUNK(113)
ATL_IMPL_THUNK(114)
ATL_IMPL_THUNK(115)
ATL_IMPL_THUNK(116)
ATL_IMPL_THUNK(117)
ATL_IMPL_THUNK(118)
ATL_IMPL_THUNK(119)
ATL_IMPL_THUNK(120)
ATL_IMPL_THUNK(121)
ATL_IMPL_THUNK(122)
ATL_IMPL_THUNK(123)
ATL_IMPL_THUNK(124)
ATL_IMPL_THUNK(125)
ATL_IMPL_THUNK(126)
ATL_IMPL_THUNK(127)
ATL_IMPL_THUNK(128)
ATL_IMPL_THUNK(129)
ATL_IMPL_THUNK(130)
ATL_IMPL_THUNK(131)
ATL_IMPL_THUNK(132)
ATL_IMPL_THUNK(133)
ATL_IMPL_THUNK(134)
ATL_IMPL_THUNK(135)
ATL_IMPL_THUNK(136)
ATL_IMPL_THUNK(137)
ATL_IMPL_THUNK(138)
ATL_IMPL_THUNK(139)
ATL_IMPL_THUNK(140)
ATL_IMPL_THUNK(141)
ATL_IMPL_THUNK(142)
ATL_IMPL_THUNK(143)
ATL_IMPL_THUNK(144)
ATL_IMPL_THUNK(145)
ATL_IMPL_THUNK(146)
ATL_IMPL_THUNK(147)
ATL_IMPL_THUNK(148)
ATL_IMPL_THUNK(149)
ATL_IMPL_THUNK(150)
ATL_IMPL_THUNK(151)
ATL_IMPL_THUNK(152)
ATL_IMPL_THUNK(153)
ATL_IMPL_THUNK(154)
ATL_IMPL_THUNK(155)
ATL_IMPL_THUNK(156)
ATL_IMPL_THUNK(157)
ATL_IMPL_THUNK(158)
ATL_IMPL_THUNK(159)
ATL_IMPL_THUNK(160)
ATL_IMPL_THUNK(161)
ATL_IMPL_THUNK(162)
ATL_IMPL_THUNK(163)
ATL_IMPL_THUNK(164)
ATL_IMPL_THUNK(165)
ATL_IMPL_THUNK(166)
ATL_IMPL_THUNK(167)
ATL_IMPL_THUNK(168)
ATL_IMPL_THUNK(169)
ATL_IMPL_THUNK(170)
ATL_IMPL_THUNK(171)
ATL_IMPL_THUNK(172)
ATL_IMPL_THUNK(173)
ATL_IMPL_THUNK(174)
ATL_IMPL_THUNK(175)
ATL_IMPL_THUNK(176)
ATL_IMPL_THUNK(177)
ATL_IMPL_THUNK(178)
ATL_IMPL_THUNK(179)
ATL_IMPL_THUNK(180)
ATL_IMPL_THUNK(181)
ATL_IMPL_THUNK(182)
ATL_IMPL_THUNK(183)
ATL_IMPL_THUNK(184)
ATL_IMPL_THUNK(185)
ATL_IMPL_THUNK(186)
ATL_IMPL_THUNK(187)
ATL_IMPL_THUNK(188)
ATL_IMPL_THUNK(189)
ATL_IMPL_THUNK(190)
ATL_IMPL_THUNK(191)
ATL_IMPL_THUNK(192)
ATL_IMPL_THUNK(193)
ATL_IMPL_THUNK(194)
ATL_IMPL_THUNK(195)
ATL_IMPL_THUNK(196)
ATL_IMPL_THUNK(197)
ATL_IMPL_THUNK(198)
ATL_IMPL_THUNK(199)
ATL_IMPL_THUNK(200)
ATL_IMPL_THUNK(201)
ATL_IMPL_THUNK(202)
ATL_IMPL_THUNK(203)
ATL_IMPL_THUNK(204)
ATL_IMPL_THUNK(205)
ATL_IMPL_THUNK(206)
ATL_IMPL_THUNK(207)
ATL_IMPL_THUNK(208)
ATL_IMPL_THUNK(209)
ATL_IMPL_THUNK(210)
ATL_IMPL_THUNK(211)
ATL_IMPL_THUNK(212)
ATL_IMPL_THUNK(213)
ATL_IMPL_THUNK(214)
ATL_IMPL_THUNK(215)
ATL_IMPL_THUNK(216)
ATL_IMPL_THUNK(217)
ATL_IMPL_THUNK(218)
ATL_IMPL_THUNK(219)
ATL_IMPL_THUNK(220)
ATL_IMPL_THUNK(221)
ATL_IMPL_THUNK(222)
ATL_IMPL_THUNK(223)
ATL_IMPL_THUNK(224)
ATL_IMPL_THUNK(225)
ATL_IMPL_THUNK(226)
ATL_IMPL_THUNK(227)
ATL_IMPL_THUNK(228)
ATL_IMPL_THUNK(229)
ATL_IMPL_THUNK(230)
ATL_IMPL_THUNK(231)
ATL_IMPL_THUNK(232)
ATL_IMPL_THUNK(233)
ATL_IMPL_THUNK(234)
ATL_IMPL_THUNK(235)
ATL_IMPL_THUNK(236)
ATL_IMPL_THUNK(237)
ATL_IMPL_THUNK(238)
ATL_IMPL_THUNK(239)
ATL_IMPL_THUNK(240)
ATL_IMPL_THUNK(241)
ATL_IMPL_THUNK(242)
ATL_IMPL_THUNK(243)
ATL_IMPL_THUNK(244)
ATL_IMPL_THUNK(245)
ATL_IMPL_THUNK(246)
ATL_IMPL_THUNK(247)
ATL_IMPL_THUNK(248)
ATL_IMPL_THUNK(249)
ATL_IMPL_THUNK(250)
ATL_IMPL_THUNK(251)
ATL_IMPL_THUNK(252)
ATL_IMPL_THUNK(253)
ATL_IMPL_THUNK(254)
ATL_IMPL_THUNK(255)
ATL_IMPL_THUNK(256)
ATL_IMPL_THUNK(257)
ATL_IMPL_THUNK(258)
ATL_IMPL_THUNK(259)
ATL_IMPL_THUNK(260)
ATL_IMPL_THUNK(261)
ATL_IMPL_THUNK(262)
ATL_IMPL_THUNK(263)
ATL_IMPL_THUNK(264)
ATL_IMPL_THUNK(265)
ATL_IMPL_THUNK(266)
ATL_IMPL_THUNK(267)
ATL_IMPL_THUNK(268)
ATL_IMPL_THUNK(269)
ATL_IMPL_THUNK(270)
ATL_IMPL_THUNK(271)
ATL_IMPL_THUNK(272)
ATL_IMPL_THUNK(273)
ATL_IMPL_THUNK(274)
ATL_IMPL_THUNK(275)
ATL_IMPL_THUNK(276)
ATL_IMPL_THUNK(277)
ATL_IMPL_THUNK(278)
ATL_IMPL_THUNK(279)
ATL_IMPL_THUNK(280)
ATL_IMPL_THUNK(281)
ATL_IMPL_THUNK(282)
ATL_IMPL_THUNK(283)
ATL_IMPL_THUNK(284)
ATL_IMPL_THUNK(285)
ATL_IMPL_THUNK(286)
ATL_IMPL_THUNK(287)
ATL_IMPL_THUNK(288)
ATL_IMPL_THUNK(289)
ATL_IMPL_THUNK(290)
ATL_IMPL_THUNK(291)
ATL_IMPL_THUNK(292)
ATL_IMPL_THUNK(293)
ATL_IMPL_THUNK(294)
ATL_IMPL_THUNK(295)
ATL_IMPL_THUNK(296)
ATL_IMPL_THUNK(297)
ATL_IMPL_THUNK(298)
ATL_IMPL_THUNK(299)
ATL_IMPL_THUNK(300)
ATL_IMPL_THUNK(301)
ATL_IMPL_THUNK(302)
ATL_IMPL_THUNK(303)
ATL_IMPL_THUNK(304)
ATL_IMPL_THUNK(305)
ATL_IMPL_THUNK(306)
ATL_IMPL_THUNK(307)
ATL_IMPL_THUNK(308)
ATL_IMPL_THUNK(309)
ATL_IMPL_THUNK(310)
ATL_IMPL_THUNK(311)
ATL_IMPL_THUNK(312)
ATL_IMPL_THUNK(313)
ATL_IMPL_THUNK(314)
ATL_IMPL_THUNK(315)
ATL_IMPL_THUNK(316)
ATL_IMPL_THUNK(317)
ATL_IMPL_THUNK(318)
ATL_IMPL_THUNK(319)
ATL_IMPL_THUNK(320)
ATL_IMPL_THUNK(321)
ATL_IMPL_THUNK(322)
ATL_IMPL_THUNK(323)
ATL_IMPL_THUNK(324)
ATL_IMPL_THUNK(325)
ATL_IMPL_THUNK(326)
ATL_IMPL_THUNK(327)
ATL_IMPL_THUNK(328)
ATL_IMPL_THUNK(329)
ATL_IMPL_THUNK(330)
ATL_IMPL_THUNK(331)
ATL_IMPL_THUNK(332)
ATL_IMPL_THUNK(333)
ATL_IMPL_THUNK(334)
ATL_IMPL_THUNK(335)
ATL_IMPL_THUNK(336)
ATL_IMPL_THUNK(337)
ATL_IMPL_THUNK(338)
ATL_IMPL_THUNK(339)
ATL_IMPL_THUNK(340)
ATL_IMPL_THUNK(341)
ATL_IMPL_THUNK(342)
ATL_IMPL_THUNK(343)
ATL_IMPL_THUNK(344)
ATL_IMPL_THUNK(345)
ATL_IMPL_THUNK(346)
ATL_IMPL_THUNK(347)
ATL_IMPL_THUNK(348)
ATL_IMPL_THUNK(349)
ATL_IMPL_THUNK(350)
ATL_IMPL_THUNK(351)
ATL_IMPL_THUNK(352)
ATL_IMPL_THUNK(353)
ATL_IMPL_THUNK(354)
ATL_IMPL_THUNK(355)
ATL_IMPL_THUNK(356)
ATL_IMPL_THUNK(357)
ATL_IMPL_THUNK(358)
ATL_IMPL_THUNK(359)
ATL_IMPL_THUNK(360)
ATL_IMPL_THUNK(361)
ATL_IMPL_THUNK(362)
ATL_IMPL_THUNK(363)
ATL_IMPL_THUNK(364)
ATL_IMPL_THUNK(365)
ATL_IMPL_THUNK(366)
ATL_IMPL_THUNK(367)
ATL_IMPL_THUNK(368)
ATL_IMPL_THUNK(369)
ATL_IMPL_THUNK(370)
ATL_IMPL_THUNK(371)
ATL_IMPL_THUNK(372)
ATL_IMPL_THUNK(373)
ATL_IMPL_THUNK(374)
ATL_IMPL_THUNK(375)
ATL_IMPL_THUNK(376)
ATL_IMPL_THUNK(377)
ATL_IMPL_THUNK(378)
ATL_IMPL_THUNK(379)
ATL_IMPL_THUNK(380)
ATL_IMPL_THUNK(381)
ATL_IMPL_THUNK(382)
ATL_IMPL_THUNK(383)
ATL_IMPL_THUNK(384)
ATL_IMPL_THUNK(385)
ATL_IMPL_THUNK(386)
ATL_IMPL_THUNK(387)
ATL_IMPL_THUNK(388)
ATL_IMPL_THUNK(389)
ATL_IMPL_THUNK(390)
ATL_IMPL_THUNK(391)
ATL_IMPL_THUNK(392)
ATL_IMPL_THUNK(393)
ATL_IMPL_THUNK(394)
ATL_IMPL_THUNK(395)
ATL_IMPL_THUNK(396)
ATL_IMPL_THUNK(397)
ATL_IMPL_THUNK(398)
ATL_IMPL_THUNK(399)
ATL_IMPL_THUNK(400)
ATL_IMPL_THUNK(401)
ATL_IMPL_THUNK(402)
ATL_IMPL_THUNK(403)
ATL_IMPL_THUNK(404)
ATL_IMPL_THUNK(405)
ATL_IMPL_THUNK(406)
ATL_IMPL_THUNK(407)
ATL_IMPL_THUNK(408)
ATL_IMPL_THUNK(409)
ATL_IMPL_THUNK(410)
ATL_IMPL_THUNK(411)
ATL_IMPL_THUNK(412)
ATL_IMPL_THUNK(413)
ATL_IMPL_THUNK(414)
ATL_IMPL_THUNK(415)
ATL_IMPL_THUNK(416)
ATL_IMPL_THUNK(417)
ATL_IMPL_THUNK(418)
ATL_IMPL_THUNK(419)
ATL_IMPL_THUNK(420)
ATL_IMPL_THUNK(421)
ATL_IMPL_THUNK(422)
ATL_IMPL_THUNK(423)
ATL_IMPL_THUNK(424)
ATL_IMPL_THUNK(425)
ATL_IMPL_THUNK(426)
ATL_IMPL_THUNK(427)
ATL_IMPL_THUNK(428)
ATL_IMPL_THUNK(429)
ATL_IMPL_THUNK(430)
ATL_IMPL_THUNK(431)
ATL_IMPL_THUNK(432)
ATL_IMPL_THUNK(433)
ATL_IMPL_THUNK(434)
ATL_IMPL_THUNK(435)
ATL_IMPL_THUNK(436)
ATL_IMPL_THUNK(437)
ATL_IMPL_THUNK(438)
ATL_IMPL_THUNK(439)
ATL_IMPL_THUNK(440)
ATL_IMPL_THUNK(441)
ATL_IMPL_THUNK(442)
ATL_IMPL_THUNK(443)
ATL_IMPL_THUNK(444)
ATL_IMPL_THUNK(445)
ATL_IMPL_THUNK(446)
ATL_IMPL_THUNK(447)
ATL_IMPL_THUNK(448)
ATL_IMPL_THUNK(449)
ATL_IMPL_THUNK(450)
ATL_IMPL_THUNK(451)
ATL_IMPL_THUNK(452)
ATL_IMPL_THUNK(453)
ATL_IMPL_THUNK(454)
ATL_IMPL_THUNK(455)
ATL_IMPL_THUNK(456)
ATL_IMPL_THUNK(457)
ATL_IMPL_THUNK(458)
ATL_IMPL_THUNK(459)
ATL_IMPL_THUNK(460)
ATL_IMPL_THUNK(461)
ATL_IMPL_THUNK(462)
ATL_IMPL_THUNK(463)
ATL_IMPL_THUNK(464)
ATL_IMPL_THUNK(465)
ATL_IMPL_THUNK(466)
ATL_IMPL_THUNK(467)
ATL_IMPL_THUNK(468)
ATL_IMPL_THUNK(469)
ATL_IMPL_THUNK(470)
ATL_IMPL_THUNK(471)
ATL_IMPL_THUNK(472)
ATL_IMPL_THUNK(473)
ATL_IMPL_THUNK(474)
ATL_IMPL_THUNK(475)
ATL_IMPL_THUNK(476)
ATL_IMPL_THUNK(477)
ATL_IMPL_THUNK(478)
ATL_IMPL_THUNK(479)
ATL_IMPL_THUNK(480)
ATL_IMPL_THUNK(481)
ATL_IMPL_THUNK(482)
ATL_IMPL_THUNK(483)
ATL_IMPL_THUNK(484)
ATL_IMPL_THUNK(485)
ATL_IMPL_THUNK(486)
ATL_IMPL_THUNK(487)
ATL_IMPL_THUNK(488)
ATL_IMPL_THUNK(489)
ATL_IMPL_THUNK(490)
ATL_IMPL_THUNK(491)
ATL_IMPL_THUNK(492)
ATL_IMPL_THUNK(493)
ATL_IMPL_THUNK(494)
ATL_IMPL_THUNK(495)
ATL_IMPL_THUNK(496)
ATL_IMPL_THUNK(497)
ATL_IMPL_THUNK(498)
ATL_IMPL_THUNK(499)
ATL_IMPL_THUNK(500)
ATL_IMPL_THUNK(501)
ATL_IMPL_THUNK(502)
ATL_IMPL_THUNK(503)
ATL_IMPL_THUNK(504)
ATL_IMPL_THUNK(505)
ATL_IMPL_THUNK(506)
ATL_IMPL_THUNK(507)
ATL_IMPL_THUNK(508)
ATL_IMPL_THUNK(509)
ATL_IMPL_THUNK(510)
ATL_IMPL_THUNK(511)
ATL_IMPL_THUNK(512)
ATL_IMPL_THUNK(513)
ATL_IMPL_THUNK(514)
ATL_IMPL_THUNK(515)
ATL_IMPL_THUNK(516)
ATL_IMPL_THUNK(517)
ATL_IMPL_THUNK(518)
ATL_IMPL_THUNK(519)
ATL_IMPL_THUNK(520)
ATL_IMPL_THUNK(521)
ATL_IMPL_THUNK(522)
ATL_IMPL_THUNK(523)
ATL_IMPL_THUNK(524)
ATL_IMPL_THUNK(525)
ATL_IMPL_THUNK(526)
ATL_IMPL_THUNK(527)
ATL_IMPL_THUNK(528)
ATL_IMPL_THUNK(529)
ATL_IMPL_THUNK(530)
ATL_IMPL_THUNK(531)
ATL_IMPL_THUNK(532)
ATL_IMPL_THUNK(533)
ATL_IMPL_THUNK(534)
ATL_IMPL_THUNK(535)
ATL_IMPL_THUNK(536)
ATL_IMPL_THUNK(537)
ATL_IMPL_THUNK(538)
ATL_IMPL_THUNK(539)
ATL_IMPL_THUNK(540)
ATL_IMPL_THUNK(541)
ATL_IMPL_THUNK(542)
ATL_IMPL_THUNK(543)
ATL_IMPL_THUNK(544)
ATL_IMPL_THUNK(545)
ATL_IMPL_THUNK(546)
ATL_IMPL_THUNK(547)
ATL_IMPL_THUNK(548)
ATL_IMPL_THUNK(549)
ATL_IMPL_THUNK(550)
ATL_IMPL_THUNK(551)
ATL_IMPL_THUNK(552)
ATL_IMPL_THUNK(553)
ATL_IMPL_THUNK(554)
ATL_IMPL_THUNK(555)
ATL_IMPL_THUNK(556)
ATL_IMPL_THUNK(557)
ATL_IMPL_THUNK(558)
ATL_IMPL_THUNK(559)
ATL_IMPL_THUNK(560)
ATL_IMPL_THUNK(561)
ATL_IMPL_THUNK(562)
ATL_IMPL_THUNK(563)
ATL_IMPL_THUNK(564)
ATL_IMPL_THUNK(565)
ATL_IMPL_THUNK(566)
ATL_IMPL_THUNK(567)
ATL_IMPL_THUNK(568)
ATL_IMPL_THUNK(569)
ATL_IMPL_THUNK(570)
ATL_IMPL_THUNK(571)
ATL_IMPL_THUNK(572)
ATL_IMPL_THUNK(573)
ATL_IMPL_THUNK(574)
ATL_IMPL_THUNK(575)
ATL_IMPL_THUNK(576)
ATL_IMPL_THUNK(577)
ATL_IMPL_THUNK(578)
ATL_IMPL_THUNK(579)
ATL_IMPL_THUNK(580)
ATL_IMPL_THUNK(581)
ATL_IMPL_THUNK(582)
ATL_IMPL_THUNK(583)
ATL_IMPL_THUNK(584)
ATL_IMPL_THUNK(585)
ATL_IMPL_THUNK(586)
ATL_IMPL_THUNK(587)
ATL_IMPL_THUNK(588)
ATL_IMPL_THUNK(589)
ATL_IMPL_THUNK(590)
ATL_IMPL_THUNK(591)
ATL_IMPL_THUNK(592)
ATL_IMPL_THUNK(593)
ATL_IMPL_THUNK(594)
ATL_IMPL_THUNK(595)
ATL_IMPL_THUNK(596)
ATL_IMPL_THUNK(597)
ATL_IMPL_THUNK(598)
ATL_IMPL_THUNK(599)
ATL_IMPL_THUNK(600)
ATL_IMPL_THUNK(601)
ATL_IMPL_THUNK(602)
ATL_IMPL_THUNK(603)
ATL_IMPL_THUNK(604)
ATL_IMPL_THUNK(605)
ATL_IMPL_THUNK(606)
ATL_IMPL_THUNK(607)
ATL_IMPL_THUNK(608)
ATL_IMPL_THUNK(609)
ATL_IMPL_THUNK(610)
ATL_IMPL_THUNK(611)
ATL_IMPL_THUNK(612)
ATL_IMPL_THUNK(613)
ATL_IMPL_THUNK(614)
ATL_IMPL_THUNK(615)
ATL_IMPL_THUNK(616)
ATL_IMPL_THUNK(617)
ATL_IMPL_THUNK(618)
ATL_IMPL_THUNK(619)
ATL_IMPL_THUNK(620)
ATL_IMPL_THUNK(621)
ATL_IMPL_THUNK(622)
ATL_IMPL_THUNK(623)
ATL_IMPL_THUNK(624)
ATL_IMPL_THUNK(625)
ATL_IMPL_THUNK(626)
ATL_IMPL_THUNK(627)
ATL_IMPL_THUNK(628)
ATL_IMPL_THUNK(629)
ATL_IMPL_THUNK(630)
ATL_IMPL_THUNK(631)
ATL_IMPL_THUNK(632)
ATL_IMPL_THUNK(633)
ATL_IMPL_THUNK(634)
ATL_IMPL_THUNK(635)
ATL_IMPL_THUNK(636)
ATL_IMPL_THUNK(637)
ATL_IMPL_THUNK(638)
ATL_IMPL_THUNK(639)
ATL_IMPL_THUNK(640)
ATL_IMPL_THUNK(641)
ATL_IMPL_THUNK(642)
ATL_IMPL_THUNK(643)
ATL_IMPL_THUNK(644)
ATL_IMPL_THUNK(645)
ATL_IMPL_THUNK(646)
ATL_IMPL_THUNK(647)
ATL_IMPL_THUNK(648)
ATL_IMPL_THUNK(649)
ATL_IMPL_THUNK(650)
ATL_IMPL_THUNK(651)
ATL_IMPL_THUNK(652)
ATL_IMPL_THUNK(653)
ATL_IMPL_THUNK(654)
ATL_IMPL_THUNK(655)
ATL_IMPL_THUNK(656)
ATL_IMPL_THUNK(657)
ATL_IMPL_THUNK(658)
ATL_IMPL_THUNK(659)
ATL_IMPL_THUNK(660)
ATL_IMPL_THUNK(661)
ATL_IMPL_THUNK(662)
ATL_IMPL_THUNK(663)
ATL_IMPL_THUNK(664)
ATL_IMPL_THUNK(665)
ATL_IMPL_THUNK(666)
ATL_IMPL_THUNK(667)
ATL_IMPL_THUNK(668)
ATL_IMPL_THUNK(669)
ATL_IMPL_THUNK(670)
ATL_IMPL_THUNK(671)
ATL_IMPL_THUNK(672)
ATL_IMPL_THUNK(673)
ATL_IMPL_THUNK(674)
ATL_IMPL_THUNK(675)
ATL_IMPL_THUNK(676)
ATL_IMPL_THUNK(677)
ATL_IMPL_THUNK(678)
ATL_IMPL_THUNK(679)
ATL_IMPL_THUNK(680)
ATL_IMPL_THUNK(681)
ATL_IMPL_THUNK(682)
ATL_IMPL_THUNK(683)
ATL_IMPL_THUNK(684)
ATL_IMPL_THUNK(685)
ATL_IMPL_THUNK(686)
ATL_IMPL_THUNK(687)
ATL_IMPL_THUNK(688)
ATL_IMPL_THUNK(689)
ATL_IMPL_THUNK(690)
ATL_IMPL_THUNK(691)
ATL_IMPL_THUNK(692)
ATL_IMPL_THUNK(693)
ATL_IMPL_THUNK(694)
ATL_IMPL_THUNK(695)
ATL_IMPL_THUNK(696)
ATL_IMPL_THUNK(697)
ATL_IMPL_THUNK(698)
ATL_IMPL_THUNK(699)
ATL_IMPL_THUNK(700)
ATL_IMPL_THUNK(701)
ATL_IMPL_THUNK(702)
ATL_IMPL_THUNK(703)
ATL_IMPL_THUNK(704)
ATL_IMPL_THUNK(705)
ATL_IMPL_THUNK(706)
ATL_IMPL_THUNK(707)
ATL_IMPL_THUNK(708)
ATL_IMPL_THUNK(709)
ATL_IMPL_THUNK(710)
ATL_IMPL_THUNK(711)
ATL_IMPL_THUNK(712)
ATL_IMPL_THUNK(713)
ATL_IMPL_THUNK(714)
ATL_IMPL_THUNK(715)
ATL_IMPL_THUNK(716)
ATL_IMPL_THUNK(717)
ATL_IMPL_THUNK(718)
ATL_IMPL_THUNK(719)
ATL_IMPL_THUNK(720)
ATL_IMPL_THUNK(721)
ATL_IMPL_THUNK(722)
ATL_IMPL_THUNK(723)
ATL_IMPL_THUNK(724)
ATL_IMPL_THUNK(725)
ATL_IMPL_THUNK(726)
ATL_IMPL_THUNK(727)
ATL_IMPL_THUNK(728)
ATL_IMPL_THUNK(729)
ATL_IMPL_THUNK(730)
ATL_IMPL_THUNK(731)
ATL_IMPL_THUNK(732)
ATL_IMPL_THUNK(733)
ATL_IMPL_THUNK(734)
ATL_IMPL_THUNK(735)
ATL_IMPL_THUNK(736)
ATL_IMPL_THUNK(737)
ATL_IMPL_THUNK(738)
ATL_IMPL_THUNK(739)
ATL_IMPL_THUNK(740)
ATL_IMPL_THUNK(741)
ATL_IMPL_THUNK(742)
ATL_IMPL_THUNK(743)
ATL_IMPL_THUNK(744)
ATL_IMPL_THUNK(745)
ATL_IMPL_THUNK(746)
ATL_IMPL_THUNK(747)
ATL_IMPL_THUNK(748)
ATL_IMPL_THUNK(749)
ATL_IMPL_THUNK(750)
ATL_IMPL_THUNK(751)
ATL_IMPL_THUNK(752)
ATL_IMPL_THUNK(753)
ATL_IMPL_THUNK(754)
ATL_IMPL_THUNK(755)
ATL_IMPL_THUNK(756)
ATL_IMPL_THUNK(757)
ATL_IMPL_THUNK(758)
ATL_IMPL_THUNK(759)
ATL_IMPL_THUNK(760)
ATL_IMPL_THUNK(761)
ATL_IMPL_THUNK(762)
ATL_IMPL_THUNK(763)
ATL_IMPL_THUNK(764)
ATL_IMPL_THUNK(765)
ATL_IMPL_THUNK(766)
ATL_IMPL_THUNK(767)
ATL_IMPL_THUNK(768)
ATL_IMPL_THUNK(769)
ATL_IMPL_THUNK(770)
ATL_IMPL_THUNK(771)
ATL_IMPL_THUNK(772)
ATL_IMPL_THUNK(773)
ATL_IMPL_THUNK(774)
ATL_IMPL_THUNK(775)
ATL_IMPL_THUNK(776)
ATL_IMPL_THUNK(777)
ATL_IMPL_THUNK(778)
ATL_IMPL_THUNK(779)
ATL_IMPL_THUNK(780)
ATL_IMPL_THUNK(781)
ATL_IMPL_THUNK(782)
ATL_IMPL_THUNK(783)
ATL_IMPL_THUNK(784)
ATL_IMPL_THUNK(785)
ATL_IMPL_THUNK(786)
ATL_IMPL_THUNK(787)
ATL_IMPL_THUNK(788)
ATL_IMPL_THUNK(789)
ATL_IMPL_THUNK(790)
ATL_IMPL_THUNK(791)
ATL_IMPL_THUNK(792)
ATL_IMPL_THUNK(793)
ATL_IMPL_THUNK(794)
ATL_IMPL_THUNK(795)
ATL_IMPL_THUNK(796)
ATL_IMPL_THUNK(797)
ATL_IMPL_THUNK(798)
ATL_IMPL_THUNK(799)
ATL_IMPL_THUNK(800)
ATL_IMPL_THUNK(801)
ATL_IMPL_THUNK(802)
ATL_IMPL_THUNK(803)
ATL_IMPL_THUNK(804)
ATL_IMPL_THUNK(805)
ATL_IMPL_THUNK(806)
ATL_IMPL_THUNK(807)
ATL_IMPL_THUNK(808)
ATL_IMPL_THUNK(809)
ATL_IMPL_THUNK(810)
ATL_IMPL_THUNK(811)
ATL_IMPL_THUNK(812)
ATL_IMPL_THUNK(813)
ATL_IMPL_THUNK(814)
ATL_IMPL_THUNK(815)
ATL_IMPL_THUNK(816)
ATL_IMPL_THUNK(817)
ATL_IMPL_THUNK(818)
ATL_IMPL_THUNK(819)
ATL_IMPL_THUNK(820)
ATL_IMPL_THUNK(821)
ATL_IMPL_THUNK(822)
ATL_IMPL_THUNK(823)
ATL_IMPL_THUNK(824)
ATL_IMPL_THUNK(825)
ATL_IMPL_THUNK(826)
ATL_IMPL_THUNK(827)
ATL_IMPL_THUNK(828)
ATL_IMPL_THUNK(829)
ATL_IMPL_THUNK(830)
ATL_IMPL_THUNK(831)
ATL_IMPL_THUNK(832)
ATL_IMPL_THUNK(833)
ATL_IMPL_THUNK(834)
ATL_IMPL_THUNK(835)
ATL_IMPL_THUNK(836)
ATL_IMPL_THUNK(837)
ATL_IMPL_THUNK(838)
ATL_IMPL_THUNK(839)
ATL_IMPL_THUNK(840)
ATL_IMPL_THUNK(841)
ATL_IMPL_THUNK(842)
ATL_IMPL_THUNK(843)
ATL_IMPL_THUNK(844)
ATL_IMPL_THUNK(845)
ATL_IMPL_THUNK(846)
ATL_IMPL_THUNK(847)
ATL_IMPL_THUNK(848)
ATL_IMPL_THUNK(849)
ATL_IMPL_THUNK(850)
ATL_IMPL_THUNK(851)
ATL_IMPL_THUNK(852)
ATL_IMPL_THUNK(853)
ATL_IMPL_THUNK(854)
ATL_IMPL_THUNK(855)
ATL_IMPL_THUNK(856)
ATL_IMPL_THUNK(857)
ATL_IMPL_THUNK(858)
ATL_IMPL_THUNK(859)
ATL_IMPL_THUNK(860)
ATL_IMPL_THUNK(861)
ATL_IMPL_THUNK(862)
ATL_IMPL_THUNK(863)
ATL_IMPL_THUNK(864)
ATL_IMPL_THUNK(865)
ATL_IMPL_THUNK(866)
ATL_IMPL_THUNK(867)
ATL_IMPL_THUNK(868)
ATL_IMPL_THUNK(869)
ATL_IMPL_THUNK(870)
ATL_IMPL_THUNK(871)
ATL_IMPL_THUNK(872)
ATL_IMPL_THUNK(873)
ATL_IMPL_THUNK(874)
ATL_IMPL_THUNK(875)
ATL_IMPL_THUNK(876)
ATL_IMPL_THUNK(877)
ATL_IMPL_THUNK(878)
ATL_IMPL_THUNK(879)
ATL_IMPL_THUNK(880)
ATL_IMPL_THUNK(881)
ATL_IMPL_THUNK(882)
ATL_IMPL_THUNK(883)
ATL_IMPL_THUNK(884)
ATL_IMPL_THUNK(885)
ATL_IMPL_THUNK(886)
ATL_IMPL_THUNK(887)
ATL_IMPL_THUNK(888)
ATL_IMPL_THUNK(889)
ATL_IMPL_THUNK(890)
ATL_IMPL_THUNK(891)
ATL_IMPL_THUNK(892)
ATL_IMPL_THUNK(893)
ATL_IMPL_THUNK(894)
ATL_IMPL_THUNK(895)
ATL_IMPL_THUNK(896)
ATL_IMPL_THUNK(897)
ATL_IMPL_THUNK(898)
ATL_IMPL_THUNK(899)
ATL_IMPL_THUNK(900)
ATL_IMPL_THUNK(901)
ATL_IMPL_THUNK(902)
ATL_IMPL_THUNK(903)
ATL_IMPL_THUNK(904)
ATL_IMPL_THUNK(905)
ATL_IMPL_THUNK(906)
ATL_IMPL_THUNK(907)
ATL_IMPL_THUNK(908)
ATL_IMPL_THUNK(909)
ATL_IMPL_THUNK(910)
ATL_IMPL_THUNK(911)
ATL_IMPL_THUNK(912)
ATL_IMPL_THUNK(913)
ATL_IMPL_THUNK(914)
ATL_IMPL_THUNK(915)
ATL_IMPL_THUNK(916)
ATL_IMPL_THUNK(917)
ATL_IMPL_THUNK(918)
ATL_IMPL_THUNK(919)
ATL_IMPL_THUNK(920)
ATL_IMPL_THUNK(921)
ATL_IMPL_THUNK(922)
ATL_IMPL_THUNK(923)
ATL_IMPL_THUNK(924)
ATL_IMPL_THUNK(925)
ATL_IMPL_THUNK(926)
ATL_IMPL_THUNK(927)
ATL_IMPL_THUNK(928)
ATL_IMPL_THUNK(929)
ATL_IMPL_THUNK(930)
ATL_IMPL_THUNK(931)
ATL_IMPL_THUNK(932)
ATL_IMPL_THUNK(933)
ATL_IMPL_THUNK(934)
ATL_IMPL_THUNK(935)
ATL_IMPL_THUNK(936)
ATL_IMPL_THUNK(937)
ATL_IMPL_THUNK(938)
ATL_IMPL_THUNK(939)
ATL_IMPL_THUNK(940)
ATL_IMPL_THUNK(941)
ATL_IMPL_THUNK(942)
ATL_IMPL_THUNK(943)
ATL_IMPL_THUNK(944)
ATL_IMPL_THUNK(945)
ATL_IMPL_THUNK(946)
ATL_IMPL_THUNK(947)
ATL_IMPL_THUNK(948)
ATL_IMPL_THUNK(949)
ATL_IMPL_THUNK(950)
ATL_IMPL_THUNK(951)
ATL_IMPL_THUNK(952)
ATL_IMPL_THUNK(953)
ATL_IMPL_THUNK(954)
ATL_IMPL_THUNK(955)
ATL_IMPL_THUNK(956)
ATL_IMPL_THUNK(957)
ATL_IMPL_THUNK(958)
ATL_IMPL_THUNK(959)
ATL_IMPL_THUNK(960)
ATL_IMPL_THUNK(961)
ATL_IMPL_THUNK(962)
ATL_IMPL_THUNK(963)
ATL_IMPL_THUNK(964)
ATL_IMPL_THUNK(965)
ATL_IMPL_THUNK(966)
ATL_IMPL_THUNK(967)
ATL_IMPL_THUNK(968)
ATL_IMPL_THUNK(969)
ATL_IMPL_THUNK(970)
ATL_IMPL_THUNK(971)
ATL_IMPL_THUNK(972)
ATL_IMPL_THUNK(973)
ATL_IMPL_THUNK(974)
ATL_IMPL_THUNK(975)
ATL_IMPL_THUNK(976)
ATL_IMPL_THUNK(977)
ATL_IMPL_THUNK(978)
ATL_IMPL_THUNK(979)
ATL_IMPL_THUNK(980)
ATL_IMPL_THUNK(981)
ATL_IMPL_THUNK(982)
ATL_IMPL_THUNK(983)
ATL_IMPL_THUNK(984)
ATL_IMPL_THUNK(985)
ATL_IMPL_THUNK(986)
ATL_IMPL_THUNK(987)
ATL_IMPL_THUNK(988)
ATL_IMPL_THUNK(989)
ATL_IMPL_THUNK(990)
ATL_IMPL_THUNK(991)
ATL_IMPL_THUNK(992)
ATL_IMPL_THUNK(993)
ATL_IMPL_THUNK(994)
ATL_IMPL_THUNK(995)
ATL_IMPL_THUNK(996)
ATL_IMPL_THUNK(997)
ATL_IMPL_THUNK(998)
ATL_IMPL_THUNK(999)
ATL_IMPL_THUNK(1000)
ATL_IMPL_THUNK(1001)
ATL_IMPL_THUNK(1002)
ATL_IMPL_THUNK(1003)
ATL_IMPL_THUNK(1004)
ATL_IMPL_THUNK(1005)
ATL_IMPL_THUNK(1006)
ATL_IMPL_THUNK(1007)
ATL_IMPL_THUNK(1008)
ATL_IMPL_THUNK(1009)
ATL_IMPL_THUNK(1010)
ATL_IMPL_THUNK(1011)
ATL_IMPL_THUNK(1012)
ATL_IMPL_THUNK(1013)
ATL_IMPL_THUNK(1014)
ATL_IMPL_THUNK(1015)
ATL_IMPL_THUNK(1016)
ATL_IMPL_THUNK(1017)
ATL_IMPL_THUNK(1018)
ATL_IMPL_THUNK(1019)
ATL_IMPL_THUNK(1020)
ATL_IMPL_THUNK(1021)
ATL_IMPL_THUNK(1022)
ATL_IMPL_THUNK(1023)

#endif	// _M_IX86

};  // namespace ATL
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\src\atl\atls\atlimage.cpp ===
// This is a part of the Active Template Library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Active Template Library Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the	
// Active Template Library product.

#include "StdAfx.H"

#pragma warning( disable: 4073 )  // initializers put in library initialization area

namespace ATL
{

#pragma init_seg( lib )

CImage::CDCCache CImage::s_cache;

};  // namespace ATL
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\src\atl\atls\atlimage2.cpp ===
// This is a part of the Active Template Library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Active Template Library Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the	
// Active Template Library product.

#include "StdAfx.H"

#pragma warning( disable: 4073 )  // initializers put in library initialization area

namespace ATL
{

#pragma init_seg( lib )

CImage::CInitGDIPlus CImage::s_initGDIPlus;

};  // namespace ATL
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\src\atl\atls\atlmem.cpp ===
// This is a part of the Active Template Library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Active Template Library Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the	
// Active Template Library product.

#include "StdAfx.H"

#pragma warning( disable: 4073 )  // initializers put in library initialization area

namespace ATL
{

#pragma init_seg( lib )

CCRTHeap g_heapCRT;

};  // namespace ATL
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\src\atl\atls\AtlDebugAPI.cpp ===
// This is a part of the Active Template Library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Active Template Library Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Active Template Library product.

#include "StdAfx.h"

#include "Common.h"
#include "AtlTraceModuleManager.h"
#include "sal.h"

namespace ATL
{
static bool WINAPI ShouldTraceOutput(
	_In_ DWORD_PTR dwModule,
	_In_ DWORD_PTR dwCategory,
	_In_ UINT nLevel,
	_Deref_out_opt_ const CAtlTraceCategory **ppCategory,
	_Deref_out_opt_ CAtlTraceModule::fnCrtDbgReport_t *pfnCrtDbgReport);

void WINAPI NotifyTool()
{
	HANDLE hEvent;
	hEvent = OpenEventA(EVENT_MODIFY_STATE, FALSE, g_pszUpdateEventName);

	if(hEvent)
	{
		SetEvent(hEvent);
		CloseHandle(hEvent);
	}
}

// API
DWORD_PTR __stdcall AtlTraceRegister(
	_In_ HINSTANCE hInst,
	_In_opt_ int (__cdecl *fnCrtDbgReport)(
		_In_ int,
		_In_z_ const char *,
		_In_ int,
		_In_z_ const char *,
		_In_z_ const char *,...))
{
	int iModule = g_Allocator.AddModule(hInst);
	CAtlTraceModule* pModule = g_Allocator.GetModule(iModule);
	ATLASSERT(pModule != NULL);
	if(pModule != NULL)
	{
		pModule->CrtDbgReport(fnCrtDbgReport);
		NotifyTool();
	}

	return( DWORD_PTR( iModule )+1 );
}

BOOL __stdcall AtlTraceUnregister(_In_ DWORD_PTR dwModule)
{
	int iModule = int( dwModule-1 );
	g_Allocator.RemoveModule( iModule );

	NotifyTool();

	return TRUE;
}

DWORD_PTR __stdcall AtlTraceRegisterCategoryA(
	_In_ DWORD_PTR dwModule,
	_In_z_count_c_(ATL_TRACE_MAX_NAME_SIZE) const CHAR szCategoryName[ATL_TRACE_MAX_NAME_SIZE])
{
	if( szCategoryName == NULL )
	{
		return 0;
	}
	return AtlTraceRegisterCategoryU(dwModule, CA2W(szCategoryName));
}

DWORD_PTR __stdcall AtlTraceRegisterCategoryU(
	_In_ DWORD_PTR dwModule,
	_In_z_count_c_(ATL_TRACE_MAX_NAME_SIZE) const WCHAR szCategoryName[ATL_TRACE_MAX_NAME_SIZE])
{
	if( szCategoryName == NULL )
		return 0;

	int iModule = int( dwModule-1 );

	int iCategory = g_Allocator.AddCategory(iModule, szCategoryName);
	NotifyTool();

	return( DWORD_PTR( iCategory )+1 );
}

BOOL __stdcall AtlTraceModifyProcess(
	_In_ DWORD_PTR dwProcess,
	_In_ UINT nLevel,
	_In_ BOOL bEnabled,
	_In_ BOOL bFuncAndCategoryNames,
	_In_ BOOL bFileNameAndLineNo)
{
	CAtlAllocator* pAllocator = reinterpret_cast< CAtlAllocator* >( dwProcess );
#ifdef _DEBUG
	if( pAllocator == NULL )
	{
		pAllocator = &g_Allocator;
	}
#endif  // _DEBUG

	CAtlTraceProcess* pProcess = pAllocator->GetProcess();
	ATLASSERT(pProcess != NULL);
	if(pProcess != NULL)
	{
		pProcess->m_nLevel = nLevel;
		pProcess->m_bEnabled = 0 != bEnabled;
		pProcess->m_bFuncAndCategoryNames = 0 != bFuncAndCategoryNames;
		pProcess->m_bFileNameAndLineNo = 0 != bFileNameAndLineNo;
	}

	return( TRUE );
}

BOOL __stdcall AtlTraceModifyModule(
	_In_ DWORD_PTR dwProcess,
	_In_ DWORD_PTR dwModule,
	_In_ UINT nLevel,
	_In_ ATLTRACESTATUS eStatus)
{
	CAtlAllocator* pAllocator = reinterpret_cast< CAtlAllocator* >( dwProcess );
#ifdef _DEBUG
	if( pAllocator == NULL )
	{
		pAllocator = &g_Allocator;
	}
#endif  // _DEBUG

	int iModule = int( dwModule-1 );

	CAtlTraceModule* pModule = pAllocator->GetModule(iModule);
	ATLASSERT(pModule != NULL);
	if(pModule != NULL)
	{
		switch(eStatus)
		{
		case ATLTRACESTATUS_INHERIT:
			pModule->m_eStatus = CAtlTraceSettings::Inherit;
			break;
		case ATLTRACESTATUS_ENABLED:
			pModule->m_eStatus = CAtlTraceSettings::Enabled;
			break;
		case ATLTRACESTATUS_DISABLED:
			pModule->m_eStatus = CAtlTraceSettings::Disabled;
			break;
		default:
			ATLASSERT( false );
			break;
		}
		pModule->m_nLevel = nLevel;
	}

	return( TRUE );
}

BOOL __stdcall AtlTraceModifyCategory(
	_In_ DWORD_PTR dwProcess,
	_In_ DWORD_PTR dwCategory,
	_In_ UINT nLevel,
	_In_ ATLTRACESTATUS eStatus)
{
	CAtlAllocator* pAllocator = reinterpret_cast< CAtlAllocator* >( dwProcess );
#ifdef _DEBUG
	if( pAllocator == NULL )
	{
		pAllocator = &g_Allocator;
	}
#endif  // _DEBUG

	int iCategory = int( dwCategory-1 );
	CAtlTraceCategory *pCategory = pAllocator->GetCategory(iCategory);
	if(pCategory != NULL)
	{
		switch(eStatus)
		{
		case ATLTRACESTATUS_INHERIT:
			pCategory->m_eStatus = CAtlTraceSettings::Inherit;
			break;
		case ATLTRACESTATUS_ENABLED:
			pCategory->m_eStatus = CAtlTraceSettings::Enabled;
			break;
		case ATLTRACESTATUS_DISABLED:
			pCategory->m_eStatus = CAtlTraceSettings::Disabled;
			break;
		default:
			ATLASSERT(false);
			break;
		}
		pCategory->m_nLevel = nLevel;
	}
	return TRUE;
}

BOOL __stdcall AtlTraceGetProcess(
	_In_ DWORD_PTR dwProcess,
	_Out_opt_ UINT *pnLevel,
	_Out_opt_ BOOL *pbEnabled,
	_Out_opt_ BOOL *pbFuncAndCategoryNames,
	_Out_opt_ BOOL *pbFileNameAndLineNo)
{
	CAtlAllocator* pAllocator = reinterpret_cast< CAtlAllocator* >( dwProcess );
#ifdef _DEBUG
	if( pAllocator == NULL )
	{
		pAllocator = &g_Allocator;
	}
#endif  // _DEBUG

	CAtlTraceProcess* pProcess = pAllocator->GetProcess();
	ATLENSURE(pProcess != NULL);

	if(pnLevel)
		*pnLevel = pProcess->m_nLevel;
	if(pbEnabled)
		*pbEnabled = pProcess->m_bEnabled;
	if(pbFuncAndCategoryNames)
		*pbFuncAndCategoryNames = pProcess->m_bFuncAndCategoryNames;
	if(pbFileNameAndLineNo)
		*pbFileNameAndLineNo = pProcess->m_bFileNameAndLineNo;

	return( TRUE );
}

BOOL __stdcall AtlTraceGetModule(
	_In_ DWORD_PTR dwProcess,
	_In_ DWORD_PTR dwModule,
	_Out_opt_ UINT *pnLevel,
	_Out_opt_ ATLTRACESTATUS *peStatus)
{
	CAtlAllocator* pAllocator = reinterpret_cast< CAtlAllocator* >( dwProcess );
#ifdef _DEBUG
	if( pAllocator == NULL )
	{
		pAllocator = &g_Allocator;
	}
#endif  // _DEBUG

	int iModule = int( dwModule-1 );
	CAtlTraceModule *pModule = pAllocator->GetModule(iModule);
	ATLENSURE(pModule != NULL);

	if(pnLevel != NULL)
	{
		*pnLevel = pModule->m_nLevel;
	}

	if(peStatus != NULL)
	{
		switch(pModule->m_eStatus)
		{
		case CAtlTraceSettings::Inherit:
			*peStatus = ATLTRACESTATUS_INHERIT;
			break;
		case CAtlTraceSettings::Enabled:
			*peStatus = ATLTRACESTATUS_ENABLED;
			break;
		case CAtlTraceSettings::Disabled:
			*peStatus = ATLTRACESTATUS_DISABLED;
			break;
		default:
			ATLASSERT(false);
			break;
		}
	}

	return TRUE;
}

BOOL __stdcall AtlTraceGetCategory(
	_In_ DWORD_PTR dwProcess,
	_In_ DWORD_PTR dwCategory,
	_Out_opt_ UINT *pnLevel,
	_Out_opt_ ATLTRACESTATUS *peStatus)
{
	CAtlAllocator* pAllocator = reinterpret_cast< CAtlAllocator* >( dwProcess );
#ifdef _DEBUG
	if( pAllocator == NULL )
	{
		pAllocator = &g_Allocator;
	}
#endif  // _DEBUG

	int iCategory = int( dwCategory-1 );
	CAtlTraceCategory* pCategory = pAllocator->GetCategory( iCategory );
	ATLENSURE(pCategory != NULL);

	if(pnLevel != NULL)
	{
		*pnLevel = pCategory->m_nLevel;
	}

	if(peStatus != NULL)
	{
		switch(pCategory->m_eStatus)
		{
		case CAtlTraceSettings::Inherit:
			*peStatus = ATLTRACESTATUS_INHERIT;
			break;
		case CAtlTraceSettings::Enabled:
			*peStatus = ATLTRACESTATUS_ENABLED;
			break;
		case CAtlTraceSettings::Disabled:
			*peStatus = ATLTRACESTATUS_DISABLED;
			break;
		}
	}

	return( TRUE );
}

void __stdcall AtlTraceGetUpdateEventNameA(_Inout_z_ CHAR *pszEventName)
{
	if( g_pszUpdateEventName == NULL || pszEventName == NULL )
	{
		return;
	}
#pragma warning(push)
#pragma warning(disable:4996)
	// This API is deprecated because the size of the buffer cannot be
	// known. Therefore, we have to use unsafe version of strcpy. The
	// warning is disabled to prevent build problems.
	strcpy(pszEventName, g_pszUpdateEventName);
#pragma warning(pop)
}

void __stdcall AtlTraceGetUpdateEventNameA_s(
	_Out_z_cap_(cchEventName) CHAR *pszEventName,
	_In_ size_t cchEventName)
{
	if( g_pszUpdateEventName == NULL || pszEventName == NULL )
	{
		return;
	}
	Checked::strcpy_s(pszEventName, cchEventName, g_pszUpdateEventName);
}

void __stdcall AtlTraceGetUpdateEventNameU(_Inout_z_ WCHAR *pszEventName)
{
	if( g_pszUpdateEventName == NULL || pszEventName == NULL )
	{
		return;
	}
#pragma warning(push)
#pragma warning(disable:4996)
	// This API is deprecated because the size of the buffer cannot be
	// known. Therefore, we have to use unsafe version of wcscpy. The
	// warning is disabled to prevent build problems.
	wcscpy(pszEventName, CA2W(g_pszUpdateEventName));
#pragma warning(pop)
}

void __stdcall AtlTraceGetUpdateEventNameU_s(
	_Out_z_cap_(cchEventName) WCHAR *pszEventName,
	_In_ size_t cchEventName)
{
	if( g_pszUpdateEventName == NULL || pszEventName == NULL )
	{
		return;
	}
	Checked::wcscpy_s(pszEventName, cchEventName, CA2W(g_pszUpdateEventName));
}

void __cdecl AtlTraceVA(
	_In_ DWORD_PTR dwModule,
	_In_opt_z_ const char *pszFileName,
	_In_ int nLine,
	_In_ DWORD_PTR dwCategory,
	_In_ UINT nLevel,
	_In_z_ _Printf_format_string_ const CHAR *pszFormat, 
	_In_ va_list ptr)
{
	const CAtlTraceCategory *pCategory;
	CAtlTraceModule::fnCrtDbgReport_t pfnCrtDbgReport = NULL;
	static const int nCount = 1024;
	CHAR szBuf[nCount] = {'\0'};
	int nLen = 0;

	if(ShouldTraceOutput(dwModule, dwCategory, nLevel, &pCategory, &pfnCrtDbgReport))
	{
		if (nLen >= 0 && nLen < nCount)
                {
                        if(g_Allocator.GetProcess()->m_bFileNameAndLineNo)
		        {
			        int nTemp;
			        ATL_CRT_ERRORCHECK_SPRINTF(nTemp = _snprintf_s(szBuf + nLen, nCount - nLen, nCount - nLen - 1, "%s(%d) : ", pszFileName, nLine));
			        if( nTemp < 0 )
				        nLen = nCount;
			        else
				        nLen += nTemp;
		        }
                }
		if (nLen >= 0 && nLen < nCount)
                {
		        if(pCategory && g_Allocator.GetProcess()->m_bFuncAndCategoryNames)
		        {
			        int nTemp;
			        ATL_CRT_ERRORCHECK_SPRINTF(nTemp = _snprintf_s(szBuf + nLen, nCount - nLen, nCount - nLen - 1, "%S: ", pCategory->Name()));
			        if( nTemp < 0 )
				        nLen = nCount;
			        else
				        nLen += nTemp;
		        }
                }
		if (nLen >= 0 && nLen < nCount)
		{
			ATL_CRT_ERRORCHECK_SPRINTF(_vsnprintf_s(szBuf + nLen, nCount - nLen, nCount - nLen - 1, pszFormat, ptr));
		}

		if(pfnCrtDbgReport != NULL)
			pfnCrtDbgReport(_CRT_WARN, NULL, 0, NULL, "%s", szBuf);
		else
			OutputDebugStringA(szBuf);
	}
}

void __cdecl AtlTraceVU(
	_In_ DWORD_PTR dwModule,
	_In_opt_z_ const char *pszFileName,
	_In_ int nLine,
	_In_ DWORD_PTR dwCategory,
	_In_ UINT nLevel,
	_In_z_ _Printf_format_string_ const WCHAR *pszFormat, 
	_In_ va_list ptr)
{
	const CAtlTraceCategory *pCategory;
	CAtlTraceModule::fnCrtDbgReport_t pfnCrtDbgReport = NULL;
	const int nCount = 1024;
	WCHAR szBuf[nCount] = {L'\0'};
	int nLen = 0;

	if(ShouldTraceOutput(dwModule, dwCategory, nLevel, &pCategory, &pfnCrtDbgReport))
	{
		if (nLen >= 0 && nLen < nCount)
                {
                        if(g_Allocator.GetProcess()->m_bFileNameAndLineNo && nLen < nCount && nLen >= 0)
		        {
			        int nTemp;
			        ATL_CRT_ERRORCHECK_SPRINTF(nTemp = _snwprintf_s(szBuf + nLen, nCount - nLen, nCount - nLen - 1, L"%S(%d) : ", pszFileName, nLine));
			        if( nTemp < 0 )
				        nLen = nCount;
			        else
				        nLen += nTemp;
		        }
                }
		if (nLen >= 0 && nLen < nCount)
                {
                        if(pCategory && g_Allocator.GetProcess()->m_bFuncAndCategoryNames)
		        {
			        int nTemp;
			        ATL_CRT_ERRORCHECK_SPRINTF(nTemp = _snwprintf_s(szBuf + nLen, nCount - nLen, nCount - nLen - 1, L"%s: ", pCategory->Name()));
			        if( nTemp < 0 )
				        nLen = nCount;
			        else
				        nLen += nTemp;
		        }

                }
		if (nLen >= 0 && nLen < nCount)
		{
			ATL_CRT_ERRORCHECK_SPRINTF(_vsnwprintf_s(szBuf + nLen, nCount - nLen, nCount - nLen - 1, pszFormat, ptr));
		}

		if(pfnCrtDbgReport)
			pfnCrtDbgReport(_CRT_WARN, NULL, 0, NULL, "%S", szBuf);
		else
			OutputDebugStringW(szBuf);
	}
}

DWORD_PTR __stdcall AtlTraceOpenProcess(_In_ DWORD idProcess)
{
	CAtlAllocator* pAllocator = new CAtlAllocator;

	char szBuf[64];
	ATL_CRT_ERRORCHECK_SPRINTF(_snprintf_s(szBuf, _countof(szBuf), _countof(szBuf) - 1, g_pszKernelObjFmt, g_pszAllocFileMapName, idProcess));
	if( !pAllocator->Open(szBuf) )
	{
		delete pAllocator;
		return( 0 );
	}

	return( reinterpret_cast< DWORD_PTR >( pAllocator ) );
}

void __stdcall AtlTraceCloseProcess(_In_ DWORD_PTR dwProcess)
{
	ATLENSURE(dwProcess!=0);

	CAtlAllocator* pAllocator = reinterpret_cast< CAtlAllocator* >( dwProcess );
	pAllocator->Close( true );
	delete pAllocator;
}

void __stdcall AtlTraceSnapshotProcess(_In_ DWORD_PTR dwProcess)
{
	ATLENSURE(dwProcess!=0);

	CAtlAllocator* pAllocator = reinterpret_cast< CAtlAllocator* >( dwProcess );
	pAllocator->TakeSnapshot();
}

BOOL __stdcall AtlTraceGetProcessInfo(
	_In_ DWORD_PTR dwProcess,
	_Out_ ATLTRACEPROCESSINFO* pProcessInfo)
{
	ATLENSURE(dwProcess!=0);
	ATLASSERT(pProcessInfo != NULL);

	CAtlAllocator* pAllocator = reinterpret_cast< CAtlAllocator* >( dwProcess );
	ATLASSERT(pAllocator->m_bSnapshot);
	CAtlTraceProcess *pProcess = pAllocator->GetProcess();
	ATLASSERT(pProcess != NULL);

	if(pProcess)
	{
		wcsncpy_s(pProcessInfo->szName, _countof(pProcessInfo->szName), pProcess->Name(), _TRUNCATE);
		wcscpy_s(pProcessInfo->szPath, _countof(pProcessInfo->szPath), pProcess->Path());
		pProcessInfo->dwId = pProcess->Id();
		pProcessInfo->settings.nLevel = pProcess->m_nLevel;
		pProcessInfo->settings.bEnabled = pProcess->m_bEnabled;
		pProcessInfo->settings.bFuncAndCategoryNames = pProcess->m_bFuncAndCategoryNames;
		pProcessInfo->settings.bFileNameAndLineNo = pProcess->m_bFileNameAndLineNo;
		pProcessInfo->nModules = pAllocator->m_snapshot.m_aModules.GetSize();
	}
	return( TRUE );
}

void __stdcall AtlTraceGetModuleInfo(
	_In_ DWORD_PTR dwProcess,
	_In_ int iModule,
	_Out_ ATLTRACEMODULEINFO* pModuleInfo)
{
	ATLENSURE(dwProcess!=0);
	ATLASSERT(pModuleInfo != NULL);
	if( pModuleInfo == NULL )
		return;

	CAtlAllocator* pAllocator = reinterpret_cast< CAtlAllocator* >( dwProcess );
	ATLASSERT(pAllocator->m_bSnapshot);

	DWORD_PTR dwModule = pAllocator->m_snapshot.m_aModules[iModule].m_dwModule;
	CAtlTraceModule* pModule = pAllocator->GetModule(int(dwModule-1));
	if( pModule == NULL )
		return;

	wcsncpy_s(pModuleInfo->szName, _countof(pModuleInfo->szName), pModule->Name(), _TRUNCATE);
	wcsncpy_s(pModuleInfo->szPath, _countof(pModuleInfo->szPath), pModule->Path(), _TRUNCATE);
	pModuleInfo->nCategories = pModule->m_nCategories;
	pModuleInfo->settings.nLevel = pModule->m_nLevel;
	pModuleInfo->dwModule = dwModule;
	switch(pModule->m_eStatus)
	{
	default:
	case CAtlTraceSettings::Inherit:
		pModuleInfo->settings.eStatus = ATLTRACESTATUS_INHERIT;
		break;
	case CAtlTraceSettings::Enabled:
		pModuleInfo->settings.eStatus = ATLTRACESTATUS_ENABLED;
		break;
	case CAtlTraceSettings::Disabled:
		pModuleInfo->settings.eStatus = ATLTRACESTATUS_DISABLED;
		break;
	}
}

void __stdcall AtlTraceGetCategoryInfo(
	_In_ DWORD_PTR dwProcess,
	_In_ DWORD_PTR dwModule,
	_In_ int iCategory,
	_Out_ ATLTRACECATEGORYINFO* pCategoryInfo)
{
	ATLENSURE(dwProcess!=0);
	ATLASSERT(pCategoryInfo != NULL);

	CAtlAllocator* pAllocator = reinterpret_cast< CAtlAllocator* >( dwProcess );
	ATLASSERT(pAllocator->m_bSnapshot);

	int iModule = int( dwModule-1 );
	CAtlTraceModule* pModule = pAllocator->GetModule( iModule );
	if( pModule == NULL )
		return;

	CAtlTraceCategory* pCategory = pAllocator->GetCategory( pModule->m_iFirstCategory );

	int nCategory = pModule->m_iFirstCategory;
	for( int iCategoryIndex = 0; iCategoryIndex < iCategory; iCategoryIndex++ )
	{
		if( pCategory == NULL )
			return;
		nCategory = pCategory->m_iNextCategory;
		pCategory = pAllocator->GetCategory( pCategory->m_iNextCategory );
	}

	if( pCategory == NULL )
		return;

	wcsncpy_s(pCategoryInfo->szName, _countof(pCategoryInfo->szName), pCategory->Name(), _TRUNCATE);
	pCategoryInfo->settings.nLevel = pCategory->m_nLevel;
	pCategoryInfo->dwCategory = DWORD_PTR( nCategory )+1;
	switch(pCategory->m_eStatus)
	{
	case CAtlTraceSettings::Inherit:
		pCategoryInfo->settings.eStatus = ATLTRACESTATUS_INHERIT;
		break;
	case CAtlTraceSettings::Enabled:
		pCategoryInfo->settings.eStatus = ATLTRACESTATUS_ENABLED;
		break;
	case CAtlTraceSettings::Disabled:
		pCategoryInfo->settings.eStatus = ATLTRACESTATUS_DISABLED;
		break;
	default:
		ATLASSERT( false );
		break;
	}
}

static bool WINAPI ShouldTraceOutput(
	_In_ DWORD_PTR dwModule,
	_In_ DWORD_PTR dwCategory,
	_In_ UINT nLevel,
	_Deref_out_opt_ const CAtlTraceCategory **ppCategory,
	_Deref_out_opt_ CAtlTraceModule::fnCrtDbgReport_t *pfnCrtDbgReport)
{
	bool bFound = false;

	ATLASSERT(ppCategory && pfnCrtDbgReport);
	*ppCategory = NULL;
	*pfnCrtDbgReport = NULL;

	CAtlTraceProcess *pProcess = g_Allocator.GetProcess();
	ATLASSERT(pProcess);
	CAtlTraceModule *pModule = g_Allocator.GetModule( int( dwModule-1 ) );

	ATLASSERT(pModule != NULL);
	if(pModule != NULL)
	{
		*pfnCrtDbgReport = pModule->CrtDbgReport();

		CAtlTraceCategory *pCategory = g_Allocator.GetCategory( int( dwCategory-1 ) );
		if( pCategory != NULL )
		{
			bFound = true;
			bool bOut = false;

			if(pProcess->m_bEnabled &&
				pModule->m_eStatus == CAtlTraceSettings::Inherit &&
				pCategory->m_eStatus == CAtlTraceSettings::Inherit &&
				nLevel <= pProcess->m_nLevel)
			{
				bOut = true;
			}
			else if(pModule->m_eStatus == CAtlTraceSettings::Enabled &&
				pCategory->m_eStatus == CAtlTraceSettings::Inherit &&
				nLevel <= pModule->m_nLevel)
			{
				bOut = true;
			}
			else if(pCategory->m_eStatus == CAtlTraceSettings::Enabled &&
				nLevel <= pCategory->m_nLevel)
			{
				bOut = true;
			}

			if(bOut)
			{
				*ppCategory = pProcess->m_bFuncAndCategoryNames ? pCategory : NULL;
				return true;
			}
		}
	}

	return false;
}

bool _IsTracingEnabled(
	_In_ DWORD_PTR dwModule,
	_In_ DWORD_PTR dwCategory,
	_In_ UINT nLevel)
{
	const CAtlTraceCategory *pCategory = NULL;
	CAtlTraceModule::fnCrtDbgReport_t pfnCrtDbgReport = NULL;

	return(ShouldTraceOutput(dwModule, dwCategory, nLevel, &pCategory, &pfnCrtDbgReport));
}

};  // namespace ATL
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\src\atl\atls\atltime.cpp ===
// This is a part of the Active Template Library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Active Template Library Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the	
// Active Template Library product.

#include "stdafx.h"

#ifdef _DEBUG
#define ATLTIME_INLINE 
#include <atltime.inl>

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\src\atl\atls\atlstr.cpp ===
// This is a part of the Active Template Library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Active Template Library Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the	
// Active Template Library product.

#include "StdAfx.H"

#pragma warning( disable: 4073 )  // initializers put in library initialization area

namespace ATL
{

#pragma init_seg( lib )

CWin32Heap g_strheap( ::GetProcessHeap() );
CAtlStringMgr g_strmgr( &g_strheap );

};  // namespace ATL
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\src\atl\atls\atltrace.cpp ===
// This is a part of the Active Template Library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Active Template Library Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the	
// Active Template Library product.

#include "StdAfx.H"

#pragma warning( disable: 4073 )  // initializers put in library initialization area

namespace ATL
{

#pragma init_seg( lib )

#ifdef _DEBUG

CTraceCategory atlTraceGeneral("atlTraceGeneral");
CTraceCategory atlTraceCOM("atlTraceCOM");  
CTraceCategory atlTraceQI("atlTraceQI");	
CTraceCategory atlTraceRegistrar("atlTraceRegistrar");
CTraceCategory atlTraceRefcount("atlTraceRefcount");
CTraceCategory atlTraceWindowing("atlTraceWindowing");
CTraceCategory atlTraceControls("atlTraceControls");
CTraceCategory atlTraceHosting("atlTraceHosting"); 
CTraceCategory atlTraceDBClient("atlTraceDBClient");  
CTraceCategory atlTraceDBProvider("atlTraceDBProvider");
CTraceCategory atlTraceSnapin("atlTraceSnapin");
CTraceCategory atlTraceNotImpl("atlTraceNotImpl");   
CTraceCategory atlTraceAllocation("atlTraceAllocation");
CTraceCategory atlTraceException("atlTraceException");
CTraceCategory atlTraceTime("atlTraceTime");
CTraceCategory atlTraceCache("atlTraceCache");
CTraceCategory atlTraceStencil("atlTraceStencil");
CTraceCategory atlTraceString("atlTraceString");
CTraceCategory atlTraceMap("atlTraceMap");	
CTraceCategory atlTraceUtil("atlTraceUtil");		
CTraceCategory atlTraceSecurity("atlTraceSecurity");
CTraceCategory atlTraceSync("atlTraceSync");
CTraceCategory atlTraceISAPI("atlTraceISAPI");		

#pragma warning( disable: 4995 )  // Ignore #pragma deprecated warnings
CTraceCategory atlTraceUser("atlTraceUser");		
CTraceCategory atlTraceUser2("atlTraceUser2");		
CTraceCategory atlTraceUser3("atlTraceUser3");		
CTraceCategory atlTraceUser4("atlTraceUser4");		

#endif

};  // namespace ATL
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\src\atl\atls\atlwinmodule.cpp ===
// This is a part of the Active Template Library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Active Template Library Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the	
// Active Template Library product.

#include "StdAfx.H"

#pragma warning( disable: 4073 )  // initializers put in library initialization area

namespace ATL
{
#pragma init_seg( lib )
CAtlWinModule _AtlWinModule;

};  // namespace ATL
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\src\atl\atls\atltypes.cpp ===
// This is a part of the Active Template Library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Active Template Library Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the	
// Active Template Library product.

#include "StdAfx.H"

#ifdef _DEBUG
#define ATLTYPES_INLINE
#include <atltypes.inl>
#endif	// _DEBUG
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\src\atl\atls\Common.h ===
// This is a part of the Active Template Library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Active Template Library Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the	
// Active Template Library product.

extern const char *g_pszUpdateEventName;
extern const char *g_pszLockMutexName;
extern const char *g_pszLockEventName;
extern const char *g_pszAllocFileMapName;
extern const char *g_pszAllocMutexName;

extern const char *g_pszKernelObjFmt;

extern const wchar_t *g_pszProcessObject;
extern const wchar_t *g_pszReadsInProgress;

extern class CAtlAllocator g_Allocator;
extern class CAtlTraceLock g_Lock;
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\src\atl\atls\AtlTraceModuleManager.cpp ===
// This is a part of the Active Template Library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Active Template Library Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Active Template Library product.

#include "stdafx.h"
#include "Common.h"
#include "AtlTraceModuleManager.h"

extern HINSTANCE g_hInst;

CAtlTraceModuleInfo::CAtlTraceModuleInfo() :
	m_hInst(NULL),
	m_nCategories(0),
	m_iFirstCategory(-1)
{
	m_szPath[0] = L'\0';
	m_szName[0] = L'\0';
}

void CAtlTraceModuleInfo::Reset(_In_ HINSTANCE hInst)
{
	WCHAR szModulePath[MAX_PATH] = {L'\0'};

	GetModuleFileNameW(hInst, szModulePath, MAX_PATH);

	szModulePath[MAX_PATH - 1] = 0;

	ATL_CRT_ERRORCHECK(wcsncpy_s(m_szPath, _countof(m_szPath), szModulePath, _TRUNCATE));
	WCHAR *pszShortName = m_szPath + wcslen(m_szPath);
	while(pszShortName > m_szPath && *(pszShortName - 1) != L'\\')
		pszShortName--;
	ATL_CRT_ERRORCHECK(wcsncpy_s(m_szName, _countof(m_szName), pszShortName, ATL_TRACE_MAX_NAME_SIZE - 1));

	m_hInst = hInst;
	m_nCategories = 0;
	m_iFirstCategory = -1;
}

// Categories
CAtlTraceCategory::CAtlTraceCategory() :
	m_nModuleCookie(0),
	m_iNextCategory(-1)
{
	Reset(L"", 0);
}

void CAtlTraceCategory::Reset(
	_In_z_ const WCHAR *pszName,
	_In_ LONG nModuleCookie)
{
	ATL_CRT_ERRORCHECK(wcsncpy_s(m_szName, _countof(m_szName), pszName, wcslen(pszName)));
	m_nModuleCookie = nModuleCookie;
	m_iNextCategory = -1;
}

// Modules
CAtlTraceModule::CAtlTraceModule() :
	m_pfnCrtDbgReport(NULL)
{
}

void CAtlTraceModule::CrtDbgReport(
	_In_opt_ CAtlTraceModule::fnCrtDbgReport_t pfnCrtDbgReport)
{
#ifdef _DEBUG
	m_pfnCrtDbgReport = pfnCrtDbgReport ? pfnCrtDbgReport : _CrtDbgReport;
#else
	m_pfnCrtDbgReport = pfnCrtDbgReport ? pfnCrtDbgReport : NULL;
#endif
}

// Processes
CAtlTraceProcess::CAtlTraceProcess(_In_ DWORD_PTR dwMaxSize) :
	CAtlTraceModuleInfo(),
	m_dwId(GetCurrentProcessId()), m_nRef(1), m_dwMaxSize(dwMaxSize),
	m_dwFrontAlloc(0), m_dwBackAlloc(0), m_dwCurrFront(0), m_dwCurrBack(0),
	m_nLevel(0), m_bLoaded(false), m_bEnabled(true), m_bFuncAndCategoryNames(false), m_bFileNameAndLineNo(false),
	m_nNextCookie( 0 )
{
	m_pvBase = this;

	Reset( NULL );
}

LONG CAtlTraceProcess::GetNextCookie()
{
	return( ::InterlockedIncrement( &m_nNextCookie ) );
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\src\atl\atls\stdafx.cpp ===
// This is a part of the Active Template Library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Active Template Library Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the	
// Active Template Library product.

#include "StdAfx.H"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\src\atl\atls\AtlTraceModuleManager.h ===
// This is a part of the Active Template Library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Active Template Library Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Active Template Library product.

#ifndef ATLDEBUG_TRACE_MANAGER
#define ATLDEBUG_TRACE_MANAGER

#include "Allocate.h"

//
// if you make changes to those classes look at file mappings in Externs.cpp
//

// Names
class CAtlTraceModuleInfo
{
public:
	explicit CAtlTraceModuleInfo();

	void Reset(_In_ HINSTANCE hInst);
	HINSTANCE GetInstance() const
	{
		return m_hInst;
	}
	const WCHAR *Path() const
	{
		return m_szPath;
	}
	const WCHAR *Name() const
	{
		return m_szName;
	}

	int m_iFirstCategory;
	LONG m_nCategories;

private:
	WCHAR m_szPath[MAX_PATH];
	WCHAR m_szName[_MAX_FNAME];
	HINSTANCE m_hInst;
};

class CAtlTraceSettings
{
public:
	CAtlTraceSettings() :
		m_nLevel(0),
		m_eStatus(Inherit),
		m_nRefCount(0),
		m_nCookie(0)
	{
	}

	UINT m_nLevel;
	enum Status
	{
		Inherit = 0,
		Enabled,
		Disabled
	};

	Status m_eStatus;

	// Only valid if (m_nRefCount > 0) && (m_nCookie != 0)
	LONG m_nRefCount;
	LONG m_nCookie;

public:
	// Tries to mark the object as allocated.  If the object is not available for allocation, returns false.
	// Call this, then initialize the data, then call MarkValid.  A successful TryAllocate gets a reference
	// to the object
	bool TryAllocate()
	{
		if( m_nCookie != 0 )
		{
			return( false );
		}
		LONG nNewRefCount = ::InterlockedIncrement( &m_nRefCount );
		if( nNewRefCount == 1 )
		{
			// We are the first ones here
			return( true );
		}

		return( false );
	}

	// Marks the object as valid.
	void MarkValid(_In_ LONG nCookie)
	{
		ATLASSERT( nCookie != 0 );
		m_nCookie = nCookie;
	}

	// Tries to get a reference to the object.  If the object is invalid, returns false.  Must call Release to
	// release the reference after a successful TryAddRef
	bool TryAddRef()
	{
		LONG nNewRefCount = ::InterlockedIncrement( &m_nRefCount );
		if( (nNewRefCount > 1) && (m_nCookie != 0) )
		{
			// The object is valid, and we now own a reference to it
			return( true );
		}
		else
		{
			Release();

			return( false );
		}
	}

	// Releases a reference to the object.  If the objects refcount hits zero, the object is invalidated
	void Release()
	{
		LONG nNewRefCount = ::InterlockedDecrement( &m_nRefCount );
		if( nNewRefCount == 0 )
		{
			// We just released the last reference, so mark as invalid
			m_nCookie = 0;
		}
	}
};

// Categories
class CAtlTraceCategory :
	public CAtlTraceSettings
{
public:
	CAtlTraceCategory();

	const WCHAR *Name() const
	{
		return m_szName;
	}

	void Reset(
		_In_z_ const WCHAR *pszName,
		_In_ LONG nModuleCookie);

	LONG m_nModuleCookie;
	int m_iNextCategory;

private:
	WCHAR m_szName[ATL_TRACE_MAX_NAME_SIZE];
};

// Modules (DLLs)
class CAtlTraceModule :
	public CAtlTraceModuleInfo,
	public CAtlTraceSettings
{
public:
	typedef int (__cdecl *fnCrtDbgReport_t)(
		_In_ int,
		_In_z_ const CHAR *,
		_In_ int,
		_In_z_ const CHAR *,
		_In_z_ _Printf_format_string_ const CHAR *,...);

	explicit CAtlTraceModule();

	void CrtDbgReport(_In_opt_ fnCrtDbgReport_t pfnCrtDbgReport);
	fnCrtDbgReport_t CrtDbgReport() const
	{
		return m_pfnCrtDbgReport;
	}

private:
	fnCrtDbgReport_t m_pfnCrtDbgReport;
};

// Process Info
class CAtlTraceProcess :
	public CAtlTraceModuleInfo
{
public:
	explicit CAtlTraceProcess(_In_ DWORD_PTR dwMaxSize);
	void Save(_In_ FILE *file, _In_ UINT nTabs) const;
	bool Load(_In_ FILE *file);

	UINT IncRef()
	{
		return ++m_nRef;
	}
	UINT DecRef()
	{
		return --m_nRef;
	}
	DWORD Id() const
	{
		return m_dwId;
	}
	DWORD_PTR MaxSize() const
	{
		return m_dwMaxSize;
	}
	void *Base() const
	{
		return m_pvBase;
	}
	int ModuleCount() const
	{
		return m_nModuleCount;
	}
	int CategoryCount() const
	{
		return m_nCategoryCount;
	}
	void IncModuleCount(_In_ UINT nModules)
	{
		m_nModuleCount += nModules;
	}
	void IncCategoryCount(_In_ UINT nCategories)
	{
		m_nCategoryCount += nCategories;
	}

	LONG GetNextCookie();

	DWORD_PTR m_dwFrontAlloc, m_dwBackAlloc, m_dwCurrFront, m_dwCurrBack;

	UINT m_nLevel;
	bool m_bLoaded, m_bEnabled, m_bFuncAndCategoryNames, m_bFileNameAndLineNo;

private:
	DWORD m_dwId;
	DWORD_PTR m_dwMaxSize;
	UINT m_nRef;
	void *m_pvBase;

	UINT m_nModuleCount, m_nCategoryCount;
	LONG m_nNextCookie;
};

#endif // ATLDEBUG_TRACE_MANAGER
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\src\atl\atls\Externs.cpp ===
// This is a part of the Active Template Library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Active Template Library Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the	
// Active Template Library product.

#include "stdafx.h"
#include "Common.h"
#include "Allocate.h"

//disable compiler reserved initialization area warning
#pragma warning(disable : 4074)
#pragma init_seg(compiler)

// if you change data size or data placement in CAtlTraceProcess or CAtlTraceModule 
// you should also change file mappings name because atltrace uses shared memory to store
// data and it will be not compatible with previous version
const char *g_pszUpdateEventName	= "AtlTraceModuleManager_ProcessAddedStatic_100";
const char *g_pszAllocFileMapName	= "AtlDebugAllocator_FileMappingNameStatic_100";

const char *g_pszKernelObjFmt = "%s_%0x";

CAtlAllocator g_Allocator;

static bool WINAPI Init()
{
	char szFileMappingName[MAX_PATH];

	int ret;
	ATL_CRT_ERRORCHECK_SPRINTF(ret = _snprintf_s(szFileMappingName, _countof(szFileMappingName), _countof(szFileMappingName) - 1, g_pszKernelObjFmt,
		g_pszAllocFileMapName, GetCurrentProcessId()));
	
	if(ret == -1 || ret >= MAX_PATH)
	{
		throw CAtlException( E_FAIL );
	}

	// surely four megs is enough?
	g_Allocator.Init(szFileMappingName, 4*1024*1024);

	return true;
}

static const bool g_bInitialized = Init();

#ifdef _DEBUG

namespace ATL
{

CTrace CTrace::s_trace;

};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\src\atl\atls\stdafx.h ===
// This is a part of the Active Template Library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Active Template Library Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the	
// Active Template Library product.

#define _ATL_STATIC_LIB_IMPL
#define _ATL_DEBUG_INTERFACES

#include <atlbase.h>
#include <atlcom.h>
#include <atlwin.h>
#include <atlimage.h>
#include <atlcomtime.h>
#include <atlmem.h>
#include <atlstr.h>
#include <atltime.h>

#include <atldebugapi.h>
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\src\atl\atls\LoadNSave.cpp ===
// This is a part of the Active Template Library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Active Template Library Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Active Template Library product.

#include "stdafx.h"
#include "Common.h"
#include "AtlTraceModuleManager.h"

namespace ATL
{
void WINAPI NotifyTool();

#define TRACE_SETTINGS_EXT ".trc"
#define TRACE_SETTINGS_EXTW L".trc"

static bool WINAPI SetSettings(
	_Inout_ CAtlTraceSettings *pTraceSettings,
	_In_ UINT nLevel,
	_In_ UINT nStatus)
{
	ATLASSERT(pTraceSettings);
	if(!pTraceSettings)
		return false;

	pTraceSettings->m_nLevel = nLevel;
	switch(nStatus)
	{
	case 0:
		pTraceSettings->m_eStatus = CAtlTraceSettings::Inherit;
		break;
	case 1:
		pTraceSettings->m_eStatus = CAtlTraceSettings::Enabled;
		break;
	case 2:
	default:
		pTraceSettings->m_eStatus = CAtlTraceSettings::Disabled;
		break;
	}
	return true;
}

static bool WINAPI GetSettings(
	_In_ const CAtlTraceSettings &rTraceSettings,
	_Out_ UINT *pnStatus)
{
	ATLASSERT(pnStatus);
	if(!pnStatus)
		return false;

	switch(rTraceSettings.m_eStatus)
	{
	case CAtlTraceSettings::Inherit:
		*pnStatus = 0;
		break;
	case CAtlTraceSettings::Enabled:
		*pnStatus = 1;
		break;
	case CAtlTraceSettings::Disabled:
	default:
		*pnStatus = 2;
		break;
	}
	return true;
}

BOOL __stdcall AtlTraceLoadSettingsA(
	_In_opt_z_ const CHAR *pszFileName,
	_In_ DWORD_PTR dwProcess /* = 0 */)
{
	CHAR szFileName[_MAX_PATH];
	if(!pszFileName)
	{
		CHAR szDrive[_MAX_DRIVE];
		CHAR szDir[_MAX_DIR];
		CHAR szFName[_MAX_FNAME];
		CHAR szExt[_MAX_EXT];

		DWORD dwret = ::GetModuleFileNameA(NULL, szFileName, MAX_PATH);
		if( dwret == 0 || dwret == MAX_PATH )
			return FALSE;
		ATL_CRT_ERRORCHECK(_splitpath_s(szFileName, szDrive, _countof(szDrive), szDir, _countof(szDir), szFName, _countof(szFName), szExt, _countof(szExt)));
		ATL_CRT_ERRORCHECK(strncpy_s(szExt, _MAX_EXT, TRACE_SETTINGS_EXT, sizeof(TRACE_SETTINGS_EXT)));
		ATL_CRT_ERRORCHECK(_makepath_s(szFileName, _MAX_PATH, szDrive, szDir, szFName, szExt));
		pszFileName = szFileName;
	}

	if(pszFileName)
	{
		if(-1 != GetFileAttributesA(pszFileName))
		{
			// file exists
			CHAR szSection[MAX_PATH], szKey[MAX_PATH], szValue[MAX_PATH];
			CHAR szName[MAX_PATH];
			UINT nModules, nCategories, nStatus, nLevel;
			UINT nModule;
			CAtlTraceProcess *pProcess;
			CAtlTraceModule *pModule;
			CAtlTraceCategory *pCategory;
			CHAR *pszProcess = "Process";
			CHAR cEnabled, cFuncAndCategoryNames, cFileNameAndLineInfo;
			CAtlAllocator *pAllocator = &g_Allocator;

			if (dwProcess)
				pAllocator = reinterpret_cast<CAtlAllocator*>(dwProcess);

			pProcess = pAllocator->GetProcess();
			ATLASSERT(pProcess);
			if(!pProcess)
				return FALSE;

			pProcess->m_bLoaded = true;

			::GetPrivateProfileStringA(pszProcess, "Info", "", szValue, MAX_PATH, pszFileName);
			szValue[MAX_PATH - 1] = 0;

			if(5 != sscanf_s(szValue, "ModuleCount:%u, Level:%u, Enabled:%c, "
				"FuncAndCategoryNames:%c, FileNameAndLineNo:%c", &nModules, &pProcess->m_nLevel, &cEnabled, sizeof(cEnabled),
				&cFuncAndCategoryNames, sizeof(cFuncAndCategoryNames), &cFileNameAndLineInfo, sizeof(cFileNameAndLineInfo)))
			{
				return FALSE;
			}
			pProcess->m_bEnabled = cEnabled != 'f';
			pProcess->m_bFuncAndCategoryNames = cFuncAndCategoryNames != 'f';
			pProcess->m_bFileNameAndLineNo = cFileNameAndLineInfo != 'f';

			for(UINT i = 0; i < nModules; i++)
			{
				if(-1 == sprintf_s(szKey, MAX_PATH, "Module%d", i+1))
					return FALSE;
				::GetPrivateProfileStringA(pszProcess, szKey, "", szSection, MAX_PATH, pszFileName);
				szSection[MAX_PATH -1] = 0;

				::GetPrivateProfileStringA(szSection, "Name", "", szName, MAX_PATH, pszFileName);
				szName[MAX_PATH -1] = 0;
				if(!pAllocator->FindModule(CA2W(szName), &nModule))
					continue;

				pModule = pAllocator->GetModule(nModule);
				ATLASSERT(pModule);
				if(!pModule)
					continue;

				::GetPrivateProfileStringA(szSection, "Settings", "", szValue, MAX_PATH, pszFileName);
				szValue[MAX_PATH -1] = 0;
				if(3 != sscanf_s(szValue, "CategoryCount:%u, Level:%u, Status:%u", &nCategories, &nLevel, &nStatus))
					continue;

				SetSettings(pModule, nLevel, nStatus);

				for(UINT j = 0; j < nCategories; j++)
				{
					if(-1 == sprintf_s(szKey, MAX_PATH, "Category%d", j+1))
						return FALSE;
					::GetPrivateProfileStringA(szSection, szKey, "", szValue, MAX_PATH, pszFileName);
					szValue[MAX_PATH -1] = 0;
					if(3 != sscanf_s(szValue, "Level:%u, Status:%u, Name:%s", &nLevel, &nStatus, szName, _countof(szName)))
						continue;

					UINT iCategory = pModule->m_iFirstCategory;
					while( iCategory != UINT( -1 ) )
					{
						pCategory = pAllocator->GetCategory(iCategory);

						if( lstrcmpA(CW2A(pCategory->Name()), szName) == 0 )
						{
							SetSettings(pCategory, nLevel, nStatus);
						}
						iCategory = pCategory->m_iNextCategory;
					}
				}
			}
			NotifyTool();
		}
	}
	return TRUE;
}

BOOL __stdcall AtlTraceSaveSettingsA(
	_In_opt_z_ const CHAR *pszFileName,
	_In_ DWORD_PTR dwProcess /* = 0 */)
{
	ATLASSERT(pszFileName);
	if(!pszFileName)
		return FALSE;

	BOOL bRetVal = FALSE;

	CHAR szKey[MAX_PATH], szValue[MAX_PATH];
	UINT nCategories, nStatus;
	CAtlTraceProcess *pProcess;
	CAtlTraceModule *pModule;
	CAtlTraceCategory *pCategory;
	LPCSTR pszProcess = "Process";
	CAtlAllocator *pAllocator = &g_Allocator;

	if (dwProcess)
		pAllocator = reinterpret_cast<CAtlAllocator*>(dwProcess);

	pProcess = pAllocator->GetProcess();
	ATLASSERT(pProcess);
	if(!pProcess)
		return FALSE;

	bRetVal = TRUE;
	ATLTRACEPROCESSINFO info;
	AtlTraceGetProcessInfo(dwProcess, &info);

	if(-1 == sprintf_s(szValue, MAX_PATH, "ModuleCount:%u, Level:%u, Enabled:%c, "
		"FuncAndCategoryNames:%c, FileNameAndLineNo:%c", info.nModules, pProcess->m_nLevel,
		pProcess->m_bEnabled ? 't' : 'f', pProcess->m_bFuncAndCategoryNames ? 't' : 'f',
		pProcess->m_bFileNameAndLineNo ? 't' : 'f'))
	{
		return FALSE;
	}

	if(::WritePrivateProfileStringA(pszProcess, "Info", szValue, pszFileName) == 0)
		return FALSE;

	for(int i = 0; i <  info.nModules; i++)
	{
		pModule = pAllocator->GetModule(i);
		ATLASSERT(pModule);
		if(!pModule)
			return FALSE;

		if(-1 == sprintf_s(szKey, MAX_PATH, "Module%d", i+1))
			return FALSE;
		if(::WritePrivateProfileStringA(pszProcess, szKey, CW2A(pModule->Name()), pszFileName) == 0)
			return FALSE;
		GetSettings(*pModule, &nStatus);

		nCategories = pAllocator->GetCategoryCount(i);

		if(::WritePrivateProfileStringA(CW2A(pModule->Name()), "Name", CW2A(pModule->Path()), pszFileName) == 0)
			return FALSE;

		if(-1 == sprintf_s(szValue, MAX_PATH, "CategoryCount:%u, Level:%u, Status:%u", nCategories, pModule->m_nLevel, nStatus))
			return FALSE;
		if(::WritePrivateProfileStringA(CW2A(pModule->Name()), "Settings", szValue, pszFileName) == 0)
			return FALSE;

		int j = 0;
		UINT nCategory = pModule->m_iFirstCategory;
		while( nCategory != UINT( -1 ) )
		{
			pCategory = pAllocator->GetCategory(nCategory);

			GetSettings(*pCategory, &nStatus);

			if(-1 == sprintf_s(szKey, MAX_PATH, "Category%d", j+1))
				return FALSE;
			j++;
			if(-1 == sprintf_s(szValue, MAX_PATH, "Level:%u, Status:%u, Name:%S",
				pCategory->m_nLevel, nStatus, pCategory->Name()))
			{
				return FALSE;
			}

			if(::WritePrivateProfileStringA(CW2A(pModule->Name()), szKey, szValue, pszFileName) == 0)
				return FALSE;

			nCategory = pCategory->m_iNextCategory;
		}
	}
	return bRetVal;
}

BOOL __stdcall AtlTraceLoadSettingsU(
	_In_opt_z_ const WCHAR *pszFileName,
	_In_ DWORD_PTR dwProcess /* = 0 */)
{
	WCHAR szFileName[MAX_PATH];
	if(!pszFileName)
	{
		WCHAR szDrive[_MAX_DRIVE];
		WCHAR szDir[_MAX_DIR];
		WCHAR szFName[_MAX_FNAME];
		WCHAR szExt[_MAX_EXT];

		DWORD dwret = ::GetModuleFileNameW(NULL, szFileName, MAX_PATH);
		if( dwret == 0 || dwret == MAX_PATH )
			return FALSE;
		ATL_CRT_ERRORCHECK(_wsplitpath_s(szFileName, szDrive, _countof(szDrive), szDir, _countof(szDir), szFName, _countof(szFName), szExt, _countof(szExt)));
		ATL_CRT_ERRORCHECK(wcsncpy_s(szExt, _MAX_EXT, TRACE_SETTINGS_EXTW, _countof(TRACE_SETTINGS_EXTW)));
		ATL_CRT_ERRORCHECK(_wmakepath_s(szFileName, MAX_PATH, szDrive, szDir, szFName, szExt));
		pszFileName = szFileName;
	}

	if(pszFileName)
	{
		if(-1 != GetFileAttributesW(pszFileName))
		{
			// file exists
			WCHAR szSection[MAX_PATH], szKey[MAX_PATH], szValue[MAX_PATH];
			WCHAR szName[MAX_PATH];
			UINT nModules, nCategories, nStatus, nLevel;
			UINT nModule;
			CAtlTraceProcess *pProcess;
			CAtlTraceModule *pModule;
			CAtlTraceCategory *pCategory;
			LPCWSTR pszProcess = L"Process";
			WCHAR cEnabled, cFuncAndCategoryNames, cFileNameAndLineInfo;
			CAtlAllocator *pAllocator = &g_Allocator;

			if (dwProcess)
				pAllocator = reinterpret_cast<CAtlAllocator*>(dwProcess);

			pProcess = pAllocator->GetProcess();
			ATLASSERT(pProcess);
			if(!pProcess)
				return FALSE;

			pProcess->m_bLoaded = true;

			::GetPrivateProfileStringW(pszProcess, L"Info", L"", szValue, MAX_PATH, pszFileName);
			szValue[MAX_PATH -1] = 0;
			if(5 != swscanf_s(szValue, L"ModuleCount:%u, Level:%u, Enabled:%c, "
				L"FuncAndCategoryNames:%c, FileNameAndLineNo:%c", &nModules, &pProcess->m_nLevel, &cEnabled, sizeof(cEnabled),
				&cFuncAndCategoryNames, sizeof(cFuncAndCategoryNames), &cFileNameAndLineInfo, sizeof(cFileNameAndLineInfo)))
			{
				return FALSE;
			}
			pProcess->m_bEnabled = cEnabled != L'f';
			pProcess->m_bFuncAndCategoryNames = cFuncAndCategoryNames != L'f';
			pProcess->m_bFileNameAndLineNo = cFileNameAndLineInfo != L'f';

			for(UINT i = 0; i < nModules; i++)
			{
				if(swprintf(szKey, MAX_PATH, L"Module%d", i+1) < 0)
					return FALSE;

				::GetPrivateProfileStringW(pszProcess, szKey, L"", szSection, MAX_PATH, pszFileName);
				szSection[MAX_PATH -1] = 0;
				::GetPrivateProfileStringW(szSection, L"Name", L"", szName, MAX_PATH, pszFileName);
				szName[MAX_PATH -1] = 0;
				if(!pAllocator->FindModule(szName, &nModule))
					continue;

				pModule = pAllocator->GetModule(nModule);
				ATLASSERT(pModule);
				if(!pModule)
					continue;

				::GetPrivateProfileStringW(szSection, L"Settings", L"", szValue, MAX_PATH, pszFileName);
				szValue[MAX_PATH -1] = 0;
				if(3 != swscanf_s(szValue, L"CategoryCount:%u, Level:%u, Status:%u", &nCategories, &nLevel, &nStatus))
					continue;

				SetSettings(pModule, nLevel, nStatus);

				for(UINT j = 0; j < nCategories; j++)
				{
					if(swprintf(szKey, MAX_PATH, L"Category%d", j+1) < 0)
						return FALSE;
					::GetPrivateProfileStringW(szSection, szKey, L"", szValue, MAX_PATH, pszFileName);
					szValue[MAX_PATH -1] = 0;
					if(3 != swscanf_s(szValue, L"Level:%u, Status:%u, Name:%s", &nLevel, &nStatus, szName, _countof(szName)))
						continue;

					UINT iCategory = pModule->m_iFirstCategory;
					while( iCategory != UINT( -1 ) )
					{
						pCategory = pAllocator->GetCategory(iCategory);

						if( lstrcmpW(pCategory->Name(), szName) == 0 )
						{
							SetSettings(pCategory, nLevel, nStatus);
						}
						iCategory = pCategory->m_iNextCategory;
					}
				}
			}
			NotifyTool();
		}
	}
	return TRUE;
}

BOOL __stdcall AtlTraceSaveSettingsU(
	_In_opt_z_ const WCHAR *pszFileName,
	_In_ DWORD_PTR dwProcess /* = 0 */)
{
	ATLASSERT(pszFileName);
	if(!pszFileName)
		return FALSE;

	BOOL bRetVal = FALSE;

	WCHAR szKey[MAX_PATH], szValue[MAX_PATH];
	UINT nCategories, nStatus;
	CAtlTraceProcess *pProcess;
	CAtlTraceModule *pModule;
	CAtlTraceCategory *pCategory;
	LPCWSTR pszProcess = L"Process";
	CAtlAllocator *pAllocator = &g_Allocator;

	if (dwProcess)
		pAllocator = reinterpret_cast<CAtlAllocator*>(dwProcess);

	pProcess = pAllocator->GetProcess();
	ATLASSERT(pProcess);
	if(!pProcess)
		return FALSE;

	bRetVal = TRUE;
	ATLTRACEPROCESSINFO info;
	AtlTraceGetProcessInfo(dwProcess, &info);

	if(swprintf(szValue, MAX_PATH, L"ModuleCount:%u, Level:%u, Enabled:%c, "
		L"FuncAndCategoryNames:%c, FileNameAndLineNo:%c", info.nModules, pProcess->m_nLevel,
		pProcess->m_bEnabled ? L't' : L'f', pProcess->m_bFuncAndCategoryNames ? L't' : L'f',
		pProcess->m_bFileNameAndLineNo ? L't' : L'f') < 0)
		return FALSE;

	if(::WritePrivateProfileStringW(pszProcess, L"Info", szValue, pszFileName) == 0)
		return FALSE;

	for(int i = 0; i <  info.nModules; i++)
	{
		pModule = pAllocator->GetModule(i);
		ATLASSERT(pModule);
		if(!pModule)
			return FALSE;

		if(swprintf(szKey, MAX_PATH,  L"Module%d", i+1) < 0)
			return FALSE;

		if(::WritePrivateProfileStringW(pszProcess, szKey, pModule->Name(), pszFileName) == 0)
			return FALSE;
		GetSettings(*pModule, &nStatus);

		nCategories = pAllocator->GetCategoryCount(i);

		if(::WritePrivateProfileStringW(pModule->Name(), L"Name", pModule->Path(), pszFileName) == 0)
			return FALSE;

		if(swprintf(szValue, MAX_PATH, L"CategoryCount:%u, Level:%u, Status:%u", nCategories, pModule->m_nLevel, nStatus) < 0)
			return FALSE;

		if(::WritePrivateProfileStringW(pModule->Name(), L"Settings", szValue, pszFileName) == 0)
			return FALSE;

		int j = 0;
		UINT nCategory = pModule->m_iFirstCategory;
		while( nCategory != UINT( -1 ) )
		{
			pCategory = pAllocator->GetCategory(nCategory);

			GetSettings(*pCategory, &nStatus);

			if(swprintf(szKey,MAX_PATH, L"Category%d", j+1) < 0)
				return FALSE;
			j++;
			if(swprintf(szValue, MAX_PATH,  L"Level:%u, Status:%u, Name:%s",
				pCategory->m_nLevel, nStatus, pCategory->Name()) < 0)
				return FALSE;

			if(::WritePrivateProfileStringW(pModule->Name(), szKey, szValue, pszFileName) == 0)
				return FALSE;

			nCategory = pCategory->m_iNextCategory;
		}
	}
	return bRetVal;
}

}; // namespace ATL
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\src\atl\atls\amd64\qithunk.s ===
; This is a part of the Active Template Library.
; Copyright (C) Microsoft Corporation
; All rights reserved.
;
; This source code is only intended as a supplement to the
; Active Template Library Reference and related
; electronic documentation provided with the library.
; See these sources for detailed information regarding the	
; Active Template Library product.


IMPL_QITHUNK MACRO num

	PUBLIC	?f&num&@_QIThunk@ATL@@UEAAJXZ

?f&num&@_QIThunk@ATL@@UEAAJXZ PROC

		cmp qword ptr [rcx+16], 0;		; compare m_dwRef to 0 ( rcx points to the _QIThunk )
		jg goodref;						; if it is greater than 0, the reference count is OK
		int 3;							; Break if call through deleted thunk
goodref:
		mov rax, qword ptr [rcx+8];		; rax = _QIThunk->pUnk
		mov rcx, rax;					; replace the 1st parameter (this) with _QIThunk->pUnk
		mov rax, qword ptr [rax];		; rax = _QIThunk->pUnk->vTable
		jmp qword ptr [rax+8*&num&];	; jump to the nth function in the vTable

?f&num&@_QIThunk@ATL@@UEAAJXZ ENDP

ENDM

_TEXT	SEGMENT

; the code below uses the IMPL_QITHUNK macro to generate functions f3@... to f1023@...

; UNFORTUNATELY there is a bug in the AMD64 MASM that prevents the WHILE macro from working,
; therefore for the time being we will just call the macro explicitely, and once the bug is
; fixed we will use the loop instead.

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;ordinal = 3
;
;WHILE ordinal LE 1023
;
;IMPL_QITHUNK %ordinal%
;
;ordinal = ordinal + 1
;
;ENDM
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

IMPL_QITHUNK 3
IMPL_QITHUNK 4
IMPL_QITHUNK 5
IMPL_QITHUNK 6
IMPL_QITHUNK 7
IMPL_QITHUNK 8
IMPL_QITHUNK 9
IMPL_QITHUNK 10
IMPL_QITHUNK 11
IMPL_QITHUNK 12
IMPL_QITHUNK 13
IMPL_QITHUNK 14
IMPL_QITHUNK 15
IMPL_QITHUNK 16
IMPL_QITHUNK 17
IMPL_QITHUNK 18
IMPL_QITHUNK 19
IMPL_QITHUNK 20
IMPL_QITHUNK 21
IMPL_QITHUNK 22
IMPL_QITHUNK 23
IMPL_QITHUNK 24
IMPL_QITHUNK 25
IMPL_QITHUNK 26
IMPL_QITHUNK 27
IMPL_QITHUNK 28
IMPL_QITHUNK 29
IMPL_QITHUNK 30
IMPL_QITHUNK 31
IMPL_QITHUNK 32
IMPL_QITHUNK 33
IMPL_QITHUNK 34
IMPL_QITHUNK 35
IMPL_QITHUNK 36
IMPL_QITHUNK 37
IMPL_QITHUNK 38
IMPL_QITHUNK 39
IMPL_QITHUNK 40
IMPL_QITHUNK 41
IMPL_QITHUNK 42
IMPL_QITHUNK 43
IMPL_QITHUNK 44
IMPL_QITHUNK 45
IMPL_QITHUNK 46
IMPL_QITHUNK 47
IMPL_QITHUNK 48
IMPL_QITHUNK 49
IMPL_QITHUNK 50
IMPL_QITHUNK 51
IMPL_QITHUNK 52
IMPL_QITHUNK 53
IMPL_QITHUNK 54
IMPL_QITHUNK 55
IMPL_QITHUNK 56
IMPL_QITHUNK 57
IMPL_QITHUNK 58
IMPL_QITHUNK 59
IMPL_QITHUNK 60
IMPL_QITHUNK 61
IMPL_QITHUNK 62
IMPL_QITHUNK 63
IMPL_QITHUNK 64
IMPL_QITHUNK 65
IMPL_QITHUNK 66
IMPL_QITHUNK 67
IMPL_QITHUNK 68
IMPL_QITHUNK 69
IMPL_QITHUNK 70
IMPL_QITHUNK 71
IMPL_QITHUNK 72
IMPL_QITHUNK 73
IMPL_QITHUNK 74
IMPL_QITHUNK 75
IMPL_QITHUNK 76
IMPL_QITHUNK 77
IMPL_QITHUNK 78
IMPL_QITHUNK 79
IMPL_QITHUNK 80
IMPL_QITHUNK 81
IMPL_QITHUNK 82
IMPL_QITHUNK 83
IMPL_QITHUNK 84
IMPL_QITHUNK 85
IMPL_QITHUNK 86
IMPL_QITHUNK 87
IMPL_QITHUNK 88
IMPL_QITHUNK 89
IMPL_QITHUNK 90
IMPL_QITHUNK 91
IMPL_QITHUNK 92
IMPL_QITHUNK 93
IMPL_QITHUNK 94
IMPL_QITHUNK 95
IMPL_QITHUNK 96
IMPL_QITHUNK 97
IMPL_QITHUNK 98
IMPL_QITHUNK 99
IMPL_QITHUNK 100
IMPL_QITHUNK 101
IMPL_QITHUNK 102
IMPL_QITHUNK 103
IMPL_QITHUNK 104
IMPL_QITHUNK 105
IMPL_QITHUNK 106
IMPL_QITHUNK 107
IMPL_QITHUNK 108
IMPL_QITHUNK 109
IMPL_QITHUNK 110
IMPL_QITHUNK 111
IMPL_QITHUNK 112
IMPL_QITHUNK 113
IMPL_QITHUNK 114
IMPL_QITHUNK 115
IMPL_QITHUNK 116
IMPL_QITHUNK 117
IMPL_QITHUNK 118
IMPL_QITHUNK 119
IMPL_QITHUNK 120
IMPL_QITHUNK 121
IMPL_QITHUNK 122
IMPL_QITHUNK 123
IMPL_QITHUNK 124
IMPL_QITHUNK 125
IMPL_QITHUNK 126
IMPL_QITHUNK 127
IMPL_QITHUNK 128
IMPL_QITHUNK 129
IMPL_QITHUNK 130
IMPL_QITHUNK 131
IMPL_QITHUNK 132
IMPL_QITHUNK 133
IMPL_QITHUNK 134
IMPL_QITHUNK 135
IMPL_QITHUNK 136
IMPL_QITHUNK 137
IMPL_QITHUNK 138
IMPL_QITHUNK 139
IMPL_QITHUNK 140
IMPL_QITHUNK 141
IMPL_QITHUNK 142
IMPL_QITHUNK 143
IMPL_QITHUNK 144
IMPL_QITHUNK 145
IMPL_QITHUNK 146
IMPL_QITHUNK 147
IMPL_QITHUNK 148
IMPL_QITHUNK 149
IMPL_QITHUNK 150
IMPL_QITHUNK 151
IMPL_QITHUNK 152
IMPL_QITHUNK 153
IMPL_QITHUNK 154
IMPL_QITHUNK 155
IMPL_QITHUNK 156
IMPL_QITHUNK 157
IMPL_QITHUNK 158
IMPL_QITHUNK 159
IMPL_QITHUNK 160
IMPL_QITHUNK 161
IMPL_QITHUNK 162
IMPL_QITHUNK 163
IMPL_QITHUNK 164
IMPL_QITHUNK 165
IMPL_QITHUNK 166
IMPL_QITHUNK 167
IMPL_QITHUNK 168
IMPL_QITHUNK 169
IMPL_QITHUNK 170
IMPL_QITHUNK 171
IMPL_QITHUNK 172
IMPL_QITHUNK 173
IMPL_QITHUNK 174
IMPL_QITHUNK 175
IMPL_QITHUNK 176
IMPL_QITHUNK 177
IMPL_QITHUNK 178
IMPL_QITHUNK 179
IMPL_QITHUNK 180
IMPL_QITHUNK 181
IMPL_QITHUNK 182
IMPL_QITHUNK 183
IMPL_QITHUNK 184
IMPL_QITHUNK 185
IMPL_QITHUNK 186
IMPL_QITHUNK 187
IMPL_QITHUNK 188
IMPL_QITHUNK 189
IMPL_QITHUNK 190
IMPL_QITHUNK 191
IMPL_QITHUNK 192
IMPL_QITHUNK 193
IMPL_QITHUNK 194
IMPL_QITHUNK 195
IMPL_QITHUNK 196
IMPL_QITHUNK 197
IMPL_QITHUNK 198
IMPL_QITHUNK 199
IMPL_QITHUNK 200
IMPL_QITHUNK 201
IMPL_QITHUNK 202
IMPL_QITHUNK 203
IMPL_QITHUNK 204
IMPL_QITHUNK 205
IMPL_QITHUNK 206
IMPL_QITHUNK 207
IMPL_QITHUNK 208
IMPL_QITHUNK 209
IMPL_QITHUNK 210
IMPL_QITHUNK 211
IMPL_QITHUNK 212
IMPL_QITHUNK 213
IMPL_QITHUNK 214
IMPL_QITHUNK 215
IMPL_QITHUNK 216
IMPL_QITHUNK 217
IMPL_QITHUNK 218
IMPL_QITHUNK 219
IMPL_QITHUNK 220
IMPL_QITHUNK 221
IMPL_QITHUNK 222
IMPL_QITHUNK 223
IMPL_QITHUNK 224
IMPL_QITHUNK 225
IMPL_QITHUNK 226
IMPL_QITHUNK 227
IMPL_QITHUNK 228
IMPL_QITHUNK 229
IMPL_QITHUNK 230
IMPL_QITHUNK 231
IMPL_QITHUNK 232
IMPL_QITHUNK 233
IMPL_QITHUNK 234
IMPL_QITHUNK 235
IMPL_QITHUNK 236
IMPL_QITHUNK 237
IMPL_QITHUNK 238
IMPL_QITHUNK 239
IMPL_QITHUNK 240
IMPL_QITHUNK 241
IMPL_QITHUNK 242
IMPL_QITHUNK 243
IMPL_QITHUNK 244
IMPL_QITHUNK 245
IMPL_QITHUNK 246
IMPL_QITHUNK 247
IMPL_QITHUNK 248
IMPL_QITHUNK 249
IMPL_QITHUNK 250
IMPL_QITHUNK 251
IMPL_QITHUNK 252
IMPL_QITHUNK 253
IMPL_QITHUNK 254
IMPL_QITHUNK 255
IMPL_QITHUNK 256
IMPL_QITHUNK 257
IMPL_QITHUNK 258
IMPL_QITHUNK 259
IMPL_QITHUNK 260
IMPL_QITHUNK 261
IMPL_QITHUNK 262
IMPL_QITHUNK 263
IMPL_QITHUNK 264
IMPL_QITHUNK 265
IMPL_QITHUNK 266
IMPL_QITHUNK 267
IMPL_QITHUNK 268
IMPL_QITHUNK 269
IMPL_QITHUNK 270
IMPL_QITHUNK 271
IMPL_QITHUNK 272
IMPL_QITHUNK 273
IMPL_QITHUNK 274
IMPL_QITHUNK 275
IMPL_QITHUNK 276
IMPL_QITHUNK 277
IMPL_QITHUNK 278
IMPL_QITHUNK 279
IMPL_QITHUNK 280
IMPL_QITHUNK 281
IMPL_QITHUNK 282
IMPL_QITHUNK 283
IMPL_QITHUNK 284
IMPL_QITHUNK 285
IMPL_QITHUNK 286
IMPL_QITHUNK 287
IMPL_QITHUNK 288
IMPL_QITHUNK 289
IMPL_QITHUNK 290
IMPL_QITHUNK 291
IMPL_QITHUNK 292
IMPL_QITHUNK 293
IMPL_QITHUNK 294
IMPL_QITHUNK 295
IMPL_QITHUNK 296
IMPL_QITHUNK 297
IMPL_QITHUNK 298
IMPL_QITHUNK 299
IMPL_QITHUNK 300
IMPL_QITHUNK 301
IMPL_QITHUNK 302
IMPL_QITHUNK 303
IMPL_QITHUNK 304
IMPL_QITHUNK 305
IMPL_QITHUNK 306
IMPL_QITHUNK 307
IMPL_QITHUNK 308
IMPL_QITHUNK 309
IMPL_QITHUNK 310
IMPL_QITHUNK 311
IMPL_QITHUNK 312
IMPL_QITHUNK 313
IMPL_QITHUNK 314
IMPL_QITHUNK 315
IMPL_QITHUNK 316
IMPL_QITHUNK 317
IMPL_QITHUNK 318
IMPL_QITHUNK 319
IMPL_QITHUNK 320
IMPL_QITHUNK 321
IMPL_QITHUNK 322
IMPL_QITHUNK 323
IMPL_QITHUNK 324
IMPL_QITHUNK 325
IMPL_QITHUNK 326
IMPL_QITHUNK 327
IMPL_QITHUNK 328
IMPL_QITHUNK 329
IMPL_QITHUNK 330
IMPL_QITHUNK 331
IMPL_QITHUNK 332
IMPL_QITHUNK 333
IMPL_QITHUNK 334
IMPL_QITHUNK 335
IMPL_QITHUNK 336
IMPL_QITHUNK 337
IMPL_QITHUNK 338
IMPL_QITHUNK 339
IMPL_QITHUNK 340
IMPL_QITHUNK 341
IMPL_QITHUNK 342
IMPL_QITHUNK 343
IMPL_QITHUNK 344
IMPL_QITHUNK 345
IMPL_QITHUNK 346
IMPL_QITHUNK 347
IMPL_QITHUNK 348
IMPL_QITHUNK 349
IMPL_QITHUNK 350
IMPL_QITHUNK 351
IMPL_QITHUNK 352
IMPL_QITHUNK 353
IMPL_QITHUNK 354
IMPL_QITHUNK 355
IMPL_QITHUNK 356
IMPL_QITHUNK 357
IMPL_QITHUNK 358
IMPL_QITHUNK 359
IMPL_QITHUNK 360
IMPL_QITHUNK 361
IMPL_QITHUNK 362
IMPL_QITHUNK 363
IMPL_QITHUNK 364
IMPL_QITHUNK 365
IMPL_QITHUNK 366
IMPL_QITHUNK 367
IMPL_QITHUNK 368
IMPL_QITHUNK 369
IMPL_QITHUNK 370
IMPL_QITHUNK 371
IMPL_QITHUNK 372
IMPL_QITHUNK 373
IMPL_QITHUNK 374
IMPL_QITHUNK 375
IMPL_QITHUNK 376
IMPL_QITHUNK 377
IMPL_QITHUNK 378
IMPL_QITHUNK 379
IMPL_QITHUNK 380
IMPL_QITHUNK 381
IMPL_QITHUNK 382
IMPL_QITHUNK 383
IMPL_QITHUNK 384
IMPL_QITHUNK 385
IMPL_QITHUNK 386
IMPL_QITHUNK 387
IMPL_QITHUNK 388
IMPL_QITHUNK 389
IMPL_QITHUNK 390
IMPL_QITHUNK 391
IMPL_QITHUNK 392
IMPL_QITHUNK 393
IMPL_QITHUNK 394
IMPL_QITHUNK 395
IMPL_QITHUNK 396
IMPL_QITHUNK 397
IMPL_QITHUNK 398
IMPL_QITHUNK 399
IMPL_QITHUNK 400
IMPL_QITHUNK 401
IMPL_QITHUNK 402
IMPL_QITHUNK 403
IMPL_QITHUNK 404
IMPL_QITHUNK 405
IMPL_QITHUNK 406
IMPL_QITHUNK 407
IMPL_QITHUNK 408
IMPL_QITHUNK 409
IMPL_QITHUNK 410
IMPL_QITHUNK 411
IMPL_QITHUNK 412
IMPL_QITHUNK 413
IMPL_QITHUNK 414
IMPL_QITHUNK 415
IMPL_QITHUNK 416
IMPL_QITHUNK 417
IMPL_QITHUNK 418
IMPL_QITHUNK 419
IMPL_QITHUNK 420
IMPL_QITHUNK 421
IMPL_QITHUNK 422
IMPL_QITHUNK 423
IMPL_QITHUNK 424
IMPL_QITHUNK 425
IMPL_QITHUNK 426
IMPL_QITHUNK 427
IMPL_QITHUNK 428
IMPL_QITHUNK 429
IMPL_QITHUNK 430
IMPL_QITHUNK 431
IMPL_QITHUNK 432
IMPL_QITHUNK 433
IMPL_QITHUNK 434
IMPL_QITHUNK 435
IMPL_QITHUNK 436
IMPL_QITHUNK 437
IMPL_QITHUNK 438
IMPL_QITHUNK 439
IMPL_QITHUNK 440
IMPL_QITHUNK 441
IMPL_QITHUNK 442
IMPL_QITHUNK 443
IMPL_QITHUNK 444
IMPL_QITHUNK 445
IMPL_QITHUNK 446
IMPL_QITHUNK 447
IMPL_QITHUNK 448
IMPL_QITHUNK 449
IMPL_QITHUNK 450
IMPL_QITHUNK 451
IMPL_QITHUNK 452
IMPL_QITHUNK 453
IMPL_QITHUNK 454
IMPL_QITHUNK 455
IMPL_QITHUNK 456
IMPL_QITHUNK 457
IMPL_QITHUNK 458
IMPL_QITHUNK 459
IMPL_QITHUNK 460
IMPL_QITHUNK 461
IMPL_QITHUNK 462
IMPL_QITHUNK 463
IMPL_QITHUNK 464
IMPL_QITHUNK 465
IMPL_QITHUNK 466
IMPL_QITHUNK 467
IMPL_QITHUNK 468
IMPL_QITHUNK 469
IMPL_QITHUNK 470
IMPL_QITHUNK 471
IMPL_QITHUNK 472
IMPL_QITHUNK 473
IMPL_QITHUNK 474
IMPL_QITHUNK 475
IMPL_QITHUNK 476
IMPL_QITHUNK 477
IMPL_QITHUNK 478
IMPL_QITHUNK 479
IMPL_QITHUNK 480
IMPL_QITHUNK 481
IMPL_QITHUNK 482
IMPL_QITHUNK 483
IMPL_QITHUNK 484
IMPL_QITHUNK 485
IMPL_QITHUNK 486
IMPL_QITHUNK 487
IMPL_QITHUNK 488
IMPL_QITHUNK 489
IMPL_QITHUNK 490
IMPL_QITHUNK 491
IMPL_QITHUNK 492
IMPL_QITHUNK 493
IMPL_QITHUNK 494
IMPL_QITHUNK 495
IMPL_QITHUNK 496
IMPL_QITHUNK 497
IMPL_QITHUNK 498
IMPL_QITHUNK 499
IMPL_QITHUNK 500
IMPL_QITHUNK 501
IMPL_QITHUNK 502
IMPL_QITHUNK 503
IMPL_QITHUNK 504
IMPL_QITHUNK 505
IMPL_QITHUNK 506
IMPL_QITHUNK 507
IMPL_QITHUNK 508
IMPL_QITHUNK 509
IMPL_QITHUNK 510
IMPL_QITHUNK 511
IMPL_QITHUNK 512
IMPL_QITHUNK 513
IMPL_QITHUNK 514
IMPL_QITHUNK 515
IMPL_QITHUNK 516
IMPL_QITHUNK 517
IMPL_QITHUNK 518
IMPL_QITHUNK 519
IMPL_QITHUNK 520
IMPL_QITHUNK 521
IMPL_QITHUNK 522
IMPL_QITHUNK 523
IMPL_QITHUNK 524
IMPL_QITHUNK 525
IMPL_QITHUNK 526
IMPL_QITHUNK 527
IMPL_QITHUNK 528
IMPL_QITHUNK 529
IMPL_QITHUNK 530
IMPL_QITHUNK 531
IMPL_QITHUNK 532
IMPL_QITHUNK 533
IMPL_QITHUNK 534
IMPL_QITHUNK 535
IMPL_QITHUNK 536
IMPL_QITHUNK 537
IMPL_QITHUNK 538
IMPL_QITHUNK 539
IMPL_QITHUNK 540
IMPL_QITHUNK 541
IMPL_QITHUNK 542
IMPL_QITHUNK 543
IMPL_QITHUNK 544
IMPL_QITHUNK 545
IMPL_QITHUNK 546
IMPL_QITHUNK 547
IMPL_QITHUNK 548
IMPL_QITHUNK 549
IMPL_QITHUNK 550
IMPL_QITHUNK 551
IMPL_QITHUNK 552
IMPL_QITHUNK 553
IMPL_QITHUNK 554
IMPL_QITHUNK 555
IMPL_QITHUNK 556
IMPL_QITHUNK 557
IMPL_QITHUNK 558
IMPL_QITHUNK 559
IMPL_QITHUNK 560
IMPL_QITHUNK 561
IMPL_QITHUNK 562
IMPL_QITHUNK 563
IMPL_QITHUNK 564
IMPL_QITHUNK 565
IMPL_QITHUNK 566
IMPL_QITHUNK 567
IMPL_QITHUNK 568
IMPL_QITHUNK 569
IMPL_QITHUNK 570
IMPL_QITHUNK 571
IMPL_QITHUNK 572
IMPL_QITHUNK 573
IMPL_QITHUNK 574
IMPL_QITHUNK 575
IMPL_QITHUNK 576
IMPL_QITHUNK 577
IMPL_QITHUNK 578
IMPL_QITHUNK 579
IMPL_QITHUNK 580
IMPL_QITHUNK 581
IMPL_QITHUNK 582
IMPL_QITHUNK 583
IMPL_QITHUNK 584
IMPL_QITHUNK 585
IMPL_QITHUNK 586
IMPL_QITHUNK 587
IMPL_QITHUNK 588
IMPL_QITHUNK 589
IMPL_QITHUNK 590
IMPL_QITHUNK 591
IMPL_QITHUNK 592
IMPL_QITHUNK 593
IMPL_QITHUNK 594
IMPL_QITHUNK 595
IMPL_QITHUNK 596
IMPL_QITHUNK 597
IMPL_QITHUNK 598
IMPL_QITHUNK 599
IMPL_QITHUNK 600
IMPL_QITHUNK 601
IMPL_QITHUNK 602
IMPL_QITHUNK 603
IMPL_QITHUNK 604
IMPL_QITHUNK 605
IMPL_QITHUNK 606
IMPL_QITHUNK 607
IMPL_QITHUNK 608
IMPL_QITHUNK 609
IMPL_QITHUNK 610
IMPL_QITHUNK 611
IMPL_QITHUNK 612
IMPL_QITHUNK 613
IMPL_QITHUNK 614
IMPL_QITHUNK 615
IMPL_QITHUNK 616
IMPL_QITHUNK 617
IMPL_QITHUNK 618
IMPL_QITHUNK 619
IMPL_QITHUNK 620
IMPL_QITHUNK 621
IMPL_QITHUNK 622
IMPL_QITHUNK 623
IMPL_QITHUNK 624
IMPL_QITHUNK 625
IMPL_QITHUNK 626
IMPL_QITHUNK 627
IMPL_QITHUNK 628
IMPL_QITHUNK 629
IMPL_QITHUNK 630
IMPL_QITHUNK 631
IMPL_QITHUNK 632
IMPL_QITHUNK 633
IMPL_QITHUNK 634
IMPL_QITHUNK 635
IMPL_QITHUNK 636
IMPL_QITHUNK 637
IMPL_QITHUNK 638
IMPL_QITHUNK 639
IMPL_QITHUNK 640
IMPL_QITHUNK 641
IMPL_QITHUNK 642
IMPL_QITHUNK 643
IMPL_QITHUNK 644
IMPL_QITHUNK 645
IMPL_QITHUNK 646
IMPL_QITHUNK 647
IMPL_QITHUNK 648
IMPL_QITHUNK 649
IMPL_QITHUNK 650
IMPL_QITHUNK 651
IMPL_QITHUNK 652
IMPL_QITHUNK 653
IMPL_QITHUNK 654
IMPL_QITHUNK 655
IMPL_QITHUNK 656
IMPL_QITHUNK 657
IMPL_QITHUNK 658
IMPL_QITHUNK 659
IMPL_QITHUNK 660
IMPL_QITHUNK 661
IMPL_QITHUNK 662
IMPL_QITHUNK 663
IMPL_QITHUNK 664
IMPL_QITHUNK 665
IMPL_QITHUNK 666
IMPL_QITHUNK 667
IMPL_QITHUNK 668
IMPL_QITHUNK 669
IMPL_QITHUNK 670
IMPL_QITHUNK 671
IMPL_QITHUNK 672
IMPL_QITHUNK 673
IMPL_QITHUNK 674
IMPL_QITHUNK 675
IMPL_QITHUNK 676
IMPL_QITHUNK 677
IMPL_QITHUNK 678
IMPL_QITHUNK 679
IMPL_QITHUNK 680
IMPL_QITHUNK 681
IMPL_QITHUNK 682
IMPL_QITHUNK 683
IMPL_QITHUNK 684
IMPL_QITHUNK 685
IMPL_QITHUNK 686
IMPL_QITHUNK 687
IMPL_QITHUNK 688
IMPL_QITHUNK 689
IMPL_QITHUNK 690
IMPL_QITHUNK 691
IMPL_QITHUNK 692
IMPL_QITHUNK 693
IMPL_QITHUNK 694
IMPL_QITHUNK 695
IMPL_QITHUNK 696
IMPL_QITHUNK 697
IMPL_QITHUNK 698
IMPL_QITHUNK 699
IMPL_QITHUNK 700
IMPL_QITHUNK 701
IMPL_QITHUNK 702
IMPL_QITHUNK 703
IMPL_QITHUNK 704
IMPL_QITHUNK 705
IMPL_QITHUNK 706
IMPL_QITHUNK 707
IMPL_QITHUNK 708
IMPL_QITHUNK 709
IMPL_QITHUNK 710
IMPL_QITHUNK 711
IMPL_QITHUNK 712
IMPL_QITHUNK 713
IMPL_QITHUNK 714
IMPL_QITHUNK 715
IMPL_QITHUNK 716
IMPL_QITHUNK 717
IMPL_QITHUNK 718
IMPL_QITHUNK 719
IMPL_QITHUNK 720
IMPL_QITHUNK 721
IMPL_QITHUNK 722
IMPL_QITHUNK 723
IMPL_QITHUNK 724
IMPL_QITHUNK 725
IMPL_QITHUNK 726
IMPL_QITHUNK 727
IMPL_QITHUNK 728
IMPL_QITHUNK 729
IMPL_QITHUNK 730
IMPL_QITHUNK 731
IMPL_QITHUNK 732
IMPL_QITHUNK 733
IMPL_QITHUNK 734
IMPL_QITHUNK 735
IMPL_QITHUNK 736
IMPL_QITHUNK 737
IMPL_QITHUNK 738
IMPL_QITHUNK 739
IMPL_QITHUNK 740
IMPL_QITHUNK 741
IMPL_QITHUNK 742
IMPL_QITHUNK 743
IMPL_QITHUNK 744
IMPL_QITHUNK 745
IMPL_QITHUNK 746
IMPL_QITHUNK 747
IMPL_QITHUNK 748
IMPL_QITHUNK 749
IMPL_QITHUNK 750
IMPL_QITHUNK 751
IMPL_QITHUNK 752
IMPL_QITHUNK 753
IMPL_QITHUNK 754
IMPL_QITHUNK 755
IMPL_QITHUNK 756
IMPL_QITHUNK 757
IMPL_QITHUNK 758
IMPL_QITHUNK 759
IMPL_QITHUNK 760
IMPL_QITHUNK 761
IMPL_QITHUNK 762
IMPL_QITHUNK 763
IMPL_QITHUNK 764
IMPL_QITHUNK 765
IMPL_QITHUNK 766
IMPL_QITHUNK 767
IMPL_QITHUNK 768
IMPL_QITHUNK 769
IMPL_QITHUNK 770
IMPL_QITHUNK 771
IMPL_QITHUNK 772
IMPL_QITHUNK 773
IMPL_QITHUNK 774
IMPL_QITHUNK 775
IMPL_QITHUNK 776
IMPL_QITHUNK 777
IMPL_QITHUNK 778
IMPL_QITHUNK 779
IMPL_QITHUNK 780
IMPL_QITHUNK 781
IMPL_QITHUNK 782
IMPL_QITHUNK 783
IMPL_QITHUNK 784
IMPL_QITHUNK 785
IMPL_QITHUNK 786
IMPL_QITHUNK 787
IMPL_QITHUNK 788
IMPL_QITHUNK 789
IMPL_QITHUNK 790
IMPL_QITHUNK 791
IMPL_QITHUNK 792
IMPL_QITHUNK 793
IMPL_QITHUNK 794
IMPL_QITHUNK 795
IMPL_QITHUNK 796
IMPL_QITHUNK 797
IMPL_QITHUNK 798
IMPL_QITHUNK 799
IMPL_QITHUNK 800
IMPL_QITHUNK 801
IMPL_QITHUNK 802
IMPL_QITHUNK 803
IMPL_QITHUNK 804
IMPL_QITHUNK 805
IMPL_QITHUNK 806
IMPL_QITHUNK 807
IMPL_QITHUNK 808
IMPL_QITHUNK 809
IMPL_QITHUNK 810
IMPL_QITHUNK 811
IMPL_QITHUNK 812
IMPL_QITHUNK 813
IMPL_QITHUNK 814
IMPL_QITHUNK 815
IMPL_QITHUNK 816
IMPL_QITHUNK 817
IMPL_QITHUNK 818
IMPL_QITHUNK 819
IMPL_QITHUNK 820
IMPL_QITHUNK 821
IMPL_QITHUNK 822
IMPL_QITHUNK 823
IMPL_QITHUNK 824
IMPL_QITHUNK 825
IMPL_QITHUNK 826
IMPL_QITHUNK 827
IMPL_QITHUNK 828
IMPL_QITHUNK 829
IMPL_QITHUNK 830
IMPL_QITHUNK 831
IMPL_QITHUNK 832
IMPL_QITHUNK 833
IMPL_QITHUNK 834
IMPL_QITHUNK 835
IMPL_QITHUNK 836
IMPL_QITHUNK 837
IMPL_QITHUNK 838
IMPL_QITHUNK 839
IMPL_QITHUNK 840
IMPL_QITHUNK 841
IMPL_QITHUNK 842
IMPL_QITHUNK 843
IMPL_QITHUNK 844
IMPL_QITHUNK 845
IMPL_QITHUNK 846
IMPL_QITHUNK 847
IMPL_QITHUNK 848
IMPL_QITHUNK 849
IMPL_QITHUNK 850
IMPL_QITHUNK 851
IMPL_QITHUNK 852
IMPL_QITHUNK 853
IMPL_QITHUNK 854
IMPL_QITHUNK 855
IMPL_QITHUNK 856
IMPL_QITHUNK 857
IMPL_QITHUNK 858
IMPL_QITHUNK 859
IMPL_QITHUNK 860
IMPL_QITHUNK 861
IMPL_QITHUNK 862
IMPL_QITHUNK 863
IMPL_QITHUNK 864
IMPL_QITHUNK 865
IMPL_QITHUNK 866
IMPL_QITHUNK 867
IMPL_QITHUNK 868
IMPL_QITHUNK 869
IMPL_QITHUNK 870
IMPL_QITHUNK 871
IMPL_QITHUNK 872
IMPL_QITHUNK 873
IMPL_QITHUNK 874
IMPL_QITHUNK 875
IMPL_QITHUNK 876
IMPL_QITHUNK 877
IMPL_QITHUNK 878
IMPL_QITHUNK 879
IMPL_QITHUNK 880
IMPL_QITHUNK 881
IMPL_QITHUNK 882
IMPL_QITHUNK 883
IMPL_QITHUNK 884
IMPL_QITHUNK 885
IMPL_QITHUNK 886
IMPL_QITHUNK 887
IMPL_QITHUNK 888
IMPL_QITHUNK 889
IMPL_QITHUNK 890
IMPL_QITHUNK 891
IMPL_QITHUNK 892
IMPL_QITHUNK 893
IMPL_QITHUNK 894
IMPL_QITHUNK 895
IMPL_QITHUNK 896
IMPL_QITHUNK 897
IMPL_QITHUNK 898
IMPL_QITHUNK 899
IMPL_QITHUNK 900
IMPL_QITHUNK 901
IMPL_QITHUNK 902
IMPL_QITHUNK 903
IMPL_QITHUNK 904
IMPL_QITHUNK 905
IMPL_QITHUNK 906
IMPL_QITHUNK 907
IMPL_QITHUNK 908
IMPL_QITHUNK 909
IMPL_QITHUNK 910
IMPL_QITHUNK 911
IMPL_QITHUNK 912
IMPL_QITHUNK 913
IMPL_QITHUNK 914
IMPL_QITHUNK 915
IMPL_QITHUNK 916
IMPL_QITHUNK 917
IMPL_QITHUNK 918
IMPL_QITHUNK 919
IMPL_QITHUNK 920
IMPL_QITHUNK 921
IMPL_QITHUNK 922
IMPL_QITHUNK 923
IMPL_QITHUNK 924
IMPL_QITHUNK 925
IMPL_QITHUNK 926
IMPL_QITHUNK 927
IMPL_QITHUNK 928
IMPL_QITHUNK 929
IMPL_QITHUNK 930
IMPL_QITHUNK 931
IMPL_QITHUNK 932
IMPL_QITHUNK 933
IMPL_QITHUNK 934
IMPL_QITHUNK 935
IMPL_QITHUNK 936
IMPL_QITHUNK 937
IMPL_QITHUNK 938
IMPL_QITHUNK 939
IMPL_QITHUNK 940
IMPL_QITHUNK 941
IMPL_QITHUNK 942
IMPL_QITHUNK 943
IMPL_QITHUNK 944
IMPL_QITHUNK 945
IMPL_QITHUNK 946
IMPL_QITHUNK 947
IMPL_QITHUNK 948
IMPL_QITHUNK 949
IMPL_QITHUNK 950
IMPL_QITHUNK 951
IMPL_QITHUNK 952
IMPL_QITHUNK 953
IMPL_QITHUNK 954
IMPL_QITHUNK 955
IMPL_QITHUNK 956
IMPL_QITHUNK 957
IMPL_QITHUNK 958
IMPL_QITHUNK 959
IMPL_QITHUNK 960
IMPL_QITHUNK 961
IMPL_QITHUNK 962
IMPL_QITHUNK 963
IMPL_QITHUNK 964
IMPL_QITHUNK 965
IMPL_QITHUNK 966
IMPL_QITHUNK 967
IMPL_QITHUNK 968
IMPL_QITHUNK 969
IMPL_QITHUNK 970
IMPL_QITHUNK 971
IMPL_QITHUNK 972
IMPL_QITHUNK 973
IMPL_QITHUNK 974
IMPL_QITHUNK 975
IMPL_QITHUNK 976
IMPL_QITHUNK 977
IMPL_QITHUNK 978
IMPL_QITHUNK 979
IMPL_QITHUNK 980
IMPL_QITHUNK 981
IMPL_QITHUNK 982
IMPL_QITHUNK 983
IMPL_QITHUNK 984
IMPL_QITHUNK 985
IMPL_QITHUNK 986
IMPL_QITHUNK 987
IMPL_QITHUNK 988
IMPL_QITHUNK 989
IMPL_QITHUNK 990
IMPL_QITHUNK 991
IMPL_QITHUNK 992
IMPL_QITHUNK 993
IMPL_QITHUNK 994
IMPL_QITHUNK 995
IMPL_QITHUNK 996
IMPL_QITHUNK 997
IMPL_QITHUNK 998
IMPL_QITHUNK 999
IMPL_QITHUNK 1000
IMPL_QITHUNK 1001
IMPL_QITHUNK 1002
IMPL_QITHUNK 1003
IMPL_QITHUNK 1004
IMPL_QITHUNK 1005
IMPL_QITHUNK 1006
IMPL_QITHUNK 1007
IMPL_QITHUNK 1008
IMPL_QITHUNK 1009
IMPL_QITHUNK 1010
IMPL_QITHUNK 1011
IMPL_QITHUNK 1012
IMPL_QITHUNK 1013
IMPL_QITHUNK 1014
IMPL_QITHUNK 1015
IMPL_QITHUNK 1016
IMPL_QITHUNK 1017
IMPL_QITHUNK 1018
IMPL_QITHUNK 1019
IMPL_QITHUNK 1020
IMPL_QITHUNK 1021
IMPL_QITHUNK 1022
IMPL_QITHUNK 1023

_TEXT	ENDS

END
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\src\atl\atls\amd64\stdcallthunk.s ===
; This is a part of the Active Template Library.
; Copyright (C) Microsoft Corporation
; All rights reserved.
;
; This source code is only intended as a supplement to the
; Active Template Library Reference and related
; electronic documentation provided with the library.
; See these sources for detailed information regarding the	
; Active Template Library product.


PUBLIC	CComStdCallThunkHelper

_TEXT	SEGMENT

CComStdCallThunkHelper PROC

	mov rax, rcx;		; save the 1st argument (pThunk pointer)
	mov rcx, 8[rcx];	; replace the 1st argument (pThunk) with the pThunk->pThis
	jmp qword ptr 16[rax];	; get pThunk->pfn

CComStdCallThunkHelper ENDP

_TEXT	ENDS

END
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\src\atl\atls\amd64\atlthunk.cpp ===
// This is a part of the Active Template Library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Active Template Library Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the	
// Active Template Library product.

#include <windows.h>
#include <atlstdthunk.h>

using namespace ATL;

extern "C"
{
typedef struct _CLIENT_ID {
    HANDLE UniqueProcess;
    HANDLE UniqueThread;
} CLIENT_ID;
typedef CLIENT_ID *PCLIENT_ID;

struct _PEB;
typedef struct _PEB * PPEB;

typedef struct _TEB {
    NT_TIB NtTib;
    PVOID EnvironmentPointer;
    CLIENT_ID ClientId;
    PVOID ActiveRpcHandle;
    PVOID ThreadLocalStoragePointer;
    PPEB ProcessEnvironmentBlock;
    /* .... Don't need any thing below this*/
} TEB, *PTEB;
 
__inline PTEB Atl_NtCurrentTeb( void ) { return (PTEB)__readgsqword(FIELD_OFFSET(NT_TIB, Self)); }
 
}

#if !defined(_AMD64_)
#error Unsupported platform
#endif

#if !defined(PAGE_SIZE)
#define PAGE_SIZE 4096
#endif

PSLIST_HEADER AtlThunkPool = NULL;

#define ATL_THUNKS_PER_PAGE (PAGE_SIZE / sizeof(ATL_THUNK_ENTRY))
#define NtCurrentPeb() (Atl_NtCurrentTeb()->ProcessEnvironmentBlock)

BOOL
static
__InitializeThunkPool (
    VOID
    );

//
// An ATL thunk structure, used to manage free thunks in the pool
//
typedef union _ATL_THUNK_ENTRY {
    SLIST_ENTRY SListEntry;
    struct _stdcallthunk Thunk;
} ATL_THUNK_ENTRY, *PATL_THUNK_ENTRY;


PVOID
__AllocStdCallThunk_cmn (
    VOID
    )

/*++

Routine Description:

    This function is called by ATL to allocate a thunk structure from
    executable memory.

Arguments:

    None.

Return Value:

    Returns a pointer to a thunk structure on success.  Raises an exception
    on failure.

--*/

{
    PATL_THUNK_ENTRY lastThunkEntry;
    PATL_THUNK_ENTRY thunkEntry;
    PVOID thunkPage;
    ULONG_PTR exceptionArguments[1];

    //
    // Perform initialization if this is the first time through.
    //

    if (AtlThunkPool == NULL) {
        if (__InitializeThunkPool() == FALSE) {
            goto outOfMemory;
        }
    }

    //
    // Attempt to pop a thunk structure from the list and return it
    // 

    thunkEntry = (PATL_THUNK_ENTRY)InterlockedPopEntrySList(AtlThunkPool);
    if (thunkEntry != NULL) {
        return &thunkEntry->Thunk;
    }

    //
    // The thunk list was empty.  Allocate a new page of executable
    // memory.
    //

    thunkPage = (PATL_THUNK_ENTRY)VirtualAlloc(NULL,
                                               PAGE_SIZE,
                                               MEM_COMMIT,
                                               PAGE_EXECUTE_READWRITE);
    if (thunkPage == NULL) {
        goto outOfMemory;
    }

    //
    // See if another thread has replenished the pool while we were off
    // allocating memory.  This does not close the window but makes it much
    // smaller.
    //
    // The volatile reference moves the overhead of making the page present
    // outside of the window.
    //

    *(DWORD volatile *)thunkPage;
    thunkEntry = (PATL_THUNK_ENTRY)InterlockedPopEntrySList(AtlThunkPool);
    if (thunkEntry != NULL) {

        //
        // The pool has been replenished.  Free the page and use the thunk
        // entry that we just received.
        //

        VirtualFree(thunkPage,0,MEM_RELEASE);
        return thunkEntry;
    }

    //
    // Create an array of thunk structures on the page and insert all but
    // the last into the free thunk list.
    //
    // The last is kept out of the list and represents the thunk allocation.
    //

    thunkEntry = (PATL_THUNK_ENTRY)thunkPage;
    lastThunkEntry = thunkEntry + (ATL_THUNKS_PER_PAGE - 1);
    do {
        InterlockedPushEntrySList(AtlThunkPool,&thunkEntry->SListEntry);
        thunkEntry += 1;
    } while (thunkEntry < lastThunkEntry);

    return thunkEntry;

outOfMemory:

    //
    // ATL expects an exception in the event of an out of memory condition
    // 

    exceptionArguments[0] = sizeof(ATL_THUNK_ENTRY);
    RaiseException((DWORD)STATUS_NO_MEMORY,
                   0,
                   1,
                   exceptionArguments);

    return NULL;
}


VOID
__FreeStdCallThunk_cmn (
    IN PVOID Thunk
    )

/*++

Routine Description:

    This function is called by ATL to release a thunk structure back to the
    process-wide free thunk pool.

Arguments:

    Thunk - supplies a pointer to a thunk structure that was allocated with
            __AllocStdCallThunk().

Return Value:

    None.

--*/

{
    PATL_THUNK_ENTRY thunkEntry;

    //
    // Simply push the free thunk structure back onto the pool
    //

    thunkEntry = (PATL_THUNK_ENTRY)Thunk;
    InterlockedPushEntrySList(AtlThunkPool,&thunkEntry->SListEntry);
}


BOOL
static
__InitializeThunkPool (
    VOID
    )

/*++

Routine Description:

    This function is called on the first invocation of __AllocStdCallThunk().
    It retrieves a pointer to the process-wide thunk pool SLIST_HEADER, if
    one already exists, otherwise this routine supplies an initialized
    SLIST_HEADER.

Arguments:

    None.

Return Value:

    Returns TRUE if initialization succeeded, FALSE otherwise.

--*/

{
    #define PEB_POINTER_OFFSET 0x40

    PSLIST_HEADER *atlThunkPoolPtr;
    PSLIST_HEADER atlThunkPool;

    atlThunkPoolPtr = (PSLIST_HEADER *)((PCHAR)NtCurrentPeb() + PEB_POINTER_OFFSET);

    atlThunkPool = *atlThunkPoolPtr;
    if (atlThunkPool == NULL) {

        //
        // The pool list has not yet been initialized.  Try to use ours.
        //
        // Normally we would simply call InitializeSListHead() to initialize
        // the SLIST_HEADER.  However, this creates linkage that conflicts with
        // modules (such as duser) which also link to ntslist.lib.
        //
        // So to avoid that, the SLIST_HEADER is initialized manually.  This
        // code is specific to AMD64.
        // 
    
        //InitializeSListHead(&AtlThunkPoolLocal);
        atlThunkPool = (PSLIST_HEADER)HeapAlloc( GetProcessHeap(),
                                                 0,
                                                 sizeof(SLIST_HEADER) );
        if (atlThunkPool == NULL) {
            return FALSE;
        }

        atlThunkPool->Alignment = 0;
        atlThunkPool->Region = 0;

        if (InterlockedCompareExchangePointer( (PVOID *)atlThunkPoolPtr,
                                               atlThunkPool,
                                               NULL ) != NULL) {
            HeapFree( GetProcessHeap(),
                      0,
                      atlThunkPool );
        }

        atlThunkPool = *atlThunkPoolPtr;
    }

    AtlThunkPool = atlThunkPool;
    return TRUE;
}

//
// Now create the actual routines, one pair within an ATL namespace and one
// without.
// 

PVOID
__AllocStdCallThunk (
    VOID
    )
{
    return __AllocStdCallThunk_cmn();
}

VOID
__FreeStdCallThunk (
    IN PVOID Thunk
    )
{
    __FreeStdCallThunk_cmn(Thunk);
}

namespace ATL {

PVOID
__AllocStdCallThunk (
    VOID
    )
{
    return __AllocStdCallThunk_cmn();
}

VOID
__FreeStdCallThunk (
    IN PVOID Thunk
    )
{
    __FreeStdCallThunk_cmn(Thunk);
}

}   // namespace ATL
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\src\atl\atls\INTEL\atlthunk.cpp ===
// This is a part of the Active Template Library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Active Template Library Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the	
// Active Template Library product.

#include <windows.h>
#include <atlstdthunk.h>
 
extern "C"
{
typedef struct _CLIENT_ID {
    HANDLE UniqueProcess;
    HANDLE UniqueThread;
} CLIENT_ID;
typedef CLIENT_ID *PCLIENT_ID;

struct _PEB;
typedef struct _PEB * PPEB;

typedef struct _TEB {
    NT_TIB NtTib;
    PVOID EnvironmentPointer;
    CLIENT_ID ClientId;
    PVOID ActiveRpcHandle;
    PVOID ThreadLocalStoragePointer;
    PPEB ProcessEnvironmentBlock;
    /* .... Don't need any thing below this*/
} TEB, *PTEB;
 
}

#if !defined(_X86_)
#error Unsupported platform
#endif

#if !defined(PAGE_SIZE)
#define PAGE_SIZE 4096
#endif

#if !defined(DECLSPEC_NOINLINE)
#define DECLSPEC_NOINLINE __declspec(noinline)
#endif

#define ATL_THUNKS_PER_PAGE (PAGE_SIZE / sizeof(ATL_THUNK_ENTRY))

//
// Local function prototypes and typedefs
//

BOOL
static
__InitializeThunkPool (
    VOID
    );

//
// An ATL thunk structure, used to manage free thunks in the pool
//

typedef union _ATL_THUNK_ENTRY {
    SLIST_ENTRY SListEntry;
	struct ATL::_stdcallthunk Thunk;
} ATL_THUNK_ENTRY, *PATL_THUNK_ENTRY;

//
// Pointer to the process-wide ATL thunk slist.
//

PSLIST_HEADER __AtlThunkPool = NULL;

//
// Special value for __AtlThunkPool indicating that the standard
// heap should be used for thunk allocation.
//

#define ATLTHUNK_USE_HEAP_VALUE (PSLIST_HEADER)UlongToPtr(1)
#define ATLTHUNK_USE_HEAP()     (__AtlThunkPool == ATLTHUNK_USE_HEAP_VALUE)


PVOID
__AllocStdCallThunk_cmn (
    VOID
    )

/*++

Routine Description:

    This function is called by ATL to allocate a thunk structure from
    executable memory.

Arguments:

    None.

Return Value:

    Returns a pointer to a thunk structure on success.  Raises an exception
    on failure.

--*/

{
    PATL_THUNK_ENTRY lastThunkEntry;
    PATL_THUNK_ENTRY thunkEntry;
    PVOID thunkPage;

    //
    // Perform initialization if this is the first time through.
    //

    if (__AtlThunkPool == NULL) {
        if (__InitializeThunkPool() == FALSE) {
            goto outOfMemory;
        }
    }

    if (ATLTHUNK_USE_HEAP()) {

        //
        // On a non-NX capable platform, use the standard heap.
        //

        thunkEntry = (PATL_THUNK_ENTRY)HeapAlloc(GetProcessHeap(),
                                                 0,
                                                 sizeof(ATL::_stdcallthunk));
        if (thunkEntry == NULL) {
            goto outOfMemory;
        }

        return thunkEntry;
    }

    //
    // Attempt to pop a thunk structure from the list and return it
    // 

    thunkEntry = (PATL_THUNK_ENTRY) InterlockedPopEntrySList(__AtlThunkPool);
    if (thunkEntry != NULL) {
        return &thunkEntry->Thunk;
    }

    //
    // The thunk list was empty.  Allocate a new page of executable
    // memory.
    //

    thunkPage = (PATL_THUNK_ENTRY)VirtualAlloc(NULL,
                                               PAGE_SIZE,
                                               MEM_COMMIT,
                                               PAGE_EXECUTE_READWRITE);
    if (thunkPage == NULL) {
        goto outOfMemory;
    }

    //
    // See if another thread has replenished the pool while we were off
    // allocating memory.  This does not close the window but makes it much
    // smaller.
    //
    // The volatile reference moves the overhead of making the page present
    // outside of the window.
    //

    *(DWORD volatile *)thunkPage;
    thunkEntry = (PATL_THUNK_ENTRY) InterlockedPopEntrySList(__AtlThunkPool);
    if (thunkEntry != NULL) {

        //
        // The pool has been replenished.  Free the page and use the thunk
        // entry that we just received.
        //

        VirtualFree(thunkPage,0,MEM_RELEASE);
        return thunkEntry;
    }

    //
    // Create an array of thunk structures on the page and insert all but
    // the last into the free thunk list.
    //
    // The last is kept out of the list and represents the thunk allocation.
    //

    thunkEntry = (PATL_THUNK_ENTRY)thunkPage;
    lastThunkEntry = thunkEntry + ATL_THUNKS_PER_PAGE - 1;
    do {
        InterlockedPushEntrySList(__AtlThunkPool,&thunkEntry->SListEntry);
        thunkEntry += 1;
    } while (thunkEntry < lastThunkEntry);

    return thunkEntry;

outOfMemory:

    return NULL;
}


VOID
__FreeStdCallThunk_cmn (
    IN PVOID Thunk
    )

/*++

Routine Description:

    This function is called by ATL to release a thunk structure back to the
    process-wide free thunk pool.

Arguments:

    Thunk - supplies a pointer to a thunk structure that was allocated with
            __AllocStdCallThunk().

Return Value:

    None.

--*/

{
    PATL_THUNK_ENTRY thunkEntry;

    if (ATLTHUNK_USE_HEAP()) {

        //
        // On a non-NX capable platform, use the standard heap.
        //                              

        HeapFree(GetProcessHeap(),0,Thunk);

    } else {

        //
        // Simply push the free thunk structure back onto the pool
        //
    
        thunkEntry = (PATL_THUNK_ENTRY)Thunk;
        InterlockedPushEntrySList(__AtlThunkPool,&thunkEntry->SListEntry);
    }
}


BOOL
static
DECLSPEC_NOINLINE
__InitializeThunkPool (
    VOID
    )

/*++

Routine Description:

    This function is called on the first invocation of __AllocStdCallThunk().
    It retrieves a pointer to the process-wide thunk pool SLIST_HEADER, if
    one already exists, otherwise this routine supplies an initialized
    SLIST_HEADER.

Arguments:

    None.

Return Value:

    Returns TRUE if initialization succeeded, FALSE otherwise.

--*/

{
    #define PEB_POINTER_OFFSET 0x34

    PSLIST_HEADER *atlThunkPoolPtr;
    PSLIST_HEADER atlThunkPool;

    //
    // On Win64, a per-process ATL thunk "heap" (anchored in the PEB) is always
    // mantained as an SLIST.
    //
    // On X86, such a heap is conditional.  If the OS is < 5.1 (Windows XP) then
    // thunks are allocated/freed from/to the heap, otherwise they are mantained
    // as they would be on Win64.
    //
    // Two reasons for this:
    //
    // - We can't guarantee that the SLIST slot in the PEB is available downlevel
    // - Downlevel OSs may not offer the SLIST functionality
    // 

    BOOL result;

    result = IsProcessorFeaturePresent(PF_NX_ENABLED);
    if (result == FALSE) {

        //
        // NX execution is not happening on this machine.
        //
        // Indicate that the regular heap should be used by setting
        // __AtlThunkPool to a special value.
        //

        __AtlThunkPool = ATLTHUNK_USE_HEAP_VALUE;
        return TRUE;
    }

    atlThunkPoolPtr =
        (PSLIST_HEADER *)((PCHAR)(NtCurrentTeb()->ProcessEnvironmentBlock) + PEB_POINTER_OFFSET);

    atlThunkPool = *atlThunkPoolPtr;
    if (atlThunkPool == NULL) {

        //
        // The pool list has not yet been initialized.  Try to use ours.
        //
        // Normally we would simply call InitializeSListHead() to initialize
        // the SLIST_HEADER.  However, this creates linkage that conflicts with
        // modules (such as duser) which also link to ntslist.lib.
        //
        // So to avoid that, the SLIST_HEADER is initialized manually.  This
        // code is platform-specific.
        // 
    
        atlThunkPool = (PSLIST_HEADER)HeapAlloc( GetProcessHeap(),
                                                 0,
                                                 sizeof(SLIST_HEADER) );
        if (atlThunkPool == NULL) {
            return FALSE;
        }

        //InitializeSListHead(atlThunkPool);
        atlThunkPool->Alignment = 0;

        if (InterlockedCompareExchangePointer( (PVOID *)atlThunkPoolPtr,
                                               atlThunkPool,
                                               NULL ) != NULL) {

            //
            // Another thread was initializing as well, and won the race.
            // Free our slist header and use the one that is now there.
            //

            HeapFree( GetProcessHeap(),
                      0,
                      atlThunkPool );
        }

        atlThunkPool = *atlThunkPoolPtr;
    }

    __AtlThunkPool = atlThunkPool;
    return TRUE;
}

//
// Now create the actual routines, one pair within an ATL namespace and one
// without.
// 

PVOID
__stdcall __AllocStdCallThunk (
    VOID
    )
{
    return __AllocStdCallThunk_cmn();
}

VOID
__stdcall __FreeStdCallThunk (
    IN PVOID Thunk
    )
{
    __FreeStdCallThunk_cmn(Thunk);
}

namespace ATL {

PVOID
__stdcall __AllocStdCallThunk (
    VOID
    )
{
    return __AllocStdCallThunk_cmn();
}

VOID
__stdcall __FreeStdCallThunk (
    IN PVOID Thunk
    )
{
    __FreeStdCallThunk_cmn(Thunk);
}

}   // namespace ATL
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\src\mfc\afxabort.cpp ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#include "stdafx.h"


// Note: in separate module so it can be replaced if needed

void AFXAPI AfxAbort()
{
	TRACE(traceAppMsg, 0, "AfxAbort called.\n");

	AfxWinTerm();
	abort();
}

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\src\atl\atls\ia64\StdCallThunk.s ===
// This is a part of the Active Template Library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Active Template Library Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the	
// Active Template Library product.

	.global	_StdCallThunkProcProc
	.proc	_StdCallThunkProcProc
	.global _StdCallThunkProc
	.align	32

_StdCallThunkProcProc:
_StdCallThunkProc:
	// On entry, gp is actually a pointer to the m_pFunc member of 
	// the _stdcallthunk struct
	mov		r14=gp
	ld8		r15=[r14],8		// r15 = m_pFunc, r14 = &m_pThis
	ld8		r16=[r15],8		// r16 = m_pFunc->pfn, r15 = &m_pFunc->gp
	ld8		gp=[r15]		// gp = m_pFunc->gp
	ld8		r32=[r14]		// r32 = m_pThis
	mov		b6=r16			// b6 = m_pFunc->pfn
	br.cond.sptk.many	b6	// Jump to the real proc
	.endp	_StdCallThunkProcProc
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\src\mfc\afxacceleratorkey.cpp ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#include "stdafx.h"
#include "afxacceleratorkey.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#endif

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CMFCAcceleratorKey::CMFCAcceleratorKey(LPACCEL lpAccel) : m_lpAccel(lpAccel)
{
}

CMFCAcceleratorKey::CMFCAcceleratorKey() : m_lpAccel(NULL)
{
}

CMFCAcceleratorKey::~CMFCAcceleratorKey()
{
}

void CMFCAcceleratorKey::Format(CString& str) const
{
	str.Empty();

	if (m_lpAccel == NULL)
	{
		ASSERT(FALSE);
		return;
	}

	if (m_lpAccel->fVirt & FCONTROL)
	{
		AddVirtKeyStr(str, VK_CONTROL);
	}

	if (m_lpAccel->fVirt & FSHIFT)
	{
		AddVirtKeyStr(str, VK_SHIFT);
	}

	if (m_lpAccel->fVirt & FALT)
	{
		AddVirtKeyStr(str, VK_MENU);
	}

	if (m_lpAccel->fVirt & FVIRTKEY)
	{
		AddVirtKeyStr(str, m_lpAccel->key, TRUE);
	}
	else if (m_lpAccel->key != 27) // Don't print esc
	{
		str += (char) m_lpAccel->key;
	}
}

void CMFCAcceleratorKey::AddVirtKeyStr(CString& str, UINT uiVirtKey, BOOL bLast) const
{
	CString strKey;

	if (uiVirtKey == VK_PAUSE)
	{
		strKey = _T("Pause");
	}
	else
	{
#define AFX_BUFFER_LEN 50
		TCHAR szBuffer [AFX_BUFFER_LEN + 1];

		ZeroMemory(szBuffer, sizeof(szBuffer));

		UINT nScanCode = ::MapVirtualKeyEx(uiVirtKey, 0, ::GetKeyboardLayout(0)) << 16 | 0x1;

		if ((uiVirtKey >= VK_PRIOR && uiVirtKey <= VK_HELP) || (uiVirtKey == VK_DIVIDE))
		{
			nScanCode |= 0x01000000;
		}

		::GetKeyNameText(nScanCode, szBuffer, AFX_BUFFER_LEN);

		strKey = szBuffer;
	}

	strKey.MakeLower();

	//--------------------------------------
	// The first letter should be uppercase:
	//--------------------------------------
	for (int nCount = 0; nCount < strKey.GetLength(); nCount++)
	{
		TCHAR c = strKey[nCount];
		if (IsCharLower(c))
		{
			c = (TCHAR) toupper(c); // Convert single character JY 4-Dec-99
			strKey.SetAt(nCount, c);
			break;
		}
	}

	str += strKey;

	if (!bLast)
	{
		str += '+';
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\src\mfc\afxasert.cpp ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#include "stdafx.h"

#ifdef _DEBUG   // entire file


// NOTE: in separate module so it can replaced if needed

BOOL AFXAPI AfxAssertFailedLine(LPCSTR lpszFileName, int nLine)
{
#ifndef _AFX_NO_DEBUG_CRT
	// we remove WM_QUIT because if it is in the queue then the message box
	// won't display
	MSG msg;
	BOOL bQuit = PeekMessage(&msg, NULL, WM_QUIT, WM_QUIT, PM_REMOVE);
	BOOL bResult = _CrtDbgReport(_CRT_ASSERT, lpszFileName, nLine, NULL, NULL);
	if (bQuit)
		PostQuitMessage((int)msg.wParam);
	return bResult;
#else
	// Not supported.
#error _AFX_NO_DEBUG_CRT is not supported.
#endif // _AFX_NO_DEBUG_CRT
}
#endif // _DEBUG
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\src\mfc\afxacceleratorkeyassignctrl.cpp ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#include "stdafx.h"
#include "afxacceleratorkeyassignctrl.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#endif

/////////////////////////////////////////////////////////////////////////////
// CMFCAcceleratorKeyAssignCtrl

CMFCAcceleratorKeyAssignCtrl::CMFCAcceleratorKeyAssignCtrl() : m_Helper(&m_Accel)
{
	m_bIsDefined = FALSE;
	m_bIsFocused = FALSE;

	ResetKey();
}

CMFCAcceleratorKeyAssignCtrl::~CMFCAcceleratorKeyAssignCtrl()
{
}

BEGIN_MESSAGE_MAP(CMFCAcceleratorKeyAssignCtrl, CEdit)
	//{{AFX_MSG_MAP(CMFCAcceleratorKeyAssignCtrl)
	ON_WM_KILLFOCUS()
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CMFCAcceleratorKeyAssignCtrl message handlers

BOOL CMFCAcceleratorKeyAssignCtrl::PreTranslateMessage(MSG* pMsg)
{
	BOOL bIsKeyPressed = FALSE;
	BOOL bIsFirstPress = FALSE;

	switch(pMsg->message)
	{
	case WM_LBUTTONDOWN:
	case WM_MBUTTONDOWN:
	case WM_RBUTTONDOWN:
		m_bIsFocused = TRUE;
		SetFocus();
		return TRUE;

	case WM_KEYDOWN:
	case WM_SYSKEYDOWN:
		bIsKeyPressed = TRUE;
		bIsFirstPress = (pMsg->lParam &(1 << 30)) != 0;
		// To the key processing....

	case WM_KEYUP:
	case WM_SYSKEYUP:
		{
			if (bIsKeyPressed && m_bIsDefined && !bIsFirstPress)
			{
				ResetKey();
			}

			if (!m_bIsDefined)
			{
				switch(pMsg->wParam)
				{
				case VK_SHIFT:
					SetAccelFlag(FSHIFT, bIsKeyPressed);
					break;

				case VK_CONTROL:
					SetAccelFlag(FCONTROL, bIsKeyPressed);
					break;

				case VK_MENU:
					SetAccelFlag(FALT, bIsKeyPressed);
					break;

				default:
					if (!m_bIsFocused)
					{
						m_bIsFocused = TRUE;
						return TRUE;
					}

					m_Accel.key = (WORD) pMsg->wParam;

					if (bIsKeyPressed)
					{
						m_bIsDefined = TRUE;
						SetAccelFlag(FVIRTKEY, TRUE);
					}
				}
			}

			BOOL bDefaultProcess = FALSE;

			if ((m_Accel.fVirt & FCONTROL) == 0 && (m_Accel.fVirt & FSHIFT) == 0 && (m_Accel.fVirt & FALT) == 0 && (m_Accel.fVirt & FVIRTKEY))
			{
				switch(m_Accel.key)
				{
				case VK_ESCAPE:
					ResetKey();
					return TRUE;

				case VK_TAB:
				case VK_PROCESSKEY:
					bDefaultProcess = TRUE;
				}
			}

			if (!bDefaultProcess)
			{
				CString strKbd;
				m_Helper.Format(strKbd);

				SetWindowText(strKbd);
				return TRUE;
			}

			ResetKey();
		}
	}

	return CEdit::PreTranslateMessage(pMsg);
}

void CMFCAcceleratorKeyAssignCtrl::ResetKey()
{
	memset(&m_Accel, 0, sizeof(ACCEL));
	m_bIsDefined = FALSE;

	if (m_hWnd != NULL)
	{
		SetWindowText(_T(""));
	}
}

void CMFCAcceleratorKeyAssignCtrl::SetAccelFlag(BYTE bFlag, BOOL bOn)
{
	if (bOn)
	{
		m_Accel.fVirt |= bFlag;
	}
	else
	{
		m_Accel.fVirt &= ~bFlag;
	}
}

void CMFCAcceleratorKeyAssignCtrl::OnKillFocus(CWnd* pNewWnd)
{
	m_bIsFocused = FALSE;
	CEdit::OnKillFocus(pNewWnd);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\src\mfc\afxautohidebar.cpp ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#include "stdafx.h"
#include "afxcontrolbarutil.h"
#include "afxautohidebar.h"
#include "afxautohidebutton.h"
#include "afxglobalutils.h"
#include "afxdockingmanager.h"
#include "afxdocksite.h"
#include "afxdockablepane.h"
#include "afxdockingpanesrow.h"
#include "afxtrackmouse.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#endif

#define AFX_DISPLAY_AHWND_EVENT	1

int CMFCAutoHideBar::m_nShowAHWndDelay = 400;

CRuntimeClass* CMFCAutoHideBar::m_pAutoHideButtonRTS = RUNTIME_CLASS(CMFCAutoHideButton);

IMPLEMENT_DYNCREATE(CMFCAutoHideBar, CPane)

/////////////////////////////////////////////////////////////////////////////
// CMFCAutoHideBar

CMFCAutoHideBar::CMFCAutoHideBar()
{
	m_pLastActiveButton = NULL;
	m_bReadyToDisplayAHWnd = FALSE;
	m_nDisplayAHWndTimerID = 0;
	m_pHighlightedButton = NULL;
	m_bTracked = FALSE;
}

CMFCAutoHideBar::~CMFCAutoHideBar()
{
	if (m_nDisplayAHWndTimerID != 0)
	{
		KillTimer(m_nDisplayAHWndTimerID);
	}
	CleanUpAutoHideButtons();
}

BEGIN_MESSAGE_MAP(CMFCAutoHideBar, CPane)
	//{{AFX_MSG_MAP(CMFCAutoHideBar)
	ON_WM_CREATE()
	ON_WM_MOUSEMOVE()
	ON_WM_NCDESTROY()
	ON_WM_TIMER()
	ON_WM_LBUTTONDOWN()
	//}}AFX_MSG_MAP
	ON_MESSAGE(WM_MOUSELEAVE, &CMFCAutoHideBar::OnMouseLeave)
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CMFCAutoHideBar message handlers

int CMFCAutoHideBar::OnCreate(LPCREATESTRUCT lpCreateStruct)
{
	if (CPane::OnCreate(lpCreateStruct) == -1)
		return -1;

	return 0;
}

CMFCAutoHideButton* CMFCAutoHideBar::AddAutoHideWindow(CDockablePane* pAutoHideWnd, DWORD dwAlignment)
{
	ASSERT_VALID(this);
	ASSERT_VALID(pAutoHideWnd);
	ASSERT_KINDOF(CDockablePane, pAutoHideWnd);

	CDockablePane* pAutoHideBar = DYNAMIC_DOWNCAST(CDockablePane, pAutoHideWnd);

	if (pAutoHideBar == NULL)
	{
		ASSERT(FALSE);
		TRACE0("Only CDockablePane-derived class may have autohide state!\n");
		return NULL;
	}

	ENSURE(m_pAutoHideButtonRTS != NULL);

	CMFCAutoHideButton* pNewAutoHideButton = DYNAMIC_DOWNCAST(CMFCAutoHideButton, m_pAutoHideButtonRTS->CreateObject());

	if (pNewAutoHideButton == NULL)
	{
		ASSERT(FALSE);
		TRACE0("Wrong runtime class was specified for the autohide button class.\n");
		return NULL;
	}

	if (!pNewAutoHideButton->Create(this, pAutoHideBar, dwAlignment))
	{
		delete pNewAutoHideButton;
		TRACE0("Failed to create new AutoHide button.\n");
		return NULL;
	}

	CRect rect;
	GetWindowRect(rect);
	CSize sizeBtn = pNewAutoHideButton->GetSize();

	if (m_lstAutoHideButtons.IsEmpty())
	{
		rect.right += sizeBtn.cx;
		rect.bottom += sizeBtn.cy;
	}

	SetWindowPos(NULL, 0, 0, rect.Width(), rect.Height(), SWP_NOZORDER | SWP_NOMOVE);

	m_lstAutoHideButtons.AddTail(pNewAutoHideButton);
	return pNewAutoHideButton;
}

BOOL CMFCAutoHideBar::RemoveAutoHideWindow(CDockablePane* pAutoHideWnd)
{
	if (m_nDisplayAHWndTimerID != 0)
	{
		KillTimer(m_nDisplayAHWndTimerID);
		m_nDisplayAHWndTimerID = 0;
	}

	POSITION posSave = NULL;
	for (POSITION pos = m_lstAutoHideButtons.GetHeadPosition(); pos != NULL;)
	{
		posSave = pos;
		CMFCAutoHideButton* pBtn = (CMFCAutoHideButton*) m_lstAutoHideButtons.GetNext(pos);
		ASSERT_VALID(pBtn);

		if (pBtn->GetAutoHideWindow() == pAutoHideWnd)
		{
			if (m_pLastActiveButton == pBtn)
			{
				m_pLastActiveButton = NULL;
			}

			m_lstAutoHideButtons.RemoveAt(posSave);
			delete pBtn;

			if (m_lstAutoHideButtons.IsEmpty())
			{
				ASSERT_VALID(m_pParentDockBar);
				m_pParentDockBar->RemovePane(this, DM_UNKNOWN);
				CRect rectClient;
				m_pParentDockBar->GetClientRect(rectClient);
				m_pParentDockBar->RepositionPanes(rectClient);
			}
			DestroyWindow();
			return TRUE;
		}
	}

	return FALSE;
}

BOOL CMFCAutoHideBar::ShowAutoHideWindow(CDockablePane* pAutoHideWnd, BOOL bShow, BOOL /*bDelay*/)
{
	ASSERT_VALID(this);

	CMFCAutoHideButton* pBtn = ButtonFromAutoHideWindow(pAutoHideWnd);
	if (pBtn == NULL)
	{
		return FALSE;
	}

	ASSERT_VALID(pBtn);
	pBtn->ShowButton(bShow);

	UpdateVisibleState();
	return TRUE;
}

void CMFCAutoHideBar::UpdateVisibleState()
{
	BOOL bVisible = IsWindowVisible();
	int nCount = GetVisibleCount();

	ENSURE(m_pParentDockBar != NULL);

	if (/*bVisible &&*/ nCount == 0)
	{
		m_pParentDockBar->ShowPane(this, FALSE, FALSE, FALSE);
	}
	else if (!bVisible && nCount > 0)
	{
		m_pParentDockBar->ShowPane(this, TRUE, FALSE, TRUE);
	}
}

void CMFCAutoHideBar::UnSetAutoHideMode(CDockablePane* pFirstBarInGroup)
{
	for (POSITION pos = m_lstAutoHideButtons.GetHeadPosition(); pos != NULL;)
	{
		CMFCAutoHideButton* pBtn = (CMFCAutoHideButton*) m_lstAutoHideButtons.GetNext(pos);
		ASSERT_VALID(pBtn);

		pBtn->UnSetAutoHideMode(pFirstBarInGroup);
	}
}

int CMFCAutoHideBar::GetVisibleCount()
{
	int nCount = 0;
	for (POSITION pos = m_lstAutoHideButtons.GetHeadPosition(); pos != NULL;)
	{
		CMFCAutoHideButton* pBtn = (CMFCAutoHideButton*) m_lstAutoHideButtons.GetNext(pos);
		ASSERT_VALID(pBtn);
		if (pBtn->IsVisible())
		{
			nCount++;
		}
	}
	return nCount;
}

CMFCAutoHideButton* CMFCAutoHideBar::ButtonFromAutoHideWindow(CDockablePane* pAutoHideWnd)
{
	ASSERT_VALID(this);
	for (POSITION pos = m_lstAutoHideButtons.GetHeadPosition(); pos != NULL;)
	{
		CMFCAutoHideButton* pBtn = (CMFCAutoHideButton*) m_lstAutoHideButtons.GetNext(pos);
		ASSERT_VALID(pBtn);

		if (pBtn->GetAutoHideWindow() == pAutoHideWnd)
		{
			return pBtn;
		}
	}

	return NULL;
}

void CMFCAutoHideBar::DoPaint(CDC* pDC)
{
	ASSERT_VALID(pDC);

	CMemDC memDC(*pDC, this);
	CPane::DoPaint(&memDC.GetDC());

	CMFCAutoHideButton* pBtnTop = NULL;
	for (POSITION pos = m_lstAutoHideButtons.GetHeadPosition(); pos != NULL;)
	{
		CMFCAutoHideButton* pBtn = (CMFCAutoHideButton*) m_lstAutoHideButtons.GetNext(pos);
		ASSERT_VALID(pBtn);
		if (pBtn->IsTop())
		{
			pBtnTop = pBtn;
		}
		else if (pBtn->IsVisible())
		{
			pBtn->OnDraw(&memDC.GetDC());
		}
	}

	if (pBtnTop != NULL && pBtnTop->IsVisible())
	{
		pBtnTop->OnDraw(&memDC.GetDC());
	}
}

void CMFCAutoHideBar::OnMouseMove(UINT /*nFlags*/, CPoint /*point*/)
{
	CPoint pt;
	GetCursorPos(&pt);
	ScreenToClient(&pt);
	CMFCAutoHideButton* pBtn = ButtonFromPoint(pt);

	if (!m_bTracked)
	{
		m_bTracked = TRUE;
		
		TRACKMOUSEEVENT trackmouseevent;
		trackmouseevent.cbSize = sizeof(trackmouseevent);
		trackmouseevent.dwFlags = TME_LEAVE;
		trackmouseevent.hwndTrack = GetSafeHwnd();
		trackmouseevent.dwHoverTime = HOVER_DEFAULT;
		::AFXTrackMouse(&trackmouseevent);
	}

	if (pBtn != NULL && !m_bReadyToDisplayAHWnd)
	{
		CDockablePane* pAttachedBar = pBtn->GetAutoHideWindow();
		ASSERT_VALID(pAttachedBar);

		if (!pAttachedBar->IsWindowVisible())
		{
			m_bReadyToDisplayAHWnd = TRUE;

			if (m_nDisplayAHWndTimerID != 0)
			{
				KillTimer(m_nDisplayAHWndTimerID);
			}
			m_nDisplayAHWndTimerID = SetTimer(AFX_DISPLAY_AHWND_EVENT, m_nShowAHWndDelay, NULL);
		}

		if (m_pHighlightedButton != NULL && m_pHighlightedButton != pBtn)
		{
			ASSERT_VALID(m_pHighlightedButton);

			m_pHighlightedButton->HighlightButton(FALSE);
		}

		if (pBtn != m_pHighlightedButton)
		{
			pBtn->HighlightButton(TRUE);
			m_pHighlightedButton = pBtn;

			UpdateWindow();
			Invalidate();
		}
	}
}

LRESULT CMFCAutoHideBar::OnMouseLeave(WPARAM, LPARAM)
{
	if (m_pHighlightedButton != NULL)
	{
		ASSERT_VALID(m_pHighlightedButton);

		m_pHighlightedButton->HighlightButton(FALSE);
		m_pHighlightedButton = NULL;

		UpdateWindow ();
		Invalidate ();
	}

	m_bTracked = FALSE;
	return 0;
}

CMFCAutoHideButton* CMFCAutoHideBar::ButtonFromPoint(CPoint pt)
{
	POSITION pos = NULL;
	for (pos = m_lstAutoHideButtons.GetHeadPosition(); pos != NULL;)
	{
		CMFCAutoHideButton* pBtn = (CMFCAutoHideButton*) m_lstAutoHideButtons.GetNext(pos);
		ASSERT_VALID(pBtn);

		if (!pBtn->IsTop())
		{
			continue;
		}

		if (pBtn->IsVisible())
		{
			CRect rect = pBtn->GetRect();
			if (rect.PtInRect(pt))
			{
				return pBtn;
			}
		}
	}

	for (pos = m_lstAutoHideButtons.GetHeadPosition(); pos != NULL;)
	{
		CMFCAutoHideButton* pBtn = (CMFCAutoHideButton*) m_lstAutoHideButtons.GetNext(pos);
		ASSERT_VALID(pBtn);

		if (pBtn->IsVisible())
		{
			CRect rect = pBtn->GetRect();
			if (rect.PtInRect(pt))
			{
				return pBtn;
			}
		}
	}

	return NULL;
}

CSize CMFCAutoHideBar::CalcFixedLayout(BOOL /*bStretch*/, BOOL /*bHorz*/)
{
	CRect rect;
	GetWindowRect(&rect);
	return rect.Size();
}

void CMFCAutoHideBar::CleanUpAutoHideButtons()
{
	for (POSITION pos = m_lstAutoHideButtons.GetHeadPosition(); pos != NULL;)
	{
		CMFCAutoHideButton* pBtn = (CMFCAutoHideButton*) m_lstAutoHideButtons.GetNext(pos);
		ASSERT_VALID(pBtn);

		delete pBtn;
	}

	m_lstAutoHideButtons.RemoveAll();
}

void CMFCAutoHideBar::OnNcDestroy()
{
	if (m_nDisplayAHWndTimerID != 0)
	{
		KillTimer(m_nDisplayAHWndTimerID);
		m_nDisplayAHWndTimerID = 0;
	}

	CWnd::OnNcDestroy();
	delete this;
}

void CMFCAutoHideBar::OnTimer(UINT_PTR nIDEvent)
{
	if (nIDEvent == AFX_DISPLAY_AHWND_EVENT)
	{
		CPoint pt;
		GetCursorPos(&pt);
		ScreenToClient(&pt);
		CMFCAutoHideButton* pBtn = ButtonFromPoint(pt);

		KillTimer(m_nDisplayAHWndTimerID);
		m_nDisplayAHWndTimerID = 0;

		if (pBtn != NULL && m_bReadyToDisplayAHWnd)
		{
			m_bReadyToDisplayAHWnd = FALSE;

			CDockablePane* pAttachedBar = pBtn->GetAutoHideWindow();
			ASSERT_VALID(pAttachedBar);

			if (!pAttachedBar->IsWindowVisible())
			{
				pBtn->ShowAttachedWindow(TRUE);
			}
		}
		else
		{
			m_bReadyToDisplayAHWnd = FALSE;
		}
	}

	CPane::OnTimer(nIDEvent);
}

CSize CMFCAutoHideBar::StretchPane(int /*nLength*/, BOOL /*bVert*/)
{
	CRect rect;
	GetWindowRect(rect);
	CSize size(0, 0);

	for (POSITION pos = m_lstAutoHideButtons.GetHeadPosition(); pos != NULL;)
	{
		CMFCAutoHideButton* pBtn = (CMFCAutoHideButton*) m_lstAutoHideButtons.GetNext(pos);
		ASSERT_VALID(pBtn);

		size = pBtn->GetSize();
	}

	SetWindowPos(NULL, 0, 0, size.cx, size.cy, SWP_NOMOVE | SWP_NOZORDER);

	return size;
}

void CMFCAutoHideBar::OnLButtonDown(UINT nFlags, CPoint point)
{
	CMFCAutoHideButton* pBtn = CMFCAutoHideBar::ButtonFromPoint(point);

	if (pBtn != NULL)
	{
		CDockablePane* pAttachedBar = pBtn->GetAutoHideWindow();
		if (pAttachedBar != NULL)
		{
			pAttachedBar->SetFocus();
		}
	}

	CPane::OnLButtonDown(nFlags, point);
}

void CMFCAutoHideBar::SetActiveInGroup(BOOL bActive)
{
	CPane::SetActiveInGroup(bActive);
	if (bActive)
	{
		CObList lst;
		m_pDockBarRow->GetGroupFromPane(this, lst);

		for (POSITION pos = lst.GetHeadPosition(); pos != NULL;)
		{
			CPane* pBar = DYNAMIC_DOWNCAST(CPane, lst.GetNext(pos));
			ASSERT_VALID(pBar);

			if (pBar != this)
			{
				pBar->SetActiveInGroup(FALSE);
			}
		}

		CRect rect; rect.SetRectEmpty();
		m_pParentDockBar->RepositionPanes(rect);

	}
}

CDockablePane* CMFCAutoHideBar::GetFirstAHWindow()
{
	if (m_lstAutoHideButtons.IsEmpty())
	{
		return NULL;
	}

	CMFCAutoHideButton* pBtn = (CMFCAutoHideButton*) m_lstAutoHideButtons.GetHead();
	if (pBtn != NULL)
	{
		return pBtn->GetAutoHideWindow();
	}
	return NULL;
}


BOOL CMFCAutoHideBar::Create(LPCTSTR lpszClassName, DWORD dwStyle, const RECT& rect, CWnd* pParentWnd, UINT nID, DWORD dwControlBarStyle, CCreateContext* pContext)
{
	ENSURE( AfxIsExtendedFrameClass(pParentWnd) );

	return CPane::Create(lpszClassName, dwStyle, rect, pParentWnd, nID, dwControlBarStyle, pContext);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\src\mfc\afxautohidebutton.cpp ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#include "stdafx.h"
#include "afxcontrolbarutil.h"
#include "afxautohidebutton.h"
#include "afxdockablepane.h"
#include "afxglobals.h"
#include "afxglobalutils.h"
#include "afxvisualmanager.h"
#include "afxdockingpanesrow.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#endif

IMPLEMENT_DYNCREATE(CMFCAutoHideButton, CObject)

int CMFCAutoHideButton::m_nBorderSize = 1;
int CMFCAutoHideButton::m_nMarginSize = 2; // from border to icon
int CMFCAutoHideButton::m_nTextMargin = 10;
int CMFCAutoHideButton::m_nTextSizeNoIcon = 20;
BOOL CMFCAutoHideButton::m_bOverlappingTabs = TRUE;

// Construction/Destruction
CMFCAutoHideButton::CMFCAutoHideButton()
{
	m_bTop = FALSE;
	m_pParentBar = NULL;
	m_pAutoHideWindow = NULL;
	m_dwAlignment = 0;
	m_bVisible = FALSE;
	m_bHighlighted = FALSE;
	m_rect.SetRectEmpty();
}

CMFCAutoHideButton::~CMFCAutoHideButton()
{
}

BOOL CMFCAutoHideButton::Create(CMFCAutoHideBar* pParentBar, CDockablePane* pAutoHideWnd, DWORD dwAlignment)
{
	ASSERT_VALID(this);
	ASSERT_VALID(pAutoHideWnd);
	ASSERT(dwAlignment & CBRS_ALIGN_ANY);

	m_pParentBar = pParentBar;
	m_pAutoHideWindow = pAutoHideWnd;
	m_dwAlignment = dwAlignment;

	pAutoHideWnd->SetAutoHideParents(pParentBar, this);

	CSize size = GetSize();
	m_rect.SetRect(0, 0, size.cx, size.cy);

	m_bVisible = TRUE;

	return TRUE;
}

void CMFCAutoHideButton::Move(int nOffset)
{
	ASSERT_VALID(this);
	// nOffset in pixels
	IsHorizontal() ? m_rect.OffsetRect(nOffset, 0) : m_rect.OffsetRect(0, nOffset);
}

CSize CMFCAutoHideButton::GetSize() const
{
	ASSERT_VALID(this);

	const BOOL bIsOverlapped = (CMFCVisualManager::GetInstance()->HasOverlappedAutoHideButtons());

	CSize size(m_nMarginSize + 2 * m_nBorderSize, m_nMarginSize + 2 * m_nBorderSize);

	if (m_pAutoHideWindow != NULL)
	{
		BOOL bHorz = IsHorizontal();
		HICON hIcon = m_pAutoHideWindow->GetPaneIcon(FALSE);
		CSize sizeText = GetTextSize();

		CSize sizeIcon(0, 0);
		if (hIcon != NULL)
		{
			sizeIcon = afxGlobalData.m_sizeSmallIcon;
		}

		int nSpacing = 0;

		if (bIsOverlapped)
		{
			if (bHorz)
			{
				int cy = max(sizeIcon.cy, sizeText.cy) + size.cy;
				nSpacing = cy * 2 / 3 + afxGlobalData.GetTextHeight();
			}
			else
			{
				int cx = max(sizeIcon.cx, sizeText.cx) + size.cx;
				nSpacing = cx * 2 / 3 + afxGlobalData.GetTextHeight();
			}
		}
		else
		{
			if (hIcon != NULL && (sizeText.cx > 0 && bHorz || sizeText.cy > 0 && !bHorz))
			{
				nSpacing = m_nTextMargin;
				nSpacing += IsHorizontal() ? sizeIcon.cx : sizeIcon.cy;
			}
			else if (hIcon == NULL)
			{
				nSpacing += m_nMarginSize + m_nTextSizeNoIcon;
			}
			else
			{
				nSpacing += m_nMarginSize + 1;
			}
		}

		if (bHorz)
		{
			size.cx += sizeIcon.cx + sizeText.cx + nSpacing;
			size.cy += max(sizeIcon.cy, sizeText.cy);
		}
		else
		{
			size.cx += max(sizeIcon.cx, sizeText.cx);
			size.cy += sizeIcon.cy + sizeText.cy + nSpacing;
		}

		CDockingPanesRow* pParentRow = m_pParentBar->GetDockSiteRow();
		if (pParentRow != NULL)
		{
			int nExtraSpace = pParentRow->GetExtraSpace();
			int nMaxBarSize = pParentRow->GetMaxPaneSize() - nExtraSpace;

			bHorz ? size.cy = max(size.cy, nMaxBarSize) : size.cx = max(size.cx, nMaxBarSize);
		}
	}

	return size;
}

void CMFCAutoHideButton::OnDraw(CDC* pDC)
{
	ASSERT_VALID(this);

	const BOOL bIsOverlapped = (CMFCVisualManager::GetInstance()->HasOverlappedAutoHideButtons());
	const int nTextMargin = bIsOverlapped ? (IsHorizontal() ? 5 : 7) : m_nTextMargin;

	CSize size = GetSize();
	m_rect.SetRect(0, 0, size.cx, size.cy);

	// calculate border size and draw the border
	CRect rectBorderSize(m_nBorderSize, 0, m_nBorderSize, m_nBorderSize);

	switch (m_dwAlignment & CBRS_ALIGN_ANY)
	{
	case CBRS_ALIGN_RIGHT:
		afxGlobalUtils.FlipRect(rectBorderSize, 90);
		break;
	case CBRS_ALIGN_BOTTOM:
		afxGlobalUtils.FlipRect(rectBorderSize, 180);
		break;
	case CBRS_ALIGN_LEFT:
		afxGlobalUtils.FlipRect(rectBorderSize, -90);
		break;
	}

	if (bIsOverlapped && !m_pParentBar->m_bFirstInGroup)
	{
		CRect rectPrev = m_rect;

		switch (m_dwAlignment & CBRS_ALIGN_ANY)
		{
		case CBRS_ALIGN_RIGHT:
		case CBRS_ALIGN_LEFT:
			rectPrev.OffsetRect(0, -m_rect.Height() + size.cx / 2);
			break;

		case CBRS_ALIGN_TOP:
		case CBRS_ALIGN_BOTTOM:
			rectPrev.OffsetRect(-m_rect.Width() + size.cy / 2, 0);
			break;
		}

		OnFillBackground(pDC, rectPrev);
		OnDrawBorder(pDC, rectPrev, rectBorderSize);
	}

	OnFillBackground(pDC, m_rect);
	OnDrawBorder(pDC, m_rect, rectBorderSize);

	if (m_pAutoHideWindow == NULL)
	{
		return;
	}

	ASSERT_VALID(m_pAutoHideWindow);

	CRect rectDraw = m_rect;

	if (!bIsOverlapped)
	{
		rectDraw.DeflateRect(rectBorderSize);
	}

	rectDraw.DeflateRect(m_nMarginSize, m_nMarginSize);

	if (bIsOverlapped)
	{
		if (IsHorizontal())
		{
			const int nExtra = rectDraw.Height() * 2 / 3;
			rectDraw.DeflateRect(nExtra, 0);
		}
		else
		{
			const int nExtra = rectDraw.Width() * 2 / 3;
			rectDraw.DeflateRect(0, nExtra);
		}
	}

	if (m_pAutoHideWindow != NULL)
	{
		// draw the icon (if any)
		HICON hIcon = m_pAutoHideWindow->GetPaneIcon(FALSE);
		if (hIcon != NULL)
		{
			CSize sizeIcon(afxGlobalData.m_sizeSmallIcon);

			int dx = IsHorizontal() ? 0 : (rectDraw.Width() - sizeIcon.cx) / 2;
			int dy = IsHorizontal() ? (rectDraw.Height() - sizeIcon.cy) / 2 : 0;

			::DrawIconEx(pDC->GetSafeHdc(), rectDraw.left + dx, rectDraw.top + dy, hIcon, sizeIcon.cx, sizeIcon.cy, 0, NULL, DI_NORMAL);

			if (IsHorizontal())
			{
				rectDraw.left += nTextMargin + sizeIcon.cx;
			}
			else
			{
				rectDraw.top += nTextMargin + sizeIcon.cy;
			}
		}
		else
		{
			if (IsHorizontal())
			{
				rectDraw.left += m_nMarginSize;
			}
			else
			{
				rectDraw.top += m_nMarginSize;
			}
		}

		// Draw text:
		CString strText;
		m_pAutoHideWindow->GetWindowText(strText);

		if (!strText.IsEmpty() && m_pParentBar->m_bActiveInGroup || hIcon == NULL || !m_bOverlappingTabs)
		{
			int nOldMode = pDC->SetBkMode(TRANSPARENT);

			CFont* pFontOld = (CFont*) pDC->SelectObject(IsHorizontal() ? &afxGlobalData.fontRegular : &afxGlobalData.fontVert);
			ENSURE(pFontOld != NULL);

			pDC->SetTextColor(CMFCVisualManager::GetInstance()->GetAutoHideButtonTextColor(this));

			if (IsHorizontal())
			{
				pDC->DrawText(strText, &rectDraw, DT_SINGLELINE | DT_VCENTER);
			}
			else
			{
				TEXTMETRIC tm;
				pDC->GetTextMetrics(&tm);

				CRect rectText = rectDraw;

				rectText.left = rectText.right - (rectDraw.Width() - tm.tmHeight + 1) / 2;
				rectText.bottom = rectDraw.top + nTextMargin;

				pDC->DrawText(strText, &rectText, DT_SINGLELINE | DT_VCENTER | DT_NOCLIP);
			}

			pDC->SelectObject(pFontOld);
			pDC->SetBkMode(nOldMode);
		}
	}
}

void CMFCAutoHideButton::OnFillBackground(CDC* pDC, CRect rect)
{
	CMFCVisualManager::GetInstance()->OnFillAutoHideButtonBackground(pDC, rect, this);
}

void CMFCAutoHideButton::OnDrawBorder(CDC* pDC, CRect rectBounds, CRect rectBorderSize)
{
	CMFCVisualManager::GetInstance()->OnDrawAutoHideButtonBorder(pDC, rectBounds, rectBorderSize, this);
}

CSize CMFCAutoHideButton::GetTextSize() const
{
	CSize size(0, 0);

	if (m_pAutoHideWindow != NULL && m_pParentBar != NULL)
	{
		CString strText;
		m_pAutoHideWindow->GetWindowText(strText);

		if (!strText.IsEmpty())
		{
			CWindowDC dc(m_pParentBar);

			CFont* pFontOld = (CFont*) dc.SelectObject(IsHorizontal() ? &afxGlobalData.fontRegular : &afxGlobalData.fontVert);
			ENSURE(pFontOld != NULL);
			size = dc.GetTextExtent(strText);
			size.cx += m_nMarginSize;
			size.cy += m_nMarginSize;

			dc.SelectObject(pFontOld);

			if (!IsHorizontal())
			{
				int n = size.cy;
				size.cy = size.cx;
				size.cx = n;
			}

		}

		if (!m_pParentBar->m_bActiveInGroup && m_bOverlappingTabs)
		{
			IsHorizontal() ? size.cx = 0 : size.cy = 0;
		}
	}
	return size;
}

BOOL CMFCAutoHideButton::IsHorizontal() const
{
	return (m_dwAlignment & CBRS_ALIGN_TOP || m_dwAlignment & CBRS_ALIGN_BOTTOM);
}

void CMFCAutoHideButton::ShowAttachedWindow(BOOL bShow)
{
	ASSERT_VALID(this);
	ASSERT_VALID(m_pAutoHideWindow);

	// collapse window out only if it is visible
	// expand window only if it is not visible

	if (bShow && !m_pAutoHideWindow->IsWindowVisible() || !bShow && m_pAutoHideWindow->IsWindowVisible())
	{
		m_pAutoHideWindow->Slide(bShow);
	}

	m_pParentBar->SetActiveInGroup(bShow);

}

void CMFCAutoHideButton::ShowButton(BOOL bShow)
{
	ASSERT_VALID(this);
	ASSERT_VALID(m_pParentBar);

	m_bVisible = bShow;
}

void CMFCAutoHideButton::HighlightButton(BOOL bHighlight)
{
	ASSERT_VALID (this);
	ASSERT_VALID(m_pParentBar);

	m_bHighlighted = bHighlight;
}

void CMFCAutoHideButton::UnSetAutoHideMode(CDockablePane* pFirstBarInGroup)
{
	if (m_pAutoHideWindow != NULL)
	{
		m_pAutoHideWindow->UnSetAutoHideMode(pFirstBarInGroup);
	}
}

void CMFCAutoHideButton::ReplacePane(CDockablePane* pNewBar)
{
	ASSERT_VALID(pNewBar);
	m_pAutoHideWindow = pNewBar;
	pNewBar->SetAutoHideParents(m_pParentBar, this);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\src\mfc\afxautohidedocksite.cpp ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#include "stdafx.h"
#include "afxcontrolbarutil.h"
#include "afxautohidedocksite.h"
#include "afxpane.h"
#include "afxdockingpanesrow.h"
#include "afxvisualmanager.h"
#include "afxautohidebar.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#endif

int CAutoHideDockSite::m_nExtraSpace = 2;

IMPLEMENT_DYNCREATE(CAutoHideDockSite, CDockSite)

/////////////////////////////////////////////////////////////////////////////
// CAutoHideDockSite

CAutoHideDockSite::CAutoHideDockSite()
{
	m_nOffsetLeft = 0;
	m_nOffsetRight = 0;
}

CAutoHideDockSite::~CAutoHideDockSite()
{
}

BEGIN_MESSAGE_MAP(CAutoHideDockSite, CDockSite)
	//{{AFX_MSG_MAP(CAutoHideDockSite)
	ON_WM_PAINT()
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

void CAutoHideDockSite::DockPane(CPane* pControlBar, AFX_DOCK_METHOD /*dockMethod*/, LPCRECT lpRect)
{
	ASSERT_VALID(this);
	ASSERT_VALID(pControlBar);

	BOOL bVertDock = !IsHorizontal();
	CSize szBarSize = pControlBar->CalcFixedLayout(FALSE, !bVertDock);

	// the control bar doesn't take up all space of the row
	int nRowHeight = bVertDock ? szBarSize.cx + m_nExtraSpace : szBarSize.cy + m_nExtraSpace;

	if (!m_lstControlBars.Find(pControlBar))
	{
		CDockingPanesRow* pRowToDock = NULL;

		if (m_lstDockBarRows.IsEmpty())
		{
			pRowToDock = AddRow(NULL, nRowHeight);
			if (GetCurrentAlignment() & CBRS_ALIGN_LEFT || GetCurrentAlignment() & CBRS_ALIGN_TOP)
			{
				pRowToDock->SetExtra(m_nExtraSpace, AFX_ROW_ALIGN_TOP);
			}
			else
			{
				pRowToDock->SetExtra(m_nExtraSpace, AFX_ROW_ALIGN_BOTTOM);
			}
		}
		else
		{
			pRowToDock = (CDockingPanesRow*) m_lstDockBarRows.GetHead();
		}

		ASSERT_VALID(pRowToDock);
		// the bar should be placed on the existing row or new row
		pRowToDock->AddPane(pControlBar, DM_RECT, lpRect, TRUE);

		ShowWindow(SW_SHOW);

		m_lstControlBars.AddTail(pControlBar);
		AdjustDockingLayout();
		CRect rectClient;
		GetClientRect(rectClient);
		RepositionPanes(rectClient);

	}
}

void CAutoHideDockSite::RepositionPanes(CRect& /*rectNewClientArea*/)
{
	ASSERT_VALID(this);

	if (!m_lstDockBarRows.IsEmpty())
	{
		CDockingPanesRow* pRow = (CDockingPanesRow*) m_lstDockBarRows.GetHead();
		ASSERT_VALID(pRow);

		pRow->ArrangePanes(m_nOffsetLeft + afxGlobalData.m_nAutoHideToolBarMargin, afxGlobalData.m_nAutoHideToolBarSpacing);

		if (CMFCVisualManager::GetInstance()->HasOverlappedAutoHideButtons())
		{
			pRow->RedrawAll();
		}
	}
}

void CAutoHideDockSite::UnSetAutoHideMode(CMFCAutoHideBar* pAutohideToolbar)
{
	if (pAutohideToolbar == NULL)
	{
		CObList lstBars;
		lstBars.AddTail(&m_lstControlBars);

		POSITION posSave = NULL;
		POSITION pos = NULL;

		for (pos = lstBars.GetHeadPosition(); pos != NULL;)
		{
			posSave = pos;
			CMFCAutoHideBar* pToolBar = (CMFCAutoHideBar*) lstBars.GetNext(pos);
			if (!pToolBar->m_bFirstInGroup)
			{
				lstBars.RemoveAt(posSave);
			}
		}

		for (pos = lstBars.GetHeadPosition(); pos != NULL;)
		{
			CMFCAutoHideBar* pToolBar = (CMFCAutoHideBar*) lstBars.GetNext(pos);
			UnSetAutoHideMode(pToolBar);
		}
		return;
	}

	// find the group;
	CDockingPanesRow* pRow = RowFromPane(pAutohideToolbar);

	CObList lstGroup;
	if (pRow != NULL)
	{
		pRow->GetGroupFromPane(pAutohideToolbar, lstGroup);
	}

	if (lstGroup.IsEmpty())
	{
		pAutohideToolbar->UnSetAutoHideMode(NULL);
	}
	else
	{
		BOOL bFirstBar = TRUE;
		CDockablePane* pFirstBar = NULL;
		for (POSITION pos = lstGroup.GetHeadPosition(); pos != NULL;)
		{
			CMFCAutoHideBar* pNextBar = DYNAMIC_DOWNCAST(CMFCAutoHideBar, lstGroup.GetNext(pos));
			if (pNextBar != NULL)
			{
				if (bFirstBar)
				{
					pFirstBar = pNextBar->GetFirstAHWindow();
					pNextBar->UnSetAutoHideMode(NULL);
					bFirstBar = FALSE;
				}
				else
				{
					pNextBar->UnSetAutoHideMode(pFirstBar);
				}
			}
		}
	}
}

void CAutoHideDockSite::OnPaint()
{
	CPaintDC dc(this); // device context for painting
	CMemDC memDC(dc, this);

	CRect rectClient;
	GetClientRect(rectClient);

	CMFCVisualManager::GetInstance()->OnFillBarBackground(&memDC.GetDC(), this, rectClient, rectClient);
}

void CAutoHideDockSite::GetAlignRect(CRect& rect) const
{
	GetWindowRect(rect);

	if (IsHorizontal())
	{
		rect.left += m_nOffsetLeft;
		rect.right -= m_nOffsetRight;
	}
	else
	{
		rect.top += m_nOffsetLeft;
		rect.bottom -= m_nOffsetRight;
	}
}

BOOL CAutoHideDockSite::CanAcceptPane(const CBasePane* pBar) const
{
	return pBar->IsKindOf(RUNTIME_CLASS(CMFCAutoHideBar));
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\src\mfc\afxbasepane.cpp ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#include "stdafx.h"

#include "afxframewndex.h"
#include "afxpaneframewnd.h"
#include "afxmultipaneframewnd.h"
#include "afxpanedivider.h"

#include "afxframewndex.h"
#include "afxmdiframewndex.h"
#include "afxoleipframewndex.h"
#include "afxoledocipframewndex.h"
#include "afxmdichildwndex.h"
#include "afxolecntrframewndex.h"

#include "afxdocksite.h"
#include "afxdockingpanesrow.h"

#include "afxbasetabctrl.h"

#include "afxbasepane.h"
#include "afxbasetabbedpane.h"
#include "afxdockablepaneadapter.h"

#include "afxregpath.h"
#include "afxsettingsstore.h"

#include "afxglobalutils.h"
#include "afxdockingmanager.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#endif

static const CString strBaseControlBarProfile = _T("BasePanes");
BOOL CBasePane::m_bSetTooltipTopmost = TRUE;

#define AFX_REG_SECTION_FMT    _T("%sBasePane-%d")
#define AFX_REG_SECTION_FMT_EX _T("%sBasePane-%d%x")

BOOL CBasePane::m_bMultiThreaded = FALSE;
CCriticalSection CBasePane::m_CriticalSection;

IMPLEMENT_DYNAMIC(CBasePane, CWnd)

/////////////////////////////////////////////////////////////////////////////
// CBasePane

CBasePane::CBasePane()
{
	m_dwEnabledAlignment = 0;
	m_dwStyle = 0;
	m_pParentDockBar = NULL;
	m_pDockBarRow = NULL;
	m_pDockSite = NULL;

	m_bRecentVisibleState = FALSE;
	m_bIsRestoredFromRegistry = FALSE;

	m_dwControlBarStyle = 0;

	m_bVisible = FALSE;
	m_dockMode = DT_UNDEFINED;
	m_bEnableIDChecking = TRUE;

	m_lpszBarTemplateName = NULL;
	m_sizeDialog = CSize(0, 0);

	m_rectBar.SetRectEmpty();

	m_bIsDlgControl = FALSE;
	m_bIsMDITabbed = FALSE;

	EnableActiveAccessibility();

}

CBasePane::~CBasePane()
{
}

//{{AFX_MSG_MAP(CBasePane)
BEGIN_MESSAGE_MAP(CBasePane, CWnd)
	ON_WM_PAINT()
	ON_WM_ERASEBKGND()
	ON_WM_SIZE()
	ON_WM_SETTINGCHANGE()
	ON_MESSAGE(WM_IDLEUPDATECMDUI, &CBasePane::OnIdleUpdateCmdUI)
	ON_MESSAGE(WM_HELPHITTEST, &CBasePane::OnHelpHitTest)
	ON_MESSAGE(WM_INITDIALOG, &CBasePane::HandleInitDialog)
	ON_MESSAGE(WM_SETICON, &CBasePane::OnSetIcon)
	ON_MESSAGE(WM_GETOBJECT, &CBasePane::OnGetObject)
	ON_MESSAGE(WM_PRINTCLIENT, &CBasePane::OnPrintClient)
END_MESSAGE_MAP()
//}}AFX_MSG_MAP

/////////////////////////////////////////////////////////////////////////////
// CBasePane message handlers

BOOL CBasePane::CreateEx(DWORD dwStyleEx, LPCTSTR lpszClassName, LPCTSTR lpszWindowName,
	DWORD dwStyle, const RECT& rect, CWnd* pParentWnd, UINT nID, DWORD dwControlBarStyle, CCreateContext* pContext)
{
	ASSERT_VALID(pParentWnd);

	m_bIsDlgControl = pParentWnd->IsKindOf(RUNTIME_CLASS(CDialog));

	if (m_bEnableIDChecking)
	{
		CDockingManager* pDockManager = afxGlobalUtils.GetDockingManager(pParentWnd);
		if (pDockManager == NULL)
		{
			pDockManager = afxGlobalUtils.GetDockingManager(AFXGetParentFrame(pParentWnd));
			if (pDockManager != NULL)
			{
				if (pDockManager->FindPaneByID(nID, TRUE) != NULL)
				{
					TRACE0("Control bar must be created with unique ID!\n");
				}
			}
		}
	}

	m_bVisible = m_bVisible & WS_VISIBLE;

	SetPaneStyle(dwStyle | GetPaneStyle());
	m_dwControlBarStyle = dwControlBarStyle;

	BOOL bResult = FALSE;

	if (m_lpszBarTemplateName != NULL)
	{
		CREATESTRUCT cs;
		memset(&cs, 0, sizeof(cs));
		cs.lpszClass = lpszClassName;//AFX_WNDCONTROLBAR;
		cs.lpszName = lpszWindowName;
		cs.style = dwStyle | WS_CHILD;
		cs.hMenu = (HMENU)(UINT_PTR) nID;
		cs.hInstance = AfxGetInstanceHandle();
		cs.hwndParent = pParentWnd->GetSafeHwnd();

		if (!PreCreateWindow(cs))
		{
			return FALSE;
		}

		//--------------------------
		// create a modeless dialog
		//--------------------------
		if (!CreateDlg(m_lpszBarTemplateName, pParentWnd))
		{
			TRACE(_T("Can't create dialog: %s\n"), m_lpszBarTemplateName);
			return FALSE;
		}

#pragma warning (disable : 4311)
		SetClassLongPtr(m_hWnd, GCLP_HBRBACKGROUND, (long) ::GetSysColorBrush(COLOR_BTNFACE));
#pragma warning (default : 4311)

		SetDlgCtrlID(nID);

		CRect rectWindow;
		GetWindowRect(&rectWindow);

		m_sizeDialog = rectWindow.Size();
		bResult = TRUE;
	}
	else
	{
		bResult = CWnd::CreateEx(dwStyleEx, lpszClassName, lpszWindowName, dwStyle, rect, pParentWnd, nID, pContext);
	}

	if (bResult)
	{
		if (pParentWnd->IsKindOf(RUNTIME_CLASS(CFrameWnd)))
		{
			m_pDockSite = DYNAMIC_DOWNCAST(CFrameWnd, pParentWnd);
		}
		else
		{
			// case of miniframe or smth. else
			m_pDockSite = DYNAMIC_DOWNCAST(CFrameWnd, AFXGetParentFrame(pParentWnd));
		}

		m_bIsDlgControl = pParentWnd->IsKindOf(RUNTIME_CLASS(CDialog));
	}

	return bResult;
}

BOOL CBasePane::OnEraseBkgnd(CDC* /*pDC*/)
{
	return TRUE;
}

void CBasePane::DoPaint(CDC* pDC)
{
	CRect rectClip;
	pDC->GetClipBox(rectClip);

	CRect rect;
	GetClientRect(rect);

	CMFCVisualManager::GetInstance()->OnFillBarBackground(pDC, this, rect, rectClip);
}

BOOL CBasePane::IsDocked() const
{
	// return TRUE if its parent is not miniframe or the bar is floating
	// in the miniframe with another control bar
	CPaneFrameWnd* pParentMiniFrame = GetParentMiniFrame();
	if (pParentMiniFrame != NULL)
	{
		ASSERT_VALID(pParentMiniFrame);
		if (pParentMiniFrame->GetPaneCount() == 1)
		{
			return FALSE;
		}
	}

	return TRUE;
}

BOOL CBasePane::IsTabbed() const
{
	ASSERT_VALID(this);
	CWnd* pParent = GetParent();
	ASSERT_VALID(pParent);
	return pParent->IsKindOf(RUNTIME_CLASS(CMFCBaseTabCtrl));
}

BOOL CBasePane::IsMDITabbed() const
{
	return m_bIsMDITabbed;
}

BOOL CBasePane::IsVisible() const
{
	ASSERT_VALID(this);

	if (!IsTabbed())
	{
		if (CDockingManager::m_bRestoringDockState)
		{
			return GetRecentVisibleState();
		}

		return ((GetStyle() & WS_VISIBLE) != 0);
	}

	HWND hWndTab = NULL;
	CMFCBaseTabCtrl* pParent = GetParentTabWnd(hWndTab);

	ASSERT_VALID(pParent);

	if (!pParent->IsWindowVisible())
	{
		return FALSE;
	}

	int iTabNum = pParent->GetTabFromHwnd(hWndTab);

	if (iTabNum >= 0 && iTabNum < pParent->GetTabsNum())
	{
		return pParent->IsTabVisible(iTabNum);
	}

	return FALSE;
}

CPaneFrameWnd* CBasePane::GetParentMiniFrame(BOOL bNoAssert) const
{
	ASSERT_VALID(this);
	CPaneFrameWnd* pMiniFrame = NULL;
	CWnd* pParent = GetParent();

	while (pParent != NULL)
	{
		if (!bNoAssert)
		{
			ASSERT_VALID(pParent);
		}

		if (pParent != NULL && pParent->IsKindOf(RUNTIME_CLASS(CPaneFrameWnd)))
		{
			pMiniFrame = DYNAMIC_DOWNCAST(CPaneFrameWnd, pParent);
			break;
		}
		pParent = pParent->GetParent();
	}

	return pMiniFrame;
}

void CBasePane::OnPaint()
{
	if (m_bMultiThreaded)
	{
		m_CriticalSection.Lock();
	}

	CPaintDC dc(this);

	// erase background now
	if (GetStyle() & WS_VISIBLE)
		DoPaint(&dc);

	if (m_bMultiThreaded)
	{
		m_CriticalSection.Unlock();
	}
}

HDWP CBasePane::MoveWindow(CRect& rect, BOOL bRepaint, HDWP hdwp)
{
	CRect rectOld;
	GetWindowRect(rectOld);

	if (IsFloating())
	{
		CPaneFrameWnd* pMiniFrame = GetParentMiniFrame();
		ASSERT_VALID(pMiniFrame);
		pMiniFrame->ScreenToClient(rectOld);
	}
	else if(m_pDockSite != NULL)
	{
		m_pDockSite->ScreenToClient(rectOld);
	}

	if (rectOld == rect)
	{
		return hdwp;
	}

	if (hdwp != NULL)
	{
		UINT uFlags = SWP_NOZORDER | SWP_NOACTIVATE;
		return DeferWindowPos(hdwp, GetSafeHwnd(), NULL, rect.left, rect.top, rect.Width(),
			rect.Height(), uFlags);

	}
	CWnd::MoveWindow(&rect, bRepaint);
	return NULL;
}

HDWP CBasePane::SetWindowPos(const CWnd* pWndInsertAfter, int x, int y, int cx, int cy, UINT nFlags, HDWP hdwp)
{
	if (hdwp == NULL)
	{
		CWnd::SetWindowPos(pWndInsertAfter, x, y, cx, cy, nFlags);
		return NULL;
	}

	HDWP hdwpNew = DeferWindowPos(hdwp, GetSafeHwnd(), NULL, x, y, cx, cy, nFlags);
	if (hdwpNew == NULL)
	{
		DWORD dwLastError = GetLastError();
		TRACE1("DeferWindowPos failded, error code %d\n", dwLastError);
		SetWindowPos(NULL, x, y, cx, cy, nFlags);
		return hdwp;
	}

	return hdwpNew;
}

// frame mapping functions
void CBasePane::AddPane(CBasePane* pBar)
{
	CWnd* pParentFrame = GetDockSiteFrameWnd();
	if (pParentFrame == NULL || afxGlobalUtils.m_bDialogApp)
	{
		return;
	}
	ASSERT_VALID(pParentFrame);

	if (pParentFrame->IsKindOf(RUNTIME_CLASS(CFrameWndEx)))
	{
		((CFrameWndEx*) pParentFrame)->AddPane(pBar);
	}
	else if (pParentFrame->IsKindOf(RUNTIME_CLASS(CMDIFrameWndEx)))
	{
		((CMDIFrameWndEx*) pParentFrame)->AddPane(pBar);
	}
	else if (pParentFrame->IsKindOf(RUNTIME_CLASS(COleIPFrameWndEx)))
	{
		((COleIPFrameWndEx*) pParentFrame)->AddPane(pBar);
	}
	else if (pParentFrame->IsKindOf(RUNTIME_CLASS(COleDocIPFrameWndEx)))
	{
		((COleDocIPFrameWndEx*) pParentFrame)->AddPane(pBar);
	}
	else if (pParentFrame->IsKindOf(RUNTIME_CLASS(CMDIChildWndEx)))
	{
		((CMDIChildWndEx*) pParentFrame)->AddPane(pBar);
	}
	else if (pParentFrame->IsKindOf(RUNTIME_CLASS(COleCntrFrameWndEx)))
	{
		((COleCntrFrameWndEx*) pParentFrame)->AddPane(pBar);
	}
	else
	{
		ASSERT(FALSE);
	}
}

void CBasePane::RemovePaneFromDockManager(CBasePane* pBar, BOOL bDestroy,BOOL bAdjustLayout, BOOL bAutoHide, CBasePane* pBarReplacement)
{
	CWnd* pParentFrame = GetDockSiteFrameWnd();
	if (pParentFrame == NULL || afxGlobalUtils.m_bDialogApp)
	{
		return;
	}

	ASSERT_VALID(pParentFrame);

	if (pParentFrame->IsKindOf(RUNTIME_CLASS(CFrameWndEx)))
	{
		((CFrameWndEx*) pParentFrame)->RemovePaneFromDockManager(pBar, bDestroy, bAdjustLayout, bAutoHide, pBarReplacement);
	}
	else if (pParentFrame->IsKindOf(RUNTIME_CLASS(CMDIFrameWndEx)))
	{
		((CMDIFrameWndEx*) pParentFrame)->RemovePaneFromDockManager(pBar, bDestroy, bAdjustLayout, bAutoHide, pBarReplacement);
	}
	else if (pParentFrame->IsKindOf(RUNTIME_CLASS(COleIPFrameWndEx)))
	{
		((COleIPFrameWndEx*) pParentFrame)->RemovePaneFromDockManager(pBar, bDestroy, bAdjustLayout, bAutoHide, pBarReplacement);
	}
	else if (pParentFrame->IsKindOf(RUNTIME_CLASS(COleDocIPFrameWndEx)))
	{
		((COleDocIPFrameWndEx*) pParentFrame)->RemovePaneFromDockManager(pBar, bDestroy, bAdjustLayout, bAutoHide, pBarReplacement);
	}
	else if (pParentFrame->IsKindOf(RUNTIME_CLASS(CMDIChildWndEx)))
	{
		((CMDIChildWndEx*) pParentFrame)->RemovePaneFromDockManager(pBar, bDestroy, bAdjustLayout, bAutoHide, pBarReplacement);
	}
	else if (pParentFrame->IsKindOf(RUNTIME_CLASS(COleCntrFrameWndEx)))
	{
		((COleCntrFrameWndEx*) pParentFrame)->RemovePaneFromDockManager(pBar, bDestroy, bAdjustLayout, bAutoHide, pBarReplacement);
	}
	else
	{
		ASSERT(FALSE);
	}
}

BOOL CBasePane::IsPointNearDockSite(CPoint point, DWORD& dwBarAlignment, BOOL& bOuterEdge) const
{
	CWnd* pParentFrame = GetDockSiteFrameWnd();

	if (pParentFrame == NULL || afxGlobalUtils.m_bDialogApp)
	{
		return TRUE;
	}

	ASSERT_VALID(pParentFrame);

	if (pParentFrame->IsKindOf(RUNTIME_CLASS(CFrameWndEx)))
	{
		return ((CFrameWndEx*) pParentFrame)->IsPointNearDockSite(point, dwBarAlignment, bOuterEdge);
	}
	else if (pParentFrame->IsKindOf(RUNTIME_CLASS(CMDIFrameWndEx)))
	{
		return ((CMDIFrameWndEx*) pParentFrame)->IsPointNearDockSite(point, dwBarAlignment, bOuterEdge);
	}
	else if (pParentFrame->IsKindOf(RUNTIME_CLASS(COleIPFrameWndEx)))
	{
		return ((COleIPFrameWndEx*) pParentFrame)->IsPointNearDockSite(point, dwBarAlignment, bOuterEdge);
	}
	else if (pParentFrame->IsKindOf(RUNTIME_CLASS(COleDocIPFrameWndEx)))
	{
		return ((COleDocIPFrameWndEx*) pParentFrame)->IsPointNearDockSite(point, dwBarAlignment, bOuterEdge);
	}
	else if (pParentFrame->IsKindOf(RUNTIME_CLASS(CMDIChildWndEx)))
	{
		return ((CMDIChildWndEx*) pParentFrame)->IsPointNearDockSite(point, dwBarAlignment, bOuterEdge);
	}
	else if (pParentFrame->IsKindOf(RUNTIME_CLASS(COleCntrFrameWndEx)))
	{
		return ((COleCntrFrameWndEx*) pParentFrame)->IsPointNearDockSite(point, dwBarAlignment, bOuterEdge);
	}
	else
	{
		ASSERT(FALSE);
	}
	return FALSE;
}

CBasePane* CBasePane::PaneFromPoint(CPoint point, int nSensitivity, bool bExactBar, CRuntimeClass* pRTCBarType) const
{
	CWnd* pParentFrame = GetDockSiteFrameWnd();

	if (pParentFrame == NULL || afxGlobalUtils.m_bDialogApp)
	{
		return NULL;
	}

	ASSERT_VALID(pParentFrame);

	if (pParentFrame->IsKindOf(RUNTIME_CLASS(CFrameWndEx)))
	{
		return ((CFrameWndEx*) pParentFrame)->PaneFromPoint(point, nSensitivity, bExactBar, pRTCBarType);
	}
	else if (pParentFrame->IsKindOf(RUNTIME_CLASS(CMDIFrameWndEx)))
	{
		return ((CMDIFrameWndEx*) pParentFrame)->PaneFromPoint(point, nSensitivity, bExactBar, pRTCBarType);
	}
	else if (pParentFrame->IsKindOf(RUNTIME_CLASS(COleIPFrameWndEx)))
	{
		return ((COleIPFrameWndEx*) pParentFrame)->PaneFromPoint(point, nSensitivity, bExactBar, pRTCBarType);
	}
	else if (pParentFrame->IsKindOf(RUNTIME_CLASS(COleDocIPFrameWndEx)))
	{
		return ((COleDocIPFrameWndEx*) pParentFrame)->PaneFromPoint(point, nSensitivity, bExactBar, pRTCBarType);
	}
	else if (pParentFrame->IsKindOf(RUNTIME_CLASS(CMDIChildWndEx)))
	{
		return ((CMDIChildWndEx*) pParentFrame)->PaneFromPoint(point, nSensitivity, bExactBar, pRTCBarType);
	}
	else if (pParentFrame->IsKindOf(RUNTIME_CLASS(COleCntrFrameWndEx)))
	{
		return ((COleCntrFrameWndEx*) pParentFrame)->PaneFromPoint(point, nSensitivity, bExactBar, pRTCBarType);
	}
	else
	{
		ASSERT(FALSE);
	}
	return FALSE;
}

BOOL CBasePane::InsertPane(CBasePane* pControlBar, CBasePane* pTarget, BOOL bAfter)
{
	CMultiPaneFrameWnd* pParentMiniFrame = DYNAMIC_DOWNCAST(CMultiPaneFrameWnd, GetParentMiniFrame());
	if (pParentMiniFrame != NULL)
	{
		return pParentMiniFrame->InsertPane(pControlBar, pTarget, bAfter);
	}

	CWnd* pParentFrame = GetDockSiteFrameWnd();

	if (pParentFrame == NULL || afxGlobalUtils.m_bDialogApp)
	{
		return TRUE;
	}

	ASSERT_VALID(pParentFrame);

	if (pParentFrame->IsKindOf(RUNTIME_CLASS(CFrameWndEx)))
	{
		return ((CFrameWndEx*) pParentFrame)->InsertPane(pControlBar, pTarget, bAfter);
	}
	else if (pParentFrame->IsKindOf(RUNTIME_CLASS(CMDIFrameWndEx)))
	{
		return ((CMDIFrameWndEx*) pParentFrame)->InsertPane(pControlBar, pTarget, bAfter);
	}
	else if (pParentFrame->IsKindOf(RUNTIME_CLASS(COleIPFrameWndEx)))
	{
		return ((COleIPFrameWndEx*) pParentFrame)->InsertPane(pControlBar, pTarget, bAfter);
	}
	else if (pParentFrame->IsKindOf(RUNTIME_CLASS(COleDocIPFrameWndEx)))
	{
		return ((COleDocIPFrameWndEx*) pParentFrame)->InsertPane(pControlBar, pTarget, bAfter);
	}
	else if (pParentFrame->IsKindOf(RUNTIME_CLASS(CMDIChildWndEx)))
	{
		return ((CMDIChildWndEx*) pParentFrame)->InsertPane(pControlBar, pTarget, bAfter);
	}
	else if (pParentFrame->IsKindOf(RUNTIME_CLASS(COleCntrFrameWndEx)))
	{
		return ((COleCntrFrameWndEx*) pParentFrame)->InsertPane(pControlBar, pTarget, bAfter);
	}
	else
	{
		ASSERT(FALSE);
	}
	return FALSE;
}

void CBasePane::AdjustDockingLayout(HDWP hdwp)
{
	CPaneFrameWnd* pParentMiniFrame = GetParentMiniFrame();

	if (pParentMiniFrame != NULL)
	{
		pParentMiniFrame->OnPaneRecalcLayout();
		return;
	}

	CWnd* pParentFrame = GetDockSiteFrameWnd();

	if (afxGlobalUtils.m_bDialogApp || pParentFrame == NULL)
	{
		return;
	}

	ASSERT_VALID(pParentFrame);

	if (pParentFrame->IsKindOf(RUNTIME_CLASS(CFrameWndEx)))
	{
		((CFrameWndEx*) pParentFrame)->AdjustDockingLayout(hdwp);
	}
	else if (pParentFrame->IsKindOf(RUNTIME_CLASS(CMDIFrameWndEx)))
	{
		((CMDIFrameWndEx*) pParentFrame)->AdjustDockingLayout(hdwp);
	}
	else if (pParentFrame->IsKindOf(RUNTIME_CLASS(COleIPFrameWndEx)))
	{
		((COleIPFrameWndEx*) pParentFrame)->AdjustDockingLayout(hdwp);
	}
	else if (pParentFrame->IsKindOf(RUNTIME_CLASS(COleDocIPFrameWndEx)))
	{
		((COleDocIPFrameWndEx*) pParentFrame)->AdjustDockingLayout(hdwp);
	}
	else if (pParentFrame->IsKindOf(RUNTIME_CLASS(CMDIChildWndEx)))
	{
		((CMDIChildWndEx*) pParentFrame)->AdjustDockingLayout(hdwp);
	}
	else if (pParentFrame->IsKindOf(RUNTIME_CLASS(COleCntrFrameWndEx)))
	{
		((COleCntrFrameWndEx*) pParentFrame)->AdjustDockingLayout(hdwp);
	}
	else
	{
		ASSERT(FALSE);
	}
}

void CBasePane::DockPaneUsingRTTI(BOOL bUseDocSite)
{
	CWnd* pParentFrame = bUseDocSite ? m_pDockSite : (CWnd*) AFXGetParentFrame(this);

	if (pParentFrame == NULL || afxGlobalUtils.m_bDialogApp)
	{
		return;
	}

	ASSERT_VALID(pParentFrame);

	if (pParentFrame->IsKindOf(RUNTIME_CLASS(CFrameWndEx)))
	{
		((CFrameWndEx*) pParentFrame)->DockPane(this);
	}
	else if (pParentFrame->IsKindOf(RUNTIME_CLASS(CMDIFrameWndEx)))
	{
		((CMDIFrameWndEx*) pParentFrame)->DockPane(this);
	}
	else if (pParentFrame->IsKindOf(RUNTIME_CLASS(COleIPFrameWndEx)))
	{
		((COleIPFrameWndEx*) pParentFrame)->DockPane(this);
	}
	else if (pParentFrame->IsKindOf(RUNTIME_CLASS(COleDocIPFrameWndEx)))
	{
		((COleDocIPFrameWndEx*) pParentFrame)->DockPane(this);
	}
	else if (pParentFrame->IsKindOf(RUNTIME_CLASS(CMDIChildWndEx)))
	{
		((CMDIChildWndEx*) pParentFrame)->DockPane(this);
	}
	else if (pParentFrame->IsKindOf(RUNTIME_CLASS(COleCntrFrameWndEx)))
	{
		((COleCntrFrameWndEx*) pParentFrame)->DockPane(this);
	}
	else
	{
		ASSERT(FALSE);
	}
}

void CBasePane::ShowPane(BOOL bShow, BOOL bDelay, BOOL bActivate)
{
	int nShowCmd = bShow ? SW_SHOWNOACTIVATE : SW_HIDE;

	if (IsFloating() && !IsTabbed())
	{
		ShowWindow(nShowCmd);

		CWnd* pParent = GetParent();
		ASSERT_VALID(pParent);

		if (!bDelay || !bShow)
		{
			// call ShowWindow only if no delay or if we need to hide the pane
			pParent->ShowWindow(nShowCmd);
		}
		
		pParent->PostMessage(AFX_WM_CHECKEMPTYMINIFRAME);
	}
	else if (m_pParentDockBar != NULL)
	{
		m_pParentDockBar->ShowPane(this, bShow, bDelay, bActivate);
	}
	else if (IsTabbed())
	{
		HWND hWndTab = NULL;
		CMFCBaseTabCtrl* pTabParent = GetParentTabWnd(hWndTab);
		ASSERT_VALID(pTabParent);

		CBaseTabbedPane* pTabbedControlBar = DYNAMIC_DOWNCAST(CBaseTabbedPane, pTabParent->GetParent());

		if (pTabbedControlBar != NULL && !pTabbedControlBar->IsPaneVisible() && pTabbedControlBar->GetTabsNum() > 1 && bShow)
		{
			pTabbedControlBar->ShowTab(this, TRUE, bDelay, bActivate);
			return;
		}

		if (pTabbedControlBar != NULL)
		{
			ASSERT_VALID(pTabbedControlBar);
			pTabbedControlBar->ShowTab(this, bShow, bDelay, bActivate);

			if (pTabParent->GetVisibleTabsNum() == 0)
			{
				pTabbedControlBar->ShowPane(bShow, bDelay, bActivate);
			}
		}
		else
		{
			int iTab = pTabParent->GetTabFromHwnd(GetSafeHwnd());
			pTabParent->ShowTab(iTab, bShow, !bDelay);
		}
	}
	else
	{
		ShowWindow(nShowCmd);
		if (!bDelay)
		{
			AdjustDockingLayout();
		}
	}

	if (GetPaneRow() != NULL)
	{
		GetPaneRow()->FixupVirtualRects(false);
	}
}

LRESULT CBasePane::OnIdleUpdateCmdUI(WPARAM wParam, LPARAM)
{
	// the style must be visible and if it is docked
	// the dockbar style must also be visible
	if ((GetStyle() & WS_VISIBLE) &&
		(m_pParentDockBar == NULL || (m_pParentDockBar->GetStyle() & WS_VISIBLE)))
	{
		CFrameWnd* pTarget = (CFrameWnd*)GetOwner();
		if (pTarget == NULL || !pTarget->IsFrameWnd())
			pTarget = AFXGetParentFrame(this);
		if (pTarget != NULL)
			OnUpdateCmdUI(pTarget, (BOOL)wParam);
	}

	return 0L;
}

void CBasePane::OnSize(UINT nType, int cx, int cy)
{
	CWnd::OnSize(nType, cx, cy);

	if (m_pDockBarRow != NULL)
	{
		m_pDockBarRow->OnResizePane(this);
	}
}

void CBasePane::Serialize(CArchive& ar)
{
	CWnd::Serialize(ar);

	if (ar.IsLoading())
	{
		DWORD dwAlign = 0;
		ar >> dwAlign;
		m_dwStyle |= dwAlign;

		ar >> m_bRecentVisibleState;
	}
	else
	{
		ar << (m_dwStyle & CBRS_ALIGN_ANY);
		ar << IsVisible();
	}
}

BOOL CBasePane::LoadState(LPCTSTR lpszProfileName, int nIndex, UINT uiID)
{
	CString strProfileName = ::AFXGetRegPath(strBaseControlBarProfile, lpszProfileName);

	if (nIndex == -1)
	{
		nIndex = GetDlgCtrlID();
	}

	CString strSection;
	if (uiID == (UINT) -1)
	{
		strSection.Format(AFX_REG_SECTION_FMT, (LPCTSTR)strProfileName, nIndex);
	}
	else
	{
		strSection.Format(AFX_REG_SECTION_FMT_EX, (LPCTSTR)strProfileName, nIndex, uiID);
	}

	CSettingsStoreSP regSP;
	CSettingsStore& reg = regSP.Create(FALSE, TRUE);

	if (!reg.Open(strSection))
	{
		return FALSE;
	}

	reg.Read(_T("IsVisible"), m_bRecentVisibleState);
	m_bIsRestoredFromRegistry = TRUE;

	return TRUE;
}

BOOL CBasePane::SaveState(LPCTSTR lpszProfileName, int nIndex, UINT uiID)
{

	CString strProfileName = ::AFXGetRegPath(strBaseControlBarProfile, lpszProfileName);

	if (nIndex == -1)
	{
		nIndex = GetDlgCtrlID();
	}

	CString strSection;
	if (uiID == (UINT) -1)
	{
		strSection.Format(AFX_REG_SECTION_FMT, (LPCTSTR)strProfileName, nIndex);
	}
	else
	{
		strSection.Format(AFX_REG_SECTION_FMT_EX, (LPCTSTR)strProfileName, nIndex, uiID);
	}

	CSettingsStoreSP regSP;
	CSettingsStore& reg = regSP.Create(FALSE, FALSE);

	if (reg.CreateKey(strSection))
	{
		BOOL bIsVisible = IsVisible();
		reg.Write(_T("IsVisible"), bIsVisible);
	}

	return TRUE;
}

CWnd* CBasePane::GetDockSiteFrameWnd() const
{
	if (m_pDockSite == NULL && GetParent()->IsKindOf(RUNTIME_CLASS(CDialog)) && GetParent()->GetSafeHwnd() == AfxGetMainWnd()->GetSafeHwnd())
	{
		afxGlobalUtils.m_bDialogApp = TRUE;
	}

	return m_pDockSite;
}

AFX_DOCK_TYPE CBasePane::GetDockingMode() const
{
	if (m_dockMode != DT_UNDEFINED)
	{
		return m_dockMode;
	}

	return CDockingManager::GetDockingMode();
}

BOOL CBasePane::CanFloat() const
{
	if (!IsTabbed())
	{
		return m_dwControlBarStyle & AFX_CBRS_FLOAT;
	}

	HWND hWndTab = NULL;

	CMFCBaseTabCtrl* pParentTabWnd = GetParentTabWnd(hWndTab);

	if (pParentTabWnd == NULL)
	{
		return m_dwControlBarStyle & AFX_CBRS_FLOAT;
	}

	int nTabNum = pParentTabWnd->GetTabFromHwnd(hWndTab);
	if (nTabNum == -1)
	{
		return m_dwControlBarStyle & AFX_CBRS_FLOAT;
	}

	return pParentTabWnd->IsTabDetachable(nTabNum);
}

CMFCBaseTabCtrl* CBasePane::GetParentTabWnd(HWND& hWndTab) const
{
	ASSERT_VALID(this);

	const CWnd* pWndToCheck = this;

	CDockablePaneAdapter* pWrapper = DYNAMIC_DOWNCAST(CDockablePaneAdapter, GetParent());
	if (pWrapper != NULL)
	{
		pWndToCheck = pWrapper;
		hWndTab = pWrapper->GetSafeHwnd();
	}
	else
	{
		hWndTab = GetSafeHwnd();
	}

	CMFCBaseTabCtrl* pParentTabWnd = DYNAMIC_DOWNCAST(CMFCBaseTabCtrl, pWndToCheck->GetParent());
	if (pParentTabWnd == NULL)
	{
		CBaseTabbedPane* pParentTabBar = DYNAMIC_DOWNCAST(CBaseTabbedPane, pWndToCheck->GetParent());
		if (pParentTabBar != NULL)
		{
			return pParentTabBar->GetUnderlyingWindow();
		}
	}

	return pParentTabWnd;
}

CBaseTabbedPane* CBasePane::GetParentTabbedPane() const
{
	HWND hWndTab = NULL;

	if (!IsTabbed())
	{
		return NULL;
	}

	CMFCBaseTabCtrl* pTabWnd = GetParentTabWnd(hWndTab);
	if (hWndTab == NULL || pTabWnd == NULL)
	{
		return NULL;
	}

	ASSERT_VALID(pTabWnd);

	return DYNAMIC_DOWNCAST(CBaseTabbedPane, pTabWnd->GetParent());
}

LRESULT CBasePane::OnHelpHitTest(WPARAM, LPARAM lParam)
{
	ASSERT_VALID(this);

	INT_PTR nID = OnToolHitTest((DWORD_PTR)lParam, NULL);
	if (nID != -1)
		return HID_BASE_COMMAND+nID;

	nID = _AfxGetDlgCtrlID(m_hWnd);
	return nID != 0 ? HID_BASE_CONTROL+nID : 0;
}

LRESULT CBasePane::WindowProc(UINT message, WPARAM wParam, LPARAM lParam)
{
	ASSERT_VALID(this);

	LRESULT lResult;
	switch (message)
	{
	case WM_NOTIFY:
	case WM_COMMAND:
	case WM_DRAWITEM:
	case WM_MEASUREITEM:
	case WM_DELETEITEM:
	case WM_COMPAREITEM:
	case WM_VKEYTOITEM:
	case WM_CHARTOITEM:
		// send these messages to the owner if not handled
		if (OnWndMsg(message, wParam, lParam, &lResult))
			return lResult;
		else
		{
			// try owner next
			lResult = GetOwner()->SendMessage(message, wParam, lParam);

			// special case for TTN_NEEDTEXTA and TTN_NEEDTEXTW
			if (message == WM_NOTIFY)
			{
				NMHDR* pNMHDR = (NMHDR*)lParam;
				if (pNMHDR->code == TTN_NEEDTEXTA || pNMHDR->code == TTN_NEEDTEXTW)
				{
					TOOLTIPTEXTA* pTTTA = (TOOLTIPTEXTA*)pNMHDR;
					TOOLTIPTEXTW* pTTTW = (TOOLTIPTEXTW*)pNMHDR;

					if (pNMHDR->code == TTN_NEEDTEXTA)
					{
						if (pTTTA->hinst == 0 && (!pTTTA->lpszText || !*pTTTA->lpszText))
						{
							// not handled by owner, so let bar itself handle it
							lResult = CWnd::WindowProc(message, wParam, lParam);
						}
					}
					else if (pNMHDR->code == TTN_NEEDTEXTW)
					{
						if (pTTTW->hinst == 0 && (!pTTTW->lpszText || !*pTTTW->lpszText))
						{
							// not handled by owner, so let bar itself handle it
							lResult = CWnd::WindowProc(message, wParam, lParam);
						}
					}
				}
			}
			return lResult;
		}
	}

	// otherwise, just handle in default way
	lResult = CWnd::WindowProc(message, wParam, lParam);
	return lResult;
}

BOOL CBasePane::PreTranslateMessage(MSG* pMsg)
{
	ASSERT_VALID(this);
	ENSURE(m_hWnd != NULL);

	if (CWnd::PreTranslateMessage(pMsg))
		return TRUE;

	CWnd* pOwner = GetOwner();

	// don't translate dialog messages when in Shift+F1 help mode
	CFrameWnd* pFrameWnd = GetTopLevelFrame();
	if (pFrameWnd != NULL && pFrameWnd->m_bHelpMode)
		return FALSE;

	// since 'IsDialogMessage' will eat frame window accelerators,
	//   we call all frame windows' PreTranslateMessage first
	while (pOwner != NULL)
	{
		// allow owner & frames to translate before IsDialogMessage does
		if (pOwner->PreTranslateMessage(pMsg))
			return TRUE;

		// try parent frames until there are no parent frames
		if (IsWindow(pOwner->GetSafeHwnd()))
		{
			pOwner = pOwner->GetParentFrame();
		}
		else
		{
			break;
		}
	}

	// filter both messages to dialog and from children
	return PreTranslateInput(pMsg);
}

LRESULT CBasePane::HandleInitDialog(WPARAM, LPARAM)
{
	if (m_lpszBarTemplateName != NULL)
	{
		if (!ExecuteDlgInit(m_lpszBarTemplateName))
		{
			return FALSE;
		}
	}

	if (!UpdateData(FALSE))
	{
		return FALSE;
	}

	return TRUE;
}

LRESULT CBasePane::OnSetIcon(WPARAM,LPARAM)
{
	LRESULT lres = Default();

	if (IsTabbed())
	{
		HWND hWndTab = NULL;
		CMFCBaseTabCtrl* pParentTab = GetParentTabWnd(hWndTab);

		ASSERT_VALID(pParentTab);

		int iTabNum = pParentTab->GetTabFromHwnd(hWndTab);

		if (iTabNum >= 0 && iTabNum < pParentTab->GetTabsNum())
		{
			pParentTab->SetTabHicon(iTabNum, GetIcon(FALSE));
		}
	}

	return lres;
}

LRESULT CBasePane::OnGetObject(WPARAM wParam, LPARAM lParam)
{
	if (afxGlobalData.IsAccessibilitySupport() && IsAccessibilityCompatible())
	{
		return CWnd::OnGetObject(wParam, lParam);
	}

	return (LRESULT)0L;
}

BOOL CBasePane::OnSetAccData(long /*lVal*/)
{
	return TRUE;
}

DWORD CBasePane::GetCurrentAlignment() const
{
	return m_dwStyle & CBRS_ALIGN_ANY;
}

void CBasePane::CopyState(CBasePane* pOrgBar)
{
	ASSERT_VALID(pOrgBar);

	m_dwEnabledAlignment = pOrgBar->GetEnabledAlignment();
	m_bRecentVisibleState = pOrgBar->GetRecentVisibleState();
	m_bIsRestoredFromRegistry = pOrgBar->IsRestoredFromRegistry();
	m_pDockSite = pOrgBar->GetDockSiteFrameWnd();
	m_rectBar = pOrgBar->GetPaneRect();
	m_bIsDlgControl = pOrgBar->IsDialogControl();
	m_dwStyle = pOrgBar->GetPaneStyle();
	m_dwControlBarStyle = pOrgBar->GetControlBarStyle();
}

void CBasePane::OnSettingChange(UINT uFlags, LPCTSTR lpszSection)
{
	CWnd::OnSettingChange(uFlags, lpszSection);
	afxGlobalData.OnSettingChange();
}

void CBasePane::OnPaneContextMenu(CWnd* pParentFrame, CPoint point)
{
	ASSERT_VALID(pParentFrame);

	if (pParentFrame->SendMessage(AFX_WM_TOOLBARMENU, (WPARAM) GetSafeHwnd(), MAKELPARAM(point.x, point.y)) == 0)
	{
		return;
	}

	CDockingManager* pDockManager = afxGlobalUtils.GetDockingManager(GetParentFrame());
	if (pDockManager == NULL)
	{
		return;
	}

	ASSERT_VALID(pDockManager);
	pDockManager->OnPaneContextMenu(point);
}

HRESULT CBasePane::get_accChildCount(long *pcountChildren)
{
	if (!pcountChildren)
	{
		return E_INVALIDARG;
	}

	*pcountChildren = 0;
	return S_OK;
}

HRESULT CBasePane::get_accParent(IDispatch **ppdispParent)
{
	HRESULT hr = E_INVALIDARG;

	if (ppdispParent)
	{
		CWnd* pWnd = GetParent();
		if (pWnd)
		{
			AccessibleObjectFromWindow(pWnd->GetSafeHwnd () , (DWORD) OBJID_CLIENT, IID_IAccessible, (void**) ppdispParent);

			hr  = (*ppdispParent) ? S_OK : S_FALSE;
		}
	}

	return hr;
}

HRESULT CBasePane::get_accChild(VARIANT varChild, IDispatch **ppdispChild)
{
	if (!(*ppdispChild))
	{
		return E_INVALIDARG;
	}

	if ((varChild.vt == VT_I4) && (varChild.lVal == CHILDID_SELF))
	{
		return E_INVALIDARG;
	}

	if (m_pStdObject != NULL)
	{
		*ppdispChild = m_pStdObject;
	}
	else
	{
		*ppdispChild = NULL;
	}

	return S_OK;
}

HRESULT CBasePane::get_accName(VARIANT varChild, BSTR *pszName)
{
	if ((varChild.vt == VT_I4) && (varChild.lVal == CHILDID_SELF))
	{
		CString strText;
		GetWindowText(strText);
		*pszName = strText.AllocSysString();
		return S_OK;
	}

	if ((varChild.vt == VT_I4) && (varChild.lVal > 0))
	{
		OnSetAccData(varChild.lVal);
		if (m_AccData.m_strAccName.IsEmpty())
		{
			return S_FALSE;
		}
		*pszName = m_AccData.m_strAccName.AllocSysString();
	}

	return S_OK;
}

HRESULT CBasePane::get_accDescription(VARIANT varChild, BSTR *pszDescription)
{
	if ((varChild.vt == VT_I4) && (varChild.lVal == CHILDID_SELF))
	{
		CString strText;
		GetWindowText(strText);
		*pszDescription = strText.AllocSysString();
		return S_OK;
	}

	if ((varChild.vt == VT_I4) && (varChild.lVal > 0))
	{
		OnSetAccData(varChild.lVal);
		if (m_AccData.m_strDescription.IsEmpty())
		{
			return S_FALSE;
		}
		*pszDescription = m_AccData.m_strDescription.AllocSysString();
		return S_OK;
	}

	return S_FALSE;
}

HRESULT CBasePane::get_accRole(VARIANT varChild, VARIANT *pvarRole)
{
	if ((varChild.vt == VT_I4) && (varChild.lVal == CHILDID_SELF))
	{
		pvarRole->vt = VT_I4;
		pvarRole->lVal = ROLE_SYSTEM_TOOLBAR;
		return S_OK;
	}

	if (!pvarRole || ((varChild.vt != VT_I4) && (varChild.lVal != CHILDID_SELF)))
	{
		return E_INVALIDARG;
	}

	if ((varChild.vt == VT_I4) && (varChild.lVal > 0))
	{
		pvarRole->vt = VT_I4;
		OnSetAccData(varChild.lVal);
		pvarRole->lVal = m_AccData.m_nAccRole;
		return S_OK;
	}

	pvarRole->vt = VT_I4;
	pvarRole->lVal = ROLE_SYSTEM_PUSHBUTTON;

	return S_OK;
}

HRESULT CBasePane::get_accState(VARIANT varChild, VARIANT *pvarState)
{
	if ((varChild.vt == VT_I4) && (varChild.lVal == CHILDID_SELF))
	{
		pvarState->vt = VT_I4;
		pvarState->lVal = STATE_SYSTEM_DEFAULT;
		return S_OK;
	}

	if (!pvarState || ((varChild.vt != VT_I4) && (varChild.lVal != CHILDID_SELF)))
	{
		return E_INVALIDARG;
	}

	if ((varChild.vt == VT_I4) && (varChild.lVal > 0))
	{
		OnSetAccData(varChild.lVal);
		pvarState->vt = VT_I4;
		pvarState->lVal = m_AccData.m_bAccState;
		return S_OK; 
	}

	return E_INVALIDARG;
}

HRESULT CBasePane::get_accHelp(VARIANT varChild, BSTR *pszHelp)
{
	if ((varChild.vt == VT_I4) && (varChild.lVal == CHILDID_SELF))
	{
		*pszHelp = SysAllocString(L"ControlPane");
		return S_OK;
	}

	if (((varChild.vt != VT_I4) && (varChild.lVal != CHILDID_SELF)) || (NULL == pszHelp))
	{
		return E_INVALIDARG;
	}

	OnSetAccData(varChild.lVal);
	if (m_AccData.m_strAccHelp.IsEmpty())
	{
		return S_FALSE;
	}

	*pszHelp = m_AccData.m_strAccHelp.AllocSysString();
	return S_OK;
}

HRESULT CBasePane::get_accFocus(VARIANT *pvarChild)
{
	if (NULL == pvarChild)
	{
		return E_INVALIDARG;
	}

	return DISP_E_MEMBERNOTFOUND; 
}

HRESULT CBasePane::get_accSelection(VARIANT *pvarChildren)
{
	if (NULL == pvarChildren)
	{
		return E_INVALIDARG;
	}

	return DISP_E_MEMBERNOTFOUND; 
}

HRESULT CBasePane::get_accHelpTopic(BSTR* /*pszHelpFile*/, VARIANT /*varChild*/, long* /*pidTopic*/)
{
	return S_FALSE;
}

HRESULT CBasePane::get_accKeyboardShortcut(VARIANT varChild, BSTR *pszKeyboardShortcut)
{
	if ((varChild.vt != VT_I4) && (varChild.lVal != CHILDID_SELF))
	{
		return E_INVALIDARG;
	}

	if ((varChild.vt == VT_I4) && (varChild.lVal == CHILDID_SELF))
	{
		*pszKeyboardShortcut = SysAllocString(L"");
		return S_OK;
	}

	if (!pszKeyboardShortcut || ((varChild.vt != VT_I4) && (varChild.lVal != CHILDID_SELF)))
	{
		return E_INVALIDARG;
	}

	if ((varChild.vt == VT_I4) && (varChild.lVal > 0))
	{
		OnSetAccData(varChild.lVal);
		if (m_AccData.m_strAccKeys.IsEmpty())
		{
			return S_FALSE;
		}

		*pszKeyboardShortcut = m_AccData.m_strAccKeys.AllocSysString();
		return S_OK;
	}

	return S_FALSE;
}

HRESULT CBasePane::get_accDefaultAction(VARIANT varChild, BSTR *pszDefaultAction)
{
	if ((varChild.vt == VT_I4) && (varChild.lVal == CHILDID_SELF))
	{
		return S_FALSE;
	}

	if ((varChild.vt != VT_I4) && (varChild.lVal != CHILDID_SELF))
	{
		return E_INVALIDARG;
	}

	OnSetAccData(varChild.lVal);

	if (m_AccData.m_strAccDefAction.IsEmpty())
	{
		return S_FALSE;
	}

	*pszDefaultAction = m_AccData.m_strAccDefAction.AllocSysString();
	return S_OK;
}

HRESULT CBasePane::accSelect(long flagsSelect, VARIANT varChild)
{
	if (m_pStdObject != NULL)
	{
		return m_pStdObject->accSelect(flagsSelect, varChild); 
	}

	return E_INVALIDARG;
}

HRESULT CBasePane::accLocation(long *pxLeft, long *pyTop, long *pcxWidth, long *pcyHeight, VARIANT varChild)
{
	if( !pxLeft || !pyTop || !pcxWidth || !pcyHeight )
	{
		return E_INVALIDARG;
	}

	if ((varChild.vt == VT_I4) && (varChild.lVal == CHILDID_SELF))
	{
		CRect rc;
		GetWindowRect(rc);

		*pxLeft = rc.left;
		*pyTop = rc.top;
		*pcxWidth = rc.Width();
		*pcyHeight = rc.Height();

		return S_OK;
	}

	if ((varChild.vt == VT_I4) && (varChild.lVal > 0))
	{
		OnSetAccData(varChild.lVal);

		*pxLeft = m_AccData.m_rectAccLocation.left;
		*pyTop = m_AccData.m_rectAccLocation.top;
		*pcxWidth = m_AccData.m_rectAccLocation.Width();
		*pcyHeight = m_AccData.m_rectAccLocation.Height();
		return S_OK;
	}

	return S_OK;
}

HRESULT CBasePane::accHitTest(long xLeft, long yTop, VARIANT *pvarChild)
{
	if (!pvarChild)
	{
		return E_INVALIDARG;
	}

	OnSetAccData((LONG)MAKELPARAM((WORD)xLeft, (WORD)yTop));

	if (m_AccData.m_nAccHit != 0)
	{
		pvarChild->vt = VT_I4;
		LPARAM lParam = MAKELPARAM((WORD)xLeft, (WORD)yTop);
		pvarChild->lVal = (LONG)lParam;
	}
	else
	{
		pvarChild->vt = VT_I4;
		pvarChild->lVal = CHILDID_SELF;
	}

	return S_OK;
}

HRESULT CBasePane::get_accValue(VARIANT varChild, BSTR *pszValue)
{
	if ((varChild.vt == VT_I4) && (varChild.lVal > 0))
	{
		OnSetAccData(varChild.lVal);
		if (m_AccData.m_strAccValue.IsEmpty())
		{
			return S_FALSE;
		}
		*pszValue = m_AccData.m_strAccValue.AllocSysString();
	}
	else
	{
		return S_FALSE;
	}

	return S_OK;
}

LRESULT CBasePane::OnPrintClient(WPARAM wp, LPARAM lp)
{
	DWORD dwFlags = (DWORD)lp;

	if (dwFlags & PRF_ERASEBKGND)
	{
		SendMessage(WM_ERASEBKGND, wp);
	}

	if (dwFlags & PRF_CLIENT)
	{
		CDC* pDC = CDC::FromHandle((HDC) wp);
		ASSERT_VALID(pDC);

		DoPaint(pDC);
	}

	return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\src\mfc\afxbasetabctrl.cpp ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#include "stdafx.h"
#include "afxcontrolbarutil.h"
#include "afxbasetabctrl.h"
#include "afxdockablepane.h"
#include "afxdockablepaneadapter.h"
#include "afxbasetabbedpane.h"
#include "afxpaneframewnd.h"
#include "afxdockingmanager.h"
#include "afxglobalutils.h"
#include "afxmdiclientareawnd.h"
#include "afxtooltipmanager.h"
#include "afxribbonres.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#endif

/////////////////////////////////////////////////////////////////////////////
// CMFCTabDropTarget message handlers

BOOL CMFCTabDropTarget::Register(CMFCBaseTabCtrl *pOwner)
{
	m_pOwner = pOwner;
	return COleDropTarget::Register(pOwner);
}

DROPEFFECT CMFCTabDropTarget::OnDragEnter(CWnd* /*pWnd*/, COleDataObject* pDataObject, DWORD dwKeyState, CPoint point)
{
	ENSURE(m_pOwner != NULL);

	if (!CMFCToolBar::IsCustomizeMode() || !pDataObject->IsDataAvailable(CMFCToolBarButton::m_cFormat))
	{
		return DROPEFFECT_NONE;
	}

	return m_pOwner->OnDragEnter(pDataObject, dwKeyState, point);
}

void CMFCTabDropTarget::OnDragLeave(CWnd* /*pWnd*/)
{
	ENSURE(m_pOwner != NULL);
	m_pOwner->OnDragLeave();
}

DROPEFFECT CMFCTabDropTarget::OnDragOver(CWnd* /*pWnd*/, COleDataObject* pDataObject, DWORD dwKeyState, CPoint point)
{
	ENSURE(m_pOwner != NULL);

	if (!CMFCToolBar::IsCustomizeMode() || !pDataObject->IsDataAvailable(CMFCToolBarButton::m_cFormat))
	{
		if (m_pOwner != NULL)
		{
			int nTabIndex = m_pOwner->GetTabFromPoint(point);

			if (nTabIndex != -1 && nTabIndex != m_pOwner->GetActiveTab())
			{
				m_pOwner->SetActiveTab(nTabIndex);
			}
		}

		return(DROPEFFECT_NONE);
	}


	return m_pOwner->OnDragOver(pDataObject, dwKeyState, point);
}

DROPEFFECT CMFCTabDropTarget::OnDropEx(CWnd* /*pWnd*/, COleDataObject* pDataObject, DROPEFFECT dropEffect, DROPEFFECT /*dropList*/, CPoint point)
{
	ENSURE(m_pOwner != NULL);

	if (!CMFCToolBar::IsCustomizeMode() || !pDataObject->IsDataAvailable(CMFCToolBarButton::m_cFormat))
	{
		return DROPEFFECT_NONE;
	}

	return m_pOwner->OnDrop(pDataObject, dropEffect, point) ? dropEffect : DROPEFFECT_NONE;
}

/////////////////////////////////////////////////////////////////////////////
// CMFCBaseTabCtrl

int CMFCBaseTabCtrl::AFX_TAB_TEXT_MARGIN = 4;
int CMFCBaseTabCtrl::AFX_TAB_IMAGE_MARGIN = 4;

#define AFX_DEFAULT_TAB_BORDER_SIZE 2

UINT AFX_WM_ON_RENAME_TAB = ::RegisterWindowMessage(_T("AFX_WM_ON_RENAME_TAB"));
UINT AFX_WM_CHANGE_ACTIVE_TAB = ::RegisterWindowMessage(_T("AFX_WM_ONCHANGE_ACTIVE_TAB"));
UINT AFX_WM_ON_MOVE_TAB = ::RegisterWindowMessage(_T("AFX_WM_ON_MOVE_TAB"));
UINT AFX_WM_CHANGING_ACTIVE_TAB = ::RegisterWindowMessage(_T("AFX_WM_ON_CHANGING_ACTIVE_TAB"));
UINT AFX_WM_ON_GET_TAB_TOOLTIP = ::RegisterWindowMessage(_T("AFX_WM_ON_GET_TAB_TOOLTIP"));

IMPLEMENT_DYNAMIC(CMFCBaseTabCtrl, CWnd)

CMFCBaseTabCtrl::CMFCBaseTabCtrl()
{
	m_bAutoDestroyWindow = FALSE;
	m_iActiveTab = -1;
	m_iTabBeforeDrag = -1;
	m_iTabsNum = 0;

	m_sizeImage = CSize(0, 0);
	m_hImageList = NULL;

	m_iCurTab = -1;
	m_nNextTabID = 1;

	m_bCustomToolTips = FALSE;

	m_bHideInactiveWnd = TRUE;

	m_location = LOCATION_BOTTOM;
	m_bReadyToDetach = FALSE;
	m_ptHot = CPoint(0, 0);
	m_nOffsetFromTabLeft = 0;

	m_iHighlighted = -1;
	m_iPressed = -1;

	m_bActivateOnBtnUp = FALSE;

	m_bEnableTabSwap = TRUE;
	m_nRestoredActiveTabID = 0;

	m_pDockingBarWrapperRTC = NULL;

	m_bEnableWrapping = FALSE;

	m_clrActiveTabBk = (COLORREF) -1;
	m_clrActiveTabFg = (COLORREF) -1;

	m_nTabBorderSize = AFX_DEFAULT_TAB_BORDER_SIZE;

	m_nTabsHeight = 0;

	// in-place editing
	m_pInPlaceEdit = NULL;
	m_iEditedTab = -1;

	m_bIsInPlaceEdit = FALSE;
	m_bHideSingleTab = FALSE;

	m_bLabelNoPrefix = FALSE;
	m_bActivateLastVisibleTab = FALSE;
	m_bHighLightTabs = FALSE;

	m_bIsAutoColor = FALSE;
	m_bIsDefaultAutoColor = TRUE;

	m_bIsDlgControl = FALSE;

	m_iLastActiveTab = -1;
	m_bActivateLastActiveTab = FALSE;

	m_bIsMDITab = FALSE;
	m_bSetActiveTabFired = FALSE;
	m_bUserSelectedTab = FALSE;

	m_bSetActiveTabByMouseClick = FALSE;
	m_bActivateTabOnRightClick = FALSE;

	m_bWindowPosChanged = FALSE;

	m_pToolTip = NULL;
	m_pToolTipClose = NULL;

	m_bTabCloseButtonHighlighted = FALSE;
	m_bTabCloseButtonPressed = FALSE;
	m_rectCloseButton.SetRectEmpty();
}

CMFCBaseTabCtrl::~CMFCBaseTabCtrl()
{
}

//{{AFX_MSG_MAP(CMFCBaseTabCtrl)
BEGIN_MESSAGE_MAP(CMFCBaseTabCtrl, CWnd)
	ON_WM_LBUTTONDOWN()
	ON_WM_RBUTTONDOWN()
	ON_WM_LBUTTONUP()
	ON_WM_LBUTTONDBLCLK()
	ON_WM_MOUSEMOVE()
	ON_WM_CANCELMODE()
	ON_WM_DESTROY()
	ON_WM_CREATE()
	ON_WM_SYSCOLORCHANGE()
	ON_WM_WINDOWPOSCHANGED()
	ON_NOTIFY_EX_RANGE(TTN_NEEDTEXT, 0, 0xFFFF, &CMFCBaseTabCtrl::OnNeedTipText)
END_MESSAGE_MAP()
//}}AFX_MSG_MAP

/////////////////////////////////////////////////////////////////////////////
// CMFCBaseTabCtrl message handlers

void CMFCBaseTabCtrl::CleanUp()
{
	for (int i = 0; i < m_iTabsNum; i ++)
	{
		CMFCTabInfo* pTab = (CMFCTabInfo*) m_arTabs [i];
		ASSERT_VALID(pTab);

		// we need to delete tab info only in the case the contained window is not
		// derived from CPane, because CPane detects that it's
		// tabbed while processing OnDestroy and removes itself from the parent tabbed
		// window.
		if (pTab->m_pWnd->m_hWnd == NULL || ::IsWindow(pTab->m_pWnd->m_hWnd))
		{
			BOOL bDeleteTabInfo = !pTab->m_pWnd->IsKindOf(RUNTIME_CLASS(CPane));

			if (m_bAutoDestroyWindow)
			{
				pTab->m_pWnd->DestroyWindow();
			}

			if (bDeleteTabInfo || !m_bAutoDestroyWindow)
			{
				delete pTab;
			}
		}
	}

	CTooltipManager::DeleteToolTip(m_pToolTip);
	CTooltipManager::DeleteToolTip(m_pToolTipClose);

	m_arTabs.RemoveAll();
	m_iTabsNum = 0;
	m_iActiveTab = -1;
}

void CMFCBaseTabCtrl::AddTab(CWnd* pNewWnd, LPCTSTR lpszName, UINT uiImageId, BOOL bDetachable)
{
	if (pNewWnd->GetSafeHwnd() != NULL && pNewWnd->GetDlgCtrlID() == -1)
	{
		ASSERT(FALSE);
		TRACE0("Unable to add a new tab with control bar ID -1. \n");
		return;
	}

	CWnd* pWndToAdd = CreateWrapper(pNewWnd, lpszName, bDetachable);
	ASSERT_VALID(pWndToAdd);

	InsertTab(pWndToAdd, lpszName, -1, uiImageId, bDetachable);
}

void CMFCBaseTabCtrl::AddTab(CWnd* pTabWnd, UINT uiResTabLabel, UINT uiImageId, BOOL bDetachable)
{
	ASSERT_VALID(this);
	ASSERT_VALID(pTabWnd);

	if (pTabWnd->GetDlgCtrlID() == -1)
	{
		ASSERT(FALSE);
		TRACE0("Unable to add a new tab with control bar ID -1. \n");
		return;
	}

	CString strLabel;
	ENSURE(strLabel.LoadString(uiResTabLabel));

	CWnd* pWndToAdd = CreateWrapper(pTabWnd, strLabel, bDetachable);
	ASSERT_VALID(pWndToAdd);

	AddTab(pWndToAdd, strLabel, uiImageId, bDetachable);
}

void CMFCBaseTabCtrl::InsertTab(CWnd* pNewWnd, LPCTSTR lpszTabLabel, int nInsertAt, UINT uiImageId, BOOL bDetachable)
{
	ASSERT_VALID(this);
	ASSERT_VALID(pNewWnd);
	ENSURE(lpszTabLabel != NULL);

	CWnd* pWndToAdd = CreateWrapper(pNewWnd, lpszTabLabel, bDetachable);
	ASSERT_VALID(pWndToAdd);

	if (!IsWindowVisible())
	{
		ShowWindow(SW_SHOW);
	}

	if (nInsertAt < 0 || nInsertAt > m_iTabsNum)
	{
		nInsertAt = m_iTabsNum;
	}

	CWnd* pActiveWnd = GetActiveWnd();

	// can't detach non-docking control bar derived objects
	if (!pWndToAdd->IsKindOf(RUNTIME_CLASS(CDockablePane)))
	{
		bDetachable = FALSE;
	}

	m_arTabs.InsertAt(nInsertAt, new CMFCTabInfo(lpszTabLabel, uiImageId, pWndToAdd, m_nNextTabID, bDetachable));

	m_iTabsNum++;

	if (m_pToolTip->GetSafeHwnd() != NULL)
	{
		CRect rectEmpty(0, 0, 0, 0);
		m_pToolTip->AddTool(this, m_bCustomToolTips ? LPSTR_TEXTCALLBACK : lpszTabLabel, &rectEmpty, m_nNextTabID);
	}

	m_nNextTabID ++;

	OnChangeTabs();
	RecalcLayout();

	if (m_iTabsNum == 1)
	{
		//----------------------------------------
		// First tab automatically becames active:
		//----------------------------------------
		SetActiveTab(0);
	}
	else
	{
		m_iLastActiveTab = m_iActiveTab;

		if (m_iActiveTab == nInsertAt)
		{
			m_iLastActiveTab++;

			if (m_bHideInactiveWnd && pActiveWnd != NULL)
			{
				pActiveWnd->ShowWindow(SW_HIDE);
			}

			pWndToAdd->ShowWindow(SW_SHOWNORMAL);
		}
		else if (m_bHideInactiveWnd)
		{
			if (pWndToAdd->GetSafeHwnd() != NULL)
			{
				pWndToAdd->ShowWindow(SW_HIDE);
			}
		}
	}

	if (!m_bHideInactiveWnd && pActiveWnd != NULL && pActiveWnd->GetSafeHwnd() != NULL)
	{
		pActiveWnd->BringWindowToTop();
	}
}

void CMFCBaseTabCtrl::InsertTab(CWnd* pNewWnd, UINT uiResTabLabel, int nInsertAt, UINT uiImageId, BOOL bDetachable)
{
	ASSERT_VALID(this);
	ASSERT_VALID(pNewWnd);

	if (pNewWnd->GetDlgCtrlID() == -1)
	{
		ASSERT(FALSE);
		TRACE0("Unable to add a new tab with control bar ID -1. \n");
		return;
	}

	CString strLabel;
	ENSURE(strLabel.LoadString(uiResTabLabel));

	CWnd* pWndToAdd = CreateWrapper(pNewWnd, strLabel, bDetachable);
	ASSERT_VALID(pWndToAdd);

	InsertTab(pWndToAdd, strLabel, nInsertAt, uiImageId, bDetachable);
}

BOOL CMFCBaseTabCtrl::RemoveTab(int iTab, BOOL bRecalcLayout)
{
	if (iTab < 0 || iTab >= m_iTabsNum)
	{
		TRACE(_T("RemoveTab: illegal tab number %d\n"), iTab);
		return FALSE;
	}

	if (m_iTabsNum == 1)
	{
		RemoveAllTabs();
		return TRUE;
	}

	CMFCTabInfo* pTab = (CMFCTabInfo*) m_arTabs [iTab];
	ASSERT_VALID(pTab);

	if (m_pToolTip->GetSafeHwnd() != NULL)
	{
		m_pToolTip->DelTool(this, pTab->m_iTabID);
	}

	//----------------------------
	// Detach tab from collection:
	//----------------------------
	m_arTabs.RemoveAt(iTab);
	m_iTabsNum --;

	//-----------------------------------
	// Destroy tab window and delete tab:
	//-----------------------------------
	if (m_bAutoDestroyWindow)
	{
		ASSERT_VALID(pTab->m_pWnd);
		pTab->m_pWnd->DestroyWindow();
	}

	delete pTab;

	int iActiveTab = m_iActiveTab;
	if (m_iActiveTab >= iTab)
	{
		if (m_bActivateLastVisibleTab)
		{
			GetLastVisibleTab(iActiveTab);
		}
		else
		{
			// Find the next best tab to be activated
			for (int i = m_iTabsNum - 1; i >= 0; --i)
			{
				CMFCTabInfo* pNextActiveTab = (CMFCTabInfo*) m_arTabs [i];
				ASSERT_VALID(pNextActiveTab);

				if (i < iTab && iActiveTab >= 0 && iActiveTab < m_iTabsNum)
				{
					break;
				}

				if (pNextActiveTab->m_bVisible)
				{
					iActiveTab = i;
				}
			}
		}

		m_iActiveTab = -1;
	}

	OnChangeTabs();

	if (bRecalcLayout)
	{
		RecalcLayout();
		if (iActiveTab != -1)
		{
			if (m_bActivateLastActiveTab &&(m_iLastActiveTab != -1))
			{
				int iLastActiveTab = m_iLastActiveTab;
				if (iTab < m_iLastActiveTab)
				{
					iLastActiveTab = m_iLastActiveTab -1;
				}

				int iTabToActivate = -1;
				GetFirstVisibleTab(iLastActiveTab, iTabToActivate);

				SetActiveTab(iTabToActivate);
			}
			else
			{
				int iTabToActivate = -1;
				GetFirstVisibleTab(iActiveTab, iTabToActivate);
				SetActiveTab(iTabToActivate);
			}

			FireChangeActiveTab(m_iActiveTab);
		}
	}

	return TRUE;
}

void CMFCBaseTabCtrl::RemoveAllTabs()
{
	m_iActiveTab = -1;
	m_nNextTabID = 1;

	while (m_iTabsNum > 0)
	{
		CMFCTabInfo* pTab = (CMFCTabInfo*) m_arTabs [m_iTabsNum - 1];
		ASSERT_VALID(pTab);

		m_iTabsNum--;

		if (m_pToolTip->GetSafeHwnd() != NULL)
		{
			m_pToolTip->DelTool(this, pTab->m_iTabID);
		}

		if (m_bAutoDestroyWindow)
		{
			pTab->m_pWnd->DestroyWindow();
		}

		delete pTab;
	}

	if (m_pToolTip->GetSafeHwnd() != NULL)
	{
		ASSERT(m_pToolTip->GetToolCount() == 0);
	}

	m_arTabs.RemoveAll();

	OnChangeTabs();

	RecalcLayout();
	FireChangeActiveTab((UINT)-1);
}

int CMFCBaseTabCtrl::GetVisibleTabsNum() const
{
	int nCount = 0;

	for (int i = 0; i < m_iTabsNum; i++)
	{
		CMFCTabInfo* pTab = (CMFCTabInfo*) m_arTabs [i];
		ASSERT_VALID(pTab);

		if (pTab->m_bVisible)
		{
			nCount++;
		}
	}

	return nCount;
}

BOOL CMFCBaseTabCtrl::ShowTab(int iTab, BOOL bShow /*= TRUE*/, BOOL bRecalcLayout /*= TRUE*/, BOOL bActivate)
{
	if (iTab < 0 || iTab >= m_iTabsNum)
	{
		TRACE(_T("ShowTab: illegal tab number %d\n"), iTab);
		return FALSE;
	}

	CMFCTabInfo* pTab = (CMFCTabInfo*) m_arTabs [iTab];
	ASSERT_VALID(pTab);

	if (pTab->m_bVisible == bShow)
	{
		return TRUE;
	}

	int nVisibleCount = GetVisibleTabsNum();
	pTab->m_bVisible = bShow;

	int iActiveTab = (bShow ? m_iActiveTab : -1);

	if (!bShow)
	{
		//----------
		// Hide tab:
		//----------
		if (m_bHideInactiveWnd)
		{
			ASSERT_VALID(pTab->m_pWnd);
			pTab->m_pWnd->ShowWindow(SW_HIDE);
		}

		if (iTab == m_iActiveTab)
		{
			// Find the next best tab to be activated
			for (int i = m_iTabsNum - 1; i >= 0; --i)
			{
				CMFCTabInfo* pNextActiveTab = (CMFCTabInfo*) m_arTabs [i];
				ASSERT_VALID(pNextActiveTab);

				if (i < iTab && iActiveTab >= 0)
				{
					break;
				}

				if (pNextActiveTab->m_bVisible)
				{
					iActiveTab = i;
				}
			}

			m_iActiveTab = -1;
		}
	}

	// If there was no tab visible, activate this first one
	if (bShow && nVisibleCount == 0)
	{
		iActiveTab = iTab;
	}

	if (bRecalcLayout)
	{
		RecalcLayout();
	}

	if (iActiveTab >= 0 && !bShow && m_iActiveTab == -1 || bActivate || nVisibleCount == 0)
	{
		SetActiveTab(iActiveTab);
		FireChangeActiveTab(m_iActiveTab);
	}

	return TRUE;
}

CWnd* CMFCBaseTabCtrl::GetTabWnd(int iTab) const
{
	if (iTab >= 0 && iTab < m_iTabsNum)
	{
		CMFCTabInfo* pTab = (CMFCTabInfo*) m_arTabs [iTab];
		ASSERT_VALID(pTab);

		return pTab->m_pWnd;
	}
	else
	{
		return NULL;
	}
}

CWnd* CMFCBaseTabCtrl::GetTabWndNoWrapper(int iTab) const
{
	if (iTab >= 0 && iTab < m_iTabsNum)
	{
		CMFCTabInfo* pTab = (CMFCTabInfo*) m_arTabs [iTab];
		ASSERT_VALID(pTab);

		CDockablePaneAdapter* pWrapper = DYNAMIC_DOWNCAST(CDockablePaneAdapter, pTab->m_pWnd);
		if (pWrapper != NULL)
		{
			return pWrapper->GetWrappedWnd();
		}

		return pTab->m_pWnd;
	}
	else
	{
		return NULL;
	}
}

BOOL CMFCBaseTabCtrl::GetTabRect(int iTab, CRect& rect) const
{
	if (iTab < 0 || iTab >= m_iTabsNum)
	{
		return FALSE;
	}

	CMFCTabInfo* pTab = (CMFCTabInfo*) m_arTabs [iTab];
	ASSERT_VALID(pTab);

	if (!pTab->m_bVisible)
	{
		rect.SetRectEmpty();
		return FALSE;
	}

	rect = pTab->m_rect;
	return TRUE;
}

int CMFCBaseTabCtrl::GetTabID(int iTab) const
{
	if (iTab < 0 || iTab >= m_iTabsNum)
	{
		return -1;
	}

	CMFCTabInfo* pTab = (CMFCTabInfo*) m_arTabs [iTab];
	ASSERT_VALID(pTab);

	return pTab->m_iTabID;
}

BOOL CMFCBaseTabCtrl::GetTabLabel(int iTab, CString& strLabel) const
{
	if (iTab < 0 || iTab >= m_iTabsNum)
	{
		return FALSE;
	}

	CMFCTabInfo* pTab = (CMFCTabInfo*) m_arTabs [iTab];
	ASSERT_VALID(pTab);

	strLabel = pTab->m_bIconOnly ? _T("") : pTab->m_strText;
	return TRUE;
}

BOOL CMFCBaseTabCtrl::SetTabLabel(int iTab, const CString& strLabel)
{
	if (iTab < 0 || iTab >= m_iTabsNum || strLabel.IsEmpty())
	{
		return FALSE;
	}

	CMFCTabInfo* pTab = (CMFCTabInfo*) m_arTabs [iTab];
	ASSERT_VALID(pTab);

	pTab->m_strText = strLabel;

	if (m_pToolTip->GetSafeHwnd() != NULL)
	{
		if (m_bCustomToolTips)
		{
			CToolInfo info;

			m_pToolTip->GetToolInfo(info, this, pTab->m_iTabID);
			m_pToolTip->DelTool(this, pTab->m_iTabID);

			m_pToolTip->AddTool(this, LPSTR_TEXTCALLBACK, &info.rect, pTab->m_iTabID);
		}
		else
		{
			m_pToolTip->UpdateTipText(strLabel, this, pTab->m_iTabID);
		}
	}

	if (pTab->m_pWnd->GetSafeHwnd() != NULL)
	{
		pTab->m_pWnd->SetWindowText(strLabel);
	}

	RecalcLayout();

	if (iTab == m_iActiveTab)
	{
		//--------------------------------------------------
		// Set text to the parent frame/docking control bar:
		//--------------------------------------------------
		CBaseTabbedPane* pTabControlBar = DYNAMIC_DOWNCAST(CBaseTabbedPane, GetParent());
		if (pTabControlBar != NULL) // tabbed dock bar - redraw caption only in this case
		{
			// miniframe will take the text from the tab control bar
			if (pTabControlBar->CanSetCaptionTextToTabName())
			{
				pTabControlBar->SetWindowText(strLabel);
			}

			CWnd* pWndToUpdate = pTabControlBar;
			if (!pTabControlBar->IsDocked())
			{
				pWndToUpdate = pTabControlBar->GetParent();
			}

			if (pWndToUpdate != NULL)
			{
				pWndToUpdate->RedrawWindow(NULL, NULL, RDW_FRAME | RDW_INVALIDATE);
			}
		}
	}

	return TRUE;
}
UINT CMFCBaseTabCtrl::GetTabIcon(int iTab) const
{
	if (iTab < 0 || iTab >= m_iTabsNum)
	{
		return(UINT) -1;
	}

	CMFCTabInfo* pTab = (CMFCTabInfo*) m_arTabs [iTab];
	ASSERT_VALID(pTab);

	return pTab->m_uiIcon;
}

BOOL CMFCBaseTabCtrl::SetTabIcon(int iTab, UINT uiIcon)
{
	if (iTab < 0 || iTab >= m_iTabsNum)
	{
		return FALSE;
	}

	CMFCTabInfo* pTab = (CMFCTabInfo*) m_arTabs [iTab];
	ASSERT_VALID(pTab);

	if (pTab->m_hIcon != NULL)
	{
		::DestroyIcon(pTab->m_hIcon);
	}

	pTab->m_uiIcon = uiIcon;
	pTab->m_hIcon = NULL;

	return TRUE;
}

HICON CMFCBaseTabCtrl::GetTabHicon(int iTab) const
{
	if (iTab < 0 || iTab >= m_iTabsNum)
	{
		return NULL;
	}

	CMFCTabInfo* pTab = (CMFCTabInfo*) m_arTabs [iTab];
	ASSERT_VALID(pTab);

	return pTab->m_hIcon;
}

BOOL CMFCBaseTabCtrl::SetTabHicon(int iTab, HICON hIcon)
{
	if (iTab < 0 || iTab >= m_iTabsNum)
	{
		return FALSE;
	}

	CMFCTabInfo* pTab = (CMFCTabInfo*) m_arTabs [iTab];
	ASSERT_VALID(pTab);

	if (pTab->m_hIcon != NULL)
	{
		::DestroyIcon(pTab->m_hIcon);
	}

	if (hIcon != NULL)
	{
		pTab->m_hIcon = ::CopyIcon(hIcon);
	}
	else
	{
		pTab->m_hIcon = NULL;
	}

	pTab->m_uiIcon = (UINT)-1;

	m_sizeImage.cx = max(m_sizeImage.cx, afxGlobalData.m_sizeSmallIcon.cx);
	m_sizeImage.cy = max(m_sizeImage.cy, afxGlobalData.m_sizeSmallIcon.cy);

	SetTabsHeight();

	return TRUE;
}

BOOL CMFCBaseTabCtrl::IsTabIconOnly(int iTab) const
{
	ASSERT_VALID(this);

	if (iTab < 0 || iTab >= m_iTabsNum)
	{
		return FALSE;
	}

	CMFCTabInfo* pTab = (CMFCTabInfo*) m_arTabs [iTab];
	ASSERT_VALID(pTab);

	return pTab->m_bIconOnly;
};

BOOL CMFCBaseTabCtrl::SetTabIconOnly(int iTab, BOOL bIconOnly, BOOL bAlwaysShowToolTip)
{
	ASSERT_VALID(this);

	if (iTab < 0 || iTab >= m_iTabsNum)
	{
		return FALSE;
	}

	CMFCTabInfo* pTab = (CMFCTabInfo*) m_arTabs [iTab];
	ASSERT_VALID(pTab);

	pTab->m_bIconOnly = bIconOnly;
	pTab->m_bAlwaysShowToolTip = bAlwaysShowToolTip;

	RecalcLayout();
	return TRUE;
}

BOOL CMFCBaseTabCtrl::IsTabDetachable(int iTab) const
{
	if (iTab < 0 || iTab >= m_iTabsNum)
	{
		return FALSE;
	}

	CMFCTabInfo* pTab = (CMFCTabInfo*) m_arTabs [iTab];
	ASSERT_VALID(pTab);

	return pTab->m_bIsDetachable;
}

BOOL CMFCBaseTabCtrl::EnableTabDetach(int iTab, BOOL bEnable)
{
	if (iTab < 0 || iTab >= m_iTabsNum)
	{
		return FALSE;
	}

	CMFCTabInfo* pTab = (CMFCTabInfo*) m_arTabs [iTab];
	ASSERT_VALID(pTab);

	pTab->m_bIsDetachable = bEnable;
	return TRUE;
}

CWnd* CMFCBaseTabCtrl::GetActiveWnd() const
{
	return m_iActiveTab == -1 ? NULL : ((CMFCTabInfo*) m_arTabs [m_iActiveTab])->m_pWnd;
}

int CMFCBaseTabCtrl::GetTabFromPoint(CPoint& pt) const
{
	for (int i = 0; i < m_iTabsNum; i ++)
	{
		CMFCTabInfo* pTab = (CMFCTabInfo*) m_arTabs [i];
		ASSERT_VALID(pTab);

		if (pTab->m_bVisible && pTab->m_rect.PtInRect(pt))
		{
			return i;
		}
	}

	return -1;
}

int CMFCBaseTabCtrl::GetTabFromHwnd(HWND hwnd) const
{
	for (int i = 0; i < m_iTabsNum; i ++)
	{
		CMFCTabInfo* pTab = (CMFCTabInfo*) m_arTabs [i];
		ASSERT_VALID(pTab);

		if (pTab->m_pWnd == NULL)
		{
			continue;
		}

		if (pTab->m_pWnd->GetSafeHwnd() == hwnd)
		{
			return i;
		}

		CDockablePaneAdapter* pWrapper = DYNAMIC_DOWNCAST(CDockablePaneAdapter, pTab->m_pWnd);
		if (pWrapper != NULL)
		{
			CWnd* pWrappedWnd = pWrapper->GetWrappedWnd();
			if (pWrappedWnd != NULL && pWrappedWnd->GetSafeHwnd() == hwnd)
			{
				return i;
			}
		}
	}

	return -1;
}

int CMFCBaseTabCtrl::GetTabByID(int id) const
{
	for (int i = 0; i < m_iTabsNum; i ++)
	{
		CMFCTabInfo* pTab = (CMFCTabInfo*) m_arTabs [i];
		ASSERT_VALID(pTab);

		if (pTab->m_iTabID == id)
		{
			return i;
		}
	}

	return -1;
}

BOOL CMFCBaseTabCtrl::IsTabVisible(int iTab) const
{
	if (iTab < 0 || iTab >= m_iTabsNum)
	{
		TRACE(_T("IsTabVisible: illegal tab number %d\n"), iTab);
		return FALSE;
	}

	const CMFCTabInfo* pTab = (const CMFCTabInfo*) m_arTabs [iTab];
	ASSERT_VALID(pTab);

	return pTab->m_bVisible;
}

int CMFCBaseTabCtrl::GetTabNumberToDetach(int nTabNum) const
{
	return(nTabNum == -1 ? m_iActiveTab : nTabNum);
}

BOOL CMFCBaseTabCtrl::DetachTab(AFX_DOCK_METHOD dockMethod, int nTabNum, BOOL bHide)
{
	int nTabToDetach = GetTabNumberToDetach(nTabNum);
	if (nTabToDetach < 0)
	{
		return FALSE;
	}

	ASSERT(nTabToDetach >= 0 && nTabToDetach < GetTabsNum());

	if (!IsTabDetachable(nTabToDetach))
	{
		return FALSE;
	}

	CPane* pDockingBar = DYNAMIC_DOWNCAST(CPane, GetTabWnd(nTabToDetach));
	if (pDockingBar == NULL)
	{
		return FALSE;
	}

	ASSERT_VALID(pDockingBar);

	if (!pDockingBar->CanFloat())
	{
		return FALSE;
	}

	CRect rectFloat; rectFloat.SetRectEmpty();

	if (!pDockingBar->OnBeforeFloat(rectFloat, dockMethod))
	{
		return FALSE;
	}

	if (dockMethod == DM_MOUSE)
	{
		CPoint ptMouse;
		GetCursorPos(&ptMouse);
		CPoint ptHotDelta = m_ptHot - ptMouse;
		CSize szSensitivity = CDockablePane::GetDragSensitivity();

		if (abs(ptHotDelta.x) < szSensitivity.cx && abs(ptHotDelta.y) < szSensitivity.cy)
		{
			return FALSE;
		}
	}

	if (pDockingBar != NULL && pDockingBar->CanBeAttached())
	{
		AFX_DOCK_TYPE dockType = pDockingBar->GetDockingMode();

		CBaseTabbedPane* pParent = DYNAMIC_DOWNCAST(CBaseTabbedPane, GetParent());
		CPaneFrameWnd* pMiniFrame = pParent == NULL ? NULL : pParent->GetParentMiniFrame();

		if (pParent != NULL)
		{
			if (!pParent->CanFloat() && GetVisibleTabsNum() == 1)
			{
				return FALSE;
			}

			if (pDockingBar->IsKindOf(RUNTIME_CLASS(CDockablePane)))
			{
				((CDockablePane*) pDockingBar)->EnableGripper(TRUE);
			}

			if (!bHide &&(dockType & DT_STANDARD) != 0 && dockMethod == DM_MOUSE)
			{
				bHide = TRUE;
			}

			if (/*!bHide && */nTabToDetach != m_iActiveTab)
			{
				pDockingBar->ShowWindow(SW_SHOW);
			}

			pParent->FloatTab(pDockingBar, nTabToDetach, dockMethod, bHide);

			if (GetTabsNum() == 0)
			{
				if (pMiniFrame != NULL)
				{
					pMiniFrame->RemovePane(pParent, TRUE);
				}
				else
				{
					if (pParent->AllowDestroyEmptyTabbedPane())
					{
						pParent->DestroyWindow();
					}
					else
					{
						ShowWindow(SW_HIDE);
					}
				}
			}
			else if (GetVisibleTabsNum() == 0)
			{
				pParent->ShowPane(FALSE, FALSE, FALSE);
			}
			RecalcLayout();
		}

		CPaneFrameWnd* pParentFrame = pDockingBar->GetParentMiniFrame();
		if ((dockType & DT_STANDARD) != 0 && dockMethod == DM_MOUSE)
		{
			if (pParentFrame != NULL)
			{
				ReleaseCapture();
				pParentFrame->SetFocus();
				GetParent()->SendMessage(WM_IDLEUPDATECMDUI);
			}
		}

		m_bReadyToDetach = FALSE;

		HWND hWndToDestroy = NULL;
		if (GetTabsNum() == 1 && m_bHideSingleTab)
		{
			CRect rectWnd;
			pParent->GetWindowRect(rectWnd);

			CDockablePane* pTabDockingBar = DYNAMIC_DOWNCAST(CDockablePane, GetTabWnd(0));

			pParent->InsertPane(pTabDockingBar, pParent);
			pParent->ReplacePane(pTabDockingBar, dockMethod);
			pTabDockingBar->SetPaneAlignment(pParent->GetCurrentAlignment());
			RemoveTab(0);
			CWnd* pNewParent = (pMiniFrame == NULL) ? pParent->GetDockSiteFrameWnd() : pMiniFrame;

			pTabDockingBar->EnableGripper(TRUE);
			pNewParent->ScreenToClient(rectWnd);

			pTabDockingBar->SetParent(pNewParent);
			pTabDockingBar->SetWindowPos(NULL, rectWnd.left, rectWnd.top, rectWnd.Width(), rectWnd.Height(), SWP_NOZORDER | SWP_NOACTIVATE | SWP_HIDEWINDOW);

			pTabDockingBar->ShowPane(TRUE, FALSE, FALSE);
			pParent->ShowWindow(SW_HIDE);
			pTabDockingBar->GetParent()->InvalidateRect(NULL);
			pTabDockingBar->GetParent()->UpdateWindow();
			hWndToDestroy = pParent->GetSafeHwnd();
		}

		if (dockMethod == DM_MOUSE && pParentFrame != NULL)
		{
			ASSERT_VALID(pParentFrame);

			if ((dockType & DT_STANDARD) != 0)
			{
				pParentFrame->EnterDragMode(hWndToDestroy);
				pParentFrame->MoveDragFrame();
			}
			else if ((dockType & DT_IMMEDIATE) != 0)
			{
				pParentFrame->SetFocus();
			}
		}

		return TRUE;
	}

	return FALSE;
}

void CMFCBaseTabCtrl::OnLButtonDown(UINT nFlags, CPoint point)
{
	m_bWindowPosChanged = FALSE;

	CWnd::OnLButtonDown(nFlags, point);

	if (m_rectCloseButton.PtInRect(point))
	{
		m_bTabCloseButtonPressed = TRUE;
		RedrawWindow(m_rectCloseButton);
		return;
	}

	m_iHighlighted = GetTabFromPoint(point);
	int iHighlighted = m_iHighlighted;

	if (iHighlighted >= 0)
	{
		BOOL bTabWasMoved = FALSE;

		if (!ActivateOnBtnUp())
		{
			int nTab = GetTabFromPoint(point);

			if (nTab >= 0 && nTab != m_iActiveTab)
			{
				m_iLastActiveTab = m_iActiveTab;

				m_bSetActiveTabFired = FALSE;
				m_bSetActiveTabByMouseClick = TRUE;
				m_bUserSelectedTab = TRUE;

				if (!SetActiveTab(nTab))
				{
					m_bSetActiveTabFired = TRUE;
					m_bSetActiveTabByMouseClick = FALSE;
					m_bUserSelectedTab = FALSE;
					m_bWindowPosChanged = FALSE;
					return;
				}

				m_bSetActiveTabByMouseClick = FALSE;
				m_bUserSelectedTab = FALSE;

				if (!m_bSetActiveTabFired)
				{
					FireChangeActiveTab(m_iActiveTab);
				}

				m_bSetActiveTabFired = FALSE;
			}
			else if (nTab == m_iActiveTab)
			{
				//-----------------------------
				// Set focus to the tab window:
				//-----------------------------
				CWnd* pWnd = GetTabWnd(nTab);
				if (pWnd->GetSafeHwnd() != NULL)
				{
					pWnd->SetFocus();
				}
			}

			bTabWasMoved = (nTab != GetTabFromPoint(point));

			m_iHighlighted = -1;
			ReleaseCapture();
		}
		else
		{
			m_iPressed = m_iHighlighted;
		}

		if (iHighlighted != m_iActiveTab)
		{
			InvalidateTab(iHighlighted);
		}

		if (!bTabWasMoved && !m_bWindowPosChanged)
		{
			EnterDragMode();
		}
	}
	m_bWindowPosChanged = FALSE;
}

void CMFCBaseTabCtrl::OnRButtonDown(UINT nFlags, CPoint point)
{
	CWnd::OnRButtonDown(nFlags, point);

	if (m_bActivateTabOnRightClick)
	{
		int nTab = GetTabFromPoint(point);
		if (nTab >= 0 && nTab != m_iActiveTab)
		{
			m_bSetActiveTabFired = FALSE;
			m_bSetActiveTabByMouseClick = TRUE;
			m_bUserSelectedTab = FALSE;

			if (!SetActiveTab(nTab))
			{
				m_bSetActiveTabByMouseClick = FALSE;
				m_bUserSelectedTab = FALSE;
				return;
			}

			m_bSetActiveTabByMouseClick = FALSE;
			m_bUserSelectedTab = FALSE;

			if (!m_bSetActiveTabFired)
			{
				FireChangeActiveTab(m_iActiveTab);
			}

			m_bSetActiveTabFired = FALSE;
		}
		else if (nTab == m_iActiveTab)
		{
			//-----------------------------
			// Set focus to the tab window:
			//-----------------------------
			CWnd* pWnd = GetTabWnd(nTab);
			if (pWnd->GetSafeHwnd() != NULL)
			{
				pWnd->SetFocus();
			}
		}
	}
}

void CMFCBaseTabCtrl::EnterDragMode()
{
	m_bReadyToDetach = TRUE;
	SetCapture();
	GetCursorPos(&m_ptHot);

	CRect rectTab;
	GetTabRect(m_iActiveTab, rectTab);
	m_iTabBeforeDrag = m_iActiveTab;
	ClientToScreen(rectTab);
	m_nOffsetFromTabLeft = m_ptHot.x - rectTab.left;
}

void CMFCBaseTabCtrl::OnLButtonDblClk(UINT nFlags, CPoint point)
{
	CWnd::OnLButtonDblClk(nFlags, point);

	if (m_bIsInPlaceEdit)
	{
		int iTab = GetTabFromPoint(point);
		if (iTab  == GetActiveTab())
		{
			if (StartRenameTab(iTab))
				return;
		}
	}
	else
	{
		CWnd* pWndTarget = FindTargetWnd(point);
		if (pWndTarget == NULL)
		{
			DetachTab(DM_DBL_CLICK);
		}
	}
}

void CMFCBaseTabCtrl::OnLButtonUp(UINT nFlags, CPoint point)
{
	if (m_bTabCloseButtonPressed)
	{
		m_bTabCloseButtonPressed = FALSE;
		m_bTabCloseButtonHighlighted = FALSE;

		RedrawWindow(m_rectCloseButton);

		if (m_rectCloseButton.PtInRect(point))
		{
			CWnd* pWndActive = GetActiveWnd();
			if (pWndActive != NULL)
			{
				pWndActive->SendMessage(WM_CLOSE);
			}

			return;
		}
	}

	if (m_iTabBeforeDrag != m_iActiveTab)
	{
		CWnd* pWndParent = GetParent();
		ASSERT_VALID(pWndParent);

		pWndParent->SendMessage(AFX_WM_ON_MOVE_TAB, m_iTabBeforeDrag, m_iActiveTab);
		if (pWndParent->IsKindOf(RUNTIME_CLASS(CBaseTabbedPane)) || pWndParent->IsKindOf(RUNTIME_CLASS(CMDIClientAreaWnd)))
		{
			pWndParent = AFXGetParentFrame(pWndParent);
			if (pWndParent != NULL)
			{
				pWndParent->SendMessage(AFX_WM_ON_MOVE_TAB, m_iTabBeforeDrag, m_iActiveTab);
			}
		}
	}

	if (m_bReadyToDetach)
	{
		m_bReadyToDetach = FALSE;
		ReleaseCapture();

		if (!ActivateOnBtnUp())
		{
			m_iPressed = -1;
			m_iHighlighted = -1;
		}
	}

	if (ActivateOnBtnUp())
	{
		bool bNewActiveTab = m_iActiveTab != m_iHighlighted;

		if (m_iHighlighted == m_iPressed && m_iHighlighted >= 0 && m_iHighlighted != m_iActiveTab)
		{
			m_iLastActiveTab = m_iActiveTab;
			m_bSetActiveTabByMouseClick = TRUE;
			m_bUserSelectedTab = FALSE;

			if (!SetActiveTab(m_iHighlighted))
			{
				m_bSetActiveTabByMouseClick = FALSE;
				m_bUserSelectedTab = FALSE;
				m_iPressed = -1;

				if (!IsOneNoteStyle())
				{
					m_iHighlighted = -1;
				}

				ReleaseCapture();
				return;
			}

			FireChangeActiveTab(m_iActiveTab);
			m_bSetActiveTabByMouseClick = FALSE;
			m_bUserSelectedTab = FALSE;
		}

		int iHighlighted = m_iHighlighted;
		int iPressed = m_iPressed;

		m_iPressed = -1;

		if (!IsOneNoteStyle())
		{
			m_iHighlighted = -1;
		}

		ReleaseCapture();

		if (bNewActiveTab)
		{
			InvalidateTab(iHighlighted);

			if (iPressed != iHighlighted)
			{
				InvalidateTab(iPressed);
			}
		}
	}

	if (IsOneNoteStyle())
	{
		CRect rectTabAreaTop;
		CRect rectTabAreaBottom;

		GetTabArea(rectTabAreaTop, rectTabAreaBottom);

		if (!rectTabAreaTop.IsRectEmpty())
		{
			InvalidateRect(rectTabAreaTop, FALSE);
		}

		if (!rectTabAreaBottom.IsRectEmpty())
		{
			InvalidateRect(rectTabAreaBottom, FALSE);
		}

		UpdateWindow();
	}

	CWnd::OnLButtonUp(nFlags, point);
}

void CMFCBaseTabCtrl::OnMouseMove(UINT nFlags, CPoint point)
{
	CWnd::OnMouseMove(nFlags, point);

	int iPrevHighlighted = m_iHighlighted;

	BOOL bTabCloseButtonHighlighted = m_bTabCloseButtonHighlighted;
	m_bTabCloseButtonHighlighted = m_rectCloseButton.PtInRect(point);

	if (bTabCloseButtonHighlighted != m_bTabCloseButtonHighlighted)
	{
		if (m_bTabCloseButtonHighlighted)
		{
			m_bTabCloseButtonPressed = (nFlags & MK_LBUTTON);
		}

		RedrawWindow(m_rectCloseButton);
	}

	if (m_iHighlighted >= 0 && m_iPressed < 0 && !m_bReadyToDetach)
	{
		CPoint pt = point;
		ClientToScreen(&pt);
		CWnd* pWnd = CWnd::WindowFromPoint(pt);
		if (pWnd != NULL && pWnd->GetSafeHwnd() != GetSafeHwnd())
		{
			ReleaseCapture();
			m_iHighlighted = -1;
			InvalidateTab(iPrevHighlighted);
			return;
		}
	}

	m_iHighlighted = GetTabFromPoint(point);

	if (m_iPressed >= 0 && m_iHighlighted != m_iPressed)
	{
		m_iHighlighted = -1;
	}

	if (m_iHighlighted != iPrevHighlighted &&(m_bHighLightTabs || IsActiveTabCloseButton()))
	{
		if (iPrevHighlighted < 0)
		{
			if (m_iHighlighted >= 0)
			{
				SetCapture();
			}
		}
		else
		{
			if (m_iHighlighted < 0 && m_iPressed < 0)
			{
				m_bTabCloseButtonHighlighted = FALSE;
				m_bTabCloseButtonPressed = FALSE;

				if (!m_bReadyToDetach)
				{
					ReleaseCapture();
				}
			}
		}

		InvalidateTab(m_iHighlighted);
		InvalidateTab(iPrevHighlighted);
	}

	if (m_bReadyToDetach)
	{
		int nNumTabs = m_iTabsNum; // how many tabs before detch

		// try to rearrange tabs if their number > 1
		if (IsPtInTabArea(point) && nNumTabs > 1 && m_bEnableTabSwap)
		{
			CRect rectTab;
			int nTabNum = GetTabFromPoint(point);

			if (nTabNum != m_iActiveTab && nTabNum != -1)
			{
				int nSecondTab = m_iActiveTab;
				SwapTabs(nTabNum, nSecondTab);
				RecalcLayout();
				SetActiveTab(nTabNum);
				int nCurrTabNum = GetTabFromPoint(point);
				if (nCurrTabNum != nTabNum)
				{
					GetTabRect(nTabNum, rectTab);
					CPoint ptCursorNewPos = point;

					ptCursorNewPos.x = rectTab.left + m_nOffsetFromTabLeft;

					ClientToScreen(&ptCursorNewPos);
					SetCursorPos(ptCursorNewPos.x, ptCursorNewPos.y);
				}
			}
			return;
		}

		if (IsPtInTabArea(point))
		{
			return;
		}

		BOOL bDetachSucceeded = DetachTab(DM_MOUSE);

		if (bDetachSucceeded && nNumTabs <= 2)
		{
			// last tab was detached successfully - run out, because the control
			// has been destroyed
			return;
		}

		if (bDetachSucceeded)
		{
			m_bReadyToDetach = FALSE;
		}

		return;
	}
}

void CMFCBaseTabCtrl::OnCancelMode()
{
	CWnd::OnCancelMode();

	if (m_bTabCloseButtonPressed || m_bTabCloseButtonHighlighted)
	{
		m_bTabCloseButtonPressed = FALSE;
		m_bTabCloseButtonHighlighted = FALSE;

		RedrawWindow(m_rectCloseButton);
	}

	if (m_iHighlighted >= 0)
	{
		int iTab = m_iHighlighted;

		ReleaseCapture();
		m_iHighlighted = -1;
		m_iPressed = -1;

		InvalidateTab(iTab);
	}

	if (m_pInPlaceEdit != NULL)
	{
		m_pInPlaceEdit->DestroyWindow();
		delete m_pInPlaceEdit;
		m_pInPlaceEdit = NULL;
		m_iEditedTab = -1;
		ReleaseCapture();
	}

	m_bReadyToDetach = FALSE;
}

void CMFCBaseTabCtrl::InvalidateTab(int iTab)
{
	ASSERT_VALID(this);

	if (iTab < 0)
	{
		return;
	}

	CRect rectTab;

	if (GetTabRect(iTab, rectTab))
	{
		InvalidateRect(rectTab);
		UpdateWindow();
	}
}

void CMFCBaseTabCtrl::OnDestroy()
{
	CleanUp();
	CWnd::OnDestroy();
}

int CMFCBaseTabCtrl::FindTabInfo(int nBarID, CMFCTabInfo** ppTabInfo)
{
	*ppTabInfo = NULL;
	for (int i = 0; i < m_arTabs.GetSize(); i++)
	{
		CMFCTabInfo* pTabInfo = (CMFCTabInfo*) m_arTabs.GetAt(i);
		ASSERT_VALID(pTabInfo);

		if (pTabInfo->m_pWnd != NULL && pTabInfo->m_pWnd->GetDlgCtrlID() == nBarID)
		{
			*ppTabInfo = pTabInfo;
			return i;
		}
	}

	return NULL;
}

void CMFCBaseTabCtrl::ApplyRestoredTabInfo(BOOL bUseTabIndexes)
{
	CDockingManager* pDockManager = afxGlobalUtils.GetDockingManager(AFXGetParentFrame(this));
	ASSERT_VALID(pDockManager);

	POSITION pos = NULL;

	for (pos = m_lstRestoredTabInfo.GetHeadPosition(); pos != NULL;)
	{
		CMFCRestoredTabInfo tabInfo = m_lstRestoredTabInfo.GetNext(pos);

		CMFCTabInfo* pCurrTabInfo = NULL;
		FindTabInfo(tabInfo.m_nControlBarID, &pCurrTabInfo);
		if (pCurrTabInfo != NULL)
		{
			continue;
		}

		CDockablePane* pBar = DYNAMIC_DOWNCAST(CDockablePane, pDockManager->FindPaneByID(tabInfo.m_nControlBarID, TRUE));

		if (pBar != NULL)
		{
			if (pBar->IsTabbed())
			{
				CMFCBaseTabCtrl* pTabWnd = (CMFCBaseTabCtrl*) pBar->GetParent();
				CBaseTabbedPane* pTabBar = (CBaseTabbedPane*) pTabWnd->GetParent();
				ASSERT_VALID(pTabBar);
				pBar->SetParent(GetParent());
				pTabBar->RemovePane(pBar);
				if (pBar->IsKindOf(RUNTIME_CLASS(CDockablePane)))
				{
					((CDockablePane*) pBar)->EnableGripper(TRUE);
				}

				pBar->ShowWindow(SW_SHOW);
			}

			if (pBar->IsAutoHideMode())
			{
				pBar->SetAutoHideMode(FALSE, CBRS_ALIGN_ANY);
			}

			CPaneFrameWnd* pMiniFrame = pBar->GetParentMiniFrame();
			if (pMiniFrame != NULL)
			{
				pMiniFrame->RemovePane(pBar);
			}

			pBar->SetParent(GetParent());

			CBaseTabbedPane* pTabbedBar = DYNAMIC_DOWNCAST(CBaseTabbedPane, GetParent());
			pBar->AttachToTabWnd(pTabbedBar, DM_SHOW, FALSE);
		}
	}

	int nTabIdx = 0;
	int nVisibleTabNumber = 0;

	for (pos = m_lstRestoredTabInfo.GetHeadPosition(); pos != NULL; nTabIdx++)
	{
		CMFCRestoredTabInfo tabInfo = m_lstRestoredTabInfo.GetNext(pos);
		CMFCTabInfo* pCurrTabInfo = NULL;
		int nCurIdx = FindTabInfo(tabInfo.m_nControlBarID, &pCurrTabInfo);

		if (pCurrTabInfo == NULL)
		{
			continue;
		}

		pCurrTabInfo->m_strText  = tabInfo.m_strText;
		pCurrTabInfo->m_clrText  = tabInfo.m_clrText;
		pCurrTabInfo->m_clrBack  = tabInfo.m_clrBack;
		pCurrTabInfo->m_bIsDetachable = tabInfo.m_bDetachable;

		ShowTab(nCurIdx, tabInfo.m_bVisible, FALSE);

		if (tabInfo.m_bVisible)
		{
			nVisibleTabNumber++;
		}

		if (bUseTabIndexes && nCurIdx != nTabIdx)
		{
			SwapTabs(nCurIdx, nTabIdx);
			if (pCurrTabInfo->m_pWnd != NULL && nTabIdx == m_nRestoredActiveTabID)
			{
				pCurrTabInfo->m_pWnd->ShowWindow(SW_SHOW);
			}

			if (nVisibleTabNumber > 0)
			{
				SetActiveTab(nCurIdx);
			}
		}
	}

	if (nVisibleTabNumber > 0 && !SetActiveTab(m_nRestoredActiveTabID))
	{
		SetActiveTab(0);
	}

	if (nVisibleTabNumber == 0)
	{
		CBaseTabbedPane* pTabBar = DYNAMIC_DOWNCAST(CBaseTabbedPane, GetParent());
		if (pTabBar != NULL)
		{
			pTabBar->ShowPane(FALSE, FALSE, FALSE);
		}
	}

	RecalcLayout();
}

void CMFCBaseTabCtrl::Serialize(CArchive& ar)
{
	int nTabCount = 0;
	if (ar.IsLoading())
	{
		m_lstRestoredTabInfo.RemoveAll();

		ar >> nTabCount;

		for (int i = 0; i < nTabCount; i++)
		{
			CMFCRestoredTabInfo tabInfo;

			ar >> tabInfo.m_strText;
			ar >> tabInfo.m_bVisible;
			ar >> tabInfo.m_nControlBarID;
			ar >> tabInfo.m_bDetachable;
			ar >> tabInfo.m_clrText;
			ar >> tabInfo.m_clrBack;

			m_lstRestoredTabInfo.AddTail(tabInfo);
		}
		ar >> m_nRestoredActiveTabID;

		int nLoc = 0;
		ar >> nLoc;
	}
	else
	{
		nTabCount = (int) m_arTabs.GetSize();
		ar << nTabCount;

		for (int i = 0; i < nTabCount; i++)
		{
			CMFCTabInfo* pTabInfo = (CMFCTabInfo*) m_arTabs.GetAt(i);
			ASSERT_VALID(pTabInfo);

			ar << pTabInfo->m_strText;
			ar << pTabInfo->m_bVisible;

			ASSERT_VALID(pTabInfo->m_pWnd);
			ar << pTabInfo->m_pWnd->GetDlgCtrlID();

			ar << pTabInfo->m_bIsDetachable;
			ar << pTabInfo->m_clrText;
			ar << pTabInfo->m_clrBack;
		}

		ar << m_iActiveTab;
		ar << m_location;
	}
}

void CMFCBaseTabCtrl::SwapTabs(int nFisrtTabID, int nSecondTabID)
{
	if (m_arTabs.GetSize() <= nFisrtTabID ||
		m_arTabs.GetSize() <= nSecondTabID)
	{
		return;
	}
	CMFCTabInfo* pTabInfoFirst  = (CMFCTabInfo*) m_arTabs.GetAt(nFisrtTabID);
	CMFCTabInfo* pTabInfoSecond = (CMFCTabInfo*) m_arTabs.GetAt(nSecondTabID);
	m_arTabs.SetAt(nFisrtTabID, pTabInfoSecond);
	m_arTabs.SetAt(nSecondTabID, pTabInfoFirst);
}

void CMFCBaseTabCtrl::MoveTab(int nSource, int nDest)
{
	ASSERT_VALID(this);

	if (nSource == nDest)
	{
		return;
	}

	CMFCTabInfo* pSource = (CMFCTabInfo*) m_arTabs [nSource];
	CMFCTabInfo* pActive = (CMFCTabInfo*) m_arTabs [m_iActiveTab];

	ASSERT(nDest < m_arTabs.GetSize());

	if (nDest == -1)
	{
		m_arTabs.Add(pSource);
		m_arTabs.RemoveAt(nSource);
	}
	else
	{
		m_arTabs.RemoveAt(nSource);
		m_arTabs.InsertAt(nDest, pSource);
	}

	for (int iTab = 0; iTab < m_arTabs.GetSize(); iTab++)
	{
		if (pActive == (CMFCTabInfo*) m_arTabs [iTab])
		{
			if (iTab != m_iActiveTab)
			{
				SetActiveTab(iTab);
				FireChangeActiveTab(m_iActiveTab);
			}
			break;
		}
	}
	RecalcLayout();
}

BOOL CMFCBaseTabCtrl::SetTabsOrder(const CArray<int,int>& arOrder)
{
	ASSERT_VALID(this);

	if (arOrder.GetSize() != m_iTabsNum)
	{
		ASSERT(FALSE);
		return FALSE;
	}

	CPtrArray arTabsSaved;
	int i = 0;

	for (i = 0; i < m_iTabsNum; i ++)
	{
		CMFCTabInfo* pTab = (CMFCTabInfo*) m_arTabs [i];
		ASSERT_VALID(pTab);

		arTabsSaved.Add(pTab);
	}

	m_arTabs.RemoveAll();

	BOOL bActiveTabIsChamged = FALSE;

	for (i = 0; i < m_iTabsNum; i ++)
	{
		int nIndex = arOrder [i];
		ASSERT(nIndex >= 0);
		ASSERT(nIndex < m_iTabsNum);

		CMFCTabInfo* pTab = (CMFCTabInfo*) arTabsSaved [nIndex];
		ASSERT_VALID(pTab);

		m_arTabs.Add(pTab);

		if (nIndex == m_iActiveTab && !bActiveTabIsChamged)
		{
			m_iActiveTab = i;
			bActiveTabIsChamged = TRUE;
		}
	}

	return TRUE;
}

CWnd* CMFCBaseTabCtrl::CreateWrapper(CWnd* pWndToWrap, LPCTSTR lpszTabLabel, BOOL bDetachable)
{
	ASSERT_VALID(pWndToWrap);

	if (pWndToWrap->IsKindOf(RUNTIME_CLASS(CDockablePane)) || !bDetachable || !m_bEnableWrapping)
	{
		return pWndToWrap;
	}


	CDockablePaneAdapter* pWrapper = NULL;

	if (m_pDockingBarWrapperRTC != NULL)
	{
		pWrapper = DYNAMIC_DOWNCAST(CDockablePaneAdapter, m_pDockingBarWrapperRTC->CreateObject());
	}
	else
	{
		pWrapper = new CDockablePaneAdapter;
	}

	ASSERT_VALID(pWrapper);

	CRect rectInit(pWrapper->m_rectInitial);

	// create will alter the runtime class, but here we have to save it
	// and set back after create
	CRuntimeClass* pSaveRTC = pWrapper->GetTabbedPaneRTC();

	DWORD dwStyle = WS_CHILD | WS_VISIBLE | WS_CLIPSIBLINGS | WS_CLIPCHILDREN;
	DWORD dwControlBarStyle = AFX_DEFAULT_DOCKING_PANE_STYLE;
	if (pWndToWrap->IsKindOf(RUNTIME_CLASS(CBasePane)))
	{
		dwStyle |= ((CBasePane*) pWndToWrap)->GetPaneStyle();
		dwControlBarStyle = ((CBasePane*) pWndToWrap)->GetControlBarStyle();
	}

	if (!pWrapper->Create(lpszTabLabel, this, rectInit, TRUE, (UINT) pWndToWrap->GetDlgCtrlID(), dwStyle, AFX_CBRS_REGULAR_TABS, dwControlBarStyle))
	{
		delete pWrapper;
		TRACE0("Unable to create CDockablePaneAdapter. \n");
		return pWndToWrap;
	}
	pWrapper->EnableGripper(FALSE);
	pWrapper->SetWrappedWnd(pWndToWrap);

	pWrapper->m_recentDockInfo.m_rectRecentFloatingRect = rectInit;

	if (pSaveRTC != NULL)
	{
		pWrapper->SetTabbedPaneRTC(pSaveRTC);
	}

	return pWrapper;
}

BOOL CMFCBaseTabCtrl::StartRenameTab(int iTab)
{
	ASSERT_VALID(this);
	ENSURE(GetSafeHwnd() != NULL);

	if (!m_bIsInPlaceEdit)
	{
		return FALSE;
	}

	if (iTab < 0 || iTab >= m_arTabs.GetSize())
	{
		return FALSE;
	}

	CMFCTabInfo* pTabInfo = (CMFCTabInfo*) m_arTabs.GetAt(iTab);
	if (pTabInfo->m_rect.IsRectEmpty())
	{
		return FALSE;
	}

	ENSURE(m_pInPlaceEdit == NULL);

	m_pInPlaceEdit = new CEdit;
	ASSERT_VALID(m_pInPlaceEdit);

	CRect rectEdit = pTabInfo->m_rect;
	CalcRectEdit(rectEdit);

	if (!m_pInPlaceEdit->Create(WS_VISIBLE | WS_CHILD | WS_BORDER | ES_AUTOHSCROLL, rectEdit, this, 1))
	{
		delete m_pInPlaceEdit;
		m_pInPlaceEdit = NULL;

		return FALSE;
	}

	m_pInPlaceEdit->SetWindowText(pTabInfo->m_strText);
	m_pInPlaceEdit->SetFont(&afxGlobalData.fontRegular);
	m_pInPlaceEdit->SetSel(0, -1, TRUE);

	m_pInPlaceEdit->SetFocus();
	m_iEditedTab = iTab;

	SetCapture();
	return TRUE;
}

BOOL CMFCBaseTabCtrl::PreTranslateMessage(MSG* pMsg)
{
	if (m_pInPlaceEdit != NULL)
	{
		if (pMsg->message >= WM_KEYFIRST && pMsg->message <= WM_KEYLAST)
		{
			switch(pMsg->wParam)
			{
			case VK_RETURN:
				if (!RenameTab())
				{
					MessageBeep((UINT)-1);
					return TRUE;
				}
				// Slide down!

			case VK_ESCAPE:
				m_pInPlaceEdit->DestroyWindow();
				delete m_pInPlaceEdit;
				m_pInPlaceEdit = NULL;
				m_iEditedTab = -1;
				ReleaseCapture();
				break;

			default:
				return FALSE;
			}

			return TRUE;
		}
		else if (pMsg->message >= WM_MOUSEFIRST && pMsg->message <= WM_MOUSELAST)
		{
			CRect rectEdit;
			m_pInPlaceEdit->GetClientRect(rectEdit);
			m_pInPlaceEdit->MapWindowPoints(this, rectEdit);

			CPoint ptCursor;
			::GetCursorPos(&ptCursor);
			ScreenToClient(&ptCursor);

			if (rectEdit.PtInRect(ptCursor))
			{
				m_pInPlaceEdit->SendMessage(pMsg->message, pMsg->wParam, pMsg->lParam);
			}
			else if (pMsg->message != WM_MOUSEMOVE)
			{
				m_pInPlaceEdit->DestroyWindow();
				delete m_pInPlaceEdit;
				m_pInPlaceEdit = NULL;
				m_iEditedTab = -1;
				ReleaseCapture();
			}

			return TRUE;
		}
		else
		{
			return FALSE;
		}
	}

	return CWnd::PreTranslateMessage(pMsg);
}

BOOL CMFCBaseTabCtrl::RenameTab()
{
	ASSERT_VALID(this);
	ASSERT(m_bIsInPlaceEdit);

	if (m_pInPlaceEdit == NULL)
	{
		ASSERT(FALSE);
		return FALSE;
	}

	CString strName;
	m_pInPlaceEdit->GetWindowText(strName);

	if (!strName.IsEmpty() && OnRenameTab(m_iEditedTab, strName) &&
		GetParent()->SendMessage(AFX_WM_ON_RENAME_TAB, m_iEditedTab, (LPARAM)(LPCTSTR) strName) == 0)
	{
		return SetTabLabel(m_iEditedTab, strName);
	}

	return FALSE;
}

void CMFCBaseTabCtrl::SetActiveTabTextColor(COLORREF clr)
{
	m_clrActiveTabFg = clr;
}

void CMFCBaseTabCtrl::SetActiveTabColor(COLORREF clr)
{
	m_clrActiveTabBk = clr;

	if (m_brActiveTab.GetSafeHandle() != NULL)
	{
		m_brActiveTab.DeleteObject();
	}

	m_brActiveTab.CreateSolidBrush(GetActiveTabColor());
}

COLORREF CMFCBaseTabCtrl::GetTabBkColor(int iTab) const
{
	ASSERT_VALID(this);

	if (iTab < 0 || iTab >= m_iTabsNum)
	{
		return(COLORREF)-1;
	}

	CMFCTabInfo* pTab = (CMFCTabInfo*) m_arTabs [iTab];
	ASSERT_VALID(pTab);

	COLORREF color = pTab->m_clrBack;

	CMFCTabInfo* pTabPrev = NULL;
	if (iTab > 0)
	{
		pTabPrev = (CMFCTabInfo*) m_arTabs [iTab - 1];
		ASSERT_VALID(pTabPrev);
	}

	if (color == (COLORREF)-1 && m_bIsAutoColor)
	{
		// try to make sure that unique tab colors are used
		static int nLastColorIndexUsed = 0, nCyclicalColor = 0;
		int nColorIndexUsed = iTab % m_arAutoColors.GetSize();
		if (nColorIndexUsed == nLastColorIndexUsed)
		{
			nColorIndexUsed = ++nCyclicalColor % m_arAutoColors.GetSize();
		}

		if (pTabPrev != NULL)
		{
			COLORREF colorPrev = pTabPrev->m_clrBack;
			if (colorPrev == m_arAutoColors[nColorIndexUsed])
			{
				nColorIndexUsed = ++nCyclicalColor % m_arAutoColors.GetSize();
			}
		}

		color = m_arAutoColors[nColorIndexUsed];
		pTab->m_clrBack = color;
		nLastColorIndexUsed = nColorIndexUsed;
	}

	return color;
}

BOOL CMFCBaseTabCtrl::SetTabBkColor(int iTab, COLORREF color)
{
	ASSERT_VALID(this);

	if (iTab < 0 || iTab >= m_iTabsNum)
	{
		return FALSE;
	}

	CMFCTabInfo* pTab = (CMFCTabInfo*) m_arTabs [iTab];
	ASSERT_VALID(pTab);

	pTab->m_clrBack = color;
	return TRUE;
}

COLORREF CMFCBaseTabCtrl::GetTabTextColor(int iTab) const
{
	ASSERT_VALID(this);

	if (iTab < 0 || iTab >= m_iTabsNum)
	{
		return(COLORREF)-1;
	}

	CMFCTabInfo* pTab = (CMFCTabInfo*) m_arTabs [iTab];
	ASSERT_VALID(pTab);

	return pTab->m_clrText;
}

BOOL CMFCBaseTabCtrl::SetTabTextColor(int iTab, COLORREF color)
{
	ASSERT_VALID(this);

	if (iTab < 0 || iTab >= m_iTabsNum)
	{
		return FALSE;
	}

	CMFCTabInfo* pTab = (CMFCTabInfo*) m_arTabs [iTab];
	ASSERT_VALID(pTab);

	pTab->m_clrText = color;
	return TRUE;
}

int CMFCBaseTabCtrl::GetTabFullWidth(int iTab) const
{
	ASSERT_VALID(this);

	if (iTab < 0 || iTab >= m_iTabsNum)
	{
		return 0;
	}

	CMFCTabInfo* pTab = (CMFCTabInfo*) m_arTabs [iTab];
	ASSERT_VALID(pTab);

	return pTab->m_nFullWidth;
}

BOOL CMFCBaseTabCtrl::SetImageList(UINT uiID, int cx, COLORREF clrTransp)
{
	CBitmap bmp;
	if (!bmp.LoadBitmap(uiID))
	{
		TRACE(_T("CMFCTabCtrl::SetImageList Can't load bitmap: %x\n"), uiID);
		return FALSE;
	}

	if (m_Images.GetSafeHandle() != NULL)
	{
		m_Images.DeleteImageList();
	}

	BITMAP bmpObj;
	bmp.GetBitmap(&bmpObj);

	UINT nFlags = (clrTransp == (COLORREF) -1) ? 0 : ILC_MASK;

	switch(bmpObj.bmBitsPixel)
	{
	case 4:
	default:
		nFlags |= ILC_COLOR4;
		break;

	case 8:
		nFlags |= ILC_COLOR8;
		break;

	case 16:
		nFlags |= ILC_COLOR16;
		break;

	case 24:
		nFlags |= ILC_COLOR24;
		break;

	case 32:
		nFlags |= ILC_COLOR32;
		break;
	}

	m_Images.Create(cx, bmpObj.bmHeight, nFlags, 0, 0);
	m_Images.Add(&bmp, clrTransp);

	m_sizeImage = CSize(cx, bmpObj.bmHeight);

	SetTabsHeight();
	return TRUE;
}

BOOL CMFCBaseTabCtrl::SetImageList(HIMAGELIST hImageList)
{
	ENSURE(hImageList != NULL);

	if (m_Images.GetSafeHandle() != NULL)
	{
		m_Images.DeleteImageList();
	}

	CImageList* pImageList = CImageList::FromHandle(hImageList);
	if (pImageList == NULL)
	{
		ASSERT(FALSE);
		return FALSE;
	}

	IMAGEINFO info;
	pImageList->GetImageInfo(0, &info);

	CRect rectImage = info.rcImage;
	m_sizeImage = rectImage.Size();

	m_hImageList = hImageList;

	SetTabsHeight();
	return TRUE;
}

void CMFCBaseTabCtrl::ClearImageList()
{
	if (m_Images.GetSafeHandle() != NULL)
	{
		m_Images.DeleteImageList();
	}

	m_sizeImage = CSize(0, 0);
	SetTabsHeight();
}

void CMFCBaseTabCtrl::ResetImageList()
{
	ClearImageList();
	m_hImageList = NULL;
	m_mapAddedIcons.RemoveAll();
}

void CMFCBaseTabCtrl::SetTabsHeight()
{
	const int nImageHeight = m_sizeImage.cy <= 0 ? 0 : m_sizeImage.cy + 7;
	m_nTabsHeight = (max(nImageHeight, afxGlobalData.GetTextHeight() + 5));
}

void CMFCBaseTabCtrl::HideSingleTab(BOOL bHide)
{
	if (m_bHideSingleTab == bHide)
	{
		return;
	}

	m_bHideSingleTab = bHide;

	if (GetSafeHwnd() != NULL)
	{
		RecalcLayout();
	}
}

CWnd* CMFCBaseTabCtrl::GetFirstVisibleTab(int& iTabNum)
{
	return GetFirstVisibleTab(0, iTabNum);
}

CWnd* CMFCBaseTabCtrl::GetFirstVisibleTab(int iStartFrom, int& iTabNum)
{
	for (int i = iStartFrom; i < m_iTabsNum; i++)
	{
		CMFCTabInfo* pTabInfo = (CMFCTabInfo*) m_arTabs [i];
		ASSERT_VALID(pTabInfo);

		if (pTabInfo->m_bVisible)
		{
			iTabNum = i;
			return pTabInfo->m_pWnd;
		}
	}
	if (iStartFrom > 0)
	{
		return GetFirstVisibleTab(0, iTabNum);
	}
	iTabNum = -1;
	return NULL;
}

CWnd* CMFCBaseTabCtrl::GetLastVisibleTab(int& iTabNum)
{
	for (int i = m_iTabsNum - 1; i >= 0; i--)
	{
		CMFCTabInfo* pTabInfo = (CMFCTabInfo*) m_arTabs [i];
		ASSERT_VALID(pTabInfo);

		if (pTabInfo->m_bVisible)
		{
			iTabNum = i;
			return pTabInfo->m_pWnd;
		}
	}
	iTabNum = -1;
	return NULL;
}

void CMFCBaseTabCtrl::SetDrawNoPrefix(BOOL bNoPrefix, BOOL bRedraw)
{
	ASSERT_VALID(this);
	m_bLabelNoPrefix = bNoPrefix;

	if (bRedraw && GetSafeHwnd() != NULL)
	{
		RedrawWindow();
	}
}

int CMFCBaseTabCtrl::OnCreate(LPCREATESTRUCT lpCreateStruct)
{
	if (CWnd::OnCreate(lpCreateStruct) == -1)
		return -1;

	if (AFXGetParentFrame(this) == NULL)
	{
		m_bEnableWrapping = FALSE;
	}

	_AFX_THREAD_STATE* pState = AfxGetThreadState();
	if (pState->m_bNeedTerm) // AfxOleInit was called
	{
		m_DropTarget.Register(this);
	}

	return 0;
}

CSize CMFCBaseTabCtrl::GetMaxWindowSize() const
{
	CSize sizeMax(0, 0);
	int nTabCount = (int) m_arTabs.GetSize();

	for (int i = 0; i < nTabCount; i++)
	{
		CMFCTabInfo* pTabInfo = (CMFCTabInfo*) m_arTabs.GetAt(i);
		ASSERT_VALID(pTabInfo);

		if (pTabInfo->m_pWnd != NULL)
		{
			CSize sizeCurr(0, 0);
			if (pTabInfo->m_pWnd->IsKindOf(RUNTIME_CLASS(CBasePane)))
			{
				CBasePane* pBar = DYNAMIC_DOWNCAST(CBasePane, pTabInfo->m_pWnd);
				if (pBar != NULL)
				{
					sizeCurr = pBar->CalcFixedLayout(FALSE, TRUE);
				}
			}
			else
			{
				CRect rectWnd;
				pTabInfo->m_pWnd->GetWindowRect(rectWnd);
				sizeCurr = rectWnd.Size();
			}

			sizeMax.cx = max(sizeCurr.cx, sizeMax.cx);
			sizeMax.cy = max(sizeCurr.cy, sizeMax.cy);
		}
	}

	return sizeMax;
}

void CMFCBaseTabCtrl::EnableAutoColor(BOOL bEnable/* = TRUE*/)
{
	if (m_bIsAutoColor && !bEnable)
	{
		for (int i = 0; i < m_iTabsNum; i ++)
		{
			CMFCTabInfo* pTabInfo = (CMFCTabInfo*) m_arTabs.GetAt(i);
			ASSERT_VALID(pTabInfo);

			pTabInfo->m_clrBack = (COLORREF)-1;
		}
	}

	m_bIsAutoColor = bEnable;
	InitAutoColors();

	if (GetSafeHwnd() != NULL)
	{
		RedrawWindow();
	}
}

void CMFCBaseTabCtrl::InitAutoColors()
{
	if (!m_bIsDefaultAutoColor)
	{
		return;
	}

	m_arAutoColors.RemoveAll();

	if (afxGlobalData.m_nBitsPerPixel > 8)
	{
		m_arAutoColors.Add(RGB(197, 212, 242));
		m_arAutoColors.Add(RGB(255, 220, 120));
		m_arAutoColors.Add(RGB(190, 206, 161));
		m_arAutoColors.Add(RGB(240, 160, 161));
		m_arAutoColors.Add(RGB(188, 168, 225));
		m_arAutoColors.Add(RGB(156, 193, 182));
		m_arAutoColors.Add(RGB(247, 184, 134));
		m_arAutoColors.Add(RGB(217, 173, 194));
		m_arAutoColors.Add(RGB(165, 194, 215));
		m_arAutoColors.Add(RGB(179, 166, 190));
		m_arAutoColors.Add(RGB(234, 214, 163));
		m_arAutoColors.Add(RGB(246, 250, 125));
		m_arAutoColors.Add(RGB(181, 233, 157));
		m_arAutoColors.Add(RGB(95, 195, 207));
		m_arAutoColors.Add(RGB(193, 131, 131));
		m_arAutoColors.Add(RGB(202, 202, 213));
	}
	else
	{
		m_arAutoColors.Add(RGB(0, 255, 0));
		m_arAutoColors.Add(RGB(0, 255, 255));
		m_arAutoColors.Add(RGB(255, 0, 255));
		m_arAutoColors.Add(RGB(192, 192, 192));
		m_arAutoColors.Add(RGB(255, 255, 0));
	}
}

void CMFCBaseTabCtrl::OnSysColorChange()
{
	CWnd::OnSysColorChange();

	InitAutoColors();
}

void CMFCBaseTabCtrl::SetAutoColors(const CArray<COLORREF, COLORREF>& arColors)
{
	int i = 0;

	for (i = 0; i < m_iTabsNum; i ++)
	{
		CMFCTabInfo* pTabInfo = (CMFCTabInfo*) m_arTabs.GetAt(i);
		ASSERT_VALID(pTabInfo);

		pTabInfo->m_clrBack = (COLORREF)-1;
	}

	m_arAutoColors.RemoveAll();

	if (arColors.GetSize() == 0)
	{
		m_bIsDefaultAutoColor = TRUE;
		InitAutoColors();
	}
	else
	{
		m_bIsDefaultAutoColor = FALSE;

		for (i = 0; i < arColors.GetSize(); i++)
		{
			m_arAutoColors.Add(arColors [i]);
		}
	}

	if (GetSafeHwnd() != NULL)
	{
		RedrawWindow();
	}
}

void CMFCBaseTabCtrl::SetLocation(Location location)
{
	ASSERT_VALID(this);

	m_location = location;
	RecalcLayout();

	if (GetSafeHwnd() != NULL)
	{
		GetParent()->RedrawWindow(NULL, NULL, RDW_INVALIDATE | RDW_UPDATENOW | RDW_ERASE | RDW_ALLCHILDREN);
	}
}

BOOL CMFCBaseTabCtrl::IsColored() const
{
	for (int iTab = 0; iTab < m_iTabsNum; iTab++)
	{
		if (GetTabBkColor(iTab) != (COLORREF)-1)
		{
			return TRUE;
		}
	}

	return FALSE;
}

void CMFCBaseTabCtrl::FireChangeActiveTab(int nNewTab)
{
	CFrameWnd* pParentFrame = AFXGetTopLevelFrame(this);
	CWnd* pParent = GetParent();
	ASSERT_VALID(pParent);

	pParent->SendMessage(AFX_WM_CHANGE_ACTIVE_TAB, nNewTab, (LPARAM)this);
	if (pParent != pParentFrame && pParentFrame != NULL)
	{
		ASSERT_VALID(pParentFrame);
		pParentFrame->SendMessage(AFX_WM_CHANGE_ACTIVE_TAB, nNewTab, (LPARAM)this);
	}

	m_bSetActiveTabFired = TRUE;
}

BOOL CMFCBaseTabCtrl::FireChangingActiveTab(int nNewTab)
{
	CFrameWnd* pParentFrame = AFXGetTopLevelFrame(this);
	CWnd* pParent = GetParent();
	ASSERT_VALID(pParent);

	BOOL bRes = (BOOL) pParent->SendMessage(AFX_WM_CHANGING_ACTIVE_TAB, nNewTab, (LPARAM)this);
	if (bRes)
	{
		return TRUE;
	}

	if (pParent != pParentFrame && pParentFrame != NULL)
	{
		ASSERT_VALID(pParentFrame);
		bRes = (BOOL) pParentFrame->SendMessage(AFX_WM_CHANGING_ACTIVE_TAB, nNewTab, (LPARAM)this);
	}

	return bRes;
}

BOOL CMFCBaseTabCtrl::HasImage(int iTab) const
{
	ASSERT_VALID(this);

	if (iTab < 0 || iTab >= m_iTabsNum)
	{
		return FALSE;
	}

	CMFCTabInfo* pTab = (CMFCTabInfo*) m_arTabs [iTab];
	ASSERT_VALID(pTab);

	if (pTab->m_hIcon != NULL)
	{
		return TRUE;
	}

	return GetImageList() != NULL && pTab->m_uiIcon != (UINT)-1;
}

void CMFCBaseTabCtrl::SetTabBorderSize(int nTabBorderSize, BOOL bRepaint/* = TRUE*/)
{
	if (nTabBorderSize == -1)
	{
		nTabBorderSize = AFX_DEFAULT_TAB_BORDER_SIZE;
	}

	if (m_nTabBorderSize != nTabBorderSize)
	{
		m_nTabBorderSize = nTabBorderSize;

		RecalcLayout();

		if (bRepaint && GetSafeHwnd() != NULL)
		{
			Invalidate();
			UpdateWindow();
		}
	}
}

BOOL CMFCBaseTabCtrl::EnableCustomToolTips(BOOL bEnable/* = TRUE*/)
{
	if (m_bCustomToolTips == bEnable)
	{
		return TRUE;
	}

	m_bCustomToolTips = bEnable;

	if (m_pToolTip->GetSafeHwnd() == NULL)
	{
		return TRUE;
	}

	for (int i = 0; i < m_iTabsNum; i++)
	{
		CMFCTabInfo* pTab = (CMFCTabInfo*) m_arTabs [i];
		ASSERT_VALID(pTab);

		if (m_bCustomToolTips)
		{
			CToolInfo info;

			m_pToolTip->GetToolInfo(info, this, pTab->m_iTabID);
			m_pToolTip->DelTool(this, pTab->m_iTabID);

			m_pToolTip->AddTool(this, LPSTR_TEXTCALLBACK, &info.rect, pTab->m_iTabID);
		}
		else
		{
			m_pToolTip->UpdateTipText(pTab->m_strText, this, pTab->m_iTabID);
		}
	}

	RecalcLayout();
	return TRUE;
}

BOOL CMFCBaseTabCtrl::OnNeedTipText(UINT /*id*/, NMHDR* pNMH, LRESULT* /*pResult*/)
{
	static CMFCTabToolTipInfo info;

	ENSURE(pNMH != NULL);

	LPNMTTDISPINFO pTTDispInfo = (LPNMTTDISPINFO) pNMH;
	ASSERT((pTTDispInfo->uFlags & TTF_IDISHWND) == 0);

	if (pNMH->hwndFrom == m_pToolTipClose->GetSafeHwnd())
	{
		ENSURE(info.m_strText.LoadString(IDS_AFXBARRES_CLOSEBAR));

		pTTDispInfo->lpszText = const_cast<LPTSTR>((LPCTSTR) info.m_strText);
		return TRUE;
	}

	if (m_pToolTip->GetSafeHwnd() == NULL || pNMH->hwndFrom != m_pToolTip->GetSafeHwnd())
	{
		return FALSE;
	}

	CFrameWnd* pParentFrame = AFXGetTopLevelFrame(this);
	CWnd* pParent = GetParent();
	ASSERT_VALID(pParent);

	info.m_pTabWnd = this;

	CPoint ptCursor;
	::GetCursorPos(&ptCursor);
	ScreenToClient(&ptCursor);

	if (m_rectCloseButton.PtInRect(ptCursor))
	{
		return FALSE;
	}

	info.m_nTabIndex = GetTabFromPoint(ptCursor);
	info.m_strText.Empty();

	pParent->SendMessage(AFX_WM_ON_GET_TAB_TOOLTIP, 0, (LPARAM) &info);
	if (pParent != pParentFrame && pParentFrame != NULL)
	{
		ASSERT_VALID(pParentFrame);
		pParentFrame->SendMessage(AFX_WM_ON_GET_TAB_TOOLTIP, 0, (LPARAM) &info);
	}

	if (info.m_strText.IsEmpty())
	{
		return FALSE;
	}

	pTTDispInfo->lpszText = const_cast<LPTSTR>((LPCTSTR) info.m_strText);
	return TRUE;
}

void CMFCBaseTabCtrl::OnWindowPosChanged(WINDOWPOS FAR* lpwndpos)
{
	CWnd::OnWindowPosChanged(lpwndpos);

	m_bWindowPosChanged = TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\src\mfc\afxbaseribbonelement.cpp ===
// This MFC Library source code supports the Microsoft Office Fluent User Interface 
// (the "Fluent UI") and is provided only as referential material to supplement the 
// Microsoft Foundation Classes Reference and related electronic documentation 
// included with the MFC C++ library software.  
// License terms to copy, use or distribute the Fluent UI are available separately.  
// To learn more about our Fluent UI licensing program, please visit 
// http://msdn.microsoft.com/officeui.
//
// Copyright (C) Microsoft Corporation
// All rights reserved.

#include "stdafx.h"
#include "afxbaseribbonelement.h"

#include "afxribboncategory.h"
#include "afxribbonbar.h"
#include "afxpopupmenu.h"
#include "afxribbonpanelmenu.h"
#include "afxkeyboardmanager.h"
#include "afxvisualmanager.h"
#include "afxribboncommandslistbox.h"
#include "afxribbonquickaccesstoolbar.h"
#include "afxribbonkeytip.h"
#include "afxribbonres.h"
#include "afxmenuimages.h"
#include "afxmdiframewndex.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#endif

static inline BOOL __stdcall IsSystemCommand(UINT uiCmd)
{
	return (uiCmd >= 0xF000 && uiCmd < 0xF1F0);
}

//////////////////////////////////////////////////////////////////////
// CMFCRibbonSeparator

IMPLEMENT_DYNCREATE(CMFCRibbonSeparator, CMFCRibbonBaseElement)

CMFCRibbonSeparator::CMFCRibbonSeparator(BOOL bIsHoriz)
{
	m_bIsHoriz = bIsHoriz;
}

CSize CMFCRibbonSeparator::GetRegularSize(CDC* /*pDC*/)
{
	ASSERT_VALID(this);
	return CSize(4, 4);
}

void CMFCRibbonSeparator::CopyFrom(const CMFCRibbonBaseElement& s)
{
	ASSERT_VALID(this);
	CMFCRibbonBaseElement::CopyFrom(s);

	const CMFCRibbonSeparator& src =(const CMFCRibbonSeparator&) s;
	m_bIsHoriz = src.m_bIsHoriz;
}

void CMFCRibbonSeparator::OnDraw(CDC* pDC)
{
	ASSERT_VALID(this);
	ASSERT_VALID(pDC);

	if (m_rect.IsRectEmpty())
	{
		return;
	}

	CRect rect = m_rect;

	if (m_bQuickAccessMode)
	{
		rect.left = rect.CenterPoint().x - 1;
		rect.right = rect.left + 2;

		rect.DeflateRect(0, 3);

		CMFCVisualManager::GetInstance()->OnDrawRibbonQuickAccessToolBarSeparator(pDC, this, rect);
		return;
	}

	if (m_bIsHoriz)
	{
		rect.top = rect.CenterPoint().y;
		rect.bottom = rect.top + 1;
	}
	else
	{
		rect.left = rect.CenterPoint().x;
		rect.right = rect.left + 1;

		rect.DeflateRect(0, 5);
	}

	CBasePane* pParentBar = NULL;

	if (m_pParentMenu != NULL)
	{
		pParentBar = m_pParentMenu;
	}
	else
	{
		pParentBar = GetTopLevelRibbonBar();
	}

	if (pParentBar != NULL)
	{
		BOOL bDisableSideBarInXPMode = FALSE;

		if (m_bIsDefaultMenuLook && m_pParentMenu != NULL)
		{
			bDisableSideBarInXPMode = m_pParentMenu->m_bDisableSideBarInXPMode;
			rect.left += 2 * CMFCVisualManager::GetInstance()->GetMenuImageMargin() + 2;
			m_pParentMenu->m_bDisableSideBarInXPMode = FALSE;
		}

		CMFCVisualManager::GetInstance()->OnDrawSeparator(pDC, pParentBar, rect, !m_bIsHoriz);

		if (m_pParentMenu != NULL)
		{
			m_pParentMenu->m_bDisableSideBarInXPMode = bDisableSideBarInXPMode;
		}
	}
}

int CMFCRibbonSeparator::AddToListBox(CMFCRibbonCommandsListBox* pWndListBox, BOOL /*bDeep*/)
{
	ASSERT_VALID(this);
	ASSERT_VALID(pWndListBox);
	ENSURE(pWndListBox->GetSafeHwnd() != NULL);

	CString strText;
	ENSURE(strText.LoadString(IDS_AFXBARRES_QAT_SEPARATOR));

	int nIndex = pWndListBox->AddString(_T(" ") + strText);	// Should be always first!
	pWndListBox->SetItemData(nIndex, (DWORD_PTR) this);

	return nIndex;
}

void CMFCRibbonSeparator::OnDrawOnList(CDC* pDC, CString strText, int nTextOffset, CRect rect, BOOL /*bIsSelected*/, BOOL /*bHighlighted*/)
{
	ASSERT_VALID(this);
	ASSERT_VALID(pDC);

	BOOL bIsDisabled = m_bIsDisabled;
	m_bIsDisabled = FALSE;

	const int nXMargin = 3;

	rect.DeflateRect(nXMargin, 0);
	rect.left += nTextOffset;

	pDC->DrawText(strText, rect, DT_VCENTER | DT_SINGLELINE | DT_NOPREFIX);

	m_bIsDisabled = bIsDisabled;
}

//////////////////////////////////////////////////////////////////////
// CMFCRibbonBaseElement

IMPLEMENT_DYNAMIC(CMFCRibbonBaseElement, CObject)

CMFCRibbonBaseElement::CMFCRibbonBaseElement()
{
	m_Location = RibbonElementNotInGroup;
	m_nID = 0;
	m_dwData = 0;
	m_rect.SetRectEmpty();
	m_pParent = NULL;
	m_pParentGroup = NULL;
	m_pParentMenu = NULL;
	m_bCompactMode = FALSE;
	m_bIntermediateMode = FALSE;
	m_bFloatyMode = FALSE;
	m_bQuickAccessMode = FALSE;
	m_bIsHighlighted = FALSE;
	m_bIsFocused = FALSE;
	m_bIsPressed = FALSE;
	m_bIsDisabled = FALSE;
	m_bIsChecked = FALSE;
	m_bIsRadio = FALSE;
	m_bIsDroppedDown = FALSE;
	m_pOriginal = NULL;
	m_pRibbonBar = NULL;
	m_nRow = -1;
	m_bDontNotify = FALSE;
	m_bTextAlwaysOnRight = FALSE;
	m_pPopupMenu = NULL;
	m_nImageOffset = 0;
	m_bShowGroupBorder = FALSE;
	m_bIsVisible = TRUE;
	m_bIsDefaultMenuLook = FALSE;
	m_bIsAlwaysLarge = FALSE;
	m_bDrawDefaultIcon = TRUE;
	m_bIsOnPaletteTop = FALSE;
	m_bOnBeforeShowItemMenuIsSent = FALSE;
	m_bEnableUpdateTooltipInfo   = TRUE;
	m_bEnableTooltipInfoShortcut = TRUE;
}

CMFCRibbonBaseElement::~CMFCRibbonBaseElement()
{
	if (m_pPopupMenu != NULL)
	{
		ASSERT_VALID(m_pPopupMenu);
		ENSURE(m_pPopupMenu->m_pParentRibbonElement == this);

		m_pPopupMenu->m_pParentRibbonElement = NULL;
		ClosePopupMenu();
	}
}

void CMFCRibbonBaseElement::SetID(UINT nID)
{
	ASSERT_VALID(this);
	m_nID = nID;
}

void CMFCRibbonBaseElement::SetText(LPCTSTR lpszText)
{
	ASSERT_VALID(this);
	m_strText = lpszText == NULL ? _T("") : lpszText;

	int nIndex = m_strText.Find(_T('\n'));
	if (nIndex >= 0)
	{
		m_strKeys = m_strText.Mid(nIndex + 1);
		m_strText = m_strText.Left(nIndex);
	}

	m_strText.TrimLeft();
	m_strText.TrimRight();
}

void CMFCRibbonBaseElement::SetKeys(LPCTSTR lpszKeys, LPCTSTR lpszMenuKeys)
{
	ASSERT_VALID(this);

	m_strKeys = lpszKeys == NULL ? _T("") : lpszKeys;
	m_strMenuKeys = lpszMenuKeys == NULL ? _T("") : lpszMenuKeys;
}

void CMFCRibbonBaseElement::SetTextAlwaysOnRight(BOOL bSet)
{
	ASSERT_VALID(this);
	m_bTextAlwaysOnRight = bSet;
}

void CMFCRibbonBaseElement::OnLButtonDown(CPoint /*point*/)
{
	CMFCRibbonPanel* pPanel = GetParentPanel();
	if (pPanel != NULL)
	{
		ASSERT_VALID(pPanel);

		CMFCRibbonBaseElement* pDroppedDown = pPanel->GetDroppedDown();
		if (pDroppedDown != NULL)
		{
			ASSERT_VALID(pDroppedDown);
			pDroppedDown->ClosePopupMenu();
		}
	}

	if (m_pParentMenu != NULL)
	{
		return;
	}

	if (m_pRibbonBar != NULL)
	{
		ASSERT_VALID(m_pRibbonBar);

		CMFCRibbonBaseElement* pDroppedDown = m_pRibbonBar->GetDroppedDown();
		if (pDroppedDown != NULL)
		{
			ASSERT_VALID(pDroppedDown);
			pDroppedDown->ClosePopupMenu();
		}
	}

	if (m_pParent != NULL)
	{
		ASSERT_VALID(m_pParent);

		CMFCRibbonBaseElement* pDroppedDown = m_pParent->GetDroppedDown();
		if (pDroppedDown != NULL)
		{
			ASSERT_VALID(pDroppedDown);
			pDroppedDown->ClosePopupMenu();
		}
	}
}

void CMFCRibbonBaseElement::OnUpdateCmdUI(CMFCRibbonCmdUI* pCmdUI, CFrameWnd* pTarget, BOOL bDisableIfNoHndler)
{
	ASSERT_VALID(this);
	ENSURE(pCmdUI != NULL);

	if (m_nID == 0 || IsSystemCommand(m_nID) ||
		m_nID >= AFX_IDM_FIRST_MDICHILD)
	{
		return;
	}

	pCmdUI->m_pUpdated = this;

	pCmdUI->m_nID = m_nID;
	pCmdUI->DoUpdate(pTarget, bDisableIfNoHndler);

	pCmdUI->m_pUpdated = NULL;
}

BOOL CMFCRibbonBaseElement::NotifyControlCommand(BOOL bAccelerator, int nNotifyCode, WPARAM wParam, LPARAM lParam)
{
	UNREFERENCED_PARAMETER(bAccelerator);
	UNREFERENCED_PARAMETER(nNotifyCode);
	UNREFERENCED_PARAMETER(wParam);
	UNREFERENCED_PARAMETER(lParam);

	return FALSE;
}

CMFCRibbonBaseElement* CMFCRibbonBaseElement::HitTest(CPoint /*point*/)
{
	ASSERT_VALID(this);
	return this;
}

CMFCRibbonBar* CMFCRibbonBaseElement::GetTopLevelRibbonBar() const
{
	ASSERT_VALID(this);

	if (m_pRibbonBar != NULL)
	{
		ASSERT_VALID(m_pRibbonBar);
		return m_pRibbonBar;
	}

	if (m_pParent != NULL)
	{
		ASSERT_VALID(m_pParent);

		if (m_pParent->GetParentRibbonBar() != NULL)
		{
			ASSERT_VALID(m_pParent->GetParentRibbonBar());
			return m_pParent->GetParentRibbonBar();
		}
	}

	if (m_pParentMenu != NULL)
	{
		ASSERT_VALID(m_pParentMenu);
		return m_pParentMenu->GetTopLevelRibbonBar();
	}

	return NULL;
}

void CMFCRibbonBaseElement::SetDroppedDown(CMFCPopupMenu* pPopupMenu)
{
	ASSERT_VALID(this);

	m_pPopupMenu = pPopupMenu;

	if (pPopupMenu != NULL)
	{
		ASSERT_VALID(pPopupMenu);
		pPopupMenu->SetParentRibbonElement(this);
	}
	else
	{
		NotifyHighlightListItem(-1);
	}

	BOOL bWasDroppedDown = m_bIsDroppedDown;
	m_bIsDroppedDown = pPopupMenu != NULL;

	if (!m_bIsDroppedDown)
	{
		m_bIsHighlighted = m_bIsPressed = FALSE;
	}

	if (bWasDroppedDown != m_bIsDroppedDown)
	{
		Redraw();
	}

	if (m_pParentMenu->GetSafeHwnd() != NULL && pPopupMenu == NULL)
	{
		ASSERT_VALID(m_pParentMenu);
		ASSERT_VALID(m_pParentMenu->GetParent());

		CMFCPopupMenu::m_pActivePopupMenu = (CMFCPopupMenu*) m_pParentMenu->GetParent();
	}

	m_bOnBeforeShowItemMenuIsSent = FALSE;
}

CMFCRibbonBaseElement* CMFCRibbonBaseElement::Find(const CMFCRibbonBaseElement* pElement)
{
	ASSERT_VALID(this);
	return (pElement == this) ? this : NULL;
}

CMFCRibbonBaseElement* CMFCRibbonBaseElement::FindByID(UINT uiCmdID)
{
	ASSERT_VALID(this);
	return (m_nID == uiCmdID) ? this : NULL;
}

CMFCRibbonBaseElement* CMFCRibbonBaseElement::FindByData(DWORD_PTR dwData)
{
	ASSERT_VALID(this);
	return (m_dwData == dwData) ? this : NULL;
}

CMFCRibbonBaseElement* CMFCRibbonBaseElement::FindByOriginal(CMFCRibbonBaseElement* pOriginal)
{
	ASSERT_VALID(this);
	ASSERT_VALID(pOriginal);
	return (m_pOriginal == pOriginal) ? this : NULL;
}

CMFCRibbonBaseElement* CMFCRibbonBaseElement::GetPressed()
{
	ASSERT_VALID(this);
	return IsPressed() ? this : NULL;
}

CMFCRibbonBaseElement* CMFCRibbonBaseElement::GetDroppedDown()
{
	ASSERT_VALID(this);
	return IsDroppedDown() ? this : NULL;
}

CMFCRibbonBaseElement* CMFCRibbonBaseElement::GetHighlighted()
{
	ASSERT_VALID(this);
	return IsHighlighted() ? this : NULL;
}

CMFCRibbonBaseElement* CMFCRibbonBaseElement::GetFocused()
{
	ASSERT_VALID(this);

	return IsFocused() ? this : NULL;
}

BOOL CMFCRibbonBaseElement::ReplaceByID(UINT uiCmdID, CMFCRibbonBaseElement* pElem)
{
	ASSERT_VALID(this);
	UNREFERENCED_PARAMETER(uiCmdID);
	UNREFERENCED_PARAMETER(pElem);

	return FALSE;
}

void CMFCRibbonBaseElement::SetParentCategory(CMFCRibbonCategory* pParent)
{
	ASSERT_VALID(this);
	m_pParent = pParent;
}

void CMFCRibbonBaseElement::CopyFrom(const CMFCRibbonBaseElement& src)
{
	ASSERT_VALID(this);

	m_nID = src.m_nID;
	m_dwData = src.m_dwData;
	m_bTextAlwaysOnRight = src.m_bTextAlwaysOnRight;
	m_strText = src.m_strText;
	m_strKeys = src.m_strKeys;
	m_strMenuKeys = src.m_strMenuKeys;
	m_pParent = src.m_pParent;
	m_pParentGroup = src.m_pParentGroup;
	m_strToolTip = src.m_strToolTip;
	m_strDescription = src.m_strDescription;
	m_bQuickAccessMode = src.m_bQuickAccessMode;
	m_bIsVisible = src.m_bIsVisible;
	m_bIsDefaultMenuLook = src.m_bIsDefaultMenuLook;
	m_bIsRadio = src.m_bIsRadio;
	m_bIsAlwaysLarge = src.m_bIsAlwaysLarge;
	m_bIsOnPaletteTop = src.m_bIsOnPaletteTop;
	m_bEnableUpdateTooltipInfo = src.m_bEnableUpdateTooltipInfo;
	m_bEnableTooltipInfoShortcut = src.m_bEnableTooltipInfoShortcut;
}

void CMFCRibbonBaseElement::SetParentMenu(CMFCRibbonPanelMenuBar* pMenuBar)
{
	ASSERT_VALID(this);

	m_pParentMenu = pMenuBar;
}

void CMFCRibbonBaseElement::SetOriginal(CMFCRibbonBaseElement* pOriginal)
{
	ASSERT_VALID(this);

	if (pOriginal != NULL)
	{
		ASSERT_VALID(pOriginal);

		while (pOriginal->m_pOriginal != NULL)
		{
			pOriginal = pOriginal->m_pOriginal;
		}
	}

	m_pOriginal = pOriginal;
}

CWnd* CMFCRibbonBaseElement::GetParentWnd() const
{
	ASSERT_VALID(this);

	if (m_pRibbonBar != NULL)
	{
		ASSERT_VALID(m_pRibbonBar);
		return m_pRibbonBar;
	}
	else if (m_pParentMenu != NULL)
	{
		ASSERT_VALID(m_pParentMenu);
		return m_pParentMenu;
	}
	else if (m_pParent != NULL)
	{
		ASSERT_VALID(m_pParent);
		ASSERT_VALID(m_pParent->GetParentRibbonBar());

		return m_pParent->GetParentRibbonBar();
	}

	return NULL;
}

CMFCRibbonPanel* CMFCRibbonBaseElement::GetParentPanel() const
{
	ASSERT_VALID(this);

	if (m_pParentMenu != NULL)
	{
		ASSERT_VALID(m_pParentMenu);

		if (m_pParentMenu->m_pCategory != NULL)
		{
			ASSERT_VALID(m_pParentMenu->m_pCategory);
			return m_pParentMenu->m_pCategory->FindPanelWithElem(this);
		}

		return m_pParentMenu->m_pPanel;
	}
	else if (m_pParent != NULL)
	{
		ASSERT_VALID(m_pParent);
		return m_pParent->FindPanelWithElem(this);
	}

	return NULL;
}

BOOL CMFCRibbonBaseElement::IsMenuMode() const
{
	ASSERT_VALID(this);

	if (m_pParentMenu != NULL)
	{
		ASSERT_VALID(m_pParentMenu);

		if (m_pParentMenu->m_pPanel == NULL)
		{
			return FALSE;
		}

		ASSERT_VALID(m_pParentMenu->m_pPanel);

		return m_pParentMenu->m_pPanel->IsMenuMode();
	}

	return FALSE;
}

void CMFCRibbonBaseElement::Redraw()
{
	ASSERT_VALID(this);

	if (m_rect.IsRectEmpty())
	{
		return;
	}

	if (m_pParentMenu->GetSafeHwnd() != NULL)
	{
		m_pParentMenu->RedrawWindow(m_rect);
		return;
	}

	CWnd* pWndParent = GetParentWnd();

	if (pWndParent->GetSafeHwnd() != NULL)
	{
		pWndParent->RedrawWindow(m_rect);
	}
}

CString CMFCRibbonBaseElement::GetToolTipText() const
{
	ASSERT_VALID(this);

	if (IsDroppedDown())
	{
		return _T("");
	}

	CString strTipText = m_strToolTip;

	if (m_bQuickAccessMode && strTipText.IsEmpty())
	{
		strTipText = m_strText;

		const CString strDummyAmpSeq = _T("\001\001");

		strTipText.Replace(_T("&&"), strDummyAmpSeq);
		strTipText.Remove(_T('&'));
		strTipText.Replace(strDummyAmpSeq, _T("&"));
	}

	//--------------------
	// Add shortcut label:
	//--------------------
	CWnd* pWndParent = NULL;

	if (m_pRibbonBar != NULL)
	{
		pWndParent = m_pRibbonBar;
	}
	else if (m_pParentMenu != NULL)
	{
		pWndParent = m_pParentMenu;
	}
	else if (m_pParent != NULL)
	{
		ASSERT_VALID(m_pParent);
		pWndParent = m_pParent->GetParentRibbonBar();
	}

	if (m_bEnableTooltipInfoShortcut)
	{
		CString strLabel;
		CFrameWnd* pParentFrame = AFXGetParentFrame(pWndParent) == NULL ? NULL : AFXGetTopLevelFrame(AFXGetParentFrame(pWndParent));

		if (pParentFrame != NULL && (CKeyboardManager::FindDefaultAccelerator(m_nID, strLabel, pParentFrame, TRUE) ||
			CKeyboardManager::FindDefaultAccelerator(m_nID, strLabel, pParentFrame->GetActiveFrame(), FALSE)))
		{
			strTipText += _T(" (");
			strTipText += strLabel;
			strTipText += _T(')');
		}
	}

	return strTipText;
}

CString CMFCRibbonBaseElement::GetDescription() const
{
	ASSERT_VALID(this);
	return m_strDescription;
}

void CMFCRibbonBaseElement::SetToolTipText(LPCTSTR lpszText)
{
	ASSERT_VALID(this);
	m_strToolTip = lpszText == NULL ? _T("") : lpszText;
}

void CMFCRibbonBaseElement::SetDescription(LPCTSTR lpszText)
{
	ASSERT_VALID(this);
	m_strDescription = lpszText == NULL ? _T("") : lpszText;
}

void CMFCRibbonBaseElement::EnableUpdateTooltipInfo(BOOL bEnable)
{
	if (m_bEnableUpdateTooltipInfo != bEnable)
	{
		m_bEnableUpdateTooltipInfo = bEnable;

		if (m_bEnableUpdateTooltipInfo)
		{
			UpdateTooltipInfo();
		}
	}
}

void CMFCRibbonBaseElement::EnableTooltipInfoShortcut(BOOL bEnable)
{
	m_bEnableTooltipInfoShortcut = bEnable;
}

void CMFCRibbonBaseElement::UpdateTooltipInfo()
{
	ASSERT_VALID(this);

	if (!m_bEnableUpdateTooltipInfo || m_nID == 0 || m_nID == (UINT)-1)
	{
		return;
	}

	CString strText;
	if (!strText.LoadString(m_nID))
	{
		return;
	}

	m_strToolTip.Empty();
	m_strDescription.Empty();

	if (strText.IsEmpty())
	{
		return;
	}

	AfxExtractSubString(m_strDescription, strText, 0);
	AfxExtractSubString(m_strToolTip, strText, 1, '\n');

	const CString strDummyAmpSeq = _T("\001\001");

	m_strToolTip.Replace(_T("&&"), strDummyAmpSeq);
	m_strToolTip.Remove(_T('&'));
	m_strToolTip.Replace(strDummyAmpSeq, _T("&"));
}

void CMFCRibbonBaseElement::OnAfterChangeRect(CDC* /*pDC*/)
{
	ASSERT_VALID(this);

	if (m_strToolTip.IsEmpty())
	{
		UpdateTooltipInfo();
	}
}

BOOL CMFCRibbonBaseElement::NotifyCommand(BOOL bWithDelay)
{
	ASSERT_VALID(this);

	if (m_pOriginal != NULL)
	{
		if (m_bQuickAccessMode && (m_bIsHighlighted || m_bIsPressed || m_bIsFocused))
		{
			m_bIsHighlighted = m_bIsPressed = m_bIsFocused = FALSE;
			Redraw();
		}

		ASSERT_VALID(m_pOriginal);
		return m_pOriginal->NotifyCommand(bWithDelay);
	}

	UINT uiID = GetNotifyID();

	if (uiID == 0 || uiID == (UINT)-1)
	{
		return FALSE;
	}

	CMFCRibbonBar* pRibbonBar = GetTopLevelRibbonBar();
	if (pRibbonBar == NULL)
	{
		return FALSE;
	}

	ASSERT_VALID(pRibbonBar);

	CWnd* pWndParent = pRibbonBar->GetParent();
	if (pWndParent == NULL)
	{
		return FALSE;
	}

	m_bIsHighlighted = m_bIsPressed = m_bIsFocused = FALSE;

	Redraw();

	ASSERT_VALID(pWndParent);

	if (uiID == AFX_IDM_FIRST_MDICHILD)
	{
		HWND hwndMDIChild = (HWND) m_dwData;

		if (::IsWindow(hwndMDIChild))
		{
			CMFCRibbonBar* pTopLevelRibbon = GetTopLevelRibbonBar();
			if (pTopLevelRibbon != NULL)
			{
				CMDIFrameWndEx* pMDIFrameWnd = DYNAMIC_DOWNCAST(CMDIFrameWndEx, pTopLevelRibbon->GetTopLevelFrame());

				if (pMDIFrameWnd != NULL)
				{
					WINDOWPLACEMENT	wndpl;
					wndpl.length = sizeof(WINDOWPLACEMENT);
					::GetWindowPlacement(hwndMDIChild,&wndpl);

					if (wndpl.showCmd == SW_SHOWMINIMIZED)
					{
						::ShowWindow(hwndMDIChild, SW_RESTORE);
					}

					if (bWithDelay)
					{
						::PostMessage(pMDIFrameWnd->m_hWndMDIClient, WM_MDIACTIVATE, (WPARAM) hwndMDIChild, 0);
					}
					else
					{
						::SendMessage(pMDIFrameWnd->m_hWndMDIClient, WM_MDIACTIVATE, (WPARAM) hwndMDIChild, 0);
					}

					return TRUE;
				}
			}
		}
	}

	if (bWithDelay)
	{
		pWndParent->PostMessage(WM_COMMAND, uiID);
	}
	else
	{
		pWndParent->SendMessage(WM_COMMAND, uiID);
	}

	return TRUE;
}

void CMFCRibbonBaseElement::PostMenuCommand(UINT /*uiCmdId*/)
{
	ASSERT_VALID(this);

	m_bIsDroppedDown = FALSE;
	Redraw();

	if (m_pParentMenu != NULL)
	{
		ASSERT_VALID(m_pParentMenu);
		m_pParentMenu->GetParent()->SendMessage(WM_CLOSE);
	}
}

void CMFCRibbonBaseElement::GetElementsByID(UINT uiCmdID, CArray <CMFCRibbonBaseElement*, CMFCRibbonBaseElement*>& arElements)
{
	ASSERT_VALID(this);

	if (uiCmdID == m_nID)
	{
		arElements.Add(this);
	}
}

void CMFCRibbonBaseElement::GetItemIDsList(CList<UINT,UINT>& lstItems) const
{
	ASSERT_VALID(this);

	if (m_nID != 0 && m_nID != (UINT)-1 && lstItems.Find(m_nID) == NULL)
	{
		lstItems.AddTail(m_nID);
	}
}

int CMFCRibbonBaseElement::AddToListBox(CMFCRibbonCommandsListBox* pWndListBox, BOOL /*bDeep*/)
{
	ASSERT_VALID(this);
	ASSERT_VALID(pWndListBox);
	ENSURE(pWndListBox->GetSafeHwnd() != NULL);

	if (m_nID == 0 || m_nID == (UINT)-1)
	{
		return -1;
	}

	if (m_nID >= ID_FILE_MRU_FILE1 && m_nID <= ID_FILE_MRU_FILE16)
	{
		return -1;
	}

	for (int i = 0; i < pWndListBox->GetCount (); i++)
	{
		CMFCRibbonBaseElement* pItem = (CMFCRibbonBaseElement*) pWndListBox->GetItemData (i);
		if (pItem == NULL)
		{
			continue;
		}

		ASSERT_VALID(pItem);

		if (pItem->m_nID == m_nID && !pItem->HasMenu ())
		{
			// Already exist, don't add it
			return -1;
		}
	}


	UpdateTooltipInfo();

	CString strText = m_strToolTip;
	if (strText.IsEmpty())
	{
		strText = GetText();
	}

	const CString strDummyAmpSeq = _T("\001\001");

	strText.Replace(_T("&&"), strDummyAmpSeq);
	strText.Remove(_T('&'));
	strText.Replace(strDummyAmpSeq, _T("&"));

	int nIndex = pWndListBox->AddString(strText);
	pWndListBox->SetItemData(nIndex, (DWORD_PTR) this);

	return nIndex;
}

void CMFCRibbonBaseElement::OnDrawOnList(CDC* pDC, CString strText, int nTextOffset, CRect rect, BOOL /*bIsSelected*/, BOOL /*bHighlighted*/)
{
	ASSERT_VALID(this);
	ASSERT_VALID(pDC);

	BOOL bIsDisabled = m_bIsDisabled;
	m_bIsDisabled = FALSE;

	if (m_bDrawDefaultIcon)
	{
		CRect rectImage = rect;
		rectImage.right = rect.left + nTextOffset;

		CMFCVisualManager::GetInstance()->OnDrawDefaultRibbonImage(pDC, rectImage);
	}

	CRect rectText = rect;

	rectText.left += nTextOffset;

	const int nXMargin = 3;
	rectText.DeflateRect(nXMargin, 0);

	pDC->DrawText(strText, rectText, DT_VCENTER | DT_SINGLELINE | DT_NOPREFIX);
	m_bIsDisabled = bIsDisabled;
}

void CMFCRibbonBaseElement::ClosePopupMenu()
{
	ASSERT_VALID(this);

	if (m_pPopupMenu != NULL && ::IsWindow(m_pPopupMenu->m_hWnd))
	{
		if (m_pPopupMenu->InCommand())
		{
			return;
		}

		m_pPopupMenu->m_bAutoDestroyParent = FALSE;
		m_pPopupMenu->CloseMenu();
	}

	m_pPopupMenu = NULL;
	m_bOnBeforeShowItemMenuIsSent = FALSE;
}

BOOL CMFCRibbonBaseElement::CanBeAddedToQuickAccessToolBar() const
{
	ASSERT_VALID(this);

	return m_nID != 0 && m_nID != (UINT)-1 && !IsStandardCommand(m_nID);
}

BOOL CMFCRibbonBaseElement::OnAddToQAToolbar(CMFCRibbonQuickAccessToolBar& qat)
{
	qat.Add(this);
	return TRUE;
}

BOOL CMFCRibbonBaseElement::StretchToWholeRow(CDC* /*pDC*/, int nHeight)
{
	ASSERT_VALID(this);

	if (!CanBeStretched() || m_bCompactMode || m_bIntermediateMode)
	{
		return FALSE;
	}

	m_rect.bottom = m_rect.top + nHeight;
	return TRUE;
}

BOOL CMFCRibbonBaseElement::SetACCData(CWnd* pParent, CAccessibilityData& data)
{
	ASSERT_VALID(this);
	ASSERT_VALID(pParent);

	data.Clear();

	data.m_strAccName = m_strText.IsEmpty() ? m_strToolTip : m_strText;
	data.m_strAccName.Remove(_T('&'));
	data.m_strAccName.Trim();

	data.m_nAccRole = IsMenuMode() ? ROLE_SYSTEM_MENUITEM : ROLE_SYSTEM_PUSHBUTTON;

	data.m_strDescription = m_strDescription;
	data.m_nAccHit = 1;
	data.m_strAccDefAction = IsMenuMode () ? _T("Execute") : _T("Press");

	data.m_bAccState = STATE_SYSTEM_FOCUSABLE;
	if (IsChecked())
	{
		data.m_bAccState |= STATE_SYSTEM_CHECKED;
	}

	if (IsDisabled())
	{
		data.m_bAccState |= STATE_SYSTEM_UNAVAILABLE;
	}

	if (IsPressed() || IsMenuMode() && IsHighlighted())
	{
		data.m_bAccState |= STATE_SYSTEM_FOCUSED;
	}

	data.m_rectAccLocation = m_rect;
	pParent->ClientToScreen(&data.m_rectAccLocation);

	CString strKeys = m_strKeys;

	if (!m_bQuickAccessMode && m_pParentMenu != NULL && strKeys.GetLength() < 2)
	{
		// Try to find key from label:
		int nIndexAmp = m_strText.Find(_T('&'));

		if (nIndexAmp >= 0 && nIndexAmp < m_strText.GetLength() - 1 && m_strText[nIndexAmp + 1] != _T('&'))
		{
			strKeys = m_strText.Mid(nIndexAmp + 1, 1);
		}
	}

	if (!strKeys.IsEmpty())
	{
		data.m_strAccKeys = _T("Alt, ");

		if (m_pParent != NULL)
		{
			ASSERT_VALID(m_pParent);
			data.m_strAccKeys += m_pParent->m_Tab.m_strKeys + _T(", ");
		}

		data.m_strAccKeys += strKeys;
	}

	return TRUE;
}

void CMFCRibbonBaseElement::OnDrawKeyTip(CDC* pDC, const CRect& rect, BOOL bIsMenu)
{
	ASSERT_VALID(this);
	ASSERT_VALID(pDC);

	if (m_strKeys.IsEmpty())
	{
		return;
	}

	CMFCVisualManager::GetInstance()->OnDrawRibbonKeyTip(pDC, this, rect, bIsMenu ? m_strMenuKeys : m_strKeys);
}

CSize CMFCRibbonBaseElement::GetKeyTipSize(CDC* pDC)
{
	ASSERT_VALID(this);
	ASSERT_VALID(pDC);

	if (!m_bQuickAccessMode && m_pParentMenu != NULL && m_strKeys.GetLength() < 2)
	{
		// Try to find key from label:
		int nIndexAmp = m_strText.Find(_T('&'));

		if (nIndexAmp >= 0 && nIndexAmp < m_strText.GetLength() - 1 && m_strText [nIndexAmp + 1] != _T('&'))
		{
			m_strKeys = m_strText.Mid(nIndexAmp + 1, 1);
		}
	}

	if (m_strKeys.IsEmpty())
	{
		return CSize(0, 0);
	}

	const CString strMin = _T("O");

	CSize sizeMin = pDC->GetTextExtent(strMin);
	CSize sizeText = pDC->GetTextExtent(m_strKeys);

	sizeText.cx = max(sizeText.cx, sizeMin.cx);
	sizeText.cy = max(sizeText.cy, sizeMin.cy);

	return CSize(sizeText.cx + 10, sizeText.cy + 2);
}

BOOL CMFCRibbonBaseElement::OnKey(BOOL bIsMenuKey)
{
	ASSERT_VALID(this);

	if (m_bIsDisabled)
	{
		return FALSE;
	}

	if (m_rect.IsRectEmpty())
	{
		CMFCRibbonPanel* pParentPanel = GetParentPanel();
		if (pParentPanel != NULL)
		{
			ASSERT_VALID(pParentPanel);

			if (pParentPanel->IsCollapsed())
			{
				if (!HasMenu())
				{
					if (!NotifyCommand(TRUE))
					{
						return FALSE;
					}

					if (m_pParentMenu != NULL)
					{
						CMFCRibbonBar* pTopLevelRibbon = GetTopLevelRibbonBar();

						// Close menu:
						ASSERT_VALID(m_pParentMenu);

						CFrameWnd* pParentFrame = AFXGetParentFrame(m_pParentMenu);
						ASSERT_VALID(pParentFrame);

						pParentFrame->DestroyWindow();

						if (pTopLevelRibbon != NULL && pTopLevelRibbon->GetTopLevelFrame() != NULL)
						{
							pTopLevelRibbon->GetTopLevelFrame()->SetFocus();
						}
					}

					return TRUE;
				}
				else
				{
					CMFCRibbonBar* pTopLevelRibbon = GetTopLevelRibbonBar();
					if (pTopLevelRibbon != NULL)
					{
						pTopLevelRibbon->HideKeyTips();
					}

					CMFCRibbonPanelMenu* pPopup = pParentPanel->ShowPopup();
					if (pPopup != NULL)
					{
						ASSERT_VALID(pPopup);

						CMFCRibbonBaseElement* pPopupElem = pPopup->FindByOrigin(this);
						if (pPopupElem != NULL)
						{
							ASSERT_VALID(pPopupElem);
							return pPopupElem->OnKey(bIsMenuKey);
						}
					}
				}
			}
		}

		return FALSE;
	}

	return NotifyCommand(TRUE);
}

void CMFCRibbonBaseElement::AddToKeyList(CArray<CMFCRibbonKeyTip*,CMFCRibbonKeyTip*>& arElems)
{
	ASSERT_VALID(this);

	arElems.Add(new CMFCRibbonKeyTip(this));

	if (!m_strMenuKeys.IsEmpty() && HasMenu())
	{
		arElems.Add(new CMFCRibbonKeyTip(this, TRUE));
	}
}

int CMFCRibbonBaseElement::GetDropDownImageWidth() const
{
	ASSERT_VALID(this);

	return CMenuImages::Size().cx;
}

void CMFCRibbonBaseElement::NotifyHighlightListItem(int nIndex)
{
	ASSERT_VALID(this);

	CMFCRibbonBar* pRibbonBar = GetTopLevelRibbonBar();
	if (pRibbonBar == NULL)
	{
		return;
	}

	ASSERT_VALID(pRibbonBar);

	CWnd* pWndParent = pRibbonBar->GetParent();
	if (pWndParent == NULL)
	{
		return;
	}

	pWndParent->SendMessage(AFX_WM_ON_HIGHLIGHT_RIBBON_LIST_ITEM, (WPARAM)nIndex, (LPARAM)this);
}

void CMFCRibbonBaseElement::OnShowPopupMenu()
{
	ASSERT_VALID(this);

	CMFCRibbonBar* pRibbonBar = GetTopLevelRibbonBar();
	if (pRibbonBar == NULL)
	{
		return;
	}

	ASSERT_VALID(pRibbonBar);

	CWnd* pWndParent = pRibbonBar->GetParent();
	if (pWndParent == NULL)
	{
		return;
	}

	if (!m_bOnBeforeShowItemMenuIsSent)
	{
		m_bOnBeforeShowItemMenuIsSent = TRUE;
		pWndParent->SendMessage(AFX_WM_ON_BEFORE_SHOW_RIBBON_ITEM_MENU, (WPARAM)0, (LPARAM)this);
	}
}

void CMFCRibbonBaseElement::GetVisibleElements(CArray <CMFCRibbonBaseElement*, CMFCRibbonBaseElement*>& arElements)
{
	ASSERT_VALID(this);

	if (!m_rect.IsRectEmpty())
	{
		arElements.Add(this);
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\src\mfc\afxbasetabbedpane.cpp ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#include "stdafx.h"
#include "afxcontrolbarutil.h"
#include "afxbasetabctrl.h"
#include "afxbasetabbedpane.h"
#include "afxpaneframewnd.h"
#include "afxmultipaneframewnd.h"
#include "afxdockablepaneadapter.h"
#include "afxautohidebar.h"
#include "afxdocksite.h"
#include "afxglobalutils.h"
#include "afxmdiframewndex.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#endif

IMPLEMENT_DYNAMIC(CBaseTabbedPane, CDockablePane)

/////////////////////////////////////////////////////////////////////////////
// CBaseTabbedPane

CBaseTabbedPane::CBaseTabbedPane(BOOL bAutoDestroy)
{
	m_bAutoDestroy = bAutoDestroy;
	m_pTabWnd = NULL;
	m_bEnableIDChecking = FALSE;
	m_bSetCaptionTextToTabName = TRUE;

	EnableDocking(CBRS_ALIGN_ANY);
}

CBaseTabbedPane::~CBaseTabbedPane()
{
}

//{{AFX_MSG_MAP(CBaseTabbedPane)
BEGIN_MESSAGE_MAP(CBaseTabbedPane, CDockablePane)
	ON_WM_SIZE()
	ON_WM_NCDESTROY()
	ON_WM_ERASEBKGND()
	ON_WM_SETFOCUS()
	ON_REGISTERED_MESSAGE(AFX_WM_CHANGE_ACTIVE_TAB, &CBaseTabbedPane::OnChangeActiveTab)
END_MESSAGE_MAP()
//}}AFX_MSG_MAP

/////////////////////////////////////////////////////////////////////////////
// CBaseTabbedPane message handlers

void CBaseTabbedPane::OnSize(UINT nType, int cx, int cy)
{
	CDockablePane::OnSize(nType, cx, cy);

	CWnd* pUnderlinedWnd = GetUnderlyingWindow();

	if (pUnderlinedWnd != NULL && IsWindow(pUnderlinedWnd->GetSafeHwnd()))
	{
		CRect rectClient;
		GetClientRect(rectClient);

		pUnderlinedWnd->SetWindowPos(NULL, 0, 0, rectClient.Width(), rectClient.Height(), SWP_NOACTIVATE | SWP_NOZORDER | SWP_NOREDRAW);
	}
}

void CBaseTabbedPane::OnNcDestroy()
{
	if (m_pTabWnd != NULL)
	{
		delete m_pTabWnd;
		m_pTabWnd = NULL;
	}

	CDockablePane::OnNcDestroy();

	if (m_bAutoDestroy)
	{
		delete this;
	}
}

BOOL CBaseTabbedPane::OnEraseBkgnd(CDC* /*pDC*/)
{
	return TRUE;
}

BOOL CBaseTabbedPane::AddTab(CWnd* pNewBar, BOOL bVisible, BOOL bSetActive, BOOL bDetachable)
{
	ASSERT_VALID(this);
	ASSERT_VALID(m_pTabWnd);
	ASSERT_VALID(pNewBar);

	if (pNewBar->IsKindOf(RUNTIME_CLASS(CBaseTabbedPane)))
	{
		CBaseTabbedPane* pTabbedControlBar = DYNAMIC_DOWNCAST(CBaseTabbedPane, pNewBar);

		// it's false when the tabbed bar is added from miniframe to docksite
		BOOL bSetInfoForSlider = (GetParentMiniFrame() != NULL);

		ASSERT_VALID(pTabbedControlBar);

		CMFCBaseTabCtrl* pWndTab = pTabbedControlBar->GetUnderlyingWindow();

		ASSERT_VALID(pWndTab);

		int nTabsNum = pWndTab->GetTabsNum();
		ASSERT(nTabsNum > 0);

		for (int i = 0; i < nTabsNum; i++)
		{
			CBasePane* pWnd = DYNAMIC_DOWNCAST(CBasePane, pWndTab->GetTabWnd(i));
			ASSERT_VALID(pWnd);

			bVisible = pWndTab->IsTabVisible(i);
			bDetachable = pWndTab->IsTabDetachable(i);

			pWnd->EnableGripper(FALSE);

			if (!AddTab(pWnd, bVisible, bVisible, bDetachable))
			{
				ASSERT(FALSE);
			}

			CDockablePane* pDockingBar = DYNAMIC_DOWNCAST(CDockablePane, pWnd);
			if (pDockingBar != NULL)
			{
				pDockingBar->m_recentDockInfo.SetInfo(bSetInfoForSlider, pTabbedControlBar->m_recentDockInfo);
			}
		}

		pWndTab->RemoveAllTabs();
		pNewBar->DestroyWindow();

		// stop processing - this function will be called
		// from AttachToTabWnd
		return FALSE;
	}
	else
	{
		if (pNewBar->IsKindOf(RUNTIME_CLASS(CPane)))
		{
			CPane* pNewControlBar = DYNAMIC_DOWNCAST(CPane, pNewBar);
			ASSERT_VALID(pNewControlBar);

			CWnd* pOldParent = pNewControlBar->GetParent();
			pNewControlBar->OnBeforeChangeParent(m_pTabWnd, TRUE);
			pNewControlBar->SetParent(m_pTabWnd);
			pNewControlBar->OnAfterChangeParent(pOldParent);

			if (pNewControlBar->IsKindOf(RUNTIME_CLASS(CDockablePane)))
			{
				((CDockablePane*) pNewControlBar)->EnableGripper(FALSE);
			}
		}

		CString strText;
		pNewBar->GetWindowText(strText);

		m_pTabWnd->AddTab(pNewBar, strText, bSetActive, bDetachable);

		int iTab = m_pTabWnd->GetTabsNum() - 1;
		m_pTabWnd->SetTabHicon(iTab, pNewBar->GetIcon(FALSE));
		m_pTabWnd->EnableTabDetach(iTab, bDetachable);

		if (bVisible)
		{
			if (bSetActive)
			{
				m_pTabWnd->SetActiveTab(iTab);
			}
		}
		else
		{
			ASSERT(!bSetActive);
			m_pTabWnd->ShowTab(iTab, FALSE);
		}
	}
	return TRUE;
}


CWnd* CBaseTabbedPane::FindPaneByID(UINT uBarID)
{
	ASSERT_VALID(this);
	ASSERT_VALID(m_pTabWnd);

	for (int i = 0; i < m_pTabWnd->GetTabsNum(); i++)
	{
		CWnd* pBar = m_pTabWnd->GetTabWnd(i);
		ASSERT_VALID(pBar);

		if ((UINT) pBar->GetDlgCtrlID() == uBarID)
		{
			return pBar;
		}
	}

	return NULL;
}

CWnd* CBaseTabbedPane::FindBarByTabNumber(int nTabNum, BOOL bGetWrappedBar)
{
	ASSERT_VALID(this);
	ASSERT_VALID(m_pTabWnd);

	if (nTabNum < 0 || nTabNum >= m_pTabWnd->GetTabsNum())
	{
		return NULL;
	}

	CWnd* pWnd = m_pTabWnd->GetTabWnd(nTabNum);
	ASSERT_VALID(pWnd);

	if (bGetWrappedBar && pWnd->IsKindOf(RUNTIME_CLASS(CDockablePaneAdapter)))
	{
		CDockablePaneAdapter* pWrapper = DYNAMIC_DOWNCAST(CDockablePaneAdapter, pWnd);
		pWnd = pWrapper->GetWrappedWnd();
		ASSERT_VALID(pWnd);
	}

	return pWnd;
}

BOOL CBaseTabbedPane::DetachPane(CWnd* pBar, BOOL bHide)
{
	ASSERT_VALID(this);
	ASSERT_VALID(pBar);
	ASSERT_VALID(m_pTabWnd);

	int nTabNumber = m_pTabWnd->GetTabFromHwnd(pBar->GetSafeHwnd());

	if (nTabNumber < 0)
	{
		return FALSE;
	}

	m_pTabWnd->DetachTab(DM_UNKNOWN, nTabNumber, bHide);
	return TRUE;
}

BOOL CBaseTabbedPane::RemovePane(CWnd* pBar)
{
	ASSERT_VALID(this);
	ASSERT_VALID(pBar);
	ASSERT_VALID(m_pTabWnd);

	int nTabNumber = m_pTabWnd->GetTabFromHwnd(pBar->GetSafeHwnd());

	if (nTabNumber < 0 || nTabNumber >= m_pTabWnd->GetTabsNum())
	{
		return FALSE;
	}

	m_pTabWnd->RemoveTab(nTabNumber);

	if (m_pTabWnd->GetTabsNum() == 0)
	{
		if (AllowDestroyEmptyTabbedPane())
		{
			if (IsDocked())
			{
				UndockPane();
			}
			else
			{
				CPaneFrameWnd* pMiniFrame = GetParentMiniFrame();
				pMiniFrame->RemovePane(this);
			}

			DestroyWindow();
			return FALSE;
		}
		else
		{
			m_pTabWnd->ShowWindow(SW_HIDE);
		}
	}

	return TRUE;
}

BOOL CBaseTabbedPane::ShowTab(CWnd* pBar, BOOL bShow, BOOL bDelay, BOOL bActivate)
{
	ASSERT_VALID(this);
	ASSERT_VALID(pBar);
	ASSERT_VALID(m_pTabWnd);

	int nTabNum = m_pTabWnd->GetTabFromHwnd(pBar->GetSafeHwnd());

	BOOL bResult = m_pTabWnd->ShowTab(nTabNum, bShow, !bDelay, bActivate);
	BOOL bNowVisible = m_pTabWnd->GetVisibleTabsNum() > 0;

	if (bNowVisible && !(m_pTabWnd->GetStyle() & WS_VISIBLE))
	{
		m_pTabWnd->ShowWindow(SW_SHOW);
	}

	CDockablePane::ShowPane(bNowVisible, bDelay, bActivate);
	return bResult;
}

BOOL CBaseTabbedPane::FloatTab(CWnd* pBar, int nTabID, AFX_DOCK_METHOD dockMethod, BOOL bHide)
{
	ASSERT_VALID(this);
	ASSERT_VALID(pBar);
	ASSERT_VALID(m_pTabWnd);

	CString strWndText;
	pBar->GetWindowText(strWndText);

	if (strWndText.IsEmpty())
	{
		if (m_pTabWnd->GetTabLabel(nTabID, strWndText))
		{
			pBar->SetWindowText(strWndText);
		}
	}

	m_pTabWnd->RemoveTab(nTabID);

	if (dockMethod == DM_MOUSE)
	{
		m_pTabWnd->SendMessage(WM_LBUTTONUP, 0, 0);
	}

	CDockablePane* pDockingBar = DYNAMIC_DOWNCAST(CDockablePane, pBar);

	if (pDockingBar != NULL)
	{
		pDockingBar->StoreRecentTabRelatedInfo();
	}

	if (dockMethod == DM_DBL_CLICK && pDockingBar != NULL)
	{
		CMultiPaneFrameWnd* pParentMiniFrame = DYNAMIC_DOWNCAST(CMultiPaneFrameWnd, GetParentMiniFrame());

		if (pParentMiniFrame != NULL)
		{
			pParentMiniFrame->DockRecentPaneToMainFrame(pDockingBar);
			return TRUE;
		}
		else if (m_hDefaultSlider != NULL && IsWindow(m_hDefaultSlider))
		{
			CMultiPaneFrameWnd* pRecentMiniFrame = DYNAMIC_DOWNCAST(CMultiPaneFrameWnd, CWnd::FromHandlePermanent(pDockingBar->m_recentDockInfo.m_hRecentMiniFrame));
			if (pRecentMiniFrame != NULL && pRecentMiniFrame->AddRecentPane(pDockingBar))
			{
				return TRUE;
			}
		}
	}

	if (pBar->IsKindOf(RUNTIME_CLASS(CPane)))
	{
		CPane* pControlBar = DYNAMIC_DOWNCAST(CPane, pBar);
		ASSERT_VALID(pControlBar);
		pControlBar->FloatPane(pControlBar->m_recentDockInfo.m_rectRecentFloatingRect, dockMethod, !bHide);
		return TRUE;
	}
	return FALSE;
}

void CBaseTabbedPane::StoreRecentDockSiteInfo()
{
	int nTabsNum = m_pTabWnd->GetTabsNum();
	for (int i = 0; i < nTabsNum; i++)
	{
		CDockablePane* pBar = DYNAMIC_DOWNCAST(CDockablePane, m_pTabWnd->GetTabWnd(i));
		if (pBar != NULL)
		{
			pBar->StoreRecentTabRelatedInfo();
		}
	}

	CDockablePane::StoreRecentDockSiteInfo();
}

BOOL CBaseTabbedPane::FloatPane(CRect rectFloat, AFX_DOCK_METHOD dockMethod, bool bShow)
{
	ASSERT_VALID(this);
	ASSERT_VALID(m_pTabWnd);

	if (!CDockablePane::FloatPane(rectFloat, dockMethod, bShow))
	{
		return FALSE;
	}

	CPaneFrameWnd* pParentFrame = GetParentMiniFrame();
	if (pParentFrame != NULL)
	{
		pParentFrame->SetIcon(m_pTabWnd->GetTabHicon(m_pTabWnd->GetActiveTab()), FALSE);
	}

	return TRUE;
}

void CBaseTabbedPane::Serialize(CArchive& ar)
{
	CDockablePane::Serialize(ar);
}

void CBaseTabbedPane::SerializeTabWindow(CArchive& ar)
{
	if (m_pTabWnd != NULL)
	{
		m_pTabWnd->Serialize(ar);
	}
}

void __stdcall CBaseTabbedPane::LoadSiblingPaneIDs(CArchive& ar, CList<UINT, UINT>& lstBarIDs)
{
	ASSERT(ar.IsLoading());
	if (ar.IsLoading())
	{
		int nTabsNum = 0;
		ar >> nTabsNum;
		for (int i = 0; i < nTabsNum; i++)
		{
			int nBarID = -1;
			ar >> nBarID;
			ASSERT(nBarID != -1);
			lstBarIDs.AddTail(nBarID);
		}
	}
}

void CBaseTabbedPane::SaveSiblingBarIDs(CArchive& ar)
{
	ASSERT_VALID(this);
	ASSERT(ar.IsStoring());
	ASSERT_VALID(m_pTabWnd);

	if (ar.IsStoring() && m_pTabWnd != NULL)
	{
		int nTabsNum = m_pTabWnd->GetTabsNum();
		// DO NOT SAVE empty tabbed bars
		if (nTabsNum > 0)
		{
			ar << nTabsNum;
			for (int i = 0; i < nTabsNum; i++)
			{
				CBasePane* pWnd = DYNAMIC_DOWNCAST(CBasePane, m_pTabWnd->GetTabWnd(i));
				ASSERT_VALID(pWnd);

				ar << pWnd->GetDlgCtrlID();
			}
		}
	}
}

BOOL CBaseTabbedPane::LoadState(LPCTSTR lpszProfileName, int nIndex, UINT uiID)
{
	ASSERT_VALID(this);
	ASSERT_VALID(m_pTabWnd);

	FillDefaultTabsOrderArray();

	// if initially tabbed bars were detached by user and exist only as regular
	// docking control bars we need to give them a chance to load their state
	// from the registry

	CDockablePane::LoadState(lpszProfileName, nIndex, uiID);

	int nTabsNum = m_pTabWnd->GetTabsNum();
	for (int i = 0; i < nTabsNum; i++)
	{
		CBasePane* pWnd = DYNAMIC_DOWNCAST(CBasePane, m_pTabWnd->GetTabWnd(i));

		if (pWnd != NULL)
		{
			ASSERT_VALID(pWnd);
			pWnd->LoadState(lpszProfileName, nIndex, uiID);
		}
	}

	return TRUE;
}

BOOL CBaseTabbedPane::SaveState(LPCTSTR lpszProfileName, int nIndex, UINT uiID)
{
	ASSERT_VALID(this);
	ASSERT_VALID(m_pTabWnd);

	CDockablePane::SaveState(lpszProfileName, nIndex, uiID);

	int nTabsNum = m_pTabWnd->GetTabsNum();
	for (int i = 0; i < nTabsNum; i++)
	{
		CBasePane* pWnd = DYNAMIC_DOWNCAST(CBasePane, m_pTabWnd->GetTabWnd(i));

		if (pWnd != NULL)
		{
			ASSERT_VALID(pWnd);
			if (!pWnd->SaveState(lpszProfileName, nIndex, uiID))
			{
				return FALSE;
			}
		}
	}

	return TRUE;
}


void CBaseTabbedPane::ApplyRestoredTabInfo(BOOL bUseTabIndexes)
{
	ASSERT_VALID(this);

	if (m_pTabWnd != NULL)
	{
		m_pTabWnd->ApplyRestoredTabInfo(bUseTabIndexes);
	}
}

void CBaseTabbedPane::RecalcLayout()
{
	ASSERT_VALID(this);

	CDockablePane::RecalcLayout();

	if (m_pTabWnd != NULL)
	{
		m_pTabWnd->RecalcLayout();
	}
}

BOOL CBaseTabbedPane::CanFloat() const
{
	ASSERT_VALID(this);

	return CDockablePane::CanFloat();
}

void CBaseTabbedPane::OnSetFocus(CWnd* pOldWnd)
{
	CDockablePane::OnSetFocus(pOldWnd);

	// Pass the focus to the tab window
	CWnd* pWndChild = GetUnderlyingWindow();
	if (pWndChild != NULL)
		pWndChild->SetFocus();
}

CMFCAutoHideBar* CBaseTabbedPane::SetAutoHideMode(BOOL bMode, DWORD dwAlignment, CMFCAutoHideBar* pCurrAutoHideBar, BOOL bUseTimer)
{
	BOOL bHandleMinSize = CPane::m_bHandleMinSize;
	if (bHandleMinSize)
	{
		CPane::m_bHandleMinSize = FALSE;
	}

	CMFCAutoHideBar* pAutoHideBar = pCurrAutoHideBar;
	CDockablePane* pActiveBar = NULL;

	int nActiveTab = m_pTabWnd->GetActiveTab();
	int nTabsNum = m_pTabWnd->GetTabsNum();

	CObList lstTmp;

	ShowPane(FALSE, TRUE, FALSE);

	int nNonDetachedCount = 0;
	for (int nNextTab = nTabsNum - 1; nNextTab >= 0; nNextTab--)
	{
		CDockablePane* pBar = DYNAMIC_DOWNCAST(CDockablePane, m_pTabWnd->GetTabWnd(nNextTab));
		ASSERT_VALID(pBar);

		BOOL bIsVisible = m_pTabWnd->IsTabVisible(nNextTab);
		BOOL bDetachable = m_pTabWnd->IsTabDetachable(nNextTab);

		if (pBar != NULL && bIsVisible && bDetachable)
		{
			m_pTabWnd->RemoveTab(nNextTab, FALSE);
			pBar->EnableGripper(TRUE);

			pBar->StoreRecentTabRelatedInfo();

			CWnd* pOldParent = pBar->GetParent();
			pBar->OnBeforeChangeParent(m_pDockSite);
			pBar->SetParent(m_pDockSite);
			pBar->SetOwner(m_pDockSite);
			pBar->OnAfterChangeParent(pOldParent);

			lstTmp.AddHead(pBar);

			if (nNextTab == nActiveTab)
			{
				pActiveBar = pBar;
			}
		}
		else
		{
			nNonDetachedCount++;
		}
	}

	BOOL bActiveSet = FALSE;
	CPane* pNewAHBar = NULL;

	for (POSITION pos = lstTmp.GetHeadPosition(); pos != NULL;)
	{
		CDockablePane* pBar = DYNAMIC_DOWNCAST(CDockablePane, lstTmp.GetNext(pos));
		ENSURE(pBar != NULL);
		ASSERT_VALID(pBar);

		BOOL bUseTimerForActiveBar = (pBar == pActiveBar) && bUseTimer;
		pNewAHBar = pBar->SetAutoHideMode(TRUE, dwAlignment, NULL, bUseTimerForActiveBar);

		if (pNewAHBar != NULL)
		{
			pNewAHBar->m_bFirstInGroup = (lstTmp.GetHead() == pBar);
			pNewAHBar->m_bLastInGroup = (lstTmp.GetTail() == pBar);
			pNewAHBar->m_bActiveInGroup = (pBar == pActiveBar);

			if (!bActiveSet && pNewAHBar->m_bActiveInGroup)
			{
				bActiveSet = TRUE;
			}
		}
	}

	if (pNewAHBar != NULL)
	{
		if (!bActiveSet)
		{
			pNewAHBar->m_bActiveInGroup = TRUE;
		}
		CRect rect(0, 0, 0, 0);
		pNewAHBar->GetParentDockSite()->RepositionPanes(rect);
	}

	if (nNonDetachedCount > 0)
	{
		if (m_pTabWnd->GetVisibleTabsNum() == 0)
		{
			ShowPane(FALSE, TRUE, FALSE);
		}
		else
		{
			if (m_pTabWnd->GetActiveTab() == -1)
			{
				int nVisibleTab = -1;
				GetFirstVisibleTab(nVisibleTab);
				m_pTabWnd->SetActiveTab(nVisibleTab);
			}
			m_pTabWnd->RecalcLayout();
			ShowPane(TRUE, TRUE, FALSE);
			pAutoHideBar = CDockablePane::SetAutoHideMode(bMode, dwAlignment, pCurrAutoHideBar, bUseTimer);
		}
	}

	if (pAutoHideBar != NULL)
	{
		pAutoHideBar->UpdateVisibleState();
	}

	CPane::m_bHandleMinSize = bHandleMinSize;

	return pAutoHideBar;
}

CWnd* CBaseTabbedPane::GetFirstVisibleTab(int& iTabNum)
{
	iTabNum = -1;
	if (m_pTabWnd == NULL)
	{
		return NULL;
	}

	return m_pTabWnd->GetFirstVisibleTab(iTabNum);
}

HICON CBaseTabbedPane::GetPaneIcon(BOOL bBigIcon)
{
	HICON hIcon = GetIcon(bBigIcon);

	if (hIcon == NULL && m_pTabWnd != NULL)
	{
		CWnd* pWnd = m_pTabWnd->GetActiveWnd();
		if (pWnd != NULL)
		{
			hIcon = pWnd->GetIcon(bBigIcon);
		}
	}

	return hIcon;
}

LRESULT CBaseTabbedPane::OnChangeActiveTab(WPARAM wp, LPARAM)
{
	int iTabNum = (int) wp;

	CString strLabel;
	if (m_pTabWnd != NULL && m_pTabWnd->GetTabLabel(iTabNum, strLabel) && m_bSetCaptionTextToTabName)
	{
		SetWindowText(strLabel);
	}

	OnActivateTab(iTabNum);
	if (CPane::m_bHandleMinSize)
	{
		CPaneFrameWnd* pWnd = GetParentMiniFrame();
		if (pWnd != NULL)
		{
			pWnd->OnPaneRecalcLayout();
		}
		else
		{
			afxGlobalUtils.ForceAdjustLayout(afxGlobalUtils.GetDockingManager(GetDockSiteFrameWnd()));
		}
	}
	return 0;
}

BOOL CBaseTabbedPane::Dock(CBasePane* pTargetBar, LPCRECT lpRect, AFX_DOCK_METHOD dockMethod)
{
	BOOL bFloating = (GetParentMiniFrame() != NULL);
	int nTabsNum = m_pTabWnd->GetTabsNum();
	BOOL bTabsHaveRecentInfo = TRUE;

	if (bFloating)
	{
		for (int i = 0; i < nTabsNum; i++)
		{
			if (m_pTabWnd->IsTabDetachable(i))
			{
				CDockablePane* pBar = DYNAMIC_DOWNCAST(CDockablePane,
					m_pTabWnd->GetTabWnd(i));
				if (pBar != NULL)
				{
					ASSERT_VALID(pBar);
					if (pBar->m_recentDockInfo.GetRecentPaneContainer(TRUE) == NULL && pBar->m_recentDockInfo.GetRecentTabContainer(TRUE) == NULL)
					{
						bTabsHaveRecentInfo = FALSE;
						break;
					}
				}
			}
		}
	}

	if (dockMethod != DM_DBL_CLICK || !bTabsHaveRecentInfo)
	{
		return CDockablePane::Dock(pTargetBar, lpRect, dockMethod);
	}

	if (bFloating && m_recentDockInfo.GetRecentPaneContainer(TRUE) != NULL || !bFloating && m_recentDockInfo.GetRecentPaneContainer(FALSE) != NULL)
	{
		return CDockablePane::Dock(pTargetBar, lpRect, dockMethod);
	}

	ShowPane(FALSE, TRUE, FALSE);

	int nNonDetachedCount = 0;
	for (int nNextTab = nTabsNum - 1; nNextTab >= 0; nNextTab--)
	{
		CDockablePane* pBar = DYNAMIC_DOWNCAST(CDockablePane, m_pTabWnd->GetTabWnd(nNextTab));
		ASSERT_VALID(pBar);

		BOOL bIsVisible = m_pTabWnd->IsTabVisible(nNextTab);
		BOOL bDetachable = m_pTabWnd->IsTabDetachable(nNextTab);

		if (pBar != NULL && bIsVisible && bDetachable)
		{
			m_pTabWnd->RemoveTab(nNextTab, FALSE);
			pBar->EnableGripper(TRUE);

			pBar->StoreRecentTabRelatedInfo();

			pBar->DockPane(pBar, lpRect, dockMethod);
		}
		else
		{
			nNonDetachedCount++;
		}
	}

	if (nNonDetachedCount > 0)
	{
		if (m_pTabWnd->GetVisibleTabsNum() == 0)
		{
			ShowPane(FALSE, TRUE, FALSE);
		}
		else
		{
			if (m_pTabWnd->GetActiveTab() == -1)
			{
				int nVisibleTab = -1;
				GetFirstVisibleTab(nVisibleTab);
				m_pTabWnd->SetActiveTab(nVisibleTab);
			}
			m_pTabWnd->RecalcLayout();
			ShowPane(TRUE, TRUE, FALSE);
			return CDockablePane::Dock(pTargetBar, lpRect, dockMethod);

		}
	}
	else
	{
		DestroyWindow();
		return FALSE;
	}

	return TRUE;
}

void CBaseTabbedPane::FillDefaultTabsOrderArray()
{
	ASSERT_VALID(m_pTabWnd);
	m_arDefaultTabsOrder.RemoveAll();

	const int nTabsNum = m_pTabWnd->GetTabsNum();

	for (int i = 0; i < nTabsNum; i++)
	{
		int nID = m_pTabWnd->GetTabID(i);
		m_arDefaultTabsOrder.Add(nID);
	}
}

void CBaseTabbedPane::GetMinSize(CSize& size) const
{
	if (CPane::m_bHandleMinSize)
	{
		CDockablePane* pBar = DYNAMIC_DOWNCAST(CDockablePane, m_pTabWnd->GetActiveWnd());
		if (pBar != NULL)
		{
			pBar->GetMinSize(size);
			return;

		}
	}
	CDockablePane::GetMinSize(size);
}

void CBaseTabbedPane::GetPaneList(CObList& lst, CRuntimeClass* pRTCFilter)
{
	CMFCBaseTabCtrl* pTabWnd = GetUnderlyingWindow();
	for (int i = 0; i < pTabWnd->GetTabsNum(); i++)
	{
		CDockablePane* pBar = DYNAMIC_DOWNCAST(CDockablePane, pTabWnd->GetTabWnd(i));
		if (pBar != NULL)
		{
			ASSERT_VALID(pBar);
			if (pRTCFilter == NULL || pBar->GetRuntimeClass() == pRTCFilter)
			{
				lst.AddTail(pBar);
			}
		}
	}
}

void CBaseTabbedPane::ConvertToTabbedDocument(BOOL bActiveTabOnly)
{
	ASSERT_VALID(this);
	ASSERT_VALID(m_pTabWnd);

	CMDIFrameWndEx* pMDIFrame = DYNAMIC_DOWNCAST(CMDIFrameWndEx, GetDockSiteFrameWnd());
	if (pMDIFrame == NULL)
	{
		ASSERT(FALSE);
		return;
	}

	ASSERT_VALID(pMDIFrame);

	HWND hwnd = GetSafeHwnd();

	if (bActiveTabOnly)
	{
		CDockablePane* pBar = DYNAMIC_DOWNCAST(CDockablePane, m_pTabWnd->GetActiveWnd());
		if (pBar == NULL)
		{
			return;
		}

		pBar->StoreRecentTabRelatedInfo();
		pMDIFrame->ControlBarToTabbedDocument(pBar);
		RemovePane(pBar);
	}
	else
	{
		CObList lst;
		CMFCBaseTabCtrl* pTabWnd = GetUnderlyingWindow();

		for (int i = 0; i < pTabWnd->GetTabsNum(); i++)
		{
			if (pTabWnd->IsTabVisible(i))
			{
				CDockablePane* pBar = DYNAMIC_DOWNCAST(CDockablePane, pTabWnd->GetTabWnd(i));
				if (pBar != NULL)
				{
					pBar->StoreRecentTabRelatedInfo();
					lst.AddTail(pBar);
				}
			}
		}

		for (POSITION pos = lst.GetHeadPosition(); pos != NULL;)
		{
			CDockablePane* pBar = (CDockablePane*) lst.GetNext(pos);
			pMDIFrame->ControlBarToTabbedDocument(pBar);
			RemovePane(pBar);
		}
	}

	if (IsWindow(hwnd) && GetVisibleTabsNum() == 0 && GetTabsNum() > 0)
	{
		ShowPane(FALSE, FALSE, FALSE);
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\src\mfc\afxbutton.cpp ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#include "stdafx.h"
#include "afxcontrolbarutil.h"
#include "afxribbonres.h"
#include "afxbutton.h"
#include "afxglobals.h"
#include "afxtoolbarimages.h"
#include "afxpopupmenu.h"
#include "afxvisualmanager.h"
#include "afxdrawmanager.h"
#include "afxtooltipmanager.h"
#include "afxtagmanager.h"
#include "afxctrlcontainer.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#endif

static const int nImageHorzMargin = 10;
static const int nVertMargin = 5;
static const COLORREF clrDefault = (COLORREF) -1;
static const UINT IdAutoCommand = 1;

BOOL CMFCButton::m_bWinXPTheme = FALSE;
BOOL CMFCButton::m_bWinXPThemeWasChecked = FALSE;

/////////////////////////////////////////////////////////////////////////////
// CMFCButton

IMPLEMENT_DYNCREATE(CMFCButton, CButton)

CMFCButton::CMFCButton()
{
	m_bPushed = FALSE;
	m_bClickiedInside = FALSE;
	m_bHighlighted = FALSE;
	m_bCaptured = FALSE;
	m_nFlatStyle = BUTTONSTYLE_3D;
	m_nAlignStyle = ALIGN_CENTER;
	m_sizeImage = CSize(0, 0);
	m_nStdImageId = (CMenuImages::IMAGES_IDS) -1;
	m_nStdImageDisabledId = (CMenuImages::IMAGES_IDS) -1;
	m_StdImageState = CMenuImages::ImageBlack;
	m_bFullTextTooltip = FALSE;
	m_bRightImage = FALSE;
	m_bTopImage = FALSE;
	m_hCursor = NULL;
	m_sizePushOffset = CSize(2, 2);
	m_bHover = FALSE;
	m_clrRegular = clrDefault;
	m_clrHover = clrDefault;
	m_clrFace = (COLORREF)-1;
	m_bDrawFocus = TRUE;
	m_bTransparent = FALSE;
	m_hFont = NULL;
	m_bDelayFullTextTooltipSet = FALSE;
	m_bGrayDisabled = TRUE;
	m_bChecked = FALSE;
	m_bCheckButton = FALSE;
	m_bRadioButton = FALSE;
	m_bAutoCheck = FALSE;
	m_bHighlightChecked = TRUE;
	m_nAutoRepeatTimeDelay = 0;
	m_bResponseOnButtonDown = FALSE;
	m_bDontUseWinXPTheme = FALSE;
	m_bWasDblClk = FALSE;
	m_pToolTip = NULL;

	EnableActiveAccessibility();
}

CMFCButton::~CMFCButton()
{
	CleanUp();
}

void CMFCButton::CleanUp()
{
	m_nStdImageId = (CMenuImages::IMAGES_IDS) -1;
	m_nStdImageDisabledId = (CMenuImages::IMAGES_IDS) -1;

	m_sizeImage = CSize(0, 0);

	m_Image.Clear();
	m_ImageHot.Clear();
	m_ImageDisabled.Clear();

	m_ImageChecked.Clear();
	m_ImageCheckedHot.Clear();
	m_ImageCheckedDisabled.Clear();
}

//{{AFX_MSG_MAP(CMFCButton)
BEGIN_MESSAGE_MAP(CMFCButton, CButton)
	ON_WM_ERASEBKGND()
	ON_WM_CANCELMODE()
	ON_WM_MOUSEMOVE()
	ON_WM_LBUTTONDOWN()
	ON_WM_LBUTTONUP()
	ON_WM_SETCURSOR()
	ON_WM_ENABLE()
	ON_WM_SIZE()
	ON_WM_KILLFOCUS()
	ON_WM_LBUTTONDBLCLK()
	ON_WM_TIMER()
	ON_WM_DESTROY()
	ON_MESSAGE(WM_SETFONT, &CMFCButton::OnSetFont)
	ON_MESSAGE(WM_GETFONT, &CMFCButton::OnGetFont)
	ON_MESSAGE(BM_GETCHECK, &CMFCButton::OnGetCheck)
	ON_MESSAGE(BM_SETCHECK, &CMFCButton::OnSetCheck)
	ON_MESSAGE(BM_SETIMAGE, &CMFCButton::OnSetImage)
	ON_MESSAGE(BM_GETIMAGE, &CMFCButton::OnGetImage)
	ON_MESSAGE(WM_MFC_INITCTRL, &CMFCButton::OnInitControl)
	ON_REGISTERED_MESSAGE(AFX_WM_UPDATETOOLTIPS, &CMFCButton::OnUpdateToolTips)
END_MESSAGE_MAP()
//}}AFX_MSG_MAP

/////////////////////////////////////////////////////////////////////////////
// CMFCButton message handlers

void CMFCButton::DrawItem(LPDRAWITEMSTRUCT lpDIS)
{
	ENSURE(lpDIS != NULL);
	ENSURE(lpDIS->CtlType == ODT_BUTTON);

	CDC* pDCPaint = CDC::FromHandle(lpDIS->hDC);
	ASSERT_VALID(pDCPaint);

	CMemDC memDC(*pDCPaint, this);
	CDC* pDC = &memDC.GetDC();

	CRect rectClient = lpDIS->rcItem;

	OnFillBackground(pDC, rectClient);
	OnDrawBorder(pDC, rectClient, lpDIS->itemState);

	// Draw button content:
	OnDraw(pDC, rectClient, lpDIS->itemState);

	if ((lpDIS->itemState & ODS_FOCUS) && m_bDrawFocus)
	{
		OnDrawFocusRect(pDC, rectClient);
	}
}

void CMFCButton::PreSubclassWindow()
{
	InitStyle(GetStyle());

	ModifyStyle(BS_DEFPUSHBUTTON, BS_OWNERDRAW);
	CButton::PreSubclassWindow();
}

BOOL CMFCButton::PreCreateWindow(CREATESTRUCT& cs)
{
	InitStyle(cs.style);

	cs.style |= BS_OWNERDRAW;
	cs.style &= ~BS_DEFPUSHBUTTON;

	return CButton::PreCreateWindow(cs);
}

void CMFCButton::InitStyle(DWORD dwStyle)
{
	switch (dwStyle & 0x0F)
	{
	case BS_CHECKBOX:
		m_bCheckButton = TRUE;
		break ;
	case BS_AUTOCHECKBOX:
		m_bCheckButton = m_bAutoCheck = TRUE;
		break ;
	case BS_RADIOBUTTON:
		m_bRadioButton = TRUE;
		break ;
	case BS_AUTORADIOBUTTON:
		m_bRadioButton = m_bAutoCheck = TRUE;
		break ;
	}

	if (m_bCheckButton || m_bRadioButton)
	{
		switch (dwStyle & BS_CENTER)
		{
		case BS_LEFT:
			m_nAlignStyle = CMFCButton::ALIGN_LEFT;
			break;
		case BS_RIGHT:
			m_nAlignStyle = CMFCButton::ALIGN_RIGHT;
			break;
		case BS_CENTER:
			m_nAlignStyle = CMFCButton::ALIGN_CENTER;
			break;
		}
	}

	if (!m_bWinXPThemeWasChecked)
	{
		if (!m_bWinXPTheme)
		{
			EnableWindowsTheming(AfxFindResourceHandle(MAKEINTRESOURCE(1), _T("24")) != NULL);
		}

		m_bWinXPThemeWasChecked = TRUE;
	}
}

BOOL CMFCButton::OnEraseBkgnd(CDC* /*pDC*/)
{
	return TRUE;
}

void CMFCButton::OnFillBackground(CDC* pDC, const CRect& rectClient)
{
	if (m_bTransparent)
	{
		// Copy background from the parent window
		afxGlobalData.DrawParentBackground(this, pDC);
	}
	else
	{
		if (m_clrFace == (COLORREF)-1)
		{
			pDC->FillRect(rectClient, &afxGlobalData.brBtnFace);
		}
		else
		{
			pDC->FillSolidRect(rectClient, m_clrFace);
		}
	}

	if (m_bChecked && m_bHighlightChecked && !(m_bPushed && m_bHighlighted))
	{
		CDrawingManager dm(*pDC);
		dm.HighlightRect(rectClient);
	}
}

void CMFCButton::OnDraw(CDC* pDC, const CRect& rect, UINT uiState)
{
	CRect rectText = rect;
	CRect rectImage = rect;

	CString strText;
	GetWindowText(strText);

	if (m_sizeImage.cx != 0)
	{
		if (!strText.IsEmpty())
		{
			if (m_bTopImage)
			{
				rectImage.bottom = rectImage.top + m_sizeImage.cy + GetVertMargin();
				rectText.top = rectImage.bottom;
				rectText.bottom -= GetVertMargin();
			}
			else if (m_bRightImage)
			{
				rectText.right -= m_sizeImage.cx + GetImageHorzMargin() / 2;
				rectImage.left = rectText.right;
				rectImage.right -= GetImageHorzMargin() / 2;
			}
			else
			{
				rectText.left +=  m_sizeImage.cx + GetImageHorzMargin() / 2;
				rectImage.left += GetImageHorzMargin() / 2;
				rectImage.right = rectText.left;
			}
		}

		// Center image:
		rectImage.DeflateRect((rectImage.Width() - m_sizeImage.cx) / 2, max(0, (rectImage.Height() - m_sizeImage.cy) / 2));
	}
	else
	{
		rectImage.SetRectEmpty();
	}

	// Draw text:
	CFont* pOldFont = SelectFont(pDC);
	ENSURE(pOldFont != NULL);

	pDC->SetBkMode(TRANSPARENT);
	COLORREF clrText = m_clrRegular == clrDefault ? afxGlobalData.clrBtnText : m_clrRegular;

	if (m_bHighlighted && m_clrHover != clrDefault)
	{
		clrText = m_clrHover;
	}

	UINT uiDTFlags = DT_END_ELLIPSIS;
	BOOL bIsSingleLine = FALSE;

	if (strText.Find(_T('\n')) < 0)
	{
		uiDTFlags |= DT_VCENTER | DT_SINGLELINE;
		bIsSingleLine = TRUE;
	}
	else
	{
		rectText.DeflateRect(0, GetVertMargin() / 2);
	}

	switch (m_nAlignStyle)
	{
	case ALIGN_LEFT:
		uiDTFlags |= DT_LEFT;
		rectText.left += GetImageHorzMargin() / 2;
		break;

	case ALIGN_RIGHT:
		uiDTFlags |= DT_RIGHT;
		rectText.right -= GetImageHorzMargin() / 2;
		break;

	case ALIGN_CENTER:
		uiDTFlags |= DT_CENTER;
	}

	if (GetExStyle() & WS_EX_LAYOUTRTL)
	{
		uiDTFlags |= DT_RTLREADING;
	}

	if ((uiState & ODS_DISABLED) && m_bGrayDisabled)
	{
		pDC->SetTextColor(afxGlobalData.clrBtnHilite);

		CRect rectShft = rectText;
		rectShft.OffsetRect(1, 1);
		OnDrawText(pDC, rectShft, strText, uiDTFlags, uiState);

		clrText = afxGlobalData.clrGrayedText;
	}

	pDC->SetTextColor(clrText);

	if (m_bDelayFullTextTooltipSet)
	{
		BOOL bIsFullText = pDC->GetTextExtent(strText).cx <= rectText.Width();
		SetTooltip(bIsFullText || !bIsSingleLine ? NULL :(LPCTSTR) strText);
		m_bDelayFullTextTooltipSet = FALSE;
	}

	OnDrawText(pDC, rectText, strText, uiDTFlags, uiState);

	// Draw image:
	if (!rectImage.IsRectEmpty())
	{
		if (m_nStdImageId != (CMenuImages::IMAGES_IDS) -1)
		{
			CMenuImages::IMAGES_IDS id = m_nStdImageId;

			if ((uiState & ODS_DISABLED) && m_bGrayDisabled && m_nStdImageDisabledId != 0)
			{
				id = m_nStdImageDisabledId;
			}

			CMenuImages::Draw(pDC, id, rectImage.TopLeft(), m_StdImageState);
		}
		else
		{
			BOOL bIsDisabled = (uiState & ODS_DISABLED) && m_bGrayDisabled;

			CMFCToolBarImages& imageChecked = (bIsDisabled && m_ImageCheckedDisabled.GetCount() != 0) ? m_ImageCheckedDisabled :
				(m_bHighlighted && m_ImageCheckedHot.GetCount() != 0) ? m_ImageCheckedHot : m_ImageChecked;

			CMFCToolBarImages& image = (bIsDisabled && m_ImageDisabled.GetCount() != 0) ? m_ImageDisabled :
				(m_bHighlighted && m_ImageHot.GetCount() != 0) ? m_ImageHot : m_Image;

			if (m_bChecked && imageChecked.GetCount() != 0)
			{
				CAfxDrawState ds;

				imageChecked.PrepareDrawImage(ds);
				imageChecked.Draw(pDC, rectImage.left, rectImage.top, 0, FALSE, bIsDisabled && m_ImageCheckedDisabled.GetCount() == 0);
				imageChecked.EndDrawImage(ds);
			}
			else if (image.GetCount() != 0)
			{
				CAfxDrawState ds;

				image.PrepareDrawImage(ds);
				image.Draw(pDC, rectImage.left, rectImage.top, 0, FALSE, bIsDisabled && m_ImageDisabled.GetCount() == 0);
				image.EndDrawImage(ds);
			}
		}
	}

	pDC->SelectObject(pOldFont);
}

void CMFCButton::OnDrawText(CDC* pDC, const CRect& rect, const CString& strText, UINT uiDTFlags, UINT /*uiState*/)
{
	ASSERT_VALID(pDC);

	CRect rectText = rect;
	pDC->DrawText(strText, rectText, uiDTFlags);
}

void CMFCButton::SetImage(HICON hIconCold, BOOL bAutoDestroy, HICON hIconHot, HICON hIconDisabled, BOOL bAlphaBlend)
{
	SetImageInternal(hIconCold, bAutoDestroy, hIconHot, FALSE /* Not checked */, hIconDisabled, bAlphaBlend);
}

void CMFCButton::SetImage(HBITMAP hBitmapCold, BOOL bAutoDestroy, HBITMAP hBitmapHot, BOOL bMap3dColors, HBITMAP hBitmapDisabled)
{
	SetImageInternal(hBitmapCold, bAutoDestroy, hBitmapHot, bMap3dColors, FALSE /* Not checked */, hBitmapDisabled);
}

void CMFCButton::SetImage(UINT uiBmpResId, UINT uiBmpHotResId, UINT uiBmpDsblResID)
{
	SetImageInternal(uiBmpResId, uiBmpHotResId, FALSE /* Not checked */, uiBmpDsblResID);
}

void CMFCButton::SetCheckedImage(HICON hIconCold, BOOL bAutoDestroy, HICON hIconHot, HICON hIconDisabled, BOOL bAlphaBlend)
{
	SetImageInternal(hIconCold, bAutoDestroy, hIconHot, TRUE /* Checked */, hIconDisabled, bAlphaBlend);
}

void CMFCButton::SetCheckedImage(HBITMAP hBitmapCold, BOOL bAutoDestroy, HBITMAP hBitmapHot, BOOL bMap3dColors, HBITMAP hBitmapDisabled)
{
	SetImageInternal(hBitmapCold, bAutoDestroy, hBitmapHot, bMap3dColors, TRUE /* Checked */, hBitmapDisabled);
}

void CMFCButton::SetCheckedImage(UINT uiBmpResId, UINT uiBmpHotResId, UINT uiBmpDsblResID)
{
	SetImageInternal(uiBmpResId, uiBmpHotResId, TRUE /* Checked */, uiBmpDsblResID);
}

void CMFCButton::SetImageInternal(HICON hIconCold, BOOL bAutoDestroy, HICON hIconHot, BOOL bChecked, HICON hIconDisabled, BOOL bAlphaBlend)
{
	ClearImages(bChecked);

	if (hIconCold == NULL)
	{
		return;
	}

	const int nCount = hIconDisabled == NULL ? 2 : 3;

	for (int i = 0; i < nCount; i++)
	{
		HICON hIcon = (i == 0) ? hIconCold :(i == 1) ? hIconHot : hIconDisabled;
		CMFCToolBarImages& image = bChecked ?((i == 0) ? m_ImageChecked :(i == 1) ? m_ImageCheckedHot : m_ImageCheckedDisabled) :
			((i == 0) ? m_Image :(i == 1) ? m_ImageHot : m_ImageDisabled);

		if (hIcon == NULL)
		{
			continue;
		}

		ICONINFO info;
		::GetIconInfo(hIcon, &info);

		BITMAP bmp;
		::GetObject(info.hbmColor, sizeof(BITMAP), (LPVOID) &bmp);

		m_sizeImage.cx = bmp.bmWidth;
		m_sizeImage.cy = bmp.bmHeight;

		if (i == 0)
		{
			// Create disabled image from the "cold" icon:
			CDC dcMem;
			dcMem.CreateCompatibleDC(NULL);

			HBITMAP hBmp = (HBITMAP) ::CopyImage(info.hbmColor, IMAGE_BITMAP, 0, 0, LR_CREATEDIBSECTION);
			if (hBmp == NULL)
			{
				ASSERT(FALSE);
			}
			else
			{
				HBITMAP hOldBmp = (HBITMAP) dcMem.SelectObject(hBmp);

				dcMem.FillRect(CRect(0, 0, m_sizeImage.cx, m_sizeImage.cy), &afxGlobalData.brBtnFace);

				::DrawIconEx(dcMem.GetSafeHdc(), 0, 0, hIcon, m_sizeImage.cx, m_sizeImage.cy, 0, NULL, DI_NORMAL);

				dcMem.SelectObject(hOldBmp);
				::DeleteObject(hBmp);
			}
		}

		::DeleteObject(info.hbmColor);
		::DeleteObject(info.hbmMask);

		image.SetImageSize(CSize(bmp.bmWidth, bmp.bmHeight));

		if (!bAlphaBlend)
		{
			image.SetTransparentColor(afxGlobalData.clrBtnFace);
		}

		image.AddIcon(hIcon, bAlphaBlend);
	}

	if (bAutoDestroy)
	{
		if (hIconCold != NULL)
		{
			::DestroyIcon(hIconCold);
		}

		if (hIconHot != NULL)
		{
			::DestroyIcon(hIconHot);
		}

		if (hIconDisabled != NULL)
		{
			::DestroyIcon(hIconDisabled);
		}
	}
}

void CMFCButton::SetImageInternal(HBITMAP hBitmapCold, BOOL bAutoDestroy, HBITMAP hBitmapHot, BOOL bMap3dColors, BOOL bChecked, HBITMAP hBitmapDisabled)
{
	ClearImages(bChecked);

	if (hBitmapCold == NULL)
	{
		return;
	}

	const int nCount = hBitmapDisabled == NULL ? 2 : 3;

	for (int i = 0; i < nCount; i++)
	{
		HBITMAP hBitmap = (i == 0) ? hBitmapCold :(i == 1) ? hBitmapHot : hBitmapDisabled;
		CMFCToolBarImages& image = bChecked ?((i == 0) ? m_ImageChecked :(i == 1) ? m_ImageCheckedHot : m_ImageCheckedDisabled) :
			((i == 0) ? m_Image :(i == 1) ? m_ImageHot : m_ImageDisabled);

		if (hBitmap == NULL)
		{
			break;
		}

		BITMAP bmp;
		::GetObject(hBitmap, sizeof(BITMAP), (LPVOID) &bmp);

		BOOL bMap3dColorsCurr = bMap3dColors ||(bmp.bmBitsPixel > 8 && bmp.bmBitsPixel < 32);
		BOOL bAlpha = !bMap3dColors && bmp.bmBitsPixel == 32 && CMFCToolBarImages::Is32BitTransparencySupported();

		if (i == 0)
		{
			m_sizeImage.cx = bmp.bmWidth;
			m_sizeImage.cy = bmp.bmHeight;
		}
		else
		{
			// Hot and cold bitmaps should have the same size!
			ASSERT(m_sizeImage.cx == bmp.bmWidth);
			ASSERT(m_sizeImage.cy == bmp.bmHeight);
		}

		if (bAlpha)
		{
			CMFCToolBarImages::PreMultiplyAlpha(hBitmap, TRUE);
		}

		image.SetImageSize(CSize(bmp.bmWidth, bmp.bmHeight));
		image.SetTransparentColor(bMap3dColorsCurr ? RGB(192, 192, 192) : bAlpha ?(COLORREF) -1 : afxGlobalData.clrBtnFace);
		image.AddImage(hBitmap, TRUE);
	}

	if (bAutoDestroy)
	{
		if (hBitmapHot != NULL)
		{
			::DeleteObject(hBitmapHot);
		}

		if (hBitmapCold != NULL)
		{
			::DeleteObject(hBitmapCold);
		}

		if (hBitmapDisabled != NULL)
		{
			::DeleteObject(hBitmapDisabled);
		}
	}
}

static HBITMAP __stdcall ButtonLoadBitmap(UINT uiBmpResId)
{
	if (uiBmpResId == 0)
	{
		return NULL;
	}

	LPCTSTR lpszResourceName = MAKEINTRESOURCE(uiBmpResId);
	ENSURE(lpszResourceName != NULL);

	HBITMAP hbmp = NULL;

	// Try to load PNG image first:
	CPngImage pngImage;
	if (pngImage.Load(lpszResourceName))
	{
		hbmp = (HBITMAP) pngImage.Detach();
	}
	else
	{
		HINSTANCE hinstRes = AfxFindResourceHandle(lpszResourceName, RT_BITMAP);
		if (hinstRes == NULL)
		{
			return NULL;
		}

		UINT uiLoadImageFlags = LR_CREATEDIBSECTION | LR_LOADMAP3DCOLORS;

		hbmp = (HBITMAP) ::LoadImage(hinstRes, lpszResourceName, IMAGE_BITMAP, 0, 0, uiLoadImageFlags);
	}

	return hbmp;
}

void CMFCButton::SetImageInternal(UINT uiBmpResId, UINT uiBmpHotResId, BOOL bChecked, UINT uiBmpDsblResID)
{
	ClearImages(bChecked);

	if (uiBmpResId == 0)
	{
		return;
	}

	HBITMAP hbmp = ButtonLoadBitmap(uiBmpResId);
	HBITMAP hbmpHot = ButtonLoadBitmap(uiBmpHotResId);
	HBITMAP hbmpDisabled = ButtonLoadBitmap(uiBmpDsblResID);

	SetImageInternal(hbmp, TRUE /* AutoDestroy */, hbmpHot, FALSE, bChecked, hbmpDisabled);
}

void CMFCButton::SetStdImage(CMenuImages::IMAGES_IDS id, CMenuImages::IMAGE_STATE state, CMenuImages::IMAGES_IDS idDisabled)
{
	CleanUp();

	m_sizeImage = CMenuImages::Size();
	m_nStdImageId = id;
	m_nStdImageDisabledId = idDisabled;
	m_StdImageState = state;
}

void CMFCButton::OnCancelMode()
{
	CButton::OnCancelMode();

	if (m_bCaptured)
	{
		ReleaseCapture();

		m_bCaptured = FALSE;
		m_bPushed = FALSE;
		m_bClickiedInside = FALSE;
		m_bHighlighted = FALSE;
		m_bHover = FALSE;

		Invalidate();
		UpdateWindow();
	}

	if (m_nAutoRepeatTimeDelay >= 0)
	{
		KillTimer(IdAutoCommand);
	}
}

void CMFCButton::OnMouseMove(UINT nFlags, CPoint point)
{
	m_bHover = FALSE;

	if ((nFlags & MK_LBUTTON) || m_nFlatStyle != BUTTONSTYLE_3D ||
		(m_bWinXPTheme && !m_bDontUseWinXPTheme))
	{
		BOOL bRedraw = FALSE;

		CRect rectClient;
		GetClientRect(rectClient);

		if (rectClient.PtInRect(point))
		{
			m_bHover = TRUE;

			if (!m_bHighlighted)
			{
				m_bHighlighted = TRUE;
				bRedraw = TRUE;
			}

			if ((nFlags & MK_LBUTTON) && !m_bPushed && m_bClickiedInside)
			{
				m_bPushed = TRUE;
				bRedraw = TRUE;
			}

			if (!m_bCaptured)
			{
				SetCapture();
				m_bCaptured = TRUE;
				bRedraw = TRUE;
			}
		}
		else
		{
			if (nFlags & MK_LBUTTON)
			{
				if (m_bPushed)
				{
					m_bPushed = FALSE;
					bRedraw = TRUE;
				}
			}
			else if (m_bHighlighted)
			{
				m_bHighlighted = FALSE;
				bRedraw = TRUE;
			}

			if (m_bCaptured && !(nFlags & MK_LBUTTON))
			{
				ReleaseCapture();
				m_bCaptured = FALSE;

				bRedraw = TRUE;
			}
		}

		if (bRedraw)
		{
			Invalidate();
			UpdateWindow();
		}
	}

	CButton::OnMouseMove(nFlags, point);
}

void CMFCButton::OnLButtonDown(UINT nFlags, CPoint point)
{
	if (m_bResponseOnButtonDown)
	{
		CWnd* pParent = GetParent();
		if (pParent != NULL)
		{
			pParent->SendMessage( WM_COMMAND, MAKEWPARAM(GetDlgCtrlID(), BN_CLICKED), (LPARAM) m_hWnd);
		}
	}
	else
	{
		m_bPushed = TRUE;
		m_bClickiedInside = TRUE;
		m_bHighlighted = TRUE;

		if (!m_bCaptured)
		{
			SetCapture();
			m_bCaptured = TRUE;
		}

		Invalidate();
		UpdateWindow();

		if (m_nAutoRepeatTimeDelay > 0)
		{
			SetTimer(IdAutoCommand, m_nAutoRepeatTimeDelay, NULL);
		}
	}

	CButton::OnLButtonDown(nFlags, point);
}

void CMFCButton::OnLButtonUp(UINT nFlags, CPoint point)
{
	BOOL bClicked = m_bPushed && m_bClickiedInside && m_bHighlighted;

	m_bPushed = FALSE;
	m_bClickiedInside = FALSE;
	m_bHighlighted = FALSE;

	if (bClicked && m_bAutoCheck)
	{
		if (m_bCheckButton)
		{
			m_bChecked = !m_bChecked;
		}
		else if (m_bRadioButton && !m_bChecked)
		{
			m_bChecked = TRUE;
			UncheckRadioButtonsInGroup();
		}
	}

	HWND hWnd = GetSafeHwnd();

	if (m_bWasDblClk)
	{
		m_bWasDblClk = FALSE;
		CWnd* pParent = GetParent();
		if (pParent != NULL)
		{
			pParent->SendMessage(WM_COMMAND, MAKEWPARAM(GetDlgCtrlID(), BN_CLICKED), (LPARAM) m_hWnd);
		}
	}

	if (!::IsWindow(hWnd))
	{
		// The button was destroyed after send message
		return;
	}

	RedrawWindow();

	CButton::OnLButtonUp(nFlags, point);

	if (!::IsWindow(hWnd))
	{
		// The button was destroyed after the OnLButtonUp handler
		return;
	}

	if (m_bCaptured)
	{
		ReleaseCapture();
		m_bCaptured = FALSE;
	}

	if (m_nAutoRepeatTimeDelay > 0)
	{
		KillTimer(IdAutoCommand);
	}

	if (m_pToolTip->GetSafeHwnd() != NULL)
	{
		m_pToolTip->Pop();
	}
}

CSize CMFCButton::SizeToContent(BOOL bCalcOnly)
{
	ENSURE(GetSafeHwnd() != NULL);

	CClientDC dc(this);

	CFont* pOldFont = SelectFont(&dc);
	ENSURE(pOldFont != NULL);

	CString strText;
	GetWindowText(strText);

	CSize sizeText(0, 0);

	if (strText.Find(_T('\n')) < 0)
	{
		sizeText = dc.GetTextExtent(strText);
	}
	else
	{
		CRect rectText;
		GetClientRect(rectText);

		dc.DrawText(strText, rectText, DT_CALCRECT);
		sizeText = rectText.Size();
	}

	int cx = 0;
	int cy = 0;

	if (m_bTopImage)
	{
		cx = max(sizeText.cx, m_sizeImage.cx) + GetImageHorzMargin();
		if (sizeText.cx > 0)
		{
			cx += GetImageHorzMargin();
		}

		cy = sizeText.cy + m_sizeImage.cy + GetVertMargin();
		if (m_sizeImage.cy > 0)
		{
			cy += GetVertMargin();
		}
		if (sizeText.cy > 0)
		{
			cy += GetVertMargin();
		}
	}
	else
	{
		cx = sizeText.cx + m_sizeImage.cx + GetImageHorzMargin();
		if (sizeText.cx > 0)
		{
			cx += GetImageHorzMargin();
		}

		cy = max(sizeText.cy, m_sizeImage.cy) + GetVertMargin() * 2;
	}

	if (!bCalcOnly)
	{
		SetWindowPos(NULL, -1, -1, cx, cy, SWP_NOMOVE | SWP_NOACTIVATE | SWP_NOZORDER);
	}

	dc.SelectObject(pOldFont);

	return CSize(cx, cy);
}

BOOL CMFCButton::PreTranslateMessage(MSG* pMsg)
{
	if (m_pToolTip->GetSafeHwnd() != NULL)
	{
		if (pMsg->message == WM_LBUTTONDOWN || pMsg->message == WM_LBUTTONUP || pMsg->message == WM_MOUSEMOVE)
		{
			m_pToolTip->RelayEvent(pMsg);
		}
	}

	if (pMsg->message == WM_KEYDOWN && pMsg->wParam == VK_RETURN && CMFCPopupMenu::GetActiveMenu() == NULL)
	{
		CWnd* pParent = GetParent();
		if (pParent != NULL)
		{
			pParent->SendMessage( WM_COMMAND, MAKEWPARAM(GetDlgCtrlID(), BN_CLICKED), (LPARAM) m_hWnd);
			return TRUE;
		}
	}

	if (pMsg->message == WM_KEYDOWN && m_bAutoCheck && GetParent() != NULL)
	{
		switch (pMsg->wParam)
		{
		case VK_SPACE:
			if (m_bCheckButton)
			{
				m_bChecked = !m_bChecked;

				RedrawWindow();

				CWnd* pWndParent = GetParent();
				ASSERT_VALID(pWndParent);

				::SendMessage(pWndParent->GetSafeHwnd(), WM_COMMAND, MAKELONG(::GetWindowLong(m_hWnd, GWL_ID), BN_CLICKED), (LPARAM) m_hWnd);

				return TRUE ;
			}
			break;

		case VK_UP:
		case VK_LEFT:
			if (CheckNextPrevRadioButton(FALSE))
			{
				return TRUE;
			}
			break;

		case VK_DOWN:
		case VK_RIGHT:
			if (CheckNextPrevRadioButton(TRUE))
			{
				return TRUE;
			}
			break ;
		}
	}

	return CButton::PreTranslateMessage(pMsg);
}

void CMFCButton::SetTooltip(LPCTSTR lpszToolTipText)
{
	ENSURE(GetSafeHwnd() != NULL);

	if (lpszToolTipText == NULL)
	{
		if (m_pToolTip->GetSafeHwnd() != NULL)
		{
			m_pToolTip->Activate(FALSE);
		}
	}
	else
	{
		if (m_pToolTip->GetSafeHwnd() != NULL)
		{
			m_pToolTip->UpdateTipText(lpszToolTipText, this);
		}
		else
		{
			if (CTooltipManager::CreateToolTip(m_pToolTip, this, AFX_TOOLTIP_TYPE_BUTTON))
			{
				m_pToolTip->AddTool(this, lpszToolTipText);
			}
		}

		if (m_pToolTip->GetSafeHwnd() != NULL)
		{
			m_pToolTip->Activate(TRUE);
		}
	}
}

void CMFCButton::SetMouseCursor(HCURSOR hcursor)
{
	m_hCursor = hcursor;
}

void CMFCButton::SetMouseCursorHand()
{
	SetMouseCursor(afxGlobalData.GetHandCursor());
}

BOOL CMFCButton::OnSetCursor(CWnd* pWnd, UINT nHitTest, UINT message)
{
	if (m_hCursor != NULL)
	{
		CRect rectClient;
		GetClientRect(rectClient);

		CPoint ptCursor;
		::GetCursorPos(&ptCursor);
		ScreenToClient(&ptCursor);

		if (rectClient.PtInRect(ptCursor))
		{
			::SetCursor(m_hCursor);
			return TRUE;
		}
	}

	return CButton::OnSetCursor(pWnd, nHitTest, message);
}

void CMFCButton::OnDrawFocusRect(CDC* pDC, const CRect& rectClient)
{
	ASSERT_VALID(pDC);

	CRect rectFocus = rectClient;
	rectFocus.DeflateRect(1, 1);

	COLORREF clrBckgr = (m_clrFace == (COLORREF)-1) ? afxGlobalData.clrBtnFace : m_clrFace;

	if (!m_bWinXPTheme || m_bDontUseWinXPTheme)
	{
		rectFocus.DeflateRect(1, 1);
		pDC->Draw3dRect(rectFocus, clrBckgr, clrBckgr);
	}

	pDC->DrawFocusRect(rectFocus);
}

void CMFCButton::OnDrawParentBackground(CDC* pDC, CRect rectClient)
{
	ASSERT_VALID(pDC);
	afxGlobalData.DrawParentBackground(this, pDC, rectClient);
}

void CMFCButton::OnEnable(BOOL bEnable)
{
	if (!bEnable)
	{
		// control disabled
		m_bPushed = FALSE;
		m_bClickiedInside = FALSE;
		m_bHighlighted = FALSE;

		if (m_bCaptured)
		{
			ReleaseCapture();
			m_bCaptured = FALSE;
		}
	}

	RedrawWindow();
	CButton::OnEnable(bEnable);
}

void CMFCButton::SetFaceColor(COLORREF crFace, BOOL bRedraw)
{
	m_clrFace = crFace;

	if (bRedraw && GetSafeHwnd() != NULL)
	{
		Invalidate();
		UpdateWindow();
	}
}

CFont* CMFCButton::SelectFont(CDC* pDC)
{
	ASSERT_VALID(pDC);

	if (m_hFont != NULL && ::GetObjectType(m_hFont) != OBJ_FONT)
	{
		m_hFont = NULL;
	}

	CFont* pOldFont = m_hFont == NULL ? (CFont*) pDC->SelectStockObject(DEFAULT_GUI_FONT) : pDC->SelectObject(CFont::FromHandle(m_hFont));

	ENSURE(pOldFont != NULL);
	return pOldFont;
}

afx_msg LRESULT CMFCButton::OnSetFont(WPARAM wParam, LPARAM lParam)
{
	BOOL bRedraw = (BOOL) LOWORD(lParam);

	m_hFont = (HFONT) wParam;

	if (bRedraw)
	{
		Invalidate();
		UpdateWindow();
	}

	return 0;
}

afx_msg LRESULT CMFCButton::OnGetFont(WPARAM, LPARAM)
{
	return(LRESULT) m_hFont;
}

void CMFCButton::EnableMenuFont(BOOL bOn, BOOL bRedraw)
{
	m_hFont = bOn ?(HFONT) afxGlobalData.fontRegular.GetSafeHandle() : NULL;

	if (bRedraw && GetSafeHwnd() != NULL)
	{
		Invalidate();
		UpdateWindow();
	}
}

void CMFCButton::EnableFullTextTooltip(BOOL bOn)
{
	m_bFullTextTooltip = bOn;
	m_bDelayFullTextTooltipSet = bOn;
}

void CMFCButton::OnSize(UINT nType, int cx, int cy)
{
	m_bDelayFullTextTooltipSet = m_bFullTextTooltip;
	CButton::OnSize(nType, cx, cy);
}

void CMFCButton::OnDrawBorder(CDC* pDC, CRect& rectClient, UINT uiState)
{
	DrawBorder(pDC, rectClient, uiState);
}

void CMFCButton::OnKillFocus(CWnd* pNewWnd)
{
	CButton::OnKillFocus(pNewWnd);

	if (m_bCaptured)
	{
		ReleaseCapture();
		m_bCaptured = FALSE;
	}

	m_bPushed = FALSE;
	m_bClickiedInside = FALSE;
	m_bHighlighted = FALSE;
	m_bHover = FALSE;

	Invalidate();
	UpdateWindow();
}

void CMFCButton::OnLButtonDblClk(UINT nFlags, CPoint point)
{
	m_bPushed = TRUE;
	m_bClickiedInside = TRUE;
	m_bHighlighted = TRUE;

	Invalidate();
	UpdateWindow();

	CButton::OnLButtonDblClk(nFlags, point);
	m_bWasDblClk = TRUE;
}

void __stdcall CMFCButton::EnableWindowsTheming(BOOL bEnable/* = TRUE*/)
{
	m_bWinXPTheme = bEnable;
}

LRESULT CMFCButton::OnGetCheck(WPARAM, LPARAM)
{
	if (m_bCheckButton || m_bRadioButton)
	{
		return m_bChecked ? BST_CHECKED : BST_UNCHECKED;
	}

	return 0;
}

LRESULT CMFCButton::OnSetCheck(WPARAM fCheck, LPARAM)
{
	ASSERT(fCheck != BST_INDETERMINATE);

	if ((m_bCheckButton || m_bRadioButton) &&(!m_bChecked) != (fCheck == BST_UNCHECKED))
	{
		m_bChecked = fCheck != BST_UNCHECKED;

		if (m_bRadioButton)
		{
			UncheckRadioButtonsInGroup();
		}

		Invalidate();
		UpdateWindow();
	}

	return 0 ;
}

void CMFCButton::ClearImages(BOOL bChecked)
{
	m_nStdImageId = (CMenuImages::IMAGES_IDS) -1;
	m_nStdImageDisabledId = (CMenuImages::IMAGES_IDS) -1;
	m_sizeImage = CSize(0, 0);

	if (bChecked)
	{
		m_ImageChecked.Clear();
		m_ImageCheckedHot.Clear();
		m_ImageCheckedDisabled.Clear();
	}
	else
	{
		m_Image.Clear();
		m_ImageHot.Clear();
		m_ImageDisabled.Clear();
	}
}

BOOL CMFCButton::CheckNextPrevRadioButton(BOOL bNext)
{
	ASSERT_VALID(this);

	if (!m_bRadioButton)
	{
		return FALSE;
	}

	CWnd* pWndParent = GetParent();
	ASSERT_VALID(pWndParent);

	CMFCButton* pBtn = NULL;

	for (CWnd* pWnd = pWndParent->GetNextDlgGroupItem(this, !bNext); pWnd != this; pWnd = pWndParent->GetNextDlgGroupItem(pWnd, !bNext))
	{
		if ((pBtn = DYNAMIC_DOWNCAST(CMFCButton, pWnd)) != NULL && pBtn->m_bRadioButton && (pBtn->GetStyle() &(WS_DISABLED | WS_VISIBLE)) == WS_VISIBLE)
		{
			break;
		}
	}

	if (pBtn != NULL && pBtn != this && !pBtn->m_bChecked)
	{
		pBtn->SetCheck(TRUE);
		pBtn->SetFocus();

		::SendMessage(pBtn->GetParent()->GetSafeHwnd(), WM_COMMAND, MAKELONG(::GetWindowLong(pBtn->m_hWnd, GWL_ID), BN_CLICKED), (LPARAM) pBtn->m_hWnd);
		return TRUE;
	}

	return FALSE;
}

void CMFCButton::UncheckRadioButtonsInGroup()
{
	CWnd* pWndParent = GetParent();
	if (pWndParent == NULL)
	{
		return;
	}

	ASSERT_VALID(pWndParent);

	if (!IsWindowEnabled())
	{
		return;
	}

	// Walk through group and clear radio buttons check state
	for (CWnd * pCtl = pWndParent->GetNextDlgGroupItem(this); pCtl != this && pCtl != NULL; pCtl = pWndParent->GetNextDlgGroupItem(pCtl))
	{
		CMFCButton* pBtn = DYNAMIC_DOWNCAST(CMFCButton, pCtl);

		if (pBtn != NULL && pBtn->m_bRadioButton && pBtn->m_bChecked)
		{
			pBtn->m_bChecked = FALSE;
			pBtn->RedrawWindow();
		}
	}
}

void CMFCButton::SetAutorepeatMode(int nTimeDelay)
{
	ASSERT(nTimeDelay >= 0);
	m_nAutoRepeatTimeDelay = nTimeDelay;
}

void CMFCButton::OnTimer(UINT_PTR nIDEvent)
{
	if (nIDEvent == IdAutoCommand)
	{
		if (m_bPushed && m_bHighlighted)
		{
			CWnd* pParent = GetParent();
			if (pParent != NULL)
			{
				pParent->SendMessage( WM_COMMAND, MAKEWPARAM(GetDlgCtrlID(), BN_CLICKED), (LPARAM) m_hWnd);
			}
		}
	}

	CButton::OnTimer(nIDEvent);
}

void CMFCButton::DrawBorder(CDC* pDC, CRect& rectClient, UINT uiState)
{
	ASSERT_VALID(pDC);

	BOOL bBorderIsReady = FALSE;

	// Draw 3d border:
	if (m_nFlatStyle != BUTTONSTYLE_NOBORDERS)
	{
		if (m_bWinXPTheme && !m_bDontUseWinXPTheme && CMFCVisualManager::GetInstance()->DrawPushButtonWinXP(pDC, rectClient, this, uiState))
		{
			bBorderIsReady = TRUE;
		}

		if (m_bPushed && m_bHighlighted ||(uiState & ODS_SELECTED) || m_bChecked)
		{
			if (!bBorderIsReady)
			{
				pDC->Draw3dRect(rectClient, afxGlobalData.clrBtnDkShadow, afxGlobalData.clrBtnHilite);

				rectClient.DeflateRect(1, 1);

				if (m_nFlatStyle != BUTTONSTYLE_FLAT)
				{
					pDC->Draw3dRect(rectClient, afxGlobalData.clrBtnShadow, afxGlobalData.clrBtnLight);
				}

				rectClient.DeflateRect(1, 1);
			}
			else
			{
				rectClient.DeflateRect(2, 2);
			}

			if (!m_bWinXPTheme || m_bDontUseWinXPTheme)
			{
				rectClient.left += m_sizePushOffset.cx;
				rectClient.top += m_sizePushOffset.cy;
			}
		}
		else if (!bBorderIsReady &&(m_nFlatStyle != BUTTONSTYLE_FLAT || m_bHighlighted))
		{
			pDC->Draw3dRect(rectClient, afxGlobalData.clrBtnHilite, afxGlobalData.clrBtnDkShadow);
			rectClient.DeflateRect(1, 1);

			if (m_nFlatStyle == BUTTONSTYLE_3D || (m_nFlatStyle == BUTTONSTYLE_SEMIFLAT && m_bHighlighted))
			{
				pDC->Draw3dRect(rectClient, afxGlobalData.clrBtnLight, afxGlobalData.clrBtnShadow);
			}

			rectClient.DeflateRect(1, 1);
		}
		else
		{
			rectClient.DeflateRect(2, 2);
		}
	}
	else
	{
		rectClient.DeflateRect(2, 2);
	}
}

LRESULT CMFCButton::OnSetImage(WPARAM wParam, LPARAM lParam)
{
	switch (wParam)
	{
	case IMAGE_BITMAP:
		SetImage((HBITMAP) lParam, FALSE);
		break;

	case IMAGE_ICON:
		SetImage((HICON) lParam, FALSE);
		break;

	default:
		TRACE1("Error: unknown image type '%u'\n", (unsigned) wParam);
	}

	return 0;
}

LRESULT CMFCButton::OnGetImage(WPARAM wParam, LPARAM)
{
	switch (wParam)
	{
	case IMAGE_BITMAP:
		return(LRESULT) m_Image.GetImageWell();

	case IMAGE_ICON:
		return(LRESULT) m_Image.ExtractIcon(0);

	default:
		TRACE1("Error: unknown image type '%u'\n", (unsigned) wParam);
	}

	return 0;
}

int CMFCButton::GetImageHorzMargin() const
{
	return nImageHorzMargin;
}

int CMFCButton::GetVertMargin() const
{
	return nVertMargin;
}

void CMFCButton::OnDestroy()
{
	CTooltipManager::DeleteToolTip(m_pToolTip);
	CButton::OnDestroy();
}

LRESULT CMFCButton::OnUpdateToolTips(WPARAM wp, LPARAM)
{
	UINT nTypes = (UINT) wp;

	if (m_pToolTip->GetSafeHwnd() == NULL)
	{
		return 0;
	}

	if (nTypes & AFX_TOOLTIP_TYPE_BUTTON)
	{
		CString str;
		m_pToolTip->GetText(str, this);

		CTooltipManager::CreateToolTip(m_pToolTip, this, AFX_TOOLTIP_TYPE_BUTTON);

		if (m_pToolTip != NULL)
		{
			m_pToolTip->AddTool(this, str);
		}
	}

	return 0;
}

static HICON __stdcall ButtonLoadIcon(UINT uiIconResId)
{
	if (uiIconResId == 0)
	{
		return NULL;
	}

	LPCTSTR lpszResourceName = MAKEINTRESOURCE(uiIconResId);
	ENSURE(lpszResourceName != NULL);

	HINSTANCE hinstRes = AfxFindResourceHandle(lpszResourceName, RT_ICON);
	if (hinstRes == NULL)
	{
		return NULL;
	}

	return (HICON) ::LoadIcon(hinstRes, lpszResourceName);;
}

LRESULT CMFCButton::OnInitControl(WPARAM wParam, LPARAM lParam)
{
	DWORD dwSize = (DWORD)wParam;
	BYTE* pbInitData = (BYTE*)lParam;

	CString strDst;
	CMFCControlContainer::UTF8ToString((LPSTR)pbInitData, strDst, dwSize);

	CTagManager tagManager(strDst);

	CString strStyle;
	if (tagManager.ExcludeTag(PS_MFCButton_Style, strStyle))
	{
		if (!strStyle.IsEmpty())
		{
			int nStyle = _ttoi((LPCTSTR)strStyle);
			switch (nStyle)
			{
			case MFC_BTN_STYLE_3D:
				m_nFlatStyle = CMFCButton::BUTTONSTYLE_3D;
				break;
			case MFC_BTN_STYLE_FLAT:
				m_nFlatStyle = CMFCButton::BUTTONSTYLE_FLAT;
				break;
			case MFC_BTN_STYLE_NOBORDERS:
				m_nFlatStyle = CMFCButton::BUTTONSTYLE_NOBORDERS;
				break;
			case MFC_BTN_MODE_STYLE_SEMIFLAT:
				m_nFlatStyle = CMFCButton::BUTTONSTYLE_SEMIFLAT;
				break;
			}
		}
	}

	BOOL bAutosize = FALSE;
	if (CMFCControlContainer::ReadBoolProp(tagManager, PS_MFCButton_Autosize, bAutosize))
	{
		if (bAutosize)
		{
			SizeToContent();
		}
	}

	CString strTooltip;
	if (tagManager.ExcludeTag(PS_MFCButton_Tooltip, strTooltip))
	{
		SetTooltip(strTooltip);
	}

	CString strFullTextTooltip;
	if (tagManager.ExcludeTag(PS_MFCButton_FullTextTooltip, strFullTextTooltip))
	{
		if (!strFullTextTooltip.IsEmpty())
		{
			strFullTextTooltip.MakeUpper();
			EnableFullTextTooltip(strFullTextTooltip == PS_True);
		}
	}

	CString strCursorType;
	if (tagManager.ExcludeTag(PS_MFCButton_CursorType, strCursorType))
	{
		if (!strCursorType.IsEmpty())
		{
			int nCursorType = _ttoi((LPCTSTR)strCursorType);
			switch (nCursorType)
			{
			case MFC_BTN_CURSORTYPE_NONE:
			case MFC_BTN_CURSORTYPE_CUSTOM:
				SetMouseCursor(NULL);
				break;

			case MFC_BTN_CURSORTYPE_HAND:
				SetMouseCursorHand();
				break;
			}
		}
	}

	CString strImageType;
	if (tagManager.ExcludeTag(PS_MFCButton_ImageType, strImageType))
	{
		if (!strImageType.IsEmpty())
		{
			int nImageType = _ttoi((LPCTSTR)strImageType);
			switch (nImageType)
			{
			case MFC_BTN_IMAGETYPE_NONE:
				SetImage((HBITMAP)NULL);
				break;
			case MFC_BTN_IMAGETYPE_ICON:
			case MFC_BTN_IMAGETYPE_BITMAP:
				{
					CString strImage;
					if (tagManager.ExcludeTag(PS_MFCButton_ImageID, strImage))
					{
						if (!strImage.IsEmpty())
						{
							int nImageID = _ttoi((LPCTSTR)strImage);

							// Load resource by ID
							if (nImageType == MFC_BTN_IMAGETYPE_BITMAP)
							{
								SetImage((UINT)nImageID);
							}
							else if (nImageType == MFC_BTN_IMAGETYPE_ICON)
							{
								HICON hIcon = ButtonLoadIcon((UINT)nImageID);
								SetImage(hIcon);
							}
						}
						else
						{
							SetImage((HBITMAP)NULL);
						}
					}
				}
				break;
			}
		}
	}

	BOOL bImageOnTop = FALSE;
	if (CMFCControlContainer::ReadBoolProp(tagManager, PS_MFCButton_ImageOnTop, bImageOnTop))
	{
		m_bTopImage = bImageOnTop;
	}

	BOOL bImageOnRight = FALSE;
	if (CMFCControlContainer::ReadBoolProp(tagManager, PS_MFCButton_ImageOnRight, bImageOnRight))
	{
		m_bRightImage = bImageOnRight;
	}

	return 0;
}

HRESULT CMFCButton::get_accState(VARIANT varChild, VARIANT *pvarState)
{
	HRESULT hr = CButton::get_accState(varChild, pvarState);
	if (FAILED(hr))
	{
		return hr;
	}

	if (m_bHighlighted)
	{
		pvarState->lVal |= STATE_SYSTEM_HOTTRACKED;
	}

	if (m_bChecked)
	{
		if (m_bRadioButton)
		{
			pvarState->lVal |= STATE_SYSTEM_SELECTED;
		}
		else
		{
			pvarState->lVal |= STATE_SYSTEM_CHECKED;
		}
	}

	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\src\mfc\afxbasetoolbar.cpp ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#include "stdafx.h"

#include "afxdocksite.h"
#include "afxbasetoolbar.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#endif

IMPLEMENT_DYNCREATE(CMFCBaseToolBar,CPane)

/////////////////////////////////////////////////////////////////////////////
// CMFCBaseToolBar

CMFCBaseToolBar::CMFCBaseToolBar()
{
}

CMFCBaseToolBar::~CMFCBaseToolBar()
{
}

BEGIN_MESSAGE_MAP(CMFCBaseToolBar, CPane)
	//{{AFX_MSG_MAP(CMFCBaseToolBar)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CMFCBaseToolBar message handlers

void CMFCBaseToolBar::OnAfterChangeParent(CWnd* /*pWndOldParent*/)
{
}

void CMFCBaseToolBar::OnAfterStretch(int /*nStretchSize*/)
{
	CRect rectClient;
	GetClientRect(&rectClient);

	if (rectClient.Width() != m_rectVirtual.Width())
	{
		Invalidate();
		UpdateWindow();
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\src\mfc\afxcaptionbar.cpp ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#include "stdafx.h"

#include "afxcaptionbar.h"
#include "afxvisualmanager.h"
#include "afxtoolbar.h"
#include "afxtrackmouse.h"
#include "afxframewndex.h"
#include "afxmdiframewndex.h"
#include "afxoleipframewndex.h"
#include "afxoledocipframewndex.h"
#include "afxmdichildwndex.h"
#include "afxglobalutils.h"
#include "afxtooltipmanager.h"
#include "afxtooltipctrl.h"
#include "afxribbonres.h"

const int nMenuArrowWidth = 10;
const int nButtonHorzMargin = 10;
const int nButtonVertMargin = 5;
const int nMessageBarMargin = 4;

const int nIdToolTipClose = 1;
const int nIdToolTipText = 2;
const int nIdToolTipImage = 3;
const int nIdToolTipButton = 4;

IMPLEMENT_DYNCREATE(CMFCCaptionBar, CPane)

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CMFCCaptionBar::CMFCCaptionBar()
{
	m_pToolTip = NULL;

	m_clrBarText = (COLORREF)-1;
	m_clrBarBackground = (COLORREF)-1;
	m_clrBarBorder = (COLORREF)-1;

	m_nBorderSize = 4;
	m_nMargin = 4;
	m_nHorzElementOffset = 4;

	m_hIcon = NULL;
	m_hFont = NULL;

	m_nDefaultHeight = -1;
	m_nCurrentHeight = 0;

	m_btnAlignnment = ALIGN_LEFT;
	m_iconAlignment = ALIGN_LEFT;
	m_textAlignment = ALIGN_LEFT;

	m_bStretchImage = FALSE;

	m_bFlatBorder = FALSE;
	m_uiBtnID = 0;

	m_bIsBtnPressed = FALSE;
	m_bIsBtnForcePressed = FALSE;
	m_bIsBtnHighlighted = FALSE;

	m_bTracked = FALSE;
	m_bBtnEnabled = TRUE;
	m_bBtnHasDropDownArrow = TRUE;

	m_rectImage.SetRectEmpty();
	m_rectText.SetRectEmpty();
	m_rectDrawText.SetRectEmpty();
	m_rectButton.SetRectEmpty();
	m_bTextIsTruncated = FALSE;

	m_bIsMessageBarMode = FALSE;

	m_bIsCloseBtnPressed = FALSE;
	m_bIsCloseBtnHighlighted= FALSE;
	m_bCloseTracked = FALSE;

	m_rectClose.SetRectEmpty();
}

CMFCCaptionBar::~CMFCCaptionBar()
{
}

BOOL CMFCCaptionBar::Create(DWORD dwStyle, CWnd* pParentWnd, UINT uID, int nHeight, BOOL bIsMessageBarMode)
{
	ENSURE( AfxIsExtendedFrameClass(pParentWnd) || pParentWnd->IsKindOf(RUNTIME_CLASS(CDialog)) );

	SetPaneStyle(CBRS_ALIGN_TOP);
	m_nDefaultHeight = nHeight;

	if (bIsMessageBarMode)
	{
		m_dwStyle |= CBRS_HIDE_INPLACE;
	}

	if (!CPane::Create(NULL, dwStyle, CRect(0, 0, 0, 0), pParentWnd, uID, 0))
	{
		return FALSE;
	}

	// register with parent frames' dock manager!!!
	if (pParentWnd->IsKindOf(RUNTIME_CLASS(CFrameWndEx)))
	{
		((CFrameWndEx*) pParentWnd)->AddPane(this);
	}
	else if (pParentWnd->IsKindOf(RUNTIME_CLASS(CMDIFrameWndEx)))
	{
		((CMDIFrameWndEx*) pParentWnd)->AddPane(this);
	}
	else if (pParentWnd->IsKindOf(RUNTIME_CLASS(COleIPFrameWndEx)))
	{
		((COleIPFrameWndEx*) pParentWnd)->AddPane(this);
	}
	else if (pParentWnd->IsKindOf(RUNTIME_CLASS(COleDocIPFrameWndEx)))
	{
		((COleIPFrameWndEx*) pParentWnd)->AddPane(this);
	}
	else if (pParentWnd->IsKindOf(RUNTIME_CLASS(CMDIChildWndEx)))
	{
		((CMDIChildWndEx*) pParentWnd)->AddPane(this);
	}
	else if (pParentWnd->IsKindOf(RUNTIME_CLASS(CDialog)))
	{
		if (pParentWnd->GetSafeHwnd() == AfxGetMainWnd()->GetSafeHwnd())
		{
			afxGlobalUtils.m_bDialogApp = TRUE;
		}
	}
	else
	{
		ASSERT(FALSE);
	}

	m_bIsMessageBarMode = bIsMessageBarMode;

	if (m_bIsMessageBarMode)
	{
		m_nBorderSize = 0;
	}

	return TRUE;
}

//{{AFX_MSG_MAP(CMFCCaptionBar)
BEGIN_MESSAGE_MAP(CMFCCaptionBar, CPane)
	ON_WM_CREATE()
	ON_WM_PAINT()
	ON_WM_ERASEBKGND()
	ON_WM_SIZE()
	ON_WM_SYSCOLORCHANGE()
	ON_WM_NCCALCSIZE()
	ON_WM_NCPAINT()
	ON_WM_LBUTTONDOWN()
	ON_WM_LBUTTONUP()
	ON_WM_MOUSEMOVE()
	ON_WM_RBUTTONUP()
	ON_WM_DESTROY()
	ON_MESSAGE(WM_SETFONT, &CMFCCaptionBar::OnSetFont)
	ON_MESSAGE(WM_GETFONT, &CMFCCaptionBar::OnGetFont)
	ON_MESSAGE(WM_MOUSELEAVE, &CMFCCaptionBar::OnMouseLeave)
	ON_REGISTERED_MESSAGE(AFX_WM_UPDATETOOLTIPS, &CMFCCaptionBar::OnUpdateToolTips)
	ON_NOTIFY_EX_RANGE(TTN_NEEDTEXT, 0, 0xFFFF, &CMFCCaptionBar::OnNeedTipText)
END_MESSAGE_MAP()
//}}AFX_MSG_MAP

void CMFCCaptionBar::OnUpdateCmdUI(CFrameWnd* /*pTarget*/, BOOL /*bDisableIfNoHndler*/)
{
}

int CMFCCaptionBar::OnCreate(LPCREATESTRUCT lpCreateStruct)
{
	if (CPane::OnCreate(lpCreateStruct) == -1)
		return -1;

	CTooltipManager::CreateToolTip(m_pToolTip, this, AFX_TOOLTIP_TYPE_CAPTIONBAR);

	if (m_pToolTip->GetSafeHwnd() != NULL)
	{
		CRect rectDummy(0, 0, 0, 0);

		m_pToolTip->SetMaxTipWidth(640);

		m_pToolTip->AddTool(this, LPSTR_TEXTCALLBACK, &rectDummy, nIdToolTipClose);
		m_pToolTip->AddTool(this, LPSTR_TEXTCALLBACK, &rectDummy, nIdToolTipText);
		m_pToolTip->AddTool(this, LPSTR_TEXTCALLBACK, &rectDummy, nIdToolTipImage);
		m_pToolTip->AddTool(this, LPSTR_TEXTCALLBACK, &rectDummy, nIdToolTipButton);
	}

	SetWindowText(_T("Caption Bar"));
	return 0;
}

void CMFCCaptionBar::OnSize(UINT nType, int cx, int cy)
{
	CPane::OnSize(nType, cx, cy);
	RecalcLayout();
	InvalidateRect(NULL);
}

void CMFCCaptionBar::OnNcCalcSize(BOOL /*bCalcValidRects*/, NCCALCSIZE_PARAMS FAR* lpncsp)
{
	lpncsp->rgrc[0].bottom -= m_nBorderSize;
	lpncsp->rgrc[0].top  += m_nBorderSize;
}

void CMFCCaptionBar::OnPaint()
{
	CPaintDC dcPaint(this);
	CMemDC memDC(dcPaint, this);
	CDC& dc = memDC.GetDC();

	CRect rectClient;
	GetClientRect(rectClient);

	OnDrawBackground(&dc, rectClient);

	int nOldBkMode = dc.SetBkMode(TRANSPARENT);
	COLORREF clrOldText = dc.SetTextColor(m_clrBarText != (COLORREF) -1 ? m_clrBarText : CMFCVisualManager::GetInstance()->GetCaptionBarTextColor(this));

	CFont* pOldFont = dc.SelectObject(m_hFont == NULL ? &afxGlobalData.fontRegular : CFont::FromHandle(m_hFont));

	OnDrawButton(&dc, m_rectButton, m_strBtnText, m_bBtnEnabled);
	OnDrawText(&dc, m_rectDrawText, m_strText);

	if (!m_rectImage.IsRectEmpty())
	{
		OnDrawImage(&dc, m_rectImage);
	}

	if (!m_rectClose.IsRectEmpty())
	{
		COLORREF clrText = CMFCVisualManager::GetInstance()->OnFillCaptionBarButton(&dc, this, m_rectClose, m_bIsCloseBtnPressed, m_bIsCloseBtnHighlighted, FALSE, FALSE, TRUE);

		CMenuImages::IMAGE_STATE imageState;

		if (GetRValue(clrText) > 192 && GetGValue(clrText) > 192 && GetBValue(clrText) > 192)
		{
			imageState = CMenuImages::ImageWhite;
		}
		else
		{
			imageState = CMenuImages::ImageBlack;
		}

		CMenuImages::Draw(&dc, CMenuImages::IdClose, m_rectClose, imageState);

		CMFCVisualManager::GetInstance()->OnDrawCaptionBarButtonBorder(&dc, this, m_rectClose, m_bIsCloseBtnPressed, m_bIsCloseBtnHighlighted, FALSE, FALSE, TRUE);
	}

	dc.SelectObject(pOldFont);
	dc.SetTextColor(clrOldText);
	dc.SetBkMode(nOldBkMode);
}

void CMFCCaptionBar::OnNcPaint()
{
	CWindowDC dcWin(this);

	CRect rectClient;
	GetClientRect(rectClient);

	CRect rectWindow;
	GetWindowRect(rectWindow);

	CRect rectBorder = rectWindow;

	ScreenToClient(rectWindow);

	rectClient.OffsetRect(-rectWindow.left, -rectWindow.top);
	dcWin.ExcludeClipRect(rectClient);

	rectBorder.OffsetRect(-rectBorder.left, -rectBorder.top);

	int nTop = rectBorder.top;
	rectBorder.top = rectBorder.bottom - m_nBorderSize;
	OnDrawBorder(&dcWin, rectBorder);

	rectBorder.top = nTop;
	rectBorder.bottom = rectBorder.top + m_nBorderSize;

	OnDrawBorder(&dcWin, rectBorder);
	dcWin.SelectClipRgn(NULL);
}

void CMFCCaptionBar::OnDrawBackground(CDC* pDC, CRect rect)
{
	ASSERT_VALID(pDC);

	CMFCVisualManager::GetInstance()->OnFillBarBackground(pDC, this, rect, rect);

	if (m_bIsMessageBarMode)
	{
		CRect rectInfo = rect;
		rectInfo.DeflateRect(nMessageBarMargin, nMessageBarMargin);
		rectInfo.right -= m_rectClose.Width();

		CMFCVisualManager::GetInstance()->OnDrawCaptionBarInfoArea(pDC, this, rectInfo);
	}
}

void CMFCCaptionBar::OnDrawBorder(CDC* pDC, CRect rect)
{
	ASSERT_VALID(pDC);

	rect.InflateRect(2, 0);

	CMFCVisualManager::GetInstance()->OnDrawCaptionBarBorder(pDC, this, rect, m_clrBarBorder, m_bFlatBorder);
}

void CMFCCaptionBar::OnDrawButton(CDC* pDC, CRect rect, const CString& strButton, BOOL bEnabled)
{
	ASSERT_VALID(pDC);

	COLORREF clrText = CMFCVisualManager::GetInstance()->OnFillCaptionBarButton(pDC, this, rect, m_bIsBtnPressed || m_bIsBtnForcePressed, m_bIsBtnHighlighted, !m_bBtnEnabled, m_bBtnHasDropDownArrow, FALSE);

	CRect rectText = rect;
	rectText.DeflateRect(m_nHorzElementOffset, 0);

	if (m_bIsMessageBarMode)
	{
		rectText.DeflateRect(nButtonHorzMargin, 0);
	}

	if (m_uiBtnID != 0 && bEnabled && m_bBtnHasDropDownArrow)
	{
		rectText.right -= nMenuArrowWidth;
	}

	COLORREF clrTextOld = (COLORREF)-1;
	if (clrText != (COLORREF)-1)
	{
		clrTextOld = pDC->SetTextColor(clrText);
	}

	pDC->DrawText(strButton, rectText, DT_END_ELLIPSIS | DT_SINGLELINE | DT_VCENTER);

	if (clrTextOld != (COLORREF)-1)
	{
		pDC->SetTextColor(clrTextOld);
	}

	if (m_uiBtnID != 0 && bEnabled)
	{
		if (m_uiBtnID != 0 && m_bBtnHasDropDownArrow)
		{
			// Draw menu triangle:
			CRect rectArrow = rect;
			rectArrow.bottom -= m_nMargin;
			rectArrow.top = rectArrow.bottom - nMenuArrowWidth;
			rectArrow.left = rectText.right;

			int iXMiddle = rectArrow.left + rectArrow.Width() / 2;

			rectArrow.DeflateRect(0, rectArrow.Height() / 3);
			rectArrow.DeflateRect(rectArrow.Height() / 3, rectArrow.Height() / 3);
			rectArrow.left = iXMiddle - rectArrow.Height() - 1;
			rectArrow.right = iXMiddle + rectArrow.Height() + 1;

			int iHalfWidth = (rectArrow.Width() % 2 != 0) ? (rectArrow.Width() - 1) / 2 : rectArrow.Width() / 2;

			CPoint pts [3];
			pts[0].x = rectArrow.left;
			pts[0].y = rectArrow.top;
			pts[1].x = rectArrow.right;
			pts[1].y = rectArrow.top;
			pts[2].x = rectArrow.left + iHalfWidth;
			pts[2].y = rectArrow.bottom + 1;

			CBrush brArrow(pDC->GetTextColor());

			CPen* pOldPen = (CPen*) pDC->SelectStockObject(NULL_PEN);
			CBrush* pOldBrush = (CBrush*) pDC->SelectObject(&brArrow);

			pDC->SetPolyFillMode(WINDING);
			pDC->Polygon(pts, 3);

			pDC->SelectObject(pOldBrush);
			pDC->SelectObject(pOldPen);
		}

		CMFCVisualManager::GetInstance()->OnDrawCaptionBarButtonBorder(pDC, this, rect, m_bIsBtnPressed || m_bIsBtnForcePressed, m_bIsBtnHighlighted, !m_bBtnEnabled, m_bBtnHasDropDownArrow, FALSE);
	}
}

void CMFCCaptionBar::OnDrawText(CDC* pDC, CRect rect, const CString& strText)
{
	ASSERT_VALID(pDC);

	if (m_arTextParts.GetSize() == 1)
	{
		pDC->DrawText(strText, rect, DT_END_ELLIPSIS | DT_SINGLELINE | DT_VCENTER);
		return;
	}

	int x = rect.left;

	BOOL bIsBold = FALSE;

	for (int i = 0; i < m_arTextParts.GetSize(); i++)
	{
		if (!m_arTextParts [i].IsEmpty())
		{
			CFont* pOldFont = NULL;

			if (bIsBold)
			{
				pOldFont = pDC->SelectObject(&afxGlobalData.fontBold);
			}

			CRect rectPart = rect;
			rectPart.left = x;

			CSize sizePart = pDC->GetTextExtent(m_arTextParts [i]);

			pDC->DrawText(m_arTextParts [i], rectPart, DT_END_ELLIPSIS | DT_SINGLELINE | DT_VCENTER);

			if (pOldFont != NULL)
			{
				pDC->SelectObject(pOldFont);
			}

			x += sizePart.cx;
		}

		bIsBold = !bIsBold;
	}
}

void CMFCCaptionBar::OnDrawImage(CDC* pDC, CRect rect)
{
	ASSERT_VALID(pDC);

	if (m_hIcon != NULL)
	{
		DrawIconEx(pDC->GetSafeHdc(), rect.left, rect.top, m_hIcon, rect.Width(), rect.Height(), NULL, (HBRUSH)NULL, DI_NORMAL) ;
	}
	else if (m_Bitmap.GetCount() > 0)
	{
		CSize sizeDest;
		if (m_bStretchImage)
		{
			sizeDest = rect.Size();
		}
		else
		{
			sizeDest = m_rectImage.Size();
		}

		CAfxDrawState ds;
		m_Bitmap.PrepareDrawImage(ds, sizeDest);
		m_Bitmap.Draw(pDC, rect.left, rect.top, 0);
		m_Bitmap.EndDrawImage(ds);
	}
}

void CMFCCaptionBar::OnSysColorChange()
{
}

CSize CMFCCaptionBar::CalcFixedLayout(BOOL /*bStretch*/, BOOL /*bHorz*/)
{
	RecalcLayout();
	return CSize(32767, m_nCurrentHeight);
}

void CMFCCaptionBar::SetButton(LPCTSTR lpszLabel, UINT uiCmdUI, BarElementAlignment btnAlignment, BOOL bHasDropDownArrow)
{
	ENSURE(lpszLabel != NULL);

	m_strBtnText = lpszLabel;
	m_uiBtnID = uiCmdUI;
	m_btnAlignnment = btnAlignment;
	m_bBtnHasDropDownArrow = bHasDropDownArrow;

	AdjustLayout();
}

void CMFCCaptionBar::EnableButton(BOOL bEnable)
{
	m_bBtnEnabled = bEnable;

	if (GetSafeHwnd() != NULL)
	{
		CRect rectButton = m_rectButton;

		RecalcLayout();

		InvalidateRect(rectButton);
		InvalidateRect(m_rectButton);

		UpdateWindow();
	}
}

void CMFCCaptionBar::SetButtonPressed(BOOL bPresed)
{
	m_bIsBtnForcePressed = bPresed;

	if (GetSafeHwnd() != NULL)
	{
		InvalidateRect(m_rectButton);
		UpdateWindow();
	}
}

void CMFCCaptionBar::SetButtonToolTip(LPCTSTR lpszToolTip, LPCTSTR lpszDescription)
{
	m_strButtonToolTip = lpszToolTip == NULL ? _T("") : lpszToolTip;
	m_strButtonDescription = lpszDescription == NULL ? _T("") : lpszDescription;

	UpdateTooltips();
}

void CMFCCaptionBar::RemoveButton()
{
	m_strBtnText.Empty();
	AdjustLayout();
}

void CMFCCaptionBar::SetIcon(HICON hIcon, BarElementAlignment iconAlignment)
{
	m_Bitmap.Clear();

	m_hIcon = hIcon;
	m_iconAlignment = iconAlignment;

	AdjustLayout();
}

void CMFCCaptionBar::RemoveIcon()
{
	m_hIcon = NULL;
	AdjustLayout();
}

void CMFCCaptionBar::SetBitmap(HBITMAP hBitmap, COLORREF clrTransparent, BOOL bStretch, BarElementAlignment bmpAlignment)
{
	ENSURE(hBitmap != NULL);

	m_hIcon = NULL;
	m_Bitmap.Clear();

	BITMAP bmp;
	::GetObject(hBitmap, sizeof(BITMAP), (LPVOID) &bmp);

	m_Bitmap.SetImageSize(CSize(bmp.bmWidth, bmp.bmHeight));
	m_Bitmap.SetTransparentColor(clrTransparent);
	m_Bitmap.AddImage(hBitmap, clrTransparent == (COLORREF)-1);

	m_bStretchImage = bStretch;

	m_iconAlignment = bmpAlignment;

	AdjustLayout();
}

void CMFCCaptionBar::SetBitmap(UINT uiBmpResID, COLORREF clrTransparent, BOOL bStretch, BarElementAlignment bmpAlignment)
{
	m_hIcon = NULL;
	m_Bitmap.Clear();

	m_Bitmap.SetTransparentColor(clrTransparent);
	m_Bitmap.Load(uiBmpResID);
	m_Bitmap.SetSingleImage();

	m_bStretchImage = bStretch;
	m_iconAlignment = bmpAlignment;

	AdjustLayout();
}

void CMFCCaptionBar::RemoveBitmap()
{
	m_Bitmap.Clear();

	AdjustLayout();
}

void CMFCCaptionBar::SetImageToolTip(LPCTSTR lpszToolTip, LPCTSTR lpszDescription)
{
	m_strImageToolTip = lpszToolTip == NULL ? _T("") : lpszToolTip;
	m_strImageDescription = lpszDescription == NULL ? _T("") : lpszDescription;

	UpdateTooltips();
}

void CMFCCaptionBar::SetText(const CString& strText, BarElementAlignment textAlignment)
{
	BOOL bWasEmptyText = m_strText.IsEmpty();

	m_arTextParts.RemoveAll();

	int iStart = 0;

	for (int i = 0; i < strText.GetLength(); i++)
	{
		if (strText [i] == _T('\b'))
		{
			m_arTextParts.Add(strText.Mid(iStart, i - iStart));
			iStart = i + 1;
		}
	}

	m_arTextParts.Add(strText.Mid(iStart));

	m_strText = strText;
	m_textAlignment = textAlignment;

	if (m_nCurrentHeight == 0 || m_strText.IsEmpty() || bWasEmptyText)
	{
		AdjustLayout();
	}
	else
	{
		RecalcLayout();
		RedrawWindow();
	}
}

void CMFCCaptionBar::RemoveText()
{
	m_strText.Empty();
	AdjustLayout();
}

afx_msg LRESULT CMFCCaptionBar::OnSetFont(WPARAM wParam, LPARAM /*lParam*/)
{
	m_hFont = (HFONT) wParam;

	AdjustLayout();
	return 0;
}

afx_msg LRESULT CMFCCaptionBar::OnGetFont(WPARAM, LPARAM)
{
	return(LRESULT) m_hFont;
}

CMFCCaptionBar::BarElementAlignment CMFCCaptionBar::GetAlignment(BarElement elem)
{
	switch (elem)
	{
	case ELEM_BUTTON:
		return m_btnAlignnment;

	case ELEM_TEXT:
		return m_textAlignment;

	case ELEM_ICON:
		return m_iconAlignment;
	}

	ASSERT(FALSE);
	return ALIGN_INVALID;
}

void CMFCCaptionBar::RecalcLayout()
{
	CClientDC dc(NULL);

	CFont* pOldFont = dc.SelectObject(m_hFont == NULL ? &afxGlobalData.fontRegular : CFont::FromHandle(m_hFont));

	TEXTMETRIC tm;
	dc.GetTextMetrics(&tm);

	int nTextHeight = tm.tmHeight + 2;
	CSize sizeImage = GetImageSize();

	// the height is set to the default(provided by the user in Create)
	// or calculated if it is -1
	if (m_nDefaultHeight != -1)
	{
		m_nCurrentHeight = m_nDefaultHeight;
	}
	else
	{
		if (!m_strBtnText.IsEmpty() && m_bIsMessageBarMode)
		{
			nTextHeight += 2 * nButtonVertMargin;
		}

		m_nCurrentHeight = max(nTextHeight, sizeImage.cy) + m_nMargin * 2 + m_nBorderSize;
	}

	if (m_bIsMessageBarMode)
	{
		m_nCurrentHeight += nMessageBarMargin * 2;
	}

	// for left and center alignment: icon, button, text
	// for right alignment: text, button, icon

	CRect rectClient;
	GetClientRect(rectClient);
	if (rectClient.IsRectEmpty())
	{
		return;
	}

	if (m_bIsMessageBarMode)
	{
		CSize sizeMenuImage = CMenuImages::Size();
		sizeMenuImage.cx += 2 * nMessageBarMargin;
		sizeMenuImage.cy += 2 * nMessageBarMargin;

		m_rectClose = CRect(CPoint(rectClient.right - sizeImage.cx, rectClient.top + nMessageBarMargin), sizeMenuImage);

		rectClient.DeflateRect(nMessageBarMargin, nMessageBarMargin);
		rectClient.right -= m_rectClose.Width();
	}

	BOOL bButtonLeftOfIcon = FALSE;
	BOOL bTextLeftOfButton = FALSE;
	BOOL bTextLeftOfIcon = FALSE;

	BOOL bIconCenter = FALSE;
	BOOL bButtonCenter = FALSE;
	BOOL bButtonAfterText = FALSE;
	BOOL bTextCenter = FALSE;

	// differs from the current height, because the border size is non-client area
	int nBaseLine = rectClient.CenterPoint().y;
	int nCenterOffset = rectClient.CenterPoint().x;

	int nNextXOffsetLeft  = rectClient.left + m_nMargin;
	int nNextXOffsetRight = rectClient.right - m_nMargin;
	int nNextXOffsetCenter = nCenterOffset;

	if (IsImageSet())
	{
		if (sizeImage.cy < rectClient.Height())
		{
			// center the icon if its height lesser than client area height
			m_rectImage.top = nBaseLine - sizeImage.cy / 2;
		}
		else
		{
			// otherwise, clip it from the buttom
			m_rectImage.top = rectClient.top + m_nMargin;
		}

		if (!m_bStretchImage)
		{
			m_rectImage.bottom = m_rectImage.top + sizeImage.cy;
		}
		else
		{
			m_rectImage.bottom = rectClient.bottom - m_nMargin;
		}

		switch (m_iconAlignment)
		{
		case ALIGN_LEFT:
			m_rectImage.left = nNextXOffsetLeft;
			m_rectImage.right = m_rectImage.left + sizeImage.cx;
			nNextXOffsetLeft = m_rectImage.right + m_nHorzElementOffset;
			break;

		case ALIGN_RIGHT:
			m_rectImage.left = nNextXOffsetRight - sizeImage.cx;
			m_rectImage.right = m_rectImage.left + sizeImage.cx;
			nNextXOffsetRight = m_rectImage.left - m_nHorzElementOffset;
			// only in this case button and text is at the left side of the icon
			bButtonLeftOfIcon = TRUE;
			bTextLeftOfIcon = TRUE;
			break;

		case ALIGN_CENTER:
			bIconCenter = TRUE;
			nNextXOffsetCenter -= sizeImage.cx / 2;

			if (m_btnAlignnment == ALIGN_LEFT)
			{
				bButtonLeftOfIcon = TRUE;
			}

			if (m_textAlignment == ALIGN_LEFT)
			{
				bTextLeftOfIcon = TRUE;
			}
			break;

		default:
			ASSERT(FALSE);
		}
	}

	int nButtonWidth = 0;

	if (!m_strBtnText.IsEmpty())
	{
		nButtonWidth = dc.GetTextExtent(m_strBtnText).cx + 2 * m_nHorzElementOffset;

		if (m_bIsMessageBarMode)
		{
			nButtonWidth += 2 * nButtonHorzMargin;
		}

		if (m_uiBtnID != 0 && m_bBtnEnabled && m_bBtnHasDropDownArrow)
		{
			nButtonWidth += nMenuArrowWidth;
		}

		// the button always has a height equivalent to the bar's height
		m_rectButton.top = rectClient.top;
		m_rectButton.bottom = rectClient.bottom;

		if (m_bIsMessageBarMode)
		{
			m_rectButton.DeflateRect(0, nButtonVertMargin);
		}

		switch (m_btnAlignnment)
		{
		case ALIGN_LEFT:
			if (!m_bIsMessageBarMode || m_textAlignment != ALIGN_LEFT)
			{
				m_rectButton.left = nNextXOffsetLeft;

				if (nNextXOffsetLeft == rectClient.left + m_nMargin)
				{
					m_rectButton.left = rectClient.left + m_nMargin;
				}

				m_rectButton.right = m_rectButton.left + nButtonWidth;
				nNextXOffsetLeft = m_rectButton.right + m_nHorzElementOffset;
			}
			else
			{
				bButtonAfterText = TRUE;
			}
			break;

		case ALIGN_RIGHT:
			m_rectButton.left = nNextXOffsetRight - nButtonWidth;

			if (nNextXOffsetRight == rectClient.right - m_nMargin)
			{
				m_rectButton.left = rectClient.right - nButtonWidth - m_nMargin;
			}

			m_rectButton.right = m_rectButton.left + nButtonWidth;
			nNextXOffsetRight = m_rectButton.left - m_nHorzElementOffset;
			// only in this case text at the left side of the button
			bTextLeftOfButton = TRUE;
			break;

		case ALIGN_CENTER:
			bButtonCenter = TRUE;
			nNextXOffsetCenter -= nButtonWidth / 2;

			if (m_textAlignment == ALIGN_LEFT)
			{
				bTextLeftOfButton = TRUE;
			}
			break;

		default:
			ASSERT(FALSE);
			return;
		}
	}

	CSize sizeText(0, 0);

	if (!m_strText.IsEmpty())
	{
		sizeText = GetTextSize(&dc, m_strText);

		m_rectText.top = nBaseLine - sizeText.cy / 2;
		m_rectText.bottom = m_rectText.top + sizeText.cy;

		switch (m_textAlignment)
		{
		case ALIGN_LEFT:
			m_rectText.left = nNextXOffsetLeft;
			nNextXOffsetLeft += sizeText.cx + 2 * m_nMargin;
			break;

		case ALIGN_RIGHT:
			m_rectText.left = nNextXOffsetRight - sizeText.cx;
			break;

		case ALIGN_CENTER:
			bTextCenter = TRUE;
			nNextXOffsetCenter -= sizeText.cx / 2;
			break;

		default:
			ASSERT(FALSE);
			return;
		}

		m_rectText.right = m_rectText.left + sizeText.cx;
		AdjustRectToMargin(m_rectText, rectClient, m_nMargin);
		m_rectDrawText = m_rectText;
	}

	if (bIconCenter)
	{
		m_rectImage.left = nNextXOffsetCenter;
		m_rectImage.right = m_rectImage.left + sizeImage.cx;
		nNextXOffsetCenter = m_rectImage.right + m_nHorzElementOffset;
	}

	if (bButtonAfterText)
	{
		m_rectButton.left = nNextXOffsetLeft;
		m_rectButton.right = m_rectButton.left + nButtonWidth;

		if (m_rectButton.right + m_nMargin > rectClient.right)
		{
			m_rectButton.right = rectClient.right - m_nMargin;
			m_rectButton.left = m_rectButton.right - nButtonWidth;
		}
	}
	else if (bButtonCenter)
	{
		m_rectButton.left = nNextXOffsetCenter;
		m_rectButton.right = m_rectButton.left + nButtonWidth;
		nNextXOffsetCenter = m_rectButton.right + m_nHorzElementOffset;
	}

	if (bTextCenter)
	{
		m_rectText.left = nNextXOffsetCenter;
		m_rectText.right = m_rectText.left + sizeText.cx;
		AdjustRectToMargin(m_rectText, rectClient, m_nMargin);
		m_rectDrawText = m_rectText;
	}

	if (IsImageSet())
	{
		// do not retain image size if it should be stretched
		AdjustRectToMargin(m_rectImage, rectClient, m_nMargin, !m_bStretchImage);

		if (m_rectImage.left < rectClient.left || m_rectImage.right > rectClient.right)
		{
			m_rectImage.SetRectEmpty();
		}
	}

	CRect rectButtonTemp = m_rectButton;
	if (!m_strBtnText.IsEmpty() && IsImageSet())
	{
		CheckRectangle(rectButtonTemp, m_rectImage, bButtonLeftOfIcon);
	}

	if (!m_strBtnText.IsEmpty())
	{
		AdjustRectToMargin(rectButtonTemp, rectClient, m_nMargin);

		if (m_rectButton.Width() + m_rectImage.Width() + 2 * m_nMargin > rectClient.Width())
		{
			m_rectButton.SetRectEmpty();
		}
	}

	if (!m_strText.IsEmpty())
	{
		CheckRectangle(m_rectDrawText, m_rectImage, bTextLeftOfIcon);
		CheckRectangle(m_rectDrawText, rectButtonTemp, bTextLeftOfButton || bButtonAfterText);
	}

	if (pOldFont != NULL)
	{
		dc.SelectObject(pOldFont);
	}

	m_bTextIsTruncated = m_rectDrawText.Width() < sizeText.cx;

	UpdateTooltips();
}

BOOL CMFCCaptionBar::CheckRectangle(CRect& rectSrc, const CRect& rectOther, BOOL bLeftOf)
{
	if (rectSrc.IsRectEmpty() || rectOther.IsRectEmpty())
	{
		return FALSE;
	}

	CRect rectOtherWithOffset = rectOther;
	rectOtherWithOffset.InflateRect(m_nHorzElementOffset, m_nHorzElementOffset);

	if (rectSrc.left <= rectOtherWithOffset.right && rectSrc.left >= rectOtherWithOffset.left)
	{
		rectSrc.left = rectOtherWithOffset.right;
	}

	if (rectSrc.right >= rectOtherWithOffset.left && rectSrc.right <= rectOtherWithOffset.right)
	{
		rectSrc.right = rectOtherWithOffset.left;
	}

	if (rectSrc.left >= rectOtherWithOffset.left && rectSrc.right <= rectOtherWithOffset.right)
	{
		rectSrc.right = rectSrc.left;
	}

	if (rectSrc.left <= rectOtherWithOffset.left && rectSrc.right >= rectOtherWithOffset.right)
	{
		if (bLeftOf)
		{
			rectSrc.right = rectOtherWithOffset.left;
		}
		else
		{
			rectSrc.left = rectOtherWithOffset.right;
		}
	}

	if (bLeftOf && rectSrc.left >= rectOtherWithOffset.right || !bLeftOf && rectSrc.right <= rectOtherWithOffset.left)
	{
		rectSrc.left = rectSrc.right;
	}

	return FALSE;
}

void CMFCCaptionBar::AdjustRectToMargin(CRect& rectSrc, const CRect& rectClient, int nMargin, BOOL bRetainSize)
{
	BOOL bLeftChanged = FALSE;
	BOOL bRightChanged = FALSE;
	int nWidth = rectSrc.Width();
	if (rectSrc.left < rectClient.left + nMargin)
	{
		rectSrc.left = rectClient.left + nMargin;
		bLeftChanged = TRUE;
	}

	if (rectSrc.right > rectClient.right - nMargin)
	{
		rectSrc.right = rectClient.right - nMargin;
		bRightChanged = TRUE;
	}

	if (bRetainSize)
	{
		if (bLeftChanged)
		{
			rectSrc.right = rectSrc.left + nWidth;
		}
		else if (bRightChanged)
		{
			rectSrc.left = 	rectSrc.right - nWidth;
		}
	}
}

CSize CMFCCaptionBar::GetImageSize() const
{
	if (m_Bitmap.GetCount() > 0)
	{
		ENSURE(m_hIcon == NULL);
		return m_Bitmap.GetImageSize();
	}

	if (m_hIcon == NULL)
	{
		return CSize(0, 0);
	}

	ICONINFO info;
	memset(&info, 0, sizeof(ICONINFO));

	::GetIconInfo(m_hIcon, &info);
	HBITMAP hBmp = info.hbmColor;

	BITMAP bmp;
	::GetObject(hBmp, sizeof(BITMAP), (LPVOID) &bmp);

	::DeleteObject(info.hbmColor);
	::DeleteObject(info.hbmMask);

	return CSize(bmp.bmWidth, bmp.bmHeight);
}

BOOL CMFCCaptionBar::OnEraseBkgnd(CDC* /*pDC*/)
{
	return TRUE;
}

void CMFCCaptionBar::OnLButtonDown(UINT nFlags, CPoint point)
{
	CPane::OnLButtonDown(nFlags, point);

	if (m_uiBtnID != 0 && m_bBtnEnabled && m_bIsBtnHighlighted)
	{
		m_bIsBtnPressed = TRUE;
		InvalidateRect(m_rectButton);
		UpdateWindow();

		if (m_bBtnHasDropDownArrow)
		{
			ASSERT_VALID(GetOwner());
			GetOwner()->SendMessage(WM_COMMAND, m_uiBtnID);
		}
	}

	if (m_bIsCloseBtnHighlighted)
	{
		m_bIsCloseBtnPressed= TRUE;
		InvalidateRect(m_rectClose);
		UpdateWindow();
	}
}

void CMFCCaptionBar::OnLButtonUp(UINT nFlags, CPoint point)
{
	CPane::OnLButtonUp(nFlags, point);

	if (m_bIsBtnPressed)
	{
		m_bIsBtnPressed = FALSE;
		InvalidateRect(m_rectButton);
		UpdateWindow();

		if (!m_bBtnHasDropDownArrow && m_uiBtnID != 0)
		{
			ASSERT_VALID(GetOwner());
			GetOwner()->SendMessage(WM_COMMAND, m_uiBtnID);
		}
	}
	else if (m_bIsCloseBtnPressed)
	{
		m_bIsCloseBtnPressed = FALSE;

		InvalidateRect(m_rectClose);
		UpdateWindow();

		ShowPane(FALSE, FALSE, FALSE);
	}
}

void CMFCCaptionBar::OnMouseMove(UINT nFlags, CPoint point)
{
	CPane::OnMouseMove(nFlags, point);

	BOOL bTrack = FALSE;

	if (m_uiBtnID != 0 && m_bBtnEnabled)
	{
		BOOL bIsBtnHighlighted = m_rectButton.PtInRect(point);

		if (m_bIsBtnHighlighted != bIsBtnHighlighted)
		{
			m_bIsBtnHighlighted = bIsBtnHighlighted;
			m_bIsBtnPressed = (nFlags & MK_LBUTTON) && m_bIsBtnHighlighted;

			InvalidateRect(m_rectButton);
			UpdateWindow();

			bTrack = bIsBtnHighlighted;
		}
	}

	if (!m_rectClose.IsRectEmpty())
	{
		BOOL bIsBtnHighlighted = m_rectClose.PtInRect(point);

		if (m_bIsCloseBtnHighlighted != bIsBtnHighlighted)
		{
			m_bIsCloseBtnHighlighted = bIsBtnHighlighted;
			m_bIsCloseBtnPressed = (nFlags & MK_LBUTTON) && m_bIsCloseBtnHighlighted;

			InvalidateRect(m_rectClose);
			UpdateWindow();

			bTrack = bIsBtnHighlighted;
		}
	}

	if (!m_bTracked)
	{
		m_bTracked = TRUE;

		TRACKMOUSEEVENT trackmouseevent;
		trackmouseevent.cbSize = sizeof(trackmouseevent);
		trackmouseevent.dwFlags = TME_LEAVE;
		trackmouseevent.hwndTrack = GetSafeHwnd();
		trackmouseevent.dwHoverTime = HOVER_DEFAULT;
		::AFXTrackMouse(&trackmouseevent);
	}
}

afx_msg LRESULT CMFCCaptionBar::OnMouseLeave(WPARAM,LPARAM)
{
	m_bTracked = FALSE;

	if (m_bIsBtnPressed || m_bIsBtnHighlighted)
	{
		m_bIsBtnPressed = FALSE;
		m_bIsBtnHighlighted = FALSE;

		InvalidateRect(m_rectButton);
		UpdateWindow();
	}

	if (m_bIsCloseBtnPressed || m_bIsCloseBtnHighlighted)
	{
		m_bIsCloseBtnPressed = FALSE;
		m_bIsCloseBtnHighlighted = FALSE;

		InvalidateRect(m_rectClose);
		UpdateWindow();
	}

	return 0;
}

void CMFCCaptionBar::AdjustLayout()
{
	if (GetSafeHwnd() == NULL)
	{
		return;
	}

	CFrameWnd* pParent = AFXGetParentFrame(this);
	if (pParent != NULL && pParent->GetSafeHwnd() != NULL)
	{
		pParent->RecalcLayout();
	}

	RecalcLayout();
}

void CMFCCaptionBar::OnRButtonUp(UINT nFlags, CPoint point)
{
	if (!CMFCToolBar::IsCustomizeMode())
	{
		ASSERT_VALID(GetOwner());

		ClientToScreen(&point);
		OnPaneContextMenu(GetOwner(), point);
		return;
	}

	CPane::OnRButtonUp(nFlags, point);
}

void CMFCCaptionBar::OnDestroy()
{
	CTooltipManager::DeleteToolTip(m_pToolTip);
	CPane::OnDestroy();
}

BOOL CMFCCaptionBar::OnNeedTipText(UINT /*id*/, NMHDR* pNMH, LRESULT* /*pResult*/)
{
	static CString strTipText;

	ENSURE(pNMH != NULL);

	if (m_pToolTip->GetSafeHwnd() == NULL || pNMH->hwndFrom != m_pToolTip->GetSafeHwnd())
	{
		return FALSE;
	}

	if (CMFCPopupMenu::GetActiveMenu() != NULL)
	{
		return FALSE;
	}

	LPNMTTDISPINFO pTTDispInfo = (LPNMTTDISPINFO) pNMH;
	ASSERT((pTTDispInfo->uFlags & TTF_IDISHWND) == 0);

	CString strDescr;

	switch (pNMH->idFrom)
	{
	case nIdToolTipClose:
		ENSURE(strTipText.LoadString(IDS_AFXBARRES_CLOSEBAR));
		break;

	case nIdToolTipText:
		strTipText = m_strText;
		strTipText.Remove(_T('\b'));
		break;

	case nIdToolTipImage:
		strTipText = m_strImageToolTip;
		strDescr = m_strImageDescription;
		break;

	case nIdToolTipButton:
		strTipText = m_strButtonToolTip;
		strDescr = m_strButtonDescription;
		break;
	}

	if (strTipText.IsEmpty())
	{
		return TRUE;
	}

	CMFCToolTipCtrl* pToolTip = DYNAMIC_DOWNCAST(CMFCToolTipCtrl, m_pToolTip);

	if (pToolTip != NULL && !strDescr.IsEmpty())
	{
		ASSERT_VALID(pToolTip);
		pToolTip->SetDescription(strDescr);
	}

	pTTDispInfo->lpszText = const_cast<LPTSTR>((LPCTSTR) strTipText);
	return TRUE;
}

BOOL CMFCCaptionBar::PreTranslateMessage(MSG* pMsg)
{
	switch (pMsg->message)
	{
	case WM_KEYDOWN:
	case WM_SYSKEYDOWN:
	case WM_LBUTTONDOWN:
	case WM_RBUTTONDOWN:
	case WM_MBUTTONDOWN:
	case WM_LBUTTONUP:
	case WM_RBUTTONUP:
	case WM_MBUTTONUP:
	case WM_MOUSEMOVE:
		if (m_pToolTip->GetSafeHwnd() != NULL)
		{
			m_pToolTip->RelayEvent(pMsg);
		}
		break;
	}

	return CPane::PreTranslateMessage(pMsg);
}

LRESULT CMFCCaptionBar::OnUpdateToolTips(WPARAM wp, LPARAM)
{
	UINT nTypes = (UINT) wp;

	if (nTypes & AFX_TOOLTIP_TYPE_CAPTIONBAR)
	{
		CTooltipManager::CreateToolTip(m_pToolTip, this, AFX_TOOLTIP_TYPE_CAPTIONBAR);

		CRect rectDummy(0, 0, 0, 0);

		m_pToolTip->SetMaxTipWidth(640);

		m_pToolTip->AddTool(this, LPSTR_TEXTCALLBACK, &rectDummy, nIdToolTipClose);
		m_pToolTip->AddTool(this, LPSTR_TEXTCALLBACK, &rectDummy, nIdToolTipText);
		m_pToolTip->AddTool(this, LPSTR_TEXTCALLBACK, &rectDummy, nIdToolTipImage);
		m